post_cb({"bq_ids": {"n4140": {"so_21825933_21836197_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 3296}, "so_21825933_21836197_16": {"length": 10, "quality": 1.0, "section_id": 3325}, "so_21825933_21836197_17": {"length": 18, "quality": 1.0, "section_id": 3325}, "so_21825933_21836197_14": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_21825933_21836197_10": {"length": 36, "quality": 0.9, "section_id": 3296}, "so_21825933_21836197_7": {"length": 6, "quality": 1.0, "section_id": 3296}, "so_21825933_21836197_11": {"length": 29, "quality": 0.9666666666666667, "section_id": 3296}, "so_21825933_21836197_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 3296}, "so_21825933_21836197_21": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_21825933_21836197_8": {"length": 41, "quality": 0.9111111111111111, "section_id": 3296}, "so_21825933_21836197_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 3296}, "so_21825933_21836197_6": {"length": 5, "quality": 1.0, "section_id": 3296}, "so_21825933_21836197_15": {"length": 4, "quality": 0.8, "section_id": 3325}, "so_21825933_21836197_0": {"length": 20, "quality": 0.6896551724137931, "section_id": 599}, "so_21825933_21836197_19": {"length": 25, "quality": 1.0, "section_id": 3325}, "so_21825933_21836197_20": {"length": 27, "quality": 0.9, "section_id": 3325}, "so_21825933_21836197_18": {"length": 21, "quality": 0.875, "section_id": 3325}, "so_21825933_21836197_9": {"length": 81, "quality": 0.9204545454545454, "section_id": 3296}}, "n3337": {"so_21825933_21836197_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 3166}, "so_21825933_21836197_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 3166}, "so_21825933_21836197_16": {"length": 9, "quality": 0.9, "section_id": 3195}, "so_21825933_21836197_17": {"length": 17, "quality": 0.9444444444444444, "section_id": 3195}, "so_21825933_21836197_10": {"length": 36, "quality": 0.9, "section_id": 3166}, "so_21825933_21836197_7": {"length": 6, "quality": 1.0, "section_id": 3166}, "so_21825933_21836197_0": {"length": 20, "quality": 0.6896551724137931, "section_id": 589}, "so_21825933_21836197_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 3166}, "so_21825933_21836197_21": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_21825933_21836197_8": {"length": 41, "quality": 0.9111111111111111, "section_id": 3166}, "so_21825933_21836197_14": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_21825933_21836197_6": {"length": 5, "quality": 1.0, "section_id": 3166}, "so_21825933_21836197_15": {"length": 4, "quality": 0.8, "section_id": 3195}, "so_21825933_21836197_19": {"length": 19, "quality": 0.76, "section_id": 3195}, "so_21825933_21836197_11": {"length": 29, "quality": 0.9666666666666667, "section_id": 3166}, "so_21825933_21836197_20": {"length": 21, "quality": 0.7, "section_id": 3195}, "so_21825933_21836197_18": {"length": 21, "quality": 0.875, "section_id": 3195}, "so_21825933_21836197_9": {"length": 81, "quality": 0.9204545454545454, "section_id": 3166}}, "n4659": {"so_21825933_21836197_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 4058}, "so_21825933_21836197_16": {"length": 10, "quality": 1.0, "section_id": 4091}, "so_21825933_21836197_17": {"length": 10, "quality": 0.5555555555555556, "section_id": 4058}, "so_21825933_21836197_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 4058}, "so_21825933_21836197_7": {"length": 6, "quality": 1.0, "section_id": 4058}, "so_21825933_21836197_0": {"length": 20, "quality": 0.6896551724137931, "section_id": 622}, "so_21825933_21836197_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 4058}, "so_21825933_21836197_21": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_21825933_21836197_8": {"length": 41, "quality": 0.9111111111111111, "section_id": 4058}, "so_21825933_21836197_14": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_21825933_21836197_6": {"length": 5, "quality": 1.0, "section_id": 4058}, "so_21825933_21836197_20": {"length": 21, "quality": 0.7, "section_id": 4091}, "so_21825933_21836197_10": {"length": 36, "quality": 0.9, "section_id": 4058}, "so_21825933_21836197_19": {"length": 25, "quality": 1.0, "section_id": 4091}, "so_21825933_21836197_11": {"length": 29, "quality": 0.9666666666666667, "section_id": 4058}, "so_21825933_21836197_15": {"length": 4, "quality": 0.8, "section_id": 4091}, "so_21825933_21836197_18": {"length": 21, "quality": 0.875, "section_id": 4091}, "so_21825933_21836197_9": {"length": 60, "quality": 0.6818181818181818, "section_id": 4058}}}, "21827109": {"Id": "21827109", "PostTypeId": "2", "Body": "<p>Copy-initialization always considers availability of copy constructors, while copy-list-initialization doesn't.</p>\n<pre><code>class B {};\nstruct A \n{\n  A(B const&amp;) {}\n  A(A const&amp;) = delete;\n};\n\nB b;\nA a1 = {b};  // this compiles\nA a2 = b;    // this doesn't because of deleted copy-ctor\n</code></pre>\n<p>This is because copy-list-initialization is identical to direct-list-initialization except in one situation - had <code>A(B const&amp;)</code> been <code>explicit</code>, the former would've failed, while the latter will work. </p>\n<pre><code>class B {};\nstruct A \n{\n  explicit A(B const&amp;) {}\n};\n\n\nint main()\n{\n    B b;\n    A a1{b};    // compiles\n    A a2 = {b}; // doesn't compile because ctor is explicit\n}\n</code></pre>\n", "LastActivityDate": "2014-02-17T10:53:59.603", "CommentCount": "16", "CreationDate": "2014-02-17T10:53:59.603", "ParentId": "21825933", "Score": "5", "OwnerUserId": "241631"}, "21836197": {"Id": "21836197", "PostTypeId": "2", "Body": "<p>Probably, the behaviour of the new copy-list-initialization was defined to be \"good\" and consistent, but the \"weird\" behaviour of old copy-initialization couldn't be changed because of backward compatibility.<br>\nAs you can see the rules for list-initialization in this clause are identical for direct and copy forms.<br>\nThe difference related to <code>explicit</code> is described only in the chapter on overload resolution. But for traditional initialization direct and copy forms are not identical.<br>\nThe traditional and brace initializations are defined separately, so there's always a potential for some (probably unintended) subtle differences.</br></br></br></p>\n<p>The differences I can see from the excerpts of the standard:</p>\n<h3>1. Already mentioned differences</h3>\n<ul>\n<li>narrowing conversions are disallowed  </li>\n<li>multiple arguments are possible  </li>\n<li><p>braced syntax prefers initializer-list constructors if they present: </p>\n<pre><code>struct A\n{\n    A(int i_) : i (i_) {}\n    A(std::initializer_list&lt;int&gt; il) : i (*il.begin() + 1) {}\n    int i;\n}\n\nA a1 = 5; // a1.i == 5\nA a2 = {5}; // a2.i = 6\n</code></pre>\n<p><br/></p></li>\n</ul>\n<h3>2. Different behaviour for aggregates</h3>\n<p>For aggregates you can't use braced copy-constructor, but can use traditional one.  </p>\n<pre><code>    struct Aggr\n    {\n        int i;\n    };\n\n    Aggr aggr;\n    Aggr aggr1 = aggr; // OK\n    Aggr aggr2 = {aggr}; // ill-formed\n</code></pre>\n<p><br/></p>\n<h3>3. Different behaviour for reference initialization in presence of conversion operator</h3>\n<p>Brace initialization can't use operators of conversion to reference type  </p>\n<pre><code>struct S\n{\n    operator int&amp;() { return some_global_int;}\n};\n\nint&amp; iref1 = s; // OK\nint&amp; iref2 = {s}; // ill-formed\n</code></pre>\n<p><br/></p>\n<h3>4. Some subtle differences in initialization of object of class type by object of other type</h3>\n<p>These difference are marked by [*] in the excerpts of the Standard at the end of this answer.</p>\n<ul>\n<li>Old initialization uses notion of user-defined conversion sequences (and, particularly, requires availability of copy constructor, as was mentioned)  </li>\n<li>Brace initialization just performs overload resolution among applicable constructors, i.e. brace initialization can't use operators of conversion to class type  </li>\n</ul>\n<p>These differences are responsible for some not very obvious (for me) cases like  </p>\n<pre><code>struct Intermediate {};\n\nstruct S\n{\n    operator Intermediate() { return {}; }\n    operator int() { return 10; }\n};\n\nstruct S1\n{\n    S1(Intermediate) {}\n};\n\nS s;\nIntermediate im1 = s; // OK\nIntermediate im2 = {s}; // ill-formed\nS1 s11 = s; // ill-formed\nS1 s12 = {s}; // OK\n\n// note: but brace initialization can use operator of conversion to int\nint i1 = s; // OK\nint i2 = {s}; // OK\n</code></pre>\n<p><br/></p>\n<h3>5. Difference in overload resolution</h3>\n<ul>\n<li>Different treatment of explicit constructors</li>\n</ul>\n<p>See <em>13.3.1.7 Initialization by list-initialization</em></p>\n<blockquote>\n<p id=\"so_21825933_21836197_0\">In copy-list-initialization, if an <code>explicit</code> constructor is chosen, the\n  initialization is ill-formed. [ <em>Note:</em> This differs from other\n  situations (13.3.1.3, 13.3.1.4), where only converting constructors\n  are considered for copy initialization. This restriction only applies\n  if this initialization is part of the final result of overload\n  resolution. <em>\u2014 end note</em> ]</p>\n</blockquote>\n<p>If you can see more differences or somehow correct my answer (including grammar mistakes), please do.</p>\n<hr>\n<p>Here are the relevant (but long) excerpts from the <a href=\"http://isocpp.org/files/papers/N3797.pdf\">current draft of the C++ standard</a> (I haven't found a way to hide them under spoiler):<br>\nAll of them are located in the chapter 8.5 Initializers</br></p>\n<blockquote>\n<p id=\"so_21825933_21836197_1\">8.5 Initializers</p>\n<ul>\n<li><p id=\"so_21825933_21836197_2\">If the initializer is a (non-parenthesized) <em>braced-init-list</em>, the\n  object or reference is list-initialized (8.5.4).</p></li>\n<li><p id=\"so_21825933_21836197_3\">If the destination type is a reference type, see 8.5.3.  </p></li>\n<li><p id=\"so_21825933_21836197_4\">If the destination type is an array of characters, an array of <code>char16_t</code>, an\n  array of <code>char32_t</code>, or an array of <code>wchar_t</code>, and the initializer is a\n  string literal, see 8.5.2.  </p></li>\n<li><p id=\"so_21825933_21836197_5\">If the initializer is <code>()</code>, the object is\n  value-initialized.</p></li>\n<li><p id=\"so_21825933_21836197_6\">Otherwise, if the destination type is an array,\n  the program is ill-formed.  </p></li>\n<li><p id=\"so_21825933_21836197_7\">If the destination type is a (possibly\n  cv-qualified) class type:   </p>\n<ul>\n<li><p id=\"so_21825933_21836197_8\">If the initialization is\n  direct-initialization, or if it is copy-initialization where the\n  cv-unqualified version of the source type is the same class as, or a\n  derived class of, the class of the destination, constructors are\n  considered. The applicable constructors are enumerated (13.3.1.3), and\n  the best one is chosen through overload resolution (13.3). The\n  constructor so selected is called to initialize the object, with the\n  initializer expression or <em>expression-list</em> as its argument(s). If no\n  constructor applies, or the overload resolution is ambiguous, the\n  initialization is ill-formed.   </p></li>\n<li><p id=\"so_21825933_21836197_9\"><strong>[*]</strong> Otherwise (i.e., for the\n  remaining copy-initialization cases), user-defined conversion\n  sequences that can convert from the source type to the destination\n  type or (when a conversion function is used) to a derived class\n  thereof are enumerated as described in 13.3.1.4, and the best one is\n  chosen through overload resolution (13.3). If the conversion cannot be\n  done or is ambiguous, the initialization is ill-formed. The function\n  selected is called with the initializer expression as its argument; if\n  the function is a constructor, the call initializes a temporary of the\n  cv-unqualified version of the destination type. The temporary is a\n  prvalue. The result of the call (which is the temporary for the\n  constructor case) is then used to direct-initialize, according to the\n  rules above, the object that is the destination of the\n  copy-initialization. In certain cases, an implementation is permitted\n  to eliminate the copying inherent in this direct-initialization by\n  constructing the intermediate result directly into the object being\n  initialized; see 12.2, 12.8.   </p></li>\n<li><p id=\"so_21825933_21836197_10\">Otherwise, if the source type is a\n  (possibly cv-qualified) class type, conversion functions are\n  considered. The applicable conversion functions are enumerated\n  (13.3.1.5), and the best one is chosen through overload resolution\n  (13.3). The user-defined conversion so selected is called to convert\n  the initializer expression into the object being initialized. If the\n  conversion cannot be done or is ambiguous, the initialization is\n  ill-formed.   </p></li>\n</ul></li>\n<li><p id=\"so_21825933_21836197_11\">Otherwise, the initial value of the object being\n  initialized is the (possibly converted) value of the initializer\n  expression. Standard conversions (Clause 4) will be used, if\n  necessary, to convert the initializer expression to the cv-unqualified\n  version of the destination type; no user-defined conversions are\n  considered. If the conversion cannot be done, the initialization is\n  ill-formed.</p></li>\n</ul>\n<hr>\n<p id=\"so_21825933_21836197_12\">8.5.3 References ...</p>\n<hr>\n<p id=\"so_21825933_21836197_13\">8.5.4 List-initialization</p>\n<p id=\"so_21825933_21836197_14\">List-initialization of an object or reference of type T is defined as\n  follows:   </p>\n<ul>\n<li><p id=\"so_21825933_21836197_15\">If <code>T</code> is an aggregate, aggregate initialization is\n  performed (8.5.1).   </p></li>\n<li><p id=\"so_21825933_21836197_16\">Otherwise, if the initializer list has no\n  elements and <code>T</code> is a class type with a default constructor, the object\n  is value-initialized.   </p></li>\n<li><p id=\"so_21825933_21836197_17\">Otherwise, if <code>T</code> is a specialization of\n  <code>std::initializer_list&lt;E&gt;</code>, a prvalue <code>initializer_list</code> object is\n  constructed as described below and used to initialize the object\n  according to the rules for initialization of an object from a class of\n  the same type (8.5).  </p></li>\n<li><p id=\"so_21825933_21836197_18\"><strong>[*]</strong> Otherwise, if <code>T</code> is a class type,\n  constructors are considered. The applicable constructors are\n  enumerated and the best one is chosen through overload resolution\n  (13.3, 13.3.1.7). If a narrowing conversion (see below) is required to\n  convert any of the arguments, the program is ill-formed.   </p></li>\n<li><p id=\"so_21825933_21836197_19\">Otherwise, if the initializer list has a single element of type <code>E</code> and\n  either <code>T</code> is not a reference type or its referenced type is\n  reference-related to <code>E</code>, the object or reference is initialized from\n  that element; if a narrowing conversion (see below) is required to\n  convert the element to <code>T</code>, the program is ill-formed.   </p></li>\n<li><p id=\"so_21825933_21836197_20\">Otherwise, if\n  <code>T</code> is a reference type, a prvalue temporary of the type referenced by <code>T</code>\n  is copy-list-initialized or direct-list-initialized, depending on the\n  kind of initialization for the reference, and the reference is bound\n  to that temporary. [ <em>Note:</em> As usual, the binding will fail and the\n  program is ill-formed if the reference type is an lvalue reference to\n  a non-const type. <em>\u2014\u00a0end note</em>\u00a0]   </p></li>\n<li><p id=\"so_21825933_21836197_21\">Otherwise, if the initializer list\n  has no elements, the object is value-initialized.   </p></li>\n<li><p id=\"so_21825933_21836197_22\">Otherwise, the program is ill-formed.</p></li>\n</ul>\n<hr>\n</hr></hr></hr></blockquote>\n</hr>", "LastEditorUserId": "2665887", "LastActivityDate": "2014-02-18T01:08:49.253", "Score": "9", "CreationDate": "2014-02-17T18:03:08.630", "ParentId": "21825933", "CommentCount": "2", "OwnerUserId": "2665887", "LastEditDate": "2014-02-18T01:08:49.253"}, "21825933": {"ViewCount": "1314", "Body": "<p>Except for supporting multiple arguments, disallowing narrowing conversion, matching constructor taking std::initializer_list argument, what else is different for copy-list-initialization against traditional copy-initialization?</p>\n<p>To be specific, assume there are two user-defined types, <code>A</code> and <code>B</code>:</p>\n<pre><code>class A {...};\nclass B {...};\n\nB b;\nA a1 = {b};\nA a2 = b;\n</code></pre>\n<p>What kind of definition of <code>A</code> and <code>B</code> will make a difference on those two forms of initialization?  e.g. Is there a certain definition of <code>A</code> and <code>B</code> that will make one of the initialization legal but the other illegal, or both legal but with different semantics, or both illegal with different causes?</p>\n<p>(Assume <code>A</code> doesn't have a constructor taking std::initializer_list argument.)</p>\n<p>EDIT: Adding a link to a somewhat related question of mine: <a href=\"https://stackoverflow.com/questions/21829678/what-is-the-supposed-behavior-of-copy-list-initialization-in-the-case-of-an-init\">What is the supposed behavior of copy-list-initialization in the case of an initializer with a conversion operator?</a></p>\n", "Title": "Any difference between copy-list-initialization and traditional copy-initialization?", "CreationDate": "2014-02-17T10:02:41.827", "LastActivityDate": "2014-02-18T01:53:32.373", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:53:13.660", "LastEditorUserId": "-1", "Id": "21825933", "Score": "10", "OwnerUserId": "3237645", "Tags": "<c++><c++11>", "AnswerCount": "2"}});