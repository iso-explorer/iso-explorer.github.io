post_cb({"33812887": {"ParentId": "33812659", "LastEditDate": "2015-11-20T14:15:10.447", "CommentCount": "9", "CreationDate": "2015-11-19T19:38:16.190", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "PostTypeId": "2", "Id": "33812887", "Score": "3", "Body": "<p>Since you are <a href=\"http://en.cppreference.com/w/cpp/language/definition#ODR-use\" rel=\"nofollow\">odr-using</a> <code>i</code> by taking its address it has to be defined outside the class:</p>\n<pre><code>const int X::i ;\n</code></pre>\n<p>Violations of this rule fall into the <em>no diagnostic required</em> category, so this is completely valid behavior:</p>\n<blockquote>\n<p id=\"so_33812659_33812887_0\">Informally, an object is odr-used if its address is taken, or a\n  reference is bound to it, and a function is odr-used if a function\n  call to it is made or its address is taken. If an object or a function\n  is odr-used, its definition must exist somewhere in the program; a\n  violation of that is a link-time error.</p>\n</blockquote>\n<p>This can depend on the compiler, the optimizations level etc...</p>\n<p>Draft C++ standard  section <code>3.2</code> [basic.def.odr] says:</p>\n<blockquote>\n<p id=\"so_33812659_33812887_1\">Every program shall contain exactly one definition of every non-inline\n  function or variable that is odr-used in that program; no diagnostic\n  required</p>\n</blockquote>\n<p>Some notes:</p>\n<ul>\n<li>Catching odr violations in general is a <a href=\"http://hubicka.blogspot.com/search/label/devirtualization\" rel=\"nofollow\">hard problem</a>.</li>\n<li>In this case, catching it is not as simple as it looks since <code>i</code> could be defined later on or in another translation unit.</li>\n<li>We want out of line definitions since we only want one definition, while the declarations can be repeated i.e. if they are part of a header file.</li>\n</ul>\n", "LastActivityDate": "2015-11-20T14:15:10.447"}, "33812659": {"CommentCount": "8", "ViewCount": "92", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-11-19T19:25:08.883", "LastActivityDate": "2015-11-20T14:15:10.447", "Title": "Basic fun with static const integral members", "AcceptedAnswerId": "33812887", "LastEditDate": "2015-11-20T03:59:35.240", "Id": "33812659", "Score": "2", "Body": "<p>Consider following code:</p>\n<pre><code>struct X {\n  static const int i = 45;\n};\n\nvoid foo() {\n  const int* k = &amp;X::i;\n}\n\nint main() {\n}\n</code></pre>\n<p>Without opening your favorite compiler, what would you think would be the result of an attempt on compiling and linking this simple beast? </p>\n<p>Some might be surprised that it is going to depend not only on the compiler, but on its optimization options! For instance, on gcc the code will refuse to link with optimization turned off, but will gladly link (and produce runnable-doing-nothing executable) with any optimization turned on.</p>\n<p>The diagnostics in the failure case would be funny - symbol <code>X::i</code> would not be found. Optimization-enabled links will succeed, because <code>X::i</code> will be thrown away.</p>\n<p>And question. Is it correct behaviour of the compiler to <em>compile</em> this code? Since <code>X::i</code> does not have a linkage, should not compiler complain when asked to produce a code which asks for a linkage on this symbol?</p>\n", "Tags": "<c++><compiler-errors><language-lawyer><one-definition-rule>", "OwnerUserId": "5245033", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33812659_33812887_1": {"section_id": 7041, "quality": 1.0, "length": 12}}, "n3337": {"so_33812659_33812887_1": {"section_id": 6786, "quality": 1.0, "length": 12}}, "n4659": {"so_33812659_33812887_1": {"section_id": 8538, "quality": 1.0, "length": 12}}}});