post_cb({"34899232": {"Id": "34899232", "PostTypeId": "2", "Body": "<p>This was an addendum to the standard to address an issue with the discarding of cv-qualifiers through indirect reference binding of a class with user-defined conversions.</p>\n<p>The pertinent defect is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1571\" rel=\"nofollow\">1571</a>.</p>\n<p>The example given was this:</p>\n<pre><code>class A {\npublic:\n  operator volatile int &amp;();\n};\nA a;\n\nconst int &amp; ir1a = a.operator volatile int&amp;(); // error!\nconst int &amp; ir2a = a; // allowed! ir = a.operator volatile int&amp;();\n</code></pre>\n<p>The first reference initialization is invalid, as it discards cv-qualifiers from the initializer expression. However, under the old rules, the second was valid, as only the cv-qualifiers on the converted object were considered, not those of the reference returned by the conversion operator.</p>\n<p>I think your confusion arises from the two possible conversions. User-defined conversions are considered to see if they could copy-initialize a non-reference of <code>cv1 T1</code>, then the result of that conversion is used to direct-initialize the reference, for which user-defined conversions are not considered.</p>\n", "Score": "2", "LastActivityDate": "2016-01-20T11:48:19.797", "CreationDate": "2016-01-20T11:48:19.797", "ParentId": "34898678", "CommentCount": "8", "OwnerUserId": "496161"}, "bq_ids": {"n4140": {"so_34898678_34898678_0": {"length": 30, "quality": 0.8333333333333334, "section_id": 3321}}, "n4659": {"so_34898678_34898678_0": {"length": 32, "quality": 0.8888888888888888, "section_id": 4087}}}, "34898678": {"ViewCount": "92", "Body": "<p>\u00a78.5.3[dcl.init.ref]/5 bullet point (5.2.2.1):</p>\n<p>Emphases are mine</p>\n<blockquote>\n<p id=\"so_34898678_34898678_0\">If T1 or T2 is a class type and T1 is not reference-related to T2,\n  <strong>user-defined conversions are considered</strong> using the rules for copy-initialization of an object of type \u201ccv1 T1\u201d by userdefined\n  conversion (8.5, 13.3.1.4, 13.3.1.5); the program is ill-formed if the\n  corresponding non-reference copy-initialization would be ill-formed.\n  The result of the call to the conversion function, as described for\n  the non-reference copy-initialization, is then used to\n  direct-initialize the reference. For this direct-initialization,\n  <strong>user-defined conversions are not considered</strong>.</p>\n</blockquote>\n", "AcceptedAnswerId": "34899232", "Title": "What does the Standard mean by \"user-defined conversions are not considered\", in bullet point (5.2.2.1) in paragraph \u00a78.5.3/5 of the latest draft?", "CreationDate": "2016-01-20T11:23:11.247", "Id": "34898678", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-01-20T11:48:19.797", "Score": "1", "OwnerUserId": "1042389", "Tags": "<c++><reference><language-lawyer><c++1z>", "AnswerCount": "1"}});