post_cb({"bq_ids": {"n4140": {"so_20015309_20015438_0": {"length": 9, "quality": 0.9, "section_id": 6018}}, "n3337": {"so_20015309_20015438_0": {"length": 9, "quality": 0.9, "section_id": 5786}}, "n4659": {"so_20015309_20015438_0": {"length": 9, "quality": 0.9, "section_id": 7517}}}, "20015438": {"Id": "20015438", "PostTypeId": "2", "Body": "<p><code>dynamic_cast&lt;T&gt;(v)</code> may go down to the most derived object of which <code>v</code> is a sub-object, then up (possibly a different branch) to find an unambiguous base class to which <code>T</code> is a pointer or a reference. From the standard:</p>\n<blockquote>\n<p id=\"so_20015309_20015438_0\"><strong>5.2.7/8</strong> If <code>C</code> is the class type to which <code>T</code> points or refers, the run-time check logically executes as follows:</p>\n<ul>\n<li>If, in the most derived object pointed (referred) to by <code>v</code>, <code>v</code> points (refers) to a public base class subobject of a <code>C</code> object, and\n  if only one object of type <code>C</code> is derived from the subobject pointed\n  (referred) to by <code>v</code> the result points (refers) to that <code>C</code> object.</li>\n<li>Otherwise, if <code>v</code> points (refers) to a public base class subobject of the most derived object, and the type of the most derived object\n  has a base class, of type <code>C</code>, that is unambiguous and public, the\n  result points (refers) to the <code>C</code> subobject of the most derived\n  object.</li>\n<li>Otherwise, the run-time check <em>fails.</em></li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2013-11-16T06:18:11.533", "CommentCount": "0", "CreationDate": "2013-11-16T06:18:11.533", "ParentId": "20015309", "Score": "6", "OwnerUserId": "1670129"}, "20015309": {"ViewCount": "279", "Body": "<p><strong>CODE</strong></p>\n<pre><code>struct A { };           // virtual details there, but left out\nstruct B { };           // virtual details there, but left out\nstruct C : A, B { };    // virtual details there, but left out\n\nC c;\nB&amp; b = c;\nA&amp; a = dynamic_cast&lt;A&amp;&gt;( b );  // will this cast succeed at run-time?\n</code></pre>\n<p>Note that I have left out the virtual details to keep the code simple.</p>\n<p>If dynamic_cast&lt;&gt; is limited to direct casts along the inheritance hierarchy, then I expect the code above to fail at run-time (because B&amp; is unrelated to A&amp;).</p>\n<p>However, if it is more generic/flexible, the code should work, because the true-type of the referred to object is of C type (and C can be referred to as B&amp; or A&amp;).</p>\n<p><em>What do the C++ specifications say about this case?</em></p>\n", "AcceptedAnswerId": "20015377", "Title": "Is a dynamic_cast<> limited to direct casts along the inheritance hierarchy?", "CreationDate": "2013-11-16T05:57:43.517", "Id": "20015309", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-11-16T06:21:55.330", "Score": "3", "OwnerUserId": "975129", "Tags": "<c++><c++11><casting>", "AnswerCount": "2"}, "20015377": {"Id": "20015377", "PostTypeId": "2", "Body": "<p>Right now, the code won't compile because none of the classes has any virtual functions -- a requirement to use <code>dynamic_cast</code>. If you add at least one virtual function (e.g., a virtual dtor to <code>B</code>, then yes, since a <code>C</code> is derived publicly from <code>B</code>, the cast will succeed.</p>\n<p>Here's a bit of quick demo code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {\n    virtual void junk() { std::cout &lt;&lt; \"A\"; }\n    void trash() { std::cout &lt;&lt; \"A\"; }\n    virtual ~A() {}\n};\n\nstruct B { \n    virtual ~B(){} \n    void trash() { std::cout &lt;&lt; \"B\"; }\n    void junk() { std::cout &lt;&lt; \"B\"; }\n};\n\nstruct C : virtual A, virtual B { \n    void trash()  { std::cout &lt;&lt; \"C\"; }\n    void junk() { std::cout &lt;&lt; \"C\"; }\n};    \n\nint main() {\n    C c;\n    B&amp; b = c;\n    A&amp; a = dynamic_cast&lt;A&amp;&gt;(b); \n    a.trash();\n    std::cout &lt;&lt; \"\\n\";\n    a.junk();\n}\n</code></pre>\n<p>The output (with both VC++ and g++, and this isn't cutting edge, so I'd expect anything but a truly ancient compiler to get it right) is:</p>\n<pre><code>A\nC\n</code></pre>\n<p>Showing that the <code>a</code> has a static type of <code>A</code>, but a dynamic type of <code>C</code>.</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2013-11-16T06:21:55.330", "Score": "3", "CreationDate": "2013-11-16T06:06:53.903", "ParentId": "20015309", "CommentCount": "2", "OwnerUserId": "179910", "LastEditDate": "2013-11-16T06:21:55.330"}});