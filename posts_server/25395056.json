post_cb({"bq_ids": {"n4140": {"so_25395056_26110725_2": {"length": 31, "quality": 0.8611111111111112, "section_id": 603}, "so_25395056_26110725_3": {"length": 18, "quality": 0.9, "section_id": 603}, "so_25395056_25395056_1": {"length": 23, "quality": 0.92, "section_id": 3296}, "so_25395056_26110725_5": {"length": 25, "quality": 0.9259259259259259, "section_id": 603}, "so_25395056_25395056_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 603}, "so_25395056_26110725_7": {"length": 57, "quality": 0.8769230769230769, "section_id": 615}, "so_25395056_26110725_6": {"length": 30, "quality": 0.9090909090909091, "section_id": 621}, "so_25395056_25395056_0": {"length": 58, "quality": 0.9666666666666667, "section_id": 615}}, "n3337": {"so_25395056_26110725_2": {"length": 31, "quality": 0.8611111111111112, "section_id": 593}, "so_25395056_26110725_3": {"length": 18, "quality": 0.9, "section_id": 593}, "so_25395056_25395056_1": {"length": 23, "quality": 0.92, "section_id": 3166}, "so_25395056_26110725_5": {"length": 25, "quality": 0.9259259259259259, "section_id": 593}, "so_25395056_25395056_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 593}, "so_25395056_26110725_7": {"length": 57, "quality": 0.8769230769230769, "section_id": 605}, "so_25395056_26110725_6": {"length": 30, "quality": 0.9090909090909091, "section_id": 611}, "so_25395056_25395056_0": {"length": 58, "quality": 0.9666666666666667, "section_id": 605}}, "n4659": {"so_25395056_26110725_2": {"length": 31, "quality": 0.8611111111111112, "section_id": 629}, "so_25395056_26110725_3": {"length": 18, "quality": 0.9, "section_id": 629}, "so_25395056_25395056_1": {"length": 23, "quality": 0.92, "section_id": 4058}, "so_25395056_26110725_5": {"length": 25, "quality": 0.9259259259259259, "section_id": 629}, "so_25395056_25395056_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 629}, "so_25395056_26110725_7": {"length": 57, "quality": 0.8769230769230769, "section_id": 641}, "so_25395056_26110725_6": {"length": 30, "quality": 0.9090909090909091, "section_id": 647}, "so_25395056_25395056_0": {"length": 58, "quality": 0.9666666666666667, "section_id": 641}}}, "26110725": {"Id": "26110725", "PostTypeId": "2", "Body": "<p>When deciding the best user-defined conversion for a user-defined conversion sequence we have an overload candidate set.</p>\n<p>\u00a713.3.3/p1 says:</p>\n<blockquote>\n<p id=\"so_25395056_26110725_0\">Define ICSi(F) as follows:</p>\n<ul>\n<li><p id=\"so_25395056_26110725_1\">[...]</p></li>\n<li><p id=\"so_25395056_26110725_2\">let ICSi(F) denote the implicit conversion sequence that converts the i-th argument in the list to the\n  type of the i-th parameter of viable function F. 13.3.3.1 defines the implicit conversion sequences and\n  13.3.3.2 defines what it means for one implicit conversion sequence to be a better conversion sequence\n  or worse conversion sequence than another.</p></li>\n</ul>\n<p id=\"so_25395056_26110725_3\">Given these definitions, <strong>a viable function F1 is defined to be a better function than another viable function\n  F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</strong></p>\n<p id=\"so_25395056_26110725_4\">\u2014 [...]</p>\n<p id=\"so_25395056_26110725_5\">\u2014 <strong>the context is an initialization by user-defined conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the\n  standard conversion sequence from the return type of F1 to the destination type (i.e., the type of the\n  entity being initialized) is a better conversion sequence than the standard conversion sequence from\n  the return type of F2 to the destination type.</strong></p>\n</blockquote>\n<p>This applies since</p>\n<p>\u00a713.3.3.1.2/p2</p>\n<blockquote>\n<p id=\"so_25395056_26110725_6\">2 The second standard conversion sequence converts the result of the user-defined conversion to the target \n  type for the sequence. <strong>Since an implicit conversion sequence is an initialization, the special rules for \n  initialization by user-defined conversion apply when selecting the best user-defined conversion for a user-defined \n  conversion sequence (see 13.3.3 and 13.3.3.1).</strong></p>\n</blockquote>\n<p>and therefore the conversion sequence involving <code>operator int</code> is selected as best match.</p>\n<p>Finally I would rephrase \u00a713.3.3.1/p10 as</p>\n<blockquote>\n<p id=\"so_25395056_26110725_7\">If several different sequences of conversions exist that each convert the argument to the parameter type <em>and it was not possible to determine a best candidate,</em>\n  the implicit conversion sequence associated with the parameter is defined to be the unique conversion sequence\n  designated the ambiguous conversion sequence. For the purpose of ranking implicit conversion sequences\n  as described in 13.3.3.2, the ambiguous conversion sequence is treated as a user-defined sequence that is\n  indistinguishable from any other user-defined conversion sequence134. If a function that uses the ambiguous\n  conversion sequence is selected as the best viable function, the call will be ill-formed because the conversion\n  of one of the arguments in the call is ambiguous.</p>\n</blockquote>\n", "LastEditorUserId": "1938163", "LastActivityDate": "2014-09-30T09:20:19.053", "Score": "8", "CreationDate": "2014-09-30T00:01:30.490", "ParentId": "25395056", "CommentCount": "3", "OwnerUserId": "1938163", "LastEditDate": "2014-09-30T09:20:19.053"}, "25395056": {"ViewCount": "584", "Body": "<p>The question arose while I was researching the answer to <a href=\"https://stackoverflow.com/questions/25385464/how-is-the-implicit-type-conversion-priority-determined\">this SO question</a>. Consider the following code:</p>\n<pre><code>struct A{\n    operator char() const{ return 'a'; }\n    operator int() const{ return 10; }\n};\n\nstruct B {\n    void operator&lt;&lt; (int) { }\n};\n\nint main()\n{\n    A a;\n    B b;\n    b &lt;&lt; a;\n}\n</code></pre>\n<p>The conversion of <code>a</code> to <code>int</code> can be either via <code>a.operator char()</code> followed by an integral promotion, or <code>a.operator int()</code> followed by an identity conversion (i.e., no conversion at all). The standard says that (\u00a713.3.3.1 [over.best.ics]/p10, footnote omitted, bolding mine; all quotes are from N3936):</p>\n<blockquote>\n<p id=\"so_25395056_25395056_0\">If several different sequences of conversions exist that each convert\n  the argument to the parameter type, the implicit conversion sequence\n  associated with the parameter is defined to be the unique conversion\n  sequence designated the <em>ambiguous conversion sequence</em>. For the\n  purpose of ranking implicit conversion sequences as described in\n  13.3.3.2, the ambiguous conversion sequence is treated as a user-defined sequence that is indistinguishable from any other\n  user-defined conversion sequence. <strong>If a function that uses the\n  ambiguous conversion sequence is selected as the best viable function,\n  the call will be ill-formed because the conversion of one of the\n  arguments in the call is ambiguous.</strong></p>\n</blockquote>\n<p>Here, <code>B::operator&lt;&lt;(int)</code> is the only viable candidate - and hence is the best viable candidate, even though the conversion sequence for the parameter is the <em>ambiguous conversion sequence</em>. According to the bolded sentence, then, the call should be ill-formed because \"the conversion of one of the arguments in the call is ambiguous\". </p>\n<p>Yet no compiler that I tested (g++, clang, and MSVC) actually reports an error, which makes sense because after the function to call is selected through overload resolution, the function's \"parameter (8.3.5) shall be initialized (8.5, 12.8, 12.1) with its corresponding\nargument\" (\u00a75.2.2 [expr.call]/p4). This initialization is <em>copy-initialization</em> (\u00a78.5 [dcl.init]/p15), and according to \u00a78.5 [dcl.init]/p17, results in a new round of overload resolution to determine the conversion function to use:</p>\n<blockquote>\n<p id=\"so_25395056_25395056_1\">The semantics of initializers are as follows. The <em>destination type</em>\n  is the type of the object or reference being initialized and the\n  <em>source type</em> is the type of the initializer expression. If the initializer is not a single (possibly parenthesized) expression, the\n  source type is not defined.</p>\n<ul>\n<li>[...]</li>\n<li>If the destination type is a (possibly cv-qualified) class type: [...]</li>\n<li>Otherwise, if the source type is a (possibly cv-qualified) class type, conversion functions are considered. The applicable conversion\n  functions are enumerated (13.3.1.5), and the best one is chosen\n  through overload resolution (13.3). The user-defined conversion so\n  selected is called to convert the initializer expression into the\n  object being initialized. If the conversion cannot be done or is\n  ambiguous, the initialization is ill-formed.</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>And in this round of overload resolution, there is a tiebreaker in \u00a713.3.3 [over.match.best]/p1:</p>\n<blockquote>\n<p id=\"so_25395056_25395056_2\">a viable function <code>F1</code> is defined to be a better function than another\n  viable function F2 if for all arguments <code>i</code>, <code>ICSi(F1)</code> is not a worse\n  conversion sequence than <code>ICSi(F2)</code>, and then</p>\n<ul>\n<li>for some argument <code>j</code>, <code>ICSj(F1)</code> is a better conversion sequence than <code>ICSj(F2)</code>, or, if not that,</li>\n<li>the context is an initialization by user-defined conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the standard conversion sequence from the return type of <code>F1</code> to the destination type (i.e., the type of the\n  entity being initialized) is a better conversion sequence than the\n  standard conversion sequence from the return type of <code>F2</code> to the\n  destination type.</li>\n</ul>\n<p id=\"so_25395056_25395056_3\"><em>(Example and remainder of the list omitted)</em></p>\n</blockquote>\n<p>Since the standard conversion sequence from <code>int</code> to <code>int</code> (Exact Match rank) is better than the standard conversion sequence from <code>char</code> to <code>int</code> (Promotion rank), the first beats the second, and there should be no ambiguity - the conversion defined by <code>operator int()</code> will be used for the initialization, which then contradicts the sentence in \u00a713.3.3.1 [over.best.ics]/p10 that says the function call will be ill-formed because of ambiguity.</p>\n<p>Is there anything wrong in the above analysis, or is that sentence a bug in the standard?</p>\n", "Title": "In overload resolution, does selection of a function that uses the ambiguous conversion sequence necessarily result in the call being ill-formed?", "CreationDate": "2014-08-20T00:33:33.993", "LastActivityDate": "2014-09-30T09:20:19.053", "CommentCount": "14", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:28:00.223", "LastEditorUserId": "-1", "Id": "25395056", "Score": "25", "OwnerUserId": "2756719", "Tags": "<c++><language-lawyer><implicit-conversion><overload-resolution>", "AnswerCount": "1"}});