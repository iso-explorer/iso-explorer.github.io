post_cb({"7646071": {"ParentId": "7645394", "CommentCount": "3", "Body": "<p>For C++11, the relevant Standard quote can be found in</p>\n<blockquote>\n<p id=\"so_7645394_7646071_0\"><strong>7.3.3 The using declaration [namespace.udecl]</strong></p>\n<p id=\"so_7645394_7646071_1\"><strong>14/</strong> If a function declaration in namespace scope or block scope has the same name and the same parameter types as a function introduced by a using-declaration, and the declarations do not declare the same function, the program is ill-formed.</p>\n</blockquote>\n<p>This supports the EDG-based compilers. However, a special case is meant for use in classes:</p>\n<blockquote>\n<p id=\"so_7645394_7646071_2\"><strong>15/</strong> When a using-declaration brings names from a base class into a derived class scope, member functions and member function templates in the derived class override and/or hide member functions and member function templates with the same name, parameter-type-list (8.3.5), cv-qualification, and ref-qualifier (if any) in a base class (rather than conflicting). <em>[ Note: For using-declarations that name a constructor, see 12.9. \u2014end\n  note ] [ Example:</em></p>\n</blockquote>\n<pre><code>struct B {\n  virtual void f(int);\n  virtual void f(char);\n  void g(int);\n  void h(int);\n};\n\nstruct D : B {\n  using B::f;\n  void f(int); // OK: D::f(int) overrides B::f(int);\n\n  using B::g;\n  void g(char); // OK\n\n  using B::h;\n  void h(int); // OK: D::h(int) hides B::h(int)\n};\n\nvoid k(D* p)\n{\n  p-&gt;f(1); // calls D::f(int)\n  p-&gt;f(\u2019a\u2019); // calls B::f(char)\n  p-&gt;g(1); // calls B::g(int)\n  p-&gt;g(\u2019a\u2019); // calls D::g(char)\n}\n</code></pre>\n<blockquote>\n<p id=\"so_7645394_7646071_3\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p>Therefore, in C++11, it seems Comeau and Intel are wrong. I do not know whether these rules equally applied in C++03</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "7646071", "Score": "5", "CreationDate": "2011-10-04T09:53:11.953", "LastActivityDate": "2011-10-04T09:53:11.953"}, "7645394": {"CommentCount": "6", "AcceptedAnswerId": "7646071", "CreationDate": "2011-10-04T08:53:35.373", "LastActivityDate": "2011-10-04T09:53:11.953", "PostTypeId": "1", "ViewCount": "689", "FavoriteCount": "2", "Title": "Combining the 'using' directive with partial overloading: gcc feature or intel bug?", "Id": "7645394", "Score": "7", "Body": "<p>I wish to use a set of libraries written in C++ with the Intel compilers. I've attached sample code which demonstrates the problem. There are many places in the libraries where they make use of combining the 'using' directive with partial overloading (e.g., I want to use the foo(void) method from the base class but reimplement the second version fo foo in the derived class). gcc does not have a problem but intel does.</p>\n<pre><code>#include &lt;iostream&gt;\ntemplate &lt;class F&gt;\nstruct Interface\n  {\n     static const F f=10;\n  };\n\ntemplate &lt;class F&gt;\nstruct Base : public Interface&lt;F&gt;\n  {\n     void foo (void) { std::cout &lt;&lt; \"void\" &lt;&lt; std::endl; }\n     template &lt;class FF&gt;\n     void foo (Interface&lt;FF&gt; &amp;ii) { std::cout &lt;&lt; \"F : \" &lt;&lt; ii.f &lt;&lt; std::endl; }\n  };\n\ntemplate &lt;class F,int i&gt;\nstruct Derived : public Base&lt;F&gt;\n  {\n    // void foo (void) { Base&lt;F&gt;::foo(); }  // works fine\n    using Base&lt;F&gt;::foo;                     // gives error\n    template &lt;class FF&gt;\n    void foo (Interface&lt;FF&gt; &amp;ii) { std::cout &lt;&lt; \"Derived&lt;\" &lt;&lt; i &lt;&lt; \"&gt; F : \" &lt;&lt; ii.f &lt;&lt; std::endl; }\n };\n\nint main (void)\n  {\n    Derived&lt;double,10&gt; o;\n    o.foo();                  // ok\n    o.foo (o);                // problem\n  }\n</code></pre>\n<p>The compiler error that icc gives is:</p>\n<pre><code>test.cc(30): error: more than one instance of overloaded function \"Derived&lt;F, i&gt;::foo    [with F=double, i=10]\" matches the argument list:\n        function template \"void Base&lt;F&gt;::foo(Interface&lt;FF&gt; &amp;) [with F=double]\"\n        function template \"void Derived&lt;F, i&gt;::foo(Interface&lt;FF&gt; &amp;) [with F=double, i=10]\"\n        argument types are: (Derived&lt;double, 10&gt;)\n        object type is: Derived&lt;double, 10&gt;\no.foo (o);                // problem\n  ^\n\ncompilation aborted for test.cc (code 2)\n</code></pre>\n<p>If you remove the line</p>\n<pre><code>using Base&lt;F&gt;::foo;\n</code></pre>\n<p>and replace it with the line</p>\n<pre><code>void foo (void) { Base&lt;F&gt;::foo(); }\n</code></pre>\n<p>everything works fine.</p>\n<p>My question is does anyone know if this is a special gcc feature or icc bug? Or is there another work around which would not involve changing the code?</p>\n<p>This is with g++.real (Ubuntu 4.4.3-4ubuntu5) 4.4.3 and icc (ICC) 12.0.2 20110112.</p>\n", "Tags": "<c++><gcc><compiler-construction><overloading><icc>", "OwnerUserId": "978070", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_7645394_7646071_1": {"section_id": 5503, "quality": 0.8947368421052632, "length": 17}, "so_7645394_7646071_2": {"section_id": 5504, "quality": 0.8478260869565217, "length": 39}}, "n3337": {"so_7645394_7646071_1": {"section_id": 5289, "quality": 1.0, "length": 19}, "so_7645394_7646071_2": {"section_id": 5290, "quality": 0.8478260869565217, "length": 39}}, "n4659": {"so_7645394_7646071_1": {"section_id": 6937, "quality": 0.8947368421052632, "length": 17}, "so_7645394_7646071_2": {"section_id": 6938, "quality": 0.6956521739130435, "length": 32}}}});