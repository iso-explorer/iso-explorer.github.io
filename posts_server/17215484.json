post_cb({"bq_ids": {"n4140": {"so_17215484_17215694_0": {"length": 44, "quality": 1.0, "section_id": 5943}}, "n3337": {"so_17215484_17215694_0": {"length": 44, "quality": 1.0, "section_id": 5714}}, "n4659": {"so_17215484_17215694_0": {"length": 44, "quality": 1.0, "section_id": 7428}}}, "17215484": {"ViewCount": "1238", "Body": "<p>In section 10.5.1 of Stroustrup's new book \"The C++ Programming Language - Fourth Edition\" he says, that before an arithmetic operation is performed, integral promotion is used to create ints out of shorter integer types, and similarly, floating-point promotion is used to create doubles out of floats.</p>\n<p>I confirmed the first claim with the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nint main()\n{\n    short a;\n    short b;\n    std::cout &lt;&lt; typeid(a + b).name() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>This outputs \"int\" with vc++ and \"i\" with gcc.</p>\n<p>But testing it with floats instead of shorts, the output is still \"float\" or \"f\":</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nint main()\n{\n    float a;\n    float b;\n    std::cout &lt;&lt; typeid(a + b).name() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>According to Stroustrup there are no exceptions to the floating-point promotion-rule, so I expected \"double\" or \"d\" as output.</p>\n<p>Is the mentioned section about promotions wrong or somehow unclear? And is there any difference in C++98 and C++11 regarding type promotions?</p>\n", "AcceptedAnswerId": "17215694", "Title": "floating-point promotion : stroustrup vs compiler - who is right?", "CreationDate": "2013-06-20T13:53:52.577", "Id": "17215484", "CommentCount": "11", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2013-06-20T14:21:17.403", "LastEditorUserId": "2143766", "LastActivityDate": "2014-09-22T19:19:30.443", "Score": "32", "OwnerUserId": "2143766", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "25952261": {"Id": "25952261", "PostTypeId": "2", "Body": "<p>In the meantime Stroustrup seems to recognised the refer sentence is not correct or at least misleading. He has removed the sentence, about the floating-point promotion, from section 10.5.1.</p>\n<p>Please see <a href=\"http://stroustrup.com/4th_printing3.html\" rel=\"nofollow\">errata</a> of 3rd printing of 4th edition on Stroustrup's web page:</p>\n<blockquote>\n<p id=\"so_17215484_25952261_0\">pg 267: s/Similarly, floating-point promotion is used to create doubles out of floats//</p>\n</blockquote>\n<p>(Remark: The expression s/regexp/replacement/ is similar to <em>sed</em> unix tool semantics. It searches for the pattern <em>regexp</em> and replaces it with <em>replacement</em>. Nothing in our case.)</p>\n", "LastEditorUserId": "4061909", "LastActivityDate": "2014-09-21T09:47:49.113", "Score": "5", "CreationDate": "2014-09-20T18:57:37.620", "ParentId": "17215484", "CommentCount": "3", "OwnerUserId": "4061909", "LastEditDate": "2014-09-21T09:47:49.113"}, "17215694": {"Id": "17215694", "PostTypeId": "2", "Body": "<p>I don't know what exactly Stroustrup's book says, but according to the standard, <code>float</code>s will not be converted to <code>double</code>s in this case. Before applying most arithmetic binary operators, the <em>usual arithmetic conversions</em> described in 5p9 are applied:</p>\n<blockquote id=\"so_17215484_17215694_0\">\n<ul>\n<li>If either operand is of scoped enumeration type (7.2), no conversions are performed; if the other operand does not have the same type, the expression is ill-formed.  </li>\n<li>If either operand is of type long double, the other shall be converted to long double.</li>\n<li>Otherwise, if either operand is double, the other shall be converted to double.</li>\n<li>Otherwise, if either operand is float, the other shall be converted to float.</li>\n<li>Otherwise, the integral promotions (4.5) shall be performed on both operands. [...]</li>\n</ul>\n</blockquote>\n<p>The integral promotions are what causes two <code>short</code>s to be converted to <code>int</code>s. But two <code>float</code>s will not be converted to <code>double</code>s according to these rules. If you add a <code>float</code> to a <code>double</code>, the <code>float</code> will be converted to a <code>double</code>.</p>\n<p>The above is from C++11. C++03 contains the same rules, except for the one referring to scoped enumerations.</p>\n", "LastEditorUserId": "189205", "LastActivityDate": "2013-06-20T14:09:08.073", "Score": "29", "CreationDate": "2013-06-20T14:02:31.937", "ParentId": "17215484", "CommentCount": "5", "OwnerUserId": "189205", "LastEditDate": "2013-06-20T14:09:08.073"}});