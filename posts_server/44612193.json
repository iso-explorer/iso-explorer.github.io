post_cb({"44612193": {"CommentCount": "4", "AcceptedAnswerId": "44612324", "LastEditDate": "2017-06-23T09:15:37.310", "LastEditorUserId": "3980929", "CreationDate": "2017-06-18T06:01:15.710", "LastActivityDate": "2017-06-23T09:15:37.310", "PostTypeId": "1", "ViewCount": "439", "FavoriteCount": "4", "Title": "Why can't the compiler deduce the template parameter when used with a conversion operator?", "Id": "44612193", "OwnerUserId": "3980929", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;utility&gt;\n\ntemplate&lt;typename T&gt;\nstruct wrapper {\n    T value;\n};\n\nstruct foo {\n    operator wrapper&lt;int&gt;() {\n        return{10};\n    }\n};\n\n\nint main() {\n    foo f;\n    wrapper w = f; // error\n    std::pair p = std::make_pair(1, 0); // ok\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/70facfa17b742736\" rel=\"nofollow noreferrer\">gcc 7.1.1</a> fails to compile at the marked line above:</p>\n<blockquote id=\"so_44612193_44612193_0\">\n<pre><code>main.cpp: In function 'int main()':\nmain.cpp:17:17: error: class template argument deduction failed:\n     wrapper w = f; // error\n                 ^\nmain.cpp:17:17: error: no matching function for call to 'wrapper(foo&amp;)'\nmain.cpp:4:8: note: candidate: template&lt;class T&gt; wrapper(wrapper&lt;T&gt;)-&gt; wrapper&lt;T&gt;\n struct wrapper {\n        ^~~~~~~\nmain.cpp:4:8: note:   template argument deduction/substitution failed:\nmain.cpp:17:17: note:   'foo' is not derived from 'wrapper&lt;T&gt;'\n     wrapper w = f; // error\n                 ^\n</code></pre>\n</blockquote>\n<p><code>f</code> is convertible to <code>wrapper&lt;int&gt;</code>, so I expect that to happen. From there the compiler should be able to deduce that <code>T</code> is <code>int</code>. But it can't.</p>\n<p>The compiler can deduce <code>std::pair</code>'s template parameter correctly, so I'm wondering why this isn't the case with the <code>wrapper</code>.</p>\n<p>Any ideas?</p>\n", "Tags": "<c++><c++1z><template-deduction>", "Score": "13", "AnswerCount": "1"}, "bq_ids": {"n4659": {"so_44612193_44612324_1": {"section_id": 623, "quality": 1.0, "length": 14}, "so_44612193_44612324_3": {"section_id": 623, "quality": 0.7727272727272727, "length": 17}, "so_44612193_44612324_0": {"section_id": 623, "quality": 0.8833333333333333, "length": 53}, "so_44612193_44612324_2": {"section_id": 623, "quality": 0.9090909090909091, "length": 10}}}, "44612324": {"ParentId": "44612193", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>For class template argument deduction, the \"overload set\" is composed as described in <a href=\"http://eel.is/c++draft/over.match.class.deduct#1\" rel=\"nofollow noreferrer\">[over.match.class.deduct/1]</a>. Those are the following:</p>\n<blockquote>\n<p id=\"so_44612193_44612324_0\">A set of functions and function templates is formed comprising:<br>\n  (1.1) - For each constructor of the primary class template designated\n  by the template-name, if the template is defined, a function template\n  with the following properties:<br>\n  (1.1.1) - The template parameters are\n  the template parameters of the class template followed by the template\n  parameters (including default template arguments) of the constructor,\n  if any.<br>\n  (1.1.2) - The types of the function parameters are those of\n  the constructor.<br>\n  (1.1.3) - The return type is the class template\n  specialization designated by the template-name and template arguments\n  corresponding to the template parameters obtained from the class\n  template.</br></br></br></br></p>\n<p id=\"so_44612193_44612324_1\">(1.2) - If the primary class template C is not defined or does not\n  declare any constructors, an additional function template derived as\n  above from a hypothetical constructor C().  </p>\n<p id=\"so_44612193_44612324_2\">(1.3) - An additional function template derived as above from a\n  hypothetical constructor C(C), called the copy deduction candidate.  </p>\n<p id=\"so_44612193_44612324_3\">(1.4) - For each deduction-guide, a function or function template with\n  the following properties:<br>\n  (1.4.1) - The template parameters, if any,\n  and function parameters are those of the deduction-guide.<br>\n  (1.4.2) - The return type is the simple-template-id of the deduction-guide.</br></br></p>\n</blockquote>\n<p>As you can see, the matching \"function\" in 1.1 only attempts to match the argument types to the template parameter types <em>exactly</em>. It doesn't take conversion into account (much like most other template deduction related behavior). </p>\n<p>The reason it works for <code>std::pair</code> is due to item 1.3, and the \"copy deduction candidate\" it defines.</p>\n", "OwnerUserId": "817643", "LastEditorUserId": "817643", "LastEditDate": "2017-06-18T14:16:42.527", "Id": "44612324", "Score": "11", "CreationDate": "2017-06-18T06:25:59.653", "LastActivityDate": "2017-06-18T14:16:42.527"}});