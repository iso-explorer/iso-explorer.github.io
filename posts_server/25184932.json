post_cb({"bq_ids": {"n4140": {"so_25184932_25185070_0": {"length": 20, "quality": 1.0, "section_id": 289}, "so_25184932_25185070_1": {"length": 28, "quality": 0.875, "section_id": 305}}, "n3337": {"so_25184932_25185070_0": {"length": 20, "quality": 1.0, "section_id": 280}, "so_25184932_25185070_1": {"length": 28, "quality": 0.875, "section_id": 296}}, "n4659": {"so_25184932_25185070_0": {"length": 20, "quality": 1.0, "section_id": 296}, "so_25184932_25185070_1": {"length": 17, "quality": 0.53125, "section_id": 296}}}, "25185137": {"Id": "25185137", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_25184932_25185137_0\">Why does auto deduce a typ[e in this case that is not convertible to const_iterator?</p>\n</blockquote>\n<ul>\n<li>You have two available overloads for <code>begin()</code> :</li>\n</ul>\n<p><strong>Signatures:</strong></p>\n<pre><code>iterator begin();\n\nconst_iterator begin() const;\n</code></pre>\n<p>You declared your vector as <code>Packets test (100);</code>, which is non const.</p>\n<p>If you declare it const, <code>auto</code> type deduction will have the second <code>begin()</code> overload as a best (and unique) match.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/7d3fdd3771c83e19\" rel=\"nofollow\">It compiles and run with this simple fix</a>.</p>\n", "LastActivityDate": "2014-08-07T14:28:52.813", "CommentCount": "2", "CreationDate": "2014-08-07T14:28:52.813", "ParentId": "25184932", "Score": "1", "OwnerUserId": "3510483"}, "25185193": {"Id": "25185193", "PostTypeId": "2", "Body": "<p>The problem has nothing common with the iterator conversion. The compiler simply unable to determine the template argument. It is the same if you would write</p>\n<pre><code>int x = 10;\nlong y = 20;\n\nstd::cout &lt;&lt; std::max( x, y ) &lt;&lt; std::endl;\n</code></pre>\n<p>though an object of type <code>int</code> can be implicitly converted to an object of type <code>long</code>.</p>\n<p>As for your example you could write</p>\n<pre><code>const size_t n = std::distance&lt;std::vector&lt;char&gt;::const_iterator&gt; (it, itr);\n</code></pre>\n", "LastActivityDate": "2014-08-07T14:31:15.193", "CommentCount": "3", "CreationDate": "2014-08-07T14:31:15.193", "ParentId": "25184932", "Score": "4", "OwnerUserId": "2877241"}, "25185070": {"Id": "25185070", "PostTypeId": "2", "Body": "<p>Your problem can be reduced to the following example, which fails for the same reasons.</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iterator&gt;\nint main()\n{\n    std::vector&lt;int&gt; v;\n    std::vector&lt;int&gt;::const_iterator it1 = v.begin();\n    auto it2 = v.end();\n    auto n = std::distance(it1, it2);\n}\n</code></pre>\n<p><a href=\"http://en.cppreference.com/w/cpp/iterator/distance\" rel=\"nofollow noreferrer\"><code>std::distance</code></a> is defined using the same template parameter type for both arguments, and template argument deduction is failing because you have a <code>const_iterator</code> and <code>iterator</code>. </p>\n<p>User defined conversions are not considered when deducing template arguments from function calls, and since the two arguments have different types in this case, and both are participating in template argument deduction, the deduction fails.</p>\n<p><em>\u00a714.8.1/6 [temp.arg.explicit]</em></p>\n<blockquote>\n<p id=\"so_25184932_25185070_0\">Implicit conversions (Clause 4) will be performed on a function argument to convert it to the type of the corresponding function parameter if the parameter type contains no <em>template-parameters</em> that participate in template argument deduction.</p>\n</blockquote>\n<p><em>\u00a714.8.2.1/4 [temp.over]</em></p>\n<blockquote>\n<p id=\"so_25184932_25185070_1\"><code>...</code> [ <em>Note:</em> as specified in 14.8.1, implicit conversions will be performed on a function argument to convert it to the type of the corresponding function parameter if the parameter contains no <em>template-parameters</em> that participate in template argument deduction. Such conversions are also allowed, in addition to the ones described in the preceding list. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>You'll need to convert the <code>iterator</code> to <code>const_iterator</code>, or specify the template argument to <code>std::distance</code> explicitly.</p>\n<pre><code>auto n = std::distance(it1, static_cast&lt;decltype(it1)&gt;(it2));\n</code></pre>\n<p>or</p>\n<pre><code>auto n = std::distance&lt;decltype(it1)&gt;(it1, it2);\n</code></pre>\n<p>Other options are, of course, to not use <code>auto</code> and explicitly specify the iterator type in both cases, or use the <code>vector::cbegin()</code> and <code>vector::cend()</code> member functions when you need to ensure that the type is a <code>const_iterator</code>.</p>\n", "LastEditorUserId": "241631", "LastActivityDate": "2014-08-07T16:28:59.780", "Score": "18", "CreationDate": "2014-08-07T14:25:56.597", "ParentId": "25184932", "CommentCount": "10", "OwnerUserId": "241631", "LastEditDate": "2014-08-07T16:28:59.780"}, "25184932": {"ViewCount": "890", "Body": "<p>Containers are required to provide an <code>iterator</code> type which is implicitly convertible to a <code>const_iterator</code>.  Given this, I am trying to use <code>auto</code> to initialize an object via <code>vector::begin()</code>, and use that resulting object in <code>std::distance</code> where the RHS is a <code>const_iterator</code>.  This isn't working.  Here is a complete example:</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;vector&gt;\n#include &lt;iterator&gt;\n#include &lt;iostream&gt;\n\ntypedef std::vector &lt;char&gt; Packet;\ntypedef std::vector &lt;Packet&gt; Packets;\n\ntemplate &lt;typename Iter&gt; \nIter next_upto (Iter begin, Iter end, size_t n)\n{\n    Iter ret = begin;\n      for (; n &gt; 0 &amp;&amp; ret != end; ++ret, --n)\n            ;   \n        return ret;\n}\n\nPackets::const_iterator Process (Packets::const_iterator begin, Packets::const_iterator end)\n{\n  Packets::const_iterator ret = begin;\n  while (ret != end)\n    ++ret;  // do something\n  return ret;\n}\n\nint main()\n{\n  Packets test (100); // vector of 100 default-initialized packets\n\n  // process them 10 at a time\n  for (auto it = test.begin();\n    it != test.end();\n    it = next_upto (it, test.end(), 10))\n  {\n     auto itr = Process (it, next_upto (it, test.end(), 10));\n     Packets::const_iterator it2 = it; \n     const size_t n1 = std::distance (it2, itr);\n     const size_t n = std::distance (it, itr);\n     std::cout &lt;&lt; \"Processed \" &lt;&lt; n &lt;&lt; \" packets\\n\";\n  }\n}\n</code></pre>\n<p>Under g++ 4.8.1 (and 4.8.2) compiling this yields:</p>\n<pre><code>[1/2] Building CXX object CMakeFiles/hacks.dir/main.o\nFAILED: /usr/bin/g++    -Wall -std=c++11 -g -MMD -MT CMakeFiles/hacks.dir/main.o -MF \"CMakeFiles/hacks.dir/main.o.d\" -o CMakeFiles/hacks.dir/main.o -c main.cpp\nmain.cpp: In function \u2018int main()\u2019:\nmain.cpp:39:45: error: no matching function for call to \u2018distance(__gnu_cxx::__normal_iterator&lt;std::vector&lt;char&gt;*, std::vector&lt;std::vector&lt;char&gt; &gt; &gt;&amp;, __gnu_cxx::__normal_iterator&lt;const std::vector&lt;char&gt;*, std::vector&lt;std::vector&lt;char&gt; &gt; &gt;&amp;)\u2019\n      const size_t n = std::distance (it, itr);\n                                             ^\nmain.cpp:39:45: note: candidate is:\nIn file included from /usr/include/c++/4.8/bits/stl_algobase.h:66:0,\n                 from /usr/include/c++/4.8/vector:60,\n                 from main.cpp:2:\n/usr/include/c++/4.8/bits/stl_iterator_base_funcs.h:114:5: note: template&lt;class _InputIterator&gt; typename std::iterator_traits&lt;_Iterator&gt;::difference_type std::distance(_InputIterator, _InputIterator)\n     distance(_InputIterator __first, _InputIterator __last)\n     ^\n/usr/include/c++/4.8/bits/stl_iterator_base_funcs.h:114:5: note:   template argument deduction/substitution failed:\nmain.cpp:39:45: note:   deduced conflicting types for parameter \u2018_InputIterator\u2019 (\u2018__gnu_cxx::__normal_iterator&lt;std::vector&lt;char&gt;*, std::vector&lt;std::vector&lt;char&gt; &gt; &gt;\u2019 and \u2018__gnu_cxx::__normal_iterator&lt;const std::vector&lt;char&gt;*, std::vector&lt;std::vector&lt;char&gt; &gt; &gt;\u2019)\n      const size_t n = std::distance (it, itr);\n                                             ^\n</code></pre>\n<p>I'm aware that I can fix this particular instance by calling <code>cbegin()</code> and <code>cend()</code> rather than <code>begin()</code> and <code>end()</code>, but since <code>begin()</code> and <code>end()</code> return a type that should be convertible to <code>const_iterator</code>, I'm not sure I understand why this is needed.</p>\n<p>Why does <code>auto</code> deduce a type in this case that is not convertible to <code>const_iterator</code>?</p>\n", "AcceptedAnswerId": "25185070", "Title": "auto it = vector.begin() resulting type is not convertible to const_iterator", "CreationDate": "2014-08-07T14:18:50.507", "Id": "25184932", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-08-07T14:52:43.613", "LastEditorUserId": "241536", "LastActivityDate": "2014-08-07T16:28:59.780", "Score": "4", "OwnerUserId": "241536", "Tags": "<c++><c++11><auto><implicit-conversion>", "AnswerCount": "3"}});