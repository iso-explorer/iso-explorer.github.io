post_cb({"bq_ids": {"n4140": {"so_17430377_17433978_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 370}}, "n3337": {"so_17430377_17433978_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 360}}, "n4659": {"so_17430377_17433978_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 384}}}, "17433978": {"Id": "17433978", "PostTypeId": "2", "Body": "<p>Maybe this is the problem:</p>\n<blockquote>\n<p id=\"so_17430377_17433978_0\">\u00a712.1 5. A default constructor that is defaulted and not defined as deleted is implicitly defined when it is odr-\n  used (3.2) to create an object of its class type (1.8) or when it is explicitly defaulted after its first declaration</p>\n</blockquote>\n<p>So, the default constructor is generated when first looked up, but the lookup will fail because A is not completely defined and B inside A will therefore not be found.</p>\n", "LastActivityDate": "2013-07-02T19:16:58.983", "CommentCount": "4", "CreationDate": "2013-07-02T19:16:58.983", "ParentId": "17430377", "Score": "0", "OwnerUserId": "1030146"}, "17436088": {"Id": "17436088", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_17430377_17436088_0\">Is this code really incorrect or are the compilers wrong?</p>\n</blockquote>\n<p>Well, neither. The standard has a defect -- it says both that <code>A</code> is considered complete while parsing the initializer for <code>B::i</code>, and that <code>B::B()</code> (which uses the initializer for <code>B::i</code>) can be used within the definition of <code>A</code>. That's clearly cyclic. Consider this:</p>\n<pre><code>struct A {\n  struct B {\n    int i = (A(), 0);\n  };\n  A() noexcept(!noexcept(B()));\n};\n</code></pre>\n<p>This has a contradiction: <code>B::B()</code> is implicitly <code>noexcept</code> iff <code>A()</code> does not throw, and <code>A()</code> does not throw iff <code>B::B()</code> is <em>not</em> <code>noexcept</code>. There are a number of other cycles and contradictions in this area.</p>\n<p>This is tracked by core issues <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1360\" rel=\"noreferrer\" title=\"core issue 1360\">1360</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1397\" rel=\"noreferrer\" title=\"core issue 1397\">1397</a>. Note in particular this note in core issue 1397:</p>\n<blockquote>\n<p id=\"so_17430377_17436088_1\">Perhaps the best way of addressing this would be to make it ill-formed for a non-static data member initializer to use a defaulted constructor of its class.</p>\n</blockquote>\n<p>That's a special case of the rule that I implemented in Clang to resolve this issue. Clang's rule is that a defaulted default constructor for a class cannot be used before the non-static data member initializers for that class are parsed. Hence Clang issues a diagnostic here:</p>\n<pre><code>    A(const B&amp; _b = B())\n                    ^\n</code></pre>\n<p>... because Clang parses default arguments before it parses default initializers, and this default argument would require <code>B</code>'s default initializers to have already been parsed (in order to implicitly define <code>B::B()</code>).</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-05-04T18:53:34.903", "Score": "71", "CreationDate": "2013-07-02T21:24:31.007", "ParentId": "17430377", "CommentCount": "7", "OwnerUserId": "1041090", "LastEditDate": "2015-05-04T18:53:34.903"}, "17430377": {"ViewCount": "12720", "Body": "<p>The following code is quite trivial and I expected that it should compile fine.</p>\n<pre><code>struct A\n{\n    struct B\n    {\n        int i = 0;\n    };\n\n    B b;\n\n    A(const B&amp; _b = B())\n        : b(_b)\n    {}\n};\n</code></pre>\n<p>I've tested this code with g++ version 4.7.2, 4.8.1, clang++ 3.2 and 3.3. Apart from fact that g++ 4.7.2 segfaults on this code (<a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=57770\">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=57770</a>), the other tested compilers give error messages that don't explain much.</p>\n<p>g++ 4.8.1:</p>\n<pre><code>test.cpp: In constructor \u2018constexpr A::B::B()\u2019:\ntest.cpp:3:12: error: constructor required before non-static data member for \u2018A::B::i\u2019 has been parsed\n     struct B\n            ^\ntest.cpp: At global scope:\ntest.cpp:11:23: note: synthesized method \u2018constexpr A::B::B()\u2019 first required here \n     A(const B&amp; _b = B())\n                       ^\n</code></pre>\n<p>clang++ 3.2 and 3.3:</p>\n<pre><code>test.cpp:11:21: error: defaulted default constructor of 'B' cannot be used by non-static data member initializer which appears before end of class definition\n    A(const B&amp; _b = B())\n                    ^\n</code></pre>\n<p>Making this code compilable is possible and seems like it should make no difference. There are two options:</p>\n<pre><code>struct B\n{\n    int i = 0;\n    B(){} // using B()=default; works only for clang++\n};\n</code></pre>\n<p>or</p>\n<pre><code>struct B\n{\n    int i;\n    B() : i(0) {} // classic c++98 initialization\n};\n</code></pre>\n<p>Is this code really incorrect or are the compilers wrong?</p>\n", "AcceptedAnswerId": "17436088", "Title": "Error when using in-class initialization of non-static data member and nested class constructor", "CreationDate": "2013-07-02T16:03:59.937", "Id": "17430377", "CommentCount": "9", "FavoriteCount": "14", "PostTypeId": "1", "LastEditDate": "2013-07-02T22:29:57.610", "LastEditorUserId": "906773", "LastActivityDate": "2015-09-02T10:28:04.633", "Score": "82", "OwnerUserId": "952263", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "2"}});