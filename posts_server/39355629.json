post_cb({"bq_ids": {"n4140": {"so_39355629_39356164_0": {"length": 32, "quality": 0.9142857142857143, "section_id": 603}, "so_39355629_39356164_1": {"length": 11, "quality": 0.55, "section_id": 323}}, "n3337": {"so_39355629_39356164_0": {"length": 32, "quality": 0.9142857142857143, "section_id": 593}, "so_39355629_39356164_1": {"length": 11, "quality": 0.55, "section_id": 313}}, "n4659": {"so_39355629_39356164_0": {"length": 32, "quality": 0.9142857142857143, "section_id": 629}, "so_39355629_39356164_1": {"length": 20, "quality": 1.0, "section_id": 331}}}, "39355629": {"ViewCount": "135", "Body": "<p>I am having trouble understanding why the following leads to an ambiguous call:</p>\n<pre><code>#include &lt;iostream&gt;\n\n// generic version f(X, Y)\ntemplate &lt;class X, class Y&gt;\nvoid f(X x, Y y) {\n    std::cout &lt;&lt; \"generic\" &lt;&lt; std::endl;\n}\n\n// overload version\ntemplate &lt;class X&gt;\nvoid f(X x, typename X::type y) {\n    std::cout &lt;&lt; \"overload\" &lt;&lt; std::endl;\n}\n\nstruct MyClass {\n    using type = int;\n};\n\nint main() {\n    f(MyClass(), int()); // Call to f is ambiguous\n}\n</code></pre>\n<p>I would expect the overload version, which is more specialised in the second argument than the generic version, to be selected as the best candidate. I know that if I change the overload version to </p>\n<pre><code>template &lt;class X&gt;\nvoid f(X x, int y) {\n    std::cout &lt;&lt; \"overload\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>then the call is resolved just fine, which means it has to do with the fact that X::type is a template dependent name, but still cannot work out why it fails. Any help is much appreciated.</p>\n", "AcceptedAnswerId": "39356164", "Title": "Overload resolution with template parameters", "CreationDate": "2016-09-06T18:30:34.043", "Id": "39355629", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2016-09-06T19:53:04.380", "Score": "8", "OwnerUserId": "1598163", "Tags": "<c++><templates><overload-resolution>", "AnswerCount": "1"}, "39356164": {"Id": "39356164", "PostTypeId": "2", "Body": "<p>First, we pick the viable candidates. Those are:</p>\n<pre><code>void f(MyClass, int);                    // with X=MyClass, Y=int\nvoid f(MyClass, typename MyClass::type); // with X=MyClass\n</code></pre>\n<p>Those candidates both take the same arguments, so have equivalent conversion sequences. So none of the tiebreakers based on those apply, so we fall back to the last possible tiebreaker in [over.match.best]:</p>\n<blockquote>\n<p id=\"so_39355629_39356164_0\">Given these definitions, a viable function F1 is defined to be a better function than another viable function\n  F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then [...] F1 and F2 are function template specializations, and the function template for F1 is more specialized\n  than the template for F2 according to the partial ordering rules described in 14.5.6.2.</p>\n</blockquote>\n<p>So we try to order the two function templates based on the partial ordering rules, which involve synthesizing a unique type for each template parameter and attempting to perform template deduction against each over overload. But with a key additional relevant rule from [temp.deduct.partial]:</p>\n<blockquote>\n<p id=\"so_39355629_39356164_1\">Each type nominated above from the parameter template and the corresponding type from the argument\n  template are used as the types of P and A. <strong>If a particular P contains no template-parameters that participate\n  in template argument deduction, that P is not used to determine the ordering.</strong></p>\n</blockquote>\n<p>So what does this mean. First, let's try to deduce the generic version from the overload. We pick synthetic types <code>UniqueX</code> (for <code>X</code>) and <code>UniqueX_type</code> (for <code>typename X::type</code>) and see if we can invoke the generic function. This succeeds (with <code>X=UniqueX</code> and <code>Y=typename X::type</code>). </p>\n<p>Let's try the inverse. We pick a <code>UniqueX</code> (for <code>X</code>) and a <code>UniqueY</code> (for <code>Y</code>) and try to perform template deduction. For the first P/A pair, this trivially succeeds. But for the second argument, <code>X</code> is a non-deduced context, which you would think would mean that template deduction fails. <strong>BUT</strong> as per the bolded part of the quote, we just skip this P/A pair for the purposes of ordering. So, since the first P/A pair succeeded, we consider the entire deduction process to have succeeded.</p>\n<p>Since template deduction succeeds in both directions, we cannot pick one function or the other as being more specialized. Since there are no further tiebreakers, there is no single best viable candidate, so the call is ambiguous. </p>\n<hr/>\n<p>When the second overload is changed to:</p>\n<pre><code>template &lt;class X&gt; void f(X, int);\n</code></pre>\n<p>the part of the process that changes is that deduction now fails in one direction. We can deduce <code>X=UniqueX</code> but the second pair has a parameter of type <code>int</code> and an argument of type <code>UniqueY</code>, which will not work, so this direction fails. In the reverse direction, we can deduce <code>X=UniqueX</code> and <code>Y=int</code>. That makes this overload more specialized that the generic overload, so it would be preferred by the last tiebreaker I originally mentioned. </p>\n<hr/>\n<p>As an addendum, note that partial ordering of templates is complicated. Consider:</p>\n<pre><code>template &lt;class T&gt; struct identity { using type = T; };\n\ntemplate &lt;class T&gt; void foo(T );                             // #1\ntemplate &lt;class T&gt; void foo(typename identity&lt;T&gt;::type );    // #2\n\ntemplate &lt;class T&gt; void bar(T, T);                           // #3\ntemplate &lt;class T&gt; void bar(T, typename identity&lt;T&gt;::type ); // #4\n\nfoo(0);      // calls #1, #2 isn't even viable\nfoo&lt;int&gt;(0); // calls #2\nbar(0,0);    // calls #3! we fail to deduce 3 from 4, but we succeed\n             // in deducing 4 from 3 because we ignore the second P/A pair!\n</code></pre>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-09-06T19:53:04.380", "Score": "8", "CreationDate": "2016-09-06T19:05:57.370", "ParentId": "39355629", "CommentCount": "2", "OwnerUserId": "2069064", "LastEditDate": "2016-09-06T19:53:04.380"}});