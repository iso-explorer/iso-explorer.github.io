post_cb({"603454": {"CommentCount": "0", "CreationDate": "2009-03-02T18:35:16.937", "LastEditorUserId": "34509", "LastActivityDate": "2009-03-02T20:13:10.277", "ParentId": "603390", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastEditDate": "2009-03-02T20:13:10.277", "Id": "603454", "Score": "8", "Body": "<p>Just my two cents. This is not about virtual function in particular, but about inline and member-functions generally. Maybe it is useful.</p>\n<h3>C++</h3>\n<p>As far as Standard C++ is concerned, a inline function <em>must</em> be defined in every translation unit in which it is used. And an non-static inline function will have the same static variables in every translation unit and the same address. The compiler/linker will have to merge the multiple definitions into one function to achieve this. So, always place the definition of an inline function into the header - or place no declaration of it into the header if you define it only in the implementation file (\".cpp\") (for a non-member function), because if you would, and someone used it, you would get a linker error about an undefined function or something similar. </p>\n<p>This is different from non-inline functions which must be defined only once in an entire program (<em>one-definition-rule</em>). For inline functions, multiple definitions as outlined above are rather the normal case. And this is independent on whether the call is atually inlined or not. The rules about inline functions still matter. Whether the Microsoft compiler adheres to those rules or not - i can't tell you. If it adheres to the Standard in that regard, then it will. However, i could imagine some combination using virtual, dlls and different TUs could be problematic. I've never tested it but i believe there are no problems.</p>\n<p>For member-functions, if you define your function in the class, it is implicitly inline. And because it appears in the header, the rule that it has to be defined in every translation unit in which it is used is automatically satisfied. However, if you define the function out-of-class and in a header file (for example because there is a circular dependency with code in between), then that definition has to be inline if you include the corresponding file more than once, to avoid multiple-definition errors thrown by the linker. Example of a file <code>f.h</code>:</p>\n<pre><code>struct f {\n    // inline required here or before the definition below\n    inline void g();\n};\n\nvoid f::g() { ... }\n</code></pre>\n<p>This would have the same effect as placing the definition straight into the class definition.</p>\n<h3>C99</h3>\n<p>Note that the rules about inline functions are more complicated for C99 than for C++. Here, an inline function can be defined as an <em>inline definition</em>, of which can exist more than one in the entire program. But if such a (inline-) definition is used (e.g if it is called), then there <em>must</em> be also <em>exactly one</em> external definition in the entire program contained in another translation unit. Rationale for this (quoting from a PDF explaining the rationale behind several C99 features):</p>\n<blockquote>\n<p id=\"so_603390_603454_0\">Inlining in C99 does extend the C++ specification in two ways. First, if a function is declared inline in one translation unit, it need not be declared inline in every other translation unit. This allows, for example, a library function that is to be inlined within the library but available only through an external definition elsewhere. The alternative of using a wrapper function for the external function requires an additional name; and it may also adversely impact performance if a translator does not actually do inline substitution.</p>\n<p id=\"so_603390_603454_1\">Second, the requirement that all definitions of an inline function be \"exactly the same\" is replaced by the requirement that the behavior of the program should not depend on whether a call is implemented with a visible inline definition, or the external definition, of a function. This allows an inline definition to be specialized for its use within a particular translation unit. For example, the external definition of a library function might include some argument validation that is not needed for calls made from other functions in the same library. These extensions do offer some advantages; and programmers who are concerned about compatibility can simply abide by the stricter C++ rules.</p>\n</blockquote>\n<p>Why do i include C99 into here? Because i know that the Microsoft compiler supports some stuff of C99. So in those MSDN pages, some stuff may come from C99 too - haven't figured anything in particular though. One should be careful when reading it and when applying those techniques to ones own C++ code intended to be portable C++. Probably informing which parts are C99 specific, and which not. </p>\n<p>A good place to test small C++ snippets for Standard conformance is the <a href=\"http://www.comeaucomputing.com/tryitout/\" rel=\"noreferrer\">comeau online compiler</a>. If it gets rejected, one can be pretty sure it is not strictly Standard conforming. </p>\n", "OwnerUserId": "34509", "OwnerDisplayName": "litb"}, "603398": {"ParentId": "603390", "CommentCount": "0", "Body": "<p>Don't inline your functions if you want to ensure they get compiled into a specific library.</p>\n", "OwnerUserId": "1254", "Id": "603398", "PostTypeId": "2", "OwnerDisplayName": "Brian Ensink", "Score": "2", "CreationDate": "2009-03-02T18:19:11.937", "LastActivityDate": "2009-03-02T18:19:11.937"}, "603632": {"CommentCount": "2", "CreationDate": "2009-03-02T19:27:24.457", "LastEditorUserId": "8999", "LastActivityDate": "2013-01-30T12:40:00.317", "ParentId": "603390", "PostTypeId": "2", "LastEditorDisplayName": "Fabio Ceconello", "LastEditDate": "2013-01-30T12:40:00.317", "Id": "603632", "Score": "7", "Body": "<p>When you have an inline method that is forced to be non-inlined by the compiler, it will really instantiate the method in every compiled unit that uses it. Today most compilers are smart enough to instantiate a method only if needed (if used) so merely including the header file will not force instantiation. The linker, as you said, will pick one of the instantiations to include in the executable file - but keep in mind that the record inside the object module is of a special kind (for instance, a COMDEF) in order to give the linker enough information to know how to discard duplicated instances. These records will not, therefore, result in unwanted dependencies between modules, because the linker will use them with less priority than \"regular\" records to resolve dependencies.</p>\n<p>In the example you gave, you really don't know, but it doesn't matter. The linker won't resolve dependencies based on non-inlined instances alone ever. The result (in terms of modules included by the linker) will be as good as if the inline method didn't exist.</p>\n", "OwnerUserId": "8999", "OwnerDisplayName": "Fabio Ceconello"}, "603400": {"CommentCount": "18", "CreationDate": "2009-03-02T18:20:07.333", "LastEditorUserId": "66692", "LastActivityDate": "2009-03-02T21:59:46.103", "ParentId": "603390", "PostTypeId": "2", "LastEditorDisplayName": "dirkgently", "LastEditDate": "2009-03-02T21:59:46.120", "Id": "603400", "Score": "3", "Body": "<blockquote>\n<p id=\"so_603390_603400_0\">If the compiler decided to create a symbol for that function (and in this case, it will, because of 'virtualness', there will be several (externally-seen) instantiations in different object file, which definition (from which object file?) will the linker choose?)</p>\n</blockquote>\n<p>The definition that is present in the corresponding translation unit. And a translation unit cannot, and I repeat, cannot have but exactly one such definition. The standard is clear about that.</p>\n<blockquote>\n<p id=\"so_603390_603400_1\">[...]the linker might \"pick\" an arbitrary object file as a source for the definition. </p>\n</blockquote>\n<p><strong>EDIT:</strong> To avoid any further misunderstanding, let me make my point clear: As per my reading of the standard, the ability to have multiple definition across different TUs does not give us <strong>any</strong> practical leverage. By practical, I mean having even slightly varying implementations. <strong><em>Now, if all your TUs have the exact same definition, why bother which TU the definition is being picked up from?</em></strong></p>\n<p>If you browse through the standard you will find the One Definition Rule is applied everywhere. Even though it <em>is</em> allowed to have multiple definitions of an <code>inline</code> function:</p>\n<blockquote>\n<p id=\"so_603390_603400_2\"><strong>3.2 One Definition Rule:</strong></p>\n<p id=\"so_603390_603400_3\">5 There can be more than one definition of a class type (Clause 9), concept (14.9), concept map (14.9.2), enumeration type (7.2), inline function with external linkage (7.1.2), [...]</p>\n</blockquote>\n<p>Read it in conjunction with </p>\n<blockquote>\n<p id=\"so_603390_603400_4\">3 [...] An inline function shall be defined in every translation unit in which it is used.</p>\n<p id=\"so_603390_603400_5\">This means that the function will be defined in every compilation unit [...]</p>\n</blockquote>\n<p>and </p>\n<blockquote>\n<p id=\"so_603390_603400_6\"><strong>7.1.2 Function Specifiers</strong></p>\n<p id=\"so_603390_603400_7\">2 A function declaration (8.3.5, 9.3, 11.4) with an inline specifier declares an inline function. The inline specifier indicates to the implementation that inline substitution of the function body at the point of call is to be preferred to the usual function call mechanism. An implementation is not required to perform this inline substitution at the point of call; however, even if this inline substitution is omitted, the other rules\n  for inline functions defined by 7.1.2 shall still be respected.</p>\n<p id=\"so_603390_603400_8\">3 A function defined within a class definition is an inline function. The inline specifier shall not appear on a block scope function declaration.[footnote: 82] If the inline specifier is used in a friend declaration, that declaration shall be a definition or the function shall have previously been declared inline. </p>\n</blockquote>\n<p>and the footnote:</p>\n<blockquote>\n<p id=\"so_603390_603400_9\">82) The inline keyword has no effect on the linkage of a function.\n  \u00a7 7.1.2 138</p>\n</blockquote>\n<p>as well as:</p>\n<blockquote>\n<p id=\"so_603390_603400_10\">4 An inline function shall be defined in every translation unit in which it is used and shall have exactly the same definition in every case (3.2). [ Note: a call to the inline function may be encountered before its definition appears in the translation unit. \u2014end note ] If the definition of a function appears in a translation unit before its first declaration as inline, the program is ill-formed. If a function with external linkage is\n  declared inline in one translation unit, it shall be declared inline in all translation units in which it appears; no diagnostic is required. An inline function with external linkage shall have the same address in all translation units. A static local variable in an extern inline function always refers to the same object. A string literal in the body of an extern inline function is the same object in different translation units. [ Note: A string literal appearing in a default argument expression is not in the body of an inline function merely because the expression is used in a function call from that inline function. \u2014end note ]</p>\n</blockquote>\n<p>Distilled: Its ok to have multiple definitions, but they must have the same look and feel in <strong>every</strong> translation unit and address -- but that doesn't really give you much to cheer about. Having multiple deinition across translation units is therefore <strong>not defined</strong> (note: I am not saying you are invoking UB, yet).</p>\n<p>As for the <code>virtual</code> thingy -- there won't be any inlining. Period.</p>\n<p>The standard says:</p>\n<ul>\n<li>The same <strong>declaration</strong> must be available </li>\n<li>There must be <strong>one definition</strong></li>\n</ul>\n<p>From <a href=\"http://msdn.microsoft.com/en-us/library/bw1hbe6y(VS.71).aspx\" rel=\"nofollow noreferrer\">MSDN</a>:</p>\n<blockquote>\n<p id=\"so_603390_603400_11\">A given inline member function must be declared the same way in every compilation unit. This constraint causes inline functions to behave as if they were instantiated functions. Additionally, there must be exactly one definition of an inline function.</p>\n</blockquote>\n<p>Your <code>A.h</code> contains the class definition and the member <code>foo()</code>'s definition. </p>\n<p><code>U1.cpp</code> and <code>U2.cpp</code> both <em>define</em> two different <strong>objects</strong> of class <code>A</code>. </p>\n<p>You create another <code>A</code> object in <code>main()</code>. This is just fine.</p>\n<p>So far, I have seen only one definition of <code>A::foo()</code> which is inline. (Remember that a function defined within the class declaration is <em>always</em> inlined whether or not it is preceded by the <code>inline</code> keyword.)</p>\n", "OwnerUserId": "66692", "OwnerDisplayName": "dirkgently"}, "603423": {"ParentId": "603390", "CommentCount": "0", "Body": "<p>AFAIK, there is no standard definition of how and when a C++ compiler will inline a function call. These are usually \"recommendations\" that the compiler is in no way required to follow. In fact, different users may want different behaviors. One user may care about speed, while another may care about small generated object file size. In addition, compilers and platforms are different. Some compilers may apply smarter analysis, some may not. Some compilers may generate longer code from the inline, or work on a platform where calls are too expensive, etc. </p>\n<p>When you have an inline function, the compiler should still generate a symbol for it and eventually resolve a single version of it. So that if it is in a static library, people can still call the function not in inline. In other words, it still acts as a normal function,.</p>\n<p>The only effect of the inline is that some cases, the compiler will see the call, see the inline, and skip the call completely, but the function should still be there, it's just not getting called in this case. </p>\n", "OwnerUserId": "23072", "Id": "603423", "PostTypeId": "2", "OwnerDisplayName": "Uri", "Score": "4", "CreationDate": "2009-03-02T18:27:16.443", "LastActivityDate": "2009-03-02T18:27:16.443"}, "bq_ids": {"n4140": {"so_603390_603400_10": {"section_id": 5404, "quality": 0.9320388349514563, "length": 96}, "so_603390_603400_4": {"section_id": 5404, "quality": 1.0, "length": 6}, "so_603390_603400_9": {"section_id": 5403, "quality": 0.625, "length": 5}, "so_603390_603400_7": {"section_id": 5402, "quality": 0.8888888888888888, "length": 40}, "so_603390_603400_3": {"section_id": 7043, "quality": 0.7142857142857143, "length": 15}, "so_603390_603400_8": {"section_id": 5403, "quality": 0.9259259259259259, "length": 25}}, "n3337": {"so_603390_603400_10": {"section_id": 5199, "quality": 0.9320388349514563, "length": 96}, "so_603390_603400_4": {"section_id": 5199, "quality": 1.0, "length": 6}, "so_603390_603400_9": {"section_id": 5198, "quality": 0.625, "length": 5}, "so_603390_603400_7": {"section_id": 5197, "quality": 0.8888888888888888, "length": 40}, "so_603390_603400_3": {"section_id": 6788, "quality": 0.7142857142857143, "length": 15}, "so_603390_603400_8": {"section_id": 5198, "quality": 0.9259259259259259, "length": 25}}, "n4659": {"so_603390_603400_10": {"section_id": 6853, "quality": 0.7184466019417476, "length": 74}, "so_603390_603400_4": {"section_id": 6853, "quality": 1.0, "length": 6}, "so_603390_603400_9": {"section_id": 6852, "quality": 0.625, "length": 5}, "so_603390_603400_7": {"section_id": 6849, "quality": 0.8666666666666667, "length": 39}, "so_603390_603400_8": {"section_id": 6852, "quality": 0.6666666666666666, "length": 18}, "so_603390_603400_3": {"section_id": 8540, "quality": 0.7142857142857143, "length": 15}}}, "603390": {"CommentCount": "4", "AcceptedAnswerId": "603632", "PostTypeId": "1", "LastEditorUserId": "72896", "LastEditorDisplayName": "EFraim", "CreationDate": "2009-03-02T18:16:48.683", "LastActivityDate": "2013-01-30T12:40:00.317", "AnswerCount": "5", "LastEditDate": "2009-03-02T20:12:59.340", "ViewCount": "9314", "FavoriteCount": "2", "Title": "Inline member functions in C++", "Id": "603390", "Score": "14", "Body": "<p>ISO C++ says that the inline definition of member function in C++ is the same as declaring it with inline. This means that the function will be defined in every compilation unit the member function is used. However, if the function call cannot be inlined for whatever reason, the function is to be instantiated \"as usual\". (<a href=\"http://msdn.microsoft.com/en-us/library/z8y1yy88%28VS.71%29.aspx\" rel=\"noreferrer\">http://msdn.microsoft.com/en-us/library/z8y1yy88%28VS.71%29.aspx</a>) The problem I have with this definition is that it does not tell in which translation unit it would be instantiated.\nThe problem I encountered is that when facing two object files in a single static library, both of which have the reference to some inline member function which cannot be inlined, the linker might \"pick\" an arbitrary object file as a source for the definition. This particular choice might introduce unneeded dependencies. (among other things)</p>\n<p>For instance:\n<strong>In a static library</strong></p>\n<pre><code>A.h:\n\nclass A{\n  public:\n    virtual bool foo() { return true; }\n};\n</code></pre>\n<p>U1.cpp:</p>\n<pre><code>A a1;\n</code></pre>\n<p>U2.cpp:</p>\n<pre><code>A a2;\n</code></pre>\n<p><em>and lots of dependencies</em></p>\n<p><strong>In another project</strong>\nmain.cpp:</p>\n<pre><code>#include \"A.h\"\n\nint main(){\n  A a;\n  a.foo();\n  return 0;\n}\n</code></pre>\n<p>The second project refers the first. How do I know which definition the compiler will use, and, consequently which object files with their dependencies will be linked in? Is there anything the standard says on that matter? (Tried, but failed to find that)</p>\n<p>Thanks</p>\n<p>Edit: since I've seen some people misunderstand what the question is, I'd like to emphasize: <em>If the compiler decided to create a symbol for that function (and in this case, it will, because of 'virtualness', there will be several (externally-seen) instantiations in different object file, which definition (from which object file?) will the linker choose?)</em></p>\n", "Tags": "<c++><inline-method>", "OwnerUserId": "72896", "OwnerDisplayName": "EFraim"}});