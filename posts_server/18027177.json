post_cb({"bq_ids": {"n4140": {"so_18027177_18027177_0": {"length": 23, "quality": 0.92, "section_id": 6325}}, "n3337": {"so_18027177_18027177_0": {"length": 23, "quality": 0.92, "section_id": 6082}}, "n4659": {"so_18027177_18027177_0": {"length": 23, "quality": 0.92, "section_id": 7835}}}, "18027177": {"ViewCount": "172", "Body": "<p>From \u00a7 17.6.4.9 of ISO/IEC 14882:2011(E) (C++11):</p>\n<blockquote>\n<p id=\"so_18027177_18027177_0\">Each of the following applies to all arguments to functions de\ufb01ned in\n  the C++ standard library, unless explicitly stated otherwise.<br>\n  [snip]<br>\n  \u2014 If a function argument binds to an rvalue reference parameter, the\n  implementation may assume that this parameter is a unique reference to\n  this argument.</br></br></p>\n</blockquote>\n<p>This specification only applies to standard library functions, but it seems like the whole point of rvalue references is for this kind of assumption to be possible. If I have a function that takes an rvalue reference and pass it one (either through a temporary or <code>std::move</code>), can the implementation legally perform optimizations that assume it's unique? If not, do any implementations do so anyway?</p>\n", "AcceptedAnswerId": "18027435", "Title": "Are C++ implementations allowed to assume any rvalue reference function parameter is unique?", "CreationDate": "2013-08-02T22:42:57.097", "Id": "18027177", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-08-02T23:27:55.063", "Score": "5", "OwnerUserId": "636917", "Tags": "<c++><rvalue-reference>", "AnswerCount": "1"}, "18027435": {"Id": "18027435", "PostTypeId": "2", "Body": "<p>The language does not itself mandate that an rvalue reference cannot alias any other object, this is simply a stated pre-condition of standard library functions.  So if by \"implementation\" you mean the compiler, then no - the compiler will not perform any optimizations based on this requirement, certainly not in code that you write.</p>\n<p>If a particular compiler has some kind of extensions that allow code to convey aliasing information, then that pre-condition makes it is possible for standard library functions to take advantage of such extensions. That kind of aliasing information may make it possible for the compiler to perform some optimizations.</p>\n<p>In any case, the main consequence of the statement is that the standard library implementation does not need to behave reasonably in the face of unreasonable aliasing of function parameters. For example, if you construct a pair with </p>\n<pre><code>std::vector&lt;int&gt; some_vector(100, 42);\nauto p = std::make_pair(std::move(some_vector), some_vector);\n</code></pre>\n<p>there's no guarantee that <code>p.first == p.second</code>.</p>\n<p>The absence of a requirement like this for lvalue reference parameters means that the standard library has to do some crazy things to make sure that code like <code>vector.insert(vector.end(), vector[3])</code> works even if the vector has to be reallocated. I imagine the committee thought it was unrealistic for implementations to detect rvalue aliasing and have to maybe-move-only-sometimes.</p>\n", "LastEditorUserId": "923854", "LastActivityDate": "2013-08-02T23:27:55.063", "Score": "5", "CreationDate": "2013-08-02T23:06:32.800", "ParentId": "18027177", "CommentCount": "5", "LastEditDate": "2013-08-02T23:27:55.063", "OwnerUserId": "923854"}});