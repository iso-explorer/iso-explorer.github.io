post_cb({"7762954": {"ParentId": "7762929", "CommentCount": "1", "Body": "<p>I would wrap that conversion up in a class (so that if you need to change platform or something, it's at least localised in one spot) but yes it should be possible.</p>\n<p>You'll want to use <code>reinterpret_cast</code>, not <code>static_cast</code> as well.</p>\n", "OwnerUserId": "481760", "PostTypeId": "2", "Id": "7762954", "Score": "1", "CreationDate": "2011-10-14T04:14:05.850", "LastActivityDate": "2011-10-14T04:14:05.850"}, "7762929": {"CommentCount": "0", "CreationDate": "2011-10-14T04:09:46.093", "PostTypeId": "1", "AcceptedAnswerId": "7762964", "LastEditorUserId": "620863", "LastActivityDate": "2011-10-14T04:27:07.197", "LastEditDate": "2011-10-14T04:15:47.980", "ViewCount": "447", "FavoriteCount": "1", "Title": "Safety of casting between pointers of two identical classes?", "Id": "7762929", "Score": "9", "Body": "<p>Let's say I have two different classes, both represent 2D coordinate data in the same internal way like the following:</p>\n<pre><code>class LibA_Vertex{\n    public:\n    // ... constructors and various methods, operator overloads\n    float x, y\n};\n\nclass LibB_Vertex{\n    public:\n    // ... same usage and internal data as LibA, but with different methods\n    float x, y\n};\n\n\nvoid foobar(){\n    LibA_Vertex * verticesA = new LibA_Vertex[1000];\n    verticesA[50].y = 9;\n    LibB_Vertex * verticesB = reinterpret_cast&lt;LibB_Vertex*&gt;( vertexA );\n    print(verticesB[50].y); // should output a \"9\"\n};\n</code></pre>\n<p>Given the two classes being identical and the function above, can I reliably count on this pointer conversion working as expected in every case?   </p>\n<p>(The background, is that I need an easy way of trading vertex arrays between two separate libraries that have identical Vertex classes, and I want to avoid needlessly copying arrays).</p>\n", "Tags": "<c++><pointers><casting>", "OwnerUserId": "620863", "AnswerCount": "4"}, "7762973": {"ParentId": "7762929", "CommentCount": "1", "Body": "<p>Theoretically this is an undefined behavior. However, it may work in certain systems/platforms.</p>\n<p>I would suggest that you should <strong>try to merge</strong> 2 classes into 1. i.e.</p>\n<pre><code>class Lib_Vertex{\n// data (which is exactly same for both classes)\npublic:\n// methods for LibA_Vertex\n// methods for LibB_Vertex\n};\n</code></pre>\n<p>Adding methods into a <code>class</code> will not affect its size. You may have to change your design a bit but it's worth it.</p>\n", "OwnerUserId": "514235", "PostTypeId": "2", "Id": "7762973", "Score": "1", "CreationDate": "2011-10-14T04:17:51.517", "LastActivityDate": "2011-10-14T04:17:51.517"}, "7762964": {"ParentId": "7762929", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>C++11 added a concept called <em>layout-compatible</em> which applies here.</p>\n<blockquote>\n<p id=\"so_7762929_7762964_0\">Two <em>standard-layout struct</em> (Clause 9) types are <em>layout-compatible</em> if they have the same number of non-static data members and corresponding non-static data members (in declaration order) have <em>layout-compatible</em> types (3.9).</p>\n</blockquote>\n<p>where</p>\n<blockquote>\n<p id=\"so_7762929_7762964_1\">A standard-layout class is a class that:</p>\n<ul>\n<li>has no non-static data members of type non-standard-layout class (or array of such types) or reference,</li>\n<li>has no virtual functions (10.3) and no virtual base classes (10.1),</li>\n<li>has the same access control (Clause 11) for all non-static data members,</li>\n<li>has no non-standard-layout base classes,</li>\n<li>either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members, and</li>\n<li>has no base classes of the same type as the first non-static data member.</li>\n</ul>\n<p id=\"so_7762929_7762964_2\">A <em>standard-layout struct</em> is a <em>standard-layout class</em> defined with the <em>class-key</em> <code>struct</code> or the <em>class-key</em> <code>class</code>.</p>\n<p id=\"so_7762929_7762964_3\">A <em>standard-layout union</em> is a <em>standard-layout class</em> defined with the <em>class-key</em> <code>union</code>.</p>\n</blockquote>\n<p>Finally</p>\n<blockquote>\n<p id=\"so_7762929_7762964_4\">Pointers to cv-qualified and cv-unqualified versions (3.9.3) of layout-compatible\n  types shall have the same value representation and alignment requirements (3.11).</p>\n</blockquote>\n<p>Which guarantees that <code>reinterpret_cast</code> can turn a pointer to one type into a pointer to any layout-compatible type.</p>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2011-10-14T04:27:07.197", "Id": "7762964", "Score": "13", "CreationDate": "2011-10-14T04:15:38.237", "LastActivityDate": "2011-10-14T04:27:07.197"}, "7763001": {"ParentId": "7762929", "CommentCount": "0", "Body": "<p>Technically this is undefined behavior. In reality, if the same compiler was used to compile both classes, they'll have the same layout in memory if the fields are declared in the same order, have the same types and the same access level.</p>\n", "OwnerUserId": "531578", "PostTypeId": "2", "Id": "7763001", "Score": "0", "CreationDate": "2011-10-14T04:23:07.670", "LastActivityDate": "2011-10-14T04:23:07.670"}, "bq_ids": {"n4140": {"so_7762929_7762964_2": {"section_id": 5852, "quality": 1.0, "length": 9}, "so_7762929_7762964_4": {"section_id": 7223, "quality": 0.8571428571428571, "length": 12}, "so_7762929_7762964_0": {"section_id": 5876, "quality": 0.9545454545454546, "length": 21}, "so_7762929_7762964_3": {"section_id": 5852, "quality": 1.0, "length": 7}}, "n3337": {"so_7762929_7762964_2": {"section_id": 5622, "quality": 1.0, "length": 9}, "so_7762929_7762964_4": {"section_id": 6967, "quality": 0.8571428571428571, "length": 12}, "so_7762929_7762964_0": {"section_id": 5647, "quality": 1.0, "length": 22}, "so_7762929_7762964_3": {"section_id": 5622, "quality": 1.0, "length": 7}}, "n4659": {"so_7762929_7762964_2": {"section_id": 7331, "quality": 0.8888888888888888, "length": 8}, "so_7762929_7762964_4": {"section_id": 8732, "quality": 0.6428571428571429, "length": 9}, "so_7762929_7762964_0": {"section_id": 7361, "quality": 0.8181818181818182, "length": 18}, "so_7762929_7762964_3": {"section_id": 7331, "quality": 1.0, "length": 7}}}});