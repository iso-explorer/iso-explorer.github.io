post_cb({"bq_ids": {"n4140": {"so_30461583_30461995_0": {"length": 6, "quality": 1.0, "section_id": 3325}}, "n3337": {"so_30461583_30461995_0": {"length": 6, "quality": 1.0, "section_id": 3195}}, "n4659": {"so_30461583_30461995_0": {"length": 6, "quality": 1.0, "section_id": 4091}}}, "30461995": {"Id": "30461995", "PostTypeId": "2", "Body": "<p>I believe this is a clang bug. According to the rules for list-initialization in [dcl.init.list]:</p>\n<blockquote>\n<p id=\"so_30461583_30461995_0\">List-initialization of an object or reference of type <code>T</code> is defined as follows:</p>\n<ul>\n<li>If <code>T</code> is a class type and the initializer list has a single element of type <em>cv</em> <code>U</code>, where <code>U</code> is <code>T</code> or a class derived from <code>T</code>, [...]</li>\n<li>Otherwise, if <code>T</code> is a character array and [...]</li>\n<li>Otherwise, if <code>T</code> is an aggregate, [...]</li>\n<li>Otherwise, if the initializer list has no elements [...]</li>\n<li>Otherwise, if <code>T</code> is a specialization of <code>std::initializer_list&lt;E&gt;</code>, [...]</li>\n<li>Otherwise, if <code>T</code> is a class type, constructors are considered. The applicable constructors are enumerated\n  and the best one is chosen through overload resolution (13.3, 13.3.1.7). If a narrowing conversion (see\n  below) is required to convert any of the arguments, the program is ill-formed.</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p><code>T</code> is a class type, so we consider the <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/basic_string\" rel=\"nofollow\"><code>basic_string</code> constructors</a>. #7 in that list (the copy constructor) is an applicable, viable constructor and so it should be chosen. At that point, these expressions should be equivalent:</p>\n<pre><code>struct Foo {\n    operator std::string() const { return \"hello\"; }\n};\n\nstd::string s{Foo{}};  // error\nstd::string s(Foo{});  // OK\nstd::string s = Foo{}; // OK\n</code></pre>\n<p>For some reason though, in the list-initialization case, clang complains that there is:</p>\n<blockquote>\n<p id=\"so_30461583_30461995_1\">no known conversion from <code>Foo</code> to <code>const std::__cxx11::basic_string&lt;char&gt; &amp;</code> for 1st argument</p>\n</blockquote>\n<p>There is though, so I filed this as <a href=\"https://llvm.org/bugs/show_bug.cgi?id=23658\" rel=\"nofollow\">LLVM Bug 23658</a>.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-05-26T15:22:00.937", "Score": "6", "CreationDate": "2015-05-26T14:51:36.907", "ParentId": "30461583", "CommentCount": "6", "OwnerUserId": "2069064", "LastEditDate": "2015-05-26T15:22:00.937"}, "30461583": {"ViewCount": "1362", "Body": "<p>Here is the code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std; \n\nclass Foo { \npublic:\n    operator string() const { return n; }\n    string n {\"foo\"};\n};\n\nint main (int argc, char** argv) {\n\n    string s {Foo{}};\n    cout &lt;&lt; s &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>This code compiles using gcc 4.8.3, but it does not compile using clang 3.5, can someone tell me what's wrong with it? </p>\n<p>I got an error like this:</p>\n<pre><code>main.cpp:45:12: error: no matching constructor for initialization of 'string' (aka 'basic_string&lt;char&gt;')\n    string s {Foo{}};\n           ^ ~~~~~~~\n</code></pre>\n<p>clang --version:</p>\n<pre><code>clang version 3.5.0 (tags/RELEASE_350/final 216961)\nTarget: x86_64-suse-linux\nThread model: posix\n</code></pre>\n<p>Thanks</p>\n", "AcceptedAnswerId": "30461995", "Title": "no matching constructor for initialization of 'string' (aka 'basic_string<char>')", "CreationDate": "2015-05-26T14:34:47.753", "Id": "30461583", "CommentCount": "2", "LastEditDate": "2015-05-26T15:06:37.767", "PostTypeId": "1", "LastEditorUserId": "3671410", "LastActivityDate": "2015-05-26T15:22:00.937", "Score": "2", "OwnerUserId": "3671410", "Tags": "<c++><string><c++11><clang>", "AnswerCount": "1"}});