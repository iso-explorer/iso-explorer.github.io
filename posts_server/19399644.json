post_cb({"19399644": {"ViewCount": "723", "Body": "<p>I'm about to create an exception class hierarchy which conceptually looks somewhat like this:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n\nclass ExceptionBase : public std::runtime_error {\npublic: \n    ExceptionBase( const char * msg ) : std::runtime_error(msg) {}\n};\n\nclass OperationFailure : virtual public ExceptionBase {\npublic: \n    using ExceptionBase::ExceptionBase;\n};\n\nclass FileDoesNotExistError : virtual public ExceptionBase {\npublic: \n    using ExceptionBase::ExceptionBase;\n};\n\nclass OperationFailedBecauseFileDoesNotExistError\n    : public OperationFailure, FileDoesNotExistError {\npublic: \n    using ExceptionBase::ExceptionBase; // does not compile\n};\n\nint main() {\n    OperationFailedBecauseFileDoesNotExistError e(\"Hello world!\\n\");\n\n    std::cout &lt;&lt; e.what();\n}\n</code></pre>\n<p>All constructors should look the same as the constructor of the <code>ExceptionBase</code> class. The derived exceptions only differ concerning their type, there's no added functionality otherwise. The last exception type mentioned in the above code should also have these constructors. Is this possible using the inheriting constructors feature of the C++11 standard? If that is not possible: what are alternatives?</p>\n<p>(By the way: In the above code the classes <code>OperationFailure</code> and <code>FileDoesNotExistError</code> did not compile with gcc 4.8, but with clang 3.4. Apparently, gcc rejects inheriting constructors for virtual bases. It would be interesting to know who's right here. Both compilers rejected the class <code>OperationFailedBecauseFileDoesNotExistError</code>, because the inheriting constructor does not inherit from a direct base.)</p>\n", "AcceptedAnswerId": "19405833", "Title": "Inheriting constructors and virtual base classes", "CreationDate": "2013-10-16T09:23:55.193", "Id": "19399644", "CommentCount": "5", "LastEditDate": "2013-10-16T11:04:56.913", "PostTypeId": "1", "LastEditorUserId": "1335865", "LastActivityDate": "2013-10-16T14:47:16.783", "Score": "6", "OwnerUserId": "1335865", "Tags": "<c++><c++11><virtual-inheritance><inheriting-constructors>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_19399644_19405833_0": {"length": 20, "quality": 1.0, "section_id": 5492}}, "n3337": {"so_19399644_19405833_0": {"length": 20, "quality": 1.0, "section_id": 5278}}, "n4659": {"so_19399644_19405833_0": {"length": 11, "quality": 0.55, "section_id": 6926}}}, "19400478": {"Id": "19400478", "PostTypeId": "2", "Body": "<p>Inhering constructors is like introducing wrapper functions for all the constructors you have specified. In your case, you must call the specific constructors of both <code>OperationFailure</code> and <code>FileDoesNotExistError</code> but the introduced wrappers will only call either of them.</p>\n<hr>\n<p>I just checked <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow\">the latest C++11 draft</a> (section 12.9) but it doesn't really explicitly cover your case.</p>\n</hr>", "LastEditorUserId": "133374", "LastActivityDate": "2013-10-16T10:11:49.887", "Score": "1", "CreationDate": "2013-10-16T10:04:01.077", "ParentId": "19399644", "CommentCount": "3", "OwnerUserId": "133374", "LastEditDate": "2013-10-16T10:11:49.887"}, "19405833": {"Id": "19405833", "PostTypeId": "2", "Body": "<p>When the <em>using-declaration</em> is used to inherit constructors, it requires a direct base class [namespace.udecl]/3</p>\n<blockquote>\n<p id=\"so_19399644_19405833_0\">If such a <em>using-declaration</em> names a constructor, the <em>nested-name-specifier</em> shall name a direct base class of the class being defined; otherwise it introduces the set of declarations found by member name lookup.</p>\n</blockquote>\n<p>I.e. in your case, the <em>using-declaration</em> in <code>OperationFailedBecauseFileDoesNotExistError</code> doesn't inherit, but re-declares (as an alias), or unhides, the name of the ctor of <code>ExceptionBase</code>.</p>\n<p>You'll have to write a non-inheriting ctor for <code>OperationFailedBecauseFileDoesNotExistError</code>.</p>\n<hr>\n<p>By the way, this is fine for non-virtual base classes: The using-declaration for inheriting ctors is rewritten as:</p>\n<pre><code>//using ExceptionBase::ExceptionBase;\n\nOperationFailure(char const * msg)\n: ExceptionBase( static_cast&lt;const char*&amp;&amp;&gt;(msg) )\n{}\n</code></pre>\n<p>As you may only initialize a direct base class (or virtual base class) in the <em>mem-initializer-list</em>, it makes sense for non-virtual base classes to restrict the <em>using-declaration</em> to inherit ctors only from direct base classes.</p>\n<p>The authors of the inheriting ctors proposal have been aware that this breaks support for virtual base class ctors, see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2540.htm\" rel=\"nofollow\">N2540</a>:</p>\n<blockquote>\n<p id=\"so_19399644_19405833_1\">Typically, inheriting constructor definitions for classes with virtual bases will be ill-formed, unless the virtual base supports default initialization, or the virtual base is a direct base, and named as the base forwarded-to. Likewise, all data members and other direct bases must support default initialization, or any attempt to use a inheriting constructor will be ill-formed. Note: ill-formed when used, not declared. </p>\n</blockquote>\n</hr>", "LastEditorUserId": "420683", "LastActivityDate": "2013-10-16T14:47:16.783", "Score": "2", "CreationDate": "2013-10-16T14:15:33.143", "ParentId": "19399644", "CommentCount": "0", "OwnerUserId": "420683", "LastEditDate": "2013-10-16T14:47:16.783"}});