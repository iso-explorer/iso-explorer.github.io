post_cb({"29989381": {"ParentId": "29989250", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>By default c++ <strong><code>class</code></strong> members are <code>private</code>, so without specifying you get a private variable. Because you made the types private you do not get the aggregate-initialization for free anymore so you need to write your own  constructor for this class:</p>\n<pre><code>class C{\n    C(int _a, int _b):\n    a(_a), b(_b)\n    {}\n};\n</code></pre>\n<p>You just need to fix the namespacing for the <code>cout</code> and your code should compile fine: <a href=\"http://coliru.stacked-crooked.com/a/1d69f4f141d2bcd2\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/1d69f4f141d2bcd2</a></p>\n<p>From the standard:</p>\n<blockquote>\n<p id=\"so_29989250_29989381_0\">[dcl.init.aggr] An <em>aggregate</em> is an array or a class with no user-provided constructors, no brace-or-equal-initializers for non-static data members, no private or protected non-static data members, no base classes, and no virtual functions</p>\n</blockquote>\n<p>In the first code you only had public variables so the code worked because you had an aggregate, making the variable private is what caused the problem because it was no longer an aggregate according to the above definition. </p>\n", "OwnerUserId": "296460", "LastEditorUserId": "3777958", "LastEditDate": "2015-08-25T05:49:57.870", "Id": "29989381", "Score": "3", "CreationDate": "2015-05-01T15:02:30.873", "LastActivityDate": "2015-08-25T05:49:57.870"}, "29989338": {"ParentId": "29989250", "CommentCount": "0", "Body": "<p>You need to move the line <code>int a,b;</code> into the <code>public:</code> scope like the first example.</p>\n<p>You also need <code>std::</code> in front of <code>cout</code> </p>\n<pre><code>#include &lt;iostream&gt;\nclass C {\n    public:\n        int a,b;     //Make public\n        int get_a(){\n            return a;\n        }\n        int get_b(){\n            return b;\n        }\n};\nint main(){\n    C c{3,6};\n    std::cout&lt;&lt;c.get_a()&lt;&lt;'\\n';   //use namespace std::\n    std::cout&lt;&lt;c.get_b()&lt;&lt;'\\n';   //use namespace std::\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "588734", "PostTypeId": "2", "Id": "29989338", "Score": "1", "CreationDate": "2015-05-01T15:00:31.347", "LastActivityDate": "2015-05-01T15:00:31.347"}, "29989360": {"ParentId": "29989250", "CommentCount": "4", "Body": "<p>The first code worked because the data members <code>a</code> and <code>b</code> were public, so they could be accessed from outside the class. However, in the second code, they are declared as private, so they cannot be accessed from outside the class. Either declare them as public again, or use a constructor as follows (if you still want them as private): </p>\n<pre><code> C(int x,int y)   // This is a parameterised constructor\n    {\n        a=x;\n        b=y;\n    }\n</code></pre>\n<p>And initialise them as <code>C c(3,6);</code></p>\n", "OwnerUserId": "4427938", "PostTypeId": "2", "Id": "29989360", "Score": "1", "CreationDate": "2015-05-01T15:01:50.497", "LastActivityDate": "2015-05-01T15:01:50.497"}, "29989310": {"ParentId": "29989250", "CommentCount": "0", "Body": "<p><code>a</code> and <code>b</code> are <code>private</code> in your second example and are therefore inaccessible from outside the class.</p>\n", "OwnerUserId": "4342498", "PostTypeId": "2", "Id": "29989310", "Score": "1", "CreationDate": "2015-05-01T14:58:52.803", "LastActivityDate": "2015-05-01T14:58:52.803"}, "29989340": {"ParentId": "29989250", "CommentCount": "0", "Body": "<p>In the modified version of the code, you moved the <code>public:</code> label so the <code>a</code> and <code>b</code> data members are no longer public. Hence, they cannot be referenced from outside the class, even not implicitly by an initializer list.</p>\n", "OwnerUserId": "2422776", "PostTypeId": "2", "Id": "29989340", "Score": "1", "CreationDate": "2015-05-01T15:00:34.737", "LastActivityDate": "2015-05-01T15:00:34.737"}, "29989250": {"CommentCount": "3", "ViewCount": "82", "PostTypeId": "1", "LastEditorUserId": "2422776", "CreationDate": "2015-05-01T14:55:53.183", "LastActivityDate": "2015-08-25T05:49:57.870", "Title": "clarification of initialization in C++", "AcceptedAnswerId": "29989381", "LastEditDate": "2015-05-01T15:02:23.573", "Id": "29989250", "Score": "0", "Body": "<p>I am really getting confused in following examples:</p>\n<pre><code>#include &lt;iostream&gt;\nclass C {\n    public:\n    int a,b;\n};\nint main() {\n    C c{3,6};\n    std::cout&lt;&lt;c.a&lt;&lt;'\\n';\n    std::cout&lt;&lt;c.b&lt;&lt;'\\n';\n    return 0;\n}\n</code></pre>\n<p>It works fine and gives the expected outcome. But if I modify the above code like below.</p>\n<pre><code>#include &lt;iostream&gt;\nclass C {\n    int a,b;\n    public:\n        int get_a(){\n            return a;\n        }\n        int get_b(){\n            return b;\n        }\n};\nint main(){\n    C c{3,6};\n    std::cout&lt;&lt;c.get_a()&lt;&lt;'\\n';\n    std::cout&lt;&lt;c.get_b()&lt;&lt;'\\n';\n    return 0;\n}\n</code></pre>\n<p>In the above program compiler shows multiple errors. Why uniform initialization allowed in first program but not in second? Where I am wrong? </p>\n", "Tags": "<c++><initialization><uniform-initialization>", "OwnerUserId": "3777958", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_29989250_29989381_0": {"section_id": 3298, "quality": 0.6842105263157895, "length": 13}}, "n3337": {"so_29989250_29989381_0": {"section_id": 3168, "quality": 0.8947368421052632, "length": 17}}, "n4659": {"so_29989250_29989381_0": {"section_id": 4063, "quality": 0.5263157894736842, "length": 10}}}});