post_cb({"23603877": {"ParentId": "23603576", "CommentCount": "0", "Body": "<p>Here is my take on the standard:</p>\n<p>From [basic.lookup.argdep] (2):</p>\n<blockquote>\n<p id=\"so_23603576_23603877_0\">\u2014 If T is a class type (including unions), its associated classes are:\n  the class itself; the class of which it is a member, if any; and its\n  direct and indirect base classes. Its associated namespaces are the\n  innermost enclosing namespaces of its associated classes.</p>\n</blockquote>\n<p>From [basic.namespace] (2) (and 3.3.6 where <code>global namespace</code> is defined):</p>\n<blockquote>\n<p id=\"so_23603576_23603877_1\">The outermost declarative region of a translation unit is a namespace; see 3.3.6.</p>\n</blockquote>\n<p>So I don't see anything to exclude the global namespace from ADL.</p>\n", "OwnerUserId": "596167", "PostTypeId": "2", "Id": "23603877", "Score": "1", "CreationDate": "2014-05-12T08:04:45.430", "LastActivityDate": "2014-05-12T08:04:45.430"}, "23603805": {"ParentId": "23603576", "CommentCount": "2", "Body": "<p>The global namespace is not special in this regard, it works just like any other namespace and is thus perfectly fine for your use case.</p>\n<p><a href=\"http://ideone.com/7oZDdg\" rel=\"nofollow\"><strong>Live example 1</strong></a> of global namespace working.</p>\n<p><a href=\"http://ideone.com/n69opD\" rel=\"nofollow\"><strong>Live example 2</strong></a> of ADL actually being the reason #1 works<sup>1</sup>.</p>\n<p>Here's the text of the live example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct X {};\n\ntemplate &lt;class T&gt;\nvoid bar(T t)\n{\n  foo(t);\n}\n\nvoid foo(X x)\n{\n  std::cout &lt;&lt; \"Foo\\n\";\n}\n\nint main()\n{\n  X x;\n  bar(x);\n}\n</code></pre>\n<p><sup>1</sup> This fails, because ADL cannot find the function, while normal lookup would. So it proves that #1 really works thanks to ADL.</p>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "23603805", "Score": "2", "CreationDate": "2014-05-12T08:00:07.080", "LastActivityDate": "2014-05-12T08:00:07.080"}, "23603576": {"CommentCount": "6", "AcceptedAnswerId": "23603805", "CreationDate": "2014-05-12T07:45:12.487", "LastActivityDate": "2014-05-12T08:04:45.430", "PostTypeId": "1", "ViewCount": "66", "FavoriteCount": "1", "Title": "Argument dependent lookup for classes in top-level namespace?", "Id": "23603576", "Score": "1", "Body": "<p>I have a class that is in top-level namespace for historical reasons. I need to define a function for it that must<sup>1</sup> be found using argument-dependent lookup. Is the top-level namespace considered associated namespace of such class or do I have to make some workaround?</p>\n<p><sup>1</sup><sub>Otherwise the template that uses it might not find it, because symbols defined after the template are only seen when found by ADL.</sub></p>\n", "Tags": "<c++><c++03><argument-dependent-lookup>", "OwnerUserId": "201725", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_23603576_23603877_0": {"section_id": 7104, "quality": 1.0, "length": 25}, "so_23603576_23603877_1": {"section_id": 5472, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_23603576_23603877_0": {"section_id": 6848, "quality": 0.96, "length": 24}, "so_23603576_23603877_1": {"section_id": 5258, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_23603576_23603877_0": {"section_id": 8605, "quality": 1.0, "length": 25}, "so_23603576_23603877_1": {"section_id": 6907, "quality": 0.7777777777777778, "length": 7}}}});