post_cb({"19073335": {"ParentId": "19073325", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>In this case there is no need for it.</p>\n<p>The <code>L</code> indicates a long value which means it reserves more space just your calculation will go beyond the range of a normal integer.</p>\n", "OwnerUserId": "54017", "LastEditorUserId": "54017", "LastEditDate": "2013-09-29T12:42:42.203", "Id": "19073335", "Score": "0", "CreationDate": "2013-09-29T00:52:40.280", "LastActivityDate": "2013-09-29T12:42:42.203"}, "19073408": {"ParentId": "19073325", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The <code>L</code> suffix is used to signify that a number literal is of type <code>long int</code>. Normally it is not necessary if you are just assigning the value to a variable, since, as for C++11 \u00a72.14.2 \u00b62 (and in particular table 6), a decimal integer literal without suffix will be of the first type that can represent it between <code>int</code>, <code>long int</code> or <code>long long int</code>.<sup>1</sup></p>\n<p>So, you <em>don't</em> risk to have the value itself truncated; but:</p>\n<ol>\n<li>you do have a certain degree of uncertainty about the type of the literal (<code>32768</code> may be an <code>int</code> or a <code>long</code>, depending from the platform/compiler);</li>\n<li>you may inadvertently get a literal of the wrong type for your specific expression.</li>\n</ol>\n<p>So, you need to specify <code>L</code> instead in contexts where you want to be sure that the type of the literal is <code>long</code> (or bigger); two important cases come to mind:</p>\n<ul>\n<li><p>resolving overloads; if you have two overloads of a function, one for <code>int</code> and one for <code>long</code>, and you want to be sure to call the <code>long</code> one even if you are passing a small number, you'll have to use a <code>long</code> literal;</p>\n<pre><code>void foo(int);\nvoid foo(long);\n\nfoo(1);      // &lt;-- will call the first overload\nfoo(1L);     // &lt;-- will call the second overload\nfoo(32768);  // &lt;-- may call the first or the second overload, depending\n             //     from the specific platform\nfoo(32768L); // &lt;-- will call the second overload\n</code></pre></li>\n<li><p>but most importantly: avoid surprises when doing arithmetic; if you perform e.g. a multiplication like this:</p>\n<pre><code>int a;\n...\nlong v=32767*a; // don't let the \"long\" fool you - 32767*a is evaluated as an int!\n</code></pre>\n<p><code>32767</code> is an <code>int</code> literal (since it's small enough to fit an <code>int</code>), <code>a</code> is an <code>int</code>, and the result will be an <code>int</code>, even if you are assigning to a <code>long</code>. This may be a problem if <code>a</code> can be big enough to overflow your calculation; by specifying a <code>long</code> literal, you guarantee that you'll perform a <code>long</code> multiplication.</p>\n<pre><code>long v=32767L*a; // now we are doing all the math with longs\n</code></pre>\n<p>(This problem is actually <em>way</em> more frequent with division and FP literals, where often you have to specify <code>double</code> or <code>float</code> literals to get the intended \"real division\" behavior)</p>\n<p>As <em>@chris</em> suggests, a way more frequent situation (of this same kind) arises when doing \"big\" bitshifts, e.g.:</p>\n<pre><code>long long mask=1&lt;&lt;53;\n</code></pre>\n<p>presents the same problem as above: <code>1</code> is an <code>int</code>, <code>53</code> is an <code>int</code>, the computation will be performed with <code>int</code>s, resulting in overflow (although in this particular case any decent compiler will issue a warning); here the correct form would be:</p>\n<pre><code>long long mask=1LL&lt;&lt;53; // LL is the suffix for long long\n</code></pre></li>\n</ul>\n<hr>\n<p>Coming to your particular code: there's no risk in taking the <code>L</code> away; since <code>number</code> is already a <code>long</code>, <code>2</code> will be promoted to <code>long</code> anyway in doing the modulo (as per the \"usual arithmetic conversions\", \u00a75 \u00b610, and \u00a74.5), so here <code>L</code> makes no difference.</p>\n<p>Still, in many cases it's not a bad idea to keep the literal of the \"intended type\": it guarantees that, even if the type of the other operand is changed for some reason to a narrower type, the computation will still be done in the intended way (not that for modulo it would make any difference).</p>\n<hr>\n<ol>\n<li><blockquote>\n<p id=\"so_19073325_19073408_0\">The type of an integer literal is the first of the corresponding list in Table 6 in which its value can be\n  represented.\n  <img alt=\"table from the C++11 standard describing the type to be used for integer literals\" src=\"https://i.stack.imgur.com/dbQxG.png\"/></p>\n</blockquote></li>\n</ol>\n</hr></hr>", "OwnerUserId": "214671", "LastEditorUserId": "214671", "LastEditDate": "2013-09-29T01:46:38.353", "Id": "19073408", "Score": "11", "CreationDate": "2013-09-29T01:06:31.767", "LastActivityDate": "2013-09-29T01:46:38.353"}, "bq_ids": {"n4140": {"so_19073325_19073408_0": {"section_id": 5341, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_19073325_19073408_0": {"section_id": 5138, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_19073325_19073408_0": {"section_id": 6762, "quality": 0.8333333333333334, "length": 10}}}, "19073325": {"CommentCount": "6", "ViewCount": "114", "CreationDate": "2013-09-29T00:50:37.890", "LastActivityDate": "2013-09-29T12:42:42.203", "Title": "What is the point of 'L' here?", "PostTypeId": "1", "Id": "19073325", "Score": "3", "Body": "<pre><code>//Using the if-else\n#include &lt;iostream&gt;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\nint main() {\n  long number = 0;                  // Store input here\n  cout &lt;&lt; \"Enter an integer less than 2 billion: \";\n  cin &gt;&gt; number;\n  cout &lt;&lt; endl;\n\n  if(number % 2L == 0)              // Test remainder after division by 2\n    cout &lt;&lt; \"Your number is even.\"  // Here if remainder is 0\n         &lt;&lt; endl;\n  else\n    cout &lt;&lt; \"Your number is odd.\"   // Here if remainder is 1\n         &lt;&lt; endl;\n  return 0;\n}\n</code></pre>\n<p>Here, in the first 'if' condition, why do they have 'L' after 2? taking 'L' out seems to run the code just fine. </p>\n", "Tags": "<c++>", "OwnerUserId": "2826094", "AnswerCount": "2"}});