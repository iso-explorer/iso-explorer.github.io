post_cb({"19648782": {"Id": "19648782", "PostTypeId": "2", "Body": "<p>Maybe I'm mistaken, but ... my understanding is that all rtti implementations involve some kind of lookup/search to find the type of an object passed to dynamic_cast or typeinfo.</p>\n<p>Barring quantum effects, this search must take a measurable number of cycles to complete and, in the OP's code, the search result is cached, while in the dynamic_cast examples the search is repeated in each conditional.</p>\n<p>Therefore the cached version must be faster.  Keeping in mind caveats about premature optimization, I think it is also easy on the eye.</p>\n<p>Nicht war?</p>\n<p>PS: Tried this and it doesn't work.  Hmmm.  Anybody suggest why?</p>\n", "LastEditorUserId": "2930415", "LastActivityDate": "2013-10-29T03:37:28.103", "Score": "0", "CreationDate": "2013-10-29T02:49:57.277", "ParentId": "6025466", "CommentCount": "0", "OwnerUserId": "2930415", "LastEditDate": "2013-10-29T03:37:28.103"}, "6025485": {"Id": "6025485", "PostTypeId": "2", "Body": "<p><a href=\"https://stackoverflow.com/questions/28002/regular-cast-vs-static-cast-vs-dynamic-cast\">This</a> seems like a pretty solid answer.  Basically static cast is faster but doesn't do runtime type checking.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-05-17T02:03:26.077", "Score": "0", "CreationDate": "2011-05-17T02:03:26.077", "ParentId": "6025466", "CommentCount": "1", "OwnerUserId": "512947", "LastEditDate": "2017-05-23T12:12:03.910"}, "6025466": {"ViewCount": "1888", "Body": "<p>I copy the following text from the book More Effective C++.</p>\n<p><strong>Item 31:  Making functions virtual with respect to more than one object.</strong> </p>\n<pre><code>class GameObject { ... };\nclass SpaceShip: public GameObject { ... };\nclass SpaceStation: public GameObject { ... };\nclass Asteroid: public GameObject { ... };\n</code></pre>\n<p>The most common approach to double-dispatching returns us to the unforgiving world of virtual function emulation via chains of if-then-elses. In this harsh world, we first discover the real type of otherObject, then we test it against all the possibilities: </p>\n<pre><code>void SpaceShip::collide(GameObject&amp; otherObject)\n{\n  const type_info&amp; objectType = typeid(otherObject);\n\n  if (objectType == typeid(SpaceShip)) {\n    SpaceShip&amp; ss = static_cast&lt;SpaceShip&amp;&gt;(otherObject);\n\n    process a SpaceShip-SpaceShip collision;\n\n  }\n  else if (objectType == typeid(SpaceStation)) {\n    SpaceStation&amp; ss =\n      static_cast&lt;SpaceStation&amp;&gt;(otherObject);\n\n    process a SpaceShip-SpaceStation collision;\n\n  }\n...\n}\n</code></pre>\n<p>Here is the question:</p>\n<p>Q1&gt; Why we use static_cast here rather than obvious dynamic_cast?   </p>\n<p>Q2&gt;\u3000Are they same in this case?</p>\n<p>thank you</p>\n<p>// updated //</p>\n<p>In fact, I am more interested in question 2. </p>\n<p>For example,</p>\n<pre><code>class base {};\nclass subclass : public base {};\n\nbase *pSubClass = new subclass;\n\nsubclass *pSubClass1 = static_cast&lt;subClass*&gt; (pSubClass); \n</code></pre>\n<p>// does the static_cast do the job correctly in this case although I know we should use dynamic_cast here?</p>\n", "AcceptedAnswerId": "6025575", "Title": "Why use static_cast rather than dynamic_cast in here?", "CreationDate": "2011-05-17T01:59:50.837", "Id": "6025466", "CommentCount": "1", "LastEditDate": "2011-05-17T18:40:19.043", "PostTypeId": "1", "LastEditorUserId": "560648", "LastActivityDate": "2013-10-29T03:37:28.103", "Score": "3", "OwnerUserId": "391104", "Tags": "<c++>", "AnswerCount": "7"}, "6026089": {"Id": "6026089", "PostTypeId": "2", "Body": "<p>Some compilers will generate codes that throws <code>std::bad_cast</code> if <code>dynamic_cast</code> fails. So in this case the two approaches are different. Using <code>dynamic_cast</code> may looks like</p>\n<pre><code>try {\n    SpaceShip&amp; ship = dynamic_cast&lt;SpaceShip&amp;&gt;(otherObject);\n    // collision logic\n    return;\n} catch (std::bad_cast&amp;) {}\n\ntry {\n    SpaceStation&amp; station = dynamic_cast&lt;SpaceStation&amp;&gt;(otherObject);\n    // collision logic\n    return;\n} catch (std::bad_cast&amp;) {}\n</code></pre>\n<p>that looks really bad.</p>\n", "LastActivityDate": "2011-05-17T03:58:15.130", "CommentCount": "1", "CreationDate": "2011-05-17T03:58:15.130", "ParentId": "6025466", "Score": "0", "OwnerUserId": "555515"}, "6027372": {"Id": "6027372", "PostTypeId": "2", "Body": "<p><em>Why</em> they chose to implement it this way, instead of the more traditional <code>dynamic_cast</code> I can't say, but the behavior of the two options is not necessarily the same.  As written, that code only considers the actual type of the parameter, while <code>dynamic_cast</code> considers where the parameter falls in an inheritance tree.  Consider:</p>\n<pre><code>struct Base { virtual ~Base() { } };\nstruct Intermediate : Base { };\nstruct Derived : Intermediate { };\n\nint main() {\n    Intermediate i;\n    Base* p_i = &amp;i;\n\n    Derived d;\n    Base* p_d = &amp;d;\n\n    assert(typeid(*p_i) == typeid(Intermediate)); //1\n    assert(dynamic_cast&lt;Intermediate*&gt;(p_i)); //2\n\n    assert(typeid(*p_d) == typeid(Intermediate)); //3\n    assert(dynamic_cast&lt;Intermediate*&gt;(p_d)); //4\n}\n</code></pre>\n<p>(1) and (2) both pass their assertions, but (3) fails while (4) succeeds.  <code>p_d</code> points to a <code>Derived</code> object, so <code>type_id</code> yields information for a <code>Derived</code> object, which will not compare equal to the information for an <code>Intermediate</code> object.  But <code>Derived</code> derives from <code>Intermediate</code>, so <code>dynamic_cast</code> will happily convert a pointer to <code>Derived</code> to a pointer to <code>Intermediate</code>.</p>\n<p>To put it in terms used in the original question, if <code>otherObject</code> is a <code>Frigate</code>, which derives from <code>SpaceShip</code>, it will not use the \"spaceship&lt;-&gt;spaceship\" collision routine.  There's a good chance this is not the intended behavior; you might want <code>Frigate</code> to use that code, but instead you have to manually add an explicit check for that new type.  </p>\n<p>Of course, if you're only checking against types that are never inherited from, this difference goes away.  Or if you just don't want polymorphic behavior (although that would make the heading somewhat misleading).  In that case, this <em>might</em> be more performant, but that's a giant implementation detail and I certainly wouldn't put money on it in practice.</p>\n<hr>\n<p>Another small, and largely inconsequential, difference occurs if the types are not polymorphic.  In my above code, if you remove the virtual destructor from <code>Base</code>, (2) and (4) now exhibit undefined behavior.  (1) and (3) remain well defined, but are now worthless; both will fail because <code>typeid(*p_i)</code> will yield information about <code>Base</code> rather than <code>Intermediate</code> like it used to.</p>\n</hr>", "LastEditorUserId": "293791", "LastActivityDate": "2011-05-17T16:56:30.623", "Score": "1", "CreationDate": "2011-05-17T07:03:29.067", "ParentId": "6025466", "CommentCount": "0", "OwnerUserId": "293791", "LastEditDate": "2011-05-17T16:56:30.623"}, "bq_ids": {"n4140": {"so_6025466_6025575_0": {"length": 54, "quality": 0.9, "section_id": 6037}}, "n3337": {"so_6025466_6025575_0": {"length": 56, "quality": 0.9333333333333333, "section_id": 5805}}, "n4659": {"so_6025466_6025575_0": {"length": 49, "quality": 0.8166666666666667, "section_id": 7536}}}, "6025575": {"Id": "6025575", "PostTypeId": "2", "Body": "<p>For the record, here is the idiomatic way of doing that:</p>\n<pre><code>void SpaceShip::collide(GameObject&amp; otherObject)\n{\n    if (SpaceShip* ss = dynamic_cast&lt;SpaceShip*&gt;(&amp;otherObject)) {\n        // process a SpaceShip-SpaceShip collision;\n    }\n    else if (SpaceStation* ss = dynamic_cast&lt;SpaceStation*&gt;(&amp;otherObject)) {\n        // process a SpaceShip-SpaceStation collision;\n    }\n\n    // ...\n}\n</code></pre>\n<p>It's shorter, exhibits identical performance characteristics, and again, most importantly, is idiomatic C++ that won't make other programmers scratch their heads and wonder what the point is.</p>\n<hr>\n<p><strong>EDIT</strong> (in response to the OP's edit):</p>\n<p>Yes, that is well defined behavior. Here's what the C++03 standard says, \u00a75.2.9/8:</p>\n<blockquote>\n<p id=\"so_6025466_6025575_0\">An rvalue of type \u201cpointer to <em>cv1</em> <code>B</code>\u201d, where <code>B</code> is a class type, can be converted to an rvalue of type \u201cpointer to <em>cv2</em> <code>D</code>\u201d, where <code>D</code> is a class derived from <code>B</code>, if a valid standard conversion from \u201cpointer to <code>D</code>\u201d to \u201cpointer to <code>B</code>\u201d exists, <em>cv2</em> is the same cv-qualification as, or greater cv-qualification than, <em>cv1</em>, and <code>B</code> is not a virtual base class of <code>D</code>. The null pointer value is converted to the null pointer value of the destination type. If the rvalue of type \u201cpointer to <em>cv1</em> <code>B</code>\u201d points to a <code>B</code> that is actually a sub-object of an object of type <code>D</code>, the resulting pointer points to the enclosing object of type <code>D</code>. Otherwise, the result of the cast is undefined.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "636019", "LastActivityDate": "2011-05-17T18:38:31.793", "Score": "7", "CreationDate": "2011-05-17T02:22:51.883", "ParentId": "6025466", "CommentCount": "6", "OwnerUserId": "636019", "LastEditDate": "2011-05-17T18:38:31.793"}, "6025490": {"Id": "6025490", "PostTypeId": "2", "Body": "<p>You've already verified the types yourself, so you don't need to use dynamic_cast.  Dynamic_cast will check the types for you automatically.</p>\n", "LastActivityDate": "2011-05-17T02:04:33.350", "CommentCount": "4", "CreationDate": "2011-05-17T02:04:33.350", "ParentId": "6025466", "Score": "3", "OwnerUserId": "744056"}, "6036224": {"Id": "6036224", "PostTypeId": "2", "Body": "<p>First, I think it's important to note that Myers is presenting this code as the first strawman solution for double dispatch before moving on to superior solutions that are not dependent on RTTI.</p>\n<p>To answer the second question first, yes, this is equivalent to implementations using <code>dynamic_cast.</code></p>\n<p><code>static_cast</code> is used here because we have already established that the object is of the targetted type, and thus don't need to pay for run-time checking again.</p>\n<p>So why not use <code>dynamic_cast</code> in the first place?</p>\n<p>My suspicion is that Myers wrote it this way because this was going to be a chain of an indefinite number of <code>if ()</code> checks.  He could have done something like @ildjarn suggests, but that would have involved declaring a new variable for every type he wanted to check it against.  My suspicion is he just liked the aesthetics of what he put up better.  </p>\n", "LastActivityDate": "2011-05-17T19:43:07.240", "CommentCount": "0", "CreationDate": "2011-05-17T19:43:07.240", "ParentId": "6025466", "Score": "0", "OwnerUserId": "1674"}});