post_cb({"bq_ids": {"n4140": {"so_16534931_16535030_0": {"length": 5, "quality": 1.0, "section_id": 744}, "so_16534931_16534996_0": {"length": 7, "quality": 0.7, "section_id": 744}}, "n3337": {"so_16534931_16535030_0": {"length": 5, "quality": 1.0, "section_id": 733}, "so_16534931_16534996_0": {"length": 7, "quality": 0.7, "section_id": 733}}, "n4659": {"so_16534931_16535030_0": {"length": 5, "quality": 1.0, "section_id": 802}, "so_16534931_16534996_0": {"length": 7, "quality": 0.7, "section_id": 802}}}, "16534996": {"Id": "16534996", "PostTypeId": "2", "Body": "<p>It's to make it consistent with other container classes, given that one of the great aspects of polymorphism is to be able to treat different classes with the same API.</p>\n<p>It <em>does</em> actually return the count. The fact that the count can only be zero or one for a set does not change that aspect.</p>\n<p>It's not <em>fundamentally</em> different to a collection object that only allows two things of each \"value\" at the same time. In that case, it would return the count of zero, one or two, but it's still a count, the same as with a set.</p>\n<p>The relevant part of the standard that requires this is <code>C++11 23.2.4</code> which talks about the associative containers <code>set</code>, <code>multiset</code>, <code>map</code> and <code>multimap</code>. Table 102 contains the requirements for these associative containers over and above the requirements for \"regular\" containers, and the bit for <code>count</code> is paraphrased below:</p>\n<blockquote>\n<p id=\"so_16534931_16534996_0\"><code>size_type a.count(k)</code> - returns the number of elements with key equivalent to <code>k</code>. Complexity is <code>log(a.size()) + a.count(k)</code>.</p>\n</blockquote>\n", "LastEditorUserId": "14860", "LastActivityDate": "2017-08-03T01:28:50.137", "Score": "12", "CreationDate": "2013-05-14T04:13:18.780", "ParentId": "16534931", "CommentCount": "3", "OwnerUserId": "14860", "LastEditDate": "2017-08-03T01:28:50.137"}, "16534997": {"Id": "16534997", "PostTypeId": "2", "Body": "<p>It's a standard operation on containers that returns the number of matching elements.  In things like lists, this makes perfect sense.  It just so happens that on a set, there can only be one occurrence of an element and therefore <code>count</code> can never return a value greater than 1.</p>\n", "LastActivityDate": "2013-05-14T04:13:26.630", "CommentCount": "2", "CreationDate": "2013-05-14T04:13:26.630", "ParentId": "16534931", "Score": "-1", "OwnerUserId": "178382"}, "16534931": {"ViewCount": "1352", "Body": "<p>What it really checks for is contains() and not the count of the number of occurrences, right? Duplicates are not permitted either so wouldn't contains() be a better name than count()?</p>\n", "AcceptedAnswerId": "16534996", "Title": "Why is the C++ STL set container's count() method thus named?", "CreationDate": "2013-05-14T04:06:58.000", "Id": "16534931", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-08-03T01:28:50.137", "Score": "7", "OwnerUserId": "2380088", "Tags": "<c++><stl><naming-conventions><naming>", "AnswerCount": "3"}, "16535030": {"Id": "16535030", "PostTypeId": "2", "Body": "<p>All associative containers must meet the requirements listed in <em>\u00a723.2.4/8 Table 102 - Associative container requirements</em>. One of these is that they implement <code>a.count(k)</code> which then </p>\n<blockquote>\n<p id=\"so_16534931_16535030_0\">returns the number of elements with key equivalent to k</p>\n</blockquote>\n<p>So the reason is to have a consistent interface between all associative containers. For instance, this uniformity will be very important when writing generic function templates that must work with any associative container.</p>\n", "LastActivityDate": "2013-05-14T04:17:05.983", "CommentCount": "0", "CreationDate": "2013-05-14T04:17:05.983", "ParentId": "16534931", "Score": "4", "OwnerUserId": "241631"}});