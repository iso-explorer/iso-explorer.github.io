post_cb({"16535030": {"ParentId": "16534931", "CommentCount": "0", "Body": "<p>All associative containers must meet the requirements listed in <em>\u00a723.2.4/8 Table 102 - Associative container requirements</em>. One of these is that they implement <code>a.count(k)</code> which then </p>\n<blockquote>\n<p id=\"so_16534931_16535030_0\">returns the number of elements with key equivalent to k</p>\n</blockquote>\n<p>So the reason is to have a consistent interface between all associative containers. For instance, this uniformity will be very important when writing generic function templates that must work with any associative container.</p>\n", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "16535030", "Score": "4", "CreationDate": "2013-05-14T04:17:05.983", "LastActivityDate": "2013-05-14T04:17:05.983"}, "16534931": {"CommentCount": "3", "AcceptedAnswerId": "16534996", "CreationDate": "2013-05-14T04:06:58.000", "LastActivityDate": "2017-08-03T01:28:50.137", "PostTypeId": "1", "ViewCount": "1352", "FavoriteCount": "1", "Title": "Why is the C++ STL set container's count() method thus named?", "Id": "16534931", "Score": "7", "Body": "<p>What it really checks for is contains() and not the count of the number of occurrences, right? Duplicates are not permitted either so wouldn't contains() be a better name than count()?</p>\n", "Tags": "<c++><stl><naming-conventions><naming>", "OwnerUserId": "2380088", "AnswerCount": "3"}, "16534996": {"ParentId": "16534931", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>It's to make it consistent with other container classes, given that one of the great aspects of polymorphism is to be able to treat different classes with the same API.</p>\n<p>It <em>does</em> actually return the count. The fact that the count can only be zero or one for a set does not change that aspect.</p>\n<p>It's not <em>fundamentally</em> different to a collection object that only allows two things of each \"value\" at the same time. In that case, it would return the count of zero, one or two, but it's still a count, the same as with a set.</p>\n<p>The relevant part of the standard that requires this is <code>C++11 23.2.4</code> which talks about the associative containers <code>set</code>, <code>multiset</code>, <code>map</code> and <code>multimap</code>. Table 102 contains the requirements for these associative containers over and above the requirements for \"regular\" containers, and the bit for <code>count</code> is paraphrased below:</p>\n<blockquote>\n<p id=\"so_16534931_16534996_0\"><code>size_type a.count(k)</code> - returns the number of elements with key equivalent to <code>k</code>. Complexity is <code>log(a.size()) + a.count(k)</code>.</p>\n</blockquote>\n", "OwnerUserId": "14860", "LastEditorUserId": "14860", "LastEditDate": "2017-08-03T01:28:50.137", "Id": "16534996", "Score": "12", "CreationDate": "2013-05-14T04:13:18.780", "LastActivityDate": "2017-08-03T01:28:50.137"}, "16534997": {"ParentId": "16534931", "CommentCount": "2", "Body": "<p>It's a standard operation on containers that returns the number of matching elements.  In things like lists, this makes perfect sense.  It just so happens that on a set, there can only be one occurrence of an element and therefore <code>count</code> can never return a value greater than 1.</p>\n", "OwnerUserId": "178382", "PostTypeId": "2", "Id": "16534997", "Score": "-1", "CreationDate": "2013-05-14T04:13:26.630", "LastActivityDate": "2013-05-14T04:13:26.630"}, "bq_ids": {"n4140": {"so_16534931_16535030_0": {"section_id": 744, "quality": 1.0, "length": 5}, "so_16534931_16534996_0": {"section_id": 744, "quality": 0.7, "length": 7}}, "n3337": {"so_16534931_16535030_0": {"section_id": 733, "quality": 1.0, "length": 5}, "so_16534931_16534996_0": {"section_id": 733, "quality": 0.7, "length": 7}}, "n4659": {"so_16534931_16535030_0": {"section_id": 802, "quality": 1.0, "length": 5}, "so_16534931_16534996_0": {"section_id": 802, "quality": 0.7, "length": 7}}}});