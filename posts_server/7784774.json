post_cb({"7784799": {"Id": "7784799", "PostTypeId": "2", "Body": "<p>It should be always evaluated from left to right, as this is the in the definition of the comma operator: \n<a href=\"http://msdn.microsoft.com/en-us/library/2bxt6kc4.aspx\" rel=\"nofollow\">Link</a></p>\n", "LastActivityDate": "2011-10-16T14:09:46.293", "CommentCount": "0", "CreationDate": "2011-10-16T14:09:46.293", "ParentId": "7784774", "Score": "1", "OwnerUserId": "992460"}, "7784793": {"Id": "7784793", "PostTypeId": "2", "Body": "<p>Yes, in C++ the comma operator is a sequence point and those expression will be evaluated in the order they are written. See <code>5.18</code> in the current working draft: </p>\n<blockquote>\n<p id=\"so_7784774_7784793_0\">[snip] is evaluated left-to-right. [snip]</p>\n</blockquote>\n<p>I feel that your question is lacking some explanation as to what you mean by \"side effects\". Every statement in C++ is allowed to have a side effect and so is an overloaded comma operator.</p>\n<p><strong>Why is the statement you have written not valid in a function call?</strong></p>\n<p>It's all about sequence points. In C++ and C it is forbidden to modify a value twice inside between two sequence points. If your example truly uses <code>operator,</code> every self-assignment is inside its own sequence point. If you use it like this <code>foo(c += 2, c -= 2)</code> the order of evaluation is undefined. I'm actually unsure if the second case is undefined behaviour as I do not know if an argument list is one or many sequence points. I ought to ask a question about this.</p>\n", "LastEditorUserId": "105672", "LastActivityDate": "2011-10-16T14:27:06.777", "Score": "4", "CreationDate": "2011-10-16T14:08:13.907", "ParentId": "7784774", "CommentCount": "0", "OwnerUserId": "105672", "LastEditDate": "2011-10-16T14:27:06.777"}, "7784792": {"Id": "7784792", "PostTypeId": "2", "Body": "<p>Yes, the comma operator guarantees that the statements are evaluated in left-to-right order, and the returned value is the evaluated rightmost statement.</p>\n<p>Be aware, however, that the comma in some contexts is not the <em>comma operator</em>. For example, the above is not guaranteed for function argument lists.</p>\n", "LastActivityDate": "2011-10-16T14:08:03.640", "CommentCount": "0", "CreationDate": "2011-10-16T14:08:03.640", "ParentId": "7784774", "Score": "7", "OwnerUserId": "265804"}, "7784774": {"ViewCount": "636", "Body": "<p>For example for such statement:</p>\n<pre><code>c += 2, c -= 1\n</code></pre>\n<p>Is it true that c += 2 will be always evaluated first, and c in second expression c-= 1 will always be updated value from expression c += 2?</p>\n", "AcceptedAnswerId": "7784819", "Title": "Is comma operator free from side effect?", "CreationDate": "2011-10-16T14:05:29.570", "Id": "7784774", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2011-10-16T22:46:49.263", "Score": "5", "OwnerUserId": "738811", "Tags": "<c++><expression>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_7784774_7784819_4": {"length": 15, "quality": 0.8333333333333334, "section_id": 6182}, "so_7784774_7784819_5": {"length": 4, "quality": 0.8, "section_id": 6182}, "so_7784774_7784819_7": {"length": 25, "quality": 0.5434782608695652, "section_id": 6182}, "so_7784774_7784819_0": {"length": 4, "quality": 0.8, "section_id": 6182}, "so_7784774_7784819_2": {"length": 48, "quality": 0.9230769230769231, "section_id": 6182}}, "n3337": {"so_7784774_7784819_4": {"length": 15, "quality": 0.8333333333333334, "section_id": 5943}, "so_7784774_7784819_5": {"length": 4, "quality": 0.8, "section_id": 5943}, "so_7784774_7784819_7": {"length": 25, "quality": 0.5434782608695652, "section_id": 5943}, "so_7784774_7784819_0": {"length": 4, "quality": 0.8, "section_id": 5943}, "so_7784774_7784819_2": {"length": 48, "quality": 0.9230769230769231, "section_id": 5943}}, "n4659": {"so_7784774_7784819_5": {"length": 4, "quality": 0.8, "section_id": 7684}, "so_7784774_7784819_7": {"length": 26, "quality": 0.5652173913043478, "section_id": 7684}, "so_7784774_7784819_0": {"length": 4, "quality": 0.8, "section_id": 7684}, "so_7784774_7784819_2": {"length": 47, "quality": 0.9038461538461539, "section_id": 7684}}}, "7785060": {"Id": "7785060", "PostTypeId": "2", "Body": "<p>You've got two questions.</p>\n<p>The first question: \"Is comma operator free from side effect?\" </p>\n<p>The answer to this is no. The comma operator naturally facilitates writing expressions with side effects, and deliberately writing expressions with side effects is what the operator is commonly used for. E.g., in <code>while (cin &gt;&gt; str, str != \"exit\")</code> the state of the input stream is changed, which is an intentional side effect.</p>\n<p>But maybe you don't mean side-effect in the computer science sense, but in some ad hoc sense.</p>\n<p>Your second question: \"For example for such statement: <code>c += 2, c -= 1</code> Is it true that c += 2 will be always evaluated first, and c in second expression c-= 1 will always be updated value from expression c += 2?\"</p>\n<p>The answer to this is yes in the case of a statement or expression, except when the comma operator is overloaded (very unusual). However, sequences like <code>c += 2, c -= 1</code> can also occur in argument lists, in which case, what you've got is not an expression, and the comma is not a sequence operator, and the order of evaluation is not defined. In <code>foo(c += 2, c -= 1)</code> the comma is not a comma operator, but in <code>foo((c += 2, c -= 1))</code> it is, so it may pay to pay attention to the parentheses in function calls.</p>\n", "LastEditorUserId": "987411", "LastActivityDate": "2011-10-16T22:25:41.163", "Score": "0", "CreationDate": "2011-10-16T14:56:38.700", "ParentId": "7784774", "CommentCount": "0", "OwnerUserId": "987411", "LastEditDate": "2011-10-16T22:25:41.163"}, "7784819": {"Id": "7784819", "PostTypeId": "2", "Body": "<p>Yes, it is guaranteed by the standard, as long as that comma is a non-overloaded comma operator. Quoting n3290 \u00a75.18:</p>\n<blockquote>\n<p id=\"so_7784774_7784819_0\">The comma operator groups left-to-right.</p>\n<blockquote>\n<p id=\"so_7784774_7784819_3\">expression:<br>\n<code></code>  assignment-expression<br>\n<code></code>  expression , assignment-expression</br></br></p>\n</blockquote>\n<p id=\"so_7784774_7784819_2\">A pair of expressions separated by a comma is evaluated left-to-right; the left expression is a discarded-\n  value expression (Clause 5)<sup>83</sup>. Every value computation and side effect associated with the left expression\n  <strong>is sequenced before</strong> every value computation and side effect associated with the right expression. The type\n  and value of the result are the type and value of the right operand; the result is of the same value category\n  as its right operand, and is a bit-field if its right operand is a glvalue and a bit-field.</p>\n</blockquote>\n<p>And the corresponding footnote:</p>\n<blockquote>\n<p id=\"so_7784774_7784819_4\"><sup>83</sup> However, an invocation of an overloaded comma operator is an ordinary function call; hence, <strong>the evaluations of its argument\n  expressions are unsequenced</strong> relative to one another (see 1.9).</p>\n</blockquote>\n<p>So this holds <strong>only</strong> for the non-overloaded comma operator.</p>\n<p>The <code>,</code> between arguments to a function are not comma operators. This rule does not apply there either.</p>\n<p>For C++03, the situation is similar:</p>\n<blockquote>\n<p id=\"so_7784774_7784819_5\">The comma operator groups left-to-right.</p>\n<blockquote>\n<p id=\"so_7784774_7784819_8\">expression:<br>\n<code></code> assignment-expression<br>\n<code></code> expression , assignment-expression  </br></br></p>\n</blockquote>\n<p id=\"so_7784774_7784819_7\">A pair of expressions separated by a comma is evaluated left-to-right and the value of the left expression is\n  discarded. The lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conver-\n  sions are not applied to the left expression. <em>All side effects (1.9) of the left expression, except for the\n  destruction of temporaries (12.2), are performed before the evaluation of the right expression.</em> The type and\n  value of the result are the type and value of the right operand; the result is an lvalue if its right operand is.</p>\n</blockquote>\n<p>Restrictions are the same though: does not apply to overloaded comma operators, or function argument lists.</p>\n", "LastEditorUserId": "827263", "LastActivityDate": "2011-10-16T22:46:49.263", "Score": "9", "CreationDate": "2011-10-16T14:11:41.267", "ParentId": "7784774", "CommentCount": "2", "OwnerUserId": "635608", "LastEditDate": "2011-10-16T22:46:49.263"}});