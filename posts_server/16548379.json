post_cb({"16548497": {"ParentId": "16548379", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>The problem here is that the point where your call to <code>operator &gt;&gt;</code> is being made is somewhere inside the <code>std</code> namespace, and the namespace where the types of the arguments live is <code>std</code>.</p>\n<p>Provided the compiler can find an <code>operator &gt;&gt;</code> in either the namespace where the call occurs or the namespace where the types of the arguments live (both are the <code>std</code> namespace in this case), no matter whether it is viable or not for overload resolution (which is performed <em>after</em> name lookup), it won't bother looking for more overloads of <code>operator &gt;&gt;</code> in parent namespaces. </p>\n<p>Unfortunately, your <code>operator &gt;&gt;</code> lives in the global namespace and is, therefore, not found.</p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-05-14T16:46:22.543", "Id": "16548497", "Score": "3", "CreationDate": "2013-05-14T16:40:14.920", "LastActivityDate": "2013-05-14T16:46:22.543"}, "16548379": {"CommentCount": "0", "AcceptedAnswerId": "16548497", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-05-14T16:32:51.227", "LastActivityDate": "2013-05-17T02:50:03.987", "LastEditDate": "2017-05-23T10:28:21.260", "ViewCount": "470", "FavoriteCount": "1", "Title": "Dependent name resolution & namespace std / Standard Library", "Id": "16548379", "Score": "6", "Body": "<p>While answering <a href=\"https://stackoverflow.com/q/16544974/420683\">this SO question</a> (better read <a href=\"https://stackoverflow.com/q/4447827/420683\">this \"duplicate\"</a>), I came up with the following solution to dependent name resolution of an operator:</p>\n<p>[temp.dep.res]/1:</p>\n<blockquote>\n<p id=\"so_16548379_16548379_0\">In resolving dependent names, names from the following sources are considered:</p>\n<ul>\n<li>Declarations that are visible at the point of definition of the template.</li>\n<li>Declarations from namespaces associated with the types of the function arguments both from the instantiation context (14.6.4.1) and from the definition context.</li>\n</ul>\n</blockquote>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\n// this operator should be called from inside `istream_iterator`\nstd::istream&amp; operator&gt;&gt;(std::istream&amp; s, std::pair&lt;int,int&gt;&amp; p)\n{\n    s &gt;&gt; p.first &gt;&gt; p.second;\n    return s;\n}\n\n// include definition of `istream_iterator` only after declaring the operator\n// -&gt; temp.dep.res/1 bullet 1 applies??\n#include &lt;iterator&gt;\n\n#include &lt;map&gt;\n#include &lt;fstream&gt;\n\nint main()\n{\n    std::ifstream in(\"file.in\");\n\n    std::map&lt;int, int&gt; pp; \n    pp.insert( std::istream_iterator&lt;std::pair&lt;int, int&gt;&gt;{in},\n               std::istream_iterator&lt;std::pair&lt;int, int&gt;&gt;{} );\n}\n</code></pre>\n<p>But clang++ 3.2 and g++ 4.8 don't find this operator (name resolution).</p>\n<p><strike>Doesn't the inclusion of <code>&lt;iterator&gt;</code> define the \"point of definition of the template\" <code>istream_iterator</code>?</strike></p>\n<p>Edit: As <a href=\"https://stackoverflow.com/users/1932150/andy-prowl\">Andy Prowl</a> points out, this has nothing to do with the Standard Library, but rather with name lookup (can be proven by mimicking the Standard Library with multiple <code>operator&gt;&gt;</code>, at least one in the namespace of the fake <code>istream</code>).</p>\n<hr>\n<p>Edit2: A workaround, using [basic.lookup.argdep]/2 bullet 2</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\n// can include &lt;iterator&gt; already here,\n// as the definition of a class template member function\n// is only instantiated when the function is called (or explicit instantiation)\n// (make sure there are no relevant instantiations before the definition\n//  of the operator&gt;&gt; below)\n#include &lt;iterator&gt;\n\nstruct my_int\n{\n    int m;\n    my_int() : m() {}\n    my_int(int p) : m(p) {}\n    operator int() const { return m; }\n};\n\n// this operator should be called from inside `istream_iterator`\nstd::istream&amp; operator&gt;&gt;(std::istream&amp; s, std::pair&lt;my_int,my_int&gt;&amp; p)\n{\n    s &gt;&gt; p.first.m &gt;&gt; p.second.m;\n    return s;\n}\n\n#include &lt;map&gt;\n#include &lt;fstream&gt;\n\nint main()\n{\n    std::ifstream in(\"file.in\");\n\n    std::map&lt;int, int&gt; pp; \n    pp.insert( std::istream_iterator&lt;std::pair&lt;my_int, my_int&gt;&gt;{in},\n               std::istream_iterator&lt;std::pair&lt;my_int, my_int&gt;&gt;{} );\n}\n</code></pre>\n<p>Of course, you can also use your own <code>pair</code> type, as long as the workaround introduces an associated class in the namespace of the custom <code>operator&gt;&gt;</code>.</p>\n</hr>", "Tags": "<c++><templates><c++11><name-resolution>", "OwnerUserId": "420683", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_16548379_16548379_0": {"section_id": 215, "quality": 1.0, "length": 6}}, "n3337": {"so_16548379_16548379_0": {"section_id": 209, "quality": 1.0, "length": 6}}, "n4659": {"so_16548379_16548379_0": {"section_id": 223, "quality": 1.0, "length": 6}}}});