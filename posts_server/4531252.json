post_cb({"bq_ids": {"n4140": {"so_4531252_4531346_1": {"length": 23, "quality": 0.92, "section_id": 6107}}, "n3337": {"so_4531252_4531346_1": {"length": 23, "quality": 0.92, "section_id": 5873}}, "n4659": {"so_4531252_4531346_1": {"length": 23, "quality": 0.92, "section_id": 7604}}}, "4531252": {"ViewCount": "630", "Body": "<p>I have a class with protected constructor:</p>\n<pre><code>class B {\nprotected:\n    B(){};\n};\n</code></pre>\n<p>Now I derive from it and define two static functions and I manage to actually create objects of the class B, but not on the heap:</p>\n<pre><code>class A : public B {\npublic:\n    static B createOnStack() {return B();}\n    //static B* createOnHeap() {return new B;} //Compile time Error on VS2010\n};\n\nB b = A::createOnStack(); //This works on VS2010!\n</code></pre>\n<p>The question is: 1) Is VS2010 wrong in allowing the first case? 2) Is it possible to create objects of B without modifying B in any way (no friendship and no extra functions).\nI am asking, because it is possible to make something similar when dealing with instances of B and its member functions, see:\n<a href=\"http://accu.org/index.php/journals/296\" rel=\"nofollow\">http://accu.org/index.php/journals/296</a></p>\n<p>Thank you in advance for any suggestion!</p>\n<p>Kind regards</p>\n", "AcceptedAnswerId": "4531346", "Title": "C++ allocate objects on heap of base class with protected constructors via inheritance", "CreationDate": "2010-12-25T18:49:49.050", "Id": "4531252", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2010-12-25T19:38:07.710", "Score": "6", "OwnerUserId": "349351", "Tags": "<c++><inheritance>", "AnswerCount": "2"}, "4531346": {"Id": "4531346", "PostTypeId": "2", "Body": "<ol>\n<li><p>Yes, this code is non-compliant. This is related to special rules for protected member access (C++03 draft, 11.5/1):</p>\n<blockquote>\n<p id=\"so_4531252_4531346_0\">When a friend or a member function of a derived class references a protected nonstatic member function or\n  protected nonstatic data member of a base class, an access check applies in addition to those described earlier in clause 11.10). Except when forming a pointer to member (5.3.1), the access must be through a pointer to, reference to, or object of the derived class itself (or any class derived from that class) (5.2.5).</p>\n</blockquote>\n<p>When you use B() or new B(), you're effectively using the constructor through a pointer to the base class.</p></li>\n<li><p>You can create an object of type A (I assume that A is as posted - no additional members/non-static functions) and use it instead. If you're creating it on stack, everything should work fine, unless you're trying to assign other objects of type B to it. If you're creating it on heap, everything is fine as long as B's destructor is virtual. If B's destructor is not virtual, and you're returning new A() as a B*, then deleting the pointer is technically undefined behavior (5.3.5/3:</p>\n<blockquote>\n<p id=\"so_4531252_4531346_1\">In the first alternative (delete object), if the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand\u2019s dynamic type and the static type shall have a virtual destructor or the behavior is undefined.</p>\n</blockquote>\n<p>However you'll probably find it working fine in practice, so you can rely on the actual behavior if there is no other workaround (i.e. use it as a last resort).</p></li>\n</ol>\n", "LastActivityDate": "2010-12-25T19:17:51.300", "Score": "5", "CreationDate": "2010-12-25T19:17:51.300", "ParentId": "4531252", "CommentCount": "0", "OwnerUserId": "503215"}, "4531369": {"Id": "4531369", "PostTypeId": "2", "Body": "<p>There is a common misunderstanding on what <code>protected</code> actually means. It means that the derived class can access that particular member on <em>itself</em> not on other objects. The compiler should have rejected both functions as in both cases it is accessing the constructor of an object that is not of the derived type.</p>\n<p>Another example, easier to discuss for its correctness would be:</p>\n<pre><code>struct base {\nprotected:\n   int x;\n};\nstruct derived : base{\n   static void modify( base&amp; b ) {\n      b.x = 5; // error\n   }\n};\n</code></pre>\n<p>The commented line is an error as it is trying to modify an object of type <code>base</code>, not necessarily a <code>derived</code> object. If the language allowed that code to compile, then you would be able to modify an object of type <code>base</code> or even objects of types <code>derived1</code>, <code>derived2</code>... effectively breaking access rules.</p>\n<pre><code>struct derived2 : base {};\nint main() {\n   base b;\n   derived2 d;\n   derived::modify( b );    // modifying a base!!!\n   derived::modify( d );    // modifying a derived2!!!\n}\n</code></pre>\n", "LastEditorUserId": "36565", "LastActivityDate": "2010-12-25T19:38:07.710", "Score": "2", "CreationDate": "2010-12-25T19:26:10.083", "ParentId": "4531252", "CommentCount": "2", "LastEditDate": "2010-12-25T19:38:07.710", "OwnerUserId": "36565"}});