post_cb({"40018774": {"ParentId": "40018653", "CommentCount": "1", "Body": "<p>Yes you are correct: <code>enum { value = true };</code> doesn't occupy any memory.</p>\n<p>Furthermore, prior to C++11 it was pretty much the <em>only</em> way of achieving this: <code>static const bool value = true;</code> is only legal in a class definition from C++11 onwards. Although a <code>constexpr</code> might be preferred.</p>\n", "OwnerUserId": "2380830", "PostTypeId": "2", "Id": "40018774", "Score": "6", "CreationDate": "2016-10-13T10:42:41.057", "LastActivityDate": "2016-10-13T10:42:41.057"}, "40357212": {"ParentId": "40018653", "CommentCount": "0", "Body": "<p>It also is another symbol in every object file that includes it, to no benefit. If you use symbol folding (--gc-sections) you'll run out of separatable sections &amp; bloat your binary.</p>\n", "OwnerUserId": "272708", "PostTypeId": "2", "Id": "40357212", "Score": "0", "CreationDate": "2016-11-01T09:25:17.063", "LastActivityDate": "2016-11-01T09:25:17.063"}, "40020448": {"ParentId": "40018653", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>A notable difference is in the fact that the following code compiles and links:</p>\n<pre><code>template&lt;typename&gt;\nstruct is_pointer { };\n\ntemplate&lt;typename T&gt;  \nstruct is_pointer&lt;T*&gt; {\n  enum { value = true };\n};     \n\nvoid f(const bool &amp;b) { }\n\nint main() {\n  f(is_pointer&lt;void*&gt;::value);\n}\n</code></pre>\n<p>The following does not work instead (you get an <em>undefined reference</em> to <code>value</code>):</p>\n<pre><code>template&lt;typename&gt;\nstruct is_pointer { };\n\ntemplate&lt;typename T&gt;\nstruct is_pointer&lt;T*&gt; {\n  static const bool value = true;\n};\n\nvoid f(const bool &amp;b) { }\n\nint main() {\n  f(is_pointer&lt;void*&gt;::value);\n}\n</code></pre>\n<p>Of course, it doesn't work unless you add somewhere the following lines:</p>\n<pre><code>template&lt;typename T&gt;\nconst bool is_pointer&lt;T*&gt;::value;\n</code></pre>\n<p>That is because of <a href=\"http://eel.is/c++draft/class.static.data#3\" rel=\"nofollow noreferrer\">[class.static.data]/3</a> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_40018653_40020448_0\">If a non-volatile non-inline const static data member is of integral or enumeration type, its declaration in the class definition can specify a brace-or-equal-initializer in which every initializer-clause that is an assignment-expression is a constant expression ([expr.const]). <strong>The member shall still be defined in a namespace scope if it is odr-used</strong> ([basic.def.odr]) in the program and the namespace scope definition shall not contain an initializer. [...]</p>\n</blockquote>\n<p>In other terms, <code>static const bool value = true;</code> is a declaration, not a definition and you cannot odr-use <code>value</code>.<br>\nOn the other side, according with <a href=\"http://eel.is/c++draft/dcl.enum#1\" rel=\"nofollow noreferrer\">[dcl.enum/1]</a> (emphasis mine):</br></p>\n<blockquote>\n<p id=\"so_40018653_40020448_1\">An enumeration is a distinct type <strong>with named constants</strong>.</p>\n</blockquote>\n<p>Those named constants can be const referenced as shown in the example above.  </p>\n<hr>\n<p>As a side note, something similar applies if you use <code>static</code> <code>constexpr</code> data members in C++11/14:</p>\n<pre><code>template&lt;typename T&gt;\nstruct is_pointer&lt;T*&gt; { static constexpr bool value = true; }; \n</code></pre>\n<p>This doesn't work as well and that's how I discovered the subtle differences between them.</p>\n<p>I found help here on SO getting some nice hints out of the answer I've been given.<br>\nReferences to the standard are a plus to better explain what's going on under the hood.</br></p>\n<p>Note that a <code>static</code> <code>constexpr</code> data member declaration like the one above is also a definition since C++17. Therefore you won't have to define it anymore and you'll be able to odr-use it directly instead.</p>\n<hr>\n<p>As mentioned in the comments (thanks to @Yakk that confirmed this) I'm also trying to explain how it happens that the above mentioned <em>named constants</em> bind to a const reference.  </p>\n<p><a href=\"http://eel.is/c++draft/expr.const#3\" rel=\"nofollow noreferrer\">[expr.const/3]</a> introduces the <em>integral constant expression</em> and mentions unscoped <code>enum</code>s by saying that it's implicitly converted to a <em>prvalue</em>.<br>\n<a href=\"http://eel.is/c++draft/dcl.init.ref#5\" rel=\"nofollow noreferrer\">[dcl.init.ref/5]</a> and <a href=\"http://eel.is/c++draft/class.temporary#2\" rel=\"nofollow noreferrer\">[class.temporary/2]</a> do the rest, for they rule on reference binding and temporaries.</br></p>\n</hr></hr>", "OwnerUserId": "4987285", "LastEditorUserId": "4987285", "LastEditDate": "2017-07-15T06:16:44.003", "Id": "40020448", "Score": "21", "CreationDate": "2016-10-13T12:01:45.353", "LastActivityDate": "2017-07-15T06:16:44.003"}, "40018711": {"ParentId": "40018653", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_40018653_40018711_0\">Is it only because the <code>static const</code> variable uses a byte of memory, whereas the <code>enum</code> doesn't?</p>\n</blockquote>\n<p>Yes, that's the reason.</p>\n<pre><code>static const bool value = true;\n</code></pre>\n<p>would occupy memory, while </p>\n<pre><code>enum { value = true };\n</code></pre>\n<p>doesn't.</p>\n", "OwnerUserId": "1413395", "PostTypeId": "2", "Id": "40018711", "Score": "7", "CreationDate": "2016-10-13T10:39:56.257", "LastActivityDate": "2016-10-13T10:39:56.257"}, "bq_ids": {"n4140": {"so_40018653_40020448_1": {"section_id": 5460, "quality": 1.0, "length": 5}, "so_40018653_40020448_0": {"section_id": 5908, "quality": 0.8857142857142857, "length": 31}}, "n3337": {"so_40018653_40020448_1": {"section_id": 5247, "quality": 1.0, "length": 5}, "so_40018653_40020448_0": {"section_id": 5680, "quality": 0.8857142857142857, "length": 31}}, "n4659": {"so_40018653_40020448_1": {"section_id": 6894, "quality": 1.0, "length": 5}, "so_40018653_40020448_0": {"section_id": 7390, "quality": 0.9142857142857143, "length": 32}}}, "40018653": {"CommentCount": "0", "AcceptedAnswerId": "40020448", "CreationDate": "2016-10-13T10:37:33.573", "LastActivityDate": "2017-07-15T06:16:44.003", "PostTypeId": "1", "ViewCount": "1166", "FavoriteCount": "4", "Title": "In a type trait, why do people use enum rather than static const for the value?", "Id": "40018653", "Score": "18", "Body": "<p>For example, this is how I would write it, and it compiles and works just fine:</p>\n<pre><code>template&lt;typename T&gt; struct is_pointer&lt;T*&gt; {\n  static const bool value = true;\n}\n</code></pre>\n<p>Then why do some people write the less obvious</p>\n<pre><code>template&lt;typename T&gt; struct is_pointer&lt;T*&gt; {\n  enum { value = true };\n}      \n</code></pre>\n<p>instead? Is it only because the <code>static const</code> variable uses a byte of memory, whereas the <code>enum</code> doesn't?</p>\n", "Tags": "<c++><templates><enums><static><const>", "OwnerUserId": "14637", "AnswerCount": "4"}});