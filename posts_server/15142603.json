post_cb({"15142704": {"ParentId": "15142603", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I don't know what documentation it is you're reading, but <em>the standard</em> says (\u00a721.4.2/15):</p>\n<blockquote>\n<p id=\"so_15142603_15142704_0\">[..] constructs a string from the values in the range <code>[begin, end)</code>, as indicated in the Sequence Requirements table </p>\n</blockquote>\n<p>And the Sequence requirements table (Table 100) defines <code>X a(i, j)</code> for a valid range <code>[i, j)</code> as:</p>\n<blockquote>\n<p id=\"so_15142603_15142704_1\">Constructs a sequence container equal to the range <code>[i, j)</code></p>\n</blockquote>\n<p>A range is <em>valid</em> when the second iterator is reachable from the first (through incrementing). For two iterators that are equal, the range is empty. See \u00a724.2.1/7:</p>\n<blockquote>\n<p id=\"so_15142603_15142704_2\">A <em>range</em> is a pair of iterators that designate the beginning and end of the computation. A range <code>[i,i)</code> is an empty range; in general, a range <code>[i,j)</code> refers to the elements in the data structure starting with the element pointed to by <code>i</code> and up to but not including the element pointed to by <code>j</code>. Range <code>[i,j)</code> is valid if and only if <code>j</code> is reachable from <code>i</code>. The result of the application of functions in the library to invalid ranges is undefined.</p>\n</blockquote>\n<p>So if <code>first == last</code>, as you say, you will get an empty string. If <code>last</code> is not reachable from <code>first</code>, you have undefined behaviour.</p>\n", "OwnerUserId": "150634", "LastEditorUserId": "150634", "LastEditDate": "2013-02-28T18:24:06.083", "Id": "15142704", "Score": "4", "CreationDate": "2013-02-28T18:17:39.990", "LastActivityDate": "2013-02-28T18:24:06.083"}, "bq_ids": {"n4140": {"so_15142603_15142704_1": {"section_id": 723, "quality": 1.0, "length": 5}, "so_15142603_15142704_2": {"section_id": 5561, "quality": 0.9411764705882353, "length": 32}, "so_15142603_15142704_0": {"section_id": 1581, "quality": 1.0, "length": 9}}, "n3337": {"so_15142603_15142704_1": {"section_id": 712, "quality": 1.0, "length": 5}, "so_15142603_15142704_2": {"section_id": 5343, "quality": 0.9411764705882353, "length": 32}, "so_15142603_15142704_0": {"section_id": 1577, "quality": 1.0, "length": 9}}, "n4659": {"so_15142603_15142704_1": {"section_id": 754, "quality": 1.0, "length": 5}, "so_15142603_15142704_2": {"section_id": 7008, "quality": 0.9411764705882353, "length": 32}, "so_15142603_15142704_0": {"section_id": 1732, "quality": 1.0, "length": 9}}}, "15142721": {"ParentId": "15142603", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>One thing I've used it for several times is constructing a <code>std::string</code> from a substring in a large C-style string (<code>const char*</code>). You can pass it two <code>const char*</code> pointers and it will construct a string from the characters starting at the first pointer and ending one before the second pointer.</p>\n<p>If <code>first == last</code>, the result is an empty string. If <code>first &gt; last</code>, behavior is undefined (thanks Mooing Duck)</p>\n", "OwnerUserId": "713961", "LastEditorUserId": "713961", "LastEditDate": "2013-03-01T06:16:59.990", "Id": "15142721", "Score": "0", "CreationDate": "2013-02-28T18:18:34.513", "LastActivityDate": "2013-03-01T06:16:59.990"}, "15142693": {"ParentId": "15142603", "CommentCount": "0", "Body": "<p>The range is empty, so there's nothing to copy. The result is an empty string.</p>\n", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "15142693", "Score": "3", "CreationDate": "2013-02-28T18:16:56.343", "LastActivityDate": "2013-02-28T18:16:56.343"}, "15142603": {"CommentCount": "3", "ViewCount": "141", "PostTypeId": "1", "LastEditorUserId": "115751", "CreationDate": "2013-02-28T18:11:38.450", "LastActivityDate": "2013-03-01T06:16:59.990", "Title": "What is std::string(itr, itr) supposed to do?", "AcceptedAnswerId": "15142704", "LastEditDate": "2013-02-28T18:28:36.747", "Id": "15142603", "Score": "0", "Body": "<p>The <a href=\"http://www.cplusplus.com/reference/string/basic_string/basic_string/\" rel=\"nofollow\">web site cplusplus documentation</a> for std::string constructor taking two input iterators states in part:</p>\n<blockquote>\n<p id=\"so_15142603_15142603_0\">Copies the sequence of characters in the range [first,last), in the same order.</p>\n<p id=\"so_15142603_15142603_1\">first, last:\n  Input iterators to the initial and final positions in a range. The range used is [first,last), which includes all the characters between first and last, including the character pointed by first but not the character pointed by last.</p>\n</blockquote>\n<p>What does this mean in the degenerate case where <code>first == last</code>?  On the one hand <code>first</code> is included and on the other <code>last</code> is excluded?  What does the official C++ standard say should happen in this case?  Should an exception be thrown?</p>\n", "Tags": "<c++><iterator><language-lawyer><stdstring>", "OwnerUserId": "115751", "AnswerCount": "4"}, "15142696": {"ParentId": "15142603", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_15142603_15142696_0\">What does this mean in the degenerate case where first == last?</p>\n</blockquote>\n<p>It means that the input range is empty, so the string will be empty.</p>\n<blockquote>\n<p id=\"so_15142603_15142696_1\">What does the standard say should happen in this case?</p>\n</blockquote>\n<p>C++11 24.2.1/7 says:</p>\n<blockquote>\n<p id=\"so_15142603_15142696_2\">A range <code>[i,i)</code> is an empty range</p>\n</blockquote>\n", "OwnerUserId": "204847", "LastEditorUserId": "204847", "LastEditDate": "2013-02-28T18:25:35.280", "Id": "15142696", "Score": "2", "CreationDate": "2013-02-28T18:17:05.267", "LastActivityDate": "2013-02-28T18:25:35.280"}});