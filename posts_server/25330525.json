post_cb({"bq_ids": {"n4140": {"so_25330525_25330821_1": {"length": 29, "quality": 1.0, "section_id": 3327}, "so_25330525_25330763_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 715}}, "n3337": {"so_25330525_25330821_1": {"length": 29, "quality": 1.0, "section_id": 3197}, "so_25330525_25330763_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 704}}, "n4659": {"so_25330525_25330821_1": {"length": 26, "quality": 0.896551724137931, "section_id": 4093}, "so_25330525_25330763_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 745}}}, "25330763": {"Id": "25330763", "PostTypeId": "2", "Body": "<p>Reading the <a href=\"https://isocpp.org/files/papers/N3797.pdf\" rel=\"nofollow\">current C++1y draft standard</a>.</p>\n<p>From before Table 99:</p>\n<blockquote>\n<p id=\"so_25330525_25330763_0\">T\n  is\n  EmplaceConstructible\n  into\n  X\n  from\n  args\n  , for zero or more arguments\n  args\n  , means that the\n  following expression is well-formed:\n  allocator_traits::construct(m, p, args)</p>\n</blockquote>\n<p>Table 100:</p>\n<pre><code>X(il);              |  Equivalent to      | X(il.begin(), il.end());\n--------------------+---------------------+--------------------------------\nX(i, j);            |                     | Requires:\nX a(i, j);          |                     | T shall be EmplaceConstructible\n                                          | into X from *i.\n</code></pre>\n<p>So <code>std::vector&lt;double[3]&gt; v{ {1,2,3}, {4,5,6} };</code> is valid iff <code>double[3]</code> is <code>EmplaceConstructible</code> from <code>{1,2,3}</code> as an element of an initializer list being passed to a <code>std::vector&lt;double[3]&gt;</code>.</p>\n<p>There is a clause about forward iterators as well, but that is no problem (as <code>std::initialzier_list</code> iterators are forward iterators).</p>\n<p><code>std::vector&lt;T&gt;</code> takes an <code>std::initializer_list&lt;T&gt;</code> parameter.</p>\n<p>So <code>std::initializer_list&lt;double[3]&gt;</code> is the candidate list.</p>\n<p>First, <code>std::initializer_list&lt;double[3]&gt; x = {{1.0, 2.0, 3.0}};</code> fails to compile in gcc.  But suppose that is a bug in gcc.</p>\n<p>Second, <code>::new (nullptr) double[3](std::initializer_list&lt;double&gt;{1.0, 2.0, 3.0});</code> placement new, which <code>EmplaceConstructable</code> reduces to in the lack of a suitable <code>construct</code> override, fails to compile.</p>\n<p>So <code>double[3]</code> is not <code>EmplaceConstruble</code> from a <code>std::initalizer_list&lt;double&gt;</code>  nor from a <code>double[3]</code> nor anything else (as the error occurs because I used a bracket, not because of what was in the brackets, in the placement new), unless the allocator does magic I am not aware of to avoid the placement new.</p>\n<p>Thus your code violates the current draft standard, and probably C++11, and certainly C++03 (which had stricter requirements on containers).</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2014-08-15T17:50:47.107", "Score": "5", "CreationDate": "2014-08-15T16:57:45.553", "ParentId": "25330525", "CommentCount": "9", "OwnerUserId": "1774667", "LastEditDate": "2014-08-15T17:50:47.107"}, "25330821": {"Id": "25330821", "PostTypeId": "2", "Body": "<p>This is a bug in gcc and MSVC; clang compiles your code correctly.</p>\n<p>Recent versions of gcc actually crash (\"ice\") the compiler:</p>\n<blockquote>\n<p id=\"so_25330525_25330821_0\">internal compiler error: tree check: expected class \u2018type\u2019, have \u2018exceptional\u2019 (error_mark) in useless_type_conversion_p, at tree-ssa.c:1189</p>\n</blockquote>\n<p>The standard is reasonably clear; from <strong>[dcl.init.list]</strong>:</p>\n<blockquote>\n<p id=\"so_25330525_25330821_1\">5 - An object of type <code>std::initializer_list&lt;E&gt;</code> is constructed from an initializer list as if the implementation allocated an array of <code>N</code> elements of type <code>E</code>, where <code>N</code> is the number of elements in the initializer list. Each element of that array is copy-initialized with the corresponding element of the initializer list, and the <code>std::initializer_list&lt;E&gt;</code> object is constructed to refer to that array. [...]</p>\n</blockquote>\n<p>Adapting the example from that paragraph:</p>\n<pre><code>using E = double[3];\nusing X = std::vector&lt;E&gt;;\nE __a[2] = {{10, 11, 12}, {20, 21, 22}};\nX x(__a, __a+2);\n</code></pre>\n<p>This is a bit of a cheat, though; a closer translation would write <code>E __a[2] = {E{10, 11, 12}, E{20, 21, 22}};</code>, which is not valid. But it certainly <em>is</em> possible to copy-initialize an array <code>double[3]</code> from a braced-init-list: <code>E __a0 = {10, 11, 12};</code></p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2014-08-15T17:26:01.433", "Score": "2", "CreationDate": "2014-08-15T17:01:29.287", "ParentId": "25330525", "CommentCount": "5", "OwnerUserId": "567292", "LastEditDate": "2014-08-15T17:26:01.433"}, "25330525": {"ViewCount": "3795", "Body": "<p>I am working on a petty (pretty) printer for PODs, STLs and Composite Types like Arrays. While doing so, I was also fiddling with Initialization Lists and came across the following declaration</p>\n<pre><code>std::vector&lt;double[3]&gt; arr{ { 10, 11, 12 }, { 20, 21, 22 } }; \n</code></pre>\n<p>It seems both VC2013 and G++ 4.8 is not quite happy and issues a consistent error message which in either case is not quite helpful to me</p>\n<p><strong>For VC++:</strong> <code>error C3074: an array can only be initialized with an initialize-list</code></p>\n<p><strong>For G++ 4.8:</strong> <code>error: array must be initialized with a brace-enclosed initialize</code></p>\n<p>So either Initialization lists cannot be used here or my syntax is quite not right?</p>\n<p>On a similar front, the following syntax seems to be valid</p>\n<pre><code>std::vector&lt;std::array&lt;int, 3&gt;&gt;  arr{ { 10, 11, 12 }, { 20, 21, 22 } };\n</code></pre>\n<p>What is the possible problem with my initialization list?</p>\n<ul>\n<li><strong>Note</strong> I understand I should use <code>std::array</code> instead of C type arrays but I am just experimenting.  </li>\n<li><strong>Note</strong> If you wan't to play around with this, here is an <a href=\"http://ideone.com/e.js/5uOFDq\" rel=\"noreferrer\">IDEONE</a> version</li>\n<li><strong>Note</strong> Also, it would be quite beneficial if you can refer me back to the standard.</li>\n</ul>\n", "AcceptedAnswerId": "25330763", "Title": "error C3074: an array can only be initialized with an initializer-list", "CreationDate": "2014-08-15T16:42:09.353", "Id": "25330525", "CommentCount": "5", "LastEditDate": "2014-08-15T17:07:44.163", "PostTypeId": "1", "LastEditorUserId": "977038", "LastActivityDate": "2014-08-15T17:50:47.107", "Score": "5", "OwnerUserId": "977038", "Tags": "<c++><arrays><visual-c++><c++11><initialization-list>", "AnswerCount": "2"}});