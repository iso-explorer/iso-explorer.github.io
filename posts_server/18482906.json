post_cb({"18482906": {"CommentCount": "7", "ViewCount": "375", "PostTypeId": "1", "LastEditorUserId": "96780", "CreationDate": "2013-08-28T08:28:35.583", "LastActivityDate": "2013-08-28T11:25:42.607", "Title": "Can I use function-notation operator#() to call operator for built-in types?", "AcceptedAnswerId": "18483006", "LastEditDate": "2013-08-28T08:30:54.857", "Id": "18482906", "Score": "2", "Body": "<p>When I define my own data type I can also define operators on them by overloading the appropriate <code>operator</code>-functions globally:</p>\n<pre><code>struct Stuff {};\n\nStuff operator+(Stuff, Stuff) { return Stuff{}; }\n</code></pre>\n<p>I can then use it infix-like, but still can address it via the function-notation. So this is fine:</p>\n<pre><code>Stuff x;\nStuff y;\nStuff a = x+y;             // using infix-notation\nStuff b = operator+(x,y);  // using the function-notation\n</code></pre>\n<p>But with <code>int</code> (for example) there already <em>is</em> a <code>+</code> defined.</p>\n<p><strong>Is there a way to call <code>int operator+(int,int)</code> (if I may refer to it this way) in the function-notation and not in the infix-notation?</strong></p>\n<p>When I try</p>\n<pre><code>int aa = 12;\nint bb = operator+(a, 6);    // err\nint cc = ::operator+(a, 6);  // err\n</code></pre>\n<p>I get errors like \"operator+ not defined\". <strong>Am I addressing the function wrongly or is this not possible for built-ins?</strong></p>\n<p><em>Bonus:</em> if I write a template I would have different behavior for different type arguments, then:</p>\n<pre><code>template&lt;typename T&gt;\nT add_op(T a, T b) { return a+b; }\n\ntemplate&lt;typename T&gt;\nT add_fun(T a, T b) { return operator+(a,b); } // failing for int\n\nint main() {\n    int am = add_op(3, 4);                 // ok\n    int bm = add_fun(3, 4);                // fail\n    Stuff um = add_op(Stuff{}, Stuff{});   // ok\n    Stuff vm = add_fun(Stuff{}, Stuff{});  // ok\n}\n</code></pre>\n<p>This seems rather strange and I wonder if there is a way to write <code>add_fun</code> using function-notation for <code>+</code>, or if I have to stick to the infix-<code>+</code> as a rule in templates.</p>\n", "Tags": "<c++><function><operators><operator-overloading>", "OwnerUserId": "472245", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_18482906_18483006_1": {"section_id": 675, "quality": 0.8695652173913043, "length": 20}}, "n3337": {"so_18482906_18483006_1": {"section_id": 665, "quality": 0.8695652173913043, "length": 20}}, "n4659": {"so_18482906_18483006_1": {"section_id": 703, "quality": 0.8695652173913043, "length": 20}}}, "18483006": {"ParentId": "18482906", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>You can't even define <code>operator+( int, int )</code>; at least one of\nthe operands of a user defined operator must be a user defined\ntype (class or enum type). </p>\n<p>Logically, one might expect to be able to <em>call</em> these\nfunctions using the <code>operator+</code> syntax, as the compiler does\nconsider them in overload resolution, <em>as if</em> they existed as\nfunctions.  But \u00a713.6 says clearly that they are only used in\noverload resolution, and not in any other context.</p>\n<blockquote>\n<p id=\"so_18482906_18483006_0\">13.6.(1) <strong>Built-in operators</strong> [over.built]</p>\n<p id=\"so_18482906_18483006_1\">The candidate operator functions that represent the built-in operators defined in Clause 5 are specified in this subclause. These candidate functions participate in the operator overload resolution process as described in 13.3.1.2 <em>and are used for no other purpose</em>. ... </p>\n</blockquote>\n", "OwnerUserId": "649665", "LastEditorUserId": "472245", "LastEditDate": "2013-08-28T11:25:42.607", "Id": "18483006", "Score": "2", "CreationDate": "2013-08-28T08:32:32.857", "LastActivityDate": "2013-08-28T11:25:42.607"}});