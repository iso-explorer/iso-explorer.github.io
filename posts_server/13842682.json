post_cb({"bq_ids": {"n4140": {"so_13842682_13843053_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 5895}, "so_13842682_13843022_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 5895}, "so_13842682_13843053_5": {"length": 5, "quality": 1.0, "section_id": 6064}}, "n3337": {"so_13842682_13843053_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 5666}, "so_13842682_13843053_5": {"length": 5, "quality": 1.0, "section_id": 5832}, "so_13842682_13843022_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 5666}}, "n4659": {"so_13842682_13843053_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 7378}, "so_13842682_13843053_5": {"length": 5, "quality": 1.0, "section_id": 242}, "so_13842682_13843022_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7378}}}, "13843053": {"Id": "13843053", "PostTypeId": "2", "Body": "<p>In this case, the type of <code>this</code> is <code>C *</code></p>\n<blockquote>\n<p id=\"so_13842682_13843053_0\">9.3.2 The this pointer [class.this]</p>\n<p id=\"so_13842682_13843053_1\">In the body of a non-static (9.3) member function, the keyword this is a prvalue\n  expression whose value is the address of the object for which the function is called.\n  The type of this in a member function of a class X is X*. </p>\n<p id=\"so_13842682_13843053_2\">...</p>\n</blockquote>\n<p>No mention for <code>X *const</code>, etc. The <code>this</code> pointer is a <em>prvalue</em>, that's why it cannot be assigned to, not because it const-qualified.</p>\n<p>PS. By the way, it seems</p>\n<pre><code>C *p; // for any type C\nis_same&lt;declype (*p), C &amp;&gt;::value == true\n</code></pre>\n<p>though it may be an artefact of the implementation (compiler or <code>is_same</code>), because the standard says:</p>\n<blockquote>\n<p id=\"so_13842682_13843053_3\">5.3.1 Unary operators [expr.unary.op]</p>\n<p id=\"so_13842682_13843053_4\">1 ...</p>\n<p id=\"so_13842682_13843053_5\">... If the type of the expression is \u201cpointer to T,\u201d the type of the result is \u201cT.\u201d ...</p>\n</blockquote>\n", "LastEditorUserId": "390807", "LastActivityDate": "2012-12-12T15:44:18.917", "Score": "2", "CreationDate": "2012-12-12T15:29:17.767", "ParentId": "13842682", "CommentCount": "2", "OwnerUserId": "390807", "LastEditDate": "2012-12-12T15:44:18.917"}, "13843022": {"Id": "13843022", "PostTypeId": "2", "Body": "<blockquote>\n<h3>9.3.2 The this pointer [class.this]</h3>\n<p id=\"so_13842682_13843022_0\">1 - [...] the keyword <code>this</code> is a prvalue expression whose value\n  is the address of the object for which the function is called. The type of <code>this</code> in a member function of a class <code>X</code> is <code>X*</code>.</p>\n</blockquote>\n<p><code>this</code> is not a <code>const</code> lvalue, it's a prvalue expression, so it doesn't need to be <code>const</code>.  You can't assign to it because it's a prvalue, the same reason you can't write <code>2 + 2 = 5</code>.</p>\n", "LastActivityDate": "2012-12-12T15:28:15.493", "CommentCount": "2", "CreationDate": "2012-12-12T15:28:15.493", "ParentId": "13842682", "Score": "3", "OwnerUserId": "567292"}, "13842682": {"ViewCount": "325", "Body": "<p>Related question: <a href=\"https://stackoverflow.com/questions/13843222/template-function-is-same-in-template-classes\">template-function-is-same-in-template-classes</a></p>\n<p>I'm a bit disconcerted with the type of the pointer \"this\" (gcc 4.7.2, c++11). In principle, the type of pointer \"this\" of a non-const object of type C, for example, is \"C * const\", and thus, the type of \"*this\" is \"C\". But the behaviour of the \"is_same\" class confused me.</p>\n<p>Test:</p>\n<pre><code>// this-type.cpp\n#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nusing namespace std;\n\nclass C\n{\npublic:\n   void test()\n   {\n       cout &lt;&lt; boolalpha;\n\n       cout &lt;&lt; \"'this' const?\" &lt;&lt; \"              \"\n            &lt;&lt; is_const&lt;decltype(this)&gt;::value &lt;&lt; endl;\n\n       cout &lt;&lt; \"'*this' const?\" &lt;&lt; \"             \"\n            &lt;&lt; is_const&lt;decltype(*this)&gt;::value &lt;&lt; endl;\n\n       cout &lt;&lt; \"'*this' and 'C' the same?\" &lt;&lt; \"  \"\n            &lt;&lt; is_same&lt;decltype(*this), C&gt;::value &lt;&lt; endl;\n\n       cout &lt;&lt; \"'this' and 'C*' the same?\" &lt;&lt; \"  \"\n            &lt;&lt; is_same&lt;decltype(this), C*&gt;::value &lt;&lt; endl;\n   }\n};\n\nint main()\n{\n    C c;\n\n    c.test();\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>$ g++ --version | grep g++\ng++ (Ubuntu/Linaro 4.7.2-2ubuntu1) 4.7.2\n$ g++ -std=c++11 this-type.cpp\n$ ./a.out\n'this' const?              false\n'*this' const?             false\n'*this' and 'C' the same?  false\n'this' and 'C*' the same?  true\n</code></pre>\n<p>However, the expected output is:</p>\n<pre><code>$./a.out\n'this' const?              true   // C* const\n'*this' const?             false  // C\n'*this' and 'C' the same?  true\n'this' and 'C*' the same?  false  // C* const vs. C*\n</code></pre>\n<p>What are happened here?</p>\n", "AcceptedAnswerId": "13843053", "Title": "Template function \"is_same\" with pointer this, unexpected behaviour?", "CreationDate": "2012-12-12T15:11:12.243", "Id": "13842682", "CommentCount": "4", "LastEditDate": "2017-05-23T10:34:58.200", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2012-12-12T21:27:05.063", "Score": "0", "OwnerUserId": "1794803", "Tags": "<c++><types><c++11><g++>", "AnswerCount": "2"}});