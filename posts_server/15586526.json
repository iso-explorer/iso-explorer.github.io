post_cb({"15586575": {"Id": "15586575", "PostTypeId": "2", "Body": "<p><a href=\"http://msdn.microsoft.com/en-us/library/kbd4xa4d%28v=vs.80%29.aspx\" rel=\"nofollow\">Argument Matching</a> - Overloaded functions are selected for the best match of function declarations in the current scope.</p>\n<blockquote>\n<p id=\"so_15586526_15586575_0\">If template argument deduction succeeds, then the generated function\n  is compared with the other functions to determine the best match,\n  following the rules for overload resolution</p>\n</blockquote>\n<p>\u00a0</p>\n<blockquote>\n<ul>\n<li><p id=\"so_15586526_15586575_1\">An exact match was found.</p></li>\n<li><p id=\"so_15586526_15586575_2\">A trivial conversion was performed.</p></li>\n<li><p id=\"so_15586526_15586575_3\">An integral promotion was performed.</p></li>\n<li><p id=\"so_15586526_15586575_4\">A standard conversion to the desired argument type exists.</p></li>\n<li><p id=\"so_15586526_15586575_5\">A user-defined conversion (either conversion operator or constructor) to the desired argument type exists.</p></li>\n<li><p id=\"so_15586526_15586575_6\">Arguments represented by an ellipsis were found.</p></li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "952747", "LastActivityDate": "2013-03-23T12:12:01.270", "Score": "0", "CreationDate": "2013-03-23T12:06:04.957", "ParentId": "15586526", "CommentCount": "1", "OwnerUserId": "952747", "LastEditDate": "2013-03-23T12:12:01.270"}, "15586526": {"ViewCount": "500", "Body": "<p>Why the overload resolution for the call <code>max(x, y)</code> in the expression <code>return max(max(x, y), z);</code> below results in a call to the non-template function <code>char const* max(char const*, char const*)</code> ?</p>\n<p>As far as I can understand, the function <code>max&lt;const char*&gt;(x, y)</code> is a better fit than the former, as <code>x</code> is a <code>const char* const&amp;</code> and <code>y</code> is a <code>const char* const&amp;</code> !</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nT const&amp; max (T const&amp; x, T const&amp; y)\n{\n    return x &lt; y ? y : x;\n}\n\nchar const* max (char const* x, char const* y)\n{\n    return std::strcmp(x, y) &lt; 0 ? y : x;\n}\n\ntemplate &lt;typename T&gt;\nT const&amp; max (T const&amp; x, T const&amp; y, T const&amp; z)\n{\n    return max (max(x, y), z);\n}\n\nint main ()\n{\n    const char* sx = \"String_x\";\n    const char* sy = \"String_y\";\n    const char* sz = \"String_z\";\n    max(sx, sy, sz);\n}\n</code></pre>\n", "AcceptedAnswerId": "15586567", "Title": "Why the overload resolution below calls the non-template function?", "CreationDate": "2013-03-23T12:01:19.923", "Id": "15586526", "CommentCount": "1", "PostTypeId": "1", "ClosedDate": "2013-03-24T04:03:51.140", "LastActivityDate": "2013-03-23T12:12:01.270", "Score": "8", "OwnerUserId": "1042389", "Tags": "<c++><templates><overloading>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_15586526_15586575_4": {"length": 4, "quality": 0.8, "section_id": 611}, "so_15586526_15586567_3": {"length": 25, "quality": 0.9259259259259259, "section_id": 603}, "so_15586526_15586567_1": {"length": 18, "quality": 0.9, "section_id": 603}, "so_15586526_15586567_5": {"length": 14, "quality": 0.9333333333333333, "section_id": 603}, "so_15586526_15586567_4": {"length": 5, "quality": 1.0, "section_id": 111}, "so_15586526_15586567_2": {"length": 6, "quality": 0.75, "section_id": 603}, "so_15586526_15586575_5": {"length": 6, "quality": 0.6, "section_id": 620}}, "n3337": {"so_15586526_15586575_4": {"length": 4, "quality": 0.8, "section_id": 601}, "so_15586526_15586575_5": {"length": 6, "quality": 0.6, "section_id": 610}, "so_15586526_15586567_1": {"length": 18, "quality": 0.9, "section_id": 593}, "so_15586526_15586567_5": {"length": 14, "quality": 0.9333333333333333, "section_id": 593}, "so_15586526_15586567_4": {"length": 5, "quality": 1.0, "section_id": 106}, "so_15586526_15586567_2": {"length": 6, "quality": 0.75, "section_id": 593}, "so_15586526_15586567_3": {"length": 25, "quality": 0.9259259259259259, "section_id": 593}}, "n4659": {"so_15586526_15586575_4": {"length": 4, "quality": 0.8, "section_id": 637}, "so_15586526_15586575_5": {"length": 6, "quality": 0.6, "section_id": 616}, "so_15586526_15586567_1": {"length": 18, "quality": 0.9, "section_id": 629}, "so_15586526_15586567_5": {"length": 14, "quality": 0.9333333333333333, "section_id": 629}, "so_15586526_15586567_4": {"length": 5, "quality": 1.0, "section_id": 115}, "so_15586526_15586567_2": {"length": 6, "quality": 0.75, "section_id": 629}, "so_15586526_15586567_3": {"length": 25, "quality": 0.9259259259259259, "section_id": 629}}}, "15586567": {"Id": "15586567", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_15586526_15586567_0\">Why the overload resolution for the call <code>max(x, y)</code> in the expression <code>return max(max(x, y), z);</code> below results in a call to the non-template function <code>char const* max(char const*, char const*)</code>?</p>\n</blockquote>\n<p>When invoking this function:</p>\n<pre><code>template &lt;typename T&gt;\nT const&amp; max (T const&amp; x, T const&amp; y, T const&amp; z)\n{\n    return max (max(x, y), z);\n}\n</code></pre>\n<p><code>T</code> is deduced to be <code>const char*</code>. Therefore, this signature is instantiated:</p>\n<pre><code>const char* const&amp; max (\n    const char* const&amp; x, \n    const char* const&amp; y, \n    const char* const&amp; z\n    )\n</code></pre>\n<p>The function internally calls the binary version of <code>max()</code> with arguments of type <code>const char*</code>. Both the template and the non-template overload are viable for an argument of type <code>const char*</code>.</p>\n<p>However, when two functions are viable for resolving the call <em>and</em> one of them is not a template, <strong>the non-template version is considered a best fit</strong>.</p>\n<p>Per Paragraph 13.3.3/1 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15586526_15586567_1\">Given these definitions,** a viable function F1 is defined to be a better function than another viable function\n  F2 if** for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</p>\n<p id=\"so_15586526_15586567_2\">\u2014 for some argument j, ICSj(F1) is a better conversion sequence than ICSj(F2), or, if not that,</p>\n<p id=\"so_15586526_15586567_3\">\u2014 the context is an initialization by user-defined conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the\n  standard conversion sequence from the return type of F1 to the destination type (i.e., the type of the\n  entity being initialized) is a better conversion sequence than the standard conversion sequence from\n  the return type of F2 to the destination type. [ ... ] or, if not that,</p>\n<p id=\"so_15586526_15586567_4\">\u2014 <strong>F1 is a non-template function and F2 is a function template specialization</strong>, or, if not that,</p>\n<p id=\"so_15586526_15586567_5\">\u2014 F1 and F2 are function template specializations, and the function template for F1 is more specialized\n  than the template for F2 according to the partial ordering rules described in 14.5.6.2.</p>\n</blockquote>\n<p>This explains why the non-template overload is picked.</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-03-23T12:10:42.170", "Score": "4", "CreationDate": "2013-03-23T12:05:37.737", "ParentId": "15586526", "CommentCount": "25", "OwnerUserId": "1932150", "LastEditDate": "2013-03-23T12:10:42.170"}});