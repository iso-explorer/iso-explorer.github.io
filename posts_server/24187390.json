post_cb({"bq_ids": {"n4140": {"so_24187390_24188484_1": {"length": 23, "quality": 0.5111111111111111, "section_id": 6142}}, "n3337": {"so_24187390_24188484_1": {"length": 23, "quality": 0.5111111111111111, "section_id": 5906}}}, "24188274": {"PostTypeId": "2", "Body": "<p>My first guess would be that (<code>dynamic_cast&lt;B&amp;&gt;(aArray[1])).x = 2;</code>\nwill/should throw an exception because <code>aArray[1]</code>cannot be downcasted....</p>\n<p>Lets say I will work without exception or you would use <code>static_cast&lt;&gt;</code> instead, you would definitely corrupt your memory!</p>\n<p>imagine: sizeof(A) = 4 bytes; sizeof(B) = 8 bytes </p>\n<p>memory after </p>\n<pre><code>A* aArray = new B[2];\n</code></pre>\n<p>[-----B------|------B-----] memory</p>\n<p>[-----0------|------1-----] indices</p>\n<p>you are saving it to A*. So whats happening if you i.e do </p>\n<pre><code>(static_cast&lt;B&amp;&gt;(aArray[1])).x = 2; \n</code></pre>\n<p>[[--A--]B[--A--]]|----B-----]</p>\n<p>[-------x--------|--- you start writing memory on this position.</p>\n", "LastActivityDate": "2014-06-12T15:28:05.887", "Id": "24188274", "CommentCount": "0", "CreationDate": "2014-06-12T15:28:05.887", "ParentId": "24187390", "Score": "3", "OwnerUserId": "2007358"}, "24187390": {"ViewCount": "441", "Body": "<p>I was curious about about how dynamic_cast can cast an element of an array to a larger class (does it shift all the other elements ?). So I wrote a small code to try it. But I was suprised as it compiles but segfault at the first line. Why ?</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A\n{\npublic:\n    virtual ~A() {}\n};\n\nclass B : public A\n{\npublic:\n    int x;\n};\n\nclass C : public A\n{\npublic:\n    int x;\n    int y;\n};\n\nint main()\n{\n    A* aArray = new B[2];\n    (dynamic_cast&lt;B&amp;&gt;(aArray[0])).x = 1; //segfault here\n    (dynamic_cast&lt;B&amp;&gt;(aArray[1])).x = 2;\n\n    (dynamic_cast&lt;C&amp;&gt;(aArray[0])).y = 3;\n\n    std::cout &lt;&lt; (dynamic_cast&lt;B&amp;&gt;(aArray[1])).x &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "24188484", "Title": "dynamic_cast segfault with RTTI enabled", "CreationDate": "2014-06-12T14:46:21.933", "Id": "24187390", "CommentCount": "13", "PostTypeId": "1", "LastActivityDate": "2014-06-12T15:38:36.590", "Score": "2", "OwnerUserId": "2312686", "Tags": "<c++><rtti><dynamic-cast>", "AnswerCount": "2"}, "24188484": {"PostTypeId": "2", "Body": "<p>Here I go. I compiled and run with gdb</p>\n<p>First I set the print object option:</p>\n<pre><code>(gdb) set print object\n</code></pre>\n<p>check the address of aArray</p>\n<pre><code>(gdb) print aArray\n$1 = (B *) 0x8003a404\n</code></pre>\n<p>check the size of A and B</p>\n<pre><code>(gdb) print sizeof(B)\n$2 = 8\n(gdb) print sizeof(A)\n$3 = 4\n</code></pre>\n<p>get the address of aArray[0]</p>\n<pre><code>(gdb) print &amp;aArray[0]\n$4 = (B *) 0x8003a404\n</code></pre>\n<p>get the address of aArray[1]</p>\n<pre><code>(gdb) print &amp;aArray[1]\n$5 = (A *) 0x8003a408\n</code></pre>\n<p>Quoting the <a href=\"https://stackoverflow.com/questions/7197677/base-pointer-to-array-of-derived-objects\">answer in linked question</a>:</p>\n<blockquote>\n<p id=\"so_24187390_24188484_0\">if you look at the expression <code>p[1]</code>, <code>p</code> is a <code>Base*</code> (Base is a completely-defined type) and 1 is an int, so according to ISO/IEC 14882:2003 5.2.1 [expr.sub] this expression is valid and identical to <code>*((p)+(1))</code></p>\n</blockquote>\n<p>and </p>\n<blockquote>\n<p id=\"so_24187390_24188484_1\">From 5.7 [expr.add] / 5, when an integer is added to a pointer, the result is only well defined when the pointer points to an element of an array object and the result of the pointer arithmetic also points the an element of that array object or one past the end of the array. p, however, does not point to an element of an array object, it points at the base class sub-object of a Derived object. It is the Derived object that is an array member, not the Base sub-object.</p>\n</blockquote>\n<p>In this particular case, the implementation of the pointer arithmetic is to increase the pointer memory by the size of the pointer type (but refer to this <a href=\"https://stackoverflow.com/a/11714314/308705\">answer</a> for additional nuances).</p>\n<p>The effect of <code>aArray + 1</code> is to point at the 2nd element of an array of objects of type A</p>\n<p>That matches:</p>\n<pre><code>(gdb) print (A*)(((char *)aArray) + sizeof(A))\n$6 = (A *) 0x8003a408\n</code></pre>\n<p>... however <code>aArray</code> is really an array of objects of type B.</p>\n<p>So the second element of the array is:</p>\n<pre><code>(gdb) print &amp;((B *)aArray)[1]\n$6 = (B *) 0x8003a40c\n</code></pre>\n<p>so you ended up pointing somewhere in the middle of the first B object... and that access caused the segmentation fault.</p>\n<p>For an alternative explanation an example refer to: [<a href=\"http://www.parashift.com/c++-faq/array-derived-vs-base.html]\" rel=\"nofollow noreferrer\">http://www.parashift.com/c++-faq/array-derived-vs-base.html]</a></p>\n", "LastActivityDate": "2014-06-12T15:38:36.590", "LastEditorUserId": "-1", "Id": "24188484", "CommentCount": "0", "CreationDate": "2014-06-12T15:38:36.590", "ParentId": "24187390", "Score": "2", "OwnerUserId": "308705", "LastEditDate": "2017-05-23T12:05:32.753"}});