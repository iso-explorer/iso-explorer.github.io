post_cb({"36329784": {"ParentId": "36327494", "CommentCount": "1", "Body": "<p>The explicit typecasting is a programming feature of C language which doesn't have any object orientation features or rules. For C language everything is pointers (to memory or functions). Updcasting and downcasting are object orientation features provided by c++. The inheritance casting must behave on the object orientation rules of the language.  However, by typecasting the object like this: <code>A* a1 = (A*)new B;</code> you force \nthe compiler to treat the object as <code>A</code> just as you would do in C by forcing a pointer of a struct to another. Therefore, when the compiler decides which function pointer to assign on the <code>f()</code> calling pointer of the casted object it assigns the pointer of the <code>A</code> class implementation.</p>\n", "OwnerUserId": "1766432", "PostTypeId": "2", "Id": "36329784", "Score": "1", "CreationDate": "2016-03-31T09:45:41.373", "LastActivityDate": "2016-03-31T09:45:41.373"}, "36327779": {"ParentId": "36327494", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The cast in</p>\n<pre><code>A* a1 = (A*)new B;\n</code></pre>\n<p>is a cast to inaccessible base class.</p>\n<p>It can only be expressed as a C style cast. It is equivalent to what a <code>static_cast</code> would do if a <code>static_cast</code> could be used in this situation, and it is not equivalent to a <code>reinterpret_cast</code>. In particular the result address is not necessarily the same as the argument address.</p>\n<b>C++11 \u00a75.4/4:</b>\n<blockquote>\n<p id=\"so_36327494_36327779_0\"><strong>\u201d</strong>  The same semantic restrictions and behaviors [as for a <code>static_cast</code>] apply [for a C style cast], with the exception that in performing a <code>static_cast</code> in the following situations the conversion is valid even if the base class is inaccessible:</p>\n<p id=\"so_36327494_36327779_1\">\u2014 a pointer to an object of derived class type or an lvalue or rvalue of derived class type may be explicitly converted to a pointer or reference to an unambiguous base class type, respectively;</p>\n</blockquote>\n", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2016-03-31T08:24:49.567", "Id": "36327779", "Score": "18", "CreationDate": "2016-03-31T08:17:15.087", "LastActivityDate": "2016-03-31T08:24:49.567"}, "36327613": {"ParentId": "36327494", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Explicit casting allow you to do everything you want. You can, for example, to write so:</p>\n<pre><code>int *p = (int*)new B; \n</code></pre>\n<p>and the code will be compiled.\nExplicit cast means that you know what you are doing.</p>\n", "OwnerUserId": "6113678", "LastEditorUserId": "464581", "LastEditDate": "2016-03-31T08:19:53.993", "Id": "36327613", "Score": "5", "CreationDate": "2016-03-31T08:07:49.877", "LastActivityDate": "2016-03-31T08:19:53.993"}, "36327494": {"CommentCount": "2", "AcceptedAnswerId": "36327779", "PostTypeId": "1", "LastEditorUserId": "254477", "CreationDate": "2016-03-31T08:02:02.787", "LastActivityDate": "2016-03-31T18:38:57.483", "LastEditDate": "2016-03-31T18:38:57.483", "ViewCount": "1166", "FavoriteCount": "1", "Title": "Why does explicit typecasting allow upcasting for private inheritance?", "Id": "36327494", "Score": "24", "Body": "<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nclass A {\n    public:\n    void f(){cout&lt;&lt;\"A\"&lt;&lt;endl;}\n};\n\nclass B : private A {\n    public:\n    void f(){cout&lt;&lt;\"B\"&lt;&lt;endl;}\n};\n\nint main (){\n</code></pre>\n<p>As Class B is inheriting Class A privately, this upcasting is not supposed to work:</p>\n<pre><code>    A* a = new B;\n</code></pre>\n<p>But explicit typecasting is allowing it.\nWhy?</p>\n<pre><code>    A* a1 = (A*)new B;\n    a1-&gt;f();\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "6138595", "AnswerCount": "4"}, "36327931": {"ParentId": "36327494", "CommentCount": "0", "Body": "<p>This is allowed by the rules of C-style casts:</p>\n<blockquote>\n<p id=\"so_36327494_36327931_0\">(N3337) <code>[expr.cast]/4</code>: The conversions performed by</p>\n<ul>\n<li>a const_cast (5.2.11),</li>\n<li>a static_cast (5.2.9),</li>\n<li>a static_cast followed by a const_cast,</li>\n<li>a reinterpret_cast (5.2.10), or</li>\n<li>a reinterpret_cast followed by a const_cast,</li>\n</ul>\n<p id=\"so_36327494_36327931_1\">can be performed using the cast notation of explicit type conversion. The same semantic restrictions\n  and behaviors apply, <strong>with the exception that in performing a static_cast in the following situations the conversion is valid even if the base class is inaccessible</strong>:</p>\n<ul>\n<li><p id=\"so_36327494_36327931_2\"><strong>a pointer to an object of derived class type or an lvalue or rvalue of derived class type may be explicit\n  converted to a pointer or reference to an unambiguous base class type, respectively;</strong></p></li>\n<li><p id=\"so_36327494_36327931_3\">[...]</p></li>\n</ul>\n</blockquote>\n<p>If you change to a <code>static_cast</code>, then this will fail to compile. GCC gives this error:</p>\n<pre><code>error: 'A' is an inaccessible base of 'B'\n    A* a1 = static_cast&lt;A*&gt;(new B);\n</code></pre>\n", "OwnerUserId": "496161", "PostTypeId": "2", "Id": "36327931", "Score": "8", "CreationDate": "2016-03-31T08:24:25.813", "LastActivityDate": "2016-03-31T08:24:25.813"}, "bq_ids": {"n4140": {"so_36327494_36327779_1": {"section_id": 6126, "quality": 1.0, "length": 20}, "so_36327494_36327779_0": {"section_id": 6126, "quality": 0.8, "length": 16}, "so_36327494_36327931_2": {"section_id": 6126, "quality": 0.95, "length": 19}, "so_36327494_36327931_1": {"section_id": 6126, "quality": 0.96, "length": 24}}, "n3337": {"so_36327494_36327779_1": {"section_id": 5890, "quality": 1.0, "length": 20}, "so_36327494_36327779_0": {"section_id": 5890, "quality": 0.8, "length": 16}, "so_36327494_36327931_2": {"section_id": 5890, "quality": 0.95, "length": 19}, "so_36327494_36327931_1": {"section_id": 5890, "quality": 0.96, "length": 24}}, "n4659": {"so_36327494_36327779_1": {"section_id": 7623, "quality": 1.0, "length": 20}, "so_36327494_36327779_0": {"section_id": 7623, "quality": 0.8, "length": 16}, "so_36327494_36327931_2": {"section_id": 7623, "quality": 0.95, "length": 19}, "so_36327494_36327931_1": {"section_id": 7623, "quality": 0.96, "length": 24}}}});