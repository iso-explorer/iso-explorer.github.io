post_cb({"15670218": {"Id": "15670218", "PostTypeId": "2", "Body": "<p>For the same reason you can't cast from <code>char **</code> to <code>const char **</code>. Otherwise you could write </p>\n<pre><code>f3() = \"hello\";\n</code></pre>\n<p>and a subsequent call to f3 would be able to write to the memory of the string literal, aliased to the static local <code>x</code>.</p>\n", "LastActivityDate": "2013-03-27T21:51:43.290", "CommentCount": "2", "CreationDate": "2013-03-27T21:51:43.290", "ParentId": "15670136", "Score": "2", "OwnerUserId": "567292"}, "15670920": {"Id": "15670920", "PostTypeId": "2", "Body": "<p>From Paragraph 8.5.3/2 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15670136_15670920_0\">A reference cannot be changed to refer to another object after initialization. Note that initialization of a\n  reference is treated very differently from assignment to it. Argument passing (5.2.2) and <strong>function value\n  return (6.6.3) are initializations</strong>.</p>\n</blockquote>\n<p>This basically tells you that returning a value from a function is equivalent to performing an initialization. Therefore, function <code>f3()</code> doesn't compile for the same reason the last initialization in the code snippet below doesn't compile:</p>\n<pre><code>char c = 'a';\nchar* x = &amp;c;\nconst char*&amp; y = x; // ERROR!\n</code></pre>\n<p>The type of the object referenced by <code>y</code> is <code>const char*</code>, while the type of the expression we are trying to initialize it with (i.e. the type of <code>x</code>) is <code>char*</code>. Those are <em>different types</em>, and when binding a reference the types of the initializer expression and of the object referenced by the initialized reference <strong>must be identical</strong> (with an exception for base and derived classes, which are not involved here), <strong>apart from <em>top-level</em> cv qualifications</strong>. </p>\n<p>Here, the <code>const</code> qualification in <code>const char*</code> is <em>not</em> a top-level qualification, because it applies to the pointed object, and not to the pointer itself: while the pointed <code>char</code> value cannot be modified through a <code>const char*</code> pointer, the pointer itself <em>can</em> be reassigned.</p>\n<p>In Standard terms, this means that the types <code>const char*</code> and <code>char*</code> are not <em>reference-related</em>:</p>\n<blockquote>\n<p id=\"so_15670136_15670920_1\">Given types \u201c<code>cv1 T1</code>\u201d and \u201c<code>cv2 T2</code>,\u201d \u201c<code>cv1 T1</code>\u201d is <em>reference-related</em> to \u201c<code>cv2 T2</code>\u201d if <code>T1</code> is the <strong>same type as</strong> <code>T2</code>, or <code>T1</code> is a base class of <code>T2</code>. \u201ccv1 T1\u201d is <em>reference-compatible</em> with \u201c<code>cv2 T2</code>\u201d if <code>T1</code> is <em>reference-related</em> to <code>T2</code> and <code>cv1</code> is the same cv-qualification as, or greater cv-qualification than, <code>cv2</code>. [...]</p>\n</blockquote>\n<p>On the other hand, function <code>f2()</code> compiles, consistently with the fact that the initialization in the last line below is legal: </p>\n<pre><code>char c = 'a';\nchar* x = &amp;c;\nchar* const&amp; y = x; // OK\n</code></pre>\n<p>Here, the type of the referenced object is <code>char* const</code>, which (unlike <code>const char*</code>) is reference-compatible with <code>char*</code> in the sense defined by the Paragraph quoted above *(the <code>const</code> qualification is a <strong>top-level</strong> qualification in this case).</p>\n<p>In Particular, per 8.5.3/5:</p>\n<blockquote>\n<p id=\"so_15670136_15670920_2\">A reference to type \u201ccv1 T1\u201d is initialized by an expression of type \u201ccv2 T2\u201d as follows:</p>\n<p id=\"so_15670136_15670920_3\">\u2014 If the reference is an lvalue reference and the initializer expression</p>\n<ul>\n<li>is an lvalue (but is not a bit-field), <strong>and \u201ccv1 T1\u201d is reference-compatible with \u201ccv2 T2,\u201d</strong> or</li>\n</ul>\n<p id=\"so_15670136_15670920_4\">[...]</p>\n</blockquote>\n<p>The omitted part is not relevant to this case. Here, <code>char* const</code> and <code>char*</code> are <em>reference-compatible</em>, and the initialization is legal (and <code>f2()</code> compiles). On the other hand, <code>const char*</code> and <code>char*</code> are <strong>not</strong> <em>reference-compatible</em>, and the initialization is illegal (and <code>f3()</code> does not compile).</p>\n", "LastActivityDate": "2013-03-27T22:40:17.003", "CommentCount": "2", "CreationDate": "2013-03-27T22:40:17.003", "ParentId": "15670136", "Score": "5", "OwnerUserId": "1932150"}, "bq_ids": {"n4140": {"so_15670136_15670920_2": {"length": 8, "quality": 1.0, "section_id": 3321}, "so_15670136_15670920_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 3318}, "so_15670136_15670920_1": {"length": 15, "quality": 0.6818181818181818, "section_id": 3321}, "so_15670136_15670920_3": {"length": 5, "quality": 1.0, "section_id": 3321}}, "n3337": {"so_15670136_15670920_2": {"length": 8, "quality": 1.0, "section_id": 3191}, "so_15670136_15670920_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 3188}, "so_15670136_15670920_1": {"length": 15, "quality": 0.6818181818181818, "section_id": 3191}, "so_15670136_15670920_3": {"length": 5, "quality": 1.0, "section_id": 3191}}, "n4659": {"so_15670136_15670920_2": {"length": 8, "quality": 1.0, "section_id": 4087}, "so_15670136_15670920_0": {"length": 15, "quality": 0.6521739130434783, "section_id": 4084}, "so_15670136_15670920_1": {"length": 20, "quality": 0.9090909090909091, "section_id": 4086}, "so_15670136_15670920_3": {"length": 5, "quality": 1.0, "section_id": 4087}}}, "15670931": {"Id": "15670931", "PostTypeId": "2", "Body": "<pre><code>#include &lt;iostream&gt;\nvoid problem( const char*&amp; output, const char* input )\n{\n  output = input; // legal, const char*&amp; = const char*\n}\n\nint main() {\n  const char buff[] = \"hello\";\n  char* out = nullptr;\n  problem( const_cast&lt;const char*&amp;&gt;(out), &amp;buff[0] );\n  out[0] = 'H'; // I just changed a const array's first character\n  std::cout &lt;&lt; &amp;buff[0] &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>This prints \"Hello\", which is evidence I just engaged in undefined behavior.  To do so, I had to use a <code>const_cast</code>.  If you could initialize a <code>const char*&amp;</code> with a <code>char*</code>, I wouldn't have to do the <code>const_cast</code> to invoke the undefined behavior.</p>\n<p>\"But\" one might say \"this doesn't match the exact case that the OP posted!\"</p>\n<p>Which is true.</p>\n<pre><code>// the \"legal\" way to do what the OP wants to do, but it leads to undefined\n// behavior:\nconst char*&amp; problem2( char*&amp; c ) { return const_cast&lt;const char*&amp;&gt;(c); }\nvoid problem3( const char*&amp; left, const char* right ) { left = right; }\n\n#include &lt;iostream&gt;\nint main() {\n  char* c = nullptr;\n  char const* buff = \"hello undefined behavior\";\n  problem3( problem2(c), buff );\n  c[0] = 'H';\n  std::cout &lt;&lt; buff &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>also prints \"Hello undefined behavior\".</p>\n<p>\"But\", one might say, \"you turned a <code>char*&amp;</code> into a <code>const char*&amp;</code>, not a <code>char*</code> into a <code>const char*&amp;</code>.</p>\n<p>Very well:</p>\n<pre><code>void problem3( const char*&amp; left, const char* right ) { left = right; }\nconst char*&amp; problem4( char x = 0 ) {\n  static char* bob = nullptr;\n  if (bob &amp;&amp; x)\n    bob[0] = x;\n  return const_cast&lt;const char*&amp;&gt;(bob);\n}\n#include &lt;iostream&gt;\nint main() {\n  char const* buff = \"hello problem\";\n  problem3( problem4(), buff );\n  problem4('H');\n  std::cout &lt;&lt; buff &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Again, that incriminating capital <code>H</code> (well, actually, undefined behavior that typically is a capital <code>H</code>).</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2013-03-28T00:12:02.573", "Score": "2", "CreationDate": "2013-03-27T22:41:03.533", "ParentId": "15670136", "CommentCount": "0", "OwnerUserId": "1774667", "LastEditDate": "2013-03-28T00:12:02.573"}, "15670136": {"ViewCount": "255", "Body": "<p>VS2010 shows error C2440: <code>'return' : cannot convert from 'char *' to 'const char *&amp;</code> in <code>f3</code> below. Why is it not possible to return a <code>char*</code> when the return type is <code>const char*&amp;</code>?</p>\n<pre><code>const char* const&amp; f1()\n{\n    static char* x = new char[5]();\n    return x;\n}\n\nchar* const&amp; f2()\n{\n    static char* x = new char[5]();\n    return x;\n}\n\nconst char* &amp; f3()\n{\n    static char* x = new char[5]();\n    return x;    // error C2440\n}\n\nchar* &amp; f4()\n{\n    static char* x = new char[5]();\n    return x;\n}\n</code></pre>\n", "AcceptedAnswerId": "15670920", "Title": "Why can't a const T*& bind to a T*?", "CreationDate": "2013-03-27T21:45:34.693", "Id": "15670136", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-03-27T22:16:00.717", "LastEditorUserId": "906773", "LastActivityDate": "2013-03-28T00:12:02.573", "Score": "5", "OwnerUserId": "1042389", "Tags": "<c++>", "AnswerCount": "3"}});