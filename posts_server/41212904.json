post_cb({"41212904": {"CommentCount": "1", "ViewCount": "45", "PostTypeId": "1", "ClosedDate": "2016-12-21T09:17:50.650", "LastEditorUserId": "105466", "CreationDate": "2016-12-18T21:08:35.000", "LastActivityDate": "2016-12-21T21:40:49.603", "Title": "Array passing to function", "LastEditDate": "2016-12-21T05:59:54.203", "Id": "41212904", "Score": "-1", "Body": "<p>When passing the values of an array into a function, the C++ compiler\nonly passes the name of the array (address where the array begins) into\nthe function. Explain why the C++ compiler only passes the name of an\narray into a function and not the entire contents of the array?</p>\n", "Tags": "<c++><arrays><function>", "OwnerUserId": "7314064", "AnswerCount": "2"}, "41213314": {"ParentId": "41212904", "CommentCount": "0", "Body": "<p>Your question is incorrect. When you write</p>\n<pre><code>int foo[5] = {1,2,3,4,5};\nf(foo);\n</code></pre>\n<p>you're not passing the name of <code>foo</code> to function <code>f</code>, you're passing a pointer to the first element of <code>foo</code>. Function <code>f</code> knows it's getting an <code>int*</code>, and it knows how big an <code>int</code> is, so it knows how far ahead in memory to look for the second, third, fourth etc elements. This is the barest minimum to implement arrays, which is why it was popular.</p>\n<p>In C++11, to pass an array which knows how big it is, use <code>std::array</code>. This is an array which knows how big it is:</p>\n<pre><code>#include &lt;array&gt;\nstd::array&lt;int, 5&gt; foo {1,2,3,4,5};\n\nf(foo);\n\nfoo[42] = 1; // compile-time error!\n</code></pre>\n<p>However you need to write <code>f</code> such that it knows how big <code>array</code> is:</p>\n<pre><code>void f(const std::array&lt;int, 5&gt;&amp; ai); // this works\n</code></pre>\n<p>or make it templated, so it can take any size array:</p>\n<pre><code>template&lt;size_t Size&gt;\nvoid f(const std::array&lt;int, Size&gt;&amp; ai);\n</code></pre>\n<p>(or even an array of any type:)</p>\n<pre><code>template&lt;typename T, size_t Size&gt;\nvoid f(const std::array&lt;T, Size&gt;&amp; a);\n</code></pre>\n<p>Alternatively, store data in <code>std::vector</code>s. They're sometimes less efficient than <code>std::array</code> or built-in arrays, but a lot more flexible:</p>\n<pre><code>std::vector&lt;int&gt; foo {1,2,3,4,5};\nf(foo);\n\n...\n\nvoid f(const std::vector&lt;int&gt;&amp; foo);\n</code></pre>\n", "OwnerUserId": "2449857", "PostTypeId": "2", "Id": "41213314", "Score": "0", "CreationDate": "2016-12-18T21:57:25.337", "LastActivityDate": "2016-12-18T21:57:25.337"}, "bq_ids": {"n4140": {"so_41212904_41256180_1": {"section_id": 3241, "quality": 0.900990099009901, "length": 91}, "so_41212904_41256180_0": {"section_id": 11, "quality": 0.7083333333333334, "length": 17}}, "n3337": {"so_41212904_41256180_1": {"section_id": 3114, "quality": 0.900990099009901, "length": 91}, "so_41212904_41256180_0": {"section_id": 8, "quality": 0.7083333333333334, "length": 17}}, "n4659": {"so_41212904_41256180_1": {"section_id": 3997, "quality": 0.900990099009901, "length": 91}, "so_41212904_41256180_0": {"section_id": 12, "quality": 0.875, "length": 21}}}, "41256180": {"ParentId": "41212904", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The \"why\" is simple. Because that's what the standard says.</p>\n<p>[<a href=\"http://eel.is/c++draft/conv.array#1\" rel=\"nofollow noreferrer\">\u00a74.2 \u00b6 1</a>]</p>\n<blockquote>\n<p id=\"so_41212904_41256180_0\">An lvalue or rvalue of type \u201carray of N T\u201d or \u201carray of unknown bound\n  of T\u201d can be converted to a prvalue of type \u201cpointer to T\u201d. The\n  temporary materialization conversion ([conv.rval]) is applied. The\n  result is a pointer to the first element of the array.</p>\n</blockquote>\n<p>[<a href=\"http://eel.is/c++draft/dcl.fct#5\" rel=\"nofollow noreferrer\">\u00a78.3.5 \u00b6 5</a>]</p>\n<blockquote>\n<p id=\"so_41212904_41256180_1\">A single name can be used for several different functions in a single\n  scope; this is function overloading (Clause [over]). All declarations\n  for a function shall agree exactly in both the return type and the\n  parameter-type-list. The type of a function is determined using the\n  following rules. The type of each parameter (including function\n  parameter packs) is determined from its own decl-specifier-seq and\n  declarator. <strong>After determining the type of each parameter, any\n  parameter of type \u201carray of T\u201d or of function type T is adjusted to be\n  \u201cpointer to T\u201d.</strong> After producing the list of parameter types, any\n  top-level cv-qualifiers modifying a parameter type are deleted when\n  forming the function type. The resulting list of transformed parameter\n  types and the presence or absence of the ellipsis or a function\n  parameter pack is the function's parameter-type-list. [ Note: This\n  transformation does not affect the types of the parameters. For\n  example, <code>int(*)(const int p, decltype(p)*)</code> and <code>int(*)(int, const int*)</code>\n  are identical types.  \u2014 end note ]</p>\n</blockquote>\n", "OwnerUserId": "817643", "LastEditorUserId": "775806", "LastEditDate": "2016-12-21T21:40:49.603", "Id": "41256180", "Score": "1", "CreationDate": "2016-12-21T06:05:07.943", "LastActivityDate": "2016-12-21T21:40:49.603"}});