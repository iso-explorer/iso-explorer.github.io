post_cb({"23070800": {"ParentId": "23070099", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Something along the lines of your <code>is_integral</code> trick:</p>\n<pre><code>#include &lt;limits&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nstruct is_floating_point\n{\n  static const bool value;\n};\n\n// is a fundamental type (i.e. not a user defined type) but not an integer\ntemplate &lt;typename T&gt;\nconst bool is_floating_point&lt;T&gt;::value =\n!std::numeric_limits&lt;T&gt;::is_integer &amp;&amp; std::numeric_limits&lt;T&gt;::is_bounded;\n\nstruct Obj\n{\n};\n\nint main()\n{\n    std::cout &lt;&lt; is_floating_point&lt;float&gt;::value &lt;&lt; std::endl;        // 1\n    std::cout &lt;&lt; is_floating_point&lt;int&gt;::value &lt;&lt; std::endl;          // 0\n    std::cout &lt;&lt; is_floating_point&lt;Obj&gt;::value &lt;&lt; std::endl;          // 0\n    std::cout &lt;&lt; is_floating_point&lt;bool&gt;::value &lt;&lt; std::endl;         // 0\n    std::cout &lt;&lt; is_floating_point&lt;double&gt;::value &lt;&lt; std::endl;       // 1\n    std::cout &lt;&lt; is_floating_point&lt;long double&gt;::value &lt;&lt; std::endl;  // 1\n\n    // this would compile since it's an array of size 1\n    int Y[is_floating_point&lt;float&gt;::value] = { };\n    // this wouldn't compile since it's an array of size 0\n    int N[is_floating_point&lt;int&gt;::value] = { };\n}\n</code></pre>\n", "OwnerUserId": "183120", "LastEditorUserId": "183120", "LastEditDate": "2014-04-14T21:36:47.300", "Id": "23070800", "Score": "1", "CreationDate": "2014-04-14T21:29:09.970", "LastActivityDate": "2014-04-14T21:36:47.300"}, "23070099": {"CommentCount": "2", "ViewCount": "324", "CreationDate": "2014-04-14T20:47:51.183", "LastActivityDate": "2014-04-14T21:36:47.300", "Title": "C++98: Compile Time Detect floating point type", "AcceptedAnswerId": "23070776", "PostTypeId": "1", "Id": "23070099", "Score": "2", "Body": "<p>So you can make a fake is_integral in C++98 with the following:</p>\n<pre><code>template &lt;typename T&gt;\nstruct is_integral\n{\n  static const bool value;\n};\n\ntemplate &lt;typename T&gt;\nconst bool is_integral&lt;T&gt;::value = std::numeric_limits&lt;T&gt;::is_integer;\n</code></pre>\n<p>easy enough...is there anything similar you can do for floating point (without getting a boost dependency?)</p>\n", "Tags": "<c++><templates><c++98>", "OwnerUserId": "1756405", "AnswerCount": "3"}, "23070776": {"ParentId": "23070099", "CommentCount": "3", "Body": "<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf\" rel=\"nofollow\">C++ standard</a>* states:</p>\n<blockquote>\n<p id=\"so_23070099_23070776_0\">Specializations shall be provided for each fundamental type, both floating point and integer, including bool. </p>\n</blockquote>\n<p>(*- I am having trouble finding an earlier draft of the standard. If someone can lend a hand here, it'd be much appreciated.)</p>\n<p>Since <code>std::numeric_limits</code> provides definitions for <code>is_integer</code> and <code>is_specialized</code>, you can combine the information to deduce whether or not a type is a floating point type.</p>\n<p>For example:</p>\n<pre><code>template &lt;typename T&gt;\nstruct is_floating_point\n{\n    static const bool value;\n};\n\ntemplate &lt;typename T&gt;\nconst bool is_floating_point&lt;T&gt;::value =\n    std::numeric_limits&lt;T&gt;::is_specialized &amp;&amp;  // Is fundamental arithmetic type...\n    !std::numeric_limits&lt;T&gt;::is_integer;       // ...that is not an integer\n</code></pre>\n", "OwnerUserId": "926713", "PostTypeId": "2", "Id": "23070776", "Score": "3", "CreationDate": "2014-04-14T21:28:09.643", "LastActivityDate": "2014-04-14T21:28:09.643"}, "bq_ids": {"n4140": {"so_23070099_23070776_0": {"section_id": 6714, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_23070099_23070776_0": {"section_id": 6469, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_23070099_23070776_0": {"section_id": 8209, "quality": 0.7272727272727273, "length": 8}}}, "23070652": {"ParentId": "23070099", "CommentCount": "1", "Body": "<p>Since there are only three floating point types (per C++98 \u00a73.9.1/8), it's not hard to enumerate them:</p>\n<pre><code>template &lt;typename T&gt;\nstruct is_floating_point {\n  enum { value = 0 };\n};\n\ntemplate &lt;&gt;\nstruct is_floating_point&lt;float&gt; {\n  enum { value = 1 };\n};\n\ntemplate &lt;&gt;\nstruct is_floating_point&lt;double&gt; {\n  enum { value = 1 };\n};\n\ntemplate &lt;&gt;\nstruct is_floating_point&lt;long double&gt; {\n  enum { value = 1 };\n};\n</code></pre>\n", "OwnerUserId": "923854", "PostTypeId": "2", "Id": "23070652", "Score": "1", "CreationDate": "2014-04-14T21:20:54.160", "LastActivityDate": "2014-04-14T21:20:54.160"}});