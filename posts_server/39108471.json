post_cb({"39109030": {"ParentId": "39108471", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>Yes, in this example it is perfectly fine to check for <code>== 0.0</code>. This is not because <code>0.0</code> is special in any way, but because you only <em>assign</em> a value and compare it afterwards. You could also set it to <code>3.3</code> and compare for <code>== 3.3</code>, this would be fine too. You're storing a bit pattern, and comparing for that exact same bit pattern, as long as the values are not promoted to another type for doing the comparison.</p>\n<p>However, calculation results that would mathematically equal zero would not always equal <code>0.0</code>.</p>\n<hr>\n<p>This Q/A has evolved to also include cases where different parts of the program are compiled by different compilers. The question does not mention this, my answer applies only when the same compiler is used for all relevant parts.</p>\n<p>C++ 11 Standard,<br>\n\u00a75.10 <strong>Equality operators</strong></br></p>\n<blockquote>\n<p id=\"so_39108471_39109030_0\">6 If both operands are of arithmetic or enumeration type, the usual\n  arithmetic conversions are performed on both operands; each of the\n  operators shall yield true if the specified relationship is true and\n  false if it is false.</p>\n</blockquote>\n<p>The relationship is not defined further, so we have to use the common meaning of \"equal\".</p>\n<p>\u00a72.13.4 <strong>Floating literals</strong></p>\n<blockquote>\n<p id=\"so_39108471_39109030_1\">1 [...] If the scaled value is in the range of representable values\n  for its type, the result is the scaled value if representable, else\n  the larger or smaller representable value nearest the scaled value,\n  chosen in an implementation-defined manner. [...]</p>\n</blockquote>\n<p>The compiler has to choose between exactly two values when converting a literal, when the value is not representable. If the same value is chosen for the same literal consistently, you are safe to compare values such as <code>3.3</code>, because <code>==</code> means \"equal\".</p>\n</hr>", "OwnerUserId": "3435400", "LastEditorUserId": "3435400", "LastEditDate": "2016-08-23T21:44:43.123", "Id": "39109030", "Score": "2", "CreationDate": "2016-08-23T19:13:16.123", "LastActivityDate": "2016-08-23T21:44:43.123"}, "39110067": {"ParentId": "39108471", "PostTypeId": "2", "CommentCount": "1", "Body": "<p><strong>correction:</strong> <code>0</code> as a floating point value is not unique, but IEEE 754 defines the comparison <code>0.0==-0.0</code> to be true (any zero for that matter).</p>\n<p>So with <code>0.0</code> this works - for every other number it does not. The literal <code>3.3</code> in one compilation unit (e.g. a library) and another (e.g. your application) might differ. The standard only requires the compiler to use the same rounding it would use at runtime - but different compilers / compiler settings might use different rounding.</p>\n<p><strike>It will work most of the time (for <code>0</code>), but is very bad practice.</strike></p>\n<p>As long as you are using the same compiler with the same settings (e.g. one compilation unit) it will work because the literal <code>0.0</code> or <code>0.0f</code> will translate to the same bit pattern every time. The representation of zero is not unique though. So if <code>foo</code> is declared in a library and your call to it in some application the same function might fail.</p>\n<p>You can rescue this very case by using <code>std::fpclassify</code> to check whether the returned value represents a zero. For every finite (non-zero) value you will have to use an epsilon-comparison though unless you stay within one compilation unit and perform no operations on the values.</p>\n", "OwnerUserId": "1365260", "LastEditorUserId": "1365260", "LastEditDate": "2016-08-23T20:30:37.587", "Id": "39110067", "Score": "1", "CreationDate": "2016-08-23T20:23:26.870", "LastActivityDate": "2016-08-23T20:30:37.587"}, "39108957": {"ParentId": "39108471", "CommentCount": "17", "Body": "<p>Yes, if you return <code>0.0</code> you can compare it to <code>0.0</code>; 0 is representable exactly as a floating-point value. If you return <code>3.3</code> you have to be a much more careful, since <code>3.3</code> is not exactly representable, so a conversion from double to float, for example, will produce a different value.</p>\n", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "39108957", "Score": "4", "CreationDate": "2016-08-23T19:09:42.343", "LastActivityDate": "2016-08-23T19:09:42.343"}, "39108471": {"CommentCount": "25", "ViewCount": "965", "PostTypeId": "1", "LastEditorUserId": "168986", "CreationDate": "2016-08-23T18:38:18.910", "LastActivityDate": "2016-08-24T18:46:18.783", "Title": "Is it ok to compare floating points to 0.0 without epsilon?", "FavoriteCount": "1", "LastEditDate": "2016-08-24T18:46:18.783", "Id": "39108471", "Score": "10", "Body": "<p>I am aware, that to compare two floating point values one needs to use some epsilon precision, as they are not exact. However, I wonder if there are edge cases, where I don't need that epsilon.</p>\n<p>In particular, I would like to know if it is always safe to do something like this:</p>\n<pre><code>double foo(double x){\n    if (x &lt; 0.0) return 0.0;\n    else return somethingelse(x); // somethingelse(x) != 0.0\n}\n\nint main(){\n   int x = -3.0;\n   if (foo(x) == 0.0) { \n     std::cout &lt;&lt; \"^- is this comparison ok?\" &lt;&lt; std::endl; \n   }\n}\n</code></pre>\n<p>I know that there are better ways to write <code>foo</code> (e.g. returning a flag in addition), but I wonder if in general is it ok to assign <code>0.0</code> to a floating point variable and later compare it to <code>0.0</code>.</p>\n<p>Or more general, does the following comparison yield true always?</p>\n<pre><code>double x = 3.3;\ndouble y = 3.3;\nif (x == y) { std::cout &lt;&lt; \"is an epsilon required here?\" &lt;&lt; std::endl; }\n</code></pre>\n<p>When I tried it, it seems to work, but it might be that one should not rely on that. </p>\n", "Tags": "<c++><floating-point><equality>", "OwnerUserId": "4117728", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_39108471_39109030_0": {"section_id": 6159, "quality": 1.0, "length": 20}, "so_39108471_39109030_1": {"section_id": 5348, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_39108471_39109030_0": {"section_id": 5916, "quality": 0.7, "length": 14}, "so_39108471_39109030_1": {"section_id": 5145, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_39108471_39109030_0": {"section_id": 7656, "quality": 1.0, "length": 20}, "so_39108471_39109030_1": {"section_id": 6773, "quality": 0.9545454545454546, "length": 21}}}, "39110273": {"ParentId": "39108471", "CommentCount": "0", "Body": "<p>As written in both cases you are using identical constants in the same file fed to the same compiler.  The string to float conversion the compiler uses should return the same bit pattern so these should not only be equal as in a plus or minus cases for zero thing but equal bit by bit.  </p>\n<p>Were you to have a constant which uses the operating systems C library to generate the bit pattern then have a string to f or something that can possibly use a different C library if the binary is transported to another computer than the one compiled on.  You might have a problem.</p>\n<p>Certainly if you compute 3.3 for one of the terms, runtime, and have the other 3.3 computed compile time again you can and will get failures on the equal comparisons.  Some constants obviously are more likely to work than others.</p>\n<p>Of course as written your 3.3 comparison is dead code and the compiler just removes it if optimizations are enabled.</p>\n<p>You didnt specify the floating point format nor standard if any for that format you were interested in.  Some formats have the +/- zero problem, some dont for example.</p>\n", "OwnerUserId": "16007", "PostTypeId": "2", "Id": "39110273", "Score": "1", "CreationDate": "2016-08-23T20:39:48.113", "LastActivityDate": "2016-08-23T20:39:48.113"}});