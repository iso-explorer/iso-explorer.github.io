post_cb({"bq_ids": {"n4140": {"so_48717494_48718305_6": {"length": 20, "quality": 0.8695652173913043, "section_id": 3336}, "so_48717494_48718305_5": {"length": 9, "quality": 1.0, "section_id": 303}, "so_48717494_48718305_7": {"length": 4, "quality": 0.8, "section_id": 3348}, "so_48717494_48718305_3": {"length": 25, "quality": 0.8928571428571429, "section_id": 611}, "so_48717494_48718305_2": {"length": 9, "quality": 1.0, "section_id": 7195}, "so_48717494_48718305_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 58}, "so_48717494_48718305_4": {"length": 9, "quality": 1.0, "section_id": 303}, "so_48717494_48718305_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 558}, "so_48717494_48718305_8": {"length": 7, "quality": 0.875, "section_id": 3348}}, "n3337": {"so_48717494_48718305_6": {"length": 23, "quality": 1.0, "section_id": 3206}, "so_48717494_48718305_5": {"length": 9, "quality": 1.0, "section_id": 294}, "so_48717494_48718305_7": {"length": 4, "quality": 0.8, "section_id": 3218}, "so_48717494_48718305_3": {"length": 25, "quality": 0.8928571428571429, "section_id": 601}, "so_48717494_48718305_2": {"length": 9, "quality": 1.0, "section_id": 6939}, "so_48717494_48718305_8": {"length": 7, "quality": 0.875, "section_id": 3218}, "so_48717494_48718305_4": {"length": 9, "quality": 1.0, "section_id": 294}, "so_48717494_48718305_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 549}, "so_48717494_48718305_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 53}, "so_48717494_48717494_0": {"length": 8, "quality": 0.8, "section_id": 5792}}, "n4659": {"so_48717494_48718305_6": {"length": 13, "quality": 0.5652173913043478, "section_id": 7672}, "so_48717494_48718305_5": {"length": 7, "quality": 0.7777777777777778, "section_id": 310}, "so_48717494_48718305_7": {"length": 4, "quality": 0.8, "section_id": 4115}, "so_48717494_48718305_3": {"length": 25, "quality": 0.8928571428571429, "section_id": 637}, "so_48717494_48718305_2": {"length": 9, "quality": 1.0, "section_id": 8704}, "so_48717494_48718305_8": {"length": 7, "quality": 0.875, "section_id": 4115}, "so_48717494_48718305_4": {"length": 7, "quality": 0.7777777777777778, "section_id": 310}, "so_48717494_48718305_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 581}, "so_48717494_48718305_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 60}}}, "48717494": {"ViewCount": "75", "Body": "<p>From the C++ language standard, \u00a75.2.8 from ISO/IEC 14882:2003, quote,</p>\n<blockquote>\n<p id=\"so_48717494_48717494_0\">The top-level cv-qualifiers of the lvalue expression or the type-id that is the operand of typeid are always ignored.</p>\n</blockquote>\n<p>What is the rationale for this decision. It punched a hole in the type system and is counter-intuitive. The const information (or the volatile part) is known at compile time, so there would be no overhead if typeid just took account of cv-qualifiers.</p>\n", "Title": "What is the rationale behind the typeid operator ignoring cv-qualifiers", "CreationDate": "2018-02-10T05:14:23.060", "LastActivityDate": "2018-02-12T19:21:08.560", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2018-02-10T19:03:28.537", "LastEditorUserId": "196844", "Id": "48717494", "Score": "2", "OwnerUserId": "6156470", "Tags": "<c++><typeid><typeinfo>", "AnswerCount": "2"}, "48718305": {"Id": "48718305", "PostTypeId": "2", "Body": "<p>Notwithstanding the ability to overload nonstatic member functions with <code>const</code>, <code>volatile</code>, and <code>const volatile</code> variants (see [class.mfct.nonstatic]), types <code>D</code>, <code>const D</code>, <code>volatile D</code>, and <code>const volatile D</code> (for some non-cv-qualified type <code>D</code>) are not unrelated; the standard specifies in [basic.type.qualifier] that for each <em>cv-unqualified type</em>, there is a distinct <code>const</code>-qualified, <code>volatile</code>-qualified, and <code>const volatile</code>-qualified \"version\" of the type having the same representation and alignment requirements. If it were possible for <code>D</code> and <code>const D</code> to be unrelated to one another (e.g. by having different representations, storage requirements, or in the case of classes, different members), then a lot of the language would break down.</p>\n<p>For example, an object of type <code>D&amp;</code> is implicitly convertible to <code>const D&amp;</code>, <code>volatile D&amp;</code>, and <code>const volatile D&amp;</code> (see [conv.qual]). However, if <code>D</code> was allowed to be unrelated to <code>const D</code>, then this conversion would not make sense.</p>\n<p>Consider also that a number of places in the standard specify that top-level cv-qualifiers are ignored:</p>\n<ul>\n<li><p>[over.load] specifies:</p>\n<blockquote>\n<p id=\"so_48717494_48718305_0\">Parameter declarations that differ only in the presence or absence of <code>const</code> and/or <code>volatile</code> are equivalent. That is, the <code>const</code> and <code>volatile</code> type-specifiers for each parameter type are ignored when determining which function is being declared, defined, or called.</p>\n</blockquote></li>\n<li><p>[temp.param] specifies:</p>\n<blockquote>\n<p id=\"so_48717494_48718305_1\">The top-level <em>cv-qualifiers</em> on the <em>template-parameter</em> are ignored when determining its type.</p>\n</blockquote></li>\n<li><p>[basic.life], when specifying how storage of an object whose lifetime ended can be reused, mentions:</p>\n<blockquote>\n<p id=\"so_48717494_48718305_2\">the new object is of the same type as the original object (ignoring the top-level cv-qualifiers)</p>\n</blockquote></li>\n<li><p>[over.best.ics] specifies:</p>\n<blockquote>\n<p id=\"so_48717494_48718305_3\">Any difference in top-level cv-qualification is subsumed by the initialization itself and does not constitute a conversion. [<em>Example:</em> a parameter of type <code>A</code> can be initialized from an argument of type <code>const A</code>. The implicit conversion sequence for that case is the identity sequence; it contains no \u201cconversion\u201d from <code>const A</code> to <code>A</code>. ]</p>\n</blockquote></li>\n<li><p>[temp.deduct.call] specifies:</p>\n<blockquote>\n<p id=\"so_48717494_48718305_4\">If <code>A</code> is a cv-qualified type, the top level cv-qualifiers of <code>A</code>\u2019s type are ignored for type deduction.</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_48717494_48718305_5\">If <code>P</code> is a cv-qualified type, the top level cv-qualifiers of <code>P</code>\u2019s type are ignored for type deduction.</p>\n</blockquote>\n<p>([temp.deduct.conv] has similar language.)</p></li>\n<li><p>[except.throw] specifies:</p>\n<blockquote>\n<p id=\"so_48717494_48718305_6\">A <em>throw-expression</em> initializes a temporary object, the type of which is determined by removing any top-level <em>cv-qualifiers</em> from the static type of the operand of <code>throw</code> and adjusting the type from \u201carray of <code>T</code>\u201d or \u201cfunction returning <code>T</code>\u201d to \u201cpointer to <code>T</code>\u201d or \u201cpointer to function returning <code>T</code>\u201d, respectively.</p>\n</blockquote></li>\n<li><p>[except.handle] specifies:</p>\n<blockquote>\n<p id=\"so_48717494_48718305_7\">A <em>handler</em> is a match for a <em>throw-expression</em> with an object of type <code>E</code> if</p>\n<p id=\"so_48717494_48718305_8\">\u2014 The handler is of type <em>cv</em> <code>T</code> or <em>cv</em> <code>T&amp;</code> and <code>E</code> and <code>T</code> are the same type (ignoring the top-level cv-qualifiers), or \u2026</p>\n</blockquote></li>\n</ul>\n<p>All of these would have to be changed if <code>D</code>, <code>const D</code>, <code>volatile D</code>, and <code>const volatile D</code> were allowed to be unrelated types.</p>\n", "LastEditorUserId": "196844", "LastActivityDate": "2018-02-12T19:21:08.560", "Score": "2", "CreationDate": "2018-02-10T07:21:34.750", "ParentId": "48717494", "CommentCount": "6", "OwnerUserId": "196844", "LastEditDate": "2018-02-12T19:21:08.560"}, "48738808": {"Id": "48738808", "PostTypeId": "2", "Body": "<p>Because <code>typeid</code> returns dynamic type if the operand is a <a href=\"http://en.cppreference.com/w/cpp/language/object#Polymorphic_objects\" rel=\"nofollow noreferrer\">polymorphic object</a>. Cv-qualifiers are designed to be compile-time limits, and additional information has to be recorded at runtime to retrieve cv-qualifiers of dynamic type, so it is rational to ignore top-level cv-qualifiers.</p>\n<p>For operand of type or non-polymorphic object, <code>typeid</code> ignores top-level cv-qualifiers for consistency. Otherwise, for example, the following <code>assert</code> will fire unexpectedly:</p>\n<pre><code>struct Base {\n    virtual ~Base() {}\n};\n\nstruct Derived : public Base {};\n\nconst Derived *d = new Derived;\nconst Base *b = d;\n\nassert(typeid(*b) == typeid(decltype(*d))); // should not fire\n</code></pre>\n", "LastActivityDate": "2018-02-12T02:35:30.663", "Score": "1", "CreationDate": "2018-02-12T02:35:30.663", "ParentId": "48717494", "CommentCount": "0", "OwnerUserId": "5376789"}});