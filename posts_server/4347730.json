post_cb({"bq_ids": {"n4140": {"so_4347730_4347986_1": {"length": 8, "quality": 0.8, "section_id": 6975}, "so_4347730_4347986_0": {"length": 19, "quality": 0.95, "section_id": 169}}, "n3337": {"so_4347730_4347986_1": {"length": 8, "quality": 0.8, "section_id": 6721}, "so_4347730_4347986_0": {"length": 19, "quality": 0.95, "section_id": 163}}, "n4659": {"so_4347730_4347986_1": {"length": 8, "quality": 0.8, "section_id": 8474}, "so_4347730_4347986_0": {"length": 19, "quality": 0.95, "section_id": 174}}}, "4348214": {"Id": "4348214", "PostTypeId": "2", "Body": "<p>Firstly, I don't think there ever was an intent to make a sharp and precise distinction between the situations where only typenames are allowed (like base class name) and situations where non-type entities are allowed as well (like expressions). I'd say that the base class name context was singled out for some other reason.</p>\n<p>Secondly, it is not exactly correct to say that in function parameter declarations every entity is necessarily a typename. You can declare a parameter as follows</p>\n<pre><code>template &lt;class T&gt;\nvoid foo(const T::type&amp; v[T::value]);\n</code></pre>\n<p>Of course, the grammar in this case explicitly dictates that <code>type</code> must be a typename and <code>value</code> must be a value. However, the compiler can only figure that out <em>after</em> the syntactic analysis of the declaration, while I believe the idea of <code>typename</code> was introduced to aid the compiler in actually <em>starting</em> the proper syntactic analysis of the code, i.e. the distinction should be available <em>before</em> the syntactic analysis, as an input into the syntactic analysis. This distinction might have profound effects on the interpretation of the code.</p>\n", "LastActivityDate": "2010-12-03T17:34:39.977", "CommentCount": "0", "CreationDate": "2010-12-03T17:34:39.977", "ParentId": "4347730", "Score": "4", "OwnerUserId": "187690"}, "4348172": {"Id": "4348172", "PostTypeId": "2", "Body": "<p>If you slightly change your declaration, you get an entire different story</p>\n<pre><code>template &lt;class T&gt;\nvoid foo(T::type&amp; v);\n</code></pre>\n<p>That isn't unambiguous anymore. It could declare a variable of type <code>void</code> that is initialized by a bit-wise <code>AND</code> expression. The entire declaration would be templated. Of course, this semantically is all nonsense, but it syntactically is alright. </p>\n<p>The appearance of a single <code>const</code> syntactically makes it unambiguous, but it's too much context dependence to make this work in a compiler. It has to remember that it read a <code>const</code> or any other such thing, and when it parses the <code>T::type</code> after it will need to remember to take this name as a type. It would also further bloat the already complicated Standard beyond belief. </p>\n<p>Let's again change your function declaration</p>\n<pre><code>template &lt;class T&gt;\nvoid foo(const T::type);\n</code></pre>\n<p>Not even the appearance of <code>const</code> in there provides for a unambiguous parse. Should it be a function declaration with an unnamed parameter, or should it be a function declaration with an invalid parameter name that misses its type? A parameter's name is parsed by a <code>declarator-id</code>, which can also be a qualified name. So here, the <code>const</code> will belong to the type specifiers, while the <code>T::type</code> will be parsed by the compiler as the name of the parameter, in absence of a <code>typename</code>. That is totally nonsense too, <a href=\"http://llvm.org/bugs/show_bug.cgi?id=4594\" rel=\"nofollow noreferrer\">but is syntactically valid</a>.  </p>\n<p>In the case of base-class names <em>name lookup itself</em> states that non-type names are ignored. So you get omission of <code>typename</code> for free: The name that name lookup yields to more higher level modules of the compiler either refers to a type, or name lookup will have given an error. </p>\n<p>I have written a FAQ entry about <a href=\"https://stackoverflow.com/questions/610245/where-to-put-the-template-and-typename-on-dependent-names/613132#613132\">Where to put the \"template\" and \"typename\" on dependent names</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-12-03T17:43:54.727", "Score": "22", "CreationDate": "2010-12-03T17:31:32.987", "ParentId": "4347730", "CommentCount": "2", "OwnerUserId": "34509", "LastEditDate": "2017-05-23T11:53:31.280"}, "4347730": {"ViewCount": "3860", "Body": "<p>In C++, the <code>typename</code> keyword is needed so the compiler can disambiguate between nested types and nested values in templates.  However, there are certain situations where no ambiguity is possible, such as when a derived class inherits from a nested class type.</p>\n<pre><code>template &lt;class T&gt;\nclass Derived : public T::type\n{ };\n</code></pre>\n<p>Here the <code>typename</code> keyword is not required, and is in fact not even allowed.  This makes sense, because the context removes the ambiguity.  Here, <code>T::type</code> must refer to a type, since you obviously can't inherit from a value.</p>\n<p>I would think the same thing would hold true for function template parameters.</p>\n<pre><code>template &lt;class T&gt;\nvoid foo(const T::type&amp; v)\n{\n\n}\n</code></pre>\n<p>In this case, the context makes it clear that <code>T::type</code> must refer to a type, since a function parameter can't be a value.  Yet, the compiler doesn't accept this.  It wants <code>const typename T::type&amp;</code>.  This seems inconsistent.  Why does the language allow the implicit assumption of a nested type in the context of inheritance, but <em>not</em> in the context of function parameters?  In both cases there can be no ambiguity, so why the need for <code>typename</code> in one but not the other?</p>\n", "AcceptedAnswerId": "4348172", "Title": "Use of typename keyword with template function parameters", "CreationDate": "2010-12-03T16:38:58.870", "Id": "4347730", "CommentCount": "9", "FavoriteCount": "13", "PostTypeId": "1", "LastActivityDate": "2010-12-03T17:43:54.727", "Score": "28", "OwnerUserId": "469408", "Tags": "<c++><templates><typename>", "AnswerCount": "3"}, "4347986": {"Id": "4347986", "PostTypeId": "2", "Body": "<p>Would be interesting to find what is causing this.</p>\n<p>I've been trying to read the standard in search for an answer, please note I'm am novice in this. </p>\n<p>However I believe I've found a relevant clause.</p>\n<blockquote>\n<p id=\"so_4347730_4347986_0\">\u00a714.6.2. A name used in a template\n  declaration or definition and that is\n  dependent on a template-parameter is\n  assumed not to name a type <strong>unless the\n  applicable name lookup finds a type\n  name or the name is qualified by the\n  keyword typename</strong>.</p>\n</blockquote>\n<p>I guess this implies that the issue is in the difference of how name lookup works for base specifier lists and function arguments.</p>\n<p>Base specifier name lookup:</p>\n<blockquote>\n<p id=\"so_4347730_4347986_1\">\u00a710.2. During the lookup for a base\n  class name, <strong>non-type names are ignored</strong>\n  (3.3.10).</p>\n</blockquote>\n<p>Which explains why <strong>typename</strong> is not required for base specifiers.</p>\n<p>Still looking for function argument name lookup.</p>\n<p>Please correct me if this is an incorrect or irrelevant assumption. In the meantime I while keep digging. </p>\n<p>The error given by VS2010 when not qualifying the template argument in the function declaration is the following:</p>\n<blockquote>\n<p id=\"so_4347730_4347986_2\">'T::type' : dependent name is not a\n  type prefix with 'typename' to\n  indicate a type.</p>\n</blockquote>\n<p>However, I'm still unclear about the rules for dependent function argument name lookup...</p>\n", "LastEditorUserId": "346804", "LastActivityDate": "2010-12-03T17:19:53.270", "Score": "2", "CreationDate": "2010-12-03T17:06:33.897", "ParentId": "4347730", "CommentCount": "1", "OwnerUserId": "346804", "LastEditDate": "2010-12-03T17:19:53.270"}});