post_cb({"14079108": {"CommentCount": "3", "ViewCount": "445", "CreationDate": "2012-12-29T05:55:40.190", "LastActivityDate": "2012-12-29T07:08:25.703", "Title": "Standard C++ MoneyPunct / put_money bug?", "AcceptedAnswerId": "14079538", "PostTypeId": "1", "Id": "14079108", "Score": "0", "Body": "<p>There seems to be almost zero documentation on these money manipulators.  I am trying to figure this out by trial and error.  Consider the example program:</p>\n<pre><code>class CAccountingMoneyPunctFacet : public std::moneypunct&lt;char&gt;\n{\nprotected:\n    virtual string_type do_curr_symbol() const      {return \")\";}\n    virtual char_type do_thousands_sep() const      {return ',';}\n    virtual char_type do_decimal_point() const      {return '.';}\n    virtual string_type do_positive_sign() const    {return \"\";}\n    virtual string_type do_negative_sign() const    {return \"(\";}\n    virtual string_type do_grouping() const         {return \"\\03\";}\n    virtual int do_frac_digits() const              {return 2;}\n\n    virtual pattern do_pos_format() const\n    {\n        pattern p;\n        p.field[0] = value;\n        p.field[1] = none;\n        p.field[2] = none;\n        p.field[3] = none;\n        return p;\n    }\n\n    virtual pattern do_neg_format() const\n    {\n        pattern p;\n        p.field[0] = sign;\n        p.field[1] = value;\n        p.field[2] = symbol;    // Very retarded C++ standard need to do this kind of a hack for negative numbers!\n        p.field[3] = none;\n        return p;\n    }\n};\n\n\nint main(int argc,char* argv[])\n{\n    std::ostringstream oss;\n    oss.imbue(std::locale(std::locale(),new CAccountingMoneyPunctFacet));\n    oss &lt;&lt;  std::put_money(1234567.23) &lt;&lt; std::endl;\n//      &lt;&lt; (-1234567) &lt;&lt; \" \" &lt;&lt; std::setiosflags(std::ios_base::showbase) &lt;&lt; std::put_money(-12345678911.314159) &lt;&lt; std::endl;\n    std::cerr &lt;&lt; oss.str();\nreturn 0;\n}\n</code></pre>\n<p>The problem with this code is that it prints out 12,345.67.  Which is pretty bad since it not only lost the decimals it is now off by a factor of 100.  I look at the MSVC++ STL implementation and was quite perplexed:</p>\n<pre><code>virtual _OutIt __CLR_OR_THIS_CALL do_put(_OutIt _Dest,\n    bool _Intl, ios_base&amp; _Iosbase, _Elem _Fill,\n        long double _Val) const\n    {   // put long double to _Dest\n    bool _Negative = false;\n    if (_Val &lt; 0)\n        _Negative = true, _Val = -_Val;\n\n    size_t _Exp;\n    for (_Exp = 0; 1e35 &lt;= _Val &amp;&amp; _Exp &lt; 5000; _Exp += 10)\n        _Val /= 1e10;   // drop 10 zeros before decimal point\n\n    string_type _Val2;\n    char _Buf[40];\n\n    **int _Count = _CSTD sprintf_s(_Buf, sizeof (_Buf), \"%.0Lf\",**\n        _Val);  // convert to chars\n\n    for (int _Off = 0; _Off &lt; _Count; ++_Off)\n        _Val2.append((typename string_type::size_type)1,\n            _MAKLOCCHR(_Elem, _Buf[_Off], _Cvt));   // convert chars\n    _Val2.append(_Exp,\n        _MAKLOCCHR(_Elem, '0', _Cvt));  // scale by trailing zeros\n\n    return (_Putmfld(_Dest, _Intl, _Iosbase, _Fill, _Negative, _Val2));\n    }\n</code></pre>\n<p>Observe the function which takes a double but has a sprintf which chops off all the decimals.  Before I reinvent the wheel again, I would like to get the opinion of the C++ experts on here.  </p>\n", "Tags": "<c++><stl><locale><manipulators>", "OwnerUserId": "805547", "AnswerCount": "1"}, "14079538": {"ParentId": "14079108", "CommentCount": "1", "Body": "<p>Those are all direct requirements of the C++ standard:</p>\n<p><em>\u00a722.4.6.2.2[locale.money.put.virtuals]/1</em></p>\n<blockquote>\n<p id=\"so_14079108_14079538_0\">The argument units is transformed into a sequence of wide characters as if by <code>ct.widen(buf1, buf1 + sprintf(buf1, \"%.0Lf\", units), buf2)</code> [...] the pattern is the\n  result of <code>mp.pos_format()</code>.</p>\n</blockquote>\n<p>here, <code>mp</code> is the <code>std::moneypunct</code> facet, so, continuing on to its requirements,</p>\n<p><em>\u00a722.4.6.3[locale.moneypunct]/3</em></p>\n<blockquote>\n<p id=\"so_14079108_14079538_1\">The number of digits required after the decimal point (if any) is exactly the value returned by <code>frac_digits()</code>.</p>\n</blockquote>\n<p>and finally,\n<em>\u00a722.4.6.3.2[locale.moneypunct.virtuals]/6</em></p>\n<blockquote>\n<p id=\"so_14079108_14079538_2\"><code>int do_frac_digits() const;</code> Returns: The number of digits after the decimal radix separator, if any. [261]</p>\n<p id=\"so_14079108_14079538_3\">261) In common U.S. locales, this is 2.</p>\n</blockquote>\n<p>All this can indeed be summed as \"the argument to <code>put_money</code> is in cents\"</p>\n", "OwnerUserId": "273767", "PostTypeId": "2", "Id": "14079538", "Score": "3", "CreationDate": "2012-12-29T07:08:25.703", "LastActivityDate": "2012-12-29T07:08:25.703"}, "bq_ids": {"n4140": {"so_14079108_14079538_0": {"section_id": 6614, "quality": 0.7058823529411765, "length": 12}, "so_14079108_14079538_1": {"section_id": 6619, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_14079108_14079538_0": {"section_id": 6369, "quality": 0.7058823529411765, "length": 12}, "so_14079108_14079538_1": {"section_id": 6374, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_14079108_14079538_0": {"section_id": 8096, "quality": 0.7058823529411765, "length": 12}, "so_14079108_14079538_1": {"section_id": 8101, "quality": 0.9090909090909091, "length": 10}}}});