post_cb({"bq_ids": {"n4140": {"so_41869849_41870007_2": {"length": 13, "quality": 0.8666666666666667, "section_id": 5770}, "so_41869849_41870007_0": {"length": 17, "quality": 0.85, "section_id": 7156}, "so_41869849_41870007_1": {"length": 20, "quality": 0.625, "section_id": 7165}}, "n3337": {"so_41869849_41870007_2": {"length": 13, "quality": 0.8666666666666667, "section_id": 5543}, "so_41869849_41870007_0": {"length": 17, "quality": 0.85, "section_id": 6900}, "so_41869849_41870007_1": {"length": 20, "quality": 0.625, "section_id": 6909}}, "n4659": {"so_41869849_41870007_2": {"length": 13, "quality": 0.8666666666666667, "section_id": 7227}, "so_41869849_41870007_0": {"length": 13, "quality": 0.65, "section_id": 8661}, "so_41869849_41870007_1": {"length": 20, "quality": 0.625, "section_id": 8673}}}, "41869922": {"Id": "41869922", "PostTypeId": "2", "Body": "<p>If there is a limit in the static variables cleaned-up at program exit, it surely is NOT mandated by the C++ language standard.  </p>\n<p>Depending on the platform, compiler and runtime library, there may be however be some limitation, i.e. on embedded platforms with small CPU capabilities and/or strict memory constraints.</p>\n", "LastActivityDate": "2017-01-26T09:03:02.667", "CommentCount": "3", "CreationDate": "2017-01-26T09:03:02.667", "ParentId": "41869849", "Score": "2", "OwnerUserId": "1242646"}, "41870007": {"Id": "41870007", "PostTypeId": "2", "Body": "<p>The standard says that all destructors <em>must</em> be called if they have side effects.</p>\n<blockquote>\n<p id=\"so_41869849_41870007_0\"><code>[basic.start.term]/1:</code> Destructors (12.4) for initialized objects (that is, objects whose lifetime (3.8) has begun) with static storage\n  duration are called as a result of returning from main and as a result of calling std::exit (18.5). [...]</p>\n<p id=\"so_41869849_41870007_1\"><code>[basic.stc.static]/2:</code> If a variable with static storage duration has initialization or a destructor with side effects, it shall not be\n  eliminated even if it appears to be unused, except that a class object or its copy/move may be eliminated\n  as specified in 12.8.\n  The keyword static can be used to declare a local variable with static storage duration.</p>\n</blockquote>\n<p>However, the rules on standards compliance do allow for some leeway when it comes to implementation limits:</p>\n<blockquote>\n<p id=\"so_41869849_41870007_2\"><code>[intro.compilance]/2.1:</code> If a program contains no violations of the rules in this International Standard, a conforming implementation shall, <strong>within its resource limits</strong>, accept and correctly execute that program.</p>\n</blockquote>\n<p>A hard limit on the number of static variables allowed may seem odd, but common implementations have hard limits on all sorts of things, e.g. template instantiation depth.</p>\n", "LastActivityDate": "2017-01-26T09:07:34.547", "CommentCount": "0", "CreationDate": "2017-01-26T09:07:34.547", "ParentId": "41869849", "Score": "6", "OwnerUserId": "496161"}, "41869849": {"ViewCount": "97", "Body": "<p>I was talking with developpers from a platform which are claiming to support C++, but they said, in the same breath, that the number of static variables that are cleand-up at programm exit is bound to a magic number (i think they said 32 on their platform), they say that is conform with the C++ standard.</p>\n<p>Is this correct?</p>\n", "AcceptedAnswerId": "41870007", "Title": "Is the number of static variables limited in C++", "CreationDate": "2017-01-26T08:58:52.753", "Id": "41869849", "CommentCount": "8", "PostTypeId": "1", "LastActivityDate": "2017-01-26T09:07:34.547", "Score": "1", "OwnerUserId": "1235183", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}});