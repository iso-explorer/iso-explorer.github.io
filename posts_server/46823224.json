post_cb({"bq_ids": {"n4140": {"so_46823224_46823285_0": {"length": 5, "quality": 1.0, "section_id": 4240}}, "n3337": {"so_46823224_46823285_0": {"length": 5, "quality": 1.0, "section_id": 4081}}, "n4659": {"so_46823224_46823285_0": {"length": 5, "quality": 1.0, "section_id": 6399}}}, "46823277": {"Id": "46823277", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_46823224_46823277_0\">Is this guaranteed by the standard? </p>\n</blockquote>\n<p>As long as you don't use a custom allocator to create an instance of a container, I believe that is true.</p>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/memory/allocator\" rel=\"noreferrer\">http://en.cppreference.com/w/cpp/memory/allocator</a></p>\n<blockquote>\n<p id=\"so_46823224_46823277_1\">The <code>std::allocator</code> class template is the default Allocator used by all standard library containers if no user-specified allocator is provided. </p>\n</blockquote>\n<p>and</p>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/memory/allocator/allocate\" rel=\"noreferrer\">http://en.cppreference.com/w/cpp/memory/allocator/allocate</a>:</p>\n<blockquote>\n<p id=\"so_46823224_46823277_2\">Allocates <code>n * sizeof(T)</code> bytes of uninitialized storage by calling <code>::operator new(std::size_t)</code></p>\n</blockquote>\n", "LastActivityDate": "2017-10-19T05:22:55.563", "CommentCount": "0", "CreationDate": "2017-10-19T05:22:55.563", "ParentId": "46823224", "Score": "7", "OwnerUserId": "434551"}, "46823285": {"Id": "46823285", "PostTypeId": "2", "Body": "<p>The default allocator for allocator-aware containers such as <code>std::vector&lt;T&gt;</code> is <code>std::allocator&lt;T&gt;</code>. This class template is described in section [default.allocator] of the standard. According to [allocator.members]/6 in C++14:</p>\n<blockquote>\n<p id=\"so_46823224_46823285_0\">the storage is obtained by calling <code>::operator new(std::size_t)</code></p>\n</blockquote>\n<p>So the global operator new is the one that you need to replace. If you overloaded <code>operator new</code> specifically for <code>T</code>, that overload will <em>not</em> be used by the default allocator.</p>\n", "LastActivityDate": "2017-10-19T05:24:32.473", "CommentCount": "2", "CreationDate": "2017-10-19T05:24:32.473", "ParentId": "46823224", "Score": "27", "OwnerUserId": "481267"}, "46823224": {"ViewCount": "1870", "Body": "<p>If I replace all the <code>operator new</code> signatures that I can, at least on the implementations I have tested, I see that the standard containers call into my replaced versions to allocate memory.</p>\n<p>Is this guaranteed by the standard? That is, would it be illegal for an implementation to use an optimized version which didn't call my replacement functions for the memory underlying the standard containers?</p>\n", "Title": "Is it guaranteed that C++ standard library containers call the replaceable new functions?", "CreationDate": "2017-10-19T05:16:16.417", "LastActivityDate": "2017-10-19T13:25:09.867", "CommentCount": "6", "LastEditDate": "2017-10-19T13:25:09.867", "PostTypeId": "1", "LastEditorUserId": "1600770", "Id": "46823224", "Score": "21", "OwnerUserId": "149138", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "2"}});