post_cb({"30409313": {"Id": "30409313", "PostTypeId": "2", "Body": "<p>Those are the rules that the language designers decided on. <code>operator()</code> allows for a syntax which looks like it is part of the class itself (<code>std::function</code> in your case) and the interface of that class should be controlled by the class itself.</p>\n<p>The standard defines this in</p>\n<blockquote>\n<h3>13.5.4 Function call [over.call]</h3>\n<p id=\"so_30409287_30409313_0\"><sup>1</sup> <code>operator()</code> shall be a <strong>non-static member function</strong> with an arbitrary number of parameters. [...]</p>\n</blockquote>\n<p><em>emphasis mine</em></p>\n<p>Similar decisions were made for other operators like assignment <code>=</code>, subscripting <code>[]</code> and class member access <code>-&gt;</code>, while for operators like <code>&gt;&gt;</code>, they decided that it makes sense to allow adding operators between two (almost) arbitrary classes independently of the class' interface itself.</p>\n", "LastEditorUserId": "2073257", "LastActivityDate": "2015-05-23T05:54:10.863", "Score": "4", "CreationDate": "2015-05-23T05:44:31.683", "ParentId": "30409287", "CommentCount": "0", "OwnerUserId": "2073257", "LastEditDate": "2015-05-23T05:54:10.863"}, "bq_ids": {"n4140": {"so_30409287_30409313_0": {"length": 7, "quality": 1.0, "section_id": 662}, "so_30409287_30409317_3": {"length": 32, "quality": 0.9411764705882353, "section_id": 662}, "so_30409287_30409317_1": {"length": 15, "quality": 1.0, "section_id": 662}}, "n3337": {"so_30409287_30409313_0": {"length": 7, "quality": 1.0, "section_id": 652}, "so_30409287_30409317_3": {"length": 32, "quality": 0.9411764705882353, "section_id": 652}, "so_30409287_30409317_1": {"length": 15, "quality": 1.0, "section_id": 652}}, "n4659": {"so_30409287_30409313_0": {"length": 7, "quality": 1.0, "section_id": 690}, "so_30409287_30409317_3": {"length": 32, "quality": 0.9411764705882353, "section_id": 690}, "so_30409287_30409317_1": {"length": 15, "quality": 1.0, "section_id": 690}}}, "30409287": {"ViewCount": "313", "Body": "<p>I am just playing with <code>std::function&lt;&gt;</code> and <code>operator</code>s, to make C++ statements look like Functional Languages(<code>F#</code>) and found out that there is a difference between <code>operator()</code> and <code>operator&lt;&lt;</code>. My code :</p>\n<p>Function 1 (Operator Overload): </p>\n<pre><code>function&lt;int(int)&gt; operator&gt;&gt;(function&lt;int(int)&gt; f1, function&lt;int(int)&gt; f2)\n{\n  function&lt;int(int)&gt; f3 = [=](int x){return f1(f2(x));};\n  return f3;\n}\n</code></pre>\n<p>Function 2 (Operator Overload):</p>\n<pre><code>function&lt;int(int, int)&gt; operator&gt;&gt;(function&lt;int(int, int)&gt; f1, function&lt;int(int)&gt; f2)\n{\n  function&lt;int(int, int)&gt; f3 = [=](int x,int y){return f2(f1(x, y));};\n  return f3;\n}\n</code></pre>\n<p>Function 3 (Operator Overload):</p>\n<pre><code>function&lt;int(int)&gt; operator()(function&lt;int(int, int)&gt; f1, int x)\n{\n  function&lt;int(int)&gt; f2 = [=](int y){return f1(x, y);};\n  return f2;\n}\n</code></pre>\n<p>while the Function 1 and Function 2 ( or Operator Overload ), Function 3 gives out error that : </p>\n<pre><code>error: \u2018std::function&lt;int(int)&gt; operator()(std::function&lt;int(int, int)&gt;, int)\u2019 must be a nonstatic member function\n     function&lt;int(int)&gt; operator()(function&lt;int(int, int)&gt; f1, int x)\n                                                                    ^\n</code></pre>\n<p>Why do <code>operator()</code> needs to be non-static member?\nI think its different than <a href=\"https://stackoverflow.com/questions/1238613/what-is-the-difference-between-the-dot-operator-and-in-c\">What is the difference between the dot (.) operator and -&gt; in C++?</a> In that question the answer is explained in terms of pointers. But here I am using simple <code>operator()</code> and <code>operator&gt;&gt;</code>, which has nothing to do with pointers.</p>\n", "AcceptedAnswerId": "30420190", "Title": "Why did the C++ designers choose not to allow non-member operator()()?", "CreationDate": "2015-05-23T05:40:25.513", "Id": "30409287", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:23:14.517", "LastEditorUserId": "-1", "LastActivityDate": "2015-05-24T04:51:26.710", "Score": "4", "OwnerUserId": "3789604", "Tags": "<c++><c++11><gcc><g++><c++14>", "AnswerCount": "3"}, "30409317": {"Id": "30409317", "PostTypeId": "2", "Body": "<p><code>operator&gt;&gt;()</code> can be overloaded as a non-member function but not <code>operator()</code>. <code>operator()</code> can only be a non-static member function of a <code>class</code> or a <code>struct</code>.</p>\n<p>From the standard:</p>\n<blockquote>\n<p id=\"so_30409287_30409317_0\"><strong>13.5.4 Function call</strong>  [over.call]</p>\n<p id=\"so_30409287_30409317_1\">1 <code>operator()</code> shall be a non-static member function with an arbitrary number of parameters. It can have default arguments. It implements the function call syntax</p>\n<p id=\"so_30409287_30409317_2\"><em>postfix-expression ( expression-list opt )</em></p>\n<p id=\"so_30409287_30409317_3\">where the <em>postfix-expression</em> evaluates to a class object and the possibly empty <em>expression-list</em> matches the parameter list of an <code>operator()</code> member function of the class. Thus, a call <code>x(arg1,...)</code> is interpreted as <code>x.operator()(arg1, ...)</code> for a class object <code>x</code> of type <code>T</code> if <code>T::operator()(T1, T2, T3)</code> exists and if the operator is selected as the best match function by the overload resolution mechanism (13.3.3).</p>\n</blockquote>\n", "LastEditorUserId": "434551", "LastActivityDate": "2015-05-23T05:53:43.900", "Score": "1", "CreationDate": "2015-05-23T05:44:41.087", "ParentId": "30409287", "CommentCount": "0", "OwnerUserId": "434551", "LastEditDate": "2015-05-23T05:53:43.900"}, "30420190": {"Id": "30420190", "PostTypeId": "2", "Body": "<p><code>operator&gt;&gt;()</code> can be called as a non-static member or as a standalone function, depending on how it is defined for the left-hand data type.  The statement:</p>\n<pre><code>lhs &gt;&gt; rhs\n</code></pre>\n<p>Can resolve as either:</p>\n<pre><code>lhs.operator&gt;&gt;(rhs) // non-static member\n</code></pre>\n<p>Or:</p>\n<pre><code>operator&gt;&gt;(lhs, rhs) // standalone function\n</code></pre>\n<p><code>operator()</code>, on the other hand, cannot be called as a standalone function.  It must have something on the left-hand side to invoke it.  The statement:</p>\n<pre><code>lhs(arguments)\n</code></pre>\n<p>Can only resolve as:</p>\n<pre><code>lhs(arguments) // only if lhs is an actual function\n</code></pre>\n<p>Or:</p>\n<pre><code>lhs.operator()(arguments) // must be a non-static member\n</code></pre>\n<p>There is no C++ language syntax that would allow the statement:</p>\n<pre><code>lhs(arguments)\n</code></pre>\n<p>to resolve as:</p>\n<pre><code>operator()(lhs, arguments)\n</code></pre>\n", "LastActivityDate": "2015-05-24T04:51:26.710", "CommentCount": "1", "CreationDate": "2015-05-24T04:51:26.710", "ParentId": "30409287", "Score": "2", "OwnerUserId": "65863"}});