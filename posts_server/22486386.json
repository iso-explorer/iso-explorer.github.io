post_cb({"22486781": {"ParentId": "22486386", "CommentCount": "1", "Body": "<p>You can add a <code>typename=void</code> parameter to the end of the list of <code>template</code> arguments, then go hog wild with <code>std::enable_if_t&lt;</code> condition <code>&gt;</code> in specializations.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "22486781", "Score": "2", "CreationDate": "2014-03-18T17:32:10.673", "LastActivityDate": "2014-03-18T17:32:10.673"}, "22486386": {"CommentCount": "0", "AcceptedAnswerId": "22486607", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2014-03-18T17:13:48.920", "LastActivityDate": "2015-08-19T14:58:41.513", "LastEditDate": "2015-08-19T14:58:41.513", "ViewCount": "4338", "FavoriteCount": "8", "Title": "(Partially) specializing a non-type template parameter of dependent type", "Id": "22486386", "Score": "20", "Body": "<p>Maybe I'm tired, but I'm stuck with this simple partial specialization, which doesn't work because <code>non-type template argument specializes a template parameter with dependent type 'T'</code>:</p>\n<pre><code>template &lt;typename T, T N&gt; struct X;\ntemplate &lt;typename T&gt;      struct X &lt;T, 0&gt;;\n</code></pre>\n<p>Replacing <code>0</code> by <code>T(0)</code>, <code>T{0}</code> or <code>(T)0</code> doesn't help. So is this specialization even possible?</p>\n", "Tags": "<c++><templates><partial-specialization><non-type>", "OwnerUserId": "2644390", "AnswerCount": "4"}, "22486607": {"ParentId": "22486386", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>See paragraph [temp.class.spec] 14.5.5/8 of the standard:</p>\n<blockquote>\n<p id=\"so_22486386_22486607_0\">The type of a template parameter corresponding to a specialized\n  non-type argument shall not be dependent on a parameter of the\n  specialization. [ <em>Example:</em></p>\n<pre><code>template &lt;class T, T t&gt; struct C {};\ntemplate &lt;class T&gt; struct C&lt;T, 1&gt;; // error\n\ntemplate&lt; int X, int (*array_ptr)[X] &gt; class A {};\nint array[5];\ntemplate&lt; int X &gt; class A&lt;X,&amp;array&gt; { }; // error\n</code></pre>\n<p id=\"so_22486386_22486607_1\"><em>\u2014end example</em> ]</p>\n</blockquote>\n<p>The answer to your edit: the easiest workaround is to replace a non-type template parameter with a type one:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;typename T, typename U&gt;\nstruct X_;\n\ntemplate &lt;typename T, T N&gt;\nstruct X_&lt;T, std::integral_constant&lt;T, N&gt;&gt; {};\n\ntemplate &lt;typename T&gt;\nstruct X_&lt;T, std::integral_constant&lt;T, 0&gt;&gt; {};\n\ntemplate &lt;typename T, T N&gt;\nstruct X : X_&lt;T, std::integral_constant&lt;T, N&gt;&gt; {};\n</code></pre>\n", "OwnerUserId": "3043539", "LastEditorUserId": "3043539", "LastEditDate": "2014-03-18T19:43:29.670", "Id": "22486607", "Score": "19", "CreationDate": "2014-03-18T17:24:21.687", "LastActivityDate": "2014-03-18T19:43:29.670"}, "22487113": {"ParentId": "22486386", "CommentCount": "4", "Body": "<p>Solution using Yakk's solution:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\ntemplate &lt;typename T, T N, typename = void &gt; \nstruct X {\n  static const bool isZero = false;\n};\n\ntemplate &lt;typename T, T N&gt;\nstruct X &lt; T, N, typename std::enable_if&lt;N == 0&gt;::type &gt; {\n  static const bool isZero = true;\n};\n\nint main(int argc, char* argv[]) {\n    std::cout &lt;&lt; X &lt;int, 0&gt;::isZero &lt;&lt; std::endl;\n    std::cout &lt;&lt; X &lt;int, 1&gt;::isZero &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/qtMGew\">Live Demo</a></p>\n", "OwnerUserId": "1843316", "PostTypeId": "2", "Id": "22487113", "Score": "5", "CreationDate": "2014-03-18T17:47:26.563", "LastActivityDate": "2014-03-18T17:47:26.563"}, "22487448": {"ParentId": "22486386", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You need to pass an integral value in a template, Both, your first and second template, will not work if the type T is not an integral type.</p>\n<p>You can pass Traits as a typed template parameter to specify the value N:</p>\n<pre><code>#include &lt;iostream&gt;\n\n// error: \u2018double\u2019 is not a valid type for a template non-type parameter\ntemplate &lt;typename T, T N&gt; struct X0;\n\n// error: \u2018double\u2019 is not a valid type for a template non-type parameter\ntemplate &lt;typename T, T N, int = 0&gt; struct X1;\n\n\n\ntemplate &lt;typename T, T N&gt;\nstruct IntegralTraits {\n    static constexpr T Value() { return N; }\n};\n\ntemplate &lt;typename T, typename Traits = void&gt;\nstruct X2 {\n    static constexpr T Value() { return Traits::Value(); }\n};\n\ntemplate &lt;typename T&gt;\nstruct X2&lt;T, void&gt; {\n    static constexpr T Value() { return T(); }\n};\n\n\nint main() {\n    // error: \u2018double\u2019 is not a valid type for a template non-type parameter\n    // X0&lt;double, 0&gt;();\n\n    // error: \u2018double\u2019 is not a valid type for a template non-type parameter\n    // X1&lt;double, 0&gt;();\n\n    X2&lt;int&gt; a;\n    X2&lt;double, IntegralTraits&lt;int, 1&gt;&gt; b;\n\n    std::cout.precision(2);\n    std::cout &lt;&lt; std::fixed  &lt;&lt;  a.Value() &lt;&lt; \", \"&lt;&lt; b.Value() &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>\n<p>If you limit yourself to integral types pick a large one:</p>\n<pre><code>template &lt;typename T, std::size_t N = 0&gt; struct X {};\n</code></pre>\n", "OwnerUserId": "2249683", "LastEditorUserId": "2249683", "LastEditDate": "2014-03-18T18:10:09.780", "Id": "22487448", "Score": "0", "CreationDate": "2014-03-18T18:03:06.540", "LastActivityDate": "2014-03-18T18:10:09.780"}, "bq_ids": {"n4140": {"so_22486386_22486607_0": {"section_id": 142, "quality": 0.8333333333333334, "length": 10}}, "n3337": {"so_22486386_22486607_0": {"section_id": 136, "quality": 0.8333333333333334, "length": 10}}, "n4659": {"so_22486386_22486607_0": {"section_id": 146, "quality": 0.8333333333333334, "length": 10}}}});