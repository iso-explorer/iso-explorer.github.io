post_cb({"bq_ids": {"n4140": {"so_17514704_17514704_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 3884}, "so_17514704_17514704_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 3903}, "so_17514704_17514704_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 3883}}, "n3337": {"so_17514704_17514704_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 3743}, "so_17514704_17514704_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 3763}, "so_17514704_17514704_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 3744}}, "n4659": {"so_17514704_17514704_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 4762}, "so_17514704_17514704_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 4774}, "so_17514704_17514704_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 4763}}}, "17514704": {"ViewCount": "592", "Body": "<p>When running <code>git bisect</code> on some C++ code (written for GCC), I came across a compiler error generated by something along the lines of</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n  for (int i = 0; i &lt; 10; ++i) {\n    long i = 0;\n    printf(\"%ld\\n\", i);\n  }\n  return 0;\n}\n</code></pre>\n<p>This piece of code is, I beleive, perfectly standard C99 (<code>gcc -std=c99</code> compiles it fine), however, <code>g++</code> fails because of the redeclaration of <code>i</code>. The answer <a href=\"https://stackoverflow.com/a/12351531/560450\">https://stackoverflow.com/a/12351531/560450</a> quoted the C++11 standard on this matter:</p>\n<blockquote>\n<p id=\"so_17514704_17514704_0\">6.4/2 The rules for conditions apply both to selection-statements and to the for and while statements</p>\n<p id=\"so_17514704_17514704_1\">6.4/3 If the name is re-declared in the outermost block of a substatement controlled by the condition, the declaration that\n  re-declares the name is ill-formed.</p>\n<p id=\"so_17514704_17514704_2\">6.5.3/1 names declared in the for-init-statement are in the same declarative-region as those declared in the condition</p>\n</blockquote>\n<p>Therefore, I am no more curious about why this is illegal C++. :-) I would just like to get it compile!</p>\n<p>I looked at G++'s options related to language dialects. According to the <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.8.1/gcc/C_002b_002b-Dialect-Options.html#C_002b_002b-Dialect-Options\" rel=\"nofollow noreferrer\" title=\"GCC 4.8.1 Online Documentation: 3.5 Options Controlling C++ Dialect\">manual</a>,</p>\n<blockquote>\n<p id=\"so_17514704_17514704_3\">If <code>-ffor-scope</code> is specified, the scope of variables declared in a\n  <em>for-init-statement</em> is limited to the <code>\u2018for\u2019</code> loop itself, as specified\n  by the C++ standard. If <code>-fno-for-scope</code> is specified, the scope of\n  variables declared in a <em>for-init-statement</em> extends to the end of the\n  enclosing scope, as was the case in old versions of G++, and other\n  (traditional) implementations of C++.</p>\n</blockquote>\n<p>This is the only even remotely related-sounding option I could find. Oddly enough, passing <code>-fno-for-scope</code> to <code>g++</code> makes the example compile; with no warnings even with <code>-Wall -Wextra</code>. However, back to the code I would like to compile, this option generates many errors, because the variables initialized in a <em>for-init-statement</em> now have there scope extended. Clearly, this is not the solution.</p>\n<p><em>Just to clarify: I am not looking to compile C99 code with a C++ compiler, that would be foolish. I have some C++ code; <code>git blame</code> tells that the line with the redeclaration is from 2001. I would like to compile a commit which was tagged for release in 2011, therefore, I presume it was not broken at that time.</em></p>\n<p>What could I do to get it compile without modifications? Currently, I cherry-pick a commit that that renames the offending variable, but I would prefer to pass something in <code>CXXFLAGS</code> to <code>configure</code>. More generally, why does (or did) <code>g++</code> have this behaviour with <code>-fno-for-scope</code> and the redeclarations?</p>\n<p><strong>EDIT:</strong> Okay, probably I should have been more explicit. The fact that I have some code form 2001 which is broken today is just to set some context. The present-day <code>master</code> of the repository, of course, compiles without any compiler trickery. However, I am interested in how could I make <code>g++</code> behave as it behaved historically, because there is an overwhelming probability that the time the commit in question was tagged, <code>g++</code> accepted this kind of code.</p>\n<p><strong>EDIT2:</strong> After playing around with <code>-fdump-tree-original</code>, the question basically becomes: <em>Was there any C++ standard or non-standard C++ implementation (in GCC, preferably) in which in a variable declared in a <code>for-init-statement</code> lived in a different scope than either the loop body or the sorrounding code?</em></p>\n", "Title": "Redeclaring for-loop variables in old g++", "CreationDate": "2013-07-07T17:56:55.333", "LastActivityDate": "2013-07-07T18:28:47.187", "CommentCount": "6", "LastEditDate": "2017-05-23T12:23:37.330", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "17514704", "Score": "1", "OwnerUserId": "560450", "Tags": "<c++><for-loop><g++><declaration><compiler-options>", "AnswerCount": "0"}});