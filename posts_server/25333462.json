post_cb({"25333462": {"CommentCount": "0", "AcceptedAnswerId": "25334005", "PostTypeId": "1", "LastEditorUserId": "241631", "CreationDate": "2014-08-15T20:08:37.057", "LastActivityDate": "2014-08-15T20:48:33.363", "LastEditDate": "2014-08-15T20:19:42.893", "ViewCount": "80", "FavoriteCount": "0", "Title": "Memory referenced by rvalue references", "Id": "25333462", "Score": "3", "Body": "<p>Given a function</p>\n<pre><code>int foo()\n{\n   return 15;\n}\n</code></pre>\n<p>it is OK to use:</p>\n<pre><code>int&amp;&amp; ref = foo();\n</code></pre>\n<p>but not OK to use:</p>\n<pre><code>int&amp; ref = foo();\n</code></pre>\n<p>which is understandable since the return value of <code>foo()</code> is an <code>rvalue</code>. However, how I am able to use the following?</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nvoid f(T&amp;&amp; param)\n{\n   param *= 2;\n}\n\nint foo()\n{\n   return 15;\n}\n\nint test1()\n{\n   int&amp;&amp; ref = foo();\n   std::cout &lt;&lt; \"ref = \" &lt;&lt; ref &lt;&lt; std::endl;\n   f(ref);\n   std::cout &lt;&lt; \"ref = \" &lt;&lt; ref &lt;&lt; std::endl;\n}\n\nint main()\n{\n   test1();\n   return 0;\n}\n</code></pre>\n<p>with the following output, which looks reasonable:</p>\n<pre>\nref = 15\nref = 30\n</pre>\n<p>It seems that <code>ref</code> points to memory that is writeable. Does the line:</p>\n<pre><code>   int&amp;&amp; ref = foo();\n</code></pre>\n<p>allocate writeable memory for use by <code>ref</code>?</p>\n<p>Is this standard compliant? </p>\n<p>The code was tested using g++ 4.8.2.</p>\n", "Tags": "<c++><c++11><rvalue-reference>", "OwnerUserId": "434551", "AnswerCount": "1"}, "25334005": {"ParentId": "25333462", "CommentCount": "1", "Body": "<p>Yes, the behavior is well-defined because by binding the return value to an rvalue reference, you've extended the lifetime of the temporary to match that of the reference it is bound to.</p>\n<p>From <em>\u00a712.2 [class.temporary]</em></p>\n<blockquote>\n<p id=\"so_25333462_25334005_0\"><em>4</em> \u00a0 There are two contexts in which temporaries are destroyed at a different point than the end of the full-expression. <code>...</code><br/>\n<em>5</em> \u00a0 The second context is when a reference is bound to a temporary. The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference except: <br/>\n<code>...</code> (list of exceptions, none of which apply to this case)</p>\n</blockquote>\n<p>Note that the lifetime extension rule only applies to <a href=\"https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues\"><em>prvalues</em>, and not <em>xvalues</em></a> (refer to <em>\u00a712.2/1</em>). So if your example did the following, you'd have a dangling reference:</p>\n<pre><code>int&amp;&amp; ref = std::move(foo());\n</code></pre>\n", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "25334005", "Score": "4", "CreationDate": "2014-08-15T20:48:33.363", "LastActivityDate": "2014-08-15T20:48:33.363"}, "bq_ids": {"n4140": {"so_25333462_25334005_0": {"section_id": 382, "quality": 0.5555555555555556, "length": 20}}, "n3337": {"so_25333462_25334005_0": {"section_id": 373, "quality": 0.5555555555555556, "length": 20}}, "n4659": {"so_25333462_25334005_0": {"section_id": 397, "quality": 0.5277777777777778, "length": 19}}}});