post_cb({"44280061": {"CommentCount": "0", "ViewCount": "99", "CreationDate": "2017-05-31T08:53:34.080", "LastActivityDate": "2017-05-31T09:44:31.560", "Title": "What does the scope resolution operator return in case of Type::var?", "AcceptedAnswerId": "44280318", "PostTypeId": "1", "Id": "44280061", "Score": "3", "Body": "<p>Consider the following example:</p>\n<pre><code>class A { int x; };\n</code></pre>\n<p>Now what is <code>A::x</code>?</p>\n<ul>\n<li>It cannot be an lvalue because it does not refer to a storage Location.</li>\n<li>It cannot be a type, because the type would be <code>decltype(A::x)</code>.</li>\n</ul>\n", "Tags": "<c++><c++11><scope><operators><member>", "OwnerUserId": "4792058", "AnswerCount": "5"}, "44281278": {"ParentId": "44280061", "CommentCount": "1", "Body": "<p><code>A::x</code> is exact equivalent of accessing static variable in JAVA. </p>\n<p>Regarding your example:- </p>\n<p>1) <strong>x</strong> will be variable for distinct objects</p>\n<p>2) <strong>A::x</strong> will be the variable for the class itself. Regardless of how many objects of A has been declared for every object the value of <code>A::x</code> will be same until assignment. </p>\n<p>For example:-</p>\n<pre><code>#include&lt;iostream&gt;\n\nusing namespace std;\n\nclass A { \npublic:\n   static int x; \n};\n\nint A::x;\n\nint main()\n{\n   A a,b;\n\n   a.x=8;\n\n   b.x=6;\n\n   A::x=10;\n\n\n   return 0;\n}\n</code></pre>\n", "OwnerUserId": "7010082", "PostTypeId": "2", "Id": "44281278", "Score": "-3", "CreationDate": "2017-05-31T09:44:31.560", "LastActivityDate": "2017-05-31T09:44:31.560"}, "44280179": {"ParentId": "44280061", "CommentCount": "5", "Body": "<p><code>A::x</code> is merely a less ambiguous way of referring to the member <code>x</code> which can be necessary if the local context <em>shadows</em> that member:</p>\n<p><hr>\nExample 1:</hr></p>\n<p>A child class also has a member <code>x</code>.</p>\n<pre><code>struct B : public A\n{\n    int x;\n    void foo()\n    {\n        int local_x = x;\n        int parent_x = A::x;\n    }\n}\n</code></pre>\n<p>which would compile had you made <code>x</code> <code>protected</code> in class <code>A</code> (it's currently <code>private</code>).</p>\n<p><hr>\nExample 2:</hr></p>\n<p>You can even use it in a member <em>function</em> of <code>A</code> that has <code>x</code> as a parameter:</p>\n<pre><code>class A {\n    int x;\n    void foo(int x)\n    {\n        int parameter_x = x;\n        int member_x = A::x;\n    }\n};\n</code></pre>\n", "OwnerUserId": "2380830", "PostTypeId": "2", "Id": "44280179", "Score": "6", "CreationDate": "2017-05-31T08:59:13.543", "LastActivityDate": "2017-05-31T08:59:13.543"}, "44280318": {"ParentId": "44280061", "LastEditDate": "2017-05-31T09:12:35.303", "CommentCount": "2", "CreationDate": "2017-05-31T09:04:56.720", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "PostTypeId": "2", "Id": "44280318", "Score": "11", "Body": "<p>It is, in fact, an lvalue. <a href=\"https://timsong-cpp.github.io/cppwp/expr.prim.id.qual#2\" rel=\"noreferrer\">[expr.prim.id.qual]/2</a>:</p>\n<blockquote>\n<p id=\"so_44280061_44280318_0\">A <em>nested-name-specifier</em> that denotes a class [...] followed by the\n  name of a member of either that class ([class.mem]) or one of its base\n  classes, is a <em>qualified-id</em> [...]. The result is the member. The type\n  of the result is the type of the member. The result is an lvalue if\n  the member is a static member function or a data member and a prvalue\n  otherwise.</p>\n</blockquote>\n<p>Though its usage outside a class member access expression is severely restricted by <a href=\"https://timsong-cpp.github.io/cppwp/expr.prim.id#2\" rel=\"noreferrer\">[expr.prim.id]/2</a>, it can notably be used in unevaluated operands, where its lvalueness can manifest:</p>\n<pre><code>struct A {\n    int x;\n};\n\nvoid f(int &amp;);\n\nusing p = decltype(&amp;(A::x)); // p is int*; the parens prevents forming a pointer-to-member\nusing q = decltype(f(A::x)); // q is void\n</code></pre>\n", "LastActivityDate": "2017-05-31T09:12:35.303"}, "44280834": {"ParentId": "44280061", "CommentCount": "0", "Body": "<p>From the C++ Standard (5.1 Primary expressions)</p>\n<blockquote>\n<p id=\"so_44280061_44280834_0\">9 A nested-name-specifier that denotes a class, optionally followed by\n  the keyword template (14.2), and then followed by the name of a member\n  of either that class (9.2) or one of its base classes (Clause 10), is\n  a qualified-id; 3.4.3.1 describes name lookup for class members that\n  appear in qualified-ids. The result is the member. The type of the\n  result is the type of the member. <strong>The result is an lvalue if the\n  member is a static member function or a data member</strong> and a prvalue\n  otherwise. [ Note: a class member can be referred to using a\n  qualified-id at any point in its potential scope (3.3.7). \u2014end note\n  ]...</p>\n</blockquote>\n<p>The qualified name allows to specify an otherwise hidden name for example when  derived and base classes have members with the same name. For example</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    int i;\n};\n\nstruct B : A\n{\n    B( int i ) : A { i }, i( 2 * A::i ) {}\n    int i;\n    std::ostream &amp;out( std::ostream &amp;os = std::cout ) const\n    {\n        return os &lt;&lt; \"A::i = \" &lt;&lt; A::i &lt;&lt; \", B::i = \" &lt;&lt; B::i;\n    }\n};\n\nint main() \n{\n    B( 10 ).out() &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>The program output is</p>\n<pre><code>A::i = 10, B::i = 20\n</code></pre>\n<p>Also (5.1 Primary expressions)</p>\n<blockquote>\n<p id=\"so_44280061_44280834_1\">13 An id-expression that denotes a non-static data member or\n  non-static member function of a class can only be used:</p>\n<p id=\"so_44280061_44280834_2\">(13.1) \u2014 as part of a class member access (5.2.5) in which the object\n  expression refers to the member\u2019s class63 or a class derived from that\n  class, or</p>\n<p id=\"so_44280061_44280834_3\">(13.2) \u2014 to form a pointer to member (5.3.1), or</p>\n<p id=\"so_44280061_44280834_4\">(13.3) \u2014 if that id-expression denotes a non-static data member and it\n  appears in an unevaluated operand.</p>\n</blockquote>\n", "OwnerUserId": "2877241", "PostTypeId": "2", "Id": "44280834", "Score": "0", "CreationDate": "2017-05-31T09:26:44.753", "LastActivityDate": "2017-05-31T09:26:44.753"}, "bq_ids": {"n4140": {"so_44280061_44280834_2": {"section_id": 5959, "quality": 0.7857142857142857, "length": 11}, "so_44280061_44280834_1": {"section_id": 5959, "quality": 1.0, "length": 10}, "so_44280061_44280318_0": {"section_id": 5955, "quality": 0.8787878787878788, "length": 29}, "so_44280061_44280834_0": {"section_id": 5955, "quality": 0.8524590163934426, "length": 52}, "so_44280061_44280834_4": {"section_id": 5959, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_44280061_44280834_2": {"section_id": 5728, "quality": 0.7857142857142857, "length": 11}, "so_44280061_44280834_1": {"section_id": 5728, "quality": 1.0, "length": 10}, "so_44280061_44280318_0": {"section_id": 5724, "quality": 0.8787878787878788, "length": 29}, "so_44280061_44280834_0": {"section_id": 5724, "quality": 0.8524590163934426, "length": 52}, "so_44280061_44280834_4": {"section_id": 5728, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_44280061_44280834_2": {"section_id": 7440, "quality": 0.7857142857142857, "length": 11}, "so_44280061_44280834_4": {"section_id": 7440, "quality": 0.8888888888888888, "length": 8}, "so_44280061_44280834_1": {"section_id": 7440, "quality": 1.0, "length": 10}, "so_44280061_44280834_0": {"section_id": 7443, "quality": 0.8524590163934426, "length": 52}, "so_44280061_44280318_0": {"section_id": 7443, "quality": 0.8787878787878788, "length": 29}}}, "44280285": {"ParentId": "44280061", "CommentCount": "1", "Body": "<p>In addition to Bathsheba's answer, which is correct when you're within the class's scope, <code>A::x</code> can also be used as part of a pointer-to-member expression, i.e. <code>&amp;A::x</code>, which returns a <code>int A::*</code>.</p>\n<p>In this case, the standalone <code>A::x</code> is not valid and therefore the question of what it returns is moot.</p>\n", "OwnerUserId": "8922", "PostTypeId": "2", "Id": "44280285", "Score": "2", "CreationDate": "2017-05-31T09:03:28.787", "LastActivityDate": "2017-05-31T09:03:28.787"}});