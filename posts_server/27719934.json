post_cb({"bq_ids": {"n4140": {"so_27719934_27720191_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 129}}, "n3337": {"so_27719934_27720191_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 123}}}, "27719934": {"ViewCount": "767", "Body": "<p>I am trying to overload the ostream operator in template and inherited classes and I have been following some tips <a href=\"https://stackoverflow.com/questions/4571611/making-operator-virtual\">here</a> and <a href=\"https://stackoverflow.com/questions/4147399/template-class-friend-operator-overload\">here</a>, but I get a redefinition error. Here is a reproduction of my code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nenum type\n{\n        A,\n        B\n};\n\ntemplate &lt;type T&gt;\nclass base\n{\nprotected:\n        virtual std::ostream&amp; print(std::ostream&amp; out) const =0;\n};\n\ntemplate &lt;type T&gt;\nclass derived: public base&lt;T&gt;\n{\nprotected:\n        virtual std::ostream&amp; print(std::ostream&amp; out) const\n        {\n                out&lt;&lt;\"Hello World.\\n\";\n                return out;\n        }\npublic:\n        template &lt;type S&gt;\n        friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const derived&lt;S&gt;&amp; D)\n        {\n                return (D.print(out));\n        }\n};\n\nint main ()\n{\n#ifdef __NOT_WORKING__\n        derived&lt;A&gt; a;\n        std::cout&lt;&lt;a;\n        derived&lt;B&gt; b;\n        std::cout&lt;&lt;b;\n#else\n        derived&lt;A&gt; a;\n        std::cout&lt;&lt;a;\n#endif\n        return 0;\n}\n</code></pre>\n<p>If I define just a derived A class, everything works, but if I define a derived A and a derived B class I get this error from the compiler:</p>\n<pre><code>test.cpp: In instantiation of 'class derived&lt;(type)1u&gt;':\ntest.cpp:38:20:   required from here\ntest.cpp:27:30: error: redefinition of 'template&lt;type S&gt; std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const derived&lt;S&gt;&amp;)'\n         friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const derived&lt;S&gt;&amp; D)\n                              ^\ntest.cpp:27:30: note: 'template&lt;type S&gt; std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const derived&lt;S&gt;&amp;)' previously defined here\ntest.cpp: In instantiation of 'std::ostream&amp; operator&lt;&lt;(std::ostream&amp;, const derived&lt;S&gt;&amp;) [with type S = (type)1u; type T = (type)0u; std::ostream = std::basic_ostream&lt;char&gt;]':\ntest.cpp:39:20:   required from here\ntest.cpp:20:31: error: 'std::ostream&amp; derived&lt;T&gt;::print(std::ostream&amp;) const [with type T = (type)1u; std::ostream = std::basic_ostream&lt;char&gt;]' is protected\n         virtual std::ostream&amp; print(std::ostream&amp; out) const\n                               ^\ntest.cpp:29:37: error: within this context\n                 return (D.print(out));\n                                     ^\n</code></pre>\n<p>Why is it redefining the friend function?\nThanks for your time.</p>\n<p>PS. I am using gcc49.</p>\n", "AcceptedAnswerId": "27720043", "Title": "Redefinition error in ostream overload in template and inherited classes", "CreationDate": "2014-12-31T10:38:43.323", "Id": "27719934", "CommentCount": "0", "LastEditDate": "2017-05-23T11:44:55.323", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2014-12-31T11:01:55.637", "Score": "2", "OwnerUserId": "4187292", "Tags": "<c++><templates><inheritance><ostream>", "AnswerCount": "2"}, "27720191": {"PostTypeId": "2", "Body": "<p>[temp.friend]/4:</p>\n<blockquote>\n<p id=\"so_27719934_27720191_0\">When a function is defined in a friend function declaration in a class\n  template, the function is instantiated when the function is odr-used.\n  <strong>The same restrictions on multiple declarations and definitions that\n  apply to non-template function declarations and definitions also apply\n  to these implicit definitions.</strong></p>\n</blockquote>\n<p>Clang compiles the above fine - that can be considered a bug, but recall that violations of the ODR are ill-formed with no diagnostic required.</p>\n<hr>\n<p>You have two ways to solve this. Extract the definition of the template:</p>\n<pre><code>template &lt;typename T&gt;\nclass derived: public base&lt;T&gt;\n{\n//     [..]\n\n       template &lt;type S&gt;\n       friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const derived&lt;S&gt;&amp; D);\n};\n\ntemplate &lt;type S&gt;\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const derived&lt;S&gt;&amp; D)\n{\n    return (D.print(out));\n}\n</code></pre>\n<p>Or make the operator a non-template:</p>\n<pre><code>template &lt;type T&gt;\nclass derived: public base&lt;T&gt;\n{\n//     [..]\n\n       friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const derived&lt;T&gt;&amp; D)\n       {\n               return (D.print(out));\n       }\n};\n</code></pre>\n</hr>", "LastActivityDate": "2014-12-31T11:01:55.637", "Id": "27720191", "CommentCount": "0", "CreationDate": "2014-12-31T11:01:55.637", "ParentId": "27719934", "Score": "0", "OwnerUserId": "3647361"}, "27720043": {"Id": "27720043", "PostTypeId": "2", "Body": "<p>Replace </p>\n<pre><code>template &lt;type S&gt;\nfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const derived&lt;S&gt;&amp; D)\n{\n    return (D.print(out));\n}\n</code></pre>\n<p>with </p>\n<pre><code>friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const derived&lt;T&gt;&amp; D)\n{\n    return (D.print(out));\n}\n</code></pre>\n<p>error will go away.</p>\n<p>With earlier definition, you are trying to define a new template function with same signature.</p>\n", "LastEditorUserId": "3924882", "LastActivityDate": "2014-12-31T10:54:24.223", "CommentCount": "1", "CreationDate": "2014-12-31T10:48:09.537", "ParentId": "27719934", "Score": "1", "OwnerUserId": "3924882", "LastEditDate": "2014-12-31T10:54:24.223"}});