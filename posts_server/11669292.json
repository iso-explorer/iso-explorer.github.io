post_cb({"bq_ids": {"n4140": {"so_11669292_11669652_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 5979}}, "n3337": {"so_11669292_11669652_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 5747}}, "n4659": {"so_11669292_11669652_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 7461}}}, "11669652": {"Id": "11669652", "PostTypeId": "2", "Body": "<p>C++11's lambda's copy-assignment operator is explicitly disabled<sup>1</sup>. This is not a matter of \"semantically equivalent\". It can't even assign back to itself. Not to mention an unrelated type.</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;type_traits&gt;\n\nint main() {\n    auto lambda1 = []() -&gt; void { printf(\"Lambda 1!\\n\"); };\n    lambda1 = lambda1;  // error: use of deleted function \u2018main()::&lt;lambda()&gt;&amp; main()::&lt;lambda()&gt;::operator=(const main()::&lt;lambda()&gt;&amp;)\u2019\n    return 0;\n}\n</code></pre>\n<hr>\n<p><code>std::function</code> can hold an Objective-C block.</p>\n<ul>\n<li><code>std::function</code> can hold any types which can be invoked as <code>f(a,b,c,...)</code>. Since blocks support \"the invoke operator\", it can also be held by a <code>std::function</code>. But notice that Objective-C and C++ follow different memory management scheme, so storing a block in a <code>std::function</code> for a long time may cause dangling reference. </li>\n</ul>\n<hr>\n<p>Lambdas are assignable to Objective-C blocks:</p>\n<ul>\n<li>Blame <a href=\"https://stackoverflow.com/questions/4148242/is-it-possible-to-convert-a-c0x-lambda-to-a-clang-block\">SAHChandler</a><sup>2</sup> :). It's not documented yet, though.</li>\n</ul>\n<hr>\n<p><sup>1</sup>: C++11 \u00a75.1.2/19:</p>\n<blockquote>\n<p id=\"so_11669292_11669652_0\">The closure type associated with a <em>lambda-expression</em> has a deleted (8.4.3) default constructor and a deleted copy assignment operator.</p>\n</blockquote>\n<p><sup>2</sup>: <a href=\"http://llvm.org/viewvc/llvm-project?view=rev&amp;revision=150620\" rel=\"nofollow noreferrer\">http://llvm.org/viewvc/llvm-project?view=rev&amp;revision=150620</a></p>\n</hr></hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2012-07-26T13:26:43.490", "Score": "14", "CreationDate": "2012-07-26T12:47:44.243", "ParentId": "11669292", "CommentCount": "0", "OwnerUserId": "224671", "LastEditDate": "2017-05-23T12:30:33.023"}, "11669292": {"ViewCount": "3215", "Body": "<p>So, I just upgraded to Xcode 4.4, and I noticed in the changelog: </p>\n<blockquote>\n<p id=\"so_11669292_11669292_0\">Apple LLVM compiler supports additional C++11 features, including lambdas</p>\n</blockquote>\n<p>Which is awesome! So I got around to coding, and I found a few things out:</p>\n<ol>\n<li><p>Lambdas are assignable to Objective-C blocks:</p>\n<pre><code>void (^block)() = []() -&gt; void { \n    NSLog(@\"Inside Lambda called as block!\");\n};\n\nblock();\n</code></pre></li>\n<li><p><code>std::function</code> can hold an Objective-C block:</p>\n<pre><code>std::function&lt;void(void)&gt; func = ^{\n    NSLog(@\"Block inside std::function\");\n};\n\nfunc();\n</code></pre></li>\n<li><p>We cant assign an Objective-C block to a lambda:</p>\n<pre><code>auto lambda = []() -&gt; {\n    NSLog(@\"Lambda!\");\n};\n\nlambda = ^{ // error!\n    NSLog(@\"Block!\");\n};\n\nlambda();\n</code></pre></li>\n</ol>\n<p>Why is this? Shouldn't the two be semantically equivalent, given what we've seen above?</p>\n", "AcceptedAnswerId": "11669652", "Title": "Objective-C++ 11 - Why can't we assign a block to a lambda?", "CreationDate": "2012-07-26T12:27:27.257", "Id": "11669292", "CommentCount": "1", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2012-07-26T19:18:43.373", "LastEditorUserId": "636019", "LastActivityDate": "2012-07-26T19:18:43.373", "Score": "14", "OwnerUserId": "427309", "Tags": "<c++><objective-c><lambda><c++11><objective-c++>", "AnswerCount": "2"}, "11669626": {"Id": "11669626", "PostTypeId": "2", "Body": "<p>Lambdas have their own, implementation-defined types which are specific to each lambda.  The following code is also an error:</p>\n<pre><code>auto l1=[](){return 1;}\nauto l2=[](){return 2;}\nl1=l2; //Error\n</code></pre>\n<p><code>std::function</code> is a wrapper which is designed to hold any callable type; you should use that to hold callables which may be of different types.</p>\n", "OwnerDisplayName": "user1554710", "LastActivityDate": "2012-07-26T12:46:24.393", "Score": "3", "CreationDate": "2012-07-26T12:46:24.393", "ParentId": "11669292", "CommentCount": "1"}});