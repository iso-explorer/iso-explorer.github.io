post_cb({"bq_ids": {"n4140": {"so_36587204_36607411_0": {"length": 41, "quality": 0.9761904761904762, "section_id": 5862}}, "n3337": {"so_36587204_36607411_0": {"length": 37, "quality": 0.8809523809523809, "section_id": 5632}}, "n4659": {"so_36587204_36607411_0": {"length": 32, "quality": 0.7619047619047619, "section_id": 7345}}}, "36607411": {"Id": "36607411", "PostTypeId": "2", "Body": "<p>The problem is that in certain places of code your classes are really incomplete.</p>\n<p>According to [class.mem]/1:</p>\n<blockquote>\n<p id=\"so_36587204_36607411_0\">A class is considered a completely-defined object type (3.9) (or complete type) at the closing <code>}</code> of the <em>class-specifier</em>.\n  Within the class <em>member-specification</em>, the class is regarded as complete within function bodies,\n  default arguments, <em>using-declarations</em> introducing inheriting constructors (12.9), <em>exception-specifications</em>, and\n  <em>brace-or-equal-initializers</em> for non-static data members (including such things in nested classes). Otherwise\n  it is regarded as incomplete within its own class <em>member-specification</em>.</p>\n</blockquote>\n<p>When applied to your code, this means in particular that the class is incomplete within function parameter lists. Now let's look at the definition of <code>DDirectory::foo()</code>:</p>\n<pre><code>template&lt;class arg,class conv&gt;\nstruct DDirectory : public virtual Directory&lt;arg,conv&gt;, public virtual DFile&lt;arg,conv&gt;{\n    void foo(typename conv::Directory::UnionType&amp; d){\n    }\n};\n</code></pre>\n<p>In the instantiation <code>DDirectory&lt;int,thing&gt;</code> <code>conv</code> is <code>FSU&lt;int,DFS,DFS&gt;</code>, so instantiation of it involves instantiation of <code>UnionBase</code>s inside, and eventially to this:</p>\n<pre><code>static_assert(AllInheritFrom&lt;Base,Rest...&gt;::value, \"All of the elements of UnionBase must have Base as a public base\");\n</code></pre>\n<p>where one of classes is <code>DDirectory&lt;int,thing&gt;</code>. Remember, all this happens in the deducing the type of the parameter of <code>foo()</code>, so <code>DDirectory&lt;int,thing&gt;</code> is incomplete, and that's what the compiler is saying.</p>\n<p>You could try to move that <code>static_assert</code> for example to the constructor of <code>UnionBase</code>, but it doesn't solve other error which I think is impossible to fix, and the reason is the same:</p>\n<pre><code>error: invalid application of 'sizeof' to an incomplete type 'DDirectory&lt;int, FSU&lt;int, DFS, DFS&gt; &gt;'\nstatic const bool FirstBigger = sizeof(First) &gt; sizeof(Best);\n                                ^~~~~~~~~~~~~\n</code></pre>\n<p>Here is a minimized example reproducing the problem:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;typename T1, typename T2&gt;\nstruct BiggerType {\n    using type = typename std::conditional&lt;(sizeof(T1) &gt; sizeof(T2)), T1, T2&gt;::type;\n};\n\ntemplate&lt;typename T&gt;\nstruct S {\n    using B = BiggerType&lt;S, int&gt;;\n\n    // This causes the instantiation of BiggerType,\n    // leading to calculation of sizeof(S) which is incomplete\n    void foo(const typename B::type&amp; bt) {\n    }\n};\n\nint main() {\n    S&lt;int&gt; s;\n}\n</code></pre>\n<p>Or in very compressed form,</p>\n<pre><code>template&lt;typename T&gt;\nstruct S {\n    // Same problem here\n    void foo(typename std::conditional&lt;(sizeof(S) &gt; sizeof(int)), S, int&gt;::type&amp;) {\n    }\n};\n</code></pre>\n", "LastEditorUserId": "3959454", "LastActivityDate": "2016-04-13T19:11:49.820", "Score": "1", "CreationDate": "2016-04-13T19:06:48.433", "ParentId": "36587204", "CommentCount": "1", "LastEditDate": "2016-04-13T19:11:49.820", "OwnerUserId": "3959454"}, "36587204": {"ViewCount": "247", "Body": "<p>I am trying to create a filesystem interface so that my micro controller can interface with an SD card (and I decided to implement all of the File System stuff from the ground up).  The problem is I don't know what file system will be on the card....It could be FAT16, FAT32, NFTS, ext3, ect.</p>\n<p>So I created a the following abstract classes: <code>FileSystem</code> <code>File</code> and <code>Directory</code>.  Now that is all fine and dandy but I am on a micro controller so I want to avoid using the <code>new</code> operator.</p>\n<p>This leads to my creation of the <code>UnionBase</code> class (not a very helpful name).  Basically this class holds a union of all of the different derived classes and allows you to convert between them:</p>\n<pre><code>struct BaseFile_t{\n};\nstruct DerivedA : BaseFile_t{\n};\nstruct DerivedB : BaseFile_t{\n};\n\nUnionBase&lt;BaseFile_t,DerivedA,DerivedB&gt; var;   //Can now pass references \n//of this into File system function \n//so that they can modify the right\n//Derived type (which can then be\n//used as if it is the base type)\n</code></pre>\n<p>Now in order to pass this in I have a struct called <code>FileSystemUnion</code> or <code>FSU</code> for short.  This basically just defines all of the necessary BaseUnion types.</p>\n<p>The real problem is that it seems that it might end up being a type if recursive typedef (which I know is not allowed).  Here is a shortened version of my code:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;conio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;fstream&gt;\n#include \"prototypeInd/templates/UnionBase.h\"\nusing namespace prototypeInd::templates;\n\ntemplate&lt;class arg,class conv&gt;\nstruct File{\n};\ntemplate&lt;class arg,class conv&gt;\nstruct Directory : public File&lt;arg,conv&gt;{\n};\ntemplate&lt;class arg,class conv&gt;\nstruct FS{\n    typedef Directory&lt;arg,conv&gt; Directory;\n    typedef File&lt;arg,conv&gt; File;\n};\ntemplate&lt;class arg,class conv&gt;\nstruct DFile : public virtual File&lt;arg,conv&gt;{\n};\ntemplate&lt;class arg,class conv&gt;\nstruct DDirectory : public virtual Directory&lt;arg,conv&gt;, public virtual DFile&lt;arg,conv&gt;{\n    void foo(typename conv::Directory::UnionType&amp; d){\n    }\n};\ntemplate&lt;class arg,class conv&gt;\nstruct DFS : public virtual FS&lt;arg,conv&gt;{\n    typedef DFile&lt;arg,conv&gt; File;\n    typedef DDirectory&lt;arg,conv&gt; Directory;\n};\ntemplate&lt;class arg,template&lt;class,class&gt; class fsa,template&lt;class,class&gt; class fsb&gt;\nstruct FSU{\n    typedef UnionBase&lt;FS&lt;arg,FSU&gt;,fsa&lt;arg,FSU&gt;,fsb&lt;arg,FSU&gt; &gt; FS;\n    typedef UnionBase&lt;typename ::FS&lt;arg,FSU&gt;::Directory,typename fsa&lt;arg,FSU&gt;::Directory,typename fsb&lt;arg,FSU&gt;::Directory&gt; Directory;\n    typedef UnionBase&lt;typename ::FS&lt;arg,FSU&gt;::File,typename fsa&lt;arg,FSU&gt;::File,typename fsb&lt;arg,FSU&gt;::File&gt; File;\n};\n\ntypedef FSU&lt;int,DFS,DFS&gt; thing;\nDDirectory&lt;int,thing&gt; d;\n\n\n\nint main(int d,char** thing){\n\n}\n</code></pre>\n<p>The error I get is:\n<code>invalid use of incomplete type 'struct DDirectory&lt;int, FSU&lt;int, DFS, DFS&gt; &gt;'</code></p>\n<p>Here is UnionBase.h (its huge but don't worry all of this is working):</p>\n<pre><code>#ifndef prototypeInd_templates_UnionBase_h\n#define prototypeInd_templates_UnionBase_h\n#include &lt;type_traits&gt;\n\ntemplate&lt;class Type, uint64_t time,class First,class... Array&gt;\nclass IndexOf_{\n        static const bool isSame = std::is_same&lt;First,Type&gt;::value;\n    public:\n        static const uint64_t value = isSame ? time : IndexOf_&lt;Type,time+1,Array...&gt;::value;\n};\ntemplate&lt;class Type, uint64_t time, class First&gt;\nclass IndexOf_&lt;Type,time,First&gt;{\n    public:\n        //static_assert(std::is_same&lt;First,Type&gt;::value,\"Not contained in list\");\n        static const uint64_t value = time;\n};\ntemplate&lt;class Type,class... Array&gt;\nusing IndexOf = IndexOf_&lt;Type,0,Array...&gt;;\ntemplate&lt;class Target, class First, class... Rest&gt;\nclass ContainsType{\n    public:\n    static const bool value = std::is_same&lt;Target, First&gt;::value ? true : ContainsType&lt;Target,Rest...&gt;::value;\n};\ntemplate&lt;class Target, class First&gt;\nclass ContainsType&lt;Target,First&gt;{\n    public:\n    static const bool value = std::is_same&lt;Target, First&gt;::value;\n};\n//Best is the highes so far while rest is the rest of the list\ntemplate &lt;class Best,class First, class... Rest&gt;\nclass GetMaxSize{\n        //typedef typename GetFirstType&lt;Rest...&gt;::value First;\n        static const bool FirstBigger = sizeof(First) &gt; sizeof(Best);\n\n    public:\n        typedef typename std::conditional&lt;FirstBigger,typename GetMaxSize&lt;First,Rest...&gt;::value,typename GetMaxSize&lt;Best,Rest...&gt;::value &gt;::type value;\n};\ntemplate&lt;class Best, class First&gt;\nclass GetMaxSize&lt;Best,First&gt;{\n    static const bool FirstBigger = sizeof(First) &gt; sizeof(Best);\n    public:\n        typedef typename std::conditional&lt;FirstBigger,First,Best &gt;::type value;\n};\ntemplate&lt;class From,uint16_t index,class UT,class First,class... Array&gt; \nstruct cast{\n    static void apply(From** t,UT* f){\n        if (index == f-&gt;GetActive()){\n            *t = &amp;((First)(*f));\n        }\n        else{\n            cast&lt;From,index+1,UT,Array...&gt;::apply(t,f);\n        }\n    }\n};\ntemplate&lt;class From,uint16_t index,class UT,class First&gt;\nstruct cast&lt;From,index,UT,First&gt;{\n    static void apply(From** t,UT* f){\n        if (index == f-&gt;GetActive()){\n            *t = &amp;((First)(*f));\n        }\n    }\n};\n\n\ntemplate&lt;class... Values&gt;\nclass UnionType{\n    typedef typename GetMaxSize&lt;Values...&gt;::value internal_t;\n    internal_t data;\n    uint16_t active;\n    public:\n    template&lt;class CastFrom, class Dummy = typename std::enable_if&lt;ContainsType&lt;CastFrom,Values...&gt;::value, int&gt;::type &gt;\n    UnionType(CastFrom&amp;&amp; d) : data(reinterpret_cast&lt;internal_t&amp;&gt;(d)),active(IndexOf&lt;CastFrom,Values...&gt;::value){\n    }\n    template&lt;class CastTo, class Condition = typename std::enable_if&lt;ContainsType&lt;CastTo,Values...&gt;::value,int&gt;::type &gt;\n    operator CastTo const&amp;() const{\n        return reinterpret_cast&lt;const CastTo&amp;&gt;(data);\n    }\n    uint16_t GetActive() const{\n        return active;\n    }\n    //This one actually uses casting of the active data type\n    template&lt;class CastTo, class Condition = typename std::enable_if&lt;!ContainsType&lt;CastTo,Values...&gt;::value,int&gt;::type &gt;\n    explicit operator CastTo*() const{\n        CastTo temp;\n        CastTo* ret = &amp;temp;\n        cast&lt;CastTo,0,UnionType,Values...&gt;::apply(&amp;ret,this);\n        return ret;\n    }\n};\n\nnamespace prototypeInd{namespace templates{\ntemplate&lt;class Base, class Thing&gt;\nstruct IsPublicBase{\n    static const bool value = std::is_base_of&lt;Base,Thing&gt;::value &amp;&amp; std::is_convertible&lt;Thing*,Base*&gt;::value;\n};\ntemplate&lt;class Base, class First, class... Rest&gt;\nstruct AllInheritFrom{\n    static const bool value = IsPublicBase&lt;Base,First&gt;::value ? AllInheritFrom&lt;Base,Rest...&gt;::value : false;\n};\ntemplate&lt;class Base, class First&gt;\nstruct AllInheritFrom&lt;Base,First&gt;{\n    static const bool value = IsPublicBase&lt;Base,First&gt;::value;\n};\ntemplate&lt;template&lt;class&gt; class Function,class First,class... Args&gt;\nstruct AllFullfill{\n    static const bool value = Function&lt;First&gt;::value ? AllFullfill&lt;Function,Args...&gt;::value : false;\n};\ntemplate&lt;template&lt;class&gt; class Function,class First&gt;\nstruct AllFullfill&lt;Function,First&gt;{\n    static const bool value = Function&lt;First&gt;::value;\n};\ntemplate&lt;class Base, class... Rest&gt;\nclass UnionBase{\n    static_assert(AllInheritFrom&lt;Base,Rest...&gt;::value, \"All of the elements of UnionBase must have Base as a public base\");\n    public:\n        typedef UnionType&lt;Rest...&gt; UnionType;\n    private:\n        UnionType internal;\n    public:\n        UnionBase() : internal(typename GetFirstType&lt;Rest...&gt;::value()){};\n\n        UnionBase(Base&amp;&amp; value) : internal(value){\n        }\n        operator UnionType&amp;(){\n            return internal;\n        }\n        Base* operator -&gt;() const{\n            //return 0;\n            return &amp;((Base&amp;)internal);\n        }\n};\n//template&lt;class Base, class... Rest&gt;\n//using UnionBase = UnionBase_&lt;Base,Rest...&gt;*;\n}}\n#endif\n</code></pre>\n<p>So the real question is: what should I do to make this work?  I am open to restructuring a little bit, but after hours of trying everything I can think of I am almost ready to scrap the whole thing and start again.</p>\n", "AcceptedAnswerId": "36607411", "Title": "Invalid use of incomplete type (chained templated classes)", "CreationDate": "2016-04-13T01:59:49.967", "Id": "36587204", "CommentCount": "2", "LastEditDate": "2016-04-13T02:12:32.377", "PostTypeId": "1", "LastEditorUserId": "6149078", "LastActivityDate": "2016-04-13T19:11:49.820", "Score": "0", "OwnerUserId": "6149078", "Tags": "<c++><templates><typedef>", "AnswerCount": "1"}});