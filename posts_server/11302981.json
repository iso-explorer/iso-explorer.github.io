post_cb({"bq_ids": {"n4140": {"so_11302981_11303175_0": {"length": 18, "quality": 0.6206896551724138, "section_id": 5449}}, "n3337": {"so_11302981_11303175_0": {"length": 19, "quality": 0.6551724137931034, "section_id": 5243}}}, "11302981": {"ViewCount": "9847", "Body": "<p>Does C++11 allow declaring non-static data members as 'auto' if they are initialized in the declaration? For example:</p>\n<pre><code>struct S\n{\n    auto x = 5;  // in place of 'int x = 5;', which is definitely allowed\n};\n</code></pre>\n<p>GCC 4.7 rejects the above code, while it accepts <code>int x = 5;</code>.</p>\n<p>Assuming this is not a compiler bug but rather the standard really doesn't allow it, why not? It would be just as useful as declaring local variables <code>auto</code>.</p>\n", "AcceptedAnswerId": "11303175", "Title": "C++11 - declaring non-static data members as 'auto'", "CreationDate": "2012-07-03T00:28:39.610", "Id": "11302981", "CommentCount": "8", "FavoriteCount": "7", "PostTypeId": "1", "LastActivityDate": "2012-07-03T01:04:19.810", "Score": "33", "OwnerUserId": "141719", "Tags": "<c++><c++11><auto><variable-declaration>", "AnswerCount": "1"}, "11303175": {"Id": "11303175", "PostTypeId": "2", "Body": "<p>The rule for prohibiting non-static members is in 7.1.6.4 clause 4:</p>\n<blockquote>\n<p id=\"so_11302981_11303175_0\">The auto type-specifier can also be used in declaring a variable in\n  the condition of a selection statement (6.4) or an iteration statement\n  (6.5), in the type-specifier-seq in the new-type-id or type-id of a\n  new-expression (5.3.4), in a for-range-declaration, and in declaring a\n  <strong>static data member</strong> with a brace-or-equal-initializer that appears within the member-specification of a class definition (9.4.2).</p>\n</blockquote>\n<p>I found the rationale for it being static <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2713\">here</a> which reflects how James McNellis explains it in the comment.</p>\n<blockquote>\n<p id=\"so_11302981_11303175_1\">One national body dislikes allowing the auto type-specifier for\n  non-statics. From an e-mail to the authors:</p>\n<pre><code>    template&lt; class T &gt;\n    struct MyType : T {\n      auto data = func();\n      static const size_t erm = sizeof(data);\n    };\n</code></pre>\n<p id=\"so_11302981_11303175_2\">In order to determine the layout of X, we now have 2-phase name lookup and ADL. Note that func could be either a type or a function;\n  it may be found in T, the namespace of MyType, the associated\n  namespace(s) of T when instantiated, the global namespace, an\n  anonymous namespace, or any namespaces subject to a using directive.\n  With care we could probably throw some concept_map lookup in for luck.\n  Depending on the order of header inclusion I might even get different results for ADL, and break the One Definition Rule - which\n  is not required to be diagnosed. </p>\n<p id=\"so_11302981_11303175_3\">Because of this controversy, the authors no longer propose that auto\n  be allowed for non-static data members.</p>\n</blockquote>\n<p>So, basically depending on the order of header inclusion, the type of <code>data</code> could be very different. Of course, <code>auto x = 5;</code> would not need to depend on 2-phase name lookup or ADL, however, I'm a assuming that they made it a \"blanket\" rule because otherwise, they would have to make individual rules for every use case which would make things very complicated.</p>\n<p>In the same paper, the author proposes eliminating this restriction, however, it seems this proposal has been rejected probably due to the above rationale and also so that expected behavior can be the same no matter what the initializer is.</p>\n", "LastEditorUserId": "906773", "LastActivityDate": "2012-07-03T01:04:19.810", "CommentCount": "4", "CreationDate": "2012-07-03T00:58:00.343", "ParentId": "11302981", "Score": "50", "OwnerUserId": "906773", "LastEditDate": "2012-07-03T01:04:19.810"}});