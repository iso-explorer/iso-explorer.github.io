post_cb({"47090896": {"CommentCount": "1", "Body": "<p>According to the standard (e.g. <a href=\"https://timsong-cpp.github.io/cppwp/n3337/basic.stc.dynamic.deallocation#3\" rel=\"nofollow noreferrer\">this</a> online draft version), the behaviour of <code>delete</code>-ing a pointer, which has not been obtained previously by <code>new</code>, is undefined:</p>\n<blockquote>\n<p id=\"so_47090640_47090896_0\"><strong>3.7.4.2 Deallocation functions</strong></p>\n<p id=\"so_47090640_47090896_1\">(3) If a deallocation function terminates by throwing an exception, the\n  behavior is undefined. The value of the first argument supplied to a\n  deallocation function may be a null pointer value; if so, and if the\n  deallocation function is one supplied in the standard library, the\n  call has no effect. <strong>Otherwise, the behavior is undefined if the value\n  supplied to operator delete(void*) in the standard library is not one\n  of the values returned by a previous invocation of either operator\n  new(std::size_t) or operator new(std::size_t, const std::nothrow_t&amp;)\n  in the standard library, and the behavior is undefined if the value\n  supplied to operator delete in the standard library is not\n  one of the values returned by a previous invocation of either operator\n  new or operator new[](std::size_t, const\n  std::nothrow_t&amp;) in the standard library.</strong></p>\n</blockquote>\n<p>The value of <code>ptr+1</code> is not the one returned by <code>new[]</code>, and hence the call to <code>delete[] (ptr+1)</code> is UB. Anything can happen, including that it seems to work correctly; But it is for sure <em>not guaranteed to work correctly</em>.</p>\n", "CreationDate": "2017-11-03T07:53:26.877", "ParentId": "47090640", "Id": "47090896", "LastActivityDate": "2017-11-03T07:53:26.877", "PostTypeId": "2", "Score": "2", "OwnerUserId": "2630032"}, "47090640": {"CreationDate": "2017-11-03T07:35:32.220", "ViewCount": "54", "Id": "47090640", "AcceptedAnswerId": "47090896", "Score": "1", "Title": "Memory leaks when using pointer arithmetic", "LastEditorUserId": "4284627", "CommentCount": "1", "Body": "<p>Will such code cause a memory leak?</p>\n<pre><code>unsigned char *ptr = new unsigned char[2];\nptr++; //pointer now points to the second member of array\ndelete [] ptr;\n</code></pre>\n", "Tags": "<c++><memory-leaks>", "LastEditDate": "2017-11-27T22:23:43.960", "LastActivityDate": "2017-11-27T22:23:43.960", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "7257279"}, "47090775": {"CommentCount": "0", "Body": "<p>It is undefined behavior as mentioned <a href=\"http://en.cppreference.com/w/cpp/language/delete\" rel=\"nofollow noreferrer\">here</a></p>\n<blockquote>\n<p id=\"so_47090640_47090775_0\">delete [] expression </p>\n<p id=\"so_47090640_47090775_1\">expression must be a null pointer value or a pointer value previously\n  obtained by an array form of new-expression. If expression is anything\n  else, including if it's a pointer obtained by the non-array form of\n  new-expression, the behavior is undefined.</p>\n</blockquote>\n<p>This makes sense as <code>delete[]</code> would expect to get some information about number of elements to be deleted from the pointer supplied, which it would not found if a different pointer is passed.</p>\n", "CreationDate": "2017-11-03T07:44:52.393", "ParentId": "47090640", "Id": "47090775", "LastActivityDate": "2017-11-03T07:44:52.393", "PostTypeId": "2", "Score": "1", "OwnerUserId": "3475381"}, "bq_ids": {"n4140": {"so_47090640_47090896_1": {"length": 63, "quality": 0.9545454545454546, "section_id": 7182}}, "n3337": {"so_47090640_47090896_1": {"length": 63, "quality": 0.9545454545454546, "section_id": 6926}}}});