post_cb({"44870557": {"CommentCount": "8", "ViewCount": "472", "PostTypeId": "1", "LastEditorUserId": "3980929", "CreationDate": "2017-07-02T11:57:20.123", "LastActivityDate": "2017-07-03T08:18:05.677", "Title": "Why don't compilers optimize this out?", "FavoriteCount": "3", "LastEditDate": "2017-07-03T05:50:28.137", "Id": "44870557", "Score": "12", "Body": "<p>Look at this code:</p>\n<pre><code>struct Data {\n};\n\nstruct Init {\n    Data *m_data;\n\n    Init() : m_data(new Data) { }\n    ~Init() {\n        delete m_data;\n    }\n};\n\nclass Object {\n    private:\n        const int m_initType;\n        Data *m_data;\n    public:\n        Object(const Init &amp;init) : m_initType(0), m_data(init.m_data) { }\n        Object(Init &amp;&amp;init) : m_initType(1), m_data(init.m_data) { init.m_data = nullptr; }\n        ~Object() {\n            if (m_initType==1) {\n                delete m_data;\n            }\n        }\n};\n\nvoid somefunction(const Object &amp;object); // it is intentionally not defined\n\nvoid callInitA() {\n        Init x;\n        somefunction(x);\n}\n\nvoid callInitB() {\n        somefunction(Init());\n}\n</code></pre>\n<p>As <code>Object::m_initType</code> is const, it doesn't change after constructor. So, in theory, in <code>callInitA</code>, and in <code>callInitB</code>, the compiler knows of the value of <code>m_initType</code> when it inlines <code>~Object()</code>. However, both gcc and clang <a href=\"https://godbolt.org/g/mWm3aC\" rel=\"nofollow noreferrer\">fails to apply</a> this optimization, and both checks the value of <code>m_initType</code>.</p>\n<p>Why is that? Is there some language rule against this optimization, or compilers just don't do this kind of optimization?</p>\n<p>(This question is closely related to <a href=\"https://stackoverflow.com/questions/44597835/c-optimizing-out-destructor-call\">this</a>, but it is a more specific question, I hope I can get an answer for this)</p>\n", "Tags": "<c++><gcc><clang>", "OwnerUserId": "8157187", "AnswerCount": "2"}, "44871311": {"ParentId": "44870557", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2017-07-02T13:26:49.213", "Score": "3", "LastEditorUserId": "4832499", "LastEditDate": "2017-07-02T13:41:33.433", "Id": "44871311", "OwnerUserId": "4832499", "Body": "<p>To answer whether there is any rules in the language that forbids this kind of optimization, here's my take</p>\n<p>From <a href=\"http://eel.is/c++draft/dcl.type.cv#4\" rel=\"nofollow noreferrer\">[dcl.type.cv]</a></p>\n<blockquote>\n<p id=\"so_44870557_44871311_0\">Except that any class member declared mutable can be modified, any attempt to modify a const object during its lifetime results in undefined behavior.</p>\n</blockquote>\n<p>And so in theory, the optimizer may safely assume <code>m_initType</code> will never change after initialization. This can of course be used to deduce whether the branch in <code>~Object</code> will be taken at compile time.</p>\n<p>That said, optimizers are free to do anything as long as the observed behaviour stay the same, so too are they free to ignore <code>const</code>. To make matters more complicated for the optimizer, there is an forward declared but not defined function in the mix, the optimizer probably just gave up after that to do anything useful with the information.</p>\n<p><a href=\"https://godbolt.org/g/H14hPa\" rel=\"nofollow noreferrer\">Comparison of defined vs undefined function</a></p>\n<p>If the function is defined later on, gcc and clang both optimizes everything away. Note however, in this particular case, they will <a href=\"https://godbolt.org/g/7eyvwe\" rel=\"nofollow noreferrer\">still do this</a> even without any <code>const</code>.</p>\n<p><a href=\"https://stackoverflow.com/questions/212237/constants-and-compiler-optimization-in-c\">This post</a> might be of interest</p>\n", "LastActivityDate": "2017-07-02T13:41:33.433"}, "44871230": {"ParentId": "44870557", "CommentCount": "6", "CreationDate": "2017-07-02T13:17:24.830", "OwnerUserId": "5089311", "PostTypeId": "2", "Id": "44871230", "Score": "0", "Body": "<p>Object destructor is not inlined in your example and you have 2 invocations, where in one m_initType is 1 and in another is 0. So compiler have to support both versions.\nAlso, I suppose that your actual code is somewhat more complex that your example, so compiler might decide that inline whole destructor code is more expensive than keeping generic version with single 'if' inside.</p>\n", "LastActivityDate": "2017-07-02T13:17:24.830"}, "bq_ids": {"n4140": {"so_44870557_44871311_0": {"section_id": 5433, "quality": 1.0, "length": 17}}, "n3337": {"so_44870557_44871311_0": {"section_id": 5228, "quality": 1.0, "length": 17}}, "n4659": {"so_44870557_44871311_0": {"section_id": 6861, "quality": 1.0, "length": 17}}}});