post_cb({"14261176": {"ParentId": "2677221", "CommentCount": "1", "Body": "<p>The latest declaration takes precedence:</p>\n<blockquote>\n<p id=\"so_2677221_14261176_0\"><code>[C++03: 9.1/2]:</code> A class definition introduces the class name into the scope where it is defined and hides any class, object, function, or other declaration of that name in an enclosing scope (3.3). <strong>If a class name is declared in a scope where an object, function, or enumerator of the same name is also declared, then when both declarations are in scope, the class can be referred to only using an <em>elaborated-type-specifier</em></strong> (3.4.4).</p>\n</blockquote>\n<p>An <em>elaborated-type-specifier</em> is when you stick <code>struct</code> or <code>class</code> at the front of the type; this effectively disambiguates it, though, strictly speaking, and due to the above cited rule, the lookup was never really ambiguous in the first place.</p>\n<p>So:</p>\n<pre><code>void foo()\n{\n   struct bar {};\n   bar bar[5];\n\n   memset(bar, 0, sizeof(bar));\n   //             ^^^^^^^^^^^\n   //                  5\n\n   memset(bar, 0, sizeof(struct bar));\n   //             ^^^^^^^^^^^^^^^^^^\n   //                  1\n}\n\n// (NB. Exact sizes may differ; 1 and 5 given as relative examples only)\n</code></pre>\n<p>The fact that this is all well-defined is one reason that you didn't get a warning. Still, I'd <em>hope</em> that an intelligent compiler would spot your code as a possible programmer mistake \u2014 rationalising about why some given implementation does or does not emit some given warning in some non-mandated case, though, is largely folly.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "14261176", "Score": "2", "CreationDate": "2013-01-10T15:19:15.293", "LastActivityDate": "2013-01-10T15:19:15.293"}, "2677245": {"ParentId": "2677221", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Number one would be, don't do this as it's confusing - but you've already discovered this.</p>\n<p>The variable hides the name of the struct, but you can still use <code>struct fred</code> to refer to the type.</p>\n<p>e.g.</p>\n<pre><code>fred     fred[MAX_SIZE+1];\n\nmemset( fred, 0, sizeof(struct fred) * (MAX_SIZE+1) );\n</code></pre>\n<p>Alternatively, why not just use the size of the complete object. That way your <code>memset</code> call is robust in the face of changes to either the array size or type. You can do:</p>\n<pre><code>memset( fred, 0, sizeof fred );\n</code></pre>\n<p>You <em>must</em> have the parentheses when using a type id with <code>sizeof</code> but it's not needed when you use an object.</p>\n", "OwnerUserId": "19563", "LastEditorUserId": "19563", "LastEditDate": "2010-04-20T18:21:54.490", "Id": "2677245", "Score": "14", "CreationDate": "2010-04-20T17:27:22.140", "LastActivityDate": "2010-04-20T18:21:54.490"}, "2677316": {"ParentId": "2677221", "CommentCount": "0", "Body": "<p>With the exception of run-time sized cases, the typical idiomatic way to use <code>memset</code> (as well as <code>memcpy</code>, <code>malloc</code>, etc.) is to do</p>\n<pre><code>memset(dst_ptr, 0, sizeof *dst_ptr);\n</code></pre>\n<p>or, equivalently,</p>\n<pre><code>memset(&amp;dst_object, 0, sizeof dst_object);\n</code></pre>\n<p>Which is how it should have been used in this case as well </p>\n<pre><code>memset(&amp;fred, 0, sizeof fred);\n</code></pre>\n<p>and the problem with the name conflict would not arise. The <code>memset(fred, 0, sizeof fred)</code> variant will work as well.</p>\n", "OwnerUserId": "187690", "PostTypeId": "2", "Id": "2677316", "Score": "0", "CreationDate": "2010-04-20T17:37:37.653", "LastActivityDate": "2010-04-20T17:37:37.653"}, "2677221": {"CommentCount": "4", "AcceptedAnswerId": "2677245", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2010-04-20T17:22:55.083", "LastActivityDate": "2013-01-10T15:19:15.293", "LastEditDate": "2013-01-10T15:10:45.357", "ViewCount": "1407", "FavoriteCount": "1", "Title": "Someone is using the struct name as a variable name too. What does the code really say?", "Id": "2677221", "Score": "11", "Body": "<p>This morning we found an old chunk of code that was causing a library call to crash.</p>\n<pre><code>struct   fred\n{\n    int     a;\n    int     b;\n    int     c;\n};\n\nfred     fred[MAX_SIZE+1];\n\nmemset( fred, 0, sizeof(fred) * MAX_SIZE+1 );\n</code></pre>\n<p>It appears that the sizeof(fred) may have been the full array size, rather than the structure size, as it was overwriting a <em>great deal</em> of memory.</p>\n<p>The fact that it compiled without warning on several different systems seemed odd.</p>\n<p><strong>Is there a correct semantic for this case where the type and variable name are colliding?\nor is this some sort of undefined behavior? or just a defect?</strong></p>\n", "Tags": "<c++><naming-conventions>", "OwnerUserId": "7734", "AnswerCount": "5"}, "2677266": {"ParentId": "2677221", "CommentCount": "0", "Body": "<p>When you define the variable, it hides the name of the type, so yes, when you do <code>sizeof(fred)</code>, you're getting the size of the array, not the size of the struct. it's pretty easy to verify this by simply printing out <code>sizeof(fred)</code>.</p>\n<p>The short answer, however, is just: \"don't do that.\"</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "2677266", "Score": "1", "CreationDate": "2010-04-20T17:30:03.693", "LastActivityDate": "2010-04-20T17:30:03.693"}, "2677241": {"ParentId": "2677221", "CommentCount": "1", "Body": "<p>Shouldn't this be sizeof(fred)*(MAX_SIZE+1) since your array is MAX_SIZE+1 long?</p>\n", "OwnerUserId": "36973", "PostTypeId": "2", "Id": "2677241", "Score": "2", "CreationDate": "2010-04-20T17:26:50.130", "LastActivityDate": "2010-04-20T17:26:50.130"}, "bq_ids": {"n4140": {"so_2677221_14261176_0": {"section_id": 5857, "quality": 0.8372093023255814, "length": 36}}, "n3337": {"so_2677221_14261176_0": {"section_id": 5627, "quality": 0.8372093023255814, "length": 36}}, "n4659": {"so_2677221_14261176_0": {"section_id": 7336, "quality": 0.8372093023255814, "length": 36}}}});