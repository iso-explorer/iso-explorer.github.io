post_cb({"48242502": {"Id": "48242502", "PostTypeId": "2", "Body": "<p>I am pretty sure your vendors implementation is broken.  Your program looks almost OK from the perspective of obeying the contract with the cv/mutex classes.   I couldn\u2019t 100% verify, I am behind one version.</p>\n<p>The notion of \u201cblocking\u201d is confusing in the condition_variable (CV) class because there are multiple things to be blocking on.   The contract requires the implementation to be more complex than a veneer on pthread_cond* (for example).  My reading of it indicates that a single CV would require at least 2 pthread_cond_t\u2019s to implement.</p>\n<p>The crux is the destructor having a definition while threads are waiting upon a CV; and its ruin is in a race between CV.wait and ~CV.  The naive implementation simply has ~CV broadcast the condvar then eliminate it, and has CV.wait remember the lock in a local variable, so that when it awakens from the runtime notion of blocking it no longer has to reference the object.   In that implementation, ~CV becomes a \u201cfire and forget\u201d mechanism.</p>\n<p>Sadly, a racing CV.wait could meet the preconditions, yet not be finished interacting with the object yet, when ~CV sneaks in and destroys it.   To resolve the race CV.wait and ~CV need to exclude each other, thus the CV requires at least a private mutex to resolve races.</p>\n<p>We aren\u2019t finished yet.  There usually isn\u2019t an underlying support [ eg. kernel ] for an operation like \u201cwait on cv controlled by lock and release this other lock once I am blocked\u201d.  I think that even the posix folks found that too funny to require.  Thus, burying a mutex in my CV isn\u2019t enough, I actually require a mechanism that permits me to process events within it; thus a private condvar is required inside the implementation of CV.   <a href=\"https://www.johndcook.com/blog/2009/07/22/bad-programmers-create-jobs/\" rel=\"nofollow noreferrer\">Obligatory David Parnas meme</a>.</p>\n<p>Almost OK, because as Marek R points out, you are relying on referencing a class after its destruction has begun; not the cv/mutex class, your notify_on_delete class.  The conflict is a bit academic. I doubt clang would depend upon nod remaining valid after control had transferred to nod-&gt;cv.wait(); but the real customer of most compiler vendors are benchmarks, not programmers.</p>\n<p>As as general note, multi-threaded programming is difficult, and having now peaked at the c++ threading model, it might be best to give it a decade or two to settle down.   It\u2019s contracts are astonishing. When I first looked at your program, I thought \u2018duh, there is no way you can destroy a cv that can be accessed because RAII\u2019.  Silly me.</p>\n<p>Pthreads is another awful API for threading.  At least it doesn\u2019t attempt over-reach, and is mature enough that robust test suites keep vendors in line.</p>\n", "LastEditorUserId": "4664415", "LastActivityDate": "2018-01-14T23:16:07.350", "Score": "3", "CreationDate": "2018-01-13T17:39:47.523", "ParentId": "48093715", "CommentCount": "13", "OwnerUserId": "4664415", "LastEditDate": "2018-01-14T23:16:07.350"}, "bq_ids": {"n4140": {"so_48093715_48093715_0": {"length": 58, "quality": 0.8529411764705882, "section_id": 2991}}, "n3337": {"so_48093715_48093715_0": {"length": 58, "quality": 0.8529411764705882, "section_id": 2861}}, "n4659": {"so_48093715_48093715_0": {"length": 58, "quality": 0.8529411764705882, "section_id": 3750}}}, "48094109": {"Id": "48094109", "PostTypeId": "2", "Body": "<p>When NOTIFY_IN_DESTRUCTOR is defined: <br>\nCalling <code>notify_one()/notify_all()</code> doesn't mean that the waiting thread is immediately woken up and the current thread will wait for the other thread. It just means that if the waiting thread wakes up at some point after the current thread has called notify, it should proceed. So in essence, you might be deleting the condition variable before the waiting thread wakes up (depending on how the threads are scheduled). <br/></br></p>\n<p>The explanation for why it hangs, even if the condition variable is deleted while the other thread is waiting on it lies on the fact the wait/notify operations are implemented using queues associated with the condition variables. These queues hold the threads waiting on the condition variables. Freeing the condition variable would mean getting rid of these thread queues. </p>\n", "LastEditorUserId": "3286661", "LastActivityDate": "2018-01-04T11:28:18.440", "Score": "7", "CreationDate": "2018-01-04T11:18:19.890", "ParentId": "48093715", "CommentCount": "12", "OwnerUserId": "3286661", "LastEditDate": "2018-01-04T11:28:18.440"}, "48093715": {"ViewCount": "367", "Body": "<p>Given a condition_variable as a member of a class, my understanding is that:</p>\n<ol>\n<li><a href=\"https://stackoverflow.com/questions/28356069/what-order-are-destructors-called-and-member-variables-destroyed-in-c-using-in\">The condition variable is destroyed after the class destructor completes.</a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/thread/condition_variable/%7Econdition_variable\" rel=\"noreferrer\">Destruction of a condition variable does not need to wait for notifications to have been received.</a></li>\n</ol>\n<p>In light of these expectations, my question is: why does the example code below <em>randomly</em> fail to notify a waiting thread?</p>\n<pre><code>#include &lt;mutex&gt;\n#include &lt;condition_variable&gt;\n#define NOTIFY_IN_DESTRUCTOR \n\nstruct notify_on_delete {\n    std::condition_variable cv;\n\n    ~notify_on_delete() {\n#ifdef NOTIFY_IN_DESTRUCTOR\n        cv.notify_all();\n#endif\n    }\n};\n\nint main () {\n    for (int trial = 0; trial &lt; 10000; ++trial) {\n        notify_on_delete* nod = new notify_on_delete();\n        std::mutex flag;\n        bool kill = false;\n\n        std::thread run([nod, &amp;flag, &amp;kill] () {\n            std::unique_lock&lt;std::mutex&gt; lock(flag);\n            kill = true;\n            nod-&gt;cv.wait(lock);\n        });\n\n        while(true) {\n            std::unique_lock&lt;std::mutex&gt; lock(flag);\n            if (!kill) continue;\n#ifdef NOTIFY_IN_DESTRUCTOR\n            delete nod;\n#else\n            nod-&gt;cv.notify_all();\n#endif\n            break;\n        }\n        run.join();\n#ifndef NOTIFY_IN_DESTRUCTOR\n        delete nod;\n#endif\n    }\n    return 0;\n}\n</code></pre>\n<p>In the code above, if NOTIFY_IN_DESTRUCTOR is not defined then the test will run to completion reliably. However, when NOTIFY_IN_DESTRUCTOR is defined the test will <em>randomly</em> hang (usually after a few thousand trials).</p>\n<p>I am compiling using Apple Clang:\nApple LLVM version 9.0.0 (clang-900.0.39.2)\nTarget: x86_64-apple-darwin17.3.0\nThread model: posix\nC++14 specified, compiled with DEBUG flags set.</p>\n<p><strong>EDIT:</strong></p>\n<p>To clarify: this question is about the semantics of the specified behavior of instances of condition_variable. The second point above appears to be reenforced in the following <a href=\"https://timsong-cpp.github.io/cppwp/thread.condition.condvar#5\" rel=\"noreferrer\">quote</a>:</p>\n<blockquote>\n<p id=\"so_48093715_48093715_0\">Blockquote\n  Requires: There shall be no thread blocked on *this. [\u2009Note: That is, all threads shall have been notified; they may subsequently block on the lock specified in the wait. This relaxes the usual rules, which would have required all wait calls to happen before destruction. Only the notification to unblock the wait needs to happen before destruction. The user should take care to ensure that no threads wait on *this once the destructor has been started, especially when the waiting threads are calling the wait functions in a loop or using the overloads of wait, wait_\u00adfor, or wait_\u00aduntil that take a predicate. \u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>The core semantic question seems to be what \"blocked on\" means. My present interpretation of the quote above would be that after the line</p>\n<pre><code>cv.notify_all(); // defined NOTIFY_IN_DESTRUCTOR\n</code></pre>\n<p>in ~notify_on_delete() the thread test is <em>not</em> \"blocked on\" nod - which is to say that I presently understand that after this call \"the notification to unblock the wait\" <em>has</em> occurred, so according to the quote the requirement has been met to proceed with the destruction of the condition_variable instance.</p>\n<p>Can someone provide a clarification of \"blocked on\" or \"notification to unblock\" to the effect that in the code above, the call to notify_all() does not satisfy the requirements of ~condition_variable()?</p>\n", "AcceptedAnswerId": "48242502", "Title": "Destruction of condition variable randomly loses notification", "CreationDate": "2018-01-04T10:55:00.983", "LastActivityDate": "2018-01-14T23:16:07.350", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-01-07T07:02:28.407", "LastEditorUserId": "5917300", "Id": "48093715", "Score": "14", "OwnerUserId": "5917300", "Tags": "<c++><multithreading><c++11>", "AnswerCount": "2"}});