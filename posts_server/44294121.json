post_cb({"bq_ids": {"n4140": {"so_44294121_44295205_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 7049}, "so_44294121_44295205_0": {"length": 13, "quality": 0.8125, "section_id": 7049}}, "n3337": {"so_44294121_44295205_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 6794}, "so_44294121_44295205_0": {"length": 13, "quality": 0.8125, "section_id": 6794}}, "n4659": {"so_44294121_44295205_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 8546}, "so_44294121_44295205_0": {"length": 13, "quality": 0.8125, "section_id": 8546}}}, "44295732": {"Id": "44295732", "PostTypeId": "2", "Body": "<p>This is a side effect of the rule that a name is in scope immediately after it is declared. There's no need to complicate this simple rule just to prevent writing code that's obvious nonsense.</p>\n", "LastActivityDate": "2017-05-31T22:36:37.277", "Score": "0", "CreationDate": "2017-05-31T22:36:37.277", "ParentId": "44294121", "CommentCount": "0", "OwnerUserId": "1593860"}, "44295205": {"Id": "44295205", "PostTypeId": "2", "Body": "<p>I guess the gist of your question is about why the second identifier is recognized as identifying the same object as the first, in <code>int i = i;</code> or <code>int &amp;p = p;</code></p>\n<p>This is defined in [basic.scope.pdecl]/1 of the C++14 standard:</p>\n<blockquote>\n<p id=\"so_44294121_44295205_0\">The point of declaration for a name is immediately after its complete declarator and before its initializer (if any), except as noted below. [Example:</p>\n<pre><code>unsigned char x = 12;\n{ unsigned char x = x; }\n</code></pre>\n<p id=\"so_44294121_44295205_1\">Here the second <code>x</code> is initialized with its own (indeterminate) value. \u2014end example ]</p>\n</blockquote>\n<p>The semantics of these statements are covered by other threads:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/q/14935722/1708801\">Is <code>int x = x;</code> UB?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/40692129/why-can-a-const-class-be-initialized-to-itself/40692203#40692203\">Why can a Class&amp; be initialized to itself?</a></li>\n</ul>\n<p>Note - the quoted example differs in semantics from <code>int i = i;</code> because it is not UB to evaluate an uninitialized <code>unsigned char</code>, but is UB to evaluate an uninitialized <code>int</code>.</p>\n<p>As noted on the linked thread, g++ and clang can give warnings when they detect this.</p>\n<hr>\n<p>Regarding rationale for the scope rule: I don't know for sure, but the scope rule existed in C so perhaps it just made its way into C++ and now it would be confusing to change it.</p>\n<p>If we did say that the declared variable is not in scope for its initializer, then <code>int i = i;</code> might make the second <code>i</code> find an <code>i</code> from an outer scope, which would also be confusing.</p>\n</hr>", "LastEditorUserId": "1505939", "LastActivityDate": "2017-05-31T21:54:57.553", "Score": "0", "CreationDate": "2017-05-31T21:48:47.070", "ParentId": "44294121", "CommentCount": "0", "LastEditDate": "2017-05-31T21:54:57.553", "OwnerUserId": "1505939"}, "44294121": {"ViewCount": "172", "Body": "<p>The following C++ program compiles just fine (g++ 5.4 at least gives a warning when invoked with <code>-Wall</code>):</p>\n<pre><code>int main(int argc, char *argv[])\n{\n  int i = i; // !\n  return 0;\n}\n</code></pre>\n<p>Even something like</p>\n<pre><code>int&amp; p = p;\n</code></pre>\n<p>is swallowed by the compiler.</p>\n<p>Now my question is: Why is such an initialization legal? Is there any actual use-case or is it just a consequence of the general design of the language?</p>\n", "Title": "Self-assignment of variable in its definition", "CreationDate": "2017-05-31T20:29:07.327", "LastActivityDate": "2017-05-31T22:36:37.277", "CommentCount": "7", "PostTypeId": "1", "Id": "44294121", "Score": "5", "OwnerUserId": "4378613", "Tags": "<c++>", "AnswerCount": "3"}, "44294518": {"Id": "44294518", "PostTypeId": "2", "Body": "<p>Just because the compiler accepts it (syntactically valid code) does <em>not</em> mean that it has well defined behaviour.</p>\n<p>The compiler is <em>not required</em> to diagnose all cases of Undefined Behaviour or other classes of problems.\nThe standard gives it pretty free hands to accept and translate broken code, on the assumption that if the results were to be undefined or nonsensical the programmer would not have written that code.</p>\n<p>So; the absense of warnings or errors from your compiler does not <em>in any way</em> prove that your program has well defined behaviour.\nIt is <em>your</em> responsibility to follow the rules of the language.\nThe compiler usually tries to help you by pointing out obvious flaws, but in the end it's on <em>you</em> to make sure your program makes sense.</p>\n<p>And something like <code>int i = i;</code> does not make sense but is <em>syntactically</em> correct, so the compiler may or may not warn you, but in any case is within its rights to just generate garbage (and not tell you about it) because you broke the rules and invoked Undefined Behaviour.</p>\n", "LastEditorUserId": "5910058", "LastActivityDate": "2017-05-31T21:06:07.903", "Score": "0", "CreationDate": "2017-05-31T20:55:48.163", "ParentId": "44294121", "CommentCount": "4", "LastEditDate": "2017-05-31T21:06:07.903", "OwnerUserId": "5910058"}});