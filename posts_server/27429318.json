post_cb({"bq_ids": {"n4140": {"so_27429318_27430786_0": {"length": 13, "quality": 0.8125, "section_id": 5768}}, "n3337": {"so_27429318_27430786_0": {"length": 13, "quality": 0.8125, "section_id": 5541}}, "n4659": {"so_27429318_27430786_0": {"length": 13, "quality": 0.8125, "section_id": 7225}}}, "27430786": {"Id": "27430786", "PostTypeId": "2", "Body": "<p>The issue the OP tried to solved by introducing an ellipsis <code>...</code>, as far as I understand, is that you may not define two functions with the same signature (a violation of the ODR).</p>\n<p>This concept of <em>signature</em> is extended to function templates. However, the <em>signature</em> of a function template includes its template-parameters. From a recent github draft, based on N4296:</p>\n<blockquote>\n<p id=\"so_27429318_27430786_0\">[defns.signature.templ] <h3>signature</h3> &lt;function template&gt;\n  name, parameter type list (8.3.5), enclosing namespace (if any),\n  return type, and template parameter list</p>\n</blockquote>\n<p>[basic.link]/9.4 and [temp.over.link] specify under what circumstances two function templates are equivalent. In the OP's case, you can make the signature of those function templates different by slightly altering the way SFINAE is applied:</p>\n<pre><code>template&lt;typename T,\n         typename std::enable_if&lt; std::is_integral&lt;T&gt;::value, int &gt;::type = 0&gt;\nexplicit Object(T&amp;&amp;);\n\ntemplate&lt;typename T,\n         typename std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, int&gt;::type = 0&gt;\nexplicit Object(T&amp;&amp;);\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/58cdc70863fa3173\" rel=\"nofollow\">Live example</a></p>\n<p>The type of the second (non-type) template-parameter is an expression dependent on the first template parameter. Those expressions distinguish the two templates; for details see [temp.over.link]/5. In the OP, the second template parameter is just a type. The template parameters of those two templates are therefore equivalent, there is just a difference in the <em>default template-argument</em>, which is not part of the signature.</p>\n<hr>\n<p>The problem of the ellipsis, when using constructor inheritance, is that the inherited constructor emits the ellipsis. This is a quirk of constructor inheritance, as specified in [class.inhctor]/1.4 When inheriting the two ctors in the OP, this leads to two function templates in the <em>candidate set of inherited constructors</em> with the same signature. I do not see how this is resolved in the Standard; clang++ and g++ agree that it is illegal, the ctor \"cannot be inherited\" or \"cannot be overloaded\".</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/29f31c7b9046c661\" rel=\"nofollow\">Live example</a></p>\n</hr>", "LastEditorUserId": "420683", "LastActivityDate": "2014-12-11T19:31:07.237", "Score": "5", "CreationDate": "2014-12-11T19:24:29.687", "ParentId": "27429318", "CommentCount": "2", "LastEditDate": "2014-12-11T19:31:07.237", "OwnerUserId": "420683"}, "27429676": {"Id": "27429676", "PostTypeId": "2", "Body": "<p>When the base class has ellipsis operator, it is ignored in the inherited one (when inherited with using...):</p>\n<pre><code>class A {\npublic:\n    A(int,...);\n};\n\nclass B: public A {\npublic:\n    using A::A;\n};\n</code></pre>\n<p>In the example, class B has a B::B(int), that will call A::A(int,...) with ... equals nothing, as it nothing where the default argument value, but the default is the only and mandatory option for constructors inheritance, see 12.9.1 on the standard:</p>\n<p><em>\"for each non-template constructor of X that has at least one parameter with a default argument, the set of constructors that results from omitting any ellipsis parameter specification and successively omitting parameters with a default argument from the end of the parameter-type-list, and\"</em> ... <em>\"for each constructor template of X that has at least one parameter with a default argument, the set of constructor templates that results from omitting any ellipsis parameter specification and successively omitting parameters with a default argument from the end of the parameter-type-list.\"</em></p>\n<p>I think that you cannot inherited a constructor with ..., and in this case you cannot redefine it neither because it will conflict with the inherited one.</p>\n", "LastEditorUserId": "4341442", "LastActivityDate": "2014-12-11T18:19:45.477", "Score": "1", "CreationDate": "2014-12-11T18:14:18.713", "ParentId": "27429318", "CommentCount": "0", "LastEditDate": "2014-12-11T18:19:45.477", "OwnerUserId": "4341442"}, "27429318": {"ViewCount": "285", "Body": "<p>I've recently come across a new warning:</p>\n<p><strong>Inheriting constructor does not inherit ellipsis</strong></p>\n<p>I'm attempting to pipe</p>\n<pre><code>Object{42}; // ... into an init that handles integers\n</code></pre>\n<p>...and...</p>\n<pre><code>Object{3.14}; // ... into an init that handles FLOATS\n</code></pre>\n<p>... by using some SFINAE cunning:</p>\n<pre><code>    #define DECAY(T)                typename std::decay&lt;T&gt;::type\n    #define IS_INTEGRAL(T)          std::is_integral&lt; DECAY(T) &gt;::value\n    #define IS_FLOATING(T)          std::is_floating_point&lt; DECAY(T) &gt;::value\n    #define SUBFAIL_UNLESS(PRED)    typename X = \\\n                                          typename std::enable_if&lt;PRED&gt;::type\n\n    // long, float\n    template&lt;typename T, SUBFAIL_UNLESS(IS_INTEGRAL(T)) &gt; \n    explicit Object( T&amp;&amp; t      ) : Object{ pyob_from_integral(t) }  { }\n\n    template&lt;typename T, SUBFAIL_UNLESS(IS_FLOATING(T)) &gt; \n    explicit Object( T&amp;&amp; t, ... ) : Object{ pyob_from_floating(t) }  { }\n\nprivate:\n    template&lt;typename T&gt; PyObject* pyob_from_integral( T t ) { \n        cout &lt;&lt; \"integral\"; return nullptr; \n    }\n\n    template&lt;typename T&gt; PyObject* pyob_from_floating(T t)   { \n        cout &lt;&lt; \"FLOATING\"; return nullptr; \n    }\n</code></pre>\n<p>.  Full code demonstrating the warning can be seen at <a href=\"http://coliru.stacked-crooked.com/a/4572e41b58843901\" rel=\"nofollow\">coliru</a>.</p>\n<p>Now the purpose of the ... is to avoid the compiler throwing an error because it thinks I have two separate templates templating the constructor. i.e. It isn't smart enough to realise they are disjoint / mutually exclusive.</p>\n<p>What is the significance of this warning, and how to code around it?</p>\n<p>PS please note that there is good reason for not simply supplying a couple of constructor overloads; I am deliberately simplifying the scenario to make the question as clear as I can.</p>\n<p>EDIT: working simplified test-case demonstrates the necessity of the ... <a href=\"http://coliru.stacked-crooked.com/a/3896e89d56dad40e\" rel=\"nofollow\">here</a>. (i.e. If you remove it, it no longer compiles).</p>\n", "AcceptedAnswerId": "27430786", "Title": "SFINAE gives \"Inheriting constructor does not inherit ellipsis\" warning", "CreationDate": "2014-12-11T17:54:32.300", "Id": "27429318", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-12-11T18:10:06.940", "LastEditorUserId": "435129", "LastActivityDate": "2014-12-11T19:31:07.237", "Score": "2", "OwnerUserId": "435129", "Tags": "<c++><inheritance><c++11><compiler-warnings><sfinae>", "AnswerCount": "2"}});