post_cb({"6009012": {"ParentId": "6009004", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2011-05-15T14:31:30.370", "Score": "24", "LastEditorUserId": "511601", "LastEditDate": "2011-05-18T11:21:07.153", "Id": "6009012", "OwnerUserId": "511601", "Body": "<p>If there is a move ctor for Foo, it should be selected.</p>\n<p>Function parameters are explicitly excluded from copy elision in return statements (FDIS \u00a712.9p31, first bullet):</p>\n<blockquote id=\"so_6009004_6009012_0\">\n<ul>\n<li>in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object <strong>(other than a function or catch-clause parameter)</strong></li>\n</ul>\n</blockquote>\n<p>However, the next paragraph explicitly brings move ctors back into consideration:</p>\n<blockquote>\n<p id=\"so_6009004_6009012_1\">When the criteria for elision of a copy operation are met or <strong>would be met save for the fact that the source object is a function parameter</strong>, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed <strong>as if the object were designated by an rvalue</strong>. \u2026</p>\n</blockquote>\n<p>(Emphasis is mine in both quotes.)</p>\n", "LastActivityDate": "2011-05-18T11:21:07.153"}, "6009019": {"ParentId": "6009004", "CommentCount": "4", "CreationDate": "2011-05-15T14:33:28.953", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "6009019", "Score": "12", "Body": "<p>This is valid code- G++'s behaviour is non-conformant. MSVC10 does support this behaviour.</p>\n", "LastActivityDate": "2011-05-15T14:33:28.953"}, "bq_ids": {"n4140": {"so_6009004_6009012_0": {"section_id": 480, "quality": 1.0, "length": 17}, "so_6009004_6009012_1": {"section_id": 481, "quality": 0.6896551724137931, "length": 20}}, "n3337": {"so_6009004_6009012_0": {"section_id": 471, "quality": 1.0, "length": 17}, "so_6009004_6009012_1": {"section_id": 472, "quality": 1.0, "length": 29}}, "n4659": {"so_6009004_6009012_0": {"section_id": 502, "quality": 1.0, "length": 17}, "so_6009004_6009012_1": {"section_id": 504, "quality": 0.5517241379310345, "length": 16}}}, "6009004": {"CommentCount": "0", "AcceptedAnswerId": "6009012", "CreationDate": "2011-05-15T14:30:01.460", "LastActivityDate": "2011-05-18T11:21:07.153", "PostTypeId": "1", "ViewCount": "542", "FavoriteCount": "4", "Title": "Are value parameters implicitly moved when returned by value?", "Id": "6009004", "Score": "22", "Body": "<p>Consider the following function:</p>\n<pre><code>Foo foo(Foo x)\n{\n    return x;\n}\n</code></pre>\n<p>Will <code>return x</code> invoke the copy constructor or the move constructor? (Let's leave NRVO aside here.)</p>\n<p>To investigate, I wrote a simple <code>Foo</code> class that is only movable but not copyable:</p>\n<pre><code>struct Foo\n{\n    Foo() = default;\n    Foo(const Foo&amp;) = delete;\n    Foo(Foo&amp;&amp;) = default;\n};\n</code></pre>\n<p>If the move constructor were invoked when returning value parameters by value, all should be fine. But the current g++ compiler complains about <code>return x</code> with the following error message:</p>\n<pre><code>error: deleted function 'Foo::Foo(const Foo&amp;)'\n</code></pre>\n<p>If I replace <code>return x</code> with <code>return std::move(x)</code>, everything is fine. From this I conclude that moving from value parameters must be done explicitly if desired. Is g++'s behavior conforming or not?</p>\n", "Tags": "<c++><rvalue-reference><move-semantics><c++11>", "OwnerUserId": "252000", "AnswerCount": "2"}});