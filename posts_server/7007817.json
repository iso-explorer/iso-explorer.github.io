post_cb({"7007817": {"CommentCount": "0", "AcceptedAnswerId": "7007890", "PostTypeId": "1", "LastEditorUserId": "5640", "CreationDate": "2011-08-10T08:23:45.120", "LastActivityDate": "2015-08-10T15:56:03.567", "LastEditDate": "2015-08-10T15:56:03.567", "ViewCount": "1311", "FavoriteCount": "3", "Title": "A confusing detail about the Most Vexing Parse", "Id": "7007817", "Score": "15", "Body": "<p>My question is how the following line can be parsed as a function declaration:</p>\n<pre><code>vector&lt;int&gt; v(istream_iterator&lt;int&gt;(cin), istream_iterator&lt;int&gt;());\n</code></pre>\n<p>I understand most of the details of the Most Vexing Parse and why the second temporary iterator can be interpreted as a type that is a function returning an iterator and taking no arguments, but what I don't get is why the first temporary iterator can be interpreted as a type.  What type does it represent?  My thought is that it would be some sort of function type, but I can't see how the name <code>cin</code> gets used.  Is it declaring that the parameter is an <code>istream_iterator&lt;int&gt;</code> named <code>cin</code>?  If so, does that mean that you can arbitrarily parenthesize the names of arguments to functions?  And if so, why?</p>\n", "Tags": "<c++><most-vexing-parse>", "OwnerUserId": "501557", "AnswerCount": "4"}, "7007890": {"ParentId": "7007817", "CommentCount": "25", "Body": "<p><code>istream_iterator&lt;int&gt;(cin)</code> is exactly the same as <code>istream_iterator&lt;int&gt; cin</code> but with superfluous parens. This declarator syntax was inherited from C, and I think even the inventor of C (Ken Thompson?) described it as a mistake.</p>\n", "OwnerUserId": "882003", "PostTypeId": "2", "Id": "7007890", "Score": "10", "CreationDate": "2011-08-10T08:29:47.530", "LastActivityDate": "2011-08-10T08:29:47.530"}, "7009105": {"ParentId": "7007817", "CommentCount": "0", "Body": "<p>There is a section called <strong><code>Ambiguity resolution</code></strong> in the Standard (2003) which is dedicated to such syntaxes. I think I don't need to explain it further if you read the section yourself, for its very clear with lots of examples!</p>\n<p>So here you go:</p>\n<blockquote>\n<p id=\"so_7007817_7009105_0\"><strong>8.2 Ambiguity resolution [dcl.ambig.res]</strong></p>\n<p id=\"so_7007817_7009105_1\">1 - The ambiguity arising from the similarity between a function-style cast and a declaration mentioned in 6.8 can also occur in the context of a declaration. <strong>In that context, the choice is between a function declaration with a redundant set of parentheses around a parameter name and an object declaration with a function-style cast as the initializer. Just as for the ambiguities mentioned in 6.8, the resolution is to consider any construct that could possibly be a declaration a declaration.</strong> [Note: a declaration can be explicitly disambiguated by a nonfunction-style cast, by a = to indicate initialization or by removing the redundant parentheses around the parameter name. ] </p>\n</blockquote>\n<pre><code>[Example:\n\nstruct S {\n    S(int);\n};\n\nvoid foo(double a)\n{\n   S w(int(a));  // function declaration\n   S x(int());   // function declaration\n   S y((int)a);  // object declaration\n   S z = int(a); // object declaration\n}\n\u2014end example]\n</code></pre>\n<blockquote>\n<p id=\"so_7007817_7009105_2\">2 - The ambiguity arising from the similarity between a function-style cast and a type-id can occur in different contexts. The ambiguity appears as a choice between a function-style cast expression and a declaration of a type. <strong>The resolution is that any construct that could possibly be a type-id in its syntactic context shall be considered a type-id.</strong></p>\n</blockquote>\n<pre><code>3- [Example:\n\n#include &lt;cstddef&gt;\n\nchar *p;\nvoid *operator new(size_t, int);\n\nvoid foo() {\n    const int x = 63;\n    new (int(*p)) int; // new-placement expression\n    new (int(*[x]));   // new type-id\n}\n\n//4 - For another example,\n\ntemplate &lt;class T&gt;\nstruct S {\n    T *p;\n};\nS&lt;int()&gt; x;  // type-id\nS&lt;int(1)&gt; y; // expression (ill-formed)\n\n//5 - For another example,\nvoid foo()\n{\n   sizeof(int(1)); // expression\n   sizeof(int()); // type-id (ill-formed)\n}\n\n//6 - For another example,\nvoid foo()\n{\n   (int(1)); //expression\n   (int())1; //type-id (ill-formed)\n}\n\u2014end example]\n</code></pre>\n<blockquote>\n<p id=\"so_7007817_7009105_3\">7 - Another ambiguity arises in a parameter-declaration-clause of a function declaration, or in a type-id that is the operand of a sizeof or typeid operator, when a type-name is nested in parentheses. <strong>In this case, the choice is between the declaration of a parameter of type pointer to function and the declaration of a parameter with redundant parentheses around the declarator-id. The resolution is to consider the type-name as a\n  simple-type-specifier rather than a declarator-id.</strong> </p>\n</blockquote>\n<pre><code>[Example:\n\nclass C { };\nvoid f(int(C)) { }    // void f(int (*fp)(C c)) { }\n                      // not: void f(int C);\nint g(C);\nvoid foo() {\n    f(1); //error: cannot convert 1 to function pointer\n    f(g); //OK\n}\n\n//For another example,\nclass C { };\nvoid h(int *(C[10]));  // void h(int *(*_fp)(C _parm[10]));\n                      // not: void h(int *C[10]);\n\n\u2014end example]\n</code></pre>\n", "OwnerUserId": "415784", "PostTypeId": "2", "Id": "7009105", "Score": "2", "CreationDate": "2011-08-10T10:10:27.367", "LastActivityDate": "2011-08-10T10:10:27.367"}, "7007867": {"ParentId": "7007817", "CommentCount": "3", "Body": "<p>Yes, it is the parameter name. And, yes you can add a set of parenthesis, because sometimes you have to.</p>\n<p>If the parameter is a function pointer, <code>void (*f)()</code> you need to write it like that. </p>\n<p>The people writing the standard have not spent their precious time pointing out exactly the cases where the parenthesis are allowed or actually required, so the standard just says that you <em>can</em> have them.</p>\n", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "7007867", "Score": "6", "CreationDate": "2011-08-10T08:27:57.607", "LastActivityDate": "2011-08-10T08:27:57.607"}, "7008524": {"ParentId": "7007817", "CommentCount": "1", "Body": "<p>Did I already said that I liked Clang (a lot) ?</p>\n<p>Just try the following (simplified code)</p>\n<pre><code>#include &lt;vector&gt;\n\nvoid foo(std::vector&lt;int&gt;);\n\nint main() {\n  std::vector&lt;int&gt; v(int(i), int());\n  foo(v);\n}\n</code></pre>\n<p>In the newly rebrandished <a href=\"http://llvm.org/demo/index.cgi\">LLVM Try Out</a> (well, it just went from llvm-gcc to clang).</p>\n<p>And you get:</p>\n<pre><code>/tmp/webcompile/_21483_0.cc:6:21: warning: parentheses were disambiguated\n                                           as a function declarator\n  std::vector&lt;int&gt; v(int(i), int());\n                    ^~~~~~~~~~~~~~~\n/tmp/webcompile/_21483_0.cc:7:3: error: no matching function for call to 'foo'\n  foo(v);\n  ^~~\n/tmp/webcompile/_21483_0.cc:3:6: note: candidate function not viable:\n     no known conversion from 'std::vector&lt;int&gt; (int, int (*)())'\n     to 'std::vector&lt;int&gt;' for 1st argument\nvoid foo(std::vector&lt;int&gt;);\n     ^\n3 diagnostics generated.\n</code></pre>\n<p>And therefore, @john is right, <code>int(i)</code> is interpreted as <code>int i</code>, ie a named parameter to the function.</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "7008524", "Score": "7", "CreationDate": "2011-08-10T09:24:05.293", "LastActivityDate": "2011-08-10T09:24:05.293"}, "bq_ids": {"n4140": {"so_7007817_7009105_2": {"section_id": 3202, "quality": 0.90625, "length": 29}, "so_7007817_7009105_1": {"section_id": 3201, "quality": 0.9629629629629629, "length": 52}, "so_7007817_7009105_3": {"section_id": 3207, "quality": 0.9722222222222222, "length": 35}}, "n3337": {"so_7007817_7009105_2": {"section_id": 3076, "quality": 0.90625, "length": 29}, "so_7007817_7009105_1": {"section_id": 3075, "quality": 0.9629629629629629, "length": 52}, "so_7007817_7009105_3": {"section_id": 3081, "quality": 0.9722222222222222, "length": 35}}, "n4659": {"so_7007817_7009105_1": {"section_id": 3962, "quality": 0.8148148148148148, "length": 44}, "so_7007817_7009105_3": {"section_id": 3964, "quality": 0.7777777777777778, "length": 28}}}});