post_cb({"bq_ids": {"n4140": {"so_48893928_48902008_2": {"length": 7, "quality": 1.0, "section_id": 340}, "so_48893928_48902008_0": {"length": 5, "quality": 0.625, "section_id": 94}, "so_48893928_48902008_3": {"length": 7, "quality": 1.0, "section_id": 340}, "so_48893928_48902008_1": {"length": 7, "quality": 1.0, "section_id": 340}, "so_48893928_48902008_4": {"length": 9, "quality": 0.6428571428571429, "section_id": 94}, "so_48893928_48893928_0": {"length": 6, "quality": 0.75, "section_id": 142}}, "n3337": {"so_48893928_48902008_1": {"length": 7, "quality": 1.0, "section_id": 330}, "so_48893928_48902008_0": {"length": 5, "quality": 0.625, "section_id": 89}, "so_48893928_48902008_4": {"length": 9, "quality": 0.6428571428571429, "section_id": 89}, "so_48893928_48902008_3": {"length": 7, "quality": 1.0, "section_id": 330}, "so_48893928_48902008_2": {"length": 7, "quality": 1.0, "section_id": 330}, "so_48893928_48893928_0": {"length": 6, "quality": 0.75, "section_id": 136}}, "n4659": {"so_48893928_48902008_1": {"length": 7, "quality": 1.0, "section_id": 349}, "so_48893928_48902008_0": {"length": 8, "quality": 1.0, "section_id": 97}, "so_48893928_48902008_4": {"length": 14, "quality": 1.0, "section_id": 97}, "so_48893928_48902008_3": {"length": 7, "quality": 1.0, "section_id": 349}, "so_48893928_48902008_2": {"length": 7, "quality": 1.0, "section_id": 349}, "so_48893928_48893928_0": {"length": 6, "quality": 0.75, "section_id": 146}}}, "48902008": {"Id": "48902008", "PostTypeId": "2", "Body": "<p>This finaly seems to be a GCC bug in the implementation of the new C++ template template argument deduction <a href=\"https://clang.llvm.org/cxx_status.html\" rel=\"nofollow noreferrer\">partial support for this feature</a>.</p>\n<p>To determine if a partial specialization is more specialized than the class template, <a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp.class.order\" rel=\"nofollow noreferrer\">partial ordering is applied to 2 corresponding synthetized functions</a>:</p>\n<pre><code>//template class:\ntemplate&lt;template&lt;class...&gt;class P&gt; void f_foo0(foo&lt;P&gt;);\n\n//Partial specialization\ntemplate&lt;template&lt;class P&gt; class P&gt; void f_foo_partial0(foo&lt;P&gt;);\n</code></pre>\n<p>Then it is attempted to perform template argument deduction, by calling each functions with an argument corresponding to the other function parameter (see <a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp.func.order#3\" rel=\"nofollow noreferrer\">[temp.func.order]</a>)</p>\n<pre><code>template&lt;class P&gt; struct Atype{};\ntemplate&lt;class ...P&gt; struct ATypePack{};\n\n//Is f_foo_partial at least as specialized as f_foo?\nf_foo(foo&lt;AType&gt;{});\n\n//Is f_foo at least as specialized as f_foo_partial?\nf_foo_partial(foo&lt;ATypePack&gt;{});\n</code></pre>\n<p>If template argument succeed for (1) then <code>f_foo_partial</code> is <em>at least as specialized</em> as <code>f_foo</code>. If template argument succeed for (2) then <code>f_foo</code> is <em>at least as specialized</em> as <code>f_foo_partial</code>.( see <a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp.deduct.partial#10\" rel=\"nofollow noreferrer\">[temp.deduct.partial]</a>). Then if only one is <em>at least as specialized</em> as the other, then it is the one which is <em>more specialized</em>.</p>\n<p>So <a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp.deduct.partial#8\" rel=\"nofollow noreferrer\">to check if template argument is deductible</a>, then <a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp.deduct.type\" rel=\"nofollow noreferrer\">deduction of template argument from a type</a> is perfomed.</p>\n<p>Then to perform this matching, the introduced rule in C++17 is applied <a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp.arg.template#3\" rel=\"nofollow noreferrer\">[temp.arg.template]/3</a>:</p>\n<blockquote>\n<p id=\"so_48893928_48902008_0\">A template-argument matches a template template-parameter P when P is at least as specialized as the template-argument A.[...]</p>\n</blockquote>\n<p>And [temp.arg.template]/4 specify that this ordering will be performed similarily to the preceding case using these invented two functions:</p>\n<pre><code>template&lt;class...&gt; struct X{};\n//for the argument\ntemplate&lt;class...P&gt; void f_targ(X&lt;P...&gt;);\n\n//Partial specialization\ntemplate&lt;class P&gt; void f_tparam(X&lt;P&gt;);\n\nstruct Atype{};\nstruct ATypePack{};\n\n//Is template template parameter at least as specialized template template arg?\nf_targ(X&lt;AType&gt;{});\n\n//Is template template arg at least as specialized as template template parameter?\nf_tparam(X&lt;ATypePack&gt;{});\n</code></pre>\n<ul>\n<li><p>for (1) template argument succeed the deduced argument for <code>...P`` is</code>AType`.</p></li>\n<li><p>for (2) there is a special rule, that applies only in the case of template partial ordering [temp.deduct.type]/9.2:</p></li>\n</ul>\n<blockquote>\n<p id=\"so_48893928_48902008_1\">[...] <strong>During partial ordering, if Ai was originally a pack expansion:</strong></p>\n<ul>\n<li><p id=\"so_48893928_48902008_2\">if P does not contain a template argument corresponding to Ai then Ai\n  is ignored;</p></li>\n<li><p id=\"so_48893928_48902008_3\"><strong>otherwise, if Pi is not a pack expansion, template argument deduction fails.</strong> </p></li>\n</ul>\n</blockquote>\n<p>Here Ai is <code>ATypePack</code> and <code>Pi</code> is the <code>P</code> in the function argument of  <code>template&lt;class P&gt; void p_foo_partial(foo&lt;P&gt;)</code>.</p>\n<p>So due to this rule cited in bold, template argument deduction fails for (2), so template template parameter \"class P\" is <em>more specialized</em> than its argument. So the call <code>f_foo_partial(foo&lt;ATypePack&gt;{})</code> is well formed.</p>\n<p>On the other hand the same rules, the call to <code>f_foo(AType{})</code> is well formed because of [temp.arg.temp]/3:</p>\n<blockquote>\n<p id=\"so_48893928_48902008_4\">[...] If P contains a parameter pack, then A also matches P if each of A's template parameters matches the corresponding template parameter in the template-parameter-list of P.[...]</p>\n</blockquote>\n<p>so <code>f_foo_partial</code> is not more specialized than <code>f_foo</code>, so <code>template&lt;class&lt;class &gt; class C&gt; struct foo&lt;C&gt;;</code> is not a partial specialization of template <code>foo</code>.</p>\n", "LastEditorUserId": "5632316", "LastActivityDate": "2018-02-21T12:52:04.293", "Score": "2", "CreationDate": "2018-02-21T09:14:12.743", "ParentId": "48893928", "CommentCount": "18", "OwnerUserId": "5632316", "LastEditDate": "2018-02-21T12:52:04.293"}, "48893928": {"ViewCount": "279", "Body": "<p>Consider the following program:</p>\n<pre><code>template&lt;template&lt;typename ...&gt; class&gt;\nstruct foo {};\n\ntemplate&lt;template&lt;typename&gt; class C&gt;\nstruct foo&lt;C&gt; {};\n\nint main() {}\n</code></pre>\n<p>Clang rejects it with error:</p>\n<blockquote>\n<p id=\"so_48893928_48893928_0\">class template partial specialization does not specialize any template argument</p>\n</blockquote>\n<p>even in latest clang 7.0 HEAD, see demo <a href=\"https://wandbox.org/permlink/0A9I3yMrHz6rBo8i\" rel=\"noreferrer\">here</a>. However, <a href=\"https://wandbox.org/permlink/O4qh7qQWjhhS6YUZ\" rel=\"noreferrer\">gcc accepts it</a>.</p>\n<p>Refer to <a href=\"http://www.eel.is/c++draft/temp.class.spec\" rel=\"noreferrer\">[temp.class.spec]</a> where the rules of partial specialization are stated, I couldn't find anything that prohibits the partial specialization of this template. Especially, the specialization is indeed <a href=\"http://www.eel.is/c++draft/temp.class.order#def:more_specialized\" rel=\"noreferrer\">more specialized</a>, the error message looks incorrect.</p>\n<p><strong>EDIT:</strong></p>\n<p>However, gcc's behavior is also abnormal, consider the following program:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;template&lt;typename ...&gt; class&gt;\nstruct foo { void show() { std::cout &lt;&lt; \"Primary.\\n\"; } };\n\ntemplate&lt;template&lt;typename&gt; class C&gt;\nstruct foo&lt;C&gt; { void show() { std::cout &lt;&lt; \"Specialized.\\n\"; } };\n\ntemplate&lt;class...&gt; struct bar {};\n\nint main() {\n    foo&lt;bar&gt; f;\n    f.show();\n}\n</code></pre>\n<p>It turns out that gcc uses the specialized version in this case, see <a href=\"https://wandbox.org/permlink/2OjOulfvDjGJ0CPo\" rel=\"noreferrer\">here</a>.</p>\n<p>Now I want to ask:</p>\n<ul>\n<li><p>is this kind of partial specialization allowed by standard ?</p></li>\n<li><p>which compiler is correct ? ( one/all/none of them ? )</p></li>\n</ul>\n", "Title": "Can variadic template template parameter be partial-specialized?", "CreationDate": "2018-02-20T20:46:10.043", "LastActivityDate": "2018-02-21T12:52:04.293", "CommentCount": "8", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2018-02-20T23:08:21.743", "LastEditorUserId": "8605791", "Id": "48893928", "Score": "16", "OwnerUserId": "8605791", "Tags": "<c++><templates><clang><language-lawyer><template-specialization>", "AnswerCount": "1"}});