post_cb({"bq_ids": {"n4140": {"so_14063717_14067836_1": {"length": 17, "quality": 1.0, "section_id": 6286}, "so_14063717_14067836_0": {"length": 16, "quality": 0.8, "section_id": 4292}}, "n3337": {"so_14063717_14067836_1": {"length": 17, "quality": 1.0, "section_id": 6046}, "so_14063717_14067836_0": {"length": 18, "quality": 0.9, "section_id": 4133}}, "n4659": {"so_14063717_14067836_1": {"length": 17, "quality": 1.0, "section_id": 7793}, "so_14063717_14067836_0": {"length": 15, "quality": 0.75, "section_id": 5550}}}, "14067836": {"Id": "14067836", "PostTypeId": "2", "Body": "<p>As I said in my comment, if the deleter type you pass has a nested <code>pointer</code> typedef, it must fulfill the <em>NullablePointer</em>  requirements:</p>\n<p><code>20.7.1.2 [unique.ptr.single] p3</code></p>\n<blockquote>\n<p id=\"so_14063717_14067836_0\">If the type <code>remove_reference&lt;D&gt;::type::pointer</code> exists, then <code>unique_ptr&lt;T, D&gt;::pointer</code> shall be a synonym for <code>remove_reference&lt;D&gt;::type::pointer</code>. Otherwise <code>unique_ptr&lt;T, D&gt;::pointer</code> shall be a synonym for <code>T*</code>. <strong>The type <code>unique_ptr&lt;T, D&gt;::pointer</code> shall satisfy the requirements of <code>NullablePointer</code> (17.6.3.3)</strong>.</p>\n</blockquote>\n<p>And <code>\u00a717.6.3.3</code> then lists all the requirements a type has to fulfill to be a NullablePointer. Certain semantics are listed in a table, where:</p>\n<blockquote>\n<p id=\"so_14063717_14067836_1\"><code>u</code> denotes an identifier, <code>t</code> denotes a non-const lvalue of type <code>P</code>, <code>a</code> and <code>b</code> denote values of type (possibly <code>const</code>) <code>P</code>, and <code>np</code> denotes a value of type (possibly <code>const</code>) <code>std::nullptr_t</code>.</p>\n</blockquote>\n<pre><code>Expression    Return type                         Operational semantics\nP u(np);                                          post: u == nullptr\nP u = np;\nP(np)                                             post: P(np) == nullptr\nt = np        P&amp;                                  post: t == nullptr\na != b        contextually convertible to bool    !(a == b)\na == np       contextually convertible to bool    a == P()\nnp == a\na != np       contextually convertible to bool    !(a == np)\nnp != a\n</code></pre>\n<p>Now, the simplest solution is to wrap your <code>int</code> in a type that provides these semantics:</p>\n<pre><code>#include &lt;cstddef&gt; // std::nullptr_t\n\nstruct handle{\n  handle() : value(0){}\n  handle(std::nullptr_t) : value(0){}\n  /*explicit*/ handle(int v) : value(v){} // make it explicit if you need it\n  // special members can be generated\n\n  handle&amp; operator=(std::nullptr_t){ value = 0; return *this; }\n\n  // contextual conversion to bool\n  explicit operator bool() const{ return value != 0; }\n\n  int value;\n};\n\nbool operator==(handle lhs, handle rhs){ return lhs.value == rhs.value; }\nbool operator!=(handle lhs, handle rhs){ return lhs.value != rhs.value; }\n// comparision against 'nullptr' is handled by the above operators\n// since 'nullptr' can be implicitly converted to 'handle'\n</code></pre>\n", "LastActivityDate": "2012-12-28T10:05:22.723", "CommentCount": "2", "CreationDate": "2012-12-28T10:05:22.723", "ParentId": "14063717", "Score": "7", "OwnerUserId": "500104"}, "14063717": {"ViewCount": "1539", "Body": "<p>I'm attempting to use <code>std::unique_ptr</code> in order to store the integer handle to some opaque objects. For this purpose, I have defined a custom deleter type which does <code>typedef int pointer</code> in order to override the raw pointer type to <code>int</code> instead of <code>int*</code>. This process is described in the last section of this site: <a href=\"http://asawicki.info/news_1494_unique_ptr_in_visual_c_2010.html\" rel=\"nofollow\">http://asawicki.info/news_1494_unique_ptr_in_visual_c_2010.html</a></p>\n<p>Here is some sample code to better illustrate what I'm attempting to do:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\nstatic void close(int p)\n{\n    std::cout &lt;&lt; p &lt;&lt; \" has been deleted!\" &lt;&lt; std::endl;\n}\n\nstruct handle_deleter\n{\n    typedef int pointer;\n    void operator()(pointer p) { close(p); }\n};\n\ntypedef std::unique_ptr&lt; int, handle_deleter&gt; unique_handle;\n\nint main(int argc, char *argv[])\n{\n    unique_handle handle(1);\n\n    return 0;\n}\n</code></pre>\n<p>When I compile this code using GCC 4.7.2, I get the following error:</p>\n<pre><code>In file included from /usr/lib/gcc/x86_64-redhat-linux/4.7.2/../../../../include/c++/4.7.2/memory:86:0,\n                 from unique_ptr_test.cpp:1:\n/usr/lib/gcc/x86_64-redhat-linux/4.7.2/../../../../include/c++/4.7.2/bits/unique_ptr.h: In instantiation of \u2018std::unique_ptr&lt;_Tp, _Dp&gt;::~unique_ptr() [with _Tp = int; _Dp = handle_deleter]\u2019:\nunique_ptr_test.cpp:19:23:   required from here\n/usr/lib/gcc/x86_64-redhat-linux/4.7.2/../../../../include/c++/4.7.2/bits/unique_ptr.h:172:2: error: invalid operands of types \u2018int\u2019 and \u2018std::nullptr_t\u2019 to binary \u2018operator!=\u2019\n</code></pre>\n<p>The code of the <code>~unique_ptr</code> procedure reads as follows:</p>\n<pre><code>// Destructor.\n~unique_ptr() noexcept\n{\n    auto&amp; __ptr = std::get&lt;0&gt;(_M_t);\n    if (__ptr != nullptr)\n      get_deleter()(__ptr);\n    __ptr = pointer();\n}\n</code></pre>\n<p>According to me, the check against nullptr does not make sense since the raw pointer type is <code>int</code> (and not <code>int*</code> due to overriding it in <code>HandleDeleter</code>). Strangely enough, this code compiles with no error under GCC 4.6.1. Upon execution, the sample displays \"1 has been deleted!\" as expected.</p>\n<p>I was wondering if there is any detail I'm overlooking or if it really is a bug within GCC's STL implementation of unique_ptr.</p>\n<p>Thanks,</p>\n<p>PMJ</p>\n", "AcceptedAnswerId": "14067836", "Title": "Broken std::unique_ptr in GCC 4.7.2", "CreationDate": "2012-12-28T02:08:34.240", "Id": "14063717", "CommentCount": "7", "LastEditDate": "2012-12-28T10:15:58.977", "PostTypeId": "1", "LastEditorUserId": "500104", "LastActivityDate": "2012-12-28T10:15:58.977", "Score": "1", "OwnerUserId": "522742", "Tags": "<c++><c++11><unique-ptr>", "AnswerCount": "1"}});