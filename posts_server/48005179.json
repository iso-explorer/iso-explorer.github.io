post_cb({"bq_ids": {"n4140": {"so_48005179_48008932_2": {"length": 22, "quality": 0.9166666666666666, "section_id": 7224}, "so_48005179_48008932_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 40}, "so_48005179_48008932_0": {"length": 44, "quality": 0.8979591836734694, "section_id": 6046}, "so_48005179_48008932_3": {"length": 41, "quality": 0.7321428571428571, "section_id": 6039}}, "n3337": {"so_48005179_48008932_2": {"length": 22, "quality": 0.9166666666666666, "section_id": 6968}, "so_48005179_48008932_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 37}, "so_48005179_48008932_0": {"length": 40, "quality": 0.8163265306122449, "section_id": 5814}, "so_48005179_48008932_3": {"length": 30, "quality": 0.5357142857142857, "section_id": 5807}}, "n4659": {"so_48005179_48008932_2": {"length": 20, "quality": 0.8333333333333334, "section_id": 8734}, "so_48005179_48008932_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 40}, "so_48005179_48008932_0": {"length": 43, "quality": 0.8775510204081632, "section_id": 7545}, "so_48005179_48008932_3": {"length": 56, "quality": 1.0, "section_id": 7538}}}, "48008932": {"Id": "48008932", "PostTypeId": "2", "Body": "<p><sub>I want to put the back and forth under <a href=\"https://stackoverflow.com/a/48005212/817643\">@Bathsheba's post</a> to rest. So here's an answer about the finer details of what you are doing.</sub></p>\n<hr>\n<p><a href=\"https://stackoverflow.com/a/48005277/817643\">@Sean already suggested</a> you <code>reinterpret_cast</code> your pointers instead. And that is equivalent to your second chain of casts. It says as much in <a href=\"https://timsong-cpp.github.io/cppwp/n4659/expr.reinterpret.cast#7\" rel=\"nofollow noreferrer\">[expr.reinterpret.cast]/7</a>:</p>\n<blockquote>\n<p id=\"so_48005179_48008932_0\">An object pointer can be explicitly converted to an object pointer of\n  a different type. When a prvalue <code>v</code> of object pointer type is\n  converted to the object pointer type \u201cpointer to cv <code>T</code>\u201d, the result is\n  <code>static_\u00adcast&lt;cv T*&gt;(static_\u00adcast&lt;cv void*&gt;(v))</code>. [\u2009Note: Converting a\n  prvalue of type \u201cpointer to <code>T1</code>\u201d to the type \u201cpointer to <code>T2</code>\u201d (where <code>T1</code>\n  and <code>T2</code> are object types and where the alignment requirements of <code>T2</code> are\n  no stricter than those of <code>T1</code>) and back to its original type yields the\n  original pointer value. \u2009\u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>Now, let's examine each step of the two step conversion. First we have a <code>static_cast&lt;void*&gt;</code>. According to <a href=\"https://timsong-cpp.github.io/cppwp/n4659/conv.ptr#2\" rel=\"nofollow noreferrer\">[conv.ptr]/2</a> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_48005179_48008932_1\">A prvalue of type \u201cpointer to cv <code>T</code>\u201d, where <code>T</code> is an object type, can be\n  converted to a prvalue of type \u201cpointer to cv <code>void</code>\u201d. <strong>The pointer value\n  is unchanged by this conversion</strong>.</p>\n</blockquote>\n<p>The first conversion doesn't do any alteration to the address. And then it also says in <a href=\"https://timsong-cpp.github.io/cppwp/n4659/basic.compound#5\" rel=\"nofollow noreferrer\">[basic.compound]/5</a>:</p>\n<blockquote>\n<p id=\"so_48005179_48008932_2\">A pointer to cv-qualified or cv-unqualified <code>void</code> can be used to point\n  to objects of unknown type. Such a pointer shall be able to hold any\n  object pointer. An object of type cv <code>void*</code> shall have the same\n  representation and alignment requirements as cv <code>char*</code>.</p>\n</blockquote>\n<p>So a <code>char*</code> may store any address a <code>void*</code> may store. Now it doesn't mean the conversion from <code>void*</code> to <code>char*</code> is value preserving, only that they can represent the same values. Now, assuming a very restricted use case, that is enough of a guarantee. But there's more at <a href=\"https://timsong-cpp.github.io/cppwp/n4659/expr.static.cast#13\" rel=\"nofollow noreferrer\">[expr.static.cast]/13</a>:</p>\n<blockquote>\n<p id=\"so_48005179_48008932_3\">A prvalue of type \u201cpointer to cv1 void\u201d can be converted to a prvalue\n  of type \u201cpointer to cv2 T\u201d, where T is an object type and cv2 is the\n  same cv-qualification as, or greater cv-qualification than, cv1. If\n  the original pointer value represents the address A of a byte in\n  memory and A does not satisfy the alignment requirement of T, then the\n  resulting pointer value is unspecified. Otherwise, if the original\n  pointer value points to an object a, and there is an object b of type\n  T (ignoring cv-qualification) that is pointer-interconvertible with a,\n  the result is a pointer to b. <strong>Otherwise, the pointer value is\n  unchanged by the conversion</strong>.</p>\n</blockquote>\n<p>Where am I going with this? Assuming <code>pc</code> already holds the address of an <code>int</code> (suitably converted according to the above), then casting the <code>char*</code> to an <code>int*</code> via <code>reinterpret_cast</code> will give you the address of the original <code>int</code>. The note under the first paragraph says as much, and the further quotes prove it. If it doesn't hold the address of an <code>int</code>, you are playing roulette and are likely going to lose. Your program has undefined behavior. You should follow Bathsheba's advice to the letter.</p>\n</hr>", "LastEditorUserId": "817643", "LastActivityDate": "2018-01-02T21:58:21.577", "Score": "1", "CreationDate": "2017-12-28T14:05:02.617", "ParentId": "48005179", "CommentCount": "1", "OwnerUserId": "817643", "LastEditDate": "2018-01-02T21:58:21.577"}, "48005212": {"Id": "48005212", "PostTypeId": "2", "Body": "<p>The behaviour on converting, in general, a <code>char*</code> pointer to an <code>int*</code> pointer is <em>undefined</em>. Dereferencing such a pointer will cause you further trouble as you will be breaking <em>strict aliasing</em> rules. Note that the C++ Standard does not require <code>sizeof(char*)</code> to be the same as <code>sizeof(int*)</code>.</p>\n<p>(Note that converting an <code>unsigned char*</code> pointer to an <code>int*</code> is well-defined if the <code>unsigned char*</code> pointer actually points to an <code>int</code>).</p>\n<p>Don't do it. Ever.</p>\n", "LastEditorUserId": "2380830", "LastActivityDate": "2017-12-28T10:25:46.643", "Score": "6", "CreationDate": "2017-12-28T09:50:48.073", "ParentId": "48005179", "CommentCount": "22", "OwnerUserId": "2380830", "LastEditDate": "2017-12-28T10:25:46.643"}, "48005179": {"ViewCount": "150", "Body": "<p>I want to cast a pointer <code>pc</code> which points to char to a point <code>pi</code> which points to int</p>\n<pre><code>char *pc;\nint *pi;\npi = (int*)pc                                    // compiler complaint about old-style cast\npi = static_cast&lt;int *&gt;(static_cast&lt;void *&gt;(pc)) // no complaint any more but too complex\n</code></pre>\n<p>is there any simpler ways to do this cast and make compiler silence?</p>\n", "AcceptedAnswerId": "48008932", "Title": "How to cast a pointer to char to a pointer to int", "CreationDate": "2017-12-28T09:49:19.973", "LastActivityDate": "2018-01-03T08:48:06.177", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-01-03T08:48:06.177", "LastEditorUserId": "4652706", "Id": "48005179", "Score": "2", "OwnerUserId": "5829527", "Tags": "<c++><pointers><casting>", "AnswerCount": "3"}, "48005277": {"Id": "48005277", "PostTypeId": "2", "Body": "<p>If you really need to do this then <a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast\" rel=\"noreferrer\">reinterpret_cast</a> is your friend:</p>\n<pre><code>char *pc = 0;\nint *pi = 0;\n\npi = reinterpret_cast&lt;int*&gt;(pc);\n</code></pre>\n", "LastActivityDate": "2017-12-28T09:54:34.243", "Score": "7", "CreationDate": "2017-12-28T09:54:34.243", "ParentId": "48005179", "CommentCount": "2", "OwnerUserId": "26095"}});