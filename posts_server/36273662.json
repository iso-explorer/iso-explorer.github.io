post_cb({"bq_ids": {"n4140": {"so_36273662_36273770_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 3360}, "so_36273662_36273770_0": {"length": 7, "quality": 1.0, "section_id": 3359}}, "n3337": {"so_36273662_36273770_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 3230}, "so_36273662_36273770_0": {"length": 7, "quality": 1.0, "section_id": 3229}}, "n4659": {"so_36273662_36273770_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 4126}, "so_36273662_36273770_0": {"length": 7, "quality": 1.0, "section_id": 4125}}}, "36273770": {"Id": "36273770", "PostTypeId": "2", "Body": "<p><em>function-try-block</em> in the constructor doesn't prevent the exception from being thrown. Here's an excerpt from C++ standard draft N4140, [except.handle]:</p>\n<blockquote>\n<p id=\"so_36273662_36273770_0\"><code>14</code> If a return statement appears in a handler of the <em>function-try-block</em> of a constructor, the program is ill-formed.</p>\n<p id=\"so_36273662_36273770_1\"><code>15</code> The currently handled exception is rethrown if control reaches the end of a handler of the <em>function-try-block</em> of a constructor or destructor. Otherwise, ...</p>\n</blockquote>\n<p>The reason for this is that if base class or any member constructor throws an exception, then the construction of the whole object fails, and there's no way to fix it, so the exception has to be thrown.</p>\n<p>There's a <a href=\"http://gotw.ca/gotw/066.htm\">GOTW</a> on this, and the bottomline is</p>\n<blockquote>\n<p id=\"so_36273662_36273770_2\">Constructor function-try-block handlers have only one purpose -- to translate an exception. (And maybe to do logging or some other side effects.) They are not useful for any other purpose.</p>\n</blockquote>\n<p>So, yes, your last code sample is perfectly fine.</p>\n", "LastEditorUserId": "3959454", "LastActivityDate": "2016-03-29T01:20:06.940", "Score": "7", "CreationDate": "2016-03-29T01:12:08.710", "ParentId": "36273662", "CommentCount": "2", "OwnerUserId": "3959454", "LastEditDate": "2016-03-29T01:20:06.940"}, "36273769": {"Id": "36273769", "PostTypeId": "2", "Body": "<p>Wrapping a try/catch around a superclass's constructor lets you trap exceptions that get thrown in the superclass's constructor; however the exception gets automatically rethrown when the <code>catch</code> block ends, and the exception continues to propagate.</p>\n<p>After all, the superclass did not get constructed. It threw an exception. So you can't really continue on your merry way, in the subclass's constructor, and then end up with a constructed subclass, but with a superclass that did not get constructed. That makes no sense.</p>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/language/function-try-block\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/function-try-block</a>:</p>\n<blockquote>\n<p id=\"so_36273662_36273769_0\">The primary purpose of function-try-blocks is to log or modify, and\n  then rethrow the exceptions thrown from the member initializer list in\n  a constructor. They are rarely used with destructors or with regular\n  functions.</p>\n</blockquote>\n<p>This is really the primary value-added of function-try blocks: a convenient place to log \"hey, this function threw an exception\", that encompasses the entire function, a single place to log this kind of a thing, but without affecting ordinary exception handling.</p>\n", "LastActivityDate": "2016-03-29T01:11:37.850", "CommentCount": "0", "CreationDate": "2016-03-29T01:11:37.850", "ParentId": "36273662", "Score": "3", "OwnerUserId": "3943312"}, "36273662": {"ViewCount": "415", "Body": "<p><a href=\"http://ideone.com/UtVzxw\" rel=\"nofollow\">http://ideone.com/UtVzxw</a></p>\n<pre><code>struct base\n{\n    base() { throw std::exception(); }\n};\n\nstruct derived : public base\n{\n    derived() try : base()  { }\n\n    catch (std::exception&amp; e)\n    {\n        std::cout &lt;&lt; \"exception handled\" &lt;&lt; std::endl;\n    }\n};\n\nint main()\n{\n    derived a; // My app crashes.\n    return 0;\n}\n</code></pre>\n<p>Shoun't my app write \"exception handled\" and continue running?</p>\n<p>The only solution I've found is to surround the construction of \"<code>a</code>\" in a try/catch block. But If I do that, what's the point of having the try / catch in the constructor at the first place? I'm guessing maybe it's use is to clean up member variables that may have been allocated? since the <strong>destructor</strong> is not called?</p>\n<p>The following works, but handles the exception 2 times. </p>\n<pre><code>struct base\n{\n    base() { throw std::exception(); }\n};\n\nstruct derived : public base\n{\n    derived() try : base() { }\n\n    catch(std::exception&amp; e)\n    {\n      std::cout &lt;&lt; \"exception 1\" &lt;&lt; std::endl;\n    }\n};\n\nint main()\n{\n    // This works fine.\n    try {\n       derived a;\n    }\n    catch(std::exception&amp; e)\n    {\n      std::cout &lt;&lt; \"exception 2\" &lt;&lt; std::endl;\n    }\n    return 0;\n}\n</code></pre>\n<p>I'm just trying to ask myself why I shouldn't simply dodge the try / catch syntax for the constructor and write this:</p>\n<pre><code>struct base\n{\n    base() { throw std::exception(); }\n};\n\nstruct derived : public base\n{\n    derived() : base() { }\n};\n\nint main()\n{\n    // This works fine.\n    try {\n       derived a;\n    }\n    catch(std::exception&amp; e)\n    {\n      std::cout &lt;&lt; \"exception handled\" &lt;&lt; std::endl;\n    }\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "36273770", "Title": "Try catch syntax constructor", "CreationDate": "2016-03-29T00:57:52.083", "Id": "36273662", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-03-29T01:15:32.373", "LastEditorUserId": "6053907", "LastActivityDate": "2016-03-29T01:20:06.940", "Score": "6", "OwnerUserId": "6053907", "Tags": "<c++><exception>", "AnswerCount": "2"}});