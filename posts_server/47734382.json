post_cb({"47734522": {"Id": "47734522", "PostTypeId": "2", "Body": "<p>In overload resolution, direct reference binding is an <em>identity conversion</em> (even if qualifiers are added); it's no better or worse for a <code>double</code> to match a parameter of <code>double</code> or reference-to-<code>double</code>.</p>\n<p>The <code>const</code> is somewhat of a red herring in your examples. For a non-reference type, <code>f(const double)</code>, the top-level <code>const</code> is not part of the function signature; and in <code>f(const double&amp;)</code>,  it is still direct binding and so still the identity conversion.</p>\n<p>So, your first 2 cases are both identity conversions in both cases and no reason to prefer one or the other.</p>\n<p>In case 3, rule C++14 [over.ics.rank]/3.1.3 applies:</p>\n<blockquote>\n<p id=\"so_47734382_47734522_0\">Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence\n  S2 if</p>\n<ul>\n<li>[...]</li>\n<li>S1 and S2 are reference bindings (8.5.3) and neither refers to an implicit object parameter of a\n  non-static member function declared without a ref-qualifier, and S1 binds an rvalue reference to an rvalue and S2 binds an lvalue reference.</li>\n</ul>\n</blockquote>\n<p>This rule allows functions to be overloaded for rvalues and lvalues of the same type. </p>\n", "LastEditorUserId": "1505939", "LastActivityDate": "2017-12-10T00:11:59.447", "Score": "3", "CreationDate": "2017-12-10T00:04:28.750", "ParentId": "47734382", "CommentCount": "0", "OwnerUserId": "1505939", "LastEditDate": "2017-12-10T00:11:59.447"}, "47736813": {"Id": "47736813", "PostTypeId": "2", "Body": "<h2>Overload resolution table</h2>\n<p>This table summarizes who can go where:</p>\n<pre><code>    ---------------------------------------------------------------------------------\n               Caller    |   lvalue     | const lvalue |   rvalue     | const rvalue \n         Function        |              |              |              |  \n    ---------------------------------------------------------------------------------\n    [a]  f(X&amp; x)         |    V (1)     |              |              |\n    ---------------------------------------------------------------------------------\n    [b]  f(const X&amp; x)   |    V (2)     |      V       |    V (3)     |    V (2)\n    ---------------------------------------------------------------------------------\n    [c]  f(X&amp;&amp; x)        |              |              |    V (1)     |\n    ---------------------------------------------------------------------------------\n    [d]  f(const X&amp;&amp; x)  |              |              |    V (2)     |    V (1)\n    ---------------------------------------------------------------------------------\n</code></pre>\n<ul>\n<li>All the above signatures can live together. </li>\n<li>The <strong>V</strong> sign marks the possible valid resolutions</li>\n<li>When there is more than one valid resolution for the same caller they are numbered, (1) being a better match than (2) etc.</li>\n<li>There is no sense in overloading byval version with any of the above, unless having additional difference such as const on the method etc.\nAdding a byvalue version: f(X x) would not work well with any combination of the above - in most cases it would result with an <em>ambiguity</em> for any call, for some cases it would just prefer the byval version (if it lives only with [a] -  any call except lvalue would prefer the byvalue version and an lvalue call would result with an <em>ambiguity</em>).</li>\n<li>Signature [d] is rarely used, see: <a href=\"https://stackoverflow.com/questions/4938875/do-rvalue-references-to-const-have-any-use\">Do rvalue references to const have any use?</a></li>\n</ul>\n", "LastEditorUserId": "2085626", "LastActivityDate": "2017-12-10T09:29:03.027", "Score": "2", "CreationDate": "2017-12-10T07:33:33.050", "ParentId": "47734382", "CommentCount": "0", "OwnerUserId": "2085626", "LastEditDate": "2017-12-10T09:29:03.027"}, "47734382": {"ViewCount": "99", "Body": "<p>While studying C++ I have come across the complex topic of conversion sequences and I have encountered a problem that I couldn't solve on my own.     </p>\n<pre><code>void g(const double)\n{\n    std::cout &lt;&lt; \"void g(const double)\" &lt;&lt; std::endl;\n}\n\nvoid g(const double&amp;&amp;)\n{\n    std::cout &lt;&lt; \"void g(const double&amp;&amp;)\" &lt;&lt; std::endl;\n}\n\nint main(int argc, char **argv)\n{\n    g(3.14);    \n    return (0);\n}\n</code></pre>\n<p>---------------------------- Second example ----------------------------</p>\n<pre><code>void g(const double)\n{\n    std::cout &lt;&lt; \"void g(const double)\" &lt;&lt; std::endl;\n}\n\nvoid g(const double&amp;)\n{\n    std::cout &lt;&lt; \"void g(const double&amp;)\" &lt;&lt; std::endl;\n}\n\nint main(int argc, char **argv)\n{\n    g(3.14);    \n    return (0);\n}\n</code></pre>\n<p>In this two examples the compiler complains about the fact that the call of the overloaded function \"g(double)\" is ambiguous.</p>\n<pre><code>void g(const double&amp;&amp;)\n{\n    std::cout &lt;&lt; \"void g(const double&amp;&amp;)\" &lt;&lt; std::endl;\n}\n\nvoid g(const double&amp;)\n{\n    std::cout &lt;&lt; \"void g(const double&amp;)\" &lt;&lt; std::endl;\n}\n\nint main(int argc, char **argv)\n{\n    g(3.14);    \n    return (0);\n}\n</code></pre>\n<p>But in this example the program compiles properly and prints out \"void g(const double&amp;&amp;)\".\nSo I don't get why the compiler complains about the first two examples but doesn't about the third.</p>\n", "Title": "C++ - How does the compiler decide between overloaded functions with reference types as parameter?", "CreationDate": "2017-12-09T23:38:24.007", "LastActivityDate": "2017-12-10T09:29:03.027", "CommentCount": "5", "PostTypeId": "1", "Id": "47734382", "Score": "2", "OwnerUserId": "6542975", "Tags": "<c++><c++11><implicit-conversion><function-overloading>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_47734382_47734522_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 603}}, "n3337": {"so_47734382_47734522_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 593}}, "n4659": {"so_47734382_47734522_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 629}}}});