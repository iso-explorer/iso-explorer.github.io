post_cb({"34522064": {"LastActivityDate": "2015-12-30T02:18:49.197", "CommentCount": "3", "Body": "<p>Sometimes, one has to acknowledge that C++ by itself will not solve all of the world's problems.</p>\n<p>Sometimes, it becomes necessary to integrate additional tools and scripts into one's build system. I think this is one of those cases.</p>\n<p>But first, let's use just C++ to solve as much of this problem as possible. And we'll use the <a href=\"https://stackoverflow.com/questions/4173254/what-is-the-curiously-recurring-template-pattern-crtpp://\">Curiously Recursive Template Pattern</a>:</p>\n<pre><code>template&lt;typename C&gt; class UID {\n\npublic:\n\n    static const int id;\n};\n</code></pre>\n<p>Then, each class that requests a unique ID would then inherit from this template, accordingly, resulting in a member called <code>id</code>:</p>\n<pre><code>class Widget : public UID&lt;Widget&gt; {\n\n// ...\n\n};\n</code></pre>\n<p>So, <code>Widget::id</code> becomes the class's unique ID.</p>\n<p>Now, all that we need to do is to figure out how to declare all classes' <code>id</code> values. And, at this point we reach the limits of what C++ can do by itself, and we must call in some reinforcements.</p>\n<p>We'll begin by creating a file that lists all classes that have an assigned ID. This is nothing complicated, just a simple file named, say, <code>classlist</code>, whose contents would simply be something like this.</p>\n<pre><code>Button\nField\nWidget\n</code></pre>\n<p>(Button, Field, and Widget, are other classes than inherit from the UID class).</p>\n<p>Now, it becomes a simple two step process:</p>\n<p>1) A simple shell, or a Perl script, that reads the <code>classlist</code> file, and spews out robo-generated code of the form (given the above input):</p>\n<pre><code>const int UID&lt;Button&gt;::id=0;\nconst int UID&lt;Field&gt;::id=1;\nconst int UID&lt;Widget&gt;::id=2;\n</code></pre>\n<p>... and so on.</p>\n<p>2) The appropriate tweaks to your build script or <code>Makefile</code>, to compile this robo-generated code (with all the necessary <code>#include</code>, etc..., to make this happen), and link it with your application. So, a class that wants an ID assigned to it must explicitly inherit from the <code>UID</code> class, and its name added to a file. The build script/Makefile then automatically runs a script that generates a new uid list, and compiles it, during the next build cycle.</p>\n<p>(Hopefully, you <strong>are</strong> using a real C++ development environment, that provides you with flexible development tools, instead of being forced to suffer some inflexible visual-IDE type limited development environment, with limited functionality).</p>\n<p>This is just a starting point. With a little bit more work, it should be possible to take this basic approach, and enhance it to auto-generate <code>constexpr</code> uids, which would be even better. This will require cracking a few tough nuts, such as trying to avoid triggering a recompile of the entire app, when the list of UID-using classes changes. But, I think this is a solvable problem, too...</p>\n<p>Postscriptum:</p>\n<p>It might still be possible to pull this off using only C++, by leveraging compiler-specific extensions. For example, using <a href=\"https://gcc.gnu.org/onlinedocs/cpp/Common-Predefined-Macros.html\" rel=\"nofollow noreferrer\">gcc's __COUNTER__ macro</a>.</p>\n", "CreationDate": "2015-12-30T02:18:49.197", "LastEditDate": "2017-05-23T11:44:52.287", "ParentId": "34520851", "Id": "34522064", "LastEditorUserId": "-1", "PostTypeId": "2", "Score": "1", "OwnerUserId": "3943312"}, "34551358": {"LastActivityDate": "2015-12-31T20:28:52.367", "CommentCount": "0", "Body": "<p>This is a very interesting question because it's related to not just implementing a counter at compile-time in C++, it's also about associating (static) counter values with types at compile-time.</p>\n<p>So I researched for a bit and came across a very interesting blog post\n<a href=\"http://b.atch.se/posts/constexpr-counter/\" rel=\"nofollow noreferrer\">How to implement a constant expression counter in C++</a> by <a href=\"https://stackoverflow.com/users/1090079/filip-ros%C3%A9en-refp\">Filip Ros\u00e9en</a></p>\n<p>His implementation of a counter really stretches the limits of ADL and SFINAE to work:</p>\n<pre><code>template&lt;int N&gt;\nstruct flag {\n  friend constexpr int adl_flag (flag&lt;N&gt;);\n};\ntemplate&lt;int N&gt;\nstruct writer {\n  friend constexpr int adl_flag (flag&lt;N&gt;) {\n    return N;\n  }\n\n  static constexpr int value = N;\n};\ntemplate&lt;int N, int = adl_flag (flag&lt;N&gt; {})&gt;\nint constexpr reader (int, flag&lt;N&gt;) {\n  return N;\n}\n\ntemplate&lt;int N&gt;\nint constexpr reader (float, flag&lt;N&gt;, int R = reader (0, flag&lt;N-1&gt; {})) {\n  return R;\n}\n\nint constexpr reader (float, flag&lt;0&gt;) {\n  return 0;\n}\ntemplate&lt;int N = 1&gt;\nint constexpr next (int R = writer&lt;reader (0, flag&lt;32&gt; {}) + N&gt;::value) {\n  return R;\n}\nint main () {\n  constexpr int a = next ();\n  constexpr int b = next ();\n  constexpr int c = next ();\n\n  static_assert (a == 1 &amp;&amp; b == a+1 &amp;&amp; c == b+1, \"try again\");\n}\n</code></pre>\n<p>Essentially it relies on ADL failing to find an appropriate definition of a <code>friend</code> function, resulting in SFINAE, and recursing with templates until either an exact match or ADL succeeds. The blog post does a fairly good job of explaining what's going on.</p>\n<h3>Limitations</h3>\n<p>(lifted from the article)</p>\n<ul>\n<li>You cannot use the same counter across translation units else you may violate ODR.</li>\n<li>Be careful with some comparison operators between constexpr generated values; despite the order of your calls there are sometimes no guarantees on the relative time the compiler will instantiate them. (could we do anything about this with <code>std::atomic</code>?)\n\n<ul>\n<li>This means <code>a &lt; b</code> is not guaranteed to be true if evaluated at compile-time, even though it will be by run time.</li>\n</ul></li>\n<li>Order of template argument substitution; may result in inconsistent behavior across C++11 compilers; fixed in C++14</li>\n<li>MSVC support: Even the compiler that ships with Visual Studio 2015 still doesn't have full support for expression SFINAE. Workarounds available in the blog post.</li>\n</ul>\n<hr>\n<h2>Turning the counter into a type-associated UUID</h2>\n<p>Turns out it was really pretty simple to change:</p>\n<pre><code>template&lt;int N = 1, int C = reader (0, flag&lt;32&gt; ())&gt;\nint constexpr next (int R = writer&lt;C + N&gt;::value) {\n  return R;\n}\n</code></pre>\n<p>into</p>\n<pre><code>template&lt;typename T, int N = 1&gt;\nstruct Generator{\n static constexpr int next = writer&lt;reader (0, flag&lt;32&gt; {}) + N&gt;::value; // 32 implies maximum UUID of 32\n};\n</code></pre>\n<p>Given that <code>const static int</code> is one of the few types you can declare and define\nin the same spot [9.4.2.3]:</p>\n<blockquote>\n<p id=\"so_34520851_34551358_0\">A static data member of literal type can be declared in the\n  class definition with the constexpr specifier; if so, its declaration shall\n  specify a brace-or-equal-initializer\n  in which every initializer-clause that is an assignment-expression is a constant\n  expression. [ Note: In both\n  these cases, the member may appear in constant expressions. \u2014 end note ] </p>\n</blockquote>\n<p>So now we can write code like this:</p>\n<pre><code>constexpr int a = Generator&lt;int&gt;::next;\nconstexpr int b = Generator&lt;int&gt;::next;\nconstexpr int c = Generator&lt;char&gt;::next;\n\nstatic_assert(a == 1, \"try again\");\nstatic_assert(b == 1, \"try again\");\nstatic_assert(c == 2, \"try again\");\n</code></pre>\n<p>Notice how <code>int</code> remains <code>1</code> while <code>char</code> increments the\ncounter to <code>2</code>.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/2925ed186128c2c7\" rel=\"nofollow noreferrer\">Live\nDemo</a></p>\n<p>This code suffers from all the same drawbacks as before\n(and probably more I haven't though of)</p>\n<h3>Note</h3>\n<p>There will be a great number of compiler warnings with this code, due to the fact of so many declarations of <code>friend constexpr int adl_flag(flag&lt;N&gt;)</code> for the each integer value; one for every unused counter value in fact.</p>\n</hr>", "CreationDate": "2015-12-31T20:28:52.367", "LastEditDate": "2017-05-23T11:44:52.287", "ParentId": "34520851", "Id": "34551358", "LastEditorUserId": "-1", "PostTypeId": "2", "Score": "1", "OwnerUserId": "27678"}, "34520851": {"CreationDate": "2015-12-29T23:40:03.803", "ViewCount": "147", "FavoriteCount": "1", "Id": "34520851", "AcceptedAnswerId": "34551358", "Score": "3", "Title": "How can classes be enumerated, ordered, etc. at compile time?", "LastEditorUserId": "560648", "CommentCount": "6", "Body": "<p>I'm struggling with some of the rules of what can be pushed into compile time calculations. Here I've written code that associates a unique ID with each class that requests one (and a demangled name for testing purposes.) However, this unique ID can't be used as a template argument or a part of a static_assert condition, because it isn't a constexpr.</p>\n<pre><code>#include &lt;cassert&gt;\n#include &lt;cxxabi.h&gt;\n#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nnamespace UID {\n    static int nextID(void) {\n        static int stored = 0;\n        return stored++;\n    }\n    template&lt;class C&gt;\n    static int getID(void) {\n        static int once = nextID();\n        return once;\n    }\n    template&lt;class C&gt;\n    static const char *getName(void) {\n        static int status = -4;\n        static const char *output =\n            abi::__cxa_demangle(typeid(C).name(), 0, 0, &amp;status);\n        return output;\n    }\n}\n\nnamespace Print {\n    template&lt;class C&gt;\n    std::ostream&amp; all(std::ostream&amp; out) {\n        return out &lt;&lt; \"[\" &lt;&lt; UID::getID&lt;C&gt;() &lt;&lt; \"] = \"\n            &lt;&lt; UID::getName&lt;C&gt;() &lt;&lt; std::endl;\n    }\n    template&lt;class C0, class C1, class... C_N&gt;\n        std::ostream&amp; all(std::ostream&amp; out) {\n        return all&lt;C1, C_N&gt;(all&lt;C0&gt;(out));\n    }\n}\n\nvoid test(void) {\n    Print::all&lt;int, char, const char*&gt;(std::cout) &lt;&lt; std::endl;\n    // [0] = int\n    // [1] = char\n    // [2] = char const*\n    Print::all&lt;char, int, const char*&gt;(std::cout);\n    // [1] = char\n    // [0] = int\n    // [2] = char const*\n}\n</code></pre>\n<p>If it isn't clear, I'd like to change other compile-time behavior based on the ID. I've seen several approaches that involved a linked list of types, so that the ID is the sum of a previously assigned constexpr ID and a constexpr offset. However, I don't see how this is an improvement over manually assigning ID's. If you were to sort one list of classes by their ID's, then wrap each of the classes and request ID's for the wrappers, the ID's would depend on the sorting; then to determine the \"last\" element, you would have to either sort the elements manually! What am I missing? </p>\n", "Tags": "<c++><template-meta-programming><compile-time>", "LastEditDate": "2015-12-29T23:56:39.167", "LastActivityDate": "2015-12-31T20:28:52.367", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "1043529"}, "bq_ids": {"n4140": {"so_34520851_34551358_0": {"length": 27, "quality": 0.9, "section_id": 5908}}, "n3337": {"so_34520851_34551358_0": {"length": 27, "quality": 0.9, "section_id": 5680}}}});