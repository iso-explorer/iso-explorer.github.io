post_cb({"bq_ids": {"n4140": {"so_48126305_48126411_0": {"length": 12, "quality": 0.5454545454545454, "section_id": 7043}}, "n3337": {"so_48126305_48126411_0": {"length": 12, "quality": 0.5454545454545454, "section_id": 6788}}, "n4659": {"so_48126305_48126411_0": {"length": 12, "quality": 0.5454545454545454, "section_id": 8540}}}, "48126411": {"Id": "48126411", "PostTypeId": "2", "Body": "<p>By default, the GCC compiler enables a C <em>extension</em> (even when <code>-pedantic</code> flag is in effect), which allows multiple external definitions of objects across <a href=\"https://en.wikipedia.org/wiki/Translation_unit_(programming)\" rel=\"nofollow noreferrer\">translation units</a>.</p>\n<p>Referring to C11 (N1570) J.5.11 <em>Multiple external definitions</em> (informative section):</p>\n<blockquote>\n<p id=\"so_48126305_48126411_0\">There may be more than one external definition for the identifier of\n  an object, with or without the explicit use of the keyword <code>extern</code>; if\n  the definitions disagree, or more than one is initialized, the\n  behavior is undefined (6.9.2).</p>\n</blockquote>\n<p>Note that an application, that relies on this behavior is not strictly conformant with the ISO C language. More specifically, C11 6.9/p5 <em>External definitions</em> states (emphasis mine):</p>\n<blockquote>\n<p id=\"so_48126305_48126411_1\">An <em>external definition</em> is an external declaration that is also a\n  definition of a function (other than an inline definition) or an\n  object. If an identifier declared with external linkage is used in an\n  expression (other than as part of the operand of a <code>sizeof</code> or <code>_Alignof</code>\n  operator whose result is an integer constant), somewhere in the entire\n  program <strong>there shall be exactly one external definition for the\n  identifier; otherwise, there shall be no more than one</strong>.<sup>161)</sup></p>\n</blockquote>\n<p>Technically, a violation of that rule invokes an <a href=\"https://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow noreferrer\">undefined behavior</a>, which means that an implementation may or may not issue an diagnostic message.</p>\n<p>You may inspect, that this extension has been enabled by <code>nm</code> command:</p>\n<pre><code>nm test.o \n0000000000000000 T foo\n0000000000000004 C _TestEnum\n</code></pre>\n<p>According to <code>man nm</code>:</p>\n<blockquote>\n<p id=\"so_48126305_48126411_2\">\"C\" The symbol is common.  Common symbols are uninitialized data. \n  When linking,  multiple common symbols may appear with the same name. \n  If the symbol is defined anywhere, the common symbols are treated as\n  undefined references.</p>\n</blockquote>\n<p>In order to disable this extension, you may use <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Code-Gen-Options.html#index-fno-common\" rel=\"nofollow noreferrer\"><code>-fno-common</code></a> flag. From GCC documentation:</p>\n<blockquote>\n<p id=\"so_48126305_48126411_3\">Unix C compilers have traditionally allocated storage for\n  uninitialized global variables in a common block. This allows the\n  linker to resolve all tentative definitions of the same variable in\n  different compilation units to the same object, or to a non-tentative\n  definition. This is the behavior specified by <code>-fcommon</code>, and is the\n  default for GCC on most targets.</p>\n</blockquote>\n", "LastEditorUserId": "586873", "LastActivityDate": "2018-01-06T16:18:53.760", "Score": "11", "CreationDate": "2018-01-06T10:25:11.930", "ParentId": "48126305", "CommentCount": "5", "OwnerUserId": "586873", "LastEditDate": "2018-01-06T16:18:53.760"}, "48126305": {"ViewCount": "445", "Body": "<p>I came across the following construct in a C project that I port to C++;</p>\n<pre><code>enum TestEnum \n{\n    A=303,\n    B=808\n} _TestEnum;\n\nint foo()\n{\n  _TestEnum = B;\n}\n</code></pre>\n<p>When compiling with GCC and taking a look at the generated code I get:</p>\n<pre><code>nils@doofnase ~ $ gcc -std=c90 -O2 -c ./test.c -o test.o\nnils@doofnase ~ $ size test.o\n   text    data     bss     dec     hex filename\n     59       0       0      59      3b test.o\n</code></pre>\n<p>So zero bytes of data or BSS segments used.</p>\n<p>On the other hand if I compile in C++ I get:</p>\n<pre><code>nils@doofnase ~ $ g++ -std=c++11 -O2 -c ./test.c -o test.o\nnils@doofnase ~ $ size test.o\n   text    data     bss     dec     hex filename\n     59       0       4      63      3f test.o\n</code></pre>\n<p>I see four byte storage allocated in BSS as I would expect.</p>\n<p>Also, in the C project the enum definition is actually located in a header-file which gets included in multiple c files. The project compiles and links just fine. When compiled and linked as C++ the compiler complains that _TestEnum is defined in multiple objects (right so!).</p>\n<p>What is going on here? Am I looking at some archaic C language special case?</p>\n<p>Edit: For completes sake, this is the gcc version:</p>\n<pre><code>nils@doofnase ~ $ gcc --version\ngcc (Ubuntu 5.4.0-6ubuntu1~16.04.5) 5.4.0 20160609\n</code></pre>\n", "AcceptedAnswerId": "48126411", "Title": "Enum storage differences in C vs. C++", "CreationDate": "2018-01-06T10:09:36.357", "Id": "48126305", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2018-01-06T16:18:53.760", "Score": "9", "OwnerUserId": "15955", "Tags": "<c++><c><enums>", "AnswerCount": "1"}});