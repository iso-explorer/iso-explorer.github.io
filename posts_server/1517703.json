post_cb({"1518937": {"ParentId": "1517703", "CommentCount": "1", "Body": "<p>Short explanation: functions that return by value create a temporary object which is treated as constant and therefore cannot be passed to functions accepting by reference, it can only be passed to functions accepting const reference. If you really allocate an object in get_a(), you should really be returning a pointer (so that you remember to delete it, hopefully) or in the worst case - a reference. If you really want to return a copy - create the object on the stack. </p>\n<p>Long explanation: To understand why your code doesn't compile if there is only \"non-const copy constructor\"<sup>1</sup>, you need to be familiar with the terms <em>lvalue</em> and <em>rvalue</em>. They originally meant that <em>rvalue</em>s can <strong>only</strong> stand on the right side of operator = (assignment) while <em>lvalue</em>s can stand also on the left side. Example:</p>\n<pre><code>T a, b;\nconst T ac;\na = b; // a can appear on the left of = \nb = a; // so can b =&gt; a and b are lvalues in this context\nac = a; // however, ac is const so assignment doesn't make sense&lt;sup&gt;2&lt;/sup&gt;, ac is a rvalue\n</code></pre>\n<p>When the compiler is performing overload resolution (finding which overload of a function/method best match the provided arguments) it will allow <em>lvalue</em>s to match parameters passed by value<sup>3</sup>, reference and const reference types. However, it will match <em>rvalue</em>s only against value<sup>3</sup> and const reference parameters. And that's because in some sense, since <em>rvalue</em>s cannot be put on the left side of operator =, they have read-only semantic, and when it shouldn't be allowed to modify them. And when you accept a parameter through non-const reference, it's implied that you'll somehow change this parameter.</p>\n<p>The last piece of the puzzle: temporary objects are <em>rvalue</em>s. Function returning by value creates a temporary object with very limited lifespan. Because of its limited lifespan it's considered const, and is therefore a <em>rvalue</em>. And this <em>rvalue</em> doesn't match functions with parameters by non-const reference. Examples:</p>\n<pre><code>void f_cref(const A&amp; a) { std::cout &lt;&lt; \"const ref\" &lt;&lt; std::endl; }\nvoid f_ref(A&amp; a) { std::cout &lt;&lt; \"non-const ref\" &lt;&lt; std::endl; }\n\nA geta() { return A(); }\n\nA a;\nconst A ac;\nf_ref(a); // ok, a is a lvalue\nf_ref(ac); // error, passing const to non-const - rvalue as lvalue - it's easy to spot here\nf_cref(a); // ok, you can always pass non-const to const (lvalues to rvalues)\nf_ref(geta()); // error, passing temporary and therefore const object as reference\nf_cref(geta()); // ok, temporary as const reference\n</code></pre>\n<p>Now you have all the information to figure out why your code doesn't compile. Copy constructor are like regular functions.</p>\n<p>I have oversimplified things a bit, so better, more complete and correct explanation can be found at this excellent <a href=\"http://blogs.msdn.com/vcblog/archive/2009/02/03/rvalue-references-c-0x-features-in-vc10-part-2.aspx\" rel=\"nofollow noreferrer\">Visual C++ Studio Team blog post about rvalue references</a>, which also addresses the new C++ 0x feature \"rvalue references\"</p>\n<p><sup>1</sup> - there's no such thing as non-const copy constructor. The copy constructor accepts const reference, period.</p>\n<p><sup>2</sup> - you can probably put const object on the left of = if it has its operator = declared const. But that would be terrible, terrible, nonsensical thing to do. </p>\n<p><sup>3</sup> - actually, you wouldn't be able to pass const A by value if A doesn't have a copy constructor - one that accepts const A&amp; that is. </p>\n", "OwnerUserId": "169828", "PostTypeId": "2", "Id": "1518937", "Score": "1", "CreationDate": "2009-10-05T09:02:20.257", "LastActivityDate": "2009-10-05T09:02:20.257"}, "1518278": {"ParentId": "1517703", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>I've done some extra reading into this, and as I suspected all along, the reason why this occurs is due to return value optimization. As the <a href=\"http://en.wikipedia.org/wiki/Return_value_optimization\" rel=\"nofollow noreferrer\">Wikipedia article</a> explains, RVO is the allowed mechanism by which compilers are allowed to eliminate temporary objects in the process of assigning them or copying them into permanent variables. Additionally, RVO is one of the few features (if not the only) which are allowed to violate the <em>as-if</em> rule, whereby compilers are only allowed to make optimizations only if they have the same observable behaviours <em>as if</em> the optimization were never made in the first place -- an exemption which is key in explaining the behaviour here (I admittedly only learned of that exemption as I was researching this question, which is why I was also confused initially). </p>\n<p>In your case, GCC is smart enough to avoid one of the two copies. To boil your code down to a simpler example</p>\n<pre><code>B returnB()\n{\n    B a;\n    B* b = &amp;a;\n    return *b;\n}\n\nint main()\n{\n    B c = returnB();\n    return 0;\n}\n</code></pre>\n<p>If one follows the standard and does not perform RVO, two copies are made in the process of making <code>c</code> -- the copy of <code>*b</code> into <code>returnB</code>'s return value, and the copy of the return value into <code>c</code> itself. In your case, GCC omits the first copy and instead makes only one copy, from <code>*b</code> directly into <code>c</code>. That also explains why <code>B(B&amp;)</code> is called instead of <code>B(const B&amp;)</code> -- since <code>*b</code> (a.k.a. <code>a</code>) is not a temporary value, the compiler doesn't need to use <code>B(const B&amp;)</code> anymore and instead chooses the simpler <code>B(B&amp;)</code> call instead when constructing <code>c</code> (a non-<code>const</code> overload is always automatically preferred over a <code>const</code> overload if the choice exists).</p>\n<p>So why does the compiler still give an error if <code>B(const B&amp;)</code> isn't there? That's because your code's syntax must be correct before optimizations (like RVO) can be made. In the above example, <code>returnB()</code> <em>is</em> returning a temporary (according to the C++ syntax rules), so the compiler must see a <code>B(const B&amp;)</code> copy constructor. However, once your code is confirmed to be grammatically correct by the compiler, it then can make the optimization such that <code>B(const B&amp;)</code> is never used anyway. </p>\n<p><strong>EDIT</strong>: Hat tip to Charles Bailey who found the following in the C++ standard</p>\n<blockquote>\n<p id=\"so_1517703_1518278_0\">12.2 [class.temporary]: \"Even when the creation of the temporary is avoided,\n  all the semantic restrictions must be\n  respected as if the temporary object\n  was created.\"</p>\n</blockquote>\n<p>which just reinforces and confirms the need for a copy constructor taking a reference to const when temporaries are to be copied for construction (irrespective of whether or not the constructor is actually used)</p>\n", "OwnerUserId": "157098", "LastEditorUserId": "157098", "LastEditDate": "2009-10-05T07:14:27.187", "Id": "1518278", "Score": "7", "CreationDate": "2009-10-05T04:37:17.473", "LastActivityDate": "2009-10-05T07:14:27.187"}, "1518656": {"ParentId": "1517703", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The line <code>B b1 = b0;</code> is the culprit.  This line requires calling a copy constructor.  You could fix the code by writing <code>B b1(b0)</code> instead, or by defining a copy constructor, which takes a <code>const B&amp;</code>, but not a <code>B&amp;</code>.</p>\n", "OwnerUserId": "10593", "LastEditorUserId": "10593", "LastEditDate": "2009-10-05T23:27:44.733", "Id": "1518656", "Score": "1", "CreationDate": "2009-10-05T07:22:12.020", "LastActivityDate": "2009-10-05T23:27:44.733"}, "1517703": {"CommentCount": "2", "ViewCount": "1564", "PostTypeId": "1", "LastEditorUserId": "15168", "CreationDate": "2009-10-04T23:23:24.697", "LastActivityDate": "2009-10-05T23:27:44.733", "Title": "C++ copy constructor causing code not to compile ( gcc )", "FavoriteCount": "2", "LastEditDate": "2009-10-05T05:36:16.073", "Id": "1517703", "Score": "2", "Body": "<p>I have the following code which doesn't compile. The compiler error is:</p>\n<pre><code>\"error: no matching function to call B::B(B)\",\ncandidates are B::B(B&amp;) B::B(int)\"\n</code></pre>\n<p>The code compiles under either of the following two conditions:</p>\n<ol>\n<li>Uncommenting the function B(const B&amp;)</li>\n<li><p>change 'main' to the following</p>\n<pre><code>int main()\n{\n        A a;\n        B b0;\n        B b1 = b0;\n        return 0;\n}\n</code></pre></li>\n</ol>\n<p>If I do 1, the code compiles, but from the output it says it's calling the 'non const copy constructor'.</p>\n<p>Can anyone tell me what's going on here?</p>\n<pre><code>using namespace std;\nclass B\n{\n    public:\n    int k;\n     B()\n     { \n        cout&lt;&lt;\"B()\"&lt;&lt;endl; \n     }\n     B(int k) \n     { \n        cout&lt;&lt;\"B(int)\"&lt;&lt;endl;\n        this-&gt;k = k;\n     }\n     /*B(const B&amp; rhs) { \n        cout&lt;&lt;\"Copy constructor\"&lt;&lt;endl;\n        k = rhs.k;\n     }*/\n     B(B&amp; rhs) \n     { \n        cout&lt;&lt;\"non const Copy constructor\"&lt;&lt;endl;\n        k = rhs.k;\n     }\n     B operator=(B&amp; rhs)\n     {\n        cout&lt;&lt;\"assign operator\"&lt;&lt;endl;\n        k = rhs.k;\n        return *this;\n     }  \n};\n\nclass A\n{\n    public:\n        B get_a(void)\n        {\n            B* a = new B(10);\n            return *a;\n        }       \n};\n\nint main()\n{\n    A a;\n    B b0 = a.get_a();  // was a.just();\n    B b1 = b0 ;\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><constructor><reference><copy><const>", "OwnerUserId": "184083", "AnswerCount": "4"}, "1517710": {"ParentId": "1517703", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>Your <code>get_a()</code> function returns an object <code>B</code>, not a reference (but leaks the newly-created <code>B</code> object).  Also, for assignments to work as you're doing, you need to make sure your assignment operator and copy constructors are both taking <code>const B&amp;</code> arguments \u2014 then <code>B b1 = b0</code> will work in this case.  This works:</p>\n<pre><code>class B\n{\npublic:\n  int k;\n  B() { cout&lt;&lt;\"B()\"&lt;&lt;endl; }\n  B(int k) { \n    cout&lt;&lt;\"B(int)\"&lt;&lt;endl;\n    this-&gt;k = k;\n  }\n  B(const B&amp; rhs) { \n    cout&lt;&lt;\"non const Copy constructor\"&lt;&lt;endl;\n    k = rhs.k;\n  }\n  B operator=(const B&amp; rhs) {\n    cout&lt;&lt;\"assign operator\"&lt;&lt;endl;\n    k = rhs.k;\n    return *this;\n  }\n};\n\nclass A {\npublic:\n  B* get_a(void) {\n    B* a = new B(10);\n    return a;\n  }\n  B get_a2(void) {\n    B a(10);\n    return a;\n  }\n};\n\nint main() {\n  A a;\n  B b0 = *a.get_a(); // bad: result from get_a() never freed!\n  B b1 = a.get_a2(); // this works too\n  return 0;\n}\n</code></pre>\n", "OwnerUserId": "112380", "LastEditorUserId": "112380", "LastEditDate": "2009-10-04T23:40:42.683", "Id": "1517710", "Score": "3", "CreationDate": "2009-10-04T23:27:58.607", "LastActivityDate": "2009-10-04T23:40:42.683"}, "bq_ids": {"n4140": {"so_1517703_1518278_0": {"section_id": 378, "quality": 0.75, "length": 12}}, "n3337": {"so_1517703_1518278_0": {"section_id": 369, "quality": 0.75, "length": 12}}, "n4659": {"so_1517703_1518278_0": {"section_id": 392, "quality": 0.6875, "length": 11}}}});