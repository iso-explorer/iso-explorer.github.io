post_cb({"33569726": {"Id": "33569726", "PostTypeId": "2", "Body": "<p>This is not possible if you want to remain fully portable.</p>\n<p>The range of <code>unsigned int</code> is only specified to at least cover the non-negative values of <code>int</code>. The standard allows for implementations where <code>UINT_MAX == INT_MAX</code>. The same applies to all other non-fixed-width integer types.</p>\n<p>Given that the range of <code>unsigned int</code> may be smaller than that of <code>int</code>, the pigeonhole principle applies: you have no way of redistributing all values of <code>int</code> to corresponding but different values of <code>unsigned int</code> unless <code>unsigned int</code> can store at least as many different values as <code>int</code>.</p>\n<hr>\n<p>To quote N4140 (roughly C++14):</p>\n<blockquote>\n<p id=\"so_33569303_33569726_0\"><strong>3.9.1 Fundamental types [basic.fundamental]</strong></p>\n<p id=\"so_33569303_33569726_1\">1 [...] For narrow character types, all bits of the object representation participate in the value representation. For unsigned narrow character types, all possible bit patterns of the value representation represent numbers. These requirements do not hold for other types. [...]</p>\n<p id=\"so_33569303_33569726_2\">3 For each of the standard signed integer types, there exists a corresponding (but different) <em>standard unsigned integer type</em>: \"<code>unsigned char</code>\", \"<code>unsigned short int</code>\", \"<code>unsigned int</code>\", \"<code>unsigned long int</code>\", and \"<code>unsigned long long int</code>\", each of which occupies the same amount of storage and has the same alignment requirements (3.11) as the corresponding signed integer type<sup>47</sup>; that is, each signed integer type\n  has the same object representation as its corresponding unsigned integer type. [...] The range of non-negative values of a <em>signed integer</em> type is a\n  subrange of the corresponding <em>unsigned integer</em> type, and the value representation of each corresponding signed/unsigned type shall be the same. [...]</p>\n</blockquote>\n<p>This guarantees that you don't have a problem for <code>unsigned char</code>. There is no possibility for <code>unsigned char</code> to have any kind of padding bits. It wouldn't make sense for <code>unsigned char</code> to have padding bits: given <code>unsigned char c;</code>, how would you access those padding bits? <code>reinterpret_cast&lt;unsigned char &amp;&gt;(c)</code>? That obviously just gives you <code>c</code>. The only thing similar to padding bits that is possible for <code>unsigned char</code> is something that's completely transparent to the program, for instance when ECC memory is used.</p>\n<p>For all the other non-fixed-width integer type, from <code>short</code> to <code>long long</code>, the standard meaning of \"subrange\" allows for an equal range.</p>\n<p>I think I vaguely recall reading that there may have been ancient CPUs that did not provide any native unsigned operations. This would make it very tricky for implementations to properly implement unsigned division, unless they declared that the would-be-sign-bit of unsigned types would be treated as a padding bit. This way, they could simply use the CPU's signed division instruction for either signed or unsigned types.</p>\n</hr>", "LastEditorUserId": "743382", "LastActivityDate": "2015-11-06T18:47:06.220", "Score": "13", "CreationDate": "2015-11-06T15:06:00.647", "ParentId": "33569303", "CommentCount": "7", "OwnerUserId": "743382", "LastEditDate": "2015-11-06T18:47:06.220"}, "33569628": {"Id": "33569628", "PostTypeId": "2", "Body": "<p>You are doing it wrong, because flipping the sign-bit of a signed value isn't actually defined.</p>\n<p>Let's use two-bit types:</p>\n<pre><code>          00    01 10  11  Order for unsigned               0     1  2  3\n10  11    00    01         Order for 2s complement -2 -1    0     1\n    11 (10  00) 01         Order for sign-magnitude   -1 (-0 +0)  1\n    10 (11  00) 01         Order for 1s-complement    -1 (-0 +0)  1\n</code></pre>\n<p>What you want to do is convert to unsigned (Which is always defined as value-preserving, with wrap-around), and then add a bias so the most-negative number becomes 0:</p>\n<pre><code>int x = whatever;\nunsigned r = (unsigned)x - (unsigned)INT_MIN;\n</code></pre>\n<p>Take care: Signed overflow is not defined, so we avoided signed types.</p>\n<p>Of course, it doesn't help if the unsigned type has fewer values than the signed one, which <em>is</em> allowed in general, though not for <code>char</code>.<br>\nAnd you need to take special care if you want to preserve a negative 0 as negative.</br></p>\n", "LastEditorUserId": "3204551", "LastActivityDate": "2015-11-06T20:31:52.080", "Score": "19", "CreationDate": "2015-11-06T15:00:19.860", "ParentId": "33569303", "CommentCount": "0", "OwnerUserId": "3204551", "LastEditDate": "2015-11-06T20:31:52.080"}, "33569303": {"ViewCount": "938", "Body": "<p>I have a use case where I need to convert signed values to unsigned, to make values sortable.  I need this for <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, and <code>long long</code></p>\n<p>By sortable, I mean that for <code>signed</code> type X, if <code>(a &lt; b)</code> then converting to unsigned the <code>converted(a) &lt; converted(b)</code>.   Note that in many cases, converting from a negative <code>signed</code> value directly to a <code>unsigned</code> value will make the value greater than <code>0</code> and breaks this constraint (<em>two's complement implementations</em>)</p>\n<p>The simplest idea for a <code>char</code> is:</p>\n<pre><code>unsigned char convert(char x)\n{\n       return (unsigned char)(x ^ 0x80);  // flip sign to make it sortable\n}\n</code></pre>\n<p>But this seems to be <code>undefined behavior</code>.</p>\n<p>While it might be possible to convert to a larger type, add the types MIN value, and convert to the <code>unsigned</code> type, I'm not sure this is any more compliant, and won't work with <code>long long</code></p>\n<p>How can this be done without any <code>undefined behavior</code> for all types?</p>\n<p>It seems safe to convert using <code>memcpy</code>, but it's not clear how to maintain sort order in a compliant way.</p>\n<p>(Note that this is similar to: <a href=\"https://stackoverflow.com/questions/9467475/no-compliant-way-to-convert-signed-unsigned-of-same-size\">No compliant way to convert signed/unsigned of same size</a> except I need the results to be maintain sort order)</p>\n", "AcceptedAnswerId": "33569726", "Title": "What is the standard compliant way to convert a signed integral value to a sortable, unsigned in C++?", "CreationDate": "2015-11-06T14:43:03.687", "Id": "33569303", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:15:11.363", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-06T21:58:32.247", "Score": "22", "OwnerUserId": "2963099", "Tags": "<c++><casting><language-lawyer>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_33569303_33569726_2": {"length": 67, "quality": 0.9436619718309859, "section_id": 7212}, "so_33569303_33569726_1": {"length": 26, "quality": 0.896551724137931, "section_id": 7210}}, "n3337": {"so_33569303_33569726_2": {"length": 67, "quality": 0.9436619718309859, "section_id": 6956}, "so_33569303_33569726_1": {"length": 24, "quality": 0.8275862068965517, "section_id": 6954}}, "n4659": {"so_33569303_33569726_2": {"length": 67, "quality": 0.9436619718309859, "section_id": 8721}, "so_33569303_33569726_1": {"length": 22, "quality": 0.7586206896551724, "section_id": 8719}}}, "33571169": {"Id": "33571169", "PostTypeId": "2", "Body": "<p>To keep the ordering that you want, you must add the same amount to all values such that</p>\n<p>a) their relative differences are unchanged and</p>\n<p>b) all negative values are turned into nonnegative values.</p>\n<p>Adding a consistent amount is the only way to do this.  If all the values you are sorting are originally of the same signed type T, then the amount to add to ensure any negative value becomes nonnegative must be\n\"-numeric_limits::min()\" or in other words you must subtract the minimum signed value, which is negative.</p>\n<p>If you are bringing in different types into the same sort (e.g. sorting char values along with short, int, long, etc.), you might want to make the first step a conversion to the largest <strong>signed</strong> type you will handle.  There is no loss of information to go from a smaller signed type to a larger signed type.</p>\n<p>To avoid overflow problems, I would suggest doing the shift (i.e. subtracting the minimum) <strong>conditionally</strong>.</p>\n<p>if (value &lt; 0)</p>\n<p>convert by first subtracting the minimum (making nonnegative) and then convert to the unsigned type (which is now completely safe)</p>\n<p>else</p>\n<p>first convert the already nonnegative value to the unsigned type (completely safe) and then add the same adjustment as a positive value i.e. add numeric_limits::max()+1</p>\n<p>T for both is the original signed T.  The expression \"numeric_limits::max()+1\" could be calculated and converted to the new destination type once and then used as a constant in type newT.</p>\n", "LastActivityDate": "2015-11-06T16:22:06.643", "CommentCount": "0", "CreationDate": "2015-11-06T16:22:06.643", "ParentId": "33569303", "Score": "3", "OwnerUserId": "5534276"}, "33569661": {"Id": "33569661", "PostTypeId": "2", "Body": "<p>I would subtract <code>numeric_limits&lt;T&gt;::min()</code> from each value.  This preserves the ordering property you want, and if the underlying representation is 2's complement (i.e., the only <em>sane</em> representation, and the one that is in practice what every non-museum-resident computer uses) will do what you expect, including for the boundary cases when the input value is equal to the most negative or most positive representable integer -- <em>provided</em> that the compiler uses a <code>SUB</code> instruction, and not an <code>ADD</code> instruction (since the positive value <code>-numeric_limits&lt;T&gt;::min()</code> is too large to represent).</p>\n<p>Is this standard compliant?  No idea.  My guess is: Probably not.  Feel free to edit if you know.</p>\n", "LastActivityDate": "2015-11-06T15:02:13.290", "CommentCount": "1", "CreationDate": "2015-11-06T15:02:13.290", "ParentId": "33569303", "Score": "2", "OwnerUserId": "47984"}, "33576378": {"Id": "33576378", "PostTypeId": "2", "Body": "<p>The formula <code>x-(unsigned)INT_MIN</code> will yield a suitable ranking on all machines where <code>UINT_MAX &gt; INT_MAX</code>.  For any pair of signed integers x and y, where x&gt;=y,\n(unsigned)x-(unsigned)y will equal the numerical value of x-y; so if y is\nINT_MIN, then x&gt;=y for all x, and the aformentioned formula will report the amount by which x is greater than INT_MIN, which is of course ranked the same as x.</p>\n", "LastActivityDate": "2015-11-06T21:58:32.247", "CommentCount": "0", "CreationDate": "2015-11-06T21:58:32.247", "ParentId": "33569303", "Score": "2", "OwnerUserId": "363751"}});