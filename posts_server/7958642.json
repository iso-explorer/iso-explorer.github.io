post_cb({"7958642": {"ViewCount": "1797", "Body": "<p>At first one might think <code>std::numeric_limits&lt;size_t&gt;::max()</code>, but if there was an object that huge, could it still offer a one-past-the-end pointer? I guess not. Does that imply the largest value <code>sizeof(T)</code> could yield is <code>std::numeric_limits&lt;size_t&gt;::max()-1</code>? Am I right, or am I missing something?</p>\n", "AcceptedAnswerId": "7958757", "Title": "What is the largest value sizeof(T) can yield?", "CreationDate": "2011-10-31T19:26:07.090", "Id": "7958642", "CommentCount": "6", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2011-11-01T09:11:49.727", "Score": "8", "OwnerUserId": "252000", "Tags": "<c++><memory><pointers><sizeof><size-t>", "AnswerCount": "7"}, "7958690": {"Id": "7958690", "PostTypeId": "2", "Body": "<p>If this was a test, I'd say <code>(size_t) -1</code></p>\n", "LastActivityDate": "2011-10-31T19:30:45.193", "CommentCount": "1", "CreationDate": "2011-10-31T19:30:45.193", "ParentId": "7958642", "Score": "0", "OwnerUserId": "371408"}, "7958989": {"Id": "7958989", "PostTypeId": "2", "Body": "<p>You can have a standard compliant compiler that allows for object sizes that cause pointer arithmetic to overflow; however, the result is undefined. From the C++ standard, 5.7 [expr.add]:</p>\n<blockquote>\n<p id=\"so_7958642_7958989_0\">When two pointers to elements of the same array object are subtracted,\n  the result is the difference of the subscripts of the two array\n  elements. The type of the result is an implementation-defined signed\n  integral type; this type shall be the same type that is defined as\n  <code>std::ptrdiff_t</code> in the <code>&lt;cstddef&gt;</code> header (18.2). As with any other\n  arithmetic overflow, if the result does not fit in the space provided,\n  the behavior is undefined.</p>\n</blockquote>\n", "LastActivityDate": "2011-10-31T19:56:11.957", "CommentCount": "0", "CreationDate": "2011-10-31T19:56:11.957", "ParentId": "7958642", "Score": "0", "OwnerUserId": "6210"}, "7958821": {"Id": "7958821", "PostTypeId": "2", "Body": "<p>it's not exactly well-defined. but to stay within safe limits of the standard, max object size is <code>std::numeric_limits&lt;ptrdiff_t&gt;::max()</code></p>\n<p>that's because when you subtract two pointers, you get a <code>ptrdiff_t</code></p>\n<p>which is a signed integer type</p>\n<p>cheers &amp; hth.,</p>\n", "LastActivityDate": "2011-10-31T19:41:43.010", "CommentCount": "2", "CreationDate": "2011-10-31T19:41:43.010", "ParentId": "7958642", "Score": "2", "OwnerUserId": "464581"}, "bq_ids": {"n4140": {"so_7958642_7958989_0": {"length": 36, "quality": 0.9230769230769231, "section_id": 6143}}, "n3337": {"so_7958642_7958989_0": {"length": 36, "quality": 0.9230769230769231, "section_id": 5907}}, "n4659": {"so_7958642_7958989_0": {"length": 22, "quality": 0.5641025641025641, "section_id": 7639}}}, "7958757": {"Id": "7958757", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_7958642_7958757_0\">Q: What is the largest value sizeof(T) can yield?</p>\n</blockquote>\n<p>A: <code>std::numeric_limits&lt;size_t&gt;::max()</code></p>\n<p>Clearly, sizeof cannot return a value larger than <code>std::numeric_limits&lt;size_t&gt;::max()</code>, since it wouldn't fit.  The only question is, can it return <code>...::max()</code>?</p>\n<p>Yes. Here is a valid program, that violates no constraints of the C++03 standard, which demonstrates a proof-by-example. In particular, this program does not violate any constraint listed in \u00a75.3.3 [expr.sizeof], nor in \u00a78.3.4 [dcl.array]:</p>\n<pre><code>#include &lt;limits&gt;\n#include &lt;iostream&gt;\nint main () {\n typedef char T[std::numeric_limits&lt;size_t&gt;::max()];\n std::cout &lt;&lt; sizeof(T)&lt;&lt;\"\\n\";\n}\n</code></pre>\n", "LastEditorUserId": "140719", "LastActivityDate": "2011-11-01T09:11:49.727", "Score": "3", "CreationDate": "2011-10-31T19:37:17.587", "ParentId": "7958642", "CommentCount": "10", "OwnerUserId": "8747", "LastEditDate": "2011-11-01T09:11:49.727"}, "7958694": {"Id": "7958694", "PostTypeId": "2", "Body": "<p>A <code>sizeof()</code> expression yields a value of type <code>size_t</code>. From C99 standard 6.5.3.4:</p>\n<blockquote>\n<p id=\"so_7958642_7958694_0\">The value of the result is implementation-defined, and its type (an\n  unsigned integer type) is size_t, defined in stddef.h (and other\n  headers).</p>\n</blockquote>\n<p>Therefore, the maximum value that sizeof() can yield is SIZE_MAX.</p>\n", "LastActivityDate": "2011-10-31T19:31:00.700", "CommentCount": "1", "CreationDate": "2011-10-31T19:31:00.700", "ParentId": "7958642", "Score": "0", "OwnerUserId": "1020667"}, "7959239": {"Id": "7959239", "PostTypeId": "2", "Body": "<p>The requirement to be able to point beyond the end of an array has nothing to do with the range of <code>size_t</code>. Given an object <code>x</code>, it's quite possible for <code>(&amp;x)+1</code> to be a valid pointer, even if the number of bytes separating the two pointers can't be represented by <code>size_t</code>.</p>\n<p>You could argue that the requirement <em>does</em> imply an upper bound on object size of the maximum range of pointers, minus the alignment of the object. However, I don't believe the standard says anywhere that such a type can't be defined; it would just be impossible to instantiate one and still remain conformant.</p>\n", "LastActivityDate": "2011-10-31T20:16:31.303", "CommentCount": "0", "CreationDate": "2011-10-31T20:16:31.303", "ParentId": "7958642", "Score": "1", "OwnerUserId": "204847"}, "7958888": {"Id": "7958888", "PostTypeId": "2", "Body": "<p>If <code>std::numeric_limits&lt;ptrdiff_t&gt;::max() &gt; std::numeric_limits&lt;size_t&gt;::max()</code> you can compute the size of an object of size <code>std::numeric_limits&lt;size_t&gt;::max()</code> by subtracting a pointer to it from a one-past-the-end pointer.</p>\n<p>If <code>sizeof(T*) &gt; sizeof(size_t)</code> you can have enough distinct pointers to address each and every single byte inside that object (in case you have an array of char, for example) plus one for one-past-the-end.</p>\n<p>So, it's possible to write an implementation where <code>sizeof</code> can return <code>std::numeric_limits&lt;size_t&gt;::max()</code>, and where you can get pointer to one-past-the-end of an object that large.</p>\n", "LastEditorUserId": "46642", "LastActivityDate": "2011-10-31T20:16:43.323", "Score": "3", "CreationDate": "2011-10-31T19:47:45.123", "ParentId": "7958642", "CommentCount": "2", "OwnerUserId": "46642", "LastEditDate": "2011-10-31T20:16:43.323"}});