post_cb({"bq_ids": {"n4140": {"so_12654067_12654277_3": {"length": 18, "quality": 1.0, "section_id": 300}, "so_12654067_12654277_2": {"length": 36, "quality": 0.9473684210526315, "section_id": 299}, "so_12654067_12654277_1": {"length": 49, "quality": 0.98, "section_id": 298}}, "n3337": {"so_12654067_12654277_3": {"length": 18, "quality": 1.0, "section_id": 291}, "so_12654067_12654277_2": {"length": 36, "quality": 0.9473684210526315, "section_id": 290}, "so_12654067_12654277_1": {"length": 49, "quality": 0.98, "section_id": 289}}, "n4659": {"so_12654067_12654277_3": {"length": 18, "quality": 1.0, "section_id": 307}, "so_12654067_12654277_2": {"length": 36, "quality": 0.9473684210526315, "section_id": 306}, "so_12654067_12654277_1": {"length": 49, "quality": 0.98, "section_id": 305}}}, "12654067": {"ViewCount": "9983", "Body": "<p>At <a href=\"http://blogs.msdn.com/b/vcblog/archive/2011/09/12/10209291.aspx\" rel=\"noreferrer\">http://blogs.msdn.com/b/vcblog/archive/2011/09/12/10209291.aspx</a>, the VC++ team officially declare that they have not yet implemented the C++11 core feature \"Expression SFINAE\". However, The following code examples copied from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2634.html\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2634.html</a> are accepted by the VC++ compiler.</p>\n<p>example 1:</p>\n<pre><code>template &lt;int I&gt; struct A {};\n\nchar xxx(int);\nchar xxx(float);\n\ntemplate &lt;class T&gt; A&lt;sizeof(xxx((T)0))&gt; f(T){}\n\nint main()\n{\n    f(1);\n}\n</code></pre>\n<p>example 2:</p>\n<pre><code>struct X {};\nstruct Y \n{\n    Y(X){}\n};\n\ntemplate &lt;class T&gt; auto f(T t1, T t2) -&gt; decltype(t1 + t2); // #1\nX f(Y, Y);  // #2\n\nX x1, x2;\nX x3 = f(x1, x2);  // deduction fails on #1 (cannot add X+X), calls #2\n</code></pre>\n<p><strong>My question is: What is \"Expression SFINAE\"?</strong></p>\n", "AcceptedAnswerId": "12654277", "Title": "What is \"Expression SFINAE\"?", "CreationDate": "2012-09-29T15:37:17.060", "Id": "12654067", "CommentCount": "3", "FavoriteCount": "24", "PostTypeId": "1", "LastEditDate": "2012-09-29T16:17:02.050", "LastEditorUserId": "508343", "LastActivityDate": "2017-06-09T20:38:39.090", "Score": "49", "OwnerUserId": "508343", "Tags": "<c++><templates><visual-c++><c++11><sfinae>", "AnswerCount": "1"}, "12654277": {"Id": "12654277", "PostTypeId": "2", "Body": "<p>Expression SFINAE is explained quite well in the paper you linked, I think. It's <a href=\"http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error\" rel=\"noreferrer\">SFINAE</a> on expressions. If the expression inside <code>decltype</code> isn't valid, well, kick the function from the VIP lounge of overloads. You can find the normative wording at the end of this answer.</p>\n<p>A note on VC++: They didn't implement it <em>completely</em>. On simple expressions, it might work, but on others, it won't. See a discussion in the comments <a href=\"https://stackoverflow.com/a/6194623/500104\">on this answer</a> for examples that fail. To make it simple, this won't work:</p>\n<pre><code>#include &lt;iostream&gt;\n\n// catch-all case\nvoid test(...)\n{\n  std::cout &lt;&lt; \"Couldn't call\\n\";\n}\n\n// catch when C is a reference-to-class type and F is a member function pointer\ntemplate&lt;class C, class F&gt;\nauto test(C c, F f) -&gt; decltype((c.*f)(), void()) // 'C' is reference type\n{\n  std::cout &lt;&lt; \"Could call on reference\\n\";\n}\n\n// catch when C is a pointer-to-class type and F is a member function pointer\ntemplate&lt;class C, class F&gt;\nauto test(C c, F f) -&gt; decltype((c-&gt;*f)(), void()) // 'C' is pointer type\n{\n  std::cout &lt;&lt; \"Could call on pointer\\n\";\n}\n\nstruct X{\n  void f(){}\n};\n\nint main(){\n  X x;\n  test(x, &amp;X::f);\n  test(&amp;x, &amp;X::f);\n  test(42, 1337);\n}\n</code></pre>\n<p>With Clang, this outputs the expected:</p>\n<blockquote>\n<p id=\"so_12654067_12654277_0\">Could call with reference<br>\n  Could call with pointer<br>\n  Couldn't call  </br></br></p>\n</blockquote>\n<p>With MSVC, I get... well, a compiler error:</p>\n<pre>\n1&gt;src\\main.cpp(20): error C2995: ''unknown-type' test(C,F)' : function template has already been defined\n1&gt;          src\\main.cpp(11) : see declaration of 'test'\n</pre>\n<p>It also seems that GCC 4.7.1 isn't quite up to the task:</p>\n<pre>\nsource.cpp: In substitution of 'template decltype ((c.*f(), void())) test(C, F) [with C = X*; F = void (X::*)()]':\nsource.cpp:29:17:   required from here\nsource.cpp:11:6: error: cannot apply member pointer 'f' to 'c', which is of non-class type 'X*'\nsource.cpp: In substitution of 'template decltype ((c.*f(), void())) test(C, F) [with C = int; F = int]':\nsource.cpp:30:16:   required from here\nsource.cpp:11:6: error: 'f' cannot be used as a member pointer, since it is of type 'int'\n</pre>\n<p>A common use of Expression SFINAE is when defining traits, like a trait to check if a class sports a certain member function:</p>\n<pre><code>struct has_member_begin_test{\n  template&lt;class U&gt;\n  static auto test(U* p) -&gt; decltype(p-&gt;begin(), std::true_type());\n  template&lt;class&gt;\n  static auto test(...) -&gt; std::false_type;\n};\n\ntemplate&lt;class T&gt;\nstruct has_member_begin\n  : decltype(has_member_begin_test::test&lt;T&gt;(0)) {};\n</code></pre>\n<p><a href=\"http://liveworkspace.org/code/45043173e3b62ee33deaeec3e609516a\" rel=\"noreferrer\">Live example.</a> (Which, surprisingly, works again on GCC 4.7.1.)</p>\n<p>See also <a href=\"https://stackoverflow.com/a/9154394/500104\">this answer of mine</a>, which uses the same technique in another environment (aka without traits).</p>\n<hr>\n<p>Normative wording:</p>\n<p><code>\u00a714.8.2 [temp.deduct]</code></p>\n<blockquote>\n<p id=\"so_12654067_12654277_1\">p6 <strong>At certain points in the template argument deduction process it is necessary to take a function type that makes use of template parameters and replace those template parameters with the corresponding template arguments.</strong> This is done at the beginning of template argument deduction when any explicitly specified template arguments are substituted into the function type, and <strong>again at the end of template argument deduction when any template arguments that were deduced or obtained from default arguments are substituted</strong>.</p>\n<p id=\"so_12654067_12654277_2\">p7 <strong>The substitution occurs in all types and expressions</strong> that are used in the function type and in template parameter declarations. <strong>The expressions include not only constant expressions</strong> such as those that appear in array bounds or as nontype template arguments <strong>but also general expressions</strong> (i.e., non-constant expressions) <strong>inside</strong> <code>sizeof</code>, <strong><code>decltype</code></strong>, and other contexts that allow non-constant expressions.</p>\n<p id=\"so_12654067_12654277_3\">p8 If a substitution results in an invalid type or expression, type deduction fails. An invalid type or expression is one that would be ill-formed if written using the substituted arguments. [...]</p>\n</blockquote>\n</hr>", "LastEditorUserId": "1254880", "LastActivityDate": "2017-06-09T20:38:39.090", "Score": "61", "CreationDate": "2012-09-29T16:10:34.210", "ParentId": "12654067", "CommentCount": "2", "OwnerUserId": "500104", "LastEditDate": "2017-06-09T20:38:39.090"}});