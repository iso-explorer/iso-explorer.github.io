post_cb({"31595016": {"ParentId": "31497357", "CommentCount": "1", "Body": "<p>I feel the intent is that the examples compile, however, the standard doesn't clearly state what should happen (if anything) when matching of template argument lists for the synthesized argument lists used by partial ordering (14.5.5.1/1):</p>\n<blockquote>\n<p id=\"so_31497357_31595016_0\">This is done by matching the template arguments of the class template specialization with the template argument lists of the partial specializations.</p>\n</blockquote>\n<p>The above paragraph is required so that #1 is selected in the following:</p>\n<pre><code>template &lt;typename T, typename Q&gt; struct A;\ntemplate &lt;typename T&gt;             struct A&lt;T, void&gt; {}; #1\ntemplate &lt;typename T&gt;             struct A&lt;T, char&gt; {}; #2\n\nvoid foo ()\n{\n  A&lt;int, void&gt; a;\n}\n</code></pre>\n<p>Here:</p>\n<ol>\n<li>The template parameter <code>T</code> is deduced to <code>int</code> (14.5.5.1/2)</li>\n<li>The resulting argument lists match: <code>int</code> == <code>int</code>, <code>void</code> == <code>void</code> (14.5.5.1/1)</li>\n</ol>\n<p>For the partial ordering case:</p>\n<pre><code>template&lt; typename c &gt; struct t&lt; c, typename c::v &gt; {};  #3\ntemplate&lt; typename c &gt; struct t&lt; s&lt; c &gt;, typename s&lt; c &gt;::w &gt; {}; #4\n</code></pre>\n<p>For the first parameter, #4 is more specialized and both second parameters are non-deduced contexts, ie. type deduction succeeds for #4 to #3 but not for #3 to #4.</p>\n<p>I think the compilers are then appling the \"argument lists must match\" rule from 14.5.5.1/1 on the synthesized argument lists.  This compares the first synthesized type <code>Q1::v</code> to the second <code>s&lt;Q2&gt;::w</code> and these types are not the same.</p>\n<p>This may explain why changing <code>v</code> to <code>w</code> resulted in some examples working, as the compiler decided those types were the same.</p>\n<p>This is not an issue outside of partial ordering, because the types are concrete as types like <code>c::v</code> will be instantiated to <code>void</code> etc.</p>\n<p>It could be that the committee intends for the type equivalence (14.4) to apply, but I don't think so.  The standard should probably just clarify exactly what should happen regarding matching (or not) of synthesized types created as part of the partial ordering step.</p>\n", "OwnerUserId": "11698", "PostTypeId": "2", "Id": "31595016", "Score": "1", "CreationDate": "2015-07-23T18:09:14.087", "LastActivityDate": "2015-07-23T18:09:14.087"}, "31497357": {"CommentCount": "0", "ViewCount": "321", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2015-07-19T02:11:14.363", "LastActivityDate": "2017-02-23T13:38:44.303", "Title": "partial specialization ordering with non-deduced context", "FavoriteCount": "4", "LastEditDate": "2017-02-23T13:38:44.303", "Id": "31497357", "Score": "6", "Body": "<p>According to [temp.class.order] \u00a714.5.5.2, the selection of a partial specialization of <code>t</code> in this example:</p>\n<pre><code>template&lt; typename &gt;\nstruct s { typedef void v, w; };\n\ntemplate&lt; typename, typename = void &gt;\nstruct t {};\n\ntemplate&lt; typename c &gt;\nstruct t&lt; c, typename c::v &gt; {};\n\ntemplate&lt; typename c &gt;\nstruct t&lt; s&lt; c &gt;, typename s&lt; c &gt;::w &gt; {};\n\nt&lt; s&lt; int &gt; &gt; q;\n</code></pre>\n<p>is equivalent to the selection of an overload of <code>f</code> in this example:</p>\n<pre><code>template&lt; typename &gt;\nstruct s { typedef void v, w; };\n\ntemplate&lt; typename, typename = void &gt;\nstruct t {};\n\ntemplate&lt; typename c &gt;\nconstexpr int f( t&lt; c, typename c::v &gt; ) { return 1; }\n\ntemplate&lt; typename c &gt;\nconstexpr int f( t&lt; s&lt; c &gt;, typename s&lt; c &gt;::w &gt; ) { return 2; }\n\nstatic_assert ( f( t&lt; s&lt; int &gt; &gt;() ) == 2, \"\" );\n</code></pre>\n<p>However, GCC, Clang, and ICC all reject the first example as ambiguous, but accept the second.</p>\n<p>Even more strangely, the first example works if <code>::v</code> is replaced with <code>::w</code> or vice versa. The non-deduced contexts <code>c::</code> and <code>s&lt; c &gt;::</code> are apparently being considered in specialization ordering, which doesn't make sense.</p>\n<p>Am I missing something in the standard, or do all these implementations have the same bug?</p>\n", "Tags": "<c++><templates><language-lawyer><partial-specialization><partial-ordering>", "OwnerUserId": "153285", "AnswerCount": "3"}, "31499858": {"ParentId": "31497357", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>The information in this answer is based in large part off of <a href=\"https://stackoverflow.com/q/1180325/2069064\">this question</a>. The template partial ordering algorithm is underspecified by the standard. The main compilers seem to at least agree on what the algorithm should be though. </p>\n<hr/>\n<p>To start with, your two examples aren't equivalent. You have two template specializations in addition to your primary template, but with your function example, you're not adding a function overload for the primary. If you add it:</p>\n<pre><code>template &lt;typename c&gt;\nconstexpr int f( t&lt;c&gt; ) { return 0; } \n</code></pre>\n<p>The function call becomes ambiguous as well. The reason for this is that partial ordering type synthesis algorithm does not instantiate templates and instead synthesizes new unique types. </p>\n<p>First, if we compare the function I just introduced to this one:</p>\n<pre><code>template&lt; typename c &gt;\nconstexpr int f( t&lt; c, typename c::v &gt; ) { return 1; }\n</code></pre>\n<p>We have:</p>\n<pre><code>+---+---------------------+----------------------+\n|   | Parameters          | Arguments            |\n+---+---------------------+----------------------+\n| 0 | c, typename c::v    | Unique0, void        |\n| 1 | c, void             | Unique1, Unique1_v   |\n+---+---------------------+----------------------+\n</code></pre>\n<p>We ignore non-deduced contexts in the partial ordering deduction rules, so <code>Unique0</code> matches <code>c</code>, but <code>Unique1_v</code> does not match <code>void</code>! Thus <code>0</code> is preferred. This is probably not what you expected.</p>\n<p>If we then compare <code>0</code> and <code>2</code>:</p>\n<pre><code>+---+--------------------------+----------------------+\n|   | Parameters               | Arguments            |\n+---+--------------------------+----------------------+\n| 0 | s&lt;c&gt;, typename s&lt;c&gt;::w   | Unique0, void        |\n| 2 | c, void                  | Unique2, Unique2_v   |\n+---+--------------------------+----------------------+\n</code></pre>\n<p>Here, the <code>0</code> deduction fails (since <code>Unique0</code> won't match <code>s&lt;c&gt;</code>), but the <code>2</code> deduction also fails (since <code>Unique2_v</code> won't match <code>void</code>). That's why it's ambiguous. </p>\n<hr/>\n<p>This lead me to an interesting question about <code>void_t</code>:</p>\n<pre><code>template &lt;typename... &gt;\nusing void_t = void;\n</code></pre>\n<p>This function overload:</p>\n<pre><code>template&lt; typename c &gt;\nconstexpr int f( t&lt; s&lt; c &gt;, void_t&lt;s&lt;c&gt;&gt;&gt; ) { return 3; }\n</code></pre>\n<p>would be preferred over <code>0</code>, since the arguments would be <code>s&lt;c&gt;</code> and <code>void</code>. But this one would not be:</p>\n<pre><code>template &lt;typename... &gt;\nstruct make_void {\n    using type = void;\n};\n\ntemplate&lt; typename c &gt;\nconstexpr int f( t&lt; s&lt; c &gt;, typename make_void&lt;s&lt;c&gt;&gt;::type&gt; ) { return 4; }\n</code></pre>\n<p>Since we wouldn't instantiate <code>make_void&lt;s&lt;c&gt;&gt;</code> in order to determine <code>::type</code>, so we end up in the same situation as <code>2</code>. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:09:58.840", "Id": "31499858", "Score": "1", "CreationDate": "2015-07-19T09:39:32.880", "LastActivityDate": "2015-07-19T09:39:32.880"}, "bq_ids": {"n4140": {"so_31497357_31735144_0": {"section_id": 147, "quality": 0.8, "length": 24}, "so_31497357_31735144_4": {"section_id": 332, "quality": 1.0, "length": 11}, "so_31497357_31735144_1": {"section_id": 160, "quality": 0.9333333333333333, "length": 14}, "so_31497357_31735144_2": {"section_id": 322, "quality": 0.8888888888888888, "length": 8}, "so_31497357_31595016_0": {"section_id": 143, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_31497357_31735144_0": {"section_id": 141, "quality": 0.8, "length": 24}, "so_31497357_31735144_4": {"section_id": 322, "quality": 1.0, "length": 11}, "so_31497357_31735144_1": {"section_id": 154, "quality": 0.9333333333333333, "length": 14}, "so_31497357_31735144_2": {"section_id": 312, "quality": 0.8888888888888888, "length": 8}, "so_31497357_31595016_0": {"section_id": 137, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_31497357_31735144_0": {"section_id": 151, "quality": 0.9, "length": 27}, "so_31497357_31735144_4": {"section_id": 341, "quality": 1.0, "length": 11}, "so_31497357_31735144_1": {"section_id": 164, "quality": 0.9333333333333333, "length": 14}, "so_31497357_31595016_0": {"section_id": 147, "quality": 0.9230769230769231, "length": 12}, "so_31497357_31735144_2": {"section_id": 330, "quality": 0.8888888888888888, "length": 8}}}, "31735144": {"ParentId": "31497357", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Switching to extremely-pedantic-mode for a moment, yes, I think you are missing something in the standard, and no, it shouldn't make any difference in this case.</p>\n<p>All standard references are to N4527, the current working draft. </p>\n<p>[14.5.5.2p1] says:</p>\n<blockquote>\n<p id=\"so_31497357_31735144_0\">For two class template partial specializations, the first is <em>more\n  specialized</em> than the second if, given the following rewrite to two\n  function templates, the first function template is more specialized\n  than the second according to the ordering rules for function templates\n  (14.5.6.2):</p>\n<ul>\n<li>the first function template has the same template parameters as the first partial specialization and has a single function parameter whose\n  type is a class template specialization with the template arguments of\n  the first partial specialization, and</li>\n<li>the second function template has the same template parameters as the second partial specialization and has a single function parameter\n  whose type is a class template specialization with the template\n  arguments of the second partial specialization.</li>\n</ul>\n</blockquote>\n<p>Going to [14.5.6.2p1]:</p>\n<blockquote>\n<p id=\"so_31497357_31735144_1\">[...] <em>Partial ordering</em> of overloaded function template declarations\n  is used in the following contexts to select the function template to\n  which a function template specialization refers:</p>\n<ul>\n<li>during overload resolution for a call to a function template specialization (13.3.3);</li>\n<li>when the address of a function template specialization is taken;</li>\n<li>when a placement operator delete that is a function template specialization is selected to match a placement operator new (3.7.4.2,\n  5.3.4);</li>\n<li>when a friend function declaration (14.5.4), an explicit instantiation (14.7.2) or an explicit specialization (14.7.3) refers\n  to a function template specialization.</li>\n</ul>\n</blockquote>\n<p>No mention of partial ordering of class template specializations. However, [14.8.2.4p3] says:</p>\n<blockquote>\n<p id=\"so_31497357_31735144_2\">The types used to determine the ordering depend on the context in\n  which the partial ordering is done:</p>\n<ul>\n<li>In the context of a function call, the types used are those function parameter types for which the function call has arguments.</li>\n<li>In the context of a call to a conversion function, the return types of the conversion function templates are used.</li>\n<li>In other contexts (14.5.6.2) the function template\u2019s function type is used.</li>\n</ul>\n</blockquote>\n<p>Even though it refers back to [14.5.6.2], it does say \"other contexts\". I can only conclude that, when applying the partial ordering algorithm to the function templates generated according to the rules in [14.5.5.2], the function template\u2019s function type is used, not the list of parameter types, as it would happen for a function call. </p>\n<p>So, the selection of a partial specialization of <code>t</code> in your first snippet would be equivalent not to a case involving a function call, but to one that takes the address of a function template (for example), which also falls under \"other contexts\":</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename&gt; struct s { typedef void v, w; };\ntemplate&lt;typename, typename = void&gt; struct t { };\n\ntemplate&lt;typename C&gt; void f(t&lt;C, typename C::v&gt;) { std::cout &lt;&lt; \"t&lt;C, C::v&gt;\\n\"; }\ntemplate&lt;typename C&gt; void f(t&lt;s&lt;C&gt;, typename s&lt;C&gt;::w&gt;) { std::cout &lt;&lt; \"t&lt;s&lt;C&gt;, s&lt;C&gt;::w&gt;\\n\"; }\n\nint main()\n{\n   using pft = void (*)(t&lt;s&lt;int&gt;&gt;);\n   pft p = f;\n   p(t&lt;s&lt;int&gt;&gt;());\n}\n</code></pre>\n<p>(Since we're still in extremely-pedantic-mode, I rewrote the function templates exactly like the example in [14.5.5.2p2].)</p>\n<p>Needless to say, this also compiles and prints <code>t&lt;s&lt;C&gt;, s&lt;C&gt;::w&gt;</code>. The chances of it producing different behaviour were slim, but I had to try it. Considering how the algorithm works, it would have made a difference if the function parameters were, for example, reference types (triggering the special rules in [14.8.2.4] in the case of a function call, but not in the other cases), but such forms can't occur with function templates generated from class template specializations. </p>\n<p>So, this whole detour didn't help us one bit, but... it's a <code>language-lawyer</code> question, we had to have some standard quotes in here...</p>\n<hr>\n<p>There are some active Core issues related to your example: </p>\n<ul>\n<li><p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1157\" rel=\"nofollow noreferrer\">1157</a> contains a note that I think is relevant:</p>\n<blockquote>\n<p id=\"so_31497357_31735144_3\">Template argument deduction is an attempt to match a <code>P</code> and a deduced\n  <code>A</code>; however, template argument deduction is not specified to fail if\n  the <code>P</code> and the deduced <code>A</code> are incompatible. This may occur in the\n  presence of non-deduced contexts. Notwithstanding the parenthetical\n  statement in 14.8.2.4 [temp.deduct.partial] paragraph 9, template\n  argument deduction may succeed in determining a template argument for\n  every template parameter while producing a deduced <code>A</code> that is not\n  compatible with the corresponding <code>P</code>.</p>\n</blockquote>\n<p>I'm not entirely sure that's so clearly specified; after all, [14.8.2.5p1] says</p>\n<blockquote>\n<p id=\"so_31497357_31735144_4\">[...] find template argument values [...] that will make P, after substitution of the deduced values [...], compatible with A.</p>\n</blockquote>\n<p>and [14.8.2.4] references [14.8.2.5] in its entirety. However, it's pretty clear that partial ordering of function templates doesn't look for compatibility when non-deduced contexts are involved, and changing that would break a lot of valid cases, so I think this is just a lack of proper specification in the standard.</p></li>\n<li><p>To a lesser extent, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1847\" rel=\"nofollow noreferrer\">1847</a> has to do with non-deduced contexts appearing in arguments to template specializations. It references <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1391\" rel=\"nofollow noreferrer\">1391</a> for the resolution; I think there are some issues with that wording - more details in <a href=\"https://stackoverflow.com/a/31735126/4326278\">this answer</a>.</p></li>\n</ul>\n<p>To me, all of this says that your example should work.</p>\n<hr>\n<p>Like you, I was quite intrigued by the fact that the same inconsistency is present in three different compilers. I got even more intrigued after I verified that MSVC 14 exhibits the exact same behaviour as the others. So, when I got some time, I thought I'd take a quick look at what Clang does; it turned out to be anything but quick, but it yielded some answers. </p>\n<p>All the code relevant to our case is in <a href=\"https://github.com/llvm-mirror/clang/blob/master/lib/Sema/SemaTemplateDeduction.cpp\" rel=\"nofollow noreferrer\"><code>lib/Sema/SemaTemplateDeduction.cpp</code></a>. </p>\n<p>The core of the deduction algorithm is the <a href=\"https://github.com/llvm-mirror/clang/blob/master/lib/Sema/SemaTemplateDeduction.cpp#L943\" rel=\"nofollow noreferrer\"><code>DeduceTemplateArgumentsByTypeMatch</code></a> function; all variants of deduction end up calling it, and it's then used recursively to walk through the structure of compound types, sometimes with the help of the heavily overloaded <code>DeduceTemplateArguments</code> set of functions, and some <a href=\"https://github.com/llvm-mirror/clang/blob/master/lib/Sema/SemaTemplateDeduction.cpp#L33\" rel=\"nofollow noreferrer\">flags</a> to adjust the algorithm based on the specific type of deduction being done and the parts of a type's form being looked at.</p>\n<p>An important aspect to note regarding this function is that it handles strictly deduction, and not substitution. It compares type forms, deduces template argument values for template parameters that appear in deduced contexts, and skips non-deduced contexts. The only other check it does is verifying that deduced argument values for a template parameter are consistent. I've written some more about the way Clang does deduction during partial ordering in <a href=\"https://stackoverflow.com/a/31735126/4326278\">the answer I mentioned above</a>.</p>\n<p>For partial ordering of function templates, the algorithm starts in the <a href=\"https://github.com/llvm-mirror/clang/blob/master/lib/Sema/SemaTemplateDeduction.cpp#L4313\" rel=\"nofollow noreferrer\"><code>Sema::getMoreSpecializedTemplate</code></a> member function, which uses a flag of type <a href=\"https://github.com/llvm-mirror/clang/blob/master/include/clang/Sema/Template.h#L114\" rel=\"nofollow noreferrer\"><code>enum TPOC</code></a> to determine the context for which partial ordering is being done; the enumerators are <code>TPOC_Call</code>, <code>TPOC_Conversion</code>, and <code>TPOC_Other</code>; self-explanatory. This function then calls <a href=\"https://github.com/llvm-mirror/clang/blob/master/lib/Sema/SemaTemplateDeduction.cpp#L4128\" rel=\"nofollow noreferrer\"><code>isAtLeastAsSpecializedAs</code></a> twice, back and forth between the two templates, and compares the results.</p>\n<p><a href=\"https://github.com/llvm-mirror/clang/blob/master/lib/Sema/SemaTemplateDeduction.cpp#L4128\" rel=\"nofollow noreferrer\"><code>isAtLeastAsSpecializedAs</code></a> switches on the value of the <code>TPOC</code> flag, makes some adjustments based on that, and ends up calling, directly or indirectly, <a href=\"https://github.com/llvm-mirror/clang/blob/master/lib/Sema/SemaTemplateDeduction.cpp#L943\" rel=\"nofollow noreferrer\"><code>DeduceTemplateArgumentsByTypeMatch</code></a>. If that returns <a href=\"https://github.com/llvm-mirror/clang/blob/master/include/clang/Sema/Sema.h#L6229\" rel=\"nofollow noreferrer\"><code>Sema::TDK_Success</code></a>, <a href=\"https://github.com/llvm-mirror/clang/blob/master/lib/Sema/SemaTemplateDeduction.cpp#L4128\" rel=\"nofollow noreferrer\"><code>isAtLeastAsSpecializedAs</code></a> does only one more check, to verify that all template parameters that are used for partial ordering have values. If that's good too, it returns <code>true</code>.</p>\n<p>And that's partial ordering for function templates. Based on the paragraphs quoted in the previous section, I was expecting partial ordering for class template specializations to call <a href=\"https://github.com/llvm-mirror/clang/blob/master/lib/Sema/SemaTemplateDeduction.cpp#L4313\" rel=\"nofollow noreferrer\"><code>Sema::getMoreSpecializedTemplate</code></a> with suitably constructed function templates and a flag of <code>TPOC_Other</code>, and everything to flow naturally from there. If that were the case, your example should work. Surprise: that's not what happens.</p>\n<p>Partial ordering for class template specializations starts in <a href=\"https://github.com/llvm-mirror/clang/blob/master/lib/Sema/SemaTemplateDeduction.cpp#L4463\" rel=\"nofollow noreferrer\"><code>Sema::getMoreSpecializedPartialSpecialization</code></a>. As an optimization (red flag!), it doesn't synthesize function templates, but rather uses <a href=\"https://github.com/llvm-mirror/clang/blob/master/lib/Sema/SemaTemplateDeduction.cpp#L943\" rel=\"nofollow noreferrer\"><code>DeduceTemplateArgumentsByTypeMatch</code></a> to do type deduction directly on the class template specializations themselves as the types of <code>P</code> and <code>A</code>. This is fine; after all, that's what the algorithm for function templates would end up doing anyway. </p>\n<p>However, if all goes well during deduction, it then calls <a href=\"https://github.com/llvm-mirror/clang/blob/master/lib/Sema/SemaTemplateDeduction.cpp#L2107\" rel=\"nofollow noreferrer\"><code>FinishTemplateArgumentDeduction</code></a> (the overload for class template specializations), which does substitution and other checks, including checking that the substituted arguments to the specialization <a href=\"https://github.com/llvm-mirror/clang/blob/master/lib/Sema/SemaTemplateDeduction.cpp#L2176\" rel=\"nofollow noreferrer\">are equivalent to the original ones</a>. This would be fine if the code were checking whether a partial specialization matches a set of arguments, but is not fine during partial ordering, and, as far as I can tell, causes the problem with your example.</p>\n<p>So, it seems that <a href=\"https://stackoverflow.com/users/11698/richard-corden\">Richard Corden's</a> assumption as to what happens is correct, but I'm not entirely sure this was intentional. This looks more like an oversight to me. How we ended up with all compilers behaving the same way remains a mystery.</p>\n<p>In my opinion, removing the two calls to <a href=\"https://github.com/llvm-mirror/clang/blob/master/lib/Sema/SemaTemplateDeduction.cpp#L2107\" rel=\"nofollow noreferrer\"><code>FinishTemplateArgumentDeduction</code></a> from <a href=\"https://github.com/llvm-mirror/clang/blob/master/lib/Sema/SemaTemplateDeduction.cpp#L4463\" rel=\"nofollow noreferrer\"><code>Sema::getMoreSpecializedPartialSpecialization</code></a> would do no harm, and would restore consistency to the partial ordering algorithm. There's no need for the additional check (done by <a href=\"https://github.com/llvm-mirror/clang/blob/master/lib/Sema/SemaTemplateDeduction.cpp#L4128\" rel=\"nofollow noreferrer\"><code>isAtLeastAsSpecializedAs</code></a>) that all template parameters have values either, as we know all template parameters are deducible from the specialization's arguments; if they weren't, the partial specialization would fail matching, so we wouldn't get to partial ordering in the first place. (Whether such partial specializations are allowed in the first place is the subject of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#549\" rel=\"nofollow noreferrer\">issue 549</a>. Clang issues a warning for such cases, MSVC and GCC issue an error. Anyway, not a problem.)</p>\n<p>As a side note, I think all of this applies to the <a href=\"https://github.com/llvm-mirror/clang/blob/master/lib/Sema/SemaTemplateDeduction.cpp#L4536\" rel=\"nofollow noreferrer\">overload for variable template specializations</a> as well.</p>\n<p>Unfortunately, I don't have a build environment set up for Clang, so I can't test this change at the moment. </p>\n</hr></hr>", "OwnerUserId": "4326278", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:34:19.433", "Id": "31735144", "Score": "7", "CreationDate": "2015-07-30T22:28:13.810", "LastActivityDate": "2015-07-30T22:28:13.810"}});