post_cb({"1632659": {"ParentId": "1632600", "CommentCount": "0", "Body": "<p>The answer is, \"it's complicated\". Dynamic cast does not simply adjust pointers with an offset; it may actually retrieve internal pointers inside the object in order to do its work. GCC follows an ABI designed for Itanium but implemented more broadly. You can find the gory details here: <a href=\"http://www.codesourcery.com/public/cxx-abi/abi.html\" rel=\"nofollow noreferrer\" title=\"Itanium C++ ABI\">Itanium C++ ABI</a>.</p>\n", "OwnerUserId": "197411", "PostTypeId": "2", "Id": "1632659", "Score": "4", "CreationDate": "2009-10-27T18:10:22.333", "LastActivityDate": "2009-10-27T18:10:22.333"}, "27682344": {"ParentId": "1632600", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Memory layout is mostly left to the implementation. The key exception is that member variables for a given access specifier will be in order of their declaration. </p>\n<p>\u00a7 9.2.14</p>\n<blockquote>\n<p id=\"so_1632600_27682344_0\">Nonstatic data members of a (non-union) class with the same access\n  control (Clause 11) are allocated so that later members have higher\n  addresses within a class object. The order of allocation of non-static\n  data members with different access control is unspecified (11).\n  Implementation alignment requirements might cause two adjacent members\n  not to be allocated immediately after each other; so might\n  requirements for space for managing virtual functions (10.3) and\n  virtual base classes (10.1).</p>\n</blockquote>\n<p>Other than member variables, a class or struct needs to provide space for member variables, subobjects of base classes, virtual function management (e.g. a virtual table), and padding and alignment of these data. This is up to the implementation but the Itanium ABI specification is a popular choice. gcc and clang adhere to it (at least to a degree).</p>\n<p><a href=\"http://mentorembedded.github.io/cxx-abi/abi.html#layout\" rel=\"nofollow\">http://mentorembedded.github.io/cxx-abi/abi.html#layout</a></p>\n<p>The Itanium ABI is of course not part of the C++ standard and is not binding. To get more detailed you need to turn to your implementor's documentation and tools. clang provides a tool to view the memory layout of classes. As an example, the following:</p>\n<pre><code>class VBase {\n    virtual void corge();\n    int j;\n};\n\nclass SBase1 {\n    virtual void grault();\n    int k;\n};\n\nclass SBase2 {\n    virtual void grault();\n    int k;\n};\n\nclass SBase3 {\n    void grault();\n    int k;\n};\n\nclass Class : public SBase1, SBase2, SBase3, virtual VBase {\npublic:\n    void bar();\n    virtual void baz();\n    // virtual member function templates not allowed, thinking about memory\n    // layout and vtables will tell you why\n    // template&lt;typename T&gt;\n    // virtual void quux();\nprivate:\n    int i;\n    char c;\npublic:\n    float f;\nprivate:\n    double d;\npublic:\n    short s;\n};\n\nclass Derived : public Class {\n    virtual void qux();\n};\n\nint main() {\n    return sizeof(Derived);\n}\n</code></pre>\n<p>After creating a source file that uses the memory layout of the class, clang will reveal the memory layout.</p>\n<pre><code>$ clang -cc1 -fdump-record-layouts layout.cpp\n</code></pre>\n<p>The layout for <code>Class</code>:</p>\n<pre><code>*** Dumping AST Record Layout\n   0 | class Class\n   0 |   class SBase1 (primary base)\n   0 |     (SBase1 vtable pointer)\n   8 |     int k\n  16 |   class SBase2 (base)\n  16 |     (SBase2 vtable pointer)\n  24 |     int k\n  28 |   class SBase3 (base)\n  28 |     int k\n  32 |   int i\n  36 |   char c\n  40 |   float f\n  48 |   double d\n  56 |   short s\n  64 |   class VBase (virtual base)\n  64 |     (VBase vtable pointer)\n  72 |     int j\n     | [sizeof=80, dsize=76, align=8\n     |  nvsize=58, nvalign=8]\n</code></pre>\n<p>More on this clang feature can be found on Eli Bendersky's blog:</p>\n<p><a href=\"http://eli.thegreenplace.net/2012/12/17/dumping-a-c-objects-memory-layout-with-clang/\" rel=\"nofollow\">http://eli.thegreenplace.net/2012/12/17/dumping-a-c-objects-memory-layout-with-clang/</a></p>\n<p>gcc provides a similar tool, `-fdump-class-hierarchy'. For the class given above, it prints  (among other things):</p>\n<pre><code>Class Class\n   size=80 align=8\n   base size=58 base align=8\nClass (0x0x141f81280) 0\n    vptridx=0u vptr=((&amp; Class::_ZTV5Class) + 24u)\n  SBase1 (0x0x141f78840) 0\n      primary-for Class (0x0x141f81280)\n  SBase2 (0x0x141f788a0) 16\n      vptr=((&amp; Class::_ZTV5Class) + 56u)\n  SBase3 (0x0x141f78900) 28\n  VBase (0x0x141f78960) 64 virtual\n      vptridx=8u vbaseoffset=-24 vptr=((&amp; Class::_ZTV5Class) + 88u)\n</code></pre>\n<p>It doesn't itemize the member variables (or at least I don't know how to get it to) but you can tell they would have to be between offset 28 and 64, just as in the clang layout.</p>\n<p>You can see that one base class is singled out as <code>primary</code>. This removes the need for adjustment of the <code>this</code> pointer when <code>Class</code> is accessed as an <code>SBase1</code>.</p>\n<p>The equivalent for gcc is:</p>\n<pre><code>$ g++ -fdump-class-hierarchy -c layout.cpp\n</code></pre>\n<p>The equivalent for Visual C++ is:</p>\n<pre><code>cl main.cpp /c /d1reportSingleClassLayoutTest_A\n</code></pre>\n<p>see: <a href=\"https://blogs.msdn.microsoft.com/vcblog/2007/05/17/diagnosing-hidden-odr-violations-in-visual-c-and-fixing-lnk2022/\" rel=\"nofollow\">https://blogs.msdn.microsoft.com/vcblog/2007/05/17/diagnosing-hidden-odr-violations-in-visual-c-and-fixing-lnk2022/</a></p>\n", "OwnerUserId": "1128289", "LastEditorUserId": "5397116", "LastEditDate": "2016-07-20T22:45:12.783", "Id": "27682344", "Score": "6", "CreationDate": "2014-12-29T01:26:02.553", "LastActivityDate": "2016-07-20T22:45:12.783"}, "1632755": {"ParentId": "1632600", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Each class lays out its data members in the order of declaration.<br>\nThe compiler is allowed to place padding between members to make access efficient (but it is not allowed to re-order).</br></p>\n<p>How <code>dynamic_cast&lt;&gt;</code> works is a compiler implementation detail and not defined by the standard. It will all depend on the ABI used by the compiler.</p>\n<p><code>reinterpret_cast&lt;&gt;</code> works by just changing the type of the object. The only thing that you can guarantee that works is that casting a pointer to a void* and back to the same the pointer to class will give you the same pointer.</p>\n", "OwnerUserId": "14065", "LastEditorUserId": "2390083", "LastEditDate": "2015-02-28T21:01:30.170", "Id": "1632755", "Score": "8", "CreationDate": "2009-10-27T18:24:21.633", "LastActivityDate": "2015-02-28T21:01:30.170"}, "24371918": {"ParentId": "1632600", "CommentCount": "1", "Body": "<p>this question is already answered at\n<a href=\"http://dieharddeveloper.blogspot.in/2013/07/c-memory-layout-and-process-image.html\" rel=\"nofollow\">http://dieharddeveloper.blogspot.in/2013/07/c-memory-layout-and-process-image.html</a>\nhere is a excerpt from there:\nIn the middle of the process's address space, there is a region is reserved for shared objects.  When a new process is created, the process manager first maps the two segments from the executable into memory. It then decodes the program's ELF header. If the program header indicates that the executable was linked against a shared library, the process manager (PM) will extract the name of the dynamic interpreter from the program header. The dynamic interpreter points to a shared library that contains the runtime linker code. </p>\n", "OwnerUserId": "1321569", "PostTypeId": "2", "Id": "24371918", "Score": "1", "CreationDate": "2014-06-23T17:34:06.333", "LastActivityDate": "2014-06-23T17:34:06.333"}, "1632887": {"ParentId": "1632600", "CommentCount": "0", "Body": "<p>As stated previously, the full details are complicated, painful to read, and really only useful to compiler developers, and varies between compilers. Basically, each object contains the following (usually laid out in this order):</p>\n<ol>\n<li>Runtime type information</li>\n<li>Non-Virtual base objects and their data (probably in order of declaration).</li>\n<li>Member variables</li>\n<li>Virtual base objects and their data (Probably in some DFS tree search order).</li>\n</ol>\n<p>These pieces of data may or may not be padded to make memory alignment easier etc. Hidden in the runtime type information is stuff about the type, v-tables for virtual parent classes etc, all of which is compiler specific.</p>\n<p>When it comes to casts, <code>reinterpret_cast</code> simply changes the C++ data type of the pointer and does nothing else, so you had better be sure you know what you're doing when you use it, otherwise you're liable to mess things up badly. <code>dynamic_cast</code> does very much the same thing as static_cast (in altering the pointer) except it uses the runtime type information to figure out if it can cast to the given type, and how to do so. Again, all that is compiler specific. Note that you can't  <code>dynamic_cast</code> a <code>void*</code> because it needs to know where to find the runtime type information so it can do all its wonderful runtime checks.</p>\n", "OwnerUserId": "193325", "PostTypeId": "2", "Id": "1632887", "Score": "4", "CreationDate": "2009-10-27T18:49:56.963", "LastActivityDate": "2009-10-27T18:49:56.963"}, "bq_ids": {"n4140": {"so_1632600_27682344_0": {"section_id": 5873, "quality": 0.9423076923076923, "length": 49}}, "n3337": {"so_1632600_27682344_0": {"section_id": 5644, "quality": 0.9423076923076923, "length": 49}}, "n4659": {"so_1632600_27682344_0": {"section_id": 7356, "quality": 0.9423076923076923, "length": 49}}}, "1632600": {"CommentCount": "0", "AcceptedAnswerId": "1632755", "PostTypeId": "1", "ClosedDate": "2015-10-22T20:09:38.733", "LastEditorUserId": "1073386", "CreationDate": "2009-10-27T18:00:04.353", "LastActivityDate": "2016-07-20T22:45:12.783", "LastEditDate": "2015-10-22T19:06:36.193", "ViewCount": "38883", "FavoriteCount": "21", "Title": "memory layout C++ objects", "Id": "1632600", "Score": "28", "Body": "<p>I am basically wondering how C++ lays out the object in memory. So, I hear that dynamic casts simply adjust the object's pointer in memory with an offset; and reinterpret kind of allows us to do anything with this pointer. I don't really understand this. Details would be appreciated!</p>\n", "Tags": "<c++><memory><object>", "OwnerUserId": "90446", "AnswerCount": "5"}});