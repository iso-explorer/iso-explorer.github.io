post_cb({"bq_ids": {"n4140": {"so_22977043_24067054_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 5313}}, "n3337": {"so_22977043_24067054_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 5110}}, "n4659": {"so_22977043_24067054_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 6737}}}, "24069557": {"Id": "24069557", "PostTypeId": "2", "Body": "<p>As another fun note, <code>foo.f++()</code> can be semantically valid.  But it has nothing at all to do with \"the next function defined\".</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct CallMe {\n    void operator()() const\n    { std::cout &lt;&lt; \"Used as function call.\\n\"; }\n};\n\nstruct F_Type {\n    CallMe operator++(int)\n    { std::cout &lt;&lt; \"f was incremented.\\n\"; return {}; }\n};\n\nstruct Foo_Type {\n    F_Type f;\n} foo;\n\nint main()\n{\n    foo.f++();\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>f was incremented.\nUsed as function call.\n</code></pre>\n", "LastActivityDate": "2014-06-05T20:21:50.827", "CommentCount": "2", "CreationDate": "2014-06-05T20:21:50.827", "ParentId": "22977043", "Score": "5", "OwnerUserId": "459640"}, "22977043": {"ViewCount": "753", "Body": "<p>When looking through the C++ grammar I discovered that postfixes are defined roughly like this:</p>\n<pre><code>Postfix ::=  Primary\n        |    Postfix '['  Expression ']'\n        |    Postfix '('  Expression ')'\n        |    Postfix '.'  Identifier\n        |    Postfix '-&gt;' Identifier\n        |    Postfix '++'\n        |    Postfix '--'\n</code></pre>\n<p>Meaning that <code>foo.f++()</code> would be syntactically valid--presumably because functions are pointers it would refer to the next function that was defined, but I would be shocked if it wasn't caught during the semantic parse as modifying a const object--as would <code>foo.f()&lt;true&gt;;</code> which doesn't seem to have any meaning at all, while <code>foo.++f()</code> wouldn't be allowed, even though it does more or less the same thing as the first one. Furthermore, unary expressions are defined so that <code>++*\"hello world\"</code> would be syntactically valid because literals are considered the same way that identifiers are. </p>\n<p>Conversely something like:</p>\n<pre><code>postfix0 ::= ScopeResolution\n         |   postfix0 '.' postfix2\n         |   postfix0 '-&gt;' postfix2\n\npostfix1 ::= postfix0\n         |   postfix1 '&lt;' expression '&gt;'\n\npostfix2 ::= postfix1\n         |   postfix2 '[' expression ']'\n         |   postfix2 '(' expression ']'\n\npostfix3 ::= postfix2\n         |   Literal\n         |   postfix3 '++'\n         |   postfix3 '--'\n</code></pre>\n<p>Would appear catch such invalid expressions during the syntactic phase of the parse.  At first I thought that it was just left in the standard as a legacy thing, but newer languages such as Java and D do the same thing, so is there some sort of meaning that those statements carry that leads to the grammar being defined that way? </p>\n", "Title": "Do these syntactically correct C++ statements carry any meaning?", "CreationDate": "2014-04-10T01:31:28.450", "LastActivityDate": "2016-07-19T18:28:40.510", "CommentCount": "10", "LastEditDate": "2014-06-05T18:01:40.823", "PostTypeId": "1", "LastEditorUserId": "102937", "Id": "22977043", "Score": "2", "OwnerUserId": "2908202", "Tags": "<c++><syntax>", "AnswerCount": "3"}, "24069399": {"Id": "24069399", "PostTypeId": "2", "Body": "<p>Just tried to compile and run this little program with <code>gcc</code> and <code>g++</code>:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nvoid foo() {\n    printf(\"foo()\\n\");\n}\n\nint main(void) {\n    void (*bar)() = foo;\n    bar++();\n    bar();\n}\n</code></pre>\n<p>If interpreted as C code, there is no compiler error, the string \"foo()\\n\" is printed two times, but it segfaults when it tries to return from <code>foo()</code> because part of the function prolog seems to have been skipped.</p>\n<p>So, yes, at least <code>gcc</code> thinks that <code>bar++()</code> is valid C code, and expediently does nonsense.</p>\n<p><strong>Update:</strong><br>\nAs zwol points out (thank for that), this is due to a rather dangerous than useful gnu extension, which treats pointers to <code>void</code> and functions as pointers to objects of size 1, allowing pointer arithmetic on them. Compiling with <code>gcc --pedantic -Werror</code> yields the expected error, <code>gcc -std=c99</code> doesn't.</br></p>\n<hr>\n<p>Different story with <code>g++</code>: Here I get the compiler error</p>\n<pre><code>foo.c: In function \u2018int main()\u2019:\nfoo.c:9:5: error: ISO C++ forbids incrementing a pointer of type \u2018void (*)()\u2019 [-fpermissive]\n</code></pre>\n<p>This is a provision within the C++ standard (section 5.2.6, as pointed out by Ben Voigt, thanks): pointer arithmetic on function pointers is not defined in C++.</p>\n</hr>", "LastEditorUserId": "2445184", "LastActivityDate": "2016-07-19T18:28:40.510", "Score": "2", "CreationDate": "2014-06-05T20:12:31.320", "ParentId": "22977043", "CommentCount": "9", "OwnerUserId": "2445184", "LastEditDate": "2016-07-19T18:28:40.510"}, "24067054": {"Id": "24067054", "PostTypeId": "2", "Body": "<p>C++ isn't actually defined by its grammar productions.  The BNF grammar is provided as an accompaniment to the rules of the language to aid in understanding, but there is not, and cannot be, a distinction between <em>syntax errors</em> and <em>semantic errors</em> in C++, because it does not have a context-free grammar.</p>\n<p>So the improvement you're trying to make in changing \"syntactically valid... caught during the semantic parse\" to \"catch such invalid expressions during the syntactic phase of the parse\" is completely meaningless, since these don't actually exist as independent phases.</p>\n<p>The phases of C++ compilation are found in section 2.1, <code>[lex.phases]</code> of the Standard.  Of particular interest to this topic is phase 7:</p>\n<blockquote>\n<p id=\"so_22977043_24067054_0\">White-space characters separating tokens are no longer significant.  Each preprocessing token is converted into a token. (2.7).  The resulting tokens are syntactically and semantically analyzed and translated as a translation unit.</p>\n</blockquote>\n<p>Syntactic and semantic analysis are performed together, inseparably.  Semantic errors <em>are</em> caught during the syntactic phase of the parse, phase 7.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2014-06-05T19:48:47.140", "Score": "10", "CreationDate": "2014-06-05T18:02:26.707", "ParentId": "22977043", "CommentCount": "0", "OwnerUserId": "103167", "LastEditDate": "2014-06-05T19:48:47.140"}});