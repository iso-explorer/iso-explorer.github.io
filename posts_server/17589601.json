post_cb({"17591567": {"ParentId": "17589601", "CommentCount": "8", "Body": "<p>In addition to the alignment issue already mentioned, you are creating a copy of the lambda through placement <code>new</code> but you are not destroying the copy.</p>\n<p>The following code illustrates the problem:</p>\n<pre><code>// This class plays the role of the OP's lambdas\nstruct Probe {\n    Probe() { std::cout &lt;&lt; \"Ctr\" &lt;&lt; '\\n'; }\n    Probe(const Probe&amp;) { std::cout &lt;&lt; \"Cpy-ctr\" &lt;&lt; '\\n'; }\n    ~Probe() { std::cout &lt;&lt; \"Dtr\" &lt;&lt; '\\n'; }\n\n};\n\n// This plays the role of the OP's assign_lambda\nvoid f(const Probe&amp; p) {\n\n    typedef typename std::aligned_storage&lt;sizeof(Probe),\n        std::alignment_of&lt;Probe&gt;::value&gt;::type buffer_type;\n\n    static buffer_type store;\n    new (&amp;store) Probe(p);\n}\n\nint main() {\n\n    Probe p;\n\n    // This plays the role of the loop\n    f(p);\n    f(p);\n    f(p);\n}\n</code></pre>\n<p>The output is:</p>\n<pre><code>Ctr\nCpy-ctr\nCpy-ctr\nCpy-ctr\nDtr\n</code></pre>\n<p>Therefore, 4 objects are constructed and only one is destroyed.</p>\n<p>In addition, in the OP's code the <code>store</code> is <code>static</code> and this means that one lambda is repeatedly constructed on top of the other as if the latter was just raw memory.</p>\n", "OwnerUserId": "1137388", "PostTypeId": "2", "Id": "17591567", "Score": "2", "CreationDate": "2013-07-11T10:57:31.413", "LastActivityDate": "2013-07-11T10:57:31.413"}, "17590822": {"ParentId": "17589601", "LastEditDate": "2013-07-12T05:32:46.203", "CommentCount": "7", "CreationDate": "2013-07-11T10:18:12.260", "OwnerUserId": "1838266", "LastEditorUserId": "1838266", "PostTypeId": "2", "Id": "17590822", "Score": "5", "Body": "<p>You'll have to make sure that <code>store</code> has the proper alignment for <code>functor_type</code>. Apart from that, I don't see any problems regarding standard conformance. However, you can easily address the multithreading issue by making the array nonstatic, because <code>sizeof</code> gives a compiletime constant.</p>\n<p>The alignment is demanded by <strong>\u00a75.3.4,14</strong>:</p>\n<blockquote>\n<p id=\"so_17589601_17590822_0\">[ Note: when the allocation function returns a value other than null, it must be a pointer to a block of storage in which space for the object has been reserved. The block of storage is assumed to be appropriately aligned and of the requested size. [...] -end note ]</p>\n</blockquote>\n<p>There is another paragraph, \u00a73.7.4.1 about alignment, but that one does explicitly not apply to placement new (\u00a718.6.1.3,1).</p>\n<p>To get the alignment right, you can do the following:</p>\n<pre><code>template &lt;typename T&gt;\nvoid assign_lambda(T&amp;&amp; f)\n{\n  typedef typename std::remove_reference&lt;T&gt;::type functor_type;\n\n  //alignas(functor_type) char store[sizeof(functor_type)];\n  std::aligned_storage&lt;sizeof(functor_type), \n            std::alignment_of&lt;functor_type&gt;::value&gt;::type store;\n\n  auto const p(new (&amp;store) functor_type(std::forward&lt;T&gt;(f)));\n\n  (*p)();\n\n  //\"placement delete\"\n  p-&gt;~functor_type();\n}\n</code></pre>\n<p><strong>Update:</strong>\nThe approach shown above is not different from using just a normal variable:</p>\n<pre><code>template &lt;typename T&gt;\nvoid assign_lambda(T&amp;&amp; f)\n{\n  typedef typename std::remove_reference&lt;T&gt;::type functor_type;\n\n  functor_type func{std::forward&lt;T&gt;(f)};\n\n  func();\n}\n</code></pre>\n<p>If it <em>has</em> to be a static variable inside the function you will need an RAII wrapper for functors that are not assignable. Just placement-newing is not sufficient since the functors will not get destroyed properly and ressources they possess (e.g. via captured smartpointers) will not get released.</p>\n<pre><code>template &lt;typename F&gt;\nstruct RAIIFunctor {\n  typedef typename std::remove_reference&lt;F&gt;::type functor_type;\n\n  std::aligned_storage&lt;sizeof(functor_type), \n            std::alignment_of&lt;functor_type&gt;::value&gt;::type store;\n\n  functor_type* f;\n\n  RAIIFunctor() : f{nullptr} {}\n  ~RAIIFunctor() { destroy(); }\n\n  template &lt;class T&gt;\n  void assign(T&amp;&amp; t) {\n    destroy();\n    f = new(&amp;store) functor_type {std::forward&lt;T&gt;(t)};\n  }\n\n  void destroy() {\n    if (f) \n      f-&gt;~functor_type();\n    f = nullptr;\n  }\n\n  void operator() {\n    (*f)();\n  }\n};\n\n\ntemplate &lt;typename T&gt;\nvoid assign_lambda(T&amp;&amp; f)\n{\n  static RAIIFunctor&lt;T&gt; func;\n\n  func.assign(std::forward&lt;T&gt;(f));\n  func();\n}\n</code></pre>\n<p>You can see the code in action <a href=\"http://ideone.com/3N2PVe\" rel=\"nofollow\">here</a></p>\n", "LastActivityDate": "2013-07-12T05:32:46.203"}, "17591204": {"ParentId": "17589601", "LastEditDate": "2013-07-11T11:07:59.377", "CommentCount": "3", "CreationDate": "2013-07-11T10:37:50.773", "OwnerUserId": "46642", "LastEditorUserId": "46642", "PostTypeId": "2", "Id": "17591204", "Score": "3", "Body": "<p>I don't get it. Why would one use <code>aligned_storage</code> merely to get some size to create uninitialised storage, instead of... using the aligned storage it provides? It's almost like travelling from Berlin to Lisbon by taking a Berlin -&gt; Lisbon flight followed by a Lisbon -&gt; Moscow flight.</p>\n<pre><code>  typedef typename std::remove_reference&lt;T&gt;::type functor_type;\n\n  typedef typename std::aligned_storage&lt;sizeof(functor_type),\n    std::alignment_of&lt;functor_type&gt;::value&gt;::type buffer_type;\n\n  static buffer_type store;\n\n  auto const p(new (&amp;store) functor_type(std::forward&lt;T&gt;(f)));\n</code></pre>\n", "LastActivityDate": "2013-07-11T11:07:59.377"}, "bq_ids": {"n4140": {"so_17589601_17590822_0": {"section_id": 6097, "quality": 0.8518518518518519, "length": 23}, "so_17589601_17589601_1": {"section_id": 6812, "quality": 0.7058823529411765, "length": 12}}, "n3337": {"so_17589601_17590822_0": {"section_id": 5863, "quality": 0.8518518518518519, "length": 23}, "so_17589601_17589601_1": {"section_id": 6567, "quality": 0.7058823529411765, "length": 12}}, "n4659": {"so_17589601_17590822_0": {"section_id": 7594, "quality": 0.8148148148148148, "length": 22}, "so_17589601_17589601_1": {"section_id": 8304, "quality": 0.7058823529411765, "length": 12}}}, "17589601": {"CommentCount": "8", "CreationDate": "2013-07-11T09:18:19.640", "PostTypeId": "1", "AcceptedAnswerId": "17590822", "LastEditorUserId": "1095108", "LastActivityDate": "2013-07-12T05:32:46.203", "LastEditDate": "2013-07-11T12:58:44.017", "ViewCount": "404", "FavoriteCount": "1", "Title": "lambda functors assignment workaround", "Id": "17589601", "Score": "2", "Body": "<p>Is there something wrong with the code below?</p>\n<pre><code>#include &lt;iostream&gt;\n\n#include &lt;type_traits&gt;\n\ntemplate &lt;typename T&gt;\nvoid assign_lambda(T&amp;&amp; f)\n{\n  typedef typename std::remove_reference&lt;T&gt;::type functor_type;\n\n  typedef typename std::aligned_storage&lt;sizeof(functor_type),\n    std::alignment_of&lt;functor_type&gt;::value&gt;::type buffer_type;\n\n  static char store[sizeof(buffer_type)];\n\n  auto const p(new (store) functor_type(std::forward&lt;T&gt;(f)));\n\n  (*p)();\n}\n\nint main()\n{\n  for (int i(0); i != 5; ++i)\n  {\n    assign_lambda([i](){ std::cout &lt;&lt; i &lt;&lt; std::endl; });\n  }\n\n  return 0;\n}\n</code></pre>\n<p>I worry though that this might be non-standard and/or dangerous to do.</p>\n<p>EDIT:\nWhy initialize into a <code>char</code> array you ask? One might allocate a block of size <code>sizeof(buffer_type)</code> from the heap and reuse for repeated assignments (i.e. avoid repeated memory allocations), if the block should prove large enough.</p>\n<blockquote>\n<p id=\"so_17589601_17589601_0\">void*operator new(std::size_t size);</p>\n<p id=\"so_17589601_17589601_1\">Effects: The allocation function (3.7.4.1) called by a new-expression (5.3.4) to allocate size bytes of storage suitably aligned to represent any object of that size.</p>\n</blockquote>\n<p>I suppose if I allocate from the heap the alignment issues will go away.</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1095108", "AnswerCount": "3"}});