post_cb({"2194549": {"Id": "2194549", "PostTypeId": "2", "Body": "<p>Just a thought I would like to share, perhaps you could get around the endianess of a value by using the functions or macros found in <code>&lt;arpa/inet.h&gt;</code>, to convert the Network to Host order and vice versa, it may be said that it is more used in conjunction to sockets, but it could be used for this instance to guarantee that a value such as 0xABCD from another processor is still 0xABCD on the Intel x86, instead of resorting to hand-coded custom functions to deal with the endian architecture....?!</p>\n<p><strong>Edit:</strong> Here's an article about Endianess on <a href=\"http://www.codeproject.com/KB/cpp/endianness.aspx\" rel=\"nofollow noreferrer\">CodeProject</a> and the author developed macros to deal with 64-bit values.</p>\n<p>Hope this helps,\nBest regards,\nTom.</p>\n", "LastActivityDate": "2010-02-03T18:52:12.533", "CommentCount": "1", "CreationDate": "2010-02-03T18:52:12.533", "ParentId": "2194310", "Score": "1", "OwnerUserId": "206367"}, "2196025": {"Id": "2196025", "PostTypeId": "2", "Body": "<p>It will work, but the strange propensity of some authors for doing bit-masking before bit-shifting always puzzled me.</p>\n<p>In my opinion, a much more elegant approach would be the one that does the shift first</p>\n<pre><code>msw = (temp &gt;&gt; 32) &amp; 0xFFFFFFFF; \nlsw = temp &amp; 0xFFFFFFFF; \n</code></pre>\n<p>at least because it uses the same \"magic\" bit-mask constant every time. </p>\n<p>Now, if your target type is unsigned and already has the desired bit-width, masking becomes completely unnecesary</p>\n<pre><code>msw = temp &gt;&gt; 32; \nlsw = temp; \n</code></pre>\n", "LastActivityDate": "2010-02-03T22:35:49.130", "CommentCount": "1", "CreationDate": "2010-02-03T22:35:49.130", "ParentId": "2194310", "Score": "3", "OwnerUserId": "187690"}, "2194310": {"ViewCount": "4463", "Body": "<p>It's my understanding that in C/C++ bitwise operators are supposed to be endian independent and behave the way you expect.  I want to make sure that I'm truly getting the most significant and least significant words out of a 64-bit value and not worry about endianness of the machine.  Here's an example:</p>\n<pre><code>uint64_t temp;\nuint32_t msw, lsw;\nmsw = (temp &amp; 0xFFFFFFFF00000000) &gt;&gt; 32;\nlsw = temp &amp; 0x00000000FFFFFFFF;\n</code></pre>\n<p>Will this work?</p>\n", "AcceptedAnswerId": "2194359", "Title": "Getting 32 bit words out of 64-bit values in C/C++ and not worrying about endianness", "CreationDate": "2010-02-03T18:21:17.217", "Id": "2194310", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2010-02-03T22:38:40.407", "Score": "10", "OwnerUserId": "119215", "Tags": "<c++><c><bit-manipulation><endianness><bitwise-operators>", "AnswerCount": "8"}, "2195317": {"Id": "2195317", "PostTypeId": "2", "Body": "<p>In addition to the other responses, I shall add that you should not worry about endianness in C. Endianness trouble comes only from looking at some bytes under a different type than what was used to write those bytes in the first place. When you do that, you are very close to have aliasing issues, which means that your code may break when using another compiler or another optimization flag.</p>\n<p>As long as you do not try to do such trans-type accesses, your code should be endian-neutral, and run flawlessly on both little-endian and big-endian architectures. Or, in other words, if you have endianness issues, then other kinds of bigger trouble are also lurking nearby.</p>\n", "LastActivityDate": "2010-02-03T20:45:55.673", "CommentCount": "0", "CreationDate": "2010-02-03T20:45:55.673", "ParentId": "2194310", "Score": "0", "OwnerUserId": "254279"}, "2194359": {"Id": "2194359", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_2194310_2194359_0\"><strong>6.5.7 Bitwise shift operators</strong></p>\n<p id=\"so_2194310_2194359_1\">4 The result of E1 &lt;&lt; E2 is E1\n  left-shifted E2 bit positions; vacated\n  bits are filled with zeros. If E1 has\n  an unsigned type, the value of the\n  result is E1 \u00d7 2E2, reduced modulo one\n  more than the maximum value\n  representable in the result type. If\n  E1 has a signed type and nonnegative\n  value, and E1 \u00d7 2E2 is representable\n  in the result type, then that is the\n  resulting value; otherwise, the\n  behavior is undefined. </p>\n</blockquote>\n<p>So, yes -- guranteed by the standard.</p>\n", "LastActivityDate": "2010-02-03T18:25:26.910", "CommentCount": "0", "CreationDate": "2010-02-03T18:25:26.910", "ParentId": "2194310", "Score": "17", "OwnerUserId": "66692"}, "2194373": {"Id": "2194373", "PostTypeId": "2", "Body": "<p>I think what you are saying is quite true, but where does this get you?</p>\n<p>If you have some literal values hanging around, then you know which end is which.  But if you find yourself with values that have come from outside the program, then you can't be sure, unless they have been encoded in some way.</p>\n", "LastActivityDate": "2010-02-03T18:27:02.680", "CommentCount": "0", "CreationDate": "2010-02-03T18:27:02.680", "ParentId": "2194310", "Score": "0", "OwnerUserId": "4834"}, "bq_ids": {"n4140": {"so_2194310_2194359_1": {"length": 32, "quality": 0.8421052631578947, "section_id": 6147}}, "n3337": {"so_2194310_2194359_1": {"length": 32, "quality": 0.8421052631578947, "section_id": 5910}}, "n4659": {"so_2194310_2194359_1": {"length": 32, "quality": 0.8421052631578947, "section_id": 7643}}}, "2194401": {"Id": "2194401", "PostTypeId": "2", "Body": "<p>Yes, that should work. When you're retrieving the msw, your mask isn't really accomplishing much though -- the bits you mask to zero will be discarded when you do the shift anyway. Personally, I'd probably use something like this:</p>\n<pre><code>uint32_t lsw = -1, msw = -1;\nlsw &amp;= temp;\nmsw &amp;= temp &gt;&gt; 32;\n</code></pre>\n<p>Of course, to produce a meaningful result, <code>temp</code> has to be initialized, which it wasn't in your code.</p>\n", "LastActivityDate": "2010-02-03T18:29:05.737", "CommentCount": "3", "CreationDate": "2010-02-03T18:29:05.737", "ParentId": "2194310", "Score": "3", "OwnerUserId": "179910"}, "2196038": {"Id": "2196038", "PostTypeId": "2", "Body": "<p>Endianness is about memory layout. Shifting is about bits (and bit layout). Word significance is about bit layout, not memory layout. So endianness has nothing to do with word significance.</p>\n", "LastActivityDate": "2010-02-03T22:38:40.407", "CommentCount": "0", "CreationDate": "2010-02-03T22:38:40.407", "ParentId": "2194310", "Score": "1", "OwnerUserId": "6210"}, "2194331": {"Id": "2194331", "PostTypeId": "2", "Body": "<p>Yes.\nIt should work.</p>\n", "LastActivityDate": "2010-02-03T18:23:23.347", "CommentCount": "0", "CreationDate": "2010-02-03T18:23:23.347", "ParentId": "2194310", "Score": "2", "OwnerUserId": "14065"}});