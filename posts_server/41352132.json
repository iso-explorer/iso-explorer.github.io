post_cb({"41352132": {"CommentCount": "0", "ViewCount": "65", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-12-27T20:56:56.827", "LastActivityDate": "2017-01-25T13:18:53.857", "Title": "Is dereferencing nullptr to lambda function undefined behaviour?", "AcceptedAnswerId": "41352253", "LastEditDate": "2017-05-23T12:24:17.577", "Id": "41352132", "Score": "2", "Body": "<p>As show by <a href=\"http://pfultz2.com/blog/2014/09/02/static-lambda/\" rel=\"nofollow noreferrer\">pfultz2</a> there is a work-around for static initialization of lambda functions. One of the steps mention dereferencing a nullptr of pointer to lambda function type.</p>\n<pre><code>template &lt;typename T&gt; typename std::remove_reference &lt;T&gt;::type * addr (T &amp;&amp; t)\n{\n    return &amp; t;\n}\n\nconstexpr auto f = true ? nullptr : addr ([] (int arg) { return arg + 1; });\n\nint main ()\n{\n    assert (((*f) (1) == 2));\n}\n</code></pre>\n<p>Going through the spec and another question <a href=\"https://stackoverflow.com/questions/38615436/c-c-nullptr-dereference\">C/C++ nullptr dereference</a> I have trouble understanding whether <code>*f</code> is undefined behaviour or not. What sections in the spec would make this <em>not</em> undefined behaviour?</p>\n", "Tags": "<c++11><lambda><static-initialization>", "OwnerUserId": "5740196", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_41352132_41352253_2": {"section_id": 5890, "quality": 1.0, "length": 11}}, "n3337": {"so_41352132_41352253_2": {"section_id": 5661, "quality": 1.0, "length": 11}}, "n4659": {"so_41352132_41352253_2": {"section_id": 7373, "quality": 1.0, "length": 11}}}, "41352253": {"ParentId": "41352132", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_41352132_41352253_0\">What sections in the spec would make this not undefined behaviour?</p>\n</blockquote>\n<p>That's the wrong question to ask. There's no program where one part of the standard explicitly says it's undefined, and another part of the standard says it's defined anyway.</p>\n<p>The question you link to is about taking the address of a dereferenced null pointer. That's not what you're doing here. What you're doing here is calling a member function through a null pointer. <code>(*f) (1)</code> means <code>f-&gt;operator() (1)</code>. That's explicitly invalid, will fail at run-time with GCC or clang if <code>-fsanitize=undefined</code> option, and may otherwise cause unpredictable behaviour due to the optimiser assuming <code>f != null</code>.</p>\n<p>Quoting from N4140 (roughly C++14), but it's not different in other versions of the standard:</p>\n<blockquote>\n<p id=\"so_41352132_41352253_1\"><strong>9.3.1 Nonstatic member functions [class.mfct.non-static]</strong></p>\n<p id=\"so_41352132_41352253_2\">2 If a non-static member function of a class <code>X</code> is called for an object that is not of type <code>X</code>, or of a type derived from <code>X</code>, the behavior is undefined.</p>\n</blockquote>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "41352253", "Score": "3", "CreationDate": "2016-12-27T21:08:35.987", "LastActivityDate": "2016-12-27T21:08:35.987"}});