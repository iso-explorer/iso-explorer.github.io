post_cb({"bq_ids": {"n4140": {"so_30020005_30020407_1": {"length": 9, "quality": 0.6923076923076923, "section_id": 4701}, "so_30020005_30020407_2": {"length": 9, "quality": 0.9, "section_id": 7217}, "so_30020005_30020407_3": {"length": 33, "quality": 0.9428571428571428, "section_id": 6299}, "so_30020005_30020407_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 4699}}, "n3337": {"so_30020005_30020407_3": {"length": 33, "quality": 0.9428571428571428, "section_id": 6056}, "so_30020005_30020407_2": {"length": 9, "quality": 0.9, "section_id": 6961}, "so_30020005_30020407_1": {"length": 9, "quality": 0.6923076923076923, "section_id": 4510}, "so_30020005_30020407_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 4508}}, "n4659": {"so_30020005_30020407_3": {"length": 33, "quality": 0.9428571428571428, "section_id": 7808}, "so_30020005_30020407_2": {"length": 7, "quality": 0.7, "section_id": 8726}, "so_30020005_30020407_1": {"length": 7, "quality": 0.5384615384615384, "section_id": 6097}, "so_30020005_30020407_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 6095}}}, "30020005": {"ViewCount": "170", "Body": "<p>I'm implementing a function as follows:</p>\n<pre><code>template &lt;typename FP&gt;\nvoid do_something(FP f){\n    static_assert(std::is_floating_point&lt;FP&gt;::value, \"not a floating point\");\n    ...\n}\n</code></pre>\n<p>In this context, any floating point can be used (native or custom, i.e. multi-precision float libraries).</p>\n<p>I wonder if standard states anything about what to expect from types overloading the is_floating_point. Can I count for them being required to work with FENV?</p>\n<p>Can I assume the following code should work properly if a custom floating point implementation is overloading the std::is_floating_point?</p>\n<pre><code>template &lt;typename FP&gt;\nvoid do_something(FP f){\n    static_assert(std::is_floating_point&lt;FP&gt;::value, \"not a floating point\");\n    if (std::fetestexcept(FE_DIVBYZERO)){\n        ...\n    }\n}\n</code></pre>\n", "AcceptedAnswerId": "30020407", "Title": "Are all types extending std::is_floating_point required to implement FENV in C++11 standard?", "CreationDate": "2015-05-03T22:12:45.613", "Id": "30020005", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-05-03T23:08:41.050", "Score": "0", "OwnerUserId": "861649", "Tags": "<c++11><floating-point><standards>", "AnswerCount": "1"}, "30020407": {"Id": "30020407", "PostTypeId": "2", "Body": "<p>There ain't no such thing as a \"custom floating point type\", as far as <code>std::is_floating_point</code> is concerned.</p>\n<blockquote>\n<p id=\"so_30020005_30020407_0\"><strong>20.10.4.1/1</strong> The primary type categories correspond to the descriptions given in section 3.9 of the C++ standard.</p>\n<p id=\"so_30020005_30020407_1\"><strong>Table 47</strong> \u2014 Primary type category predicates\n  <code>template &lt;class T&gt; struct is_floating_point;</code> <code>T</code> is a floating point type (3.9.1)</p>\n<p id=\"so_30020005_30020407_2\"><strong>3.9.1/8</strong> There are three <em>floating point types</em>: <code>float</code>, <code>double</code>, and <code>long double</code>.</p>\n<p id=\"so_30020005_30020407_3\"><strong>17.6.4.2.1/1</strong> The behavior of a C++ program is undefined if it adds declarations or definitions to namespace <code>std</code> or to a namespace within namespace <code>std</code> unless otherwise specified. A program may add a template specialization for any standard library template to namespace <code>std</code> only if the declaration depends on a user-defined type and the specialization meets the standard library requirements for the original template and is not explicitly prohibited.</p>\n</blockquote>\n", "LastActivityDate": "2015-05-03T23:08:41.050", "CommentCount": "1", "CreationDate": "2015-05-03T23:08:41.050", "ParentId": "30020005", "Score": "2", "OwnerUserId": "1670129"}});