post_cb({"bq_ids": {"n4140": {"so_24708594_24708787_0": {"length": 38, "quality": 0.8837209302325582, "section_id": 7216}}, "n3337": {"so_24708594_24708787_0": {"length": 38, "quality": 0.8837209302325582, "section_id": 6960}}, "n4659": {"so_24708594_24708787_0": {"length": 38, "quality": 0.8837209302325582, "section_id": 8725}}}, "24708594": {"ViewCount": "816", "Body": "<p>Say I want to send 4 byte integer over network. The integer has fixed size, due to using types from <code>stdint</code>.\nMy question is: Does it matter if I try to send either signed or unsigned integer using these 4 bytes? (assuming I use same method to serialize/deserialize the integer to/from bytes, both on client and server side). Can there be some other problems? (I don't refer to endianness issues either)</p>\n", "AcceptedAnswerId": "24708787", "Title": "send int over socket: signed vs unsigned", "CreationDate": "2014-07-12T00:58:39.153", "Id": "24708594", "CommentCount": "3", "LastEditDate": "2014-07-12T01:04:56.600", "PostTypeId": "1", "LastEditorDisplayName": "user2793162", "OwnerDisplayName": "user2793162", "LastActivityDate": "2014-07-12T02:00:37.057", "Score": "3", "Tags": "<c++><c>", "AnswerCount": "3"}, "24708883": {"Id": "24708883", "PostTypeId": "2", "Body": "<p>This issue seldom gets the attention it deserves.</p>\n<p>As Floris observes, only the bytes of the representation get sent. C and C++ define the bitwise representation* of unsigned numbers, but not signed ones, so sending signed numbers as bytes opens a compatibility gap.</p>\n<p>It's easy to \"fix\" the format for transmission. Casting a signed int to its corresponding unsigned type is guaranteed to generate two's complement representation. But how to convert back? Casting an unsigned integer to its signed counterpart will generate integer overflow when you want negative number, and integer overflow is unsigned behavior.</p>\n<p>To be really safe, use a branch:</p>\n<pre><code>signed int deserialize_sint( unsigned int nonnegative ) {\n    if ( nonnegative &lt; INT_MAX ) return nonnegative;\n    else return - (int) ( - nonnegative ); // Only cast an unsigned number &lt; INT_MAX\n}\n</code></pre>\n<p>With luck, the compiler will see that both cases are the same and eliminate the branch.</p>\n<p>The above function is written in C; apologies to the C++ crowd.</p>\n<p>If you want to be extra paranoid, you could check <code>- nonnegative &lt; INT_MAX</code> before performing the cast, because the most negative number in a two's complement will still overflow a one's complement machine. The best you can do for the case of <code>nonnegative == - nonnegative</code> is to return a wider type, or if that's impossible, flag a runtime error.</p>\n<p><sub>* Endianness becomes ambiguous when the bits are divided into a byte sequence, though.</sub></p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2014-07-12T02:00:37.057", "Score": "1", "CreationDate": "2014-07-12T01:55:26.927", "ParentId": "24708594", "CommentCount": "0", "OwnerUserId": "153285", "LastEditDate": "2014-07-12T02:00:37.057"}, "24708633": {"Id": "24708633", "PostTypeId": "2", "Body": "<p>When you send a number over a socket, it's just bytes.</p>\n<p>Now if you want to send a negative number, <strong>and the representation of negative numbers is different at the receiving end</strong>, then you might have a problem. Otherwise, it's just bytes.</p>\n<p>So if there is a chance that the binary representation of the negative number would be misunderstood at the receiving end, then you need to do some translating (maybe send a sign byte followed by four magnitude bytes, and put it all together at the other end).</p>\n<p>That's quite unlikely though.</p>\n", "LastActivityDate": "2014-07-12T01:07:55.820", "CommentCount": "5", "CreationDate": "2014-07-12T01:07:55.820", "ParentId": "24708594", "Score": "3", "OwnerUserId": "1967396"}, "24708787": {"Id": "24708787", "PostTypeId": "2", "Body": "<p>Because the standard does not mandate a particular representation for signed types:</p>\n<h3>3.9.1 Fundamental types [basic.fundamental] Paragraph 7 of n3936</h3>\n<blockquote>\n<p id=\"so_24708594_24708787_0\">Types bool, char, char16_t, char32_t, wchar_t, and the signed and unsigned integer types are collectively called integral types. A synonym for integral type is integer type. The representations of integral types shall define values by use of a pure binary numeration system. [ Example: this International Standard <b>permits 2\u2019s complement, 1\u2019s complement and signed magnitude representations for integral types</b>. \u2014end example ]</p>\n</blockquote>\n<p>Sending signed integer values in a binary representation is not well defined (unless you explicitly specify this as part of your protocol and do some manual work to make sure you know how to read/write that binary representation).</p>\n<p>There are a couple of solutions depending on the exact requirements.</p>\n<ul>\n<li>If speed is not primary concern then you could use an English (substitute language of your choice) representation and serialize integers to/from text. For a lot of problems this is not a bad solution as the major speed bump is not the serialization cost but network latency. Network latency is the major problem in most situations (but not always).</li>\n<li>So alternatively if you need binary representation (because you timed it and the volume/density of your numbers requires it). Then the endianess problem is not hard to solve because of <code>htonl()</code> and family. Which covers all unsigned integral types (well at least 16/32 bit values). \n<ul>\n<li>So all you really need to solve is the representation of signed values. So pick one (Use the most common representation for the machines you use and the translation will then usually be a no-op). But if you know the on the wire representation (because it is specified in your protocol), then you can translate to/from this representation (usually this cost is small (a conditional addition)) on machines that do not natively support this representation.</li>\n</ul></li>\n</ul>\n", "LastEditorUserId": "14065", "LastActivityDate": "2014-07-12T01:43:38.897", "Score": "2", "CreationDate": "2014-07-12T01:37:37.040", "ParentId": "24708594", "CommentCount": "4", "OwnerUserId": "14065", "LastEditDate": "2014-07-12T01:43:38.897"}});