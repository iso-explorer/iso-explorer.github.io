post_cb({"13692176": {"ParentId": "13692112", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You can't mix-and-match either way. If you do, you have undefined behaviour (\u00a75.3.5/2):</p>\n<blockquote>\n<p id=\"so_13692112_13692176_0\"><strong>In the first alternative</strong> (<em>delete object</em>), the value of the operand of <code>delete</code> may be a null pointer value, a <strong>pointer to a non-array object created by a previous <em>new-expression</em></strong>, or a pointer to a subobject (1.8) representing a base class of such an object (Clause 10). If not, the behavior is undefined.</p>\n<p id=\"so_13692112_13692176_1\"><strong>In the second alternative</strong> (<em>delete array</em>), the value of the operand of <code>delete</code> may be a null pointer value or a <strong>pointer value that resulted from a previous array <em>new-expression</em></strong>. If not, the behavior is undefined.</p>\n</blockquote>\n<p>(bold emphasis is mine)</p>\n", "OwnerUserId": "150634", "LastEditorUserId": "150634", "LastEditDate": "2012-12-03T21:43:25.853", "Id": "13692176", "Score": "3", "CreationDate": "2012-12-03T21:38:19.037", "LastActivityDate": "2012-12-03T21:43:25.853"}, "13692181": {"ParentId": "13692112", "CommentCount": "0", "Body": "<p><code>k[i]</code> is an <code>int</code>, so it's <strong>syntactically invalid</strong> to call <code>delete</code> on it. The compiler should raise an error.</p>\n<p>Even if you could, it would result in undefined behavior (saying you have an array of pointers which you allocate with <code>new[]</code> and attempt to delete it with <code>delete</code>). Mixing <code>new[]</code> with <code>delete</code> and <code>new[]</code> with <code>delete</code> results in UB.</p>\n", "OwnerUserId": "673730", "PostTypeId": "2", "Id": "13692181", "Score": "6", "CreationDate": "2012-12-03T21:38:31.080", "LastActivityDate": "2012-12-03T21:38:31.080"}, "13692112": {"CommentCount": "4", "ViewCount": "225", "PostTypeId": "1", "LastEditorUserId": "970171", "CreationDate": "2012-12-03T21:34:41.443", "LastActivityDate": "2012-12-03T21:50:23.593", "Title": "If I allocate an a array of objects with operator new[] in C++ but deallocate them individually does it still constitute a memory leak?", "AcceptedAnswerId": "13692181", "LastEditDate": "2012-12-03T21:50:23.593", "Id": "13692112", "Score": "2", "Body": "<p>I know one is supposed to not mix and match new[] with delete and vice versa (delete[] with new). So</p>\n<pre><code>int* k = new int[5];\ndelete k;\n</code></pre>\n<p>is flawed as it will not free the allocated array. But is the following wrong?</p>\n<pre><code>int *k = new int[5];\nfor (int i = 0; i &lt; 5; ++i)\n    delete k[i];\n</code></pre>\n<p>by wrong I mean - will it actually cause a memory leak or undefined behavior?</p>\n<p>EDIT** My bad, what I meant to type was this:</p>\n<pre><code>int** k = new int*[5];\nmemset(k, 0, sizeof(int*)*5);\n\nk[3] = new int;\n\nfor (int i = 0; i &lt; 5; ++i)\n    if (k[i])\n    {\n        delete k[i];\n        k[i] = 0;\n    }\n</code></pre>\n<p>In the above, the block of 5 places is never actually freed unless i call delete[] on <code>k</code> itself, though I can new/delete manage the ints inside of it.</p>\n", "Tags": "<c++><memory><memory-management><memory-leaks>", "OwnerUserId": "970171", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_13692112_13692176_1": {"section_id": 6106, "quality": 0.9473684210526315, "length": 18}, "so_13692112_13692176_0": {"section_id": 6106, "quality": 0.9629629629629629, "length": 26}}, "n3337": {"so_13692112_13692176_1": {"section_id": 5872, "quality": 0.9473684210526315, "length": 18}, "so_13692112_13692176_0": {"section_id": 5872, "quality": 0.9629629629629629, "length": 26}}, "n4659": {"so_13692112_13692176_1": {"section_id": 7603, "quality": 0.9473684210526315, "length": 18}, "so_13692112_13692176_0": {"section_id": 7603, "quality": 0.9629629629629629, "length": 26}}}});