post_cb({"17636690": {"CommentCount": "3", "AcceptedAnswerId": "17636736", "PostTypeId": "1", "LastEditorUserId": "1058591", "CreationDate": "2013-07-14T05:06:42.793", "LastActivityDate": "2015-11-22T14:01:02.197", "LastEditDate": "2014-03-13T19:31:51.210", "ViewCount": "1814", "FavoriteCount": "4", "Title": "Nice way to append a vector to itself", "Id": "17636690", "Score": "15", "Body": "<p>I want to duplicate the contents of the vector and want them to be appended at the end of the original vector i.e. <code>v[i]=v[i+n] for i=0,2,...,n-1</code></p>\n<p>I am looking for a nice way to do it, not with a loop. I saw <code>std::vector::insert</code> but the iterative version forbids a iterator to <code>*this</code>(i.e behaviour is undefined).</p>\n<p>I also tried <code>std::copy</code> as follows(but it resulted in segmentation fault):</p>\n<p><code>copy( xx.begin(), xx.end(), xx.end());</code></p>\n", "Tags": "<c++><c++11><stl><stdvector>", "OwnerUserId": "1317240", "AnswerCount": "4"}, "17636736": {"ParentId": "17636690", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Wow.  So many answers that are close, none with all the right pieces.  You need both <code>resize</code> (or <code>reserve</code>) and <code>copy_n</code>, along with remembering the original size.</p>\n<pre><code>auto old_count = xx.size();\nxx.resize(2 * old_count);\nstd::copy_n(xx.begin(), old_count, xx.begin() + old_count);\n</code></pre>\n<p>or</p>\n<pre><code>auto old_count = xx.size();\nxx.reserve(2 * old_count);\nstd::copy_n(xx.begin(), old_count, std::back_inserter(xx));\n</code></pre>\n<p>When using <code>reserve</code>, <code>copy_n</code> is required because the <code>end()</code> iterator points one element past the end... which means it also is not \"before the insertion point\" of the first insertion, and becomes invalid.</p>\n<hr>\n<p>23.3.6.5 <code>[vector.modifiers]</code> promises that for <code>insert</code> and <code>push_back</code>: </p>\n<blockquote>\n<p id=\"so_17636690_17636736_0\"><em>Remarks:</em> Causes reallocation if the new size is greater than the old capacity. <strong>If no reallocation happens, all the iterators and references before the insertion point remain valid.</strong> If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move assignment operator of T or by any InputIterator operation there are no effects. If an exception is thrown by the move constructor of a non-CopyInsertable T, the e\ufb00ects are unspecified.</p>\n</blockquote>\n</hr>", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2014-03-13T18:34:47.570", "Id": "17636736", "Score": "22", "CreationDate": "2013-07-14T05:16:54.093", "LastActivityDate": "2014-03-13T18:34:47.570"}, "17636791": {"ParentId": "17636690", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>I would do it like this:</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;utility&gt;\n\nint main(int argc, char* argv[])\n{\n    std::vector&lt;int&gt; v1 = { 1, 2, 3, 4, 5 };\n\n    {\n        std::vector&lt;int&gt; v2(v1.begin(), v1.end());\n        std::copy(v1.begin(), v1.end(), std::back_inserter(v2));\n        std::swap(v1, v2);\n    }\n\n    return 0;\n}\n</code></pre>\n<p>EDIT: I added a slightly more efficient version.</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n#include &lt;utility&gt;\n\nint main(int argc, char* argv[])\n{\n    std::vector&lt;int&gt; v1 = { 1, 2, 3, 4, 5 };\n\n    {\n        typedef std::move_iterator&lt;decltype(v1)::iterator&gt; VecMoveIter;\n        std::vector&lt;int&gt; v2(v1);\n        std::copy(VecMoveIter(v1.begin()), VecMoveIter(v1.end()), std::back_inserter(v2));\n        v1 = std::move(v2);\n    }\n\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "583833", "LastEditorUserId": "583833", "LastEditDate": "2013-07-14T16:02:51.687", "Id": "17636791", "Score": "3", "CreationDate": "2013-07-14T05:29:17.303", "LastActivityDate": "2013-07-14T16:02:51.687"}, "24869342": {"ParentId": "17636690", "CommentCount": "0", "Body": "<p>For appending more than one slot of duplicates.</p>\n<pre><code>    int main() {\n        std::vector&lt;int&gt; V;\n        V.push_back(1);\n        V.push_back(2);\n\n        int oldSize = V.size();\n        int newSize = oldSize;\n        int nDupSlot = 4;\n\n        V.resize(nDupSlot * oldSize);\n        for(int i=0; i&lt;(nDupSlot-1); ++i) {\n            std::copy_n(V.begin(), oldSize, V.begin() + newSize);       \n            newSize = newSize + oldSize;\n         }\n\n        for(int i =0; i&lt;V.size(); ++i) {\n            std::cout&lt;&lt;V[i];\n            }\n\n        return 0;\n    }\n</code></pre>\n<p>Output:</p>\n<pre><code>12121212\n</code></pre>\n", "OwnerUserId": "1308589", "PostTypeId": "2", "Id": "24869342", "Score": "0", "CreationDate": "2014-07-21T15:53:13.453", "LastActivityDate": "2014-07-21T15:53:13.453"}, "33855607": {"ParentId": "17636690", "CommentCount": "0", "Body": "<p>It might not be the most effective way, but it sure is simple:</p>\n<pre><code>std::vector&lt;int&gt; toAppend(xx);\nxx.insert(xx.end(), toAppend.begin(), toAppend.end();\n</code></pre>\n", "OwnerUserId": "5577677", "PostTypeId": "2", "Id": "33855607", "Score": "0", "CreationDate": "2015-11-22T14:01:02.197", "LastActivityDate": "2015-11-22T14:01:02.197"}, "bq_ids": {"n4140": {"so_17636690_17636736_0": {"section_id": 986, "quality": 0.9534883720930233, "length": 41}}, "n3337": {"so_17636690_17636736_0": {"section_id": 971, "quality": 0.9534883720930233, "length": 41}}, "n4659": {"so_17636690_17636736_0": {"section_id": 1049, "quality": 0.9534883720930233, "length": 41}}}});