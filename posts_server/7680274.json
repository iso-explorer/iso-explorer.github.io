post_cb({"7680317": {"ParentId": "7680274", "LastEditDate": "2011-10-06T21:56:42.617", "CommentCount": "14", "CreationDate": "2011-10-06T20:51:21.550", "OwnerUserId": "596781", "LastEditorUserId": "596781", "PostTypeId": "2", "Id": "7680317", "Score": "4", "Body": "<p>Write this:</p>\n<pre><code>template &lt;typename T&gt; class TestA\n{\n  operator const int();\n};\n\ntemplate &lt;typename T&gt; TestA&lt;T&gt;::operator const int()\n{\n  return 10;\n}\n</code></pre>\n<p>The standard antonym of \"inline\" is usually \"out of line\", by the way. Also, I'd probably make the function <code>const</code>, as one usually does with conversion operators (to allow conversions from constant objects).</p>\n<p>You can either specialize the entire class, or just the member function. For the member function only, write this:</p>\n<pre><code>template &lt;&gt; TestA&lt;int&gt;::operator const int() { /* ... */ }\n</code></pre>\n<p>For the entire class specialization, the syntax is this:</p>\n<pre><code>template &lt;&gt; class TestA&lt;int&gt;\n{\n  operator const int();\n};\nTestA&lt;int&gt;::operator const int() { /*...*/ }\n</code></pre>\n", "LastActivityDate": "2011-10-06T21:56:42.617"}, "7680333": {"ParentId": "7680274", "LastEditDate": "2011-10-06T20:59:53.400", "CommentCount": "1", "CreationDate": "2011-10-06T20:52:55.417", "OwnerUserId": "845092", "LastEditorUserId": "845092", "PostTypeId": "2", "Id": "7680333", "Score": "1", "Body": "<p>I don't think you can specialize a non-template function of a template class without specializing the whole class.  Which means you have to cheat.  Simplist way is to move most of the implementation to a \"Base\" class, (everything that the two share), and have TestA inherit from that base class, and only define the functions that need specializing.</p>\n<pre><code> //general base\ntemplate&lt;typename TemplateItem&gt;\nclass TestABase\n{\nprotected:\n    TemplateItem data;\n};\n//non specialized members\ntemplate&lt;typename TemplateItem&gt;\nclass TestA: public TestABase&lt;TemplateItem&gt;\n{\npublic:\n    operator const int ();\n};\n//specialized members\ntemplate&lt;&gt;\nclass TestA&lt;int&gt; : public TestABase&lt;TemplateItem&gt;\n{\npublic:\n    operator const int ();\n};\n\n\n//implementations\ntemplate&lt;typename TemplateItem&gt;\nTestA&lt;TemplateItem&gt;::operator const int()\n{\n   return data;\n}\ntemplate&lt;&gt;\nTestA&lt;int&gt;::operator const int()\n{\n   return data;\n}\n</code></pre>\n", "LastActivityDate": "2011-10-06T20:59:53.400"}, "bq_ids": {"n4140": {"so_7680274_7680681_1": {"section_id": 104, "quality": 0.9, "length": 9}, "so_7680274_7680681_0": {"section_id": 104, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_7680274_7680681_1": {"section_id": 99, "quality": 0.9, "length": 9}, "so_7680274_7680681_0": {"section_id": 99, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_7680274_7680681_1": {"section_id": 108, "quality": 0.9, "length": 9}, "so_7680274_7680681_0": {"section_id": 108, "quality": 0.9166666666666666, "length": 11}}}, "7680681": {"ParentId": "7680274", "LastEditDate": "2011-10-06T22:00:51.513", "CommentCount": "0", "CreationDate": "2011-10-06T21:29:39.427", "OwnerUserId": "636019", "LastEditorUserId": "636019", "PostTypeId": "2", "Id": "7680681", "Score": "1", "Body": "<p>First off, declare and define the primary templates as follows:</p>\n<pre><code>template&lt;typename T&gt;\nclass TestA\n{\npublic:\n    operator int() const;\n};\n\ntemplate&lt;typename T&gt;\nTestA&lt;T&gt;::operator int() const\n{\n    return -1;\n}\n</code></pre>\n<p>Regarding specialization, the C++03 standard \u00a714.5.1.1/1 tells us that non-template member functions (and constructors!) of a class template are themselves considered function templates:</p>\n<blockquote>\n<p id=\"so_7680274_7680681_0\">A member function of a class template may be defined outside of the class template definition in which it is declared. [<em>Example:</em></p>\n<pre><code>template&lt;class T&gt; class Array {\n    T* v;\n    int sz;\npublic:\n    explicit Array(int);\n    T&amp; operator[](int);\n    T&amp; elem(int i) { return v[i]; }\n    // ...\n};\n</code></pre>\n<p id=\"so_7680274_7680681_1\">declares three function templates. The subscript function might be defined like this:</p>\n<pre><code>template&lt;class T&gt; T&amp; Array&lt;T&gt;::operator[](int i)\n{\n    if (i&lt;0 || sz&lt;=i) error(\"Array: range error\");\n    return v[i];\n}\n</code></pre>\n<p id=\"so_7680274_7680681_2\"><em>\u2014end example</em>]</p>\n</blockquote>\n<p>Consequently, they can be specialized <em>without</em> also specializing the rest of the primary class template (unlike if you were to specialize, explicitly or partially, the class template itself):</p>\n<pre><code>template&lt;&gt;\nTestA&lt;int&gt;::operator int() const\n{\n    return 5;\n}\n\ntemplate&lt;&gt;\nTestA&lt;double&gt;::operator int() const\n{\n    return 3;\n}\n</code></pre>\n<p><strong><a href=\"http://ideone.com/dEXNZ\" rel=\"nofollow\">Full demo</a></strong></p>\n", "LastActivityDate": "2011-10-06T22:00:51.513"}, "7680274": {"CommentCount": "2", "ViewCount": "2376", "CreationDate": "2011-10-06T20:46:57.777", "LastActivityDate": "2011-10-06T22:00:51.513", "Title": "How do I externalise the conversion operator?", "AcceptedAnswerId": "7680317", "PostTypeId": "1", "Id": "7680274", "Score": "4", "Body": "<p>How do I make it so the following code is externalised outside the class:</p>\n<pre><code>template&lt;typename TemplateItem&gt;\nclass TestA\n{\n     operator const int (){return 10;}\n};\n</code></pre>\n<p>So it appears like:</p>\n<pre><code>template&lt;typename TemplateItem&gt;\nclass TestA\n{\n    operator const int ();\n};\n\ntemplate&lt;&gt;\nTestA&lt;int&gt;::operator const int()\n{\n    //etc etc\n}\n</code></pre>\n<p>So I can specialise the function for different templated types?</p>\n", "Tags": "<c++><class>", "OwnerUserId": "889894", "AnswerCount": "3"}});