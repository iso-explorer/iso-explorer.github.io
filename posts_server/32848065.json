post_cb({"32848065": {"ViewCount": "627", "Body": "<p>In C++11, is there a clean way to disable implicit conversion between typedefs, or do you have to do something nasty like wrap your int in a class and define and delete various operators? </p>\n<pre><code>typedef int Foo;\ntypedef int Bar;\nFoo foo(1);\nBar bar(2);\nbar = foo; // Implicit conversion!\n</code></pre>\n", "Title": "Disable implicit conversion between typedefs", "CreationDate": "2015-09-29T15:31:16.050", "LastActivityDate": "2016-11-29T23:44:05.207", "CommentCount": "12", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-09-29T15:33:46.090", "LastEditorUserId": "1491895", "Id": "32848065", "Score": "11", "OwnerUserId": "139802", "Tags": "<c++><types><typedef>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_32848065_32848342_1": {"length": 37, "quality": 1.0, "section_id": 5407}}, "n3337": {"so_32848065_32848342_1": {"length": 37, "quality": 1.0, "section_id": 5202}}, "n4659": {"so_32848065_32848342_1": {"length": 37, "quality": 1.0, "section_id": 6829}}}, "32848342": {"Id": "32848342", "PostTypeId": "2", "Body": "<p>The C++ standard says:</p>\n<blockquote>\n<p id=\"so_32848065_32848342_0\"><strong>7.1.3 The typedef specifier</strong></p>\n<p id=\"so_32848065_32848342_1\">A name declared with the typedef specifier becomes a typedef-name. Within the scope of its declaration, a typedef-name is <strong>syntactically equivalent to a keyword and names the type associated with the identifier</strong> in\n  the way described in Clause 8. A typedef-name is <strong>thus a synonym for another type. A typedef-name does\n  not introduce a new type the way a class declaration</strong> (9.1) or enum declaration does</p>\n</blockquote>\n<p>But e.g. <code>class</code> or <code>struct</code> introduce new types. In the following example <code>uniqueUnused</code> does actually nothing but is used to create a different type <code>Value&lt;int, 1&gt; != Value&lt;int, 2&gt;</code>. So maybe this is something you are looking for. <em>Keep in mind there is no guarantee the compiler gets rid of the outer structure! The only guarantee this code gives you it's the same size as int</em></p>\n<pre><code>template&lt;typename T, int uniqueUnused&gt;\nstruct Value\n{\n  Value() : _val({}) {}\n  Value(T val) : _val(val) { }\n  T _val;\n  operator T&amp;() { return _val; }\n\n  // evaluate if you with or without refs for assignments\n  operator T() { return _val; }\n};\n\nusing Foo = Value&lt;int, 1&gt;;\nusing Bar = Value&lt;int, 2&gt;;\nstatic_assert(sizeof(Foo) == sizeof(int), \"int must be of same size\");\nstatic_assert(sizeof(Bar) == sizeof(int), \"int must be of same size\");\n</code></pre>\n<p>If you want to create a new type based on a class you can simply go with this example (this doesn't work with scalar types since you can't inherit from ints):</p>\n<pre><code>class Foo : public Bar // introduces a new type called Foo\n{\n    using Bar::Bar;\n};\n</code></pre>\n", "LastEditorUserId": "1385931", "LastActivityDate": "2015-09-29T15:50:47.867", "Score": "5", "CreationDate": "2015-09-29T15:43:21.953", "ParentId": "32848065", "CommentCount": "0", "OwnerUserId": "1385931", "LastEditDate": "2015-09-29T15:50:47.867"}, "40877827": {"Id": "40877827", "PostTypeId": "2", "Body": "<p>It's not strict type-checking, but illegal conversions can made <strong>visible</strong> by using original, or <em>Apps Hungarian Notation</em> (H. N.). If you think H. N. means name-type-as-prefix, you're wrong (it's <em>System H. N.</em>, and it's, hm, unnecessary naming overhead).</p>\n<p>Using the (Apps) H. N., the variable prefix marks not the type (e.g. <em>int</em>), but the purpose, e.g. counter, length, seconds etc. So, when you add a counter to a variable contains elapsed time, you write <code>cntSomethingCounter + secElapsedSinceLastSomething</code>, and you can see that it smells. Compiler does not alerts, but it pokes your eyes.</p>\n<p>Read more: <a href=\"http://www.joelonsoftware.com/articles/Wrong.html\" rel=\"nofollow noreferrer\">http://www.joelonsoftware.com/articles/Wrong.html</a></p>\n", "LastActivityDate": "2016-11-29T23:44:05.207", "CommentCount": "0", "CreationDate": "2016-11-29T23:44:05.207", "ParentId": "32848065", "Score": "-1", "OwnerUserId": "185881"}, "32848482": {"Id": "32848482", "PostTypeId": "2", "Body": "<p><a href=\"https://stackoverflow.com/a/32848342/2069064\">HelloWorld</a> explains why what you have cannot work. You'll need what's typically called a \"strong\" <code>typedef</code> to do what you want. An example implementation is <a href=\"http://www.boost.org/doc/libs/1_59_0/libs/serialization/doc/strong_typedef.html\" rel=\"nofollow noreferrer\"><code>BOOST_STRONG_TYPEDEF</code></a>:</p>\n<pre><code>#include &lt;boost/serialization/strong_typedef.hpp&gt;    \n\nBOOST_STRONG_TYPEDEF(int, a)\nvoid f(int x);  // (1) function to handle simple integers\nvoid f(a x);    // (2) special function to handle integers of type a \nint main(){\n    int x = 1;\n    a y;\n    y = x;      // other operations permitted as a is converted as necessary\n    f(x);       // chooses (1)\n    f(y);       // chooses (2)\n}\n</code></pre>\n<p>If we had done <code>typedef int a;</code>, then the code would be ambiguous. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-09-29T15:50:28.910", "Score": "4", "CreationDate": "2015-09-29T15:50:28.910", "ParentId": "32848065", "CommentCount": "4", "OwnerUserId": "2069064", "LastEditDate": "2017-05-23T12:09:59.617"}});