post_cb({"10618726": {"Id": "10618726", "PostTypeId": "2", "Body": "<p>If I'm not mistaken <code>reinterpret_cast</code> is not a portable operation.</p>\n", "LastEditorUserId": "1033896", "LastActivityDate": "2012-05-16T12:42:08.777", "Score": "0", "CreationDate": "2012-05-16T12:39:26.813", "ParentId": "10618473", "CommentCount": "1", "OwnerUserId": "940285", "LastEditDate": "2012-05-16T12:42:08.777"}, "10618603": {"Id": "10618603", "PostTypeId": "2", "Body": "<p>As for the assumption, that multidimensional arrays have continuous memory layout it is standards conformant and portable. It is true ever since the times of C, and C++ does not change this.</p>\n<p>However, <code>reinterpret_cast</code> isn't portable, so overall your code isn't guaranteed to work everywhere.</p>\n", "LastEditorUserId": "1265432", "LastActivityDate": "2012-05-16T21:23:13.813", "Score": "0", "CreationDate": "2012-05-16T12:32:43.913", "ParentId": "10618473", "CommentCount": "3", "OwnerUserId": "1265432", "LastEditDate": "2012-05-16T21:23:13.813"}, "10618473": {"ViewCount": "790", "Body": "<p>First of all, sorry for my english if i make any grammar mistakes, etc ...  </p>\n<p>My question is, that when we have a two dimensional array, then if i am right, from the point of the computer and C/C++, it's just a long one dimensional array, the indices are just helping the compiler to map to the concrete address.  </p>\n<p>This code fragment works in Visual C++, however I would like to know, whether this code is <strong>portable</strong> and <strong>conforms</strong> <em>to the</em> <strong>standard</strong> (C++98), not causing surprises on other architectures and/or operating systems:</p>\n<pre><code>int arr[][3] = { 1, 5, 3, 7, 5, 2, 7, 8, 9 };\nconst int ARR_NUM = sizeof(arr) / sizeof(int);\n\nint* ptr = reinterpret_cast&lt;int*&gt;(arr);    // NOT: int(*)[][3] !!!\nfor (int i = 0; i &lt; ARR_NUM; ++i) {\n    cout &lt;&lt; ptr[i] &lt;&lt; endl;\n}\n</code></pre>\n", "AcceptedAnswerId": "10618866", "Title": "Is this C++ code portable? (assuming multidimensional arrays have continuous memory layout)", "CreationDate": "2012-05-16T12:26:02.910", "Id": "10618473", "CommentCount": "8", "LastEditDate": "2012-05-16T18:07:06.463", "PostTypeId": "1", "LastEditorUserId": "553846", "LastActivityDate": "2012-05-16T21:23:13.813", "Score": "18", "OwnerUserId": "553846", "Tags": "<c++><arrays><memory><multidimensional-array><portability>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_10618473_10618866_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 6040}, "so_10618473_10618866_0": {"length": 10, "quality": 1.0, "section_id": 3228}}, "n3337": {"so_10618473_10618866_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5808}, "so_10618473_10618866_0": {"length": 10, "quality": 1.0, "section_id": 3101}}, "n4659": {"so_10618473_10618866_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 7539}, "so_10618473_10618866_0": {"length": 10, "quality": 1.0, "section_id": 3985}}}, "10618931": {"Id": "10618931", "PostTypeId": "2", "Body": "<p>If you want to be really strict, reinterpret_cast is not terribly well defined in the standard. This will work everywhere, but you could make a pedantic case against it.</p>\n<p>Use</p>\n<pre><code>int *ptr = arr[0];\n</code></pre>\n<p>to be on the very safe side. The contiguous array layout is guaranteed.</p>\n", "LastActivityDate": "2012-05-16T12:49:52.073", "CommentCount": "0", "CreationDate": "2012-05-16T12:49:52.073", "ParentId": "10618473", "Score": "4", "OwnerUserId": "1398647"}, "10618866": {"Id": "10618866", "PostTypeId": "2", "Body": "<h2>Standardese</h2>\n<p>The elements of the multidimensional array are stored sequentially in row-major order, so the manual indexing is portable:</p>\n<p>C++98, 8.3.4/1:</p>\n<blockquote>\n<p id=\"so_10618473_10618866_0\">An object of array type contains a contiguously allocated non-empty\n  set of N sub-objects of type T.</p>\n</blockquote>\n<p>Obviously for a multidimensional array this applies recursively.</p>\n<p>However, this use of <code>reinterpret_cast</code> is not portable. The standard says (C++98, 5.2.10/1) that</p>\n<blockquote>\n<p id=\"so_10618473_10618866_1\">[...] otherwise, the result is an rvalue and the [...],\n  array-to-pointer, [...] standard conversions are performed on the\n  expression v.</p>\n</blockquote>\n<p>In other words, passing <code>arr</code> immediately triggers a decay of the array to a pointer to its first element. Then (C++98, 5.2.10/3) comes the catch-all</p>\n<blockquote>\n<p id=\"so_10618473_10618866_2\">The mapping performed by <code>reinterpret_cast</code> is implementation-defined.</p>\n</blockquote>\n<p>The rest of the section lists a number of exceptions to this, specifying casts that are always well-defined. Seeing as none of them applies here, the conclusion is that technically it's implementation-defined by default.</p>\n<h2>Final conclusion</h2>\n<p>Theoretically speaking, this is not portable. Practically, as long as the architectures are the same (e.g. x86) I would certainly expect the cast to work reliably.</p>\n<p>Fortunately you don't have to assume anything like that because as <a href=\"https://stackoverflow.com/a/10618931/50079\">others</a> <a href=\"https://stackoverflow.com/questions/10618473/is-this-c-code-portable-assuming-multidimensional-arrays-have-continuous-mem/10618866#comment13760969_10618473\">have mentioned</a>, something like <code>int* ptr = arr[0]</code> does the same thing and is guaranteed portable.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-05-16T13:37:40.333", "Score": "14", "CreationDate": "2012-05-16T12:46:45.830", "ParentId": "10618473", "CommentCount": "12", "OwnerUserId": "50079", "LastEditDate": "2017-05-23T12:27:59.130"}});