post_cb({"bq_ids": {"n4140": {"so_11859262_11859390_1": {"length": 7, "quality": 1.0, "section_id": 763}, "so_11859262_11859390_0": {"length": 11, "quality": 1.0, "section_id": 763}, "so_11859262_11859262_0": {"length": 4, "quality": 0.8, "section_id": 744}}, "n3337": {"so_11859262_11859390_1": {"length": 7, "quality": 1.0, "section_id": 750}, "so_11859262_11859390_0": {"length": 11, "quality": 1.0, "section_id": 750}, "so_11859262_11859262_0": {"length": 4, "quality": 0.8, "section_id": 733}}, "n4659": {"so_11859262_11859390_1": {"length": 7, "quality": 1.0, "section_id": 823}, "so_11859262_11859390_0": {"length": 11, "quality": 1.0, "section_id": 823}, "so_11859262_11859262_0": {"length": 4, "quality": 0.8, "section_id": 802}}}, "11859262": {"ViewCount": "552", "Body": "<p>Apparently, <a href=\"http://en.cppreference.com/w/cpp/container/unordered_set/erase\" rel=\"nofollow\"><code>unordered_set::erase</code></a> and <a href=\"http://en.cppreference.com/w/cpp/container/unordered_set/count\" rel=\"nofollow\"><code>unordered_set::count</code></a> return something that is not strictly boolean (logically, that is, I'm not talking about the actual type).</p>\n<p>The linked page reads for the third version of erase:</p>\n<pre><code>size_type erase( const key_type&amp; key );\n</code></pre>\n<blockquote>\n<p id=\"so_11859262_11859262_0\">Removes the elements with the key value key</p>\n</blockquote>\n<p>This has a tone to it that suggests there could be more than just one element with a given key. It doesn't explicitly state this, but it sounds like it a lot.<br>\nNow, the point of a set, even an unordered one, is to have each element once.</br></p>\n<p>The standard library acknowledges the existence of the <code>bool</code> type and uses it for boolean values like <a href=\"http://en.cppreference.com/w/cpp/container/unordered_set/empty\" rel=\"nofollow\"><code>unordered_set::empty()</code></a>. <strong>So, what's the point of returning <code>size_type</code> in the cases above? Even in spite of hash collisions, the container should distinguish elements with different keys, right? Can I still rely on that?</strong></p>\n", "AcceptedAnswerId": "11859390", "Title": "Why do unordered_set operations like count and erase return a size_type?", "CreationDate": "2012-08-08T07:00:09.573", "Id": "11859262", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2012-08-08T07:31:56.857", "Score": "4", "OwnerUserId": "430766", "Tags": "<c++><hashset><c++-standard-library><unordered-set>", "AnswerCount": "2"}, "11859390": {"Id": "11859390", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_11859262_11859390_0\">a.erase(k) size_type Erases all elements with key\n                      equivalent to k. Returns the\n                     number of elements erased.</p>\n<p id=\"so_11859262_11859390_1\">b.count(k) size_type  Returns the number of elements with key\n  equivalent to k.</p>\n</blockquote>\n<p>It's because of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"noreferrer\">unordered associative container requirements</a> [23.2.5].</p>\n", "LastEditorUserId": "430766", "LastActivityDate": "2012-08-08T07:31:56.857", "Score": "6", "CreationDate": "2012-08-08T07:08:38.480", "ParentId": "11859262", "CommentCount": "5", "OwnerUserId": "1498580", "LastEditDate": "2012-08-08T07:31:56.857"}, "11859387": {"Id": "11859387", "PostTypeId": "2", "Body": "<p>It's probably just so that they could re-use the wording from <code>unordered_multiset</code>. You don't have to worry about hash collisions except for performance-wise, the container is still correct even if every element collides- even if such a thing would be stupendously slow.</p>\n", "LastActivityDate": "2012-08-08T07:08:24.127", "CommentCount": "1", "CreationDate": "2012-08-08T07:08:24.127", "ParentId": "11859262", "Score": "1", "OwnerUserId": "298661"}});