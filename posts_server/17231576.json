post_cb({"17231576": {"ViewCount": "1069", "Body": "<p>I understand that using <code>templates</code> is one of the appreciated way of overloading but i was wondering why <code>auto</code> cannot be used for function parameter type deduction hence aiding overloading of the function?</p>\n<p><code>N3690</code> says in 7.6.1.4/3 that lambda expression can be made generic using auto,providing this example </p>\n<pre><code>auto glambda = [](int i, auto a) { return i; };//OK: a generic lambda\n</code></pre>\n<p>(note: this is not mentioned in N3485)</p>\n<p>1).why cant i do a similar thing for a normal function for e.g</p>\n<pre><code>void swap(auto&amp; param1, decltype(param1)&amp; param2)\n{\n     decltype(param1) temp = param1;\n     param1 = param2;\n     param2 = temp;\n}\n</code></pre>\n<p>this gives errors <code>error : parameters declared auto</code>.</p>\n<p>from N3690 7.1.6.4/4</p>\n<blockquote>\n<p id=\"so_17231576_17231576_0\">The type of a variable declared using auto or decltype(auto) is deduced from its  \n    initializer. This use is allowed <strong>when declaring variables in a block (6.3)</strong>, in namespace scope (3.3.6), and in a for-init-statement (6.5.3).[...]</p>\n</blockquote>\n<p>am i wrong in assuming that the <code>param1</code> and <code>param2</code> fall under block scope and hence eligible for auto deduction?</p>\n<p>2). if such feature was allowed what would be the pitfalls?</p>\n<p>i'm using gcc 4.8.1. </p>\n<p>Thank you</p>\n", "AcceptedAnswerId": "17231914", "Title": "why auto cannot be used to overload functions?", "CreationDate": "2013-06-21T09:15:05.257", "Id": "17231576", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-06-21T10:14:28.463", "LastEditorUserId": "1825795", "LastActivityDate": "2013-06-21T12:11:44.463", "Score": "13", "OwnerUserId": "1825795", "Tags": "<c++><auto><function-overloading><c++14>", "AnswerCount": "4"}, "17232399": {"Id": "17232399", "PostTypeId": "2", "Body": "<p>There is already a way to write what you wanted :-</p>\n<pre><code>template &lt;class T&gt;\nvoid swap(T&amp; param1, T&amp; param2)\n{\n     T temp = param1;\n     param1 = param2;\n     param2 = temp;\n}\n</code></pre>\n<p>So why create a new syntax that doesn't let you do anything you couldn't do before. The suggested change to lambdas are to allow generic lambdas which you couldn't do before, and I guess any syntax using the template syntax would have been ugly here. </p>\n", "LastActivityDate": "2013-06-21T09:56:26.173", "CommentCount": "2", "CreationDate": "2013-06-21T09:56:26.173", "ParentId": "17231576", "Score": "0", "OwnerUserId": "417292"}, "bq_ids": {"n4140": {"so_17231576_17231914_4": {"length": 20, "quality": 0.7142857142857143, "section_id": 5449}, "so_17231576_17231576_0": {"length": 17, "quality": 0.7727272727272727, "section_id": 5448}, "so_17231576_17231914_5": {"length": 8, "quality": 1.0, "section_id": 5450}, "so_17231576_17231914_1": {"length": 10, "quality": 0.8333333333333334, "section_id": 5447}, "so_17231576_17231914_0": {"length": 15, "quality": 0.9375, "section_id": 5446}, "so_17231576_17231914_2": {"length": 29, "quality": 0.7435897435897436, "section_id": 5448}}, "n3337": {"so_17231576_17231914_4": {"length": 18, "quality": 0.6428571428571429, "section_id": 5243}, "so_17231576_17231914_0": {"length": 9, "quality": 0.5625, "section_id": 5241}, "so_17231576_17231914_5": {"length": 7, "quality": 0.875, "section_id": 5244}, "so_17231576_17231914_2": {"length": 24, "quality": 0.6153846153846154, "section_id": 5242}, "so_17231576_17231576_0": {"length": 13, "quality": 0.5909090909090909, "section_id": 5242}}, "n4659": {"so_17231576_17231914_0": {"length": 15, "quality": 0.9375, "section_id": 6873}, "so_17231576_17231914_5": {"length": 8, "quality": 1.0, "section_id": 6877}, "so_17231576_17231914_1": {"length": 10, "quality": 0.8333333333333334, "section_id": 6874}, "so_17231576_17231914_2": {"length": 21, "quality": 0.5384615384615384, "section_id": 6875}}}, "17232391": {"Id": "17232391", "PostTypeId": "2", "Body": "<p>On top of <a href=\"https://stackoverflow.com/users/1498580/forever\">ForEveR</a>'s <a href=\"https://stackoverflow.com/a/17231914/1137388\">answer</a>:</p>\n<blockquote>\n<blockquote>\n<p id=\"so_17231576_17232391_1\">Why cant i do a similar thing for a normal function for e.g</p>\n</blockquote>\n</blockquote>\n<pre><code>void swap(auto&amp; param1, decltype(param1)&amp; param2)\n</code></pre>\n<p>Simply because the language doesn't allow this. Before <code>auto</code> was (re)invented in C++11 what you want was achievable through templates:</p>\n<pre><code>template &lt;class T, class U&gt;\nvoid swap(T&amp; param1, U&amp; param2);\n</code></pre>\n<p>C++11 also brough lambda expressions and C++14 is likely to introduce  polymorphic lambdas which are, basically, lambdas whose <code>operator ()</code> are templates. A syntax similar to that of templates was considered for the polymorphic lambdas, for instance (example taken from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3418.pdf\" rel=\"nofollow noreferrer\">N3418</a>)</p>\n<pre><code>[]&lt;class T&gt;(T* p) { /* ... */ }\n</code></pre>\n<p>At the end, the prefered syntax was using <code>auto</code> rather than introducing a template parameter list.</p>\n<p>It's true that one could consider extend this terser syntax to function templates (as the OP suggests) but, as far as I know, the committee hasn't considered this possibility. It might do in the future but someone has to formally propose it. This might be a \"nice feature to have\" but IMHO this is just syntactic sugar that doesn't bring much to the language.</p>\n<p>Also, I can't see how this terser syntax (with no template parameter lists) could be used for template classes and perhaps diverging the syntax for template functions from that of template classes is not worth doing.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-06-21T09:56:05.367", "Score": "1", "CreationDate": "2013-06-21T09:56:05.367", "ParentId": "17231576", "CommentCount": "1", "OwnerUserId": "1137388", "LastEditDate": "2017-05-23T12:29:52.310"}, "17232116": {"Id": "17232116", "PostTypeId": "2", "Body": "<p>N3690 is the committee draft for C++14, i.e. for the next C++ standard that has yet to be released and wich might not be implemented yet in most compilers. So you should refer to your compiler's documentation if generic lambdas are implemented - I guess they are not.</p>\n<p>However, with gcc you have good chances that C++14 features will be implemented before the new standard is officially released, though you might have to explicitly enable C++14 support with a command line flag. Looking at the docs it should be <code>-std=gnu++1y</code> </p>\n<p>According to <a href=\"http://gcc.gnu.org/projects/cxx1y.html\" rel=\"nofollow\">this site</a>, generic lambdas are not implemented yet in GCC.</p>\n<p><strong>Update:</strong>\nAs for normal generic functions using <code>auto</code> parameters: These don't exist and won't be coming for the next time. The reason is that templated functions are only slightly more verbose to type and more powerful, since you can refer to the types and directly apply template metafunctions to them. In generic lambdas this can be done only by using <code>decltype(a)</code>, wich is a bit more tedious and has to be used with care, because it behaves a bit different than template argument deduction.<br>\nAn additional bonus with templates compared to auto params is a bit more typesafety or expressiveness:</br></p>\n<pre><code>void func(auto a, auto b);  //a and b might be different types\n\ntemplate &lt;class T&gt;\nvoid func(T a, T b); //a and b must be the same type\n</code></pre>\n", "LastEditorUserId": "1838266", "LastActivityDate": "2013-06-21T10:05:13.570", "Score": "2", "CreationDate": "2013-06-21T09:42:45.180", "ParentId": "17231576", "CommentCount": "3", "OwnerUserId": "1838266", "LastEditDate": "2013-06-21T10:05:13.570"}, "17231914": {"Id": "17231914", "PostTypeId": "2", "Body": "<p>n3690 7.1.6.4/2\n<blockquote><p id=\"so_17231576_17231914_0\">\nThe placeholder type can appear with a function declarator in the decl-specifier-seq, type-specifier-seq,\nconversion-function-id, or trailing-return-type, in any context where such a declarator is valid.</p></blockquote>\n7.1.6.4/3\n<blockquote><p id=\"so_17231576_17231914_1\">\nIf the auto type-specifier appears as one of the decl-specifiers in the decl-specifier-seq of a parameter-\ndeclaration of a lambda-expression, the lambda is a generic lambda.</p></blockquote>\n7.1.6.4/4\n<blockquote><p id=\"so_17231576_17231914_2\">\nThe type of a variable declared using auto or decltype(auto) is deduced from its initializer. This use is al-\nlowed when declaring variables in a block (6.3), in namespace scope (3.3.6), and in a for-init-statement (6.5.3).\nauto or decltype(auto) shall appear as one of the decl-specifiers in the decl-specifier-seq and the decl-\nspecifier-seq shall be followed by one or more init-declarators, each of which shall have a non-empty initial-\nizer.</p></blockquote>\n7.1.6.4/5\n<blockquote><p id=\"so_17231576_17231914_3\"></p>\n<p id=\"so_17231576_17231914_4\">A placeholder type can also be used in declaring a variable in the condition of a selection statement (6.4) or\nan iteration statement (6.5), in the type-specifier-seq in the new-type-id or type-id of a new-expression (5.3.4), in\na for-range-declaration, and in declaring a static data member with a brace-or-equal-initializer that appears\nwithin the member-specification of a class definition (9.4.2).</p></blockquote>\nOnly such usage is alowed. Any other usage is prohibited (in particular usage in <code>parameter-declaration-clause</code>).</p>\n<p>7.1.6.4/6\n<blockquote><p id=\"so_17231576_17231914_5\">\nA program that uses auto or decltype(auto) in a context not explicitly allowed in this section is ill-formed.</p></blockquote></p>\n", "LastEditorUserId": "1498580", "LastActivityDate": "2013-06-21T09:54:20.127", "Score": "5", "CreationDate": "2013-06-21T09:32:53.730", "ParentId": "17231576", "CommentCount": "9", "OwnerUserId": "1498580", "LastEditDate": "2013-06-21T09:54:20.127"}});