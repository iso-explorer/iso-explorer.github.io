post_cb({"14974888": {"ParentId": "14974591", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-02-20T07:59:14.053", "Score": "2", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:54:22.003", "Id": "14974888", "OwnerUserId": "961353", "Body": "<p>You might want to have a look at <a href=\"http://www.sgi.com/tech/stl/Rope.html\" rel=\"nofollow noreferrer\"><code>rope</code></a>. It is a heavy-duty string (get it?) designed for large strings, with much faster substring operations. Unfortunately, it isn't part of the <code>std</code>, but rather a common addition (in SGI, STLPort and GNU's libstdc++). </p>\n<p>See <a href=\"https://stackoverflow.com/q/2826431/961353\">STL Rope - when and where to use</a></p>\n", "LastActivityDate": "2013-02-20T07:59:14.053"}, "14974742": {"ParentId": "14974591", "CommentCount": "0", "CreationDate": "2013-02-20T07:48:46.090", "OwnerUserId": "485505", "PostTypeId": "2", "Id": "14974742", "Score": "1", "Body": "<p>From my realisation of STL I can see that condition of reallocating string during <code>std::string::erase</code> is:\n<code>if (__new_size &gt; this-&gt;capacity() || _M_rep()-&gt;_M_is_shared())</code>\nI think it means that string isn't reallocating during <code>erase</code> call.</p>\n", "LastActivityDate": "2013-02-20T07:48:46.090"}, "bq_ids": {"n4140": {"so_14974591_14974859_0": {"section_id": 4706, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_14974591_14974859_0": {"section_id": 1559, "quality": 1.0, "length": 6}}, "n4659": {"so_14974591_14974859_0": {"section_id": 6103, "quality": 0.6666666666666666, "length": 4}}}, "14974894": {"ParentId": "14974591", "CommentCount": "0", "CreationDate": "2013-02-20T07:59:44.947", "OwnerUserId": "1838266", "PostTypeId": "2", "Id": "14974894", "Score": "1", "Body": "<ol>\n<li>No, <code>std::string::erase</code> does not reallocate - because it does not need to and because it's C++ philosophy that you don't pay (reallocation time) for what you don't need.</li>\n<li>Depends on what you want to erase and what you mean with quickly (quickly to type or to perform).</li>\n</ol>\n<p>First thing to do is of course find a fast algorithm to <em>find</em> the words/phrases that you want to remove. Then, if there's only one chunk to erase, <code>std::string::erase</code> should be perfectly suited for your needs.\nHowever, if for example you have the string \"000aa11111bbbbb2222222c3333333333\" and want to erase all phrases containing letters, just finding and erasing them one after another will lead to multiple copies of the remainder of the string - the '1's will get copied once, '2's will get copied twice and so on. So if there are many phrases to erase in the string, there will be a possibility to improve performance - just copy the chunks that should remain in the string individually and overwrite the chunks you want to erase:\n(| denotes an iterator until which the string is \"correct\"):</p>\n<ul>\n<li>\"000|aa11111bbbbb2222222c3333333333\"</li>\n<li>\"00011111|11bbbbb2222222c3333333333\" </li>\n<li>\"000111112222222|2222222c3333333333\" </li>\n<li>\"0001111122222223333333333|33333333\" </li>\n<li>\"0001111122222223333333333\"</li>\n</ul>\n<p>That way, you have to copy every character after the first erased phrase exactly once.</p>\n", "LastActivityDate": "2013-02-20T07:59:44.947"}, "18569598": {"ParentId": "14974591", "CommentCount": "0", "CreationDate": "2013-09-02T09:17:54.080", "OwnerUserId": "2515755", "PostTypeId": "2", "Id": "18569598", "Score": "0", "Body": "<p>I'm using VC6 from MS and this last DO reallocate buffer on std::string::erase() call.\nI had to remove all erase() calls from my code as I'm sometimes using big strings and I found some big slow down due to this.\nSo care about your compiler and avoid erase(). Personally, I use reaffectations\n         str = \"\";\n as a workaround.</p>\n", "LastActivityDate": "2013-09-02T09:17:54.080"}, "14974903": {"ParentId": "14974591", "CommentCount": "0", "CreationDate": "2013-02-20T08:00:01.507", "OwnerUserId": "1399765", "PostTypeId": "2", "Id": "14974903", "Score": "2", "Body": "<p>It's already been mentioned that it's implementation dependent whether std::string::erase triggers a reallocation. so I wanted to focus on the string searching.  The traditional approach to this problem would be to use the <a href=\"https://en.wikipedia.org/wiki/Aho%E2%80%93Corasick_string_matching_algorithm\" rel=\"nofollow\">Aho-Corasick algorithm</a>.</p>\n<p>Alternatively, David Musser wrote a paper on searching for needles (substrings) in large haystacks (strings) using a hybrid of the Boyer-Moore and Knuth-Morris-Pratt algorithms.  The paper is available <a href=\"http://citeseerx.ist.psu.edu/viewdoc/download;jsessionid=739701AAE158FBA3F652E627ADC86D05?doi=10.1.1.4.43&amp;rep=rep1&amp;type=pdf\" rel=\"nofollow\">here</a>.  Adapting this would probably be simpler than rolling an Aho-Corasick implementation.</p>\n<p>Musser's approach exhibits must faster behavior than the naive search and replace.  It should be possible to adapt the algorithm for your purposes by modifying the BM skip loop and KNP lookup table to account for all of the needles that you are looking to replace.  Allocate an output buffer in advance and iteratively construct the output string by appending to it all non-matching segments of the haystack.  This approach will get less effective as the number of needles grows and the BM/KNP lookups saturate.</p>\n", "LastActivityDate": "2013-02-20T08:00:01.507"}, "14974859": {"ParentId": "14974591", "CommentCount": "1", "CreationDate": "2013-02-20T07:57:11.150", "OwnerUserId": "440119", "PostTypeId": "2", "Id": "14974859", "Score": "4", "Body": "<p>21.4.1/3</p>\n<blockquote>\n<p id=\"so_14974591_14974859_0\">No erase() or pop_back() member function shall throw any exceptions.</p>\n</blockquote>\n<p>Since no such restriction exists on the allocator, I think that it is safe to say that no, <code>std::string::erase</code> does not, and can not, reallocate.</p>\n", "LastActivityDate": "2013-02-20T07:57:11.150"}, "14974701": {"ParentId": "14974591", "CommentCount": "0", "CreationDate": "2013-02-20T07:45:57.157", "OwnerUserId": "105672", "PostTypeId": "2", "Id": "14974701", "Score": "4", "Body": "<p>It is not defined if <code>string::erase</code> is going to trigger a reallocation. You can check by comparing <code>string::capacity</code> to after and before calling the method to see what happens. Removing parts of a string is always going to trigger a copy of all characters that come after the erased parts, since the storage of a string is required to be continuous.</p>\n<p>For operations on large strings you might want to consider using a rope or a std::list instead. This might turn out faster depending on what you do.</p>\n", "LastActivityDate": "2013-02-20T07:45:57.157"}, "14974591": {"CommentCount": "7", "AcceptedAnswerId": "14974701", "PostTypeId": "1", "LastEditorUserId": "147192", "CreationDate": "2013-02-20T07:37:42.190", "LastActivityDate": "2013-09-02T09:17:54.080", "LastEditDate": "2013-02-20T07:48:07.090", "ViewCount": "1111", "FavoriteCount": "1", "Title": "C++ does std::string::erase reallocate and...?", "Id": "14974591", "Score": "1", "Body": "<p>First question, does <code>std::string::erase</code> reallocate?</p>\n<p>Second question, are there any faster method to quickly erase certain words or phrase from a <code>std::string</code>? The length of the string is usually around 300K.</p>\n", "Tags": "<c++>", "OwnerUserId": "2014656", "AnswerCount": "7"}});