post_cb({"33243400": {"ParentId": "33242948", "LastEditDate": "2015-10-20T18:01:48.000", "CommentCount": "2", "CreationDate": "2015-10-20T17:47:57.433", "OwnerUserId": "4611899", "LastEditorUserId": "4611899", "PostTypeId": "2", "Id": "33243400", "Score": "1", "Body": "<p>When discussing direct initialization (emphasis is my own):</p>\n<blockquote>\n<p id=\"so_33242948_33243400_0\">If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified\n  version of the source type is the same class as, or a derived class of, the class of the destination,\n  constructors are considered. The applicable constructors are enumerated (13.3.1.3), and the best\n  one is chosen through <strong><em>overload resolution (13.3)</em></strong>. The constructor so selected is called to initialize\n  the object, with the initializer expression or expression-list as its argument(s). If no constructor\n  applies, or the overload resolution is ambiguous, the initialization is ill-formed.</p>\n</blockquote>\n<p>This line leads to section <strong>\u00a78.5 (2.8,2.9)</strong> on Overload Resolutions which describes the process.</p>\n<blockquote>\n<p id=\"so_33242948_33243400_1\">Overload resolution selects the function to call in seven distinct contexts within the language:</p>\n<p id=\"so_33242948_33243400_2\">...\n  (2.4) \u2014 invocation of a constructor for direct-initialization (8.5) of a class object...</p>\n<p id=\"so_33242948_33243400_3\">But, once the candidate functions and argument lists have been identified, the selection of the best function\n  is the same in all cases:</p>\n<p id=\"so_33242948_33243400_4\">(2.8) \u2014 First, a subset of the candidate functions (those that have the proper number of arguments and meet\n  certain other conditions) is selected to form a set of viable functions (13.3.2).</p>\n<p id=\"so_33242948_33243400_5\">(2.9) \u2014 Then the best viable function is selected based on the <strong><em>implicit conversion sequences (13.3.3.1)</em></strong> needed\n  to match each argument to the corresponding parameter of each viable function.</p>\n</blockquote>\n<p>Given the above, direct initialization does in fact go through the process of selecting candidate constructors (in your case, the one parameter constructor <code>A::A( A const &amp;)</code> ) and finding an implicit converse sequence to match the two together - that is <code>operator C::A()</code>.</p>\n<p><s>It is somewhat misleading that they apply - what seems to be - redundant language in the text for other copy-initialization cases.</s></p>\n<p>The extra language on an implicit conversion sequence - that you quote in the question - for the other copy-initialization cases of <strong>(17.6.2)</strong> directly refer to the following case:</p>\n<pre><code>class B {\n    operator A();\n};\nclass A {\n\n};\n\nB b;\nA a = b;\n</code></pre>\n<p>This isn't covered under the first point in <strong>(17.6.1)</strong> as <code>B</code> doesn't derive from <code>A</code> nor do any helpful constructors exist. Therefore it falls under the 'other' clause.   </p>\n", "LastActivityDate": "2015-10-20T18:01:48.000"}, "33244250": {"ParentId": "33242948", "LastEditDate": "2015-10-20T18:42:41.633", "CommentCount": "1", "CreationDate": "2015-10-20T18:34:19.723", "OwnerUserId": "34509", "LastEditorUserId": "34509", "PostTypeId": "2", "Id": "33244250", "Score": "1", "Body": "<p>I don't understand your concern, but answering what happens, in case this can solve it for you. <code>A a{c}</code> directly branches off of bullet 1 of dcl.initp17 to dcl.init.list.</p>\n<p>From there it happens that it will initialize a <code>const A&amp;</code> from a <code>C</code> (by over.match.list selecting the copy-constructor of <code>A</code>). This will invoke the paragraph you cited (by first branching off to dcl.init.ref and then applying dcl.initp17 in turn). This will construct a normal user-defined conversion sequence which is able to use conversion functions, such as your <code>operator A</code>.</p>\n<p>I think you are confused by the fact that it only mentions user defined conversion sequences for the copy initializations, but in the preceeding bullet it doesn't. The reason is that when doing direct initialization, that is conceptual a direct call to the constructors of a class instead of being a conversion (in which the call to constructors is only a part, surrounded by a standard conversion sequence before (for constructors) and after (for conversion functions/operators) it). In other words, for direct initialization, you already force the constructor call, rather than making the compiler find out that it needs to do it. And you haven't \"paid\" a user defined conversion sequence (you cannot nest user defined conversion sequences, so they are \"precious\") - the compiler can still apply a user defined conversion sequence for matching up the argument for the constructor.</p>\n<p>The proper testcase for this would be <code>A a(c)</code> rather than <code>A a{c}</code> though, to prevent branching off to dcl.init.list.</p>\n", "LastActivityDate": "2015-10-20T18:42:41.633"}, "bq_ids": {"n4140": {"so_33242948_33243400_1": {"section_id": 563, "quality": 1.0, "length": 10}, "so_33242948_33243400_5": {"section_id": 563, "quality": 0.9473684210526315, "length": 18}, "so_33242948_33243400_4": {"section_id": 563, "quality": 0.9473684210526315, "length": 18}, "so_33242948_33243400_2": {"section_id": 563, "quality": 1.0, "length": 5}, "so_33242948_33243400_3": {"section_id": 563, "quality": 1.0, "length": 15}, "so_33242948_33243400_0": {"section_id": 3296, "quality": 0.9111111111111111, "length": 41}, "so_33242948_33242948_0": {"section_id": 3296, "quality": 0.9204545454545454, "length": 81}}, "n3337": {"so_33242948_33243400_1": {"section_id": 554, "quality": 1.0, "length": 10}, "so_33242948_33243400_5": {"section_id": 554, "quality": 0.9473684210526315, "length": 18}, "so_33242948_33243400_4": {"section_id": 554, "quality": 0.9473684210526315, "length": 18}, "so_33242948_33243400_2": {"section_id": 554, "quality": 1.0, "length": 5}, "so_33242948_33243400_3": {"section_id": 554, "quality": 1.0, "length": 15}, "so_33242948_33243400_0": {"section_id": 3166, "quality": 0.9111111111111111, "length": 41}, "so_33242948_33242948_0": {"section_id": 3166, "quality": 0.9204545454545454, "length": 81}}, "n4659": {"so_33242948_33243400_1": {"section_id": 586, "quality": 1.0, "length": 10}, "so_33242948_33243400_3": {"section_id": 586, "quality": 1.0, "length": 15}, "so_33242948_33243400_4": {"section_id": 586, "quality": 0.9473684210526315, "length": 18}, "so_33242948_33243400_2": {"section_id": 586, "quality": 1.0, "length": 5}, "so_33242948_33242948_0": {"section_id": 4058, "quality": 0.6818181818181818, "length": 60}, "so_33242948_33243400_5": {"section_id": 586, "quality": 0.9473684210526315, "length": 18}, "so_33242948_33243400_0": {"section_id": 4058, "quality": 0.9111111111111111, "length": 41}}}, "33242948": {"CommentCount": "2", "ViewCount": "108", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-10-20T17:23:13.680", "LastActivityDate": "2015-10-20T18:44:35.413", "Title": "I think there might be a small inaccuracy in bullet point (17.6.2) in \u00a78.5[dcl.init]/17 in N4140", "LastEditDate": "2017-05-23T10:28:10.253", "Id": "33242948", "Score": "1", "Body": "<p>In bullet point <strong>(17.6.2)</strong> in <strong>\u00a78.5[dcl.init]/17</strong> in N4140 we have (emphasis is mine):</p>\n<blockquote>\n<p id=\"so_33242948_33242948_0\">Otherwise (i.e., <strong>for the remaining copy-initialization cases</strong>),\n  user-defined conversion sequences that can convert from the source\n  type to the destination type or (when a conversion function is used)\n  to a derived class thereof are enumerated as described in 13.3.1.4,\n  and the best one is chosen through overload resolution (13.3). If the\n  conversion cannot be done or is ambiguous, the initialization is\n  ill-formed. The function selected is called with the initializer\n  expression as its argument; if the function is a constructor, the call\n  initializes a temporary of the cv-unqualified version of the\n  destination type. The temporary is a prvalue. The result of the call\n  (which is the temporary for the constructor case) is then used to\n  direct-initialize, according to the rules above, the object that is\n  the destination of the copy-initialization. In certain cases, an\n  implementation is permitted to eliminate the copying inherent in this\n  direct-initialization by constructing the intermediate result directly\n  into the object being initialized; see 12.2, 12.8.</p>\n</blockquote>\n<p>The portion of the text in bold seems to indicate that direct-initializations will never invoke a user-defined conversion sequence. But that's not what I found out below:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {\n    A() { std::cout &lt;&lt; \"default ctor A\" &lt;&lt; '\\n'; }\n    A(const A&amp;) { std::cout &lt;&lt; \"copy A\" &lt;&lt; '\\n'; }\n};\n\nstruct C {\n    C() { std::cout &lt;&lt; \"default ctor C\" &lt;&lt; '\\n'; }\n    operator A() { std::cout &lt;&lt; \"C::operator A()\" &lt;&lt; '\\n'; return A(); };\n};\n\nint main()\n{\n     C c;\n     A a{c};        // direct-initialization where the C::operator A() is invoked\n                    // to copy construct the object `a`.\n}\n</code></pre>\n<p>The following is printed by this snippet:</p>\n<pre><code>default ctor C\nC::operator A()\ndefault ctor A\ncopy A\ncopy A\n</code></pre>\n<p>See <a href=\"http://coliru.stacked-crooked.com/a/0b527fcd61943e7c\" rel=\"nofollow noreferrer\">live example</a> </p>\n<p><strong>Edit</strong></p>\n<p>In response to <a href=\"https://stackoverflow.com/users/34509/johannes-schaub-litb\">@Johannes</a> answer, please consider <code>A a(c);</code> instead of <code>A a{c};</code>. The rest remains valid, as far as I can understand.</p>\n", "Tags": "<c++><initialization><language-lawyer><c++14>", "OwnerUserId": "1042389", "AnswerCount": "2"}});