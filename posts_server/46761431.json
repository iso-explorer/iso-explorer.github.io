post_cb({"46761456": {"ParentId": "46761431", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>What you're doing is <a href=\"http://en.cppreference.com/w/cpp/language/ub\" rel=\"nofollow noreferrer\">undefined behaviour</a>, so anything can happen. The C++ standard says:</p>\n<blockquote>\n<p id=\"so_46761431_46761456_0\">Except that any class member declared <code>mutable</code> (10.1.1) can be modified, any attempt to modify a <code>const</code> object during its lifetime (6.8) results in undefined behavior.</p>\n</blockquote>\n<p>And:</p>\n<blockquote>\n<p id=\"so_46761431_46761456_1\"><em>[Note:</em> Depending on the type of the object, a write operation through the pointer, lvalue or pointer to data member resulting from a <code>const_cast</code> that casts away a const-qualifier may produce undefined\n  behavior (10.1.7.1). <em>\u2014 end note]</em></p>\n</blockquote>\n<p>So you can cast away the \"const\" to get <code>int*</code> but attempting to actually modify the variable through that pointer is undefined.</p>\n<p>The reason you can cast away the <code>const</code> is that it might not actually point to a constant:</p>\n<pre><code>int i = 0;\nconst int* p = &amp;i;\n*(int*)p = 1;      // OK, because p points to a non-constant\nconst int j = 0;\nconst int* q = &amp;j;\n*(int*)q = 1;      // NOT OK, because q points to a constant\n</code></pre>\n<p>In your second example the compiler is making assumptions when optimizing, based on the fact it knows that a constant value will not change, so it doesn't bother testing its value. The assumption is correct because a correct program can never change the value of a constant. Your program is not correct, but that means the compiler isn't required to give a sensible result.</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2017-10-16T00:43:13.433", "Id": "46761456", "Score": "2", "CreationDate": "2017-10-16T00:36:31.993", "LastActivityDate": "2017-10-16T00:43:13.433"}, "46761431": {"CommentCount": "1", "ViewCount": "41", "PostTypeId": "1", "ClosedDate": "2017-10-16T00:41:48.583", "LastEditorUserId": "7702177", "CreationDate": "2017-10-16T00:31:55.617", "LastActivityDate": "2017-10-16T03:38:58.590", "Title": "What happens when I use *(int*)&x to assign to a constant value x?", "AcceptedAnswerId": "46761456", "LastEditDate": "2017-10-16T03:38:58.590", "Id": "46761431", "Score": "-3", "Body": "<p>I have tried the following codes:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nstruct MyClass {\n    const int x;\n};\nint main() {\n    MyClass c = {3};\n    const int *p = &amp;c.x;\n\n    cout &lt;&lt; \"x = \" &lt;&lt; c.x &lt;&lt; endl;\n    cout &lt;&lt; \"&amp;x = \" &lt;&lt; &amp;c.x &lt;&lt; endl;\n    cout &lt;&lt; \"p = \" &lt;&lt; p &lt;&lt; endl;\n    cout &lt;&lt; \"*p = \" &lt;&lt; *p &lt;&lt; endl;\n    cout &lt;&lt; \"*(&amp;x) = \" &lt;&lt; *(&amp;c.x) &lt;&lt; endl;\n    cout &lt;&lt; endl;\n\n    *(int*)&amp;c.x = 4;\n\n    cout &lt;&lt; \"x = \" &lt;&lt; c.x &lt;&lt; endl;\n    cout &lt;&lt; \"&amp;x = \" &lt;&lt; &amp;c.x &lt;&lt; endl;\n    cout &lt;&lt; \"p = \" &lt;&lt; p &lt;&lt; endl;\n    cout &lt;&lt; \"*p = \" &lt;&lt; *p &lt;&lt; endl;\n    cout &lt;&lt; \"*(&amp;x) = \" &lt;&lt; *(&amp;c.x) &lt;&lt; endl;\n\n    cout &lt;&lt; (p == &amp;c.x) &lt;&lt; endl;\n    cout &lt;&lt; (*p == *(&amp;c.x)) &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>Then I get the following answer:</p>\n<pre><code>x = 3\n&amp;x = 0x61fe98\np = 0x61fe98\n*p = 3\n*(&amp;x) = 3\n\nx = 4\n&amp;x = 0x61fe98\np = 0x61fe98\n*p = 4\n*(&amp;x) = 4\n1\n1\n</code></pre>\n<p>It seems that I have successfully change the value of constant integer x. But when I directly declare x in main() instead of in a class, I get the totally different answer.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    const int x = 3;\n    const int *p = &amp;x;\n\n    cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; endl;\n    cout &lt;&lt; \"&amp;x = \" &lt;&lt; &amp;x &lt;&lt; endl;\n    cout &lt;&lt; \"p = \" &lt;&lt; p &lt;&lt; endl;\n    cout &lt;&lt; \"*p = \" &lt;&lt; *p &lt;&lt; endl;\n    cout &lt;&lt; \"*(&amp;x) = \" &lt;&lt; *(&amp;x) &lt;&lt; endl;\n    cout &lt;&lt; endl;\n\n    *(int*)&amp;x = 4;\n\n    cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; endl;\n    cout &lt;&lt; \"&amp;x = \" &lt;&lt; &amp;x &lt;&lt; endl;\n    cout &lt;&lt; \"p = \" &lt;&lt; p &lt;&lt; endl;\n    cout &lt;&lt; \"*p = \" &lt;&lt; *p &lt;&lt; endl;\n    cout &lt;&lt; \"*(&amp;x) = \" &lt;&lt; *(&amp;x) &lt;&lt; endl;\n    cout &lt;&lt; endl;\n\n    cout &lt;&lt; (p == &amp;x) &lt;&lt; endl;\n    cout &lt;&lt; (*p == *(&amp;x)) &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>The result is</p>\n<pre><code>x = 3\n&amp;x = 0x61fe98\np = 0x61fe98\n*p = 3\n*(&amp;x) = 3\n\nx = 3\n&amp;x = 0x61fe98\np = 0x61fe98\n*p = 4\n*(&amp;x) = 3\n\n1\n0\n</code></pre>\n<p>That is really strange that (p == &amp;x) is true but (*p == *(&amp;x)) is false!!! I don't know what's going on in the second codes.</p>\n", "Tags": "<c++>", "OwnerUserId": "7702177", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_46761431_46761456_1": {"section_id": 6057, "quality": 0.8333333333333334, "length": 20}, "so_46761431_46761456_0": {"section_id": 5433, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_46761431_46761456_1": {"section_id": 5825, "quality": 0.8333333333333334, "length": 20}, "so_46761431_46761456_0": {"section_id": 5228, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_46761431_46761456_1": {"section_id": 7555, "quality": 0.8333333333333334, "length": 20}, "so_46761431_46761456_0": {"section_id": 6861, "quality": 0.9444444444444444, "length": 17}}}});