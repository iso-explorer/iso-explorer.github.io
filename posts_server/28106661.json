post_cb({"28106896": {"Id": "28106896", "PostTypeId": "2", "Body": "<p>If I understand your post correctly, your sample code can be reduced to:</p>\n<pre><code>struct X\n{\n    static int x;\n};\n\nint main()\n{\n    void *f = &amp;X::x;\n}\n</code></pre>\n<p>and you are finding that a link error is only generated if <code>-O2</code> is not passed.</p>\n<hr>\n<p>The One Definition Rule is extremely complicated but I'm fairly confident that <code>&amp;X::x</code> counts as <em>odr-use</em>. However , [basic.def.odr]/4 says:</p>\n<blockquote>\n<p id=\"so_28106661_28106896_0\">Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in that program; no diagnostic required.</p>\n</blockquote>\n<p>The last 3 words is a big weasel clause for compilers, it basically permits the behaviour that you are seeing. The program is ill-formed (and so any executable generated has completely undefined behaviour) but the standard does not require that the compiler/linker produce any warnings or errors.</p>\n<p>If the ODR rule didn't have this escape clause then the optimizer's job would be much more difficult; e.g. it could have identified that your function only contains dead code but it would have to have extra logic to check for all <em>odr-use</em> of things in the function.</p>\n<hr>\n<p>So how do we fix this?  Since all ODR violations for variables have the same \"no diagnostic required\" provision, there's no guaranteed solution. We will have to try and find something that your particular compiler likes, or a way to prevent optimization.</p>\n<p>This worked for me with gcc 4.8.1:</p>\n<pre><code>void *volatile f = &amp;X::x;\n</code></pre>\n<p>(and the same thing worked in your code sample).  This will incur a small runtime penalty though (the compiler has to generate an instruction for the call to <code>runme</code>).  Maybe someone else will come up with a nicer trick :)</p>\n</hr></hr>", "LastEditorUserId": "1505939", "LastActivityDate": "2015-01-23T09:56:26.210", "Score": "2", "CreationDate": "2015-01-23T09:38:50.007", "ParentId": "28106661", "CommentCount": "5", "OwnerUserId": "1505939", "LastEditDate": "2015-01-23T09:56:26.210"}, "bq_ids": {"n4140": {"so_28106661_28106896_0": {"length": 12, "quality": 1.0, "section_id": 7041}}, "n3337": {"so_28106661_28106896_0": {"length": 12, "quality": 1.0, "section_id": 6786}}, "n4659": {"so_28106661_28106896_0": {"length": 12, "quality": 1.0, "section_id": 8538}}}, "28106661": {"ViewCount": "102", "Body": "<p>There have been a few questions about static data members of template classes not being initialized. Unfortunately none of these had answers that were able to help me with my specific problem.</p>\n<p>I have a template class that has a static data member that must be instantiated explicitly for specific types (i.e., must be specialized). If this is not the case, using a different template function should cause a linker error.</p>\n<p>Here's some code:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nclass Instantiate {\npublic:\n    static Instantiate instance;\nprivate:\n    Instantiate(std::string const &amp;id) {\n        std::cout &lt;&lt; \"Instantiated \" &lt;&lt; id &lt;&lt; \".\" &lt;&lt; std::endl;\n        // Additional, important side effects...\n    }\n};\n\ntemplate &lt;typename T&gt;\nvoid runme() {\n    // Do something to ensure instance is instantiated,\n    // without creating run-time overhead.\n    // The following only works without optimization.\n    void *force = &amp;Instantiate&lt;T&gt;::instance;\n}\n\n// Instances need to be explicitly specialized for specific types.\ntemplate &lt;&gt; Instantiate&lt;int&gt; Instantiate&lt;int&gt;::instance = {\"int\"};\n\nint main() {\n    // This is OK, since Instantiate&lt;int&gt;::instance was defined.\n    runme&lt;int&gt;();\n    // This should cause a (linker) error, since\n    // Instantiate&lt;double&gt;::instance is not defined.\n    runme&lt;double&gt;();\n}\n</code></pre>\n<p>Calling <code>runme&lt;T&gt;</code> should require that <code>Instantiate&lt;T&gt;::instance</code> is defined, without actually using it. Getting a pointer to <code>instance</code> as shown works - but only if no optimizations are enabled. I need a different method that works with at least <code>O2</code>, and also works if the instantiation of <code>instance</code> occurs in a different compilation unit.</p>\n<p>Question:\nHow can I ensure that I get a linker error when calling <code>runme</code> with a type <code>T</code> for which no explicit <code>Instantiate&lt;T&gt;::instance</code> has been defined/specialized?</p>\n", "AcceptedAnswerId": "28106896", "Title": "Forcing initialization of static data member of template class", "CreationDate": "2015-01-23T09:25:26.220", "Id": "28106661", "CommentCount": "1", "LastEditDate": "2015-01-23T09:47:50.740", "PostTypeId": "1", "LastEditorUserId": "1505939", "LastActivityDate": "2015-01-23T10:02:21.737", "Score": "1", "OwnerUserId": "694509", "Tags": "<c++><templates><optimization><g++><one-definition-rule>", "AnswerCount": "1"}});