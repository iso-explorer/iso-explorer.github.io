post_cb({"27470467": {"ParentId": "27470421", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Given that NewCopy supports the strong guarantee then the code as you have it is exception-safe. </p>\n<p>Agree with @Barry that making the change you propose will make it exception-unsafe (and provide no more performance).</p>\n<p>Again,</p>\n<p>Why on earth are you writing your own stack then the standard library contains a fully optimised, exception-safe implementation?</p>\n", "OwnerUserId": "2015579", "LastEditorUserId": "2015579", "LastEditDate": "2014-12-14T14:54:56.370", "Id": "27470467", "Score": "0", "CreationDate": "2014-12-14T14:49:55.507", "LastActivityDate": "2014-12-14T14:54:56.370"}, "27470487": {"ParentId": "27470421", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>From the standard, 1.9/15:</p>\n<blockquote>\n<p id=\"so_27470421_27470487_0\">When calling a function (whether or not the function is inline), every value computation and side effect associated with any argument expression, or with the postfix expression designating the called function, is sequenced before execution of every expression or statement in the body of the called function.</p>\n</blockquote>\n<p>So when we call:</p>\n<pre><code>v_[vused_++]\n</code></pre>\n<p>which is to say:</p>\n<pre><code>*(v_ + vused_++)\n</code></pre>\n<p>The postincrement operator is sequenced <em>before</em> the dereference. Thus, regardless of what happens in that call, even if it throws, <code>vused_</code> will be incremented. So this will violate the strong exception guarantee if the subsequent assignment throws since <code>vused_</code> will be incremented. This is easy to convince yourself:</p>\n<pre><code>void foo(int ) { throw std::runtime_error(\"\"); }\n\nint main() {\n    int ctr = 0;\n    try {\n        foo(ctr++);\n    }\n    except(...) { }\n\n    std::cout &lt;&lt; ctr &lt;&lt; std::endl; // prints 1\n}\n</code></pre>\n<p>But if we had called <code>foo(ctr); ctr++</code>, it'd print 0.</p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2014-12-14T15:06:48.607", "Id": "27470487", "Score": "2", "CreationDate": "2014-12-14T14:51:22.393", "LastActivityDate": "2014-12-14T15:06:48.607"}, "27471512": {"ParentId": "27470421", "CommentCount": "0", "Body": "<p>C++ Standard n3337 <strong>\u00a7</strong> 8.3.4/6 Arrays</p>\n<blockquote>\n<p id=\"so_27470421_27471512_0\">Note: Except where it has been declared for a class (13.5.5), the\n  subscript operator [] is interpreted in such a way that E1[E2] is\n  identical to *((E1)+(E2)). Because of the conversion rules that apply\n  to +, if E1 is an array and E2 an integer, then E1[E2] refers to the\n  E2-th member of E1. Therefore, despite its asymmetric appearance,\n  subscripting is a commutative operation.</p>\n</blockquote>\n<p>Thus</p>\n<pre><code>v_[vused_++] = t;\n</code></pre>\n<p>is not different from </p>\n<pre><code>*((v_)+(vused_++)) = t;\n</code></pre>\n<p>so it is clear that <code>++</code> will evaluate before assignment and in case of exception being thrown by <code>T::operator=</code> state of the object is invalid.</p>\n", "OwnerUserId": "1141471", "PostTypeId": "2", "Id": "27471512", "Score": "1", "CreationDate": "2014-12-14T16:43:43.803", "LastActivityDate": "2014-12-14T16:43:43.803"}, "bq_ids": {"n4140": {"so_27470421_27471512_0": {"section_id": 3233, "quality": 0.9411764705882353, "length": 32}, "so_27470421_27470487_0": {"section_id": 5811, "quality": 1.0, "length": 28}}, "n3337": {"so_27470421_27471512_0": {"section_id": 3106, "quality": 0.9411764705882353, "length": 32}, "so_27470421_27470487_0": {"section_id": 5584, "quality": 1.0, "length": 28}}, "n4659": {"so_27470421_27471512_0": {"section_id": 3990, "quality": 0.9411764705882353, "length": 32}, "so_27470421_27470487_0": {"section_id": 7273, "quality": 1.0, "length": 28}}}, "27470421": {"CommentCount": "0", "ViewCount": "95", "PostTypeId": "1", "LastEditorUserId": "1141471", "CreationDate": "2014-12-14T14:43:15.520", "LastActivityDate": "2015-03-08T12:54:49.257", "Title": "Exception safety in array assignment using postincremented index", "AcceptedAnswerId": "27471512", "LastEditDate": "2015-03-08T12:54:49.257", "Id": "27470421", "Score": "3", "Body": "<p>In this code:</p>\n<pre><code>template&lt;class T&gt;\nvoid Stack&lt;T&gt;::Push( const T&amp; t )\n{\n  if( vused_ == vsize_ )                           // grow if necessary\n  {\n    size_t vsize_new = vsize_*2+1;                 // by some grow factor\n    T* v_new = NewCopy( v_, vsize_, vsize_new );\n    delete[] v_;                                   // this can't throw\n    v_ = v_new;                                    // take ownership\n    vsize_ = vsize_new;\n  }\n  v_[vused_] = t;\n  vused++;\n}\n</code></pre>\n<p>we try to be exception safe and exception neutral. It is achieved by a means of having <code>NewCopy()</code> helper function (that copies pointed memory and returns a pointer to a copied values) which follows these principles (we are not interested in that function here, it is exception safe &amp; neutral). Lastly, all works because</p>\n<pre><code>  v_[vused_] = t;\n  vused++;\n</code></pre>\n<p>we only change state of Stack if assignment does not throw. If we wrote</p>\n<pre><code>  v_[vused_++] = t;\n</code></pre>\n<p>would the exception safety be violated? My guess is yes (postincrement operator returns old value but it <strong>does</strong> increment variable <strong>before</strong> return, and then after it returned the assignment is performed, so in case of exception the object state is invalid). But I might be mistaken (?)</p>\n", "Tags": "<c++><arrays><exception><exception-handling><increment>", "OwnerUserId": "1141471", "AnswerCount": "3"}});