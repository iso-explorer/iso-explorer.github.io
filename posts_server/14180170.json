post_cb({"bq_ids": {"n4140": {"so_14180170_25789864_0": {"length": 60, "quality": 0.967741935483871, "section_id": 327}}, "n3337": {"so_14180170_25789864_0": {"length": 60, "quality": 0.967741935483871, "section_id": 317}}, "n4659": {"so_14180170_25789864_0": {"length": 48, "quality": 0.7741935483870968, "section_id": 335}}}, "14180170": {"ViewCount": "192", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\n// Variadic version\ntemplate&lt;class... Variadic&gt;\nvoid f(const Variadic&amp;... variadic)\n{\n    std::cout&lt;&lt;\"variadic\"&lt;&lt;std::endl;\n}\n\n// Single version\ntemplate&lt;class Single, class = typename std::enable_if&lt;std::is_fundamental&lt;Single&gt;::value&gt;::type&gt;\nvoid f(const Single&amp; single)\n{\n    std::cout&lt;&lt;\"single\"&lt;&lt;std::endl;\n}\n\n// Main\nint main()\n{\n    f();              // variadic\n    f(42);            // single : why?\n    f(std::string()); // variadic \n    f(42, 42);        // variadic\n    return 0;\n}\n</code></pre>\n<p>I do not understand why the line marked \"single\" compiles well (under g++ 4.6.3) and does not produce an overload resolution problem. Does the c++11 standard say that a template function with a fixed number of parameters is prefered over a variadic function that could have the same signature ?</p>\n", "AcceptedAnswerId": "14180725", "Title": "variadic list vs single template parameter: what does the standard say?", "CreationDate": "2013-01-06T07:12:19.173", "Id": "14180170", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-09-11T14:34:41.503", "Score": "5", "OwnerUserId": "882932", "Tags": "<c++><c++11><variadic-templates><standards-compliance><overload-resolution>", "AnswerCount": "2"}, "25789864": {"Id": "25789864", "PostTypeId": "2", "Body": "<p><a href=\"http://coliru.stacked-crooked.com/a/6e798a12713c2770\" rel=\"nofollow\">It is really</a> <a href=\"http://ideone.com/TKDvd7\" rel=\"nofollow\">quite simple</a> (two live examples, gcc and clang)</p>\n<pre><code>template&lt;class...T&gt; void foo(T&amp;&amp;...) {std::cout &lt;&lt; \"...T\\n\";}\ntemplate&lt;class T&gt; void foo(T&amp;&amp;) {std::cout &lt;&lt; \"T\\n\";}\nint main() {\n  foo(3);\n}\n</code></pre>\n<p>Overloads not taking <code>...</code> seem to be preferred when the choice is an explicit template parameter.</p>\n<p>The <code>class=std::enable_if_t</code> does not change this.</p>\n<p>So both your functions <code>f</code> are candidates, then the compiler prefers the one without variardics.</p>\n<h1>14.8.2.4 Deducing template arguments during partial ordering [temp.deduct.partial]</h1>\n<p>/8:</p>\n<blockquote>\n<p id=\"so_14180170_25789864_0\">If <code>A</code> was transformed from a function parameter pack and <code>P</code> is not a parameter pack, type deduction fails.  Otherwise, using the resulting types <code>P</code> and <code>A</code>, the deduction is then done as described in <code>14.8.2.5</code>. If <code>P</code> is a function parameter pack, the type <code>A</code> of each remaining parameter type of the argument template is compared with the type P of the declarator-id\n  of the function parameter pack. Each comparison deduces template arguments for subsequent positions in the template parameter packs expanded by the function parameter pack. If deduction succeeds for a given type, the type from the argument template is considered to be at least as specialized as the type from the parameter template. [\n  Example:</p>\n</blockquote>\n<pre><code>template&lt;class... Args&gt; void f(Args... args); // #1\ntemplate&lt;class T1, class... Args&gt; void f(T1 a1, Args... args); // #2\ntemplate&lt;class T1, class T2&gt; void f(T1 a1, T2 a2); // #3\nf(); // calls #1\nf(1, 2, 3); // calls #2\nf(1, 2); // calls #3; non-variadic template #3 is more\n// specialized than the variadic templates #1 and #\n</code></pre>\n<p>In particular, the <code>f(1,2)</code> example.</p>\n<p>All the <code>enable_if_t</code> clause does is remove the one-argument version from consideration when you pass a <code>std::string</code> as <code>T</code>.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2014-09-11T14:34:41.503", "Score": "5", "CreationDate": "2014-09-11T14:17:51.063", "ParentId": "14180170", "CommentCount": "0", "OwnerUserId": "1774667", "LastEditDate": "2014-09-11T14:34:41.503"}, "14180725": {"Id": "14180725", "PostTypeId": "2", "Body": "<p>Due to the use of the second, enable_if, template parameter in the 'single' version, the compiler considers that version to be a more-specialized template for use with the types for which it is enabled.\n<br/>It is considered more specialized because there are types where the variadic template can be instantiated, but the 'single' can't.</p>\n<p>The general rule is that a more specialized template trumps a less specialized template in overload resolution.</p>\n", "LastActivityDate": "2013-01-06T09:07:17.497", "CommentCount": "8", "CreationDate": "2013-01-06T09:07:17.497", "ParentId": "14180170", "Score": "2", "OwnerUserId": "430719"}});