post_cb({"bq_ids": {"n4140": {"so_28966141_28966680_7": {"length": 14, "quality": 1.0, "section_id": 5364}, "so_28966141_28966680_5": {"length": 7, "quality": 0.875, "section_id": 5315}, "so_28966141_28966680_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 5314}, "so_28966141_28966680_6": {"length": 24, "quality": 0.96, "section_id": 5315}}, "n3337": {"so_28966141_28966680_7": {"length": 14, "quality": 1.0, "section_id": 5160}, "so_28966141_28966680_5": {"length": 7, "quality": 0.875, "section_id": 5112}, "so_28966141_28966680_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 5111}, "so_28966141_28966680_6": {"length": 24, "quality": 0.96, "section_id": 5112}}, "n4659": {"so_28966141_28966680_7": {"length": 14, "quality": 1.0, "section_id": 6788}, "so_28966141_28966680_5": {"length": 7, "quality": 0.875, "section_id": 6739}, "so_28966141_28966680_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 6738}, "so_28966141_28966680_6": {"length": 24, "quality": 0.96, "section_id": 6739}}}, "28967979": {"Id": "28967979", "PostTypeId": "2", "Body": "<blockquote id=\"so_28966141_28967979_0\">\n<ol>\n<li>Despite being an ASCII (within range of 0 to 256), why those 3 extended characters take 2 bytes of space?</li>\n</ol>\n</blockquote>\n<p>If you define 'being ASCII' as containing only bytes in the range [0, 256), then all data is ASCII: [0, 256) is the same as the range a byte is capable of representing, thus all data represented with bytes is ASCII, under your definition.</p>\n<p>The issue is that your definition is incorrect, and you're looking incorrectly at how data types are determined; The kind of data represented by a sequence of bytes is not determined by those bytes. Instead, the data type is <em>metadata</em> that is external to the sequence of bytes. (This isn't to say that it's impossible to examine a sequence of bytes and determine statistically what kind of data it is likely to be.)</p>\n<p>Let's examine your code, keeping the above in mind. I've taken the relevant snippets from the two versions of your source code:</p>\n<pre><code>s += \"\u00c3\u00a2\"; // 131\ns += \"\u00c3\u00a4\"; // 132\n\ns += \"\u00e2\"; // 131\ns += \"\u00e4\"; // 132\n</code></pre>\n<p>You're viewing these source code snippets as text rendered in a browser, rather than as raw binary data. You've presented these two things as the 'same' data, but in fact they're not the same. Pictured above are two different sequences of characters.</p>\n<p>However there is something interesting about these two sequences of text elements: one of them, when encoded into bytes using a certain encoding scheme, is represented by the same sequence of bytes as the other sequence of text elements when that sequence is encoded into bytes using a different encoding scheme. That is, the same sequence of bytes on disk may represent two different sequences of text elements <em>depending on the encoding scheme</em>! In other words, in order to figure out what the sequence of bytes <em>means</em>, we have to know what kind of data it is, and therefore what decoding scheme to use.</p>\n<p>So here's what probably happened. In vi you wrote:</p>\n<pre><code>s += \"\u00e2\"; // 131\ns += \"\u00e4\"; // 132\n</code></pre>\n<p>You were under the impression that vi would represent those characters using extended ASCII, and thus use the bytes 131 and 132. But that was incorrect. vi did not use extended ASCII, and instead it represented those characters using a different scheme (UTF-8) which happens to use two bytes to represent each of those characters.</p>\n<p>Later, when you opened the source code in a different editor, that editor incorrectly assumed the file was extended ASCII and displayed it as such. Since extended ASCII uses a single byte for every character, it took the two bytes vi used to represent each of those characters, and showed one character for each byte.</p>\n<p>The bottom line is that you're incorrect that the source code is using extended ASCII, and so your assumption that those characters would be represented by single bytes with the values 131 and 132 was incorrect.</p>\n<blockquote id=\"so_28966141_28967979_1\">\n<ol start=\"2\">\n<li>When we iterate through the s using range based loop, how is it figured out that for normal characters it has to increment 1 time and for extended characters 2 times!?</li>\n</ol>\n</blockquote>\n<p>Your program isn't doing this. The characters are printing okay in your ideone.com example because independently printing out the two bytes that represent those characters works to display that character. Here's an example that makes this clear: <a href=\"http://coliru.stacked-crooked.com/a/722efe53c7f1ca49\" rel=\"nofollow\">live example</a>.</p>\n<pre><code>std::cout &lt;&lt; \"Printed together: '\";\nstd::cout &lt;&lt; (char)0xC3;\nstd::cout &lt;&lt; (char)0xA2;\nstd::cout &lt;&lt; \"'\\n\";\n\nstd::cout &lt;&lt; \"Printed separated: '\";\nstd::cout &lt;&lt; (char)0xC3;\nstd::cout &lt;&lt; '/';\nstd::cout &lt;&lt; (char)0xA2;\nstd::cout &lt;&lt; \"'\\n\";\n</code></pre>\n<hr>\n<pre><code>Printed together: '\u00e2'\nPrinted separated: '\ufffd/\ufffd'\n</code></pre>\n<p>The '\ufffd' character is what shows up when an invalid encoding is encountered.</p>\n<p>If you're asking how you can write a program that does do this, the answer is to use code that understands the details of the encoding being used. Either get a library that understands UTF-8 or read the UTF-8 spec yourself.</p>\n<p>You should also keep in mind that the use of UTF-8 here is simply because this editor and compiler use UTF-8 by default. If you were to write the same code with a different editor and compile it with a different compiler, the encoding could be completely different; assuming code is UTF-8 can be just as wrong as your earlier assumption that the code was extended ASCII.</p>\n</hr>", "LastEditorUserId": "365496", "LastActivityDate": "2015-03-12T05:06:18.747", "Score": "3", "CreationDate": "2015-03-10T15:42:41.063", "ParentId": "28966141", "CommentCount": "1", "OwnerUserId": "365496", "LastEditDate": "2015-03-12T05:06:18.747"}, "28966191": {"Id": "28966191", "PostTypeId": "2", "Body": "<p>Your terminal probably uses <a href=\"http://en.wikipedia.org/wiki/UTF-8\" rel=\"nofollow\">UTF-8</a> encoding.  It uses one byte for ASCII characters, and 2-4 bytes for everything else.</p>\n", "LastActivityDate": "2015-03-10T14:20:38.877", "CommentCount": "0", "CreationDate": "2015-03-10T14:20:38.877", "ParentId": "28966141", "Score": "2", "OwnerUserId": "287586"}, "28966141": {"ViewCount": "2241", "Body": "<p>ASCII ranging from 32 to 126 are printable. 127 is <code>DEL</code> and thereafter are considered the <a href=\"http://www.theasciicode.com.ar/extended-ascii-code/letter-a-grave-accent-lowercase-ascii-code-133.html\" rel=\"nofollow\">extended characters</a>.</p>\n<p>To check, how are they stored in the <code>std::string</code>, I wrote a test program:</p>\n<pre><code>int main ()\n{\n  string s; // ASCII\n  s += \"!\"; // 33\n  s += \"A\"; // 65\n  s += \"a\"; // 97\n  s += \"\u00c3\u00a2\"; // 131\n  s += \"\u00c3\u00a4\"; // 132\n  s += \"\u00c3\u00a0\"; // 133\n\n  cout &lt;&lt; s &lt;&lt; endl;  // Print directly\n  for(auto i : s)     // Print after iteration\n    cout &lt;&lt; i;\n\n  cout &lt;&lt; \"\\ns.size() = \" &lt;&lt; s.size() &lt;&lt; endl; // outputs 9!\n}\n</code></pre>\n<p>The special characters visible in the code above actually look different and those can be seen in this <a href=\"http://ideone.com/WUcMGB\" rel=\"nofollow\">online example</a> (also visible in vi).</p>\n<p>In the string <code>s</code>, first 3 normal characters acquire 1 byte each as expected. The next 3 extended characters take surprisingly 2 bytes each.</p>\n<p><strong>Questions</strong>:  </p>\n<ol>\n<li>Despite being an ASCII (within range of 0 to 256), why those 3 extended characters take 2 bytes of space?</li>\n<li>When we iterate through the <code>s</code> using range based loop, how is it figured out that for normal characters it has to increment 1 time and for extended characters 2 times!?</li>\n</ol>\n<p>[Note: This may also apply to C and other languages.]</p>\n", "AcceptedAnswerId": "28967979", "Title": "Why extended ASCII (special) characters take 2 bytes to get stored?", "CreationDate": "2015-03-10T14:18:16.877", "Id": "28966141", "CommentCount": "5", "LastEditDate": "2015-07-03T17:53:01.403", "PostTypeId": "1", "LastEditorUserId": "3204551", "LastActivityDate": "2015-07-03T17:53:01.403", "Score": "1", "OwnerUserId": "514235", "Tags": "<c++><c++11><utf-8><byte><ascii>", "AnswerCount": "3"}, "28966680": {"Id": "28966680", "PostTypeId": "2", "Body": "<p>The basic source character set for C++ source code does not include extended ASCII characters (ref. \u00a72.3 in ISO/IEC 14882:2011) :</p>\n<blockquote>\n<p id=\"so_28966141_28966680_0\">The basic source character set consists of 96 characters: the space character, the control characters representing horizontal tab, vertical tab, form feed, and new-line, plus the following 91 graphical characters:</p>\n<p id=\"so_28966141_28966680_1\">a b c d e f g h i j k l m n o p q r s t u v w x y z</p>\n<p id=\"so_28966141_28966680_2\">A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</p>\n<p id=\"so_28966141_28966680_3\">0 1 2 3 4 5 6 7 8 9</p>\n<p id=\"so_28966141_28966680_4\">_ { } [ ] # ( ) &lt; &gt; % : ; . ? * + - / ^ &amp; | \u223c ! = , \\ \" \u2019</p>\n</blockquote>\n<p>So, an implementation has to map those characters from the source file to characters in the basic source character set, before passing them on to the compiler. They will likely be mapped to universal character names, following ISO/IEC 10646 (UCS) :</p>\n<blockquote>\n<p id=\"so_28966141_28966680_5\">The universal-character-name construct provides a way to name other characters.</p>\n<p id=\"so_28966141_28966680_6\">The character designated by the universal-character-name \\UNNNNNNNN is that character whose character short name in ISO/IEC 10646 is NNNNNNNN; the character designated by the universal-character-name \\uNNNN is that character whose character short name in ISO/IEC 10646 is 0000NNNN.</p>\n</blockquote>\n<p>A universal character name in a narrow string literal (as in your case) may be mapped to multiple chars, using multibyte encoding (ref. \u00a72.14.5 in ISO/IEC 14882:2011) :</p>\n<blockquote>\n<p id=\"so_28966141_28966680_7\">In a narrow string literal, a universal-character-name may map to more than one char element due to multibyte encoding.</p>\n</blockquote>\n<p>That's what you're seeing for those 3 last characters.</p>\n", "LastEditorUserId": "822669", "LastActivityDate": "2015-03-10T14:49:13.183", "Score": "2", "CreationDate": "2015-03-10T14:41:35.610", "ParentId": "28966141", "CommentCount": "0", "OwnerUserId": "822669", "LastEditDate": "2015-03-10T14:49:13.183"}});