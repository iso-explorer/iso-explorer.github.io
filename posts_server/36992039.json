post_cb({"bq_ids": {"n4140": {"so_36992039_36992250_0": {"length": 18, "quality": 0.9, "section_id": 5995}, "so_36992039_36992152_1": {"length": 18, "quality": 0.72, "section_id": 5995}, "so_36992039_36992143_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 5991}}, "n3337": {"so_36992039_36992250_0": {"length": 17, "quality": 0.85, "section_id": 5763}, "so_36992039_36992152_1": {"length": 21, "quality": 0.84, "section_id": 5763}, "so_36992039_36992143_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 5759}}}, "36992152": {"LastActivityDate": "2016-05-12T14:01:02.947", "CommentCount": "6", "Body": "<p>The order in which the arguments to a function are evaluated is not specified by the standard. From the C++11 Standard (<a href=\"http://eel.is/c++draft/expr.call#8\" rel=\"nofollow\">online draft</a>):</p>\n<blockquote>\n<p id=\"so_36992039_36992152_0\"><strong>5.2.2 Function call</strong></p>\n<p id=\"so_36992039_36992152_1\">8 [ <em>Note:</em> The evaluations of the postfix expression and of the argument expressions are all unsequenced relative to one another. All side effects of argument expression evaluations are sequenced before the function\n  is entered (see 1.9). <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>Hence, it is entirely up to an implementation to decide in what order to evaluate the arguments to a function. This, in turn, implies that the order of construction of the arguments is also implementation dependent.</p>\n<p>A sensible implementation would destroy the objects in the reverse order of their construction.</p>\n", "CreationDate": "2016-05-02T21:43:10.357", "LastEditDate": "2016-05-12T14:01:02.947", "ParentId": "36992039", "Id": "36992152", "LastEditorUserId": "3919155", "PostTypeId": "2", "Score": "11", "OwnerUserId": "434551"}, "36992039": {"CreationDate": "2016-05-02T21:33:19.753", "ViewCount": "1425", "FavoriteCount": "6", "Id": "36992039", "AcceptedAnswerId": "36992152", "Score": "35", "Title": "What is the order of destruction of function arguments?", "LastEditorUserId": "-1", "CommentCount": "21", "Body": "<p>If some function <code>f</code> with parameters <code>p_1</code>, ..., <code>p_n</code> of types <code>T_1</code>, ..., <code>T_n</code> respectively is called with arguments <code>a_1</code>, ..., <code>a_n</code> and its body throws an exception, finishes or returns, in what order are the arguments destroyed and why? Please provide a reference to the standard, if possible.</p>\n<p><strong>EDIT:</strong> I actually wanted to ask about function \"parameters\", but as T.C. and Columbo managed to clear my confusion, I'm leaving this question be about the arguments and asked <a href=\"https://stackoverflow.com/q/36992569/3919155\">a new separate question about the parameters</a>. See the comments on this question for the distinction.</p>\n", "Tags": "<c++><function><arguments><language-lawyer><object-lifetime>", "LastEditDate": "2017-05-23T12:24:19.243", "LastActivityDate": "2016-06-09T07:12:36.423", "PostTypeId": "1", "AnswerCount": "3", "OwnerUserId": "3919155"}, "36992250": {"LastActivityDate": "2016-05-12T13:58:46.857", "CommentCount": "0", "Body": "<p>I did not manage to find the answer in the standard, but I was able to test this on 3 most popular C++ compliant compilers. The answer of <strong>R Sahu</strong> pretty much explains that it is implementation defined.</p>\n<blockquote>\n<p id=\"so_36992039_36992250_0\"><a href=\"http://eel.is/c++draft/expr.call#8\" rel=\"nofollow noreferrer\">\u00a75.2.2/8</a>: The evaluations of the postfix expression and of the arguments are all unsequenced relative to one\n  another. All side effects of argument evaluations are sequenced before the function is entered.</p>\n</blockquote>\n<p><em>Visual Studio C++ Compiler (Windows) and gcc (Debian)</em><br>\nArguments are constructed in order reverse to their declaration and destroyed in reversed order (thus destroyed in order of delcaration):</br></p>\n<blockquote>\n<p id=\"so_36992039_36992250_1\">2<br>\n  1<br>\n  -1<br>\n  -2  </br></br></br></p>\n</blockquote>\n<p><em>Clang (FreeBSD)</em><br>\nArguments are constructed in order of their declaration and destroyed in reversed order:</br></p>\n<blockquote>\n<p id=\"so_36992039_36992250_2\">1<br>\n  2<br>\n  -2<br>\n  -1</br></br></br></p>\n</blockquote>\n<p>All compilers were instructed to treat the source code as C++11 and I used the following snippet to demonstrate the situation:</p>\n<pre><code>struct A\n{\n    A(int) { std::cout &lt;&lt; \"1\" &lt;&lt; std::endl; }\n    ~A() { std::cout &lt;&lt; \"-1\" &lt;&lt; std::endl; }\n};\n\nstruct B\n{\n    B(double) { std::cout &lt;&lt; \"2\" &lt;&lt; std::endl; }\n    ~B() { std::cout &lt;&lt; \"-2\" &lt;&lt; std::endl; }\n};\n\nvoid f(A, B) { }\n\nint main()\n{\n    f(4, 5.);\n}\n</code></pre>\n", "CreationDate": "2016-05-02T21:52:37.313", "LastEditDate": "2016-05-12T13:58:46.857", "ParentId": "36992039", "Id": "36992250", "LastEditorUserId": "3919155", "PostTypeId": "2", "Score": "21", "OwnerUserId": "3087601"}, "36992143": {"LastActivityDate": "2016-05-12T14:00:23.460", "CommentCount": "15", "Body": "<p>In \u00a75.2.2[4] <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">N3337</a> is quite explicit on what happens (<a href=\"http://eel.is/c++draft/expr.call#4\" rel=\"nofollow\">online draft</a>):</p>\n<blockquote>\n<p id=\"so_36992039_36992143_0\">During the initialization of a parameter, an implementation may avoid the construction of extra temporaries by combining the conversions on the associated argument and/or the construction of temporaries with the\n  initialization of the parameter (see 12.2). The lifetime of a parameter ends when the function in which it is defined returns.</p>\n</blockquote>\n<p>So for example in</p>\n<pre><code>f(g(h()));\n</code></pre>\n<p>the return value from the call <code>h()</code> is a temporary that will be destroyed at the end of the full expression. However the compiler is allowed to avoid this temporary and directly initialize with its value the parameter of <code>g()</code>. In this case the return value will be destroyed once <code>g()</code> returns (i.e. BEFORE calling <code>f()</code>).</p>\n<p>If I understood correctly what is stated in the standard however it's not permitted to have the value returned from <code>h()</code> to survive to the end of the full expression unless a copy is made (the parameter) and this copy is destroyed once <code>g()</code> returns.</p>\n<p>The two scenarios are:</p>\n<ol>\n<li><code>h</code> return value is used to directly initialize <code>g</code> parameter. This object is destroyed when <code>g</code> returns and before calling <code>f</code>.</li>\n<li><code>h</code> return value is a temporary. A copy is made to initialize <code>g</code> parameter and it is destroyed when <code>g</code> returns. The original temporary is destroyed at the end of the full expression instead.</li>\n</ol>\n<p>I don't know if implementations are following the rules on this.</p>\n", "CreationDate": "2016-05-02T21:42:23.683", "LastEditDate": "2016-05-12T14:00:23.460", "ParentId": "36992039", "Id": "36992143", "LastEditorUserId": "3919155", "PostTypeId": "2", "Score": "14", "OwnerUserId": "320726"}});