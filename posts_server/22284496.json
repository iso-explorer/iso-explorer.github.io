post_cb({"bq_ids": {"n4140": {"so_22284496_22286476_0": {"length": 47, "quality": 0.9038461538461539, "section_id": 87}}, "n3337": {"so_22284496_22286476_0": {"length": 41, "quality": 0.7884615384615384, "section_id": 82}}}, "22286476": {"PostTypeId": "2", "Body": "<p>That's not a bug in clang, but an unfortunate restriction of arguments for non-type template parameters of pointer type (see <a href=\"https://stackoverflow.com/questions/15885399/pointer-as-non-type-template-argument\">pointer as non-type template argument</a>). Essentially, you can only use arguments of the form <code>&amp;something</code>: [temp.arg.nontype]/1 (from n3797)</p>\n<blockquote>\n<p id=\"so_22284496_22286476_0\">[if the template-parameter is a pointer, its argument can be] a constant expression (5.19) that designates the address of a\n  complete object with static storage duration and external or\n  internal linkage or a function with external or internal linkage,\n  including function templates and function <em>template-ids</em> but excluding\n  non-static class members, <strong>expressed (ignoring parentheses) as <code>&amp;</code>\n<em>id-expression</em>, where the <em>id-expression</em> is the name of an object or\n  function</strong>, except that the &amp; may be omitted if the name refers to a\n  function or array and shall be omitted if the corresponding\n  <em>template-parameter</em> is a reference; or [..]</p>\n</blockquote>\n<p>[emphasis mine]</p>\n<p>You can however, use a function pointer in a constant expression that has a non-pointer type, for example a boolean expression such as</p>\n<pre><code>T::ptr != nullptr\n</code></pre>\n<p>This works under clang++3.5 and g++4.8.2:</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\n\ntypedef int (*ptr_t)();\nint bar() { return 9; }\n\nstruct Foo0 {\n    static constexpr ptr_t ptr = &amp;bar;\n};\n\nstruct Foo1 {\n    static const ptr_t ptr;\n};\nptr_t const Foo1::ptr = &amp;bar;\n\nstruct Foo2 {\n    static const ptr_t ptr;\n};\n//ptr_t const Foo2::ptr = nullptr;\n\nnamespace detail\n{\n    template &lt;bool&gt;\n    struct sfinae_true : std::true_type {};\n\n    template &lt;class T&gt;\n    sfinae_true&lt;(T::ptr != nullptr)&gt; check(int);\n    // the result of the comparison does not care\n\n    template &lt;class&gt;\n    std::false_type check(...);\n}  // detail::\n\ntemplate &lt;class T&gt;\nstruct has_constexpr_f : decltype(detail::check&lt;T&gt;(0)) {};\n\nint main(int argc, char *argv[]) {\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; has_constexpr_f&lt;Foo0&gt;::value &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; has_constexpr_f&lt;Foo1&gt;::value &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; has_constexpr_f&lt;Foo2&gt;::value &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Note there's a difference between clang++ and g++ for the second output (<code>Foo1</code>): g++ says <code>true</code>, clang++ says <code>false</code>.</p>\n", "LastActivityDate": "2014-03-09T18:46:56.020", "LastEditorUserId": "-1", "Id": "22286476", "CommentCount": "2", "CreationDate": "2014-03-09T18:46:56.020", "ParentId": "22284496", "Score": "0", "OwnerUserId": "420683", "LastEditDate": "2017-05-23T11:49:46.100"}, "22284496": {"ViewCount": "228", "Body": "<p>Based on the answer in <a href=\"https://stackoverflow.com/questions/15232758/detecting-constexpr-with-sfinae\">Detecting constexpr with SFINAE</a> I'm trying to use SFINAE to check if a 'constexpr' is present in my class.</p>\n<p>The problem is that the constexpr is a function pointer: </p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\n\ntypedef int (*ptr_t)();\nint bar() { return 9; }\n\nstruct Foo {\n    static constexpr ptr_t ptr = &amp;bar;\n};\n\nnamespace detail {\ntemplate &lt;ptr_t&gt;\nstruct sfinae_true : std::true_type {};\n\ntemplate &lt;class T&gt;\nsfinae_true&lt;T::ptr&gt; check(int);\n\n// Commented out to see why clang was not evaluating to true. This should only be\n// a comment when debugging!\n// template &lt;class&gt;\n// std::false_type check(...);\n}  // detail::\n\ntemplate &lt;class T&gt;\nstruct has_constexpr_f : decltype(detail::check&lt;T&gt;(0)) {};\n\nint main(int argc, char *argv[]) {\n    std::cout &lt;&lt; has_constexpr_f&lt;Foo&gt;::value &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>It seems to work fine using gcc, but clang complains:</p>\n<pre><code>test.cxx:23:39: error: no matching function for call to 'check'\n    struct has_constexpr_f : decltype(detail::check&lt;T&gt;(0)) {};\n                                      ^~~~~~~~~~~~~~~~\ntest.cxx:26:22: note: in instantiation of template class 'has_constexpr_f&lt;Foo&gt;' requested here\n        std::cout &lt;&lt; has_constexpr_f&lt;Foo&gt;::value &lt;&lt; std::endl;\n                     ^\ntest.cxx:16:25: note: candidate template ignored: substitution failure [with T = Foo]: non-type template argument for template parameter of pointer type 'ptr_t' (aka 'int (*)()') must have its address taken\n    sfinae_true&lt;T::ptr&gt; check(int);\n                ~       ^\n1 error generated.\n</code></pre>\n<p>Q1: Can anyone suggest a way of doing this which works both for Clang and GCC?</p>\n<p>Q2: Is this a bug in gcc, clang or is this left undefined in the c++ standard?</p>\n", "AcceptedAnswerId": "22286476", "Title": "Clang issue: Detecting constexpr function pointer with SFINAE", "CreationDate": "2014-03-09T16:00:36.620", "Id": "22284496", "CommentCount": "0", "LastEditDate": "2017-05-23T11:49:46.100", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2014-03-09T18:46:56.020", "Score": "1", "OwnerUserId": "339753", "Tags": "<c++11><template-meta-programming>", "AnswerCount": "1"}});