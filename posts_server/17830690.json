post_cb({"17831126": {"Id": "17831126", "PostTypeId": "2", "Body": "<p>NO one compiler initialize with zero. I can say that somehow you were lucky.\nTry this in online compiler you gave.  </p>\n<pre><code>for(int i;i &lt; 10; ++i)   \n{  \n    int a;  \n    cout &lt;&lt; a &lt;&lt; endl;  \n    a = 1;  \n}\n</code></pre>\n<p>And you will see that first time a is equal 0 and next 9 times it's equal 1.</p>\n", "LastActivityDate": "2013-07-24T10:17:07.753", "CommentCount": "0", "CreationDate": "2013-07-24T10:17:07.753", "ParentId": "17830690", "Score": "0", "OwnerUserId": "2281611"}, "17830996": {"Id": "17830996", "PostTypeId": "2", "Body": "<p>What initialization.  In your example, accessing <code>i</code> is\nundefined behavior, since it wasn't initialized.  Some compilers\n<em>do</em> initialize it, at least in debug mode, but generally with\nsomething like <code>0xDEADBEEF</code> or <code>0xCCCCCCCC</code>, so that you can\neasily recognize in a debugger that you're accessing\nuninitialized memory (and so that the program is likely to crash\nif you use it as a pointer), but this is not required.</p>\n<p>The only time built-in types are implicitly initialized is when\nthey have static storage duration: variables defined at\nnamespace scope (include static class members), or local\nvariables which have been declared <code>static</code>.  </p>\n<p>You don't show the context of your code, but if it is directly\nin <code>main</code>, or in the first function called from <code>main</code>, <code>int i</code>\nwill be the first use of this actual memory.  And the OS\nprobably will have set it to 0, for security reasons.  You might\nwant to try something like:</p>\n<pre><code>void scribble()\n{\n    int x = 0x12345678;\n}\n\nvoid testit()\n{\n    for ( int i; i &lt; 10; ++ i ) {\n        std::cout &lt;&lt; i &lt;&lt; '\\n';\n    }\n}\n\nint\nmain()\n{\n    scribble();\n    testit();\n    return 0;\n}\n</code></pre>\n<p>The call to <code>std::operator&lt;&lt;( std::ostream&amp;, char const* )</code> is\nmight have left something different from 0 in this\nparticular memory cell.  (Or the compiler has optimized it out.\nTry this with all optimization turned off.)  Neither g++ nor\nVC++ initialize the <code>i</code> in <code>testit</code>.</p>\n", "LastEditorUserId": "649665", "LastActivityDate": "2013-07-24T10:25:57.777", "Score": "2", "CreationDate": "2013-07-24T10:11:02.870", "ParentId": "17830690", "CommentCount": "1", "OwnerUserId": "649665", "LastEditDate": "2013-07-24T10:25:57.777"}, "17830690": {"ViewCount": "904", "Body": "<p>Do all \"real\" C++ compilers don't have default initialization with zeros of built-in types? I'm asking 'cos I've found <a href=\"http://www.compileonline.com/compile_cpp_online.php\" rel=\"nofollow\">on-line compilers</a> that is claimed to be gcc, and it does zero initialization of built-in types</p>\n<pre><code>int h=6548;\n   for (int i; i &lt; 10; ++i) {\n    cout&lt;&lt;i&lt;&lt;\"\\n\";\n}\n</code></pre>\n<p>for this code its output is</p>\n<pre><code>0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n</code></pre>\n", "Title": "C++ default initialization of built-in types", "CreationDate": "2013-07-24T09:56:48.370", "Id": "17830690", "CommentCount": "13", "LastEditDate": "2013-07-24T10:16:54.860", "PostTypeId": "1", "LastEditorUserId": "207421", "LastActivityDate": "2013-07-24T10:45:03.343", "Tags": "<c++><gcc><compiler-construction><initialization>", "Score": "-2", "OwnerUserId": "2298709", "ClosedDate": "2013-07-25T05:12:22.637", "AnswerCount": "5"}, "17831711": {"Id": "17831711", "PostTypeId": "2", "Body": "<p>Whether or not the values are initialized is undefined behaviour and implementation dependant. You must not rely on that.</p>\n<h3>1. C++11, 8.5/11</h3>\n<blockquote>\n<p id=\"so_17830690_17831711_0\">If <strong>no initializer</strong> is specified for an object, the object is default-initialized; if no initialization is performed, an object with automatic or dynamic storage duration has <strong>indeterminate value</strong>. [ Note: Objects with static or thread storage duration are zero-initialized, see 3.6.2. \u2014end note ]</p>\n</blockquote>\n<p>If you use <code>int i;</code> this results in an uninitialized integer which has \"<em>indeterminate value</em>\"! You can't predict what will happen if you access it's value.</p>\n<h3>2. C++11, 8.5/10</h3>\n<blockquote>\n<p id=\"so_17830690_17831711_1\"><strong>An object whose initializer is an empty set of parentheses, i.e., (), shall be value-initialized</strong>.</p>\n</blockquote>\n<p>If you use <code>int i = int();</code> you have a value-initialized <code>i</code>. Now, what is value-initialized?</p>\n<h3>3. C++11, 8.5/7</h3>\n<blockquote>\n<p id=\"so_17830690_17831711_2\">To <strong>value-initialize</strong> an object of type T <strong>means</strong>:</p>\n<ul>\n<li>[...] (some options where T may be class or array type)</li>\n<li>otherwise, the object is <strong>zero-initialized.</strong></li>\n</ul>\n</blockquote>\n<p>Ok now we know that <code>int i = int();</code> means having <code>i=0</code>.</p>\n<p><strong>Be aware of the following:</strong></p>\n<blockquote>\n<p id=\"so_17830690_17831711_3\">Note: Since () is not permitted by the syntax for initializer,  </p>\n<p id=\"so_17830690_17831711_4\">\u00a0\u00a0\u00a0\u00a0<code>X a();</code></p>\n<p id=\"so_17830690_17831711_5\">is not the declaration of a value-initialized object of class X, but the declaration of a function taking no argument and returning an X.</p>\n</blockquote>\n<p><sub>Emphasis on standard quotes are mine.</sub></p>\n", "LastActivityDate": "2013-07-24T10:45:03.343", "CommentCount": "0", "CreationDate": "2013-07-24T10:45:03.343", "ParentId": "17830690", "Score": "1", "OwnerUserId": "951423"}, "bq_ids": {"n4140": {"so_17830690_17831711_5": {"length": 9, "quality": 0.9, "section_id": 3290}, "so_17830690_17831711_3": {"length": 4, "quality": 0.8, "section_id": 3290}, "so_17830690_17831711_1": {"length": 7, "quality": 1.0, "section_id": 3290}, "so_17830690_17831711_0": {"length": 19, "quality": 0.76, "section_id": 3291}, "so_17830690_17831711_2": {"length": 4, "quality": 1.0, "section_id": 3287}}, "n3337": {"so_17830690_17831711_0": {"length": 21, "quality": 0.84, "section_id": 3161}, "so_17830690_17831711_5": {"length": 9, "quality": 0.9, "section_id": 3160}, "so_17830690_17831711_1": {"length": 7, "quality": 1.0, "section_id": 3160}, "so_17830690_17831711_3": {"length": 4, "quality": 0.8, "section_id": 3160}, "so_17830690_17831711_2": {"length": 4, "quality": 1.0, "section_id": 3157}}, "n4659": {"so_17830690_17831711_0": {"length": 19, "quality": 0.76, "section_id": 4053}, "so_17830690_17831711_5": {"length": 9, "quality": 0.9, "section_id": 4052}, "so_17830690_17831711_1": {"length": 7, "quality": 1.0, "section_id": 4052}, "so_17830690_17831711_3": {"length": 4, "quality": 0.8, "section_id": 4052}}}, "17830873": {"Id": "17830873", "PostTypeId": "2", "Body": "<p>It may depend on compilers to compilers, but it is better to make initialization a habit because you may not know which old compiler you may end up with and you may get screwed up by using the uninitialized garbage values....\nAnother compiler is <a href=\"http://codepad.org/\" rel=\"nofollow\">http://codepad.org/</a> which also initializes on its part..</p>\n", "LastEditorUserId": "1571180", "LastActivityDate": "2013-07-24T10:38:32.383", "Score": "0", "CreationDate": "2013-07-24T10:05:25.733", "ParentId": "17830690", "CommentCount": "13", "OwnerUserId": "1571180", "LastEditDate": "2013-07-24T10:38:32.383"}, "17830955": {"Id": "17830955", "PostTypeId": "2", "Body": "<p>Both the C and C++ standards are VERY clear that there is only one kind of memory that is initialize, and that is the memory for static storage. </p>\n<p>Variable with static storage duration are guaranteed to be zero (that aren't initialized or have a constructor). Everything else is \"uninitialized\", which means \"you don't know what it will be\" - and one of the options is of course that it is zero. </p>\n<p>All other variables are almost guaranteed to not be zero, at least under some circumstances - and it may well be that you can't find those circumstances with a simple test program.</p>\n<p>For example, <code>malloc</code> (or <code>new</code>) memory is often zero for \"virgin\" memory, but fill it with something, then free it and use it again, and it's no longer zero. </p>\n<p>Variables on the stack almost inevitably will have different values depending on what the previous call was (and thus, what stuff got put on the stack in the previous function that the code visited). </p>\n", "LastEditorUserId": "1919155", "LastActivityDate": "2013-07-24T10:33:24.890", "Score": "1", "CreationDate": "2013-07-24T10:09:05.970", "ParentId": "17830690", "CommentCount": "4", "OwnerUserId": "1919155", "LastEditDate": "2013-07-24T10:33:24.890"}});