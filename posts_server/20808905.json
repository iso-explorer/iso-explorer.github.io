post_cb({"20808956": {"ParentId": "20808905", "CommentCount": "27", "Body": "<p>The standard just mandates that the type of <code>sizeof(expr)</code> is the same type as <code>std::size_t</code>. There is no mandate that using <code>sizeof(expr)</code> makes the name <code>std::size_t</code> available and since <code>std::size_t</code> just names one of the the built-in integral types there isn't really a problem.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "20808956", "Score": "50", "CreationDate": "2013-12-27T22:56:48.950", "LastActivityDate": "2013-12-27T22:56:48.950"}, "20809251": {"ParentId": "20808905", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Yes.</p>\n<p>The type yielded by <code>sizeof</code> is some unsigned integer type; the implementation defines which one it is.</p>\n<p>For example, on some particular implementation, the type of a <code>sizeof</code> expression might be <code>unsigned long</code>.</p>\n<p><code>std::size_t</code>, if it's a <code>typedef</code>, is nothing more than an alternative name for <code>unsigned long</code>. So these two statements:</p>\n<blockquote>\n<p id=\"so_20808905_20809251_0\">The type of <code>sizeof ...</code> is a constant of type <code>unsigned long</code></p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_20808905_20809251_1\">The type of <code>sizeof ...</code> is a constant of type <code>std::size_t</code></p>\n</blockquote>\n<p>are saying exactly the same thing <em>for that implementation</em>. The type <code>unsigned long</code> and the type <code>std::size_t</code> are the same type. The difference is that the latter is accurate for all (conforming) implementations, where <code>std::size_t</code> might be an alias for, say, <code>unsigned int</code> or some other unsigned type.</p>\n<p>As far as the compiler is concerned, <code>sizeof</code> yields a result of type <code>unsigned long</code>; the compiler (as opposed to the runtime library) needn't have any knowledge of the name <code>size_t</code>.</p>\n<p>This all assumes that <code>std::size_t</code> (or just <code>size_t</code> if you're talking about C) is a typedef. That's not spelled out in either the C or the C++ standard. Nevertheless, an implementation can straightforwardly conform to the requirements of the standard by making <code>size_t</code> a typedef. I don't believe there's any other <em>portable</em> way to satisfy those requirements. (It can't be a macro or an implementation-defined keyword because that would infringe on the user's name space, and a macro wouldn't be scoped within the <code>std</code> namespace.) A compiler <em>could</em> make <code>size_t</code> some implementation-specific construct other than a typedef, but since a typedef works perfectly well, there's no point in doing so. It would be nice, IMHO, if the standard stated that <code>size_t</code> is a typedef.</p>\n<p>(An irrelevant aside: The real problem is that the standard refers to the result as a \"constant\". In ISO C, a \"constant\" is a token, such as an integer literal. C++, as far as I know, doesn't define the noun \"constant\", but it does refer to the ISO C definition of the term. <code>sizeof ...</code> is a constant <em>expression</em>; it's not a <em>constant</em>. Calling the result a \"constant value\" would have been reasonable.)</p>\n", "OwnerUserId": "827263", "LastEditorUserId": "827263", "LastEditDate": "2013-12-27T23:56:05.797", "Id": "20809251", "Score": "5", "CreationDate": "2013-12-27T23:31:39.513", "LastActivityDate": "2013-12-27T23:56:05.797"}, "20808905": {"CommentCount": "8", "AcceptedAnswerId": "20809166", "CreationDate": "2013-12-27T22:51:52.273", "LastActivityDate": "2013-12-27T23:56:05.797", "PostTypeId": "1", "ViewCount": "2741", "FavoriteCount": "2", "Title": "Does `sizeof` *really* evaluate to a `std::size_t`? Can it?", "Id": "20808905", "Score": "58", "Body": "<p>Take the following standard passage:</p>\n<blockquote>\n<p id=\"so_20808905_20808905_0\"><code>[C++11: 5.3.3/6]:</code> The result of <code>sizeof</code> and <code>sizeof...</code> is a constant of type <code>std::size_t</code>. <em>[ Note:</em> <code>std::size_t</code> is defined in the standard header <code>&lt;cstddef&gt;</code> (18.2). <em>\u2014end note ]</em></p>\n</blockquote>\n<p>Now:</p>\n<blockquote>\n<p id=\"so_20808905_20808905_1\"><code>[C++11: 18.2/6]:</code> The type <code>size_t</code> is an implementation-defined unsigned integer type that is large enough to contain the size in bytes of any object.</p>\n</blockquote>\n<p>Granted, the passage doesn't require that <code>size_t</code> is a type alias defined with <code>typedef</code>, but since it's explicitly stated to be made available by the standard header <code>&lt;cstddef&gt;</code>, I think we can take as read that failing to include <code>&lt;cstddef&gt;</code> should remove any guarantee that <code>size_t</code> shall be available to a program.</p>\n<p>However, according to that first quote, we can regardless obtain an expression of type <code>std::size_t</code>.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/2773cc8d2a92d4e7\">We can actually demonstrate both of these facts</a>:</p>\n<pre><code>int main()\n{\n    typedef decltype(sizeof(0)) my_size_t;\n\n    my_size_t x   = 0;  // OK\n    std::size_t y = 1;  // error: 'size_t' is not a member of 'std'\n}\n</code></pre>\n<p><code>std::size_t</code> is not visible to the program, but <code>sizeof(0)</code> still gives us one? Really?</p>\n<p><strong>Is it therefore not correct to say that <code>5.3.3/6</code> is <em>flawed</em>, and that it actually has \"the same type as whatever <code>std::size_t</code> resolves to\", but <em>not</em> <code>std::size_t</code> itself?</strong></p>\n<p>Sure, the two are one and the same if <code>std::size_t</code> is a type alias but, again, nowhere is this actually required.</p>\n", "Tags": "<c++><c++11><std><language-lawyer>", "OwnerUserId": "560648", "AnswerCount": "5"}, "20809166": {"ParentId": "20808905", "CommentCount": "5", "Body": "<p>Do not confuse the map for the territory.</p>\n<p>Types can be named by typenames.  These typenames can be built-in, they can be user-defined types, or they could even be <code>template</code> parameters and refer to multiple different types depending on the instantiation.</p>\n<p>But the names are not the types.  Clearly standard does not mandate that all types have names -- the classic <code>struct {}</code> is a type without a name.</p>\n<p><code>std::size_t</code> is a typename.  It names the type that <code>sizeof(expression)</code> returns.</p>\n<p>The compiler could have a canonical name for the type -- <code>__size_t</code> would be one way for it to have a unique built-in canonical typename.</p>\n<p>The standard guarantees in that clause that whatever the type of <code>sizeof(expression)</code> is, once you <code>#include &lt;cstddef&gt;</code>, the name <code>std::size_t</code> now refers to that type.</p>\n<p>In the standard, they refer to types by names.  They do not say \"the type that this typename refers to\", but simply say \"the type $NAME$\".  The compiler could decide that <code>int</code> is another name for <code>__int_32_fast</code> if it wanted to, and the standard would have no objection either.</p>\n<p>This same thing happens with <code>std::nullptr_t</code> and <code>std::initializer_list&lt;Ts&gt;</code> and <code>std::type_info</code>: use of variables of those types does not always require that the header that provides you with a name for those types be included in your program.</p>\n<p>The traditional C/C++ built-in types all had canonical names that did not require a header.  The downside is that this breaks existing code, as new typenames in the global scope collide with other identifiers.</p>\n<p>By having \"nameless types\", where you can get a name for them via including a header file, we avoid that problem.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "20809166", "Score": "44", "CreationDate": "2013-12-27T23:20:07.257", "LastActivityDate": "2013-12-27T23:20:07.257"}, "20808939": {"ParentId": "20808905", "CommentCount": "1", "Body": "<p>It is the same type but you have to include that header to use it.</p>\n", "OwnerUserId": "2030677", "PostTypeId": "2", "Id": "20808939", "Score": "2", "CreationDate": "2013-12-27T22:55:30.183", "LastActivityDate": "2013-12-27T22:55:30.183"}, "20809037": {"ParentId": "20808905", "CommentCount": "8", "Body": "<p>As I understand it, this standard passage requires the following expression:</p>\n<pre><code>typeid(sizeof(0)) == typeid(std::size_t)\n</code></pre>\n<p>will always yield <code>true</code>. If you use the actual identifier <code>std::size_t</code>, <code>::size_t</code> or any other alias/typedef will be irrelevant as long as the identity of the type, as per <code>std::typeinfo::operator==()</code>, is preserved.</p>\n<p>The same <em>type identity</em> issue appears in other places of the language. For example, in my 64-bit machine the following code fails to compile because of function redefinition:</p>\n<pre><code>#include &lt;cstddef&gt;\nvoid foo(std::size_t x)\n{}\n\nvoid foo(unsigned long x)\n{}\n</code></pre>\n", "OwnerUserId": "865874", "PostTypeId": "2", "Id": "20809037", "Score": "5", "CreationDate": "2013-12-27T23:04:03.590", "LastActivityDate": "2013-12-27T23:04:03.590"}, "bq_ids": {"n4140": {"so_20808905_20808905_0": {"section_id": 6081, "quality": 0.5882352941176471, "length": 10}, "so_20808905_20808905_1": {"section_id": 6708, "quality": 0.7333333333333333, "length": 11}, "so_20808905_20809251_1": {"section_id": 6081, "quality": 0.6666666666666666, "length": 4}, "so_20808905_20809251_0": {"section_id": 3487, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_20808905_20808905_0": {"section_id": 5849, "quality": 0.5882352941176471, "length": 10}, "so_20808905_20808905_1": {"section_id": 6463, "quality": 0.7333333333333333, "length": 11}, "so_20808905_20809251_1": {"section_id": 5849, "quality": 0.6666666666666666, "length": 4}, "so_20808905_20809251_0": {"section_id": 3352, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_20808905_20808905_0": {"section_id": 7577, "quality": 0.5882352941176471, "length": 10}, "so_20808905_20808905_1": {"section_id": 8183, "quality": 0.7333333333333333, "length": 11}, "so_20808905_20809251_1": {"section_id": 3985, "quality": 0.6666666666666666, "length": 4}, "so_20808905_20809251_0": {"section_id": 4250, "quality": 0.5714285714285714, "length": 4}}}});