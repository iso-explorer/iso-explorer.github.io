post_cb({"39801353": {"ParentId": "39800666", "CommentCount": "0", "CreationDate": "2016-09-30T23:16:47.990", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "39801353", "Score": "11", "Body": "<p>The rule in <a href=\"http://eel.is/c++draft/class.copy#32\" rel=\"noreferrer\">[class.copy]</a> is:</p>\n<blockquote>\n<p id=\"so_39800666_39801353_0\">[...] when the <em>expression</em> in a <code>return</code> statement is a (possibly\n  parenthesized) <em>id-expression</em> that names an object with automatic storage duration declared in the body or <em>parameter-declaration-clause</em> of the innermost enclosing function or <em>lambda-expression</em>, overload resolution to\n  select the constructor for the copy is first performed as if the object were designated by an rvalue.</p>\n</blockquote>\n<p>In this example:</p>\n<pre><code>std::unique_ptr&lt;int&gt; foo() {\n  std::unique_ptr&lt;int&gt; p {new int{10}};\n  return p;\n}\n</code></pre>\n<p><code>p</code> is the name of an object with automatic storage duration declared in the body of the function. So rather than copying it into the return value, we first try to move it. That works fine.</p>\n<p>But in this example:</p>\n<pre><code>static std::unique_ptr&lt;int&gt; Foo(A &amp;a) {\n    return a.p;\n}\n</code></pre>\n<p>that doesn't apply.  <code>a.p</code> isn't the name of an object at all, so we don't try overload resolution as if it were an rvalue, we instead just do the normal thing: try to copy it. This fails, so you have to explicitly <code>move()</code> it.</p>\n<hr/>\n<p>That's the wording of the rule, but it might not answer your question. Why is this the rule? Basically - we're trying to be safe. If we're naming a local variable, it's always safe to move from it in a return statement. It will never be accessed again. Easy optimization, no possible downside. But in your original example, <code>a</code> isn't owned by this function, neither is <code>a.p</code>. It's not inherently safe to move from it, so the language won't try to do it automatically. </p>\n", "LastActivityDate": "2016-09-30T23:16:47.990"}, "39800666": {"CommentCount": "1", "ViewCount": "222", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2016-09-30T22:00:05.947", "LastActivityDate": "2016-10-01T15:11:41.067", "Title": "Returning member unique_ptr from class method", "AcceptedAnswerId": "39801353", "LastEditDate": "2016-09-30T23:18:29.680", "Id": "39800666", "Score": "13", "Body": "<p>I am trying to return a <code>std::unique_ptr class</code> member (trying to move the ownership) to the caller. The following is a sample code snippet:</p>\n<pre><code>class A {\npublic:\n  A() : p {new int{10}} {}\n\n  static std::unique_ptr&lt;int&gt; Foo(A &amp;a) {\n    return a.p; // ERROR: Copy constructor getting invoked\n                // return std::move(a.p); WORKS FINE\n  }\n\n  std::unique_ptr&lt;int&gt; p;\n};\n</code></pre>\n<p>I thought the compiler (gcc-5.2.1) would be able to do return value optimization (copy elision) in this case without requiring the explicit intent via <code>std::move()</code>. But that isn't the case. Why not?</p>\n<p>The following code seems to be working fine, which seems equivalent:</p>\n<pre><code>std::unique_ptr&lt;int&gt; foo() {\n  std::unique_ptr&lt;int&gt; p {new int{10}};\n  return p;\n}\n</code></pre>\n", "Tags": "<c++><c++11><smart-pointers><rvo>", "OwnerUserId": "6906795", "AnswerCount": "2"}, "39808179": {"ParentId": "39800666", "CommentCount": "3", "CreationDate": "2016-10-01T15:11:41.067", "OwnerUserId": "1987633", "PostTypeId": "2", "Id": "39808179", "Score": "-1", "Body": "<p>Copy elision can't apply (among other reasons) since <code>a.p</code> is a <code>std::unique_ptr</code>, which is uncopyable.  And since <code>a.p</code> has a lifetime beyond the body of <code>A::Foo(A&amp;)</code>, it would be very surprising (as in, surprising to the person writing the code) if the compiler automatically tried to move from <code>a.p</code>, which would likely wreck the class invariants of <code>a</code>.  It would work if you <code>return std::move(a.p);</code>, but that explicitly steals <code>a.p</code>.</p>\n", "LastActivityDate": "2016-10-01T15:11:41.067"}, "bq_ids": {"n4140": {"so_39800666_39801353_0": {"section_id": 481, "quality": 1.0, "length": 30}}, "n4659": {"so_39800666_39801353_0": {"section_id": 504, "quality": 0.9666666666666667, "length": 29}}}});