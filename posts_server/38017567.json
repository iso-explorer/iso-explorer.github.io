post_cb({"bq_ids": {"n4140": {"so_38017567_38024739_0": {"length": 7, "quality": 0.875, "section_id": 6341}}, "n3337": {"so_38017567_38024739_0": {"length": 7, "quality": 0.875, "section_id": 6098}}, "n4659": {"so_38017567_38024739_0": {"length": 6, "quality": 0.75, "section_id": 7709}}}, "38017567": {"ViewCount": "207", "Body": "<p>The following code successfully compiled with clang and MSVC but fail to compile in GCC 6.1.0.</p>\n<pre><code>#include &lt;memory&gt;\n\ntemplate&lt;typename R, typename T, typename... Args&gt;\nT* test(R(T::*)(Args...) const)\n{\n    return nullptr;\n}\n\nint main()\n{\n    using T = std::shared_ptr&lt;int&gt;;\n    T* p = test(&amp;T::get);\n}\n</code></pre>\n<p>with the following error message</p>\n<pre><code>prog.cc: In function 'int main()':\nprog.cc:13:16: error: invalid conversion from 'std::__shared_ptr&lt;int, (__gnu_cxx::_Lock_policy)2u&gt;*' to 'T* {aka std::shared_ptr&lt;int&gt;*}' [-fpermissive]\n     T* p = test(&amp;T::get);\n            ~~~~^~~~~~~~~\n</code></pre>\n<p>The problem is that libstdc++ implemented <code>std::shared_ptr</code> by inheriting member function <code>get</code> from a base class <code>std::__shared_ptr</code>.</p>\n<p>In the C++ standard <strong>20.8.2.2 Class template shared_ptr</strong>, it specifies the class definition of std::shared_ptr class with all the member functions of that class.</p>\n<p>My question is whether the implementation must at least provide all public class members as defined in the standard inside the standard class?  Is it allowed to provide the member functions by inheriting from base class as implemented in libstdc++?</p>\n", "AcceptedAnswerId": "38024739", "Title": "Is it permissible for standard library implementation to have class definition that is different from the C++ standard?", "CreationDate": "2016-06-24T16:00:42.833", "Id": "38017567", "CommentCount": "7", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2016-06-27T13:43:22.597", "LastEditorUserId": "3919155", "LastActivityDate": "2016-06-27T13:43:22.597", "Score": "12", "OwnerUserId": "3069853", "Tags": "<c++><language-lawyer><c++-standard-library>", "AnswerCount": "1"}, "38024739": {"Id": "38024739", "PostTypeId": "2", "Body": "<p>The standard's specification for types and their members is normative text, unless it <em>explicitly</em> says otherwise. As such, an implementation is required to follow that... to the extent that an implementation is required to follow <em>anything</em> from the standard.</p>\n<p>And that extent is the \"as if\" rule. Namely, the implementation is allowed to do what it wants so long as the type behaves \"as if\" it were done as specified. The reason the standard has specific language stating that types can be derived from arbitrary, implementation-provided base classes is because that is something which a user can detect. It's visible behavior (through implicit conversions and the like) and therefore the standard would have to make an exception in order to allow for it.</p>\n<p>Inheriting a member is <em>almost</em> the same thing as declaring it in your main class. Indeed, the only way I know of to tell the difference is to do what you did here: use template argument deduction rules. Even though you can specify the member as <code>Derived::get</code>, if it really comes from some base class, the compiler will know.</p>\n<p>However, [member.functions] comes to GCC's rescue here. It has explicit language allowing standard library implementations to add additional overloads to a class. Because of that, your use of <code>std::shared_ptr&lt;int&gt;::get</code> here is not well-defined behavior. Indeed, footnote 187 clarifies this:</p>\n<blockquote>\n<p id=\"so_38017567_38024739_0\">Hence, the address of a member function of a class in the C++ standard library has an unspecified type.</p>\n</blockquote>\n<p>That's merely a footnote, but the intent seems clear: you cannot rely on any particular implementation to return any particular type of member pointer. Even if you applied a cast operation to the right signature, there is no guarantee that it would work.</p>\n<p>So while the class definition in the standard library is normative text, [member.functions] makes it clear that the <em>only</em> thing you can guarantee about those definitions is that you can call those functions using the arguments provided. Anything else, like getting member pointers, is implementation-defined.</p>\n", "LastEditorUserId": "734069", "LastActivityDate": "2016-06-25T03:55:48.523", "Score": "5", "CreationDate": "2016-06-25T03:45:22.043", "ParentId": "38017567", "CommentCount": "6", "OwnerUserId": "734069", "LastEditDate": "2016-06-25T03:55:48.523"}});