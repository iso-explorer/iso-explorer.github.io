post_cb({"bq_ids": {"n4140": {"so_20548370_20631809_4": {"length": 32, "quality": 0.9411764705882353, "section_id": 7003}, "so_20548370_20631809_0": {"length": 8, "quality": 1.0, "section_id": 5490}, "so_20548370_20631809_2": {"length": 40, "quality": 0.9523809523809523, "section_id": 5505}, "so_20548370_20548370_0": {"length": 13, "quality": 1.0, "section_id": 7021}, "so_20548370_20631809_3": {"length": 35, "quality": 0.8974358974358975, "section_id": 7003}, "so_20548370_20631809_1": {"length": 14, "quality": 0.6363636363636364, "section_id": 5490}}, "n3337": {"so_20548370_20631809_4": {"length": 32, "quality": 0.9411764705882353, "section_id": 6749}, "so_20548370_20631809_0": {"length": 8, "quality": 1.0, "section_id": 5276}, "so_20548370_20631809_2": {"length": 40, "quality": 0.9523809523809523, "section_id": 5291}, "so_20548370_20631809_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 5276}, "so_20548370_20631809_3": {"length": 35, "quality": 0.8974358974358975, "section_id": 6749}, "so_20548370_20548370_0": {"length": 13, "quality": 1.0, "section_id": 6767}}, "n4659": {"so_20548370_20631809_2": {"length": 39, "quality": 0.9285714285714286, "section_id": 6939}, "so_20548370_20631809_4": {"length": 32, "quality": 0.9411764705882353, "section_id": 8500}, "so_20548370_20631809_0": {"length": 7, "quality": 0.875, "section_id": 6924}, "so_20548370_20548370_0": {"length": 13, "quality": 1.0, "section_id": 8518}, "so_20548370_20631809_3": {"length": 35, "quality": 0.8974358974358975, "section_id": 8500}}}, "20548370": {"ViewCount": "690", "Body": "<p>Consider following example</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct PureVirtual {\n    virtual void Function() = 0;\n};\n\nstruct FunctionImpl {\n    virtual void Function() {\n        std::cout &lt;&lt; \"FunctionImpl::Function()\" &lt;&lt; std::endl;\n    }   \n};\n\nstruct NonPureVirtual : public FunctionImpl, public PureVirtual {\n    using FunctionImpl::Function;\n};\n\nint main() {\n    NonPureVirtual c;\n    c.Function();\n}\n</code></pre>\n<p>Compiler (GCC 4.9, Clang 3.5) is exits with error</p>\n<pre><code>test.cpp:18:20: error: variable type 'NonPureVirtual' is an abstract class\n    NonPureVirtual c;\n                   ^\ntest.cpp:4:18: note: unimplemented pure virtual method 'Function' in 'NonPureVirtual'\n    virtual void Function() = 0;\n                 ^\n</code></pre>\n<p>But when I don't derive form <code>PureVirtual</code> everything is OK. This is weird because Standard  <em>10.4.4</em> says</p>\n<blockquote>\n<p id=\"so_20548370_20548370_0\">A class is abstract if it contains or inherits at least one pure\n  virtual function for which the final overrider is pure virtual.</p>\n</blockquote>\n<p>They are not saying anything about what the <em>final overrider</em> is but I suppose it should be <code>FunctionImpl::Function()</code> especially when I made it available through <code>using</code> directive. So why is still <code>NonPureVirtual</code> abstract class and how can I fix this.</p>\n", "AcceptedAnswerId": "20548807", "Title": "Deriving implementation of pure virtual function", "CreationDate": "2013-12-12T16:08:02.487", "Id": "20548370", "CommentCount": "13", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-12-19T08:48:19.830", "Score": "10", "OwnerUserId": "2057304", "Tags": "<c++><polymorphism><abstract-class><pure-virtual><virtual-method>", "AnswerCount": "3"}, "20548807": {"Id": "20548807", "PostTypeId": "2", "Body": "<p><code>FunctionImpl::Function</code> and <code>PureVirtual::Function</code> are different functions from different classes.</p>\n<p>Their respective types are <code>void (FunctionImpl::*)()</code> and <code>void (PureVirtual::*)()</code>.<br>\nSince <code>PureVirtual</code> and <code>FunctionImpl</code> are unrelated classes, these function types are unrelated.</br></p>\n<p>They happen to have the same name and the same parameters and return type, but since they're different, the <code>using FunctionImpl::Function</code> line doesn't make that function an override of the one in <code>PureVirtual</code>.</p>\n<p>And if you declared a variable of type <code>void (PureVirtual::*)()</code>, you wouldn't be able to assign <code>FunctionImpl::Function</code> to it.</p>\n<p>In other words, the final override of <code>PureVirtual::Function</code> is the original one in <code>PureVirtual</code>, which is pure virtual.   </p>\n<p>For making what you want possible, Matthieu M.'s answer (using a forwarding call) is the way to go, it seems.  </p>\n", "LastEditorUserId": "404970", "LastActivityDate": "2013-12-19T08:48:19.830", "Score": "11", "CreationDate": "2013-12-12T16:26:43.877", "ParentId": "20548370", "CommentCount": "9", "OwnerUserId": "404970", "LastEditDate": "2013-12-19T08:48:19.830"}, "20631809": {"Id": "20631809", "PostTypeId": "2", "Body": "<p>You're attributing a using declaration with something that it doesn't do. What it does is (From draft n3337, 7.3.3/1):</p>\n<blockquote>\n<p id=\"so_20548370_20631809_0\">... using-declaration introduces a name into the declarative region in which the <em>using-declaration</em> appears.  </p>\n</blockquote>\n<p>Later from the same paragraph:</p>\n<blockquote>\n<p id=\"so_20548370_20631809_1\">If a <em>using-declaration</em> names a constructor (3.4.3.1), it implicitly declares a set of constructors in the\n  class in which the <em>using-declaration</em> appears (12.9); <strong>otherwise the name speci\ufb01ed in a using-declaration is a\n  synonym for the name of some entity declared elsewhere.</strong></p>\n</blockquote>\n<p>In your case, <code>FunctionImpl::Function</code> is first declared in <code>FunctionImpl</code> class and it is its member. A using-declaration doesn't change that fact, as paragraph 16 says further down: </p>\n<blockquote>\n<p id=\"so_20548370_20631809_2\">For the purpose of overload resolution, the functions which are introduced by a <em>using-declaration</em> into a derived class will be treated as though they were members of the derived class. In particular, the implicit <code>this</code> parameter shall be treated as if it were a pointer to the derived class rather than to the base class. <strong>This has no effect on the type of the function, and in all other respects the function remains a member of\n  the base class.</strong></p>\n</blockquote>\n<p>Now on to the definition of overriding (10.3/2):</p>\n<blockquote>\n<p id=\"so_20548370_20631809_3\">If a virtual member function <code>vf</code> is declared in a class <code>Base</code> and in a class <code>Derived</code>, derived directly or indirectly from <code>Base</code>, a member function <code>vf</code> with the same name, parameter-type-list (8.3.5), cv-quali\ufb01cation, and ref-quali\ufb01er (or absence of same) as <code>Base::vf</code> is declared, then <code>Derived::vf</code> is also virtual (whether or not it is so declared) and it <em>overrides</em> <code>Base::vf</code>. For convenience we say that any virtual function overrides itself.</p>\n</blockquote>\n<p>And there's also the definition of a final overrider in the same paragraph.</p>\n<blockquote>\n<p id=\"so_20548370_20631809_4\">A virtual member function <code>C::vf</code> of a class object <code>S</code> is a <em>\ufb01nal overrider</em> unless the most derived class (1.8) of which <code>S</code> is a base class subobject (if any) declares or inherits another member function that overrides <code>vf</code>. In a derived class, if a virtual member function of a base class subobject has more than one \ufb01nal overrider the program is ill-formed. [...]</p>\n</blockquote>\n<p>I think that makes it clear that you can't use a using declaration to override a virtual function. A possible fix is in <a href=\"https://stackoverflow.com/a/20549400/947836\">Matthieu's answer</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-12-17T10:35:04.270", "Score": "2", "CreationDate": "2013-12-17T10:35:04.270", "ParentId": "20548370", "CommentCount": "0", "OwnerUserId": "947836", "LastEditDate": "2017-05-23T12:19:08.603"}, "20549400": {"Id": "20549400", "PostTypeId": "2", "Body": "<p>You cannot use a <code>using</code> directive and have to resort to a fowarding call instead:</p>\n<pre><code>struct NonPureVirtual : public FunctionImpl, public PureVirtual {\n    virtual void Function() override {\n        return FunctionImpl::Function();\n    }\n};\n</code></pre>\n<p>And yes, <a href=\"http://ideone.com/rjqTLC\" rel=\"noreferrer\">it works as expected</a>.</p>\n", "LastActivityDate": "2013-12-12T16:53:14.580", "CommentCount": "4", "CreationDate": "2013-12-12T16:53:14.580", "ParentId": "20548370", "Score": "5", "OwnerUserId": "147192"}});