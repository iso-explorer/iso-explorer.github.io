post_cb({"3224209": {"ParentId": "3224155", "CommentCount": "4", "Body": "<p>Just to climb on my hobby-horse for a moment, Universities have no business in teaching people how to program in specific computer languages. The fact that they do is simply an indicator of how degraded they have become over the past 30 years. I worked for the University of London from 1979 to 1983 as a microbiology technician and programmer, and the microbiology students (note not CS students!) were expected to pick up how to use the computers and to program more or less on their own, which they did, as much as they needed to.</p>\n<p>But nowadays even CS students seem to be spoonfed everything, and tested on that \"knowledge\" by almost impossible to fail tests like the one quoted by the OP.</p>\n<p>Gah!!!</p>\n", "Id": "3224209", "PostTypeId": "2", "OwnerDisplayName": "anon", "Score": "4", "CreationDate": "2010-07-11T18:34:05.583", "LastActivityDate": "2010-07-11T18:34:05.583"}, "3504786": {"ParentId": "3224155", "CommentCount": "0", "Body": "<p>Answering to whether the teacher is wrong:\nSimple logic.  Strictly speaking, it is what the name (and the standard) say: It is a <strong>reference</strong> to (=\"a name of\") the object, <strong>NOT</strong> the object itself.  As said before, when the reference variable runs out of scope, the object's destructor is not called, therefore the reference is <strong>not</strong> the object.</p>\n<pre><code>#include &lt;iostream&gt;\nclass A {\npublic:\n    ~A()\n    {\n            std::cout &lt;&lt; \"~A() called.\\n\";\n    }\n};\nvoid f(A &amp;a)\n{\n    // a running out of scope...\n}\nint main()\n{\n    A a;\n    std::cout &lt;&lt; \"calling f()\\n\";\n    f(a);\n    std::cout &lt;&lt; \"done calling f()\\n\";\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "423031", "PostTypeId": "2", "Id": "3504786", "Score": "1", "CreationDate": "2010-08-17T16:34:36.747", "LastActivityDate": "2010-08-17T16:34:36.747"}, "3224155": {"CommentCount": "15", "ViewCount": "7266", "PostTypeId": "1", "LastEditorUserId": "1560599", "CreationDate": "2010-07-11T18:18:27.050", "LastActivityDate": "2015-02-23T06:30:35.693", "Title": "C++ difference between reference, objects and pointers", "FavoriteCount": "2", "LastEditDate": "2015-02-23T06:30:35.693", "Id": "3224155", "Score": "14", "Body": "<p>This is a question from an exam in an advanced course in OOP, taught in C++ (in TAU university, this semester):</p>\n<p>Q:  What is the difference between a C++ pointer and a reference?  </p>\n<pre>\nA.  A reference is the entire object while a pointer is only the address of it.\nB.  The same meaning, and difference is only in syntax and usage.\nC.  The syntax used to access the object.\nD.  Pointers are simple address to the object while a reference uses the virtual table.\n</pre>\n<p>Which is the correct answer?</p>\n<p>The course teacher claims that A is the correct one, and that a reference to an object is, in fact, the object itself. Is that correct? I realize that accessing the reference is equivalent to accessing the object itself, however, when destructing a reference, we do not destruct the object itself. A reference is an alternative name for the object, but saying that reference==object true?</p>\n<p>BTW, the lecturer gave <a href=\"https://isocpp.org/wiki/faq/references\" rel=\"nofollow noreferrer\">the following link to an faq as support for his claim</a>, a quote:</p>\n<blockquote>\n<p id=\"so_3224155_3224155_0\">\"Important note: Even though a\n  reference is often implemented using\n  an address in the underlying assembly\n  language, please do not think of a\n  reference as a funny looking pointer\n  to an object. <strong><em>A reference is the\n  object</em></strong>. It is not a pointer to the\n  object, nor a copy of the object. It\n  is the object.\"</p>\n</blockquote>\n<p>But still, I believe this is incorrect.</p>\n", "Tags": "<c++><oop><pointers><reference>", "OwnerUserId": "271362", "AnswerCount": "11"}, "3224287": {"ParentId": "3224155", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>I believe your teacher is confusing a metaphor and a concrete statement. A reference definitely is <em>not</em> the actual object, and it <em>is</em> implemented as a \"funny looking pointer\" but the point of that statement is that you are to think of a reference as the actual object being referenced, you are not to think or program as if you are handling a pointer. Syntactically, accessing a reference to an object is identical to accessing the object itself, except in a few cases mentioned in the comments below.</p>\n", "OwnerUserId": "328501", "LastEditorUserId": "328501", "LastEditDate": "2010-07-17T20:10:26.827", "Id": "3224287", "Score": "0", "CreationDate": "2010-07-11T19:08:15.043", "LastActivityDate": "2010-07-17T20:10:26.827"}, "3595154": {"ParentId": "3224155", "CommentCount": "0", "Body": "<p>One of the big differences between pointers and references that I haven't seen mentioned is that a pointer can be NULL while a reference can't.  That doesn't mean the object a reference pointers to can't go out of scope resulting in the same types of issues people have with pointers, merely that there is no \"no assigned\" state.</p>\n", "OwnerUserId": "178060", "PostTypeId": "2", "Id": "3595154", "Score": "1", "CreationDate": "2010-08-29T14:40:30.260", "LastActivityDate": "2010-08-29T14:40:30.260"}, "bq_ids": {"n4140": {"so_3224155_3230386_0": {"section_id": 5938, "quality": 0.8947368421052632, "length": 17}}, "n3337": {"so_3224155_3230386_0": {"section_id": 5710, "quality": 0.8947368421052632, "length": 17}}, "n4659": {"so_3224155_3230386_0": {"section_id": 7422, "quality": 0.8947368421052632, "length": 17}}}, "7880675": {"ParentId": "3224155", "CommentCount": "0", "Body": "<p>Let's evaluate one option at a time - </p>\n<p><em>A.  A reference is the entire object while a pointer is only the address of it.</em></p>\n<p>There is no such a thing as \"entire object\"! it is just the object. Many references can point object and then cease to refer to it even though object itself continues to persist. \nWrong Answer!</p>\n<p><em>B.  The same meaning, and difference is only in syntax and usage.</em> \nIt is <strong>NOT</strong> the same thing. For example, when you get &amp;ref - you cannot do ref++ where as if you get *ptr, you can do ptr++. \nPointer not only allow you to access objects but allows pointer arithmetic; thereby with pointers, you can pass not only 1 address (and modify that address) but the entire array of arbitrary location with the same syntax. You cannot do this with reference! \nWrong Ans!</p>\n<p><em>C.  The syntax used to access the object.</em>\nDidn't quite get how it constitutes difference between two concept. \nWrong Ans!</p>\n<p><em>D.  Pointers are simple address to the object while a reference uses the virtual table.</em>\nI don't thing there is anything called virtual table. Pointers are usually pointing in heap, where as reference is a pointer sitting inside the stack.\nWrong Ans!</p>\n<p>All are wrong...</p>\n<p>Dipan.</p>\n", "OwnerUserId": "990673", "PostTypeId": "2", "Id": "7880675", "Score": "0", "CreationDate": "2011-10-24T19:14:48.413", "LastActivityDate": "2011-10-24T19:14:48.413"}, "3224182": {"ParentId": "3224155", "PostTypeId": "2", "CommentCount": "21", "Body": "<p>(B) is the closest, but still not exactly correct.  A reference is syntactic sugar for a const pointer.  Just like a const pointer, it must be bound to an lvalue at initialization, and can never be rebound.  Just like a const pointer, it is polymorphic.</p>\n<p>EDIT: Short proof that (A) is incorrect, since at least a couple people are defending it:</p>\n<pre><code>struct A { int x; int f() { return 1; } }\nstruct B : public A { int y; int f() { return 2; } }\n\nB b;\nA&amp; a = b;\n\nassert(sizeof(a) == sizeof(b)); // fail\nassert(a.f() == b.f()); // fail again\n</code></pre>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2010-07-11T19:15:08.497", "Id": "3224182", "Score": "5", "CreationDate": "2010-07-11T18:27:19.103", "LastActivityDate": "2010-07-11T19:15:08.497"}, "3224169": {"ParentId": "3224155", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>They're all wrong.</p>\n<p>A <strong>reference</strong> is essentially a synonym for another object. Internally, it is often implemented as a pointer, but it has the syntax as if it were the object it refers to.</p>\n<p>A <strong>pointer</strong> is a separate object that stores the memory address of the object it points to (or 0 if it doesn't point to an object).</p>\n<p>You <em>could</em> say that the reference is the object that it refers to (it certainly acts that way), but it is not. If a reference goes out of scope then the object it refers to is not destructed, so the reference is not the object.</p>\n", "OwnerUserId": "235825", "LastEditorUserId": "235825", "LastEditDate": "2010-08-29T14:36:59.123", "Id": "3224169", "Score": "36", "CreationDate": "2010-07-11T18:22:07.117", "LastActivityDate": "2010-08-29T14:36:59.123"}, "3224164": {"ParentId": "3224155", "CommentCount": "1", "Body": "<p>There's a distinction between a reference and an object - you can have multiple references to the same object.  An object has 'identity', while a reference itself doesn't really.</p>\n<p>While the mechanics of a reference are quite different than those of a pointer, I'd say that conceptually, a reference is actually quite similar to a pointer.</p>\n", "OwnerUserId": "12711", "PostTypeId": "2", "Id": "3224164", "Score": "7", "CreationDate": "2010-07-11T18:20:27.483", "LastActivityDate": "2010-07-11T18:20:27.483"}, "3224284": {"ParentId": "3224155", "CommentCount": "6", "Body": "<p>The question isn't about objects and references, it's about pointers and references. The point is that pointers denote a memory location and references denote an object- a higher level semantic construct. Simple as that. </p>\n<p>And the teacher already gave you the answer anyhow: A -&gt; correct answer.</p>\n<p>Good luck in your studies.</p>\n", "OwnerUserId": "389001", "PostTypeId": "2", "Id": "3224284", "Score": "-1", "CreationDate": "2010-07-11T19:06:15.690", "LastActivityDate": "2010-07-11T19:06:15.690"}, "3230386": {"ParentId": "3224155", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>An important thing is to differentiate between:</p>\n<ul>\n<li>Reference as an expression</li>\n<li>Reference itself</li>\n</ul>\n<p>The FAQ and the teacher seem to talk about the first point, but the teacher's question is formulated as if it were asking about the second point. To explain the point of view of the FAQ, consider what the Standard describes as the very first stage of expression processing</p>\n<blockquote>\n<p id=\"so_3224155_3230386_0\">If an expression initially has the type \"reference to T\" (8.3.2, 8.5.3), the type is adjusted to \"T\" prior to any further analysis, the expression designates the object or function denoted by the reference, and the expression is an lvalue</p>\n</blockquote>\n<p><em>After</em> this transformation, a reference and the object or function it designates cannot be distinguished anymore using that expression. But that doesn't make a reference equivalent to an object. The former just <em>refers</em> to the latter. Even less so since references can also refer to functions. </p>\n<p>Now, a reference itself is just that - an entity that happens to refer to an object or function but that doesn't store something on its own. </p>\n<p>The same mistake in arguing is sometimes made by people when they say that arrays in C would be just pointers. What they really mean is that arrays <em>in expressions</em> are (mostly) just pointers. But that doesn't make both of them equal in their own right. </p>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2010-07-12T17:12:21.507", "Id": "3230386", "Score": "3", "CreationDate": "2010-07-12T16:47:21.397", "LastActivityDate": "2010-07-12T17:12:21.507"}, "3224186": {"ParentId": "3224155", "CommentCount": "0", "Body": "<p>All answers are incorrect, A is closest. </p>\n<p>Pointer is address of object which is object itself.<br>\n\"Object\" is \"something\" somewhere in a memory. Class instance, int, float, etc.<br>\nReference is an <em>alternative way of accessing an object</em>. It is reference to an object, but not the object itself. It may or may not be implemented as pointer. You may think about it as an alternative object name, but this isn't exactly right. The closest correct descriptions I can think of is \"alternative interface for accessing/manipulating object\"(unfortunately \"interface\" sounds misleading if you take OOP in account, although it is (IMO) most correct one).</br></br></p>\n", "OwnerUserId": "271376", "PostTypeId": "2", "Id": "3224186", "Score": "1", "CreationDate": "2010-07-11T18:28:14.483", "LastActivityDate": "2010-07-11T18:28:14.483"}});