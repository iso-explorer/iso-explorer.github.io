post_cb({"30785910": {"ParentId": "30785257", "CommentCount": "0", "Body": "<p>The use of <code>virtual</code> is redundant in <code>D1</code>.</p>\n<p>From C++11, \u00a710.3\u00b62:</p>\n<blockquote>\n<p id=\"so_30785257_30785910_0\">If a virtual member function <code>vf</code> is declared in a class <code>Base</code> and in a class <code>Derived</code>, derived directly or indirectly from <code>Base</code>, a member function <code>vf</code> with the same name, parameter-type-list (8.3.5), cv-qualification, and ref-qualifier (or absence of same) as <code>Base::vf</code> is declared, <strong>then <code>Derived::vf</code> is also virtual (whether or not it is so declared)</strong> and it overrides<sup>111</sup> <code>Base::vf</code>.</p>\n<hr>\n<p id=\"so_30785257_30785910_1\"><sub>111) A function with the same name but a different parameter list (Clause 13) as a virtual function is not necessarily virtual and does not override. The use of the <code>virtual</code> specifier in the declaration of an overriding function is legal but redundant (has empty semantics). Access control (Clause 11) is not considered in determining overriding.</sub></p>\n</hr></blockquote>\n<p>Thus, the memory layout (which is what the question seems to be about) is the same for <code>D</code> and <code>D1</code>. Obviously, different types will have different virtual tables.</p>\n", "OwnerUserId": "315052", "PostTypeId": "2", "Id": "30785910", "Score": "3", "CreationDate": "2015-06-11T16:04:44.140", "LastActivityDate": "2015-06-11T16:04:44.140"}, "30785380": {"ParentId": "30785257", "PostTypeId": "2", "CommentCount": "7", "Body": "<p><code>f1()</code> and <code>f2()</code> are <em>virtual</em> in <code>D</code> too. If a function is declared <em>virtual</em>, it remains <em>virtual</em> in any class that inherits.</p>\n<p>So, classes <code>D</code> and <code>D1</code> almost do not differ inside (but, obviously, are different types), but both of them give implementations of <code>f1</code> and <code>f2</code>, and their <em>virtual tables</em> will differ, as virtual table for <code>D</code> will point to <code>D</code>'s implementations, and the same for <code>D1</code>.</p>\n<pre><code>vtable for D:\n    f1: D::f1\n    f2: D::f2\n\nvtavle for D1:\n    f1: D1::f1\n    f2: D1::f2\n</code></pre>\n", "OwnerUserId": "2315602", "LastEditorUserId": "2315602", "LastEditDate": "2015-06-11T15:59:00.663", "Id": "30785380", "Score": "1", "CreationDate": "2015-06-11T15:40:17.800", "LastActivityDate": "2015-06-11T15:59:00.663"}, "bq_ids": {"n4140": {"so_30785257_30785910_1": {"section_id": 7003, "quality": 0.9375, "length": 30}, "so_30785257_30785910_0": {"section_id": 7003, "quality": 0.9375, "length": 30}}, "n3337": {"so_30785257_30785910_1": {"section_id": 6749, "quality": 0.9375, "length": 30}, "so_30785257_30785910_0": {"section_id": 6749, "quality": 0.9375, "length": 30}}, "n4659": {"so_30785257_30785910_0": {"section_id": 8500, "quality": 0.9375, "length": 30}, "so_30785257_30785910_1": {"section_id": 8500, "quality": 0.9375, "length": 30}}}, "30785257": {"CommentCount": "5", "AcceptedAnswerId": "30785910", "PostTypeId": "1", "LastEditorUserId": "315052", "CreationDate": "2015-06-11T15:35:33.077", "LastActivityDate": "2015-06-11T20:40:08.217", "LastEditDate": "2015-06-11T20:40:08.217", "ViewCount": "127", "FavoriteCount": "1", "Title": "memory layout of a multiple-inherited object in C++", "Id": "30785257", "Score": "2", "Body": "<pre><code>class B1 {\n    virtual void f1();\n    int int_in_b1;\n};\nclass B2 {\n    virtual void f2();\n    int int_in_b2;\n};\nclass D: B1, B2 {\n    int int_in_d;\n    void f1();\n    void f2();\n};\nclass D1: B1, B2 {\n    int int_in_d;\n    virtual void f1();\n    virtual void f2();\n};\n</code></pre>\n<p>Based on this <a href=\"http://en.wikipedia.org/wiki/Virtual_method_table\" rel=\"nofollow\">article</a>, the memory layout for an object <code>d</code> of class <code>D</code> is like this:</p>\n<pre><code>d:\n  +0: pointer to virtual method table of D (for B1)\n  +4: value of int_in_b1\n  +8: pointer to virtual method table of D (for B2)\n +12: value of int_in_b2\n +16: value of int_in_d\n\nvirtual method table of D (for B1):\n  +0: D::f1()  // B1::f1() is overridden by D::f1()\n\nvirtual method table of D (for B2):\n  +0: D::f2()   // B2::f2() is overridden by D::f2()\n</code></pre>\n<p>What about an object of class <code>D1</code>? In class <code>D1</code>, the members <code>f1</code> and <code>f2</code> are both declared as <code>virtual</code>!</p>\n", "Tags": "<c++><compiler-construction><multiple-inheritance>", "OwnerUserId": "389898", "AnswerCount": "2"}});