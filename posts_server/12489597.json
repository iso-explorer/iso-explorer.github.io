post_cb({"bq_ids": {"n4140": {"so_12489597_12489697_0": {"length": 12, "quality": 0.75, "section_id": 5908}}, "n3337": {"so_12489597_12489697_0": {"length": 12, "quality": 0.75, "section_id": 5680}}, "n4659": {"so_12489597_12489697_0": {"length": 12, "quality": 0.75, "section_id": 7390}}}, "12489597": {"ViewCount": "139", "Body": "<p>in Foo.h:</p>\n<pre><code>class Foo\n{\npublic:\n    Foo();\n    static const unsigned int FOOBAR = 10;\n    static const unsigned int BARFOO = 20;\n\nprivate:\n    unsigned int m_FooBar;\n    bool m_Bar;\n    void Bar();\n};\n</code></pre>\n<p>in Foo.cpp:</p>\n<pre><code>Foo::Foo()\n    : m_FooBar(FOOBAR), // this works\n      m_Bar(false)\n{\n}\n\nvoid Foo::Bar()\n{\n    //m_FooBar = m_Bar ? FOOBAR : BARFOO; // linker fails *1\n    m_FooBar = FOOBAR; // ok\n}\n</code></pre>\n<p>I'm compiling with GCC 4.5.3. Is there any reason why the linker would fail when line *1 is uncommented?</p>\n<pre><code>Foo.o: In function 'Foo::Bar' (name unmangled):\nFoo.cpp: undefined reference to `Foo::FOOBAR'\nFoo.cpp: undefined reference to `Foo::BARFOO'\n</code></pre>\n<p>Tried with VC2005, 2008, 2010 and CB2010. They all compiled and linked fine. Why does GCC fail in this case?</p>\n<p>Given the <a href=\"https://stackoverflow.com/questions/5446005/why-dont-static-member-variables-play-well-with-the-ternary-operator\">answer here</a>, why doesn't the other popular compilers fail like GCC? One way or another, it has to be a bug, either for GCC or the other popular compilers. Or is there a more reasonable explanation?</p>\n", "AcceptedAnswerId": "12489697", "Title": "Static constant class member declaration", "CreationDate": "2012-09-19T06:34:34.027", "Id": "12489597", "CommentCount": "10", "LastEditDate": "2017-05-23T11:49:08.650", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2012-09-19T07:06:25.720", "Score": "7", "OwnerUserId": "383306", "Tags": "<c++><gcc><linker>", "AnswerCount": "2"}, "12489697": {"Id": "12489697", "PostTypeId": "2", "Body": "<p>Formally, the header only declares the static constants, and they also have to be defined (at least in C++03). However, if you only use their values, you most often get away with this.</p>\n<p>In C++11 this is more formally specified as requiring a definition when the static is \"odr-used\". The <code>*1</code> line is an example of this. The triadic operator tries to form a reference to the values, and the compiler (or linker actually) realizes that it cannot.</p>\n<hr>\n<p>The C++11 standard says</p>\n<blockquote>\n<p id=\"so_12489597_12489697_0\"><strong>9.4.2 Static data members</strong><br>\n  \u00a73...<br>\n  The member shall still be defined\n  in a namespace scope if it is odr-used (3.2) in the program and the namespace scope definition shall not\n  contain an <em>initializer</em>.</br></br></p>\n</blockquote>\n</hr>", "LastEditorUserId": "597607", "LastActivityDate": "2012-09-19T06:57:14.763", "Score": "4", "CreationDate": "2012-09-19T06:43:59.507", "ParentId": "12489597", "CommentCount": "6", "OwnerUserId": "597607", "LastEditDate": "2012-09-19T06:57:14.763"}, "12489689": {"Id": "12489689", "PostTypeId": "2", "Body": "<p>Try defining these members:</p>\n<pre><code>static const unsigned int FOOBAR = 10;\nstatic const unsigned int BARFOO = 20;\n</code></pre>\n<p>Outside the class declaration.</p>\n<pre><code>Foo::FOOBAR = 10;\nFoo::BARFOO = 20;\n</code></pre>\n", "LastActivityDate": "2012-09-19T06:43:39.833", "CommentCount": "0", "CreationDate": "2012-09-19T06:43:39.833", "ParentId": "12489597", "Score": "0", "OwnerUserId": "1110833"}});