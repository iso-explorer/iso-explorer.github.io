post_cb({"bq_ids": {"n4140": {"so_21961474_21961474_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 5964}}, "n3337": {"so_21961474_21961474_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 5733}}, "n4659": {"so_21961474_21961474_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 7454}}}, "21970587": {"Id": "21970587", "PostTypeId": "2", "Body": "<p>As pointed out in the comments, a mutable lambda requires a non-const function call operator in order to let const references to function objects represent pure functions.</p>\n<p>It turns out that the culprit for my application is Boost.Iterator underyling the Boost.Range implementation of <code>boost::adaptors::transformed</code>. After some digging in the Boost.Iterator documentation's <a href=\"http://www.boost.org/doc/libs/1_55_0/libs/iterator/doc/transform_iterator.html#transform-iterator-requirements\" rel=\"nofollow noreferrer\">requirements for <code>transform_iterator</code></a>, it turns out that (bold emphasis mine)</p>\n<blockquote>\n<p id=\"so_21961474_21970587_0\">The type <code>UnaryFunction</code> must be Assignable, Copy Constructible, and the\n  expression <code>f(*i)</code> must be valid where <strong><code>f</code> is a const object</strong> of type\n  <code>UnaryFunction</code>, <code>i</code> is an object of type Iterator, and where the type of\n  <code>f(*i)</code> must be <code>result_of&lt;const\n  UnaryFunction(iterator_traits&lt;Iterator&gt;::reference)&gt;::type</code>.</p>\n</blockquote>\n<p>Stateful non-pure function objects can therefore not be written using lambdas but instead have to written using a <code>const</code> function call <code>operator()</code> and with <code>mutable</code> data members representing the state. This was also remarked in <a href=\"https://stackoverflow.com/questions/12820104/use-boosttransform-iterator-with-a-non-const-functor\">this related Q&amp;A</a>.</p>\n<p><strong>Note</strong>: there is an <a href=\"https://svn.boost.org/trac/boost/ticket/4969\" rel=\"nofollow noreferrer\">open bug report</a> for this.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-02-23T16:14:50.827", "Score": "1", "CreationDate": "2014-02-23T15:57:14.447", "ParentId": "21961474", "CommentCount": "0", "OwnerUserId": "819272", "LastEditDate": "2017-05-23T12:03:41.270"}, "22052614": {"Id": "22052614", "PostTypeId": "2", "Body": "<pre><code>template&lt;class L&gt;\nstruct force_const_call_t {\n  mutable L f;\n  template&lt;class...Args&gt;\n  auto operator()(Args&amp;&amp;...args) const\n  { return f(std::forward&lt;Args&gt;(args)...); }\n};\ntemplate&lt;class L&gt;\nforce_const_call_t&lt;L&gt; force_const_call(L&amp;&amp;f){\n  return {std::forward&lt;L&gt;(f)};\n}\n</code></pre>\n<p>the above should let you take a lambda, wrap it in <code>force_const_call(</code> ... <code>)</code>, and call your <code>boost</code> algorithm, without a custom <code>mutable</code> callable object (or more precisely, the above turns lambdas into custom <code>mutable</code> callables).</p>\n", "LastEditorUserId": "819272", "LastActivityDate": "2014-02-26T21:33:07.663", "Score": "2", "CreationDate": "2014-02-26T20:33:05.473", "ParentId": "21961474", "CommentCount": "3", "OwnerUserId": "1774667", "LastEditDate": "2014-02-26T21:33:07.663"}, "21961474": {"ViewCount": "370", "Body": "<p>This question is related to <a href=\"https://stackoverflow.com/q/21724760/819272\">this previous one</a> where it was noticed that init-capturing <code>mutable</code> lambdas are incompatible with Boost's range and iterator <code>transform</code> for some rather obscure and deeply nested <code>typedef</code> failures that may or may not be easy to resolve through hacking the Boost.Range sources. </p>\n<p>The accepted answer suggested storing the lambda in a <code>std::function</code> object. To avoid potential <code>virtual</code> function call overhead, I wrote two function objects that could serve as potential work-arounds. They are called <code>MutableLambda1</code> and <code>MutableLambda2</code> in the code below</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n#include &lt;vector&gt;\n#include &lt;boost/range/adaptors.hpp&gt;\n#include &lt;boost/range/algorithm.hpp&gt;\n\n// this version is conforming to the Standard\n// but is not compatible with boost::transformed\nstruct MutableLambda1\n{\n    int delta;     \n    template&lt;class T&gt; auto operator()(T elem) { return elem * delta++; }\n};\n\n// Instead, this version works with boost::transformed\n// but is not conforming to the Standard\nstruct MutableLambda2\n{\n    mutable int delta;\n    template&lt;class T&gt; auto operator()(T elem) const { return elem * delta++; }\n};\n\n// simple example of an algorithm that takes a range and laziy transformes that\n// using a function object that stores and modifies internal state\ntemplate&lt;class R, class F&gt;\nauto scale(R r, F f) \n{\n    return r | boost::adaptors::transformed(f);\n}\n\nint main()\n{\n    // real capturing mutable lambda, will not work with boost::transformed\n    auto lam = [delta = 1](auto elem) mutable { return elem * delta++; };        \n    auto rng = std::vector&lt;int&gt;{ 1, 2, 3, 4 };\n\n    //boost::copy(scale(rng, lam), std::ostream_iterator&lt;int&gt;(std::cout, \",\"));                 /* ERROR */\n    //boost::copy(scale(rng, MutableLambda1{1}), std::ostream_iterator&lt;int&gt;(std::cout, \",\"));   /* ERROR */\n    boost::copy(scale(rng, MutableLambda2{1}), std::ostream_iterator&lt;int&gt;(std::cout, \",\"));     /* OK!   */\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/a56fcb849a9b1e90\" rel=\"nofollow noreferrer\"><strong>Live Example</strong></a> that won't compile the lines with <code>lam</code> and <code>MutableLambda1</code>, and correctly prints <code>1, 4, 9, 16</code> for the line with <code>MutableLambda2</code>.</p>\n<p>However, the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\"><strong>draft Standard</strong></a> mentions</p>\n<p><strong>5.1.2 Lambda expressions [expr.prim.lambda]</strong></p>\n<blockquote>\n<p id=\"so_21961474_21961474_0\">5 [...] This function call operator or operator template is declared const\n  (9.3.1) if and only if the lambda-expression\u2019s\n  parameter-declaration-clause is not followed by <code>mutable</code>. [...]</p>\n<p id=\"so_21961474_21961474_1\">11 For every init-capture a non-static data member named by the\n  identi\ufb01er of the init-capture is declared in the closure type. This\n  member is not a bit-\ufb01eld and not <code>mutable</code>. [...]</p>\n</blockquote>\n<p>This means that <code>MutableLambda2</code> is not a conforming handwritten replacement for an init-capturing <code>mutable</code> lambda expression.</p>\n<h2>Questions</h2>\n<ul>\n<li>why is the implementation of init-capturing <code>mutable</code> lambdas the way it is (i.e. non-const function call operator)?</li>\n<li>why is the seemingly equivalent alternative of <code>mutable</code> data members with a <code>const</code> function call operator forbidden? </li>\n<li>(<strong>bonus</strong>) why does the Boost range and iterator <code>transform</code> rely on the fact that a function objects <code>operator()</code> is <code>const</code>?</li>\n</ul>\n", "AcceptedAnswerId": "22052614", "Title": "Why can't init-capturing mutable lambdas have mutable data members?", "CreationDate": "2014-02-22T22:28:44.660", "Id": "21961474", "CommentCount": "6", "LastEditDate": "2017-05-23T10:31:57.577", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2014-02-26T21:33:07.663", "Score": "3", "OwnerUserId": "819272", "Tags": "<c++><lambda><language-lawyer><mutable><c++14>", "AnswerCount": "2"}});