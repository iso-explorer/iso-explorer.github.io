post_cb({"47096750": {"CreationDate": "2017-11-03T13:20:37.837", "CommentCount": "5", "Body": "<p>Is it legal?  No.  As others mentioned, it invokes <em>Undefined Behavior</em>.</p>\n<p>Will it work?  That depends on your compiler.  That's the thing about undefined behavior: it's <em>undefined</em>.  </p>\n<p>On many C and C++ compilers, the struct will be laid out such that b will immediately follow a in memory and there will be no bounds checking.  So accessing a[6] will effectively be the same as b[2] and will not cause any sort of exception.  </p>\n<p>Given</p>\n<pre><code>struct S {\n  int a[4];\n  int b[4];\n} s\n</code></pre>\n<p>and <em>assuming no extra padding</em>, the structure is really just a way of looking at a block of memory containing 8 integers.  You could cast it to <code>(int*)</code> and    <code>((int*)s)[6]</code> would point to the same memory as <code>s.b[2]</code>.  </p>\n<p>Should you rely on this sort of behavior?  Absolutely not.  <em>Undefined</em> means that the compiler doesn't have to support this.  The compiler is free to pad the structure which could render the assumption that &amp;(s.b[2]) == &amp;(s.a[6]) incorrect. The compiler could also add bounds checking on the array access (although enabling compiler optimizations would probably disable such a check).</p>\n<p>I've have experienced the effects of this in the past.  It's quite common to have a struct like this</p>\n<pre><code>struct Bob {\n    char name[16];\n    char whatever[64];\n} bob;\nstrcpy(bob.name, \"some name longer than 16 characters\");\n</code></pre>\n<p>Now bob.whatever will be \" than 16 characters\".  (which is why you should always use strncpy, BTW)</p>\n", "Id": "47096750", "OwnerUserId": "1195482", "LastEditDate": "2017-11-03T14:15:28.803", "ParentId": "47094166", "LastActivityDate": "2017-11-03T14:15:28.803", "PostTypeId": "2", "Score": "6", "LastEditorUserId": "1195482"}, "47094166": {"FavoriteCount": "10", "ViewCount": "4284", "Id": "47094166", "AcceptedAnswerId": "47094204", "Score": "50", "Title": "In a structure, is it legal to use one array field to access another one?", "LastEditorUserId": "1780687", "CommentCount": "15", "Body": "<p>As an example, consider the following structure:</p>\n<pre><code>struct S {\n  int a[4];\n  int b[4];\n} s;\n</code></pre>\n<p>Would it be legal to write <code>s.a[6]</code> and expect it to be equal to <code>s.b[2]</code>?\nPersonally, I feel that it must be UB in C++, whereas I'm not sure about C.\nHowever, I failed to find anything relevant in the standards of C and C++ languages.</p>\n<hr>\n<p><strong>Update</strong></p>\n<p>There are several answers suggesting ways to make sure there is no padding\nbetween fields in order to make the code work reliably. I'd like to emphasize\nthat if such code is UB, then absense of padding is not enough. If it is UB,\nthen the compiler is free to assume that accesses to <code>S.a[i]</code> and <code>S.b[j]</code> do not\noverlap and the compiler is free to reorder such memory accesses. For example,</p>\n<pre><code>    int x = s.b[2];\n    s.a[6] = 2;\n    return x;\n</code></pre>\n<p>can be transformed to</p>\n<pre><code>    s.a[6] = 2;\n    int x = s.b[2];\n    return x;\n</code></pre>\n<p>which always returns <code>2</code>.</p>\n</hr>", "Tags": "<c++><c><arrays><struct>", "CreationDate": "2017-11-03T10:59:12.080", "LastEditDate": "2017-11-04T09:55:01.313", "LastActivityDate": "2017-11-28T07:10:33.010", "PostTypeId": "1", "AnswerCount": "9", "OwnerUserId": "1780687"}, "47112827": {"CommentCount": "0", "Body": "<p>The Standard does not impose any restrictions upon what implementations must do when a program tries to use an out-of-bounds array subscript in one structure field to access a member of another.  Out-of-bounds accesses are thus \"illegal\" <em>in strictly conforming programs</em>, and programs which make use of such accesses cannot simultaneously be 100% portable and free of errors.  On the other hand, many implementations do define the behavior of such code, and programs which are targeted solely at such implementations may exploit such behavior.</p>\n<p>There are three issues with such code:</p>\n<ol>\n<li><p>While many implementations lay out structures in predictable fashion, the Standard allows implementations to add arbitrary padding before any structure member other than the first.  Code could use <code>sizeof</code> or <code>offsetof</code> to ensure that structure members are placed as expected, but the other two issues would remain.</p></li>\n<li><p>Given something like:</p>\n<pre><code>if (structPtr-&gt;array1[x])\n structPtr-&gt;array2[y]++;\nreturn structPtr-&gt;array1[x];\n</code></pre>\n<p>it would normally be useful for a compiler to assume that the use of <code>structPtr-&gt;array1[x]</code> will yield the same value as the preceding use in the \"if\" condition, even though it would change the behavior of code that relies upon aliasing between the two arrays.</p></li>\n<li><p>If <code>array1[]</code> has e.g. 4 elements, a compiler given something like:</p>\n<pre><code>if (x &lt; 4) foo(x);\nstructPtr-&gt;array1[x]=1;\n</code></pre></li>\n</ol>\n<p>might conclude that since there would be no defined cases where <code>x</code> isn't less than 4, it could call <code>foo(x)</code> unconditionally.</p>\n<p>Unfortunately, while programs can use <code>sizeof</code> or <code>offsetof</code> to ensure that there aren't any surprises with struct layout, there's no way by which they  can test whether compilers promise to refrain from the optimizations of types #2 or #3.  Further, the Standard is a little vague about what would be meant in a case like:</p>\n<pre><code>struct foo {char array1[4],array2[4]; };\n\nint test(struct foo *p, int i, int x, int y, int z)\n{\n  if (p-&gt;array2[x])\n  {\n    ((char*)p)[x]++;\n    ((char*)(p-&gt;array1))[y]++;\n    p-&gt;array1[z]++;\n  }\n  return p-&gt;array2[x];\n}\n</code></pre>\n<p>The Standard is pretty clear that behavior would only be defined if z is in the range 0..3, but since the type of p-&gt;array in that expression is char* (due to decay) it's not clear the cast in the access using <code>y</code> would have any effect.  On the other hand, since converting pointer to the first element of a struct to <code>char*</code> should yield the same result as converting a struct pointer to <code>char*</code>, and the converted struct pointer should be usable to access all bytes therein, it would seem the access using <code>x</code> should be defined for (at minimum) x=0..7 [if the offset of <code>array2</code> is greater than 4, it would affect the value of <code>x</code> needed to hit members of <code>array2</code>, but some value of <code>x</code> could do so with defined behavior].</p>\n<p>IMHO, a good remedy would be to define the subscript operator on array types in a fashion that does not involve pointer decay.  In that case, the expressions <code>p-&gt;array[x]</code> and <code>&amp;(p-&gt;array1[x])</code> could invite a compiler to assume that <code>x</code> is 0..3, but <code>p-&gt;array+x</code> and <code>*(p-&gt;array+x)</code> would require a compiler to allow for the possibility of other values.  I don't know if any compilers do that, but the Standard doesn't require it.</p>\n", "CreationDate": "2017-11-04T16:23:19.297", "ParentId": "47094166", "Id": "47112827", "LastActivityDate": "2017-11-04T16:23:19.297", "PostTypeId": "2", "Score": "0", "OwnerUserId": "363751"}, "47094343": {"CreationDate": "2017-11-03T11:08:58.157", "CommentCount": "0", "Body": "<p><code>a</code> and <code>b</code> are two different arrays, and <code>a</code> is defined as containing <code>4</code> elements. Hence, <code>a[6]</code> accesses the array out of bounds and is therefore undefined behaviour. Note that array subscript <code>a[6]</code> is defined as <code>*(a+6)</code>, so the proof of UB is actually given by section \"Additive operators\" in conjunction with pointers\". See the following section of the C11-standard (e.g. <a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.5.6p8\" rel=\"noreferrer\">this</a> online draft version) describing this aspect:</p>\n<blockquote>\n<p id=\"so_47094166_47094343_0\"><strong>6.5.6 Additive operators</strong></p>\n<p id=\"so_47094166_47094343_1\">When an expression that has integer type is added to or subtracted\n  from a pointer, the result has the type of the pointer operand. If the\n  pointer operand points to an element of an array object, and the array\n  is large enough, the result points to an element offset from the\n  original element such that the difference of the subscripts of the\n  resulting and original array elements equals the integer expression.\n  In other words, if the expression P points to the i-th element of an\n  array object, the expressions (P)+N (equivalently, N+(P)) and (P)-N\n  (where N has the value n) point to, respectively, the i+n-th and\n  i-n-th elements of the array object, provided they exist. Moreover, if\n  the expression P points to the last element of an array object, the\n  expression (P)+1 points one past the last element of the array object,\n  and if the expression Q points one past the last element of an array\n  object, the expression (Q)-1 points to the last element of the array\n  object. <strong>If both the pointer operand and the result point to elements\n  of the same array object, or one past the last element of the array\n  object, the evaluation shall not produce an overflow; otherwise, the\n  behavior is undefined</strong>. If the result points one past the last element\n  of the array object, it shall not be used as the operand of a unary *\n  operator that is evaluated.</p>\n</blockquote>\n<p>The same argument applies to C++ (though not quoted here).</p>\n<p>Further, though it is clearly undefined behaviour due to the fact of exceeding array bounds of <code>a</code>, note that the compiler might introduce padding between members <code>a</code> and <code>b</code>, such that - even if such pointer arithmetics were allowed - <code>a+6</code> would not necessarily yield the same address as <code>b+2</code>.</p>\n", "Id": "47094343", "OwnerUserId": "2630032", "LastEditDate": "2017-11-03T11:18:31.063", "ParentId": "47094166", "LastActivityDate": "2017-11-03T11:18:31.063", "PostTypeId": "2", "Score": "10", "LastEditorUserId": "2630032"}, "47094204": {"CreationDate": "2017-11-03T11:01:11.717", "CommentCount": "8", "Body": "<blockquote>\n<p id=\"so_47094166_47094204_0\">Would it be legal to write s.a[6] and expect it to be equal to s.b[2]?</p>\n</blockquote>\n<p><strong>No</strong>. Because accessing an array out of bound invoked <strong>undefined behaviour</strong> in C and C++.</p>\n<p><strong>C11 J.2 Undefined behavior</strong></p>\n<blockquote>\n<ul>\n<li><p id=\"so_47094166_47094204_1\">Addition or subtraction of a pointer into, or just beyond, an array object and an integer type produces a result that points just beyond\n  the array object and is used as the operand of a unary <code>*</code> operator that\n  is evaluated (6.5.6).</p></li>\n<li><p id=\"so_47094166_47094204_2\">An array subscript is out of range, even if an object is apparently  accessible with the given subscript (as in the lvalue expression \n  <code>a[1][7]</code> given the declaration int <code>a[4][5])</code> (6.5.6).</p></li>\n</ul>\n</blockquote>\n<p><strong>C++ standard <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow noreferrer\">draft</a> section 5.7 Additive operators paragraph 5 says:</strong></p>\n<blockquote>\n<p id=\"so_47094166_47094204_3\">When an expression that has integral type is added to or subtracted\n  from a pointer, the result has the type of the pointer operand. If the\n  pointer operand points to an element of an array object, and the array\n  is large enough, the result points to an element offset from the\n  original element such that the difference of the subscripts of the\n  resulting and original array elements equals the integral expression.\n  [...] <strong>If both the pointer operand and the result point to elements\n  of the same array object, or one past the last element of the array\n  object, the evaluation shall not produce an overflow; otherwise, the\n  behavior is undefined.</strong></p>\n</blockquote>\n", "Id": "47094204", "OwnerUserId": "6935629", "LastEditDate": "2017-11-28T07:10:33.010", "ParentId": "47094166", "LastActivityDate": "2017-11-28T07:10:33.010", "PostTypeId": "2", "Score": "60", "LastEditorUserId": "6935629"}, "bq_ids": {"n4140": {"so_47094166_47094343_1": {"length": 106, "quality": 0.8833333333333333, "section_id": 6142}, "so_47094166_47094204_3": {"length": 57, "quality": 1.0, "section_id": 6142}}, "n3337": {"so_47094166_47094343_1": {"length": 106, "quality": 0.8833333333333333, "section_id": 5906}, "so_47094166_47094204_3": {"length": 57, "quality": 1.0, "section_id": 5906}}}, "47094379": {"CreationDate": "2017-11-03T11:10:53.720", "CommentCount": "7", "Body": "<p>Apart from the answer of <code>@rsp</code> (<code>Undefined behavior for an array subscript that is out of range</code>) I can add that it is not legal to access <code>b</code> via <code>a</code> because the C language does not specify how much padding space can be between the end of area allocated for a and the start of b, so even if you can run it on a particular implementation , it is not portable.</p>\n<pre><code>instance of struct:\n+-----------+----------------+-----------+---------------+\n|  array a  |  maybe padding |  array b  | maybe padding |\n+-----------+----------------+-----------+---------------+\n</code></pre>\n<p>The second padding may miss as well as the alignment of <code>struct object</code> is the alignment of <code>a</code> which is the same as the alignment of <code>b</code> but the C language also does not impose the second padding not to be there.</p>\n", "Id": "47094379", "OwnerUserId": "1419272", "LastEditDate": "2017-11-03T15:20:06.573", "ParentId": "47094166", "LastActivityDate": "2017-11-03T15:20:06.573", "PostTypeId": "2", "Score": "32", "LastEditorUserId": "1419272"}, "47094216": {"CommentCount": "0", "Body": "<p><strong>No</strong>, since accesing an array out of bounds invokes <em>Undefined Behavior</em>, both in C and C++.</p>\n", "CreationDate": "2017-11-03T11:02:11.917", "ParentId": "47094166", "Id": "47094216", "LastActivityDate": "2017-11-03T11:02:11.917", "PostTypeId": "2", "Score": "3", "OwnerUserId": "2411320"}, "47100352": {"CreationDate": "2017-11-03T16:27:02.367", "CommentCount": "1", "Body": "<p>Short Answer: <strong>No.</strong> You're in the land of undefined behavior.</p>\n<p>Long Answer: <strong>No.</strong> But that doesn't mean that you can't access the data in other sketchier ways... if you're using GCC you can do something like the following (elaboration of dwillis's answer):</p>\n<pre><code>struct __attribute__((packed,aligned(4))) Bad_Access {\n    int arr1[3];\n    int arr2[3];\n};\n</code></pre>\n<p>and then you <em>could</em> access via (<a href=\"https://gcc.godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,source:'struct+__attribute__((packed,aligned(4)))+Bad_Access+%7B%0A++++int+arr1%5B3%5D%3B%0A++++int+arr2%5B3%5D%3B%0A%7D%3B%0A%0Aint+foo(Bad_Access+*ba)+%7B%0A++++//auto+x+%3D+(int*)Bad_Access%5B4%5D%3B+++//+error%0A++++int+x+%3D+((int*)ba)%5B4%5D%3B%0A++++return+x%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:41.73014145810664,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((g:!((h:compiler,i:(compiler:g72,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',trim:'1'),libs:!(),options:'-std%3Dgnu%2B%2B11+-Wall+-O3+-Wextra+-Wpedantic+-pedantic',source:1),l:'5',n:'0',o:'x86-64+gcc+7.2+(Editor+%231,+Compiler+%231)',t:'0')),k:31.733077934517716,l:'4',m:50,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1),l:'5',n:'0',o:'%231+with+x86-64+gcc+7.2',t:'0')),header:(),l:'4',m:50,n:'0',o:'',s:0,t:'0')),k:58.26985854189336,l:'3',n:'0',o:'',t:'0')),l:'2',n:'0',o:'',t:'0')),version:4\" rel=\"nofollow noreferrer\">Godbolt source+asm</a>):</p>\n<pre><code>int x = ((int*)ba_pointer)[4];\n</code></pre>\n<p>But that cast violates strict aliasing so is only safe with <code>g++ -fno-strict-aliasing</code>.  You can cast a struct pointer to a pointer to the first member, but then you're back in the UB boat because you're accessing outside the first member.</p>\n<p>Alternatively, just don't do that. Save a future programmer (probably yourself) the heartache of that mess.</p>\n<p>Also, while we're at it, why not use std::vector? It's not fool-proof, but on the back-end it has guards to prevent such bad behavior.</p>\n<p><strong>Addendum:</strong></p>\n<p>If you're really concerned about performance:</p>\n<p>Let's say you have two same-typed pointers that you're accessing. The compiler will more than likely assume that both pointers have the chance to interfere, and will instantiate additional logic to protect you from doing something dumb.</p>\n<p>If you solemnly swear to the compiler that you're not trying to alias, the compiler will reward you handsomely:\n<a href=\"https://stackoverflow.com/questions/1965487/does-the-restrict-keyword-provide-significant-benefits-in-gcc-g\">Does the restrict keyword provide significant benefits in gcc / g++</a></p>\n<p>Conclusion: Don't be evil; your future self, <strong>and the compiler</strong> will thank you.</p>\n", "Id": "47100352", "OwnerUserId": "8881651", "LastEditDate": "2017-11-15T16:22:00.040", "ParentId": "47094166", "LastActivityDate": "2017-11-15T16:22:00.040", "PostTypeId": "2", "Score": "1", "LastEditorUserId": "8881651"}, "47108851": {"CreationDate": "2017-11-04T08:21:42.523", "CommentCount": "0", "Body": "<p>Jed Schaff\u2019s answer is on the right track, but not quite correct.  If the compiler inserts padding between <code>a</code> and <code>b</code>, his solution will still fail.  If, however, you declare:</p>\n<pre><code>typedef struct {\n  int a[4];\n  int b[4];\n} s_t;\n\ntypedef union {\n  char bytes[sizeof(s_t)];\n  s_t s;\n} u_t;\n</code></pre>\n<p>You may now access <code>(int*)(bytes + offsetof(s_t, b))</code> to get the address of <code>s.b</code>, no matter how the compiler lays out the structure.  The <code>offsetof()</code> macro is declared in <code>&lt;stddef.h&gt;</code>.</p>\n<p>The expression <code>sizeof(s_t)</code> is a constant expression, legal in an array declaration in both C and C++.  It will not give a variable-length array.  (Apologies for misreading the C standard before.  I thought that sounded wrong.)</p>\n<p>In the real world, though, two consecutive arrays of <code>int</code> in a structure are going to be laid out the way you expect.  (You <em>might</em> be able to engineer a very contrived counterexample by setting the bound of <code>a</code> to 3 or 5 instead of 4 and then getting the compiler to align both <code>a</code> and <code>b</code> on a 16-byte boundary.)  Rather than convoluted methods to try to get a program that makes no assumptions whatsoever beyond the strict wording of the standard, you want some kind of defensive coding, such as <code>static assert(&amp;both_arrays[4] == &amp;s.b[0], \"\");</code>. These add no run-time overhead and will fail if your compiler is doing something that would break your program, so long as you don\u2019t trigger UB in the assertion itself.</p>\n<p>If you want a portable way to guarantee that both sub-arrays are packed into a contiguous memory range, or split a block of memory the other way, you can copy them with <code>memcpy()</code>.</p>\n", "Id": "47108851", "OwnerUserId": "4474419", "LastEditDate": "2017-11-04T10:56:56.603", "ParentId": "47094166", "LastActivityDate": "2017-11-04T10:56:56.603", "PostTypeId": "2", "Score": "1", "LastEditorUserId": "4474419"}, "47106069": {"CreationDate": "2017-11-04T00:18:19.887", "CommentCount": "1", "Body": "<p>As @MartinJames mentioned in a comment, if you need to guarantee that <code>a</code> and <code>b</code> are in contiguous memory (or at least able to be treated as such, (edit) unless your architecture/compiler uses an unusual memory block size/offset and forced alignment that would require padding to be added), you need to use a <code>union</code>.</p>\n<pre><code>union overlap {\n    char all[8]; /* all the bytes in sequence */\n    struct { /* (anonymous struct so its members can be accessed directly) */\n        char a[4]; /* padding may be added after this if the alignment is not a sub-factor of 4 */\n        char b[4];\n    };\n};\n</code></pre>\n<p>You can't directly access <code>b</code> from <code>a</code> (e.g. <code>a[6]</code>, like you asked), but you <em>can</em> access the elements of both <code>a</code> and <code>b</code> by using <code>all</code> (e.g. <code>all[6]</code> refers to the same memory location as <code>b[2]</code>).</p>\n<p>(Edit: You could replace <code>8</code> and <code>4</code> in the code above with <code>2*sizeof(int)</code> and <code>sizeof(int)</code>, respectively, to be more likely to match the architecture's alignment, especially if the code needs to be more portable, but then you have to be careful to avoid making any assumptions about how many bytes are in <code>a</code>, <code>b</code>, or <code>all</code>. However, this will work on what are probably the most common (1-, 2-, and 4-byte) memory alignments.)</p>\n<p>Here is a simple example:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nunion overlap {\n    char all[2*sizeof(int)]; /* all the bytes in sequence */\n    struct { /* anonymous struct so its members can be accessed directly */\n        char a[sizeof(int)]; /* low word */\n        char b[sizeof(int)]; /* high word */\n    };\n};\n\nint main()\n{\n    union overlap testing;\n    testing.a[0] = 'a';\n    testing.a[1] = 'b';\n    testing.a[2] = 'c';\n    testing.a[3] = '\\0'; /* null terminator */\n    testing.b[0] = 'e';\n    testing.b[1] = 'f';\n    testing.b[2] = 'g';\n    testing.b[3] = '\\0'; /* null terminator */\n    printf(\"a=%s\\n\",testing.a); /* output: a=abc */\n    printf(\"b=%s\\n\",testing.b); /* output: b=efg */\n    printf(\"all=%s\\n\",testing.all); /* output: all=abc */\n\n    testing.a[3] = 'd'; /* makes printf keep reading past the end of a */\n    printf(\"a=%s\\n\",testing.a); /* output: a=abcdefg */\n    printf(\"b=%s\\n\",testing.b); /* output: b=efg */\n    printf(\"all=%s\\n\",testing.all); /* output: all=abcdefg */\n\n    return 0;\n}\n</code></pre>\n", "Id": "47106069", "OwnerUserId": "1736312", "LastEditDate": "2017-11-19T03:44:17.637", "ParentId": "47094166", "LastActivityDate": "2017-11-19T03:44:17.637", "PostTypeId": "2", "Score": "5", "LastEditorUserId": "1736312"}});