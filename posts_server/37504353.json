post_cb({"bq_ids": {"n4140": {"so_37504353_37504414_0": {"length": 16, "quality": 0.6153846153846154, "section_id": 6187}, "so_37504353_37504414_1": {"length": 9, "quality": 0.5625, "section_id": 6187}, "so_37504353_37504414_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 6187}}, "n3337": {"so_37504353_37504414_2": {"length": 14, "quality": 0.7368421052631579, "section_id": 5947}}, "n4659": {"so_37504353_37504414_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 7690}, "so_37504353_37504414_1": {"length": 16, "quality": 1.0, "section_id": 7690}, "so_37504353_37504414_2": {"length": 19, "quality": 1.0, "section_id": 7690}, "so_37504353_37504414_4": {"length": 20, "quality": 1.0, "section_id": 7690}, "so_37504353_37504414_3": {"length": 10, "quality": 1.0, "section_id": 7690}}}, "37504414": {"Id": "37504414", "PostTypeId": "2", "Body": "<h2>Discussion</h2>\n<p>Your <code>world</code> variable is <code>constexpr</code> but <code>operator+</code> in expression:</p>\n<pre><code>constexpr StaticString both3 = \"hello \" + world;\n</code></pre>\n<p>although marked as <code>constexpr</code> is not. Because in its return statement:</p>\n<pre><code>return StaticString(str) + other;\n</code></pre>\n<p>due to the creation of the temporary <code>StaticString(str)</code> pointers to non-static-storage duration temporaries are also being created. This is attributed to the fact that in your <code>StaticString</code> objects you're storing addresses of non-static-storage duration temporaries and these kind of pointers are not allowed in constant expressions. </p>\n<h2>Justification</h2>\n<p>According to the standard <em>\u00a75.20/p5 Constant expressions [expr.const]</em> (<strong>Emphasis Mine</strong>):</p>\n<blockquote>\n<p id=\"so_37504353_37504414_0\">A constant expression is either a glvalue core constant expression\n  whose value refers to an entity that is a permitted result of a\n  constant expression (as defined below), or a prvalue core constant\n  expression whose value satisfies the following constraints:</p>\n<p id=\"so_37504353_37504414_1\">(5.1) \u2014 if the value is an object of class type, each non-static data\n  member of reference type refers to an entity that is a permitted\n  result of a constant expression,</p>\n<p id=\"so_37504353_37504414_2\">(5.2) \u2014 <strong>if the value is of pointer type, it contains the address of an\n  object with static storage duration, the address past the end of such\n  an object (5.7), the address of a function, or a null pointer value,\n  and</strong></p>\n<p id=\"so_37504353_37504414_3\">(5.3) \u2014 if the value is an object of class or array type, <strong>each\n  subobject satisfies these constraints for the value.</strong></p>\n<p id=\"so_37504353_37504414_4\">An entity is a permitted result of a constant expression if it is an\n  object with static storage duration that is either not a temporary\n  object or is a temporary object whose value satisfies the above\n  constraints, or it is a function.</p>\n</blockquote>\n<p>.</p>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2016-05-29T00:08:58.857", "Score": "7", "CreationDate": "2016-05-28T22:44:32.507", "ParentId": "37504353", "CommentCount": "9", "LastEditDate": "2016-05-29T00:08:58.857", "OwnerUserId": "2352671"}, "37504353": {"ViewCount": "219", "Body": "<p>I have made a <code>constexpr</code> string type, which I call <code>StaticString</code>.  I got this idea from <a href=\"https://www.daniweb.com/programming/software-development/code/482276/c-11-compile-time-string-concatenation-with-constexpr\" rel=\"nofollow\">this</a> website.</p>\n<p>I am having some weird issues with the compiler treating a variable as a <code>constexpr</code> on one line, and then not a <code>constexpr</code> on the next line.</p>\n<p>Here is the code:</p>\n<pre><code>constexpr StaticString hello = \"hello\";\nconstexpr StaticString hello2 = hello + \" \";\nconstexpr StaticString world = \"world\";\nconstexpr StaticString both = hello + \" world\";\nconstexpr StaticString both2 = hello2 + world;\n//This works fine (world is constexpr?)\n\n//constexpr StaticString both3 = \"hello \" + world; \n//ERROR: \"world\" is not constexpr\n\nint main(void)\n{\n    static_assert(hello[4] == 'o' ,\"ERROR\");\n    static_assert(hello == \"hello\", \"ERROR\");\n    static_assert(both2 == \"hello world\", \"ERROR\");\n}\n</code></pre>\n<p>And here is the definition of <code>StaticString</code>:</p>\n<pre><code>class StaticString{\n        const char* const str;\n        const size_t len;\n        const StaticString* head;\n    public:\n        template&lt;size_t N&gt;\n        constexpr StaticString(const char(&amp;aStr)[N]) \n            : str(aStr), len(N-1), head(nullptr)  //Chop off the null terminating char\n        {\n            static_assert(N&gt;=1,\"String cannot have a negative length\");\n        }\n        template&lt;size_t N&gt;\n        constexpr StaticString(const char(&amp;aStr)[N] ,const StaticString* ss) : head(ss), str(aStr),len(N-1) { }\n        constexpr StaticString(const char* const aStr ,const size_t len,const StaticString* ss = nullptr) \n            : str(aStr), len(len), head(ss)\n        {\n        }\n        constexpr char GetFromHead(size_t index) const{\n            return index &lt; head-&gt;GetSize() ? (*head)[index] : str[index - head-&gt;GetSize()];\n        }\n        constexpr char operator[](size_t index) const{\n            return head ? GetFromHead(index) : str[index];\n        }\n        constexpr size_t GetSize() const{\n            return head ? len + head-&gt;GetSize() : len;\n        }\n        constexpr bool Equals(const char* const other,size_t len,size_t index = 0) const{\n\n            return (other[0] == (*this)[index]) ? (len &gt; 1 ? Equals(&amp;other[1],len-1,index+1) : true) : false;\n        }\n        template&lt;size_t N&gt;\n        constexpr bool operator==(const char(&amp;other)[N]) const{\n            return Equals(other,N-1);\n        }\n        template&lt;size_t N&gt;\n        constexpr StaticString operator+(const char(&amp;other)[N]) const{\n            return StaticString(other,this);\n        }\n        constexpr StaticString operator+(StaticString other) const{\n            return StaticString(other.str,other.len,this);\n        }\n\n};\ntemplate&lt;size_t N&gt;\nconstexpr StaticString operator+(const char(&amp;str)[N],const StaticString&amp; other){\n    return StaticString(str) + other;\n}\n</code></pre>\n<p>So my question is this: why does <code>world</code> get treated as a <code>constexpr</code> on one line but not the next?</p>\n<p><strong>NOTE:</strong> \nThis is the error I get:</p>\n<pre><code>'StaticString{((const char*)\"world\"), 5ull, ((const prototypeInd::util::StaticString*)(&amp;&lt;anonymous&gt;))}' is not a constant expression\n</code></pre>\n<p>Also I am using <code>gcc</code></p>\n", "Title": "How can a variable be both constexpr and not constexpr?", "CreationDate": "2016-05-28T22:34:51.887", "LastActivityDate": "2016-05-29T00:44:44.157", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-05-29T00:44:44.157", "LastEditorUserId": "4928", "Id": "37504353", "Score": "8", "OwnerUserId": "6149078", "Tags": "<c++><constexpr><compile-time-constant>", "AnswerCount": "1"}});