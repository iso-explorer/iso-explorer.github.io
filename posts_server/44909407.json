post_cb({"bq_ids": {"n4140": {"so_44909407_44909130_6": {"length": 38, "quality": 0.9743589743589743, "section_id": 5795}, "so_44909407_44909913_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 5795}, "so_44909407_44909130_2": {"length": 20, "quality": 0.8333333333333334, "section_id": 5791}, "so_44909407_44909831_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 5795}, "so_44909407_44909130_4": {"length": 19, "quality": 0.95, "section_id": 5794}}, "n3337": {"so_44909407_44909130_6": {"length": 38, "quality": 0.9743589743589743, "section_id": 5568}, "so_44909407_44909913_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 5568}, "so_44909407_44909130_2": {"length": 20, "quality": 0.8333333333333334, "section_id": 5564}, "so_44909407_44909831_0": {"length": 24, "quality": 0.8571428571428571, "section_id": 5568}, "so_44909407_44909130_4": {"length": 19, "quality": 0.95, "section_id": 5567}}, "n4659": {"so_44909407_44909130_6": {"length": 37, "quality": 0.9487179487179487, "section_id": 7254}, "so_44909407_44909913_0": {"length": 28, "quality": 1.0, "section_id": 7254}, "so_44909407_44909130_2": {"length": 20, "quality": 0.8333333333333334, "section_id": 7248}, "so_44909407_44909831_0": {"length": 28, "quality": 1.0, "section_id": 7254}, "so_44909407_44909130_4": {"length": 19, "quality": 0.95, "section_id": 7253}}}, "44909407": {"ViewCount": "873", "Body": "<p>Consider</p>\n<pre><code>struct base {};\nstruct child : base {};\n</code></pre>\n<p>It's well-known that <code>sizeof(child)</code> can be 1 by application of the <em>empty base optimisation</em>.</p>\n<p>Now however, consider</p>\n<pre><code>struct base {};\nstruct child : base {base b;};\n</code></pre>\n<p>Can the compiler apply the empty base optimisation now, or must <code>sizeof(child)</code> be at least 2?</p>\n<p>Reference: <a href=\"http://en.cppreference.com/w/cpp/language/ebo\" rel=\"noreferrer\">http://en.cppreference.com/w/cpp/language/ebo</a></p>\n", "AcceptedAnswerId": "44909645", "Title": "Can the compiler exploit empty base optimisation if the class contains a member of the base class?", "CreationDate": "2017-07-04T15:11:26.837", "Id": "44909407", "CommentCount": "12", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2017-07-04T21:33:06.273", "LastEditorUserId": "3233393", "LastActivityDate": "2017-07-04T21:33:06.273", "Score": "12", "OwnerUserId": "2380830", "Tags": "<c++><language-lawyer>", "AnswerCount": "4"}, "44909913": {"Id": "44909913", "PostTypeId": "2", "Body": "<p>Objects in C++ are required to have unique \"identity\". From [intro.object]/8 (N4659):</p>\n<blockquote>\n<p id=\"so_44909407_44909913_0\">Two objects <code>a</code> and <code>b</code> with overlapping lifetimes that are not bit-fields may have the same address if one is nested within the other, or if at least one is a base class subobject of zero size and they are of different types; otherwise, they have distinct addresses.</p>\n</blockquote>\n<p>A base class subobject and a member subobject are separate objects; neither is \"nested within\" the other. Therefore, if they are of the same type, they must have separate addresses.</p>\n<p>Note that this extends <em>recursively</em>. Consider the following:</p>\n<pre><code>struct eb1 {};\n\nstruct eb2 : eb1 {};\nstruct not_empty(eb1 a;};\n\nstruct derived : eb2 {not_empty b;};\n</code></pre>\n<p>Because of the unique identity rule of C++, <code>derived::eb2::eb1</code> <em>must</em> have a different address from <code>derived::b::a</code>. Therefore, the compiler <em>cannot</em> employ EBO on <code>derived</code>.</p>\n", "LastActivityDate": "2017-07-04T15:41:05.837", "CommentCount": "1", "CreationDate": "2017-07-04T15:41:05.837", "ParentId": "44909407", "Score": "14", "OwnerUserId": "734069"}, "44909130": {"Id": "44909130", "PostTypeId": "2", "Body": "<p>The rule is that sub-objects of the same type cannot be at the same address. You have 2 <code>X</code> sub-objects here, hence each one must be at a different address.</p>\n<p>Objects of the same type cannot share the same address because the identity of an object in C++ is its address. If multiples objects of the same type share the same address they are indistinguishable. And this is why the minimum complete object size is 1, so that each object in an array has a distinct address. See \"\u00a7 The C++ object model [intro.object]\":</p>\n<blockquote>\n<p id=\"so_44909407_44909130_0\">An object is a region of storage.</p>\n<p id=\"so_44909407_44909130_1\">...</p>\n<p id=\"so_44909407_44909130_2\">Objects can contain other objects, called subobjects. A subobject can be a member subobject (9.2), a base class subobject (Clause 10), or an array element. An object that is not a subobject of any other object is\n  called a complete object.</p>\n<p id=\"so_44909407_44909130_3\">...</p>\n<p id=\"so_44909407_44909130_4\">Unless it is a bit-field (9.6), a most derived object shall have a non-zero size and shall occupy one or more bytes of storage. Base class subobjects may have zero size.</p>\n<p id=\"so_44909407_44909130_5\">...</p>\n<p id=\"so_44909407_44909130_6\">Unless an object is a bit-field or a base class subobject of zero size, the address of that object is the address of the first byte it occupies. Two objects that are not bit-fields may have the same address if one is a subobject of the other, or if at least one is a base class subobject of zero size and they are of different types; otherwise, they shall have distinct addresses.</p>\n</blockquote>\n<p>This is why, for example, <code>boost::noncopyable</code> can increase a class size if one inherits it more than once unwittingly indirectly through empty base classes. E.g. in:</p>\n<pre><code>struct A : boost::noncopyable {};\nstruct B : boost::noncopyable {};\nstruct C : boost::noncopyable {};\nstruct D : A, B, C {};\n</code></pre>\n<p><code>sizeof(D) == 3</code> because there are three distinct <code>boost::noncopyable</code> sub-subjects. If derivation from <code>boost::noncopyable</code> is dropped, then <code>sizeof(D) == 1</code>.</p>\n", "LastEditorUserId": "412080", "LastActivityDate": "2017-07-04T15:27:19.307", "Score": "15", "CreationDate": "2017-07-04T14:56:48.417", "ParentId": "44909407", "CommentCount": "23", "OwnerUserId": "412080", "LastEditDate": "2017-07-04T15:27:19.307"}, "44909645": {"Id": "44909645", "PostTypeId": "2", "Body": "<p>No, it cannot. From the same reference:</p>\n<blockquote>\n<p id=\"so_44909407_44909645_0\">Empty base optimization is prohibited if one of the empty base classes\n  is also the type or the base of the type of the first non-static data\n  member</p>\n</blockquote>\n<p>Thus <code>sizeof(child) &gt;= 2</code>.</p>\n", "LastEditorUserId": "5581801", "LastActivityDate": "2017-07-04T15:26:47.080", "Score": "18", "CreationDate": "2017-07-04T15:24:34.510", "ParentId": "44909407", "CommentCount": "2", "OwnerUserId": "5581801", "LastEditDate": "2017-07-04T15:26:47.080"}, "44909831": {"Id": "44909831", "PostTypeId": "2", "Body": "<p>I'll plop in another more basic quote</p>\n<p><a href=\"http://eel.is/c++draft/intro.object#8\" rel=\"noreferrer\">[intro.object]</a></p>\n<blockquote>\n<p id=\"so_44909407_44909831_0\">Two objects a and b with overlapping lifetimes that are not bit-fields may have the same address if one is nested within the other, or if at least one is a base class subobject of zero size and they are of different types; otherwise, they have distinct addresses.</p>\n</blockquote>\n<hr>\n<p>Since <code>b</code> is not an subobject of the inherited <code>base</code>, they must have distinct addresses.</p>\n</hr>", "LastActivityDate": "2017-07-04T15:36:16.180", "CommentCount": "4", "CreationDate": "2017-07-04T15:36:16.180", "ParentId": "44909407", "Score": "6", "OwnerUserId": "4832499"}});