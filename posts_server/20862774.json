post_cb({"bq_ids": {"n4140": {"so_20862774_20862774_10": {"length": 8, "quality": 1.0, "section_id": 3401}, "so_20862774_20862774_6": {"length": 42, "quality": 0.9545454545454546, "section_id": 7151}, "so_20862774_20862936_1": {"length": 13, "quality": 1.0, "section_id": 7152}, "so_20862774_20862774_8": {"length": 7, "quality": 0.7, "section_id": 6185}, "so_20862774_20862936_2": {"length": 20, "quality": 1.0, "section_id": 7152}, "so_20862774_20862936_0": {"length": 18, "quality": 1.0, "section_id": 7152}, "so_20862774_20862774_2": {"length": 13, "quality": 0.8666666666666667, "section_id": 7151}, "so_20862774_20862774_5": {"length": 15, "quality": 1.0, "section_id": 7151}}, "n3337": {"so_20862774_20862774_10": {"length": 8, "quality": 1.0, "section_id": 3270}, "so_20862774_20862774_6": {"length": 42, "quality": 0.9545454545454546, "section_id": 6895}, "so_20862774_20862936_1": {"length": 13, "quality": 1.0, "section_id": 6896}, "so_20862774_20862774_8": {"length": 10, "quality": 1.0, "section_id": 5946}, "so_20862774_20862936_2": {"length": 20, "quality": 1.0, "section_id": 6896}, "so_20862774_20862936_0": {"length": 18, "quality": 1.0, "section_id": 6896}, "so_20862774_20862774_12": {"length": 25, "quality": 1.0, "section_id": 5947}, "so_20862774_20862774_2": {"length": 13, "quality": 0.8666666666666667, "section_id": 6895}, "so_20862774_20862774_5": {"length": 15, "quality": 1.0, "section_id": 6895}}, "n4659": {"so_20862774_20862774_10": {"length": 8, "quality": 1.0, "section_id": 4158}, "so_20862774_20862936_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 8653}, "so_20862774_20862936_2": {"length": 20, "quality": 1.0, "section_id": 8653}, "so_20862774_20862936_1": {"length": 11, "quality": 0.8461538461538461, "section_id": 8653}, "so_20862774_20862774_2": {"length": 9, "quality": 0.6, "section_id": 4051}, "so_20862774_20862774_5": {"length": 8, "quality": 0.5333333333333333, "section_id": 8652}}}, "20862936": {"Id": "20862936", "PostTypeId": "2", "Body": "<p>I think what's happening here is that <code>1 + 2 * INT_MIN</code> <em>is</em> evaluated at compile-time, and <code>i</code> <em>is</em> initialized during static-initialization. This is allowed in [basic.start.init]/3</p>\n<blockquote>\n<p id=\"so_20862774_20862936_0\">An implementation is permitted to perform the initialization of a non-local variable with static storage\n  duration as a static initialization even if such initialization is not required to be done statically, provided\n  that</p>\n<ul>\n<li><p id=\"so_20862774_20862936_1\">the dynamic version of the initialization does not change the value of any other object of namespace\n  scope prior to its initialization, and</p></li>\n<li><p id=\"so_20862774_20862936_2\">the static version of the initialization produces the same value in the initialized variable as would be\n  produced by the dynamic initialization if all variables not required to be initialized statically were\n  initialized dynamically.</p></li>\n</ul>\n</blockquote>\n<p>So, even though <code>i</code> isn't required to be initialized during constant initialization, it <em>can</em> be initialized during static initialization, which is still before dynamic initialization. The same could be true for <code>s</code>, but I don't think that's possible for a compiler to do because of the side-effects.</p>\n<hr>\n<p>As <a href=\"https://stackoverflow.com/users/150634/sftrabbit\">sftrabbit</a> noted, instead of invoking UB, you can make the initializing expression arbitrarily complex, so that <code>i</code> is indeed only initialized during dynamic initialization. For example:</p>\n<pre><code>int foobar()\n{\n    return 42;\n}\n\nint i = foobar();\n</code></pre>\n<p>prints <code>Hello, world!</code> on both compilers.</p>\n<hr>\n<p>As a side remark: In order to see that <code>1 + 2 * INT_MIN</code> invokes UB because of signed integer overflow, it might be necessary to evaluate the expression. This could lead to UB during the initialization.</p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-12-31T20:48:16.957", "Score": "6", "CreationDate": "2013-12-31T20:37:28.637", "ParentId": "20862774", "CommentCount": "9", "LastEditDate": "2017-05-23T12:28:13.477", "OwnerUserId": "420683"}, "20862774": {"ViewCount": "210", "Body": "<p>Consider this program:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;limits.h&gt;\n\nextern int i;\n\nstruct S {\n    S() {\n        if (i == 0) {\n            puts(\"Hello, world!\");\n            exit(0);\n        }\n    }\n};\n\nS s;\n\nint i = 1 + 2 * INT_MIN;\n\nint main() { }\n</code></pre>\n<p>As I understood the evaluation of expressions, this is a strictly conforming program, that prints \"Hello, world!\", then exits, and never actually evaluates the initialiser for <code>i</code>:</p>\n<blockquote>\n<p id=\"so_20862774_20862774_0\"><strong>3.6.2 Initialization of non-local variables [basic.start.init]</strong></p>\n<p id=\"so_20862774_20862774_1\">[...]</p>\n<p id=\"so_20862774_20862774_2\">Variables with static storage duration (3.7.1) or thread storage duration (3.7.2) shall be zero-initialized (8.5) before any other initialization takes place.</p>\n<p id=\"so_20862774_20862774_3\">Constant initialization is performed:</p>\n<p id=\"so_20862774_20862774_4\">-- [...]</p>\n<p id=\"so_20862774_20862774_5\">-- if an object with static or thread storage duration is not initialized by a constructor call and if every full-expression that appears in its initializer is a constant expression.</p>\n<p id=\"so_20862774_20862774_6\">Together, zero-initialization and constant initialization are called <em>static initialization</em>; all other initialization is <em>dynamic initialization</em>. Static initialization shall be performed before any dynamic initialization takes place. Dynamic initialization of a non-local variable with static storage duration is either ordered or unordered. [...] Variables with ordered initialization defined within a single translation unit shall be initialized in the order of their definitions in the translation unit. [...]</p>\n<p id=\"so_20862774_20862774_7\"><strong>5.19 Constant expressions [expr.const]</strong></p>\n<p id=\"so_20862774_20862774_8\">A conditional-expression is a <em>core constant expression</em> unless it involves one of the\n  following as a potentially evaluated subexpression (3.2) [...]:</p>\n<p id=\"so_20862774_20862774_9\">-- [...]</p>\n<p id=\"so_20862774_20862774_10\">-- a result that is not mathematically defined or not in the range of representable values for its type;</p>\n<p id=\"so_20862774_20862774_11\">[...]</p>\n<p id=\"so_20862774_20862774_12\">A <em>literal constant expression</em> is a prvalue core constant expression of literal type, but not pointer type. [...] Collectively, literal constant expressions, reference constant expressions, and address constant expressions are called <em>constant expressions</em>.</p>\n</blockquote>\n<p>Because the expression <code>1 + 2 * INT_MIN</code> has signed integer overflow, it is not a core constant expression, thus not a literal constant expression, thus not a constant expression. Because the initialiser for <code>i</code> is not a constant expression, dynamic initialisation is performed. The initialisation for <code>s</code> is also dynamic, and because its definition precedes that of <code>i</code>, its constructor runs first. At that point, only zero-initialisation has been performed, so the check <code>i == 0</code> should evaluate as true.</p>\n<p>However, GCC and clang agree that <code>i</code> can be statically initialised to <code>1</code>. My experience when those two agree is that they are correct, so I am left wondering... is any part of my analysis incorrect?</p>\n", "AcceptedAnswerId": "20862936", "Title": "Undefined behaviour during evaluation of a potential constant expression", "CreationDate": "2013-12-31T20:15:34.230", "Id": "20862774", "CommentCount": "7", "PostTypeId": "1", "LastActivityDate": "2013-12-31T20:48:16.957", "Score": "9", "OwnerUserId": "743382", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "1"}});