post_cb({"11116209": {"ViewCount": "440", "Body": "<p>How can I put the address of the array into a variable?</p>\n<pre><code>char * str1 = \"Hello\";\nint add = 0;\n</code></pre>\n<p>Now I want to put the address of the array into <code>add</code>.\nI know I can print out the address of the array by the following way:</p>\n<pre><code>printf(\"Address = %p\", str1);\n</code></pre>\n<p>But, I want to store the address in the variable.</p>\n", "AcceptedAnswerId": "11116261", "Title": "How to put the address of the array into a variable", "CreationDate": "2012-06-20T09:07:28.250", "Id": "11116209", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2012-06-20T09:55:55.467", "Score": "1", "OwnerUserId": "619540", "Tags": "<c++>", "AnswerCount": "4"}, "11116261": {"Id": "11116261", "PostTypeId": "2", "Body": "<p>If you want to store a memory address in a variable, the correct way is to type the variable as <code>std::intptr_t</code> or <code>std::uintptr_t</code>. That is because these types are <em>guaranteed</em> large enough to hold any memory address:</p>\n<pre><code>char * str1 = \"Hello\";\nuintptr_t p = (uintptr_t)str1;\n</code></pre>\n<p>Apart from that, note that the value of <code>str1</code> is already a memory address (it points to <code>H</code>) albeit a different one from the value of <code>&amp;str1</code> (which points to <code>str1</code>).</p>\n", "LastEditorUserId": "50079", "LastActivityDate": "2012-06-20T09:32:46.213", "Score": "4", "CreationDate": "2012-06-20T09:10:51.763", "ParentId": "11116209", "CommentCount": "6", "LastEditDate": "2012-06-20T09:32:46.213", "OwnerUserId": "50079"}, "bq_ids": {"n4140": {"so_11116209_11116280_0": {"length": 20, "quality": 0.8, "section_id": 6043}}, "n3337": {"so_11116209_11116280_0": {"length": 20, "quality": 0.8, "section_id": 5811}}, "n4659": {"so_11116209_11116280_0": {"length": 20, "quality": 0.8, "section_id": 7542}}}, "11116280": {"Id": "11116280", "PostTypeId": "2", "Body": "<p>Use <code>reinterpret_cast</code> (see 5.2.10/p4):</p>\n<blockquote>\n<p id=\"so_11116209_11116280_0\">4 A pointer can be explicitly converted to any integral type large enough to hold it. The mapping function is\n  implementation-defined. [ Note: It is intended to be unsurprising to those who know the addressing structure\n  of the underlying machine. \u2014end note ]</p>\n</blockquote>\n<pre><code>static_assert( sizeof( unsigned int ) &gt;= sizeof( &amp;str1[ 0 ] ),  \"warning: use a wider type!\" );\nunsigned int add = reinterpret_cast&lt; unsigned int &gt;( &amp;str1[ 0 ] );\n</code></pre>\n", "LastActivityDate": "2012-06-20T09:12:03.367", "Score": "1", "CreationDate": "2012-06-20T09:12:03.367", "ParentId": "11116209", "CommentCount": "0", "OwnerUserId": "66692"}, "11116278": {"Id": "11116278", "PostTypeId": "2", "Body": "<p>Turning a pointer into a number requires reinterpretation:</p>\n<pre><code>add = reinterpret_cast&lt;int&gt;(str1);\n</code></pre>\n<p>But there are all kinds of problems associated with this approach:</p>\n<ul>\n<li>If sizeof(int) &lt; sizeof(char*) then part of the pointer is lost, you won't be able to restore it.</li>\n<li>Some optimizations might turn your code invalid due to unexpected aliasing.</li>\n</ul>\n<p>If you need a variable which can hold pointers <em>or</em> integers, it would be better to use a union instead.</p>\n", "LastActivityDate": "2012-06-20T09:11:54.867", "Score": "3", "CreationDate": "2012-06-20T09:11:54.867", "ParentId": "11116209", "CommentCount": "3", "OwnerUserId": "1468366"}, "11117033": {"Id": "11117033", "PostTypeId": "2", "Body": "<p>From your comment on Jon's accepted answer:</p>\n<pre><code>char str1[] = \"Hello\";\nchar* str2 = &amp;str1[0];\nuintptr_t p = (uintptr_t)str2;\nstd::cout &lt;&lt; std::hex &lt;&lt; p &lt;&lt; std::endl;\np = (uintptr_t)&amp;str1[1];\nstd::cout &lt;&lt; std::hex &lt;&lt; p &lt;&lt; std::endl;\np = (uintptr_t)&amp;str1[0];\nstd::cout &lt;&lt; std::hex &lt;&lt; p &lt;&lt; std::endl;\n</code></pre>\n<p>This implies your objective is to be able to stream the pointer value in a readable format.  The Standard provides for this in an implementation-defined fashion as follows:</p>\n<pre><code>basic_ostream&lt;charT,traits&gt;&amp; operator&lt;&lt;(const void* p);\n</code></pre>\n<p>So, perhaps what you really want is satisfied by the C++ style or (concise but less self-doncumenting and compiler-checked) C-style code below:</p>\n<pre><code>std::cout &lt;&lt; static_cast&lt;void*&gt;(str1) &lt;&lt; '\\n';\nstd::cout &lt;&lt; (void*)str1 &lt;&lt; '\\n';\n</code></pre>\n<p>(But, if you specifically want a numeric versions, or to ensure it's displayed in hex with no leading 0x or whatever else an implementation may decide upon, then you're back to Jon's suggestion or your own (possibly compile-time checked) logic to find a big enough integral type.</p>\n", "LastActivityDate": "2012-06-20T09:55:55.467", "Score": "1", "CreationDate": "2012-06-20T09:55:55.467", "ParentId": "11116209", "CommentCount": "1", "OwnerUserId": "410767"}});