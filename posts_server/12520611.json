post_cb({"12520856": {"ParentId": "12520611", "CommentCount": "0", "Body": "<p>According to the C++11 document I have (i.e. the freebie, slightly-prior-to-ratification n3242), section 5.1.2, para 21, the captures are constructed in declaration order and destructed in reverse declaration order. However, declaration order is unspecified (paragraph 14). So the answer is, \"in unspecified order\" and \"you cannot influence it\" (except, I suppose, by writing a compiler).</p>\n<p>If bar really needs to be destructed before foo, it would be wise for bar to hold a shared pointer to foo (or something of the kind).</p>\n", "OwnerUserId": "1566221", "PostTypeId": "2", "Id": "12520856", "Score": "3", "CreationDate": "2012-09-20T21:00:12.030", "LastActivityDate": "2012-09-20T21:00:12.030"}, "12520816": {"ParentId": "12520611", "CommentCount": "4", "Body": "<p>The spec covers this... sort of. From 5.1.2, paragraph 14:</p>\n<blockquote>\n<p id=\"so_12520611_12520816_0\">An entity is captured by copy if it is implicitly captured and the capture-default is = or if it is explicitly captured with a capture that does not include an &amp;. For each entity captured by copy, an unnamed non-static data member is declared in the closure type. <strong>The declaration order of these members is unspecified.</strong></p>\n</blockquote>\n<p>Emphasis added. Because the declaration order is unspecified, the construction order is unspecified (since the order of construction is the same as the order of declaration). And therefore, the <em>destruction</em> order is unspecified, since the order of destruction is the reverse of the order of construction.</p>\n<p>In short, if you need to care about declaration order (and the various construction/destruction orders that key off of it), you <em>cannot</em> use a lambda. You'll need to make your own type.</p>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "12520816", "Score": "15", "CreationDate": "2012-09-20T20:57:02.067", "LastActivityDate": "2012-09-20T20:57:02.067"}, "bq_ids": {"n4140": {"so_12520611_12520816_0": {"section_id": 5974, "quality": 0.8214285714285714, "length": 23}}, "n3337": {"so_12520611_12520816_0": {"section_id": 5742, "quality": 0.8928571428571429, "length": 25}}, "n4659": {"so_12520611_12520816_0": {"section_id": 7473, "quality": 0.8214285714285714, "length": 23}}}, "12521216": {"ParentId": "12520611", "CommentCount": "0", "Body": "<p>Rather than worrying on what the order of destruction will be, you should fix the fact that this is a problem. Noting that you are using shared pointers for both objects, you can ensure the order of destruction by adding a shared pointer in the object that you need to outlive the other. At that point whether <code>foo</code> or <code>bar</code> is destroyed earlier will not matter. If the order is correct, destruction of the shared pointer will release the objects immediately. If the order is incorrect the additional shared pointer will maintain the object alive until the other goes away.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "12521216", "Score": "8", "CreationDate": "2012-09-20T21:31:17.770", "LastActivityDate": "2012-09-20T21:31:17.770"}, "12520611": {"CommentCount": "3", "CreationDate": "2012-09-20T20:41:48.243", "PostTypeId": "1", "AcceptedAnswerId": "12520816", "LastEditorUserId": "636019", "LastActivityDate": "2012-09-20T21:39:05.130", "LastEditDate": "2012-09-20T20:59:52.660", "ViewCount": "674", "FavoriteCount": "2", "Title": "C++11: In what order are lambda captures destructed?", "Id": "12520611", "Score": "12", "Body": "<p>Let's say I have two local smart pointers, <code>foo</code> and <code>bar</code>.</p>\n<pre><code>shared_ptr&lt;Foo&gt; foo = ...\nshared_ptr&lt;Bar&gt; bar = ...\n</code></pre>\n<p>These smart pointers are wrappers around resources that for some reason must be destructed in the order <code>foo</code>, then <code>bar</code>.</p>\n<p>Now I want to create a lambda that uses <code>foo</code> and <code>bar</code>, but outlives the scope containing them. So I'd capture them by value, like this:</p>\n<pre><code>auto lambda = [foo, bar]() { ... };\n</code></pre>\n<p>This creates copies of <code>foo</code> and <code>bar</code> within the function object. When the function object is destructed, these copies will be destructed, as well, but I care about the order in which this happens. So my question is:</p>\n<p>When a lambda object is destructed, in what order are its by-value captures destructed? And how can I (hopefully) influence this order?</p>\n", "Tags": "<c++><lambda><c++11><raii>", "OwnerUserId": "52041", "AnswerCount": "4"}, "12521246": {"ParentId": "12520611", "LastEditDate": "2012-09-20T21:39:05.130", "CommentCount": "1", "CreationDate": "2012-09-20T21:33:27.163", "OwnerUserId": "582", "LastEditorUserId": "582", "PostTypeId": "2", "Id": "12521246", "Score": "8", "Body": "<p>As Nicol says, the order of destruction is unspecified.</p>\n<p>However, you shouldn't have to depend on the destruction of the lambda. You should be able to simply reset <code>foo</code> at the end of your lambda, thus ensuring it releases its resource before <code>bar</code> does. You'll also have to mark the lambda as <code>mutable</code> though. The only downside here is you can't call the lambda multiple times and expect it to work.</p>\n<pre><code>auto lambda = [foo, bar]() mutable { ...; foo.reset(); };\n</code></pre>\n<hr>\n<p>If you do need your lambda to be callable multiple times, then you need to come up with some other way to control the order of deallocation. One option would be to use an intermediate structure with a known data member order, such as a <code>std::pair&lt;&gt;</code>:</p>\n<pre><code>auto p = std::make_pair(bar, foo);\nauto lambda = [p]() { auto foo = p.second, bar = p.first; ... };\n</code></pre>\n</hr>", "LastActivityDate": "2012-09-20T21:39:05.130"}});