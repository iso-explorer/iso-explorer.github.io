post_cb({"bq_ids": {"n4140": {"so_43672392_43720636_4": {"length": 10, "quality": 1.0, "section_id": 632}, "so_43672392_43720636_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 629}, "so_43672392_43720636_2": {"length": 20, "quality": 1.0, "section_id": 599}, "so_43672392_43720636_1": {"length": 54, "quality": 0.9642857142857143, "section_id": 632}, "so_43672392_43720636_3": {"length": 35, "quality": 0.8974358974358975, "section_id": 626}}, "n3337": {"so_43672392_43720636_3": {"length": 35, "quality": 0.8974358974358975, "section_id": 616}, "so_43672392_43720636_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 620}, "so_43672392_43720636_2": {"length": 20, "quality": 1.0, "section_id": 589}, "so_43672392_43720636_1": {"length": 49, "quality": 0.875, "section_id": 622}, "so_43672392_43720636_4": {"length": 10, "quality": 1.0, "section_id": 622}}, "n4659": {"so_43672392_43720636_4": {"length": 10, "quality": 1.0, "section_id": 660}, "so_43672392_43720636_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 655}, "so_43672392_43720636_2": {"length": 20, "quality": 1.0, "section_id": 622}, "so_43672392_43720636_1": {"length": 54, "quality": 0.9642857142857143, "section_id": 660}, "so_43672392_43720636_3": {"length": 37, "quality": 0.9487179487179487, "section_id": 652}}}, "43673323": {"Id": "43673323", "PostTypeId": "2", "Body": "<p><code>B b({0})</code> can result in a call to either of the following:</p>\n<ol>\n<li><p><code>B::B(A)</code></p></li>\n<li><p>Copy constructor of <code>B</code>: constructing a temporary <code>B</code>object from <code>{0}</code> and\nthen copying it over to <code>b</code>.</p></li>\n</ol>\n<p>Hence the ambiguity.</p>\n<p>It can be resolved if you call <code>B b{0}</code>, which directly uses the defined constructor with no copy constructor involvement.</p>\n<p><strong>EDIT:</strong></p>\n<p>Regarding how point 2 is valid:</p>\n<p><code>B</code> has a constructor which accepts <code>A</code>. Now, <code>A</code> can be constructed by an <code>int</code>. Also, <code>int</code> can be constructed via the initialization list. That's why this is a valid case. Had <code>A</code>'s constructor been <code>explicit</code>, automatic casting from <code>{0}</code> to <code>int</code> would have failed, resulting in no ambiguity.</p>\n", "LastEditorUserId": "2912665", "LastActivityDate": "2017-04-28T09:41:35.463", "Score": "3", "CreationDate": "2017-04-28T06:22:05.103", "ParentId": "43672392", "CommentCount": "11", "OwnerUserId": "2912665", "LastEditDate": "2017-04-28T09:41:35.463"}, "43672392": {"ViewCount": "497", "Body": "<pre><code>struct A {\n    A(int) {}\n};\n\nstruct B {\n    B(A) {}\n};\n\nint main() {\n    B b({0});\n}\n</code></pre>\n<p>The construction of <code>b</code> gives the following errors:</p>\n<pre><code>In function 'int main()':\n24:9: error: call of overloaded 'B(&lt;brace-enclosed initializer list&gt;)' is ambiguous\n24:9: note: candidates are:\n11:2: note: B::B(A)\n10:8: note: constexpr B::B(const B&amp;)\n10:8: note: constexpr B::B(B&amp;&amp;)\n</code></pre>\n<p>I was expecting <code>B::B(A)</code> to be called, why is it ambiguous in this case?</p>\n", "AcceptedAnswerId": "43720636", "Title": "Ambigous constructor call with list-initialization", "CreationDate": "2017-04-28T05:11:54.983", "Id": "43672392", "CommentCount": "0", "LastEditDate": "2017-04-28T06:01:44.353", "PostTypeId": "1", "LastEditorUserId": "4672588", "LastActivityDate": "2017-05-01T14:20:19.647", "Score": "12", "OwnerUserId": "381646", "Tags": "<c++><c++11><list-initialization>", "AnswerCount": "3"}, "43720636": {"Id": "43720636", "PostTypeId": "2", "Body": "<p>Given a class, <code>A</code> with a user-defined constructor:</p>\n<pre><code>struct A\n{\n    A(int) {}\n};\n</code></pre>\n<p>and another one, <code>B</code>, accepting <code>A</code> as a constructor parameter:</p>\n<pre><code>struct B\n{\n    B(A) {}\n};\n</code></pre>\n<p>then in order to perform the initialization as below:</p>\n<pre><code>B b({0});\n</code></pre>\n<p>the compiler has to consider the following candidates:</p>\n<pre><code>B(A);         // #1\nB(const B&amp;);  // #2\nB(B&amp;&amp;);       // #3\n</code></pre>\n<p>trying to find an implicit conversion sequence from <code>{0}</code> to each of the parameters.</p>\n<p>Note that <code>B b({0})</code> does not list-initialize <code>b</code> -- the (copy-)list-initialization applies to a constructor parameter itself.</p>\n<p>Since the argument is an initializer list, the implicit conversion sequence needed to match the argument to a parameter is defined in terms of list-initialization sequence <a href=\"http://eel.is/c++draft/over.ics.list\" rel=\"nofollow noreferrer\">[over.ics.list]/p1</a>:</p>\n<blockquote>\n<p id=\"so_43672392_43720636_0\">When an argument is an initializer list ([dcl.init.list]), it is not an expression and special rules apply for converting it to a parameter type.</p>\n</blockquote>\n<p>It reads:</p>\n<blockquote>\n<p id=\"so_43672392_43720636_1\">[...], if the parameter is a non-aggregate class X and overload resolution per 13.3.1.7 chooses a single\n  best constructor of X to perform the initialization of an object of type X from the argument initializer list,\n  the implicit conversion sequence is a user-defined conversion sequence with the second standard conversion\n  sequence an identity conversion. If multiple constructors are viable but none is better than the others, the\n  implicit conversion sequence is the ambiguous conversion sequence. User-defined conversions are allowed\n  for conversion of the initializer list elements to the constructor parameter types except as noted in 13.3.3.1.</p>\n</blockquote>\n<p>For #1 to be viable, the following call must be valid:</p>\n<pre><code>A a = {0};\n</code></pre>\n<p>which is correct due to <a href=\"http://eel.is/c++draft/over.match.list#1.2\" rel=\"nofollow noreferrer\">[over.match.list]/p1</a>:</p>\n<blockquote>\n<p id=\"so_43672392_43720636_2\">\u2014 If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all the constructors of the class <code>T</code> and the argument list consists of the elements of the initializer list.</p>\n</blockquote>\n<p>i.e., class <code>A</code> has a constructor that accepts an <code>int</code> argument.</p>\n<p>For #2 to be a valid candidate, the following call must be valid:</p>\n<pre><code>const B&amp; b = {0};\n</code></pre>\n<p>which according to <a href=\"http://eel.is/c++draft/over.ics.ref#2\" rel=\"nofollow noreferrer\">[over.ics.ref]/p2</a>:</p>\n<blockquote>\n<p id=\"so_43672392_43720636_3\">When a parameter of reference type is not bound directly to an argument expression, the conversion sequence is the one required to convert the argument expression to the referenced type according to [over.best.ics]. Conceptually, this conversion sequence corresponds to copy-initializing a temporary of the referenced type with the argument expression. Any difference in top-level cv-qualification is subsumed by the initialization itself and does not constitute a conversion.</p>\n</blockquote>\n<p>translates to:</p>\n<pre><code>B b = {0};\n</code></pre>\n<p>Once again, following <a href=\"http://eel.is/c++draft/over.ics.list#6.2\" rel=\"nofollow noreferrer\">[over.ics.list]/p6</a>:</p>\n<blockquote>\n<p id=\"so_43672392_43720636_4\">User-defined conversions are allowed for conversion of the initializer list elements to the constructor parameter types [...]</p>\n</blockquote>\n<p>the compiler is allowed to use the user-defined conversion:</p>\n<pre><code>A(int);\n</code></pre>\n<p>to convert the argument <code>0</code> to <code>B</code>'s constructor parameter <code>A</code>.</p>\n<p>For candidate #3, the same reasoning applies as in #2. Eventually, the compiler cannot choose between the aforementioned implicit conversion sequences <sup>{citation needed}</sup>, and reports ambiguity.</p>\n", "LastActivityDate": "2017-05-01T14:20:19.647", "CommentCount": "2", "CreationDate": "2017-05-01T14:20:19.647", "ParentId": "43672392", "Score": "3", "OwnerUserId": "3953764"}, "43673537": {"Id": "43673537", "PostTypeId": "2", "Body": "<p>The code compiles fine with <a href=\"https://wandbox.org/permlink/HNRMJnjQ7eFGaAgB\" rel=\"nofollow noreferrer\">GCC8</a>.</p>\n<p>This shouldn't be ambiguous calling. For the copy/move constructor of <code>B</code> being invoked, then for <code>B b({0});</code> the following steps are required:</p>\n<ol>\n<li>construct <code>A</code> from <code>0</code> by <code>A::A(int)</code></li>\n<li>construct <code>B</code> from <code>A</code> constructed in step1 by <code>B::B(A)</code></li>\n<li>construct <code>b</code> from <code>B</code> constructed in step2 by copy/move constructor of <code>B</code>.</li>\n</ol>\n<p>That means two user-defined conversions (step#1 and #2) are required, but this is not allowed in one implicit convertion sequence.</p>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2017-04-28T08:43:45.117", "Score": "3", "CreationDate": "2017-04-28T06:35:45.130", "ParentId": "43672392", "CommentCount": "9", "OwnerUserId": "3309790", "LastEditDate": "2017-04-28T08:43:45.117"}});