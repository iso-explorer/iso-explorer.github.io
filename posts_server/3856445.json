post_cb({"3856445": {"CommentCount": "0", "AcceptedAnswerId": "3860676", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2010-10-04T15:00:43.517", "LastActivityDate": "2010-10-05T16:40:16.560", "LastEditDate": "2017-05-23T10:29:47.460", "ViewCount": "776", "FavoriteCount": "4", "Title": "Can someone explain rvalue references with respect to exceptions?", "Id": "3856445", "Score": "9", "Body": "<p>Lets say I've this exception class:</p>\n<pre><code>struct MyException : public std::exception\n{\n    MyException(const std::exception &amp;exc) : std::exception(exc)\n    {\n        cout &lt;&lt; \"lval\\n\";\n    }\n    MyException(std::exception &amp;&amp;exc) : std::exception(std::forward&lt;std::exception&gt;(exc))\n    {\n        cout &lt;&lt; \"rval\\n\";\n    }\n};\n\n...\n...\n\ntry\n{\n    throw std::exception(\"Oh no!\");\n    // above is rvalue since it's got no name, what if the throw is made as\n    // std::exception lvalExc(\"Oh wierd!\");\n    // throw lvalExc;\n    // if the throw is made thus, how can it be caught by catch(std::exception &amp;&amp;exc)?\n}\ncatch(std::exception &amp;&amp;rValRef)\n{\n    cout &lt;&lt; \"rValRef!\\n\";\n    throw MyException(std::forward&lt;std::exception&gt;(rValRef));\n}\n</code></pre>\n<p>When I tried to catch by value or by (<em>const</em>) lvalue ref. the compiler says these cases are already handled by the rvalue ref <code>catch</code> clause, which is understandable, as an exception is an <a href=\"https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues\">xvalue</a> and perhaps the best way to catch an xvalue is an rvalue ref (correct me if I'm wrong). But can someone explain about the <a href=\"http://thbecker.net/articles/rvalue_references/section_07.html\" rel=\"nofollow noreferrer\">perfect forwarding</a> in the above case of exception creation? Is it correct? Even though it compiles, is it meaningful or useful? Should the C++ library I use have a move constructor implemented for its <code>std::exception</code> for this kind of usage to be truly meaningful? I tried searching for articles and SO questions on rvalue references with respect to exceptions, couldn't find any.</p>\n", "Tags": "<c++><exception><c++11><forwarding><rvalue-reference>", "OwnerUserId": "183120", "AnswerCount": "1"}, "3860676": {"ParentId": "3856445", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Actually, exception handling has special rules with respect to lvalues and rvalues. The temporary exception object is an lvalue, see 15.1/3 of the current draft:</p>\n<blockquote>\n<p id=\"so_3856445_3860676_0\">A throw-expression initializes a temporary object, called the exception object, the type of which is determined by removing any top-level cv-qualifiers from the static type of the operand of throw and adjusting the type from \u201carray of T\u201d or \u201cfunction returning T\u201d to \u201cpointer to T\u201d or \u201cpointer to function returning T\u201d, respectively. <strong>The temporary is an lvalue</strong> and is used to initialize the variable named in the matching handler (15.3). If the type of the exception object would be an incomplete type or a pointer to an incomplete type other than (possibly cv-qualified) void the program is ill-formed. Except for these restrictions and the restrictions on type matching mentioned in 15.3, the operand of throw is treated exactly as a function argument in a call (5.2.2) or the operand of a return statement.</p>\n</blockquote>\n<p>And catching by rvalue reference is illegal, too, see 15.3/1:</p>\n<blockquote>\n<p id=\"so_3856445_3860676_1\">The exception-declaration in a handler describes the type(s) of exceptions that can cause that handler to be entered. <strong>The exception-declaration shall not denote an incomplete type or an rvalue reference type</strong>. The exception-declaration shall not denote a pointer or reference to an incomplete type, other than void*, const void*, volatile void*, or const volatile void*.</p>\n</blockquote>\n<p>Also, you don't seem to understand perfect forwarding. Your forward invocation is no better than a move. The idea of perfect forwarding is to encode the value category of the argument as part of the type and let template argument deduction figure it out. But your exception handler is not and cannot be a function template.</p>\n<p>Basically, perfect forwarding relies on template argument deduction and rvalue references:</p>\n<pre><code>void inner(const int&amp;);  // #1 takes only lvalues or const rvalues\nvoid inner(int&amp;&amp;);       // #2 takes non-const rvalues only\n\ntemplate&lt;class T&gt;\nvoid outer(T &amp;&amp; x) {\n    inner(forward&lt;T&gt;(x));\n}\n\nint main() {\n   int k = 23;\n   outer(k);   // outer&lt;T=int&amp;&gt; --&gt; forward&lt;int&amp;&gt; --&gt; #1\n   outer(k+2); // outer&lt;T=int&gt;  --&gt; forward&lt;int&gt;  --&gt; #2\n}\n</code></pre>\n<p>Depending on the value category of the argument, template argumend deduction deduces T to be either an lvalue reference or a normal value type. Due to reference collapsing, T&amp;&amp; is also an <em>lvalue</em> reference in the first case, or an <em>rvalue</em> reference in the second case. If you see T&amp;&amp; and T is a template parameter which can be deduced, it's basically a \"catch everything\". std::forward restores the original value category (encoded in T) so we can perfectly forward the argument to the overloaded inner functions and select the correct one. But this only works because outer is a template and because there are special rules for determining T with respect to its value category. If you use an rvalue references without templates/template argument deduction (like in #2), the function will only accept rvalues.</p>\n", "OwnerUserId": "172531", "LastEditorUserId": "172531", "LastEditDate": "2010-10-05T16:40:16.560", "Id": "3860676", "Score": "7", "CreationDate": "2010-10-05T03:34:42.130", "LastActivityDate": "2010-10-05T16:40:16.560"}, "bq_ids": {"n4140": {"so_3856445_3860676_1": {"section_id": 3346, "quality": 0.8571428571428571, "length": 30}}, "n3337": {"so_3856445_3860676_1": {"section_id": 3216, "quality": 0.8571428571428571, "length": 30}, "so_3856445_3860676_0": {"section_id": 3206, "quality": 0.9117647058823529, "length": 62}}, "n4659": {"so_3856445_3860676_1": {"section_id": 4113, "quality": 0.9142857142857143, "length": 32}}}});