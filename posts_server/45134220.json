post_cb({"45134220": {"ViewCount": "82", "Body": "<p>How to convert a pointer of type <code>void(*)()</code> to <code>void *</code>?</p>\n<p>is any of the following operators can be used to do so?</p>\n<ul>\n<li><code>const_cast</code></li>\n<li><code>static_cast</code></li>\n<li><code>dynamic_cast</code></li>\n<li><code>reinterpret_cast</code></li>\n</ul>\n<p>Example: all of the following are compiled (<em>tried in Visual Studio 2017</em>), I wonder if they all have the same result after converting.</p>\n<pre><code>void operation(void(*callback)()) {\n\n    void* test1 = callback;\n    void* test2 = static_cast&lt;void*&gt;(callback);\n    void* test3 = reinterpret_cast&lt;void*&gt;(callback);\n}\n</code></pre>\n", "AcceptedAnswerId": "45134428", "Title": "How to convert a pointer of type void(*)() to void*", "CreationDate": "2017-07-16T23:30:36.270", "Id": "45134220", "CommentCount": "8", "LastEditDate": "2017-07-16T23:59:11.960", "PostTypeId": "1", "LastEditorUserId": "4505446", "LastActivityDate": "2017-07-17T00:19:11.673", "Score": "2", "OwnerUserId": "4505446", "Tags": "<c++>", "AnswerCount": "2"}, "45134253": {"Id": "45134253", "PostTypeId": "2", "Body": "<p>In Standard C++, since C++11, it is <em>conditionally-supported</em>, which means that an implementation may or may not support it, and must document whether it is supported.</p>\n<p>For implementations that do support this cast, the appropriate cast operator to use is <code>reinterpret_cast</code>. The details can be found in the C++14 standard [expr.reinterpret.cast]/8.  </p>\n<p>It's an error to try and convert a function pointer to an object pointer with no cast ([conv.ptr]), or with <code>static_cast</code> ([expr.static.cast]/5).  If your compiler permits this in standard mode and doesn't issue a diagnostic then the compiler is non-conforming. </p>\n", "LastEditorUserId": "1505939", "LastActivityDate": "2017-07-17T00:19:11.673", "Score": "3", "CreationDate": "2017-07-16T23:38:11.883", "ParentId": "45134220", "CommentCount": "8", "LastEditDate": "2017-07-17T00:19:11.673", "OwnerUserId": "1505939"}, "bq_ids": {"n4140": {"so_45134220_45134428_1": {"length": 32, "quality": 0.9411764705882353, "section_id": 6047}, "so_45134220_45134428_0": {"length": 13, "quality": 1.0, "section_id": 6031}}, "n3337": {"so_45134220_45134428_1": {"length": 32, "quality": 0.9411764705882353, "section_id": 5815}, "so_45134220_45134428_0": {"length": 13, "quality": 1.0, "section_id": 5799}}, "n4659": {"so_45134220_45134428_1": {"length": 32, "quality": 0.9411764705882353, "section_id": 7546}, "so_45134220_45134428_0": {"length": 13, "quality": 1.0, "section_id": 7530}}}, "45134428": {"Id": "45134428", "PostTypeId": "2", "Body": "<p>In ISO standard C++, there is no implicit conversion from any function pointer type to any object pointer type.  So this line is ill-formed.</p>\n<pre><code>void* test1 = callback;\n</code></pre>\n<p>For the compiler to accept this without a diagnostic is a bug<sup>1</sup> (you do have warnings enabled, correct?)</p>\n<p><code>static_cast</code> between any object pointer type and a function pointer type (either direction) is prohibited in standard C++.  The controlling rule is found in 5.2.9:</p>\n<blockquote>\n<p id=\"so_45134220_45134428_0\">Otherwise, the <code>static_cast</code> shall perform one of the conversions listed below. No other conversion shall be performed explicitly using a <code>static_cast</code>.</p>\n</blockquote>\n<p>Since none of the rules above or below discuss function pointer casts, this forbids the line</p>\n<pre><code>void* test2 = static_cast&lt;void*&gt;(callback);\n</code></pre>\n<p>However, this is not necessarily a separate compiler bug, because one of the rules does permit <code>static_cast</code> to be used to accomplish any implicit conversion.</p>\n<p>The final line is the only correct one:</p>\n<pre><code>void* test3 = reinterpret_cast&lt;void*&gt;(callback);\n</code></pre>\n<p>The controlling rule is provided in the specification for <code>reinterpret_cast</code> (5.2.10)</p>\n<blockquote>\n<p id=\"so_45134220_45134428_1\">Converting a function pointer to an object pointer type or vice versa is conditionally-supported. The meaning of such a conversion is implementation-defined, except that if an implementation supports conversions in both directions, converting a prvalue of one type to the other type and back, possibly with different cv-qualification, shall yield the original pointer value.</p>\n</blockquote>\n<hr>\n<p><sup>1</sup> When standard-compliant mode is enabled using <code>/Za</code>, the Microsoft C++ compilers do correctly reject the copy-initialization and <code>static_cast</code> attempts:</p>\n<blockquote>\n<p id=\"so_45134220_45134428_2\">source_file.cpp(8): error C2440: 'initializing': cannot convert from <code>void (*)(void)</code> to <code>void *</code></p>\n<p id=\"so_45134220_45134428_3\">source_file.cpp(8): note: Types pointed to are unrelated; conversion requires reinterpret_cast, C-style cast\n  or function-style cast</p>\n<p id=\"so_45134220_45134428_4\">source_file.cpp(9): error C2440: <code>static_cast</code>:\n  cannot convert from <code>void (*)(void)</code> to <code>void *</code></p>\n<p id=\"so_45134220_45134428_5\">source_file.cpp(9):\n  note: Types pointed to are unrelated; conversion requires\n  reinterpret_cast, C-style cast or function-style cast</p>\n</blockquote>\n</hr>", "LastEditorUserId": "103167", "LastActivityDate": "2017-07-17T00:16:55.660", "Score": "4", "CreationDate": "2017-07-17T00:11:01.510", "ParentId": "45134220", "CommentCount": "0", "LastEditDate": "2017-07-17T00:16:55.660", "OwnerUserId": "103167"}});