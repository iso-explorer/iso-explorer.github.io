post_cb({"18405725": {"ParentId": "18405501", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Yes, a copy constructor  is what it is -- a copy constructor.  Which isn't a conversion constructor that <em>converts</em> from one type to a different type.</p>\n", "OwnerUserId": "1312406", "LastEditorUserId": "1312406", "LastEditDate": "2013-08-23T14:56:42.803", "Id": "18405725", "Score": "0", "CreationDate": "2013-08-23T14:46:54.727", "LastActivityDate": "2013-08-23T14:56:42.803"}, "18405796": {"ParentId": "18405501", "CommentCount": "1", "Body": "<p>Quoting the Standard:</p>\n<p>[class.conv.ctor]/3</p>\n<blockquote>\n<p id=\"so_18405501_18405796_0\"><strong>A non-explicit copy-constructor (12.8) is a converting constructor</strong>. An implicitly-declared copy constructor is not an explicit constructor; it may be called for implicit type conversions.</p>\n</blockquote>\n<p>So yes, a copy-ctor is a converting ctor.</p>\n<p>Also note [conv]/1 which specifies and points out in a remark:</p>\n<blockquote>\n<p id=\"so_18405501_18405796_1\">Note: a standard conversion sequence can be empty, i.e., it can consist of no conversions.</p>\n</blockquote>\n<p>and in /3:</p>\n<blockquote>\n<p id=\"so_18405501_18405796_2\">An expression <code>e</code> can be implicitly converted to a type <code>T</code> if and only if the declaration <code>T t=e;</code> is well-formed</p>\n</blockquote>\n<p>So the set of implicit conversions contain the empty conversions.</p>\n", "OwnerUserId": "420683", "PostTypeId": "2", "Id": "18405796", "Score": "10", "CreationDate": "2013-08-23T14:49:26.873", "LastActivityDate": "2013-08-23T14:49:26.873"}, "bq_ids": {"n4140": {"so_18405501_18405796_0": {"section_id": 390, "quality": 0.8, "length": 12}, "so_18405501_18405796_1": {"section_id": 0, "quality": 0.875, "length": 7}, "so_18405501_18405796_2": {"section_id": 2, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_18405501_18405796_0": {"section_id": 381, "quality": 0.8, "length": 12}, "so_18405501_18405796_1": {"section_id": 0, "quality": 0.875, "length": 7}, "so_18405501_18405796_2": {"section_id": 2, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_18405501_18405796_0": {"section_id": 407, "quality": 0.8, "length": 12}, "so_18405501_18405501_0": {"section_id": 616, "quality": 0.6, "length": 6}, "so_18405501_18405796_1": {"section_id": 0, "quality": 0.875, "length": 7}, "so_18405501_18405796_2": {"section_id": 2, "quality": 0.8571428571428571, "length": 6}}}, "18405501": {"CommentCount": "12", "ViewCount": "273", "CreationDate": "2013-08-23T14:35:35.237", "LastActivityDate": "2013-08-23T14:56:42.803", "Title": "Confused between a copy constructor and a converting constructor", "PostTypeId": "1", "Id": "18405501", "Score": "5", "Body": "<p>Since I have doubts about this question (for C++03) I am posting it here.I just read about conversion constructors and it states that </p>\n<blockquote>\n<p id=\"so_18405501_18405501_0\">\"To be a converting constructor, constructor must have single\n  argument and be declared without keyword explicit.\"</p>\n</blockquote>\n<p>Now my question is whether the copy constructor can be called a conversion constructor provided it is not explicitly declared ? Does it qualify to be one ?\nI believe it cant be called a conversion constructor because it only accepts the same type parameter ths resulting in no conversion. For Instance </p>\n<pre><code>foo a;\nfoo b;\na = 100; //a Conversion constructor would be called (i.e) foo(int a){...}\na = b ;  //Since both objects are same type and have been initialized the assignment operator will be called (if there is an overloaded version otherwise the default will be called)\n</code></pre>\n<p>Is my understanding correct ?</p>\n", "Tags": "<c++><constructor>", "OwnerUserId": "1305891", "AnswerCount": "2"}});