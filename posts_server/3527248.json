post_cb({"3527595": {"Id": "3527595", "PostTypeId": "2", "Body": "<p>Might want to point out that following declaration is <strong>NOT</strong> copy constructor.</p>\n<pre><code>template &lt; typename T &gt;\n  derived(T const&amp; x, typename boost::disable_if&lt; is_derived&lt;T&gt; &gt;::type * = 0) : T1(0), T2(x) {}\n</code></pre>\n<p>a copy constructor for <code>derived&lt;base, another_base&gt;</code> should take <code>const derived&lt;base, another_base&gt;&amp;</code> as input, not arbitrary <code>const derived&lt;X,Y&gt;&amp;</code></p>\n<p><br/></p>\n<blockquote>\n<p id=\"so_3527248_3527595_0\">A copy constructor has as its first\n  parameter a (possibly const or\n  volatile) reference to its own class\n  type. It can have more arguments, but\n  the rest must have default values\n  associated with them.</p>\n</blockquote>\n<p><a href=\"http://en.wikipedia.org/wiki/Copy_constructor\" rel=\"nofollow noreferrer\">http://en.wikipedia.org/wiki/Copy_constructor</a></p>\n", "LastActivityDate": "2010-08-20T01:34:34.937", "CommentCount": "1", "CreationDate": "2010-08-20T01:34:34.937", "ParentId": "3527248", "Score": "3", "OwnerUserId": "217571"}, "bq_ids": {"n4140": {"so_3527248_3527705_1": {"length": 8, "quality": 0.6153846153846154, "section_id": 466}, "so_3527248_3527662_1": {"length": 26, "quality": 0.7428571428571429, "section_id": 455}, "so_3527248_3527662_0": {"length": 24, "quality": 1.0, "section_id": 451}}, "n3337": {"so_3527248_3527705_1": {"length": 8, "quality": 0.6153846153846154, "section_id": 457}, "so_3527248_3527662_1": {"length": 26, "quality": 0.7428571428571429, "section_id": 446}, "so_3527248_3527662_0": {"length": 24, "quality": 1.0, "section_id": 442}}, "n4659": {"so_3527248_3527705_1": {"length": 8, "quality": 0.6153846153846154, "section_id": 489}, "so_3527248_3527662_1": {"length": 26, "quality": 0.7428571428571429, "section_id": 478}, "so_3527248_3527662_0": {"length": 24, "quality": 1.0, "section_id": 474}}}, "3527662": {"Id": "3527662", "PostTypeId": "2", "Body": "<p>I'm pretty sure the answer to your question is \"never\".</p>\n<p>Section 12.8.2 of the ANSI C++ Standard says</p>\n<blockquote>\n<p id=\"so_3527248_3527662_0\">A non-template constructor for class X\n  is a <em>copy</em> constructor if its first\n  parameter is of type X&amp;, const X&amp;,\n  volatile X&amp; or const volatile X&amp;, and\n  either there are no other parameters\n  or else all other parameters have\n  default arguments.</p>\n</blockquote>\n<p>Section 12.8.3 says</p>\n<blockquote>\n<p id=\"so_3527248_3527662_1\">A declaration of a constructor for a\n  class X is ill-formed if its first\n  parameter is of type (optionally\n  cv-qualified) X and either there are\n  no other parameters or else all other\n  parameters have default arguments. A\n  member function template is never\n  instantiated to perform the copy of a\n  class object to an object of its class\n  type. [Example:</p>\n</blockquote>\n<pre><code>struct S { \n    template &lt;typename T&gt; S(T);\n};\n\nS f();\n\nvoid g() {\n    S a( f() ); // does not instantiate member template\n}\n</code></pre>\n<blockquote>\n<p id=\"so_3527248_3527662_2\">-- end example]</p>\n</blockquote>\n", "LastActivityDate": "2010-08-20T01:54:50.660", "CommentCount": "0", "CreationDate": "2010-08-20T01:54:50.660", "ParentId": "3527248", "Score": "3", "OwnerUserId": "4928"}, "3527248": {"ViewCount": "557", "Body": "<p>I was pretty sure that the answer to that question was, \"Never, ever can a template be the copy constructor.\"</p>\n<p>Unfortunately, I just spent 3 hours figuring out why I was getting a warning about recursion, tracked it to the copy constructor, watched the debugger go insane and not let me look at the recursive code, and finally tracked it down to a missing '&amp;' in a base constructor.</p>\n<p>You see, I have this complex policy-based design host that's been working fine for a while now.  I went about overriding two policies in one and ran into a recursive copy constructor.  Narrowed it down to one policy that is required to provide a constructor that can take a type of XXX concept as its argument, but in this case I'm just discarding it.  So I wrote</p>\n<pre><code>struct my_policy\n{\n  template &lt; typename T &gt;\n  my_polity(T const) {} // missing '&amp;'...oops\n};\n</code></pre>\n<p>Now, my_policy is a base class to the host (of course) and this little typo caused recursion where the host's copy constructor passed itself up the chain to this, templated constructor rather than an implicit, compiler generated copy constructor.  It would then of course call its copy constructor again to create the temporary.</p>\n<p>The truly fascinating thing is that I can't recreate this in simplified code.  Even with a sort of mock policy host example I can't make it happen.  The following code does not exhibit the issue:</p>\n<pre><code>#include &lt;boost/utility/enable_if.hpp&gt;\n#include &lt;boost/mpl/bool.hpp&gt;\n\nstruct base\n{\n  template &lt; typename T &gt;\n  base(T const) {}\n};\n\nstruct another_base \n{\n  int x;\n\n  another_base(int y) : x(y) {}\n};\n\ntemplate &lt; typename T &gt;\nstruct is_derived : boost::mpl::false_ {};\n\ntemplate &lt; typename T1, typename T2 &gt;\nstruct derived : T1, T2\n{\n  template &lt; typename T &gt;\n  derived(T const&amp; x, typename boost::disable_if&lt; is_derived&lt;T&gt; &gt;::type * = 0) : T1(0), T2(x) {}\n};\n\ntemplate &lt; typename T1, typename T2 &gt;\nstruct is_derived&lt;derived&lt;T1,T2&gt;&gt; : boost::mpl::true_ {};\n\nint main() \n{\n  derived&lt;base, another_base&gt; d(23);\n  derived&lt;base, another_base&gt; x = d;\n}\n</code></pre>\n<p>I am using boost's parameter library to make the 7 or so arguments to the host accessible by \"name\".  Maybe that's the issue, I don't know.  At any rate, I'm wondering if someone out there knows what specific conditions, if any, could cause a compiler to legitimately use the templated constructor for \"base\" as a copy constructor or from the implicit copy constructor for \"derived\".</p>\n<p><b>Edit note: </b></p>\n<p>I recreated the problem in the above code by giving \"another_base\" an explicit copy constructor:</p>\n<pre><code>struct another_base \n{\n  int x;\n\n  another_base(another_base const&amp; b) : x(b.x) {}\n\n  another_base(int y) : x(y) {}\n};\n</code></pre>\n<p>Starting to conclude that this is a compiler bug unless someone can tell me why this is legitimate.</p>\n<p><b>More information:</b></p>\n<pre><code>struct derived;\n\nstruct base\n{\n  base() {}\n\nprivate:\n  base(derived const&amp;);\n};\n\nstruct base2 \n{\n  base2() {}\n  //base2 (base2 const&amp;) {}\n};\n\nstruct derived : base, base2 {};\n\nint main()\n{\n  derived d1; derived d2(d1);\n}\n</code></pre>\n<p>Looking more at Schaub's answer I took the above code and compiled it.  It compiles just fine until you uncomment base2's copy constructor declaration.  Then it will blow up in the way I'm assuming was expected with the original code (no access to private constructor in base).  So templates aren't even part of the issue; you can recreate the problem without them.  Looks like it's an MI issue, which VS has always been a little slow at getting right.</p>\n<p>I've changed the tags to reflect this finding.</p>\n<p><b>Posted to MS's bug repository</b></p>\n<p><a href=\"http://connect.microsoft.com/VisualStudio/feedback/details/587787/implicit-copy-constructor-calls-base-with-derived-type-under-specific-conditions\" rel=\"nofollow noreferrer\">http://connect.microsoft.com/VisualStudio/feedback/details/587787/implicit-copy-constructor-calls-base-with-derived-type-under-specific-conditions</a></p>\n<p>I included a work around in the example code.</p>\n", "AcceptedAnswerId": "3527662", "Title": "MI and implicit copy constructor bug (was: Under what conditions can a template be the copy constructor?)", "CreationDate": "2010-08-20T00:02:18.287", "Id": "3527248", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2010-08-27T16:01:58.963", "LastEditorUserId": "301883", "LastActivityDate": "2010-08-27T16:01:58.963", "Score": "4", "OwnerUserId": "301883", "Tags": "<c++><multiple-inheritance>", "AnswerCount": "3"}, "3527705": {"Id": "3527705", "PostTypeId": "2", "Body": "<p>With Visual C++, there is an issue with derived to base delegation of the copy constructor argument:</p>\n<pre><code>struct Derived;\n\nstruct Base {\n  Base(){ }\n\nprivate:\n  Base(Derived const&amp;);\n};\n\nstruct Derived : Base { };\n\nDerived d1;\nDerived d2(d1);\n</code></pre>\n<p>This code is valid, but Visual C++ fails to compile it, because they call the base-class copy constructor using a <code>Derived</code> object. The Standard however require the compiler to pass a <code>Base const</code> (or <code>Base</code> in some cases) down to the base class. </p>\n<p>This is the first part of your puzzle: The template is a better match, because the copy constructor would need a derived to base conversion, but your template accepts the derived class directly, and then would need another copy, and so on and so on. Notice that the template will <em>not</em> act as a copy constructor here (given the VC++ bug), just as the above declaration of <code>Base(Derived const&amp;)</code> did not declare a copy constructor. </p>\n<p>The second part is the answer to your other question: The Standard was ambiguous and not clear in C++03 as to whether instantiated templates could act as copy constructors or not. In a note, it says</p>\n<blockquote>\n<p id=\"so_3527248_3527705_0\">Because a template constructor is never a copy constructor, the presence of such a template does not suppress the implicit declaration of a copy constructor. Template constructors participate in overload resolution with other constructors, including copy constructors, and a template constructor may be used to copy an object if it provides a better match than other constructors.</p>\n</blockquote>\n<p>but a few paragraphs below that, it says</p>\n<blockquote>\n<p id=\"so_3527248_3527705_1\">A member function template is never instantiated to perform the copy of a class object to an object of its class type. </p>\n</blockquote>\n<p>Because of the context that this text appears on (forbidding by-value parameter copy constructors) one may argue that this is not forbiding an instantiation of a by-reference copy constructor from a template. But such arguing is moot, facing this vague wording. </p>\n<p>The C++0x FCD clearified it, and removed the weird note. It now is clear that templates are never instantiated to perform a copy, no matter whether it would yield to by-reference or by-value parameters. But as explained above, if you happen to use VC++ by any chance, and it exhibits that behavior, then it has nothing to do with copy constructors. </p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2010-08-20T02:27:45.893", "Score": "5", "CreationDate": "2010-08-20T02:12:26.647", "ParentId": "3527248", "CommentCount": "4", "OwnerUserId": "34509", "LastEditDate": "2010-08-20T02:27:45.893"}});