post_cb({"bq_ids": {"n4140": {"so_4985800_4985978_0": {"length": 16, "quality": 0.64, "section_id": 382}}, "n3337": {"so_4985800_4985978_0": {"length": 16, "quality": 0.64, "section_id": 373}}, "n4659": {"so_4985800_4985978_0": {"length": 16, "quality": 0.64, "section_id": 397}}}, "4985800": {"ViewCount": "852", "Body": "<p>In <a href=\"https://stackoverflow.com/questions/2552839/which-c-standard-library-wrapper-functions-do-you-use/2553109#2553109\">GMan's answer here</a>, the destructor of the <code>restore_base</code> class isn't <code>virtual</code>, so I keep wondering how exactly that works. Normally you'd expect the destructor of <code>restorer_base</code> to be executed only, after the object goes out of scope, but it seems that the derived <code>restorer_holder</code> destructor is really called. Anyone care to enlighten me?</p>\n", "AcceptedAnswerId": "4985978", "Title": "Why is the derived class's destructor invoked on a const reference to the base class?", "CreationDate": "2011-02-13T17:49:45.517", "Id": "4985800", "CommentCount": "7", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:34:36.100", "LastEditorUserId": "-1", "LastActivityDate": "2015-05-05T17:33:15.317", "Score": "8", "OwnerUserId": "500104", "Tags": "<c++><inheritance><reference>", "AnswerCount": "1"}, "4985978": {"Id": "4985978", "PostTypeId": "2", "Body": "<p>The standard case where you need a virtual destructor is</p>\n<pre><code>void foo()\n{\n   scoped_ptr&lt;Base&gt; obj = factory_returns_a_Derived();\n\n   // ... use 'obj' here ...\n}\n</code></pre>\n<p>And the standard case where you <em>don't</em> is</p>\n<pre><code>void foo()\n{\n   Derived obj;\n\n   // ... use 'obj' here ...\n}\n</code></pre>\n<p>GMan's code is doing something a little trickier, that turns out to be equivalent to the second case:</p>\n<pre><code>void foo()\n{\n   Base&amp; obj = Derived();\n\n   // ... use 'obj' here ...\n}\n</code></pre>\n<p><code>obj</code> is a bare reference; normally, it would not trigger destructors at all.  But it's initialized from an anonymous temporary object whose static type -- known to the compiler -- is <code>Derived</code>.  When <em>that object</em>'s lifetime ends, the compiler will call the <code>Derived</code> destructor.  Normally an anonymous temporary object dies at the end of the <em>expression</em> that created it, but there's a special case for temporaries initializing a reference: they live till the reference itself dies, which here is the end of the scope.  So you get pseudo-<code>scoped_ptr</code> behavior and you don't need a virtual destructor.</p>\n<p><strong>EDIT:</strong> Since this has now come up twice: The reference <strong>does not</strong> have to be <code>const</code> for this special rule to apply.  C+98 [class.temporary]/5:</p>\n<blockquote>\n<p id=\"so_4985800_4985978_0\">The second context [in which a temporary object is not destroyed at the end of the\n  full-expression] is when <em>a reference</em> is bound to a temporary.  The temporary to which\n  the reference is bound or the temporary that is the complete object to a subobject of\n  which the temporary is bound persists <em>for the lifetime of the reference</em> ...</p>\n</blockquote>\n<p>Emphasis mine. There is no mention of <code>const</code> in this language, so the reference does not have to be <code>const</code>.</p>\n<p><strong>EDIT 2:</strong> Other rules in the standard prohibit creation of non-const references to temporary objects that are not lvalues. I suspect that at least some temporary objects <em>are</em> lvalues, but I don't know for certain.  Regardless, <em>that does not affect this rule</em>.  It would still be formally true that non-const references to temporary objects prolong their lifetime <em>even if</em> no strictly conforming C++ program could ever create such a reference.  This might seem ridiculous, but you're <em>supposed</em> to read standardese this literally and pedantically.  Every word counts, every word that isn't there counts.</p>\n", "LastEditorUserId": "388520", "LastActivityDate": "2015-05-05T17:33:15.317", "Score": "18", "CreationDate": "2011-02-13T18:25:30.093", "ParentId": "4985800", "CommentCount": "7", "OwnerUserId": "388520", "LastEditDate": "2015-05-05T17:33:15.317"}});