post_cb({"25890042": {"CommentCount": "5", "ViewCount": "117", "PostTypeId": "1", "LastEditorUserId": "2760487", "CreationDate": "2014-09-17T12:01:20.223", "LastActivityDate": "2014-09-17T12:19:12.683", "Title": "C++: Compiler instantiate template function only on demand?", "AcceptedAnswerId": "25890231", "LastEditDate": "2014-09-17T12:09:44.067", "Id": "25890042", "Score": "2", "Body": "<p>Consider the following simple template function:  </p>\n<pre><code>template &lt;typename T&gt;\nint compare(const T&amp; lhs, const T&amp; rhs) {\n    if (lhs&lt;rhs) {\n        return -1;\n    }\n    else if (rhs&lt;lhs) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\n</code></pre>\n<p>My course lecturer explained that when we use a template function, we should specify, either implicitly or explicitly, the template argument to bind to the template parameter:  </p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing std::cout;\nusing std::endl;\nusing std::string;\n\nint main() {\n    // implicitly specifying that T is int\n    cout&lt;&lt;compare(2,3)&lt;&lt;endl;\n\n    // explicitly specifying that T is string\n    cout&lt;&lt;compare&lt;string&gt;(string(\"something\"),string(\"another\"))&lt;&lt;endl;\n}\n</code></pre>\n<p>This process of deducing the right template is called \"instantiation\"; the actual template argument is used to generate a specific instance (in this case - a function) of the appropriate version to be run later at runtime.<br>\nHe also mentioned that the instantiation happens \"on demand\"; for example, the last code segment will produce two instances of the compare function, one for <code>int</code> and one for <code>string</code>.<br>\nThis made me wonder, why would the compiler complain about something like this:  </br></br></p>\n<pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\nusing std::cout;\nusing std::endl;\nusing std::string;\n\n\ntemplate &lt;typename T&gt;\nint compare(const T&amp; lhs, const T&amp; rhs) {\n    if (lhs&lt;rhs) {\n        return x; // deliberate compile-time error; x cannot be resolved\n    }\n    else if (rhs&lt;lhs) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\n\nint main() {\n    // no calls for compare are made here\n}\n</code></pre>\n<p>You'd think that the compiler shouldn't have any problem with the above compile-time error, since compare never gets instantiated. However, this will not compile...<br>\nSince no template argument was provided, this template function allegedly doesn't make any sense to the compiler (this is a simple compare function, but think about a template function that lies heavily on the template arguments' types...)<br>\nSo what exactly is \"instantiation\" then?</br></br></p>\n", "Tags": "<c++><templates>", "OwnerUserId": "2760487", "AnswerCount": "2"}, "25890231": {"ParentId": "25890042", "CommentCount": "2", "Body": "<p>When the compiler sees your template, it already parses and analyses it <em>to some degree</em>. What exactly is already done is quite complicated, but among other things, (template parameter independent) <strong>name lookup</strong> takes place. This means the compiler already tries to figure out what <code>x</code> is, and he fails.</p>\n<p>An example what the compiler does <em>not</em> try to resolve is what exactly <code>T::x</code> is, because it <strong>depends</strong> on <code>T</code>, your template parameter. The expression <code>x</code> <em>does not depend</em> on any template parameter, that's basically the key difference why <code>x</code> fails to compile and <code>T::x</code> <a href=\"http://ideone.com/4XV7s6\" rel=\"noreferrer\">will succeed</a>:</p>\n<pre><code>template &lt;typename T&gt;\nint compare(const T&amp; lhs, const T&amp; rhs) {\n    if (lhs&lt;rhs) {\n        return T::x;\n    }\n    else if (rhs&lt;lhs) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\n</code></pre>\n<p>Of course, with most types <code>T</code> this will fail to <em>be instantiated</em>, but that's not the key here. You can even write a template for which the instantiation fails for all <code>T</code>, but that's out of scope for an answer to this question.</p>\n", "OwnerUserId": "592323", "PostTypeId": "2", "Id": "25890231", "Score": "5", "CreationDate": "2014-09-17T12:10:26.503", "LastActivityDate": "2014-09-17T12:10:26.503"}, "bq_ids": {"n4140": {"so_25890042_25890408_0": {"section_id": 177, "quality": 0.9655172413793104, "length": 28}}, "n3337": {"so_25890042_25890408_0": {"section_id": 171, "quality": 0.9655172413793104, "length": 28}}, "n4659": {"so_25890042_25890408_0": {"section_id": 182, "quality": 0.9655172413793104, "length": 28}}}, "25890408": {"ParentId": "25890042", "CommentCount": "0", "Body": "<p>\u00a7 14.6 [temp.res]/p10, emphasis added:</p>\n<blockquote>\n<p id=\"so_25890042_25890408_0\">If a name does not depend on a <em>template-parameter</em> (as defined in\n  14.6.2), <strong>a declaration (or set of declarations) for that name shall be in scope at the point where the name appears in the template\n  definition</strong>; the name is bound to the declaration (or declarations)\n  found at that point and this binding is not affected by declarations\n  that are visible at the point of instantiation.</p>\n</blockquote>\n<p>Unlike the general rule that a template is ill-formed if no valid specialization can be generated for it, violation of this rule requires a diagnostic (since it has no \"no diagnostic required\").</p>\n<p>In your code, <code>x</code> is a non-dependent name, so the <code>compare</code> template violates this rule, and a conforming implementation is required to generate a diagnostic.</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "25890408", "Score": "1", "CreationDate": "2014-09-17T12:19:12.683", "LastActivityDate": "2014-09-17T12:19:12.683"}});