post_cb({"32920229": {"CommentCount": "2", "CreationDate": "2015-10-03T07:51:19.557", "PostTypeId": "1", "AcceptedAnswerId": "32926471", "LastEditorUserId": "1362568", "LastActivityDate": "2015-11-16T04:43:29.330", "LastEditDate": "2015-10-04T18:06:27.800", "ViewCount": "221", "FavoriteCount": "3", "Title": "Using argc in a constexpr, is it strictly required that any sub-expression involved be a constant expression?", "Id": "32920229", "Score": "7", "Body": "<p>Example:</p>\n<pre><code>int main(int argc, char**)\n{\n    constexpr int a = argc * 0;\n    (void)a;\n    constexpr int b = argc - argc;\n    (void)b;\n    return 0;\n}\n</code></pre>\n<p><code>argc</code> is not a constant expression, but the compiler is still able to compute the results of <code>a</code> and <code>b</code> in compile time (i.e. <code>0</code>) in both cases.</p>\n<p><a href=\"http://melpon.org/wandbox/permlink/Q0CpJqBPuPiT5nTa\" rel=\"nofollow\">g++</a> accepts the code above, while <a href=\"http://melpon.org/wandbox/permlink/Y3kelmH0N6fyuw6Y\" rel=\"nofollow\">clang</a> and MSVC14 reject it.</p>\n<p>Does the standard allows the compiler being as smart as g++ with regard to <code>constexpr</code>?</p>\n", "Tags": "<c++><c++11><gcc><language-lawyer><constexpr>", "OwnerUserId": "2969631", "AnswerCount": "2"}, "32926471": {"ParentId": "32920229", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Neither <code>argc * 0</code> nor <code>argc - argc</code> are constant expressions, the lvalue-to-rvalue conversion is allowed in certain cases none of them apply here. If we look at the draft C++11 standard section <code>5.19</code> [expr.const] it lays out the exceptions. It says:</p>\n<blockquote>\n<p id=\"so_32920229_32926471_0\">A conditional-expression is a core constant expression unless it involves one of the following as a potentially\n  evaluated subexpression [...]</p>\n</blockquote>\n<p>and has several bullets including the following on lvalue-to-rvalue conversion:</p>\n<blockquote>\n<p id=\"so_32920229_32926471_1\">an lvalue-to-rvalue conversion (4.1) unless it is applied to</p>\n<ul>\n<li><p id=\"so_32920229_32926471_2\">a glvalue of integral or enumeration type that refers to a non-volatile const object with a preceding\n  initialization, initialized with a constant expression, or</p></li>\n<li><p id=\"so_32920229_32926471_3\">a glvalue of literal type that refers to a non-volatile object defined with constexpr, or that refers\n  to a sub-object of such an object, or</p></li>\n<li><p id=\"so_32920229_32926471_4\">a glvalue of literal type that refers to a non-volatile temporary object whose lifetime has not\n  ended, initialized with a constant expression;</p></li>\n</ul>\n</blockquote>\n<p>It is interesting to note that gcc does not accept the following code (<em><a href=\"http://melpon.org/wandbox/permlink/96yJb9xdM83Iujls\" rel=\"nofollow noreferrer\">see it live</a></em>):</p>\n<pre><code>constexpr int a = argc * 2;\n</code></pre>\n<p>So it looks like gcc is saying I know the result will be zero and therefore it performs constant folding and it does not need to perform the lvalue-to-rvalue conversion of <code>argc</code> to determine the result.</p>\n<p>Unfortunately I don't see any provisions in section <code>5.19</code> that allows this kind of short-circuiting. This looks very similar to case in <a href=\"https://stackoverflow.com/q/31526278/1708801\">int a=1, is a || 1 a constant expression?</a> which has a bug report but no one from the gcc team has replied to that one. I added a <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=55986#c5\" rel=\"nofollow noreferrer\">comment</a> to that bug report indicating this seems related.</p>\n<p>Mark's comment below indicates this is a bug:</p>\n<blockquote>\n<p id=\"so_32920229_32926471_5\">There is a whole c++-delayed-folding branch on which some gcc developers are working, which will delay a number of optimizations and might fix this. It is important for other reasons, rejecting the code in this question is very low priority</p>\n</blockquote>\n<p>Do constant expressions strictly require every sub-expression to be a constant expression? No, for example from <code>5.19</code> it says: (<em>emphasis mine</em>)</p>\n<blockquote>\n<p id=\"so_32920229_32926471_6\">A conditional-expression is a core constant expression unless it involves one of the following as a potentially\n  evaluated subexpression (3.2), <strong>but subexpressions of logical AND (5.14), logical OR (5.15), and conditional\n  (5.16) operations that are not evaluated are not considered</strong> [...]</p>\n</blockquote>\n<p>So the following is a constant expression:</p>\n<pre><code>constexpr int a = false &amp;&amp; argc * 0;\n</code></pre>\n<p>Because <code>argc * 0</code> is not evaluated since <code>&amp;&amp;</code> evaluates left-to-right and short-circuits.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:30:13.740", "Id": "32926471", "Score": "6", "CreationDate": "2015-10-03T19:15:07.977", "LastActivityDate": "2015-11-16T04:43:29.330"}, "32920273": {"ParentId": "32920229", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You can take a look here:\n<a href=\"http://en.cppreference.com/w/cpp/language/constexpr\" rel=\"nofollow\">constexpr at cppreference.com</a></p>\n<p>The baseline is that a constexpr should be something that can be determined unambiguously at compile-time so that the compiler can substitute its value in the expression is evaluated. </p>\n<p>I think the problem is the argc is not a constexpr. Is not something the compiler knows. In fact you can execute your main with a different number of arguments. If gcc accepts it it may be a bug or there may be some subtle thing involved I don't get.</p>\n", "OwnerUserId": "1469167", "LastEditorUserId": "483486", "LastEditDate": "2015-10-05T14:21:53.150", "Id": "32920273", "Score": "0", "CreationDate": "2015-10-03T07:57:51.860", "LastActivityDate": "2015-10-05T14:21:53.150"}, "bq_ids": {"n4140": {"so_32920229_32926471_4": {"section_id": 6185, "quality": 0.8461538461538461, "length": 11}, "so_32920229_32926471_3": {"section_id": 6185, "quality": 0.9166666666666666, "length": 11}, "so_32920229_32926471_0": {"section_id": 6185, "quality": 0.6, "length": 6}, "so_32920229_32926471_2": {"section_id": 6185, "quality": 1.0, "length": 13}}, "n3337": {"so_32920229_32926471_4": {"section_id": 5946, "quality": 1.0, "length": 13}, "so_32920229_32926471_3": {"section_id": 5946, "quality": 1.0, "length": 12}, "so_32920229_32926471_0": {"section_id": 5946, "quality": 0.9, "length": 9}, "so_32920229_32926471_6": {"section_id": 5946, "quality": 0.7619047619047619, "length": 16}, "so_32920229_32926471_2": {"section_id": 5946, "quality": 1.0, "length": 13}}, "n4659": {"so_32920229_32926471_4": {"section_id": 7687, "quality": 0.8461538461538461, "length": 11}, "so_32920229_32926471_3": {"section_id": 7687, "quality": 0.9166666666666666, "length": 11}, "so_32920229_32926471_2": {"section_id": 7687, "quality": 1.0, "length": 13}}}});