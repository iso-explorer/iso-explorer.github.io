post_cb({"28154038": {"ParentId": "28153959", "CommentCount": "3", "Body": "<p>Yes it is. But, since, C++99 it's far better to use the sized types</p>\n<pre><code>std::int8_t\nstd::int16_t\nstd::int32_t\nstd::int64_t\n</code></pre>\n<p>and their unsigned cousins <code>std::uint8_t</code> <em>etc</em> whenever possible. Then you know what you're dealing with.</p>\n<p>Note that compilers don't have to support the 64 bit integral types.</p>\n", "OwnerUserId": "2380830", "PostTypeId": "2", "Id": "28154038", "Score": "2", "CreationDate": "2015-01-26T16:13:53.450", "LastActivityDate": "2015-01-26T16:13:53.450"}, "28154026": {"ParentId": "28153959", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, this is valid it is covered in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">draft C++11 standard</a> section <code>7.1.6.2</code> <em>Simple type specifiers</em> which says:</p>\n<blockquote>\n<p id=\"so_28153959_28154026_0\">Table 10 summarizes\n  the valid combinations of simple-type-specifiers and the types they specify.</p>\n</blockquote>\n<p>and in Table <code>10</code> <em>simple-type-specifiers and the types they specify</em> says:</p>\n<pre><code>long long      \u201clong long int\u201d\n</code></pre>\n<p>and:</p>\n<pre><code>short          \u201cshort int\u201d\n</code></pre>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-01-26T22:00:50.770", "Id": "28154026", "Score": "5", "CreationDate": "2015-01-26T16:13:02.657", "LastActivityDate": "2015-01-26T22:00:50.770"}, "28154018": {"ParentId": "28153959", "CommentCount": "0", "Body": "<p>Yes, see table 10 in 7.1.6.2, which defines the mapping from various specifier combinations to the types from 3.9.</p>\n", "OwnerUserId": "8922", "PostTypeId": "2", "Id": "28154018", "Score": "1", "CreationDate": "2015-01-26T16:12:24.397", "LastActivityDate": "2015-01-26T16:12:24.397"}, "bq_ids": {"n4140": {"so_28153959_28154026_0": {"section_id": 5438, "quality": 0.875, "length": 7}}, "n3337": {"so_28153959_28154026_0": {"section_id": 5233, "quality": 0.875, "length": 7}}, "n4659": {"so_28153959_28154026_0": {"section_id": 6865, "quality": 0.875, "length": 7}}}, "28153959": {"CommentCount": "8", "AcceptedAnswerId": "28154026", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-01-26T16:09:32.807", "LastActivityDate": "2015-01-26T22:00:50.770", "LastEditDate": "2015-01-26T18:05:04.763", "ViewCount": "647", "FavoriteCount": "0", "Title": "Abbreviated type name long long vs long long int, is it standard-compliant?", "Id": "28153959", "Score": "4", "Body": "<p>Most of the code I see use abbreviated types to declare a variable, such as</p>\n<pre><code>long long x; // long long int x\nshort y; // short int y\n</code></pre>\n<p>I skimmed through the C++11 standard (Sec. <code>3.9.1</code>) and the type is always declared fully, as <code>long long int</code>. I couldn't find any mentioning of abbreviated types. I am pretty sure the abbreviations are standard-compliant, but wanted to make sure if this is indeed the case. So my question is whether the above code is fully standard compliant.</p>\n", "Tags": "<c++><c++11><types><language-lawyer>", "OwnerUserId": "3093378", "AnswerCount": "3"}});