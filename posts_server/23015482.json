post_cb({"23019886": {"ParentId": "23015482", "CommentCount": "8", "Body": "<p>You can use this: <a href=\"http://gcc.godbolt.org/\" rel=\"noreferrer\">http://gcc.godbolt.org/</a> to view the assembly..</p>\n<pre><code>int main()\n{\n    int(*)() = 0;\n    return 0;\n}\n</code></pre>\n<p>Generates:</p>\n<pre><code>main:\n    pushq   %rbp\n    movq    %rsp, %rbp\n    movl    $0, %eax\n    popq    %rbp\n    ret\n</code></pre>\n<p>Which is equivalent to:  <code>int main() {return 0;}</code>\nSo even with NO optimization, gcc just doesn't generate assembly for it.. Should it give a warning or error? I have no clue but it doesn't care or do anything for the unnamed func pointer.</p>\n<p>However:</p>\n<pre><code>int main()\n{\n    int (*p)() = 0;\n    return 0;\n}\n</code></pre>\n<p>With no optimization will generate:</p>\n<pre><code>main:\n    pushq   %rbp\n    movq    %rsp, %rbp\n    movq    $0, -8(%rbp)\n    movl    $0, %eax\n    popq    %rbp\n    ret\n</code></pre>\n<p>which allocates 8 bytes on the stack..</p>\n", "OwnerUserId": "1462718", "PostTypeId": "2", "Id": "23019886", "Score": "6", "CreationDate": "2014-04-11T18:18:28.923", "LastActivityDate": "2014-04-11T18:18:28.923"}, "23015482": {"CommentCount": "20", "ViewCount": "3755", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-04-11T14:30:41.587", "LastActivityDate": "2015-11-11T11:02:17.033", "Title": "Strange code that compiles with g++", "FavoriteCount": "17", "LastEditDate": "2017-05-23T12:22:39.510", "Id": "23015482", "Score": "70", "Body": "<p>The following code compiles successfully with g++ 4.8.1:</p>\n<pre><code>int main()\n{\n    int(*)();\n}\n</code></pre>\n<p>It looks like a simple declaration of a pointer to function:</p>\n<pre><code>int(*f)();\n</code></pre>\n<p>It doesn't compile with clang 3.4 and vc++ 2013.</p>\n<p>Is it a compiler bug or one of dark places of the standard?</p>\n<hr>\n<h3>List of similar strange code pieces which compile fine with g++ 4.8.1 (updated):</h3>\n<ol>\n<li><p><code>int(*)();</code></p></li>\n<li><p><code>int(*);</code></p></li>\n<li><p><code>int(*){};</code></p></li>\n<li><p><code>int(*());</code></p></li>\n</ol>\n<p><a href=\"http://ideone.com/yGG2yZ\" rel=\"nofollow noreferrer\">Live example with these strange code pieces</a>.</p>\n<p><strong>Update 1:</strong> <a href=\"https://stackoverflow.com/users/341970/ali\"><strong>@Ali</strong></a> added some interesting information in the comments:</p>\n<blockquote>\n<p id=\"so_23015482_23015482_0\">All 4 cases give a compile error with clang 3.5 trunk (202594) and compile fine with gcc 4.9 trunk (20140302). The behavior is the same with <code>-std=c++98 -pedantic</code>, except for <code>int(*){};</code> which is understandable; extended initializer lists only available with <code>-std=c++11</code>.</p>\n</blockquote>\n<p><strong>Update 2:</strong> As <a href=\"https://stackoverflow.com/users/1462718/cantchooseusernames\"><strong>@CantChooseUsernames</strong></a> noted in <a href=\"https://stackoverflow.com/questions/23015482/strange-code-that-compiles-with-g/23019886#23019886\">his answer</a> they still compile fine even with initialization and no assembly is generated for them by g++ (neither with nor without initialization) even without any enabled optimization:</p>\n<ol>\n<li><p><code>int(*)() = 0;</code></p></li>\n<li><p><code>int(*) = 0;</code></p></li>\n<li><p><code>int(*){} = 0;</code></p></li>\n<li><p><code>int(*()) = 0;</code></p></li>\n</ol>\n<p><a href=\"http://ideone.com/5Ugc92\" rel=\"nofollow noreferrer\">Live example with initializations</a>.</p>\n<p><strong>Update 3:</strong> I was really surprised to find that <code>int(*)() = \"Hello, world!\";</code> compiles fine, too (while <code>int(*p)() = \"Hello, world!\";</code> doesn't compile, of course).</p>\n<p><strong>Update 4:</strong> It is fantastic but <code>int(*){} = Hello, world!;</code> compiles fine. And the following extremely strange piece of code, too: <code>int(*){}() = -+*/%&amp;|^~.,:!?$()[]{};</code> (<a href=\"http://ideone.com/JvqcVL\" rel=\"nofollow noreferrer\">live example</a>).</p>\n<p><strong>Update 5:</strong> As <a href=\"https://stackoverflow.com/users/388520/zwol\"><strong>@zwol</strong></a> noted in <a href=\"https://stackoverflow.com/questions/23015482/strange-code-that-compiles-with-g?lq=1#comment55044024_23015482\">his comment</a></p>\n<blockquote>\n<p id=\"so_23015482_23015482_1\">This and a number of related syntactic problems are being tracked as gcc <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=68265\" rel=\"nofollow noreferrer\">bug 68265</a>.</p>\n</blockquote>\n</hr>", "Tags": "<c++><gcc><c++11><g++>", "OwnerUserId": "3043539", "AnswerCount": "3"}, "23016270": {"ParentId": "23015482", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>I am not sure how much this helps, but I tried the following (clang 3.3, g++ 4.8.1):</p>\n<pre><code>using P = int(*)();\nusing Q = int*;\nP; // warning only\nQ; // warning only\nint(*)(); // error (but only in clang)\nint*;     // error\nint(*p)(); // ok\nint *q;    // ok\n</code></pre>\n<p>On the other hand, everything compiles fine in g++ 4.8.2 and 4.9.0. I have no clang 3.4, unfortunately.</p>\n<p><em>Very roughly</em>, a declaration [iso section 7] consists of the following parts in order:</p>\n<ol>\n<li>optional prefix specifiers (e.g. <code>static</code>, <code>virtual</code>)</li>\n<li>base type (e.g. <code>const double</code>, <code>vector&lt;int&gt;</code>)</li>\n<li>declarator (e.g. <code>n</code>, <code>*p</code>, <code>a[7]</code>, <code>f(int)</code>)</li>\n<li>optional suffix function specifiers (e.g. <code>const</code>, <code>noexcept</code>)</li>\n<li>optional initializer or function body (e.g. <code>= {1,2,3}</code> or <code>{ return 0; }</code></li>\n</ol>\n<p>Now, a <em>declarator</em> roughly consists of a name and optionally some declarator operators [iso 8/4].</p>\n<p>Prefix operators, e.g.:</p>\n<ul>\n<li><code>*</code> (pointer)</li>\n<li><code>*const</code> (constant pointer)</li>\n<li><code>&amp;</code> (lvalue reference)</li>\n<li><code>&amp;&amp;</code> (rvalue reference)</li>\n<li><code>auto</code> (function return type, when trailing)</li>\n</ul>\n<p>Postfix operators, e.g.:</p>\n<ul>\n<li><code>[]</code> (array)</li>\n<li><code>()</code> (function)</li>\n<li><code>-&gt;</code> (function trailing return type)</li>\n</ul>\n<p>The above operators were designed to reflect their use in expressions. Postfix operators bind tighter than prefix, and parentheses can be used to change their order: <code>int *f()</code> is a function returning a pointer to <code>int</code>, whereas <code>int (*f)()</code> is a pointer to a function returning <code>int</code>.</p>\n<p>Maybe I am wrong, but I think these operators cannot be in the declaration without the name. So when we write <code>int *q;</code>, then <code>int</code> is the base type, and <code>*q</code> is the declarator consisting of prefix operator <code>*</code> followed by name <code>q</code>. But <code>int *;</code> cannot appear by itself.</p>\n<p>On the other hand, when we define <code>using Q = int*;</code>, then declaration <code>Q;</code> is fine by itself because <code>Q</code> is the base type. Of course, because we are not declaring anything, we may get an error or a warning depending on compiler options, but this is a different error.</p>\n<p>The above are just my understanding. What the standard (e.g. N3337) says is [iso 8.3/1]:</p>\n<blockquote>\n<p id=\"so_23015482_23016270_0\">Each declarator contains exactly one <em>declarator-id</em>; it names the identifier that is declared. An <em>unqualified-id</em> occurring in a <em>declarator-id</em> shall be a simple <em>identifier</em> except for the declaration of some special functions (12.3 [<em>user-defined conversions</em>], 12.4 [destructors], 13.5 [overloaded operators]) and for the declaration of template specializations or partial specializations (14.7).</p>\n</blockquote>\n<p>(notes in square brackets are mine). So I understand <code>int(*)();</code> should be invalid and I cannot say why it has different behaviour in clang and different versions of g++.</p>\n", "OwnerUserId": "2644390", "LastEditorUserId": "2644390", "LastEditDate": "2014-04-18T10:41:23.003", "Id": "23016270", "Score": "7", "CreationDate": "2014-04-11T15:07:33.867", "LastActivityDate": "2014-04-18T10:41:23.003"}, "bq_ids": {"n4140": {"so_23015482_23015727_0": {"section_id": 5384, "quality": 1.0, "length": 15}, "so_23015482_23016270_0": {"section_id": 3208, "quality": 0.7272727272727273, "length": 24}, "so_23015482_23015727_1": {"section_id": 3199, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_23015482_23015727_0": {"section_id": 5178, "quality": 1.0, "length": 15}, "so_23015482_23016270_0": {"section_id": 3082, "quality": 0.7272727272727273, "length": 24}, "so_23015482_23015727_1": {"section_id": 3073, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_23015482_23016270_0": {"section_id": 3965, "quality": 0.696969696969697, "length": 23}, "so_23015482_23015727_1": {"section_id": 3960, "quality": 0.9583333333333334, "length": 23}, "so_23015482_23015727_0": {"section_id": 6809, "quality": 1.0, "length": 15}}}, "23015727": {"ParentId": "23015482", "PostTypeId": "2", "CommentCount": "19", "Body": "<p>According to the C++ Standard (p. #6 of section 7 Declarations)</p>\n<blockquote>\n<p id=\"so_23015482_23015727_0\">6 Each init-declarator in the init-declarator-list <strong>contains exactly\n  one declarator-id</strong>, which is the name declared by that\n  init-declarator and hence one of the names declared by the declaration</p>\n</blockquote>\n<p>So it is simply a compiler bug.</p>\n<p>The valid code could look as for example (apart from the function pointer declaration showed by you) though I can not compile it with my MS VC++ 2010.</p>\n<pre><code>int(*p){};\n</code></pre>\n<p>It seems that the compiler you are using for testing allows declarations without a declarator-id.</p>\n<p>Also take into account the following paragraph of section 8.1 Type names</p>\n<blockquote>\n<p id=\"so_23015482_23015727_1\">1 To specify type conversions explicitly, and as an argument of\n  <strong>sizeof, alignof, new, or typeid</strong>, the name of a type shall be\n  specified. This can be done with a type-id, which is syntactically a\n  declaration for a variable or function of that type that omits the\n  name of the entity.</p>\n</blockquote>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2014-04-11T15:39:03.777", "Id": "23015727", "Score": "15", "CreationDate": "2014-04-11T14:41:53.763", "LastActivityDate": "2014-04-11T15:39:03.777"}});