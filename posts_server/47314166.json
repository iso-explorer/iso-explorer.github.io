post_cb({"47314166": {"CommentCount": "0", "ViewCount": "44", "CreationDate": "2017-11-15T17:51:38.990", "LastActivityDate": "2017-11-15T19:10:38.697", "Title": "Detection Idiom and SFINAE via Inheritance", "AcceptedAnswerId": "47314443", "PostTypeId": "1", "Id": "47314166", "Score": "2", "Body": "<p>I can use <code>std::experimental::is_detected</code> to check whether <code>chips1_t</code> can be instantiated with <code>float*</code> (which it can't) as shown in the <code>static_assert</code> below:</p>\n<pre><code>#include &lt;experimental/type_traits&gt;\n#include &lt;type_traits&gt;\n\ntemplate &lt;typename, typename = void&gt;\n  struct chips1;\n\ntemplate &lt;typename T&gt;\nstruct chips1&lt;T*,std::enable_if_t&lt;std::is_same&lt;T,int&gt;::value&gt;&gt; {\n  using type = int;\n};\n\ntemplate &lt;typename T&gt; using chips1_t = typename chips1&lt;T&gt;::type;\n\nstatic_assert(!std::experimental::is_detected&lt;chips1_t,float*&gt;::value,\"\");\n</code></pre>\n<p>If I then try a check using <code>chips2_t</code>, a similar <code>static_assert</code>, shown below, will produce a compilation error; regarding the missing <code>type</code> member. Can anyone tell me why?</p>\n<pre><code>struct Base {};\n\ntemplate &lt;typename&gt;\n  struct chips2;\n\ntemplate &lt;typename T&gt;\nstruct chips2&lt;T*&gt; : std::enable_if_t&lt;std::is_same&lt;T,int&gt;::value,Base&gt; {\n  using type = int;\n};\n\ntemplate &lt;typename T&gt; using chips2_t = typename chips2&lt;T&gt;::type;\n\nstatic_assert(!std::experimental::is_detected&lt;chips2_t,float*&gt;::value,\"\");\n</code></pre>\n", "Tags": "<c++><templates><sfinae>", "OwnerUserId": "2023370", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_47314166_47314443_0": {"section_id": 229, "quality": 1.0, "length": 5}}, "n3337": {"so_47314166_47314443_0": {"section_id": 222, "quality": 1.0, "length": 5}}, "n4659": {"so_47314166_47314443_0": {"section_id": 237, "quality": 1.0, "length": 5}}}, "47314443": {"ParentId": "47314166", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-11-15T18:08:34.050", "Score": "2", "LastEditorUserId": "27678", "LastEditDate": "2017-11-15T19:10:38.697", "Id": "47314443", "OwnerUserId": "27678", "Body": "<p>In the second case, the base class is not part of the template type, so it's not considered during SFINAE (It's a <em>dependent base class</em>)</p>\n<p>Instantiating </p>\n<pre><code>template &lt;typename T&gt;\nstruct chips2&lt;T*&gt;\n</code></pre>\n<p>Succeeds, and then compilation fails because it derives from <code>std::enable_if_t&lt;std::is_same&lt;T,int&gt;::value,Base&gt;</code> which becomes an ill-formed expression.</p>\n<hr>\n<p>You cannot specialize templates by their base class<sup>*</sup>.</p>\n<p>For example, you couldn't have two competing specializations like:</p>\n<pre><code>template &lt;typename T&gt;\nstruct chips2&lt;T*&gt; : std::enable_if_t&lt;std::is_same&lt;T,int&gt;::value,Base&gt; {\n  using type = int;\n};\n\ntemplate &lt;typename T&gt;\nstruct chips2&lt;T*&gt; : std::enable_if_t&lt;!std::is_same&lt;T,int&gt;::value,Base&gt; {\n  using type = float;\n};\n</code></pre>\n<p>They would be considered identical from a specialization standpoint (i.e., they are identical from a naming standpoint, so the compiler will consider the second one to be a redeclaration of the first one). The only part that matters is everything up to the colon <code>:</code></p>\n<p>In the first case, your <code>enable_if</code> is directly part of the template specialization, so SFINAE works properly.</p>\n<hr>\n<h2>Another note</h2>\n<p>In the second one, you've effectively made it impossible to instantiate <code>chips2</code> with anything other than <code>int*</code>, see the following example:</p>\n<pre><code>struct Base {};\n\ntemplate &lt;typename&gt;\nstruct chips2\n{};\n\ntemplate &lt;typename T&gt;\nstruct chips2&lt;T*&gt; \n   : std::enable_if_t&lt;std::is_same&lt;T,int&gt;::value, Base&gt; \n{};\n\nint main(){\n    chips2&lt;float*&gt; c;\n}\n</code></pre>\n<p>You might be inclined to think that SFINAE will choose the base class template for <code>c</code>, but in reality it chooses the specialization <code>chips2&lt;T*&gt;</code> because of what I said above, and compilation fails.</p>\n<hr>\n<p><sup>*</sup>Relevant standardese at [temp.spec]</p>\n<blockquote>\n<p id=\"so_47314166_47314443_0\">the name of the class that is explicitly specialized shall be a <em>simple-template-id.</em></p>\n</blockquote>\n<p>Where a <em>simple-template-id</em> is of the form: <br/>\n\u00a0\u00a0 <em>template-name &lt; template-argument-listopt &gt;</em></p>\n<p>e.g. <code>chips2&lt;T*&gt;</code>. Note that there is no option to also include the class it derives from </p>\n</hr></hr></hr>", "LastActivityDate": "2017-11-15T19:10:38.697"}});