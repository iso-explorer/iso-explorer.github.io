post_cb({"45489752": {"ParentId": "45489631", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The condition of <code>static_assert</code> is always <code>false</code>, that make the primary template failing to be selected in overload resolution, before the selection of the specifications. You can change the condition of <code>static_assert</code> to make it depending on the tempalate parameter <code>x</code>. .e.g</p>\n<pre><code>template&lt;int x&gt;\nvoid f()\n{\n    static_assert(x == 3 || x == 5, \"You are trying to use f with the wrong numbers\");\n}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/B8wcnx3b2Pj4Jq3R\" rel=\"nofollow noreferrer\">LIVE</a></p>\n<p>From the standard, <a href=\"http://eel.is/c++draft/temp.res#8\" rel=\"nofollow noreferrer\">$17.7/8,9 Name resolution [temp.res]</a>:</p>\n<blockquote>\n<p id=\"so_45489631_45489752_0\">a hypothetical instantiation of a template immediately following its definition would be ill-formed due to a construct that does not depend on a template parameter</p>\n<p id=\"so_45489631_45489752_1\">...</p>\n<p id=\"so_45489631_45489752_2\">Otherwise, no diagnostic shall be issued for a template for which a valid specialization can be generated.</p>\n</blockquote>\n<p>and <a href=\"http://eel.is/c++draft/temp.dep#1\" rel=\"nofollow noreferrer\">$17.7.2/1 Dependent names [temp.dep]</a>:</p>\n<blockquote>\n<p id=\"so_45489631_45489752_3\">Inside a template, some constructs have semantics which may differ from one instantiation to another. Such a construct depends on the template parameters.</p>\n</blockquote>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2017-08-03T16:52:25.467", "Id": "45489752", "Score": "2", "CreationDate": "2017-08-03T16:23:04.640", "LastActivityDate": "2017-08-03T16:52:25.467"}, "45489631": {"CommentCount": "2", "ViewCount": "76", "PostTypeId": "1", "LastEditorUserId": "3309790", "CreationDate": "2017-08-03T16:17:02.440", "LastActivityDate": "2017-08-05T04:18:51.940", "Title": "About specialization with ints, and static_assert", "FavoriteCount": "0", "LastEditDate": "2017-08-03T16:52:20.910", "Id": "45489631", "Score": "5", "Body": "<p>I want to write a template function that only work with 2 numbers (for instance 3 and 5) and gives and error if you try to use it with another numbers.</p>\n<p>I can do this in this way:</p>\n<pre><code>template&lt;int x&gt;\nvoid f();\n\ntemplate&lt;&gt;\nvoid f&lt;3&gt;()\n{\n   cout &lt;&lt; \"f&lt;3&gt;()\\n\";\n}\n\n\ntemplate&lt;&gt;\nvoid f&lt;5&gt;()\n{\n  cout &lt;&lt; \"f&lt;5&gt;()\\n\";\n}\n</code></pre>\n<p>and then I can call this function the normal way:</p>\n<pre><code>f&lt;3&gt;();\nf&lt;5&gt;();\n</code></pre>\n<p>and it compiles well, and if I try to use my function incorrectly:</p>\n<pre><code>f&lt;10&gt;();\n</code></pre>\n<p>the compiler gives me an error.</p>\n<p>I have 2 problems with this approach:</p>\n<p>1.- Is this standard? Can I specialized a template with ints?</p>\n<p>2.- I don't like the error you get if you use this approach, because the error doesn't tell the user what he had done incorrectly. I'd prefer write something like:</p>\n<pre><code>template&lt;int x&gt;\nvoid f()\n{\n    static_assert(false, \"You are trying to use f with the wrong numbers\");\n}\n</code></pre>\n<p>but this doesn't compile. It appears my compiler (gcc 5.4.0) is trying to instantiate first the primary template, and because of that it gives the error (of the static_assert).</p>\n<p>Thank you for your help.</p>\n<p>In case you are wondering why I want to do this is because I am learning how to program a microcontroller. In a microcontroller you have some pins that only do some things. For instance, the pins 3 and 5 are the pins in which you can generate a square wave. If in an application I want to generate a square wave I want to write somthing like:</p>\n<pre><code>square_wave&lt;3&gt;(frecuency);\n</code></pre>\n<p>But, if some months later I want to reuse this code (or change it) in another application with a differente microcontroller, I want my compiler say to me: \"eh, in this microcontroller you can't generate a square wave in pins 3 and 5. Instead, use pins 7 and 9\". And I think this can save me a lot of headaches (or maybe not, I really don't know. I'm just learning how to program a microcontroller).</p>\n", "Tags": "<c++><templates><microcontroller><template-specialization><static-assert>", "OwnerUserId": "6683567", "AnswerCount": "3"}, "45489826": {"ParentId": "45489631", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_45489631_45489826_0\">1.- Is this standard? Can I specialized a template with ints?</p>\n</blockquote>\n<p>Yes.</p>\n<blockquote>\n<p id=\"so_45489631_45489826_1\">2.</p>\n</blockquote>\n<pre><code>template&lt;int x&gt;\nvoid f()\n{\n    static_assert(false, \"You are trying to use f with the wrong numbers\");\n}\n</code></pre>\n<p>You need to change the static assert condition into something that is dependent on the value of the template parameter. Something as simple as</p>\n<pre><code>template &lt;int x&gt;\nvoid f()\n{\n    static_assert(x - x, \"You are trying to use f with the wrong numbers\");\n}\n</code></pre>\n<p>should work.</p>\n<hr>\n<p>As an aside, it's worth noting that it's usually considered not such a great idea to specialise function templates, as specialisation interacts badly (or at least somewhat unpredictably) with function overloading. So it may be a better idea in general to use a function object instead:</p>\n<pre><code>template &lt;int I&gt;\nstruct do_f {\n    static_assert(I - I, \"You are trying to use f with the wrong numbers\");\n};\n\ntemplate &lt;&gt;\nstruct do_f&lt;3&gt; {\n    void operator()(args...) { ... }\n};\n\ntemplate &lt;&gt;\nstruct do_f&lt;5&gt; {\n    void operator()(args...) { ... }\n};\n</code></pre>\n<p>Then you can write a wrapper function which calls out to the function object:</p>\n<pre><code>template &lt;int I&gt;\nvoid f(args...) {\n    do_f&lt;I&gt;{}(args...);\n}\n</code></pre>\n</hr>", "OwnerUserId": "2797826", "LastEditorUserId": "2797826", "LastEditDate": "2017-08-03T16:34:43.597", "Id": "45489826", "Score": "5", "CreationDate": "2017-08-03T16:26:26.553", "LastActivityDate": "2017-08-03T16:34:43.597"}, "45518149": {"ParentId": "45489631", "CommentCount": "0", "Body": "<p>The other answers only propose a workaround.  Especially because it involves writing some boilerplate code.  The easiest thing to do is</p>\n<pre><code>template&lt;int x&gt;\nvoid f() = delete;\n</code></pre>\n<p>Then you will obtain a nice compiler error like</p>\n<pre class=\"lang-none prettyprint-override\"><code>error: call to deleted function 'f'\n</code></pre>\n<p>when you try to instantiate the template for a non-specialized <code>int</code>.</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;int x&gt;\nvoid f() = delete;\n\ntemplate&lt;&gt;\nvoid f&lt;3&gt;()\n{\n  std::cout &lt;&lt; \"f&lt;3&gt;()\\n\";\n}\n\ntemplate&lt;&gt;\nvoid f&lt;5&gt;()\n{\n  std::cout &lt;&lt; \"f&lt;5&gt;()\\n\";\n}\n\nint main()\n{\n  f&lt;3&gt;();\n  f&lt;5&gt;();\n  f&lt;10&gt;(); // BOOM!\n}\n</code></pre>\n<p><kbd><a href=\"https://wandbox.org/permlink/TUUXY5gZvYOPWtUl\" rel=\"nofollow noreferrer\">Live example</a></kbd></p>\n", "OwnerUserId": "1944004", "PostTypeId": "2", "Id": "45518149", "Score": "0", "CreationDate": "2017-08-05T04:18:51.940", "LastActivityDate": "2017-08-05T04:18:51.940"}, "bq_ids": {"n4140": {"so_45489631_45489752_2": {"section_id": 175, "quality": 0.875, "length": 7}, "so_45489631_45489752_3": {"section_id": 188, "quality": 0.9375, "length": 15}}, "n3337": {"so_45489631_45489752_2": {"section_id": 169, "quality": 0.875, "length": 7}, "so_45489631_45489752_3": {"section_id": 182, "quality": 0.9375, "length": 15}}, "n4659": {"so_45489631_45489752_0": {"section_id": 180, "quality": 1.0, "length": 15}, "so_45489631_45489752_2": {"section_id": 180, "quality": 1.0, "length": 8}, "so_45489631_45489752_3": {"section_id": 193, "quality": 0.9375, "length": 15}}}});