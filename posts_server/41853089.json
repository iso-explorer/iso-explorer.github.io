post_cb({"bq_ids": {"n4140": {"so_41853089_41853089_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 776}, "so_41853089_41853537_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 5556}}, "n3337": {"so_41853089_41853089_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 763}, "so_41853089_41853537_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 5338}}, "n4659": {"so_41853089_41853089_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 837}, "so_41853089_41853537_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 7001}}}, "41853089": {"ViewCount": "132", "Body": "<p><a href=\"https://stackoverflow.com/questions/41851547/how-to-adjust-vector-iterator-to-return-struct/41851678?noredirect=1#comment70888064_41851678\">Angew made a comment</a> that a <code>vector</code> using a raw pointer as it's iterator type was fine. That kinda threw me for a loop.</p>\n<p>I started researching it and found that the requirement for <code>vector</code> iterators was only that they are <a href=\"http://en.cppreference.com/w/cpp/concept/RandomAccessIterator\" rel=\"nofollow noreferrer\">\"Random Access Iterators\"</a> for which it is explicitly stated that pointers qualify:</p>\n<blockquote>\n<p id=\"so_41853089_41853089_0\">A pointer to an element of an array satisfies all requirements</p>\n</blockquote>\n<p>Is the only reason that compilers even provide iterators to <code>vector</code> for debugging purposes, or is there actually a requirement I missed on <code>vector</code>?</p>\n", "AcceptedAnswerId": "41853537", "Title": "Does Using a Pointer as a Container Iterator Violate the Standard", "CreationDate": "2017-01-25T13:38:10.610", "Id": "41853089", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:16:46.737", "LastEditorUserId": "-1", "LastActivityDate": "2017-01-25T14:16:54.403", "Score": "6", "OwnerUserId": "2642059", "Tags": "<c++><pointers><vector><iterator><random-access>", "AnswerCount": "3"}, "41853472": {"Id": "41853472", "PostTypeId": "2", "Body": "<p>My 50 cents:</p>\n<p>Iterators are generic ways to access <em>any</em> STL container. What I feel you're saying is: Since pointers are OK as a replacement of iterators for vectors, why are there iterators for vectors?</p>\n<p>Well, who said you can't have duplicates in C++? Actually it's a good thing to have different interfaces to the same functionality. That should not be a problem.</p>\n<p>On the other hand, think about libraries that have algorithms that use iterators. If vectors don't have iterators, it's just an invitation to exceptions (exceptions in the linguistic since, not programming sense). Every time one has to write an algorithm, he must do something different for vectors with pointers. But why? No reason for this hassle. Just interface everything the same way.</p>\n", "LastEditorUserId": "1317944", "LastActivityDate": "2017-01-25T14:11:48.057", "Score": "2", "CreationDate": "2017-01-25T13:56:55.613", "ParentId": "41853089", "CommentCount": "3", "LastEditDate": "2017-01-25T14:11:48.057", "OwnerUserId": "1317944"}, "41853537": {"Id": "41853537", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_41853089_41853537_0\">\u00a7 24.2.1</p>\n<p id=\"so_41853089_41853537_1\">Since iterators are an abstraction of pointers, their semantics is a generalization of most of the semantics\n  of pointers in C++. This ensures that every function template that takes iterators works as well with\n  regular pointers.</p>\n</blockquote>\n<p>So yes, using a pointer satisfies all of the requirements for a <code>Random Access Iterator</code>.</p>\n<p><code>std::vector</code> likely provides iterators for a few reasons</p>\n<ol>\n<li><p>The standard says it should. </p></li>\n<li><p>It would be odd if containers such as <code>std::map</code> or <code>std::set</code> provided iterators while <code>std::vector</code> provided only a <code>value_type*</code> pointer. Iterators provide consistency across the containers library.</p></li>\n<li><p>It allows for specializations of the vector type eg, <code>std::vector&lt;bool&gt;</code> where a <code>value_type*</code> pointer would not be a valid iterator.</p></li>\n</ol>\n", "LastEditorUserId": "1020484", "LastActivityDate": "2017-01-25T14:06:04.003", "Score": "3", "CreationDate": "2017-01-25T13:59:24.367", "ParentId": "41853089", "CommentCount": "2", "LastEditDate": "2017-01-25T14:06:04.003", "OwnerUserId": "1020484"}, "41853877": {"Id": "41853877", "PostTypeId": "2", "Body": "<p>What those comments are saying is that </p>\n<pre><code>template &lt;typename T, ...&gt;\nclass vector\n{\npublic:\n    typedef T* iterator;\n    typedef const T* const_iterator;\n    ...\nprivate:\n    T* elems; // pointer to dynamic array\n    size_t count;\n    ...\n}\n</code></pre>\n<p>is valid. Similarly a user defined container intended for use with <code>std::</code> algorithms can do that. Then when a template asks for <code>Container::iterator</code> the type it gets back <em>in that instantiation</em> is <code>T*</code>, and that behaves properly.</p>\n<p>So the standard requires that <code>vector</code> has a definition for <code>vector::iterator</code>, and you use that in your code. On one platform it is implemented as a pointer into an array, but on a different platform it is something else. Importantly these things behave the same way in all the aspects that the standard specifies.</p>\n", "LastActivityDate": "2017-01-25T14:16:54.403", "Score": "2", "CreationDate": "2017-01-25T14:16:54.403", "ParentId": "41853089", "CommentCount": "1", "OwnerUserId": "2610810"}});