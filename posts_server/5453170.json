post_cb({"5453170": {"ViewCount": "8292", "Body": "<p>I saw some code as follows:</p>\n<pre><code>class A \n{\nprivate:\n    union {\n        B *rep;\n        A *next;\n    }; // no variables of this anonymous defined!\n\n    void func()\n    {\n        A *p = new A;\n\n        p-&gt;next = NULL; // why p has a member variable of 'next'?\n    }\n};\n</code></pre>\n<p>I have compiled the above code with VS2010 without any error.\nHere is the question,</p>\n<p>why p has member variable 'next'?</p>\n<pre><code>    union {\n        B *rep;\n        A *next;\n    };\n</code></pre>\n<p>As far as I know, this is an anonymous union without even defining a variable. How can we access the member variables inside this union like that?</p>\n", "AcceptedAnswerId": "5453262", "Title": "Usage of union inside a class", "CreationDate": "2011-03-27T23:19:51.993", "Id": "5453170", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-06-24T01:46:17.923", "LastEditorUserId": "242924", "LastActivityDate": "2014-06-24T01:46:17.923", "Score": "9", "OwnerUserId": "391104", "Tags": "<c++><class><unions>", "AnswerCount": "4"}, "5453262": {"Id": "5453262", "PostTypeId": "2", "Body": "<p>Because that's pretty much what an anonymous union does, it defines zero-or-more variables in the enclosing namespace (which in a class declaration makes them field names) which occupy overlapping memory. Hence in use it's the same as if you'd declared</p>\n<pre><code>class A \n{\nprivate:\n    B *rep;\n    A *next;\n\n    void func()\n    {\n        A *p = new A;\n\n        p-&gt;next = NULL;\n    }\n};\n</code></pre>\n<p>...except for rep and next occupying overlapping space (or given that the two pointers will have the same size, the same space), and hence all the dangers and benefits that come with a named union.</p>\n", "LastActivityDate": "2011-03-27T23:38:06.340", "CommentCount": "1", "CreationDate": "2011-03-27T23:38:06.340", "ParentId": "5453170", "Score": "14", "OwnerUserId": "400547"}, "5453211": {"Id": "5453211", "PostTypeId": "2", "Body": "<p>I am not really sure I understand your question.</p>\n<p>A has the member p, because you declared it in A inside an anonymous union along with rep.</p>\n<p>You did declare a variable! It's just that 'rep' and 'next' share the same memory.</p>\n<p>You can access it just the way you did.</p>\n<p>anonymous unions (just like structs) put their members in the same namespace as the above namespace is.</p>\n<p>It's useful for e.g.:</p>\n<pre><code>union W00t {\n    struct {\n         uint32_t a,b;\n    };\n    struct {\n         uint64_t c;\n    };\n }\n</code></pre>\n", "LastEditorUserId": "14114", "LastActivityDate": "2011-03-27T23:33:29.160", "Score": "0", "CreationDate": "2011-03-27T23:28:02.047", "ParentId": "5453170", "CommentCount": "5", "OwnerUserId": "14114", "LastEditDate": "2011-03-27T23:33:29.160"}, "bq_ids": {"n4140": {"so_5453170_5453325_0": {"length": 50, "quality": 0.8064516129032258, "section_id": 5917}}, "n3337": {"so_5453170_5453325_0": {"length": 51, "quality": 0.8225806451612904, "section_id": 5689}}, "n4659": {"so_5453170_5453325_0": {"length": 48, "quality": 0.7741935483870968, "section_id": 7410}}}, "5453266": {"Id": "5453266", "PostTypeId": "2", "Body": "<p>I'm surprised there is a modern compiler which still allows that construct.  It is one from the early days of C, circa 1975.  In those days, structure and union members were not actually tied to a particular structure, but contained as attributes an offset from a base address and a data type.</p>\n<p>The end result was that using a structure or union properly results in correct code with expressions evaluated as expected.  The only difference is that misuse of a structure member with a pointer unassociated with the type would not be flagged as an error.  I don't think there was any particular reason for not enforcing the associate\u2014K&amp;R hint that future compilers <em>hopefully</em> would check such uses\u2014probably just to save symbol table space in 16-bit land.</p>\n", "LastActivityDate": "2011-03-27T23:39:50.370", "CommentCount": "4", "CreationDate": "2011-03-27T23:39:50.370", "ParentId": "5453170", "Score": "0", "OwnerUserId": "198536"}, "5453325": {"Id": "5453325", "PostTypeId": "2", "Body": "<p>Here's the quote from the standard that controls this behavior: section <code>[class.union]</code> (wording from C++0x draft n3242)</p>\n<blockquote>\n<p id=\"so_5453170_5453325_0\">A union of the form\n  <code>union {</code> <em>member-specification</em> <code>} ;</code> is called an anonymous union; it de\ufb01nes an unnamed object of unnamed type. The <em>member-specification</em> of an anonymous union shall only de\ufb01ne non-static data members. [ Note: Nested types and functions cannot be declared within an anonymous union.  \u2014 end note ] The names of the members of an anonymous union shall be distinct from the names of any other entity in the scope in which the anonymous union is declared. For the purpose of name lookup, after the anonymous union de\ufb01nition, the members of the anonymous union are considered to have been de\ufb01ned in the scope in which the anonymous union is declared.</p>\n</blockquote>\n", "LastActivityDate": "2011-03-27T23:50:42.330", "CommentCount": "3", "CreationDate": "2011-03-27T23:50:42.330", "ParentId": "5453170", "Score": "11", "OwnerUserId": "103167"}});