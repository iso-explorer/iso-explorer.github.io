post_cb({"32761132": {"CommentCount": "1", "AcceptedAnswerId": "32761352", "CreationDate": "2015-09-24T12:18:15.003", "LastActivityDate": "2015-09-24T12:35:26.167", "PostTypeId": "1", "ViewCount": "215", "FavoriteCount": "1", "Title": "Throwing an rvalue", "Id": "32761132", "Score": "13", "Body": "<p>Consider the fragment:</p>\n<pre><code>try {\n    Foo f;\n    throw std::move(f);\n}\ncatch (Foo&amp; f) { }\n</code></pre>\n<p>[expr.throw] says that:</p>\n<blockquote>\n<p id=\"so_32761132_32761132_0\">the type of the exception object\n  is determined by removing any top-level <em>cv-qualifiers</em> from the static type of the operand and adjusting the\n  type from \u201carray of T\u201d or \u201cfunction returning T\u201d to \u201cpointer to T\u201d or \u201cpointer to function returning T\u201d,\n  respectively.</p>\n</blockquote>\n<p>which would be <code>Foo&amp;&amp;</code>. The exception object is then initialized according to [except.throw]:</p>\n<blockquote>\n<p id=\"so_32761132_32761132_1\">Throwing an exception copy-initializes (8.5, 12.8) a temporary object, called the <em>exception object</em>. The\n  temporary is an lvalue and is used to initialize the variable declared in the matching <em>handler</em> (15.3). If the\n  type of the exception object would be an incomplete type or a pointer to an incomplete type other than\n  (possibly cv-qualified) <code>void</code> the program is ill-formed.</p>\n</blockquote>\n<p>This suggests to me that the exception object is initialized as:</p>\n<pre><code>Foo&amp;&amp; __exception_object = std::move(f);\n</code></pre>\n<p>and that the handler would not match. However, both gcc and clang do catch this exception. So what's the actual type of the exception object here? If <code>Foo</code>, why?</p>\n", "Tags": "<c++><language-lawyer><c++14><throw>", "OwnerUserId": "2069064", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_32761132_32761352_1": {"section_id": 5938, "quality": 0.8695652173913043, "length": 20}, "so_32761132_32761132_0": {"section_id": 3336, "quality": 1.0, "length": 20}, "so_32761132_32761352_0": {"section_id": 5768, "quality": 1.0, "length": 7}, "so_32761132_32761132_1": {"section_id": 3336, "quality": 0.8484848484848485, "length": 28}}, "n3337": {"so_32761132_32761352_1": {"section_id": 5710, "quality": 0.8695652173913043, "length": 20}, "so_32761132_32761132_0": {"section_id": 3206, "quality": 0.9, "length": 18}, "so_32761132_32761352_0": {"section_id": 5541, "quality": 1.0, "length": 7}, "so_32761132_32761132_1": {"section_id": 3206, "quality": 0.7272727272727273, "length": 24}}, "n4659": {"so_32761132_32761352_1": {"section_id": 7422, "quality": 0.8695652173913043, "length": 20}, "so_32761132_32761132_0": {"section_id": 7672, "quality": 0.75, "length": 15}, "so_32761132_32761132_1": {"section_id": 4103, "quality": 0.7575757575757576, "length": 25}, "so_32761132_32761352_0": {"section_id": 7225, "quality": 1.0, "length": 7}}}, "32761352": {"ParentId": "32761132", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The static type of an expression is never a reference type.</p>\n<p>1.3.24 [defns.static.type] defines \"static type\":</p>\n<blockquote>\n<p id=\"so_32761132_32761352_0\">type of an expression (3.9) resulting from analysis of the program without considering execution semantics</p>\n</blockquote>\n<p>the first step in that \"analysis of the program\" is to remove references, see\n5 [expr] p5 and <a href=\"http://scottmeyers.blogspot.co.uk/2015/02/expressions-can-have-reference-type.html\">Expressions can have reference type</a></p>\n<blockquote>\n<p id=\"so_32761132_32761352_1\">If an expression initially has the type \u201creference to <code>T</code>\u201d (8.3.2, 8.5.3), the type is adjusted to <code>T</code> prior to any further analysis. The expression designates the object or function denoted by the reference, and  the expression is an lvalue or an xvalue, depending on the expression.</p>\n</blockquote>\n<p>So <code>std::move(f)</code> is an xvalue expression, with static type <code>Foo</code>.</p>\n<p>You don't need to involve rvalues to demonstrate this, the same was true in C++03 with:</p>\n<pre><code>int&amp; f();\nthrow f();\n</code></pre>\n<p>This throws an <code>int</code> not an <code>int&amp;</code>.</p>\n<p>Without considering the specifics, an exception object is an object, and a reference is not an object, so an exception object cannot be a reference. It must be an object.</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2015-09-24T12:35:26.167", "Id": "32761352", "Score": "14", "CreationDate": "2015-09-24T12:29:08.103", "LastActivityDate": "2015-09-24T12:35:26.167"}});