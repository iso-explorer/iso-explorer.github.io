post_cb({"bq_ids": {"n4140": {"so_25668600_25668899_0": {"length": 32, "quality": 0.9696969696969697, "section_id": 3604}}, "n3337": {"so_25668600_25668899_0": {"length": 32, "quality": 0.9696969696969697, "section_id": 3466}}, "n4659": {"so_25668600_25668899_0": {"length": 31, "quality": 0.9393939393939394, "section_id": 4368}}}, "25669510": {"Id": "25669510", "PostTypeId": "2", "Body": "<p>The problem is in mapping from the codomain of <code>std::mt19937</code> (<code>std::uint_fast32_t</code>) to <code>float</code>; the algorithm described by the standard gives incorrect results (inconsistent with its description of the output of the algorithm) when loss of precision occurs if the current IEEE754 rounding mode is anything other than round-to-negative-infinity (note that the default is round-to-nearest).</p>\n<p>The 7549723rd output of mt19937 with your seed is 4294967257 (<code>0xffffffd9u</code>), which when rounded to 32-bit float gives <code>0x1p+32</code>, which is equal to the max value of mt19937, 4294967295 (<code>0xffffffffu</code>) when that is also rounded to 32-bit float.</p>\n<p>The standard could ensure correct behavior if it were to specify that when converting from the output of the URNG to the <code>RealType</code> of <code>generate_canonical</code>, rounding is to be performed towards negative infinity; this would give a correct result in this case.  As QOI, it would be good for libstdc++ to make this change.</p>\n<p>With this change, <code>1.0</code> will no longer be generated; instead the boundary values <code>0x1.fffffep-N</code> for <code>0 &lt; N &lt;= 8</code> will be generated more often (approximately <code>2^(8 - N - 32)</code> per <code>N</code>, depending on the actual distribution of MT19937).</p>\n<p>I would recommend to not use <code>float</code> with <code>std::generate_canonical</code> directly; rather generate the number in <code>double</code> and then round towards negative infinity:</p>\n<pre><code>    double rd = std::generate_canonical&lt;double,\n        std::numeric_limits&lt;float&gt;::digits&gt;(rng);\n    float rf = rd;\n    if (rf &gt; rd) {\n      rf = std::nextafter(rf, -std::numeric_limits&lt;float&gt;::infinity());\n    }\n</code></pre>\n<p>This problem can also occur with <code>std::uniform_real_distribution&lt;float&gt;</code>; the solution is the same, to specialize the distribution on <code>double</code> and round the result towards negative infinity in <code>float</code>.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2017-03-28T19:03:32.513", "Score": "119", "CreationDate": "2014-09-04T15:34:47.663", "ParentId": "25668600", "CommentCount": "22", "OwnerUserId": "567292", "LastEditDate": "2017-03-28T19:03:32.513"}, "25668600": {"ViewCount": "5737", "Body": "<p>I always thought random numbers would lie between zero and one, <strong>without <code>1</code></strong>, i.e. they are numbers from the half-open interval [0,1). The <a href=\"http://en.cppreference.com/w/cpp/numeric/random/generate_canonical\">documention on cppreference.com</a> of <code>std::generate_canonical</code> confirms this.</p>\n<p>However, when I run the following program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;limits&gt;\n#include &lt;random&gt;\n\nint main()\n{\n    std::mt19937 rng;\n\n    std::seed_seq sequence{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    rng.seed(sequence);\n    rng.discard(12 * 629143 + 6);\n\n    float random = std::generate_canonical&lt;float,\n                   std::numeric_limits&lt;float&gt;::digits&gt;(rng);\n\n    if (random == 1.0f)\n    {\n        std::cout &lt;&lt; \"Bug!\\n\";\n    }\n\n    return 0;\n}\n</code></pre>\n<p>It gives me the following output:</p>\n<pre><code>Bug!\n</code></pre>\n<p>i.e. it generates me a perfect <code>1</code>, which causes problems in my MC integration. Is that valid behavior or is there an error on my side? This gives the same output with G++ 4.7.3</p>\n<pre><code>g++ -std=c++11 test.c &amp;&amp; ./a.out\n</code></pre>\n<p>and clang 3.3</p>\n<pre><code>clang++ -stdlib=libc++ -std=c++11 test.c &amp;&amp; ./a.out\n</code></pre>\n<p>If this is correct behavior, how can I avoid <code>1</code>?</p>\n<p><strong>Edit 1</strong>: G++ from git seems to suffer from the same problem. I am on</p>\n<pre><code>commit baf369d7a57fb4d0d5897b02549c3517bb8800fd\nDate:   Mon Sep 1 08:26:51 2014 +0000\n</code></pre>\n<p>and compiling with <code>~/temp/prefix/bin/c++ -std=c++11 -Wl,-rpath,/home/cschwan/temp/prefix/lib64 test.c &amp;&amp; ./a.out</code> gives the same output, <code>ldd</code> yields</p>\n<pre><code>linux-vdso.so.1 (0x00007fff39d0d000)\nlibstdc++.so.6 =&gt; /home/cschwan/temp/prefix/lib64/libstdc++.so.6 (0x00007f123d785000)\nlibm.so.6 =&gt; /lib64/libm.so.6 (0x000000317ea00000)\nlibgcc_s.so.1 =&gt; /home/cschwan/temp/prefix/lib64/libgcc_s.so.1 (0x00007f123d54e000)\nlibc.so.6 =&gt; /lib64/libc.so.6 (0x000000317e600000)\n/lib64/ld-linux-x86-64.so.2 (0x000000317e200000)\n</code></pre>\n<p><strong>Edit 2</strong>: I reported the behavior here: <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63176\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=63176</a></p>\n<p><strong>Edit 3</strong>: The clang team seems to be aware of the problem: <a href=\"http://llvm.org/bugs/show_bug.cgi?id=18767\">http://llvm.org/bugs/show_bug.cgi?id=18767</a></p>\n", "AcceptedAnswerId": "25669510", "Title": "Is 1.0 a valid output from std::generate_canonical?", "CreationDate": "2014-09-04T14:51:52.230", "Id": "25668600", "CommentCount": "23", "FavoriteCount": "15", "PostTypeId": "1", "LastEditDate": "2014-09-05T09:42:35.457", "LastEditorUserId": "96982", "LastActivityDate": "2017-09-03T05:16:04.670", "Score": "121", "OwnerUserId": "812178", "Tags": "<c++><c++11><random>", "AnswerCount": "3"}, "25668899": {"Id": "25668899", "PostTypeId": "2", "Body": "<p>According to the standard, <code>1.0</code> is not valid.</p>\n<blockquote>\n<h3>C++11  \u00a726.5.7.2 Function template generate_canonical</h3>\n<p id=\"so_25668600_25668899_0\">Each function instantiated from the template described in this section 26.5.7.2 maps the result of one or more invocations of a supplied uniform random number generator <code>g</code> to one member of the specified RealType such that, if the values g<sub>i</sub> produced by <code>g</code> are uniformly distributed, the instantiation\u2019s results t<sub>j</sub> , <strong>0 \u2264  t<sub>j</sub> &lt; 1</strong>, are distributed as uniformly as possible as specified below.</p>\n</blockquote>\n", "LastEditorUserId": "1009479", "LastActivityDate": "2014-09-04T15:14:09.033", "Score": "39", "CreationDate": "2014-09-04T15:04:40.273", "ParentId": "25668600", "CommentCount": "1", "OwnerUserId": "1009479", "LastEditDate": "2014-09-04T15:14:09.033"}, "46020507": {"Id": "46020507", "PostTypeId": "2", "Body": "<p>I just ran into a similar question with <code>uniform_real_distribution</code>, and here's how I interpret the Standard's parsimonious wording on the subject:</p>\n<p>The Standard always defines math functions in terms of <em>math</em>, never in terms of IEEE floating-point (because the Standard still pretends that floating-point <em>might not</em> mean IEEE floating point). So, any time you see mathematical wording in the Standard, it's talking about <em>real math</em>, not IEEE.</p>\n<p>The Standard says that both <code>uniform_real_distribution&lt;T&gt;(0,1)(g)</code> and <code>generate_canonical&lt;T,1000&gt;(g)</code> should return values in the half-open range [0,1). But these are <em>mathematical</em> values. When you take a real number in the half-open range [0,1) and represent it as IEEE floating-point, well, a significant fraction of the time it will round up to <code>T(1.0)</code>.</p>\n<p>When <code>T</code> is <code>float</code> (24 mantissa bits), we expect to see <code>uniform_real_distribution&lt;float&gt;(0,1)(g) == 1.0f</code> about 1 in 2^25 times. <a href=\"https://wandbox.org/permlink/Culi50l3hCPLJMSD\" rel=\"nofollow noreferrer\">My brute-force experimentation with libc++ confirms this expectation.</a></p>\n<pre><code>template&lt;class F&gt;\nvoid test(long long N, const F&amp; get_a_float) {\n    int count = 0;\n    for (long long i = 0; i &lt; N; ++i) {\n        float f = get_a_float();\n        if (f == 1.0f) {\n            ++count;\n        }\n    }\n    printf(\"Expected %d '1.0' results; got %d in practice\\n\", (int)(N &gt;&gt; 25), count);\n}\n\nint main() {\n    std::mt19937 g(std::random_device{}());\n    auto N = (1uLL &lt;&lt; 29);\n    test(N, [&amp;g]() { return std::uniform_real_distribution&lt;float&gt;(0,1)(g); });\n    test(N, [&amp;g]() { return std::generate_canonical&lt;float, 32&gt;(g); });\n}\n</code></pre>\n<p>Example output:</p>\n<pre><code>Expected 16 '1.0' results; got 19 in practice\nExpected 16 '1.0' results; got 11 in practice\n</code></pre>\n<p>When <code>T</code> is <code>double</code> (53 mantissa bits), we expect to see <code>uniform_real_distribution&lt;double&gt;(0,1)(g) == 1.0</code> about 1 in 2^54 times. I don't have the patience to test this expectation. :)</p>\n<p>My understanding is that this behavior is fine. It may offend our sense of \"half-open-rangeness\" that a distribution claiming to return numbers \"less than 1.0\" can in fact return numbers that are <em>equal</em> to <code>1.0</code>; but those are two different meanings of \"1.0\", see? The first is the <em>mathematical</em> 1.0; the second is the IEEE single-precision floating-point number <code>1.0</code>. And we've been taught for decades not to compare floating-point numbers for exact equality.</p>\n<p>Whatever algorithm you feed the random numbers into isn't going to care if it sometimes gets exactly <code>1.0</code>. There's nothing you can <em>do</em> with a floating-point number except mathematical operations, and as soon as you do some mathematical operation, your code will have to deal with rounding. Even if you <em>could</em> legitimately assume that <code>generate_canonical&lt;float,1000&gt;(g) != 1.0f</code>, you <em>still</em> wouldn't be able to assume that <code>generate_canonical&lt;float,1000&gt;(g) + 1.0f != 2.0f</code> \u2014 because of rounding. You just can't get away from it; so why would we pretend in this single instance that you can?</p>\n", "LastActivityDate": "2017-09-03T05:16:04.670", "CommentCount": "2", "CreationDate": "2017-09-03T05:16:04.670", "ParentId": "25668600", "Score": "-2", "OwnerUserId": "1424877"}});