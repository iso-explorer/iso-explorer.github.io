post_cb({"8425199": {"ParentId": "8424260", "LastEditDate": "2011-12-08T02:01:50.340", "CommentCount": "1", "CreationDate": "2011-12-08T01:54:43.047", "OwnerUserId": "224671", "LastEditorUserId": "224671", "PostTypeId": "2", "Id": "8425199", "Score": "3", "Body": "<p>For <code>ios_base</code> itself, no. <code>showpos</code> and <code>showbase</code> calls the single-argument <code>setf</code> (\u00a727.5.6.1[fmtflags.manip]/5 and /13) on the stream, which the two does not affect each other.</p>\n<hr>\n<p>Going deeper, a <code>std::ostream</code> uses the <code>locale::facet::put</code> function to print an integer (\u00a727.7.3.6.2[ostream.inserters.arithmetic]/1), and its implementation <code>locale::facet::do_put</code> \n(\u00a722.4.2.2.2[facet.num.put.virtuals]/5) specifies:</p>\n<blockquote>\n<p id=\"so_8424260_8425199_0\">All tables used in describing stage 1 are ordered. That is, the first line whose condition is true applies. A line without a condition is the default behavior when none of the earlier lines apply.</p>\n<p id=\"so_8424260_8425199_1\">...</p>\n<p id=\"so_8424260_8425199_2\">The conversion specifier has the following optional additional qualifiers prepended as indicated in Table 90.</p>\n<pre>\n                  Table 90 \u2014 Numeric conversions\n\n+-----------------------+-------------------+------------------+\n| Type(s)               | State             | stdio equivalent |\n+=======================+===================+==================+\n|                       | flags &amp; showpos   | +                |\n| an integral type      |                   |                  |\n|                       | flags &amp; showbase  | #                |\n+-----------------------+-------------------+------------------+\n|                       | flags &amp; showpos   | +                |\n| a floating-point type |                   |                  |\n|                       | flags &amp; showpoint | #                |\n+-----------------------+-------------------+------------------+\n\n</pre>\n<p id=\"so_8424260_8425199_3\">...</p>\n<p id=\"so_8424260_8425199_4\">The representations at the end of stage 1 consists of the char\u2019s that would be printed by a call of <code>printf(s, val)</code> where <code>s</code> is the conversion specifier determined above.</p>\n</blockquote>\n<p>Here, we see that <code>showpos</code> and <code>showbase</code> are in the same cell, which, I believe the standard implicitly mean that they're in the same \"line\", and thus <em>both</em> applies (it can be seen from <code>std::cout &lt;&lt; std::showpos &lt;&lt; std::showpoint &lt;&lt; 6.0</code> for the following \"line\"), and the two flags are still not mutually exclusive here.</p>\n<hr>\n<p>So far, we see that <code>showpos</code> and <code>showbase</code> are not exclusive in C++, and the actual formatting behavior is defined by <code>printf</code> <sub><sup>(though the implementation doesn't need to use <code>printf</code>, e.g. libc++ uses <code>sprintf</code>, while libstdc++ does not)</sup></sub>, which we have to check the C standard.</p>\n<p>In C, using <code>+</code> (<code>showpos</code>) with <code>o</code> and <code>x</code>/<code>X</code> (<code>oct</code> and <code>hex</code>) is not defined, because C99 \u00a77.19.6.1/6 and /8 says</p>\n<blockquote>\n<p id=\"so_8424260_8425199_5\"><code>+</code> </p>\n<blockquote>\n<p id=\"so_8424260_8425199_9\">The result of a <strong>signed</strong> conversion always begins with a plus or minus sign. ...  </p>\n</blockquote>\n<p id=\"so_8424260_8425199_7\"><code>o</code>, <code>u</code>, <code>x</code>, <code>X</code></p>\n<blockquote>\n<p id=\"so_8424260_8425199_10\">The <code>unsigned int</code> argument is converted to ...</p>\n</blockquote>\n</blockquote>\n<p>The argument is <em>not signed</em>, so the <code>+</code> cannot apply. The behavior is not written out, so it is undefined.</p>\n<p>Adding <code>#</code> (<code>showbase</code>) to <code>d</code> (<code>dec</code>) is also undefined behavior, as clause /6 says:</p>\n<blockquote>\n<p id=\"so_8424260_8425199_11\"><code>#</code></p>\n<blockquote>\n<p id=\"so_8424260_8425199_13\">The result is converted to an \u201calternative form\u201d. For <code>o</code> conversion, ... For <code>x</code> (or <code>X</code>) conversion, ... For <code>a</code>, <code>A</code>, <code>e</code>, <code>E</code>, <code>f</code>, <code>F</code>, <code>g</code>, and <code>G</code> conversions, ... For <code>g</code> and <code>G</code> conversions, ... <strong>For other conversions, the behavior is undefined.</strong></p>\n</blockquote>\n</blockquote>\n<p>Oops. </p>\n<p>Therefore, not only the two flags are not mutually exclusive, the output is not defined at all. Scenarios 2 and 3 OP mentioned may happen. In gcc and clang, the conflicting option (<code>showpos</code> for <code>oct</code> and <code>hex</code>; <code>showbase</code> for <code>dec</code>) are simply ignored, which gives one an illusion of the two options being mutually exclusive, but the standard will not guarentee that.</p>\n<p>(Disclaimer: I am using n3242 and n1124 as reference, the final standard might not be exactly the same)</p>\n</hr></hr>", "LastActivityDate": "2011-12-08T02:01:50.340"}, "bq_ids": {"n4140": {"so_8424260_8425199_2": {"section_id": 6549, "quality": 0.8, "length": 8}, "so_8424260_8425199_0": {"section_id": 6549, "quality": 0.9523809523809523, "length": 20}, "so_8424260_8425199_4": {"section_id": 6549, "quality": 0.9375, "length": 15}}, "n3337": {"so_8424260_8425199_2": {"section_id": 6304, "quality": 0.8, "length": 8}, "so_8424260_8425199_0": {"section_id": 6304, "quality": 0.9523809523809523, "length": 20}, "so_8424260_8425199_4": {"section_id": 6304, "quality": 0.9375, "length": 15}}, "n4659": {"so_8424260_8425199_2": {"section_id": 8031, "quality": 0.8, "length": 8}, "so_8424260_8425199_0": {"section_id": 8031, "quality": 0.9523809523809523, "length": 20}, "so_8424260_8425199_4": {"section_id": 8031, "quality": 0.9375, "length": 15}}}, "8424260": {"CommentCount": "0", "ViewCount": "324", "CreationDate": "2011-12-07T23:38:41.247", "LastActivityDate": "2015-03-30T17:21:46.523", "PostTypeId": "1", "AcceptedAnswerId": "8425199", "FavoriteCount": "2", "Title": "Are std::showbase and std::showpos mutually exclusive?", "Id": "8424260", "Score": "5", "Body": "<p>This question arose from a discussion I was having about the correct way to output a numeric value using the usual <code>ostream &amp; operator &lt;&lt; (ostream &amp;, some_type)</code> for a numeric type in C++.</p>\n<p>The way I'm familiar with the behavior of std::showbase and std::showpos in each base, they are basically mutually exclusive. That is: in decimal no base is shown, and the '+' is added on positive numbers; whereas in hexadecimal or octal, the base is shown, but a '+' is not shown (nor is a minus), as the value of the type is printed as if it's cast to an unsigned type.</p>\n<p>For example, this simple (verbose) program:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main() {\n  std::cout &lt;&lt; std::dec &lt;&lt; std::showpos &lt;&lt; std::showbase &lt;&lt; int64_t(+5) &lt;&lt; std::endl;\n  std::cout &lt;&lt; std::oct &lt;&lt; std::showpos &lt;&lt; std::showbase &lt;&lt; int64_t(+5) &lt;&lt; std::endl;\n  std::cout &lt;&lt; std::hex &lt;&lt; std::showpos &lt;&lt; std::showbase &lt;&lt; int64_t(+5) &lt;&lt; std::endl;\n  std::cout &lt;&lt; std::dec &lt;&lt; std::showpos &lt;&lt; std::showbase &lt;&lt; int64_t(-5) &lt;&lt; std::endl;\n  std::cout &lt;&lt; std::oct &lt;&lt; std::showpos &lt;&lt; std::showbase &lt;&lt; int64_t(-5) &lt;&lt; std::endl;\n  std::cout &lt;&lt; std::hex &lt;&lt; std::showpos &lt;&lt; std::showbase &lt;&lt; int64_t(-5) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Gives this output when compiled with GCC:</p>\n<pre><code>+5\n05\n0x5\n-5\n01777777777777777777773\n0xfffffffffffffffb\n</code></pre>\n<p>This is what I've always expected, having used C++ for many years, but is this really guaranteed by the standard, or is this just common behavior? For example, could a standard-compliant C++ compiler output one of these sequences instead?</p>\n<pre><code>+5\n+05\n+0x5\n-5\n01777777777777777777773\n0xfffffffffffffffb\n</code></pre>\n<p>or even:</p>\n<pre><code>+5\n+05\n+0x5\n-5\n-05\n-0x5\n</code></pre>\n", "Tags": "<c++><iostream><ostream>", "OwnerUserId": "631429", "AnswerCount": "2"}, "8424635": {"ParentId": "8424260", "LastEditDate": "2015-03-30T17:21:46.523", "CommentCount": "1", "CreationDate": "2011-12-08T00:27:36.430", "OwnerUserId": "16800", "LastEditorUserId": "608639", "PostTypeId": "2", "Id": "8424635", "Score": "0", "Body": "<p>Bit of googling found me <a href=\"http://faculty.cs.niu.edu/~mcmahon/CS241/c241man/node83.html\" rel=\"nofollow\">this page</a> which says the following on the subject:</p>\n<blockquote>\n<p id=\"so_8424260_8424635_0\">Note that negative integers are not printed as such in octal or hexadecimal. Rather, the internal bit patterns are interpreted as always being positive values.</p>\n</blockquote>\n<p><em>If</em> this is accurate, it would make sense that <code>showpos</code> would do nothing, why show a <code>+</code> in front of a number that is always positive?</p>\n", "LastActivityDate": "2015-03-30T17:21:46.523"}});