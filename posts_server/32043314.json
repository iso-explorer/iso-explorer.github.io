post_cb({"32043314": {"CommentCount": "27", "ViewCount": "205", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-08-17T05:26:38.517", "LastActivityDate": "2015-08-19T00:14:54.913", "Title": "Overwriting an object with an object of same type", "FavoriteCount": "0", "LastEditDate": "2017-05-23T11:45:54.820", "Id": "32043314", "Score": "3", "Body": "<p>Is the following well defined?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string.h&gt;\n\nusing namespace std;\n\nstruct Const {\n    const int i; \n    Const (int i) : i(i) {}\n    int get0() { return 0; } // best accessor ever!\n};\n\nint main() {\n    Const *q,*p = new Const(1);\n    new (p) Const(2);\n    memcpy (&amp;q, &amp;p, sizeof p);\n    cout &lt;&lt; q-&gt;i;\n    return 0;\n}\n</code></pre>\n<p>Note that after construction of second <code>Const</code>, <code>p</code> doesn't semantically (intentionally?) points to new object, and the first is gone, so it is usable \"as a <code>void*</code>\". But the second object is constructed at the exact same address, so the bit pattern of <code>p</code> represents the address of the new object.</p>\n<p>COMMENT</p>\n<p><strong><code>new (p) Const(2)</code> erase the old object stored at <code>p</code></strong>, so the pointer is not valid anymore, except as a pointer to storage (<code>void*</code>).</p>\n<p>I want to recover the value of <code>p</code> as a <code>Const*</code>.</p>\n<p>COMMENT 2</p>\n<p>After either <code>p-&gt;~Const()</code> or <code>memset (p, 0, sizeof *p)</code> it is clear that <code>p</code> does not point to a valid object, so <code>p</code> can only be used as pointer to storage (<code>void*</code> or <code>char*</code>), for example to reconstruct another object. At that point <code>p-&gt;get0()</code> is not allowed.</p>\n<p>Here the demolition of the old object is done by the constructor of the new one, but I don't think that makes a difference. </p>\n<p>My intuition is that: <strong>In any case, the old object is gone, and <code>p</code> points to the old object, not the new one.</strong></p>\n<p>I am looking for a <em>confirmation or refutation</em> based on the standard.</p>\n<p>SEE ALSO</p>\n<p>I have asked essentially the same question about pointers, in C and C++ :</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/32043795/dereferencing-an-out-of-bound-pointer-that-contains-the-address-of-an-object-ar\">Dereferencing an out of bound pointer that contains the address of an object (array of array)</a></li>\n<li><a href=\"https://stackoverflow.com/questions/32048698/is-memcpy-of-a-pointer-the-same-as-assignment\">Is memcpy of a pointer the same as assignment?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/32045888/are-pointer-variables-just-integers-with-some-operators-or-are-they-mystical\">Are pointer variables just integers with some operators or are they \"mystical\"?</a></li>\n</ul>\n<p>Please read these discussions before answering \"this is ridiculous\".</p>\n", "Tags": "<c++><const><language-lawyer><memcpy><placement-new>", "OwnerUserId": "963864", "AnswerCount": "2"}, "32043636": {"CommentCount": "28", "CreationDate": "2015-08-17T05:58:17.343", "CommunityOwnedDate": "2015-08-17T08:28:49.633", "LastEditorUserId": "410767", "LastActivityDate": "2015-08-17T08:28:49.633", "ParentId": "32043314", "PostTypeId": "2", "LastEditDate": "2015-08-17T08:28:49.633", "Id": "32043636", "Score": "4", "Body": "<p>(making community-wiki as incorporating dyp's comment re 3.8/7 is very significant; while my earlier analysis was correct I would have said much the same things about code that was broken, having overlooked 3.8/7 myself)</p>\n<pre><code>Const *q,*p = new Const(1);\nnew (p) Const(2);\n</code></pre>\n<p>The <code>new(p) Const(2);</code> line overwrites the object that had been constructed with <code>Const(1)</code>.</p>\n<pre><code>memcpy (&amp;q, &amp;p, sizeof p);\n</code></pre>\n<p>This is equivalent to <code>q = p;</code>.</p>\n<pre><code>cout &lt;&lt; q-&gt;i;\n</code></pre>\n<p>This accesses the <code>q-&gt;i</code> member, which will be <code>2</code>.</p>\n<p>The somewhat noteworthy things are:</p>\n<ul>\n<li><code>std::memcpy</code> is an ugly way to assign <code>p</code> to <code>q</code>... it is legal though under 3.9/3:</li>\n</ul>\n<blockquote>\n<p id=\"so_32043314_32043636_0\">For any trivially copyable type <code>T</code>, if two pointers to <code>T</code> point to distinct <code>T</code> objects <code>obj1</code> and <code>obj2</code>, where neither <code>obj1</code> nor <code>obj2</code> is a base-class subobject, if the underlying bytes (1.7) making up <code>obj1</code> are copied into <code>obj2</code>, <code>obj2</code> shall subsequently hold the same value as <code>obj1</code>. [ Example:</p>\n</blockquote>\n<pre><code>T* t1p;\nT* t2p;\n// provided that t2p points to an initialized object ...\nstd::memcpy(t1p, t2p, sizeof(T));\n// at this point, every subobject of trivially copyable type in *t1p contains\n// the same value as the corresponding subobject in *t2p\n</code></pre>\n<ul>\n<li><p>The overwriting of the old <code>Const(1)</code> object with <code>Const(2)</code> is allowed as long as the program doesn't depend on side effects of the former's destructor, which it doesn't.</p></li>\n<li><p>(as dyp noted in comments below) ongoing access to the <code>Const(2)</code> object using <code>p</code> is illegal under 3.8/7's third point:</p></li>\n</ul>\n<blockquote>\n<p id=\"so_32043314_32043636_1\">pointer that pointed to the original object [...] can be used to manipulate the new object, if...</p>\n<ul>\n<li>the type of the original object is not <code>const</code>-qualified, and, if a class type, does not contain any non-static data member whose type is <code>const</code>-qualified or a reference type ...</li>\n</ul>\n</blockquote>\n<ul>\n<li>using <code>q</code> - rather than <code>p</code> - to access <code>i</code> is presumably necessary to avoid compiler optimisations based on presumed knowledge of <code>i</code>.</li>\n</ul>\n<p>As for your commentary:</p>\n<blockquote>\n<p id=\"so_32043314_32043636_2\">Note that after construction of second <code>Const</code>, <code>p</code> doesn't semantically (intentionally?) points to new object, and the first is gone, so it is usable \"as a <code>void*</code>\".</p>\n</blockquote>\n<p>Given you placement-new an object at the address contained in <code>p</code>, <code>p</code> most certainly does point to the newly created object, and very intentionally, but it can't be used to manipulate that object under 3.8/7 as above.</p>\n<p>Given you seem to have a notion of \"semantically pointing\" that's not defined in C++ the truth of that part of the statement's in your own mind.</p>\n<p>'after construction of second <code>Const</code>, <code>p</code>...<em>is usable \"as a <code>void*</code>'</em> makes no sense... it's not more usable as anything than it was beforehand.</p>\n<blockquote>\n<p id=\"so_32043314_32043636_3\">But the second object is constructed at the exact same address, so the bit pattern of <code>p</code> represents the address of the new object.</p>\n</blockquote>\n<p>Of course, but your comments show you think \"bit pattern\" is somehow distinct from the <em>value</em> of the pointer as applies to assignment with <code>=</code>, which is not true.</p>\n<blockquote>\n<p id=\"so_32043314_32043636_4\"><code>new (p) Const(2)</code> erase the old object stored at <code>p</code>, so the pointer is not valid anymore, except as a pointer to storage (<code>void*</code>).</p>\n</blockquote>\n<p>\"erase\" is a strange term for it... overwrites would be more meaningful.  As dyp noted and explained above, 3.8/7 says you shouldn't \"manipulate\" the object <code>p</code> points to after the placement new, but the value and type of the pointer are unaffected by the placmeent new.  Much as you can call <code>f(void*)</code> with a pointer to any type, the placement-<code>new</code> doesn't need to know or care about the type of the <code>p</code> expression.</p>\n<blockquote>\n<p id=\"so_32043314_32043636_5\">After either <code>p-&gt;~Const()</code> or <code>memset (p, 0, sizeof *p)</code> it is clear that <code>p</code> does not point to a valid object, so <code>p</code> can only be used as pointer to storage (<code>void*</code> or <code>char*</code>), for example to reconstruct another object. At that point <code>p-&gt;get0()</code> is not allowed.</p>\n</blockquote>\n<p>Most of that's true, if by \"<code>p</code> can only be used\" you mean the value of <code>p</code> at that time rather than the pointer itself (which can be of course also be assigned to).  And you're trying to be a little too clever with the <code>void*</code> / <code>char*</code> thing - <code>p</code> remains a <code>Const*</code>, even if it's only used by placement new which doesn't care about the pointee type.</p>\n<blockquote>\n<p id=\"so_32043314_32043636_6\">\"I want to recover the value of <code>p</code> as a <code>Const*</code>.\" </p>\n</blockquote>\n<p>The value of <code>p</code> was not changed after it was first initialised.  placement-<code>new</code> uses the value - it does not modify it.  There's nothing to recover as nothing was lost.  That said, dyp's highlighted the need not to use <code>p</code> to manipulate the object, so while the value wasn't lost it's not directly usable as wanted either.</p>\n", "OwnerUserId": "410767"}, "32044054": {"ParentId": "32043314", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2015-08-17T06:32:41.827", "Score": "3", "LastEditorUserId": "1116364", "LastEditDate": "2015-08-19T00:14:54.913", "Id": "32044054", "OwnerUserId": "1116364", "Body": "<p>This is only intended as an addendum to @Tony D's answer, regarding</p>\n<blockquote>\n<p id=\"so_32043314_32044054_0\"><code>new (p) Const(2)</code> erase the old object stored at <code>p</code></p>\n</blockquote>\n<p>I think you need to differentiate between an object and the conceptual idea of an \"instance\".</p>\n<blockquote>\n<p id=\"so_32043314_32044054_1\">[...] An object is a region of storage.[...]</p>\n<p id=\"so_32043314_32044054_2\">[N4431 \u00a71.8/1]</p>\n</blockquote>\n<p>So the pointer <code>p</code> points to a region of storage, which contains the bit pattern of some \"instance\" before the placement new and some different bit pattern of a different, but well constructed \"instance\" of the correct (same) type.</p>\n<p>So at the location pointed to by <code>p</code> there's a valid object, and when assigning <code>q</code> from it <code>q</code> points to it. Though as noted in the other answer, accessing it via <code>p</code> isn't permited.</p>\n", "LastActivityDate": "2015-08-19T00:14:54.913"}, "bq_ids": {"n4140": {"so_32043314_32043636_0": {"section_id": 7201, "quality": 0.9375, "length": 30}, "so_32043314_32043636_1": {"section_id": 7195, "quality": 1.0, "length": 8}}, "n3337": {"so_32043314_32043636_0": {"section_id": 6945, "quality": 0.9375, "length": 30}, "so_32043314_32043636_1": {"section_id": 6939, "quality": 1.0, "length": 8}}, "n4659": {"so_32043314_32043636_1": {"section_id": 8704, "quality": 1.0, "length": 8}, "so_32043314_32043636_0": {"section_id": 8710, "quality": 0.9375, "length": 30}}}});