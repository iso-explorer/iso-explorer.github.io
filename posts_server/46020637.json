post_cb({"bq_ids": {"n4140": {"so_46020637_46025291_3": {"length": 6, "quality": 1.0, "section_id": 7028}, "so_46020637_46020924_0": {"length": 14, "quality": 0.875, "section_id": 7026}, "so_46020637_46025291_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 7026}, "so_46020637_46025291_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 5440}, "so_46020637_46025291_2": {"length": 9, "quality": 0.9, "section_id": 7027}}, "n3337": {"so_46020637_46025291_3": {"length": 6, "quality": 1.0, "section_id": 6774}, "so_46020637_46020924_0": {"length": 14, "quality": 0.875, "section_id": 6772}, "so_46020637_46025291_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 6772}, "so_46020637_46025291_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 5235}, "so_46020637_46025291_2": {"length": 9, "quality": 0.9, "section_id": 6773}}, "n4659": {"so_46020637_46025291_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 8525}, "so_46020637_46020924_0": {"length": 15, "quality": 0.9375, "section_id": 8523}, "so_46020637_46025291_1": {"length": 15, "quality": 0.8823529411764706, "section_id": 8523}, "so_46020637_46025291_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 6867}, "so_46020637_46025291_2": {"length": 9, "quality": 0.9, "section_id": 8524}}}, "46020637": {"ViewCount": "289", "Body": "<p><br>\nI am not asking <code>decltype((x))</code>, I know how it works.<br>\n<br>\nAccording to the draft N4687, \u00a7 10.1.7.2<br/></br></br></br></p>\n<pre><code>    4 For an expression e, the type denoted by decltype(e) is defined as follows:\n        ...\n(4.2)   \u2014 otherwise, if e is an unparenthesized id-expression or an unparenthesized class\n          member access (8.2.5), decltype(e) is the type of the entity named by e. If\n          there is no such entity, or if e names a set of overloaded functions, the\n          program is ill-formed;\n        ...\n</code></pre>\n<p>And example<br/></p>\n<pre><code>struct A { double x; };\nconst A* a = new A();\ndecltype(a-&gt;x) x3; // type is double\n</code></pre>\n<p>My question is,<br>\n<code>a-&gt;x</code> is <code>const double</code>, but why does x3 is <code>double</code>? where does the <code>const</code> go?<br>\nBTW, what is <code>decltype(e) is the type of the entity named by e</code> meaning exactly?</br></br></p>\n", "Title": "c++11 decltype(e) is the type of the entity named by e", "CreationDate": "2017-09-03T05:40:01.290", "LastActivityDate": "2017-09-03T16:00:06.350", "CommentCount": "12", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-09-03T06:00:03.633", "LastEditorUserId": "5642738", "Id": "46020637", "Score": "10", "OwnerUserId": "5642738", "Tags": "<c++><c++11><language-lawyer><decltype>", "AnswerCount": "3"}, "46020732": {"Id": "46020732", "PostTypeId": "2", "Body": "<p>The \"entity\" named by a class member access expression is that class member, in this case, <code>A::x</code>.</p>\n<p>The type of <code>A::x</code> is <code>double</code>.</p>\n", "LastActivityDate": "2017-09-03T05:57:39.353", "CommentCount": "3", "CreationDate": "2017-09-03T05:57:39.353", "ParentId": "46020637", "Score": "1", "OwnerUserId": "2756719"}, "46025291": {"Id": "46025291", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_46020637_46025291_0\">N4687 [dcl.type.simple] \u00b64.2 ...if <code>e</code> is an unparenthesized <em>id-expression</em> or an unparenthesized class member access, <code>decltype(e)</code> is the type of the entity named by <code>e</code>.</p>\n</blockquote>\n<p>A class member access is either <code>.</code> or <code>-&gt;</code>, according to [expr.ref].</p>\n<blockquote>\n<p id=\"so_46020637_46025291_1\">[basic] \u00b63 An <em>entity</em> is a value, object, reference, function, enumerator, type, class member, bit-field, template, template specialization, namespace, or parameter pack.</p>\n<p id=\"so_46020637_46025291_2\">\u00b64 A <em>name</em> is a use of an <em>identifier</em>, <em>operator-function-id</em>, <em>literal-operator-id</em>, <em>conversionfunction-id</em>, or <em>template-id</em> that denotes an entity or label.</p>\n<p id=\"so_46020637_46025291_3\">\u00b65 Every name that denotes an entity is introduced by a <em>declaration</em>.</p>\n</blockquote>\n<p>There is an ambiguity here: <code>a-&gt;x</code> is both a class member and an object (a member subobject). The important thing to note is that <code>decltype(e)</code> is the type of the entity <strong>named by</strong> <code>e</code>. The only kinds of entities that can be <strong>named</strong> are those that are introduced by declarations (\u00b65). A member subobject does not have a name in this sense, as it is not declared. That leaves the only other alternative that <code>decltype(x-&gt;a)</code> must be the type of the class member (not the object member).</p>\n", "LastActivityDate": "2017-09-03T16:00:06.350", "CommentCount": "0", "CreationDate": "2017-09-03T16:00:06.350", "ParentId": "46020637", "Score": "3", "OwnerUserId": "1639256"}, "46020924": {"Id": "46020924", "PostTypeId": "2", "Body": "<p>The standard seems ambiguous im this area.</p>\n<blockquote>\n<p id=\"so_46020637_46020924_0\">An <em>entity</em> is a value, object, reference, function, enumerator, type, class member, bit-field, template, template specialization, namespace, or parameter pack.</p>\n</blockquote>\n<p>The expression <code>a-&gt;x</code> can be said to name a <em>member</em> <code>x</code> of <code>struct A</code>, which has type <code>double</code>. The same expression can also be said to name an <em>object</em> which has type <code>const double</code>. Both of these things are entities. The normative text doesn't make it absolutely clear that the intended interpretation is the first one, it can only be inferred from the example.</p>\n", "LastEditorUserId": "775806", "LastActivityDate": "2017-09-03T07:18:40.653", "Score": "6", "CreationDate": "2017-09-03T06:36:24.947", "ParentId": "46020637", "CommentCount": "8", "OwnerUserId": "775806", "LastEditDate": "2017-09-03T07:18:40.653"}});