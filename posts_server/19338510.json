post_cb({"19338860": {"ParentId": "19338510", "LastEditDate": "2013-10-12T20:42:15.847", "CommentCount": "2", "CreationDate": "2013-10-12T20:26:37.913", "OwnerUserId": "420683", "LastEditorUserId": "420683", "PostTypeId": "2", "Id": "19338860", "Score": "2", "Body": "<p>I don't see any (N)RVO in your example. RVO, or copy/move elision, is <em>allowed</em> but not mandated in [class.copy]/31. Here are some examples:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    A(int i) { std::cout &lt;&lt; \"ctor\\n\"; }\n    ~A() { std::cout &lt;&lt; \"dtor\\n\"; }\n    A&amp; operator=(A const&amp;)\n    { std::cout &lt;&lt; \"copy-assignment-op\\n\"; return *this; }\n\n    // N.B. no default move ctor will be created!\n};\n\nA foo() { return 42; }\nA bar() { return A(42); }\n\nconst A cfoo() { return 42; }\nconst A cbar() { return A(42); }\n\nint main()\n{\n    std::cout &lt;&lt; \"A a(42);\\n\";\n    A a(42);\n    std::cout &lt;&lt; \"\\na = foo();\\n\";\n    a = foo();\n    std::cout &lt;&lt; \"\\na = bar();\\n\";\n    a = bar();\n\n    std::cout &lt;&lt; \"\\nA b( foo() );\\n\";\n    A b( foo() );\n    std::cout &lt;&lt; \"\\nA c( bar() );\\n\";\n    A c( bar() );\n\n    std::cout &lt;&lt; \"\\nA d( cfoo() );\\n\";\n    A d( cfoo() );\n    std::cout &lt;&lt; \"\\nA e( cbar() );\\n\";\n    A e( cbar() );\n\n    std::cout &lt;&lt; \"\\ndtors following for a, b, c, d, e\\n\";\n}\n</code></pre>\n<p>The output on most recent compilers (on many even at <code>-O0</code>) is:</p>\n<pre>A a(42);\nctor\n\na = foo();\nctor\ncopy-assignment-op\ndtor\n\na = bar();\nctor\ncopy-assignment-op\ndtor\n\nA b( foo() );\nctor\n\nA c( bar() );\nctor\n\nA d( cfoo() );\nctor\n\nA e( cbar() );\nctor\n\ndtors following for a, b, c, d, e\ndtor\ndtor\ndtor\ndtor\ndtor\n</pre>\n<p>As you can see, whether the return type is <code>const</code> or not doesn't affect RVO. However, it could, as it isn't mandated. So if you have an old / weird compiler -- test it (or look up in the documentation).</p>\n<hr>\n<p>There are two kinds of RVO in the example above:</p>\n<ol>\n<li><p>copy/move elision of an object with automatic storage duration to the return value (also called NRVO), such as</p>\n<pre><code>A foo() { A a; return a; }\n</code></pre>\n<p>[class.copy]/31 Allows this</p>\n<blockquote>\n<p id=\"so_19338510_19338860_0\">in a <code>return</code> statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (other than a function or catch-clause parameter) with the same cv-unqualified type as the function return type</p>\n</blockquote></li>\n<li><p>copy/move elision of a temporary to another object</p>\n<pre><code>A a( foo() ); // only 1 ctor is called\nA foo() { return A(); } // no copy/move from the temporary to the return value\n</code></pre>\n<p>this is allowed</p>\n<blockquote>\n<p id=\"so_19338510_19338860_1\">when a temporary class object that has not been bound to a reference (12.2) would be copied/moved to a class object with the same cv-unqualified type</p>\n</blockquote></li>\n</ol>\n<p>Where \"cv-unqualified\" (probably) means that the top-level <code>const</code> qualified is ignored for this kind of optimization.</p>\n</hr>", "LastActivityDate": "2013-10-12T20:42:15.847"}, "19338707": {"ParentId": "19338510", "CommentCount": "9", "Body": "<p>In BOTH of the cases of </p>\n<pre><code>std::string getName();\n</code></pre>\n<p>and</p>\n<pre><code>const std::string getName();\n</code></pre>\n<p>there will be a copy of a string made. However, as long as you write (something like):</p>\n<pre><code>std::string name;\n...\nname = getName();\n</code></pre>\n<p>it will make ABSOLUTELY no difference if <code>getName()</code>'s return type is const or not const, and the compiler will optimise the copy and just copy the internal value inside <code>getName</code> directly to the <code>name</code> variable without making a temporary copy. </p>\n<p>However, if you, instead, return a reference:</p>\n<pre><code>std::string&amp; getName();\n</code></pre>\n<p>or</p>\n<pre><code>const std::string&amp; getName();\n</code></pre>\n<p>it makes a BIG difference, since the first form will let you do:</p>\n<pre><code>getName() = \"Mats\";\n</code></pre>\n<p>which is probably not what you would WANT the user of the interface to do. </p>\n<p>To me, it seems like the reviewers are confusing those two variants. </p>\n", "OwnerUserId": "1919155", "PostTypeId": "2", "Id": "19338707", "Score": "1", "CreationDate": "2013-10-12T20:09:44.373", "LastActivityDate": "2013-10-12T20:09:44.373"}, "bq_ids": {"n4140": {"so_19338510_19338860_0": {"section_id": 480, "quality": 1.0, "length": 23}, "so_19338510_19338860_1": {"section_id": 480, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_19338510_19338860_0": {"section_id": 471, "quality": 1.0, "length": 23}, "so_19338510_19338860_1": {"section_id": 471, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_19338510_19338860_0": {"section_id": 502, "quality": 0.9130434782608695, "length": 21}, "so_19338510_19338860_1": {"section_id": 502, "quality": 0.5333333333333333, "length": 8}}}, "19338510": {"CommentCount": "4", "ViewCount": "88", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-10-12T19:50:29.797", "LastActivityDate": "2013-10-13T19:51:42.953", "Title": "Do CV qualifiers affect copy elision of returned objects?", "AcceptedAnswerId": "19338860", "LastEditDate": "2017-05-23T11:57:20.053", "Id": "19338510", "Score": "1", "Body": "<p>This is a possible duplicate of <a href=\"https://stackoverflow.com/questions/1579435/should-useless-type-qualifiers-on-return-types-be-used-for-clarity\" title=\"this question\">this question</a>, but the example under discussion there dealt with a builtin type (<code>int</code>). In my current job, I keep getting flagged in code reviews for failing to declare functions like this:</p>\n<pre><code>std::string getName();\n</code></pre>\n<p>as:</p>\n<pre><code>const std::string getName();\n</code></pre>\n<p>The latter seems meaningless to me, but a few of my colleagues feel that the <code>const</code> qualifier may afford the compiler a chance to avoid making a copy of the returned value (or some similar optimization). I ran <code>gcc -s</code> on this small test program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nconst std::string name()\n{\n    return \"World\";\n}\n\nint main()\n{\n    std::cout &lt;&lt; \"Hello, \" &lt;&lt; name() &lt;&lt; '!' &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>and the assembly produced is identical if I remove the <code>const</code> from the <code>name()</code> function. However, my colleagues suggest that the optimization (if any) afforded by the <code>const</code> qualifier may be platform-/compiler-specific, so it's better to tack on <code>const</code> 'just in case'. I'm reticent to adopt this habit because I haven't managed to find any code in the wild that does this.</p>\n<p>So my question is a two-parter:</p>\n<ol>\n<li>Does the <code>const</code> qualifer in the above example make any difference?</li>\n<li>Would it matter if the returned value were an instance of some <code>class Foo</code> instead of <code>std::string</code>?</li>\n</ol>\n<p>My colleagues are quite reasonable people and are open to the idea that this is a quaint convention that has crept into our code base more-or-less by accident. But nobody is sure enough about this particular usage that they're willing to say it's completely unnecessary.</p>\n", "Tags": "<c++>", "OwnerUserId": "99127", "AnswerCount": "2"}});