post_cb({"25144037": {"ParentId": "25143860", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This is a difference between C++11 and C++14; clang correctly accepts it in C++14 mode (<code>-std=c++1y</code>) and rejects it in C++11 mode (<code>-std=c++11</code>), while gcc is incorrect to accept it in C++11 mode.</p>\n<p>The behavior of <code>switch</code> statements was changed by paper <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3323.pdf\">n3323</a>, which landed after the C++11 standard was finalized.</p>\n<p><strong>[stmt.switch]</strong>, in C++11:</p>\n<blockquote>\n<p id=\"so_25143860_25144037_0\">2 - The condition shall be of integral type, enumeration type, or of a class type for which <strong>a single non-explicit conversion function</strong> to integral or enumeration type exists (12.3). [...]</p>\n</blockquote>\n<p>In n3936 (wording per n3323):</p>\n<blockquote>\n<p id=\"so_25143860_25144037_1\">2 - The condition shall be of integral type, enumeration type, or class type. If of class type, the condition is <strong>contextually implicitly converted</strong> (Clause 4) to an integral or enumeration type.</p>\n</blockquote>\n<p>Contextual implicit conversion is a variant of implicit conversion (i.e. the declaration <code>T t = e</code> is required to be well-formed); for contextual implicit conversion to be well-formed the class type <code>E</code> is allowed to have multiple conversion functions, but all those valid in the context must have the same return type modulo <em>cv</em> and reference qualification: <strong>[conv]</strong></p>\n<blockquote>\n<p id=\"so_25143860_25144037_2\">5 - [...] <code>E</code> is searched for conversion functions whose return type is <em>cv</em> <code>T</code> or\n  reference to <em>cv</em> <code>T</code> such that <code>T</code> is allowed by the context. There shall be exactly one such <code>T</code>.</p>\n</blockquote>\n<p>In a <code>switch</code> statement, contextual implicit conversion is <em>to an integral or enumeration type</em>, so <code>C</code> must have at least one non-<code>explicit</code> conversion function to <em>cv</em> integral or enumeration type or reference to <em>cv</em> integral or enumeration type, and <em>all</em> its conversion functions to <em>cv</em> integral or enumeration type or reference to <em>cv</em> integral or enumeration type must have that same underlying type.</p>\n<p>A pretty nice workaround (as mentioned in n3323) is to use unary plus to coerce the argument of the <code>switch</code> statement to arithmetic type:</p>\n<pre><code>  switch (+c) {\n    // ...\n</code></pre>\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2014-08-05T20:26:38.413", "Id": "25144037", "Score": "17", "CreationDate": "2014-08-05T16:38:01.717", "LastActivityDate": "2014-08-05T20:26:38.413"}, "25143860": {"CommentCount": "3", "AcceptedAnswerId": "25144037", "PostTypeId": "1", "LastEditorUserId": "3550406", "CreationDate": "2014-08-05T16:26:58.487", "LastActivityDate": "2014-08-07T20:45:03.030", "LastEditDate": "2014-08-05T19:01:55.253", "ViewCount": "896", "FavoriteCount": "2", "Title": "implicit conversion from class to enumeration type in switch conditional", "Id": "25143860", "Score": "18", "Body": "<p>g++ 4.9.0 accepts the following code:</p>\n<pre><code>enum E { foo };\n\nstruct C {\n  operator E() const { return foo; }\n  operator E() { return foo; }\n};\n\nint main() {\n  C c;\n  switch (c) {\n    case foo: break;\n  }\n}\n</code></pre>\n<p>But clang 3.4.1 rejects it with the following diagnostic:</p>\n<pre><code>12 : error: multiple conversions from switch condition type 'C' to an integral or enumeration type\nswitch (c)\n^ ~\n5 : note: conversion to enumeration type 'E'\noperator E() const { return foo; }\n^\n6 : note: conversion to enumeration type 'E'\noperator E() { return foo; }\n^\n</code></pre>\n<p>Which one is correct? Is it a clang bug, g++ bug, libstdc++ bug, standard defect, or other? Did I do something stupid?</p>\n<p>In the code which triggered this question, <code>C</code> is <code>std::atomic&lt;E&gt;</code>, and <code>std::atomic&lt;T&gt;::operator T</code> is overloaded on the cv-qualifiers <code>const</code> and <code>const volatile</code>.</p>\n<p>Both compilers accept <code>E e = c;</code>, so it seems to be something peculiar to the <code>switch</code> statement.</p>\n", "Tags": "<c++><c++11><switch-statement><language-lawyer><implicit-conversion>", "OwnerUserId": "1639256", "AnswerCount": "2"}, "25143950": {"ParentId": "25143860", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I believe <code>clang</code> is correct here, depending on which version of the standard is being used. I usually use <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow noreferrer\">N3485</a> as a C++11 after fixes reference but it could be argued that the change that I noted in <a href=\"https://stackoverflow.com/a/25048219/1708801\">Classes with both template and non-template conversion operators in the condition of switch statement</a> are an addition and thus are actually part of C++1y. </p>\n<p>So going with the contention that <em>contextually implicit conversions</em> is a addition then <code>clang</code> is correct for the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">draft C++11 standard</a>. Due to section <code>6.4.2</code> <em>The switch statement</em> which says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_25143860_25143950_0\">The condition shall be of integral type, enumeration type, or of a\n  class type for which a single non-explicit conversion function to\n  integral or enumeration type exists (12.3).[...]</p>\n</blockquote>\n<p>In C++1y then this should be acceptable code and running this in C++1y mode in <code>clang</code> seems to confirm this is indeed the case (<em><a href=\"http://coliru.stacked-crooked.com/a/b6898ae803273d1f\" rel=\"nofollow noreferrer\">see it live</a></em>).</p>\n<p>We can see from the <a href=\"https://github.com/cplusplus/draft/blob/b7b8ed08ba4c111ad03e13e8524a1b746cb74ec6/papers/N3936.pdf\" rel=\"nofollow noreferrer\">draft C++1y standard</a> section <code>6.4.2</code> <em>The switch statement</em> that this involves a <em>contextually implicit conversion</em>. Paragraph <em>2</em> says:</p>\n<blockquote>\n<p id=\"so_25143860_25143950_1\">The condition shall be of integral type, enumeration type, or class\n  type. If of class type, the condition is <strong>contextually implicitly\n  converted (Clause 4)</strong> to an integral or enumeration type.</p>\n</blockquote>\n<p>We can see the section we need to use is <code>4</code> <em>Standard conversions</em> and paragraph <em>5</em> covers these cases, it says:</p>\n<blockquote>\n<p id=\"so_25143860_25143950_2\">Certain language constructs require conversion to a value having one\n  of a specified set of types appropriate to the construct. An\n  expression e of class type E appearing in such a context is said to be\n  <strong>contextually implicitly converted</strong> to a specified type T and is\n  well-formed if and only if e can be implicitly converted to a type T\n  that is determined as follows: E is searched for conversion functions\n  whose return type is cv T or reference to cv T such that T is allowed\n  by the context. There shall be exactly one such T.</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:53:05.847", "Id": "25143950", "Score": "5", "CreationDate": "2014-08-05T16:32:11.700", "LastActivityDate": "2014-08-07T20:45:03.030"}, "bq_ids": {"n4140": {"so_25143860_25143950_1": {"section_id": 3890, "quality": 0.9444444444444444, "length": 17}, "so_25143860_25144037_1": {"section_id": 3890, "quality": 0.9444444444444444, "length": 17}, "so_25143860_25144037_2": {"section_id": 4, "quality": 1.0, "length": 14}, "so_25143860_25144037_0": {"section_id": 3890, "quality": 0.5882352941176471, "length": 10}, "so_25143860_25143950_0": {"section_id": 3890, "quality": 0.5882352941176471, "length": 10}, "so_25143860_25143950_2": {"section_id": 4, "quality": 0.9782608695652174, "length": 45}}, "n3337": {"so_25143860_25144037_0": {"section_id": 3750, "quality": 0.8823529411764706, "length": 15}, "so_25143860_25143950_1": {"section_id": 3750, "quality": 0.6666666666666666, "length": 12}, "so_25143860_25144037_1": {"section_id": 3750, "quality": 0.6666666666666666, "length": 12}, "so_25143860_25143950_0": {"section_id": 3750, "quality": 0.8823529411764706, "length": 15}}, "n4659": {"so_25143860_25143950_1": {"section_id": 4776, "quality": 0.9444444444444444, "length": 17}, "so_25143860_25144037_1": {"section_id": 4776, "quality": 0.9444444444444444, "length": 17}, "so_25143860_25144037_2": {"section_id": 4, "quality": 1.0, "length": 14}, "so_25143860_25144037_0": {"section_id": 4776, "quality": 0.5882352941176471, "length": 10}, "so_25143860_25143950_0": {"section_id": 4776, "quality": 0.5882352941176471, "length": 10}, "so_25143860_25143950_2": {"section_id": 4, "quality": 0.9782608695652174, "length": 45}}}});