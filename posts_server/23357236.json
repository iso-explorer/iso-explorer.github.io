post_cb({"23357600": {"ParentId": "23357236", "CommentCount": "0", "Body": "<p>The standard does not specify when in the operation of <code>std::function::operator()</code> that the function uses its internal state object.  In practice, some implementations use it after the call.</p>\n<p>So what you did was undefined behaviour, and in particular it crashes.</p>\n<pre><code>struct bob {\n  std::function&lt;void()&gt; task;\n  std::function&lt;void()&gt; next_task;\n  void operator()(){\n    next_task=task;\n    task();\n    task=std::move(next_task);\n  }\n}\n</code></pre>\n<p>now if you want to change what happens when you next invoke <code>bob</code> within <code>bob()</code>, simply set <code>next_task</code>.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "23357600", "Score": "2", "CreationDate": "2014-04-29T06:56:19.287", "LastActivityDate": "2014-04-29T06:56:19.287"}, "23357236": {"CommentCount": "3", "ViewCount": "151", "CreationDate": "2014-04-29T06:35:50.377", "LastActivityDate": "2014-09-13T18:23:37.460", "Title": "Re-assigning an std::function object while inside its execution", "PostTypeId": "1", "Id": "23357236", "Score": "1", "Body": "<p>I have an std::function object I'm using as a callback to some event. I'm assigning a lambda to this object, within which, I assign the object to a different lambda mid execution. I get a segfault when I do this. Is this not something I'm allowed to do? If so, why? And how would I go about achieving this? </p>\n<p>declaration:</p>\n<pre><code>std::function&lt;void(Data *)&gt; doCallback;\n</code></pre>\n<p>calling:</p>\n<pre><code>//\n// This gets called after a sendDataRequest call returns with data\n//\nvoid onIncomingData(Data *data)\n{\n    if ( doCallback )\n    {\n        doCallback(data);\n    }\n}\n</code></pre>\n<p>assignment:</p>\n<pre><code>doCallback =\n    [=](Data *data)\n    {\n        //\n        // Change the callback within itself because we want to do \n        // something else after getting one request  \n        //\n        doCallback =\n            [=](Data *data2)\n            {\n                ... do some work ...\n            };\n        sendDataRequest();\n    };\nsendDataRequest();\n</code></pre>\n", "Tags": "<c++><c++11><lambda><std-function>", "OwnerUserId": "3583654", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_23357236_23365730_1": {"section_id": 444, "quality": 0.9411764705882353, "length": 32}, "so_23357236_23365730_2": {"section_id": 4680, "quality": 0.5714285714285714, "length": 4}, "so_23357236_23365730_0": {"section_id": 444, "quality": 0.9411764705882353, "length": 32}, "so_23357236_23365730_3": {"section_id": 4680, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_23357236_23365730_1": {"section_id": 435, "quality": 0.9411764705882353, "length": 32}, "so_23357236_23365730_2": {"section_id": 4489, "quality": 0.5714285714285714, "length": 4}, "so_23357236_23365730_0": {"section_id": 435, "quality": 0.9411764705882353, "length": 32}, "so_23357236_23365730_3": {"section_id": 4489, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_23357236_23365730_1": {"section_id": 467, "quality": 0.9411764705882353, "length": 32}, "so_23357236_23365730_2": {"section_id": 6051, "quality": 0.5714285714285714, "length": 4}, "so_23357236_23365730_0": {"section_id": 467, "quality": 0.9411764705882353, "length": 32}, "so_23357236_23365730_3": {"section_id": 6051, "quality": 0.5714285714285714, "length": 4}}}, "23365730": {"ParentId": "23357236", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><strong>Short answer</strong></p>\n<p>It depends on whether, after the (re)assignment, the lambda being called accesses any of its non static data members or not. If it does then you get undefined behavior. Otherwise, I believe nothing bad should happen.</p>\n<p><strong>Long answer</strong></p>\n<p>In the OP's example, a lambda object -- denoted here by <code>l_1</code> -- held by a <code>std::function</code> object is invoked and, during its execution, the <code>std::function</code> object is assigned to another lambda -- denoted here by <code>l_2</code>.</p>\n<p>The assignment calls <code>template&lt;class F&gt; function&amp; operator=(F&amp;&amp; f);</code> which, by 20.8.11.2.1/18, has the effects of</p>\n<pre><code>function(std::forward&lt;F&gt;(f)).swap(*this);\n</code></pre>\n<p>where <code>f</code> binds to <code>l_2</code> and <code>*this</code> is the <code>std::function</code> object being assigned to. At this time, the temporary <code>std::function</code> holds <code>l_2</code> and <code>*this</code> holds <code>l_1</code>. After the <code>swap</code> the temporary holds <code>l_1</code> and <code>*this</code> holds <code>l_2</code> (*). Then the temporary is destroyed and so is <code>l_1</code>.</p>\n<p>In summary, while running <code>operator()</code> on <code>l_1</code> this object gets destroyed. Then according to 12.7/1</p>\n<blockquote>\n<blockquote>\n<p id=\"so_23357236_23365730_1\">For an object with a non-trivial constructor, referring to any non-static member or base class of the object before the constructor begins execution results in undefined behavior. <strong>For an object with a non-trivial destructor, referring to any non-static member or base class of the object after the destructor finishes execution results in undefined behavior.</strong></p>\n</blockquote>\n</blockquote>\n<p>Lambdas non static data members correspond its captures. So if you don't access them, then it should be fine.</p>\n<p>There's one more important point raised by <a href=\"https://stackoverflow.com/users/1774667/yakk\">Yakk</a>'s <a href=\"https://stackoverflow.com/a/23357600/1137388\">answer</a>. As far as I understand, the concern was whether <code>std::function::operator()</code>, after having forwarded the call to <code>l_1</code>, tries to access <code>l_1</code> (which is now dead) or not? I don't think this is the case because the effects of <code>std::function::operator()</code> don't imply that. Indeed, 20.8.11.2.4 says that the effect of this call is </p>\n<blockquote>\n<blockquote>\n<p id=\"so_23357236_23365730_3\"><code>INVOKE(f, std::forward&lt;ArgTypes&gt;(args)..., R)</code> (20.8.2), where <code>f</code> is the target object (20.8.1) of <code>*this</code>.</p>\n</blockquote>\n</blockquote>\n<p>which basicallky says that <code>std::function::operator()</code> calls <code>l_1.operator()</code> and does nothing else (at least, nothing that is detectable).</p>\n<p>(*) I'm putting details on how the interchange happens under the carpet but the idea remains valid. (E.g. what if the temporary holds a copy of <code>l_1</code> and not a pointer to it?)</p>\n", "OwnerUserId": "1137388", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:51:15.297", "Id": "23365730", "Score": "0", "CreationDate": "2014-04-29T13:13:30.340", "LastActivityDate": "2014-09-13T18:23:37.460"}});