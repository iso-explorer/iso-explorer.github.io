post_cb({"12015938": {"CommentCount": "3", "AcceptedAnswerId": "17509696", "PostTypeId": "1", "LastEditorUserId": "415784", "CreationDate": "2012-08-18T04:47:45.467", "LastActivityDate": "2013-07-07T19:40:30.743", "LastEditDate": "2012-11-15T18:31:22.243", "ViewCount": "3149", "FavoriteCount": "2", "Title": "Overload resolution behaviour difference between GCC and clang (SFINAE)", "Id": "12015938", "Score": "18", "Body": "<p>GCC accepts the following code:</p>\n<pre><code>template &lt;typename T&gt;\nstruct meta\n{\n    typedef typename T::type type;\n};\n\nstruct S {};\n\ntemplate &lt;typename T&gt;\ntypename meta&lt;T&gt;::type foo(T, S);\n\nint foo(int, int);      \n\nint main()\n{\n    foo(0, 0);\n}\n</code></pre>\n<p>But clang rejects it with the following error:</p>\n<pre><code>test.cpp:4:22: error: type 'int' cannot be used prior to '::' because it has no members\n    typedef typename T::type type;\n                     ^\ntest.cpp:10:10: note: in instantiation of template class 'meta&lt;int&gt;' requested here\ntypename meta&lt;T&gt;::type foo(T, S);\n         ^\ntest.cpp:10:24: note: while substituting deduced template arguments into function template 'foo' [with T = int]\ntypename meta&lt;T&gt;::type foo(T, S);\n                       ^\n</code></pre>\n<p>This seems to suggest a difference in the order in which GCC and clang do certain operations during overload resolution. GCC seems to throw out the template candidate because of the type mismatch in the second parameter (<code>S</code> vs. <code>int</code>) <em>before</em> trying to instantiate the return type of the template candidate, while clang seems to do it the other way around.</p>\n<p>Who is right?</p>\n<p>I believe this question has important implications for the authors of template libraries. Specifically, if clang is right, the author of the template <code>foo</code> would have to do extra work to turn the error into a substitution failure.</p>\n<p><strong>EDIT</strong>: Note that the following slightly simpler example is rejected by both GCC and clang, with similar errors:</p>\n<pre><code>template &lt;typename T&gt;\nstruct meta\n{\n    typedef typename T::type type;\n};\n\ntemplate &lt;typename T&gt;\ntypename meta&lt;T&gt;::type foo(T);\n\nint foo(int);      \n\nint main()\n{\n    foo(0);\n}\n</code></pre>\n<p>suggesting that GCC knows that \"only invalid types and expressions in the immediate context of the function type and its template parameter types can result in a deduction failure\". The difference between this example and the original is the presence of the second function parameter in the original example, on the basis of which GCC throws out the template candidate before it even gets to trying to perform substitution on the return type. I think the question is, whether GCC is correct to do things in that order, or should it be trying to perform substitution on the return type before considering matches in argument types.</p>\n<p><strong>UPDATE</strong>: Luc Danton's answer convinced me that clang is correct to reject the code. I have accordingly <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=54310\" rel=\"noreferrer\">filed a GCC bug</a>.</p>\n", "Tags": "<c++><templates><gcc><clang><overload-resolution>", "OwnerUserId": "141719", "AnswerCount": "2"}, "17509696": {"ParentId": "12015938", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Both Clang and g++ are correct here.</p>\n<p>Per Luc Danton's answer, a compiler is permitted to deduce <code>T = int</code> for the <code>foo</code> function template. Then, during the substitution of that value into the declaration of <code>foo</code>, the implicit instantiation of <code>meta&lt;int&gt;</code> is required, and it results in an error outside the immediate context of the substitution (so SFINAE does not apply). So Clang is correct to reject this code.</p>\n<p>However, <em>[temp.inst]p7</em> says:</p>\n<blockquote>\n<p id=\"so_12015938_17509696_0\">If the overload resolution process can determine the correct function to call without instantiating a class template definition, it is unspecified whether that instantiation actually takes place.</p>\n</blockquote>\n<p>Because the non-template <code>foo</code> is an exact match for the arguments in the call, a compiler could determine that a function template specialization will never be the best viable function, and so need not perform argument deduction and substitution. Therefore g++ is correct to not reject this code.</p>\n", "OwnerUserId": "1041090", "LastEditorUserId": "1041090", "LastEditDate": "2013-07-07T19:40:30.743", "Id": "17509696", "Score": "9", "CreationDate": "2013-07-07T06:00:16.267", "LastActivityDate": "2013-07-07T19:40:30.743"}, "bq_ids": {"n4140": {"so_12015938_17509696_0": {"section_id": 239, "quality": 1.0, "length": 18}, "so_12015938_12016077_0": {"section_id": 294, "quality": 0.7692307692307693, "length": 10}, "so_12015938_12016077_1": {"section_id": 300, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_12015938_17509696_0": {"section_id": 231, "quality": 1.0, "length": 18}, "so_12015938_12016077_0": {"section_id": 285, "quality": 0.7692307692307693, "length": 10}, "so_12015938_12016077_1": {"section_id": 291, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_12015938_17509696_0": {"section_id": 248, "quality": 0.7222222222222222, "length": 13}, "so_12015938_12016077_0": {"section_id": 301, "quality": 0.7692307692307693, "length": 10}, "so_12015938_12016077_1": {"section_id": 307, "quality": 0.9583333333333334, "length": 23}}}, "12016077": {"ParentId": "12015938", "CommentCount": "10", "Body": "<p>C++03 uses this wording as part of the specification for what is usually referred to as SFINAE (14.8.2 Template argument deduction [temp.deduct], paragraph 2):</p>\n<blockquote>\n<p id=\"so_12015938_12016077_0\">[...] If a substitution in a template parameter or in the\n  function type of the function template results in an invalid type, type deduction fails. [...]</p>\n</blockquote>\n<p>By contrast, C++11 uses this wording (14.8.2 Template argument deduction [temp.deduct], paragraph 8):</p>\n<blockquote>\n<p id=\"so_12015938_12016077_1\">If a substitution results in an invalid type or expression, type deduction fails. [...] Only invalid types and expressions <strong>in the immediate context</strong> of the function type and its template parameter types can result in a deduction failure. [...]</p>\n</blockquote>\n<p>Emphasis is mine. As I understand it the wording was improved in C++11 to unambiguously outline what should result in SFINAE (so-called soft errors) and what shouldn't (hard errors). <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2634.html\" rel=\"noreferrer\">This 2008 paper</a> is an example of the discussion that was going on at the time and led to the current rules.</p>\n<p>With this in mind it may be the case that according to C++03 an implementation may be right to accept your code (and even perhaps it should). I suspect that a C++11 implementation should reject it however: the error (<code>int::type</code>) is in the context of <code>meta&lt;int&gt;</code>, not of <code>foo&lt;int&gt;</code>.</p>\n", "OwnerUserId": "726300", "PostTypeId": "2", "Id": "12016077", "Score": "5", "CreationDate": "2012-08-18T05:17:10.727", "LastActivityDate": "2012-08-18T05:17:10.727"}});