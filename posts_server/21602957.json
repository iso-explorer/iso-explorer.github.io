post_cb({"21605768": {"ParentId": "21602957", "PostTypeId": "2", "CommentCount": "5", "Body": "<h2>Preamble with some Standardese</h2>\n<p>Your <code>friend</code> declaration matches the first of the four clauses from <code>[temp.friend]/1</code> (other 3 clauses omitted):</p>\n<p><strong>14.5.4 Friends [temp.friend]</strong></p>\n<blockquote>\n<p id=\"so_21602957_21605768_0\">1 A friend of a class or class template can be a function template or\n  class template, a <strong>specialization of a function template</strong> or class\n  template, or an ordinary (non-template) function or class. For a\n  friend function declaration that is not a template declaration: </p>\n<p id=\"so_21602957_21605768_1\">\u2014 if\n  the name of the friend is a quali\ufb01ed or unquali\ufb01ed template-id, the\n  friend declaration refers to a <strong>specialization of a function template</strong>,\n  otherwise</p>\n</blockquote>\n<p>Which names will be found by your friend declaration?</p>\n<p><strong>7.3.1.2 Namespace member de\ufb01nitions [namespace.memdef]</strong></p>\n<blockquote>\n<p id=\"so_21602957_21605768_2\">3 [...] If the name in a friend declaration is <strong>neither quali\ufb01ed nor a\n  template-id</strong> and the declaration is a function or an\n  elaborated-type-speci\ufb01er, the lookup to determine whether the entity\n  has been previously declared shall not consider any scopes outside the\n  innermost enclosing namespace. [ Note: <strong>The other forms of friend\n  declarations</strong> cannot declare a new member of the innermost enclosing\n  namespace and thus <strong>follow the usual lookup rules</strong>. \u2014 end note ]</p>\n</blockquote>\n<p>Because you have several overloads of <code>operator&amp;</code>, partial ordering is required:</p>\n<p><strong>14.5.6.2 Partial ordering of function templates\n[temp.func.order]</strong></p>\n<blockquote>\n<p id=\"so_21602957_21605768_3\">1 If a function template is overloaded, the use of a function template\n  specialization might be ambiguous because <strong>template argument deduction\n  (14.8.2)</strong> may associate the function template specialization with more\n  than one function template declaration. Partial ordering of overloaded\n  function template declarations is used in the following contexts to\n  select the function template to which a function template\n  specialization refers: </p>\n<p id=\"so_21602957_21605768_4\">\u2014 when a <strong>friend function\n  declaration (14.5.4)</strong>, an explicit instantiation (14.7.2) or an\n  explicit specialization (14.7.3) refers to a <strong>function template\n  specialization</strong>.</p>\n</blockquote>\n<p>and the set of candidates is as usual determined by a set of functions that survive argument template deduction:</p>\n<p><strong>14.8.2.6 Deducing template arguments from a function declaration [temp.deduct.decl]</strong></p>\n<blockquote>\n<p id=\"so_21602957_21605768_5\">1 In a declaration whose declarator-id refers to a <strong>specialization of a\n  function template</strong>, template argument deduction is performed to\n  identify the specialization to which the declaration refers.\n  Speci\ufb01cally, this is done for explicit instantiations (14.7.2),\n  explicit specializations (14.7.3), <strong>and certain friend declarations\n  (14.5.4).</strong></p>\n</blockquote>\n<p>where surviving argument deduction is governed by the infamous SFINAE (Substition failure is not an error) clause that applies only to the immediate context:</p>\n<p><strong>14.8.2\nTemplate argument deduction\n[temp.deduct]</strong></p>\n<blockquote>\n<p id=\"so_21602957_21605768_6\">8 [...] If a <strong>substitution results in an invalid type or expression, type deduction fails</strong>. An invalid type or expression is\n  one that would be ill-formed, with a diagnostic required, if written using the substituted arguments. [ Note:\n  If no diagnostic is required, the program is still ill-formed. Access checking is done as part of the substitution\n  process. \u2014 end note ] Only invalid types and expressions <strong>in the immediate context</strong> of the function type and\n  its template parameter types can result in a deduction failure.</p>\n</blockquote>\n<h2>Applying the Standard to your example</h2>\n<p>In all variations on your post, argument-dependent-lookup will find two overloads of <code>operator&amp;</code> in the associated globabl namespace of the <code>fvMatrix</code> class template. These overloads then have to play argument-deduction and partial ordering:</p>\n<ol>\n<li><strong>first example (code fragment)</strong>: because you have <code>friend ... operator&amp; &lt;Type&gt; (...)</code>, there is no argument deduction but simple substitution of <code>Cmpt=int</code> and <code>Type=int</code>, which yields an invalid type for <code>product&lt;int&gt;::type</code> <strong>inside</strong> <code>product2</code>. This is not in the immediate context and therefore a hard error. Removing the <code>Tensor</code> class template of course also removes the error.</li>\n<li><strong>second example</strong>: as above but with <code>typename product&lt;Cmpt&gt;::type</code> instead of <code>product2&lt;Cmpt::type</code> as the return type of the <code>operator&amp;</code> on <code>Tensor&lt;Cmpt&gt;</code>. Here, the invalid type is in the immediate context, and you get a SFINAE soft error and the valid <code>operator&amp;</code> for <code>fvMatrix&lt;Type&gt;</code> is selected.</li>\n<li><strong>third example</strong>: as the first but with <code>friend ... operator&amp; &lt;&gt; (...)</code>. This requires argument deduction and now the original <code>operator&amp;</code> on <code>Tensor</code> with the <code>product2::type</code> return type is actually harmless because argument-deduction itself fails (there is no template <code>Cmpt</code> that can make <code>Tensor&lt;Cmpt&gt;</code> equal to <code>fvMatrix&lt;int&gt;</code>) and there is no substition that can yield the hard error. </li>\n</ol>\n<h2>The best way to avoid these subtleties</h2>\n<p>Because the root cause is polluttion of the global namespace by unrelated operator overloads, the cure is simple: <strong>wrap each class template inside its own namespace</strong>! E.g. <code>Tensor&lt;Cmpt&gt;</code> into <code>namespace N1</code> and <code>fvMatrix&lt;Type&gt;</code> into <code>namespace N2</code>. Then the friend declaration inside <code>fvMatrix</code> will not find the <code>operator&amp;</code> for <code>Tensor&lt;Cmpt&gt;</code> and all works fine.</p>\n", "OwnerUserId": "819272", "LastEditorUserId": "819272", "LastEditDate": "2014-02-06T19:08:31.017", "Id": "21605768", "Score": "3", "CreationDate": "2014-02-06T14:34:40.003", "LastActivityDate": "2014-02-06T19:08:31.017"}, "bq_ids": {"n4140": {"so_21602957_21605768_6": {"section_id": 300, "quality": 0.9183673469387755, "length": 45}, "so_21602957_21605768_0": {"section_id": 126, "quality": 0.9166666666666666, "length": 22}, "so_21602957_21605768_4": {"section_id": 160, "quality": 0.8, "length": 12}, "so_21602957_21605768_2": {"section_id": 5485, "quality": 0.8571428571428571, "length": 36}, "so_21602957_21605768_3": {"section_id": 160, "quality": 0.95, "length": 38}, "so_21602957_21605768_1": {"section_id": 126, "quality": 0.8333333333333334, "length": 10}, "so_21602957_21605768_5": {"section_id": 353, "quality": 0.8518518518518519, "length": 23}}, "n3337": {"so_21602957_21605768_6": {"section_id": 291, "quality": 0.7959183673469388, "length": 39}, "so_21602957_21605768_0": {"section_id": 120, "quality": 0.9583333333333334, "length": 23}, "so_21602957_21605768_4": {"section_id": 154, "quality": 0.8, "length": 12}, "so_21602957_21605768_2": {"section_id": 5271, "quality": 0.8571428571428571, "length": 36}, "so_21602957_21605768_3": {"section_id": 154, "quality": 0.95, "length": 38}, "so_21602957_21605768_1": {"section_id": 120, "quality": 0.8333333333333334, "length": 10}, "so_21602957_21605768_5": {"section_id": 343, "quality": 0.8518518518518519, "length": 23}}, "n4659": {"so_21602957_21605768_6": {"section_id": 307, "quality": 0.9183673469387755, "length": 45}, "so_21602957_21605768_0": {"section_id": 131, "quality": 0.9166666666666666, "length": 22}, "so_21602957_21605768_4": {"section_id": 164, "quality": 0.8, "length": 12}, "so_21602957_21605768_2": {"section_id": 6920, "quality": 0.8571428571428571, "length": 36}, "so_21602957_21605768_3": {"section_id": 164, "quality": 0.95, "length": 38}, "so_21602957_21605768_1": {"section_id": 131, "quality": 0.8333333333333334, "length": 10}, "so_21602957_21605768_5": {"section_id": 363, "quality": 0.8518518518518519, "length": 23}}}, "21607515": {"ParentId": "21602957", "CommentCount": "3", "Body": "<p>From what I can tell, the first two lines</p>\n<pre><code>template &lt;class Type&gt; class product {};\ntemplate &lt;&gt; class product&lt;double&gt; { public: typedef double type; };\n</code></pre>\n<p>should be replaced with</p>\n<pre><code>template &lt;class Type&gt; class product { public: typedef Type type; };\n</code></pre>\n<p>I'm not entirely sure if this is what you want, but this does get rid of the compiler error.\nFundamentally, the error</p>\n<pre><code>c.cpp:5:50: error: no type named 'type' in 'class product&lt;int&gt;'\n</code></pre>\n<p>was caused by the fact that the definition for <code>product&lt;int&gt;</code> is empty.\nNotice that your first line defines a general <code>product&lt;Type&gt;</code> that is empty, and the second line only defines</p>\n<pre><code>public: typedef double type;\n</code></pre>\n<p>as the body of <code>product&lt;double&gt;</code>, not for a general <code>product&lt;Type&gt;</code>.</p>\n<p>The new version of this allows a similar <code>typedef</code> to be created for all types.</p>\n<p>As a side note, if you change</p>\n<pre><code>fvMatrix&lt;int&gt; m;\n</code></pre>\n<p>into</p>\n<pre><code>fvMatrix&lt;double&gt; m;\n</code></pre>\n<p>the code also compiles because <code>product&lt;double&gt;</code> does contain <code>public: typedef double type;</code>.</p>\n", "OwnerUserId": "3264405", "PostTypeId": "2", "Id": "21607515", "Score": "0", "CreationDate": "2014-02-06T15:48:29.003", "LastActivityDate": "2014-02-06T15:48:29.003"}, "21602957": {"CommentCount": "1", "ViewCount": "370", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-02-06T12:26:06.660", "LastActivityDate": "2014-02-06T19:10:15.607", "Title": "c++ template friend operator with another similar operator", "AcceptedAnswerId": "21605768", "LastEditDate": "2017-05-23T11:56:06.377", "Id": "21602957", "Score": "2", "Body": "<p>I have a template with an overloaded friend operator. It works well, but if there is another unrelated but similar operator within a scope, it does not compile: g++ produces strange error, and a similar errors are produced by icc and MSVC.</p>\n<p>The code is:</p>\n<pre><code>template &lt;class Type&gt; class product {};\ntemplate &lt;&gt; class product&lt;double&gt; { public: typedef double type; };\n\ntemplate&lt;class Type&gt; class product2 { \n    public: typedef typename product&lt;Type&gt;::type type; \n};\n\n//------------\n\ntemplate &lt;class Cmpt&gt; class Tensor {  };\n\ntemplate &lt;class Cmpt&gt; \ntypename product2&lt;Cmpt&gt;::type operator&amp; \n(const Tensor&lt;Cmpt&gt;&amp; a, const Tensor&lt;Cmpt&gt;&amp; b) \n{ return 0; }         // [1]\n\n//template &lt;class Cmpt&gt; \n//typename product&lt;Cmpt&gt;::type operator&amp; \n//(const Tensor&lt;Cmpt&gt;&amp; a, const Tensor&lt;Cmpt&gt;&amp; b) \n//{ return 0; }\n\n//-----\n\ntemplate&lt;class Type&gt; class fvMatrix;\n\ntemplate&lt;class Type&gt;\nfvMatrix&lt;Type&gt; operator&amp; \n(const fvMatrix&lt;Type&gt;&amp; a, const fvMatrix&lt;Type&gt;&amp; b) \n{ return a; }\n\ntemplate &lt;class Type&gt; class fvMatrix {\n    friend fvMatrix&lt;Type&gt; operator&amp; &lt;Type&gt; \n    (const fvMatrix&lt;Type&gt;&amp; a, const fvMatrix&lt;Type&gt;&amp; b);\n};\n\n//----------\n\nint main() {\n  fvMatrix&lt;int&gt; m;\n  m &amp; m;\n  return 0;\n}\n</code></pre>\n<p>The error by gcc 4.8.1 is (similar for 4.8.0 and 4.7.2):</p>\n<pre><code>c.cpp: In instantiation of 'class product2&lt;int&gt;':\nc.cpp:13:31:   required by substitution of 'template&lt;class Cmpt&gt; typename product2&lt;Type&gt;::type operator&amp;(const Tensor&lt;Cmpt&gt;&amp;, const Tensor&lt;Cmpt&gt;&amp;) [with Cmpt = int]'\nc.cpp:32:27:   required from 'class fvMatrix&lt;int&gt;'\nc.cpp:39:17:   required from here\nc.cpp:5:50: error: no type named 'type' in 'class product&lt;int&gt;'\n     public: typedef typename product&lt;Type&gt;::type type;\n</code></pre>\n<p>Similar errors (that is, attempting to use <code>product&lt;int&gt;::type</code> via <code>operator&amp;</code> for <code>Tensor&lt;int&gt;</code>) are produced by icc and MSVC.</p>\n<p>If I change the code so that <code>product</code> is used instead or <code>product2</code> in <code>operator&amp;</code> for <code>Tensor</code> (uncomment the commented lines and comment operator [1]), the code compiles.</p>\n<p>If I completely remove class <code>Tensor</code> with its <code>operator&amp;</code>, the code compiles.</p>\n<p><strong>UPDATE</strong>: completely removing <code>m&amp;m;</code> line still leaves code not compiling.</p>\n<hr>\n<p>I see that many sources suggest writing <code>friend fvMatrix&lt;Type&gt; operator&amp; &lt;&gt;</code>, i.e. without <code>Type</code> between <code>&lt;&gt;</code> (<a href=\"http://www.parashift.com/c++-faq-lite/template-friends.html\" rel=\"nofollow noreferrer\">http://www.parashift.com/c++-faq-lite/template-friends.html</a>, <a href=\"https://stackoverflow.com/questions/3989678/c-template-friend-operator-overloading\">C++ template friend operator overloading</a>), and this indeed solves this problem. </p>\n<p>However, even the review at <a href=\"https://stackoverflow.com/a/4661372/3216312\">https://stackoverflow.com/a/4661372/3216312</a> uses <code>friend std::ostream&amp; operator&lt;&lt; &lt;T&gt;</code></p>\n<p>So, the question is: why does the above code not compile? Is writing <code>friend fvMatrix&lt;Type&gt; operator&amp; &lt;Type&gt;</code> wrong and why?</p>\n<hr>\n<p>Background: we are modifying OpenFOAM framework and ran into such a problem inside the original OpenFOAM code which uses <code>friend ... operator&amp; &lt;Type&gt;</code> (<a href=\"http://foam.sourceforge.net/docs/cpp/a04795_source.html\" rel=\"nofollow noreferrer\">http://foam.sourceforge.net/docs/cpp/a04795_source.html</a>, line 484).</p>\n</hr></hr>", "Tags": "<c++><templates><friend><sfinae><argument-deduction>", "OwnerUserId": "3216312", "AnswerCount": "2"}});