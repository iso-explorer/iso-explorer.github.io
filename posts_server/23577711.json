post_cb({"23577802": {"ParentId": "23577711", "LastEditDate": "2014-05-10T14:34:51.523", "CommentCount": "3", "CreationDate": "2014-05-10T06:19:28.390", "OwnerUserId": "1390091", "LastEditorUserId": "1390091", "PostTypeId": "2", "Id": "23577802", "Score": "0", "Body": "<p>From the standard:</p>\n<pre><code>Name lookup may associate more than one declaration with a name if  \nit finds the name to be a function name.  Overload resolution (13.3) takes\nplace after name lookup has succeeded. \n</code></pre>\n<p>So first the possible candidates are sorted out, and then the most appropriate overload is used.</p>\n<p><strong>name lookup ends as soon as a declaration is found for the name</strong> does not mean it returns when first declaration is found. It accumulates all the <em>names in the scope</em> that match, and then uses the most suitable one. In case of method, if none of them can be used, then it will give error, rather than searching in any enclosing scope. Consider the following code:</p>\n<pre><code>namespace  A\n{\n    void f(double x){cout&lt;&lt;\"A::f(double)\\n\";}\n\n    void f(string s){cout&lt;&lt;\"A::f(string)\\n\";}\n\n    namespace B\n    {\n        void f(int x){cout&lt;&lt;\"B::f\\n\";}\n\n        void call()\n        {\n            f(10); // calls B::f\n            f(10.5); // calls B::f even if better matching method is present in A\n            f(\"Hi\"); // error, does not search in A\n        }\n    }\n}\n</code></pre>\n", "LastActivityDate": "2014-05-10T14:34:51.523"}, "23577711": {"CommentCount": "0", "ViewCount": "60", "OwnerDisplayName": "user2953119", "CreationDate": "2014-05-10T06:06:47.670", "LastActivityDate": "2014-05-10T14:34:51.523", "PostTypeId": "1", "AcceptedAnswerId": "23577802", "Title": "3.4.1 Unqualified name lookup and function overloading", "Id": "23577711", "Score": "0", "Body": "<p>I've read about unqualified name lookup and I've one misunderstanding about function overloading. In the N3797 said:</p>\n<blockquote>\n<p id=\"so_23577711_23577711_0\">In all the cases listed in 3.4.1, the scopes are searched for a\n  declaration in the order listed in each of the respective categories;\n  name lookup ends as soon as a declaration is found for the name.</p>\n</blockquote>\n<p>Consider the following code snippet:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nvoid foo(int)\n{\n    printf(\"foo(int)\\n\");\n}\n\nvoid foo()\n{\n    printf(\"foo(void)\\n\");\n}\n\nint main()\n{\n    foo();\n}\n</code></pre>\n<p>This program obviously printed <code>foo(void)</code>. In this case the name <code>foo</code> are searched for the declaration in the scope. And let the first founded defenition of the foo is </p>\n<pre><code>void foo(int)\n{\n    printf(\"foo(int)\\n\");\n}\n</code></pre>\n<p>Why is the program continue to search the best overload for the called function after the name is found.</p>\n", "Tags": "<c++><function><scope><overloading>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_23577711_23577711_0": {"section_id": 7087, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_23577711_23577711_0": {"section_id": 6831, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_23577711_23577711_0": {"section_id": 8588, "quality": 0.9473684210526315, "length": 18}}}});