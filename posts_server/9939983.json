post_cb({"9940046": {"LastActivityDate": "2012-03-30T09:09:01.457", "ParentId": "9939983", "Id": "9940046", "Score": "1", "Body": "<p>In the first, <code>size</code> is a variable whose value happens to be -2 but the compiler doesn't track it as it is a variable (at least for diagnostic purpose, I'm pretty sure the optimizing phase can track it). Execution should be problematic (I don't know if it is guarantee to have an exception or just UB).</p>\n<p>In the second, <code>size</code> is a constant and thus its value is known and verified at compile time.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "136208", "CreationDate": "2012-03-30T09:09:01.457"}, "bq_ids": {"n3337": {"so_9939983_9940132_0": {"section_id": 5855, "quality": 0.6046511627906976, "length": 26}}}, "9940014": {"LastActivityDate": "2012-03-30T09:07:16.963", "ParentId": "9939983", "Id": "9940014", "Score": "2", "Body": "<p>Because <code>const int size = -2;</code> can be replaced at compilation time by the compiler - whereas a non-const cannot - the compiler can tell that <code>size</code> is negative and doesn't allow the allocation.</p>\n<p>There's no way for the compiler to tell whether <code>int* p = new int[size];</code> is legal or not, if <code>size</code> is not const - <code>size</code> can be altered in the program or by a different thread. A <code>const</code> can't.</p>\n<p>You'll get into undefined behavior running the first sample anyway, it's just not legal.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "673730", "CreationDate": "2012-03-30T09:07:16.963"}, "9939983": {"AcceptedAnswerId": "9940047", "Tags": "<c++><new-operator>", "AnswerCount": "4", "OwnerUserId": "265130", "Body": "<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main(void){\n    int size = -2;\n    int* p = new int[size];\n    cout&lt;&lt;p&lt;&lt;endl;\n    return 0;\n}\n</code></pre>\n<p>Above code compiles without any problem on visual studio 2010.</p>\n<p>But</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main(void){\n    const int size = -2;\n    int* p = new int[size];\n    cout&lt;&lt;p&lt;&lt;endl;\n    return 0;\n}\n</code></pre>\n<p>But this code(added const keyword) gives error on compilation(size of array cannot be negative).</p>\n<p>Why these different results ?</p>\n", "CommentCount": "0", "CreationDate": "2012-03-30T09:05:07.193", "PostTypeId": "1", "FavoriteCount": "1", "LastActivityDate": "2012-03-30T09:28:09.740", "Id": "9939983", "Title": "compiler behaviour on return value of new", "Score": "3", "ViewCount": "115"}, "9940047": {"LastActivityDate": "2012-03-30T09:09:02.360", "ParentId": "9939983", "Id": "9940047", "Score": "4", "Body": "<p>By making it a constant expression, you've given the compiler the ability to diagnose the problem at compile time. Since you've made it <code>const</code>, the compiler can easily figure out that the value will necessarily be negative when you pass it to <code>new</code>.</p>\n<p>With a non-constant expression, you have the same problem, but it takes more intelligence on the part of the compiler to detect it. Specifically, the compiler has to detect that the value doesn't change between the time you initialize it and the time you pass it to <code>new</code>. With optimization turned on, chances are pretty good at least some compilers still could/would detect the problem, because for optimization purposes they detect data flow so they'd \"realize\" that in this case the value remains constant, even though you haven't specified it as <code>const</code>.</p>\n", "CommentCount": "1", "PostTypeId": "2", "OwnerUserId": "179910", "CreationDate": "2012-03-30T09:09:02.360"}, "9940132": {"LastActivityDate": "2012-03-30T09:28:09.740", "LastEditorUserId": "452307", "ParentId": "9939983", "LastEditDate": "2012-03-30T09:28:09.740", "Id": "9940132", "Score": "1", "Body": "<p>The first yields a compilation error because the compiler can detect a valid syntax is being violated at compilation time.<br>\nThe Second yields a Undefined Behaivor<sup>[1]</sup> because compiler cannot detect the illegal syntax at compilation time.       </br></p>\n<p><strong>Rationale:</strong><br>\nOnce you make the variable a <code>const</code> the compiler knows that the value of the variable <code>size</code> is not supposed to change anytime during the execution of the program. So compiler will apply its optimization &amp; just simply replace the <code>const</code> integral type <code>size</code> with its constant value <code>-2</code> wherever it is being used at compile time, While doing so it understands that legal syntax is not being folowed<sup>[1]</sup> and complains with a error.            </br></p>\n<p>In the Second case not adding a <code>const</code> prevents the compiler from applying the optimization mentioned above, because it cannot be sure that the variable <code>size</code> will never change during the course of execution of the program.So it cannot detect the illegal syntax at all.However, You end up getting a Undefined Behavior at run-time.</p>\n<p><sup>[1]</sup><strong>Reference:</strong><br>\n<strong>C++03 5.3.4 New [expr.new]</strong> </br></p>\n<pre><code>noptr-new-declarator:\n        [ expression ] attribute-speci\ufb01er-seqopt\n        noptr-new-declarator [ constant-expression ] attribute-speci\ufb01er-seqopt\n</code></pre>\n<p><code>constant-expression</code> are further explained in 5.4.3/6 and 5.4.3/7:</p>\n<blockquote>\n<p id=\"so_9939983_9940132_0\">Every constant-expression in a noptr-new-declarator shall be an integral constant expression (5.19) and evaluate to a strictly positive value. The expression in a <code>direct-new-declarator</code> shall have integral or enumeration type (3.9.1) with a non-negative value. [Example: if n is a variable of type int, then <code>new float[n][5]</code> is well-formed (because <code>n</code> is the expression of a direct-new-declarator), but <code>new float[5][n]</code> is ill-formed (because <code>n</code> is not a constant-expression). <strong>If <code>n</code> is negative, the effect of <code>new float[n][5]</code> is undefined.</strong> ]</p>\n</blockquote>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "452307", "CreationDate": "2012-03-30T09:14:47.533"}});