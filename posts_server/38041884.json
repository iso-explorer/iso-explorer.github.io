post_cb({"bq_ids": {"n4140": {"so_38041884_38041884_1": {"length": 5, "quality": 0.625, "section_id": 294}, "so_38041884_38042018_0": {"length": 21, "quality": 0.75, "section_id": 6187}}, "n3337": {"so_38041884_38041884_1": {"length": 5, "quality": 0.625, "section_id": 285}}, "n4659": {"so_38041884_38041884_1": {"length": 5, "quality": 0.625, "section_id": 301}, "so_38041884_38042018_0": {"length": 23, "quality": 0.8214285714285714, "section_id": 7690}}}, "38042018": {"Id": "38042018", "PostTypeId": "2", "Body": "<p>If you are worried about non-type pointer below you have perfectly valid  specialization of a structure with non-type pointer to function template parameter:</p>\n<pre><code>void foo() { }\n\ntemplate &lt;void(*)()&gt;\nstruct bar { };\n\nint main() {\n   bar&lt;&amp;foo&gt; b; \n}\n</code></pre>\n<p>The <code>&amp;foo</code> here is also a constant expression as it has a static lifetime.</p>\n<p>As Revolver_Ocelot mentioned 5.20[expr.const] /5 and 5.2 states it clearly:</p>\n<blockquote>\n<p id=\"so_38041884_38042018_0\">A constant expression is either a glvalue core constant expression\n  whose value refers to an entity that is a permitted result of a\n  constant expression (as defined below), or a prvalue core constant\n  expression whose value is an object where, for that object and its\n  subobjects:</p>\n<p id=\"so_38041884_38042018_1\">(...)</p>\n<ul>\n<li>if the object or subobject is of pointer type, it contains the address of an object with static storage duration, the address past\n  the end of such an object (5.7), the address of a function, or a null\n  pointer value</li>\n</ul>\n</blockquote>\n<p>(I used draft N4296)</p>\n", "LastEditorUserId": "4324224", "LastActivityDate": "2016-06-26T19:23:26.677", "Score": "2", "CreationDate": "2016-06-26T18:51:28.740", "ParentId": "38041884", "CommentCount": "4", "OwnerUserId": "4324224", "LastEditDate": "2016-06-26T19:23:26.677"}, "38041884": {"ViewCount": "111", "Body": "<p>The following is an excerpt from the book C++ Primer 5th edition (emphasis is mine):</p>\n<blockquote>\n<p id=\"so_38041884_38041884_0\">A nontype parameter may be an integral type, or a pointer or (lvalue)\n  reference to an object or to a function type. An argument bound to a\n  nontype integral parameter must be a constant expression. <strong>Arguments\n  bound to a pointer or reference nontype parameter must have static\n  lifetime</strong> (Chapter 12, p. 450). We may not use an ordinary (nonstatic)\n  local object or a dynamic object as a template argument for reference\n  or pointer nontype template parameters. A pointer parameter can also\n  be instantiated by nullptr or a zero-valued constant expression.</p>\n</blockquote>\n<p>Right below this paragraph one can find this highlighted Note:</p>\n<blockquote>\n<p id=\"so_38041884_38041884_1\">Template arguments used for nontype template parameters must be\n  constant expressions.</p>\n</blockquote>\n<p>Maybe I'm missing something, but I believe the Note is wrong, as nontype template parameters of a pointer or lvalue reference to an object or function type are not constant expressions.</p>\n", "AcceptedAnswerId": "38042018", "Title": "This seems to be an error in the book C++ Primer 5th edition", "CreationDate": "2016-06-26T18:40:00.267", "Id": "38041884", "CommentCount": "4", "LastEditDate": "2016-06-26T18:47:54.647", "PostTypeId": "1", "LastEditorUserId": "1577873", "LastActivityDate": "2016-06-26T19:23:26.677", "Score": "1", "OwnerUserId": "1577873", "Tags": "<c++><templates><pointers><reference>", "AnswerCount": "1"}});