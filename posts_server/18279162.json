post_cb({"18280009": {"ParentId": "18279162", "LastEditDate": "2013-08-16T18:47:57.557", "CommentCount": "0", "CreationDate": "2013-08-16T18:36:16.177", "OwnerUserId": "204847", "LastEditorUserId": "204847", "PostTypeId": "2", "Id": "18280009", "Score": "3", "Body": "<blockquote>\n<p id=\"so_18279162_18280009_0\">Why is this? Why cant I do it the way I wanted to do it.</p>\n</blockquote>\n<p>In Java, <code>aArray</code> would be a reference to a separate object which you'd have to create with <code>new</code>.</p>\n<p>In C++, you must forget everything you know about the Java object model. <code>aArray</code> is an object contained within the <code>PolyGon</code>, created automatically when the <code>PolyGon</code> is created, and initialised before the constructor body is run. If you need to provide constructor arguments, then these have to be given in the initialiser list before the constructor body; by the time you enter the constructor body, it's already been initialised.</p>\n<blockquote>\n<p id=\"so_18279162_18280009_1\">Does this rule only apply to the constructor. Like can I say <code>PointArray aArray = new PointArray(point, newSize);</code> somewhere else?</p>\n</blockquote>\n<p><code>new</code> returns a pointer to a dynamic object; so you can use it to initialise a pointer (not an object):</p>\n<pre><code>// Careful! This is a recipe for memory leaks.\nPointArray * aArray = new PointArray(point, newSize);\n</code></pre>\n<p>but remember that, if you create something with <code>new</code>, you must destroy it with <code>delete</code> when you've finished with it. There is no garbage collection, so abandoned dynamic objects leak memory. To prevent this, avoid <code>new</code> whenever possible, and learn how to use <a href=\"http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\" rel=\"nofollow\">RAII</a> to manage dynamic resources when you really do need them.</p>\n<p>You can also create objects without <code>new</code>:</p>\n<pre><code>PointArray aArray(point, newSize);\n</code></pre>\n<p>If this is inside a code block (a local variable; technically, at <em>block scope</em>), then it will be destroyed automatically when the program leaves that block. If it's not inside any function (a global variable; technically, at <em>namespace scope</em>), then it lasts for the duration of the program (more or less); but globals are generally considered a bad idea.</p>\n<blockquote>\n<p id=\"so_18279162_18280009_2\">I do have a no-arg constructor. So why is it giving me this error?</p>\n</blockquote>\n<p>The default constructor is being used; but then you try to assign a pointer to it. If you really wanted to avoid the initialiser list (which you shouldn't), then you could reassign to it by copying a temporary:</p>\n<pre><code>PolyGon(Point point[], const int newSize) {\n    aArray = PointArray(point, newSize);  // No new\n} \n</code></pre>\n<p>but that's potentially less efficient, and requires that the type implements a default constructor and copy-assignment operator that it perhaps doesn't need. Also there are some types (such as constants and references) that can't be default-initialised or reassigned. Direct initialisation in the list works for all types.</p>\n", "LastActivityDate": "2013-08-16T18:47:57.557"}, "bq_ids": {"n4140": {"so_18279162_18279505_0": {"section_id": 7189, "quality": 0.6956521739130435, "length": 16}}, "n3337": {"so_18279162_18279505_0": {"section_id": 6933, "quality": 0.6956521739130435, "length": 16}}, "n4659": {"so_18279162_18279505_0": {"section_id": 8697, "quality": 0.6956521739130435, "length": 16}}}, "18279230": {"ParentId": "18279162", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_18279162_18279230_0\">aArray(point, newSize) is equivalent to aArray = new PointArray(point, newSize).</p>\n</blockquote>\n<p>No.</p>\n<pre><code>PointArray aArray;\n</code></pre>\n<p><code>aArray</code> type is <code>PointArray</code> but not <code>PointArray *</code>. Both are different types in C++.So, you get compilation error when you try to assign <code>PointArray *</code> to the member variable <code>aArray</code>.</p>\n", "OwnerUserId": "528724", "PostTypeId": "2", "Id": "18279230", "Score": "0", "CreationDate": "2013-08-16T17:45:07.740", "LastActivityDate": "2013-08-16T17:45:07.740"}, "18279162": {"CommentCount": "3", "ViewCount": "450", "PostTypeId": "1", "LastEditorUserId": "1612290", "CreationDate": "2013-08-16T17:42:03.983", "LastActivityDate": "2013-08-16T18:47:57.557", "Title": "Initializer lists in C++ and class initialization. I have no-arg constructor but still have to use initializer lists?", "AcceptedAnswerId": "18280009", "LastEditDate": "2013-08-16T17:59:53.997", "Id": "18279162", "Score": "0", "Body": "<p>Okay new to C++, I know Java pretty well and now trying to learn c++.\nAnyways here is my simple class.</p>\n<pre><code>class PolyGon{\n\n    private:\n        PointArray aArray;\n        static int numberOfInst;\n\n    public:\n        PolyGon(Point point[], const int newSize) : aArray(point, newSize){} \n};\n</code></pre>\n<p>This complies fine. And correct me if I am wrong but in the initializer list <code>aArray(point, newSize)</code> is equivalent to <code>aArray = new PointArray(point, newSize)</code>.</p>\n<p>Because when I try the exact same code but change the last line to:</p>\n<pre><code>class PolyGon{\n\n    private:\n        PointArray aArray;\n        static int numberOfInst;\n\n    public:\n        PolyGon(Point point[], const int newSize){aArray = new PointArray(point, newSize)} \n};\n</code></pre>\n<p>This gives the exception: </p>\n<blockquote>\n<p id=\"so_18279162_18279162_0\">no match for 'operator=' in '((PolyGon*)this)-&gt;PolyGon::aArray = (((PointArray*)operator new(8u)), (-&gt;PointArray::PointArray(((const Point*)point), newSize), ))'|</p>\n</blockquote>\n<p>In case you want to see the constructor for PointArray here it is:</p>\n<pre><code>PointArray::PointArray(const Point points[], const int newSize)\n{\n    size = newSize;\n\n    x = new Point[size];\n\n    for(int i = 0; i &lt; size; i++)\n    {\n        x[i] = points[i];\n    }\n}\n</code></pre>\n<p>Okay before I submitted this I found an answer that said if the object does not have a default constructor you must initialize it with intializer lists. I now have three questions:</p>\n<ol>\n<li>Why is this? Why cant I do it the way I wanted to do it.</li>\n<li>Does this rule only apply to the constructor. Like can I say \"PointArray aArray = new PointArray(point, newSize);\" somewhere else?</li>\n<li>I do have a no-arg constructor. So why is it giving me this error?</li>\n</ol>\n<p>My no-arg constructor looks like this:</p>\n<pre><code>PointArray(){size = 0; x = new Point[0];}\n</code></pre>\n", "Tags": "<c++><initializer-list>", "OwnerUserId": "2690235", "AnswerCount": "3"}, "18279505": {"ParentId": "18279162", "LastEditDate": "2013-08-16T18:18:51.717", "CommentCount": "0", "CreationDate": "2013-08-16T18:02:19.943", "OwnerUserId": "845092", "LastEditorUserId": "845092", "PostTypeId": "2", "Id": "18279505", "Score": "2", "Body": "<pre><code>PolyGon(Point point[], const int newSize) : aArray(point, newSize){} \n</code></pre>\n<p>This says \"As the first part of constructing a PolyGon object, construct it's internal <code>aArray</code> with the parameters <code>point, newSize</code>.  I use the word \"internal\" deliberately here.  To make it more clear, I'm going use a \"person\" object as an analogy.  In Java, objects <em>refer</em> to each other.  When making a new person object, you make a new (separate) name object and then tell the person they now own that name.  </p>\n<p>In C++, it doesn't work even remotely like that.  The members (skin and blood) are actually <em>part of the object itself</em>.  When making a person object, you have to <em>simultaniously</em> make the skin object and blood object, as you make the person, you can't make them separately and then tell the person that they own that skin now.  Likewise, you can't remove them, or destroy them, without destroying the person.  The constructor body is the process of becoming alive (being born).</p>\n<p>This explains both why members must be constructed before the constructor body begins (person can't begin \"living\" until skin is complete), and why you can't give a member a <code>new</code> object (can't take away a person's skin and give them another) The member is <em>literally</em> part of the object.  The initializer list constructs the members of the object that are <em>literally</em> part of the object, and required for the object to \"live\".  (person analogy is growing in the womb) Once the parts are assembled and ready to go, then the constructor body finally begins, which begins the process of making the object finally \"alive\" (being born).  </p>\n<blockquote>\n<p id=\"so_18279162_18279505_0\">From the C++11 specification, section \u00a7 3.8/1<br>\n  The lifetime of an object of type T begins when ...its initialization is complete.  The lifetime of an object of type T ends when... the destructor call starts.</br></p>\n</blockquote>\n<p>So I totally didn't make up the \"life\" termononlogy.</p>\n<p>Back to the C++ code:</p>\n<pre><code>PolyGon(Point point[], const int newSize) \n//when making a new PolyGon\n: aArray(point, newSize)\n//construct it's internal aArray member at the same time\n{}\n//No additional steps needed to make it \"live\".\n</code></pre>\n<p>About the <code>new</code> keyword:<br>\nThe <code>new</code> keyword is required for everything in Java, because Java stores all objects separately no matter what, so you use <code>new</code> no matter what.  In C++, we can make objects <em>literally inside of</em> other objects, or <em>in</em> the stack memory.  We don't need the system to create us a <code>new</code> object, we need to construct the object in the space we already have. Alternatively, if you absolutely need a separate or dynamic object, you can use <code>new</code> to create a new object in the heap.</br></p>\n<pre><code>{\n    PolyGon inst; //this construts a PolyGon object _in_ the stack space\n                 //we refer to this object by the name \"inst\"\n    inst.print_name(); //work with inst directly\n    PolyGon* ptr = new PolyGon(); //this constructs a brand new PolyGon _in_ the \"heap\"\n                                  //and a pointer _in_ the stack space\n                                  //and stores the position of the PolyGon in the pointer\n                                  //we refer to this _pointer_ by the name \"ptr\"\n    ptr-&gt;print_name(); //call print_name on the object that ptr points at.\n    delete ptr; //delete the thing that ptr points at\n    ptr = &amp;inst;  //now we store the address of inst in the ptr pointer object\n    ptr-&gt;print_name(); //call print_name on inst\n} //inst was in the stack, so as the stack unwinds, \"inst\" is destructed automatically\n  //ptr also destructed. Destructing pointers DOES NOT destroy the things they point at\n</code></pre>\n", "LastActivityDate": "2013-08-16T18:18:51.717"}});