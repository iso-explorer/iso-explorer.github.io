post_cb({"bq_ids": {"n4140": {"so_16206626_16210319_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 300}, "so_16206626_16206626_0": {"length": 11, "quality": 1.0, "section_id": 6667}}, "n3337": {"so_16206626_16210319_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 291}, "so_16206626_16206626_0": {"length": 11, "quality": 1.0, "section_id": 6422}}, "n4659": {"so_16206626_16210319_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 307}, "so_16206626_16206626_0": {"length": 11, "quality": 1.0, "section_id": 8142}}}, "16210319": {"Id": "16210319", "PostTypeId": "2", "Body": "<p>I would assume that GCC is right.</p>\n<p>The first thing to note is that no non-<code>friend</code> code should be able to positively report the existence of a given private member. So if that is what you try to do, you have to modify your design. A class can do anything with its private members, and other code (excepting friends) should have no way to know about it. That's by design.</p>\n<p>However, there is the <a href=\"http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error\" rel=\"nofollow noreferrer\">SFINAE</a> principle: substitution failure is not an error. Since <code>MyClass::Data</code> is private, the code in <code>has_Data</code> should \u2013 in my opinion \u2013 act as if there was no <code>C::Data</code> member at all. Hence the first function would lead to a substitution failure, which gets silently ignored, and the second function is the one used. Adding a bit more code, my GCC 4.7.2 compiles this without issues and with <code>has_Data&lt;MyClass&gt;::value</code> evaluating to <code>false</code>. Correct SFINAE in my opinion.</p>\n<p>Trying to back this opinion up with a quotation from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow noreferrer\">the document you referred to</a>, I found the following in section 14.8.2 paragraph 8:</p>\n<blockquote>\n<p id=\"so_16206626_16210319_0\">Note: Access checking is done as part of the substitution process.</p>\n</blockquote>\n<p>This is a non-normative note in the standard, but to me appears to be a very readable and clear indication that SFINAE should in fact apply in this situation, just the way GCC handles it.</p>\n<p><em>Edit:</em> As <a href=\"https://stackoverflow.com/users/743382/hvd\">@hvd</a> pointed out in <a href=\"https://stackoverflow.com/questions/16206626/private-member-existence-test-using-meta-programming-gcc-vs-clang-which-is-rig/16210319?noredirect=1#comment23182432_16210319\">a comment</a>, the above is only true for C++11. In older versions of the standard, the situation used to be different. <a href=\"http://wg21.cmeerw.net/cwg/issue1170\" rel=\"nofollow noreferrer\">Issue 1170: Access checking during template argument deduction</a> has details on that change.</p>\n<p>GCC will not compile this code with <code>-std=c++03</code> or <code>-std=c++11</code> due to the fact that <code>typeof</code> is a GNU extension. The fact that <code>-std=gnu++03</code> still compiles the code might perhaps be considered inappropriate, but since the way forward is using the C++11 semantics, I wouldn't bother filing a report about this.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-04-25T10:37:43.220", "Score": "3", "CreationDate": "2013-04-25T08:47:50.263", "ParentId": "16206626", "CommentCount": "2", "OwnerUserId": "1468366", "LastEditDate": "2017-05-23T12:04:58.917"}, "16206626": {"ViewCount": "282", "Body": "<p>This is more of a c++ standards question.\nConsider the following code:</p>\n<pre><code>template &lt;typename T&gt;\nclass has_Data\n{\n   typedef char one;\n   typedef long two;\n\n   template &lt;typename C&gt; static one test( typeof(&amp;C::Data) ) ;\n   template &lt;typename C&gt; static two test(...);\n\npublic:\n   enum { value = sizeof(test&lt;T&gt;(0)) == sizeof(char) };\n};\n\nclass MyClass {\nprivate:\n   struct Data {\n   };\n};\n\n\nvoid function(bool val = has_Data&lt;MyClass&gt;::value) {}\n</code></pre>\n<p>The above code works with <code>gcc (GCC) 4.4.3</code></p>\n<p>However with <code>clang version 3.3 (2545b1d99942080bac4a74cda92c620123d0d6e9) (2ff97832e593926ea8dbdd5fc5bcf367475638a9)</code></p>\n<p>it gives this error:</p>\n<pre><code>test_private_data.cpp:7:54: error: 'Data' is a private member of 'MyClass'\n   template &lt;typename C&gt; static one test( typeof(&amp;C::Data) ) ;\n                                                     ^\n/devshared/home/rhanda/test_private_data.cpp:7:37: note: while substituting explicitly-specified template arguments into function template 'test'\n   template &lt;typename C&gt; static one test( typeof(&amp;C::Data) ) ;\n                                    ^\n/devshared/home/rhanda/test_private_data.cpp:21:26: note: in instantiation of template class 'has_Data&lt;MyClass&gt;' requested here\nvoid function(bool val = has_Data&lt;MyClass&gt;::value) {}\n                         ^\n1 error generated.\n</code></pre>\n<p>Which one is right?</p>\n<p>From standard document (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">n3485</a>), I found a statement which seems to agree with clang more than gcc.</p>\n<blockquote>\n<p id=\"so_16206626_16206626_0\">Access control is applied uniformly to all names, whether the names are referred to from declarations or expressions.</p>\n</blockquote>\n", "Title": "Private member existence test using meta programming, GCC vs clang, which is right?", "CreationDate": "2013-04-25T04:51:56.027", "LastActivityDate": "2013-04-25T10:37:43.220", "CommentCount": "6", "LastEditDate": "2013-04-25T08:28:37.963", "PostTypeId": "1", "LastEditorUserId": "1468366", "Id": "16206626", "Score": "5", "OwnerUserId": "1418784", "Tags": "<c++><gcc><clang>", "AnswerCount": "1"}});