post_cb({"bq_ids": {"n4140": {"so_31843093_32013955_2": {"length": 31, "quality": 0.7045454545454546, "section_id": 7040}}, "n4659": {"so_31843093_32013955_2": {"length": 31, "quality": 0.7045454545454546, "section_id": 8537}}}, "31843093": {"ViewCount": "387", "FavoriteCount": "3", "AcceptedAnswerId": "32013955", "Title": "Odd behavior passing static constexpr members without definitions by value", "CreationDate": "2015-08-05T21:23:52.630", "LastActivityDate": "2015-08-15T13:17:53.913", "CommentCount": "4", "Body": "<p>I was surprised to find that GCC and Clang disagree on whether to give me a linker error when passing a static constexpr member by value when there is no out-of-class definition:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n#include &lt;typeinfo&gt;\n\ntemplate &lt;typename X&gt;\nvoid show(X)\n{\n    std::cout &lt;&lt; typeid(X).name() &lt;&lt; std::endl;\n}\n\ntemplate &lt;typename T&gt;\nstruct Foo\n{\n    //static constexpr struct E {} nested {}; // works in gcc and clang\n    //static constexpr struct E {T x;} nested {}; // doesn't work in gcc\n    //static constexpr enum E {} nested {}; // works in gcc and clang\n    //static constexpr enum E { FOO } nested {}; // works in gcc and clang\n    //static constexpr struct E { constexpr E() {} constexpr E(const E&amp;) {} T x=T();} nested {}; // works in gcc and clang\n    static constexpr struct E { constexpr E() {} constexpr E(const E&amp;) = default; T x=T(); } nested {}; // doesn't work in gcc\n};\n\nint main()\n{\n    Foo&lt;int&gt; x;\n    show(x.nested);\n}\n</code></pre>\n<p>Snippet can be played with <a href=\"http://coliru.stacked-crooked.com/a/104f2f58f67c14f6\">here</a>.</p>\n<p>I would like to use the first line's syntax with no out-of-class definition:</p>\n<pre><code>static constexpr struct E {} nested {}; // works in gcc and clang\n</code></pre>\n<p>When there are no members in <code>E</code>, Clang and GCC only seem to care that I have no out-of-class definition of <code>nested</code> if I trip ODR (e.g. by taking the address). <strong>Is this standard mandated or luck?</strong></p>\n<p>When there are members, GCC (5.2) appears to additionally want me to have manually defined a constexpr copy constructor. <strong>Is this a bug?</strong></p>\n<p>From googling and SO I have found several different answers but it's hard to tease apart which are up to date with C++14. In C++98/03 I believe only integer types could be initialized inside the class. I <em>think</em> that C++14 expanded this to 'literal' types which includes constexpr constructable things. I don't know if this is the same as saying I am allowed to get away with not having an out-of-class definition though.</p>\n", "PostTypeId": "1", "Id": "31843093", "Score": "17", "OwnerUserId": "50385", "Tags": "<c++><gcc><clang><c++14><one-definition-rule>", "AnswerCount": "1"}, "32013955": {"Id": "32013955", "PostTypeId": "2", "LastEditDate": "2017-05-23T11:45:20.537", "CommentCount": "6", "LastEditorUserId": "-1", "LastActivityDate": "2015-08-15T13:17:53.913", "CreationDate": "2015-08-14T15:47:32.557", "ParentId": "31843093", "Score": "7", "Body": "<p>So in the cases where E is a class they all looks like odr violations, if we look at cppreferences page on <a href=\"http://en.cppreference.com/w/cpp/language/definition#ODR-use\" rel=\"nofollow noreferrer\">odr-use</a> it says:</p>\n<blockquote>\n<p id=\"so_31843093_32013955_0\">Informally, an object is odr-used if its address is taken, or a reference is bound to it, and a function is odr-used if a function call to it is made or its address is taken. If an object or a function is odr-used, its definition must exist somewhere in the program; a violation of that is a link-time error. </p>\n</blockquote>\n<p>and in this case we take a reference when we call the copy constructor on this line:</p>\n<pre><code>show(x.nested);\n</code></pre>\n<p>It is also worth it to note that <a href=\"https://stackoverflow.com/a/28446388/1708801\">odr-violations do not require a diagnostic</a>.</p>\n<p>It looks what you are seeing in some cases in the effects of constructor elision with gcc if we use <a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/C_002b_002b-Dialect-Options.html#index-fno_002delide_002dconstructors-134\" rel=\"nofollow noreferrer\">-fno-elide-constructors</a> we get an error for all the cases where E is a class. In the enum cases the lvalue-to-rvalue conversion is applied and therefore there is no odr-use.</p>\n<p><b>Update</b> </p>\n<p>dyp pointed me to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1741\" rel=\"nofollow noreferrer\">defect report 1741</a> which questions whether binding to the reference parameter of a copy ctor is an odr-use or not:</p>\n<blockquote>\n<p id=\"so_31843093_32013955_1\">Does this odr-use T::s, requiring it to have a definition, because of binding it to the reference parameter of S's copy constructor? </p>\n</blockquote>\n<p>and the result was the following change to [basic.def.odr] paragraph 3:</p>\n<blockquote>\n<p id=\"so_31843093_32013955_2\">A variable x whose name appears as a potentially-evaluated expression ex is odr-used unless <s>x satisfies the requirements for appearing in a constant expression (5.20 [expr.const])</s> <strong>applying the lvalue-to-rvalue conversion (4.1 [conv.lval]) to x yields a constant expression (5.20 [expr.const]) that does not invoke any non-trivial functions</strong> and, if x is an object, ex is an element of the set of potential results of an expression e, where either the lvalue-to-rvalue conversion (4.1 [conv.lval]) is applied to e, or e is a discarded-value expression (Clause 5 [expr]). this is odr-used... </p>\n</blockquote>\n<p>So then the question becomes which cases are covered by this change. It would seem these examples are ok:</p>\n<pre><code>//static constexpr struct E {} nested {}; // works in gcc and clang\n//static constexpr struct E {T x;} nested {}; // doesn't work in gcc\nstatic constexpr struct E { constexpr E() {} constexpr E(const E&amp;) = default; T x=T(); } nested {}; // doesn't work in gcc\n</code></pre>\n<p>Since the copy ctor is trivial while this one is not trivial:</p>\n<pre><code>//static constexpr struct E { constexpr E() {} constexpr E(const E&amp;) {} T x=T();} nested {}; // works in gcc and clang\n</code></pre>\n<p>We can confirm this using <a href=\"http://en.cppreference.com/w/cpp/types/is_trivially_copyable\" rel=\"nofollow noreferrer\">std::is_trivially_copyable</a>, <a href=\"http://melpon.org/wandbox/permlink/BKKseLGjj5GjrOEJ\" rel=\"nofollow noreferrer\">see it live</a>. </p>\n<p>The enum cases are still ok for the same reasons I stated originally.</p>\n<p>The defect also report variance in implementation.</p>\n", "OwnerUserId": "1708801"}});