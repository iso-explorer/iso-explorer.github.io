post_cb({"31310429": {"CommentCount": "8", "CreationDate": "2015-07-09T07:09:19.990", "PostTypeId": "1", "AcceptedAnswerId": "31310585", "LastEditorUserId": "3864091", "LastActivityDate": "2015-09-08T11:56:21.960", "LastEditDate": "2015-07-09T21:32:57.150", "ViewCount": "3698", "FavoriteCount": "2", "Title": "C++ - What's the point of nested classes?", "Id": "31310429", "Score": "27", "Body": "<p>I'm studying a little of C++ and now I'm fighting against it's similitudes with Java. I know the purpose of inner classes in Java, but now I'm trying to use nested classes in C++, <strong>and I discover that private attributes of \"container\" class are not visibile by nested class</strong>, so why I should use them? Also, is there a way to make visibile those attributes?</p>\n", "Tags": "<c++><inner-classes>", "OwnerUserId": "3864091", "AnswerCount": "3"}, "31318488": {"ParentId": "31310429", "CommentCount": "0", "Body": "<p>Different isn't the same.</p>\n<p>Java's <strong>inner</strong> classes create objects that are assumed to be connected with an object of the <strong>outer</strong> class, so access to members of the outer class from methods of the inner class can be done without explicitly creating a pointer or reference. C++ doesn't do that; a <strong>nested</strong> class is just a class whose definition is nested inside the definition of another class. That's handy for encapsulation, but that's it: it's not intended to magically make objects of that type know about objects of the containing type.</p>\n", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "31318488", "Score": "1", "CreationDate": "2015-07-09T13:09:36.790", "LastActivityDate": "2015-07-09T13:09:36.790"}, "31310525": {"ParentId": "31310429", "CommentCount": "2", "Body": "<p>It provides another good encapsulation technique. Placing one class entirely within the <em>namespace</em> of another class reduces its visibility to other parts of your code base. This helps achieve scalability and reduces your maintenance burden.</p>\n<p><em>Function objects</em> are often coded in such a manner.</p>\n", "OwnerUserId": "2380830", "PostTypeId": "2", "Id": "31310525", "Score": "5", "CreationDate": "2015-07-09T07:14:17.383", "LastActivityDate": "2015-07-09T07:14:17.383"}, "bq_ids": {"n4140": {"so_31310429_31310585_2": {"section_id": 6700, "quality": 1.0, "length": 9}, "so_31310429_31310585_5": {"section_id": 6684, "quality": 1.0, "length": 6}}, "n3337": {"so_31310429_31310585_2": {"section_id": 6455, "quality": 1.0, "length": 9}, "so_31310429_31310585_5": {"section_id": 6439, "quality": 1.0, "length": 6}}, "n4659": {"so_31310429_31310585_2": {"section_id": 8174, "quality": 1.0, "length": 9}, "so_31310429_31310585_5": {"section_id": 8159, "quality": 1.0, "length": 6}}}, "31310585": {"ParentId": "31310429", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_31310429_31310585_0\">I'm studying a little of C++ and now I'm fighting against it's similitudes with Java.</p>\n</blockquote>\n<p>First of all be aware that C++ nested classes are <em>similar</em> to what in Java you call <em>static nested classes</em>. There isn't anything in C++ syntax to reproduce Java <em>nested classes</em>.</p>\n<blockquote>\n<p id=\"so_31310429_31310585_1\">I discover that private attributes of \"container\" class are not visible by inner class...</p>\n</blockquote>\n<h2>C++ 98</h2>\n<p>In C++ inner classes aren't different to <em>normal</em> classes, they're not class <em>members</em> then they can't access container class' private members (unlike other languages like Java or C#). </p>\n<h2>C++ 03</h2>\n<p>Nested classes are class members but restrictions on what they can access still applies (see also section <strong>Weird things</strong> at the end of this answer). It has been considered a standard defect (see <a href=\"http://open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#45\" rel=\"nofollow noreferrer\">DR45</a>) then some compilers earlier implemented C++0x access rule earlier even when compiling for C++03 (notably GCC, thanks to Jonathan Wakely to spot this out).</p>\n<h2>C++ 11</h2>\n<p>This rule changed in C++ 11, now nested classes can access private member of container class. From \u00a711.7:</p>\n<blockquote>\n<p id=\"so_31310429_31310585_2\">A nested class is a member and as such has the same access rights as any other member.</p>\n</blockquote>\n<p>Of course you still need an instance to access non static members.</p>\n<hr/>\n<blockquote>\n<p id=\"so_31310429_31310585_3\">...so why I should use them?</p>\n</blockquote>\n<p>They're then an <em>implementation</em> detail to group related classes and they have same <em>issues</em> about their usage that you may have in other languages (clarity for newbies, primary). Their greatest benefit IMO is encapsulation, if for example you have this:</p>\n<pre><code>class stream {\n    virtual void write(const std::string text) = 0;\n};\n\nclass channel {\npublic:\n    virtual stream* get_stream() = 0;\n\n    // Other methods...\n};\n\nclass tcp_channel : public channel {\npublic:\n    virtual stream* get_stream() {\n        return new tcp_stream(this);\n    }\n\nprivate:\n    class tcp_stream : public stream { /* implementation */ };\n};\n</code></pre>\n<p>They're also helpful in some circumstances to <em>substitute</em> nested namespaces:</p>\n<pre><code>class protocol {\npublic:\n    virtual void create_connection() = 0;\n\n    class tcp : public protocol { /* implementation */ };\n    class shared_memory : public protocol { /* implementation */ };\n    class named_pipes: public protocol { /* implementation */ };\n};\n\nauto media = protocol::tcp();\n</code></pre>\n<p>Or to hide implementation details:</p>\n<pre><code>class file_system_entry {\npublic:\n    class file : public file_system_entry { };\n    class directory : public file_system_entry { };\n\n    std::time_t get_last_modified() { ... }\n\n    void remove() { ... }\n    virtual void copy_to(std::string path) = 0;\n\nprivate:\n    class local_handle {\n        // Implementation details\n    } _handle;\n};\n</code></pre>\n<p>There are many others usage patterns (see also <a href=\"https://stackoverflow.com/q/4571355/1207195\">Why would one use nested classes in C++?</a> for a much better discussion), just remember not everyone will correctly <em>understand</em> (and use!) them. See also <a href=\"https://stackoverflow.com/q/216748/1207195\">Pros and cons of using nested C++ classes and enumerations?</a></p>\n<blockquote>\n<p id=\"so_31310429_31310585_4\">Also, is there a way to make visible those attributes?</p>\n</blockquote>\n<p>Before C++ 11 you can't (of course unless you declare them as <code>friend</code>s but see next paragraph), if you need this feature just use a C++ 11 compiler (that supports this feature). GCC does (from long time ago) and also MSVC does, I don't know about other compilers. </p>\n<h2>Nested Friends</h2>\n<p><strong>Is there any difference between C++ 11 access rules and friend classes?</strong> In general they're <strong>almost equivalent</strong> (<em>automatic</em> access is just less verbose):</p>\n<pre><code>class container {\npublic:\n    class nested;\n    friend class nested;\n\n    class nested { };\n};\n</code></pre>\n<p>Compared to:</p>\n<pre><code>class container {\npublic:\n    class nested { };\n};\n</code></pre>\n<p>However with forward declaration you have some <em>side effects</em>. Also remember that from accessibility point of view they're equivalent (access, like friendship, is not inherited nor transitive). These examples don't compile:</p>\n<pre><code>class external : public container::nested {\npublic:\n    // No: only class declared inside \"container\"\n    // has access to private members, we do not inherit that \n    void foo(container obj) { /* access a private member of obj*/ }\n};\n\n// No, \"container\" has not access to \"nested\" private members,\n// visibility isn't reciprocal\nvoid container::foo(container::nested obj) {\n    // Access some private member of obj\n}\n\n// No, we don't have anything to do with container,\n// visibility isn't transitive\nvoid friendOfNested(container obj) {\n    // Access some private member of obj\n}\n</code></pre>\n<p>Are then <strong>completely equivalent</strong>? <strong>No</strong>, because private members of <code>container</code>'s friends are accessible in <code>nested</code> if it's a nested class in C++ 11 but they're not if <code>nested</code> is a friend of <code>container</code>. Given this outlined structure:</p>\n<pre><code>class container;\n\nclass another {\n    friend class container;     \n};\n\nclass container {\npublic:\n    class nested { };   \n};\n</code></pre>\n<p><code>nested</code> can access <code>another</code>'s private members:</p>\n<pre><code>void container::nested::foo(another obj) {\n    obj.somePrivateMember = 0;\n}\n</code></pre>\n<p>It works because <code>nested</code> is a <strong>member of</strong> <code>container</code> then transitive restriction of friendship doesn't apply. Before C++ 11, declaring <code>nested</code> as friend of <code>container</code>, that code won't compile because friendship isn't transitive.</p>\n<h2>Weird things</h2>\n<p>We'd assume we can always declare a nested class as friend of its container? Actually standard <strong>said</strong> (SO/IEC 14822:2003(E), 11.8): </p>\n<blockquote>\n<p id=\"so_31310429_31310585_5\">A friend of a class is a function or class that is not a member of the class...</p>\n</blockquote>\n<p>Then we <em>shouldn't</em> be able to declare <code>nested</code> as friend of <code>container</code>: in C++ 03 nested classes are class members (but standard explicitly said they have no access to container privates and also they can't be friends of container class). It seems there was no hope, fortunately most compilers allowed us to do so (regardless to what standard said).</p>\n", "OwnerUserId": "1207195", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:46:14.863", "Id": "31310585", "Score": "42", "CreationDate": "2015-07-09T07:17:03.517", "LastActivityDate": "2015-09-08T11:56:21.960"}});