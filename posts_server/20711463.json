post_cb({"20711541": {"PostTypeId": "2", "Body": "<p>Just to clarify the other answers, if you attempt to write to or read from memory referred to by an uninitialized pointer, or a pointer referring to memory that has been <code>delete</code>d or <code>free</code>d, the program may not crash, or may crash long after the write/read, making it hard to find the bug.</p>\n<p>If you do the same with a null pointer, the program will (probably) crash immediately, making debugging easier.</p>\n", "LastActivityDate": "2013-12-20T20:34:29.920", "Id": "20711541", "CommentCount": "0", "CreationDate": "2013-12-20T20:34:29.920", "ParentId": "20711463", "Score": "1", "OwnerUserId": "1704521"}, "20711544": {"Id": "20711544", "PostTypeId": "2", "Body": "<p>After</p>\n<pre><code>delete ptr;\n</code></pre>\n<p>the pointer object <code>ptr</code> <em>probably</em> still holds the same value it had before. It now points to a nonexistent object, so attempting to dereference it, or even to refer to its value, has undefined behavior. If you accidentally do something like:</p>\n<pre><code>delete ptr;\n// ...\n*ptr = 42;\n</code></pre>\n<p>it's likely to quietly clobber memory that you no longer own, or that may have been reallocated to some other object.</p>\n<p>Setting the pointer to null:</p>\n<pre><code>delete ptr;\nptr = NULL; // or 0 or nullptr\n</code></pre>\n<p>means that an accidental attempt to dereference the pointer is more likely to cause your program to crash. (Crashing is a good thing in this context.)</p>\n<p>Stealing Casey's comment:</p>\n<p>C++11 \u00a73.7.4.2 Deallocation Functions [basic.stc.dynamic.deallocation] para 4:</p>\n<blockquote>\n<p id=\"so_20711463_20711544_0\">If the argument given to a deallocation function in the standard\n  library is a pointer that is not the null pointer value (4.10), the\n  deallocation function shall deallocate the storage referenced by the\n  pointer, rendering invalid all pointers referring to any part of the\n  deallocated storage. The effect of using an invalid pointer value\n  (including passing it to a deallocation function) is undefined.</p>\n</blockquote>\n<p>If the pointer object is at the very end of its lifetime, you needn't bother, since there's no possibility of accidentally using it:</p>\n<pre><code>{\n    int *ptr = new int(42);\n    // ...\n    delete ptr;\n}\n</code></pre>\n<p>And as others have said, you're probably better off using some higher-level construct like smart pointers anyway.</p>\n", "LastEditorUserId": "827263", "LastActivityDate": "2013-12-20T21:03:33.010", "CommentCount": "4", "CreationDate": "2013-12-20T20:34:39.747", "ParentId": "20711463", "Score": "8", "OwnerUserId": "827263", "LastEditDate": "2013-12-20T21:03:33.010"}, "20711563": {"PostTypeId": "2", "Body": "<p>It is good coding practice to always initialize your pointers to <em>something</em>. In C++, the value of an uninitialized pointer is undefined, so if you have a single line like:</p>\n<pre><code>int* p;\n</code></pre>\n<p><code>p</code> takes on the value of whatever happened to be in the memory <code>p</code> takes up (not what it points to, but the memory for the pointer value itself). There are times when it makes sense to initialize a pointer to NULL, but that really depends on your code.</p>\n<p>As for setting NULL after deletion, it's a habit a few people follow. The benefit is that you can call <code>delete</code> on NULL without problems, whereas a double <code>delete</code> on a pointer could cause undefined behavior. Before the idea of RAII was popular, some people followed the \"better safe than sorry\" method of calling <code>delete</code> on multiple code paths. In those cases, if you don't set pointer to NULL, you might accidentally <code>delete</code> a pointer twice, so setting it to NULL mitigates that problem. Personally, I think it's a sign of poor design if your pointers don't have proper ownership, and you have to guess at when to call <code>delete</code>.</p>\n", "LastActivityDate": "2013-12-20T20:35:51.377", "Id": "20711563", "CommentCount": "1", "CreationDate": "2013-12-20T20:35:51.377", "ParentId": "20711463", "Score": "1", "OwnerUserId": "2420744"}, "bq_ids": {"n4140": {"so_20711463_20711544_0": {"length": 30, "quality": 0.8571428571428571, "section_id": 7183}}, "n3337": {"so_20711463_20711544_0": {"length": 33, "quality": 0.9428571428571428, "section_id": 6927}}}, "20711502": {"PostTypeId": "2", "Body": "<p>There is no benefit from an optimising compiler's point of view: the redundant stores will be eliminated.  Modern compilers will be able to see that the value isn't used and remove them.</p>\n<p>There may be benefit from the human reader's point of view: it may make the code easier to understand and may help reduce bugs caused by using uninitialised or freed data.  In some cases initialising to NULL can actually hide issues, though, as most compilers will warn if you try to use a value without initialising it first.</p>\n<p>My personal opinion though is that you should initialise the variable properly with its final value as close to declaring it as possible and let the compiler warn you if you miss an execution path, then you shouldn't be able to use a variable once its value has been freed because it's also gone out of scope.  Freeing data using smart pointers helps here.</p>\n", "LastActivityDate": "2013-12-20T20:31:37.177", "Id": "20711502", "CommentCount": "0", "CreationDate": "2013-12-20T20:31:37.177", "ParentId": "20711463", "Score": "1", "OwnerUserId": "24762"}, "20711508": {"PostTypeId": "2", "Body": "<p>If you initialise it to null and then immediately assign some other value to it, or if you assign null to it (after deletion) and then immediately let it go out of scope, it's pretty pointless.</p>\n<p>However, if there's any chance that some other code might want to use the object it's pointing at while the pointer still exists and the object may not exist, then you will want to be able to signify to that code that nothing is there. If the pointer is set to null, the code can check for null before attempting to dereference the pointer.</p>\n", "LastActivityDate": "2013-12-20T20:32:17.537", "Id": "20711508", "CommentCount": "0", "CreationDate": "2013-12-20T20:32:17.537", "ParentId": "20711463", "Score": "2", "OwnerUserId": "150634"}, "20711463": {"ViewCount": "139", "Body": "<p>I was just wondering if there is any benefit in initializing a pointer to NULL, or in setting it to NULL after pointer deletion.</p>\n<p>I've read on a few forums that setting to NULL after deletion is unnecessary, and that some compilers do not even consider the line. If it changes nothing, why do some people use it?</p>\n", "Title": "Pointers and \"NULL\"", "CreationDate": "2013-12-20T20:28:11.797", "LastActivityDate": "2013-12-20T21:03:33.010", "CommentCount": "6", "PostTypeId": "1", "ClosedDate": "2013-12-20T21:22:03.757", "Id": "20711463", "Score": "1", "OwnerUserId": "3013199", "Tags": "<c++><null>", "AnswerCount": "7"}, "20711510": {"PostTypeId": "2", "Body": "<p>Initializing a pointer to <code>NULL</code>/<code>nullptr</code>, in any context, is a generally idea because dangling pointers can refer to actual memory. If you nullify a pointer after its use and you dereference it, modern platforms will usually crash cleanly.</p>\n<p>Setting a pointer to <code>null</code> after you're done with it can be a good idea for the same reason, but I personally don't think that it's especially useful if you're not keeping the variable around, like when it's a local variable.</p>\n<p>Even better practice, though, is to avoid raw pointers altogether. C++11 provides <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr\" rel=\"nofollow\"><code>unique_ptr</code></a>, <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr\" rel=\"nofollow\"><code>shared_ptr</code></a> and <a href=\"http://en.cppreference.com/w/cpp/memory/weak_ptr\" rel=\"nofollow\"><code>weak_ptr</code></a> (in <code>&lt;memory&gt;</code>) that wrap pointers with those three semantics. Using them, you never need to delete anything manually and you almost never need to set anything to <code>nullptr</code> yourself.</p>\n", "LastActivityDate": "2013-12-20T20:32:28.160", "Id": "20711510", "CommentCount": "0", "CreationDate": "2013-12-20T20:32:28.160", "ParentId": "20711463", "Score": "0", "OwnerUserId": "251153"}, "20711506": {"PostTypeId": "2", "Body": "<p>On a modern hardware and operating system, a null pointer is an invalid pointer. Therefore, when you try to access it then your program will be shutdown by either your hardware or your operating system. This can help as it will guarantee that you your program will not attempt to access some memory that has been freed earlier and cause undefined behavior and get away with it.</p>\n<p>It can also help with debugging, as you can then see if that memory has been freed at your breakpoint. </p>\n<p>But ideally, a good C++ programmer should trie to avoid using raw pointers and use RAII when ever possible.</p>\n", "LastActivityDate": "2013-12-20T20:31:47.747", "Id": "20711506", "CommentCount": "0", "CreationDate": "2013-12-20T20:31:47.747", "ParentId": "20711463", "Score": "0", "OwnerUserId": "1496443"}});