post_cb({"15727869": {"CommentCount": "5", "AcceptedAnswerId": "15728900", "CreationDate": "2013-03-31T08:47:35.910", "LastActivityDate": "2013-03-31T16:00:14.300", "PostTypeId": "1", "ViewCount": "390", "FavoriteCount": "2", "Title": "C++11 \"enumerated types\" (17.5.2.1.2)", "Id": "15727869", "Score": "10", "Body": "<p>A quote from C++11 standard (17.5.2.1.2 Enumerated types):</p>\n<blockquote>\n<p id=\"so_15727869_15727869_0\">1 Several types defined in Clause 27 are <em>enumerated types</em>. Each enumerated type may be implemented as an enumeration or as a synonym for an enumeration (Such as an integer type, with constant integer values (3.9.1)).</p>\n<p id=\"so_15727869_15727869_1\">2 The enumerated type <em>enumerated</em> can be written:</p>\n</blockquote>\n<pre><code>enum enumerated { V0 , V1 , V2 , V3 , ..... };\nstatic const enumerated C0 (V0 );\nstatic const enumerated C1 (V1 );\nstatic const enumerated C2 (V2 );\nstatic const enumerated C3 (V3 );\n.....\n</code></pre>\n<blockquote>\n<p id=\"so_15727869_15727869_2\">3 Here, the names C0, C1, etc. represent <em>enumerated elements</em> for this particular enumerated type. All such elements have distinct values.</p>\n</blockquote>\n<p>One of such \"enumerated types\" is \"seekdir\" from class ios_base (27.5.3 Class ios_base):</p>\n<pre><code>// 27.5.3.1.5 seekdir\ntypedef T4 seekdir;\nstatic constexpr fmtflags beg = unspecified ;\nstatic constexpr fmtflags cur = unspecified ;\nstatic constexpr fmtflags end = unspecified ;\n</code></pre>\n<p>and</p>\n<blockquote>\n<p id=\"so_15727869_15727869_3\">27.5.3.1.5 Type ios_base::seekdir [ios::seekdir]</p>\n</blockquote>\n<pre><code>typedef T4 seekdir;\n</code></pre>\n<blockquote>\n<p id=\"so_15727869_15727869_4\">1 The type seekdir is an enumerated type (17.5.2.1.2) that contains the elements indicated in Table 126.</p>\n</blockquote>\n<p>So, the ONLY reason those static const and constexpr members are required is because \"enumerated types\" are allowed to be implemented as integer type (i.e. when <em>enumerated</em> is int we need to define constants in place of enumerators), right?</p>\n<p><strong>Question 1</strong>. If library vendor decides to implement seekdir as enum does he still have to define static constants for enumeration values?</p>\n<p><strong>Question 2</strong>. WHY \"enumerated types\" are allowed to be implemented as integer types in the first place? I.e. when enum implementation (and in C++11 enums can have any underlying integer type) without those static constant members can be worse than integer type implementation?</p>\n", "Tags": "<c++><c++11><enums>", "OwnerUserId": "1997715", "AnswerCount": "2"}, "15728900": {"ParentId": "15727869", "CommentCount": "3", "Body": "<p>The original reason for requiring objects for the values of enumerated types was so that you could take their address. That always struck me as silly, but there was quite a bit of overdesign in the early stages of standardization.</p>\n", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "15728900", "Score": "3", "CreationDate": "2013-03-31T11:27:17.267", "LastActivityDate": "2013-03-31T11:27:17.267"}, "bq_ids": {"n4140": {"so_15727869_15727869_4": {"section_id": 1949, "quality": 0.6363636363636364, "length": 7}, "so_15727869_15727869_2": {"section_id": 6232, "quality": 0.9333333333333333, "length": 14}, "so_15727869_15727869_0": {"section_id": 6230, "quality": 0.8571428571428571, "length": 18}, "so_15727869_15727869_1": {"section_id": 6231, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_15727869_15727869_2": {"section_id": 5992, "quality": 0.9333333333333333, "length": 14}, "so_15727869_15727869_0": {"section_id": 5990, "quality": 0.8571428571428571, "length": 18}, "so_15727869_15727869_4": {"section_id": 1938, "quality": 0.6363636363636364, "length": 7}, "so_15727869_15727869_1": {"section_id": 5991, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_15727869_15727869_4": {"section_id": 2220, "quality": 0.6363636363636364, "length": 7}, "so_15727869_15727869_2": {"section_id": 7736, "quality": 0.9333333333333333, "length": 14}, "so_15727869_15727869_0": {"section_id": 7734, "quality": 0.8571428571428571, "length": 18}, "so_15727869_15727869_1": {"section_id": 7735, "quality": 0.6666666666666666, "length": 4}}}, "15728578": {"ParentId": "15727869", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>When the standard was written, strongly-typed enums weren't available and the problem with plain <code>enum</code> is, that their internal type is unspecified and may <em>change</em> depending on compiler switches.</p>\n<p>For <code>seekdir</code>, it could be <code>int</code> or <code>byte</code> (as an example), both would be valid representations. GCC has an command line option for that (<code>--short-enums</code> or <code>-fshort-enums</code>), by default it would use <code>int</code> for all <code>enum</code>s as the smallest type, but with the option it would use the smallest type that could contain all values.</p>\n<p>That means that if a real <code>enum</code> is used in a function signature, the symbol may change and you'd need to recompile everything. This is why the Standard allows other options, why it's important for the Standard Library implementation to have control over the type and this is why it is allowed to resort to specific integer types.</p>\n", "OwnerUserId": "2073257", "LastEditorUserId": "2073257", "LastEditDate": "2013-03-31T16:00:14.300", "Id": "15728578", "Score": "6", "CreationDate": "2013-03-31T10:42:54.437", "LastActivityDate": "2013-03-31T16:00:14.300"}});