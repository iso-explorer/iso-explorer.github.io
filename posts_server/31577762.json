post_cb({"bq_ids": {"n4140": {"so_31577762_31578597_9": {"length": 39, "quality": 1.0, "section_id": 6169}, "so_31577762_31578597_5": {"length": 55, "quality": 1.0, "section_id": 6169}, "so_31577762_31578597_6": {"length": 16, "quality": 1.0, "section_id": 6169}, "so_31577762_31578597_8": {"length": 13, "quality": 1.0, "section_id": 6169}, "so_31577762_31578597_10": {"length": 10, "quality": 1.0, "section_id": 6169}, "so_31577762_31578597_3": {"length": 42, "quality": 0.9767441860465116, "section_id": 6169}, "so_31577762_31578597_4": {"length": 13, "quality": 1.0, "section_id": 6169}, "so_31577762_31578597_0": {"length": 6, "quality": 1.0, "section_id": 3947}, "so_31577762_31578597_7": {"length": 19, "quality": 0.95, "section_id": 6169}, "so_31577762_31578597_2": {"length": 30, "quality": 0.9090909090909091, "section_id": 6027}}, "n3337": {"so_31577762_31578597_3": {"length": 42, "quality": 0.9767441860465116, "section_id": 5930}, "so_31577762_31578597_5": {"length": 55, "quality": 1.0, "section_id": 5930}, "so_31577762_31578597_6": {"length": 16, "quality": 1.0, "section_id": 5930}, "so_31577762_31578597_8": {"length": 12, "quality": 0.9230769230769231, "section_id": 5930}, "so_31577762_31578597_9": {"length": 39, "quality": 1.0, "section_id": 5930}, "so_31577762_31578597_7": {"length": 19, "quality": 0.95, "section_id": 5930}, "so_31577762_31578597_10": {"length": 10, "quality": 1.0, "section_id": 5930}, "so_31577762_31578597_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 3806}, "so_31577762_31578597_4": {"length": 12, "quality": 0.9230769230769231, "section_id": 5930}, "so_31577762_31578597_2": {"length": 30, "quality": 0.9090909090909091, "section_id": 5795}}, "n4659": {"so_31577762_31578597_7": {"length": 11, "quality": 0.55, "section_id": 7667}, "so_31577762_31578597_5": {"length": 38, "quality": 0.6909090909090909, "section_id": 7667}, "so_31577762_31578597_6": {"length": 9, "quality": 0.5625, "section_id": 7667}, "so_31577762_31578597_8": {"length": 11, "quality": 0.8461538461538461, "section_id": 7667}, "so_31577762_31578597_3": {"length": 34, "quality": 0.7906976744186046, "section_id": 7667}, "so_31577762_31578597_0": {"length": 6, "quality": 1.0, "section_id": 4834}, "so_31577762_31578597_4": {"length": 11, "quality": 0.8461538461538461, "section_id": 7667}, "so_31577762_31578597_2": {"length": 30, "quality": 0.9090909090909091, "section_id": 7526}}}, "31578597": {"Id": "31578597", "PostTypeId": "2", "Body": "<h3>The type of <code>std::move(x)</code></h3>\n<p>Ok, so let's start by figuring out the type of <code>std::move(snd)</code>. The implementation of <code>std::move(x)</code> is defined to be approximately <code>static_cast&lt;T&amp;&amp;&gt;(x)</code>, as per \u00a720.2.4:</p>\n<blockquote>\n<p id=\"so_31577762_31578597_0\"><code>template &lt;class T&gt; constexpr remove_reference_t&lt;T&gt;&amp;&amp; move(T&amp;&amp; t) noexcept;</code></p>\n<p id=\"so_31577762_31578597_1\"><em>Returns</em>: <code>static_cast&lt;remove_reference_t&lt;T&gt;&amp;&amp;&gt;(t)</code>.</p>\n</blockquote>\n<p>which according to \u00a75.2.9/1:</p>\n<blockquote>\n<p id=\"so_31577762_31578597_2\">The result of the expression <code>static_cast&lt;T&gt;(v)</code> is the result of converting the expression <code>v</code> to type <code>T</code>. If <code>T</code> is an lvalue reference type or an rvalue reference to function type, the result is an lvalue; <strong>if <code>T</code> is an rvalue reference to object type, the result is an xvalue</strong>; otherwise, the result is a prvalue. The <code>static_cast</code> operator shall not cast away constness (5.2.11).</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>Ok, so the returned value of <code>std::move(snd)</code> is an xvalue of type <code>printer&amp;&amp;</code>. The type of <code>fst</code> is an lvalue of type <code>const printer</code>.</p>\n<hr>\n<h3>How to calculate the common type</h3>\n<p>Now, the standard describes the process to calculate the type of the resulting expression for the ternary conditional operator:</p>\n<blockquote>\n<p id=\"so_31577762_31578597_3\">if the second and third operand have different types and either has (possibly cv-qualified) class type, or if both are glvalues of the same value category and the same type except for cv-qualification, an attempt is made to convert each of those operands to the type of the other. The process for determining whether an operand expression E1 of type T1 can be converted to match an operand expression E2 of type T2 is defined as follows:</p>\n<ul>\n<li>If E2 is an lvalue: E1 can be converted to match E2 if E1 can be implicitly converted (Clause 4) to the type \u201clvalue reference to T2\u201d, subject to the constraint that in the conversion the reference must bind directly (8.5.3) to an lvalue.</li>\n<li>If E2 is an xvalue: E1 can be converted to match E2 if E1 can be implicitly converted to the type \u201crvalue reference to T2\u201d, subject to the constraint that the reference must bind directly.</li>\n<li><p id=\"so_31577762_31578597_4\">If E2 is a prvalue or if neither of the conversions above can be done and at least one of the operands has (possibly cv-qualified) class type:</p>\n<ul>\n<li>if E1 and E2 have class type, and the underlying class types are the same or one is a base class of the other: E1 can be converted to match E2 if the class of T2 is the same type as, or a base class of, the class of T1, and the cv-qualification of T2 is the same cv-qualification as, or a greater cv-qualification than, the cv-qualification of T1. If the conversion is applied, E1 is changed to a prvalue of type T2 by copy-initializing a temporary of type T2 from E1 and using that temporary as the converted operand.</li>\n<li>Otherwise (if E1 or E2 has a non-class type, or if they both have class types but the underlying classes are not the same and neither is a base class of the other): E1 can be converted to match E2 if E1 can be implicitly converted to the type that E2 would have after applying the lvalue-to-\n  rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) standard conversions.</li>\n</ul></li>\n</ul>\n<p id=\"so_31577762_31578597_5\">Using this process, it is determined whether the second operand can be converted to match the third operand, <strong>and whether the third operand can be converted to match the second operand. If both can be converted, or one can be converted but the conversion is ambiguous, the program is ill-formed. If neither can be converted, the operands are left unchanged and further checking is performed as described below. If exactly one conversion is possible, that conversion is applied to the chosen operand and the converted operand is used in place of the original operand for the remainder of this section</strong>.</p>\n</blockquote>\n<p>(again emphasis mine)</p>\n<hr>\n<h3>In this context</h3>\n<p>So we have two cases:</p>\n<ol>\n<li>E1 is <code>fst</code> and E2 is <code>std::move(snd)</code></li>\n<li>E1 is <code>std::move(snd)</code> and E2 is <code>fst</code></li>\n</ol>\n<p>In the first case we have that E2 is an xvalue, so:</p>\n<blockquote>\n<p id=\"so_31577762_31578597_6\">If E2 is an xvalue: E1 can be converted to match E2 if E1 can be implicitly converted to the type \u201crvalue reference to T2\u201d, subject to the constraint that the reference must bind directly.</p>\n</blockquote>\n<p>applies; but E1 (of type <code>const printer</code>) cannot be implicitly converted to <code>printer&amp;&amp;</code> due to the fact that it would lose the constness. So this conversion is not possible.</p>\n<p>In the second case, we have that:</p>\n<blockquote>\n<p id=\"so_31577762_31578597_7\">If E2 is an lvalue: E1 can be converted to match E2 if E1 can be implicitly converted (Clause 4) to the type \u201clvalue reference to T2\u201d, subject to the constraint that in the conversion the reference must bind directly (8.5.3) to an lvalue.</p>\n</blockquote>\n<p>applies, but E1 (<code>std::move(snd)</code> of type <code>printer&amp;&amp;</code>) can be implicitly converted to <code>const printer&amp;</code>, but does not bind directly to an lvalue; so this one also doesn't apply.</p>\n<p>At this point we are at:</p>\n<blockquote>\n<p id=\"so_31577762_31578597_8\">If E2 is a prvalue or if neither of the conversions above can be done and at least one of the operands has (possibly cv-qualified) class type:</p>\n</blockquote>\n<p>section.</p>\n<p>From which we have to consider:</p>\n<blockquote>\n<p id=\"so_31577762_31578597_9\">if E1 and E2 have class type, and the underlying class types are the same or one is a base class of the other: E1 can be converted to match E2 if the class of T2 is the same type as, or a base class of, the class of T1, and the cv-qualification of T2 is the same cv-qualification as, or a greater cv-qualification than, the cv-qualification of T1. If the conversion is applied, E1 is changed to a prvalue of type T2 by copy-initializing a temporary of type T2 from E1 and using that temporary as the converted operand.</p>\n</blockquote>\n<p>E1 and E2 indeed have the same underlying class types. And <code>const printer</code> has a greater cv-qualification than the cv-qualification of <code>std::move(snd)</code>, so the case is the one in which E1 = <code>std::move(snd)</code> and E2 = <code>fst</code>.</p>\n<p>From which we finally have that:</p>\n<blockquote>\n<p id=\"so_31577762_31578597_10\">E1 is changed to a prvalue of type T2 by copy-initializing a temporary of type T2 from E1 and using that temporary as the converted operand.</p>\n</blockquote>\n<p>Which translated to the fact that <code>std::move(snd)</code> is changed to a prvalue of type <code>const printer</code> by copy-initializing a temporary of type <code>const printer</code> from <code>std::move(snd)</code>.</p>\n<p>Since <code>std::move(snd)</code> yields a <code>printer&amp;&amp;</code>, the expression would be equivalent to the construction of a <code>const printer</code> with <code>printer(std::move(snd))</code>, which should result in <code>printer(printer&amp;&amp;)</code> being selected.</p>\n</hr></hr>", "LastEditorUserId": "493122", "LastActivityDate": "2015-07-23T05:44:19.990", "Score": "11", "CreationDate": "2015-07-23T05:09:59.987", "ParentId": "31577762", "CommentCount": "11", "LastEditDate": "2015-07-23T05:44:19.990", "OwnerUserId": "493122"}, "31577762": {"ViewCount": "318", "Body": "<p>I was writing some code similar to:</p>\n<pre><code>std::string foo(bool b, const std::string&amp; fst, std::string&amp;&amp; snd) {\n  return b ? fst : std::move(snd);\n}\n</code></pre>\n<p>and clang and copied <code>snd</code> out while <code>gcc</code> moved it out.\nI tried to minimize the example and I came up with:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\nstruct printer {\n  printer() { }\n  printer(const printer&amp;) { std::cout &lt;&lt; \"copy\" &lt;&lt; std::endl; }\n  printer(printer&amp;&amp;) { std::cout &lt;&lt; \"move\" &lt;&lt; std::endl; }\n  printer(const printer&amp;&amp;) { std::cout &lt;&lt; \"const rvalue ref\" &lt;&lt; std::endl; }\n};\n\nint main() {\n  const printer fst;\n  printer snd;\n  false ? fst : std::move(snd);\n}\n</code></pre>\n<p>gcc 5.2 outputs</p>\n<pre><code>move\n</code></pre>\n<p>clang 3.6 outputs</p>\n<pre><code>const rvalue ref\n</code></pre>\n<p>Does the standard allow both the gcc and clang behavior?</p>\n<p>Random observations below:</p>\n<p>Both gcc and clang unify the type of the ternary to:</p>\n<pre><code>const printer\n</code></pre>\n<p><a href=\"https://goo.gl/Sl9oLT\">gcc 5.2 disassembly</a></p>\n<p><a href=\"https://goo.gl/LY0Wgi\">clang 3.6 disassembly</a></p>\n", "AcceptedAnswerId": "31578597", "Title": "Moving out of one side of a ternary operator", "CreationDate": "2015-07-23T03:40:47.387", "Id": "31577762", "CommentCount": "5", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-07-23T05:10:45.900", "LastEditorUserId": "3163831", "LastActivityDate": "2015-07-23T05:44:19.990", "Score": "11", "OwnerUserId": "3163831", "Tags": "<c++><c++11><gcc><clang>", "AnswerCount": "1"}});