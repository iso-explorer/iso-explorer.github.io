post_cb({"47620649": {"ViewCount": "29", "Body": "<p>I'm trying to invoke a function from a lambda that is part of running std::for_each in a specific member function.\nExample here:\n<a href=\"https://godbolt.org/g/KCBLjL\" rel=\"nofollow noreferrer\">https://godbolt.org/g/KCBLjL</a></p>\n<pre><code>namespace A {\n  struct Foo {\n    int a;\n    int b;\n  };\n\n  void dump(const A::Foo&amp; v) {\n      std::cout &lt;&lt; v.a &lt;&lt; v.b &lt;&lt; std::endl;\n  }\n} // ns A\n\nclass B {\npublic:\n   void dump() const {\n       (void)std::for_each(std::begin(foo), std::end(foo),\n                           [](const A::Foo &amp;f){\n                           dump(f); // &lt;- fails here, I expected ADL to kick in\n       });\n   }\nprivate:\n   std::vector&lt;A::Foo&gt; foo = { A::Foo{}, A::Foo{} };\n};\n</code></pre>\n<p>getting:</p>\n<pre><code>&lt;source&gt;: In lambda function:\n21 : &lt;source&gt;:21:19: error: no matching function for call to \n'B::dump(const A::Foo&amp;)'\n         dump(f);\n               ^\n18 : &lt;source&gt;:18:10: note: candidate: void B::dump() const\n         void dump() const {\n</code></pre>\n<p>Why does ADL fails here?\nI'd assume the compiler would find B::dump but also since A::Foo has dump(const Foo&amp;) in the same namespace, the compiler would add this as an option. But it does not work. Compiled with -std=c++17</p>\n", "AcceptedAnswerId": "47620746", "Title": "ADL fails when invoking function within a lambda", "CreationDate": "2017-12-03T16:41:59.857", "Id": "47620649", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2017-12-03T16:50:28.190", "Score": "2", "OwnerUserId": "1442880", "Tags": "<c++>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_47620649_47620746_0": {"length": 16, "quality": 1.0, "section_id": 7105}}, "n3337": {"so_47620649_47620746_0": {"length": 16, "quality": 1.0, "section_id": 6849}}, "n4659": {"so_47620649_47620746_0": {"length": 16, "quality": 1.0, "section_id": 8606}}}, "47620746": {"Id": "47620746", "PostTypeId": "2", "Body": "<p><a href=\"http://eel.is/c++draft/basic.lookup.argdep#3\" rel=\"nofollow noreferrer\">[basic.lookup.argdep]/3</a>, emphasis mine:</p>\n<blockquote>\n<p id=\"so_47620649_47620746_0\">Let <em>X</em> be the lookup set produced by unqualified lookup and let <em>Y</em> be the lookup set produced by argument dependent lookup (defined as follows).\n  <strong>If <em>X</em> contains</strong></p>\n<ul>\n<li><strong>a declaration of a class member</strong>, or</li>\n<li>a block-scope function declaration that is not a using-declaration, or</li>\n<li>a declaration that is neither a function nor a function template</li>\n</ul>\n<p id=\"so_47620649_47620746_1\"><strong>then <em>Y</em> is empty.</strong></p>\n</blockquote>\n", "LastActivityDate": "2017-12-03T16:50:28.190", "CommentCount": "0", "CreationDate": "2017-12-03T16:50:28.190", "ParentId": "47620649", "Score": "1", "OwnerUserId": "4672588"}, "47620701": {"Id": "47620701", "PostTypeId": "2", "Body": "<pre><code>void dump() const {\n</code></pre>\n<p>The issue is that you already have a symbol named <code>dump</code>() in scope that includes the lambda call, inside this method, here. That takes precedence.</p>\n<p>If you name this method <code>dump2()</code>, the lookup succeeds as expected.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/adl\" rel=\"nofollow noreferrer\">The key rule here:</a></p>\n<blockquote>\n<p id=\"so_47620649_47620701_0\">... are looked up in the namespaces of their arguments <strong>in addition to\n  the scopes and namespaces considered by the usual unqualified name\n  lookup</strong>.</p>\n</blockquote>\n<p>Emphasis mine. \"In addition to the scopes and namespaces scopes and namespaces considered by the usual unqualified name lookup\".</p>\n<p>The \"usual\" unqualified name lookup finds the <code>dump()</code> symbol in the calling class. Full stop.</p>\n", "LastActivityDate": "2017-12-03T16:45:45.237", "CommentCount": "0", "CreationDate": "2017-12-03T16:45:45.237", "ParentId": "47620649", "Score": "1", "OwnerUserId": "3943312"}});