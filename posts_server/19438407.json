post_cb({"19438407": {"CommentCount": "4", "AcceptedAnswerId": "19444353", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2013-10-17T22:26:35.813", "LastActivityDate": "2014-01-12T23:41:54.887", "LastEditDate": "2014-01-12T23:41:54.887", "ViewCount": "520", "FavoriteCount": "1", "Title": "What was the issue solved by the new \"using\" syntax for template typedefs?", "Id": "19438407", "Score": "16", "Body": "<p>In C++11 you can create a \"type alias\" by doing something like </p>\n<pre><code>template &lt;typename T&gt;\nusing stringpair = std::pair&lt;std::string, T&gt;;\n</code></pre>\n<p>But this is a deviation from what you'd expect a template typedef would look like:</p>\n<pre><code>template &lt;typename T&gt;\ntypedef std::pair&lt;std::string, T&gt; stringpair;\n</code></pre>\n<p>So this raises the question - why did they need to come up with a new syntax? what was it that did not work with the old <code>typedef</code> syntax?</p>\n<p>I realize the last bit doesn't compile but why can't it be made to compile?</p>\n", "Tags": "<c++><templates><c++11><typedef><template-aliases>", "OwnerUserId": "9611", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_19438407_19438466_0": {"section_id": 5408, "quality": 0.9090909090909091, "length": 30}, "so_19438407_19438466_1": {"section_id": 165, "quality": 0.8, "length": 16}}, "n3337": {"so_19438407_19438466_0": {"section_id": 5203, "quality": 0.9090909090909091, "length": 30}, "so_19438407_19438466_1": {"section_id": 159, "quality": 0.8, "length": 16}}, "n4659": {"so_19438407_19438466_0": {"section_id": 6830, "quality": 0.8484848484848485, "length": 28}, "so_19438407_19438466_1": {"section_id": 169, "quality": 0.8, "length": 16}}}, "19439100": {"ParentId": "19438407", "CommentCount": "0", "Body": "<p>One more reason for the new syntax - typedefs for functions, arrays and similar constructs become a bit more comprehensible.</p>\n<p>Reference to array before / after:</p>\n<pre><code>typedef int(&amp;my_type)[3];\nusing my_type = int(&amp;)[3];\n</code></pre>\n<p>Array of function pointers before / after:</p>\n<pre><code>typedef void(*my_type[3])();\nusing my_type = void(*[3])();\n</code></pre>\n", "OwnerUserId": "2665887", "PostTypeId": "2", "Id": "19439100", "Score": "0", "CreationDate": "2013-10-17T23:35:29.007", "LastActivityDate": "2013-10-17T23:35:29.007"}, "19444353": {"ParentId": "19438407", "CommentCount": "1", "Body": "<p>From the WG21 proposal <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1489.pdf\" rel=\"noreferrer\"><strong>N1489 Template aliases</strong></a> (by Stroustrup and Dos Reis):</p>\n<blockquote>\n<p id=\"so_19438407_19444353_0\">It has been suggested to (re)use the keyword <code>typedef</code> as done in the\n  paper [4] to introduce template aliases:</p>\n<pre><code> template&lt;class T&gt; \n typedef std::vector&lt;T, MyAllocator&lt;T&gt; &gt; Vec;\n</code></pre>\n<p id=\"so_19438407_19444353_1\">That notation has the advantage of using a keyword already known to\n  introduce a type alias. However, it also displays several disavantages\n  among which the confusion of using a keyword known to introduce an\n  alias for a type-name in a context where the alias does not designate\n  a type, but a template; Vec is not an alias for a type, and should not\n  be taken for a typedef-name. The name Vec is a name for the family\n  <code>std::vector&lt;o, MyAllocator&lt;o&gt; &gt;</code>  where the bullet is a placeholder\n  for a type-name. Consequently we do not propose the typedef syntax.</p>\n<p id=\"so_19438407_19444353_2\">On the other hand the sentence</p>\n<pre><code>template&lt;class T&gt; \nusing Vec = std::vector&lt;T, MyAllocator&lt;T&gt; &gt;;\n</code></pre>\n<p id=\"so_19438407_19444353_3\">can be read/interpreted as: from now on, I'll be using <code>Vec&lt;T&gt;</code> as a\n  synonym for <code>std::vector&lt;T, MyAllocator&lt;T&gt; &gt;</code>. With that reading, the\n  new syntax for aliasing seems reasonably logical.</p>\n</blockquote>\n<p>The paper [4] referred to in the above quote was a prior proposal WG21 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1406.pdf\" rel=\"noreferrer\"><strong>N1406 Proposed Addition to C++: Typedef Templates</strong></a> (by Herb Sutter). It uses both a different syntax (<code>typedef</code> vs <code>using</code>) as well as a different nomenclature (typedef templates vs template aliases). Herb's proposed syntax didn't make it, but the nomenclature can sometimes be found in informal discussions.</p>\n", "OwnerUserId": "819272", "PostTypeId": "2", "Id": "19444353", "Score": "9", "CreationDate": "2013-10-18T07:50:47.693", "LastActivityDate": "2013-10-18T07:50:47.693"}, "19438466": {"ParentId": "19438407", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><em>(tl;dr: <code>using</code> supports templates, whereas <code>typedef</code> does not.)</em></p>\n<hr>\n<p>As it sounds like you know already, the difference between the two examples <em>without templates</em> is nothing:</p>\n<blockquote>\n<p id=\"so_19438407_19438466_0\"><code>[C++11: 7.1.3/2]:</code> A <em>typedef-name</em> can also be introduced by an <em>alias-declaration</em>. The identifier following the <code>using</code> keyword becomes a <em>typedef-name</em> and the optional <em>attribute-specifier-seq</em> following the identifier appertains to that <em>typedef-name</em>. <strong>It has the same semantics as if it were introduced by the <code>typedef</code> specifier</strong>. In particular, it does not define a new type and it shall not appear in the <em>type-id</em>.</p>\n</blockquote>\n<p>However, template <code>typedef</code>s do not exist!</p>\n<blockquote>\n<p id=\"so_19438407_19438466_1\"><code>[C++11: 14.5.7/1]:</code> A <em>template-declaration</em> in which the declaration is an <em>alias-declaration</em> (Clause 7) declares the identifier to be a alias template. An alias template is a name for a family of types. The name of the alias template is a <em>template-name</em>.</p>\n</blockquote>\n<p>Why didn't they simply re-use <code>typedef</code> syntax? Well, I think <code>typedef</code> is simply the \"old\" style and, given the use of <code>using</code> in other contexts, it was decided that new functionality should take the <code>using</code> form for consistency.</p>\n</hr>", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2013-10-17T22:38:44.753", "Id": "19438466", "Score": "0", "CreationDate": "2013-10-17T22:32:25.330", "LastActivityDate": "2013-10-17T22:38:44.753"}, "19438479": {"ParentId": "19438407", "CommentCount": "8", "Body": "<p>I'll just refer to stroustrup himself:</p>\n<p><a href=\"http://www.stroustrup.com/C++11FAQ.html#template-alias\">http://www.stroustrup.com/C++11FAQ.html#template-alias</a></p>\n<blockquote>\n<p id=\"so_19438407_19438479_0\">The keyword using is used to get a linear notation \"name followed by\n  what it refers to.\" We tried with the conventional and convoluted\n  typedef solution, but never managed to get a complete and coherent\n  solution until we settled on a less obscure syntax.</p>\n</blockquote>\n", "OwnerUserId": "2725719", "PostTypeId": "2", "Id": "19438479", "Score": "18", "CreationDate": "2013-10-17T22:33:52.087", "LastActivityDate": "2013-10-17T22:33:52.087"}});