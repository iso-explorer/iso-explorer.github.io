post_cb({"4885497": {"Id": "4885497", "PostTypeId": "2", "Body": "<p>According C++ standard 3.3.6 </p>\n<blockquote>\n<p id=\"so_4884494_4885497_0\">The following rules describe the scope of names declared in classes.</p>\n<p id=\"so_4884494_4885497_1\">1) The potential scope of a name declared in a class consists not only of the declarative region following the name\u2019s declarator, but also of all function bodies, default arguments, and constructor ctor- initializers in that class (including such things in nested classes).\n  ...........</p>\n</blockquote>\n<p>So you can declare only things from this list in class scope. Declaring anything else in class scope isn't valid. Not only namespace alliance, but also namespace. For example</p>\n<pre><code>class myClass\n{\n    //compilation error !!!\n    namespace myNamespace\n    {\n    }\n    using namespace std;//another compilation error\n}\n</code></pre>\n<p><strong>Edit:</strong> </p>\n<blockquote>\n<p id=\"so_4884494_4885497_2\">Any idea why such a restriction exists ? This doesn't seem very consistent with typedefs which can be declared inside a class.</p>\n</blockquote>\n<p>Because using typedefs in classes are very usefull (for example <code>vector&lt;int&gt;::iterator</code>), while for namespaces it's useless. Consider following code</p>\n<pre><code>class myClass\n{\n   namespce N=std;\n};\n\n//now let's use N\nMyClass::N::vector&lt;int&gt; v;//don't you think, that this syntax is horrible, and useless?????\n</code></pre>\n<p>For comparison see what it is doing in function</p>\n<pre><code>void f()\n{\n    namespace bnu= boost::numeric::ublas;\n    bnu::matrix&lt;int&gt; m;//and now we can use short name bnu\n}\n</code></pre>\n<p>For class we can declare namespace alliance in cpp file and  there is  <strong>NO NEED</strong> to daclare it in class declaration.</p>\n", "LastEditorUserId": "556049", "LastActivityDate": "2011-02-03T15:21:08.647", "Score": "6", "CreationDate": "2011-02-03T11:22:11.883", "ParentId": "4884494", "CommentCount": "1", "LastEditDate": "2011-02-03T15:21:08.647", "OwnerUserId": "556049"}, "bq_ids": {"n4140": {"so_4884494_4885478_0": {"length": 13, "quality": 1.0, "section_id": 5861}, "so_4884494_4885497_1": {"length": 23, "quality": 0.8214285714285714, "section_id": 7070}, "so_4884494_4885497_0": {"length": 7, "quality": 0.875, "section_id": 7070}}, "n3337": {"so_4884494_4885478_0": {"length": 13, "quality": 1.0, "section_id": 5631}, "so_4884494_4885497_0": {"length": 7, "quality": 0.875, "section_id": 6814}, "so_4884494_4885497_1": {"length": 23, "quality": 0.8214285714285714, "section_id": 6814}}, "n4659": {"so_4884494_4885478_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 7342}, "so_4884494_4885497_1": {"length": 23, "quality": 0.8214285714285714, "section_id": 8567}}}, "9089275": {"Id": "9089275", "PostTypeId": "2", "Body": "<p>I disagree that namespace declaration within a class is completely useless.  It would be useful to be able to declare enumerations within namespaces within classes.  This would alow you to access the elements of different arrays with logical indices for the specific array.</p>\n<pre><code>class myClass\n{\n   private:\n        namespace TransAndRotIdx {\n            enum { U, V, W, P, Q, R }; };\n        namespace RotIdx {\n            enum { P, Q, R }; };\n        double tr[6];\n        double r[3];\n\n    public:\n        double getTranslationMag(void)\n        {\n            using namespace TransAndRotIdx;\n            return sqrt(tr[U]*tr[U]+tr[V]*tr[V]+tr[W]*tr[W]);\n        }\n        double getRotationMag(void)\n        {\n            using namespace RotIdx;\n            return sqrt(tr[P]*tr[P]+tr[Q]*tr[Q]+tr[R]*tr[R]);\n        }\n}\n</code></pre>\n", "LastActivityDate": "2012-02-01T00:51:32.067", "CommentCount": "1", "CreationDate": "2012-02-01T00:51:32.067", "ParentId": "4884494", "Score": "3", "OwnerUserId": "1181670"}, "4884494": {"ViewCount": "3305", "Body": "<p>It looks like it's impossible to declare a namespace alias inside a class; however we can do so at function-level (tested with g++ 4.3.4) :</p>\n<pre><code>namespace A\n{\n}\n\nclass C\n{\n  namespace N = A; // error: expected unqualified-id before `namespace'\n};\n\nclass D\n{\n  void f();\n};\n\nvoid D::f()\n{\n  namespace N = A; // OK\n}\n</code></pre>\n<p>Any idea why such a restriction exists ? This doesn't seem very consistent with typedefs which can be declared inside a class.</p>\n", "AcceptedAnswerId": "4885478", "Title": "Why can't we declare namespace aliases inside a class?", "CreationDate": "2011-02-03T09:45:10.767", "Id": "4884494", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2012-02-01T00:51:32.067", "Score": "13", "OwnerUserId": "138807", "Tags": "<c++><namespaces>", "AnswerCount": "3"}, "4885478": {"Id": "4885478", "PostTypeId": "2", "Body": "<p>I'm not an expert on the C++ Standard but I'll stick my neck out and have a go at answering your question. I assume the use of <code>namespace N = A</code> within a class declaration falls foul of the definition of how a class member should be defined.</p>\n<p>The C++ Standard defines a class member as </p>\n<pre><code>member-specification:\n  member-declaration member-specification_opt\n  access-specifier : member-specification_opt\nmember-declaration:\n  decl-specifier-seq_opt member-declarator-list_opt ;\n  function-definition ;opt\n  ::opt nested-name-specifier templateopt unqualified-id ;\n  using-declaration\n  static_assert-declaration\n  template-declaration\nmember-declarator-list:\n  member-declarator\n  member-declarator-list , member-declarator\nmember-declarator:\n  declarator pure-specifier_opt\n  declarator constant-initializer_opt\n  identifier_opt : constant-expression\npure-specifier:\n  = 0\nconstant-initializer:\n  = constant-expression\n</code></pre>\n<p>The important point being the <code>=</code> in the declaration, the compiler is expecting either a pure-specifier or constant-initializer statement and as the line does not end in a zero, we are not applying a pure-specifier in this case.</p>\n<p>Analysing the <code>namespace N = A</code> declaration the compiler sees this as</p>\n<pre><code>declarator = constant-expression\n</code></pre>\n<p>And since <code>namespace</code> is a keyword it cannot be used.</p>\n<p><code>typedef</code> is permitted because (from the standard)</p>\n<blockquote>\n<p id=\"so_4884494_4885478_0\">Nested types are classes and enumerations defined in the class, \n  and arbitrary types declared as members by use of a typedef declaration.</p>\n</blockquote>\n", "LastActivityDate": "2011-02-03T11:20:58.770", "CommentCount": "1", "CreationDate": "2011-02-03T11:20:58.770", "ParentId": "4884494", "Score": "5", "OwnerUserId": "243925"}});