post_cb({"33574233": {"CommentCount": "3", "ViewCount": "173", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2015-11-06T19:27:38.170", "LastActivityDate": "2015-11-10T11:20:21.130", "Title": "Does virtual inheritance force a base class to be default constructible?", "AcceptedAnswerId": "33628803", "LastEditDate": "2015-11-09T12:24:03.500", "Id": "33574233", "Score": "5", "Body": "<p>In the following code, the compiler is requesting the base <strong>class X</strong> to be <strong>default constructible</strong>. However, if I remove the <strong>virtual</strong> keyword from the inheritance of the <strong>class Node</strong>, the access to the member <strong>m_x</strong> becomes, of course, ambiguous, but the <strong>default constructor</strong> for <strong>class X</strong> is no longer required.</p>\n<p>What is the reason for that?</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Apply\n{\n    template&lt; typename T &gt;\n    struct Node : virtual T    // this line contains the virtual inheritance\n    {\n        template&lt; typename ...Args&gt;\n        Node( Args... args )\n            : T( args... )\n        {}\n    };\n\n    template &lt; typename ...BaseClasses&gt;\n    struct Inheritance;\n\n    template &lt; typename FirstBaseClass, typename ...OtherBaseClasses&gt;\n    struct Inheritance&lt; FirstBaseClass, OtherBaseClasses... &gt;   : FirstBaseClass\n            , Inheritance&lt; OtherBaseClasses... &gt;\n    {\n        template&lt; typename ...Args&gt;\n        Inheritance( Args... args )\n            : FirstBaseClass( args... )\n            , Inheritance&lt; OtherBaseClasses... &gt;( args... )\n        {\n\n        }\n    };\n};\n\ntemplate &lt; &gt;\nstruct Apply::Inheritance&lt; &gt;\n{\n    template&lt; typename ...Args&gt;\n    Inheritance( Args... args ){}\n};\n\nstruct X\n{\n    X(int i){}\n\n    int m_x;\n};\n\nstruct A : Apply::Node&lt; X &gt;\n{\n    A( int i )\n        : Apply::Node&lt; X &gt;( i )\n        , m_a( i )\n    {\n\n    }\n    int m_a;\n};\n\n\nstruct B : Apply::Node&lt; X &gt;\n{\n    B( int i )\n        : Apply::Node&lt; X &gt;( i )\n        , m_b( i )\n    { }\n\n    int m_b;\n};\n\nstruct C : Apply::Node&lt; X &gt;\n{\n    C( int i )\n        : Apply::Node&lt; X &gt;( i )\n        , m_c( i )\n    { }\n\n    int m_c;\n};\n\nstruct Example : Apply::Inheritance&lt; A, B, C &gt;\n{\n    Example( int i )\n        : Apply::Inheritance&lt; A, B, C &gt;( i )\n    { }\n\n    void print( ) const\n    {\n        // this line needs the virtual inheritance\n        std::cout &lt;&lt; m_x &lt;&lt; std::endl;\n\n        std::cout &lt;&lt; m_a &lt;&lt; std::endl;\n        std::cout &lt;&lt; m_b &lt;&lt; std::endl;\n        std::cout &lt;&lt; m_c &lt;&lt; std::endl;\n    }\n};\n\nint main()\n{\n    Example ex( 10 );\n\n    ex.print( );\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><variadic-templates><template-meta-programming><default-constructor><virtual-inheritance>", "OwnerUserId": "3074280", "AnswerCount": "2"}, "33628803": {"ParentId": "33574233", "CommentCount": "0", "Body": "<p>Starting from @Berry answer, the only way to fix the code was to code an explicit call to the virtual inherited <strong>X</strong> constructor. </p>\n<p>However, it is not enough to explicit call the construction of X in classes <strong>A</strong>, <strong>B</strong>, or <strong>C</strong>: it must be called basically in <strong>every class</strong> involved in the inheritance at any level!</p>\n<p>The tricky one was the <strong>Inheritance&lt;&gt;</strong> variadic template class: every step of the variadic expansion must provide the explicit call to the X constructor.</p>\n<p>Here is the code that works on <strong>MinGW 4.9.2</strong> with enabled C++11 flag:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt; typename T, typename V &gt;\nstruct Node : virtual V\n{\n    using Virtual = V;    // Added this line\n\n    template&lt; typename ...Args &gt;\n    Node( Args... args )\n        : V( args... )\n    { }\n};\n\ntemplate &lt; typename ...BaseClasses&gt;\nstruct Inheritance;\n\ntemplate &lt; typename FirstBaseClass, typename ...OtherBaseClasses&gt;\nstruct Inheritance&lt; FirstBaseClass, OtherBaseClasses... &gt;\n        : FirstBaseClass\n        , Inheritance&lt; OtherBaseClasses... &gt;\n{\n    template&lt; typename ...Args&gt;\n    Inheritance( Args... args )\n        : FirstBaseClass::Virtual( args... )    // added this line\n        , FirstBaseClass( args... )\n        , Inheritance&lt; OtherBaseClasses... &gt;( args... )\n    { }\n};\n\ntemplate &lt; &gt;\nstruct Inheritance&lt; &gt;\n{\n    template&lt; typename ...Args &gt;\n    Inheritance( Args... args )\n    { }\n};\n\nstruct X\n{\n    X(int i)\n        : m_x( i )\n    { }\n\n    int m_x;\n};\n\nstruct A : Node&lt; A, X &gt;\n{\n    A( int i )\n        : X( i )    // added this line\n        , Node&lt; A, X &gt;( i )\n        , m_a( i )\n    { }\n\n    int m_a;\n};\n\n\nstruct B : Node&lt; B, X &gt;\n{\n    B( int i )\n        : X ( i )    // added this line\n        , Node&lt; B, X &gt;( i )\n        , m_b( i )\n    { }\n\n    int m_b;\n};\n\nstruct C : Node&lt; C, X &gt;\n{\n    C( int i )\n        : X ( i )    // added this line\n        , Node&lt; C, X &gt;( i )\n        , m_c( i )\n    { }\n\n    int m_c;\n};\n\nstruct Example : Inheritance&lt; A, B, C &gt;\n{\n    Example( int i )\n        : X ( i )    // added this line\n        , Inheritance&lt; A, B, C &gt;( i )\n    { }\n\n    void print( ) const\n    {\n        // this line needs the virtual inheritance\n        std::cout &lt;&lt; m_x &lt;&lt; std::endl;\n\n        std::cout &lt;&lt; m_a &lt;&lt; std::endl;\n        std::cout &lt;&lt; m_b &lt;&lt; std::endl;\n        std::cout &lt;&lt; m_c &lt;&lt; std::endl;\n    }\n};\n\nint main()\n{\n    Example ex( 10 );\n\n    ex.print( );\n\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "3074280", "PostTypeId": "2", "Id": "33628803", "Score": "0", "CreationDate": "2015-11-10T11:20:21.130", "LastActivityDate": "2015-11-10T11:20:21.130"}, "bq_ids": {"n4140": {"so_33574233_33574389_0": {"section_id": 438, "quality": 1.0, "length": 35}}, "n3337": {"so_33574233_33574389_0": {"section_id": 429, "quality": 1.0, "length": 35}}, "n4659": {"so_33574233_33574389_0": {"section_id": 458, "quality": 1.0, "length": 35}}}, "33574389": {"ParentId": "33574233", "CommentCount": "5", "Body": "<p>The initialization ordering for a class goes like this [class.base.init]:</p>\n<blockquote>\n<p id=\"so_33574233_33574389_0\">In a non-delegating constructor, initialization proceeds in the following order:<br>\n  \u2014 First, and only for the constructor of the most derived class (1.8), virtual base classes are initialized in\n  the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes,\n  where \u201cleft-to-right\u201d is the order of appearance of the base classes in the derived class base-specifier-list.</br></p>\n</blockquote>\n<p>Your hierarchy is <code>A --&gt; Node&lt;X&gt; --&gt; X</code>, so the first thing to get initialized is the <code>X</code>, since it's a virtual base class. It's not specified in your mem-initializer, so the implicit default construction is inserted:</p>\n<pre><code>A( int i )\n    : X() // &lt;== implicit \n    , Node&lt; X &gt;( i )\n    , m_a( i )\n{\n\n}\n</code></pre>\n<p>Since <code>X</code> isn't default constructible, you get that error. You can fix this with just explicitly providing the right thing:</p>\n<pre><code>A( int i )\n    : X(i)\n    , Node&lt; X &gt;( i )\n    , m_a( i )\n{\n</code></pre>\n<p>You don't have to worry about <code>X</code> being constructed twice, since virtual base classes are only constructed for the <strong>most</strong> derived class... which would be <code>A</code> and not <code>Node&lt;X&gt;</code>.</p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "33574389", "Score": "5", "CreationDate": "2015-11-06T19:37:07.007", "LastActivityDate": "2015-11-06T19:37:07.007"}});