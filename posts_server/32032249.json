post_cb({"bq_ids": {"n4140": {"so_32032249_32034107_1": {"length": 7, "quality": 1.0, "section_id": 3290}, "so_32032249_32034107_0": {"length": 21, "quality": 0.65625, "section_id": 3325}}, "n3337": {"so_32032249_32034107_1": {"length": 7, "quality": 1.0, "section_id": 3160}, "so_32032249_32034107_0": {"length": 17, "quality": 0.53125, "section_id": 3195}}, "n4659": {"so_32032249_32034107_1": {"length": 7, "quality": 1.0, "section_id": 4052}, "so_32032249_32034107_0": {"length": 30, "quality": 0.9375, "section_id": 4091}}}, "32032249": {"ViewCount": "189", "Body": "<p>Following up on <a href=\"https://stackoverflow.com/questions/26914076/initialization-list-bug-in-gcc\">this question about multiple (virtual) inheritance</a>, I'd like to inquire about a simple MWE that makes <strong>g++ 5.2.0</strong> upset whereas <strong>clang++ 3.6.2</strong> handles it just fine, with no complaints at all, even with <code>-Wall</code> and <code>-Wextra</code> set. So here's the MWE:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class Z {};\nclass A : virtual Z { protected: A() {} };\nclass B : virtual Z { protected: B() {} };\nclass C : A, B { public: C() : A{}, B{} {} };\nint main() { C c{}; return 0; }\n</code></pre>\n<p>Unlike clang++, g++ complains like this:</p>\n<pre class=\"lang-none prettyprint-override\"><code>gccodd.c++: In constructor \u2018C::C()\u2019:\ngccodd.c++:2:34: error: \u2018A::A()\u2019 is protected\n class A : virtual Z { protected: A() {} };\n                                  ^\ngccodd.c++:4:39: error: within this context\n class C : A, B { public: C() : A{}, B{} {} };\n                                       ^\ngccodd.c++:3:34: error: \u2018B::B()\u2019 is protected\n class B : virtual Z { protected: B() {} };\n                                  ^\ngccodd.c++:4:39: error: within this context\n class C : A, B { public: C() : A{}, B{} {} };\n                                       ^\n</code></pre>\n<p>Replacing the uniform initialization in C's constructor with the old form works fine though and both clang++ and g++ are happy with the following:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class C : A, B { public: C() : A(), B() {} };\n</code></pre>\n<p>This yields the two obvious options:</p>\n<ol>\n<li>The code violates the standard in some way, making the outcome undefined (i.e., any outcome would be acceptable).</li>\n<li>One of the two compilers has a bug related to uniform initialization and multiple + virtual inheritance.</li>\n</ol>\n<p>If it were a matter of voting, (1) might win, because <strong>icpc 15.0.0</strong> says the following:</p>\n<pre class=\"lang-none prettyprint-override\"><code>gccodd.c++(4): error #453: protected function \"A::A()\" (declared at line 2) is not accessible through a \"A\" pointer or object\n  class C : public virtual A, public virtual B { public: C() : A{}, B{} {} };\n                                                                ^\n\ngccodd.c++(4): error #453: protected function \"B::B()\" (declared at line 3) is not accessible through a \"B\" pointer or object\n  class C : public virtual A, public virtual B { public: C() : A{}, B{} {} };\n                                                                     ^\n</code></pre>\n<p>So, is it (1) or (2)? And if it's the former case, then what's wrong with my MWE?</p>\n", "Title": "Virtual inheritance and uniform initialization in C++", "CreationDate": "2015-08-16T05:52:07.000", "LastActivityDate": "2015-08-20T08:32:44.413", "CommentCount": "4", "LastEditDate": "2017-05-23T12:22:01.177", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "32032249", "Score": "6", "OwnerUserId": "1715611", "Tags": "<c++><c++11><inheritance><gcc><c++14>", "AnswerCount": "1"}, "32034107": {"Id": "32034107", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_32032249_32034107_0\">List-initialization of an object or reference of type <code>T</code> is defined as\n  follows:<br> (3.1) \u2014 If <code>T</code> is a class type and the initializer list has a\n  single element of type <em>cv</em> <code>U</code> [..]<br> (3.2) \u2014 Otherwise, if <code>T</code> is a\n  character array [..] <br>(3.3) \u2014 Otherwise, if T is an aggregate,\n  aggregate initialization is performed (8.5.1). <br>(3.4) \u2014 <strong>Otherwise, if\n  the initializer list has no elements and <code>T</code> is a class type with a\n  default constructor, the object is value-initialized.</strong></br></br></br></br></p>\n</blockquote>\n<p><code>A</code> and <code>B</code> both have base classes and hence aren't aggregates. So the fourth bullet point applies. And thus we have the exact same effect as if we had used <code>()</code>:</p>\n<blockquote>\n<p id=\"so_32032249_32034107_1\">An object whose initializer is an empty set of parentheses, i.e.,\n  <code>()</code>, shall be value-initialized.</p>\n</blockquote>\n<p>Any compiler yielding different results with those initializers cannot be  conforming.  </p>\n<p>\u00a711.4, which handles access to <code>protected</code> members, does not mention anything related to the form of initialization. However, concerning initialization of bases in a mem-initializer in the constructor, \u00a711.4 is defective at the moment as mentioned by CWG issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1883\" rel=\"nofollow\"><strong>#1883</strong></a>.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2015-08-20T08:32:44.413", "Score": "5", "CreationDate": "2015-08-16T10:35:39.943", "ParentId": "32032249", "CommentCount": "1", "OwnerUserId": "3647361", "LastEditDate": "2015-08-20T08:32:44.413"}});