post_cb({"3276235": {"CommentCount": "8", "ViewCount": "414", "PostTypeId": "1", "LastEditorUserId": "388056", "CreationDate": "2010-07-18T16:08:22.313", "LastActivityDate": "2010-07-31T18:27:36.417", "Title": "relation between access specifiers and using initializer lists for POD types in c++0x", "AcceptedAnswerId": "3379328", "LastEditDate": "2010-07-19T05:16:44.633", "Id": "3276235", "Score": "2", "Body": "<p>take two following classes:</p>\n<pre><code>class Test1{\n public:\n  Test1()=default;\n  Test1(char in1,char in2):char1(in1),char2(in2){}\n  char char1;\n  char char2;\n};\nclass Test2{\n public:\n  Test2()=default;\n  Test2(char in1,char in2):char1(in1),char2(in2){}\n private:\n  char char1;\n  char char2;\n};\n</code></pre>\n<p>I know in c++0x both of these classes are considered as POD types and we can initialize objects of them using initializer lists as below:</p>\n<pre><code>Test1 obj1={'a','b'};//valid in c++0x\nTest2 obj2={'a','b'};//valid in c++0x\n</code></pre>\n<p>But I wonder what the technical reason is that when we have different access specifiers in a class like below, it's not possible to use initializer list for initializing objects of that class and that class is not considered as a POD type ?</p>\n<pre><code>class Test{\n public:\n  Test()=default;\n  Test(char in1,char in2):char1(in1),char2(in2){}\n  char char1;\n private:\n  char char2;\n};\nTest obj={'a','b'};//invalid in c++0x\n</code></pre>\n<p><strong>In case you don't know definition of PODs in c++0x:</strong><br>\nA class/struct is considered a POD if it is trivial, standard-layout, and if all of its non-static members are PODs.</br></p>\n<p>A trivial class or struct is defined as one that:</p>\n<ol>\n<li>Has a trivial default constructor. This may use the default constructor syntax (SomeConstructor() = default;).</li>\n<li>Has a trivial copy constructor, which may use the default syntax.</li>\n<li>Has a trivial copy assignment operator, which may use the default syntax.</li>\n<li>Has a trivial destructor, which must not be virtual.</li>\n</ol>\n<p>A standard-layout class or struct is defined as one that:</p>\n<ol>\n<li>Has only non-static data members that are of standard-layout type</li>\n<li>Has the same access control (public, private, protected) for all non-static members</li>\n<li>Has no virtual functions</li>\n<li>Has no virtual base classes</li>\n<li>Has only base classes that are of standard-layout type</li>\n<li>Has no base classes of the same type as the first defined non-static member</li>\n<li>Either has no base classes with non-static members, or has no non-static data members in the most derived class and at most one base class with non-static members. In essence, there may be only one class in this class's hierarchy that has non-static members.  </li>\n</ol>\n<p><strong>In case you don't know what a trivial constructor or operator is:</strong><br>\nCompiler generates a trivial one of each of following items for a class, in case it isn't user-declared:\nCopy constructor, destructor and copy assignment operator.<br>\nAnd also if there's no user-declared constructor for a class, a trivial default constructor is generated for that class, in case there are any user-declared constructors you can use the syntax(SomeConstructor() = default;) to make your own trivial default constructor.</br></br></p>\n", "Tags": "<c++><initialization><c++11><aggregate><pod>", "OwnerUserId": "388056", "AnswerCount": "2"}, "3276642": {"ParentId": "3276235", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The \"technical\" reason is due to the following:</p>\n<blockquote>\n<p id=\"so_3276235_3276642_0\">Nonstatic data members of a (non-union) class with the same access control are allocated so that later members have higher addresses within a class object. The order of allocation of non-static data members with different access control is unspeci\ufb01ed (C++0x \u00a79.2/12). </p>\n</blockquote>\n<p>So long as all the nonstatic data members have the same access control, their order is well-specified; otherwise their order is unspecified.</p>\n", "OwnerUserId": "151292", "LastEditorUserId": "168225", "LastEditDate": "2010-07-18T19:36:54.023", "Id": "3276642", "Score": "3", "CreationDate": "2010-07-18T18:10:18.223", "LastActivityDate": "2010-07-18T19:36:54.023"}, "bq_ids": {"n4140": {"so_3276235_3276642_0": {"section_id": 5873, "quality": 0.8620689655172413, "length": 25}}, "n3337": {"so_3276235_3276642_0": {"section_id": 5644, "quality": 0.8620689655172413, "length": 25}}, "n4659": {"so_3276235_3276642_0": {"section_id": 7356, "quality": 0.8620689655172413, "length": 25}}}, "3379328": {"ParentId": "3276235", "CommentCount": "0", "Body": "<pre><code>class Test{\n public:\n  Test()=default;\n  Test(char in1,char in2):char1(in1),char2(in2){}\n  char char1;\n private:\n  char char2;\n};\n</code></pre>\n<p>considering above class following syntax is valid in c++0x:</p>\n<pre><code>Test obj={'a','b'};//valid in c++0x\n</code></pre>\n<p>The final proposal is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2640.pdf\" rel=\"nofollow noreferrer\"><strong>here</strong></a>.</p>\n", "OwnerUserId": "388056", "PostTypeId": "2", "Id": "3379328", "Score": "0", "CreationDate": "2010-07-31T18:27:36.417", "LastActivityDate": "2010-07-31T18:27:36.417"}});