post_cb({"bq_ids": {"n4140": {"so_23557419_23557641_0": {"length": 14, "quality": 1.0, "section_id": 380}, "so_23557419_23557641_1": {"length": 4, "quality": 0.8, "section_id": 5806}}, "n3337": {"so_23557419_23557641_0": {"length": 14, "quality": 1.0, "section_id": 371}, "so_23557419_23557641_1": {"length": 4, "quality": 0.8, "section_id": 5579}}, "n4659": {"so_23557419_23557641_0": {"length": 14, "quality": 1.0, "section_id": 395}, "so_23557419_23557641_1": {"length": 4, "quality": 0.8, "section_id": 7267}}}, "23557419": {"ViewCount": "153", "Body": "<p>Is following code standard compliant:</p>\n<pre><code>struct Temp\n{\n    Temp&amp; op1() { ...; return *this; }\n    Temp&amp; op2() { ...; return *this; }\n    // more op...\n};\n\nTemp().op1().op2()....;   // safe or not? Which paragraph from ISO 12.2 qualifies it?\n</code></pre>\n", "AcceptedAnswerId": "23557641", "Title": "successively calling temporary object's methods", "CreationDate": "2014-05-09T05:46:54.807", "LastActivityDate": "2014-05-09T15:43:49.593", "CommentCount": "1", "LastEditDate": "2014-05-09T06:08:55.977", "PostTypeId": "1", "Tags": "<c++>", "Id": "23557419", "AnswerCount": "2", "Score": "4", "OwnerUserId": "872102", "ClosedDate": "2014-05-09T15:10:11.553", "LastEditorUserId": "872102"}, "23557641": {"Id": "23557641", "PostTypeId": "2", "Body": "<p>Totally safe.</p>\n<p>It's in paragraph 3 (of \u00a712.2, <code>[class.temporary]</code>):</p>\n<blockquote>\n<p id=\"so_23557419_23557641_0\">Temporary objects are destroyed as the last step in evaluating the full-expression (1.9) that (lexically) contains the point where they were created.</p>\n</blockquote>\n<p>\u00a71.9/10 (<code>[intro.execution]</code>) defines full-expression:</p>\n<blockquote>\n<p id=\"so_23557419_23557641_1\">A full-expression is an expression that is not a subexpression of another expression.</p>\n</blockquote>\n<p>and includes an example somewhat similar to your question:</p>\n<pre><code>void f() {\n  if (S(3).v()) // full-expression includes lvalue-to-rvalue and\n                // int to bool conversions, performed before\n                // temporary is deleted at end of full-expression\n  { }\n}\n</code></pre>\n<p>The quotes and paragraph numbering come from N3691, the mid-2013 c++-draft, but they haven't changed in a few years and they will probably continue to be valid in C++1x and quite possibly even in C++1y (x\u22454; y\u22457)</p>\n", "LastEditorUserId": "1566221", "LastActivityDate": "2014-05-09T15:43:49.593", "Score": "7", "CreationDate": "2014-05-09T06:03:56.883", "ParentId": "23557419", "CommentCount": "5", "OwnerUserId": "1566221", "LastEditDate": "2014-05-09T15:43:49.593"}, "23557624": {"Id": "23557624", "PostTypeId": "2", "Body": "<p>Original code:</p>\n<pre><code>struct Temp\n{\n    Temp&amp; op1() { ...; return *this; }\n    Temp&amp; op2() { ...; return *this; }\n    // more op...\n}\n</code></pre>\n<p>Due to the lack of a final semicolon this code is not standard-compliant and will not compile.</p>\n<p>It illustrates the importance of posting real code.</p>\n<hr>\n<p>That said, yes, member functions, even non-<code>const</code> member funcitons, can be called on temporary class type objects, and that includes the assignment operator.</p>\n<p>And yes, the lifetime of a temporary extends to the end of the full expression (unless extended by binding to a reference).</p>\n</hr>", "LastActivityDate": "2014-05-09T06:03:14.227", "CommentCount": "1", "CreationDate": "2014-05-09T06:03:14.227", "ParentId": "23557419", "Score": "3", "OwnerUserId": "464581"}});