post_cb({"41902914": {"CommentCount": "9", "ViewCount": "121", "PostTypeId": "1", "LastEditorUserId": "3204551", "CreationDate": "2017-01-27T20:59:07.930", "LastActivityDate": "2017-01-27T22:48:31.700", "Title": "Ambiguity while calling template function", "AcceptedAnswerId": "41903588", "LastEditDate": "2017-01-27T21:03:57.940", "Id": "41902914", "Score": "3", "Body": "<p>I have the following problem:</p>\n<pre><code>template&lt; typename T &gt;\nclass A\n{};\n\nclass B\n{\n  public:\n    template&lt; typename... T &gt;\n    void operator()( A&lt;T&gt;... a )\n    {\n      std::cout &lt;&lt; \"A&lt;T&gt;\\n\";\n    }\n\n    template&lt; typename callable &gt;\n    void operator()( callable f )\n    {\n      std::cout &lt;&lt; \"callable\\n\";\n    }\n};\n\n\nint main()\n{\n  B      b;\n  A&lt;int&gt; a;\n\n  b( a );\n}\n</code></pre>\n<p>The call <code>b( a )</code> is ambiguous -- I expected the output <code>A&lt;T&gt;</code>, i.e., the execution of the first definition of <code>operator()</code>. Does anyone know how to fix it?</p>\n", "Tags": "<c++><templates><c++14><variadic-templates><ambiguity>", "OwnerUserId": "7006673", "AnswerCount": "2"}, "41903588": {"ParentId": "41902914", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Up to and including standard working draft N4606 (this includes the published C++11 and C++14 standards), the call was indeed ambiguous, and Clang was correct to reject it. A change introduced in the latest draft, N4618, makes the partial ordering rules select the <code>A&lt;T&gt;...</code> overload. This is a very recent change; we need to give compilers some time to implement it.</p>\n<p>MSVC 2015 U3 and EDG 4.11 choose the <code>A&lt;T&gt;...</code> overload, so they were non-conforming before and have magically become compliant with the latest draft in this respect.</p>\n<p>What happens is that after template argument deduction we have two overloads that are both template specializations and are equally good based on conversions (identity conversions for both, obviously), so overload resolution has to resort to partial ordering of function templates.</p>\n<p>The process is described in the standard in [temp.deduct.partial], and we're interested in paragraph 8. Before draft N4618, it said:</p>\n<blockquote>\n<p id=\"so_41902914_41903588_0\"><strong>If <code>A</code> was transformed from a function parameter pack and <code>P</code> is not a\n  parameter pack, type deduction fails.</strong> Otherwise, using the resulting\n  types <code>P</code> and <code>A</code>, the deduction is then done as described in\n  14.8.2.5. If <code>P</code> is a function parameter pack, the type <code>A</code> of each remaining parameter type of the argument template is compared with the\n  type <code>P</code> of the <em>declarator-id</em> of the function parameter pack. Each\n  comparison deduces template arguments for subsequent positions in the\n  template parameter packs expanded by the function parameter pack. If\n  deduction succeeds for a given type, the type from the argument\n  template is considered to be at least as specialized as the type from\n  the parameter template.</p>\n</blockquote>\n<p>(emphasis mine above and below)</p>\n<p>Attempting deduction from the first overload to the second, <code>A</code> is a pack and <code>P</code> is not, so the first sentence in the paragraph above applies; deduction fails. Attempting deduction the other way around, the third and fourth sentences apply, but deduction fails again because we're trying to deduce arguments for a parameter of the form <code>A&lt;T&gt;</code> from an argument of a general form <code>callable</code>. </p>\n<p>So, deduction fails both ways; neither template is more specialized than the other; the call is ambiguous.</p>\n<p>The new wording for the paragraph is the following:</p>\n<blockquote>\n<p id=\"so_41902914_41903588_1\">Using the resulting types <code>P</code> and <code>A</code>, the deduction is then done as\n  described in 14.8.2.5. If <code>P</code> is a function parameter pack, the type\n  <code>A</code> of each remaining parameter type of the argument template is\n  compared with the type P of the <em>declarator-id</em> of the function\n  parameter pack. Each comparison deduces template arguments for\n  subsequent positions in the template parameter packs expanded by the\n  function parameter pack. <strong>Similarly, if <code>A</code> was transformed from a\n  function parameter pack, it is compared with each remaining parameter\n  type of the parameter template.</strong> If deduction succeeds for a given\n  type, the type from the argument template is considered to be at least\n  as specialized as the type from the parameter template.</p>\n</blockquote>\n<p>Note that the first sentence is gone and was replaced with the one emphasised, which allows deduction from a pack <code>A</code> to a non-pack <code>P</code>.</p>\n<p>Now, deduction succeeds from <code>A&lt;T&gt;</code> to <code>callable</code> thanks to the new rule, and still fails the other way around (nothing changed). This makes the first overload more specialized.</p>\n<hr>\n<p>Quick fix: You can add a leading non-pack parameter to the first overload:</p>\n<pre><code>template&lt;class T, class... Ts&gt; void operator()(A&lt;T&gt;, A&lt;Ts&gt;...)\n</code></pre>\n<p>This will avoid the comparison between a pack and a non-pack for the first position in the function parameter list. A non-pack <code>A&lt;T&gt;</code> is clearly more specialized than <code>callable</code> for all compilers.</p>\n<p>If you need an overload that matches a call with no arguments, provide one separately (sorry...).</p>\n</hr>", "OwnerUserId": "4326278", "LastEditorUserId": "4326278", "LastEditDate": "2017-01-27T22:48:31.700", "Id": "41903588", "Score": "9", "CreationDate": "2017-01-27T21:49:59.620", "LastActivityDate": "2017-01-27T22:48:31.700"}, "41903760": {"ParentId": "41902914", "CommentCount": "0", "Body": "<p>Thank you.</p>\n<p>I solved the problem as follows:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt; typename T &gt;\nclass A\n{};\n\nclass B\n{\n  public:\n  template&lt; typename... T &gt;\n  void operator()( A&lt;T&gt;... a )\n  {\n  std::cout &lt;&lt; \"A&lt;T&gt;\\n\";\n  }\n\n  template&lt; typename T &gt;\n  void operator()( A&lt;T&gt; a )\n  {\n  std::cout &lt;&lt; \"A&lt;T&gt;\\n\";\n  }\n\n  template&lt; typename callable &gt;\n  void operator()( callable f )\n  {\n  std::cout &lt;&lt; \"callable\\n\";\n  }\n};\n\n\nint main()\n  {\n    B      b;\n    A&lt;int&gt; a;\n\n    b( a );\n    b( );\n}\n</code></pre>\n<p>This allows calling <code>operator()</code> also without parameters.</p>\n", "OwnerUserId": "7006673", "PostTypeId": "2", "Id": "41903760", "Score": "3", "CreationDate": "2017-01-27T22:03:50.677", "LastActivityDate": "2017-01-27T22:03:50.677"}, "bq_ids": {"n4140": {"so_41902914_41903588_0": {"section_id": 327, "quality": 0.9836065573770492, "length": 60}, "so_41902914_41903588_1": {"section_id": 327, "quality": 0.7619047619047619, "length": 48}}, "n3337": {"so_41902914_41903588_0": {"section_id": 317, "quality": 0.9836065573770492, "length": 60}, "so_41902914_41903588_1": {"section_id": 317, "quality": 0.7619047619047619, "length": 48}}, "n4659": {"so_41902914_41903588_0": {"section_id": 335, "quality": 0.7868852459016393, "length": 48}, "so_41902914_41903588_1": {"section_id": 335, "quality": 0.9841269841269841, "length": 62}}}});