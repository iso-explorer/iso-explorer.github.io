post_cb({"31993022": {"ViewCount": "661", "Body": "<p>I am facing a concurrency problem here. I have a <code>std::map</code>, there is one \noccasional writer and multiple frequent readers from different threads, this writer will occasionally add keys (key is a <code>std::string</code>)to the map, and I can not guarantee when exactly the readers perform reading and stop reading. I don't want to put locks for the readers, since reading is very frequent and checking locks frequently will hurt performance. </p>\n<p>If the readers will always access the map by keys (not <code>map</code> iterators), will it be always thread-safe? If not, any idea how to design the code so that the readers will always access valid keys (or <code>map</code> iterators )? </p>\n<p>Other approaches using different containers solving this problem are also welcome.</p>\n", "AcceptedAnswerId": "31993987", "Title": "One occasional writer, multiple frequent readers for std::map", "CreationDate": "2015-08-13T15:52:26.337", "Id": "31993022", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-08-13T15:58:24.307", "LastEditorUserId": "4342498", "LastActivityDate": "2015-08-13T23:10:11.383", "Score": "5", "OwnerUserId": "2345484", "Tags": "<c++><multithreading><c++11><stdmap>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_31993022_31993987_1": {"length": 25, "quality": 0.9259259259259259, "section_id": 717}, "so_31993022_31993987_2": {"length": 14, "quality": 0.7368421052631579, "section_id": 718}}, "n3337": {"so_31993022_31993987_1": {"length": 25, "quality": 0.9259259259259259, "section_id": 706}, "so_31993022_31993987_2": {"length": 15, "quality": 0.7894736842105263, "section_id": 707}}, "n4659": {"so_31993022_31993987_1": {"length": 25, "quality": 0.9259259259259259, "section_id": 748}, "so_31993022_31993987_2": {"length": 14, "quality": 0.7368421052631579, "section_id": 749}}}, "31996207": {"Id": "31996207", "PostTypeId": "2", "Body": "<p>I have to disagree with the previous answer.  When they talk about \"concurrently accessing existing elements\" (when talking about <code>insert()</code>), that presumes that you already have a pointer/reference/iterator to the existing element.  This is basically acknowledging that the map isn't going to move the elements around in memory after the insertion.  It also acknowledges that iterating the map is not safe during an insert.</p>\n<p>Thus, as soon as you have an insert, attempting to do an <code>at()</code> on the same container (at the same time) is a data race.   During the insert the map must change some sort of internal state (pointers to tree nodes, perhaps).  If the <code>at()</code> catches the container during that manipulation, the pointers may not be in a consistent state.</p>\n<p>You need some sort of external synchronization (such as a reader-writer lock) as soon as you have the possibility of both an <code>insert()</code> and <code>at()</code> (or <code>operator[]</code>) occurring at the same time.</p>\n", "LastActivityDate": "2015-08-13T18:50:31.457", "CommentCount": "8", "CreationDate": "2015-08-13T18:50:31.457", "ParentId": "31993022", "Score": "5", "OwnerUserId": "1987633"}, "31993987": {"Id": "31993987", "PostTypeId": "2", "Body": "<p><strong><em>Attention: fundamentally edited answer</em></strong></p>\n<p>As a reflex I would put a lock.  </p>\n<p>At first sight, it seems not required to put a lock in your case:     </p>\n<ul>\n<li>For <a href=\"http://www.cplusplus.com/reference/map/map/insert/\" rel=\"nofollow noreferrer\"><code>insert()</code></a>, it's said that <em>\"Concurrently accessing existing elements is safe, although iterating ranges in the container is not.\"</em> </li>\n<li>For <a href=\"http://www.cplusplus.com/reference/map/map/at/\" rel=\"nofollow noreferrer\"><code>at()</code></a> , it's said that:  <em>\"Concurrently accessing or modifying other elements is safe.\"</em></li>\n</ul>\n<p>The standard library addresses thread-safe aspects:</p>\n<blockquote>\n<p id=\"so_31993022_31993987_0\"><strong>23.2.2.</strong> Container data races</p>\n<p id=\"so_31993022_31993987_1\">1)  For purposes of avoiding data races (17.6.5.9), implementations\n  shall consider the following functions to be const: begin, end,\n  rbegin, rend, front, back, data, find, lower_bound, upper_bound,\n  equal_range, at and, except in associative or unordered associative\n  containers, operator[].  </p>\n<p id=\"so_31993022_31993987_2\">2) Notwithstanding (17.6.5.9),\n  implementations are required to <strong>avoid data races when the contents of\n  the contained object in di\ufb00erent elements in the same sequence</strong>,\n  excepting vector,are modi\ufb01ed concurrently.</p>\n</blockquote>\n<p>There are several other SO answers which interpret this as thread-safe guarantee, as I originally did. </p>\n<p>Nevertheless, we know that iterating ranges in the container is not safe when an insert is done. And access to an element requires before somehow iterating to find the element. So, while the standard clarifies safety for concurent access to different elements when you already have their address,  <strong>the wording leaves potential container concurrency issues open.</strong> </p>\n<p>I have tried a simulation scenario with multiple read and single write on MSVC, and it never failed.  But this is not engough to make the point : implementations are allowed to avoid more data races than what is foressen in the standard (see 17.5.6.9) (or maybe I was simply many times lucky).  </p>\n<p>Finally, I have found two serious (post C++11) references stating unambiguously that a user lock is required to be safe :  </p>\n<ul>\n<li><p><a href=\"https://gcc.gnu.org/onlinedocs/libstdc++/manual/using_concurrency.html\" rel=\"nofollow noreferrer\">GNU document on concurrency in the standard library</a>:  \"<em>The standard places requirements on the library to ensure that no data races are caused by the library itself (...) <strong>The user code must guard against concurrent function calls which access any particular library object's state when one or more of those accesses modifies the state.</strong></em></p></li></ul>\" \n<li><p><a href=\"http://herbsutter.com/2014/01/13/gotw-95-solution-thread-safety-and-synchronization/\" rel=\"nofollow noreferrer\">GotW #95 Solution: Thread Safety and Synchronization, by Herb Sutter</a> :  \"<em>Is the code correctly synchronized (...) ? No. The code has one thread reading (via const operations) from some_obj, and a second thread writing to the same variable. If those threads can execute at the same time, that\u2019s a race and a direct non-stop ticket to undefined behavior land.</em>\" </p></li>\n<p>Based on these two almost authoritative interpretations, I revise my first answer and come back to my initial reflex : you'll have to lock your concurrent accesses.  </p>\n<p>Alternatively you could use non standard-libraries with concurrent implementation of maps such as for example <a href=\"https://msdn.microsoft.com/en-us/library/hh750089.aspx\" rel=\"nofollow noreferrer\">Microsoft's concurrent_unordered_map</a> from the <em>Parallel Pattern Library</em> or <a href=\"https://www.threadingbuildingblocks.org/docs/help/reference/containers_overview/concurrent_unordered_map_cls.htm\" rel=\"nofollow noreferrer\">Intel's concurrent_unordered_map</a> from the <em>Threading Building Blocks (TBB)</em>  or lock-free library as described in this <a href=\"https://stackoverflow.com/questions/14338732/is-it-possbile-to-implement-lock-free-map-in-c\">SO answer</a> </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-08-13T23:10:11.383", "Score": "2", "CreationDate": "2015-08-13T16:43:31.863", "ParentId": "31993022", "CommentCount": "4", "OwnerUserId": "3723423", "LastEditDate": "2017-05-23T11:54:02.647"}});