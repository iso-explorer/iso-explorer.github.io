post_cb({"882055": {"ParentId": "881966", "CommentCount": "0", "Body": "<p>What you see, is a result of allowed by standard optimization, when compiler avoids creation of temporary. Compiler is allowed to replace construction and assignment with simple construction even in presence of side effects (like IO in your example).</p>\n<p>But fact if program is ill-formed or not should not depend on situation, when compiler makes this optimization or not. That's why</p>\n<pre><code>Foo f = Foo(3);\n</code></pre>\n<p>requires copy constructor. And</p>\n<pre><code>Foo f(3);\n</code></pre>\n<p>does not. Though it will probably lead to same binary code.</p>\n<p>Quote from 12.8.15</p>\n<blockquote>\n<p id=\"so_881966_882055_0\">When certain criteria are met, an\n  implementation is allowed to omit the\n  copy construction of a class object,\n  even if the copy constructor and/or\n  destructor for the object have side\n  effects. In such cases, the\n  implementation treats the source and\n  target of the omitted copy operation\n  as simply two different ways of\n  referring to the same object, and the\n  destruction of that object occurs at\n  the later of the times when the two\n  objects would have been destroyed\n  without the optimization.111) This\n  elision of copy operations is\n  permitted in the following\n  circumstances (which may be combined\n  to eliminate multiple copies):</p>\n<p id=\"so_881966_882055_1\">\u2014 in a\n  return statement in a function with a\n  class return type, when the expression\n  is the name of a non-volatile\n  automatic object with the same\n  cv-unqualified type as the function\n  return type, the copy operation can be\n  omitted by constructing the automatic\n  object directly into the function\u2019s\n  return value</p>\n<p id=\"so_881966_882055_2\">\u2014 when a temporary class\n  object that has not been bound to a\n  reference (12.2) would be copied to a\n  class object with the same\n  cv-unqualified type, the copy\n  operation can be omitted by\n  constructing the temporary object\n  directly into the target of the\n  omitted copy</p>\n</blockquote>\n<p>See also \"Return value optimization\".</p>\n", "OwnerUserId": "102243", "PostTypeId": "2", "Id": "882055", "Score": "2", "CreationDate": "2009-05-19T10:50:42.073", "LastActivityDate": "2009-05-19T10:50:42.073"}, "881966": {"CommentCount": "0", "ViewCount": "227", "CreationDate": "2009-05-19T10:28:09.747", "LastActivityDate": "2009-05-19T10:57:50.123", "Title": "Constructor access rules", "AcceptedAnswerId": "881971", "PostTypeId": "1", "Id": "881966", "Score": "3", "Body": "<p>if I compile (under G++) and run the following code it prints \"Foo::Foo(int)\". However after making copy constructor and assignment operators private, it fails to compile with the following error: \"error: \u2018Foo::Foo(const Foo&amp;)\u2019 is private\". How comes it needs a copy constructor if it only calls standard constructor at runtime?</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct Foo {\n    Foo(int x) {\n        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;\n    }\n\n\n    Foo(const Foo&amp; f) {\n        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;\n    }\n\n    Foo&amp; operator=(const Foo&amp; f) {\n        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;\n        return *this;\n    }\n};\n\nint main() {\n    Foo f = Foo(3);\n}\n</code></pre>\n", "Tags": "<c++><constructor>", "OwnerUserId": "70514", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_881966_882055_1": {"section_id": 480, "quality": 0.9666666666666667, "length": 29}, "so_881966_882055_0": {"section_id": 480, "quality": 0.9016393442622951, "length": 55}, "so_881966_882055_2": {"section_id": 480, "quality": 0.8888888888888888, "length": 24}}, "n3337": {"so_881966_882055_1": {"section_id": 471, "quality": 0.9666666666666667, "length": 29}, "so_881966_882055_0": {"section_id": 471, "quality": 0.9016393442622951, "length": 55}, "so_881966_882055_2": {"section_id": 471, "quality": 0.8888888888888888, "length": 24}}, "n4659": {"so_881966_882055_1": {"section_id": 502, "quality": 0.8666666666666667, "length": 26}, "so_881966_882055_0": {"section_id": 502, "quality": 0.9016393442622951, "length": 55}, "so_881966_882055_2": {"section_id": 502, "quality": 0.6296296296296297, "length": 17}}}, "881971": {"ParentId": "881966", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The copy constructor is used here:</p>\n<pre><code>Foo f = Foo(3);\n</code></pre>\n<p>This is equivalent to:</p>\n<pre><code>Foo f( Foo(3) );\n</code></pre>\n<p>where the first set of parens a re a call to the copy constructor. You can avoid this by saying:</p>\n<pre><code>Foo f(3);\n</code></pre>\n<p>Note that the compiler may choose to optimise away the copy constructor call, but the copy constructor must still be available (i.e not private). The C++ Standard specifically allows this optimisation (see section 12.8/15), no matter what an implementation of the copy constructor actually does.</p>\n", "Id": "881971", "LastEditDate": "2009-05-19T10:57:50.123", "OwnerDisplayName": "anon", "Score": "15", "CreationDate": "2009-05-19T10:29:36.203", "LastActivityDate": "2009-05-19T10:57:50.123", "LastEditorDisplayName": "anon"}});