post_cb({"13521163": {"CommentCount": "4", "AcceptedAnswerId": "13738472", "PostTypeId": "1", "LastEditorUserId": "46642", "CreationDate": "2012-11-22T23:10:55.780", "LastActivityDate": "2012-12-06T06:57:37.680", "LastEditDate": "2012-11-23T11:25:04.300", "ViewCount": "815", "FavoriteCount": "2", "Title": "Variadic template as template parameter: deduction works with GCC but not with Clang", "Id": "13521163", "Score": "21", "Body": "<p>While compiling some C++11 code with both GCC 4.7.2 and Clang 3.1, I ran into a problem with Clang not managing to deduce a template argument where GCC succeeds.\nIn a more abstract form, the code looks like this:</p>\n<p>src/test.cc:</p>\n<pre><code>struct Element {\n};\n\ntemplate &lt;typename T&gt;\nstruct FirstContainer {\n};\n\ntemplate &lt;typename T, typename U = Element&gt;\nstruct SecondContainer {\n};\n\ntemplate &lt;template &lt;typename&gt; class Container&gt;\nvoid processOrdinary(Container&lt;Element&gt; /*elements*/) {\n}\n\ntemplate &lt;template &lt;typename, typename&gt; class Container&gt;\nvoid processOrdinary(Container&lt;Element, Element&gt; /*elements*/) {\n}\n\ntemplate &lt;template &lt;typename, typename...&gt; class Container&gt;\nvoid processVariadic(Container&lt;Element&gt; /*elements*/) {\n}\n\nint main() {\n  // This function instantiation works in both GCC and Clang.\n  processOrdinary(FirstContainer&lt;Element&gt;{});\n  // This function instantiation works in both GCC and Clang.\n  processOrdinary(SecondContainer&lt;Element&gt;{});\n  // This function instantiation works in both GCC and Clang.\n  processVariadic(FirstContainer&lt;Element&gt;{});\n  // This function instantiation works in both GCC and Clang.\n  processVariadic&lt;SecondContainer&gt;(SecondContainer&lt;Element&gt;{});\n  // This function instantiation works in GCC but not in Clang.\n  processVariadic(SecondContainer&lt;Element&gt;{});\n  return 0;\n}\n</code></pre>\n<p>From reading the examples in \u00a714.3.3 and the specifications in \u00a714.8.2 of the standard I think the deduction should work, but I can not say for sure. This is the output I get from building:</p>\n<pre><code>mkdir -p build-gcc/\ng++ -std=c++0x -W -Wall -Wextra -Weffc++ -pedantic -c -o build-gcc/test.o src/test.cc\ng++  -o build-gcc/test build-gcc/test.o\nmkdir -p build-clang/\nclang++ -std=c++11 -Weverything -Wno-c++98-compat -c -o build-clang/test.o src/test.cc\nsrc/test.cc:34:3: error: no matching function for call to 'processVariadic'\n  processVariadic(SecondContainer&lt;Element&gt;{});\n  ^~~~~~~~~~~~~~~\nsrc/test.cc:21:6: note: candidate template ignored: failed template argument deduction\nvoid processVariadic(Container&lt;Element&gt; /*elements*/) {\n     ^\n1 error generated.\nmake: *** [build-clang/test.o] Fel 1\n</code></pre>\n<p>Why do the results differ? Is GCC sloppy, Clang dumb, does my code contain unspecified behavior or all of them?</p>\n", "Tags": "<c++><gcc><c++11><clang><variadic-templates>", "OwnerUserId": "1846177", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_13521163_13738472_0": {"section_id": 339, "quality": 0.9534883720930233, "length": 41}, "so_13521163_13738472_1": {"section_id": 340, "quality": 1.0, "length": 16}}, "n3337": {"so_13521163_13738472_0": {"section_id": 329, "quality": 0.9534883720930233, "length": 41}, "so_13521163_13738472_1": {"section_id": 330, "quality": 1.0, "length": 16}}, "n4659": {"so_13521163_13738472_0": {"section_id": 348, "quality": 0.9534883720930233, "length": 41}, "so_13521163_13738472_1": {"section_id": 349, "quality": 1.0, "length": 16}}}, "13738472": {"ParentId": "13521163", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-12-06T06:57:37.680", "OwnerUserId": "1041090", "CommunityOwnedDate": "2012-12-06T06:57:37.680", "Id": "13738472", "Score": "7", "Body": "<p>Clang is trying to deduce the arguments for this call:</p>\n<pre><code>processVariadic(SecondContainer&lt;Element&gt;{});\n</code></pre>\n<p>Since <code>SecondContainer</code> has a default template argument, this is equivalent to:</p>\n<pre><code>processVariadic(SecondContainer&lt;Element, Element&gt;{});\n</code></pre>\n<p>Thus, it performs template argument deduction with <code>P</code> = <code>Container&lt;Element&gt;</code> and <code>A</code> = <code>SecondContainer&lt;Element, Element&gt;</code>. It can immediately deduce that the <code>Container</code> template parameter is <code>SecondContainer</code>.</p>\n<p>Next, it considers the template arguments. Since the argument type is fully resolved, Clang believes that the parameter must have as many types, or deduction cannot possibly succeed (it doesn't take default arguments into account). So it flags a deduction failure.</p>\n<hr>\n<p>So, what's supposed to happen? In the words of <code>[temp.deduct.type]p8</code>,</p>\n<blockquote>\n<p id=\"so_13521163_13738472_0\">A template type argument <code>T</code>, a template template argument <code>TT</code> or a template non-type argument i can be deduced if <code>P</code> and <code>A</code> have one of the following forms:<br>\n<code>[...]</code><br>\n<code>TT&lt;T&gt;</code><br>\n<code>TT&lt;i&gt;</code><br>\n<code>TT&lt;&gt;</code><br>\n  where [...] <code>&lt;T&gt;</code> represents template argument lists where at least one argument contains a <code>T</code>, <code>&lt;i&gt;</code> represents template argument lists where at least one argument contains an <code>i</code> and <code>&lt;&gt;</code> represents template argument lists where no argument contains a <code>T</code> or an <code>i</code>.</br></br></br></br></br></p>\n</blockquote>\n<p>In order to match the template arguments, we turn to <code>[temp.deduct.type]p9</code>:</p>\n<blockquote>\n<p id=\"so_13521163_13738472_1\">If <code>P</code> has a form that contains <code>&lt;T&gt;</code> or <code>&lt;i&gt;</code>, then each argument <code>Pi</code> of the respective template argument list <code>P</code> is compared with the corresponding argument <code>Ai</code> of the corresponding template argument list of <code>A</code>.</p>\n</blockquote>\n<p>There are two things to observe here. One is that this rule does not say what happens if the list <code>Pi</code> and <code>Ai</code> are different lengths (as they are in this case), and the common interpretation seems to be that the mismatched items are not examined. The other is that this rule should not be followed anyway, since the form of <code>P</code> does not contain <code>&lt;T&gt;</code> or <code>&lt;i&gt;</code> (it just contains <code>&lt;&gt;</code>, because there are no template parameters in it).</p>\n<hr>\n<p>So, Clang was wrong to reject this code. I've fixed it in <a href=\"http://lists.cs.uiuc.edu/pipermail/cfe-commits/Week-of-Mon-20121203/069267.html\" rel=\"noreferrer\">r169475</a>.</p>\n</hr></hr>", "LastActivityDate": "2012-12-06T06:57:37.680"}});