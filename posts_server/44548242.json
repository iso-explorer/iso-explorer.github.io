post_cb({"bq_ids": {"n4140": {"so_44548242_44549084_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 85}, "so_44548242_44549084_2": {"length": 60, "quality": 0.9523809523809523, "section_id": 5846}, "so_44548242_44549084_1": {"length": 27, "quality": 0.8709677419354839, "section_id": 7203}, "so_44548242_44549084_3": {"length": 15, "quality": 1.0, "section_id": 7009}}, "n3337": {"so_44548242_44549084_2": {"length": 60, "quality": 0.9523809523809523, "section_id": 5616}, "so_44548242_44549084_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 80}, "so_44548242_44549084_1": {"length": 23, "quality": 0.7419354838709677, "section_id": 6947}, "so_44548242_44549084_3": {"length": 12, "quality": 0.8, "section_id": 6755}}, "n4659": {"so_44548242_44549084_2": {"length": 60, "quality": 0.9523809523809523, "section_id": 7325}, "so_44548242_44549084_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 88}, "so_44548242_44549084_1": {"length": 25, "quality": 0.8064516129032258, "section_id": 8712}, "so_44548242_44549084_3": {"length": 15, "quality": 1.0, "section_id": 8506}}}, "44549084": {"Id": "44549084", "PostTypeId": "2", "Body": "<p>Here's the thing. While to us it may appear that the compiler knows everything it needs to know about the types in question, the standard says otherwise.</p>\n<p><a href=\"http://eel.is/c++draft/temp#arg.type-2\" rel=\"noreferrer\">[temp.arg.type/2]</a></p>\n<blockquote>\n<p id=\"so_44548242_44549084_0\">... [\u2009Note: <strong>A template type argument may be an incomplete type</strong>. \u2014\u2009end note\u2009]</p>\n</blockquote>\n<p><a href=\"http://eel.is/c++draft/basic.types#5\" rel=\"noreferrer\">[basic.types/5]</a></p>\n<blockquote>\n<p id=\"so_44548242_44549084_1\"><strong>A class that has been declared but not defined</strong>, an enumeration type in\n  certain contexts ([dcl.enum]), or an array of unknown bound or of\n  incomplete element type, <strong>is an incompletely-defined object type</strong>.46\n  <strong>Incompletely-defined object types and cv void are incomplete types</strong>\n  ([basic.fundamental]). Objects shall not be defined to have an\n  incomplete type.</p>\n</blockquote>\n<p><a href=\"http://eel.is/c++draft/class#2\" rel=\"noreferrer\">[class/2]</a></p>\n<blockquote>\n<p id=\"so_44548242_44549084_2\">A class-name is inserted into the scope in which it is declared\n  immediately after the class-name is seen. The class-name is also\n  inserted into the scope of the class itself; this is known as the\n  injected-class-name. For purposes of access checking, the\n  injected-class-name is treated as if it were a public member name. A\n  class-specifier is commonly referred to as a class definition. <strong>A class\n  is considered defined after the closing brace of its class-specifier\n  has been seen</strong> even though its member functions are in general not yet\n  defined. The optional attribute-specifier-seq appertains to the class;\n  the attributes in the attribute-specifier-seq are thereafter\n  considered attributes of the class whenever it is named.</p>\n</blockquote>\n<p>The text in bold paints the simple picture that the compilers in question treat the type parameter T as an incomplete object type. It's as though you only forward declared it, like so:</p>\n<pre><code>class derived;\n</code></pre>\n<p>They cannot deduce that this forward declaration is a class derived from <code>base</code>. So they cannot accept it as a co-variant return type in the context of <code>foo_default_impl</code>. Like was pointed out by <strong>@marcinj</strong> <a href=\"https://stackoverflow.com/questions/44548242/covariant-return-type-is-not-recognized#comment76088448_44548242\">in the comments</a>:</p>\n<p><a href=\"http://eel.is/c++draft/class.derived#class.virtual-8\" rel=\"noreferrer\">[class.virtual/8]</a></p>\n<blockquote>\n<p id=\"so_44548242_44549084_3\">If the class type in the covariant return type of D\u200b::\u200bf differs from\n  that of B\u200b::\u200bf, the class type in the return type of D\u200b::\u200bf shall be\n  complete at the point of declaration of D\u200b::\u200bf or shall be the class\n  type D.</p>\n</blockquote>\n<p>Since <code>T</code> is neither complete, nor is it <code>foo_default_impl&lt;T&gt;</code> itself, it cannot be a co-variant return type.</p>\n", "LastEditorUserId": "817643", "LastActivityDate": "2017-06-14T15:40:52.840", "Score": "19", "CreationDate": "2017-06-14T15:35:36.217", "ParentId": "44548242", "CommentCount": "3", "LastEditDate": "2017-06-14T15:40:52.840", "OwnerUserId": "817643"}, "44548242": {"ViewCount": "477", "Body": "<p>For some reason, up-to-date versions of both GCC and clang do not recognize return type covariance in this particular scenario. The error message is misleading: </p>\n<pre><code>error: return type of virtual function 'foo' is not covariant with the return\n     type of the function it overrides ('derived *' is not derived from 'base *')\n</code></pre>\n<p>Here is the code:</p>\n<pre><code>class base\n{\nprivate:\n  virtual base * foo() = 0;\n};\n\ntemplate&lt; class T &gt;\nclass foo_default_impl : public virtual base\n{\nprivate:\n  T * foo() override { return nullptr; }\n};\n\nclass derived : public virtual base, private foo_default_impl&lt; derived &gt;\n{\n};\n\nint main() {\n  derived d{}; // error: return type of virtual function 'foo' is not covariant with the return type of the function it overrides ('derived *' is not derived from 'base *')\n  return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "44549084", "Title": "Covariant return type is not recognized", "CreationDate": "2017-06-14T14:56:10.340", "Id": "44548242", "CommentCount": "12", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-06-14T15:01:02.920", "LastEditorUserId": "717822", "LastActivityDate": "2017-06-14T15:40:52.840", "Score": "22", "OwnerUserId": "8161208", "Tags": "<c++>", "AnswerCount": "1"}});