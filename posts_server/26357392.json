post_cb({"bq_ids": {"n4140": {"so_26357392_26358037_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 382}, "so_26357392_26358037_0": {"length": 36, "quality": 0.972972972972973, "section_id": 381}, "so_26357392_26357392_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 6030}}, "n3337": {"so_26357392_26358037_1": {"length": 19, "quality": 0.9047619047619048, "section_id": 373}, "so_26357392_26358037_0": {"length": 36, "quality": 0.972972972972973, "section_id": 372}, "so_26357392_26357392_0": {"length": 30, "quality": 0.967741935483871, "section_id": 5798}}, "n4659": {"so_26357392_26358037_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 397}, "so_26357392_26358037_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 396}}}, "26357392": {"ViewCount": "59", "Body": "<p>When compiling some weird code for better C++ standard understanding, I met an example, where I'm not actually sure what is happening. Consider a simple class, which make debug output, when it constructed or destructed:</p>\n<pre><code>struct C {\n    C() { cout &lt;&lt; \"Constructed\\t\" &lt;&lt; this &lt;&lt; \"\\n\"; }\n    C(const C&amp; source) = delete;\n    C(C&amp;&amp;) = delete;\n    ~C() { cout &lt;&lt; \"Destructed\\t\" &lt;&lt; this &lt;&lt; \"\\n\"; }\n};\n</code></pre>\n<p>Now the code, which behaviour I don't understand:</p>\n<pre><code>int main()\n{\n    const C&amp; r = static_cast&lt;const C&amp;&gt;(C());\n    cout &lt;&lt; \"Next line\" &lt;&lt; endl;\n}\n</code></pre>\n<p>The output is (tried it with gcc and clang):</p>\n<pre class=\"lang-none prettyprint-override\"><code>Constructed 0x7fff6d6ebe60  \nNext line  \nDestructed  0x7fff6d6ebe60\n</code></pre>\n<p>So, as u can see here, temporary object is binded to reference even when it casted to reference type first. I'm not sure why this is happening. I've tried to answer it myself and this is my thoughts:</p>\n<ol>\n<li><code>C()</code> creates a temporary prvalue</li>\n<li><p>For <code>static_cast</code> 5.2.9p4 is applicated:</p>\n<blockquote>\n<p id=\"so_26357392_26357392_0\">Otherwise, an expression <code>e</code> can be explicitly converted to a type <code>T</code> using a <code>static_cast</code> of the form <code>static_cast&lt;T&gt;(e)</code> if the declaration <code>T t(e);</code> is well-formed, for some invented temporary variable <code>t</code> (8.5). The effect of such an explicit conversion is the same as performing the declaration and initialization and then using the temporary variable as the result of the conversion.</p>\n</blockquote>\n<p>So a temporary reference is created and the result of <code>static_cast</code> expression is lvalue  </p></li>\n<li>What happens next and why lifetime of temporary is extended? Is it something like a temporary binded to temporary reference, which itself binded to other reference?</li>\n</ol>\n<p>P.S. Also tried this (add an address-taking and derefernce operators):</p>\n<pre><code>int main()\n{\n    const C&amp; r = *&amp;static_cast&lt;const C&amp;&gt;(C());\n    cout &lt;&lt; \"Next line\" &lt;&lt; endl;\n}\n</code></pre>\n<p>And gcc output is still:</p>\n<pre class=\"lang-none prettyprint-override\"><code>Constructed 0x7fffa1c50157\nNext line\nDestructed  0x7fffa1c50157\n</code></pre>\n<p>while clang destroy temporary before \"Next line\" in this case:</p>\n<pre class=\"lang-none prettyprint-override\"><code>Constructed 0x7fff3374ab60\nDestructed  0x7fff3374ab60\nNext line\n</code></pre>\n", "Title": "Temporary is still binded to reference, when casted to reference type first", "CreationDate": "2014-10-14T09:36:37.200", "LastActivityDate": "2014-10-14T10:04:45.730", "CommentCount": "1", "LastEditDate": "2014-10-14T09:51:20.940", "PostTypeId": "1", "LastEditorUserId": "4140624", "Id": "26357392", "Score": "2", "OwnerUserId": "4140624", "Tags": "<c++>", "AnswerCount": "1"}, "26358037": {"Id": "26358037", "PostTypeId": "2", "Body": "<p>Try to look at clauses 12.2/4 and 12.2/5 of Standard:</p>\n<blockquote>\n<ol start=\"4\">\n<li><p id=\"so_26357392_26358037_0\">There are two contexts in which temporaries are destroyed at a different point than the end of the fullexpression. The first context is when a default constructor is called to initialize an element of an array. If\n  the constructor has one or more default arguments, the destruction of every temporary created in a default\n  argument is sequenced before the construction of the next array element, if any.</p></li>\n<li><p id=\"so_26357392_26358037_1\">The second context is when a reference is bound to a temporary. The temporary to which the reference is\n  bound or the temporary that is the complete object of a subobject to which the reference is bound persists\n  for the lifetime of the reference except: ...</p></li>\n</ol>\n</blockquote>\n<p>this should answer your question - why the lifetime is extended.</p>\n", "LastActivityDate": "2014-10-14T10:04:45.730", "CommentCount": "4", "CreationDate": "2014-10-14T10:04:45.730", "ParentId": "26357392", "Score": "-1", "OwnerUserId": "3240681"}});