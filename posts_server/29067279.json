post_cb({"29067638": {"ParentId": "29067279", "CommentCount": "1", "CreationDate": "2015-03-15T23:48:49.627", "OwnerUserId": "962089", "PostTypeId": "2", "Id": "29067638", "Score": "3", "Body": "<p>N3485, \u00a73.2 [basic.def.odr]/3 says:</p>\n<blockquote>\n<p id=\"so_29067279_29067638_0\">A variable x whose name appears as a potentially-evaluated expression\n  ex is odr-used unless x is an object that satisfies the requirements\n  for appearing in a constant expression (5.19) and ex is an element of\n  the set of potential results of an expression e, where either the\n  lvalue-to-rvalue conversion (4.1) is applied to e, or e is a\n  discarded-value expression (Clause 5).</p>\n</blockquote>\n<p>In the case of the array, it must undergo an array-to-pointer conversion in order to fit the overload set of <code>operator&lt;&lt;</code>. This is not listed in the above text, and so the array <code>str</code> is odr-used.</p>\n<p>\u00a79.4.2 [class.static.data]/3 says (emphasis mine):</p>\n<blockquote>\n<p id=\"so_29067279_29067638_1\">A static data member of literal type can be declared in the class\n  definition with the constexpr specifier; if so, its declaration shall\n  specify a brace-or-equal-initializer in which every initializer-clause\n  that is an assignment-expression is a constant expression. [ Note: In\n  both these cases, the member may appear in constant expressions. \u2014 end\n  note ] <strong>The member shall still be defined in a namespace scope if it is\n  odr-used (3.2) in the program</strong> and the namespace scope definition shall\n  not contain an initializer.</p>\n</blockquote>\n<p>Since the array <code>str</code> is odr-used, it must be defined outside of the class. The pointer <code>str</code> is not odr-used, and thus does not have to be.</p>\n", "LastActivityDate": "2015-03-15T23:48:49.627"}, "29067683": {"ParentId": "29067279", "CommentCount": "1", "CreationDate": "2015-03-15T23:53:38.827", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "29067683", "Score": "10", "Body": "<p>An object or function must be defined if it is odr-used. In some cases objects and functions are not odr-used and in those cases you don't have to define them. Whether or not the declaration of a static class member has an initializer, it is still not a definition. In all cases the rule is that an out-of-class definition at an enclosing namespace scope is required if the static member is odr-used.</p>\n<p>The intuition is that \"odr-used\" means \"the linker needs its address\". If a <code>constexpr</code> variable is only used in ways that require its value---and never its address---then it may avoid being odr-used. In such cases the compiler simply inlines its value, and it does not need to be defined, because the linker doesn't need its address. That's the case with <code>const char* Something&lt;int&gt;::str</code>, but not <code>const char Something&lt;int&gt;::str[]</code>.</p>\n<p>\"But they're the same!\", you shout. Not so. For when <code>str</code> is a <code>const char*</code>, its <strong>value</strong> is the <strong>address</strong> of the string literal <code>\"int\"</code>. The address of the string literal is needed, but not the address of <code>str</code> itself. The former is the value of <code>str</code> and it satisfies the requirements for <em>not</em> being odr-used; the compiler can just inline it. But when <code>str</code> is a <code>const char[]</code>, its <strong>value</strong> is the string literal <code>\"int\"</code> itself. When you try to output it using <code>istream::operator&lt;&lt;</code>, it is implicitly converted into a <code>const char*</code>. But the <code>const char*</code>'s <strong>value</strong> is the <strong>address</strong> of the string literal, that is, the address of <code>Something&lt;int&gt;::str</code>. Therefore in this case <code>Something&lt;int&gt;::str</code> is odr-used; its address is needed.</p>\n<p>There is logic in the standard that can be used to determine precisely when a variable is odr-used ([basic.def.odr]). But I'm not going to quote it because it's the most confusing section of the entire standard. I will say that in the case where you have <code>const char* Something&lt;int&gt;::str</code>, the lvalue-to-rvalue conversion is immediately applied, which is one of the conditions for it to not be odr-used; and in the case where you have <code>const char Something&lt;int&gt;::str[]</code>, the array-to-pointer conversion is immediately applied, and that doesn't satisfy the condition.</p>\n", "LastActivityDate": "2015-03-15T23:53:38.827"}, "bq_ids": {"n4140": {"so_29067279_29067638_1": {"section_id": 5908, "quality": 0.9047619047619048, "length": 38}, "so_29067279_29067638_0": {"section_id": 7040, "quality": 0.7777777777777778, "length": 21}}, "n3337": {"so_29067279_29067638_1": {"section_id": 5680, "quality": 0.9047619047619048, "length": 38}, "so_29067279_29067638_0": {"section_id": 6785, "quality": 0.5185185185185185, "length": 14}}, "n4659": {"so_29067279_29067638_1": {"section_id": 7390, "quality": 0.5714285714285714, "length": 24}, "so_29067279_29067638_0": {"section_id": 8537, "quality": 0.7777777777777778, "length": 21}}}, "29067279": {"CommentCount": "1", "AcceptedAnswerId": "29067683", "CreationDate": "2015-03-15T23:03:47.230", "LastActivityDate": "2015-03-15T23:53:38.827", "PostTypeId": "1", "ViewCount": "1164", "FavoriteCount": "1", "Title": "Undefined reference to static constexpr string (except if it's a pointer)", "Id": "29067279", "Score": "4", "Body": "<p>This work:</p>\n<pre><code>template&lt;typename T&gt; struct Something\n{ static constexpr const char* str = \"int\"; };\n\nint main()\n{ std::cout &lt;&lt; Something&lt;int&gt;::str &lt;&lt; std::endl; }\n</code></pre>\n<p>But it doesn't:</p>\n<pre><code>template&lt;typename T&gt; struct Something\n{ static constexpr const char str[] = \"int\"; };\n\nint main()\n{ std::cout &lt;&lt; Something&lt;int&gt;::str &lt;&lt; std::endl; }\n</code></pre>\n<p><code>gcc-4.8</code> says: \"undefined reference to <code>Something&lt;int&gt;::str</code>\".</p>\n<p>This error can be solved defining the static member outside of the class:</p>\n<pre><code>template&lt;typename T&gt;\nconstexpr const char Something&lt;T&gt;::name[];\n</code></pre>\n<p>Why isn't it neccesary with pointers but with arrays? Both are <code>static constexpr</code> members after all.</p>\n", "Tags": "<c++><c++11><static><constexpr>", "OwnerUserId": "1794803", "AnswerCount": "2"}});