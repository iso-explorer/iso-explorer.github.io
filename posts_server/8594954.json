post_cb({"8595137": {"Id": "8595137", "PostTypeId": "2", "Body": "<p>You can do it in C++ because of 7.1.3/3 and /4.</p>\n<p>You can't do it in C99 because it doesn't have any equivalent special case in 6.7.7, so re-declaring a typedef name follows the same rules as re-declaring any other identifier. Specifically 6.2.2/6 (typedefs have no linkage) and 6.7/3 (identifiers with no linkage can only be declared once with the same scope).</p>\n<p>Remember <code>typedef</code> is a storage-class-specifier in C99, whereas in C++ it's a decl-specifier. The different grammar leads me to suspect that the C++ authors decided to put more effort into making typedefs \"a different kind of declaration\", and so may well have been willing to spend more time and text on special rules for them. Beyond that I don't know what the C99 authors' (lack of) motivation was.</p>\n<p>[Edit: see Johannes's answer for C1x. I'm not following that at all, so I should probably stop using \"C\" to mean \"C99\" because I probably won't even notice when they ratify and publish. It's bad enough as it is: \"C\" should mean \"C99\", but in practice means \"C99 if you're lucky, but if you have to support MSVC then C89\".]</p>\n<p>[Edit again: and indeed, it has been published and is now C11. Woot.]</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2011-12-22T10:34:28.003", "Score": "8", "CreationDate": "2011-12-21T19:21:52.603", "ParentId": "8594954", "CommentCount": "2", "OwnerUserId": "13005", "LastEditDate": "2011-12-22T10:34:28.003"}, "8594954": {"ViewCount": "8249", "Body": "<p>I would like a standard reference why the following code triggers a compliance warning in C (tested with <code>gcc -pedantic</code>; \"typedef redefinition\"), but is fine in C++ (<code>g++ -pedantic</code>):</p>\n<pre><code>typedef struct Foo Foo;\ntypedef struct Foo Foo;\n\nint main() { return 0; }\n</code></pre>\n<p>Why can I not define a <code>typedef</code> repeatedly in C?</p>\n<p>(This has practical implications for the header structuring of a <a href=\"http://sc2.svn.sourceforge.net/viewvc/sc2/trunk/sc2/src/libs/resource/index.h?revision=3704&amp;view=markup\">C project</a>.)</p>\n", "AcceptedAnswerId": "8595131", "Title": "Repeated typedefs - invalid in C but valid in C++?", "CreationDate": "2011-12-21T19:03:23.517", "Id": "8594954", "CommentCount": "9", "FavoriteCount": "9", "PostTypeId": "1", "LastActivityDate": "2016-06-05T22:33:52.230", "Score": "43", "OwnerUserId": "596781", "Tags": "<c++><c><typedef><language-lawyer>", "AnswerCount": "5"}, "8595193": {"Id": "8595193", "PostTypeId": "2", "Body": "<p>There is nothing in the c spec that says <em>why</em> this is invalid. The spec is the wrong place to clarify that. FWIW it is allowed in C1x (according to an answer i received to one of my last questions).</p>\n<p>I suppose that this c1x feature supports transforming macros to typedefs (the former are allowed to be repeated if identically).</p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2011-12-21T19:30:52.713", "Score": "3", "CreationDate": "2011-12-21T19:25:52.043", "ParentId": "8594954", "CommentCount": "10", "OwnerUserId": "34509", "LastEditDate": "2011-12-21T19:30:52.713"}, "bq_ids": {"n4140": {"so_8594954_8595131_0": {"length": 15, "quality": 1.0, "section_id": 5409}}, "n3337": {"so_8594954_8595131_0": {"length": 15, "quality": 1.0, "section_id": 5204}}, "n4659": {"so_8594954_8595131_0": {"length": 15, "quality": 1.0, "section_id": 6831}}}, "8595191": {"Id": "8595191", "PostTypeId": "2", "Body": "<h2>Standard C is now ISO/IEC 9989:2011</h2>\n<p>The 2011 C standard was published on Monday 2011-12-19 by ISO (or, more precisely, the notice that it had been published was added to the committee web site on the 19th; the standard may have been published as 'long ago' as 2011-12-08).  See the announcement at the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/\" rel=\"nofollow noreferrer\">WG14</a> web site.  Sadly, the <a href=\"http://www.iso.org/iso/iso_catalogue/catalogue_tc/catalogue_detail.htm?csnumber=57853\" rel=\"nofollow noreferrer\">PDF from ISO</a> costs 338 CHF, <s>and from <a href=\"http://webstore.ansi.org/FindStandards.aspx?SearchString=9899:2011\" rel=\"nofollow noreferrer\">ANSI</a> 387 USD</s>.</p>\n<ul>\n<li>You can obtain the PDF for INCITS/ISO/IEC 9899:2012 (C2011) from <a href=\"http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS/ISO/IEC%209899-2012\" rel=\"nofollow noreferrer\">ANSI</a> for 30 USD.</li>\n<li>You can obtain the PDF for INCITS/ISO/IEC 14882:2012 (C++2011) from <a href=\"http://webstore.ansi.org/RecordDetail.aspx?sku=INCITS/ISO/IEC%2014882-2012\" rel=\"nofollow noreferrer\">ANSI</a> for 30 USD.</li>\n</ul>\n<h2>Main Answer</h2>\n<p>The question is \"Are repeated typedefs allowed in C\"?  The answer is \"No - not in the ISO/IEC 9899:1999 or 9899:1990 standards\".  The reason is probably historical; the original C compilers did not allow it, so the original standardizers (who were mandated to standardize what was already available in C compilers) standardized that behaviour.</p>\n<p>See the <a href=\"https://stackoverflow.com/questions/8594954/repeated-typedefs-invalid-in-c-but-valid-in-c/8595131#8595131\">answer</a> by <a href=\"https://stackoverflow.com/users/452307/als\">Als</a> for where the C99 standard proscribes repeated typedefs.  The C11 standard has changed the rule in \u00a76.7 \u00b63 to:</p>\n<blockquote>\n<p id=\"so_8594954_8595191_0\">3 If an identifier has no linkage, there shall be no more than one declaration of the identifier\n  (in a declarator or type specifier) with the same scope and in the same name space, except\n  that:</p>\n<ul>\n<li>a typedef name may be redefined to denote the same type as it currently does,\n  provided that type is not a variably modified type;</li>\n<li>tags may be redeclared as specified in 6.7.2.3.</li>\n</ul>\n</blockquote>\n<p>So there is now an explicit mandate a repeated typedef in C11.  Roll on the availability of C11-compliant C compilers.</p>\n<hr>\n<p>For those still using C99 or earlier, the follow-up question is then, presumably \"So how do I avoid running into problems with repeated typedefs?\"</p>\n<p>If you follow the rule that there is a single header that defines each type that is needed in more than one source file (but there can be many headers defining such types; each separate type is found in only one header, though), and if that header is used any time that type is needed, then you don't run into the conflict.</p>\n<p>You can also use incomplete structure declarations if you only need pointers to the types and don't need to allocate the actual structure or access the members of them (opaque types). Again, set rules about which header declares the incomplete type, and use that header wherever the type is needed.</p>\n<p>See also <a href=\"https://stackoverflow.com/questions/1433204/\">What are extern variables in C</a>; it talks about variables, but types can be treated somewhat similarly.</p>\n<hr>\n<h2>Question from Comments</h2>\n<blockquote>\n<p id=\"so_8594954_8595191_1\">I very much need the \"incomplete structure declarations\", on account of separate preprocessor complications that prohibit certain inclusions. So you're saying that I must not typedef those forward declarations if they're typedefed again by the full header?</p>\n</blockquote>\n<p>More or less.  I've not really had to deal with this (though there are parts of the systems at work that get very close to having to worry about it), so this is a little tentative, but I believe it should work.</p>\n<p>Generally, a header describes the external services provided by a 'library' (one or more source files) in sufficient detail for the users of the library to be able to compile with it.  Especially in the case where there are multiple source files, there may also be an internal header that defines, for example, the complete types.</p>\n<p>All headers are (a) self-contained and (b) idempotent.  That means you can (a) include the header and all the required other headers are automatically included, and (b) you can include the header multiple times without incurring the wrath of the compiler.  The latter is usually achieved with header guards, though some prefer <code>#pragma once</code> - but that is not portable.</p>\n<p>So, you can have a public header like this:</p>\n<h3>public.h</h3>\n<pre><code>#ifndef PUBLIC_H_INCLUDED\n#define PUBLIC_H_INCLUDED\n\n#include &lt;stddef.h&gt;    // size_t\n\ntypedef struct mine mine;\ntypedef struct that that;\n\nextern size_t polymath(const mine *x, const that *y, int z);\n\n#endif /* PUBLIC_H_INCLUDED */\n</code></pre>\n<p>So far, so not very controversial (though one can legitimately suspect that the interface provided by this library is very incomplete).</p>\n<h3>private.h</h3>\n<pre><code>#ifndef PRIVATE_H_INCLUDED\n#define PRIVATE_H_INCLUDED\n\n#include \"public.h\"  // Get forward definitions for mine and that types\n\nstruct mine { ... };\nstruct that { ... };\n\nextern mine *m_constructor(int i);\n...\n\n#endif /* PRIVATE_H_INCLUDED */\n</code></pre>\n<p>Again, not very controversial.  The <code>public.h</code> header must be listed first; this provides an automatic check of self-containment.</p>\n<h3>Consumer code</h3>\n<p>Any code that needs the <code>polymath()</code> services writes:</p>\n<pre><code>#include \"public.h\"\n</code></pre>\n<p>That is all the information that's needed to use the service.</p>\n<h3>Provider code</h3>\n<p>Any code in the library that defines the <code>polymath()</code> services writes:</p>\n<pre><code>#include \"private.h\"\n</code></pre>\n<p>Thereafter, everything functions as normal.</p>\n<h3>Other provider code</h3>\n<p>If there's another library (call it <code>multimath()</code>) that uses the <code>polymath()</code> services, then that code gets to include <code>public.h</code> just like any other consumer.  If the <code>polymath()</code> services are part of the external interface to <code>multimath()</code>, then the <code>multimath.h</code> public header will include <code>public.h</code> (sorry, I switched terminologies near the end, here).  If the <code>multimath()</code> services completely conceal the <code>polymath()</code> services, then the <code>multimath.h</code> header won't include <code>public.h</code>, but the <code>multimath()</code> private header might well do so, or the individual source files that need the <code>polymath()</code> services can include it when needed.</p>\n<p>As long as you religiously follow the discipline of including the correct header everywhere, then you won't run into double-definition trouble.</p>\n<p>If you subsequently find that one of your headers contains two groups of definitions, one which can be used without conflict and one which can sometimes (or always) conflict with some new header (and the services declared therein), then you need to split the original header into two sub-headers.  Each sub-header individually follows the rules elaborated here.  The original header becomes trivial - a header guard and lines to include the two individual files.  All existing working code remains untouched - though the dependencies change (extra files to depend on).  New code can now include the relevant acceptable sub-header while also using the new header that conflicts with the original header.</p>\n<p>Of course, you can have two headers that are simply irreconcilable.  For a contrived example, if there is a (badly designed) header that declares a different version of the <code>FILE</code> structure (from the version in <code>&lt;stdio.h&gt;</code>), you are hosed; code can include either the badly designed header or <code>&lt;stdio.h&gt;</code> but not both.  In this case, the badly designed header should be revised to use a new name (perhaps <code>File</code>, but perhaps something else).  You might more realistically run into this trouble if you have to merge code from two products into one after a corporate takeover, with some common data structures, such as <code>DB_Connection</code> for a database connection.  In the absence of the C++ <code>namespace</code> feature, you are stuck with a renaming exercise for one or both lots of code.</p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2016-06-05T22:33:52.230", "Score": "21", "CreationDate": "2011-12-21T19:25:44.743", "ParentId": "8594954", "CommentCount": "5", "OwnerUserId": "15168", "LastEditDate": "2017-05-23T12:01:57.267"}, "8595131": {"Id": "8595131", "PostTypeId": "2", "Body": "<h2>Why does this compile in C++?</h2>\n<p>Because the C++ Standard explicitly says so.     </p>\n<p>Reference:     </p>\n<p><strong>C++03 Standard 7.1.3 typedef specifier</strong> </p>\n<p><strong>\u00a77.1.3.2:</strong> </p>\n<blockquote>\n<p id=\"so_8594954_8595131_0\">In a given non-class scope, a typedef specifier can be used to redefine the name of any type declared in that scope to refer to the type to which it already refers.    </p>\n<p id=\"so_8594954_8595131_1\">[Example:<br>\n  typedef struct s { /* ... */ } s;<br>\n  typedef int I;<br>\n  typedef int I;<br>\n  typedef I I;<br>\n  \u2014end example]       </br></br></br></br></br></p>\n</blockquote>\n<h2>Why does this fail to compile in C?</h2>\n<p><code>typedef</code> names have no linkage and C99 standard disallows identifiers with no linkage specification to have more than one declaration with the same scope and in the same name space.   </p>\n<p>Reference:   </p>\n<p><strong>C99 Standard: \u00a76.2.2 Linkages of identi\ufb01ers</strong> </p>\n<p><strong>\u00a76.2.2/6</strong> states: </p>\n<blockquote>\n<p id=\"so_8594954_8595131_2\"><strong>The following identi\ufb01ers have no linkage: an identi\ufb01er declared to be anything other than\n  an object or a function; an identi\ufb01er declared to be a function parameter;</strong> a block scope\n  identi\ufb01er for an object declared without the storage-class speci\ufb01erextern.</p>\n</blockquote>\n<p>Further <strong>\u00a76.7/3</strong> states:</p>\n<blockquote>\n<p id=\"so_8594954_8595131_3\"><strong>If an identifier has no linkage, there shall be no more than one declaration of the identifier (in a declarator or type specifier) with the same scope and in the same name space</strong>, except for tags as specified in 6.7.2.3.  </p>\n</blockquote>\n", "LastEditorUserId": "452307", "LastActivityDate": "2011-12-22T04:36:14.613", "Score": "38", "CreationDate": "2011-12-21T19:21:34.980", "ParentId": "8594954", "CommentCount": "1", "OwnerUserId": "452307", "LastEditDate": "2011-12-22T04:36:14.613"}, "22430885": {"Id": "22430885", "PostTypeId": "2", "Body": "<p>A lot of people have answered, referring to the standards, but nobody said, WHY the standards differ for C and C++ here. Well, I believe, the reason for allowing repeated typedefs in C++ was, that C++ implicitely declares structures and classes as types. So the following is legal in C++:</p>\n<pre><code>struct foo { int a; int b; };\nfoo f;\n</code></pre>\n<p>In C, one has to write:</p>\n<pre><code>struct foo { int a; int b; };\ntypedef struct foo foo;\nfoo f;\n</code></pre>\n<p>There is a lot of C code like that, that declares structs as types. If such code is migrated to C++, the typedefs become duplicate, because the C++ language adds its own implicit typedefs. So, to avoid programmers the hassle to remove those no longer required typedefs, they allowed duplicate typedefs in C++ from the beginning.</p>\n<p>As others have said, people with time realized, that allowing repeated identical typedefs in C could also be usefull. At least, it shouldn't harm. That's why this C++ feature got sort of \"backported\" into C11.</p>\n", "LastActivityDate": "2014-03-15T23:05:52.920", "CommentCount": "0", "CreationDate": "2014-03-15T23:05:52.920", "ParentId": "8594954", "Score": "3", "OwnerUserId": "2528436"}});