post_cb({"31922063": {"CommentCount": "4", "ViewCount": "398", "PostTypeId": "1", "LastEditorUserId": "1054324", "CreationDate": "2015-08-10T14:20:39.023", "LastActivityDate": "2015-08-12T14:20:20.987", "Title": "Passing local string parameter as reference to const into a constexpr function? Why is that legal?", "LastEditDate": "2015-08-12T14:20:20.987", "Id": "31922063", "Score": "2", "Body": "<p>A <em>constexpr function</em> accepts only parameters, which are of a <em>literal type</em>. An object of the class string is not a literal type itself, but a pointer (which is a <em>scalar type</em>) or a reference is a literal type. And therefore a reference to string is a literal type.  </p>\n<p>Furthermore a <em>constexpr function</em> returns only a constant expression, if it's arguments are also <em>constant expressions</em>.  </p>\n<blockquote>\n<p id=\"so_31922063_31922063_0\">\"The scale* function will return a constant expression if its argument\n  is a constant expression but not otherwise:\"<br>\n  Source: The C++ Primer, 5th edition</br></p>\n</blockquote>\n<p><em>scale</em> is in this case <em>is_shorter()</em> </p>\n<p>Now I'm passing here two references to string to a constexpr function, which doesn't remain at a fixed address (global or static) but at a variable address (local). Therefore both arguments shouldn't be constant expressions.<br>\nThe result of the <em>constexpr function</em> is assigned to a <em>constexpr bool</em>.</br></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\nusing namespace std;\n\n/*\n * it isn't possible to define is_shorter as constexpr function\n * 1. string is not a literal type, but can be passed as pointer or reference,\n *    which are literal types.\n * 2. the member function size() is not a constexpr function\n *\n */\n\n// compare the length of two strings\nconstexpr bool is_shorter(const string&amp; s1, const string&amp; s2) {\n    // compiler message from gcc: 'error: call to non-constexpr function'\n    // return s1.size() &lt; s2.size();\n\n    // compare addresses of pointers, which is legal or illegal but useless, because\n    // both parameters are local objects and not stored at fixed addresses.\n    return &amp;s1 != &amp;s2;\n}\n\nint main() {\n    string shrt = \"short\";\n    string longer = \"longer\";\n\n    cout &lt;&lt; \"address of shrt \" &lt;&lt; &amp;shrt &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"address of longer \" &lt;&lt; &amp;longer &lt;&lt; \"\\n\";\n\n    constexpr bool state = is_shorter(shrt, longer);\n    if (state) {\n        cout &lt;&lt; \"shrt is shorter\\n\";\n    } else {\n        cout &lt;&lt; \"longer is longer\\n\";\n    }\n\n    cout &lt;&lt; \"string \" &lt;&lt; is_literal_type&lt;string&gt;::value &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"string&amp; \" &lt;&lt; is_literal_type&lt;string&amp;&gt;::value &lt;&lt; \"\\n\";\n    cout &lt;&lt; \"string* \" &lt;&lt; is_literal_type&lt;string*&gt;::value &lt;&lt; \"\\n\";\n    return 0;\n}   \n</code></pre>\n<p>Compile:  </p>\n<pre><code>$ g++ -o ex646 ex646.cpp -std=gnu++11 -Wall -Wpedantic\n</code></pre>\n<p>Run:  </p>\n<pre><code>$ ./ex646\naddress of shrt 0x7ffd39e41a50 # every time different\naddress of longer 0x7ffd39e41a40 # every time different, always 0x10 more than &amp;shrt\nshrt is shorter\nstring 0\nstring&amp; 1\nstring* 1\n</code></pre>\n<p>How is the compiler able to compare the addresses of both strings? They are during every run-time of the program different, whereas their relative position remains constant. Is the key to this usage, that at least their relative position to each other remains constant?</p>\n<p><strong>Update 2015-08-12</strong><br>\nAs time of writing this looks like in 'a bug in the constant evaluation rules' of the ISO-Standard (correct me if I'm wrong). See this <a href=\"https://groups.google.com/a/isocpp.org/d/msg/std-discussion/ppHUwsgl6yc/RJ-YZ2XlBQAJ\" rel=\"nofollow\" title=\"ISO C++ Standard - Discussion\">discussion</a> on an isocpp.org list. And therefore this shouldn't be a compiler bug inside GCC and CLANG.</br></p>\n<p>Thanks dyp!</p>\n", "Tags": "<c++><c++11><constexpr>", "OwnerUserId": "1054324", "AnswerCount": "2"}, "31922278": {"ParentId": "31922063", "PostTypeId": "2", "CommentCount": "21", "Body": "<p>So as far as I can tell this looks like some sort of compiler extension or a bug. C++11 was adjusted via a defect report to allow references to be considered literal types regardless if the variable it references is a literal type. But, a reference constant expression should refer to an object of static storage duration and similar for a address constant expression.</p>\n<p>The draft C++11 standard tell us what cases pointers can be considered equal:</p>\n<blockquote>\n<p id=\"so_31922063_31922278_0\">Two pointers of the same type compare equal if\n  and only if they are both null, both point to the same function, or both represent the same address (3.9.2).</p>\n</blockquote>\n<p>so in the your case the compiler can trivially deduce which case the <code>!=</code> falls under but I don't see a carve out that it would let it avoid the constant expressions requirements for this case.</p>\n<p>For reference section <code>5.19</code> <em>[expr.const]</em> tell us:</p>\n<blockquote>\n<p id=\"so_31922063_31922278_1\">an id-expression that refers to a variable or data member of reference type unless the reference has a\n  preceding initialization, initialized with a constant expression</p>\n</blockquote>\n<p>this was modified by <a href=\"http://wg21.cmeerw.net/cwg/issue1454\" rel=\"nofollow\">defect report 1454</a> which changes to read as follows:</p>\n<blockquote>\n<p id=\"so_31922063_31922278_2\">an id-expression that refers to a variable or data member of reference type unless the reference has a\n  preceding initialization and either</p>\n<ul>\n<li>it is initialized with a constant expression or</li>\n<li>it is a non-static data member of an object whose lifetime began within the evaluation of e</li>\n</ul>\n</blockquote>\n<p>but in either case that should be sufficient to make this case not a constant expression.</p>\n<blockquote>\n<p id=\"so_31922063_31922278_3\">A reference constant expression is an lvalue\n  core constant expression that designates an object with static storage duration or a function. An address\n  constant expression is a prvalue core constant expression of pointer type that evaluates to the address of an\n  object with static storage duration, to the address of a function, or to a null pointer value, or a prvalue core\n  constant expression of type std::nullptr_t.</p>\n</blockquote>\n<p>none of which applies to the automatic variables in your case.</p>\n<p>References were initially not literals but <a href=\"http://wg21.cmeerw.net/cwg/issue1195\" rel=\"nofollow\">defect report 1195 </a> which says:</p>\n<blockquote>\n<p id=\"so_31922063_31922278_4\">7.1.5 [dcl.constexpr] paragraph 3 is overly restrictive in requiring that reference parameter and return types of a constexpr function or constructor must refer to a literal type. 5.20 [expr.const] paragraph 2 already prevents any problematic uses of lvalues of non-literal types, and it permits use of pointers to non-literal types as address constants. The same should be permitted via reference parameters and return types of constexpr functions.</p>\n</blockquote>\n<p>and changes section <code>3.9</code> <em>[basic.types]</em> which said in the <code>N3337</code> the draft C++11 standard:</p>\n<blockquote>\n<p id=\"so_31922063_31922278_5\">A type is a literal type if it is:</p>\n<p id=\"so_31922063_31922278_6\">[...]</p>\n<ul>\n<li>a reference type referring to a literal type; or</li>\n</ul>\n</blockquote>\n<p>to:</p>\n<blockquote id=\"so_31922063_31922278_7\">\n<ul>\n<li>a reference type; or</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-08-11T20:22:43.663", "Id": "31922278", "Score": "2", "CreationDate": "2015-08-10T14:30:07.890", "LastActivityDate": "2015-08-11T20:22:43.663"}, "31922163": {"ParentId": "31922063", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>The address of the string is the address of the stack object and not the underlying pointer that the string is wrapping.  The address might be different on each run but the compiler will load the variables into memory the same way each time so the comparison will always yield the same results.  </p>\n<p>Note: Different compilers might order the variables in a different way so this code is not portable.</p>\n<p>Note 2: comparing pointers for equality (==, !=) is defined behavior for pointers of the same type.  trying to compare with relational operators (&lt;,&gt;,&lt;=,&gt;=) is unspecified if:</p>\n<blockquote>\n<p id=\"so_31922063_31922163_0\">two pointers p and q of the same type point to different objects that are not members of the same object or elements of the same array or to different functions, or if only one of them is null</p>\n</blockquote>\n", "OwnerUserId": "4342498", "LastEditorUserId": "4342498", "LastEditDate": "2015-08-10T14:48:12.837", "Id": "31922163", "Score": "2", "CreationDate": "2015-08-10T14:24:56.277", "LastActivityDate": "2015-08-10T14:48:12.837"}, "bq_ids": {"n4140": {"so_31922063_31922278_2": {"section_id": 6185, "quality": 1.0, "length": 11}, "so_31922063_31922278_3": {"section_id": 6187, "quality": 0.6153846153846154, "length": 24}, "so_31922063_31922278_1": {"section_id": 6185, "quality": 1.0, "length": 13}, "so_31922063_31922278_0": {"section_id": 6155, "quality": 0.7777777777777778, "length": 14}}, "n3337": {"so_31922063_31922278_2": {"section_id": 5946, "quality": 0.9090909090909091, "length": 10}, "so_31922063_31922278_3": {"section_id": 5947, "quality": 0.9487179487179487, "length": 37}, "so_31922063_31922163_0": {"section_id": 5913, "quality": 1.0, "length": 18}, "so_31922063_31922278_1": {"section_id": 5946, "quality": 1.0, "length": 13}, "so_31922063_31922278_0": {"section_id": 5917, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_31922063_31922278_0": {"section_id": 7652, "quality": 0.6111111111111112, "length": 11}, "so_31922063_31922278_2": {"section_id": 7687, "quality": 1.0, "length": 11}, "so_31922063_31922278_1": {"section_id": 7687, "quality": 1.0, "length": 13}, "so_31922063_31922278_3": {"section_id": 7690, "quality": 0.5641025641025641, "length": 22}}}});