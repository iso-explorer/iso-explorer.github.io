post_cb({"33312291": {"CommentCount": "3", "AcceptedAnswerId": "33312402", "LastEditDate": "2017-05-31T13:08:39.323", "LastEditorUserId": "963864", "CreationDate": "2015-10-23T22:25:36.633", "LastActivityDate": "2017-05-31T13:08:39.323", "PostTypeId": "1", "ViewCount": "146", "FavoriteCount": "1", "Title": "Is this use of reinterpret_cast on differently-qualified struct members safe?", "Id": "33312291", "Score": "7", "Body": "<p><sub>I have looked at the following \u2014 related \u2014 questions, and none of them seem to address my exact issue: <a href=\"https://stackoverflow.com/q/7762929/\">one</a>, <a href=\"https://stackoverflow.com/q/10204032/\">two</a>, <a href=\"https://stackoverflow.com/q/28792554/\">three</a>.</sub></p>\n<p>I am writing a collection of which the elements (key-value pairs) are stored along with some bookkeeping information:</p>\n<pre><code>struct Element {\n    Key key;\n    Value value;\n    int flags;\n};\n\nstd::vector&lt;Element&gt; elements;\n</code></pre>\n<p>(For simplicity, suppose that both <code>Key</code> and <code>Value</code> are standard-layout types. The collection won't be used with any other types anyway.)</p>\n<p>In order to support iterator-based access, I've written iterators that override <code>operator-&gt;</code> and <code>operator*</code> to return to the user a pointer and a reference, respectively, to the key-value pair. However, due to the nature of the collection, the user is never allowed to change the returned key. For this reason, I've declared a <code>KeyValuePair</code> structure:</p>\n<pre><code>struct KeyValuePair {\n    const Key key;\n    Value value;\n};\n</code></pre>\n<p>And I've implemented <code>operator-&gt;</code> on the iterator like this:</p>\n<pre><code>struct iterator {\n    size_t index;\n\n    KeyValuePair *operator-&gt;() {\n        return reinterpret_cast&lt;KeyValuePair *&gt;(&amp;elements[index]);\n    }\n};\n</code></pre>\n<p>My question is: is this use of <code>reinterpret_cast</code> well-defined, or does it invoke undefined behavior? I have tried to interpret relevant parts of the standard and examined answers to questions about similar issues, however, I failed to draw a definitive conclusion from them, because\u2026:</p>\n<ul>\n<li>the two struct types share some initial data members (namely, <code>key</code> and <code>value</code>) that only differ in <code>const</code>-qualification;</li>\n<li>the standard does not explicitly say that <code>T</code> and <code>cv T</code> are layout-compatible, but it doesn't state the converse either; furthermore, it mandates that they should have the same representation and alignment requirements;</li>\n<li>Two standard-layout class types share a common initial sequence if the first however many members have layout-compatible types;</li>\n<li>for union types containing members of class type that share a common initial sequence, it is permitted to examine the members of such initial sequence using either of the union members (9.2p18).\n\u2013 there's no similar explicit guarantee made about <code>reinterpret_cast</code>ed pointers-to-structs sharing a common initial sequence.\n\u2013 it is, however, guaranteed that a pointer-to-struct points to its initial member (9.2p19).</li>\n</ul>\n<p>Using merely this information, I found it impossible to deduce whether the <code>Element</code> and <code>KeyValuePair</code> structs share a common initial sequence, or have anything other in common that would justify my <code>reinterpret_cast</code>.</p>\n<p>As an aside, if you think using <code>reinterpret_cast</code> for this purpose is inappropriate, and I'm really facing an XY problem and therefore I should simply do something else to achieve my goal, let me know.</p>\n", "Tags": "<c++><c++11><language-lawyer><reinterpret-cast><strict-aliasing>", "OwnerUserId": "3477950", "AnswerCount": "1"}, "bq_ids": {"n3337": {"so_33312291_33312402_1": {"section_id": 5254, "quality": 0.625, "length": 5}}, "n4659": {"so_33312291_33312402_1": {"section_id": 8718, "quality": 0.625, "length": 5}}}, "33312402": {"ParentId": "33312291", "LastEditDate": "2015-10-23T22:41:27.607", "CommentCount": "2", "CreationDate": "2015-10-23T22:37:40.320", "Score": "7", "Id": "33312402", "PostTypeId": "2", "LastEditorUserId": "3647361", "OwnerUserId": "3647361", "Body": "<blockquote>\n<p id=\"so_33312291_33312402_0\">My question is: is this use of reinterpret_cast well-defined, or does\n  it invoke undefined behavior?</p>\n</blockquote>\n<p><code>reinterpret_cast</code> is the wrong approach here, you're simply violating strict aliasing. It is somewhat perplexing that <code>reinterpret_cast</code> and <code>union</code> diverge here, but the wording is very clear about this scenario.</p>\n<p>You might be better off simply defining a union thusly:</p>\n<pre><code>union elem_t {\n   Element e{}; KeyValuePair p;\n   /* special member functions defined if necessary */\n};\n</code></pre>\n<p>\u2026 and using that as your vector element type. Note that cv-qualification is ignored when determining layout-compability - [basic.types]/11:</p>\n<blockquote>\n<p id=\"so_33312291_33312402_1\">Two types <em>cv1</em> <code>T1</code> and <em>cv2</em> <code>T2</code> are layout-compatible types if\n  <code>T1</code> and <code>T2</code> are the same type, [\u2026]</p>\n</blockquote>\n<p>Hence <code>Element</code> and <code>KeyValuePair</code> do indeed share a common initial sequence, and accessing the corresponding members of <code>p</code>, provided <code>e</code> is alive, is well-defined.</p>\n<hr>\n<p>Another approach: Define </p>\n<pre><code>struct KeyValuePair {\n    Key key;\n    mutable Value value;\n};\n\nstruct Element : KeyValuePair {\n    int flags;\n};\n</code></pre>\n<p>Now provide an iterator that simply wraps a <code>const_iterator</code> from the vector and upcasts the references/pointers to be exposed. <code>key</code> won't be modifiable, but <code>value</code> will be.</p>\n</hr>", "LastActivityDate": "2015-10-23T22:41:27.607"}});