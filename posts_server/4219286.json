post_cb({"4219672": {"CommentCount": "0", "Body": "<p>You are just trying to obfuscate your code, it is as simple as that. And the compiler is completely correct in telling you so.</p>\n<p>If you have a precise idea what the assigned value should be, use that. My guess is that you have some unfounded presumption of <code>short</code> being 16 bit wide and that the sign representation of the target machine is two's complement. If that is so, assign -4083 to your variable. If you just need your variable as a bit vector, use an unsigned type.</p>\n<p>As far as C is concerned the standard simply says about conversion from one integer type to another:</p>\n<blockquote>\n<p id=\"so_4219286_4219672_0\">Otherwise, the new type is signed and\n  the value cannot be represented in it;\n  either the result is\n  implementation-defined or an\n  implementation-defined signal is\n  raised.</p>\n</blockquote>\n<p>I imagine the the point of view of C++ with this respect is not much different. Other answers mention border cases where in C++ you would need a `C'-style cast to overrule all typechecks that C++ gives you. Feeling the need for them is an indication of bad design.</p>\n<p>The case that you give as an example is certainly not one for which I would find any valid circumstances.</p>\n", "CreationDate": "2010-11-18T21:17:21.367", "ParentId": "4219286", "Id": "4219672", "LastActivityDate": "2010-11-18T21:17:21.367", "PostTypeId": "2", "Score": "2", "OwnerUserId": "366377"}, "4219550": {"CommentCount": "5", "Body": "<p>There are 4 c++ style casts, const_cast, reinterpret_cast, static_cast and dynamic_cast. They work as follows:</p>\n<pre><code>// const_cast casts away constness or adds it\nconst int const_integer = 5;\nconst_cast&lt;int&gt;(const_integer) = 3;\n\n// static_cast will perform standards defined casts and will \n// cast up or down a c++ inheritance hierarchy without checking the result of the cast\nstruct b {};\nstruct a : public b {};\nstruct c {};\ndouble value = static_cast&lt;double&gt;(0.0f);\nb* b_value = new b;\na* a_value = static_cast&lt;a*&gt;(b_value);\n\n// dynamic_cast will perform any cast that static_cast will, but will check to see\n// if the cast makes sense. If the values are not pointers, this cast can throw\nb* value_b = new b;\na* value_a = new a;\nb* new_b = dynamic_cast&lt;b*&gt;(value_a); // will return NULL\na* new_a = dynamic_cast&lt;a*&gt;(value_b); // will not return NULL    \n\n// reinterpret_cast will change any type to any other type, as long as the constness of the types is the same.\n// the behavior of this cast is implementation specific.\ndouble* a = new double;\n*a = 0.0f;\nint *b = reinterpret_cast&lt;int*&gt;(a);\n</code></pre>\n<p>A c-style cast in c++ simply tries to perform those casts in a specific order until one of them works. That order is as follows:</p>\n<ul>\n<li>a const_cast</li>\n<li>a static_cast</li>\n<li>a static_cast followed by a const_cast</li>\n<li>a reinterpret_cast, or</li>\n<li>a reinterpret_cast followed by a const_cast.</li>\n</ul>\n<p>So, in short, you can do any c-style cast in c++, because a c-style cast in c++ is just some arrangement of c++ style casts. Get it?</p>\n", "CreationDate": "2010-11-18T21:01:41.260", "ParentId": "4219286", "Id": "4219550", "LastActivityDate": "2010-11-18T21:01:41.260", "PostTypeId": "2", "Score": "0", "OwnerUserId": "365086"}, "4219366": {"LastActivityDate": "2010-11-18T21:21:51.860", "CommentCount": "9", "Body": "<p>In C++, the C-style cast is defined (\u00a75.4) in terms of C++-style casts. So for every cast you can do C-style, there's a matching C++-style cast (almost).</p>\n<p>The \"almost\" is that C-style casts ignore base class accessibility. That is, there is no equivalent C++-style cast for the following:</p>\n<pre><code>struct foo {};\nstruct bar : private foo {};\n\nbar b;\nfoo* f = (foo*)&amp;b; // only way this can be done in a well-defined manner\n</code></pre>\n<p>So, no it's not strictly-speaking possible to completely ditch C-style casts. But the number of areas where a (combination  of) C++-style casts doesn't suffice is few in count.</p>\n<hr>\n<p>The above is the \"language answer\". What you're experiencing has nothing to do with C-style casts versus C++ casts, but just compiler implementation. Warnings are absolutely implementation-specific, and have nothing to do with C++.</p>\n<p>So don't make the mistake of using your findings <em>on this particular compiler in this particular situation</em> for concluding things <em>about C++ in general</em>.</p>\n</hr>", "CreationDate": "2010-11-18T20:40:07.887", "LastEditDate": "2010-11-18T21:21:51.860", "ParentId": "4219286", "Id": "4219366", "LastEditorUserId": "87234", "PostTypeId": "2", "Score": "10", "OwnerUserId": "87234"}, "4219286": {"CreationDate": "2010-11-18T20:32:36.887", "ViewCount": "1262", "Id": "4219286", "AcceptedAnswerId": "4219672", "Score": "6", "Title": "Is it possible to completely avoid C-style casts in C++?", "LastEditorUserId": "-1", "CommentCount": "16", "Body": "<p>I do not believe that it is possible to completely avoid C-style casts when writing C++. I was surprised to <a href=\"https://stackoverflow.com/questions/4219160/avoiding-truncation-warnings-from-my-c-compiler-when-initializing-signed-values\">find out</a> that I needed to use a C-style cast to avoid a compiler truncation warning:</p>\n<pre><code>short value_a = 0xF00D;                     // Truncation warning in VS2008\nshort value_b = static_cast&lt;short&gt;(0xF00D); // Truncation warning in VS2008\nshort value_c = (short)0xF00D;              // No warning!\n</code></pre>\n<p>Are there other scenarios where there is no C++-style substitute for a C-style cast?</p>\n", "Tags": "<c++><c><casting>", "LastEditDate": "2017-05-23T12:13:44.067", "LastActivityDate": "2010-12-27T12:28:51.400", "PostTypeId": "1", "AnswerCount": "6", "OwnerUserId": "111327"}, "4219303": {"LastActivityDate": "2010-11-18T20:37:31.887", "CommentCount": "4", "Body": "<p>In these cases, you can use <code>reinterpret_cast</code>. It was meant for a replacement of a unchecked C-style cast. The typical note here: this is unchecked cast, and should be avoided when possible by using the other available: <code>const_cast</code>, <code>dynamic_cast</code>, etc.</p>\n", "CreationDate": "2010-11-18T20:34:39.080", "LastEditDate": "2010-11-18T20:37:31.887", "ParentId": "4219286", "Id": "4219303", "LastEditorUserId": "62365", "PostTypeId": "2", "Score": "-3", "OwnerUserId": "62365"}, "4219339": {"LastActivityDate": "2010-11-18T20:44:21.750", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_4219286_4219339_0\">I was surprised to find out that I needed to use a C-style cast to avoid a compiler truncation warning</p>\n</blockquote>\n<p>I see it the other way around: You use a C-style cast to <strong><em>prevent the compiler from warning you</em></strong>,  and I see this as a severe disadvantage of the C-style cast.</p>\n<p>if you feel you know what you're doing, then shut up the compiler for this one case by using a compiler-specific way. For example, for VC use something like </p>\n<pre><code>#pragma warning(push, disable: XXXX)\n// code goes here\n#pragma warning(pop)\n</code></pre>\n", "CreationDate": "2010-11-18T20:38:21.420", "LastEditDate": "2010-11-18T20:44:21.750", "ParentId": "4219286", "Id": "4219339", "LastEditorUserId": "140719", "PostTypeId": "2", "Score": "0", "OwnerUserId": "140719"}, "bq_ids": {"n4140": {"so_4219286_4219334_0": {"length": 4, "quality": 0.8, "section_id": 500}}, "n3337": {"so_4219286_4219334_0": {"length": 4, "quality": 0.8, "section_id": 491}}}, "4219334": {"LastActivityDate": "2010-12-27T12:28:51.400", "CommentCount": "5", "Body": "<p>Yes, it is completely possible.</p>\n<p>I never use C-style casts.  I can write hundreds of thousands of lines of code without having to revert to using <code>reinterpret_cast</code>, C++'s closes cousin to the C-style cast.  The only times I have to use <code>reinterpret_cast</code> is when doing socket programming -- a fairly narrow domain, in the big picture.</p>\n<p><em>You</em> don't <em>need</em> to use C-style casts, either.  In your <a href=\"https://stackoverflow.com/questions/4219160/avoiding-truncation-warnings-from-my-c-compiler-when-initializing-signed-values\">other post</a>, you said </p>\n<blockquote>\n<p id=\"so_4219286_4219334_0\">I could just use a negative value,</p>\n</blockquote>\n<pre><code>short my_value = -4083;\n</code></pre>\n<blockquote>\n<p id=\"so_4219286_4219334_1\">but in my code it is much more understandable to use hexadecimal.</p>\n</blockquote>\n<p>So in this case you didn't have to use the cast.  You chose to.</p>\n", "CreationDate": "2010-11-18T20:37:57.733", "LastEditDate": "2017-05-23T12:30:51.023", "ParentId": "4219286", "Id": "4219334", "LastEditorUserId": "-1", "PostTypeId": "2", "Score": "2", "OwnerUserId": "241536"}});