post_cb({"bq_ids": {"n4140": {"so_12718423_12718425_0": {"length": 36, "quality": 0.8181818181818182, "section_id": 5974}, "so_12718423_12718425_1": {"length": 15, "quality": 1.0, "section_id": 5981}}, "n3337": {"so_12718423_12718425_0": {"length": 38, "quality": 0.8636363636363636, "section_id": 5742}, "so_12718423_12718425_1": {"length": 15, "quality": 1.0, "section_id": 5749}}, "n4659": {"so_12718423_12718425_0": {"length": 33, "quality": 0.75, "section_id": 7473}, "so_12718423_12718425_1": {"length": 15, "quality": 1.0, "section_id": 7478}}}, "12718423": {"ViewCount": "1746", "Body": "<p>I have a decent amount of code that relies on capturing a <code>shared_from_this()</code> when using a lambda expression as a callback to ensure that my instance stays alive:</p>\n<pre><code>std::shared_ptr&lt;Thing&gt; self = shared_from_this();\nauto doSomething = [this, self] ()\n{\n    // various statements, none of which reference self, but do use this\n}\n</code></pre>\n<p>So the question is: Since I am not referencing <code>self</code> inside the lambda body, is a conformant compiler allowed to optimize the capture away?</p>\n<hr>\n<p>Consider the following program:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\nstd::function&lt;void ()&gt; gFunc;\n\nstruct S : std::enable_shared_from_this&lt;S&gt;\n{\n    void putGlobal()\n    {\n        auto self = shared_from_this();\n        gFunc = [self] { };\n    }\n};\n\nint main()\n{\n    auto x = std::make_shared&lt;S&gt;();\n    std::cout &lt;&lt; x.use_count() &lt;&lt; std::endl;\n    x-&gt;putGlobal();\n    std::cout &lt;&lt; x.use_count() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>The output is:</p>\n<pre><code>1\n2\n</code></pre>\n<p>This indicates that <code>g++-4.7.1</code> does not optimize the capture away (nor does <code>clang-3.1</code>). </p>\n</hr>", "AcceptedAnswerId": "12718425", "Title": "C++: Can an unused lambda explicit capture be optimized out?", "CreationDate": "2012-10-03T23:42:41.290", "Id": "12718423", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-10-04T15:14:10.123", "LastEditorUserId": "254306", "LastActivityDate": "2012-10-04T15:14:10.123", "Score": "23", "OwnerUserId": "254306", "Tags": "<c++><lambda><c++11><language-lawyer>", "AnswerCount": "1"}, "12718425": {"Id": "12718425", "PostTypeId": "2", "Body": "<p>The standard guarantees that captured values are not optimized away (per \u00a75.1.2/14):</p>\n<blockquote>\n<p id=\"so_12718423_12718425_0\"><strong>An entity is captured by copy if</strong> it is implicitly captured and the capture-default is = or if <strong>it is explicitly\n  captured</strong> with a capture that does not include an &amp;. <strong>For each entity captured by copy, an unnamed non-\n  static data member is declared in the closure type.</strong> The declaration order of these members is unspecified.\n  The type of such a data member is the type of the corresponding captured entity if the entity is not a\n  reference to an object, or the referenced type otherwise.</p>\n</blockquote>\n<p>So, <code>self</code> is copied into the closure on evaluation (per \u00a75.1.2/21):</p>\n<blockquote>\n<p id=\"so_12718423_12718425_1\">When the lambda-expression is evaluated, the entities that are captured by copy are used to direct-initialize\n  each corresponding non-static data member of the resulting closure object.</p>\n</blockquote>\n", "LastEditorUserId": "87234", "LastActivityDate": "2012-10-03T23:47:24.187", "Score": "30", "CreationDate": "2012-10-03T23:42:41.290", "ParentId": "12718423", "CommentCount": "3", "OwnerUserId": "254306", "LastEditDate": "2012-10-03T23:47:24.187"}});