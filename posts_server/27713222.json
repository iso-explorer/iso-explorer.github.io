post_cb({"bq_ids": {"n4140": {"so_27713222_27713222_5": {"length": 9, "quality": 1.0, "section_id": 206}, "so_27713222_27713597_4": {"length": 9, "quality": 0.9, "section_id": 206}, "so_27713222_27713597_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 203}, "so_27713222_27713222_3": {"length": 10, "quality": 1.0, "section_id": 203}, "so_27713222_27713597_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 205}, "so_27713222_27713597_1": {"length": 7, "quality": 0.875, "section_id": 200}}, "n3337": {"so_27713222_27713222_5": {"length": 9, "quality": 1.0, "section_id": 200}, "so_27713222_27713597_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 197}, "so_27713222_27713222_3": {"length": 10, "quality": 1.0, "section_id": 197}, "so_27713222_27713597_1": {"length": 7, "quality": 0.875, "section_id": 194}, "so_27713222_27713597_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 199}, "so_27713222_27713597_4": {"length": 9, "quality": 0.9, "section_id": 200}}, "n4659": {"so_27713222_27713222_5": {"length": 9, "quality": 1.0, "section_id": 214}, "so_27713222_27713597_3": {"length": 10, "quality": 0.9090909090909091, "section_id": 209}, "so_27713222_27713222_3": {"length": 10, "quality": 1.0, "section_id": 209}, "so_27713222_27713597_1": {"length": 7, "quality": 0.875, "section_id": 206}, "so_27713222_27713597_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 213}, "so_27713222_27713597_4": {"length": 9, "quality": 0.9, "section_id": 214}}}, "27713597": {"Id": "27713597", "PostTypeId": "2", "Body": "<p>I'm using a post-N4296 draft.</p>\n<pre><code>typedef I&lt;sizeof(sizeof(T))&gt;::Type Type;\n</code></pre>\n<p><code>typename</code> is required if the <em>nested-name-specifier</em> <code>I&lt;..&gt;</code> depends on a template parameter [temp.res]/5. So, is <code>I&lt;..&gt;</code> dependent?</p>\n<blockquote>\n<p id=\"so_27713222_27713597_0\">[temp.dep.type]/9 A type is dependent if it is</p>\n<ul>\n<li>[...]</li>\n<li>(9.7) a <em>simple-template-id</em> in which either the template name is a template parameter or any of the template arguments is a dependent\n  type or an expression that is <strong>type-dependent</strong> or <strong>value-dependent</strong>, or\n  [...]</li>\n</ul>\n</blockquote>\n<p><code>I&lt;..&gt;</code> is a <em>simple-template-id</em>, the template argument is an expression. Is this expression <code>sizeof(sizeof(T))</code> type-dependent or value-dependent?</p>\n<p>The expression <code>sizeof(sizeof(T))</code> can be broken down into the following expressions:</p>\n<pre>\nexpression           form\n===============================================\n              T      <i>type-id</i>\n       sizeof(T)     sizeof ( <i>type-id</i> )\n      (sizeof(T))    ( <i>expression</i> )\nsizeof(sizeof(T))    sizeof <i>unary-expression</i>\n</pre>\n<p><code>T</code> is not an expression, but I'll leave it in the list for later. A note on the parentheses: A <em>primary-expression</em> can be a parenthesized (general) <em>expression</em>. A <em>unary-expression</em> can be a <em>postfix-expression</em> which can be a <em>primary-expression</em>, hence it can be parenthesized, too.</p>\n<p>A parenthesized expression <code>(X)</code> is dependent if <code>X</code> is dependent:</p>\n<blockquote>\n<p id=\"so_27713222_27713597_1\">[temp.dep.expr]/1 Except as described below, an expression is type-dependent if any subexpression is type-dependent.</p>\n<p id=\"so_27713222_27713597_2\">[temp.dep.constexpr]/1  Except as described below, a constant expression is value-dependent if any subexpression is value-dependent.</p>\n</blockquote>\n<p>In general, <code>sizeof</code> expressions are never <strong>type</strong>-dependent, because they always produce a value of type <code>std::size_t</code>:</p>\n<blockquote>\n<p id=\"so_27713222_27713597_3\">[temp.dep.expr]/4 Expressions of the following forms <strong>are never type-dependent</strong> (because the type of the expression cannot be dependent):</p>\n<pre><code>[...]\nsizeof unary-expression\nsizeof ( type-id )\n</code></pre>\n</blockquote>\n<p>However, the value they yield can be dependent on a template parameter:</p>\n<blockquote>\n<p id=\"so_27713222_27713597_4\">[temp.dep.constexpr]/2 Expressions of the following form <strong>are value-dependent if the <em>unary-expression</em> or <em>expression</em> is type-dependent or the <em>type-id</em> is dependent</strong>:</p>\n<pre><code>sizeof unary-expression\nsizeof ( type-id )\n</code></pre>\n</blockquote>\n<pre>\nexpression           form                       value-dep?   type-dep?\n=======================================================================\n              T      <i>type-id</i>                    no           yes\n       sizeof(T)     sizeof ( <i>type-id</i> )         yes          no\n      (sizeof(T))    ( <i>expression</i> )             yes          no\nsizeof(sizeof(T))    sizeof <i>unary-expression</i>    no           no\n</pre>\n<p>Since <code>T</code> is <strong>type</strong>-dependent, <code>sizeof(T)</code> becomes <strong>value</strong>-dependent. However, since <code>(sizeof(T))</code> is <strong>not type</strong>-dependent, <code>sizeof(sizeof(T))</code> is not dependent at all.</p>\n", "LastEditorUserId": "420683", "LastActivityDate": "2014-12-30T23:07:55.407", "Score": "7", "CreationDate": "2014-12-30T22:39:34.907", "ParentId": "27713222", "CommentCount": "1", "OwnerUserId": "420683", "LastEditDate": "2014-12-30T23:07:55.407"}, "27713222": {"ViewCount": "221", "Body": "<p>I noticed that gcc 5.0 rejects the following code, while clang 3.6 accepts it.</p>\n<pre><code>template&lt;int n&gt;\nstruct I\n{\n    typedef int Type;\n};\n\ntemplate&lt;typename T&gt;\nstruct A\n{\n    typedef I&lt;sizeof(sizeof(T))&gt;::Type Type;\n};\n</code></pre>\n<p>The two compilers seem to differ on whether <code>sizeof(sizeof(T))</code> is a type-dependent or value-dependent expression. If the expression were dependent, then it follows that <code>I&lt;sizeof(sizeof(T))&gt;</code> is a dependent type, meaning that <code>typename</code> should be required.</p>\n<p>This is covered by the following wording in the C++11 standard:</p>\n<blockquote>\n<p id=\"so_27713222_27713222_0\">[temp.dep.type]/8</p>\n<p id=\"so_27713222_27713222_1\">A type is dependent if it is</p>\n<ul>\n<li>a simple-template-id in which either the template name is a template parameter or <strong>any of the template\n  arguments is a dependent type or an expression that is type-dependent or value-dependent</strong></li>\n</ul>\n<p id=\"so_27713222_27713222_2\">[temp.dep.expr]/4</p>\n<p id=\"so_27713222_27713222_3\">Expressions of the following forms are never type-dependent (because the type of the expression cannot be\n  dependent):</p>\n<pre><code>sizeof unary-expression\nsizeof ( type-id )\n</code></pre>\n<p id=\"so_27713222_27713222_4\">[temp.dep.constexpr]/2</p>\n<p id=\"so_27713222_27713222_5\">Expressions of the following form are value-dependent if the unary-expression or expression is typedependent\n  or the type-id is dependent:</p>\n<pre><code>sizeof unary-expression\nsizeof ( type-id )\n</code></pre>\n</blockquote>\n<p>My interpretation is that <code>sizeof(T)</code> can never be type-dependent, meaning <code>sizeof(sizeof(T))</code> can never be type-dependent or value-dependent.</p>\n<p>Is this a bug in gcc?</p>\n", "AcceptedAnswerId": "27713597", "Title": "Can sizeof nested twice ever be a dependent expression?", "CreationDate": "2014-12-30T22:02:39.563", "Id": "27713222", "CommentCount": "9", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-12-30T22:52:27.380", "LastEditorUserId": "1690864", "LastActivityDate": "2014-12-30T23:07:55.407", "Score": "16", "OwnerUserId": "1690864", "Tags": "<c++><templates><language-lawyer><dependent-type><compiler-bug>", "AnswerCount": "1"}});