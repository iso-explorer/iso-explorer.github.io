post_cb({"bq_ids": {"n4140": {"so_15232758_15236647_2": {"section_id": 217, "quality": 1.0, "length": 18}}, "n3337": {"so_15232758_15236647_2": {"section_id": 211, "quality": 1.0, "length": 18}}, "n4659": {"so_15232758_15236647_2": {"section_id": 225, "quality": 1.0, "length": 18}}}, "15232758": {"CommentCount": "10", "AcceptedAnswerId": "15236647", "PostTypeId": "1", "LastEditorUserId": "500104", "CreationDate": "2013-03-05T19:47:05.563", "LastActivityDate": "2017-04-30T10:48:53.860", "LastEditDate": "2013-03-05T23:07:53.760", "ViewCount": "2699", "FavoriteCount": "10", "Title": "Detecting constexpr with SFINAE", "Id": "15232758", "Score": "29", "Body": "<p>I'm working on upgrading some C++ code to take advantage of the new functionality in C++11. I have a trait class with a few functions returning fundamental types which would most of the time, but not always, return a constant expression. I would like to do different things based on whether the function is <code>constexpr</code> or not. I came up with the following approach:</p>\n<pre><code>template&lt;typename Trait&gt;\nstruct test\n{\n    template&lt;int Value = Trait::f()&gt;\n    static std::true_type do_call(int){ return std::true_type(); }\n\n    static std::false_type do_call(...){ return std::false_type(); }\n\n    static bool call(){ return do_call(0); }\n};\n\nstruct trait\n{\n    static int f(){ return 15; }\n};\n\nstruct ctrait\n{\n    static constexpr int f(){ return 20; }\n};\n\nint main()\n{\n   std::cout &lt;&lt; \"regular: \" &lt;&lt; test&lt;trait&gt;::call() &lt;&lt; std::endl;\n   std::cout &lt;&lt; \"constexpr: \" &lt;&lt; test&lt;ctrait&gt;::call() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>The extra <code>int</code>/<code>...</code> parameter is there so that if both functions are available after <em>SFINAE</em>, the first one gets chosen by overloading resolution.</p>\n<p>Compiling and running this with <em>Clang 3.2</em> shows:</p>\n<pre><code>regular: 0\nconstexpr: 1\n</code></pre>\n<p>So this appears to work, but I would like to know if the code is legal C++11. Specially since it's my understanding that the rules for <em>SFINAE</em> have changed.</p>\n", "Tags": "<c++><templates><c++11><sfinae><constexpr>", "OwnerUserId": "927034", "AnswerCount": "2"}, "43701691": {"ParentId": "15232758", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Prompted by @marshall-clow, I put together a somewhat more-generic version of an type-trait for detecting <code>constexpr</code>. I modelled it on <a href=\"http://en.cppreference.com/w/cpp/types/result_of\" rel=\"nofollow noreferrer\"><code>std::invoke_result</code></a>, but because <code>constexpr</code> depends on the inputs, the template arguments are for the values passed in, rather than the types.</p>\n<p>It's somewhat limited, as the template args can only be a <a href=\"http://eel.is/c++draft/temp.param#4\" rel=\"nofollow noreferrer\">limited set of types</a>, and they're all <em>const</em> when they get to the method call. You can easily test a <code>constexpr</code> wrapper method if you need other types, or <em>non-const lvalues</em> for a reference parameter.</p>\n<p>So somewhat more of an exercise and demonstration than actually-useful code.</p>\n<p>And the use of <a href=\"https://stackoverflow.com/a/38044251/166389\"><code>template&lt;auto F, auto... Args&gt;</code></a> makes it C++17-only, needing gcc 7 or clang 4. MSVC 14.10.25017 can't compile it.</p>\n<pre><code>namespace constexpr_traits {\n\nnamespace detail {\n\n// Call the provided method with the provided args.\n// This gives us a non-type template parameter for void-returning F.\n// This wouldn't be needed if \"auto = F(Args...)\" was a valid template\n// parameter for void-returning F.\ntemplate&lt;auto F, auto... Args&gt;\nconstexpr void* constexpr_caller() {\n    F(Args...);\n    return nullptr;\n}\n\n// Takes a parameter with elipsis conversion, so will never be selected\n// when another viable overload is present\ntemplate&lt;auto F, auto... Args&gt;\nconstexpr bool is_constexpr(...) { return false; }\n\n// Fails substitution if constexpr_caller&lt;F, Args...&gt;() can't be\n// called in constexpr context\ntemplate&lt;auto F, auto... Args, auto = constexpr_caller&lt;F, Args...&gt;()&gt;\nconstexpr bool is_constexpr(int) { return true; }\n\n}\n\ntemplate&lt;auto F, auto... Args&gt;\nstruct invoke_constexpr : std::bool_constant&lt;detail::is_constexpr&lt;F, Args...&gt;(0)&gt; {};\n\n}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/BskkPyebb2vUZICh\" rel=\"nofollow noreferrer\">Live demo with use-cases on wandbox</a></p>\n", "OwnerUserId": "166389", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:10:03.420", "Id": "43701691", "Score": "1", "CreationDate": "2017-04-30T00:16:46.603", "LastActivityDate": "2017-04-30T10:48:53.860"}, "15236647": {"ParentId": "15232758", "PostTypeId": "2", "CommentCount": "10", "Body": "<blockquote>\n<p id=\"so_15232758_15236647_0\"><strong>NOTE:</strong> <a href=\"https://stackoverflow.com/q/15248944/500104\">I opened a question here</a> about whether OPs code is actually valid. My rewritten example below will work in any case.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_15232758_15236647_1\">but I would like to know if the code is legal C++11</p>\n</blockquote>\n<p>It is, although the default template argument may be considered a bit unusual. I personally like the following style better, which is similar to how you (read: I) write a trait to <a href=\"https://stackoverflow.com/a/9154394/500104\">check for a function's existence</a>, just using a non-type template parameter and leaving out the <code>decltype</code>:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nnamespace detail{\ntemplate&lt;int&gt; struct sfinae_true : std::true_type{};\ntemplate&lt;class T&gt;\nsfinae_true&lt;(T::f(), 0)&gt; check(int);\ntemplate&lt;class&gt;\nstd::false_type check(...);\n} // detail::\n\ntemplate&lt;class T&gt;\nstruct has_constexpr_f : decltype(detail::check&lt;T&gt;(0)){};\n</code></pre>\n<p><a href=\"https://ideone.com/AaqMHa\" rel=\"nofollow noreferrer\">Live example.</a></p>\n<hr>\n<p>Explanation time~</p>\n<p>Your original code works<sup>\u2020</sup> because a default template argument's point of instantiation is the point of instantiation of its function template, meaning, in your case, in <code>main</code>, so it can't be substituted earlier than that.</p>\n<p><code>\u00a714.6.4.1 [temp.point] p2</code></p>\n<blockquote>\n<p id=\"so_15232758_15236647_2\">If a function template [...] is called in a way which uses the definition of a default argument of that function template [...], the point of instantiation of the default argument is the point of instantiation of the function template [...].</p>\n</blockquote>\n<p>After that, it's just usual SFINAE rules.</p>\n<hr>\n<p>\u2020 Atleast I think so, it's not <em>entirely</em> clear in the standard.</p>\n</hr></hr></hr>", "OwnerUserId": "500104", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:34:23.590", "Id": "15236647", "Score": "12", "CreationDate": "2013-03-06T00:11:41.543", "LastActivityDate": "2013-03-06T13:42:53.217"}});