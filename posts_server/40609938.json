post_cb({"40610131": {"ParentId": "40609938", "CommentCount": "0", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/container/array/begin\" rel=\"nofollow noreferrer\"><code>std::array::begin</code></a> returns an <code>iterator</code>, not a <code>pointer</code>.</p>\n<p>The <code>iterator</code> <em>can</em> be defined as a pointer, but it doesn't need to be.</p>\n<p>To get a pointer to first item you can use <a href=\"http://en.cppreference.com/w/cpp/container/array/data\" rel=\"nofollow noreferrer\"><code>std::array::data</code></a>.</p>\n<hr>\n<p>Re the \u201cimplicit cast\u201d, no, there's no such here.</p>\n<hr>\n<p>A general technique for converting an iterator to raw pointer is to first derefence it, <code>*it</code>, which generally yields a reference, and then take the address of that, <code>&amp;*it</code>. However, this will necessarily fail when there is no addressable item to take the address of, such as in a packed <code>std::vector&lt;bool&gt;</code> (it's up to the implementation whether it's packed, but <em>if</em> it's packed). In such a case dereferencing the iterator yields some proxy object instead of a raw reference.</p>\n</hr></hr>", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "40610131", "Score": "2", "CreationDate": "2016-11-15T12:43:11.247", "LastActivityDate": "2016-11-15T12:43:11.247"}, "40610189": {"ParentId": "40609938", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>As seen in <a href=\"http://eel.is/c++draft/sequences#array.overview-3\" rel=\"nofollow noreferrer\">The C++ standard draft</a> an <code>iterator</code> is <em>implementation-defined</em>:</p>\n<blockquote>\n<p id=\"so_40609938_40610189_0\"><code>using iterator               = implementation-defined; // see [container.requirements]</code></p>\n</blockquote>\n<p><em>[container.requirements]</em> says that <code>iterator</code> should <a href=\"http://eel.is/c++draft/container.requirements\" rel=\"nofollow noreferrer\">be at least</a>:</p>\n<blockquote>\n<p id=\"so_40609938_40610189_1\">Any iterator category that meets the forward iterator requirements.\n  convertible to X::const_iterator.</p>\n</blockquote>\n<p>Neither <a href=\"http://en.cppreference.com/w/cpp/concept/ForwardIterator\" rel=\"nofollow noreferrer\">requirements of a forward iterator</a> nor the requirements of the <a href=\"http://en.cppreference.com/w/cpp/concept/InputIterator\" rel=\"nofollow noreferrer\">InputIterator</a> (ForwardIterator needs to satisfy requirements for InputIterator) nor the requirements of an <a href=\"http://en.cppreference.com/w/cpp/concept/Iterator\" rel=\"nofollow noreferrer\">Iterator</a> (InputIterator needs to satisfy requirements for Iterator) state that they should have this conversion operator and thus this is very compiler specific and not standard.</p>\n", "OwnerUserId": "1870760", "LastEditorUserId": "1870760", "LastEditDate": "2016-11-15T12:57:34.933", "Id": "40610189", "Score": "1", "CreationDate": "2016-11-15T12:46:02.543", "LastActivityDate": "2016-11-15T12:57:34.933"}, "40610013": {"ParentId": "40609938", "CommentCount": "0", "Body": "<p>It is implementation defined: C++14 Standard \u00a7 23.3.2.1 numeral 3. Your code works on GCC, but you cannot make that assumption across compilers.</p>\n", "OwnerUserId": "870609", "PostTypeId": "2", "Id": "40610013", "Score": "0", "CreationDate": "2016-11-15T12:37:24.593", "LastActivityDate": "2016-11-15T12:37:24.593"}, "bq_ids": {"n4140": {"so_40609938_40610189_1": {"section_id": 705, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_40609938_40610189_1": {"section_id": 695, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_40609938_40610189_1": {"section_id": 734, "quality": 0.8888888888888888, "length": 8}}}, "40609938": {"CommentCount": "0", "ViewCount": "151", "PostTypeId": "1", "LastEditorUserId": "870609", "CreationDate": "2016-11-15T12:32:58.487", "LastActivityDate": "2016-11-15T13:28:17.070", "Title": "C++ - Can you assume type* = std::array<type>::iterator?", "AcceptedAnswerId": "40610189", "LastEditDate": "2016-11-15T13:28:17.070", "Id": "40609938", "Score": "3", "Body": "<p>I think it is easier to just show this in code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\nstruct Test\n{};\n\nint main()\n{\n    std::array&lt;Test, 1&gt; arr {};\n    Test* t = arr.begin();\n}\n</code></pre>\n<p>arr.begin() returns a iterator but as you can see I can refer to it with Test*. This seems to be possible due to implicit cast, can I expect this to work across other compilers as well according to the standard?</p>\n<p>Also is it the operator TYPE that does the implicit cast, ex:</p>\n<pre><code>operator T*()\n{\n    return &amp;(*this-&gt;CONTAINER)[index];\n}\n\ntemplate &lt;typename U&gt;\noperator U() = delete;\n</code></pre>\n<p>or something else?</p>\n<p>Thanks in advance</p>\n", "Tags": "<c++>", "OwnerUserId": "6433910", "AnswerCount": "3"}});