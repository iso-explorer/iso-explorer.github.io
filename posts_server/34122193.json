post_cb({"bq_ids": {"n4140": {"so_34122193_34124651_1": {"length": 43, "quality": 0.9555555555555556, "section_id": 2182}}, "n3337": {"so_34122193_34124651_1": {"length": 43, "quality": 0.9555555555555556, "section_id": 2170}}, "n4659": {"so_34122193_34124651_1": {"length": 43, "quality": 0.9555555555555556, "section_id": 2455}}}, "34124651": {"Id": "34124651", "PostTypeId": "2", "Body": "<p>The problem is that, quoting <a href=\"http://en.cppreference.com/w/cpp/io/manip/endl\" rel=\"nofollow noreferrer\">cppreference</a>:</p>\n<blockquote>\n<p id=\"so_34122193_34124651_0\">any input from std::cin, output to std::cerr, or program termination forces a call to std::cout.flush()</p>\n</blockquote>\n<p>This is easy to test: if you replace</p>\n<pre><code>cin &gt;&gt; fact_num;\n</code></pre>\n<p>with</p>\n<pre><code>scanf(\"%d\", &amp;fact_num);\n</code></pre>\n<p>and same for <code>cin &gt;&gt; num_of_inputs</code> but keep <code>cout</code> you'll get pretty much the same performance in your C++ version (or, rather IOStream version) as in C one:</p>\n<p><a href=\"https://i.stack.imgur.com/1zyQL.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/1zyQL.png\"/></a></p>\n<p>The same happens if you keep <code>cin</code> but replace</p>\n<pre><code>cout &lt;&lt; num_of_trailing_zeros &lt;&lt; \"\\n\";\n</code></pre>\n<p>with</p>\n<pre><code>printf(\"%d\", num_of_trailing_zeros);\nprintf(\"%s\",\"\\n\");\n</code></pre>\n<p>A simple solution is to untie <code>cout</code> and <code>cin</code> as mentioned by Ilya Popov:</p>\n<pre><code>cin.tie(nullptr);\n</code></pre>\n<p>Standard library implementations are allowed to omit the call to flush in certain cases, but not always. Here's a quote from C++14 27.7.2.1.3 (thanks to chqrlie):</p>\n<blockquote>\n<p id=\"so_34122193_34124651_1\">Class basic_istream::sentry : First, if is.tie() is not a null pointer, the function calls is.tie()-&gt;flush() to synchronize the output sequence with any associated external C stream. Except that this call can be suppressed if the put area of is.tie() is empty. Further an implementation is allowed to defer the call to flush until a call of is.rdbuf()-&gt;underflow() occurs. If no such call occurs before the sentry object is destroyed, the call to flush may be eliminated entirely.</p>\n</blockquote>\n", "LastEditorUserId": "471164", "LastActivityDate": "2015-12-07T15:12:46.990", "Score": "27", "CreationDate": "2015-12-07T00:29:56.950", "ParentId": "34122193", "CommentCount": "5", "OwnerUserId": "471164", "LastEditDate": "2015-12-07T15:12:46.990"}, "34122833": {"Id": "34122833", "PostTypeId": "2", "Body": "<p>Both programs do exactly the same thing.  They use the same exact algorithm, and given its low complexity, their performance is mostly bound to efficiency of the input and output handling.</p>\n<p>scanning the input with <code>scanf(\"%d\", &amp;fact_num);</code> on one side and <code>cin &gt;&gt; fact_num;</code> on the other does not seem very costly either way.  In fact it should be less costly in C++ since the type of conversion is known at compile time and the correct parser can be invoked directly by the C++ compiler.  The same holds for the output. You even make a point of writing a separate call for <code>printf(\"%s\",\"\\n\");</code>, but the C compiler is good enough to compile this as a call to <code>putchar('\\n');</code>.</p>\n<p>So looking at the complexity of both the I/O and computation, the C++ version should be faster than the C version.</p>\n<p>Completely disabling the buffering of <code>stdout</code> slows the C implementation to something even slower than the C++ version.  Another test by AlexLop with an <code>fflush(stdout);</code> after the last <code>printf</code> yields similar performance as the C++ version. It is not as slow as completely disabling buffering because output is written to the system in small chunks instead of one byte at a time.</p>\n<p>This seems to point to a specific behavior in your C++ library: I suspect your system's implementation of <code>cin</code> and <code>cout</code> flushes the output to <code>cout</code> when input is requested from <code>cin</code>. Some C libraries do this as well, but usually only when reading/writing to and from the terminal. The benchmarking done by the www.spoj.com site probably redirects input and output to and from files.</p>\n<p>AlexLop did another test: reading all the inputs at once in a vector and subsequently computing and writing all output helps understanding why the C++ version is so much slower. It increases performance to that of the C version, this proves my point and removes suspicion on the C++ formatting code.</p>\n<p>Another test by Blastfurnace, storing all outputs in an <code>std::ostringstream</code> and flushing that in one blast at the end, does improve the C++ performance to that of the basic C version. QED.</p>\n<blockquote>\n<p id=\"so_34122193_34122833_0\">Interlacing input from <code>cin</code> and output to <code>cout</code> seems to cause very inefficient I/O handling, defeating the stream buffering scheme. reducing performance by a factor of 10.</p>\n</blockquote>\n<p>PS: your algorithm is incorrect for <code>fact_num &gt;= UINT_MAX / 5</code> because <code>fives *= 5</code> will overflow and wrap around before it becomes <code>&gt; fact_num</code>.  You can correct this by making <code>fives</code> an <code>unsigned long</code> or an <code>unsigned long long</code> if one of these types is larger than <code>unsigned int</code>.  Also use <code>%u</code> as the <code>scanf</code> format.  You are lucky the guys at www.spoj.com are not too strict in their benchmarks.</p>\n<p>EDIT: As later explained by vitaux, this behavior is indeed mandated by the C++ standard.  <code>cin</code> is tied to <code>cout</code> by default.  An input operation from <code>cin</code> for which the input buffer needs refilling will cause <code>cout</code> to flush pending output.  In the OP's implementation, <code>cin</code> seems to flush <code>cout</code> systematically, which is a bit overkill and visibly inefficient.</p>\n<p>Ilya Popov provided a simple solution for this: <code>cin</code> can be untied from <code>cout</code> by casting another magical spell in addition to <code>std::ios_base::sync_with_stdio(false);</code>:</p>\n<blockquote>\n<p id=\"so_34122193_34122833_1\"><code>cin.tie(nullptr);</code></p>\n</blockquote>\n<p>Also note that such forced flush also occurs when using <code>std::endl</code> instead of <code>'\\n'</code> to produce an end of line on <code>cout</code>. Changing the output line to the more C++ idiomatic and innocent looking <code>cout &lt;&lt; num_of_trailing_zeros &lt;&lt; endl;</code> would degrade performance the same way.</p>\n", "LastEditorUserId": "4593267", "LastActivityDate": "2015-12-07T15:25:02.730", "Score": "56", "CreationDate": "2015-12-06T21:12:46.777", "ParentId": "34122193", "CommentCount": "19", "OwnerUserId": "4593267", "LastEditDate": "2015-12-07T15:25:02.730"}, "34122193": {"ViewCount": "6044", "Body": "<p>I was trying to solve this exercise  from www.spoj.com : <a href=\"http://www.spoj.com/problems/FCTRL/\" rel=\"nofollow noreferrer\">FCTRL - Factorial</a></p>\n<p>You don't really have to read it, just do it if you are curious :)</p>\n<p>First I implemented it in <strong>C++</strong> (here is my solution):</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() {\n    unsigned int num_of_inputs;\n    unsigned int fact_num;\n    unsigned int num_of_trailing_zeros;\n\n    std::ios_base::sync_with_stdio(false); // turn off synchronization with the C library\u2019s stdio buffers (from https://stackoverflow.com/a/22225421/5218277)\n\n    cin &gt;&gt; num_of_inputs;\n\n    while (num_of_inputs--)\n    {\n        cin &gt;&gt; fact_num;\n\n        num_of_trailing_zeros = 0;\n\n        for (unsigned int fives = 5; fives &lt;= fact_num; fives *= 5)\n            num_of_trailing_zeros += fact_num/fives;\n\n        cout &lt;&lt; num_of_trailing_zeros &lt;&lt; \"\\n\";\n    }\n\n    return 0;\n}\n</code></pre>\n<p>I uploaded it as the solution for <strong>g++ 5.1</strong></p>\n<p>The result was: <em>Time</em> 0.18 <em>Mem</em> 3.3M\n<a href=\"https://i.stack.imgur.com/oqpfY.jpg\" rel=\"nofollow noreferrer\"><img alt=\"C++ execution results\" src=\"https://i.stack.imgur.com/oqpfY.jpg\"/></a></p>\n<p>But then I saw some comments which claimed that their time execution was less than 0.1. Since I couldn't think about faster algorithm I tried to implement the same code in <strong>C</strong>:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    unsigned int num_of_inputs;\n    unsigned int fact_num;\n    unsigned int num_of_trailing_zeros;\n\n    scanf(\"%d\", &amp;num_of_inputs);\n\n    while (num_of_inputs--)\n    {\n        scanf(\"%d\", &amp;fact_num);\n\n        num_of_trailing_zeros = 0;\n\n        for (unsigned int fives = 5; fives &lt;= fact_num; fives *= 5)\n            num_of_trailing_zeros += fact_num/fives;\n\n        printf(\"%d\", num_of_trailing_zeros);\n        printf(\"%s\",\"\\n\");\n    }\n\n    return 0;\n}\n</code></pre>\n<p>I uploaded it as the solution for <strong>gcc 5.1</strong></p>\n<p>This time the result was: <em>Time</em> 0.02 <em>Mem</em> 2.1M\n<a href=\"https://i.stack.imgur.com/PgZLu.jpg\" rel=\"nofollow noreferrer\"><img alt=\"C execution results\" src=\"https://i.stack.imgur.com/PgZLu.jpg\"/></a></p>\n<p>Now the code is <em>almost the same</em>, I added <code>std::ios_base::sync_with_stdio(false);</code> to the C++ code as was suggested <a href=\"https://stackoverflow.com/a/22225421/5218277\">here</a> to turn off the synchronization with the C library\u2019s stdio buffers. I also split the <code>printf(\"%d\\n\", num_of_trailing_zeros);</code> to <code>printf(\"%d\", num_of_trailing_zeros); printf(\"%s\",\"\\n\");</code> to compensate for double call of <code>operator&lt;&lt;</code> in <code>cout &lt;&lt; num_of_trailing_zeros &lt;&lt; \"\\n\";</code>.</p>\n<p>But I still saw <strong>x9 better performance</strong> and lower memory usage in C vs. C++ code.</p>\n<p>Why is that?</p>\n<p><strong>EDIT</strong></p>\n<p>I fixed <code>unsigned long</code> to <code>unsigned int</code> in the C code. It should have been <code>unsigned int</code> and the results which are shown above are related to the new (<code>unsigned int</code>) version.</p>\n", "AcceptedAnswerId": "34122833", "Title": "Big difference (x9) in the execution time between almost identical code in C and C++", "CreationDate": "2015-12-06T20:16:05.030", "Id": "34122193", "CommentCount": "37", "FavoriteCount": "20", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:53:04.730", "LastEditorUserId": "-1", "LastActivityDate": "2015-12-07T15:25:02.730", "Score": "84", "OwnerUserId": "5218277", "Tags": "<c++><c><performance><gcc><iostream>", "AnswerCount": "3"}, "34124985": {"Id": "34124985", "PostTypeId": "2", "Body": "<p>Another trick to make <code>iostream</code>s faster when you use both <code>cin</code> and <code>cout</code> is to call </p>\n<pre><code>cin.tie(nullptr);\n</code></pre>\n<p>By default, when you input anything from <code>cin</code>, it flushes <code>cout</code>. It can significantly harm performance if you do interleaved input and output. This is done for the command line interface uses, where you show some prompt and then wait for data:</p>\n<pre><code>std::string name;\ncout &lt;&lt; \"Enter your name:\";\ncin &gt;&gt; name;\n</code></pre>\n<p>In this case you want to make sure the prompt is actually shown before you start waiting for input. With the line above you break that tie, <code>cin</code> and <code>cout</code> become independent. </p>\n<p>Since C++11, one more way to achieve better performance with iostreams is to use <code>std::getline</code> together with <code>std::stoi</code>, like this:</p>\n<pre><code>std::string line;\nfor (int i = 0; i &lt; n &amp;&amp; std::getline(std::cin, line); ++i)\n{\n    int x = std::stoi(line);\n}\n</code></pre>\n<p>This way can come close to C-style in performance, or even surpass <code>scanf</code>. Using <code>getchar</code> and especially <code>getchar_unlocked</code> together with handwritten parsing still provides better performance.</p>\n<p>PS. I have written <a href=\"http://habrahabr.ru/post/246257/\">a post</a> comparing several ways to input numbers in C++, useful for online judges, but it is only in Russian, sorry. The code samples and the final table, however,  should be understandable.</p>\n", "LastEditorUserId": "329564", "LastActivityDate": "2015-12-07T09:51:36.783", "Score": "44", "CreationDate": "2015-12-07T01:16:16.443", "ParentId": "34122193", "CommentCount": "1", "OwnerUserId": "4451432", "LastEditDate": "2015-12-07T09:51:36.783"}});