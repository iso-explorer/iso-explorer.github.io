post_cb({"2628388": {"ParentId": "2626533", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>there is only one entry point in the global scope.</p>\n", "OwnerUserId": "315275", "LastEditorUserId": "388614", "LastEditDate": "2013-12-23T23:21:01.923", "Id": "2628388", "Score": "0", "CreationDate": "2010-04-13T09:24:55.487", "LastActivityDate": "2013-12-23T23:21:01.923"}, "2626580": {"ParentId": "2626533", "CommentCount": "0", "Body": "<p>A program can only have one entry point, but of course that one main() function can call out to other functions, based on whatever logic you care to specify.  So if you are looking for a way to effectively compile two or more programs into a single executable, you can do something like this:</p>\n<pre><code>int main(int argc, char ** argv)\n{\n   if (argc &gt; 0)  // paranoia\n   {\n           if (strstr(argv[0], \"frogger\")) return frogger_main(argc, argv);\n      else if (strstr(argv[0], \"pacman\"))  return pacman_main(argc, argv);\n      else if (strstr(argv[0], \"tempest\")) return tempest_main(argc, argv);\n   }\n\n   printf(\"Hmm, I'm not sure what I should run.\\n\");\n   return 10;\n}\n</code></pre>\n<p>... then just rename your 'other' main() functions to frogger_main(), pacman_main(), or whatever names you care to give them, and you'll have a program that runs as Frogger if the executable name has the word 'frogger' in it, or runs as PacMan if the executable has the name 'pacman' in it, etc.</p>\n", "OwnerUserId": "131930", "PostTypeId": "2", "Id": "2626580", "Score": "3", "CreationDate": "2010-04-13T02:20:10.287", "LastActivityDate": "2010-04-13T02:20:10.287"}, "2626616": {"ParentId": "2626533", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The standard explicitly says in 3.6.1:</p>\n<blockquote>\n<p id=\"so_2626533_2626616_0\">A program shall contain a global function called main, which is the designated start of the program. [...] <em>This function shall not be overloaded.</em></p>\n</blockquote>\n<p>So there can one only be one one <code>main</code> function in the global scope in a program. Functions in other scopes that are also called <code>main</code> are not affected by this, there can be any number of them.</p>\n", "OwnerUserId": "56338", "LastEditorUserId": "56338", "LastEditDate": "2010-04-13T02:38:43.717", "Id": "2626616", "Score": "19", "CreationDate": "2010-04-13T02:32:54.103", "LastActivityDate": "2010-04-13T02:38:43.717"}, "2626543": {"ParentId": "2626533", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Only one function can be named <code>main</code> outside of any namespace, just as for any other name.  If you have namespaces <code>foo</code> and <code>bar</code> (etc) you can perfectly well have functions named <code>foo::main</code>, <code>bar::main</code>, and so on, but they won't be treated as anything special from the system's point of view (only the function named <code>main</code> outside of any namespace is treated specially, as the program's entry point).  Of course, from your <code>main</code> you could perfectly well call the various <code>foo::main</code>, <code>bar::main</code>, and so on.</p>\n", "OwnerUserId": "95810", "LastEditorUserId": "56338", "LastEditDate": "2010-04-13T02:14:08.257", "Id": "2626543", "Score": "11", "CreationDate": "2010-04-13T02:07:58.910", "LastActivityDate": "2010-04-13T02:14:08.257"}, "2626549": {"ParentId": "2626533", "CommentCount": "0", "Body": "<p>Yes! Why not?</p>\n<p>Consider the following code:</p>\n<pre><code> namespace ps\n {\n     int main(){return 0;}\n }\n\n int main()\n {\n     ps::main();\n }\n</code></pre>\n<p>Its <code>::main()</code> that will be called during execution.</p>\n", "OwnerUserId": "165520", "PostTypeId": "2", "Id": "2626549", "Score": "8", "CreationDate": "2010-04-13T02:09:05.337", "LastActivityDate": "2010-04-13T02:09:05.337"}, "2626606": {"ParentId": "2626533", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Ooh, trick question!</p>\n<p>Short answer: \"It depends.\"</p>\n<p>Long answer: As others have pointed out, you can have multiple functions named <code>main</code> so long as they are in different namespaces, and only the <code>main</code> in the root namespace (i.e. <code>::main</code>) is used as the main program.  In fact, some threading libraries' thread classes have a method named <code>main</code> that the library user overrides with the code they want run in the thread.</p>\n<p>Now, assuming you're not doing any namespace tricks, if you try to define <code>::main</code> in two different <code>.cpp</code> files, the files themselves will both compile, however, the linker will abort since there are two definitions named <code>main</code>; it can't tell which to link.</p>\n<p>(A question I have for the gurus out there: in C++, do the function definitions <code>int main() {}</code> and <code>extern \"C\" int main() {}</code> generate functions with the same signature?  I haven't tried it myself.)</p>\n<p>And now for the time <strong>you can have more than one <code>::main</code> in your program's source</strong>: if one <code>main</code> is in a library (.a or .so file), and another is in your source (.o) files, the one in your sources wins and the one in the library is dropped, <em>and linking succeeds</em> unless there's some other problem!  If you <em>didn't</em> write a <code>main</code>, the library's <code>main</code> would win.  This is actually done in the support libraries that ship with <code>lex</code> and <code>yacc</code>; they provide a barebones <code>main</code> so you don't have to write one for a quick parser.</p>\n<p>Which leads to an interesting application: providing a <code>main</code> with every library.  My libraries tend to be small and focused, and so I put a <code>main.cpp</code> in every one with a <code>main</code> that is test or utility code for the library.  For example, my shared memory library has a <code>main</code> that allows all the functions for managing shared memory to be called from the command line.  Then I can test a variety of cases with a <code>bash</code> script.  Anything that links in the shared memory library gets the test code for free, or can dispose of it simply by defining their own <code>main</code>.</p>\n<p>EDIT: Just to make sure folks are clear on the concept, I'm talking about a build that looks like:</p>\n<pre><code>gcc -c -o bar_main.o bar_main.cpp\nar -r libbar.a bar_main.o\nranlib libbar.a\ngcc -c -o foo_main.o foo_main.cpp\ngcc -o foo foo_main.o -L. -lbar\n</code></pre>\n<p>In this example, the <code>main</code> in <code>foo_main.o</code> beats the <code>main</code> in <code>bar_main.o</code>.  The standard doesn't define this behavior because they don't care.  There's a lot of nonstandard things that people use anyway; Linux is an example with its use of C bitfields.  <code>ld</code> has worked this way longer than I've known how to type.</p>\n<p>Seriously, guys, feel free to strictly adhere to standards if you need to turn out least-common-denominator code.  But if you have the luxury of working on a platform that can build <code>lex</code> and <code>yacc</code> programs, by all means, consider taking advantage of it.</p>\n", "OwnerUserId": "2624511", "LastEditorUserId": "2624511", "LastEditDate": "2010-04-13T03:21:34.560", "Id": "2626606", "Score": "1", "CreationDate": "2010-04-13T02:30:09.867", "LastActivityDate": "2010-04-13T03:21:34.560"}, "2626544": {"ParentId": "2626533", "CommentCount": "0", "Body": "<p>You can't overload main() in the global scope.</p>\n", "OwnerUserId": "3153", "PostTypeId": "2", "Id": "2626544", "Score": "4", "CreationDate": "2010-04-13T02:08:12.853", "LastActivityDate": "2010-04-13T02:08:12.853"}, "2626533": {"CommentCount": "3", "AcceptedAnswerId": "2626616", "PostTypeId": "1", "LastEditorUserId": "165520", "CreationDate": "2010-04-13T02:05:36.870", "LastActivityDate": "2013-12-23T23:21:01.923", "LastEditDate": "2010-04-13T02:13:44.327", "ViewCount": "4253", "FavoriteCount": "1", "Title": "Two main functions", "Id": "2626533", "Score": "6", "Body": "<p>Can we have two <code>main()</code> functions in a C++ program?</p>\n", "Tags": "<c++><main>", "OwnerUserId": "165520", "AnswerCount": "8"}, "2626539": {"ParentId": "2626533", "CommentCount": "0", "Body": "<p>In one single program, only one entry point is allowed.</p>\n", "OwnerUserId": "304319", "PostTypeId": "2", "Id": "2626539", "Score": "2", "CreationDate": "2010-04-13T02:06:43.817", "LastActivityDate": "2010-04-13T02:06:43.817"}, "bq_ids": {"n4140": {"so_2626533_2626616_0": {"section_id": 7145, "quality": 0.8, "length": 8}}, "n3337": {"so_2626533_2626616_0": {"section_id": 6889, "quality": 0.8, "length": 8}}, "n4659": {"so_2626533_2626616_0": {"section_id": 8646, "quality": 0.6, "length": 6}}}});