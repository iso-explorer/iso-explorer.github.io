post_cb({"bq_ids": {"n4140": {"so_16357681_16357708_0": {"length": 5, "quality": 1.0, "section_id": 5962}}, "n3337": {"so_16357681_16357708_0": {"length": 5, "quality": 1.0, "section_id": 5731}}, "n4659": {"so_16357681_16357708_0": {"length": 5, "quality": 1.0, "section_id": 7451}}}, "16357681": {"ViewCount": "1316", "Body": "<p>Consider the following function which is returning a lambda:</p>\n<pre><code>std::function&lt;int()&gt; make_counter()\n{\n    int i = 0;\n    return [=]() mutable { return i++; };\n}\n</code></pre>\n<p>Is it possible to return the actual lambda type, without wrapping it into a <code>std::function</code>?</p>\n", "AcceptedAnswerId": "16357708", "Title": "returning a lambda without std::function", "CreationDate": "2013-05-03T11:16:21.770", "Id": "16357681", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-05-03T11:39:08.793", "Score": "13", "OwnerUserId": "252000", "Tags": "<c++><c++11><lambda><return-type><higher-order-functions>", "AnswerCount": "2"}, "16357708": {"Id": "16357708", "PostTypeId": "2", "Body": "<p>C++11: No. Every lambda expression has, I quote (\u00a75.1.2/3):</p>\n<blockquote>\n<p id=\"so_16357681_16357708_0\">[...] a <strong>unique</strong>, unnamed non-union class type [...]</p>\n</blockquote>\n<p>This effectively means that you can't know the lambda's type without knowing the corresponding expression first.</p>\n<p>Now, if you didn't capture anything, you could use the conversion to function pointer and return that (a function pointer type), but that's pretty limiting.</p>\n<p>As @Luc noted in the Lounge, if you're willing to replace your <code>make_counter</code> (and if it isn't a template, or overloaded, or something), the following would work:</p>\n<pre><code>auto const make_counter = [](int i = 0) {\n  return [i]() mutable { return i++; };\n};\n</code></pre>\n<hr>\n<p>C++1y: Yes, through return-type deduction for normal functions (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3582.html\" rel=\"noreferrer\">N3582</a>).</p>\n</hr>", "LastEditorUserId": "500104", "LastActivityDate": "2013-05-03T11:39:08.793", "Score": "18", "CreationDate": "2013-05-03T11:18:08.243", "ParentId": "16357681", "CommentCount": "4", "OwnerUserId": "500104", "LastEditDate": "2013-05-03T11:39:08.793"}, "16357764": {"Id": "16357764", "PostTypeId": "2", "Body": "<p>If you cheat and use return type deduction, <a href=\"http://coliru.stacked-crooked.com/view?id=87c1b7f4deaf36b1749bac254cf466bd-a2574bcf90a5184e7a985df72132c580\">yes you can (Link)</a>.</p>\n<p>Note this is only possible beyond C++11 itself, though it can be accomplished in regular, non-warning-inducing C++11 using lambdas (that is, a lambda inside of a lambda that returns that lamba).</p>\n", "LastEditorDisplayName": "user1357649", "OwnerDisplayName": "user1357649", "LastActivityDate": "2013-05-03T11:24:38.410", "Score": "10", "CreationDate": "2013-05-03T11:21:09.833", "ParentId": "16357681", "CommentCount": "4", "LastEditDate": "2013-05-03T11:24:38.410"}});