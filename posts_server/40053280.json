post_cb({"40053280": {"CommentCount": "0", "ViewCount": "146", "CreationDate": "2016-10-14T23:16:23.857", "LastActivityDate": "2016-10-14T23:36:20.500", "Title": "Template argument deduction for class templates and multiple parameters packs", "AcceptedAnswerId": "40053432", "PostTypeId": "1", "Id": "40053280", "Score": "3", "Body": "<p>In C++17 template arguments for a class template will be deduced more or less as it happens nowadays for a function template.<br>\n<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0091r2.html\" rel=\"nofollow\">Here</a> is the relevant paper.</br></p>\n<p>As an example from the above mentioned paper:</p>\n<pre><code>template&lt;class ... Ts&gt; struct X { X(Ts...) };\nX x1{1}; // OK X&lt;int&gt;\nX x11; // OK X&lt;&gt;\n</code></pre>\n<p>Function templates have another interesting feature when deduction happens.<br>\nConsider the following code:</br></p>\n<pre><code>template&lt;typename... U, typename... T&gt;\nauto func(T&amp;&amp;...) {}\n\n// ...\n\n// U is int, char - T is int, double\nfunc&lt;int, char&gt;(0, .0);\n</code></pre>\n<p>We can have two parameters packs as long as deduction helps to discriminate between them.<br>\nNo need to wrap them within a tuple or some other structure.</br></p>\n<p><strong>Will it be possible to do the same with class templates?</strong></p>\n<p>As an example:</p>\n<pre><code>template&lt;typename... U, typename... T&gt;\nstruct S {\n    S(T&amp;&amp;...) {}\n};\n\n// ...\n\n// U is int, char - T is int, double\nS&lt;int, char&gt; s{0, .0};\n</code></pre>\n<p>The paper contains the example below:</p>\n<pre><code>template&lt;class ... Ts&gt; struct X { X(Ts...) };\nX&lt;int&gt; x3{1, 'a', \"bc\"}; // OK X&lt;int,char,const char*&gt;\n</code></pre>\n<p>Anyway, it isn't exactly the same thing and I'm not sure if it will be allowed or not.</p>\n", "Tags": "<c++><templates><variadic-templates><c++1z>", "OwnerUserId": "4987285", "AnswerCount": "1"}, "40053432": {"ParentId": "40053280", "CommentCount": "1", "Body": "<p>This:</p>\n<pre><code>template&lt;typename... U, typename... T&gt;\nstruct S { ... };\n</code></pre>\n<p>is just ill-formed per [temp.param]:</p>\n<blockquote>\n<p id=\"so_40053280_40053432_0\">If a <em>template-parameter</em> of a primary class template, primary variable template, or alias template is a template parameter pack, it shall be the last <em>template-parameter</em>.</p>\n</blockquote>\n<p>This case:</p>\n<pre><code>template&lt;class ... Ts&gt; struct X { X(Ts...) };\nX&lt;int&gt; x3{1, 'a', \"bc\"}; // OK X&lt;int,char,const char*&gt;\n</code></pre>\n<p>is problematic since <code>X&lt;int&gt;</code> is already a valid type. This part of the paper was dropped in Oulu, though it's possible some proposal in the future will make it possible to indicate that some of the class template parameters should be deduced but others should be specified:</p>\n<pre><code>X&lt;string, ???&gt; x3{\"a\", 1, \"b\"}; // X&lt;string, int, const char*&gt;.\n</code></pre>\n<p>where <code>???</code> is some series of tokens that makes intent clear. </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "40053432", "Score": "4", "CreationDate": "2016-10-14T23:36:20.500", "LastActivityDate": "2016-10-14T23:36:20.500"}, "bq_ids": {"n4140": {"so_40053280_40053432_0": {"section_id": 64, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_40053280_40053432_0": {"section_id": 59, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_40053280_40053432_0": {"section_id": 66, "quality": 1.0, "length": 14}}}});