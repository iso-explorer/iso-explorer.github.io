post_cb({"31498920": {"ParentId": "31498758", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Placement deallocation function is called to clean up when the constructor invocation throws during a <code>new</code>-expression evaluation. At this point the information that was passed to the placement allocation is still available, and can be passed again to the deallocation function. At some later point, after a successful <code>new</code>-expression, that information isn't available, so the ordinary deallocation function is used by a <code>delete</code> statement.</p>\n<hr>\n<p>Essentially, if the deallocation depends on information passed to a placement allocation function, then user code is responsible for retaining that information for a successfully created object. An alternative could have been to specify how the C++ implementation would retain it, so that it could comply with whatever restrictions that implied. But that would introduce complexity and would violate the don't-pay-for-what-you-don't-use design principle of C++.</p>\n<hr>\n<p>Microsoft's MFC class framework once had a bug where they forgot to supply a placement deallocation function to match the placement allocation function they used in their debug <code>new</code>, resulting in memory leaks only in debug builds. Silly.</p>\n</hr></hr>", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2015-07-19T07:31:23.057", "Id": "31498920", "Score": "5", "CreationDate": "2015-07-19T07:25:50.633", "LastActivityDate": "2015-07-19T07:31:23.057"}, "31498758": {"CommentCount": "0", "ViewCount": "66", "CreationDate": "2015-07-19T06:58:30.103", "LastActivityDate": "2015-07-19T07:31:23.057", "Title": "What the placement deallocation functions were introduced for?", "AcceptedAnswerId": "31498920", "PostTypeId": "1", "Id": "31498758", "Score": "0", "Body": "<p>The section <code>12.5/4 [class.free]</code>:</p>\n<blockquote>\n<p id=\"so_31498758_31498758_0\">If the result of the lookup is ambiguous or inaccessible, or if the\n  lookup selects a placement deallocation function, the program is\n  ill-formed.</p>\n</blockquote>\n<p>So, for example if we write:</p>\n<pre><code>class A\n{\npublic:\n    void* operator new  ( std::size_t count, std::size_t msg, std::size_t mmsg );\n    void operator delete  ( void* ptr, std::size_t msg, std::size_t mmsg );\n};\n\nvoid* A::operator new  ( std::size_t sz, std::size_t msg, std::size_t mmsg ){\n    std::printf(\"global op new called, message = %lu, %lu\", msg, mmsg);\n    return std::malloc(sz);\n}\n\nvoid A::operator delete  ( void* ptr, std::size_t msg, std::size_t mmsg ){\n    std::printf(\"global op new called, message = %lu, %lu\", msg, mmsg);\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/7b8016d03b28d15b\" rel=\"nofollow\">live example</a> </p>\n<p>The placement deallocation function will never called as a part of the evaluation of delete expression. So it's reasonable to ask what they were introduced for. We can call them only through the manual call to the <code>operator[](void*, std::size_t, std::size_t)</code> whic is not convinient.</p>\n", "Tags": "<c++><class>", "OwnerUserId": "4671213", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31498758_31498758_0": {"section_id": 408, "quality": 1.0, "length": 10}}, "n3337": {"so_31498758_31498758_0": {"section_id": 399, "quality": 1.0, "length": 10}}, "n4659": {"so_31498758_31498758_0": {"section_id": 434, "quality": 1.0, "length": 10}}}});