post_cb({"bq_ids": {"n4140": {"so_12336511_14385036_0": {"length": 5, "quality": 0.625, "section_id": 5986}}, "n3337": {"so_12336511_14385036_0": {"length": 5, "quality": 0.625, "section_id": 5754}}, "n4659": {"so_12336511_14385036_0": {"length": 5, "quality": 0.625, "section_id": 7486}}}, "12336638": {"Id": "12336638", "PostTypeId": "2", "Body": "<p>In C/C++, you can either subscript a pointer with an integral index, or subscript an integral index with a pointer, and the meaning (semantics) are exactly the same. I don't know offhand why the heck the insane syntax is valid, but so it is, and apparently so it will remain for ever after.</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main(int argc, char** argv)\n{\n  int i = 1, array[10];\n  printf(\"%ld\\n\", &amp;(i[array])-&amp;(array[i]));\n  return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>0\n</code></pre>\n", "LastActivityDate": "2012-09-09T05:02:57.060", "Score": "0", "CreationDate": "2012-09-09T05:02:57.060", "ParentId": "12336511", "CommentCount": "0", "OwnerUserId": "1329652"}, "12336524": {"Id": "12336524", "PostTypeId": "2", "Body": "<p>C arrays have a strange quirk that allows them to be accessed through the \"opposite\" direction. This is deeply rooted in the pointer arithmetic of arrays. For example, <code>a[1]</code> is equivalent to <code>*(a + 1)</code>. Likewise, <code>1[a]</code> is equivalent to <code>*(1 + a)</code>. Due to the commutative nature of addition, this works out quite nicely. More details can be found <a href=\"https://stackoverflow.com/questions/381542/with-c-arrays-why-is-it-the-case-that-a5-5a?lq=1\">here</a>.</p>\n<p>With that knowledge in tact, the expression <code>i[j[a]]</code> can be broken down into two different parts. <code>j[a]</code> is equivalent to <code>*(j + a)</code> which would return another array due to the multi-dimensional nature of the array you have, for example purposes we'll call this returned array <code>p</code>. Then you have the statement <code>i[p]</code> which would be equivalent to <code>*(i + p)</code>. Bringing it back all together would show you that <code>i[j[a]]</code> is equivalent to <code>*(i + *(j + a))</code>. Indeed, this means that <code>i[j[a]]</code> is just an obfuscated way of writing <code>a[j][i]</code>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-12-17T23:52:54.127", "Score": "1", "CreationDate": "2012-09-09T04:29:29.420", "ParentId": "12336511", "CommentCount": "7", "LastEditDate": "2017-05-23T12:27:15.830", "OwnerUserId": "1381108"}, "14385036": {"Id": "14385036", "PostTypeId": "2", "Body": "<pre><code>cout &lt;&lt; i[j[a]];\ncout &lt;&lt; j[i[a]];\n</code></pre>\n<p>In C++, the <code>X[Y]</code> notation is <em>lexically</em> equivalent to <code>*(X+Y)</code>:</p>\n<blockquote>\n<p id=\"so_12336511_14385036_0\"><code>[C++11: 5.2.1/1]:</code> <em>[..]</em> The expression <code>E1[E2]</code> is identical (by definition) to <code>*((E1)+(E2))</code> <em>[..]</em></p>\n</blockquote>\n<p>That means that <code>Y[X]</code> is equivalent to <code>*(Y+X)</code>, which is the same as <code>*(X+Y)</code> since <a href=\"http://en.wikipedia.org/wiki/Commutativity\" rel=\"nofollow\">addition is commutative</a>.</p>\n<p>For some reason, the author has decided to try to be \"clever\" by writing this confusing code.</p>\n<p>By commutativity and the definition for <code>X[Y]</code> alone:</p>\n<pre><code>i[j[a]] =&gt; i[*(j+a)] =&gt; *(i+*(j+a)) =&gt; *(*(a+j)+i) =&gt; *(a[j] + i) =&gt; a[j][i]\nj[i[a]] =&gt; j[*(i+a)] =&gt; *(j+*(i+a)) =&gt; *(*(a+i)+j) =&gt; *(a[i] + j) =&gt; a[i][j]\n</code></pre>\n<p>Your <code>cout</code> statements are, then, equivalent to:</p>\n<pre><code>cout &lt;&lt; a[j][i];\ncout &lt;&lt; a[i][j];\n</code></pre>\n<p>In any case, the loop attempts to read past the array bounds because there are only <code>5</code> integers in each element of the array <code>a</code>, whereas your inner loop attempts to go all the way up to <code>10</code>.</p>\n<p>The practical result of this is undefined, so you could get silent success, silent failure, arbitrary values, a segmentation fault, a power cut, a black hole, a pony for Christmas, a toe amputation or a new bike.</p>\n<p>Even when the loop condition is fixed, note that the first statement is semantically incorrect (assuming you continue to ascribe the first dimension to the outer loop and the second dimension to the inner loop).</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2013-01-17T17:52:40.763", "Score": "1", "CreationDate": "2013-01-17T17:47:37.747", "ParentId": "12336511", "CommentCount": "1", "LastEditDate": "2013-01-17T17:52:40.763", "OwnerUserId": "560648"}, "12336511": {"ViewCount": "134", "Body": "<pre><code>int a[10][5];\nfor (int i = 0; i &lt; 10; i++)\n{\n    for (int j = 0; j &lt; 10; j++)\n    {\n        cout &lt;&lt; i[j[a]];\n        cout &lt;&lt; j[i[a]];\n    }\n}  \n</code></pre>\n<p><em>Edit</em>:assume the values are already initialized to the array and is this cout valid then? </p>\n<p>please explain the <code>i[j[a]];</code> part only regardless of the program I'm concerned about that statement only!</p>\n", "AcceptedAnswerId": "12336524", "Title": "how will this cout statement run", "CreationDate": "2012-09-09T04:26:43.327", "Id": "12336511", "CommentCount": "5", "LastEditDate": "2012-09-14T08:45:15.287", "PostTypeId": "1", "LastEditorUserId": "1490355", "LastActivityDate": "2014-12-17T23:52:54.127", "Score": "0", "OwnerUserId": "1657633", "Tags": "<c++>", "AnswerCount": "3"}});