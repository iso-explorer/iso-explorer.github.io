post_cb({"bq_ids": {"n4140": {"so_28956250_28956470_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 5444}, "so_28956250_28956250_0": {"length": 16, "quality": 1.0, "section_id": 103}}, "n3337": {"so_28956250_28956470_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 5239}, "so_28956250_28956250_0": {"length": 16, "quality": 1.0, "section_id": 98}}, "n4659": {"so_28956250_28956470_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 6871}, "so_28956250_28956250_0": {"length": 16, "quality": 1.0, "section_id": 107}}}, "28956250": {"ViewCount": "58", "Body": "<p>The following quote is from <code>14.5.1/4 [temp.class]</code>:</p>\n<blockquote>\n<p id=\"so_28956250_28956250_0\">In a redeclaration, partial specialization, explicit specialization or\n  explicit instantiation of a class template, the <em>class-key</em> shall agree\n  in kind with the original class template declaration</p>\n</blockquote>\n<p>I thought it meant that we cannot declare an explicit specialization with another class key, for instance:</p>\n<pre><code>template &lt;class T, class W&gt;\nstruct A\n{\n    void foo();\n};\n\ntemplate &lt;class T, class W&gt;\nclass A&lt;T*, W&gt;                 // Should have printed an error\n{\n    void foo();\n};\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/8249583cfcd03b6f\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>But it works fine. So what's the point of that rule?</p>\n", "AcceptedAnswerId": "28956470", "Title": "Redeclared class name class-key", "CreationDate": "2015-03-10T04:35:22.667", "Id": "28956250", "CommentCount": "5", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "LastActivityDate": "2015-03-10T04:59:39.693", "Score": "2", "Tags": "<c++><templates>", "AnswerCount": "1"}, "28956470": {"Id": "28956470", "PostTypeId": "2", "Body": "<p>Right after the quoted sentence is a reference to [dcl.type.elab]. [dcl.type.elab]/p3 describes what \"agree in kind\" means:</p>\n<blockquote>\n<p id=\"so_28956250_28956470_0\">The <em>class-key</em> or <code>enum</code> keyword present in the\n  <em>elaborated-type-specifier</em> shall agree in kind with the declaration to which the name in the <em>elaborated-type-specifier</em> refers.  [...]\n  Thus, in any <em>elaborated-type-specifier</em>, the <code>enum</code> keyword shall be\n  used to refer to an enumeration (7.2), the <code>union</code> <em>class-key</em> shall\n  be used to refer to a union (Clause 9), and either the <code>class</code> or\n  <code>struct</code> <em>class-key</em> shall be used to refer to a class (Clause 9)\n  declared using the <code>class</code> or <code>struct</code> <em>class-key</em>.</p>\n</blockquote>\n<p>In other words, if the primary template is a union, the \"redeclaration, partial specialization, explicit specialization or explicit instantiation\" must use <code>union</code>; otherwise it can use either <code>class</code> or <code>struct</code>, but not <code>union</code>. </p>\n", "LastActivityDate": "2015-03-10T04:59:39.693", "Score": "2", "CreationDate": "2015-03-10T04:59:39.693", "ParentId": "28956250", "CommentCount": "8", "OwnerUserId": "2756719"}});