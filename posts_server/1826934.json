post_cb({"1827394": {"LastActivityDate": "2009-12-01T16:39:38.003", "ParentId": "1826934", "Id": "1827394", "Score": "5", "Body": "<p>The applicable parts of the standard here are \u00a78.5.3/5, which covers initialization of references and \u00a73.10/6, which tells what's an rvalue and what's an lvalue (not always obvious in C++).</p>\n<p>In this case, you initialization expression is: \"N(1)\", so you're explicitly creating an object using functional notation. According to 3.10/6, that expression is an rvalue.</p>\n<p>Then we have to walk through the rules in 8.5.3/5 in order, and use the first that applies. The first possibility is if the expression represents an lvalue, or can be implicitly converted to an lvalue. Your expression is an rvalue, and implicit conversion to an lvalue would require a conversion function that returns a reference, which doesn't seem to exist in this case, so that doesn't seem to apply.</p>\n<p>The next rule says the reference must be to a const T (which is the case here). In this case, the expression is an rvalue of class type and is reference-compatible with the reference (i.e. the reference is to the same class, or a base of the class). That means the bullet at the bottom of page 151 (179 of the C++ 2003 PDF) seems to apply. In this case, the compiler is allowed to either bind the reference directly to the object representing the rvalue, OR create a temporary copy of the rvalue, and bind to that temporary copy.</p>\n<p>Either way, however, the standard explicitly requires that: \"The constructor that would be used to make the copy shall be callable whether or not the copy is actually done.\"</p>\n<p>As such, I <em>believe</em> that gcc is right to give an error message, and the others are technically wrong to accept the code. I simplified your code a bit to the following:</p>\n<pre><code>class N {\n    public:\n        N(int)  {}\n    private:\n        N(N const&amp;);\n};\n\nvoid plop(N const&amp; data) { }\n\nint main() {\n    plop(N(1));\n}\n</code></pre>\n<p>When invoked with \"--A\" (strict errors mode), Comeau gives the following error message:</p>\n<pre><code>\"plop.cpp\", line 12: error: \"N::N(const N &amp;)\", required for copy that was\n          eliminated, is inaccessible\n      plop(N(1));\n           ^\n</code></pre>\n<p>Likewise, when invoked with \"/Za\" (its \"ANSI conforming\" mode), VC++ 9 gives:</p>\n<pre><code>plop.cpp\nplop.cpp(12) : error C2248: 'N::N' : cannot access private member declared in class 'N'\n        plop.cpp(6) : see declaration of 'N::N'\n        plop.cpp(2) : see declaration of 'N'\n        while checking that elided copy-constructor 'N::N(const N &amp;)' is callable\n        plop.cpp(6) : see declaration of 'N::N'\n        when converting from 'N' to 'const N &amp;'\n</code></pre>\n<p>My guess is that most of the other compilers do roughly the same. Since they optimize out the call to the copy constructor, they don't normally require that it exist or be accessible. When you ask them to conform to the standard as accurately as they can, they give the error message, because it's technically required even though they don't use it.</p>\n", "CommentCount": "2", "PostTypeId": "2", "OwnerUserId": "179910", "CreationDate": "2009-12-01T16:39:38.003"}, "1827049": {"LastActivityDate": "2009-12-01T16:11:53.860", "LastEditorUserId": "19100", "ParentId": "1826934", "LastEditDate": "2009-12-01T16:11:53.860", "Id": "1827049", "Score": "15", "Body": "<p>From <a href=\"http://gcc.gnu.org/gcc-3.4/changes.html\" rel=\"noreferrer\">http://gcc.gnu.org/gcc-3.4/changes.html</a></p>\n<blockquote>\n<p id=\"so_1826934_1827049_0\">When binding an rvalue of class type\n  to a reference, the copy constructor\n  of the class must be accessible. For\n  instance, consider the following code:</p>\n</blockquote>\n<pre><code>class A \n{\npublic:\n  A();\n\nprivate:\n  A(const A&amp;);   // private copy ctor\n};\n\nA makeA(void);\nvoid foo(const A&amp;);\n\nvoid bar(void)\n{\n  foo(A());       // error, copy ctor is not accessible\n  foo(makeA());   // error, copy ctor is not accessible\n\n  A a1;\n  foo(a1);        // OK, a1 is a lvalue\n}\n</code></pre>\n<blockquote>\n<p id=\"so_1826934_1827049_1\">This might be surprising at first\n  sight, especially since most popular\n  compilers do not correctly implement\n  this rule (<a href=\"http://gcc.gnu.org/bugs/#cxx_rvalbind\" rel=\"noreferrer\">further details</a>).</p>\n</blockquote>\n<p>This will be fixed in C++1x by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#391\" rel=\"noreferrer\">Core Issue 391</a>.</p>\n", "CommentCount": "1", "PostTypeId": "2", "OwnerUserId": "19100", "CreationDate": "2009-12-01T15:48:38.577"}, "1826934": {"ViewCount": "2932", "AcceptedAnswerId": "1827049", "Tags": "<c++><copy-constructor>", "AnswerCount": "2", "OwnerUserId": "14065", "Body": "<p>The following code only works when the copy constructor is available.  </p>\n<p>When I add print statements (via <code>std::cout</code>) and make the copy constructor available it is not used (I assume there is so compiler trick happening to remove the unnecessary copy).  </p>\n<p>But in both the output <code>operator &lt;&lt;</code> and the function <code>plop()</code> below (where I create a temporary object) I don't see the need for the copy constructor. Can somebody explain why the language needs it when I am passing everything by const reference (or what I am doing wrong).</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass N\n{\n    public:\n        N(int)  {}\n    private:\n        N(N const&amp;);\n};\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; str,N const&amp; data)\n{\n    return str &lt;&lt; \"N\\n\";\n}\n\nvoid plop(std::ostream&amp; str,N const&amp; data)\n{\n    str &lt;&lt; \"N\\n\";\n}\n\nint main()\n{\n    std::cout &lt;&lt; N(1);     // Needs copy constructor  (line 25)\n    plop(std::cout,N(1));  // Needs copy constructor\n\n    N    a(5);\n    std::cout &lt;&lt; a;\n    plop(std::cout,a);\n}\n</code></pre>\n<p>Compiler:</p>\n<blockquote>\n<p id=\"so_1826934_1826934_0\">[Alpha:~/X] myork% g++ -v<br>\n  Using built-in specs.<br>\n  Target: i686-apple-darwin10<br>\n  Configured with: /var/tmp/gcc/gcc-5646~6/src/configure --disable-checking --enable-werror --prefix=/usr --mandir=/share/man --enable-languages=c,objc,c++,obj-c++ --program-transform-name=/^[cg][^.-]*$/s/$/-4.2/ --with-slibdir=/usr/lib --build=i686-apple-darwin10 --with-gxx-include-dir=/include/c++/4.2.1 --program-prefix=i686-apple-darwin10- --host=x86_64-apple-darwin10 --target=i686-apple-darwin10<br>\n  Thread model: posix<br>\n  gcc version 4.2.1 (Apple Inc. build 5646)</br></br></br></br></br></p>\n<p id=\"so_1826934_1826934_1\">[Alpha:~/X] myork% g++ t.cpp<br>\n  t.cpp: In function \u2018int main()\u2019:<br>\n  t.cpp:10: error: \u2018N::N(const N&amp;)\u2019 is private<br>\n  t.cpp:25: error: within this context<br>\n  t.cpp:10: error: \u2018N::N(const N&amp;)\u2019 is private<br>\n  t.cpp:26: error: within this context  </br></br></br></br></br></p>\n</blockquote>\n<p>This is a simplified version of some real code.<br>\nIn the real code I have a class that contains a std::auto_ptr. This means that a copy constructor that takes a const reference is not valid (without some work) and I was getting an error indicating that the copy constructor was not available because of it:  </br></p>\n<p>Change the class too:</p>\n<pre><code>class N\n{\n    public:\n        N(int)  {}\n    private:\n        std::auto_ptr&lt;int&gt;  data;\n};\n</code></pre>\n<p>The error is then:</p>\n<blockquote>\n<p id=\"so_1826934_1826934_2\">t.cpp:25: error: no matching function for call to \u2018N::N(N)\u2019</p>\n</blockquote>\n", "CommentCount": "9", "PostTypeId": "1", "CreationDate": "2009-12-01T15:30:37.907", "FavoriteCount": "4", "LastActivityDate": "2009-12-01T16:39:38.003", "Id": "1826934", "LastEditorUserId": "14065", "Title": "Copy Constructor Needed with temp object", "Score": "10", "LastEditDate": "2009-12-01T15:51:40.907"}, "bq_ids": {"n3337": {"so_1826934_1827049_0": {"section_id": 472, "quality": 0.5333333333333333, "length": 8}}}});