post_cb({"bq_ids": {"n4140": {"so_32427433_32428111_2": {"length": 29, "quality": 0.9666666666666667, "section_id": 6030}, "so_32427433_32428111_1": {"length": 31, "quality": 0.9117647058823529, "section_id": 3296}, "so_32427433_32428111_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 389}}, "n3337": {"so_32427433_32428111_2": {"length": 29, "quality": 0.9666666666666667, "section_id": 5798}, "so_32427433_32428111_1": {"length": 31, "quality": 0.9117647058823529, "section_id": 3166}, "so_32427433_32428111_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 380}}, "n4659": {"so_32427433_32428111_1": {"length": 23, "quality": 0.6764705882352942, "section_id": 4058}, "so_32427433_32428111_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 406}}}, "32428111": {"Id": "32428111", "PostTypeId": "2", "Body": "<p>\u00a7 12.3.1 [class.conv.ctor]/p2:</p>\n<blockquote>\n<p id=\"so_32427433_32428111_0\">An explicit constructor constructs objects just like non-explicit constructors, but does so only where the\n  direct-initialization syntax (8.5) or where casts (5.2.9, 5.4) are explicitly used.</p>\n</blockquote>\n<p>Example 1:</p>\n<pre><code>CL cl2 = 5;\n</code></pre>\n<p>\u00a7 8.5 [dcl.init]/p17:</p>\n<blockquote>\n<p id=\"so_32427433_32428111_1\">The function selected is called with the initializer expression as its\n  argument; if the function is a constructor, the call initializes a temporary of the cv-unqualified\n  version of the destination type. The temporary is a prvalue. The result of the call (which is the\n  temporary for the constructor case) <strong>is then used to direct-initialize</strong>, according to the rules above,\n  the object that is the destination of the copy-initialization.</p>\n</blockquote>\n<p>In direct-initialization, <code>explicit</code> constructors can be considered, so the error is not expected. GCC trunk already compiles this example <a href=\"http://melpon.org/wandbox/permlink/lZOTnSDH0rHdeTdw\" rel=\"nofollow\">successfully</a>. This was <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54521\" rel=\"nofollow\">bug 54521</a>. </p>\n<hr>\n<p>Example 2:</p>\n<pre><code>CL cl3 = (CL)5;\n</code></pre>\n<p>In this case, that cast syntax performs a <code>static_cast</code>:</p>\n<p>\u00a7 5.2.9 [expr.static.cast]/p4:</p>\n<blockquote>\n<p id=\"so_32427433_32428111_2\">An expression <code>e</code> can be explicitly converted to a type <code>T</code> using a <code>static_cast</code> of the form <code>static_cast&lt;T&gt;(e)</code>\n  if the declaration <code>T t(e);</code> is well-formed, for some invented temporary variable <code>t</code> (8.5). The effect of such an\n  explicit conversion is the same as performing the declaration and initialization and then using <strong>the temporary\n  variable as the result of the conversion.</strong></p>\n</blockquote>\n<p>The rhs is of type <code>CL</code>, and the (copy-)initialization requires a non-<code>explicit</code> constructor, thus the error is expected.</p>\n</hr>", "LastActivityDate": "2015-09-06T20:43:08.500", "CommentCount": "0", "CreationDate": "2015-09-06T20:43:08.500", "ParentId": "32427433", "Score": "2", "OwnerUserId": "3953764"}, "32427433": {"ViewCount": "82", "Body": "<p>Here is small example which demonstrates an unclear moment</p>\n<pre><code>struct CL\n{\n    CL(){}\n    CL(int){}\n    explicit CL(const CL&amp;){}\n};\n\nint main() {\n    CL cl1;\n    CL cl2=5;     //(1)\n    CL cl3=(CL)5; //(2)\n    return 0;\n}\n</code></pre>\n<p>The CL class have conversion constructor from int and copy constructor marked as explicit. In (1) case 5 (int) implicitly converted to CL and then cl2 is direct-initialized. In (2) case cl3 is copy-initialized. In both cases explicit copy-constructor must be involved. But different compilers give different results:</p>\n<p>clang and VS: first case is right, but second is wrong<br>\ngcc: both cases are wrong</br></p>\n<p>I think clang and VS are right because according to Standard \"explicit\" keyword prevents using a constructor in a copy-initialization, but not in a direct-initialization and gcc is wrong because direct-initialization is applied in (1) case.<br>\nWho of the compilers is right?</br></p>\n", "AcceptedAnswerId": "32428111", "Title": "Should an explicit copy constructor be ignored?", "CreationDate": "2015-09-06T19:30:23.587", "Id": "32427433", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-09-06T20:43:08.500", "Score": "2", "OwnerUserId": "3514538", "Tags": "<initialization><c++14><explicit>", "AnswerCount": "1"}});