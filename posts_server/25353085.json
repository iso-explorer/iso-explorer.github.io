post_cb({"25355345": {"ParentId": "25353085", "CommentCount": "1", "Body": "<p>As all field types have a common interface, you could simplify the problem by changing the interface if it is possible:</p>\n<pre><code>class Abstract_Visitor\n{\n  public:\n  virtual void visit(const Field_Interface&amp; f) = 0;\n};\n\nclass Visitor_Name_Query_3 : public Abstract_Visitor\n{\n  public:\n  void visit(const Field_Interface&amp; f)\n  {\n      std::cout &lt;&lt; \"Field name is: \"\n                &lt;&lt; f.get_field_name()\n                &lt;&lt; \"\\n\";\n  }\n};\n</code></pre>\n", "OwnerUserId": "3951057", "PostTypeId": "2", "Id": "25355345", "Score": "0", "CreationDate": "2014-08-18T01:45:54.367", "LastActivityDate": "2014-08-18T01:45:54.367"}, "bq_ids": {"n4140": {"so_25353085_25353919_1": {"section_id": 113, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_25353085_25353919_1": {"section_id": 108, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_25353085_25353919_1": {"section_id": 117, "quality": 0.9090909090909091, "length": 10}}}, "25354534": {"ParentId": "25353085", "CommentCount": "2", "Body": "<p>It seems you really want the <code>Abstract_Visitor</code> to have a default implementation. If you move the <code>template</code> into the <code>Abstract_Visitor</code>, you can let each <code>virtual</code> visitor have the default implementation.</p>\n<pre><code>class Abstract_Visitor\n{\n  template &lt;class Field&gt;\n  void visit(const Field&amp; f)\n  {\n      std::cout &lt;&lt; \"Field name is: \"\n                &lt;&lt; f.get_field_name()\n                &lt;&lt; \"\\n\";\n  }\n  public:\n  virtual void visit(const Field_Integer&amp; fi) { visit&lt;&gt;(fi); }\n  virtual void visit(const Field_String&amp; fi) { visit&lt;&gt;(fi); }\n  virtual void visit(const Field_Double&amp; fi) { visit&lt;&gt;(fi); }\n};\n</code></pre>\n", "OwnerUserId": "315052", "PostTypeId": "2", "Id": "25354534", "Score": "0", "CreationDate": "2014-08-17T23:19:12.423", "LastActivityDate": "2014-08-17T23:19:12.423"}, "25353919": {"ParentId": "25353085", "LastEditDate": "2014-08-17T22:01:03.820", "CommentCount": "0", "CreationDate": "2014-08-17T21:42:08.977", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "PostTypeId": "2", "Id": "25353919", "Score": "2", "Body": "<blockquote>\n<p id=\"so_25353085_25353919_0\">So why is the compiler generating saying that class <code>Visitor_Name_Query_1</code> is abstract?</p>\n</blockquote>\n<p>Because the standard says so. \u00a714.5.2 [temp.mem]/p4:</p>\n<blockquote>\n<p id=\"so_25353085_25353919_1\">A specialization of a member function template does not override a\n  virtual function from a base class. [ <em>Example</em>:</p>\n<pre><code>class B {\n    virtual void f(int);\n};\nclass D : public B {\n    template &lt;class T&gt; void f(T); // does not override B::f(int)\n    void f(int i) { f&lt;&gt;(i); }     // overriding function that calls\n                                  // the template instantiation\n};\n</code></pre>\n<p id=\"so_25353085_25353919_2\">\u2014<em>end example</em> ]</p>\n</blockquote>\n", "LastActivityDate": "2014-08-17T22:01:03.820"}, "25353085": {"CommentCount": "10", "ViewCount": "114", "PostTypeId": "1", "LastEditorUserId": "225074", "CreationDate": "2014-08-17T19:56:10.530", "LastActivityDate": "2014-08-18T01:45:54.367", "Title": "Using Templates to resolve virtual methods", "AcceptedAnswerId": "25353919", "LastEditDate": "2014-08-17T21:10:59.237", "Id": "25353085", "Score": "-2", "Body": "<p>This issue involves using templates to resolve virtual members in a Dispatch pattern.<br>\n<em>Note:  This is not the same as virtual template method questions already asked on StackOverflow</em>. *</br></p>\n<p><strong>Edit 1:  Corrected syntax errors, added clarifications.</strong> </p>\n<p>Given the following:  </p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nclass Field_Interface\n{\n  public:\n    virtual std::string  get_field_name(void) const = 0;\n};\n\nclass Field_Integer : public Field_Interface\n{\n  public:\n    std::string get_field_name(void) const\n    { return \"INT\";}\n};\n\nclass Field_String : public Field_Interface\n{\n  public:\n    std::string get_field_name(void) const\n    { return \"VARCHAR\";}\n};\n\nclass Field_Double : public Field_Interface\n{\n  public:\n    std::string get_field_name(void) const\n    { return \"DOUBLE\";}\n};\n\n\nclass Abstract_Visitor\n{\n  public:\n  virtual void visit(const Field_Integer&amp; fi) = 0;\n  virtual void visit(const Field_String&amp; fi) = 0;\n  virtual void visit(const Field_Double&amp; fi) = 0;\n};\n\nclass Visitor_Name_Query_1 : public Abstract_Visitor\n{\n  public:\n  template &lt;class Field&gt;\n  void visit(const Field&amp; f)\n  {\n      std::cout &lt;&lt; \"Field name is: \"\n                &lt;&lt; f.get_field_name()\n                &lt;&lt; \"\\n\";\n  }\n};\n\nclass Visitor_Name_Query_2 : public Abstract_Visitor\n{\n  public:\n    void visit(const Field_Integer&amp; fi)\n    { print_field_name(fi); }\n\n    void visit(const Field_String&amp; fi)\n    { print_field_name(fi); }\n\n    void visit(const Field_Double&amp; fi)\n    { print_field_name(fi); }\n\n  private:\n    void print_field_name(const Field_Interface&amp; fi)\n    { \n        std::cout &lt;&lt; \"Field name is: \"\n                  &lt;&lt; fi.get_field_name()\n                  &lt;&lt; \"\\n\";\n    }\n};\n\nint main(void)\n{\n    Visitor_Name_Query_1    q1;\n    Field_Integer           fi;\n    q1.visit(f1);\n    return 0;\n}\n</code></pre>\n<p>The compiler is saying the templated method in <code>Visitor_Name_Query_1</code> is not resolving the abstract interface from <code>Abstract_Visitor</code>.  </p>\n<p><strong>Edit 2: Results from g++</strong> </p>\n<pre><code># g++ -o main.exe main.cpp\nmain.cpp: In function `int main()':\nmain.cpp:75: error: cannot declare variable `q1' to be of type `Visitor_Name_Query_1'\nmain.cpp:75: error:   because the following virtual functions are abstract:\nmain.cpp:35: error:  virtual void Abstract_Visitor::visit(const Field_Integer&amp;)\nmain.cpp:36: error:  virtual void Abstract_Visitor::visit(const Field_String&amp;)\nmain.cpp:37: error:  virtual void Abstract_Visitor::visit(const Field_Double&amp;)\nmain.cpp:77: error: `f1' undeclared (first use this function)\nmain.cpp:77: error: (Each undeclared identifier is reported only once for each function it appears in.)\n</code></pre>\n<p><code>Visitor_Name_Query_1</code> is an attempt to simplify the class <code>Visitor_Name_Query_2</code>.  When the number of <code>visit</code> methods grows beyond a simple quantity (like 5), maintenance becomes tedious.  This is the reason for the <code>template</code> declaration.  </p>\n<p>When the template is expanded, with one of the field types, the declaration matches the one in <code>Visitor_Name_Query_2</code>.  </p>\n<p>So why is the compiler generating saying that <code>class Visitor_Name_Query_1</code> is abstract? </p>\n<p><em>Note:  I am using Visual Studio 2008 on Windows Vista.</em></p>\n<p>*<sub> The other posts involve using templates to create virtual method declarations.  I'm using templates to create functions that implement the abstract methods.</sub> </p>\n", "Tags": "<c++><templates><visual-studio-2008><dispatch><visitor-pattern>", "OwnerUserId": "225074", "AnswerCount": "3"}});