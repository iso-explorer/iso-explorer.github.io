post_cb({"bq_ids": {"n4140": {"so_36430134_36430425_0": {"length": 50, "quality": 1.0, "section_id": 5422}}, "n3337": {"so_36430134_36430425_0": {"length": 34, "quality": 0.68, "section_id": 5217}}, "n4659": {"so_36430134_36430425_0": {"length": 50, "quality": 1.0, "section_id": 6844}}}, "36430134": {"ViewCount": "59", "Body": "<p>Please consider the following class</p>\n<pre><code>template&lt;class T&gt;\nclass foo\n{\npublic:\n    auto bar() { return m_t.bar(); }\n\nprivate:\n    T m_t;\n};\n</code></pre>\n<p>If we want <code>foo&lt;T&gt;::bar</code> to be non-throwing whenever <code>T::bar</code> is non-throwing, we can change its declaration to</p>\n<pre><code>auto bar() noexcept(noexcept(m_t.bar())) { return m_t.bar(); }\n</code></pre>\n<p>But what can we do, if we want <code>foo&lt;T&gt;::bar</code> to be specified with <code>constexpr</code> whenever <code>T::bar</code> is specified with <code>constexpr</code>?</p>\n<p>Can we just write</p>\n<pre><code>constexpr auto bar() noexcept(noexcept(m_t.bar())) { return m_t.bar(); }\n</code></pre>\n<p>and it will work in either case? I've tested this with clang 3.7 (C++17) and it seems to be the case, but I'm not sure whether or not the compiler is working correctly here.</p>\n", "Title": "Declaring a delegating method as constexpr whenever the invoked function is specified with constexpr", "CreationDate": "2016-04-05T15:04:12.067", "LastActivityDate": "2016-04-05T15:16:46.430", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-04-05T15:07:54.587", "LastEditorUserId": "2069064", "Id": "36430134", "Score": "4", "OwnerUserId": "547231", "Tags": "<c++><templates><c++14><constexpr><c++1z>", "AnswerCount": "1"}, "36430425": {"Id": "36430425", "PostTypeId": "2", "Body": "<p>From <a href=\"http://eel.is/c++draft/dcl.constexpr#6\">[dcl.constexpr]</a>:</p>\n<blockquote>\n<p id=\"so_36430134_36430425_0\">If the instantiated template specialization of a <code>constexpr</code> function template or member function of a class template would fail to satisfy the requirements for a <code>constexpr</code> function or <code>constexpr</code> constructor, that specialization is still a <code>constexpr</code> function or <code>constexpr</code> constructor, even though a call to such a function cannot appear in a constant expression. If no specialization of the template would satisfy the requirements for a <code>constexpr</code> function or <code>constexpr</code> constructor when considered as a non-template function or constructor, the template is ill-formed; no diagnostic required.</p>\n</blockquote>\n<p>Given that there are <code>T</code>s that could have a <code>constexpr X bar()</code> that can be used in a constant expression, the template is fine. If <code>T</code> has a non-<code>constexpr</code> <code>bar()</code>, then <code>foo::bar</code> is still considered <code>constexpr</code> but just cannot appear in a constant expression. </p>\n", "LastActivityDate": "2016-04-05T15:16:46.430", "CommentCount": "4", "CreationDate": "2016-04-05T15:16:46.430", "ParentId": "36430134", "Score": "5", "OwnerUserId": "2069064"}});