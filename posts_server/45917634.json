post_cb({"45917728": {"ParentId": "45917634", "CommentCount": "3", "Body": "<p>The problem here is that C++ has two options to deal with <code>a &lt; 0</code> expression:</p>\n<ul>\n<li>Convert <code>a</code> to <code>bool</code>, and compare the result to <code>0</code> with built-in operator <code>&lt;</code> (one conversion)</li>\n<li>Convert <code>0</code> to <code>Foo</code>, and compare the results with <code>&lt;</code> that you defined (one conversion)</li>\n</ul>\n<p>Both approaches are equivalent to the compiler, so it issues an error.</p>\n<p>You can make this explicit by removing the conversion in the second case:</p>\n<pre><code>if (a &lt; Foo(0)) {\n    ...\n}\n</code></pre>\n", "OwnerUserId": "335858", "PostTypeId": "2", "Id": "45917728", "Score": "24", "CreationDate": "2017-08-28T11:17:43.137", "LastActivityDate": "2017-08-28T11:17:43.137"}, "45917746": {"ParentId": "45917634", "LastEditDate": "2017-08-28T13:09:54.227", "CommentCount": "4", "CreationDate": "2017-08-28T11:18:44.107", "OwnerUserId": "4341198", "LastEditorUserId": "4341198", "PostTypeId": "2", "Id": "45917746", "Score": "2", "Body": "<p>This is exactly what the compiler tells you.</p>\n<p>One approach for solving the <code>if (a &lt; 0)</code> for the compiler is to use the <code>Foo(int x)</code> constructor you've provided to create object from 0.</p>\n<p>The second one is to use the <code>operator bool</code> conversion and compare it against the <code>int</code> (promotion). You can read more about it in <a href=\"http://en.cppreference.com/w/cpp/language/implicit_conversion\" rel=\"nofollow noreferrer\">Numeric promotions</a> section.</p>\n<p>Hence, it is ambiguous for the compiler and it cannot decide which way you want it to go.</p>\n", "LastActivityDate": "2017-08-28T13:09:54.227"}, "45920103": {"ParentId": "45917634", "CommentCount": "1", "Body": "<p>The important points are:</p>\n<p>First, there are two relevant overloads of <code>operator &lt;</code>.</p>\n<ul>\n<li><code>operator &lt;(const Foo&amp;, const Foo&amp;)</code>. Using this overload requires a user-defined conversion of the literal <code>0</code> to <code>Foo</code> using <code>Foo(int)</code>.</li>\n<li><code>operator &lt;(int, int)</code>. Using this overload requires converting <code>Foo</code> to <code>bool</code> with the user-defined <code>operator bool()</code>, followed by a <em>promotion</em> to <code>int</code> (this is, in standardese, different from a conversion, as has been pointed out by Bo Persson).</li>\n</ul>\n<p>The question here is: From whence does the ambiguity arise? Certainly, the first call, which requires only a user-defined conversion, is more sensible than the second, which requires a user-defined conversion followed by a promotion?</p>\n<p>But that is not the case. The standard assigns a rank to each <em>candidate</em>. However, there is no rank for \"user-defined conversion followed by a promotion\". This has the same rank as only using a user-defined conversion. Simply (but informally) put, the ranking sequence looks a bit like this:</p>\n<ol>\n<li>exact match</li>\n<li>(only) promotion required</li>\n<li>(only) implicit conversion required (including \"unsafe\" ones inherited from C such as <code>float</code> to <code>int</code>)</li>\n<li>user-defined conversion required</li>\n</ol>\n<p>(Disclaimer: As mentioned, this is informal. It gets significantly more complex when multiple arguments are involved, and I also didn't mention references or cv-qualification. This is just intended as a rough overview.)</p>\n<p>So this, hopefully, explains why the call is ambiguous. Now for the practical part of how to fix this. <em>Almost never</em> does someone who provides <code>operator bool()</code> want it to be implicitly used in expressions involving integer arithmetic or comparisons. In C++98, there were obscure workarounds, ranging from <code>std::basic_ios&lt;CharT, Traits&gt;::operator void *</code> to \"improved\" safer versions involving pointers to members or incomplete private types. Fortunately, C++11 introduced a more readable and consistent way of preventing integer promotion after implicit uses of <code>operator bool()</code>, which is to mark the operator as <code>explicit</code>. This will remove the <code>operator &lt;(int, int)</code> overload entirely, rather than just \"demoting\" it.</p>\n<p>As others have mentioned, you can also mark the <code>Foo(int)</code> constructor as explicit. This will have the converse effect of removing the <code>operator &lt;(const Foo&amp;, const Foo&amp;)</code> overload.</p>\n<p>A third solution would be to provide additional overloads, e.g.:</p>\n<ul>\n<li><code>operator &lt;(int, const Foo&amp;)</code></li>\n<li><code>operator &lt;(const Foo&amp;, int)</code></li>\n</ul>\n<p>The latter, in this example, will then be preferred over the above-mentioned overloads as an exact match, even if you did not introduce <code>explicit</code>. The same goes e.g. for</p>\n<ul>\n<li><code>operator &lt;(const Foo&amp;, long long)</code></li>\n</ul>\n<p>which would be preferred over <code>operator &lt;(const Foo&amp;, const Foo&amp;)</code> in <code>a &lt; 0</code> because its use requires only a promotion.</p>\n", "OwnerUserId": "4083309", "PostTypeId": "2", "Id": "45920103", "Score": "13", "CreationDate": "2017-08-28T13:21:01.273", "LastActivityDate": "2017-08-28T13:21:01.273"}, "45917775": {"ParentId": "45917634", "LastEditDate": "2017-08-28T12:00:30.537", "CommentCount": "5", "CreationDate": "2017-08-28T11:20:02.687", "OwnerUserId": "6639082", "LastEditorUserId": "6639082", "PostTypeId": "2", "Id": "45917775", "Score": "4", "Body": "<p>Because compiler can not choose between <code>bool operator &lt;(const Foo &amp;,const Foo &amp;)</code> and <code>operator&lt;(bool, int)</code> which both fits in this situation.</p>\n<p>In order to fix the issue make second constructor <code>explicit</code>:</p>\n<pre><code>struct Foo\n{\n    Foo() {}\n    explicit Foo(int x) {}\n\n    operator bool() const { return false; }\n\n    friend bool operator&lt;(const Foo&amp; a, const Foo&amp; b)\n    {\n        return true;\n    }\n};\n</code></pre>\n<p><strong>Edit:</strong>\nOk, at last I got a real point of the question :) OP asks why his compiler offers <code>operator&lt;(int, int)</code> as a candidate, though <strong><em>\"multi-step conversions are not allowed\"</em></strong>. </p>\n<p><strong>Answer:</strong>\nYes, in order to call <code>operator&lt;(int, int)</code> object <code>a</code> needs to be converted <code>Foo -&gt; bool -&gt; int</code>. <strong>But</strong>, C++ Standard does not actually say that \"multi-step conversions are illegal\".</p>\n<p><strong>\u00a7 12.3.4  [class.conv]</strong></p>\n<blockquote>\n<p id=\"so_45917634_45917775_0\">At most one user-defined conversion (constructor or conversion\n  function) is implicitly applied to a single value.</p>\n</blockquote>\n<p><code>bool</code> to <code>int</code> <strong>is not user-defined</strong> conversion, hence it is legal and compiler has the full right to chose <code>operator&lt;(int, int)</code> as a candidate. </p>\n", "LastActivityDate": "2017-08-28T12:00:30.537"}, "45917634": {"CommentCount": "6", "CreationDate": "2017-08-28T11:12:38.043", "PostTypeId": "1", "AcceptedAnswerId": "45920103", "LastEditorUserId": "3204551", "LastActivityDate": "2017-08-28T14:22:36.287", "LastEditDate": "2017-08-28T14:22:36.287", "ViewCount": "1893", "FavoriteCount": "2", "Title": "Why is this C++ expression involving overloaded operators and implicit conversions ambiguous?", "Id": "45917634", "Score": "18", "Body": "<p><code>operator bool</code> breaks the use of <code>operator&lt;</code> in the following example. Can anyone explain why <code>bool</code> is just as relevant in the <code>if (a &lt; 0)</code> expression as the specific operator, an whether there is a workaround?</p>\n<pre><code>struct Foo\n{\n    Foo() {}\n    Foo(int x) {}\n\n    operator bool() const { return false; }\n\n    friend bool operator&lt;(const Foo&amp; a, const Foo&amp; b)\n    {\n        return true;\n    }\n};\n\nint main()\n{\n    Foo a, b;\n\n    if (a &lt; 0) {\n        a = 0;\n    }\n\n    return 1;\n}\n</code></pre>\n<p>When I compile, I get:</p>\n<pre class=\"lang-none prettyprint-override\"><code>g++ foo.cpp\nfoo.cpp: In function 'int main()':\nfoo.cpp:18:11: error: ambiguous overload for 'operator&lt;' (operand types are 'Foo' and 'int')\n     if (a &lt; 0) {\n           ^\nfoo.cpp:18:11: note: candidate: operator&lt;(int, int) &lt;built-in&gt;\nfoo.cpp:8:17: note: candidate: bool operator&lt;(const Foo&amp;, const Foo&amp;)\n     friend bool operator&lt;(const Foo&amp; a, const Foo&amp; b)\n</code></pre>\n", "Tags": "<c++><type-conversion><operators><ambiguous>", "OwnerUserId": "1964167", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_45917634_45917775_0": {"section_id": 386, "quality": 1.0, "length": 11}}, "n3337": {"so_45917634_45917775_0": {"section_id": 377, "quality": 1.0, "length": 11}}, "n4659": {"so_45917634_45917775_0": {"section_id": 403, "quality": 1.0, "length": 11}}}});