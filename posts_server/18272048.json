post_cb({"18273125": {"ParentId": "18272048", "CommentCount": "5", "Body": "<p>I think a better way to provide a generic singleton implementation is to use the CRTP, and directly inheriting from that template. That means every class automagically implements the singleton pattern only inheriting from the CRTP base:</p>\n<pre><code>template&lt;typename DERIVED&gt;\nclass generic_singleton\n{\nprivate:\n    static DERIVED* _instance;\n\n    static void _singleton_deleter() { delete _instance; } //Function that manages the destruction of the instance at the end of the execution.\n\nprotected:\n    generic_singleton() {}\n    virtual generic_singleton() {} //IMPORTANT: virtual destructor\n\npublic:\n    DERIVED&amp; instance() //Never return pointers!!! Be aware of \"delete Foo.instance()\"\n    {\n        if(!_instance)\n        {\n            _instance = new DERIVED;\n            std::atexit( _singleton_deleter ); //Destruction of instance registered at runtime exit (No leak).\n        }\n\n        return static_cast&lt;DERIVED&amp;&gt;( _instance );\n    }\n};\n\ntemplate&lt;typename DERIVED&gt;\nDERIVED* generic_singleton&lt;DERIVED&gt;::_instance = nullptr;\n</code></pre>\n<p>The memory release is provided by registering a function that does the delete at the end of the application, with <code>std::ateexit()</code>.</p>\n", "OwnerUserId": "1609356", "PostTypeId": "2", "Id": "18273125", "Score": "3", "CreationDate": "2013-08-16T12:14:34.990", "LastActivityDate": "2013-08-16T12:14:34.990"}, "18272228": {"ParentId": "18272048", "CommentCount": "0", "Body": "<p>This is expected behaviour. The rule is you can only access protected members in <code>Deringlton</code> if the pointer is of type <code>Deringlton</code>. You <em>cannot</em> access protected members through a pointer of type <code>Singleton</code>. For example:</p>\n<pre><code>Deringlton* d = this;\nd-&gt;someProtectedMethod(); // OK!\nSingleton* s = this;\ns-&gt;someProtectedMethod(); // Will fail\n</code></pre>\n<p>Since accessing <code>new Singleton</code> is not through a <code>Deringlton</code> pointer, it is not allowed. You can only access it through Deringlton by doing <code>new Deringlton</code>.</p>\n", "OwnerUserId": "1301852", "PostTypeId": "2", "Id": "18272228", "Score": "0", "CreationDate": "2013-08-16T11:24:24.153", "LastActivityDate": "2013-08-16T11:24:24.153"}, "18272246": {"ParentId": "18272048", "CommentCount": "0", "Body": "<p>This behavior is specified in the standard.</p>\n<p>Section 11.4 [class.protected] of C++11 states (emphasis mine):</p>\n<blockquote>\n<p id=\"so_18272048_18272246_0\">As described earlier, access to a <code>protected</code> member is granted because\n  the reference occurs in a friend or member of some class <code>C</code>. If the\n  access is to form a pointer to member (5.3.1), the\n  nested-name-specifier shall denote C or a class derived from C. <strong>All\n  other accesses involve a (possibly implicit) object expression\n  (5.2.5). In this case, the class of the object expression shall be <code>C</code>\n  or a class derived from <code>C</code>.</strong></p>\n</blockquote>\n<p>What this means is that access to the base constructor is granted <em>only if you are creating an object of the derived class</em>. So for example, this would compile:</p>\n<pre><code>Deringlton()\n{\n    Deringlton* p = new Deringlton();\n}\n</code></pre>\n", "OwnerUserId": "50079", "PostTypeId": "2", "Id": "18272246", "Score": "0", "CreationDate": "2013-08-16T11:25:00.817", "LastActivityDate": "2013-08-16T11:25:00.817"}, "18273437": {"ParentId": "18272048", "CommentCount": "7", "Body": "<p>What's the point of having a pointer an not just a static variable?</p>\n<pre><code>class Singleton\n{\npublic:\n    static Singleton&amp; instance()\n    { static Singleton z; return z; }\nprivate:\n    Singleton() {}\n    ~SIngleton() {}\n};\n</code></pre>\n<p>In don't see any value in deriving it.</p>\n<p>If you want to make this pattern coded as a template you can do</p>\n<pre><code>template&lt;class S&gt;\nS&amp; instance_of() { static S z; return z; }\n</code></pre>\n<p>and make <code>instance_of&lt;yourclass&gt;()</code> a friend of <code>yourclass</code>, having private ctor / dtor.</p>\n<p>The use of a static variable makes the object granted to be properly constructed and destructed. (Unlike a remaining leaked pointer, with no destructor call...)</p>\n", "OwnerUserId": "924727", "PostTypeId": "2", "Id": "18273437", "Score": "0", "CreationDate": "2013-08-16T12:33:52.607", "LastActivityDate": "2013-08-16T12:33:52.607"}, "18272048": {"CommentCount": "3", "ViewCount": "4125", "CreationDate": "2013-08-16T11:14:28.877", "LastActivityDate": "2013-08-16T12:33:52.607", "Title": "Is this standard way to derive from singleton class?", "AcceptedAnswerId": "18272242", "PostTypeId": "1", "Id": "18272048", "Score": "0", "Body": "<p>My Base class is Singleton having protected c'tor. Now, I can derive another class from it but I cannot create instance of that Base class inside functions of derived class. This is expected behavior as per my design. But I like to know is it correct by C++ standards or just my compiler specific behavior? (So that I shouldn't face issues if I want to port this code in future)</p>\n<pre><code>class Singleton\n{\nprotected:\n    Singleton() {}\n\npublic:\n    Singleton * GetInstance()\n    {\n        static Singleton* InstanceCreated = NULL ;\n\n        if (!InstanceCreated)\n            InstanceCreated = new Singleton ;\n\n        return InstanceCreated ;\n    }\n};\n\nclass Deringlton : public Singleton\n{\npublic:\n    Deringlton()\n    {\n        Singleton * pSing ;\n        // pSing = new Singlton ; // Cannot create object of singlton \n                                  // (Despite class is derived from singlton)\n    }\n};\n</code></pre>\n", "Tags": "<c++><singleton>", "OwnerUserId": "1911652", "AnswerCount": "5"}, "18272242": {"ParentId": "18272048", "CommentCount": "0", "Body": "<p>If you have to make a singleton (which you should avoid) the instance and(!) the declaration are a singleton. You could use a template have a 'generic' one, but inheritance is no good.</p>\n", "OwnerUserId": "2249683", "PostTypeId": "2", "Id": "18272242", "Score": "0", "CreationDate": "2013-08-16T11:24:56.190", "LastActivityDate": "2013-08-16T11:24:56.190"}, "bq_ids": {"n4140": {"so_18272048_18272246_0": {"section_id": 6695, "quality": 0.9459459459459459, "length": 35}}, "n3337": {"so_18272048_18272246_0": {"section_id": 6450, "quality": 0.9459459459459459, "length": 35}}, "n4659": {"so_18272048_18272246_0": {"section_id": 8170, "quality": 0.9459459459459459, "length": 35}}}});