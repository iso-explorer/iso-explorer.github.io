post_cb({"bq_ids": {"n4140": {"so_35315472_35316231_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 6074}}, "n3337": {"so_35315472_35316231_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 5842}}, "n4659": {"so_35315472_35316231_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 7570}}}, "35315472": {"ViewCount": "124", "Body": "<p><strong>First example</strong></p>\n<pre><code>int a = 0;\nauto &amp;&amp; b = ++a;\n++a;\ncout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;\n</code></pre>\n<p>prints <code>22</code></p>\n<p><strong>Second example</strong></p>\n<pre><code>int a = 0;\nauto &amp;&amp; b = a++;\n++a;\ncout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;\n</code></pre>\n<p>prints <code>20</code></p>\n<p><strong>Question:</strong>\nWhy in first example <code>++a</code> in 3rd line also increments <code>b</code>, and why there is no such behavior in second example?</p>\n<p><strong>Update:</strong> <a href=\"https://stackoverflow.com/questions/35315826/can-i-use-rvalue-to-temporary-is-it-ub-or-not\">New question</a> arised.</p>\n", "AcceptedAnswerId": "35315562", "Title": "Why this two rvalue references examples have different behavior?", "CreationDate": "2016-02-10T12:35:13.843", "Id": "35315472", "CommentCount": "3", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:14:53.447", "LastEditorUserId": "-1", "LastActivityDate": "2016-02-10T13:10:51.067", "Score": "5", "OwnerUserId": "1555823", "Tags": "<c++><rvalue-reference>", "AnswerCount": "3"}, "35315569": {"Id": "35315569", "PostTypeId": "2", "Body": "<p>In the second case (post-increment) b actually references the temporary created for (a++), so the increments do not affect b.</p>\n", "LastActivityDate": "2016-02-10T12:39:38.793", "CommentCount": "0", "CreationDate": "2016-02-10T12:39:38.793", "ParentId": "35315472", "Score": "1", "OwnerUserId": "4030223"}, "35315562": {"Id": "35315562", "PostTypeId": "2", "Body": "<p>Because pre-increment (<code>++a</code>) first increments the value of <code>a</code>, stores the result, and <em>then</em> returns the reference to <code>a</code>. Now <code>a</code> and <code>b</code> effectively point to the same object.</p>\n<p>Post-increment (<code>a++</code>), however, first stores the current value of <code>a</code> in a temporary, increments <code>a</code>, and returns this temporary - to which your rvalue ref points. <code>a</code> and <code>b</code> point to different objects, more specifically - <code>b</code> is a temporary holding the value of <code>a</code> prior to incrementing.</p>\n<p>This is the reason why it's encouraged to use <code>++it</code> over <code>it++</code> for iterators and other complex objects that define increment / decrement: the latter creates a temporary copy and thus <em>may</em> be slower.</p>\n", "LastEditorUserId": "634821", "LastActivityDate": "2016-02-10T12:41:59.227", "Score": "10", "CreationDate": "2016-02-10T12:39:13.950", "ParentId": "35315472", "CommentCount": "12", "OwnerUserId": "634821", "LastEditDate": "2016-02-10T12:41:59.227"}, "35316231": {"Id": "35316231", "PostTypeId": "2", "Body": "<p>The difference is that <code>++a</code> is an lvalue, however <code>a++</code> is not. This is specified by C++14 [expr.pre.incr]/1:</p>\n<blockquote>\n<p id=\"so_35315472_35316231_0\">The operand of prefix <code>++</code> is modified by adding 1 [...] The\n  operand shall be a modifiable lvalue. [...] The result is the updated operand; it is an lvalue</p>\n</blockquote>\n<p>and [expr.post.incr]/1:</p>\n<blockquote>\n<p id=\"so_35315472_35316231_1\">[...] The result is a prvalue.</p>\n</blockquote>\n<hr>\n<p>Now we consider <code>auto &amp;&amp; b = ++a;</code> . <code>++a</code> is an lvalue. <code>auto&amp;&amp;</code> is a forwarding reference. Forwarding references can actually bind to lvalues: the <code>auto</code> may itself deduce to a reference type. This code deduces to <code>int &amp;b = ++a;</code>.</p>\n<p>When a reference is bound to an lvalue of the same type, the reference binds directly, so <code>b</code> becomes another name for <code>a</code>.</p>\n<hr>\n<p>In the second example, <code>auto &amp;&amp; b = a++;</code>, <code>a++</code> is a prvalue. This means it doesn't have an associated address and it's no longer any relation to the variable <code>a</code>. This line has the same behaviour as <code>++a; auto &amp;&amp; b = (a + 0);</code> would.</p>\n<p>Firstly, since <code>a++</code> is a prvalue, <code>auto&amp;&amp;</code> deduces to <code>int&amp;&amp;</code>. (i.e. <code>auto</code> deduces to <code>int</code>).  When a reference of non-class type is bound to a prvalue, a temporary object is copy-initialized from the value. This object has its lifetime extended to match the reference.</p>\n<p>So <code>b</code> in the second case is bound to a different object from <code>a</code>, a \"temporary\" int (which is not really so temporary, since it lasts as long as <code>b</code> does).</p>\n<p>The reference binding rules are in [dcl.init.ref].</p>\n</hr></hr>", "LastActivityDate": "2016-02-10T13:10:51.067", "CommentCount": "0", "CreationDate": "2016-02-10T13:10:51.067", "ParentId": "35315472", "Score": "2", "OwnerUserId": "1505939"}});