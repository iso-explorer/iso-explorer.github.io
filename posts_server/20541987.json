post_cb({"20541987": {"CommentCount": "4", "AcceptedAnswerId": "20542143", "CreationDate": "2013-12-12T11:15:31.930", "LastActivityDate": "2013-12-12T14:11:57.590", "PostTypeId": "1", "ViewCount": "334", "FavoriteCount": "0", "Title": "Is it dangerous to use placement new on an old object without explicitly calling the destructor first?", "Id": "20541987", "Score": "3", "Body": "<p>I would like to recycle memory for an object rather than deallocating and reconstructing it. Is the following usage of \"placement new\" safe, assuming that <code>Foo</code> in practice does not contain pointers (but might contain functions)?</p>\n<p>Also, is the final <code>delete</code> call safe, and will it correctly call the destructor on the second \"new\" object, and correctly free the memory afterwards?</p>\n<pre><code>#include &lt;new&gt;\nstruct Foo {\n    int hello;\n    int world;\n};\n\nint main() {\n    Foo* foo = new Foo;\n    // Do something with foo\n    // Done with foo, writing a new version of foo on top of the old one.\n    new(foo) Foo();\n\n    delete(foo);\n}\n</code></pre>\n<p>The simple example above compiles and runs without errors, but I cannot tell by running it whether it might blow up for some reason in a more complex environment.</p>\n", "Tags": "<c++><placement-new>", "OwnerUserId": "391161", "AnswerCount": "3"}, "20542142": {"ParentId": "20541987", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2013-12-12T11:22:54.330", "Score": "5", "LastEditorUserId": "947836", "LastEditDate": "2013-12-12T11:53:47.313", "Id": "20542142", "OwnerUserId": "947836", "Body": "<p>It's safe because the object you're overwriting has a trivial destructor. From n3337, chapter 3.8 (Object lifetime):</p>\n<blockquote>\n<p id=\"so_20541987_20542142_0\">4 <strong>A program may end the lifetime of any object by reusing the storage which the object occupies or by explicitly\n  calling the destructor for an object of a class type with a non-trivial destructor.</strong> For an object of a class type\n  with a non-trivial destructor, the program is not required to call the destructor explicitly before the storage\n  which the object occupies is reused or released; however, if there is no explicit call to the destructor or if a\n  delete-expression (5.3.5) is not used to release the storage, the destructor shall not be implicitly called and\n  any program that depends on the side effects produced by the destructor has unde\ufb01ned behavior.</p>\n</blockquote>\n<p>The <code>delete</code> call is safe, too. You're calling it on a pointer that you got from <code>new</code> and there's a live object at that place.</p>\n<p>And as you hinted in the question, it could invoke undefined behaviour if the destructor is non-trivial and has side effects - you need to call it explicitly in that case. Whether or not the class contains pointers is not directly important - reusing the storage is safe even in that case, but of course, you could introduce memory leaks and other bugs that way.</p>\n", "LastActivityDate": "2013-12-12T11:53:47.313"}, "bq_ids": {"n4140": {"so_20541987_20542142_0": {"section_id": 7192, "quality": 0.9411764705882353, "length": 48}}, "n3337": {"so_20541987_20542142_0": {"section_id": 6936, "quality": 0.9411764705882353, "length": 48}}, "n4659": {"so_20541987_20542142_0": {"section_id": 8701, "quality": 0.9411764705882353, "length": 48}}}, "20542143": {"ParentId": "20541987", "CommentCount": "0", "CreationDate": "2013-12-12T11:23:03.817", "OwnerUserId": "335858", "PostTypeId": "2", "Id": "20542143", "Score": "5", "Body": "<p>No, it is not dangerous to reuse memory of an object, provided that you are doing it correctly. Moreover, you do not have to restrict yourself to objects that have no pointers: by calling the destructor explicitly you can prepare the object for reuse, like this:</p>\n<pre><code>Foo* foo = new Foo;\n// Do something with foo\n// Done with foo, writing a new version of foo on top of the old one.\nfoo-&gt;~Foo();     // Call the destructor explicitly to clean up the resources of a Foo\nnew(foo) Foo();  // Place new data into the previously allocated memory\ndelete(foo);     // We are deleting a fully initialized object, so it is OK\n</code></pre>\n", "LastActivityDate": "2013-12-12T11:23:03.817"}, "20545824": {"ParentId": "20541987", "CommentCount": "12", "CreationDate": "2013-12-12T14:11:57.590", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "20545824", "Score": "0", "Body": "<p>There have been two answers already, but they give, I fear, an incomplete picture.</p>\n<p>You may reuse the storage of an object, providing that you respect a few conditions:</p>\n<ul>\n<li>You need not use a dynamically allocated object, <strong>any object is fine</strong>.</li>\n<li>You should properly <strong>destroy the previous object</strong>, by calling its destructor (explicitly); failure to do so leads to <em>undefined behavior</em> if the destructor has side-effects (see \u00a73.8/4)</li>\n<li>The object that you place should have the <strong>same dynamic type</strong> as the previous object  (see \u00a73.8/7)</li>\n</ul>\n<p>Let us review them, starting with <em>any object is fine</em>:</p>\n<pre><code>struct Foo {\n    int hello;\n    int world;\n};\n\nvoid automatically_allocated() {\n    Foo foo;\n    foo.~Foo();\n    new (&amp;foo) Foo{};\n}\n\nvoid dynamically_allocated() {\n    std::unique_ptr&lt;Foo&gt; foo(new Foo{});\n    foo-&gt;~Foo();\n    new (&amp;*foo) Foo{};\n}\n</code></pre>\n<p>Let use continue with <em>destroy the previous object</em>:</p>\n<pre><code>struct Bar {\n    int hello;\n    std::string world;\n};\n\nvoid UNDEFINED_BEHAVIOR() {\n    Bar bar;\n    new (&amp;bar) Bar{}; // most likely scenario: leaks memory owned by bar.world\n}\n</code></pre>\n<p>And finally with <em>same dynamic type</em>:</p>\n<pre><code>struct Base { virtual ~Base() {} };\n\nstruct Derived: Base { std::string world; };\nstruct Other: Base { int hello; }\n\nvoid UNDEFINED_BEHAVIOR() {\n    Derived derived;\n\n    Base&amp; b = derived;\n    b.~Base(); // fine\n\n    new (&amp;b) Other{};\n\n    // Most likely here, calls \"derived.~Derived()\" on an object of type Other...\n}\n</code></pre>\n", "LastActivityDate": "2013-12-12T14:11:57.590"}});