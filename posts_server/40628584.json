post_cb({"40628584": {"CommentCount": "5", "AcceptedAnswerId": "40629271", "PostTypeId": "1", "LastEditorUserId": "237575", "CreationDate": "2016-11-16T09:39:19.357", "LastActivityDate": "2016-11-18T07:58:04.853", "LastEditDate": "2016-11-18T07:58:04.853", "ViewCount": "183", "FavoriteCount": "2", "Title": "Understanding C++03 Standard Grammar for Operator Overloading", "Id": "40628584", "Score": "14", "Body": "<p>The standard C++03 grammar for overloading an operator is as follows:</p>\n<p><em>operator-function-id</em>:<br>\n<strong>operator</strong> <em>operator</em><br>\n<strong>operator</strong> <em>operator</em> &lt; <em>template-argument-list</em>?&gt;</br></br></p>\n<p>The first one is the ordinary operator overloading syntax that we normally use, e.g.</p>\n<pre><code>Myclass operator + (Myclass s) {...}\n</code></pre>\n<p>But what does the second alternative mean? In particular, under what situation do we use the <em>template-argument-list</em>? After a quick look at C++11, I found that the second form was removed from the standard. What was the original intention of it?</p>\n<p>EDIT: after testing with VC++2010, below is one way of using the above syntax, although it does not make much sense to me:</p>\n<pre><code>class K {\npublic:\n    int a;\n    template &lt;int B&gt;\n    int operator + (int b) {\n        return a+b+B;\n    }\n};\n\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    K k;\n    k.a=1;\n    int s;\n    s=k.operator+&lt;115&gt;(2);\n    printf(\"%d\\n\",s);\n    return 0;\n\n}\n\noutput:118\n</code></pre>\n", "Tags": "<c++><language-lawyer><c++03>", "OwnerUserId": "237575", "AnswerCount": "1"}, "40629271": {"ParentId": "40628584", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The grammar rule which allows specialization of operator function templates still exists in C++11, it's just in a different place.</p>\n<p><strong>[temp.names]/1 (C++03)</strong>:</p>\n<blockquote>\n<p id=\"so_40628584_40629271_0\">A template specialization (14.7) can be referred to by a template-id:</p>\n<p id=\"so_40628584_40629271_1\">template-id:</p>\n<pre><code>template-name &lt; template-argument-listopt&gt;\n</code></pre>\n<p id=\"so_40628584_40629271_2\">template-name:</p>\n<pre><code>identifier\n</code></pre>\n<p id=\"so_40628584_40629271_3\">template-argument-list:</p>\n<pre><code>template-argument\ntemplate-argument-list , template-argument\n</code></pre>\n<p id=\"so_40628584_40629271_4\">template-argument:</p>\n<pre><code>assignment-expression\ntype-id\nid-expression\n</code></pre>\n</blockquote>\n<p><strong>[temp.names]/1 (C++11)</strong>:</p>\n<blockquote>\n<p id=\"so_40628584_40629271_5\">A template specialization (14.7) can be referred to by a template-id:</p>\n<p id=\"so_40628584_40629271_6\">simple-template-id:</p>\n<pre><code>template-name &lt; template-argument-listopt&gt;\n</code></pre>\n<p id=\"so_40628584_40629271_7\">template-id:</p>\n<pre><code>simple-template-id\noperator-function-id &lt; template-argument-listopt&gt; &lt;- HERE\nliteral-operator-id &lt; template-argument-listopt&gt;\n</code></pre>\n<p id=\"so_40628584_40629271_8\">template-name:</p>\n<pre><code>identifer\n</code></pre>\n<p id=\"so_40628584_40629271_9\">template-argument-list:</p>\n<pre><code>template-argument ...opt\ntemplate-argument-list , template-argument ...opt\n</code></pre>\n<p id=\"so_40628584_40629271_10\">template-argument:</p>\n<pre><code>constant-expression\ntype-id\nid-expression\n</code></pre>\n</blockquote>\n<p>This was likely done because the grammatical rule <em>operator-function-id</em> is referred to in contexts where that template argument list would not make sense, so they moved the rule to somewhere more reasonable &lt;/conjecture&gt;.</p>\n<hr>\n<p>Here is an example of this rule in action:</p>\n<pre><code>struct foo{\n    template &lt;typename T&gt;\n    void operator() (T t) { std::cout &lt;&lt; t; }\n};\n\ntemplate &lt;&gt;\nvoid foo::operator()&lt;double&gt; (double) { \n    std::cout &lt;&lt; \"It's a double!\"; \n}\n</code></pre>\n<p>Note the specialization for <code>operator()</code> for when <code>T</code> is <code>double</code>. If you run this code:</p>\n<pre><code>foo f;\nf(0);\nf(0.0);\n</code></pre>\n<p>Then <code>0</code> will be printed for the first call, and <code>It's a double!</code> for the second.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/edfe39e14dbc2e9e\" rel=\"nofollow noreferrer\">Live demo</a></p>\n</hr>", "OwnerUserId": "496161", "LastEditorUserId": "496161", "LastEditDate": "2016-11-16T10:10:45.507", "Id": "40629271", "Score": "5", "CreationDate": "2016-11-16T10:07:58.443", "LastActivityDate": "2016-11-16T10:10:45.507"}, "bq_ids": {"n4140": {"so_40628584_40629271_0": {"section_id": 69, "quality": 0.8333333333333334, "length": 5}, "so_40628584_40629271_5": {"section_id": 69, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_40628584_40629271_0": {"section_id": 64, "quality": 0.8333333333333334, "length": 5}, "so_40628584_40629271_5": {"section_id": 64, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_40628584_40629271_0": {"section_id": 71, "quality": 0.8333333333333334, "length": 5}, "so_40628584_40629271_5": {"section_id": 71, "quality": 0.8333333333333334, "length": 5}}}});