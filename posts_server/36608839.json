post_cb({"bq_ids": {"n4140": {"so_36608839_36608988_1": {"length": 55, "quality": 0.6875, "section_id": 233}, "so_36608839_36608988_0": {"length": 33, "quality": 0.6111111111111112, "section_id": 233}}, "n3337": {"so_36608839_36608988_1": {"length": 55, "quality": 0.6875, "section_id": 226}, "so_36608839_36608988_0": {"length": 33, "quality": 0.6111111111111112, "section_id": 226}}, "n4659": {"so_36608839_36608988_0": {"length": 31, "quality": 0.5740740740740741, "section_id": 243}}}, "36608839": {"ViewCount": "120", "Body": "<p>When I compile the following with <code>g++ --std=c++98 -Wall -Werror -Wpedantic Test.cc</code>, there's no error.</p>\n<pre><code>template &lt;class T&gt;\nstruct TemplateClass {\n  T *ptr;\n\n  TemplateClass(T *p): ptr(p) {}\n\n  int foo() {\n    return ptr-&gt;bar();\n  }\n};\n\nstruct ExampleClass {\n};\n\nint main() {\n  TemplateClass&lt;ExampleClass&gt; x(new ExampleClass());\n}\n</code></pre>\n<p>I expected that the compiler would complain that <code>ExampleClass</code> doesn't implement method <code>bar</code>.</p>\n<p>But it looks like it only complains if I actually use the method <code>foo</code>.</p>\n<p>Can I rely on this behavior on any C++98 and C++11 compliant compilers?</p>\n<p>My understanding of templates before was that whenever a template is instantiated, the entirety of the body is copied with <code>T</code> replaced with the template argument. Is this not how templates work?</p>\n", "AcceptedAnswerId": "36608988", "Title": "Template class method does not cause error -- is this part of the standard?", "CreationDate": "2016-04-13T20:21:47.587", "Id": "36608839", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2016-04-13T20:30:19.083", "Score": "6", "OwnerUserId": "956134", "Tags": "<c++><templates><c++11>", "AnswerCount": "1"}, "36608988": {"Id": "36608988", "PostTypeId": "2", "Body": "<p>This is the correct behaviour according to the standard. The definition of <code>foo</code> is not instantiated until used in a context that requires it to exist. Emphasis mine in the below:</p>\n<p>C++03, [temp.inst]/1:</p>\n<blockquote>\n<p id=\"so_36608839_36608988_0\">The implicit instantiation of a class template specialization causes the implicit\n  instantiation of the declarations, but <strong>not of the definitions</strong> or default arguments, of the class member functions, member classes, static data members and member templates; and it causes the implicit instantiation\n  of the definitions of member anonymous unions. Unless a member of a class template or a member template has been explicitly instantiated or explicitly specialized, the specialization of the member is implicitly\n  instantiated when the specialization is referenced in a context that requires the member definition to exist; ...</p>\n</blockquote>\n<p>C++11, [temp.inst]/1 and [temp.inst]/2:</p>\n<blockquote>\n<p id=\"so_36608839_36608988_1\">Unless a class template specialization has been explicitly instantiated (14.7.2) or explicitly specialized (14.7.3),\n  the class template specialization is implicitly instantiated when the specialization is referenced in a context\n  that requires a completely-defined object type or when the completeness of the class type affects the semantics of the program. The implicit instantiation of a class template specialization causes the implicit\n  instantiation of the declarations, but <strong>not of the definitions</strong> or default arguments, of the class member functions, member classes, scoped member enumerations, static data members and member templates; ... Unless a member of a class template or a member template has been explicitly instantiated or explicitly\n  specialized, the specialization of the member is implicitly instantiated when the specialization is referenced\n  in a context that requires the member definition to exist; ...</p>\n</blockquote>\n", "LastActivityDate": "2016-04-13T20:30:19.083", "CommentCount": "1", "CreationDate": "2016-04-13T20:30:19.083", "ParentId": "36608839", "Score": "11", "OwnerUserId": "481267"}});