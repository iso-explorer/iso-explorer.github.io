post_cb({"43213997": {"CommentCount": "1", "AcceptedAnswerId": "43219391", "PostTypeId": "1", "LastEditorUserId": "3272850", "CreationDate": "2017-04-04T17:34:56.143", "LastActivityDate": "2017-04-06T01:13:46.743", "LastEditDate": "2017-04-05T16:15:33.810", "ViewCount": "411", "FavoriteCount": "4", "Title": "Why is gcc failing when using lambda for non-type template parameter?", "Id": "43213997", "Score": "15", "Body": "<p>The following snippet <a href=\"https://godbolt.org/#g:!((g:!((g:!((g:!((h:codeEditor,i:(j:1,source:'using+FuncT+%3D+int+(*)(double)%3B%0A%0Atemplate+%3CFuncT+FUNC%3E%0Aint+temp_foo(double+a)%0A%7B%0A++++return+FUNC(a)%3B%0A%7D%0A%0Aint+foo(double+a)%0A%7B%0A++++return+42%3B%0A%7D%0A%0Avoid+func()%0A%7B%0A++++auto+lambda+%3D+%5B%5D(double+a)+%7B+return+5%3B+%7D%3B%0A%0A++++struct+MyStruct%0A++++%7B%0A++++++++static+int+foo(double+a)+%7B+return+42%3B+%7D%0A++++%7D%3B%0A%0A++++temp_foo%3Cfoo%3E(3)%3B%0A++++temp_foo%3Cstatic_cast%3CFuncT%3E(lambda)%3E(3)%3B%0A++++temp_foo%3CMyStruct::foo%3E(3)%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',m:58.01526717557252,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1),l:'5',n:'0',o:'%231+with+x86-64+clang+4.0.0',t:'0')),l:'4',m:41.98473282442748,n:'0',o:'',s:0,t:'0')),k:55.705229793977814,l:'3',n:'0',o:'',t:'0'),(g:!((h:compiler,i:(compiler:clang400,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),options:'-std%3Dc%2B%2B1z',source:1),l:'5',n:'0',o:'x86-64+clang+4.0.0+(Editor+%231,+Compiler+%231)',t:'0')),k:44.294770206022186,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4\" rel=\"nofollow noreferrer\">compiles</a> with no error with Clang 4.0 but GCC 7.0 produces <a href=\"https://godbolt.org/#g:!((g:!((g:!((g:!((h:codeEditor,i:(j:1,source:'using+FuncT+%3D+int+(*)(double)%3B%0A%0Atemplate+%3CFuncT+FUNC%3E%0Aint+temp_foo(double+a)%0A%7B%0A++++return+FUNC(a)%3B%0A%7D%0A%0Aint+foo(double+a)%0A%7B%0A++++return+42%3B%0A%7D%0A%0Avoid+func()%0A%7B%0A++++auto+lambda+%3D+%5B%5D(double+a)+%7B+return+5%3B+%7D%3B%0A%0A++++struct+MyStruct%0A++++%7B%0A++++++++static+int+foo(double+a)+%7B+return+42%3B+%7D%0A++++%7D%3B%0A%0A++++temp_foo%3Cfoo%3E(3)%3B%0A++++temp_foo%3Cstatic_cast%3CFuncT%3E(lambda)%3E(3)%3B%0A++++temp_foo%3CMyStruct::foo%3E(3)%3B%0A%7D%0A'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',m:58.01526717557252,n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1),l:'5',n:'0',o:'%231+with+x86-64+gcc+7+(snapshot)',t:'0')),l:'4',m:41.98473282442748,n:'0',o:'',s:0,t:'0')),k:55.705229793977814,l:'3',n:'0',o:'',t:'0'),(g:!((h:compiler,i:(compiler:g7snapshot,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),options:'-std%3Dc%2B%2B1z',source:1),l:'5',n:'0',o:'x86-64+gcc+7+(snapshot)+(Editor+%231,+Compiler+%231)',t:'0')),k:44.294770206022186,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4\" rel=\"nofollow noreferrer\">errors</a> (note the use of -std=c++1z flag). </p>\n<pre><code>using FuncT = int (*)(double);\n\ntemplate &lt;FuncT FUNC&gt;\nint temp_foo(double a)\n{\n    return FUNC(a);\n}\n\nint foo(double a)\n{\n    return 42;\n}\n\nvoid func()\n{\n    auto lambda = [](double a) { return 5; };\n\n    struct MyStruct\n    {\n        static int foo(double a) { return 42; }\n    };\n\n    temp_foo&lt;foo&gt;(3);\n    temp_foo&lt;static_cast&lt;FuncT&gt;(lambda)&gt;(3);\n    temp_foo&lt;MyStruct::foo&gt;(3);\n}\n</code></pre>\n<p>Specifically, GCC complains that both the lambda and the nested class's method have no linkage, so they can't be used as a non-type template argument.</p>\n<p>At least for the lambda case I think that Clang is correct (and GCC is wrong) since (quoting from <a href=\"http://en.cppreference.com/w/cpp/language/lambda\" rel=\"nofollow noreferrer\">cppreference</a>, the conversion operator):</p>\n<blockquote>\n<p id=\"so_43213997_43213997_0\">The value returned by this conversion function is a pointer to a\n  function with C++ language linkage that, when invoked, has the same\n  effect as invoking the closure object's function call operator\n  directly.</p>\n</blockquote>\n<p>Is GCC misbehaving?</p>\n", "Tags": "<c++><templates><lambda><c++1z><non-type>", "OwnerUserId": "3272850", "AnswerCount": "2"}, "43238095": {"ParentId": "43213997", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I agree with <a href=\"https://stackoverflow.com/a/43219391/3272850\">Nir's answer</a> and wanted to add some information to it. He cites the relevant section in the standard (\u00a714.3.2 [temp.arg.nontype]) that shows that there is no longer a requirement for non-type parameters to have linkage, but that still doesn't show that GCC is misbehaving for the lambda part. For that we need to show that <code>static_cast&lt;FUNCT&gt;(lambda)</code> is a converted constant expression. For that we need a <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/n4618.pdf\" rel=\"nofollow noreferrer\">newer</a> draft from the one Nir linked. And this section</p>\n<p>\u00a75.1.5 Lambda expressions [expr.prim.lambda]:</p>\n<blockquote id=\"so_43213997_43238095_0\">\n<ol start=\"7\">\n<li>The closure type for a non-generic lambda-expression with no lambda-capture has a conversion function to pointer to function with\n  C++ language linkage (7.5) having the same parameter and return types\n  as the closure type\u2019s function call operator. [...] The conversion\n  function [...] is public, constexpr,\n  non-virtual, non-explicit, const, and has a non-throwing exception\n  specification.</li>\n</ol>\n</blockquote>\n<p>Interestingly enough, GCC <a href=\"https://gcc.gnu.org/projects/cxx-status.html\" rel=\"nofollow noreferrer\">claims</a> to have already implemented this (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4268.html\" rel=\"nofollow noreferrer\">N4268</a>) in the already released version 6 (in case you want to excuse GCC's behavior by saying that GCC 7 hasn't been officially released yet, so maybe when it will come out this will be fixed):</p>\n<pre><code>Language Feature                                               Proposal  Available in GCC?  SD-6 Feature Test\nAllow constant evaluation for all non-type template arguments  N4268     6                  __cpp_nontype_template_args &gt;= 201411\n</code></pre>\n<p>So in summary, this is a bug in GCC.</p>\n", "OwnerUserId": "3272850", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:34:24.333", "Id": "43238095", "Score": "2", "CreationDate": "2017-04-05T17:40:53.090", "LastActivityDate": "2017-04-06T01:13:46.743"}, "43219391": {"ParentId": "43213997", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>According to <a href=\"http://en.cppreference.com/w/cpp/language/template_parameters#Non-type_template_parameter\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/template_parameters#Non-type_template_parameter</a>, it seems like external linkage is no longer a requirement since C++17. The same language is found in the C++17 draft under [temp.arg.nontype] at <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf</a> (note that it is incorrectly linked as a C++14 draft).</p>\n<blockquote>\n<p id=\"so_43213997_43219391_0\">The template argument that can be used with a non-type template parameter can be any converted constant expression of the type of the template parameter...</p>\n<p id=\"so_43213997_43219391_1\">The only exceptions are that non-type template parameters of reference and pointer type cannot refer to/be the address of</p>\n<ul>\n<li>a subobject (including non-static class member, base subobject, or array \n  element);</li>\n<li>a temporary object (including one created during reference initialization);</li>\n<li>a string literal;</li>\n<li>the result of typeid;</li>\n<li>or the predefined variable __func__.</li>\n</ul>\n</blockquote>\n<p>That link on cppreference also specifically mentions function pointers, pre C++ 17:</p>\n<blockquote>\n<p id=\"so_43213997_43219391_2\">The following limitations apply when instantiating templates that have non-type template parameters: </p>\n<p id=\"so_43213997_43219391_3\">...</p>\n<p id=\"so_43213997_43219391_4\">For pointers to functions, the valid arguments are pointers to functions with linkage (or constant expressions that evaluate to null pointer values).</p>\n</blockquote>\n<p>Since your question is labelled C++1z (we should probably have a 17 tag by now and use that instead since 17 is finished) we should use the first set of rules. Your example does not seem to fall into any of the exception categories for C++ 17, and therefore gcc is in error.</p>\n<p>Note that clang does not compile your example if you change the language flag to 14.</p>\n", "OwnerUserId": "1908347", "LastEditorUserId": "1908347", "LastEditDate": "2017-04-05T15:22:36.250", "Id": "43219391", "Score": "4", "CreationDate": "2017-04-04T23:25:45.037", "LastActivityDate": "2017-04-05T15:22:36.250"}, "bq_ids": {"n4140": {"so_43213997_43213997_0": {"section_id": 5965, "quality": 0.7, "length": 14}, "so_43213997_43238095_0": {"section_id": 5965, "quality": 0.8181818181818182, "length": 27}, "so_43213997_43219391_0": {"section_id": 4706, "quality": 0.7142857142857143, "length": 10}}, "n3337": {"so_43213997_43213997_0": {"section_id": 5734, "quality": 0.7, "length": 14}, "so_43213997_43238095_0": {"section_id": 5734, "quality": 0.6060606060606061, "length": 20}, "so_43213997_43219391_0": {"section_id": 291, "quality": 0.5714285714285714, "length": 8}}, "n4659": {"so_43213997_43213997_0": {"section_id": 7456, "quality": 0.7, "length": 14}, "so_43213997_43238095_0": {"section_id": 7456, "quality": 0.7575757575757576, "length": 25}, "so_43213997_43219391_0": {"section_id": 6103, "quality": 0.6428571428571429, "length": 9}}}});