post_cb({"32539424": {"ParentId": "32537994", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2015-09-12T13:33:47.167", "Score": "2", "LastEditorUserId": "2069064", "LastEditDate": "2015-09-12T15:07:26.850", "Id": "32539424", "OwnerUserId": "2069064", "Body": "<p>A copy constructor is of the form <code>X(X&amp; )</code> or <code>(X const&amp;)</code>, and will be provided for you by the compiler if you didn't declare one yourself (or a few other conditions which are not relevant here). You didn't, so implicitly we have the following set of candidates:</p>\n<pre><code>MyTemplateClass(const MyTemplateClass&amp;);\ntemplate &lt;typename U&gt; MyTemplateClass(const MyTemplateClass&lt;U&gt;&amp;);\n</code></pre>\n<p>Both are viable for</p>\n<pre><code>MyTemplateClass&lt;int&gt; instance2(instance);\n</code></pre>\n<p>Both take the same exact arguments. The issue isn't that your copy constructor template doesn't <em>match</em>. The issue is that the implicit copy constructor is not a function template, and non-templates are preferred to template specializations when it comes to overload resolution. From [over.match.best], omitting the unrelated bullet points:</p>\n<blockquote>\n<p id=\"so_32537994_32539424_0\">Given these definitions, a viable function F1 is defined to be a better function than another viable function\n  F2 if for all arguments i, ICS<sub>i</sub>(F1) is not a worse conversion sequence than ICS<sub>i</sub>(F2), and then<br>\n  \u2014 [...]<br>\n  \u2014 F1 is not a function template specialization and F2 is a function template specialization, or, if not that,<br>\n  \u2014 [...]  </br></br></br></p>\n</blockquote>\n<p>That's why it calls your implicit (and then, your explicit) copy constructor over your constructor template. </p>\n", "LastActivityDate": "2015-09-12T15:07:26.850"}, "32538030": {"ParentId": "32537994", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-09-12T10:59:30.763", "Score": "2", "LastEditorUserId": "963881", "LastEditDate": "2015-09-12T11:04:42.160", "Id": "32538030", "OwnerUserId": "963881", "Body": "<p>When you do not have a copy constructor in you code, the compiler will implicitly generate it. Therefore when this line is executed:</p>\n<pre><code>MyTemplateClass&lt;int&gt; instance2(instance);\n</code></pre>\n<p>A copy constructor <em>is</em> being executed, though obviously not yours. I think that templating has nothing to do with it.</p>\n<p>Read more about it here: <a href=\"http://en.cppreference.com/w/cpp/language/copy_constructor#Implicitly-defined_copy_constructor\" rel=\"nofollow\">Implicitly-defined copy constructor</a></p>\n", "LastActivityDate": "2015-09-12T11:04:42.160"}, "32537994": {"CommentCount": "3", "ViewCount": "2185", "CreationDate": "2015-09-12T10:55:37.210", "LastActivityDate": "2015-09-12T18:56:40.693", "Title": "c++ template copy constructor on template class", "AcceptedAnswerId": "32539424", "PostTypeId": "1", "Id": "32537994", "Score": "5", "Body": "<p>I have a template class that has a template copy constructor. The problem is when I instantiate this class using another instance of this class with the same template type, my template copy constructor is not called. Why doesn't it match ?\nHere is the code snippet:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nclass MyTemplateClass\n{\n    public:\n        MyTemplateClass()\n        {\n            std::cout &lt;&lt; \"default constructor\" &lt;&lt; std::endl;\n        }\n\n        /*\n        MyTemplateClass(const MyTemplateClass&lt;T&gt;&amp; other)\n        {\n            std::cout &lt;&lt; \"copy constructor\" &lt;&lt; std::endl;\n        }\n        */\n\n        template &lt;typename U&gt;\n        MyTemplateClass(const MyTemplateClass&lt;U&gt;&amp; other)\n        {\n            std::cout &lt;&lt; \"template copy constructor\" &lt;&lt; std::endl;\n        }\n};\n\nint main()\n{\n    MyTemplateClass&lt;int&gt; instance;\n    MyTemplateClass&lt;int&gt; instance2(instance);\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>The output is </p>\n<pre><code>default constructor\n</code></pre>\n<p>But if I explicitly write the default copy constructor (by uncommenting it), then the output becomes</p>\n<pre><code>default constructor\ncopy constructor\n</code></pre>\n<p>I really don't get it. I tested it with my local compiler (clang-500.2.79) and with <a href=\"http://www.tutorialspoint.com/compile_cpp11_online.php\" rel=\"noreferrer\" title=\"here\">this one</a> (gcc 4.9.2) and got the same result.</p>\n", "Tags": "<c++><templates><copy-constructor>", "OwnerUserId": "5328162", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_32537994_32539424_0": {"section_id": 603, "quality": 0.8846153846153846, "length": 23}}, "n3337": {"so_32537994_32539424_0": {"section_id": 593, "quality": 0.8076923076923077, "length": 21}}, "n4659": {"so_32537994_32539424_0": {"section_id": 629, "quality": 0.8846153846153846, "length": 23}}}, "32538529": {"ParentId": "32537994", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-09-12T12:00:03.917", "Score": "-1", "LastEditorUserId": "4235856", "LastEditDate": "2015-09-12T18:56:40.693", "Id": "32538529", "OwnerUserId": "4235856", "Body": "<p>I think REACHUS is right, the compiler is generating a default copy-constructor (as it would with a non-template class too) and preferring this over your template as it's more specialised. You should make your \"normal\" copy-constructor private, or better, use the C++11 'deleted' keyword to mark the function as unusable. EDIT: This doesn't compile, sorry, I wasn't able to test it at the time.</p>\n", "LastActivityDate": "2015-09-12T18:56:40.693"}});