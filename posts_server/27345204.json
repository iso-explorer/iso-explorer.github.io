post_cb({"27345204": {"ViewCount": "39", "Body": "<p>Assuming a class A has a member variable(which is an object rather than a reference) m. Naturally I will think that:\nWhen I defined an object 'o1', then the Expression 'o1.m' is an object type either;\nWhen I defined a reference 'q1', then the Expression 'q1.m' is a reference type either.</p>\n<p>Is that conclusion correct? I'm wondering what any relative clauses are in C++ standard document if it is true(I've been searching for it/them for one more days already but got almost all about 'reference as member of class' so far)?</p>\n", "AcceptedAnswerId": "27345362", "Title": "Part of an object or reference", "CreationDate": "2014-12-07T17:01:56.103", "Id": "27345204", "CommentCount": "9", "PostTypeId": "1", "LastActivityDate": "2014-12-07T17:51:23.217", "Score": "0", "OwnerUserId": "2848654", "Tags": "<c++><reference-type><member-variables>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_27345204_27345362_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 6006}, "so_27345204_27345362_1": {"length": 14, "quality": 1.0, "section_id": 6007}}, "n3337": {"so_27345204_27345362_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 5774}, "so_27345204_27345362_1": {"length": 14, "quality": 1.0, "section_id": 5775}}, "n4659": {"so_27345204_27345362_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 7505}, "so_27345204_27345362_1": {"length": 14, "quality": 1.0, "section_id": 7506}}}, "27345362": {"Id": "27345362", "PostTypeId": "2", "Body": "<p>Take a look at <strong>\u00a75.2.5</strong> (<em>Class member access</em> in <em>Postfix Expressions</em>, from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow\">N3797 C++14 Draft</a>):</p>\n<blockquote>\n<p id=\"so_27345204_27345362_0\">Abbreviating postfix-expression.id-expression as E1.E2, E1 is called the object expression. The type and value category of E1.E2 are determined as follows. In the remainder of 5.2.5, cq represents either const or the absence of const and vq represents either volatile or the absence of volatile. cv represents an\n  arbitrary set of cv-qualifiers, as defined in 3.9.3.</p>\n<p id=\"so_27345204_27345362_1\">If E2 is declared to have type \u201creference to T,\u201d then E1.E2 is an lvalue; the type of E1.E2 is T. Otherwise,\n  one of the following rules applies.</p>\n<ul>\n<li>If E2 is a non-static data member and the type of E1 is \u201ccq1 vq1 X\u201d, and the type of E2 is \u201ccq2 vq2 T\u201d, the expression designates the named member of the object designated by the first expression. If E1 is an lvalue, then E1.E2 is an lvalue; otherwise E1.E2 is an xvalue. Let the notation vq12 stand for the \u201cunion\u201d of vq1 and vq2 ; that is, if vq1 or vq2 is volatile, then vq12 is volatile. Similarly, let the notation cq12 stand for the \u201cunion\u201d of cq1 and cq2 ; that is, if cq1 or cq2 is const, then cq12 is const. If E2 is declared to be a mutable member, then the type of E1.E2 is \u201cvq12 T\u201d. If E2 is not declared to be a mutable member, then the type of E1.E2 is \u201ccq12 vq12 T\u201d.</li>\n</ul>\n</blockquote>\n<p>The standard says nothing about E2 becoming a reference even if E1 is. To be explicit, if E1 is a reference type and E2 is not, E1.E2 is not a reference type.</p>\n", "LastEditorUserId": "2228299", "LastActivityDate": "2014-12-07T17:51:23.217", "Score": "2", "CreationDate": "2014-12-07T17:15:31.383", "ParentId": "27345204", "CommentCount": "1", "OwnerUserId": "2228299", "LastEditDate": "2014-12-07T17:51:23.217"}});