post_cb({"12638393": {"ViewCount": "999", "Body": "<p>$ 20.8.2 of the standard describes the INVOKE facility that is mostly used to describe how callables are called with variadic argument lists throughout the standard library:</p>\n<blockquote>\n<p id=\"so_12638393_12638393_0\">Define INVOKE (f, t1, t2, ..., tN) as follows:</p>\n<p id=\"so_12638393_12638393_1\">\u2014 <code>(t1.*f)(t2, ..., tN)</code> when f is a pointer to a member function of a class T and t1 is an object of\n  type T or a reference to an object of type T or a reference to an object of a type derived from T;</p>\n<p id=\"so_12638393_12638393_2\">\u2014 <code>((*t1).*f)(t2, ..., tN)</code> when f is a pointer to a member function of a class T and t1 is not one of\n  the types described in the previous item;</p>\n<p id=\"so_12638393_12638393_3\">\u2014 <code>t1.*f</code> when N == 1 and f is a pointer to member data of a class T and t1 is an object of type T or a\n  reference to an object of type T or a reference to an object of a type derived from T;</p>\n<p id=\"so_12638393_12638393_4\">\u2014 <code>(*t1).*f</code> when N == 1 and f is a pointer to member data of a class T and t1 is not one of the types\n  described in the previous item;</p>\n<p id=\"so_12638393_12638393_5\">\u2014 <code>f(t1, t2, ..., tN)</code> in all other cases.</p>\n</blockquote>\n<p>What are the third and the fourth item for? As far as I can tell, they don't call <code>f</code> even if <code>f</code> is callable. What's the user case for them. Maybe it's a typo in the standard and <code>*f()</code> was intended?</p>\n", "AcceptedAnswerId": "12638715", "Title": "Why does INVOKE facility in the C++11 standard refer to data members?", "CreationDate": "2012-09-28T10:37:05.477", "Id": "12638393", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-09-28T10:43:42.347", "LastEditorUserId": "500104", "LastActivityDate": "2012-09-28T10:59:33.837", "Score": "3", "OwnerUserId": "1356084", "Tags": "<c++><c++11><standards>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_12638393_12638715_1": {"length": 18, "quality": 0.8181818181818182, "section_id": 4643}, "so_12638393_12638393_4": {"length": 11, "quality": 1.0, "section_id": 4560}, "so_12638393_12638393_5": {"length": 4, "quality": 1.0, "section_id": 4560}, "so_12638393_12638393_2": {"length": 11, "quality": 1.0, "section_id": 4560}, "so_12638393_12638393_1": {"length": 15, "quality": 1.0, "section_id": 4560}, "so_12638393_12638393_3": {"length": 15, "quality": 1.0, "section_id": 4560}}, "n3337": {"so_12638393_12638715_1": {"length": 18, "quality": 0.8181818181818182, "section_id": 4454}, "so_12638393_12638393_4": {"length": 11, "quality": 1.0, "section_id": 4390}, "so_12638393_12638393_5": {"length": 4, "quality": 1.0, "section_id": 4390}, "so_12638393_12638393_2": {"length": 11, "quality": 1.0, "section_id": 4390}, "so_12638393_12638393_1": {"length": 15, "quality": 1.0, "section_id": 4390}, "so_12638393_12638393_3": {"length": 15, "quality": 1.0, "section_id": 4390}}, "n4659": {"so_12638393_12638715_1": {"length": 14, "quality": 0.6363636363636364, "section_id": 6386}, "so_12638393_12638393_4": {"length": 7, "quality": 0.6363636363636364, "section_id": 5932}, "so_12638393_12638393_5": {"length": 4, "quality": 1.0, "section_id": 5932}, "so_12638393_12638393_2": {"length": 7, "quality": 0.6363636363636364, "section_id": 5932}, "so_12638393_12638393_1": {"length": 9, "quality": 0.6, "section_id": 7709}, "so_12638393_12638393_3": {"length": 9, "quality": 0.6, "section_id": 7709}}}, "12638715": {"Id": "12638715", "PostTypeId": "2", "Body": "<p><code>INVOKE</code> is specified like that because you can actually bind member data pointers (through <code>bind</code> and <code>mem_fn</code>):</p>\n<p><code>\u00a720.8.10 [func.memfn]</code></p>\n<blockquote>\n<p id=\"so_12638393_12638715_0\"><code>template&lt;class R, class T&gt;</code><br>\n<em><code>unspecified</code></em><code>mem_fn(R T::* pm);</code></br></p>\n<p id=\"so_12638393_12638715_1\">p1 <em>Returns:</em> A simple call wrapper (20.8.1) <code>fn</code> such that the expression <code>fn(t, a2, ..., aN)</code> is equivalent to <code>INVOKE(pm, t, a2, ..., aN)</code> (20.8.2). <code>fn</code> shall have a nested type <code>result_type</code> that is a synonym for the return type of <code>pm</code> <strong>when <code>pm</code> is a pointer to member function</strong>.</p>\n</blockquote>\n<p>I don't think that special wording would exist if you couldn't bind member data pointers.</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\nstruct X{\n  int n = 5;\n};\n\nint main(){\n  X x;\n  auto f = std::mem_fn(&amp;X::n);\n  std::cout &lt;&lt; f(&amp;x) &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Output: 5</p>\n<p><a href=\"http://liveworkspace.org/code/e62e72d203d9da6d918af1e5601384c5\">Live example.</a></p>\n", "LastActivityDate": "2012-09-28T10:59:33.837", "CommentCount": "2", "CreationDate": "2012-09-28T10:59:33.837", "ParentId": "12638393", "Score": "7", "OwnerUserId": "500104"}});