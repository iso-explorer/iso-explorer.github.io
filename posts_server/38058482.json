post_cb({"38059361": {"ParentId": "38058482", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It is undefined what happens to the memory you have not written to.  The compiler may choose to leave its contents untouched.  It may (e.g. for performance reasons) overwrite the previous contents with arbitrary values.</p>\n<p>It is Unspecified Behaviour to read from <code>foo.i</code> after writing <code>foo.a</code> for exactly this reason.</p>\n", "OwnerUserId": "4850040", "LastEditorUserId": "4850040", "LastEditDate": "2016-06-27T20:54:07.697", "Id": "38059361", "Score": "2", "CreationDate": "2016-06-27T16:57:12.120", "LastActivityDate": "2016-06-27T20:54:07.697"}, "bq_ids": {"n4140": {"so_38058482_38059960_1": {"section_id": 5913, "quality": 0.9473684210526315, "length": 54}}, "n3337": {"so_38058482_38059960_1": {"section_id": 5685, "quality": 0.9473684210526315, "length": 54}}, "n4659": {"so_38058482_38059960_1": {"section_id": 7404, "quality": 0.9298245614035088, "length": 53}}}, "38059960": {"ParentId": "38058482", "CommentCount": "0", "Body": "<p>Interestingly, the C11 standard is very clear about this in 6.2.6.1.7:</p>\n<blockquote>\n<p id=\"so_38058482_38059960_0\">When a value is stored in a member of an object of union type, the bytes of the object representation that do not correspond to that member but do correspond to other members take <strong>unspecified values</strong>.</p>\n</blockquote>\n<p>Unfortunately, I have not found anything as clear in the C++14 standard. Section 9.5.:</p>\n<blockquote>\n<p id=\"so_38058482_38059960_1\">In a union, at most one of the non-static data members can be active at any time, that is, the value of at\n  most one of the non-static data members can be stored in a union at any time. [ Note: One special guarantee\n  is made in order to simplify the use of unions: If a standard-layout union contains several standard-layout\n  structs that share a common initial sequence (9.2), and if an object of this standard-layout union type\n  contains one of the standard-layout structs, it is <strong>permitted to inspect the common initial sequence</strong> of any of\n  standard-layout struct members; see 9.2. \u2014 end note ]</p>\n</blockquote>\n<p>This guarantee is oddly specific, I cannot find any guarantee regarding <em>layout-compatible members</em>. Nevertheless, two types of different size are not <em>layout-compatible</em>, could not be part of a <em>common initial sequences</em>. So I guess the standard would <strong>not permit to inspect the inactive members</strong>.</p>\n<p>That would be a case towards <strong>undefined behavior</strong> when accessing the values, although I would believe that <strong>unspecified values</strong> make more sense.</p>\n", "OwnerUserId": "620382", "PostTypeId": "2", "Id": "38059960", "Score": "1", "CreationDate": "2016-06-27T17:35:49.213", "LastActivityDate": "2016-06-27T17:35:49.213"}, "38058482": {"CommentCount": "7", "ViewCount": "75", "PostTypeId": "1", "LastEditorUserId": "4850040", "CreationDate": "2016-06-27T16:01:20.280", "LastActivityDate": "2016-06-27T20:54:07.697", "Title": "What are the contents of unused memory in unions?", "LastEditDate": "2016-06-27T16:55:20.953", "Id": "38058482", "Score": "-1", "Body": "<p>Suppose I have a union:</p>\n<pre><code>union foo {\n    char a;\n    int i;\n}\n</code></pre>\n<p>on a platform where <code>sizeof foo.i</code> &gt; <code>sizeof foo.a</code>.</p>\n<p>If I assign to <code>foo.a</code>, what happens to the rest of the memory which was previously part of <code>foo.i</code>?</p>\n", "Tags": "<c++><unions><stack-memory>", "OwnerUserId": "5740666", "AnswerCount": "2"}});