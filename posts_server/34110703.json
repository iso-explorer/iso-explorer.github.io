post_cb({"bq_ids": {"n4140": {"so_34110703_34110836_0": {"length": 29, "quality": 1.0, "section_id": 5404}}, "n3337": {"so_34110703_34110836_0": {"length": 29, "quality": 1.0, "section_id": 5199}}, "n4659": {"so_34110703_34110836_0": {"length": 29, "quality": 1.0, "section_id": 6853}}}, "34110703": {"ViewCount": "116", "Body": "<p>In Agner Fog's <a href=\"http://www.agner.org/optimize/optimizing_cpp.pdf\" rel=\"nofollow noreferrer\">Optimizing C++ manual</a> he has a section \"Inlined functions have a non-inlined copy\" where he writes</p>\n<blockquote>\n<p id=\"so_34110703_34110703_0\">Function inlining has the complication that the same function may be called from another module. The compiler has to make a non-inlined copy of the inlined function for the sake of the possibility that the function is also called from another module. This non-inlined copy is dead code if no other modules call the function. This fragmentation of the code makes caching less efficient.</p>\n</blockquote>\n<p>Let's make a test for this.</p>\n<p><strong>foo.h</strong></p>\n<pre><code>inline double foo(double x) {\n    return x;\n}\n</code></pre>\n<p><strong>t1.cpp</strong> </p>\n<pre><code>#include \"foo.h\"\ndouble t1(double x) {\n    return foo(x);\n}\n</code></pre>\n<p><strong>main.cpp</strong></p>\n<pre><code>#include &lt;stdio.h&gt;\nextern double foo(double);\n\nint main(void) {\n    printf(\"%f\\n\", foo(3.14159));\n}\n</code></pre>\n<p>compile with <code>g++ t1.cpp main.cpp</code> and it runs correctly.  If I do <code>g++ -S t1.cpp main.cpp</code> and look at the assembly I see that <code>main.s</code> calls a function defined in <code>t1.s</code>.  Doing <code>g++ -c main.cpp</code> and <code>g++ t1.cpp</code> and looking at the symbols with <code>nm</code> shows <code>U _Z3food</code> in <code>main.o</code> and <code>W _Z3food</code> in <code>t1.o</code>.  So it's clear that Agner's claim of there being a non-inlined copy is correct.</p>\n<p>What about with <code>g++ -O1 t1.cpp main.cpp</code>? <strong>This fails to compile due to <code>foo</code> being undefined.</strong>  Doing <code>g++ -O1 t1.cpp</code> and <code>nm t1.o</code> shows that <code>_Z3food</code> has been stripped out.  </p>\n<p>Now I am confused.  I did not expect g++ to remove the non-inline copy with optimization enabled. </p>\n<p>It seems that with optimization enabled <code>inline</code> is equivalent to <code>static inline</code>.  But without optimization <code>inline</code> means there is a non-inline copy generated.</p>\n<p>Maybe GCC does not think I would ever want the non-inline copy.  But I can think of a case. Let's say  I wanted to create a library and in the library I want a function defined in multiple translation units (so that the compiler could inline the code for the function in each translation unit) but I also want an external module linking to my library to be able to call the function defined in the library. I would obviously need a non-inlined version of the function for this.</p>\n<p>One suggestion Agner gives if I don't want the non-inline copy is to use <code>static inline</code>. But from this <a href=\"https://stackoverflow.com/questions/10876930/should-one-never-use-static-inline-function\">question and answers</a> I infer that this is only useful to show intent. So on the one hand it's clear it's more than just intent without using optimization since it makes a non-inline copy. But on the other had, with optimization it really only seems to show intent since the non-inline copy is stripped away. This is confusing.</p>\n<p>My questions:</p>\n<ol>\n<li>Is GCC correct in stripping away the non-inline copy with optimization enabled? In other words should there always be a non-inline copy if I don't use <code>static inline</code>?</li>\n<li>If I want to be certain that there is not a non-inline copy should I use <code>static inline</code>?</li>\n</ol>\n<hr>\n<p>I just realized that I could have misinterpreted Agner's statement.  When he says function inlinng he may be referering to the compiler inclining the code and not to the use of the <code>inline</code> keyword. In other words he could be referring to functions defined with <code>extern</code> and not with <code>inline</code> or <code>static</code>.</p>\n<p>for example</p>\n<pre><code>//foo.cpp\nint foo(int x) {\n    return x;\n}\n\nfloat bar(int x) {\n    return 1.0*foo(x);\n}\n</code></pre>\n<p>and </p>\n<pre><code>//main.cpp\n#include &lt;stdio.h&gt;    \nextern float bar(int x);    \nint main(void) {\n    printf(\"%f\\n\", bar(3));\n}\n</code></pre>\n<p>compile with <code>gcc -O3 foo.cpp main.cpp</code> shows that <code>foo</code> was inline in <code>bar</code> but that a non-inlined copy of <code>foo</code> which is never used is in the binary.</p>\n</hr>", "AcceptedAnswerId": "34110836", "Title": "Inlined functions have a non-inlined copy", "CreationDate": "2015-12-05T20:49:13.930", "Id": "34110703", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:29:50.780", "LastEditorUserId": "-1", "LastActivityDate": "2015-12-28T15:31:51.213", "Score": "3", "OwnerUserId": "2542702", "Tags": "<c++><gcc><inline>", "AnswerCount": "1"}, "34110836": {"Id": "34110836", "PostTypeId": "2", "Body": "<p>The standard says that the full definition of an <code>inline</code> method needs to be visible in every translation unit that uses it:</p>\n<blockquote>\n<p id=\"so_34110703_34110836_0\">An inline function shall be defined in every translation unit in which it is odr-used and shall have exactly\n  the same definition in every case (3.2). [...] If a function with external linkage is\n  declared inline in one translation unit, it shall be declared inline in all translation units in which it appears;\n  no diagnostic is required.</p>\n</blockquote>\n<p>(7.1.2/4 in N4140)</p>\n<p>This does indeed make the example in your question ill-formed.</p>\n<p>This rule also includes every TU from whatever external module is linking your library. They would also need the full definition in C++ code, e.g. by defining the function in a header. So a compiler can safely omit any kind of <em>\"non-inlined copy\"</em> if the current translation does not need it.</p>\n<p>Concerning being certain the copy does not exist: The standard does not guarantee any optimization, so that is up to the compiler. Both with and without an additional <code>static</code> keyword.</p>\n", "LastEditorUserId": "3002139", "LastActivityDate": "2015-12-05T21:20:31.460", "Score": "6", "CreationDate": "2015-12-05T21:01:32.453", "ParentId": "34110703", "CommentCount": "14", "OwnerUserId": "3002139", "LastEditDate": "2015-12-05T21:20:31.460"}});