post_cb({"bq_ids": {"n4140": {"so_30695810_30696007_0": {"length": 24, "quality": 1.0, "section_id": 6325}}, "n3337": {"so_30695810_30696007_0": {"length": 24, "quality": 1.0, "section_id": 6082}}, "n4659": {"so_30695810_30696007_0": {"length": 24, "quality": 1.0, "section_id": 7835}}}, "30696007": {"Id": "30696007", "PostTypeId": "2", "Body": "<p>It's a condition to handle the case where the element you're trying to insert already exists in the <code>vector</code>. </p>\n<p>To explain this, let's start with defining the variables being used in the function.</p>\n<ul>\n<li><code>__p</code> is a pointer to the position where you want to insert the new element</li>\n<li><code>__xr</code> is a pointer to the address of the element you want to insert</li>\n</ul>\n<p>The code path you're asking about is executed when the <code>vector</code> has sufficient capacity to insert an additional element (<code>if (this-&gt;__end_ &lt; this-&gt;__end_cap())</code>). Also, the insertion point is not the <code>end()</code> iterator (<code>if (__p == this-&gt;__end_)</code> \u2014 the <code>else</code> path is executed).</p>\n<p>In this case, the implementation first moves everything in the range <code>[__p, end())</code> one position further \u2014 <code>__move_range(__p, this-&gt;__end_, __p + 1);</code></p>\n<p>But what if the element you're trying to insert was part of the range that just got moved? If so, you must increment the pointer to the element to be inserted. That is what the following lines do</p>\n<pre><code>if (__p &lt;= __xr &amp;&amp; __xr &lt; this-&gt;__end_)\n  ++__xr;\n</code></pre>\n<p>The rvalue reference overload isn't doing the same checks because the implementation is allowed to assume that any object referred to by an rvalue reference is uniquely referenced, so trying to perform an <code>insert</code> with an rvalue reference to an element that already exists in the <code>vector</code> is undefined behavior.</p>\n<p>From N3337, <em>\u00a717.6.4.9/1 [res.on.arguments]</em></p>\n<blockquote>\n<p id=\"so_30695810_30696007_0\">Each of the following applies to all arguments to functions defined in the C++ standard library, unless explicitly stated otherwise.<br/>\n  \u2014 ...<br/>\n  \u2014 If a function argument binds to an rvalue reference parameter, the implementation may assume that this parameter is a unique reference to this argument.</p>\n</blockquote>\n<p>Here's the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#1204\">defect report</a> and rationale for the above clause.</p>\n", "LastEditorUserId": "241631", "LastActivityDate": "2015-06-07T16:54:16.333", "Score": "8", "CreationDate": "2015-06-07T16:44:23.630", "ParentId": "30695810", "CommentCount": "3", "OwnerUserId": "241631", "LastEditDate": "2015-06-07T16:54:16.333"}, "30695810": {"ViewCount": "278", "Body": "<p>The <code>std::vector</code> <a href=\"http://llvm.org/svn/llvm-project/libcxx/trunk/include/vector\" rel=\"nofollow\">implementation</a> of libc++ has the following overloads of <code>insert</code>:</p>\n<pre><code>template &lt;class _Tp, class _Allocator&gt;\ntypename vector&lt;_Tp, _Allocator&gt;::iterator\nvector&lt;_Tp, _Allocator&gt;::insert(const_iterator __position, const_reference __x)\n{\n    pointer __p = this-&gt;__begin_ + (__position - begin());\n    if (this-&gt;__end_ &lt; this-&gt;__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this-&gt;__end_)\n        {\n            __alloc_traits::construct(this-&gt;__alloc(),\n                                      _VSTD::__to_raw_pointer(this-&gt;__end_), __x);\n            ++this-&gt;__end_;\n        }\n        else\n        {\n            __move_range(__p, this-&gt;__end_, __p + 1);\n            const_pointer __xr = pointer_traits&lt;const_pointer&gt;::pointer_to(__x);\n            if (__p &lt;= __xr &amp;&amp; __xr &lt; this-&gt;__end_) // [*]\n                ++__xr;\n            *__p = *__xr;\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type&amp; __a = this-&gt;__alloc();\n        __split_buffer&lt;value_type, allocator_type&amp;&gt; __v(__recommend(size() + 1), __p - this-&gt;__begin_, __a);\n        __v.push_back(__x);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n</code></pre>\n<p>... and a similar, taking an rvalue reference:</p>\n<pre><code>template &lt;class _Tp, class _Allocator&gt;\ntypename vector&lt;_Tp, _Allocator&gt;::iterator\nvector&lt;_Tp, _Allocator&gt;::insert(const_iterator __position, value_type&amp;&amp; __x)\n{\n    pointer __p = this-&gt;__begin_ + (__position - begin());\n    if (this-&gt;__end_ &lt; this-&gt;__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this-&gt;__end_)\n        {\n            __alloc_traits::construct(this-&gt;__alloc(),\n                                      _VSTD::__to_raw_pointer(this-&gt;__end_),\n                                      _VSTD::move(__x));\n            ++this-&gt;__end_;\n        }\n        else\n        {\n            __move_range(__p, this-&gt;__end_, __p + 1);\n            *__p = _VSTD::move(__x);\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type&amp; __a = this-&gt;__alloc();\n        __split_buffer&lt;value_type, allocator_type&amp;&gt; __v(__recommend(size() + 1), __p - this-&gt;__begin_, __a);\n        __v.push_back(_VSTD::move(__x));\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n</code></pre>\n<p>What is the purpose of the branch marked with <code>[*]</code> in the first overload? Is it required by the standard? Why is it absent in the second overload? I couldn't find the equivalent construct in <code>libstdc++</code>.</p>\n<p><strong>Edit</strong>: <code>libstdc++</code> <a href=\"https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/vector.tcc#L127\" rel=\"nofollow\">solves</a> the same problem by creating a temporary copy.</p>\n", "AcceptedAnswerId": "30696007", "Title": "libc++ difference between vector::insert overloads", "CreationDate": "2015-06-07T16:23:19.433", "Id": "30695810", "CommentCount": "1", "LastEditDate": "2015-06-08T02:46:05.437", "PostTypeId": "1", "LastEditorUserId": "241631", "LastActivityDate": "2015-06-08T02:46:05.437", "Score": "5", "OwnerUserId": "116273", "Tags": "<c++><c++11><vector><libc++>", "AnswerCount": "1"}});