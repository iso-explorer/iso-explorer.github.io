post_cb({"27744079": {"CommentCount": "0", "ViewCount": "1958", "PostTypeId": "1", "LastEditorUserId": "1708801", "LastActivityDate": "2015-12-14T16:32:22.540", "Body": "<p><code>gcc</code> compiles the following code without warning:</p>\n<pre><code>#include &lt;cmath&gt;\n\nstruct foo {\n  static constexpr double a = std::cos(3.);\n  static constexpr double c = std::exp(3.);\n  static constexpr double d = std::log(3.);\n  static constexpr double e1 = std::asin(1.);\n  static constexpr double h = std::sqrt(.1);\n  static constexpr double p = std::pow(1.3,-0.75);\n};\n\nint main()\n{\n}\n</code></pre>\n<p>None of the standard library functions used above are <em>constexpr functions</em>, we are allowed to use them where a <em>constant expression</em> is required from both <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\">the draft C++11 standard</a> and <a href=\"https://github.com/cplusplus/draft/blob/b7b8ed08ba4c111ad03e13e8524a1b746cb74ec6/papers/N3936.pdf\">draft C++14 standard</a> section <code>7.1.5</code> <em>[dcl.constexpr]</em>:</p>\n<blockquote>\n<p id=\"so_27744079_27744079_0\">[...]If it is initialized by a constructor call, that call shall be a\n  constant expression (5.19). Otherwise, or if a constexpr specifier is\n  used in a reference declaration, every full expression that appears in\n  its initializer shall be a constant expression.[...]</p>\n</blockquote>\n<p>Even when using <code>-std=c++14 -pedantic</code>  or <code>-std=c++11 -pedantic</code> no warnings are generated (<em><a href=\"http://coliru.stacked-crooked.com/a/d6320f90f8e868b6\">see it live</a></em>). Using <code>-fno-builtin</code> produces errors (<em><a href=\"http://coliru.stacked-crooked.com/a/d5a8fdfc9783014c\">see it live</a></em>) which indicates that the <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html\">builtin</a> version of these standard library functions are being treated as if they where <em>constexpr</em></p>\n<p>While <code>clang</code> does not allow the code with any combination of flags I have tried. </p>\n<p>So this is a <code>gcc</code> extension to treat at least some builtin functions as if they were <em>constexpr functions</em> even though the standard does not explicitly require them to be. I would have expected to at least receive a warning in strict conformance mode, is this a conforming extension?</p>\n", "Title": "Is it a conforming compiler extension to treat non-constexpr standard library functions as constexpr?", "FavoriteCount": "4", "LastEditDate": "2015-12-14T16:32:22.540", "Id": "27744079", "Score": "33", "CreationDate": "2015-01-02T14:58:25.397", "Tags": "<c++><c++11><gcc><language-lawyer><c++14>", "OwnerUserId": "1708801", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_27744079_27744080_1": {"section_id": 6343, "quality": 1.0, "length": 11}, "so_27744079_27744079_0": {"section_id": 5425, "quality": 0.85, "length": 17}}, "n3337": {"so_27744079_27744079_0": {"section_id": 5220, "quality": 0.85, "length": 17}}, "n4659": {"so_27744079_27744080_3": {"section_id": 7709, "quality": 0.5454545454545454, "length": 6}, "so_27744079_27744080_1": {"section_id": 7852, "quality": 1.0, "length": 11}}}, "27744080": {"ParentId": "27744079", "LastEditDate": "2017-05-23T12:02:44.547", "CommentCount": "5", "CreationDate": "2015-01-02T14:58:25.397", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "27744080", "Score": "33", "Body": "<p><b>TL;DR</b></p>\n<p>In C++14 this is explicitly not allowed, although in <code>2011</code> it appeared like this case would be explicitly allowed. It is unclear if for C++11 this fell under the <a href=\"http://en.cppreference.com/w/cpp/language/as_if\" rel=\"nofollow noreferrer\">as-if rule</a>, I don't believe it does since it alters observable behavior but that point was not clarified in the issue I reference below.</p>\n<p><b>Details</b></p>\n<p>The answer to this question has shifted with the evolving status of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3788.html#2013\" rel=\"nofollow noreferrer\">LWG issue 2013</a> which opens with:</p>\n<blockquote>\n<p id=\"so_27744079_27744080_0\">Suppose that a particular function is not tagged as constexpr in the\n  standard, but that, in some particular implementation, it is possible\n  to write it within the constexpr constraints. If an implementer tags\n  such a function as constexpr, is that a violation of the standard or\n  is it a conforming extension?</p>\n</blockquote>\n<p>In C++11 it was unclear if the <em>as-if rule</em> permitted this but the orignal proposal would have explicitly allowed it once it was accepted and we can see below in the gcc bug report I reference, this was the assumption made by the gcc team.</p>\n<p>The consensus to allow this shifted in 2012 and the proposal changed and in C++14 this is a non-conforming extension. This is reflected in the draft C++14 standard section <code>17.6.5.6</code> <em>[constexpr.functions]</em> which says:</p>\n<blockquote>\n<p id=\"so_27744079_27744080_1\">[...]An implementation shall not declare any standard library function\n  signature as constexpr except for those where it is explicitly\n  required.[..]</p>\n</blockquote>\n<p>and although a strict reading of this seems to leave some wiggle room for treating a builtin implicitly as if it were a constexpr we can see from the following quote in the issue that the intention was to prevent divergence in implementations since identical code could produce different behavior when using <em>SFINAE</em> (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_27744079_27744080_2\">Some concern expressed when presented to full committee for the vote\n  to WP status that this issue had been resolved without sufficient\n  thought of the consequences for <strong>diverging library implementations, as\n  users may use SFINAE to observe different behavior from otherwise\n  identical code</strong>.</p>\n</blockquote>\n<p>We can see from the gcc bug report <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=49813\" rel=\"nofollow noreferrer\">[C++0x] sinh vs asinh vs constexpr</a> that the team relied on the earlier proposed resolution of <a href=\"http://lwg.github.io/issues/lwg-active.html#2013\" rel=\"nofollow noreferrer\">LWG 2013</a> which says:</p>\n<blockquote>\n<p id=\"so_27744079_27744080_3\">[...]Additionally, an implementation may declare any function to be\n  constexpr if that function's definition satisfies the necessary\n  constraints[...]</p>\n</blockquote>\n<p>when deciding whether this change for the math functions was allowed in strict conformance mode.</p>\n<p>As far as I can tell this would become conforming if this we received a warning in strict conformance mode i.e. using <code>-std=c++11 -pedantic</code> or if it was disabled in this mode.</p>\n<p>Note, I added a comment to the bug report explaining that the resolution changed since this issue was originally addressed.</p>\n<p>Jonathan Wakely <a href=\"https://stackoverflow.com/questions/22182432/is-gcc-considering-builtins-of-non-constant-expression-functions-to-be-constant#comment44214059_27906899\">pointed out</a> in another question a more recent <a href=\"https://gcc.gnu.org/ml/libstdc++/2014-09/msg00004.html\" rel=\"nofollow noreferrer\">discussion</a> and it seems likely the gcc bug report will be reopened to address this conformance issue.</p>\n<p><b>What about intrinsics</b></p>\n<p><a href=\"http://en.wikipedia.org/wiki/Intrinsic_function\" rel=\"nofollow noreferrer\">Compiler intrinsics</a> are not covered by the standard and so as far as I can tell they should be exempt from this rule, so using:</p>\n<pre><code>static constexpr double a = __builtin_cos(3.);\n</code></pre>\n<p>should be allowed. This question came up in the bug report and opinion of Daniel Kr\u00fcgler was:</p>\n<blockquote>\n<p id=\"so_27744079_27744080_4\">[...]Library functions and other intrinsics can probably be considered as\n  exceptions, because they are not required to be \"explainable\" by\n  normal language rules.</p>\n</blockquote>\n", "LastActivityDate": "2015-09-24T14:31:41.567"}});