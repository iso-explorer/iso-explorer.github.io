post_cb({"bq_ids": {"n4140": {"so_32321006_32321006_2": {"length": 59, "quality": 1.0, "section_id": 268}, "so_32321006_32321006_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 275}}, "n3337": {"so_32321006_32321006_2": {"length": 59, "quality": 1.0, "section_id": 259}, "so_32321006_32321006_0": {"length": 23, "quality": 0.7419354838709677, "section_id": 266}}, "n4659": {"so_32321006_32321006_2": {"length": 59, "quality": 1.0, "section_id": 275}, "so_32321006_32321006_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 282}}}, "32321006": {"ViewCount": "255", "Body": "<p><em>Compiler Fights XIV: Doom of the Duplicitous Double Definition, co-starring The Dubious Declaration!</em></p>\n<p>Compilers, all with either <code>-O0</code> or Debug mode:  </p>\n<ul>\n<li>g++ 5.2.0  </li>\n<li>clang++ 3.6.0  </li>\n<li>VC++ 18.00.40629 (MSVC 2013, Update 5)</li>\n</ul>\n<p><strong>Summary:</strong> </p>\n<ul>\n<li>Is VC++ wrong in rejecting the declaration and definition of a specialized static member variable of a templated class with the syntax?  </li>\n</ul>\n<pre><code>template &lt;&gt; const std::string TemplatedClass::x; // .h file\ntemplate &lt;&gt; const std::string TemplatedClass::x= \"string\"; // .cpp file\n</code></pre>\n<ul>\n<li>Does removing the declaration in the header file cause an otherwise well-defined program to be ill-formed?</li>\n<li>If so, is there a VC++ friendly way to declare the specialization of a static member variable of a templated class?</li>\n</ul>\n<hr>\n<p>While making an MCVE of a problem I was having with defining specialized static member variables of a template, I encountered an interesting variation in behavior between VC++, GCC and Clang with respect to the declaration said specialized static member variables. Specifically, the syntax</p>\n<pre><code>template &lt;&gt; const std::string TemplatedClass&lt;int&gt;::x; // .h file\ntemplate &lt;&gt; const std::string TemplatedClass&lt;int&gt;::x= \"string\"; // .cpp file        \n</code></pre>\n<p>seems to mortally offend VC++, which responds with complaints of multiple definitions:</p>\n<pre><code>error C2374: 'member' : redefinition; multiple initialization\n</code></pre>\n<p>while both gcc and clang take this in stride.  </p>\n<h3>Research</h3>\n<p>I'm assuming the latter two are correct because they usually are, and also because the above syntax is from an <a href=\"https://stackoverflow.com/a/2342696/4892076\">answer regarding static member initialization of a specialized template class</a>, which quotes paragraph 14.7.3/15 from the standard of 2010 in stating that <code>template&lt;&gt; X Q&lt;int&gt;::x</code> is a declaration, not a definition. I took the liberty of tracking down the equivalent paragraph of draft N4296, thinking it could have changed in the intervening time. It has, but only in that it's moved two paragraphs up and contains additional clarification:</p>\n<p><strong>14.7.3/13</strong></p>\n<blockquote>\n<p id=\"so_32321006_32321006_0\">An explicit specialization of a static data member of a template or an explicit specialization of a static data member template is a definition if the declaration includes an initializer; otherwise, it is a declaration.\n  [ Note: The definition of a static data member of a template that requires default initialization must use a braced-init-list:</p>\n<pre><code>template&lt;&gt; X Q&lt;int&gt;::x;      // declaration\ntemplate&lt;&gt; X Q&lt;int&gt;::x ();   // error: declares a function\ntemplate&lt;&gt; X Q&lt;int&gt;::x { };  // definition\n</code></pre>\n<p id=\"so_32321006_32321006_1\">\u2014 end note ]</p>\n</blockquote>\n<p>This seems pretty clear to me, but VC++ seems to have a different interpretation. I've tried simply commenting out the offending declaration, and no compilers complain, which would seem to solve my troubles, but doesn't because paragraph 6 has this to say: (worrying emphasis mine)</p>\n<p><strong>14.7.3/6</strong></p>\n<blockquote>\n<p id=\"so_32321006_32321006_2\">If a template, a member template or a member of a class template is explicitly specialized then that specialization shall be declared before the first use of that specialization that would cause an implicit instantiation to take place, in every translation unit in which such a use occurs; <strong>no diagnostic is required.</strong> If the program does not provide a definition for an explicit specialization and either the specialization is used in a way that would cause an implicit instantiation to take place or the member is a virtual member function, <strong>the program is ill-formed, no diagnostic required.</strong> An implicit instantiation is never generated for an explicit specialization that is declared but not defined.</p>\n</blockquote>\n<p>It provides examples, but all of them are for specializing functions after they're used or specializing member enums and classes of a templated type, which I'm fairly certain don't apply to this problem. However, the initial words of p13 seem to imply that the declaration of the specialized static member variable is also an explicit specialization, at least when using the illustrated syntax.</p>\n<h3>MCVE</h3>\n<p>The test I used for my experimentation can be found on Coliru, with apologies to StackedCrooked for the fairly involved command line. A much shortened version is below:</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/589134880561de13\" rel=\"nofollow noreferrer\">main.cpp</a></p>\n<pre><code>#include &lt;iostream&gt;\n\n// 'header' file\n#include \"test.h\"\n\nint main(){\n\n  std::cout &lt;&lt; test::FruitNames&lt;Fruit::APPLE&gt;::lowercaseName();\n\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/f6a30a1914e60ea5\" rel=\"nofollow noreferrer\">test.h</a> (declaration not commented out)<br>\n<a href=\"http://coliru.stacked-crooked.com/a/f472e0dbebc9aa3c\" rel=\"nofollow noreferrer\">test.h</a> (declaration commented out)</br></p>\n<pre><code>#ifndef TEMPLATE_TEST\n#define TEMPLATE_TEST\n\n#include &lt;algorithm&gt;\n#include &lt;locale&gt;\n#include &lt;string&gt;\n\nnamespace test{\n\n  enum class Fruits{\n    APPLE\n  };\n\n  template &lt;Fruits FruitType_&gt;\n  class FruitNames{\n    static const std::string name_;\n\n  /*...*/\n\n  public:\n    static std::string lowercaseName() {/*...uses name_...*/}\n  };\n\n    // should be counted as declaration. VC++ doesn't.\n  template &lt;&gt; const std::string FruitNames&lt;Fruits::APPLE&gt;::name_;\n\n} // end namespace test\n\n#endif // TEMPLATE_TEST\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/69a65973369227c0\" rel=\"nofollow noreferrer\">test.cpp</a></p>\n<pre><code>#include \"test.h\"\n\nnamespace test{\n\n  template &lt;&gt; const std::string FruitNames&lt;Fruits::APPLE&gt;::name_ = \"Apple\";\n\n}\n</code></pre>\n<h3>Output</h3>\n<p>Both gcc and clang will output </p>\n<pre><code>apple\n</code></pre>\n<p>with or without the specialization declaration in test.h. VC++ will do so if the declaration in test.h is commented out, but will produce a double initialization error if it is present.</p>\n<h3>Finally</h3>\n<ul>\n<li>Is VC++ incorrect to reject the declaration/explicit specialization syntax for the static member variable of a templated class as previously stated, or is it an allowed but not mandatory diagnostic error? </li>\n<li>Does the removal of the declaration cause the program to be\nill-formed? </li>\n<li>If it is ill formed without the declaration, how do I get VC++ to play nice with a\nwell-defined program?</li>\n</ul>\n</hr>", "Title": "Resolving Definitions of Specialized Static Member Variables of Templated Classes", "CreationDate": "2015-08-31T22:43:07.723", "LastActivityDate": "2015-08-31T22:43:07.723", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:22:01.593", "LastEditorUserId": "-1", "Id": "32321006", "Score": "3", "OwnerUserId": "4892076", "Tags": "<c++><templates><language-lawyer>", "AnswerCount": "0"}});