post_cb({"25858963": {"Id": "25858963", "PostTypeId": "2", "Body": "<p>You can use <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/pointer_cast\"><code>std::static_pointer_cast</code></a> or <a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/pointer_cast\"><code>std::dynamic_pointer_cast</code></a> depending on what kind of cast you want.</p>\n", "LastEditorUserId": "82320", "LastActivityDate": "2014-09-16T00:36:00.443", "Score": "17", "CreationDate": "2014-09-16T00:31:40.863", "ParentId": "25858939", "CommentCount": "0", "OwnerUserId": "77567", "LastEditDate": "2014-09-16T00:36:00.443"}, "25859013": {"Id": "25859013", "PostTypeId": "2", "Body": "<p>You can use the pointer casts from <a href=\"https://stackoverflow.com/a/25858963/82320\">rob mayoff's answer</a>; but be careful. It is easy to unintentionally trigger undefined behavior here:</p>\n<pre><code>struct MyClass {};\n\nvoid* rawPtr = new MyClass;\nshared_ptr&lt;void&gt; exampleVoid(rawPtr); // Undefined behavior;\n                                      // calls delete (void*)ptr;\n\nshared_ptr&lt;void&gt; exampleVoidCons(new MyClass);\n    // OK, calls shared_ptr&lt;void&gt;::shared_ptr&lt;MyClass&gt;(MyClass*) which\n    // makes a deleter calling delete (MyClass*)ptr;\n\nshared_ptr&lt;MyClass&gt; example(new MyClass); // OK, calls delete (MyClass*)ptr;\n\nshared_ptr&lt;void&gt; castToVoid = static_pointer_cast&lt;void&gt;(example);\n    // OK, shared_ptr's deleter is erased so this still calls delete (MyClass*)ptr;\n</code></pre>\n<p>Typically this undefined behavior will result in the type's destructor not being called. For example, <a href=\"http://ideone.com/w1qznT\" rel=\"nofollow noreferrer\">see the output on ideone</a> and note that the version put into a <code>void*</code> never prints that it was destroyed.</p>\n<hr>\n<p>See C++11 5.3.5 [expr.delete]/3:</p>\n<blockquote>\n<p id=\"so_25858939_25859013_0\">In the first alternative (delete object), if the static type of the object to be deleted is different from its dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the static type shall have a virtual destructor or the behavior is undefined.</p>\n</blockquote>\n<p>Since the actual object will never have a dynamic type <code>void</code>, and <code>void</code> is never a base class of a dynamic type, <code>delete</code>ing a <code>void*</code> triggers undefined behavior.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2014-09-16T01:19:27.290", "Score": "20", "CreationDate": "2014-09-16T00:39:07.153", "ParentId": "25858939", "CommentCount": "4", "OwnerUserId": "82320", "LastEditDate": "2017-05-23T12:25:10.563"}, "25858939": {"ViewCount": "2654", "Body": "<p>I want to keep the smart behavior of <code>std::shared_ptr</code>. So is there a way to cast a shared void pointer to another type while without confusing the reference counting? I can't get the raw pointer and create a new shared pointer from it.</p>\n", "AcceptedAnswerId": "25859013", "Title": "Is there a way to cast shared_ptr<void> to shared_ptr<T>?", "CreationDate": "2014-09-16T00:28:31.813", "Id": "25858939", "CommentCount": "3", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-09-16T01:19:27.290", "Score": "15", "OwnerUserId": "1079110", "Tags": "<c++><shared-ptr><void-pointers><reference-counting>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_25858939_25859013_0": {"length": 27, "quality": 1.0, "section_id": 6107}}, "n3337": {"so_25858939_25859013_0": {"length": 27, "quality": 1.0, "section_id": 5873}}, "n4659": {"so_25858939_25859013_0": {"length": 27, "quality": 1.0, "section_id": 7604}}}});