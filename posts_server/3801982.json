post_cb({"3802147": {"ParentId": "3801982", "CommentCount": "0", "Body": "<p>It's a very common mistake for English speaking people, because of the way the English grammar works.</p>\n<p>I consider it extremely unfortunate that the C++ syntax would allow both:</p>\n<pre><code>const int // immutable int\nint const // immutable int\n</code></pre>\n<p>to have the same meaning.</p>\n<p>It doesn't make it easier, really, and isn't composable since:</p>\n<pre><code>const int* // mutable pointer to immutable int\nint* const // immutable pointer to mutable int\n</code></pre>\n<p>certainly do NOT have the same meaning.</p>\n<p>And this, unfortunately for you, what kicks in here, as @GMan explains.</p>\n<p>If you wish to avoid this kind of error in the future, take the habit of qualifying your types (<code>const</code> and <code>volatile</code>) on their <strong>right</strong>, then you'll be able to treat a <code>typedef</code> as simple text replacement.</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "3802147", "Score": "8", "CreationDate": "2010-09-27T08:27:39.347", "LastActivityDate": "2010-09-27T08:27:39.347"}, "3801982": {"CommentCount": "0", "ViewCount": "3794", "PostTypeId": "1", "LastEditorUserId": "87234", "CreationDate": "2010-09-27T07:58:18.587", "LastActivityDate": "2010-09-27T08:28:39.153", "Title": "constant references with typedef and templates in c++", "FavoriteCount": "4", "LastEditDate": "2010-09-27T08:14:41.760", "Id": "3801982", "Score": "15", "Body": "<p>I heard the temporary objects can only be assigned to constant references.</p>\n<p>But this code gives error</p>\n<pre><code>#include &lt;iostream.h&gt;    \ntemplate&lt;class t&gt;\nt const&amp; check(){\n  return t(); //return a temporary object\n}    \nint main(int argc, char** argv){\n\nconst int &amp;resCheck = check&lt;int&gt;(); /* fine */\ntypedef int&amp; ref;\nconst ref error = check&lt;int&gt;(); / *error */\nreturn 0;\n}\n</code></pre>\n<p>The error that is get is <code>invalid initialization of reference of type 'int&amp;' from expression of type 'const int'</code></p>\n", "Tags": "<c++><templates><reference><const><temporary>", "OwnerUserId": "459242", "AnswerCount": "5"}, "3802155": {"ParentId": "3801982", "CommentCount": "1", "Body": "<p>To maintain consistency with the <a href=\"http://ieng9.ucsd.edu/~cs30x/rt_lt.rule.html\" rel=\"nofollow\">Right Left Rule</a>, I prefer to use 'cv' qualifiers like so.</p>\n<pre><code>int const x = 2; // x is a const int (by applying Right Left rule)\n\nint const *p = &amp;x;  // p is a pinter to const int\n</code></pre>\n<p>In your example, I would write <code>const ref error = check&lt;int&gt;();</code> like so</p>\n<pre><code>ref const error = check&lt;int&gt;(); // parsed as error is a const reference to an integer\n</code></pre>\n<p>As @Prasoon Saurav pointed out, cv qualifiers are ignored when introduced through typedef because as @GMan also says, that cv qualified references are ill-formed.</p>\n<p>Therefore the declaration is effectively as below, which of course is an error.</p>\n<pre><code>   int &amp;error = check&lt;int&gt;(); \n</code></pre>\n<p>Check out <a href=\"http://www.dansaks.com/articles/1999-02%20const%20T%20vs%20T%20const.pdf\" rel=\"nofollow\">this</a> for more information.</p>\n", "OwnerUserId": "418110", "PostTypeId": "2", "Id": "3802155", "Score": "3", "CreationDate": "2010-09-27T08:28:39.153", "LastActivityDate": "2010-09-27T08:28:39.153"}, "3802028": {"ParentId": "3801982", "CommentCount": "0", "Body": "<p>Your code gives error because the <code>const</code> qualifier in <code>const ref error</code> is just ignored because <code>8.3.2/1</code> says </p>\n<blockquote>\n<p id=\"so_3801982_3802028_0\">Cv-qualified references are ill-formed except when the cv-qualifiers are introduced through the use of a typedef (7.1.3) or of a template type argument(14.3), in which case the <strong>cv-qualifiers are ignored</strong>.`</p>\n</blockquote>\n<p>So <code>error</code> has type <code>int&amp;</code> not <code>const int&amp;</code> .</p>\n", "OwnerUserId": "165520", "PostTypeId": "2", "Id": "3802028", "Score": "7", "CreationDate": "2010-09-27T08:07:49.170", "LastActivityDate": "2010-09-27T08:07:49.170"}, "3802031": {"ParentId": "3801982", "CommentCount": "0", "Body": "<p>This is compiled:</p>\n<pre>\ntypedef const int&amp; ref; \nref error = check&lt;int&gt;(); \n</pre>\n<p>VC++ compiler gives some explanation of your error: qualifier applied to reference type; ignored. Reference type must be declared as constant, const cannot be applied later.</p>\n", "OwnerUserId": "279313", "PostTypeId": "2", "Id": "3802031", "Score": "0", "CreationDate": "2010-09-27T08:08:20.340", "LastActivityDate": "2010-09-27T08:08:20.340"}, "bq_ids": {"n4140": {"so_3801982_3802028_0": {"section_id": 3218, "quality": 0.7058823529411765, "length": 12}}, "n3337": {"so_3801982_3802028_0": {"section_id": 3092, "quality": 0.8823529411764706, "length": 15}}, "n4659": {"so_3801982_3802028_0": {"section_id": 3975, "quality": 0.7058823529411765, "length": 12}}}, "3802019": {"ParentId": "3801982", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This:</p>\n<pre><code>typedef int&amp; ref;\nconst ref error;\n</code></pre>\n<p>Doesn't do what you think it does. Consider instead:</p>\n<pre><code>typedef int* pointer;\ntypedef const pointer const_pointer;\n</code></pre>\n<p>The type of <code>const_pointer</code> is <code>int* const</code>, <strong>not</strong> <code>const int *</code>. That is, when you say <code>const T</code> you're saying \"make a type where T is immutable\"; so in the previous example, the pointer (not the pointee) is made immutable.</p>\n<p>References cannot be made <code>const</code> or <code>volatile</code>. This:</p>\n<pre><code>int&amp; const x;\n</code></pre>\n<p>is meaningless, so adding cv-qualifiers to references has no effect.</p>\n<p>Therefore, <code>error</code> has the type <code>int&amp;</code>. You cannot assign a <code>const int&amp;</code> to it.</p>\n<hr>\n<p>There are other problems in your code. For example, this is certainly wrong:</p>\n<pre><code>template&lt;class t&gt;\nt const&amp; check()\n{\n    return t(); //return a temporary object\n}\n</code></pre>\n<p>What you're doing here is returning a reference to a temporary object <em>which ends its lifetime when the function returns</em>. That is, you get undefined behavior if you use it because there is no object at the referand. This is no better than:</p>\n<pre><code>template&lt;class t&gt;\nt const&amp; check()\n{\n    T x = T();\n    return x; // return a local...bang you're dead\n}    \n</code></pre>\n<p>A better test would be:</p>\n<pre><code>template&lt;class T&gt;\nT check()\n{\n    return T();\n}\n</code></pre>\n<p>The return value of the function is a temporary, so you can still test that you can indeed bind temporaries to constant references.</p>\n</hr>", "OwnerUserId": "87234", "LastEditorUserId": "87234", "LastEditDate": "2010-09-27T08:12:51.513", "Id": "3802019", "Score": "21", "CreationDate": "2010-09-27T08:06:22.610", "LastActivityDate": "2010-09-27T08:12:51.513"}});