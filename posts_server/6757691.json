post_cb({"6767483": {"Id": "6767483", "PostTypeId": "2", "Body": "<p>If you like to find out whether a tuple as a specific last member, here's a type trait for that:</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;tuple&gt;\n\ntemplate &lt;typename ...Args&gt; struct back;\ntemplate &lt;typename T, typename ...Args&gt; struct back&lt;T, Args...&gt;\n  { typedef typename back&lt;Args...&gt;::type type; };\ntemplate &lt;typename T&gt; struct back&lt;T&gt;\n  { typedef T type; };\n\n\ntemplate &lt;typename...&gt; struct tuple_has_last : public std::false_type {};\ntemplate &lt;typename T, typename... Args&gt; struct tuple_has_last&lt;T, std::tuple&lt;Args...&gt;&gt;\n{\n  static const bool value = std::is_same&lt;typename back&lt;Args...&gt;::type, T&gt;::value;\n};\n</code></pre>\n<p><em>Edit:</em> Oh, I didn't see that Matthieu had already written the exact same thing. Never mind.</p>\n", "LastActivityDate": "2011-07-20T19:38:33.550", "CommentCount": "0", "CreationDate": "2011-07-20T19:38:33.550", "ParentId": "6757691", "Score": "1", "OwnerUserId": "596781"}, "6757830": {"Id": "6757830", "PostTypeId": "2", "Body": "<p>If you compile using <a href=\"http://clang.llvm.org/\" rel=\"nofollow noreferrer\">clang</a>, it helpfully reports that (2) and (3) are unusable.  The warning for (3), which you expect to be selected, is as follows:</p>\n<blockquote>\n<p id=\"so_6757691_6757830_0\">warning: class template partial specialization contains a template parameter that can not be deduced; this partial specialization will never be used</p>\n<pre><code>struct alpha&lt;std::tuple&lt;Args..., T&gt;, T&gt; {\n       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n</code></pre>\n<p id=\"so_6757691_6757830_1\">note: non-deducible template parameter '<code>Args</code>'</p>\n<pre><code>template&lt;class T, class... Args&gt;\n                           ^\n</code></pre>\n</blockquote>\n<p>Why is <code>Args</code> not deducible?  The C++0x FDIS states at \u00a714.8.2.5/9:</p>\n<blockquote>\n<p id=\"so_6757691_6757830_2\">If the template argument list of [a type that is specified in terms of template parameters] contains a pack expansion that is not the last template argument, the entire template argument list is a non-deduced context.</p>\n</blockquote>\n<p>In your specialization, the type <code>std::tuple&lt;Args..., T&gt;</code> is a type that is specified in terms of template parameters <code>Args</code> and <code>T</code>.  It contains a pack expansion (<code>Args...</code>), but that pack expansion is not the last template argument (<code>T</code> is the last template argument).  Thus, the entire template argument list of the <code>tuple</code> (the entirety of <code>&lt;Args..., T&gt;</code>) is a non-deduced context.</p>\n<p>The argument list of the <code>std::tuple</code> is the only place in the template specialization's argument list that <code>Args</code> appears; since it is not deducible from there, it is not deducible at all and the specialization will never be used.</p>\n<p>Matthieu M. <a href=\"https://stackoverflow.com/questions/6757691/partial-specialization-of-tuple-contents-with-variadic-arguments/6758377#6758377\">provides a clever workaround in his answer</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-07-21T17:19:30.103", "Score": "13", "CreationDate": "2011-07-20T06:28:01.900", "ParentId": "6757691", "CommentCount": "12", "OwnerUserId": "151292", "LastEditDate": "2017-05-23T12:29:37.923"}, "bq_ids": {"n4140": {"so_6757691_6757830_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 147}, "so_6757691_6757830_2": {"length": 16, "quality": 0.8, "section_id": 340}}, "n3337": {"so_6757691_6757830_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 141}, "so_6757691_6757830_2": {"length": 16, "quality": 0.8, "section_id": 330}}, "n4659": {"so_6757691_6757830_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 151}, "so_6757691_6757830_2": {"length": 16, "quality": 0.8, "section_id": 349}}}, "6758377": {"Id": "6758377", "PostTypeId": "2", "Body": "<p>@James provided the why, now let's try to find an alternative.</p>\n<p>I would suggest using another level of indirection.</p>\n<p><strong>1. Getting the last argument</strong></p>\n<pre><code>template &lt;typename T&gt; struct Last;\n\ntemplate &lt;typename T, typename U, typename... Args&gt;\nstruct Last&lt;std::tuple&lt;T,U,Args...&gt;&gt;\n{\n  typedef typename Last&lt;std::tuple&lt;U,Args...&gt;&gt;::type type;\n};\n\ntemplate &lt;typename T&gt;\nstruct Last&lt;std::tuple&lt;T&gt;&gt;\n{\n  typedef T type;\n};\n</code></pre>\n<p><strong>2. Introducing a specialized helper</strong></p>\n<pre><code>template &lt;typename T, typename U&gt;\nstruct alpha_tuple\n{\n  enum { value = 1 };\n};\n\ntemplate &lt;typename T&gt;\nstruct alpha_tuple&lt;T,T&gt;\n{\n  enum { value = 3 };\n};\n\ntemplate &lt;typename T&gt;\nstruct alpha_tuple&lt;std::vector&lt;T&gt;,T&gt;\n{\n  enum { value = 2; }\n};\n</code></pre>\n<p><strong>3. Hooking it up</strong></p>\n<pre><code>template &lt;typename T&gt;\nstruct alpha&lt;std::tuple&lt;&gt;, T&gt;\n{\n  enum { value = 1 };\n};\n\ntemplate &lt;typename T, typename U, typename Args...&gt;\nstruct alpha&lt;std::tuple&lt;U, Args...&gt;, T&gt;\n{\n  typedef typename Last&lt;std::tuple&lt;U, Args...&gt;&gt;::type LastType;\n  enum { value = alpha_tuple&lt;LastType,T&gt;::value };\n};\n</code></pre>\n<p>Note that there is no last type for empty tuples, so I had to deal with them in a separate specialization.</p>\n", "LastActivityDate": "2011-07-20T07:22:54.920", "CommentCount": "3", "CreationDate": "2011-07-20T07:22:54.920", "ParentId": "6757691", "Score": "12", "OwnerUserId": "147192"}, "6757691": {"ViewCount": "1183", "Body": "<p>Currently, I'm trying to get some code to react differently to different types. This isn't the exact code, but it gets the message across.</p>\n<pre><code>template&lt;class A, class B&gt;\nstruct alpha {\n  enum { value = 0 };\n};\n\ntemplate&lt;class T, class... Args&gt;\nstruct alpha&lt;std::tuple&lt;Args...&gt;, T&gt; {\n  enum { value = 1 };\n};\n\n// This gets ignored\ntemplate&lt;class T, class... Args&gt;\nstruct alpha&lt;std::tuple&lt;Args..., std::vector&lt;T&gt; &gt;, T&gt; {\n  enum { value = 2 };\n};\n\n// This gets ignored\ntemplate&lt;class T, class... Args&gt;\nstruct alpha&lt;std::tuple&lt;Args..., T&gt;, T&gt; {\n  enum { value = 3 };\n};\n\ntemplate&lt;class T, class... Args&gt;\nstruct alpha&lt;T, std::tuple&lt;Args...&gt; &gt; {\n  enum { value = 4 };\n};\n\ntemplate&lt;class... LArgs, class... RArgs&gt;\nstruct alpha&lt;std::tuple&lt;LArgs...&gt;, std::tuple&lt;RArgs...&gt; &gt; {\n  enum { value = 5 };\n};\n\nint main(int argc, char* argv[]) {\n  std::cout &lt;&lt; alpha&lt;std::tuple&lt;int, double&gt;, double&gt;::value &lt;&lt; std::endl; // prints 1\n  return 0;\n}\n</code></pre>\n<p>I've tried more than this code shows, but nothing works so far and I ran across a problem with explicit specialization in a non-namespace scope. For reference, I'm working on gcc 4.6 (the one that comes with oneiric server), which I believe has complete variadic template support. I don't care how ugly it gets if the implementation works to detect the last argument of the parameter pack and the other types as well. Any suggestions?</p>\n<p>EDIT:\nI wanted to share the solution I used based on the answers (this is an example).</p>\n<pre><code>template&lt;typename T&gt; struct tuple_last;\n\ntemplate&lt;typename T, typename U, typename... Args&gt;\nstruct tuple_last&lt;std::tuple&lt;T,U,Args...&gt;&gt; {\n  typedef typename tuple_last&lt;std::tuple&lt;U,Args...&gt;&gt;::type type;\n};\n\ntemplate&lt;typename T&gt;\nstruct tuple_last&lt;std::tuple&lt;T&gt;&gt; {\n  typedef T type;\n};\n\nnamespace details {\n// default case:\ntemplate&lt;class T, class U&gt;\nstruct alpha_impl {\nenum { value = 1 };\n};\n\ntemplate&lt;class T&gt;\nstruct alpha_impl&lt;T, T&gt; {\nenum { value = 101 };\n};\n\ntemplate&lt;class T&gt;\nstruct alpha_impl&lt;T, std::vector&lt;T&gt;&gt; {\nenum { value = 102 };\n};\n\n// and so on.\n}\n\ntemplate&lt;class T, class... Args&gt;\nstruct alpha&lt;std::tuple&lt;Args...&gt;, T&gt;\n  : details::alpha_impl&lt;T, tuple_last&lt;std::tuple&lt;Args...&gt;&gt;;\n</code></pre>\n", "AcceptedAnswerId": "6757830", "Title": "Partial Specialization of tuple contents with variadic arguments", "CreationDate": "2011-07-20T06:11:01.377", "Id": "6757691", "CommentCount": "0", "LastEditDate": "2012-09-29T03:15:47.370", "PostTypeId": "1", "LastEditorUserId": "151292", "LastActivityDate": "2012-09-29T03:15:47.370", "Score": "5", "OwnerUserId": "837964", "Tags": "<c++><templates><c++11><tuples><variadic-templates>", "AnswerCount": "3"}});