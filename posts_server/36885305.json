post_cb({"36885605": {"ParentId": "36885305", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The meaning of typedef is defined in the standard as (7.1.3 The typedef specifier):</p>\n<blockquote>\n<p id=\"so_36885305_36885605_0\">Within the scope of its declaration, a typedef-name is syntactically equivalent to a keyword and names the type associated with the identifier (...). A typedef-name is thus a synonym for another type. A typedef-name does\n  not introduce a new type (...).</p>\n</blockquote>\n<p>Therefore the two functions are indeed ambiguous in regard to the type of input parameter. You need to distinguish the type (e.g. by using different type, e.g. a class or enum) or perhaps add a second parameter (maybe with a default value) indicating which kind type exactly is being passed in.</p>\n<p>Link to original answer: <a href=\"https://softwareengineering.stackexchange.com/questions/254473/in-which-stage-of-compilation-is-typedef-resolved-by-the-compiler\">https://softwareengineering.stackexchange.com/questions/254473/in-which-stage-of-compilation-is-typedef-resolved-by-the-compiler</a></p>\n", "OwnerUserId": "1043352", "LastEditorUserId": "-1", "LastEditDate": "2017-04-12T07:31:24.410", "Id": "36885605", "Score": "0", "CreationDate": "2016-04-27T09:24:15.467", "LastActivityDate": "2016-04-27T09:24:15.467"}, "36885612": {"ParentId": "36885305", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_36885305_36885612_0\">Is this correct or is there some other way to make the compiler choose the correct overload?</p>\n</blockquote>\n<p>Yes you're correct, you can't overload on <code>typedef</code> since it's simply an alias.  As you rightly suggest, either rename the function or create a new type with <code>class</code>.  Adding a <em>fake</em> parameter simply to change the function signature is usually a bad idea, renaming is clearer.</p>\n", "OwnerUserId": "1312406", "PostTypeId": "2", "Id": "36885612", "Score": "1", "CreationDate": "2016-04-27T09:24:35.967", "LastActivityDate": "2016-04-27T09:24:35.967"}, "36885305": {"CommentCount": "2", "ViewCount": "94", "CreationDate": "2016-04-27T09:11:35.530", "LastActivityDate": "2016-04-27T09:32:57.370", "Title": "overload with typedef gives an error", "AcceptedAnswerId": "36885797", "PostTypeId": "1", "Id": "36885305", "Score": "7", "Body": "<p>Consider the following types:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntypedef unsigned long long      usize_t;\ntypedef unsigned __int16        uword_t;\ntypedef uword_t                 clockval_t;     // time without seconds in format HHMM\n\nstd::string toString(clockval_t nClock)\n{\n    return std::to_string((usize_t)nClock/100) + \":\" + std::to_string((usize_t)nClock % 100);\n}\n\nstd::string toString(uword_t nValue)\n{\n    return std::to_string((usize_t)nValue);\n}\n\nvoid test(void)\n{\n    uword_t val = 1;\n    clockval_t time = 1023; // 10:23\n\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; toString(val);\n    std::cout &lt;&lt; \"time: \" &lt;&lt; toString(time);\n}\n</code></pre>\n<p>Now when I try to compile this, I get an error from the compiler telling me that the <code>std::string toString(clockval_t)</code> already has a body. I understand why this happens of course, because the typedef is just an alias for <code>uword_t</code>.</p>\n<p>AFAIK the only solutions are to provide a separate method:</p>\n<pre><code>std::string toClockString(clockval_t);\n</code></pre>\n<p>or make it an object:</p>\n<pre><code>class clockval ...\n</code></pre>\n<p>Is this correct or is there some other way to make the compiler choose the correct overload?</p>\n", "Tags": "<c++><overloading>", "OwnerUserId": "2282011", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_36885305_36885605_0": {"section_id": 5407, "quality": 1.0, "length": 22}}, "n3337": {"so_36885305_36885605_0": {"section_id": 5202, "quality": 1.0, "length": 22}}, "n4659": {"so_36885305_36885605_0": {"section_id": 6829, "quality": 1.0, "length": 22}}}, "36885797": {"ParentId": "36885305", "CommentCount": "2", "Body": "<p>Even if there were a way to make compiler choose correct version, do you realize how it would be error-prone? Luckily, there is no such way  because <code>typedef</code> creates alias and nothing more.</p>\n<p>I suggest that you convert it into class. If you provide proper constructor and conversion operator then you even don't need to change parts of code which make use of <code>clockval_t</code>:</p>\n<pre><code>class clockval_t {\npublic:\n  clockval_t(uword_t aValue) : value(aValue) {}\n  operator uword_t() const { return value; }\n\nprivate:\n  uword_t value;\n};\n\n...\n\nclockval_t time = 1023; // works fine\nstd::cout &lt;&lt; time &lt;&lt; std::endl; // works fine\nstd::cout &lt;&lt; (time / 10) &lt;&lt; std::endl; // works fine\n</code></pre>\n", "OwnerUserId": "5793987", "PostTypeId": "2", "Id": "36885797", "Score": "2", "CreationDate": "2016-04-27T09:32:57.370", "LastActivityDate": "2016-04-27T09:32:57.370"}});