post_cb({"bq_ids": {"n4140": {"so_4186165_4186424_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 5519}}, "n3337": {"so_4186165_4186424_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 5305}}, "n4659": {"so_4186165_4186424_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 6954}}}, "4186165": {"ViewCount": "413", "Body": "<p>I am creating a C++ library with a C-ABI interface.</p>\n<p>This is how GCC treats the extern \"C\" qualifier with regards to mangling:</p>\n<pre><code>namespace x {\n\n    extern \"C\" int monkey(int x) {\n        return 1;\n    }\n\n    int chimpanzee(int x) {\n        return 1;\n    }\n}\n</code></pre>\n<p>The relevant <code>nm</code> output:</p>\n<pre><code>00000000004005cd T _ZN1x10chimpanzeeEi\n00000000004005bf T monkey\n</code></pre>\n<p><strong>Question:</strong>\nI want to leave functions which are involved in the C-ABI inside a namespace, for maximum flexibility for reuse. <strong>Important Note:</strong> Once the library has been compiled I will give the linker a map file (GCC) or a module definition file (MSVC). </p>\n<ol>\n<li>Is the mangling output standard behaviour -- will other major compilers (MSVC in specific) strip mangling as well ? </li>\n<li>are their any pitfalls or best-practises regarding placing functions in a name-space when they are involved in an external ABI? </li>\n<li>Will this interfere with the C-ABI export of the de-mangled functions during link time ?</li>\n</ol>\n", "AcceptedAnswerId": "4186424", "Title": "Best Practise and Semantics of namespace nested functions and the use of extern \"C\"", "CreationDate": "2010-11-15T15:58:35.067", "Id": "4186165", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-11-19T13:27:41.057", "LastEditorUserId": "759866", "LastActivityDate": "2013-11-19T13:27:41.057", "Score": "3", "OwnerUserId": "153865", "Tags": "<c++><portability><abi>", "AnswerCount": "2"}, "4186317": {"Id": "4186317", "PostTypeId": "2", "Body": "<p>What you're doing is fine and will give you the effects that you want. From <em>The C++ Programming Language, 3rd Edition</em>, page 208: \"A name with C linkage can be declared in a namespace. The namespace will affect the way the name is accessed in  a C++ program, but not the way a linker sees it. The <code>printf()</code> from <code>std</code> is a typical example. \u2026 Even when called with <code>std::printf()</code>, it is still the same old C <code>printf()</code>.\" </p>\n", "LastActivityDate": "2010-11-15T16:12:19.240", "CommentCount": "1", "CreationDate": "2010-11-15T16:12:19.240", "ParentId": "4186165", "Score": "5", "OwnerUserId": "101225"}, "4186424": {"Id": "4186424", "PostTypeId": "2", "Body": "<p>This is for MSVC.</p>\n<p>The namespace itself is not name-mangled, but the name of the namespace is incorporated in to the function's (or object's) name when name mangling occurs.  This process is undocumented, but described <a href=\"http://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B_Name_Mangling\" rel=\"nofollow\">here</a>.</p>\n<p>Answering your specific questions by jumping around:</p>\n<p>1) There is no Standard-defined behavior regarding name mangling.  What the Standard actually says is that implementations provides a C-compatible linkage for <code>extern \"C\"</code> constructs:</p>\n<h2>7.5.3 [Linkage specifications]</h2>\n<blockquote>\n<p id=\"so_4186165_4186424_0\">Every implementation shall provide for\n  linkage to functions written in the C\n  programming language, \"C\", and linkage\n  to C + + functions, \"C++\".  [Example:</p>\n</blockquote>\n<pre><code>complex sqrt(complex); // C + + linkage by default \nextern \"C\" { double sqrt(double); // C linkage } \n</code></pre>\n<blockquote>\n<p id=\"so_4186165_4186424_1\">\u2014end example]</p>\n</blockquote>\n<p>Ultimately what this means is that since C has no concept of <code>namespace</code>s, if <code>extern \"C\"</code> functions or objects in namespaces, your exported names will lose the namespace qualification.  This leads to...</p>\n<p>3) Yes, you can have a linkage problem.  Try this:</p>\n<h2>main.h</h2>\n<pre><code>#ifndef MAIN_API\n#   define MAIN_API __declspec(dllexport)\n#endif\n\nnamespace x\n{\n    extern \"C\" MAIN_API void foo();\n};\n\nnamespace y\n{\n    extern \"C\" MAIN_API void foo();\n};\n</code></pre>\n<h2>main.cpp</h2>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n#define MAIN_API __declspec(dllexport)\n#include \"main.h\"\n\nvoid x::foo()\n{\n    cout &lt;&lt; \"x::foo()\\n\";\n}\n\nvoid y::foo()\n{\n    cout &lt;&lt; \"y::foo()\\n\";\n}\n\nint main()\n{\n}\n</code></pre>\n<p>This will emit a linker error because the <code>extern \"C\"</code>-ed versions of <code>x::foo()</code> and <code>y::foo()</code> have lost their namespace identification, so they end up with exactly the same name:  <code>foo()</code></p>\n<p>2) Best practices regarding this.  If you must export a C-ABI for functions in namespaces, you have to be careful that the names you end up exporting are not the same.  To some degree, this defeats the purpose of using a <code>namespace</code> in the first place.  But you can do something like this:</p>\n<pre><code>#ifndef MAIN_API\n#   define MAIN_API __declspec(dllexport)\n#endif\n\nnamespace x\n{\n    extern \"C\" MAIN_API void x_foo();\n};\n\nnamespace y\n{\n    extern \"C\" MAIN_API void y_foo();\n};\n</code></pre>\n", "LastActivityDate": "2010-11-15T16:21:05.137", "CommentCount": "1", "CreationDate": "2010-11-15T16:21:05.137", "ParentId": "4186165", "Score": "2", "OwnerUserId": "241536"}});