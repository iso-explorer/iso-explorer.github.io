post_cb({"bq_ids": {"n4140": {"so_46891778_46891919_0": {"length": 5, "quality": 1.0, "section_id": 3348}}, "n3337": {"so_46891778_46891919_0": {"length": 5, "quality": 1.0, "section_id": 3218}}, "n4659": {"so_46891778_46891919_0": {"length": 5, "quality": 1.0, "section_id": 4115}}}, "46891778": {"ViewCount": "179", "Body": "<p>Error : Terminate called after throwing an instance of 'char const*'</p>\n<p>terminate application has been required the Runtime to terminate it in an unusual way. Please contact the application's support team.</p>\n<p>I'm not sure what's causing the compiler to crash when I do this. Any ideas? A bit new to programming.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing namespace std;\n\n//Template for Maximum\n\ntemplate &lt;class X&gt;\nX Maximum(X arg1, X arg2)\n{\n    if (arg1 &gt; arg2)\n        return arg1;\n    else\n        return arg2;\n}\n\n//Template for Minimum\n\ntemplate &lt;class M&gt;\nM Minimum(M arg1, M arg2)\n{\n    if (arg1 &gt; arg2)\n        return arg2;\n    else\n        return arg1;\n}\n\n/* Template for Divide(D arg1, D arg2) arg1: the dividend arg2: the divisor Description: \nDivides arg1 by arg2. If arg2 equals zero then an exception is thrown. */\n\ntemplate &lt;class D&gt;\nD Divide(D arg1, D arg2)\n{\n    if (arg2 == 0) {\n        throw \"You cannot devide by zero! \";\n    }\n    return (arg1 / arg2);\n}\n\nint main()\n{\n\n    int a, b;\n    float c, d;\n    double e, f;\n    a = 2;\n    b = 22;\n    cout &lt;&lt; setprecision(4) &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; \"min:\" &lt;&lt; Minimum(a, b) &lt;&lt; \"\\tmax: \" &lt;&lt; Maximum(a, b) &lt;&lt; endl;\n    c = 4.7f;\n    d = 2.97f;\n    cout &lt;&lt; setprecision(4) &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; \"min:\" &lt;&lt; Minimum(c, d) &lt;&lt; \"\\tmax: \" &lt;&lt; Maximum(c, d) &lt;&lt; endl;\n\n    e = 387.78;\n    f = 387.7798;\n    cout &lt;&lt; setprecision(4) &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; \"min:\" &lt;&lt; Minimum(e, f) &lt;&lt; \"\\tmax: \" &lt;&lt; Maximum(e, f) &lt;&lt; endl;\n    e = 40;\n    f = 0;\n    try {\n        cout &lt;&lt; setprecision(4) &lt;&lt; fixed &lt;&lt; showpoint &lt;&lt; \"Divide: \" &lt;&lt; e &lt;&lt; '/' &lt;&lt; f &lt;&lt; \" = \" &lt;&lt; Divide(e, f) &lt;&lt; endl;\n    }\n    catch (string exceptionString) {\n        cout &lt;&lt; exceptionString;\n    }\n    system(\"pause\");\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "46891919", "Title": "Exception Handling in C++ Terminate called after throwing an instance of 'char const*'", "CreationDate": "2017-10-23T14:24:49.470", "Id": "46891778", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-10-23T14:39:27.487", "Score": "4", "OwnerUserId": "7501943", "Tags": "<c++>", "AnswerCount": "1"}, "46891919": {"Id": "46891919", "PostTypeId": "2", "Body": "<p>A string literal is not a <code>std::string</code>. You throw the former, but try to catch the latter. Despite the fact a <code>std::string</code> may be constructed from a string literal, it won't happen in a catch clause. The conversions which are allowed in a catch clause are detailed in <a href=\"https://timsong-cpp.github.io/cppwp/n4659/except.handle#2\" rel=\"nofollow noreferrer\">[except.handle]/3</a>:</p>\n<blockquote>\n<p id=\"so_46891778_46891919_0\">A handler is a match for an exception object of type E if:</p>\n<ul>\n<li>The handler is of type cv T or cv T&amp; and E and T are the same type (ignoring the top-level cv-qualifiers), or</li>\n<li>the handler is of type cv T or cv T&amp; and T is an unambiguous public base class of E, or</li>\n<li>the handler is of type cv T or const T&amp; where T is a pointer or pointer to member type and E is a pointer or pointer to member type\n  that can be converted to T by one or more of\n  \n  <ul>\n<li>a standard pointer conversion not involving conversions to pointers to private or protected or ambiguous classes</li>\n<li>a function pointer conversion</li>\n<li>a qualification conversion, or</li>\n</ul></li>\n<li>the handler is of type cv T or const T&amp; where T is a pointer or pointer to member type and E is std\u200b::\u200bnullptr_\u00adt.</li>\n</ul>\n</blockquote>\n<p>And neither of which applied for the case of literal -&gt; <code>std::string</code> conversion.</p>\n<p>Which ultimately results in that exception being uncaught, and the run-time calling <code>std::terminate</code> as is supposed to happen with uncaught exceptions.</p>\n<p>In general, it's best to throw a dedicated exception type (which may be part of a hierarchy), such that the very type name communicates the error that occurred. This will allow handling the error in more robust ways, if a handler (or a set of handlers) need to be written.</p>\n<p>If you don't want to follow the standard practice for some reason, you must make the conversion be one of those mentioned in the above bullets. You can either:</p>\n<ol>\n<li>Throw a <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/operator%22%22s\" rel=\"nofollow noreferrer\"><code>std::string</code> literal</a>, like <code>\"You cannot devide by zero!\"s</code> (note the <code>s</code> suffix).</li>\n<li>Catch a <code>const char*</code>.</li>\n</ol>\n", "LastEditorUserId": "817643", "LastActivityDate": "2017-10-23T14:39:27.487", "Score": "4", "CreationDate": "2017-10-23T14:30:42.640", "ParentId": "46891778", "CommentCount": "1", "OwnerUserId": "817643", "LastEditDate": "2017-10-23T14:39:27.487"}});