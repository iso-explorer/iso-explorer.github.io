post_cb({"13380317": {"ParentId": "13380063", "CommentCount": "0", "Body": "<p>On most platforms with a flat address space, they can simply do a numerical comparison between the pointers. On platforms where this isn't possible, the implementer has to come up with some other method of establishing a total order to use in <code>std::less</code>, but they can potentially use a more efficient method for <code>&lt;</code>, since it has a weaker guarantee.</p>\n<p>In the case of GCC and Clang, they can implement <code>std::less</code> as <code>&lt;</code> as long as they provide the stronger guarantee for <code>&lt;</code>. Since they are the ones implementing the behavior for <code>&lt;</code>, they can rely on this behavior, but their users can't, since it might change in the future.</p>\n", "OwnerUserId": "1568792", "PostTypeId": "2", "Id": "13380317", "Score": "4", "CreationDate": "2012-11-14T14:03:19.567", "LastActivityDate": "2012-11-14T14:03:19.567"}, "13380820": {"ParentId": "13380063", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-11-14T14:34:05.467", "Score": "3", "LastEditorUserId": "1593860", "LastEditDate": "2012-11-14T14:45:50.260", "Id": "13380820", "OwnerUserId": "1593860", "Body": "<p>The problem is segmented architectures, where a memory address has two parts: a segment and an offset. It's \"easy enough\" to turn those pieces into some sort of linear form, but that takes extra code, and the decision was to not impose that overhead for <code>operator&lt;</code>. For segmented architectures, <code>operator&lt;</code> can simply compare the offsets. This issue was present for earlier versions of Windows.</p>\n<p>Note that \"easy enough\" is a systems programmer's perspective. Different segment selectors can refer to the same memory block, so producing a canonical ordering requires pawing through details of segment mapping, which is platform-dependent and may well be slow.</p>\n", "LastActivityDate": "2012-11-14T14:45:50.260"}, "13381081": {"ParentId": "13380063", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2012-11-14T14:46:27.163", "Score": "16", "LastEditorUserId": "649665", "LastEditDate": "2013-03-05T19:36:11.560", "Id": "13381081", "OwnerUserId": "649665", "Body": "<p>Can pointers be totally ordered?  Not in portable, standard C++.  That's\nwhy the standard requires the implementation to solve the problem, not\nyou.  For any given representation of a pointer, it should be possible\nto define an arbitrary total ordering, but how you do it will depend on\nthe the representation of a pointer.</p>\n<p>For machines with a flat address space and byte addressing, just\ntreating the pointer as if it were a similarly sized integer or unsigned\ninteger is usually enough; this is how most compilers will handle \ncomparison within an object as well, so on such machines, there's no\nneed for the library to specialize <code>std::less</code> et al.  The \"unspecified\"\nbehavior just happens to do the right thing.</p>\n<p>For word addressed machines (and there is at least one still in\nproduction), it may be necessary to convert the pointers to <code>void*</code>\nbefore the compiler native comparison will work.</p>\n<p>For machines with segmented architectures, more work may be necessary.\nIt's typical on such machines to require an array to be entirely in one\nsegment, and just compare the offset in the segment; this means that if\n<code>a</code> and <code>b</code> are two arbitrary pointers, you may end up with <code>!(a &lt; b) &amp;&amp;\n!(b &lt; a)</code> but not <code>a == b</code>.  In this case, the compiler must provide\nspecializations of <code>std::less&lt;&gt;</code> et al for pointers, which (probably)\nextract the segment and the offset from the pointer, and do some sort of\nmanipulation of them.</p>\n<p>EDIT:</p>\n<p>On other thing worth mentionning, perhaps: the guarantees in the C++\nstandard only apply to standard C++, or in this case, pointers obtained\nfrom standard C++.  On most modern systems, it's rather easy to <code>mmap</code>\nthe same file to two different address ranges, and have two pointers <code>p</code>\nand <code>q</code> which compare unequal, but which point to the same object.</p>\n", "LastActivityDate": "2013-03-05T19:36:11.560"}, "13380063": {"CommentCount": "11", "AcceptedAnswerId": "13381081", "CreationDate": "2012-11-14T13:48:38.940", "LastActivityDate": "2013-03-05T19:36:11.560", "PostTypeId": "1", "ViewCount": "800", "FavoriteCount": "5", "Title": "How can pointers be totally ordered?", "Id": "13380063", "Score": "21", "Body": "<p>Pointers in C++ may in general only be compared for equality. By contrast, less-than comparison is only allowed for two pointers that point to subobjects of the same complete object (e.g. array elements).</p>\n<p>So given <code>T * p, * q</code>, it is illegal in general to evaluate <code>p &lt; q</code>.</p>\n<p>The standard library contains functor class templates <code>std::less&lt;T&gt;</code> etc. which wrap the built-in operator <code>&lt;</code>. However, the standard has this to say about pointer types (20.8.5/8):</p>\n<blockquote>\n<p id=\"so_13380063_13380063_0\">For templates <code>greater</code>, <code>less</code>, <code>greater_equal</code>, and <code>less_equal</code>, the specializations for any pointer type yield a total order, even if the built-in operators <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> do not.</p>\n</blockquote>\n<p>How can this be realised? Is it even possible to implement this?</p>\n<p>I took a look at GCC 4.7.2 and Clang 3.2, which don't contain <em>any</em> specialization for pointer types at all. They seem to depend on <code>&lt;</code> being valid unconditionally on all their supported platforms.</p>\n", "Tags": "<c++><pointers><predicate><standard-library>", "OwnerUserId": "596781", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_13380063_13380063_0": {"section_id": 4605, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_13380063_13380063_0": {"section_id": 4423, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_13380063_13380063_0": {"section_id": 5962, "quality": 0.7333333333333333, "length": 11}}}, "13380230": {"ParentId": "13380063", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2012-11-14T13:58:54.487", "Score": "10", "LastEditorUserId": "46642", "LastEditDate": "2012-11-14T14:04:40.430", "Id": "13380230", "OwnerUserId": "46642", "Body": "<blockquote>\n<p id=\"so_13380063_13380230_0\">Is it possible to implement the standard library on targets where pointers do not form a global, total order?</p>\n</blockquote>\n<p>Yes. Given any finite set you can always define an arbitrary total order over it.</p>\n<p>Consider a simple example where you have only five possible distinct pointer values. Let's call these O (for nullptr), \u03b3, \u03b6, \u03c7, \u03c8<sup>1</sup>.</p>\n<p>Let's say that no pair of two distinct pointers from the four non-null pointers can be compared with <code>&lt;</code>. We can simply arbitrarily say that <code>std::less</code> gives us this order: O \u03b6 \u03b3 \u03c8 \u03c7, even if <code>&lt;</code> doesn't.</p>\n<p>Of course, implementing this arbitrary ordering in an efficient manner is a matter of quality of implementation.</p>\n<hr>\n<p><sup>1</sup> I am using Greek letters to remove subconscious notion of order that would arise due to familiarity with the latin alphabet; my apologies to readers that know the Greek alphabet order</p>\n</hr>", "LastActivityDate": "2012-11-14T14:04:40.430"}});