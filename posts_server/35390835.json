post_cb({"35392987": {"Id": "35392987", "PostTypeId": "2", "Body": "<p>Surprisingly, C++98 and C++11 didn't say that you can compare a <code>iterator</code> with a <code>const_iterator</code>. This leads to <a href=\"http://cplusplus.github.io/LWG/lwg-defects.html#179\">LWG issue 179</a> and <a href=\"http://cplusplus.github.io/LWG/lwg-defects.html#2263\">LWG issue 2263</a>. Now in C++14, this is explicitly permitted by \u00a7 23.2.1[container.requirements.general]p7</p>\n<blockquote>\n<p id=\"so_35390835_35392987_0\">In the expressions</p>\n<pre><code>i == j\ni != j\ni &lt; j\ni &lt;= j\ni &gt;= j\ni &gt; j\ni - j\n</code></pre>\n<p id=\"so_35390835_35392987_1\">where <code>i</code> and <code>j</code> denote objects of a container's <code>iterator</code> type, either or\n  both may be replaced by an object of the container's <code>const_iterator</code>\n  type referring to the same element with no change in semantics.</p>\n</blockquote>\n", "LastActivityDate": "2016-02-14T14:41:28.043", "CommentCount": "2", "CreationDate": "2016-02-14T14:41:28.043", "ParentId": "35390835", "Score": "27", "OwnerUserId": "4672588"}, "bq_ids": {"n4140": {"so_35390835_35392987_1": {"length": 19, "quality": 1.0, "section_id": 708}, "so_35390835_35390954_1": {"length": 6, "quality": 1.0, "section_id": 705}, "so_35390835_35390932_0": {"length": 6, "quality": 1.0, "section_id": 5578}}, "n3337": {"so_35390835_35390954_1": {"length": 6, "quality": 1.0, "section_id": 695}, "so_35390835_35390932_0": {"length": 6, "quality": 1.0, "section_id": 5360}}, "n4659": {"so_35390835_35392987_1": {"length": 19, "quality": 1.0, "section_id": 737}, "so_35390835_35390954_1": {"length": 6, "quality": 1.0, "section_id": 734}, "so_35390835_35390932_0": {"length": 6, "quality": 1.0, "section_id": 7025}}}, "35390835": {"ViewCount": "1285", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nint main()\n{\n    std::vector&lt;int&gt; vec{1,2,3,5};\n    for(auto it=vec.cbegin();it!=vec.cend();++it)\n    {\n        std::cout &lt;&lt; *it;\n        // A typo: end instead of cend\n        if(next(it)!=vec.end()) std::cout &lt;&lt; \",\";\n    }\n    std::cout &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Here I've introduced a typo: in the comparison I called <code>vec.end()</code> instead of <code>vec.cend()</code>. This appears to work as intended with gcc 5.2. But is it actually well-defined according to the Standard? Can <code>iterator</code> and <code>const_iterator</code> be safely compared?</p>\n", "AcceptedAnswerId": "35392987", "Title": "Is comparison of const_iterator with iterator well-defined?", "CreationDate": "2016-02-14T10:43:57.097", "Id": "35390835", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-02-14T15:13:08.890", "Score": "23", "OwnerUserId": "673852", "Tags": "<c++><iterator><comparison-operators><const-iterator>", "AnswerCount": "3"}, "35390954": {"Id": "35390954", "PostTypeId": "2", "Body": "<p>See \u00a723.2.1, Table 96:</p>\n<blockquote id=\"so_35390835_35390954_0\">\n<pre><code>X::iterator\n</code></pre>\n</blockquote>\n<p>[...]</p>\n<blockquote>\n<p id=\"so_35390835_35390954_1\">any iterator category that meets the forward iterator requirements.</p>\n<p id=\"so_35390835_35390954_2\"><strong>convertible to <code>X::const_iterator</code></strong></p>\n</blockquote>\n<p>So, yes, it is well-defined.</p>\n", "LastActivityDate": "2016-02-14T10:58:02.870", "CommentCount": "4", "CreationDate": "2016-02-14T10:58:02.870", "ParentId": "35390835", "Score": "9", "OwnerUserId": "3313064"}, "35390932": {"Id": "35390932", "PostTypeId": "2", "Body": "<p>Table 96 in the C++11 Standard, in section 23.2.1, defines the <em>operational semantics</em> of <code>a.cend()</code> for any container type <code>X</code> (including <code>std::vector</code>) as follows:</p>\n<pre><code>const_cast&lt;X const &amp;&gt;(a).end()\n</code></pre>\n<p>So the answer is yes because by this definition <code>cend()</code> refers to the same element/position in the container as <code>end()</code>, and <code>X::iterator</code> must be convertible to <code>X::const_iterator</code> (a requirement also specified in the same table<sup>(&amp;ast;)</sup>).</p>\n<p>(The answer is also yes for <code>begin()</code> vs. <code>cbegin()</code> for the same reasons, as defined in the same table.)</p>\n<hr>\n<p><sup>(&amp;ast;)</sup> It has been pointed out in comments to other answers that convertibility does not necessarily imply that the comparison operation <code>i1==i2</code> will always work, e.g. if <code>operator==()</code> is a member function of the iterator type, the implicit conversion will only be accepted for the righthand-side argument, not the lefthand-side one. 24.2.5/6 states (about forward-iterators <code>a</code> and <code>b</code>):</p>\n<blockquote>\n<p id=\"so_35390835_35390932_0\">If <code>a</code> and <code>b</code> are both dereferenceable, then <code>a == b</code> if and only if <code>*a</code> and <code>*b</code> are bound to the same object</p>\n</blockquote>\n<p>Even though the iterators <code>end()</code> and <code>cend()</code> are not dereferenceable, the statement above implies that <code>operator==()</code> must be defined in such a way that the comparison is possible even if <code>a</code> is a const-iterator and <code>b</code> is not, and vice versa, because 24.2.5 is about forward-iterators in general, including both const- and non-const-versions -- this is clear e.g. from 24.2.5/1. This is why I am convinced that the wording from Table 96, which refers to convertibility, also implies comparability. But as described in cpplearner@'s later answer, this has been made explicitly clear only in C++14.</p>\n</hr>", "LastEditorUserId": "777186", "LastActivityDate": "2016-02-14T15:13:08.890", "Score": "7", "CreationDate": "2016-02-14T10:55:43.167", "ParentId": "35390835", "CommentCount": "0", "OwnerUserId": "777186", "LastEditDate": "2016-02-14T15:13:08.890"}});