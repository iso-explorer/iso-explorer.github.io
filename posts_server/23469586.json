post_cb({"23469586": {"CommentCount": "5", "ViewCount": "335", "PostTypeId": "1", "LastEditorUserId": "3865653", "CreationDate": "2014-05-05T09:53:22.200", "LastActivityDate": "2016-06-13T05:28:25.103", "Title": "Put an `unsigned char` into a `char`", "AcceptedAnswerId": "23469720", "LastEditDate": "2016-06-13T03:12:44.337", "Id": "23469586", "Score": "5", "Body": "<p>I would like to store an <code>unsigned char</code> into a <code>char</code> by means of a shift. As the two data types have the same length (1 byte on my machine), I would have expected the following code to work:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;cstdio&gt;\n\nusing namespace std;\n\nint main () {\n\n        printf (\"%d\\n\", sizeof(char));\n        printf (\"%d\\n\", sizeof(unsigned char));\n\n        unsigned char test = 49;\n        char testchar = (char) (test - 127);\n        printf (\"%x\\n\", testchar);\n\n        return 0;\n}\n</code></pre>\n<p>but it doesn't. In particular, I got the following output:</p>\n<pre><code>1\n1\nffffffb2\n</code></pre>\n<p>that suggests that the char has been casted to <code>int</code>. Does anybody has an explanation and, hopefully, a solution?</p>\n", "Tags": "<c++><casting>", "OwnerUserId": "3602256", "AnswerCount": "5"}, "23469871": {"ParentId": "23469586", "LastEditDate": "2016-06-13T03:58:24.853", "CommentCount": "0", "CreationDate": "2014-05-05T10:07:16.150", "Score": "2", "LastEditorUserId": "2172854", "PostTypeId": "2", "Id": "23469871", "OwnerUserId": "2632764", "Body": "<p><strong>What happens is !!!!</strong> </p>\n<p>1) <code>unsigned char test</code> = <code>49</code>;             // hex value 31 gets assigned</p>\n<p>2) <code>char testchar = (char) (test - 127);</code> // <code>49-127 = -78</code> ie; <code>0xb2</code> (as <code>unsigned</code>),converting it to <code>signed char</code> results <code>F</code> padding before <code>b2</code> to indicate it as negative</p>\n<p>3) <code>printf (\"%x\\n\", testchar);</code>  //Since <code>%x</code> is a specifier for a 4-byte int (as <em>@Don't You Worry Child</em> said) <code>ffffffb2</code>, 4 byte output is obtained </p>\n<p><strong>So try as per <em>@Don't You Worry Child</em> said</strong></p>\n", "LastActivityDate": "2016-06-13T03:58:24.853"}, "23469720": {"ParentId": "23469586", "LastEditDate": "2014-05-05T10:05:39.220", "CommentCount": "0", "CreationDate": "2014-05-05T10:00:11.383", "Score": "5", "LastEditorUserId": "2628863", "PostTypeId": "2", "Id": "23469720", "OwnerUserId": "2628863", "Body": "<p><code>%x</code> is a specifier for a 4-byte <code>int</code>. To print one byte <code>char</code> use <code>%hhx</code>.</p>\n<p><code>printf</code> typecasts its arguments according to the format specifiers passed to it.That is why <code>testchar</code> was type promoted to <code>int</code>.</p>\n", "LastActivityDate": "2014-05-05T10:05:39.220"}, "37782374": {"ParentId": "23469586", "CommentCount": "0", "CreationDate": "2016-06-13T05:28:25.103", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "37782374", "Score": "0", "Body": "<blockquote>\n<p id=\"so_23469586_37782374_0\">I would have expected the following code to work:</p>\n</blockquote>\n<p>It won't.</p>\n<p>Ignoring the issues other people have pointed out with how you're <em>printing</em> the character, there is no guarantee in the standard that your code will work. Why?</p>\n<p>Because <code>char</code> does not have to be <em>signed</em>. Whether <code>char</code> is <code>signed</code> or <code>unsigned</code> is implementation-dependent. Some implementations make <code>char</code> signed, others make it unsigned.</p>\n<p>As such, there's no guarantee that <code>(char) (test - 127)</code> will produce a value that can be represented by <code>char</code>.</p>\n<p>C++(14) does allow lossless conversion between <code>unsigned char</code> and <code>char</code>. The stadnard says (3.9.1/1):</p>\n<blockquote>\n<p id=\"so_23469586_37782374_1\">For each value i of type <code>unsigned char</code> in the range 0 to 255 inclusive, there exists a value j of type <code>char</code> such that the result of an integral conversion (4.7) from i to <code>char</code> is j, and the result of an integral conversion from j to <code>unsigned char</code> is i.</p>\n</blockquote>\n", "LastActivityDate": "2016-06-13T05:28:25.103"}, "37781463": {"ParentId": "23469586", "CommentCount": "0", "CreationDate": "2016-06-13T03:35:20.930", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "37781463", "Score": "1", "Body": "<p><code>%x</code> is only for printing <code>unsigned int</code>, however you supply a <code>char</code>. </p>\n<p>Using <code>%x</code> with a negative value of <code>char</code> causes undefined behaviour.  </p>\n<p><em>Aside:</em> The C Standard specification of <code>printf</code> is not particularly clear; some feel that passing anything except exactly an <code>unsigned int</code> causes undefined behaviour. Others (including myself) feel that it's OK to pass arguments that are not specifically <code>unsigned int</code>, but after the default argument promotions, have type <code>int</code> with a non-negative value. The standard does guarantee that non-negative <code>int</code>s have the same representation as the <code>unsigned int</code> with the same value.</p>\n<hr>\n<p>Some of the other answers suggest <code>%hhx</code>, but that is not any better than <code>%x</code>.  The standard (on a sensible interpretation) specifies that <code>%hhx</code> only be used with an <code>unsigned char</code> argument, and <code>%hhd</code> only be used with a <code>signed char</code> argument.  There is actually no modifier for plain <code>char</code>.</p>\n<p>Either way you look at it, nowhere can <code>printf</code> be used to convert negative values to positive representations in a well-defined manner.  You must convert the argument yourself and then use a matching format specifier.  In this case:</p>\n<pre><code>printf (\"%hhx\\n\", (unsigned char)testchar);\n</code></pre>\n<p>would be one option.  IMO <code>%x</code> could be used here, but as mentioned above, some disagree.</p>\n<hr>\n<p>NB. The wrong format specifier is used in <code>printf (\"%d\\n\", sizeof(char));</code> and the line following that. The specifier for <code>size_t</code> is <code>%zu</code>. So you could either use <code>%zu</code>, or cast the argument to <code>int</code>, or even better:</p>\n<pre><code>printf(\"1\\n\");\n</code></pre>\n</hr></hr>", "LastActivityDate": "2016-06-13T03:35:20.930"}, "23469694": {"ParentId": "23469586", "LastEditDate": "2017-05-23T10:29:01.153", "CommentCount": "0", "CreationDate": "2014-05-05T09:58:43.627", "Score": "5", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "23469694", "OwnerUserId": "126769", "Body": "<p>printf is a variable argument function, and as such it's arguments are subject to default promotion rules. For this case, your char is promoted to an int, and in that process is sign extended.\nA 2's complement int of 4 bytes with the binary pattern 0xffffffb2 is -78. Print it as a char with the <code>%hhx</code> specifier.</p>\n<p>See also <a href=\"https://stackoverflow.com/questions/19444843/which-integral-promotions-do-take-place-when-printing-a-char\">Which integral promotions do take place when printing a char?</a></p>\n", "LastActivityDate": "2014-05-05T10:04:20.953"}, "bq_ids": {"n4140": {"so_23469586_37782374_1": {"section_id": 7210, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_23469586_37782374_1": {"section_id": 8719, "quality": 0.9583333333333334, "length": 23}}}});