post_cb({"14035689": {"ParentId": "14035520", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The problem is the same at the one faced by the standard library implementation. There are several ways to solve it.</p>\n<ul>\n<li><p>You can meticulously provide non-template overloaded constructors for all integral types (in place of the first parameter).</p></li>\n<li><p>You can use SFINAE-based technique (like <code>enable_if</code>) to make sure the range constructor is not selected for integer argument.</p></li>\n<li><p>You can branch the range constructor at run-time (by using <code>if</code>) after detecting integral argument (by using <code>is_integral</code>) and redirect control to the proper constructing code. The branching condition will be a compile-time value, meaning that the code will probably be reduced at compile-time by the compiler.</p></li>\n<li><p>You can simply peek into your version of standard library implementation and see how they do it (although their approach is not required to be portable and/or valid from the point of view of abstract C++ language).</p></li>\n</ul>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2012-12-26T03:39:28.280", "Id": "14035689", "Score": "3", "CreationDate": "2012-12-26T03:28:16.237", "LastActivityDate": "2012-12-26T03:39:28.280"}, "14035612": {"ParentId": "14035520", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This ambiguity caused problems for early library implementers. It's called the \"Do The Right Thing\" effect. As far as I know, you need <a href=\"http://en.wikipedia.org/wiki/SFINAE\" rel=\"nofollow\">SFINAE</a> to solve it\u2026 it might have been one of the first applications of that technique. (Some compilers cheated and hacked their overload resolution internals, until the solution was found within the core language.)</p>\n<p>The standard specification of this issue is one of the key differences between C++98 and C++03. From C++11, \u00a723.2.3:</p>\n<blockquote>\n<p id=\"so_14035520_14035612_0\">14 For every sequence container defined in this Clause and in Clause 21:</p>\n<p id=\"so_14035520_14035612_1\">\u2014 If the constructor</p>\n<pre><code>       template &lt;class InputIterator&gt;\n       X(InputIterator first, InputIterator last,\n         const allocator_type&amp; alloc = allocator_type())\n</code></pre>\n<p id=\"so_14035520_14035612_2\">is called with a type InputIterator that does not qualify as an input iterator, then the constructor shall not participate in overload resolution.</p>\n<p id=\"so_14035520_14035612_3\">15 The extent to which an implementation determines that a type cannot be an input iterator is unspecified, except that as a minimum integral types shall not qualify as input iterators.</p>\n</blockquote>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2012-12-26T03:34:52.497", "Id": "14035612", "Score": "2", "CreationDate": "2012-12-26T03:12:33.013", "LastActivityDate": "2012-12-26T03:34:52.497"}, "14035577": {"ParentId": "14035520", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You can use <code>std::enable_if</code> (or <code>boost::enable_if</code> if you don't use C++11) to disambiguate the constructors.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\n\ntemplate &lt;typename Type&gt; \nclass Vector {\npublic:\n    // fill constructor\n    Vector(size_t num, const Type&amp; cont)\n    { \n        cout &lt;&lt; \"Fill constructor\" &lt;&lt; endl;\n    }\n\n    // range constructor\n    template&lt;typename InputIterator&gt; Vector(InputIterator first, InputIterator last,\n        typename std::enable_if&lt;!std::is_integral&lt;InputIterator&gt;::value&gt;::type* = 0)\n    { \n        cout &lt;&lt; \"Range constructor\" &lt;&lt; endl;\n    }\n\n};\n\nint main()\n{\n    Vector&lt;int&gt; v1(3, 5);\n    std::vector&lt;int&gt; v2(3, 5);\n    Vector&lt;int&gt; v3(v2.begin(), v2.end());\n}\n</code></pre>\n<p><br>\nThe above program should first call the fill constructor by checking if the type is an integral type (and thus not an iterator.)<br>\n<br>\n<br/></br></br></br></p>\n<p>By the way, in your implementation of the range constructor, you should use <code>std::distance(first, last)</code> rather than <code>last - first</code>.  Explicitly using the <code>-</code> operator on iterators limits you to <code>RandomAccessIterator</code> types, but you want to support <code>InputIterator</code> which is the most generic type of Iterator.  </p>\n", "OwnerUserId": "168288", "LastEditorUserId": "168288", "LastEditDate": "2012-12-26T03:46:23.927", "Id": "14035577", "Score": "12", "CreationDate": "2012-12-26T03:06:40.107", "LastActivityDate": "2012-12-26T03:46:23.927"}, "14035520": {"CommentCount": "1", "AcceptedAnswerId": "14035577", "PostTypeId": "1", "LastEditorUserId": "890846", "CreationDate": "2012-12-26T02:53:11.217", "LastActivityDate": "2012-12-26T03:46:23.927", "LastEditDate": "2012-12-26T03:00:01.737", "ViewCount": "2331", "FavoriteCount": "2", "Title": "choose which constructor in c++", "Id": "14035520", "Score": "13", "Body": "<p>I am practicing C++ by building my own version of vector, named \"Vector\". I have two constructors among others, fill constructor and range constructor. Their declarations look like following:</p>\n<pre><code>template &lt;typename Type&gt; \nclass Vector {\npublic:\n    // fill constructor\n    Vector(size_t num, const Type&amp; cont);\n\n    // range constructor\n    template&lt;typename InputIterator&gt; Vector(InputIterator first, InputIterator last);\n\n    /* \n    other members\n    ......\n    */\n}\n</code></pre>\n<p>The fill constructor fills the container with num of val; and the range constructor copies every value in the range [first, last) into the container. They are supposed to be the same with the two constructors of the STL vector.</p>\n<p>Their definitions goes following:</p>\n<pre><code>//fill constructor \ntemplate &lt;typename Type&gt; \nVector&lt;Type&gt;::Vector(size_t num, const Type&amp; cont){\n    content = new Type[num];\n    for (int i = 0; i &lt; num; i ++)\n        content[i] = cont;\n    contentSize = contentCapacity = num;\n}\n\n// range constructor\ntemplate &lt;typename Type&gt; \ntemplate&lt;typename InputIterator&gt;\nVector&lt;Type&gt;::Vector(InputIterator first, InputIterator last){\n    this-&gt;content = new Type[last - first];\n\n    int i = 0;\n    for (InputIterator iitr = first; iitr != last; iitr ++, i ++)\n    *(content + i) = *iitr;\n\n    this-&gt;contentSize = this-&gt;contentCapacity = i;\n}\n</code></pre>\n<p>However, when I try to use them, I have problem distinguishing them.\nFor example:</p>\n<pre><code>Vector&lt;int&gt; v1(3, 5);\n</code></pre>\n<p>With the this line of code, I intended to create a Vector that contains three elements, each of which is 5. But the compiler goes for the range constructor, treating both \"3\" and \"5\" as instances of the \"InputIterator\", which, with no surprises, causes error. </p>\n<p>Of course, if I change the code to:</p>\n<pre><code>Vector&lt;int&gt; v1(size_t(3), 5);\n</code></pre>\n<p>Everything is fine, the fill constructor is called. But that is obviously not intuitive and user friendly. </p>\n<p>So, is there a way that I can use the fill constructor intuitively?</p>\n", "Tags": "<c++><constructor><resolution>", "OwnerUserId": "890846", "AnswerCount": "4"}, "14035610": {"ParentId": "14035520", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Even <code>std::vector</code> seems to have this issue.</p>\n<pre><code>std::vector&lt;int&gt; v2(2,3);\n</code></pre>\n<p>chooses </p>\n<pre><code>template&lt;class _Iter&gt;\n        vector(_Iter _First, _Iter _Last)\n</code></pre>\n<p>In Visual C++, even though it should match closer to the non templated case..</p>\n<p>Edit: That above function (correctly) delegates the construction to the below one. I am totally lost..</p>\n<pre><code>template&lt;class _Iter&gt;\n        void _Construct(_Iter _Count, _Iter _Val, _Int_iterator_tag)\n</code></pre>\n<p>Edit #2 AH!:</p>\n<p>Somehow this below function identifies which version of the constructor is meant to be called. </p>\n<pre><code>template&lt;class _Iter&gt; inline\n    typename iterator_traits&lt;_Iter&gt;::iterator_category\n        _Iter_cat(const _Iter&amp;)\n    {   // return category from iterator argument\n    typename iterator_traits&lt;_Iter&gt;::iterator_category _Cat;\n    return (_Cat);\n    }\n</code></pre>\n<p>The above shown <code>_Construct</code> function has (atleast) 2 versions overloading on the third variable which is a tag to returned by the above <code>_Iter_cat</code> function. Based on the type of this category the correct overload of the <code>_Construct</code> is picked. </p>\n<p>Final edit:\n<code>iterator_traits&lt;_Iter&gt;</code> is a class that seems to be templated for many different common varieties, each returning the appropriate \"Category\" type</p>\n<p><strong>Solution</strong>: It appears template specialization of the first arguement's type is how the <code>std</code> library handles this messy situation (primitive value type) in the case of MS VC++. Perhaps you could look into it and follow suit?</p>\n<p>The problem arises (I think) because with primitive value types, the <code>Type</code> and <code>size_t</code> variables are similar, and so the template version with two identical types gets picked.</p>\n", "OwnerUserId": "1520364", "LastEditorUserId": "1520364", "LastEditDate": "2012-12-26T03:30:37.733", "Id": "14035610", "Score": "3", "CreationDate": "2012-12-26T03:12:01.213", "LastActivityDate": "2012-12-26T03:30:37.733"}, "bq_ids": {"n4140": {"so_14035520_14035612_3": {"section_id": 734, "quality": 0.9375, "length": 15}, "so_14035520_14035612_2": {"section_id": 733, "quality": 1.0, "length": 12}, "so_14035520_14035612_0": {"section_id": 733, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_14035520_14035612_3": {"section_id": 723, "quality": 0.9375, "length": 15}, "so_14035520_14035612_2": {"section_id": 722, "quality": 1.0, "length": 12}, "so_14035520_14035612_0": {"section_id": 722, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_14035520_14035612_3": {"section_id": 747, "quality": 0.9375, "length": 15}, "so_14035520_14035612_2": {"section_id": 763, "quality": 1.0, "length": 12}, "so_14035520_14035612_0": {"section_id": 763, "quality": 0.8571428571428571, "length": 6}}}});