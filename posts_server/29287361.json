post_cb({"29287615": {"ParentId": "29287361", "CommentCount": "0", "Body": "<p>If you have:</p>\n<p>file1.cpp:</p>\n<pre><code>inline void foo() { std::cout &lt;&lt; \"Came to foo in file1.cpp\" &lt;&lt; std::endl; }\n</code></pre>\n<p>and</p>\n<p>file2.cpp:</p>\n<pre><code>inline void foo() { std::cout &lt;&lt; \"Came to foo in file2.cpp\" &lt;&lt; std::endl; }\n</code></pre>\n<p>and you link those files together in an executable, you are violating the <code>one-definition-rule</code> since the two versions of the <code>inline</code> function are not same.</p>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "29287615", "Score": "0", "CreationDate": "2015-03-26T19:54:15.307", "LastActivityDate": "2015-03-26T19:54:15.307"}, "29287444": {"ParentId": "29287361", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_29287361_29287444_0\">I just read that constexpr and inline functions obey one-definition rule, but they definition must be identical.</p>\n</blockquote>\n<p>This is in reference to inline functions in different translations units.  In your example they are both in the same translation unit.</p>\n<p>This is covered in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">draft C++ standard</a> <code>3.2</code> One definition rule <em>[basic.def.odr]</em> which says:</p>\n<blockquote>\n<p id=\"so_29287361_29287444_1\">There can be more than one definition of a class type (Clause 9), enumeration type (7.2), <strong>inline function with\n  external linkage</strong> (7.1.2), class template (Clause 14), non-static function template (14.5.6), static data member\n  of a class template (14.5.1.3), member function of a class template (14.5.1.1), or template specialization for\n  which some template parameters are not specified (14.7, 14.5.5) in a program provided that each definition\n  appears in a different translation unit, and provided the definitions satisfy the following requirements. Given\n  such an entity named D defined in more than one translation unit, then</p>\n</blockquote>\n<p>and includes the following bullet:</p>\n<blockquote id=\"so_29287361_29287444_2\">\n<ul>\n<li>each definition of D shall consist of the same sequence of tokens; and</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-03-26T22:06:29.733", "Id": "29287444", "Score": "2", "CreationDate": "2015-03-26T19:42:16.837", "LastActivityDate": "2015-03-26T22:06:29.733"}, "29287458": {"ParentId": "29287361", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You are defining functions repeatedly <em>in one translation unit</em>. This is always forbidden:</p>\n<blockquote>\n<p id=\"so_29287361_29287458_0\">No translation unit shall contain more than one definition of any variable, function, class type, enumeration\n  type, or template. (C++11 3.2/1)</p>\n</blockquote>\n<p>For <code>inline</code> functions, you are allowed to define same function in exactly the same way in more than one translation unit (read: .cpp file). In fact, you <em>must</em> define it in every translation unit (which is usually done by defining it in a header file):</p>\n<blockquote>\n<p id=\"so_29287361_29287458_1\">An inline function shall be defined in every translation unit in which it is odr-used. (C++11 3.2/3)</p>\n</blockquote>\n<p>For \"normal\" (non-inline, non-constexpr, non-template, etc.) functions with external linkage (non-static) functions, this will usually (no diagnostic required) lead to a linker error.</p>\n<blockquote>\n<p id=\"so_29287361_29287458_2\">Every program shall contain exactly one definition of every non-inline function or variable that is odr-used\n  in that program; no diagnostic required. (C++11 3.2/3)</p>\n</blockquote>\n<p>To sum up:</p>\n<ul>\n<li>Never define anything multiple times in one translation unit (which is a .cpp file and all directly or indirectly included headers).</li>\n<li>You may put a certain number of things into header files, where they will be included <em>once</em> in several different translation units, for example:\n<ul>\n<li><code>inline</code> functions</li>\n<li><code>class</code> types and <code>template</code>s</li>\n<li><code>static</code> data members of a <code>class template</code>.</li>\n</ul></li>\n</ul>\n", "OwnerUserId": "65678", "LastEditorUserId": "65678", "LastEditDate": "2015-03-26T19:52:10.973", "Id": "29287458", "Score": "2", "CreationDate": "2015-03-26T19:43:09.060", "LastActivityDate": "2015-03-26T19:52:10.973"}, "bq_ids": {"n4140": {"so_29287361_29287444_1": {"section_id": 7043, "quality": 0.9076923076923077, "length": 59}, "so_29287361_29287458_2": {"section_id": 7041, "quality": 0.8571428571428571, "length": 12}, "so_29287361_29287458_1": {"section_id": 5404, "quality": 0.7777777777777778, "length": 7}, "so_29287361_29287458_0": {"section_id": 7038, "quality": 0.875, "length": 14}, "so_29287361_29287444_2": {"section_id": 7043, "quality": 1.0, "length": 6}}, "n3337": {"so_29287361_29287444_1": {"section_id": 6788, "quality": 0.9076923076923077, "length": 59}, "so_29287361_29287458_2": {"section_id": 6786, "quality": 0.8571428571428571, "length": 12}, "so_29287361_29287458_1": {"section_id": 5199, "quality": 0.7777777777777778, "length": 7}, "so_29287361_29287458_0": {"section_id": 6784, "quality": 0.875, "length": 14}, "so_29287361_29287444_2": {"section_id": 6788, "quality": 1.0, "length": 6}}, "n4659": {"so_29287361_29287458_0": {"section_id": 8535, "quality": 0.875, "length": 14}, "so_29287361_29287458_2": {"section_id": 8538, "quality": 0.8571428571428571, "length": 12}, "so_29287361_29287458_1": {"section_id": 6853, "quality": 0.7777777777777778, "length": 7}, "so_29287361_29287444_1": {"section_id": 8540, "quality": 0.9076923076923077, "length": 59}, "so_29287361_29287444_2": {"section_id": 8540, "quality": 1.0, "length": 6}}}, "29287361": {"CommentCount": "1", "ViewCount": "192", "CreationDate": "2015-03-26T19:37:19.607", "LastActivityDate": "2015-03-26T22:06:29.733", "Title": "What means \"obey ODR\" in case of inline and constexpr function?", "AcceptedAnswerId": "29287444", "PostTypeId": "1", "Id": "29287361", "Score": "3", "Body": "<p>I just read that constexpr and inline functions obey one-definition rule, but they definition must be identical. So I try it:</p>\n<pre><code>inline void foo() {\n    return;\n}\n\ninline void foo() {\n    return;\n}\n\nint main() {\n    foo();\n};\n</code></pre>\n<p>error: redefinition of 'void foo()',<br/>\nand</p>\n<pre><code>constexpr int foo() {\n    return 1;\n}\n\nconstexpr int foo() {\n    return 1;\n}\n\nint main() {\n    constexpr x = foo();\n}; \n</code></pre>\n<p>error: redefinition of 'constexpr int foo()'</p>\n<p>So what exactly means that, constexpr and inline function can obey ODR?</p>\n", "Tags": "<c++><c++11><inline><constexpr><one-definition-rule>", "OwnerUserId": "2534793", "AnswerCount": "3"}});