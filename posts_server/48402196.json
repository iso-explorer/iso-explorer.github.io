post_cb({"bq_ids": {"n4140": {"so_48402196_48402461_2": {"length": 13, "quality": 0.5416666666666666, "section_id": 3298}, "so_48402196_48402461_1": {"length": 7, "quality": 0.5833333333333334, "section_id": 3325}}, "n3337": {"so_48402196_48402461_2": {"length": 13, "quality": 0.5416666666666666, "section_id": 3168}, "so_48402196_48402461_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 3195}}, "n4659": {"so_48402196_48402461_2": {"length": 20, "quality": 0.8333333333333334, "section_id": 4063}, "so_48402196_48402461_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 4091}}}, "48402196": {"ViewCount": "108", "Body": "<p>The following code does not compile with either Visual Studio2017 or online GDB. I expected it to compile as iterator is just a class with types and it is inherited from publicly. Is this not allowed or doesnt this work in VS2017?</p>\n<pre><code>template&lt;typename T&gt;\nstruct Gen : public std::iterator&lt;std::input_iterator_tag, T&gt;\n{\n    T value;\n};\n\nint main()\n{   \n    Gen&lt;int&gt; g = Gen&lt;int&gt;{ 10 }; // this doesnt\n    Gen&lt;int&gt; g2 = Gen&lt;int&gt;{ {}, 10 }; // neither does this\n}\n</code></pre>\n<p>The error is </p>\n<blockquote>\n<p id=\"so_48402196_48402196_0\">Error C2440   'initializing': cannot convert from 'initializer list' to\n  'Gen'</p>\n</blockquote>\n", "AcceptedAnswerId": "48402461", "Title": "Aggregate initialization of a derived class", "CreationDate": "2018-01-23T12:49:38.130", "LastActivityDate": "2018-01-23T14:50:44.337", "CommentCount": "1", "LastEditDate": "2018-01-23T13:39:23.270", "PostTypeId": "1", "LastEditorUserId": "5470596", "Id": "48402196", "Score": "5", "OwnerUserId": "1866300", "Tags": "<c++><initialization>", "AnswerCount": "1"}, "48402461": {"Id": "48402461", "PostTypeId": "2", "Body": "<p>What </p>\n<pre><code>Gen&lt;int&gt; g = Gen&lt;int&gt;{ 10 };\n</code></pre>\n<p>tries to do is calling the non-existent <code>Gen&lt;int&gt;(int)</code> constructor. What you want to do is <em>aggregate initialization</em> whose syntax is:</p>\n<pre><code>Gen&lt;int&gt; g = { {}, 10 };\n</code></pre>\n<p>And <a href=\"http://en.cppreference.com/w/cpp/language/aggregate_initialization\" rel=\"nofollow noreferrer\"><strong>only works since C++17</strong></a> for derived types:</p>\n<blockquote>\n<p id=\"so_48402196_48402461_0\">If the initializer clause is a nested braced-init-list (which is not an expression), the corresponding array element/class member <strong>/public base (since C++17)</strong> is list-initialized from that clause: aggregate initialization is recursive. </p>\n</blockquote>\n<hr>\n<p>For more information, <em>aggregate initialization</em> is defined in the following standard sections.</p>\n<blockquote id=\"so_48402196_48402461_1\">\n<h3><a href=\"http://eel.is/c++draft/dcl.init.list#3\" rel=\"nofollow noreferrer\"><code>[dcl.init.list]/3</code></a></h3>\n<ol start=\"3\">\n<li>List-initialization of an object or reference of type T is defined as follows:<br>\n  3.1 If the <em>braced-init-list</em> contains a <em>designated-initializer-list</em>, T shall be an aggregate class.</br></li>\n</ol>\n</blockquote>\n<p>and</p>\n<blockquote>\n<h3><a href=\"http://eel.is/c++draft/dcl.init.aggr#1\" rel=\"nofollow noreferrer\"><code>[dcl.init.aggr]/1</code></a></h3>\n<p id=\"so_48402196_48402461_2\">An aggregate is an array or a class (Clause 12) with<br>\n  1.1 no user-provided, explicit, or inherited constructors (15.1),<br>\n  1.2 no private or protected non-static data members (Clause 14),<br>\n  1.3 no virtual functions (13.3), and<br>\n  1.4 no virtual, private, or protected base classes (13.1).  </br></br></br></br></p>\n</blockquote>\n<p>Because in inherits from <code>std::iterator&lt;std::input_iterator_tag, T&gt;</code>.</p>\n</hr>", "LastEditorUserId": "5470596", "LastActivityDate": "2018-01-23T14:50:44.337", "Score": "10", "CreationDate": "2018-01-23T13:03:21.227", "ParentId": "48402196", "CommentCount": "3", "OwnerUserId": "5470596", "LastEditDate": "2018-01-23T14:50:44.337"}});