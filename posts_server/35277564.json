post_cb({"35278267": {"Id": "35278267", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_35277564_35278267_0\">Does the Standard explicitly forbid modifying a container within <code>std::for_each</code>?</p>\n</blockquote>\n<p>The only thing I can think of that would make this code not standard compliant is that in <code>[alg.foreach]</code> we have </p>\n<blockquote>\n<p id=\"so_35277564_35278267_1\"><em>Complexity:</em> Applies <code>f</code> exactly <code>last - first</code> times.</p>\n</blockquote>\n<p><sup><code>f</code> being the function <code>for_each</code> applies.</sup></p>\n<p>Since the list is modified and an element is removed we no longer satisfy that complexity.  I do not know if that make it non conforming but it is the only thing I could see that would not allow you to remove elements from the container while using <code>for_each</code></p>\n", "LastEditorUserId": "4342498", "LastActivityDate": "2016-02-08T21:10:10.120", "Score": "3", "CreationDate": "2016-02-08T20:01:32.127", "ParentId": "35277564", "CommentCount": "0", "OwnerUserId": "4342498", "LastEditDate": "2016-02-08T21:10:10.120"}, "35277592": {"Id": "35277592", "PostTypeId": "2", "Body": "<p>Yes, it's legal. There's const iters if you need something that is guaranteed not to modify the underlying container.</p>\n", "LastActivityDate": "2016-02-08T19:21:41.270", "CommentCount": "3", "CreationDate": "2016-02-08T19:21:41.270", "ParentId": "35277564", "Score": "-1", "OwnerUserId": "4433386"}, "35278527": {"Id": "35278527", "PostTypeId": "2", "Body": "<p>25.2.4/2:</p>\n<blockquote>\n<p id=\"so_35277564_35278527_0\">Effects: Applies f to the result of dereferencing every iterator in the\n  range [first,last), starting from first and proceeding to last - 1.</p>\n</blockquote>\n<p>Then 25.2.4/4:</p>\n<blockquote>\n<p id=\"so_35277564_35278527_1\">Complexity: Applies f exactly last - first times.</p>\n</blockquote>\n<p>I'm prepared to argue that these two points explicitly prohibit mutating the container in a way that changes the number of elements.</p>\n<p>That said, even it doesn't your example fails if the list has even one more item, OR if your standard library implementation increments the iterator before calling your function (and I can't see anything in the standard that prohibits such an implementation).</p>\n", "LastEditorUserId": "251738", "LastActivityDate": "2016-02-08T20:31:32.040", "Score": "2", "CreationDate": "2016-02-08T20:18:52.253", "ParentId": "35277564", "CommentCount": "0", "OwnerUserId": "251738", "LastEditDate": "2016-02-08T20:31:32.040"}, "35278515": {"Id": "35278515", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_35277564_35278515_0\">Does the Standard explicitly forbid modifying a container within\n  <code>std::for_each</code>?</p>\n</blockquote>\n<p>No, not <strong>explicitly</strong>. At least for any sensible definition of \"explicitly\". The section on <code>std::for_each</code> (\u00a725.2.4) does not say anything at all about iterator invalidation or side effects that cause modification of the iterated range.</p>\n<p>There are, however, plenty of <strong>implicit</strong> reasons for why your code cannot work. Consider how <code>std::for_each</code> must be implemented. It's completely generic and therefore does not know anything about the <code>std::list</code> it operates on; you gave it two iterators to form a range, which means that <code>last</code> can be reached from <code>first</code>. How should <code>std::for_each</code> know that your function object has invalidated the local iterator object with which it goes from <code>first</code> to <code>last</code>?</p>\n<p>And even if the function knew that invalidation has occurred, what should it do? In a hand-written loop, you'd take the result of <code>erase</code> and continue iteration with it, but <code>std::for_each</code> cannot do that, by definition.</p>\n<p>Here's an old but still valid reference article: <a href=\"http://www.drdobbs.com/effective-standard-c-library-foreach-vs/184403769\" rel=\"nofollow\">http://www.drdobbs.com/effective-standard-c-library-foreach-vs/184403769</a></p>\n<p>It says:</p>\n<blockquote>\n<p id=\"so_35277564_35278515_1\">For instance, invalidating the iterators or the sequences that the\n  algorithm works with is disastrous in any case. Even the function\n  object supplied to for_each must obey this common-sense rule, even if\n  the Standard does not say so.</p>\n</blockquote>\n<hr>\n<p>Paraphrasing some wise words I once read:</p>\n<p><em>The C++ standard is written by human beings; it's not always as perfect as we wish it to be.</em></p>\n</hr>", "LastEditorUserId": "3313064", "LastActivityDate": "2016-02-08T20:25:38.377", "Score": "3", "CreationDate": "2016-02-08T20:18:06.660", "ParentId": "35277564", "CommentCount": "0", "OwnerUserId": "3313064", "LastEditDate": "2016-02-08T20:25:38.377"}, "bq_ids": {"n4140": {"so_35277564_35278527_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 1253}, "so_35277564_35278267_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 1255}, "so_35277564_35278527_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 1255}}, "n3337": {"so_35277564_35278527_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 1251}, "so_35277564_35278267_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 1253}, "so_35277564_35278527_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 1253}}, "n4659": {"so_35277564_35278527_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 1358}, "so_35277564_35278267_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 1360}, "so_35277564_35278527_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 1360}}}, "35277908": {"Id": "35277908", "PostTypeId": "2", "Body": "<p>Your code is borderline legal.</p>\n<p>With the posted code, it is legal by coincidence. If you add one more item to the list, your program will crash.</p>\n<p>Try the following to see the problem:</p>\n<pre><code>int main()\n{\n   std::list&lt;int&gt; list;\n\n   list.push_front(5);\n   list.push_front(10);\n   list.push_front(12);\n   auto it = list.end();\n   it--; // point to 5\n\n   std::for_each(list.begin(), list.end(), [&amp;](int i){\n                 /* the line below will remove the last element in the list;\n                  * list will have only one element (the currently processed one);\n                  * list.end() is not invalidated and we exit for_each() */\n                 list.erase(it);\n                 });\n}\n</code></pre>\n", "LastActivityDate": "2016-02-08T19:41:07.753", "CommentCount": "6", "CreationDate": "2016-02-08T19:41:07.753", "ParentId": "35277564", "Score": "2", "OwnerUserId": "434551"}, "35277564": {"ViewCount": "240", "Body": "<p>Does the Standard explicitly forbid modifying a container within <code>std::for_each</code>?</p>\n<p>More specifically, in case of <code>std::list</code> iterators are not invalidated when the list is modified. Thus, the following code works:</p>\n<pre><code>std::list&lt;int&gt; list;\n\nlist.push_front(5);\nlist.push_front(10);\nauto it = list.end();\nit--; // point to 5\n\nstd::for_each(list.begin(), list.end(), [&amp;](int i){\n    /* the line below will remove the last element in the list;\n     * list will have only one element (the currently processed one);\n     * list.end() is not invalidated and we exit for_each() */\n    list.erase(it);\n});\n</code></pre>\n<p>This is definitely a bad code. But is it legal?</p>\n", "AcceptedAnswerId": "35278267", "Title": "Modifying a container within std::for_each", "CreationDate": "2016-02-08T19:19:35.383", "Id": "35277564", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-02-08T21:10:10.120", "Score": "7", "OwnerUserId": "2508253", "Tags": "<c++><language-lawyer>", "AnswerCount": "5"}});