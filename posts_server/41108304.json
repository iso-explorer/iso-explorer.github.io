post_cb({"bq_ids": {"n4140": {"so_41108304_41108347_1": {"length": 11, "quality": 1.0, "section_id": 6014}, "so_41108304_41108347_3": {"length": 9, "quality": 0.8181818181818182, "section_id": 40}}, "n3337": {"so_41108304_41108347_1": {"length": 11, "quality": 1.0, "section_id": 5782}, "so_41108304_41108347_3": {"length": 9, "quality": 0.8181818181818182, "section_id": 37}}, "n4659": {"so_41108304_41108347_1": {"length": 11, "quality": 1.0, "section_id": 7513}, "so_41108304_41108347_3": {"length": 9, "quality": 0.8181818181818182, "section_id": 41}}}, "41108304": {"ViewCount": "194", "Body": "<p>As the title says, if I cast a pointer to a base class, to a derived class, when the pointer is null, is it a safe operation from the point of view of the C++11/C++14 standard?</p>\n<pre><code>struct base\n{\n   virtual ~base() = default;\n};\n\nstruct derived : base {};\n\nstruct wrapper\n{\n   using allowed_derived_t = derived;\n   base* base_ptr = nullptr;\n\n   void set_ptr(base* ptr)\n   {\n       if (!dynamic_cast&lt;allowed_derived_t*&gt;(ptr))\n          throw std::logic_error(\"Check your user code\");\n\n      base_ptr = ptr;\n   }\n\n   allowed_derived_t* ptr() const\n   { return static_cast&lt;allowed_derived_t*&gt;(base_ptr); }\n};\n</code></pre>\n<p>Is it the <code>ptr()</code> method safe, if I call it before calling <code>set_ptr</code>? Because, before setting the pointer, the <code>base_ptr</code> is not of the required type (<code>allowed_derived_t</code>), however, the dynamic pointed-to object isn't either of the wrong type (because there's no pointed-to object).</p>\n<p>What does the standard say in that situation?</p>\n", "Title": "use `static_cast` for downcasting over a null pointer (single or multiple inheritance)", "CreationDate": "2016-12-12T19:40:19.957", "LastActivityDate": "2016-12-12T19:57:58.763", "CommentCount": "0", "PostTypeId": "1", "Id": "41108304", "Score": "0", "OwnerUserId": "1794803", "Tags": "<c++><pointers><polymorphism><downcasting>", "AnswerCount": "2"}, "41108365": {"Id": "41108365", "PostTypeId": "2", "Body": "<p><code>static_cast</code> checks if the conversion is valid at compile time, thus the runtime value of the casted pointer doesn't play any role.</p>\n<p>So it's safe, a <code>nullptr</code> will result in a <code>nullptr</code> at runtime.</p>\n<p>As much that's true for any other type of cast.</p>\n", "LastEditorUserId": "1413395", "LastActivityDate": "2016-12-12T19:57:58.763", "Score": "1", "CreationDate": "2016-12-12T19:45:24.820", "ParentId": "41108304", "CommentCount": "0", "OwnerUserId": "1413395", "LastEditDate": "2016-12-12T19:57:58.763"}, "41108347": {"Id": "41108347", "PostTypeId": "2", "Body": "<p>All well-formed pointer-to-pointer casts guarantee that null pointer of source type is safely converted to a null pointer of target type.</p>\n<p>For <code>dynamic_cast</code> it is stated in </p>\n<blockquote>\n<p id=\"so_41108304_41108347_0\"><strong>5.2.7 Dynamic cast</strong></p>\n<p id=\"so_41108304_41108347_1\"><strong>4</strong> If the value of v is a null pointer value in the pointer case, the result is the null pointer value of type T.</p>\n</blockquote>\n<p>For <code>static_cast</code> it is stated in</p>\n<blockquote>\n<p id=\"so_41108304_41108347_2\"><strong>5.2.9 Static cast</strong></p>\n<p id=\"so_41108304_41108347_3\"><strong>11</strong> [...] The null pointer value (4.10) is converted to the null pointer value of the destination type.</p>\n</blockquote>\n<p>Similar guarantees are provided by all other casts.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2016-12-12T19:50:22.017", "Score": "5", "CreationDate": "2016-12-12T19:44:18.107", "ParentId": "41108304", "CommentCount": "0", "OwnerUserId": "187690", "LastEditDate": "2016-12-12T19:50:22.017"}});