post_cb({"28204078": {"Id": "28204078", "PostTypeId": "2", "Body": "<p>This is a feature called <a href=\"https://stackoverflow.com/questions/12654067/what-is-expression-sfinae\">\"Expression SFINAE.\"</a>  It is not yet fully supported by Visual C++ (see <a href=\"http://blogs.msdn.com/b/vcblog/archive/2014/11/17/c-11-14-17-features-in-vs-2015-preview.aspx\" rel=\"nofollow noreferrer\">\"C++11/14/17 Features In VS 2015 Preview\"</a> for the latest conformance update as of the time of this answer).</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-01-28T23:01:38.410", "Score": "32", "CreationDate": "2015-01-28T23:01:38.410", "ParentId": "28203981", "CommentCount": "1", "OwnerUserId": "151292", "LastEditDate": "2017-05-23T12:09:23.757"}, "bq_ids": {"n4140": {"so_28203981_28204207_0": {"length": 18, "quality": 1.0, "section_id": 158}, "so_28203981_28204207_2": {"length": 11, "quality": 1.0, "section_id": 7043}, "so_28203981_28204207_1": {"length": 16, "quality": 1.0, "section_id": 157}, "so_28203981_28204207_3": {"length": 16, "quality": 1.0, "section_id": 158}}, "n3337": {"so_28203981_28204207_2": {"length": 11, "quality": 1.0, "section_id": 6788}, "so_28203981_28204207_0": {"length": 18, "quality": 1.0, "section_id": 152}, "so_28203981_28204207_1": {"length": 16, "quality": 1.0, "section_id": 151}, "so_28203981_28204207_3": {"length": 16, "quality": 1.0, "section_id": 152}}, "n4659": {"so_28203981_28204207_2": {"length": 11, "quality": 1.0, "section_id": 8540}, "so_28203981_28204207_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 162}, "so_28203981_28204207_1": {"length": 13, "quality": 0.8125, "section_id": 161}, "so_28203981_28204207_3": {"length": 15, "quality": 0.9375, "section_id": 162}}}, "28203981": {"ViewCount": "3723", "Body": "<p>I frequently use a technique I call the \"lazy man's <code>enable_if</code>,\" where I use <code>decltype</code> and the comma operator to enable a function based on some template input. Here is a small example:</p>\n<pre><code>template &lt;typename F&gt;\nauto foo(F&amp;&amp; f) -&gt; decltype(f(0), void())\n{\n    std::cout &lt;&lt; \"1\" &lt;&lt; std::endl;\n}\n\ntemplate &lt;typename F&gt;\nauto foo(F&amp;&amp; f) -&gt; decltype(f(0, 1), void())\n{\n    std::cout &lt;&lt; \"2\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>With <code>--std=c++11</code>, g++ 4.7+ and Clang 3.5+ happily compile that bit of code (and it works as I would expect). However, when using MSVC 14 CTP5, I get this error complaining of <code>foo</code> already being defined:</p>\n<blockquote>\n<p id=\"so_28203981_28203981_0\">Error error C2995: 'unknown-type foo(F &amp;&amp;)': function template has\n  already been defined  c++-scratch main.cpp    15</p>\n</blockquote>\n<p>So my question is: Is the \"lazy man's <code>enable_if</code>\" legal C++ or is this an MSVC bug?</p>\n", "AcceptedAnswerId": "28204207", "Title": "Is the \"lazy man's enable_if\" legal C++?", "CreationDate": "2015-01-28T22:53:52.747", "Id": "28203981", "CommentCount": "3", "FavoriteCount": "12", "PostTypeId": "1", "LastEditDate": "2016-03-18T11:45:40.330", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-21T14:52:44.690", "Score": "48", "OwnerUserId": "254306", "Tags": "<c++><c++11><visual-c++><language-lawyer><sfinae>", "AnswerCount": "2"}, "28204207": {"Id": "28204207", "PostTypeId": "2", "Body": "<p><a href=\"http://eel.is/c++draft/temp.over.link#6\" rel=\"nofollow\">[temp.over.link]/6</a> specifies when two function template declarations are overloads. That is done by defining equivalency of two function templates as follows:</p>\n<blockquote>\n<p id=\"so_28203981_28204207_0\">Two function templates are <em>equivalent</em> if they [..] have return types [..] that are equivalent using the rules\n  described above to compare expressions involving template parameters.</p>\n</blockquote>\n<p>The \"rules described above\" are</p>\n<blockquote>\n<p id=\"so_28203981_28204207_1\">Two expressions involving template parameters are considered\n  <em>equivalent</em> if two function definitions containing the expressions would satisfy the one definition rule (3.2) [..]</p>\n</blockquote>\n<p>The ODR relevant for this part states in <a href=\"http://eel.is/c++draft/basic.def.odr#6\" rel=\"nofollow\">[basic.def.odr]/6</a> that</p>\n<blockquote>\n<p id=\"so_28203981_28204207_2\">Given such an entity named <code>D</code> defined in more than one translation\n  unit, then</p>\n<ul>\n<li><strong>each definition of <code>D</code> shall consist of the same sequence of tokens</strong>;</li>\n</ul>\n</blockquote>\n<p>Clearly, as the return types (which are the trailing return types as per <a href=\"http://eel.is/c++draft/dcl.fct#2\" rel=\"nofollow\">[dcl.fct]/2</a>) do not consist of the same tokens, two function definitions containing those expressions would violate the ODR.<br>\nHence the declarations of <code>foo</code> declare non-equivalent function templates and overload the name.  </br></p>\n<p>The error you see is issued due to the lack of support from VC++ for expression SFINAE - presumably the trailing-return-types are not inspected for equivalency.</p>\n<hr>\n<h3>Workaround</h3>\n<p>You can make the function templates non-equivalent in another way - Change the template parameter list. If you rewrite the second definition like so:</p>\n<pre><code>template &lt;typename F, int=0&gt;\nauto foo(F&amp;&amp; f) -&gt; decltype(f(0, 1), void())\n{\n    std::cout &lt;&lt; \"2\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Then VC++ <a href=\"http://rextester.com/CED85004\" rel=\"nofollow\">compiles it fine</a>.\nI shortened the quote in [temp.over.link]/6, which covers this:</p>\n<blockquote>\n<p id=\"so_28203981_28204207_3\">Two function templates are <em>equivalent</em> if they are declared in the same\n  scope, have the same name, <strong>have identical template parameter lists</strong> [..]</p>\n</blockquote>\n<p>In fact, to be able to easily introduce new overloads, you can use a little helper:</p>\n<pre><code>template &lt;int I&gt;\nusing overload = std::integral_constant&lt;int, I&gt;*;\n</code></pre>\n<p>Usage is e.g.</p>\n<pre><code>// Remember to separate &gt; and = with whitespace\ntemplate &lt;typename... F, overload&lt;0&gt; = nullptr&gt;\nauto foo(F&amp;&amp;... f) -&gt; decltype(f(0, 1)..., void())\n\ntemplate &lt;typename... F, overload&lt;1&gt; = nullptr&gt;\nauto foo(F&amp;&amp;... f) -&gt; decltype(f(0, 1, 2)..., void())\n</code></pre>\n<p><a href=\"http://rextester.com/AGOD13940\" rel=\"nofollow\"><strong>Demo</strong></a>.  </p>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-21T14:52:44.690", "Score": "43", "CreationDate": "2015-01-28T23:11:54.640", "ParentId": "28203981", "CommentCount": "5", "OwnerUserId": "3647361", "LastEditDate": "2016-03-21T14:52:44.690"}});