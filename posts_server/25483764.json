post_cb({"bq_ids": {"n4140": {"so_25483764_25485314_0": {"length": 30, "quality": 0.967741935483871, "section_id": 143}, "so_25483764_25485314_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 144}}, "n3337": {"so_25483764_25485314_0": {"length": 30, "quality": 0.967741935483871, "section_id": 137}, "so_25483764_25485314_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 138}}, "n4659": {"so_25483764_25485314_0": {"length": 30, "quality": 0.967741935483871, "section_id": 147}, "so_25483764_25485314_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 148}}}, "25483764": {"ViewCount": "403", "Body": "<p>At the root of my policy-based class lies a container adapter that provides an interface for conversion between different containers. It is parametrized by a type T and template template parameter Container. In order to make it work with standard containers I need to partially apply some of their arguments, for example an allocator, or array size. This is how I do it:</p>\n<pre><code>template&lt; typename T &gt;\nstruct vector_{\n  using policy = std::vector&lt;T&gt;; //default allocator\n}; \n</code></pre>\n<p>or in the case that's giving me trouble:</p>\n<pre><code> //data_adapter expects template template parameter that takes one type-argument,\n //but sadly std::array is a template&lt;typename, size_t&gt;\n //so we need to partially apply the size_t parameter\nnamespace array_detail{\n  template&lt; size_t N &gt;\n  struct array_impl{\n    template&lt; typename T &gt;\n    using array_default = std::array&lt;T, N&gt;;\n  };  //now we can write array_impl&lt;32&gt;::array_default which is template&lt;typename T&gt;\n}\n</code></pre>\n<p>The problem is that I need to partially specialize <code>data_adaptor</code> for all N of <code>array_impl</code> and GCC 4.8.1 seems not to consider my specialization when calling its constructor. Here is the code:</p>\n<p>data_adapter.hpp:</p>\n<pre><code>//data_adapter.hpp\n#ifndef __DATA_ADAPTER_HPP__\n#define __DATA_ADAPTER_HPP__\n\n#include &lt;array&gt;\n#include &lt;type_traits&gt;\n\ntemplate &lt;\n  typename T,\n  template&lt; typename t &gt;\n  class Container\n&gt; class data_adapter\n: protected Container&lt; T &gt;\n{\nprotected:\n  typedef Container&lt;T&gt; data_type;\n\npublic:\n    //constructor forwarding\n  using data_type::data_type;\n\n    //const iterator access for cross-container conversion copying\n  using data_type::cbegin;\n  using data_type::cend;\n\n  data_adapter() = default;\n\npublic:\n  ~data_adapter() {}\n};\n\n  //SFINAE helper to test whether T is an iterator or not\n\ntemplate&lt;typename T, typename = void&gt;\nstruct is_iterator\n{\n   static constexpr bool value = false;\n};\n\ntemplate&lt;typename T&gt;\nstruct is_iterator&lt;T, typename std::enable_if&lt;!std::is_same&lt;typename std::iterator_traits&lt;T&gt;::value_type, void&gt;::value&gt;::type&gt;\n{\n   static constexpr bool value = true;\n};\n\n  //data_adapter expects template template parameter that takes one type-argument,\n  //but sadly std::array is a template&lt;typename, size_t&gt;\n  //so we need to partially apply the size_t parameter\nnamespace array_detail{\n  template&lt; size_t N &gt;\n  struct array_impl{\n    template&lt; typename T &gt;\n    using array_default = std::array&lt;T, N&gt;;\n  };  //now we can write array_impl&lt;32&gt;::array_default which is template&lt;typename T&gt;\n}\n\n//partial specialization for array_impl&lt;N&gt;::array_default for any N???\n\ntemplate&lt; typename T, size_t N &gt;\nclass data_adapter&lt; T, array_detail::array_impl&lt;N&gt;::template array_default &gt;\n: protected array_detail::array_impl&lt;N&gt;::template array_default&lt;T&gt;\n{\nprotected:\n  typedef typename array_detail::array_impl&lt;N&gt;::template array_default&lt;T&gt; data_type;\n\npublic:\n  using data_type::data_type;\n\n  using data_type::cbegin;\n  using data_type::cend;\n\n    //why doesn't std::array implement this constructor?\n    //is it because it has static size and conversion from a dynamic container is dangerous?\n\n  template&lt;\n    typename InputIt,\n    typename = typename\n      std::enable_if&lt;is_iterator&lt;InputIt&gt;::value&gt;::type\n  &gt; data_adapter( InputIt begin, InputIt end )\n  : data_type() {\n    std::copy( begin, end, this-&gt;begin() );\n  }\n\npublic:\n  ~data_adapter() {}\n};\n\n//still doesn't work with explicit instantiation\n//template class data_adapter&lt; int, array_detail::array_impl&lt;32&gt;::template array_default &gt;;\n\n#endif // __DATA_ADAPTER_HPP__\n</code></pre>\n<p>main.cpp:</p>\n<pre><code>//main.cpp\n#include &lt;algorithm&gt;\n#include &lt;ctime&gt;\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n#include &lt;random&gt;\n\n\n#include \"data_adapter.hpp\"\n\nint main()\n{\n  std::mt19937 generator(time(NULL));\n  std::uniform_int_distribution&lt;unsigned char&gt; uniform_symbol( 0, 255 );\n  auto random_symbol =\n    [ &amp;generator, &amp;uniform_symbol ]( int ){\n      return uniform_symbol(generator);\n    };\n\n  std::vector&lt; int &gt; symbols(32);\n  std::transform( symbols.cbegin(), symbols.cend(), symbols.begin(), random_symbol );\n\n  data_adapter&lt; int, array_detail::array_impl&lt;32&gt;::template array_default &gt; adapter( symbols.cbegin(), symbols.cend() );\n\n  std::for_each( symbols.begin(), symbols.end(), []( int s ){ std::cout &lt;&lt; s &lt;&lt; \" \"; } );\n\n  return 0;\n}\n</code></pre>\n<p>errors:</p>\n<pre><code>g++.exe -Wall -fexceptions  -std=c++11 -g  -Wall    -c C:\\Users\\windows\\Desktop\\data_test\\main.cpp -o obj\\Debug\\main.o\nC:\\Users\\windows\\Desktop\\data_test\\main.cpp: In function 'int main()':\nC:\\Users\\windows\\Desktop\\data_test\\main.cpp:23:119: error: no matching function for call to 'data_adapter&lt;int, array_detail::array_impl&lt;32u&gt;::array_default&gt;::data_adapter(std::vector&lt;int&gt;::const_iterator, std::vector&lt;int&gt;::const_iterator)'\n   data_adapter&lt; int, array_detail::array_impl&lt;32&gt;::template array_default &gt; adapter( symbols.cbegin(), symbols.cend() );\n                                                                                                                       ^\nC:\\Users\\windows\\Desktop\\data_test\\main.cpp:23:119: note: candidates are:\nIn file included from C:\\Users\\windows\\Desktop\\data_test\\main.cpp:9:0:\nC:\\Users\\windows\\Desktop\\data_test\\data_adapter.hpp:25:3: note: data_adapter&lt;T, Container&gt;::data_adapter() [with T = int; Container = array_detail::array_impl&lt;32u&gt;::array_default]\n   data_adapter() = default;\n   ^\nC:\\Users\\windows\\Desktop\\data_test\\data_adapter.hpp:25:3: note:   candidate expects 0 arguments, 2 provided\nC:\\Users\\windows\\Desktop\\data_test\\data_adapter.hpp:11:9: note: constexpr data_adapter&lt;int, array_detail::array_impl&lt;32u&gt;::array_default&gt;::data_adapter(const data_adapter&lt;int, array_detail::array_impl&lt;32u&gt;::array_default&gt;&amp;)\n &gt; class data_adapter\n         ^\n</code></pre>\n<p>It clearly does not consider the constructor I defined in the partial specialization for the array_impl, so the conclusion is that the data_adaptor in main.cpp instantiated the unspecialized version of the class. This is not a SFINAE problem, as the compiler would complain about lack of ::type in std::enable_if. Even, if I explicitly instantiate the specialized version, it still doesn't work. What am I doing wrong here?</p>\n<hr>\n<p>EDIT:\nHere is a minimal version that I think is equivalent:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\ntemplate&lt;\n  typename T,\n  template &lt; typename &gt;\n  class Container\n&gt; struct Foo{\n  void test() const {\n    std::cout &lt;&lt; \"Unspecialized Foo\" &lt;&lt; std::endl;\n  }\n};\n\ntemplate&lt; size_t N &gt;\nstruct array_{\n  template&lt; typename T &gt;\n  using policy = std::array&lt;T, N&gt;;\n};\n\ntemplate&lt;\n  typename T, size_t N\n&gt; struct Foo&lt; T, array_&lt;N&gt;::template policy &gt;{\n  void test() const {\n    std::cout &lt;&lt; \"Foo&lt; T, array&lt;\" &lt;&lt; N &lt;&lt; \"&gt;::policy &gt;\" &lt;&lt; std::endl;\n  }\n};\n\nint main()\n{\n    Foo&lt; int, array_&lt;10&gt;::template policy &gt; foo;\n    foo.test();\n    return 0;\n}\n</code></pre>\n<p>Result at GCC 4.8.1:</p>\n<pre><code>Unspecialized Foo\n</code></pre>\n<p>Why is the unspecialized version called?</p>\n<hr>\n<p>EDIT 2:\nIt seems to work when I write it this way:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\ntemplate&lt;\n  typename container\n&gt; struct Foo{\n  void test() const {\n    std::cout &lt;&lt; \"Unspecialized Foo\" &lt;&lt; std::endl;\n  }\n};\n\ntemplate&lt;\n  typename T, size_t N\n&gt; struct Foo&lt; std::array&lt;T, N&gt; &gt;{\n  void test() const {\n    std::cout &lt;&lt; \"Foo&lt; std::array&lt; T, \" &lt;&lt; N &lt;&lt; \"&gt;\" &lt;&lt; std::endl;\n  }\n};\n\nint main()\n{\n    Foo&lt; std::array&lt;int, 10&gt; &gt; foo;\n    foo.test();\n    return 0;\n}\n</code></pre>\n<p>Looks like a GCC bug to me.</p>\n</hr></hr>", "AcceptedAnswerId": "25485314", "Title": "Partial template specialization for partial template parameter application not working GCC 4.8.1", "CreationDate": "2014-08-25T10:22:35.517", "Id": "25483764", "CommentCount": "4", "LastEditDate": "2014-08-25T11:19:23.933", "PostTypeId": "1", "LastEditorUserId": "2571986", "LastActivityDate": "2014-08-25T11:53:18.950", "Score": "1", "OwnerUserId": "2571986", "Tags": "<c++><templates><gcc><c++11><partial-specialization>", "AnswerCount": "1"}, "25485314": {"Id": "25485314", "PostTypeId": "2", "Body": "<p>This is not a compiler bug. \u00a714.5.5.1 [temp.class.spec.match]/p1-2 specifies that</p>\n<blockquote>\n<p id=\"so_25483764_25485314_0\">When a class template is used in a context that requires an\n  instantiation of the class, it is necessary to determine whether the\n  instantiation is to be generated using the primary template or one of\n  the partial specializations. This is done by matching the template\n  arguments of the class template specialization with the template\n  argument lists of the partial specializations.</p>\n<ul>\n<li>If exactly one matching specialization is found, the instantiation is generated from that specialization.</li>\n<li>If more than one matching specialization is found, the partial order rules\n  (14.5.5.2) are used to determine whether one of the\n  specializations is more specialized than the others. If none of the\n  specializations is more specialized than all of the other matching\n  specializations, then the use of the class template is ambiguous and\n  the program is ill-formed.</li>\n<li>If no matches are found, the instantiation is generated from the primary template.</li>\n</ul>\n<p id=\"so_25483764_25485314_1\">A partial specialization matches a given actual template argument list\n  if the template arguments of the partial specialization can be deduced\n  from the actual template argument list (14.8.2).</p>\n</blockquote>\n<p>This uses the standard template argument deduction rules, and anything to the left of <code>::</code> (the technical term is the <em>nested-name-specifier</em> in a <em>qualified-id</em>) is a non-deduced context (\u00a714.8.2.5 [temp.deduct.type]/p5), meaning that the compiler won't be able to deduce <code>N</code>; since deduction fails, the partial specialization is not a match, and the base template is used.</p>\n", "LastActivityDate": "2014-08-25T11:53:18.950", "CommentCount": "1", "CreationDate": "2014-08-25T11:53:18.950", "ParentId": "25483764", "Score": "4", "OwnerUserId": "2756719"}});