post_cb({"bq_ids": {"n4140": {"so_14914940_14914996_2": {"length": 54, "quality": 0.8571428571428571, "section_id": 6037}}, "n3337": {"so_14914940_14914996_2": {"length": 56, "quality": 0.8888888888888888, "section_id": 5805}}, "n4659": {"so_14914940_14914996_2": {"length": 49, "quality": 0.7777777777777778, "section_id": 7536}}}, "14915014": {"Id": "14915014", "PostTypeId": "2", "Body": "<p>The cast is allowed (and hence works) if the pointed to object really is a <code>B</code>. In your example, it is a plain <code>A</code> and therefore, you get undefined behaviour.</p>\n<p>Which leaved the question, why does it work? It works (or <em>seems</em> to work), because the method you called is not accessing the object. It will more likely fail if you add some member variables to <code>B</code> and try to access them in <code>Show()</code> or if you make <code>Show</code> a virtual function. But in any case it's UB, so basically anything can happen.</p>\n", "LastActivityDate": "2013-02-16T20:56:50.083", "Score": "1", "CreationDate": "2013-02-16T20:56:50.083", "ParentId": "14914940", "CommentCount": "7", "OwnerUserId": "2073257"}, "14914940": {"ViewCount": "209", "Body": "<p>I've encountered myself in a problem where casting to the derived class would solve the problem. I've found an answer on  S.O that says it can lead to UB, testing it, it both compiled and worked correctly. Is it undefined behavior? If it is what would be a correct approach to this problem?</p>\n<pre><code>class A\n{\npublic:\n    A(){};\n    ~A(){}\n};\n\nclass B : public A\n{\npublic:\n    B(){};\n    ~B(){}\n    void Show() { std::cout &lt;&lt; \"Show\" &lt;&lt; std::endl; }\n};\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    A a;\n    B* b = static_cast&lt;B*&gt;(&amp;a);\n    b-&gt;Show();\n\n    return 0;\n}\n</code></pre>\n", "Title": "Is it undefined behavior to cast from base class to derived?", "CreationDate": "2013-02-16T20:47:50.117", "LastActivityDate": "2013-02-16T21:25:30.137", "CommentCount": "0", "PostTypeId": "1", "Id": "14914940", "Score": "1", "OwnerUserId": "1513286", "Tags": "<c++><class><derived-class>", "AnswerCount": "3"}, "14914996": {"Id": "14914996", "PostTypeId": "2", "Body": "<p>As long as the pointer to a base type actually points to an instance of a derived type, then such usage is not undefined according to the C++ standard. <strong><em>However</em></strong>, in your code sample, the pointer <code>b</code> does not point to an instance of <code>B</code> or any of its derived types (which there are none), it points to an instance of <code>A</code>. So your code does in fact invoke undefined behavior.</p>\n<blockquote>\n<p id=\"so_14914940_14914996_0\">I've found an answer on S.O that says it can lead to UB, testing it,\n  it both compiled and worked correctly.</p>\n</blockquote>\n<p>The fact that some code compiles and works correctly does not rule out the possibility of code invoking undefined behavior, because undefined behavior includes \"appears to work\". The reason why you should avoid undefined behavior is because there's no guarantee that it will work the same way the next time you invoke UB.</p>\n<blockquote>\n<p id=\"so_14914940_14914996_1\">Is it undefined behavior? If it is what would be a correct approach to\n  this problem?</p>\n</blockquote>\n<p>In your sample, yes, it is undefined behavior. The correct approach would depend on what your code is actually supposed to do, as the example you provide is an academic example at best.</p>\n<p>To make it clear, the following modification to your <code>main()</code> function has well-defined behavior and is explictly allowed by the C++ standard:</p>\n<pre><code>B objectB;\nA* ptrA = &amp;objectB;\n\nB* b = static_cast&lt;B*&gt;(ptrA);\nb-&gt;Show();\n</code></pre>\n<p>Here, it's well defined because the pointer <code>ptrA</code> actually points to an instance of <code>B</code>, even though the pointer itself has type <code>A*</code>. In the above example, casting from <code>A*</code> to <code>B*</code> then invoking one of <code>B</code>'s functions on the casted pointer will work. The difference is that in the example in your question, <code>b</code> does not actually point to an instance of <code>B</code>.</p>\n<hr>\n<p>The relevant clause (emphasis mine):</p>\n<h3>C++ standard 5.2.9/8 Static cast [expr.static.cast]</h3>\n<blockquote>\n<p id=\"so_14914940_14914996_2\"><strong>An rvalue of type \u201cpointer to <em>cv1</em> <code>B</code>\u201d, where <code>B</code> is a class type, can be\n  converted to an rvalue of type \u201cpointer to <em>cv2</em> <code>D</code>\u201d, where <code>D</code> is a class\n  derived (clause 10) from <code>B</code>, if a valid standard conversion from\n  \u201cpointer to <code>D</code>\u201d to \u201cpointer to <code>B</code>\u201d exists</strong> (4.10), <em>cv2</em> is the same\n  <em>cv</em>-qualification as, or greater <em>cv</em>-qualification than, <em>cv1</em>, and <code>B</code> is\n  not a virtual base class of <code>D</code>. The null pointer value (4.10) is\n  converted to the null pointer value of the destination type. <strong>If the\n  rvalue of type \u201cpointer to cv1 <code>B</code>\u201d points to a <code>B</code> that is actually a\n  sub-object of an object of type <code>D</code>, the resulting pointer points to the\n  enclosing object of type <code>D</code>. Otherwise, the result of the cast is\n  undefined.</strong></p>\n</blockquote>\n</hr>", "LastEditorUserId": "308661", "LastActivityDate": "2013-02-16T21:25:30.137", "Score": "8", "CreationDate": "2013-02-16T20:54:24.323", "ParentId": "14914940", "CommentCount": "1", "LastEditDate": "2013-02-16T21:25:30.137", "OwnerUserId": "308661"}, "14915001": {"Id": "14915001", "PostTypeId": "2", "Body": "<p>You can cast a pointer to a base object that is indeed pointing to a derived instance to a pointer to a derived object.</p>\n<p>In your code however the object pointed by <code>&amp;a</code> is not a derived object but a base object and what you are doing is indeed undefined behaviour.</p>\n<p>In implementations I know it should \"work\" if the class has no virtual functions or bases and the derived object doesn't add any data member but just methods. Still it's something that is not formally guaranteed to work.</p>\n<p>Just don't do that.</p>\n", "LastEditorUserId": "320726", "LastActivityDate": "2013-02-16T21:00:10.483", "Score": "2", "CreationDate": "2013-02-16T20:54:54.517", "ParentId": "14914940", "CommentCount": "0", "LastEditDate": "2013-02-16T21:00:10.483", "OwnerUserId": "320726"}});