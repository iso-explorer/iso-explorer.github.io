post_cb({"bq_ids": {"n4140": {"so_26937270_26937418_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 480}}, "n3337": {"so_26937270_26937418_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 471}}, "n4659": {"so_26937270_26937418_0": {"length": 17, "quality": 0.6296296296296297, "section_id": 502}}}, "26937418": {"Id": "26937418", "PostTypeId": "2", "Body": "<p>The copy that is elided is the copy of the temporary return value into <code>b</code>. Without elision the return value is initialized from <code>a</code> and copied to <code>b</code>. Instead, the temporary that would otherwise hold the return value is <em>constructed into <code>b</code> and initialized with <code>a</code></em>. [class.copy]/31:</p>\n<blockquote>\n<p id=\"so_26937270_26937418_0\">when a temporary class object that has not been bound to a reference\n  (12.2) would be copied/moved to a class object with the same\n  cv-unqualified type, the copy/move operation can be omitted by\n  constructing the temporary object directly into the target of the\n  omitted copy/move</p>\n</blockquote>\n<p>You can observe this if you add an additional output in <code>fun</code>:</p>\n<pre><code>A fun(A a)\n{\n    cout &lt;&lt; \"fun!\" &lt;&lt; endl;\n    return a;\n}\n</code></pre>\n<p>Then with the elision you'll get</p>\n<blockquote>\n<p id=\"so_26937270_26937418_1\">[\u2026]<br>\n  fun!<br>\n  Copy Constructor</br></br></p>\n</blockquote>\n<p>And without:</p>\n<blockquote>\n<p id=\"so_26937270_26937418_2\">[\u2026]<br> \n  fun!                         <br> \n  Copy Constructor<br>\n  Copy Constructor<br/></br></br></br></p>\n</blockquote>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-11-14T19:36:32.407", "Score": "4", "CreationDate": "2014-11-14T19:26:23.863", "ParentId": "26937270", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2014-11-14T19:36:32.407"}, "26937270": {"ViewCount": "468", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass A\n{\n    public:\n        int a;\n        A(): a(5)\n        {\n           cout &lt;&lt; \"Constructor\\n\";\n        }\n        A(const A &amp;b)\n        {\n            a = b.a;\n            cout &lt;&lt; \"Copy Constructor\\n\";\n        }\n        A fun(A a)\n        {\n            return a;\n        }\n};\n\nint main()\n{\n    A a, c;\n    A b = a.fun(c);\n    return 0;\n}\n</code></pre>\n<p>The output of the above code with <code>g++ file.cpp</code> is:</p>\n<pre><code>Constructor\nConstructor\nCopy Constructor\nCopy Constructor\n</code></pre>\n<p>The output of the above code with <code>g++ -fno-elide-constructors file.cpp</code> is:</p>\n<pre><code>Constructor\nConstructor\nCopy Constructor\nCopy Constructor\nCopy Constructor\n</code></pre>\n<p>I know Return Value Optimization. My question is which call to copy constructor is elided(temporary object during returning or returned object being copied to b)?</p>\n<p>If the elided copy constructor is the one used for creating b, then how is b created at all (because there is no constructor call in this case also)?</p>\n<p>If I replace the line <code>A b = a.fun(c);</code> with <code>a.fun(c)</code> and compile using the first method or even the second method, then also the copy constructor is being called 2 times . So, if in the case explained in the previous paragraph, the temporary object's copy constructor is elided, then why isn't it elided in this case?</p>\n", "AcceptedAnswerId": "26937435", "Title": "Copy constructor not called when initializing an object with return value of a function", "CreationDate": "2014-11-14T19:16:02.640", "Id": "26937270", "CommentCount": "1", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2014-11-15T16:10:34.370", "LastEditorUserId": "2636873", "LastActivityDate": "2014-11-15T16:10:34.370", "Score": "8", "OwnerUserId": "2636873", "Tags": "<c++><copy-constructor><temporary-objects><return-value-optimization><copy-elision>", "AnswerCount": "2"}, "26937435": {"Id": "26937435", "PostTypeId": "2", "Body": "<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass A\n{\npublic:\n    int a;\n    A(): a(5)\n    {\n        cout &lt;&lt; \"Constructing: \" &lt;&lt; (void *)this &lt;&lt; std::endl;\n    }\n    A(const A &amp;b)\n    {\n        a = b.a;\n        cout &lt;&lt; \"Copy Constructor: \" &lt;&lt; (void *)this &lt;&lt; \" from \" &lt;&lt; (void *)&amp;b &lt;&lt; std::endl;\n    }\n    A fun(A a)\n    {\n        return a;\n    }\n};\n\nint main()\n{\n\n    A a, c;\n    A b = a.fun(c);\n\n    std::cout &lt;&lt; \"a:\" &lt;&lt; (void *)&amp;a &lt;&lt; std::endl &lt;&lt;\n              \"b:\" &lt;&lt; (void *)&amp;b &lt;&lt; std::endl &lt;&lt;\n              \"c:\" &lt;&lt; (void *)&amp;c &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Yields:</p>\n<pre><code>Constructing: 0x7fffbb377220\nConstructing: 0x7fffbb377210\nCopy Constructor: 0x7fffbb377230 from 0x7fffbb377210\nCopy Constructor: 0x7fffbb377200 from 0x7fffbb377230\na:0x7fffbb377220\nb:0x7fffbb377200\nc:0x7fffbb377210\n</code></pre>\n<p>So it constructs <code>a</code>, constructs <code>c</code>, copies <code>c</code> to an intermediate (argument <code>a</code> of the function), and then copies the intermediate directly into <code>b</code>, skipping the typical copying of a to a return intermediate. This is even better demonstrated if you pass by value (change to <code>A fun(const A&amp; a)</code>:</p>\n<pre><code>Constructing: 0x7fff8e9642b0\nConstructing: 0x7fff8e9642a0\nCopy Constructor: 0x7fff8e964290 from 0x7fff8e9642a0\na:0x7fff8e9642b0\nb:0x7fff8e964290\nc:0x7fff8e9642a0\n</code></pre>\n<p>a is constructed, c is constructed, c is copied directly to b, despite b not being passed to fun!</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-11-14T19:51:29.467", "Score": "6", "CreationDate": "2014-11-14T19:27:41.407", "ParentId": "26937270", "CommentCount": "0", "OwnerUserId": "1756405", "LastEditDate": "2014-11-14T19:51:29.467"}});