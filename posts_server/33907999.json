post_cb({"33908540": {"ParentId": "33907999", "CommentCount": "0", "Body": "<p>According to: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3209.htm\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3209.htm</a></p>\n<blockquote>\n<p id=\"so_33907999_33908540_0\">On the other hand, there are strong reasons to require that programs be written to tolerate spurious try_lock() failures:</p>\n<ol>\n<li>As pointed out in Boehm, Adve, \"Foundations of the C++ Concurrency Memory Model\", PLDI 08, enforcing sequential consistency for data-race-free programs without spurious try_lock() failures requires significantly stronger memory ordering for lock() operations on try_lock()-compatible mutex types. On some architectures that significantly increases the cost of uncontended mutex acquisitions. This cost appears to greatly outweigh any benefit from prohibiting spurious try_lock() failures.</li>\n<li>It allows a user-written try_lock() to fail if, for example, the implementation fails to acquire a low-level lock used to protect the mutex data structure. Or it allows such an operation to be written directly in terms of compare_exchange_weak.</li>\n<li>It ensures that client code remains correct when, for example, a debugging thread is introduced that occasionally acquires locks in order to be able to read consistent values from a data structure being checked or examined. Any code that obtains information from try_lock() failure would break with the introduction of another thread that purely locks and reads the data structure. </li>\n</ol>\n</blockquote>\n", "OwnerUserId": "5226168", "PostTypeId": "2", "Id": "33908540", "Score": "16", "CreationDate": "2015-11-25T04:35:22.687", "LastActivityDate": "2015-11-25T04:35:22.687"}, "33915524": {"ParentId": "33907999", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From C++14 chapter \"30.4.1.2 Mutex types\"</p>\n<p>paragraph 16:</p>\n<blockquote>\n<p id=\"so_33907999_33915524_0\">An implementation may fail to obtain the lock even if it is not held by any other thread. [Note: This spurious failure is normally uncommon, but allows interesting implementations based on a simple compare and exchange (Clause 29). \u2014end note] An implementation should ensure that <code>try_lock()</code> does not consistently return <code>false</code> in the absence of contending mutex acquisitions.</p>\n</blockquote>\n<p>and paragraph 19:</p>\n<blockquote>\n<p id=\"so_33907999_33915524_1\">little would be known about the state after a failure, even in the absence of spurious failures</p>\n</blockquote>\n<p>And in answer to</p>\n<blockquote>\n<p id=\"so_33907999_33915524_2\">I know that spurious wakeup may happen with std::condition_variable\n  and the rationale behind it. But, what is the case with a mutex?</p>\n</blockquote>\n<p><code>std::timed_mutex</code> sometimes is implemented using <code>std::condition_varible</code> when there is no direct support in the OS. As in GNU libstdc++:</p>\n<pre><code>#if _GTHREAD_USE_MUTEX_TIMEDLOCK\n\n...\n\n#else // !_GTHREAD_USE_MUTEX_TIMEDLOCK\n\n  class timed_mutex\n  {\n    mutex       _M_mut;\n    condition_variable  _M_cv;\n    bool        _M_locked = false;\n\n  public:\n\n    template&lt;typename _Rep, typename _Period&gt;\n      bool\n      try_lock_for(const chrono::duration&lt;_Rep, _Period&gt;&amp; __rtime)\n      {\n        unique_lock&lt;mutex&gt; __lk(_M_mut);\n        if (!_M_cv.wait_for(__lk, __rtime, [&amp;]{ return !_M_locked; }))\n          return false;\n        _M_locked = true;\n        return true;\n      }\n\n    template&lt;typename _Clock, typename _Duration&gt;\n      bool\n      try_lock_until(const chrono::time_point&lt;_Clock, _Duration&gt;&amp; __atime)\n      {\n        unique_lock&lt;mutex&gt; __lk(_M_mut);\n        if (!_M_cv.wait_until(__lk, __atime, [&amp;]{ return !_M_locked; }))\n          return false;\n        _M_locked = true;\n        return true;\n      }\n  };\n\n#endif\n</code></pre>\n", "OwnerUserId": "5599569", "LastEditorUserId": "5599569", "LastEditDate": "2017-05-24T11:04:55.123", "Id": "33915524", "Score": "5", "CreationDate": "2015-11-25T11:36:57.090", "LastActivityDate": "2017-05-24T11:04:55.123"}, "bq_ids": {"n4140": {"so_33907999_33915524_0": {"section_id": 2763, "quality": 0.8918918918918919, "length": 33}, "so_33907999_33915524_1": {"section_id": 2766, "quality": 1.0, "length": 11}}, "n3337": {"so_33907999_33915524_0": {"section_id": 2724, "quality": 0.8918918918918919, "length": 33}, "so_33907999_33915524_1": {"section_id": 2727, "quality": 1.0, "length": 11}}, "n4659": {"so_33907999_33915524_0": {"section_id": 3501, "quality": 0.8918918918918919, "length": 33}, "so_33907999_33915524_1": {"section_id": 3504, "quality": 1.0, "length": 11}}}, "33907999": {"CommentCount": "0", "AcceptedAnswerId": "33908540", "CreationDate": "2015-11-25T03:27:11.340", "LastActivityDate": "2017-05-24T11:04:55.123", "PostTypeId": "1", "ViewCount": "1162", "FavoriteCount": "1", "Title": "std::timed_mutex::try_lock* fail spuriously", "Id": "33907999", "Score": "9", "Body": "<p>By <code>try_lock*</code>, I take to mean <code>try_lock()</code>, <code>try_lock_for()</code>, and <code>try_lock_until()</code>. According to <a href=\"http://en.cppreference.com/w/cpp/thread/timed_mutex\">cppreference</a>, all three methods may just fail spuriously. Following is quoted from the description for <code>try_lock_for()</code></p>\n<blockquote>\n<p id=\"so_33907999_33907999_0\">As with <code>try_lock()</code>, this function is allowed to fail spuriously and\n  return <code>false</code> even if the mutex was not locked by any other thread at\n  some point during <code>timeout_duration</code>.</p>\n</blockquote>\n<p>I know that spurious wakeup may happen with <code>std::condition_variable</code> and the rationale behind it. But, what is the case with a mutex?</p>\n", "Tags": "<c++><multithreading><c++11><mutex><thread-synchronization>", "OwnerUserId": "1348273", "AnswerCount": "2"}});