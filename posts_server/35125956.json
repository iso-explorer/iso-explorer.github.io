post_cb({"35134612": {"ParentId": "35125956", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The code you post has undefined behaviour, a placement <code>new</code> is used before the constructor is run. This means that you're referring to <code>MyClass::m_BaseAddress</code> before <code>MyClass</code>'s constructor has run so the <code>static_cast</code> is a lie and the program is invalid.</p>\n<p>The standard explicitly says this is undefined behaviour in section <strong>3.8.5 Object lifetime</strong> (emphasis mine).</p>\n<blockquote>\n<p id=\"so_35125956_35134612_0\"><strong>Before the lifetime of an object has started but after the storage which the object will occupy has been allocated</strong> or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any pointer that refers to the storage location where the object will be or was located may be used but only in limited ways. For an object under construction or destruction, see 12.7. Otherwise, such a pointer refers to allocated storage (3.7.4.2), and using the pointer as if the pointer were of type <code>void*</code>, is well-de\ufb01ned. Such a pointer may be dereferenced but the resulting lvalue may only be used in limited ways, as described below. <strong>The program has unde\ufb01ned behavior if</strong>:<br>\n  \u2022 the object will be or was of a class type with a non-trivial destructor and the pointer is used as the operand of a delete-expression,<br>\n  \u2022 <strong>the pointer is used to access a non-static data member</strong> or call a non-static   member function of the object</br></br></p>\n</blockquote>\n<p>You can see that this is what's happening by adding <a href=\"http://ideone.com/A1nE0z\" rel=\"nofollow\">some prints to your code</a>.</p>\n<p>The program will probably work fine with this undefined behaviour but it's still an invalid C++ program and should be avoided.</p>\n<p><sub>Please ignore previous edits of this answer :(</sub></p>\n", "OwnerUserId": "3848", "LastEditorUserId": "3848", "LastEditDate": "2016-02-01T18:39:24.810", "Id": "35134612", "Score": "2", "CreationDate": "2016-02-01T15:48:32.910", "LastActivityDate": "2016-02-01T18:39:24.810"}, "bq_ids": {"n4140": {"so_35125956_35134612_0": {"section_id": 7193, "quality": 0.9010989010989011, "length": 82}}, "n3337": {"so_35125956_35134612_0": {"section_id": 6937, "quality": 0.9340659340659341, "length": 85}}, "n4659": {"so_35125956_35134612_0": {"section_id": 8702, "quality": 0.8901098901098901, "length": 81}}}, "35125956": {"CommentCount": "5", "ViewCount": "84", "PostTypeId": "1", "LastEditorUserId": "179895", "CreationDate": "2016-02-01T08:28:44.000", "LastActivityDate": "2016-02-01T18:39:24.810", "Title": "Accessing member from within class-level placement new overload", "AcceptedAnswerId": "35134612", "LastEditDate": "2016-02-01T15:41:16.383", "Id": "35125956", "Score": "3", "Body": "<p>Is is legal to access a data member of a class from within a placement-new overload defined in that class?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n\nusing namespace std;\n\nclass MyClass\n{\npublic:\n\n    MyClass ()\n    {\n        // Non-default constructor to make sure m_BaseAddress doesn't get\n        // overwritten.\n    }\n\n    // T is some class that directly or indirectly inherits from MyClass.\n    template&lt;typename T&gt;\n    static void* operator new (size_t /* numBytes */, T* memory)\n    {\n        auto object = static_cast&lt;MyClass*&gt;(memory);\n        object-&gt;m_BaseAddress = memory;\n        return static_cast&lt;void*&gt;(memory);\n    }\n\n    template&lt;typename T&gt;\n    static void operator delete (void* /* memory */, T* /* memory */)\n    {\n    }\n\n    void* GetBaseAddress ()\n    {\n        return m_BaseAddress;\n    }\n\nprivate:\n\n    void* m_BaseAddress;\n};\n\nint wmain ()\n{\n    auto memory = reinterpret_cast&lt;MyClass*&gt;(malloc(sizeof(MyClass)));\n\n    auto object = new (memory) MyClass();\n\n    wcout &lt;&lt; L\"Expected: \" &lt;&lt; memory &lt;&lt; endl;\n    wcout &lt;&lt; L\"Actual: \" &lt;&lt; object-&gt;GetBaseAddress() &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>I'm using a templatized placement-new in an attempt to make it work even if what is being \"newed\" is an instance of a class that inherits from <code>MyClass</code>.</p>\n<p><strong>Use-case</strong>: I use a special allocator to allocate memory for objects. There are some auxiliary properties associated with the allocated memory that I can query from this allocator if I give it the base address of the allocated memory. To handle the placement-new and storing of this base address, I use a class (<code>MyClass</code> in the example above) that I use as a base class for all classes that need to be allocated on this special heap. Since the placement-new already gets the base address as a parameter, I was wondering if I can set the member directly, rather than requiring that it be passed as a parameter in the constructor as well.</p>\n", "Tags": "<c++>", "OwnerUserId": "179895", "AnswerCount": "1"}});