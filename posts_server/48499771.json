post_cb({"48499771": {"ViewCount": "2133", "Body": "<p>My internal sanity check failed so I'm rerunning it on Stackoverflow.</p>\n<p>The following code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n#include &lt;utility&gt;\n\nint main()\n{\n    constexpr auto pair_of_ints = std::make_pair(1, 2);\n    std::cerr &lt;&lt; typeid(pair_of_ints).name();\n    //static_assert(std::is_same&lt;decltype(pair_of_ints), std::pair&lt;int, int&gt;&gt;::value, \"WTF\");\n}\n</code></pre>\n<p>produces the mangled symbol name for <code>std::__1::pair&lt;int, int&gt;</code> on my system (XCode Clang 8.x).</p>\n<p>If I then enable the <code>static_assert</code>, it fails. I have no idea why.\nHow can I make this work? I have a function that returns a pair or tuple depending on the arguments passed to it and would like to verify it actually returns a pair or tuple in the correct cases.</p>\n", "AcceptedAnswerId": "48499856", "Title": "Why does std::make_pair not return a pair? Or does it?", "CreationDate": "2018-01-29T11:05:21.687", "Id": "48499771", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2018-01-29T11:26:53.840", "Score": "20", "OwnerUserId": "256138", "Tags": "<c++><c++11><std-pair><static-assert>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_48499771_48499856_1": {"length": 14, "quality": 1.0, "section_id": 6024}, "so_48499771_48499856_0": {"length": 7, "quality": 1.0, "section_id": 5425}}, "n3337": {"so_48499771_48499856_0": {"length": 7, "quality": 1.0, "section_id": 5220}, "so_48499771_48499856_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 5791}}, "n4659": {"so_48499771_48499856_0": {"length": 7, "quality": 1.0, "section_id": 6847}, "so_48499771_48499856_1": {"length": 14, "quality": 1.0, "section_id": 7523}}}, "48499856": {"Id": "48499856", "PostTypeId": "2", "Body": "<p>You declared <code>pair_of_ints</code> as <code>constexpr</code> which implies <code>const</code>:</p>\n<p><a href=\"http://eel.is/c++draft/dcl.constexpr#9\" rel=\"noreferrer\">[dcl.constexpr]#9</a></p>\n<blockquote>\n<p id=\"so_48499771_48499856_0\">A <code>constexpr</code> specifier used in an object declaration declares the object as <code>const</code>.</p>\n</blockquote>\n<p>So the type of <code>pair_of_ints</code> is actually:</p>\n<pre><code>const std::pair&lt;int, int&gt;\n</code></pre>\n<p><code>typeid</code> ignores cv-qualifiers, which is why this information does not appear in the name:</p>\n<p><a href=\"http://eel.is/c++draft/expr.typeid#5\" rel=\"noreferrer\">[expr.typeid]#5</a></p>\n<blockquote>\n<p id=\"so_48499771_48499856_1\">If the type of the expression or <em>type-id</em> is a cv-qualified type, the result of the <code>typeid</code> expression refers to a <code>std::type_info</code> object representing the cv-unqualified type. </p>\n</blockquote>\n<p>You could either test against the const-qualified type, or drop the const-qualifier using <a href=\"http://en.cppreference.com/w/cpp/types/remove_cv\" rel=\"noreferrer\">std::remove_const_t</a>:</p>\n<pre><code>static_assert(std::is_same&lt;decltype(pair_of_ints), \n                           const std::pair&lt;int, int&gt;&gt;::value);\nstatic_assert(std::is_same&lt;std::remove_const_t&lt;decltype(pair_of_ints)&gt;, \n                           std::pair&lt;int, int&gt;&gt;::value);\n</code></pre>\n", "LastEditorUserId": "2666289", "LastActivityDate": "2018-01-29T11:26:53.840", "Score": "38", "CreationDate": "2018-01-29T11:09:15.650", "ParentId": "48499771", "CommentCount": "3", "OwnerUserId": "2666289", "LastEditDate": "2018-01-29T11:26:53.840"}});