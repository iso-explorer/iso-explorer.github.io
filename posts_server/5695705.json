post_cb({"bq_ids": {"n4140": {"so_5695705_5696018_0": {"section_id": 1855, "quality": 0.9615384615384616, "length": 50}, "so_5695705_5695741_6": {"section_id": 1857, "quality": 0.7777777777777778, "length": 7}, "so_5695705_5695741_4": {"section_id": 1855, "quality": 1.0, "length": 6}, "so_5695705_5695741_3": {"section_id": 1855, "quality": 1.0, "length": 4}, "so_5695705_5695741_1": {"section_id": 1855, "quality": 0.8157894736842105, "length": 31}, "so_5695705_5695741_5": {"section_id": 1856, "quality": 1.0, "length": 9}}, "n3337": {"so_5695705_5696018_0": {"section_id": 1849, "quality": 0.9615384615384616, "length": 50}, "so_5695705_5695741_6": {"section_id": 1851, "quality": 0.7777777777777778, "length": 7}, "so_5695705_5695741_4": {"section_id": 1849, "quality": 1.0, "length": 6}, "so_5695705_5695741_3": {"section_id": 1849, "quality": 1.0, "length": 4}, "so_5695705_5695741_1": {"section_id": 1849, "quality": 0.8157894736842105, "length": 31}, "so_5695705_5695741_5": {"section_id": 1850, "quality": 1.0, "length": 9}}, "n4659": {"so_5695705_5696018_0": {"section_id": 2028, "quality": 0.9230769230769231, "length": 48}, "so_5695705_5695741_6": {"section_id": 2030, "quality": 0.7777777777777778, "length": 7}, "so_5695705_5695741_4": {"section_id": 2028, "quality": 0.8333333333333334, "length": 5}, "so_5695705_5695741_3": {"section_id": 2028, "quality": 1.0, "length": 4}, "so_5695705_5695741_1": {"section_id": 2028, "quality": 0.7894736842105263, "length": 30}, "so_5695705_5695741_5": {"section_id": 2029, "quality": 1.0, "length": 9}}}, "5695749": {"ParentId": "5695705", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>I deleted my original answer because I wanted to test this. This is what I see, if there is an error whilst reading (EOF is not counted in this context), the original string is modified and the branch sees the modified version. To test I did the following, created a 2Gb file (<code>touch</code> then <code>truncate</code>), the above code to read. Whilst the code was running, removed the file (this should set the <code>failbit</code> - I think). Immediately stops reading, but the string is modified - it has a larger size.</p>\n<p>To me this indicates that the string is modified even if the stream operation fails.</p>\n", "OwnerUserId": "266198", "LastEditorUserId": "266198", "LastEditDate": "2011-04-17T19:29:53.420", "Id": "5695749", "Score": "1", "CreationDate": "2011-04-17T19:05:09.653", "LastActivityDate": "2011-04-17T19:29:53.420"}, "5695741": {"ParentId": "5695705", "PostTypeId": "2", "CommentCount": "10", "Body": "<blockquote>\n<p id=\"so_5695705_5695741_0\">Is the output in the second case guaranteed to be an empty string?</p>\n</blockquote>\n<p>The answer is : no, because it depends, as described below.</p>\n<p>Since <code>else</code> block will be executed only if an attempt to read from the stream fails, and that can occur anytime in the course of reading.</p>\n<ul>\n<li><p>If it fails at the very first attempt, then there is no character extraction from the stream, and hence <code>token</code> will  be empty (as it was).</p></li>\n<li><p>If it fails after few reads, then <code>token</code> will not be empty. It will contain the  characters successfully read so far from  the stream.</p></li>\n</ul>\n<p>The section \u00a721.3.7.9 from the Standard says,</p>\n<blockquote>\n<p id=\"so_5695705_5695741_1\">Begins by constructing a sentry object\n  k as if k were constructed by typename\n  basic_istream::sentry\n  k(is). If bool(k) is true, it calls\n  str.erase() and then <strong>extracts\n  characters from is and appends them to\n  str as if by calling str.append(1,c)</strong>.\n  If is.width() is greater than zero,\n  the maximum number n of characters\n  appended is is.width(); otherwise n is\n  str.max_size(). <strong>Characters are\n  extracted and appended until any of\n  the following occurs</strong>:</p>\n<p id=\"so_5695705_5695741_2\">\u2014 n characters\n  are stored; </p>\n<p id=\"so_5695705_5695741_3\">\u2014 end-of-file occurs on\n  the input sequence; </p>\n<p id=\"so_5695705_5695741_4\">\u2014 isspace(c,is.getloc()) is true for the\n  next available input character c. </p>\n<p id=\"so_5695705_5695741_5\">After the last character (if any) is\n  extracted, is.width(0) is called and\n  the sentry object k is destroyed.</p>\n<p id=\"so_5695705_5695741_6\">If the function extracts no characters, it calls is.setstate(ios::failbit), which may throw ios_base::failure (27.4.4.3).</p>\n</blockquote>\n<hr>\n<p>Also note that the section \u00a721.3.1/2 from the Standard guarantees that the default constructed string will be empty. The Standard says its size will be zero, that means, empty.</p>\n</hr>", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-04-17T19:49:52.100", "Id": "5695741", "Score": "2", "CreationDate": "2011-04-17T19:04:13.290", "LastActivityDate": "2011-04-17T19:49:52.100"}, "5695705": {"CommentCount": "1", "AcceptedAnswerId": "5695741", "CreationDate": "2011-04-17T19:00:10.713", "LastActivityDate": "2011-04-17T19:51:45.083", "PostTypeId": "1", "ViewCount": "142", "FavoriteCount": "1", "Title": "Contents of the string after failed extraction from istream", "Id": "5695705", "Score": "3", "Body": "<p>If I do this:</p>\n<pre><code>ifstream stream(\"somefilewhichopenssuccesfully.txt\");\nstring token;\nif( stream &gt;&gt; token )\n    cout &lt;&lt; token;\nelse\n    cout &lt;&lt; token;\n</code></pre>\n<p>Is the output in the second case guaranteed to be an empty string? I can't seem to find the answer to this on cplusplus.com.</p>\n<p>Thanks!</p>\n", "Tags": "<c++><extraction><istream>", "OwnerUserId": "256138", "AnswerCount": "3"}, "5696018": {"ParentId": "5695705", "CommentCount": "0", "Body": "<p>No, even if the operation fails, the string will contain the characters extracted so far. </p>\n<p>The standard says (\u00a721.4.8.9):</p>\n<blockquote>\n<p id=\"so_5695705_5696018_0\">Effects: Behaves as a formatted input function (27.7.2.2.1). After constructing a <code>sentry</code> object, if the sentry converts to true, calls <code>str.erase()</code> and then extracts characters from <code>is</code> and appends them to <code>str</code> as if by calling <code>str.append(1,c)</code>. If <code>is.width()</code> is greater than zero, the maximum number n of characters appended is <code>is.width()</code>; otherwise n is <code>str.max_size()</code>. Characters are extracted and appended until any of the following occurs:<br>\n   \u2014 n characters are stored;<br>\n  \u2014 end-of-file occurs on the input sequence;<br>\n  \u2014 <code>isspace(c,is.getloc())</code> is true for the next available input character c.</br></br></br></p>\n</blockquote>\n", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "5696018", "Score": "0", "CreationDate": "2011-04-17T19:51:45.083", "LastActivityDate": "2011-04-17T19:51:45.083"}});