post_cb({"37751162": {"ParentId": "37750904", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2016-06-10T14:46:57.287", "Score": "-1", "LastEditorUserId": "6412786", "LastEditDate": "2016-06-10T15:09:02.333", "Id": "37751162", "OwnerUserId": "6412786", "Body": "<blockquote>\n<p id=\"so_37750904_37751162_0\">Padding bits are \"unspecified\" not \"implementation-defined\".</p>\n</blockquote>\n<p>Wrong. Very, very wrong. The <strong>values</strong> of padding bytes are unspecified.  The intention here is that the values of these bits may represent trap values, but not necessarily.</p>\n<p>The standard tells you <code>sizeof</code> returns <code>bytes * CHAR_BITS</code>, but doesn't specify a size (other than the exact-width types). The number of bytes a type occupies is implementation-defined, hence <code>sizeof</code> must be as well.</p>\n<p>Implementation-defined is decribed as:</p>\n<blockquote>\n<p id=\"so_37750904_37751162_1\">unspecified value where each implementation documents how the choice\n  is made</p>\n</blockquote>\n", "LastActivityDate": "2016-06-10T15:09:02.333"}, "37751184": {"ParentId": "37750904", "CommentCount": "1", "CreationDate": "2016-06-10T14:48:01.927", "OwnerUserId": "4566726", "PostTypeId": "2", "Id": "37751184", "Score": "1", "Body": "<p>Because the sizes of basic types are defined in terms of efficiency, not in terms of exact number of bits. An \"int\" must be something that the CPU can manipulate efficiently. For most modern systems, this quantity turns out to be 32 bits (or 64 bits). For older systems, it was quite often 16 bits. However, if a 35 bits CPU were to exist, an int on such a system would be 35 bits. In other words, C++ does not apply a penalty to enforce a bit-width a CPU might not support at all. </p>\n<p>Of course, one could argue that notions of exotic bit widths for basic types have been overtaken by history. I cannot think of any modern CPU that does not support the standard set of 8, 16, and 32 bits (feel free to disagree with this statement, but at least be so kind to give an example!), and 64 bits is also pretty common (and not a big deal to support in software if hardware support is unavailable).</p>\n<p>Arguably the C++ language has already moved away from having variable numbers of bits for char; as far as I know, u8\"...\" converts to char *, but the unicode specification demands that u8 is encoded in 8 bits.</p>\n<p>If a char of 8 bits is size 1, then an int of 32 bits is size 4. If a char of 16 bits is size 1, then an int of 32 bits is only size 2. Both situations are equally valid in C++, if such sizes happen to be good choices for their respective hardware.</p>\n", "LastActivityDate": "2016-06-10T14:48:01.927"}, "37751678": {"ParentId": "37750904", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2016-06-10T15:12:46.783", "Score": "5", "LastEditorUserId": "168986", "LastEditDate": "2016-06-10T19:21:59.260", "Id": "37751678", "OwnerUserId": "168986", "Body": "<p>The result of <code>sizeof</code> <em>is not</em> implementation defined.  The standard does not say that; it says:</p>\n<blockquote>\n<p id=\"so_37750904_37751678_0\">The <strong><em>value</em></strong> of the result is implementation-defined, [...]</p>\n</blockquote>\n<p>That is semantically different.  The result of <code>sizeof</code> is well defined:</p>\n<blockquote>\n<p id=\"so_37750904_37751678_1\">[...] the size (in bytes) of its operand [...]</p>\n</blockquote>\n<p>Both the bit width of a byte in this context and the number of bytes in non <code>char</code> types <em>is</em> implementation defined. </p>\n", "LastActivityDate": "2016-06-10T19:21:59.260"}, "37751139": {"ParentId": "37750904", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-06-10T14:46:12.897", "Score": "12", "LastEditorUserId": "4342498", "LastEditDate": "2016-06-10T15:01:45.747", "Id": "37751139", "OwnerUserId": "4342498", "Body": "<p>The result of <code>sizeof</code> is implementation defined because the size of the various basic types are implementation defined.  The only guarantees we have on the size of the types in C++ is that</p>\n<pre><code>sizeof(char) = 1 and sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= \nsizeof(long) &lt;= sizeof(long long)\n</code></pre>\n<p>And that each type has a minimum value it must support C11 [Annex E (informative) Implementation limits]/1</p>\n<blockquote>\n<p id=\"so_37750904_37751139_0\">[...]The minimum magnitudes shown shall be replaced by implementation-defined magnitudes with the same sign.[...]</p>\n</blockquote>\n<pre class=\"lang-none prettyprint-override\"><code>#define CHAR_BIT    8\n#define CHAR_MAX    UCHAR_MAX or SCHAR_MAX\n#define CHAR_MIN    0 or SCHAR_MIN\n#define INT_MAX     +32767\n#define INT_MIN     -32767\n#define LONG_MAX    +2147483647\n#define LONG_MIN    -2147483647\n#define LLONG_MAX   +9223372036854775807\n#define LLONG_MIN   -9223372036854775807\n#define MB_LEN_MAX  1\n#define SCHAR_MAX   +127\n#define SCHAR_MIN   -127\n#define SHRT_MAX    +32767\n#define SHRT_MIN    -32767\n#define UCHAR_MAX   255\n#define USHRT_MAX   65535\n#define UINT_MAX    65535\n#define ULONG_MAX   4294967295\n#define ULLONG_MAX  18446744073709551615\n</code></pre>\n<p>So per the standard a <code>int</code> has to be able to store a number that could be stored in 16 bits but it can be bigger and on most of today's systems it is 32 bits.</p>\n<blockquote>\n<p id=\"so_37750904_37751139_1\">What I'm getting at here is that <code>n * CHAR_BITS</code> is a fixed formula. The formula itself can't changed between implementations. Yes, an int may be 4 bytes or 8 bytes. I get that. But between all implementations, the value must <code>n * CHAR_BITS</code>.</p>\n</blockquote>\n<p>You are correct but <code>n</code> is defined per C99 \u00a76.2.6.1 as</p>\n<blockquote>\n<p id=\"so_37750904_37751139_2\">where <code>n</code> is the <strong>size of an object</strong> of that type</p>\n</blockquote>\n<p><sup>emphasis mine</sup></p>\n<p>So the formula may be fixed but <code>n</code> is not fixed and different implementations on the same system can use a different value of <code>n</code>.</p>\n", "LastActivityDate": "2016-06-10T15:01:45.747"}, "37754169": {"ParentId": "37750904", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2016-06-10T17:36:31.333", "Score": "-1", "LastEditorUserId": "6449990", "LastEditDate": "2016-06-11T12:30:53.947", "Id": "37754169", "OwnerUserId": "6449990", "Body": "<p>When you declare a new variable in example like this: </p>\n<p>size_t a;</p>\n<p>it will be equal with this:</p>\n<pre><code>unsigned short int a; // unsigned short a\n</code></pre>\n<p>On 32-bit computers size of the integer number (int) is 4 bytes.\nSize of the short int is 2 bytes.</p>\n<p>In C programming languange 'size_t' is the return type of the 'sizeof()' operator.When you use 'sizeof()' operator he will give you the size of the object.Argument of the 'sizeof()' must be an l-value type. Size of the element(object) cannot be a negative number and it must be an integer.</p>\n", "LastActivityDate": "2016-06-11T12:30:53.947"}, "bq_ids": {"n4140": {"so_37750904_37750904_2": {"section_id": 6076, "quality": 0.8421052631578947, "length": 16}, "so_37750904_37751139_2": {"section_id": 6290, "quality": 1.0, "length": 4}, "so_37750904_37750904_0": {"section_id": 6076, "quality": 0.7692307692307693, "length": 10}}, "n3337": {"so_37750904_37750904_2": {"section_id": 5844, "quality": 0.8421052631578947, "length": 16}, "so_37750904_37751139_2": {"section_id": 6050, "quality": 1.0, "length": 4}, "so_37750904_37750904_0": {"section_id": 5844, "quality": 0.7692307692307693, "length": 10}}, "n4659": {"so_37750904_37750904_0": {"section_id": 7572, "quality": 0.7692307692307693, "length": 10}, "so_37750904_37751139_2": {"section_id": 7797, "quality": 1.0, "length": 4}, "so_37750904_37750904_2": {"section_id": 7572, "quality": 0.8421052631578947, "length": 16}}}, "37750904": {"CommentCount": "12", "ViewCount": "308", "PostTypeId": "1", "ClosedDate": "2016-06-13T07:00:23.543", "LastEditorUserId": "6292850", "CreationDate": "2016-06-10T14:35:06.387", "LastActivityDate": "2016-06-11T12:30:53.947", "LastEditDate": "2016-06-10T14:55:44.120", "FavoriteCount": "2", "Title": "Why is the result of sizeof implementation defined?", "Id": "37750904", "Score": "-7", "Body": "<p>In C99, \u00a76.5.3.4:</p>\n<blockquote>\n<p id=\"so_37750904_37750904_0\">2 The <code>sizeof</code> operator yields the size (in bytes) of its operand,\n  which may be an expression or the parenthesized name of a type. ...</p>\n<p id=\"so_37750904_37750904_1\">4 The value of the result is implementation-defined, and its type (an\n  unsigned integer type) is <code>size_t</code>, defined in <code>&lt;stddef.h&gt;</code> (and other\n  headers).</p>\n</blockquote>\n<p>In C++14, \u00a75.3.3:</p>\n<blockquote>\n<p id=\"so_37750904_37750904_2\">1 The <code>sizeof</code> operator yields the number of bytes in the object\n  representation of its operand. ... The result of sizeof applied to any\n  other fundamental type (3.9.1) is implementation-defined.</p>\n</blockquote>\n<p>The only guaranteed values are <code>sizeof(char)</code>, <code>sizeof(unsigned char)</code> and <code>sizeof(signed char)</code> which is one.</p>\n<p>However, \"the number of bytes in the object representation\" seems pretty iron-clad to me. For example, in C99 \u00a76.2.6.1:</p>\n<blockquote>\n<p id=\"so_37750904_37750904_3\">4 Values stored in non-bit-field objects of any other object type\n  consist of <em>n</em> \u00d7 <strong>CHAR_BIT</strong> bits, where <em>n</em> is the size of an object\n  of that type, in bytes. ...</p>\n</blockquote>\n<p>So why is it implementation-defined if it seems pretty defined?</p>\n<hr/>\n<p>Many of you seem to be misinterpretating my question. I never claimed that:</p>\n<p>A) The size of types are defined or the same on all systems,</p>\n<p>B) implementation-defined means it can return \"random values\"</p>\n<p>What I'm getting at here is that <code>n * CHAR_BITS</code> is a fixed formula. The formula itself can't changed between implementations. Yes, an <code>int</code> may be 4 bytes or 8 bytes. I get that. But between <strong>all</strong> implementations, the value must <code>n * CHAR_BITS</code>.</p>\n", "Tags": "<c++><c><sizeof>", "OwnerUserId": "6292850", "AnswerCount": "5"}});