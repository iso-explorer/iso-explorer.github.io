post_cb({"bq_ids": {"n4140": {"so_39508272_39508813_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 6047}}, "n3337": {"so_39508272_39508813_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 5815}}, "n4659": {"so_39508272_39508813_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 7546}}}, "39508272": {"ViewCount": "164", "Body": "<p>Hopefully this is rather a simple C++ question (not a language-lawyer one).</p>\n<p>How is one supposed to use the GNU extension <code>dladdr</code> in C++ ? Typically one would write the following in C:</p>\n<pre><code>#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n#include &lt;dlfcn.h&gt;\n\nstatic void where_am_i() {}\n\nint main()\n{\n  Dl_info info;\n  dladdr( (void*)&amp;where_am_i, &amp;info );\n\n  return 0;\n}\n</code></pre>\n<p>However using clang one can see the cast may be invalid:</p>\n<pre><code>$ clang --version\nDebian clang version 3.6.2-3 (tags/RELEASE_362/final) (based on LLVM 3.6.2)\nTarget: x86_64-pc-linux-gnu\nThread model: posix\n$ clang -Wpedantic -o foo foo.cpp -ldl\nfoo.cpp:11:11: warning: cast between pointer-to-function and pointer-to-object is an extension [-Wpedantic]\n  dladdr( (void*)&amp;where_am_i, &amp;info );\n          ^~~~~~~~~~~~~~~~~~\n1 warning generated.\n</code></pre>\n<p>The warning seems legitimate to me, so is there a way to work around that ?</p>\n", "AcceptedAnswerId": "39508813", "Title": "dladdr: pointer-to-function vs pointer-to-object", "CreationDate": "2016-09-15T10:02:18.967", "Id": "39508272", "CommentCount": "3", "LastEditDate": "2016-09-15T10:32:32.390", "PostTypeId": "1", "LastEditorUserId": "136285", "LastActivityDate": "2016-09-15T10:57:49.800", "Score": "6", "OwnerUserId": "136285", "Tags": "<c++><c><pointers><language-lawyer>", "AnswerCount": "1"}, "39508813": {"Id": "39508813", "PostTypeId": "2", "Body": "<p>There is no standard way to portably convert a function pointer to <code>void*</code>. As such, there is no standard way to portably use <code>dladdr</code>. Prior to C++11, such conversion was ill-formed (I don't have the document available, but the warning by clang suggests it). Since C++11 however, the conversion is conditionally supported:</p>\n<p><a href=\"http://eel.is/c++draft/expr.reinterpret.cast#8\" rel=\"nofollow\">[expr.reinterpret.cast]</a>/8 (standard draft)</p>\n<blockquote>\n<p id=\"so_39508272_39508813_0\">Converting a function pointer to an object pointer type or vice versa is conditionally-supported. The meaning of such a conversion is implementation-defined, except that if an implementation supports conversions in both directions, converting a prvalue of one type to the other type and back, possibly with different cv-qualification, shall yield the original pointer value.</p>\n</blockquote>\n<hr>\n<p>Since you are already relying on the c library extension that provides <code>dladdr</code>, you might as well rely on the language extension that lets you cast function pointer to <code>void*</code>. In that case, you may want to ask the compiler to not warn about using language extensions by compiling without the <code>-Wpedantic</code> option - or use a standard version where the conversion is at least conditionally supported. If the conversion isn't supported, then so isn't <code>dladdr</code>.</p>\n</hr>", "LastEditorUserId": "2079303", "LastActivityDate": "2016-09-15T10:57:49.800", "Score": "2", "CreationDate": "2016-09-15T10:29:16.917", "ParentId": "39508272", "CommentCount": "0", "OwnerUserId": "2079303", "LastEditDate": "2016-09-15T10:57:49.800"}});