post_cb({"40591633": {"ParentId": "40590216", "CommentCount": "4", "Body": "<p>This is undefined behavior.</p>\n<p>There are lots of rules in C++ that attempt to give the compiler some hope of understanding what you are doing, so it can reason about it and optimize it.</p>\n<p>There are rules about aliasing (accessing data through two different pointer types), array bounds, etc.</p>\n<p>When you have a variable <code>x</code>, the fact that it isn't a member of an array means that the compiler can assume that no <code>[]</code> based array access can modify it.  So it doesn't have to constantly reload the data from memory every time you use it; only if someone could have modified it <em>from its name</em>.</p>\n<p>Thus <code>(&amp;thing.a)[1]</code> can be assumed by the compiler to not refer to <code>thing.b</code>.  It can use this fact to reorder reads and writes to <code>thing.b</code>, invalidating what you want it to do without invalidating what you actually told it to do.</p>\n<p>A classic example of this is casting away const.</p>\n<pre><code>const int x = 7;\nstd::cout &lt;&lt; x &lt;&lt; '\\n';\nauto ptr = (int*)&amp;x;\n*ptr = 2;\nstd::cout &lt;&lt; *ptr &lt;&lt; \"!=\" &lt;&lt; x &lt;&lt; '\\n';\nstd::cout &lt;&lt; ptr &lt;&lt; \"==\" &lt;&lt; &amp;x &lt;&lt; '\\n';\n</code></pre>\n<p>here you typically get a compiler saying 7 then 2 != 7, and then two identical pointers; despite the fact that <code>ptr</code> is pointing at <code>x</code>.  The compiler takes the fact that <code>x</code> is a constant value to not bother reading it when you ask for the value of <code>x</code>.</p>\n<p>But when you take the address of <code>x</code>, you force it to exist.  You then cast away const, and modify it.  So the actual location in memory where <code>x</code> is has been modified, the compiler is free to not actually read it when reading <code>x</code>!</p>\n<p>The compiler may get smart enough to figure out how to even avoid following <code>ptr</code> to read <code>*ptr</code>, but often they are not.  Feel free to go and use <code>ptr = ptr+argc-1</code> or somesuch confusion if the optimizer is getting smarter than you.</p>\n<p>You can provide a custom <code>operator[]</code> that gets the right item.</p>\n<pre><code>int&amp; operator[](std::size_t);\nint const&amp; operator[](std::size_t) const;\n</code></pre>\n<p>having both is useful.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "40591633", "Score": "8", "CreationDate": "2016-11-14T14:55:38.400", "LastActivityDate": "2016-11-14T14:55:38.400"}, "40602953": {"ParentId": "40590216", "CommentCount": "3", "Body": "<p>Heres a way to use a proxy class to access elements in a member array by name.  It is very C++, and has no benefit vs. ref-returning accessor functions, except for syntactic preference.  This overloads the <code>-&gt;</code> operator to access elements as members, so to be acceptable, one needs to both dislike the syntax of accessors (<code>d.a() = 5;</code>), as well as tolerate using <code>-&gt;</code> with a non-pointer object.  I expect this might also confuse readers not familiar with the code, so this might be more of a neat trick than something you want to put into production.</p>\n<p>The <code>Data</code> struct in this code also includes overloads for the subscript operator, to access indexed elements inside its <code>ar</code> array member, as well as <code>begin</code> and <code>end</code> functions, for iteration.  Also, all of these are overloaded with non-const and const versions, which I felt needed to be included for completeness.</p>\n<p>When <code>Data</code>'s <code>-&gt;</code> is used to access an element by name (like this: <code>my_data-&gt;b = 5;</code>), a <code>Proxy</code> object is returned.  Then, because this <code>Proxy</code> rvalue is not a pointer, its own <code>-&gt;</code> operator is auto-chain-called, which returns a pointer to itself.  This way, the <code>Proxy</code> object is instantiated and remains valid during evaluation of the initial expression.</p>\n<p>Contruction of a <code>Proxy</code> object populates its 3 reference members <code>a</code>, <code>b</code> and <code>c</code> according to a pointer passed in the constructor, which is assumed to point to a buffer containing at least 3 values whose type is given as the template parameter <code>T</code>.  So instead of using named references which are members of the <code>Data</code> class, this saves memory by populating the references at the point of access (but unfortunately, using <code>-&gt;</code> and not the <code>.</code> operator).</p>\n<p>In order to test how well the compiler's optimizer eliminates all of the indirection introduced by the use of <code>Proxy</code>, the code below includes 2 versions of <code>main()</code>.  The <code>#if 1</code> version uses the <code>-&gt;</code> and <code>[]</code> operators, and the <code>#if 0</code> version performs the equivalent set of procedures, but only by directly accessing <code>Data::ar</code>.</p>\n<p>The <code>Nci()</code> function generates runtime integer values for initializing array elements, which prevents the optimizer from just plugging constant values directly into each <code>std::cout</code> <code>&lt;&lt;</code> call.</p>\n<p>For gcc 6.2, using -O3, both versions of <code>main()</code> generate the same assembly (toggle between <code>#if 1</code> and <code>#if 0</code> before the first <code>main()</code> to compare): <a href=\"https://godbolt.org/g/QqRWZb\" rel=\"nofollow noreferrer\">https://godbolt.org/g/QqRWZb</a></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n\ntemplate &lt;typename T&gt;\nclass Proxy {\npublic:\n    T &amp;a, &amp;b, &amp;c;\n    Proxy(T* par) : a(par[0]), b(par[1]), c(par[2]) {}\n    Proxy* operator -&gt; () { return this; }\n};\n\nstruct Data {\n    int ar[3];\n    template &lt;typename I&gt; int&amp; operator [] (I idx) { return ar[idx]; }\n    template &lt;typename I&gt; const int&amp; operator [] (I idx) const { return ar[idx]; }\n    Proxy&lt;int&gt;       operator -&gt; ()       { return Proxy&lt;int&gt;(ar); }\n    Proxy&lt;const int&gt; operator -&gt; () const { return Proxy&lt;const int&gt;(ar); }\n    int* begin()             { return ar; }\n    const int* begin() const { return ar; }\n    int* end()             { return ar + sizeof(ar)/sizeof(int); }\n    const int* end() const { return ar + sizeof(ar)/sizeof(int); }\n};\n\n// Nci returns an unpredictible int\ninline int Nci() {\n    static auto t = std::time(nullptr) / 100 * 100;\n    return static_cast&lt;int&gt;(t++ % 1000);\n}\n\n#if 1\nint main() {\n    Data d = {Nci(), Nci(), Nci()};\n    for(auto v : d) { std::cout &lt;&lt; v &lt;&lt; ' '; }\n    std::cout &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; d-&gt;b &lt;&lt; \"\\n\";\n    d-&gt;b = -5;\n    std::cout &lt;&lt; d[1] &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"\\n\";\n\n    const Data cd = {Nci(), Nci(), Nci()};\n    for(auto v : cd) { std::cout &lt;&lt; v &lt;&lt; ' '; }\n    std::cout &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; cd-&gt;c &lt;&lt; \"\\n\";\n    //cd-&gt;c = -5;  // error: assignment of read-only location\n    std::cout &lt;&lt; cd[2] &lt;&lt; \"\\n\";\n}\n#else\nint main() {\n    Data d = {Nci(), Nci(), Nci()};\n    for(auto v : d.ar) { std::cout &lt;&lt; v &lt;&lt; ' '; }\n    std::cout &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; d.ar[1] &lt;&lt; \"\\n\";\n    d-&gt;b = -5;\n    std::cout &lt;&lt; d.ar[1] &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"\\n\";\n\n    const Data cd = {Nci(), Nci(), Nci()};\n    for(auto v : cd.ar) { std::cout &lt;&lt; v &lt;&lt; ' '; }\n    std::cout &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; cd.ar[2] &lt;&lt; \"\\n\";\n    //cd.ar[2] = -5;\n    std::cout &lt;&lt; cd.ar[2] &lt;&lt; \"\\n\";\n}\n#endif\n</code></pre>\n", "OwnerUserId": "1687639", "PostTypeId": "2", "Id": "40602953", "Score": "6", "CreationDate": "2016-11-15T05:53:51.043", "LastActivityDate": "2016-11-15T05:53:51.043"}, "40590641": {"ParentId": "40590216", "CommentCount": "5", "Body": "<p>For c++: If you need to access a member without knowing its name, you can use a pointer to member variable.</p>\n<pre><code>struct data {\n  int a, b, c;\n};\n\ntypedef int data::* data_int_ptr;\n\ndata_int_ptr arr[] = {&amp;data::a, &amp;data::b, &amp;data::c};\n\ndata thing;\nthing.*arr[0] = 123;\n</code></pre>\n", "OwnerUserId": "817643", "PostTypeId": "2", "Id": "40590641", "Score": "13", "CreationDate": "2016-11-14T14:07:38.913", "LastActivityDate": "2016-11-14T14:07:38.913"}, "bq_ids": {"n4140": {"so_40590216_40590301_2": {"section_id": 5986, "quality": 0.7567567567567568, "length": 28}, "so_40590216_40590301_3": {"section_id": 6142, "quality": 0.9411764705882353, "length": 16}, "so_40590216_40590301_1": {"section_id": 5873, "quality": 0.9285714285714286, "length": 13}, "so_40590216_40620526_2": {"section_id": 6142, "quality": 0.9230769230769231, "length": 24}, "so_40590216_40620526_1": {"section_id": 5986, "quality": 0.8333333333333334, "length": 5}, "so_40590216_40590301_0": {"section_id": 3228, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_40590216_40590301_3": {"section_id": 5906, "quality": 0.9411764705882353, "length": 16}, "so_40590216_40590301_2": {"section_id": 5754, "quality": 0.7297297297297297, "length": 27}, "so_40590216_40590301_1": {"section_id": 5644, "quality": 0.9285714285714286, "length": 13}, "so_40590216_40620526_2": {"section_id": 5906, "quality": 0.9230769230769231, "length": 24}, "so_40590216_40620526_1": {"section_id": 5754, "quality": 0.8333333333333334, "length": 5}, "so_40590216_40590301_0": {"section_id": 3101, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_40590216_40590301_2": {"section_id": 7486, "quality": 0.8648648648648649, "length": 32}, "so_40590216_40590301_3": {"section_id": 7638, "quality": 0.9411764705882353, "length": 16}, "so_40590216_40620526_0": {"section_id": 7562, "quality": 0.8888888888888888, "length": 16}, "so_40590216_40590301_1": {"section_id": 7356, "quality": 0.9285714285714286, "length": 13}, "so_40590216_40620526_2": {"section_id": 7638, "quality": 1.0, "length": 26}, "so_40590216_40620526_3": {"section_id": 8732, "quality": 0.9166666666666666, "length": 33}, "so_40590216_40620526_1": {"section_id": 7486, "quality": 0.8333333333333334, "length": 5}, "so_40590216_40590301_0": {"section_id": 3985, "quality": 0.9090909090909091, "length": 10}}}, "40590494": {"ParentId": "40590216", "CommentCount": "11", "Body": "<p>It is illegal, but there is a workaround:</p>\n<pre><code>struct data {\n    union {\n        struct {\n            int a;\n            int b;\n            int c;\n        };\n        int v[3];\n    };\n};\n</code></pre>\n<p>Now you can index v:</p>\n", "OwnerUserId": "4847311", "PostTypeId": "2", "Id": "40590494", "Score": "1", "CreationDate": "2016-11-14T14:00:30.113", "LastActivityDate": "2016-11-14T14:00:30.113"}, "40590216": {"CommentCount": "20", "AcceptedAnswerId": "40590301", "PostTypeId": "1", "LastEditorUserId": "15168", "CreationDate": "2016-11-14T13:46:36.820", "LastActivityDate": "2016-11-17T10:38:02.680", "LastEditDate": "2016-11-14T14:14:31.160", "ViewCount": "8289", "FavoriteCount": "11", "Title": "Is it legal to index into a struct?", "Id": "40590216", "Score": "96", "Body": "<p>Regardless of how 'bad' the code is, and assuming that alignment etc are not an issue on the compiler/platform, is this undefined or broken behavior?</p>\n<p>If I have a struct like this :-</p>\n<pre><code>struct data\n{\n    int a, b, c;\n};\n\nstruct data thing;\n</code></pre>\n<p>Is it <strong>legal</strong> to access <code>a</code>, <code>b</code> and <code>c</code> as <code>(&amp;thing.a)[0]</code>, <code>(&amp;thing.a)[1]</code>, and <code>(&amp;thing.a)[2]</code>?</p>\n<p>In every case, on every compiler and platform I tried it on, with every setting I tried it 'worked'. I'm just worried that the compiler might not realize that <strong>b</strong> and <strong>thing[1]</strong> are the same thing and stores to 'b' might be put in a register and thing[1] reads the wrong value from memory (for example). In every case I tried it did the right thing though. (I realize of course that doesn't prove much)</p>\n<p>This is not my code; it's code I have to work with, I'm interested in whether this is <strong>bad</strong> code or <strong>broken</strong> code as the different affects my priorities for changing it a great deal :)</p>\n<p>Tagged C and C++ . I'm mostly interested in C++ but also C if it is different, just for interest.</p>\n", "Tags": "<c++><c><struct>", "OwnerUserId": "417292", "AnswerCount": "10"}, "40590301": {"ParentId": "40590216", "PostTypeId": "2", "CommentCount": "21", "Body": "<p>It is illegal <sup>1</sup>. That's an Undefined behavior in C++.</p>\n<p>You are taking the members in an array fashion, but here is what the C++ standard says (emphasis mine): </p>\n<blockquote>\n<p id=\"so_40590216_40590301_0\"><strong><a href=\"http://eel.is/c++draft/dcl.array#1\" rel=\"nofollow noreferrer\">[dcl.array/1]</a>:</strong> ...An object of array type contains a <strong>contiguously</strong> allocated non-empty set of N\n  subobjects of type T...</p>\n</blockquote>\n<p>But, for members, there's no such <em>contiguous</em> requirement:</p>\n<blockquote>\n<p id=\"so_40590216_40590301_1\"><strong><a href=\"http://eel.is/c++draft/class.mem#17\" rel=\"nofollow noreferrer\">[class.mem/17]</a>:</strong> ...;Implementation alignment requirements <strong>might cause two adjacent\n  members not to be allocated immediately after each other</strong>...</p>\n</blockquote>\n<p>While the above two quotes should be enough to hint why indexing into a <code>struct</code> as you did isn't a defined behavior by the C++ standard, let's pick one example: look at the expression <code>(&amp;thing.a)[2]</code> - Regarding the subscript operator:</p>\n<blockquote>\n<p id=\"so_40590216_40590301_2\"><strong><a href=\"http://eel.is/c++draft/expr.post#expr.sub-1\" rel=\"nofollow noreferrer\">[expr.post//expr.sub/1]</a>:</strong>\n  A postfix expression followed by an expression in square brackets is a\n  postfix expression. One of the expressions shall be a glvalue of type\n  \u201carray of T\u201d or a prvalue of type \u201cpointer to T\u201d and the other shall\n  be a prvalue of unscoped enumeration or integral type. The result is\n  of type \u201cT\u201d. The type \u201cT\u201d shall be a completely-defined object type.66\n  <strong>The expression <code>E1[E2]</code> is identical (by definition) to <code>((E1)+(E2))</code></strong></p>\n</blockquote>\n<p>Digging into the bold text of the above quote: regarding adding an integral type to a pointer type (note the emphasis here)..</p>\n<blockquote>\n<p id=\"so_40590216_40590301_3\"><strong><a href=\"http://eel.is/c++draft/expr.add#4\" rel=\"nofollow noreferrer\">[expr.add/4]</a>:</strong> When an expression that has integral type is added to or subtracted from a\n  pointer, the result has the type of the pointer operand. <strong>If</strong> the\n  expression <code>P</code> points to element <code>x[i]</code> of <strong><em>an array</em></strong> object <code>x</code></p></blockquote>\n  with n elements, the expressions <code>P + J</code> and <code>J + P</code> (where <code>J</code> has\n  the value <code>j</code>) point to the (possibly-hypothetical) element <code>x[i + j]</code>\n  if <code>0 \u2264 i + j \u2264 n</code>; <strong>otherwise</strong>, the behavior is undefined. ...\n\n<p>Note the <em>array</em> requirement for the <strong>if</strong> clause; else the <strong>otherwise</strong> in the above quote. The expression <code>(&amp;thing.a)[2]</code> obviously doesn't qualify for the <strong>if</strong> clause; Hence, Undefined Behavior.</p>\n<hr>\n<p>On a side note: Though I have extensively experimented the code and its variations on various compilers and they don't introduce any padding here, (it <em>works</em>); from a maintenance view, the code is extremely fragile. you should still assert that the implementation allocated the members contiguously before doing this. And stay in-bounds :-).  But its still Undefined behavior....</p>\n<p>Some viable workarounds (with defined behavior) have been provided by other answers.</p>\n<hr>\n<hr>\n<p>As rightly pointed out in the comments, <strong><a href=\"http://eel.is/c++draft/basic.lval#8\" rel=\"nofollow noreferrer\">[basic.lval/8]</a></strong>, which was in my previous edit doesn't apply. Thanks @2501 and @M.M.</p>\n<p><sup>1</sup>: See @Barry's answer to this question for the only one legal case where you can access <code>thing.a</code> member of the struct via this parttern.</p>\n</hr></hr></hr>", "OwnerUserId": "1621391", "LastEditorUserId": "1621391", "LastEditDate": "2016-11-17T10:38:02.680", "Id": "40590301", "Score": "67", "CreationDate": "2016-11-14T13:51:22.317", "LastActivityDate": "2016-11-17T10:38:02.680"}, "40620526": {"ParentId": "40590216", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>In C++, this is <strong>mostly</strong> undefined behavior (it depends on which index).</p>\n<p>From [expr.unary.op]:</p>\n<blockquote>\n<p id=\"so_40590216_40620526_0\">For purposes of pointer\n  arithmetic (5.7) and comparison (5.9, 5.10), an object that is not an array element whose address is taken in\n  this way is considered to belong to an array with one element of type <code>T</code>.</p>\n</blockquote>\n<p>The expression <code>&amp;thing.a</code> is thus considered to refer to an array of one <code>int</code>. </p>\n<p>From [expr.sub]:</p>\n<blockquote>\n<p id=\"so_40590216_40620526_1\">The expression <code>E1[E2]</code> is identical (by definition) to <code>*((E1)+(E2))</code></p>\n</blockquote>\n<p>And from [expr.add]:</p>\n<blockquote>\n<p id=\"so_40590216_40620526_2\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the expression <code>P</code> points to element <code>x[i]</code> of an array object <code>x</code> with <code>n</code> elements, the expressions <code>P + J</code> and <code>J + P</code> (where <code>J</code> has the value <code>j</code>) point to the (possibly-hypothetical) element <code>x[i + j]</code> if <code>0 &lt;= i + j &lt;= n</code>; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p><code>(&amp;thing.a)[0]</code> is perfectly well-formed because <code>&amp;thing.a</code> is considered an array of size 1 and we're taking that first index. That is an allowed index to take.</p>\n<p><code>(&amp;thing.a)[2]</code> violates the precondition that <code>0 &lt;= i + j &lt;= n</code>, since we have <code>i == 0</code>, <code>j == 2</code>, <code>n == 1</code>. Simply constructing the pointer <code>&amp;thing.a + 2</code> is undefined behavior.</p>\n<p><code>(&amp;thing.a)[1]</code> is the interesting case. It doesn't actually violate anything in [expr.add]. We're allowed to take a pointer one past the end of the array - which this would be. Here, we turn to a note in [basic.compound]:</p>\n<blockquote>\n<p id=\"so_40590216_40620526_3\">A value of a pointer type that is a pointer to or past the end of an object represents the address of the\n  first byte in memory (1.7) occupied by the object53 or the first byte in memory after the end of the storage\n  occupied by the object, respectively. <em>[ Note:</em> A pointer past the end of an object (5.7) is not considered to\n  point to an unrelated object of the object\u2019s type that might be located at that address.</p>\n</blockquote>\n<p>Hence, taking the pointer <code>&amp;thing.a + 1</code> is defined behavior, but dereferencing it is undefined because it does not point to anything. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2016-11-16T15:03:37.857", "Id": "40620526", "Score": "7", "CreationDate": "2016-11-15T22:02:39.813", "LastActivityDate": "2016-11-16T15:03:37.857"}, "40590471": {"ParentId": "40590216", "PostTypeId": "2", "CommentCount": "20", "Body": "<p>In C++ if you really need it - create operator[]:</p>\n<pre><code>struct data\n{\n    int a, b, c;\n    int &amp;operator[]( size_t idx ) {\n        switch( idx ) {\n            case 0 : return a;\n            case 1 : return b;\n            case 2 : return c;\n            default: throw std::runtime_error( \"bad index\" );\n        }\n    }\n};\n\n\ndata d;\nd[0] = 123; // assign 123 to data.a\n</code></pre>\n<p>it is not only guaranteed to work but usage is simpler, you do not need to write unreadable expression <code>(&amp;thing.a)[0]</code></p>\n<p>Note: this answer is given in assumption that you already have a structure with fields, and you need to add access via index. If speed is an issue and you can change the structure this could be more effective:</p>\n<pre><code>struct data \n{\n     int array[3];\n     int &amp;a = array[0];\n     int &amp;b = array[1];\n     int &amp;c = array[2];\n};\n</code></pre>\n<p>This solution would change size of structure so you can use methods as well:</p>\n<pre><code>struct data \n{\n     int array[3];\n     int &amp;a() { return array[0]; }\n     int &amp;b() { return array[1]; }\n     int &amp;c() { return array[2]; }\n};\n</code></pre>\n", "OwnerUserId": "432358", "LastEditorUserId": "432358", "LastEditDate": "2016-11-14T17:29:32.713", "Id": "40590471", "Score": "37", "CreationDate": "2016-11-14T13:59:08.127", "LastActivityDate": "2016-11-14T17:29:32.713"}, "40590270": {"ParentId": "40590216", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>No. In C, this is undefined behavior even if there is no padding. </p>\n<p>The thing that causes undefined behavior is out-of-bounds access<sup>1</sup>. When you have a scalar (members a,b,c in the struct) and try to use it as an array<sup>2</sup> to access the next hypothetical element, you cause undefined behavior, even if there happens to be another object of the same type at that address.</p>\n<p>However you may use the address of the struct object and calculate the offset into a specific member:</p>\n<pre><code>struct data thing = { 0 };\nchar* p = ( char* )&amp;thing + offsetof( thing , b );\nint* b = ( int* )p;\n*b = 123;\nassert( thing.b == 123 );\n</code></pre>\n<p>This has to be done for each member individually, but can be put into a function that resembles an array access.</p>\n<hr>\n<p><sup>1</sup> (Quoted from: ISO/IEC 9899:201x 6.5.6 Additive operators 8)<br>\n If the result points one past the last element of the array object, it\nshall not be used as the operand of a unary * operator that is evaluated.</br></p>\n<p><sup>2</sup> (Quoted from: ISO/IEC 9899:201x 6.5.6 Additive operators 7)<br>\nFor the purposes of these operators, a pointer to an object that is not an element of an\narray behaves the same as a pointer to the first element of an array of length one with the\ntype of the object as its element type.</br></p>\n</hr>", "OwnerUserId": "4082723", "LastEditorUserId": "4082723", "LastEditDate": "2016-11-14T19:33:26.870", "Id": "40590270", "Score": "49", "CreationDate": "2016-11-14T13:50:16.477", "LastActivityDate": "2016-11-14T19:33:26.870"}, "40594542": {"ParentId": "40590216", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>In ISO C99/C11, union-based type-punning is legal, so you can use that instead of indexing pointers to non-arrays (see various other answers).</p>\n<p>ISO C++ doesn't allow union-based type-punning.  <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Type%2Dpunning\" rel=\"nofollow noreferrer\">GNU C++ does, as an extension</a>, and I think some other compilers that don't support GNU extensions in general do support union type-punning.  But that doesn't help you write strictly portable code.</p>\n<p>With current versions of gcc and clang, writing a C++ member function using a <code>switch(idx)</code> to select a member will optimize away for compile-time constant indices, but will produce terrible branchy asm for runtime indices.  There's nothing inherently wrong with <code>switch()</code> for this; this is simply a missed-optimization bug in current compilers.  They could compiler Slava' switch() function efficiently.</p>\n<hr>\n<p>The solution/workaround to this is to do it the other way: give your class/struct an array member, and write accessor functions to attach names to specific elements.</p>\n<pre><code>struct array_data\n{\n  int arr[3];\n\n  int &amp;operator[]( unsigned idx ) {\n      // assert(idx &lt;= 2);\n      //idx = (idx &gt; 2) ? 2 : idx;\n      return arr[idx];\n  }\n  int &amp;a(){ return arr[0]; } // TODO: const versions\n  int &amp;b(){ return arr[1]; }\n  int &amp;c(){ return arr[2]; }\n};\n</code></pre>\n<p>We can have a look at the asm output for different use-cases, on the <a href=\"https://godbolt.org/#z:OYLghAFBqd5QCxAYwPYBMCmBRdBLAF1QCcAaPECAKxAEZTUAHAvVAOwGdK0AbVAV2J4OmAIIcAtiADkABmmk0Exnh6YA8mwDCCAIZtgmGfICUpDgOLIj0tromYOjXdYDUu4sV0BPVwFIAdgAhP1lxAmJ%2BZAJ3Tx8AfXRdAl1Q0UCQsNdXPDYYj2I/AFYggGZigBE/Usz0rJy8/wAmADYmTC8iQpLKiFd%2BTjxgNkx0HPQAD1cTf2C07IXXAHol9w4RYgIIPEn/Uq1qitcmk2raxeyVnanD123d6uxjmeqAMWPXEHGJs/mL4kwBEEbFi3SC10qv3qgSq9VyMT8rV0EFOwVcAKBxBBBWKQVkkJqsyOK1cABV1BV1F80JwYgA3DocVicP7w5otABGKIy6MBwNBuNoBKCRNZjURLWQ3LRGP5OJKTWForCMKhojZSRS8QKCSZAC9MHsjvrMKgAGYQHXeRLJXSnGppNJswwELlWm0pdnoF4yvlY1zoAB0XPtItVYTpqB2rhEBCl7s1ui9pAa9N0PB9IqDUpepSOdPTZ2V6saLuulri1sTydT30zvMxIPQuIhRSqhPD6QC7dqaTsDicLkNALNHFmtQ4ESiMUT8RHHEdc3qCzZVtx5TbaoubIlSdua5K%2BM3DuX2R3rQ5RtBPkFwr%2BK/FrWQV4PQUVx973bVGtt8/iJqvE1zQgWd51DR0wmdQEuVAzBRy9etZX9IMOSLTtI2jWMpVg%2BCJXQFM2QLDNxwDQNn1uIi0K/SDS0BcscLHPCCMaa5EL9JtA1fVse2LVUTzqUQSVeYhUAkVwAGUeF0AswGkMd9A4AB3DpHSaUo8DNVxaGWVYCAQQ1UD0jpXEUnwviZCR%2BCklgDHcbFK1cdhXCIRhHM0/tRlcBwJA5Rk%2B3sRxnDcWclMIZAEHHNJJ0iaIA1tRdzlrVJ%2BLPRpUJS2tkC3Wtmwy1KEVadpOhIXFelra5pki09FiuB48zuCrHmePZ3iaT5viLHTHOILzdAAa0NIyAzg3QrJiAYARcPQOTUZzUFcRgRIkYRBv01wlBUNQer05IOrzWRA0DJoU3QVBHDYWSYn0nhGHvbcHlaW5ykJLrGFQZTiAAWnNT62swNQHEaNABhiCR%2BscZyEGEdb9N0W7qoWUK4wQPoKszO6LgWZBdBEVxZHapDsWyzHFmx3HtK%2BQnXHSxKSaxnHDTayn2PW4m6fWhnXFKZnGwDNm6awM1Rp4AgQAxkmSQmzApt0GbDX0bxTN8Ha2D6sciHcGHpdciVDnFzGqeSsMEcxlZ4niDl%2BFUGz4ilmW5e5PL2ZWPSRMUvH%2BYWTtFk7PjezCAhvEYUY4P6NhmRI6Lpziz1cpFVdK1xAAWJUYWcoPMHiAg1SdRpzeSCI8EtghM/iO4IDYKM2B4XJMBMGZkEYRgQNtVwACp8PKyZThVJdRGyKmIA704Sm4nPqIEtl84IQvi9L8vK9yGuRnr9aIED4Os/bghmJiViEr%2BKmCE%2Bx4uMmO9e9hASljb3OYmn2f%2BBL82F6r5e64blvPQ73e6wP%2BoViDwlCBE%2BpRsB2hHuCc%2BH5LirABAARytgCMcn0zSV0%2BtFPA0RPrpjwDjXIwA/h/A3pnGICJ6o8kDGMW4HdRQvS6i4IE6YeC%2BDQCoRwh8WYEE4onUe0CeyLivm3JYgic5qUwGwfAZppBmB4DIIoCg2AyFoAoVAMgDhNBCJomMlg3CIlKCo0gos5AyLMH1EApRSiBksTY2xdiWikDkdIJOijjCqJkAoLgsgjFuLMHAWASANqqA6OQbgolNodBAMAFox0zTW0ZJQDkbjFCiUBgQTQLDkn4ABNEPADIuAmPIHkf6viGDMGZAUz66hSiuE%2BgAdWYbUupmAJgRF0DIxx8jXGFLUdIfR2lFKEAihMAAHC0T6LQk6uGAMgZ8LQjoKGMaYMxFirF2PWTYhxTiXGkCUT0jx5gQDeKWR0/xiAUDhOCWQCgEAglbRQFJAwpQACc3i4kiwSRAJJhSlBpIyd4LJeAcksHyck%2BEJSTFmCYCwdglTqlNMafUlpbSOlOIUbs5JvT%2BkmSGa4UZ4zJnrUecALmgZnmBnkD4yFKzLHWI2eszpzjumUt6Z4o5VLlmMqaMy9x0hFm%2BLMAyYgTJ2AgCTkAA%3D%3D%3D\" rel=\"nofollow noreferrer\">Godbolt compiler explorer</a>.  These are complete x86-64 System V functions, with the trailing RET instruction omitted to better show what you'd get when they inline.  ARM/MIPS/whatever would be similar.</p>\n<pre><code># asm from g++6.2 -O3\nint getb(array_data &amp;d) { return d.b(); }\n    mov     eax, DWORD PTR [rdi+4]\n\nvoid setc(array_data &amp;d, int val) { d.c() = val; }\n    mov     DWORD PTR [rdi+8], esi\n\nint getidx(array_data &amp;d, int idx) { return d[idx]; }\n    mov     esi, esi                   # zero-extend to 64-bit\n    mov     eax, DWORD PTR [rdi+rsi*4]\n</code></pre>\n<hr>\n<p>By comparison, @Slava's answer using a <code>switch()</code> for C++ makes asm like this for a runtime-variable index.  (Code in the previous Godbolt link).</p>\n<pre><code>int cpp(data *d, int idx) {\n    return (*d)[idx];\n}\n\n    # gcc6.2 -O3, using `default: __builtin_unreachable()` to promise the compiler that idx=0..2,\n    # avoiding an extra cmov for idx=min(idx,2), or an extra branch to a throw, or whatever\n    cmp     esi, 1\n    je      .L6\n    cmp     esi, 2\n    je      .L7\n    mov     eax, DWORD PTR [rdi]\n    ret\n.L6:\n    mov     eax, DWORD PTR [rdi+4]\n    ret\n.L7:\n    mov     eax, DWORD PTR [rdi+8]\n    ret\n</code></pre>\n<p>This is obviously terrible, compared to the C (or GNU C++) union-based type punning version:</p>\n<pre><code>c(type_t*, int):\n    movsx   rsi, esi                   # sign-extend this time, since I didn't change idx to unsigned here\n    mov     eax, DWORD PTR [rdi+rsi*4]\n</code></pre>\n</hr></hr>", "OwnerUserId": "224132", "LastEditorUserId": "224132", "LastEditDate": "2016-11-15T08:07:31.440", "Id": "40594542", "Score": "10", "CreationDate": "2016-11-14T17:31:09.427", "LastActivityDate": "2016-11-15T08:07:31.440"}, "40604136": {"ParentId": "40590216", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>If reading values is enough, and efficiency is not a concern, or if you trust your compiler to optimize things well, or if struct is just that 3 bytes, you can safely do this:</p>\n<pre><code>char index_data(const struct data *d, size_t index) {\n  assert(sizeof(*d) == offsetoff(*d, c)+1);\n  assert(index &lt; sizeof(*d));\n  char buf[sizeof(*d)];\n  memcpy(buf, d, sizeof(*d));\n  return buf[index];\n}\n</code></pre>\n<p>For C++ only version, you would probably want to use <code>static_assert</code> to verify that <code>struct data</code> has standard layout, and perhaps throw exception on invalid index instead.</p>\n", "OwnerUserId": "1717300", "LastEditorUserId": "1717300", "LastEditDate": "2016-11-15T09:30:22.710", "Id": "40604136", "Score": "2", "CreationDate": "2016-11-15T07:19:30.907", "LastActivityDate": "2016-11-15T09:30:22.710"}});