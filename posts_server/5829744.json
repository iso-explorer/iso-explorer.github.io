post_cb({"5830023": {"ParentId": "5829744", "CommentCount": "2", "Body": "<p>On the <em>it should generate an error</em> part of the question. Not according to the standard:</p>\n<p>9.2 [class.mem]/13</p>\n<blockquote>\n<p id=\"so_5829744_5830023_0\">If T is the name of a class, then each of the following shall have a name different from T:</p>\n</blockquote>\n<ul>\n<li>every static data member of class T;</li>\n<li>every member function of class T [Note: this restriction does not apply to constructors, which do not have names (12.1) ] ;</li>\n<li>every member of class T that is itself a type;</li>\n<li>every enumerator of every member of class T that is an enumerated type; and</li>\n<li>every member of every anonymous union that is a member of class T.</li>\n</ul>\n<p>9.2 [class.mem]/13a</p>\n<blockquote>\n<p id=\"so_5829744_5830023_1\">In addition, if class T has a user-declared constructor (12.1), every nonstatic data member of class T shall have a name different from T.</p>\n</blockquote>\n<p>As to why does it find the member rather than the variable, that is pretty much consistent with how the identifiers are handled in C++, where there are two identifier spaces, one for user defined types and another for the rest of the elements (including typedefs):</p>\n<pre><code>struct test {};\nvoid test() {}\n// or (but not both)\n// int test;\n</code></pre>\n<p>With those two definitions, <code>test</code> refers to the function (or variable), and <code>struct test</code> to the user defined type. This is the particular corner case where the use of <code>typedef</code> when declaring an <code>struct</code> in C makes a difference in C++, as it will inject the name in the common identifier space:</p>\n<pre><code>typedef struct test {} test; // now \"test\" is in both spaces\n// void test() {}            // error: redefinition of \"test\"\n</code></pre>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "5830023", "Score": "6", "CreationDate": "2011-04-29T08:53:49.657", "LastActivityDate": "2011-04-29T08:53:49.657"}, "5829830": {"ParentId": "5829744", "CommentCount": "0", "Body": "<p>When you call <code>f.memfunc</code>, the call to <code>fred()</code> will resolve to the member named <code>fred</code> of type <code>foo</code>. Declaring <code>memfunc</code> as returning <code>struct fred</code> won't help you anything, since you cannot do polymorphism on return values in C++.</p>\n<p>To make the <code>fred()</code> call resolve to the constructor of <code>struct fred</code>, qualify the call with a namespace (<code>::fred()</code>). </p>\n", "OwnerUserId": "94237", "PostTypeId": "2", "Id": "5829830", "Score": "3", "CreationDate": "2011-04-29T08:33:47.373", "LastActivityDate": "2011-04-29T08:33:47.373"}, "5829798": {"ParentId": "5829744", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>Because in the <code>fred</code> structure you have a member <code>fred</code> (of type <code>foo</code>) which shadows the definition of <code>struct fred</code>. When you then do:</p>\n<pre><code>return fred();\n</code></pre>\n<p>... the <code>fred</code> refers to the object of type <code>foo</code> rather than the <code>fred</code> struct type, and so the <code>foo</code> () operator is called.</p>\n<p>Notice that the name \"fred\" refers to two different things - the member, of type foo, and the <code>fred</code> struct type. The compiler must choose one or the other, and it does so according to the rules defined in section 3.4 (\"Name Lookup\") of the C++ standard.</p>\n<p>You can force <code>fred</code> to refer to the type using a namespace qualification:</p>\n<pre><code>return ::fred();\n</code></pre>\n", "OwnerUserId": "388661", "LastEditorUserId": "388661", "LastEditDate": "2011-04-29T08:43:32.850", "Id": "5829798", "Score": "6", "CreationDate": "2011-04-29T08:29:56.747", "LastActivityDate": "2011-04-29T08:43:32.850"}, "5829846": {"ParentId": "5829744", "CommentCount": "0", "Body": "<p>As others have pointed out, you are calling the <code>operator()</code> on the member <code>fred</code>. Either change the name of the member, or use <code>::fred()</code> to refer to the struct <code>fred</code> in the global scope.</p>\n", "OwnerUserId": "98117", "PostTypeId": "2", "Id": "5829846", "Score": "1", "CreationDate": "2011-04-29T08:34:50.817", "LastActivityDate": "2011-04-29T08:34:50.817"}, "5829744": {"CommentCount": "9", "AcceptedAnswerId": "5829798", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-04-29T08:22:55.653", "LastActivityDate": "2011-04-29T09:05:11.653", "LastEditDate": "2017-05-23T12:03:12.273", "ViewCount": "513", "FavoriteCount": "0", "Title": "Why does this program call operator () instead of the constructor?", "Id": "5829744", "Score": "6", "Body": "<p>Here is a program that compiles without warning on e.g. GNU C++:</p>\n<pre><code>$ g++ -o t -Wall -pedantic -Wshadow t.cpp\n\n$ ./t.exe\nCalling barney::barney()\nCalling foo::operator()()\nCalling barney::barney()\n</code></pre>\n<p>But it completely fails to compile on MSVC++:</p>\n<pre><code>$ cl /EHsc t.cpp\nMicrosoft (R) 32-bit C/C++ Optimizing Compiler Version 15.00.30729.01 for 80x86\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\nt.cpp\nt.cpp(17) : error C2380: type(s) preceding 'fred' (constructor with return type, or illegal redefinition of current class-name?)\nt.cpp(17) : error C2208: 'fred' : no members defined using this type\n</code></pre>\n<p><strong>What's more, when it does compile, the output is not what I'd expect. Can someone shed some light on what would be the required standard behaviour for this code</strong>?</p>\n<p>Here it is:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing ::std::cerr;\n\nstruct fred;\n\nstruct foo {\n   inline fred operator ()();\n};\n\nstruct barney {\n   barney() : v_(0) { cerr &lt;&lt; \"Calling barney::barney()\\n\"; }\n   int v_;\n};\n\nstruct fred : public barney {\n   foo fred;\n   int joe;\n   struct fred memfunc() { return fred(); }\n};\n\ninline fred foo::operator ()()\n{\n   cerr &lt;&lt; \"Calling foo::operator()()\\n\"; return fred();\n}\n\nint main(int argc, const char *argv[])\n{\n   fred f;\n   f.memfunc();\n   return 0;\n}\n</code></pre>\n<p>It outputs this:</p>\n<pre><code>Calling barney::barney()\nCalling foo::operator()()\nCalling barney::barney()\n</code></pre>\n<p>But I would expect this:</p>\n<pre><code>Calling barney::barney()\nCalling barney::barney()\n</code></pre>\n<p>Why do I get the output I do? Is this standard behavior? If it is, why, which sections of the standard are relevant?</p>\n<p>In addition to the accepted answer, <a href=\"https://stackoverflow.com/users/36565/david-rodriguez-dribeas\">David Rodriguez</a> gave an <a href=\"https://stackoverflow.com/questions/5829744/why-does-this-program-call-operator-instead-of-the-constructor/5830023#5830023\">excellent answer detailing where it says in the standard that I'm allowed to declare the member named <code>fred</code> of <code>struct fred</code></a>.</p>\n", "Tags": "<c++>", "OwnerUserId": "167958", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_5829744_5830023_0": {"section_id": 5874, "quality": 1.0, "length": 8}, "so_5829744_5830023_1": {"section_id": 5875, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_5829744_5830023_0": {"section_id": 5645, "quality": 1.0, "length": 8}, "so_5829744_5830023_1": {"section_id": 5646, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_5829744_5830023_0": {"section_id": 7357, "quality": 1.0, "length": 8}, "so_5829744_5830023_1": {"section_id": 7358, "quality": 0.9230769230769231, "length": 12}}}});