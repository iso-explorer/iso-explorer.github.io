post_cb({"27909861": {"CommentCount": "1", "ViewCount": "870", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-01-12T20:04:17.540", "LastActivityDate": "2015-01-12T20:33:00.527", "Title": "How to convert uint16_t to a wide string (std::wstring)", "AcceptedAnswerId": "27910289", "LastEditDate": "2017-05-23T11:45:46.413", "Id": "27909861", "Score": "3", "Body": "<p>My question is related to this older question\n<a href=\"https://stackoverflow.com/questions/6993132/format-specifiers-for-uint8-t-uint16-t\">Format specifiers for uint8_t, uint16_t, ...?</a></p>\n<p>Just to recap the original question was related to how to use the specifiers for uint8_t, uint16_t, uint32_t and uint64_t with a scanf?</p>\n<p>The answer to the question was as follows:</p>\n<pre><code>sscanf (line, \"Value of integer: %\" SCNd32 \"\\n\", &amp;my_integer);\n</code></pre>\n<p>But does anyone know how to do this but resulting in a wide string?</p>\n<p>ie</p>\n<pre><code>std::wstring line;\nswscanf (line.c_str(), L\"Value of integer: %\" SCNd16 L\"\\n\", &amp;my_integer);\n</code></pre>\n<p>The sbove line gives me a concatenating error. I believe because the SCNd16 is just not intended for a widestring?</p>\n<p>Currently my solution is to create the std::string in the original answer and then convert it to a wide string </p>\n<pre><code>sscanf_s(line.c_str(), \"%\" SCNd16 \"\\n\", &amp;sixteenBitInteger)\n// code here to check for EOF and EINVAL\n//then I convert it \ntypedef std::codecvt_utf8&lt;wchar_t&gt; ConverterType; \nstd::wstring_convert&lt;ConverterType, wchar_t&gt; converter;\nstd::wstring convertedString = converter.from_bytes(line);\n</code></pre>\n<p>but it's rather ugly and I am sure there must be a more polished way to do this conversion? \nIf it helps to understand my use, I am using the uint16_t type to store the port number for a web server but I want to be able to convert it to a wide string as that is the expected display type. I am also using C++11 if that changes the answer at all and I do have access to the boost libraries although I would rather not use them.</p>\n", "Tags": "<c++><string><c++11>", "OwnerUserId": "3802795", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_27909861_27910289_0": {"section_id": 5362, "quality": 1.0, "length": 28}}, "n3337": {"so_27909861_27910289_0": {"section_id": 5158, "quality": 1.0, "length": 28}}, "n4659": {"so_27909861_27910289_0": {"section_id": 6786, "quality": 0.7142857142857143, "length": 20}}}, "27910037": {"ParentId": "27909861", "CommentCount": "0", "Body": "<p>A pure guess as I don't have time at the moment to try it.</p>\n<p>Can you use the preprocesser to token paste the wide-string L to the front of the expanded SCNd16?</p>\n", "OwnerUserId": "13422", "PostTypeId": "2", "Id": "27910037", "Score": "0", "CreationDate": "2015-01-12T20:15:15.667", "LastActivityDate": "2015-01-12T20:15:15.667"}, "27910289": {"ParentId": "27909861", "CommentCount": "0", "Body": "<p>This is a <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/816826/error-c2308-concatenating-mismatched-strings-given-when-it-shouldnt-be\" rel=\"nofollow\">VS2013 compiler bug</a>. Since it has been closed as \"fixed\", maybe it'll work in VS2015 (don't have the preview installed to give it a try).</p>\n<p>The line of code you have</p>\n<pre><code>swscanf (line.c_str(), L\"Value of integer: %\" SCNd16 L\"\\n\", &amp;my_integer);\n</code></pre>\n<p>is well formed, because even if <code>SCNd16</code> expands to a string literal that lacks the <code>L</code> prefix, the standard says that if out of two adjacent string literals, one lacks an encoding prefix, it is treated as if it has the same encoding prefix as the other.</p>\n<p><em>\u00a72.14.5/14</em> <strong>[lex.string]</strong></p>\n<blockquote>\n<p id=\"so_27909861_27910289_0\">In translation phase 6 (2.2), adjacent string literals are concatenated. If both string literals have the same <em>encoding-prefix</em>, the resulting concatenated string literal has that <em>encoding-prefix</em>. If one string literal has no <em>encoding-prefix</em>, it is treated as a string literal of the same <em>encoding-prefix</em> as the other operand. <code>...</code></p>\n</blockquote>\n<hr>\n<p>Typically, you can use the preprocessor to widen strings by using token concatenation. For instance, defining a set of macros like this</p>\n<pre><code>#define WIDEN_(x) L##x\n#define WIDEN(x) WIDEN_(x)\n</code></pre>\n<p>and converting the offending line of code to</p>\n<pre><code>swscanf (line.c_str(), L\"Value of integer: %\" WIDEN(SCNd16) L\"\\n\", &amp;my_integer);\n</code></pre>\n<p>would fix the problem, but it doesn't on VS2013 because of an implementation detail. The <code>SCNd16</code> macro actually expands into two separate string literals - <code>\"h\" \"d\"</code>. So the above macro widens the first literal, but not the second, and you run into the same (bogus) error.</p>\n<p>Your options are to either hardcode the string <code>\"hd\"</code> or go with the runtime conversion solution you've shown.</p>\n</hr>", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "27910289", "Score": "4", "CreationDate": "2015-01-12T20:33:00.527", "LastActivityDate": "2015-01-12T20:33:00.527"}});