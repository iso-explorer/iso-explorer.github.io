post_cb({"bq_ids": {"n4140": {"so_36545819_36548889_1": {"length": 28, "quality": 0.9655172413793104, "section_id": 7093}, "so_36545819_36548889_2": {"length": 22, "quality": 0.88, "section_id": 190}, "so_36545819_36548889_0": {"length": 18, "quality": 0.9, "section_id": 5846}}, "n3337": {"so_36545819_36548889_1": {"length": 21, "quality": 0.7241379310344828, "section_id": 6837}, "so_36545819_36548889_0": {"length": 18, "quality": 0.9, "section_id": 5616}, "so_36545819_36548889_2": {"length": 22, "quality": 0.88, "section_id": 184}}, "n4659": {"so_36545819_36548889_1": {"length": 27, "quality": 0.9310344827586207, "section_id": 8594}, "so_36545819_36548889_0": {"length": 18, "quality": 0.9, "section_id": 7325}, "so_36545819_36548889_2": {"length": 24, "quality": 0.96, "section_id": 195}}}, "36548889": {"Id": "36548889", "PostTypeId": "2", "Body": "<p>The problem you're running into is the <em>injected-class-name</em>. From [class]:</p>\n<blockquote>\n<p id=\"so_36545819_36548889_0\">The <em>class-name</em> is also inserted into the scope of the class itself; this is known as the <em>injected-class-name</em>.\n  For purposes of access checking, the <em>injected-class-name</em> is treated as if it were a public member name.</p>\n</blockquote>\n<p>With unqualified lookup in a class definition, the first stop is in the scope of the class and its members. From [basic.lookup.unqual]:</p>\n<blockquote>\n<p id=\"so_36545819_36548889_1\">A name used in the definition of a class <code>X</code> outside of a member function body, default argument, <em>exception-specification</em>,\n  <em>brace-or-equal-initializer</em> of a non-static data member, or nested class definition shall be\n  declared in one of the following ways:<br>\n  (7.1) \u2014 before its use in class <code>X</code> or be a member of a base class of <code>X</code> (10.2), or<br>\n  (7.2) \u2014 [...]</br></br></p>\n</blockquote>\n<p>We're looking for <code>X</code>. There is no <code>Q::X</code> (<code>Q</code>'s own scope) but there is an <code>A::X&lt;1,1&gt;::X</code> (base class scope), so lookup stops there and we never consider the enclosing namespace of <code>Q</code>. That's why we find <code>A::X&lt;&gt;</code> instead of <code>B::X&lt;&gt;</code>.</p>\n<p>With <code>Z</code>, the situation is a little bit different. Now the base class is a <em>dependent</em> class template, and unqualified lookup will not look in dependent base classes. From [temp.dep]:</p>\n<blockquote>\n<p id=\"so_36545819_36548889_2\">In the definition of a class or class template, the scope of a dependent base class (14.6.2.1) is not examined\n  during unqualified name lookup either at the point of definition of the class template or member or during\n  an instantiation of the class template or member.</p>\n</blockquote>\n<p>So while the name <code>A::X&lt;_K,_K&gt;::X</code> exists, it is not considered, so lookup continues into the enclosing namespace and <code>B::X&lt;&gt;</code> is found.</p>\n<p>In both cases, gcc/clang are correct. </p>\n", "LastActivityDate": "2016-04-11T12:36:40.893", "CommentCount": "0", "CreationDate": "2016-04-11T12:36:40.893", "ParentId": "36545819", "Score": "3", "OwnerUserId": "2069064"}, "36546041": {"Id": "36546041", "PostTypeId": "2", "Body": "<p>The gcc's error message provides the clue:</p>\n<pre><code>38 : error: wrong number of template arguments (1, should be 2)\nconst X&lt;1&gt;&amp;) {}\n^\n4 : note: provided for 'template&lt;int _I, int _II&gt; struct A::X'\nstruct X {};\n^\n</code></pre>\n<blockquote>\n<p id=\"so_36545819_36546041_0\">What is going on here?</p>\n</blockquote>\n<p>A template class is not code. It's a recipe for creating code. two-phase lookup will handle the definition of <code>Z&lt;&gt;</code> when you use it (at which point there had better be an <code>X&lt;i&gt;</code> available).</p>\n<p><code>Q</code> is a concrete class, so there's no two-phase lookup involved. <code>X&lt;i&gt;</code> must exist at that point - and it doesn't.</p>\n<p>As ever, clang and gcc are correct. MSVC is non-conforming.</p>\n", "LastEditorUserId": "2015579", "LastActivityDate": "2016-04-11T10:46:32.883", "Score": "0", "CreationDate": "2016-04-11T10:24:59.957", "ParentId": "36545819", "CommentCount": "6", "OwnerUserId": "2015579", "LastEditDate": "2016-04-11T10:46:32.883"}, "36545819": {"ViewCount": "74", "Body": "<p>I finally managed to boil down my monolithic template library compilation failure to a simple test case. MSVC disagrees with Clang and GCC on the code being malformed, mostly due to name lookup. Unfortunately, I am not adept at reading the C++ specification, and I tend to believe Clang and GCC when it comes to conformance, but could you help me finding the relevant part of the specs so I may file a bug?</p>\n<pre><code>namespace A\n{\n    template &lt;int _I, int _II&gt;\n    struct X {};\n}\n\nnamespace B\n{\n    template &lt;int _J&gt;\n    struct X {};\n\n    // Clang: OK\n    // GCC: OK\n    // MSVC: OK\n    template &lt;int _K&gt;\n    struct Y\n    {\n        Y(const A::X&lt;_K, _K&gt;&amp;,\n          const X&lt;_K&gt;&amp;) {}\n    };\n\n    // Clang: OK\n    // GCC: OK\n    // MSVC: ERROR\n    template &lt;int _K&gt;\n    struct Z : A::X&lt;_K, _K&gt;\n    {\n        Z(const A::X&lt;_K, _K&gt;&amp;,\n          const X&lt;_K&gt;&amp;) {}\n    };\n\n    // Clang: ERROR\n    // GCC: ERROR\n    // MSVC: ERROR\n    struct Q : A::X&lt;1, 1&gt;\n    {\n        Q(const A::X&lt;1, 1&gt;&amp;,\n          const X&lt;1&gt;&amp;) {}\n    };\n}\n\nint main()\n{\n    A::X&lt;1, 1&gt; ax;\n    B::X&lt;1&gt; bx;\n\n    B::Z&lt;1&gt; bz(ax, bx);\n\n    return 0;\n}\n</code></pre>\n<p>Three cases are:</p>\n<ol>\n<li>Y is nothing extraordinary. It compiles fine with both compilers.</li>\n<li>Compilation error stems from the second argument of Z's CTOR, X not having enough template arguments. It is up to name lookup to decide which X do I refer to. As far as I understood from reading <a href=\"http://en.cppreference.com/w/cpp/language/lookup\" rel=\"nofollow\">cppreference</a>, inheriting from a class should not bring in it's name into scope when it comes to unqualified name lookup.</li>\n<li>If the class Q itself is not a template , all compilers reject it. Now this is the part where I completely lose ground. Why does it matter if the class is a template or not?</li>\n</ol>\n<p>What is going on here?</p>\n", "AcceptedAnswerId": "36548889", "Title": "Name lookup with template class inheriting over namespaces", "CreationDate": "2016-04-11T10:14:43.543", "Id": "36545819", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2016-04-11T10:52:16.197", "LastEditorUserId": "1476661", "LastActivityDate": "2016-04-11T12:36:40.893", "Score": "3", "OwnerUserId": "1476661", "Tags": "<c++><templates>", "AnswerCount": "2"}});