post_cb({"18343629": {"ParentId": "18343518", "CommentCount": "0", "Body": "<p>Somewhere in your program you are doing this:</p>\n<pre><code>std::string s(nullptr);\n</code></pre>\n<p>Calling <code>std::string</code>'s constructor with a null pointer is causing it to throw a <code>std::logic_error</code> exception.</p>\n<p>From the standard:</p>\n<blockquote>\n<p id=\"so_18343518_18343629_0\">\u00a7 21.4.2</p>\n<p id=\"so_18343518_18343629_1\">basic_string(const charT* s, size_type n, const Allocator&amp; a = Allocator());</p>\n<p id=\"so_18343518_18343629_2\">Requires: s shall not be a null pointer and n &lt; npos.</p>\n</blockquote>\n", "OwnerUserId": "2093113", "PostTypeId": "2", "Id": "18343629", "Score": "3", "CreationDate": "2013-08-20T19:37:50.733", "LastActivityDate": "2013-08-20T19:37:50.733"}, "18343645": {"ParentId": "18343518", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Part of your problem is here:</p>\n<pre><code>ListNode(T item)\n{\n    mItem = item; // for a std::string, this will be a class member, non-pointer\n    mNext = NULL;\n    mPrev = NULL;\n}\n\nListNode(T item, ListNode&lt;T&gt;* next, ListNode&lt;T&gt;* prev)\n{\n    mItem = item; // same here\n    mNext = next;\n    mPrev = prev;\n}\n\n\n~ListNode()\n{\n    delete &amp;mItem; // you are attempting to delete an item you never created\n}\n</code></pre>\n<p>You should either change your constructors to create a <code>T*</code> object on the heap (which will then be deleted in your destructor), or remove the <code>delete</code> line from your destructor.</p>\n<p>This problem will be evident with far more than just <code>std::string</code>, by the way.</p>\n", "OwnerUserId": "529761", "LastEditorUserId": "529761", "LastEditDate": "2013-08-20T19:44:56.177", "Id": "18343645", "Score": "5", "CreationDate": "2013-08-20T19:38:49.073", "LastActivityDate": "2013-08-20T19:44:56.177"}, "18343518": {"CommentCount": "5", "ViewCount": "631", "CreationDate": "2013-08-20T19:31:08.393", "LastActivityDate": "2013-08-21T17:33:07.027", "Title": "C++ custom template LinkedList crashes adding std::string", "PostTypeId": "1", "Id": "18343518", "Score": "0", "Body": "<p>For academic purposes, I'm trying to develop a little \"textual adventure game\". I have to implement all data structures by my own. Now, I have some problems with the implementation of a generic (template) LinkedList.</p>\n<p>In the specific, this data structure works with everything (primitive data types and custom objects) BUT strings! (standard library strings).</p>\n<p>When I try to add strings to a list, the application crashes with the following error (in console):</p>\n<p>\"terminate called after throwing an instance of 'std::logic_error'\nwhat(): basic_string::_S_constructor null not valid\"</p>\n<p>The list is implemented as a \"double linked list\" using the head-node as first-last node</p>\n<p>Here the code (\"Abstract\" List interface):</p>\n<pre><code>#ifndef LIST_H_\n#define LIST_H_\n\ntemplate &lt;class T&gt;\nclass List\n{\npublic:\n virtual ~List() {}\n virtual T get(int position) = 0;\n virtual List* add(T item) = 0;\n virtual List* insert(T item, int position) = 0;\n virtual List* remove(int position) = 0;\n virtual int size() const = 0;\n virtual bool isEmpty() const = 0;\n\nprotected:\n\nprivate:\n\n};\n\n#endif /* LIST_H_ */\n</code></pre>\n<p>This is the LinkedList implementation (the \"node\" class):</p>\n<pre><code>#include \"List.h\"\n#include &lt;stdlib.h&gt;\n\n#ifndef LINKEDLIST_H_\n#define LINKEDLIST_H_\n\ntemplate &lt;class T&gt;\nclass ListNode\n{\npublic:\nListNode(T item)\n{\n    mItem = item;\n    mNext = NULL;\n    mPrev = NULL;\n}\n\nListNode(T item, ListNode&lt;T&gt;* next, ListNode&lt;T&gt;* prev)\n{\n    mItem = item;\n    mNext = next;\n    mPrev = prev;\n}\n\n\n~ListNode()\n{\n    delete &amp;mItem;\n}\n\n\nT getItem()\n{\n    return mItem;\n}\n\n\nListNode&lt;T&gt;* getNext()\n{\n    return mNext;\n}\n\n\nListNode&lt;T&gt;* getPrev()\n{\n    return mPrev;\n}\n\n\nvoid setItem(T item)\n{\n    mItem = item;\n}\n\n\nvoid setNext(ListNode&lt;T&gt;* next)\n{\n    mNext = next;\n}\n\n\nvoid setPrev(ListNode&lt;T&gt;* prev)\n{\n    mPrev = prev;\n}\n\nprotected:\nprivate:\nT mItem;\nListNode&lt;T&gt; *mNext, *mPrev;\n};\n</code></pre>\n<p>The LinkedList class:</p>\n<pre><code>template &lt;class K&gt;\nclass LinkedList : public List&lt;K&gt;\n{\npublic:\nLinkedList()\n{\n    mSize = 0;\n    mFirstNode = NULL;\n}\n\n~LinkedList()\n{\n    // implementazione distruttore tramite ciclo sui nodi\n}\n\nK get(int position)\n{\n    K item = NULL;\n\n    ListNode&lt;K&gt;* targetNode = getNodeAtPosition(position);\n    if (targetNode != NULL) item = targetNode-&gt;getItem();\n\n    return item;\n}\n\nList&lt;K&gt;* add(K item)\n{\n    if (mFirstNode == NULL)\n    {\n        mFirstNode = new ListNode&lt;K&gt;(item);\n        mFirstNode-&gt;setNext(mFirstNode);\n        mFirstNode-&gt;setPrev(mFirstNode);\n    }\n    else\n    {\n        ListNode&lt;K&gt;* newNode = new ListNode&lt;K&gt;(item, mFirstNode, mFirstNode-&gt;getPrev());\n        mFirstNode-&gt;getPrev()-&gt;setNext(newNode);\n        mFirstNode-&gt;setPrev(newNode);\n    }\n\n    mSize++;\n    return this;\n}\n\nList&lt;K&gt;* insert(K item, int position)\n{\n    ListNode&lt;K&gt;* targetNode = getNodeAtPosition(position);\n\n    if (targetNode != NULL)\n    {\n        ListNode&lt;K&gt;* newNode = new ListNode&lt;K&gt;(targetNode-&gt;getItem(), targetNode-&gt;getNext(), targetNode);\n        targetNode-&gt;setItem(item);\n        targetNode-&gt;setNext(newNode);\n\n        mSize++;\n    }\n\n    return this;\n}\n\nList&lt;K&gt;* remove(int position)\n{\n    ListNode&lt;K&gt;* targetNode = getNodeAtPosition(position);\n    if (targetNode != NULL)\n    {\n        targetNode-&gt;setItem(targetNode-&gt;getNext()-&gt;getItem());\n        targetNode-&gt;setNext(targetNode-&gt;getNext()-&gt;getNext());\n\n        //delete targetNode-&gt;getNext();\n        mSize--;\n    }\n\n    return this;\n}\n\nint size() const\n{\n    return mSize;\n}\n\nbool isEmpty() const\n{\n    return (mFirstNode == NULL) ? true : false;\n}\n\nprotected:\nListNode&lt;K&gt;* getNodeAtPosition(int position)\n{\n    ListNode&lt;K&gt;* current = NULL;\n\n    if (mFirstNode != NULL &amp;&amp; position &lt; mSize)\n    {\n        current = mFirstNode;\n\n        for (int i = 0; i &lt; position; i++)\n        {\n            current = current-&gt;getNext();\n        }\n    }\n\n    return current;\n}\n\nprivate:\n     int mSize;\n     ListNode&lt;K&gt;* mFirstNode;\n};\n\n #endif /* LINKEDLIST_H_ */\n</code></pre>\n<p>Suggestions?</p>\n", "Tags": "<c++><string><list><nodes>", "OwnerUserId": "721749", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_18343518_18343629_1": {"section_id": 1572, "quality": 1.0, "length": 6}}, "n3337": {"so_18343518_18343629_1": {"section_id": 1568, "quality": 1.0, "length": 6}}, "n4659": {"so_18343518_18343629_1": {"section_id": 1725, "quality": 1.0, "length": 6}}}, "18364049": {"ParentId": "18343518", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It seems it's not possible to pass std::string as template argument...</p>\n<p><a href=\"https://stackoverflow.com/questions/1826464/strings-as-template-arguments\">Strings as Template Arguments</a></p>\n<p>Now I use an \"old\" - char const* - to achieve the expected result, even if I have to implement my personal \"utils\" methods to work with those pointers now...</p>\n", "OwnerUserId": "721749", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:25:27.643", "Id": "18364049", "Score": "0", "CreationDate": "2013-08-21T17:33:07.027", "LastActivityDate": "2013-08-21T17:33:07.027"}});