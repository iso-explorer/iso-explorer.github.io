post_cb({"bq_ids": {"n4140": {"so_23150761_23150939_1": {"length": 44, "quality": 1.0, "section_id": 7043}}, "n3337": {"so_23150761_23150939_1": {"length": 44, "quality": 1.0, "section_id": 6788}}, "n4659": {"so_23150761_23150939_1": {"length": 44, "quality": 1.0, "section_id": 8540}}}, "27049057": {"Id": "27049057", "PostTypeId": "2", "Body": "<p>Expanding on Mike Seymour's answer -- the paragraph (3.2/5) he cites in in the Standard refers to a concept called <a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.9.2/gcc/Vague-Linkage.html#Vague-Linkage\" rel=\"nofollow\">\"vague linkage\"</a>.  Basically, it's a way of saying \"we need this to exist <em>somewhere</em> in the resulting binary, but we don't have a clear-cut home for it in any specific object file we're emitting.\"  On modern platforms (Windows, ELF systems such as Linux, and OS X), this is implemented using a mechanism known as COMDAT support that allows the compiler to simply generate the instantiations and other vague linkage items (vtables, typeinfos, and inline function bodies) as-needed -- the linker then is free to throw out the duplicates:</p>\n<blockquote>\n<p id=\"so_23150761_27049057_0\">When used with GNU ld version 2.8 or later on an ELF system such as GNU/Linux or Solaris &gt; 2, or on Microsoft Windows, duplicate copies of these constructs will be discarded at \n  link time. This is known as COMDAT support. </p>\n</blockquote>\n<p>This is discussed in more detail in the <a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.9.2/gcc/Template-Instantiation.html#Template-Instantiation\" rel=\"nofollow\">GCC manual</a> (quote snipped as the Cfront model is irrelevant for modern compilers): </p>\n<blockquote>\n<p id=\"so_23150761_27049057_1\">C++ templates are the first language feature to require more intelligence from the \n  environment than one usually finds on a UNIX system. Somehow the compiler and linker \n  have to make sure that each template instance occurs exactly once in the executable if \n  it is needed, and not at all otherwise. There are two basic approaches to this problem, \n  which are referred to as the Borland model and the Cfront model.</p>\n<p id=\"so_23150761_27049057_2\">Borland model</p>\n<p id=\"so_23150761_27049057_3\">Borland C++ solved the template instantiation problem by adding the code equivalent \n  of common blocks to their linker; the compiler emits template instances in each \n  translation unit that uses them, and the linker collapses them together. The advantage \n  of this model is that the linker only has to consider the object files themselves; there \n  is no external complexity to worry about. This disadvantage is that compilation time is \n  increased because the template code is being compiled repeatedly. Code written for this \n  model tends to include definitions of all templates in the header file, since they must \n  be seen to be instantiated. </p>\n</blockquote>\n", "LastActivityDate": "2014-11-20T20:35:21.087", "CommentCount": "0", "CreationDate": "2014-11-20T20:35:21.087", "ParentId": "23150761", "Score": "1", "OwnerUserId": "3657206"}, "23150861": {"Id": "23150861", "PostTypeId": "2", "Body": "<p>Consider that a template function (or function template if you prefer) is not a function at all.  It is rather a recipe to create a function.  The actual function is only created when and where the template is instantiated.  So you do not need the <code>inline</code> keyword here, because template functions will not result in multiple-definition linker errors because they are not actually defined (from the linker's perspective) until they are used.</p>\n", "LastActivityDate": "2014-04-18T09:02:55.477", "CommentCount": "0", "CreationDate": "2014-04-18T09:02:55.477", "ParentId": "23150761", "Score": "1", "OwnerUserId": "4323"}, "23150939": {"Id": "23150939", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_23150761_23150939_0\">Is <code>inline</code> necessary to avoid a linker error?</p>\n</blockquote>\n<p>On a function template, no. Templates, like inline functions, are subject to a more relaxed One Definition Rule which allows multiple definitions - as long as the definitions are identical and in separate translation units.</p>\n<p>As you say, <code>inline</code> would be necessary if you wanted to define a non-template function in a header; non-inline functions are subject to a more strict One Definition Rule, and can only have one definition in a program.</p>\n<p>For the gory details, this is specified by C++11 3.2/5:</p>\n<blockquote>\n<p id=\"so_23150761_23150939_1\">There can be more than one definition of a class type, <strong>inline function</strong> with\n  external linkage, class template, non-static <strong>function template</strong>, static data member\n  of a class template, member function of a class template, or template specialization for\n  which some template parameters are not specified in a program provided that each definition\n  appears in a different translation unit, and provided the definitions satisfy the following requirements.</p>\n</blockquote>\n<p>(The \"following requirements\" basically say that the definitions must be identical).</p>\n", "LastActivityDate": "2014-04-18T09:07:53.887", "CommentCount": "0", "CreationDate": "2014-04-18T09:07:53.887", "ParentId": "23150761", "Score": "5", "OwnerUserId": "204847"}, "23150761": {"ViewCount": "127", "Body": "<p>This code will be placed in a header file:</p>\n<pre><code>template&lt;typename TTT&gt;\ninline Permutation&lt;TTT&gt; operator * (const Cycle&lt;TTT&gt;&amp; cy, const Permutation&lt;TTT&gt;&amp; p)\n{\n    return Permutation&lt;TTT&gt;(cy)*p;\n}\n</code></pre>\n<p>Is <code>inline</code> necessary to avoid a linker error?</p>\n<p>If this function is not a template and the header file is used in more than one .cpp file, <code>inline</code> is necessary to avoid a liker error complaining about multiple definitions for a function. It seems linker ignores this for templates.</p>\n", "AcceptedAnswerId": "23150939", "Title": "inline keyword for templates", "CreationDate": "2014-04-18T08:54:39.797", "Id": "23150761", "CommentCount": "6", "PostTypeId": "1", "ClosedDate": "2015-01-07T17:24:07.850", "LastActivityDate": "2014-11-20T20:35:21.087", "Score": "1", "OwnerUserId": "2029077", "Tags": "<c++>", "AnswerCount": "3"}});