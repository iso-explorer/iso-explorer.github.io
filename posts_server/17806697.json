post_cb({"17807273": {"Id": "17807273", "PostTypeId": "2", "Body": "<p>You transferred <code>locks</code> out of <code>lock_array()</code> function, compiler should use <a href=\"http://en.wikipedia.org/wiki/Return_value_optimization\" rel=\"nofollow\">RVO</a> or <strong>move</strong> locks out of <code>lock_array()</code>, otherwise you will get compiler error as unique_lock is moveable but not copyable.</p>\n<p>locks still locked because they acquire lock during construction and will destroy only when locks go out of scope. Your <strong>transfer action</strong> won't destroy locks. </p>\n<p>\u00a7 30.4.2.2</p>\n<blockquote>\n<p id=\"so_17806697_17807273_0\">An object of type unique_lock controls the ownership of a lockable object within a scope. <strong>Ownership of the lockable object may be acquired at construction or after construction, and may be transferred, after acquisition, to another unique_lock object. Objects of type unique_lock are not copyable but are movable.</strong></p>\n</blockquote>\n", "LastActivityDate": "2013-07-23T10:12:28.537", "CommentCount": "0", "CreationDate": "2013-07-23T10:12:28.537", "ParentId": "17806697", "Score": "1", "OwnerUserId": "951757"}, "bq_ids": {"n4140": {"so_17806697_17807273_0": {"length": 30, "quality": 1.0, "section_id": 2856}}, "n3337": {"so_17806697_17807273_0": {"length": 30, "quality": 1.0, "section_id": 2777}}, "n4659": {"so_17806697_17807273_0": {"length": 30, "quality": 1.0, "section_id": 3606}}}, "17807196": {"Id": "17807196", "PostTypeId": "2", "Body": "<p>Yes. Moving a <code>unique_lock</code> will preserve the lock, and moving the vector should not affect the locks at all. You could verify this:</p>\n<pre><code>void some_method()\n{\n    auto locks = lock_array();\n    for (auto const &amp; lock : locks) {\n        assert(lock.owns_lock());\n    }\n}\n</code></pre>\n<p>Also, note that you don't need <code>std::move</code> when returning; return values are moved anyway (unless the move is elided).</p>\n", "LastActivityDate": "2013-07-23T10:09:04.313", "CommentCount": "0", "CreationDate": "2013-07-23T10:09:04.313", "ParentId": "17806697", "Score": "3", "OwnerUserId": "204847"}, "17806697": {"ViewCount": "508", "Body": "<p>I have a data structure consisting of few 'blocks'. For each block I have mutex. I want to implement a method that locks entire data structure and move this lock to calling function. Here's my code:</p>\n<pre><code>std::vector&lt;std::unique_lock&lt;boost::shared_mutex&gt;&gt; lock_array() \n{\n    std::vector&lt;std::unique_lock&lt;boost::shared_mutex&gt;&gt; locks;\n    for(size_t block = 0; block &lt; BLOCK_COUNT; ++block)\n    {\n        locks.push_back(std::unique_lock&lt;boost::shared_mutex&gt;(mutexes[block]));\n    }\n    return std::move(locks);\n}\n</code></pre>\n<p>And if I call it in such way, will my array still be locked?</p>\n<pre><code>void some_method()\n{\n    auto locks = lock_array();\n    ...\n}\n</code></pre>\n", "AcceptedAnswerId": "17807196", "Title": "Move std::vector of std::unique_locks", "CreationDate": "2013-07-23T09:43:44.850", "Id": "17806697", "CommentCount": "13", "LastEditDate": "2013-07-31T10:01:11.960", "PostTypeId": "1", "LastEditorUserId": "951757", "LastActivityDate": "2013-07-31T10:01:11.960", "Score": "0", "OwnerUserId": "1882829", "Tags": "<c++><c++11><vector><locking><move-semantics>", "AnswerCount": "2"}});