post_cb({"5704869": {"ParentId": "5704498", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I'm still loss at what happen.  I'd put a comment if putting code there wasn't problematic.</p>\n<pre><code>template &lt;typename Foo&gt;\nvoid f()\n{\n    class Foo::bb x;\n}\n\nstruct X {\n    typedef int bb;\n};\n\nint main()\n{\n    f&lt;X&gt;();\n    return 0;\n}\n</code></pre>\n<p>doesn't compile with gcc with an error during the instantiation.  It will compile if X::bb is a class.  Como has the same behavior.</p>\n<p>Edit, I think I've a better understanding now.</p>\n<pre><code>class Foo::Bar;\n</code></pre>\n<p>is an elaborated-class-specifier. Foo::Bar is looked up as a qualified name (3.4.4/3).  As it is dependent, the look-up has to be done in the second phase, during instantiation.  Then if it isn't found or if it isn't a class-name or enum-name, the elaborated-class-specifier is ill-formed.</p>\n<p>TL;DR g++ doesn't seem to have a bug.</p>\n", "OwnerUserId": "136208", "LastEditorUserId": "136208", "LastEditDate": "2011-04-18T15:25:06.170", "Id": "5704869", "Score": "-1", "CreationDate": "2011-04-18T15:01:48.457", "LastActivityDate": "2011-04-18T15:25:06.170"}, "5704886": {"ParentId": "5704498", "CommentCount": "1", "Body": "<p>It fails to compile with Comeau Online (Comeau C/C++ 4.3.10.1 (Oct  6 2008 11:28:09)), so at least one of the two compiler has a bug.</p>\n<pre><code>error: typedef \"iterator\" may not be used in an elaborated\n          type specifier\n       class std::vector&lt;T&gt;::iterator it;\n</code></pre>\n", "OwnerUserId": "5353", "PostTypeId": "2", "Id": "5704886", "Score": "1", "CreationDate": "2011-04-18T15:02:46.453", "LastActivityDate": "2011-04-18T15:02:46.453"}, "5704498": {"CommentCount": "8", "CreationDate": "2011-04-18T14:36:10.893", "PostTypeId": "1", "AcceptedAnswerId": "5733997", "LastEditorUserId": "713593", "LastActivityDate": "2011-05-15T20:28:31.127", "LastEditDate": "2011-04-18T14:57:25.853", "ViewCount": "533", "FavoriteCount": "0", "Title": "gcc and class keyword", "Id": "5704498", "Score": "8", "Body": "<p>I know that <code>typename</code> and <code>class</code> keywords are interchangeable in template arguments, but I thought only <code>typename</code> is allowed for nested classes specification.</p>\n<p>Once I've accidentally wrote incorrectly \"<code>class</code>\" instead of \"<code>typename</code>\" for a nested class.\nAnd I found is that gcc accepts <code>class</code> there too, so you can write something like:</p>\n<pre><code>class std::vector&lt;T&gt;::iterator it;\ninstead of\ntypename std::vector&lt;T&gt;::iterator it;\n</code></pre>\n<p>in your template.</p>\n<p>Is this a gcc bug or does the standard really allow this syntax?</p>\n<p>UPDATE: example of code:</p>\n<pre><code>template &lt;typename T&gt;\nvoid test()\n{\n     class std::vector&lt;T&gt;::iterator it;\n}\n</code></pre>\n", "Tags": "<c++><templates><gcc>", "OwnerUserId": "713593", "AnswerCount": "6"}, "5704908": {"ParentId": "5704498", "CommentCount": "0", "Body": "<p>Certainly the Standard seems to confirm that typename should be used. From 14.6/2:</p>\n<blockquote>\n<p id=\"so_5704498_5704908_0\">A   name   used   in   a   template  declaration   or   definition   and  that is   dependent   on   a  template-parameter  is assumed not to name a type unless the applicable name lookup finds a type name or the name is qualified by the keyword typename. </p>\n</blockquote>\n", "OwnerUserId": "2100815", "PostTypeId": "2", "Id": "5704908", "Score": "1", "CreationDate": "2011-04-18T15:04:53.057", "LastActivityDate": "2011-04-18T15:04:53.057"}, "5704875": {"ParentId": "5704498", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><a href=\"http://ideone.com/BeL37\" rel=\"nofollow\">Ideone</a> shows a nice error message when the dependent name doesn't resolve to a class. So your example only works because <code>iterator</code> is indeed a <code>class</code>. :)</p>\n<hr>\n<p><strong>Edit</strong>: MSVC fails to compile even if the dependent is indeed a class,</p>\n<blockquote>\n<p id=\"so_5704498_5704875_0\"><a href=\"http://msdn.microsoft.com/en-us/library/te5w3zxd%28v=vs.80%29.aspx\" rel=\"nofollow\">error C2242</a>: typedef name cannot follow class/struct/union</p>\n</blockquote>\n<p><strong>Edit 2</strong>:\nThis seems to be a MSVC bug, as g++ and Comeau online compile just fine if the dependent name is a class.</p>\n</hr>", "OwnerUserId": "500104", "LastEditorUserId": "500104", "LastEditDate": "2011-04-18T15:36:22.757", "Id": "5704875", "Score": "0", "CreationDate": "2011-04-18T15:02:00.640", "LastActivityDate": "2011-04-18T15:36:22.757"}, "5704996": {"ParentId": "5704498", "CommentCount": "2", "Body": "<p>Section 14.6 (\"Name resolution\") in ISO 14886:2003 seems to be the definition of how this is supposed to work.  Paragraph 3 says:</p>\n<blockquote>\n<p id=\"so_5704498_5704996_0\">A <em>qualified-id</em> that refers to a type and in which the <em>nested-name-specifier</em> depends on a <em>template-parameter</em> (14.6.2) shall be prefixed by the keyword <code>typename</code> to indicate that the <em>qualified-id</em> denotes a type, forming an <em>elaborated-type-specifier</em> (7.1.5.3).</p>\n</blockquote>\n<p>No mention of the <code>class</code> keyword.  I think this is a GCC bug.</p>\n", "OwnerUserId": "226975", "PostTypeId": "2", "Id": "5704996", "Score": "2", "CreationDate": "2011-04-18T15:12:08.343", "LastActivityDate": "2011-04-18T15:12:08.343"}, "5733997": {"ParentId": "5704498", "PostTypeId": "2", "CommentCount": "1", "Body": "<p><code>class a::b</code> is an elaborated type specifier. Name lookup for an elaborated type specifier ignores non-type names. So if you are parsing a template, you can assume two things:</p>\n<ul>\n<li>When we are instantiating and do name-lookup for <code>b</code>, either name lookup gives us a type, or it errors out (wouldn't find any name). </li>\n</ul>\n<p>In C++0x for that reason, <code>class a::b</code> doesn't need <code>typename</code> (you can't put it anywhere anyway on a elaborated type specifier). C++03 doesn't allow that, so GCC appears to implement the C++0x rules as an extension. </p>\n<p>That's not particularly bad. Every real compiler implements rules that are sensible and easy to implement in their C++03 version, on their behalf, even if formally they would need to reject it. However, <code>class a::b</code> <em>must</em> lookup to a class name. If it's merely a typedef, then the lookup for the elaborated type specifier is invalid. </p>\n<p>Note that <code>class a::b</code> is the only way to ignore non-type names in a lookup (except for arcane cases like before a <code>::</code> in a qualified name that have similar special rules). For example</p>\n<pre><code>template&lt;typename T&gt; \nstruct A { typename T::type t; } \n\nstruct B { class type { }; int type; };\n\n// invalid, even though GCC accepts that incorrectly\nA&lt;B&gt; a;\n</code></pre>\n<p>If you compile to C++0x, and you use <code>class T::type t;</code>, then the code becomes valid, because <code>class T::type</code> ignores the data member, but finds the nested class. </p>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2011-05-15T20:28:31.127", "Id": "5733997", "Score": "2", "CreationDate": "2011-04-20T17:05:35.450", "LastActivityDate": "2011-05-15T20:28:31.127"}, "bq_ids": {"n4140": {"so_5704498_5704908_0": {"section_id": 169, "quality": 1.0, "length": 19}}, "n3337": {"so_5704498_5704908_0": {"section_id": 163, "quality": 1.0, "length": 19}}, "n4659": {"so_5704498_5704908_0": {"section_id": 174, "quality": 1.0, "length": 19}}}});