post_cb({"bq_ids": {"n4140": {"so_12748212_12748299_0": {"length": 11, "quality": 1.0, "section_id": 603}}, "n3337": {"so_12748212_12748299_0": {"length": 11, "quality": 1.0, "section_id": 593}}, "n4659": {"so_12748212_12748299_0": {"length": 11, "quality": 1.0, "section_id": 629}}}, "12748212": {"ViewCount": "1069", "Body": "<p>I have two snippets for ADL for demo purposes. Both snippets have been compiled by VC10, gcc &amp; comeau C++ compilers, and the result are the same for all three.</p>\n<p><strong>&lt;1&gt;ADL against using directive of a user defined namespace:</strong></p>\n<pre><code>#include &lt;algorithm&gt;\nnamespace N \n{ \n    struct T {}; \n    void swap(T,T) {} \n} \n\nnamespace M \n{ \n    void swap(N::T,N::T) {} \n} \n\nint main() \n{ \n    using M::swap; \n    N::T o1,o2;\n    swap(o1,o2); \n}\n</code></pre>\n<p>Compile result:</p>\n<pre><code>error C2668: 'M::swap' : ambiguous call to overloaded function\ncould be 'void M::swap(N::T,N::T)'\nor       'void N::swap(N::T,N::T)' [found using argument-dependent lookup]\n</code></pre>\n<p>This is expected as ADL doesn't take precedence over normal lookup result plus ADL is not 2nd class citizen, the ADL search result is unioned with normal(non ADL) unquailfied lookup. That's why we have the ambiguity.</p>\n<p><strong>&lt;2&gt;ADL against using directive of std namespace:</strong></p>\n<pre><code>#include &lt;algorithm&gt;\nnamespace N \n{ \n    struct T {}; \n    void swap(T,T) {}  //point 1\n} \n\nnamespace M \n{ \n    void swap(N::T,N::T) {} \n} \n\nint main() \n{ \n    using std::swap; \n    N::T o1,o2;\n    swap(o1,o2); \n}\n</code></pre>\n<p>This one compiles ok.</p>\n<p>The result is compiler choose ADL result(it take precedent of std::swap), meaning <code>N::swap()</code> at 'point 1' will be called. Only when in the absense of 'point 1'(say if I comment out that line), the compile will use the fall back <code>std::swap</code> instead. </p>\n<p>Note this way has been used in many places as a way to overwrite the <code>std::swap</code>.\nBut my question is, why does ADL takes precedence over 'std namespace'(case2) but is considered equal to user-defined namespace function(case1)?</p>\n<p>Is there a paragraph in C++ standard that says so ?</p>\n<p>=================================================================================\nEdit after reading useful answers, might be helpful to others.</p>\n<p>So I have tweaked my snippet 1 &amp; now the ambiguity is gone and compile apparantly prefer Nontemplate function when doing overloading resolution !</p>\n<pre><code>#include &lt;algorithm&gt;\nnamespace N \n{ \n    struct T {}; \n    void swap(T,T) {} \n} \n\nnamespace M \n{ \n    template&lt;class T&gt;\n    void swap(N::T,N::T) {} \n} \n\nint main() \n{ \n    using M::swap;\n    N::T o1,o2;\n    swap(o1,o2); //here compiler choose N::swap()\n}\n</code></pre>\n<p>I have also tweaked my snippet 2. Just to make the ambiguity appear just for fun !</p>\n<pre><code>#include &lt;algorithm&gt;\nnamespace N \n{ \n    struct T {}; \n\n    template&lt;class _Ty&gt; inline\n    void swap(_Ty&amp; _Left, _Ty&amp; _Right)\n    {\n        _Ty _Tmp = _Move(_Left);\n        _Left = _Move(_Right);\n        _Right = _Move(_Tmp);\n    }\n} \n\nnamespace M \n{ \n    void swap(N::T,N::T) {} \n} \n\nint main() \n{ \n    using std::swap; \n    N::T o1,o2;\n    swap(o1,o2); \n}\n</code></pre>\n<p>gcc and comeau both say ambiguity as expected:</p>\n<pre><code>\"std::swap\" matches the argument list, the choices that match are:\n            function template \"void N::swap(_Ty &amp;, _Ty &amp;)\"\n            function template \"void std::swap(_Tp &amp;, _Tp &amp;)\"\n</code></pre>\n<p>BTW VC10 stupid as usual let this one pass ok unless I remove the 'using std::swap'.</p>\n<p>Just a bit more to write: C++ overloading can be tricky(30+ page in C++ standard), but at appendlix B of  there is a very readable 10 page there...</p>\n<p>Thanks for all the nice inputs, now it's clear.</p>\n", "AcceptedAnswerId": "12748367", "Title": "Why does ADL take precedence over a function in 'std namespace' but is equal to function in user-defined namespace?", "CreationDate": "2012-10-05T14:15:27.187", "Id": "12748212", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-10-05T15:32:53.010", "LastEditorUserId": "833538", "LastActivityDate": "2012-10-05T17:13:10.013", "Score": "6", "OwnerUserId": "833538", "Tags": "<c++><namespaces><using-directives><argument-dependent-lookup>", "AnswerCount": "2"}, "12748367": {"Id": "12748367", "PostTypeId": "2", "Body": "<p>Your test does not check whether ADL takes precedence or not over usual lookup, but rather how overload resolution determines the best match. The reason that the second test case works is that <code>std::swap</code> is a template, and when performing overload resolution on a perfect match (found by ADL) and a template, the non-templated function takes precedence.</p>\n", "LastActivityDate": "2012-10-05T14:23:59.933", "CommentCount": "2", "CreationDate": "2012-10-05T14:23:59.933", "ParentId": "12748212", "Score": "9", "OwnerUserId": "36565"}, "12748299": {"Id": "12748299", "PostTypeId": "2", "Body": "<p>A function call happens in several stages<sup>\u2020</sup>:</p>\n<ol>\n<li>name lookup -&gt; puts candidate functions in a so-called <em>overload set</em>\n<ul>\n<li>this is the part where ADL happens if you have an unqualified name lookup</li>\n</ul></li>\n<li>template argument deduction -&gt; for every template in the overload set</li>\n<li>overload resolution -&gt; pick the best match</li>\n</ol>\n<p>You're confusing part 1 with part 3. The name lookup will actually put both <code>swap</code> functions in the overload set (<code>{N::swap, std::swap}</code>), but part 3 will decide, which one to call in the end.</p>\n<p>Now, since <code>std::swap</code> is a template, and the standard says that non-template functions are <em>more specialized</em> than template functions when doing overload resolution, your <code>&lt;2&gt;</code> calls <code>N::swap</code>:</p>\n<p><code>\u00a713.3.3 [over.match.best] p1</code></p>\n<blockquote>\n<p id=\"so_12748212_12748299_0\">Given these definitions, a viable function <code>F1</code> is defined to be a better function than another viable function <code>F2</code> if [...]</p>\n<ul>\n<li><code>F1</code> is a non-template function and <code>F2</code> is a function template specialization [...]</li>\n</ul>\n</blockquote>\n<hr>\n<p>\u2020 I recommend the first three videos of <a href=\"http://channel9.msdn.com/Series/C9-Lectures-Stephan-T-Lavavej-Core-C-\">this excellent series</a> on the subject.</p>\n</hr>", "LastEditorUserId": "500104", "LastActivityDate": "2012-10-05T17:13:10.013", "Score": "12", "CreationDate": "2012-10-05T14:20:07.710", "ParentId": "12748212", "CommentCount": "5", "OwnerUserId": "500104", "LastEditDate": "2012-10-05T17:13:10.013"}});