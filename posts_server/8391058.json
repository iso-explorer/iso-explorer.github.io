post_cb({"34139860": {"Id": "34139860", "PostTypeId": "2", "Body": "<p>The short answer: static variables declared inside of a lambda work the same as function static variables in the enclosing scope that were automatically captured (by reference).</p>\n<p>In this case, even though the lambda object is returned twice, the values persist: </p>\n<pre><code>auto make_sum()\n{\n    static int sum = 0;\n    static int count = 0;\n\n    //Wrong, since these do not have static duration, they are implicitly captured\n    //return [&amp;sum, &amp;count](const int&amp;i){\n    return [](const int&amp;i){\n        sum += i;\n        ++count;\n\n        cout &lt;&lt; \"sum: \"&lt;&lt; sum &lt;&lt; \" count: \" &lt;&lt; count &lt;&lt; endl;\n    };\n}\n\nint main(int argc, const char * argv[]) {\n    vector&lt;int&gt; v = {0,1,1,2,3,5,8,13};\n\n    for_each(v.begin(), v.end(), make_sum());\n\n    for_each(v.begin(), v.end(), make_sum());\n\n    return 0;\n}\n</code></pre>\n<p>vs:</p>\n<pre><code>auto make_sum()\n{\n    return [](const int&amp;i){\n        //Now they are inside the lambda\n        static int sum = 0;\n        static int count = 0;\n\n        sum += i;\n        ++count;\n\n        cout &lt;&lt; \"sum: \"&lt;&lt; sum &lt;&lt; \" count: \" &lt;&lt; count &lt;&lt; endl;\n    };\n}\n\nint main(int argc, const char * argv[]) {\n    vector&lt;int&gt; v = {0,1,1,2,3,5,8,13};\n\n    for_each(v.begin(), v.end(), make_sum());\n\n    for_each(v.begin(), v.end(), make_sum());\n\n    return 0;\n}\n</code></pre>\n<p>Both give the same output:</p>\n<pre><code>sum: 0 count: 1\nsum: 1 count: 2\nsum: 2 count: 3\nsum: 4 count: 4\nsum: 7 count: 5\nsum: 12 count: 6\nsum: 20 count: 7\nsum: 33 count: 8\nsum: 33 count: 9\nsum: 34 count: 10\nsum: 35 count: 11\nsum: 37 count: 12\nsum: 40 count: 13\nsum: 45 count: 14\nsum: 53 count: 15\nsum: 66 count: 16\n</code></pre>\n", "LastActivityDate": "2015-12-07T17:43:26.427", "CommentCount": "0", "CreationDate": "2015-12-07T17:43:26.427", "ParentId": "8391058", "Score": "0", "OwnerUserId": "807433"}, "8391983": {"Id": "8391983", "PostTypeId": "2", "Body": "<p>tl;dr version at the bottom.</p>\n<hr>\n<p><code>\u00a75.1.2 [expr.prim.lambda]</code></p>\n<blockquote>\n<p id=\"so_8391058_8391983_0\">p1 <em>lambda-expression</em>:<br>\n<em>lambda-introducer lambda-declarator<sub>opt</sub> compound-statement</em></br></p>\n<p id=\"so_8391058_8391983_1\">p3 The type of the <em>lambda-expression</em> (which is also the type of the closure object) is a unique, unnamed nonunion class type \u2014 called the <em>closure type</em> \u2014 whose properties are described below. This class type is not an aggregate (8.5.1). <strong>The closure type is declared in the smallest block scope, class scope, or namespace scope that contains the corresponding <em>lambda-expression</em></strong>. (<em>My note: Functions have a block scope.</em>)</p>\n<p id=\"so_8391058_8391983_2\">p5 The <em>closure type</em> for a <em>lambda-expression</em> has a public <code>inline</code> function call operator [...]</p>\n<p id=\"so_8391058_8391983_3\">p7 The <em>lambda-expression</em>\u2019s <em>compound-statement</em> yields the <em>function-body</em> (8.4) of the function call operator [...]</p>\n</blockquote>\n<p>Since the compound-statement is directly taken as the function call operator's body, and the closure type is defined in the smallest (innermost) scope, it's the same as writing the following:</p>\n<pre><code>void some_function()\n{\n    struct /*unnamed unique*/{\n      inline void operator()(int const&amp; i) const{\n        static int calls_to_cout = 0;\n        cout &lt;&lt; \"cout has been called \" &lt;&lt; calls_to_cout &lt;&lt; \" times.\\n\"\n             &lt;&lt; \"\\tCurrent int: \" &lt;&lt; i &lt;&lt; \"\\n\";\n        ++calls_to_cout;\n\n      }\n    } lambda;\n    std::vector&lt;int&gt; v = {0,1,2,3,4,5};\n    std::for_each( v.begin(), v.end(), lambda);\n}\n</code></pre>\n<p>Which is legal C++, functions are allowed to have <code>static</code> local variables.</p>\n<p><code>\u00a73.7.1 [basic.stc.static]</code></p>\n<blockquote>\n<p id=\"so_8391058_8391983_4\">p1 All variables which do not have dynamic storage duration, do not have thread storage duration, and are not local have static storage duration. <strong>The storage for these entities shall last for the duration of the program</strong>. </p>\n<p id=\"so_8391058_8391983_5\">p3 The keyword <code>static</code> can be used to declare a local variable with static storage duration. [...]</p>\n</blockquote>\n<p><code>\u00a76.7 [stmt.dcl] p4</code><br>\n(This deals with initialization of variables with static storage duration in a block scope.)</br></p>\n<blockquote>\n<p id=\"so_8391058_8391983_6\">[...] Otherwise such a variable is initialized the first time control passes through its declaration; [...]</p>\n</blockquote>\n<hr>\n<p>To reiterate: </p>\n<ul>\n<li>The type of a lambda expression is created in the innermost scope.</li>\n<li>It is <em>not</em> created anew for each function call (that wouldn't make sense, since the enclosing function body would be as my example above). </li>\n<li>It obeys (nearly) all the rules of normal classes / structs (just some stuff about <code>this</code> is different), since it <em>is</em> a non-union class type. </li>\n</ul>\n<p>Now that we have assured that for every function call, the closure type is the same, we can safely say that the static local variable is also the same; it's initialized the first time the function call operator is invoked and lives until the end of the program.</p>\n</hr></hr>", "LastEditorUserId": "500104", "LastActivityDate": "2011-12-05T21:48:16.887", "Score": "32", "CreationDate": "2011-12-05T21:16:10.240", "ParentId": "8391058", "CommentCount": "8", "OwnerUserId": "500104", "LastEditDate": "2011-12-05T21:48:16.887"}, "bq_ids": {"n4140": {"so_8391058_8391983_6": {"length": 11, "quality": 1.0, "section_id": 3919}, "so_8391058_8391983_3": {"length": 7, "quality": 0.875, "section_id": 5966}, "so_8391058_8391983_5": {"length": 9, "quality": 0.9, "section_id": 7166}, "so_8391058_8391983_4": {"length": 18, "quality": 0.9, "section_id": 7164}, "so_8391058_8391983_1": {"length": 33, "quality": 0.7674418604651163, "section_id": 5962}, "so_8391058_8391983_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 5964}}, "n3337": {"so_8391058_8391983_6": {"length": 11, "quality": 1.0, "section_id": 3779}, "so_8391058_8391983_3": {"length": 7, "quality": 0.875, "section_id": 5735}, "so_8391058_8391983_5": {"length": 9, "quality": 0.9, "section_id": 6910}, "so_8391058_8391983_4": {"length": 18, "quality": 0.9, "section_id": 6908}, "so_8391058_8391983_1": {"length": 33, "quality": 0.7674418604651163, "section_id": 5731}, "so_8391058_8391983_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 5733}}, "n4659": {"so_8391058_8391983_6": {"length": 8, "quality": 0.7272727272727273, "section_id": 4805}, "so_8391058_8391983_3": {"length": 7, "quality": 0.875, "section_id": 7460}, "so_8391058_8391983_5": {"length": 9, "quality": 0.9, "section_id": 8674}, "so_8391058_8391983_4": {"length": 18, "quality": 0.9, "section_id": 8672}, "so_8391058_8391983_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 7453}}}, "8391285": {"Id": "8391285", "PostTypeId": "2", "Body": "<p>The static variable should behave just like it would in a function body. However there's little reason to use one, since a lambda object can have member variables.</p>\n<p>In the following, <code>calls_to_cout</code> is captured by value, which gives the lambda a member variable with the same name, initialized to the current value of <code>calls_to_cout</code>. This member variable retains its value across calls but is local to the lambda object, so any copies of the lambda will get their own calls_to_cout member variable instead of all sharing one static variable. This is much safer and better.</p>\n<p>(and since lambda's are const by default and this lambda modifies <code>calls_to_cout</code> it must be declared as mutable.)</p>\n<pre><code>void some_function()\n{\n    vector&lt;int&gt; v = {0,1,2,3,4,5};\n    int calls_to_cout = 0;\n    for_each( v.begin(), v.end(),[calls_to_cout](const int &amp;i) mutable\n    {\n        cout &lt;&lt; \"cout has been called \" &lt;&lt; calls_to_cout &lt;&lt; \" times.\\n\"\n          &lt;&lt; \"\\tCurrent int: \" &lt;&lt; i &lt;&lt; \"\\n\";\n        ++calls_to_cout;\n    });\n}\n</code></pre>\n<p>If you <em>do</em> want a single variable to be shared between instances of the lambda you're still better off using captures. Just capture some kind of reference to the variable. For example here's a function that returns a pair of functions which share a reference to a single variable, and each function performs its own operation on that shared variable when called.</p>\n<pre><code>std::tuple&lt;std::function&lt;int()&gt;,std::function&lt;void()&gt;&gt;\nmake_incr_reset_pair() {\n    std::shared_ptr&lt;int&gt; i = std::make_shared&lt;int&gt;(0);\n    return std::make_tuple(\n      [=]() { return ++*i; },\n      [=]() { *i = 0; });\n}\n\nint main() {\n    std::function&lt;int()&gt; increment;\n    std::function&lt;void()&gt; reset;\n    std::tie(increment,reset) = make_incr_reset_pair();\n\n    std::cout &lt;&lt; increment() &lt;&lt; '\\n';\n    std::cout &lt;&lt; increment() &lt;&lt; '\\n';\n    std::cout &lt;&lt; increment() &lt;&lt; '\\n';\n    reset();\n    std::cout &lt;&lt; increment() &lt;&lt; '\\n';\n</code></pre>\n", "LastEditorUserId": "365496", "LastActivityDate": "2011-12-05T20:39:38.470", "Score": "7", "CreationDate": "2011-12-05T20:16:53.567", "ParentId": "8391058", "CommentCount": "1", "OwnerUserId": "365496", "LastEditDate": "2011-12-05T20:39:38.470"}, "8391058": {"ViewCount": "10972", "Body": "<p>Are static variables used in a lambda retained across calls of the function wherein the lambda is used? Or is the function object \"created\" again each function call?</p>\n<p>Useless Example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nusing std::cout;\n\nvoid some_function()\n{\n    std::vector&lt;int&gt; v = {0,1,2,3,4,5};\n    std::for_each( v.begin(), v.end(),\n         [](const int &amp;i)\n         {\n             static int calls_to_cout = 0;\n             cout &lt;&lt; \"cout has been called \" &lt;&lt; calls_to_cout &lt;&lt; \" times.\\n\"\n                  &lt;&lt; \"\\tCurrent int: \" &lt;&lt; i &lt;&lt; \"\\n\";\n             ++calls_to_cout;\n         } );\n}\n\nint main()\n{\n    some_function();\n    some_function();\n}\n</code></pre>\n<p>What is the correct output for this program?\nIs it dependent on the fact if the lambda captures local variables or not? (it will certainly change the underlying implementation of the function object, so it might have an influence) Is it an allowed behavioural inconsistency?</p>\n<p>I'm not looking for: \"My compiler outputs ...\", this is too new a feature to trust current implementations IMHO. I know asking for Standard quotes seems to be popular since the world discovered such a thing exists, but still, I would like a decent source.</p>\n", "AcceptedAnswerId": "8391983", "Title": "How do static variables in lambda function objects work?", "CreationDate": "2011-12-05T19:57:56.290", "Id": "8391058", "CommentCount": "8", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2014-05-28T07:12:09.073", "LastEditorUserId": "256138", "LastActivityDate": "2016-01-27T13:11:15.897", "Score": "37", "OwnerUserId": "256138", "Tags": "<c++><c++11><static><lambda>", "AnswerCount": "5"}, "35038341": {"Id": "35038341", "PostTypeId": "2", "Body": "<p>A static can be constructed in the capture:-</p>\n<pre><code>auto v = vector&lt;int&gt;(99);\ngenerate(v.begin(), v.end(), [x = int(1)] () mutable { return x++; });\n</code></pre>\n<p>The lambda can made by another lambda</p>\n<pre><code>auto inc = [y=int(1)] () mutable { \n    ++y; // has to be separate, it doesn't like ++y inside the []\n    return [y, x = int(1)] () mutable { return y+x++; }; \n};\ngenerate(v.begin(), v.end(), inc());\n</code></pre>\n<p>Here, y can also be captured by reference as long as inc lasts longer.</p>\n", "LastActivityDate": "2016-01-27T13:11:15.897", "CommentCount": "0", "CreationDate": "2016-01-27T13:11:15.897", "ParentId": "8391058", "Score": "1", "OwnerUserId": "832009"}, "8391223": {"Id": "8391223", "PostTypeId": "2", "Body": "<p>I do not have a copy of the final standard, and the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3092.pdf\" rel=\"nofollow\">draft</a> does not appear to address the issue explicitly (see section 5.1.2, starting on page 87 of the PDF).  But it does say that a lambda expression evaluates to a single object of <em>closure type</em>, which may be invoked repeatedly.  That being so, I believe the standard requires that static variables be initialized once and only once, just as though you'd written out the class, <code>operator()</code>, and variable capture by hand.</p>\n<p>But as you say, this is a new feature; at least for now you're stuck with whatever your implementation does, no matter what the standard says.  It's better style to explicitly capture a variable in the enclosing scope anyway.</p>\n", "LastActivityDate": "2011-12-05T20:12:09.767", "CommentCount": "0", "CreationDate": "2011-12-05T20:12:09.767", "ParentId": "8391058", "Score": "2", "OwnerUserId": "121674"}});