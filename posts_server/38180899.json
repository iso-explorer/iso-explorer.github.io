post_cb({"bq_ids": {"n4140": {"so_38180899_38183507_0": {"length": 17, "quality": 0.8095238095238095, "section_id": 4467}}, "n3337": {"so_38180899_38183507_0": {"length": 16, "quality": 0.7619047619047619, "section_id": 4304}}, "n4659": {"so_38180899_38183507_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 5732}}}, "38180899": {"ViewCount": "533", "Body": "<p>Im trying to use <code>shared_ptr</code> in an embedded project which is build with xc32 1.34 (a derivative of gcc 4.5.2). The project has RTTI disabled with <code>-fno-rtti</code>. </p>\n<pre><code>#include &lt;memory&gt;\n</code></pre>\n<p>Just including the header gives me the following errors:</p>\n<pre><code>/Applications/microchip/xc32/v1.34/bin/bin/../../lib/gcc/pic32mx/4.5.2/../../../../pic32mx/include/Cpp/memory: In member function 'virtual void* std::tr1::_Ref_count_del&lt;_Ty, _Dx&gt;::_Get_deleter(const std::type_info&amp;) const':\nIn file included from APP/MODULES/LIGHT_MANAGER/LightManager.cpp:13:0:\n/Applications/microchip/xc32/v1.34/bin/bin/../../lib/gcc/pic32mx/4.5.2/../../../../pic32mx/include/Cpp/memory:1264:39: error: cannot use typeid with -fno-rtti\n/Applications/microchip/xc32/v1.34/bin/bin/../../lib/gcc/pic32mx/4.5.2/../../../../pic32mx/include/Cpp/memory: In member function 'virtual void* std::tr1::_Ref_count_del_alloc&lt;_Ty, _Dx, _Alloc&gt;::_Get_deleter(const std::type_info&amp;) const':\n/Applications/microchip/xc32/v1.34/bin/bin/../../lib/gcc/pic32mx/4.5.2/../../../../pic32mx/include/Cpp/memory:1299:39: error: cannot use typeid with -fno-rtti\n/Applications/microchip/xc32/v1.34/bin/bin/../../lib/gcc/pic32mx/4.5.2/../../../../pic32mx/include/Cpp/memory: In function '_Dx* std::tr1::get_deleter(const std::tr1::shared_ptr&lt;_Ty2&gt;&amp;)':\n/Applications/microchip/xc32/v1.34/bin/bin/../../lib/gcc/pic32mx/4.5.2/../../../../pic32mx/include/Cpp/memory:1956:44: error: cannot use typeid with -fno-rtti\n</code></pre>\n<p>So what i want to know is: is it generally impossible to use <code>shared_ptr</code> without RTTI, or am I doing something wrong?</p>\n", "AcceptedAnswerId": "38183507", "Title": "shared_ptr without RTTI?", "CreationDate": "2016-07-04T09:13:17.547", "Id": "38180899", "CommentCount": "12", "LastEditDate": "2016-07-04T09:58:07.377", "PostTypeId": "1", "LastEditorUserId": "1741469", "LastActivityDate": "2016-07-04T14:50:27.127", "Score": "7", "OwnerUserId": "1741469", "Tags": "<c++><c++11><gcc><stl><mplab>", "AnswerCount": "1"}, "38183507": {"Id": "38183507", "PostTypeId": "2", "Body": "<p>The problem is the <code>get_deleter</code> free function:</p>\n<blockquote>\n<pre><code>template&lt;class D, class T&gt; D* get_deleter(const shared_ptr&lt;T&gt;&amp; p) noexcept;\n</code></pre>\n<p id=\"so_38180899_38183507_0\"><em>Returns:</em> If <code>p</code> owns a deleter <code>d</code> of type <em>cv</em>-unqualified <code>D</code>, returns <code>std:addressof(d)</code>; otherwise returns <code>nullptr</code>. The returned pointer remains valid as long as there exists a <code>shared_ptr</code> instance that owns <code>d</code>.</p>\n</blockquote>\n<p>Obviously, the most straightforward implementation of this is to store the <code>typeid</code> of the deleter in the control block. While there are other possible implementations they would (a) be more complicated, (b) lose binary compatibility with RTTI-enabled code, and (c) be against the \"spirit\" of <code>-fno-rtti</code>.</p>\n<p>Another problematic function is <code>dynamic_pointer_cast</code>, which calls <code>dynamic_cast</code> on the stored pointer.</p>\n<p>However, the main functionality of <code>shared_ptr</code> is implementable without the use of RTTI features, and indeed as Sergei Nikulov mentions above, the <code>shared_ptr</code> shipped with gcc 4.8.5 works with <code>-fno-rtti</code>, with the exception of the <code>get_deleter</code> and <code>dynamic_pointer_cast</code> functions; as long as you do not use those facilities there is no reason you should not be able to use <code>shared_ptr</code>. This can be contrasted with e.g. <code>any</code>, which is not implementable without the use of <code>typeid</code>.</p>\n<p>It is the responsibility of your vendor to provide a standard library that works in all configurations of their compiler, including non-standard ones if they are supporting their use. However, if your vendor is noncooperative you still have a few options:</p>\n<ul>\n<li>Patch the supplied standard library to remove the broken <code>get_deleter</code> code;</li>\n<li>Use an alternative standard library (e.g. more recent libstdc++ or libc++);</li>\n<li>Use an alternative smart pointer facility (e.g. Boost) or write one yourself.</li>\n</ul>\n", "LastEditorUserId": "567292", "LastActivityDate": "2016-07-04T14:50:27.127", "Score": "8", "CreationDate": "2016-07-04T11:22:00.253", "ParentId": "38180899", "CommentCount": "0", "OwnerUserId": "567292", "LastEditDate": "2016-07-04T14:50:27.127"}});