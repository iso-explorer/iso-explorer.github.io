post_cb({"bq_ids": {"n4140": {"so_35207678_35211117_1": {"length": 4, "quality": 1.0, "section_id": 3194}}, "n3337": {"so_35207678_35211117_1": {"length": 4, "quality": 1.0, "section_id": 3068}}, "n4659": {"so_35207678_35211117_1": {"length": 4, "quality": 1.0, "section_id": 3956}}}, "35207678": {"ViewCount": "110", "Body": "<p>Boiling a problem I'm having down to its essence, I can initialize a variable as an int by first executing a do-nothing lambda in a comma expression like this:</p>\n<pre><code>int main(){\n  auto x = ( []{}(), 10 );          // same effect as auto x = 10;\n}\n</code></pre>\n<p>But if I don't parenthesize the initializing expression,</p>\n<pre><code>int main(){\n  auto y = []{}(), 10;              // won't compile\n}\n</code></pre>\n<p>all of gcc, clang, and MSVC complain about trying to initialize <code>y</code> with a <code>void</code> expression.</p>\n<p>Why do I have to parenthesize the comma expression to use it as an initializer?</p>\n", "Title": "Why do I have to parenthesize an initializing expression that's a comma expression?", "CreationDate": "2016-02-04T17:28:29.030", "LastActivityDate": "2016-02-04T20:47:25.140", "CommentCount": "6", "LastEditDate": "2016-02-04T18:17:39.350", "PostTypeId": "1", "LastEditorUserId": "4342498", "Id": "35207678", "Score": "3", "OwnerUserId": "1426649", "Tags": "<c++><initialization><comma-operator>", "AnswerCount": "1"}, "35211117": {"Id": "35211117", "PostTypeId": "2", "Body": "<p>In a declaration, the <code>,</code> symbol separates declarators. A simpler example:</p>\n<pre><code>int i = 2, j = 3;     // OK: declares `i` and `j`\nint i = 2, 3;         // Error: `3` is not a declarator\n</code></pre>\n<p>In the second case, it looks ambiguous. Is the <code>,</code> separating declarators, or is the <code>,</code> part of an expression <code>2, 3</code>?</p>\n<p>To resolve this ambiguity we can consult the language grammar (C++14 [dcl.decl]):</p>\n<blockquote>\n<p id=\"so_35207678_35211117_0\"><em>simple-declaration:</em><br>\n  \u00a0\u00a0\u00a0\u00a0<em>decl-specifier-seq<sub>opt</sub> init-declarator-list<sub>opt</sub></em> <code>;</code><br>\n  \u00a0\u00a0\u00a0\u00a0<em>attribute-specifier-seq decl-specifier-seq<sub>opt</sub> init-declarator-list</em> <code>;</code></br></br></p>\n<p id=\"so_35207678_35211117_1\"><em>init-declarator-list:</em><br>\n  \u00a0\u00a0\u00a0\u00a0<em>init-declarator</em><br>\n  \u00a0\u00a0\u00a0\u00a0<em>init-declarator-list</em> <code>,</code> <em>init-declarator</em><br/></br></br></p>\n<p id=\"so_35207678_35211117_2\"><em>init-declarator:</em><br>\n  \u00a0\u00a0\u00a0\u00a0<em>declarator initializer<sub>opt</sub></em></br></p>\n</blockquote>\n<p>The way grammars work, this means that when parsing a declaration the longest possible sequence that matches <em>init-declarator <code>,</code></em> is considered. (This is sometimes called \"maximum munch principle\").   So <code>int i = 2,</code> matches <em>init-declarator <code>,</code></em> . Then <code>3</code> fails to match <code>init-declarator</code>, so parsing fails.</p>\n", "LastActivityDate": "2016-02-04T20:36:26.343", "CommentCount": "0", "CreationDate": "2016-02-04T20:36:26.343", "ParentId": "35207678", "Score": "5", "OwnerUserId": "1505939"}});