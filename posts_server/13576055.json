post_cb({"bq_ids": {"n4140": {"so_13576055_23698999_1": {"length": 12, "quality": 0.7058823529411765, "section_id": 3286}, "so_13576055_23698999_3": {"length": 9, "quality": 1.0, "section_id": 3287}, "so_13576055_23698999_2": {"length": 12, "quality": 0.75, "section_id": 3287}, "so_13576055_23698999_0": {"length": 4, "quality": 1.0, "section_id": 3287}}, "n3337": {"so_13576055_23698999_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 3157}, "so_13576055_23698999_3": {"length": 9, "quality": 1.0, "section_id": 3157}, "so_13576055_23698999_2": {"length": 16, "quality": 1.0, "section_id": 3157}, "so_13576055_23698999_0": {"length": 4, "quality": 1.0, "section_id": 3157}}, "n4659": {"so_13576055_23698999_1": {"length": 11, "quality": 0.6470588235294118, "section_id": 4049}, "so_13576055_23698999_3": {"length": 9, "quality": 1.0, "section_id": 4049}, "so_13576055_23698999_2": {"length": 11, "quality": 0.6875, "section_id": 4049}}}, "23698999": {"Id": "23698999", "PostTypeId": "2", "Body": "<p>The important difference between</p>\n<pre><code>class B {\n    public:\n    B(){}\n    int i;\n    int j;\n};\n</code></pre>\n<p>and</p>\n<pre><code>class B {\n    public:\n    B() = default;\n    int i;\n    int j;\n};\n</code></pre>\n<p>is that default constructor defined with <code>B() = default;</code> is considered <strong>not-user defined</strong>. This means that in case of <em>value-initialization</em> as in</p>\n<pre><code>B* pb = new B();  // use of () triggers value-initialization\n</code></pre>\n<p>special kind of initialization that doesn't use a constructor at all will take place and for built-in types this will result in <em>zero-initialization</em>. In case of <code>B(){}</code> this won't take place. The C++ Standard n3337 <strong>\u00a7</strong> 8.5/7 says</p>\n<blockquote>\n<p id=\"so_13576055_23698999_0\">To value-initialize an object of type T means:</p>\n<p id=\"so_13576055_23698999_1\">\u2014 if T is a (possibly\n  cv-qualified) class type (Clause 9) <strong>with a user-provided constructor</strong>\n  (12.1), then the default constructor for T is called (and the\n  initialization is ill-formed if T has no accessible default\n  constructor); </p>\n<p id=\"so_13576055_23698999_2\">\u2014 if T is a (possibly cv-qualified) non-union class type\n  <strong>without a user-provided constructor</strong>, then the object is\n  zero-initialized and, if T\u2019s implicitly-declared default constructor\n  is non-trivial, that constructor is called.</p>\n<p id=\"so_13576055_23698999_3\">\u2014 if T is an array type,\n  then each element is value-initialized; \u2014 otherwise, the object is\n  zero-initialized.</p>\n</blockquote>\n<p>For example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A {\n    public:\n    A(){}\n    int i;\n    int j;\n};\n\nclass B {\n    public:\n    B() = default;\n    int i;\n    int j;\n};\n\nint main()\n{\n    for( int i = 0; i &lt; 100; ++i) {\n        A* pa = new A();\n        B* pb = new B();\n        std::cout &lt;&lt; pa-&gt;i &lt;&lt; \",\" &lt;&lt; pa-&gt;j &lt;&lt; std::endl;\n        std::cout &lt;&lt; pb-&gt;i &lt;&lt; \",\" &lt;&lt; pb-&gt;j &lt;&lt; std::endl;\n        delete pa;\n        delete pb;\n    }\n  return 0;\n}\n</code></pre>\n<p>possible result:</p>\n<pre><code>0,0\n0,0\n145084416,0\n0,0\n145084432,0\n0,0\n145084416,0\n//...\n</code></pre>\n<p><a href=\"http://ideone.com/k8mBrd\">http://ideone.com/k8mBrd</a></p>\n", "LastEditorUserId": "675100", "LastActivityDate": "2015-05-11T22:37:13.683", "Score": "17", "CreationDate": "2014-05-16T15:22:09.210", "ParentId": "13576055", "CommentCount": "4", "LastEditDate": "2015-05-11T22:37:13.683", "OwnerUserId": "1141471"}, "13578720": {"Id": "13578720", "PostTypeId": "2", "Body": "<p>This is a completely different question when asking about constructors than destructors.</p>\n<p>If your destructor is <code>virtual</code>, then the difference is negligible, <a href=\"https://stackoverflow.com/a/13576544/734069\">as Howard pointed out</a>. However, if your destructor was <em>non-virtual</em>, it's a completely different story. The same is true of constructors.</p>\n<p>Using <code>= default</code> syntax for special member functions (default constructor, copy/move constructors/assignment, destructors etc) means something very different from simply doing <code>{}</code>. With the latter, the function becomes \"user-provided\". And that changes everything.</p>\n<p>This is a trivial class by C++11's definition:</p>\n<pre><code>struct Trivial\n{\n  int foo;\n};\n</code></pre>\n<p>If you attempt to default construct one, the compiler will generate a default constructor automatically. Same goes for copy/movement and destructing. Because the user did not provide any of these member functions, the C++11 specification considers this a \"trivial\" class. It therefore legal to do this, like memcpy their contents around to initialize them and so forth.</p>\n<p>This:</p>\n<pre><code>struct NotTrivial\n{\n  int foo;\n\n  NotTrivial() {}\n};\n</code></pre>\n<p>As the name suggests, this is no longer trivial. It has a default constructor that is user-provided. It doesn't matter if it's empty; as far as the rules of C++11 are concerned, this cannot be a trivial type.</p>\n<p>This:</p>\n<pre><code>struct Trivial2\n{\n  int foo;\n\n  Trivial2() = default;\n};\n</code></pre>\n<p>Again as the name suggests, this is a trivial type. Why? Because you told the compiler to automatically generate the default constructor. The constructor is therefore not \"user-provided.\" And therefore, the type counts as trivial, since it doesn't have a user-provided default constructor.</p>\n<p>The <code>= default</code> syntax is mainly there for doing things like copy constructors/assignment, when you add member functions that prevent the creation of such functions. But it also triggers special behavior from the compiler, so it's useful in default constructors/destructors too.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-05-06T17:24:41.140", "Score": "65", "CreationDate": "2012-11-27T06:40:46.717", "ParentId": "13576055", "CommentCount": "5", "LastEditDate": "2017-05-23T11:54:59.990", "OwnerUserId": "734069"}, "13576544": {"Id": "13576544", "PostTypeId": "2", "Body": "<p>They are both non-trivial.</p>\n<p>They both have the same noexcept specification depending upon the noexcept specification of the bases and members.</p>\n<p>The only difference I'm detecting so far is that if <code>Widget</code> contains a base or member with an inaccessible or deleted destructor:</p>\n<pre><code>struct A\n{\nprivate:\n    ~A();\n};\n\nclass Widget {\n    A a_;\npublic:\n#if 1\n   virtual ~Widget() = default;\n#else\n   virtual ~Widget() {}\n#endif\n};\n</code></pre>\n<p>Then the <code>=default</code> solution will compile, but <code>Widget</code> won't be a destructible type.  I.e. if you try to destruct a <code>Widget</code>, you'll get a compile-time error.  But if you don't, you've got a working program.</p>\n<p>Otoh, if you supply the <em>user-provided</em> destructor, then things won't compile whether or not you destruct a <code>Widget</code>:</p>\n<pre><code>test.cpp:8:7: error: field of type 'A' has private destructor\n    A a_;\n      ^\ntest.cpp:4:5: note: declared private here\n    ~A();\n    ^\n1 error generated.\n</code></pre>\n", "LastEditorUserId": "2642204", "LastActivityDate": "2015-05-11T22:44:27.863", "Score": "32", "CreationDate": "2012-11-27T02:33:09.763", "ParentId": "13576055", "CommentCount": "1", "LastEditDate": "2015-05-11T22:44:27.863", "OwnerUserId": "576911"}, "13576055": {"ViewCount": "10716", "Body": "<p>I originally posted this as a question only about destructors, but now I'm adding consideration of the default constructor.  Here's the original question:</p>\n<blockquote>\n<p id=\"so_13576055_13576055_0\">If I want to give my class a destructor that is virtual, but is\n  otherwise the same as what the compiler would generate, I can use <code>=default</code>:</p>\n<pre><code>class Widget {\npublic:\n   virtual ~Widget() = default;\n};\n</code></pre>\n<p id=\"so_13576055_13576055_1\">But it seems that I can get the same effect with less typing using an\n  empty definition:</p>\n<pre><code>class Widget {\npublic:\n   virtual ~Widget() {}\n};\n</code></pre>\n<p id=\"so_13576055_13576055_2\">Is there any way in which these two definitions behave differently?</p>\n</blockquote>\n<p>Based on the replies posted for this question, the situation for the default constructor seems similar.  Given that there is almost no difference in meaning between \"<code>=default</code>\" and \"<code>{}</code>\" for destructors, is there similarly almost no difference in meaning between these options for default constructors?  That is, assuming I want to create a type where the objects of that type will be both created and destroyed, why would I want to say</p>\n<pre><code>Widget() = default;\n</code></pre>\n<p>instead of</p>\n<pre><code>Widget() {}\n</code></pre>\n<p>?</p>\n<p>I apologize if extending this question after its original posting is violating some SO rules.  Posting an almost-identical question for default constructors struck me as the less desirable option.</p>\n", "AcceptedAnswerId": "13578720", "Title": "How is \"=default\" different from \"{}\" for default constructor and destructor?", "CreationDate": "2012-11-27T01:25:52.080", "Id": "13576055", "CommentCount": "4", "FavoriteCount": "29", "PostTypeId": "1", "LastEditDate": "2012-11-28T08:11:36.393", "LastEditorUserId": "819272", "LastActivityDate": "2016-05-06T17:24:41.140", "Score": "110", "OwnerUserId": "1426649", "Tags": "<c++><c++11><user-defined-functions><default-constructor><deleted-functions>", "AnswerCount": "3"}});