post_cb({"bq_ids": {"n4140": {"so_27208502_27208585_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 6045}, "so_27208502_27208585_1": {"length": 5, "quality": 0.625, "section_id": 7043}, "so_27208502_27208546_2": {"length": 21, "quality": 0.9130434782608695, "section_id": 6045}}, "n3337": {"so_27208502_27208585_1": {"length": 5, "quality": 0.625, "section_id": 6788}, "so_27208502_27208585_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 5813}, "so_27208502_27208546_2": {"length": 21, "quality": 0.9130434782608695, "section_id": 5813}}, "n4659": {"so_27208502_27208585_1": {"length": 5, "quality": 0.625, "section_id": 7612}, "so_27208502_27208585_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 7544}, "so_27208502_27208546_2": {"length": 21, "quality": 0.9130434782608695, "section_id": 7544}}}, "27208546": {"Id": "27208546", "PostTypeId": "2", "Body": "<p>Casting a function pointer to a different type and using it to call a function results in undefined behavior.</p>\n<blockquote>\n<p id=\"so_27208502_27208546_0\">From C11 Standard 6.3.2.3 p8:</p>\n<p id=\"so_27208502_27208546_1\">A pointer to a function of one type may be converted to a pointer to a function of another\n  type and back again; the result shall compare equal to the original pointer. <em>If a converted\n  pointer is used to call a function whose type is not compatible with the referenced type,\n  the behavior is undefined.</em></p>\n</blockquote>\n<p>The rule is the same in C++:</p>\n<blockquote>\n<p id=\"so_27208502_27208546_2\">A function pointer can be explicitly converted to a function pointer of a different type. The effect of calling\n  a function through a pointer to a function type (8.3.5) that is not the same as the type used in the definition\n  of the function is undefined</p>\n</blockquote>\n", "LastEditorUserId": "4082723", "LastActivityDate": "2014-11-30T00:13:36.787", "Score": "4", "CreationDate": "2014-11-29T23:59:36.260", "ParentId": "27208502", "CommentCount": "0", "OwnerUserId": "4082723", "LastEditDate": "2014-11-30T00:13:36.787"}, "27208883": {"Id": "27208883", "PostTypeId": "2", "Body": "<p>I think you get it since in any case function parameters has alignment of 4.</p>\n<p>I tested it in visual studio, and I get the same result. even <code>#pack(1)</code> doesn't affect it.</p>\n<p>I change your functions to print the variable address:</p>\n<pre><code>void p( int x, int y,int a,int b ) {\n    printf( \"x = 0x%p\\ny = 0x%p\\na = 0x%p\\nb = 0x%p\\n\", &amp;x, &amp;y, &amp;a, &amp;b );\n}\n</code></pre>\n<p>I got the following result:</p>\n<pre><code>x = 0x0047F92C\ny = 0x0047F930\na = 0x0047F934\nb = 0x0047F938\n</code></pre>\n<p>As you can see the pointers, as expected, are allign to 4.     </p>\n<p>now I change the function to get chars:</p>\n<pre><code>void p( char x, char y,char a,char b ) {\n    printf( \"x = 0x%p\\ny = 0x%p\\na = 0x%p\\nb = 0x%p\\n\", &amp;x, &amp;y, &amp;a, &amp;b );\n} \n</code></pre>\n<p>and the result is:</p>\n<pre><code>x = 0x0101F750\ny = 0x0101F754\na = 0x0101F758\nb = 0x0101F75C\n</code></pre>\n<p>As you can see it still align to 4!</p>\n<p>I think it should answer your question.</p>\n", "LastActivityDate": "2014-11-30T00:54:07.280", "CommentCount": "7", "CreationDate": "2014-11-30T00:54:07.280", "ParentId": "27208502", "Score": "0", "OwnerUserId": "2852165"}, "27208585": {"Id": "27208585", "PostTypeId": "2", "Body": "<p>Nasal demons galore. \u00a75.2.10 [expr.reinterpret.cast]/p6:</p>\n<blockquote>\n<p id=\"so_27208502_27208585_0\">A function pointer can be explicitly converted to a function pointer\n  of a different type. The effect of calling a function through a\n  pointer to a function type (8.3.5) that is not the same as the type\n  used in the definition of the function is undefined.</p>\n</blockquote>\n<p>Plus, the use of <code>printf</code> is <em>also</em> undefined behavior (WG14 N1570 \u00a77.21.6.1/p9):</p>\n<blockquote>\n<p id=\"so_27208502_27208585_1\">If any argument is not the correct type for the corresponding\n  conversion specification, the behavior is undefined.</p>\n</blockquote>\n<p>How function parameters are passed depends on the calling convention. Common x64 calling conventions,\nfor instance, always pass the first several integer parameters in registers.</p>\n", "LastActivityDate": "2014-11-30T00:06:53.987", "CommentCount": "1", "CreationDate": "2014-11-30T00:06:53.987", "ParentId": "27208502", "Score": "2", "OwnerUserId": "2756719"}, "27208544": {"Id": "27208544", "PostTypeId": "2", "Body": "<p>Your program has undefined behaviour. When you give <code>printf</code> the format specifier <code>%p</code>, the corresponding variable argument must be of type <code>void *</code>, which is not the case in your program.</p>\n", "LastActivityDate": "2014-11-29T23:59:27.373", "CommentCount": "0", "CreationDate": "2014-11-29T23:59:27.373", "ParentId": "27208502", "Score": "1", "OwnerUserId": "596781"}, "27208502": {"ViewCount": "119", "Body": "<p>I just tried:</p>\n<pre><code>void p( int x, int y,int a,int b ) {\n    printf( \"x = 0x%p\\ny = 0x%p\\na = 0x%p\\nb = 0x%p\\n\", x, y, a, b );\n}\n\nint main( ) {\n    ( ( void( *)( char, char, char, char, char, char, char, char ) )&amp;p )\n        ( 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08 );\n}\n</code></pre>\n<p>Which the expected output from this is:</p>\n<pre><code>x = 0x01020304\ny = 0x05060708\na = 0x???????? &lt;-- random hex value\nb = 0x???????? &lt;--\n</code></pre>\n<p>Or if the compiler pushing the arguments in reverse:</p>\n<pre><code>x = 0x????????\ny = 0x????????\na = 0x04030201\nb = 0x08070605\n</code></pre>\n<p>But why the actual output is:</p>\n<pre><code>x = 0x00000001\ny = 0x00000002\na = 0x00000003\nb = 0x00000004\n</code></pre>\n<p>Is there a limitation? Corrent me if I am wrong here: To get value that is not aligned to 4 bytes, you can just do <code>8B 45 01</code> that is <code>mov eax,ebp+01h</code> in assembly; there's no problem; if there's another limitation then what is it?</p>\n", "AcceptedAnswerId": "27208546", "Title": "Why char parameters promoted to int in parameters?", "CreationDate": "2014-11-29T23:55:00.903", "Id": "27208502", "CommentCount": "6", "LastEditDate": "2015-04-17T11:12:13.187", "PostTypeId": "1", "LastEditorUserId": "4082723", "LastActivityDate": "2015-04-17T11:12:13.187", "Score": "-1", "OwnerUserId": "4211034", "Tags": "<c++>", "AnswerCount": "5"}, "27208627": {"Id": "27208627", "PostTypeId": "2", "Body": "<p>This is how the C ABI for your platform is specified- they are often specified as including mechanisms like this to cater for variadic arguments, stack alignment, and other such features.</p>\n<p>If you want to know why the ABI is that way, you'll have to ask a platform-specific question about the ABI specifically.</p>\n<p>Neither the C nor C++ languages have anything to say about this matter whatsoever except that it's totally undefined behaviour. It is totally ABI-specific.</p>\n", "LastActivityDate": "2014-11-30T00:15:23.640", "CommentCount": "0", "CreationDate": "2014-11-30T00:15:23.640", "ParentId": "27208502", "Score": "0", "OwnerUserId": "298661"}});