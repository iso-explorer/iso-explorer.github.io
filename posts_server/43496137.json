post_cb({"43498115": {"ParentId": "43496137", "Score": "2", "CreationDate": "2017-04-19T14:07:53.043", "Id": "43498115", "OwnerUserId": "2069064", "LastActivityDate": "2017-04-19T14:07:53.043", "Body": "<p><code>if constexpr</code> is only for templates. From [stmt.if]:</p>\n<blockquote>\n<p id=\"so_43496137_43498115_0\">If the <code>if</code> statement is of the form <code>if constexpr</code>, the value of the condition shall be a contextually converted constant expression of type <code>bool</code> (5.20); this form is called a <em>constexpr if</em> statement. If the value of\n  the converted condition is <code>false</code>, the first substatement is a <em>discarded statement</em>, otherwise the second substatement, if present, is a discarded statement. <strong>During the instantation of an enclosing templated entity\n  (Clause 14)</strong>, if the condition is not value-dependent after its instantiation, the discarded substatement (if any) is not instantiated.</p>\n</blockquote>\n<p>Within <code>X</code>, the constexpr if statement will prevent the otherwise ill-formed statement from being instantiated. That is the goal of this language feature. But outside of templates, there's no such equivalent gain. </p>\n", "PostTypeId": "2", "CommentCount": "0"}, "43496137": {"Tags": "<c++><c++1z><if-constexpr>", "ViewCount": "353", "LastEditDate": "2017-04-19T14:09:25.540", "CreationDate": "2017-04-19T12:44:24.390", "LastEditorUserId": "2069064", "Title": "if constexpr(condition) as compile-time conditional", "CommentCount": "2", "AcceptedAnswerId": "43498115", "Score": "2", "OwnerUserId": "3359751", "Id": "43496137", "LastActivityDate": "2017-04-19T14:09:25.540", "Body": "<p>I want to use a constexpr bool (<code>useF</code> in the example below) to enable a feature in the following code. Here, calling <code>A::f()</code>. Additionally, I want to be the alias-template (<code>a</code>) to be <code>void</code> in the case I switch off the feature.</p>\n<p>I tried to use a constexpr if statement, but the body is still being instantiated, which causes a compile error. If I use a wrapper template (<code>X</code>), the body is being discarded as I'd expected, but that seems ugly to me. Are there any other ways to do this?</p>\n<pre><code>constexpr bool useF = false;\n\nstruct A {\n    static void f() {}\n};\n\nusing a = std::conditional&lt;useF, A, void&gt;::type;\n\ntemplate&lt;typename L&gt;\nstruct X {\n    static void h() {\n        if constexpr(std::is_same&lt;L, A&gt;::value) {\n            L::f(); // not instantiated, no error\n        }\n    }\n};\n\nint main() {\n    if constexpr(useF) {\n        a::f(); // error!?\n    }\n\n    X&lt;a&gt;::h();\n}\n</code></pre>\n<p>I am using g++-7.0.1 with -std=c++17</p>\n", "PostTypeId": "1", "AnswerCount": "1"}, "bq_ids": {"n4659": {"so_43496137_43498115_0": {"length": 41, "section_id": 4773, "quality": 0.9318181818181818}}}});