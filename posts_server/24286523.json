post_cb({"24287590": {"ParentId": "24286523", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_24286523_24287590_0\">why the first assignment doesn't call template operator= in Foo, but second does? What is going one here?</p>\n</blockquote>\n<p>Apart from the fact explained by William's answer on implicitly generated copy assignment operator function, overload resolution also has a play in this. Below are the candidates for the first assignment operator, after the template argument substitution, as seen by the compiler:</p>\n<pre><code>Foo&amp; operator=(const Foo&amp;);        // implicitly generated\nvoid operator=(const Foo&amp;);        // template generated\n</code></pre>\n<p>All things being equal, nontemplate functions are preferred over function templates. As per C++11 (draft N3337), 13.3.3/1 (emphasis mine)</p>\n<blockquote>\n<p id=\"so_24286523_24287590_1\">Given these definitions, <strong>a viable function F1 is defined to be a better function than another viable function F2 if</strong> for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</p>\n<p id=\"so_24286523_24287590_2\">\u2014 for some argument j, ICSj(F1) is a better conversion sequence than ICSj(F2), or, if not that,</p>\n<p id=\"so_24286523_24287590_3\">\u2014 the context is an initialization by user-defined conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the\n  standard conversion sequence from the return type of F1 to the destination type (i.e., the type of the\n  entity being initialized) is a better conversion sequence than the standard conversion sequence from\n  the return type of F2 to the destination type. [ ... ] or, if not that,</p>\n<p id=\"so_24286523_24287590_4\">\u2014 <strong>F1 is a non-template function and F2 is a function template specialization</strong>, or, if not that,</p>\n<p id=\"so_24286523_24287590_5\">\u2014 F1 and F2 are function template specializations, and the function template for F1 is more specialized\n  than the template for F2 according to the partial ordering rules described in 14.5.6.2.</p>\n</blockquote>\n<p>This explains why the non-template overload is picked. You can verify the same with a small exercise:</p>\n<pre><code>void print(int, int) { std::cout &lt;&lt; \"int\"; }\ntemplate &lt;typename T&gt; void print(T, T) { std::cout &lt;&lt; \"T\"; }\nprint(1, 2); // prints int\nprint&lt;&gt;(1, 2); // prints T\n</code></pre>\n<p>As for the second assignment, it sees</p>\n<pre><code>Foo&amp; operator=(const Foo&amp;);      // implicitly generated\nvoid operator=(const UberFoo&amp;);  // template generated\n</code></pre>\n<p>Here the template generated function is a closer match than the implicitly generated one and thus it was chosen.</p>\n", "OwnerUserId": "183120", "LastEditorUserId": "183120", "LastEditDate": "2014-06-18T15:27:58.183", "Id": "24287590", "Score": "1", "CreationDate": "2014-06-18T13:59:37.667", "LastActivityDate": "2014-06-18T15:27:58.183"}, "24286824": {"ParentId": "24286523", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The compiler is still generating a <em>non-templated</em> <code>operator=</code> which the first assignment binds to. In the second assignment, the templated <code>operator=</code> is a better candidate (because it involves no cast), so that one is picked.</p>\n<p>You can see that by adding the following in your code:</p>\n<pre><code>Foo&amp; operator=(const Foo&amp;) = delete;\n</code></pre>\n<p>Or forcing the proper template call:</p>\n<pre><code>pa.operator=&lt;Foo&gt;(b);\n</code></pre>\n<p><a href=\"https://isocpp.org/files/papers/N3690.pdf\" rel=\"nofollow\">The standard</a> says (emphasis mine):</p>\n<p><strong>12.8 Copying and moving class objects, \u00a712.8/17, page 271:</strong></p>\n<blockquote>\n<p id=\"so_24286523_24286824_0\">A user-declared copy assignment operator X::operator= is a non-static <strong>non-template member function</strong> of class X with exactly one parameter of type X, X&amp;, const X&amp;, volatile X&amp; or const volatile X&amp;</p>\n</blockquote>\n<p>\u00a712.8/18, same page:</p>\n<blockquote>\n<p id=\"so_24286523_24286824_1\">If the class definition does not explicitly declare a copy assignment operator, one is declared <em>implicitly</em>.</p>\n</blockquote>\n", "OwnerUserId": "703016", "LastEditorUserId": "703016", "LastEditDate": "2014-06-18T13:39:42.040", "Id": "24286824", "Score": "5", "CreationDate": "2014-06-18T13:26:40.410", "LastActivityDate": "2014-06-18T13:39:42.040"}, "bq_ids": {"n4140": {"so_24286523_24287590_5": {"section_id": 603, "quality": 0.9333333333333333, "length": 14}, "so_24286523_24286824_0": {"section_id": 466, "quality": 0.9444444444444444, "length": 17}, "so_24286523_24286824_1": {"section_id": 467, "quality": 1.0, "length": 11}, "so_24286523_24287590_1": {"section_id": 603, "quality": 0.85, "length": 17}, "so_24286523_24287590_3": {"section_id": 603, "quality": 0.9259259259259259, "length": 25}, "so_24286523_24287590_4": {"section_id": 111, "quality": 1.0, "length": 5}, "so_24286523_24287590_2": {"section_id": 603, "quality": 0.75, "length": 6}}, "n3337": {"so_24286523_24287590_5": {"section_id": 593, "quality": 0.9333333333333333, "length": 14}, "so_24286523_24286824_0": {"section_id": 457, "quality": 0.9444444444444444, "length": 17}, "so_24286523_24286824_1": {"section_id": 458, "quality": 1.0, "length": 11}, "so_24286523_24287590_1": {"section_id": 593, "quality": 0.85, "length": 17}, "so_24286523_24287590_3": {"section_id": 593, "quality": 0.9259259259259259, "length": 25}, "so_24286523_24287590_4": {"section_id": 106, "quality": 1.0, "length": 5}, "so_24286523_24287590_2": {"section_id": 593, "quality": 0.75, "length": 6}}, "n4659": {"so_24286523_24287590_5": {"section_id": 629, "quality": 0.9333333333333333, "length": 14}, "so_24286523_24286824_0": {"section_id": 489, "quality": 0.9444444444444444, "length": 17}, "so_24286523_24286824_1": {"section_id": 490, "quality": 1.0, "length": 11}, "so_24286523_24287590_2": {"section_id": 629, "quality": 0.75, "length": 6}, "so_24286523_24287590_3": {"section_id": 629, "quality": 0.9259259259259259, "length": 25}, "so_24286523_24287590_4": {"section_id": 115, "quality": 1.0, "length": 5}, "so_24286523_24287590_1": {"section_id": 629, "quality": 0.85, "length": 17}}}, "24286523": {"CommentCount": "2", "ViewCount": "336", "CreationDate": "2014-06-18T13:12:27.120", "LastActivityDate": "2014-06-18T15:27:58.183", "Title": "using template assignment operator", "AcceptedAnswerId": "24286824", "PostTypeId": "1", "Id": "24286523", "Score": "6", "Body": "<p>Having following code, why the first assignment doesn't call template <code>operator=</code> in <code>Foo</code>, but second does? What is going one here? Is there compiler-generated one for the first assignment even if user defined template exists?</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct UberFoo { };\n\nstruct Foo : public UberFoo \n{\n    template&lt;typename T&gt; void operator=(const T&amp; v) { cout &lt;&lt; \"const T&amp;\" &lt;&lt; endl; Set(v); }\n    template&lt;typename T&gt; void operator=(T&amp; v) { cout &lt;&lt; \"T&amp;\" &lt;&lt; endl; return Set(v); }\n\n    virtual void Set(const Foo&amp;) { cout &lt;&lt; \"Foo::Set(const Foo&amp;)\" &lt;&lt; endl; }\n    virtual void Set(const UberFoo&amp;) { cout &lt;&lt; \"Foo::Set(const UberFoo&amp;)\" &lt;&lt; endl; }\n};\n\nstruct Bar : public Foo \n{\n    virtual void Set(const Foo&amp;) { cout &lt;&lt; \"Bar::Set(const Foo&amp;)\" &lt;&lt; endl; }\n    virtual void Set(const UberFoo&amp;) { cout &lt;&lt; \"Bar::Set(const UberFoo&amp;)\" &lt;&lt; endl; }\n};\n\nint main()\n{\n    Bar a, b;\n\n    Foo &amp; pa = a;\n    const Foo&amp; rb = b;\n    const UberFoo &amp; urb = b;\n\n    cout &lt;&lt; \"First\" &lt;&lt; endl;\n\n    pa = rb;\n\n    cout &lt;&lt; endl &lt;&lt; \"Second\" &lt;&lt; endl;\n\n    pa = urb;\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><templates>", "OwnerUserId": "680031", "AnswerCount": "2"}});