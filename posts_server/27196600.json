post_cb({"bq_ids": {"n4140": {"so_27196600_28525629_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 261}}, "n3337": {"so_27196600_28525629_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 252}}, "n4659": {"so_27196600_28525629_0": {"length": 38, "quality": 0.9743589743589743, "section_id": 268}}}, "28525629": {"Id": "28525629", "PostTypeId": "2", "Body": "<p>The following way seems the most proper when dealing with base class members that are not exposed via any mechanism (but must be accessed for some close functionality, and the base class must not be modified):</p>\n<p>Link: <a href=\"http://bloglitb.blogspot.com.au/2010/07/access-to-private-members-thats-easy.html\" rel=\"nofollow\">Access to private member variables</a></p>\n<p>The reasoning behind this idea as to why this works can be found in the <strong>14.7.2p8</strong> of the standard:</p>\n<blockquote>\n<p id=\"so_27196600_28525629_0\">The usual access checking rules do not apply to names used to specify explicit instantiations.\n            In particular, the template  arguments and names used in the function declarator\n            (including parameter  types, return types and exception specifications) may be private types\n            or objects which would normally not be accessible and the template may  be a member template\n            or member function which would not normally be  accessible.]</p>\n</blockquote>\n<p>I took the liberty to outsource this into two macros that may come in handy again one day.</p>\n<p><strong>As with all of these workarounds - use wisely!</strong></p>\n<pre><code>/* The ROB_PRIVATE_MEMBER_INST() macro should be used for explicit instantiation of the template at the appropriate source/compilation unit\n   The ROB_PRIVATE_MEMBER_ACCESS() macro should be used for access to the variable where required\n*/\n#define ROB_PRIVATE_MEMBER_INST(CLASS, TYPE, MEMBER)    \\\ntemplate&lt;typename T&gt;                                    \\\nstruct CLASS##_##MEMBER##_rob_tag {                     \\\n  typedef T CLASS::*type;                               \\\n  friend type get(CLASS##_##MEMBER##_rob_tag);          \\\n};                                                      \\\ntemplate&lt;typename Tag, typename Tag::type M&gt;            \\\nstruct CLASS##_##MEMBER##_rob_private                   \\\n{                                                       \\\n    friend typename Tag::type get(Tag) { return M; }    \\\n};                                                      \\\ntemplate struct CLASS##_##MEMBER##_rob_private&lt;         \\\nCLASS##_##MEMBER##_rob_tag&lt;TYPE&gt; , &amp;CLASS::MEMBER&gt;;     \\\n/**/\n\n#define ROB_PRIVATE_MEMBER_ACCESS(CLASS, INSTANCE, TYPE, MEMBER) \\\n    (INSTANCE.*get(CLASS##_##MEMBER##_rob_tag&lt;TYPE&gt;()))          \\\n/**/\n</code></pre>\n", "LastActivityDate": "2015-02-15T11:36:29.173", "CommentCount": "0", "CreationDate": "2015-02-15T11:36:29.173", "ParentId": "27196600", "Score": "-1", "OwnerUserId": "1641845"}, "27196600": {"ViewCount": "321", "Body": "<p>I am trying to set dependencies in the Boost Unit Testing Framework.\nI have found <a href=\"https://stackoverflow.com/questions/17604111/does-the-boost-testing-framework-support-test-dependencies\">this thread</a> tbat has an example of how to use the test_unit::depends_on() method. So far so good, I can write some magickery around that to smooth it out.\nHowever, the UTF doesn't honor test dependencies during execution.</p>\n<p>Scenario: A BOOST_AUTO_TEST_CASE A is declared before another (B), and A depends_on() B\nExcpected (desired) outcome: The framework detects the dependency and runs B first, and then A if B succeeded.\nActual Outcome: A is skipped because B, which has not run yet, has \"failed\" (i.e. no/false result yet).</p>\n<p>Now, my idea was to do a topological sort on the test cases / suites and then run them in the sorted order.\nFor that, I created a test_tree_visitor to walk the suites and determine the order of the m_members test_suite member.</p>\n<p>However, m_members is protected and not accessible via methods.\nSince I can't change the headers, (would make upgrading to a newer version more difficult, etc, etc), and the BOOST_* macros \"hardcode\" the class as test_suite, I was thinking about the following hackery:</p>\n<pre><code>class member_accessible_test_suite : public test_suite\n{\npublic:\n    const std::vector&lt;test_unit_id&gt; *get_members() const { return &amp;m_members; }\n};\n\nclass dependency_order_visitor : public test_tree_visitor\n{\npublic:\n    virtual void visit( test_case const&amp; tu)\n    {}\n\n    virtual bool test_suite_start( test_suite const&amp; tu)\n    {\n        const member_accessible_test_suite *psuite(reinterpret_cast&lt;const member_accessible_test_suite*&gt;(&amp;tu));\n        const std::vector&lt;test_unit_id&gt; *pmembers(psuite-&gt;get_members());\n        /* do something with pmembers */\n        return true;\n    }\n\n    virtual void test_suite_finish( test_suite const&amp; tu)\n    {}\n\n};\n</code></pre>\n<p>See a <a href=\"http://coliru.stacked-crooked.com/a/8b7a0d4c1ceeb351\" rel=\"nofollow noreferrer\">watered down version</a> on Coliru</p>\n<p>So now to my questions:</p>\n<ol>\n<li><p>The boost libraries are generally well designed - am I making a fundamental mistake due to a misunderstanding about unit testing design by requiring this feature?</p></li>\n<li><p>Since member_accessible_test_suite has no data and adds only functions, is the reinterpret_cast() safe or the fast lane into UB land?\nEither way, I am worried to use such a ghastly hack in production.</p></li>\n<li><p>Is there a better way, and if so, at which point did this turn into an XY problem?</p></li>\n</ol>\n", "AcceptedAnswerId": "28525629", "Title": "Boost Unit Test Framework dependencies execution order", "CreationDate": "2014-11-28T22:18:17.027", "Id": "27196600", "CommentCount": "3", "LastEditDate": "2017-05-23T12:06:50.310", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-02-15T11:36:29.173", "Score": "0", "OwnerUserId": "1641845", "Tags": "<c++><unit-testing><dependencies><reinterpret-cast><boost-test>", "AnswerCount": "1"}});