post_cb({"11472302": {"Id": "11472302", "PostTypeId": "2", "Body": "<p>Your call to <code>UseResource</code> is an initialization of a non-class type (a pointer type), so the following clause applies:</p>\n<blockquote>\n<p id=\"so_11465999_11472302_0\"><a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b11\" rel=\"tag\" title=\"show questions tagged 'c++11'\">c++11</a></p>\n<h3>8.5 Initializers [dcl.init]</h3>\n<p id=\"so_11465999_11472302_1\">15 [...] \u2014 Otherwise, if the source type is a (possibly cv-quali\ufb01ed) class type, conversion functions are considered.\n  The applicable conversion functions are enumerated (13.3.1.5), and the best one is chosen through\n  overload resolution (13.3).</p>\n</blockquote>\n<p>It doesn't matter whether you provide an explicit cast to the parameter type <code>resource_class *</code>; the cast changes the initialization from a <em>copy-initialization</em> to a <em>direct-initialization</em>, but (per 8.5:13) the distinction is irrelevant when the target type is a non-class type.</p>\n<p>We then have two conversion functions with effective argument list <code>(resource_ptr &amp;)</code> and <code>(resource_ptr const &amp;)</code> (for the implicit object parameter) respectively; 13.3.3.2:3 applies for binding the references, so the less cv-qualified reference binding is preferred over the more cv-qualified binding.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2012-07-25T10:47:41.627", "Score": "0", "CreationDate": "2012-07-13T14:17:25.870", "ParentId": "11465999", "CommentCount": "0", "OwnerUserId": "567292", "LastEditDate": "2012-07-25T10:47:41.627"}, "bq_ids": {"n4140": {"so_11465999_11472302_1": {"length": 18, "quality": 0.8181818181818182, "section_id": 3296}}, "n3337": {"so_11465999_11472302_1": {"length": 18, "quality": 0.8181818181818182, "section_id": 3166}}, "n4659": {"so_11465999_11472302_1": {"length": 18, "quality": 0.8181818181818182, "section_id": 4058}}}, "11465999": {"ViewCount": "128", "Body": "<p>During parameter resolution for a function which expects a pointer, why is the the reference-to-pointer conversion being selected rather than the pointer conversion?</p>\n<pre><code>template&lt;typename T&gt;\n  class resource_ptr\n  {\n    public:\n      operator T*()const {...} // &lt;- C1: Convert to raw pointer for observation.\n      operator T*&amp;()     {...} // &lt;- C2: Convert to reference to pointer, for assignment.\n    ...\n  };\n...\nvoid AcquireResource(resource_class *&amp;);  // Assigns to the given pointer.\nvoid UseResource(resource_class *);\n...\nresource_ptr&lt;resource_class&gt; rpResource;\nAcquireResource(rpResource); // &lt;- Calls C2, as expected.\nUseResource(rpResource);     // &lt;- Calls C2.  C1 would have been nice.\n\nUseResource((resource_class*)rpResource); // &lt;- Still calls C2. ???\n</code></pre>\n<p>Note that in this particular design, since C2 is granting write access, it asserts that the resource pointer is currently unassigned, to prevent resource leaks.  So it's important that C2 only get used when we actually want the pointer by reference, as when passing to an API which assigns to it.  As it stands, this design is broken.</p>\n<p>(These conversions can be replaced with explicit functions, but I would like to understand this issue.)</p>\n", "Title": "Precedence between conversion operators in C++", "CreationDate": "2012-07-13T07:29:11.033", "LastActivityDate": "2012-07-25T10:47:41.627", "CommentCount": "2", "PostTypeId": "1", "Id": "11465999", "Score": "3", "OwnerUserId": "1522684", "Tags": "<c++>", "AnswerCount": "2"}, "11466048": {"Id": "11466048", "PostTypeId": "2", "Body": "<p>The <code>const</code> version is used when the object to be converted is const. That works the same  as with ordinary member functions.</p>\n<p>I would go with named conversion functions, to make this easier to read.</p>\n", "LastActivityDate": "2012-07-13T07:33:08.377", "CommentCount": "1", "CreationDate": "2012-07-13T07:33:08.377", "ParentId": "11465999", "Score": "3", "OwnerUserId": "597607"}});