post_cb({"21210969": {"CommentCount": "7", "AcceptedAnswerId": "21211176", "ClosedDate": "2014-01-19T13:09:58.433", "CreationDate": "2014-01-18T22:58:03.993", "LastActivityDate": "2014-01-18T23:22:40.953", "PostTypeId": "1", "ViewCount": "169", "FavoriteCount": "0", "Title": "SFINAE unexpected result", "Id": "21210969", "Score": "2", "Body": "<p>Try to understand SFINAE.</p>\n<pre><code>template &lt;class T, class T1 = void&gt;\nstruct foo\n{\n    static constexpr char* a = \"primary definition\\n\";\n};\n\nstruct A\n{\n};\n\ntemplate &lt;class T&gt;\nstruct foo&lt;T, std::enable_if&lt;std::is_same&lt;T, A&gt;::value&gt;::type&gt;\n{\n    static constexpr char* a = \"secondary definition\\n\";\n};\n</code></pre>\n<p>Compiler gcc-4.8.1 gives an error </p>\n<blockquote>\n<p id=\"so_21210969_21210969_0\">error: type/value mismatch at argument 2 in template parameter list\n  for \u2018template struct foo\u2019  struct foo::value&gt;::type&gt;</p>\n</blockquote>\n", "Tags": "<c++><c++11><sfinae><typetraits>", "OwnerUserId": "3120079", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_21210969_21211176_1": {"section_id": 170, "quality": 0.8421052631578947, "length": 16}}, "n3337": {"so_21210969_21211176_1": {"section_id": 164, "quality": 0.8421052631578947, "length": 16}}, "n4659": {"so_21210969_21211176_1": {"section_id": 175, "quality": 0.9473684210526315, "length": 18}}}, "21211176": {"ParentId": "21210969", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_21210969_21211176_0\"><strong>C++11 Standard: 14.6/3</strong></p>\n<p id=\"so_21210969_21211176_1\">When a <em>qualified-id</em> is intended to refer to a type that is not a member of the current instantiation (14.6.2.1) and its <em>nested-name-specifier</em> refers to a dependent type, it shall be prefixed by the keyword <code>typename</code> forming a <em>typename-specifier</em>.</p>\n</blockquote>\n<p><code>T</code> is a dependent type, so the <code>typename</code> keyword is required:</p>\n<pre><code>struct foo&lt;T, typename std::enable_if&lt;std::is_same&lt;T, A&gt;::value&gt;::type&gt;\n//            ^^^^^^^^\n</code></pre>\n<p>There's also a helper template provided in C++14 that is an alias returning the type:</p>\n<pre><code>struct foo&lt;T, std::enable_if_t&lt;std::is_same&lt;T, A&gt;::value&gt;&gt;\n//            ^^^^^^^^^^^^^^^^\n</code></pre>\n", "OwnerUserId": "701092", "PostTypeId": "2", "Id": "21211176", "Score": "2", "CreationDate": "2014-01-18T23:22:40.953", "LastActivityDate": "2014-01-18T23:22:40.953"}});