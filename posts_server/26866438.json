post_cb({"26866457": {"ParentId": "26866438", "CommentCount": "25", "Body": "<p>Yes, they are both same. <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/basic_string\" rel=\"nofollow\">Default constructor</a> of <code>std::string</code> prepares an empty string same as <code>\"\"</code></p>\n<blockquote>\n<p id=\"so_26866438_26866457_0\">explicit basic_string( const Allocator&amp; alloc = Allocator() );<br>\n  Default constructor. Constructs empty string (zero size and\n  unspecified capacity)\n  <br><br>\n  basic_string( const CharT* s, const Allocator&amp; alloc = Allocator() ); <br>\n  Constructs the string with the contents initialized with a copy of the null-terminated character string pointed to by s. The length of the string is determined by the first null character. The behavior is undefined if s does not point at an array of at least Traits::length(s)+1 elements of CharT.</br></br></br></br></p>\n</blockquote>\n", "OwnerUserId": "2659313", "PostTypeId": "2", "Id": "26866457", "Score": "3", "CreationDate": "2014-11-11T13:52:27.910", "LastActivityDate": "2014-11-11T13:52:27.910"}, "26866438": {"CommentCount": "5", "AcceptedAnswerId": "26866812", "PostTypeId": "1", "LastEditorUserId": "3510483", "CreationDate": "2014-11-11T13:51:26.450", "LastActivityDate": "2014-11-12T02:13:28.613", "LastEditDate": "2014-11-11T14:10:34.257", "ViewCount": "845", "FavoriteCount": "1", "Title": "Is std::string() the same as std::string(\"\")", "Id": "26866438", "Score": "13", "Body": "<p>Suppose I have a function that returns a <code>std::string</code>. Certain circumstances mean that the string is not populated with anything.</p>\n<p>Is returning <code>std::string()</code> exactly equivalent to <code>std::string(\"\")</code>? For example, would <code>c_str()</code> or <code>data()</code> give you the same character sequence? Perhaps the <code>std::string(\"\")</code> invokes a short string optimisation but <code>std::string()</code> does no such thing until some characters are added.</p>\n<p>Does anyone know if the current standard (C++11) says anything definitive?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "3415258", "AnswerCount": "4"}, "26866812": {"ParentId": "26866438", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>If we look at the effects of each constructor in the C++ standard, section \u00a7 21.4.2 [string.cons] :</p>\n<p>For <code>explicit basic_string(const Allocator&amp; a = Allocator())</code> :</p>\n<blockquote id=\"so_26866438_26866812_0\">\n<ul>\n<li><code>data()</code> : a non-null pointer that is copyable and can have 0 added to    it </li>\n<li><code>size()</code> : 0 </li>\n<li><code>capacity()</code> : an unspecified value</li>\n</ul>\n</blockquote>\n<p>For <code>basic_string(const charT* s, const Allocator&amp; a = Allocator())</code> :</p>\n<blockquote id=\"so_26866438_26866812_1\">\n<ul>\n<li><code>data()</code> : points at the first element of an allocated copy of the array whose first element is pointed at by s</li>\n<li><code>size()</code> : <code>traits::length(s)</code> </li>\n<li><code>capacity()</code> : a value at least as large as size()</li>\n</ul>\n</blockquote>\n<hr>\n<p>So strictly speaking, <strong>both constructs are not identical</strong> : in particular, the capacity of the constructed <code>std::string</code> objects <em>might</em> be different.</p>\n<p>In practice, it's unlikely that this possible difference will have any observable effect on your code.</p>\n</hr>", "OwnerUserId": "3510483", "LastEditorUserId": "3510483", "LastEditDate": "2014-11-11T14:22:38.237", "Id": "26866812", "Score": "4", "CreationDate": "2014-11-11T14:10:10.400", "LastActivityDate": "2014-11-11T14:22:38.237"}, "26866989": {"ParentId": "26866438", "CommentCount": "7", "Body": "<p>There's certainly no member function on <code>std::string</code> that would allow you to distinguish between a <code>std::string()</code> and a <code>std::string(\"\")</code>.</p>\n<p>I defer to a philosopher or logician to verify if that satisfies any definition of equality.</p>\n<p>As for the standard itself, it states that <code>std::string()</code> will leave the capacity unspecified but <code>std::string(\"\")</code> will define a capacity of at least zero. So the internal state of the object <em>could</em> be different.</p>\n<p>On my particular STL implementation (MSVC2012), <code>std::string()</code> calls a function called <code>_Tidy</code> whereas <code>std::string(\"\")</code> calls <code>_Tidy</code> and <code>assign</code>. (The base class initialisation is identical). <code>assign</code> is a standard <code>std::string</code> function.</p>\n<p>So could they be different? <strong>Yes</strong>.\nCan you tell if they are different? <strong>No</strong>.</p>\n", "OwnerUserId": "2380830", "PostTypeId": "2", "Id": "26866989", "Score": "5", "CreationDate": "2014-11-11T14:18:51.963", "LastActivityDate": "2014-11-11T14:18:51.963"}, "26878102": {"ParentId": "26866438", "CommentCount": "2", "Body": "<p>The only difference is that  <code>std::string()</code> knows at compile-time that it will produce a zero-length string, while <code>std::string(\"\")</code> has to use <code>strlen</code> or something similar to determine the length of the string it will construct at run-time.  Therefore the default-constructor should be faster.</p>\n", "OwnerUserId": "2103751", "PostTypeId": "2", "Id": "26878102", "Score": "2", "CreationDate": "2014-11-12T02:13:28.613", "LastActivityDate": "2014-11-12T02:13:28.613"}, "bq_ids": {"n4140": {"so_26866438_26866812_0": {"section_id": 1568, "quality": 1.0, "length": 11}, "so_26866438_26866812_1": {"section_id": 1576, "quality": 1.0, "length": 18}}, "n3337": {"so_26866438_26866812_0": {"section_id": 1563, "quality": 1.0, "length": 11}, "so_26866438_26866812_1": {"section_id": 1572, "quality": 1.0, "length": 18}}, "n4659": {"so_26866438_26866812_0": {"section_id": 1717, "quality": 1.0, "length": 11}, "so_26866438_26866812_1": {"section_id": 1729, "quality": 1.0, "length": 18}}}});