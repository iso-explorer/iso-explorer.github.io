post_cb({"bq_ids": {"n4140": {"so_36104071_36104426_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 215}, "so_36104071_36104426_1": {"length": 6, "quality": 1.0, "section_id": 215}, "so_36104071_36104426_2": {"length": 5, "quality": 1.0, "section_id": 215}}, "n3337": {"so_36104071_36104426_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 209}, "so_36104071_36104426_1": {"length": 6, "quality": 1.0, "section_id": 209}, "so_36104071_36104426_2": {"length": 5, "quality": 1.0, "section_id": 209}}, "n4659": {"so_36104071_36104426_2": {"length": 5, "quality": 1.0, "section_id": 223}, "so_36104071_36104426_1": {"length": 6, "quality": 1.0, "section_id": 223}, "so_36104071_36104426_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 223}}}, "36104071": {"ViewCount": "136", "Body": "<p>When trying to get to grips with std::ostream_iterator I have come up with the following code which doesn't compile (under gcc 5.3 or clang 3.6).</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n\nnamespace temp {\nstruct Point {\n    int x;\n};\n}\n\n//namespace temp {\n//namespace std {\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, temp::Point p) {\n    return s &lt;&lt; p.x;\n}\n//}\n\nint main(int argc, char** argv) {\n    temp::Point p{1};\n    std::ostream_iterator{std::cout} = p;\n    //std::cout &lt;&lt; p;\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>When <code>operator&lt;&lt;</code> is in global scope, compilation throws up a host of template instantiation errors.</p>\n<p>However, <code>std::cout &lt;&lt; p</code> works fine. And, if <code>operator&lt;&lt;</code> is declare in <code>namespace temp</code> or <code>namespace std</code>, the code compiles and runs as one would expect.</p>\n<p>My question is why does a global <code>operator&lt;&lt;</code> not work?</p>\n", "AcceptedAnswerId": "36104426", "Title": "Strange function look up", "CreationDate": "2016-03-19T16:17:22.137", "Id": "36104071", "CommentCount": "0", "LastEditDate": "2016-03-19T16:36:30.897", "PostTypeId": "1", "LastEditorUserId": "2069064", "LastActivityDate": "2016-03-19T20:18:19.327", "Score": "2", "OwnerUserId": "5825355", "Tags": "<c++><c++11><operator-overloading>", "AnswerCount": "3"}, "36104151": {"Id": "36104151", "PostTypeId": "2", "Body": "<p>I have no clue what you are trying to do with this line:</p>\n<pre><code>std::ostream_iterator{std::cout} = p;\n</code></pre>\n<p>As to your actual question, you can define the <code>operator&lt;&lt;()</code> at global scope:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iterator&gt;\n\nnamespace temp {\n    struct Point {\n        int x;\n    };\n}\n\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, temp::Point p) {\n    return s &lt;&lt; p.x;\n}\n\nint main(int argc, char** argv) {\n    temp::Point p{1};\n    //std::ostream_iterator{std::cout} = p;\n    std::cout &lt;&lt; p;\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Which compiles and outputs <code>1</code>.</p>\n", "LastActivityDate": "2016-03-19T16:24:59.120", "CommentCount": "0", "CreationDate": "2016-03-19T16:24:59.120", "ParentId": "36104071", "Score": "1", "OwnerUserId": "47453"}, "36104179": {"Id": "36104179", "PostTypeId": "2", "Body": "<p>There are two problems with this line (outside of the fact that it makes no sense):</p>\n<pre><code>std::ostream_iterator{std::cout} = p;\n</code></pre>\n<p>First, <code>std::ostream_iterator</code> is a class template, not a class. So you probably meant:</p>\n<pre><code>std::ostream_iterator&lt;Point&gt;{std::cout} = p;\n</code></pre>\n<p>Now, how does <a href=\"http://en.cppreference.com/w/cpp/iterator/ostream_iterator/operator%3D\" rel=\"nofollow\"><code>ostream_iterator::operator=</code></a> actually work? It does rely on <code>operator&lt;&lt;</code>, but in the context of the definition of that member function of that class template. So the overloads that it will find are those in the scope of <code>ostream_iterator</code>'s <code>operator=</code> (which yours is not) and those that can be found in the associated namespaces of the arguments (which yours is not again). That's why lookup fails. </p>\n<p>If you simply move your <code>operator&lt;&lt;</code> into <code>namespace temp</code>:</p>\n<pre><code>namespace temp {\n    std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, Point p) {\n        return s &lt;&lt; p.x;\n   }\n}\n</code></pre>\n<p>Or as a non-member friend:</p>\n<pre><code>namespace temp {\n    struct Point {\n        int x;\n\n        friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; s, Point p) { ... }\n    };\n}\n</code></pre>\n<p>Then argument-dependent lookup succeeds, and this works:</p>\n<pre><code>std::ostream_iterator&lt;Point&gt;{std::cout} = p;\n</code></pre>\n<p>That said, don't write that code. Use the normal <code>std::cout &lt;&lt; p</code>. </p>\n<hr/>\n<p>Here's another example of the same phenomenon that might be easier to understand.  Let's say we have some function template that just calls another function on its argument:</p>\n<pre><code>template &lt;class T&gt;\nvoid call_f(T val) {\n    f(val);\n}\n</code></pre>\n<p><code>f</code> will be found by lookup from the <strong>point of definition</strong> of <code>call_f</code> or via argument-dependent lookup on <code>val</code>. So if we later do something like:</p>\n<pre><code>namespace N {\n    struct X { };\n}\n\nvoid f(N::X ) { }\n\nint main() {\n    f(N::X{});      // ok\n    call_f(N::X{}); // error: can't find 'f'\n}\n</code></pre>\n<p>That line errors because from the point of definition of <code>call_f</code>, there is no function <code>f()</code> (at all) and there is no function <code>f</code> in <code>namespace N</code> either. But if we move <code>f</code> into that namespace, both versions work fine:</p>\n<pre><code>template &lt;class T&gt;\nvoid call_f(T val) { f(val); }\n\nnamespace N {\n    struct X { };\n    void f(X ) { }\n}\n\nint main() {\n    f(N::X{});      // ok\n    call_f(N::X{}); // now ok too, ADL finds N::f\n}\n</code></pre>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-03-19T16:41:06.913", "Score": "2", "CreationDate": "2016-03-19T16:27:45.037", "ParentId": "36104071", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2016-03-19T16:41:06.913"}, "36104426": {"Id": "36104426", "PostTypeId": "2", "Body": "<p>The behavior that you observe is a peculiarity of <em>Two-Phase Lookup</em> process, which is used when resolving names referred from template definitions, and its interaction with Argument Dependent Lookup (ADL).</p>\n<p>In your case you use <code>operator =</code> from <code>std::ostream_iterator</code>. Names referred from the definition of <code>std::ostream_iterator::operator =</code> will be looked up through two-phase lookup: non-dependent names are looked up at the first phase (from the definition of <code>operator =</code>), while dependent names are looked up from the point of instantiation (your call to <code>operator =</code>).</p>\n<p>Internally, <code>std::ostream_iterator::operator =</code> uses operator <code>&lt;&lt;</code> for the given <code>(stream, value)</code> pair. And since the type of <code>value</code> is dependent on template parameter, this reference to operator <code>&lt;&lt;</code> is treated as a <em>dependent</em> one. Thus, its resolution is postponed to the second phase.</p>\n<p>It is true that the second phase of lookup (performed from the point of instantiation) generally sees more names than the first phase. And you apparently expected your definition of <code>operator &lt;&lt;</code> in global namespace to become visible as well.</p>\n<p>However, it is crucial to note one important detail about the second phase: at the second phase only the <em>associated namespaces</em> (namespaces brought in by ADL) are \"enriched\" with additional names visible at the point of instantiation. But the \"regular\" namespaces (not related to ADL) <em>are not affected by the second phase at all</em>. In the latter namespaces the compiler is still restricted to seeing the same names that were visible at the first phase and nothing else.</p>\n<p>That is exactly what the following passage in the standard says</p>\n<blockquote>\n<p id=\"so_36104071_36104426_0\"><strong>14.6.4 Dependent name resolution [temp.dep.res]</strong> </p>\n<p id=\"so_36104071_36104426_1\"><strong>1</strong> In resolving dependent names, names from the following sources are considered:</p>\n<p id=\"so_36104071_36104426_2\">\u2014\n  Declarations that are visible at the point of definition of the\n  template. </p>\n<p id=\"so_36104071_36104426_3\">\u2014 Declarations from namespaces associated with the types of\n  the function arguments both from the instantiation context (14.6.4.1)\n  and from the definition context.</p>\n</blockquote>\n<p>This explains what happens in your case. Even though you added an extra <code>operator &lt;&lt;</code> to the <em>global</em> namespace, the global namespace is not one of the ADL associated namespaces in this case (only <code>std</code> and <code>temp</code> are). For this reason, the second phase cannot really see your extra <code>&lt;&lt;</code> definition. </p>\n<p>But if you add your definition to one of ADL associated namespaces, the second phase will immediately notice that addition. This is why your code compiles fine if you define your operator in <code>std</code> or <code>temp</code> namespaces. </p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2016-03-19T20:18:19.327", "Score": "2", "CreationDate": "2016-03-19T16:51:20.193", "ParentId": "36104071", "CommentCount": "0", "OwnerUserId": "187690", "LastEditDate": "2016-03-19T20:18:19.327"}});