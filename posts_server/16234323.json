post_cb({"16238053": {"ParentId": "16234323", "CommentCount": "1", "Body": "<p>Answering my own question here: I'm going to bite the bullet and use an intermediate type:</p>\n<pre><code>struct B;\n\nstruct A\n{\n    A(int i) : m_i(i) {}\n    A(const B&amp; a);\n    A(const A&amp; a) : m_i(a.m_i)\n    {\n        std::cout &lt;&lt; \"A(const A&amp;)\" &lt;&lt; std::endl;\n    }\n    int m_i;\n};\nstruct B\n{\n    B(int i) : m_i(i) {}\n    int m_i;\n};\n\nA::A(const B&amp; a) : m_i(a.m_i)\n{\n    std::cout &lt;&lt; \"A(const B&amp;)\" &lt;&lt; std::endl;\n}\n\nB operator+(const A&amp; a0, const A&amp; a1)\n{\n    B b(a0.m_i + a1.m_i);\n    std::cout &lt;&lt; \"A+A\" &lt;&lt; std::endl;\n    return b;\n}\nB operator+(const B&amp; a0, const A&amp; a1)\n{\n    B b(a0.m_i + a1.m_i);\n    std::cout &lt;&lt; \"B+A\" &lt;&lt; std::endl;\n    return b;\n}\nB operator+(const A&amp; a0, const B&amp; a1)\n{\n    B b(a0.m_i + a1.m_i);\n    std::cout &lt;&lt; \"A+B\" &lt;&lt; std::endl;\n    return b;\n}\nB operator+(const B&amp; a0, const B&amp; a1)\n{\n    B b(a0.m_i + a1.m_i);\n    std::cout &lt;&lt; \"B+B\" &lt;&lt; std::endl;\n    return b;\n}\n\nint main()\n{\n    A a(1);\n    A b(2);\n    A c(3);\n    A d = (a+b) + (a + b + c);\n}\n</code></pre>\n<p>Output on GCC 4.2.1:</p>\n<pre><code>A+A\nB+A\nA+A\nB+B\nA(const B&amp;)\n</code></pre>\n<p>And I can do the \"very important thing\" in the A(const B&amp;) constructor.</p>\n", "OwnerUserId": "2020792", "PostTypeId": "2", "Id": "16238053", "Score": "1", "CreationDate": "2013-04-26T13:44:19.437", "LastActivityDate": "2013-04-26T13:44:19.437"}, "16235654": {"ParentId": "16234323", "CommentCount": "2", "Body": "<p>RVO is allowed by the standard, in the following cases ([class.copy]\u00a731, listing only applicable parts):</p>\n<blockquote>\n<ul>\n<li><p id=\"so_16234323_16235654_0\">in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (other\n  than a function or catch-clause parameter) with the same cv-unqualified\n  type as the function return type, the copy/move operation can be\n  omitted by constructing the automatic object directly into the\n  function\u2019s return value</p></li>\n<li><p id=\"so_16234323_16235654_1\">when a temporary class object that has not been bound to a reference (12.2) would be copied/moved to a class object with the same\n  cv-unqualified type, the copy/move operation can be omitted by\n  constructing the temporary object directly into the target of the\n  omitted copy/move</p></li>\n</ul>\n</blockquote>\n<p>In your code:</p>\n<pre><code>A operator+(const A&amp; a1, const A&amp; a2) {\n    A retVal(a1.m_val + a2.m_val);\n    // Do something else important\n    return retVal;\n}\n\n\nA a4 = (a1 + a2) * a3 / a1;\n</code></pre>\n<p>there are two elidable copies involved: copying <code>revVal</code> into temporary object storing return value of <code>operator+</code>, and copying this temporary object into <code>a4</code>.</p>\n<p>I can't see a way to prevent elision of the second copy (the one from return value to <code>a4</code>), but the \"non-volatile\" part of the standard makes me believe this should prevent elision of the first copy:</p>\n<pre><code>A operator+(const A&amp; a1, const A&amp; a2) {\n    A retVal(a1.m_val + a2.m_val);\n    // Do something else important\n    volatile A volRetVal(retVal);\n    return volRetVal;\n}\n</code></pre>\n<p>Of course this means you'll have to define an additional copy constructor for <code>A</code> taking <code>const volatile A&amp;</code>.</p>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "16235654", "Score": "0", "CreationDate": "2013-04-26T11:45:54.087", "LastActivityDate": "2013-04-26T11:45:54.087"}, "16236760": {"ParentId": "16234323", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2013-04-26T12:42:04.123", "Score": "1", "LastEditorUserId": "420683", "LastEditDate": "2013-04-26T13:49:32.280", "Id": "16236760", "OwnerUserId": "420683", "Body": "<p>As Angew pointed out, you can use an intermediate type. Here's an example with some optimizations using the move ctor.</p>\n<pre><code>#include &lt;utility&gt;\n#include &lt;iostream&gt;\n\nstruct B;\n\nstruct A {\n    explicit A(double val) : m_val(val)\n    {\n        std::cout &lt;&lt; \"A(double)\" &lt;&lt; std::endl;\n    }\n    A(A&amp;&amp; p) : m_val(p.m_val)\n    { /* no output */ }\n\n    A(const A&amp; other) : m_val(other.m_val) {\n        // Do something really important here\n        std::cout &lt;&lt; \"A(A const&amp;)\" &lt;&lt; std::endl;\n    }\n    A&amp; operator=(const A&amp; other) {\n        if (&amp;other != this) {\n            m_val = other.m_val;\n            // Do something really important here\n            std::cout &lt;&lt; \"A::operator=(A const&amp;)\" &lt;&lt; std::endl;\n        }\n        return *this;\n    }\n    double m_val;\n\n    A(B&amp;&amp;);\n};\n\nstruct B\n{\n    operator A const&amp;() const\n    {\n        std::cout &lt;&lt; \"B::operator A const&amp;()\" &lt;&lt; std::endl;\n        return a;\n    }\n\nprivate:\n    friend struct A;\n    A a;\n\n    // better: befriend a factory function\n    friend B operator+(const A&amp;, const A&amp;);\n    friend B operator*(const A&amp;, const A&amp;);\n    friend B operator/(const A&amp;, const A&amp;);\n    B(A&amp;&amp; p) : a( std::move(p) )\n    { /* no output */ }\n};\n\nA::A(B&amp;&amp; p) : A( std::move(p.a) )\n{\n    std::cout &lt;&lt; \"A(B&amp;&amp;)\" &lt;&lt; std::endl;\n}\n\nB operator+(const A&amp; a1, const A&amp; a2) {\n    std::cout &lt;&lt; \"A const&amp; + A const&amp;\" &lt;&lt; std::endl;\n    A retVal(a1.m_val + a2.m_val);\n    // Do something else important\n    return std::move(retVal);\n}\n\nB operator*(const A&amp; a1, const A&amp; a2) {\n    std::cout &lt;&lt; \"A const&amp; * A const&amp;\" &lt;&lt; std::endl;\n    A retVal(a1.m_val * a2.m_val);\n    // Do something else important\n    return std::move(retVal);\n}\n\nB operator/(const A&amp; a1, const A&amp; a2) {\n    std::cout &lt;&lt; \"A const&amp; / A const&amp;\" &lt;&lt; std::endl;\n    A retVal(a1.m_val / a2.m_val);\n    // Do something else important\n    return std::move(retVal);\n}\n\nint main()\n{\n    A a1(3), a2(4), a3(5);\n    A a4 = (a1 + a2) * a3 / a1;\n}\n</code></pre>\n<p>IIRC, the temporary returned by, say <code>a1 + a2</code> lasts for the whole copy-initialization (more precisely: for the whole full-expression, and that includes AFAIK the construction of <code>a4</code>).\nThat's the reason why we can return an <code>A const&amp;</code> from within <code>B</code>, even though the <code>B</code> objects are only created as temporaries.\n(If I'm wrong about that, see my previous edits for some other solutions.. :D )</p>\n<p>The essence of this example is the combination of an intermediate type, move ctors and the said return of a reference.</p>\n<p>Output of g++4.6.3 and clang++3.2:</p>\n<pre><code>A(double)             &lt;---- A a1(3);\nA(double)             &lt;---- A a2(4);\nA(double)             &lt;---- A a3(5);\nA const&amp; + A const&amp;   &lt;---- a1 + a2;\nA(double)               &lt;-- A retVal(a1.m_val + a2.m_val);\nB::operator A const&amp;()&lt;---- __temp__ conversion B --&gt; const A&amp;\nA const&amp; * A const&amp;   &lt;---- __temp__ * a3;\nA(double)               &lt;-- A retVal(a1.m_val * a2.m_val);\nB::operator A const&amp;()&lt;---- __temp__ conversion B --&gt; const A&amp;\nA const&amp; / A const&amp;   &lt;---- __temp__ / a1;\nA(double)               &lt;-- A retVal(a1.m_val / a2.m_val);\nA(B&amp;&amp;)                &lt;---- A a4 = __temp__;\n</code></pre>\n<p>Now that the copy and move operations (which are not shown) are split up, I think you can implement your \"something important\" more precisely where it belongs to:</p>\n<ul>\n<li><code>A(double)</code> -- creation of a new <code>A</code> object from numerical values</li>\n<li><code>A(A const&amp;)</code> -- actual copy of an <code>A</code> object; doesn't happen here</li>\n<li><code>A(B&amp;&amp;)</code> -- construction of an <code>A</code> object from an operator result</li>\n<li><code>B(A&amp;&amp;)</code> -- invoked for the return value of an operator</li>\n<li><code>B::operator A const&amp;() const</code> -- invoked to use the return value of an operator</li>\n</ul>\n", "LastActivityDate": "2013-04-26T13:49:32.280"}, "bq_ids": {"n4140": {"so_16234323_16235654_0": {"section_id": 480, "quality": 1.0, "length": 35}, "so_16234323_16235654_1": {"section_id": 480, "quality": 0.9629629629629629, "length": 26}}, "n3337": {"so_16234323_16235654_0": {"section_id": 471, "quality": 1.0, "length": 35}, "so_16234323_16235654_1": {"section_id": 471, "quality": 0.9629629629629629, "length": 26}}, "n4659": {"so_16234323_16235654_0": {"section_id": 502, "quality": 0.8857142857142857, "length": 31}, "so_16234323_16235654_1": {"section_id": 502, "quality": 0.6296296296296297, "length": 17}}}, "16234323": {"CommentCount": "13", "ViewCount": "563", "PostTypeId": "1", "LastEditorUserId": "2020792", "CreationDate": "2013-04-26T10:32:21.363", "LastActivityDate": "2013-04-26T13:49:32.280", "Title": "How can I disable c++ return value optimization for one type only?", "LastEditDate": "2013-04-26T11:21:34.647", "Id": "16234323", "Score": "-1", "Body": "<p>I have come across the situation where I <em>really do</em> need to execute non-trivial code in a copy-constructor/assignment-operator. The correctness of the algorithm depends on it. </p>\n<p>While I could disable return value optimisation with a compiler switch, it seems a waste because it's only the one type I need it disabled for, so why should the performance of the whole application suffer? (Not to mention that my company would not allow me to add the switch, anyway).</p>\n<pre><code>struct A {\n    explicit A(double val) : m_val(val) {}\n\n    A(const A&amp; other) : m_val(other.m_val) {\n        // Do something really important here\n    }\n    A&amp; operator=(const A&amp; other) {\n        if (&amp;other != this) {\n            m_val = other.m_val;\n            // Do something really important here \n        }\n        return *this;\n    }\n    double m_val;\n};\n\nA operator+(const A&amp; a1, const A&amp; a2) {\n    A retVal(a1.m_val + a2.m_val);\n    // Do something else important\n    return retVal;\n}\n// Implement other operators like *,+,-,/ etc.\n</code></pre>\n<p>This class would be used as such:</p>\n<pre><code>A a1(3), a2(4), a3(5);\nA a4 = (a1 + a2) * a3 / a1;\n</code></pre>\n<p>Return value optimisation means that a4 will not be created with the copy constructor, and the  \"really important thing to do\" does not happen!</p>\n<p>I know I could hack in a solution where operator+ returns a different type (B, say) and have an A constructor that takes a B as input. But then the number of operators needed to be implemented explodes:</p>\n<pre><code>B operator+(const A&amp; a1, const A&amp; a2);\nB operator+(const B&amp; a1, const A&amp; a2);\nB operator+(const A&amp; a1, const B&amp; a2);\nB operator+(const B&amp; a1, const B&amp; a2);\n</code></pre>\n<p>There must be a better solution. How can I hack it so that RVO does not happen for my type? I can only change the A class code and the operators. I can't change the calling site code; i.e. I can't do this:</p>\n<pre><code>A a1(3), a2(4), a3(5);\nA a4;\na4 = (a1 + a2) * a3 / a1;\n</code></pre>\n<p>One thing I've considered trying is to try and experiment with C++11 move constructors, but I'm not sure this would work, and I don't like it not being valid in C++03.</p>\n<p>Any ideas?    </p>\n<p>EDIT: Please just accept that this is the only way I can do what I need to do. I cannot just 'change the design'. The calling code is fixed, and I must implement my strategy inside the mathematical operators and copy constructor &amp; assignment operator. The idea is that the intermediate values calculated inside the \"a4 = (a1+a2)*a3/a1\" equation cannot be referenced anywhere else in the program - but a4 can. I know this is vague but you'll just have to live with it.</p>\n", "Tags": "<c++><return-value-optimization><copy-elision>", "OwnerUserId": "2020792", "AnswerCount": "3"}});