post_cb({"17528912": {"ParentId": "17528836", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_17528836_17528912_0\">In both cases Base is never referenced.</p>\n</blockquote>\n<p>And that is precisely the reason why you see nothing being printed to the standard output.</p>\n<p>The definition of a class template's static data member does not get instantiated unless you use that data member; like member functions, the definitions of static data members of a class template are instantiated <em>on demand</em>.</p>\n<p>This is specified in paragraph 14.7.1/1 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_17528836_17528912_1\">[...] The implicit instantiation of a class template specialization causes the implicit\n  instantiation of the declarations, but not of the definitions or default arguments, of the class member functions,\n  member classes, scoped member enumerations, <strong>static data members</strong> and member templates. [...] </p>\n</blockquote>\n<p>Since your client code never refers to <code>Base&lt;&gt;::temp</code>, there is no need to construct and initialize it.</p>\n<hr>\n<p>As a side note, this signature:</p>\n<pre><code>void main()\n</code></pre>\n<p>Is not valid (standard) C++. If you want to write portable code, the return type of <code>main()</code> should always be <code>int</code>.</p>\n</hr>", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-07-08T14:28:39.293", "Id": "17528912", "Score": "6", "CreationDate": "2013-07-08T14:15:00.283", "LastActivityDate": "2013-07-08T14:28:39.293"}, "17528836": {"CommentCount": "2", "AcceptedAnswerId": "17528912", "CreationDate": "2013-07-08T14:11:36.153", "LastActivityDate": "2013-07-08T14:40:27.580", "PostTypeId": "1", "ViewCount": "374", "FavoriteCount": "1", "Title": "C++ static variables of unreferenced class", "Id": "17528836", "Score": "7", "Body": "<p>In the following program \"Here\" is printed:</p>\n<pre><code>#include &lt;iostream&gt;\nclass Base\n{\n  static bool temp;\n  static bool initTemp()\n  {std::cout&lt;&lt;\"Here\\n\";return true;}\n};\n\nbool Base::temp = Base::initTemp();\n\nclass Derived : public Base\n{};\n\nint main() {int a;std::cin&gt;&gt;a;}\n</code></pre>\n<p>In the following program \"Here\" is not printed:</p>\n<pre><code>#include &lt;iostream&gt;\ntemplate &lt;class T&gt;\nclass Base\n{\n  static bool temp;\n  static bool initTemp()\n  {std::cout&lt;&lt;\"Here\\n\";return true;}\n};\n\ntemplate &lt;class T&gt;\nbool Base&lt;T&gt;::temp = Base&lt;T&gt;::initTemp();\n\nclass Derived : public Base&lt;int&gt;\n{};\n\nint main() {int a;std::cin&gt;&gt;a;}\n</code></pre>\n<p>In both cases Base is never referenced. The only difference is that in the second case it is a template class. Can anyone explain to me why this behavior occurs. I am using VS 2012.</p>\n", "Tags": "<c++><templates><static>", "OwnerUserId": "919578", "AnswerCount": "3"}, "17529030": {"ParentId": "17528836", "CommentCount": "3", "Body": "<p>In the first case, you don't instantiate <code>Base</code>, but you do call the static function:</p>\n<pre><code>bool Base::temp = Base::initTemp();\n</code></pre>\n<p>In the second case, you never instantiate the <code>template</code>:</p>\n<pre><code>template &lt;class T&gt;\nbool Base&lt;T&gt;::temp = Base&lt;T&gt;::initTemp();\n</code></pre>\n<p>You can explicitly instantiate the <code>Base</code> class template, as with:</p>\n<pre><code>template class Base&lt;int&gt;;\n</code></pre>\n<p>And then you will see \"Here\" printed.</p>\n", "OwnerUserId": "241536", "PostTypeId": "2", "Id": "17529030", "Score": "2", "CreationDate": "2013-07-08T14:20:38.740", "LastActivityDate": "2013-07-08T14:20:38.740"}, "bq_ids": {"n4140": {"so_17528836_17528912_1": {"section_id": 233, "quality": 0.9629629629629629, "length": 26}}, "n3337": {"so_17528836_17528912_1": {"section_id": 226, "quality": 0.9629629629629629, "length": 26}}, "n4659": {"so_17528836_17528912_1": {"section_id": 243, "quality": 0.9629629629629629, "length": 26}}}, "17528965": {"ParentId": "17528836", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>You cannot create variable of undefined class, which you seem to do with line:</p>\n<pre><code>template &lt;class T&gt;\nbool Base&lt;T&gt;::temp = Base&lt;T&gt;::initTemp();\n</code></pre>\n<p>You cannot allocate variable of undefined type. What you need is write something like:</p>\n<pre><code>Base&lt;int&gt;::temp = value;\n</code></pre>\n<p>of cause there will be different variable allocated for each type provided, so you cannot have common static variable for a template class. You'll have separate variable for each type you instantiate your template instead.</p>\n<p>To downvoters here is complete example:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class T&gt;\nclass X\n{\npublic:\n    static int v;\n};\n\ntemplate&lt;class T&gt;\nint X&lt;T&gt;::v = 0;\n\nint main()\n{\n    X&lt;int&gt;::v = 3;\n    X&lt;char&gt;::v = 2;\n\n    using namespace std;\n    cout &lt;&lt; X&lt;char&gt;::v &lt;&lt; endl &lt;&lt; X&lt;int&gt;::v;\n}\n</code></pre>\n<p>It prints 2 3 which means you cannot have single variable for all classes you'll instantiate your template.</p>\n", "OwnerUserId": "384602", "LastEditorUserId": "384602", "LastEditDate": "2013-07-08T14:27:48.277", "Id": "17528965", "Score": "-3", "CreationDate": "2013-07-08T14:17:24.637", "LastActivityDate": "2013-07-08T14:27:48.277"}});