post_cb({"31624209": {"CommentCount": "0", "CreationDate": "2015-07-25T07:44:35.913", "PostTypeId": "1", "AcceptedAnswerId": "31625178", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-25T12:04:29.057", "LastEditDate": "2017-05-23T10:29:15.467", "ViewCount": "374", "FavoriteCount": "1", "Title": "Template struct with the default template argument is not instantiated", "Id": "31624209", "Score": "4", "Body": "<p>Let's say I have this code</p>\n<pre><code>template&lt;typename T2, typename T = int&gt;\nstruct X\n{\n    static double f;\n};\n\ntemplate&lt;typename T&gt;\ndouble X&lt;T&gt;::f = 14.0;\n</code></pre>\n<p>If I try to compile clang give me the following error </p>\n<blockquote>\n<p id=\"so_31624209_31624209_0\">nested name specifier 'X::' for declaration does not refer into a\n  class, class template or class template partial specialization</p>\n</blockquote>\n<p>and for GCC :</p>\n<blockquote>\n<p id=\"so_31624209_31624209_1\">error: template definition of non-template 'double X::f'</p>\n</blockquote>\n<p>The question is :</p>\n<p>Why the compiler want us to specialize the struct X like that : </p>\n<pre><code>template&lt;typename T2&gt;\nstruct X&lt;T2,int&gt;\n{\n    static double f;\n};\n</code></pre>\n<p>The first declaration has <code>int</code> as a default argument, why the compiler don't choose this declaration ?</p>\n<p>I searched in the <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf\" rel=\"nofollow noreferrer\">standard</a> anchor [temp.spec] but it didn't help. </p>\n<p>I ask this question after answered this <a href=\"https://stackoverflow.com/q/31623570/5076707\">one</a> on SO.</p>\n<p>Thanks for your help !</p>\n", "Tags": "<c++><templates><template-specialization><default-arguments>", "OwnerUserId": "5076707", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31624209_31625178_1": {"section_id": 62, "quality": 1.0, "length": 12}, "so_31624209_31625178_2": {"section_id": 149, "quality": 0.9387755102040817, "length": 46}, "so_31624209_31625178_0": {"section_id": 102, "quality": 0.9714285714285714, "length": 68}, "so_31624209_31624209_0": {"section_id": 126, "quality": 0.6428571428571429, "length": 9}}, "n3337": {"so_31624209_31625178_1": {"section_id": 57, "quality": 1.0, "length": 12}, "so_31624209_31625178_2": {"section_id": 143, "quality": 0.9387755102040817, "length": 46}, "so_31624209_31625178_0": {"section_id": 97, "quality": 0.9714285714285714, "length": 68}, "so_31624209_31624209_0": {"section_id": 120, "quality": 0.6428571428571429, "length": 9}}, "n4659": {"so_31624209_31625178_1": {"section_id": 64, "quality": 1.0, "length": 12}, "so_31624209_31625178_2": {"section_id": 153, "quality": 0.9387755102040817, "length": 46}, "so_31624209_31625178_0": {"section_id": 106, "quality": 0.9714285714285714, "length": 68}, "so_31624209_31624209_0": {"section_id": 131, "quality": 0.6428571428571429, "length": 9}}}, "31625178": {"ParentId": "31624209", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2015-07-25T09:47:11.253", "Score": "8", "LastEditorUserId": "4326278", "LastEditDate": "2015-07-25T12:04:29.057", "Id": "31625178", "OwnerUserId": "4326278", "Body": "<p>\"Why the compiler want us to specialize the struct X like that\" - that's not what the error messages are saying. You don't <em>need</em> to do this, and you really shouldn't do it unless what you want is a partial specialization and a static member defined only for that partial specialization.</p>\n<p>The problem is that <code>template&lt;typename T2, typename T = int&gt; struct X</code> is a class template that has <em>two</em> template parameters. The fact that the second one has a default template argument doesn't change the fact that there are still two parameters. </p>\n<p>So, you need to define your class template member as belonging to a class template with two parameters, like this:</p>\n<pre><code>template&lt;typename T2, typename T&gt;\ndouble X&lt;T2, T&gt;::f = 14.0;\n</code></pre>\n<p>The relevant paragraphs in the standard (N4527, the current draft): </p>\n<p>[14.5.1p3]</p>\n<blockquote>\n<p id=\"so_31624209_31625178_0\">When a member function, a member class, a member enumeration, a static\n  data member or a member template of a class template is defined\n  outside of the class template definition, the member definition is\n  defined as a template definition in which the <em>template-parameters</em> are\n  those of the class template. The names of the template parameters used\n  in the definition of the member may be different from the template\n  parameter names used in the class template definition. The template\n  argument list following the class template name in the member\n  definition shall name the parameters in the same order as the one used\n  in the template parameter list of the member. Each template parameter\n  pack shall be expanded with an ellipsis in the template argument list.</p>\n</blockquote>\n<p>[14.1p9]</p>\n<blockquote>\n<p id=\"so_31624209_31625178_1\">[...] A default <em>template-argument</em> shall not be specified in the\n  <em>template-parameter-lists</em> of the definition of a member of a class\n  template that appears outside of the member\u2019s class. [...]</p>\n</blockquote>\n<hr>\n<p>As specified in the quote above, the actual names of the template parameters (<code>T2</code> and <code>T</code>) don't matter, they can be different from the ones in the class template definition, but they need to be consistent within the definition of the member. That is, you can do this</p>\n<pre><code>template&lt;typename T, typename U&gt;\ndouble X&lt;T, U&gt;::f = 14.0;\n</code></pre>\n<p>and it will still define the member of the correct <code>X</code> class template. However, using the same names can make things easier to understand when reading the code.</p>\n<hr>\n<p>By defining the partial specialization before the definition of <code>f</code> in your original example, <code>template&lt;typename T&gt; double X&lt;T&gt;::f = 14.0;</code> becomes a valid definition of the member <code>f</code> of the partial specialization <code>template&lt;typename T2&gt; struct X&lt;T2,int&gt;</code>, and only of that template (partial specializations are templates themselves). The member <code>f</code> of the primary template <code>template&lt;typename, typename&gt; struct X</code> remains undefined.</p>\n<p>The relevant wording is in [14.5.5.3p1]:</p>\n<blockquote>\n<p id=\"so_31624209_31625178_2\">The template parameter list of a member of a class template partial\n  specialization shall match the template parameter list of the class\n  template partial specialization. The template argument list of a\n  member of a class template partial specialization shall match the\n  template argument list of the class template partial specialization. A\n  class template specialization is a distinct template. The members of\n  the class template partial specialization are unrelated to the members\n  of the primary template. [...]</p>\n</blockquote>\n</hr></hr>", "LastActivityDate": "2015-07-25T12:04:29.057"}});