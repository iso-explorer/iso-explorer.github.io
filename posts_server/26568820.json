post_cb({"26568899": {"ParentId": "26568820", "CommentCount": "4", "Body": "<p>They don't. Your test is flawed.</p>\n<p>The problem is not detected until you actually attempt to instantiate the broken function template.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "26568899", "Score": "2", "CreationDate": "2014-10-26T01:19:12.493", "LastActivityDate": "2014-10-26T01:19:12.493"}, "26568820": {"CommentCount": "7", "CreationDate": "2014-10-26T01:04:22.130", "PostTypeId": "1", "AcceptedAnswerId": "26598013", "LastEditorUserId": "2970186", "LastActivityDate": "2014-10-27T23:32:09.743", "LastEditDate": "2014-10-26T01:31:22.283", "ViewCount": "307", "FavoriteCount": "0", "Title": "Why do templates allow constexpr function members with non-constexpr constructors?", "Id": "26568820", "Score": "2", "Body": "<p>Using C++14. Why will this compile:</p>\n<pre><code>template&lt;unsigned N&gt;\nconstexpr bool foo()\n{\n    std::array&lt;char, N&gt; arr;\n    return true;\n}\n</code></pre>\n<p>but not this?</p>\n<pre><code>constexpr bool foo()\n{\n    std::array&lt;char, 10&gt; arr; // Non-constexpr constructor 'array' cannot be used in a constant expression\n    return true;\n}\n</code></pre>\n", "Tags": "<c++><templates><c++14><constexpr>", "OwnerUserId": "2970186", "AnswerCount": "2"}, "26598013": {"ParentId": "26568820", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>\u00a77.1.5 [dcl.constexpr]/p6:</p>\n<blockquote>\n<p id=\"so_26568820_26598013_0\">If the instantiated template specialization of a <code>constexpr</code> function\n  template or member function of a class template would fail to satisfy\n  the requirements for a <code>constexpr</code> function or <code>constexpr</code>\n  constructor, that specialization is still a <code>constexpr</code> function or\n  <code>constexpr</code> constructor, even though a call to such a function cannot\n  appear in a constant expression. If no specialization of the template\n  would satisfy the requirements for a <code>constexpr</code> function or\n  <code>constexpr</code> constructor when considered as a non-template function or\n  constructor, the template is ill-formed; no diagnostic required.</p>\n</blockquote>\n<p>It is valid for <code>constexpr</code> function templates to have some specializations that do not satisfy the <code>constexpr</code> requirements, and it is valid to use those specializations as long as they are not in a context that requires a constant expression.</p>\n<p>It isn't valid, however, if no specialization of the template could satisfy <code>constexpr</code> requirements. Since in the general case it is impossible to determine whether all possible instantiations of a function template will fail to satisfy the <code>constexpr</code> requirements,the standard doesn't require a diagnostic. Hence, your code is ill-formed with no diagnostic required - the compiler can, but is not required to, report an error.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2014-10-27T23:32:09.743", "Id": "26598013", "Score": "7", "CreationDate": "2014-10-27T22:35:29.430", "LastActivityDate": "2014-10-27T23:32:09.743"}, "bq_ids": {"n4140": {"so_26568820_26598013_0": {"section_id": 5422, "quality": 1.0, "length": 50}}, "n3337": {"so_26568820_26598013_0": {"section_id": 5217, "quality": 0.68, "length": 34}}, "n4659": {"so_26568820_26598013_0": {"section_id": 6844, "quality": 1.0, "length": 50}}}});