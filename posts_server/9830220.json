post_cb({"9830220": {"ViewCount": "3757", "AcceptedAnswerId": "9830400", "Tags": "<c++><try-catch><throw>", "AnswerCount": "4", "OwnerUserId": "1286875", "Body": "<p>I want to throw my own exceptions with the base class <code>Exception</code>. There is a virtual method <code>print</code> which will be overwritten by the subclasses. I only catch the type <code>Exception&amp;</code> and use <code>print</code> to get the specific error. The problem is that once I throw a reference of a subclass it is trated as if it were the base class.</p>\n<p>Here is an example:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Exception\n{\n    public:\n        virtual void print()\n        {\n            cout &lt;&lt; \"Exception\" &lt;&lt; endl;\n        }\n};\n\nclass IllegalArgumentException : public Exception\n{\n    public:\n        virtual void print()\n        {\n            cout &lt;&lt; \"IllegalArgumentException\" &lt;&lt; endl;\n        }\n};\n\nint main(int argc, char **argv)\n{\n    try\n    {\n        IllegalArgumentException i;\n        Exception&amp; ref = i;\n\n        cout &lt;&lt; \"ref.print: \";\n        ref.print();\n\n        throw ref;\n    }\n    catch(Exception&amp; e)\n    {\n        cout &lt;&lt; \"catched: \";\n        e.print();\n    }\n}\n</code></pre>\n<p>The output of this example is:</p>\n<pre><code>ref.print: IllegalArgumentException\ncatched: Exception\n</code></pre>\n<p>Using a reference should result in the <code>print</code> method from the derived class being used. Inside the try block the reference does use it. Why doesn't the catched <code>Exception&amp;</code> act like an <code>IllegalArgumentException</code> and how can I get that behavior?</p>\n<p>The following code seems to do what it is supposed to:</p>\n<pre><code>try\n{\n    IllegalArgumentException i;\n    Exception* pointer = &amp;i;\n\n    throw pointer;\n}\ncatch(Exception* e)\n{\n    cout &lt;&lt; \"pointer catched: \";\n    e-&gt;print();\n}\n</code></pre>\n<p>but doesn't the pointer become possibly invalid outside the scope of the try block? It would then be risky to do this and if I allocate memory on the heap to get around that problem I have the responsibility for the deletion inside the catch block which isn't pretty either. So how would you solve the problem?</p>\n", "CommentCount": "3", "PostTypeId": "1", "CreationDate": "2012-03-22T20:44:51.030", "FavoriteCount": "1", "LastActivityDate": "2016-06-18T07:54:20.003", "Id": "9830220", "LastEditorUserId": "1286875", "Title": "C++: Throwing a derived class by reference does not work when catching base class", "Score": "10", "LastEditDate": "2012-03-22T21:17:26.370"}, "18677252": {"LastActivityDate": "2013-09-07T19:48:33.840", "ParentId": "9830220", "Id": "18677252", "Score": "0", "Body": "<p>You can use a pointer instead of reference to avoid slicing:  </p>\n<pre><code>int main(int argc, char **argv)\n{\n    try\n    {\n        IllegalArgumentException* pIAE = new IllegalArgumentException();\n        throw pIAE;\n    }\n    catch(IllegalArgumentException* i)\n        {\n            i-&gt;print();\n    }\n}\n</code></pre>\n<p>The caught pointer points to the same object, because the copy constructor is not called implicitly.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "1080529", "CreationDate": "2013-09-07T19:48:33.840"}, "bq_ids": {"n3337": {"so_9830220_9830400_0": {"section_id": 3206, "quality": 0.9545454545454546, "length": 63}}}, "9830400": {"LastActivityDate": "2012-03-22T20:57:28.280", "ParentId": "9830220", "Id": "9830400", "Score": "6", "Body": "<p><code>throw</code> implicitly copies, and consequently slices. Quoting C++11, \u00a715.1/3:</p>\n<blockquote>\n<p id=\"so_9830220_9830400_0\">A <em>throw-expression</em> initializes a temporary object, called the <em>exception object</em>, the type of which is determined by removing any top-level <em>cv-qualifiers</em> from the static type of the operand of throw and adjusting the type from \u201carray of <code>T</code>\u201d or \u201cfunction returning <code>T</code>\u201d to \u201cpointer to <code>T</code>\u201d or \u201cpointer to function returning <code>T</code>\u201d, respectively. The temporary is an lvalue and is used to initialize the variable named in the matching <em>handler</em>. If the type of the exception object would be an incomplete type or a pointer to an incomplete type other than (possibly cv-qualified) <code>void</code> the program is ill-formed. Except for these restrictions and the restrictions on type matching mentioned in 15.3, the operand of <code>throw</code> is treated exactly as a function argument in a call or the operand of a return statement.</p>\n</blockquote>\n<p>I've seen a handful of codebases that work around this by throwing pointers to exceptions rather than objects directly, but personally I'd just reconsider your \"need\" to do this in the first place.</p>\n", "CommentCount": "11", "PostTypeId": "2", "OwnerUserId": "636019", "CreationDate": "2012-03-22T20:57:28.280"}, "9830748": {"LastActivityDate": "2016-02-07T23:25:21.570", "LastEditorUserId": "365496", "ParentId": "9830220", "LastEditDate": "2016-02-07T23:25:21.570", "Id": "9830748", "Score": "0", "Body": "<p>When you throw an object a copy of that object is made to some other location so stack unwinding can proceed and the copy can be passed to the exception handler (either by reference so no further copies are made, or by value creating a second copy).</p>\n<p>You can verify that a copy is made if you make your exception non-copyable. You will no longer be able to throw objects of that type.</p>\n<p>When the implementation copies the object you throw, it looks at the <em>static</em> type of the expression, not the dynamic type. This means that in your code, it sees you're throwing an <code>Exception</code>, and so the resulting copy is an example of <em>slicing</em> (i.e. instead of copying the complete object, only a base class sub-object is copied).</p>\n<p>You can avoid the slicing if you ensure that the static type of the throw expression matches the type of the complete object, which you can do by simply not forcing the type to <code>Exception</code>.</p>\n<p>This should print \"caught: IllegalArgumentException\".</p>\n<pre><code>try\n{\n    IllegalArgumentException i;\n\n    throw i;\n}\ncatch(Exception&amp; e)\n{\n    cout &lt;&lt; \"caught: \";\n    e.print();\n}\n</code></pre>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "365496", "CreationDate": "2012-03-22T21:22:06.553"}, "9830423": {"LastActivityDate": "2016-06-18T07:54:20.003", "LastEditorUserId": "1779477", "ParentId": "9830220", "LastEditDate": "2016-06-18T07:54:20.003", "Id": "9830423", "Score": "1", "Body": "<p>What you see is called slicing.</p>\n<p>You are apparently used to polymorphism, where you can assign a pointer to a subclass to a pointer to a base class, and you retain the (sub)type and all data.  After all, it's been just a pointer being copied, not the object itself.  However, nothing like this can happen when the assignment is directly between the objects themselves; the base class typically has shorter instances, and there may be no available room (in your case, on the stack; in somebody else's case, on the heap) following the variable of the base class type.</p>\n<p>So, C++ is defined to perform slicing on the object.  Only the base class part is copied, and the type is \"downgraded\" to the base class as well.</p>\n", "CommentCount": "0", "PostTypeId": "2", "OwnerUserId": "1235565", "CreationDate": "2012-03-22T20:59:18.453"}});