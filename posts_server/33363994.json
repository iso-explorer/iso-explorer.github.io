post_cb({"33363994": {"ViewCount": "238", "Body": "<p>Can anyone please explain, why </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\nusing namespace std;\nenum E : signed int { a=-1, b = 1,};\nint main() {\n    std::cout &lt;&lt; std::boolalpha;\n    cout &lt;&lt; \"strong typed enum E:int should be signed, but is_signed returns \" \n    &lt;&lt; is_signed&lt;E&gt;() &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>\n<p>std::is_signed&lt;&gt; does not do, what it says on the tin?\nThanks...</p>\n", "AcceptedAnswerId": "33364183", "Title": "std::is_signed does not work for strongly typed enums : int", "CreationDate": "2015-10-27T09:22:20.790", "Id": "33363994", "CommentCount": "3", "LastEditDate": "2015-10-27T17:11:18.937", "PostTypeId": "1", "LastEditorUserId": "560648", "LastActivityDate": "2015-10-28T00:08:15.907", "Score": "5", "OwnerUserId": "4003134", "Tags": "<c++><c++11><enums>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_33363994_33364183_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 44}, "so_33363994_33364183_1": {"length": 7, "quality": 1.0, "section_id": 7217}}, "n3337": {"so_33363994_33364183_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 41}, "so_33363994_33364183_1": {"length": 7, "quality": 1.0, "section_id": 6961}}, "n4659": {"so_33363994_33364183_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 45}, "so_33363994_33364183_1": {"length": 7, "quality": 1.0, "section_id": 8726}}}, "33365073": {"Id": "33365073", "PostTypeId": "2", "Body": "<p>For the record, to know whether the <em>underlying type</em> of a strongly typed enum (that is, not the enum itself, which <a href=\"https://stackoverflow.com/a/33364183/3953764\">can't be</a> checked for signedness) is signed or not, you can query <a href=\"http://en.cppreference.com/w/cpp/types/underlying_type\" rel=\"nofollow noreferrer\"><code>std::underlying_type&lt;E&gt;::type</code></a>:</p>\n<pre><code>std::is_signed&lt;std::underlying_type&lt;E&gt;::type&gt;::value\n</code></pre>\n<p>or define your own trait:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;typename T&gt;\nstruct identity { using type = T; };\n\ntemplate &lt;typename T&gt;\nstruct is_signed\n    : std::is_signed&lt;typename std::conditional&lt;std::is_enum&lt;T&gt;::value\n                                             , std::underlying_type&lt;T&gt;\n                                             , identity&lt;T&gt;&gt;::type::type&gt; {};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/e4b22ec5e44addc1\" rel=\"nofollow noreferrer\"><strong>DEMO</strong></a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-27T15:14:25.930", "Score": "2", "CreationDate": "2015-10-27T10:11:29.857", "ParentId": "33363994", "CommentCount": "7", "OwnerUserId": "3953764", "LastEditDate": "2017-05-23T11:58:52.967"}, "33364183": {"Id": "33364183", "PostTypeId": "2", "Body": "<p>If we look at the documentation for <a href=\"http://en.cppreference.com/w/cpp/types/is_signed\" rel=\"nofollow\">is_signed</a> it says:</p>\n<blockquote>\n<p id=\"so_33363994_33364183_0\">If <strong>T is a signed arithmetic type</strong>, provides the member constant value equal true. For any other type, value is false. </p>\n</blockquote>\n<p>and an enum is not an arithmetic type so the result should be false. From the draft C++11 standard section <code>3.9.1</code> Fundamental types [basic.fundamental]:</p>\n<blockquote>\n<p id=\"so_33363994_33364183_1\">[...]Integral and floating types are collectively called arithmetic\n  types[...]</p>\n</blockquote>\n<p>You can get the underlying type for an enum using <a href=\"http://en.cppreference.com/w/cpp/types/underlying_type\" rel=\"nofollow\">std::underlying_type</a> and then apply <code>std::is_signed</code> to that type.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-10-28T00:08:15.907", "Score": "6", "CreationDate": "2015-10-27T09:30:47.473", "ParentId": "33363994", "CommentCount": "4", "OwnerUserId": "1708801", "LastEditDate": "2015-10-28T00:08:15.907"}});