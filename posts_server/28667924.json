post_cb({"28701901": {"Id": "28701901", "PostTypeId": "2", "Body": "<p>Short circuit is not supposed to compile <code>true || (whatever_ill_formed)</code>. <code>isFinite&lt;Foo&gt;</code> is instantiated as part of expression and during instantiation it should be compiled and during compilation it should static assert. After that the compiler may never evaluate <code>isFinite&lt;Foo&gt;(f)</code> because of short circuit but static assert is not supposed to happen during it.</p>\n<p>It is unclear why Visual Studio 2013 compiles Program B. Standard only allows bypassing syntax checking of templates when template is never instantiated. Even then the code is still ill formed only diagnostics are not required. Behind the defect is perhaps the same internal issue in Visual C++ that does not let Microsoft to implement <code>constexpr</code>.</p>\n<p><strong>Edit</strong> I add some language lawyer texts from standard per @zneak request</p>\n<p>3.2/3 </p>\n<blockquote>\n<p id=\"so_28667924_28701901_0\">A function whose name appears as a potentially-evaluated expression is\n  odr-used if it is the unique lookup result or the selected member of a\n  set of overloaded functions (3.4, 13.3, 13.4), unless it is a pure\n  virtual function and its name is not explicitly qualified. [Note: This\n  covers calls to named functions (5.2.2), operator overloading (Clause\n  13), user-defined conversions (12.3.2), allocation function for\n  placement new (5.3.4), as well as non-default initialization (8.5). A\n  constructor selected to copy or move an object of class type is\n  odr-used even if the call is actually elided by the implementation\n  (12.8). \u2014end note]</p>\n</blockquote>\n<p>5.13/1 </p>\n<blockquote>\n<p id=\"so_28667924_28701901_1\">The || operator groups left-to-right. The operands are both\n  contextually converted to bool (Clause 4). It returns true if either\n  of its operands is true, and false otherwise. Unlike |, || guarantees\n  left-to-right evaluation; moreover, the second operand is not\n  evaluated if the first operand evaluates to true.</p>\n</blockquote>\n<p>7.1/4 </p>\n<blockquote>\n<p id=\"so_28667924_28701901_2\">In a static_assert-declaration the constant-expression shall be a\n  constant expression (5.19) that can be contextually converted to bool\n  (Clause 4). If the value of the expression when so converted is true,\n  the declaration has no effect. Otherwise, the program is ill-formed,\n  and the resulting diagnostic message (1.4) shall include the text of\n  the string-literal, except that characters not in the basic source\n  character set (2.3) are not required to appear in the diagnostic\n  message.</p>\n</blockquote>\n<p>14.7.1/3 </p>\n<blockquote>\n<p id=\"so_28667924_28701901_3\">Unless a function template specialization has been explicitly\n  instantiated or explicitly specialized, the function template\n  specialization is implicitly instantiated when the specialization is\n  referenced in a context that requires a function definition to exist.</p>\n</blockquote>\n", "LastEditorUserId": "528720", "LastActivityDate": "2015-02-24T20:20:06.147", "Score": "5", "CreationDate": "2015-02-24T17:05:57.833", "ParentId": "28667924", "CommentCount": "2", "OwnerUserId": "528720", "LastEditDate": "2015-02-24T20:20:06.147"}, "bq_ids": {"n4140": {"so_28667924_28701901_2": {"length": 34, "quality": 0.9714285714285714, "section_id": 5382}, "so_28667924_28701901_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 6165}, "so_28667924_28701901_0": {"length": 51, "quality": 0.8360655737704918, "section_id": 7040}, "so_28667924_28701901_3": {"length": 21, "quality": 0.9545454545454546, "section_id": 235}}, "n3337": {"so_28667924_28701901_2": {"length": 34, "quality": 0.9714285714285714, "section_id": 5176}, "so_28667924_28701901_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 5926}, "so_28667924_28701901_0": {"length": 41, "quality": 0.6721311475409836, "section_id": 6785}, "so_28667924_28701901_3": {"length": 21, "quality": 0.9545454545454546, "section_id": 228}}, "n4659": {"so_28667924_28701901_2": {"length": 30, "quality": 0.8571428571428571, "section_id": 6806}, "so_28667924_28701901_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 7662}, "so_28667924_28701901_0": {"length": 49, "quality": 0.8032786885245902, "section_id": 8537}, "so_28667924_28701901_3": {"length": 21, "quality": 0.9545454545454546, "section_id": 245}}}, "28667924": {"ViewCount": "626", "Body": "<p><strong>Program A</strong> produces a compilation error (<strong>as expected</strong>) since <code>isFinite</code> is called with a non-integral type.</p>\n<h2>Program A</h2>\n<pre><code>#include &lt;iostream&gt;\n\nclass Foo {};\n\ntemplate&lt;typename T&gt;\nbool isFinite(const T&amp; t)\n{\n    static_assert(std::is_integral&lt;T&gt;::value, \"Called isFinite with a non-integral type\");\n    return false;\n}\n\nint main()\n{\n    Foo f;\n    std::cout &lt;&lt; \"Foo is finite? \" &lt;&lt; ((isFinite(f)) ? \"yes\" : \"no\") &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre>\n<p>However, a slight modification (see <strong>Program B</strong>) allows the program to compile (Visual Studio 2013) and produce the following output.</p>\n<h2>Program B Visual Studio 2013 Ouput</h2>\n<p><code>Foo is finite? yes</code></p>\n<h2>Program B</h2>\n<pre><code>#include &lt;iostream&gt;\n\nclass Foo {};\n\ntemplate&lt;typename T&gt;\nbool isFinite(const T&amp; t)\n{\n    static_assert(std::is_integral&lt;T&gt;::value, \"Called isFinite with a non-integral type\");\n    return false;\n}\n\nint main()\n{\n    Foo f;\n    std::cout &lt;&lt; \"Foo is finite? \" &lt;&lt; ((true || isFinite(f)) ? \"yes\" : \"no\") &lt;&lt; \"\\n\";\n\n    return 0;\n}\n</code></pre>\n<p>It appears that <strong>Program B</strong> is short circuiting on the logical OR operation and not attempting to compile the rest of the expression. <strong>However</strong>, this application does not compile using g++ 4.8.3 (<code>g++ -std=c++11 -o main main.cpp</code>). I get the following output.</p>\n<pre><code>main.cpp: In instantiation of 'bool isFinite(const T&amp;) [with T = Foo]':\nmain.cpp:15:56:   required from here\nmain.cpp:8:2: error: static assertion failed: Called isFinite with a non-integral type\n  static_assert(std::is_integral&lt;T&gt;::value, \"Called isFinite with a non-integral type\");\n  ^\n</code></pre>\n<p>My intuition leads me to believe that the compilation failure is the correct behavior <strong>but it is curious that Visual Studio 2013 compiles successfully</strong>. My intuition is based on the fact that it is expected that the following code cannot be compiled.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Foo\n{\n    void doOperation1() {}\n    void doOperation2() {}\n};\n\nstruct Bar\n{\n    void doOperationA() {}\n    void doOperation2() {}\n};\n\ntemplate&lt;typename T&gt;\nvoid performOperation(T&amp; t, bool value)\n{\n    if (value)\n    {\n        t.doOperation1();\n    }\n    else\n    {\n        t.doOperation2();\n    }\n}\n\nint main()\n{\n    Foo f;\n    performOperation(f, true);\n    performOperation(f, false);\n\n    Bar b;\n    performOperation(b, false); // Fails to compile (as expected)\n\n    return 0;\n}\n</code></pre>\n<h2>Restated Question</h2>\n<p>Are the logical operators supposed to adhere to short circuit evaluation rules <strong>at compile time</strong> (i.e., what is the expected compilation behavior of <strong>Program B</strong>)?</p>\n", "AcceptedAnswerId": "28701901", "Title": "Are short circuit evaluation rules expected at compile time?", "CreationDate": "2015-02-23T06:21:08.643", "Id": "28667924", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-02-23T07:14:50.683", "LastEditorUserId": "4505712", "LastActivityDate": "2015-02-24T20:20:06.147", "Score": "12", "OwnerUserId": "4505712", "Tags": "<c++><templates><c++11>", "AnswerCount": "1"}});