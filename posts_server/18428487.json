post_cb({"bq_ids": {"n4140": {"so_18428487_18428874_4": {"length": 23, "quality": 0.9583333333333334, "section_id": 767}, "so_18428487_18428874_2": {"length": 17, "quality": 1.0, "section_id": 761}, "so_18428487_18428874_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 766}, "so_18428487_18428874_1": {"length": 15, "quality": 0.9375, "section_id": 745}, "so_18428487_18428874_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 713}}, "n3337": {"so_18428487_18428874_4": {"length": 23, "quality": 0.9583333333333334, "section_id": 754}, "so_18428487_18428874_2": {"length": 17, "quality": 1.0, "section_id": 748}, "so_18428487_18428874_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 753}, "so_18428487_18428874_1": {"length": 15, "quality": 0.9375, "section_id": 734}, "so_18428487_18428874_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 702}}, "n4659": {"so_18428487_18428874_4": {"length": 23, "quality": 0.9583333333333334, "section_id": 827}, "so_18428487_18428874_2": {"length": 17, "quality": 1.0, "section_id": 821}, "so_18428487_18428874_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 826}, "so_18428487_18428874_1": {"length": 15, "quality": 0.9375, "section_id": 803}, "so_18428487_18428874_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 742}}}, "18428874": {"Id": "18428874", "PostTypeId": "2", "Body": "<p>The first question is simple: in general, there is no direct way to get an iterator from a pointer to an element or from a value. That is, to get an iterator from a value you generally need to search the container. Since <code>std::vector&lt;T&gt;</code> is required to be contiguous you can get an iterator from a pointer using a simple computation (which requires that <code>v</code> is non-empty):</p>\n<pre><code>std::vector&lt;T&gt; v(...);\nT* ptr = ...;\nstd::vector&lt;T&gt;::iterator it(v.begin() + (ptr - &amp;v[0]));\n</code></pre>\n<p>To track down whether iterators and values stay stable, isn't entirely trivial as the relevant guarantees are distributed over multiple clauses, e.g.:</p>\n<ol>\n<li><p>23.2.1 [container.requirements.general] paragraph 11:</p>\n<blockquote>\n<p id=\"so_18428487_18428874_0\">Unless otherwise specified (either explicitly or by defining a function in terms of other functions), invoking a container member function or passing a container as an argument to a library function shall not invalidate iterators to, or change the values of, objects within that container.</p>\n</blockquote></li>\n<li><p>23.2.4 [associative.reqmts] paragraph 9:</p>\n<blockquote>\n<p id=\"so_18428487_18428874_1\">The insert and emplace members shall not affect the validity of iterators and references to the container, and the erase members shall invalidate only iterators and references to the erased elements.</p>\n</blockquote></li>\n<li><p>23.2.5 [unord.req] paragraph 9:</p>\n<blockquote>\n<p id=\"so_18428487_18428874_2\">... Rehashing invalidates iterators, changes ordering between elements, and changes which buckets elements appear in, but does not invalidate pointers or references to elements. ...</p>\n</blockquote></li>\n<li><p>23.2.5 [unord.req] paragraph 14:</p>\n<blockquote>\n<p id=\"so_18428487_18428874_3\">The insert and emplace members shall not affect the validity of references to container elements, but may invalidate all iterators to the container. ...</p>\n</blockquote></li>\n<li><p>23.2.5 [unord.req] paragraph 15:</p>\n<blockquote>\n<p id=\"so_18428487_18428874_4\">The insert and emplace members shall not affect the validity of iterators if (N+n) &lt; z * B, where N is the number of elements in the container prior to the insert operation, n is the number of elements inserted, B is the container\u2019s bucket count, and z is the container\u2019s maximum load factor.</p>\n</blockquote></li>\n</ol>\n<p>The above clauses should to be the important clauses with respect to iterator validity of the associative containers. The iterator validity in the unordered associative containers entirely depends on whether the container is rehashed. It seems the rehashing can be controlled to avoid it happening by surprise.</p>\n<p>However, the entire idea of the unordered containers is that it is very efficient to locate an object using <code>find()</code>. It should never be necessary to store an iterator to an element because you can find them back. Of course, if you have a <code>std::unordered_multimap&lt;K, V&gt;</code> or a <code>std::unordered_multiset&lt;V&gt;</code> you may need to know which of the equivalent elements you are looking at.</p>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2013-08-25T12:31:15.103", "Score": "2", "CreationDate": "2013-08-25T12:16:54.903", "ParentId": "18428487", "CommentCount": "0", "OwnerUserId": "1120273", "LastEditDate": "2013-08-25T12:31:15.103"}, "18428775": {"Id": "18428775", "PostTypeId": "2", "Body": "<p>Associative containers (<code>set</code>, <code>multi_set</code>, <code>map</code>, <code>multi_map</code>, and their <code>unordered_</code> brethren) do <strong>not</strong> invalidate pointers or references when you add elements to the container;  they can invalidate iterators. In addition, when you remove elements, only iterators, pointers, and references to those elements are invalidated. One consequence of this is that if you take the address of an element, that address remains valid as long as that element remains in the container.</p>\n<p>There is no portable way to directly convert from the address of an element to an iterator that points to that element. If you need to do this you have to search for the element.</p>\n", "LastEditorUserId": "1593860", "LastActivityDate": "2013-08-25T12:11:00.127", "Score": "1", "CreationDate": "2013-08-25T12:04:51.537", "ParentId": "18428487", "CommentCount": "2", "OwnerUserId": "1593860", "LastEditDate": "2013-08-25T12:11:00.127"}, "18428487": {"ViewCount": "201", "Body": "<p><code>std::unordered_map&lt;K,T&gt;</code> offers methods like <code>find</code> which return a <code>std::unordered_map&lt;K,T&gt;::iterator</code>. As far as I know, an iterator remains valid unless rehashing occurrs.</p>\n<p>But my suspicion is that there is no guaranteed way for roundtripping <code>::iterator</code> -&gt; <code>T *</code> -&gt; <code>::iterator</code>, similar to the \"hack\" that is done in the Linux linked list. I think that because the iterator is only required to be dereferenceable via <code>-&gt;second</code>, but I don't see where it is required to have a durable storage type inside the container.</p>\n<p>So, am I right? Am I required to keep the iterator or is <code>T *ptr = &amp;myiterator-&gt;second</code> later back-castable to an iterator pointer whose <code>-&gt;second</code> member's address is <code>ptr</code>?</p>\n<p>This question is naturally also applicable to other container's iterators.</p>\n", "AcceptedAnswerId": "18428874", "Title": "C++: cast from value type pointer to containing iterator", "CreationDate": "2013-08-25T11:25:35.573", "Id": "18428487", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2013-08-25T12:31:15.103", "Score": "2", "OwnerUserId": "1073695", "Tags": "<c++>", "AnswerCount": "2"}});