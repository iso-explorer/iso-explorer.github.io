post_cb({"26668180": {"ParentId": "26666834", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It's implementation-defined behavior according to the C++ standard (draft N3797).</p>\n<p>\u00a7 3.7.4.2/p4</p>\n<blockquote>\n<p id=\"so_26666834_26668180_0\">Indirection through an invalid pointer value and passing an invalid\n  pointer value to a deallocation function have undefined behavior. <strong>Any\n  other use of an invalid pointer value has implementation-defined\n  behavior</strong>.</p>\n</blockquote>\n<p>footnote 38:</p>\n<blockquote>\n<p id=\"so_26666834_26668180_1\">Some implementations might define that copying an invalid pointer\n  value causes a system-generated runtime fault</p>\n</blockquote>\n<p>\u00a7 3.7.4.3/p4</p>\n<blockquote>\n<p id=\"so_26666834_26668180_2\">An implementation may have relaxed pointer safety, in which case the\n  validity of a pointer value does not depend on whether it is a\n  safely-derived pointer value. Alternatively, an implementation may\n  have strict pointer safety, in which case a pointer value referring to\n  an object with dynamic storage duration that is not a safely-derived\n  pointer value is an invalid pointer value unless the referenced\n  complete object has previously been declared reachable (20.7.4) [...] <strong>It is implementation\n  defined whether an implementation has relaxed or strict pointer safety</strong>.</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>So it is safe if the implementation has relaxed pointer safety, and we can use the <code>union</code> trick as shown in the <a href=\"https://stackoverflow.com/a/26666941/2969631\">answer</a> from <a href=\"https://stackoverflow.com/users/3935776/smith-61\">@Smith_61</a> to avoid strict aliasing.</p>\n", "OwnerUserId": "2969631", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:49:39.340", "Id": "26668180", "Score": "0", "CreationDate": "2014-10-31T05:39:13.003", "LastActivityDate": "2014-10-31T05:39:13.003"}, "26666834": {"CommentCount": "3", "ViewCount": "69", "PostTypeId": "1", "LastEditorUserId": "2969631", "CreationDate": "2014-10-31T02:49:34.557", "LastActivityDate": "2014-10-31T05:39:13.003", "Title": "Can we emplace small object on void*?", "AcceptedAnswerId": "26668180", "LastEditDate": "2014-10-31T04:22:19.397", "Id": "26666834", "Score": "0", "Body": "<p>Suppose there's API like below:</p>\n<pre><code>typedef void callback_t(void* data);\n\nvoid addCallback(handle_t h, callback_t callback, void* data);\n</code></pre>\n<p>I'd like to wrap this API to a higher order C++ interface:</p>\n<pre><code>template&lt;class F, bool emplace = IsEmplaceable&lt;F&gt;::value&gt;\nstruct MakeCallback;\n\nclass Handle\n{\n    template&lt;class F&gt;\n    void addCallback(F f)\n    {\n        ::addCallback(_h, MakeCallback&lt;F&gt;::f, MakeCallback&lt;F&gt;::create(f));\n    }\n\n    handle_t _h;\n};\n</code></pre>\n<p>so that the user can pass any callable object (e.g. lambda function).</p>\n<p>I'd like to apply small object optimization to avoid dynamic alloc (e.g. for empty lambdas), the trait <code>IsEmplaceable&lt;F&gt;</code> decides whether <code>F</code> can be emplaced in a <code>void*</code>.</p>\n<p>For <code>F</code> that is not emplaceable, <code>MakeCallback</code> can be implemented like below:</p>\n<pre><code>template&lt;class F&gt;\nstruct MakeCallback&lt;F, false&gt;\n{\n    static void f(void* data)\n    {\n        auto f = static_cast&lt;F*&gt;(data);\n        (*f)(status);\n        delete f;\n    }\n\n    static void* create(F&amp; f)\n    {\n        return new F(std::move(f));\n    }\n};\n</code></pre>\n<p>For <code>F</code> that is emplaceable, how could I properly implement the following?</p>\n<pre><code>template&lt;class F&gt;\nstruct MakeCallback&lt;F, true&gt;\n{\n    static void f(void* data)\n    {\n        // from void* to F\n    }\n\n    static void* create(F&amp; f)\n    {\n        // form F to void*\n    }\n};\n</code></pre>\n<p>More basically, can a <code>void*</code> hold a non-address value if we don't use it as a pointer? will it be UB?</p>\n", "Tags": "<c++><pointers><optimization>", "OwnerUserId": "2969631", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_26666834_26668180_2": {"section_id": 7187, "quality": 0.9433962264150944, "length": 50}, "so_26666834_26668180_0": {"section_id": 7183, "quality": 0.9545454545454546, "length": 21}, "so_26666834_26668180_1": {"section_id": 7183, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_26666834_26668180_2": {"section_id": 6931, "quality": 0.8490566037735849, "length": 45}, "so_26666834_26668180_1": {"section_id": 6927, "quality": 0.5833333333333334, "length": 7}}, "n4659": {"so_26666834_26668180_2": {"section_id": 8695, "quality": 0.9245283018867925, "length": 49}, "so_26666834_26668180_0": {"section_id": 8671, "quality": 0.9090909090909091, "length": 20}, "so_26666834_26668180_1": {"section_id": 8671, "quality": 0.9166666666666666, "length": 11}}}, "26666941": {"ParentId": "26666834", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>A very big warning should be mentioned before even attempting the code shown in this answer. Doing this is most likely very very undefined and not portable behavior. I would highly suggest not doing this as it could very well break a long time into the future and you will have a very hard time finding out why.</p>\n<p>That being said, it appears to work on at least my compiler. Results may vary for other compilers. I use a union to convert between a class instance and a void *, don't know of any other clean way to do this. This should work as long as <code>sizeof( Class ) &lt;= sizeof( void * )</code>, but I make no guarantees on behavior with different compilers or even with the exact same compiler I used on my exact same setup.</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Small {\npublic:\n    int i;\n};\n\nvoid *castToVoid( Small&amp; s ) {\n    union {\n        Small s;\n        void *p;\n    } un;\n    un.s = s;\n    return un.p;\n}\n\nSmall castToSmall( void *p ) {\n    union {\n        Small s;\n        void *p;\n    } un;\n    un.p = p;\n    return un.s;\n}\n\nint main( ) {\n    Small s;\n    s.i = 100;\n\n    void *p = castToVoid( s );\n\n    s.i = 200;\n    cout &lt;&lt; p &lt;&lt; endl; // Prints 0x64\n\n    Small s2 = castToSmall( p );\n    cout &lt;&lt; s2.i &lt;&lt; endl; // Prints 100\n}\n</code></pre>\n<p>or this example for converting to/from a void *</p>\n<pre><code>void *castToVoid( Small&amp; s ) {\n    void **p = reinterpret_cast&lt; void ** &gt;( &amp;s );\n    return *p;\n}\n\nSmall castToSmall( void *p ) {\n    Small *s = reinterpret_cast&lt; Small * &gt;( &amp;p );\n    return *s;\n}\n</code></pre>\n", "OwnerUserId": "3935776", "LastEditorUserId": "3935776", "LastEditDate": "2014-10-31T03:41:58.327", "Id": "26666941", "Score": "0", "CreationDate": "2014-10-31T03:03:20.453", "LastActivityDate": "2014-10-31T03:41:58.327"}});