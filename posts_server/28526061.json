post_cb({"bq_ids": {"n4140": {"so_28526061_28526122_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 7073}}, "n3337": {"so_28526061_28526122_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 6817}}, "n4659": {"so_28526061_28526122_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 8574}}}, "28526076": {"Id": "28526076", "PostTypeId": "2", "Body": "<p>No. It's a template parameter for TP&lt;&gt;, not the outer template function.</p>\n", "LastActivityDate": "2015-02-15T12:34:33.203", "CommentCount": "3", "CreationDate": "2015-02-15T12:34:33.203", "ParentId": "28526061", "Score": "0", "OwnerUserId": "3547110"}, "28526061": {"ViewCount": "109", "Body": "<p>In the code</p>\n<pre><code>template &lt; template&lt;class TTP&gt; class TP &gt; ... // whatever\n</code></pre>\n<p>is <code>TTP</code> usable anywhere at all then? Can't find any reference to what happens with these names in the Standard.</p>\n", "AcceptedAnswerId": "28526122", "Title": "Template template parameter argument names usage", "CreationDate": "2015-02-15T12:31:48.537", "Id": "28526061", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-02-16T18:52:32.667", "Score": "-1", "OwnerUserId": "396583", "Tags": "<c++><template-templates>", "AnswerCount": "3"}, "28526122": {"Id": "28526122", "PostTypeId": "2", "Body": "<p>[basic.scope.temp]/p1:</p>\n<blockquote>\n<p id=\"so_28526061_28526122_0\">The declarative region of the name of a template parameter of a\n  template <em>template-parameter</em> is the smallest <em>template-parameter-list</em>\n  in which the name was introduced.</p>\n</blockquote>\n<p>It can be used inside that list, and that's it. For instance,</p>\n<pre><code>template &lt; template&lt;class T, T t&gt; class TP &gt; class foo {};\n//                           ^  ^-----T's scope ends here\n//                           |\n//                           T can be used here\n\nfoo&lt;std::integral_constant&gt; bar;\n</code></pre>\n", "LastActivityDate": "2015-02-15T12:40:30.900", "CommentCount": "0", "CreationDate": "2015-02-15T12:40:30.900", "ParentId": "28526061", "Score": "2", "OwnerUserId": "2756719"}, "28548278": {"Id": "28548278", "PostTypeId": "2", "Body": "<p>You can access it, you just have to be slightly indirect about it.</p>\n<pre><code>                        /--- don't bother giving this a name.\n                        |\n                        |             Put it here instead ------------------\\                                 |\n                        |                                                   |\n                        V                                                   V\ntemplate&lt;template&lt;typename, typename ...&gt; class container_tmpl, typename value_t&gt;\nvoid foo(container_tmpl&lt;value_t&gt; x) {\n    std:: cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std:: endl;\n}\n</code></pre>\n<p>More precisely, if you have an object of type <code>vector&lt;int&gt;</code> and you pass it to <code>foo</code> above, then <code>foo</code> can access the relevant type parameters:</p>\n<pre><code>vector&lt;int&gt; v;\nbar(v);\n</code></pre>\n<p>When <code>bar(v)</code> is called, then <code>bar</code> \"knows\" the first parameter, which (I think?) is your goal.</p>\n<p>I'm not saying the other answers are incorrect, it's just that you asked slightly the wrong question.</p>\n<p>To understand the answer I've given, it's probably easier to forget about the <code>template</code> line and instead look at:</p>\n<pre><code>/* complex template-template gibberish */\nvoid foo(container_tmpl&lt;value_t&gt; x) {\n</code></pre>\n<p>The type of <code>x</code>, the parameter to <code>foo</code>, is of type <code>container_tmpl&lt;value_t&gt;</code>. Where <code>container_tmpl</code> is something like <code>vector</code> or <code>list</code>, and <code>value_t</code> is something like <code>int</code> or <code>std::string</code>. Once you write this signature, it's obvious that <code>value_t</code> is simple a type (and hence becomes <code>typename value_t</code> in the template introduction) and that <code>container_tmpl</code> is a template taking (at least) one type parameter.</p>\n<p>In this context, <code>value_t</code> and <code>container_tmpl</code> are defined inside <code>bar</code>.</p>\n<p>If you don't understand why I have <code>typename ...</code>, then remember that <code>vector</code> actually takes two type args, not one. Anyway, the basic idea is that you must provide names for these template args <em>outside</em> where you would expect to get them. E.g. if you have a template that takes three arguments, two type parameters and an integer.</p>\n<pre><code>template&lt; template&lt;typename,int,typename&gt; class the_template, typename T1, int I, typename T2&gt;\nvoid foo(the_template&lt;T1,I,T2&gt; x);\n</code></pre>\n", "LastEditorUserId": "146041", "LastActivityDate": "2015-02-16T18:52:32.667", "Score": "0", "CreationDate": "2015-02-16T18:47:17.900", "ParentId": "28526061", "CommentCount": "1", "OwnerUserId": "146041", "LastEditDate": "2015-02-16T18:52:32.667"}});