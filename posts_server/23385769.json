post_cb({"23386002": {"ParentId": "23385769", "CommentCount": "0", "Body": "<p>There are two inter-related issues:</p>\n<p><ul>\n<li>You are not forcing a reload of <code>r-&gt;commands</code> or <code>r-&gt;commands-Yempty()</code>, thus your compiler, diligent as it is in search of the pinnacle of performance, cached the result. Adding some more code might make the compiler remove this optimisation if it cannot prove the caching is still valid.</li>\n<li>You have a data-race, so your program has undefined behavior. (I am assuming <code>doSomething()</code> removes an element and some other thread adds elements.<br/></li></ul></p>\n<blockquote>\n<h3>1.10 Multi-threaded executions and data races \u00a7 21</h3>\n<p id=\"so_23385769_23386002_0\">The execution of a program contains a data race if it contains two conflicting actions in different threads,\n  at least one of which is not atomic, and neither happens before the other. Any such data race results in\n  undefined behavior. [ Note: It can be shown that programs that correctly use mutexes and memory_order_-\n  seq_cst operations to prevent all data races and use no other synchronization operations behave as if the\n  operations executed by their constituent threads were simply interleaved, with each value computation of an\n  object being taken from the last side effect on that object in that interleaving. This is normally referred to as\n  \u201csequential consistency\u201d. However, this applies only to data-race-free programs, and data-race-free programs\n  cannot observe most program transformations that do not change single-threaded program semantics. In\n  fact, most single-threaded program transformations continue to be allowed, since any program that behaves\n  differently as a result must perform an undefined operation. \u2014end note ]\n  22</p></blockquote>\n", "OwnerUserId": "3204551", "PostTypeId": "2", "Id": "23386002", "Score": "0", "CreationDate": "2014-04-30T10:44:29.180", "LastActivityDate": "2014-04-30T10:44:29.180"}, "23385872": {"ParentId": "23385769", "CommentCount": "2", "Body": "<p>When u first run the thread and then fill up the queue, not entering the inner loop is logical, since the <code>test !r-&gt;commands-&gt;empty()</code> is true. After u add the <code>cout</code> statement, it is working because it takes some time to print the output, and meanwhile the other thread fills up the queue. so the condition becomes again true. But this is not good programming to rely on this facts in a multi-threading environment.</p>\n", "OwnerUserId": "1390091", "PostTypeId": "2", "Id": "23385872", "Score": "0", "CreationDate": "2014-04-30T10:37:42.603", "LastActivityDate": "2014-04-30T10:37:42.603"}, "bq_ids": {"n4140": {"so_23385769_23386002_0": {"section_id": 5834, "quality": 0.8865979381443299, "length": 86}}, "n3337": {"so_23385769_23386002_0": {"section_id": 5605, "quality": 0.9072164948453608, "length": 88}}, "n4659": {"so_23385769_23386002_0": {"section_id": 7296, "quality": 0.8865979381443299, "length": 86}}}, "23385769": {"CommentCount": "5", "ViewCount": "149", "CreationDate": "2014-04-30T10:32:54.020", "LastActivityDate": "2014-04-30T10:56:21.577", "Title": "while inside while not working properly in c++", "AcceptedAnswerId": "23385848", "PostTypeId": "1", "Id": "23385769", "Score": "1", "Body": "<p>I have curious situation (at least for me :D ) in C++</p>\n<p>My code is: </p>\n<pre><code>static void startThread(Object* r){\n    while(true)\n    {\n        while(!r-&gt;commands-&gt;empty())\n        {\n            doSomthing();\n        }\n    }\n}\n</code></pre>\n<p>I start this function as thread using boost where commands in r is queue... this queue I fill up in another thread....</p>\n<p>The problem is that if I fill the queue first and then start this tread everything works fine... But if I run the startThread first and after that I fill up queue commands, it is not working... doSomething() will not run...</p>\n<p>Howewer if I modify startThread:</p>\n<pre><code>static void startThread(Object* r){\n    while(true)\n    {\n        std::cout &lt;&lt; \"c\" &lt;&lt; std::endl;\n        while(!r-&gt;commands-&gt;empty())\n        {\n            doSomthing();\n        }\n    }\n}\n</code></pre>\n<p>I just added cout... and it is working... Can anybody explain why it is working with cout and not without? Or anybody has idea what can be wrong?</p>\n<p>Maybe compiler is doing some kind of optimalization? I do not think so... :(\nThanks</p>\n", "Tags": "<c++><multithreading><while-loop>", "OwnerUserId": "2599892", "AnswerCount": "3"}, "23385848": {"ParentId": "23385769", "PostTypeId": "2", "CommentCount": "10", "Body": "<blockquote>\n<p id=\"so_23385769_23385848_0\">But if I run the startThread first and after that I fill up queue commands, it is not working... doSomething() will not run</p>\n</blockquote>\n<p>Of course not! What did you expect? Your queue is empty, so <code>!r-&gt;commands-&gt;empty()</code> will be <code>false</code>.</p>\n<blockquote>\n<p id=\"so_23385769_23385848_1\">I just added cout... and it is working</p>\n</blockquote>\n<p>You got lucky. <code>cout</code> is comparatively slow, so your main thread had a chance to fill the queue before the inner <code>while</code> test was executed for the first time.</p>\n<p>So why does the thread not see an updated version of <code>r-&gt;commands</code> after it has been filled by the main thread? Because nothing in your code indicates that your variable is going to change from the outside, so the compiler assumes that it doesn\u2019t.</p>\n<p>In fact, the compiler sees that your <code>r</code>\u2019s pointee <strong>cannot</strong> change, so it can just remove the redundant checks from the inner loop. When working with multithreaded code, you explicitly need to tell C++ that variables can be changed from a different context, using <a href=\"https://stackoverflow.com/q/12878344/1968\">atomic memory access</a>.</p>\n", "OwnerUserId": "1968", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:20:48.297", "Id": "23385848", "Score": "3", "CreationDate": "2014-04-30T10:36:41.663", "LastActivityDate": "2014-04-30T10:56:21.577"}});