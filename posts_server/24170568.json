post_cb({"24170747": {"ParentId": "24170568", "CommentCount": "7", "Body": "<p><code>inline</code> is easy to explain. <code>inline</code> basically is a hint to the compiler that the given function should be copied (inlined) into any function that calls it, rather than doing a normal function call. For short, simple functions, this eliminates function call overhead.</p>\n<p>The compiler is not required to obey <code>inline</code>: it can choose to generate a normal function if it decides the inlining isn't worth the extra code bulk (which can cause cache misses and increase code size).</p>\n<p><code>inline</code> functions are only available in the source file that declares them. Therefore, <code>inline</code> functions intended for wide reuse are often placed in header files.</p>\n<hr>\n<p><code>static</code> has a bunch of different uses in C++:</p>\n<ul>\n<li>A <code>static</code> class method or member belongs essentially to the class rather than any particular instance of the class, like Java's <code>static</code>. This applies to both static methods and static variables. Note that there is only ever one copy of a static class member, even if you put the declaration in a shared header file; the definition must be in only one file (except for <code>static const</code> members)</li>\n<li>A <code>static</code> global function or variable is accessible only to the compilation unit (source file) in which it is defined. In this way, it is a bit like an inlined function, and compilers may choose to inline a static function. Static functions that are meant to be shared are also placed in header files.</li>\n<li>A <code>static</code> local variable inside a function is a variable which exists across all invocations of that function, but which is accessible only inside that function (unlike local variables, which are private to a particular invocation of the function).</li>\n</ul>\n</hr>", "OwnerUserId": "1204143", "PostTypeId": "2", "Id": "24170747", "Score": "9", "CreationDate": "2014-06-11T19:09:20.313", "LastActivityDate": "2014-06-11T19:09:20.313"}, "bq_ids": {"n4140": {"so_24170568_24170568_2": {"section_id": 5404, "quality": 0.6428571428571429, "length": 9}}, "n3337": {"so_24170568_24170568_2": {"section_id": 5199, "quality": 0.6428571428571429, "length": 9}}, "n4659": {"so_24170568_24170568_2": {"section_id": 6853, "quality": 0.6428571428571429, "length": 9}}}, "24170568": {"CommentCount": "2", "AcceptedAnswerId": "24170747", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-06-11T18:59:59.473", "LastActivityDate": "2014-06-12T13:52:43.347", "LastEditDate": "2017-05-23T11:49:34.003", "ViewCount": "664", "FavoriteCount": "2", "Title": "Looking for clarification on static and inline functions", "Id": "24170568", "Score": "7", "Body": "<p>Originally, I thought <code>static</code> and <code>inline</code> meant the following for functions:</p>\n<hr>\n<p><strong><em>WARNING:</em></strong> This is what I used to think, don't assume this is correct.</p>\n<hr>\n<p>A <code>static</code> function exists only once. Everything that uses it uses the same function.* </p>\n<p>An <code>inline</code> function's content is, presumably, copied into the calling function. Compilers may actually ignore this but in case of definitions in non-template header files they are necessary to avoid duplicate definitions.</p>\n<p>A <code>static inline</code> function, I still haven't figured out what that should mean.</p>\n<p><sub>*with the added note that class templates effectively generate classes, so their static contents are completely different for each derived type.</sub></p>\n<hr>\n<p>I got this impression from the book C++ for Java Programmers (Mark Allen Weiss, ISBN 0-13-919424-X). At paragraph 2.1.6, it says:</p>\n<blockquote>\n<p id=\"so_24170568_24170568_0\">In some situations, the overhead of making a function call can be significant. For instance, the max2 routine is trivial, and so one might be tempted to simply replace the function invocation in main with the code that max2 is logically performing: ... Of course, this would be sacrificing good programming practice for speed.</p>\n<p id=\"so_24170568_24170568_1\">To avoid this one can use the inline directive. The inline directive suggests to the compiler that it should generate code that avoids the overhead of a function definition ...</p>\n</blockquote>\n<p>Surprisingly, I can't find anything about <code>static</code> functions. It might be there but I can't find it in the index.</p>\n<hr>\n<p>But then I found <a href=\"https://stackoverflow.com/a/12836392/982107\">this answer</a>, which seems to claim the exact opposite:</p>\n<blockquote>\n<p id=\"so_24170568_24170568_2\">The non-static inline function declaration refers to the same function in every translation unit (source file) that uses it.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_24170568_24170568_3\">If it is static then each TU has its own version of the function and hence its own copy of the static local variables.</p>\n</blockquote>\n<hr>\n<p><a href=\"https://stackoverflow.com/a/22103109/982107\">This answer</a> seems to take a different stance on what <code>inline</code> means, agreeing with my original interpretation:</p>\n<blockquote>\n<p id=\"so_24170568_24170568_4\">inline conveys exactly what you want: \"please suppress the ODR rule for this function, so that each translation unit can (and must) supply its own copy of the function's definition\".</p>\n</blockquote>\n<p>But then proceeds to say an <code>inline</code> function can either be inlined (I assume this means duplicated into every place where it's called) or merged together.</p>\n<blockquote>\n<p id=\"so_24170568_24170568_5\">The compiler will then either inline calls to the function, or merge together the function definitions from different TU's (so that the resulting function exists once in the executable).</p>\n</blockquote>\n<p>It then also says that declaring a function <code>static</code> means an arbitrary number of the function will exist:</p>\n<blockquote>\n<p id=\"so_24170568_24170568_6\">static, on the other hand, tells the compiler to generate the function in every translation unit where it is defined, and just not share it. So you end up with an arbitrary number of technically separate functions existing in the resulting executable.</p>\n</blockquote>\n<hr>\n<p>I'm not sure, but it sounds like <code>static</code> functions exist more than once and <code>inline</code> functions, when the compiler actually performs the inline, exist only once. Which would be the exact opposite of what I used to think.</p>\n<p>But to top it off, here's a bunch of questions about singletons where every getInstance function is declared <code>static</code>:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/1008019/c-singleton-design-pattern\">C++ Singleton design pattern</a></li>\n<li><a href=\"https://stackoverflow.com/questions/86582/singleton-how-should-it-be-used\">Singleton: How should it be used</a></li>\n<li><a href=\"https://stackoverflow.com/questions/11708667/c-singleton-class-getinstance-as-java\">C++ Singleton class getInstance (as java)</a></li>\n<li><a href=\"https://stackoverflow.com/questions/11580461/c-different-singleton-implementations\">C++ different singleton implementations</a></li>\n</ul>\n<p>So if <code>static</code> functions can really exist more than once, this would actually mean that there will be multiple local <code>static</code> singleton objects and every C++ singleton example I ever saw would be wrong, which seems unlikely.</p>\n<p>I don't get it anymore. Everything seems to be suggesting something else. What do <code>static</code>, <code>inline</code>, and, as a bonus: <code>static inline</code>, really mean for functions?</p>\n</hr></hr></hr></hr></hr></hr>", "Tags": "<c++><static><inline>", "OwnerUserId": "982107", "AnswerCount": "1"}});