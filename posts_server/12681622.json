post_cb({"12681728": {"Id": "12681728", "PostTypeId": "2", "Body": "<p><a href=\"https://stackoverflow.com/a/12681690/5987\">Ben Voigt's answer</a> is correct, but I want to add a little to it.</p>\n<p>You are essentially getting two different versions of the function, one in other.o and one in spec.o (generated by the inline template). The linker is designed to choose one and only one, making the assumption that they're both identical as the standard requires. In the first case, the linker will only pull a definition from a library if the symbol isn't already defined. Since it's defined in spec.o the library definition isn't used.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-10-01T22:11:01.723", "Score": "2", "CreationDate": "2012-10-01T21:59:52.617", "ParentId": "12681622", "CommentCount": "4", "LastEditDate": "2017-05-23T10:24:52.433", "OwnerUserId": "5987"}, "bq_ids": {"n4140": {"so_12681622_12681690_2": {"length": 15, "quality": 1.0, "section_id": 269}, "so_12681622_12681690_0": {"length": 49, "quality": 0.98, "section_id": 268}, "so_12681622_12681690_1": {"length": 90, "quality": 0.989010989010989, "section_id": 269}}, "n3337": {"so_12681622_12681690_2": {"length": 15, "quality": 1.0, "section_id": 260}, "so_12681622_12681690_0": {"length": 49, "quality": 0.98, "section_id": 259}, "so_12681622_12681690_1": {"length": 90, "quality": 0.989010989010989, "section_id": 260}}, "n4659": {"so_12681622_12681690_2": {"length": 15, "quality": 1.0, "section_id": 276}, "so_12681622_12681690_0": {"length": 49, "quality": 0.98, "section_id": 275}, "so_12681622_12681690_1": {"length": 90, "quality": 0.989010989010989, "section_id": 276}}}, "12681622": {"ViewCount": "109", "Body": "<p>Consider the following minimal example which reproduces a problem in a much bigger project:</p>\n<h1>spec.h:</h1>\n<pre><code>#include &lt;iostream&gt;\n\nclass A\n{\npublic:\n    template&lt;typename T&gt;\n    T test(const std::string&amp; a)\n    {\n        std::cout &lt;&lt; \"DEFAULT CALLED WITH \" &lt;&lt; a &lt;&lt; \"\\n\";\n        return T();\n    }\n};\n</code></pre>\n<h1>other.cpp:</h1>\n<pre><code>#include \"spec.h\"\n\ntemplate&lt;&gt;\nfloat A::test&lt;float&gt;(const std::string&amp; a)\n{\n    std::cout &lt;&lt; \"SPECIAL CALLED WITH \" &lt;&lt; a &lt;&lt; \"\\n\";\n    return float();\n}\n</code></pre>\n<h1>spec.cpp:</h1>\n<pre><code>#include &lt;iostream&gt;\n#include \"spec.h\"\n\nint main()\n{\n    A a;\n    a.test&lt;int&gt;(\"int\");\n    a.test&lt;float&gt;(\"float\");\n    return 0;\n}\n</code></pre>\n<h1>compilation:</h1>\n<pre><code>$ make\nrm -f *.o lib.a output\nclang++ -g other.cpp -c\nclang++ -g spec.cpp -c\nar cr lib.a other.o\nclang++ -g -o output lib.a spec.o\nrm -f *.o output2\nclang++ -g other.cpp -c\nclang++ -g spec.cpp -c\nclang++ -g -o output2 other.o spec.o\n\n$ ./output\nDEFAULT CALLED WITH int\nDEFAULT CALLED WITH float\n\n$ ./output2\nDEFAULT CALLED WITH int\nSPECIAL CALLED WITH float\n</code></pre>\n<h1>question:</h1>\n<p>Why is this happening? is it getting stripped somehow? what is the difference between lib.a and direct object file usage? :-)</p>\n<p>Thanks!</p>\n", "AcceptedAnswerId": "12681690", "Title": "specialized member function lost after linking thru ar", "CreationDate": "2012-10-01T21:49:28.117", "Id": "12681622", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2012-10-01T22:12:44.480", "Score": "3", "OwnerUserId": "722736", "Tags": "<c++><templates><linker><ar>", "AnswerCount": "3"}, "12681690": {"Id": "12681690", "PostTypeId": "2", "Body": "<p>From section 14.7.3p6:</p>\n<blockquote>\n<p id=\"so_12681622_12681690_0\">If a template, a member template or a member of a class template is explicitly specialized then <strong>that specialization shall be declared before the first use of that specialization that would cause an implicit instantiation to take place, in every translation unit in which such a use occurs</strong>; no diagnostic is required. If the program does not provide a de\ufb01nition for an explicit specialization and either the specialization is used in a way that would cause an implicit instantiation to take place or the member is a virtual member function, the program is ill-formed, no diagnostic required.</p>\n</blockquote>\n<p>Your program is ill-formed because you used the specialization in spec.cpp without declaring it first in that translation unit.  Or, as the following paragraph says:</p>\n<blockquote>\n<p id=\"so_12681622_12681690_1\">The placement of explicit specialization declarations for function templates, class templates, member functions of class templates, static data members of class templates, member classes of class templates, member enumerations of class templates, member class templates of class templates, member function templates of class templates, member functions of member templates of class templates, member functions of member templates of non-template classes, member function templates of member classes of class templates, etc., and the placement of partial specialization declarations of class templates, member class templates of non-template classes, member class templates of class templates, etc., can affect whether a program is well-formed according to the relative positioning of the explicit specialization declarations and their points of instantiation in the translation unit as specified above and below.</p>\n<p id=\"so_12681622_12681690_2\"><strong>When writing a specialization<br/> be careful about its location;<br/> or to make it compile<br/> will be such a trial<br/> as to kindle its self-immolation.</strong></p>\n</blockquote>\n<p>which I vote for as <em>the awesomest <strike>paragraph</strike> limerick in the whole Standard</em>.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2012-10-01T22:01:41.243", "Score": "8", "CreationDate": "2012-10-01T21:55:37.310", "ParentId": "12681622", "CommentCount": "4", "LastEditDate": "2012-10-01T22:01:41.243", "OwnerUserId": "103167"}, "12681704": {"Id": "12681704", "PostTypeId": "2", "Body": "<p>With the definition in the header each translation unit can create its own instantiation. Thus, there is never an undefined symbol referencing your specialized version. Correspondingly, the object file with the specialized version isn't included when looking at the library: it doesn't define any undefined symbol. When including the object file explicitly while linking, the linker has no choice than including it. However, you need to declare all specializations: without the declaration the compiler has no clue that the general version isn't applicable. What happens do this version, whether it is used or not, thus, depends on the way the symbol is treated.</p>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2012-10-01T22:12:44.480", "Score": "1", "CreationDate": "2012-10-01T21:56:50.623", "ParentId": "12681622", "CommentCount": "2", "LastEditDate": "2012-10-01T22:12:44.480", "OwnerUserId": "1120273"}});