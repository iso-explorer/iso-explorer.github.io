post_cb({"3503163": {"Id": "3503163", "PostTypeId": "2", "Body": "<p>Since C++ does not currently have a standard concurrency model, it would depend entirely on your threading implementation and whatever guarantees it gives.  It is all but certainly unsafe in the general case, however, because of the potential for torn reads.  There might be specific cases where it would \"work\" or at least \"appear to work.\"</p>\n<p>In C++0x (which does have a standard concurrency model), your scenario would formally result in undefined behavior.  There is a long, detailed, hard-to-read specification of the concurrency model in the C++0x Final Committee Draft \u00a71.10, but it basically boils down to this:</p>\n<blockquote>\n<p id=\"so_3503008_3503163_0\">Two expression evaluations conflict if one of them modifies a memory location and the other one accesses or modifies the same memory location (\u00a71.10/3).</p>\n<p id=\"so_3503008_3503163_1\">The execution of a program contains a data race if it contains two conflicting actions in different threads, at least one of which is not atomic, and neither happens before the other. Any such data race results in undefined behavior (\u00a71.10/14).</p>\n</blockquote>\n<p>Your expression evaluations clearly conflict because they modify and read the same memory location, and since the object is not atomic and access is not synchronized using a lock, you have undefined behavior.</p>\n", "LastActivityDate": "2010-08-17T13:55:02.780", "CommentCount": "4", "CreationDate": "2010-08-17T13:55:02.780", "ParentId": "3503008", "Score": "3", "OwnerUserId": "151292"}, "3503074": {"Id": "3503074", "PostTypeId": "2", "Body": "<p>Yes it is possible for unexpected behavior to happen in this scenario.  Consider the case where the initial value of the variable was not 0.  It is possible for one thread to start the set to 0 and another thread see the variable with only some of the bytes set.</p>\n<p>For types <code>int</code> this is very unlikely as most processor's will have atomic assignment of word sized values.  However once you hit 8 bit numeric values (<code>long</code> on some platforms) or large structs, this begins to be an issue.</p>\n", "LastActivityDate": "2010-08-17T13:45:57.837", "CommentCount": "2", "CreationDate": "2010-08-17T13:45:57.837", "ParentId": "3503008", "Score": "1", "OwnerUserId": "23283"}, "3503176": {"Id": "3503176", "PostTypeId": "2", "Body": "<p>It's incredibly unlikely but not impossible according to the standard.</p>\n<p>There's nothing stating what the underlying representation of an integer is, not does the standard specify how the values are loaded.</p>\n<p>I can envisage, however weird, an implementation where the underlying bit pattern for 0 is <code>10101010</code> and the architecture only supports loading data into memory by bit-shifting it over eight cycles but reading it as a single unit in one cycle.</p>\n<p>If another thread reads the value while the bit pattern is being shifted in (e.g., <code>00000001</code>, <code>00000010</code>,<code>00000101</code> and so on), you will have a problem.</p>\n<p>The chances of anyone designing such a bizarre architecture is so close to zero as to be negligible. But, unfortunately, it's not zero. All I'm trying to get across is that you shouldn't rely on assumptions at all when it comes to standards compliance.</p>\n<p>And please, before you vote me down, feel free to quote the part of the standard that states this is not possible :-)</p>\n", "LastActivityDate": "2010-08-17T13:56:32.057", "Score": "5", "CreationDate": "2010-08-17T13:56:32.057", "ParentId": "3503008", "CommentCount": "4", "OwnerUserId": "14860", "CommunityOwnedDate": "2010-08-17T14:06:31.033"}, "3503008": {"ViewCount": "575", "Body": "<p>I have the following situation (caused by a defect in the code):</p>\n<p>There's a shared variable of primitive type (let it be <code>int</code>) that is initialized during program startup from strictly one thread to value <code>N</code> (let it be <code>0</code>). Then (strictly <em>after the variable is initialized</em>) during the program runtime various threads are started and they in some random order either read that variable or overwrite it with <em>the very same value <code>N</code></em> (<code>0</code> in this example). There's no synchronization around accessing the variable.</p>\n<p>Can this situation cause unexpected behavior in the program?</p>\n", "AcceptedAnswerId": "3503176", "Title": "Is concurrently overwriting a variable with the same value safe?", "CreationDate": "2010-08-17T13:39:55.527", "Id": "3503008", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2010-08-17T13:47:33.340", "LastEditorUserId": "57428", "LastActivityDate": "2010-08-17T13:59:58.377", "Score": "3", "OwnerUserId": "57428", "Tags": "<c++><multithreading><concurrency><synchronization>", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_3503008_3503163_1": {"length": 20, "quality": 0.7692307692307693, "section_id": 5834}, "so_3503008_3503163_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 5817}}, "n3337": {"so_3503008_3503163_1": {"length": 22, "quality": 0.8461538461538461, "section_id": 5605}, "so_3503008_3503163_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 5588}}, "n4659": {"so_3503008_3503163_1": {"length": 20, "quality": 0.7692307692307693, "section_id": 7296}, "so_3503008_3503163_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 7278}}}, "3503046": {"Id": "3503046", "PostTypeId": "2", "Body": "<p>No.  Of course, you could end up with a data race if one of the threads later tries to change the value.  You will also end up with a little cache contention, but I doubt this will have noticable effect.</p>\n", "LastActivityDate": "2010-08-17T13:43:43.650", "CommentCount": "0", "CreationDate": "2010-08-17T13:43:43.650", "ParentId": "3503008", "Score": "2", "OwnerUserId": "114421"}, "3503064": {"Id": "3503064", "PostTypeId": "2", "Body": "<p>You can not really rely on it. For primitive types you should be fine, and if the operation is atomic (eg a correctly aligned int on most platforms) then writing and reading different values is safe (note by this I mean like \"x = 5;\", <strong>not</strong> \"x += 5;\" which is never atomic and is not thread safe).</p>\n<p>For non-primitive types even if its the same value all bets are off since there may be a copy constructor that does something un-safe (like allocating memory).</p>\n", "LastActivityDate": "2010-08-17T13:45:14.270", "CommentCount": "0", "CreationDate": "2010-08-17T13:45:14.270", "ParentId": "3503008", "Score": "1", "OwnerUserId": "6266"}, "3503053": {"Id": "3503053", "PostTypeId": "2", "Body": "<p>If no other thread (and this includes the main thread) can change the value of the 0 to anything else (lets say <code>1</code>) while those threads are initializing then it you will not have problems. But if any other thread had the potential to change the value during the start-up phase you could have a problem. You are playing a dangerous game and I would recommend locking before reading the value.</p>\n", "LastActivityDate": "2010-08-17T13:44:03.260", "CommentCount": "0", "CreationDate": "2010-08-17T13:44:03.260", "ParentId": "3503008", "Score": "0", "OwnerUserId": "80274"}});