post_cb({"9653789": {"Id": "9653789", "PostTypeId": "2", "Body": "<p>On Intel architecture, simple values (integers and pointers) are usually returned in <code>eax</code> register. This register (among others) is also used as temporary storage when moving values in memory and as operand during calculations. So whatever value left in that register is treated as the return value, and in your case it turned out to be exactly what you wanted to be returned.</p>\n", "LastActivityDate": "2012-03-11T09:24:23.047", "CommentCount": "4", "CreationDate": "2012-03-11T09:24:23.047", "ParentId": "9653722", "Score": "7", "OwnerUserId": "544621"}, "9653722": {"ViewCount": "2066", "Body": "<p>I recently had a serious bug, where I forgot to return a value in a function. The problem was that even though nothing was returned it worked fine under Linux/Windows and only crashed under Mac. I discovered the bug when I turned on all compiler warnings.</p>\n<p>So here is a simple example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A{\npublic:\n    A(int p1, int p2, int p3): v1(p1), v2(p2), v3(p3)\n    {\n    }\n\n    int v1;\n    int v2;\n    int v3;\n};\n\nA* getA(){\n    A* p = new A(1,2,3);\n//  return p;\n}\n\nint main(){\n\n    A* a = getA();\n\n    std::cerr &lt;&lt; \"A: v1=\" &lt;&lt; a-&gt;v1 &lt;&lt; \" v2=\" &lt;&lt; a-&gt;v2 &lt;&lt; \" v3=\" &lt;&lt; a-&gt;v3 &lt;&lt; std::endl;  \n\n    return 0;\n}\n</code></pre>\n<p>My question is how can this work under Linux/Windows without crashing? How is the returning of values done on lower level?</p>\n", "AcceptedAnswerId": "9653789", "Title": "How does returning values from a function work?", "CreationDate": "2012-03-11T09:09:47.873", "Id": "9653722", "CommentCount": "9", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2012-03-11T10:10:25.900", "Score": "6", "OwnerUserId": "1115279", "Tags": "<c++><stack>", "AnswerCount": "8"}, "9653790": {"Id": "9653790", "PostTypeId": "2", "Body": "<p>As Kerrek SB mentioned, your code has ventured into the realm of undefined behavior.</p>\n<p>Basically, your code is going to compile down to assembly.  In assembly, there's no concept of a function requiring a return type, there's just an expectation.  I'm the most comfortable with MIPS, so I shall use MIPS to illustrate.</p>\n<p>Assume you have the following code:</p>\n<pre><code>int add(x, y)\n{\n    return x + y;\n}\n</code></pre>\n<p>This is going to be translated to something like:</p>\n<pre><code>add:\n    add $v0, $a0, $a1 #add $a0 and $a1 and store it in $v0\n    jr $ra #jump back to where ever this code was jumped to from\n</code></pre>\n<p>To add 5 and 4, the code would be called something like:</p>\n<pre><code>addi $a0, $0, 5 # 5 is the first param\naddi $a1, $0, 4 # 4 is the second param\njal add\n# $v0 now contains 9\n</code></pre>\n<p>Note that unlike C, there's no explicit requirement that $v0 contain the return value, just an expectation.  So, what happens if you don't actually push anything into $v0?  Well, $v0 always has <em>some</em> value, so the value will be whatever it last was.</p>\n<p><em>Note:</em> This post makes some simplifications.  Also, you're computer is likely not running MIPS...  But hopefully the example holds, and if you learned assembly at a university, MIPS might be what you know anyway.</p>\n", "LastActivityDate": "2012-03-11T09:24:41.127", "CommentCount": "2", "CreationDate": "2012-03-11T09:24:41.127", "ParentId": "9653722", "Score": "1", "OwnerUserId": "567864"}, "9653837": {"Id": "9653837", "PostTypeId": "2", "Body": "<p>There are two major ways for a compiler to return a value:</p>\n<ol>\n<li>Put a value in a <em>register</em> before returning, and</li>\n<li>Have the caller pass a block of stack memory for the return value, and write the value into that block <a href=\"http://en.wikipedia.org/wiki/Return_value_optimization\" rel=\"nofollow\">[more info]</a></li>\n</ol>\n<p>The #1 is usually used with anything that fits into a register; #2 is for everything else (large structs, arrays, et cetera).</p>\n<p>In your case, the compiler uses #1 <strong>both for the return of <code>new</code> and for the return of your function</strong>. On Linux and Windows, the compiler did not perform any value-distorting operations on the register with the returned value between writing it into the pointer variable and returning from your function; on Mac, it did. Hence the difference in the results that you see: in the first case, the <em>left-over value</em> in the return register happened to co-inside with the value that you <em>wanted</em> to return anyway.</p>\n", "LastActivityDate": "2012-03-11T09:34:11.070", "CommentCount": "0", "CreationDate": "2012-03-11T09:34:11.070", "ParentId": "9653722", "Score": "2", "OwnerUserId": "335858"}, "9653782": {"Id": "9653782", "PostTypeId": "2", "Body": "<p>Probably by luck, 'a' left in a register that happens to be used for returning single pointer results, something like that.</p>\n<p>The calling/ conventions and function result returns are architecture-dependent, so it's not surprising that your code works on Windows/Linux but not on a Mac.</p>\n", "LastActivityDate": "2012-03-11T09:23:25.830", "CommentCount": "3", "CreationDate": "2012-03-11T09:23:25.830", "ParentId": "9653722", "Score": "3", "OwnerUserId": "758133"}, "bq_ids": {"n4140": {"so_9653722_9653800_0": {"length": 12, "quality": 1.0, "section_id": 3913}}, "n3337": {"so_9653722_9653800_0": {"length": 12, "quality": 1.0, "section_id": 3773}}, "n4659": {"so_9653722_9653800_0": {"length": 9, "quality": 0.75, "section_id": 4799}}}, "9653804": {"Id": "9653804", "PostTypeId": "2", "Body": "<p>First off, you need to slightly modify your example to get it to compile. The function must have at least an execution path that returns a value.</p>\n<pre><code>A* getA(){\n    if(false)\n        return NULL;\n    A* p = new A(1,2,3);\n//  return p;\n}\n</code></pre>\n<p>Second, it's obviously undefined behavior, which means anything can happen, but I guess this answer won't satisfy you.</p>\n<p>Third, in Windows it works in Debug mode, but if you compile under Release, it doesn't.</p>\n<p>The following is compiled under Debug:</p>\n<pre><code>    A* p = new A(1,2,3);\n00021535  push        0Ch  \n00021537  call        operator new (211FEh) \n0002153C  add         esp,4 \n0002153F  mov         dword ptr [ebp-0E0h],eax \n00021545  mov         dword ptr [ebp-4],0 \n0002154C  cmp         dword ptr [ebp-0E0h],0 \n00021553  je          getA+7Eh (2156Eh) \n00021555  push        3    \n00021557  push        2    \n00021559  push        1    \n0002155B  mov         ecx,dword ptr [ebp-0E0h] \n00021561  call        A::A (21271h) \n00021566  mov         dword ptr [ebp-0F4h],eax \n0002156C  jmp         getA+88h (21578h) \n0002156E  mov         dword ptr [ebp-0F4h],0 \n00021578  mov         eax,dword ptr [ebp-0F4h] \n0002157E  mov         dword ptr [ebp-0ECh],eax \n00021584  mov         dword ptr [ebp-4],0FFFFFFFFh \n0002158B  mov         ecx,dword ptr [ebp-0ECh] \n00021591  mov         dword ptr [ebp-14h],ecx \n</code></pre>\n<p>The second instruction, the call to <code>operator new</code>, moves into <code>eax</code> the pointer to the newly created instance.</p>\n<pre><code>    A* a = getA();\n0010484E  call        getA (1012ADh) \n00104853  mov         dword ptr [a],eax \n</code></pre>\n<p>The calling context expects <code>eax</code> to contain the returned value, but it does not, it contains the last pointer allocated by <code>new</code>, which is incidentally, <code>p</code>.</p>\n<p>So that's why it works.</p>\n", "LastEditorUserId": "673730", "LastActivityDate": "2012-03-11T09:56:31.147", "Score": "2", "CreationDate": "2012-03-11T09:28:37.580", "ParentId": "9653722", "CommentCount": "3", "LastEditDate": "2012-03-11T09:56:31.147", "OwnerUserId": "673730"}, "9653767": {"Id": "9653767", "PostTypeId": "2", "Body": "<p>The way of returning of value from the function depends on architecture and the type of value. It could be done thru registers or thru stack.\nTypically in the x86 architecture the value is returned in EAX register if it is an integral type: char, int or pointer.\nWhen you don't specify the return value, that value is undefined. This is only your luck that your code sometimes worked correctly.</p>\n", "LastActivityDate": "2012-03-11T09:20:28.443", "CommentCount": "2", "CreationDate": "2012-03-11T09:20:28.443", "ParentId": "9653722", "Score": "0", "OwnerUserId": "706900"}, "9653800": {"Id": "9653800", "PostTypeId": "2", "Body": "<p>Regarding the following statement from n3242 draft C++ Standard, paragraph 6.6.3.2, your example yields <strong>undefined behavior</strong>:</p>\n<blockquote>\n<p id=\"so_9653722_9653800_0\">Flowing off the end of a function is equivalent to a return with no\n  value; this results in undefined behavior in a value-returning\n  function.</p>\n</blockquote>\n<p>The best way to see what actually happens is to check the assembly code generated by the given compiler on a given architecture. For the following code:</p>\n<pre><code>#pragma warning(default:4716)\nint foo(int a, int b)\n{\n    int c = a + b;\n}\n\nint main()\n{\n    int n = foo(1, 2);\n}\n</code></pre>\n<p>...VS2010 compiler (in Debug mode, on Intel 32-bit machine) generates the following assembly:</p>\n<pre><code>#pragma warning(default:4716)\nint foo(int a, int b)\n{\n011C1490  push        ebp  \n011C1491  mov         ebp,esp  \n011C1493  sub         esp,0CCh  \n011C1499  push        ebx  \n011C149A  push        esi  \n011C149B  push        edi  \n011C149C  lea         edi,[ebp-0CCh]  \n011C14A2  mov         ecx,33h  \n011C14A7  mov         eax,0CCCCCCCCh  \n011C14AC  rep stos    dword ptr es:[edi]  \n    int c = a + b;\n011C14AE  mov         eax,dword ptr [a]  \n011C14B1  add         eax,dword ptr [b]  \n011C14B4  mov         dword ptr [c],eax  \n}\n...\nint main()\n{\n011C14D0  push        ebp  \n011C14D1  mov         ebp,esp  \n011C14D3  sub         esp,0CCh  \n011C14D9  push        ebx  \n011C14DA  push        esi  \n011C14DB  push        edi  \n011C14DC  lea         edi,[ebp-0CCh]  \n011C14E2  mov         ecx,33h  \n011C14E7  mov         eax,0CCCCCCCCh  \n011C14EC  rep stos    dword ptr es:[edi]  \n    int n = foo(1, 2);\n011C14EE  push        2  \n011C14F0  push        1  \n011C14F2  call        foo (11C1122h)  \n011C14F7  add         esp,8  \n011C14FA  mov         dword ptr [n],eax  \n}\n</code></pre>\n<p>The result of addition operation in <code>foo()</code> is stored in <code>eax</code> register (accumulator) and its content is used as a return value of the function, moved to variable <code>n</code>.</p>\n<p><code>eax</code> is used to store a return value (pointer) in the following example as well:</p>\n<pre><code>#pragma warning(default:4716)\nint* foo(int a)\n{\n    int* p = new int(a);\n}\n\nint main()\n{\n    int* pn = foo(1);\n\n    if(pn)\n    {\n        int n = *pn;\n        delete pn;\n    }\n}\n</code></pre>\n<p>Assembly code:</p>\n<pre><code>#pragma warning(default:4716)\nint* foo(int a)\n{\n000C1520  push        ebp  \n000C1521  mov         ebp,esp  \n000C1523  sub         esp,0DCh  \n000C1529  push        ebx  \n000C152A  push        esi  \n000C152B  push        edi  \n000C152C  lea         edi,[ebp-0DCh]  \n000C1532  mov         ecx,37h  \n000C1537  mov         eax,0CCCCCCCCh  \n000C153C  rep stos    dword ptr es:[edi]  \n    int* p = new int(a);\n000C153E  push        4  \n000C1540  call        operator new (0C1253h)  \n000C1545  add         esp,4  \n000C1548  mov         dword ptr [ebp-0D4h],eax  \n000C154E  cmp         dword ptr [ebp-0D4h],0  \n000C1555  je          foo+50h (0C1570h)  \n000C1557  mov         eax,dword ptr [ebp-0D4h]  \n000C155D  mov         ecx,dword ptr [a]  \n000C1560  mov         dword ptr [eax],ecx  \n000C1562  mov         edx,dword ptr [ebp-0D4h]  \n000C1568  mov         dword ptr [ebp-0DCh],edx  \n000C156E  jmp         foo+5Ah (0C157Ah)  \nstd::operator&lt;&lt;&lt;std::char_traits&lt;char&gt; &gt;:\n000C1570  mov         dword ptr [ebp-0DCh],0  \n000C157A  mov         eax,dword ptr [ebp-0DCh]  \n000C1580  mov         dword ptr [p],eax  \n}\n...\nint main()\n{\n000C1610  push        ebp  \n000C1611  mov         ebp,esp  \n000C1613  sub         esp,0E4h  \n000C1619  push        ebx  \n000C161A  push        esi  \n000C161B  push        edi  \n000C161C  lea         edi,[ebp-0E4h]  \n000C1622  mov         ecx,39h  \n000C1627  mov         eax,0CCCCCCCCh  \n000C162C  rep stos    dword ptr es:[edi]  \n    int* pn = foo(1);\n000C162E  push        1  \n000C1630  call        foo (0C124Eh)  \n000C1635  add         esp,4  \n000C1638  mov         dword ptr [pn],eax  \n\n    if(pn)\n000C163B  cmp         dword ptr [pn],0  \n000C163F  je          main+51h (0C1661h)  \n    {\n        int n = *pn;\n000C1641  mov         eax,dword ptr [pn]  \n000C1644  mov         ecx,dword ptr [eax]  \n000C1646  mov         dword ptr [n],ecx  \n        delete pn;\n000C1649  mov         eax,dword ptr [pn]  \n000C164C  mov         dword ptr [ebp-0E0h],eax  \n000C1652  mov         ecx,dword ptr [ebp-0E0h]  \n000C1658  push        ecx  \n000C1659  call        operator delete (0C1249h)  \n000C165E  add         esp,4  \n    }\n}\n</code></pre>\n<p>VS2010 compiler issues <a href=\"http://msdn.microsoft.com/en-us/library/ft5xye74.aspx\" rel=\"nofollow\">warning 4716</a> in both examples. By default this warning is promoted to an error.</p>\n", "LastEditorUserId": "404421", "LastActivityDate": "2012-03-11T10:10:25.900", "Score": "0", "CreationDate": "2012-03-11T09:27:29.727", "ParentId": "9653722", "CommentCount": "0", "LastEditDate": "2012-03-11T10:10:25.900", "OwnerUserId": "404421"}, "9653811": {"Id": "9653811", "PostTypeId": "2", "Body": "<p>When popping values from the stack in IBM PC architecture there is no physical destruction of the old values \u200b\u200bof data stored there. They just become unavailable through the operation of the stack, but still remain in the same memory cell. </p>\n<p>Of course, the previous values \u200b\u200bof these data will be destroyed during the subsequent pushing of new data on the stack. </p>\n<p>So probably you are just lucky enough, and nothing is added to stack during your function's call and return surrounding code.</p>\n", "LastActivityDate": "2012-03-11T09:29:57.433", "CommentCount": "0", "CreationDate": "2012-03-11T09:29:57.433", "ParentId": "9653722", "Score": "0", "OwnerUserId": "737655"}});