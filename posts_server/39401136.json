post_cb({"39401136": {"CommentCount": "14", "ViewCount": "741", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-09-08T22:30:45.887", "LastActivityDate": "2016-09-09T16:29:19.437", "Title": "Is a variable an array of size 1?", "FavoriteCount": "2", "LastEditDate": "2017-05-23T10:31:09.620", "Id": "39401136", "Score": "12", "Body": "<p>Consider this:</p>\n<pre><code>int main(int, char **) {\n  int variable = 21;\n  int array[1] = {21};\n  using ArrayOf1Int = int[1];\n  (*reinterpret_cast&lt;ArrayOf1Int *&gt;(&amp;variable))[0] = 42;\n  *reinterpret_cast&lt;int *&gt;(&amp;array) = 42;\n  return 0;\n}\n</code></pre>\n<p>Did I just violate <a href=\"https://stackoverflow.com/a/7005988/1116364\">the strict aliasing rule</a>?</p>\n<p>Or, as in <a href=\"https://stackoverflow.com/questions/39376813/is-the-stdarray-bit-compatible-with-the-old-c-array#comment66082963_39377268\">this comment</a> that led me to this question: <em>Is a variable an array of size 1</em>?</p>\n<p>Note that I tagged this as language-lawyer question. Thus I'm not interested in <code>-fno-strict-aliasing</code> or compiler specific behavior, but instead in what's said in the standard. Also I think it would be interesting to know if and how this changed between C++03, C++11, C++14, and newer versions.</p>\n", "Tags": "<c++><c++11><c++14><language-lawyer><c++1z>", "OwnerUserId": "1116364", "AnswerCount": "4"}, "39413058": {"ParentId": "39401136", "CommentCount": "0", "Body": "<p>An array of 1 integer is not layout-compatible with an integer.</p>\n<p>This means:</p>\n<pre><code>struct A {\n  int x;\n};\nstruct B {\n  int y[1];\n};\nA a={0};\nstd::cout &lt;&lt; ((B*)&amp;a).y[0];\n</code></pre>\n<p>is not defined behavior.  See <code>[basic.types]/11</code> for the definition of <em>layout-compatible</em>.</p>\n<p><code>A::x</code> and <code>B::y</code> are not the same types from <code>[basic.types]/10</code> -- one is under <code>[basic.types]/10.2</code> (scalar type) and the other under <code>[basic.types]/10.4</code> (array of literals).  They are not layout-compatible enumerations.  They are not class types, so <code>[class.name]/20-21</code> does not apply.</p>\n<p>Thus <code>[class.name]/20</code> (common initial sequence) does not consider <code>x</code> and <code>y</code> to be  a common initial sequence.</p>\n<p>I am unaware of a compiler that does not make <code>A</code> and <code>B</code> actually bit-for-bit identical, but the standard states that the above reinterpretation is ill-formed, and as such compilers are free to assume that it will never be done.  This can lead to optimizers or other exploiters of strict aliasing to cause unexpected behavior if you depend upon it.</p>\n<p>I personally would think it would be a good idea to state that an array <code>T[N]</code> is layout-compatible with a sequence of N adjacent <code>T</code>s.  This would permit a number of useful techniques, such as:</p>\n<pre><code>struct pixel {\n  union {\n    struct {\n      char r, g, b, a;\n    } e;\n    std::array&lt;char,4&gt; pel;\n  };\n};\n</code></pre>\n<p>where <code>pixel.pel[0]</code> is guaranteed to correspond to <code>pixel.e.r</code>.  But to the best of my knowledge, this is not legal.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "39413058", "Score": "1", "CreationDate": "2016-09-09T13:46:56.143", "LastActivityDate": "2016-09-09T13:46:56.143"}, "39401437": {"ParentId": "39401136", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Clearly, if an object were a variable of an array of size one, you could initialise a reference to an array of size one with an object:</p>\n<pre><code>int variable{21};\nint (&amp;array)[1] = variable; // illegal\n</code></pre>\n<p>However, the initialisation is illegal. The relevant clause for this is Clause 4 [conv] (Standard Conversions) which stated in paragraph 1:</p>\n<blockquote>\n<p id=\"so_39401136_39401437_0\">Standard conversions are implicit conversions with built-in meaning. Clause 4 enumerates the full set of such conversions.</p>\n</blockquote>\n<p>This clause is too long to quote here but it has nothing to say about a conversion of an object to a reference of an array of any size. Similarly, the section in <code>reinterpret_cast</code> (5.2.10 [expr.reinterpret.cast]) does not spell out any behaviour involving arrays but does spell out this exclusion in paragraph 1:</p>\n<blockquote>\n<p id=\"so_39401136_39401437_1\">... Conversions that can be performed explicitly using <code>reinterpret_cast</code> are listed below. No other conversion can be performed explicitly using <code>reinterpret_cast</code>.</p>\n</blockquote>\n<p>I don't think there is an explicit statement that an object is not an array of one object but there are sufficient omissions to make the case implicitly. The guarantee given by the standard relating objects and array is that pointer to an object behave as if they are pointing to array of size 1 (5.7 [expr.add] paragraph 4):</p>\n<blockquote>\n<p id=\"so_39401136_39401437_2\">For the purposes of these operators, a pointer to a nonarray object behaves the same as a pointer to the first element of an array of length one with the type of the object as its element type.</p>\n</blockquote>\n<p>The presence of this statement also implies that array objects and nonarray objects are different entities: if they were considered the same this statement wouldn't be necessary to start with.</p>\n<p>With respect to prior (or future) versions of the standard: although the exact words in the different clauses may have changed, the overall situation didn't change: objects and arrays were always different entities and, so far, I'm not aware of an intent to change that.</p>\n", "OwnerUserId": "1120273", "LastEditorUserId": "3002139", "LastEditDate": "2016-09-08T23:17:22.540", "Id": "39401437", "Score": "9", "CreationDate": "2016-09-08T23:06:05.630", "LastActivityDate": "2016-09-08T23:17:22.540"}, "39401334": {"ParentId": "39401136", "CommentCount": "4", "Body": "<p><code>reinterpret_cast</code> only behaves predictably in C++11 and above, so neither line is guaranteed to have defined behaviour before C++11. We'll proceed assuming C++11 or above.</p>\n<p><strong>First line</strong></p>\n<pre><code>(*reinterpret_cast&lt;decltype(&amp;array)&gt;(&amp;variable))[0] = 42;\n</code></pre>\n<p>In this line, dereferencing the <code>reinterpret_cast</code> yields a glvalue but does not <em>access</em> the <code>int</code> object through that glvalue. By the time the <code>int</code> object is accessed, the glvalue referring to the array has already been decayed into a pointer to that object (that is, an <code>int*</code>).</p>\n<p>However, one can \"contrive\" a case that looks like it might contain a strict aliasing violation, like so:</p>\n<pre><code>struct S {\n    int a[1];\n};\nint variable = 42;\nS s = reinterpret_cast&lt;S&amp;&gt;(variable);\n</code></pre>\n<p>This does <em>not</em> violate strict aliasing because you are allowed to access an object through a subobject of an aggregate or union type. (This rule has existed since C++98.)</p>\n<p><strong>Second line</strong></p>\n<pre><code>*reinterpret_cast&lt;decltype(&amp;variable)&gt;(&amp;array) = 42;\n</code></pre>\n<p>The <code>reinterpret_cast</code> is guaranteed to give a pointer to the first subobject of the array, which is an <code>int</code> object, so assigning to it through an <code>int</code> pointer is well-defined.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "39401334", "Score": "7", "CreationDate": "2016-09-08T22:54:59.740", "LastActivityDate": "2016-09-08T22:54:59.740"}, "39401390": {"ParentId": "39401136", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>One recent draft says:</p>\n<p>\u00a7[expr.unary.op]/3:</p>\n<blockquote>\n<p id=\"so_39401136_39401390_0\">The result of the unary &amp; operator is a pointer to its operand.\n  [...]\n  For purposes of pointer arithmetic (5.7) and comparison (5.9, 5.10), an object that is not an array element whose address is taken in this way is considered to belong to an array with one element of type T. </p>\n</blockquote>\n<p>The types we're dealing with here are all really pointers, but we're (eventually) dereferencing them. As such, this probably isn't enough to render the behavior defined (but it's a close call).</p>\n<p>As for changes between versions: that wording is in N4296 (a draft in between C++14 and C++17) but not N4140 or N3337 (basically C++14 and C++11 respectively).</p>\n<p>The C11 standard has vaguely similar language for <code>fscanf_s</code> and <code>fwscanf_s</code> (\u00a7K.3.5.3.2/4):</p>\n<blockquote>\n<p id=\"so_39401136_39401390_1\">The first of these arguments is the same as for fscanf. That argument is\n  immediately followed in the argument list by the second argument, which has type\n  rsize_t and gives the number of elements in the array pointed to by the first argument of the pair. If the first argument points to a scalar object, it is considered to be an array of one element.</p>\n</blockquote>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2016-09-09T16:29:19.437", "Id": "39401390", "Score": "6", "CreationDate": "2016-09-08T23:00:26.200", "LastActivityDate": "2016-09-09T16:29:19.437"}, "bq_ids": {"n4140": {"so_39401136_39401437_0": {"section_id": 0, "quality": 0.9166666666666666, "length": 11}, "so_39401136_39401437_2": {"section_id": 6141, "quality": 0.9473684210526315, "length": 18}, "so_39401136_39401437_1": {"section_id": 6040, "quality": 1.0, "length": 15}}, "n3337": {"so_39401136_39401437_0": {"section_id": 0, "quality": 0.9166666666666666, "length": 11}, "so_39401136_39401437_2": {"section_id": 5905, "quality": 0.9473684210526315, "length": 18}, "so_39401136_39401437_1": {"section_id": 5808, "quality": 1.0, "length": 15}}, "n4659": {"so_39401136_39401390_0": {"section_id": 7562, "quality": 0.88, "length": 22}, "so_39401136_39401437_0": {"section_id": 0, "quality": 0.9166666666666666, "length": 11}, "so_39401136_39401437_2": {"section_id": 7603, "quality": 0.5789473684210527, "length": 11}, "so_39401136_39401437_1": {"section_id": 7539, "quality": 1.0, "length": 15}}}});