post_cb({"bq_ids": {"n4140": {"so_14206403_14206403_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 5469}, "so_14206403_14206403_2": {"length": 35, "quality": 0.9459459459459459, "section_id": 24}, "so_14206403_14208457_1": {"length": 19, "quality": 1.0, "section_id": 640}, "so_14206403_14208457_0": {"length": 31, "quality": 0.8378378378378378, "section_id": 23}}, "n3337": {"so_14206403_14206403_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 5255}, "so_14206403_14206403_2": {"length": 35, "quality": 0.9459459459459459, "section_id": 21}, "so_14206403_14208457_1": {"length": 11, "quality": 0.5789473684210527, "section_id": 21}, "so_14206403_14208457_0": {"length": 31, "quality": 0.8378378378378378, "section_id": 20}}, "n4659": {"so_14206403_14206403_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 6903}, "so_14206403_14206403_2": {"length": 35, "quality": 0.9459459459459459, "section_id": 24}, "so_14206403_14208457_1": {"length": 19, "quality": 1.0, "section_id": 668}, "so_14206403_14208457_0": {"length": 31, "quality": 0.8378378378378378, "section_id": 23}}}, "14208457": {"Id": "14208457", "PostTypeId": "2", "Body": "<p>In C++03, the rule was:</p>\n<blockquote>\n<p id=\"so_14206403_14208457_0\">An rvalue of an unscoped enumeration type (7.2 [dcl.enum]) can be\n  converted to an rvalue of the first of the following types that can\n  represent all the values of the enumeration (i.e. the values in the\n  range bmin to bmax as described in 7.2 [dcl.enum]): int, unsigned int,\n  long int, unsigned long int, long long int, or unsigned long long int.</p>\n</blockquote>\n<p>In a C++03 compiler, <code>int</code> would be chosen because it is the first\non the list. </p>\n<hr>\n<p>In C++11, the <em>underlying type</em> was introduced. Accordingly, via <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#685\" rel=\"noreferrer\">685. Integral promotion of enumeration ignores fixed underlying type </a>, this wording was changed to the paragraph you quoted in \u00a74.5/4 and from reading the defect report, it seems the intention of the committee was for <code>fct(char)</code> (the underlying type) to be chosen. </p>\n<p>However, according to the discussion under <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1601\" rel=\"noreferrer\">core issue 1601</a>, the text in C++11 actually makes the conversion ambiguous (<code>fct(char)</code> and <code>fct(int)</code> are both possible and neither is preferred).</p>\n<p>The following fix was proposed and accepted into C++14:</p>\n<blockquote>\n<p id=\"so_14206403_14208457_1\">A conversion that promotes an enumeration whose underlying type is\n  fixed to its underlying type is better than one that promotes to the\n  promoted underlying type, if the two are different.</p>\n</blockquote>\n<p>Since it was reported as a defect in C++11, compilers should apply this fix when in C++11 mode and call <code>fct(char)</code>.</p>\n</hr>", "LastEditorUserId": "1505939", "LastActivityDate": "2015-04-12T02:16:32.957", "Score": "9", "CreationDate": "2013-01-08T05:00:27.607", "ParentId": "14206403", "CommentCount": "6", "OwnerUserId": "906773", "LastEditDate": "2015-04-12T02:16:32.957"}, "14206403": {"ViewCount": "1469", "Body": "<p>This problem came up when answering <a href=\"https://stackoverflow.com/questions/14185352/underlying-type-of-weak-typed-enum-in-c11\">this question about overload resolution with enums</a>.</p>\n<p>While the case for <code>long long</code> was definitely a bug in MSVC2012NovCTP (according to the standard text and a test with gcc 4.7.1), I cannot figure out why the following behavior occurs:</p>\n<pre><code>#include &lt;iostream&gt;\n\nenum charEnum : char { A = 'A' };\n\nvoid fct(char)      { std::cout &lt;&lt; \"fct(char)\"      &lt;&lt; std::endl; }\nvoid fct(int)       { std::cout &lt;&lt; \"fct(int)\"       &lt;&lt; std::endl; }\nvoid fct(long long) { std::cout &lt;&lt; \"fct(long long)\" &lt;&lt; std::endl; }\n\nint main() \n{\n    fct('A');\n    fct(A);\n}\n</code></pre>\n<p>Both MSVC2012NovCTP and gcc 4.7.1 agree on this output: </p>\n<blockquote>\n<p id=\"so_14206403_14206403_0\">fct(char)<br>\n  fct(int)  </br></p>\n</blockquote>\n<p>Shouldn't <code>A</code> be converted from <code>charEnum</code> to <code>char</code>? Why is <code>A</code> being converted to <code>int</code>?</p>\n<p>EDIT: clang complains that the call is ambiguous, which agrees with my interpretation below; that said, I would still find it much more intuitive if it were only considered to be the underlying type.</p>\n<hr>\n<p>Two relevant standard excerpts are \u00a77.2/9:</p>\n<blockquote>\n<p id=\"so_14206403_14206403_1\">The value of an enumerator or an object of an unscoped enumeration type is converted to an integer by integral promotion (4.5)</p>\n</blockquote>\n<p>And \u00a74.5/4:</p>\n<blockquote>\n<p id=\"so_14206403_14206403_2\">A prvalue of an unscoped enumeration type whose underlying type is \ufb01xed (7.2) can be converted to a prvalue of its underlying type. Moreover, if integral promotion can be applied to its underlying type, a prvalue of an unscoped enumeration type whose underlying type is \ufb01xed can also be converted to a prvalue of the promoted underlying type. </p>\n</blockquote>\n<p>So <code>charEnum</code> can either be converted to <code>char</code>, or any integral promotion of <code>char</code>, such as <code>int</code>.</p>\n<p>But this is vague to me because \"can\" doesn't quite say which will actually be chosen. If anything, this should be ambiguous with this wording because no preference is given between <code>char</code> or any of its promotions. If you comment out <code>fct(int)</code>, then the call <em>is</em> ambiguous. Why is <code>int</code> special?</p>\n<p>The only thing I can think of is that integral promotions are applied recursively, but nothing I see mandates it.</p>\n</hr>", "AcceptedAnswerId": "14208457", "Title": "Why does a value of an enum with a fixed underlying type of char resolve to fct(int) instead of fct(char)?", "CreationDate": "2013-01-08T00:22:53.297", "Id": "14206403", "CommentCount": "12", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:33:49.077", "LastEditorUserId": "-1", "LastActivityDate": "2015-04-12T02:16:32.957", "Score": "24", "OwnerUserId": "87234", "Tags": "<c++><c++11><enums><overloading><overload-resolution>", "AnswerCount": "2"}, "14216256": {"Id": "14216256", "PostTypeId": "2", "Body": "<p>According to my interpretation of the current standard, <strong>the call has to be ambiguous</strong>. Follows an explanation.</p>\n<p>Per 4.5/4: </p>\n<p><em>\"A prvalue of an unscoped enumeration type whose underlying type is fixed (7.2) can be converted to a prvalue of its underlying type. Moreover, if integral promotion can be applied to its underlying type, a prvalue of an unscoped enumeration type whose underlying type is fixed can also be converted to a prvalue of the promoted underlying type.\"</em></p>\n<p>This offers two alternative <em>promotions</em>: a promotion to the underlying type, and a promotion to the <em>promoted</em> underlying type. Hence, this paragraph alone introduces ambiguity as for <em>which</em> of these alternatives should be used when resolving a function call to overloaded functions. </p>\n<p>Then, paragraph 13.3.3 decides which is the best viable function of an overload set in terms of <strong>\"conversion sequence\"</strong>. In particular, relevant for this matter is 13.3.3.1 (\"<em>Implicit conversion sequences</em>\") and, more specifically, 13.3.3.1.1 (\"<em>Standard conversion sequences</em>\"), which defines what elementary steps these conversion sequences are made of.</p>\n<p>13.3.3.1.1/1 and Table 12 classify these steps into four categories, among which <em>Promotion</em> and <em>Conversion</em>, and rank conversion sequences based on the category of individual conversions that make up those sequences. </p>\n<p>In our case, we have <strong>two one-length conversion sequences made up of a single <em>Promotion</em></strong> step (both permitted by 4.5./4). </p>\n<p><strong>Conversion sequences are ranked</strong> according to 13.3.3.2. In particular, 13.3.3.2/3 mentions that a conversion sequence S1 is preferable to a conversion sequence S2 if:</p>\n<p><em>\"the rank</em> [i.e. Promotion, Conversion, etc.] <em>of S1 is <strong>better than the rank of</strong> S2, or S1 and S2 have the <strong>same rank and are distinguishable by the rules in the paragraph below</strong>, or, if not that, [...]\"</em></p>\n<p>The \"<em>paragraph below</em>\" being mentioned is 13.3.3.2/4, which says:</p>\n<p><em>\"Standard conversion sequences are ordered by their ranks: an Exact Match is a better conversion than a Promotion, which is a better conversion than a Conversion. <strong>Two conversion sequences with the same rank are indistinguishable unless one of the following rules applies</strong>:\"</em></p>\n<p>Then, what follows is a set of rules that <strong>do not apply</strong> in our situation. </p>\n<p>Therefore, we have two one-step conversion sequences made up of a single <em>Promotion</em> with the same rank. According to the above interpretation of the current standard, <strong>the call has to be ambiguous</strong>.</p>\n<p>Personally, however, I agree that a change is needed to make the conversion to the fixed underlying type of an unscoped enumeration preferable to other possible conversions.</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-01-08T21:22:55.403", "Score": "3", "CreationDate": "2013-01-08T13:42:58.633", "ParentId": "14206403", "CommentCount": "4", "OwnerUserId": "1932150", "LastEditDate": "2013-01-08T21:22:55.403"}});