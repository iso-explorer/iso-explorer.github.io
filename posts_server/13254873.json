post_cb({"13254873": {"CommentCount": "5", "ViewCount": "383", "CreationDate": "2012-11-06T16:05:06.690", "LastActivityDate": "2012-11-06T16:56:40.750", "Title": "Invoking conversion operators", "AcceptedAnswerId": "13255374", "PostTypeId": "1", "Id": "13254873", "Score": "11", "Body": "<p>What's the reason for the following behavior?</p>\n<pre><code>class BoolWrapper\n{\npublic:\n    BoolWrapper(bool value) : value(value) {}\n\n    operator bool() const { return value; }\n    operator int() const { return (int) value; }\n\nprivate:\n    bool value;\n};\n\n\nBoolWrapper bw(true);\n\nif (bw) { ... }            // invokes operator bool()\nif (bw == true) { ... }    // invokes operator int() -- why?\n</code></pre>\n<p>Is this behavior expected? (Using GCC 4.7.2.)</p>\n", "Tags": "<c++><operators>", "OwnerUserId": "1062139", "AnswerCount": "3"}, "13254998": {"ParentId": "13254873", "CommentCount": "1", "Body": "<p>From 5/9:</p>\n<blockquote>\n<p id=\"so_13254873_13254998_0\">Many binary operators that expect operands of arithmetic or\n  enumeration type cause conversions and yield result types in a similar\n  way. The purpose is to yield a common type, which is also the type of\n  the result. This pattern is called the usual arithmetic conversions,\n  which are defined as follows:</p>\n</blockquote>\n<p>[Some floating point items that don't matter.]</p>\n<blockquote>\n<p id=\"so_13254873_13254998_1\">Otherwise, the integral promotions (4.5) shall be performed on both\n  operands.</p>\n</blockquote>\n<p>And from 3.9.1/6 we see that bool is eligible for integral promotion:</p>\n<blockquote>\n<p id=\"so_13254873_13254998_2\">Values of type bool are either true or false.42) [Note: there are no\n  signed, unsigned, short, or long bool types or values. ] As described\n  below, bool values behave as integral types. Values of type bool\n  participate in integral promotions (4.5).</p>\n</blockquote>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "13254998", "Score": "6", "CreationDate": "2012-11-06T16:12:53.877", "LastActivityDate": "2012-11-06T16:12:53.877"}, "13255002": {"ParentId": "13254873", "CommentCount": "4", "Body": "<p>In the first case, an <code>if</code> clause expects a <code>bool</code> condition, so this is the selected conversion.</p>\n<p>In the second case, you are asking for a comparison between a <code>BoolWrapper</code> and a <code>bool</code>. Since no <code>operator ==</code> overload exists to do it, the compiler must convert these arguments into suitable ones. According to the standard (section 4.5, <em>Integral promotions</em>), the preferred integral type for conversions is <code>int</code>. Since both <code>BoolWrapper</code> and <code>bool</code> can be converted to <code>int</code>, this is the selected conversion.</p>\n", "OwnerUserId": "25824", "PostTypeId": "2", "Id": "13255002", "Score": "4", "CreationDate": "2012-11-06T16:13:05.180", "LastActivityDate": "2012-11-06T16:13:05.180"}, "13255374": {"ParentId": "13254873", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Your expectations are based on your belief that the language already knows how to compare two <code>bool</code> values. In reality it doesn't, however surprising it might sound. More precisely, the language \"does not know\" how to do it <em>directly</em>.</p>\n<p>At the conceptual level, C++ does not have a dedicated built-in equality comparison operator for <code>bool vs. bool</code> comparisons. Even when you write <code>true == false</code> in your code, it is really interpreted by the language as <code>(int) true == (int) false</code>. The implicit conversion to <code>int</code> is introduced by the rules of <em>usual arithmetic conversions</em> and <code>int vs. int</code> comparison is used afterwards.</p>\n<p>The most immediate built-in operator that can compare two <code>bool</code> values is the one for <code>int vs. int</code> comparison. This is the operator the compiler is trying to use in your case as well. The very same operator will be used for <code>char vs. char</code> and <code>short vs. short</code> comparisons.</p>\n<p>In other words, the only way the compiler can use your <code>bool</code> conversion operator in the <code>bw == true</code> expression would be to do</p>\n<pre><code>(int)(bool) bw == (int) true\n</code></pre>\n<p>This is certainly less \"optimal\" than the direct</p>\n<pre><code>(int) bw == (int) true\n</code></pre>\n<p>This is the logic that drives the language to select the latter variant.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2012-11-06T16:56:40.750", "Id": "13255374", "Score": "6", "CreationDate": "2012-11-06T16:33:25.977", "LastActivityDate": "2012-11-06T16:56:40.750"}, "bq_ids": {"n4140": {"so_13254873_13254998_0": {"section_id": 5943, "quality": 0.9032258064516129, "length": 28}, "so_13254873_13254998_1": {"section_id": 5943, "quality": 1.0, "length": 6}, "so_13254873_13254998_2": {"section_id": 7215, "quality": 0.6428571428571429, "length": 18}}, "n3337": {"so_13254873_13254998_0": {"section_id": 5714, "quality": 0.9032258064516129, "length": 28}, "so_13254873_13254998_1": {"section_id": 5714, "quality": 1.0, "length": 6}, "so_13254873_13254998_2": {"section_id": 6959, "quality": 0.6428571428571429, "length": 18}}, "n4659": {"so_13254873_13254998_0": {"section_id": 7428, "quality": 0.9032258064516129, "length": 28}, "so_13254873_13254998_1": {"section_id": 7428, "quality": 1.0, "length": 6}, "so_13254873_13254998_2": {"section_id": 8724, "quality": 0.6428571428571429, "length": 18}}}});