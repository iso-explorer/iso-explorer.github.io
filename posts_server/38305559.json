post_cb({"38305559": {"CommentCount": "2", "AcceptedAnswerId": "38306069", "CreationDate": "2016-07-11T11:14:54.433", "LastActivityDate": "2016-07-11T18:07:00.913", "PostTypeId": "1", "ViewCount": "241", "FavoriteCount": "1", "Title": "std::next with n > std::distance(it, c.end())", "Id": "38305559", "Score": "1", "Body": "<p>I do not want to use <code>std::distance</code> because it will calculate whole distance from my iterator to the end. But I need to be sure that I have N or more elements from my iterator to the end. So I'm using next code:  </p>\n<pre><code>if (std::next(it, n) != c.end()) // c is a std::multimap\n{\n    /// my logic\n}\n</code></pre>\n<p>Everything is great and working with my compiler (<code>g++ (GCC) 4.8.3 20140911 (Red Hat 4.8.3-9)</code>) but I have doubts. In documentation (cpprefenece.com &amp;&amp; cplusplus.com) I can not find any information about case when <code>n &gt; std::distance(it , c.end())</code> or about any other exceptional cases. So. Is my code safe? Or I should write my own <code>nextIfPossible</code>? </p>\n", "Tags": "<c++><c++11><stl>", "OwnerUserId": "658346", "AnswerCount": "3"}, "38306084": {"ParentId": "38305559", "PostTypeId": "2", "CommentCount": "12", "Body": "<p><strong><code>next(it, n)</code> is undefined behavior if <code>distance(it, c.end())</code> is less than <code>n</code>.</strong></p>\n<blockquote>\n<p id=\"so_38305559_38306084_0\">[C++14: 5.7/5] If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>See here for more info: <a href=\"https://stackoverflow.com/q/37209725/2642059\">Are iterators past the \"one past-the-end\" iterator undefined behavior?</a></p>\n<p>You <em>must</em> write a <code>nextIfPossible</code> or your code is undefined. That said, since I'm guessing this is a Random Access Iterator, you'll find working with indexes to benchmark faster than working with iterators in the case where bounds checking must be performed: <a href=\"https://stackoverflow.com/a/37299761/2642059\">https://stackoverflow.com/a/37299761/2642059</a> </p>\n<p>So I'd recommend not even bothering with iterators or <code>nextIfPossible</code> but just checking the index against the size.</p>\n", "OwnerUserId": "2642059", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:58:52.967", "Id": "38306084", "Score": "2", "CreationDate": "2016-07-11T11:42:35.653", "LastActivityDate": "2016-07-11T18:07:00.913"}, "38306182": {"ParentId": "38305559", "CommentCount": "0", "Body": "<p>The implementation of <code>RB_Tree::iterator</code> increment operator in <code>libstd++</code> makes sure it would not return an iterator to an undefined memory location:</p>\n<pre><code>static _Rb_tree_node_base*\n  local_Rb_tree_increment(_Rb_tree_node_base* __x) throw ()\n  {\n    if (__x-&gt;_M_right != 0)\n      {\n        __x = __x-&gt;_M_right;\n        while (__x-&gt;_M_left != 0)\n          __x = __x-&gt;_M_left;\n      }\n    else\n      {\n        _Rb_tree_node_base* __y = __x-&gt;_M_parent;\n        while (__x == __y-&gt;_M_right)\n          {\n            __x = __y;\n            __y = __y-&gt;_M_parent;\n          }\n        if (__x-&gt;_M_right != __y)\n          __x = __y;\n      }\n    return __x;\n  }\n</code></pre>\n<p>But the same is not true for <code>std::vector</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;iterator&gt;\n\nint main() {\n  std::vector&lt;int&gt; vec = {1,2};\n  auto it = vec.begin();\n  it = std::next(it, 5);\n  if (it != vec.end()) {\n    std::cout &lt;&lt; \"Not end..go on\" &lt;&lt; std::endl;\n  }\n  return 0;\n}\n</code></pre>\n<p>This will go on printing the message..</p>\n<p>So, since the behaviour is not same across containers, you should not depend on <code>std::next</code> for its current correct behaviour for <code>map</code> based containers.</p>\n", "OwnerUserId": "434233", "PostTypeId": "2", "Id": "38306182", "Score": "0", "CreationDate": "2016-07-11T11:48:06.267", "LastActivityDate": "2016-07-11T11:48:06.267"}, "bq_ids": {"n4140": {"so_38305559_38306084_0": {"section_id": 6142, "quality": 0.9130434782608695, "length": 21}, "so_38305559_38306069_1": {"section_id": 5595, "quality": 0.8333333333333334, "length": 5}, "so_38305559_38306069_0": {"section_id": 5594, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_38305559_38306084_0": {"section_id": 5906, "quality": 0.9130434782608695, "length": 21}, "so_38305559_38306069_1": {"section_id": 5378, "quality": 0.8333333333333334, "length": 5}, "so_38305559_38306069_0": {"section_id": 5377, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_38305559_38306069_1": {"section_id": 7039, "quality": 0.8333333333333334, "length": 5}, "so_38305559_38306069_0": {"section_id": 7038, "quality": 0.8333333333333334, "length": 5}}}, "38306069": {"ParentId": "38305559", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>According to the standard <em>\u00a724.4.4/p3 &amp; p6 Iterator operations [iterator.operations] (<strong>Emphasis Mine</strong>):</em></p>\n<blockquote>\n<pre><code>template &lt;class InputIterator, class Distance&gt;\nconstexpr void advance(InputIterator&amp; i, Distance n);\n</code></pre>\n<p id=\"so_38305559_38306069_0\"><sup>2</sup> Requires: n shall be negative only for bidirectional and random\n  access iterators. </p>\n<p id=\"so_38305559_38306069_1\"><sup>3</sup> <strong>Effects: Increments (or decrements for negative n)\n  iterator reference i by n.</strong></p>\n<pre><code>template &lt;class InputIterator&gt;\nconstexpr InputIterator next(InputIterator x,\ntypename std::iterator_traits&lt;InputIterator&gt;::difference_type n = 1);\n</code></pre>\n<p id=\"so_38305559_38306069_2\"><sup>6</sup> <strong>Effects: Equivalent to: <code>advance(x, n); return x;</code></strong></p>\n</blockquote>\n<p>Consequently, there's no bound checking and therefore you may result in undefined behaviour if input <code>n</code> is greater than <code>std::distance(it , c.end())</code>.</p>\n", "OwnerUserId": "2352671", "LastEditorUserId": "2352671", "LastEditDate": "2016-07-11T11:49:49.047", "Id": "38306069", "Score": "3", "CreationDate": "2016-07-11T11:41:53.797", "LastActivityDate": "2016-07-11T11:49:49.047"}});