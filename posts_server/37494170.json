post_cb({"37494222": {"ParentId": "37494170", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-05-28T00:56:32.010", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:52:47.610", "Id": "37494222", "OwnerUserId": "1621391", "Body": "<ul>\n<li><p>If <code>inum</code> was a <code>double</code>, your code will work because, your parameter is a <code>lvalue</code> (you can take its address).</p></li>\n<li><p>If your function signature was <code>void display(const double&amp; arg)</code> it will work, because your <em>promoted</em> parameter is a temporary and, you can bind a <code>const</code> reference to a temporary which extends its life time to the scope of the <code>const reference</code> identifier.</p></li>\n<li><p>If your function signature was <code>void display(double&amp;&amp; arg)</code> it will work, because your <em>promoted</em> parameter is a temporary and, you can bind a <code>rvalue</code> reference to a temporary which extends its life time to the scope of the <code>rvalue reference</code> identifier.</p></li>\n<li><p>The difference between the previous two methods above, is that you can modify <code>arg</code> in the latter, and its C++11 and above....</p></li>\n</ul>\n<p>In C++, You cannot bind a non const reference (specifically lvalue) to a temporary.</p>\n<p>What happens is that there is an <a href=\"http://en.cppreference.com/w/cpp/language/implicit_conversion\" rel=\"nofollow noreferrer\">implicit conversion</a> of <code>int</code> to <code>double</code></p>\n<p>Quoting <a href=\"https://stackoverflow.com/a/13827042/1621391\">Bo Personn's answer</a>:</p>\n<blockquote>\n<p id=\"so_37494170_37494222_0\">The original case for not allowing references to temporaries was for\n  function parameters. Suppose this was allowed:</p>\n<pre><code>void inc(double&amp; x)\n{ x += 0.1; }\n\nint i = 0;\ninc(i);\n</code></pre>\n<p id=\"so_37494170_37494222_1\">Why isn't i changed?</p>\n</blockquote>\n", "LastActivityDate": "2016-05-28T01:10:54.630"}, "37494194": {"ParentId": "37494170", "CommentCount": "0", "Body": "<p><code>double&amp;</code> is a reference to a double, which exists somewhere else. Usually you would use this to modify a variable which the caller provides. But, if the caller provides the address of an <code>int</code>, and you try to treat it like a <code>double</code>, things will go badly for you! The compiler also forbids calling a function like <code>void bar(double&amp;)</code> with a temporary, like <code>bar(3.14)</code>, because trying to modify a temporary value usually doesn't make sense.</p>\n<p>On the other hand, with <code>const double&amp;</code>, you promise not to change the value: you are only taking it by reference in order to avoid a copy, not to modify it. Therefore, it's okay to call <code>void foo(const double&amp;)</code> with a temporary, as in <code>foo(3.14)</code>: the compiler passes along the address of the temporary, <code>foo</code> dereferences it to get the value, and after <code>foo</code> returns the temporary disappears.</p>\n<p>So that's what's happening here: when the signature calls for a <code>const double&amp;</code>, and you provide an <code>int</code>, a temporary double is created (cast from the <code>int</code>), and its address is passed into <code>display</code>.</p>\n", "OwnerUserId": "2132213", "PostTypeId": "2", "Id": "37494194", "Score": "1", "CreationDate": "2016-05-28T00:51:53.587", "LastActivityDate": "2016-05-28T00:51:53.587"}, "37494170": {"CommentCount": "4", "CreationDate": "2016-05-28T00:46:10.887", "PostTypeId": "1", "AcceptedAnswerId": "37494202", "LastEditorUserId": "3600304", "LastActivityDate": "2016-05-28T01:14:37.970", "LastEditDate": "2016-05-28T01:10:56.653", "ViewCount": "198", "FavoriteCount": "1", "Title": "why const double reference can be assigned to int but not non const one?", "Id": "37494170", "Score": "0", "Body": "<p>Recently I have written one function which is doing some processing on double numbers but due to some change I need to do same processing for integers so to cut the long story short with simpler example as given below :</p>\n<pre><code>void display(double&amp; arg)\n{\n    std::cout &lt;&lt; arg &lt;&lt; std::endl;\n}\nint main()\n{\n    int inum = 10;\n    display(inum);\n    return 0;\n}\n</code></pre>\n<p>I found that above code is not compiling and giving error \"reference of type \"double &amp;\" (not const-qualified) cannot be initialized with a value of type \"int\", since the error is quite intuitive so i modified the code and changed the argument of display function to const double&amp; arg and everything seems to be working correctly.So my question is</p>\n<p><strong>What exactly is happening in the \"const double&amp;\" case? A full explanation is desired?</strong></p>\n<p>Now after reading some of the explanation and question link that is provided i understood that conversion produces rvalue and rvalue cannot be bound to temporaries so the only reasoning i m looking for is why conversion produces rvalue ?</p>\n", "Tags": "<c++><reference><const>", "OwnerUserId": "3600304", "AnswerCount": "3"}, "37494202": {"ParentId": "37494170", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2016-05-28T00:52:52.613", "Score": "3", "LastEditorUserId": "4505712", "LastEditDate": "2016-05-28T01:14:37.970", "Id": "37494202", "OwnerUserId": "4505712", "Body": "<p>Here's an example of the error I see: <code>error: invalid initialization of non-const reference of type 'double&amp;' from an rvalue of type 'double'</code></p>\n<p>It's clearly complaining about <code>double&amp;</code> (which is the parameter type of the <code>display</code> function) cannot be initialized with an rvalue of type <code>double</code>. Well, <code>inum</code> was passed to the function but it's type is <code>int</code>. However, <code>int</code> can be implicitly converted to <code>double</code> and this is happening. The conversion produces an <code>rvalue</code> (i.e., temporary) <code>double</code> <strong>but a temporary cannot be bound to a non-const reference</strong>.</p>\n<hr>\n<p>Changing it to <code>void display(const double&amp; arg)</code> works because everything works the same as explained above. However, an rvalue <strong>can be bound to a <em>const</em> reference</strong>.</p>\n<hr>\n<p>I don't have the official standard but the following quotes are from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">n4296 draft</a>:</p>\n<blockquote>\n<p id=\"so_37494170_37494202_0\"><strong>4 Standard conversions [conv]</strong></p>\n<p id=\"so_37494170_37494202_1\"><sup>1</sup> Standard conversions are implicit conversions with built-in meaning. Clause 4 enumerates the full set of such\n  conversions. A standard conversion sequence is a sequence of standard conversions in the following order:</p>\n<p id=\"so_37494170_37494202_2\"><sup>(1.1)</sup> \u2014 Zero or one conversion from the following set: lvalue-to-rvalue conversion, array-to-pointer conversion, and function-to-pointer conversion.</p>\n<p id=\"so_37494170_37494202_3\"><sup>3</sup> An expression e can be implicitly converted to a type T if and only if the declaration T t=e; is well-formed,\n  for some invented temporary variable t (8.5).</p>\n<p id=\"so_37494170_37494202_4\"><sup>6</sup> The effect of any implicit conversion is the same as performing the corresponding declaration and initialization\n  and then using the temporary variable as the result of the conversion.</p>\n</blockquote>\n</hr></hr>", "LastActivityDate": "2016-05-28T01:14:37.970"}, "bq_ids": {"n4140": {"so_37494170_37494202_2": {"section_id": 0, "quality": 1.0, "length": 11}, "so_37494170_37494202_4": {"section_id": 5, "quality": 0.9333333333333333, "length": 14}, "so_37494170_37494202_3": {"section_id": 2, "quality": 0.9090909090909091, "length": 10}, "so_37494170_37494202_1": {"section_id": 0, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_37494170_37494202_2": {"section_id": 0, "quality": 1.0, "length": 11}, "so_37494170_37494202_4": {"section_id": 2, "quality": 0.8666666666666667, "length": 13}, "so_37494170_37494202_3": {"section_id": 2, "quality": 0.9090909090909091, "length": 10}, "so_37494170_37494202_1": {"section_id": 0, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_37494170_37494202_3": {"section_id": 2, "quality": 0.9090909090909091, "length": 10}, "so_37494170_37494202_2": {"section_id": 0, "quality": 1.0, "length": 11}, "so_37494170_37494202_4": {"section_id": 5, "quality": 0.9333333333333333, "length": 14}, "so_37494170_37494202_1": {"section_id": 0, "quality": 0.9444444444444444, "length": 17}}}});