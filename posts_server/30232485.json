post_cb({"30234634": {"ParentId": "30232485", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-05-14T10:10:46.950", "Score": "3", "LastEditorUserId": "1938163", "LastEditDate": "2015-05-14T13:18:21.937", "Id": "30234634", "OwnerUserId": "1938163", "Body": "<p>To make some clarity.. this version of the code compiles just fine on clang and gcc</p>\n<pre><code>class Base                                                                      \n{                                                                               \npublic:                                                                         \n    static void foo() {}                                                        \n    void badfoo(int a) {}                                                       \n};                                                                              \n\ntemplate &lt;typename T&gt;                                                           \nclass Derived : public Base                                                     \n{                                                                               \npublic:                                                                         \n    void bar() { Base::foo(); }                                                 \n    void badbar() { Base::badfoo(); }   \n}; \n</code></pre>\n<p>since</p>\n<p><em>[temp.res]/p8</em></p>\n<blockquote>\n<p id=\"so_30232485_30234634_0\">If no valid specialization can\n  be generated for a template, and that template is not instantiated, the template is ill-formed, no diagnostic\n  required.</p>\n</blockquote>\n<p>Both gcc and clang <strong>aren't required to diagnose this</strong>. This one also falls in the same case as above (clang emits an error, gcc doesn't)</p>\n<pre><code>class Base                                                                      \n{                                                                               \npublic:                                                                         \n    static void foo() {}                                                        \n    void badfoo(int a) {}                                                   \n};                                                                              \n\ntemplate &lt;typename T&gt;                                                           \nclass Derived : public Base                                                     \n{                                                                               \npublic:                                                                         \n    void bar() { Base::foo(); }                                                 \n    static void badbar() { Base::badfoo(); } \n}; \n</code></pre>\n<p>The case with </p>\n<pre><code>void worsebar() { Base::nonexist(); }\n</code></pre>\n<p>is different since <strong>it violates name lookup</strong> <em>[temp.res]/p9</em></p>\n<blockquote>\n<p id=\"so_30232485_30234634_1\">When looking for the declaration of a name used in a template definition, the usual lookup rules (3.4.1,\n  3.4.2) are used for non-dependent names</p>\n</blockquote>\n<p>and <em>[temp.res]/p10</em></p>\n<blockquote>\n<p id=\"so_30232485_30234634_2\">If a name does not depend on a template-parameter (as defined in 14.6.2), a declaration (or set of declarations)\n  for that name shall be in scope at the point where the name appears in the template definition</p>\n</blockquote>\n<p>Disclaimer: all of the above does not apply to MSVC which happily postpones all this stuff to the second phase of the lookup.</p>\n<hr>\n<p>Edit:</p>\n<p>in the case </p>\n<pre><code>class Base                                                                      \n{                                                                               \npublic:                                                                         \n    static void foo() {}                                                        \n    void badfoo(int i) {}                                                       \n};                                                                              \n\ntemplate &lt;typename T&gt;                                                           \nclass Derived : public Base                                                     \n{                                                                               \npublic:                                                                         \n    static void badbar() { Base::badfoo(); }  // static function\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/566837f94eb6baf8\" rel=\"nofollow\">clang triggers an error</a> while <a href=\"http://coliru.stacked-crooked.com/a/c2cadd7274d06a49\" rel=\"nofollow\">gcc doesn't</a>. This falls in the first case since name lookup is successful but clang performs an additional check: since <code>badfoo</code> is a member function it tries to construct a valid implicit member reference expression. It then catches the fact that a member function is implicitly being called from a static function and detects the context mismatch. This diagnostic is entirely up to the compiler at this point (it wouldn't in case of an instantiation).</p>\n</hr>", "LastActivityDate": "2015-05-14T13:18:21.937"}, "30232485": {"CommentCount": "8", "AcceptedAnswerId": "30233005", "PostTypeId": "1", "LastEditorUserId": "1068497", "CreationDate": "2015-05-14T08:14:51.547", "LastActivityDate": "2016-04-11T21:21:24.570", "LastEditDate": "2015-05-18T08:21:39.540", "ViewCount": "1095", "FavoriteCount": "5", "Title": "What does a compiler check for uninstantiated template code?", "Id": "30232485", "Score": "29", "Body": "<p>For example, the following code piece compiles with gcc-4.9 and clang-602</p>\n<pre><code>class Base                                                                      \n{                                                                               \npublic:                                                                         \n    static void foo() {}                                                        \n    void badfoo(int i) {}                                                       \n};                                                                              \n\ntemplate &lt;typename T&gt;                                                           \nclass Derived : public Base                                                     \n{                                                                               \npublic:                                                                         \n    void bar() { Base::foo(); }                                                 \n    void badbar() { Base::badfoo(); }  // compiles ok\n    //static void badbar() { Base::badfoo(); }  // compile error                                                                                    \n    //void worsebar() { Base::nonexist(); }  // compile error                                   \n};                                                                              \n\nint main()                                                                      \n{                                                                               \n    return 0;                                                                   \n}  \n</code></pre>\n<p>But the commented out lines won't compile. </p>\n<p>My questions are:</p>\n<ol>\n<li><p>Why <code>badbar()</code> compiles but <code>worsebar()</code> doesn't ?</p></li>\n<li><p>If I change <code>badbar()</code> to static it won't compile either, regardless if <code>base::badfoo</code> is static or not.</p></li>\n<li><p>Does the standard say anything about what should be checked in this situation ? gcc4.4 actually refuses to compile even <code>badbar()</code>.</p></li>\n</ol>\n<p>Update: </p>\n<p>Problem 1 has been explained by a number of answers, but it seems compilers sometimes go the extra mile to check overload as well, it happens to gcc 4.4.3 and 4.8.2, but not 4.7.2 and 4.9.1.</p>\n<p>Problem 2: As Marco A. pointed out, clang won't compile but gcc4.9 will still pass. However, gcc4.2 and gcc4.4 both reject the code, and the error they are complaining is \"no matching function\" rather than \"calling non-static member without an object\" in clang. There's seems to be no conclusive answer to this question, so I'm adding a language-lawyer tag as Daniel Frey suggested.</p>\n<p>More Update:</p>\n<p>I think for question 2 the answer is pretty clear now: it's up to the compiler whether adding static declaration will change the diagnosis. It varies from compiler to compiler and different versions of the same compiler. The language lawyer didn't show up, I'm going to accept Daniel Frey's answer as it best explained the first question. But answers from Marco A. and Hadi Brais also worth reading.</p>\n", "Tags": "<c++><templates><gcc><clang><language-lawyer>", "OwnerUserId": "1068497", "AnswerCount": "5"}, "30232943": {"ParentId": "30232485", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-05-14T08:43:32.980", "Score": "7", "LastEditorUserId": "3647361", "LastEditDate": "2016-04-11T21:21:24.570", "Id": "30232943", "OwnerUserId": "3647361", "Body": "<p>Consider [temp.res]/8:</p>\n<blockquote>\n<p id=\"so_30232485_30232943_0\">If no valid specialization can be generated for a template, and that\n  template is not instantiated, the template is ill-formed, no\n  diagnostic required.</p>\n</blockquote>\n<p>This (in particular the \"no diagnostic required\" bit) makes any compiler's behaviour compliant with respect to <code>worsebar</code>. Implementations' discrepancies on this kind of code are just QoI issues - common compilers do some analysis and will complain. It is hard to say when exactly, and you should be prepared to come back to template code when upgrading or switching your implementation.</p>\n", "LastActivityDate": "2016-04-11T21:21:24.570"}, "30233005": {"ParentId": "30232485", "CommentCount": "6", "CreationDate": "2015-05-14T08:47:15.947", "OwnerUserId": "2073257", "PostTypeId": "2", "Id": "30233005", "Score": "14", "Body": "<p>The standard only requires the name-lookup to happen at phase 1, when the template is first parsed. This turns up <code>badfoo</code> in <code>badbar</code> which is why the code compiles. The compiler is not required to do the overload resolution at that time.</p>\n<p>The overload resolution (which always happens as a separate step <em>after</em> the name lookup) is then performed in phase 2 when <code>badbar</code> is instantiated - which is not the case in your example. This principle can be found in</p>\n<blockquote>\n<h3>3.4 Name lookup [basic.lookup]</h3>\n<p id=\"so_30232485_30233005_0\"><sup>1</sup> The name lookup rules apply uniformly to all names (including <em>typedef-names</em> (7.1.3), <em>namespace-names</em> (7.3), and <em>class-names</em> (9.1)) wherever the grammar allows such names in the context discussed by a particular rule. Name lookup associates the use of a name with a declaration (3.1) of that name. Name lookup shall find an unambiguous declaration for the name (see 10.2). Name lookup may associate more than one declaration with a name if it finds the name to be a function name; the declarations are said to form a set of overloaded functions (13.1). <strong>Overload resolution (13.3) takes place after name lookup has succeeded.</strong> The access rules (Clause 11) are considered only once name lookup and function overload resolution (if applicable) have succeeded. Only after name lookup, function overload resolution (if applicable) and access checking have succeeded are the attributes introduced by the name\u2019s declaration used further in expression processing (Clause 5).</p>\n</blockquote>\n<p>(Emphasis mine)</p>\n<p>I'd therefore say that the compiler(s) are correct to accept the code, although I'm not sure that they are required to do so.</p>\n<p>To see the code <a href=\"http://coliru.stacked-crooked.com/a/5689889e45edc565\">being rejected</a>, you need instantiate <code>badbar</code>.</p>\n", "LastActivityDate": "2015-05-14T08:47:15.947"}, "30232985": {"ParentId": "30232485", "CommentCount": "4", "CreationDate": "2015-05-14T08:46:02.500", "OwnerUserId": "4482870", "PostTypeId": "2", "Id": "30232985", "Score": "1", "Body": "<p>At first if you would instantiate <code>Devired</code> and try to call <code>badbar</code> there would be a compilation error:</p>\n<pre><code>// ...\nint main()                                                                      \n{                                                                               \n    Derived&lt;int&gt; d;\n    d.badbar();\n    return 0;                                                                   \n}\n</code></pre>\n<p>produces</p>\n<pre><code>error: too few arguments to function call, single argument 'i' was not specified\nvoid badbar() { Base::badfoo(); }  // compiles ok\n                ~~~~~~~~~~~~ ^\n</code></pre>\n<p>The compiler doesn't compile the code, that is not instantiated.</p>\n", "LastActivityDate": "2015-05-14T08:46:02.500"}, "30233665": {"ParentId": "30232485", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-05-14T09:23:25.123", "Score": "2", "LastEditorUserId": "4230618", "LastEditDate": "2015-05-14T19:48:10.277", "Id": "30233665", "OwnerUserId": "4230618", "Body": "<p>Before it instantiates any types or emits any code, the compiler incrementally builds a table of all symbols that have been declared. If an undeclared  symbol has been used, it emits an error. That's why worsebar won't compile. On the other hand, badfoo has been declared and so badbar compiles. At this early point in the compilation process, the compiler won't check whether the call to badfoo actually matches the declared badfoo.</p>\n<p>Since the Derived type has not been instantiated anywhere in the code, the compiler will not emit any code regarding it. In particular, badbar will just be neglected.</p>\n<p>Now when you declare an instance of Derived (such as Derived&lt; int &gt;) but without using any of its members, the compiler will just create a type with those members that have been used and omit the others. Still, no error regarding badbar.</p>\n<p>However, when declaring an instance of Derived and calling badbar, an instantiation of the badbar method would be required and so the compiler will create a type with badbar and compile it. This time, the compiler notices that badfoo is not actually declared and therefore emits an error.</p>\n<p>This behavior is documented in the C++ standard in section 14.7.1.</p>\n<blockquote>\n<p id=\"so_30232485_30233665_0\">Unless a member of a class template or a member template has been explicitly instantiated or explicitly specialized, the specialization of the member is implicitly instantiated when the specialization is referenced in a context that requires the member definition to exist.</p>\n</blockquote>\n<p>Finally, if badbar was static and was instantiated by the compiler (because it has been used) then the compiler will emit an error that badfoo does not exist. Now if you pass an integer argument to badfoo, another error will be emitted indicating that a static method cannot access an instance member because there is no instance in the first place.</p>\n<p><strong>Edit</strong></p>\n<p>The compiler is not obliged to NOT report semantic errors in uninstantiated template types. The standard just says that it does not have to, but it can. Regarding where to draw the line is open for debate. See <a href=\"http://lists.cs.uiuc.edu/pipermail/cfe-dev/2011-December.txt\" rel=\"nofollow\">this</a> discussion about a related issue in clang:</p>\n<blockquote>\n<p id=\"so_30232485_30233665_1\">which uninstantiated templates do we analyze?  For performance reasons, I don't think we should analyze all the uninstantiated templates, as we may find ourselves repeatedly analyzing a huge portion of the Boost and the STL, etc.</p>\n</blockquote>\n<p>So uninstantiated templates analysis changes with different versions of clang and gcc in different ways. But again, as per the standard: <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=21008\" rel=\"nofollow\">There's no requirement to report errors in uninstantiated templates, of course.</a></p>\n", "LastActivityDate": "2015-05-14T19:48:10.277"}, "bq_ids": {"n4140": {"so_30232485_30234634_2": {"section_id": 177, "quality": 0.9411764705882353, "length": 16}, "so_30232485_30232943_0": {"section_id": 175, "quality": 1.0, "length": 11}, "so_30232485_30233665_0": {"section_id": 234, "quality": 0.9565217391304348, "length": 22}, "so_30232485_30233005_0": {"section_id": 7083, "quality": 0.9292929292929293, "length": 92}, "so_30232485_30234634_0": {"section_id": 175, "quality": 1.0, "length": 11}, "so_30232485_30234634_1": {"section_id": 176, "quality": 0.8461538461538461, "length": 11}}, "n3337": {"so_30232485_30234634_2": {"section_id": 171, "quality": 0.9411764705882353, "length": 16}, "so_30232485_30232943_0": {"section_id": 169, "quality": 1.0, "length": 11}, "so_30232485_30233665_0": {"section_id": 227, "quality": 0.9565217391304348, "length": 22}, "so_30232485_30233005_0": {"section_id": 6827, "quality": 0.9292929292929293, "length": 92}, "so_30232485_30234634_0": {"section_id": 169, "quality": 1.0, "length": 11}, "so_30232485_30234634_1": {"section_id": 170, "quality": 0.8461538461538461, "length": 11}}, "n4659": {"so_30232485_30234634_2": {"section_id": 182, "quality": 0.9411764705882353, "length": 16}, "so_30232485_30232943_0": {"section_id": 180, "quality": 0.8181818181818182, "length": 9}, "so_30232485_30233665_0": {"section_id": 244, "quality": 0.9565217391304348, "length": 22}, "so_30232485_30234634_0": {"section_id": 180, "quality": 0.8181818181818182, "length": 9}, "so_30232485_30234634_1": {"section_id": 181, "quality": 0.8461538461538461, "length": 11}, "so_30232485_30233005_0": {"section_id": 8584, "quality": 0.7272727272727273, "length": 72}}}});