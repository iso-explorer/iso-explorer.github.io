post_cb({"bq_ids": {"n4140": {"so_21474111_21474111_0": {"length": 8, "quality": 1.0, "section_id": 48}}, "n3337": {"so_21474111_21474111_0": {"length": 6, "quality": 0.75, "section_id": 43}}, "n4659": {"so_21474111_21474111_0": {"length": 7, "quality": 0.875, "section_id": 49}}}, "21482264": {"Id": "21482264", "PostTypeId": "2", "Body": "<p>EDIT: The <a href=\"https://stackoverflow.com/questions/21474111/variable-template-at-class-scope/21482264?noredirect=1#comment32627331_21482264\">committee has spoken</a>, Clang is correct to require the <code>static</code> keyword for static data member templates. The examples given in 14/1 are <em>not</em> correct.  Hopefully, the next revision of the working draft will remove the ambiguity from the text.</p>\n<p><hr>\nThis <em>seems</em> to be a bug in Clang, but the wording in the draft standard is ambiguous. I believe the intention is that the keyword <code>static</code> is implicit. If that was not the intention, presumably the standard wording would be more along the lines of \"A variable template at class scope <strong><em>must be</em></strong> a static data member template.\" instead of \"A variable template at class scope <strong><em>is</em></strong> a static data member template.\" (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">N3797</a> \u00a714/1) The (admittedly non-normative) example given in \u00a714/1 declares three class member variable templates, none with the <code>static</code> keyword:</hr></p>\n<pre><code>struct matrix_constants {\n  template&lt;class T&gt;\n   using pauli = hermitian_matrix&lt;T, 2&gt;;\n  template&lt;class T&gt;\n   constexpr pauli&lt;T&gt; sigma1 = { { 0, 1 }, { 1, 0 } };\n  template&lt;class T&gt;\n   constexpr pauli&lt;T&gt; sigma2 = { { 0, -1i }, { 1i, 0 } };\n  template&lt;class T&gt;\n   constexpr pauli&lt;T&gt; sigma3 = { { 1, 0 }, { -1, 0 } };\n};\n</code></pre>\n<p>The example in <strong>14.5.1.3 Static data members of class templates [temp.static]/1</strong> notably <em>does</em> use <code>static</code>:</p>\n<pre><code>struct limits {\n  template&lt;class T&gt;\n    static const T min; // declaration\n};\n\ntemplate&lt;class T&gt;\n  const T limits::min = { }; // definition\n</code></pre>\n<p>so at the very least it's not forbidden to do so.</p>\n<p>As <a href=\"https://stackoverflow.com/questions/21474111/variable-template-at-class-scope/21482264?noredirect=1#comment32613609_21482264\">@RichardSmith states in his comment</a>, the actual <em>normative</em> text of the section contradicts the example. They write Clang to the text of the standard, so the example is diagnosed as ill-formed. <a href=\"https://groups.google.com/a/isocpp.org/forum/#!topic/std-proposals/ZTw3W3vjWWs\" rel=\"nofollow noreferrer\">The committee is aware that the wording for variable templates needs some help in various places</a>, so I'm sure there will be some cleanup in the next draft / C++14.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-02-06T21:38:47.773", "Score": "4", "CreationDate": "2014-01-31T14:20:20.033", "ParentId": "21474111", "CommentCount": "3", "LastEditDate": "2017-05-23T12:24:11.837", "OwnerUserId": "923854"}, "21474112": {"Id": "21474112", "PostTypeId": "2", "Body": "<p>If you try the first example, clang coughs up the magic error right away:</p>\n<pre><code>template &lt;typename T, size_t N&gt;\nstruct hermitian_matrix { };\n\nstruct foo\n{\n    template &lt;typename T&gt;\n    using pauli = hermitian_matrix&lt;T, 2&gt;;\n\n    template &lt;typename T&gt;\n    constexpr pauli&lt;T&gt; sigma1 = { { 0, 1 }, { 1, 0 } };\n};\n\nerror: non-static data member cannot be constexpr; did you intend to make it static?\n</code></pre>\n<p>Apparently at class scope, variable templates need to be declared static. clang doesn't cough up the right error unless you declare it constexpr, which can be misleading. As well as that, their example of a static data member:</p>\n<pre><code>struct foo\n{\n    template &lt;typename T&gt;\n    static T bar;\n};\n\ntemplate &lt;typename T&gt;\nT foo::bar = T{3.14};\n</code></pre>\n<p>may throw you off because one might think that the whole point of variable member templates is to replace static data members.</p>\n", "OwnerDisplayName": "user1508519", "LastActivityDate": "2014-01-31T06:49:56.213", "Score": "0", "CreationDate": "2014-01-31T06:49:56.213", "ParentId": "21474111", "CommentCount": "0"}, "21474111": {"ViewCount": "658", "Body": "<p>Using <a href=\"http://isocpp.org/files/papers/N3651.pdf\" rel=\"nofollow\">N3651</a> as a basis, </p>\n<blockquote>\n<p id=\"so_21474111_21474111_0\">A variable template at class scope is a <em>static data member\n  template</em>.</p>\n</blockquote>\n<p>The example given is:</p>\n<pre><code>struct matrix_constants {  \n template &lt;typename T&gt;   \n  using pauli = hermitian_matrix&lt;T, 2&gt;;\n</code></pre>\n<p>Yet all of the following definitions give an error:</p>\n<pre><code>struct foo\n{\n    template &lt;typename T&gt;\n    T pi = T{3.14};\n};\n\ntemplate &lt;typename T&gt;\nstruct foo2\n{\n    template &lt;typename U = T&gt;\n    U pi = U{3.14};\n};\n\ntemplate &lt;typename T&gt;\nstruct foo3\n{\n    template &lt;T&gt;\n    T pi = 42;\n};\n\nerror: member 'pi' declared as a template\n</code></pre>\n<p>What gives?</p>\n", "AcceptedAnswerId": "21482264", "Title": "Variable template at class scope", "CreationDate": "2014-01-31T06:49:56.213", "Id": "21474111", "CommentCount": "1", "LastEditDate": "2015-06-16T13:20:45.520", "PostTypeId": "1", "OwnerDisplayName": "user1508519", "LastEditorUserId": "895245", "LastActivityDate": "2015-06-16T13:20:45.520", "Score": "2", "Tags": "<c++><c++14><variable-templates>", "AnswerCount": "2"}});