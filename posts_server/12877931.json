post_cb({"12877931": {"ViewCount": "986", "Body": "<p>I've started playing around with <code>extern</code> templates a bit and I've stumbled on an issue which I can't find any relevant information on. Say I have a class template with a non-template friend function (defined within the class template declaration). I declare some <code>extern</code> template instantiations for the class, but how do I declare the friend function as extern too?</p>\n<p>Here is some example code:</p>\n<pre><code>// --- test.h ---\n\ntemplate &lt;typename T&gt;\nclass Foo {\n  private:\n    T value;\n  public:\n    friend void some_friend_function(Foo&lt;T&gt;&amp; obj) {\n      obj.value -= T(42);\n    };\n\n    void some_member_function(T rhs) { value += rhs; };\n\n};\n\nextern template class Foo&lt;int&gt;;\n//extern void some_friend_function(Foo&lt;int&gt;&amp;);  // I tried this also...\n\n\n// --- test.cpp ---\n\n#include \"test.h\"\n\ntemplate class Foo&lt;int&gt;;\n//void some_friend_function(Foo&lt;int&gt;&amp;);         // ... with this.\n</code></pre>\n<p>When I compile the above (with or without the commented lines), I only get the following exported symbol:</p>\n<pre><code>0000000000000000 W _ZN3FooIiE20some_member_functionEi\n</code></pre>\n<p>So, the non-template friend functions definitely don't get instantiated (and <code>extern</code>'d) along with the class template's explicit instantiation. Is this normal? At least, that's what GCC produces (tested on 4.6.3 and 4.7.2). </p>\n<p>Is there any way that I can get the friend function to be marked extern? I know that this isn't a huge problem, since I can happily live with the friend functions being instantiated as needed (i.e., non-extern), but I'm curious to know if there is a way to do this, if not, was it an oversight or a deliberate thing?</p>\n<p><strong>EDIT: The obvious workarounds</strong></p>\n<p>My question is specifically about non-template friend functions, not about finding a workaround to avoid the issue, which is trivial. The first obvious workaround is this:</p>\n<pre><code>template &lt;typename T&gt;\nclass Foo {\n  private:\n    T value;\n  public:\n    template &lt;typename U&gt;\n    friend void some_friend_function(Foo&lt;U&gt;&amp; obj) {\n      obj.value -= T(42);\n    };\n};\n\nextern template class Foo&lt;int&gt;;\nextern template void some_friend_function(Foo&lt;int&gt;&amp;);\n\n// --- in cpp file: ---\n\ntemplate class Foo&lt;int&gt;;\ntemplate void some_friend_function(Foo&lt;int&gt;&amp;);\n</code></pre>\n<p>And another, which matches more closely but is more troublesome, is this:</p>\n<pre><code>template &lt;typename T&gt; class Foo;  // forward-declare.\n\ntemplate &lt;typename T&gt;\nvoid some_friend_function(Foo&lt;T&gt;&amp;);  // declaration.\n\ntemplate &lt;typename T&gt;\nclass Foo {\n  private:\n    T value;\n  public:\n    friend void some_friend_function&lt;&gt;(Foo&lt;T&gt;&amp; obj);  // befriend the T-specialization.\n};\n\ntemplate &lt;typename T&gt;\nvoid some_friend_function(Foo&lt;T&gt;&amp; obj) {  // definition.\n  obj.value -= T(42);\n};\n\nextern template class Foo&lt;int&gt;;\nextern template void some_friend_function(Foo&lt;int&gt;&amp;);\n\n// --- in cpp file: ---\n\ntemplate class Foo&lt;int&gt;;\ntemplate void some_friend_function(Foo&lt;int&gt;&amp;);\n</code></pre>\n", "AcceptedAnswerId": "13204220", "Title": "Extern template class and non-template friend functions", "CreationDate": "2012-10-13T23:27:05.630", "Id": "12877931", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-10-14T04:53:09.913", "LastEditorUserId": "491645", "LastActivityDate": "2012-11-02T23:03:27.863", "Score": "4", "OwnerUserId": "491645", "Tags": "<c++><templates><c++11><extern>", "AnswerCount": "1"}, "13204220": {"Id": "13204220", "PostTypeId": "2", "Body": "<p>The effect of an \"extern template class\" is to declare an explicit instantiation to be available. The effect of explicit instantiation declarations do not apply to inline functions or template specializations (14.7.2 [temp.explicit] paragraph 10):</p>\n<blockquote>\n<p id=\"so_12877931_13204220_0\">Except for inline functions and class template specializations, explicit instantiation declarations have the effect of suppressing the implicit instantiation of the entity to which they refer.</p>\n</blockquote>\n<p>Since a <code>friend</code> function definition within a class definition is necessarily an <code>inline</code> function, it will stay an <code>inline</code> function independent of the explicit instantiation declaration of the template (and, as you correctly noted, it isn't a template and doesn't follow template instantiation rules anyway).</p>\n", "LastActivityDate": "2012-11-02T23:03:27.863", "CommentCount": "0", "CreationDate": "2012-11-02T23:03:27.863", "ParentId": "12877931", "Score": "0", "OwnerUserId": "1120273"}, "bq_ids": {"n4140": {"so_12877931_13204220_0": {"length": 17, "quality": 1.0, "section_id": 259}}, "n3337": {"so_12877931_13204220_0": {"length": 17, "quality": 1.0, "section_id": 250}}, "n4659": {"so_12877931_13204220_0": {"length": 17, "quality": 1.0, "section_id": 266}}}});