post_cb({"47991202": {"Id": "47991202", "PostTypeId": "2", "Body": "<p>In the C++ standard defines the term <em>forwarding reference</em>. A suppose <em>universal reference</em> is used as a synonym for this term. <a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp.deduct.call#3\" rel=\"nofollow noreferrer\">[temp.deduct.call]/3</a></p>\n<blockquote>\n<p id=\"so_47986284_47991202_0\">A <em>forwarding reference</em> is an rvalue reference to a cv-unqualified template parameter that does not represent a template parameter of a class template.</p>\n</blockquote>\n<p>This concept only apply to template function argument or template constructor argument. In all other cases, <code>T&amp;&amp;</code> is a <em>rvalue reference</em>. The concept of <em>forwarding reference</em> is only usefull for template argument deduction. Let's consider that in the following examples, all the fonctions and constructors are called with an <code>int</code> argument (independently of its constness and value categories (lvalue/rvalue):</p>\n<pre><code>//possibilities of argument deduction, [cv] means any combination of \"const\" and \"volatile\": \n//  &lt;\"\",\"const\",\"volatile\",\"const volatile\"&gt;\ntemplate&lt;class T&gt; void f(T&amp;);\n  //4 possibilities: void f([cv] int&amp;);\n\ntemplate&lt;class T&gt; void f(const T&amp;);\n  //2 possibilities: void f(const int&amp;);\n                   //void f(const volatile int&amp;);\n\ntemplate&lt;class T&gt; void f(T&amp;&amp;);\n  //Forwarding reference, 8 possibilities\n            //void f([cv] int&amp;);\n            //void f([cv] int&amp;&amp;);\n\ntemplate&lt;class T&gt; void f(const T&amp;&amp;);\n  //NOT a forwarding reference because of the const qualifier, 2 possibilities:\n            //void f(const int&amp;&amp;);\n            //void f(const volatile int&amp;&amp;);\n\ntemplate&lt;class T&gt;\nstruct S{\n    template&lt;class U&gt;\n    S(U&amp;&amp;);\n      //Forwarding reference, 8 posibilities:\n            //void S&lt;X&gt;([cv] int&amp;);\n            //void S&lt;X&gt;([cv] int&amp;&amp;);\n      //no template argument deduction posible\n\n    S(T&amp;&amp;);\n      //NOT a forwarding reference, 1 possibility:\n            //void S&lt;X&gt;(X&amp;&amp;);\n      //Generated argument deduction:\n         //template&lt;class T&gt; S(T&amp;&amp;) -&gt; S&lt;T&gt;;\n           //not a forwarding reference because T is a parameter of the template class; \n           //=&gt; 4 possibilities: -&gt; S&lt;[cv] int&amp;&amp;&gt;\n\n\n    T&amp;&amp; a; //an rvalue reference if T is [cv] int or [cv] int&amp;&amp;,\n           //an lvalue reference if T is [cv] int&amp;;\n           //This comes from reference colapsing rules: &amp;+&amp;=&amp;; &amp;&amp;+&amp;=&amp;; &amp;&amp;+&amp;&amp;=&amp;&amp;       //(Nota: You may consider that a rvalue reference data member is probably a mistake)\n };\n\ntemplate&lt;class U&gt;\nS(U&amp;&amp;) -&gt; S&lt;U&amp;&amp;&gt;;\n //Forwarding reference, 8 possibilities:\n //   S&lt;[cv] int&amp;&gt;;\n //   S&lt;[cv] int&amp;&amp;&gt;;\n</code></pre>\n<p>Using <code>std::forward</code> make sense only inside the body of a function or a constructor if the argument of <code>std::forward</code> can either be a rvalue reference or a lvalue reference, depending on template argument deduction and reference collapsing rules. If <code>std::forward</code>'s argument always results in a rvalue reference, <code>std::move</code> is prefered, and if it always results in a lvalue reference, nothing is prefered.</p>\n", "LastEditorUserId": "5632316", "LastActivityDate": "2017-12-27T11:33:00.643", "Score": "1", "CreationDate": "2017-12-27T11:16:15.603", "ParentId": "47986284", "CommentCount": "0", "OwnerUserId": "5632316", "LastEditDate": "2017-12-27T11:33:00.643"}, "bq_ids": {"n4140": {"so_47986284_47991202_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 341}}, "n3337": {"so_47986284_47991202_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 331}}, "n4659": {"so_47986284_47991202_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 311}}}, "47986284": {"ViewCount": "88", "Body": "<p>I would like to understand how deductions guides work with universal references and <code>std::forward</code>, in particular to create perfectly forwarding wrappers. The code below provides a code to experiment with a functor wrapper in two cases: one with an implicit deduction guide and one with an explicit deduction guide. </p>\n<p>I have put a lot of <code>&amp;&amp;</code> and <code>std::forward</code> in comments, because I do not know where they are needed to achieve perfect forwarding. I would like to know where to put them, and where they are not needed.</p>\n<pre><code>// Case with not conversion constructor\ntemplate &lt;class F&gt;\nstruct functor1\n{\n    explicit constexpr functor1(F/*&amp;&amp;*/ f) \n    noexcept(std::is_nothrow_copy_constructible_v&lt;F/*&amp;&amp;*/&gt;)\n    : _f(/*std::forward&lt;F&gt;(*/f/*)*/) \n    {}\n    template &lt;class... Args&gt;\n    constexpr operator()(Args&amp;&amp;... args) \n    noexcept(std::is_nothrow_invocable_v&lt;F/*&amp;&amp;*/, Args/*&amp;&amp;*/...&gt;)\n    {\n        /*std::forward&lt;F&gt;(*/_f/*)*/(std::forward&lt;Args&gt;(args)...);\n    }\n    private: F/*&amp;&amp;*/ _f;\n};\n\n// Case with a conversion constructor\ntemplate &lt;class F&gt;\nstruct functor2\n{\n    template &lt;class G&gt;\n    explicit constexpr functor2(G&amp;&amp; g) \n    noexcept(std::is_nothrow_constructible_v&lt;G/*&amp;&amp;*/, F/*&amp;&amp;*/&gt;)\n    : _f(/*std::forward&lt;G&gt;(*/g/*)*/) \n    {}\n    template &lt;class... Args&gt;\n    constexpr operator()(Args&amp;&amp;... args) \n    noexcept(std::is_nothrow_invocable_v&lt;F/*&amp;&amp;*/, Args/*&amp;&amp;*/...&gt;)\n    {\n        /*std::forward&lt;F&gt;(*/_f/*)*/(std::forward&lt;Args&gt;(args)...);\n    }\n    private: F/*&amp;&amp;*/ _f;\n};\ntemplate &lt;class G&gt;\nfunctor2(G&amp;&amp;) -&gt; functor2&lt;G/*&amp;&amp;*/&gt;;\n</code></pre>\n<p>EDIT: For the sake of simplicity, and because it is not the point of the question, in the preceding examples, we consider that <code>F</code> and <code>G</code> are function objects ie classes/structs with an <code>operator()</code>.</p>\n", "AcceptedAnswerId": "47991202", "Title": "Perfect forwarding with class template argument deduction", "CreationDate": "2017-12-27T04:21:52.547", "LastActivityDate": "2017-12-27T11:33:00.643", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-12-27T07:02:41.397", "LastEditorUserId": "882932", "Id": "47986284", "Score": "3", "OwnerUserId": "882932", "Tags": "<c++><templates><c++17><perfect-forwarding><deduction-guide>", "AnswerCount": "1"}});