post_cb({"26974775": {"CommentCount": "2", "ViewCount": "969", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2014-11-17T14:21:26.713", "LastActivityDate": "2014-11-22T18:41:09.403", "Title": "C++11: \"narrowing conversion inside { }\" with modulus", "AcceptedAnswerId": "26974911", "LastEditDate": "2014-11-17T18:06:37.763", "Id": "26974775", "Score": "3", "Body": "<p>I try to compile the following code with <code>gcc</code> and <code>C++11</code> enabled:</p>\n<pre><code>unsigned int id = 100;\nunsigned char array[] = { id % 3, id % 5 };\n</code></pre>\n<p>I get these warnings:</p>\n<blockquote>\n<p id=\"so_26974775_26974775_0\">narrowing conversion of \u2018(id % 3u)\u2019 from \u2018unsigned int\u2019 to \u2018unsigned char\u2019 inside { } [-Wnarrowing]</p>\n</blockquote>\n<p><a href=\"http://coliru.stacked-crooked.com/a/50c7c2108e5e1494\" rel=\"nofollow\">see demo online</a></p>\n<p>Is there a way to help the compiler find out that the result of <strong>id % 3</strong> fits into an <strong>unsigned char</strong>?</p>\n", "Tags": "<c++><c++11><narrowing>", "OwnerUserId": "678093", "AnswerCount": "4"}, "26974911": {"ParentId": "26974775", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In this specific case making <code>id</code> <em>const</em> or <a href=\"http://en.cppreference.com/w/cpp/language/constexpr\" rel=\"nofollow\">constexpr</a> will fix the problem:</p>\n<pre><code>constexpr unsigned int id = 100;\n</code></pre>\n<p>since there is an exception for the case where you have a <em>constant expression</em> whose result after conversion will fit into the target type.</p>\n<p>In the more general case you may also use <a href=\"http://en.cppreference.com/w/cpp/language/static_cast\" rel=\"nofollow\">static_cast</a> to cast the result to unsigned char:</p>\n<pre><code>{ static_cast&lt;unsigned char&gt;( id % 3), static_cast&lt;unsigned char&gt;( id % 5) }\n  ^^^^^^^^^^^                          ^^^^^^^^^^^\n</code></pre>\n<p>We can find he exception for <em>constant expressions</em> and narrowing conversions in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>8.5.4</code> <em>List-initialization</em> which says:</p>\n<blockquote>\n<p id=\"so_26974775_26974911_0\">A narrowing conversion is an implicit conversion</p>\n</blockquote>\n<p>and include the following bullet (<em>emphasis mine</em>):</p>\n<blockquote id=\"so_26974775_26974911_1\">\n<ul>\n<li>from an integer type or unscoped enumeration type to an integer type that cannot represent all the values of the original type, <strong>except\n  where the source is a constant expression whose value after integral\n  promotions will fit into the target type</strong>.</li>\n</ul>\n</blockquote>\n<p>Note, the wording changed from the original draft C++11 standard to what I quote above due to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3540.html#1449\" rel=\"nofollow\">defect report 1449</a>.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-11-22T18:41:09.403", "Id": "26974911", "Score": "8", "CreationDate": "2014-11-17T14:29:01.690", "LastActivityDate": "2014-11-22T18:41:09.403"}, "26975508": {"ParentId": "26974775", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It is a quirk of C++ that almost all mathematical operations convert their arguments to <code>int</code>.</p>\n<p>Here is a sketch of a non-widening <code>%mod%</code> operator:</p>\n<pre><code>template&lt;class T, class U,class=void&gt; struct smallest{using type=T;};\ntemplate&lt;class T, class U&gt;\nstruct smallest&lt;T,U,std::enable_if_t&lt;(sizeof(T)&gt;sizeof(U))&gt;&gt;{using type=U;};\ntemplate&lt;class T,class U&gt;using smallest_t=typename smallest&lt;T,U&gt;::type;\n\nconstexpr struct mod_t {} mod;\ntemplate&lt;class LHS&gt;struct half_mod { LHS lhs; };\ntemplate&lt;class LHS&gt;\nconstexpr half_mod&lt;std::decay_t&lt;LHS&gt;&gt; operator%( LHS&amp;&amp; lhs, mod_t ) { return {std::forward&lt;LHS&gt;(lhs)}; }\ntemplate&lt;class LHS, class RHS&gt;\nconstexpr smallest_t&lt;LHS, std::decay_t&lt;RHS&gt;&gt; operator%( half_mod&lt;LHS&gt;&amp;&amp; lhs, RHS&amp;&amp; rhs ) {\n  return std::move(lhs.lhs) % std::forward&lt;RHS&gt;(rhs);\n}\n</code></pre>\n<p>The result of a mod b should be the smallest of the two types, as it cannot be larger.  Possibly some work should be done for signed/unsigned, but I'll punt and take the first.</p>\n<p>So <code>id %mod% 3</code> ends up being <code>char</code>.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2014-11-17T16:44:44.677", "Id": "26975508", "Score": "3", "CreationDate": "2014-11-17T15:00:48.903", "LastActivityDate": "2014-11-17T16:44:44.677"}, "26974895": {"ParentId": "26974775", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As <code>id</code> is an <code>unsigned int</code>, the type of <code>id % 3</code> will also be an <code>unsigned int</code>.</p>\n<p>Your compiler is helpfully warning you that <code>unsigned char</code> (which is 8 bits by the standard), <em>might</em> be too small to receive the <code>unsigned int</code> (which is at least 16 bits by the standard).</p>\n<p>Of course you know better in this particular instance. Use <code>static_cast&lt;unsigned char&gt;(id % ...)</code> to tell the compiler that the narrowing conversion is safe.</p>\n", "OwnerUserId": "2380830", "LastEditorUserId": "2380830", "LastEditDate": "2014-11-17T14:34:31.640", "Id": "26974895", "Score": "1", "CreationDate": "2014-11-17T14:28:00.377", "LastActivityDate": "2014-11-17T14:34:31.640"}, "bq_ids": {"n4140": {"so_26974775_26974911_1": {"section_id": 3329, "quality": 1.0, "length": 28}}, "n3337": {"so_26974775_26974911_1": {"section_id": 3199, "quality": 0.8928571428571429, "length": 25}}, "n4659": {"so_26974775_26974911_1": {"section_id": 4095, "quality": 1.0, "length": 28}}}, "26974815": {"ParentId": "26974775", "CommentCount": "0", "Body": "<p>You may use:</p>\n<pre><code>unsigned char array[] = {\n    static_cast&lt;unsigned char&gt;(id % 3),\n    static_cast&lt;unsigned char&gt;(id % 5)\n};\n</code></pre>\n", "OwnerUserId": "2684539", "PostTypeId": "2", "Id": "26974815", "Score": "2", "CreationDate": "2014-11-17T14:23:57.463", "LastActivityDate": "2014-11-17T14:23:57.463"}});