post_cb({"bq_ids": {"n4140": {"so_37729367_39692746_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 1066}}, "n3337": {"so_37729367_39692746_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 1057}}, "n4659": {"so_37729367_39692746_1": {"length": 27, "quality": 0.9642857142857143, "section_id": 1152}}}, "37729367": {"ViewCount": "143", "Body": "<p>I was wondering about uniqueness of a key object inside an <code>std::unordered_multimap</code> when dealing with iteration.</p>\n<p>I'll try to explain the point: I need to associate some data with the key type in the map, this data should not be considered in <code>Hash</code> or <code>KeyEqual</code> elements, but I need it to avoid storing a separate map with it (for optimization purposes).</p>\n<p>So the code associated with my idea is the following:</p>\n<pre><code>struct Key {\n  void* data;\n  mutable bool attribute;\n\n  Key(void* data) : data(data), attribute(false) { }\n  bool operator==(const Key&amp; other) const {\n    return data == other.data;\n  }\n};\n\nstruct KeyHash {\n  size_t operator()(const Key&amp; key) const {\n    return std::hash&lt;void*&gt;()(key.data);\n  }\n};\n\nclass Foo {\npublic:\n  int i;\n  Foo(int i) : i(i) { }\n};\n\nstd::unordered_multimap&lt;Key, Foo, KeyHash&gt; map;\n</code></pre>\n<p>The problem arises from the fact that although this works fine, there are no guarantees about the fact that the key retrieved as the first element of the <code>std::pair&lt;const Key, Foo&gt;</code> mapping to a single element is always the same. Being a <code>pair</code> of <code>const Key</code> it sounds like that every element in the map has its copy of the key by value, so that if I do</p>\n<pre><code>void* target = new int();\nmap.emplace(std::make_pair(target, Foo(1)));\nmap.emplace(std::make_pair(target, Foo(2)));\n\n\nauto pit = map.equal_range(target);\npit.first-&gt;first.attribute = true;  \nstd::cout &lt;&lt; std::boolalpha &lt;&lt; (++pit.first)-&gt;first.attribute &lt;&lt; endl;\n</code></pre>\n<p>This yields <code>false</code> which is confirming what I was thinking. So there is indeed a lot of space wasted to store keys if you have multiple values with the same key (which is what you want since you are using an <code>std::unordered_map</code>).</p>\n<p>I don't see any other solution rather than something like</p>\n<pre><code>struct Value\n{\n  std::vector&lt;Foo&gt; foos;\n  bool attribute;\n};\n\nstd::unordered_map&lt;void*, Value&gt; map;\n</code></pre>\n<p>Which allows me to pair the attribute with the key but makes everything less clean since it requires working with two levels of iterators.</p>\n<p>Are there other solutions I'm not seeing?</p>\n", "AcceptedAnswerId": "39692746", "Title": "Guarantees about key uniqueness in std::unordered_multimap", "CreationDate": "2016-06-09T14:52:10.853", "Id": "37729367", "CommentCount": "5", "LastEditDate": "2016-06-09T21:42:52.420", "PostTypeId": "1", "LastEditorUserId": "121747", "LastActivityDate": "2016-09-25T23:21:29.643", "Score": "6", "OwnerUserId": "121747", "Tags": "<c++><c++11><stl><unordered-multimap>", "AnswerCount": "1"}, "39692746": {"Id": "39692746", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_37729367_39692746_0\">23.5.5.1 Class template unordered_multimap overview [unord.multimap.overview]</p>\n<p id=\"so_37729367_39692746_1\">1 An unordered_multimap is an unordered associative container that supports equivalent keys (an instance of\n  unordered_multimap may contain multiple copies of each key value) and that associates values of another\n  type mapped_type with the keys. The unordered_multimap class supports forward iterators.</p>\n</blockquote>\n<p>An <code>unordered_multimap</code> may contain multiple copies of the key, if you would like a single copy of the key then potentially a <code>unordered_map&lt;K, vector&lt;V&gt;&gt;</code> might be more appropriate.</p>\n", "LastActivityDate": "2016-09-25T23:21:29.643", "CommentCount": "0", "CreationDate": "2016-09-25T23:21:29.643", "ParentId": "37729367", "Score": "2", "OwnerUserId": "1080978"}});