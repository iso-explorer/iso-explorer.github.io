post_cb({"31874630": {"ParentId": "31871267", "CommentCount": "0", "CreationDate": "2015-08-07T09:43:33.897", "OwnerUserId": "946684", "PostTypeId": "2", "Id": "31874630", "Score": "2", "Body": "<p>Here's what the standard has to say about spurious wakeups:</p>\n<blockquote>\n<p id=\"so_31871267_31874630_0\"><strong>30.5 Condition variables [thread.condition]</strong> </p>\n<p id=\"so_31871267_31874630_1\">Condition variables provide synchronization primitives used to block a thread until notified by some other\n  thread that some condition is met or until a system time is reached.</p>\n<p id=\"so_31871267_31874630_2\">...</p>\n<p id=\"so_31871267_31874630_3\">10 Note: It is the user\u2019s responsibility to ensure that waiting threads\n  do not erroneously assume that the thread has finished if they\n  experience spurious wakeups.</p>\n</blockquote>\n<p>From the wording it seems pretty clear that the responsibility for dealing with spurious wakeups is on the user.</p>\n", "LastActivityDate": "2015-08-07T09:43:33.897"}, "31880278": {"ParentId": "31871267", "CommentCount": "0", "CreationDate": "2015-08-07T14:32:26.993", "OwnerUserId": "576911", "PostTypeId": "2", "Id": "31880278", "Score": "3", "Body": "<blockquote>\n<p id=\"so_31871267_31880278_0\">I want to understand, how does <code>wait_for()</code> deals with spurious wakeups?</p>\n</blockquote>\n<p>It doesn't.</p>\n<p>This function is typically used in a situation where if you wake up spuriously, you want to do some other work anyway.  And if you don't wake up spuriously, you want to force a \"spurious\" wake up by the time <code>duration</code> has passed.  This means it is not typically used in a loop as you show, for exactly the reasons you state.  I.e. timeouts and spurious wake ups are treated <em>identically</em>.</p>\n<p>Now you might be wondering, well, what does the predicate version do, as it implies a loop?</p>\n<pre><code>template &lt;class Rep, class Period, class Predicate&gt;\nbool\nwait_for(unique_lock&lt;mutex&gt;&amp; lock, const chrono::duration&lt;Rep, Period&gt;&amp; rel_time,\n         Predicate pred);\n</code></pre>\n<p>This is specified to have the same effects as:</p>\n<pre><code>return wait_until(lock, chrono::steady_clock::now() + rel_time, std::move(pred));\n</code></pre>\n<p>The <code>wait_until</code> variation <em>does</em> distinguish between spurious wake ups and timeouts.  It does so with a loop like this:</p>\n<pre><code>while (!pred())\n    if (wait_until(lock, abs_time) == cv_status::timeout)\n        return pred();\nreturn true;\n</code></pre>\n", "LastActivityDate": "2015-08-07T14:32:26.993"}, "bq_ids": {"n4140": {"so_31871267_31874630_1": {"section_id": 2977, "quality": 1.0, "length": 19}, "so_31871267_31874630_3": {"section_id": 2986, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_31871267_31874630_1": {"section_id": 2847, "quality": 1.0, "length": 19}, "so_31871267_31874630_3": {"section_id": 2856, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_31871267_31874630_1": {"section_id": 3736, "quality": 1.0, "length": 19}, "so_31871267_31874630_3": {"section_id": 3745, "quality": 0.9285714285714286, "length": 13}}}, "31871267": {"CommentCount": "5", "AcceptedAnswerId": "31880278", "PostTypeId": "1", "LastEditorUserId": "514235", "CreationDate": "2015-08-07T06:43:10.120", "LastActivityDate": "2015-08-07T14:32:26.993", "LastEditDate": "2015-08-07T10:31:52.480", "ViewCount": "1431", "FavoriteCount": "2", "Title": "How does `conditional_variable::wait_for()` deal with spurious wakeups?", "Id": "31871267", "Score": "4", "Body": "<p><a href=\"https://en.wikipedia.org/wiki/Spurious_wakeup\" rel=\"nofollow\">Spurious wakup</a> is allowed by various platforms. To counter that, we write below looping mechanism:</p>\n<pre><code>while(ContinueWaiting())\n  cv.wait(lock);   // cv is a `std::conditional_variable` object\n</code></pre>\n<p>Same thing is understandable for <code>conditional_variable::wait_until()</code>.<br>\nBut look at below example:</br></p>\n<pre><code>const auto duration = Returns_10_seconds();\nwhile(!Predicate())\n  cv.wait_for(lock, duration);\n</code></pre>\n<p>Imagine that, spurious wakeup happened at 1 second. Timeout is not yet reached.<br>\nWill it wait for another 10 seconds? This would lead to infinite loop, which I am sure should not happen. From source code, internally <code>wait_for()</code> calls <code>wait_until()</code>.</br></p>\n<p>I want to understand, how does <code>wait_for()</code> deals with spurious wakeups?</p>\n", "Tags": "<c++><multithreading><c++11><condition-variable><spurious-wakeup>", "OwnerUserId": "514235", "AnswerCount": "3"}, "31875319": {"ParentId": "31871267", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2015-08-07T10:15:52.120", "Score": "1", "LastEditorUserId": "390807", "LastEditDate": "2015-08-07T10:49:52.093", "Id": "31875319", "OwnerUserId": "390807", "Body": "<p><strike><pre>\n    const auto duration = Returns_10_seconds();\n    while(cv.wait_for(lock, duration) == std::cv_status::timeout);\n</pre></strike></p>\n<p>This is definitely a wrong thing to do and thus does not make sense discussing how to fix it for the case of spurious wakeups, as it is broken even for the case of ordinary wakeups, because the wait condition is not re-examined after returning from the wait.\n</p>\n<pre><code>const auto duration = Returns_10_seconds();\nwhile(!Predicate())\n  cv.wait_for(lock, duration);\n</code></pre>\n<p>Even after the edit, the answer stays the same: you can't really handle \"spurious wakeups\", because you can't really tell the reason for the wakeup - it may well be a completely legit wakeup due to a call to <code>condition_variable::notifyXXX</code> before the timeout has expired.</p>\n<p>First, note that you can't really distinguish between a wakeup  caused by a call to <code>condition_variable::notifyXXX</code> and wakeup caused by, for example, a POSIX signal[1]. \nSecond, even if POSIX signals are not of concern, the waiting thread still must reexamine the condition as it is possible for the condition to change between the time the condition variable is signaled and the waiting thread returns from the condition wait.</p>\n<p>What you really have to do is treat in a special manner not waking up before the timeout, but waking up <em>due to timeout</em>. And that entirely depends on the reasons to have a timeout in the first place, i.e. on the  specifics of application/problem domain.</p>\n<p>[1] if wait on a condition variable is interrupted by a signal, after executing the signal handler the thread is allowed either to resume wait or return</p>\n", "LastActivityDate": "2015-08-07T10:49:52.093"}});