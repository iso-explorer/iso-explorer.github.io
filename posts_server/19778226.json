post_cb({"19778665": {"ParentId": "19778226", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-11-04T22:40:35.340", "Score": "1", "LastEditorUserId": "19404", "LastEditDate": "2013-11-04T23:33:00.650", "Id": "19778665", "OwnerUserId": "19404", "Body": "<p>I can't think of a sane implementation that would use the second method. Some implementations (i.e. Visual C++) do perform default initialization, which may allocate some minimum length (such as 1 or 16), and then call <code>assign</code>, which will get the length of the string, reallocate if necessary, and then copy the string.</p>\n<p>Many - if not all - modern compilers will use hand-tuned assembly language to get the length of a null-terminated string, which is typically <strong>extremely</strong> fast. Doing an allocate-copy-reallocate-copy-etc... would be madness, really, at least on all platforms that I know of.</p>\n", "LastActivityDate": "2013-11-04T23:33:00.650"}, "19778226": {"CommentCount": "4", "AcceptedAnswerId": "19778403", "CreationDate": "2013-11-04T22:11:13.897", "LastActivityDate": "2013-11-04T23:33:00.650", "PostTypeId": "1", "ViewCount": "714", "FavoriteCount": "1", "Title": "How does the std::basic_string constructor know beforehand how much space to reserve?", "Id": "19778226", "Score": "3", "Body": "<p><code>std::basic_string</code> has the following constructor which initializes the string with the contents of the null-terminated string pointed to by <code>s</code>:</p>\n<pre><code>std::basic_string(const CharT* s, const Allocator&amp; alloc = Allocator());\n</code></pre>\n<p><strong>But how does the constructor know beforehand how much space to reserve for the string in its internal buffer?</strong></p>\n<p>I could think of two methods:</p>\n<p>1) It could first go through the whole null-terminated string until it finds the first NULL character, remember how many characters it traversed, and use that as the capacity for its internal buffer and start copying.</p>\n<p><em>Disadvantage</em>: It has to read the string twice, once for counting the characters, a second time for copying the string.</p>\n<p>2) It could reserve a conservative amount in its internal buffer and just start copying. If it hits the NULL character before the buffer runs out, we're OK, otherwise we need to reserve more space (again by a conservative amount), and repeat the steps.</p>\n<p><em>Disadvantage</em>: If the string is fairly large, the overhead of constantly readjusting the capacity might become noticeable.</p>\n<p><strong>So, what does a sane std::basic_string implementation do (or is this even specified in the standard)?</strong></p>\n", "Tags": "<c++><c++11><stdstring>", "OwnerUserId": "2228370", "AnswerCount": "3"}, "19778409": {"ParentId": "19778226", "CommentCount": "1", "Body": "<p>Common implementations will walk the original string to calculate the length and then allocate that much space. It requires walking the string twice, but that is a fast operation, in some cases with hardware support and even when there is no hardware support for the operation, it is probably <em>cheap</em> compare with a single memory allocation.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "19778409", "Score": "6", "CreationDate": "2013-11-04T22:22:20.963", "LastActivityDate": "2013-11-04T22:22:20.963"}, "bq_ids": {"n4140": {"so_19778226_19778403_1": {"section_id": 1576, "quality": 0.9444444444444444, "length": 17}, "so_19778226_19778403_0": {"section_id": 1572, "quality": 1.0, "length": 5}}, "n3337": {"so_19778226_19778403_1": {"section_id": 1572, "quality": 0.9444444444444444, "length": 17}, "so_19778226_19778403_0": {"section_id": 1568, "quality": 1.0, "length": 5}}, "n4659": {"so_19778226_19778403_1": {"section_id": 1729, "quality": 0.9444444444444444, "length": 17}, "so_19778226_19778403_0": {"section_id": 1725, "quality": 1.0, "length": 5}}}, "19778403": {"ParentId": "19778226", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-11-04T22:21:57.537", "Score": "4", "LastEditorUserId": "952747", "LastEditDate": "2013-11-04T22:58:56.310", "Id": "19778403", "OwnerUserId": "952747", "Body": "<p><strong>The first approach</strong> is the answer. Per standard  \u00a721.4.2:</p>\n<blockquote>\n<p id=\"so_19778226_19778403_0\"><code>basic_string(const charT* s, const Allocator&amp; a = Allocator());</code></p>\n<p id=\"so_19778226_19778403_1\"><sup>9</sup> <em>Effects:</em> Constructs an object of class basic_string and determines its initial string value from the array of charT of length <strong><code>traits::length(s)</code></strong> whose first element is designated by s...</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_19778226_19778403_2\"><sup>10</sup> <em>Remarks:</em> Uses <strong><code>traits::length()</code></strong>.</p>\n</blockquote>\n<p>gcc's implementation is:</p>\n<pre><code>  template&lt;typename _CharT, typename _Traits, typename _Alloc&gt;\n    basic_string&lt;_CharT, _Traits, _Alloc&gt;::\n    basic_string(const _CharT* __s, const _Alloc&amp; __a)\n    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :\n                   __s + npos, __a), __a)\n    { }\n</code></pre>\n<p>It uses <code>traits_type::length</code> which is something like <a href=\"http://en.cppreference.com/w/cpp/string/char_traits/length\" rel=\"nofollow\"><code>std::char_traits::length</code></a> to discover length of c-style zero terminated strings.</p>\n<hr>\n<p>If you have huge entry string to pass the function and you have it's length, you can use another overload which gets the size and doesn't calculate it again:</p>\n<pre><code>basic_string(const CharT* s, size_type count, ...)\n</code></pre>\n<hr>\n<p>The second approach that you've mentioned has another disadvantage, it has to <em>shrink</em> the allocate memory to stop wasting memory. This operation is expensive also.</p>\n</hr></hr>", "LastActivityDate": "2013-11-04T22:58:56.310"}});