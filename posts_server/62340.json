post_cb({"415847": {"Id": "415847", "PostTypeId": "2", "Body": "<p>You might want to consider using the return value of erase instead of swapping the back element to the deleted position an popping back. For sequences erase returns an iterator pointing the the element one beyond the element being deleted. Note that this method may cause more copying than your original algorithm.</p>\n<pre><code>for(std::vector&lt;int&gt;::iterator it = ints.begin(); it != ints.end(); )\n{\n    if(*it &lt; 10)\n        it = ints.erase( it );\n    else\n        ++it;\n}\n</code></pre>\n<p><code>std::remove_if</code> could also be an alternative solution.</p>\n<pre><code>struct LessThanTen { bool operator()( int n ) { return n &lt; 10; } };\n\nints.erase( std::remove_if( ints.begin(), ints.end(), LessThanTen() ), ints.end() );\n</code></pre>\n<p><code>std::remove_if</code> is (like my first algorithm) stable, so it may not be the most efficient way of doing this, but it is succinct.</p>\n", "OwnerDisplayName": "Charles Bailey", "LastActivityDate": "2009-01-06T08:45:21.050", "Score": "0", "CreationDate": "2009-01-06T08:45:21.050", "ParentId": "62340", "CommentCount": "0", "OwnerUserId": "19563"}, "bq_ids": {"n4140": {"so_62340_62878_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 988}, "so_62340_62840_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 956}, "so_62340_62878_0": {"length": 23, "quality": 0.8846153846153846, "section_id": 713}}, "n3337": {"so_62340_62878_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 973}, "so_62340_62840_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 944}, "so_62340_62878_0": {"length": 23, "quality": 0.8846153846153846, "section_id": 702}}, "n4659": {"so_62340_62878_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 1051}, "so_62340_62840_0": {"length": 16, "quality": 0.8421052631578947, "section_id": 1017}, "so_62340_62878_0": {"length": 23, "quality": 0.8846153846153846, "section_id": 742}}}, "62840": {"Id": "62840", "PostTypeId": "2", "Body": "<p>Here is your answer, directly from The Holy Standard:</p>\n<blockquote id=\"so_62340_62840_0\">\n23.2.4.2 A vector satisfies all of the requirements of a container and of a reversible container (given in two tables in 23.1) and of a sequence, including most of the optional sequence requirements (23.1.1).\n</blockquote>\n<blockquote id=\"so_62340_62840_1\">\n23.1.1.12 Table 68\n\n\nexpressiona.pop_back()\nreturn typevoid\noperational semantics<strong>a.erase(--a.end())</strong>\ncontainervector, list, deque\n\n</blockquote>\n<p>Notice that a.pop_back is equivalent to a.erase(--a.end()).  Looking at vector's specifics on erase:</p>\n<blockquote id=\"so_62340_62840_2\">\n23.2.4.3.3 - iterator erase(iterator position) - effects - <strong>Invalidates all the iterators and references after the point of the erase</strong>\n</blockquote>\n<p>Therefore, once you call pop_back, any iterators to the previously final element (which now no longer exists) are invalidated.</p>\n<p>Looking at your code, the problem is that when you remove the final element and the list becomes empty, you still increment it and walk off the end of the list.</p>\n", "LastActivityDate": "2008-09-15T13:25:29.547", "CommentCount": "1", "CreationDate": "2008-09-15T13:25:29.547", "ParentId": "62340", "Score": "12", "OwnerUserId": "7013"}, "62485": {"Id": "62485", "PostTypeId": "2", "Body": "<p>Error is that when \"it\" points to the last element of vector and if this element is less than 10, this last element is removed. And now \"it\" points to ints.end(), next \"it++\" moves pointer to ints.end()+1, so now \"it\" running away from ints.end(), and you got infinite loop scanning all your memory :).</p>\n", "OwnerDisplayName": "mikhaild", "LastActivityDate": "2008-09-15T12:47:52.710", "Score": "0", "CreationDate": "2008-09-15T12:47:52.710", "ParentId": "62340", "CommentCount": "1"}, "62417": {"Id": "62417", "PostTypeId": "2", "Body": "<p>Check out the information <a href=\"http://www.cplusplus.com/reference/stl/vector/pop_back.html\" rel=\"nofollow noreferrer\">here (cplusplus.com)</a>:</p>\n<blockquote>\n<p id=\"so_62340_62417_0\"><strong>Delete last element</strong></p>\n<p id=\"so_62340_62417_1\">Removes the last element in the vector, effectively reducing the vector size by one and invalidating all iterators and references to it.</p>\n</blockquote>\n", "OwnerDisplayName": "jvasak", "LastActivityDate": "2008-09-15T12:40:48.407", "Score": "-1", "CreationDate": "2008-09-15T12:40:48.407", "ParentId": "62340", "CommentCount": "2", "OwnerUserId": "5840"}, "62988": {"Id": "62988", "PostTypeId": "2", "Body": "<p>pop_back() will only invalidate <strong>it</strong> if <strong>it</strong> was pointing to the last item in the vector. Your code will therefore fail whenever the last int in the vector is less than 10, as follows:</p>\n<p>*it = ints.back(); // Set *it to the value it already has<br>\n   ints.pop_back(); // Invalidate the iterator<br>\n   continue; // Loop round and access the invalid iterator  </br></br></p>\n", "OwnerDisplayName": "Charles Anderson", "LastActivityDate": "2008-09-15T13:44:20.733", "Score": "0", "CreationDate": "2008-09-15T13:44:20.733", "ParentId": "62340", "CommentCount": "0"}, "62799": {"Id": "62799", "PostTypeId": "2", "Body": "<p>The \"official specification\" is the C++ Standard.  If you don't have access to a copy of C++03, you can get the latest draft of C++0x from the Committee's website: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf\" rel=\"nofollow noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2723.pdf</a></p>\n<p>The \"Operational Semantics\" section of container requirements specifies that pop_back() is equivalent to { iterator i = end(); --i; erase(i); }.  the [vector.modifiers] section for erase says \"Effects: Invalidates iterators and references at or after the point of the erase.\"</p>\n<p>If you want the intuition argument, pop_back is no-fail (since destruction of value_types in standard containers are not allowed to throw exceptions), so it cannot do any copy or allocation (since they can throw), which means that you can guess that the iterator to the erased element and the end iterator are invalidated, but the remainder are not.</p>\n", "LastActivityDate": "2008-09-15T13:21:23.130", "CommentCount": "0", "CreationDate": "2008-09-15T13:21:23.130", "ParentId": "62340", "Score": "0", "OwnerUserId": "7016"}, "62340": {"ViewCount": "5351", "Body": "<pre><code>std::vector&lt;int&gt; ints;\n\n// ... fill ints with random values\n\nfor(std::vector&lt;int&gt;::iterator it = ints.begin(); it != ints.end(); )\n{\n    if(*it &lt; 10)\n    {\n        *it = ints.back();\n        ints.pop_back();\n        continue;\n    }\n    it++;\n}\n</code></pre>\n<p>This code is not working because when <code>pop_back()</code> is called, <code>it</code> is invalidated. But I don't find any doc talking about invalidation of iterators in <code>std::vector::pop_back()</code>.</p>\n<p>Do you have some links about that?</p>\n", "AcceptedAnswerId": "62522", "Title": "Does pop_back() really invalidate *all* iterators on an std::vector?", "CreationDate": "2008-09-15T12:28:49.370", "LastActivityDate": "2013-08-27T13:53:27.030", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-02-21T15:47:07.420", "OwnerDisplayName": "acemtp", "LastEditorUserId": "27835", "Id": "62340", "Score": "5", "OwnerUserId": "6605", "Tags": "<c++><stl>", "AnswerCount": "11"}, "63135": {"Body": "<p><code>pop_back()</code> invalidates only iterators that point to the last element. From C++ Standard Library Reference:</p>\n<blockquote>\n<p id=\"so_62340_63135_0\">Inserting or removing elements\n  invalidates references, pointers, and\n  iterators that refer to the following\n  element. If an insertion causes\n  reallocation, it invalidates all\n  references, iterators, and pointers.</p>\n</blockquote>\n<p>So to answer your question, no it does not invalidate <em>all</em> iterators.</p>\n<p>However, in your code example, it can invalidate <strong><code>it</code></strong> when it is pointing to the last element and the value is below 10. In which case Visual Studio debug STL will mark iterator as invalidated, and further check for it not being equal to end() will show an assert.</p>\n<p>If iterators are implemented as pure pointers (as they would in probably all non-debug STL vector cases), your code should just work. If iterators are more than pointers, then your code does not handle this case of removing the last element correctly.</p>\n", "CreationDate": "2008-09-15T14:01:24.983", "ParentId": "62340", "CommentCount": "0", "LastEditDate": "2013-08-02T02:00:07.553", "PostTypeId": "2", "OwnerDisplayName": "NeARAZ", "LastEditorUserId": "234175", "LastActivityDate": "2013-08-02T02:00:07.553", "Id": "63135", "Score": "1", "OwnerUserId": "6799"}, "62522": {"Body": "<p>The call to <a href=\"http://en.cppreference.com/w/cpp/container/vector/pop_back\" rel=\"nofollow noreferrer\"><code>pop_back()</code></a> removes the last element in the vector and so the iterator to that element is invalidated.  The <code>pop_back()</code> call does <em>not</em> invalidate iterators to items before the last element, only reallocation will do that.  From Josuttis' \"C++ Standard Library Reference\":</p>\n<blockquote>\n<p id=\"so_62340_62522_0\">Inserting or removing elements\n  invalidates references, pointers, and\n  iterators that refer to the following\n  element.  If an insertion causes\n  reallocation, it invalidates all\n  references, iterators, and pointers.</p>\n</blockquote>\n", "CreationDate": "2008-09-15T12:51:20.410", "ParentId": "62340", "CommentCount": "6", "LastEditDate": "2013-08-27T13:53:27.030", "PostTypeId": "2", "LastEditorDisplayName": "user283145", "OwnerDisplayName": "Ben", "LastActivityDate": "2013-08-27T13:53:27.030", "Id": "62522", "Score": "10", "OwnerUserId": "6930"}, "62730": {"Id": "62730", "PostTypeId": "2", "Body": "<p>Here is a quote from SGI's STL documentation (<a href=\"http://www.sgi.com/tech/stl/Vector.html\" rel=\"nofollow noreferrer\">http://www.sgi.com/tech/stl/Vector.html</a>):</p>\n<p>[5] A vector's iterators are invalidated when its memory is reallocated. Additionally, inserting or deleting an element in the middle of a vector invalidates all iterators that point to elements following the insertion or deletion point. It follows that you can prevent a vector's iterators from being invalidated if you use reserve() to preallocate as much memory as the vector will ever use, and if all insertions and deletions are at the vector's end. </p>\n<p>I think it follows that pop_back only invalidates the iterator pointing at the last element and the end() iterator. We really need to see the data for which the code fails, as well as the manner in which it fails to decide what's going on.  As far as I can tell, the code should work - the usual problem in such code is that removal of element and ++ on iterator happen in the same iteration, the way @mikhaild points out. However, in this code it's not the case: it++ does not happen when pop_back is called.</p>\n<p>Something bad may still happen when it is pointing to the last element, and the last element is less than 10. We're now comparing an <em>invalidated</em> it and end(). It may still work, but no guarantees can be made.</p>\n", "OwnerDisplayName": "Arkadiy", "LastActivityDate": "2008-09-15T13:13:53.100", "Score": "3", "CreationDate": "2008-09-15T13:13:53.100", "ParentId": "62340", "CommentCount": "1", "OwnerUserId": "3458"}, "62368": {"Id": "62368", "PostTypeId": "2", "Body": "<p>Iterators are only invalidated on reallocation of storage.  Google is your friend: <a href=\"http://www.sgi.com/tech/stl/Vector.html\" rel=\"nofollow noreferrer\">see footnote 5</a>.</p>\n<p>Your code is not working for other reasons.</p>\n", "OwnerDisplayName": "David Joyner", "LastActivityDate": "2008-09-15T12:33:20.313", "Score": "1", "CreationDate": "2008-09-15T12:33:20.313", "ParentId": "62340", "CommentCount": "1", "OwnerUserId": "1146"}, "62878": {"Id": "62878", "PostTypeId": "2", "Body": "<p>(I use the numbering scheme as used in the C++0x working draft, <a href=\"http://www.justsoftwaresolutions.co.uk/cplusplus/new-cplusplus-draft-and-concurrency-papers.html\" rel=\"nofollow noreferrer\">obtainable here</a></p>\n<p>Table 94 at page 732 says that pop_back (if it exists in a sequence container) has the following effect:</p>\n<pre><code>{ iterator tmp = a.end(); \n--tmp; \na.erase(tmp); } \n</code></pre>\n<p>23.1.1, point 12 states that:</p>\n<blockquote>\n<p id=\"so_62340_62878_0\">Unless otherwise speci\ufb01ed (either explicitly or by de\ufb01ning a function in terms of other functions), invoking a container \n  member function or passing a container as an argument to a library function shall not invalidate iterators to, or change \n  the values of, objects within that container.</p>\n</blockquote>\n<p>Both accessing end() as applying prefix-- have no such effect, erase() however:</p>\n<p>23.2.6.4 (concerning vector.erase() point 4):</p>\n<blockquote>\n<p id=\"so_62340_62878_1\">Effects: Invalidates iterators and references at or after the point of the erase. </p>\n</blockquote>\n<p>So in conclusion: pop_back() will only invalidate an iterator to the last element, per the standard.</p>\n", "OwnerDisplayName": "Pieter", "LastActivityDate": "2008-09-15T13:29:12.410", "Score": "4", "CreationDate": "2008-09-15T13:29:12.410", "ParentId": "62340", "CommentCount": "0", "OwnerUserId": "5822"}});