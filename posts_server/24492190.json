post_cb({"24493590": {"ParentId": "24492190", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>There is a substantial hint in the subsequent note:</p>\n<blockquote>\n<p id=\"so_24492190_24493590_0\"><em>[ Note: such a class may have a non-trivial destructor \u2014 end note ]</em></p>\n</blockquote>\n<p>Recall that a literal class type (3.9p10):</p>\n<blockquote id=\"so_24492190_24493590_1\">\n<ul>\n<li>has a trivial destructor,<br/></li>\n<li>is an aggregate type (8.5.1) or has at least one constexpr constructor or constructor template that is not a copy or move constructor, and<br/></li>\n<li>all of its non-static data members and base classes are of non-volatile literal types.</li>\n</ul>\n</blockquote>\n<p>Thus if a class has a non-trivial destructor it is disqualified from being a literal class, but an invocation of its constexpr constructor may still qualify as a constant initializer:</p>\n<pre><code>#include &lt;iostream&gt;\nstruct A {\n    int count = 0;\n    constexpr A() {}\n    ~A() { std::cout &lt;&lt; \"~A: \" &lt;&lt; count &lt;&lt; std::endl; }\n};\nA a;\n</code></pre>\n<p>The program can then rely on <code>a</code> being initialized before any dynamic initialization takes place, even though <code>A</code> is not a literal class type.</p>\n<p>The <em>rationale</em> for this is that although <code>A</code>'s destructor has side effects, it is not called during initialization, so it is possible for the compiler to calculate the appropriate initial memory contents of <code>a</code> (in practical terms, its <code>.data</code>) at compile time.</p>\n<hr>\n<p>Note that your emphasis in the second quote is incomplete; the relevant term is \"<em>a constexpr constructor <strong>for a literal class</strong></em></p></hr>\".\n", "OwnerUserId": "567292", "LastEditorUserId": "567292", "LastEditDate": "2014-06-30T15:50:41.683", "Id": "24493590", "Score": "0", "CreationDate": "2014-06-30T15:23:39.960", "LastActivityDate": "2014-06-30T15:50:41.683"}, "bq_ids": {"n4140": {"so_24492190_24492190_1": {"section_id": 6185, "quality": 0.9285714285714286, "length": 13}, "so_24492190_24492190_3": {"section_id": 6185, "quality": 0.9333333333333333, "length": 14}, "so_24492190_24493590_0": {"section_id": 7151, "quality": 0.6666666666666666, "length": 6}, "so_24492190_24492190_0": {"section_id": 7151, "quality": 0.95, "length": 19}, "so_24492190_24493590_1": {"section_id": 7208, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_24492190_24492190_3": {"section_id": 5946, "quality": 0.7333333333333333, "length": 11}, "so_24492190_24493590_0": {"section_id": 5686, "quality": 0.5555555555555556, "length": 5}, "so_24492190_24493590_1": {"section_id": 6952, "quality": 0.9166666666666666, "length": 22}}, "n4659": {"so_24492190_24492190_1": {"section_id": 7687, "quality": 0.7857142857142857, "length": 11}, "so_24492190_24492190_3": {"section_id": 7687, "quality": 0.9333333333333333, "length": 14}, "so_24492190_24493590_0": {"section_id": 8652, "quality": 0.6666666666666666, "length": 6}, "so_24492190_24492190_0": {"section_id": 8652, "quality": 0.9, "length": 18}, "so_24492190_24493590_1": {"section_id": 8717, "quality": 0.9583333333333334, "length": 23}}}, "24492190": {"CommentCount": "2", "ViewCount": "43", "OwnerDisplayName": "user2953119", "CreationDate": "2014-06-30T14:15:15.427", "LastActivityDate": "2014-06-30T15:50:41.683", "PostTypeId": "1", "AcceptedAnswerId": "24493590", "Title": "Restriction for invocation of constexpr constructor in a constant initializer", "Id": "24492190", "Score": "2", "Body": "<p>I don't understand the following addition for <code>constexpr constructor</code> invocation:</p>\n<blockquote>\n<p id=\"so_24492190_24492190_0\">A constant initializer for an object o is an expression that is a\n  constant expression, except that it may also invoke <strong>constexpr</strong>\n<strong>constructors</strong> for o and its subobjects even if those objects are of\n  non-literal class types</p>\n</blockquote>\n<p>Constexpr constructor is core constant expression itself:</p>\n<blockquote>\n<p id=\"so_24492190_24492190_1\">A conditional-expression e is a core constant expression unless the\n  evaluation of e, following the rules of the abstract machine (1.9),\n  would evaluate one of the following expressions: </p>\n<p id=\"so_24492190_24492190_2\">[...] </p>\n<p id=\"so_24492190_24492190_3\">\u2014 an invocation\n  of a function <strong>other than a constexpr constructor</strong> for a literal class,\n  a constexpr function, or an implicit invocation of a trivial\n  destructor (12.4)[...]</p>\n</blockquote>\n", "Tags": "<c++>", "AnswerCount": "1"}});