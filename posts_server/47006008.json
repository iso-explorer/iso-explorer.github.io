post_cb({"bq_ids": {"n4140": {"so_47006008_47006105_1": {"length": 19, "quality": 1.0, "section_id": 5489}}, "n3337": {"so_47006008_47006105_1": {"length": 19, "quality": 1.0, "section_id": 5275}}}, "47006105": {"PostTypeId": "2", "LastEditDate": "2017-10-29T23:15:13.673", "LastActivityDate": "2017-10-29T23:15:13.673", "LastEditorUserId": "2630032", "Id": "47006105", "CommentCount": "0", "CreationDate": "2017-10-29T22:55:56.253", "ParentId": "47006008", "Score": "3", "Body": "<p>If you are using different namespaces for <code>foo</code>, then you introduce two different variables, i.e. <code>a_ns::foo</code> and <code>b_ns::foo</code>. Hence, there is no ambiguity, no conflict, and no undefined behaviour - just two different variables just as if you called the one <code>foo</code> and the other <code>bar</code>.</p>\n<p>A namespace alias, even at global scope, does not introduce an ambiguity with other translation units, whereas a duplicate namespace-name would. Confer <a href=\"https://timsong-cpp.github.io/cppwp/n3337/namespace.alias#4\" rel=\"nofollow noreferrer\">namespace aliases in this online c++ standard draft</a>), which defines uniqueness for <code>namespace-names</code> within the program, but uniqueness for <code>namespace aliases</code> only within a declarative region:</p>\n<blockquote>\n<p id=\"so_47006008_47006105_0\"><strong>7.3.2 Namespace alias</strong></p>\n<p id=\"so_47006008_47006105_1\">A namespace-name or namespace-alias shall not be declared as the name\n  of any other entity in the same declarative region. A namespace-name\n  defined at global scope shall not be declared as the name of any other\n  entity in any global scope of the program. ...</p>\n</blockquote>\n<p>Hence, a namespace alias <code>namespace ns=a_ns</code> introduced in <code>a.cpp</code> will be \"visible\" only in <code>a.cpp</code>, and <code>namespace ns=b_ns</code> introduced in <code>b.cpp</code> will be \"visible\" only in <code>b.cpp</code>. So each use of <code>ns::foo</code> will unambiguously refer to <code>a_ns</code> in <code>a.cpp</code> and <code>b_ns</code> in <code>b.cpp</code>, respectively.</p>\n<p>But if you actually define the same namespace for <code>foo</code> in two different translation units, e.g. <code>namespace ns { int foo; }</code> in both <code>a.cpp</code> and <code>b.cpp</code>, each individual <code>.cpp</code>-file will be compiled correctly, but you will get a linker error, e.g. <code>duplicate symbol __ZN2ns3fooE in: ../a.o; ../b.o</code>.</p>\n", "OwnerUserId": "2630032"}, "47006016": {"PostTypeId": "2", "Body": "<p>No. Your proposed alias does not change the fact that the variables have qualified names <code>a_ns::foo</code> and <code>b_ns::foo</code>, which are different.</p>\n", "LastActivityDate": "2017-10-29T22:43:30.263", "Id": "47006016", "CommentCount": "4", "CreationDate": "2017-10-29T22:43:30.263", "ParentId": "47006008", "Score": "5", "OwnerUserId": "596781"}, "47006008": {"ViewCount": "118", "Body": "<p>From my understanding, global variables in a <code>.cpp</code> file get externally linked. Suppose there are two source files, <code>a.cpp</code> and <code>b.cpp</code>:</p>\n<pre><code>// a.cpp\nnamespace a_ns\n{\n  int foo;\n}\n\n// b.cpp\nnamespace b_ns\n{\n  int foo;\n}\n</code></pre>\n<p>Now suppose both have right after <code>namespace ns=a_ns;</code> and <code>namespace ns=b_ns;</code> respectively. Will this trigger any undefined behaviour like there would be (I think) if both <code>a.cpp</code> and <code>b.cpp</code> just used the same namespace <code>ns</code> for <code>foo</code>?</p>\n", "AcceptedAnswerId": "47006105", "Title": "Does a namespace alias change linkage?", "CreationDate": "2017-10-29T22:42:11.437", "Id": "47006008", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-10-29T23:15:13.673", "Score": "4", "OwnerUserId": "4605946", "Tags": "<c++>", "AnswerCount": "2"}});