post_cb({"246594": {"ParentId": "246564", "CommentCount": "3", "CreationDate": "2008-10-29T12:24:55.733", "OwnerUserId": "1737", "Id": "246594", "PostTypeId": "2", "OwnerDisplayName": "Roddy", "Score": "111", "Body": "<p>Motti is right about the order, but there are some other things to consider:</p>\n<p>Compilers typically use a hidden flag variable to indicate if the local statics have already been initialized, and this flag is checked on every entry to the function. Obviously this is a small performance hit, but what's more of a concern is that this flag is not guaranteed to be thread-safe.</p>\n<p>If you have a local static as above, and 'foo' is called from multiple threads, you may have race conditions causing 'plonk' to be initialized incorrectly or even multiple times. Also, in this case 'plonk' may get destructed by a different thread than the one which constructed it.</p>\n<p>Despite what the standard says, I'd be very wary of the actual order of local static destruction, because it's possible that you may unwittingly rely on a static being still valid after it's been destructed, and this is really difficult to track down. </p>\n", "LastActivityDate": "2008-10-29T12:24:55.733"}, "247470": {"ParentId": "246564", "CommentCount": "3", "CreationDate": "2008-10-29T16:27:17.290", "OwnerUserId": "1737", "Id": "247470", "PostTypeId": "2", "OwnerDisplayName": "Roddy", "Score": "8", "Body": "<p>FWIW, Codegear C++Builder doesn't destruct in the expected order according to the standard.</p>\n<pre><code>C:\\&gt; sample.exe 1 2\nCreated in foo\nCreated in if\nDestroyed in foo\nDestroyed in if\n</code></pre>\n<p>... which is another reason not to rely on the destruction order!</p>\n", "LastActivityDate": "2008-10-29T16:27:17.290"}, "246564": {"CommentCount": "3", "ViewCount": "129346", "PostTypeId": "1", "LastEditorUserId": "62163", "LastEditorDisplayName": "Motti", "CreationDate": "2008-10-29T12:14:03.370", "LastActivityDate": "2015-06-16T14:28:34.767", "AnswerCount": "4", "LastEditDate": "2014-10-09T00:55:05.483", "AcceptedAnswerId": "246568", "FavoriteCount": "104", "Title": "What is the lifetime of a static variable in a C++ function?", "Id": "246564", "Score": "281", "Body": "<p>If a variable is declared as <code>static</code> in a function's scope it is only initialized once and retains its value between function calls. What exactly is its lifetime? When do its constructor and destructor get called?</p>\n<pre><code>void foo() \n{ \n    static string plonk = \"When will I die?\";\n}\n</code></pre>\n<hr>\n<p><em>P.S. For those who want to know <a href=\"http://blog.stackoverflow.com/2011/07/its-ok-to-ask-and-answer-your-own-questions/\">why I asked the question if I already knew the answer?</a></em></p>\n</hr>", "Tags": "<c++><static><lifetime>", "OwnerUserId": "3848", "OwnerDisplayName": "Motti"}, "25796970": {"ParentId": "246564", "CommentCount": "0", "CreationDate": "2014-09-11T21:08:25.050", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "25796970", "Score": "9", "Body": "<p>The existing explanations aren't really complete without the actual rule from the Standard, found in 6.7:</p>\n<blockquote>\n<p id=\"so_246564_25796970_0\">The zero-initialization of all block-scope variables with static storage duration or thread storage duration is performed before any other initialization takes place.  Constant initialization of a block-scope entity with static storage duration, if applicable, is performed before its block is first entered.  An implementation is permitted to perform early initialization of other block-scope variables with static or thread storage duration under the same conditions that an implementation is permitted to statically initialize a variable with static or thread storage duration in namespace scope.  Otherwise such a variable is initialized the first time control passes through its declaration; such a variable is considered initialized upon the  completion  of  its  initialization.   If  the  initialization  exits  by  throwing  an  exception,  the  initialization\n  is  not  complete,  so  it  will  be  tried  again  the  next  time  control  enters  the  declaration.   If  control  enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.  If control re-enters the declaration recursively while the variable is being initialized, the behavior is undefined.</p>\n</blockquote>\n", "LastActivityDate": "2014-09-11T21:08:25.050"}, "246568": {"CommentCount": "9", "CreationDate": "2008-10-29T12:16:04.987", "LastEditorUserId": "-1", "LastActivityDate": "2015-06-16T14:28:34.767", "ParentId": "246564", "PostTypeId": "2", "LastEditorDisplayName": "Motti", "LastEditDate": "2017-05-23T12:10:26.620", "Id": "246568", "Score": "171", "Body": "<p>The lifetime of function <code>static</code> variables begins the first time<sup>[0]</sup> the program flow encounters the declaration and it ends at program termination. This means that the run-time must perform some book keeping in order to destruct it only if it was actually constructed. </p>\n<p>Additionally since the standard says that the destructors' of static objects must run in the reverse order of the completion of their construction<sup>[1]</sup>  and the order of construction may depend on the specific program run, the order of construction must be taken into account.</p>\n<p><strong>Example</strong> </p>\n<pre><code>struct emitter {\n    string str;\n    emitter(const string&amp; s) : str(s) { cout &lt;&lt; \"Created \" &lt;&lt; str; &lt;&lt; endl; }\n    ~emitter() { cout &lt;&lt; \"Destroyed \" &lt;&lt; str &lt;&lt; endl; }\n};\n\nvoid foo(bool skip_first) \n{\n    if (!skip_first)\n        static emitter a(\"in if\");\n    static emitter b(\"in foo\");\n}\n\nint main(int argc, char*[])\n{\n    foo(argc != 2);\n    if (argc == 3)\n        foo(false);\n}\n</code></pre>\n<p><strong>Output:</strong></p>\n<blockquote>\n<p id=\"so_246564_246568_0\">C:&gt;sample.exe<br>\n  Created in foo<br>\n  Destroyed in foo  </br></br></p>\n<p id=\"so_246564_246568_1\">C:&gt;sample.exe  1<br>\n  Created in if<br>\n  Created in foo<br>\n  Destroyed in foo<br>\n  Destroyed in if  </br></br></br></br></p>\n<p id=\"so_246564_246568_2\">C:&gt;sample.exe 1 2<br>\n  Created in foo<br>\n  Created in if<br>\n  Destroyed in if<br>\n  Destroyed in foo  </br></br></br></br></p>\n</blockquote>\n<p><code>[0]</code> Since <strong>C++98</strong><sup>[2]</sup> has no reference to multiple threads how this will be behave in a multi-threaded environment is unspecified, and can be problematic as <a href=\"https://stackoverflow.com/questions/246564/what-is-the-lifetime-of-a-static-variable-in-a-c-function#246594\">Roddy</a> mentions.</p>\n<p><code>[1]</code> <strong>C++98</strong> section <code>3.6.3.1</code> <em>[basic.start.term]</em></p>\n<p><code>[2]</code> In C++11 statics are initialized in a thread safe way, this is also known as <a href=\"http://herbsutter.com/2013/09/09/visual-studio-2013-rc-is-now-available/\" rel=\"noreferrer\"><em>Magic Statics</em></a>.</p>\n", "OwnerUserId": "3848", "OwnerDisplayName": "Motti"}, "bq_ids": {"n4140": {"so_246564_25796970_0": {"section_id": 3919, "quality": 0.9910714285714286, "length": 111}}, "n3337": {"so_246564_25796970_0": {"section_id": 3779, "quality": 0.9910714285714286, "length": 111}}, "n4659": {"so_246564_25796970_0": {"section_id": 4805, "quality": 0.5446428571428571, "length": 61}}}});