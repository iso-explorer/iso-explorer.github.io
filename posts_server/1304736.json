post_cb({"1305294": {"Id": "1305294", "PostTypeId": "2", "Body": "<p>reinterpret_cast can only be used to</p>\n<ul>\n<li>add constness</li>\n<li>convert a pointer to an integral type large enough to hold it and back</li>\n<li>convert a pointer to a function to a pointer to a function of different type</li>\n<li>convert a pointer to an object to a pointer to an object of different type</li>\n<li>convert a pointer to a member function to a pointer to a member function of different type</li>\n<li>convert a pointer to a member object to a pointer to a member object of different type</li>\n<li>and <code>reinterpret_cast&lt;T&amp;&gt;(x)</code> is equivalent to <code>*reinterpret_cast&lt;T*&gt;(&amp;x)</code> (using builtin <code>&amp;</code> and <code>*</code>) whenever the second cast is possible using the above rules.</li>\n</ul>\n<p>(See Section 5.2.10 of the standard)</p>\n<p>This means in particular that a cast from a pointer to function to <code>void *</code> is not possible, but you can cast it to <code>void(*)()</code>.</p>\n<hr>\n<p><strong>EDIT (2017):</strong> The answer above is only correct for C++03. In C++11 through C++17, it is implementation defined if conversions between function pointers and <code>void *</code> are allowed. This is usually the case on POSIX compatible systems because <code>dlsym()</code> is declared to return <code>void *</code>, and clients are expected to <code>reinterpret_cast</code> it to the correct function pointer type.</p>\n<p>See <a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast\" rel=\"nofollow noreferrer\">cppreference.com</a> for the full list of conversions allowed.</p>\n</hr>", "LastEditorUserId": "118854", "LastActivityDate": "2017-10-04T18:22:51.043", "Score": "7", "CreationDate": "2009-08-20T10:40:15.803", "ParentId": "1304736", "CommentCount": "0", "LastEditDate": "2017-10-04T18:22:51.043", "OwnerUserId": "118854"}, "1306125": {"Id": "1306125", "PostTypeId": "2", "Body": "<p>Others pointed out you cannot do that cast (strongly speaking, casting to <code>void*</code> anything using <code>reinterpret_cast</code> is also not allowed - but silently tolerated by the compilers. <code>static_cast</code> is intended to be used here). </p>\n<p>I usually do the following, which is doing a type pun, and is the recommended way to do it, according to the manpage of <code>dlopen</code> (which is about doing the converse - casting <em>from</em> <code>void*</code> <em>to</em> a function pointer). Taking the address of the function pointer will give you a data-pointer: Pointer to a function pointer. This will allow you to cast it to <code>void*</code>. It pretends it's pointing to a <code>void*</code> (instead of a function pointer), and then reads it.</p>\n<pre><code>Test* (*pF)(void **a);\nvoid *p = *(void**)(void*)&amp;pF;\n</code></pre>\n<p>The intermediary cast to <code>void*</code> makes it equivalent to using two <code>static_cast</code>'s internally, and makes GCC be quiet about warning about a type pun. Using C++ Style casts, this looks like a combination of two <code>static_cast</code>'s</p>\n<pre><code>void *p = *static_cast&lt;void**&gt;(static_cast&lt;void*&gt;(&amp;pF));\n</code></pre>\n<p>I found that using this technique, GCC automatically notices when the left and the right types differ in size, and spit out a warning in that case. Needless to say that like with all techniques that try to work around this limitation, this is undefined behavior. </p>\n<hr>\n<p>If you have a function, and want a <code>void*</code> pointing to it, you can do it all in one line, but that's a bit cumbersome on the syntax. Here it is how this can be done, but i don't recommend it if you have problems to read it - you may however use it inside a macro</p>\n<pre><code>// using the function declaration you provided\nTest** pF(void **a); \nvoid *p = *(void**)(void *) &amp;(Test** (* const&amp;)(void **a))&amp;pF;\n</code></pre>\n<p>The trick to start being able to do the type but is to transform the temporary function pointer to an lvalue reference to const, which you can take the address of, and then proceed like above. </p>\n<p>Using explicit C++ style <code>static_cast</code> casts, this looks much more complicated, because you have to take the constness into account. The C style cast automatically dealed with that. Have fun!</p>\n<pre><code>int main() {\n    Test** pF(void **a);\n    void *p = *static_cast&lt;void* const*&gt;(\n      static_cast&lt;void const*&gt;(\n        &amp;static_cast&lt;Test** (* const&amp;)(void **a)&gt;(&amp;pF)));\n}\n</code></pre>\n</hr>", "LastEditorUserId": "34509", "LastActivityDate": "2009-08-20T13:27:54.870", "Score": "2", "CreationDate": "2009-08-20T13:17:52.917", "ParentId": "1304736", "CommentCount": "1", "LastEditDate": "2009-08-20T13:27:54.870", "OwnerUserId": "34509"}, "1304736": {"ViewCount": "7204", "Body": "<p>I want to reinterpret cast a function pointer into a void* variable. The type of the function pointer will be of type <code>Class* (*)(void*)</code>.</p>\n<p>Below is the sample code,</p>\n<pre><code>class Test\n{\n    int a;\n};\n\nint main()\n{\n    Test* *p(void **a);\n    void *f=reinterpret_cast&lt;void*&gt;(p);     \n}\n</code></pre>\n<p>The above code works well with Visual Studio/x86 compilers. But with ARM compiler, it gives compilation error. Don't know why. </p>\n<blockquote>\n<p id=\"so_1304736_1304736_0\">Error: #694: reinterpret_cast cannot\n  cast away const or other type\n  qualifiers</p>\n</blockquote>\n<p>I read the explanation in <a href=\"https://stackoverflow.com/questions/559581/casting-a-function-pointer-to-another-type\">Casting a function pointer to another type</a></p>\n<p>I was concerned about the below explanation.</p>\n<blockquote>\n<p id=\"so_1304736_1304736_1\">Casting between function pointers and\n  regular pointers (e.g. casting a <code>void\n  (*)(void)</code> to a <code>void*</code>). Function\n  pointers aren't necessarily the same\n  size as regular pointers, since on\n  some architectures they might contain\n  extra contextual information. This\n  will probably work ok on x86, but\n  remember that it's undefined behavior.</p>\n</blockquote>\n<p>How to do such conversions from <code>void (*)(void*) -&gt; void*</code> effectively so that atleast it compiles almost the same in most of the compilers ?</p>\n", "AcceptedAnswerId": "1304831", "Title": "reinterpret_cast to void* not working with function pointers", "CreationDate": "2009-08-20T08:23:29.513", "Id": "1304736", "CommentCount": "2", "LastEditDate": "2017-05-23T12:17:33.350", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2017-10-04T18:22:51.043", "Score": "6", "OwnerUserId": "156437", "Tags": "<c++><casting><arm>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_1304736_1305081_0": {"length": 41, "quality": 0.8913043478260869, "section_id": 6045}}, "n3337": {"so_1304736_1305081_0": {"length": 41, "quality": 0.8913043478260869, "section_id": 5813}}, "n4659": {"so_1304736_1305081_0": {"length": 41, "quality": 0.8913043478260869, "section_id": 7544}}}, "1304969": {"Id": "1304969", "PostTypeId": "2", "Body": "<p>shouldn't <code>Test* *p(void **a);</code> be <code>Test* (*p)(void **a)</code> ?</p>\n<p>Maybe that is your problem?</p>\n", "LastActivityDate": "2009-08-20T09:17:39.277", "Score": "0", "CreationDate": "2009-08-20T09:17:39.277", "ParentId": "1304736", "CommentCount": "1", "OwnerUserId": "45262"}, "1305081": {"Id": "1305081", "PostTypeId": "2", "Body": "<p>If you're just looking to store different types of function pointer in a list then you can cast to a common function pointer type:</p>\n<pre><code>class Test {\n  int a;\n};\n\nint main()\n{\n  Test* *p(void **a);\n  void (*f)()=reinterpret_cast&lt;void (*)()&gt;(p);\n}\n</code></pre>\n<p>This is valid to do via <code>reinterpret_cast</code> (5.2.10/6):</p>\n<blockquote>\n<p id=\"so_1304736_1305081_0\">A pointer to a function can be explicitly converted to a pointer to a function of a different type. The effect of calling a function through a pointer to a function type (8.3.5) that is not the same as the type used in the definition of the function is undefined. Except that converting an rvalue of type \"pointer to T1\" to the type \"pointer to T2\" (where T1 and T2 are function types) and back to its original type yields the original pointer value, the result of such a pointer conversion is unspecified.</p>\n</blockquote>\n", "LastActivityDate": "2009-08-20T09:46:39.297", "Score": "3", "CreationDate": "2009-08-20T09:46:39.297", "ParentId": "1304736", "CommentCount": "0", "OwnerUserId": "11698"}, "1304831": {"Id": "1304831", "PostTypeId": "2", "Body": "<p><code>reinterpret_cast</code> can't be used to cast a pointer to function to a <code>void*</code>.  While there are a few additional things that a C cast can do which aren't allowed by combination of static, reinterpret and const casts, that conversion is not one of them.</p>\n<p>In C the cast is allowed, but it's behavior isn't defined (i.e. even round trip isn't guaranteed to work).  </p>\n<p>Some POSIX functions need the conversion to be well useful.</p>\n<p>I've played with several compilers I've here:</p>\n<ul>\n<li>none prevent the C cast, even in the highest conformance mode.  Some give a warning depending on the warning and conformance level, others gave no warning whatever I tried.  </li>\n<li>the reinterpret_cast was a error with some compilers even in the more relaxed level while other accepted it in all case without ever giving a warning.</li>\n</ul>\n<p>In the last available draft for C++0X, the <code>reinterpret_cast</code> between function pointers and objects pointers is conditionally supported.</p>\n<p>Note that if that make sense or not will depend on the target more than the compiler: a portable compiler like gcc will have a behavior imposed by the target architecture and possibly ABI.</p>\n<p>As other have make the remark,</p>\n<pre><code>Test* *p(void **a);\n</code></pre>\n<p>defines a function, not a pointer to function.  But the function to pointer to function implicit conversion is made for the argument to reinterpret_cast, so what reinterpret_cast get is a <code>Test** (*p)(void** a)</code>.</p>\n<p>Thanks to Richard which makes me revisit the issue more in depth (for the record, I was mistaken in thinking that the pointer to function to pointer to object was one case where the C cast allowed something not authorized by C++ casts combinations).</p>\n", "LastEditorUserId": "1390091", "LastActivityDate": "2014-08-05T04:13:17.880", "Score": "7", "CreationDate": "2009-08-20T08:39:51.117", "ParentId": "1304736", "CommentCount": "2", "LastEditDate": "2014-08-05T04:13:17.880", "OwnerUserId": "136208"}});