post_cb({"36843699": {"CommentCount": "1", "ViewCount": "94", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-04-25T14:37:32.047", "LastActivityDate": "2016-04-26T09:36:05.713", "Title": "Make a code \"forwarding referencable\"", "AcceptedAnswerId": "36844276", "LastEditDate": "2017-05-23T12:16:02.923", "Id": "36843699", "Score": "1", "Body": "<p>I opened <a href=\"https://stackoverflow.com/questions/36842291/c-confusion-about-forwarding-reference\">this</a> post about forwarding reference, this is a (hopefully) MCVE code:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nstruct MultiMemoizator {\n    template &lt;typename ReturnType, typename... Args&gt;\n    ReturnType callFunction(std::function&lt;ReturnType(Args...)&gt; memFunc, Args&amp;&amp;... args) {\n\n    }\n};\n\ntypedef vector&lt;double&gt; vecD;\n\nvecD sort_vec (const vecD&amp; vec) {\n    return vec;\n}\n\nint main()\n{\n    vecD vec;\n    std::function&lt;vecD(const vecD&amp;)&gt; sortFunc(sort_vec);\n    MultiMemoizator mem;\n    mem.callFunction&lt;vecD, vecD&gt;(sortFunc, vec);\n}\n</code></pre>\n<p>Since this is not the whole code, maybe I'll have to add extra code based on the answers.</p>\n<p>Anyway, as was suggested in <a href=\"https://stackoverflow.com/a/36842684/4480180\">this</a> answer, forwarding reference is not possible with this version, since <code>Args</code> is not deduced.</p>\n<p>So my question is: is it possible to make this code \"forwarding referencable\"?</p>\n", "Tags": "<c++><c++11><forwarding-reference>", "OwnerUserId": "4480180", "AnswerCount": "2"}, "36844276": {"ParentId": "36843699", "CommentCount": "14", "Body": "<p>In order to perfect-forward your arguments, you need to have the types deduced. You can do this by deducing the arguments to the function and the parameters to the functor separately:</p>\n<pre><code>template &lt;typename ReturnType, typename... FunArgs, typename... Args&gt;\nReturnType callFunction(std::function&lt;ReturnType(FunArgs...)&gt; memFunc,\n                        Args&amp;&amp;... args) \n{\n    //...\n}\n</code></pre>\n<p>Then you can call <code>callFunction</code> without template parameters and have everything deduced:</p>\n<pre><code>mem.callFunction(sortFunc, vec);\n</code></pre>\n", "OwnerUserId": "496161", "PostTypeId": "2", "Id": "36844276", "Score": "2", "CreationDate": "2016-04-25T15:01:34.323", "LastActivityDate": "2016-04-25T15:01:34.323"}, "36849967": {"ParentId": "36843699", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>I will add a bit of details regarding @TartanLlama answer on <strong>why</strong> your code fails to compile (even without the explicit template parameters) but also why (in my own opinion) your code is <em>dangerous</em>.</p>\n<p>In the following, I will use only a simple type <code>T</code> instead of your parameter pack <code>Args...</code> because it is simpler to explain and does not change the meaning.</p>\n<h2>A bit of reminder on forwarding references...</h2>\n<p>First, let's take a simpler example than yours with simply the following:</p>\n<pre><code>template &lt;typename T&gt;\nvoid f (T&amp;&amp;);\n</code></pre>\n<p>Now, let's instanciate <code>f</code> from various sources, let's assume with have the following variables:</p>\n<pre><code>std::string s;\nconst std::string cs;\n</code></pre>\n<p>...then:</p>\n<pre><code>f(s); // instanciate f&lt;std::string&amp;&gt;\nf(cs); // instanciate f&lt;const std::string&amp;&gt;\nf(std::string()); // instanciate f&lt;std::string&amp;&amp;&gt;\n</code></pre>\n<p>You should be wondering: <em>Why is the first instanciation <code>f&lt;std::string&amp;&gt;</code> instead of <code>f&lt;std::string&gt;</code>?</em>, but the standard tells you (\u00a714.8.2.1#3 <strong>[temp.deduct.call]</strong>):</p>\n<blockquote>\n<p id=\"so_36843699_36849967_0\">If P is a forwarding reference and the argument is an\n  lvalue, the type \u201clvalue reference to A\u201d is used in place of A for type deduction.</p>\n</blockquote>\n<h2>Back to our initial snippet!</h2>\n<p>Now, let's complicate a bit our example:</p>\n<pre><code>template &lt;typename T&gt; \nstruct A {};\n\ntemplate &lt;typename T&gt;\nvoid f (A&lt;T&gt;, T&amp;&amp;);\n</code></pre>\n<p>And one instantiation:</p>\n<pre><code>std::string s;\nA&lt;std::string&gt; as;\nf(as, s);\n</code></pre>\n<p>The above is equivalent to your example, and will fails to compile, but why... ? Well, as explained above, when you have an <em>lvalue</em>, the deduced type for <code>T&amp;&amp;</code> is <code>T&amp;</code>, not <code>T</code>, and thus the type deduction fails for <code>A&lt;T&gt;</code> because the compiler is expecting <code>A&lt;std::string&amp;&gt;</code> and you are giving a <code>A&lt;std::string&gt;</code>.</p>\n<p>So now we know that we have to do the following:</p>\n<pre><code>A&lt;std::string&amp;&gt; ars;\nA&lt;std::string const&amp;&gt; acrs;\nf(ars, s); // good\nf(acrs, cs); // good\n</code></pre>\n<h2>Why is it dangerous?</h2>\n<p>Ok so now, this should be good:</p>\n<pre><code>A&lt;std::string&amp;&amp;&gt; arrs;\nf(arrs, std::string());\n</code></pre>\n<p>But it is not... Because when <code>T</code> is deduced as a rvalue reference, <code>T</code> is simply <code>T</code>, so the compiler is expecting <code>A&lt;std::string&gt;</code>.</p>\n<p>So here is the problem: You are going to give a <em>rvalue</em> to a method that is going to forward it to a function expecting an <em>lvalue</em>. That's not wrong, but it is probably not what you'd have expected.</p>\n<h2>How to deal with it?</h2>\n<p>The first possibility is to force the type of the first parameter regardless of the deduced type for <code>T</code>, e.g.:</p>\n<pre><code>template &lt;typename T&gt;\nvoid f (A&lt;typename std::remove_reference&lt;T&gt;::type&gt;, T&amp;&amp;);\n</code></pre>\n<p>But note:</p>\n<ol>\n<li>You would have to add more stuff to deal with <code>const</code>.</li>\n<li>One may wonder the usefulness of <code>T&amp;&amp;</code> when the type of the first argument is fixed (in your case, at least).</li>\n</ol>\n<p>The second possibility (<strong>warning: I don't know if this is standard!</strong>) is to move the first parameter at the end and then deduce the type from <code>t</code>:</p>\n<pre><code>template &lt;typename T&gt;\nvoid f (T &amp;&amp;t, A&lt;decltype(std::forward&lt;T&gt;(t))&gt;);\n</code></pre>\n<p>Now you have an exact match between the deduced type for <code>T</code> and the expected type for <code>A</code>.</p>\n<p>Unfortunately I don't know how to make the above work with variadic templates...</p>\n", "OwnerUserId": "2666289", "LastEditorUserId": "2666289", "LastEditDate": "2016-04-26T07:20:12.803", "Id": "36849967", "Score": "0", "CreationDate": "2016-04-25T20:00:16.280", "LastActivityDate": "2016-04-26T07:20:12.803"}, "bq_ids": {"n4140": {"so_36843699_36849967_0": {"section_id": 304, "quality": 0.9, "length": 9}}, "n3337": {"so_36843699_36849967_0": {"section_id": 295, "quality": 0.9, "length": 9}}, "n4659": {"so_36843699_36849967_0": {"section_id": 311, "quality": 1.0, "length": 10}}}});