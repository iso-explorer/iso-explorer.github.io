post_cb({"9963974": {"CommentCount": "1", "ViewCount": "1054", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-04-01T11:25:26.223", "LastActivityDate": "2013-03-15T13:25:20.483", "Title": "Are returned locals automatically xvalues", "AcceptedAnswerId": "9964002", "LastEditDate": "2017-05-23T12:06:43.893", "Id": "9963974", "Score": "18", "Body": "<p>Following on from a comment I made on this:</p>\n<p><a href=\"https://stackoverflow.com/questions/9963798/passing-stdvector-to-constructor-and-move-semantics\">passing std::vector to constructor and move semantics</a>\nIs the <code>std::move</code> necessary in the following code, to ensure that the returned value is a xvalue?</p>\n<pre><code>std::vector&lt;string&gt; buildVector()\n{\n  std::vector&lt;string&gt; local;\n\n  // .... build a vector\n\n  return std::move(local);\n}\n</code></pre>\n<p>It is my understanding that this is required. I have often seen this used when returning a <code>std::unique_ptr</code> from a function, however  GManNickG made the following comment:</p>\n<blockquote>\n<p id=\"so_9963974_9963974_0\">It is my understanding that in a return statement all local variables are automatically xvalues (expiring values) and will be moved, but I'm unsure if that only applies to the returned object itself. So OP should go ahead and put that in there until I'm more confident it shouldn't have to be. :)</p>\n</blockquote>\n<p>Can anyone clarify if the <code>std::move</code> is necessary?</p>\n<p>Is the behaviour compiler dependent? </p>\n", "Tags": "<c++><c++11><move-semantics>", "OwnerUserId": "926751", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_9963974_9964097_1": {"section_id": 5940, "quality": 1.0, "length": 21}, "so_9963974_9964002_0": {"section_id": 3913, "quality": 0.9333333333333333, "length": 14}, "so_9963974_9964276_0": {"section_id": 3913, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_9963974_9964097_1": {"section_id": 5711, "quality": 1.0, "length": 21}, "so_9963974_9964002_0": {"section_id": 3773, "quality": 0.9333333333333333, "length": 14}, "so_9963974_9964276_0": {"section_id": 3773, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_9963974_9964097_1": {"section_id": 7424, "quality": 1.0, "length": 21}, "so_9963974_9964002_0": {"section_id": 4799, "quality": 0.6, "length": 9}, "so_9963974_9964276_0": {"section_id": 4, "quality": 0.6666666666666666, "length": 6}}}, "9964002": {"ParentId": "9963974", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>You're guaranteed that <code>local</code> will be returned as an rvalue in this situation. Usually compilers would perform return-value optimization though before this even becomes an issue, and you probably wouldn't see any actual move at all, since the <code>local</code> object would be constructed directly at the call site.</p>\n<p>A relevant <em>Note</em> in 6.6.3 [\"The return statement\"] (2):</p>\n<blockquote>\n<p id=\"so_9963974_9964002_0\">A copy or move operation associated with a return statement may be elided or <strong>considered as an rvalue</strong> for the purpose of overload resolution in selecting a constructor (12.8).</p>\n</blockquote>\n<p>To clarify, this is to say that the returned object can be move-constructed from the local object (even though in practice RVO will skip this step entirely). The normative part of the standard is 12.8 [\"Copying and moving class objects\"] (31, 32), on copy elision and rvalues (thanks @Mankarse!).</p>\n<hr>\n<p>Here's a silly example:</p>\n<pre><code>#include &lt;utility&gt;\n\nstruct Foo\n{\n    Foo()            = default;\n    Foo(Foo const &amp;) = delete;\n    Foo(Foo &amp;&amp;)      = default;\n};\n\nFoo f(Foo &amp; x)\n{\n    Foo y;\n\n    // return x;         // error: use of deleted function \u2018Foo::Foo(const Foo&amp;)\u2019\n    return std::move(x); // OK\n    return std::move(y); // OK\n    return y;            // OK (!!)\n}\n</code></pre>\n<p>Contrast this with returning an actual rvalue reference:</p>\n<pre><code>Foo &amp;&amp; g()\n{\n    Foo y;\n    // return y;         // error: cannot bind \u2018Foo\u2019 lvalue to \u2018Foo&amp;&amp;\u2019\n    return std::move(y); // OK type-wise (but undefined behaviour, thanks @GMNG)\n}\n</code></pre>\n</hr>", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2012-04-01T12:02:55.707", "Id": "9964002", "Score": "14", "CreationDate": "2012-04-01T11:29:55.673", "LastActivityDate": "2012-04-01T12:02:55.707"}, "9964276": {"ParentId": "9963974", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Altough both, <code>return std::move(local)</code> and <code>return local</code>, do work in sense of that they do compile, their behavior is different. And probably only the latter one was intended.</p>\n<p>If you write a function which returns a <code>std::vector&lt;string&gt;</code>, you have to return a  <code>std::vector&lt;string&gt;</code> and exactly it. <code>std::move(local)</code> has the type<code>std::vector&lt;string&gt;&amp;&amp;</code> which is <strong>not</strong> a <code>std::vector&lt;string&gt;</code> so it has to be converted to it using the move constructor.</p>\n<p>The standard says in 6.6.3.2:</p>\n<blockquote>\n<p id=\"so_9963974_9964276_0\">The value of the expression is implicitly\n  converted to the return type of the function in which it appears.</p>\n</blockquote>\n<p>That means, <code>return std::move(local)</code> is equalvalent to</p>\n<pre><code>std::vector&lt;std::string&gt; converted(std::move(local); // move constructor\nreturn converted; // not yet a copy constructor call (which will be elided anyway)\n</code></pre>\n<p>whereas <code>return local</code> only is</p>\n<pre><code>return local; // not yet a copy constructor call (which will be elided anyway)\n</code></pre>\n<p>This spares you one operation.</p>\n<hr>\n<p>To give you a short example of what that means:</p>\n<pre><code>struct test {\n  test() { std::cout &lt;&lt; \"  construct\\n\"; }\n  test(const test&amp;) { std::cout &lt;&lt; \"  copy\\n\"; }\n  test(test&amp;&amp;) { std::cout &lt;&lt; \"  move\\n\"; }\n};\n\ntest f1() { test t; return t; }\ntest f2() { test t; return std::move(t); }\n\nint main()\n{\n  std::cout &lt;&lt; \"f1():\\n\"; test t1 = f1();\n  std::cout &lt;&lt; \"f2():\\n\"; test t2 = f2();\n}\n</code></pre>\n<p>This will output</p>\n<pre><code>f1():\n  construct\nf2():\n  construct\n  move\n</code></pre>\n</hr>", "OwnerUserId": "1176973", "LastEditorUserId": "1176973", "LastEditDate": "2012-04-01T12:21:03.550", "Id": "9964276", "Score": "7", "CreationDate": "2012-04-01T12:11:28.707", "LastActivityDate": "2012-04-01T12:21:03.550"}, "9964097": {"ParentId": "9963974", "CommentCount": "1", "Body": "<p>I think the answer is no. Though officially only a note, \u00a75/6 summarizes what expressions are/aren't xvalues:</p>\n<blockquote>\n<p id=\"so_9963974_9964097_0\">An expression is an xvalue if it is:</p>\n<ul>\n<li>the result of calling a function, whether implicitly or explicitly, whose return type is an rvalue reference to object type,</li>\n<li>a cast to an rvalue reference to object type,</li>\n<li>a class member access expression designating a non-static data member of non-reference type in which the object expression is an xvalue, or</li>\n<li>a .* pointer-to-member expression in which the first operand is an xvalue and the second operand is a pointer to data member.</li>\n</ul>\n<p id=\"so_9963974_9964097_1\">In general, the effect of this rule is that named rvalue references are treated as lvalues and unnamed rvalue references to objects are treated as xvalues; rvalue references to functions are treated as lvalues whether named or not.</p>\n</blockquote>\n<p>The first bullet point seems to apply here. Since the function in question returns a value rather than an rvalue reference, the result won't be an xvalue.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "9964097", "Score": "4", "CreationDate": "2012-04-01T11:45:57.737", "LastActivityDate": "2012-04-01T11:45:57.737"}});