post_cb({"bq_ids": {"n4140": {"so_44311306_44311825_1": {"length": 14, "quality": 0.875, "section_id": 3296}, "so_44311306_44311825_2": {"length": 29, "quality": 0.8787878787878788, "section_id": 3296}, "so_44311306_44311825_0": {"length": 23, "quality": 0.7666666666666667, "section_id": 3296}}, "n3337": {"so_44311306_44311825_1": {"length": 14, "quality": 0.875, "section_id": 3166}, "so_44311306_44311825_2": {"length": 29, "quality": 0.8787878787878788, "section_id": 3166}, "so_44311306_44311825_0": {"length": 23, "quality": 0.7666666666666667, "section_id": 3166}}, "n4659": {"so_44311306_44311825_1": {"length": 16, "quality": 1.0, "section_id": 4058}, "so_44311306_44311825_2": {"length": 29, "quality": 0.8787878787878788, "section_id": 4058}, "so_44311306_44311825_0": {"length": 28, "quality": 0.9333333333333333, "section_id": 4058}}}, "44311306": {"ViewCount": "322", "Body": "<p>Consider this example:</p>\n<pre><code>struct T { };\n\nstruct S {\n    operator T();\n};\n\nS s;\nT t = s;\n</code></pre>\n<p>[dcl.init] will take us to [over.match.copy] which will find the conversion function <code>operator T()</code>. But are we done at that point, or do we have to invoke <code>T(T&amp;&amp; rhs)</code>, binding <code>rhs</code> to the return of <code>operator T()</code> via [dcl.init.ref]? Are there any differences with regards to the answer to this question between C++11 and C++1z?</p>\n", "AcceptedAnswerId": "44311825", "Title": "Is the move constructor called after invoking a conversion function?", "CreationDate": "2017-06-01T15:12:56.627", "Id": "44311306", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-06-02T07:14:42.270", "Score": "17", "OwnerUserId": "2069064", "Tags": "<c++><c++11><initialization><language-lawyer><c++1z>", "AnswerCount": "1"}, "44311825": {"Id": "44311825", "PostTypeId": "2", "Body": "<p>This falls under <a href=\"https://timsong-cpp.github.io/cppwp/dcl.init#17.6.3\" rel=\"nofollow noreferrer\">[dcl.init]/17.6.3</a>, which is pretty clear about what happens after overload resolution selects the conversion function:</p>\n<blockquote>\n<p id=\"so_44311306_44311825_0\">The function selected is called with the initializer expression as its\n  argument; if the function is a constructor, the call is a prvalue of\n  the cv-unqualified version of the destination type whose result object\n  is initialized by the constructor. The call is used to\n  direct-initialize, according to the rules above, the object that is\n  the destination of the copy-initialization.</p>\n</blockquote>\n<p>In your case this in turn recurses into  <a href=\"https://timsong-cpp.github.io/cppwp/dcl.init#17.6.1\" rel=\"nofollow noreferrer\">[dcl.init]/17.6.1</a>:</p>\n<blockquote>\n<p id=\"so_44311306_44311825_1\">If the initializer expression is a prvalue and the cv-unqualified\n  version of the source type is the same class as the class of the\n  destination, the initializer expression is used to initialize the\n  destination object.</p>\n</blockquote>\n<hr>\n<p>In C++11 the second step does invoke a move constructor, since it doesn't have the bullet corresponding to C++17's 17.6.1. Instead <a href=\"https://timsong-cpp.github.io/cppwp/n3337/dcl.init#16.6.1\" rel=\"nofollow noreferrer\">you do the direct-initialization/overload resolution dance again</a>:</p>\n<blockquote>\n<p id=\"so_44311306_44311825_2\">If the initialization is direct-initialization, [...], constructors are \n  considered. The applicable constructors\n  are enumerated ([over.match.ctor]), and the best one is chosen through\n  overload resolution ([over.match]). The constructor so selected is\n  called to initialize the object, with the initializer expression or\n  expression-list as its argument(s). If no constructor applies, or the\n  overload resolution is ambiguous, the initialization is ill-formed.</p>\n</blockquote>\n<p>This move can (and in practice will) be elided; see <a href=\"https://timsong-cpp.github.io/cppwp/n3337/class.copy#31.3\" rel=\"nofollow noreferrer\">[class.copy]/31</a>.</p>\n<hr>\n<p>The more interesting case is actually</p>\n<pre><code>T t(s);\n</code></pre>\n<p>which under the C++17 wording is actually <em>required</em> to call a move constructor, because it uses the direct-initialization rule and does overload resolution on <code>T</code>'s constructors. That selects <code>T</code>'s move constructor and calls it to initialize <code>t</code>, converting <code>s</code> to a <code>T</code> prvalue that is materialized into a temporary and bound to the parameter of the move constructor. The 17.6.1 bullet is simply not reachable in the process, and the bullet in C++11's [class.copy]/31 (now <a href=\"https://timsong-cpp.github.io/cppwp/class.copy.elision#1\" rel=\"nofollow noreferrer\">[class.copy.elision]/1</a>) that permitted elision in this scenario was removed in C++17.</p>\n<p>This is most likely a defect.</p>\n</hr></hr>", "LastEditorUserId": "2756719", "LastActivityDate": "2017-06-02T07:14:42.270", "Score": "15", "CreationDate": "2017-06-01T15:35:49.650", "ParentId": "44311306", "CommentCount": "8", "OwnerUserId": "2756719", "LastEditDate": "2017-06-02T07:14:42.270"}});