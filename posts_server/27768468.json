post_cb({"bq_ids": {"n4140": {"so_27768468_27769245_1": {"length": 23, "quality": 0.92, "section_id": 6107}}, "n3337": {"so_27768468_27769245_1": {"length": 23, "quality": 0.92, "section_id": 5873}}, "n4659": {"so_27768468_27769245_1": {"length": 23, "quality": 0.92, "section_id": 7604}}}, "27769445": {"Id": "27769445", "PostTypeId": "2", "Body": "<p>Problem is that you try to delete A object via MyObject pointer and MyObject destructor is not virtual. You could make MyObject's destructor virtual and then you can delete subclasses objects via pointer to MyObject. For more details on this issue see <a href=\"https://stackoverflow.com/questions/8752111/possible-memory-leak-without-a-virtual-destructor\">this</a> question</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-01-04T19:27:37.567", "Score": "0", "CreationDate": "2015-01-04T19:27:37.567", "ParentId": "27768468", "CommentCount": "0", "OwnerUserId": "3021277", "LastEditDate": "2017-05-23T12:33:07.433"}, "27768468": {"ViewCount": "759", "Body": "<p>I have strange assertion error and I can not find what is wrong with this code.</p>\n<p>Assertion expression is _BLOCK_TYPE_IS_VALID(pHead-&gt;nBlockUse).</p>\n<p>I simplified code a bit for better readability.</p>\n<pre><code>class Creator\n{\npublic:\n    virtual ~Creator()\n    {\n        for (MyObject* item : _list)\n        {\n            delete item; &lt;-- assertion error here\n            item = 0;\n        }\n        _list.clear();\n    }\n\n    template &lt;class T&gt;\n    T&amp; create()\n    {\n        T * item = new T();\n        _list.push_back(item);\n        return *item;\n    }\n\nprivate:\n    std::list&lt;MyObject*&gt; _list;\n};\n\nclass A : public MyObject, public Creator\n{\n};\n\nclass B : public MyObject, public Creator\n{\n};\n\nint main()\n{\n    A a;\n    a.create&lt;A&gt;();\n} &lt;-- call of destructor\n</code></pre>\n<p>The idea is that an object witch inherits Creator, can create any other object, and hold pointers to those objects. While programmer can work with references. And when \"super\" object is destroyed, all \"sub\" objects are destroyed too.</p>\n<p>Program works like a charm if I change to:</p>\n<pre><code>template &lt;class T&gt;\nclass Creator\n{\npublic:\n    virtual ~Creator()\n    {\n        for (T* item : _list)\n        {\n            delete item;\n            item = 0;\n        }\n        _list.clear();\n    }\n\n    T&amp; create()\n    {\n        T * item = new T();\n        _list.push_back(item);\n        return *item;\n    }\n\nprivate:\n    std::list&lt;T*&gt; _list;\n};\n\nclass A : public MyObject, public Creator&lt;A&gt;\n{\n};\n\nclass B : public MyObject, public Creator&lt;B&gt;\n{\n};\n\nint main()\n{\n    A a;\n    a.create();\n}\n</code></pre>\n<p>Now create method creates only one type of object ( object A in this example ).\nBut I need, that create method could create any object that inherits MyObject. Like in first peace of code.</p>\n<p>Any help for this assertion error would be appreciated. Thanks.</p>\n", "AcceptedAnswerId": "27769245", "Title": "C++ assertion error while deleting object", "CreationDate": "2015-01-04T17:46:55.050", "Id": "27768468", "CommentCount": "10", "LastEditDate": "2015-07-07T12:47:18.210", "PostTypeId": "1", "LastEditorUserId": "4370109", "LastActivityDate": "2015-07-07T12:47:18.210", "Score": "0", "OwnerUserId": "3629375", "Tags": "<c++><inheritance><runtime-error><assertion><delete-operator>", "AnswerCount": "3"}, "27769245": {"Id": "27769245", "PostTypeId": "2", "Body": "<p>The issue is that your MyObject class lacks a virtual destructor, and you're attempting to call <code>delete</code> on a pointer to the derived class using a pointer to the base class <code>MyObject</code>.   Issuing a <code>delete</code> on a derived object through a base class pointer is undefined behavior if the base class destructor is not virtual.</p>\n<blockquote>\n<p id=\"so_27768468_27769245_0\">5.3.5 Delete (Paragraph 3)</p>\n<p id=\"so_27768468_27769245_1\">In the first alternative (delete object), if the static type of the\n  operand is different from its dynamic type, the static type shall be a base class of the operand\u2019s dynamic type <strong>and the static type shall have a virtual destructor or the behavior is undefined</strong>.</p>\n</blockquote>\n<p>Once the destructor is made virtual in the base class <code>MyClass</code>, the following works correctly in Visual Studio 2013:</p>\n<pre><code>#include &lt;list&gt;\nstruct MyObject \n{\n    virtual ~MyObject() {}\n};\n\nclass Creator\n{\npublic:\n    virtual ~Creator()\n    {\n        for (MyObject* item : _list)\n        {\n            delete item; \n            item = 0;\n        }\n        _list.clear();\n    }\n\n    template &lt;class T&gt;\n    T&amp; create()\n    {\n        T * item = new T();\n        _list.push_back(item);\n        return *item;\n    }\n\nprivate:\n    std::list&lt;MyObject*&gt; _list;\n};\n\nclass A : public MyObject, public Creator\n{\n};\n\nclass B : public MyObject, public Creator\n{\n};\n\nint main()\n{\n    A a;\n    a.create&lt;A&gt;();\n} \n</code></pre>\n", "LastEditorUserId": "3133316", "LastActivityDate": "2015-01-04T19:29:21.370", "Score": "1", "CreationDate": "2015-01-04T19:04:18.660", "ParentId": "27768468", "CommentCount": "1", "OwnerUserId": "3133316", "LastEditDate": "2015-01-04T19:29:21.370"}, "27769061": {"Id": "27769061", "PostTypeId": "2", "Body": "<p>I think the issue is with multiple inheritance. Here's a simplified way to reproduce the problem.\nIt can be fixed by </p>\n<ul>\n<li>casting it to the most derived type  OR </li>\n<li>having the destructor of the base class be virtual.</li>\n</ul>\n<p>In your case, the virtual function approach is best as it is recommended to have base class destructor(s) to be virtual to get the destruction calls through the inheritance hierarchy.</p>\n<pre><code>class A \n{\n};\n\nclass B\n{\n};\n\nclass C : public A, public B\n{\n};\n\nint main()\n{\n    // Fails with memory heap error\n    B* pB = new C();\n    delete pB;\n}\n</code></pre>\n<p>To fix it</p>\n<pre><code>int main()\n{\n    B* pB = new C();\n    // Casting it to the \"full\" type will fix it\n    C* pC = static_cast&lt;C*&gt;(pB);\n    delete pC;\n}\n</code></pre>\n<p>The second program works because it is similar to this below.</p>\n<pre><code>int main()\n{\n    // Pointer to the \"full\" type works\n    C* pC = new C();\n    delete pC;\n}\n</code></pre>\n", "LastEditorUserId": "3209308", "LastActivityDate": "2015-01-04T19:35:45.973", "Score": "0", "CreationDate": "2015-01-04T18:47:05.093", "ParentId": "27768468", "CommentCount": "1", "OwnerUserId": "3209308", "LastEditDate": "2015-01-04T19:35:45.973"}});