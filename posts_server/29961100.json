post_cb({"bq_ids": {"n4140": {"so_29961100_29961422_2": {"length": 11, "quality": 1.0, "section_id": 639}, "so_29961100_29961422_5": {"length": 6, "quality": 0.75, "section_id": 603}, "so_29961100_29961422_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 603}, "so_29961100_29961422_7": {"length": 6, "quality": 1.0, "section_id": 147}, "so_29961100_29961422_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 639}, "so_29961100_29961422_4": {"length": 18, "quality": 0.9, "section_id": 603}}, "n3337": {"so_29961100_29961422_2": {"length": 11, "quality": 1.0, "section_id": 629}, "so_29961100_29961422_5": {"length": 6, "quality": 0.75, "section_id": 593}, "so_29961100_29961422_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 593}, "so_29961100_29961422_7": {"length": 6, "quality": 1.0, "section_id": 141}, "so_29961100_29961422_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 629}, "so_29961100_29961422_4": {"length": 18, "quality": 0.9, "section_id": 593}}, "n4659": {"so_29961100_29961422_2": {"length": 11, "quality": 1.0, "section_id": 667}, "so_29961100_29961422_5": {"length": 6, "quality": 0.75, "section_id": 629}, "so_29961100_29961422_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 629}, "so_29961100_29961422_7": {"length": 6, "quality": 1.0, "section_id": 151}, "so_29961100_29961422_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 667}, "so_29961100_29961422_4": {"length": 18, "quality": 0.9, "section_id": 629}}}, "29961422": {"Id": "29961422", "PostTypeId": "2", "Body": "<p>Overload resolution attempts to find the best conversion. The following paragraph lists the relevant bullet points that could distinguish both conversions:</p>\n<blockquote>\n<p id=\"so_29961100_29961422_0\">Standard conversion sequence <code>S1</code> is a better conversion sequence than\n  standard conversion sequence <code>S2</code> if</p>\n<ul>\n<li><p id=\"so_29961100_29961422_1\"><code>S1</code> is a proper subsequence of <code>S2</code> (comparing the conversion sequences in the canonical form defined by 13.3.3.1.1, <strong>excluding any\n  Lvalue Transformation</strong>; the identity conversion sequence is considered\n  to be a subsequence of any non-identity conversion sequence) or, if\n  not that,</p></li>\n<li><p id=\"so_29961100_29961422_2\">the rank of <code>S1</code> is better than the rank of <code>S2</code>, or <code>S1</code> and <code>S2</code> have the same rank and are distinguishable by the\n  rules in the paragraph below, or, if not that,</p></li>\n<li><p id=\"so_29961100_29961422_3\">[\u2026]</p></li>\n</ul>\n</blockquote>\n<p>While the specialization of the function template yields a parameter with an identity conversion, the non-template overload with <code>char const*</code> requires an Array-to-pointer conversion. Intuitively, we'd say that the former is a better match and should thus be selected. However, the array-to-pointer conversion is an Lvalue Transformation, excluded from the first bullet point. And since it has Exact Match Rank, the rank of the conversion isn't different than the rank of the conversion for <code>char const (&amp;)[N]</code>, which also has Exact Match Rank. \"The rules in the paragraph below\" cannot distinguish the conversions either, as they solely address derived-to-base conversions and such, but not array-to-pointer.</p>\n<p>In fact, the conversion to <code>char const (&amp;)[N]</code> is not better in any way. But overload resolution discriminates templates:</p>\n<blockquote>\n<p id=\"so_29961100_29961422_4\">Given these definitions, a viable function <code>F1</code> is defined to be a\n  better function than another viable function <code>F2</code> if for all arguments\n  <em>i</em>, ICS<em>i</em>(F1) is not a worse conversion sequence than ICS<em>i</em>(F2), and then</p>\n<ul>\n<li><p id=\"so_29961100_29961422_5\">for some argument <em>j</em>, ICS<em>j</em>(F1) is a better conversion\n  sequence than ICS<em>j</em>(F2), or, if not that, </p></li>\n<li><p id=\"so_29961100_29961422_6\">[\u2026] </p></li>\n<li><p id=\"so_29961100_29961422_7\"><strong><code>F1</code>\n  is not a function template specialization and <code>F2</code> is a function\n  template specialization, or, if not that,</strong></p></li>\n</ul>\n</blockquote>\n<p>Hence the non-template overload is selected.</p>\n", "LastActivityDate": "2015-04-30T07:19:08.283", "Score": "6", "CreationDate": "2015-04-30T07:19:08.283", "ParentId": "29961100", "CommentCount": "5", "OwnerUserId": "3647361"}, "29961139": {"Id": "29961139", "PostTypeId": "2", "Body": "<p>In your particular case the relevant part of the resolution rules applied is that non-template functions have precedence over template functions, that's why you see a pointer and not an array reference.</p>\n", "LastEditorUserId": "267482", "LastActivityDate": "2015-04-30T08:03:56.583", "Score": "3", "CreationDate": "2015-04-30T07:04:43.570", "ParentId": "29961100", "CommentCount": "3", "LastEditDate": "2015-04-30T08:03:56.583", "OwnerUserId": "267482"}, "29961100": {"ViewCount": "315", "Body": "<p>I have simple question about the c++ function match priority. Suppose I have such code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid func(const char*)\n{\n    std::cout &lt;&lt; \"const char*\" &lt;&lt; std::endl;\n}\n\ntemplate&lt;int N&gt;\nvoid func(const char (&amp;) [N])\n{\n    std::cout &lt;&lt; \"const char (&amp;) [N]\" &lt;&lt; std::endl;\n}\n\nint main(int argc, char* argv[])\n{\n    func(\"Hello world\");\n    return 0;\n}\n</code></pre>\n<p>The result of the code is (with <code>Apple LLVM version 6.1.0 (clang-602.0.49) (based on LLVM 3.6.0svn)</code>):</p>\n<pre><code>const char*\n</code></pre>\n<p>I think the literal type of the <code>\"Hello world\"</code> should be <code>const char[]</code>. Why the <code>const char*</code> version has a higher priority than the <code>const char (&amp;)[]</code> version?</p>\n", "AcceptedAnswerId": "29961422", "Title": "C++ function match priority", "CreationDate": "2015-04-30T07:02:32.943", "Id": "29961100", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-04-30T15:13:50.750", "LastEditorUserId": "149392", "LastActivityDate": "2015-04-30T15:13:50.750", "ClosedDate": "2015-04-30T14:36:22.860", "Score": "12", "OwnerUserId": "2289969", "Tags": "<c++><function>", "AnswerCount": "2"}});