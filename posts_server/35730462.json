post_cb({"35730623": {"Id": "35730623", "PostTypeId": "2", "Body": "<p>When you write</p>\n<pre><code>foo f;\n</code></pre>\n<p>The compiler needs to be able to construct f when it's initially created. Since that variable has automatic storage duration (the fancy C++ term for \"on the stack\"), the compiler is responsible for generating code to clean it up as well. That requires access to a destructor, but since you've deleted it, you get an error.</p>\n<p>When you write</p>\n<pre><code>foo* f = new foo;\n</code></pre>\n<p>You're creating a pointer to a foo object on the stack, and the compiler can destroy the pointer itself without access to the foo destructor. On the other hand, the object created with new foo has dynamic storage duration, meaning that you promise to manually destroy it. Consequently, the compiler doesn't need to access the destructor, so the creation step is fine. That said, if you then write</p>\n<pre><code>delete f;\n</code></pre>\n<p>You should get an error because that operation does need the destructor.</p>\n<p><strong>EDIT</strong>: From your follow-up, my sense is that you're wondering why the default constructor still is generated even though the destructor is deleted. I have a draft of the C++14 spec and in \u00a712.1.4, it says the following:</p>\n<blockquote>\n<p id=\"so_35730462_35730623_0\">A default constructor for a class X is a constructor of class X that can be called without an argument. If\n  there is no user-declared constructor for class X, a constructor having no parameters is implicitly declared\n  as defaulted (8.4). An implicitly-declared default constructor is an inline public member of its class. A\n  defaulted default constructor for class X is defined as deleted if:</p>\n<p id=\"so_35730462_35730623_1\">\u2014 X is a union-like class that has a variant member with a non-trivial default constructor,</p>\n<p id=\"so_35730462_35730623_2\">\u2014 any non-static data member with no brace-or-equal-initializer is of reference type,</p>\n<p id=\"so_35730462_35730623_3\">\u2014 any non-variant non-static data member of const-qualified type (or array thereof) with no brace-or-\n  equal-initializer does not have a user-provided default constructor,</p>\n<p id=\"so_35730462_35730623_4\">\u2014 X is a union and all of its variant members are of const-qualified type (or array thereof),</p>\n<p id=\"so_35730462_35730623_5\">\u2014 X is a non-union class and all members of any anonymous union member are of const-qualified type\n  (or array thereof),</p>\n<p id=\"so_35730462_35730623_6\">\u2014 any direct or virtual base class, or non-static data member with no brace-or-equal-initializer, has class\n  type M (or array thereof) and either M has no default constructor or overload resolution (13.3) as applied\n  to M\u2019s default constructor results in an ambiguity or in a function that is deleted or inaccessible from\n  the defaulted default constructor, or</p>\n<p id=\"so_35730462_35730623_7\">\u2014 any direct or virtual base class or non-static data member has a type with a destructor that is deleted\n  or inaccessible from the defaulted default constructor.</p>\n</blockquote>\n<p>In other words, the deletion of a destructor has no effect on the autogeneration of a default constructor.</p>\n", "LastEditorUserId": "501557", "LastActivityDate": "2016-03-01T20:05:48.503", "Score": "10", "CreationDate": "2016-03-01T18:29:38.423", "ParentId": "35730462", "CommentCount": "3", "LastEditDate": "2016-03-01T20:05:48.503", "OwnerUserId": "501557"}, "bq_ids": {"n4140": {"so_35730462_35730623_1": {"length": 7, "quality": 1.0, "section_id": 369}, "so_35730462_35730623_7": {"length": 11, "quality": 0.7857142857142857, "section_id": 369}, "so_35730462_35730623_3": {"length": 13, "quality": 0.8666666666666667, "section_id": 369}, "so_35730462_35730623_0": {"length": 32, "quality": 1.0, "section_id": 369}, "so_35730462_35730623_2": {"length": 6, "quality": 1.0, "section_id": 369}, "so_35730462_35730623_5": {"length": 11, "quality": 1.0, "section_id": 369}, "so_35730462_35730623_6": {"length": 25, "quality": 0.8620689655172413, "section_id": 369}, "so_35730462_35730623_4": {"length": 9, "quality": 1.0, "section_id": 369}}, "n3337": {"so_35730462_35730623_1": {"length": 7, "quality": 1.0, "section_id": 359}, "so_35730462_35730623_7": {"length": 14, "quality": 1.0, "section_id": 359}, "so_35730462_35730623_3": {"length": 13, "quality": 0.8666666666666667, "section_id": 359}, "so_35730462_35730623_0": {"length": 32, "quality": 1.0, "section_id": 359}, "so_35730462_35730623_2": {"length": 6, "quality": 1.0, "section_id": 359}, "so_35730462_35730623_5": {"length": 11, "quality": 1.0, "section_id": 359}, "so_35730462_35730623_6": {"length": 28, "quality": 0.9655172413793104, "section_id": 359}, "so_35730462_35730623_4": {"length": 9, "quality": 1.0, "section_id": 359}}, "n4659": {"so_35730462_35730623_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 382}, "so_35730462_35730623_7": {"length": 11, "quality": 0.7857142857142857, "section_id": 382}, "so_35730462_35730623_3": {"length": 13, "quality": 0.8666666666666667, "section_id": 382}, "so_35730462_35730623_0": {"length": 24, "quality": 0.75, "section_id": 381}, "so_35730462_35730623_6": {"length": 24, "quality": 0.8275862068965517, "section_id": 382}, "so_35730462_35730623_5": {"length": 11, "quality": 1.0, "section_id": 382}, "so_35730462_35730623_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 382}, "so_35730462_35730623_4": {"length": 9, "quality": 1.0, "section_id": 382}}}, "35730462": {"ViewCount": "160", "Body": "<p>Let's say I have something that looks like this:</p>\n<pre><code>struct foo {\n    ~foo() = delete;\n}\n</code></pre>\n<p>And let's say I later dynamically allocate an object of type <code>foo</code>:</p>\n<pre><code>foo *f = new foo;\n</code></pre>\n<p>This is fine; I assume the synthesized default constructor is used to construct the object denoted by <code>f</code>, however:</p>\n<pre><code>foo f2;\n</code></pre>\n<p>Gives me an error:</p>\n<blockquote>\n<p id=\"so_35730462_35730462_0\">Attempt to use a deleted function</p>\n</blockquote>\n<p>So how is the object denoted by <code>f</code> constructed if the default constructor for <code>foo</code> is implicitly deleted?</p>\n<p>Moreover, assuming <code>foo</code> has the private member <code>size_t n</code>. What is the value of <code>n</code> for a dynamically allocated <code>foo</code>, such as the one denoted by <code>f</code>?</p>\n", "AcceptedAnswerId": "35730623", "Title": "How are dynamic objects of a type with a deleted destructor constructed?", "CreationDate": "2016-03-01T18:21:49.263", "Id": "35730462", "CommentCount": "10", "LastEditDate": "2016-03-01T21:28:26.210", "PostTypeId": "1", "LastEditorUserId": "501557", "LastActivityDate": "2016-03-01T21:28:26.210", "Score": "4", "OwnerUserId": "6003962", "Tags": "<c++><c++11><destructor><c++14>", "AnswerCount": "1"}});