post_cb({"bq_ids": {"n4140": {"so_24100576_24100676_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 6146}}, "n3337": {"so_24100576_24100676_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 5909}}, "n4659": {"so_24100576_24100676_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 7642}}}, "24100576": {"ViewCount": "453", "Body": "<p>I tried running the following code code:</p>\n<pre><code>char c = (2 &lt;&lt; 7) &gt;&gt; 7\n</code></pre>\n<p>which should return 0 because 2 has this binary representation as a <code>char</code>:</p>\n<pre><code>0 0 0 0 0 0 1 0\n</code></pre>\n<p>After 7 shifts left, we get </p>\n<pre><code>0 0 0 0 0 0 0 0\n</code></pre>\n<p>Then, after seven shifts right, we get</p>\n<pre><code>0 0 0 0 0 0 0 0\n</code></pre>\n<p>However, I'm getting the result as 2, not 0.</p>\n<p>The compiler says that <code>2 &lt;&lt; 7</code> is 256, but it's a <code>char</code> and so it shouldn't be 256.</p>\n<p>I understand that the <code>2 &lt;&lt; 7</code> will be calculated as <code>int</code>s and the answer will be put into <code>c</code> so <code>256 &gt;&gt; 7</code> is 2.</p>\n<p>I tried to cast 2 to char (ex: <code>(char)2&gt;&gt;7</code>) but it doesn't work either.</p>\n<p>I'm trying to extract each bit from the <code>char</code>, so I wrote this code:</p>\n<pre><code>char c = 0x02;\nfor(int i=0;i&lt;7;i++)\n{\n    char current = (c&lt;&lt;i)&gt;&gt;7;\n}\n</code></pre>\n<p>How can I get each bit? What's wrong with my way?</p>\n", "Title": "Bitshifting in C++ producing the wrong answer", "CreationDate": "2014-06-07T18:57:09.367", "LastActivityDate": "2015-12-30T19:30:23.887", "CommentCount": "5", "LastEditDate": "2015-12-30T19:30:23.887", "PostTypeId": "1", "LastEditorUserId": "501557", "Id": "24100576", "Score": "5", "OwnerUserId": "2462683", "Tags": "<c++><shift>", "AnswerCount": "3"}, "24100658": {"Id": "24100658", "PostTypeId": "2", "Body": "<p>To get each bit, you could write:</p>\n<pre><code>(c &gt;&gt; i) &amp; 0x01\n</code></pre>\n<p>Advantage: It works for any integer type. </p>\n", "LastActivityDate": "2014-06-07T19:06:58.320", "CommentCount": "1", "CreationDate": "2014-06-07T19:06:58.320", "ParentId": "24100576", "Score": "4", "OwnerUserId": "1419315"}, "24100607": {"Id": "24100607", "PostTypeId": "2", "Body": "<p>The result of an arithmetic shift operation with one operand being an <code>int</code> in C++ is always an <code>int</code>. Therefore, when you write</p>\n<pre><code>current = (c &lt;&lt; i) &gt;&gt; 7;\n</code></pre>\n<p>C++ will interpret <code>(c &lt;&lt; i)</code> and <code>(c &lt;&lt; i) &gt;&gt; 7</code> as <code>int</code>s, casting back to a <code>char</code> only when the assignment is done. Since the temporary values are <code>int</code>s, no overflow occurs and the result should come out to the integer result casted to a <code>char</code>.</p>\n<p>Hope this helps!</p>\n", "LastActivityDate": "2014-06-07T19:00:44.510", "CommentCount": "4", "CreationDate": "2014-06-07T19:00:44.510", "ParentId": "24100576", "Score": "7", "OwnerUserId": "501557"}, "24100676": {"Id": "24100676", "PostTypeId": "2", "Body": "<p>According to 5.8 [expr.shift] paragraph 1:</p>\n<blockquote>\n<p id=\"so_24100576_24100676_0\">... The operands shall be of integral or unscoped enumeration type and integral promotions are performed. The type of the result is that of the promoted left operand. ...</p>\n</blockquote>\n<p>This for a left argument of type <code>char</code> together with the rules on integer promotion (4.5 [conv.prom]) says that the result is <code>int</code>. Of course, an <code>int</code> can hold the result of <code>2 &lt;&lt; 7</code>. You can easily verify this behavior, too:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid print(char c) { std::cout &lt;&lt; \"char=\" &lt;&lt; int(c) &lt;&lt; \"\\n\"; }\nvoid print(int i) { std::cout &lt;&lt; \"int=\" &lt;&lt; i &lt;&lt; \"\\n\"; }\n\nint main()\n{\n    print(2 &lt;&lt; 7);\n}\n</code></pre>\n<p>The most simple approach to get the bits of a value is to use a <code>std::bitset&lt;N&gt;</code> with <code>N</code> being the digits of the corresponding unsigned type, e.g.:</p>\n<pre><code>char c('a');\nstd::bitset&lt;std::numeric_limits&lt;unsigned char&gt;::digits&gt; bits(c);\n</code></pre>\n<p>If you want to get bits yourself you'd mask the bits using its <code>unsigned</code> counterpart of the integer type, e.g.:</p>\n<pre><code>template &lt;typename T&gt;\nvoid get_bits(T val)\n{\n    typedef typename std::make_unsigned&lt;T&gt;::type U;\n    U value(val);\n    for (std::size_t s(std::numeric_limits&lt;U&gt;::digits); s-- != 0; ) {\n        std::cout &lt;&lt; bool(value &amp; (1u &lt;&lt; s));\n    }\n    std::cout &lt;&lt; '\\n';\n}\n</code></pre>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2014-06-07T19:24:46.123", "Score": "4", "CreationDate": "2014-06-07T19:09:32.607", "ParentId": "24100576", "CommentCount": "0", "OwnerUserId": "1120273", "LastEditDate": "2014-06-07T19:24:46.123"}});