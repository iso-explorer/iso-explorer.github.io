post_cb({"12554621": {"ParentId": "12554619", "LastEditDate": "2012-09-23T17:52:27.220", "CommentCount": "0", "CreationDate": "2012-09-23T17:38:28.977", "OwnerUserId": "500104", "LastEditorUserId": "500104", "PostTypeId": "2", "Id": "12554621", "Score": "13", "Body": "<p>The standard handles this in a special case in <code>\u00a712.2 [class.temporary]</code>:</p>\n<blockquote>\n<p id=\"so_12554619_12554621_0\">p4 There are two contexts in which temporaries are destroyed at a different point than the end of the full-expression. [...]</p>\n<p id=\"so_12554619_12554621_1\">p5 The second context is when a reference is bound to a temporary. The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference except:</p>\n<ul>\n<li>A temporary bound to a reference parameter in a function call (5.2.2) <strong>persists until the completion of the full-expression containing the call</strong>.</li>\n</ul>\n</blockquote>\n<p>The standard also has a handy note on full-expressions and the evaluation of their subexpressions with regards to default parameters in <code>\u00a71.9 [intro.execution] p11</code>:</p>\n<blockquote>\n<p id=\"so_12554619_12554621_2\">[ <em>Note:</em> The evaluation of a full-expression can include the evaluation of subexpressions that are not lexically part of the full-expression. For example, subexpressions involved in evaluating <strong>default arguments (8.3.6) are considered to be created in the expression that calls the function</strong>, not the expression that defines the default argument. <em>\u2014end note</em> ]</p>\n</blockquote>\n", "LastActivityDate": "2012-09-23T17:52:27.220"}, "12554619": {"CommentCount": "3", "ViewCount": "480", "LastActivityDate": "2012-09-23T18:16:14.437", "Body": "<p>I thought references only extend the lifetime of temporaries to the lifetime of the reference itself, but the output of the following snippet seems contradictory:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct X{ ~X(){ std::cout &lt;&lt; \"Goodbye, cruel world!\\n\"; } };\n\nX const&amp; f(X const&amp; x = X()){\n  std::cout &lt;&lt; \"Inside f()\\n\";\n  return x;\n}\n\nvoid g(X const&amp; x){\n  std::cout &lt;&lt; \"Inside g()\\n\";\n}\n\nint main(){\n  g(f());\n}\n</code></pre>\n<p><a href=\"http://liveworkspace.org/code/9d23d2b39382ce671217c3707d9349aa\" rel=\"noreferrer\">Live example.</a> Output:</p>\n<pre><code>Inside f()\nInside g()\nGoodbye, cruel world!\n</code></pre>\n<p>So it seems the temporary is destroyed after <code>g()</code> is called... what gives?</p>\n", "PostTypeId": "1", "AcceptedAnswerId": "12554621", "FavoriteCount": "2", "Title": "What is the lifetime of a default argument temporary bound to a reference parameter?", "Id": "12554619", "Score": "10", "CreationDate": "2012-09-23T17:38:28.977", "Tags": "<c++><language-lawyer><lifetime><temporary-objects>", "OwnerUserId": "500104", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_12554619_12554621_1": {"section_id": 382, "quality": 0.9047619047619048, "length": 19}, "so_12554619_12554621_2": {"section_id": 5807, "quality": 0.7931034482758621, "length": 23}, "so_12554619_12554621_0": {"section_id": 381, "quality": 1.0, "length": 10}}, "n3337": {"so_12554619_12554621_1": {"section_id": 373, "quality": 0.9047619047619048, "length": 19}, "so_12554619_12554621_2": {"section_id": 5580, "quality": 0.7931034482758621, "length": 23}, "so_12554619_12554621_0": {"section_id": 372, "quality": 1.0, "length": 10}}, "n4659": {"so_12554619_12554621_1": {"section_id": 397, "quality": 0.8571428571428571, "length": 18}, "so_12554619_12554621_2": {"section_id": 7268, "quality": 0.7931034482758621, "length": 23}, "so_12554619_12554621_0": {"section_id": 396, "quality": 0.9, "length": 9}}}, "12554928": {"ParentId": "12554619", "CommentCount": "3", "Body": "<p>Interesting, +1. (I do not mean to compete with your nice self answer here). Just a side note for anyone interested. If you want a similar effect but allowing non-const you could use move semantics:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct X{\n   ~X(){ std::cout &lt;&lt; \"Goodbye, cruel world!\\n\"; }\n   X(X &amp;&amp; x){  std::cout &lt;&lt; \"moved \"; }\n   X(){}\n};\n\nX  f(X x = X()){\n  std::cout &lt;&lt; \"Inside f()\\n\";\n  return x;\n}\n\nvoid g(X x){\n  std::cout &lt;&lt; \"Inside g()\\n\";\n}\n\nint main(){\n   g(f());\n}\n</code></pre>\n<p>gives </p>\n<pre><code>Inside f()\nmoved Inside g()\nGoodbye, cruel world!\nGoodbye, cruel world!\n</code></pre>\n", "OwnerUserId": "1149664", "PostTypeId": "2", "Id": "12554928", "Score": "1", "CreationDate": "2012-09-23T18:16:14.437", "LastActivityDate": "2012-09-23T18:16:14.437"}});