post_cb({"6632915": {"CommentCount": "2", "AcceptedAnswerId": "6632937", "PostTypeId": "1", "LastEditorUserId": "500104", "CreationDate": "2011-07-09T05:17:31.683", "LastActivityDate": "2012-02-05T20:41:22.133", "LastEditDate": "2012-02-05T20:09:03.743", "ViewCount": "4586", "FavoriteCount": "2", "Title": "Is the memory in std::array contiguous?", "Id": "6632915", "Score": "14", "Body": "<p>Is the memory in <code>std::array</code> contiguous? Is the following valid/good practice?</p>\n<pre><code>std::array&lt;type1,Num&gt; arr = //initialize value\ntype1 * ptr = &amp;arr[0];\n</code></pre>\n<p>Could I then pass <code>ptr</code> to functions expecting a c-style array?</p>\n", "Tags": "<c++><arrays><pointers><c++11><contiguous>", "OwnerUserId": "742350", "AnswerCount": "2"}, "6632993": {"ParentId": "6632915", "CommentCount": "2", "Body": "<p>Yes the memory of <code>std::array</code> is contiguous. On VC10, it is declared as:</p>\n<pre><code>template&lt;class _Ty,\n    size_t _Size&gt;\n    class array\n    { // fixed size array of values\n                ... \n         _Ty _Elems[_Size == 0 ? 1 : _Size];\n    };\n</code></pre>\n<p>Where <code>_Elemes</code> is nothing but a simple array of given type.</p>\n", "OwnerUserId": "264325", "PostTypeId": "2", "Id": "6632993", "Score": "0", "CreationDate": "2011-07-09T05:36:16.923", "LastActivityDate": "2011-07-09T05:36:16.923"}, "6632937": {"ParentId": "6632915", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>Yes, it is contiguous, as it is basically (and actually) a <code>type arr[10];</code>, but with STL like interface. It also doesn't decay to a pointer on the slightest provocation.</p>\n<p>You can safely pass <code>&amp;arr[0]</code> to a function expecting a C-style array, that's the design goal of it. To use it with the STL algorithms however, just use the <code>begin</code> and <code>end</code> functions:</p>\n<pre><code>// either members\nstd::sort(arr.begin(), arr.end());\n// or free from &lt;iterator&gt;\nstd::sort(std::begin(arr), std::end(arr));\n</code></pre>\n<hr>\n<p>For the language lawyer part, <code>\u00a723.3.2.1 [array.overview] p1</code>:</p>\n<blockquote>\n<p id=\"so_6632915_6632937_0\">The header <code>&lt;array&gt;</code> defines a class template for storing fixed-size sequences of objects. An array supports random access iterators. An instance of <code>array&lt;T, N&gt;</code> stores <code>N</code> elements of type <code>T</code>, so that <code>size() == N</code> is an invariant. <strong>The elements of an <code>array</code> are stored contiguously</strong>, meaning that if <code>a</code> is an <code>array&lt;T, N&gt;</code> then it obeys the identity <code>&amp;a[n] == &amp;a[0] + n</code> for all <code>0 &lt;= n &lt; N</code>.</p>\n</blockquote>\n<p>And <code>\u00a723.3.2.1 [array.overview] p2</code>:</p>\n<blockquote>\n<p id=\"so_6632915_6632937_1\">An array is an aggregate (8.5.1) that can be initialized with the syntax</p>\n<ul>\n<li><code>array&lt;T, N&gt; a = {</code> <em>initializer-list</em> <code>};</code></li>\n</ul>\n</blockquote>\n<p>Also, in <code>p3</code>, listing the members of <code>std::array</code>:</p>\n<blockquote>\n<p id=\"so_6632915_6632937_2\"><code>T elems[N]; // exposition only</code><br>\n  [ <em>Note:</em> The member variable <code>elems</code> is shown for exposition only, to emphasize that <code>array</code> is a class aggregate. The name <code>elems</code> is not part of <code>array</code>\u2019s interface. <em>\u2014end note</em> ]</br></p>\n</blockquote>\n</hr>", "OwnerUserId": "500104", "LastEditorUserId": "500104", "LastEditDate": "2012-02-05T20:41:22.133", "Id": "6632937", "Score": "27", "CreationDate": "2011-07-09T05:21:19.820", "LastActivityDate": "2012-02-05T20:41:22.133"}, "bq_ids": {"n4140": {"so_6632915_6632937_1": {"section_id": 775, "quality": 0.8333333333333334, "length": 5}, "so_6632915_6632937_0": {"section_id": 774, "quality": 0.9393939393939394, "length": 31}, "so_6632915_6632937_2": {"section_id": 777, "quality": 0.6666666666666666, "length": 14}}, "n3337": {"so_6632915_6632937_1": {"section_id": 762, "quality": 0.8333333333333334, "length": 5}, "so_6632915_6632937_0": {"section_id": 761, "quality": 0.9393939393939394, "length": 31}, "so_6632915_6632937_2": {"section_id": 764, "quality": 0.6666666666666666, "length": 14}}, "n4659": {"so_6632915_6632937_0": {"section_id": 835, "quality": 0.5151515151515151, "length": 17}}}});