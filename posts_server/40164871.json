post_cb({"40165003": {"ParentId": "40164871", "CommentCount": "5", "Body": "<p>The way <em>using-directive</em>s work is (<a href=\"https://timsong-cpp.github.io/cppwp/namespace.udir#2\" rel=\"nofollow\">[namespace.udir]/2</a>):</p>\n<blockquote>\n<p id=\"so_40164871_40165003_0\">A <em>using-directive</em> specifies that the names in the nominated namespace\n  can be used in the scope in which the <em>using-directive</em> appears after\n  the <em>using-directive</em>. During unqualified name lookup\n  ([basic.lookup.unqual]), the names appear as if they were declared in\n  the nearest enclosing namespace which contains both the\n  <em>using-directive</em> and the nominated namespace. [ <em>Note</em>: In this context,\n  \u201ccontains\u201d means \u201ccontains directly or indirectly\u201d.  \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p><code>using namespace ::std;</code> causes the members of <code>::std</code> to be visible, for this purpose, as if they were members of the global namespace. They are therefore hidden, per the normal unqualified lookup rules, by anything with the same name in the namespace <code>Toolbox</code>.</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "40165003", "Score": "2", "CreationDate": "2016-10-20T21:39:26.797", "LastActivityDate": "2016-10-20T21:39:26.797"}, "40164871": {"CommentCount": "0", "ViewCount": "55", "CreationDate": "2016-10-20T21:28:21.503", "LastActivityDate": "2016-10-20T21:39:26.797", "Title": "Why isn't std::begin/end being considered here?", "AcceptedAnswerId": "40165003", "PostTypeId": "1", "Id": "40164871", "Score": "0", "Body": "<p>I have a template free function algorithm \"contains\":</p>\n<pre><code>template &lt;typename collection_type, typename element_type, typename comparison_function_type&gt;\nbool contains(const collection_type &amp; collection, const element_type &amp; element, comparison_function_type comparison_function)\n{\n    using namespace ::std;\n    return end(collection) != find_if(begin(collection), end(collection), [&amp;](const element_type &amp; candidate) { return comparison_function(candidate, element); });\n}\n</code></pre>\n<p>This works for the following or fails for the following depending on what's in scope:</p>\n<pre><code>        static const TCHAR * kPackFiles[] = { _T(\"boxit\"), _T(\"pack\") };\n        const auto &amp; name = filename.GetName();\n        if (contains(kPackFiles, name, Toolbox::case_insensitive_equal_to&lt;Toolbox::TCHARStringPolicy&gt;()))\n              do_something_interesting();\n</code></pre>\n<p>The above compiles unless the following is in scope:</p>\n<pre><code>template &lt;typename T&gt;\nconst typename ::std::enable_if&lt;::std::is_same&lt;T, CStringA&gt;::value || ::std::is_same&lt;T, CStringW&gt;::value, T&gt;::type::XCHAR *\n    begin(const T &amp; str) { return str.GetString(); }\n\ntemplate &lt;typename T&gt;\nconst typename ::std::enable_if&lt;::std::is_same&lt;T, CStringA&gt;::value || ::std::is_same&lt;T, CStringW&gt;::value, T&gt;::type::XCHAR *\n    end(const T &amp; str) { return str.GetString() + str.GetLength(); }\n</code></pre>\n<p>The above is intended to extend CStringA and CStringW to offer const char_type iterators on them.  This generally works for other scenarios such as <code>for (c : my_cstring) cout &lt;&lt; c;</code></p>\n<p>But for the above case - where <code>collection_type=const TCHAR *[2]</code> I get messages from the compiler that it failed to specialize function template &amp; only lists the specializations found above.</p>\n<p>Here's the exact message:</p>\n<pre><code>error C2893: Failed to specialize function template 'const ::std::enable_if&lt;std::is_same&lt;T,CStringA&gt;::value||std::is_same&lt;T,CStringW&gt;::value,T&gt;::type::XCHAR *Toolbox::end(const T &amp;)'\n</code></pre>\n<p>And I'm guessing that I've run up against some namespace rules here.</p>\n<p>I'm in the midst of moving my custom library code into <code>namespace Toolbox</code> - including both <code>contains</code> template and <code>begin</code> and <code>end</code> for CStringA/W.</p>\n<p>I've verified that if I simply don't define my <code>CString</code> versions of begin/end that the above code does compile.  So the necessary definition of begin/end for raw arrays is include &amp; visible.</p>\n<p>But I'm at a loss as to why my <code>Toolbox::contains</code> template won't consider <code>std::begin/end</code> for this case - and instead tries to generate <code>Toolbox::begin(const CString &amp;)</code> for <code>kPackFiles</code>?</p>\n", "Tags": "<c++><templates><iterator><enable-if>", "OwnerUserId": "112755", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_40164871_40165003_0": {"section_id": 5510, "quality": 0.8947368421052632, "length": 34}}, "n3337": {"so_40164871_40165003_0": {"section_id": 5296, "quality": 0.8947368421052632, "length": 34}}, "n4659": {"so_40164871_40165003_0": {"section_id": 6945, "quality": 0.8947368421052632, "length": 34}}}});