post_cb({"48804017": {"Id": "48804017", "PostTypeId": "2", "Body": "<p>Yes, you will ultimately run into data races, not only <code>length</code> being written and read before <code>data</code> is written, but also parts of those members will be written out of sync of your process reading it.</p>\n<p>Although lock-free is the new trend, I'd suggest to go for a simpler tool as your first IPC sync job: the semaphore. On linux, the following man pages will be useful:</p>\n<ul>\n<li><a href=\"http://man7.org/linux/man-pages/man3/sem_init.3.html\" rel=\"nofollow noreferrer\"><code>sem_init</code></a></li>\n<li><a href=\"http://man7.org/linux/man-pages/man3/sem_wait.3.html\" rel=\"nofollow noreferrer\"><code>sem_wait</code></a></li>\n<li><a href=\"http://man7.org/linux/man-pages/man3/sem_post.3.html\" rel=\"nofollow noreferrer\"><code>sem_post</code></a></li>\n</ul>\n<p>The idea is to have both processes signal the other one it is currently reading or writing the shared memory segment. With a semaphore, you can write inter-process mutexes:</p>\n<pre><code>Producer:\nwhile true:\n    (opt) create resource\n    lock semaphore (sem_wait)\n    copy resource to shm\n    unlock semaphore (sem_post)\n\nConsumer:\nwhile true:\n    lock semaphore (sem_wait)\n    copy resource to local memory\n        or crunch resource\n    unlock semaphore (sem_post)\n</code></pre>\n<p>If for instance Producer is writing into shm while Consumer calls <code>sem_wait</code>, Consumer will block until after Producer will call <code>sem_post</code>, <strong>but</strong>, you have <em>no guarantee</em> Producer won't go for another loop, writing two times in a row before Consumer will be woke up. You have to build a mechanism unsure Producer  &amp; Consumer do work alternatively.</p>\n", "LastEditorUserId": "5470596", "LastActivityDate": "2018-02-15T09:47:03.363", "Score": "0", "CreationDate": "2018-02-15T09:41:24.750", "ParentId": "48803929", "CommentCount": "1", "OwnerUserId": "5470596", "LastEditDate": "2018-02-15T09:47:03.363"}, "bq_ids": {"n4140": {"so_48803929_48804302_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 2670}, "so_48803929_48804302_0": {"length": 35, "quality": 0.9210526315789473, "section_id": 1164}}, "n3337": {"so_48803929_48804302_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 2633}, "so_48803929_48804302_0": {"length": 35, "quality": 0.9210526315789473, "section_id": 1162}}, "n4659": {"so_48803929_48804302_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 3410}, "so_48803929_48804302_0": {"length": 35, "quality": 0.9210526315789473, "section_id": 1259}}}, "48804302": {"Id": "48804302", "PostTypeId": "2", "Body": "<p>To avoid this, you would want to make the structure <code>std::atomic</code> and access it with acquire-release memory ordering.  On most modern processors, the instructions this inserts are memory fences, which guarantee that the writer wait for all loads to complete before it begins writing, and that the reader wait for all stores to complete before it begins reading.</p>\n<p>There are, in addition, locking primitives in POSIX, but the <code>&lt;atomic&gt;</code> header is newer and what you probably want.</p>\n<h3>What the Standard Says</h3>\n<p>From [atomics.lockfree], emphasis added:</p>\n<blockquote>\n<p id=\"so_48803929_48804302_0\">Operations that are lock-free should also be address-free. That is, atomic operations on the same memory location via two different addresses will communicate atomically. The implementation should not depend on any per-process state. This restriction enables communication by memory that is mapped into a process more than once and by memory that is <strong>shared between two processes.</strong></p>\n</blockquote>\n<p>For lockable atomics, the standard says in [thread.rec.lockable.general], emphasis added:</p>\n<blockquote>\n<p id=\"so_48803929_48804302_1\">An execution agent is an entity such as a thread that may perform work in parallel with other execution agents. [...] Implementations or users may introduce other kinds of agents <strong>such as processes</strong> [....]</p>\n</blockquote>\n<p>You will sometimes see the claim that the standard supposedly makes no mention of using the <code>&lt;atomic&gt;</code> primitives with memory shared between processes, only threads.  This is incorrect.</p>\n<p>However, passing pointers to the other process through shared memory will not work, as the shared memory may be mapped to different parts of the address space, and of course a pointer to any object not in shared memory is right out.  Indices and offsets of objects within shared memory will.  (Or, if you really need pointers, Boost provides IPC-safe wrappers.)</p>\n", "LastEditorUserId": "4474419", "LastActivityDate": "2018-02-15T10:26:09.843", "Score": "3", "CreationDate": "2018-02-15T09:56:17.550", "ParentId": "48803929", "CommentCount": "7", "OwnerUserId": "4474419", "LastEditDate": "2018-02-15T10:26:09.843"}, "48803929": {"ViewCount": "55", "Body": "<p>Let's say I am on CentOS 7 x86_64 + GCC 7.</p>\n<p>I would like to create a ringbuffer in shared memory.</p>\n<p>If I have two processes Producer and Consumer, and both share a named shared memory, which is created/accessed through shm_open() + mmap().</p>\n<p>If Producer writes something like:</p>\n<pre><code>struct Data {\nuint64_t length;\nchar data[100];\n}\n</code></pre>\n<p>to the shared memory at a random time, and the Consumer is constantly polling the shared memory to read.  Will I have some sort of synchronization issue that the member length is seen but the member data is still in the progress of writing?  If yes, what's the most efficient technique to avoid the issue?</p>\n<p>I see this post:\n<a href=\"https://stackoverflow.com/questions/22207546/shared-memory-ipc-synchronization-lock-free\">Shared-memory IPC synchronization (lock-free)</a></p>\n<p>But I would like to get a deeper, more low level of understanding what's required to synchronize between two processes efficiently.</p>\n<p>Thanks in advance!</p>\n", "Title": "Visibility of change to shared memory from shm_open() + mmap()", "CreationDate": "2018-02-15T09:34:57.603", "LastActivityDate": "2018-02-15T10:39:08.970", "CommentCount": "0", "LastEditDate": "2018-02-15T10:39:08.970", "PostTypeId": "1", "LastEditorUserId": "2206057", "Id": "48803929", "Score": "1", "OwnerUserId": "2206057", "Tags": "<c++><c><linux><posix><shared-memory>", "AnswerCount": "2"}});