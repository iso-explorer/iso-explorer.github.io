post_cb({"46476150": {"CommentCount": "4", "ViewCount": "60", "PostTypeId": "1", "LastEditorUserId": "1794803", "CreationDate": "2017-09-28T18:36:37.553", "LastActivityDate": "2017-09-28T18:52:44.640", "Title": "About correct definition of iterator_category", "LastEditDate": "2017-09-28T18:52:44.640", "Id": "46476150", "Score": "2", "Body": "<p>Is this a well-defined iterator?</p>\n<pre><code>struct my_iterator\n{\n    struct iterator_category : std::bidirectional_iterator_tag,\n                               std::output_iterator_tag\n    {};\n\n    // rest of implementation. Assume it correctly models \n    // the output and bidirectional iterator requirements.\n};\n</code></pre>\n<p>I have read in different places that the inner <code>iterator_category</code> must be an alias (<code>typedef</code>/<code>using</code>) to one of the standard iterator category tags, but the standard exactly says (C++14/N3797):</p>\n<blockquote>\n<p id=\"so_46476150_46476150_0\"><strong>[std.iterator.tags]/1</strong> For every iterator of type Iterator, <code>iterator_traits&lt;Iterator&gt;::iterator_category</code> shall be defined to be\n  the most specific category tag that describes the iterator\u2019s behavior.</p>\n</blockquote>\n<p>It doesn't say that must be strictly an <em>alias</em>, but that it must <em>be</em> one of them, because inheritance defines an <em>is-a</em> relationship after all.</p>\n<p>Because in case it isn't allowed, <code>boost::iterator_facade</code> would define non-valid iterators (it uses inheritance in some cases to define a combined category/traversal tag).</p>\n<p>In case it is allowed, shouldn't the standard impose some further requirements to <code>iterator_category</code> types, to help implementations know what can they expect about the inner type?</p>\n<p>What if <code>iterator_category</code> is not default constructible, for example? Implementations couldn't make use of function overloading to select a best algorithm implementation, and play strictly with template specialization and <code>std::is_base_of</code> and the sort, forcing more verbose implementations.</p>\n", "Tags": "<c++><iterator><c++14>", "OwnerUserId": "1794803", "AnswerCount": "0"}, "bq_ids": {"n4140": {"so_46476150_46476150_0": {"section_id": 5588, "quality": 0.8, "length": 12}}, "n3337": {"so_46476150_46476150_0": {"section_id": 5371, "quality": 0.8, "length": 12}}, "n4659": {"so_46476150_46476150_0": {"section_id": 7034, "quality": 0.8, "length": 12}}}});