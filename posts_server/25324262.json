post_cb({"25324595": {"ParentId": "25324262", "CommentCount": "3", "Body": "<p>It's a bug.</p>\n<p>When <a href=\"https://gcc.gnu.org/ml/libstdc++/2009-05/msg00080.html\">I implemented it</a> for libstdc++ in 2009 the spec in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2619.pdf\">N2619</a> required <code>E</code> to be a polymorphic type, but the final spec in the 2011 standard is different and the implementation in libstdc++ was never changed.</p>\n", "OwnerUserId": "981959", "PostTypeId": "2", "Id": "25324595", "Score": "15", "CreationDate": "2014-08-15T10:02:38.547", "LastActivityDate": "2014-08-15T10:02:38.547"}, "25324599": {"ParentId": "25324262", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It does indeed look like a bug (see other answers), ref \u00a718.8.6/7. If not already derived from <code>std::nested_exception</code>, an unspecified type is used that is derived from <code>E</code> and <code>nested_exception</code>.</p>\n<p>As a proposed <strong>work around</strong> whilst it is being fixed, explicitly <strong>derive from <code>std::nested_exception</code></strong> or implement the <strong>destructor as virtual</strong>;</p>\n<pre><code>#include &lt;exception&gt;\n\nstruct E : std::nested_exception { E(int) {} };\n// Alternative workaround... virtual destructor\n// struct E { E(int) {} virtual ~E() {} };\n\nint main() {\n try {\n  std::throw_with_nested(E(42));\n  return 0;\n }\n catch (E&amp;) {\n }\n}\n</code></pre>\n<p>Sample <a href=\"http://coliru.stacked-crooked.com/a/be890b683894e055\" rel=\"nofollow\">here</a>.</p>\n", "OwnerUserId": "3747990", "LastEditorUserId": "3747990", "LastEditDate": "2014-08-18T07:02:09.960", "Id": "25324599", "Score": "3", "CreationDate": "2014-08-15T10:02:48.640", "LastActivityDate": "2014-08-18T07:02:09.960"}, "25324380": {"ParentId": "25324262", "CommentCount": "1", "Body": "<p>This would appear to be a bug.</p>\n<p>The standard says of <code>std::throw_with_nested</code>:</p>\n<blockquote>\n<p id=\"so_25324262_25324380_0\"><code>[[noreturn]] template &lt;class T&gt; void throw_with_nested(T&amp;&amp; t);</code></p>\n<p id=\"so_25324262_25324380_1\">Let <code>U</code> be <code>remove_reference&lt;T&gt;::type.</code></p>\n<p id=\"so_25324262_25324380_2\"><em>Requires:</em> <code>U</code> shall be <code>CopyConstructible</code>.</p>\n<p id=\"so_25324262_25324380_3\"><em>Throws:</em> if <code>U</code> is a non-union class type not derived from <code>nested_exception</code>, an exception of unspecified type that is publicly derived from both <code>U</code> and <code>nested_exception</code> and constructed from <code>std::forward&lt;T&gt;(t)</code>, otherwise <code>std::forward&lt;T&gt;(t)</code>.</p>\n<p id=\"so_25324262_25324380_4\">\u00a718.8.6 [except.nested]</p>\n</blockquote>\n", "OwnerUserId": "1007504", "PostTypeId": "2", "Id": "25324380", "Score": "7", "CreationDate": "2014-08-15T09:44:35.617", "LastActivityDate": "2014-08-15T09:44:35.617"}, "bq_ids": {"n4140": {"so_25324262_25324380_0": {"section_id": 6949, "quality": 0.8, "length": 4}, "so_25324262_25324380_3": {"section_id": 6952, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_25324262_25324380_0": {"section_id": 6697, "quality": 1.0, "length": 5}, "so_25324262_25324380_3": {"section_id": 6699, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_25324262_25324380_0": {"section_id": 8446, "quality": 0.8, "length": 4}, "so_25324262_25324380_3": {"section_id": 8449, "quality": 0.6470588235294118, "length": 11}}}, "25324262": {"CommentCount": "1", "ViewCount": "445", "PostTypeId": "1", "LastEditorUserId": "3919155", "CreationDate": "2014-08-15T09:38:01.330", "LastActivityDate": "2016-04-28T21:39:33.797", "Title": "std::throw_with_nested expects polymorphic type in C++11?", "AcceptedAnswerId": "25324595", "LastEditDate": "2016-04-28T21:39:33.797", "Id": "25324262", "Score": "11", "Body": "<p>Why does this not compile (tried with Clang 3.4.2 and GCC versions 4.7.4, 4.8.3 and 4.9.1):</p>\n<pre><code>#include &lt;exception&gt;\n\nstruct E { E(int) {} };\n\nint main() {\n  std::throw_with_nested(E(42));\n  return 0;\n}\n</code></pre>\n<p>Errors from GCC 4.9.1:</p>\n<pre><code>In file included from /usr/lib/gcc/x86_64-pc-linux-gnu/4.9.1/include/g++-v4/exception:163:0,\n                from test.cpp:1:\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.1/include/g++-v4/bits/nested_exception.h: In instantiation of 'static const std::nested_exception* std::__get_nested_helper&lt;_Ex&gt;::_S_get(const _Ex&amp;) [with _Ex = E]':\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.1/include/g++-v4/bits/nested_exception.h:104:51:   required from 'const std::nested_exception* std::__get_nested_exception(const _Ex&amp;) [with _Ex = E]'\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.1/include/g++-v4/bits/nested_exception.h:138:38:   required from 'void std::throw_with_nested(_Ex) [with _Ex = E]'\ntest.cpp:6:31:   required from here\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.1/include/g++-v4/bits/nested_exception.h:90:59: error: cannot dynamic_cast '&amp; __ex' (of type 'const struct E*') to type 'const class std::nested_exception*' (source type is not polymorphic)\n      { return dynamic_cast&lt;const nested_exception*&gt;(&amp;__ex); }\n                                                          ^\n</code></pre>\n<p>Errors from Clang 3.4.2:</p>\n<pre><code>In file included from test.cpp:1:\nIn file included from /usr/lib/gcc/x86_64-pc-linux-gnu/4.9.1/include/g++-v4/exception:163:\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.1/include/g++-v4/bits/nested_exception.h:90:16: error: 'E' is not polymorphic\n      { return dynamic_cast&lt;const nested_exception*&gt;(&amp;__ex); }\n              ^                                     ~~~~~\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.1/include/g++-v4/bits/nested_exception.h:104:40: note: in instantiation of member function 'std::__get_nested_helper&lt;E&gt;::_S_get' requested here\n    { return __get_nested_helper&lt;_Ex&gt;::_S_get(__ex); }\n                                      ^\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.1/include/g++-v4/bits/nested_exception.h:138:11: note: in instantiation of function template specialization 'std::__get_nested_exception&lt;E&gt;' requested here\n      if (__get_nested_exception(__ex))\n          ^\ntest.cpp:6:8: note: in instantiation of function template specialization 'std::throw_with_nested&lt;E&gt;' requested here\n  std::throw_with_nested(E(42));\n      ^\n</code></pre>\n<p>Does <code>std::throw_with_nested</code> in C++11 expect an argument with polymorphic type or is this a bug in the compiler or libstdc++?</p>\n", "Tags": "<c++><exception><c++11><exception-handling><libstdc++>", "OwnerUserId": "3919155", "AnswerCount": "3"}});