post_cb({"16356817": {"Id": "16356817", "PostTypeId": "2", "Body": "<p>Arne's answer already points out that the Standard requires trivially copyable types for <code>std::atomic</code>.</p>\n<p>Here's some rationale why atomics might not be the right tool for your problem in the first place: Atomics are the fundamental building primitives for building thread-safe data structures in C++. They are supposed to be the lowest-level building blocks for constructing more powerful data structures like thread-safe containers.</p>\n<p>In particular, atomics are usually used for building <em>lock-free data structures</em>. For locking data structures primitives like <code>std::mutex</code> and <code>std::condition_variable</code> are a way better match, if only for the fact that it is very hard to write blocking code with atomics without introducing lots of busy waiting.</p>\n<p>So when you think of <code>std::atomic</code> the first association should be <em>lock-free</em> (despite the fact that most of the atomic types are technically allowed to have blocking implementations). What you describe is a simple lock-based concurrent data structure, so wrapping it in an atomic should already feel wrong from a conceptual point of view.</p>\n<p>Unfortunately, it is currently not clear how to express in the language that a data structure is thread-safe (which I guess was your primary intent for using atomic in the first place). Herb Sutter had <a href=\"http://herbsutter.com/2013/01/01/video-you-dont-know-const-and-mutable/\" rel=\"nofollow noreferrer\">some interesting ideas</a> on this issue, but I guess for now we simply have to accept the fact that we have to rely on documentation to communicate how certain data structures behave with regards to thread-safety.</p>\n", "LastEditorUserId": "321013", "LastActivityDate": "2016-12-23T22:28:00.227", "Score": "3", "CreationDate": "2013-05-03T10:30:44.440", "ParentId": "16355425", "CommentCount": "0", "OwnerUserId": "577603", "LastEditDate": "2016-12-23T22:28:00.227"}, "bq_ids": {"n4140": {"so_16355425_16355863_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 1165}}, "n3337": {"so_16355425_16355863_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 1163}}, "n4659": {"so_16355425_16355863_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 1260}}}, "16355425": {"ViewCount": "703", "Body": "<p>Reading the docs on <a href=\"http://www.boost.org/doc/libs/1_53_0/doc/html/atomic/limitations.html\" rel=\"nofollow\"><code>boost::atomic</code></a> and on <a href=\"http://en.cppreference.com/w/cpp/atomic/atomic\" rel=\"nofollow\"><code>std::atomic</code></a> leaves me confused as to whether the <code>atomic</code> interface is supposed to support non-trivial types?</p>\n<p>That is, given a (value-)type that can only be written/read by enclosing the read/write in a full mutex, because it has a non-trivial copy-ctor/assignment operator, is this supposed to be supported by <code>std::atomic</code> (as boost clearly states that it is UB).</p>\n<p>Am I supposed to provide the specialization the <a href=\"http://en.cppreference.com/w/cpp/atomic/atomic\" rel=\"nofollow\">docs</a> talk about myself for non-trivial types?</p>\n<hr>\n<p>Note: I was hitting on this because I have a cross-thread callback object <code>boost::function&lt;bool (void)&gt; simpleFn;</code> that needs to be set/reset atomically. Having a separate mutex / critical section or even wrapping both in a atomic-like helper type with simple set and get seem easy enough, but is there anything out of the box?</p>\n</hr>", "AcceptedAnswerId": "16356817", "Title": "C++ atomic with non-trivial type?", "CreationDate": "2013-05-03T09:16:47.903", "Id": "16355425", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-12-23T22:28:00.227", "Score": "5", "OwnerUserId": "321013", "Tags": "<c++><mutex><atomic>", "AnswerCount": "2"}, "16355863": {"Id": "16355863", "PostTypeId": "2", "Body": "<p>The standard specifies (\u00a729.5,1) that </p>\n<blockquote>\n<p id=\"so_16355425_16355863_0\">The type of the template argument T shall be trivially copyable</p>\n</blockquote>\n<p>Meaning no, you cannot use types with non-trivial copy-ctor or assignment-op.</p>\n<p>However, like with any template in namespace std, you are free to specialize the template for any type that it has not been specialized for by the implementation. So <em>if</em> you really want to use <code>std::atomic&lt;MyNonTriviallyCopyableType&gt;</code>, you have to provide the specialization yourself. How that specialization behaves is up to you, meaning, you are free to <a href=\"http://www.stroustrup.com/bs_faq.html#really-say-that\" rel=\"nofollow\">blow off your leg</a> or the leg of anyone using that specialization, because it's just outside the scope of the standard.</p>\n", "LastActivityDate": "2013-05-03T09:37:10.087", "CommentCount": "0", "CreationDate": "2013-05-03T09:37:10.087", "ParentId": "16355425", "Score": "3", "OwnerUserId": "1838266"}});