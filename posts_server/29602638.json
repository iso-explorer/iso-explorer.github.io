post_cb({"bq_ids": {"n4140": {"so_29602638_29611023_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 282}, "so_29602638_29611023_1": {"length": 18, "quality": 1.0, "section_id": 302}}, "n3337": {"so_29602638_29611023_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 273}, "so_29602638_29611023_1": {"length": 18, "quality": 1.0, "section_id": 293}}, "n4659": {"so_29602638_29611023_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 289}, "so_29602638_29611023_1": {"length": 18, "quality": 1.0, "section_id": 309}}}, "29602638": {"ViewCount": "308", "Body": "<p>I was testing some of the tools in the <code>type_traits</code> header over the new C++14 runtime sized arrays, consider the code below:</p>\n<pre><code>int g[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};\n\ntemplate &lt;typename T&gt; void print(T &amp;t)\n{\n    std::cout &lt;&lt; \"Type id:    \" &lt;&lt; typeid(T).name() &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"is_array:   \" &lt;&lt; std::is_array&lt;decltype(T)&gt;::value &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"is_pointer: \" &lt;&lt; std::is_pointer&lt;decltype(T)&gt;::value &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"extent:     \" &lt;&lt; std::extent&lt;decltype(T)&gt;::value &lt;&lt; '\\n';\n}\n\nint main()\n{\n    print(g);\n    return 0;\n}\n</code></pre>\n<p>The static sized array <code>g</code> returns the following output:</p>\n<pre><code>Type id:    A11_i\nis_array:   1\nis_pointer: 0\nextent:     11\n</code></pre>\n<p>The unmangled name <code>A11_i</code> I'm assuming that is <strong>A</strong>rray of <strong>11</strong> elements of type <strong>int</strong> so all is correct here, but with this new code:</p>\n<pre><code>void f(std::size_t s)\n{\n    int a[s];\n    print(a);\n}\n\nint main()\n{\n    f(5);\n    return 0;\n}\n</code></pre>\n<p>I'm getting errors:</p>\n<pre><code>In function 'void f(std::size_t)':\nerror: no matching function for call to 'print(int [s])'\n\nnote: candidate is:\nnote: template&lt;class T&gt; void print(T&amp;)\nnote:   template argument deduction/substitution failed:\nnote:   variable-sized array type 'int [s]' is not a valid template argument\n</code></pre>\n<p>I wasn't expecting that the size argument could be passed to the template but I was expecting an automatic array-to-pointer decay. I guess that the argument <code>T &amp;</code> isn't suited for this kind of decay so I've tried to change the template signature to:</p>\n<pre><code>template &lt;typename T&gt; void print(T *&amp;t)\n</code></pre>\n<p>With similar results:</p>\n<pre><code>In function 'void f(std::size_t)':\nerror: no matching function for call to 'print(int [s])'\n\nnote: candidate is:\nnote: template&lt;class T&gt; void print(T*&amp;)\nnote:   template argument deduction/substitution failed:\nnote:   mismatched types 'T*' and 'int [s]'\n</code></pre>\n<p>And I've noticed that the size variable on the runtime sized array seems to be tied to the type (instead of <code>mismatched types 'T*' and 'int [</code><strong><code>5</code></strong><code>]'</code> we're getting <code>mismatched types 'T*' and 'int [</code><strong><code>s</code></strong><code>]'</code>) this looks pretty weird.</p>\n<p>So, what's the question?</p>\n<ul>\n<li>Why I'm not getting an array-to-pointer decay in this runtime sized array?</li>\n<li>Is the <em>variable</em> used to size the runtime sized array part of the type of the runtime sized array or I'm misunderstanding the error?</li>\n</ul>\n", "AcceptedAnswerId": "29611023", "Title": "Runtime sized arrays and pointer-decay", "CreationDate": "2015-04-13T10:01:27.377", "Id": "29602638", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-04-13T10:17:00.900", "LastEditorUserId": "499359", "LastActivityDate": "2015-04-13T17:05:03.710", "Score": "7", "OwnerUserId": "499359", "Tags": "<c++><arrays><c++14><variable-length-array>", "AnswerCount": "1"}, "29611023": {"Id": "29611023", "PostTypeId": "2", "Body": "<p>During template argument deduction, the array-to-pointer conversion is only used if the function template parameter's type is not a reference.</p>\n<blockquote>\n<p id=\"so_29602638_29611023_0\"><strong>\u00a714.8.2.1 Deducing template arguments from a function call\n  [temp.deduct.call]</strong></p>\n<p id=\"so_29602638_29611023_1\">1 Template argument deduction is done by comparing each function\n  template parameter type (call it <code>P</code>) with the type of the\n  corresponding argument of the call (call it <code>A</code>) as described below.\n  [...]</p>\n<p id=\"so_29602638_29611023_2\">2 If <code>P</code> is not a reference type:</p>\n<ul>\n<li>If <code>A</code> is an array type, the pointer type produced by the array-to-pointer standard conversion (4.2) is used in place of <code>A</code> for\n  type deduction; otherwise,</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2015-04-13T17:05:03.710", "CommentCount": "0", "CreationDate": "2015-04-13T17:05:03.710", "ParentId": "29602638", "Score": "3", "OwnerUserId": "2756719"}});