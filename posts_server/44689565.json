post_cb({"44689617": {"Id": "44689617", "PostTypeId": "2", "Body": "<p>At best one construction and one move construction.</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing std::cout;\nusing std::endl;\n\nclass Something {\npublic:\n    Something() {\n        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;\n    }\n    Something(Something&amp;&amp;) {\n        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;\n    }\n    Something(const Something&amp;) {\n        cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;\n    }\n};\n\nSomething foo(Something in) {\n    return in;\n}\n\nint main() {\n\n    Something something = foo(Something{});\n    (void) something;\n}\n</code></pre>\n<p>The output for the above is this</p>\n<pre><code>Something::Something()\nSomething::Something(Something &amp;&amp;)\n</code></pre>\n<p>The construction of the <code>Something</code> object results in a prvalue, which is a candidate for RVO, this will be elided into the function parameter for <code>foo()</code>.  If you compile with C++17 this will be elided no matter what, but when you compile with C++11 and C++14 this will be elided only if elisions are not disallowed with the <code>-fno-elide-constructors</code> compilation flag.</p>\n<p>However when you return that object from the function, NRVO isn't allowed to happen by the standard.  Eliding from function parameters is explicitly disallowed (see below for the exact quote from the standard).  So a move happens (assuming you have a move constructor, if you don't have a move constructor then a copy will take place)</p>\n<p>So in total with elisions allowed you have one construction and one move construction (if no move constructor is defined then you get a copy)</p>\n<hr>\n<p><strong>\u00a7 15.8.3 Copy/move elision [class.copy.elision]</strong></p>\n<blockquote>\n<ol>\n<li><p id=\"so_44689565_44689617_0\">When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, ...</p>\n<ul>\n<li>in a <code>return</code> statement in a function with a class return type, when the <em>expression</em> is the name of a non-volatile automatic object (other than a function parameter or a variable introduced by the <em>exception-declaration</em> of a <em>handler</em> (18.3)) with the same type (ignoring cv-qualification) as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function call\u2019s return object</li>\n</ul></li>\n</ol>\n</blockquote>\n<p>As you can see the language disallows elision from function parameters, so a move happens.  </p>\n<p>Also note that if you delete the move constructor explicitly, this code will not compile</p>\n</hr>", "LastEditorUserId": "5501675", "LastActivityDate": "2017-06-22T03:42:08.963", "Score": "3", "CreationDate": "2017-06-22T03:25:32.933", "ParentId": "44689565", "CommentCount": "0", "OwnerUserId": "5501675", "LastEditDate": "2017-06-22T03:42:08.963"}, "bq_ids": {"n4140": {"so_44689565_44689617_0": {"length": 11, "quality": 1.0, "section_id": 480}}, "n3337": {"so_44689565_44689617_0": {"length": 11, "quality": 1.0, "section_id": 471}}, "n4659": {"so_44689565_44689617_0": {"length": 11, "quality": 1.0, "section_id": 502}}}, "44689565": {"ViewCount": "36", "Body": "<p>Lets say I have a class <code>node</code> with copy, move constructor, default constructor</p>\n<pre><code>Node func (Node n){\n  return n;\n}\n\nNode newN = func(Node{});            //#2\n</code></pre>\n<p>Then how many times are these called?</p>\n<p><strong>Move constuctor:</strong> once at #2.</p>\n<p>What about copy constructor?</p>\n", "Title": "How many times is the copy constructor invoked?", "CreationDate": "2017-06-22T03:18:46.357", "LastActivityDate": "2017-06-22T03:42:08.963", "CommentCount": "5", "LastEditDate": "2017-06-22T03:22:43.800", "PostTypeId": "1", "LastEditorUserId": "5501675", "Id": "44689565", "Score": "0", "OwnerUserId": "8191438", "Tags": "<c++><oop>", "AnswerCount": "1"}});