post_cb({"24432603": {"CommentCount": "0", "AcceptedAnswerId": "24432847", "PostTypeId": "1", "LastEditorUserId": "1337961", "CreationDate": "2014-06-26T14:01:01.867", "LastActivityDate": "2014-06-26T14:35:48.850", "LastEditDate": "2014-06-26T14:07:28.947", "ViewCount": "134", "FavoriteCount": "1", "Title": "Should ownership be ended before or after stl containers call its value's destructor?", "Id": "24432603", "Score": "5", "Body": "<p>In the following code, an X is registered in a global container that becomes a shared owner of it. The destructor of X tests that it is no longer part of such ownership anymore, which I would expect to be a valid precondition for getting destroyed.  </p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;memory&gt;\n\nstruct X {\n    ~X();\n};\n\nstd::vector&lt;std::shared_ptr&lt;X&gt; &gt; global_x_reg;\n\nX::~X()\n{\n    for (auto iter = global_x_reg.begin(), end = global_x_reg.end(); iter != end; ++iter)\n        if (iter-&gt;get() == this)\n            throw \"Oops. X gets destroyed while it is still owned!\";\n}\n\nint main(int argc, char** argv)\n{\n    global_x_reg.push_back( std::shared_ptr&lt;X&gt;(new X) );\n    global_x_reg.clear(); // calls X::~X().\n}\n</code></pre>\n<p>When it runs (after compilation with VS2010), \"Oops...\" is thrown when the container is cleared.  </p>\n<p>Questions:</p>\n<ol>\n<li>is this code legal? If not, why not? If so, should it throw?  </li>\n<li>should an std container implement <code>clear()</code> in such a way that during the destruction of its values, these values are no longer visible as containees.  </li>\n<li>should <code>std::shared_ptr::get</code>, when <code>std::shared_ptr</code> is destroying its pointee, return <code>nullptr</code>?</li>\n</ol>\n", "Tags": "<c++><c++11><st>", "OwnerUserId": "2440280", "AnswerCount": "3"}, "24432723": {"ParentId": "24432603", "LastEditDate": "2014-06-26T14:12:13.437", "CommentCount": "2", "CreationDate": "2014-06-26T14:06:35.033", "OwnerUserId": "560648", "LastEditorUserId": "560648", "PostTypeId": "2", "Id": "24432723", "Score": "2", "Body": "<p>I don't think there's any particular reason that <code>.get()</code> <em>must</em> return <code>NULL</code> before the deleter (and, consequently, <code>~X()</code>) is invoked by <code>std::shared_ptr&lt;X&gt;::~shared_ptr&lt;X&gt;</code>. The only requirement is that it returns <code>NULL</code> once <code>std:shared_ptr&lt;X&gt;::~shared_ptr&lt;X&gt;</code> has completed.</p>\n<p>Similarly, if <code>std::vector</code> is using placement new to construct and destroy its elements (and it will be), there's no reason that it <em>must</em> have updated its accessors before destroying a placed element.</p>\n<p>In fact, if you think about this common old-fashioned pattern:</p>\n<pre><code>T* ptr = new T();\ndelete ptr;\nptr = NULL;\n</code></pre>\n<p>It's clear that <code>~T()</code> will be invoked before <code>ptr</code> is set to <code>NULL</code>; this is pretty much the same thing that you're seeing.</p>\n<p>The following extract from libstdc++ v4.6.3 supports the analogy:</p>\n<pre><code>00353       virtual void\n00354       _M_destroy() // nothrow\n00355       {\n00356     _My_alloc_type __a(_M_del);\n00357     this-&gt;~_Sp_counted_deleter();\n00358     __a.deallocate(this, 1);\n00359       }\n</code></pre>\n<p>(<a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.6.3/libstdc++/api/a01031_source.html#l00354\" rel=\"nofollow\">link</a>)</p>\n<p>In short, you're observing a totally harmless implementation detail and trying to assert that it breaks stated semantics, when I don't think that it does.</p>\n", "LastActivityDate": "2014-06-26T14:12:13.437"}, "24432847": {"ParentId": "24432603", "LastEditDate": "2014-06-26T14:35:48.850", "CommentCount": "3", "CreationDate": "2014-06-26T14:12:31.973", "OwnerUserId": "923854", "LastEditorUserId": "923854", "PostTypeId": "2", "Id": "24432847", "Score": "4", "Body": "<p>Per N3936 [basic.life]/1: \"The lifetime of an object with non-trivial initialization ends when the destructor call starts.\", and /3:</p>\n<blockquote>\n<p id=\"so_24432603_24432847_0\">The properties ascribed to objects throughout this International Standard apply for a given object only during its lifetime. [ <em>Note:</em> In particular, before the lifetime of an object starts and after its lifetime ends there are significant restrictions on the use of the object, as described below, in 12.6.2 and in 12.7. Also, the behavior of an object under construction and destruction might not be the same as the behavior of an object whose lifetime has started and not ended. 12.6.2 and 12.7 describe the behavior of objects during the construction and destruction phases. \u2014<em>end note</em> ]</p>\n</blockquote>\n<p>You are invoking a member function on a <code>shared_ptr</code> after the end of its lifetime. Since there's no way to know if a given standard library class member function complies with the restrictions specified, invoking a member function on a standard library object after the end of its lifetime consequently has undefined behavior unless otherwise specified.</p>\n<p>See also <a href=\"http://cplusplus.github.io/LWG/lwg-active.html#2382\" rel=\"nofollow\">Library Working Group issue 2382 \"Unclear order of container update versus object destruction on removing an object\"</a>, which pertains very much to the question. In general, it's not a good idea to re-enter a standard library object (<code>global_x_reg</code>) while it is in the middle of processing a member function call (<code>global_x_reg.clear()</code> in this case). The class invariants obviously must hold before and after a member call, but there is no guarantee that the object is in a valid state <em>during</em> a call.</p>\n", "LastActivityDate": "2014-06-26T14:35:48.850"}, "bq_ids": {"n4140": {"so_24432603_24432847_0": {"section_id": 7191, "quality": 0.8421052631578947, "length": 48}}, "n3337": {"so_24432603_24432847_0": {"section_id": 6935, "quality": 0.8421052631578947, "length": 48}}, "n4659": {"so_24432603_24432847_0": {"section_id": 8700, "quality": 0.8421052631578947, "length": 48}}}, "24432866": {"ParentId": "24432603", "CommentCount": "0", "Body": "<p>I think you're doing a strange thing here. If you want to keep access to your elements you should implement <code>X::~X()</code> in such a way that the destroyed object is unregistered but not clear the std::vector itself. Also, the shared pointer is invalidated (and X is destroyed) inside the call to <code>clear()</code> of the <code>std::vector</code> in question. Therefore the <code>std::vector</code> is in a fragile state and I would in any case not rely on it to much. Consider the example of a linked list: If you remove an item which is destroyed in the progress and the destructor iterates over the list it might be the case that the references to nodes are not in a consistent state. I would avoid this situation.</p>\n", "OwnerUserId": "1255016", "PostTypeId": "2", "Id": "24432866", "Score": "0", "CreationDate": "2014-06-26T14:13:28.303", "LastActivityDate": "2014-06-26T14:13:28.303"}});