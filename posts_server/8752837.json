post_cb({"8752879": {"ParentId": "8752837", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>This is a common question in C++ programming. There are two valid answers to this. There are advantages and disadvantages to both answers and your choice will depend on context. The common answer is to put all the implementation in the header file, but there's another approach will will be suitable in some cases. The choice is yours.</p>\n<p>The code in a template is merely a 'pattern' known to the compiler. The compiler won't compile the constructors <code>cola&lt;float&gt;::cola(...)</code> and <code>cola&lt;string&gt;::cola(...)</code> until it is forced to do so. And we must ensure that this compilation happens for the constructors <em>at least</em> once in the entire compilation process, or we will get the 'undefined reference' error. (This applies to the other methods of <code>cola&lt;T&gt;</code> also.)</p>\n<h3>Understanding the problem</h3>\n<p>The problem is caused by the fact that <code>main.cpp</code> and <code>cola.cpp</code> will be compiled separately first. In <code>main.cpp</code>, the compiler will <em>implicitly</em> instantiate the template classes <code>cola&lt;float&gt;</code> and <code>cola&lt;string&gt;</code> because those particular instantiations are used in <code>main.cpp</code>. The bad news is that the implementations of those member functions are not in <code>main.cpp</code>, nor in any header file included in <code>main.cpp</code>, and therefore the compiler can't include complete versions of those functions in <code>main.o</code>. When compiling <code>cola.cpp</code>, the compiler won't compile those instantiations either, because there are no implicit or explicit instantiations of <code>cola&lt;float&gt;</code> or <code>cola&lt;string&gt;</code>. Remember, when compiling <code>cola.cpp</code>, the compiler has no clue which instantiations will be needed; and we can't expect it to compile for <em>every</em> type in order to ensure this problem never happens! (<code>cola&lt;int&gt;</code>, <code>cola&lt;char&gt;</code>, <code>cola&lt;ostream&gt;</code>, <code>cola&lt; cola&lt;int&gt; &gt;</code> ... and so on ...)</p>\n<p>The two answers are:</p>\n<ul>\n<li>Tell the compiler, at the end of <code>cola.cpp</code>, which particular template classes will be required, forcing it to compile <code>cola&lt;float&gt;</code> and <code>cola&lt;string&gt;</code>.</li>\n<li>Put the implementation of the member functions in a header file that will be included <em>every</em> time any other 'translation unit' (such as <code>main.cpp</code>) uses the template class.</li>\n</ul>\n<h3>Answer 1: Explicitly instantiate the template, and its member definitions</h3>\n<p>At the <em>end</em> of <code>cola.cpp</code>, you should add lines explicitly instantiating all the relevant templates, such as</p>\n<pre><code>template class cola&lt;float&gt;;\ntemplate class cola&lt;string&gt;;\n</code></pre>\n<p>and you add the following two lines at the end of <code>nodo_colaypila.cpp</code>:</p>\n<pre><code>template class nodo_colaypila&lt;float&gt;;\ntemplate class nodo_colaypila&lt;std :: string&gt;;\n</code></pre>\n<p>This will ensure that, when the compiler is compiling <code>cola.cpp</code> that it will explicitly compile all the code for the <code>cola&lt;float&gt;</code> and <code>cola&lt;string&gt;</code> classes. Similarly, <code>nodo_colaypila.cpp</code> contains the implementations of the <code>nodo_colaypila&lt;...&gt;</code> classes.</p>\n<p>In this approach, you should ensure that all the of the implementation is placed into one <code>.cpp</code> file (i.e. one translation unit) and that the explicit instantation is placed after the definition of all the functions (i.e. at the end of the file).</p>\n<h3>Answer 2: Copy the code into the relevant header file</h3>\n<p>The common answer is to move all the code from the implementation files <code>cola.cpp</code> and <code>nodo_colaypila.cpp</code> into <code>cola.h</code> and <code>nodo_colaypila.h</code>. In the long run, this is more flexible as it means you can use extra instantiations (e.g. <code>cola&lt;char&gt;</code>) without any more work. But it could mean the same functions are compiled many times, once in each translation unit. This is not a big problem, as the linker will correctly ignore the duplicate implementations. But it might slow down the compilation a little.</p>\n<h3>Summary</h3>\n<p>The default answer, used by the STL for example and in most of the code that any of us will write, is to put all the implementations in the header files. But in a more private project, you will have more knowledge and control of which particular template classes will be instantiated. In fact, this 'bug' might be seen as a feature, as it stops users of your code from accidentally using instantiations you have not tested for or planned for (\"I know this works for <code>cola&lt;float&gt;</code> and <code>cola&lt;string&gt;</code>, if you want to use something else, tell me first and will can verify it works before enabling it.\").</p>\n<p>Finally, there are three other minor typos in the code in your question:</p>\n<ul>\n<li>You are missing an <code>#endif</code> at the end of nodo_colaypila.h</li>\n<li>in cola.h <code>nodo_colaypila&lt;T&gt;* ult, pri;</code> should be <code>nodo_colaypila&lt;T&gt; *ult, *pri;</code> - both are pointers.</li>\n<li>nodo_colaypila.cpp: The default parameter should be in the header file <code>nodo_colaypila.h</code>, not in this implementation file.</li>\n</ul>\n", "OwnerUserId": "146041", "LastEditorUserId": "146041", "LastEditDate": "2012-01-06T14:00:18.317", "Id": "8752879", "Score": "265", "CreationDate": "2012-01-06T03:04:13.993", "LastActivityDate": "2012-01-06T14:00:18.317"}, "8752870": {"ParentId": "8752837", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>You will have to define the functions inside your header file.<br>\nYou cannot separate definition of template functions in to the source file and declarations in to header file.    </br></p>\n<p>When a template is used in a way that triggers its intstantation, a compiler needs to see that particular templates definition. This is the reason templates are often defined in the header file in which they are declared.  </p>\n<p>Reference:<br>\n<strong>C++03 standard, \u00a7 14.7.2.4:</strong></br></p>\n<blockquote>\n<p id=\"so_8752837_8752870_0\"><strong>The definition</strong> of a non-exported function template, a non-exported member function template, or a non-exported member function or static data member of a class template <strong>shall be present in every translation unit</strong> in which it is explicitly instantiated.</p>\n</blockquote>\n<p><strong>EDIT:</strong><br>\nTo clarify the discussion on the comments:<br>\nTechnically, there are three ways to get around this linking problem:</br></br></p>\n<ul>\n<li>To move the definition to the .h file </li>\n<li>Add explicit instantiations in the <code>.cpp</code> file. </li>\n<li><code>#include</code> the <code>.cpp</code> file defining the template at the <code>.cpp</code> file using the template. </li>\n</ul>\n<p>Each of them have their pros and cons,    </p>\n<p>Moving the defintions to header files may increase the code size(modern day compilers can avoid this) but will increase the compilation time for sure.    </p>\n<p>Using the explicit instantiation approach is moving back on to traditional macro like approach.Another disadvantage is that it is necessary to know which template types are needed by the program. For a simple program this is easy but for complicated program this becomes difficult to determine in advance.         </p>\n<p>While including cpp files is confusing at the same time shares the problems of both above approaches.</p>\n<p>I find first method the easiest to follow and implement and hence advocte using it.</p>\n", "OwnerUserId": "452307", "LastEditorUserId": "452307", "LastEditDate": "2012-01-06T05:39:07.810", "Id": "8752870", "Score": "8", "CreationDate": "2012-01-06T03:02:57.477", "LastActivityDate": "2012-01-06T05:39:07.810"}, "8752837": {"CommentCount": "8", "AcceptedAnswerId": "8752879", "ClosedDate": "2015-05-09T01:15:00.020", "CreationDate": "2012-01-06T02:57:52.780", "LastActivityDate": "2012-01-06T14:00:18.317", "PostTypeId": "1", "ViewCount": "73895", "FavoriteCount": "84", "Title": "\"Undefined reference to\" template class constructor", "Id": "8752837", "Score": "97", "Body": "<p>I have no idea why this is happenning, since I think I have everything properly declared and defined.</p>\n<p>I have the following program, designed with templates. It's a simple implementation of a queue, with the member functions \"add\", \"substract\" and \"print\".</p>\n<p>I have defined the node for the queue in the fine \"nodo_colaypila.h\":</p>\n<pre><code>#ifndef NODO_COLAYPILA_H\n#define NODO_COLAYPILA_H\n\n#include &lt;iostream&gt;\n\ntemplate &lt;class T&gt; class cola;\n\ntemplate &lt;class T&gt; class nodo_colaypila\n{\n        T elem;\n        nodo_colaypila&lt;T&gt;* sig;\n        friend class cola&lt;T&gt;;\n    public:\n        nodo_colaypila(T, nodo_colaypila&lt;T&gt;*);\n\n};\n</code></pre>\n<p>Then the implementation in \"nodo_colaypila.cpp\"</p>\n<pre><code>#include \"nodo_colaypila.h\"\n#include &lt;iostream&gt;\n\ntemplate &lt;class T&gt; nodo_colaypila&lt;T&gt;::nodo_colaypila(T a, nodo_colaypila&lt;T&gt;* siguiente = NULL)\n{\n    elem = a;\n    sig = siguiente;//ctor\n}\n</code></pre>\n<p>Afterwards, the definition and declaration of the queue template class and its functions:</p>\n<p>\"cola.h\":</p>\n<pre><code>#ifndef COLA_H\n#define COLA_H\n\n#include \"nodo_colaypila.h\"\n\ntemplate &lt;class T&gt; class cola\n{\n        nodo_colaypila&lt;T&gt;* ult, pri;\n    public:\n        cola&lt;T&gt;();\n        void anade(T&amp;);\n        T saca();\n        void print() const;\n        virtual ~cola();\n\n};\n\n\n#endif // COLA_H\n</code></pre>\n<p>\"cola.cpp\":</p>\n<pre><code>#include \"cola.h\"\n#include \"nodo_colaypila.h\"\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;class T&gt; cola&lt;T&gt;::cola()\n{\n    pri = NULL;\n    ult = NULL;//ctor\n}\n\ntemplate &lt;class T&gt; void cola&lt;T&gt;::anade(T&amp; valor)\n{\n    nodo_colaypila &lt;T&gt; * nuevo;\n\n    if (ult)\n    {\n        nuevo = new nodo_colaypila&lt;T&gt; (valor);\n        ult-&gt;sig = nuevo;\n        ult = nuevo;\n    }\n    if (!pri)\n    {\n        pri = nuevo;\n    }\n}\n\ntemplate &lt;class T&gt; T cola&lt;T&gt;::saca()\n{\n    nodo_colaypila &lt;T&gt; * aux;\n    T valor;\n\n    aux = pri;\n    if (!aux)\n    {\n        return 0;\n    }\n    pri = aux-&gt;sig;\n    valor = aux-&gt;elem;\n    delete aux;\n    if(!pri)\n    {\n        ult = NULL;\n    }\n    return valor;\n}\n\ntemplate &lt;class T&gt; cola&lt;T&gt;::~cola()\n{\n    while(pri)\n    {\n        saca();\n    }//dtor\n}\n\ntemplate &lt;class T&gt; void cola&lt;T&gt;::print() const\n{\n    nodo_colaypila &lt;T&gt; * aux;\n    aux = pri;\n    while(aux)\n    {\n        cout &lt;&lt; aux-&gt;elem &lt;&lt; endl;\n        aux = aux-&gt;sig;\n    }\n}\n</code></pre>\n<p>Then, I have a program to test these functions as follows:</p>\n<p>\"main.cpp\"</p>\n<pre><code>#include &lt;iostream&gt;\n#include \"cola.h\"\n#include \"nodo_colaypila.h\"\n\nusing namespace std;\n\nint main()\n{\n    float a, b, c;\n    string d, e, f;\n    cola&lt;float&gt; flo;\n    cola&lt;string&gt; str;\n\n    a = 3.14;\n    b = 2.71;\n    c = 6.02;\n    flo.anade(a);\n    flo.anade(b);\n    flo.anade(c);\n    flo.print();\n    cout &lt;&lt; endl;\n\n    d = \"John\";\n    e = \"Mark\";\n    f = \"Matthew\";\n    str.anade(d);\n    str.anade(e);\n    str.anade(f);\n    cout &lt;&lt; endl;\n\n    c = flo.saca();\n    cout &lt;&lt; \"First In First Out Float: \" &lt;&lt; c &lt;&lt; endl;\n    cout &lt;&lt; endl;\n\n    f = str.saca();\n    cout &lt;&lt; \"First In First Out String: \" &lt;&lt; f &lt;&lt; endl;\n    cout &lt;&lt; endl;\n\n    flo.print();\n    cout &lt;&lt; endl;\n    str.print();\n\n    cout &lt;&lt; \"Hello world!\" &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>But when I build, the compiler throws errors in every instance of the template class: </p>\n<p><strong>undefined reference to `cola(float)::cola()'...</strong> (it's actually cola'&lt;'float'&gt;'::cola(), but this doesn't let me use it like that.)</p>\n<p>And so on. Altogether, 17 warnings, counting the ones for the member functions being called in the program.</p>\n<p>Why is this? Those functions and constructors WERE defined. I thought that the compiler could replace the \"T\" in the template with \"float\", \"string\" or whatever; that was the advantage of using templates.</p>\n<p>I read somewhere here that I should put the declaration of each function in the header file for some reason. Is that right? And if so, why?</p>\n<p>Thanks in advance.</p>\n", "Tags": "<c++><templates><compiler-errors><codeblocks>", "OwnerUserId": "1125383", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_8752837_8752870_0": {"section_id": 254, "quality": 0.8260869565217391, "length": 19}}, "n3337": {"so_8752837_8752870_0": {"section_id": 245, "quality": 0.8260869565217391, "length": 19}}, "n4659": {"so_8752837_8752870_0": {"section_id": 261, "quality": 0.8260869565217391, "length": 19}}}, "8752877": {"ParentId": "8752837", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This link explains where you're going wrong:</p>\n<p><a href=\"http://www.parashift.com/c++-faq-lite/templates.html#faq-35.12\" rel=\"nofollow\">[35.12] Why can't I separate the definition of my templates class from its declaration and put it inside a .cpp file?</a></p>\n<p><strong>Place the definition of your constructors, destructors methods and whatnot in your header file, and that will correct the problem.</strong></p>\n<p>This offers another solution:</p>\n<p><a href=\"http://www.parashift.com/c++-faq-lite/templates.html#faq-35.13\" rel=\"nofollow\">How can I avoid linker errors with my template functions?</a></p>\n<p>However this requires you to anticipate how your template will be used and, as a general solution, is counter-intuitive. It does solve the corner case though where you develop a template to be used by some internal mechanism, and you want to police the manner in which it is used.</p>\n", "OwnerUserId": "1021915", "LastEditorUserId": "1021915", "LastEditDate": "2012-01-06T03:11:34.917", "Id": "8752877", "Score": "3", "CreationDate": "2012-01-06T03:04:04.393", "LastActivityDate": "2012-01-06T03:11:34.917"}});