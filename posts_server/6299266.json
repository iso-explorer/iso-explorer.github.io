post_cb({"6299429": {"ParentId": "6299266", "CommentCount": "0", "Body": "<p>Each base class constructor is executed before the derived class constructor, and during the <code>B</code> constructor, the dynamic type of the object is <code>B</code>; it does not become a <code>C</code> until you enter the <code>C</code> constructor. So you cannot do anything that requires a dynamic type of <code>C</code>: you can't cross-cast to any of <code>C</code>s other base classes, and if you called a virtual function, then you would not get any overrides provided by <code>C</code>.</p>\n<p>Under the hood, the dynamic type is (in most implementations at least) determined by a pointer in the object (known as the \"vptr\"), which points to some static data specifying properties of the class, including a table of virtual functions (known as the \"vtable\") and the information needed for <code>dynamic_cast</code> and <code>typeid</code>. Before each constructor, this is updated to point to the information for the class currently under construction.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "6299429", "Score": "3", "CreationDate": "2011-06-09T21:18:59.233", "LastActivityDate": "2011-06-09T21:18:59.233"}, "6299463": {"ParentId": "6299266", "LastEditDate": "2011-06-11T14:52:15.677", "CommentCount": "4", "CreationDate": "2011-06-09T21:21:57.737", "OwnerUserId": "14065", "LastEditorUserId": "14065", "PostTypeId": "2", "Id": "6299463", "Score": "6", "Body": "<p>Basically the standard says it will not work (dynamic_cast) during construction of an object.\n&lt;quote&gt;</p>\n<p>Edit: Added based on  VJo comment below.</p>\n<p>Note: The cast from a 'B' to an 'A' using dynamic cast should work because we are casting an object of type 'C'. If we added the following code to main:</p>\n<pre><code>B  bObj;\nB&amp; bRef = c;\nB* bPtr = &amp;c;\nstd::cout &lt;&lt; !!dynamic_cast&lt;A*&gt;(&amp;bObj) &lt;&lt; std::endl;\nstd::cout &lt;&lt; !!dynamic_cast&lt;A*&gt;(&amp;bRef) &lt;&lt; std::endl;\nstd::cout &lt;&lt; !!dynamic_cast&lt;A*&gt;( bPtr) &lt;&lt; std::endl;\n</code></pre>\n<p>The extra output would be:</p>\n<pre><code>0   // Can not convert a B to an A\n1   // Can convert this B to an A because it is really a C.\n1   // This is  what we are reeling doing in B::B() that fails\n    // It is not the dynamic_cast&lt;&gt; that fails but the conversion of this from C* to B*\n    // That is causing UB\n</code></pre>\n<p>It fails in the constructor because the object is not fully formed. Using this we are trying to convert a C pointer into a B pointer before the C constructor has started (the code defined by the user). Thus the use of <code>this</code> in B::B() as a pointer to a C object fails thus when the dynamic_cast&lt;&gt; is called on this it fails to do what you want it to because of UB.</p>\n<h3>12.7 Construction and destruction    [class.cdtor]</h3>\n<p>Paragraph 3</p>\n<blockquote>\n<p id=\"so_6299266_6299463_0\">To explicitly or implicitly convert a pointer (a glvalue) referring to an object of class X to a pointer (reference) to a direct or indirect base class B of X, the construction of X and the construction of all of its direct or indirect bases that directly or indirectly derive from B shall have started and the destruction of these classes shall not have completed, otherwise the conversion results in undefined behavior. To form a pointer to (or access the value of) a direct non-static member of an object obj, the construction of obj shall have started and its destruction shall not have completed, otherwise the computation of the pointer value (or accessing the member value) results in undefined behavior.</p>\n</blockquote>\n<p>[ Example:</p>\n<pre><code>struct A { };\nstruct B : virtual A { };\nstruct C : B { };\nstruct D : virtual A { D(A*); };\nstruct X { X(A*); };\nstruct E : C, D, X \n{ \n    E() : D(this),  // undefined: upcast from E* to A*\n                    // might use path E* \u2192 D* \u2192 A* \n                    // but D is not constructed \n                    // D((C*)this), \n                    // defined: \n                    // E* \u2192 C* defined because E() has started \n                    // and C* \u2192 A* defined because\n                    // C fully constructed \n      X(this) { // defined: upon construction of X,\n                    // C/B/D/A sublattice is fully constructed\n      } \n};\n</code></pre>\n<p>\u2014 end example ]</p>\n<p>&lt;/quote&gt;</p>\n", "LastActivityDate": "2011-06-11T14:52:15.677"}, "bq_ids": {"n4140": {"so_6299266_6299463_0": {"section_id": 446, "quality": 1.0, "length": 62}}, "n3337": {"so_6299266_6299463_0": {"section_id": 437, "quality": 1.0, "length": 62}}, "n4659": {"so_6299266_6299463_0": {"section_id": 468, "quality": 1.0, "length": 62}}}, "6299304": {"ParentId": "6299266", "LastEditDate": "2011-06-09T21:20:06.490", "CommentCount": "0", "CreationDate": "2011-06-09T21:08:22.607", "OwnerUserId": "251738", "LastEditorUserId": "251738", "PostTypeId": "2", "Id": "6299304", "Score": "1", "Body": "<p>Since <code>B</code> doesn't inherit from <code>A</code> (<code>B</code> is parent-most class), the dynamic type of <code>B</code> during its constructor is <code>B</code>. Only when both the <code>A</code> and <code>B</code> parents are constructed can the child <code>C</code> be constructed, allowing for sideways <code>dynamic_cast</code>ing.</p>\n", "LastActivityDate": "2011-06-09T21:20:06.490"}, "6299319": {"ParentId": "6299266", "CommentCount": "2", "Body": "<p>It doesn't work inside B, because B doesn't inherit from A</p>\n", "OwnerUserId": "476681", "PostTypeId": "2", "Id": "6299319", "Score": "0", "CreationDate": "2011-06-09T21:09:39.347", "LastActivityDate": "2011-06-09T21:09:39.347"}, "6299300": {"ParentId": "6299266", "CommentCount": "0", "Body": "<p>During the construction of <code>A</code> then the dynamic type is <code>A</code> regardless. This is because you would start calling member functions of derived classes and accessing derived member variables before it's been constructed, which would be UB and very bad.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "6299300", "Score": "2", "CreationDate": "2011-06-09T21:08:12.990", "LastActivityDate": "2011-06-09T21:08:12.990"}, "6299266": {"CommentCount": "0", "CreationDate": "2011-06-09T21:04:55.127", "PostTypeId": "1", "AcceptedAnswerId": "6299463", "LastEditorUserId": "-1", "LastActivityDate": "2011-06-11T14:52:15.677", "LastEditDate": "2017-05-23T11:58:47.727", "ViewCount": "3065", "FavoriteCount": "1", "Title": "dynamic_cast of \"this\" inside constructor", "Id": "6299266", "Score": "4", "Body": "<p>This question is very similar to this one <a href=\"https://stackoverflow.com/questions/4641398/why-cant-i-dynamic-cast-sideways-during-multiple-inheritence\">Why can't I dynamic_cast \"sideways\" during multiple inheritence?</a>, except that the cast does work - just not inside in the constructor.</p>\n<p>Header:  </p>\n<pre><code>class A  \n{  \npublic:  \n    virtual                ~A() {}\n    void                    printA();\n};\n\nclass B\n{\npublic:\n                            B();\n    virtual                ~B() {}\n    void                    printB();\n\nprivate:\n    std::string             message_;\n};\n\nclass C : public A, public B\n{\npublic:\n                        C() {}\n    virtual                ~C() {}\n};\n</code></pre>\n<p>Source:</p>\n<pre><code>void A::printA() { cout &lt;&lt; \"A\" &lt;&lt; endl; }\nB::B()\n{\n    A* a = dynamic_cast&lt; A* &gt;( this );\n    if ( a ) {\n        message_ = std::string( \"A and B\" );\n    } else {\n        message_ = std::string( \"B\" );\n    }\n}\nvoid B::printB() { cout &lt;&lt; message_.c_str() &lt;&lt; endl; }\n</code></pre>\n<p>Main:</p>\n<pre><code>int main( int argc, char* argv[] )\n{\n    cout &lt;&lt; \"Printing C...\" &lt;&lt; endl;\n    C c;\n    c.printA();\n    c.printB();\n\n    cout &lt;&lt; \"Checking again...\" &lt;&lt; endl;\n    cout &lt;&lt; !!dynamic_cast&lt; A* &gt;( &amp;c ) &lt;&lt; endl;\n\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>Result:</p>\n<pre><code>Printing C...\nA\nB\nChecking again...\n1\n</code></pre>\n<p>So, the dynamic_cast does work for multiple inheritance (no surprises there!), but why not when called at runtime for the 'this' pointer inside B::B()?  I thought that the object was fully formed once inside the body of the constructor i.e. all the memory was allocated for the component objects, they haven't been initialised yet.  I appreciate that this depends on the superclass constructor order, but in this example A is called before B.</p>\n<p>I am obviously not understanding what exactly is happening under the hood, can someone please enlighten me?</p>\n<p>Thanks,\nCam Bamber.</p>\n", "Tags": "<c++><constructor><this><multiple-inheritance><dynamic-cast>", "OwnerUserId": "498437", "AnswerCount": "5"}});