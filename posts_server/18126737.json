post_cb({"18127189": {"ParentId": "18126737", "CommentCount": "0", "Body": "<p>Consider you have written <code>this-&gt;put()</code> method in the base class, During compilation time the compiler checks for put() function in the same class, as you don't have any such, it will show you compile time error.</p>\n", "OwnerUserId": "2551262", "PostTypeId": "2", "Id": "18127189", "Score": "1", "CreationDate": "2013-08-08T13:23:04.583", "LastActivityDate": "2013-08-08T13:23:04.583"}, "18126836": {"ParentId": "18126737", "CommentCount": "0", "Body": "<p>Class <code>Base</code> doesn't know that you're only going to use it as part of a <code>Derived</code> object; in general, there might be many different derived classes, only one or some of which may have <code>put()</code>. How could <code>Base</code> be compiled then?</p>\n<p>When you have a <code>Base</code> pointer to a <code>Derived</code> object, you can <em>cast</em> it to obtain a pointer to <code>Derived</code>, and call the method that way:</p>\n<pre><code>Base* b = new Derived;\ndynamic_cast&lt;Derived*&gt;(b)-&gt; put();\n</code></pre>\n<p>A class could actually cast <code>this</code> to a derived instance ponter, if needed:</p>\n<pre><code>dynamic_cast&lt;Derived*&gt;(this)-&gt; put();\n</code></pre>\n", "OwnerUserId": "659804", "PostTypeId": "2", "Id": "18126836", "Score": "2", "CreationDate": "2013-08-08T13:05:29.627", "LastActivityDate": "2013-08-08T13:05:29.627"}, "18126929": {"ParentId": "18126737", "CommentCount": "0", "Body": "<p>Me: When the compiler compiles Base::get function, it cannot see Derived::put function.</p>\n<p>You : Isn't the Derived::put in the same file? Why can't the compiler see that?</p>\n<p>Me: What if there is a Derived1::putttttt defined by somebody 4 years later deriving from Base in another file?</p>\n<p>You: mm, maybe I understand.</p>\n", "OwnerUserId": "1183123", "PostTypeId": "2", "Id": "18126929", "Score": "5", "CreationDate": "2013-08-08T13:09:57.750", "LastActivityDate": "2013-08-08T13:09:57.750"}, "18126884": {"ParentId": "18126737", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Let's imagine you were a compiler for a second. Now you see this class:</p>\n<pre><code>class foo\n{\n    void bar() { this-&gt;xyz(); }\n};\n</code></pre>\n<p>What do you do? You complain that you have no idea what <code>xyz</code> is, and that it is certainly not a member function of <code>foo</code>. You don't go looking around for other classes and check whether they might derive from <code>foo</code> and declare this function - it only works the other way around.</p>\n<p>The other way around means that you have to declare signatures of methods that you want your derived classes to implement:</p>\n<pre><code>class foo\n{\n    void bar() { this-&gt;xyz(); }\n    virtual void xyz() = 0;\n};\n</code></pre>\n<p>Suddenly, this is valid, but now you cannot create an instance of <code>foo</code> anymore: every class with purely virtual methods is an abstract class.</p>\n<p>Note however, that this <strong>does</strong> work for templates:</p>\n<pre><code>template &lt;typename T&gt;\nclass foo\n{\n    void bar() { t.xyz(); }\n    T t;\n};\n</code></pre>\n<p>because each template is instantiated at compile time, so you would not look at the above template, but at e.g. <code>foo&lt;xyz_class&gt;</code> which might provide such a function.</p>\n", "OwnerUserId": "1056003", "LastEditorUserId": "1056003", "LastEditDate": "2013-08-08T13:13:24.403", "Id": "18126884", "Score": "6", "CreationDate": "2013-08-08T13:07:37.143", "LastActivityDate": "2013-08-08T13:13:24.403"}, "18126737": {"CommentCount": "2", "AcceptedAnswerId": "18126929", "CreationDate": "2013-08-08T13:00:37.100", "LastActivityDate": "2013-08-08T13:41:18.580", "PostTypeId": "1", "ViewCount": "2050", "FavoriteCount": "0", "Title": "Why `this` can't access the derived class members from base class methods when called for derived class object", "Id": "18126737", "Score": "2", "Body": "<p><code>This</code> pointer has the type of <code>ClassName</code> in non-const member functions.</p>\n<pre><code> class Base\n {\n   public:\n     void get()\n     {\n       //this-&gt;put(); Why can't I call back a derived class method eventhough \n                       **this** is pointing to derived class object.\n     }\n };\n\n class derived: public Base\n {\n   public:\n   void put()\n   {\n    // do somthing.\n   }\n };\n\n int main()\n {\n  derived d;\n  //d.get();\n  d.put();\n  return 0;\n }\n</code></pre>\n<p>If I print the value of <code>this</code> pointer in both the functions it is same, indicating that it is called for a derived class object. And also <code>this</code> pointers type is <code>derived *</code> here. </p>\n<p>Also as I understand If you have a <code>pointer</code> to object when you're calling a method of it then you're just pointing to the <code>offset</code> where the method is present in the whole <code>object layout</code> starting from the <code>address</code> present in that <code>pointer</code> to <code>object</code>. </p>\n<p>But why can't I offset to the <code>derived</code> class method when I have the <code>start</code> address of the <code>(derived)object</code> in <code>base</code> class method.</p>\n<p>I am unbale to get it why I can't do this because of the above understanding. I am missing something which is very basic here.</p>\n", "Tags": "<c++><inheritance>", "OwnerUserId": "1634969", "AnswerCount": "6"}, "18127358": {"ParentId": "18126737", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The code you posted will not compile because the compiler has no Idea what <code>derived</code> class is while compiling the code for <code>class Base</code>. the <code>this</code> pointer is a pointer that is implicitly passed to every non static member function of a class its how that function can access member attributes of the it's instance. In a <code>Base</code> class member function <code>this</code> has type <code>Base *</code>\nIn a <code>const</code> member function it will have the type <code>const Base *</code>.</p>\n<p>Also the <code>this</code> is a non l-value that means you can not assign a value to it.</p>\n<p>The following is from the C++ standard about the this pointer:</p>\n<blockquote>\n<p id=\"so_18126737_18127358_0\">9.3.2 The this pointer</p>\n<p id=\"so_18126737_18127358_1\">In the body of a non-static (9.3) member function, the keyword this is a prvalue expression whose value\n  is the address of the object for which the function is called. The type of this in a member function of\n  a class X is X*. If the member function is declared const, the type of this is const X*, if the member\n  function is declared volatile, the type of this is volatile X*, and if the member function is declared\n  const volatile, the type of this is const volatile X*.</p>\n</blockquote>\n<p>Now as for doing what you want to do in your question the following compiles</p>\n<pre><code>#include &lt;iostream&gt;\nclass Base\n{\n   public:\n     void get();\n};\n\n\nclass derived: public Base\n{\n   public:\n   void put()\n   {\n        std::cout &lt;&lt; \"This is a bad idea\" &lt;&lt; std::endl;\n\n   }\n};\n\n\nvoid Base::get()\n{\n    //compiler knows what dervied class is\n    static_cast&lt;derived *&gt;(this)-&gt;put();  \n}\n\n\n int main()\n {\n    derived d;\n    d.get();\n\n    return 0;\n }\n</code></pre>\n<p>output is : <code>This is a bad idea</code></p>\n<p>I recommend using virtual functions or templates to get the desired behaviour.</p>\n", "OwnerUserId": "1345339", "LastEditorUserId": "1345339", "LastEditDate": "2013-08-08T13:41:18.580", "Id": "18127358", "Score": "1", "CreationDate": "2013-08-08T13:31:30.653", "LastActivityDate": "2013-08-08T13:41:18.580"}, "bq_ids": {"n4140": {"so_18126737_18127358_1": {"section_id": 5895, "quality": 0.9736842105263158, "length": 37}}, "n3337": {"so_18126737_18127358_1": {"section_id": 5666, "quality": 0.9736842105263158, "length": 37}}, "n4659": {"so_18126737_18127358_1": {"section_id": 7378, "quality": 0.9736842105263158, "length": 37}}}, "18126850": {"ParentId": "18126737", "CommentCount": "2", "Body": "<p>You have to declare your method put() as virtual.</p>\n<pre><code>class Base\n{\npublic:\n     virtual void put() = 0;\n     void get()\n     {\n       //this-&gt;put(); Why can't I call back a derived class method eventhough \n                       **this** is pointing to derived class object.\n     }\n};\n\nclass derived: public Base\n{\npublic:\n    void put()\n    {\n    // do somthing.\n    }\n};\n\nint main()\n{\n    derived d;\n    //d.get();\n    d.put();\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "2141982", "PostTypeId": "2", "Id": "18126850", "Score": "5", "CreationDate": "2013-08-08T13:05:55.253", "LastActivityDate": "2013-08-08T13:05:55.253"}});