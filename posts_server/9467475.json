post_cb({"9468563": {"ParentId": "9467475", "CommentCount": "1", "CreationDate": "2012-02-27T16:32:54.290", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "9468563", "Score": "1", "Body": "<p>Presumably it's not allowed because for machines with sign-magnitude representations it would violate the principle of least surprise that signed <code>0</code> maps to unsigned <code>0</code> while a signed <code>-0</code> would map to some other (probably very large) number.</p>\n<p>Given that the <code>memcpy</code> solution exists I assume the standards body decided to not support such an unintuitive mapping, probably because unsigned-&gt;signed-&gt;unsigned isn't as useful a sequence as pointer-&gt;integer-&gt;pointer.</p>\n", "LastActivityDate": "2012-02-27T16:32:54.290"}, "9468939": {"ParentId": "9467475", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2012-02-27T16:58:18.000", "Score": "3", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:01:51.443", "Id": "9468939", "OwnerUserId": "103167", "Body": "<p>We know that you can't cast an arbitrary bit sequence to floating-point, because it might be a trap representation.</p>\n<p>Is there any rule that says there can't be trap representations in the signed integral types?  (Unsigned types can't, because of the way the range is defined, all representations are needed for valid values)</p>\n<p>Signed representations can also include equivalence classes (such as <code>+0 == -0</code>) and may coerce values in such a class to a canonical representation, thus breaking the roundtrip.</p>\n<p>Here's the relevant rules from the Standard (sectin 4.7, <code>[conv.integral]</code>):</p>\n<blockquote>\n<p id=\"so_9467475_9468939_0\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2<sup>n</sup> where n is the number of bits used to represent the unsigned type).  [ Note:  In a two\u2019s complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation).  \u2014 end note ]</p>\n<p id=\"so_9467475_9468939_1\">If the destination type is signed, the value is unchanged if it can be represented in the destination type (and bit-field width); otherwise, the value is implementation-defined.</p>\n</blockquote>\n<p>If you mean using <code>reinterpret_cast</code> on a pointer or reference, rather than the value, you have to deal with <a href=\"https://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule\">the strict-aliasing rule</a>.  And what you find is that <a href=\"https://stackoverflow.com/a/7005988/103167\"><strong>this case is expressly allowed</strong></a>.</p>\n", "LastActivityDate": "2012-02-27T17:10:06.960"}, "9468743": {"ParentId": "9467475", "CommentCount": "2", "CreationDate": "2012-02-27T16:44:58.790", "OwnerUserId": "1200129", "PostTypeId": "2", "Id": "9468743", "Score": "-1", "Body": "<p>Unless I misunderstand the question, just put the signed type into an unsigned type and vice versa to go back again:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    signed char s = -128;\n    unsigned char u = s;\n    signed char back = u;\n\n    std::cout &lt;&lt; (int)u &lt;&lt; std::endl;\n    std::cout &lt;&lt; (int)back &lt;&lt; std::endl;\n\n    return 0;\n}\n\n./a.out \n128\n-128\n</code></pre>\n", "LastActivityDate": "2012-02-27T16:44:58.790"}, "9468027": {"ParentId": "9467475", "CommentCount": "2", "CreationDate": "2012-02-27T15:58:19.690", "OwnerUserId": "35092", "PostTypeId": "2", "Id": "9468027", "Score": "0", "Body": "<p>The issue is basically that an n-bit unsigned may <em>not</em> have a representation in the n-bit signed type.  For example, an 8-bit unsigned has a maximum value of 256, while necessarily an 8-bit signed value can have no value greater than 128 (and note that this is reguardless of hardware implementation: <em>any</em> representation will require a bit for sign.)</p>\n", "LastActivityDate": "2012-02-27T15:58:19.690"}, "9467914": {"ParentId": "9467475", "PostTypeId": "2", "CommentCount": "17", "CreationDate": "2012-02-27T15:50:07.370", "Score": "2", "LastEditorUserId": "365496", "LastEditDate": "2012-02-27T17:54:17.207", "Id": "9467914", "OwnerUserId": "365496", "Body": "<p>As you point out, memcpy is safe:</p>\n<pre><code>uint64_t a = 1ull&lt;&lt;63;\nint64_t b;\nmemcpy(&amp;b,&amp;a,sizeof a);\n</code></pre>\n<p><strike>The value is b is still implementation defined since C++ does not require a two's complement representation,</strike> but converting it back will give you the original value.</p>\n<p>As Bo Persson points out int64_t will be two's complement. Therefore the memcpy should result in a signed value for which the simple integral conversion back to the unsigned type is well defined to be the original unsigned value.</p>\n<pre><code>uint64_t c = b;\nassert( a == c );\n</code></pre>\n<p>Also, you can implement your own 'signed_cast' to make conversions easy (I don't take advantage of the two's complement thing since these aren't limited to the intN_t types):</p>\n<pre><code>template&lt;typename T&gt;\ntypename std::enable_if&lt;std::is_integral&lt;T&gt;::value &amp;&amp; std::is_signed&lt;T&gt;::value,T&gt;::type\nsigned_cast(typename std::make_unsigned&lt;T&gt;::type v) {\n    T s;\n    std::memcpy(&amp;s,&amp;v,sizeof v);\n    return s;\n}\n\ntemplate&lt;typename T&gt;\ntypename std::enable_if&lt;std::is_integral&lt;T&gt;::value &amp;&amp; std::is_unsigned&lt;T&gt;::value,T&gt;::type\nsigned_cast(typename std::make_signed&lt;T&gt;::type v) {\n    T s;\n    std::memcpy(&amp;s,&amp;v,sizeof v);\n    return s;\n}\n</code></pre>\n", "LastActivityDate": "2012-02-27T17:54:17.207"}, "9468528": {"ParentId": "9467475", "CommentCount": "3", "CreationDate": "2012-02-27T16:31:01.317", "OwnerUserId": "135669", "PostTypeId": "2", "Id": "9468528", "Score": "-1", "Body": "<p>Just run</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;stdint.h&gt;\nusing namespace std;\n\nint main()\n{\n    int64_t a = 5;\n    int64_t aa;\n    uint64_t b;\n    double c;\n\n    b = *reinterpret_cast&lt;uint64_t *&gt;(&amp;a);\n    aa = *reinterpret_cast&lt;int64_t *&gt;(&amp;b);\n\n    if (a == aa) {\n        printf(\"as expected, a == aa\\n\");\n    }\n\n    c = *reinterpret_cast&lt;double *&gt;(&amp;a);\n    aa = *reinterpret_cast&lt;int64_t *&gt;(&amp;c);\n\n    if (a == aa) {\n        printf(\"again, as expected, a == aa\\n\");\n    }\n\n    printf(\"what is this I don't even %f.\\n\", c); // this one should give some undefined behavior here\n\n    return 0;\n}\n</code></pre>\n<p>Couldn't fit it in a comment.</p>\n", "LastActivityDate": "2012-02-27T16:31:01.317"}, "9467475": {"CommentCount": "6", "AcceptedAnswerId": "9467914", "PostTypeId": "1", "LastEditorUserId": "229686", "CreationDate": "2012-02-27T15:22:54.853", "LastActivityDate": "2012-02-28T07:15:08.063", "LastEditDate": "2012-02-28T07:15:08.063", "ViewCount": "684", "FavoriteCount": "1", "Title": "No compliant way to convert signed/unsigned of same size", "Id": "9467475", "Score": "7", "Body": "<p>I fear I may be missing something trivial, but it appears there is no actual safe way to convert to/from a signed type if you wish to retain the original unsigned value.</p>\n<p>On reinterpret_cast, 5.2.10 does not list an integer to integer conversion, thus it is not defined (and static_cast defines no additional conversion). On integral conversions 4.7.3 basically says conversion of a large unsigned will be implementation defined (thus not portable).</p>\n<p>This seems limiting since we know, for example, that a <code>uint64_t</code> should, on any hardware, be safely convertible to a <code>int64_t</code> and back without change in value. Plus the rules on standard layout types actually guarantee safe conversion if we were to <code>memcpy</code> between the two types instead of assign. </p>\n<p>Am I correct? Is there a legitimate reason why one cannot <code>reinterpret_cast</code> between integral types sufficient size?</p>\n<hr>\n<p><em>Clarification: Definitely the signed version of the unsigned is not guaranteed a value, but it is only the round-trip that I am considering (unsigned =&gt; signed =&gt; unsigned)</em></p>\n<hr>\n<p><strong>UPDATE</strong>: Looking closely at the answers and cross-checking the standard, I believe the <code>memcpy</code> is not actually guaranteed to work, as nowhere does it state that the two types are layout compatible, and neither are char types. Further update, digging into the C-standard this memcpy should work, as the sizeof the target is large enough and it copies the bytes.</p>\n<hr>\n<p><strong>ANSWER</strong>: There appears to be no technical reason why reinterpret_cast was not allowed to perform this conversion. For these fixed size integer types a <code>memcpy</code> is guaranteed to work, and indeed so long as the intermediate can represent all bit-patterns any intermediate type can be used (float's can be dangerous as there may be trap patterns). In general you can't memcpy between any standard layout types, they must be compatible or char type. Here the ints are special since they have additional guarantees.</p>\n</hr></hr></hr>", "Tags": "<c++><c++11><language-lawyer>", "OwnerUserId": "229686", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_9467475_9468939_1": {"section_id": 32, "quality": 0.9285714285714286, "length": 13}, "so_9467475_9468939_0": {"section_id": 31, "quality": 0.90625, "length": 29}}, "n3337": {"so_9467475_9468939_1": {"section_id": 29, "quality": 0.9285714285714286, "length": 13}, "so_9467475_9468939_0": {"section_id": 28, "quality": 0.90625, "length": 29}}, "n4659": {"so_9467475_9468939_1": {"section_id": 32, "quality": 0.7857142857142857, "length": 11}, "so_9467475_9468939_0": {"section_id": 31, "quality": 0.90625, "length": 29}}}});