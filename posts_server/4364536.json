post_cb({"13505096": {"ParentId": "4364536", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2012-11-22T02:30:07.757", "Score": "8", "LastEditorUserId": "853315", "LastEditDate": "2015-03-10T13:16:38.183", "Id": "13505096", "OwnerUserId": "853315", "Body": "<p>If your intention was to find a way to represent null in an enumeration of singleton objects, then it's a bad idea to (de)reference null (it C++11, nullptr).</p>\n<p>Why not declare static singleton object that represents NULL within the class as follows and add a cast-to-pointer operator that returns nullptr ?</p>\n<p>Edit: Corrected several mistypes and added if-statement in main() to test for the cast-to-pointer operator actually working (which I forgot to.. my bad) - March 10 2015 -</p>\n<pre><code>// Error.h\nclass Error {\npublic:\n  static Error&amp; NOT_FOUND;\n  static Error&amp; UNKNOWN;\n  static Error&amp; NONE; // singleton object that represents null\n\npublic:\n  static vector&lt;shared_ptr&lt;Error&gt;&gt; _instances;\n  static Error&amp; NewInstance(const string&amp; name, bool isNull = false);\n\nprivate:\n  bool _isNull;\n  Error(const string&amp; name, bool isNull = false) : _name(name), _isNull(isNull) {};\n  Error() {};\n  Error(const Error&amp; src) {};\n  Error&amp; operator=(const Error&amp; src) {};\n\npublic:\n  operator Error*() { return _isNull ? nullptr : this; }\n};\n\n// Error.cpp\nvector&lt;shared_ptr&lt;Error&gt;&gt; Error::_instances;\nError&amp; Error::NewInstance(const string&amp; name, bool isNull = false)\n{\n  shared_ptr&lt;Error&gt; pNewInst(new Error(name, isNull)).\n  Error::_instances.push_back(pNewInst);\n  return *pNewInst.get();\n}\n\nError&amp; Error::NOT_FOUND = Error::NewInstance(\"NOT_FOUND\");\n//Error&amp; Error::NOT_FOUND = Error::NewInstance(\"UNKNOWN\"); Edit: fixed\n//Error&amp; Error::NOT_FOUND = Error::NewInstance(\"NONE\", true); Edit: fixed\nError&amp; Error::UNKNOWN = Error::NewInstance(\"UNKNOWN\");\nError&amp; Error::NONE = Error::NewInstance(\"NONE\");\n\n// Main.cpp\n#include \"Error.h\"\n\nError&amp; getError() {\n  return Error::UNKNOWN;\n}\n\n// Edit: To see the overload of \"Error*()\" in Error.h actually working\nError&amp; getErrorNone() {\n  return Error::NONE;\n}\n\nint main(void) {\n  if(getError() != Error::NONE) {\n    return EXIT_FAILURE;\n  }\n\n  // Edit: To see the overload of \"Error*()\" in Error.h actually working\n  if(getErrorNone() != nullptr) {\n    return EXIT_FAILURE;\n  }\n}\n</code></pre>\n", "LastActivityDate": "2015-03-10T13:16:38.183"}, "42520025": {"ParentId": "4364536", "CommentCount": "0", "CreationDate": "2017-02-28T22:36:05.373", "OwnerUserId": "2445184", "PostTypeId": "2", "Id": "42520025", "Score": "2", "Body": "<p>The answer depends on your view point:</p>\n<hr>\n<p>If you judge by the C++ standard, you cannot get a null reference because you get undefined behavior first. After that first incidence of undefined behavior, the standard allows anything to happen. So, if you write <code>*(int*)0</code>, you already have undefined behavior as you are, from a language standard point of view, dereferencing a null pointer. The rest of the program is irrelevant, once this expression is executed, you are out of the game.</p>\n<hr>\n<p>However, in practice, null references can easily be created from null pointers, and you won't notice until you actually try to access the value behind the null reference. Your example may be a bit too simple, as any good optimizing compiler will see the undefined behavior, and simply optimize away anything that depends on it (the null reference won't even be created, it will be optimized away).</p>\n<p>Yet, that optimizing away depends on the compiler to prove the undefined behavior, which may not be possible to do. Consider this simple function inside a file <code>converter.cpp</code>:</p>\n<pre><code>int&amp; toReference(int* pointer) {\n    return *pointer;\n}\n</code></pre>\n<p>When the compiler sees this function, it does not know whether the pointer is a null pointer or not. So it just generates code that turns any pointer into the corresponding reference. (Btw: This is a noop since pointers and references are the exact same beast in assembler.) Now, if you have another file <code>user.cpp</code> with the code</p>\n<pre><code>#include \"converter.h\"\n\nvoid foo() {\n    int&amp; nullRef = toReference(nullptr);\n    cout &lt;&lt; nullRef;    //crash happens here\n}\n</code></pre>\n<p>the compiler does not know that <code>toReference()</code> will dereference the passed pointer, and assume that it returns a valid reference, which will happen to be a null reference in practice. The call succeeds, but when you try to use the reference, the program crashes. Hopefully. The standard allows for anything to happen, including the appearance of ping elephants.</p>\n<p>You may ask why this is relevant, after all, the undefined behavior was already triggered inside <code>toReference()</code>. The answer is debugging: Null references may propagate and proliferate just as null pointers do. If you are not aware that null references can exist, and learn to avoid creating them, you may spend quite some time trying to figure out why your member function seems to crash when it's just trying to read a plain old <code>int</code> member (answer: the instance in the call of the member was a null reference, so <code>this</code> is a null pointer, and your member is computed to be located as address 8).</p>\n<hr>\n<p>So how about checking for null references? You gave the line</p>\n<pre><code>if( &amp; nullReference == 0 ) // null reference\n</code></pre>\n<p>in your question. Well, that won't work: According to the standard, you have undefined behavior if you dereference a null pointer, and you cannot create a null reference without dereferencing a null pointer, so null references exist only inside the realm of undefined behavior. <em>Since your compiler may assume that you are not triggering undefined behavior, it can assume that there is no such thing as a null reference</em> (even though it will readily emit code that generates null references!). As such, it sees the <code>if()</code> condition, concludes that it cannot be true, and just throw away the entire <code>if()</code> statement. With the introduction of link time optimizations, it has become plain impossible to check for null references in a robust way.</p>\n<hr>\n<h3>TL;DR:</h3>\n<p>Null references are somewhat of a ghastly existence:</p>\n<p>Their existence seems impossible (= by the standard),<br>\nbut they exist (= by the generated machine code),<br>\nbut you cannot see them if they exist (= your attempts will be optimized away),<br>\nbut they may kill you unaware anyway (= your program crashes at weird points, or worse).<br>\nYour only hope is that they don't exist (= write your program to not create them).</br></br></br></br></p>\n<p>I do hope that will not come to haunt you!</p>\n</hr></hr></hr></hr>", "LastActivityDate": "2017-02-28T22:36:05.373"}, "4364586": {"ParentId": "4364536", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2010-12-06T08:46:53.770", "Score": "57", "LastEditorUserId": "13005", "LastEditDate": "2010-12-06T09:05:58.487", "Id": "4364586", "OwnerUserId": "13005", "Body": "<p>References are not pointers.</p>\n<p>8.3.2/1:</p>\n<blockquote>\n<p id=\"so_4364536_4364586_0\">A reference shall be initialized to\n  refer to a valid object or function.\n  [Note: in particular, a null reference\n  cannot exist in a well-defined\n  program, because the only way to\n  create such a reference would be to\n  bind it to the \u201cobject\u201d obtained by\n  dereferencing a null pointer, which\n  causes undefined behavior. As\n  described in 9.6, a reference cannot\n  be bound directly to a bit-field. ]</p>\n</blockquote>\n<p>1.9/4:</p>\n<blockquote>\n<p id=\"so_4364536_4364586_1\">Certain other operations are described\n  in this International Standard as\n  undefined (for example, the effect of\n  dereferencing the null pointer)</p>\n</blockquote>\n<p>As Johannes says in a deleted answer, there's some doubt whether \"dereferencing a null pointer\" should be categorically stated to be undefined behavior. But this isn't one of the cases that raise doubts, since a null pointer certainly does not point to a \"valid object or function\", and there is no desire within the standards committee to introduce null references.</p>\n", "LastActivityDate": "2010-12-06T09:05:58.487"}, "27583126": {"ParentId": "4364536", "CommentCount": "0", "CreationDate": "2014-12-20T18:32:09.047", "OwnerUserId": "2995591", "PostTypeId": "2", "Id": "27583126", "Score": "7", "Body": "<p>clang++ 3.5 even warns on it:</p>\n<pre><code>/tmp/a.C:3:7: warning: reference cannot be bound to dereferenced null pointer in well-defined C++ code; comparison may be assumed to\n      always evaluate to false [-Wtautological-undefined-compare]\nif( &amp; nullReference == 0 ) // null reference\n      ^~~~~~~~~~~~~    ~\n1 warning generated.\n</code></pre>\n", "LastActivityDate": "2014-12-20T18:32:09.047"}, "bq_ids": {"n4140": {"so_4364536_4364586_1": {"section_id": 5800, "quality": 0.6666666666666666, "length": 8}, "so_4364536_4364586_0": {"section_id": 3222, "quality": 0.9411764705882353, "length": 32}}, "n3337": {"so_4364536_4364586_1": {"section_id": 5573, "quality": 0.6666666666666666, "length": 8}, "so_4364536_4364586_0": {"section_id": 3096, "quality": 0.9705882352941176, "length": 33}}, "n4659": {"so_4364536_4364586_1": {"section_id": 7259, "quality": 0.6666666666666666, "length": 8}, "so_4364536_4364586_0": {"section_id": 3979, "quality": 0.9411764705882353, "length": 32}}}, "4364536": {"CommentCount": "7", "AcceptedAnswerId": "4364586", "PostTypeId": "1", "LastEditorUserId": "2642204", "CreationDate": "2010-12-06T08:37:30.400", "LastActivityDate": "2017-02-28T22:36:05.373", "LastEditDate": "2017-02-28T21:41:06.167", "ViewCount": "65455", "FavoriteCount": "18", "Title": "Is null reference possible?", "Id": "4364536", "Score": "67", "Body": "<p>Is this piece of code valid (and defined behavior)?</p>\n<pre><code>int &amp;nullReference = *(int*)0;\n</code></pre>\n<p>Both g++ and clang++ compile it without any warning, even when using <code>-Wall</code>, <code>-Wextra</code>, <code>-std=c++98</code>, <code>-pedantic</code>, <code>-Weffc++</code>...</p>\n<p>Of course the reference is not actually null, since it cannot be accessed (it would mean dereferencing a null pointer), but we could check whether it's null or not by checking its address:</p>\n<pre><code>if( &amp; nullReference == 0 ) // null reference\n</code></pre>\n", "Tags": "<c++><reference><null><language-lawyer>", "OwnerUserId": "300805", "AnswerCount": "4"}});