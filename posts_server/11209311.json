post_cb({"11209311": {"CommentCount": "4", "AcceptedAnswerId": "11209425", "PostTypeId": "1", "LastEditorUserId": "842424", "CreationDate": "2012-06-26T14:14:27.473", "LastActivityDate": "2012-06-26T16:12:35.217", "LastEditDate": "2012-06-26T14:32:49.813", "ViewCount": "1040", "FavoriteCount": "2", "Title": "C++: From stringstream to char**", "Id": "11209311", "Score": "0", "Body": "<p>I have a class with <code>parse(int argc, char* argv[])</code> function which I have to use to set a desired state of an object. I'm taking the parameters from the gui using <code>stringstream</code> and then I'm trying to convert them to char** to pass them to the function. Here's what I've got:</p>\n<pre><code>std::stringstream sstream;\n\nsstream &lt;&lt; \"-clip\" &lt;&lt; \" \" &lt;&lt; min_x_entry.get_text()\n        &lt;&lt; \" \" &lt;&lt; max_x_entry.get_text(); // etc.\n\nstd::cout &lt;&lt; sstream.str();    // All looks good here\n\nstd::vector&lt;std::string&gt; args;\nstd::vector&lt;char*&gt; argv;\nstd::string arg;\n\nwhile (sstream &gt;&gt; arg)\n{\n    args.push_back(arg);\n    argv.push_back(const_cast&lt;char*&gt;(args.back().c_str()));\n}\nargv.push_back(0);\n\nint argc = args.size();\n\nfor (int i = 0; i &lt; argc; ++i)\n    std::cout &lt;&lt; &amp;argv[0][i];    // This outputs garbage\n\nmy_object.parse(argc, &amp;argv[0])  // And this fails\n</code></pre>\n<p>What am I missing? Is there a better way of achieving this?</p>\n", "Tags": "<c++><string><stdvector><stringstream>", "OwnerUserId": "842424", "AnswerCount": "4"}, "11210464": {"ParentId": "11209311", "CommentCount": "2", "Body": "<p>You can get rid of <code>const_cast</code> and not worry about <code>parse()</code> method possibly modifying the arguments by doing something like this:</p>\n<pre><code>std::vector&lt;std::vector&lt;char&gt;&gt; args;\n\nstd::for_each(std::istream_iterator&lt;std::string&gt;(sstream),\n              std::istream_iterator&lt;std::string&gt;(),\n              [&amp;args](const std::string&amp; str)\n              {\n                  std::vector&lt;char&gt; temp(str.begin(), str.end());\n                  temp.push_back('\\0');\n                  args.push_back(temp);\n              });\n\nstd::vector&lt;char*&gt; argv(args.size());\n\nfor (auto&amp; v : args) argv.push_back(v.data());\n\nmy_object.parse(argv.size(), argv.data());\n</code></pre>\n", "OwnerUserId": "947836", "PostTypeId": "2", "Id": "11210464", "Score": "0", "CreationDate": "2012-06-26T15:13:40.373", "LastActivityDate": "2012-06-26T15:13:40.373"}, "11209576": {"ParentId": "11209311", "PostTypeId": "2", "CommentCount": "9", "Body": "<pre><code>std::vector&lt;std::string&gt; args;\nstd::vector&lt;char*&gt; argv;\n\n/* ... */\n\n    argv.push_back(const_cast&lt;char*&gt;(args.back().c_str()));\n</code></pre>\n<p>Many problems here.</p>\n<ol>\n<li>The pointer returned by <code>c_str()</code> is not guaranteed to be valid after any subsequent call of a non-<code>const</code> member function of the same <code>string</code>.  The pointer returned from <code>c_str()</code> generally shouldn't be stored and used later, especially if you're not sure if other code will call a non-<code>const</code> member of the <code>string</code>.</li>\n<li>You are <code>const_cast</code>ing the <code>const</code>-nedd away from the pointer returned by <code>c_str()</code>.  The cast itself is legal, if not an anti-pattern.  But if you then later try to <em>modify</em> the data stored at that pointer, that's Undefined Behavior.</li>\n</ol>\n<p>Here is what the Standard has to say about <code>c_str()</code>:</p>\n<h2>21.3.6 basic_string string operations [lib.string.ops]</h2>\n<pre><code>const charT* c_str() const;\n</code></pre>\n<blockquote>\n<p id=\"so_11209311_11209576_0\">1/ Returns: A pointer to the initial element of an array of length\n  size() + 1 whose first size() elements equal the corresponding\n  elements of the string controlled by *this and whose last element is a\n  null character specified by charT().</p>\n<p id=\"so_11209311_11209576_1\">2/ Requires: The program shall not alter any of the values stored in\n  the array. Nor shall the program treat the returned value as a valid\n  pointer value after any subsequent call to a non-const member function\n  of the class basic_string that designates the same object as this.\n  const charT* data() const;</p>\n<p id=\"so_11209311_11209576_2\">3/ Returns: If size() is nonzero, the member returns a pointer to the\n  initial element of an array whose first size() elements equal the\n  corresponding elements of the string controlled by *this. If size() is\n  zero, the member returns a non-null pointer that is copyable and can\n  have zero added to it.</p>\n<p id=\"so_11209311_11209576_3\">4/ Requires: The program shall not alter any of the values stored in\n  the character array. Nor shall the program treat the returned value as\n  a valid pointer value after any subsequent call to a non- const member\n  function of basic_string that designates the same object as this.\n  allocator_type get_allocator() const;</p>\n<p id=\"so_11209311_11209576_4\">5/ Returns: a copy of the Allocator object used to construct the\n  string.</p>\n</blockquote>\n", "OwnerUserId": "241536", "LastEditorUserId": "241536", "LastEditDate": "2012-06-26T15:04:14.083", "Id": "11209576", "Score": "3", "CreationDate": "2012-06-26T14:26:11.833", "LastActivityDate": "2012-06-26T15:04:14.083"}, "11209679": {"ParentId": "11209311", "CommentCount": "1", "Body": "<p>You've forgotten to initialize the variable <code>i</code> in the loop. And You're trying to print out only the first item in the vector <code>argv</code>.</p>\n<pre><code>for (int i = 0; i &lt; argc; ++i)\n    std::cout &lt;&lt; argv[i];\n</code></pre>\n", "OwnerUserId": "1421758", "PostTypeId": "2", "Id": "11209679", "Score": "1", "CreationDate": "2012-06-26T14:31:38.360", "LastActivityDate": "2012-06-26T14:31:38.360"}, "11209425": {"ParentId": "11209311", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>A problem would be reallocation of the <code>args</code> vector as <a href=\"http://en.cppreference.com/w/cpp/container/vector/push_back\" rel=\"nofollow\"><code>push_back()</code></a> will grow the size of the vector if required:</p>\n<blockquote>\n<p id=\"so_11209311_11209425_0\">If new size() is not larger than capacity(), no iterators or references are invalidated. <strong>Otherwise all iterators and references are invalidated.</strong></p>\n</blockquote>\n<p>The <code>argv</code> vector is storing pointers to the internals of elements in <code>args</code>, so these would be invalidated.</p>\n<p>A solution would be to create the <code>args</code> vector first then create the <code>argv</code> vector afterwards:</p>\n<pre><code>while (sstream &gt;&gt; arg) args.push_back(arg);\n\nfor (auto i = args.begin(); i != args.end(); i++)\n{\n    argv.push_back(const_cast&lt;char*&gt;(i-&gt;c_str()));\n}\nargv.push_back(0);\n</code></pre>\n<p>The <code>for</code> loop that prints out the <code>argv</code> strings is incorrect. This:</p>\n<pre><code>&amp;argv[0][i]\n</code></pre>\n<p>is a <code>char*</code> but starts from <code>i</code>th element of the first entry in <code>argv</code>. For example, if the first c-string in <code>argv</code> was <code>\"string\"</code>:</p>\n<pre><code>&amp;argv[0][1] is \"tring\"\n&amp;argv[0][2] is \"ring\"\n</code></pre>\n<p>change to:</p>\n<pre><code>for (int i = 0; i &lt; argc; i++)\n    std::cout &lt;&lt; argv[i] &lt;&lt; std::endl; // Added 'endl' to flush 'cout'.\n</code></pre>\n", "OwnerUserId": "1033896", "LastEditorUserId": "1033896", "LastEditDate": "2012-06-26T16:12:35.217", "Id": "11209425", "Score": "5", "CreationDate": "2012-06-26T14:19:47.837", "LastActivityDate": "2012-06-26T16:12:35.217"}, "bq_ids": {"n4140": {"so_11209311_11209425_0": {"section_id": 986, "quality": 0.5384615384615384, "length": 7}, "so_11209311_11209576_4": {"section_id": 1764, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_11209311_11209425_0": {"section_id": 971, "quality": 0.5384615384615384, "length": 7}, "so_11209311_11209576_4": {"section_id": 1758, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_11209311_11209425_0": {"section_id": 1049, "quality": 0.6153846153846154, "length": 8}, "so_11209311_11209576_4": {"section_id": 1934, "quality": 0.8333333333333334, "length": 5}}}});