post_cb({"bq_ids": {"n4140": {"so_962132_45832805_0": {"section_id": 447, "quality": 0.9594594594594594, "length": 71}}, "n3337": {"so_962132_45832805_0": {"section_id": 438, "quality": 0.9594594594594594, "length": 71}}, "n4659": {"so_962132_45832805_0": {"section_id": 469, "quality": 0.9594594594594594, "length": 71}}}, "962284": {"ParentId": "962132", "CommentCount": "2", "Body": "<p>Do you know the crash error from Windows explorer?! <strong>\"Pure virtual function call ...\"</strong>\n<br>Same problem ... </br></p>\n<pre><code>class AbstractClass \n{\npublic:\n    AbstractClass( ){\n        //if you call pureVitualFunction I will crash...\n    }\n    virtual void pureVitualFunction() = 0;\n};\n</code></pre>\n<p>Because there is no implemetation for the function pureVitualFunction() and the function is called in the constructor the program will crash. </p>\n", "OwnerUserId": "106064", "PostTypeId": "2", "Id": "962284", "Score": "1", "CreationDate": "2009-06-07T16:51:29.630", "LastActivityDate": "2009-06-07T16:51:29.630"}, "16416511": {"ParentId": "962132", "CommentCount": "3", "Body": "<p>The vtables are created by the compiler. \nA class object has a pointer to its vtable.  When it starts life, that vtable pointer points to the vtable \nof the base class.  At the end of the constructor code, the compiler generates code to re-point the vtable pointer\nto the actual vtable for the class.  This ensures that constructor code that calls virtual functions calls the\nbase class implementations of those functions, not the override in the class.</p>\n", "OwnerUserId": "1581088", "PostTypeId": "2", "Id": "16416511", "Score": "1", "CreationDate": "2013-05-07T10:14:14.050", "LastActivityDate": "2013-05-07T10:14:14.050"}, "47214062": {"ParentId": "962132", "CommentCount": "0", "Body": "<p>Firstly,Object is created and then we assign it 's address to pointers.Constructors are called at the time of object creation and used to initializ the value of data members. Pointer to object comes into scenario after object creation. Thats why, C++ do not allows us to make constructors as virtual .\n.another reason is that, There is nothing like pointer to constructor ,  which can point to virtual constructor,because one of the property of virtual function is that it can be used by pointers only. </p>\n<ol start=\"2\">\n<li>Virtual functions are used to assign value dynamically,as constructors are static,so we can not make them virtual. </li>\n</ol>\n", "OwnerUserId": "8916877", "PostTypeId": "2", "Id": "47214062", "Score": "0", "CreationDate": "2017-11-10T00:48:26.270", "LastActivityDate": "2017-11-10T00:48:26.270"}, "962310": {"ParentId": "962132", "CommentCount": "2", "Body": "<p>During the object's constructor call the virtual function pointer table is not completely built. Doing this will usually not give you the behavior you expect. Calling a virtual function in this situation may work but is not guaranteed and should be avoided to be portable and follow the C++ standard. </p>\n", "OwnerUserId": "108298", "PostTypeId": "2", "Id": "962310", "Score": "-4", "CreationDate": "2009-06-07T17:00:14.470", "LastActivityDate": "2009-06-07T17:00:14.470"}, "962298": {"ParentId": "962132", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Calling a polymorphic function from a constructor is a recipe for disaster in most OO languages. Different languages will perform differently when this situation is encountered.</p>\n<p>The basic problem is that in all languages the Base type(s) must be constructed previous to the Derived type. Now, the problem is what does it mean to call a polymorphic method from the constructor. What do you expect it to behave like? There are two approaches: call the method at the Base level (C++ style) or call the polymorphic method on an unconstructed object at the bottom of the hierarchy (Java way).</p>\n<p>In C++ the Base class will build its version of the virtual method table prior to entering its own construction. At this point a call to the virtual method will end up calling the Base version of the method or producing a <em>pure virtual method called</em> in case it has no implementation at that level of the hierarchy. After the Base has been fully constructed, the compiler will start building the Derived class, and it will override the method pointers to point to the implementations in the next level of the hierarchy.</p>\n<pre><code>class Base {\npublic:\n   Base() { f(); }\n   virtual void f() { std::cout &lt;&lt; \"Base\" &lt;&lt; std::endl; } \n};\nclass Derived : public Base\n{\npublic:\n   Derived() : Base() {}\n   virtual void f() { std::cout &lt;&lt; \"Derived\" &lt;&lt; std::endl; }\n};\nint main() {\n   Derived d;\n}\n// outputs: \"Base\" as the vtable still points to Base::f() when Base::Base() is run\n</code></pre>\n<p>In Java, the compiler will build the virtual table equivalent at the very first step of construction, prior to entering the Base constructor or Derived constructor. The implications are different (and to my likings more dangerous). If the base class constructor calls a method that is overriden in the derived class the call will actually be handled at the derived level calling a method on an unconstructed object, yielding unexpected results. All attributes of the derived class that are initialized inside the constructor block are yet uninitialized, including 'final' attributes. Elements that have a default value defined at the class level will have that value.</p>\n<pre><code>public class Base {\n   public Base() { polymorphic(); }\n   public void polymorphic() { \n      System.out.println( \"Base\" );\n   }\n}\npublic class Derived extends Base\n{\n   final int x;\n   public Derived( int value ) {\n      x = value;\n      polymorphic();\n   }\n   public void polymorphic() {\n      System.out.println( \"Derived: \" + x ); \n   }\n   public static void main( String args[] ) {\n      Derived d = new Derived( 5 );\n   }\n}\n// outputs: Derived 0\n//          Derived 5\n// ... so much for final attributes never changing :P\n</code></pre>\n<p>As you see, calling a polymorphic (<em>virtual</em> in C++ terminology) methods is a common source of errors. In C++, at least you have the guarantee that it will never call a method on a yet unconstructed object...</p>\n", "OwnerUserId": "36565", "LastEditorUserId": "36565", "LastEditDate": "2009-06-07T17:02:16.213", "Id": "962298", "Score": "62", "CreationDate": "2009-06-07T16:56:53.117", "LastActivityDate": "2009-06-07T17:02:16.213"}, "962132": {"CommentCount": "2", "CreationDate": "2009-06-07T15:46:28.107", "PostTypeId": "1", "AcceptedAnswerId": "962148", "LastEditorUserId": "2508150", "LastActivityDate": "2017-11-10T00:48:26.270", "LastEditDate": "2015-12-15T11:54:39.293", "ViewCount": "65897", "FavoriteCount": "57", "Title": "Calling virtual functions inside constructors", "Id": "962132", "Score": "158", "Body": "<p>Suppose I have two C++ classes:</p>\n<pre><code>class A\n{\npublic:\n  A() { fn(); }\n\n  virtual void fn() { _n = 1; }\n  int getn() { return _n; }\n\nprotected:\n  int _n;\n};\n\nclass B : public A\n{\npublic:\n  B() : A() {}\n\n  virtual void fn() { _n = 2; }\n};\n</code></pre>\n<p>If I write the following code:</p>\n<pre><code>main()\n{\n  B b;\n  int n = b.getn();\n}\n</code></pre>\n<p>One might expect that <code>n</code> is set to 2.</p>\n<p>It turns out that <code>n</code> is set to 1. Why?</p>\n", "Tags": "<c++><constructor><override><virtual-method>", "OwnerUserId": "118058", "AnswerCount": "11"}, "19628760": {"ParentId": "962132", "CommentCount": "3", "Body": "<p>I am not seeing the importance of the virtual key word here. b is a static-typed variable, and its type is determined by compiler at compile time. The function calls would not reference the vtable. When b is constructed, its parent class's constructor is called, which is why the value of _n is set to 1. </p>\n", "OwnerUserId": "2305329", "PostTypeId": "2", "Id": "19628760", "Score": "-3", "CreationDate": "2013-10-28T06:58:10.737", "LastActivityDate": "2013-10-28T06:58:10.737"}, "962133": {"ParentId": "962132", "CommentCount": "4", "Body": "<p>The reason is that C++ objects are constructed like onions, from the inside out. Super-classes are constructed before derived classes. So, before a B can be made, an A must be made. When A's constructor is called, it's not a B yet, so the virtual function table still has the entry for A's copy of fn().</p>\n", "OwnerUserId": "118058", "PostTypeId": "2", "Id": "962133", "Score": "45", "CreationDate": "2009-06-07T15:46:40.930", "LastActivityDate": "2009-06-07T15:46:40.930"}, "45832805": {"ParentId": "962132", "CommentCount": "0", "Body": "<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">C++ Standard (ISO/IEC 14882-2014)</a> say's:</p>\n<blockquote>\n<p id=\"so_962132_45832805_0\">Member functions, including virtual functions (10.3), can be called\n  during construction or destruction (12.6.2). When a virtual function\n  is called directly or indirectly from a constructor or from a\n  destructor, including during the construction or destruction of the\n  class\u2019s non-static data members, and the object to which the call\n  applies is the object (call it x) under construction or destruction,\n  the function called is the final overrider in the constructor\u2019s or\n  destructor\u2019s class and not one overriding it in a more-derived class.\n  If the virtual function call uses an explicit class member access\n  (5.2.5) and the object expression refers to the complete object of x\n  or one of that object\u2019s base class subobjects but not x or one of its\n  base class subobjects, the behavior is <strong>undefined</strong>.</p>\n</blockquote>\n<p>So, Don't invoke <code>virtual</code> functions from constructors or destructors that attempts to call into the object under construction or destruction, Because the order of construction starts from <strong>base to derived</strong> and the order of destructors starts from <strong>derived to base class</strong>.</p>\n<p>So, attempting to call a derived class function from a base class under construction is dangerous.Similarly, an object is destroyed in reverse order from construction, so attempting to call a function in a more derived class from a destructor may access resources that have already been released.</p>\n", "OwnerUserId": "6935629", "PostTypeId": "2", "Id": "45832805", "Score": "1", "CreationDate": "2017-08-23T07:03:24.333", "LastActivityDate": "2017-08-23T07:03:24.333"}, "962325": {"ParentId": "962132", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>One solution to your problem is using factory methods to create your object.</p>\n<ul>\n<li>Define a common base class for your class hierarchy containing a virtual method afterConstruction():</li>\n</ul>\n<pre>\nclass Object\n{\npublic:\n  virtual void afterConstruction() {}\n  // ...\n};\n</pre>\n<ul>\n<li>Define a factory method:</li>\n</ul>\n<pre>\ntemplate&lt; class C &gt;\nC* factoryNew()\n{\n  C* pObject = new C();\n  pObject-&gt;afterConstruction();\n\n  return pObject;\n}\n</pre>\n<ul>\n<li>Use it like this:</li>\n</ul>\n<pre>\nclass MyClass : public Object \n{\npublic:\n  virtual void afterConstruction()\n  {\n    // do something.\n  }\n  // ...\n};\n\nMyClass* pMyObject = factoryNew();\n\n</pre>\n", "OwnerUserId": "118854", "LastEditorUserId": "143397", "LastEditDate": "2012-08-15T05:21:09.027", "Id": "962325", "Score": "11", "CreationDate": "2009-06-07T17:09:10.293", "LastActivityDate": "2012-08-15T05:21:09.027"}, "962148": {"ParentId": "962132", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>Calling virtual functions from a constructor or destructor is dangerous and should be avoided whenever possible.  All C++ implementations should call the version of the function defined at the level of the hierarchy in the current constructor and no further.  </p>\n<p>The <a href=\"https://isocpp.org/wiki/faq/strange-inheritance#calling-virtuals-from-ctors\" rel=\"noreferrer\">C++ FAQ Lite</a> covers this in section 23.7 in pretty good detail.  I suggest reading that (and the rest of the FAQ) for a followup.</p>\n<p><strong>EDIT</strong> Corrected Most to All (thanks litb)</p>\n", "OwnerUserId": "23283", "LastEditorUserId": "1951907", "LastEditDate": "2015-05-20T18:48:01.003", "Id": "962148", "Score": "152", "CreationDate": "2009-06-07T15:52:28.263", "LastActivityDate": "2015-05-20T18:48:01.003"}, "962171": {"ParentId": "962132", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>The <a href=\"http://www.parashift.com/c++-faq-lite/strange-inheritance.html#faq-23.5\" rel=\"noreferrer\">C++ FAQ Lite</a> Covers this pretty well:</p>\n<blockquote>\n<p id=\"so_962132_962171_0\">Essentially, during the call to the base classes constructor, the object is not yet of the derived type and thus the base type's implementation of the virtual function is called and not the derived type's.</p>\n</blockquote>\n", "OwnerUserId": "2603", "LastEditorUserId": "560648", "LastEditDate": "2016-09-05T20:50:25.247", "Id": "962171", "Score": "19", "CreationDate": "2009-06-07T16:03:12.153", "LastActivityDate": "2016-09-05T20:50:25.247"}});