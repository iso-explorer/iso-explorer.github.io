post_cb({"43013917": {"ParentId": "42989034", "LastEditDate": "2017-05-23T11:46:18.273", "CommentCount": "0", "CreationDate": "2017-03-25T07:52:09.423", "Score": "1", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "43013917", "OwnerUserId": "166389", "Body": "<p>According to the <a href=\"https://github.com/cplusplus/draft/commit/c9505d3aee7a0d0ff148330ad05224f519635cdc\" rel=\"nofollow noreferrer\">commit on github</a>, this was done to resolve <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1261\" rel=\"nofollow noreferrer\">CWG1261: Explicit handling of cv-qualification with non-class prvalues</a></p>\n<p>Based on comments to the question it seems there was room for surprising variations in type category of <code>this</code> (formally a <strong>prvalue</strong>) and that <a href=\"https://gcc.gnu.org/ml/gcc-patches/2013-03/msg01231.html\" rel=\"nofollow noreferrer\">gcc formerly</a> and MSVC currently instead used a <strong>const lvalue</strong>.</p>\n<p>The wording tightens up the hole to be explicit that, e.g., even if <code>this</code> is by some compiler-internal magic a prvalue of type <code>X* const</code>, <em>prior to any further analysis</em> it is adjusted to <code>X*</code>.</p>\n<p>Similarly, your given example does look like a gcc bug. Possibly <code>decltype</code> isn't looking at the value type before applying the c-style cast.</p>\n<p>The reason it's now a note in [basic.lval]/4 is that it's now a consequence of the new text in [expr]/6, rather than specifying the rule in [basic.lval]/4.</p>\n<p>Full credit to <a href=\"https://stackoverflow.com/users/2756719/t-c\">T.C.</a> for having basically answered this in the comments on the question, including the reference to the gcc bug-fix, and various other examples of previously under-specified behaviours for <em>cv-qualified non-class non-array prvalues</em>.</p>\n", "LastActivityDate": "2017-03-25T07:52:09.423"}, "42989034": {"CommentCount": "12", "ViewCount": "157", "PostTypeId": "1", "LastEditorUserId": "187690", "CreationDate": "2017-03-23T23:52:18.913", "LastActivityDate": "2017-03-25T08:15:28.933", "Title": "Cv-qualifications of prvalues in C++14", "FavoriteCount": "3", "LastEditDate": "2017-03-25T08:15:28.933", "Id": "42989034", "Score": "11", "Body": "<p>It appears that C++11 and C++14 treat cv-qualifications of prvalues differently.</p>\n<p>C++11 sticks to the \"classic\" approach that has been around since C++98: according to 3.10/4 <em>\"non-class prvalues always have cv-unqualified types\"</em>.</p>\n<p>C++14 contains a similar wording in 3.10/4, but it is presented as a note: <em>\"[Note: class and array prvalues can have cv-qualified types; other prvalues always have cv-unqualified types. See Clause 5. \u2014end note ]\"</em> </p>\n<p>And in Clause 5 it says:</p>\n<blockquote>\n<p id=\"so_42989034_42989034_0\"><strong>6</strong> If a prvalue initially has the type \u201ccv T,\u201d where T is a cv-unqualified non-class, non-array type, the type of the expression is adjusted to T prior to any further analysis.<sup>1</sup></p>\n</blockquote>\n<p>This 5/6 entry is new in C++14. It now treats cv-qualifications of prvalues using the same approach that has always been used with results of reference type (see 5/5).</p>\n<p>What could be the reason for this change? C++11 and before denied non-class prvalues the right to have any cv-qualifications. C++14 says that non-class, non-array prvalues <em>can</em> have cv-qualifications, but these cv-qualifications are discarded <em>prior to any further analysis</em>.</p>\n<p>My guess would be that there are some new (for C++14) language features that can somehow \"see\" cv-qualifications of prvalues under the right circumstances (before the aforementioned adjustment takes place). Do they exist? And if so, what are these features?<sup>2</sup></p>\n<hr>\n<p>The question originated from following context: imagine a compiler that internally implements hidden parameter <code>this</code> of class <code>X</code> as a variable of type <code>X *const</code>. Since the compiler is required to expose <code>this</code> as a prvalue, that <code>const</code> should not lead to any problems in C++11 (or before), where scalar prvalues are never cv-qualified. But what about C++14? If the very same compiler exposes that <code>this</code> as a prvalue of type <code>X *const</code>, could it possibly lead to problems?</p>\n<hr>\n<p><sup>1</sup> There appears to be a contradiction between 5/6 and the note in 3.10/4 in C++14, but notes are not normative anyway. And I'm using a draft version of the text.</p>\n<p><sup>2</sup> My initial guess was <code>decltype</code>. And I even thought that I found the answer when I tried </p>\n<pre><code>std::cout &lt;&lt; std::is_same&lt;decltype((const int) 0), const int&gt;::value &lt;&lt; std::endl;\n</code></pre>\n<p>in GCC, which outputs <code>1</code>. However, seeing that Clang and VC++ output <code>0</code> (and that the spec of <code>decltype</code> does not seem to support this behavior) I'm inclined to believe that this is just a bug in GCC (starting from 6.1)</p>\n</hr></hr>", "Tags": "<c++><c++11><c++14><language-lawyer>", "OwnerUserId": "187690", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_42989034_42989034_0": {"section_id": 5939, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_42989034_42989034_0": {"section_id": 7423, "quality": 0.9285714285714286, "length": 13}}}});