post_cb({"12983300": {"CommentCount": "4", "ViewCount": "145", "CreationDate": "2012-10-19T22:28:18.380", "LastActivityDate": "2012-10-19T22:48:09.280", "Title": "Non-pointer function type can be a non-type parameter?", "AcceptedAnswerId": "12983410", "PostTypeId": "1", "Id": "12983300", "Score": "4", "Body": "<p>I've been experimenting with function types in C++. Note that I don't mean pointer-to-function types like:</p>\n<pre><code>typedef void (*voidFuncPtr)();\n</code></pre>\n<p>but the more exotic:</p>\n<pre><code>typedef void (voidFunc)();\n</code></pre>\n<p>I didn't expect the following code to compile, but surprisingly it did:</p>\n<pre><code>template&lt;voidFunc func&gt;\nclass funcClass\n{\npublic:\n    void call() { func(); };\n};\n\nvoid func()\n{ }\n\nvoid Test()\n{\n    funcClass&lt;func&gt; foobar;\n    foobar.call();\n}\n</code></pre>\n<p>however, if I try adding the following to funcClass:</p>\n<pre><code>voidFuncPtr get() { return &amp;func; }\n</code></pre>\n<p>I get the error <code>Address expression must be an lvalue or a function designator</code></p>\n<p>My first question here is: what kind of black magic is the compiler using to pretend that a func type is something it can actually pass around an instance of? Is it just treating it like a reference? Second question is: if it can even be called, why can't the address of it be taken? Also, what are these non-pointer-to function types called? I only discovered them because of boost::function, and have never been able to find any documentation about them.</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "395029", "AnswerCount": "2"}, "12983410": {"ParentId": "12983300", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>\u00a714.1.4 of the Standard says:</p>\n<blockquote>\n<p id=\"so_12983300_12983410_0\">A non-type template-parameter shall have one of the following (optionally cv-qualified) types:</p>\n<p id=\"so_12983300_12983410_1\">\u2014 integral or enumeration type,</p>\n<p id=\"so_12983300_12983410_2\">\u2014 pointer to object or <strong>pointer to function</strong>, [<em>this is what yours is</em>]</p>\n<p id=\"so_12983300_12983410_3\">\u2014 lvalue reference to object or lvalue reference to function,</p>\n<p id=\"so_12983300_12983410_4\">\u2014 pointer to member,</p>\n<p id=\"so_12983300_12983410_5\">\u2014 std::nullptr_t.</p>\n</blockquote>\n<p>And \u00a714.1.6 says</p>\n<blockquote>\n<p id=\"so_12983300_12983410_6\">A non-type non-reference template-parameter is a prvalue. It shall not\n  be assigned to or in any other way have its value changed. <strong>A non-type\n  non-reference template-parameter cannot have its address taken</strong>. When a\n  non-type non-reference template-parameter is used as an initializer\n  for a reference, a temporary is always used.</p>\n</blockquote>\n<p>So that explains the two behaviours you are seeing.</p>\n<p>Note that <code>func</code> is the same as <code>&amp;func</code> (\u00a714.3.2.1):</p>\n<blockquote>\n<p id=\"so_12983300_12983410_7\">[A non-type template parameter can be] a constant expression (5.19) that designates the address of an object with static storage duration and external or internal linkage or a\n  function with external or internal linkage, including function\n  templates and function template-ids but excluding non-static class\n  members, expressed (ignoring parentheses) as &amp; id-expression, except\n  that <strong>the &amp; may be omitted if the name refers to a function or array</strong>\n  and shall be omitted if the corresponding template-parameter is a\n  reference; or...</p>\n</blockquote>\n<p>So it's just a function pointer.</p>\n", "OwnerUserId": "726361", "LastEditorUserId": "726361", "LastEditDate": "2012-10-19T22:48:09.280", "Id": "12983410", "Score": "4", "CreationDate": "2012-10-19T22:39:37.907", "LastActivityDate": "2012-10-19T22:48:09.280"}, "12983408": {"ParentId": "12983300", "CommentCount": "0", "Body": "<p>Given that the code compiles without the address-of operator and pointers (including to functions and member functions) are valid template arguments, it seems the compiler considers <code>voidFunc</code> to be a function pointer type, i.e., the decayed version of the type. The rules for this didn't change between C++ 2003 and C++ 2011.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "12983408", "Score": "2", "CreationDate": "2012-10-19T22:39:26.407", "LastActivityDate": "2012-10-19T22:39:26.407"}, "bq_ids": {"n4140": {"so_12983300_12983410_0": {"section_id": 57, "quality": 1.0, "length": 8}, "so_12983300_12983410_7": {"section_id": 87, "quality": 0.9111111111111111, "length": 41}, "so_12983300_12983410_6": {"section_id": 59, "quality": 1.0, "length": 27}, "so_12983300_12983410_3": {"section_id": 57, "quality": 1.0, "length": 6}, "so_12983300_12983410_2": {"section_id": 57, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_12983300_12983410_0": {"section_id": 52, "quality": 1.0, "length": 8}, "so_12983300_12983410_7": {"section_id": 82, "quality": 0.9111111111111111, "length": 41}, "so_12983300_12983410_6": {"section_id": 54, "quality": 1.0, "length": 27}, "so_12983300_12983410_3": {"section_id": 52, "quality": 1.0, "length": 6}, "so_12983300_12983410_2": {"section_id": 52, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_12983300_12983410_0": {"section_id": 59, "quality": 1.0, "length": 8}, "so_12983300_12983410_6": {"section_id": 61, "quality": 1.0, "length": 27}, "so_12983300_12983410_3": {"section_id": 59, "quality": 1.0, "length": 6}, "so_12983300_12983410_2": {"section_id": 59, "quality": 0.6666666666666666, "length": 4}}}});