post_cb({"6472128": {"Id": "6472128", "PostTypeId": "2", "Body": "<p>There's nothing in the proposed C++0x standard.  In fact, <code>export template</code> has been removed (few compilers implemented it anyway).</p>\n<p>As far as inlining is concerned, it's a total non-issue.  The compiler is smart enough not to inline functions which are too big, even if they're marked <code>inline</code> and put into a header file.</p>\n<p>If you're looking at increased compile times from header files grown bloated from templates, use precompiled headers.  These aren't standard, but almost all current compilers provide such a mechanism.</p>\n", "LastActivityDate": "2011-06-24T18:22:19.287", "CommentCount": "2", "CreationDate": "2011-06-24T18:22:19.287", "ParentId": "6472081", "Score": "5", "OwnerUserId": "103167"}, "6472161": {"Id": "6472161", "PostTypeId": "2", "Body": "<p>This feature, called <code>export</code>  is present even in the current standard of C++. Unfortunately, most compilers, including gcc, do not support it. See here <a href=\"http://gcc.gnu.org/bugs/\" rel=\"nofollow\">http://gcc.gnu.org/bugs/</a></p>\n", "LastActivityDate": "2011-06-24T18:25:10.050", "CommentCount": "0", "CreationDate": "2011-06-24T18:25:10.050", "ParentId": "6472081", "Score": "1", "OwnerUserId": "804450"}, "bq_ids": {"n4140": {"so_6472081_6472196_2": {"length": 25, "quality": 0.8928571428571429, "section_id": 53}}, "n3337": {"so_6472081_6472196_2": {"length": 25, "quality": 0.8928571428571429, "section_id": 48}}, "n4659": {"so_6472081_6472196_2": {"length": 25, "quality": 0.8928571428571429, "section_id": 55}}}, "6472196": {"Id": "6472196", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_6472081_6472196_0\">I've manually specified which classes will be used in the source file, but it's really obnoxious:</p>\n</blockquote>\n<pre><code> A&lt;int&gt;; // manually trigger code generation for int and double\n A&lt;double&gt;; \n</code></pre>\n<p>This is not legal (I assume you meant to declare dummy variables here, and missed their name). We will see below why</p>\n<blockquote>\n<p id=\"so_6472081_6472196_1\">Is there anything standard that has been mandated, and/or does g++ support anything like this?</p>\n</blockquote>\n<p>C++03 had something called <code>export</code>, but which turned out to be a misfeature. The EDG implemented that feature, and their experience with it indicated that it's not worth the trouble implementing it. And it doesn't provide a useful feature separate compilation usually gives you: Hiding of the code of templates which you once compiled. <code>export</code> still requires the code of templates, be it in raw form or encoded into a mid-level compiler-specific language. See <a href=\"http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2003/n1426.pdf\" rel=\"nofollow\">Why we can't afford export</a>. A short example is given by EDG worker <a href=\"http://groups.google.com/group/comp.std.c++/msg/f7976e6672db4544\" rel=\"nofollow\">David Vandevoorde here</a>.</p>\n<p>For C++0x and for C++0x sans export, we have</p>\n<blockquote>\n<p id=\"so_6472081_6472196_2\">A function template, member function of a class template, or static data member of a class template shall be de\ufb01ned in every translation unit in which it is implicitly instantiated (14.7.1) unless the corresponding specialization is explicitly instantiated (14.7.2) in some translation unit; no diagnostic is required</p>\n</blockquote>\n<p>As this indicates, the only way you can achieve separate compilation is to <em>explicitly instantiate</em> the template you want to have separately compiled. By defining dummy variables, you merely <em>implicitly instantiate</em> the class template. And you do <em>not</em> instantiate the member functions of the class templates that way - you would need to do dummy calls or take their address. And to all this, you are <em>not</em> guaranteed that an implicitly instantiated function won't be discarded if it's not used in the translation unit it was instantiated by, after optimization, based on the above quote. </p>\n<p>So you explicitly instantiate the class template, which will explicitly also instantiate its member functions the following way:</p>\n<pre><code>template class A&lt;int&gt;;\ntemplate class A&lt;double&gt;;\n</code></pre>\n", "LastEditorUserId": "200291", "LastActivityDate": "2013-05-12T21:30:55.897", "Score": "3", "CreationDate": "2011-06-24T18:28:37.600", "ParentId": "6472081", "CommentCount": "0", "OwnerUserId": "34509", "LastEditDate": "2013-05-12T21:30:55.897"}, "6472117": {"Id": "6472117", "PostTypeId": "2", "Body": "<p>C++0x does have <code>extern template</code>, which allows you to prevent the instantiation of certain templates in a compilation unit. So if you have a template class <code>SomeClass</code>, you can put this in the header:</p>\n<pre><code>extern template SomeClass&lt;int&gt;;\nextern template SomeClass&lt;double&gt;;\n</code></pre>\n<p>This will prevent users from instantiating the template. In the .cpp file for the template, you can force instantiation with this syntax:</p>\n<pre><code>template SomeClass&lt;int&gt;;\ntemplate SomeClass&lt;double&gt;;\n</code></pre>\n", "LastActivityDate": "2011-06-24T18:21:30.727", "CommentCount": "1", "CreationDate": "2011-06-24T18:21:30.727", "ParentId": "6472081", "Score": "3", "OwnerUserId": "734069"}, "6472081": {"ViewCount": "429", "Body": "<p>In current g++, I typically include all my templated functions that take the template parameter as an argument because they have to be compiled for each instance.</p>\n<pre><code>template&lt;typename T&gt;\nclass A {\npublic:\n  void f() { ... }\n};\n</code></pre>\n<p>So in a different source, I would write:</p>\n<pre><code>#include &lt;A.hh&gt;\nA&lt;int&gt; a1;\na1.f();\n\nA&lt;double&gt; a2;\na2.f();\n</code></pre>\n<p>Sometimes, when I've been desperate to not inline big methods, I've manually specified which classes will be used in the source file, but it's really obnoxious:</p>\n<pre><code>template&lt;typename T&gt;\nA::A() { ... }\n\ntemplate&lt;typename T&gt;\nvoid A::f() { ... }\n\nA&lt;int&gt;; // manually trigger code generation for int and double\nA&lt;double&gt;; \n</code></pre>\n<p>Obviously different IDEs and compilers have mechanisms to support this.  Is there anything standard that has been mandated, and/or does g++ support anything like this?</p>\n", "AcceptedAnswerId": "6472128", "Title": "Is there anything in the C++0x standard to support separate compilation of templates?", "CreationDate": "2011-06-24T18:17:36.117", "Id": "6472081", "CommentCount": "0", "LastEditDate": "2011-10-02T10:40:02.400", "PostTypeId": "1", "LastEditorUserId": "34509", "LastActivityDate": "2013-05-12T21:30:55.897", "Score": "3", "OwnerUserId": "233928", "Tags": "<g++><c++11>", "AnswerCount": "4"}});