post_cb({"bq_ids": {"n4140": {"so_21535047_21536600_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 6047}}, "n3337": {"so_21535047_21536600_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 5815}}, "n4659": {"so_21535047_21536600_0": {"length": 32, "quality": 0.9411764705882353, "section_id": 7546}}}, "21535047": {"ViewCount": "209", "Body": "<p>This is a question I have been searching for a while but I have not got a proper answer yet :(</p>\n<ul>\n<li>How does the Harvard Architecture map to C/C++ languages (High Level Languages)?</li>\n<li>How are they related or how does the architecture help HLLs?</li>\n</ul>\n", "Title": "Harvard Architecture maps to HLL", "CreationDate": "2014-02-03T18:38:04.780", "LastActivityDate": "2016-11-19T20:08:46.537", "CommentCount": "0", "LastEditDate": "2016-11-19T20:08:46.537", "PostTypeId": "1", "LastEditorUserId": "3885376", "Id": "21535047", "Score": "0", "OwnerUserId": "3267042", "Tags": "<c++><cpu-architecture><high-level><von-neumann><harvard-architecture>", "AnswerCount": "1"}, "21536600": {"Id": "21536600", "PostTypeId": "2", "Body": "<p>The only way Harvard vs Princeton architecture is really relevant to C++ is in the rule 5.2.10p8 concerning mixing function pointers and object pointers:</p>\n<blockquote>\n<p id=\"so_21535047_21536600_0\">Converting a function pointer to an object pointer type or vice versa is conditionally-supported. The meaning of such a conversion is implementation-defined,  except that if an implementation supports conversions in both  directions,  converting  a  prvalue  of  one  type  to  the  other  type  and  back,  possibly  with  different <em>cv-qualification</em>, shall yield the original pointer value.</p>\n</blockquote>\n<p>That rule allows C++ to be used on machines which have separate address spaces for code and data.</p>\n", "LastActivityDate": "2014-02-03T20:02:15.467", "CommentCount": "0", "CreationDate": "2014-02-03T20:02:15.467", "ParentId": "21535047", "Score": "2", "OwnerUserId": "103167"}});