post_cb({"bq_ids": {"n4140": {"so_35153996_35154862_4": {"length": 10, "quality": 0.7142857142857143, "section_id": 91}, "so_35153996_35154862_2": {"length": 14, "quality": 0.7368421052631579, "section_id": 42}, "so_35153996_35154862_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 39}}, "n3337": {"so_35153996_35154862_4": {"length": 10, "quality": 0.7142857142857143, "section_id": 5162}, "so_35153996_35154862_2": {"length": 14, "quality": 0.7368421052631579, "section_id": 39}, "so_35153996_35154862_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 36}}, "n4659": {"so_35153996_35154862_4": {"length": 10, "quality": 0.7142857142857143, "section_id": 6791}, "so_35153996_35154862_2": {"length": 14, "quality": 0.7368421052631579, "section_id": 42}, "so_35153996_35154862_1": {"length": 13, "quality": 0.8666666666666667, "section_id": 39}}}, "35153996": {"ViewCount": "240", "Body": "<p>Using <code>boost::variant</code> of pointers to AST nodes, which can contain value of special type <code>std::nullptr_t</code>, indicating emptiness, I faced the problem: generic visitors of the form <code>[] (auto /* const */ * p) { /* use p */; }</code> or of the form:</p>\n<pre><code>struct V\n{\n    template&lt; typename T &gt;\n    void operator () (T /* const */ * p)\n    { /* use p */; }\n};\n</code></pre>\n<p>can't deal with value of <code>std::nullptr_t</code> type.</p>\n<p>There is a plenty of workarounds one can imagine, but the question rising: is there good explanation why there no (very likely highly restricted) <code>decltype(*nullptr)</code> type in the language (<code>*nullptr</code> is ill-formed and <code>std::remove_pointer_t&lt; std::nullptr_t &gt;</code> is <code>std::nullptr_t</code> in <em>libc++</em>)? Are there theoretical reasons for this?</p>\n", "AcceptedAnswerId": "35154862", "Title": "matching nullptr by T *", "CreationDate": "2016-02-02T12:49:24.243", "Id": "35153996", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-02-02T18:13:29.903", "LastEditorUserId": "1430927", "LastActivityDate": "2016-02-09T16:06:53.600", "Score": "3", "OwnerUserId": "1430927", "Tags": "<c++><pointers><c++11><metaprogramming><generic-programming>", "AnswerCount": "1"}, "35154862": {"Id": "35154862", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_35153996_35154862_0\">is there good explanation why there no (very likely highly restricted) decltype(*nullptr) type in the language (*nullptr is ill-formed and std::remove_pointer_t&lt; std::nullptr_t &gt; is std::nullptr_t in libc++)? Are there theoretical reasons for this?</p>\n</blockquote>\n<p>I think to answer this question, we must look at <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1601.pdf\" rel=\"nofollow\">N1601</a> proposed by Herb Sutter and Bjarne Stroustrup.</p>\n<p>A couple sections stand out to me, particularly</p>\n<p>4.10 [conv.ptr]</p>\n<blockquote>\n<p id=\"so_35153996_35154862_1\">A null pointer constant or an object of type nullptr_t can be converted to a \n  pointer type; the result is the null pointer value of that type</p>\n</blockquote>\n<p>and 4.11 [conv.mem]:</p>\n<blockquote>\n<p id=\"so_35153996_35154862_2\">A null pointer constant (4.10) or an object of type nullptr_t (4.10) can be converted to a pointer\n  to member type; the result is the null member pointer value of that type</p>\n</blockquote>\n<p>So if the result of passing a <code>nullptr</code> or <code>nullptr_t</code> is a null pointer of the given pointer type, then it makes sense that dereferencing it (e.g., via <code>decltype(*nullptr)</code> would be the same as dereferencing any other kind of null pointer. (in the specific case of <code>delctype(*nullptr)</code> I believe it's akin to dereferencing a null <code>void*</code>). That is, you shouldn't do it.</p>\n<blockquote>\n<p id=\"so_35153996_35154862_3\">std::remove_pointer_t&lt; std::nullptr_t &gt; is std::nullptr_t</p>\n</blockquote>\n<p>The reason this is true is easy enough, but the WHY is harder to get at.</p>\n<h3>The reason:</h3>\n<blockquote>\n<p id=\"so_35153996_35154862_4\"><a href=\"http://en.cppreference.com/w/cpp/types/nullptr_t\" rel=\"nofollow\">std::nullptr_t</a> is the type of the null pointer literal, nullptr. It is a distinct type that is not itself a pointer type or a pointer to member type.</p>\n</blockquote>\n<p>Given that, it makes sense that <code>std::remove_pointer_t</code> would have no effect because <code>nullptr_t</code> is not a pointer type.</p>\n<h3>The why</h3>\n<p>In N1601, Sutter and Stroustrup said</p>\n<blockquote>\n<p id=\"so_35153996_35154862_5\">nullptr_t is not a reserved word. It is a typedef (as its _t typedef indicates) for decltype(nullptr) defined in &lt;cstddef&gt;. We do not expect to see much direct use of nullptr_t in real programs. </p>\n</blockquote>\n<p>Indeed this is what actually seems to have happened. Clang 3.9.0, for example has the following in stddef.h:</p>\n<pre><code>namespace std { typedef decltype(nullptr) nullptr_t; }\nusing ::std::nullptr_t;\n</code></pre>\n<p>(and also they were right about not much <code>nullptr_t</code> appearing in many programs). </p>\n<p>This still doesn't explain <em>WHY</em> it is defined as such. To do that, I think we need to go back in time a little farther to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1488.pdf\" rel=\"nofollow\">N1488</a>, also by Sutter and Stroustrup where they said:</p>\n<blockquote>\n<p id=\"so_35153996_35154862_6\">This use of the value <code>0</code> to mean different things (a pointer constant and an <code>int</code>) in C++ has caused\n  problems since at least 1985 in teaching, learning, and using C++. In particular: </p>\n<ul>\n<li><p id=\"so_35153996_35154862_7\">Distinguishing between null and zero. The null pointer and an integer <code>0</code> cannot be distinguished\n  well for overload resolution. For example, given two overloaded functions <code>f(int)</code> and <code>f(char*)</code>,\n  the call <code>f(0)</code> unambiguously resolves to <code>f(int)</code>. There is no way to write a call to <code>f(char*)</code> with a \n  null pointer value without writing an explicit cast (i.e., <code>f((char*)0)</code>) or using a named variable.\n  Note that this implies that today\u2019s null pointer, <code>0</code>, has no utterable type. </p></li>\n<li><p id=\"so_35153996_35154862_8\">Naming null. Further, programmers have often requested that the null pointer constant have a\n  name (rather than just <code>0</code>). This is one reason why the macro <code>NULL</code> exists, although that macro is\n  insufficient. (If the null pointer constant had a type-safe name, this would also solve the\n  previous problem as it could be distinguished from the integer <code>0</code> for overload resolution and\n  some error detection.) </p></li>\n</ul>\n</blockquote>\n<p>Which I think explains the why pretty well; programmers needed a way to distinguish between pointers and integer values for in overloads, and since <code>NULL</code> is generally defined as <code>0</code>, which is usually interpreted as an integer type, there was no easy way to force overload resolution to select the pointer overload. Now that we have <code>nullptr</code>, we can distinguish between pointer and non-pointer types which avoids this issue altogether.</p>\n", "LastEditorUserId": "1016716", "LastActivityDate": "2016-02-09T16:06:53.600", "Score": "4", "CreationDate": "2016-02-02T13:29:32.117", "ParentId": "35153996", "CommentCount": "0", "OwnerUserId": "27678", "LastEditDate": "2016-02-09T16:06:53.600"}});