post_cb({"13886412": {"ParentId": "13886101", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Within <em>list-initialization</em> (8.5.4p1) of an aggregate (8.5.1), the form of initialization performed on the elements of the aggregate is copy-initialization (8.5.1p2), even if the initialization is <em>direct-list-initialization</em>:</p>\n<blockquote>\n<p id=\"so_13886101_13886412_0\">When an aggregate is initialized by an initializer list, as speci\ufb01ed in 8.5.4, the elements of the initializer list are taken as initializers for the members of the aggregate, in increasing subscript or member order. Each member is copy-initialized from the corresponding <em>initializer-clause</em>.</p>\n</blockquote>\n<p>However, just because the form of initialization performed is copy-initialization doesn't mean that a copy occurs.  As per <a href=\"https://stackoverflow.com/questions/13693871/copy-list-initialization-of-non-copyable-types\">copy-list-initialization of non-copyable types</a>, <em>copy-list-initialization</em> should be identical to <em>direct-list-initialization</em> with the exception that explicit constructors are not allowed.</p>\n", "OwnerUserId": "567292", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:52:41.433", "Id": "13886412", "Score": "4", "CreationDate": "2012-12-14T21:21:46.373", "LastActivityDate": "2012-12-14T21:30:30.800"}, "13886302": {"ParentId": "13886101", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Arrays are aggregates, and aggregate initialization always uses copy initialization. C++11 \u00a78.5.1/1:</p>\n<blockquote>\n<p id=\"so_13886101_13886302_0\"><strong>An <em>aggregate</em> is an array</strong> or a class with no user-provided constructors, no <i>brace-or-equal-initializer</i>s for non-static data members, no private or protected non-static data members, no base classes, and no virtual functions.</p>\n</blockquote>\n<p>\u00a78.5.1/2:</p>\n<blockquote>\n<p id=\"so_13886101_13886302_1\">When an aggregate is initialized by an initializer list, as specified in 8.5.4, the elements of the initializer list are taken as initializers for the members of the aggregate, in increasing subscript or member order. <strong>Each member is copy-initialized from the corresponding <em>initializer-clause</em>.</strong> \u2026</p>\n</blockquote>\n<p>(Emphasis mine.)</p>\n<p>Additionally, the compiler does not implicitly generate a move constructor if a user-declared copy constructor is present (\u00a712.8/9); because you have a user-declared copy constructor that is defined as deleted, <code>A</code> has neither a copy nor a move constructor. Explicitly adding a move constructor works:</p>\n<pre><code>struct A\n{\n   A(int) { }\n   A(A const&amp;) = delete;\n   A&amp; operator = (A const&amp;) = delete;\n   A(A&amp;&amp;) = default;\n   ~A() = default;\n};\n\nstruct B\n{\n   B() : a{{0}, {1}} { }\n   A a[2];\n};\n\nint main()\n{\n   B b;\n}\n</code></pre>\n<p><sub><a href=\"http://liveworkspace.org/code/A3cXH%245\" rel=\"nofollow\">Online demo</a></sub></p>\n<p>This is about as close to what you want as you're going to get.</p>\n", "OwnerUserId": "636019", "LastEditorUserId": "636019", "LastEditDate": "2012-12-14T21:27:43.373", "Id": "13886302", "Score": "2", "CreationDate": "2012-12-14T21:12:06.430", "LastActivityDate": "2012-12-14T21:27:43.373"}, "13886101": {"CommentCount": "1", "ViewCount": "651", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2012-12-14T20:54:32.230", "LastActivityDate": "2012-12-14T21:30:30.800", "Title": "array member initialization of user defined types", "AcceptedAnswerId": "13886302", "LastEditDate": "2012-12-14T21:01:44.880", "Id": "13886101", "Score": "6", "Body": "<p>g++ 4.7 supports array member initialization and I started playing with it.</p>\n<p>The code below does not compile.</p>\n<pre><code>struct A\n{\n   A(int){};\n   A(const A&amp;) = delete;\n   A&amp; operator=(const A&amp;) = delete;\n   ~A(){};\n};\n\nstruct B\n{\n   B():\n      a{{0},{1}}\n   {};\n   A a[2];\n};\n\nB b;\n</code></pre>\n<p>The error message with gcc 4.8 (prerelease) is:</p>\n<pre><code>n.cc: In constructor \u2018B::B()\u2019:\nn.cc:12:20: error: use of deleted function \u2018A::A(const A&amp;)\u2019\n           a{{0},{1}}\n             ^\nn.cc:4:8: error: declared here\n        A(const A&amp;) = delete;\n        ^\n</code></pre>\n<p>Is there a way to make this code work? I can't easily change the contructors,destructor of A.\nI seem to need a move-constructor or copy-constructor to initialize the array, but this seems counter-intuitive, since all I really want is in-place construction.</p>\n<p>It works if I split a[2] in 2 members a0 and a1, and construct them separately. This looks fishy however.</p>\n", "Tags": "<c++><constructor><c++11>", "OwnerUserId": "291417", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_13886101_13886412_0": {"section_id": 3299, "quality": 0.9130434782608695, "length": 21}, "so_13886101_13886302_0": {"section_id": 3298, "quality": 0.7222222222222222, "length": 13}, "so_13886101_13886302_1": {"section_id": 3299, "quality": 0.9565217391304348, "length": 22}}, "n3337": {"so_13886101_13886412_0": {"section_id": 3169, "quality": 0.9130434782608695, "length": 21}, "so_13886101_13886302_0": {"section_id": 3168, "quality": 0.9444444444444444, "length": 17}, "so_13886101_13886302_1": {"section_id": 3169, "quality": 0.9565217391304348, "length": 22}}, "n4659": {"so_13886101_13886412_0": {"section_id": 4065, "quality": 0.6956521739130435, "length": 16}, "so_13886101_13886302_0": {"section_id": 4063, "quality": 0.5555555555555556, "length": 10}, "so_13886101_13886302_1": {"section_id": 4065, "quality": 0.7391304347826086, "length": 17}}}});