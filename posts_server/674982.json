post_cb({"675033": {"ParentId": "674982", "CommentCount": "2", "Body": "<p>When using <code>dynamic_cast</code> several checks are made during runtime to prevent you from doing something stupid (more at the <a href=\"http://gcc.gnu.org/ml/gcc/1999-12n/msg00544.html\" rel=\"nofollow noreferrer\">GCC mailing list</a>), the cost of one <code>dynamic_cast</code> depends on how many classes are affected, what classes are affected, etc.<br>\nIf you're really sure the cast is safe, you can still use <a href=\"http://www.cplusplus.com/doc/tutorial/typecasting.html\" rel=\"nofollow noreferrer\"><code>reinterpret_cast</code></a>.</br></p>\n", "OwnerUserId": "73299", "Id": "675033", "PostTypeId": "2", "OwnerDisplayName": "tstenner", "Score": "4", "CreationDate": "2009-03-23T20:09:00.640", "LastActivityDate": "2009-03-23T20:09:00.640"}, "674982": {"CommentCount": "10", "AcceptedAnswerId": "674996", "PostTypeId": "1", "LastEditorUserId": "922184", "LastEditorDisplayName": "Trevor Boyd Smith", "CreationDate": "2009-03-23T19:50:31.150", "LastActivityDate": "2014-07-21T14:45:56.937", "AnswerCount": "7", "LastEditDate": "2013-07-29T16:43:39.797", "ViewCount": "28858", "FavoriteCount": "18", "Title": "Performance hit from C++ style casts?", "Id": "674982", "Score": "44", "Body": "<p>I am new to C++ style casts and I am <strong>worried that using C++ style casts will ruin the performance of my application</strong> because I have a <a href=\"http://en.wikipedia.org/wiki/Real-time_computing\" rel=\"noreferrer\">real-time-critical deadline</a> in my interrupt-service-routine.</p>\n<p>I heard that some casts will even throw exceptions!</p>\n<p>I would like to use the C++ style casts because it would make my code more \"robust\". However, <strong>if there is any performance hit</strong> then I will probably not use C++ style casts and will instead spend more time testing the code that uses C-style casts.</p>\n<hr>\n<p>Has anyone done any rigorous testing/profiling to compare the performance of C++ style casts to C style casts?</p>\n<p>What were your results? </p>\n<p>What conclusions did you draw?</p>\n</hr>", "Tags": "<c++><performance><casting>", "OwnerUserId": "52074", "OwnerDisplayName": "Trevor Boyd Smith"}, "bq_ids": {"n4140": {"so_674982_675042_1": {"section_id": 6126, "quality": 0.96875, "length": 31}}, "n3337": {"so_674982_675042_1": {"section_id": 5890, "quality": 0.96875, "length": 31}}, "n4659": {"so_674982_675042_1": {"section_id": 7623, "quality": 0.96875, "length": 31}}}, "675124": {"CommentCount": "5", "CreationDate": "2009-03-23T20:35:54.333", "LastEditorUserId": "63550", "LastActivityDate": "2010-04-22T18:33:07.217", "ParentId": "674982", "LastEditDate": "2010-04-22T18:33:07.217", "OwnerDisplayName": "leander", "PostTypeId": "2", "Id": "675124", "Score": "3", "Body": "<p>Although I agree with the statement \"the only one with any extra cost at runtime is <code>dynamic_cast</code>\", keep in mind there may be compiler-specific differences.</p>\n<p>I've seen a few bugs filed against my current compiler where the code generation or optimization was slightly different depending on whether you use a C-style vs. C++-style <code>static_cast</code> cast.</p>\n<p>So if you're worried, check the disassembly on hotspots.  Otherwise just avoid dynamic casts when you don't need them.  (If you turn off RTTI, you can't use <code>dynamic_cast</code> anyway.)</p>\n", "OwnerUserId": "80074"}, "24868034": {"ParentId": "674982", "CommentCount": "0", "Body": "<p>The canonical truth is the assembly, so try both and see if you get different logic.</p>\n<p>If you get the exact same assembly, there is no difference- there can't be. The only place you really need to stick with the old C casts is in pure C routines and libraries, where it makes no sense to introduce C++ dependence just for type casting.</p>\n<p>One thing to be aware of is that casts happen all over the place in a decent sized piece of code. In my entire career I've never searched on \"all casts\" in a piece of logic- you tend to search for casts to a specific TYPE like 'A', and a search on \"(A)\" is usually just as efficient as something like \"static_cast&lt;A&gt;\". Use the newer casts for things like type validation and such, not because they make searches you'll never do anyway easier.</p>\n", "OwnerUserId": "3726672", "PostTypeId": "2", "Id": "24868034", "Score": "1", "CreationDate": "2014-07-21T14:45:56.937", "LastActivityDate": "2014-07-21T14:45:56.937"}, "675042": {"CommentCount": "8", "CreationDate": "2009-03-23T20:11:14.830", "LastEditorUserId": "34509", "LastActivityDate": "2009-03-23T21:09:30.383", "ParentId": "674982", "PostTypeId": "2", "LastEditorDisplayName": "litb", "LastEditDate": "2009-03-23T21:09:30.400", "Id": "675042", "Score": "16", "Body": "<p>Why would there be a performance hit? They perform <em>exactly</em> the same functionality as C casts. The only difference is that they catch more errors at compile-time, and they're easier to search for in your source code.</p>\n<p><code>static_cast&lt;float&gt;(3)</code> is exactly equivalent to <code>(float)3</code>, and will generate exactly the same code.</p>\n<p>Given a <code>float f = 42.0f</code>\n<code>reinterpret_cast&lt;int*&gt;(&amp;f)</code> is exactly equivalent to <code>(int*)&amp;f</code>, and will generate exactly the same code.</p>\n<p>And so on. The only cast that differs is <code>dynamic_cast</code>, which, yes, can throw an exception. But that is because it does things that the C-style cast cannot do. So don't use <code>dynamic_cast</code> unless you need its functionality.</p>\n<p>It is usually safe to assume that compiler writers are intelligent. Given two different expressions that have the same semantics according to the standard, it is usually safe to assume that they will be implemented identically in the compiler. </p>\n<p><strong>Oops</strong>: The second example should be reinterpret_cast, not dynamic_cast, of course. Fixed it now.</p>\n<p>Ok, just to make it absolutely clear, here is what the C++ standard says:</p>\n<p>\u00a75.4.5:</p>\n<blockquote>\n<p id=\"so_674982_675042_0\">The conversions performed by </p>\n<ul>\n<li>a <code>const_cast</code> (5.2.11)</li>\n<li>a <code>static_cast</code> (5.2.9)</li>\n<li>a <code>static_cast</code> followed by a <code>const_cast</code></li>\n<li>a <code>reinterpret_cast</code> (5.2.10), or</li>\n<li>a <code>reinterpret_cast</code> followed by a <code>const_cast</code>.</li>\n</ul>\n<p id=\"so_674982_675042_1\">can be performed using the cast\n  notation of explicit type conversion.\n  The same semantic restrictions and\n  behaviors apply. If a conversion can\n  be interpreted in more than one of the\n  ways listed above, the interpretation\n  that appears first in the list is\n  used, even if a cast resulting from\n  that interpretation is ill-formed.</p>\n</blockquote>\n<p>So if <em>anything</em>, since the C-style cast is implemented in terms of the C++ casts, C-style casts should be <em>slower</em>. (of course they aren't, because the compiler generates the same code in any case, but it's more plausible than the C++-style casts being slower.)</p>\n", "OwnerUserId": "33213", "OwnerDisplayName": "jalf"}, "674989": {"CommentCount": "0", "CreationDate": "2009-03-23T19:52:39.727", "LastEditorUserId": "27423", "LastActivityDate": "2009-03-23T20:39:16.370", "ParentId": "674982", "PostTypeId": "2", "LastEditorDisplayName": "Earwicker", "LastEditDate": "2009-03-23T20:39:16.370", "Id": "674989", "Score": "39", "Body": "<p>The only one with any extra cost at runtime is <code>dynamic_cast</code>, which has capabilities that cannot be reproduced directly with a C style cast anyway. So you have no problem.</p>\n<p>The easiest way to reassure yourself of this is to instruct your compiler to generate assembler output, and examine the code it generates. For example, in any sanely implemented compiler, <code>reinterpret_cast</code> will disappear altogether, because it just means \"go blindly ahead and pretend the data is of this type\".</p>\n", "OwnerUserId": "27423", "OwnerDisplayName": "Earwicker"}, "675248": {"CommentCount": "4", "CreationDate": "2009-03-23T21:10:53.890", "LastEditorUserId": "10593", "LastActivityDate": "2014-02-06T15:52:20.713", "ParentId": "674982", "PostTypeId": "2", "LastEditorDisplayName": "Max Lybbert", "LastEditDate": "2014-02-06T15:52:20.713", "Id": "675248", "Score": "15", "Body": "<p>There are four C++ style casts:</p>\n<ul>\n<li><code>const_cast</code></li>\n<li><code>static_cast</code></li>\n<li><code>reinterpret_cast</code></li>\n<li><code>dynamic_cast</code></li>\n</ul>\n<p>As already mentioned, the first three are compile-time operations.  There is no run-time penalty for using them.  They are messages to the compiler that data that has been declared one way needs to be accessed a different way.  \"I said this was an <code>int*</code>, but let me access it as if it were a <code>char*</code> pointing to <code>sizeof(int) char</code>s\" or \"I said this data was read-only, and now I need to pass it to a function that won't modify it, but doesn't take the parameter as a const reference.\"</p>\n<p>Aside from data corruption by casting to the wrong type and trouncing over data (always a possibility with C-style casts) the most common run-time problem with these casts is data that actually is declared <code>const</code> may not be castable to non-const.  Casting something declared <code>const</code> to non-const and then modifying it is undefined.  <a href=\"http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_21.html\" rel=\"noreferrer\">Undefined means you're not even guaranteed to get a crash</a>.</p>\n<p><code>dynamic_cast</code> is a run-time construct and has to have a run-time cost.</p>\n<p>The value of these casts is that they specifically say what you're trying to cast from/to, stick out visually, and can be searched for with brain-dead tools.  I would recommend using them over using C-style casts.</p>\n", "OwnerUserId": "10593", "OwnerDisplayName": "Max Lybbert"}, "674996": {"CommentCount": "6", "CreationDate": "2009-03-23T19:54:16.883", "LastEditorUserId": "63550", "LastActivityDate": "2010-04-22T18:31:40.607", "ParentId": "674982", "LastEditDate": "2010-04-22T18:31:40.607", "LastEditorDisplayName": "Neil Butterworth", "PostTypeId": "2", "Id": "674996", "Score": "76", "Body": "<p>If the C++ style cast can be conceptualy replaced by a C-style cast there will be no overhead. If it can't, as in the case of <code>dynamic_cast</code>, for which there is no C equivalent, you have to pay the cost one way or another.</p>\n<p>As an example, the following code:</p>\n<pre><code>int x;\nfloat f = 123.456;\n\nx = (int) f;\nx = static_cast&lt;int&gt;(f);\n</code></pre>\n<p>generates identical code for both casts with VC++ - code is:</p>\n<pre><code>00401041   fld         dword ptr [ebp-8]\n00401044   call        __ftol (0040110c)\n00401049   mov         dword ptr [ebp-4],eax\n</code></pre>\n<p>The only C++ cast that can throw is <code>dynamic_cast</code> when casting to a reference. To avoid this, cast to a pointer, which will return 0 if the cast fails.</p>\n", "OwnerDisplayName": "anon"}});