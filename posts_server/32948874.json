post_cb({"32949863": {"ParentId": "32948874", "CommentCount": "0", "CreationDate": "2015-10-05T13:29:11.060", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "32949863", "Score": "2", "Body": "<p>I think the issue comes from [basic.start.init]:</p>\n<blockquote>\n<p id=\"so_32948874_32949863_0\">Dynamic initialization of a non-local variable with static storage duration is <em>unordered</em> if the variable is an implicitly or explicitly instantiated specialization</p>\n</blockquote>\n<p>The initializations of <code>Derived&lt;Base&gt;::value</code> and <code>Foo&lt;BarType&gt;::value</code> are not static initialization - because the right-hand side is not a constant expression. That makes it dynamic initialization. Since the variables are template specializations, the initializations are <em>unordered</em> - that is, there is no explicitly defined ordering for the two <code>value</code>s. </p>\n<p>Thus, we have two possible orderings. The valid one:</p>\n<pre><code>Derived&lt;Base&gt;::value ==&gt; 0\nFoo&lt;BarType&gt;::value ==&gt; 0\nDerived&lt;Base&gt;::value ==&gt; Base::value\nFoo&lt;BarType&gt;::value ==&gt; BarType::value\n</code></pre>\n<p>And the invalid one:</p>\n<pre><code>Derived&lt;Base&gt;::value ==&gt; 0\nFoo&lt;BarType&gt;::value ==&gt; 0\nFoo&lt;BarType&gt;::value ==&gt; BarType::value\nDerived&lt;Base&gt;::value ==&gt; Base::value\n</code></pre>\n<p>If <code>Derived&lt;Base&gt;::value</code> is initialized first, then <code>Foo&lt;BarType&gt;::value</code> will point to <code>\"STRING\"</code>. Otherwise, if the latter is initialized first, it will be initialized to <code>0</code>. The segmentation fault you're seeing results from trying to stream a null character pointer. </p>\n", "LastActivityDate": "2015-10-05T13:29:11.060"}, "32951519": {"ParentId": "32948874", "CommentCount": "1", "CreationDate": "2015-10-05T14:50:15.330", "OwnerUserId": "3545273", "PostTypeId": "2", "Id": "32951519", "Score": "1", "Body": "<p>@Barry gave the why of the problem.</p>\n<p>A possible work around would be force the initialization order. As <code>String</code> is not a templated class, <code>String::value</code> will be correctly initialized (staticly) before dynamic initialization takes place.</p>\n<p>I can imagine 2 ways:</p>\n<ol>\n<li><p>Add an explicit init method to <code>Foo</code> instead of depending on automatic dynamic initialization:</p>\n<pre><code>...\ntemplate&lt;typename BarType&gt;\nstruct Foo\n{\n    static const char * value;\n        static void init() {\n            Foo::value = BarType::value;\n        }\n};\n\ntemplate&lt;typename BarType&gt;\nconst char * Foo&lt;BarType&gt;::value;\n\nusing Bar = Derived&lt;String&gt;;\nusing FooBar = Foo&lt;Bar&gt;;\n\nint main()\n{\n    FooBar::init();\n    std::cout &lt;&lt; \"FooBar::value = \" &lt;&lt; FooBar::value &lt;&lt; std::endl;\n}\n</code></pre></li>\n<li><p>Make <code>value</code> a function in Foo:</p>\n<pre><code>...\ntemplate&lt;typename BarType&gt;\nstruct Foo\n{\n    static const char * value() {\n        return BarType::value;;\n    }\n};\n\nusing Bar = Derived&lt;String&gt;;\nusing FooBar = Foo&lt;Bar&gt;;\n\nint main()\n{\n    std::cout &lt;&lt; \"FooBar::value = \" &lt;&lt; FooBar::value() &lt;&lt; std::endl;\n}\n</code></pre></li>\n</ol>\n", "LastActivityDate": "2015-10-05T14:50:15.330"}, "32948874": {"CommentCount": "22", "ViewCount": "350", "PostTypeId": "1", "LastEditorUserId": "212010", "CreationDate": "2015-10-05T12:39:50.630", "LastActivityDate": "2015-10-06T19:29:46.357", "Title": "Why is static const char * template struct member not initialized", "AcceptedAnswerId": "32949863", "LastEditDate": "2015-10-06T19:29:46.357", "Id": "32948874", "Score": "4", "Body": "<p>I have some C++11 template code I am trying to port to Visual C++ Compiler 2015. The original code works just fine, however I need to rewrite it to work around issues with constexpr.</p>\n<p><strong><a href=\"http://melpon.org/wandbox/permlink/WDLbHRgchibRGwv3\" rel=\"nofollow\">The original code (simplified example)</a></strong></p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct String\n{\n    static constexpr const char * value{ \"STRING\" };\n};\n\ntemplate&lt;typename Base&gt;\nclass Derived\n{\npublic:\n    static constexpr const char * value{ Base::value };\n};\n\ntemplate&lt;typename BarType&gt;\nstruct Foo\n{\n    static constexpr const char * value{ BarType::value };\n};\n\nusing Bar = Derived&lt;String&gt;;\nusing FooBar = Foo&lt;Bar&gt;;\n\nint main()\n{\n    std::cout &lt;&lt; \"FooBar::value = \" &lt;&lt; FooBar::value &lt;&lt; std::endl;\n}\n</code></pre>\n<p>This prints:</p>\n<pre><code>FooBar::value = STRING\n</code></pre>\n<p>However, when I rewrite, some static variables are not initialized. Even though it compiles just fine.</p>\n<p><strong><a href=\"http://melpon.org/wandbox/permlink/Ur1YLTICHKmv6R2T\" rel=\"nofollow\">The ported code (not working)</a></strong></p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct String\n{\n    static const char * value;\n};\nconst char * String::value = \"STRING\";\n\ntemplate&lt;typename Base&gt;\nclass Derived\n{\npublic:\n    static const char * value;\n};\ntemplate&lt;typename Base&gt;\nconst char * Derived&lt;Base&gt;::value = { Base::value };\n\ntemplate&lt;typename BarType&gt;\nstruct Foo\n{\n    static const char * value;\n};\ntemplate&lt;typename BarType&gt;\nconst char * Foo&lt;BarType&gt;::value = { BarType::value };\n\nusing Bar = Derived&lt;String&gt;;\nusing FooBar = Foo&lt;Bar&gt;;\n\nint main()\n{\n    std::cout &lt;&lt; \"FooBar::value = \" &lt;&lt; FooBar::value &lt;&lt; std::endl;\n}\n</code></pre>\n<p>This prints:</p>\n<pre><code>// nothing (Segmentation fault)\n</code></pre>\n<ol>\n<li><p>Why is this happening?</p></li>\n<li><p>How do I fix / work around it?</p></li>\n</ol>\n<p>This can be reproduced in Clang and Visual-C++, however GCC prints <code>FooBar::value = STRING</code> also in second example.</p>\n<p><strong>Update: <a href=\"http://melpon.org/wandbox/permlink/Ur1YLTICHKmv6R2T\" rel=\"nofollow\">Working solution</a></strong></p>\n<p>As suggested by @serge-ballesta. I prefere this solution since it is very similar to the original code. Easily applied and easily removed again when constexpr members are added to VS. </p>\n", "Tags": "<c++><templates><clang><constexpr><visual-c++-2015>", "OwnerUserId": "212010", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_32948874_32949863_0": {"section_id": 7151, "quality": 0.5384615384615384, "length": 7}}, "n3337": {"so_32948874_32949863_0": {"section_id": 6895, "quality": 0.5384615384615384, "length": 7}}, "n4659": {"so_32948874_32949863_0": {"section_id": 8654, "quality": 1.0, "length": 13}}}});