post_cb({"26821777": {"ViewCount": "658", "Body": "<p>I'm trying out the code presented by Sean Parent at his talk at GoingNative 2013 - <a href=\"http://channel9.msdn.com/Events/GoingNative/2013/Inheritance-Is-The-Base-Class-of-Evil\">\"Inheritance is the base class of evil\".</a> (code from the last slide available at <a href=\"https://gist.github.com/berkus/7041546\">https://gist.github.com/berkus/7041546</a></p>\n<p>I've tried to achieve the same goal on my own but I can't understand why the below code won't act as I expect it to.</p>\n<pre><code>#include &lt;boost/smart_ptr.hpp&gt;\n#include &lt;iostream&gt;\n#include &lt;ostream&gt;\n\ntemplate &lt;typename T&gt;\nvoid draw(const T&amp; t, std::ostream&amp; out)\n{\n    std::cout &lt;&lt; \"Template version\" &lt;&lt; '\\n';\n    out &lt;&lt; t &lt;&lt; '\\n';\n}\n\nclass object_t\n{\npublic:\n    template &lt;typename T&gt;\n    explicit object_t (T rhs) : self(new model&lt;T&gt;(rhs)) {};\n\n    friend void draw(const object_t&amp; obj, std::ostream&amp; out)\n    {\n        obj.self-&gt;draw(out);\n    }\n\nprivate:\n    struct concept_t\n    {\n        virtual ~concept_t() {};\n        virtual void draw(std::ostream&amp;) const = 0;\n    };\n\n    template &lt;typename T&gt;\n    struct model : concept_t\n    {\n        model(T rhs) : data(rhs) {};\n        void draw(std::ostream&amp; out) const\n        {\n            ::draw(data, out);\n        }\n\n        T data;\n    };\n\n    boost::scoped_ptr&lt;concept_t&gt; self;\n};\n\nclass MyClass {};\n\nvoid draw(const MyClass&amp;, std::ostream&amp; out)\n{\n    std::cout &lt;&lt; \"MyClass version\" &lt;&lt; '\\n';\n    out &lt;&lt; \"MyClass\" &lt;&lt; '\\n';\n}\n\nint main()\n{\n    object_t first(1);\n    draw(first, std::cout);\n\n    const object_t second((MyClass()));\n    draw(second, std::cout);\n\n    return 0;\n}\n</code></pre>\n<p>This version handles printing <code>int</code> fine, but fails to compile in the second case as the compiler doesn't know how to use <code>MyClass</code> with <code>operator&lt;&lt;</code>. I can't understand why the compiler won't choose the second overload provided specifically for the <code>MyClass</code>. The code compiles and works fine if I change the model::draw() method's name and remove the <code>::</code> global namespace specifier from its body, or if I change the MyClass' draw global function to a complete template specialization. </p>\n<p>The error message I get is as below, after that is a bunch of <code>candidate function not viable...</code></p>\n<pre><code>t76_stack_friend_fcn_visibility.cpp:9:9: error: invalid operands to binary expression ('std::ostream' (aka 'basic_ostream&lt;char&gt;') and 'const MyClass')\n    out &lt;&lt; t &lt;&lt; '\\n';\n    ~~~ ^  ~\nt76_stack_friend_fcn_visibility.cpp:36:15: note: in instantiation of function template specialization 'draw&lt;MyClass&gt;' requested here\n            ::draw(data, out);\n              ^\nt76_stack_friend_fcn_visibility.cpp:33:9: note: in instantiation of member function 'object_t::model&lt;MyClass&gt;::draw' requested here\n        model(T rhs) : data(rhs) {};\n        ^\nt76_stack_friend_fcn_visibility.cpp:16:42: note: in instantiation of member function 'object_t::model&lt;MyClass&gt;::model' requested here\n    explicit object_t (T rhs) : self(new model&lt;T&gt;(rhs)) {};\n                                         ^\nt76_stack_friend_fcn_visibility.cpp:58:20: note: in instantiation of function template specialization 'object_t::object_t&lt;MyClass&gt;' requested here\n    const object_t second((MyClass()));\n                   ^\n</code></pre>\n<p>Why is the template version of global draw template function choosen over the MyClass function overload? Is it because the template reference is greedy? How to fix this issue?</p>\n", "AcceptedAnswerId": "26821911", "Title": "Why does the compiler choose the incorrect function overload in this case?", "CreationDate": "2014-11-08T20:33:47.903", "Id": "26821777", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-03-18T10:27:23.970", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-18T10:27:23.970", "Score": "11", "OwnerUserId": "2900459", "Tags": "<c++><templates><inheritance><language-lawyer><argument-dependent-lookup>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_26821777_26821911_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 7105}, "so_26821777_26821911_1": {"length": 23, "quality": 0.8846153846153846, "section_id": 7103}, "so_26821777_26821911_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 224}, "so_26821777_26821911_3": {"length": 12, "quality": 1.0, "section_id": 7105}}, "n3337": {"so_26821777_26821911_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 6849}, "so_26821777_26821911_1": {"length": 23, "quality": 0.8846153846153846, "section_id": 6847}, "so_26821777_26821911_0": {"length": 13, "quality": 0.7647058823529411, "section_id": 217}, "so_26821777_26821911_3": {"length": 12, "quality": 1.0, "section_id": 6849}}, "n4659": {"so_26821777_26821911_2": {"length": 16, "quality": 0.9411764705882353, "section_id": 8606}, "so_26821777_26821911_1": {"length": 23, "quality": 0.8846153846153846, "section_id": 8604}, "so_26821777_26821911_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 232}, "so_26821777_26821911_3": {"length": 12, "quality": 1.0, "section_id": 8606}}}, "26821911": {"Id": "26821911", "PostTypeId": "2", "Body": "<p>Because you use a qualified name in the function call. [temp.dep.candidate]:</p>\n<blockquote>\n<p id=\"so_26821777_26821911_0\">For a function call that depends on a template parameter, the\n  candidate functions are found using the usual lookup rules (3.4.1,\n  3.4.2, 3.4.3) except that:</p>\n<ul>\n<li>For the part of the lookup using unqualified name lookup (3.4.1) <strong>or qualified name lookup (3.4.3), only function declarations from the\n  template definition context are found.</strong></li>\n<li>For the part of the lookup using associated namespaces (3.4.2), only function declarations found in either the template definition\n  context or the template instantiation context are found.</li>\n</ul>\n</blockquote>\n<p>\u00a73.4.2 (alias [basic.lookup.argdep]):</p>\n<blockquote>\n<p id=\"so_26821777_26821911_1\">When the <em>postfix-expression</em> in a function call (5.2.2) is an <strong><em>unqualified-id</em></strong>, other namespaces not considered during the usual <strong>unqualified lookup</strong> (3.4.1) may be searched, and in those namespaces,\n  namespace-scope friend function declarations (11.3) not otherwise\n  visible may be found.</p>\n</blockquote>\n<p>So essentially ADL doesn't apply since the call uses a qualified-id. <br>As Barry shows <a href=\"https://stackoverflow.com/a/26821916/3647361\">in his answer</a> you can resolve this by making the call unqualified:</br></p>\n<pre><code>void draw(std::ostream&amp; out) const\n{\n    using ::draw;\n    draw(data, out);\n}\n</code></pre>\n<p>You have to add a <code>using</code>-declaration before that though. Otherwise unqualified name lookup will find the <code>model&lt;&gt;::draw</code> member function first when searching the declarative regions in ascending order, and will not search any further. But not only that - <strong>because</strong> <code>model&lt;&gt;::draw</code> (which is a class member) is found my unqualified name lookup, ADL is <strong>not</strong> invoked, [basic.lookup.argdep]/3:</p>\n<blockquote>\n<p id=\"so_26821777_26821911_2\">Let <code>X</code> be the lookup set produced by unqualified lookup (3.4.1) and\n  let <code>Y</code> be the lookup set produced by argument dependent lookup\n  (defined as follows). If <code>X</code> contains</p>\n<ul>\n<li><strong>a declaration of a class member</strong>, or</li>\n<li>a block-scope function declaration that is not a <em>using-declaration</em>, or</li>\n<li>a declaration that is neither a function or a function template</li>\n</ul>\n<p id=\"so_26821777_26821911_3\">then <code>Y</code> is empty. Otherwise <code>Y</code> is the set of declarations found in the namespaces associated with the\n  argument types as described below.</p>\n</blockquote>\n<p>Hence, if the <code>using</code>-declaration is provided the only declaration found by unqualified name lookup will be the global <code>draw</code> template that was introduced into the declarative region of <code>model::draw</code>.\nADL is then invoked and finds the later declared <code>draw</code> function for <code>MyClass const&amp;</code>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-09T22:52:00.233", "Score": "8", "CreationDate": "2014-11-08T20:48:15.130", "ParentId": "26821777", "CommentCount": "10", "OwnerUserId": "3647361", "LastEditDate": "2017-05-23T11:59:46.120"}, "26821916": {"Id": "26821916", "PostTypeId": "2", "Body": "<p>When you directly call <code>::draw()</code>, you're not able to use ADL correctly. (Why? I don't actually know specifically and hopefully somebody will come in and explain this to me too <em>[edit: see <a href=\"https://stackoverflow.com/questions/26821777/why-does-the-compiler-choose-the-incorrect-function-overload-in-this-case/26821911#26821911\">Columbo's answer</a> with the why]</em>) But in order to actually use ADL, you need to make an unqualified call to <code>draw</code> like so:</p>\n<pre><code>void draw(std::ostream&amp; out) const\n{\n    using ::draw;\n    draw(data, out);\n}\n</code></pre>\n<p>That will correctly find the overload <code>draw(const MyClass&amp;, std::ostream&amp;)</code>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-08T21:01:35.797", "Score": "3", "CreationDate": "2014-11-08T20:49:00.993", "ParentId": "26821777", "CommentCount": "3", "OwnerUserId": "2069064", "LastEditDate": "2017-05-23T10:28:01.397"}});