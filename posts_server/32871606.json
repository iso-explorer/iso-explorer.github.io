post_cb({"bq_ids": {"n4140": {"so_32871606_32872389_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 4660}, "so_32871606_32872389_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 4651}}, "n3337": {"so_32871606_32872389_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 4470}, "so_32871606_32872389_1": {"length": 15, "quality": 0.8333333333333334, "section_id": 4462}}, "n4659": {"so_32871606_32872389_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 6020}, "so_32871606_32872389_1": {"length": 14, "quality": 0.7777777777777778, "section_id": 6020}}}, "32872389": {"Id": "32872389", "PostTypeId": "2", "Body": "<p><strong>Why is it broken?</strong></p>\n<p>When the return type of a lambda is deduced, reference and cv-qualifications are dropped. So the return type of </p>\n<pre><code>[](const std::vector&lt;int&gt; &amp;in){return in;};\n</code></pre>\n<p>is just <code>std::vector&lt;int&gt;</code>, not <code>std::vector&lt;int&gt; const&amp;</code>. As a result, if we strip out the lambda and <code>std::function</code> part of your code, we effectively have:</p>\n<pre><code>std::vector&lt;int&gt; lambda(std::vector&lt;int&gt; const&amp; in)\n{\n    return in;\n}\n\nstd::vector&lt;int&gt; const&amp; callback(std::vector&lt;int&gt; const&amp; in)\n{\n    return lambda(in);\n}\n</code></pre>\n<p><code>lambda</code> returns a temporary. It effectively is just copied its input. This temporary is bound the reference return in <code>callback</code>. But temporaries bound to a reference in a <code>return</code> statement do not have their lifetime extended, so the temporary is destroyed at the end of the return statement. Thus, at this point:</p>\n<pre><code>callback(v).at(0)\n-----------^\n</code></pre>\n<p>we have a dangling reference to a destroyed <em>copy</em> of <code>v</code>. </p>\n<p>The solution is to explicitly specify the return type of the lambda to be a reference:</p>\n<pre><code> [](const std::vector&lt;int&gt; &amp;in)-&gt; const std::vector&lt;int&gt;&amp; {return in;}\n [](const std::vector&lt;int&gt; &amp;in)-&gt; decltype(auto) {return in;} // C++14\n</code></pre>\n<p>Now there are no copies, no temporaries, no dangling references, and no undefined behavior. </p>\n<p><strong>Who's at fault?</strong></p>\n<p>As to whether this is expected behavior, the answer is actually yes. The conditions for constructibility of a <code>std::function</code> are [func.wrap.func.con]:</p>\n<blockquote>\n<p id=\"so_32871606_32872389_0\"><code>f</code> is Callable (20.9.12.2) for argument types <code>ArgTypes...</code> and return type <code>R</code>.</p>\n</blockquote>\n<p>where, [func.wrap.func]:</p>\n<blockquote>\n<p id=\"so_32871606_32872389_1\">A callable object <code>f</code> of type <code>F</code> is <em>Callable</em> for argument types <code>ArgTypes</code> and return type <code>R</code> if the expression\n  <code>INVOKE (f, declval&lt;ArgTypes&gt;()..., R)</code>, considered as an unevaluated operand (Clause 5), is well\n  formed (20.9.2).</p>\n</blockquote>\n<p>where, [func.require], emphasis mine:</p>\n<blockquote>\n<p id=\"so_32871606_32872389_2\">Define <code>INVOKE(f, t1, t2, ..., tN, R)</code> as <code>static_cast&lt;void&gt;(INVOKE (f, t1, t2, ..., tN))</code> if <code>R</code> is <em>cv</em> <code>void</code>, otherwise <code>INVOKE(f, t1, t2, ..., tN)</code> <strong>implicitly converted to <code>R</code></strong>.</p>\n</blockquote>\n<p>So, if we had:</p>\n<pre><code>T func();\nstd::function&lt;T const&amp;()&gt; wrapped(func);\n</code></pre>\n<p>That actually meets all the standard requirements: <code>INVOKE(func)</code> is well-formed and while it returns <code>T</code>, <code>T</code> <em>is</em> implicitly convertible to <code>T const&amp;</code>. So this isn't a gcc or clang bug. This is likely a standard defect, as I don't see why you would ever want to allow such a construction. This will <em>never</em> be valid, so the wording should likely require that if <code>R</code> is a reference type then <code>F</code> must return a reference type as well. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-10-01T13:50:24.033", "Score": "12", "CreationDate": "2015-09-30T17:34:43.787", "ParentId": "32871606", "CommentCount": "5", "OwnerUserId": "2069064", "LastEditDate": "2015-10-01T13:50:24.033"}, "32885608": {"Id": "32885608", "PostTypeId": "2", "Body": "<p>I did a bit of my own searching regarding the <code>std::function</code> constructor. It seems this part is an oversight in the interaction of <code>std::function</code> and the standard's <a href=\"http://en.cppreference.com/w/cpp/concept/Callable\" rel=\"nofollow\"><code>Callable</code> concept</a>. <code>std::function&lt;R(Args...)&gt;::function&lt;F&gt;(F)</code> requires <code>F</code> to be <code>Callable</code> as <code>R(Args...)</code>, which in itself seems reasonable. <code>Callable</code> for <code>R(Args...)</code> requires <code>F</code>'s return type (when given arguments of types <code>Args...</code> to be implicitly convertible to <code>R</code>, which also in itself seems reasonable. Now when <code>R</code> is <code>const R_ &amp;</code>, this will an allow implicit conversion of <code>R_</code> to <code>const R_ &amp;</code> because const references are allowed to bind to rvalues. This is not necessarily unsafe. E.g. consider a function <code>f()</code> that returns an <code>int</code>, but is considered callable as <code>const int &amp;()</code>.</p>\n<pre><code>const int &amp;result = f();\nif ( f == 5 )\n{\n   // ...\n}\n</code></pre>\n<p>There is no issue here because of C++'s rules for extending the lifetime of a temporary. <em>However</em>, the following has undefined behavior:</p>\n<pre><code>std::function&lt;const int &amp;()&gt; fWrapped{f};\nif ( fWrapped() == 5 )\n{\n   // ...\n}\n</code></pre>\n<p>This is because lifetime extension does not apply here. The temporary is created inside of <code>std::function</code>'s <code>operator()</code> and is destroyed before the comparison.</p>\n<p>Therefore, <code>std::function</code>'s constructor probably should not rely on <code>Callable</code> alone, but enforce the additional restriction that implicit conversion of an rvalue to a <code>const</code> lvalue in order to bind to a reference is forbidden. Alternatively, <code>Callable</code> could be changed to never allow this conversion, at the expense of disallowing some safe usage (if only because of lifetime extension).</p>\n<p>To make things more complicated yet, <code>fWrapped()</code> from the above example is perfectly safe to call, as long as you don't access the target of the dangling reference.</p>\n", "LastActivityDate": "2015-10-01T10:46:27.683", "CommentCount": "0", "CreationDate": "2015-10-01T10:46:27.683", "ParentId": "32871606", "Score": "2", "OwnerUserId": "4083309"}, "32871606": {"ViewCount": "1151", "Body": "<p>I'm having trouble with std::functions created from lambdas if the function returns a reference but the return type isn't explicitly called out as a reference. It seems that the std::function is created fine with no warnings, but upon calling it, a value is returned when a reference is expected, causing things to blow up. Here's a very contrived example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;functional&gt;\n\nint main(){\n   std::vector&lt;int&gt; v;\n   v.push_back(123);\n   std::function&lt;const std::vector&lt;int&gt;&amp;(const std::vector&lt;int&gt;&amp;)&gt; callback =\n      [](const std::vector&lt;int&gt; &amp;in){return in;};\n   std::cout &lt;&lt; callback(v).at(0) &lt;&lt; std::endl;\n   return 0;\n}\n</code></pre>\n<p>This prints out garbage, however if the lambda is modified to explicitly return a const reference it works fine. I can understand the compiler thinking the lambda is return-by-value without the hint (when I originally ran into this problem, the lambda was directly returning the result from a function that returned a const reference, in which case I would think that the const reference return of the lambda would be deducible, but apparently not.) What I am surprised by is that the compiler lets the std::function be constructed from the lambda with mismatched return types. Is this behavior expected? Am I missing something in the standard that allows this mismatch to occur? I'm seeing this with g++ (GCC) 4.8.2, haven't tried it with anything else.</p>\n<p>Thanks!</p>\n", "AcceptedAnswerId": "32872389", "Title": "Odd return behavior with std::function created from lambda (C++)", "CreationDate": "2015-09-30T16:48:51.813", "Id": "32871606", "CommentCount": "3", "LastEditDate": "2017-09-14T12:28:23.103", "PostTypeId": "1", "LastEditorUserId": "1725816", "LastActivityDate": "2017-09-14T12:28:23.103", "Score": "14", "OwnerUserId": "1725816", "Tags": "<c++><c++11><lambda><g++><std-function>", "AnswerCount": "2"}});