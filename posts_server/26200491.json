post_cb({"26200491": {"CommentCount": "5", "CreationDate": "2014-10-05T07:15:54.783", "PostTypeId": "1", "AcceptedAnswerId": "26200600", "LastEditorUserId": "251153", "LastActivityDate": "2015-01-03T01:43:31.807", "LastEditDate": "2014-10-06T22:25:39.020", "ViewCount": "3793", "FavoriteCount": "19", "Title": "What is an `int foo::*bar::*`?", "Id": "26200491", "Score": "68", "Body": "<p>A cool thing with C++ is that it lets you create variables of pointer-to-member types. The most common use case seems to be to get a pointer to a method:</p>\n<pre><code>struct foo\n{\n    int x() { return 5; }\n};\n\nint (foo::*ptr)() = &amp;foo::x;\nfoo myFoo;\ncout &lt;&lt; (myFoo.*ptr)() &lt;&lt; '\\n'; // prints \"5\"\n</code></pre>\n<p>However, messing around, I realized that they can just as well point to member variables:</p>\n<pre><code>struct foo\n{\n    int y;\n};\n\nint foo::*ptr = &amp;foo::y;\nfoo myFoo;\nmyFoo.*ptr = 5;\ncout &lt;&lt; myFoo.y &lt;&lt; '\\n'; // prints \"5\"\n</code></pre>\n<p>This is pretty rad. It led me to a further experiment: what if you could get a pointer to a sub-member of a structure?</p>\n<pre><code>struct foo\n{\n    int y;\n};\n\nstruct bar\n{\n    foo aFoo;\n};\n\nint bar::*foo::*ptr;\n</code></pre>\n<p>This <a href=\"https://ideone.com/euzlcd\" rel=\"noreferrer\">actually compiles</a>.</p>\n<p>However, I have no idea how to assign it anything useful. None of the following works:</p>\n<pre><code>int bar::*foo::*ptr = &amp;bar::foo::y; // no member named \"foo\" in \"bar\"\nint bar::*foo::*ptr = &amp;bar::aFoo::y; // no member named \"aFoo\" in \"bar\" (??)\nint bar::*foo::*ptr = &amp;foo::y; // can't init 'int bar::*foo::*' with 'int foo::*'\n</code></pre>\n<p>Furthermore, according to the error that this generates, it appears that this type is not exactly what I have in mind:</p>\n<pre><code>int bar::*foo::*ptr = nullptr;\nbar myBar;\nmyBar.*ptr = 4; // pointer to member type \u2018int bar::*\u2019 incompatible\n                // with object type \u2018bar\u2019\n</code></pre>\n<p>It appears that this concept evades me. Obviously, I can't rule out that it simply gets parsed in a way entirely different from what I would expect.</p>\n<p>Would anyone please explain me what an <code>int bar::*foo::*</code> actually is? Why does gcc tell me that a pointer to a member of <code>bar</code> is incompatible with a <code>bar</code> object? How would I use an <code>int bar::*foo::*</code>, and how would I construct a valid one?</p>\n", "Tags": "<c++><pointer-to-member>", "OwnerUserId": "251153", "AnswerCount": "5"}, "26204768": {"ParentId": "26200491", "CommentCount": "0", "Body": "<p>In case anyone is wondering, you can't create a pointer-to-member which nests multiple layers deep. The reason for this is that all pointer-to-members are actually way more complicated that what they look at a first glance; they are not simply containing a particular offset for that specific member.</p>\n<p>Using a simple offset does not work due to virtual inheritance and the likes; basically it can happen that, even within a single type, the offsets of a particular field vary between instances, and thus pointer-to-member resolution needs to be done at runtime. Mostly this is due to the fact that the standard does not specify how the internal layout for non-POD types might work, so there's no way to make it work statically.</p>\n<p>If this is the case, doing two-level deep resolution cannot be done with a normal pointer-to-member, but would need the compiler to generate a pointer such that it contains double the information of a one-deep pointer-to-member.</p>\n<p>I imagine that since pointers-to-member are not that common, there is no need to actually create a syntax to allow for setting multiple-layer deep members, when you can still use multiple pointers to achieve the same result.</p>\n", "OwnerUserId": "1356926", "PostTypeId": "2", "Id": "26204768", "Score": "3", "CreationDate": "2014-10-05T16:35:19.377", "LastActivityDate": "2014-10-05T16:35:19.377"}, "26200699": {"ParentId": "26200491", "LastEditDate": "2014-11-11T08:29:19.777", "CommentCount": "2", "CreationDate": "2014-10-05T07:50:50.570", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "PostTypeId": "2", "Id": "26200699", "Score": "13", "Body": "<p>Let's parse the declaration <code>int bar::*foo::*ptr;</code>.</p>\n<p>\u00a78.3.3 [dcl.mptr]/p1:</p>\n<blockquote>\n<p id=\"so_26200491_26200699_0\">In a declaration <code>T D</code> where <code>D</code> has the form</p>\n<pre><code>nested-name-specifier * attribute-specifier-seq_opt cv-qualifier-seq_opt D1\n</code></pre>\n<p id=\"so_26200491_26200699_1\">and the nested-name-specifier denotes a class, and the type of the\n  identifier in the declaration <code>T D1</code> is\n  \u201c<em>derived-declarator-type-list</em> <code>T</code>\u201d, then the type of the identifier\n  of <code>D</code> is \u201c<em>derived-declarator-type-list</em> <em>cv-qualifier-seq</em> pointer\n  to member of class <em>nested-name-specifier</em> of type <code>T</code>\u201d.</p>\n</blockquote>\n<ul>\n<li><p>Step 1: This is a declaration of the above form where <code>T</code> = int, <em>nested-name-specifier</em> = <code>bar::</code>, and <code>D1 = foo::* ptr</code>. We first look at the declaration <code>T D1</code>, or <code>int foo::* ptr</code>.</p></li>\n<li><p>Step 2: We apply the same rule again. <code>int foo::* ptr</code> is a declaration of the above form where <code>T</code> = int, <em>nested-name-specifier</em> = <code>foo::</code>, and <code>D1</code> = <code>ptr</code>. Obviously the type of the identifier in <code>int ptr</code> is \"<code>int</code>\", so the type of the identifier <code>ptr</code> in the declaration <code>int foo::* ptr</code> is \"pointer to member of class <code>foo</code> of type <code>int</code>\".</p></li>\n<li><p>Step 3. We go back to the original declaration; the type of the identifier in <code>T D1</code>(<code>int foo::* ptr</code>) is \"pointer to member of class <code>foo</code> of type <code>int</code>\" per step 2, so the <em>derived-declarator-type-list</em> is \"pointer to member of class <code>foo</code> of type\". Substitution tells us that this declaration declares <code>ptr</code> to be \"pointer to member of class <code>foo</code> of type pointer to member of class <code>bar</code> of type <code>int</code>\".</p></li>\n</ul>\n<p>Hopefully you will never need to use such a monstrosity.</p>\n", "LastActivityDate": "2014-11-11T08:29:19.777"}, "26200610": {"ParentId": "26200491", "LastEditDate": "2014-10-05T07:54:40.283", "CommentCount": "4", "CreationDate": "2014-10-05T07:34:18.657", "OwnerUserId": "947836", "LastEditorUserId": "947836", "PostTypeId": "2", "Id": "26200610", "Score": "19", "Body": "<p>That would be a pointer to a data member that is itself a pointer to a data member (an <code>int</code> member of <code>bar</code>).</p>\n<p>Don't ask me what it is actually useful for - my head is spinning a little :)</p>\n<p>EDIT: Here's a full example of it in action:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct bar {\n    int i;\n};\n\nstruct foo {\n    int bar::* p;\n};\n\nint main()\n{\n    bar b;\n    b.i = 42;\n\n    foo f;\n    f.p = &amp;bar::i;\n\n    int bar::*foo::*ptr = &amp;foo::p;\n    std::cout &lt;&lt; (b.*(f.*ptr));\n}\n</code></pre>\n<p>Output is, of course, 42.</p>\n<p>It can get even more fun - here's some pointers to member functions that return pointers to member functions:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct bar {\n    int f_bar(int i) { return i; };\n};\n\nstruct foo {\n    int(bar::*f_foo())(int)\n    {\n        return &amp;bar::f_bar;\n    }\n};\n\nint main()\n{\n    int(bar::*((foo::*ptr)()))(int) = &amp;foo::f_foo;\n\n    bar b;\n    foo f;\n\n    std::cout &lt;&lt; (b.*((f.*ptr)()))(42);\n}\n</code></pre>\n", "LastActivityDate": "2014-10-05T07:54:40.283"}, "27749992": {"ParentId": "26200491", "LastEditDate": "2015-01-03T01:43:31.807", "CommentCount": "0", "CreationDate": "2015-01-02T23:29:23.637", "OwnerUserId": "4183422", "LastEditorUserId": "4183422", "PostTypeId": "2", "Id": "27749992", "Score": "1", "Body": "<p>First, to help the \"readability\" you could use parenthesis (compiling will work) :</p>\n<pre><code>struct bar;\n\nstruct foo\n{\n    int y;\n    int (bar:: *whatever); // whatever is a pointer upon an int member of bar.\n};\n\nstruct bar\n{\n    foo aFoo;\n};\n\n// ptr is a pointer upon a member of foo which points upon an int member of bar.\nint (bar:: *(foo:: *ptr)) = &amp;foo::whatever;\n</code></pre>\n<p>Note that </p>\n<blockquote>\n<p id=\"so_26200491_27749992_0\">int (bar:: *whatever)</p>\n</blockquote>\n<p>is equivalent to </p>\n<blockquote>\n<p id=\"so_26200491_27749992_1\">int (*whatever)</p>\n</blockquote>\n<p>with a constraint about membership of bar.</p>\n<p>As for </p>\n<blockquote>\n<p id=\"so_26200491_27749992_2\">int (bar:: *(foo:: *ptr))</p>\n</blockquote>\n<p>, it is equivalent to </p>\n<blockquote>\n<p id=\"so_26200491_27749992_3\">int (*(*ptr))</p>\n</blockquote>\n<p>with two constraints about memberships of foo and bar.</p>\n<p>They are just pointers. They do not check if bar or foo really have a compatible member because that would prevent from using a forward declaration of class bar and class bar does not check if other classes are referring to its members through pointers. Besides, you may also need to refer an opaque class (that is, having a class bar defined in a separate unit).</p>\n<p>What about the usefulness ? maybe for C++ reflection as a way to set/get the value of a member of a class through a class wrapper ?</p>\n<pre><code>template&lt; typename Class, typename Type &gt;\nstruct ClassMember\n{\n    using MemberPointer = Type (Class:: *);\n    MemberPointer member;\n    ClassMember(MemberPointer member) : member(member) {}\n    void operator()(Class &amp; object, Type value) { object.*member = value; }\n    Type operator()(Class &amp; object)  { return object.*member; }\n};\n\ntemplate&lt; typename Class, typename Type &gt; ClassMember&lt; Class, Type &gt; MakeClassMember(Type(Class:: *member))\n{\n    return ClassMember&lt; Class, Type &gt;(member);\n}\n\nstruct Rectangle\n{\n    double width;\n    double height;\n\n    Rectangle(double width = 0., double height = 0.) : width(width), height(height) {}\n};\n\nint main(int argc, char const *argv[])\n{\n    auto r = Rectangle(2., 1.);\n\n    auto w = MakeClassMember(&amp;Rectangle::width);\n    auto h = MakeClassMember(&amp;Rectangle::height);\n\n    w(r, 3.);\n    h(r, 2.);\n\n    printf(\"Rectangle(%f, %f)\\n\", w(r), h(r));\n\n    return 0;\n}\n</code></pre>\n<p>Sure, this example does not show a particular usage of a double member pointer because I do not see a simple way to illustrate it here or a good reason to do so conceptually speaking.  </p>\n", "LastActivityDate": "2015-01-03T01:43:31.807"}, "bq_ids": {"n4140": {"so_26200491_26200699_1": {"section_id": 3225, "quality": 0.8235294117647058, "length": 14}}, "n3337": {"so_26200491_26200699_1": {"section_id": 3098, "quality": 0.8235294117647058, "length": 14}}, "n4659": {"so_26200491_26200699_1": {"section_id": 3982, "quality": 0.8823529411764706, "length": 15}}}, "26200600": {"ParentId": "26200491", "CommentCount": "4", "Body": "<p>Here's a \"valid\" way of initializing such a monstrosity:</p>\n<pre><code>struct bar;\n\nstruct foo\n{\n    int y;    \n    int bar::* whatever;\n};\n\nstruct bar\n{\n    foo aFoo;\n};\n\nint bar::* foo::* ptr = &amp;foo::whatever;\n</code></pre>\n<p>As we can see, <code>ptr</code> is a pointer to a member of <code>foo</code> (<code>foo::*</code>, reading right to left), where that member is itself a pointer to a member of <code>bar</code> (<code>bar::*</code>), where that member is an int.</p>\n<blockquote>\n<p id=\"so_26200491_26200600_0\">How would I use an int bar::* foo::*</p>\n</blockquote>\n<p>You wouldn't, hopefully!  But if you are under duress, try this!</p>\n<pre><code>struct bar\n{\n    foo aFoo;\n\n    int really;\n};\n\nint bar::* foo::* ptr = &amp;foo::whatever;\nfoo fleh;\nfleh.whatever = &amp;bar::really;\nbar blah;\nblah.*(fleh.*ptr) = 42;\nstd::cout &lt;&lt; blah.really &lt;&lt; std::endl;\n</code></pre>\n", "OwnerUserId": "4323", "PostTypeId": "2", "Id": "26200600", "Score": "53", "CreationDate": "2014-10-05T07:33:09.260", "LastActivityDate": "2014-10-05T07:33:09.260"}});