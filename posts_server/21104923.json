post_cb({"bq_ids": {"n4140": {"so_21104923_21104979_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 6955}}, "n3337": {"so_21104923_21104979_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 6702}}, "n4659": {"so_21104923_21104979_0": {"length": 8, "quality": 0.5714285714285714, "section_id": 8452}}}, "21104938": {"Id": "21104938", "PostTypeId": "2", "Body": "<p>Essentially a pointer (or rather a pair of pointers) is being passed. When you pass a pointer by reference, then under the hood you're passing a pointer to a pointer. Which is just added inefficiency and complexity.</p>\n<p>What's most efficient for small types depends much on the compiler and compilation options.</p>\n<p>Still, as a simple rule of thumb, small built-in type arguments are passed by value, and also small structs consisting of one or two such values, while larger stuff is passed by reference for efficiency (just accepting the little problem of aliasing, since it's not very much an in-practice problem).</p>\n", "LastActivityDate": "2014-01-14T02:14:20.150", "Score": "3", "CreationDate": "2014-01-14T02:14:20.150", "ParentId": "21104923", "CommentCount": "0", "OwnerUserId": "464581"}, "21104979": {"Id": "21104979", "PostTypeId": "2", "Body": "<p>If we look at this reference for <a href=\"http://en.cppreference.com/w/cpp/utility/initializer_list\" rel=\"nofollow\">std::initializer_list</a> it says:</p>\n<blockquote>\n<p id=\"so_21104923_21104979_0\">Initializer lists may be implemented as a pair of pointers or pointer and length. Copying a std::initializer_list does not copy the underlying objects. </p>\n</blockquote>\n<p>which gives you a strong hint as to why it is passed by value, because it is not very expensive to copy over a pair of pointer or a pointer and a length. The quote is actually from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft standard</a> section <code>18.9</code> <em>Initializer lists</em> paragraph <em>2</em>.</p>\n<p>If we look at one of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2100.pdf\" rel=\"nofollow\">earlier proposals</a> we find the same reasoning:</p>\n<blockquote>\n<p id=\"so_21104923_21104979_1\">Note that an initializer_list is a small object (probably two words), so passing it by value makes sense. Passing by value also simplifies inlining of begin() and end() and constant expression evaluation of size().</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-01-14T02:39:59.493", "Score": "3", "CreationDate": "2014-01-14T02:19:58.897", "ParentId": "21104923", "CommentCount": "2", "LastEditDate": "2014-01-14T02:39:59.493", "OwnerUserId": "1708801"}, "21104923": {"ViewCount": "105", "Body": "<p>Below is from <strong><em>C++ Primer 5th Edition</em></strong> (P.564):</p>\n<blockquote>\n<p id=\"so_21104923_21104923_0\">As one example, in addition to the copy- and move-assignment\n  operators, the library <strong>vector</strong> class defines a third assignment\n  operator that takes a braced list of elements (\u00a7 9.2.5, p. 337). We\n  can use this operator as follows:</p>\n<pre><code>vector&lt;string&gt; v;\nv = {\"a\", \"an\", \"the\"};\n</code></pre>\n<p id=\"so_21104923_21104923_1\">We can add this operator to our <strong>StrVec</strong> class (\u00a7 13.5, p. 526) as well:</p>\n<pre><code>class StrVec {\npublic:\n    StrVec &amp;operator=(std::initializer_list&lt;std::string&gt;);\n    //                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n};\n</code></pre>\n</blockquote>\n<p>While reading, I noticed that the parameter used here is a value rather than a reference  as I expected. So I went to the stl library codes for <code>std::vector</code>.Below is what I found from the file <code>stl_vector.h</code>:</p>\n<pre><code>  /**\n   *  @brief  Builds a %vector from an initializer list.\n   *  @param  __l  An initializer_list.\n   *  @param  __a  An allocator.\n   *\n   *  Create a %vector consisting of copies of the elements in the\n   *  initializer_list @a __l.\n   *\n   *  This will call the element type's copy constructor N times\n   *  (where N is @a __l.size()) and do no memory reallocation.\n   */\n  vector(initializer_list&lt;value_type&gt; __l,\n     const allocator_type&amp; __a = allocator_type())\n  : _Base(__a)\n  {\n_M_range_initialize(__l.begin(), __l.end(),\n            random_access_iterator_tag());\n  }\n</code></pre>\n<p>Seems the parameter used for std::vector is also a value rather than a reference just as did in this book. But why?\nIsn't it more efficient to use a reference?   </p>\n", "AcceptedAnswerId": "21104979", "Title": "Why isn't it a reference type when std::initializer_list being used as an assignment parameter?", "CreationDate": "2014-01-14T02:12:27.603", "Id": "21104923", "CommentCount": "1", "LastEditDate": "2014-01-14T02:14:54.800", "PostTypeId": "1", "LastEditorUserId": "701092", "LastActivityDate": "2014-01-14T02:39:59.493", "Score": "2", "OwnerUserId": "1809544", "Tags": "<c++><c++11><vector><stl>", "AnswerCount": "2"}});