post_cb({"14592463": {"ParentId": "14592215", "CommentCount": "0", "CreationDate": "2013-01-29T21:16:38.900", "OwnerUserId": "1150249", "PostTypeId": "2", "Id": "14592463", "Score": "2", "Body": "<p>In general, no, that is not portable. It may work by coincidence on some platform.</p>\n<p>There are end-iterators that <em>can</em> be re-used for different ranges, such as the default-constructed istream_iterator:</p>\n<pre><code>ifstream a(\"foo.txt\");\nifstream b(\"bar.txt\");\nistream_iterator&lt;string&gt; end;\nistream_iterator&lt;string&gt; ia( a);\nistream_iterator&lt;string&gt; ib( b);\n// from here on both [ia, end&gt; and [ib, end&gt; are valid ranges.\n</code></pre>\n", "LastActivityDate": "2013-01-29T21:16:38.900"}, "14593111": {"ParentId": "14592215", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-01-29T22:18:28.707", "Score": "0", "LastEditorUserId": "214671", "LastEditDate": "2013-01-29T22:21:36.343", "Id": "14593111", "OwnerUserId": "1221660", "Body": "<p>Try it yourself:</p>\n<pre><code>#include &lt;map&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nmap&lt;int,int&gt; m1;\nmap&lt;int,int&gt; m2;\n\nint main() {\n  cout&lt;&lt;(m1.end() == m2.end())&lt;&lt;endl;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/o18DtQ\" rel=\"nofollow\">http://ideone.com/o18DtQ</a></p>\n<blockquote>\n<p id=\"so_14592215_14593111_0\">output:</p>\n<pre><code>0\n</code></pre>\n</blockquote>\n", "LastActivityDate": "2013-01-29T22:21:36.343"}, "bq_ids": {"n4140": {"so_14592215_14592233_1": {"section_id": 5560, "quality": 0.875, "length": 14}, "so_14592215_14592233_0": {"section_id": 707, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_14592215_14592233_1": {"section_id": 5342, "quality": 0.875, "length": 14}, "so_14592215_14592233_0": {"section_id": 697, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_14592215_14592233_1": {"section_id": 7007, "quality": 0.875, "length": 14}, "so_14592215_14592233_0": {"section_id": 736, "quality": 0.9444444444444444, "length": 17}}}, "14592233": {"ParentId": "14592215", "PostTypeId": "2", "CommentCount": "11", "CreationDate": "2013-01-29T21:02:08.637", "Score": "6", "LastEditorUserId": "819272", "LastEditDate": "2013-01-29T22:13:17.557", "Id": "14592233", "OwnerUserId": "819272", "Body": "<p>No, because of the STL container and iterator requirements:</p>\n<p><strong>23.2.1 General container requirements [container.requirements.general]</strong></p>\n<blockquote>\n<p id=\"so_14592215_14592233_0\">6 begin() returns an iterator referring to the \ufb01rst element in the\n  container. end() returns an iterator which is the past-the-end value\n  for the container. If the container is empty, then begin() == end();</p>\n</blockquote>\n<p><strong>24.2.1 In general [iterator.requirements.general]</strong> </p>\n<blockquote>\n<p id=\"so_14592215_14592233_1\">6 An iterator j is called reachable from an iterator i if and only if\n  there is a \ufb01nite sequence of applications of the expression ++i that\n  makes i == j. If j is reachable from i, they refer to elements of the\n  same sequence.</p>\n</blockquote>\n<p>The equality of <code>begin()</code> and <code>end()</code> for empty containers means that <code>begin()</code> and <code>end()</code> need to be part of the same container objects, and hence <code>end()</code> cannot be a static member of a container class. Note also that -except for forward iterators- applying <code>operator--</code> on <code>end()</code> would be impossible to resolve with a static <code>end()</code> iterator.</p>\n", "LastActivityDate": "2013-01-29T22:13:17.557"}, "14592215": {"CommentCount": "5", "ViewCount": "349", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2013-01-29T21:01:14.390", "LastActivityDate": "2013-01-29T22:21:36.343", "Title": "Are all end() iterators equivalent for a collection type?", "AcceptedAnswerId": "14592233", "LastEditDate": "2013-01-29T21:27:43.577", "Id": "14592215", "Score": "5", "Body": "<p>Given a particular stl collection in C++, is the <code>end()</code> value equivalent for all instances of  the same templatization?  In other words, will the following work for all stl containers and circumstances (not just for std::map)?</p>\n<pre><code>std::map&lt;Key, Value&gt; foo(int seed);\n\nstd::map&lt;Key, Value&gt; instance1 = foo(1);\nstd::map&lt;Key, Value&gt; instance2 = foo(2);\nstd::map&lt;Key, Value&gt;::iterator itr = instance1.begin();\nstd::map&lt;Key, Value&gt;::iterator endItr = instance2.end(); // Comes from other collection!\n\nfor (; itr != endItr; ++itr) {\n  // Do something on each key value pair...\n}\n</code></pre>\n", "Tags": "<c++><stl><iterator><containers><language-lawyer>", "OwnerUserId": "115751", "AnswerCount": "3"}});