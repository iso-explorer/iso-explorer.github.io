post_cb({"34622076": {"ViewCount": "448", "Body": "<p>Consider the following:</p>\n<pre><code>struct A {\n    A(int, int) { }\n};\n\nstruct B {\n    B(A ) { }                   // (1)\n    explicit B(int, int ) { }   // (2)\n};\n\nint main() {\n    B paren({1, 2});   // (3)\n    B brace{1, 2};     // (4)\n}\n</code></pre>\n<p>The construction of <code>brace</code> in <code>(4)</code> clearly and unambiguously calls <code>(2)</code>. On clang, the construction of <code>paren</code> in <code>(3)</code> unambiguously calls <code>(1)</code> where as on gcc 5.2, it fails to compile with:</p>\n<pre><code>main.cpp: In function 'int main()':\nmain.cpp:11:19: error: call of overloaded 'B(&lt;brace-enclosed initializer list&gt;)' is ambiguous\n     B paren({1, 2});\n                   ^\nmain.cpp:6:5: note: candidate: B::B(A)\n     B(A ) { }  \n     ^\nmain.cpp:5:8: note: candidate: constexpr B::B(const B&amp;)\n struct B {\n        ^\nmain.cpp:5:8: note: candidate: constexpr B::B(B&amp;&amp;)\n</code></pre>\n<p>Which compiler is right? I suspect clang is correct here, as the ambiguity in gcc can only arise through a path that involves implicitly constructing <code>B{1,2}</code> and passing that to the copy/move constructor - yet that constructor is marked <code>explicit</code>, so such implicit construction should not be allowed. </p>\n", "AcceptedAnswerId": "34839362", "Title": "Calling an explicit constructor with a braced-init list: ambiguous or not?", "CreationDate": "2016-01-05T22:06:37.913", "Id": "34622076", "CommentCount": "12", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2016-01-17T14:19:38.763", "Score": "18", "OwnerUserId": "2069064", "Tags": "<c++><c++11><gcc><language-lawyer>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_34622076_34839362_0": {"length": 21, "quality": 0.75, "section_id": 599}}, "n3337": {"so_34622076_34839362_0": {"length": 21, "quality": 0.75, "section_id": 589}}, "n4659": {"so_34622076_34839362_0": {"length": 21, "quality": 0.75, "section_id": 622}}}, "34839362": {"Id": "34839362", "PostTypeId": "2", "Body": "<p>As far as I can tell, <strong>this is a clang bug</strong>.</p>\n<p>Copy-list-initialization has a rather unintuitive behaviour: It considers explicit constructors as viable until overload resolution is completely finished, but can then reject the overload result if an explicit constructor is chosen. The wording in a post-N4567 draft, [over.match.list]p1</p>\n<blockquote>\n<p id=\"so_34622076_34839362_0\">In copy-list-initialization, if an <code>explicit</code> constructor is chosen, the\n  initialization is ill-formed. [ <em>Note:</em> This differs from other\n  situations (13.3.1.3, 13.3.1.4), where only converting constructors\n  are considered for copy-initialization. This restriction only applies\n  if this initialization is part of the final result of overload\n  resolution. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<hr>\n<p>clang HEAD accepts the following program:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct String1 {\n    explicit String1(const char*) { cout &lt;&lt; \"String1\\n\"; }\n};\nstruct String2 {\n    String2(const char*) { cout &lt;&lt; \"String2\\n\"; }\n};\n\nvoid f1(String1) { cout &lt;&lt; \"f1(String1)\\n\"; }\nvoid f2(String2) { cout &lt;&lt; \"f2(String2)\\n\"; }\nvoid f(String1) { cout &lt;&lt; \"f(String1)\\n\"; }\nvoid f(String2) { cout &lt;&lt; \"f(String2)\\n\"; }\n\nint main()\n{\n    //f1( {\"asdf\"} );\n    f2( {\"asdf\"} );\n    f( {\"asdf\"} );\n}\n</code></pre>\n<p>Which is, except for commenting out the call to <code>f1</code>, straight from Bjarne Stroustrup's <a href=\"http://www.stroustrup.com/list-issues-2.pdf\" rel=\"nofollow noreferrer\">N2532 - Uniform initialization</a>, Chapter 4. Thanks to <a href=\"https://stackoverflow.com/users/34509/johannes-schaub-litb\">Johannes Schaub</a> for showing me this paper on <a href=\"https://groups.google.com/a/isocpp.org/d/topic/std-discussion/hF074Yz3wno/discussion\" rel=\"nofollow noreferrer\">std-discussion</a>.</p>\n<p>The same chapter contains the following explanation:</p>\n<blockquote>\n<p id=\"so_34622076_34839362_1\">The real advantage of <code>explicit</code> is that it renders <code>f1(\"asdf\")</code> an\n  error. A problem is that overload resolution \u201cprefers\u201d non-<code>explicit</code>\n  constructors, so that <code>f(\"asdf\")</code> calls <code>f(String2)</code>. I consider the\n  resolution of <code>f(\"asdf\")</code> less than ideal because the writer of\n  <code>String2</code> probably didn\u2019t mean to resolve ambiguities in favor of\n  <code>String2</code> (at least not in every case where explicit and non-explicit\n  constructors occur like this) and the writer of <code>String1</code> certainly\n  didn\u2019t. The rule favors \u201csloppy programmers\u201d who don\u2019t use <code>explicit</code>.</p>\n</blockquote>\n<hr>\n<p>For all I know, <a href=\"http://wg21.link/n2640\" rel=\"nofollow noreferrer\">N2640 - Initializer Lists \u2014 Alternative Mechanism and Rationale</a> is the last paper that includes rationale for this kind of overload resolution; it successor <a href=\"http://wg21.link/n2672\" rel=\"nofollow noreferrer\">N2672</a> was voted into the C++11 draft.</p>\n<p>From its chapter \"The Meaning Of Explicit\":</p>\n<blockquote>\n<p id=\"so_34622076_34839362_2\">A first approach to make the example ill-formed is to require that all\n  constructors (explicit and non-explicit) are considered for implicit\n  conversions, but if an explicit constructor ends up being selected,\n  that program is ill-formed. This rule may introduce its own surprises;\n  for example:</p>\n<pre><code>struct Matrix {\n    explicit Matrix(int n, int n);\n};\nMatrix transpose(Matrix);\n\nstruct Pixel {\n    Pixel(int row, int col);\n};\nPixel transpose(Pixel);\n\nPixel p = transpose({x, y}); // Error.\n</code></pre>\n<p id=\"so_34622076_34839362_3\">A second approach is to ignore the explicit constructors when looking\n  for the viability of an implicit conversion, but to include them when\n  actually selecting the converting constructor: If an explicit\n  constructor ends up being selected, the program is ill-formed. This\n  alternative approach allows the last (Pixel-vs-Matrix) example to work\n  as expected (<code>transpose(Pixel)</code> is selected), while making the\n  original example (\"<code>X x4 = { 10 };</code>\") ill-formed.</p>\n</blockquote>\n<p>While this paper proposes to use the second approach, its wording seems to be flawed - in my interpretation of the wording, it doesn't produce the behaviour outlined in the rationale part of the paper. The wording is revised in N2672 to use the first approach, but I couldn't find any discussion about why this was changed.</p>\n<hr>\n<p>There is of course slightly more wording involved in initializing a variable as in the OP, but considering the difference in behaviour between clang and gcc is the same for the first sample program in my answer, I think this covers the main points.</p>\n</hr></hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2016-01-17T14:19:38.763", "Score": "7", "CreationDate": "2016-01-17T14:19:38.763", "ParentId": "34622076", "CommentCount": "1", "LastEditDate": "2017-05-23T12:16:13.407", "OwnerUserId": "420683"}, "34623534": {"Id": "34623534", "PostTypeId": "2", "Body": "<p>This is not a complete answer, even though it is too long as a comment.<br/>\nI'll try to propose a counterexample to your reasoning and I'm ready to see downvote for I'm far from being sure.<br/>\nAnyway, let's try!! :-)</p>\n<p>It follows the reduced example:</p>\n<pre><code>struct A {\n    A(int, int) { }\n};\n\nstruct B {\n    B(A) { }\n    explicit B(int, int ) { }\n};\n\nint main() {\n    B paren({1, 2});\n}\n</code></pre>\n<p>In this case, the statement <code>{1, 2}</code> gives place apparently to two solutions:</p>\n<ul>\n<li><p>direct initialization by means of <code>B(A)</code>, because <code>A(int, int)</code> is not explicit and thus it is allowed and that's actually the first candidate</p></li>\n<li><p>for the same reason above, it can be interpreted as <code>B{B(A{1,2})}</code> (well, let me abuse the notation to give you an idea and what I mean), that is <code>{1,2}</code> allows the construction of a <code>B</code> temporary object that is used immediately after as an argument for the copy/move constructor, and it's allowed again because the involved constructors are not explicit</p></li>\n</ul>\n<p>The latter would explain the second and the third candidates.</p>\n<p>Does it make sense?<br/>\nI'm ready to delete the answers as long as you explain me what's wrong in my reasoning. :-)</p>\n", "LastActivityDate": "2016-01-06T00:10:11.100", "Score": "0", "CreationDate": "2016-01-06T00:10:11.100", "ParentId": "34622076", "CommentCount": "7", "OwnerUserId": "4987285"}});