post_cb({"bq_ids": {"n4140": {"so_41991363_41991412_1": {"length": 37, "quality": 0.9487179487179487, "section_id": 456}, "so_41991363_41991412_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 458}}, "n3337": {"so_41991363_41991412_1": {"length": 37, "quality": 0.9487179487179487, "section_id": 447}, "so_41991363_41991412_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 449}}, "n4659": {"so_41991363_41991412_1": {"length": 38, "quality": 0.9743589743589743, "section_id": 479}, "so_41991363_41991412_0": {"length": 34, "quality": 1.0, "section_id": 481}}}, "41991412": {"Id": "41991412", "PostTypeId": "2", "Body": "<p>You don't need <code>vector</code>, a simpler example would be just:</p>\n<pre><code>C1 a;\nC1 b(std::move(a)); // error: C1's copy constructor is deleted\n</code></pre>\n<p>From [class.copy]:</p>\n<blockquote>\n<p id=\"so_41991363_41991412_0\">If the definition of a class <code>X</code> does not explicitly declare a move constructor, a non-explicit one will be implicitly declared as defaulted if and only if<br>\n  (9.1) \u2014 <code>X</code> does not have a user-declared copy constructor,<br>\n  (9.2) \u2014 <code>X</code> does not have a user-declared copy assignment operator,<br>\n  (9.3) \u2014 <code>X</code> does not have a user-declared move assignment operator, and<br>\n<strong>(9.4) \u2014 <code>X</code> does not have a user-declared destructor.</strong></br></br></br></br></p>\n</blockquote>\n<p><code>C1</code> has a user-declared destructor, therefore it does not have a move constructor. <code>C1</code> <em>does</em> however have an implicitly declared copy constructor</p>\n<blockquote>\n<p id=\"so_41991363_41991412_1\">If the class definition does not explicitly declare a copy constructor, <strong>a non-explicit one is declared implicitly</strong>. If the class definition declares a move constructor or move assignment operator, the implicitly declared copy\n  constructor is defined as deleted; <strong>otherwise, it is defined as defaulted (8.4)</strong>. The latter case is deprecated if the class has a user-declared copy assignment operator or a user-declared destructor.</p>\n</blockquote>\n<p>The full set of constructors on <code>C1</code>, explicit and implicit, looks like:</p>\n<pre><code>C1();\nC1(C1 const&amp; ) = default; // but also delete\n~C1();\n</code></pre>\n<p>So trying to construct a <code>C1</code> from an rvalue of type <code>C1</code> will match that implicitly declared copy constructor as the best match (nothing else is viable), but that constructor is <code>deleted</code> because <code>noncopyable</code>'s copy constructor is <code>deleted</code>, so the entire expression is ill-formed.</p>\n<p>That's why the error message mentions the constructor. That move-construction is ill-formed because the best match for that move-construction is the copy constructor is ill-formed. It can't mention the move constructor because <em>there is no</em> move constructor, and the destructor isn't relevant to the expression at hand. When you changed the base class to be copyable, now <code>C1</code> also becomes copyable - so no error. There's still no move constructor, it's just that now there's a viable candidate for move construction. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-02-01T23:11:21.813", "Score": "3", "CreationDate": "2017-02-01T22:58:50.267", "ParentId": "41991363", "CommentCount": "2", "OwnerUserId": "2069064", "LastEditDate": "2017-02-01T23:11:21.813"}, "41991363": {"ViewCount": "207", "Body": "<p>I have the following sample:</p>\n<pre><code>#include &lt;vector&gt;\n\nclass noncopyable {\nprotected:\n    noncopyable() {}\n    ~noncopyable() {}\n    noncopyable(const noncopyable&amp;) = delete;\n    noncopyable&amp; operator=(const noncopyable&amp;) = delete;\n    noncopyable(noncopyable&amp;&amp;) = default;\n    noncopyable&amp; operator=(noncopyable&amp;&amp;) = default;\n};\n\nclass C1 : private noncopyable {\npublic:\n  C1() { }\n  ~C1() { }\n};\n\nint main() {\n    std::vector&lt;C1&gt; v;\n    v.emplace_back();\n    return 0;\n}\n</code></pre>\n<p>I thought it should work since <code>C1</code> should be movable since it's base class is and it has no data members. Instead, I got an an error (using clang++):</p>\n<pre><code>error: call to implicitly-deleted copy constructor of 'C1'\n    { ::new(static_cast&lt;void*&gt;(__p)) _T1(std::forward&lt;_Args&gt;(__args)...); }\n                                     ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n.\n.\n.\nnote: in instantiation of function template specialization 'std::vector&lt;C1, std::allocator&lt;C1&gt; &gt;::emplace_back&lt;&gt;' requested here\n        v.emplace_back();\n          ^\nnote: copy constructor of 'C1' is implicitly deleted because base class 'noncopyable' has a deleted copy constructor\nclass C1 : private noncopyable {\n           ^\nnote: 'noncopyable' has been explicitly marked deleted here\n        noncopyable(const noncopyable&amp;) = delete;\n</code></pre>\n<p>Doing a little research (<a href=\"http://en.cppreference.com/w/cpp/language/move_constructor\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/move_constructor</a>) revealed that if there is a user-defined destructor then no implicit move-constructor will be defined. This seemes to be the problem here, since <code>C1</code> has a destructor, the move-constructor does not get defined. Sure enough, if I either remove the destructor or add <code>C1(C1&amp;&amp;) = default;</code> to <code>C1</code> then it works.</p>\n<p>So far so good.</p>\n<p>The problem was that the error message didn't mention <code>~C1()</code> or the move-constructor. It said it was trying to call the copy constructor, which was deleted in the base class. So I tried changing the <code>delete</code>ed functions in <code>noncopyable</code> to be <code>default</code>ed instead, and (surprise!), that also solved the error.</p>\n<p>So my question is, what does this last thing have to do with the error or it's correction? If there is a destructor, what is the difference if the base class has the copy-constructor or not?</p>\n", "AcceptedAnswerId": "41991412", "Title": "What is causing the move constructor to be deleted", "CreationDate": "2017-02-01T22:54:37.603", "Id": "41991363", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-02-01T23:11:21.813", "Score": "0", "OwnerUserId": "331785", "Tags": "<c++><c++11><constructor>", "AnswerCount": "1"}});