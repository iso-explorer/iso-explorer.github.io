post_cb({"34162106": {"Id": "34162106", "PostTypeId": "2", "Body": "<p>Let's start by breaking this up into two pieces, so we can analyze each separately:</p>\n<pre><code>#include &lt;string&gt;\nvoid foo()\n{\n    auto x = std::move(\"\");\n    std::string s(x);\n}\n</code></pre>\n<p>The second part, that initializes the string from <code>x</code> (whatever type that might happen to be) isn't really the problem or question at hand here. The question at hand (at least as it seems to me) is the first line, where we try to bind an rvalue reference to a string literal.</p>\n<p>The relevant part of the standard for that would be <code>[dcl.init.ref]/5</code> (\u00a78.5.3/5, at least in most versions of the C++ standard I've seen).</p>\n<p>This starts with: </p>\n<blockquote>\n<p id=\"so_34160614_34162106_0\">A reference to type ''<em>cv1</em> T1'' is initialized by an expression of type ''<em>cv2</em> T2'' as follows.</p>\n</blockquote>\n<p>That's followed by a bullet list. The first item covers only lvalue references, so we'll ignore it. The second item says:</p>\n<blockquote>\n<p id=\"so_34160614_34162106_1\">if the initializer expression<br>\n  - is an xvalue (but not a bit-field) class prvalue, array prvalue or function lvalue[...]<br>\n  - has class type (i.e., <code>T2</code> is a class type)[...]<br>\n  - Otherwise\n    - if <code>T1</code> or <code>T2</code> is a class type and T1 is not is not reference related to T2 [...]</br></br></br></p>\n</blockquote>\n<p>Clearly none of those applies. A string literal is not an xvalue, class prvalue, array prvalue or function lvalue, nor does it have class type.</p>\n<p>That leaves only:</p>\n<blockquote>\n<p id=\"so_34160614_34162106_2\">If <code>T1</code> is reference-related to <code>T2</code>:<br>\n  - <em>cv1</em> shall be the same cv-qualification as, or greater cv-qualification than, <em>cv2</em>, and<br>\n  - <strong>if the reference is an rvalue reference, the initializer expression shall not be an lvalue.</strong></br></br></p>\n</blockquote>\n<p>Since, in this case, the type of the result of the conversion is being deduced by the compiler, it <em>will</em> be reference-related to type of the initializer. In this case, as the part I've emphasized says, the initializer expression can't be an lvalue.</p>\n<p>That leaves only the question of whether a string literal is an lvalue. At least offhand, I can't immediately find the section of the C++ standard that says they are (there's no mention of it in the section on string literals). If it's absent, the next step would be to look at the base document (the C standard) which clearly states that string literals are lvalues (N1570, \u00a76.5.1/4)</p>\n<blockquote>\n<p id=\"so_34160614_34162106_3\">A string literal is a primary expression. It is an lvalue with type as detailed in 6.4.5.</p>\n</blockquote>\n<p>I do wish I could find a direct statement to that effect in the C++ standard (I'm pretty sure it should exist), but for whatever reason I'm not finding it right now.</p>\n", "LastActivityDate": "2015-12-08T17:20:40.333", "CommentCount": "3", "CreationDate": "2015-12-08T17:20:40.333", "ParentId": "34160614", "Score": "4", "OwnerUserId": "179910"}, "bq_ids": {"n4140": {"so_34160614_34162106_1": {"length": 18, "quality": 0.9, "section_id": 3321}, "so_34160614_34163861_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 627}, "so_34160614_34162106_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 3321}, "so_34160614_34162106_0": {"length": 8, "quality": 1.0, "section_id": 3321}}, "n3337": {"so_34160614_34162106_1": {"length": 17, "quality": 0.85, "section_id": 3191}, "so_34160614_34163861_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 617}, "so_34160614_34162106_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 3191}, "so_34160614_34162106_0": {"length": 8, "quality": 1.0, "section_id": 3191}}, "n4659": {"so_34160614_34162106_1": {"length": 15, "quality": 0.75, "section_id": 4087}, "so_34160614_34163861_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 653}, "so_34160614_34162106_2": {"length": 14, "quality": 1.0, "section_id": 4087}, "so_34160614_34162106_3": {"length": 5, "quality": 0.625, "section_id": 7687}, "so_34160614_34162106_0": {"length": 8, "quality": 1.0, "section_id": 4087}}}, "34160614": {"ViewCount": "642", "Body": "<p>Given the following code:</p>\n<pre><code>#include &lt;string&gt;\nvoid foo()\n{\n  std::string s(std::move(\"\"));\n}\n</code></pre>\n<p>This compiles with apple clang (xcode 7) and does not with visual studio 2015 which generates the following error:</p>\n<pre><code>error C2440: 'return': cannot convert from 'const char [1]' to 'const char (&amp;&amp;)[1]'\nnote: You cannot bind an lvalue to an rvalue reference\nmain.cpp(4): note: see reference to function template instantiation 'const char (&amp;&amp;std::move&lt;const char(&amp;)[1]&gt;(_Ty) noexcept)[1]' being compiled\n    with\n    [\n        _Ty=const char (&amp;)[1]\n    ]\n</code></pre>\n<p>Ignoring for the moment that the move is redundant, which standard library implementation is the more correct in this case?</p>\n<p>My feeling is that the type of <code>\"\"</code> is <code>const char[1]</code> so <code>std::move</code> should return <code>std::remove_reference&lt;const char[1]&amp;&gt;::type&amp;&amp;</code> which would be <code>const char[1]&amp;&amp;</code>.</p>\n<p>It seems to me that this should decay to <code>const char*</code>.</p>\n<p>Or do I misunderstand the rules?</p>\n", "AcceptedAnswerId": "34163861", "Title": "std::move of string literal - which compiler is correct?", "CreationDate": "2015-12-08T16:09:47.733", "Id": "34160614", "CommentCount": "15", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-12-09T01:26:02.440", "LastEditorUserId": "1708801", "LastActivityDate": "2015-12-09T03:02:23.370", "Score": "25", "OwnerUserId": "2015579", "Tags": "<c++><visual-studio-2015><language-lawyer>", "AnswerCount": "2"}, "34163861": {"Id": "34163861", "PostTypeId": "2", "Body": "<p>This looks like a Visual Studio bug. This comes down to the <a href=\"http://en.cppreference.com/w/cpp/utility/move\" rel=\"nofollow noreferrer\">std::move</a> and if we look at the cppreference page it has the following signature:</p>\n<pre><code>template&lt; class T &gt;\ntypename std::remove_reference&lt;T&gt;::type&amp;&amp; move( T&amp;&amp; t );\n</code></pre>\n<p>and it returns:</p>\n<pre><code>static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t) \n</code></pre>\n<p>which matches the draft C++ standard section <code>20.2.4</code> forward/move helpers [forward]. </p>\n<p>Using the <a href=\"https://stackoverflow.com/a/16638081\">code I grabbed from here</a> we can see the following example:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nstruct value_category {\n    // Or can be an integral or enum value\n    static constexpr auto value = \"prvalue\";\n};\n\ntemplate&lt;typename T&gt;\nstruct value_category&lt;T&amp;&gt; {\n    static constexpr auto value = \"lvalue\";\n};\n\ntemplate&lt;typename T&gt;\nstruct value_category&lt;T&amp;&amp;&gt; {\n    static constexpr auto value = \"xvalue\";\n};\n\n// Double parens for ensuring we inspect an expression,\n// not an entity\n#define VALUE_CATEGORY(expr) value_category&lt;decltype((expr))&gt;::value\n\n\nint main()\n{   \n    std::cout &lt;&lt; VALUE_CATEGORY( static_cast&lt;std::remove_reference&lt;const char[1]&gt;::type&amp;&amp;&gt;(\"\") ) &lt;&lt; std::endl ;\n\n}\n</code></pre>\n<p>generates the following answer from gcc and clang using <a href=\"http://melpon.org/wandbox/permlink/4h1Ui1zmo5KmZBMp\" rel=\"nofollow noreferrer\">Wandbox</a>:</p>\n<pre><code>xvalue\n</code></pre>\n<p>and this answer from Visual Studio using <a href=\"http://webcompiler.cloudapp.net/\" rel=\"nofollow noreferrer\">webcompiler</a>:</p>\n<pre><code>lvalue\n</code></pre>\n<p>hence the error from Visual Studio for the original code:</p>\n<blockquote>\n<p id=\"so_34160614_34163861_0\">You cannot bind an lvalue to an rvalue reference</p>\n</blockquote>\n<p>when it attempt to bind the result of <code>static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t)</code> to <code>std::remove_reference&lt;T&gt;::type&amp;&amp;</code> which is the return value of <code>std::move</code>.</p>\n<p>I don't see any reason why the <code>static_cast</code> should generate an lvalue as it does in the Visual Studio case.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-12-09T03:02:23.370", "Score": "9", "CreationDate": "2015-12-08T19:00:14.563", "ParentId": "34160614", "CommentCount": "6", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T12:01:31.430"}});