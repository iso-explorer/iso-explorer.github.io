post_cb({"2675228": {"CommentCount": "0", "ViewCount": "802", "CreationDate": "2010-04-20T12:57:03.740", "LastActivityDate": "2010-04-20T13:25:56.130", "Title": "How to create pointer-to-mutable-member?", "AcceptedAnswerId": "2675229", "PostTypeId": "1", "Id": "2675228", "Score": "5", "Body": "<p>Consider the following code:</p>\n<pre><code>struct Foo\n{\n    mutable int m;\n\n    template&lt;int Foo::* member&gt; \n    void change_member() const {\n        this-&gt;*member = 12; // Error: you cannot assign to a variable that is const\n    }\n\n    void g() const {\n    change_member&lt;&amp;Foo::m&gt;();\n    }\n};\n</code></pre>\n<p>Compiler generates an error message. The thing is that the member <code>m</code> is mutable therefore it is allowed to change <code>m</code>. But the function signature hides mutable declaration.</p>\n<p>How to decalre pointer-to-mutable-member to compile this code?\nIf it is impossible please link to Standard C++.</p>\n", "Tags": "<c++><templates><const><mutable><pointer-to-member>", "OwnerUserId": "124161", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_2675228_2675229_0": {"section_id": 6132, "quality": 0.7586206896551724, "length": 22}}, "n3337": {"so_2675228_2675229_0": {"section_id": 5896, "quality": 0.7586206896551724, "length": 22}}, "n4659": {"so_2675228_2675229_0": {"section_id": 7629, "quality": 0.7586206896551724, "length": 22}}}, "2675229": {"ParentId": "2675228", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>This code is ill-formed according to C++ Standard 5.5/5:</p>\n<blockquote>\n<p id=\"so_2675228_2675229_0\">The restrictions on cv-qualification,\n  and the manner in which the\n  cv-qualifiers of the operands are\n  combined to produce the cv-qualifiers\n  of the result, are the same as the\n  rules for E1.E2 given in 5.2.5. [Note:\n  <strong>it is not possible to use a pointer to member that refers to a mutable\n  member to modify a const class\n  object.</strong>\n  For example,</p>\n<pre><code>struct S {\n  mutable int i;\n};\nconst S cs;\nint S::* pm = &amp;S::i; // pm refers to mutable member S::i\ncs.*pm = 88;         // ill-formed: cs is a const object\n</code></pre>\n<p id=\"so_2675228_2675229_1\">]</p>\n</blockquote>\n<p>You could use wrapper class to workaround this problem as follows:</p>\n<pre><code>template&lt;typename T&gt; struct mutable_wrapper { mutable T value; };\n\nstruct Foo\n{\n    mutable_wrapper&lt;int&gt; m;\n\n    template&lt;mutable_wrapper&lt;int&gt; Foo::* member&gt; \n    void change_member() const {\n        (this-&gt;*member).value = 12; // no error\n    }\n\n    void g() const {\n    change_member&lt;&amp;Foo::m&gt;();\n    }\n};\n</code></pre>\n<p>But I think you should consider redesign your code.</p>\n", "OwnerUserId": "123111", "LastEditorUserId": "123111", "LastEditDate": "2010-04-20T13:25:56.130", "Id": "2675229", "Score": "8", "CreationDate": "2010-04-20T12:57:49.993", "LastActivityDate": "2010-04-20T13:25:56.130"}});