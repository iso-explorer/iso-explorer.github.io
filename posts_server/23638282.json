post_cb({"23638529": {"ParentId": "23638282", "CommentCount": "0", "Body": "<p>The condition (if it's an expression) of an <code>if</code> statement is <em>contextually converted to <code>bool</code></em>:</p>\n<p>[stmt.select]/4 about the condition in selection statements (<code>if</code>, <code>switch</code>):</p>\n<blockquote>\n<p id=\"so_23638282_23638529_0\">The value of a condition that is an expression is the value of the\n  expression, contextually converted to <code>bool</code> for statements other than <code>switch</code>; if that conversion is ill-formed, the program is ill-formed.</p>\n</blockquote>\n<p><em>Contextual conversion to <code>bool</code></em> is defined as follows in [conv]/3:</p>\n<blockquote>\n<p id=\"so_23638282_23638529_1\">An expression <code>e</code> can be <em>implicitly converted</em> to a type <code>T</code> if and only if the declaration <code>T t=e;</code> is well-formed, for some invented temporary variable <code>t</code>. Certain language constructs require that an expression be\n  converted to a Boolean value. An expression <code>e</code> appearing in such a context is said to be contextually converted to <code>bool</code> and is well-formed if and only if the declaration <code>bool t(e);</code> is well-formed, for some invented temporary variable <code>t</code>.</p>\n</blockquote>\n<p>Here's the description of a conversion to <code>bool</code> for fundamental types [conv.bool]/1:</p>\n<blockquote>\n<p id=\"so_23638282_23638529_2\">A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a\n  prvalue of type <code>bool</code>. A zero value, null pointer value, or null member pointer value is converted to <code>false</code>;\n  any other value is converted to <code>true</code>. A prvalue of type <code>std::nullptr_t</code> can be converted to a prvalue of\n  type <code>bool</code>; the resulting value is <code>false</code>.</p>\n</blockquote>\n<p>So when we test a pointer <code>if(ptr)</code>, we compare <code>ptr</code> to the <em>null pointer value</em> of that type. What's a <em>null pointer value</em>? [conv.ptr]/1</p>\n<blockquote>\n<p id=\"so_23638282_23638529_3\">A <em>null pointer constant</em> is an integral constant expression prvalue of integer type that evaluates to\n  zero or a prvalue of type <code>std::nullptr_t</code>. A null pointer constant can be converted to a pointer type; the\n  result is the <em>null pointer value</em> of that type and is distinguishable from every other value of object pointer or\n  function pointer type. Such a conversion is called a <em>null pointer conversion</em>. Two null pointer values of the\n  same type shall compare equal.</p>\n</blockquote>\n<p>This also describes what happens when we compare <code>if(ptr != nullptr)</code>: The <code>nullptr</code> is converted to the type of <code>ptr</code> (see [expr.rel]/2), and yields the <em>null pointer value</em> of that type. Hence, the comparison is <em>equivalent</em> to <code>if(ptr)</code>.</p>\n", "OwnerUserId": "420683", "PostTypeId": "2", "Id": "23638529", "Score": "5", "CreationDate": "2014-05-13T18:07:11.310", "LastActivityDate": "2014-05-13T18:07:11.310"}, "23638420": {"ParentId": "23638282", "CommentCount": "0", "Body": "<p>Let's say you have:</p>\n<pre><code>int* ip = foo();\nif ( nullptr == ip )\n{\n}\n</code></pre>\n<p>It's as if you are saying:</p>\n<pre><code>int* ip = foo();\nif ( (int*)0 == ip )\n{\n}\n</code></pre>\n<p>At that point, you are comparing two pointers of the same type.</p>\n<p>This is what I found at <a href=\"http://en.cppreference.com/w/cpp/language/nullptr\" rel=\"nofollow\">cppreference.com</a></p>\n<blockquote>\n<p id=\"so_23638282_23638420_0\"><strong>Explanation</strong></p>\n<p id=\"so_23638282_23638420_1\">The keyword nullptr denotes the null pointer literal. It is an unspecified prvalue of type std::nullptr_t. There exist implicit conversions from nullptr to null pointer value of any pointer type and any pointer to member type. Similar conversions exist for any value of type std::nullptr_t as well as for the macro NULL, the null pointer constant.</p>\n</blockquote>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "23638420", "Score": "1", "CreationDate": "2014-05-13T17:59:01.763", "LastActivityDate": "2014-05-13T17:59:01.763"}, "23638282": {"CommentCount": "5", "ViewCount": "335", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-05-13T17:50:52.530", "LastActivityDate": "2014-05-22T20:10:43.157", "Title": "Check for null pointer in a truth-value context", "AcceptedAnswerId": "23638529", "LastEditDate": "2017-05-23T12:27:13.823", "Id": "23638282", "Score": "1", "Body": "<p>Lets say I have a pointer</p>\n<pre><code>MyType *ptr;\n</code></pre>\n<p>When checking the validity of that pointer in a <a href=\"https://stackoverflow.com/a/21713259/2567683\">\"truth-value context\"</a> by the old standards I would write something like this</p>\n<pre><code>if (ptr)    { ... // 1\nwhile (ptr) { ... // 2\n</code></pre>\n<p>The thing is that in such \"truth value contexes\" we expect for the implicit conversion of a pointer to a boolean value to take place, so we would be pretty much be comparing </p>\n<pre><code>if (NULL != ptr)    { ...\nwhile (NULL != ptr) { ...\n</code></pre>\n<p>Yet comparing against a macro for the integer <code>0</code> is deprecated and C++11 proposes comparing against <code>nullptr</code>. </p>\n<p>When in a truth value context though like (1) or (2) above where we don't explicitly say </p>\n<pre><code>if (nullptr != ptr) { ...\nwhile (nullptr != ptr) { ... \n</code></pre>\n<p><strong>what is our pointer compared against ?</strong> It's conversion to a boolean ? <strong>Do we have to explicitly compare against <code>nullptr</code> ?</strong></p>\n", "Tags": "<c++><pointers><c++11>", "OwnerUserId": "2567683", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_23638282_23638529_2": {"section_id": 44, "quality": 1.0, "length": 39}, "so_23638282_23638529_1": {"section_id": 3, "quality": 0.6571428571428571, "length": 23}, "so_23638282_23638529_3": {"section_id": 39, "quality": 0.8163265306122449, "length": 40}, "so_23638282_23638529_0": {"section_id": 3885, "quality": 0.875, "length": 14}}, "n3337": {"so_23638282_23638529_2": {"section_id": 41, "quality": 1.0, "length": 39}, "so_23638282_23638529_3": {"section_id": 36, "quality": 0.9387755102040817, "length": 46}, "so_23638282_23638529_1": {"section_id": 2, "quality": 0.9428571428571428, "length": 33}, "so_23638282_23638529_0": {"section_id": 3745, "quality": 0.875, "length": 14}}, "n4659": {"so_23638282_23638529_2": {"section_id": 45, "quality": 1.0, "length": 39}, "so_23638282_23638529_1": {"section_id": 3, "quality": 0.6571428571428571, "length": 23}, "so_23638282_23638529_0": {"section_id": 4764, "quality": 0.9375, "length": 15}, "so_23638282_23638529_3": {"section_id": 39, "quality": 0.8163265306122449, "length": 40}}}});