post_cb({"30032332": {"ViewCount": "146", "Body": "<p>This question is inspired by <a href=\"https://stackoverflow.com/questions/30030925/why-move-swap-impl-in-boostswap-to-a-separate-namespace\">this one</a>. Consider the code:</p>\n<pre><code>namespace ns {\n  template &lt;typename T&gt;\n  void swap(T&amp; a, T&amp; b) {\n    using namespace std;\n    swap(a, b);\n  }\n}\n</code></pre>\n<p>After some test with GCC, I found that <code>swap(a, b);</code> resolves to<br>\n1) <code>std::swap</code> if <code>T</code> has overloaded <code>std::swap</code> (e.g., standard container types)<br>\n2) <code>ns::swap</code> otherwise, leading to infinite recursion.<br>\nSo, it seems that the compiler will first try to find a match in the namespace <code>ns</code>. If a match is found, the search ends. But this is not the case when ADL comes in, in which case, <code>std::swap</code> is found anyway. The resolution process seems to be complicated.</br></br></br></p>\n<p>I want to know the details of what is going on under the hood in the process of resolving the function call <code>swap(a, b)</code> in the above context. Reference to the standard would be appreciated.</p>\n", "AcceptedAnswerId": "30033550", "Title": "Confusion around function call resolution", "CreationDate": "2015-05-04T14:12:51.160", "Id": "30032332", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:13:47.440", "LastEditorUserId": "-1", "LastActivityDate": "2015-05-04T17:34:41.230", "Score": "7", "OwnerUserId": "1348273", "Tags": "<c++><language-lawyer><function-calls><overload-resolution><argument-dependent-lookup>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_30032332_30033550_0": {"length": 28, "quality": 1.0, "section_id": 5510}, "so_30032332_30033553_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 5510}}, "n3337": {"so_30032332_30033550_0": {"length": 28, "quality": 1.0, "section_id": 5296}, "so_30032332_30033553_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 5296}}, "n4659": {"so_30032332_30033550_0": {"length": 28, "quality": 1.0, "section_id": 6945}, "so_30032332_30033553_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 6945}}}, "30033553": {"Id": "30033553", "PostTypeId": "2", "Body": "<p>The most important piece of the standard is 7.3.4/2 (quoting C++14 n4140, emphasis mine):</p>\n<blockquote>\n<p id=\"so_30032332_30033553_0\">A <em>using-directive</em> specifies that the names in the nominated namespace can be used in the scope in which the\n  <em>using-directive</em> appears after the <em>using-directive.</em> <strong>During unqualified name lookup (3.4.1), the names appear\n  as if they were declared in the nearest enclosing namespace which contains both the <em>using-directive</em> and the\n  nominated namespace.</strong></p>\n</blockquote>\n<p>The <em>using-directive</em> is located inside a function in <code>:: ns</code>, and nominates <code>:: std</code>. This means that for the purpose of unqualified name lookup, the effect of this <em>using-directive</em> is that names in <code>::std</code> behave as if they were declared in <code>::</code>. Particularly, <em>not</em> as if they were in <code>::ns</code>.</p>\n<p>Because the unqualified name lookup begins inside a function in <code>::ns</code>, it will search <code>::ns</code> before looking into <code>::</code>. And it finds <code>::ns::swap</code>, so it ends there, without examining <code>::</code>, where it would find <code>::std::swap</code> brought in by the <em>using-directive.</em></p>\n", "LastActivityDate": "2015-05-04T15:09:36.517", "Score": "2", "CreationDate": "2015-05-04T15:09:36.517", "ParentId": "30032332", "CommentCount": "0", "OwnerUserId": "1782465"}, "30033550": {"Id": "30033550", "PostTypeId": "2", "Body": "<p>The code in the OP is <em>equivalent</em> to this:</p>\n<pre><code>using std::swap; // only for name lookup inside ns::swap\n\nnamespace ns {\n  template &lt;typename T&gt;\n  void swap(T&amp; a, T&amp; b) {\n    swap(a, b);\n  }\n}\n</code></pre>\n<p>Why? Because <em>using-directives</em> like <code>using namespace std;</code> have a very peculiar behaviour C++14 [namespace.udir]p2:</p>\n<blockquote>\n<p id=\"so_30032332_30033550_0\">A <em>using-directive</em> specifies that the names in the nominated namespace\n  can be used in the scope in which the <em>using-directive</em> appears after\n  the <em>using-directive</em>. During unqualified name lookup, the names\n  appear as if they were declared in the nearest enclosing namespace\n  which contains both the <em>using-directive</em> and the nominated namespace.</p>\n</blockquote>\n<p>The nearest enclosing namespace that contains both namespace <code>std</code> and the block scope of function <code>ns::swap</code> is the global namespace.</p>\n<p><em>Using-declarations</em> such as <code>using std::swap;</code> on the other hand really introduce names into the scope in which they appear, not in some enclosing scope.</p>\n<hr>\n<p>The lookup of a function call expression such as <code>swap(a, b)</code> is called <em>unqualified lookup</em>. The identifier <code>swap</code> has not been qualified with any namespace or class name, as opposed to <code>ns::swap</code>, which has been qualified via <code>ns::</code>. Unqualified lookup for potential names of functions consists of two parts: pure unqualified lookup and argument-dependent lookup.</p>\n<p>Pure unqualified lookup stops at the nearest enclosing scope that contains the name. In the OP's example, as illustrated by the equivalent transformation shown above, the nearest scope that contains a declaration of the name <code>swap</code> is the namespace <code>ns</code>. The global scope will not be searched, <code>std::swap</code> will not be found via pure unqualified lookup.</p>\n<p>Argument-dependent lookup searches all scopes (here: only namespaces and classes) associated with the argument types. For class types, the namespace in which the class has been declared in is an associated scope. Types of the C++ Standard Library such as <code>std::vector&lt;int&gt;</code> are associated with namespace <code>std</code>, hence <code>std::swap</code> can be found via argument-dependent lookup for the expression <code>swap(a, b)</code> if <code>T</code> is a C++ Standard Library type. Similarly, your own class types allow finding a <code>swap</code> function in the namespaces they have been declared in:</p>\n<pre><code>namespace N2 {\n    class MyClass {};\n    void swap(MyClass&amp;, MyClass&amp;);\n}\n</code></pre>\n<p>Therefore, if argument-dependent lookup does not find a better match than pure unqualified lookup, you'll end up calling <code>ns::swap</code> recursively.</p>\n<hr>\n<p>The idea behind calling <code>swap</code> unqualified, that is, <code>swap(a, b)</code> instead of <code>std::swap(a, b)</code> is that functions found via argument-dependent lookup are assumed to be more specialized than <code>std::swap</code>. Specializing a function template such as <code>std::swap</code> for your own class template type is impossible (since partial function template specializations are forbidden), and you may not add custom overloads to namespace <code>std</code>. The generic version of <code>std::swap</code> is implemented typically as follows:</p>\n<pre><code>template&lt;typename T&gt;\nvoid swap(T&amp; a, T&amp; b)\n{\n    T tmp( move(a) );\n    a = move(b);\n    b = move(tmp);\n}\n</code></pre>\n<p>This requires a move-construction plus two move-assignments, which might even fall back to copies. Therefore, you can provide a <em>specialized swap function</em> for your own types in the namespaces associated with those types. Your specialized version can make use of certain properties of, or private access to, your own types.</p>\n</hr></hr>", "LastEditorUserId": "420683", "LastActivityDate": "2015-05-04T17:34:41.230", "Score": "6", "CreationDate": "2015-05-04T15:09:26.263", "ParentId": "30032332", "CommentCount": "4", "LastEditDate": "2015-05-04T17:34:41.230", "OwnerUserId": "420683"}});