post_cb({"28677593": {"CommentCount": "7", "AcceptedAnswerId": "28685181", "PostTypeId": "1", "LastEditorUserId": "3549027", "CreationDate": "2015-02-23T15:46:38.240", "LastActivityDate": "2015-02-24T11:10:26.880", "LastEditDate": "2015-02-23T22:14:18.990", "ViewCount": "283", "FavoriteCount": "1", "Title": "Does it violate the standard for a non-default-constuctible struct to lack a user-defined constructor?", "Id": "28677593", "Score": "6", "Body": "<p>It is possible to define a <code>struct</code> (a) that has no user-defined constructors, and (b) for which a default constructor cannot be generated. For example, <code>Foo</code> in the below:</p>\n<pre><code>struct Baz\n{\n   Baz(int) {}\n};\n\nstruct Foo\n{\n   int bar;\n   Baz baz;\n};\n</code></pre>\n<p>You can still create instances of <code>Foo</code> using aggregate initialization:</p>\n<pre><code>Foo foo = { 0, Baz(0) };\n</code></pre>\n<p>My normal compiler (VS2012) will grudgingly accept this, but it raises 2 warnings:</p>\n<blockquote>\n<p id=\"so_28677593_28677593_0\">warning C4510: 'Foo': default constructor could not be generated.</p>\n<p id=\"so_28677593_28677593_1\">warning C4610: struct 'Foo' can never be instantiated - user defined constructor required</p>\n</blockquote>\n<p>Of course, I've just proved warning #2 wrong--you can still instantiate it using aggregate initialization. The online compilers I've tried are happy enough to accept the above, so I'm guessing VS2012 is just being overly-aggressive with this warning. But I'd like to be sure--is this code ok, or does it technically violate some obscure part of the standard?</p>\n", "Tags": "<c++><visual-studio-2012><language-lawyer><default-constructor><aggregate-initialization>", "OwnerUserId": "3549027", "AnswerCount": "2"}, "28685181": {"ParentId": "28677593", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The standard explicitly allows cases like <code>Foo</code> in [12.1p4]:</p>\n<blockquote>\n<p id=\"so_28677593_28685181_0\">[...] If there is no user-declared constructor for\n  class X, a constructor having no parameters is implicitly declared as defaulted [...] A defaulted default constructor for class X is defined as\n  deleted if:</p>\n<p id=\"so_28677593_28685181_1\">[...]</p>\n<ul>\n<li>any potentially constructed subobject, except for a non-static data member with a brace-or-equal-initializer, has class type M (or array\n  thereof) and either <em>M has no default constructor</em> or overload\n  resolution (13.3) as applied to M\u2019s default constructor results in an\n  ambiguity or in a function that is deleted or inaccessible from the\n  defaulted default constructor</li>\n</ul>\n<p id=\"so_28677593_28685181_2\">[...]</p>\n</blockquote>\n<p><code>Baz</code> has no default constructor, so the emphasised part above applies (emphasis mine). </p>\n<p>There's nothing 'undefined' or 'ill-formed' about such cases. The implicitly declared default constructor is defined as deleted, that's all. You could do the same thing explicitly, and it would still be just as valid.</p>\n<p>The definition for aggregates is in [8.5.1p1]. For C++14, it is:</p>\n<blockquote>\n<p id=\"so_28677593_28685181_3\">An aggregate is an array or a class (Clause 9) with no user-provided\n  constructors (12.1), no private or protected non-static data members\n  (Clause 11), no base classes (Clause 10), and no virtual functions\n  (10.3).</p>\n</blockquote>\n<p>The 'no user-provided' part allows you to use <code>= delete</code> on all constructors that could possibly be implicitly declared (making them user-declared, but not user-provided) and the class would still be an aggregate, allowing you to use aggregate initialization on it.</p>\n<p>As for warning C4610, I've encountered it before myself and <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/866320/incorrect-warning-c4610\" rel=\"nofollow\">reported it</a>. As you can see, it's been fixed in the upcoming version of VC++.</p>\n<p>It may be worth mentioning that the example I used in the bug report is taken directly from the standard, where it's treated as well-formed ([12.2p5.4]:</p>\n<pre><code>struct S { int mi; const std::pair&lt;int,int&gt;&amp; mp; };\nS a { 1, {2,3} };\n</code></pre>\n<p>This is similar to your case, but here, the implicitly declared default constructor is defined as deleted because the class has a non-static member of reference type that has no initializer. </p>\n<p>Granted, it's only an example, but I think it's an additional indication that there's nothing wrong with these cases.</p>\n", "OwnerUserId": "4326278", "LastEditorUserId": "4326278", "LastEditDate": "2015-02-24T11:10:26.880", "Id": "28685181", "Score": "2", "CreationDate": "2015-02-23T22:55:45.317", "LastActivityDate": "2015-02-24T11:10:26.880"}, "28684696": {"ParentId": "28677593", "CommentCount": "1", "Body": "<p>That's not actually aggregate initialization, it's uniform, which is only recently supported by VS. This warning is simply them not correctly updating it to reflect that that type can now be uniform initialized.</p>\n<p>Aggregates may not have user-defined non-defaulted non-deleted constructors, and the rules for aggregate UDTs are that each member must also be an aggregate. Therefore, Baz is not an aggregate and as a direct result, neither can Foo be.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "28684696", "Score": "-1", "CreationDate": "2015-02-23T22:25:00.263", "LastActivityDate": "2015-02-23T22:25:00.263"}, "bq_ids": {"n4140": {"so_28677593_28685181_3": {"section_id": 3298, "quality": 0.8421052631578947, "length": 16}, "so_28677593_28685181_0": {"section_id": 369, "quality": 1.0, "length": 16}}, "n3337": {"so_28677593_28685181_3": {"section_id": 3168, "quality": 0.8421052631578947, "length": 16}, "so_28677593_28685181_0": {"section_id": 359, "quality": 1.0, "length": 16}}, "n4659": {"so_28677593_28685181_3": {"section_id": 4063, "quality": 0.631578947368421, "length": 12}, "so_28677593_28685181_0": {"section_id": 381, "quality": 0.75, "length": 12}}}});