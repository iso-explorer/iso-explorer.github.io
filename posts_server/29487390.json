post_cb({"bq_ids": {"n4140": {"so_29487390_29495759_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 3304}}, "n3337": {"so_29487390_29495759_0": {"length": 17, "quality": 0.7727272727272727, "section_id": 3174}}, "n4659": {"so_29487390_29495759_0": {"length": 16, "quality": 0.7272727272727273, "section_id": 4070}}}, "29495759": {"Id": "29495759", "PostTypeId": "2", "Body": "<p>This is a bug that essentially reduces to GCC complaining about not-explicitly-initialized <code>const</code> data members in aggregate initialization. E.g.</p>\n<pre><code>struct {const int i;} bar = {};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/b47f7fcb71c5925a\" rel=\"nofollow\">Fails</a> as there is no initializer-clause for <code>i</code> in <code>bar</code>'s initializer.  However, the standard specifies in <code>\u00a78.5.1/7</code> that</p>\n<blockquote>\n<p id=\"so_29487390_29495759_0\">If there are fewer <em>initializer-clauses</em> in the list than there are\n  members in the aggregate, then <strong>each member not explicitly initialized\n  shall be initialized</strong> from its <em>brace-or-equal-initializer</em> or, if there\n  is no <em>brace-or-equal-initializer</em>, <strong>from an empty initializer list\n  (8.5.4)</strong>.</p>\n</blockquote>\n<p>Thus the code initializes <code>i</code> (as if by <code>= {}</code>), and GCCs complaint is incorrect.  </p>\n<p>In fact, this bug has already been reported four years ago as <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=49132\" rel=\"nofollow\"><strong>#49132</strong></a>, and is fixed in GCC 5. </p>\n", "LastEditorUserId": "412482", "LastActivityDate": "2015-04-07T22:03:57.150", "Score": "3", "CreationDate": "2015-04-07T15:50:45.167", "ParentId": "29487390", "CommentCount": "0", "LastEditDate": "2015-04-07T22:03:57.150", "OwnerUserId": "3647361"}, "29487390": {"ViewCount": "391", "Body": "<p>I have the code:</p>\n<pre><code>struct A {\n    int a;\n};\n\nstruct B {\n    int b;\n    const A a[2];\n};\n\nstruct C {\n    int c;\n    const B b[2];\n};\n\nconst C test = {0, {}};\n\nint main()\n{\n    return test.c;\n}\n</code></pre>\n<p>I have gcc 4.8.2 and 4.9.2. It can be compiled just fine with:</p>\n<pre><code>g++-4.9 -Wall test.cpp -o test\ng++-4.8 -std=c++11 -Wall test.cpp -o test\ng++-4.8 -Wall test.cpp -o test\n</code></pre>\n<p>However, it can't be compiled with:</p>\n<pre><code>g++-4.9 -std=c++11 -Wall test.cpp -o test\n</code></pre>\n<p>And the compiler output is:</p>\n<pre><code>test.cpp:15:22: error: uninitialized const member \u2018B::a\u2019\n const C test = {0, {}};\n                      ^\ntest.cpp:15:22: error: uninitialized const member \u2018B::a\u2019\n</code></pre>\n<p>Is this a bug or I just don't understand something?</p>\n", "AcceptedAnswerId": "29495759", "Title": "gcc 4.9 bug in structures initialization?", "CreationDate": "2015-04-07T08:43:23.483", "Id": "29487390", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2015-04-07T22:03:57.150", "Score": "10", "OwnerUserId": "4757827", "Tags": "<c++><c++11><gcc><gcc4.9>", "AnswerCount": "1"}});