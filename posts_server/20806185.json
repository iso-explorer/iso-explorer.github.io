post_cb({"20806206": {"ParentId": "20806185", "PostTypeId": "2", "CommentCount": "4", "Body": "<p><strong>\u00a712.1/5 is perfectly valid</strong>: it's just saying that no default constructor can possibly be generated if all the members are <code>const</code>, because then there is no member that can be left uninitialised.</p>\n<p>\u00a79.1 says nothing about limiting <code>const</code>ness. It is a passage about limitations on accessing the union member's <em>values</em>, which is totally irrelevant.</p>\n<p>Only one member being \"active\" here means that only one can be written to and read from in arbitrary sequence. As soon as you write to another member, you may only read from that member.</p>\n<p>Here's an example, and a live demo showing that the example's <code>union</code> declaration is valid<sup>\u2020</sup>:</p>\n<pre><code>union T\n{\n    int x;\n    const int y;\n    const int z;\n};\n\nint main()\n{\n    T a{4};\n    a.x = 5;\n    a.y = 6;\n    a.z = 7;\n}\n\n// $ g++-4.8 -std=c++11 -Wall -pedantic -pthread main.cpp &amp;&amp; ./a.out\n// main.cpp: In function 'int main()':\n// main.cpp:14:9: error: assignment of read-only member 'T::y'\n//      a.y = 6;\n//          ^\n// main.cpp:15:9: error: assignment of read-only member 'T::z'\n//      a.z = 7;\n//          ^\n</code></pre>\n<h2><a href=\"http://coliru.stacked-crooked.com/a/348beda33c6b12f4\" rel=\"nofollow\">Live demo</a></h2>\n<p><sup><sup>\u2020</sup> Since compilation succeeds right up to the attempted assignment of <code>T::y</code>.</sup></p>\n<hr>\n<p><strong>Edit:</strong> The code you've now pasted, and the error message you're complaining about, have <em>nothing to do with the <code>const</code></em>.</p>\n<blockquote>\n<p id=\"so_20806185_20806206_0\">initializations for multiple members of \u2018U\u2019</p>\n</blockquote>\n<p>That is your problem. It says so right there! It makes no sense to try to initialise <em>both</em> members of a union, since only one may be \"active\" at any given time:</p>\n<blockquote>\n<p id=\"so_20806185_20806206_1\"><code>[C++11: 12.6.2/8]:</code> <em>[..]</em> An attempt to initialize more than one non-static data member of a union renders the program ill-formed. <em>[..]</em></p>\n</blockquote>\n<p>But this has nothing at all to do with <code>const</code>ness.</p>\n</hr>", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2013-12-27T19:28:01.127", "Id": "20806206", "Score": "10", "CreationDate": "2013-12-27T18:55:53.303", "LastActivityDate": "2013-12-27T19:28:01.127"}, "20806185": {"CommentCount": "0", "ViewCount": "255", "PostTypeId": "1", "LastEditorUserId": "718379", "CreationDate": "2013-12-27T18:53:44.757", "LastActivityDate": "2014-05-06T02:56:03.633", "Title": "4th bullet point in iso 12.1 p5 doesn't make sense to me", "LastEditDate": "2014-05-06T02:56:03.633", "Id": "20806185", "Score": "5", "Body": "<p>Maybe I'm missing something, but IMO the 4th bullet point in iso \u00a712.1 p5 is wrong:</p>\n<blockquote>\n<p id=\"so_20806185_20806185_0\">X is a union and all of its variant members are of const-qualified\n  type (or array thereof),</p>\n</blockquote>\n<p><s>simply because you can't have more than one const qualified member in a union.</s></p>\n<p>From \u00a79.1 we have:</p>\n<blockquote>\n<p id=\"so_20806185_20806185_1\">In a union, at most one of the non-static data members can be active\n  at any time, that is, the value of at most one of the non-static data\n  members can be stored in a union at any time.</p>\n</blockquote>\n<p><strong>Edit:</strong></p>\n<p>This snippet doesn't compile in <a href=\"http://ideone.com/Wmn4hx\" rel=\"nofollow\">Ideone</a></p>\n<pre><code>union U\n{\n    const int i;\n    const char c;\n    float x;\n    U(int j, char a) : i(j), c(a) {}\n};\n</code></pre>\n<p></p>\n<p><strong>Edit1:</strong></p>\n<p>The following code compiles in Coliru and <a href=\"http://ideone.com/eQkPtK\" rel=\"nofollow\">Ideone</a>. But according to 12.1 p5 4th bullet point, it shouldn't as the default constructor should be deleted.</p>\n<pre><code>#include &lt;iostream&gt;\nunion T\n{\n    const int y;\n    const int x;\n    const float z;\n    T(int j) : y(j) {}\n    T() = default;\n};\n\nint main()\n{\n    T t;\n}\n</code></pre>\n<p><strong>Edit2:</strong></p>\n<p>I also don't understand why the Standard disallows this code (see note in 9.5 p2)</p>\n<pre><code>struct S\n{\n    int i;\n    S() : i(1) {}\n};\n\nunion T\n{\n    S s;\n    char c;\n};\n\nint main()\n{\n    T t;\n}\n</code></pre>\n<p>but allows this. What's the difference?</p>\n<pre><code>struct S\n{\n    int i;\n    S() : i(1) {}\n};\n\nunion T\n{\n    S s;\n    char c;\n    T() {}\n};\n\nint main()\n{\n    T t;\n}\n</code></pre>\n", "Tags": "<c++><c++11><language-lawyer><unions>", "OwnerUserId": "2548699", "AnswerCount": "2"}, "20806432": {"ParentId": "20806185", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>\u00a79.1 says/does nothing to prevent you from having multiple <code>const</code> members in a <code>union</code>.</p>\n<p>Although it does a poor job of stating the limitation (at least IMO) all \u00a79.1 really says is that at any given time, only one field of a <code>union</code> contains a meaningful value--specifically, the field that was initialized when the <code>union</code> was created or the field to which a value was assigned the most recently.</p>\n<p>Now, it's certainly true that if all the members of the <code>union</code> are <code>const</code>, you won't be able to assign to any of them, so that latter provision becomes moot. That limits what you can do with such a union after it exists, but doesn't prevent you from creating such a union to start with.</p>\n<p>The effect of 12.1/5b4 is that if all the members of the <code>union</code> are <code>const</code>, you can't just define an instance of that union without specifying an initializer, either by explicitly defining a ctor, or else by specifying an initializer when you create the instance:</p>\n<pre><code>union X { \n    const int a;\n    const double b;\n};\n\nX x;   // won't compile\n\nX x(2); // no problem -- x.a == 2\n\nunion Y { \n   const int a;\n   const double b;\n\n   Y() : b(0.0) {}\n};\n\nY y;  // no problem: uses user defined ctor\n</code></pre>\n<p>The end result is that <code>const</code> gives roughly the same behavior applied to something inside a union as it does to things elsewhere--just for example, you can't define an object like:</p>\n<pre><code>const int x;\n</code></pre>\n<p>...either. You need to specify an initializer to create it:</p>\n<pre><code>const int x = 20;\n</code></pre>\n<p>The code you've added really <em>is</em> about \u00a79.1 though, not about 12.1/5 at all. Since only one member of the union can be active at any given time, it only makes sense to initialize one member. Attempting to initialize two members would imply that both those members could hold values, but in fact only one can hold a value at any one time.</p>\n<p>Edit: As to 12.1/5b4 applying only when <em>all</em> the members are const-qualified, I think that also makes sense. For example code like this:</p>\n<pre><code>union Z {\n    int a;\n    const double b;\n};\n\nZ z;\n\nz.a = 1;\n</code></pre>\n<p>Seems perfectly acceptable. Admittedly, since it hasn't been initialized, you can never actually <em>use</em> <code>Z.b</code> in this case, but that's more or less beside the point--there's still no particularly good reason for the compiler to prevent default construction.</p>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2013-12-27T19:33:22.673", "Id": "20806432", "Score": "7", "CreationDate": "2013-12-27T19:13:43.600", "LastActivityDate": "2013-12-27T19:33:22.673"}, "bq_ids": {"n4140": {"so_20806185_20806185_1": {"section_id": 5913, "quality": 1.0, "length": 19}, "so_20806185_20806185_0": {"section_id": 369, "quality": 1.0, "length": 9}, "so_20806185_20806206_1": {"section_id": 435, "quality": 0.8461538461538461, "length": 11}}, "n3337": {"so_20806185_20806185_1": {"section_id": 5685, "quality": 1.0, "length": 19}, "so_20806185_20806185_0": {"section_id": 359, "quality": 1.0, "length": 9}, "so_20806185_20806206_1": {"section_id": 427, "quality": 0.8461538461538461, "length": 11}}, "n4659": {"so_20806185_20806185_1": {"section_id": 7404, "quality": 1.0, "length": 19}, "so_20806185_20806185_0": {"section_id": 382, "quality": 1.0, "length": 9}, "so_20806185_20806206_1": {"section_id": 454, "quality": 0.8461538461538461, "length": 11}}}});