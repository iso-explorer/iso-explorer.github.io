post_cb({"bq_ids": {"n4140": {"so_34612344_34612550_0": {"section_id": 4698, "quality": 0.9090909090909091, "length": 10}, "so_34612344_34612550_1": {"section_id": 4692, "quality": 0.9183673469387755, "length": 45}, "so_34612344_34612453_0": {"section_id": 44, "quality": 0.5714285714285714, "length": 8}, "so_34612344_34612470_0": {"section_id": 7215, "quality": 0.8695652173913043, "length": 20}, "so_34612344_34612452_1": {"section_id": 44, "quality": 1.0, "length": 15}, "so_34612344_34612453_1": {"section_id": 1532, "quality": 0.5882352941176471, "length": 10}, "so_34612344_34612452_0": {"section_id": 4706, "quality": 0.875, "length": 7}}, "n3337": {"so_34612344_34612550_0": {"section_id": 4507, "quality": 0.9090909090909091, "length": 10}, "so_34612344_34612550_1": {"section_id": 4501, "quality": 0.9183673469387755, "length": 45}, "so_34612344_34612453_0": {"section_id": 41, "quality": 0.5714285714285714, "length": 8}, "so_34612344_34612452_1": {"section_id": 41, "quality": 1.0, "length": 15}, "so_34612344_34612453_1": {"section_id": 1526, "quality": 0.5882352941176471, "length": 10}, "so_34612344_34612470_0": {"section_id": 6959, "quality": 0.8695652173913043, "length": 20}}, "n4659": {"so_34612344_34612550_0": {"section_id": 6094, "quality": 0.8181818181818182, "length": 9}, "so_34612344_34612550_1": {"section_id": 6087, "quality": 0.8979591836734694, "length": 44}, "so_34612344_34612453_0": {"section_id": 45, "quality": 0.5714285714285714, "length": 8}, "so_34612344_34612452_0": {"section_id": 6103, "quality": 0.625, "length": 5}, "so_34612344_34612452_1": {"section_id": 45, "quality": 1.0, "length": 15}, "so_34612344_34612453_1": {"section_id": 1682, "quality": 0.5882352941176471, "length": 10}, "so_34612344_34612470_0": {"section_id": 8724, "quality": 0.8695652173913043, "length": 20}}}, "34612453": {"ParentId": "34612344", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Yes it is well defined and the result should be <code>std::is_unsigned&lt;bool&gt;::value == true</code></p>\n<p>The documentation for <a href=\"http://en.cppreference.com/w/cpp/types/is_signed\" rel=\"noreferrer\"><code>std::is_signed</code></a> says</p>\n<blockquote>\n<p id=\"so_34612344_34612453_0\"><strong>If <code>T</code> is a signed arithmetic type</strong>, provides the member constant value equal true. For any other type, value is false.</p>\n</blockquote>\n<p>So then if you look at <a href=\"http://en.cppreference.com/w/cpp/types/is_arithmetic\" rel=\"noreferrer\"><code>std::is_arithmetic</code></a></p>\n<blockquote>\n<p id=\"so_34612344_34612453_1\">If T is an arithmetic type (that is, <strong>an integral type or a floating-point type</strong>), provides the member constant value equal true. For any other type, value is false.</p>\n</blockquote>\n<p>Which finally leads to <a href=\"http://en.cppreference.com/w/cpp/types/is_integral\" rel=\"noreferrer\"><code>std::is_integral</code></a></p>\n<blockquote>\n<p id=\"so_34612344_34612453_2\">Checks whether T is an integral type. <strong>Provides the member constant value which is equal to true, if T is the type <code>bool</code></strong>, <code>char</code>, <code>char16_t</code>, <code>char32_t</code>, <code>wchar_t</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>long long</code>, or any implementation-defined extended integer types, including any signed, unsigned, and cv-qualified variants. Otherwise, value is equal to false.</p>\n</blockquote>\n<p>Interestingly, there is another function <a href=\"http://en.cppreference.com/w/cpp/types/numeric_limits/is_signed\" rel=\"noreferrer\"><code>std::numeric_limits::is_signed</code></a> that states</p>\n<blockquote>\n<p id=\"so_34612344_34612453_3\">The value of <code>std::numeric_limits&lt;T&gt;::is_signed</code> is <code>true</code> for all signed arithmetic types <code>T</code> and <code>false</code> for the unsigned types. This constant is meaningful for all specializations.</p>\n</blockquote>\n<p>Where the specialization for <code>bool</code> is listed as <code>false</code>, which also confirms that <code>bool</code> is considered unsigned.</p>\n", "OwnerUserId": "2296458", "LastEditorUserId": "2296458", "LastEditDate": "2016-01-05T13:53:08.090", "Id": "34612453", "Score": "9", "CreationDate": "2016-01-05T13:04:51.283", "LastActivityDate": "2016-01-05T13:53:08.090"}, "34612470": {"ParentId": "34612344", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>There is no concept of signedness for <code>bool</code>. From [basic.fundamental]/6:</p>\n<blockquote>\n<p id=\"so_34612344_34612470_0\">Values of type <code>bool</code> are either <code>true</code> of <code>false</code>. [<em>Note</em>: There are no <code>signed</code>, <code>unsigned</code>, <code>short</code>, or <code>long</code> <code>bool</code> types or values. \u2014 <em>end note</em>] Values of type <code>bool</code> participate in integral promotions (4.5).</p>\n</blockquote>\n<p>By contrast, signedness is explicitly called out for the <em>signed integer types</em> (paragraph 2) and <em>unsigned integer types</em> (paragraph 3).</p>\n<p>Now for the <code>is_signed</code> and <code>is_unsigned</code> traits. First off, the traits are always well-defined, but only interesting for arithmetic types. <code>bool</code> is an arithmetic type, and <code>is_signed&lt;T&gt;::value</code> is defined (see Table 49) as <code>T(-1) &lt; T(0)</code>. By using the rules of boolean conversion and standard arithmetic conversions, we see that this is is <code>false</code> for <code>T = bool</code> (because <code>bool(-1)</code> is <code>true</code>, which converts to <code>1</code>). Similarly, <code>is_unsigned&lt;T&gt;::value</code> is defined as <code>T(0) &lt; T(-1)</code>, which is <code>true</code> for <code>T = bool</code>.</p>\n", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2016-01-05T14:03:28.237", "Id": "34612470", "Score": "62", "CreationDate": "2016-01-05T13:05:56.243", "LastActivityDate": "2016-01-05T14:03:28.237"}, "34612550": {"ParentId": "34612344", "CommentCount": "0", "Body": "<p>Yes, it is well-defined, as is any other unary type trait.</p>\n<p>C++14 (n4140) 20.10.4/2 \"Unary type traits\" mandates:</p>\n<blockquote>\n<p id=\"so_34612344_34612550_0\">Each of these templates shall be a UnaryTypeTrait (20.10.1) with a BaseCharacteristic of <code>true_type</code> if the\n  corresponding condition is true, otherwise <code>false_type</code>.</p>\n</blockquote>\n<p>20.10.1/1:</p>\n<blockquote>\n<p id=\"so_34612344_34612550_1\">A <em>UnaryTypeTrait</em> describes a property of a type. It shall be a class template that takes one template type\n  argument and, optionally, additional arguments that help define the property being described. It shall be\n  <code>DefaultConstructible</code>, <code>CopyConstructible</code>, and publicly and unambiguously derived, directly or indirectly,\n  from its <em>BaseCharacteristic,</em> which is a specialization of the template <code>integral_constant</code> (20.10.3),\n  with the arguments to the template <code>integral_constant</code> determined by the requirements for the particular\n  property being described. The member names of the BaseCharacteristic shall not be hidden and shall be\n  unambiguously available in the UnaryTypeTrait.</p>\n</blockquote>\n<p>From this it follows that the construct <code>std::is_unsigned&lt;T&gt;::value</code> has to be well-defined for any type <code>T</code>, whether the concept of \"signedness\" makes sense for the type or not.</p>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "34612550", "Score": "10", "CreationDate": "2016-01-05T13:09:43.487", "LastActivityDate": "2016-01-05T13:09:43.487"}, "34612452": {"ParentId": "34612344", "PostTypeId": "2", "CommentCount": "10", "Body": "<p><code>is_unsigned</code> is defined in [meta.unary.comp]/2 as</p>\n<blockquote>\n<p id=\"so_34612344_34612452_0\">If <code>is_arithmetic&lt;T&gt;::value</code> is <code>true</code>, the same result as<br>\n<code>bool_constant&lt;T(0) &lt; T(-1)&gt;::value</code>; otherwise, <code>false</code></br></p>\n</blockquote>\n<p><code>bool</code><sup>\u2020</sup> is clearly an arithmetic type (being integral). Now consider [conv.bool]/1:</p>\n<blockquote>\n<p id=\"so_34612344_34612452_1\">A zero value, null pointer value, or null member pointer value is converted to <code>false</code>; any other value is converted to <code>true</code>.</p>\n</blockquote>\n<p>I.e. <code>bool(0) &lt; bool(-1)</code> is equivalent to <code>false &lt; true</code>, and the latter holds since the values are promoted to <code>0</code> and <code>1</code>, respectively.</p>\n<p>Thus <code>is_unsigned&lt;bool&gt;::value</code> is <code>true</code> (and, conversely, <code>is_signed</code> is <code>false</code>), due to the fact that <code>bool</code>ean values correspond to the unsigned values  <code>0</code> and <code>1</code> during arithmetic operations. However, it doesn't really make sense to assess <code>bool</code>'s signedness, much less perform <code>make_unsigned</code> on it, since it doesn't represent integers, but rather states.</p>\n<p><hr>\n<sup>\u2020</sup>: The fact that this template is applicable to <code>bool</code> in the first place is determined by its Requirement clause being non-existent, <code>bool</code> not being an incomplete type ([res.on.functions]/(2.5)) and no other requirements being mentioned in [meta.rqmts] for <em>UnaryTypeTraits</em>.</hr></p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2016-01-05T14:02:53.850", "Id": "34612452", "Score": "22", "CreationDate": "2016-01-05T13:04:49.203", "LastActivityDate": "2016-01-05T14:02:53.850"}, "34612344": {"CommentCount": "0", "AcceptedAnswerId": "34612470", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2016-01-05T12:59:27.967", "LastActivityDate": "2016-01-05T14:03:28.237", "LastEditDate": "2016-01-05T13:25:27.380", "ViewCount": "1813", "FavoriteCount": "1", "Title": "Is std::is_unsigned<bool>::value well defined?", "Id": "34612344", "Score": "55", "Body": "<p>I am wondering whether </p>\n<pre><code>std::is_unsigned&lt;bool&gt;::value\n</code></pre>\n<p>is well defined according to the standard or not? </p>\n<p>I ask the question because <code>typename std::make_unsigned&lt;bool&gt;::type</code> is not well defined.</p>\n", "Tags": "<c++><boolean><language-lawyer><c++14><unsigned>", "OwnerUserId": "882932", "AnswerCount": "4"}});