post_cb({"30154938": {"ParentId": "30154882", "CommentCount": "0", "Body": "<p>As said in one of the comments, it is undefined behavior to dereference an invalidated iterator. In your case it was probably still pointing to the space on the heap where the element used to be, and hasn't been overwritten by something else yet. On a different compiler, or a different run of the program it could have been jibbersish or crashed the program entirely.</p>\n", "OwnerUserId": "436025", "PostTypeId": "2", "Id": "30154938", "Score": "2", "CreationDate": "2015-05-10T18:14:53.627", "LastActivityDate": "2015-05-10T18:14:53.627"}, "30154999": {"ParentId": "30154882", "PostTypeId": "2", "CommentCount": "3", "Body": "<p><strong>N4431 - 23.3.5.5/15 list operations [list.ops]</strong> (emphasize mine)</p>\n<pre><code>void remove(const T&amp; value);\ntemplate &lt;class Predicate&gt; void remove_if(Predicate pred);\n</code></pre>\n<blockquote>\n<p id=\"so_30154882_30154999_0\">Effects: Erases all the elements in the list referred by a list iterator <code>i</code> for which the following conditions hold: <code>*i == value, pred(*i) != false</code>. <strong>Invalidates only the iterators and references to the erased elements</strong>.</p>\n</blockquote>\n<p>What you have is a typical manifestation of undefined behaviour and you should not rely on such code. </p>\n<p>What probably happens is something similar to this:</p>\n<pre><code>int* p = new int(42);\nint* iterator = p;\ndelete p;\n\n// may still display 42, since the memory may have not yet been reclaimed by the OS, \n// but it is Undefined Behaviour\nstd::cout &lt;&lt; *iterator; \n</code></pre>\n", "OwnerUserId": "3093378", "LastEditorUserId": "3093378", "LastEditDate": "2015-05-10T18:28:51.507", "Id": "30154999", "Score": "2", "CreationDate": "2015-05-10T18:19:12.673", "LastActivityDate": "2015-05-10T18:28:51.507"}, "30154882": {"CommentCount": "2", "ViewCount": "80", "PostTypeId": "1", "LastEditorUserId": "3163389", "CreationDate": "2015-05-10T18:09:52.563", "LastActivityDate": "2015-05-10T18:28:51.507", "Title": "C++11 forward_list iterator remains pointing to removed value", "AcceptedAnswerId": "30154999", "LastEditDate": "2015-05-10T18:25:38.737", "Id": "30154882", "Score": "-1", "Body": "<p>An iterator remains to point to the element it previously did and the value it points to is not removed from memory. I wonder how can this be explained? Thank you.</p>\n<pre><code>forward_list&lt;int&gt; Fwdl {46, 21, 88, 901, 404};\nauto it = Fwdl.begin();\n\nFwdl.remove(46);\n\ncout &lt;&lt; \"List : \"; for(int&amp; elem : Fwdl) cout &lt;&lt; \" \" &lt;&lt; elem; cout &lt;&lt; endl;\n\n//This prints \"List : 21 88 901 404\" as expected, but:\n\ncout &lt;&lt; \"Iterator is alive! \" &lt;&lt; *it &lt;&lt; endl;\n\n//This still prints \"Iterator is alive! 46\"\n</code></pre>\n", "Tags": "<c++><c++11><iterator><forward-list>", "OwnerUserId": "3163389", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_30154882_30154999_0": {"section_id": 937, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_30154882_30154999_0": {"section_id": 925, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_30154882_30154999_0": {"section_id": 998, "quality": 0.9473684210526315, "length": 18}}}});