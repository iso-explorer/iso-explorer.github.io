post_cb({"5592027": {"ViewCount": "1357", "Body": "<p>I'm trying to create a template function of the following sort:</p>\n<pre><code>template &lt;bool isHorizontal, float* kernel&gt;\n__global__ void smoothFilterColumns(const TwImageCUDA_Device* source, TwImageCUDA_Device* \ndestination)\n{\n// code...\n}\n</code></pre>\n<p>(Don't worry about the <code>__global__</code>; this is being implemented on CUDA.)</p>\n<p>Unfortunately, it won't allow me to create instances of this function like this:</p>\n<pre><code>float ptrKernel[] = {1, 2, 1};\nsmoothFilterColumns&lt;true, ptrKernel&gt;(dxBuffer-&gt;cuda_image, dxOutput-&gt;cuda_image);\n</code></pre>\n<p>I've tried all sorts of <code>float*</code>s and <code>float[]</code>s, with and without the <code>const</code> modifier. Is it even possible to create a template of this sort?</p>\n<p>Thanks in advance.</p>\n<p>NB. The kernel is being passed as a template parameter and not a normal function parameter because that allows me to create more efficient code in CUDA by unrolling loops.</p>\n<p><strong>Update</strong> Pointers to floats work as template parameters with standard C++, but apparently there's no way to get them to work with CUDA device functions, since they expect pointers to device addresses and one cannot define those externally. If anyone got that to work, please let me know.</p>\n", "AcceptedAnswerId": "5593747", "Title": "Passing arrays/pointers as template parameters", "CreationDate": "2011-04-08T07:43:42.520", "Id": "5592027", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-04-09T06:28:47.903", "LastEditorUserId": "1630", "LastActivityDate": "2011-04-09T08:22:28.450", "Score": "2", "OwnerUserId": "374253", "Tags": "<c++><arrays><templates><parameters><cuda>", "AnswerCount": "5"}, "5603407": {"PostTypeId": "2", "Body": "<p>Will this work in CUDA?</p>\n<pre><code>template &lt;bool isHorizontal, class Kernel&gt;\n__global__ void smoothFilterColumns(\n    const TwImageCUDA_Device* source, TwImageCUDA_Device* destination)\n{\n    const float *kernel = Kernel::ptr();\n    // code...\n}\n\nstruct Kernel_1_2_1\n{\n    static const float *ptr()\n    {\n        static const float kernel[] = {1, 2, 1};\n        return kernel;\n    }\n}\n\nsmoothFilterColumns&lt;true, Kernel_1_2_1&gt;(\n    dxBuffer-&gt;cuda_image, dxOutput-&gt;cuda_image);\n</code></pre>\n<p>You might be able to make kernel a data member of the <code>struct</code>.  And you might want to add a mechanism to pass the kernel size.</p>\n", "LastActivityDate": "2011-04-09T06:57:32.007", "Id": "5603407", "CommentCount": "0", "CreationDate": "2011-04-09T06:57:32.007", "ParentId": "5592027", "Score": "0", "OwnerUserId": "674683"}, "bq_ids": {"n4140": {"so_5592027_5592096_0": {"length": 5, "quality": 1.0, "section_id": 87}}, "n3337": {"so_5592027_5592096_0": {"length": 5, "quality": 1.0, "section_id": 82}}}, "5593747": {"PostTypeId": "2", "Body": "<p>I doubt you will get that to work. As others point out, the C++ standard says that any object or function passed as a template parameter must have external linkage (so not defined at the scope of the current translation unit). The problem is that CUDA doesn't current support external linkage at all - every symbol used in device code must have internal linkage (ie. defined within the same translation unit). The underlying reason for this restriction is that CUDA doesn't currently have a linker for device code.</p>\n", "LastActivityDate": "2011-04-08T10:30:40.950", "LastEditorUserId": "681865", "Id": "5593747", "CommentCount": "0", "CreationDate": "2011-04-08T10:23:55.530", "ParentId": "5592027", "Score": "3", "OwnerUserId": "681865", "LastEditDate": "2011-04-08T10:30:40.950"}, "5592185": {"PostTypeId": "2", "Body": "<p>I guess the <code>ptrKernel</code> variable you are passing as the template argument is a local variable. Anyway, there is a restriction on what you can pass as a non-type template argument. According to the C++ standard (14.3.2), the following are allowed:</p>\n<ul>\n<li>integral constant expression of integral or enumeration type</li>\n<li>name of a non-type template parameter</li>\n<li>name of an object or function with external linkage</li>\n<li>address of an object or function with external linkage</li>\n<li>pointer to member</li>\n</ul>\n<p>Make sure the <code>ptrKernel</code> variable meets these requirements (again, my guess is that it is not a variable with external linkage, i.e. global or static class member).</p>\n", "LastActivityDate": "2011-04-08T08:01:03.553", "Id": "5592185", "CommentCount": "0", "CreationDate": "2011-04-08T08:01:03.553", "ParentId": "5592027", "Score": "2", "OwnerUserId": "4158"}, "5592096": {"PostTypeId": "2", "Body": "<p>Please make sure <code>ptrKernel</code> has external linkage.</p>\n<pre><code>// static float ptrKernel[] = { ... };\n// ^ won't work.\n\n// const float ptrKernel[] = { ... };\n// ^ won't work.\n\nfloat ptrKernel[] = { ... };\n// ^ ok.\n\nvoid func() {\n   // float ptrKernel[] = { ... };\n   // ^ won't work (not global variable).\n   ...\n}\n</code></pre>\n<hr>\n<p>This is a restriction of non-type template, as described in \u00a7[temp.arg.nontype]/1:</p>\n<blockquote>\n<p id=\"so_5592027_5592096_0\">A <em>template-argument</em> for a non-type, non-template <em>template-parameter</em> shall be one of:</p>\n<ul>\n<li>an integral <em>constant-expression</em> of integral or enumeration type; or</li>\n<li>the name of a non-type <em>template-parameter</em>; or</li>\n<li>the name of an object or function <strong>with external linkage</strong>, including function templates and function <em>template-id</em>'s but excluding non-static class members, expressed as <em>id-expression</em>; or</li>\n<li>the address of an object or function <strong>with external linkage</strong>, including function templates and function <em>template-id</em>'s but excluding non-static class members, expressed as <code>&amp;</code> <em>id-expression</em> where the <code>&amp;</code> is optional if the name refers to a function or array; or</li>\n<li>a pointer to member expressed as described in 5.3.1 .</li>\n</ul>\n</blockquote>\n</hr>", "LastActivityDate": "2011-04-08T08:11:32.690", "LastEditorUserId": "224671", "Id": "5592096", "CommentCount": "6", "CreationDate": "2011-04-08T07:51:07.147", "ParentId": "5592027", "Score": "2", "OwnerUserId": "224671", "LastEditDate": "2011-04-08T08:11:32.690"}, "5603792": {"PostTypeId": "2", "Body": "<p>Is not gonna work. You are trying to pass a CPU-RAM pointer to a GPU-RAM kernel.</p>\n<p>You can do in different ways 1) is to embed all the constant values using multiple templates\ndepending on the different lengths of your kernels, or otherwise you\ncreate a functor class that handles the detail of the transformation that you want to apply:</p>\n<p>Here is a working example to let you understand. Don't forget the <strong>device</strong> specifier.</p>\n<pre><code>// with 3 int\ntemplate&lt;int amount, int k0,int k1, int k2&gt;\n__global__ void apply_kernel(const float *input, float *output){\n\n\n}\n\n// with four int\ntemplate&lt;int amount, int k0,int k1, int k2, int k3&gt;\n__global__ void apply_kernel(const float *input, float *output){\n\n\n}\n\n// with five int \ntemplate&lt;int amount, int k0,int k1, int k2, int k3, int k4&gt;\n__global__ void apply_kernel(const float *input, float *output){\n\n\n}\n\nclass KernelOperator {\npublic:\n      __host__ __device__ KernelOperator() {\n      }\n      __host__ __device__ int operator*(int value){\n            return value * 2;\n      }\n};\n\n\n// with KernelOperator\ntemplate&lt;class T&gt;\n__global__ void apply_kernel(const float *input, float *output){\n           T value;\n\n}\n\nint main(){\n    apply_kernel&lt;0, 1,2,1&gt;&lt;&lt;&lt;10, 20&gt;&gt;&gt;(NULL,NULL);\n\n    apply_kernel&lt; KernelOperator &gt;&lt;&lt;&lt;10, 20&gt;&gt;&gt;(NULL,NULL);\n}\n</code></pre>\n", "LastActivityDate": "2011-04-09T08:22:28.450", "Id": "5603792", "CommentCount": "0", "CreationDate": "2011-04-09T08:22:28.450", "ParentId": "5592027", "Score": "0", "OwnerUserId": "121687"}});