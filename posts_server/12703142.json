post_cb({"bq_ids": {"n4140": {"so_12703142_12703164_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 7023}, "so_12703142_12703164_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 6107}}, "n3337": {"so_12703142_12703164_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 6769}, "so_12703142_12703164_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 5873}}, "n4659": {"so_12703142_12703164_1": {"length": 25, "quality": 0.9615384615384616, "section_id": 8520}, "so_12703142_12703164_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 7604}}}, "12703164": {"Id": "12703164", "PostTypeId": "2", "Body": "<p>Your Base class destructor needs to be <code>virtual</code>, Since it is not this code invokes <strong>Undefined Behavior</strong>.     </p>\n<p>Reference:<br>\n<strong>C++03 standard: Section 5.3.5/3:</strong> </br></p>\n<blockquote>\n<p id=\"so_12703142_12703164_0\">If the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand\u2019s dynamic type and the static type shall have a virtual destructor or the behavior is undefined.</p>\n</blockquote>\n<hr>\n<p>When you call a virtual function through constructor/destructor the dynamic dispatch does not work as you expect it to.<br>\nThe type of <code>this</code> in constructor/destructor is of the type of the class who's constructor/destructor is being executed. While you expect the dynamic dispatch to call overidden derived class method <code>Derived::vfunc()</code>, it ends up in a call to <code>Base::vfunc()</code> which does not have a definition and hence results in <strong>Undefined Behavior</strong>.</br></p>\n<p>Reference:<br>\n<strong>C++03 Standard 10.4/6:</strong> </br></p>\n<blockquote>\n<p id=\"so_12703142_12703164_1\">\"Member functions can be called from a constructor (or destructor) of an abstract class; the effect of making a virtual call (10.3) to a pure virtual function directly or indirectly for the object being created (or destroyed) from such a constructor (or destructor) is undefined.\"</p>\n</blockquote>\n</hr>", "LastEditorUserId": "452307", "LastActivityDate": "2012-10-03T06:56:39.423", "Score": "4", "CreationDate": "2012-10-03T06:43:14.130", "ParentId": "12703142", "CommentCount": "2", "LastEditDate": "2012-10-03T06:56:39.423", "OwnerUserId": "452307"}, "12703224": {"Id": "12703224", "PostTypeId": "2", "Body": "<p>This happens because in your code <code>vfunc</code> can be invoked while <code>Base::Base()</code> isn't finished yet or <code>Base::~Base()</code> already started. Both of these cases will invoke undefined behavior, usually manifested as \"pure virtual call\" error.\nReason for it being an error is that the \"virtual\" mechanism doesn't kick in until after the constructor of most derived object's class started running, and the \"virtual\" mechanism is no longer in effect after the destructor of most derived object's class finished running. So when you make a call to a virtual function while a constructor or destructor is executing on the object, the corresponding function of the class of which the constructor or destructor is executing will be called. And if that function happens to be pure virtual, the behavior is undefined.</p>\n<p>ISO/IEC 14882:2003, 10.4/6:\n<em>Member functions can be called from a constructor (or destructor) of an abstract class; the effect of making\na virtual call (10.3) to a pure virtual function directly or indirectly for the object being created (or\ndestroyed) from such a constructor (or destructor) is undefined.</em></p>\n", "LastEditorUserId": "182529", "LastActivityDate": "2012-10-03T06:54:42.043", "Score": "2", "CreationDate": "2012-10-03T06:47:32.543", "ParentId": "12703142", "CommentCount": "0", "LastEditDate": "2012-10-03T06:54:42.043", "OwnerUserId": "182529"}, "12703142": {"ViewCount": "164", "Body": "<p>{ using Visual Studio 2010 , Win7 }</p>\n<pre><code>class Base\n{\n    public:\n        Base() : terminateCondition(false)\n        {\n            //spawn new thread and set entry point to newThreadFunc()\n        }\n\n        virtual ~Base() // edited to say it's virtual.\n        {\n            terminateCondition=true;\n            //wait for thread to join\n        }\n\n        virtual void vfunc() = 0;\n\n        static void __stdcall newThreadFunc(void *args)\n        {\n            while(!terminateCondition)\n                pThis-&gt;vfunc();\n        }\n\n        volatile bool terminateCondition;\n};\n\nclass Derived : public Base\n{\n    public:\n        virtual void vfunc()\n        {\n            //Do Something\n        }\n};\n\nDerived* dPtr=new Derived; //now assume pThis is dptr\n//later somewhere\ndelete dPtr;\n</code></pre>\n<p>This code crashes saying <code>pure virtual called</code>. Moving <code>terminateCondition=true</code> to the destructor of <code>Derived</code> prevents this crash. I think i partially get why. Destruction is in reverse order of construction so d'tor of <code>Derived</code> is executed 1st and all functionalities of <code>Derived</code> are destroyed before calling upon the d'tor of <code>Base</code>. In the meantime if <code>pThis-&gt;vfunc()</code> is encountered the application would crash. It crashes saying <strong>pure virtual called</strong>. I could not understand this part. Can someone please explain?</p>\n", "AcceptedAnswerId": "12703164", "Title": "c++ : Crash Saying \"Pure virtual called\"", "CreationDate": "2012-10-03T06:41:29.800", "Id": "12703142", "CommentCount": "5", "LastEditDate": "2012-10-03T06:47:03.303", "PostTypeId": "1", "LastEditorUserId": "1060004", "LastActivityDate": "2012-10-03T06:56:39.423", "Score": "1", "OwnerUserId": "1060004", "Tags": "<visual-c++>", "AnswerCount": "2"}});