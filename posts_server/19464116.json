post_cb({"19464116": {"CommentCount": "1", "ViewCount": "121", "CreationDate": "2013-10-19T08:35:12.907", "LastActivityDate": "2013-10-19T09:09:09.113", "Title": "It is possible to overload function by const specifier?", "AcceptedAnswerId": "19464360", "PostTypeId": "1", "Id": "19464116", "Score": "1", "Body": "<p>whether it is possible to overload function by const specifier. That is, we have two functions, one constant the other is not, can we say that the constant function overloaded non-const function ?</p>\n", "Tags": "<c++><function><const><overloading>", "OwnerUserId": "1886376", "AnswerCount": "2"}, "19464146": {"ParentId": "19464116", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Yes and No.</p>\n<p>It depends on where you put the <code>const</code> specifier.</p>\n<p>When defining member functions, this is possible (Yes-part):</p>\n<pre><code>int f() { /*code*/ }         //invoke this function on non-const object\nint f() const { /*code*/ }   //ok : invoke this function on const object\n</code></pre>\n<p>Note that in the absence of the <em>first</em> function, even non-const object will invoke the second function (i.e <code>const</code> member function) and in the absence of the <em>second</em> function, you wouldn't be able to invoke the first function on <code>const</code> objects!</p>\n<p>But this is <strong>not</strong> possible (No-part):</p>\n<pre><code>int g() { /*code*/ }\nconst int g() { /*code*/ } //error: redefinition \n</code></pre>\n<p>irrespective of whether they're member functions or free functions.</p>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2013-10-19T08:44:52.057", "Id": "19464146", "Score": "4", "CreationDate": "2013-10-19T08:39:45.540", "LastActivityDate": "2013-10-19T08:44:52.057"}, "bq_ids": {"n4140": {"so_19464116_19464360_2": {"section_id": 558, "quality": 1.0, "length": 14}, "so_19464116_19464360_0": {"section_id": 557, "quality": 1.0, "length": 7}, "so_19464116_19464360_1": {"section_id": 558, "quality": 1.0, "length": 9}}, "n3337": {"so_19464116_19464360_2": {"section_id": 549, "quality": 1.0, "length": 14}, "so_19464116_19464360_0": {"section_id": 548, "quality": 1.0, "length": 7}, "so_19464116_19464360_1": {"section_id": 549, "quality": 1.0, "length": 9}}, "n4659": {"so_19464116_19464360_2": {"section_id": 581, "quality": 1.0, "length": 14}, "so_19464116_19464360_0": {"section_id": 580, "quality": 1.0, "length": 7}, "so_19464116_19464360_1": {"section_id": 581, "quality": 1.0, "length": 9}}}, "19464360": {"ParentId": "19464116", "CommentCount": "2", "Body": "<p>Per \u00a7 13.1 / 2:</p>\n<p>It's not possible to put <code>const</code> in return-type to overload:</p>\n<blockquote>\n<p id=\"so_19464116_19464360_0\">Function declarations that differ only in the return type cannot be\n  overloaded.</p>\n</blockquote>\n<pre><code>int func();\nconst int func(); // Error\n</code></pre>\n<p>\u00a0</p>\n<p>It's not possible to put <code>const</code> in parameter-list to overload:</p>\n<blockquote>\n<p id=\"so_19464116_19464360_1\">Parameter declarations that differ only in the presence or absence of\n  const and/or volatile are equivalent.</p>\n</blockquote>\n<pre><code>void func(int x);\nvoid func(const int x); // Error\n</code></pre>\n<p>\u00a0</p>\n<p>BUT, it's possible:</p>\n<blockquote>\n<p id=\"so_19464116_19464360_2\">const and volatile type-specifiers buried within a parameter type\n  specification are significant and can be used to distinguish\n  overloaded function declarations.</p>\n</blockquote>\n<pre><code>void func(int &amp;x);\nvoid func(const int &amp;x); // OK\n</code></pre>\n<p>\u00a0</p>\n<p>And, it's possible to put <code>const</code> at end of method declaration to distinguish overloads:</p>\n<pre><code>int func();\nint func() const; // OK\n</code></pre>\n", "OwnerUserId": "952747", "PostTypeId": "2", "Id": "19464360", "Score": "1", "CreationDate": "2013-10-19T09:09:09.113", "LastActivityDate": "2013-10-19T09:09:09.113"}});