post_cb({"47415915": {"ParentId": "47415476", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>This is what the standard says should happen, but this is far from obvious. For quick readers, jump to the \"How to fix it?\" at the end.</p>\n<h2>Understanding why the <code>const</code> matters</h2>\n<p>Once you add the <code>const</code> qualifier, when you call <code>UseMe</code> with an instance of <code>LibIntf</code>, the compiler have the two following possibilities:</p>\n<ol>\n<li><code>LibIntf</code> \u2192<sup>1</sup> <code>LibIntf</code> \u2192<sup>2</sup> <code>void**</code> \u2192<sup>3</sup> <code>void*</code> (through <code>operator void**()</code>)</li>\n<li><code>LibIntf</code> \u2192<sup>3</sup> <code>const LibIntf</code> \u2192<sup>2</sup> <code>void*</code> \u2192<sup>1</sup> <code>void*</code> (through <code>operator void* const()</code>)</li>\n</ol>\n<p><sup>1)</sup> No conversion needed.<br>\n<sup>2)</sup> User-defined conversion operator.<br>\n<sup>3)</sup> Legal conversions.</br></br></p>\n<p>Those two conversion paths are legal, so which one to choose?<br>\nThe standard defining C++ answers:</br></p>\n<blockquote>\n<h3><a href=\"http://eel.is/c++draft/over.match.best\" rel=\"nofollow noreferrer\"><code>[over.match.best]/1</code></a></h3>\n<p id=\"so_47415476_47415915_0\">Define <code>ICSi(F)</code> as follows: </p>\n<ul>\n<li>[...]  </li>\n<li>let <code>ICSi(F)</code> denote the implicit conversion sequence that converts the <code>i</code>th argument in the list to the type of the <code>i</code>th parameter of viable function F. <a href=\"http://eel.is/c++draft/over.best.ics\" rel=\"nofollow noreferrer\"><code>[over.best.ics]</code></a> defines the implicit conversion sequences and <a href=\"http://eel.is/c++draft/over.ics.rank\" rel=\"nofollow noreferrer\"><code>[over.ics.rank]</code></a> defines what it means for one implicit conversion sequence to be a better conversion sequence or worse conversion sequence than another.</li>\n</ul>\n<p id=\"so_47415476_47415915_1\">Given these definitions, a viable function <code>F1</code> is defined to be a\n  better function than another viable function <code>F2</code> if for all arguments\n  <code>i</code>, <code>ICSi(F1)</code> is not a worse conversion sequence than <code>ICSi(F2)</code>, and then</p>\n<ul>\n<li><p id=\"so_47415476_47415915_2\">for some argument <code>j</code>, <code>ICSj(F1)</code> is a better conversion sequence than <code>ICSj(F2)</code>, or, if not that,</p></li>\n<li><p id=\"so_47415476_47415915_3\">the context is an initialization by user-defined conversion (see <a href=\"http://eel.is/c++draft/dcl.init\" rel=\"nofollow noreferrer\"><code>[dcl.init]</code></a>, <a href=\"http://eel.is/c++draft/over.match.conv\" rel=\"nofollow noreferrer\"><code>[over.match.conv]</code></a>, and <a href=\"http://eel.is/c++draft/over.match.ref\" rel=\"nofollow noreferrer\"><code>[over.match.ref]</code></a>) and the standard conversion sequence from the return type of <code>F1</code> to the destination type (i.e., the type of the entity being initialized) is a better conversion sequence than the standard conversion sequence from the return type of <code>F2</code> to the destination type.</p></li>\n</ul>\n</blockquote>\n<p>(I had to read it a couple times before getting it.)</p>\n<p>This all means <em>in your specific case</em> than option #1 is <em>better</em> than option #2 because for user-defined conversion operators, the conversion of the return type (<code>void**</code> to <code>void*</code> in option #1) is considered <strong>after</strong> the conversion of the parameter type (<code>LibIntf</code> to <code>const LibIntf</code> in option #2).</p>\n<p>In chain, this means in option #1 there is nothing to convert (latter in the conversion chain, there will but this is not yet considered) but in option #2 a conversion from <code>non-const</code> to <code>const</code> is needed. Option #1 is, thus, dubbed <em>better</em>.</p>\n<h2>How to fix it?</h2>\n<p>Simply remove the need to consider the <code>non-const</code> to <code>const</code> <em>conversion</em> by <em>casting</em> the variable to <code>const</code> (explicitly (casts are always explicit (or are called conversions))):</p>\n<pre><code>struct LibIntf\n{\n    LibIntf() : opaquePtr{nullptr} {}\n\n    operator void *()  const { return opaquePtr;  }     \n    operator void **()       { return &amp;opaquePtr; }\n\n    void *opaquePtr;\n};\n\nint UseMe(void *ptr)\n{\n    if (ptr == (void *)0x100)\n        return 1;\n    return 0;\n}\n\nvoid CreateMe(void **ptr)\n{\n    *ptr = (void *)0x100;\n}\n\nint main()\n{\n    LibIntf lib;\n    CreateMe(lib);\n\n    // unfortunately, you cannot const_cast an instance, only refs &amp; ptrs\n    return UseMe(static_cast&lt;const LibIntf&gt;(lib));\n}\n</code></pre>\n", "OwnerUserId": "5470596", "LastEditorUserId": "5470596", "LastEditDate": "2017-11-22T14:21:10.860", "Id": "47415915", "Score": "6", "CreationDate": "2017-11-21T14:47:56.983", "LastActivityDate": "2017-11-22T14:21:10.860"}, "47415476": {"CommentCount": "7", "ViewCount": "122", "PostTypeId": "1", "ClosedDate": "2017-11-21T15:04:38.263", "LastEditorUserId": "5470596", "CreationDate": "2017-11-21T14:25:29.100", "LastActivityDate": "2017-11-22T14:21:10.860", "Title": "Change member function to const silently breaks code", "AcceptedAnswerId": "47415915", "LastEditDate": "2017-11-21T14:53:13.457", "Id": "47415476", "Score": "3", "Body": "<p>I'm writing a interface to a 3rd party library. It manipulates objects through a C interface which essentially is a <code>void*</code>. Here is the code simplified:</p>\n<pre><code>struct LibIntf\n{\n    LibIntf() : opaquePtr{nullptr} {}\n\n    operator void *()  /* const */ { return opaquePtr;  }     \n    operator void **()             { return &amp;opaquePtr; }\n\n    void *opaquePtr;\n};\n\nint UseMe(void *ptr)\n{\n    if (ptr == (void *)0x100)\n        return 1;\n    return 0;\n}\n\nvoid CreateMe(void **ptr)\n{\n    *ptr = (void *)0x100;\n}\n\nint main()\n{\n    LibIntf lib;\n\n    CreateMe(lib);\n    return UseMe(lib);\n}\n</code></pre>\n<p>Everything works great until I add the <code>const</code> on the <code>operator void *()</code> line. The code then defaults silently to using the <code>operator void **()</code> breaking the code.</p>\n<p>My question is why?</p>\n<p>I'm returning a pointer through a function that doesn't modify the object. Should be able to mark it <code>const</code>. If that changes it to a <code>const</code> pointer, the compiler should error because <code>operator void **()</code> shouldn't be a good match for function <code>CallMe()</code> that just want a <code>void *</code>.</p>\n", "Tags": "<c++>", "OwnerUserId": "5741753", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_47415476_47415915_2": {"section_id": 603, "quality": 0.75, "length": 6}, "so_47415476_47415915_1": {"section_id": 603, "quality": 0.85, "length": 17}, "so_47415476_47415915_3": {"section_id": 603, "quality": 0.8928571428571429, "length": 25}}, "n3337": {"so_47415476_47415915_2": {"section_id": 593, "quality": 0.75, "length": 6}, "so_47415476_47415915_1": {"section_id": 593, "quality": 0.85, "length": 17}, "so_47415476_47415915_3": {"section_id": 593, "quality": 0.8928571428571429, "length": 25}}, "n4659": {"so_47415476_47415915_2": {"section_id": 629, "quality": 0.75, "length": 6}, "so_47415476_47415915_1": {"section_id": 629, "quality": 0.85, "length": 17}, "so_47415476_47415915_3": {"section_id": 629, "quality": 0.8928571428571429, "length": 25}}}});