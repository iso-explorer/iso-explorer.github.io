post_cb({"43977496": {"Id": "43977496", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_43971298_43977496_0\">Why a function is not an object? How does it differ?</p>\n</blockquote>\n<p>To understand this, let's move from bottom to top in terms of abstractions involved. So, you have your <em>address space</em> through which you can define the state of the memory and <strong>we have to remember that fundamentally it's all about this state you operate on.</strong> </p>\n<p>Okay, let's move a bit higher in terms of abstractions. I am not taking about any abstractions imposed by a programming language yet (<em>like object, array, etc.</em>) but simply as a layman I want to keep a record of a portion of the memory, lets call it <strong><code>Ab1</code></strong> and another one called <strong><code>Ab2</code></strong>. </p>\n<p>Both have a state fundamentally but I intend to manipulate/make use of the state <em>differently</em>.</p>\n<h2>Differently...Why and How?</h2>\n<p>Why ?</p>\n<p>Because of my requirements (to perform addition of 2 numbers and store the result back, for example). I will be using use <code>Ab1</code> as a long usage state and <code>Ab2</code> as relatively shorter usage state. So, I will create a state for <code>Ab1</code>(<em>with the 2 numbers to add</em>) and then use this state to populate some of state of <code>Ab2</code>(<em>copy them temporarily</em>) and perform further manipulation of <code>Ab2</code>(<em>add them</em>) and save a portion of resultant <code>Ab2</code> to <code>Ab1</code>(<em>the added result</em>). Post that <code>Ab2</code> becomes useless and we <strong>reset</strong> its state.</p>\n<p>How?</p>\n<p>I am going to need some management of both the portions to keep track of what words to pick from <code>Ab1</code> and copy to <code>Ab2</code> and so on. At this point I realize that I can make it work to perform some simple operations but something serious shall require a laid out specification for managing this memory. </p>\n<p>So, I look for such management specification and it turns out there exists a variety of these specifications (<em>with some having built-in memory model, others provide flexibility to manage the memory yourself</em>) with a better design. In-fact because they(<em>without even dictating how to manage the memory directly</em>) have successfully defined the encapsulation for this long lived storage and rules for how and when this can be created and destroyed. </p>\n<p>The same goes for <code>Ab2</code> but the way they present it makes me feel like this is much different from <code>Ab1</code>. And indeed, it turns out to be. They use a stack for state manipulation of <code>Ab2</code> and reserve memory from heap for <code>Ab1</code>. <code>Ab2</code> dies after a while.(after finished executing).</p>\n<p>Also, the way you define what to do with <code>Ab2</code> is done through yet another storage portion called <code>Ab2_Code</code> and specification for <code>Ab1</code> involves similarly <code>Ab1_Code</code></p>\n<p>I would say, this is fantastic! I get so much convenience that allows me to solve so many problems.</p>\n<p>Now, I am still looking from a layman's perspective so I don't feel surprised really having gone through the thought process of it all but if you question things top-down, things can get a bit difficult to put into perspective.(<em>I suspect that's what happened in your case</em>)</p>\n<p>BTW, I forgot to mention that <code>Ab1</code> is called an <em>object</em> officially and <code>Ab2</code> a <em>function stack</em> while <code>Ab1_Code</code> is the <em>class definition</em> and <code>Ab2_Code</code> is the <em>function definition</em> code.</p>\n<p>And it is because of these differences imposed by the PL, you find that they are so different.(<em>your question</em>)</p>\n<p><strong>Note:</strong> Don't take my representation of <code>Ab1</code>/<code>Object</code> as a long storage abstraction as a rule or a concrete thing - it was from layman perspective. The programming language provides much more flexibility in terms of managing lifecycle of an object. So, object may be deployed like <code>Ab1</code> but it can be much more.</p>\n<blockquote>\n<p id=\"so_43971298_43977496_1\">And does this have any relation with the functors (function objects)?</p>\n</blockquote>\n<p>Note that the first part answer is valid for many programming languages in general(including C++), this part has to do specifically with C++ (whose spec you quoted). So you have pointer to a function, you can have a pointer to an object too. Its just another programming construct that C++ defines. Notice that this is about having a <strong>pointer</strong> to the <code>Ab1</code>, <code>Ab2</code> to manipulate them rather than having another distinct abstraction to act upon.</p>\n<p>You can read about its definition, usage here:</p>\n<p><a href=\"https://stackoverflow.com/questions/356950/c-functors-and-their-uses\">C++ Functors - and their uses</a> </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-05-15T21:06:24.150", "Score": "5", "CreationDate": "2017-05-15T10:45:23.203", "ParentId": "43971298", "CommentCount": "3", "OwnerUserId": "2378217", "LastEditDate": "2017-05-23T12:26:27.260"}, "bq_ids": {"n4140": {"so_43971298_43971298_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 5790}}, "n3337": {"so_43971298_43971298_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 5563}}, "n4659": {"so_43971298_43971298_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 7247}, "so_43971298_43977496_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 8732}}}, "43971475": {"Id": "43971475", "PostTypeId": "2", "Body": "<p>A lot of the difference comes down to pointers and addressing. In C++\u00b9 pointers to functions and pointers to objects are strictly separate kinds of things.</p>\n<p>C++ requires that you can convert a pointer to any object type into a pointer to <code>void</code>, then convert it back to the original type, and the result will be equal to the pointer you started with\u00b2. In other words, regardless of exactly how they do it, the implementation has to ensure that a conversion from pointer-to-object-type to pointer-to-void is lossless, so no matter what the original was, whatever information it contained can be recreated so you can get back the same pointer as you started with by conversion from <code>T*</code> to <code>void *</code> and back to <code>T*</code>.</p>\n<p>That's <em>not</em> true with a pointer to a function though--if you take a pointer to a function, convert it to <code>void *</code>, and then convert it back to a pointer to a function, you may <em>lose</em> some information in the process. You might not get back the original pointer, and dereferencing what you do get back gives you undefined behavior (in short, don't do that).</p>\n<p>For what it's worth, you <em>can</em>, however, convert a pointer to one function to a pointer to a different type of function, then convert that result back to the original type, and you're guaranteed that the result is the same as you started with.</p>\n<p>Although it's not particularly relevant to the discussion at hand, there are a few other differences that may be worth noting. For example, you can copy most objects--but you can't copy <em>any</em> functions.</p>\n<p>As far as relationship to function objects goes: well, there really isn't much of one beyond one point: a function object supports <em>syntax</em> that looks like a function call--but it's still an object, not a function. So, a pointer to a function object is still a pointer to an object. If, for example, you convert one to <code>void *</code>, then convert it back to the original type, you're still guaranteed that you get back the original pointer value (which wouldn't be true with a pointer to a function).</p>\n<p>As to <em>why</em> pointers to functions are (at least potentially) different from pointers to objects: part of it comes down to existing systems. For example, on MS-DOS (among others) there were four entirely separate memory models: small, medium, compact, and large. Small model used 16 bit addressing for either functions or data. Medium used 16 bit addresses for data, and 20-bit addresses for code. Compact reversed that (16 bit addresses for code, 20-bit addresses for data). Large used 20-bit addresses for both code and data. So, in either compact or medium model, converting between pointers to code and pointers to functions really could and did lead to problems.</p>\n<p>More recently, a fair number of DSPs have used entirely separate memory buses for code and for data and (like with MS-DOS memory models) they were often different widths, converting between the two could and did lose information.</p>\n<hr>\n<ol>\n<li>These particular rules came to C++ from C, so the same is true in C, for whatever that's worth.</li>\n<li>Although it's not directly required, with the way things work, pretty much the same works out to be true for a conversion from the original type to a pointer to <code>char</code> and back, for whatever that's worth.</li>\n</ol>\n</hr>", "LastEditorUserId": "3853", "LastActivityDate": "2017-05-15T17:08:10.733", "Score": "43", "CreationDate": "2017-05-15T04:15:22.987", "ParentId": "43971298", "CommentCount": "9", "OwnerUserId": "179910", "LastEditDate": "2017-05-15T17:08:10.733"}, "43987427": {"Id": "43987427", "PostTypeId": "2", "Body": "<p>Let me answer the question in simpler language (terms).</p>\n<h2>What does a function contain?</h2>\n<p>It basically contains instructions to do something. While executing the instructions, the function can temporarily store and / or use some data - and might return some data.</p>\n<p>Although the instructions are stored somewhere - those instructions themselves are not considered as objects.</p>\n<h2>Then, what are the objects?</h2>\n<p>Generally, objects are entities which contain data - which get manipulated / changed / updated by functions (the instructions).</p>\n<h2>Why the difference?</h2>\n<p>Because computers are designed in such way that the instructions do not depend on the data.</p>\n<p>To understand this, let's think about a calculator. We do different mathematical operations using a calculator. Say, if we want to add some numbers, we provide the numbers to the calculator. No matter what the numbers are, the calculator will add them in the same way following the same instructions (if the result exceeds the calculator's capacity to store, it will show an error - but that is because of calculator's limitation to store the result (the data), not because of its instructions for addition).</p>\n<p>Computers are designed in the similar manner. That is why when you use a library function (for example <code>qsort()</code>) on some data which are compatible with the function, you get the same result as you expect - and the functionality of the function doesn't change if the data changes - because the instructions of the function remains unchanged.</p>\n<h2>Relation between function and functors</h2>\n<p>Functions are set of instructions; and while they are being executed, some temporary data can be required to store. In other words, some objects might be temporarily created while executing the function. These temporary objects are functors.</p>\n", "LastActivityDate": "2017-05-15T19:31:44.920", "CommentCount": "0", "CreationDate": "2017-05-15T19:31:44.920", "ParentId": "43971298", "Score": "0", "OwnerUserId": "5456631"}, "43971298": {"ViewCount": "3391", "Body": "<p>I read in the standards n4296 (Draft) \u00a7 1.8 page 7:</p>\n<blockquote>\n<p id=\"so_43971298_43971298_0\">An <strong>object</strong> is a region of storage. [ Note: A function <strong>is not</strong> an object,\n  regardless of whether or not it occupies storage in the way that\n  objects do. \u2014end note ]</p>\n</blockquote>\n<p>I spent some days on the net looking for a good reason for such exclusion, with no luck. Maybe because I do not fully understand objects. So:</p>\n<ol>\n<li>Why is a function not an object? How does it differ?</li>\n<li>And does this have any relation with the functors (function objects)?</li>\n</ol>\n", "AcceptedAnswerId": "43971475", "Title": "Why is a function not an object?", "CreationDate": "2017-05-15T03:49:19.450", "Id": "43971298", "CommentCount": "2", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2017-05-15T17:47:34.470", "LastEditorUserId": "6204556", "LastActivityDate": "2017-05-15T21:06:24.150", "Score": "34", "OwnerUserId": "6204556", "Tags": "<c++><function><object><functor>", "AnswerCount": "3"}});