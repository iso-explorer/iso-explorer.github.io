post_cb({"bq_ids": {"n4140": {"so_33107787_33108109_1": {"length": 16, "quality": 0.8421052631578947, "section_id": 91}, "so_33107787_33108109_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 91}, "so_33107787_33108109_0": {"length": 26, "quality": 0.5652173913043478, "section_id": 40}}, "n3337": {"so_33107787_33108109_1": {"length": 16, "quality": 0.8421052631578947, "section_id": 86}, "so_33107787_33108109_0": {"length": 42, "quality": 0.9130434782608695, "section_id": 37}, "so_33107787_33108109_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 86}}}, "33107988": {"PostTypeId": "2", "Body": "<p>I can't quote you the chapter and verse off the top of my head (edits are welcome), but what you are trying to do is not allowed in c++.</p>\n<p>Template parameters must be known at compile time. Pointers are only resolved at link time unless:</p>\n<ol>\n<li><p>they are defaulted using <code>= nullptr</code> in the template argument list.</p></li>\n<li><p>they are member function pointers (which <em>are</em> known at compile time since they are merely offsets).</p></li>\n</ol>\n<p>for example, this will compile:</p>\n<pre><code>template&lt;void * = nullptr&gt;\nclass X {\n    // ...\n};\n\nint r;\n\nint main()\n{\n    X&lt;nullptr&gt; x;\n\n    return 0;\n}\n</code></pre>\n", "LastActivityDate": "2015-10-13T16:48:21.913", "LastEditorUserId": "2015579", "Id": "33107988", "CommentCount": "1", "CreationDate": "2015-10-13T16:32:15.790", "ParentId": "33107787", "Score": "0", "OwnerUserId": "2015579", "LastEditDate": "2015-10-13T16:48:21.913"}, "33107787": {"ViewCount": "677", "Body": "<p>The following does not compile:</p>\n<pre><code>template&lt;void *p&gt;\nclass X {\n// ...\n};\n\nint r;\n\nint main()\n{\n    X&lt;&amp;r&gt; x;\n\n    return 0;\n}\n</code></pre>\n<p>The error message is</p>\n<blockquote>\n<p id=\"so_33107787_33107787_0\">x.cc:10:6: error: could not convert template argument \u2018&amp; r\u2019 to \u2018void*\u2019</p>\n</blockquote>\n<p>Explicitly casting &amp;r to (void *) doesn't help either. The error message becomes:</p>\n<blockquote>\n<p id=\"so_33107787_33107787_1\">x.cc:10:14: error: could not convert template argument \u2018(void*)(&amp; r)\u2019 to \u2018void*\u2019</p>\n</blockquote>\n<p>Which part of the standard specifies that behaviour?\nThe GCC version is <strong>gcc version 5.2.1 20151003 (Ubuntu 5.2.1-21ubuntu2)</strong></p>\n<p><strong>Edit:</strong></p>\n<p>Please note that using e.g. int * instead of void * works as expected.</p>\n<p><strong>Edit: (answering myself)</strong></p>\n<p>It does <strong>not</strong> work with <strong>gcc HEAD 6.0.0 20151016 (experimental)</strong> when specifying -std=c++1z, neither with implicit nor with explicit casting to \"void *\".</p>\n<p>It <strong>does</strong> work with <strong>clang HEAD 3.8.0 (trunk 250513)</strong> and has been since (at least) <strong>clang 3.6.0 (tags/RELEASE_360/final)</strong> when specifying --std=c++1z and explicitly casting to *void *\".\nWithout the explicit cast, clang complains as follows:</p>\n<blockquote>\n<p id=\"so_33107787_33107787_2\">x.cc:10:7: error: conversion from 'int *' to 'void *' is not allowed in a converted constant expression</p>\n</blockquote>\n<p>Responsible for fixing this bug in the c++ language specification is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4268.html\" rel=\"noreferrer\">N4268</a> which clang already implements.</p>\n", "Title": "Void pointer as template argument in C++", "CreationDate": "2015-10-13T16:21:40.507", "LastActivityDate": "2015-10-17T01:28:35.120", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-10-17T00:03:26.697", "LastEditorUserId": "423031", "Id": "33107787", "Score": "10", "OwnerUserId": "423031", "Tags": "<c++><templates><gcc><standards><void>", "AnswerCount": "2"}, "33108109": {"PostTypeId": "2", "Body": "<p>Normally, there is a conversion allowed for any pointer to <code>void*</code>. </p>\n<blockquote>\n<p id=\"so_33107787_33108109_0\">[C++11, 4.10/2] A prvalue of type \u201cpointer to cv T,\u201d where T is an\n  object type, can be converted to a prvalue of type \u201cpointer to cv\n  void\u201d. The result of converting a \u201cpointer to cv T\u201d to a \u201cpointer to\n  cv void\u201d points to the start of the storage location where the object\n  of type T resides, as if the object is a most derived object (1.8) of\n  type T (that is, not a base class subobject). The null pointer value\n  is converted to the null pointer value of the destination type.</p>\n</blockquote>\n<p>However, for non-type template arguments, certain conversions are specified:</p>\n<blockquote>\n<p id=\"so_33107787_33108109_1\">[C++11, 14.3.2/5] The following conversions are performed on each\n  expression used as a non-type template-argument. If a non-type\n  template-argument cannot be converted to the type of the corresponding\n  template-parameter then the program is ill-formed.</p>\n<p id=\"so_33107787_33108109_2\">[...]</p>\n<p id=\"so_33107787_33108109_3\">\u2014 for a non-type template-parameter of type pointer to object,\n  qualification conversions (4.4) and the array-to-pointer conversion\n  (4.2) are applied; if the template-argument is of type std::nullptr_t,\n  the null pointer conversion (4.10) is applied. [...]</p>\n</blockquote>\n<p>By omission, we can reason this conversion is simply not allowed.</p>\n", "LastActivityDate": "2015-10-13T16:40:04.337", "Id": "33108109", "CommentCount": "1", "CreationDate": "2015-10-13T16:40:04.337", "ParentId": "33107787", "Score": "1", "OwnerUserId": "5441780"}});