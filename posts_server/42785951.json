post_cb({"bq_ids": {"n4140": {"so_42785951_42786540_1": {"length": 34, "quality": 0.9714285714285714, "section_id": 7153}}, "n3337": {"so_42785951_42786540_1": {"length": 34, "quality": 0.9714285714285714, "section_id": 6897}}, "n4659": {"so_42785951_42786540_1": {"length": 23, "quality": 0.6571428571428571, "section_id": 8657}}}, "42786540": {"Id": "42786540", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_42785951_42786540_0\">was it a very bad intension to design an application in c++ using self registering techniques?</p>\n</blockquote>\n<p>I am afraid I have to answer \"yes\" to this one. C++ explicitly allows non-local variables to be initialised after <code>main</code> has started; the only constraint is that they must be initialised before any code from the file which defines them is executed. Quoting C++14 (N4140) [basic.start.init] 3.6.3/4:</p>\n<blockquote>\n<p id=\"so_42785951_42786540_1\">It is implementation-defined whether the dynamic initialization of a non-local variable with static storage\n  duration is done before the first statement of <code>main</code>. If the initialization is deferred to some point in time\n  after the first statement of <code>main</code>, it shall occur before the first odr-use (3.2) of any function or variable\n  defined in the same translation unit as the variable to be initialized.</p>\n</blockquote>\n<p>In other words, it is possible that a global variable defined in a file, whose initialisation does some registration, will not be initialised (and thus registered) until some other code from that file is called.</p>\n", "LastActivityDate": "2017-03-14T12:50:55.103", "CommentCount": "0", "CreationDate": "2017-03-14T12:50:55.103", "ParentId": "42785951", "Score": "2", "OwnerUserId": "1782465"}, "42785951": {"ViewCount": "304", "Body": "<p>My project uses self registering classes in two ways: the one is to implement factory pattern, which allows to iterate map of this classes, the implementation is almost completely similar to the one described in <a href=\"https://stackoverflow.com/q/23360196/4376963\">C++ how safe are self registering classes?</a>; and the other is to separate huge switch statement into map of objects. In the latter case I have just created one base class and a set of derived classes, then I instantiated each of derived classes with static object in the source file, while constructors of classes register themself in a map.</p>\n<p>Now I'm trying to move the logic part of my app into static library and use this library in two subprojects (I use Qt, Qt Creator and gcc). After doing so, none of the above-described classes are work unless I do an exlicitly instantiation of such classes somewhere.</p>\n<p>So, I'm looking for any workarounds. Actually, another question is arising: was it a very bad intension to design an application in c++ using self registering techniques?</p>\n<p>EDIT: I was asked to give an example. Here is simplified code:</p>\n<pre><code>// Class for storing actions\nclass ActionBase;\nclass SomeObject;    \nclass ActionMap\n{\n    public:\n    ActionMap();\n    static void registerAction(int n, ActionBase* action) {}\n    void performAction (SomeObject* object, int action) {\n         m_actions[action]-&gt;perform(object);\n    }\n\n private:\n     std::map&lt;int, ActionBase*&gt; m_actions;\n};\n\n// Action class - action.h\n#include \"actionmap.h\"\nclass SomeObject;\nclass ActionBase\n{\npublic:\n     ActionBase(int n, ActionBase* action) {ActionMap::registerAction(n, action); }\n     virtual ~ActionBase() = 0;\n     virtual void perform(SomeObject* object) = 0;\n };\n\n template&lt;int N&gt;\n class Action : public ActionBase\n {\n public:\n    Action() : ActionBase(N, this) {}\n };\n\n template&lt;&gt;\n class Action&lt;1&gt; : public ActionBase\n {\n public:\n     Action() : ActionBase(1, this) {}\n     void perform(SomeObject* object)\n     {\n      // Do something\n     }\n };\n</code></pre>\n<p>Now I can create some action object in actions source file, something like:</p>\n<pre><code>// action.cpp\n// #include \"action.h\"\nstatic Action&lt;1&gt; action1;\n</code></pre>\n<p>After restructuring project, I have to create action1 variable somewhere in my subproject explicitly to be enable to use it, for example in the main.cpp.</p>\n<p>Update: it seems that Angew helped me to partially solve the second problem. I have decleared a free empty function and defined it in action.cpp. Calling it somewhere in the app forces initialization of action objects.</p>\n", "Title": "Alternative to self registering classes", "CreationDate": "2017-03-14T12:24:41.203", "LastActivityDate": "2017-03-14T21:58:04.493", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:25:21.270", "LastEditorUserId": "-1", "Id": "42785951", "Score": "1", "OwnerUserId": "4376963", "Tags": "<c++>", "AnswerCount": "1"}});