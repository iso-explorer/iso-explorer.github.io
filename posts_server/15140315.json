post_cb({"bq_ids": {"n4140": {"so_15140315_15140821_1": {"length": 67, "quality": 0.9305555555555556, "section_id": 291}}, "n3337": {"so_15140315_15140821_1": {"length": 67, "quality": 0.9305555555555556, "section_id": 282}}, "n4659": {"so_15140315_15140821_1": {"length": 67, "quality": 0.9305555555555556, "section_id": 298}}}, "15140821": {"Id": "15140821", "PostTypeId": "2", "Body": "<p><strong>Q1:</strong></p>\n<blockquote>\n<p id=\"so_15140315_15140821_0\">Am I mistaken, or is this a new twist of c++11, or is gcc misbehaving?</p>\n</blockquote>\n<p>No, this is normal behavior. From Paragraph 14.8.1/8 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15140315_15140821_1\">For simple function names, argument dependent lookup (3.4.2) applies even when the function name\n  is not visible within the scope of the call. This is because the call still has the syntactic form of a function\n  call (3.4.1). <strong>But when a function template with explicit template arguments is used, the call does not have\n  the correct syntactic form unless there is a function template with that name visible at the point of the call</strong>.\n  If no such name is visible, the call is not syntactically well-formed and argument-dependent lookup does not\n  apply. If some such name is visible, argument dependent lookup applies and additional function templates\n  may be found in other namespaces. [ Example:</p>\n</blockquote>\n<pre><code>namespace A {\n    struct B { };\n    template&lt;int X&gt; void f(B);\n}\nnamespace C {\n    template&lt;class T&gt; void f(T t);\n}\nvoid g(A::B b) {\n    f&lt;3&gt;(b); // ill-formed: not a function call\n    A::f&lt;3&gt;(b); // well-formed\n    C::f&lt;3&gt;(b); // ill-formed; argument dependent lookup\n    // applies only to unqualified names\n    using C::f;\n    f&lt;3&gt;(b); // well-formed because C::f is visible; then\n    // A::f is found by argument dependent lookup\n}\n</code></pre>\n<blockquote>\n<p id=\"so_15140315_15140821_2\">\u2014end example ]</p>\n</blockquote>\n<hr>\n<p><strong>Q2:</strong> </p>\n<blockquote>\n<p id=\"so_15140315_15140821_3\">This looks to me like a compiler error, as neither with or without using directive can I call test::foo. Or perhaps I there is something about C++ that I missed?</p>\n</blockquote>\n<p>If your class becomes a class <em>template</em> which you never instantiate, then the compiler will never perform the second-phase name lookup which would occur when instantiating <code>A&lt;&gt;</code>, so it will it never find out that there are two <code>friend</code> functions declared in it.</p>\n<p>If you introduced, for instance, an explicit instantiation of your template <em>before</em> the <code>using</code> declarations, you should see things changing:</p>\n<pre><code>template class test::A&lt;int&gt;;\n</code></pre>\n<p>Alternatively, you could just change the definition of <code>A</code> so that it only <em>declares</em>, and doesn't define, the two <code>friend</code> function templates, and provide an out-of-class definition for those function templates. Which is, I guess, what you actually tried to do. But...</p>\n<p><strong>Q3:</strong></p>\n<blockquote>\n<p id=\"so_15140315_15140821_4\">gcc again complains, this time claiming that void test::foo(const test::A&amp;, F) is used but never defined... So what's wrong?</p>\n</blockquote>\n<p>The problem is that you are not declaring as friend the same function that you are later defining: notice, that the function you defined takes one additional argument (<code>T</code>). Fix your declaration, and you'll see the program compile:</p>\n<pre><code>namespace test \n{\n    template&lt;typename T&gt;\n    class A : std::vector&lt;int&gt;\n    {\n        template&lt;int K, typename C, typename F&gt;\n        //              ^^^^^^^^^^  (can't use T here, it would shadow\n        //                           the class's template parameter)\n        friend void foo(A&lt;C&gt; const&amp;a, F f);\n    };\n\n    template&lt;int K, typename C, typename F&gt;\n    void foo(A&lt;C&gt; const&amp;a, F f) \n    { for(auto i:a) if(i&amp;K) f(i); }\n}\n\nusing test::foo; // Just don't remove this, or we will be back in Q1 ;-)\n</code></pre>\n<hr>\n<p><strong>CONCLUSION:</strong></p>\n<p>Thus, after all the necessary modifications, this is how your program will look like:</p>\n<pre><code>#include &lt;vector&gt;\n\nnamespace test\n{\n    template&lt;typename T&gt;\n    class A : std::vector&lt;T&gt;\n    {\n        template&lt;typename F, typename C&gt;\n        friend void bar(A&lt;C&gt; const&amp;a, F f);\n\n        template&lt;int K, typename F, typename C&gt;\n        friend void foo(A&lt;C&gt; const&amp;a, F f);\n    };\n\n    template&lt;typename F, typename C&gt;\n    void bar(A&lt;C&gt; const&amp;a, F f) { for(auto i:a) f(i); }\n\n    template&lt;int K, typename F, typename C&gt;\n    void foo(A&lt;C&gt; const&amp;a, F f) { for(auto i:a) if(i&amp;K) f(i); }\n}\n\nusing test::foo;\nusing test::bar;\n\nint sum(test::A&lt;int&gt; const&amp; a)\n{\n    int s=0;\n    foo&lt;2&gt;(a,[&amp;s](int i) { s+=i; } );\n    bar   (a,[&amp;s](int i) { s+=i; } );\n\n    return s;\n}\n</code></pre>\n</hr></hr>", "LastEditorUserId": "1932150", "LastActivityDate": "2013-02-28T17:39:51.193", "Score": "3", "CreationDate": "2013-02-28T16:37:28.537", "ParentId": "15140315", "CommentCount": "4", "OwnerUserId": "1932150", "LastEditDate": "2013-02-28T17:39:51.193"}, "15140315": {"ViewCount": "239", "Body": "<p>I ran into what to me looks like an inconsistency of the c++ compiler. In the following example code</p>\n<pre><code>#include &lt;vector&gt;\nnamespace test {\n  class A : std::vector&lt;int&gt;\n  {\n    template&lt;typename F&gt;\n    friend void bar(A const&amp;a, F f) { for(auto i:a) f(i); }\n    template&lt;int K, typename F&gt;\n    friend void foo(A const&amp;a, F f) { for(auto i:a) if(i&amp;K) f(i); }\n  };\n}\nint sum(test::A const&amp;a)\n{\n  int s=0;\n  foo&lt;2&gt;(a,[&amp;s](int i) { s+=i; } );    // &lt;-- error here\n  bar   (a,[&amp;s](int i) { s+=i; } );    // &lt;-- but not here\n  return s;\n}\n</code></pre>\n<p>gcc (4.7.0, using std=c++11) complains about \"<code>foo</code> was not declared in this scope\" (and suggests <code>test::foo</code> as alternative), but happily compiles the usage of <code>bar</code> in the next line. Now both, <code>foo</code> and <code>bar</code> are injected into the namespace <code>test</code> via their <code>friend</code> declaration, so neither should really be present in the global namespace.</p>\n<p><strong>Q1</strong> Am I mistaken, or is this a new twist of c++11, or is gcc misbehaving?</p>\n<p>Of course, the problem is avoided if I simply inject using directives into the global namespace. However, if I make <code>A</code> a template,</p>\n<pre><code>#include &lt;vector&gt;\nnamespace test {\n  template&lt;typename T&gt;\n  class A : std::vector&lt;T&gt;\n  {\n    template&lt;typename F&gt;\n    friend void bar(A const&amp;a, F f) { for(auto i:a) f(i); }\n    template&lt;int K, typename F&gt;\n    friend void foo(A const&amp;a, F f) { for(auto i:a) if(i&amp;K) f(i); }\n  };\n}\nusing test::foo;          // does not avoid compilation error\nusing test::bar;          // does not avoid compilation error\nint sum(test::A&lt;int&gt; const&amp;a)\n{\n  int s=0;\n  foo&lt;2&gt;(a,[&amp;s](int i) { s+=i; } );\n  bar   (a,[&amp;s](int i) { s+=i; } );\n  return s;\n}\n</code></pre>\n<p>gcc complains again. Either (without the <code>using</code> directives) that \"<code>foo</code> was not declared in this scope\" (but again happily compiles <code>bar</code>, though does not suggest <code>test::foo</code>) or (with the <code>using</code> directive) that \"<code>test::foo</code> has not been declared\" (and the same for <code>test::bar</code>) at the point of the <code>using</code> directive.</p>\n<p><strong>Q2</strong> This looks to me like a compiler error, as neither with or without <code>using</code> directive can I call <code>test::foo</code>. Or perhaps I there is something about C++ that I missed?</p>\n<p>Finally, I tried to move the friend definition outside the class as in</p>\n<pre><code>namespace test {\n  template&lt;typename T&gt;\n  class A : std::vector&lt;int&gt;\n  {\n    template&lt;int K, typename F&gt;\n    friend void foo(A const&amp;a, F f);\n    template&lt;typename F&gt;\n    friend void bar(A const&amp;a, F f) { for(auto i:a) f(i); }\n  };\n\n  template&lt;int K, typename T, typename F&gt;\n  void foo(A&lt;T&gt; const&amp;a, F f) { for(auto i:a) if(i&amp;K) f(i); }\n\n}\nusing test::foo;\n</code></pre>\n<p>when gcc again complains, this time claiming that <code>void test::foo(const test::A&lt;T&gt;&amp;, F)</code> is used but never defined ... So <strong>Q3</strong> what's wrong?</p>\n<p>Answers to any sub-question welcome.</p>\n", "AcceptedAnswerId": "15140821", "Title": "problems with template friend of template class", "CreationDate": "2013-02-28T16:14:07.587", "Id": "15140315", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-02-28T16:20:44.693", "LastEditorUserId": "1023390", "LastActivityDate": "2013-02-28T17:39:51.193", "Score": "4", "OwnerUserId": "1023390", "Tags": "<c++><templates><c++11><namespaces><friend>", "AnswerCount": "2"}, "15140476": {"Id": "15140476", "PostTypeId": "2", "Body": "<p>Your problem and the answer to your questions is called ADL and the rules for when it is applied. It's not new in C++11 and it's not a problem with GCC.</p>\n<p><strong>Q1:</strong> You have a parameter <code>a</code> of type <code>test::A</code> (in the first example), hence ADL (argument dependent lookup) looks for methods in namespace <code>test</code>, but <em>only for non-template calls</em>. This is why <code>foo&lt;2&gt;</code> (a template call) is not found and <code>bar</code> is.</p>\n<p><strong>Q2:</strong> Answered after Q3, see below.</p>\n<p><strong>Q3:</strong> Your function definition for <code>test::foo</code> does not define the function you declared as a friend of <code>test::A&lt;T&gt;</code>. Change it to</p>\n<pre><code>namespace test\n{\n  template&lt;typename T&gt;\n  class A;\n\n  template&lt;int K, typename F,typename T&gt;\n  void foo(A&lt;T&gt; const&amp;a, F f);\n\n  template&lt;typename T&gt;\n  class A : std::vector&lt;int&gt;\n  {\n    template&lt;int K, typename F,typename U&gt;\n    friend void foo(A&lt;U&gt; const&amp;a, F f);\n    template&lt;typename F&gt;\n    friend void bar(A const&amp;a, F f) { for(auto i:a) f(i); }\n  };\n\n  template&lt;int K, typename F,typename T&gt;\n  void foo(A&lt;T&gt; const&amp;a, F f) { for(auto i:a) if(i&amp;K) f(i); }\n}\nusing test::foo;\n</code></pre>\n<p><strong>Q2:</strong> Similar to Q3, you can fix it like this:</p>\n<pre><code>#include &lt;vector&gt;\nnamespace test {\n  template&lt;typename T&gt;\n  class A;\n\n  template&lt;typename F,typename T&gt;\n  void bar(A&lt;T&gt; const&amp;a, F f);\n  template&lt;int K, typename F,typename T&gt;\n  void foo(A&lt;T&gt; const&amp;a, F f);\n\n  template&lt;typename T&gt;\n  class A : std::vector&lt;T&gt;\n  {\n    template&lt;typename F,typename U&gt;\n    friend void bar(A&lt;U&gt; const&amp;a, F f);\n    template&lt;int K, typename F,typename U&gt;\n    friend void foo(A&lt;U&gt; const&amp;a, F f);\n  };\n\n  template&lt;typename F,typename U&gt;\n  void bar(A&lt;U&gt; const&amp;a, F f) { for(auto i:a) f(i); }\n  template&lt;int K, typename F,typename U&gt;\n  void foo(A&lt;U&gt; const&amp;a, F f) { for(auto i:a) if(i&amp;K) f(i); }\n}\nusing test::foo;\nusing test::bar;\nint sum(test::A&lt;int&gt; const&amp;a)\n{\n  int s=0;\n  foo&lt;2&gt;(a,[&amp;s](int i) { s+=i; } );\n  bar   (a,[&amp;s](int i) { s+=i; } );\n  return s;\n}\n</code></pre>\n<p>Andy already explained why your original example does not work.</p>\n", "LastEditorUserId": "2073257", "LastActivityDate": "2013-02-28T17:14:03.160", "Score": "1", "CreationDate": "2013-02-28T16:21:27.630", "ParentId": "15140315", "CommentCount": "4", "OwnerUserId": "2073257", "LastEditDate": "2013-02-28T17:14:03.160"}});