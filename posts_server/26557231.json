post_cb({"bq_ids": {"n4140": {"so_26557231_26557488_2": {"length": 13, "quality": 1.0, "section_id": 3308}, "so_26557231_26557488_3": {"length": 16, "quality": 0.9411764705882353, "section_id": 3308}}, "n3337": {"so_26557231_26557488_2": {"length": 13, "quality": 1.0, "section_id": 3178}, "so_26557231_26557488_3": {"length": 16, "quality": 0.9411764705882353, "section_id": 3178}}, "n4659": {"so_26557231_26557488_2": {"length": 13, "quality": 1.0, "section_id": 4074}, "so_26557231_26557488_3": {"length": 16, "quality": 0.9411764705882353, "section_id": 4074}}}, "26557427": {"Id": "26557427", "PostTypeId": "2", "Body": "<p>Ok I will try it to explain it to you:</p>\n<ol>\n<li>This is a initialization. You create a two dimensional array with the values:\n<ul>\n<li>A[0][0] -&gt; 0</li>\n<li>A[0][1] -&gt; 1</li>\n<li>A[1][0] -&gt; 2</li>\n<li>A[1][1] -&gt; 3</li>\n</ul></li>\n<li>This is the exactly the same like above, but here you use braces. Do it always like this its better for reading. </li>\n<li>int **A means you have a pointer to a pointer of ints. When you do new int*[2] you will reserve memory for 2 Pointer of integer.</li>\n<li>This doesn't will be compiled.</li>\n</ol>\n", "LastActivityDate": "2014-10-24T22:51:27.800", "CommentCount": "1", "CreationDate": "2014-10-24T22:51:27.800", "ParentId": "26557231", "Score": "0", "OwnerUserId": "4145027"}, "26557377": {"Id": "26557377", "PostTypeId": "2", "Body": "<pre><code>int A[2][2] = {0,1,2,3};\nint A[2][2] = {{0,1},{2,3}};\n</code></pre>\n<p>These declare <code>A</code> as <code>array of size 2 of array of size 2 of int</code>. The declarations are absolutely identical.</p>\n<pre><code>int **A = new int*[2];\n</code></pre>\n<p>This declares a <code>pointer to pointer to int</code> initialized with an array of two pointers. You should allocate memory for these two pointers as well if you want to use it as two-dimensional array.</p>\n<pre><code>int *A = new int[2][2];\n</code></pre>\n<p>And this doesn't compile because the type of right part is <code>pointer to array of size 2 of int</code> which cannot be converted to <code>pointer to int</code>.</p>\n<p>In all valid cases <code>A + 1</code> is the same as <code>&amp;A[1]</code>, that means it points to the second element of the array, that is, in case of <code>int A[2][2]</code> to the second array of two ints, and in case of <code>int **A</code> to the second pointer in the array.</p>\n", "LastEditorUserId": "3959454", "LastActivityDate": "2014-10-24T22:59:07.467", "Score": "2", "CreationDate": "2014-10-24T22:44:20.040", "ParentId": "26557231", "CommentCount": "8", "OwnerUserId": "3959454", "LastEditDate": "2014-10-24T22:59:07.467"}, "26557488": {"Id": "26557488", "PostTypeId": "2", "Body": "<p>The other answers have covered the other declarations but I will explain why you don't need the braces in the first two initializations. The reason why these two initializations are identical:</p>\n<pre><code>int A[2][2] = {0,1,2,3};\nint A[2][2] = {{0,1},{2,3}};\n</code></pre>\n<p>is because it's covered by <a href=\"http://en.cppreference.com/w/cpp/language/aggregate_initialization\" rel=\"nofollow\">aggregate initialization</a>. Braces are allowed to be \"elided\" (omitted) in this instance.</p>\n<p>The C++ standard provides an example in \u00a7 8.5.1:</p>\n<blockquote>\n<p id=\"so_26557231_26557488_0\">[...]</p>\n<pre><code>float y[4][3] = {\n  { 1, 3, 5 },\n  { 2, 4, 6 },\n  { 3, 5, 7 },\n};\n</code></pre>\n<p id=\"so_26557231_26557488_1\">[...]</p>\n<p id=\"so_26557231_26557488_2\">In the following example, braces in the initializer-list are elided;\n  however the initializer-list has the same effect as the\n  completely-braced initializer-list of the above example,</p>\n<pre><code>float y[4][3] = {\n  1, 3, 5, 2, 4, 6, 3, 5, 7\n};\n</code></pre>\n<p id=\"so_26557231_26557488_3\">The initializer for y begins with a left brace, but the one for y[0]\n  does not, therefore three elements from the list are used. Likewise\n  the next three are taken successively for y[1] and y[2].</p>\n</blockquote>\n", "OwnerDisplayName": "user3920237", "LastActivityDate": "2014-10-24T23:00:18.683", "Score": "1", "CreationDate": "2014-10-24T23:00:18.683", "ParentId": "26557231", "CommentCount": "0"}, "26557736": {"Id": "26557736", "PostTypeId": "2", "Body": "<pre><code>int A[2][2] = {0,1,2,3};\nint A[2][2] = {{0,1},{2,3}};\n</code></pre>\n<p>These two are equivalent.<br>\nBoth mean: \"I declare a two dimentional array of integers. The array is of size 2 by 2\".  </br></p>\n<p>Memory however is not two dimensional, it is not laid out in grids, but (conceptionaly) in one long line. In a multi-dimensional array, each row is just allocated in memory right after the previous one.\nBecause of this, we can go to the memory address pointed to by <code>A</code> and either store two lines of length 2, or one line of length 4, and the end result in memory will be the same.</p>\n<pre><code>int **A = new int*[2];\n</code></pre>\n<p>Declares a pointer to a pointer called A.<br>\nA stores the address of a pointer to an array of size 2 containing <code>int</code>s. This array is allocated on the heap.</br></p>\n<pre><code>int *A = new int[2][2];\n</code></pre>\n<p><s>A is a pointer to an <code>int</code>.<br>\nThat int is the beginning of a 2x2 <code>int</code> array allocated in the heap.</br></s><br>\nAparrently this is invalid:</br></p>\n<pre><code>prog.cpp:5:23: error: cannot convert \u2018int (*)[2]\u2019 to \u2018int*\u2019 in initialization\n  int *A = new int[2][2];\n</code></pre>\n<p>But due to what we saw with the first two, this will work (and is 100% equivalent):</p>\n<pre><code>int *A new int[4];\n</code></pre>\n", "LastEditorUserId": "4022608", "LastActivityDate": "2014-10-25T17:14:22.923", "Score": "0", "CreationDate": "2014-10-24T23:32:42.903", "ParentId": "26557231", "CommentCount": "2", "OwnerUserId": "4022608", "LastEditDate": "2014-10-25T17:14:22.923"}, "26557789": {"Id": "26557789", "PostTypeId": "2", "Body": "<pre><code>int A[2][2] = {0,1,2,3};\n</code></pre>\n<p>A is an array of 4 ints. For the coder's convenience, he has decided to declare it as a 2 dimensional array so compiler will allow coder to access it as a two dimensional array. Coder has initialized all elements linearly as they are laid in memory. As usual, since A is an array, A is itself the <strong>address</strong> of the array so A + 1 (after application of pointer math) offset A by the size of 2 int pointers. Since the address of an array points to the first element of that array, A will point to first element of the second row of the array, value 2.</p>\n<p><strong>Edit</strong>: Accessing a two dimensional array using a single array operator will operate along the first dimension treating the second as 0. So A[1] is equivalent to A[1][0]. A + 1 results in equivalent pointer addition.</p>\n<pre><code>int A[2][2] = {{0,1},{2,3}};\n</code></pre>\n<p>A is an array of 4 ints. For the coder's convenience, he has decided to declare it as a 2 dimensional array so compiler will allow coder to access it as a two dimensional array. Coder has initialized elements by rows. For the same reasons above, A + 1 points to value 2.</p>\n<pre><code>int **A = new int*[2];\n</code></pre>\n<p>A is pointer to int pointer that has been initialized to point to an array of 2 pointers to int pointers. Since A is a pointer, A + 1 takes the <strong>value</strong> of A, which is the address of the pointer array (and thus, first element of the array) and adds 1 (pointer math), where it will now point to the second element of the array. As the array was not initialized, actually doing something with A + 1 (like reading it or writing to it) will be dangerous (who knows what value is there and what that would actually point to, if it's even a valid address).</p>\n<pre><code>int *A = new int[2][2];\n</code></pre>\n<p>Edit: as Jarod42 has pointed out, this is invalid. I think this may be closer to what you meant. If not, we can clarify in the comments.</p>\n<pre><code>int *A = new int[4];\n</code></pre>\n<p>A is a pointer to int that has been initialized to point to an anonymous array of 4 ints. Since A is a pointer, A + 1 takes the <strong>value</strong> of A, which is the address of the pointer array (and thus, first element of the array) and adds 1 (pointer math), where it will now point to the second element of the array.</p>\n<p>Some takeaways:</p>\n<ol>\n<li>In the first two cases, A is the address of an array while in the last two, A is the value of the pointer which happened to be initialized to the address of an array.</li>\n<li>In the first two, A cannot be changed once initialized. In the latter two, A can be changed after initialization and point to some other memory.</li>\n<li><p>That said, you need to be careful with how you might use pointers with an array element. Consider the following:</p>\n<pre><code>int *a = new int(5);\nint *b = new int(6);\nint c[2] = {*a, *b};\nint *d = a;\n</code></pre></li>\n</ol>\n<p><code>c+1</code> is not the same as <code>d+1</code>. In fact, accessing <code>d+1</code> is very dangerous. Why? Because <code>c</code> is an array of int that has been initialized by dereferencing <code>a</code> and <code>b</code>. that means that <code>c</code>, is the address of <code>a</code> chunk of memory, where at that memory location is value which has been set to the value pointed to by tovariable <code>a</code>, and at the next memory location that is a value pinned to by variable <code>b</code>. On the other hand <code>d</code> is just the address of <code>a</code>. So you can see, <code>c != d</code> therefore, there is no reason that <code>c + 1 == d + 1</code>.</p>\n", "LastEditorUserId": "2250588", "LastActivityDate": "2014-10-29T21:54:50.283", "Score": "-2", "CreationDate": "2014-10-24T23:40:39.783", "ParentId": "26557231", "CommentCount": "10", "OwnerUserId": "2250588", "LastEditDate": "2014-10-29T21:54:50.283"}, "26557380": {"Id": "26557380", "PostTypeId": "2", "Body": "<p>For the array declaration, the first specified dimension is the outermost one, an array that contains other arrays.</p>\n<p>For the pointer declarations, each <code>*</code> adds another level of indirection.</p>\n<p>The syntax was designed, for C, to let declarations mimic the use. Both the C creators and the C++ creator (Bjarne Stroustrup) have described the syntax as a failed experiment. The main problem is that it doesn't follow the usual rules of substitution in mathematics.</p>\n<p>In C++11 you can use <code>std::array</code> instead of the square brackets declaration.</p>\n<p>Also you can define a similar <code>ptr</code> type builder e.g.</p>\n<pre><code>template&lt; class T &gt;\nusing ptr = T*;\n</code></pre>\n<p>and then write</p>\n<pre><code>ptr&lt;int&gt; p;\nptr&lt;ptr&lt;int&gt;&gt; q;\n</code></pre>\n", "LastActivityDate": "2014-10-24T22:44:29.823", "CommentCount": "0", "CreationDate": "2014-10-24T22:44:29.823", "ParentId": "26557231", "Score": "2", "OwnerUserId": "464581"}, "26557231": {"ViewCount": "199", "Body": "<p>I'm trying to understand the different ways of declaring an array (of one or two dimensions) in C++ and what exactly they return (pointers, pointers to pointers, etc.)</p>\n<p>Here are some examples:</p>\n<pre><code>int A[2][2] = {0,1,2,3};\nint A[2][2] = {{0,1},{2,3}};\nint **A = new int*[2];\nint *A = new int[2][2];\n</code></pre>\n<p>In each case, what exactly is <code>A</code>? Is it a pointer, double pointer? What happens when I do <code>A+1</code>? Are these all valid ways of declaring matrices?</p>\n<p>Also, why does the first option not need the second set of curly braces to define \"columns\"?</p>\n", "AcceptedAnswerId": "26557789", "Title": "How does array declaration work in C++?", "CreationDate": "2014-10-24T22:27:47.973", "Id": "26557231", "CommentCount": "12", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-10-24T22:34:10.040", "LastEditorUserId": "623990", "LastActivityDate": "2014-10-29T21:54:50.283", "ClosedDate": "2015-04-20T22:42:05.617", "Score": "0", "OwnerUserId": "623990", "Tags": "<c++><arrays><pointers><multidimensional-array>", "AnswerCount": "7"}, "26558101": {"Id": "26558101", "PostTypeId": "2", "Body": "<p>Looks like you got a plethora of answers while I was writing mine, but I might as well post my answer anyway so I don't feel like it was all for nothing...</p>\n<p>(all <code>sizeof</code> results taken from VC2012 - 32 bit build, pointer sizes would, of course, double with a 64 bit build)</p>\n<pre><code>size_t f0(int* I);\nsize_t f1(int I[]);\nsize_t f2(int I[2]);\n\nint main(int argc, char** argv)\n{\n    // A0, A1, and A2 are local (on the stack) two-by-two integer arrays\n    // (they are technically not pointers)\n\n    // nested braces not needed because the array dimensions are explicit [2][2]\n    int A0[2][2] = {0,1,2,3};\n\n    // nested braces needed because the array dimensions are not explicit,\n    //so the braces let the compiler deduce that the missing dimension is 2\n    int A1[][2] = {{0,1},{2,3}};\n\n    // this still works, of course. Very explicit.\n    int A2[2][2] = {{0,1},{2,3}};\n\n    // A3 is a pointer to an integer pointer. New constructs an array of two\n    // integer pointers (on the heap) and returns a pointer to the first one.\n    int **A3 = new int*[2];\n    // if you wanted to access A3 with a double subscript, you would have to\n    // make the 2 int pointers in the array point to something valid as well\n    A3[0] = new int[2];\n    A3[1] = new int[2];\n    A3[0][0] = 7;\n\n    // this one doesn't compile because new doesn't return \"pointer to int\"\n    // when it is called like this\n    int *A4_1 = new int[2][2];\n\n    // this edit of the above works but can be confusing\n    int (*A4_2)[2] = new int[2][2];\n    // it allocates a two-by-two array of integers and returns a pointer to\n    // where the first integer is, however the type of the pointer that it\n    // returns is \"pointer to integer array\"\n\n    // now it works like the 2by2 arrays from earlier,\n    // but A4_2 is a pointer to the **heap**\n    A4_2[0][0] = 6;\n    A4_2[0][1] = 7;\n    A4_2[1][0] = 8;\n    A4_2[1][1] = 9;\n\n\n    // looking at the sizes can shed some light on subtle differences here\n    // between pointers and arrays\n    A0[0][0] = sizeof(A0);        // 16 // typeof(A0) is int[2][2] (2by2 int array, 4 ints total, 16 bytes)\n    A0[0][1] = sizeof(A0[0]);     // 8  // typeof(A0[0]) is int[2] (array of 2 ints)\n\n    A1[0][0] = sizeof(A1);        // 16 // typeof(A1) is int[2][2]\n    A1[0][1] = sizeof(A1[0]);     // 8  // typeof(A1[0]) is int[2]\n\n    A2[0][0] = sizeof(A2);        // 16 // typeof(A2) is int[2][2]\n    A2[0][1] = sizeof(A2[0]);     // 8  // typeof(A1[0]) is int[2]\n\n    A3[0][0] = sizeof(A3);        // 4 // typeof(A3) is int**\n    A3[0][1] = sizeof(A3[0]);     // 4 // typeof(A3[0]) is int*\n\n    A4_2[0][0] = sizeof(A4_2);    // 4 // typeof(A4_2) is int(*)[2] (pointer to array of 2 ints)\n    A4_2[0][1] = sizeof(A4_2[0]); // 8 // typeof(A4_2[0]) is int[2] (the first array of 2 ints)\n    A4_2[1][0] = sizeof(A4_2[1]); // 8 // typeof(A4_2[1]) is int[2] (the second array of 2 ints)\n    A4_2[1][1] = sizeof(*A4_2);   // 8 // typeof(*A4_2) is int[2] (different way to reference the first array of 2 ints)\n\n// confusion between pointers and arrays often arises from the common practice of\n// allowing arrays to transparently decay (implicitly convert) to pointers\n\n    A0[1][0] = f0(A0[0]); // f0 returns 4.\n    // Not surprising because declaration of f0 demands int*\n\n    A0[1][1] = f1(A0[0]); // f1 returns 4.\n    // Still not too surprising because declaration of f1 doesn't\n    // explicitly specify array size\n\n    A2[1][0] = f2(A2[0]); // f2 returns 4.\n    // Much more surprising because declaration of f2 explicitly says\n    // it takes \"int I[2]\"\n\n    int B0[25];\n    B0[0] = sizeof(B0); // 100 == (sizeof(int)*25)\n    B0[1] = f2(B0); // also compiles and returns 4.\n    // Don't do this! just be aware that this kind of thing can\n    // happen when arrays decay.\n\n    return 0;\n}\n\n// these are always returning 4 above because, when compiled,\n// all of these functions actually take int* as an argument\nsize_t f0(int* I)\n{\n    return sizeof(I);\n}\n\nsize_t f1(int I[])\n{\n    return sizeof(I);\n}\n\nsize_t f2(int I[2])\n{\n    return sizeof(I);\n}\n\n// indeed, if I try to overload f0 like this, it will not compile.\n// it will complain that, \"function 'size_t f0(int *)' already has a body\"\nsize_t f0(int I[2])\n{\n    return sizeof(I);\n}\n</code></pre>\n<p>yes, this sample has tons of signed/unsigned int mismatch, but that part isn't relevant to the question. Also, don't forget to <code>delete</code> everything created with <code>new</code> and <code>delete[]</code> everything created with <code>new[]</code></p>\n<p>EDIT:</p>\n<p>\"What happens when I do <code>A+1</code>?\" -- I missed this earlier.</p>\n<p>Operations like this would be called \"pointer arithmetic\" (even though I called out toward the top of my answer that some of these are not pointers, but they can turn into pointers).</p>\n<p>If I have a pointer <code>P</code> to an array of <code>someType</code>, then subscript access <code>P[n]</code> is exactly the same as using this syntax <code>*(P + n)</code>. The compiler will take into account the size of the type being pointed to in both cases. So, the resulting opcode will actually do something like this for you <code>*(P + n*sizeof(someType))</code> or equivalently <code>*(P + n*sizeof(*P))</code> because the physical cpu doesn't know or care about all our made up \"types\". In the end, all pointer offsets have to be a byte count. For consistency, using array names like pointers works the same here.</p>\n<p>Turning back to the samples above: <code>A0</code>, <code>A1</code>, <code>A2</code>, and <code>A4_2</code> all behave the same with pointer arithmetic.</p>\n<p><code>A0[0]</code> is the same as <code>*(A0+0)</code>, which references the first <code>int[2]</code> of <code>A0</code></p>\n<p>similarly:</p>\n<p><code>A0[1]</code> is the same as <code>*(A0+1)</code> which offsets the \"pointer\" by <code>sizeof(A0[0])</code> (i.e. 8, see above) and it ends up referencing the second <code>int[2]</code> of <code>A0</code></p>\n<p><code>A3</code> acts slightly differently. This is because <code>A3</code> is the only one that doesn't store all 4 ints of the 2 by 2 array contiguously. In my example, <code>A3</code> points to an array of 2 int pointers, each of these point to <strong>completely separate</strong> arrays of two ints. Using <code>A3[1]</code> or <code>*(A3+1)</code> would still end up directing you to the second of the two int arrays, but it would do it by offsetting only 4bytes from the beginning of A3 (using 32 bit pointers for my purposes) which gives you a pointer that tells you where to find the second two-int array. I hope that makes sense.</p>\n", "LastEditorUserId": "3170912", "LastActivityDate": "2014-10-25T02:28:45.590", "Score": "3", "CreationDate": "2014-10-25T00:26:11.650", "ParentId": "26557231", "CommentCount": "0", "OwnerUserId": "3170912", "LastEditDate": "2014-10-25T02:28:45.590"}});