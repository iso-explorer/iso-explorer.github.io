post_cb({"bq_ids": {"n4140": {"so_24851110_24869078_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 4503}}, "n3337": {"so_24851110_24869078_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 4334}}}, "24851110": {"ViewCount": "1928", "Body": "<p>Given the following source code:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct concept\n{\n    virtual void perform() = 0;\n};\n\n\nstruct model : concept, enable_shared_from_this&lt;model&gt;\n{\n    void perform() override {\n        cout &lt;&lt; \"my pointer is \" &lt;&lt; shared_from_this().get() &lt;&lt; endl;\n    }\n};\n\nint main(int argc, const char * argv[])\n{\n    // shared_ptr&lt;concept&gt; concept_ptr = make_shared&lt;model&gt;();\n    shared_ptr&lt;concept&gt; concept_ptr { new model };\n    concept_ptr-&gt;perform();\n    return 0;\n}\n</code></pre>\n<p>Compiling under <code>gcc</code>, this code compiles and associates the internal <code>weak_ptr</code> with the address of <code>model</code>.</p>\n<p>Under <code>clang</code> the code will not compile (error message included at the end)</p>\n<p>If you replace the initialisation of <code>concept_ptr</code> with <code>shared_ptr&lt;concept&gt; concept_ptr = make_shared&lt;model&gt;();</code> it will compile on both.</p>\n<p>Which is correct?</p>\n<p>edit:</p>\n<p>My version of clang is the one that ships with <code>Xcode</code>:</p>\n<pre><code>$ clang --version\nApple LLVM version 5.1 (clang-503.0.40) (based on LLVM 3.4svn)\nTarget: x86_64-apple-darwin13.3.0\nThread model: posix\n</code></pre>\n<p>edit2:</p>\n<p>Just wanted to say thanks to everyone for contributing. \nIf you're interested, the reason I want to do this is that I want an opaque interface to an implementation with shared-handle semantics. Some implementations (async ones) require that callback objects ensure that the implementation object still exists (argues for <code>shared_from_this</code> and <code>weak_ptr::lock</code>). Other implementations do not require this. I wanted to avoid encumbering the concept (public interface) with the <code>enable_shared_from_this&lt;&gt;</code> base class, since that couples implementation with interface - a known evil.</p>\n<p>In most cases, it's reasonable to use make_shared to create the implementation object. In rarer cases that require a custom destructor, the following seems portable:</p>\n<pre><code>    auto concept_ptr = static_pointer_cast&lt;concept&gt;(shared_ptr&lt;model&gt; {\n                                                        new model ,\n                                                        [](model* self) {\n                                                            // some_deletion_operation on self;\n                                                        } });\n</code></pre>\n<p>appendix:\nerror message on clang:</p>\n<pre><code>In file included from /Users/richardh/Documents/dev/Scratchpad/tryit/tryit/try2.cpp:1:\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/c++/v1/memory:4013:35: error: no viable overloaded '='\n            __e-&gt;__weak_this_ = *this;\n            ~~~~~~~~~~~~~~~~~ ^ ~~~~~\n...etc...    \n</code></pre>\n", "AcceptedAnswerId": "24869078", "Title": "which of these compilers has a bug, according to the standard?", "CreationDate": "2014-07-20T13:44:50.540", "Id": "24851110", "CommentCount": "4", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2014-07-23T14:42:54.960", "LastEditorUserId": "2015579", "LastActivityDate": "2014-07-25T06:25:58.897", "Score": "26", "OwnerUserId": "2015579", "Tags": "<c++><gcc><c++11><clang>", "AnswerCount": "1"}, "24869078": {"PostTypeId": "2", "Body": "<p>I understand that libstdc++ follows the standard more closely here.</p>\n<p>Concerning the requirements for </p>\n<pre><code>shared_ptr&lt;T&gt; shared_from_this(); \nshared_ptr&lt;const T&gt; shared_from_this() const; \n</code></pre>\n<p>both N3337 \u00a720.7.2.4 (7) and N3936 \u00a720.8.2.5 (7) only require</p>\n<blockquote>\n<p id=\"so_24851110_24869078_0\"><code>enable_shared_from_this&lt;T&gt;</code> shall be an accessible base class\n  of <code>T</code>. <code>*this</code> shall be a subobject of an object <code>t</code> of type <code>T</code>. There shall\n  be at least one <code>shared_ptr</code> instance <code>p</code> that owns <code>&amp;t</code>.</p>\n</blockquote>\n<p>There is no requirement named that one <code>shared_ptr</code> owning <code>&amp;t</code> actually has to be a <code>shared_ptr&lt;T&gt;</code> or <code>shared_ptr&lt;A_to_T_Convertible&gt;</code>.</p>\n<p>And that very function is the core of that class' functionality.</p>\n<p>Thus, given <code>Tp</code> as the actual param of the <code>enabled_shared_from_this</code> and <code>Tp1</code> as the actual parameter of that owning <code>shared_ptr</code>, <code>is_convertible&lt;Tp1, Tp&gt;::value == true</code>, let alone <code>is_same&lt;Tp1, Tp&gt;::value == true</code>, is not required by the standard, same for respective pointers.</p>\n<hr>\n<p>And indeed, the full output of clang++ using libc++ has</p>\n<pre><code>/usr/local/bin/../include/c++/v1/memory:3997:35: error: no viable overloaded '='\n                __e-&gt;__weak_this_ = *this;\n                ~~~~~~~~~~~~~~~~~ ^ ~~~~~\n/usr/local/bin/../include/c++/v1/memory:4035:5: note: in instantiation of\n      function template specialization\n      'std::__1::shared_ptr&lt;concept&gt;::__enable_weak_this&lt;model&gt;' requested here\n    __enable_weak_this(__p);\n    ^\n[...]enable_shared.cxx:34:25: note: in instantiation\n      of function template specialization\n      'std::__1::shared_ptr&lt;concept&gt;::shared_ptr&lt;model&gt;' requested here\n    shared_ptr&lt;concept&gt; model_ptr1(new model);\n                        ^\n/usr/local/bin/../include/c++/v1/memory:4942:15: note: candidate function not\n      viable: no known conversion from 'std::__1::shared_ptr&lt;concept&gt;' to 'const\n      std::__1::weak_ptr&lt;model&gt;' for 1st argument\n    weak_ptr&amp; operator=(weak_ptr const&amp; __r) _NOEXCEPT;\n              ^\n/usr/local/bin/../include/c++/v1/memory:4953:15: note: candidate function not\n      viable: no known conversion from 'std::__1::shared_ptr&lt;concept&gt;' to\n      'std::__1::weak_ptr&lt;model&gt;' for 1st argument\n    weak_ptr&amp; operator=(weak_ptr&amp;&amp; __r) _NOEXCEPT;\n              ^\n/usr/local/bin/../include/c++/v1/memory:4949:9: note: candidate template\n      ignored: could not match 'weak_ptr' against 'shared_ptr'\n        operator=(weak_ptr&lt;_Yp&gt; const&amp; __r) _NOEXCEPT;\n        ^\n/usr/local/bin/../include/c++/v1/memory:4960:9: note: candidate template\n      ignored: could not match 'weak_ptr' against 'shared_ptr'\n        operator=(weak_ptr&lt;_Yp&gt;&amp;&amp; __r) _NOEXCEPT;\n        ^\n/usr/local/bin/../include/c++/v1/memory:4967:13: note: candidate template\n      ignored: disabled by 'enable_if' [with _Yp = concept]\n            is_convertible&lt;_Yp*, element_type*&gt;::value,\n            ^\n</code></pre>\n<p>So libc++ here wants </p>\n<pre><code>is_convertible&lt;Tp1* /*= Base* = concept**/, Tp* /*= Derived* = model* */&gt;\n</code></pre>\n<p>which of course fails here, that the run-time <code>*this</code> of that very <code>shared_ptr&lt;Tp1&gt;</code> would be <code>dynamic_cast</code>-able to <code>Tp*</code> is out of ansatz here.</p>\n<hr>\n<p>From this perspective, it's also clear why <code>shared_ptr&lt;concept&gt; concept_ptr = make_shared&lt;model&gt;();</code> doesn't suffer from that; on the <code>rhs</code> there is a <code>shared_ptr&lt;Tp /* = derived = model */&gt;</code> constructor and for that <code>ptr</code> <code>is_convertible</code> holds. </p>\n<hr>\n<p>libstdc++ doesn't suffer from this, because it passes the <strong>argument</strong>, thus its type (= Derived = model), of the <code>shared_ptr&lt;Tp1 /* = Base = concept*/&gt;</code> constructor down to the internal <code>weak_ptr&lt;T /*= Derived = model*/&gt;</code> assignment, not the <code>shared_ptr</code> in construction.</p>\n<p><a href=\"https://github.com/mirrors/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr_base.h#L848\">https://github.com/mirrors/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr_base.h#L848</a></p>\n<pre><code>  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __shared_ptr\n{\n</code></pre>\n<p><a href=\"https://github.com/mirrors/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr_base.h#L858\">https://github.com/mirrors/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr_base.h#L858</a></p>\n<pre><code>template&lt;typename _Tp1&gt;\nexplicit __shared_ptr(_Tp1* __p)\n    : _M_ptr(__p), _M_refcount(__p)\n{\n  __glibcxx_function_requires(_ConvertibleConcept&lt;_Tp1*, _Tp*&gt;)\n  static_assert( !is_void&lt;_Tp1&gt;::value, \"incomplete type\" );\n  static_assert( sizeof(_Tp1) &gt; 0, \"incomplete type\" );\n  __enable_shared_from_this_helper(_M_refcount, __p, __p);\n}\n</code></pre>\n<p><a href=\"https://github.com/mirrors/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr_base.h#L1459\">https://github.com/mirrors/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr_base.h#L1459</a></p>\n<pre><code>  template&lt;typename _Tp, _Lock_policy _Lp&gt;\n    class __enable_shared_from_this\n    {\n</code></pre>\n<p><a href=\"https://github.com/mirrors/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr_base.h#L1482\">https://github.com/mirrors/gcc/blob/master/libstdc%2B%2B-v3/include/bits/shared_ptr_base.h#L1482</a></p>\n<pre><code>private:\n  template&lt;typename _Tp1&gt;\nvoid\n_M_weak_assign(_Tp1* __p, const __shared_count&lt;_Lp&gt;&amp; __n) const noexcept\n{ _M_weak_this._M_assign(__p, __n); }\n\n\n  template&lt;typename _Tp1&gt;\nfriend void\n__enable_shared_from_this_helper(const __shared_count&lt;_Lp&gt;&amp; __pn,\n                 const __enable_shared_from_this* __pe,\n                 const _Tp1* __px) noexcept\n{\n  if (__pe != 0)\n    __pe-&gt;_M_weak_assign(const_cast&lt;_Tp1*&gt;(__px), __pn);\n}\n</code></pre>\n<p>My point of view only; comments welcome.</p>\n<p>@Richard Hodges: +1, very interesting topic</p>\n</hr></hr></hr>", "LastActivityDate": "2014-07-25T06:25:58.897", "LastEditorUserId": "147192", "Id": "24869078", "CommentCount": "8", "CreationDate": "2014-07-21T15:39:08.577", "ParentId": "24851110", "Score": "11", "OwnerUserId": "2378245", "LastEditDate": "2014-07-25T06:25:58.897"}});