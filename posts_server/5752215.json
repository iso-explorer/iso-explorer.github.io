post_cb({"5752223": {"ParentId": "5752215", "CommentCount": "0", "Body": "<pre><code>struct A&lt;TA&gt;::B : C&lt;typename D&lt;TA&gt;::template T&lt;TBA&gt; &gt;\n</code></pre>\n<blockquote>\n<p id=\"so_5752215_5752223_0\">For a template-name to be explicitly qualified by the template arguments, the name must be known to refer to a template.</p>\n<p id=\"so_5752215_5752223_1\">When the name of a member template specialization appears after . or -&gt; in a postfix-expression, or after nested-name-specifier in a qualified-id, and the postfix-expression or qualified-id explicitly depends on a template-parameter (14.6.2), the member template name must be prefixed by the keyword template. Otherwise the name is assumed to name a non-template</p>\n</blockquote>\n<p><code>T</code> appears after the nested-name-specifier <code>D&lt;TA&gt;</code> which depends on the template-parameter <code>TA</code>. The construct <code>D&lt;TA&gt;::T&lt;TBA&gt;</code> must interpret <code>T</code> as the name of a class template and so the <code>template</code> keyword is mandated by the Standard at that point.</p>\n", "OwnerUserId": "165520", "PostTypeId": "2", "Id": "5752223", "Score": "6", "CreationDate": "2011-04-22T04:11:27.837", "LastActivityDate": "2011-04-22T04:11:27.837"}, "5752215": {"CommentCount": "3", "CreationDate": "2011-04-22T04:10:01.487", "PostTypeId": "1", "AcceptedAnswerId": "5752223", "LastEditorUserId": "709202", "LastActivityDate": "2011-10-31T05:39:50.037", "LastEditDate": "2011-10-31T05:39:50.037", "ViewCount": "1546", "FavoriteCount": "3", "Title": "Can someone help me with nested-name specifiers in C++ templates?", "Id": "5752215", "Score": "2", "Body": "<p>What's wrong with the following sample code? It doesn't compile in GCC. Why? </p>\n<pre><code>template &lt;class TA&gt;\nstruct A\n{\n    template &lt;class TAB&gt; struct B;\n};\n\ntemplate &lt;class TC&gt;\nstruct C {};\n\n\ntemplate &lt;class TD&gt;\nstruct D\n{\n    template &lt;class TTD&gt; class T {};\n};    \n\ntemplate&lt;class TA&gt;\ntemplate&lt;class TBA&gt;\nstruct A&lt;TA&gt;::B : C&lt;typename D&lt;TA&gt;::T&lt;TBA&gt; &gt;\n{\n    int foo;\n};\n</code></pre>\n<p>GCC 4.3.4 output:</p>\n<pre><code>error: template argument 1 is invalid\nerror: expected `{' before \u2018&gt;\u2019 token\nerror: expected unqualified-id before \u2018&gt;\u2019 token\n</code></pre>\n", "Tags": "<c++><templates>", "OwnerUserId": "719993", "AnswerCount": "2"}, "5752225": {"ParentId": "5752215", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Clang's error message is a bit more helpful:</p>\n<pre><code>error: use 'template' keyword to treat 'T' as a dependent template name\nstruct A&lt;TA&gt;::B : C&lt;typename D&lt;TA&gt;::T&lt;TBA&gt; &gt;\n                                    ^\n                                    template\n</code></pre>\n<p>For more information consider reading the Stack Overflow C++ FAQ <a href=\"https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-template-and-typename-on-dependent-names\">\"Where and why do I have to put \u201ctemplate\u201d and \u201ctypename\u201d on dependent names?\"</a></p>\n", "OwnerUserId": "151292", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:43:30.780", "Id": "5752225", "Score": "7", "CreationDate": "2011-04-22T04:12:07.900", "LastActivityDate": "2011-04-22T04:12:07.900"}, "bq_ids": {"n4140": {"so_5752215_5752223_1": {"section_id": 72, "quality": 0.8620689655172413, "length": 25}, "so_5752215_5752223_0": {"section_id": 70, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_5752215_5752223_1": {"section_id": 67, "quality": 0.8620689655172413, "length": 25}, "so_5752215_5752223_0": {"section_id": 65, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_5752215_5752223_0": {"section_id": 72, "quality": 0.9090909090909091, "length": 10}}}});