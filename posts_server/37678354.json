post_cb({"bq_ids": {"n4140": {"so_37678354_37679754_1": {"length": 14, "quality": 1.0, "section_id": 2717}}, "n3337": {"so_37678354_37679754_1": {"length": 14, "quality": 1.0, "section_id": 2678}}, "n4659": {"so_37678354_37679754_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 3457}}}, "37679754": {"Id": "37679754", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_37678354_37679754_0\">Somebody wrote here that a program aborts \"when a thread object goes out of scope and it is in joinable state\".</p>\n</blockquote>\n<p>That is what <a href=\"http://eel.is/c++draft/thread.thread.destr\" rel=\"nofollow\">39.3.1.3/1</a> [thread destructor] says actually:</p>\n<blockquote>\n<p id=\"so_37678354_37679754_1\">If\u00a0joinable(), calls\u00a0std::terminate(). [...] Thus the programmer must ensure that the destructor is never executed while the thread is still joinable.</p>\n</blockquote>\n", "LastActivityDate": "2016-06-07T12:44:20.503", "CommentCount": "5", "CreationDate": "2016-06-07T12:44:20.503", "ParentId": "37678354", "Score": "-1", "OwnerUserId": "4987285"}, "37685726": {"Id": "37685726", "PostTypeId": "2", "Body": "<p>On Linux (as on most OSes) exceptions are a language-agnostic feature, and pthread cancellation is implemented using language-agnostic exceptions (See e.g. <a href=\"http://udrepper.livejournal.com/21541.html\" rel=\"nofollow\">Cancellation and C++ Exceptions</a>).</p>\n<p>When a pthread cancellation is delivered to a thread (using a signal, but you don't need to know that) the unwind machinery invokes all the installed personalities so that they can perform language-specific cleanup prior to the thread exiting. (This is pretty cool; it means that as in the above article you can insert a catch block for <code>abi::__forced_unwind</code> to detect - though not to prevent - a thread cancellation.)</p>\n<p>The problem is that an asynchronous cancellation can occur at any instruction, and the C++ exception tables generated by g++ only handle exceptions occurring at instructions known to be capable of generating exceptions (i.e. but not only calls to exception-throwing functions). If an exception is generated at a point not covered by the C++ tables, the C++ personality panics and terminates the process (hence \"terminate called without an active exception\").</p>\n<p>The reason this is influenced by optimization is that the C++ personality is installed lazily, but with higher optimization levels the compiler might decide to preemptively install the C++ personality. You can guarantee the crash even at lower optimization levels by exercising the C++ exception machinery e.g. with <code>try { throw 0; } catch (int) {}</code>.</p>\n<p>The simplest fix is to ensure that the C++ personality is not installed in the thread you want to asynchronous cancel. You can ensure this by compiling the thread function as C and not calling any C++ functions from it.</p>\n<p>A more hacky and <em>highly</em> unsupported solution is to ensure that all the asynchronous cancellation points (that is, all the instructions where the cancelled thread could be when the asynchronous cancellation is received) are <em>in fact</em> covered by the C++ unwind tables. Firstly you need to compile with <code>-fnon-call-exceptions</code>; secondly you have to ensure that every instruction that could be an asynchronous cancellation point is <em>between</em> two points known to be synchronous cancellation points, e.g. <code>pthread_testcancel</code>:</p>\n<pre><code>static void* busy(void*)\n{\n  int oldstate ;\n  auto result = pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS,&amp;oldstate) ;\n  if (result != 0)\n#ifdef NOEXCEPT\n    { std::cerr &lt;&lt; \"pthread_setcanceltype\" &lt;&lt; std::endl ; abort() ; }\n#else\n    throw std::runtime_error(\"pthread_setcanceltype\") ;\n#endif\n  pthread_testcancel();\n  for (unsigned i = 1; ; ++i) \n    if (i == 0)\n      pthread_testcancel();\n  return nullptr ;\n}\n</code></pre>\n", "LastActivityDate": "2016-06-07T17:32:17.593", "CommentCount": "1", "CreationDate": "2016-06-07T17:32:17.593", "ParentId": "37678354", "Score": "2", "OwnerUserId": "567292"}, "37678354": {"ViewCount": "1004", "Body": "<p>Consider the following program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;pthread.h&gt;\n#include &lt;stdexcept&gt;\n#include &lt;unistd.h&gt;\n\nstatic void* busy(void*)\n{\n  int oldstate ;\n  auto result = pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS,&amp;oldstate) ;\n  if (result != 0)\n#ifdef NOEXCEPT\n    { std::cerr &lt;&lt; \"pthread_setcanceltype\" &lt;&lt; std::endl ; abort() ; }\n#else\n    throw std::runtime_error(\"pthread_setcanceltype\") ;\n#endif\n  while (true) \n    ;\n  return nullptr ;\n}\n\nstatic pthread_t start()\n{\n  pthread_t t ;\n  int result = pthread_create(&amp;t,nullptr,busy,nullptr) ;\n  if (result != 0)\n    throw std::runtime_error(\"pthread_create\") ;\n  return t ;\n}\n\nstatic void terminate(pthread_t t)\n{\n  auto result = pthread_cancel(t) ;\n  if (result != 0) \n    throw std::runtime_error(\"pthread_cancel()\") ;\n  result = pthread_join(t,nullptr) ;\n  if (result != 0) \n    throw std::runtime_error(\"pthread_join()\") ;\n}\n\nint main()\n{\n  auto t = start() ;\n  sleep(1) ; // may not cause an abort otherwise\n  terminate(t) ;\n  return 0 ;\n}\n</code></pre>\n<p>This runs fine as long as no optimization (or -O1) is used, e.g. with g++ -std=c++11 -Wall -o test test.cc -pthread</p>\n<p>However, with -O2 or -O3 the program aborts with the message above. </p>\n<p>Also kind of interesting: it runs thru if compiled with -DNOEXCEPT. So it appears, if a thread is cancelled in a function that potentially [sic!] throws an exception, and if optimization is switched on, the program may abort. -- And I can't see any way to prevent this.</p>\n<p>It's for me reproducible on amd64 gcc 4.8.4 (Ubuntu 14.04.3) and armv7l gcc 4.9.2 (Raspbian 4.9.2-10).</p>\n<p>Can you reproduce this? Do you have an explanation? This behavior seems to be odd (at least to me). I'd be happy to receive some kind of feedback. Thank you!</p>\n", "AcceptedAnswerId": "37685726", "Title": "C++: Terminate called without an active exception (GCC)", "CreationDate": "2016-06-07T11:38:29.190", "Id": "37678354", "CommentCount": "4", "LastEditDate": "2016-06-07T14:51:07.823", "PostTypeId": "1", "LastEditorUserId": "6434818", "LastActivityDate": "2016-06-07T17:32:17.593", "Score": "8", "OwnerUserId": "6434818", "Tags": "<c++><multithreading><gcc><exception-handling>", "AnswerCount": "2"}});