post_cb({"8087568": {"Id": "8087568", "PostTypeId": "2", "Body": "<p>I just double checked the stdlib.h for the GNU compiler and the declarations do not use extern \"C\" as declarations. </p>\n<p>edit: </p>\n<pre><code>if defined __cplusplus &amp;&amp; defined _GLIBCPP_USE_NAMESPACES\ndefine __BEGIN_NAMESPACE_STD    namespace std {\n</code></pre>\n<p>So including the old headers will place declarations on std provided _GLIBCPP_USE_NAMESPACES is defined?</p>\n", "LastEditorUserId": "39992", "LastActivityDate": "2013-07-29T02:59:12.970", "Score": "0", "CreationDate": "2011-11-10T22:58:23.343", "ParentId": "8087438", "CommentCount": "0", "OwnerUserId": "1030067", "LastEditDate": "2013-07-29T02:59:12.970"}, "8087438": {"ViewCount": "5635", "Body": "<p>Do I need an <code>extern \"C\" {}</code> block to include standard C headers in a C++ program. Only consider standard C headers which do not have counterparts in C++.</p>\n<p>For example:</p>\n<pre><code>extern \"C\" {\n #include &lt;fcntl.h&gt;\n #include &lt;unistd.h&gt;\n}\n</code></pre>\n", "AcceptedAnswerId": "8087599", "Title": "Do I need an extern \"C\" block to include standard C headers?", "CreationDate": "2011-11-10T22:46:04.130", "Id": "8087438", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-08-03T16:14:21.210", "LastEditorUserId": "834521", "LastActivityDate": "2015-08-03T16:14:21.210", "Score": "9", "OwnerUserId": "989331", "Tags": "<c++><posix-api>", "AnswerCount": "7"}, "8087499": {"Id": "8087499", "PostTypeId": "2", "Body": "<p>No, you should use the C++ wrapper headers (for instance like <code>&lt;cstdio&gt;</code>). Those take care of all that for you.</p>\n<p>If it's a header that doesn't have those, then yes, you'll want to wrap them in <code>extern \"C\" {}</code>.</p>\n<p><strong>ETA:</strong> It's worth noting that many implementations will include the wrapper inside the .h file like below, so that you can get away with not doing it yourself.</p>\n<pre><code>#ifdef  __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef  __cplusplus\n}\n#endif\n</code></pre>\n", "LastEditorUserId": "53089", "LastActivityDate": "2011-11-10T22:57:55.560", "Score": "1", "CreationDate": "2011-11-10T22:51:12.657", "ParentId": "8087438", "CommentCount": "1", "OwnerUserId": "53089", "LastEditDate": "2011-11-10T22:57:55.560"}, "8087539": {"Id": "8087539", "PostTypeId": "2", "Body": "<p>The system C headers usually already include a <code>extern \"C\"</code> block, guarded by <code>#ifdef __cplusplus</code>. This way the functions automatically get declared as <code>extern \"C\"</code> when compiled as C++ and you don't need to do that manually.</p>\n<p>For example on my system <code>unistd.h</code> and <code>fcntl.h</code> start with <code>__BEGIN_DECLS</code> and end with <code>__END_DECLS</code>, which are macros defined in <code>sys/cdefs.h</code>:</p>\n<pre><code>/* C++ needs to know that types and declarations are C, not C++.  */\n#ifdef   __cplusplus\n# define __BEGIN_DECLS  extern \"C\" {                                            \n# define __END_DECLS }\n#else\n# define __BEGIN_DECLS\n# define __END_DECLS\n#endif\n</code></pre>\n", "LastActivityDate": "2011-11-10T22:56:06.370", "CommentCount": "0", "CreationDate": "2011-11-10T22:56:06.370", "ParentId": "8087438", "Score": "11", "OwnerUserId": "56338"}, "bq_ids": {"n4140": {"so_8087438_8087599_0": {"length": 23, "quality": 0.5609756097560976, "section_id": 6259}}, "n3337": {"so_8087438_8087599_0": {"length": 23, "quality": 0.5609756097560976, "section_id": 6019}}, "n4659": {"so_8087438_8087599_0": {"length": 22, "quality": 0.5365853658536586, "section_id": 7763}}}, "8087519": {"Id": "8087519", "PostTypeId": "2", "Body": "<p>It <em>is</em> a good idea to let the compiler know so that it can expect C code when compiling as C++. You might also find that the header files themselves contain <code>extern \"C\" {</code> as guards.</p>\n<p>For example, <code>curses.h</code> on my system contains:</p>\n<pre><code>#ifdef __cplusplus\nextern \"C\" {\n...\n</code></pre>\n", "LastActivityDate": "2011-11-10T22:53:31.500", "CommentCount": "3", "CreationDate": "2011-11-10T22:53:31.500", "ParentId": "8087438", "Score": "-1", "OwnerUserId": "998299"}, "8087530": {"Id": "8087530", "PostTypeId": "2", "Body": "<p>Yes, you do. However, many systems (notably Linux) are already adding an <code>extern \"C\"</code> bracketing like you do. See (on Linux) files <code>/usr/include/unistd.h</code> <code>/usr/include/features.h</code> and the macro  <code>__BEGIN_DECLS</code> defined in <code>/usr/include/sys/cdefs.h</code> and used in many Linux system include files.</p>\n<p>So on Linux, you usually can avoid your <code>extern \"C\"</code> but it does not harm (and, IMHO, improve readability in that case).</p>\n", "LastActivityDate": "2011-11-10T22:54:47.910", "CommentCount": "0", "CreationDate": "2011-11-10T22:54:47.910", "ParentId": "8087438", "Score": "1", "OwnerUserId": "841108"}, "8087599": {"Id": "8087599", "PostTypeId": "2", "Body": "<p>The behavior of <code>&lt;fcntl.h&gt;</code> and <code>&lt;unistd.h&gt;</code> in C++ is not specified by the standard (because they are also not part of the C89 standard).  That said, I have never seen a platform where they (a) exist and (b) actually need to be wrapped in an <code>extern \"C\"</code> block.</p>\n<p>The behavior of <code>&lt;stdio.h&gt;</code>, <code>&lt;math.h&gt;</code>, and the other standard C headers is specified by section D.5 of the C++03 standard.  They do not require an <code>extern \"C\"</code> wrapper block, and they dump their symbols into the global namespace.  However, everything in Annex D is \"deprecated\".</p>\n<p>The canonical C++ form of those headers is <code>&lt;cstdio&gt;</code>, <code>&lt;cmath&gt;</code>, etc., and they are specified by section 17.4.1.2 (3) of the C++ standard, which says:</p>\n<pre><code>&lt;cassert&gt; &lt;ciso646&gt; &lt;csetjmp&gt; &lt;cstdio&gt; &lt;ctime&gt; &lt;cctype&gt; &lt;climits&gt;\n&lt;csignal&gt; &lt;cstdlib&gt; &lt;cwchar&gt; &lt;cerrno&gt; &lt;clocale&gt; &lt;cstdarg&gt; &lt;cstring&gt;\n&lt;cwctype&gt;\n</code></pre>\n<blockquote>\n<p id=\"so_8087438_8087599_0\">Except as noted in clauses 18 through 27, the contents of each header\n  cname shall be the same as that of the corresponding header name.h, as\n  specified in ISO/IEC 9899:1990 Programming Languages C (Clause 7), or\n  ISO/IEC:1990 Programming Languages\u2014C AMENDMENT 1: C Integrity, (Clause\n  7), as appropriate, as if by inclusion. In the C++ Standard Library,\n  however, the declarations and definitions (except for names which are\n  defined as macros in C) are within namespace scope (3.3.5) of the\n  namespace std.</p>\n</blockquote>\n<p>So the standard, non-deprecated, canonical way to use (e.g.) <code>printf</code> in C++ is to <code>#include &lt;cstdio&gt;</code> and then invoke <code>std::printf</code>.</p>\n", "LastActivityDate": "2011-11-10T23:00:48.597", "CommentCount": "0", "CreationDate": "2011-11-10T23:00:48.597", "ParentId": "8087438", "Score": "7", "OwnerUserId": "768469"}, "8087543": {"Id": "8087543", "PostTypeId": "2", "Body": "<p>In my opinion it's the duty of the exporting header file to use extern \"C\" appropriately.</p>\n", "LastActivityDate": "2011-11-10T22:56:21.490", "CommentCount": "0", "CreationDate": "2011-11-10T22:56:21.490", "ParentId": "8087438", "Score": "2", "OwnerUserId": "1023911"}});