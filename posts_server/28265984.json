post_cb({"bq_ids": {"n4140": {"so_28265984_28266104_0": {"length": 7, "quality": 1.0, "section_id": 5947}, "so_28265984_28266104_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 5440}, "so_28265984_28266104_4": {"length": 5, "quality": 1.0, "section_id": 5440}, "so_28265984_28266104_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5440}, "so_28265984_28266104_3": {"length": 5, "quality": 1.0, "section_id": 5440}}, "n3337": {"so_28265984_28266104_0": {"length": 7, "quality": 1.0, "section_id": 5717}, "so_28265984_28266104_4": {"length": 5, "quality": 1.0, "section_id": 5235}, "so_28265984_28266104_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 5235}, "so_28265984_28266104_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 5235}, "so_28265984_28266104_3": {"length": 5, "quality": 1.0, "section_id": 5235}}, "n4659": {"so_28265984_28266104_0": {"length": 7, "quality": 1.0, "section_id": 7433}, "so_28265984_28266104_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 6867}, "so_28265984_28266104_4": {"length": 5, "quality": 1.0, "section_id": 6867}, "so_28265984_28266104_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 6867}, "so_28265984_28266104_3": {"length": 5, "quality": 1.0, "section_id": 6867}}}, "28266104": {"Id": "28266104", "PostTypeId": "2", "Body": "<p>You are seeing this behavior because of how <code>decltype</code> deduces the type. String literals are lvalues. From [expr.prim.general]/p1:</p>\n<blockquote>\n<p id=\"so_28265984_28266104_0\">A string literal is an lvalue; all other literals are prvalues.</p>\n</blockquote>\n<p><code>decltype()</code> returns an lvalue-reference type for lvalues. [dcl.type.simple]/p4</p>\n<blockquote>\n<p id=\"so_28265984_28266104_1\">For an expression <code>e</code>, the type denoted by <code>decltype(e)</code> is defined as follows:</p>\n<p id=\"so_28265984_28266104_2\">(4.1) \u2014 if <code>e</code> is an unparenthesized id-expression or an unparenthesized class member access (5.2.5), <code>decltype(e)</code> is the type of the entity named by <code>e</code>. If there is no such entity, or if <code>e</code> names a set of overloaded functions,\n  the program is ill-formed;</p>\n<p id=\"so_28265984_28266104_3\">(4.2) \u2014 otherwise, if <code>e</code> is an xvalue, <code>decltype(e)</code> is <code>T&amp;&amp;</code>, where <code>T</code> is the type of <code>e</code>;</p>\n<p id=\"so_28265984_28266104_4\">(4.3) \u2014 <strong>otherwise, if <code>e</code> is an lvalue, <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code> is the type of <code>e</code>;</strong></p>\n<p id=\"so_28265984_28266104_5\">(4.4) \u2014 otherwise, <code>decltype(e)</code> is the type of <code>e</code>.</p>\n</blockquote>\n<p>So your specialization needs to be as follows:</p>\n<pre><code>template &lt;std::size_t N&gt;\nstruct select_type&lt;const char (&amp;)[N]&gt;\n</code></pre>\n", "LastActivityDate": "2015-02-01T18:17:13.950", "CommentCount": "0", "CreationDate": "2015-02-01T18:17:13.950", "ParentId": "28265984", "Score": "3", "OwnerUserId": "701092"}, "28265984": {"ViewCount": "592", "Body": "<p>I'm trying to use template specialization so that I can have specialized behavior for different types.  However, I'm unable to get a template specialization for a string literal type (<code>const char[N]</code>) to bind to the specialized template.</p>\n<p>I have a simple template <code>select_type&lt;T&gt;</code>, with the following specializations:</p>\n<pre><code>template &lt;class T&gt;\nstruct select_type\n{\n    static void action()\n    {\n        cout &lt;&lt; \"Generic type\" &lt;&lt; endl;\n    }\n};\n\ntemplate &lt;&gt;\nstruct select_type&lt;std::string&gt;\n{\n    static void action()\n    {\n        cout &lt;&lt; \"Specialization for string\" &lt;&lt; endl;\n    }\n};\n\ntemplate &lt;std::size_t N&gt;\nstruct select_type&lt;const char[N]&gt;\n{\n    static void action()\n    {\n        cout &lt;&lt; \"Specialization for const char array\" &lt;&lt; endl;\n    }\n};\n</code></pre>\n<p>When I attempt to instantiate each specialization as follows:</p>\n<pre><code>select_type&lt;int&gt;::action();\nselect_type&lt;std::string&gt;::action();\nselect_type&lt;decltype(\"abc\")&gt;::action();\n</code></pre>\n<p>... I get the following output:</p>\n<pre><code>Generic type\nSpecialization for string\nGeneric type\n</code></pre>\n<p>Note that the specialization for <code>char</code> arrays is not invoked, even though <code>decltype(abc)</code> should produce the type <code>const char[4]</code>.</p>\n<p>I thought that perhaps some type of type decay was occurring, so I added in a specialization for <code>const char*</code>, but it still wasn't selected.</p>\n<p>So, why does the expression:</p>\n<pre><code>select_type&lt;decltype(\"abc\")&gt;::action();\n</code></pre>\n<p>fail to invoke the specialization for <code>const char[N]</code>?</p>\n", "AcceptedAnswerId": "28266104", "Title": "Selecting string literal type for template specialization", "CreationDate": "2015-02-01T18:05:34.710", "Id": "28265984", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-02-01T18:17:13.950", "Score": "1", "OwnerUserId": "2923952", "Tags": "<c++><templates>", "AnswerCount": "1"}});