post_cb({"28265984": {"CommentCount": "0", "ViewCount": "592", "CreationDate": "2015-02-01T18:05:34.710", "LastActivityDate": "2015-02-01T18:17:13.950", "Title": "Selecting string literal type for template specialization", "AcceptedAnswerId": "28266104", "PostTypeId": "1", "Id": "28265984", "Score": "1", "Body": "<p>I'm trying to use template specialization so that I can have specialized behavior for different types.  However, I'm unable to get a template specialization for a string literal type (<code>const char[N]</code>) to bind to the specialized template.</p>\n<p>I have a simple template <code>select_type&lt;T&gt;</code>, with the following specializations:</p>\n<pre><code>template &lt;class T&gt;\nstruct select_type\n{\n    static void action()\n    {\n        cout &lt;&lt; \"Generic type\" &lt;&lt; endl;\n    }\n};\n\ntemplate &lt;&gt;\nstruct select_type&lt;std::string&gt;\n{\n    static void action()\n    {\n        cout &lt;&lt; \"Specialization for string\" &lt;&lt; endl;\n    }\n};\n\ntemplate &lt;std::size_t N&gt;\nstruct select_type&lt;const char[N]&gt;\n{\n    static void action()\n    {\n        cout &lt;&lt; \"Specialization for const char array\" &lt;&lt; endl;\n    }\n};\n</code></pre>\n<p>When I attempt to instantiate each specialization as follows:</p>\n<pre><code>select_type&lt;int&gt;::action();\nselect_type&lt;std::string&gt;::action();\nselect_type&lt;decltype(\"abc\")&gt;::action();\n</code></pre>\n<p>... I get the following output:</p>\n<pre><code>Generic type\nSpecialization for string\nGeneric type\n</code></pre>\n<p>Note that the specialization for <code>char</code> arrays is not invoked, even though <code>decltype(abc)</code> should produce the type <code>const char[4]</code>.</p>\n<p>I thought that perhaps some type of type decay was occurring, so I added in a specialization for <code>const char*</code>, but it still wasn't selected.</p>\n<p>So, why does the expression:</p>\n<pre><code>select_type&lt;decltype(\"abc\")&gt;::action();\n</code></pre>\n<p>fail to invoke the specialization for <code>const char[N]</code>?</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "2923952", "AnswerCount": "1"}, "28266104": {"ParentId": "28265984", "CommentCount": "0", "Body": "<p>You are seeing this behavior because of how <code>decltype</code> deduces the type. String literals are lvalues. From [expr.prim.general]/p1:</p>\n<blockquote>\n<p id=\"so_28265984_28266104_0\">A string literal is an lvalue; all other literals are prvalues.</p>\n</blockquote>\n<p><code>decltype()</code> returns an lvalue-reference type for lvalues. [dcl.type.simple]/p4</p>\n<blockquote>\n<p id=\"so_28265984_28266104_1\">For an expression <code>e</code>, the type denoted by <code>decltype(e)</code> is defined as follows:</p>\n<p id=\"so_28265984_28266104_2\">(4.1) \u2014 if <code>e</code> is an unparenthesized id-expression or an unparenthesized class member access (5.2.5), <code>decltype(e)</code> is the type of the entity named by <code>e</code>. If there is no such entity, or if <code>e</code> names a set of overloaded functions,\n  the program is ill-formed;</p>\n<p id=\"so_28265984_28266104_3\">(4.2) \u2014 otherwise, if <code>e</code> is an xvalue, <code>decltype(e)</code> is <code>T&amp;&amp;</code>, where <code>T</code> is the type of <code>e</code>;</p>\n<p id=\"so_28265984_28266104_4\">(4.3) \u2014 <strong>otherwise, if <code>e</code> is an lvalue, <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code> is the type of <code>e</code>;</strong></p>\n<p id=\"so_28265984_28266104_5\">(4.4) \u2014 otherwise, <code>decltype(e)</code> is the type of <code>e</code>.</p>\n</blockquote>\n<p>So your specialization needs to be as follows:</p>\n<pre><code>template &lt;std::size_t N&gt;\nstruct select_type&lt;const char (&amp;)[N]&gt;\n</code></pre>\n", "OwnerUserId": "701092", "PostTypeId": "2", "Id": "28266104", "Score": "3", "CreationDate": "2015-02-01T18:17:13.950", "LastActivityDate": "2015-02-01T18:17:13.950"}, "bq_ids": {"n4140": {"so_28265984_28266104_3": {"section_id": 5440, "quality": 1.0, "length": 5}, "so_28265984_28266104_1": {"section_id": 5440, "quality": 0.8571428571428571, "length": 6}, "so_28265984_28266104_2": {"section_id": 5440, "quality": 0.9473684210526315, "length": 18}, "so_28265984_28266104_0": {"section_id": 5947, "quality": 1.0, "length": 7}, "so_28265984_28266104_4": {"section_id": 5440, "quality": 1.0, "length": 5}}, "n3337": {"so_28265984_28266104_3": {"section_id": 5235, "quality": 1.0, "length": 5}, "so_28265984_28266104_1": {"section_id": 5235, "quality": 0.7142857142857143, "length": 5}, "so_28265984_28266104_2": {"section_id": 5235, "quality": 0.9473684210526315, "length": 18}, "so_28265984_28266104_0": {"section_id": 5717, "quality": 1.0, "length": 7}, "so_28265984_28266104_4": {"section_id": 5235, "quality": 1.0, "length": 5}}, "n4659": {"so_28265984_28266104_3": {"section_id": 6867, "quality": 1.0, "length": 5}, "so_28265984_28266104_1": {"section_id": 6867, "quality": 0.8571428571428571, "length": 6}, "so_28265984_28266104_2": {"section_id": 6867, "quality": 0.9473684210526315, "length": 18}, "so_28265984_28266104_0": {"section_id": 7433, "quality": 1.0, "length": 7}, "so_28265984_28266104_4": {"section_id": 6867, "quality": 1.0, "length": 5}}}});