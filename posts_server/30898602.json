post_cb({"bq_ids": {"n4140": {"so_30898602_30900449_5": {"length": 19, "quality": 1.0, "section_id": 653}, "so_30898602_30900449_3": {"length": 19, "quality": 1.0, "section_id": 653}}, "n3337": {"so_30898602_30900449_5": {"length": 19, "quality": 1.0, "section_id": 643}, "so_30898602_30900449_3": {"length": 19, "quality": 1.0, "section_id": 643}}, "n4659": {"so_30898602_30900449_5": {"length": 19, "quality": 1.0, "section_id": 681}, "so_30898602_30900449_0": {"length": 65, "quality": 0.9420289855072463, "section_id": 318}, "so_30898602_30900449_3": {"length": 19, "quality": 1.0, "section_id": 681}}}, "30898602": {"ViewCount": "255", "Body": "<p>The following simplified example compiles in <code>gcc</code> and <code>Visual Studio</code>, but fails in <code>clang</code> !?</p>\n<pre><code>namespace N\n{\n    struct A {};\n\n    template &lt;typename T&gt;\n    double operator+ (T a, double d) {return d;}\n\n    template &lt;typename T&gt;\n    double operator+ (double d, T a) {return d;}\n}\n\nvoid test()\n{\n    N::A a;\n    double x;\n\n    double y = a + x;\n    double z = x + a;\n}\n</code></pre>\n<p>As I see it, the templated <code>operator+</code> in namespace <code>N</code> should be found by ADL.</p>\n<p>Why does <code>clang</code> disagree ? Is it a bug in <code>clang</code> or in the other compilers ?</p>\n<p>Here is the compilation error from clang 3.5.1 (tested on coliru), I don't understand what is the problem here...</p>\n<pre><code>10 : error: overloaded 'operator+' must have at least one parameter of class or enumeration type\ndouble operator+ (double d, T a) {return d;}\n^\n18 : note: in instantiation of function template specialization 'N::operator+' requested here\ndouble y = a + x;\n^\n\n7 : error: overloaded 'operator+' must have at least one parameter of class or enumeration type\ndouble operator+ (T a, double d) {return d;}\n^\n19 : note: in instantiation of function template specialization 'N::operator+' requested here\ndouble z = x + a;\n^\n\n2 errors generated.\nCompilation failed\n</code></pre>\n<p>The example is simplified from real life code, of course. The intention is that any class defined inside namespace N has an overloaded operator+ with a double.</p>\n", "AcceptedAnswerId": "30900449", "Title": "C++ operator overloading and associated namespace", "CreationDate": "2015-06-17T17:39:12.650", "Id": "30898602", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-12-15T02:44:10.327", "LastEditorUserId": "1459996", "LastActivityDate": "2016-12-15T02:44:10.327", "Score": "5", "OwnerUserId": "1029366", "Tags": "<c++><namespaces><operator-overloading><clang><argument-dependent-lookup>", "AnswerCount": "2"}, "30900449": {"Id": "30900449", "PostTypeId": "2", "Body": "<p>This is caused by two different CWG issues: <a href=\"http://wg21.link/cwg2052\" rel=\"nofollow\">CWG issue 2052</a> and <a href=\"http://wg21.link/cwg1391\" rel=\"nofollow\">CWG issue 1391</a>.</p>\n<p>First, CWG 1391. On encountering <code>x + a</code>, the usual name lookup finds, among other overloads, </p>\n<pre><code>template &lt;typename T&gt; double operator+ (T, double);\n</code></pre>\n<p>Template argument deduction is performed by match <code>T</code> to the type of the lhs of <code>+</code>, which is <code>double</code>, so this deduces <code>T</code> to be <code>double</code>. The second parameter's type contains no template parameter, so is not considered under current rules. To be sure, <code>N::A</code> can't be converted to a <code>double</code>, so the resulting specialization is not viable, but the current rules say that template argument deduction doesn't care about this; that will be handled in overload resolution.</p>\n<p>The proposed resolution to CWG 1391, among other things, adds a new paragraph to the standard:</p>\n<blockquote>\n<p id=\"so_30898602_30900449_0\">If deduction succeeds for all parameters that contain\n  template-parameters that participate in template argument deduction,\n  and all template arguments are explicitly specified, deduced, or\n  obtained from default template arguments, remaining parameters are\n  then compared with the corresponding arguments. For each remaining\n  parameter <code>P</code> with a type that was non-dependent before substitution of\n  any explicitly-specified template arguments, if the corresponding\n  argument A cannot be implicitly converted to <code>P</code>, deduction fails.\n  [<em>Note</em>: Parameters with dependent types in which no template-parameters\n  participate in template argument deduction, and parameters that became\n  non-dependent due to substitution of explicitly-specified template\n  arguments, will be checked during overload resolution. \u2014<em>end note</em>]</p>\n</blockquote>\n<p>In other words, if an argument (<code>a</code> in our case) corresponding to a non-dependent parameter (<code>double</code>) cannot be converted to the parameter's type, deduction would simply fail. So in our case, post-CWG1391 template argument deduction will fail for this overload, and everything would be well.</p>\n<p>Clang implements the current rules, however, so deduction succeeds with <code>T = double</code>, substitution occurs, and we encounter CWG 2052. Quoting the writeup from Richard Smith (a Clang dev):</p>\n<blockquote>\n<p id=\"so_30898602_30900449_1\">In an example like</p>\n<pre><code>  struct A { operator int(); };\n  template&lt;typename T&gt; T operator&lt;&lt;(T, int);\n  void f(A a) { 1 &lt;&lt; a; }\n</code></pre>\n<p id=\"so_30898602_30900449_2\">Template argument deduction succeeds for the operator template,\n  producing the signature <code>operator&lt;&lt;(int,int)</code>. The resulting\n  declaration is synthesized and added to the overload set, per 14.8.3\n  [temp.over] paragraph 1. However, this violates the requirement of\n  13.5 [over.oper] paragraph 6,</p>\n<blockquote>\n<p id=\"so_30898602_30900449_5\">An operator function shall either be a non-static member function or\n    be a non-member function that has at least one parameter whose type is\n    a class, a reference to a class, an enumeration, or a reference to an\n    enumeration.</p>\n</blockquote>\n<p id=\"so_30898602_30900449_4\">This is not a SFINAE context, so the program is ill-formed, rather\n  than selecting the built-in operator.</p>\n</blockquote>\n<p>In this case, there's no conversion, so the deduced <code>operator+(double, double)</code> is actually not viable, but non-viable candidates are not eliminated until you have built the candidate set, and here building the candidate set is causing a hard error.</p>\n<p>The proposed resolution to CWG 2052 will make this case SFINAE instead - also making the original code work. The problem is - Clang is implementing the current version of the standard here, too.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2015-06-18T02:29:30.427", "Score": "4", "CreationDate": "2015-06-17T19:16:33.993", "ParentId": "30898602", "CommentCount": "6", "OwnerUserId": "2756719", "LastEditDate": "2015-06-18T02:29:30.427"}, "30898911": {"Id": "30898911", "PostTypeId": "2", "Body": "<p>It might be complaining because <code>T</code> <em>might</em> not be a class in that definition. And you are not allowed to redefine the standard <code>operator+</code> for arithmetic types IIRC. In your example, there's nothing restricting <code>T</code> to be <code>N::A</code> for instance.</p>\n<p>Adding <code>typename = std::enable_if_t&lt;std::is_class&lt;T&gt;{} || std::is_enum&lt;T&gt;{}&gt;</code> seems to fix it. Visual Studio and GCC might be a bit more lax/lazy about this restriction.</p>\n<pre><code>namespace N\n{\n    struct A {};\n\n    template &lt;typename T, typename = std::enable_if_t&lt;std::is_class&lt;T&gt;{} || std::is_enum&lt;T&gt;{}&gt;&gt;\n    double operator+ (T a, double d) {return d;}\n\n    template &lt;typename T, typename = std::enable_if_t&lt;std::is_class&lt;T&gt;{} || std::is_enum&lt;T&gt;{}&gt;&gt;\n    double operator+ (double d, T a) {return d;}\n}\n\n void test()\n {\n    N::A a;\n    double x;\n\n    double y = a + x;\n    double z = x + a;\n }\n</code></pre>\n", "LastEditorUserId": "3973558", "LastActivityDate": "2015-06-18T19:08:19.943", "Score": "2", "CreationDate": "2015-06-17T17:57:00.513", "ParentId": "30898602", "CommentCount": "6", "OwnerUserId": "3973558", "LastEditDate": "2015-06-18T19:08:19.943"}});