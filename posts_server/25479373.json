post_cb({"bq_ids": {"n4140": {"so_25479373_25479567_3": {"length": 7, "quality": 0.875, "section_id": 5923}, "so_25479373_25479567_0": {"length": 42, "quality": 0.8235294117647058, "section_id": 5873}, "so_25479373_25479567_1": {"length": 47, "quality": 0.9038461538461539, "section_id": 5873}, "so_25479373_25479567_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 5921}}, "n3337": {"so_25479373_25479567_3": {"length": 7, "quality": 0.875, "section_id": 5695}, "so_25479373_25479567_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 5693}, "so_25479373_25479567_1": {"length": 47, "quality": 0.9038461538461539, "section_id": 5644}, "so_25479373_25479567_0": {"length": 42, "quality": 0.8235294117647058, "section_id": 5644}}, "n4659": {"so_25479373_25479567_3": {"length": 7, "quality": 0.875, "section_id": 7397}, "so_25479373_25479567_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 7395}, "so_25479373_25479567_1": {"length": 47, "quality": 0.9038461538461539, "section_id": 7356}, "so_25479373_25479567_0": {"length": 42, "quality": 0.8235294117647058, "section_id": 7356}}}, "25479567": {"Id": "25479567", "PostTypeId": "2", "Body": "<ul>\n<li>Within a given accessibility block, the order of members is preserved, but between accessibility blocks member order is unspecified in C++03. This means that a1, a2, a5, z, a3, a4 would be a valid order in your example above.</li>\n<li>In C++11 this is strengthened such that members with the same accessibility must be placed in declared order. (e.g. this bans a5 a1 a2 f a3 a4 in your example because a5 is declared after a1 and a2 in your example) Order between members with different accessibility is unspecified.</li>\n<li>The compiler may insert padding between any member (e.g. in order to maintain alignment)</li>\n<li>The representation of bit fields is unspecified. They may be placed in any order and do not respect any of the previous rules. Because you cannot take the address of a bit field, there is no mechanism to observe this.</li>\n</ul>\n<p>Specific standard references (emphasis mine):</p>\n<p>C++03 9.2 [class.mem]/12:</p>\n<blockquote>\n<p id=\"so_25479373_25479567_0\">Nonstatic data members of a (non-union) class <strong>declared without an intervening access-specifier</strong> are allocated so that later members have higher addresses within a class object. The order of allocation of nonstatic data members separated by an access-specifier is unspecified (11.1). Implementation alignment requirements might cause two adjacent members not to be allocated immediately after each other; so might requirements for space for managing virtual functions (10.3) and virtual base classes (10.1).</p>\n</blockquote>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf\" rel=\"nofollow\">N3376</a> (the first post C++11 draft) 9.2 [class.mem]/13:</p>\n<blockquote>\n<p id=\"so_25479373_25479567_1\">Nonstatic data members of a (non-union) class <strong>with the same access control</strong> (Clause 11) are allocated so that later members have higher addresses within a class object. The order of allocation of non-static data members with di\ufb00erent access control is unspeci\ufb01ed. Implementation alignment requirements might cause two adjacent members not to be allocated immediately after each other; so might requirements for space for managing virtual functions (10.3) and virtual base classes (10.1).</p>\n</blockquote>\n<p>N3376 9.6 [class.bit]/1:</p>\n<blockquote>\n<p id=\"so_25479373_25479567_2\">[...] Allocation of bit-fields within a class object is implementation-defined. Alignment of bit-fields is implementation-defined. [...]</p>\n</blockquote>\n<p>/3:</p>\n<blockquote>\n<p id=\"so_25479373_25479567_3\">[...] The address-of operator &amp; shall not be applied to a bit-field, so there are no pointers to bitfields. [...]</p>\n</blockquote>\n", "LastEditorUserId": "82320", "LastActivityDate": "2014-08-25T06:05:09.690", "Score": "8", "CreationDate": "2014-08-25T05:35:37.093", "ParentId": "25479373", "CommentCount": "0", "OwnerUserId": "82320", "LastEditDate": "2014-08-25T06:05:09.690"}, "25479373": {"ViewCount": "1748", "Body": "<p>In a class, are private members allocated in separate memory from public members, or all members allocated in the sequence of their definition?</p>\n<p>For example, </p>\n<pre><code>class A { \n\nprivate:  \n    int a1;\n    int a2:3;  \npublic:  \n    int z;  \n    int a3:2;  \n    int a4:5;  \nprivate:\n    int a5:2;\n}\n</code></pre>\n<p>Are <code>a1</code>, <code>a2</code>, and <code>a5</code> clubbed together for memory allocation or is it simply <code>a1</code>, <code>a2</code>, <code>a3</code>, <code>a4</code>, <code>a5</code> ?  </p>\n<p>If clubbing happens it might change the size of the class in case of bit fields.</p>\n", "AcceptedAnswerId": "25479567", "Title": "How memory is allocated for private and public members of the class", "CreationDate": "2014-08-25T05:11:36.987", "Id": "25479373", "CommentCount": "7", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-08-25T05:22:38.223", "LastEditorUserId": "1530508", "LastActivityDate": "2014-08-25T06:08:39.843", "Score": "10", "OwnerUserId": "1660982", "Tags": "<c++><class>", "AnswerCount": "2"}, "25479383": {"Id": "25479383", "PostTypeId": "2", "Body": "<p><strong>C++ answer:</strong></p>\n<p>I may miss something and if I do please post a comment.</p>\n<p>In C++ Objects are laid on based on the type of class. In the standard, I believe only a few types of classes guarantee ordering of members.</p>\n<p>POD or Plain Old Data classes/structs are laid out exactly as they appear. With each member following the ones declared above with added padding. POD classes/structs are ones that do not contain any access modifiers, do not have any user defined constructor/desctructor. Has no statically declared members, and contains only POD member types.</p>\n<p>Ex:</p>\n<pre><code>struct POD {\n    int x;\n    int y;\n    int z;\n};\n</code></pre>\n<p>Most other types of classes do not define how members are laid out in memory. A compiler is free to place members how it sees fit if a class/struct has multiple access modifiers. Again C++ should be similar to Java in that you shouldn't really care much about how it is laid out for most cases that do not involve working with hardware.</p>\n<p>The following was added before the java tag was removed, but remains for future reference.</p>\n<p><strong>Java answer:</strong></p>\n<p>Java makes no guarantee on how an object is laid out in memory, and you shouldn't care. The JVM is free to layout an object how ever it likes in memory. This means that Objects don't have to even be in consecutive memory.</p>\n<p>Now this isn't done in any JVMs that I am aware of. A much better guess would be that it lays out Objects similar to how they are done in C++. Where each parent class members are placed before the child members, and that each member within a class is laid out consecutively based on size with the needed padding.</p>\n<p>If you want to inspect how a particular Object is laid out in memory you could use reflection along with the <a href=\"http://www.docjar.com/docs/api/sun/misc/Unsafe.html\" rel=\"nofollow\">sun.misc.Unsafe</a> class.</p>\n", "LastEditorUserId": "3935776", "LastActivityDate": "2014-08-25T05:46:51.967", "Score": "5", "CreationDate": "2014-08-25T05:13:21.727", "ParentId": "25479373", "CommentCount": "5", "OwnerUserId": "3935776", "LastEditDate": "2014-08-25T05:46:51.967"}});