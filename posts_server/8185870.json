post_cb({"bq_ids": {"n4140": {"so_8185870_8185972_0": {"length": 19, "quality": 1.0, "section_id": 72}}, "n3337": {"so_8185870_8185972_0": {"length": 19, "quality": 1.0, "section_id": 67}}}, "8185870": {"ViewCount": "785", "Body": "<p>I want to define <code>std::tr1::hash&lt;boost::tuple&lt;A,B,C&gt; &gt;</code>.  But I get an error that doesn't appear when I give a complete instantation.  Here's the code</p>\n<pre><code>namespace std{\n\nnamespace tr1{\ntemplate&lt;typename A, typename B, typename C&gt;\nstruct hash&lt;boost::tuple&lt;A,B,C&gt; &gt;{\n    size_t operator()(const boost::tuple&lt;A,B,C&gt; &amp;t) const{\n        size_t seed = 0;\n        boost::hash_combine(seed, t.get&lt;0&gt;());\n        boost::hash_combine(seed, t.get&lt;1&gt;());\n        boost::hash_combine(seed, t.get&lt;2&gt;());\n        return seed;\n    }\n};\n\ntemplate&lt;&gt;\nstruct hash&lt;boost::tuple&lt;int,int,int&gt; &gt;{\n    size_t operator()(const boost::tuple&lt;int,int,int&gt; &amp;t) const{\n        size_t seed = 0;\n        boost::hash_combine(seed, t.get&lt;0&gt;());\n        boost::hash_combine(seed, t.get&lt;1&gt;());\n        boost::hash_combine(seed, t.get&lt;2&gt;());\n        return seed;\n    }\n};\n}\n}\n</code></pre>\n<p>The first piece gives this error</p>\n<pre><code>unordered.hpp: In member function 'size_t std::tr1::hash&lt;boost::tuples::tuple&lt;A, B, C, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type&gt; &gt;::operator()(const boost::tuples::tuple&lt;A, B, C, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type, boost::tuples::null_type&gt;&amp;) const':\nunordered.hpp:12: error: expected primary-expression before ')' token\nunordered.hpp:13: error: expected primary-expression before ')' token\nunordered.hpp:14: error: expected primary-expression before ')' token\n</code></pre>\n<p>and the second compiles just fine.  What's wrong with the first template?  I'm using gcc 4.3.4.</p>\n", "AcceptedAnswerId": "8185972", "Title": "Using boost::tuple in tr1::hash", "CreationDate": "2011-11-18T16:48:18.167", "Id": "8185870", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2011-11-18T17:45:54.897", "Score": "8", "OwnerUserId": "189456", "Tags": "<c++><templates>", "AnswerCount": "2"}, "8185972": {"PostTypeId": "2", "Body": "<p>You need to use the <code>.template</code> keyword:</p>\n<pre><code>template&lt;typename A, typename B, typename C&gt;\nstruct hash&lt;boost::tuple&lt;A,B,C&gt; &gt;{\n    size_t operator()(const boost::tuple&lt;A,B,C&gt; &amp;t) const{\n        size_t seed = 0;\n        boost::hash_combine(seed, t.template get&lt;0&gt;());\n        boost::hash_combine(seed, t.template get&lt;1&gt;());\n        boost::hash_combine(seed, t.template get&lt;2&gt;());\n        return seed;\n    }\n};\n</code></pre>\n<p>This is required because type of <code>t</code> depends on three template paramaters (and so <code>t</code> is type-dependent), and <code>get&lt;0&gt;</code> is the name of a template specialization. From the C++ standard -- <code>\u00a714.2/4</code>:</p>\n<blockquote>\n<p id=\"so_8185870_8185972_0\">When the name of a member template specialization appears after . or -&gt; in a postfix-expression ... and the object expression of the postfix-expression is type-dependent ... the member template name must be prefixed by the keyword template. ...</p>\n</blockquote>\n<p>This requirement exists to allow templates to be parsed before their type arguments are known.</p>\n<p>For example, consider:</p>\n<pre><code>f . set &lt; 0 &gt; ( 2 == 3 )\n</code></pre>\n<p>Without the <code>.template</code> rule, this could interpreted as two different things:</p>\n<pre><code>//A call to an instantiation of a member function template\n//in this case equivalent to f.template set&lt;0&gt;(false)\nf.set&lt;0&gt;(2 == 3)\n//A series of comparison operations, in this case equivalent to\n//f.set &lt; 0\nf.set &lt; 0 &gt; (2 == 3)\n</code></pre>\n<p>The actual rules allow <code>f . set &lt; 0 &gt; ( 2 == 3 )</code> to be unambiguously parsed as a series of comparison operations. They also mean that <code>t.get&lt;0&gt;()</code> is parsed as <code>t.get &lt; 0 &gt; ()</code>. The <code>expected primary-expression</code> is meant to be in the empty <code>()</code>.</p>\n", "LastActivityDate": "2011-11-18T17:45:54.897", "LastEditorUserId": "485561", "Id": "8185972", "CommentCount": "0", "CreationDate": "2011-11-18T16:55:29.913", "ParentId": "8185870", "Score": "8", "OwnerUserId": "485561", "LastEditDate": "2011-11-18T17:45:54.897"}, "8185940": {"PostTypeId": "2", "Body": "<p>I don't have time to check things but I'd expect either</p>\n<pre><code>std::get&lt;0&gt;(t)\n</code></pre>\n<p>or</p>\n<pre><code>boost::get&lt;0&gt;(t)\n</code></pre>\n<p>instead of <code>t.get&lt;0&gt;()</code></p>\n<p><strong>Do</strong> <em>qualify</em> get() even if you are 'using' namespaces, or ADL will hurt you badly when mixing libraries like this. See <a href=\"https://stackoverflow.com/questions/2958648/what-are-the-pitfalls-of-adl\">What are the pitfalls of ADL?</a></p>\n", "LastActivityDate": "2011-11-18T16:58:21.983", "LastEditorUserId": "-1", "Id": "8185940", "CommentCount": "2", "CreationDate": "2011-11-18T16:53:21.093", "ParentId": "8185870", "Score": "6", "OwnerUserId": "85371", "LastEditDate": "2017-05-23T10:24:22.033"}});