post_cb({"43982799": {"ViewCount": "497", "Body": "<p>I have discovered a code snippet that compiles and works properly in <strong>clang++ 4 (and trunk)</strong> but fails to compile in <strong>g++ 7 (and trunk)</strong>. Let's assume I have the following <code>struct</code> types:</p>\n<pre><code>struct a { void foo() { } };\nstruct b { void bar() { } };\nstruct c { void bar() { } };\n</code></pre>\n<p>I want to create an <em>overload set</em> out of lambdas which handles <code>a</code> explicitly, while <code>b</code> and <code>c</code> are \"caught\" with a generic lambda using an <code>auto</code> parameter:</p>\n<pre><code>auto ol = overload([](a x)   { x.foo(); },\n                   [](auto x){ x.bar(); })\n</code></pre>\n<p>When I invoke <code>ol(a{})</code>:</p>\n<ul>\n<li><p><strong>clang++</strong> compiles and behaves as expected: <code>a</code> \"matches\" the first lambda, while <code>b</code> and <code>c</code> match the second one.</p></li>\n<li><p><strong>g++</strong> fails to compile, with the following error:</p>\n<pre><code>error: 'struct a' has no member named 'bar'\n           [](auto x){ x.bar(); };\n                       ~~^~~\n</code></pre>\n<p>It seems that the compiler tries to instantiate the second lambda even though the first one is a way better match. Hopefully this is a bug, as it seems unintuitive to me.</p></li>\n</ul>\n<hr>\n<p>Note both compilers work properly if instead of <em>lambda expressions</em> I use some old-fashioned <code>struct</code> instances:</p>\n<pre><code>struct s0\n{\n    auto operator()(a x) const { x.foo(); }\n};\n\nstruct s1\n{\n    template &lt;typename T&gt;\n    auto operator()(T x) const { x.bar(); }\n};\n\nauto os = overload(s0{}, s1{});\nos(a{}); // OK!\n</code></pre>\n<p>I would expect the lambdas to be roughly equivalent to <code>s0</code> and <code>s1</code>, so this is even more surprising.</p>\n<hr>\n<p>This is the way I'm producing the overload set:</p>\n<pre><code>template &lt;typename... Fs&gt;\nstruct overloader : Fs...\n{\n    template &lt;typename... FFwds&gt;\n    overloader(FFwds&amp;&amp;... fs) : Fs{std::forward&lt;FFwds&gt;(fs)}...\n    {\n    }\n\n    using Fs::operator()...;\n};\n\ntemplate &lt;typename... Fs&gt;\nauto overload(Fs&amp;&amp;... fs)\n{\n    return overloader&lt;std::decay_t&lt;Fs&gt;...&gt;{std::forward&lt;Fs&gt;(fs)...};\n}\n</code></pre>\n<p>And here's a <a href=\"https://godbolt.org/g/maHfcb\" rel=\"noreferrer\"><strong>live example on <code>gcc.godbolt.org</code></strong></a>, showing the different behavior between the compilers.</p>\n<hr>\n<p><strong>Is this a g++ bug?</strong> Or is there something in the standard that makes lambdas behave differently from <code>struct</code> instances in this situation?</p>\n</hr></hr></hr>", "AcceptedAnswerId": "43983372", "Title": "Overloading structs with template call operator and generic lambdas - gcc vs clang", "CreationDate": "2017-05-15T15:02:51.767", "Id": "43982799", "CommentCount": "3", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2017-05-15T15:46:31.897", "Score": "11", "OwnerUserId": "598696", "Tags": "<c++><lambda><overloading><language-lawyer><c++1z>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_43982799_43983372_0": {"length": 19, "quality": 0.76, "section_id": 243}}, "n3337": {"so_43982799_43983372_0": {"length": 17, "quality": 0.68, "section_id": 235}}, "n4659": {"so_43982799_43983372_0": {"length": 25, "quality": 1.0, "section_id": 250}}}, "43983372": {"Id": "43983372", "PostTypeId": "2", "Body": "<p>I think this is a gcc bug (submitted as <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=80767\" rel=\"noreferrer\">80767</a>), running afoul of <a href=\"http://eel.is/c++draft/temp.inst#9\" rel=\"noreferrer\">[temp.inst]/9</a>:</p>\n<blockquote>\n<p id=\"so_43982799_43983372_0\">An implementation shall not implicitly instantiate a function template, a variable template, a member template, a non-virtual member function, a member class, a static data member of a class template, or a substatement of a constexpr if statement, unless such instantiation is required.</p>\n</blockquote>\n<p>The instantiation of the generic lambda's <code>operator()</code> with <code>auto = a</code> is not required, hence it should not be instantiated. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-05-15T15:46:31.897", "Score": "7", "CreationDate": "2017-05-15T15:29:40.353", "ParentId": "43982799", "CommentCount": "1", "OwnerUserId": "2069064", "LastEditDate": "2017-05-15T15:46:31.897"}});