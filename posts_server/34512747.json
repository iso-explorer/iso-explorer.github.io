post_cb({"34512785": {"ParentId": "34512747", "LastEditDate": "2017-05-23T10:28:36.953", "CommentCount": "14", "CreationDate": "2015-12-29T14:09:59.213", "OwnerUserId": "5322470", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "34512785", "Score": "11", "Body": "<p>As many answers have already mentioned, they should not be thought of as memory addresses. Check out those answers <a href=\"https://stackoverflow.com/questions/15151377/what-exactly-is-a-c-pointer-if-not-a-memory-address\">and here</a> to get an understanding of them. Addressing your last statement </p>\n<blockquote>\n<p id=\"so_34512747_34512785_0\">*p1 and *p2 have the property p2 = p1 + 1 or p1 = p2 + 1 if and only if they are adjacent in physical memory</p>\n</blockquote>\n<p>is only correct if <code>p1</code> and <code>p2</code> are of the same type, or pointing to types of the same size.</p>\n", "LastActivityDate": "2015-12-29T15:57:38.007"}, "34513413": {"ParentId": "34512747", "CommentCount": "4", "Body": "<p><strong>Not at all.</strong></p>\n<p>C++ is an abstraction over the code that your computer will perform. We see this abstraction leak in a few places (class member references requiring storage, for example) but in general you will be better off if you code to the abstraction and nothing else.</p>\n<p>Pointers are pointers. They point to things. Will they be implemented as memory addresses in reality? Maybe. They could also be optimised out, or (in the case of e.g. pointers-to-members) they could be somewhat more complex than a simple numeric address.</p>\n<p>When you start thinking of pointers as integers that map to addresses in memory, you begin to forget for example that it's <em>undefined</em> to hold a pointer to an object that doesn't exist (you can't just increment and decrement a pointer willy nilly to any memory address you like).</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "34513413", "Score": "16", "CreationDate": "2015-12-29T14:48:06.620", "LastActivityDate": "2015-12-29T14:48:06.620"}, "35002931": {"ParentId": "34512747", "CommentCount": "0", "Body": "<p>According to the C++14 Standard, [expr.unary.op]/3:</p>\n<blockquote>\n<p id=\"so_34512747_35002931_0\">The result of the unary <code>&amp;</code> operator is a pointer to its operand. The operand shall be an lvalue or a qualified-id. If the operand is a qualified-id naming a non-static member <code>m</code> of some class <code>C</code> with type <code>T</code>, the result has type \u201cpointer to member of class <code>C</code> of type <code>T</code>\u201d and is a prvalue designating <code>C::m</code>. Otherwise, if the type of the expression is <code>T</code>, the result has type \u201cpointer to T\u201d and is a prvalue <strong>that is the address of the designated object</strong> or a pointer to the designated function. [Note: In particular, <strong>the address of an object of type \u201ccv <code>T</code>\u201d is \u201cpointer to cv <code>T</code>\u201d</strong>, with the same cv-qualification. \u2014end note  ]</p>\n</blockquote>\n<p>So this says clearly and unambiguously that pointers to object type (i.e. a <code>T *</code>, where <code>T</code> is not a function type) hold addresses.</p>\n<hr>\n<p>\"address\" is defined by [intro.memory]/1:</p>\n<blockquote>\n<p id=\"so_34512747_35002931_1\">The memory available to a C++ program consists of one or more sequences of contiguous bytes. Every byte has a unique address.</p>\n</blockquote>\n<p>So an address may be anything which serves to uniquely identify a particular byte of memory. </p>\n<p><em>Note:</em> In the C++ standard terminology, <em>memory</em> only refers to space that is in use. It doesn't mean physical memory, or virtual memory, or anything like that. The memory is a disjoint set of allocations.</p>\n<hr>\n<p>It is important to bear in mind that, although one possible way of uniquely identifying each byte in memory is to assign a unique integer to each byte of physical or virtual memory,  that is not the only possible way. </p>\n<p>To avoid writing non-portable code it is good to avoid assuming that an address is identical to an integer.  The rules of arithmetic for pointers are different to the rules of arithmetic for integers anyway.   Similarly, we would not say that <code>5.0f</code> is the same as <code>1084227584</code> even though they have identical bit representations in memory (under IEEE754).</p>\n</hr></hr>", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "35002931", "Score": "0", "CreationDate": "2016-01-25T21:41:40.910", "LastActivityDate": "2016-01-25T21:41:40.910"}, "34513048": {"ParentId": "34512747", "CommentCount": "5", "Body": "<p>Somehow answers here fail to mention one specific family of pointers - that is, pointers-to-members. Those are <strong>certainly not</strong> memory addresses.</p>\n", "OwnerUserId": "5245033", "PostTypeId": "2", "Id": "34513048", "Score": "1", "CreationDate": "2015-12-29T14:26:13.997", "LastActivityDate": "2015-12-29T14:26:13.997"}, "34512915": {"ParentId": "34512747", "CommentCount": "0", "Body": "<p>Pointers are memory addresses, but you shouldn't assume they reflect physical address. When you see addresses like <code>0x00ffb500</code> those are logical addresses that the MMU will translate to the corresponding physical address. This is the most probable scenario, since virtual memory is the most extended memory management system, but there could be systems that manage physical address directly</p>\n", "OwnerUserId": "5057191", "PostTypeId": "2", "Id": "34512915", "Score": "0", "CreationDate": "2015-12-29T14:17:33.813", "LastActivityDate": "2015-12-29T14:17:33.813"}, "34512789": {"ParentId": "34512747", "LastEditDate": "2017-05-23T12:07:56.487", "CommentCount": "11", "CreationDate": "2015-12-29T14:10:14.387", "OwnerUserId": "2455888", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "34512789", "Score": "4", "Body": "<p>Like other variables, pointer stores a data which can be an address of memory where other data is stored.    </p>\n<p>So, pointer is a variable that have an address and may hold an address. </p>\n<p>Note that, <a href=\"https://stackoverflow.com/a/15151542/2455888\">it is not necessary that a pointer always holds an address</a>. It may hold a non-address ID/handle etc. Therefore, saying pointer as an address is not a wise thing.</p>\n<hr>\n<p>Regarding your second question:  </p>\n<p><a href=\"https://www.eskimo.com/~scs/cclass/notes/sx10b.html\" rel=\"nofollow noreferrer\">Pointer arithmetic</a> is valid for contiguous chunk of memory. If <code>p2 = p1 + 1</code> and both pointers are of same type then <code>p1</code> and <code>p2</code> points to a contiguous chunk of memory. So, the addresses <code>p1</code> and <code>p2</code> holds are adjacent to each other.</p>\n</hr>", "LastActivityDate": "2015-12-29T18:28:26.517"}, "bq_ids": {"n4140": {"so_34512747_35002931_0": {"section_id": 6066, "quality": 0.9, "length": 45}, "so_34512747_35002931_1": {"section_id": 5785, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_34512747_35002931_0": {"section_id": 5834, "quality": 0.9, "length": 45}, "so_34512747_35002931_1": {"section_id": 5558, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_34512747_35002931_0": {"section_id": 7562, "quality": 0.9, "length": 45}, "so_34512747_35002931_1": {"section_id": 7242, "quality": 0.9230769230769231, "length": 12}}}, "34512747": {"CommentCount": "25", "CreationDate": "2015-12-29T14:07:31.640", "PostTypeId": "1", "AcceptedAnswerId": "34512929", "LastEditorUserId": "417501", "LastActivityDate": "2017-05-28T15:06:43.500", "LastEditDate": "2015-12-29T14:27:26.170", "ViewCount": "2147", "FavoriteCount": "1", "Title": "To what extent is it acceptable to think of C++ pointers as memory addresses?", "Id": "34512747", "Score": "40", "Body": "<p>When you learn C++, or at least when I learned it through <em>C++ Primer</em>, pointers were termed the \"memory addresses\" of the elements they point to. I'm wondering to what extent this is true. </p>\n<p>For example, do two elements <code>*p1</code> and <code>*p2</code> have the property <code>p2 = p1 + 1</code> or <code>p1 = p2 + 1</code> <strong>if and only if</strong> they are adjacent in physical memory?</p>\n", "Tags": "<c++><pointers><hardware>", "OwnerUserId": "5648283", "AnswerCount": "12"}, "34512926": {"ParentId": "34512747", "CommentCount": "5", "Body": "<p>Absolutely right to think of pointers as memory addresses. That's what they are in ALL compilers that I have worked with - for a number of different processor architectures, manufactured by a number of different compiler producers. </p>\n<p>However, the compiler does some interesting magic, to help you along with the fact that normal memory addresses [in all modern mainstream processors at least] are byte-addresses, and the object your pointer refers to may not be exactly one byte. So if we have <code>T* ptr;</code>, <code>ptr++</code> will do <code>((char*)ptr) + sizeof(T);</code> or <code>ptr + n</code> is <code>((char*)ptr) + n*sizeof(T)</code>. This also means that your <code>p1 == p2 + 1</code> requires <code>p1</code> and <code>p2</code> to be of the same type <code>T</code>, since the <code>+1</code> is actually <code>+sizeof(T)*1</code>.</p>\n<p>There is ONE exception to the above \"pointers are memory addresses\", and that is member function pointers. They are \"special\", and for now, please just ignore how they are actually implemented, sufficient to say that they are not \"just memory addresses\".</p>\n", "OwnerUserId": "1919155", "PostTypeId": "2", "Id": "34512926", "Score": "5", "CreationDate": "2015-12-29T14:18:36.500", "LastActivityDate": "2015-12-29T14:18:36.500"}, "34515118": {"ParentId": "34512747", "LastEditDate": "2017-05-28T15:06:43.500", "CommentCount": "5", "CreationDate": "2015-12-29T16:32:08.170", "OwnerUserId": "179910", "LastEditorUserId": "179910", "PostTypeId": "2", "Id": "34515118", "Score": "3", "Body": "<p>I think <a href=\"https://stackoverflow.com/a/34513413\">this answer</a> has the right idea but poor terminology. What C pointers provide are the exact opposite of abstraction.</p>\n<p>An abstraction provides a mental model that's relatively easy to understand and reason about, even if the hardware is more complex and difficult to understand or harder to reason about.</p>\n<p>C pointers are the opposite of that. They take <em>possible</em> difficulties of the hardware into account even when though the real hardware is often simpler and easier to reason about. They limit your reasoning to what's allowed by a union of the most complex parts of the most complex hardware regardless of how simple the hardware at hand may actually be.</p>\n<p>C++ pointers add one thing that C doesn't include. It allows comparing all pointers of the same type for order, even if they're not in the same array. This allows a little more of a mental model, even if it doesn't match the hardware perfectly. </p>\n", "LastActivityDate": "2017-05-28T15:06:43.500"}, "34861711": {"ParentId": "34512747", "CommentCount": "0", "Body": "<p>The particular example you give:</p>\n<blockquote>\n<p id=\"so_34512747_34861711_0\">For example, do two elements *p1 and *p2 have the property p2 = p1 + 1 or p1 = p2 + 1 if and only if they are adjacent in physical memory?</p>\n</blockquote>\n<p>would fail on platforms that do not have a flat address space, such as the <a href=\"https://en.wikipedia.org/wiki/PIC_microcontroller\" rel=\"nofollow\">PIC</a>. To access physical memory on the PIC, you need both an address and a bank number, but the latter may be derived from extrinsic information such as the particular source file. So, doing arithmetic on pointers from different banks would give unexpected results.</p>\n", "OwnerUserId": "371739", "PostTypeId": "2", "Id": "34861711", "Score": "0", "CreationDate": "2016-01-18T18:36:20.217", "LastActivityDate": "2016-01-18T18:36:20.217"}, "34512929": {"ParentId": "34512747", "LastEditDate": "2015-12-29T16:57:53.010", "CommentCount": "5", "CreationDate": "2015-12-29T14:18:55.827", "OwnerUserId": "2380830", "LastEditorUserId": "2380830", "PostTypeId": "2", "Id": "34512929", "Score": "31", "Body": "<p>You should think of pointers as being addresses of <em>virtual</em> memory: modern operating systems place at least one layer of abstraction between physical memory and what you see as a pointer value.</p>\n<p>As for your final statement, you cannot make that assumption, even in a virtual memory address space. Pointer arithmetic is only valid within blocks of contiguous memory such as arrays. And whilst it is permissible (in both C and C++) to assign a pointer to one point past an array (or scalar), the behaviour on <em>deferencing</em> such a pointer is undefined. Hypothesising about adjacency in physical memory in the context of C and C++ is pointless.</p>\n", "LastActivityDate": "2015-12-29T16:57:53.010"}, "34515261": {"ParentId": "34512747", "CommentCount": "3", "Body": "<p>Unless pointers are optimized out by the compiler, they are integers that store memory addresses. Their lenght depends on the machine the code is being compiled for, but they can <strong>usually</strong> be treated as ints.</p>\n<p>In fact, you can check that out by printing the actual number stored on them with <code>printf()</code>.</p>\n<p>Beware, however, that <code>type *</code> pointer increment/decrement operations are done by the <code>sizeof(type)</code>. See for yourself with this code (tested online on Repl.it):</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    volatile int i1 = 1337;\n    volatile int i2 = 31337;\n    volatile double d1 = 1.337;\n    volatile double d2 = 31.337;\n    volatile int* pi = &amp;i1;\n    volatile double* pd = &amp;d1;\n    printf(\"ints: %d, %d\\ndoubles: %f, %f\\n\", i1, i2, d1, d2);\n    printf(\"0x%X = %d\\n\", pi, *pi);\n    printf(\"0x%X = %d\\n\", pi-1, *(pi-1));\n    printf(\"Difference: %d\\n\",(long)(pi)-(long)(pi-1));\n    printf(\"0x%X = %f\\n\", pd, *pd);\n    printf(\"0x%X = %f\\n\", pd-1, *(pd-1));\n    printf(\"Difference: %d\\n\",(long)(pd)-(long)(pd-1));\n}\n</code></pre>\n<p>All variables and pointers were declared volatile so as the compiler wouldn't optimize them out. Also notice that I used decrement, because the variables are placed in the function stack.</p>\n<p>The output was:</p>\n<pre><code>ints: 1337, 31337\ndoubles: 1.337000, 31.337000\n0xFAFF465C = 1337\n0xFAFF4658 = 31337\nDifference: 4\n0xFAFF4650 = 1.337000\n0xFAFF4648 = 31.337000\nDifference: 8\n</code></pre>\n<p>Note that this code may not work on all compilers, specially if they do not store variables in the same order. However, what's important is that the pointer values can actually be read and printed and that decrements of one may/will decrement based on the size of the variable the pointer references.</p>\n<p>Also note that the <code>&amp;</code> and <code>*</code> are actual operators for <strong>reference</strong> (\"get the memory address of this variable\") and <strong>dereference</strong> (\"get the contents of this memory address\").</p>\n<p>This may also be used for cool tricks like getting the IEEE 754 binary values for floats, by casting the <code>float*</code> as an <code>int*</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    float f = -9.5;\n    int* p = (int*)&amp;f;\n\n    std::cout &lt;&lt; \"Binary contents:\\n\";\n    int i = sizeof(f)*8;\n    while(i) {\n        i--;\n        std::cout &lt;&lt; ((*p &amp; (1 &lt;&lt; i))?1:0);\n   } \n}\n</code></pre>\n<p>Result is:</p>\n<pre><code>Binary contents:\n11000001000110000000000000000000 \n</code></pre>\n<p>Example taken from <a href=\"https://pt.wikipedia.org/wiki/IEEE_754\" rel=\"nofollow\">https://pt.wikipedia.org/wiki/IEEE_754</a>. Check out on any converter.</p>\n", "OwnerUserId": "3754432", "PostTypeId": "2", "Id": "34515261", "Score": "1", "CreationDate": "2015-12-29T16:42:03.417", "LastActivityDate": "2015-12-29T16:42:03.417"}, "34512939": {"ParentId": "34512747", "LastEditDate": "2015-12-29T14:26:09.623", "CommentCount": "0", "CreationDate": "2015-12-29T14:19:20.423", "OwnerUserId": "2896626", "LastEditorUserId": "2896626", "PostTypeId": "2", "Id": "34512939", "Score": "5", "Body": "<p>The operating system provides an abstraction of the physical machine to your program (i.e. your program runs in a virtual machine). Thus, your program does not have access to any physical resource of your computer, be it CPU time, memory, etc; it merely has to ask the OS for these resources.</p>\n<p>In the case of memory, your program works in a virtual address space, defined by the operating system. This address space has multiple regions, such as stack, heap, code, etc. The value of your pointers represent addresses in this virtual address space. Indeed, 2 pointers to consecutive addresses will point to consecutive locations in this address space.</p>\n<p>However, this address space is splitted by the operating system into pages and segments, which are swapped in and out from memory as required, so your pointers may or may not point to consecutive physical memory locations and is impossible to tell at runtime if that is true or not. This also depends on the policy used by the operating system for paging and segmentation.</p>\n<p>Bottom line is that pointers are memory addresses. However, they are addresses in a virtual memory space and it is up to the operating system to decide how this is mapped to the physical memory space.</p>\n<p>As far as your program is concerned, this is not an issue. One reason for this abstraction is to make programs believe they are the only users of the machine. Imagine the nightmare you'd have to go through if you would need to consider the memory allocated by other processes when you write your program - you don't even know which processes are going to run concurrently with yours. Also, this is a good technique to enforce security: your process cannot (well, at least shouldn't be able to) access maliciously the memory space of another process since they run in 2 different (virtual) memory spaces.</p>\n", "LastActivityDate": "2015-12-29T14:26:09.623"}});