post_cb({"bq_ids": {"n4140": {"so_29915596_29916211_1": {"length": 19, "quality": 0.7037037037037037, "section_id": 5850}, "so_29915596_29916211_0": {"length": 40, "quality": 1.0, "section_id": 5962}}, "n3337": {"so_29915596_29916211_1": {"length": 19, "quality": 0.7037037037037037, "section_id": 5620}, "so_29915596_29916211_0": {"length": 40, "quality": 1.0, "section_id": 5731}}, "n4659": {"so_29915596_29916211_0": {"length": 40, "quality": 1.0, "section_id": 7452}}}, "29915596": {"ViewCount": "165", "Body": "<p>I would like to know if the following leaks memory or not (specified by the standard)</p>\n<pre><code>...\njmp_buf env;\nif(setjmp(env) == 0) {\n    auto lambda = [&amp;] () {\n        ... \n        longjmp(env, 1);\n    };\n    lambda();\n}\n</code></pre>\n<p>which boils down to whether lambdas capturing by reference have a trivial destructor (I guess)?</p>\n<p>I know that this is probably wicked, but has to be done nevertheless.</p>\n", "AcceptedAnswerId": "29916211", "Title": "C++11 lambdas capturing by reference trivially destructible", "CreationDate": "2015-04-28T09:32:06.097", "Id": "29915596", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-04-28T11:12:09.417", "LastEditorUserId": "3959454", "LastActivityDate": "2015-04-28T11:12:09.417", "Score": "4", "OwnerUserId": "1514922", "Tags": "<c++><c++11><lambda><longjmp>", "AnswerCount": "1"}, "29916211": {"Id": "29916211", "PostTypeId": "2", "Body": "<p>It's implementation-specific. You may reasonably expect it to be true, but here's what the standard says (N4140, [expr.prim.lambda]/3, emphasis mine):</p>\n<blockquote>\n<p id=\"so_29915596_29916211_0\">An implementation may define the closure type differently from what is described below provided this does not alter the observable\n  behavior of the program other than by changing:<br>\n   \u2014 the size and/or alignment of the closure type,<br>\n   \u2014 <strong>whether the closure type is trivially copyable</strong> (Clause 9),<br>\n   \u2014 whether the closure type is a standard-layout class (Clause 9), or<br>\n   \u2014 whether the closure type is a POD class (Clause 9).</br></br></br></br></p>\n</blockquote>\n<p>And by definition in [class]/3 </p>\n<blockquote>\n<p id=\"so_29915596_29916211_1\">A <em>trivially copyable</em> class is a class that:<br>\n   \u2014 has no non-trivial copy constructors (12.8),<br>\n   \u2014 has no non-trivial move constructors (12.8),<br>\n   \u2014 has no non-trivial copy assignment operators (13.5.3, 12.8),<br>\n   \u2014 has no non-trivial move assignment operators (13.5.3, 12.8), and<br>\n   \u2014 <strong>has a trivial destructor</strong> (12.4).</br></br></br></br></br></p>\n</blockquote>\n<p>So, an implementation is allowed to create a non-trivial destructor for the lambda.</p>\n<p>However, you can check if your particluar implementation made your particular lambda trivially destructible by the following:</p>\n<pre><code>auto lambda = [&amp;]{ /*...*/ };\nstatic_assert(std::is_trivially_destructible&lt;decltype(lambda)&gt;::value, \"Lambda isn't trivially destructible\");\n</code></pre>\n", "LastEditorUserId": "3959454", "LastActivityDate": "2015-04-28T10:58:10.563", "Score": "4", "CreationDate": "2015-04-28T09:59:41.973", "ParentId": "29915596", "CommentCount": "2", "OwnerUserId": "3959454", "LastEditDate": "2015-04-28T10:58:10.563"}});