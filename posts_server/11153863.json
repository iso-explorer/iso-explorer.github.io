post_cb({"11153923": {"ParentId": "11153863", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>Do not call <code>delete this</code> in the destructor:</p>\n<blockquote>\n<p id=\"so_11153863_11153923_0\"><strong>5.3.5, Delete:</strong> If the value of the operand of the delete-expression is not a null pointer value, the delete-expression will\n  invoke the destructor (if any) for the object or the elements of the array being deleted.</p>\n</blockquote>\n<p>Therefore, you will have infinite recursion inside the destructor.</p>\n<p>Then:</p>\n<pre><code>if (p)\n    delete p;\n</code></pre>\n<p>the check for <code>p</code> being not null (<code>if (x)</code> in C++ means <code>if x != 0</code>) is superfluous. <code>delete</code> does that check already.</p>\n<p>This would be valid:</p>\n<pre><code>class Foo {\npublic:\n    Foo () : p(0) {}\n    ~Foo() { delete p; }\nprivate:\n    int *p;\n\n    // Handcrafting copy assignment for classes that store \n    // pointers is seriously non-trivial, so forbid copying:\n    Foo (Foo const&amp;) = delete;\n    Foo&amp; operator= (Foo const &amp;) = delete;\n};\n</code></pre>\n<p>Do not assume any builtin type, like <code>int</code>, <code>float</code> or pointer to something, to be initialized automatically, therefore, do not assume them to be <code>0</code> when not explicitly initializing them (only global variables will be zero-initialized):</p>\n<blockquote>\n<p id=\"so_11153863_11153923_1\"><strong>8.5 Initializers:</strong> If no initializer is specified for an object, the object is default-initialized; if no initialization is performed, an\n  object with automatic or dynamic storage duration has indeterminate value. [ Note: Objects with static or thread storage duration are zero-initialized</p>\n</blockquote>\n<p>So: <strong>Always initialize builtin types!</strong></p>\n<hr>\n<blockquote>\n<p id=\"so_11153863_11153923_2\">My question is how should I avoid double delete of a pointer and prevent crash.</p>\n</blockquote>\n<p>Destructors are ought to be entered and left exactly once. Not zero times, not two times, once. </p>\n<p>And if you have multiple places that can reach the pointer, but are unsure about when you are allowed to delete, i.e. if you find yourself bookkeeping, use a more trivial algorithm, more trivial rules, or smart-pointers, like <code>std::shared_ptr</code> or <code>std::unique_ptr</code>:</p>\n<pre><code>class Foo {\npublic:\n    Foo (std::shared_ptr&lt;int&gt; tehInt) : tehInt_(tehInt) {}\nprivate:\n    std::shared_ptr&lt;int&gt; tehInt_;\n};\n\nint main() {\n    std::shared_ptr&lt;int&gt; tehInt;\n    Foo foo (tehInt);\n}\n</code></pre>\n</hr>", "OwnerUserId": "76722", "LastEditorUserId": "76722", "LastEditDate": "2012-06-22T10:18:59.250", "Id": "11153923", "Score": "4", "CreationDate": "2012-06-22T09:50:51.737", "LastActivityDate": "2012-06-22T10:18:59.250"}, "11154098": {"ParentId": "11153863", "CommentCount": "4", "Body": "<p>You should never use <code>delete this</code>. For two reasons, the destructor is in the process of deleting the memory and is giving you the opportunity to tidy up (release OS resources, do a delete any pointers in the object that the object has created). Secondly, the object may be on the stack.</p>\n", "OwnerUserId": "892256", "PostTypeId": "2", "Id": "11154098", "Score": "-1", "CreationDate": "2012-06-22T10:02:36.263", "LastActivityDate": "2012-06-22T10:02:36.263"}, "11155185": {"ParentId": "11153863", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You ask: \"At one point, I want to de-allocate this pointer after checking whether it is valid or already de-allocated by someone.\"</p>\n<p>There is <em>no portable way in C/C++ to check if a &gt;naked pointer&lt; is valid or not</em>. That's it. End of story right there. <strong>You can't do it.</strong> Again: only if you use a <em>naked</em>, or C-style pointer. There are other kinds of pointers that don't have that issue, so why don't use them instead!</p>\n<p>Now the question becomes: why the heck do you insist that you should use naked pointers? Don't use naked pointers, use <code>std::shared_ptr</code> and <code>std::weak_ptr</code> appropriately, and you won't even need to worry about deleting anything. It'll get deleted automatically when the last pointer goes out of scope. Below is an example.</p>\n<p>The example code shows that there are two object instances allocated on the heap: an integer, and a Holder. As test() returns, the returned <code>std::auto_ptr&lt;Holder&gt;</code> is not used by the caller <code>main()</code>. Thus the pointer gets destructed, thus deleting the instance of the Holder class. As the instance is destructed, it destructs the pointer to the instance of the integer -- the second of the two pointers that point at that integer. Then <code>myInt</code> gets destructed as well, and thus the last pointer alive to the integer is destroyed, and the memory is freed. Automagically and without worries.</p>\n<pre><code>class Holder {\n  std::auto_ptr&lt;int&gt; data;\npublic:\n  Holder(const std::auto_ptr&lt;int&gt; &amp; d) : data(d) {}\n}\n\nstd::auto_ptr&lt;Holder&gt; test() {\n  std::auto_ptr&lt;int&gt; myInt = new int;\n  std::auto_ptr&lt;Holder&gt; myHolder = new Holder(myInt);\n  return myHolder;\n}\n\nint main(int, char**) {\n  test(); // notice we don't do any deallocations!\n}\n</code></pre>\n<p>Simply don't use naked pointers in C++, there's no good reason for it. It only lets you shoot yourself in the foot. Multiple times. With abandon ;)</p>\n<p>The rough guidelines for smart pointers go as follows:</p>\n<ul>\n<li><p><strong>std::auto_ptr</strong> -- use when the scope is the sole owner of an object, and the lifetime of the object ends when the scope dies. Thus, if <code>auto_ptr</code> is a class member, it must make sense that the pointed-to object gets deletes when the instance of the class gets destroyed. Same goes for using it as an automatic variable in a function. In all other cases, don't use it.</p></li>\n<li><p><strong>std::shared_ptr</strong> -- its use implies ownership, potentially shared among multiple pointers. The pointed-to object's lifetime ends when the last pointer to it gets destroyed. Makes managing lifetime of objects quite trivial, but beware of circular references. If Class1 owns an instance of Class2, and that very same instance of Class2 owns the former instance of Class1, then the pointers themselves won't ever delete the classes.</p></li>\n<li><p><strong>std::weak_ptr</strong> -- its use implies non-ownership. It cannot be used directly, but has to be converted back to a <code>shared_ptr</code> before use. A <code>weak_ptr</code> will not prevent an object from being destroyed, so it doesn't present circular reference issues. It is otherwise safe in that you can't use it if it's dangling. It will assert or present you with a null pointer, causing an immediate segfault. Using dangling pointers is way worse, because they often appear to work.</p>\n<p>That's in fact the main benefit of <code>weak_ptr</code>: with a naked C-style pointer, you'll never know if someone has deleted the object or not. A <code>weak_ptr</code> knows when the last <code>shared_ptr</code> went out of scope, and it will prevent you from using the object. You can even ask it whether it's still valid: the <code>expired()</code> method returns <code>true</code> if the object was deleted.</p></li>\n</ul>\n", "OwnerUserId": "1329652", "LastEditorUserId": "1329652", "LastEditDate": "2012-06-22T11:24:54.480", "Id": "11155185", "Score": "0", "CreationDate": "2012-06-22T11:18:44.110", "LastActivityDate": "2012-06-22T11:24:54.480"}, "11153863": {"CommentCount": "9", "ViewCount": "1452", "PostTypeId": "1", "LastEditorUserId": "806299", "CreationDate": "2012-06-22T09:46:18.920", "LastActivityDate": "2012-06-22T15:48:47.130", "Title": "Check for non-deallocated pointer", "AcceptedAnswerId": "11153876", "LastEditDate": "2012-06-22T12:13:51.030", "Id": "11153863", "Score": "2", "Body": "<p>Assume a pointer object is being allocated on one point and it is being returned to different nested functions. At one point, I want to de-allocate this pointer after checking whether it is valid or already de-allocated by someone.</p>\n<p>Is there any guarantee that any of these will work?</p>\n<pre><code>if(ptr != NULL)\n   delete ptr;\n</code></pre>\n<p>OR</p>\n<pre><code>if(ptr)\n   delete ptr;\n</code></pre>\n<p>This code does not work. It always gives Segmentation Fault</p>\n<pre><code>#include &lt;iostream&gt;\nclass A\n{\n    public:\n    int x;\n     A(int a){ x=a;}\n     ~A()\n     { \n          if(this || this != NULL) \n              delete this;\n     }\n};\nint main()\n{ \n    A *a = new A(3);\n    delete a;\n    a=NULL;\n}\n</code></pre>\n<p><strong>EDIT</strong></p>\n<p>Whenever we talk about pointers, people start asking, why not use Smart Pointers.\nJust because smart pointers are there, everyone cannot use it.</p>\n<p>We may be working on systems which use old style pointers. We cannot convert all of them to smart pointers, one fine day.</p>\n", "Tags": "<c++><pointers><memory-management>", "OwnerUserId": "806299", "AnswerCount": "5"}, "11153900": {"ParentId": "11153863", "CommentCount": "0", "Body": "<p>You cannot assume that the pointer will be set to NULL after someone has deleted it. This is certainly the case with embarcadero C++ Builder XE. It may get set to NULL afterwards but do not use the fact that it is not to allow your code to delete it again.</p>\n", "OwnerUserId": "1342730", "PostTypeId": "2", "Id": "11153900", "Score": "2", "CreationDate": "2012-06-22T09:48:40.303", "LastActivityDate": "2012-06-22T09:48:40.303"}, "bq_ids": {"n4140": {"so_11153863_11153923_1": {"section_id": 3291, "quality": 0.8181818181818182, "length": 18}, "so_11153863_11153923_0": {"section_id": 6110, "quality": 0.8823529411764706, "length": 15}}, "n3337": {"so_11153863_11153923_1": {"section_id": 3161, "quality": 0.9090909090909091, "length": 20}, "so_11153863_11153923_0": {"section_id": 5876, "quality": 0.8823529411764706, "length": 15}}, "n4659": {"so_11153863_11153923_1": {"section_id": 4053, "quality": 0.8181818181818182, "length": 18}, "so_11153863_11153923_0": {"section_id": 7607, "quality": 0.8823529411764706, "length": 15}}}, "11153876": {"ParentId": "11153863", "PostTypeId": "2", "CommentCount": "13", "Body": "<blockquote>\n<p id=\"so_11153863_11153876_0\"><code>if(ptr != NULL)    delete ptr;</code> </p>\n<p id=\"so_11153863_11153876_1\">OR</p>\n<p id=\"so_11153863_11153876_2\"><code>if(ptr)    delete ptr;</code></p>\n</blockquote>\n<p>The two are actually equivalent, and also the same as <code>delete ptr;</code>, because calling <code>delete</code> on a <code>NULL</code> pointer is guaranteed to work (as in, it does nothing).</p>\n<p>And they are not guaranteed to work if <code>ptr</code> is a dangling pointer.</p>\n<p>Meaning:</p>\n<pre><code>int* x = new int;\nint* ptr = x;\n//ptr and x point to the same location\ndelete x;\n//x is deleted, but ptr still points to the same location\nx = NULL;\n//even if x is set to NULL, ptr is not changed\nif (ptr)  //this is true\n   delete ptr;   //this invokes undefined behavior\n</code></pre>\n<p>In your specific code, you get the exception because you call <code>delete this</code> in the destructor, which in turn calls the destructor again. Since <code>this</code> is never <code>NULL</code>, you'll get a STACK OVERFLOW because the destructor will go uncontrollably recursive. </p>\n", "OwnerUserId": "673730", "LastEditorUserId": "1245420", "LastEditDate": "2012-06-22T15:48:47.130", "Id": "11153876", "Score": "6", "CreationDate": "2012-06-22T09:47:13.153", "LastActivityDate": "2012-06-22T15:48:47.130"}});