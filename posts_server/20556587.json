post_cb({"20556770": {"ParentId": "20556587", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Function arguments are <em>expressions</em>, not objects. Even if you supply a single object as a function argument, it is still an expression. The template argument deduction process will not work with the declared type of that object. It does not care about its exact declared type. What it cares about is the type of that <em>expression</em>.</p>\n<p>Expressions in C++ never interpreted as having reference type. Every expression that physically has reference type is always interpreted as an <em>lvalue</em> (or an <em>xvalue</em>) of non-reference type. The \"reference\" part is immediately and irreversibly discarded and forgotten.</p>\n<p>This is how it is worded in the standard (5/5)</p>\n<blockquote>\n<p id=\"so_20556587_20556770_0\"><strong>5</strong> If an expression initially has the type \u201creference to T\u201d (8.3.2,\n  8.5.3), the type is adjusted to T prior to any further analysis. The expression designates the object or function denoted by the reference,\n  and the expression is an lvalue or an xvalue, depending on the\n  expression.</p>\n</blockquote>\n<p>For example, in your code <code>rx</code> is declared as an <code>int const &amp;</code>. However, every time you use <code>rx</code> as an expression, the result of that expression is always immediately adjusted from <code>int const &amp;</code> to <code>int const</code> and is seen as an <em>lvalue</em> of <code>int const</code> type. In \"expression result\" context the language completely ignores the fact that <code>rx</code> was a reference. </p>\n<p>It is often said that a reference can be thought of as just another name for an existing object. This is exactly the principle that works here. In \"expression result\" context, there's no difference between <code>rx</code> and <code>x</code> (aside from const-qualification).</p>\n<p>Returning to your code, in this call</p>\n<pre><code>int z = ::min(rx, y);\n</code></pre>\n<p>the function arguments are interpreted as lvalues of <code>int const</code> and <code>int</code> type respectively. (I.e. the first argument is not really seen as having <code>int const &amp;</code> type, contrary to your expectations). These are the types used for template argument deduction. Consequently, <code>T</code> is deduced as <code>int</code>. At no point in this process an attempt to produce a \"reference-to-reference\" has a chance to take place.</p>\n<p><code>typeid</code> works as you observe for exactly the same reason. <code>typeid</code> does not give you the declared type of the object. The argument of <code>typeid</code> in your case is an <em>expression</em>. <code>typeid</code> in this form gives you the type of the expression result, which is why <code>typeid</code> cannot \"see\" references. The <code>const</code> part is discarded because that's just how <code>typeid</code> works: top-level cv-qulifiers are always discarded by <code>typeid</code>.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2013-12-13T00:30:31.293", "Id": "20556770", "Score": "2", "CreationDate": "2013-12-13T00:05:41.323", "LastActivityDate": "2013-12-13T00:30:31.293"}, "20556665": {"ParentId": "20556587", "CommentCount": "1", "Body": "<ol>\n<li><p>Because references are collapsed in the context of type deduction, as are <code>const</code>s. Look up reference collapsing, there are many many answers on it already.</p></li>\n<li><p>No, because references are transparent, you can't look at them; when you name a variable that is a reference, the language always thinks you mean the referee. When you the <code>typeid</code> of a reference or <code>const</code> it ignores it.</p></li>\n<li><p>Avoid bolding unimportant words like <strong>variable</strong>, it makes your question hard to read :)</p></li>\n</ol>\n", "OwnerUserId": "2925619", "PostTypeId": "2", "Id": "20556665", "Score": "3", "CreationDate": "2013-12-12T23:55:33.197", "LastActivityDate": "2013-12-12T23:55:33.197"}, "bq_ids": {"n4140": {"so_20556587_20556770_0": {"section_id": 5938, "quality": 0.8695652173913043, "length": 20}}, "n3337": {"so_20556587_20556770_0": {"section_id": 5710, "quality": 0.8695652173913043, "length": 20}}, "n4659": {"so_20556587_20556770_0": {"section_id": 7422, "quality": 0.8695652173913043, "length": 20}}}, "20556587": {"CommentCount": "1", "AcceptedAnswerId": "20556770", "PostTypeId": "1", "LastEditorUserId": "2090317", "CreationDate": "2013-12-12T23:48:13.660", "LastActivityDate": "2013-12-13T00:51:34.597", "LastEditDate": "2013-12-13T00:51:34.597", "ViewCount": "520", "FavoriteCount": "1", "Title": "What is the type of a const reference?", "Id": "20556587", "Score": "1", "Body": "<p>I know that passing a const reference variable to a function\u2019s const reference parameter does not cause the function parameter to be of the type <strong>\"const reference of a const reference of the referee's type\"</strong>. The variable name of the const reference argument is merely treated as another alias for the referee, but glorified with the protection that said alias cannot be used to modify the referee.</p>\n<p>The idea of the reference variable's name being used as if it were an alias of the referee variable applies nicely to <strong>variables</strong>, giving another layer of indirection. It does not seem to make sense to apply analogous ideas of:</p>\n<ul>\n<li>a <strong>const reference type</strong> itself being used as if it were an alias of its referee's <strong>type</strong>,</li>\n<li>a <code>typedef</code> of a <strong>const reference type</strong> being used as an alias of its referee's <strong>type</strong>,</li>\n<li>a const reference variable passed to (or deduced by) a <code>template</code> parameter gets its type interpreted as that of its referee's when the template parameter is <code>typename T</code> and its function parameter is <code>T const&amp;</code>.</li>\n</ul>\n<p>But that's what appears to happen in the following:</p>\n<pre><code>#include &lt;typeinfo&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nT const&amp; min(T const&amp; a, T const&amp; b) {\n    std::cout &lt;&lt; typeid(a).name() &lt;&lt; std::endl;\n    std::cout &lt;&lt; typeid(b).name() &lt;&lt; std::endl;\n    return a &lt; b ? a : b;\n}\n\nint main() {\n    int x = 6, y = 7;\n    int const&amp; rx = x;\n    std::cout &lt;&lt; typeid(rx).name() &lt;&lt; std::endl;           // \"int\"\n    int z = ::min(rx, y);       //output shows both \"a\" and \"b\" are of type \"int\"\n    std::cout &lt;&lt; z &lt;&lt; std::endl;                           // \u201c6\u201d\n    typedef int const&amp; icr;\n    std::cout &lt;&lt; typeid(icr).name() &lt;&lt; std::endl;          // \"int\"\n    std::cout &lt;&lt; typeid(int const&amp;).name() &lt;&lt; std::endl;   // \"int\"\n}\n</code></pre>\n<ol>\n<li><p>Why does the function template work even for arguments that are already <code>int const&amp;</code>? (In the sample code, it worked even for a call that had an <code>int const&amp;</code> variable as the first parameter and an <code>int</code> variable as the second.) Shouldn\u2019t it be invalid, because C++ does not\nallow a <strong>\"reference of a reference\"</strong>?</p></li>\n<li><p>Shouldn\u2019t the <code>typeid</code>\u2019s <code>name()</code> of <code>int const&amp;</code> be <code>int const&amp;</code>, instead of <code>int</code>?</p></li>\n<li><p>If not, then wouldn\u2019t this mean <code>int const&amp;</code> is an alias of <code>int</code>; which doesn\u2019t make any sense, because both are different types (not names of variables)?</p></li>\n<li><p>Going back to variable names, given:</p>\n<pre><code>int num = 8;\nint const&amp; ref = num;\nstd::cout &lt;&lt; typeid(ref).name() &lt;&lt; std::endl;\n</code></pre>\n<p>why is the output <code>int</code>, and not <code>int const&amp;</code>?</p></li>\n</ol>\n", "Tags": "<c++><templates><types><typedef><const-reference>", "OwnerUserId": "2090317", "AnswerCount": "2"}});