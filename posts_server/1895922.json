post_cb({"1895922": {"CommentCount": "5", "ViewCount": "1549", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2009-12-13T08:29:32.050", "LastActivityDate": "2010-11-25T04:55:34.887", "LastEditDate": "2017-05-23T11:44:17.233", "AcceptedAnswerId": "1895947", "FavoriteCount": "11", "Title": "Sequence points and partial order", "Id": "1895922", "Score": "21", "Body": "<p>A few days back there was a discussion <a href=\"https://stackoverflow.com/questions/1860461/why-is-i-i-1-unspecified-behavior\">here</a> about whether the expression</p>\n<blockquote>\n<p id=\"so_1895922_1895922_0\">i = ++i + 1</p>\n</blockquote>\n<p>invokes UB \n(Undefined Behavior) or not.</p>\n<p>Finally the conclusion was made that it invokes UB as the value of 'i' is changing more than once between two sequence points.</p>\n<p>I was involved in a discussion with <a href=\"https://stackoverflow.com/users/34509/johannes-schaub-litb\">Johannes Schaub</a> in that same thread. According to him </p>\n<blockquote>\n<p id=\"so_1895922_1895922_1\">i=(i,i++,i)+1 ------ (1)   /*  invokes UB as well */</p>\n</blockquote>\n<p>I said (1) does not invoke UB because the side effects of the previous subexpressions are cleared by the comma operator ',' between i and i++ and between i++ and i.</p>\n<p>Then he gave the following explanation:</p>\n<blockquote>\n<p id=\"so_1895922_1895922_2\">\"Yes the sequence point after i++ completes all side effects before it, but there is nothing that stops the assignment side effect overlapping with the side effect of i++.<strong>The underlying problem is that the side effect of an assignment is not specified to happen after or before the evaluation of both operands of the assignment, and so sequence points cannot do anything with regard to protecting this: Sequence points induce a partial order: Just because there is a sequence point after and before i++ doesn't mean all side effects are sequenced with regard to i</strong>.</p>\n<p id=\"so_1895922_1895922_3\">Also, notice that merely a sequence point means nothing: The order of evaluations isn't dictated by the form of code. It's dictated by semantic rules. In this case, there is no semantic rule saying when the assignment side effect happens with regard to evaluating both of its operands or subexpressions of those operands\".</p>\n</blockquote>\n<p>The statement written in \"bold\" confused me. As far as I know:</p>\n<p><em>\"At certain specified points in the execution sequence called sequence points,all side effects of previous evaluations shall be complete and no side effects of subsequent evaluations shall have taken place.\"</em></p>\n<p><strong>Since,comma operators also specify execution order the side effect of i++ have been cancelled when we reach the last i.He(Johannes) would have been right had the order of evaluation been not specified(but in case of comma operator it is well specified).</strong></p>\n<p>So I just want to know whether (1) invokes UB or not?. Can someone give another valid explanation?</p>\n<p>Thanks! </p>\n", "Tags": "<c++><c><expression><language-lawyer>", "OwnerUserId": "165520", "AnswerCount": "4"}, "1895947": {"ParentId": "1895922", "LastEditDate": "2009-12-13T09:26:55.187", "CommentCount": "6", "CreationDate": "2009-12-13T08:52:30.073", "Score": "14", "LastEditorUserId": "12711", "PostTypeId": "2", "Id": "1895947", "OwnerUserId": "12711", "Body": "<p>The C standard says this about assignment operators (C90 6.3.16 or C99 6.5.16 Assignment operators):</p>\n<blockquote>\n<p id=\"so_1895922_1895947_0\">The side effect of updating the stored value of the left operand shall occur between the previous and the next sequence point.</p>\n</blockquote>\n<p>It seems to me that in the statement:</p>\n<pre><code>i=(i,i++,i)+1;\n</code></pre>\n<p>the sequence point 'previous' to the assignment operator would be the second comma operator and the 'next' sequence point would be the end of the expression. So I'd say that the expression doesn't invoke undefined behavior.</p>\n<p>However, this expression:</p>\n<pre><code>*(some_ptr + i) = (i,i++,i)+1;\n</code></pre>\n<p>would have undefined behavior because the order of evaluation of the 2 operands of the assignment operator is undefined, and in this case instead of the problem being when the assignment operator's side effect takes place, the problem is you don't know whether the value of i used in the left handle operand will be evaluated before or after the right hand side.  This order of evaluation problem doesn't occur in the first example because in that expression the value of <code>i</code> isn't actually used in the left-hand side - all that the assignment operator is interested in is the \"lvalue-ness\" of <code>i</code>.</p>\n<p>But I also think that all this is sketchy enough (and my understanding of the nuances involved are sketchy enough) that I wouldn't be surprised if someone can convince me otherwise (on either count).</p>\n", "LastActivityDate": "2009-12-13T09:26:55.187"}, "1899656": {"ParentId": "1895922", "LastEditDate": "2009-12-14T08:59:48.587", "CommentCount": "9", "CreationDate": "2009-12-14T08:29:42.403", "Score": "5", "LastEditorUserId": "149530", "PostTypeId": "2", "Id": "1899656", "OwnerUserId": "149530", "Body": "<p><code>i=(i,i++,i)+1 ------ (1) /* invokes UB as well */</code></p>\n<p>It does not invoke undefined behaviour. The side effect of <code>i++</code> will take place before the evaluation of the next sequence point, which is denoted by the comma following it, and also before the assignment.</p>\n<p>Nice language sudoku, though. :-)</p>\n<p>edit: There's a more elaborate explanation <a href=\"http://groups.google.com/group/comp.lang.c/msg/7ef196f7da0e0d6c\" rel=\"noreferrer\">here</a>.</p>\n", "LastActivityDate": "2009-12-14T08:59:48.587"}, "1898691": {"ParentId": "1895922", "LastEditDate": "2010-11-25T04:55:34.887", "CommentCount": "0", "CreationDate": "2009-12-14T03:00:41.507", "Score": "-1", "LastEditorUserId": "165520", "PostTypeId": "2", "Id": "1898691", "OwnerUserId": "165520", "Body": "<p>I was confused in the beginning regarding Johannes'(litb) statement but he mentioned that in :</p>\n<pre><code>i = (i, ++i, i) +1\n</code></pre>\n<blockquote>\n<p id=\"so_1895922_1898691_0\">&lt; Johannes&gt;<br>\n  If &lt; a &gt; is assignment, and  is an increment. <code>:s:</code> is a sequence point,then the side effects can be sequenced as follows between sequence points: <code>(i :s: i++&lt; a &gt;&lt;n&gt; :s: i) + 1</code>. The value of the scalar <code>i</code> was changed twice between the first and second sequence point here. The order in which the assignment and the increment happens is unspecified, and since between them there is no sequence point, it is not even atomic with respect to each other.This is one allowed ordering permitted by the unspecified ordering of these side effects.</br></p>\n<p id=\"so_1895922_1898691_1\">This is different to <code>(i++, i++)</code>, because the evaluation order of the two subexpressions is from left to right, and at the sequence point between them, the increment of the previous evaluation shall be complete, and the next increment shall not have yet taken place. This enforces that there is no change of the value of <code>i</code> between two sequence points, which makes <code>(i++, i++)</code> valid<br>\n  &lt; /Johannes&gt;</br></p>\n</blockquote>\n<p>This made me think the sequence mentioned by litb is invalid because as per C99:</p>\n<blockquote>\n<p id=\"so_1895922_1898691_2\">6.5.16.1 (2) In simple assignment (=), the value of the right operand is converted to the type of the assignment expression and replaces the value stored in the object designated by the left operand.</p>\n</blockquote>\n<p>i.e. the value of the right operand needs to be known before the assignment side effect (modification of the value stored in the object corresponding to the left operand) </p>\n<blockquote>\n<p id=\"so_1895922_1898691_3\">6.5.17 (2) The left operand of a comma operator is evaluated as a void expression; there is a sequence point after its evaluation. Then the right operand is evaluated; the result has its type and value.</p>\n</blockquote>\n<p>i.e. the rightmost operand of the comma operation needs to be evaluated to know the value and type of the comma expression (and the value of the right operand for my example).</p>\n<p>So in this case, the 'previous sequence point' for the assignment side effect would, in effect, be the right-most comma operation. The possible sequence mentioned by Johannes is invalid.</p>\n<p>Please correct me if I am wrong.</p>\n<hr>\n</hr>", "LastActivityDate": "2010-11-25T04:55:34.887"}, "1896112": {"ParentId": "1895922", "CommentCount": "8", "CreationDate": "2009-12-13T10:30:26.897", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "1896112", "Score": "6", "Body": "<p>I believe that the following expression definitely has undefined behaviour.</p>\n<pre><code>i + ((i, i++, i) + 1)\n</code></pre>\n<p>The reason is that the comma operator specifies sequence points between the subexpressions in parentheses but does not specify where in that sequence the evaluation of the left hand operand of <code>+</code> occurs. One possibility is between the sequence points surrounding <code>i++</code> and this violates the 5/4 as <code>i</code> is written to between two sequence points but is also read twice between the same sequence points and not just to determine the value to be stored but also to determine the value of the first operand to the <code>+</code> operator.</p>\n<p>This also has undefined behaviour.</p>\n<pre><code>i += (i, i++, i) + 1;\n</code></pre>\n<p>Now, I am not so sure about this statement.</p>\n<pre><code>i = (i, i++, i) + 1;\n</code></pre>\n<p>Although the same principals apply, <code>i</code> must be \"evaluated\" as a modifiable lvalue and can be done so at any time, but I'm not convinced that its <em>value</em> is ever <em>read</em> as part of this. (Or is there another restriction that the expression violates to cause UB?)</p>\n<p>The sub-expression <code>(i, i++, i)</code> happens as part of determining the value to be stored and that sub-expression contains a sequence point after the storage of a value to <code>i</code>. I don't see any way that this wouldn't require the side effect of <code>i++</code> to be complete before the determination of the value to be stored and hence the earliest possible point that the assignment side effect could occur.</p>\n<p>After this sequnce point <code>i</code>'s value is read at most once and only to determine the value that will be stored back to <code>i</code>, so this last part is fine.</p>\n", "LastActivityDate": "2009-12-13T10:30:26.897"}, "bq_ids": {"n4140": {"so_1895922_1898691_2": {"section_id": 3291, "quality": 0.5882352941176471, "length": 10}}, "n4659": {"so_1895922_1898691_2": {"section_id": 4053, "quality": 0.5882352941176471, "length": 10}}}});