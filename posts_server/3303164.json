post_cb({"3303164": {"ViewCount": "1857", "Body": "<p>Any idea why I get \"Maya is not Maya\" as a result for this code?</p>\n<pre><code>if (\"Maya\" == \"Maya\") \n   printf(\"Maya is Maya \\n\");\nelse\n   printf(\"Maya is not Maya \\n\");\n</code></pre>\n", "AcceptedAnswerId": "3303180", "Title": "Why isn't if (\"Maya\" == \"Maya\") true in c++?", "CreationDate": "2010-07-21T19:43:53.650", "Id": "3303164", "CommentCount": "7", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2012-04-14T18:59:51.393", "LastEditorUserId": "512251", "LastActivityDate": "2012-04-14T18:59:51.393", "Score": "22", "OwnerUserId": "398405", "Tags": "<c++><string><equality>", "AnswerCount": "8"}, "3303180": {"Id": "3303180", "PostTypeId": "2", "Body": "<p>Because you are actually comparing two pointers - use e.g. one of the following instead:</p>\n<pre><code>if (std::string(\"Maya\") == \"Maya\") { /* ... */ } \nif (std::strcmp(\"Maya\", \"Maya\") == 0) { /* ... */ }\n</code></pre>\n<p>This is because C++03, <em>\u00a72.13.4</em> says:</p>\n<blockquote>\n<p id=\"so_3303164_3303180_0\">An ordinary string literal has type \u201carray of <em>n</em> <code>const char</code>\u201d</p>\n</blockquote>\n<p>... and in your case a conversion to pointer applies.</p>\n<p>See also <a href=\"https://stackoverflow.com/questions/2985532/overloading-operator-to-compare-two-char-using-a-string-comparison\">this question</a> on why you can't provide an overload for <code>==</code> for this case.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-07-21T19:55:33.810", "Score": "46", "CreationDate": "2010-07-21T19:45:26.017", "ParentId": "3303164", "CommentCount": "7", "OwnerUserId": "168225", "LastEditDate": "2017-05-23T11:46:59.367"}, "3303510": {"Body": "<p>Indeed, \"because your compiler, in this instance, isn't using string pooling,\" is the technically correct, yet not particularly helpful answer :)</p>\n<p>This is one of the many reasons the <strong>std::string</strong> class in the Standard Template Library now exists to replace this earlier kind of string when you want to do anything useful with strings in C++, and is a problem pretty much everyone who's ever learned C or C++ stumbles over fairly early on in their studies.</p>\n<p>Let me explain.</p>\n<p>Basically, back in the days of C, <em>all</em> strings worked like this. A string is just a bunch of characters in memory. A string you embed in your C source code gets translated into a bunch of bytes representing that string in the running machine code when your program executes.</p>\n<p>The crucial part here is that a good old-fashioned C-style \"string\" is an array of characters in memory. That block of memory is often referred to by means of a pointer -- the address of the start of the block of memory. Generally, when you're referring to a \"string\" in C, you're referring to that block of memory, or a pointer to it. C doesn't have a <strong>string</strong> type per se; strings are just a bunch of <strong>char</strong>s in a row.</p>\n<p>When you write this in your code:</p>\n<pre><code>\"wibble\"\n</code></pre>\n<p>Then the compiler provides a block of memory that contains the bytes representing the characters 'w', 'i', 'b', 'b', 'l', 'e', and '\\0' in that order (the compiler adds a zero byte at the end, a \"null terminator\". In C a standard string is a null-terminated string: a block of characters starting at a given memory address and continuing until the next zero byte.)</p>\n<p>And when you start comparing expressions like that, what happens is this:</p>\n<pre><code>if (\"Maya\" == \"Maya\")\n</code></pre>\n<p>At the point of this comparison, the compiler -- in <em>your</em> case, specifically; see my explanation of string pooling at the end -- has created two separate blocks of memory, to hold two different sets of characters that are both set to 'M', 'a', 'y', 'a', '\\0'.</p>\n<p>When the compiler sees a string in quotes like this, \"under the hood\" it builds an array of characters, and the string itself, \"Maya\", acts as the <em>name</em> of the array of characters. Because the names of arrays are effectively pointers, pointing at the first character of the array, the type of the expression \"Maya\" is <em>pointer to char</em>.</p>\n<p>When you compare these two expressions using \"==\", what you're actually comparing is the <em>pointers</em>, the <em>memory addresses of the beginning of these two different blocks of memory</em>. Which is why the comparison is false, in your particular case, with your particular compiler.</p>\n<p>If you want to compare two good old-fashioned C strings, you should use the <strong>strcmp()</strong> function. This will examine the contents of the memory pointed two by both \"strings\" (which, as I've explained, are just pointers to a block of memory) and go through the bytes, comparing them one-by-one, and tell you whether they're <em>really</em> the same.</p>\n<p>Now, as I've said, this is the kind of slightly surprising result that's been biting C beginners on the arse since the days of yore. And that's one of the reasons the language evolved over time. Now, in C++, there is a <strong>std::string</strong> class, that will hold strings, and will work as you expect. The \"==\" operator for <strong>std::string</strong> will actually compare the <em>contents</em> of two <strong>std::strings</strong>.</p>\n<p>By default, though, C++ is designed to be backwards-compatible with C, i.e. a C program will generally compile and work under a C++ compiler the same way it does in a C compiler, and that means that old-fashioned strings, \"things like this in your code\", will still end up as pointers to bits of memory that will give non-obvious results to the beginner when you start comparing them.</p>\n<p>Oh, and that \"string pooling\" I mentioned at the beginning? That's where some more complexity might creep in. A smart compiler, to be efficient with its memory, may well spot that in your case, the strings are the same and can't be changed, and therefore only allocate <em>one</em> block of memory, with both of your names, \"Maya\", pointing at it. At which point, comparing the \"strings\" -- the <em>pointers</em> -- will tell you that they <em>are</em>, in fact, equal. But more by luck than design!</p>\n<p>This \"string pooling\" behaviour will change from compiler to compiler, and often will differ between debug and release modes of the same compiler, as the release mode often includes optimisations like this, which will make the output code more compact (it only has to have one block of memory with \"Maya\" in, not two, so it's saved five -- remember that null terminator! -- bytes in the object code.) And that's the kind of behaviour that can drive a person insane if they don't know what's going on :)</p>\n<p>If nothing else, this answer might give you a lot of search terms for the thousands of articles that are out there on the web already, trying to explain this. It's a bit painful, and everyone goes through it. If you can get your head around pointers, you'll be a much better C or C++ programmer in the long run, whether you choose to use std::string instead or not!</p>\n", "CreationDate": "2010-07-21T20:25:49.670", "ParentId": "3303164", "CommentCount": "3", "LastEditDate": "2010-07-22T09:26:17.390", "Id": "3303510", "PostTypeId": "2", "LastActivityDate": "2010-07-22T09:26:17.390", "LastEditorUserId": "300836", "CommunityOwnedDate": "2010-07-22T09:26:17.390", "Score": "1", "OwnerUserId": "300836"}, "3303212": {"Id": "3303212", "PostTypeId": "2", "Body": "<p>The output of your program is implementation-defined.</p>\n<p>A string literal has the type <code>const char[N]</code> (that is, it's an array). Whether or not each string literal in your program is represented by a unique array is <em>implementation-defined</em>. (\u00a72.13.4/2)</p>\n<p>When you do the comparison, the arrays decay into pointers (to the first element), and you do a pointer comparison. If the compiler decides to store both string literals as the same array, the pointers compare true; if they each have their own storage, they compare false. </p>\n<p>To compare string's, use <code>std::strcmp()</code>, like this:</p>\n<pre><code>if (std::strcmp(\"Maya\", \"Maya\") == 0) // same\n</code></pre>\n<p>Typically you'd use the standard string class, <code>std::string</code>. It defines <code>operator==</code>. You'd need to make one of your literals a <code>std::string</code> to use that operator:</p>\n<pre><code>if (std::string(\"Maya\") == \"Maya\") // same\n</code></pre>\n", "LastActivityDate": "2010-07-21T19:49:09.253", "CommentCount": "1", "CreationDate": "2010-07-21T19:49:09.253", "ParentId": "3303164", "Score": "9", "OwnerUserId": "87234"}, "3303186": {"Id": "3303186", "PostTypeId": "2", "Body": "<p>What you are doing is comparing the address of one string with the address of another. Depending on the compiler and its settings, sometimes the identical literal strings will have the same address, and sometimes they won't (as apparently you found).</p>\n", "LastActivityDate": "2010-07-21T19:45:58.847", "CommentCount": "0", "CreationDate": "2010-07-21T19:45:58.847", "ParentId": "3303164", "Score": "7", "OwnerUserId": "310574"}, "3303176": {"Id": "3303176", "PostTypeId": "2", "Body": "<p>You are not comparing strings, you are comparing pointer address equality.</p>\n<p>To be more explicit - </p>\n<p>\"foo baz bar\" implicitly defines an anonymous <code>const char[m]</code>. It is implementation-defined as to whether identical anonymous const char[m] will point to the same location in memory(a concept referred to as <em>interning</em>).</p>\n<p>The function you want - in C - is strmp(char*, char*), which returns 0 on equality.</p>\n<p>Or, in C++, what you might do is </p>\n<p><code>#include &lt;string&gt;</code></p>\n<p><code>std::string s1 = \"foo\"</code></p>\n<p><code>std::string s2 = \"bar\"</code></p>\n<p>and then compare s1 vs. s2 with the <code>==</code> operator, which is defined in an intuitive fashion for strings.</p>\n", "LastEditorUserId": "26227", "LastActivityDate": "2010-07-21T19:56:10.487", "Score": "17", "CreationDate": "2010-07-21T19:45:11.883", "ParentId": "3303164", "CommentCount": "2", "OwnerUserId": "26227", "LastEditDate": "2010-07-21T19:56:10.487"}, "bq_ids": {"n4140": {"so_3303164_3303180_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5356}}, "n3337": {"so_3303164_3303180_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5153}}, "n4659": {"so_3303164_3303180_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 6781}}}, "3303188": {"Id": "3303188", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_3303164_3303188_0\">Any idea why i get \"Maya is not Maya\" as a result</p>\n</blockquote>\n<p>Because in C, and thus in C++, string literals are of type <code>const char[]</code>, which is implicitly converted to <code>const char*</code>, a pointer to the first character, when you try to compare them. <strong><em>And pointer comparison is address comparison.</em></strong><br>\nWhether the two string literals compare equal or not depends whether your compiler (using your current settings) pools string literals. It is allowed to do that, but it doesn't need to. . </br></p>\n<p>To compare the strings in C, use <code>strcmp()</code> from the <code>&lt;string.h&gt;</code> header. (It's <code>std::strcmp()</code> from <code>&lt;cstring&gt;</code>in C++.) </p>\n<p>To do so in C++, the easiest is to turn one of them into a <code>std::string</code> (from the <code>&lt;string&gt;</code> header), which comes with all comparison operators, including <code>==</code>: </p>\n<pre><code>#include &lt;string&gt;\n\n// ...\n\nif (std::string(\"Maya\") == \"Maya\") \n   std::cout &lt;&lt; \"Maya is Maya\\n\";\nelse\n   std::cout &lt;&lt; \"Maya is not Maya\\n\";\n</code></pre>\n", "LastEditorUserId": "140719", "LastActivityDate": "2010-07-21T21:00:31.413", "Score": "5", "CreationDate": "2010-07-21T19:46:15.343", "ParentId": "3303164", "CommentCount": "16", "OwnerUserId": "140719", "LastEditDate": "2010-07-21T21:00:31.413"}, "3303198": {"Id": "3303198", "PostTypeId": "2", "Body": "<p>C and C++ do this comparison via pointer comparison; looks like your compiler is creating separate resource instances for the strings \"Maya\" and \"Maya\" (probably due to having an optimization turned off).</p>\n", "LastActivityDate": "2010-07-21T19:47:14.640", "CommentCount": "0", "CreationDate": "2010-07-21T19:47:14.640", "ParentId": "3303164", "Score": "1", "OwnerUserId": "28053"}, "3303187": {"Id": "3303187", "PostTypeId": "2", "Body": "<p>My compiler says they <em>are</em> the same ;-)</p>\n<p>even worse, my compiler is certainly broken. This very basic equation:</p>\n<pre><code>printf(\"23 - 523 = %d\\n\",\"23\"-\"523\");\n</code></pre>\n<p>produces:</p>\n<pre><code>23 - 523 = 1\n</code></pre>\n", "LastEditorUserId": "371793", "LastActivityDate": "2010-07-21T20:08:18.827", "Score": "1", "CreationDate": "2010-07-21T19:46:10.610", "ParentId": "3303164", "CommentCount": "11", "OwnerUserId": "371793", "LastEditDate": "2010-07-21T20:08:18.827"}});