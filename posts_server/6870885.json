post_cb({"6870885": {"CommentCount": "2", "AcceptedAnswerId": "6873644", "PostTypeId": "1", "LastEditorUserId": "34509", "CreationDate": "2011-07-29T09:02:28.443", "LastActivityDate": "2011-10-02T10:42:33.633", "LastEditDate": "2011-10-02T10:42:33.633", "ViewCount": "10532", "FavoriteCount": "2", "Title": "How to use extern template", "Id": "6870885", "Score": "25", "Body": "<p>I've been looking through the N3291 working draft of C++0x. And I was curious about extern template. Section 14.7.3 states:</p>\n<blockquote>\n<p id=\"so_6870885_6870885_0\">Except for inline functions and class template specializations, explicit instantiation declarations have the effect of suppressing the implicit instantiation of the entity to which they refer.</p>\n</blockquote>\n<p>FYI: the term \"explicit instantiation declaration\" is standard-speak for <code>extern template</code>. That was defined back in section 14.7.2.</p>\n<p>This sounds like it's saying that if you use <code>extern template std::vector&lt;int&gt;</code>, then doing any of the things that would normally implicitly instantiate <code>std::vector&lt;int&gt;</code> will not do so.</p>\n<p>The next paragraph is more interesting:</p>\n<blockquote>\n<p id=\"so_6870885_6870885_1\">If an entity is the subject of both an explicit instantiation declaration and an explicit instantiation definition in the same translation unit, the definition shall follow the declaration. An entity that is the subject of an explicit instantiation declaration and that is also used in a way that would otherwise cause an implicit instantiation (14.7.1) in the translation unit shall be the subject of an explicit instantiation definition somewhere in the program; otherwise the program is ill-formed, no diagnostic required.</p>\n</blockquote>\n<p>FYI: the term \"explicit instantiation definition\" is standard speak for these things: <code>template std::vector&lt;int&gt;</code>. That is, without the <code>extern</code>.</p>\n<p>To me, these two things say that <code>extern template</code> prevents implicit instantiation, but it does <em>not</em> prevent explicit instantiation. So if you do this:</p>\n<pre><code>extern template std::vector&lt;int&gt;;\ntemplate std::vector&lt;int&gt;;\n</code></pre>\n<p>The second line effectively negates the first by explicitly doing what the first line prevented from happening implicitly.</p>\n<p>The problem is this: Visual Studio 2008 doesn't seem to agree. The way I want to use <code>extern template</code> is to prevent users from implicitly instantiating certain commonly-used templates, so that I can explicitly instantiate them in the .cpp files to cut down on compile time. The templates would only be instantiated once.</p>\n<p>The problem is that I have to basically #ifdef around them in VS2008. Because if a single translation unit sees the <code>extern</code> and non-<code>extern</code> version, it will make the <code>extern</code> version win and nobody would ever instantiate it. And then come the linker errors.</p>\n<p>So, my questions are:</p>\n<ol>\n<li>What is the correct behavior according to C++0x? Should <code>extern template</code> prevent explicit instantiation or not?</li>\n<li>If the answer to the previous question is that it should not, then VS2008 is in error (granted, it was written well before the spec, so it's not like it's their fault). How does VS2010 handle this? Does it implement the correct <code>extern template</code> behavior?</li>\n</ol>\n", "Tags": "<c++><visual-studio-2008><templates><c++11><explicit-instantiation>", "OwnerUserId": "734069", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_6870885_6873644_0": {"section_id": 259, "quality": 1.0, "length": 4}, "so_6870885_6870885_0": {"section_id": 259, "quality": 1.0, "length": 17}, "so_6870885_6870885_1": {"section_id": 260, "quality": 0.9743589743589743, "length": 38}}, "n3337": {"so_6870885_6873644_0": {"section_id": 250, "quality": 1.0, "length": 4}, "so_6870885_6870885_0": {"section_id": 250, "quality": 1.0, "length": 17}, "so_6870885_6870885_1": {"section_id": 251, "quality": 0.9743589743589743, "length": 38}}, "n4659": {"so_6870885_6873644_0": {"section_id": 266, "quality": 1.0, "length": 4}, "so_6870885_6870885_0": {"section_id": 266, "quality": 1.0, "length": 17}, "so_6870885_6870885_1": {"section_id": 267, "quality": 0.9743589743589743, "length": 38}}}, "6873644": {"ParentId": "6870885", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>It says</p>\n<blockquote>\n<p id=\"so_6870885_6873644_0\">Except for ...class template specializations</p>\n</blockquote>\n<p>So it does not apply to <code>std::vector&lt;int&gt;</code>, but to its members (members that aren't inline member functions and presumably that aren't nested classes. Unfortunately, there isn't a one term that catches both of \"class template specialization and specializations of member classes of class templates\". So there are some places that use only the former but mean to also include the latter). So <code>std::vector&lt;int&gt;</code> and its nested classes (like <code>std::vector&lt;int&gt;::iterator</code>, if it is defined as a nested class) will still be implicitly instantiated if needed. </p>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2011-07-29T20:30:11.770", "Id": "6873644", "Score": "7", "CreationDate": "2011-07-29T13:11:38.863", "LastActivityDate": "2011-07-29T20:30:11.770"}});