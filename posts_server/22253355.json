post_cb({"22301358": {"Id": "22301358", "PostTypeId": "2", "Body": "<p>I can find nothing in the standard which would allow assigning\na vector to one with sufficient capacity to reduce the capacity.\nIf I've done <code>reserve</code> before the assignment, I'm guaranteed\nthat iterators won't be invalidated by a reallocation as long as\nthe vector never becomes larger than the capacity I reserved.</p>\n<p>The issue with move assignment is particular.  There doesn't\nseem to be any special case to allow it to invalidate iterators\n(unless the source is larger than the capacity of the\ndestination), but this sort of defeats the goal of move\nassignment.  I suspect that this is a defect in the standard. </p>\n<p>EDIT:</p>\n<p>For what it's worth, in table 96, for <code>a = rv</code> (where <code>a</code> is\na container, and <code>rv</code> is a non-const r-value of the same type of\ncontainer), the standard gives linear complexity, and says that\n\"all existing elements a <code>a</code> are either move assigned to or\ndestroyed\".  So apparently, the intent of the standard <em>is</em> for\nthe capacity not to be reduced; the execution-time benefits of\nmove only apply to the individual elements, not to the container\nitself. </p>\n", "LastEditorUserId": "649665", "LastActivityDate": "2014-03-10T13:28:03.007", "Score": "1", "CreationDate": "2014-03-10T13:22:57.550", "ParentId": "22253355", "CommentCount": "1", "OwnerUserId": "649665", "LastEditDate": "2014-03-10T13:28:03.007"}, "bq_ids": {"n4140": {"so_22253355_22253630_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 713}}, "n3337": {"so_22253355_22253630_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 702}}, "n4659": {"so_22253355_22253630_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 742}}}, "22253355": {"ViewCount": "580", "Body": "<p>For std::vector's copy assignment, is reallocation of storage and shrink of capacity allowed when the source's size is smaller than the destination's capacity?  Or is it guaranteed that the reallocation/shrink will not happen (i.e. always respect previous reserve())?</p>\n<p>On the other side, if the source's size is bigger than the destination's capacity and a reallocation takes place, is it required that the reallocation respect the source's capacity (e.g. the destination's new capacity should be no smaller than the source's capacity, or even require them to be the same)?  Or the reallocation simply does its job (based on the new size) with no regard to the source's capacity?</p>\n<p>As for move assignment, I suppose no storage reallocation will take place (though I failed to locate relevant part in the standard), so does it mean the value of the destination's new capacity will be exactly the same to the source's old capacity?  Can I expect <code>v = vector&lt;T&gt;{};</code> to have the same effect as <code>vector&lt;T&gt;{}.swap(v);</code>?</p>\n<p>I suppose the answers are buried somewhere in the standard, but I just failed to find them.\n(In case things are different for C++11 and C++03, I would like to know various requirements from both.)</p>\n<p>PS: For whatever answer of the above questions, is it the same for std::string (only in C++11 which means contiguous storage and no COW, C++03 string is out of the radar)?</p>\n", "Title": "What happens to the underlying storage upon vector's copy/move assignment?", "CreationDate": "2014-03-07T14:51:32.587", "LastActivityDate": "2014-03-10T13:28:03.007", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-03-07T16:31:23.857", "LastEditorUserId": "3237645", "Id": "22253355", "Score": "10", "OwnerUserId": "3237645", "Tags": "<c++><string><c++11><vector><language-lawyer>", "AnswerCount": "3"}, "22253558": {"Id": "22253558", "PostTypeId": "2", "Body": "<p>To answer your PS: \nAt least for <code>std::string</code>, you cannot assume that the handling of strings are similar to the handling of a vector of chararacters.</p>\n<p>COW (Copy-on-Write) is not mandatory to implement string, and not all library-implementations do this.</p>\n", "LastActivityDate": "2014-03-07T15:01:26.543", "CommentCount": "2", "CreationDate": "2014-03-07T15:01:26.543", "ParentId": "22253355", "Score": "0", "OwnerUserId": "1211081"}, "22253630": {"Id": "22253630", "PostTypeId": "2", "Body": "<pre><code>std::vector&lt;T,A&gt;( std::vector&lt;T,A&gt;&amp;&amp; )\n</code></pre>\n<p>this is guaranteed to be constant time (N3797 Table 99 <code>X u(rv)</code>).</p>\n<p>There is no way known to myself to move an arbitrary sized vector in constant time without just moving the pointers to the buffer.  If this (there is no way) is true, then the constructed vector must have a buffer at least as larger as the source buffer.  There is no wording in the standard that states <code>vector</code>s need be efficient, however: the right hand side <code>vector</code> can have its capacity reduced to any value greater than or equal to its <code>size</code>: the postcondition is only that the elements are the same.  In theory it could even be larger capacity, if the right hand side <code>vector</code> had \"hidden capacity\" that the compiler chose to expose for whatever reason (the phase of the moon, say).</p>\n<p>At no point in the N3797 standard is an upper bound on <code>capacity</code> placed on any container.  A conforming implementation can have all <code>std::vector</code>s have a minimum 2 million element capacity (barring <code>allocator</code> failure -- which could be used to force a capacity of <code>0</code>), with no operation capable of reducing that value below 2 million.  (<code>shrink_to_fit</code> is just a suggestion, and <code>std::vector&lt;T,A&gt;().swap(x)</code> could create a <code>vector</code> of 2 million capacity and swap it.</p>\n<p>As much of the above is of a negative form, all I can say is search the standard for every mention of <code>vector</code>, <code>allocator</code>, <code>allocate</code>, and <code>capacity</code>.  <code>capacity</code> is never described with an upper bound at any point.  No restrictions (other than exception-safety) are made against extra calls to the <code>allocator</code> in an empty <code>std::vector</code> constructor (if the <code>allocator</code> failed, you might have to stay size 0 and capacity 0, but extracting that state to anything that doesn't use the same <code>allocator</code> is challenging).</p>\n<hr>\n<p>As for copy assignment and move assignment, the copy assignment places no guarantees on capacity beyond the most basic (that <code>capacity() &gt;= size()</code>).</p>\n<p>For move-assignment, it depends on how this applies:</p>\n<p><strong>23.2.1 [container.requirements.general] /10</strong></p>\n<blockquote>\n<p id=\"so_22253355_22253630_0\">Unless otherwise specified (either explicitly or by defining a function in terms of other functions), invoking a\n  container member function or passing a container as an argument to a library function shall not invalidate\n  iterators to, or change the values of, objects within that container.</p>\n</blockquote>\n<p><code>a = rv</code> (aka <code>std::vector&lt;T,A&gt;&amp; operator=(std::vector&lt;T,A&gt;&amp;&amp;)</code>) case from Table 96 and Table 99 are what concern us.  Neither mention that the values contained in <code>rv</code> are destroyed, nor that iterators to them are invalidated.  As such, under 23.2.1/10 the iterators are not invalidated.</p>\n<p>This does not, however, demand that the buffer be moved.  Either the buffer is moved from the rhs to the lhs, or it remains intact in the rhs <code>vector</code>.  Table 99 mentions that case implicitly when it says that the lhs items can be move-assigned to (which is the only way a <code>std::array</code> can work).</p>\n<p>As <code>std::array</code> has no choice but to move elements, and <code>std::vector</code> gives no further guarantees about moving the buffer, the buffer does not have to be moved.  It appears that moving the buffer is a legal implementation, however.</p>\n<hr>\n<p>In practice, <code>std::vector&lt;T,A&gt;( std::vector&lt;T,A&gt; const&amp; )</code> will perform a copy of the contents of the right hand side into the left hand side, and in every implementation I have checked the left hand side's <code>capacity</code> is equal to the <code>size</code> of the resulting <code>vector</code>.  Similarly, <code>std::vector&lt;T,A&gt;( ForwardIterator, ForwardIterator )</code> will produce a <code>vector</code> that just-fits its input.</p>\n<p>Note that <code>std::vector&lt;T,A&gt;::operator=(std::vector&lt;T,A&gt;&amp;&amp;)</code> remains linear in complexity.</p>\n</hr></hr>", "LastEditorUserId": "1774667", "LastActivityDate": "2014-03-08T03:48:05.117", "Score": "2", "CreationDate": "2014-03-07T15:04:47.860", "ParentId": "22253355", "CommentCount": "3", "OwnerUserId": "1774667", "LastEditDate": "2014-03-08T03:48:05.117"}});