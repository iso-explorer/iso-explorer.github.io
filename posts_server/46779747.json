post_cb({"46779748": {"ParentId": "46779747", "CommentCount": "0", "CreationDate": "2017-10-16T08:03:52.860", "OwnerUserId": "8922", "Id": "46779748", "PostTypeId": "2", "OwnerDisplayName": "Sebastian Redl", "Score": "13", "Body": "<p><code>extern</code> is a little peculiar, in that a declaration marked with it looks for a previous declaration of the same entity, and if it finds one, it uses the previous linkage. Only if it doesn't find one does it declare a new entity with external linkage.</p>\n<p><code>static</code>, on the other hand, unconditionally declares its entity with internal linkage.</p>\n<p>This means that this code simply declares and defines <code>i</code> with internal linkage. The second declaration finds the first and reuses its linkage.</p>\n<pre><code>static int i;\nextern int i;\n</code></pre>\n<p>Whereas this code declares the variable to have external linkage, and then declares and defines it to have internal linkage, which is an error.</p>\n<pre><code>extern int i;\nstatic int i;\n</code></pre>\n<p>The reasons for this behavior are hard to track, but most likely reach back way to the pre-standard days of C.</p>\n<p>In C++, this behavior is specified by [basic.link], 6.5/6 in the most recent draft N4687:</p>\n<blockquote>\n<p id=\"so_46779747_46779748_0\">The name of a function declared in block scope and the name of a variable declared by a block scope extern declaration have linkage. If there is a visible declaration of an entity with linkage having the same name and type, ignoring entities declared outside the innermost enclosing namespace scope, the block scope declaration declares that same entity and receives the linkage of the previous declaration. If there is more than one such matching entity, the program is ill-formed. Otherwise, if no matching entity is found, the block scope entity receives external linkage.</p>\n</blockquote>\n", "LastActivityDate": "2017-10-16T08:03:52.860"}, "bq_ids": {"n4140": {"so_46779747_46779748_0": {"section_id": 7139, "quality": 0.9833333333333333, "length": 59}}, "n3337": {"so_46779747_46779748_0": {"section_id": 6883, "quality": 0.9833333333333333, "length": 59}}, "n4659": {"so_46779747_46779748_0": {"section_id": 8640, "quality": 0.9833333333333333, "length": 59}}}, "46779747": {"CommentCount": "1", "CreationDate": "2017-10-16T06:53:46.383", "PostTypeId": "1", "AcceptedAnswerId": "46779748", "LastEditorUserId": "7035151", "LastActivityDate": "2017-10-17T08:59:39.403", "AnswerCount": "1", "LastEditDate": "2017-10-17T08:59:39.403", "ViewCount": "51", "FavoriteCount": "1", "Title": "Declaring the same variables name within a given same scope in C++", "Id": "46779747", "Score": "3", "Body": "<p>I'm trying to understand <strong>Storage class specifiers</strong> in C++. I have a two cases.</p>\n<p>Here, Within a given same scope, declaring the same variables name.</p>\n<p><strong>Case 1:</strong></p>\n<pre><code>#include &lt;iostream&gt;\n\nstatic int i; \nextern int i; \n\nint main() {\n    std::cout&lt;&lt;i&lt;&lt;std::endl;\n    return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>0\n</code></pre>\n<p><strong>Case 2:</strong></p>\n<pre><code>#include &lt;iostream&gt;\n\nextern int i; \nstatic int i; \n\nint main() {\n    std::cout&lt;&lt;i&lt;&lt;std::endl;\n    return 0;\n}\n</code></pre>\n<p><strong>Getting an error:</strong></p>\n<pre><code>prog.cpp:4:12: error: 'i' was declared 'extern' and later 'static' [-fpermissive]\n static int i; \n            ^\nprog.cpp:3:12: note: previous declaration of 'i'\n extern int i;\n</code></pre>\n<p><strong>Why does first case working fine whereas second case give an error?</strong></p>\n", "Tags": "<c++><variables><storage><one-definition-rule>", "OwnerUserId": "7035151", "OwnerDisplayName": "Jayesh"}});