post_cb({"bq_ids": {"n4140": {"so_17198239_17198612_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 5559}}, "n3337": {"so_17198239_17198612_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 5341}}, "n4659": {"so_17198239_17198612_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 7006}}}, "17198612": {"Id": "17198612", "PostTypeId": "2", "Body": "<p>Obviously this will work for <em>some</em> iterators - <code>T*</code> being a clear example - but it's definitely not guaranteed correct behavior for <em>all</em> iterators.  C++11 24.2.1 [iterator.requirements.general] p5:</p>\n<blockquote>\n<p id=\"so_17198239_17198612_0\"><em>Singular values</em> are not associated with any sequence ... Results of most expressions are undefined for singular values; the only\n  exceptions are destroying an iterator that holds a singular value, the\n  assignment of a non-singular value to an iterator that holds a\n  singular value, and, for iterators that satisfy the\n  DefaultConstructible requirements, using a value-initialized iterator\n  as the source of a copy or move operation.</p>\n</blockquote>\n<p>You can replicate your desired behavior with a simple <code>bool</code> flag:</p>\n<pre><code>std::vector&lt;Elem&gt; container = foo();\nbool did_it_already = false;\n\nfor (I it = container.begin(), end = container.end(); it != end; ++it) {\n   if (!did_it_already &amp;&amp; bar(it)) {\n      // Does something only the first time bar(it) is satisfied\n\n      // ...\n\n      did_it_already = true;\n   }\n}\n</code></pre>\n", "LastActivityDate": "2013-06-19T18:26:05.053", "Score": "5", "CreationDate": "2013-06-19T18:26:05.053", "ParentId": "17198239", "CommentCount": "5", "OwnerUserId": "923854"}, "17198239": {"ViewCount": "526", "Body": "<p>I always thought that a \"singular\" iterator was one that has been default-initialised, and these could serve as comparable <em>sentinel</em> values of sorts:</p>\n<pre><code>typedef std::vector&lt;Elem&gt;::iterator I;\nI start = I();\n\nstd::vector&lt;Elem&gt; container = foo();\n\nfor (I it = container.begin(), end = container.end(); it != end; ++it) {\n   if ((start == I()) &amp;&amp; bar(it)) {\n      // Does something only the first time bar(it) is satisfied\n\n      // ...\n\n      start = it;\n   }\n}\n</code></pre>\n<p>But <a href=\"https://stackoverflow.com/a/2062986/560648\">this answer</a> suggests not only that my definition of \"singular\" is wrong, but also that my comparison above is totally illegal.</p>\n<p>Is it?</p>\n", "AcceptedAnswerId": "17198612", "Title": "Is this a singular iterator and, if so, can I compare it to another one?", "CreationDate": "2013-06-19T18:06:49.010", "Id": "17198239", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:56:02.783", "LastEditorUserId": "-1", "LastActivityDate": "2013-06-19T23:27:15.773", "Score": "8", "OwnerUserId": "560648", "Tags": "<c++><iterator><std><c++03>", "AnswerCount": "1"}});