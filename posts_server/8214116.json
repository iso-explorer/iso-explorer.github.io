post_cb({"8214311": {"ParentId": "8214116", "CommentCount": "1", "Body": "<p>You need a KNOWN value to use a signal. You don't have that unless you have a container to get .end() from, which you think is your problem.</p>\n<p>What you really need to do is get away from thinking that you can use 'special' iterator values for oddball cases that don't involve a container. Iterators, while they work a lot like pointers, are NOT pointers. They don't have the equivalent of 'NULL'. </p>\n<p>Instead, use a boolean flag value to see if the container is set or not, and make sure the iterators (all of them, if you have more than one) get set to some valid value when the container becomes known, and the flag gets set back to false when you lose the container. Then you can check the flag before any iterator operations.</p>\n", "OwnerUserId": "5801", "PostTypeId": "2", "Id": "8214311", "Score": "0", "CreationDate": "2011-11-21T15:38:55.113", "LastActivityDate": "2011-11-21T15:38:55.113"}, "8214201": {"ParentId": "8214116", "PostTypeId": "2", "CommentCount": "2", "Body": "<pre><code> it = jt; // crashes in VS 2010\n</code></pre>\n<p>This invokes undefined behaviour (UB). According to the C++ Standard ,<code>jt</code> is a <strong>singular</strong> iterator which is not associated with any container, and results of most expressions are undefined for singular iterator.</p>\n<p>The section \u00a724.1/5 from the C++ Standard (2003) reads (see the <strong>bold</strong> text specifically),</p>\n<blockquote>\n<p id=\"so_8214116_8214201_0\">Just as a regular pointer to an array\n  guarantees that there is a pointer\n  value pointing past the last element\n  of the array, so for any iterator type\n  there is an iterator value that points\n  past the last element of a\n  corresponding container. These values\n  are called past-the-end values. Values\n  of an iterator i for which the\n  expression *i is defined are called\n  dereferenceable. The library never\n  assumes that past-the-end values are\n  dereferenceable. <strong>Iterators can also\n  have singular values that are not\n  associated with any container.</strong>\n  [Example: After the declaration of an\n  uninitialized pointer x (as with int*\n  x;), x must always be assumed to have\n  a singular value of a pointer.]\n  <strong>Results of most expressions are\n  undefined for singular values;</strong> the\n  only exception is an assignment of a\n  non-singular value to an iterator that\n  holds a singular value. In this case\n  the singular value is overwritten the\n  same way as any other value.\n  Dereferenceable values are always\n  nonsingular.</p>\n</blockquote>\n<p>If MSVS2010 crashes this, it is one of infinite possibilities of UB, for UB means anything could happen; the Standard doesn't prescribe any behavior.</p>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-11-21T15:48:05.317", "Id": "8214201", "Score": "6", "CreationDate": "2011-11-21T15:30:54.397", "LastActivityDate": "2011-11-21T15:48:05.317"}, "8214256": {"ParentId": "8214116", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>C++11, 24.2.1/3: </p>\n<blockquote>\n<p id=\"so_8214116_8214256_0\">Results of most expressions are undefined for singular values; the\n  only exceptions are destroying an iterator that holds a singular\n  value, the assignment of a non-singular value to an iterator that\n  holds a singular value, and, for iterators that satisfy the\n  DefaultConstructible requirements, using a value-initialized iterator\n  as the source of a copy or move operation.</p>\n</blockquote>\n<p>The list is limitative, and your example isn't listed in the allowed exceptions. <code>jt</code> is singular and default-initialized. Therefore it may not be used as the source of a copy operation.</p>\n", "OwnerUserId": "15416", "LastEditorUserId": "15416", "LastEditDate": "2011-11-21T15:50:10.590", "Id": "8214256", "Score": "2", "CreationDate": "2011-11-21T15:35:13.917", "LastActivityDate": "2011-11-21T15:50:10.590"}, "8214116": {"CommentCount": "5", "AcceptedAnswerId": "8214201", "CreationDate": "2011-11-21T15:24:37.770", "LastActivityDate": "2011-11-21T15:50:10.590", "PostTypeId": "1", "ViewCount": "763", "FavoriteCount": "0", "Title": "Access violation when assigning an uninitialized iterator", "Id": "8214116", "Score": "2", "Body": "<p>I have a problem with assigning an unintialized to an initialized iterator. The following code excerpt produces an access violation when built with Visual Studio 2010. In previous versions of Visual Studio the code should work.</p>\n<pre><code>#include &lt;list&gt;\n\nint main() {\n    std::list&lt;int&gt; list;\n    std::list&lt;int&gt;::iterator it = list.begin();\n    std::list&lt;int&gt;::iterator jt;\n    it = jt; // crashes in VS 2010\n}\n</code></pre>\n<p>Wouldn't this be considered valid C++?</p>\n<p>I need this code to implement a \"cursor\" class that either points nowhere or to a specific element in a list. What else could I use as a value for an uninitialized iterator if I don't have a reference to my container yet?</p>\n", "Tags": "<c++><visual-studio-2010>", "OwnerUserId": "220438", "AnswerCount": "4"}, "8214216": {"ParentId": "8214116", "CommentCount": "1", "Body": "<p><code>list.end()</code> points anywhere beyond the container, so we can consider it like pointing nowhere.\nAlso accessing unitialized variable causes undefined behavior.</p>\n", "OwnerUserId": "1057470", "PostTypeId": "2", "Id": "8214216", "Score": "-1", "CreationDate": "2011-11-21T15:32:15.407", "LastActivityDate": "2011-11-21T15:32:15.407"}, "bq_ids": {"n4140": {"so_8214116_8214201_0": {"section_id": 5559, "quality": 0.898876404494382, "length": 80}, "so_8214116_8214256_0": {"section_id": 5559, "quality": 1.0, "length": 30}}, "n3337": {"so_8214116_8214201_0": {"section_id": 5341, "quality": 0.898876404494382, "length": 80}, "so_8214116_8214256_0": {"section_id": 5341, "quality": 1.0, "length": 30}}, "n4659": {"so_8214116_8214201_0": {"section_id": 7006, "quality": 0.898876404494382, "length": 80}, "so_8214116_8214256_0": {"section_id": 7006, "quality": 1.0, "length": 30}}}});