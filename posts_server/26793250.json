post_cb({"bq_ids": {"n4140": {"so_26793250_26793467_2": {"length": 6, "quality": 0.5454545454545454, "section_id": 3285}}, "n3337": {"so_26793250_26793467_2": {"length": 6, "quality": 0.5454545454545454, "section_id": 3155}}, "n4659": {"so_26793250_26793467_2": {"length": 6, "quality": 0.5454545454545454, "section_id": 4047}}}, "26793250": {"ViewCount": "642", "Body": "<p>What are the rules that govern the uninitialized bytes of a union ? (Assuming some are initialized)</p>\n<p>Below is a 32 bytes union of which I initialize only the first 16 bytes via the first member.\nIt seems the remaining bytes are zero-initialized. That's great for my use case but I am wondering what's the rule behind this - I was expecting garbage.</p>\n<pre><code>#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nunion Blah {\n   struct {\n      int64_t a;\n      int64_t b;\n   };\n   int64_t c[4];\n}\n\nint main()\n{\n   Blah b = {{ 1, 2 }}; // initialize first member, so only the first 16 bytes.\n\n   // prints 1, 2, 0,\u00a00 -- not 1, 2, &lt;garbage&gt;, &lt;garbage&gt;\n   cout &lt;&lt; b.c[0] &lt;&lt; \", \" &lt;&lt; b.c[1] &lt;&lt; \", \" &lt;&lt; b.c[2] &lt;&lt; \", \" &lt;&lt; b.c[3] &lt;&lt; '\\n';\n\n   return 0;\n}\n</code></pre>\n<p>I've compiled on GCC\u00a04.7.2\u00a0with <code>-O3</code> <code>-Wall</code> <code>-Wextra</code> <code>-pedantic</code> (that last one required giving a name to the anonymous struct). That hopefully should save me from being lucky.</p>\n<p>I've also tried to overlay two variables with two different scopes on the stack but gcc didn't give them the same address.</p>\n<p>I've also tried replacing the array by another struct in that case that would have mattered, but it didn't change anything.</p>\n<p>I can't access online compilers from here, they're blocked by my work.</p>\n", "AcceptedAnswerId": "26793540", "Title": "Union initialization", "CreationDate": "2014-11-07T02:53:13.033", "Id": "26793250", "CommentCount": "0", "LastEditDate": "2015-05-13T12:53:20.527", "PostTypeId": "1", "LastEditorUserId": "718379", "LastActivityDate": "2015-05-13T12:53:20.527", "Score": "2", "OwnerUserId": "628361", "Tags": "<c++><initialization><unions>", "AnswerCount": "2"}, "26793540": {"Id": "26793540", "PostTypeId": "2", "Body": "<p>Brace-enclosed initializers for a <code>union</code> are only permitted to initialize the first member. This is fine, and your initializer does initialize the anonymous struct, and causes the first member to be the active member.</p>\n<p>In C++ only one member of a union may be active at any time. Trying to read the other members via the union causes undefined behaviour.  Trying to read them by aliasing them as a character type gives unspecified values.</p>\n", "LastActivityDate": "2014-11-07T03:25:40.727", "CommentCount": "4", "CreationDate": "2014-11-07T03:25:40.727", "ParentId": "26793250", "Score": "1", "OwnerUserId": "1505939"}, "26793467": {"Id": "26793467", "PostTypeId": "2", "Body": "<p>The most pertinent part of the C11 standard 6.2.6.1.7, while not speaking specifically to initialization:</p>\n<blockquote>\n<p id=\"so_26793250_26793467_0\">When a value is stored in a member of an object of union type, the\n  bytes of the object representation that do not correspond to that\n  member but do correspond to other members take unspecified values.</p>\n</blockquote>\n<p>Section 6.7.9.17 says:</p>\n<blockquote>\n<p id=\"so_26793250_26793467_1\">Each brace-enclosed initializer list has an associated current object.\n  When no designations are present, subobjects of the current object are\n  initialized in order according to the type of the current object:\n  array elements in increasing subscript order, structure members in\n  declaration order, and the first named member of a union.</p>\n</blockquote>\n<p>but doesn't explicitly come out and say the other bits are not initialized. For static unions, 6.7.9.10 says:</p>\n<blockquote>\n<p id=\"so_26793250_26793467_2\">the first named member is initialized (recursively) according to these\n  rules, and any padding is initialized to zero bits;</p>\n</blockquote>\n<p>so the first named member and any padding bits would be zero-initialized, but the bits corresponding to other (by implication, larger) members of the union would be unspecified.</p>\n<p>So you cannot count on those extra bytes being initialized to zero.</p>\n<p>Note that technically, even if you do initialize your <code>c</code> array to zero, the moment you store something in your <code>struct</code> those excess bits become unspecified again, and you can't count on them still being zero. There's a lot of code out there which assumes this is true (e.g. putting a <code>char</code> array in a union to access the individual bytes), and in reality it probably will be, but the standard doesn't guarantee it.</p>\n", "LastEditorUserId": "2399879", "LastActivityDate": "2014-11-07T03:24:22.380", "Score": "6", "CreationDate": "2014-11-07T03:18:33.140", "ParentId": "26793250", "CommentCount": "2", "OwnerUserId": "2399879", "LastEditDate": "2014-11-07T03:24:22.380"}});