post_cb({"5061364": {"ParentId": "5061275", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2011-02-21T01:07:49.013", "Score": "2", "LastEditorUserId": "34509", "LastEditDate": "2011-02-21T01:18:25.057", "Id": "5061364", "OwnerUserId": "34509", "Body": "<p>Your code is not really C++. It uses a compound literal which is a C99 feature. In C99 it evaluates to an lvalue and taking the address of the literal is completely fine there. Integrating this extension into C++, GCC appears to change the rule of it and make it an rvalue, better fitting the classification of them into the existing rules of C++ for usual casts that also produce rvalues. </p>\n<p>GCC does not like <code>&amp;(Temp){42}</code>, complaining that I take the address of a temporary. It's a warning about invalid code which it still accepts but does not really like. The same warning is given for other obviously-wrong code like <code>&amp;A()</code>, which is a legal functional style C++ cast, which also produces an rvalue and thus cannot be used as the operand of the address-of operator. </p>\n<p>The integration of compound literals into C++ by GCC also destroys the temporary prematurely, as can be seen by the following test</p>\n<pre><code>#include &lt;iostream&gt;\nstruct B {\n  ~B() {\n    std::cout &lt;&lt; \"~B\" &lt;&lt; std::endl;\n  }\n};\nstruct A { int i; B b; };\n\nint main() {\n  A *a = &amp;(A){0};\n  std::cout &lt;&lt; \"main\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>In C99, the object that the literal refers to will be alive for the entire block (it will have automatic storage duration). In GNU C++ the object is destructed already at the end of the full expression, before the end of its block is even reached (the \"~B\" is printed before the \"main\"). </p>\n", "LastActivityDate": "2011-02-21T01:18:25.057"}, "5061275": {"CommentCount": "4", "AcceptedAnswerId": "5061364", "PostTypeId": "1", "LastEditorUserId": "635608", "CreationDate": "2011-02-21T00:47:04.470", "LastActivityDate": "2015-05-04T10:17:17.477", "LastEditDate": "2015-05-04T10:17:17.477", "ViewCount": "1172", "FavoriteCount": "1", "Title": "Binding rvalue to non-const reference via pointer cast?", "Id": "5061275", "Score": "7", "Body": "<p>I don't understand how the following code compiles/doesn't compile:</p>\n<pre><code>struct Temp\n{\n  int i;\n};\n\nint main(int argc, char * argv[])\n{\n   //Temp &amp;ref1 = (Temp){42}; // Error, as expected\n   Temp &amp;ref2 = *(Temp*)&amp;(Temp){42}; // A-OK\n   std::cerr &lt;&lt; ref2.i &lt;&lt; std::endl;\n   return 0;\n}\n</code></pre>\n<p>I'm using g++ 4.4.4.</p>\n", "Tags": "<c++><reference><g++><rvalue>", "OwnerUserId": "625809", "AnswerCount": "3"}, "5061376": {"ParentId": "5061275", "CommentCount": "0", "CreationDate": "2011-02-21T01:10:05.660", "OwnerUserId": "491645", "PostTypeId": "2", "Id": "5061376", "Score": "0", "Body": "<p>As templatetypedef has said, it does appear to be a bug in the compiler. When compiled with the 4.6.0 version of GCC, it gives:</p>\n<pre><code>error: taking address of temporary [-fpermissive]\n</code></pre>\n<p>And, of course, with the addition of -fpermissive, it compiles but complains, but still it doesn't crash and prints the correct result. I guess GCC is cheating a bit under \"permissive\" conditions.</p>\n", "LastActivityDate": "2011-02-21T01:10:05.660"}, "5061303": {"ParentId": "5061275", "CommentCount": "0", "CreationDate": "2011-02-21T00:52:58.807", "OwnerUserId": "501557", "PostTypeId": "2", "Id": "5061303", "Score": "0", "Body": "<p>I could be mistaken about this, but this looks like a bug in the compiler.  The C++ ISO standard, \u00a75.3.1/2, discusses the <code>&amp;</code> operator as</p>\n<blockquote>\n<p id=\"so_5061275_5061303_0\">The result of the unary &amp; operator is a pointer to its operand. <strong>The operand shall be an lvalue or a qualified-id.</strong></p>\n</blockquote>\n<p>The section \u00a75.4/1 discusses the casting operator as</p>\n<blockquote>\n<p id=\"so_5061275_5061303_1\">The result of the expression (T) <em>cast-expression</em> is of type <code>T</code>. The result is an lvalue if T is a reference type, <strong>otherwise the result is an rvalue.</strong></p>\n</blockquote>\n<p>This seems to suggest that</p>\n<pre><code>(Temp){42}\n</code></pre>\n<p>Produces an rvalue, which you should not be legally allowed to take the address of using <code>&amp;</code>.</p>\n<p>I've been known to make mistakes reading the spec before, so if someone could confirm this that would be awesome.</p>\n", "LastActivityDate": "2011-02-21T00:52:58.807"}, "bq_ids": {"n4140": {"so_5061275_5061303_1": {"section_id": 6123, "quality": 0.7692307692307693, "length": 10}, "so_5061275_5061303_0": {"section_id": 6066, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_5061275_5061303_1": {"section_id": 5887, "quality": 0.7692307692307693, "length": 10}, "so_5061275_5061303_0": {"section_id": 5834, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_5061275_5061303_1": {"section_id": 7620, "quality": 0.7692307692307693, "length": 10}, "so_5061275_5061303_0": {"section_id": 7562, "quality": 0.8181818181818182, "length": 9}}}});