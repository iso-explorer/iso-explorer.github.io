post_cb({"2174316": {"Id": "2174316", "PostTypeId": "2", "Body": "<p>I stand corrected - see the comments below. I won't change any of my original post, as that would remove the context of the responses. I thank the commenters for their input, and for being so kind as to not vote me down</p>\n<hr>\n<p>Consider templating to be like the macro pre-processor, which expands #defines before the compiler gets to see them. </p>\n<p>The compiler will \"expand\" your template parameters and then look at your function declarations. So, template parameter == function parameter. If you declare the same function twice, you will get an error.  </p>\n<p>You ask about return type. That is part of the function's 'signature'. Two functions with the same parameters but different return types are two different functions.</p>\n</hr>", "LastEditorUserId": "192910", "LastActivityDate": "2010-02-01T13:07:28.887", "Score": "1", "CreationDate": "2010-02-01T02:25:16.533", "ParentId": "2174300", "CommentCount": "4", "LastEditDate": "2010-02-01T13:07:28.887", "OwnerUserId": "192910"}, "2175718": {"Id": "2175718", "PostTypeId": "2", "Body": "<p>Of that list only the second introduces ambiguity, because functions - regardless of whether they are templates - can't be overloaded based on return type.</p>\n<p>You can use the other two:</p>\n<pre><code>template&lt;typename X&gt; void func(X x, int y);\n</code></pre>\n<p>will be used if the second argument of the call is an int, e.g <code>func(\"string\", 10);</code></p>\n<pre><code>template&lt;class X, class Y, class Z&gt; void func(X x, Y y, Z z);\n</code></pre>\n<p>will be used if you call func with three arguments.</p>\n<hr>\n<p>I don't understand why some other answers mentions that template functions and function overloading doesn't mix. They certainly do, and there are special rules how the function to call is selected. </p>\n<p><strong>14.5.5</strong></p>\n<blockquote>\n<p id=\"so_2174300_2175718_0\">A  function  template  can be\n  overloaded with other function\n  templates and with normal\n  (non-template) functions.  A normal \n  function  is  not related  to  a\n  function template (i.e., it is never\n  considered to be a specialization),\n  even if it has the same name and  type\n  as  a  potentially generated function\n  template specialization.)</p>\n</blockquote>\n<p>A non-templated (or \"less templated\") overload is preferred to templates, e.g</p>\n<pre><code>template &lt;class T&gt; void foo(T);\nvoid foo(int);\n\nfoo(10); //calls void foo(int)\nfoo(10u); //calls void foo(T) with T = unsigned\n</code></pre>\n<p>Your first overload with one non-template parameter also falls under this rule.</p>\n<p>Given choice between several templates, more specialized matches are preferred:</p>\n<pre><code>template &lt;class T&gt; void foo(T);\ntemplate &lt;class T&gt; void foo(T*);\n\nint i;\nint* p;\nint arr[10];\n\nfoo(i);  //calls first\nfoo(p);   //calls second\nfoo(arr); //calls second: array decays to pointer\n</code></pre>\n<p>You can find a more formal description of all the rules in the same chapter of the standard (<em>Function templates</em>)</p>\n<hr>\n<p>And finally there are some situations where two or more overloads would be ambiguous:</p>\n<pre><code>template &lt;class T&gt; void foo(T, int);\ntemplate &lt;class T&gt; void foo(int, T);\n\nfoo(1, 2);\n</code></pre>\n<p>Here the call is ambiguous, because both candidates are equally specialized.</p>\n<p>You can disambiguate such situations with the use of (for example) <code>boost::disable_if</code>. For example, we can specify that when T = int, then the second overload shouldn't be included as an overload candidate:</p>\n<pre><code>#include &lt;boost/utility/enable_if.hpp&gt;\n#include &lt;boost/type_traits/is_same.hpp&gt;\ntemplate &lt;class T&gt;\nvoid foo(T x, int i);\n\ntemplate &lt;class T&gt;\ntypename boost::disable_if&lt;boost::is_same&lt;int, T&gt; &gt;::type\nfoo(int i, T x);\n\nfoo(1, 2); //calls the first\n</code></pre>\n<p>Here the library produces a \"substitution failure\" in the return type of the second overload, if T = int, removing it from the set of overload candidates.</p>\n<p>In practice you should rarely run into situations like that.</p>\n</hr></hr>", "LastEditorUserId": "219972", "LastActivityDate": "2010-02-01T09:53:05.517", "Score": "20", "CreationDate": "2010-02-01T09:40:22.067", "ParentId": "2174300", "CommentCount": "3", "LastEditDate": "2010-02-01T09:53:05.517", "OwnerUserId": "219972"}, "2176190": {"Id": "2176190", "PostTypeId": "2", "Body": "<p>In addition to comments, some more information on topic in Herb Sutters's article <a href=\"http://www.gotw.ca/publications/mill17.htm\" rel=\"nofollow noreferrer\">Why Not Specialize Function Templates</a>. Hope it would be helpful, too.</p>\n", "LastActivityDate": "2010-02-01T11:10:17.500", "Score": "1", "CreationDate": "2010-02-01T11:10:17.500", "ParentId": "2174300", "CommentCount": "0", "OwnerUserId": "104451"}, "bq_ids": {"n4140": {"so_2174300_2175718_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 152}}, "n3337": {"so_2174300_2175718_0": {"length": 26, "quality": 1.0, "section_id": 146}}, "n4659": {"so_2174300_2175718_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 156}}}, "2174300": {"ViewCount": "21456", "Body": "<p>Can anybody summarize the idea of function template overloading?  What matters, template parameter or function parameter? What about the return value?</p>\n<p>For example, given a function template </p>\n<pre><code>template&lt;typename X, typename Y&gt; void func(X x, Y y) {};\n</code></pre>\n<p>what's the overloaded function template?</p>\n<pre><code>1) template&lt;typename X&gt; void func(X x, int y) {};       \n2) template&lt;typename X, typename Y&gt; X func(X x, Y y) {};    \n3) template&lt;class X, class Y, class Z&gt; void func(X x, Y y, Z z) {};\n</code></pre>\n", "AcceptedAnswerId": "2175718", "Title": "function template overloading", "CreationDate": "2010-02-01T02:16:30.773", "Id": "2174300", "CommentCount": "1", "FavoriteCount": "11", "PostTypeId": "1", "LastEditDate": "2017-03-07T23:11:32.137", "LastEditorUserId": "6410484", "LastActivityDate": "2017-03-07T23:11:32.137", "Score": "13", "OwnerUserId": "233254", "Tags": "<c++><templates><overloading>", "AnswerCount": "4"}, "2174369": {"Id": "2174369", "PostTypeId": "2", "Body": "<p>There are two separate things here: function templating and function overloading. Any two distinct template declarations are likely to be overloads of each other, so your question doesn't quite make sense as stated. (The three \"overloads\" you give do not build upon the first template, rather you have four overloads to the same function name.) The real issue is, given some overloads <em>and a call</em>, how to call the desired overload?</p>\n<p>First, the return type doesn't participate in the overloading process whether or not there is a template involved. So #2 will never play well with #1.</p>\n<p>Second, the rules for function template overload resolution are different from the more commonly used class template specialization rules. Both essentially solve the same problem, but</p>\n<ul>\n<li>the rules for class templates are simpler and more powerful, allowing for example recursion, and (member) functions differing only by return type</li>\n<li>the rules for function templates allow the compiler to figure the template arguments from the function argument types</li>\n</ul>\n<p>You might be able to solve your particular problem with function template overloads, but you may have trouble fixing any bug that arises as the rules are longer and fewer people are familiar with their intricacies. I was unaware after a few years of template hacking that subtle function template overloading was even possible. In libraries such as Boost and GCC's STL, an alternative approach is ubiquitous. Use a templated wrapper class:</p>\n<pre><code>template&lt; typename X, typename Y &gt;\nstruct functor {\n    void operator()( X x, Y y );\n};\ntemplate&lt; typename X &gt; // partial specialization: \nstruct functor&lt; X, int &gt; { // alternative to overloading for classes\n    void operator()( X x, int y );\n};\n</code></pre>\n<p>Now you sacrifice the implicit instantiation syntax (with no angle brackets). If you want to get that back, you need another function</p>\n<pre><code>template&lt; typename X, typename Y &gt; void func( X x, Y y ) {\n    return functor&lt; X, Y &gt;()( x, y );\n}\n</code></pre>\n<p>I'd be interested to hear whether function overloading can do anything (besides deduction) that class [partial] specialization can't\u2026</p>\n<p>And then, of course, your overload #3 will never face ambiguity because it has a different number of arguments than any other overload.</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2010-02-01T21:29:56.507", "Score": "3", "CreationDate": "2010-02-01T02:47:17.593", "ParentId": "2174300", "CommentCount": "4", "LastEditDate": "2010-02-01T21:29:56.507", "OwnerUserId": "153285"}});