post_cb({"11694142": {"ParentId": "11693512", "LastEditDate": "2012-07-28T17:25:55.920", "CommentCount": "3", "CreationDate": "2012-07-27T19:06:19.770", "OwnerUserId": "187690", "LastEditorUserId": "187690", "PostTypeId": "2", "Id": "11694142", "Score": "3", "Body": "<p>I think you are trying to derive a \"theorem\" from the facts that can be found in the standard, and then you expect the standard to acknowledge the existence of that \"theorem\". The standard does not do that. It doesn't strive to find and incorporate all possible \"theorems\" that can be derived from the standard text.</p>\n<p>Your \"theorem\" is perfectly valid (unless I'm missing something). You are right, since class <code>B</code> is abstract, this class can never be used as a most derived class. This immediately means that class <code>B</code> will never get a chance to construct its virtual base <code>A</code>. And that means that technically in <code>B</code> the compiler should not care about the availability, and/or accessibility of the appropriate constructors in <code>A</code> or in any other virtual bases.</p>\n<p>But the standard simply does not make that connection and does not care to make it. It doesn't treat constructors of abstract classes in any special way. The requirements imposed on such constructors are the same as for non-abstract classes.</p>\n<p>You can call try suggesting it as a possible improvement to the standard committee.</p>\n", "LastActivityDate": "2012-07-28T17:25:55.920"}, "11694039": {"ParentId": "11693512", "CommentCount": "0", "Body": "<p>It looks like 12.6.2/4 prohibits this to me:</p>\n<blockquote>\n<p id=\"so_11693512_11694039_0\">If a given nonstatic data member or base class is not named by a\n  mem-initializer-id (including the case where there is no\n  mem-initializer-list because the constructor has no ctor-initializer),\n  then</p>\n<p id=\"so_11693512_11694039_1\">\u2014 If the entity is a nonstatic data member of (possibly\n  cv-qualified) class type (or array thereof) or a base class, and the\n  entity class is a non-POD class, the entity is default-initialized\n  (8.5)...</p>\n</blockquote>\n<p>It looks to me like that regardless of the class being a virtual base, <code>B</code>'s default constructor is still synthesized by the compiler, and such default constructor doesn't know how to construct its <code>A</code> base (\"the entity is default-initialized (8.5)\").</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "11694039", "Score": "0", "CreationDate": "2012-07-27T18:58:04.213", "LastActivityDate": "2012-07-27T18:58:04.213"}, "11693977": {"ParentId": "11693512", "CommentCount": "3", "Body": "<p>Clang shows the error as: </p>\n<pre><code>error: call to implicitly-deleted default constructor of 'B'\n    C(): A( 1 ) {  }\n    ^\n</code></pre>\n<p>12.1/5 says \"A defaulted default constructor for class X is defined as deleted if [...] any [...] virtual base class [...] has class type M [...] and [...] M has no default constructor [...].\"</p>\n", "OwnerUserId": "365496", "PostTypeId": "2", "Id": "11693977", "Score": "4", "CreationDate": "2012-07-27T18:52:42.860", "LastActivityDate": "2012-07-27T18:52:42.860"}, "11693512": {"CommentCount": "0", "CreationDate": "2012-07-27T18:22:32.797", "PostTypeId": "1", "AcceptedAnswerId": "11693977", "LastEditorUserId": "963864", "LastActivityDate": "2012-08-04T17:00:23.673", "LastEditDate": "2012-08-04T17:00:23.673", "ViewCount": "1291", "FavoriteCount": "1", "Title": "Virtual inheritance vs. non-default constructors", "Id": "11693512", "Score": "6", "Body": "<p>This code is rejected by (at least) MSVC, ICC, and GCC:</p>\n<pre><code>class A {\npublic:\n    A( int ) {  }\n};\n\nclass B: virtual public A {\npublic:\n    //B(): A( -1 ) {  } // uncomment to make it compilable\n    virtual void do_something() = 0;\n};\n\nclass C: public B {\npublic:\n    C(): A( 1 ) {  }\n    virtual void do_something() {  }\n};\n\nint main() {\n    C c;\n    return 0;\n}\n</code></pre>\n<p>on the basis of</p>\n<pre><code>error : no default constructor exists for class \"A\"\n    class B: virtual public A {\n                            ^\n            detected during implicit generation of \"B::B()\" at line 14\n</code></pre>\n<p>Questions:</p>\n<ol>\n<li><p>If the code is indeed invalid, how <em>exactly</em> does this follow from\nthe standard? AFAICT, 10.4/2 and 1.8/4 taken together imply that B\ncannot be a type of the most derived class, and therefore from\n12.6.2/10 we have that B can never, ever call A's constructors.\n(The section numbers are for C++11.)</p></li>\n<li><p>If the code is valid, are compilers violating the standard by\nrequiring the presence of constructors they could not possibly call?\nNote that not only they want to call A::A() from B::B(), but they\nwant to do it <em>while compiling C::C()</em> (double weird).</p></li>\n</ol>\n<p>P.S. This was originally asked on the ICC forum, but posted here due to not being limited to this compiler (and no details forthcoming).</p>\n", "Tags": "<c++><constructor><language-lawyer><virtual-inheritance>", "OwnerUserId": "1558356", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_11693512_11694039_0": {"section_id": 435, "quality": 0.6470588235294118, "length": 11}, "so_11693512_11694039_1": {"section_id": 369, "quality": 0.6111111111111112, "length": 11}}, "n3337": {"so_11693512_11694039_0": {"section_id": 427, "quality": 0.9411764705882353, "length": 16}, "so_11693512_11694039_1": {"section_id": 4515, "quality": 0.6111111111111112, "length": 11}}, "n4659": {"so_11693512_11694039_0": {"section_id": 454, "quality": 0.6470588235294118, "length": 11}}}});