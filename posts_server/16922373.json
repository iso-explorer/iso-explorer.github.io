post_cb({"bq_ids": {"n4140": {"so_16922373_16925113_0": {"length": 63, "quality": 0.9692307692307692, "section_id": 7137}}, "n3337": {"so_16922373_16925113_0": {"length": 63, "quality": 0.9692307692307692, "section_id": 6881}}, "n4659": {"so_16922373_16925113_0": {"length": 59, "quality": 0.9076923076923077, "section_id": 8638}}}, "16922373": {"ViewCount": "878", "Body": "<p>I am working with a library. The library has one file containing the interface that I actually want exposed to other programs, contained in <code>foo.h</code> and <code>foo.cpp</code>. It also contains a bunch of helper classes and utility functions, in files <code>bar1.h</code>, <code>bar2.h</code>, <code>bar1.cpp</code>, <code>bar2.cpp</code>, etc.</p>\n<p>If I compile all of these files and stick them in a .lib, the problem I run into is that some of the symbols in the <code>bar</code> files have very common names that clash with those in other external libraries I need to link against.</p>\n<p>If all of the code were in one single .cpp file, I know how to fix this: I can use <code>static</code> or <code>namespace { }</code> to stop the linker from exporting the internal symbols. But obviously I have to declare the stuff in <code>bar</code> <code>extern</code> if I want to access it in <code>foo</code>.</p>\n<p>I can wrap all of the .cpp files in <code>namespace baz { }</code>. If I choose baz carefully, so that there is little chance of it conflicting with namespaces used in other libraries, that will substantially fix the problem. But ideally, <em>nothing</em> outside of the symbols in <code>foo.h</code> should get exported into my .lib. Is there a technique for doing this?</p>\n", "AcceptedAnswerId": "16925113", "Title": "hiding internal symbols in a library", "CreationDate": "2013-06-04T15:58:06.670", "Id": "16922373", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-06-05T07:22:59.713", "Score": "2", "OwnerUserId": "168715", "Tags": "<c++>", "AnswerCount": "1"}, "16925113": {"Id": "16925113", "PostTypeId": "2", "Body": "<p>You <em>can</em> achieve this, however it comes at some cost:</p>\n<p>in C++ you can have <em>internal linkage</em>. Anything inside a unnamed namespace has internal linkage* (see footnote), as well as static free functions (you should prefer the anonymous namespace).</p>\n<p><strong>Update:</strong> here's the C++11 standard quote from <strong>\u00a73.5,4</strong>:</p>\n<blockquote>\n<p id=\"so_16922373_16925113_0\">An unnamed namespace or a namespace declared directly or indirectly within an unnamed namespace has\n  internal linkage. All other namespaces have external linkage. A name having namespace scope that has not\n  been given internal linkage above has the same linkage as the enclosing namespace if it is the name of<br>\n  \u2014 a variable; or<br>\n  \u2014 a function; or<br>\n  \u2014 a named class (Clause 9), or an unnamed class defined in a typedef declaration in which the class has the typedef name for linkage purposes (7.1.3); or<br>\n  \u2014 a named enumeration (7.2), or an unnamed enumeration defined in a typedef declaration in which the enumeration has the typedef name for linkage purposes (7.1.3); or<br>\n  \u2014 an enumerator belonging to an enumeration with linkage; or<br>\n  \u2014 a template.</br></br></br></br></br></br></p>\n</blockquote>\n<p>However, internal linkage applies to translation units, not to static libraries. So if you would use the usual approach putting each class in its own translation unit (=cpp), you could not define them inside anonymous namespaces because you could not link them together to build the library.<br>\nYou can solve this dilemma by making the whole library one single translation unit: one header providing the library's public interface, one source with the function definitions, and anything else as headers, defined in anonymous namespaces:</br></p>\n<p><strong>mylib.hpp</strong> </p>\n<pre><code>class MyLib {\npublic:\n int foo();\n double bar(int i);\n};\n</code></pre>\n<p><strong>mylib.cpp</strong></p>\n<pre><code>#include \"mylib.hpp\"\n#include \"mylibimpl.h\"\n\nint MyLib::foo() {\n  return fooimpl();\n}\n\ndouble MyLib::bar(int i) {\n  return BarImpl(i).do();\n}\n</code></pre>\n<p><strong>mylibimpl.h</strong></p>\n<pre><code>namespace {\n  inline int fooimpl() { return 42; }\n\n  class BarImpl {\n    double d;\n  public:\n\n    BarImpl(int i) : d(i*3.42) {}\n    double do() { return 2*d; }\n  };\n}\n</code></pre>\n<p>You'll now have one translation unit (<code>mylib.o</code> / <code>mylib.lib</code>), and all the <code>*impl</code> classes and functions cannot be seen from outside, because they have internal linkage.</p>\n<p>The cost is that you have to reorganize the sources of your internal classes (e.g. to resolve circular dependencies) and that every simple change of the library's internal code will lead to one big recompilation of everything in the lib, just because there is only the single huge translation unit. So you should do this only when the library code itself is very stable or if the library is not too big.\nThe benefit besides the complete hiding of internal symbols is that the compiler will be able to pull out any optimization it wants, because no implementation details are hidden in different translation units.</p>\n<p>*<strong>Footnote:</strong>\nAs was commented by Billy ONeal, in C++03 entities in anonymous namespaces have <em>not</em> necessarily internal linkage. However, if they have external linkage, they have names unique to their tranlsation unit and are effectively not accessible from outside that TU, meaning that this procedure works in C++03 as well.</p>\n", "LastEditorUserId": "1838266", "LastActivityDate": "2013-06-05T07:22:59.713", "Score": "3", "CreationDate": "2013-06-04T18:38:01.993", "ParentId": "16922373", "CommentCount": "4", "OwnerUserId": "1838266", "LastEditDate": "2013-06-05T07:22:59.713"}});