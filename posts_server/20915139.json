post_cb({"bq_ids": {"n4140": {"so_20915139_20915233_0": {"length": 15, "quality": 0.6818181818181818, "section_id": 3321}}, "n3337": {"so_20915139_20915233_0": {"length": 15, "quality": 0.6818181818181818, "section_id": 3191}}, "n4659": {"so_20915139_20915233_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 4086}}}, "20915139": {"ViewCount": "257", "Body": "<p>I believe this may apply to many T's, but I know for sure this applies to integers. As part of learning  C++, I am trying to explain the following behavior in terms of the language in the standard.</p>\n<pre><code>typedef const int * constintptr;\ntypedef int * intptr;\n\nintptr p;\nconstintptr cp = p;\nconst constintptr&amp; crcp = p;\n//constintptr &amp; rcp = p;\n</code></pre>\n<p>From looking at n3337, sec 8.5.3.  It seems this behavior is explained by saying that int* is convertible to a const int * prvalue, but is not reference compatible. (correct me if I am wrong). </p>\n<p>I see that this is desirable behavior (or we could subvert the const), and the desirability of this behavior is not what this question is about. </p>\n<p>The question is  where in the standard it is specified (or implied) that they intptr and constintptr are not reference-compatible.</p>\n", "AcceptedAnswerId": "20915233", "Title": "T* and const T*", "CreationDate": "2014-01-04T00:20:46.980", "Id": "20915139", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-01-04T00:25:25.037", "LastEditorUserId": "3040457", "LastActivityDate": "2014-01-04T01:04:14.340", "Score": "4", "OwnerUserId": "2392147", "Tags": "<c++><pointers><c++11><const>", "AnswerCount": "1"}, "20915233": {"Id": "20915233", "PostTypeId": "2", "Body": "<p>Same section, 8.5.3/4 (numbering from in n3797, which I have available) defines reference-compatible:</p>\n<blockquote>\n<p id=\"so_20915139_20915233_0\">Given types \u201c<em>cv1</em> <code>T1</code>\u201d and \u201c<em>cv2</em> <code>T2</code>,\u201d \u201c<em>cv1</em> <code>T1</code>\u201d is <em>reference-related</em>\n  to \u201c<em>cv2</em> <code>T2</code>\u201d if <code>T1</code> is the same type as <code>T2</code> , or <code>T1</code> is a base class of\n  <code>T2</code> . \u201c<em>cv1</em> <code>T1</code>\u201d is <em>reference-compatible</em> with \u201c<em>cv2</em> <code>T2</code>\u201d if <code>T1</code> is\n  reference-related to <code>T2</code> and <em>cv1</em> is the same cv-qualification as, or\n  greater cv-qualification than, <em>cv2</em> </p>\n</blockquote>\n<p>So you have type T1 is <code>int*</code> and T2 <code>int const*</code>. They are not the same type. Neither one of them is a base class of the other (because neither is a class at all). Therefore, they are not reference-related.</p>\n<p>When the standard says \"cv1 T1\", it means any type that is a result of applying 0 or more of <code>const</code>, <code>volatile</code> to the type <code>T1</code>. It <em>does not</em> mean textual substitution, that is to say it does not mean any type that is declared by 0 or more of the keywords <code>const</code>, <code>volatile</code> followed by another sequence of tokens which is a type declaration for T1.</p>\n<p>So it's possible that you've misunderstood this such that you think <code>const int*</code> is a cv-qualified version of <code>int*</code>. If it were, then under the general rule they would be reference-related and so there would need to be text in the standard to make an exception. But it is not. <code>int *const</code> is a cv-qualified version of <code>int*</code>.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2014-01-04T01:04:14.340", "Score": "7", "CreationDate": "2014-01-04T00:31:29.990", "ParentId": "20915139", "CommentCount": "7", "OwnerUserId": "13005", "LastEditDate": "2014-01-04T01:04:14.340"}});