post_cb({"37541022": {"ViewCount": "346", "Body": "<p>Why is adding names to the <code>std</code> namespace undefined behaviour?</p>\n<p>The obvious answer is \"because the standard says so,\" e.g. in C++14 [namespace.std] 17.6.4.2.1/1:</p>\n<blockquote>\n<p id=\"so_37541022_37541022_0\">The behavior of a C++ program is undefined if it adds declarations or definitions to namespace <code>std</code> or to a\n  namespace within namespace <code>std</code> unless otherwise specified. ...</p>\n</blockquote>\n<p>However, I would be really interested in the reasons for this ruling. I can of course understand adding overloads of names already in <code>std</code> could break behaviour; but why is adding new, unrelated names a problem?</p>\n<p>Programs can already wreak havoc inside <code>std</code> with macros, which is why pretty much all standard library implementations have to consist solely of reserved names (double-underscore and starting-underscore-followed-by-capital) for all non-public parts.</p>\n<p>I would really be interested in a situation in which something like this can be problematic:</p>\n<pre><code>namespace std\n{\n  int foo(int i)\n  { return i * 42; }\n}\n\n#include &lt;algorithm&gt;  // or one or more other standard library headers\n</code></pre>\n<p>when this is perfectly legal and the standard library has to cope:</p>\n<pre><code>#define foo %%\n\n#include &lt;algorithm&gt;  // or one or more other standard library headers\n</code></pre>\n<p>What is the rationale for this Undefined Behaviour?</p>\n", "AcceptedAnswerId": "37541691", "Title": "What are the reasons that extending the std namespace is considered undefined behavior?", "CreationDate": "2016-05-31T08:49:46.970", "Id": "37541022", "CommentCount": "9", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-05-31T09:11:57.530", "LastEditorUserId": "366904", "LastActivityDate": "2016-05-31T09:20:53.203", "Score": "15", "OwnerUserId": "1782465", "Tags": "<c++><undefined-behavior><c++-standard-library>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_37541022_37541022_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6299}}, "n3337": {"so_37541022_37541022_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6056}}, "n4659": {"so_37541022_37541022_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7808}}}, "37541691": {"Id": "37541691", "PostTypeId": "2", "Body": "<p>Here are a few reasons:</p>\n<ol>\n<li>Even if names in <em>headers</em> have to be uglified to avoid interactions with macros, this requirement does not exist for name in the source files actually implementing the code. If an implementation does use <code>::std::foo(int)</code> as part of its implementation it would be a violation of the one definition rule.</li>\n<li>The standard is expected to grow. If names could be added to namespace <code>std</code> any name added to the standard C++ library would be a likely breaking change. To some extend this is already true in the sense that any such name could be a macro but it is considered acceptable to break those.</li>\n<li>There is actually no need to add namespace to namespace <code>std</code>: they can be added to arbitrary other namespace, i.e., even if the motivations given above are not particular strong, the restriction isn't considered to be matter in any form. ... and if there <em>is</em> a reason to add a name to namespace <code>std</code> it clearly <em>does</em> affect the behavior.</li>\n</ol>\n", "LastActivityDate": "2016-05-31T09:20:53.203", "CommentCount": "4", "CreationDate": "2016-05-31T09:20:53.203", "ParentId": "37541022", "Score": "6", "OwnerUserId": "1120273"}});