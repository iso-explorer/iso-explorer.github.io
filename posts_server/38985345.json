post_cb({"38985404": {"ParentId": "38985345", "CommentCount": "11", "Body": "<p>Situation 2 causes undefined behaviour:</p>\n<pre><code>char* ptr = const_cast&lt;char*&gt;(x0.data() + 3);\n\n(*ptr) = 'Z';\n</code></pre>\n<p>According to the specification of <code>std::basic_string::data</code> (C++14 [string.accessors]/3):</p>\n<blockquote>\n<p id=\"so_38985345_38985404_0\"><em>Requires:</em> The program shall not alter any of the values stored in the character array.</p>\n</blockquote>\n<p>In other words, you are not allowed to cast away the <code>const</code> and modify the string via the pointers returned by <code>data()</code> or <code>c_str()</code> .</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "38985404", "Score": "15", "CreationDate": "2016-08-16T22:21:57.040", "LastActivityDate": "2016-08-16T22:21:57.040"}, "bq_ids": {"n4140": {"so_38985345_38985404_0": {"section_id": 1763, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_38985345_38985404_0": {"section_id": 1757, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_38985345_38985404_0": {"section_id": 1929, "quality": 0.7142857142857143, "length": 5}}}, "38985345": {"CommentCount": "9", "CreationDate": "2016-08-16T22:16:27.133", "PostTypeId": "1", "AcceptedAnswerId": "38985404", "LastEditorUserId": "6681430", "LastActivityDate": "2016-08-16T22:33:28.433", "LastEditDate": "2016-08-16T22:33:28.433", "ViewCount": "199", "FavoriteCount": "2", "Title": "Unexplained discrepancies when copying and modifying std::strings", "Id": "38985345", "Score": "8", "Body": "<p>In the following code, <em>\"situation 1\"</em>  works as expected on all\ncompilers tested, however <em>\"situation 2\"</em> it seems to behave differently\nbased on the compiler used.</p>\n<p>As an example MSVC has sit1 and sit2 produce the same results, however\nwhen using gcc/clang and libstdc++, the modification occurs to the\noriginal string and it's copy <em>(sort of like a COW string)</em> even though\nI'm building using the C++11 switch.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nint main() {\n\n   // situation 1\n   {\n      std::string x0 = \"12345678\";\n      std::string x1 = x0;\n\n      char* ptr = &amp;x0[0] + 3;\n\n      (*ptr) = ' ';\n\n      std::cout &lt;&lt; \"1. x0: \" &lt;&lt; x0 &lt;&lt; \"\\n\";\n      std::cout &lt;&lt; \"1. x1: \" &lt;&lt; x1 &lt;&lt; \"\\n\";\n\n      if ((&amp;x0[0]) == x0.data()) std::cout &lt;&lt; \"1. ptrs are equal\\n\";\n\n   }\n\n   // situation 2\n   {\n      std::string x0 = \"12345678\";\n      std::string x1 = x0;\n\n      char* ptr = const_cast&lt;char*&gt;(x0.data() + 3);\n\n      (*ptr) = ' ';\n\n      std::cout &lt;&lt; \"2. x0: \" &lt;&lt; x0 &lt;&lt; \"\\n\";\n      std::cout &lt;&lt; \"2. x1: \" &lt;&lt; x1 &lt;&lt; \"\\n\";\n\n      if ((&amp;x0[0]) == x0.data()) std::cout &lt;&lt; \"2. ptrs are equal\\n\";\n   }\n\n   return 0;\n}\n</code></pre>\n<p>GCC (6.1)</p>\n<pre><code>1. x0: 123 5678\n1. x1: 12345678\n1. ptrs are equal\n2. x0: 123 5678\n2. x1: 123 5678\n2. ptrs are equal\n</code></pre>\n<p>MSVC (2015)</p>\n<pre><code>1. x0: 123 5678\n1. x1: 12345678\n1. ptrs are equal\n2. x0: 123 5678\n2. x1: 12345678\n2. ptrs are equal\n</code></pre>\n<p>Is there any reason for the discrepancies in behavior between the various compilers - given that &amp;x0[0] and .data() return the same address?</p>\n", "Tags": "<c++><string><c++11><copy-constructor>", "OwnerUserId": "6681430", "AnswerCount": "1"}});