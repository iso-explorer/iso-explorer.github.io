post_cb({"bq_ids": {"n4140": {"so_49038246_49038246_4": {"length": 7, "quality": 1.0, "section_id": 6290}, "so_49038246_49038246_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 7189}, "so_49038246_49039064_0": {"length": 7, "quality": 1.0, "section_id": 6857}, "so_49038246_49038246_0": {"length": 12, "quality": 0.5217391304347826, "section_id": 6812}, "so_49038246_49038246_1": {"length": 21, "quality": 0.875, "section_id": 7189}, "so_49038246_49038246_2": {"length": 6, "quality": 1.0, "section_id": 7189}, "so_49038246_49039064_2": {"length": 4, "quality": 0.8, "section_id": 6859}}, "n3337": {"so_49038246_49038246_4": {"length": 7, "quality": 1.0, "section_id": 6050}, "so_49038246_49038246_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 6933}, "so_49038246_49038246_1": {"length": 21, "quality": 0.875, "section_id": 6933}, "so_49038246_49038246_0": {"length": 12, "quality": 0.5217391304347826, "section_id": 6567}, "so_49038246_49039064_2": {"length": 4, "quality": 0.8, "section_id": 6605}, "so_49038246_49039064_0": {"length": 7, "quality": 1.0, "section_id": 6603}, "so_49038246_49038246_2": {"length": 6, "quality": 1.0, "section_id": 6933}}, "n4659": {"so_49038246_49038246_4": {"length": 7, "quality": 1.0, "section_id": 7797}, "so_49038246_49038246_3": {"length": 6, "quality": 1.0, "section_id": 8697}, "so_49038246_49038246_1": {"length": 21, "quality": 0.875, "section_id": 8697}, "so_49038246_49038246_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 8304}, "so_49038246_49039064_2": {"length": 4, "quality": 0.8, "section_id": 8351}, "so_49038246_49039064_0": {"length": 7, "quality": 1.0, "section_id": 8349}, "so_49038246_49038246_2": {"length": 6, "quality": 1.0, "section_id": 8697}}}, "49038246": {"ViewCount": "130", "Body": "<p>During a dive into dynamic memory, it occurred to me it appears contradictory how trivial types begin their lifetime. Consider the snippet</p>\n<pre><code>void* p = ::operator new(sizeof(int));  // 1\n// 2\nnew (p) int; // 3\n</code></pre>\n<p>When does the <code>int</code> start its lifetime?</p>\n<ol>\n<li><p>Only acquires storage, <code>::operator new</code> is specified to have the effect (from <a href=\"https://timsong-cpp.github.io/cppwp/support.dynamic#new.delete.single-1\" rel=\"nofollow noreferrer\">[new.delete.single]</a>)</p>\n<blockquote>\n<p id=\"so_49038246_49038246_0\">The allocation functions called by a new-expression to allocate size bytes of storage. [...] allocates storage suitably aligned to represent any object of that size provided the object's type does not have new-extended alignment.</p>\n</blockquote>\n<p>Given that acquiring storage <a href=\"https://stackoverflow.com/questions/40873520/reinterpret-cast-creating-a-trivially-default-constructible-object/40874245#40874245\">is insufficient</a> in creating an object, the <code>int</code> cannot have begin its lifetime here.</p></li>\n<li><p>At this point, suitbale storage for the <code>int</code> has been acquired.</p></li>\n<li><p>The <code>int</code> is created by placement new. But somehow its lifetime didn't begin here, since from <a href=\"https://timsong-cpp.github.io/cppwp/basic.life#1\" rel=\"nofollow noreferrer\">[basic.life]</a></p>\n<blockquote>\n<p id=\"so_49038246_49038246_1\">[...] An object is said to have non-vacuous initialization if it is of a class or aggregate type and it or one of its subobjects is initialized by a constructor other than a trivial default constructor. The lifetime of an object of type <code>T</code> begins when:</p>\n<ul>\n<li><p id=\"so_49038246_49038246_2\">storage with the proper alignment and size for type <code>T</code> is obtained, and</p></li>\n<li><p id=\"so_49038246_49038246_3\">if the object has non-vacuous initialization, its initialization is complete [...]</p></li>\n</ul>\n</blockquote>\n<p><code>int</code> is neither a class nor aggregate type, hence it has vacuous initialization. Therefore only the first bullet applies. However, this is clearly not when storage is obtained and therefore cannot be when its lifetime starts.</p></li>\n</ol>\n<h2>Some context</h2>\n<p>Allocators <a href=\"https://timsong-cpp.github.io/cppwp/allocator.requirements#tab:utilities.allocator.requirements\" rel=\"nofollow noreferrer\">are required</a> to return memory without constructing its elements. Yet this doesn't make sense with trivial types. The effects of <code>a.allocate(n)</code> with <code>a</code> an allocator object for type <code>T</code> is</p>\n<blockquote>\n<p id=\"so_49038246_49038246_4\">Memory is allocated for <code>n</code> objects of type <code>T</code> but objects are not constructed.</p>\n</blockquote>\n", "AcceptedAnswerId": "49039064", "Title": "At what point does the lifetime of a trivial type created by placement-new start?", "CreationDate": "2018-02-28T20:46:23.530", "LastActivityDate": "2018-02-28T22:39:46.833", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-02-28T22:39:46.833", "LastEditorUserId": "1505939", "Id": "49038246", "Score": "6", "OwnerUserId": "4832499", "Tags": "<c++><language-lawyer><placement-new><object-model>", "AnswerCount": "1"}, "49039064": {"Id": "49039064", "PostTypeId": "2", "Body": "<p>Technically, the <em>new-expression</em> always obtains storage. The code <code>new(p) int</code> both obtains storage and creates an object, and according to [basic.life]/1, the object's lifetime began when <code>new(p) int</code> obtained the storage.</p>\n<p>According to N4659 [expr.new], the code <code>new(p) int</code> generates a call to an allocation function <code>::operator new(sizeof(int), p)</code>.  And under [new.delete.placement], the standard library defines such a function:</p>\n<blockquote>\n<p id=\"so_49038246_49039064_0\"><code>void* operator new(std::size_t size, void* ptr) noexcept;</code></p>\n<p id=\"so_49038246_49039064_1\"><em>Returns:</em> ptr.</p>\n<p id=\"so_49038246_49039064_2\"><em>Remarks:</em> Intentionally performs no other action.</p>\n</blockquote>\n<p>Although \"no other action\" is performed, and probably the implementation will optimize out any actual function call, this call to an allocation function still counts as obtaining storage for the object being created by the <em>new-expression</em>.</p>\n", "LastEditorUserId": "1505939", "LastActivityDate": "2018-02-28T22:24:39.080", "Score": "7", "CreationDate": "2018-02-28T21:41:55.307", "ParentId": "49038246", "CommentCount": "2", "OwnerUserId": "1505939", "LastEditDate": "2018-02-28T22:24:39.080"}});