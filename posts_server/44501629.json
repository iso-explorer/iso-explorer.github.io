post_cb({"44501697": {"Id": "44501697", "PostTypeId": "2", "Body": "<p>You can return a default constructed shared_ptr instead.</p>\n<pre><code>auto GetSharedPtrClassB(Tag* tag) {\n    if (tag) {\n        auto&amp; sharedB = *(tag-&gt;b);\n        return sharedB.a;\n    } else {\n        return std::shared_ptr&lt;A&gt;{};\n    }\n}\n</code></pre>\n", "Score": "4", "LastActivityDate": "2017-06-12T14:18:22.727", "CreationDate": "2017-06-12T14:18:22.727", "ParentId": "44501629", "CommentCount": "3", "OwnerUserId": "817643"}, "44501766": {"Id": "44501766", "PostTypeId": "2", "LastEditDate": "2017-06-28T06:45:40.980", "CommentCount": "6", "LastEditorUserId": "2666289", "LastActivityDate": "2017-06-28T06:45:40.980", "CreationDate": "2017-06-12T14:21:00.640", "ParentId": "44501629", "Score": "8", "Body": "<p>Use a conditional operator to force the conversion from <code>nullptr</code> to \"whatever\":</p>\n<pre><code>auto GetSharedPtrClassB(Tag* tag) {\n    return tag ? tag-&gt;b-&gt;a : nullptr;\n}\n</code></pre>\n<hr>\n<p>Conversion from one operand to the other in a conditional operator is well-defined (see <em>[expr.cond]</em>), here the <code>nullptr</code> gets converted to an object of type <code>decltype(tag-&gt;b-&gt;a)</code>.</p>\n<p>On the other hand, the rules for return type deduction when using <code>auto</code> without a trailing return type are very strict - the deduced type must be the same for each <code>return</code> statement (<em>[dcl.spec.auto/9]</em>):</p>\n<blockquote>\n<p id=\"so_44501629_44501766_0\">If a function with a declared return type that contains a placeholder type has multiple return statements,\n  the return type is deduced for each return statement. If the type deduced is not the same in each deduction,\n  the program is ill-formed.</p>\n</blockquote>\n<hr>\n<p>If your function cannot be reduced to a conditional operator, you can use a trailing return type:</p>\n<pre><code>auto GetSharedPtrClassB(Tag* tag) -&gt; decltype(tag-&gt;b-&gt;a) {\n    if (tag) {\n        auto&amp; sharedB = *(tag-&gt;b);\n        return sharedB.a;\n    } else {\n        return {};\n    }\n}\n</code></pre>\n</hr></hr>", "OwnerUserId": "2666289"}, "44501729": {"Id": "44501729", "PostTypeId": "2", "Body": "<p>You could use <code>static_cast</code> like this:</p>\n<pre><code>auto GetSharedPtrClassB(Tag* tag) {\n    if (tag) {\n        auto&amp; sharedB = *(tag-&gt;b);\n        return sharedB.a;\n    } else {\n        return static_cast&lt;std::shared_ptr&lt;A&gt; &gt;(nullptr);\n    }\n}\n</code></pre>\n", "Score": "1", "LastActivityDate": "2017-06-12T14:19:32.060", "CreationDate": "2017-06-12T14:19:32.060", "ParentId": "44501629", "CommentCount": "2", "OwnerUserId": "1798015"}, "44501876": {"Id": "44501876", "PostTypeId": "2", "Body": "<p>I will assume that your code is actually use in a generic context. If your code don't use templates don't use decltype, specify types directly.</p>\n<p>To deduce the return type, all return statements <em>must</em> evaluate to an expression of the same type. In your code, you have two return statements with two different types. One with <code>std::shared_ptr&lt;A&gt;</code>, and one with <code>std::nullptr_t</code>.</p>\n<p>There is two solution: use the same types in both return statements, or explicitly define a return type.</p>\n<p>Here's how to return the same type:</p>\n<pre><code>auto GetSharedPtrClassB(Tag* tag) {\n    if (tag) {\n        auto&amp; sharedB = *(tag-&gt;b);\n        return sharedB.a;\n    }\n\n    // empty constructor same as initializing with `nullptr`\n    return decltype(tag-&gt;b-&gt;a){};\n}\n</code></pre>\n<p>Or explicitly define a return type:</p>\n<pre><code>auto GetSharedPtrClassB(Tag* tag) -&gt; decltype(tag-&gt;b-&gt;a) {\n    if (tag) {\n        auto&amp; sharedB = *(tag-&gt;b);\n        return sharedB.a;\n    }\n\n    // empty constructor same as initializing with `nullptr`\n    return {};\n}\n</code></pre>\n<p>By the way, in you code <code>auto&amp; sharedB = *(tag-&gt;b); return sharedB.a;</code> could be reduced to <code>return tag-&gt;b-&gt;a;</code></p>\n", "Score": "2", "LastActivityDate": "2017-06-12T14:26:08.623", "CreationDate": "2017-06-12T14:26:08.623", "ParentId": "44501629", "CommentCount": "1", "OwnerUserId": "2104697"}, "bq_ids": {"n4140": {"so_44501629_44501766_0": {"length": 22, "quality": 1.0, "section_id": 5453}}, "n4659": {"so_44501629_44501766_0": {"length": 22, "quality": 1.0, "section_id": 6879}}}, "44501629": {"ViewCount": "132", "LastEditDate": "2017-06-12T14:29:20.943", "AcceptedAnswerId": "44501766", "Title": "How can I let compiler to deduce a type of nullptr?", "CreationDate": "2017-06-12T14:15:17.897", "LastActivityDate": "2017-06-28T06:45:40.980", "CommentCount": "3", "Body": "<p>I am learning c++.\nI would like to let compiler to deduce nullptr as shared_ptr.\nPlease read the following code,</p>\n<pre><code>struct A {};\n\nstruct B {\n    std::shared_ptr&lt;A&gt; a;\n};\n\nstruct Tag {\n    std::shared_ptr&lt;B&gt; b;\n};\n\nauto GetSharedPtrClassB(Tag* tag) {\n    if (tag) {\n        auto&amp; sharedB = *(tag-&gt;b);\n        return sharedB.a;\n    } else {\n        return nullptr;  // Error : compiler cannot deduce type of nullptr.\n    }\n}\n</code></pre>\n<p>In <code>GetSharedPtrClassB</code>, <code>nullptr</code> cannot be deduced as <code>std::shared_ptr&lt;A&gt;</code>.\nThe error messages are following,</p>\n<pre><code>error: inconsistent deduction for \u2018auto\u2019: \u2018std::shared_ptr&lt;A&gt;\u2019 and then \u2018std::nullptr_t\u2019\n</code></pre>\n<p>How can I let compiler deduce nullptr as <code>std::shared_ptr&lt;A&gt;</code>?\n I can provide a type <code>decltype(*(tag-&gt;b))</code>, but I cannot think of the next step to provide a type <code>std::shared_ptr&lt;A&gt;</code>.</p>\n<p>Thank you very much.</p>\n", "PostTypeId": "1", "LastEditorUserId": "2104697", "Id": "44501629", "Score": "3", "OwnerUserId": "5396302", "Tags": "<c++>", "AnswerCount": "4"}});