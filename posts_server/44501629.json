post_cb({"44501876": {"ParentId": "44501629", "CommentCount": "1", "CreationDate": "2017-06-12T14:26:08.623", "OwnerUserId": "2104697", "PostTypeId": "2", "Id": "44501876", "Score": "2", "Body": "<p>I will assume that your code is actually use in a generic context. If your code don't use templates don't use decltype, specify types directly.</p>\n<p>To deduce the return type, all return statements <em>must</em> evaluate to an expression of the same type. In your code, you have two return statements with two different types. One with <code>std::shared_ptr&lt;A&gt;</code>, and one with <code>std::nullptr_t</code>.</p>\n<p>There is two solution: use the same types in both return statements, or explicitly define a return type.</p>\n<p>Here's how to return the same type:</p>\n<pre><code>auto GetSharedPtrClassB(Tag* tag) {\n    if (tag) {\n        auto&amp; sharedB = *(tag-&gt;b);\n        return sharedB.a;\n    }\n\n    // empty constructor same as initializing with `nullptr`\n    return decltype(tag-&gt;b-&gt;a){};\n}\n</code></pre>\n<p>Or explicitly define a return type:</p>\n<pre><code>auto GetSharedPtrClassB(Tag* tag) -&gt; decltype(tag-&gt;b-&gt;a) {\n    if (tag) {\n        auto&amp; sharedB = *(tag-&gt;b);\n        return sharedB.a;\n    }\n\n    // empty constructor same as initializing with `nullptr`\n    return {};\n}\n</code></pre>\n<p>By the way, in you code <code>auto&amp; sharedB = *(tag-&gt;b); return sharedB.a;</code> could be reduced to <code>return tag-&gt;b-&gt;a;</code></p>\n", "LastActivityDate": "2017-06-12T14:26:08.623"}, "44501766": {"ParentId": "44501629", "LastEditDate": "2017-06-28T06:45:40.980", "CommentCount": "6", "CreationDate": "2017-06-12T14:21:00.640", "Score": "8", "LastEditorUserId": "2666289", "PostTypeId": "2", "Id": "44501766", "OwnerUserId": "2666289", "Body": "<p>Use a conditional operator to force the conversion from <code>nullptr</code> to \"whatever\":</p>\n<pre><code>auto GetSharedPtrClassB(Tag* tag) {\n    return tag ? tag-&gt;b-&gt;a : nullptr;\n}\n</code></pre>\n<hr>\n<p>Conversion from one operand to the other in a conditional operator is well-defined (see <em>[expr.cond]</em>), here the <code>nullptr</code> gets converted to an object of type <code>decltype(tag-&gt;b-&gt;a)</code>.</p>\n<p>On the other hand, the rules for return type deduction when using <code>auto</code> without a trailing return type are very strict - the deduced type must be the same for each <code>return</code> statement (<em>[dcl.spec.auto/9]</em>):</p>\n<blockquote>\n<p id=\"so_44501629_44501766_0\">If a function with a declared return type that contains a placeholder type has multiple return statements,\n  the return type is deduced for each return statement. If the type deduced is not the same in each deduction,\n  the program is ill-formed.</p>\n</blockquote>\n<hr>\n<p>If your function cannot be reduced to a conditional operator, you can use a trailing return type:</p>\n<pre><code>auto GetSharedPtrClassB(Tag* tag) -&gt; decltype(tag-&gt;b-&gt;a) {\n    if (tag) {\n        auto&amp; sharedB = *(tag-&gt;b);\n        return sharedB.a;\n    } else {\n        return {};\n    }\n}\n</code></pre>\n</hr></hr>", "LastActivityDate": "2017-06-28T06:45:40.980"}, "44501697": {"ParentId": "44501629", "CommentCount": "3", "CreationDate": "2017-06-12T14:18:22.727", "OwnerUserId": "817643", "PostTypeId": "2", "Id": "44501697", "Score": "4", "Body": "<p>You can return a default constructed shared_ptr instead.</p>\n<pre><code>auto GetSharedPtrClassB(Tag* tag) {\n    if (tag) {\n        auto&amp; sharedB = *(tag-&gt;b);\n        return sharedB.a;\n    } else {\n        return std::shared_ptr&lt;A&gt;{};\n    }\n}\n</code></pre>\n", "LastActivityDate": "2017-06-12T14:18:22.727"}, "44501729": {"ParentId": "44501629", "CommentCount": "2", "CreationDate": "2017-06-12T14:19:32.060", "OwnerUserId": "1798015", "PostTypeId": "2", "Id": "44501729", "Score": "1", "Body": "<p>You could use <code>static_cast</code> like this:</p>\n<pre><code>auto GetSharedPtrClassB(Tag* tag) {\n    if (tag) {\n        auto&amp; sharedB = *(tag-&gt;b);\n        return sharedB.a;\n    } else {\n        return static_cast&lt;std::shared_ptr&lt;A&gt; &gt;(nullptr);\n    }\n}\n</code></pre>\n", "LastActivityDate": "2017-06-12T14:19:32.060"}, "44501629": {"CommentCount": "3", "ViewCount": "132", "PostTypeId": "1", "LastEditorUserId": "2104697", "CreationDate": "2017-06-12T14:15:17.897", "LastActivityDate": "2017-06-28T06:45:40.980", "Title": "How can I let compiler to deduce a type of nullptr?", "AcceptedAnswerId": "44501766", "LastEditDate": "2017-06-12T14:29:20.943", "Id": "44501629", "Score": "3", "Body": "<p>I am learning c++.\nI would like to let compiler to deduce nullptr as shared_ptr.\nPlease read the following code,</p>\n<pre><code>struct A {};\n\nstruct B {\n    std::shared_ptr&lt;A&gt; a;\n};\n\nstruct Tag {\n    std::shared_ptr&lt;B&gt; b;\n};\n\nauto GetSharedPtrClassB(Tag* tag) {\n    if (tag) {\n        auto&amp; sharedB = *(tag-&gt;b);\n        return sharedB.a;\n    } else {\n        return nullptr;  // Error : compiler cannot deduce type of nullptr.\n    }\n}\n</code></pre>\n<p>In <code>GetSharedPtrClassB</code>, <code>nullptr</code> cannot be deduced as <code>std::shared_ptr&lt;A&gt;</code>.\nThe error messages are following,</p>\n<pre><code>error: inconsistent deduction for \u2018auto\u2019: \u2018std::shared_ptr&lt;A&gt;\u2019 and then \u2018std::nullptr_t\u2019\n</code></pre>\n<p>How can I let compiler deduce nullptr as <code>std::shared_ptr&lt;A&gt;</code>?\n I can provide a type <code>decltype(*(tag-&gt;b))</code>, but I cannot think of the next step to provide a type <code>std::shared_ptr&lt;A&gt;</code>.</p>\n<p>Thank you very much.</p>\n", "Tags": "<c++>", "OwnerUserId": "5396302", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_44501629_44501766_0": {"section_id": 5453, "quality": 1.0, "length": 22}}, "n4659": {"so_44501629_44501766_0": {"section_id": 6879, "quality": 1.0, "length": 22}}}});