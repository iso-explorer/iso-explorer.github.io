post_cb({"bq_ids": {"n4140": {"so_23754223_23755126_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 710}, "so_23754223_23755126_5": {"length": 10, "quality": 0.8333333333333334, "section_id": 710}, "so_23754223_23755126_6": {"length": 17, "quality": 0.9444444444444444, "section_id": 710}, "so_23754223_23755126_4": {"length": 18, "quality": 0.9, "section_id": 710}, "so_23754223_23755126_2": {"length": 10, "quality": 0.8333333333333334, "section_id": 710}, "so_23754223_23755126_1": {"length": 18, "quality": 0.9, "section_id": 710}}, "n3337": {"so_23754223_23755126_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 699}, "so_23754223_23755126_5": {"length": 10, "quality": 0.8333333333333334, "section_id": 699}, "so_23754223_23755126_6": {"length": 17, "quality": 0.9444444444444444, "section_id": 699}, "so_23754223_23755126_4": {"length": 18, "quality": 0.9, "section_id": 699}, "so_23754223_23755126_2": {"length": 10, "quality": 0.8333333333333334, "section_id": 699}, "so_23754223_23755126_1": {"length": 18, "quality": 0.9, "section_id": 699}}, "n4659": {"so_23754223_23755126_3": {"length": 13, "quality": 0.7222222222222222, "section_id": 739}, "so_23754223_23755126_4": {"length": 18, "quality": 0.9, "section_id": 739}, "so_23754223_23755126_1": {"length": 18, "quality": 0.9, "section_id": 739}, "so_23754223_23755126_6": {"length": 13, "quality": 0.7222222222222222, "section_id": 739}}}, "23755126": {"Id": "23755126", "PostTypeId": "2", "Body": "<p>It may sound odd at first, but not explicitly stating that <code>swap</code> of standard container  is <code>noexcept</code> is intentional; and it all boils down to <em>undefined behavior</em> (UB).</p>\n<hr>\n<blockquote>\n<p id=\"so_23754223_23755126_0\"><code>23.2.1p9</code> <strong>General Container Requirements</strong> <code>[container.requirements.general]</code></p>\n<blockquote>\n<p id=\"so_23754223_23755126_4\">The expression <code>a.swap(b)</code>, for containers <code>a</code> and <code>b</code> of a standard\n    container type other than <code>array</code>, shall exchange the values of <code>a</code>\n    and <code>b</code>without invoking any move, copy, or swap operations on the\n    individual container elements.</p>\n<p id=\"so_23754223_23755126_5\">Any <code>Compare</code>, <code>Pred</code>, or <code>Hash</code> objects beloning to <code>a</code> and <code>b</code> shall\n    be swappable and shall be exchanged by unqualified calls to non-member\n    <code>swap</code>.</p>\n<p id=\"so_23754223_23755126_6\">If\n    <code>allocator_traits&lt;allocator_type&gt;::propagate_on_container_swap::value</code>\n    is <code>true</code>, then the allocators of <code>a</code> and <code>b</code> shall also be exchanged\n    using an unqalified call to non-member <code>swap</code>. <em>Otherwise, they shall\n    not be swapped, and the behavior is undefined</em> unless `a.get_allocator\n    () == b.get_allocator ().</p>\n</blockquote>\n</blockquote>\n<p><sup><strong>Note</strong>: <em>italics</em> added by me.</sup></p>\n<hr>\n<p><strong>Why is the previous section relevant to my question?</strong></p>\n<p>Since the <code>swap</code> of standard containers has a precondition (most importantly the last paragraph of the previously quoted section of the Standard), that may lead to <em>UB</em> if not satisfied, the Standard doesn't want to impose \"impossible\" constraints on implementations.</p>\n<hr>\n<p>The Standard says the following about <em>undefined behaviour</em>:</p>\n<blockquote>\n<p id=\"so_23754223_23755126_7\"><code>1.3.24</code> <strong>undefined behavior</strong> <code>[defns.undefined]</code></p>\n<blockquote>\n<p id=\"so_23754223_23755126_9\">Behavior for which this International Standard imposes no requirements.</p>\n</blockquote>\n</blockquote>\n<hr>\n<p>Only criminals, and perhaps salesmen, would consider a <em>No</em> to be something other than a <em>No</em>, but when the Standard says <em>\"no requirements\"</em>  it really means <em>\"<strong>no</strong> requirements\"</em>; marking the relevant <code>swap</code> functions as <code>noexcept</code> would impose a requirement on implementations, where there should be none.</p>\n<hr>\n<p><strong>Why doesn't the Standard want to impose such requirements?</strong></p>\n<p>There's an interesting paper (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3248.pdf\" rel=\"noreferrer\">N3248</a>) on this matter by <em>Alisdair Meredith</em> and <em>John Lakos</em> titled \"<em><code>noexcept</code> prevents Library Validation</em>\".</p>\n<p>In short it talks about how <code>noexcept</code> will prevent library implementation to use <code>asserts</code> in library code (ie. implementations of the standard library), even during debug mode, and the implications of that.</p>\n<p>If C++ had a standardized <em>\"testing\" vs \"production\" mode</em> (as the paper calls it), where <code>noexcept</code> would conditionally apply, this would be far less problematic.. but as it currently stands; C++ has no \"modes\".</p>\n</hr></hr></hr></hr></hr>", "LastActivityDate": "2014-05-20T08:52:55.763", "Score": "5", "CreationDate": "2014-05-20T08:52:55.763", "ParentId": "23754223", "CommentCount": "4", "OwnerUserId": "1090079"}, "23754223": {"ViewCount": "386", "Body": "<p>As of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\">N3797</a> the C++ standard requires <code>swap</code> functions of containers to not throw any exceptions unless specified otherwise <code>[container.requirements.general]</code> (<em>23.2.1\u00a710</em>). </p>\n<ul>\n<li>Why are the <code>swap</code> member functions that are specified to not throw not declared <code>noexcept</code>?</li>\n</ul>\n<p><sub>The same question applies to the specialized non-member <code>swap</code> overloads. </sub></p>\n", "AcceptedAnswerId": "23756081", "Title": "Why are the swap member functions in STL containers not declared noexcept?", "CreationDate": "2014-05-20T08:06:25.860", "Id": "23754223", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-05-20T09:46:11.073", "LastEditorUserId": "46642", "LastActivityDate": "2014-05-20T09:46:11.073", "Score": "12", "OwnerUserId": "1335865", "Tags": "<c++><c++11><swap><noexcept>", "AnswerCount": "2"}, "23756081": {"Id": "23756081", "PostTypeId": "2", "Body": "<p>Further to <a href=\"https://stackoverflow.com/questions/23754223/why-are-the-swap-member-functions-in-stl-containers-not-declared-noexcept/23755126#23755126\">what refp said</a>, here's a post from Daniel Kr\u00fcgler on the <code>std-discussion</code> mailing list:</p>\n<blockquote>\n<p id=\"so_23754223_23756081_0\">The internal policy to declare a function as unconditional noexcept is \n  explained in </p>\n<p id=\"so_23754223_23756081_1\"><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3279.pdf\" rel=\"nofollow noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3279.pdf</a> </p>\n<p id=\"so_23754223_23756081_2\">With the terminology used in that paper, std::vector's swap function \n  has a narrowing contract, that is it has preconditions in regard to \n  the allocators of the participating objects. This means, there exists \n  the possibility that callers may violate the preconditions and an \n  implementation should be allowed to signal this my different means \n  than by termination. Therefore such functions should not be noexcept, \n  but it should have an effective element \"Throws: Nothing\" because this \n  applies to the situation when the preconditions are satisfied.</p>\n</blockquote>\n<p>(<a href=\"https://groups.google.com/a/isocpp.org/forum/#!msg/std-discussion/8iksPomni-M/Xk6B2D07tvgJ\" rel=\"nofollow noreferrer\">link</a>)</p>\n<p>Said internal policy is the canonical, official answer to your question.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-05-20T09:35:42.793", "Score": "10", "CreationDate": "2014-05-20T09:35:42.793", "ParentId": "23754223", "CommentCount": "2", "LastEditDate": "2017-05-23T12:14:34.787", "OwnerUserId": "560648"}});