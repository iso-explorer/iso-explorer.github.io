post_cb({"bq_ids": {"n4140": {"so_5248877_5248877_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 6004}}, "n3337": {"so_5248877_5248877_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 5772}}, "n4659": {"so_5248877_5248877_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 7503}}}, "5250709": {"Id": "5250709", "PostTypeId": "2", "Body": "<p>Concerning p-&gt;a, where p is a null pointer, and a a static data member:\n\u00a79.4/2 says \"A static member may be referred to using the class member\naccess syntax, in which case the object-expression is evaluated.\"  (The\n\"object-expression\" is the expression to the left of the . or the -&gt;.)</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2011-08-20T15:23:39.210", "Score": "3", "CreationDate": "2011-03-09T18:53:16.023", "ParentId": "5248877", "CommentCount": "4", "LastEditDate": "2011-08-20T15:23:39.210", "OwnerUserId": "649665"}, "5248877": {"ViewCount": "789", "Body": "<p><strong>Setup</strong></p>\n<p>Given this user-defined type:</p>\n<pre><code>struct T\n{\n    static int x;\n    int y;\n\n    T() : y(38);\n};\n</code></pre>\n<p>and the requisite definition placed somewhere useful:</p>\n<pre><code>int T::x = 42;\n</code></pre>\n<p>the following is the canonical way to stream the <code>int</code>'s value to <em>stdout</em>:</p>\n<pre><code>std::cout &lt;&lt; T::x;\n</code></pre>\n<p><strong>Control</strong></p>\n<p>Meanwhile, the following is (of course) invalid due to an instance of <code>T</code> not existing:</p>\n<pre><code>T* ptr = NULL; // same if left uninitialised\nstd::cout &lt;&lt; ptr-&gt;y;\n</code></pre>\n<p><strong>Question</strong></p>\n<p>Now consider the horrid and evil and bad following code:</p>\n<pre><code>T* ptr = NULL;\nstd::cout &lt;&lt; ptr-&gt;x; // remember, x is static\n</code></pre>\n<p>Dereferencing <code>ptr</code> is invalid, as stated above. Even though no physical memory dereference takes place here, I <em>believe</em> that it still counts as one, making the above code UB. Or... does it?</p>\n<p>14882:2003 5.2.5/3 states explicitly that <code>a-&gt;b</code> is converted to <code>(*(a)).b</code>, and that:</p>\n<blockquote>\n<p id=\"so_5248877_5248877_0\">The postfix expression before the dot or arrow is evaluated;\n  This evaluation happens even if the result is unnecessary to determine the value of the entire postfix expression, for example if the id-expression denotes a static member.</p>\n</blockquote>\n<p>But it's not clear whether \"evaluation\" here involves an actual dereference. In fact neither 14882:2003 nor n3035 seem to explicitly say either way whether the pointer-expression has to evaluate to a pointer to a valid instance when dealing with static members.</p>\n<p>My question is, just how invalid is this? Is it really specifically prohibited by the standard (even though there's no physical dereference), or is it just a quirk of the language that we can probably get away with? And even if it is prohibited, to what extent might we expect GCC/MSVC/Clang to treat it safely anyway?</p>\n<p>My g++ 4.4 appeared to produce code that never attempts to push the [invalid] <code>this</code> pointer onto the stack, with optimisations turned off.</p>\n<p><strong>BTW</strong> If <code>T</code> were polymorphic then that would not affect this, as static members cannot be virtual.</p>\n", "AcceptedAnswerId": "5249294", "Title": "Accessing static member through invalid pointer: guaranteed to \"work\"?", "CreationDate": "2011-03-09T16:29:55.737", "Id": "5248877", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-12-28T00:11:11.780", "LastEditorUserId": "560648", "LastActivityDate": "2014-12-28T00:11:11.780", "ClosedDate": "2014-06-25T12:41:11.117", "Score": "8", "OwnerUserId": "560648", "Tags": "<c++>", "AnswerCount": "3"}, "5249294": {"Id": "5249294", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_5248877_5249294_0\">it's not clear whether \"evaluation\" here involves an actual dereference.</p>\n</blockquote>\n<p>I read \"evaluation\" here as \"the subexpression is evaluated.\"  That would mean that the unary <code>*</code> is evaluated and you perform indirection via a null pointer, yielding undefined behavior.</p>\n<p>This issue (accessing a static member via a null pointer) is discussed in another question, <a href=\"https://stackoverflow.com/questions/2474018/when-does-invoking-a-member-function-on-a-null-instance-result-in-undefined-behav\">When does invoking a member function on a null instance result in undefined behavior?</a>  While it discusses member functions specifically, I don't see any reason that data members are any different in this respect.  There is some good discussion of the issue there.</p>\n<p>There was a defect reported against the C++ Standard that asks \"Is call of static member function through null pointer undefined?\"  (see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#315\" rel=\"nofollow noreferrer\">CWG Defect 315</a>)  This defect is closed and its resolution states that it is valid to call a static member function via a null pointer:</p>\n<blockquote>\n<p id=\"so_5248877_5249294_1\"><code>p-&gt;f()</code> is rewritten as <code>(*p).f()</code> according to 5.2.5 [expr.ref]. <code>*p</code> is not an error when <code>p</code> is null unless the lvalue is converted to an rvalue</p>\n</blockquote>\n<p>However, this resolution is in fact wrong.  </p>\n<p>It presupposes the concept of an \"empty lvalue,\" which is part of the proposed resolution for another defect, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#232\" rel=\"nofollow noreferrer\">CWG defect 232</a>, which asks the more general question, \"Is indirection through a null pointer undefined behavior?\"  </p>\n<p>The resolution to that defect would make certain forms of indirection through a null pointer (like calling a static member function) valid.  However, that defect is still open and its resolution has not been adopted into the C++ Standard.  Until that defect is closed and its resolution is incorporated into the C++ Standard, indirection via a null pointer (or dereferencing a null pointer, if one prefers that term) always yields undefined behavior.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-03-09T17:04:47.217", "Score": "10", "CreationDate": "2011-03-09T16:57:58.373", "ParentId": "5248877", "CommentCount": "4", "LastEditDate": "2017-05-23T10:29:50.780", "OwnerUserId": "151292"}, "5248972": {"Id": "5248972", "PostTypeId": "2", "Body": "<p>Looking from computer side onto OOP it is yet another way to calculate where data resides in memory. When data is not static - it is calculated from instance pointer, when data is static it is always calculated as fixed pointer in data segment. Template adds nothing, since resolved at compile time.</p>\n<p>So it is rather popular technique to use NULL as start pointer (for example evaluate offset of filed in class for persisting purposes)</p>\n<p>So code above is correct for static data. </p>\n", "LastActivityDate": "2011-03-09T16:36:56.270", "Score": "0", "CreationDate": "2011-03-09T16:36:56.270", "ParentId": "5248877", "CommentCount": "7", "OwnerUserId": "149818"}});