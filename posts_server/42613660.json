post_cb({"bq_ids": {"n4140": {"so_42613660_42614857_0": {"length": 38, "quality": 0.95, "section_id": 626}}, "n3337": {"so_42613660_42614857_0": {"length": 38, "quality": 0.95, "section_id": 616}}, "n4659": {"so_42613660_42614857_0": {"length": 35, "quality": 0.875, "section_id": 652}}}, "42614028": {"Id": "42614028", "PostTypeId": "2", "Body": "<p>This is how <a href=\"http://en.cppreference.com/w/cpp/language/overload_resolution\" rel=\"nofollow noreferrer\">overload resolution</a> works in C++. Both versions of <code>print</code> are viable for overload resolution.</p>\n<ul>\n<li><code>print(const vector&lt;int&gt;&amp; v1)</code> is a viable function for overload resolution because input initializer list <code>{1,2,3,4,5}</code>  in the caller is implicitly convertible to a <code>std::vector&lt;int&gt;</code>.</li>\n<li><code>print(const initializer_list&lt;int&gt;&amp; il)</code> is a viable function for overload resolution cause the input type in the caller perfectly matches.</li>\n</ul>\n<p>When both overloads are into play <code>print(const initializer_list&lt;int&gt;&amp; il)</code> is chosen as the best viable function cause it's a perfect match and a perfect match has a higher priority in overload resolution than an implicit conversion.</p>\n", "LastActivityDate": "2017-03-05T21:07:52.997", "CommentCount": "0", "CreationDate": "2017-03-05T21:07:52.997", "ParentId": "42613660", "Score": "1", "OwnerUserId": "2352671"}, "42614857": {"Id": "42614857", "PostTypeId": "2", "Body": "<p>Overload resolution works by expressing the operations required to convert the argument to the parameter type as a <em>conversion sequence</em>, and then ranking the conversion sequences according to some rules.</p>\n<p>Since we are initializing references, [over.ics.ref]/2 applies:</p>\n<blockquote>\n<p id=\"so_42613660_42614857_0\">When a parameter of reference type is not bound directly to an argument expression, the conversion sequence is the one required to convert the argument expression to the underlying type of the reference according to 13.3.3.1. Conceptually, this conversion sequence corresponds to copy-initializing a temporary of the underlying type with the argument expression. Any difference in top-level cv-qualification is subsumed by the initialization itself and does not constitute a conversion.</p>\n</blockquote>\n<p>So this allows us to use the same conversion sequence rules as if the code were:</p>\n<pre><code>void o_print(initializer_list&lt;int&gt; ol);\nvoid o_print(vector&lt;int&gt; o1);\n</code></pre>\n<p>i.e. with non-const objects as parameters instead of const references.</p>\n<p>Now:</p>\n<ul>\n<li><p>According to [over.ics.list]/2, conversion of a braced list of <code>int</code> to <code>std::initializer_list&lt;int&gt;</code> is an <em>identity conversion</em>. (It wouldn't be if the list members needed promotion or conversion to int).</p></li>\n<li><p>According to [over.ics.list]/4, conversion of a braced list to non-aggregate class (<code>std::vector&lt;int&gt;</code> here) chooses a constructor of <code>std::vector</code> by overload resolution, and this sequence is defined as a <em>user-defined conversion sequence</em>. </p></li>\n</ul>\n<p>Finally we are ready to apply the ranking rules now. An identity conversion is ranked higher than a user-defined conversion sequence, so the <code>initializer_list&lt;int&gt;</code> version wins.</p>\n<p>NB. All references are to C++14.</p>\n", "LastActivityDate": "2017-03-05T22:29:37.397", "CommentCount": "0", "CreationDate": "2017-03-05T22:29:37.397", "ParentId": "42613660", "Score": "0", "OwnerUserId": "1505939"}, "42613660": {"ViewCount": "53", "Body": "<p>In the code below, with both versions of the print method present the first call resolves to the one with initializer_list. If I comment out the definition with initializer_list, the program seamlessly uses  the vector version. In the first case I was expecting the compiler to complain!</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid print(const vector&lt;int&gt;&amp; v1){\n        cout &lt;&lt; \"vector \\n\";\n}\nvoid print(const initializer_list&lt;int&gt;&amp; il) {\n         cout &lt;&lt; \"init list \\n\";\n}\n\nint main() {\n        print({1,2,3,4,5});\n        return 0;\n}\n</code></pre>\n", "Title": "How does the compiler decide between vector vs initializer_list?", "CreationDate": "2017-03-05T20:37:31.417", "LastActivityDate": "2017-03-05T22:29:37.397", "CommentCount": "1", "LastEditDate": "2017-03-05T21:09:01.440", "PostTypeId": "1", "LastEditorUserId": "2352671", "Id": "42613660", "Score": "1", "OwnerUserId": "3919652", "Tags": "<c++><c++11><vector><initialization>", "AnswerCount": "2"}});