post_cb({"15047883": {"ParentId": "15047809", "CommentCount": "0", "Body": "<p>If the vector is empty, then <a href=\"http://www.cplusplus.com/reference/vector/vector/resize/\" rel=\"nofollow\"><code>std::vector::resize(n)</code></a> expands the content of this vector by inserting <code>n</code> new elements at the end. <a href=\"http://www.cplusplus.com/reference/vector/vector/reserve/\" rel=\"nofollow\"><code>std::vector::reserve(n)</code></a> only reallocates the memory block that your vector uses for storing its elements so that it's big enough to hold <code>n</code> elements.</p>\n<p>Then when you call <code>prob.cols[i]</code>, you are trying to access the element at index <code>i</code>. In case you used <code>reserve</code> before, this results in accessing the memory where no element resides yet, which produces the <strong>undefined behavior</strong>.</p>\n<p>So just use <code>resize</code> in this case :)</p>\n", "OwnerUserId": "1168156", "PostTypeId": "2", "Id": "15047883", "Score": "0", "CreationDate": "2013-02-24T02:01:47.970", "LastActivityDate": "2013-02-24T02:01:47.970"}, "15047846": {"ParentId": "15047809", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Function <a href=\"http://en.cppreference.com/w/cpp/container/vector/reserve\" rel=\"nofollow\"><code>reserve()</code></a> simply allocates a contiguous region of memory big enough to hold the number of items you specify and moves the vector's old content into this new block, which makes sure no more reallocations for the vectors' storage will be done upon insertions as long as the specified capacity is not exceeded. This function is used to reduce the number of reallocations (which also invalidate iterators), but <em>does not insert any new items at the end of your vector</em>.</p>\n<p>From the C++11 Standard, Paragraph 23.3.6.3/1 about <code>reserve()</code>:</p>\n<blockquote>\n<p id=\"so_15047809_15047846_0\">A directive that informs a vector of a planned change in size, so that it can manage the storage\n  allocation accordingly. After <code>reserve()</code>, <code>capacity()</code> is greater or equal to the argument of reserve if reallocation happens; and equal to the previous value of <code>capacity()</code> otherwise. Reallocation happens at this point if and only if the current capacity is less than the argument of <code>reserve()</code>. If an exception is thrown other than by the move constructor of a non-<code>CopyInsertable</code> type, there are no effects.</p>\n</blockquote>\n<p>Notice that by doing <code>prob.cols[i].push_back(idx, value);</code> you are likely to get <strong>undefined behavior</strong>, since <code>i</code> is probably an out-of-bounds index.</p>\n<p>On the other hand, function <code>resize()</code> <em>does</em> insert items at the end of your vector, so that the final size of the vector will be the one you specified (this means it can even <em>erase</em> elements, if you specify a size smaller than the current one). If you specify no second argument to a call to <code>resize()</code>, the newly inserted items will be value-initialized. Otherwise, they will be copy-initialized from the value you provide.</p>\n<p>From the C++11 Standard, Paragraph 23.3.6.3/9 about <code>resize()</code>:</p>\n<blockquote>\n<p id=\"so_15047809_15047846_1\">If <code>sz &lt;= size()</code>, equivalent to <code>erase(begin() + sz, end())</code>;. If <code>size() &lt; sz</code>, appends\n  <code>sz - size()</code> value-initialized elements to the sequence.</p>\n</blockquote>\n<p>So to sum it up, the reason why accessing your vector after invoking <code>resize()</code> gives the expected result is that <strong>items are actually being added to the vector</strong>. On the other hand, since the call to <code>reserve()</code> does not add any item, subsequent <strong>accesses to non-existing elements will give you undefined behavior</strong>.</p>\n", "OwnerUserId": "1932150", "LastEditorDisplayName": "user283145", "LastEditDate": "2013-03-05T20:16:52.103", "Id": "15047846", "Score": "3", "CreationDate": "2013-02-24T01:54:53.117", "LastActivityDate": "2013-03-05T20:16:52.103"}, "bq_ids": {"n4140": {"so_15047809_15047846_0": {"section_id": 969, "quality": 1.0, "length": 44}, "so_15047809_15047846_1": {"section_id": 810, "quality": 0.7, "length": 7}}, "n3337": {"so_15047809_15047846_0": {"section_id": 958, "quality": 1.0, "length": 44}, "so_15047809_15047846_1": {"section_id": 801, "quality": 1.0, "length": 10}}, "n4659": {"so_15047809_15047846_0": {"section_id": 1031, "quality": 1.0, "length": 44}, "so_15047809_15047846_1": {"section_id": 868, "quality": 0.6, "length": 6}}}, "15047809": {"CommentCount": "1", "ViewCount": "318", "PostTypeId": "1", "LastEditorUserId": "548852", "CreationDate": "2013-02-24T01:49:12.603", "LastActivityDate": "2013-03-05T20:16:52.103", "Title": "Vector Resize vs Reserve for nested vectors", "AcceptedAnswerId": "15047846", "LastEditDate": "2013-02-24T02:04:03.813", "Id": "15047809", "Score": "1", "Body": "<p>I'm trying to use another project's code and they have structs of this form:</p>\n<pre><code>struct data{\n   std::vector&lt;sparse_array&gt; cols,rows;\n}\n\nstruct sparse_array {\n   std::vector&lt;unsigned int&gt; idxs;\n   std::vector&lt;double&gt; values;\n\n   void add(unsigned int idx, double value) {\n       idxs.push_back(idx);\n       values.push_back(value);\n   }\n}\n</code></pre>\n<p>For my code, I tried using the following lines:</p>\n<pre><code>data prob;\nprob.cols.reserve(num_cols);\nprob.rows.reserve(num_rows);\n\n// Some loop that calls\nprob.cols[i].add(idx, value);\nprob.rows[i].add(idx, value);\n</code></pre>\n<p>And when I output the values, <code>prob.rows[i].value[j]</code> to a file I get all zeros. But when I use <code>resize</code> instead of <code>reserve</code> I get the actual value that I read in. Can someone give me an explanation about this?</p>\n", "Tags": "<c++><vector><resize>", "OwnerUserId": "548852", "AnswerCount": "2"}});