post_cb({"45493953": {"ParentId": "45493829", "LastEditDate": "2017-08-03T20:32:21.053", "CommentCount": "3", "CreationDate": "2017-08-03T20:26:59.137", "Score": "11", "LastEditorUserId": "1896169", "PostTypeId": "2", "Id": "45493953", "OwnerUserId": "1896169", "Body": "<p>Argument Dependent Lookup doesn't work the same way <a href=\"http://en.cppreference.com/w/cpp/language/adl#Notes\" rel=\"noreferrer\">for function templates where an explicit template argument is given</a>.</p>\n<blockquote>\n<p id=\"so_45493829_45493953_0\">Although a function call can be resolved through ADL even if ordinary\n  lookup finds nothing, a function call to a function template with\n  explicitly-specified template arguments requires that there is a\n  declaration of the template found by ordinary lookup (otherwise, it is\n  a syntax error to encounter an unknown name followed by a less-than\n  character)</p>\n</blockquote>\n<p>Basically, there needs to be some way for the unqualified lookup to find a template function. Then, the ADL can kick in (because the name <code>get</code> is then known to be a template). Cppreference gives an example:</p>\n<blockquote id=\"so_45493829_45493953_1\">\n<pre><code>namespace N1 {\n  struct S {};\n  template&lt;int X&gt; void f(S);\n}\nnamespace N2 {\n  template&lt;class T&gt; void f(T t);\n}\nvoid g(N1::S s) {\n  f&lt;3&gt;(s);      // Syntax error (unqualified lookup finds no f)\n  N1::f&lt;3&gt;(s);  // OK, qualified lookup finds the template 'f'\n  N2::f&lt;3&gt;(s);  // Error: N2::f does not take a non-type parameter\n                //        N1::f is not looked up because ADL only works\n                //              with unqualified names\n  using N2::f;\n  f&lt;3&gt;(s); // OK: Unqualified lookup now finds N2::f\n           //     then ADL kicks in because this name is unqualified\n           //     and finds N1::f\n}\n</code></pre>\n</blockquote>\n<p>Structured bindings are a special case, with ADL enabled.</p>\n<blockquote>\n<p id=\"so_45493829_45493953_2\">In the following contexts ADL-only lookup (that is, lookup in\n  associated namespaces only) takes place:</p>\n<ul>\n<li>the lookup of non-member functions begin and end performed by the range-for loop if member lookup fails</li>\n<li>the dependent name lookup from the point of template instantiation.</li>\n<li><strong>the lookup of non-member function get performed by structured binding declaration for tuple-like types</strong></li>\n</ul>\n</blockquote>\n<p><sup>Emphasis added</sup></p>\n", "LastActivityDate": "2017-08-03T20:32:21.053"}, "45493829": {"CommentCount": "0", "ViewCount": "268", "PostTypeId": "1", "LastEditorUserId": "5501675", "CreationDate": "2017-08-03T20:19:02.533", "LastActivityDate": "2017-08-03T20:32:21.053", "Title": "Why ADL does not resolve to the correct function with std::get", "AcceptedAnswerId": "45493969", "LastEditDate": "2017-08-03T20:27:57.797", "Id": "45493829", "Score": "13", "Body": "<p>I am trying to code a template function that uses an ADL resolved <code>get</code> to fetch members of a struct/range (<code>tuple</code>-esque).</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n#include &lt;tuple&gt;\n\nint main() {\n    auto tup = std::make_tuple(1, 2);\n    std::cout &lt;&lt; get&lt;0&gt;(tup) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>I am doing this because of what the structured bindings proposal (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf</a>  \u00a711.5.3) says about how <code>get</code> is used to fetch elements from the struct.  It says that a non member <code>get</code> is used to fetch elements from within the struct.  </p>\n<p>I assumed that the code above would compile, because ADL would cause the <code>get</code> function to be looked for in the <code>std</code> namespace (because it's argument is of type <code>std::tuple&lt;int, int&gt;</code>, which is in <code>std</code>), where it would be found.  But, I get an error.  Can someone explain the right approach here and also why the code above does not work?  How can one force ADL to happen in this case?</p>\n", "Tags": "<c++><tuples><c++1z><structured-bindings>", "OwnerUserId": "5501675", "AnswerCount": "2"}, "45493969": {"ParentId": "45493829", "LastEditDate": "2017-08-03T20:29:05.967", "CommentCount": "4", "CreationDate": "2017-08-03T20:27:54.893", "Score": "12", "LastEditorUserId": "2069064", "PostTypeId": "2", "Id": "45493969", "OwnerUserId": "2069064", "Body": "<p>The problem ultimately is templates:</p>\n<pre><code>std::cout &lt;&lt; get&lt;0&gt;(tup) &lt;&lt; std::endl;\n//           ~~~~\n</code></pre>\n<p>At that point, the compiler doesn't know that this is a function that needs to be looked up using ADL yet - <code>get</code> is just a name. And since that name by itself doesn't find anything, this is going to be interpreted as an unknown name followed by less-than. To get this to work, you need some other function template <code>get</code> visible:</p>\n<pre><code>using std::get;\nstd::cout &lt;&lt; get&lt;0&gt;(tup) &lt;&lt; std::endl; // now, OK\n</code></pre>\n<p>Even if it does nothing:</p>\n<pre><code>template &lt;class T&gt; void get();\n\nint main() {\n    auto tup = std::make_tuple(1, 2); \n    std::cout &lt;&lt; get&lt;0&gt;(tup) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>The structured binding wording explicitly looks up <code>get</code> using argument-dependent lookup, so it avoids the need to have an already-visible function template named <code>get</code>, from [dcl.struct.bind]:</p>\n<blockquote>\n<p id=\"so_45493829_45493969_0\">The <em>unqualified-id</em> <code>get</code> is looked up in the scope of <code>E</code> by class member access lookup, and if that finds at least one declaration, the initializer is <code>e.get&lt;i&gt;()</code>. Otherwise, the initializer is <code>get&lt;i&gt;(e)</code>, where <code>get</code> is looked up in the associated namespaces. In either case, <code>get&lt;i&gt;</code> is interpreted as a <em>template-id</em>. [\u2009Note: Ordinary unqualified lookup is not performed. \u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>The note is the key. If we had performed unqualified lookup, we'd just fail. </p>\n", "LastActivityDate": "2017-08-03T20:29:05.967"}, "bq_ids": {"n4140": {"so_45493829_45493969_0": {"section_id": 3906, "quality": 0.5142857142857142, "length": 18}}, "n4659": {"so_45493829_45493969_0": {"section_id": 4040, "quality": 0.8857142857142857, "length": 31}}}});