post_cb({"33202446": {"ParentId": "33202400", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2015-10-18T19:47:59.827", "Score": "2", "LastEditorUserId": "908939", "LastEditDate": "2015-10-18T20:18:04.990", "Id": "33202446", "OwnerUserId": "908939", "Body": "<p><strong>1. Explaining your compiler error:</strong></p>\n<p>The reason you can't concatenate two string literals using the '+' operator,<br>\nis because string literals are simply arrays of characters, and you can't concatenate two arrays.  </br></p>\n<p>Arrays will be implicitly converted to the pointer of their first element.  </p>\n<p>Or as the standard describes it:   </p>\n<blockquote>\n<p id=\"so_33202400_33202446_0\"><strong>[conv.array]</strong><br>\n  An lvalue or rvalue of type \u201carray of N T\u201d or \u201carray of unknown bound\n  of T\u201d can be converted to a prvalue of type \u201cpointer to T\u201d. The result\n  is a pointer to the first element of the array.</br></p>\n</blockquote>\n<p>What you are really doing in the example above,<br>\nis trying to add two const char pointers together, and that is not possible.</br></p>\n<hr>\n<p><strong>2. Why the string literals aren't implicitly converted:</strong></p>\n<p>Since arrays and pointers are fundamental types, you can't provide an implicit conversation operator as you have done in your class example.  </p>\n<p>The main thing to keep in mind, is that <code>std::string</code> knows how to take in <code>char[]</code>, but <code>char[]</code> does not know how to become a <code>std::string</code>.  In your example, you've used <code>B</code>, as a replacement to <code>char[]</code>, but you've also given it the ability to convert itself to <code>A</code>.  </p>\n<hr>\n<p><strong>3. Alternatives:</strong></p>\n<p>You can concatenate string literals by leaving out the plus operator.  </p>\n<pre><code>\"stack\" \"overflow\"; //this will work as you indented\n</code></pre>\n<p>Optionally, you could make \"stack\" a std::string, and then use the std::string's overloaded '+' operator:  </p>\n<pre><code>std::string(\"stack\") + \"overflow\"; //this will work\n</code></pre>\n</hr></hr>", "LastActivityDate": "2015-10-18T20:18:04.990"}, "33202400": {"CommentCount": "9", "AcceptedAnswerId": "33203861", "PostTypeId": "1", "LastEditorUserId": "3002139", "CreationDate": "2015-10-18T19:43:46.957", "LastActivityDate": "2015-10-18T22:42:37.493", "LastEditDate": "2015-10-18T22:42:37.493", "ViewCount": "363", "FavoriteCount": "3", "Title": "Why does adding two string literals not use operator+(const string&, const string&)?", "Id": "33202400", "Score": "10", "Body": "<p>Edit: I have reformatted the post to be clearer. </p>\n<p>Why does this work:</p>\n<pre><code>struct A {};\n\nstruct B {\n    B(A){}\n};\n\nvoid operator+(const B&amp;, const B&amp;) {}\n\nint main()\n{\n    A a1, a2;\n    a1 + a2;\n}\n</code></pre>\n<p>and this does not?</p>\n<pre><code>struct B {\n    B(const char*){}\n};\n\nvoid operator+(const B&amp;, const B&amp;) {} //error: invalid operands of types 'const char [6]' and 'const char [6]' to binary 'operator+'|\n\nint main()\n{\n    \"Hello\" + \"world\";\n}\n</code></pre>\n<p>Essentially, in the first example <code>a1</code> and <code>a2</code> both convert to <code>B</code> objects through the implicit conversion and use the <code>operator+(const B&amp;, const B&amp;)</code> to add. </p>\n<p>Following from this example, I would have expected <code>\"Hello\"</code> and <code>\"world\"</code> to convert to <code>B</code> objects, again through the implicit constructor, and use <code>operator+(const B&amp;, const B&amp;)</code> to add to each other. Instead there is an error, which indicates the C-style strings do not attempt a user-defined conversion to <code>B</code> in order to add. Why is this? Is there a fundamental property that prevents this?</p>\n", "Tags": "<c++><string><literals><addition>", "OwnerUserId": "4338785", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_33202400_33203861_0": {"section_id": 583, "quality": 0.9428571428571428, "length": 33}, "so_33202400_33203861_2": {"section_id": 601, "quality": 0.8571428571428571, "length": 12}, "so_33202400_33203861_1": {"section_id": 600, "quality": 0.85, "length": 34}, "so_33202400_33203861_6": {"section_id": 6140, "quality": 0.625, "length": 5}, "so_33202400_33202446_0": {"section_id": 11, "quality": 0.8947368421052632, "length": 17}, "so_33202400_33203861_4": {"section_id": 582, "quality": 0.8666666666666667, "length": 13}, "so_33202400_33203861_3": {"section_id": 602, "quality": 0.7647058823529411, "length": 13}, "so_33202400_33203861_5": {"section_id": 6138, "quality": 0.875, "length": 21}}, "n3337": {"so_33202400_33203861_0": {"section_id": 573, "quality": 0.9428571428571428, "length": 33}, "so_33202400_33203861_2": {"section_id": 591, "quality": 0.8571428571428571, "length": 12}, "so_33202400_33203861_1": {"section_id": 590, "quality": 0.85, "length": 34}, "so_33202400_33203861_6": {"section_id": 5904, "quality": 0.625, "length": 5}, "so_33202400_33202446_0": {"section_id": 8, "quality": 0.8947368421052632, "length": 17}, "so_33202400_33203861_4": {"section_id": 572, "quality": 0.8666666666666667, "length": 13}, "so_33202400_33203861_3": {"section_id": 592, "quality": 0.7647058823529411, "length": 13}, "so_33202400_33203861_5": {"section_id": 5902, "quality": 0.875, "length": 21}}, "n4659": {"so_33202400_33203861_0": {"section_id": 606, "quality": 0.9428571428571428, "length": 33}, "so_33202400_33203861_2": {"section_id": 627, "quality": 0.8571428571428571, "length": 12}, "so_33202400_33203861_1": {"section_id": 626, "quality": 0.85, "length": 34}, "so_33202400_33203861_6": {"section_id": 7637, "quality": 0.625, "length": 5}, "so_33202400_33202446_0": {"section_id": 12, "quality": 0.8947368421052632, "length": 17}, "so_33202400_33203861_4": {"section_id": 605, "quality": 0.8666666666666667, "length": 13}, "so_33202400_33203861_3": {"section_id": 628, "quality": 0.7647058823529411, "length": 13}, "so_33202400_33203861_5": {"section_id": 7635, "quality": 0.875, "length": 21}}}, "33203861": {"ParentId": "33202400", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-10-18T22:15:27.060", "Score": "5", "LastEditorUserId": "560648", "LastEditDate": "2015-10-18T22:21:01.097", "Id": "33203861", "OwnerUserId": "560648", "Body": "<p>In your first example, overload resolution is allowed to find your <code>operator+</code>:</p>\n<blockquote>\n<p id=\"so_33202400_33203861_0\"><code>[C++14: 13.3.1.2/2]:</code> <strong>If either operand has a type that is a class or an enumeration, a user-defined operator function might be declared that implements this operator</strong> or a user-defined conversion can be necessary to convert the operand to a type that is appropriate for a built-in operator. <strong>In this case, overload resolution is used to determine which operator function or built-in operator is to be invoked to implement the operator.</strong> <em>[..]</em></p>\n<p id=\"so_33202400_33203861_1\"><code>[C++14: 13.3.2/1]:</code> <strong>From the set of candidate functions constructed for a given context (13.3.1), a set of viable functions is chosen</strong>, from which the best function will be selected by comparing argument conversion sequences for the best fit (13.3.3). The selection of viable functions considers relationships between arguments and function parameters other than the ranking of conversion sequences.</p>\n<p id=\"so_33202400_33203861_2\"><code>[C++14: 13.3.2/2]:</code> First, <strong>to be a viable function, a candidate function shall have enough parameters to agree in number with the arguments in the list</strong>.</p>\n<ul>\n<li>If there are <code>m</code> arguments in the list, all candidate functions having exactly <code>m</code> parameters are viable.</li>\n<li><em>[..]</em></li>\n</ul>\n<p id=\"so_33202400_33203861_3\"><code>[C++14: 13.3.2/3]</code>: Second, for <code>F</code> to be a viable function, <strong>there shall exist for each argument an <em>implicit conversion sequence</em> (13.3.3.1) that converts that argument to the corresponding parameter of <code>F</code>.</strong> <em>[..]</em></p>\n</blockquote>\n<p><em>(You may examine the wording for \"implicit conversion sequence\" yourself to see that the <code>operator+</code> call is permissible; the rules are too verbose to warrant verbatim reproduction here.)</em></p>\n<p>However, in your second example, overload resolution is constrained to a basic arithmetic addition mechanism (one which is not defined for <code>const char[N]</code> or <code>const char*</code>), effectively prohibiting any <code>operator+</code> function from being considered:</p>\n<blockquote>\n<p id=\"so_33202400_33203861_4\"><code>[C++14: 13.3.1.2/1]:</code> <strong>If no operand of an operator in an expression has a type that is a class or an enumeration, the operator is assumed to be a built-in operator and interpreted according to Clause 5.</strong></p>\n<p id=\"so_33202400_33203861_5\"><code>[C++14: 5.7/1]:</code> <em>[..]</em> <strong>For addition, either both operands shall have arithmetic or unscoped enumeration type</strong>, or one operand shall be a pointer to a completely-defined object type and the other shall have integral or unscoped enumeration type. <em>[..]</em></p>\n<p id=\"so_33202400_33203861_6\"><code>[C++14: 5.7/3]:</code> The result of the binary + operator is the sum of the operands.</p>\n</blockquote>\n", "LastActivityDate": "2015-10-18T22:21:01.097"}});