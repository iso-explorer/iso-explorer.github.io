post_cb({"5610402": {"ParentId": "5610352", "PostTypeId": "2", "CommentCount": "0", "Body": "<pre><code>int* nums[nNums] = {0, 0, 0}, d[nNums];\n</code></pre>\n<p>As @Asha already said that <code>nums</code> is an array of 4 integer pointers each initialized to NULL.</p>\n<p>The interesting question which can be further asked here is : what is the type of the variable <code>d</code>?</p>\n<blockquote>\n<p id=\"so_5610352_5610402_0\">Is it an array of 4 integer pointers?</p>\n</blockquote>\n<p>Or</p>\n<blockquote>\n<p id=\"so_5610352_5610402_1\">Is it an array of 4 integers?</p>\n</blockquote>\n<p>So the answer is : its an array of 4 integers. The <code>*</code> is associated with only first declared symbol <code>nums</code>.  </p>\n<p>The equivalent declaration would be this:</p>\n<pre><code>int* nums[nNums] = {0, 0, 0};\nint d[nNums]; //not int* d[nNums];\n</code></pre>\n<p>To avoid such confusion, I prefer to write such declaration on multiple lines. If you want to declare in one line, the second declaration would be a bit better:</p>\n<pre><code>int*  nums[nNums] = {0, 0, 0}, d[nNums];  //old one!\nint  *nums[nNums] = {0, 0, 0}, d[nNums];  //new one. note the position of *\n</code></pre>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-04-10T08:00:55.860", "Id": "5610402", "Score": "1", "CreationDate": "2011-04-10T07:41:29.443", "LastActivityDate": "2011-04-10T08:00:55.860"}, "bq_ids": {"n4140": {"so_5610352_5610375_3": {"section_id": 3285, "quality": 1.0, "length": 4}, "so_5610352_5610375_1": {"section_id": 3304, "quality": 0.8571428571428571, "length": 12}, "so_5610352_5610375_2": {"section_id": 3287, "quality": 1.0, "length": 4}}, "n3337": {"so_5610352_5610375_3": {"section_id": 3155, "quality": 1.0, "length": 4}, "so_5610352_5610375_1": {"section_id": 3174, "quality": 0.8571428571428571, "length": 12}, "so_5610352_5610375_2": {"section_id": 3157, "quality": 1.0, "length": 4}}, "n4659": {"so_5610352_5610375_1": {"section_id": 4070, "quality": 0.7142857142857143, "length": 10}}}, "5610375": {"ParentId": "5610352", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>That code is equivalent to:</p>\n<pre><code>const int nNums= 4;\nint* nums[nNums] = {0, 0, 0};\nint d[nNums];\n</code></pre>\n<p>So, <code>nums</code> is an array of <code>int*</code>s of length 4, with all four elements initialized to null; <code>d</code> is an array of <code>int</code>s of length 4, with all four elements <strong>uninitialized</strong> (to reemphasize, <code>d</code> does <em>not</em> get initialized in any way).</p>\n<p>The syntax <code>= {0, 0, 0}</code> in this context is known as \"aggregate initialization\", and is described in \u00a78.5.1 of the C++03 standard; the relevant portion for this code (\u00a78.5.1/2) states:</p>\n<blockquote>\n<p id=\"so_5610352_5610375_0\">When an aggregate is initialized the <em>initializer</em> can contain an <em>initializer-clause</em> consisting of a brace-enclosed, comma-separated list of <em>initializer-clauses</em> for the members of the aggregate, written in increasing subscript or member order. If the aggregate contains subaggregates, this rule applies recursively to the members of the subaggregate.</p>\n</blockquote>\n<p>So, the first three elements of <code>nums</code> are explicitly initialized to <code>0</code>, and the fourth element is implicitly \"value-initialized\", as stated in \u00a78.5.1/7:</p>\n<blockquote>\n<p id=\"so_5610352_5610375_1\">If there are fewer <em>initializers</em> in the list than there are members in the aggregate, then each member not explicitly initialized shall be value-initialized.</p>\n</blockquote>\n<p>Value-initialization is described in \u00a78.5/5:</p>\n<blockquote>\n<p id=\"so_5610352_5610375_2\">To <em>value-initialize</em> an object of type <code>T</code> means:</p>\n<ul>\n<li>if <code>T</code> is a class type with a user-declared constructor, then the default constructor for <code>T</code> is called (and the initialization is ill-formed if <code>T</code> has no accessible default constructor);</li>\n<li>if <code>T</code> is a non-union class type without a user-declared constructor, then every non-static data member and base-class component of <code>T</code> is value-initialized;</li>\n<li>if <code>T</code> is an array type, then each element is value-initialized;</li>\n<li><strong>otherwise, the object is zero-initialized</strong></li>\n</ul>\n<p id=\"so_5610352_5610375_3\">To <em>zero-initialize</em> an object of type <code>T</code> means:</p>\n<ul>\n<li><strong>if <code>T</code> is a scalar type, the object is set to the value of <code>0</code> (zero) converted to <code>T</code>;</strong></li>\n<li>if <code>T</code> is a non-union class type, each nonstatic data member and each base-class subobject is zero-initialized;</li>\n<li>if <code>T</code> is a union type, the object\u2019s first named data member) is zero-initialized;</li>\n<li>if <code>T</code> is an array type, each element is zero-initialized;</li>\n<li>if <code>T</code> is a reference type, no initialization is performed.</li>\n</ul>\n</blockquote>\n<p>This results in the fourth element of <code>nums</code> also being initialized to null.</p>\n", "OwnerUserId": "636019", "LastEditorUserId": "636019", "LastEditDate": "2011-04-10T07:54:02.100", "Id": "5610375", "Score": "3", "CreationDate": "2011-04-10T07:35:38.600", "LastActivityDate": "2011-04-10T07:54:02.100"}, "5610365": {"ParentId": "5610352", "CommentCount": "3", "Body": "<p><code>int* nums[nNums] = {0, 0, 0}</code> defined a array of 4 integer pointers each initialized to NULL. However, note that <code>d</code> is an array of <em>integers</em> and <em>not</em> integer pointers and these values are not initialized.</p>\n", "OwnerUserId": "392315", "PostTypeId": "2", "Id": "5610365", "Score": "5", "CreationDate": "2011-04-10T07:33:01.020", "LastActivityDate": "2011-04-10T07:33:01.020"}, "5610520": {"ParentId": "5610352", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_5610352_5610520_0\">&gt; I understand that a pointer to nums is\n  being created,</p>\n</blockquote>\n<p>You understand incorrectly. There's no \"pointer to <code>nums</code>\" being created in that declaration. Declaration</p>\n<pre><code>int* nums[4] = {0, 0, 0};\n</code></pre>\n<p>declares an array of 4 pointers. <code>nums</code> itself is an array, not a pointer to anything.</p>\n<blockquote>\n<p id=\"so_5610352_5610520_1\">&gt; but what is the business on the right? </p>\n</blockquote>\n<p>The <code>= {0, 0, 0}</code> parts is called \"aggregate initializer\". It initializes the first tree elements of the <code>nums</code> array. It is not clear why only three are <em>explicitly</em> initialized (while the fourth one is left to be initialized to zero <em>implicitly</em>). Also, in C++ the same effect can be achieved by a </p>\n<pre><code>int* nums[4] = {};\n</code></pre>\n<p>declaration, where all four elements are initialized to zero <em>implicitly</em>.</p>\n<blockquote>\n<p id=\"so_5610352_5610520_2\">&gt; d[] gets initialized</p>\n</blockquote>\n<p>Huh? No. The declaration of <code>d</code> is equivalent to</p>\n<pre><code>int d[4];\n</code></pre>\n<p>meaning that <code>d</code> does not get initialized at all.</p>\n", "OwnerUserId": "187690", "PostTypeId": "2", "Id": "5610520", "Score": "0", "CreationDate": "2011-04-10T08:09:04.293", "LastActivityDate": "2011-04-10T08:09:04.293"}, "5610352": {"CommentCount": "0", "ViewCount": "193", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2011-04-10T07:30:05.513", "LastActivityDate": "2011-04-10T08:09:04.293", "Title": "Question about a funky array declaration", "LastEditDate": "2011-04-10T07:53:02.897", "Id": "5610352", "Score": "2", "Body": "<p>I just came across this array declaration:</p>\n<pre><code>const int nNums= 4;\nint* nums[nNums] = {0, 0, 0}, d[nNums];\n</code></pre>\n<p>I understand that a pointer to <code>nums</code> is being created, but what is the business on the right? <code>d[]</code> gets initialized, but I am not quite sure what the <code>{0,0,0}</code> does.</p>\n", "Tags": "<c++><initialization><aggregate>", "OwnerUserId": "688598", "AnswerCount": "4"}});