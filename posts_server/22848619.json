post_cb({"bq_ids": {"n4140": {"so_22848619_22848951_0": {"length": 23, "quality": 1.0, "section_id": 305}, "so_22848619_22848951_2": {"length": 21, "quality": 1.0, "section_id": 305}, "so_22848619_22848951_3": {"length": 28, "quality": 0.875, "section_id": 305}}, "n3337": {"so_22848619_22848951_0": {"length": 23, "quality": 1.0, "section_id": 296}, "so_22848619_22848951_2": {"length": 21, "quality": 1.0, "section_id": 296}, "so_22848619_22848951_3": {"length": 28, "quality": 0.875, "section_id": 296}}, "n4659": {"so_22848619_22848951_0": {"length": 23, "quality": 1.0, "section_id": 312}, "so_22848619_22848951_2": {"length": 21, "quality": 1.0, "section_id": 312}, "so_22848619_22848951_3": {"length": 17, "quality": 0.53125, "section_id": 296}}}, "22848619": {"ViewCount": "403", "Body": "<p>I am trying to understand the C++ language behaviour that I have observed (I understood the first half of it).</p>\n<p>My setup: 2 templated classes: <code>A</code> and <code>C</code>. <code>A</code> can be converted to <code>C</code> but not the other way around. They have some common behaviour, so I was searching to implement some logic only with <code>C</code> and rely on the conversion from <code>A</code> to <code>C</code> to make <code>A</code> behave the same way as <code>C</code>.<br>\n<sub>The examples uses an operator overloading, but the discussion I think is the same with a function or a method.</sub></br></p>\n<p>What I tried first was to use a conversion constructor:</p>\n<pre><code>template &lt;class T&gt;\nclass A {\n};\n\ntemplate &lt;class T&gt;\nclass C {\n  public:\n    C() = default;\n    C(const A&lt;T&gt;&amp;) {};\n};\n\ntemplate &lt;class T&gt;\nbool operator&lt;(const C&lt;T&gt; &amp;, const C&lt;T&gt; &amp;) {return true;}\n\nint main() {\n  A&lt;int&gt; a1, a2;\n  C&lt;int&gt; c1, c2;\n\n  c1 = a1; // OK, no-brainer\n\n  c1 &lt; c2; // OK, no-brainer\n  c1 &lt; a1; // template deduction failure\n  a1 &lt; c1; // template deduction failure\n  a1 &lt; a2; // template deduction failure\n}\n</code></pre>\n<p>This is actually the first half that I think I understood after searching SO and the net. From what I gathered the template argument must be matched exactly before a conversion can be tried and in this case it can't be deduced without taking into account possible conversions so deduction is not possible. This can be circumvented if the operator is made non-template friend in <code>C</code> (but I don't like it).</p>\n<p>The next thing I tried was to use inheritance:</p>\n<pre><code>template &lt;class T&gt;\nclass C {\n};\n\ntemplate &lt;class T&gt;\nclass A : public C&lt;T&gt; {\n};\n\ntemplate &lt;class T&gt;\nbool operator&lt;(const C&lt;T&gt; &amp;, const C&lt;T&gt; &amp;) {return true;}\n\nint main() {  \n  A&lt;int&gt; a1, a2;\n  C&lt;int&gt; c1, c2;\n\n  c1 = a1; // Ok, slicing\n\n  c1 &lt; c2; // Ok, no-brainer\n  c1 &lt; a1; // Ok, but why?\n  a1 &lt; c1; // Ok, but why?\n  a1 &lt; a2; // Ok, but why?\n}\n</code></pre>\n<p>For this I didn't find an explanation on the net (maybe I didn't know how to search).</p>\n<p>My question is why can the template be deduced when <code>A</code> is convertible to <code>C</code> because is the base class of <code>C</code> (second case) but cannot be deduced when <code>A</code> is just convertible to <code>C</code> (first case)?</p>\n<hr>\n<p><strong>Edit</strong></p>\n<p>As suggested by KerrekSB in the comments I have tried:</p>\n<pre><code>template &lt;class T&gt;\nbool operator&lt;(const C&lt;T&gt; &amp;, const typename std::common_type&lt;C&lt;T&gt;&gt;::type &amp;) {return true;}\n</code></pre>\n<p>with my first case (conversion, not inheritance)</p>\n<p>In this case:</p>\n<pre><code>c1 &lt; c2; // OK\nc1 &lt; a1; // OK, a1 is converted\na1 &lt; c1; // template deduction failure\na1 &lt; a2; // template deduction failure\n</code></pre>\n<p>Using his answer I think <code>c1 &lt; a1</code> works because the second argument is not part of the deduction process so implicit conversion is considered for the second argument.</p>\n<p>I also tried:</p>\n<pre><code>template &lt;class T&gt;\nbool operator&lt;(const typename std::common_type&lt;C&lt;T&gt;&gt;::type &amp;, const typename std::common_type&lt;C&lt;T&gt;&gt;::type &amp;) {return true;}\n</code></pre>\n<p>this doesn't work even with <code>c1 &lt; c2</code>. I think it's because now no parameter is involved in the deduction process.</p>\n<p>Am I right?</p>\n</hr>", "AcceptedAnswerId": "22848951", "Title": "Template deduction: why it works with inheritance (when it fails with conversion)?", "CreationDate": "2014-04-03T20:43:58.480", "Id": "22848619", "CommentCount": "4", "LastEditDate": "2014-04-03T21:35:02.140", "PostTypeId": "1", "LastEditorUserId": "2805305", "LastActivityDate": "2014-04-03T21:35:02.140", "Score": "0", "OwnerUserId": "2805305", "Tags": "<c++><inheritance><template-deduction>", "AnswerCount": "1"}, "22848951": {"Id": "22848951", "PostTypeId": "2", "Body": "<p>I think your situation is described by C++11, 14.8.2.1/4 [temp.deduct.call]:</p>\n<blockquote>\n<p id=\"so_22848619_22848951_0\">In general, the deduction process attempts to find template argument values that will make the deduced <code>A</code> identical to <code>A</code> (after the type <code>A</code> is transformed as described above). However, there are three cases that allow a difference:</p>\n<p id=\"so_22848619_22848951_1\">\u2014 ...</p>\n<p id=\"so_22848619_22848951_2\">\u2014 If <code>P</code> is a class and <code>P</code> has the form <em>simple-template-id</em>, then the transformed <code>A</code> can be a derived class of the deduced <code>A</code>. Likewise, if <code>P</code> is a pointer to a class of the form <em>simple-template-id</em>, the transformed <code>A</code> can be a pointer to a derived class pointed to by the deduced <code>A</code>.</p>\n<p id=\"so_22848619_22848951_3\">[<em>Note:</em> as specified in 14.8.1, implicit conversions will be performed on a function argument to convert it to the type of the corresponding function parameter if the parameter contains no template-parameters that participate in template argument deduction. Such conversions are also allowed, in addition to the ones described in the preceding list. \u2014 <em>end note</em>]</p>\n</blockquote>\n<p>The listed clause says that derived types are OK (note that <code>C&lt;T&gt;</code> is a <em>simple-template-id</em>, by 14.2/1), and the note explains that implicit conversions are only considered for types that aren't themselves part of the deduction process.</p>\n", "LastActivityDate": "2014-04-03T21:03:00.307", "CommentCount": "0", "CreationDate": "2014-04-03T21:03:00.307", "ParentId": "22848619", "Score": "4", "OwnerUserId": "596781"}});