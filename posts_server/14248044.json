post_cb({"bq_ids": {"n4140": {"so_14248044_14248134_2": {"length": 14, "quality": 0.875, "section_id": 5917}, "so_14248044_14248134_1": {"length": 51, "quality": 0.864406779661017, "section_id": 5917}, "so_14248044_14248044_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 5845}}, "n3337": {"so_14248044_14248134_1": {"length": 52, "quality": 0.8813559322033898, "section_id": 5689}, "so_14248044_14248044_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 5615}, "so_14248044_14248134_2": {"length": 14, "quality": 0.875, "section_id": 5689}}, "n4659": {"so_14248044_14248134_1": {"length": 49, "quality": 0.8305084745762712, "section_id": 7410}, "so_14248044_14248044_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 7324}, "so_14248044_14248134_2": {"length": 14, "quality": 0.875, "section_id": 7410}}}, "14248044": {"ViewCount": "17614", "Body": "<p>MSDN <a href=\"http://msdn.microsoft.com/en-us/library/z2cx9y4f.aspx\" rel=\"nofollow noreferrer\">reckons</a> that anonymous structs are non-standard in C++:</p>\n<blockquote>\n<p id=\"so_14248044_14248044_0\">A Microsoft C extension allows you to declare a structure variable\n  within another structure without giving it a name. These nested\n  structures are called anonymous structures. C++ does not allow\n  anonymous structures.</p>\n<p id=\"so_14248044_14248044_1\">You can access the members of an anonymous structure as if they were\n  members in the containing structure.</p>\n</blockquote>\n<p><a href=\"https://stackoverflow.com/questions/14187647/c-private-modifier-ignored-on-nested-anonymous-struct#comment19665939_14187647\"><em>@K-ballo</em> agrees</a>.</p>\n<p>I'm told that this feature isn't necessarily the same as just creating an unnamed struct but I can't see a distinction in terms of standard wording.</p>\n<p>C++11 says:</p>\n<blockquote>\n<p id=\"so_14248044_14248044_2\"><code>[C++11: 9/1]</code>: <em>[..]</em> A <em>class-specifier</em> whose <em>class-head</em> omits the <em>class-head-name</em> defines an unnamed class.</p>\n</blockquote>\n<p>and provides an entire grammatical construction for a type definition missing a name.</p>\n<p>C++03 lacks this explicit wording, but similarly indicates that the <code>identifier</code> in a type definition is optional, and makes reference to \"unnamed classes\" in <code>9.4.2/5</code> and <code>3.5/4</code>.</p>\n<ul>\n<li>So is MSDN wrong, and these things are all completely standard?</li>\n<li>Or is there some subtlety I'm missing between \"unnamed structs/classes\" and the same when used as members that prevents them from being covered by this C++03/C++11 functionality?</li>\n<li>Am I missing some fundamental difference between \"unnamed struct\" and \"anonymous struct\"? They look like synonyms to me.</li>\n</ul>\n", "AcceptedAnswerId": "14248127", "Title": "Are \"anonymous structs\" standard? And, really, what *are* they?", "CreationDate": "2013-01-09T23:01:49.573", "Id": "14248044", "CommentCount": "11", "FavoriteCount": "10", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:31:09.757", "LastEditorUserId": "-1", "LastActivityDate": "2014-09-18T11:41:50.910", "Score": "42", "OwnerUserId": "560648", "Tags": "<c++>", "AnswerCount": "3"}, "14248127": {"Id": "14248127", "PostTypeId": "2", "Body": "<p>All the standard text refers to creating an \"unnamed struct\":</p>\n<pre><code>struct {\n   int hi;\n   int bye;\n};\n</code></pre>\n<p>Just a nice friendly type, with no accessible name.</p>\n<p>In a standard way, it could be instantiated as a member like this:</p>\n<pre><code>struct Foo {\n   struct {\n      int hi;\n      int bye;\n   } bar;\n};\n\nint main()\n{\n   Foo f;\n   f.bar.hi = 3;\n}\n</code></pre>\n<hr>\n<p>But an \"anonymous struct\" is subtly different \u2014 it's the combination of an \"unnamed struct\" and the fact that you magically get members out of it in the parent object:</p>\n<pre><code>struct Foo {\n   struct {\n      int hi;\n      int bye;\n   }; // &lt;--- no member name!\n};\n\nint main()\n{\n   Foo f;\n   f.hi = 3;\n}\n</code></pre>\n<p>Converse to intuition<sup>\u2020</sup>, this does not merely create an unnamed struct that's nested witin <code>Foo</code>, but also automatically gives you an \"anonymous member\" of sorts which makes the members accessible within the parent object.</p>\n<p>It is this functionality that is non-standard. GCC <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Unnamed-Fields.html\" rel=\"noreferrer\"><em>does</em> support it</a>, and so does Visual C++. Windows API headers make use of this feature by default, but you can specify that you don't want it by adding <code>#define NONAMELESSUNION</code> before including the Windows header files.</p>\n<p>Compare with the <em>standard</em> functionality of \"anonymous unions\" which do a similar thing:</p>\n<pre><code>struct Foo {\n   union {\n      int hi;\n      int bye;\n   }; // &lt;--- no member name!\n};\n\nint main()\n{\n   Foo f;\n   f.hi = 3;\n}\n</code></pre>\n<hr>\n<p><sup>\u2020</sup> It appears that, though the term \"unnamed\" refers to the type (i.e. \"the class\" or \"the struct\") itself, the term \"anonymous\" refers instead to the actual instantiated member (using an older meaning of \"the struct\" that's closer to \"an object of some <code>struct</code>y type\"). This was likely the root of your initial confusion.</p>\n</hr></hr>", "LastEditorUserId": "560648", "LastActivityDate": "2013-01-09T23:41:57.557", "Score": "45", "CreationDate": "2013-01-09T23:09:01.877", "ParentId": "14248044", "CommentCount": "14", "LastEditDate": "2013-01-09T23:41:57.557", "OwnerUserId": "560648"}, "14248107": {"Id": "14248107", "PostTypeId": "2", "Body": "<p>The things that Microsoft calls anonymous structs are not standard. An unnamed struct is just an ordinary struct that doesn't have a name. There's not much you can do with one, unless you also define an object of that type:</p>\n<pre><code>struct {\n    int i;\n    double d;\n} my_object;\n\nmy_object.d = 2.3;\n</code></pre>\n<p>Anonymous <strong>unions</strong> are part of the standard, and they have the behavior you'd expect from reading <a href=\"http://msdn.microsoft.com/en-us/library/vstudio/35ect93t.aspx\" rel=\"nofollow\">Microsoft's description</a> of their anonymous structs:</p>\n<pre><code>union {\n    int i;\n    double d;\n};\n\nd = 2.3;\n</code></pre>\n", "LastEditorUserId": "1593860", "LastActivityDate": "2014-09-18T11:41:50.910", "Score": "11", "CreationDate": "2013-01-09T23:07:17.870", "ParentId": "14248044", "CommentCount": "4", "LastEditDate": "2014-09-18T11:41:50.910", "OwnerUserId": "1593860"}, "14248134": {"Id": "14248134", "PostTypeId": "2", "Body": "<p>The standard talks about <em>anonymous unions</em>: [9.5]/5</p>\n<blockquote>\n<p id=\"so_14248044_14248134_0\">A union of the form</p>\n<pre><code>union { member-specification } ;\n</code></pre>\n<p id=\"so_14248044_14248134_1\">is called an anonymous union; it defines an unnamed object of unnamed type. The member-specification of an anonymous union shall only define non-static data members. [ Note: Nested types and functions cannot be declared within an anonymous union. \u2014end note ] The names of the members of an anonymous union shall be distinct from the names of any other entity in the scope in which the anonymous union is declared. For the purpose of name lookup, after the anonymous union definition, the members of the anonymous union are considered to have been defined in the scope in which the anonymous union is declared. [ Example:</p>\n<pre><code>void f() {\n    union { int a; const char* p; };\n    a = 1;\n    p = \"Jennifer\";\n}\n</code></pre>\n<p id=\"so_14248044_14248134_2\">Here a and p are used like ordinary (nonmember) variables, but since they are union members they have the same address. \u2014end example ]</p>\n</blockquote>\n<p>The <em>anonymous structs</em> that <em>Microsoft</em> talks about is this feature for <code>unions</code> but applied to <code>structs</code>. Is not just an unnamed definition, its important to note that mebers of the anonymous union/struct are considered to have been defined in the scope in which the anonymous union/struct is declared.</p>\n<p>As far as I know, there is no such behavior for <em>unnamed structs</em> in the Standard. Note how in the cited example you can achieve things that wouldn't be otherwise possible, like sharing storage for variables in the stack, while <em>anonymous structs</em> bring nothing new to the table.</p>\n", "LastEditorUserId": "927034", "LastActivityDate": "2013-01-09T23:18:28.483", "Score": "9", "CreationDate": "2013-01-09T23:09:41.020", "ParentId": "14248044", "CommentCount": "10", "LastEditDate": "2013-01-09T23:18:28.483", "OwnerUserId": "927034"}});