post_cb({"29958042": {"ParentId": "29951564", "CommentCount": "2", "Body": "<p>When you have any class that has a protected or private Constructor, that class is considered \"An Abstract Class Object\" This means that it represents a concept or an idea of what an object should be like that contains all comment elements. You can not instantiate an object of this type directly! Thus you must inherit from this class who's constructors are public unless if they are abstract as well. The other idea is to be a specialized object that can not be instantiated directly but can be friends to other classes where their methods can instantiate the object, meaning those classes that have friend access to this abstract class would be able to instantiate this object which will live in the life span and scope of the friends class object. Examples:</p>\n<pre><code>class A {\npublic: \n    enum ClassType {\n        TYPE_A = 0,\n        TYPE_B,\n        TYPE_C,\n        TYPE_D,\n        TYPE_E,\n        TYPE_F\n    };\n\nprivate:\n    unsigned m_uId;\nprotected:\n    explicit A( A::ClassType type ) :\n    m_uId( static_cast&lt;unsigned&gt;( type ) {}\n\n    void initialize() = 0; // Purely Abstract - Each Derived Class Must Create This Function\n    void cleanup();     \n};\n\nclass B sealed : public A {\npublic:\n    B() : A( TYPE_A ) {}\n    void initialize() override; \n};\n\nclass C sealed : public A {\npublic:\n    C() : A( TYPE_C ) {}\n    void initialize() override;\n};\n\nclass D : public A {\nprotected:\n    D( A::ClassType type ) : A( type ) {}          \n    void initialize() override = 0;\n};\n\nclass E sealed : public D {\npublic:\n    E() : D( TYPE_E ) {}\n    void initialize() override;\n};\n\nclass F sealed : public D {\npublic:\n    F : D( TYPE_F ) {}\n    void initialize() override;\n};\n</code></pre>\n<p>Here I demonstrate polymorphic inheritance. Class A &amp; D you can not instantiate objects for, however classes B,C,E &amp; F you can instantiate objects. Because the constructors for A &amp; D are protected any derived class has access to them. With this setup every class has access to A::cleanup() and every class must implement its own ::initialize() override function. </p>\n<p>For this next part I will demonstrate the use of using an abstract class that friend classes can use. </p>\n<pre><code>class Counter {\n    friend unsigned Object1::getCount();\n    friend unsigned Object2::getCount();\nprivate:\n   static unsigned m_uCounter;       \n   Counter() { ++m_uCounter; }\n\npublic:\n    unsigned getCounter() { return m_uCounter; }       \n};\n\nclass Object1 {\n    friend class Counter;\nprivate:\n    unsigned m_uCount;\npublic:\n    Object1() : m_uCount( 0 ) {}\n    void count() { \n        Counter counter; \n        m_uCount = counter.getCounter();\n    }\n\n    unsigned getCount() const { return m_uCounter; }      \n};\n\nclass Object2 {\n    friend class Counter;\nprivate:\n    unsigned m_uCount;\npublic:\n    Object2() : m_uCount( 0 ) {}\n    void count() {\n        Counter counter;\n        m_uCount = counter.getCounter();\n    }\n\n    unsigned getCount() const { return m_uCount; }\n};\n</code></pre>\n<p>This code shows how to use an abstract class that can not be declared on its own, but can be used within other classes by being a friend class. In this situation as only a demonstration the sole purpose of the Counter class is to do the work of incrementing. The counter class can not be a stand alone object which doesn't make sense to have, however its use within other classes through the friend declarations allows those classes to have access to its constructor via the function declaration from the outside classes that are declared as friend functions within the abstract class. This kind of setup allows only Object1::getCount() and Object2::getCount() to declare a type of Counter and to have access to Counter::getCounter(). </p>\n<p>I hope this helps your understanding in Abstract Classes that deal with Polymorphism using inheritance, Abstract Class association via friend use, and how to properly declare a type that is abstract. </p>\n<p>In your code in which others had addressed A A(); is declaring a function prototype where A a1; is trying to declare a type of A which is Abstract!</p>\n", "OwnerUserId": "1757805", "PostTypeId": "2", "Id": "29958042", "Score": "1", "CreationDate": "2015-04-30T02:33:21.383", "LastActivityDate": "2015-04-30T02:33:21.383"}, "29951564": {"CommentCount": "1", "ViewCount": "156", "PostTypeId": "1", "LastEditorUserId": "3478852", "CreationDate": "2015-04-29T18:22:26.970", "LastActivityDate": "2016-07-29T23:42:06.843", "Title": "Create base class instance in derived class member function when the base class constructor is protected", "AcceptedAnswerId": "29951816", "LastEditDate": "2016-07-29T23:42:06.843", "Id": "29951564", "Score": "0", "Body": "<p>Given the following code:</p>\n<pre><code>class A\n{\nprotected:\n    A(){};  // compilation error\npublic:\n    void foo(){cout &lt;&lt; \"A\\n\";}; \n};\n\nclass B : public A\n{\npublic:\n    B() { };\n    void foo(){\n        cout &lt;&lt; \"B\\n\";\n        A A(); // OK\n        A a1; // compilation error\n    }\n};\n</code></pre>\n<p>If I changed the base class <code>A</code> constructor to <code>public</code>, the code compiles. How to explain this?</p>\n", "Tags": "<c++><constructor><protected><base><derived>", "OwnerUserId": "2207605", "AnswerCount": "4"}, "29951816": {"ParentId": "29951564", "LastEditDate": "2015-04-29T19:32:21.277", "CommentCount": "2", "CreationDate": "2015-04-29T18:34:45.860", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "PostTypeId": "2", "Id": "29951816", "Score": "2", "Body": "<p>\u00a711.4/1:</p>\n<blockquote>\n<p id=\"so_29951564_29951816_0\">As described earlier, access to a protected member is granted because\n  the reference occurs in a friend or member of some class <code>C</code>. If the\n  access is to form a pointer to member (5.3.1), [\u2026].<br>\n<strong>All other\n  accesses involve a (possibly implicit) object expression (5.2.5). In\n  this case, the class of the object expression shall be <code>C</code> or a class\n  derived from <code>C</code>.</strong></br></p>\n</blockquote>\n<p>In your case, the access is implicit but nonetheless present. We are trying to access <code>A</code>s constructor with the (implicit) object argument <code>a1</code>. \u00a711/6:</p>\n<blockquote>\n<p id=\"so_29951564_29951816_1\">All access controls in Clause 11 affect the ability to access a class\n  member name from the declaration of a particular entity [\u2026]. [ <em>Note</em>:\n  <strong>this access also applies to implicit references to constructors, conversion functions, and destructors.</strong> \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>However, <code>a1</code> is not of type <code>B</code> or a class derived from <code>B</code>. Hence our above requirement is not met, and access control is not happy.</p>\n", "LastActivityDate": "2015-04-29T19:32:21.277"}, "29951632": {"ParentId": "29951564", "CommentCount": "2", "Body": "<p>In order to create an object, the constructor needed to do so must be accessible. Within a member of <code>B</code>, you can access protected members of <code>A</code>, but <em>only</em> via an object of type <code>B</code>. So you can't access the protected default constructor there.</p>\n<p>The previous line <code>A a();</code> compiles because it declares a function.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "29951632", "Score": "2", "CreationDate": "2015-04-29T18:26:19.110", "LastActivityDate": "2015-04-29T18:26:19.110"}, "bq_ids": {"n4140": {"so_29951564_29951816_0": {"section_id": 6695, "quality": 0.9393939393939394, "length": 31}, "so_29951564_29951816_1": {"section_id": 6669, "quality": 0.88, "length": 22}}, "n3337": {"so_29951564_29951816_0": {"section_id": 6450, "quality": 0.9393939393939394, "length": 31}, "so_29951564_29951816_1": {"section_id": 6424, "quality": 0.88, "length": 22}}, "n4659": {"so_29951564_29951816_1": {"section_id": 8144, "quality": 0.88, "length": 22}, "so_29951564_29951816_0": {"section_id": 8170, "quality": 0.9393939393939394, "length": 31}}}, "29952319": {"ParentId": "29951564", "CommentCount": "0", "Body": "<p>To allow access to protected methods you can use <code>friend class</code>.\nAn example:</p>\n<pre><code>class A\n{\n    friend class B;\nprotected:\n    A(){};\npublic:\n    void foo(){cout &lt;&lt; \"A\\n\";}; \n};\n\nclass B : public A\n{\npublic:\n    B() { };\n    void foo(){\n        cout &lt;&lt; \"B\\n\";\n        A a1;\n    }\n};\n</code></pre>\n", "OwnerUserId": "4833336", "PostTypeId": "2", "Id": "29952319", "Score": "0", "CreationDate": "2015-04-29T19:00:39.200", "LastActivityDate": "2015-04-29T19:00:39.200"}});