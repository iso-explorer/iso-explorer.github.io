post_cb({"22929886": {"ParentId": "22927045", "CommentCount": "1", "Body": "<p>With a reasonable implementation, you can assume:</p>\n<p><strong>std::unique_ptr</strong>:</p>\n<ul>\n<li>All operations on a std::unique_ptr are as lock-free as the corresponding operations on a raw pointer, because there is nothing special regarding concurrency.</li>\n</ul>\n<p><strong>std::shared_ptr</strong>:</p>\n<ul>\n<li>All operations, that do not change the reference count, are as lock-free as the corresponding operations on a raw pointer. That includes the operations <em>dereferencing</em> and <em>move construction</em>.</li>\n<li>std::move is lock-free, because it is only a cast to an rvalue-reference.</li>\n<li>The destructor of a std::shared_ptr is at least as lock-free as <code>std::atomic&lt;std::size_t&gt;</code> (can be checked with the member function <code>is_lock_free</code>).</li>\n<li><em>Move assignment</em> depends on whether the std::shared_ptr on the left side has an associated managed object or not. If there is an associated managed object, it is as lock-free as the <em>destructor</em>. Otherwise it is as lock-free as a <em>move constructor</em>, because the reference count is not changed.</li>\n</ul>\n", "OwnerUserId": "1305501", "PostTypeId": "2", "Id": "22929886", "Score": "4", "CreationDate": "2014-04-08T07:05:07.113", "LastActivityDate": "2014-04-08T07:05:07.113"}, "22927230": {"ParentId": "22927045", "CommentCount": "4", "Body": "<p>All that the standard says is that for <code>shared_ptr&lt;&gt;</code> (20.7.2.2/4 \"Class template shared_ptr\"):</p>\n<blockquote>\n<p id=\"so_22927045_22927230_0\">Changes in <code>use_count()</code> do not reflect modifications that can\n  introduce data races</p>\n</blockquote>\n<p>It doesn't say that those changes in <code>use_count()</code> have to be lock free.  The standard permits a mutex to be used to prevent the data race.</p>\n<p><code>unique_ptr&lt;&gt;</code> has no promises to prevent data races (it's not intended to be thread safe on it's own).</p>\n", "OwnerUserId": "12711", "PostTypeId": "2", "Id": "22927230", "Score": "2", "CreationDate": "2014-04-08T03:56:45.550", "LastActivityDate": "2014-04-08T03:56:45.550"}, "bq_ids": {"n4140": {"so_22927045_22927230_0": {"section_id": 4377, "quality": 1.0, "length": 8}}, "n3337": {"so_22927045_22927230_0": {"section_id": 4214, "quality": 1.0, "length": 8}}, "n4659": {"so_22927045_22927230_0": {"section_id": 5640, "quality": 1.0, "length": 8}}}, "22927045": {"CommentCount": "5", "AcceptedAnswerId": "22927230", "CreationDate": "2014-04-08T03:36:18.453", "LastActivityDate": "2014-04-08T07:05:07.113", "PostTypeId": "1", "ViewCount": "808", "FavoriteCount": "1", "Title": "Are C++ smart pointers lockfree?", "Id": "22927045", "Score": "5", "Body": "<p>Are the following operations lockfree for <code>std::unique_ptr</code> and/or <code>std::shared_ptr</code>?</p>\n<ol>\n<li>Dereferencing, i.e. <code>read(*myPtr)</code> or <code>myPtr-&gt;getSomething()</code></li>\n<li>Removing a reference, i.e. with <code>std::move(myUniquePtr)</code> or when a <code>std::shared_ptr</code> goes out of scope.</li>\n</ol>\n<p>In my case, I am not concurrently accessing these pointers from multiple threads. I'm just curious if I can use them exclusively on a high-priority, lockfree thread. The objects managed by the pointers were allocated by the main thread prior to the high-priority callbacks and will not be deallocated until the callbacks cease.</p>\n<p>Thanks!</p>\n", "Tags": "<c++><multithreading><c++11><smart-pointers><lock-free>", "OwnerUserId": "1599617", "AnswerCount": "2"}});