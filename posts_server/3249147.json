post_cb({"3249527": {"ParentId": "3249147", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The important verbiage in the current standard (C++03) seems to be in \u00a78.5.3, which explains how references are initialized (In these quotes, <code>T1</code> is the type of the reference being initialized and <code>T2</code> is the type of the initializer expression).</p>\n<blockquote>\n<p id=\"so_3249147_3249527_0\">If the initializer expression is an rvalue, with <code>T2</code> a class type, and \"<code>cv1 T1</code>\" is reference-compatible with \"<code>cv2 T2</code>,\" the reference is bound in one of the following ways (the choice is implementation-defined):</p>\n<p id=\"so_3249147_3249527_1\">-- The reference is bound to the object represented by the rvalue (see 3.10) or to a sub-object within that object.</p>\n<p id=\"so_3249147_3249527_2\">-- A temporary of type \"<code>cv1 T2</code>\" [sic] is created, and a constructor is called to copy the entire rvalue object into the temporary. The reference is bound to the temporary or to a sub-object within the temporary.</p>\n<p id=\"so_3249147_3249527_3\">The constructor that would be used to make the copy shall be callable whether or not the copy is actually done.</p>\n</blockquote>\n<p>So, even if the implementation binds the reference directly to the temporary object, the copy constructor must be accessible. </p>\n<p>Note that this is changed in C++0x, per the resolution of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#391\" rel=\"nofollow noreferrer\">CWG defect 391</a>.  The new language reads (N3092 \u00a78.5.3):</p>\n<blockquote>\n<p id=\"so_3249147_3249527_4\">Otherwise, if <code>T2</code> is a class type and</p>\n<p id=\"so_3249147_3249527_5\">-- the initializer expression is an rvalue and \"<code>cv1 T1</code>\" is reference-compatible with \"<code>cv2 T2</code>,\"</p>\n<p id=\"so_3249147_3249527_6\">-- <code>T1</code> is not reference-related to <code>T2</code> and the initializer expression can be implicitly converted to an rvalue of type \"<code>cv3 T3\"</code> (this conversion is selected by enumerating the applicable conversion functions (13.3.1.6) and choosing the best one through overload resolution (13.3)),</p>\n<p id=\"so_3249147_3249527_7\">then the reference is bound to the initializer expression rvalue in the first case and to the object that is the result of the conversion in the second case (or, in either case, to the appropriate base class subobject of the object).</p>\n</blockquote>\n<p>The first case applies and the reference is \"bound directly\" to the initializer expression.</p>\n", "OwnerUserId": "151292", "LastEditorUserId": "151292", "LastEditDate": "2010-07-14T19:20:35.917", "Id": "3249527", "Score": "4", "CreationDate": "2010-07-14T19:03:48.063", "LastActivityDate": "2010-07-14T19:20:35.917"}, "3249392": {"ParentId": "3249147", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>So what you're using is 'copy-initialization':</p>\n<blockquote>\n<p id=\"so_3249147_3249392_0\">8.5/11 Initializers</p>\n<p id=\"so_3249147_3249392_1\">The form of initialization (using\n  parentheses or =) is generally\n  insignificant, but does matter when\n  the entity being initialized has a\n  class type; see below. ...</p>\n<p id=\"so_3249147_3249392_2\">The initialization that occurs in\n  argument passing, function return,\n  throwing an exception (15.1), handling\n  an exception (15.3), and\n  brace-enclosed initializer lists\n  (8.5.1) is called copy-initialization\n  and is equivalent to the form</p>\n<pre><code>T x = a;\n</code></pre>\n<p id=\"so_3249147_3249392_3\">The initialization that occurs in new\n  expressions (5.3.4), static_cast\n  expressions (5.2.9), functional\n  notation type conversions (5.2.3), and\n  base and member initializers (12.6.2)\n  is called direct-initialization and is\n  equivalent to the form</p>\n<pre><code>T x(a);\n</code></pre>\n</blockquote>\n<p>In 13.3.1.3 \"Initialization by constructor\", the overloads for the constructor chosen are:</p>\n<blockquote>\n<p id=\"so_3249147_3249392_4\">When objects of class type are direct-initialized (8.5), or copy-initialized from an expression of the same or a derived class type (8.5), overload resolution selects the constructor. For direct-initialization, the candidate functions are all the constructors of the class of the object being initialized. For copy initialization, the candidate functions are all the converting constructors (12.3.1) of that class.</p>\n</blockquote>\n<p>So, for copy-initialization, the copy constructor must be available.  However, the compiler is permitted to 'optimize away' the copy:</p>\n<p>12.2/1 Temporary objects</p>\n<blockquote>\n<p id=\"so_3249147_3249392_5\">Even when the creation of the temporary object is avoided (12.8), all the semantic restrictions must be respected as if the temporary object was created. [Example: even if the copy constructor is not called, all the semantic restrictions, such as accessibility (clause 11), shall be satisfied. ]</p>\n</blockquote>\n<p>You can get the effect you want by avoiding copy-initialization and using direct-initialization:</p>\n<pre><code> const A &amp;b(B());  \n</code></pre>\n<hr>\n<p>Note:</p>\n<p>Since newer versions of GCC apparently have a different behavior, I thought I'd post this note, which might address the difference (with both behaviors still standards conforming):</p>\n<p>8.5.3/5 References says:</p>\n<blockquote>\n<p id=\"so_3249147_3249392_6\">If the initializer expression is an rvalue, with T2 a class type, and \u201ccv1 T1\u201d is reference-compatible with \u201ccv2 T2,\u201d the reference is bound in one of the following ways (the choice is implementation-defined):</p>\n<ul>\n<li><p id=\"so_3249147_3249392_7\">The reference is bound to the object represented by the rvalue (see 3.10) or to a sub-object within\n  that object.</p></li>\n<li><p id=\"so_3249147_3249392_8\">A temporary of type \u201ccv1 T2\u201d [sic] is created, and a constructor is called to copy the entire rvalue object into the temporary. The reference is bound to the temporary or to a sub-object within the temporary.</p></li>\n</ul>\n<p id=\"so_3249147_3249392_9\">The constructor that would be used to make the copy shall be callable whether or not the copy is actually done.</p>\n</blockquote>\n<p>I originally read the last sentence (\"the constructor that would be used...\") to apply to both options, but maybe it should be read as only applying to the seconds option - or at least maybe that's how the GCC maintainers are reading it. </p>\n<p>I'm not sure if this is what's going on between the differing behavior of GCC versions (comments welcome).  We're definitely reaching the limits of my language-lawyering skills...</p>\n</hr>", "OwnerUserId": "12711", "LastEditorUserId": "12711", "LastEditDate": "2010-07-14T20:05:31.310", "Id": "3249392", "Score": "3", "CreationDate": "2010-07-14T18:48:32.823", "LastActivityDate": "2010-07-14T20:05:31.310"}, "3249147": {"CommentCount": "10", "ViewCount": "338", "CreationDate": "2010-07-14T18:17:46.313", "LastActivityDate": "2010-07-14T20:05:31.310", "Title": "Unexpected const reference behavior", "AcceptedAnswerId": "3249527", "PostTypeId": "1", "Id": "3249147", "Score": "8", "Body": "<pre><code>#include &lt;iostream&gt;\n\nclass A { \n  public:  \n    A(){ cerr &lt;&lt; \"A Constructor\" &lt;&lt; endl; }  \n    ~A(){ cerr &lt;&lt; \"A Destructor\" &lt;&lt; endl; }  \n    A(const A &amp;o){ cerr &lt;&lt; \"A Copy\" &lt;&lt; endl; } \n    A&amp; operator=(const A &amp;o){ cerr &lt;&lt; \"A Assignment\" &lt;&lt; endl; return *this; }\n};\n\n\nclass B : public A { \n  public:  \n    B() : A() { cerr &lt;&lt; \"B Constructor\" &lt;&lt; endl; }  \n    ~B(){ cerr &lt;&lt; \"B Destructor\" &lt;&lt; endl; }\n  private:\n    B(const B &amp;o) : A() { cerr &lt;&lt; \"B Copy\" &lt;&lt; endl; } \n    B&amp; operator=(const B &amp;o){ cerr &lt;&lt; \"B Assignment\" &lt;&lt; endl; return *this; }\n};\n\nint main() {  \n  A a;  \n  const A &amp;b = B();  \n  return 0; \n}\n</code></pre>\n<p>In GCC 4.2, I get this message:</p>\n<pre><code>In function 'int main()':\nLine 16: error: 'B::B(const B&amp;)' is private\ncompilation terminated due to -Wfatal-errors.\n</code></pre>\n<p>If I remove the \"private\" from B, I get the output I expect:</p>\n<pre><code>A Constructor\nA Constructor\nB Constructor\nB Destructor\nA Destructor\nA Destructor\n</code></pre>\n<p>My question is: why does making a method which isn't called private change whether this code compiles?  Is this standard-mandated?  Is there a workaround?</p>\n", "Tags": "<c++><gcc4>", "OwnerUserId": "391896", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_3249147_3249527_7": {"section_id": 3321, "quality": 0.95, "length": 19}, "so_3249147_3249392_1": {"section_id": 3293, "quality": 0.9444444444444444, "length": 17}, "so_3249147_3249392_5": {"section_id": 378, "quality": 0.5357142857142857, "length": 15}, "so_3249147_3249392_4": {"section_id": 592, "quality": 0.8571428571428571, "length": 30}, "so_3249147_3249392_2": {"section_id": 3294, "quality": 0.5238095238095238, "length": 11}, "so_3249147_3249527_5": {"section_id": 597, "quality": 0.6666666666666666, "length": 4}, "so_3249147_3249527_6": {"section_id": 3321, "quality": 0.7391304347826086, "length": 17}, "so_3249147_3249392_7": {"section_id": 3321, "quality": 0.6363636363636364, "length": 7}, "so_3249147_3249392_3": {"section_id": 3295, "quality": 0.6818181818181818, "length": 15}, "so_3249147_3249527_1": {"section_id": 3321, "quality": 0.6363636363636364, "length": 7}}, "n3337": {"so_3249147_3249527_7": {"section_id": 3191, "quality": 0.9, "length": 18}, "so_3249147_3249392_1": {"section_id": 3163, "quality": 0.9444444444444444, "length": 17}, "so_3249147_3249392_5": {"section_id": 369, "quality": 0.75, "length": 21}, "so_3249147_3249392_4": {"section_id": 582, "quality": 0.8571428571428571, "length": 30}, "so_3249147_3249392_2": {"section_id": 3164, "quality": 0.5238095238095238, "length": 11}, "so_3249147_3249527_5": {"section_id": 587, "quality": 0.6666666666666666, "length": 4}, "so_3249147_3249527_6": {"section_id": 3191, "quality": 0.782608695652174, "length": 18}, "so_3249147_3249392_3": {"section_id": 3165, "quality": 0.6818181818181818, "length": 15}}, "n4659": {"so_3249147_3249527_7": {"section_id": 4087, "quality": 0.9, "length": 18}, "so_3249147_3249527_6": {"section_id": 4087, "quality": 0.7391304347826086, "length": 17}, "so_3249147_3249392_4": {"section_id": 615, "quality": 0.8571428571428571, "length": 30}, "so_3249147_3249392_2": {"section_id": 4056, "quality": 0.5238095238095238, "length": 11}, "so_3249147_3249527_5": {"section_id": 620, "quality": 0.6666666666666666, "length": 4}, "so_3249147_3249392_6": {"section_id": 4087, "quality": 0.5333333333333333, "length": 8}, "so_3249147_3249392_7": {"section_id": 4087, "quality": 0.5454545454545454, "length": 6}, "so_3249147_3249527_0": {"section_id": 4087, "quality": 0.5333333333333333, "length": 8}, "so_3249147_3249527_1": {"section_id": 4087, "quality": 0.5454545454545454, "length": 6}}}, "3249376": {"ParentId": "3249147", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I think it is indeed a compiler bug, gcc seems to think that is is copy initialization. Use direct initialization instead:</p>\n<pre><code>const A&amp; b(B());\n</code></pre>\n<p>The copy-constructor call in copy initialization is always optimized away (an instance of copy elision), and then doesn't have to be available.</p>\n", "OwnerUserId": "178761", "LastEditorUserId": "178761", "LastEditDate": "2010-07-14T18:57:31.280", "Id": "3249376", "Score": "1", "CreationDate": "2010-07-14T18:47:25.803", "LastActivityDate": "2010-07-14T18:57:31.280"}});