post_cb({"31343676": {"Id": "31343676", "PostTypeId": "2", "Body": "<p>In [namespace.udecl], we have:</p>\n<blockquote>\n<p id=\"so_31343142_31343676_0\">When a <em>using-declaration</em> brings names from a base class into a derived class scope, member functions and\n  member function templates in the derived class override and/or hide member functions and member function\n  templates with the same name, parameter-type-list (8.3.5), cv-qualification, and ref-qualifier (if any) <strong>in a\n  base class</strong> (rather than conflicting).</p>\n</blockquote>\n<p>The standard explicitly says that names brought in will not conflict with names in a <em>base</em> class. But it doesn't say anything about bringing in conflicting names.</p>\n<p>The section also says:</p>\n<blockquote>\n<p id=\"so_31343142_31343676_1\">A <em>using-declaration</em> is a declaration and can therefore be used repeatedly where (and only where) multiple\n  declarations are allowed. <em>[ Example:</em></p>\n<pre><code>struct B {\n    int i;\n};\n\nstruct X : B {\n    using B::i;\n    using B::i; // error: double member declaration\n};\n</code></pre>\n<p id=\"so_31343142_31343676_2\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p>And interestingly, in the following example it's GCC that happily compiles it (and prints A) while Clang allows the construction of a C but rejects the call to foo as ambiguous:</p>\n<pre><code>struct A {\n    void foo() { std::cout &lt;&lt; \"A\\n\"; }\n};\n\nstruct B {\n    void foo() { std::cout &lt;&lt; \"B\\n\"; }\n};\n\nstruct C : A, B {\n    using A::foo;\n    using B::foo;\n};\n\n\nint main()\n{\n    C{}.foo();\n    return 0;\n}\n</code></pre>\n<p>So the short answer is - I suspect this is underspecified in the standard and that both compilers are doing acceptable things. I would just avoid writing this sort of code for general sanity. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-07-10T15:04:52.750", "Score": "11", "CreationDate": "2015-07-10T14:42:41.327", "ParentId": "31343142", "CommentCount": "11", "OwnerUserId": "2069064", "LastEditDate": "2015-07-10T15:04:52.750"}, "31343142": {"ViewCount": "562", "Body": "<p>Consider the following code:</p>\n<pre><code>struct A {\n    int propose();\n};\n\nstruct A1 : A {\n    int propose(int);\n    using A::propose;\n};\n\nstruct B1 : A1 {\nprotected:\n    using A1::propose;\npublic:\n    using A::propose;\n};\n\nint main() {\n    B1().propose();\n}\n</code></pre>\n<p>Let's compile this: <code>g++ -std=c++11 main.cpp</code>.</p>\n<p>I'm getting the following compiler error using GNU 4.8.1:</p>\n<pre><code>main.cpp: In function 'int main()':                                                                                                                    \nmain.cpp:2:9: error: 'int A::propose()' is inaccessible\n     int propose();\n         ^\nmain.cpp:18:18: error: within this context\n     B1().propose();\n</code></pre>\n<p>However, this code compiles in AppleClang 6.0.0.6000056.</p>\n<p>I understand that there is no need for the <code>using</code> in <code>B1</code>, (in my code was necessary, but I had 1 <code>using</code> too much by mistake). In any case, why Clang compiles it? Is this expected?</p>\n", "AcceptedAnswerId": "31343676", "Title": "Using \"using\" twice interpreted differently by different compilers", "CreationDate": "2015-07-10T14:19:14.033", "Id": "31343142", "CommentCount": "3", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-07-10T14:52:53.053", "LastEditorUserId": "701092", "LastActivityDate": "2015-07-10T20:51:39.680", "Score": "14", "OwnerUserId": "931303", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "31348802": {"Id": "31348802", "PostTypeId": "2", "Body": "<p>The declaration is legal.</p>\n<p>Calling it is legal and should work anywhere, and it can only be called from the class and derived classes, and it can be called from within any class.  You'll note that this makes little sense.</p>\n<p>There are no rules that ban that construct in declarations (importing the name twice from two different base classes with the same signature), and it is even used in \"real\" code where the derived class goes and hides the name after they are imported.</p>\n<p>If you don't hide it, you are in the strange situation where the same function <code>A::propose</code> is <strong>both</strong> protected and public at the same time, as it is named twice (legally) in the same scope with different access control.  This is ... unusual.</p>\n<p>If you are within a class, a sub-clause says you can use it:</p>\n<p>[class.access.base]/5.1</p>\n<blockquote>\n<p id=\"so_31343142_31348802_0\">A member m is accessible at the point R when named in class N if \u2014 (5.1) m as a member of N is public</p>\n</blockquote>\n<p>and <code>propose</code> is clearly public.  (it is also <code>protected</code> but we don't have to keep reading for that case!)</p>\n<p>Elsewhere, we have a contradiction.  You are told you can use it everywhere without restriction [class.access]/1(3).  And you are told that you can only use it in certain circumstances [class.access]/1(2).</p>\n<p>I am uncertain how to resolve that ambiguity.</p>\n<hr>\n<p>The rest of the logic train:</p>\n<p>In [namespace.udecl]/10 we have:</p>\n<blockquote>\n<p id=\"so_31343142_31348802_1\">A <em>using-declaration</em> is a declaration and can therefore be used repeatedly where (and only where) multiple declarations are allowed.</p>\n</blockquote>\n<p>And [namespace.udecl]/13:</p>\n<blockquote>\n<p id=\"so_31343142_31348802_2\">Since a using-declaration is a declaration, the restrictions on declarations of the same name in the same declarative region</p>\n</blockquote>\n<p>so each of those <code>using X::propose;</code> are declarations.</p>\n<p>[basic.scope] has no applicable restrictions on two functions of the same name in a scope, other than [basic.scope.class]/1(3) which states that if reordering of declarations changes the program, the program is ill-formed.  So we cannot say that the later one wins.</p>\n<p>Two declarations of member functions in the same scope are legal under [basic.scope].  However, under [over], there are restrictions on two member functions with the same name.</p>\n<p>[over]/1 states:</p>\n<blockquote>\n<p id=\"so_31343142_31348802_3\">When two or more different declarations are specified for a single name in the same scope, that name is said to be overloaded</p>\n</blockquote>\n<p>And there are some restrictions on overloading.  This is what usually prevents</p>\n<pre><code>struct foo {\n  int method();\n  int method();\n};\n</code></pre>\n<p>from being legal.  However:</p>\n<p>[over.load]/1 states:</p>\n<blockquote>\n<p id=\"so_31343142_31348802_4\">Not all function declarations can be overloaded. Those that cannot be overloaded are specified here. A program is ill-formed if it contains two such non-overloadable declarations in the same scope. [Note: This\n  restriction applies to explicit declarations in a scope, and between such declarations and declarations made through a <em>using-declaration</em> (7.3.3). It does not apply to sets of functions fabricated as a result of name lookup (e.g., because of using-directives) or overload resolution (e.g., for operator functions). \u2014end note</p>\n</blockquote>\n<p>the note <em>explicitly</em> permits symbols introduced via two <em>using-declarations</em> from being considered by the overloading restrictions!  The rules only apply to two explicit declarations within the scope, or between an explicit declaration within the scope and a using declaration.</p>\n<p>There are <em>zero</em> restrictions on two <em>using-declarations</em>.  They can have the same name, and their signatures can conflict as much as you'd like.</p>\n<p>This is useful, because usually you can go and then hide their declaration (with a declaration in the derived class), and nothing goes wrong [namespace.udecl]/15:</p>\n<blockquote>\n<p id=\"so_31343142_31348802_5\">When a <em>using-declaration</em> brings names from a base class into a derived class scope, member functions and member function templates in the derived class override and/or hide member functions and member function templates with the same name, parameter-type-list (8.3.5), cv-qualification, and ref-qualifier (if any) in a base class (rather than conflicting).</p>\n</blockquote>\n<p>However, this is not done here.  We then call the method.  Overload resolution occurs.</p>\n<p>See [namespace.udecl]/16:</p>\n<blockquote>\n<p id=\"so_31343142_31348802_6\">For the purpose of overload resolution, the functions which are introduced by a\n  using-declaration into a derived class will be treated as though they were members of the derived class. In particular, the implicit this parameter shall be treated as if it were a pointer to the derived class rather than to the base class. This has no effect on the type of the function, and in all other respects the function remains a member of\n  the base class.</p>\n</blockquote>\n<p>So we have to treat them as if they are members of the derived class for the purpose of overload resolution.  But there are still 3 declarations here:</p>\n<pre><code>protected:\n  int A::propose(); // X\n  int A1::propose(int); // Y\npublic:\n  int A::propose(); // Z\n</code></pre>\n<p>Thus the call to <code>B1().propose()</code> considers all 3 declarations.  Both <code>X</code> and <code>Z</code> are equal.  They, however, refer to the same function, and overload resolution states there is an ambiguity if two <em>different</em> functions are selected.  So the result is not ambiguous.  There may be access control violations, or not, depending on how you read the standard.</p>\n<p>[over.match]/3</p>\n<blockquote>\n<p id=\"so_31343142_31348802_7\">If a best viable function exists and is unique, overload resolution succeeds and produces it as the result.  Otherwise overload resolution fails and the invocation is ill-formed. When overload resolution succeeds, and the best viable function is not accessible (Clause 11) in the context in which it is used, the program is ill-formed.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "1774667", "LastActivityDate": "2015-07-10T20:51:39.680", "Score": "2", "CreationDate": "2015-07-10T19:25:41.207", "ParentId": "31343142", "CommentCount": "0", "OwnerUserId": "1774667", "LastEditDate": "2015-07-10T20:51:39.680"}, "bq_ids": {"n4140": {"so_31343142_31343676_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 5499}, "so_31343142_31348802_6": {"length": 40, "quality": 0.9523809523809523, "section_id": 5505}, "so_31343142_31348802_5": {"length": 35, "quality": 0.9722222222222222, "section_id": 5504}, "so_31343142_31343676_0": {"length": 35, "quality": 0.9722222222222222, "section_id": 5504}, "so_31343142_31348802_0": {"length": 8, "quality": 1.0, "section_id": 6682}, "so_31343142_31348802_4": {"length": 44, "quality": 0.88, "section_id": 556}, "so_31343142_31348802_2": {"length": 10, "quality": 1.0, "section_id": 5502}, "so_31343142_31348802_3": {"length": 13, "quality": 1.0, "section_id": 554}, "so_31343142_31348802_1": {"length": 10, "quality": 1.0, "section_id": 5499}, "so_31343142_31348802_7": {"length": 27, "quality": 1.0, "section_id": 564}}, "n3337": {"so_31343142_31348802_4": {"length": 44, "quality": 0.88, "section_id": 547}, "so_31343142_31343676_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 5285}, "so_31343142_31348802_5": {"length": 35, "quality": 0.9722222222222222, "section_id": 5290}, "so_31343142_31348802_0": {"length": 8, "quality": 1.0, "section_id": 6437}, "so_31343142_31348802_6": {"length": 40, "quality": 0.9523809523809523, "section_id": 5291}, "so_31343142_31343676_0": {"length": 35, "quality": 0.9722222222222222, "section_id": 5290}, "so_31343142_31348802_2": {"length": 10, "quality": 1.0, "section_id": 5288}, "so_31343142_31348802_3": {"length": 13, "quality": 1.0, "section_id": 545}, "so_31343142_31348802_1": {"length": 10, "quality": 1.0, "section_id": 5285}, "so_31343142_31348802_7": {"length": 27, "quality": 1.0, "section_id": 555}}, "n4659": {"so_31343142_31348802_4": {"length": 44, "quality": 0.88, "section_id": 579}, "so_31343142_31343676_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 6933}, "so_31343142_31348802_5": {"length": 32, "quality": 0.8888888888888888, "section_id": 6938}, "so_31343142_31348802_0": {"length": 8, "quality": 1.0, "section_id": 8157}, "so_31343142_31348802_6": {"length": 39, "quality": 0.9285714285714286, "section_id": 6939}, "so_31343142_31343676_0": {"length": 32, "quality": 0.8888888888888888, "section_id": 6938}, "so_31343142_31348802_2": {"length": 10, "quality": 1.0, "section_id": 6936}, "so_31343142_31348802_3": {"length": 13, "quality": 1.0, "section_id": 577}, "so_31343142_31348802_1": {"length": 10, "quality": 1.0, "section_id": 6933}, "so_31343142_31348802_7": {"length": 27, "quality": 1.0, "section_id": 587}}}});