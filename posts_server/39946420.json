post_cb({"39946420": {"CommentCount": "11", "CreationDate": "2016-10-09T17:25:48.537", "PostTypeId": "1", "AcceptedAnswerId": "39946511", "LastEditorUserId": "701092", "LastActivityDate": "2016-10-09T19:58:54.907", "LastEditDate": "2016-10-09T17:49:50.583", "ViewCount": "169", "FavoriteCount": "2", "Title": "What's the difference between void and cv void?", "Id": "39946420", "Score": "3", "Body": "<p>I have come across <strong>the type \"cv void\"</strong> in the latest draft of the C++ standard (<em>N4606</em>) :</p>\n<blockquote>\n<h3>8.3.3 [dcl.mptr], paragraph 3</h3>\n<p id=\"so_39946420_39946420_0\">A pointer to member shall not point to a static member of a class (9.2.3), a member with reference type, <strong>or \u201ccv void\u201d</strong>.</p>\n</blockquote>\n<p>With a little bit of research, I found <strong>\"cv void\" is a real type</strong>, but I have no idea what's the difference <strong>compared to the type void</strong>. Can you explain it <strong>with an example</strong> (maybe with a code) ?</p>\n<hr>\n<p><strong>EDIT</strong> :</p>\n<ul>\n<li>I sort of expected cv would stand for cv-qualified. My question here is, why do we need to \"cv-qualify\" the type void?</li>\n<li>The reason I said <strong>\"cv void is a real type\"</strong> is that, the standard actually defined it:\n\n<blockquote>\n<h3>3.9.1 [basic.fundamental], paragraph 9</h3>\n<p id=\"so_39946420_39946420_1\">A type cv void is an incomplete type that cannot be completed; such a type has an empty set of values...</p>\n</blockquote></li>\n</ul>\n</hr>", "Tags": "<c++><c++11><language-lawyer>", "OwnerUserId": "5645940", "AnswerCount": "4"}, "39946581": {"ParentId": "39946420", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_39946420_39946581_0\">why do we need to \"<code>cv</code>-qualify\" the type <code>void</code>?</p>\n</blockquote>\n<p>Same reason you would need to <em>cv</em>-qualify any other type. For instance, <a href=\"http://en.cppreference.com/w/cpp/string/byte/memcpy\" rel=\"nofollow\"><code>memcpy</code></a>'s signature is:</p>\n<pre><code>void* memcpy( void* dest, const void* src, std::size_t count );\n</code></pre>\n<p>The <code>src</code> argument is a pointer to <code>const void</code>, because the memory pointed to by <code>src</code> will not be modified by the function. This let's me pass in a pointer to a <code>const</code> object:</p>\n<pre><code>const POD pod{...};\nPOD new_pod;\nmemcpy(&amp;new_pod, &amp;pod, sizeof(pod)); \n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "39946581", "Score": "1", "CreationDate": "2016-10-09T17:42:31.293", "LastActivityDate": "2016-10-09T17:42:31.293"}, "39946511": {"ParentId": "39946420", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>\"cv void\" is not a real type. \"cv\" here is a shorthand for \"possibly cv-qualified\", which means \"may have a <code>const</code> or a <code>volatile</code> on it\".</p>\n<p>The passage means that a pointer-to-member may not point to an object of the following types: <code>void</code>, <code>const void</code>, <code>volatile void</code> and <code>const volatile void</code>. It's fairly obvious, since such objects cannot exist in the first place, but I guess it's nice to be clear.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "4672588", "LastEditDate": "2016-10-09T19:58:54.907", "Id": "39946511", "Score": "3", "CreationDate": "2016-10-09T17:35:25.563", "LastActivityDate": "2016-10-09T19:58:54.907"}, "39946556": {"ParentId": "39946420", "CommentCount": "0", "Body": "<p>We don't \"need\" to allow <code>void</code> to be cv-qualified. However, it's simpler to allow it than it is to make a special exception forbidding it.</p>\n<p>But it does actually have an important practical use: allowing <code>void</code> to be cv-qualified allows us to write cv-correct code with pointers-to-<code>void</code>.</p>\n", "OwnerUserId": "1084944", "PostTypeId": "2", "Id": "39946556", "Score": "3", "CreationDate": "2016-10-09T17:39:37.723", "LastActivityDate": "2016-10-09T17:39:37.723"}, "bq_ids": {"n4140": {"so_39946420_39946420_1": {"section_id": 7218, "quality": 0.6363636363636364, "length": 7}, "so_39946420_39946420_0": {"section_id": 3227, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_39946420_39946420_1": {"section_id": 6962, "quality": 0.6363636363636364, "length": 7}, "so_39946420_39946420_0": {"section_id": 3100, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_39946420_39946420_1": {"section_id": 8727, "quality": 0.9090909090909091, "length": 10}, "so_39946420_39946420_0": {"section_id": 3984, "quality": 0.8181818181818182, "length": 9}}}, "39946580": {"ParentId": "39946420", "CommentCount": "0", "Body": "<p>\"cv <code>void</code>\" means <code>void</code> which is optionally <code>const</code>- or <code>volatile</code>-qualified. Simply <code>void</code> is not so qualified.</p>\n<p>And for some reason, someone obviously thought it was a good idea to forbid that for member-pointers (in contrast to normal pointers).<br>\nSeems someone is no fan of untyped memory...</br></p>\n", "OwnerUserId": "3204551", "PostTypeId": "2", "Id": "39946580", "Score": "2", "CreationDate": "2016-10-09T17:42:23.997", "LastActivityDate": "2016-10-09T17:42:23.997"}});