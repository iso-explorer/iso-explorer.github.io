post_cb({"23928080": {"CommentCount": "3", "AcceptedAnswerId": "23928222", "PostTypeId": "1", "LastEditorUserId": "3235496", "CreationDate": "2014-05-29T07:29:25.530", "LastActivityDate": "2014-05-30T10:26:30.607", "LastEditDate": "2014-05-30T10:26:30.607", "ViewCount": "110", "FavoriteCount": "1", "Title": "c++11 what is first? constructor or default value?", "Id": "23928080", "Score": "3", "Body": "<p>In c++11 you can do this:</p>\n<pre><code>class Foo\n{\n    public:\n        Foo();\n        bool test = false;\n};\n\nFoo::Foo()\n{\n    // is test guaranteed to be false now? and is it surely not overriden later?\n    this-&gt;test = true;\n}\n</code></pre>\n<p>what I want to know is basically described in comments, I can verify this with my compiler, but is this mentioned in standard? Is it always same on all platforms and all compilers?</p>\n", "Tags": "<c++11><constructor><initialization>", "OwnerUserId": "1514983", "AnswerCount": "3"}, "23928277": {"ParentId": "23928080", "CommentCount": "0", "Body": "<p>In C++11, there are three places a non-static data member can be initialized:</p>\n<ul>\n<li>in the body of the class (a <em>brace-or-equal-initializer</em>)</li>\n<li>in the list of members before the constructor body (a <em>mem-initializer</em>)</li>\n<li>within the constructor body.</li>\n</ul>\n<p>If a non-static data member has both a <em>brace-or-equal-initializer</em> and a <em>mem-initializer</em>, then the <em>mem-initializer</em> overrides the <em>brace-or-equal-initializer</em>; this is specified in 12.6.2.p9.</p>\n<p>In either case, the initialization of the non-static data member occurs before the body of the constructor is entered, whereupon the constructor can alter the value of the member.</p>\n", "OwnerUserId": "567292", "PostTypeId": "2", "Id": "23928277", "Score": "2", "CreationDate": "2014-05-29T07:42:20.517", "LastActivityDate": "2014-05-29T07:42:20.517"}, "23928387": {"ParentId": "23928080", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From [<em>class.base.init</em>] <strong>12.6.2 - Initializing bases and members</strong></p>\n<blockquote>\n<p id=\"so_23928080_23928387_0\"><strong>9</strong> If a given non-static data member has both a <em>brace-or-equal-initializer</em> and\n  a <em>mem-initializer</em>, the initialization specified by the mem-initializer is performed,\n  and the non-static data member\u2019s <em>brace-or-equal-initializer</em> is ignored.</p>\n</blockquote>\n<p>Example</p>\n<pre><code>struct A\n{\n  int i = /\u2217 some integer expression with side effects \u2217/ ;\n  A(int arg) : i(arg) { } // ...\n};\n</code></pre>\n<p>the <code>A(int)</code> constructor will simply initialize <code>i</code> to the value of <code>arg</code>, and the side effects in <code>i</code>'s <em>brace-or-equal-initializer</em> will not take place.</p>\n<blockquote>\n<p id=\"so_23928080_23928387_1\"><strong>10</strong> In a non-delegating constructor, initialization proceeds in the following\n  order:</p>\n<ul>\n<li>First, and only for the constructor of the most derived class (1.8),\n  virtual base classes are initialized in the order they appear on a depth-first\n  left-to-right traversal of the directed acyclic graph of base classes, where\n  \u201cleft-to-right\u201d is the order of appearance of the base classes in the derived class\n  <em>base-specifier-list</em>.</li>\n<li>Then, direct base classes are initialized in declaration order as they\n  appear in the <em>base-specifier-list</em> (regardless of the order of the\n  <em>mem-initializers</em>).</li>\n<li>Then, non-static data members are initialized in the order they were declared in\n  the class definition (again regardless of the order of the <em>mem-initializers</em>).</li>\n<li>Finally, the compound-statement of the constructor body is executed.</li>\n</ul>\n</blockquote>\n<p>So</p>\n<pre><code>class Foo\n{\npublic:\n  Foo();\n  bool test = false;\n};\n\nFoo::Foo()\n{\n  // is test guaranteed to be false now? and is it surely not overriden later?\n  this-&gt;test = true;\n}\n</code></pre>\n<p><code>test</code> is guaranteed to be <code>false</code> and it won't be overwritten (<em>\"Finally, the compound-statement of the constructor body is executed\"</em>)</p>\n", "OwnerUserId": "3235496", "LastEditorUserId": "3235496", "LastEditDate": "2014-05-29T07:54:22.027", "Id": "23928387", "Score": "2", "CreationDate": "2014-05-29T07:48:48.073", "LastActivityDate": "2014-05-29T07:54:22.027"}, "23928222": {"ParentId": "23928080", "CommentCount": "2", "Body": "<p>is test guaranteed to be false now? Yes.</p>\n<p>is it surely not overriden later? It will not be overriden. The default is set as part of the initializer list at the start of the constructor.</p>\n<p>If test is not included in the initializer list the compiler will put it in with the default. For your constructor the compiler would actually generate code for this:</p>\n<pre><code>Foo::Foo()\n    : test(false)\n{\n    // is test guaranteed to be false now?\n    this-&gt;test = true;\n    // is it surely not overriden later?\n}\n</code></pre>\n<p>With this constructor test would first be initialized to false and then later in the body set to true.</p>\n<p>If you had written:</p>\n<pre><code>Foo::Foo()\n    : test(true)\n{\n}\n</code></pre>\n<p>The test would be in the initialiser list already and the compiler won't put it there and test would be directly initialized to true.</p>\n", "OwnerUserId": "568635", "PostTypeId": "2", "Id": "23928222", "Score": "2", "CreationDate": "2014-05-29T07:38:06.180", "LastActivityDate": "2014-05-29T07:38:06.180"}, "bq_ids": {"n4140": {"so_23928080_23928387_1": {"section_id": 438, "quality": 1.0, "length": 6}, "so_23928080_23928387_0": {"section_id": 436, "quality": 1.0, "length": 16}}, "n3337": {"so_23928080_23928387_1": {"section_id": 429, "quality": 1.0, "length": 6}, "so_23928080_23928387_0": {"section_id": 428, "quality": 1.0, "length": 16}}, "n4659": {"so_23928080_23928387_1": {"section_id": 458, "quality": 1.0, "length": 6}, "so_23928080_23928387_0": {"section_id": 455, "quality": 0.875, "length": 14}}}});