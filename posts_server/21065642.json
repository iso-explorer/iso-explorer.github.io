post_cb({"bq_ids": {"n4140": {"so_21065642_21065709_0": {"length": 25, "quality": 0.8333333333333334, "section_id": 5436}}, "n3337": {"so_21065642_21065709_0": {"length": 25, "quality": 0.8333333333333334, "section_id": 5231}}, "n4659": {"so_21065642_21065709_0": {"length": 25, "quality": 0.8333333333333334, "section_id": 6863}}}, "21065709": {"Id": "21065709", "PostTypeId": "2", "Body": "<p>To help fix your confusion, the first thing you should know is that <strong>you have a double-pointer type</strong>.</p>\n<p>The next thing to say is that <code>volatile</code>-ness is part of a type just like <code>const</code>-ness is part of a type: together this fact is called <em>cv-qualification</em>.</p>\n<blockquote>\n<p id=\"so_21065642_21065709_0\"><code>[C++11: 7.1.6.1/7]:</code> <em>[ Note:</em> <code>volatile</code> is a hint to the implementation to avoid aggressive optimization involving the object because the value of the object might be changed by means undetectable by an implementation. See 1.9 for detailed semantics. In general, the semantics of <code>volatile</code> are intended to be the same in C++ as they are\n  in C. _ \u2014 end note ]_</p>\n</blockquote>\n<p>The phrase <code>volatile *</code> isn't any one specific thing: it is <em>two</em> tokens within the type that could mean a number of things.</p>\n<hr>\n<p>In this case, you have a <code>QThreadData* volatile*</code>, which is the \"pointer to volatile pointer to <code>QThreadData</code>\" type. Read it from right-to-left.</p>\n<p>If you stripped the <code>volatile</code> out, you'd be left with a <code>QThreadData**</code>.</p>\n<hr>\n<p>If you wanted a more simple example, here's two:</p>\n<pre><code>int volatile x = 5;\nvolatile int y = 6;\n</code></pre>\n<p>See, just like <code>const</code>, here we can play with the order of the <em>cv-qualifier</em> a little because there's no ambiguity.</p>\n<p>Let's step up the example a little:</p>\n<pre><code>int volatile* p = new int volatile(5);\n</code></pre>\n<p>Now we have a pointer to an <code>int volatile</code> (again, the same as a <code>volatile int</code>). The <code>volatile</code> applies left-wards; that is, to the <code>int</code>, not the <code>*</code>.</p>\n<p>But we could also have a volatile pointer! Let's say, a volatile pointer to a non-volatile int:</p>\n<pre><code>int* volatile p = new int(5);\n</code></pre>\n<hr>\n<p>And I have no idea what you mean by \"property\".</p>\n</hr></hr></hr>", "LastEditorUserId": "560648", "LastActivityDate": "2014-01-11T17:54:17.697", "Score": "6", "CreationDate": "2014-01-11T17:48:08.687", "ParentId": "21065642", "CommentCount": "2", "OwnerUserId": "560648", "LastEditDate": "2014-01-11T17:54:17.697"}, "21065642": {"ViewCount": "161", "Body": "<p>I stumbled upon something very strange in the c++ syntax. A <em>volatile</em>*  type.</p>\n<p>This is the code that I found (in the Qt-library):</p>\n<pre><code>void QCoreApplication::postEvent(QObject *receiver, QEvent *event, int priority)\n{\nif (receiver == 0) {\n    qWarning(\"\"QCoreApplication::postEvent: Unexpected null receiver\"\");\n    delete event;\n    return;\n}\n\nQThreadData * volatile * pdata = &amp;receiver-&gt;d_func()-&gt;threadData; \n// ^^^^^^^^^^^^^^^^^^^^^^^^^^^ WHAT IS THIS???\nQThreadData *data = *pdata;\nif (!data) {\n    // posting during destruction? just delete the event to prevent a leak\n    delete event;\n    return;\n}\n\n// [...]\n}\n</code></pre>\n<p><strong>What I understood form this:</strong></p>\n<ul>\n<li>I can't write <code>volatile * QThreadData * pdata</code>, because then I'd get a compiler error. That is obviously because objects cannot be <code>volatile *</code>, but pointers can.</li>\n<li><code>pdata</code> is not a <code>QThreadData *</code>, it has a <code>QThreadData * volatile *</code> type. In an attempt to compile this code: <code>int * volatile * x = new int(10);</code> I would get the following compiler error: <em>\"cannot convert 'int*' to 'int* volatile*' in initialization\"</em>.</li>\n</ul>\n<p><strong>So these are my questions:</strong></p>\n<ul>\n<li>What is the type <code>QThreadData * volatile *</code> and what is the meaning of <code>volatile *</code>?</li>\n<li>Why is <code>volatile *</code> a part of the <strong>type</strong>. Why isn't the type just <code>QThreadData *</code> with a <code>volatile *</code> property?</li>\n</ul>\n", "AcceptedAnswerId": "21065709", "Title": "What is type* volatile* name = value?", "CreationDate": "2014-01-11T17:44:05.077", "Id": "21065642", "CommentCount": "6", "LastEditDate": "2014-01-11T17:58:57.197", "PostTypeId": "1", "LastEditorUserId": "1931509", "LastActivityDate": "2014-01-11T18:01:11.353", "Score": "2", "OwnerUserId": "1931509", "Tags": "<c++><volatile>", "AnswerCount": "2"}, "21065680": {"Id": "21065680", "PostTypeId": "2", "Body": "<p>The declaration <code>QThreadData * volatile * pdata</code> means that <code>pdata</code> is a pointer to a volatile pointer to a <code>QThreadData</code>.  </p>\n<p>In general, <code>volatile</code> means that the object in can change in ways beyond the compiler's control.  For example, if it is stored in memory that is written to by other hardware.  This means that the compiler must read the value from memory every time that it is needed instead of making the assumption that if it has read the value before and it hasn't made a change to that memory location, that the value is still the same.</p>\n<p>So in this case, <code>pdata</code> itself is not volatile.  This means the compiler is allowed to assume that <code>pdata</code> won't change unexpectedly.  However, what <code>pdata</code> points to can change unexpectedly, and what it is pointing to is another pointer.  Furthermore, what that other volatile pointer is pointing to (the actual QThreadData) is not itself volatile.</p>\n<p>In C++, <code>const</code> and <code>volatile</code> are treated very similarly.  They both indicate that the object has some special property.  By requiring these properties to be carried along with the type, certain mistakes can be more easily avoided.  This is easier to see for <code>const</code>, but the same logic applies for <code>volatile</code>.  For example</p>\n<pre><code>void f(int *p)\n{\n    *p += 2;\n    *p += 3;\n}\n\nint main()\n{\n    volatile int a = 5;\n    f(&amp;a); // error: can't convert volatile int * to int *\n}\n</code></pre>\n<p>Since the function <code>f</code> is compiled separately from the function <code>main</code>, the compiler wouldn't know, when it is compiling the function <code>f</code>, that it should not assume that <code>*p</code> won't change unexpectedly.  Without this knowledge, it might change the code to effectively be</p>\n<pre><code>*p += 5;\n</code></pre>\n<p>but this would be wrong, since *p might change between the two additions.</p>\n", "LastEditorUserId": "951890", "LastActivityDate": "2014-01-11T18:01:11.353", "Score": "6", "CreationDate": "2014-01-11T17:46:04.293", "ParentId": "21065642", "CommentCount": "3", "OwnerUserId": "951890", "LastEditDate": "2014-01-11T18:01:11.353"}});