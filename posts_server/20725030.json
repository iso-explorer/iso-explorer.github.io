post_cb({"20730923": {"ParentId": "20725030", "CommentCount": "9", "Body": "<p>Having read relevant bits of both C++98 and C++11 [N3485], and all the stuff H2CO3 pointed to:</p>\n<p>Neither edition of the standard adequately describes what an \"invalid pointer\" is, under what circumstances they are created, or what their semantics are.  Therefore, it is unclear to me whether or not the OP's code was <em>intended</em> to provoke undefined behavior, but <em>de facto</em> it does (since anything that the standard does not clearly define is, tautologically, undefined).  The text is improved in C++11 but is still inadequate.</p>\n<p>As a matter of language design, the following program certainly does exhibit <em>unspecified</em> behavior as marked, which is fine. It <em>may, but should not</em> also exhibit undefined behavior as marked; in other words, <strong>to the extent that this program exhibits undefined behavior, that is IMNSHO a defect in the standard.</strong>  Concretely, copying the value of an \"invalid\" pointer, and performing equality comparisons on such pointers, <em>should not</em> be UB. I specifically reject the argument to the contrary from hypothetical hardware that traps on merely loading a pointer to unmapped memory into a register.  (Note: I cannot find text in C++11 corresponding to C11 6.5.2.3 footnote 95, regarding the legitimacy of writing one union member and reading another; this program assumes that the result of this operation is <em>unspecified</em> but not <em>undefined</em> (except insofar as it might involve a trap representation), as it is in C.)</p>\n<pre><code>#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n\nunion ptr {\n    int *val;\n    unsigned char repr[sizeof(int *)];\n};\n\nint main(void)\n{\n    ptr a, b, c, d, e;\n\n    a.val = new int(0);\n    b.val = a.val;\n    memcpy(c.repr, a.repr, sizeof(int *));\n\n    delete a.val;\n    d.val = a.val; // copy may, but should not, provoke UB\n    memcpy(e.repr, a.repr, sizeof(int *));\n\n    // accesses to b.val and d.val may, but should not, provoke UB\n    // result of comparison is unspecified (may, but should not, be undefined)\n    printf(\"b %c= d\\n\", b.val == d.val ? '=' : '!');\n\n    // result of comparison is unspecified\n    printf(\"c %c= e\\n\", memcmp(c.repr, e.repr, sizeof(int *)) ? '!' : '=');\n }\n</code></pre>\n<hr>\n<p>This is all of the relevant text from C++98:</p>\n<blockquote>\n<p id=\"so_20725030_20730923_0\">[3.7.3.2p4] If the argument given to a deallocation function in the standard library\n    is a pointer that is not the null pointer value (4.10), the deallocation function\n    shall deallocate the storage referenced by the pointer, rendering invalid all\n    pointers referring to any part of the <em>deallocated storage</em>. The effect of using\n    an invalid pointer value (including passing it to a deallocation function) is\n    undefined. [footnote: On some implementations, it causes a system-generated\n    runtime fault.]</p>\n</blockquote>\n<p>The problem is that there is no definition of \"using an invalid pointer value\", so we get to argue about what qualifies.  There is a clue to the committee's intent in the discussion of iterators (a category which is defined to include bare pointers):</p>\n<blockquote>\n<p id=\"so_20725030_20730923_1\">[24.1p5] ... Iterators can also have singular values that are not associated with any container. [<em>Example:</em> After the declaration of an uninitialized pointer <code>x</code> (as with <code>int* x;</code> [sic]), <code>x</code> must always be assumed to have a singular value of a pointer.] Results of most expressions are undefined for singular values; the only exception is an assignment of a non-singular value to an iterator that holds a singular value. In this case the singular value is overwritten the same way as any other value. Dereferenceable and past-the-end values are always non-singular.</p>\n</blockquote>\n<p>It seems at least <em>plausible</em> to assume that an \"invalid pointer\" is also meant to be an example of a \"singular iterator\", but there is no text to back this up; going in the opposite direction, there is no text confirming the (equally plausible) assumption that an uninitialized pointer value is meant to be an \"invalid pointer\" as well s a \"singular iterator\".  So the hair-splitters among us might not accept \"results of most expressions are undefined\" as clarifying what qualifies as <em>use</em> of an invalid pointer.</p>\n<p>C++11 has changed the text corresponding to 3.7.2.3p4 somewhat:</p>\n<blockquote>\n<p id=\"so_20725030_20730923_2\">[3.7.4.2p4] ... Indirection through an invalid pointer value and passing an invalid pointer value to a deallocation function have undefined behavior. Any other use of an\n  invalid pointer value has implementation-defined behavior. [footnote: Some implementations might define that copying an invalid pointer value causes a system-generated runtime fault.]</p>\n</blockquote>\n<p>(the text elided by the ellipsis is unchanged)  We now have somewhat more clarity as to what is meant by \"use of an invalid pointer value\", and we can now say that the OP's code's semantics are definitely implementation-defined (but might be implementation-defined to be undefined).  There is also a new paragraph in the discussion of iterators:</p>\n<blockquote>\n<p id=\"so_20725030_20730923_3\">[24.2.1p10] An <em>invalid</em> iterator is an iterator that may be singular.</p>\n</blockquote>\n<p>which confirms that \"invalid pointer\" and \"singular iterator\" are effectively the same thing.  The remaining confusion in C++11 is largely about the exact circumstances that <em>produce</em> invalid/singular pointers/iterators; there should be a detailed chart of pointer/iterator lifecycle transitions (like there is for *values).  And, as with C++98, the standard is defective to the extent it does not guarantee that copying-from and equality comparison upon such values are valid (not undefined).</p>\n</hr>", "OwnerUserId": "388520", "PostTypeId": "2", "Id": "20730923", "Score": "1", "CreationDate": "2013-12-22T15:26:34.643", "LastActivityDate": "2013-12-22T15:26:34.643"}, "20725046": {"ParentId": "20725030", "CommentCount": "15", "Body": "<blockquote>\n<p id=\"so_20725030_20725046_0\">As I understand, the deletecall should free up allocated memory from heap, but it shouldn't change the pointer address.</p>\n</blockquote>\n<p>Well, why not? It's perfectly legal output -- reading a pointer after having deleted it leads to undefined behavior. And that includes the pointer's value changing. (In fact, that doesn't even need UB; a <code>delete</code>d pointer can really point anywhere.)</p>\n", "Id": "20725046", "PostTypeId": "2", "OwnerDisplayName": "user529758", "Score": "5", "CreationDate": "2013-12-22T00:44:09.377", "LastActivityDate": "2013-12-22T00:44:09.377"}, "bq_ids": {"n4140": {"so_20725030_20730923_3": {"section_id": 5564, "quality": 0.6666666666666666, "length": 4}, "so_20725030_20730923_2": {"section_id": 7183, "quality": 0.8888888888888888, "length": 32}, "so_20725030_20730923_1": {"section_id": 5559, "quality": 0.86, "length": 43}, "so_20725030_20730923_0": {"section_id": 7183, "quality": 0.813953488372093, "length": 35}}, "n3337": {"so_20725030_20730923_3": {"section_id": 5346, "quality": 0.6666666666666666, "length": 4}, "so_20725030_20730923_1": {"section_id": 5341, "quality": 0.86, "length": 43}, "so_20725030_20730923_0": {"section_id": 6927, "quality": 0.8837209302325582, "length": 38}}, "n4659": {"so_20725030_20730923_3": {"section_id": 7011, "quality": 0.6666666666666666, "length": 4}, "so_20725030_20730923_2": {"section_id": 8671, "quality": 0.8611111111111112, "length": 31}, "so_20725030_20730923_1": {"section_id": 7006, "quality": 0.86, "length": 43}}}, "20725030": {"CommentCount": "2", "ViewCount": "375", "PostTypeId": "1", "LastEditorUserId": "4370109", "CreationDate": "2013-12-22T00:40:38.763", "LastActivityDate": "2015-08-27T16:18:18.867", "Title": "Address held by pointer changes after pointer is deleted", "LastEditDate": "2015-08-27T16:18:18.867", "Id": "20725030", "Score": "1", "Body": "<p>In the following code, why is the address held by pointer <code>x</code> changing after the <code>delete</code>? As I understand, the <code>delete</code>call should free up allocated memory from heap, but it shouldn't change the pointer address.</p>\n<pre><code>using namespace std;\n#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n\nint main()\n{\n    int* x = new int;\n    *x = 2;\n\n    cout &lt;&lt; x &lt;&lt; endl &lt;&lt; *x &lt;&lt; endl ;\n\n    delete x;\n\n    cout &lt;&lt; x &lt;&lt; endl;\n\n    system(\"Pause\");\n    return 0;\n}\n\nOUTPUT:\n01103ED8\n2\n00008123\n</code></pre>\n<p>Observations: I'm using Visual Studio 2013 and Windows 8. Reportedly this doesn't work the same in other compilers. Also, I understand this is bad practice and that I should just reassign the pointer to NULL after it's deletion, I'm simply trying to understand what is driving this weird behaviour.</p>\n", "Tags": "<c++><pointers><delete-operator>", "OwnerUserId": "2434460", "AnswerCount": "2"}});