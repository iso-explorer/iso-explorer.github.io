post_cb({"9201980": {"ParentId": "9201865", "CommentCount": "0", "Body": "<p>The <code>numeric_limits&lt;T&gt;</code> is a regular class template, it is not connected to the compiler in any special way as to find out about user-defined <code>enum</code> types. If you look at the <code>&lt;limits&gt;</code> file, it has the default template definition that returns zeros for everything, and a whole bunch of type-specific <em>specifications</em> for the individual types, returning the right constants.</p>\n<p>You can \"plug in\" your <code>enum</code> into <code>numeric_limits</code> by providing a specification of <code>numeric_limits&lt;test&gt;</code> by yourself. You can copy the one for <code>int</code> from the <code>&lt;limits&gt;</code>, and modify it to suit your needs.</p>\n", "OwnerUserId": "335858", "PostTypeId": "2", "Id": "9201980", "Score": "1", "CreationDate": "2012-02-08T21:45:10.607", "LastActivityDate": "2012-02-08T21:45:10.607"}, "9201963": {"ParentId": "9201865", "CommentCount": "0", "Body": "<p>For non-specialized versions of the template, <code>max</code> returns <code>T()</code>. You have not written a <code>numeric_limits</code> specialization for your <code>test</code> type, so you get the default implementation.</p>\n", "OwnerUserId": "33732", "PostTypeId": "2", "Id": "9201963", "Score": "2", "CreationDate": "2012-02-08T21:43:55.403", "LastActivityDate": "2012-02-08T21:43:55.403"}, "9201960": {"ParentId": "9201865", "CommentCount": "6", "Body": "<p><code>std::numeric_limits</code> is specialized in the Standard Library \"for each arithmetic type, both floating point and integer, including <code>bool</code>\" (\u00a718.3.2.1/2).</p>\n<p>Your enumeration <code>test</code> is not one of these types, so the primary template is used.  Its behavior is specified by \u00a718.3.2.3/1: \"The default <code>numeric_limits&lt;T&gt;</code> template shall have all members, but with <code>0</code> or <code>false</code> values.\"</p>\n<p>If you want to know the traits of the underlying type of <code>test</code>, you can use <code>underlying_type</code>:</p>\n<pre><code>std::numeric_limits&lt;std::underlying_type&lt;test&gt;::type&gt;::max()\n</code></pre>\n<p>Alternatively, you can specialize <code>numeric_limits</code> for <code>test</code> and have it return the values you want.  This is not a particularly good idea, though.</p>\n", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "9201960", "Score": "22", "CreationDate": "2012-02-08T21:43:42.560", "LastActivityDate": "2012-02-08T21:43:42.560"}, "9202027": {"ParentId": "9201865", "CommentCount": "2", "Body": "<p>From the C++11 draft:</p>\n<p>In 18.3.2.1, about <code>numeric_limits</code>:</p>\n<blockquote>\n<p id=\"so_9201865_9202027_0\">Non-arithmetic standard types, such as complex (26.4.2), shall not have specializations.</p>\n</blockquote>\n<p>And an enum is not an arithmetic standard type.</p>\n<p>Then, in the non-specialized template:</p>\n<pre><code>template&lt;class T&gt; class numeric_limits {\n    public:\n    [...]\n    static constexpr bool is_specialized = false;\n    static constexpr T max() noexcept { return T(); }\n};\n</code></pre>\n<p>That is, the non-specialized <code>max()</code> function returns the default initialized value for that type, that is 0.</p>\n", "OwnerUserId": "865874", "PostTypeId": "2", "Id": "9202027", "Score": "0", "CreationDate": "2012-02-08T21:49:03.317", "LastActivityDate": "2012-02-08T21:49:03.317"}, "bq_ids": {"n4140": {"so_9201865_9202027_0": {"section_id": 6716, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_9201865_9202027_0": {"section_id": 6471, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_9201865_9202027_0": {"section_id": 8211, "quality": 0.7142857142857143, "length": 5}}}, "9201865": {"CommentCount": "11", "AcceptedAnswerId": "9201960", "CreationDate": "2012-02-08T21:37:53.687", "LastActivityDate": "2012-02-08T21:49:03.317", "PostTypeId": "1", "ViewCount": "4138", "FavoriteCount": "2", "Title": "Why is C++ numeric_limits<enum_type>::max() == 0?", "Id": "9201865", "Score": "9", "Body": "<p>Here's a bit of code that might seem like it would work:</p>\n<pre><code>#include &lt;cassert&gt;\n#include &lt;limits&gt;\n\nenum test { A = 1 };\n\nint main()\n{\n    int max = std::numeric_limits&lt;test&gt;::max();\n    assert(max &gt; 0);\n}\n</code></pre>\n<p>But it fails under both GCC (4.6.2) and clang (2.9) on Linux: max() for enum types is in fact zero!  And this remains true even if you use the C++11 enum type specifier to explcitly say what type you want your enum to have.</p>\n<p>Why is this?  And as for the C++11 behavior, is it something explcitly called for?  I could find no mention of it in N2347, the paper on Strongly Typed Enums.</p>\n", "Tags": "<c++><enums><c++11><numeric-limits><strongly-typed-enum>", "OwnerUserId": "4323", "AnswerCount": "4"}});