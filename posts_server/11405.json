post_cb({"11703": {"ParentId": "11405", "CommentCount": "0", "Body": "<p>The main reason C++ cannot assume anything here is that the base template can be specialized for a type later. Continuing the original example:</p>\n<pre><code>template&lt;&gt;\nclass A&lt;int&gt; {};\n\nB&lt;int&gt; x; \nx.bar();//this will fail because there is no member foo in A&lt;int&gt;\n</code></pre>\n", "OwnerUserId": "852", "Id": "11703", "PostTypeId": "2", "OwnerDisplayName": "Matt Price", "Score": "8", "CreationDate": "2008-08-14T21:06:41.360", "LastActivityDate": "2008-08-14T21:06:41.360"}, "11435": {"CommentCount": "2", "CreationDate": "2008-08-14T18:09:55.413", "LastEditorUserId": "1277769", "LastActivityDate": "2015-12-15T20:14:47.277", "ParentId": "11405", "LastEditDate": "2015-12-15T20:14:47.277", "OwnerDisplayName": "Vincent Robert", "PostTypeId": "2", "Id": "11435", "Score": "33", "Body": "<p>David Joyner had the history, here is the reason.</p>\n<p>The problem when compiling <code>B&lt;T&gt;</code> is that its base class <code>A&lt;T&gt;</code> is unknown from the compiler, being a template class, so no way for the compiler to know any members from the base class.</p>\n<p>Earlier versions did some inference by actually parsing the base template class, but ISO C++ stated that this inference can lead to conflicts where there should not be.</p>\n<p>The solution to reference a base class member in a template is to use <code>this</code> (like you did) or specifically name the base class:</p>\n<pre><code>template &lt;typename T&gt; class A {\npublic:\n    T foo;\n};\n\ntemplate &lt;typename T&gt; class B: public A &lt;T&gt; {\npublic:\n    void bar() { cout &lt;&lt; A&lt;T&gt;::foo &lt;&lt; endl; }\n};\n</code></pre>\n<p>More information in <a href=\"http://gcc.gnu.org/onlinedocs/gcc-3.4.6/gcc/Name-lookup.html\" rel=\"nofollow noreferrer\">gcc manual</a>.</p>\n", "OwnerUserId": "268"}, "11414": {"CommentCount": "0", "CreationDate": "2008-08-14T17:50:24.750", "LastEditorUserId": "1146", "LastActivityDate": "2008-08-14T17:55:52.463", "ParentId": "11405", "PostTypeId": "2", "LastEditorDisplayName": "David Joyner", "LastEditDate": "2008-08-14T17:55:52.463", "Id": "11414", "Score": "10", "Body": "<p>This changed in <a href=\"http://gcc.gnu.org/gcc-3.4/changes.html#cplusplus\" rel=\"noreferrer\">gcc-3.4</a>.  The C++ parser got much more strict in that release -- per the spec but still kinda annoying for people with legacy or multi-platform code bases.</p>\n", "OwnerUserId": "1146", "OwnerDisplayName": "David Joyner"}, "11405": {"CommentCount": "1", "AcceptedAnswerId": "11414", "PostTypeId": "1", "LastEditorUserId": "1952879", "CreationDate": "2008-08-14T17:39:46.520", "LastActivityDate": "2017-03-18T19:06:13.300", "LastEditDate": "2017-03-18T19:06:13.300", "ViewCount": "6468", "FavoriteCount": "7", "Title": "GCC issue: using a member of a base class that depends on a template argument", "Id": "11405", "Score": "31", "Body": "<p>The following code doesn't compile with gcc, but does with Visual Studio:</p>\n<pre><code>template &lt;typename T&gt; class A {\npublic:\n    T foo;\n};\n\ntemplate &lt;typename T&gt; class B: public A &lt;T&gt; {\npublic:\n    void bar() { cout &lt;&lt; foo &lt;&lt; endl; }\n};\n</code></pre>\n<p>I get the error:</p>\n<blockquote>\n<p id=\"so_11405_11405_0\">test.cpp: In member function \u2018void B::bar()\u2019:</p>\n<p id=\"so_11405_11405_1\">test.cpp:11: error: \u2018foo\u2019 was not declared in this scope</p>\n</blockquote>\n<p>But it should be! If I change <code>bar</code> to</p>\n<pre><code>void bar() { cout &lt;&lt; this-&gt;foo &lt;&lt; endl; }\n</code></pre>\n<p>then it <em>does</em> compile, but I don't think I have to do this. Is there something in the official specs of C++ that GCC is following here, or is it just a quirk?</p>\n", "Tags": "<c++><templates><base-class><class-members><name-lookup>", "OwnerUserId": "112", "AnswerCount": "5"}, "212084": {"ParentId": "11405", "CommentCount": "0", "Body": "<p>VC doesn't implemented two-phase lookup, while GCC does. So GCC parses templates before they are instantiated and thus finds more errors than VC. \nIn your example, foo is a dependent name, since it depends on 'T'. Unless you tell the compiler where it comes from, it cannot check the validity of the template at all, before you instantiate it. \nThat's why you have to tell the compiler where it comes from. </p>\n", "OwnerUserId": "28906", "Id": "212084", "PostTypeId": "2", "OwnerDisplayName": "hschober", "Score": "3", "CreationDate": "2008-10-17T13:21:45.927", "LastActivityDate": "2008-10-17T13:21:45.927"}, "bq_ids": {"n4140": {"so_11405_11425_4": {"section_id": 190, "quality": 0.8823529411764706, "length": 15}, "so_11405_11425_3": {"section_id": 190, "quality": 0.84375, "length": 27}, "so_11405_11425_5": {"section_id": 190, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_11405_11425_4": {"section_id": 184, "quality": 0.8823529411764706, "length": 15}, "so_11405_11425_3": {"section_id": 184, "quality": 0.84375, "length": 27}, "so_11405_11425_5": {"section_id": 184, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_11405_11425_4": {"section_id": 195, "quality": 0.8823529411764706, "length": 15}, "so_11405_11425_3": {"section_id": 195, "quality": 0.6875, "length": 22}, "so_11405_11425_5": {"section_id": 195, "quality": 0.8571428571428571, "length": 6}}}, "11425": {"ParentId": "11405", "CommentCount": "0", "Body": "<p>Wow.  C++ never ceases to surprise me with its weirdness.</p>\n<blockquote>\n<p id=\"so_11405_11425_0\">In a template definition, unqualified names will no longer find members of a dependent base (as specified by [temp.dep]/3 in the C++ standard). For example,</p>\n</blockquote>\n<pre><code>template &lt;typename T&gt; struct B {\n  int m;\n  int n;\n  int f ();\n  int g ();\n};\nint n;\nint g ();\ntemplate &lt;typename T&gt; struct C : B&lt;T&gt; {\n  void h ()\n  {\n    m = 0; // error\n    f ();  // error\n    n = 0; // ::n is modified\n    g ();  // ::g is called\n  }\n};\n</code></pre>\n<blockquote>\n<p id=\"so_11405_11425_1\">You must make the names dependent, e.g. by prefixing them with this-&gt;. Here is the corrected definition of C::h,</p>\n</blockquote>\n<pre><code>template &lt;typename T&gt; void C&lt;T&gt;::h ()\n{\n  this-&gt;m = 0;\n  this-&gt;f ();\n  this-&gt;n = 0\n  this-&gt;g ();\n}\n</code></pre>\n<blockquote>\n<p id=\"so_11405_11425_2\">As an alternative solution (unfortunately not backwards compatible with GCC 3.3), you may use using declarations instead of this-&gt;:</p>\n</blockquote>\n<pre><code>template &lt;typename T&gt; struct C : B&lt;T&gt; {\n  using B&lt;T&gt;::m;\n  using B&lt;T&gt;::f;\n  using B&lt;T&gt;::n;\n  using B&lt;T&gt;::g;\n  void h ()\n  {\n    m = 0;\n    f ();\n    n = 0;\n    g ();\n  }\n};\n</code></pre>\n<p>That's just all kinds of crazy.  Thanks, David.</p>\n<p>Here's the \"temp.dep/3\" section of the standard [ISO/IEC 14882:2003] that they are referring to:</p>\n<blockquote>\n<p id=\"so_11405_11425_3\">In the definition of a class template or a member of a class template, if a base class of the class template depends on a template-parameter, the base class scope is not examined during unqualified name lookup either at the point of definition of the class template or member or during an instantiation of the class template or member. [Example: </p>\n</blockquote>\n<pre><code>typedef double A; \ntemplate&lt;class T&gt; class B { \n    typedef int A; \n}; \ntemplate&lt;class T&gt; struct X : B&lt;T&gt; { \n    A a; // a has typedouble \n}; \n</code></pre>\n<blockquote>\n<p id=\"so_11405_11425_4\">The type name <code>A</code> in the definition of <code>X&lt;T&gt;</code> binds to the typedef name defined in the global namespace scope, not to the typedef name defined in the base class <code>B&lt;T&gt;</code>. ] [Example: </p>\n</blockquote>\n<pre><code>struct A { \n    struct B { /* ... */ }; \n    int a; \n    int Y; \n}; \nint a; \ntemplate&lt;class T&gt; struct Y : T { \n    struct B { /* ... */ }; \n    B b; //The B defined in Y \n    void f(int i) { a = i; } // ::a \n    Y* p; // Y&lt;T&gt; \n}; \nY&lt;A&gt; ya; \n</code></pre>\n<blockquote>\n<p id=\"so_11405_11425_5\">The members <code>A::B</code>, <code>A::a</code>, and <code>A::Y</code> of the template argument <code>A</code> do not affect the binding of names in <code>Y&lt;A&gt;</code>. ] </p>\n</blockquote>\n", "OwnerUserId": "872", "Id": "11425", "PostTypeId": "2", "OwnerDisplayName": "Derek Park", "Score": "18", "CreationDate": "2008-08-14T18:05:09.510", "LastActivityDate": "2008-08-14T18:05:09.510"}});