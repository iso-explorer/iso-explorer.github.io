post_cb({"29611071": {"ParentId": "29610318", "PostTypeId": "2", "CommentCount": "7", "Body": "<blockquote>\n<p id=\"so_29610318_29611071_0\">What is the return type of a lambda expression if an item of a vector is returned?</p>\n</blockquote>\n<p>That's the wrong question.</p>\n<p>You should be asking what is the return type of a lambda expression <em>if it is not specified explicitly?</em>.</p>\n<p>The answer is given in C++11 5.1.2 [expr.prim.lambda] paragraph 5, where it says if the lambda has no <code>return expr;</code> statement it returns <code>void</code>, otherwise:</p>\n<blockquote>\n<p id=\"so_29610318_29611071_1\">the type of the returned expression after lvalue-to-rvalue conversion (4.1), array-to-pointer conversion (4.2), and function-to-pointer conversion (4.3);</p>\n</blockquote>\n<p><sub>(See T.C.'s comment below for DR 1048 which changed this rule slightly, and compilers actually implement the changed rule, but it doesn't matter in this case.)</sub></p>\n<p>lvalue-to-rvalue conversion means that if the return statement returns an lvalue like <code>v[i]</code> it decays to an rvalue, i.e. it returns just <code>int</code> by value.</p>\n<p>So the problem with your code is that the lambda returns a temporary, but the <code>std::function&lt;const int&amp;(int)&gt;</code> that wraps it binds a reference to that temporary. When you try to print out the value the temporary has aalready gone away (it was bound to an object a stack frame that no longer exists) so you have undefined behaviour.</p>\n<p>The fix is to use <code>std::function&lt;int(int)&gt;</code> or ensure the lambda returns a valid reference, not an rvalue.</p>\n<p>In C++14 non-lambdas can also use return type deduction, e.g.:</p>\n<pre><code>auto f(std::vector&lt;int&gt;&amp; v, int i) { return v[i]; }\n</code></pre>\n<p>This follows similar (but not identical) rules to the C++11 rules for lambdas, so the return type is <code>int</code>. To return a reference you need to use:</p>\n<pre><code>decltype(auto) f(std::vector&lt;int&gt;&amp; v, int i) { return v[i]; }\n</code></pre>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2015-04-13T17:15:31.457", "Id": "29611071", "Score": "12", "CreationDate": "2015-04-13T17:08:08.197", "LastActivityDate": "2015-04-13T17:15:31.457"}, "29610318": {"CommentCount": "10", "ViewCount": "2160", "PostTypeId": "1", "LastEditorUserId": "4649980", "CreationDate": "2015-04-13T16:25:18.680", "LastActivityDate": "2015-04-13T17:15:31.457", "Title": "What is the return type of a lambda expression if an item of a vector is returned?", "FavoriteCount": "2", "LastEditDate": "2015-04-13T16:30:54.307", "Id": "29610318", "Score": "27", "Body": "<p>Consider the following snippet: </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;functional&gt;\n\nint main() \n{\n    std::vector&lt;int&gt;v = {0,1,2,3,4,5,6};\n    std::function&lt;const int&amp;(int)&gt; f = [&amp;v](int i) { return v[i];}; \n    std::function&lt;const int&amp;(int)&gt; g = [&amp;v](int i) -&gt; const int&amp; { return v[i];};\n\n    std::cout &lt;&lt; f(3) &lt;&lt; ' ' &lt;&lt; g(3) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>I was expecting the same result: in <code>f</code>, <code>v</code> is passed by const reference, so <code>v[i]</code> should have <code>const int&amp;</code> type.</p>\n<p>However, I get the result </p>\n<pre><code> 0 3\n</code></pre>\n<p>If I do not use std::function, everything is fine:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;functional&gt;\n\nint main() \n{\n    std::vector&lt;int&gt;v = {0,1,2,3,4,5,6};\n    auto f = [&amp;v](int i) { return v[i];}; \n    auto g = [&amp;v](int i) -&gt; const int&amp; { return v[i];};\n\n    std::cout &lt;&lt; f(3) &lt;&lt; ' ' &lt;&lt; g(3) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>output:</p>\n<pre><code>3 3\n</code></pre>\n<p>Thus I'm wondering:</p>\n<ol>\n<li><p>In the second snippet, what is the return type of the lambda expression <code>f</code>? Is <code>f</code> the same as <code>g</code>?</p></li>\n<li><p>In the first snippet, what happened when the <code>std::function f</code> was constructed, causing the error? </p></li>\n</ol>\n", "Tags": "<c++><c++11><lambda><std-function><return-type-deduction>", "OwnerUserId": "4040558", "AnswerCount": "3"}, "29610653": {"ParentId": "29610318", "PostTypeId": "2", "CommentCount": "3", "Body": "<ol>\n<li><p>I assume the first lambda might return <code>int</code> or <code>int&amp;</code>\u00b9. Not <code>const int&amp;</code> as the reference <code>v</code> is not to a const object (it doesn't matter that the capture itself is not mutable, since that's the reference itself)</p></li>\n<li><p>Life times of temporaries get extended to the end of the enclosing scope when bound to a const-ref</p></li>\n</ol>\n<hr>\n<p>\u00b9 I'll try to dive into that later. For now, I'm going with regular deduction intuition and say that <code>auto</code> would decuce <code>int</code>, whereas <code>auto&amp;</code> would deduce <code>int&amp;</code>, so I expect that the actual return type is <code>int</code>. If anyone beats me to it, all the better. I won't have time for a few hours</p>\n<p>See the test supplied by @milleniumbug: <strong><kbd><a href=\"http://coliru.stacked-crooked.com/a/0309c80c364fc0cf\" rel=\"nofollow\">Live On Coliru</a></kbd></strong></p>\n</hr>", "OwnerUserId": "85371", "LastEditorUserId": "85371", "LastEditDate": "2015-04-13T16:52:22.423", "Id": "29610653", "Score": "5", "CreationDate": "2015-04-13T16:44:36.230", "LastActivityDate": "2015-04-13T16:52:22.423"}, "bq_ids": {"n4140": {"so_29610318_29611071_1": {"section_id": 0, "quality": 0.6, "length": 6}}, "n3337": {"so_29610318_29611071_1": {"section_id": 5732, "quality": 1.0, "length": 10}}, "n4659": {"so_29610318_29611071_1": {"section_id": 7667, "quality": 0.7, "length": 7}}}, "29610896": {"ParentId": "29610318", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The return type of a lambda uses the <code>auto</code> return type deduction rules, which strips the referenceness. (Originally it used a slightly different set of rules based on lvalue-to-rvalue conversion (which also removed the reference), but that was changed by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1048\">a DR</a>.)</p>\n<p>Hence, <code>[&amp;v](int i) { return v[i];};</code> returns <code>int</code>. As a result, in <code>std::function&lt;const int&amp;(int)&gt; f = [&amp;v](int i) { return v[i];};</code>, calling <code>f()</code> returns a dangling reference. Binding a reference to a temporary extends the lifetime of the temporary, but in this case the binding happened deep inside <code>std::function</code>'s machinery, so by the time <code>f()</code> returns, the temporary is gone already.</p>\n<p><code>g(3)</code> is fine because the <code>const int &amp;</code> returned is bound directly to the vector element <code>v[i]</code>, so the reference is never dangling.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2015-04-13T17:15:06.160", "Id": "29610896", "Score": "17", "CreationDate": "2015-04-13T16:57:19.747", "LastActivityDate": "2015-04-13T17:15:06.160"}});