post_cb({"31496161": {"ParentId": "31493761", "CommentCount": "0", "Body": "<p>Ultimately, there are a lot of details in this question that aren't relevant. We can reduce it to asking about the validity of:</p>\n<pre><code>struct A {\n    something_unmovable m;\n\n    void operator()() {\n        delete this;\n        // do something with m\n    }\n};\n</code></pre>\n<p>And ask about that behavior. After all, the impact of the <code>resize()</code> is to call the destructor of the object mid-function-call. Whether it's moved-from or copied-from by <code>std::vector</code> doesn't matter - either way it will subsequently be destroyed.</p>\n<p>The standard tells us in [class.cdtor] that:</p>\n<blockquote>\n<p id=\"so_31493761_31496161_0\">For an object with a non-trivial\n  destructor, referring to any non-static member or base class of the object after the destructor finishes\n  execution results in undefined behavior.</p>\n</blockquote>\n<p>So if the destructor of <code>something_unmovable</code> is non-trivial (which would make the destructor of <code>A</code> -- or your lambda -- non-trivial), any reference to <code>m</code> after the destructor is called is undefined behavior. If <code>something_unmovable</code> <em>does</em> have a trivial destructor, then your code is perfectly acceptable. If you <em>don't</em> do anything after the <code>delete this</code> (the <code>resize()</code> in your question), then it's perfectly valid behavior.</p>\n<blockquote>\n<p id=\"so_31493761_31496161_1\">Is m still accessible from the vector?</p>\n</blockquote>\n<p>Yes, the functor in <code>vec[0]</code> will still have <code>m</code> in it. It may be the original lambda - or it may be a copy of the original lambda. But there will be an <code>m</code> one way or the other. </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "31496161", "Score": "2", "CreationDate": "2015-07-18T22:26:07.227", "LastActivityDate": "2015-07-18T22:26:07.227"}, "31493873": {"ParentId": "31493761", "CommentCount": "7", "Body": "<p>Function objects are normally copyable, so your lambda would continue to run without ill effect. If it captures by reference AFAIR the internal implementation will use std::reference_wrapper so that the lambda remains copyable.</p>\n", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "31493873", "Score": "-1", "CreationDate": "2015-07-18T17:49:41.990", "LastActivityDate": "2015-07-18T17:49:41.990"}, "31493832": {"ParentId": "31493761", "LastEditDate": "2015-07-18T20:23:04.913", "CommentCount": "5", "CreationDate": "2015-07-18T17:46:09.103", "OwnerUserId": "368519", "LastEditorUserId": "368519", "PostTypeId": "2", "Id": "31493832", "Score": "4", "Body": "<p>You can treat lambda captures like ordinary struct instances.</p>\n<p>In your case:</p>\n<pre><code>struct lambda_UUID_HERE_stuff\n{\n    std::vector&lt;std::function&lt;void()&gt;&gt; &amp;vec;\n    something_unmovable m;\n\n    void operator()()\n    {\n        this-&gt;vec.resize(100);\n    }\n};\n</code></pre>\n<p>...and I believe all the same rules apply (as far as VS2013 is concerned).</p>\n<p>So, this appears to be another case of undefined behavior. That is, if <code>&amp;vec</code> happens to point to the vector containing the capture instance, and the operations within <code>operator()</code> cause that vector to resize.</p>\n", "LastActivityDate": "2015-07-18T20:23:04.913"}, "31493761": {"CommentCount": "2", "ViewCount": "595", "LastActivityDate": "2015-07-18T22:26:07.227", "Body": "<p>Consider:</p>\n<pre><code>std::vector&lt;std::function&lt;void()&gt;&gt; vec;\nsomething_unmovable m;\nvec.push_back([&amp;vec, m]() {\n    vec.resize(100);\n    // things with 'm'\n});\nvec[0]();\n</code></pre>\n<p><code>vec.resize(100)</code> will probably cause a re-allocation of the vector, which means that the <code>std::function</code>s will be copied to a new location, and the old ones destroyed. Yet this happens while the old one is still running. This particular code runs because the lambda doesn't do anything, but I imagine this can easily result in undefined behavior.</p>\n<p>So, what happens exactly? Is <code>m</code> still accessible from the vector? Or is it that the <code>this</code> pointer of the lambda is now invalid (points to freed memory), so nothing the lambda captures can be accessible, yet if it runs code that doesn't use anything it captures, it's not undefined behavior?</p>\n<p>Also, is the case where the lambda is movable any different?</p>\n", "PostTypeId": "1", "AcceptedAnswerId": "31494697", "FavoriteCount": "2", "Title": "What happens if a lambda is moved/destructed while it is running?", "Id": "31493761", "Score": "14", "CreationDate": "2015-07-18T17:38:12.150", "Tags": "<c++><c++11><lambda><undefined-behavior>", "OwnerUserId": "15055", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_31493761_31496161_0": {"section_id": 444, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_31493761_31496161_0": {"section_id": 435, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_31493761_31496161_0": {"section_id": 467, "quality": 0.9411764705882353, "length": 16}}}, "31494697": {"ParentId": "31493761", "LastEditDate": "2015-07-18T19:35:15.603", "CommentCount": "0", "CreationDate": "2015-07-18T19:16:46.983", "OwnerUserId": "743382", "LastEditorUserId": "743382", "PostTypeId": "2", "Id": "31494697", "Score": "5", "Body": "<p>As already covered by other answers, lambdas are essentially syntactic sugar for easily creating types that provide a custom <code>operator()</code> implementation. This is why you can even write lambda invocations using an explicit reference to <code>operator()</code>, like so: <code>int main() { return [](){ return 0; }.operator()(); }</code>. The same rules for all non-static member functions also apply to lambda bodies.</p>\n<p>And those rules allow the object being destroyed while the member function is being executed, so long as the member function does not use <code>this</code> afterwards. Your example is an unusual one, the more common example is for a non-static member function executing <code>delete this;</code>. <a href=\"https://isocpp.org/wiki/faq/freestore-mgmt#delete-this\" rel=\"nofollow\">This made it into the C++ FAQ</a>, explaining that it's allowed.</p>\n<p>The standard allows this by not really addressing it, as far as I am aware. It describes the semantics of member functions in a way that doesn't rely on the object not being destroyed, so implementations must make sure to let member functions continue executing even if the objects get destroyed.</p>\n<p>So to answer your questions:</p>\n<blockquote>\n<p id=\"so_31493761_31494697_0\">Or is it that the this pointer of the lambda is now invalid (points to freed memory), so nothing the lambda captures can be accessible, yet if it runs code that doesn't use anything it captures, it's not undefined behavior?</p>\n</blockquote>\n<p>Yes, pretty much.</p>\n<blockquote>\n<p id=\"so_31493761_31494697_1\">Also, is the case where the lambda is movable any different?</p>\n</blockquote>\n<p>No, it's not.</p>\n<p>The only time where the lambda being movable could possibly matter is after the lambda has been moved. In your example, the <code>operator()</code> continues executing on the original moved-from and then destroyed functor.</p>\n", "LastActivityDate": "2015-07-18T19:35:15.603"}});