post_cb({"11259465": {"ParentId": "11223285", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Take the following example:</p>\n<pre><code>struct X\n{\n    X(int);\n    X(const X&amp;);\n};\n\nint foo(X x){/*Do stuff*/ return 1; }\nX x(1);\nfoo(x);\n</code></pre>\n<p>In the compilers I tested, the argument to <code>foo</code> was always copied even with full optimization turned on. From this, we can gather that copies <em>will not/must not</em> be eliminated in all situations.</p>\n<p>Now lets think from a language design perspective, imagine all the scenarios you would have to think about if you wanted to make rules for when a copy is needed and when it isn't. This would be very difficult. Also, even if you were able to come up with rules, they would be very complex and almost impossible for people to comprehend. However, at the same time, if you forced copies everywhere, that would be very inefficient. This is why the rules are the way they are, you make the rules comprehensible for people to understand while still not forcing copies to be made if they can be avoided.</p>\n<p>I have to admit now, this answer is very similar to Suma's answer. The idea is that you can expect the behavior with the current rules, and anything else would be too hard for people to follow.</p>\n", "OwnerUserId": "906773", "LastEditorUserId": "906773", "LastEditDate": "2012-06-29T09:46:02.817", "Id": "11259465", "Score": "1", "CreationDate": "2012-06-29T09:40:11.040", "LastActivityDate": "2012-06-29T09:46:02.817"}, "17140173": {"ParentId": "11223285", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Initialization of built-in types like:</p>\n<pre><code>int i = 2;\n</code></pre>\n<p>is very natural syntax, in part due to historical reasons (remember your high school math). It is more natural than:</p>\n<pre><code>int i(2);\n</code></pre>\n<p>even if some mathematicians may argue this point. After all, there is nothing unnatural in calling a function (a constructor in this case) and passing it an argument. </p>\n<p>For built-in types these two types of initialization are identical. There is no extra copy in the former case.\nThat is the reason for having both types of initialization and originally there was no specific intention to make them behave differently.</p>\n<p>However, there are user-defined types and one of the stated goals of the language is to allow them to behave as built-in types as closely as possible.</p>\n<p>Thus, copy construction (taking input from some conversion function, for example) is the natural implementation of the first syntax.</p>\n<p>The fact that you may have extra copies and that they may be elided is an optimization for user-defined types. Both copy elision and explicit constructors came much later into the language. It is not surprising that standard allows optimizations after a certain period of use. Also, now you can eliminate explicit constructors from the overload resolution candidates.</p>\n", "OwnerUserId": "153380", "LastEditorUserId": "153380", "LastEditDate": "2013-06-17T16:03:29.953", "Id": "17140173", "Score": "0", "CreationDate": "2013-06-17T03:51:46.237", "LastActivityDate": "2013-06-17T16:03:29.953"}, "11224124": {"ParentId": "11223285", "CommentCount": "3", "Body": "<p>Only a speculation, but I am afraid it will be hard to be more certain without Bjarne Stroustrup confirming how it really was:</p>\n<p>It was designed this way because it was assumed such behaviour will be expected by the programmer, that he will expect the copy to be done when = sign is used, and not done with the direct initializer syntax.</p>\n<p>I think the possible copy elision was only added in later versions of the standard, but I am not sure - this is something somebody may be able to tell certainly by checking the standard history.</p>\n", "OwnerUserId": "16673", "PostTypeId": "2", "Id": "11224124", "Score": "4", "CreationDate": "2012-06-27T10:27:09.853", "LastActivityDate": "2012-06-27T10:27:09.853"}, "11223285": {"CommentCount": "9", "ViewCount": "1570", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-06-27T09:37:16.060", "LastActivityDate": "2013-06-17T16:03:29.953", "Title": "What's the motivation behind having copy and direct initialization behave differently?", "FavoriteCount": "12", "LastEditDate": "2017-05-23T11:59:39.500", "Id": "11223285", "Score": "42", "Body": "<p>Somewhat related to <a href=\"https://stackoverflow.com/questions/11222076/why-is-copy-constructor-called-instead-of-conversion-constructor\">Why is copy constructor called instead of conversion constructor?</a> </p>\n<p>There are two syntaxes for initialization, direct- and copy-initialization:</p>\n<pre><code>A a(b);\nA a = b;\n</code></pre>\n<p>I want to know the motivation for them having different defined behavior. For copy initialization, an extra copy is involved, and I can't think of any purpose for that copy. Since it's a copy from a temp, it can and probably will be optimized out, so the user can't rely on it happening - ergo the extra copy itself isn't reason enough for the different behavior. So... why?</p>\n", "Tags": "<c++><initialization><history><language-design>", "OwnerUserId": "673730", "AnswerCount": "4"}, "11223647": {"ParentId": "11223285", "PostTypeId": "2", "CommentCount": "9", "Body": "<blockquote>\n<p id=\"so_11223285_11223647_0\">Since it's a copy from a temp, it can and <strong>probably</strong> will be optimized out</p>\n</blockquote>\n<p>The keyword here is <em>probably</em>. The standard allows, but does not require, a compiler to optimize the copy away. If some compilers allowed this code (optimized), but others rejected it (non-optimized), this would be very inconsistent. </p>\n<p>So the standard prescribes a consistent way of handling this - everyone must check that the copy constructor is accessible, whether they then use it or not.</p>\n<p>The idea is that all compilers should either accept the code or reject it. Otherwise it will be non-portable.</p>\n<hr>\n<p>Another example, consider</p>\n<pre><code>A a;\nB b;\n\nA a1 = a;\nA a2 = b;\n</code></pre>\n<p>It would be equally inconsistent to allow <code>a2</code> but forbid <code>a1</code> when <code>A</code>s copy constructor is private. </p>\n<hr>\n<p>We can also see from the Standard text that the two methods of initializing a class object were intended to be different (8.5/16):</p>\n<blockquote>\n<p id=\"so_11223285_11223647_1\">If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified version of the source type is the same class as, or a derived class of, the class of the destination, constructors are considered. The applicable constructors are enumerated (13.3.1.3), and the best one is chosen through overload resolution (13.3). The constructor so selected is called to initialize the object, with the initializer expression or <em>expression-list</em> as its argument(s). If no constructor applies, or the overload resolution is ambiguous, the initialization is ill-formed.</p>\n<p id=\"so_11223285_11223647_2\">Otherwise (i.e., for the remaining copy-initialization cases), user-defined conversion sequences that can convert from the source type to the destination type or (when a conversion function is used) to a derived class thereof are enumerated as described in 13.3.1.4, and the best one is chosen through overload resolution (13.3). If the conversion cannot be done or is ambiguous, the initialization is ill-formed. The function selected is called with the initializer expression as its argument; if the function is a constructor, the call initializes a temporary of the cv-unqualified version of the destination type. The temporary is a prvalue. The result of the call (which is the temporary for the constructor case) is then used to direct-initialize, according to the rules above, the object that is the destination of the copy-initialization. In certain cases, an implementation is permitted to eliminate the copying inherent in this direct-initialization by constructing the intermediate result directly into the object being initialized; see 12.2, 12.8.</p>\n</blockquote>\n<p>A difference is that the direct-initialization uses the constructors of the constructed class directly. With copy-initialization, other conversion functions are considered and these may produce a temporary that has to be copied.</p>\n</hr></hr>", "OwnerUserId": "597607", "LastEditorUserId": "597607", "LastEditDate": "2012-06-27T10:48:55.160", "Id": "11223647", "Score": "3", "CreationDate": "2012-06-27T09:59:14.440", "LastActivityDate": "2012-06-27T10:48:55.160"}, "bq_ids": {"n4140": {"so_11223285_11223647_1": {"section_id": 3296, "quality": 0.9111111111111111, "length": 41}, "so_11223285_11223647_2": {"section_id": 3296, "quality": 0.9204545454545454, "length": 81}}, "n3337": {"so_11223285_11223647_1": {"section_id": 3166, "quality": 0.9111111111111111, "length": 41}, "so_11223285_11223647_2": {"section_id": 3166, "quality": 0.9204545454545454, "length": 81}}, "n4659": {"so_11223285_11223647_1": {"section_id": 4058, "quality": 0.9111111111111111, "length": 41}, "so_11223285_11223647_2": {"section_id": 4058, "quality": 0.6818181818181818, "length": 60}}}});