post_cb({"9223441": {"ViewCount": "264", "Body": "<p>Follow-up question to <a href=\"https://stackoverflow.com/q/9223153/500104\">this one</a>.</p>\n<p>Basically, in the following code, why does the compiler think that the <code>B</code> inside <code>A&lt;B&gt;</code> in <code>C</code>s constructor refer to the (inaccessible) constructor of the <code>B</code> base class?</p>\n<pre><code>struct B{};\n\ntemplate &lt;typename T&gt;\nstruct A : private T{};\n\nstruct C : public A&lt;B&gt;{                                                                             \n    C(A&lt;B&gt;);   // ERROR HERE\n};\n</code></pre>\n<p><a href=\"http://ideone.com/qgVQ5\" rel=\"nofollow noreferrer\">Live example on Ideone.</a> Output:</p>\n<blockquote>\n<p id=\"so_9223441_9223441_0\">prog.cpp:1:9: error: 'struct B B::B' is inaccessible<br>\n  prog.cpp:7:7: error: within this context</br></p>\n</blockquote>\n<p>Note that the same error pops up if you change the constructor argument to <code>A&lt;B*&gt;</code>, <code>A&lt;B&amp;&gt;</code> or even <code>A&lt;const B&gt;</code>. Also note that three of MSVC10, GCC 4.7 and Clang 3.1 ToT will error out, so it must be something in the C++ spec. <strong>What is it?</strong></p>\n", "AcceptedAnswerId": "9223678", "Title": "Why does the compiler select the base class constructor inside the template argument list?", "CreationDate": "2012-02-10T06:01:50.057", "Id": "9223441", "CommentCount": "7", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:48:00.473", "LastEditorUserId": "-1", "LastActivityDate": "2012-07-08T14:09:05.443", "Score": "13", "OwnerUserId": "500104", "Tags": "<c++><templates><scope><c++11><base-class>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_9223441_9223678_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 6677}}, "n3337": {"so_9223441_9223678_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 6432}}, "n4659": {"so_9223441_9223678_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 8152}}}, "9223678": {"Id": "9223678", "PostTypeId": "2", "Body": "<p>The standard allows injected class names to be less accessible than the original names. This is even mentioned in a note in \u00a711.1/5, together with an example:</p>\n<blockquote>\n<p id=\"so_9223441_9223678_0\">[ <em>Note:</em> In a derived class, the lookup of a base class name will\n  find the injected-class-name instead of the name of the base class in\n  the scope in which it was declared. The injected-class-name might be\n  less accessible than the name of the base class in the scope in which\n  it was declared. <em>\u2014end note</em> ]</p>\n<p id=\"so_9223441_9223678_1\">[ <em>Example</em>:</p>\n<pre><code>class A { };\nclass B : private A { };\nclass C : public B {\n  A *p; // error: injected-class-name A is inaccessible\n  ::A *q; // OK\n};\n</code></pre>\n<p id=\"so_9223441_9223678_2\">\u2014<em>end example</em> ]</p>\n</blockquote>\n<p>Accessing <code>A</code> unqualified uses the injected name, which is not accessible because it comes from private inheritance. Accessing <code>A</code> qualified uses the declared name, which is accessible in the global scope.</p>\n", "LastEditorUserId": "141719", "LastActivityDate": "2012-07-08T14:09:05.443", "Score": "15", "CreationDate": "2012-02-10T06:28:52.750", "ParentId": "9223441", "CommentCount": "0", "OwnerUserId": "46642", "LastEditDate": "2012-07-08T14:09:05.443"}});