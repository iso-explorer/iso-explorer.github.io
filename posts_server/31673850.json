post_cb({"37691151": {"Id": "37691151", "PostTypeId": "2", "Body": "<p>You can change the call sites to a form that works with both casts:</p>\n<pre><code>void* p = reinterpret_cast&lt;void*&amp;&gt;(v);\n            add this character  ^\n</code></pre>\n<p>This effectively treats 'v' as an object that holds a void*, which is true in both cases.  The automatic lvalue-to-rvalue conversion will insert a de-reference, extracting either the original size_t or the embedded size_t in Value.</p>\n<p>This code is equivalent to:</p>\n<pre><code>void* p = *reinterpret_cast&lt;void**&gt;(&amp;v);\n</code></pre>\n<p>However there is no way to get reinterpret_cast to call a custom operator on your object; the point of reinterpret_cast is that it's completely invisible.</p>\n", "LastEditorUserId": "4688119", "LastActivityDate": "2016-06-08T03:19:12.487", "Score": "0", "CreationDate": "2016-06-07T23:41:21.460", "ParentId": "31673850", "CommentCount": "1", "OwnerUserId": "6437704", "LastEditDate": "2016-06-08T03:19:12.487"}, "31674764": {"Id": "31674764", "PostTypeId": "2", "Body": "<p>C++ language doesn't allow overrides for <code>reinterpret_cast</code>. See <a href=\"https://stackoverflow.com/questions/5975002/overloading-c-typecasting-functions\">Overloading c++ typecasting (functions)</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-28T11:18:45.400", "Score": "0", "CreationDate": "2015-07-28T11:18:45.400", "ParentId": "31673850", "CommentCount": "0", "OwnerUserId": "241013", "LastEditDate": "2017-05-23T12:17:00.903"}, "31674621": {"Id": "31674621", "PostTypeId": "2", "Body": "<p>Unfortunately, <code>reinterpret_cast</code> is not designed for this. The reason this works for POD types is #3 on the <a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast\" rel=\"nofollow\">cppreference website</a>:</p>\n<blockquote>\n<p id=\"so_31673850_31674621_0\">A value of any integral or enumeration type can be converted to a pointer type. A pointer converted to an integer of sufficient size and back to the same pointer type is guaranteed to have its original value, otherwise the resulting pointer cannot be dereferenced safely (the round-trip conversion in the opposite direction is not guaranteed; the same pointer may have multiple integer representations) The null pointer constant NULL or integer zero is not guaranteed to yield the null pointer value of the target type; static_cast or implicit conversion should be used for this purpose.</p>\n</blockquote>\n<p>And, I believe \u00a712.3.2 plays a role here:</p>\n<blockquote>\n<p id=\"so_31673850_31674621_1\">A conversion function is never used to convert a (possibly cv-qualified) object to the (possibly cv-qualified) same object type (or a reference to it), to a (possibly cv-qualified) base class of that type (or a reference to it), or to (possibly cv-qualified) <strong>void</strong>.</p>\n</blockquote>\n<p><strong>In short</strong>: User-defined conversions do not participate in resolution of <code>reinterpret_casts</code>.</p>\n<p><strong>Possible solutions</strong></p>\n<p><strong>1.</strong> Explicitly take the address of v:</p>\n<pre><code> void* p=reinterpret_cast&lt;void*&gt;(&amp;v);\n</code></pre>\n<p><strong>2.</strong> Defined <code>operator void*()</code> as you did, you could write</p>\n<pre><code>void *p = v;\n</code></pre>\n<p><em>Note</em>: This probably opens up a wormhole of problems due to unwanted implicit conversions</p>\n<p><strong>3.</strong> Use <code>static_cast</code> as you said yourself.</p>\n<p><em>Note</em>: use <code>&amp;v</code> rather than defining <code>operator void*()</code> for the same reason as in No. 2</p>\n<p><strong>4.</strong> Ideally, but probably unrealistic, fix the underlying design issue requiring casting classes to void</p>\n<p>No. 3 might be the least painful solution here.</p>\n<p><strong>EDIT for comment</strong></p>\n<p>There are two ways here:</p>\n<p><strong>1.</strong> Use an overloaded address-of operator (<code>operator&amp;</code>). This may not be possible depending on how <code>Value</code> is used.</p>\n<pre><code>#include &lt;cstdlib&gt;\n\nstruct Value\n{\n    size_t value;\n    void* operator &amp;() { return reinterpret_cast&lt;void*&gt;(value); }\n};\n\nint main()\n{\n    Value v;    \n    void* p=reinterpret_cast&lt;void*&gt;(&amp;v); // This is how the project uses it\n}\n</code></pre>\n<p><strong>2.</strong> Implement an operator <code>uintptr_t</code>. While this requires verbose double-casting, it transfers the conversion into the <code>Value</code> class, and <code>uintptr_t</code> is <a href=\"http://www.cplusplus.com/reference/cstdint/\" rel=\"nofollow\">guaranteed</a> to be able to hold a <code>void*</code>.</p>\n<pre><code>#include &lt;cstdlib&gt;\n\nstruct Value\n{\n    size_t value;\n    operator uintptr_t() { return static_cast&lt;uintptr_t&gt;(value); }\n};\n\nint main()\n{\n    Value v;\n    void* p=reinterpret_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(v)); // This is how the project uses it\n    // or less verbose\n    void* p2=reinterpret_cast&lt;void*&gt;(uintptr_t(v)); \n\n}\n</code></pre>\n", "LastEditorUserId": "1641845", "LastActivityDate": "2015-07-28T12:05:09.940", "Score": "3", "CreationDate": "2015-07-28T11:12:53.093", "ParentId": "31673850", "CommentCount": "2", "OwnerUserId": "1641845", "LastEditDate": "2015-07-28T12:05:09.940"}, "31676368": {"Id": "31676368", "PostTypeId": "2", "Body": "<p>1) Replace all such casts with helper functions like:</p>\n<pre><code>template &lt;class T&gt;\nvoid* integer_to_voidptr(T t)\n{\n    return reinterpret_cast&lt;void*&gt;(t);\n}\n\ntemplate &lt;class T&gt;\nT voidptr_to_integer(void* p)\n{\n    return reinterpret_cast&lt;T&gt;(p);\n}\n</code></pre>\n<p>2) Add non-template overloads or specialize the templates for your POD.</p>\n", "LastActivityDate": "2015-07-28T12:29:23.073", "CommentCount": "0", "CreationDate": "2015-07-28T12:29:23.073", "ParentId": "31673850", "Score": "0", "OwnerUserId": "454519"}, "31673850": {"ViewCount": "201", "Body": "<p>I'm trying to replace a type, <code>typedef</code>'ed from a built-in integral type, used in a large project with a custom class, which would implement some additional functionality like avoiding truncation on assignment etc. But the project extensively uses a conversion like <code>reinterpret_cast&lt;void*&gt;(value)</code>. I've done a naive attempt at implementing an <code>operator void*()</code> in my new class, but apparently this doesn't make it possible to <code>reinterpret_cast</code>, only allows to <code>static_cast</code> to <code>void*</code>. Here's the code:</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;type_traits&gt;\n\n#define USE_NEW_VALUE_TYPE\n#ifdef USE_NEW_VALUE_TYPE\nstruct Value\n{\n    size_t value;\n    operator void* () { return reinterpret_cast&lt;void*&gt;(value); }\n};\nstatic_assert(std::is_pod&lt;Value&gt;::value,\"Value is not POD\");\n#else\ntypedef size_t Value;\n#endif\n\nint main()\n{\n    Value v{5};\n    void* p=reinterpret_cast&lt;void*&gt;(v); // This is how the project uses it\n}\n</code></pre>\n<p>I thought that if the class is POD, this would allow me to do such things like a <code>reinterpret_cast</code>. But this code gives me a compilation error:</p>\n<blockquote>\n<p id=\"so_31673850_31673850_0\">invalid cast from type \u2018Value\u2019 to type \u2018void*\u2019</p>\n</blockquote>\n<p>So my question is then: how do I add support for such a <code>reinterpret_cast</code>, so that I didn't have to manually switch it to <code>static_cast</code> in every part of the project?</p>\n", "AcceptedAnswerId": "31674621", "Title": "How can a POD type add support for reinterpret_cast'ing it?", "CreationDate": "2015-07-28T10:35:16.783", "Id": "31673850", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-06-08T03:19:12.487", "Score": "2", "OwnerUserId": "673852", "Tags": "<c++><reinterpret-cast>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_31673850_31673850_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 300}, "so_31673850_31674621_1": {"length": 22, "quality": 1.0, "section_id": 391}}, "n3337": {"so_31673850_31673850_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 291}, "so_31673850_31674621_1": {"length": 22, "quality": 1.0, "section_id": 382}}, "n4659": {"so_31673850_31673850_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 307}, "so_31673850_31674621_1": {"length": 22, "quality": 1.0, "section_id": 408}}}});