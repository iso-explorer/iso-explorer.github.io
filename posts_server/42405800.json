post_cb({"42406650": {"ParentId": "42405800", "CommentCount": "0", "Body": "<p><code>std::numeric_limits&lt;float&gt;::lowest()</code> will equal the negative of <code>std::numeric_limits&lt;float&gt;::max()</code> if the floating point representation uses a <a href=\"https://en.wikipedia.org/wiki/Signed_number_representations#Signed_magnitude_representation\" rel=\"nofollow noreferrer\">signed magnitude</a>, as the max and lowest values will have identical significand (ignoring the sign bit) and exponent, with both containing their maximum values. The sign bit will then determine whether the number is positive or negative, and will not affect its magnitude. (Another concequence of this is that the underlying representation will be able to represent both positive and negative zero.) IEEE 754 uses signed magnitude representation, so this is what you are most likely to encounter in practice.</p>\n<p>However, an alternative representation is to use a <a href=\"https://en.wikipedia.org/wiki/Two%27s_complement\" rel=\"nofollow noreferrer\">two's complement</a> significand. A property of two's complement is that the maximal negative value has a greater magnitude than the maximal positive value, and so for a floating point representation using a two's complement significand, <code>std::numeric_limits&lt;float&gt;::lowest()</code> will <em>not</em> equal the negative of <code>std::numeric_limits&lt;float&gt;::max()</code>. An example of a real system using a two's complement significand floating point format is the <a href=\"https://en.wikipedia.org/wiki/IBM_1130#Extended_Precision\" rel=\"nofollow noreferrer\">IBM 1130</a>, circa 1970.</p>\n<p>Now, <a href=\"http://en.cppreference.com/w/cpp/types/numeric_limits/lowest\" rel=\"nofollow noreferrer\">cppreference.com</a> does state:</p>\n<blockquote>\n<p id=\"so_42405800_42406650_0\">While it's not true for fundamental C++ floating-poing types, a third-party floating-point type T may exist such that <code>std::numeric_limits&lt;T&gt;::lowest() != -std::numeric_limits&lt;T&gt;::max()</code>.</p>\n</blockquote>\n<p>But I'm not sure what the basis of that statement is, as the C++11 standard, paragraph 18.3.2.4, merely specifies that <code>lowest()</code> is:</p>\n<blockquote>\n<p id=\"so_42405800_42406650_1\">A finite value <code>x</code> such that there is no other finite value <code>y</code> where <code>y &lt; x</code>.</p>\n<p id=\"so_42405800_42406650_2\">Meaningful for all specializations in which <code>is_bounded != false</code>.</p>\n</blockquote>\n<p>It also notes in a footnote:</p>\n<blockquote>\n<p id=\"so_42405800_42406650_3\"><code>lowest()</code> is necessary because not all floating-point representations have a smallest (most negative) value that is the\n  negative of the largest (most positive) finite value.</p>\n</blockquote>\n<p>So it would seem that a two's complement floating point representation could be used by a C++ implementation, and that would have <code>std::numeric_limits&lt;float&gt;::lowest()</code> not equal to the negative of <code>std::numeric_limits&lt;float&gt;::max()</code>.</p>\n", "OwnerUserId": "6635521", "PostTypeId": "2", "Id": "42406650", "Score": "2", "CreationDate": "2017-02-23T03:48:26.407", "LastActivityDate": "2017-02-23T03:48:26.407"}, "bq_ids": {"n4140": {"so_42405800_42406650_2": {"section_id": 6721, "quality": 1.0, "length": 5}, "so_42405800_42406650_1": {"section_id": 6724, "quality": 1.0, "length": 8}, "so_42405800_42406650_3": {"section_id": 6724, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_42405800_42406650_2": {"section_id": 6476, "quality": 1.0, "length": 5}, "so_42405800_42406650_1": {"section_id": 6479, "quality": 1.0, "length": 8}, "so_42405800_42406650_3": {"section_id": 6479, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_42405800_42406650_2": {"section_id": 8215, "quality": 1.0, "length": 5}, "so_42405800_42406650_1": {"section_id": 8218, "quality": 1.0, "length": 8}, "so_42405800_42406650_3": {"section_id": 8218, "quality": 0.9411764705882353, "length": 16}}}, "42405800": {"CommentCount": "0", "ViewCount": "57", "CreationDate": "2017-02-23T02:10:31.987", "LastActivityDate": "2017-02-23T03:48:26.407", "Title": "Numeric Limits of Float Lowest and Max", "AcceptedAnswerId": "42406650", "PostTypeId": "1", "Id": "42405800", "Score": "1", "Body": "<p>In what real case does c++ <code>std::numeric_limits&lt;float&gt;::lowest()</code> <strong>not</strong> equal the <em>negative</em> of <code>std::numeric_limits&lt;float&gt;::max()</code>?</p>\n", "Tags": "<c++>", "OwnerUserId": "4670", "AnswerCount": "1"}});