post_cb({"18605049": {"ParentId": "18599614", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_18599614_18605049_0\">the pointer variable 'a' and the 4-integer block pointed to by 'a'</p>\n</blockquote>\n<p>First, we need to clear up a basic misconception here.  <code>a</code> is <em>not</em> a separate pointer variable distinct from the 4-element array; <code>a</code> <em>is</em> the 4-element array.  The address of <code>a</code> and the address of <code>a[0]</code> are the same thing.  Under most circumstances, the <em>expression</em> <code>a</code> is converted from type \"4-element array of <code>int</code>\" to \"pointer to <code>int</code>\", and the <em>value</em> of the expression is the address of the first element in the array.  </p>\n<p>To answer the question, since <code>a</code> was declared within a block and without the <code>static</code> keyword, it has <em>automatic storage duration</em>, meaning that the memory occupied by the array is released when you leave the enclosing scope (in this case, the body of the function).  </p>\n", "OwnerUserId": "134554", "PostTypeId": "2", "Id": "18605049", "Score": "0", "CreationDate": "2013-09-04T03:44:36.740", "LastActivityDate": "2013-09-04T03:44:36.740"}, "18599644": {"ParentId": "18599614", "CommentCount": "0", "Body": "<p>In C, an automatic object like <code>a</code> is discarded at the exit of the block where it has been declared.</p>\n", "OwnerUserId": "1119701", "PostTypeId": "2", "Id": "18599644", "Score": "0", "CreationDate": "2013-09-03T19:04:44.547", "LastActivityDate": "2013-09-03T19:04:44.547"}, "18599933": {"ParentId": "18599614", "LastEditDate": "2013-09-06T14:21:10.920", "CommentCount": "0", "CreationDate": "2013-09-03T19:24:35.567", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "PostTypeId": "2", "Id": "18599933", "Score": "3", "Body": "<p><code>a</code> is not a static variable it is an <code>automatic</code> variable, from the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"nofollow\">draft C99 standard</a> section <code>6.2.4</code> <em>Storage durations of objects paragraph 4</em> says:</p>\n<blockquote>\n<p id=\"so_18599614_18599933_0\">An object whose identifier is declared with no linkage and without the storage-class\n  specifier static has automatic storage duration.</p>\n</blockquote>\n<p>In <em>paragraphs 3</em> it describes the lifetime of <code>static</code> as the lifetime of the program and in <em>paragraph 5</em> says:</p>\n<blockquote>\n<p id=\"so_18599614_18599933_1\">For such an object that does not have a variable length array type, its lifetime extends\n  from entry into the block with which it is associated until execution of that block ends in\n  any way. [...]</p>\n</blockquote>\n<p>So in other words for an automatic variable it's lifetime extends to it's scope, in this case <code>a</code>s scope is the function <code>PrintArray</code> and the storage associated with it is released after that scope is exited.</p>\n<p>For C++ the relevant section from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft standard</a> is <code>3.7.3</code> <em>Automatic storage duration paragraph 1</em> says:</p>\n<blockquote>\n<p id=\"so_18599614_18599933_2\">Block-scope variables explicitly declared register or not explicitly declared static or extern have automatic storage duration. The storage for these entities lasts until the block in which they are created exits.</p>\n</blockquote>\n", "LastActivityDate": "2013-09-06T14:21:10.920"}, "18599712": {"ParentId": "18599614", "LastEditDate": "2013-09-03T20:58:18.603", "CommentCount": "1", "CreationDate": "2013-09-03T19:10:19.920", "OwnerUserId": "390906", "LastEditorUserId": "1342470", "PostTypeId": "2", "Id": "18599712", "Score": "1", "Body": "<p>The memory does not leak.  It is not allocated on the heap.  Now, there is likely 2 different memory locations involved here.  </p>\n<ol>\n<li>The location where the <code>{ 4,3,1,5 }</code> initializer is stored.  Typically initializers like this are stored in the data segment.  In an embedded system this could be read-only flash.  On a PC or whatever though, this is going to just be a RAM area that is initialized with your program image (eg. EXE) and isn't modified.  After the function exits, it is still there.  But it is not a leak -- just a part of your program's memory footprint (some might say static memory).</li>\n<li>The stack memory allocated for <code>a[]</code> in <code>PrintArray()</code> function scope.  What the compiler does is allocate some stack space and then copies the values at the beginning of the function from the data segment.  This is generally what takes place, so that if you modify any of the elements in <code>a[]</code>, it only effects that array for that particular function call.  When <code>PrintArray()</code> gets called again, the original initializer is unmodified and available for reuse.  It would be weird/unexpected if subsequent calls to <code>PrintArray()</code> initialized to something besides <code>{ 4,3,1,5 }</code> due to a previous invocation mutating the value.  However, you aren't modifying it here, so it's plausible that optimizations may not allocated anything on the stack.  YMMV.  Assuming <code>a[]</code> does reside on the stack, it will be deallocated automatically (hence <code>auto</code> variable) upon function exit.</li>\n</ol>\n<p>Of course, <em>exactly</em> what is taking place depends upon your compiler, linker, settings (especially optimizations), and target.</p>\n", "LastActivityDate": "2013-09-03T20:58:18.603"}, "18599614": {"CommentCount": "3", "ViewCount": "907", "PostTypeId": "1", "LastEditorUserId": "160811", "LastActivityDate": "2013-09-06T17:09:12.717", "Body": "<pre><code>void PrintArray()\n{\n  int a[4] = {4,3,1,5};\n  for(int i=0; i&lt;4; i++)\n    cout&lt;&lt;a[i];\n}\n</code></pre>\n<p>What Exactly happens to the memory allocated to the pointer variable 'a' and the 4-integer block pointed to by 'a' after this function's call is completed?\nDoes the memory of the block and pointer variable get de-allocated or does it create some sort of memory leak?</p>\n", "Title": "What happens to statically allocated memory after its scope ends?", "FavoriteCount": "1", "LastEditDate": "2013-09-06T17:09:12.717", "Id": "18599614", "Score": "3", "CreationDate": "2013-09-03T19:03:08.800", "Tags": "<c++><c><memory-management><dynamic-memory-allocation><static-memory-allocation>", "OwnerUserId": "2693920", "AnswerCount": "5"}, "18599738": {"ParentId": "18599614", "LastEditDate": "2017-05-23T12:28:10.737", "CommentCount": "0", "CreationDate": "2013-09-03T19:12:12.550", "OwnerUserId": "1935378", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "18599738", "Score": "2", "Body": "<p>Automatic variables are not static, they are disposed of at the end of their scope (at the end of the function). A static variable will persist, it will keep it's value, even if it's called in a function. Here's a link about <a href=\"https://stackoverflow.com/questions/1286515/extern-and-static-pointers-in-c\">extern/static variables</a> for further details.</p>\n", "LastActivityDate": "2013-09-03T19:23:23.543"}, "bq_ids": {"n4140": {"so_18599614_18599933_2": {"section_id": 7170, "quality": 0.9090909090909091, "length": 20}}, "n3337": {"so_18599614_18599933_2": {"section_id": 6914, "quality": 0.9090909090909091, "length": 20}}, "n4659": {"so_18599614_18599933_2": {"section_id": 8678, "quality": 0.7727272727272727, "length": 17}}}});