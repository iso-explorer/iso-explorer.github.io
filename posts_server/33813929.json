post_cb({"33813929": {"CommentCount": "2", "ViewCount": "247", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-11-19T20:38:34.503", "LastActivityDate": "2015-11-20T19:14:25.547", "Title": "Is an empty class usable as a constexpr variable without an intializer or explicit default constructor?", "LastEditDate": "2015-11-20T03:39:38.453", "Id": "33813929", "Score": "9", "Body": "<p>Given the following code:</p>\n<pre><code>struct f {\n};\n\nint main(){\n    constexpr f f1 ;\n    //const f f1  ; // This also has the same issue\n    //constexpr f f1 = {} ; //This works\n}\n</code></pre>\n<p>clang and gcc disagree over whether it is valid, with clang providing the following diagnostic (<em><a href=\"http://melpon.org/wandbox/permlink/phRBq2DeenTbBpYJ\" rel=\"nofollow noreferrer\">see it live</a></em>):</p>\n<pre><code>error: default initialization of an object of const type 'const f' without a user-provided default constructor\nconstexpr f f1 ;\n            ^\n              {}\n</code></pre>\n<p>As far as I can tell <code>f</code> is a literal type and it is initialized by the implicitly defaulted constructor which should allow it to be declared constexpr. Who is correct here?</p>\n<p>Note, clang does accept the  declaration of <code>f1</code> if I explicitly add a constexpr default constructor:</p>\n<pre><code>constexpr f() {} ;\n</code></pre>\n<p>Does the answer change is <code>f</code> is not an aggregate?</p>\n", "Tags": "<c++><c++11><language-lawyer><c++14><constexpr>", "OwnerUserId": "1708801", "AnswerCount": "1"}, "33813930": {"ParentId": "33813929", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>If we start from the draft C++14 standard section <code>7.1.5</code> <em>[dcl.constexpr]</em> we can find the requirements for a constexpr object declaration are:</p>\n<blockquote>\n<p id=\"so_33813929_33813930_0\">A constexpr specifier used in an object declaration declares the object as const. Such an object shall have\n  literal type and shall be initialized. If it is initialized by a constructor call, that call shall be a constant expression (5.19).</p>\n</blockquote>\n<p>So is <code>f</code> is a literal type?</p>\n<p>Section <code>3.9</code> <em>[basic.types]</em> says:</p>\n<blockquote>\n<p id=\"so_33813929_33813930_1\">A type is a literal type if it is:</p>\n</blockquote>\n<p>and covers classes in the following bullet:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_33813929_33813930_2\">a class type (Clause 9) that has all of the following properties</p>\n<ul>\n<li>it has a trivial destructor,</li>\n<li>it is an aggregate type (8.5.1) or has at least one constexpr constructor or constructor template\n  that is not a copy or move constructor, and</li>\n<li>all of its non-static data members and base classes are of non-volatile literal types.</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>So we are okay on the first and third bullet. To cover the second bullet, we could note that <code>f</code> is an <em>aggregate</em> but if we modify the example slightly, for example if <code>f</code> looked like this:</p>\n<pre><code>struct f {\n   private:\n      int x = 0 ;\n} ;\n</code></pre>\n<p>which would not be an aggregate in either C++11 or C++14 but the issue would still exist. Then we need to show it has a constexpr constructor. Does <code>f</code> have a constexpr constructor?</p>\n<p>As far as I can tell section <code>12.1</code> <em>[class.ctor]</em> says yes:</p>\n<blockquote>\n<p id=\"so_33813929_33813930_3\">[...] If that user-written default constructor would satisfy the requirements of a constexpr constructor (7.1.5),\n  the implicitly-defined default constructor is constexpr. [...]</p>\n</blockquote>\n<p>But we are unfortunately required to have a user-provided constructor by section <code>8.5</code> which says:</p>\n<blockquote>\n<p id=\"so_33813929_33813930_4\">If a program calls for the default initialization of an object of a const-qualified type T, T shall be a class type\n  with a user-provided default constructor.</p>\n</blockquote>\n<p>So it looks like clang is correct here and if we look at the following clang bug report: <a href=\"https://llvm.org/bugs/show_bug.cgi?id=23381\" rel=\"nofollow\">\"error: default initialization of an object of const type 'const Z' requires a user-provided default constructor\" even when no constructor needed</a>. So clang is basing their lack of support for this due to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#253\" rel=\"nofollow\">defect report 253</a> which does not currently have a proposed wording and it says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_33813929_33813930_5\">Paragraph 9 of 8.5 [dcl.init] says:</p>\n<blockquote>\n<p id=\"so_33813929_33813930_10\">If no initializer is specified for an object, and the object is of\n    (possibly cv-qualified) non-POD class type (or array thereof), the\n    object shall be default-initialized; <strong>if the object is of\n    const-qualified type, the underlying class type shall have a\n    user-declared default constructor</strong>. Otherwise, <strong>if no initializer is\n    specified for an object</strong>, the object and its subobjects, if any, have\n    an indeterminate initial value; if the object or any of its subobjects\n    are of const-qualified type, <strong>the program is ill-formed</strong>.</p>\n</blockquote>\n<p id=\"so_33813929_33813930_7\">What if a const POD object has no non-static data members? This wording requires an empty initializer for such cases</p>\n<p id=\"so_33813929_33813930_8\">[...]</p>\n<p id=\"so_33813929_33813930_9\">Similar comments apply to a non-POD const object, all of whose non-static data members and base class subobjects have default constructors. Why should the class of such an object be required to have a user-declared default constructor?</p>\n</blockquote>\n<p>The defect report is still open but the last comment on it says:</p>\n<blockquote>\n<p id=\"so_33813929_33813930_11\">If the implicit default constructor initializes all subobjects, no initializer should be required.</p>\n</blockquote>\n<p>and also notes:</p>\n<blockquote>\n<p id=\"so_33813929_33813930_12\">This issue should be brought up again in light of constexpr constructors and non-static data member initializers. </p>\n</blockquote>\n<p>Note the constraints on const qualified types moved around in section <code>8.5</code> since the defect report came about. This was due to proposal <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2762.htm\" rel=\"nofollow\">N2762: Not so Trivial Issues with Trivial</a> which was pre C++11.</p>\n<p>Although the defect report is still open, given the constexpr changes and non-static data member initializers it does not seem like a necessary restriction anymore. Especially considering the following requirement on a constexpr constructor:</p>\n<blockquote id=\"so_33813929_33813930_13\">\n<ul>\n<li>every non-variant non-static data member and base class sub-object shall be initialized (12.6.2);</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-11-20T19:14:25.547", "Id": "33813930", "Score": "7", "CreationDate": "2015-11-19T20:38:34.503", "LastActivityDate": "2015-11-20T19:14:25.547"}, "bq_ids": {"n4140": {"so_33813929_33813930_2": {"section_id": 7208, "quality": 1.0, "length": 6}, "so_33813929_33813930_0": {"section_id": 5425, "quality": 0.95, "length": 19}, "so_33813929_33813930_3": {"section_id": 370, "quality": 0.9230769230769231, "length": 12}, "so_33813929_33813930_4": {"section_id": 3286, "quality": 1.0, "length": 11}, "so_33813929_33813930_13": {"section_id": 5420, "quality": 0.9, "length": 9}}, "n3337": {"so_33813929_33813930_2": {"section_id": 6952, "quality": 1.0, "length": 6}, "so_33813929_33813930_0": {"section_id": 5220, "quality": 0.95, "length": 19}, "so_33813929_33813930_3": {"section_id": 360, "quality": 0.9230769230769231, "length": 12}, "so_33813929_33813930_4": {"section_id": 3156, "quality": 1.0, "length": 11}, "so_33813929_33813930_13": {"section_id": 5215, "quality": 0.8, "length": 8}}, "n4659": {"so_33813929_33813930_2": {"section_id": 8717, "quality": 1.0, "length": 6}, "so_33813929_33813930_0": {"section_id": 6847, "quality": 0.75, "length": 15}, "so_33813929_33813930_4": {"section_id": 382, "quality": 0.6363636363636364, "length": 7}, "so_33813929_33813930_3": {"section_id": 384, "quality": 0.9230769230769231, "length": 12}, "so_33813929_33813930_13": {"section_id": 6842, "quality": 0.9, "length": 9}}}});