post_cb({"46548590": {"ParentId": "46540499", "CommentCount": "0", "Body": "<p>If you want to go overkill, we can create a factory type that has a conversion operator:</p>\n<pre><code>template &lt;class... Args&gt;\nstruct list_init_from {\n    std::tuple&lt;Args...&gt; args;\n\n    template &lt;class T&gt;\n    operator T() {\n        return std::apply([](auto... args){\n            return T{args...};\n        }, args);\n    }   \n};\n\ntemplate &lt;class... Args&gt;\nlist_init_from(Args... ) -&gt; list_init_from&lt;Args...&gt;;\n</code></pre>\n<p>Which you can use:</p>\n<pre><code>std::variant&lt;x&gt; v(std::in_place_type&lt;x&gt;, list_init_from{3});\n</code></pre>\n<p>This works, but leaves much to be desired: perfect forwarding, SFINAE on the conversion operator, and explicitly specifying which types to allow conversions to are exercises left to the reader.</p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "46548590", "Score": "0", "CreationDate": "2017-10-03T15:47:12.217", "LastActivityDate": "2017-10-03T15:47:12.217"}, "bq_ids": {"n4659": {"so_46540499_46540683_1": {"section_id": 5029, "quality": 0.8888888888888888, "length": 8}, "so_46540499_46540683_0": {"section_id": 5029, "quality": 0.8888888888888888, "length": 8}}}, "46540682": {"ParentId": "46540499", "CommentCount": "2", "Body": "<p>Maybe it is not exactly what you are asking, but what about explicitly constructing the object instead of relying on type inference?</p>\n<pre><code>#include &lt;variant&gt;\n\nstruct x {\n  int y;\n};\n\nint main() {\n  std::variant&lt;x&gt; v(std::in_place_type&lt;x&gt;, x{3});\n  return std::get&lt;x&gt;(v).y;\n}\n</code></pre>\n", "OwnerUserId": "1485885", "PostTypeId": "2", "Id": "46540682", "Score": "3", "CreationDate": "2017-10-03T08:52:38.107", "LastActivityDate": "2017-10-03T08:52:38.107"}, "46540499": {"CommentCount": "2", "AcceptedAnswerId": "46540683", "LastEditDate": "2017-10-03T08:46:23.787", "LastEditorUserId": "1537925", "CreationDate": "2017-10-03T08:41:57.543", "LastActivityDate": "2017-10-03T15:47:12.217", "PostTypeId": "1", "ViewCount": "117", "Title": "Can I avoid explicitly writing a constructor for each struct in a std::variant?", "Id": "46540499", "OwnerUserId": "1537925", "Body": "<p>Consider this code:</p>\n<pre><code>#include &lt;variant&gt;\n\nstruct x {\n  int y;\n};\n\nint main() {\n  std::variant&lt;x&gt; v(std::in_place_type&lt;x&gt;, {3}); /*1*/\n  return std::get&lt;x&gt;(v).y;\n}\n</code></pre>\n<p>This does not compile and neither does when removing the <code>{}</code> from the line <code>/*1*/</code>, even though aggregate initialization</p>\n<pre><code>x a{3};\nx b({3});\n</code></pre>\n<p>works in both \"constructor-like\" forms. Can I somehow make the <code>std::variant</code> initializer aware of the possibility of constructing structs using aggregate initialization without having to write boring boilerplate constructors for each struct that may be used in my real-world case?</p>\n<p>I would expect this to work, somehow, as per <a href=\"http://en.cppreference.com/w/cpp/utility/variant/variant\" rel=\"noreferrer\">cppreference</a> the two overloads (5) and (6) in question both say</p>\n<blockquote>\n<p id=\"so_46540499_46540499_0\">Constructs a variant with the specified alternative T and <strong><em>initializes</em></strong> the contained value with the arguments <em>[...]</em></p>\n</blockquote>\n<p>I'm using GCC 7 if that matters.</p>\n", "Tags": "<c++><c++1z><variant><aggregate-initialization>", "Score": "6", "AnswerCount": "3"}, "46540683": {"ParentId": "46540499", "CommentCount": "0", "Body": "<p>There is no workaround for this, apart from adding a constructor. The standard mandates this for both overloads you mention, <a href=\"http://eel.is/c++draft/variant.ctor#19\" rel=\"nofollow noreferrer\">[variant.ctor]19</a> and <a href=\"http://eel.is/c++draft/variant.ctor#23\" rel=\"nofollow noreferrer\">[variant.ctor]23</a> respectively:</p>\n<blockquote>\n<p id=\"so_46540499_46540683_0\"><em>Effects</em>: Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with the arguments <code>std\u200b::\u200bforward&lt;Args&gt;(args)...</code>.</p>\n<p id=\"so_46540499_46540683_1\"><em>Effects</em>: Initializes the contained value as if direct-non-list-initializing an object of type <code>T</code> with the arguments <code>il, std\u200b::\u200bforward&lt;Args&gt;(args)...</code>.</p>\n</blockquote>\n<p>You can always copy or move the object using:</p>\n<pre><code>std::variant&lt;x&gt; v(std::in_place_type&lt;x&gt;, x{3});\n// or more clear and does the same thing\nstd::variant&lt;x&gt; v(x{3});\n</code></pre>\n", "OwnerUserId": "3980929", "PostTypeId": "2", "Id": "46540683", "Score": "1", "CreationDate": "2017-10-03T08:52:38.617", "LastActivityDate": "2017-10-03T08:52:38.617"}});