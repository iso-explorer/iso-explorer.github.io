post_cb({"bq_ids": {"n4140": {"so_43749115_43762955_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 175}, "so_43749115_43766415_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 175}}, "n3337": {"so_43749115_43762955_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 169}, "so_43749115_43766415_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 169}}, "n4659": {"so_43749115_43762955_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 180}, "so_43749115_43766415_1": {"length": 12, "quality": 1.0, "section_id": 180}}}, "43766415": {"Id": "43766415", "PostTypeId": "2", "Body": "<p>I had a bit of a code clean-up (got rid of the out-of-line <code>x_hidden</code> declaration) and ended up with the following. I also fixed it slightly based on @Yakk's answer above, to avoid <a href=\"http://eel.is/c++draft/temp.res#8\" rel=\"nofollow noreferrer\">[temp.res]/8</a> invalidating it.</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\n#include &lt;cassert&gt;\n\n#define ENABLE_IF(...) std::enable_if_t&lt;(__VA_ARGS__), int&gt; = 0\n\ntemplate&lt;class T, class Base, ENABLE_IF(std::is_same&lt;void(T::*)(), decltype(&amp;T::x)&gt;::value)&gt;\nauto has_x_f() -&gt; std::true_type;\n\ntemplate&lt;class T, class Base, ENABLE_IF(std::is_same&lt;void(Base::*)(), decltype(&amp;T::x)&gt;::value)&gt;\nauto has_x_f() -&gt; std::false_type;\n\ntemplate&lt;class T, class Base&gt;\nusing has_x = decltype(has_x_f&lt;T, Base&gt;());\n\ntemplate&lt;typename T&gt;\nstruct A\n{\n  void x() {}\n\n  static bool constexpr x_hidden() {\n      return has_x&lt;T, A&lt;T&gt;&gt;::value;\n  }\n\n  void y()\n  {\n      assert(x_hidden() == y_&lt;T&gt;(nullptr) );\n  }\n\n  void y2()\n  {\n      if constexpr(x_hidden()) {\n          typename T::BType i = 1;\n          (void)i;\n      } else {\n          typename T::CType i = 1;\n          (void)i;\n      }\n  }\n\n\nprivate:\n  template &lt;typename R, typename T2=T, ENABLE_IF(A&lt;T2&gt;::x_hidden())&gt;\n  static bool y_(R*)\n  {\n     std::cout &lt;&lt; \"x() is hidden\" &lt;&lt; std::endl;\n     return true;\n  }\n\n  template &lt;typename R, typename T2=T, ENABLE_IF(!A&lt;R&gt;::x_hidden())&gt;\n  static bool y_(T*)\n  {\n     std::cout &lt;&lt; \"x() is not hidden\" &lt;&lt; std::endl;\n     return false;\n  }\n};\n\nstruct B : A&lt;B&gt;\n{\n    void x() {}\n    using BType = int;\n};\n\nstatic_assert(std::is_same&lt;decltype(&amp;B::x), void(B::*)()&gt;::value, \"B::x is a member of B\");\n\nstruct C : A&lt;C&gt;\n{\n    using CType = int;\n};\n\nstatic_assert(std::is_same&lt;decltype(&amp;C::x), void(A&lt;C&gt;::*)()&gt;::value, \"C::x is a member of A&lt;C&gt;\");\n\nint main()\n{\n  B b;\n  C c;\n\n  std::cout &lt;&lt; \"B: \";\n  std::cout &lt;&lt; B::x_hidden() &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"C: \";\n  std::cout &lt;&lt; C::x_hidden() &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; \"B: \";\n  b.y();\n  b.y2();\n  std::cout &lt;&lt; \"C: \";\n  c.y();\n  c.y2();\n\n  return 0;\n}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/UJ3tKe6P7ODRfxLB\" rel=\"nofollow noreferrer\">Live demo on wandbox</a> -- gcc and clang are both happy with it.</p>\n<p><a href=\"http://webcompiler.cloudapp.net/\" rel=\"nofollow noreferrer\">MSVC 2017</a> complained</p>\n<blockquote>\n<p id=\"so_43749115_43766415_0\">error C2064: term does not evaluate to a function taking 0 arguments\n  for both uses of <code>A&lt;T2&gt;::x_hidden()</code>, when instantiating <code>A&lt;B&gt;</code> for <code>B</code> to inherit from.</p>\n</blockquote>\n<p><a href=\"http://rextester.com/IMXO52025\" rel=\"nofollow noreferrer\">MSVC 2015</a> gave the same complaint, and then suffered an Internal Compiler Error. ^_^</p>\n<p>So I think this is valid, but exercises MSVC's <code>constexpr</code> or template instantiation machinery in unpleasant ways.</p>\n<p>Per the example in <a href=\"http://eel.is/c++draft/expr.unary.op#3\" rel=\"nofollow noreferrer\">[expr.unary.op]/3</a>, the type of <code>&amp;B::x</code> is <code>void (B::*)()</code>, and the type of <code>&amp;C::x</code> is <code>void (A&lt;C&gt;::*)()</code>. So the first <code>has_x_f()</code> will be present when <code>T</code> is <code>B</code>, and the second <code>has_x_f()</code> will be present when <code>T</code> is <code>C</code> and <code>Base</code> is <code>A&lt;C&gt;</code>.</p>\n<p>Per <a href=\"http://eel.is/c++draft/temp.spec#temp.inst-2\" rel=\"nofollow noreferrer\">[temp.inst]/2</a>, instantiating the class instantiates declarations but not definitions of the members. Per <a href=\"http://eel.is/c++draft/temp.spec#temp.inst-3\" rel=\"nofollow noreferrer\">[temp.inst]/3 and 4</a>, member function definitions (including template functions) are not instantiated until required.</p>\n<p>Our declarations here are <em>currently</em> different, as the use of <code>R</code> and <code>T2</code> mean the compiler cannot determine the truth or falsehood of either size of the <code>&amp;&amp;</code>.</p>\n<p>The use of the different parameter types helps MSVC, which would otherwise see them as redefinitions of the same template member template function. My reading of <a href=\"http://eel.is/c++draft/temp.spec#temp.inst-2\" rel=\"nofollow noreferrer\">[temp.inst]/2</a> says this is not needed, as they're only redefintions when we instantiate them, and they cannot be instantiated at the same time. Because we use <code>A&lt;T2&gt;::x_hidden()</code> and <code>!A&lt;R&gt;::x_hidden()</code>, the compiler cannot know that they are mutually exclusive at this time. I don't think it's necessary to do that to avoid <a href=\"http://eel.is/c++draft/temp.res#8\" rel=\"nofollow noreferrer\">[temp.res]/8</a>, simply using <code>A&lt;R&gt;::x_hidden()</code> seems safe-enough to me. This was also to ensure that in the two templates, <code>R</code> as actually used.</p>\n<p>From there on, it's pretty easy. <code>y()</code> shows we have the right values coming from both paths.</p>\n<p>Depend on your use-case, you could use <code>if constexpr</code> with <code>x_hidden()</code> to avoid all the template magic in <code>y_()</code>, per <code>y2()</code> above.</p>\n<p>This avoids the issue with <a href=\"http://eel.is/c++draft/temp.res#8\" rel=\"nofollow noreferrer\">[temp.res]/8</a> described in @Yakk's answer, as the problematic clause <a href=\"http://eel.is/c++draft/temp.res#8.1\" rel=\"nofollow noreferrer\">[temp.res]/8.1</a> is that the template is ill-formed if</p>\n<blockquote>\n<p id=\"so_43749115_43766415_1\">no valid specialization can be generated for a template or a substatement of a constexpr if statement within a template and the template is not instantiated, [...]</p>\n</blockquote>\n<p>So as long as you instantiate <code>A&lt;T&gt;::y2()</code> for <em>some</em> <code>T</code>, then you're not subject to this clause.</p>\n<p>The <code>y2()</code> approach has the advantage of working with MSVC2017, as long as you pass in the \"/std:c++latest\" compiler flag.</p>\n", "LastActivityDate": "2017-05-03T17:22:32.020", "Score": "1", "CreationDate": "2017-05-03T17:22:32.020", "ParentId": "43749115", "CommentCount": "0", "OwnerUserId": "166389"}, "43764080": {"Id": "43764080", "PostTypeId": "2", "Body": "<p>I tried compiling your code with the Intel C++ compiler(icpc (ICC) 17.0.2 20170213), and it would not compile with the following message:</p>\n<pre><code>main.cpp(30): error: expression must have a constant value\n    template &lt;typename R, ENABLE_IF(std::is_same&lt;T, R&gt;::value &amp;&amp; !x_hidden)&gt;\n                          ^\n\n/home/com/gcc/6.2.0/bin/../include/c++/6.2.0/type_traits(2512): error: class \"std::enable_if&lt;&lt;error-constant&gt;, int&gt;\" has no member \"type\"\n      using enable_if_t = typename enable_if&lt;_Cond, _Tp&gt;::type;\n                                                          ^\n          detected during instantiation of type \"std::enable_if_t&lt;&lt;error-constant&gt;, int&gt;\" at line 30 of \"main.cpp\"\n\nmain.cpp(62): error: more than one instance of overloaded function \"B::y\" matches the argument list:\n            function template \"void A&lt;T&gt;::y(R) [with T=B]\"\n            function template \"void A&lt;T&gt;::y(R) [with T=B]\"\n            argument types are: (B)\n            object type is: B\n    b.y(b);\n</code></pre>\n<p>I was however able to compile the following with both the Intel compiler and GCC.</p>\n<pre><code>#include &lt;iostream&gt;\n\n#define ENABLE_IF(...) std::enable_if_t&lt;(__VA_ARGS__), int&gt; = 0\n\ntemplate&lt;class T, class B, ENABLE_IF(std::is_same&lt;void(T::*)(), decltype(&amp;T::x)&gt;::value)&gt;\nauto has_x_f(T*) -&gt; std::true_type;\n\ntemplate&lt;class T, class B&gt;\nauto has_x_f(B*) -&gt; std::false_type;\n\ntemplate&lt;class T, class B&gt;\nusing has_x = decltype(has_x_f&lt;T, B&gt;((T*)nullptr));\n\ntemplate&lt;class T&gt;\nclass A\n{\n   public:\n      T&amp; self() { return static_cast&lt;T&amp;&gt;(*this); }\n\n      void x() { }\n\n      template\n         &lt;  class TT = T\n         ,  typename std::enable_if&lt;has_x&lt;TT, A&lt;TT&gt; &gt;::value, int&gt;::type = 0\n         &gt;\n      void y()\n      {\n         std::cout &lt;&lt; \" have x hidden \" &lt;&lt; std::endl;\n         // if you are so inclined, you can call x() in a \"safe\" way\n         this-&gt;self().x(); // Calls x() from class \"Derived\" (Here class B)\n      }\n\n      template\n         &lt;  class TT = T\n         ,  typename std::enable_if&lt;!has_x&lt;TT, A&lt;TT&gt; &gt;::value, int&gt;::type = 0\n         &gt;\n      void y()\n      {\n         std::cout &lt;&lt; \" does not have x hidden \" &lt;&lt; std::endl;\n         // if you are so inclined, you can call x() in a \"safe\" way\n         this-&gt;self().x(); // Calls x() from class \"Base\" (Here class A)\n      }\n}; \n\nclass B : public A&lt;B&gt;\n{\n   public:\n      void x() { }\n}; \n\nclass C : public A&lt;C&gt;\n{\n};\n\n\nint main()\n{\n   B b;\n   C c;\n\n   b.y();\n   c.y();\n\n   return 0;\n}\n</code></pre>\n<p>I am not aware whether or not this is incorrect according to the standard however, but as I see it you do not run into the problem mentioned in one of the other answers, that you have a template that cannot be instantiated.</p>\n<hr>\n<p>EDIT: I was able to get to compile on MSVC 2017 by some \"old-times\" template metaprogramming tricks, and using classes instead of functions.\nIf I use this implementation of <code>has_x</code> instead it compiles:</p>\n<pre><code>template&lt;class T, bool&gt;\nstruct has_x_impl;\n\ntemplate&lt;class T&gt;\nstruct has_x_impl&lt;T, true&gt;: std::true_type\n{\n};\n\ntemplate&lt;class T&gt;\nstruct has_x_impl&lt;T, false&gt;: std::false_type\n{\n};\n\ntemplate&lt;class T&gt;\nusing has_x = has_x_impl&lt;T, std::is_same&lt;void(T::*)(), decltype(&amp;T::x)&gt;::value&gt;;\n</code></pre>\n<p>Full code on Wandbox <a href=\"https://wandbox.org/permlink/ZbPN7rJRvEgGkX61\" rel=\"nofollow noreferrer\">here</a>.</p>\n</hr>", "LastEditorUserId": "2964487", "LastActivityDate": "2017-05-03T20:59:34.330", "Score": "2", "CreationDate": "2017-05-03T15:18:13.307", "ParentId": "43749115", "CommentCount": "4", "LastEditDate": "2017-05-03T20:59:34.330", "OwnerUserId": "2964487"}, "43749115": {"ViewCount": "369", "Body": "<p>While trying to solve <a href=\"https://stackoverflow.com/questions/43746033/is-it-possible-to-tell-if-a-class-has-hidden-a-base-function-in-c\">Is it possible to tell if a class has hidden a base function in C++?</a>, I generated this:</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\n\n#define ENABLE_IF(...) std::enable_if_t&lt;(__VA_ARGS__), int&gt; = 0\n\ntemplate&lt;class T, class B, ENABLE_IF(std::is_same&lt;void(T::*)(), decltype(&amp;T::x)&gt;::value)&gt;\nauto has_x_f(T*) -&gt; std::true_type;\n\ntemplate&lt;class T, class B&gt;\nauto has_x_f(B*) -&gt; std::false_type;\n\ntemplate&lt;class T, class B&gt;\nusing has_x = decltype(has_x_f&lt;T, B&gt;((T*)nullptr));\n\ntemplate&lt;typename T&gt;\nstruct A\n{\n  void x() {}\n\n  static const bool x_hidden;\n\n  template &lt;typename R, ENABLE_IF(std::is_same&lt;T, R&gt;::value &amp;&amp; x_hidden)&gt;\n  void y(R value)\n  {\n     std::cout &lt;&lt; \"x() is hidden\" &lt;&lt; std::endl;\n  }\n\n  template &lt;typename R, ENABLE_IF(std::is_same&lt;T, R&gt;::value &amp;&amp; !x_hidden)&gt;\n  void y(R value)\n  {\n     std::cout &lt;&lt; \"x() is not hidden\" &lt;&lt; std::endl;\n  }\n\n  //using t = std::integral_constant&lt;bool, x_hidden&gt;;\n};\n\nstruct B : A&lt;B&gt;\n{\n    void x() {}\n};\n\nstruct C : A&lt;C&gt;\n{\n};\n\ntemplate&lt;typename T&gt;\nconst bool A&lt;T&gt;::x_hidden = has_x&lt;T, A&lt;T&gt;&gt;::value;\n\nint main()\n{\n  B b;\n  C c;\n\n  std::cout &lt;&lt; \"B: \";\n  std::cout &lt;&lt; b.x_hidden &lt;&lt; std::endl;\n  std::cout &lt;&lt; \"C: \";\n  std::cout &lt;&lt; c.x_hidden &lt;&lt; std::endl;\n\n  std::cout &lt;&lt; \"B: \";\n  b.y(b);\n  std::cout &lt;&lt; \"C: \";\n  c.y(c);\n\n  return 0;\n}\n</code></pre>\n<p>Which outputs what I want:</p>\n<pre>B: 1\nC: 0\nB: x() is hidden\nC: x() is not hidden</pre>\n<p><a href=\"http://rextester.com/VFKIT77798\" rel=\"nofollow noreferrer\">clang</a> and <a href=\"http://rextester.com/RBJD75979\" rel=\"nofollow noreferrer\">gcc</a> both compile and execute this \"correctly\", but <a href=\"http://rextester.com/IPREH96372\" rel=\"nofollow noreferrer\">vc++</a> doesn't (though I am aware that there are problems with it working properly with expressions similar to <code>template &lt;typename T&gt; ... decltype(fn(std::declval&lt;T&gt;().mfn()))</code>).</p>\n<p>So my question is, is this considered valid or will it break later on?  I'm also curious about the <code>x_hidden</code> being able to be used as a template parameter in the functions but not being able to use it in <code>using t = std::integral_constant&lt;bool, x_hidden&gt;</code>.  Is that just because the template's type isn't fully declared at this point?  If so, why did using it work for the function declarations?</p>\n", "AcceptedAnswerId": "43762955", "Title": "Is this considered valid c++11 or c++14? Or is gcc/clang getting it wrong?", "CreationDate": "2017-05-03T00:15:00.300", "Id": "43749115", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:34:27.447", "LastEditorUserId": "-1", "LastActivityDate": "2017-05-04T16:53:42.987", "Score": "8", "OwnerUserId": "1366368", "Tags": "<c++><c++11><c++14><language-lawyer>", "AnswerCount": "3"}, "43762955": {"Id": "43762955", "PostTypeId": "2", "Body": "<p>If <code>x_hidden</code> is false, there is no template arguements for which this template function</p>\n<pre><code>template &lt;typename R, ENABLE_IF(std::is_same&lt;T, R&gt;::value &amp;&amp; x_hidden)&gt;\nvoid y(R value) {\n  std::cout &lt;&lt; \"x() is hidden\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>can be instantiated, so your program is ill formed no diagnostic required.  This is a common hack, its illegality may be made clear or even legal at some point.</p>\n<p>There may be a reason for using <code>has_x_f</code> instead of just directly initializing <code>is_hidden</code> with the <code>is_same</code> clause, but it isn't demonstrated in your code.</p>\n<p>For any template specialization, there <strong>must</strong> be arguments which would make the instantiation valid.  If there are not, the program is ill-formed no diagnostic required.</p>\n<p>I believe this clause is in the standard to permit compilers to do more advanced checks on templates, but not require them.</p>\n<pre><code>template &lt;typename R, ENABLE_IF(std::is_same&lt;T, R&gt;::value &amp;&amp; x_hidden)&gt;\nvoid y(R value)\n{\n   std::cout &lt;&lt; \"x() is hidden\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>the compiler is free to notice <code>x_hidden</code> is <code>false</code>, and say \"it doesn't matter what <code>is_same&lt;T,R&gt;</code> is\", and deduce that <em>no template arguments could make this specialization valid</em>.  Then generate an error.</p>\n<p>An easy hack is</p>\n<pre><code>template &lt;class T2=T, class R,\n  ENABLE_IF(std::is_same&lt;T2, R&gt;::value &amp;&amp; has_x&lt;T2, A&lt;T2&gt;&gt;::value)\n&gt;\nvoid y(R value)\n{\n   std::cout &lt;&lt; \"x() is hidden\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>where we sneak another template argument in that equals <code>T</code> usually.  Now, the compiler has to admit the possibility that <code>T2</code> passes the <code>has_x</code> test, and that the passed argument is <code>R</code>.  Users can bypass this by manually passing the \"wrong\" <code>T2</code>.</p>\n<p>This may not solve everything.  The standard is a bit tricky to read here, but one reading states that if within the body of <code>y()</code> we go and assume that our <code>T</code> itself has <code>x()</code>, we still violate the rule of the possibility of a valid template instantiation.</p>\n<p>[temp.res] 14.6/8 (root and 1)</p>\n<blockquote>\n<p id=\"so_43749115_43762955_0\">Knowing which names are type names allows the syntax of every template to be checked. The program is ill-formed, no diagnostic required, if:</p>\n<ul>\n<li>no valid specialization can be generated for a template [...] and the template is not instantiated, or</li>\n</ul>\n</blockquote>\n<p>No valid specialization for</p>\n<pre><code>template &lt;typename R, ENABLE_IF(std::is_same&lt;T, R&gt;::value &amp;&amp; x_hidden)&gt;\nvoid y(R value)\n{\n  std::cout &lt;&lt; \"x() is hidden\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>can be generated if <code>x_hidden</code> is false.  The exitence of another overload is immaterial.</p>\n<p>If you fix it using the <code>T2</code> trick, the same rule holds <em>if the body assumes <code>T=T2</code></em>.</p>\n<p>Three are words in the standard that attempt to not cause the template to be instantiated in certain contexts, but I am unsure if that makes the above code well formed or not.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2017-05-04T16:53:42.987", "Score": "5", "CreationDate": "2017-05-03T14:29:32.780", "ParentId": "43749115", "CommentCount": "2", "LastEditDate": "2017-05-04T16:53:42.987", "OwnerUserId": "1774667"}});