post_cb({"bq_ids": {"n4140": {"so_40826618_40828823_0": {"length": 15, "quality": 1.0, "section_id": 269}}, "n3337": {"so_40826618_40828823_0": {"length": 15, "quality": 1.0, "section_id": 260}}, "n4659": {"so_40826618_40828823_0": {"length": 15, "quality": 1.0, "section_id": 276}}}, "40826618": {"ViewCount": "224", "Body": "<p>Suppose I am attempting to create my own implementation of boost::filesystem::path, using the <a href=\"https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern\" rel=\"nofollow noreferrer\">Curiously Recurring Template Pattern</a>:</p>\n<p>(Code is given incomplete for brevity, but will exhibit the problem as stated when compiled with '<code>g++ -std=c++11 -o mypath ./mypath.cpp</code>', using GCC 4.8.4)</p>\n<p><strong><em>mypath.hpp:</em></strong></p>\n<pre><code>#ifndef MYPATH_HPP\n#define MYPATH_HPP\n\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace my {\n\ntemplate &lt;class T&gt;\nclass PathBase\n{\npublic:\n  PathBase();\n  PathBase(std::string const&amp; p);\n\n  std::string String() const;\n\n  bool IsSeparator(char c) const;\n  std::string Separators() const;\n\n  typedef std::vector&lt;std::string&gt; pathvec;\n\nprotected:\n  pathvec _path;\n\nprivate:\n  virtual std::string _separators() const =0;\n};\n\n\nclass Path : public PathBase&lt;Path&gt;\n{\npublic:\n  Path();\n  Path(std::string const&amp; p);\n\nprivate:\n  virtual std::string _separators() const final;\n};\n\n} // namespace 'my'\n\n#endif // MYPATH_HPP\n</code></pre>\n<p><strong><em>mypath.cpp:</em></strong></p>\n<pre><code>#include \"mypath.hpp\"\n\nnamespace my {\n\n//////////template class PathBase&lt;Path&gt;;\n\ntemplate&lt;&gt;\nbool PathBase&lt;Path&gt;::IsSeparator(char c) const\n{\n  return (Separators().find(c) != std::string::npos);\n}\n\ntemplate &lt;&gt;\nstd::string PathBase&lt;Path&gt;::Separators() const\n{\n  return _separators();\n}\n\n} // namespace\n\nint main(int argc, char** argv)\n{\n  return 0;\n}\n</code></pre>\n<p>Of course I discovered that the code as-written will not compile, since I explicitly specialize <code>Separators()</code> after <code>IsSeparator()</code> has implicitly instantiated it.  But I don't particularly want to play whack-a-mole trying to keep all my methods favorably ordered.</p>\n<p>While researching similar questions on SO, I found that this <a href=\"https://stackoverflow.com/a/7774242/980793\">accepted answer</a> to one of them suggested that I could solve this problem neatly by merely declaring my specialization.   But...</p>\n<ol>\n<li>My commented-out <code>template class PathBase&lt;Path&gt;;</code> line in mypath.cpp had no effect on the problem, and</li>\n<li>It kinda feels like my header file already declares the explicit specialization with its entire <code>class Path : public PathBase&lt;Path&gt; { ... }</code> declaration. </li>\n</ol>\n<p><strong><em>Exactly what does my explicit declaration need to look like?</em></strong></p>\n", "AcceptedAnswerId": "40828823", "Title": "Declaration doesn't solve 'explicit specialization after instantiation' error", "CreationDate": "2016-11-27T07:14:25.340", "Id": "40826618", "CommentCount": "0", "LastEditDate": "2017-05-23T10:30:16.657", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2016-11-27T23:49:43.613", "Score": "3", "OwnerUserId": "980793", "Tags": "<c++><crtp><explicit-specialization><template-instantiation>", "AnswerCount": "1"}, "40828823": {"Id": "40828823", "PostTypeId": "2", "Body": "<p>Let's get these out of the way first:</p>\n<ol>\n<li><p><code>template class PathBase&lt;Path&gt;;</code> does not declare an explicit specialization; it is an <em>explicit instantiation definition</em>. You're requesting that the compiler instantiate <code>PathBase&lt;Path&gt;</code> and all its members for which it has definitions, based on the definitions you provided up to that point. In this specific case, it doesn't make any difference indeed. </p>\n<p>The declaration of an explicit specialization would look like <code>template&lt;&gt; class PathBase&lt;Path&gt;;</code>, but that's not what you want here either; see below.</p></li>\n<li><p>The use of <code>PathBase&lt;Path&gt;</code> when defining <code>Path</code> doesn't declare an explicit specialization either; it triggers an <em>implicit instantiation</em> of <code>PathBase&lt;Path&gt;</code>, based on the definition you provided above. An implicit instantiation for a class template instantiates the class definition and only the declarations of its member functions; it doesn't try to instantiate the definitions of the functions; those are only instantiated when needed, later on.</p></li>\n</ol>\n<hr>\n<p>In your cpp file, you're explicitly specializing <code>IsSeparator</code> and <code>Separators</code> for an implicitly instantiated <code>PathBase&lt;Path&gt;</code>. You're requesting that the compiler instantiate <code>PathBase&lt;Path&gt;</code> based on the generic definition you provided, but, when the definitions of those particular functions are needed, use the specific definitions you provide.</p>\n<p>It's basically a shorthand alternative to explicitly specializing the whole class template, when the structure of the class and most of the generic definitions for the members are fine, and you only want to fine-tune the definitions of a few members. If you explicitly specialized the whole class template, you'd have to provide a separate class definition and definitions for all the member functions of the specialization, which would mean unnecessary copy-paste.</p>\n<p>You need to tell the compiler about those explicit specializations as soon as possible, before there's any chance that some code would attempt to use the definitions (it needs to know that it will have to look for specific definitions instead of generic ones). You do that by declaring (not necessarily defining) the explicit specializations.</p>\n<p>The safest place to do that is immediately after the closing brace of the definition of <code>template &lt;class T&gt; class PathBase</code>. Something like:</p>\n<pre><code>class Path;\ntemplate&lt;&gt; std::string PathBase&lt;Path&gt;::Separators() const;\ntemplate&lt;&gt; bool PathBase&lt;Path&gt;::IsSeparator(char c) const;\n</code></pre>\n<p>You definitely need to do this in the header file, not in a cpp file, otherwise other cpp files that use the header will not know about the explicit specializations and will try to instantiate generic versions (if they need them). That will make your program ill-formed, no diagnostic required (this applies to your example as well). What that means is: if the compiler is smart enough to diagnose the problem, you should be grateful; if it isn't, you can't complain, and it's still your fault.</p>\n<p>Having declared the explicit specializations up front, the definitions can come later, possibly in a separate cpp file; that's fine, just like for normal functions. </p>\n<p>Also note that, should you want to include the definitions for the explicit specializations in the header file (to ease inlining, for example), you'll have to declare them <code>inline</code>, again like for normal functions. Otherwise, including the header in multiple cpp files will make the program ill-formed, NDR (you'll typically get multiple definition errors at link time).</p>\n<hr>\n<p>Obligatory standard quote from <a href=\"http://eel.is/c++draft/temp.expl.spec#7\" rel=\"nofollow noreferrer\">[temp.expl.spec]/7</a>:</p>\n<blockquote>\n<p id=\"so_40826618_40828823_0\">[...] When writing a specialization, be careful about its location; or\n  to make it compile will be such a trial as to kindle its\n  self-immolation.</p>\n</blockquote>\n<p>Yes, the members of the standardization committee are human too.</p>\n</hr></hr>", "LastEditorUserId": "4326278", "LastActivityDate": "2016-11-27T23:49:43.613", "Score": "3", "CreationDate": "2016-11-27T12:14:02.413", "ParentId": "40826618", "CommentCount": "1", "OwnerUserId": "4326278", "LastEditDate": "2016-11-27T23:49:43.613"}});