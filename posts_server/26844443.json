post_cb({"26844547": {"ParentId": "26844443", "CommentCount": "5", "Body": "<p>No.</p>\n<p>But you can define the alias as:</p>\n<pre><code>template&lt;typename T&gt;\nusing YetAnotherVector = typename std::conditional&lt;\n                                     std::is_same&lt;T,int&gt;::value, \n                                     AFancyIntVector, \n                                     std::vector&lt;T&gt;\n                                     &gt;::type;\n</code></pre>\n<p>Hope that helps.</p>\n", "OwnerUserId": "415784", "PostTypeId": "2", "Id": "26844547", "Score": "7", "CreationDate": "2014-11-10T13:06:15.153", "LastActivityDate": "2014-11-10T13:06:15.153"}, "26844613": {"ParentId": "26844443", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>It's neither possible to specialize them explicitly nor partially. [temp.decls]/3:</p>\n<blockquote>\n<p id=\"so_26844443_26844613_0\">Because an <em>alias-declaration</em> cannot declare a <em>template-id</em>, it is\n  not possible to partially or explicitly specialize an alias template.</p>\n</blockquote>\n<p>You will have to defer specializations to class templates. E.g. with <a href=\"http://en.cppreference.com/w/cpp/types/conditional\" rel=\"nofollow\"><code>conditional</code></a>:</p>\n<pre><code>template&lt;typename T&gt;\nusing YetAnotherVector = std::conditional_t&lt; std::is_same&lt;T, int&gt;{}, \n                                             AFancyIntVector, \n                                             std::vector&lt;T&gt; &gt;;\n</code></pre>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2014-11-10T13:15:02.400", "Id": "26844613", "Score": "1", "CreationDate": "2014-11-10T13:09:18.657", "LastActivityDate": "2014-11-10T13:15:02.400"}, "26844443": {"CommentCount": "5", "AcceptedAnswerId": "26844547", "CreationDate": "2014-11-10T13:00:42.683", "LastActivityDate": "2014-11-10T13:15:02.400", "PostTypeId": "1", "ViewCount": "224", "FavoriteCount": "1", "Title": "using template specialization", "Id": "26844443", "Score": "6", "Body": "<p>Usual template structs can be specialized, e.g.,</p>\n<pre><code>template&lt;typename T&gt;\nstruct X{};\n\ntemplate&lt;&gt;\nstruct X&lt;int&gt;{};\n</code></pre>\n<p>C++11 gave us the new cool <code>using</code> syntax for expressing template typedefs:</p>\n<pre><code>template&lt;typename T&gt;\nusing YetAnotherVector = std::vector&lt;T&gt;\n</code></pre>\n<p>Is there a way to define a template specialization for these using constructs similar to specializations for struct templates? I tried the following:</p>\n<pre><code>template&lt;&gt;\nusing YetAnotherVector&lt;int&gt; = AFancyIntVector;\n</code></pre>\n<p>but it yielded a compile error. Is this possible somehow?</p>\n", "Tags": "<c++><templates><c++11><template-specialization>", "OwnerUserId": "1408611", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_26844443_26844613_0": {"section_id": 99, "quality": 1.0, "length": 11}}, "n3337": {"so_26844443_26844613_0": {"section_id": 94, "quality": 1.0, "length": 11}}, "n4659": {"so_26844443_26844613_0": {"section_id": 103, "quality": 1.0, "length": 11}}}});