post_cb({"32250549": {"ParentId": "32250408", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2015-08-27T13:20:49.937", "Score": "2", "LastEditorUserId": "493122", "LastEditDate": "2015-08-27T13:30:28.643", "Id": "32250549", "OwnerUserId": "493122", "Body": "<p>If you are concerned with a literal name clashing with a non-user defined literal (<code>like 0l</code> for <code>long</code>), then \u00a72.13.8/1 (N4296) specifies that:</p>\n<blockquote>\n<p id=\"so_32250408_32250549_0\">If a token matches both user-defined-literal and another literal kind, it is treated as the latter. [Example: <code>123_km</code> is a user-defined-literal, but <code>12LL</code> is an integer-literal. \u2014end example] The syntactic non-terminal preceding the ud-suffix in a user-defined-literal is taken to be the longest sequence of characters that could match that non-terminal.</p>\n</blockquote>\n<p>If you are concerned with other libraries name clashes, it's usually a good idea to put literals in some namespace <code>literals</code>; at least this is what Boost and the <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/operator%22%22s\" rel=\"nofollow\">standard library</a> does. This will prevent name clashing.</p>\n<p>In any way, if there are more competing overloads to the user-defined literal operator, then \u00a72.13.8/2 (N4296) specifies that:</p>\n<blockquote>\n<p id=\"so_32250408_32250549_1\">A user-defined-literal is treated as a call to a literal operator or literal operator template (13.5.8). To determine the form of this call for a given user-defined-literal <code>L</code> with ud-suffix <code>X</code>, the literal-operator-id whose literal suffix identifier is X is looked up in the context of L using the rules for unqualified name lookup (3.4.1). Let S be the set of declarations found by this lookup. S shall not be empty.</p>\n</blockquote>\n<p>Also notice that \u00a717.6.4.3.4/1 (N4296) specifies that:</p>\n<blockquote>\n<p id=\"so_32250408_32250549_2\">Literal suffix identifiers (13.5.8) that do not start with an underscore are reserved for future standardization.</p>\n</blockquote>\n<p>So your <code>i</code> suffix there is illegal.</p>\n", "LastActivityDate": "2015-08-27T13:30:28.643"}, "32250408": {"CommentCount": "9", "ViewCount": "95", "CreationDate": "2015-08-27T13:14:26.913", "LastActivityDate": "2015-08-27T13:30:28.643", "Title": "Check whether or not a user-defined literal has already been defined", "PostTypeId": "1", "Id": "32250408", "Score": "1", "Body": "<p>C++11 has introduced user-defined literals. So, we can have cool things like</p>\n<pre><code>constexpr std::complex&lt;double&gt; operator\"\"i(unsigned long long d) {\n    return std::complex&lt;double&gt;{0., static_cast&lt;double&gt;(d)};\n}\n\nconstexpr std::complex&lt;double&gt; operator\"\"i(long double d) {\n    return std::complex&lt;double&gt;{0., static_cast&lt;double&gt;(d)};\n}\n</code></pre>\n<p>What happens if these operators were already defined? Is there any possibility to check this and define the operators above only if they don't exist?</p>\n", "Tags": "<c++><c++11><c++14>", "OwnerUserId": "547231", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_32250408_32250549_1": {"section_id": 5368, "quality": 0.9411764705882353, "length": 32}, "so_32250408_32250549_0": {"section_id": 5367, "quality": 0.8666666666666667, "length": 26}, "so_32250408_32250549_2": {"section_id": 6313, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_32250408_32250549_1": {"section_id": 5164, "quality": 0.9411764705882353, "length": 32}, "so_32250408_32250549_0": {"section_id": 5163, "quality": 0.8666666666666667, "length": 26}, "so_32250408_32250549_2": {"section_id": 6070, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_32250408_32250549_1": {"section_id": 6793, "quality": 0.9411764705882353, "length": 32}, "so_32250408_32250549_0": {"section_id": 6792, "quality": 0.8666666666666667, "length": 26}, "so_32250408_32250549_2": {"section_id": 7823, "quality": 0.8888888888888888, "length": 8}}}});