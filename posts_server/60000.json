post_cb({"2688631": {"Id": "2688631", "PostTypeId": "2", "Body": "<p>C++03 std, <a href=\"http://www.open-std.org/jtc1/sc22/WG21/docs/wp/html/nov97-2/conv.html#conv.mem\" rel=\"noreferrer\">\u00a74.11 2 Pointer to member conversions</a>:</p>\n<blockquote>\n<p id=\"so_60000_2688631_0\">An rvalue of type \u201cpointer to member of B of type <i>cv</i> T,\u201d where B is a class type, can be converted to an rvalue of type \u201cpointer to member of D of type <i>cv</i> T,\u201d where D is a derived class (clause 10) of B. If B is an inaccessible (clause 11), ambiguous (10.2) or virtual (10.1) base class of D, a program that necessitates this conversion is ill-formed. The result of the conversion refers to the same member as the pointer to member before the conversion took place, but it refers to the base class member as if it were a member of the derived class. The result refers to the member in D\u2019s instance of B. Since the result has type \u201cpointer to member of D of type <i>cv</i> T,\u201d it can be dereferenced with a D object. The result is the same as if the pointer to member of B were dereferenced with the B sub-object of D.   The null member pointer value is converted to the null member pointer value of the destination type. <sup>52)</sup></p>\n<p id=\"so_60000_2688631_1\"><sup>52)</sup>The rule for conversion of pointers to members (from pointer to member of base to pointer to member of derived) appears inverted compared to the rule for pointers to objects (from pointer to derived to pointer to base) (4.10, clause 10). This inversion is necessary to ensure type safety. Note that a pointer to member is not a pointer to object or a pointer to function and the rules for conversions of such pointers do not apply to pointers to members. In particular, a pointer to member cannot be converted to a void*.</p>\n</blockquote>\n<p>In short, you can convert a pointer to a member of an accessible, non-virtual base class to a pointer to a member of a derived class as long as the member isn't ambiguous. </p>\n<pre><code>class A {\npublic: \n    void foo();\n};\nclass B : public A {};\nclass C {\npublic:\n    void bar();\n};\nclass D {\npublic:\n    void baz();\n};\nclass E : public A, public B, private C, public virtual D {\npublic: \n    typedef void (E::*member)();\n};\nclass F:public E {\npublic:\n    void bam();\n};\n...\nint main() {\n   E::member mbr;\n   mbr = &amp;A::foo; // invalid: ambiguous; E's A or B's A?\n   mbr = &amp;C::bar; // invalid: C is private \n   mbr = &amp;D::baz; // invalid: D is virtual\n   mbr = &amp;F::bam; // invalid: conversion isn't defined by the standard\n   ...\n</code></pre>\n<p>Conversion in the other direction (via <code>static_cast</code>) is governed by <a href=\"http://www.open-std.org/jtc1/sc22/WG21/docs/wp/html/nov97-2/expr.html#expr.static.cast\" rel=\"noreferrer\">\u00a7 5.2.9</a> 9:</p>\n<blockquote>\n<p id=\"so_60000_2688631_2\">An rvalue of type \"pointer to member of D of type <i>cv1</i> T\" can be converted to an rvalue of type \"pointer to member of B of type <i>cv2</i> T\", where B is a base class (clause <a href=\"http://www.open-std.org/jtc1/sc22/WG21/docs/wp/html/nov97-2/derived.html#class.derived\" rel=\"noreferrer\">10 class.derived</a>) of D, if a valid standard conversion from \"pointer to member of B of type T\" to \"pointer to member of D of type T\" exists (<a href=\"http://www.open-std.org/jtc1/sc22/WG21/docs/wp/html/nov97-2/conv.html#conv.mem\" rel=\"noreferrer\">4.11 conv.mem</a>), and <i>cv2</i> is the same cv-qualification as, or greater cv-qualification than, <i>cv1</i>.<sup>11)</sup> The null member pointer value (<a href=\"http://www.open-std.org/jtc1/sc22/WG21/docs/wp/html/nov97-2/conv.html#conv.mem\" rel=\"noreferrer\">4.11 conv.mem</a>) is converted to the null member pointer value of the destination type. If class B contains the original member, or is a base or derived class of the class containing the original member, the resulting pointer to member points to the original member.  Otherwise, the result of the cast is undefined. [Note: although class B need not contain the original member, the dynamic type of the object on which the pointer to member is dereferenced must contain the original member; see <a href=\"http://www.open-std.org/jtc1/sc22/WG21/docs/wp/html/nov97-2/expr.html#expr.mptr.oper\" rel=\"noreferrer\">5.5 expr.mptr.oper</a>.]</p>\n<p id=\"so_60000_2688631_3\"><sup>11)</sup> Function types (including those used in pointer to member function\n    types) are never cv-qualified; see <a href=\"http://www.open-std.org/jtc1/sc22/WG21/docs/wp/html/nov97-2/decl.html#dcl.fct\" rel=\"noreferrer\">8.3.5 dcl.fct</a>.</p>\n</blockquote>\n<p>In short, you can convert from a derived <code>D::*</code> to a base <code>B::*</code> if you can convert from a <code>B::*</code> to a <code>D::*</code>, though you can only use the <code>B::*</code> on objects that are of type D or are descended from D.</p>\n", "LastEditorUserId": "90527", "LastActivityDate": "2011-11-07T08:00:42.713", "Score": "27", "CreationDate": "2010-04-22T06:25:21.923", "ParentId": "60000", "CommentCount": "8", "OwnerUserId": "90527", "LastEditDate": "2011-11-07T08:00:42.713"}, "60016": {"Id": "60016", "PostTypeId": "2", "Body": "<p>You might want to check out this article <a href=\"http://www.codeproject.com/KB/cpp/FastDelegate.aspx\" rel=\"nofollow noreferrer\">Member Function Pointers and the Fastest Possible C++ Delegates</a>  The short answer seems to be yes, in some cases.</p>\n", "OwnerDisplayName": "dagorym", "LastActivityDate": "2008-09-12T21:35:05.823", "Score": "2", "CreationDate": "2008-09-12T21:35:05.823", "ParentId": "60000", "CommentCount": "0", "OwnerUserId": "171"}, "1130707": {"Id": "1130707", "PostTypeId": "2", "Body": "<p>My experimentation revealed the following: Warning - this might be undefined behaviour. It would be helpful if someone could provide a definitive reference.</p>\n<ol>\n<li>This worked, but required a cast when assigning the derived member function to <code>p</code>.</li>\n<li>This also worked, but required extra casts when dereferencing <code>p</code>.</li>\n</ol>\n<p>If we're feeling really ambitious we could ask if <code>p</code> can be used to point to member functions of unrelated classes. I didn't try it, but the <a href=\"http://www.codeproject.com/KB/cpp/FastDelegate.aspx\" rel=\"nofollow noreferrer\">FastDelegate</a> page linked in dagorym's answer suggests it's possible.</p>\n<p>In conclusion, I'll try to avoid using member function pointers in this way. Passages like the following don't inspire confidence:</p>\n<blockquote>\n<p id=\"so_60000_1130707_0\">Casting between member function\n  pointers is an extremely murky area.\n  During the standardization of C++,\n  there was a lot of discussion about\n  whether you should be able to cast a\n  member function pointer from one class\n  to a member function pointer of a base\n  or derived class, and whether you\n  could cast between unrelated classes.\n  By the time the standards committee\n  made up their mind, different compiler\n  vendors had already made\n  implementation decisions which had\n  locked them into different answers to\n  these questions. [<a href=\"http://www.codeproject.com/KB/cpp/FastDelegate.aspx\" rel=\"nofollow noreferrer\">FastDelegate article</a>]</p>\n</blockquote>\n", "LastActivityDate": "2009-07-15T10:53:14.430", "CommentCount": "0", "CreationDate": "2009-07-15T10:53:14.430", "ParentId": "60000", "Score": "1", "OwnerUserId": "1077"}, "60010": {"Id": "60010", "PostTypeId": "2", "Body": "<p>I believe so.  Since the function pointer uses the signature to identify itself, the base/derived behavior would rely on whatever object you called it on.</p>\n", "OwnerDisplayName": "Steve Duitsman", "LastActivityDate": "2008-09-12T21:30:00.920", "Score": "1", "CreationDate": "2008-09-12T21:30:00.920", "ParentId": "60000", "CommentCount": "0", "OwnerUserId": "4575"}, "28506633": {"Id": "28506633", "PostTypeId": "2", "Body": "<p>Here is an example of what works.\nYou can override a method in derived class, and another method of base class that uses pointer to this overridden method indeed calls the derived class's method.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nclass A {\npublic:\n    virtual void traverse(string arg) {\n        find(&amp;A::visit, arg);\n    }\n\nprotected:\n    virtual void find(void (A::*method)(string arg),  string arg) {\n        (this-&gt;*method)(arg);\n    }\n\n    virtual void visit(string arg) {\n        cout &lt;&lt; \"A::visit, arg:\" &lt;&lt; arg &lt;&lt; endl;\n    }\n};\n\nclass B : public A {\nprotected:\n    virtual void visit(string arg) {\n        cout &lt;&lt; \"B::visit, arg:\" &lt;&lt; arg &lt;&lt; endl;\n    }\n};\n\nint main()\n{\n    A a;\n    B b;\n    a.traverse(\"one\");\n    b.traverse(\"two\");\n    return 0;\n}\n</code></pre>\n", "LastEditorUserId": "1427063", "LastActivityDate": "2015-02-13T18:58:03.910", "Score": "0", "CreationDate": "2015-02-13T18:51:28.733", "ParentId": "60000", "CommentCount": "0", "OwnerUserId": "1427063", "LastEditDate": "2015-02-13T18:58:03.910"}, "2688793": {"Id": "2688793", "PostTypeId": "2", "Body": "<p>The critical issue with pointers to members is that they can be applied to any reference or pointer to a class of the correct type. This means that because <code>Z</code> is derived from <code>Y</code> a pointer (or reference) of type pointer (or reference) to <code>Y</code> may actually point (or refer) to the base class sub-object of <code>Z</code> or <em>any other class</em> derived from <code>Y</code>.</p>\n<pre><code>void (Y::*p)() = &amp;Z::z_fn; // illegal\n</code></pre>\n<p>This means that anything assigned to a pointer to member of <code>Y</code> must actually work with any <code>Y</code>. If it was allowed to point to a member of <code>Z</code> (that wasn't a member of <code>Y</code>) then it would be possible to call a member function of <code>Z</code> on some thing that wasn't actually a <code>Z</code>.</p>\n<p>On the other hand, any pointer to member of <code>Y</code> also points the member of <code>Z</code> (inheritance means that <code>Z</code> has all the attributes and methods of its base) is it is legal to convert a pointer to member of <code>Y</code> to a pointer to member of <code>Z</code>. This is inherently safe.</p>\n<pre><code>void (Y::*p)() = &amp;Y::y_fn;\nvoid (Z::*q)() = p; // legal and safe\n</code></pre>\n", "LastActivityDate": "2010-04-22T06:58:06.120", "CommentCount": "0", "CreationDate": "2010-04-22T06:58:06.120", "ParentId": "60000", "Score": "6", "OwnerUserId": "19563"}, "bq_ids": {"n4140": {"so_60000_2688631_3": {"length": 10, "quality": 0.7692307692307693, "section_id": 16}, "so_60000_2688631_2": {"length": 76, "quality": 0.8351648351648352, "section_id": 6038}, "so_60000_2688631_0": {"length": 71, "quality": 0.8352941176470589, "section_id": 43}, "so_60000_2688631_1": {"length": 43, "quality": 0.8775510204081632, "section_id": 43}}, "n3337": {"so_60000_2688631_3": {"length": 10, "quality": 0.7692307692307693, "section_id": 13}, "so_60000_2688631_2": {"length": 79, "quality": 0.8681318681318682, "section_id": 5806}, "so_60000_2688631_0": {"length": 75, "quality": 0.8823529411764706, "section_id": 40}, "so_60000_2688631_1": {"length": 43, "quality": 0.8775510204081632, "section_id": 40}}, "n4659": {"so_60000_2688631_3": {"length": 10, "quality": 0.7692307692307693, "section_id": 20}, "so_60000_2688631_2": {"length": 69, "quality": 0.7582417582417582, "section_id": 7537}, "so_60000_2688631_0": {"length": 71, "quality": 0.8352941176470589, "section_id": 43}, "so_60000_2688631_1": {"length": 43, "quality": 0.8775510204081632, "section_id": 43}}}, "60000": {"ViewCount": "18419", "Body": "<p>In C++, can member function pointers be used to point to derived (or even base) class members? </p>\n<p>EDIT: \nPerhaps an example will help. Suppose we have a hierarchy of three classes <code>X</code>, <code>Y</code>, <code>Z</code> in order of inheritance. \n<code>Y</code> therefore has a base class <code>X</code> and a derived class <code>Z</code>.</p>\n<p>Now we can define a member function pointer <code>p</code> for class <code>Y</code>. This is written as:</p>\n<pre><code>void (Y::*p)();\n</code></pre>\n<p>(For simplicity, I'll assume we're only interested in functions with the signature <code>void f()</code> )  </p>\n<p>This pointer <code>p</code> can now be used to point to member functions of class <code>Y</code>.</p>\n<p>This question (two questions, really) is then:</p>\n<ol>\n<li>Can <code>p</code> be used to point to a function in the derived class <code>Z</code>?</li>\n<li>Can <code>p</code> be used to point to a function in the base class <code>X</code>?</li>\n</ol>\n", "AcceptedAnswerId": "2688631", "Title": "C++ inheritance and member function pointers", "CreationDate": "2008-09-12T21:24:53.413", "Id": "60000", "CommentCount": "3", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2009-07-15T10:52:43.013", "LastEditorDisplayName": "Simon Hardy", "OwnerDisplayName": "Simon Hardy", "LastEditorUserId": "1077", "LastActivityDate": "2015-02-13T18:58:03.910", "Score": "41", "OwnerUserId": "1077", "Tags": "<c++><inheritance><oop><member-function-pointers>", "AnswerCount": "8"}, "60023": {"Id": "60023", "PostTypeId": "2", "Body": "<p>I'm not 100% sure what you are asking, but here is an example that works with virtual functions:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A { \npublic:\n    virtual void foo() { cout &lt;&lt; \"A::foo\\n\"; }\n};\nclass B : public A {\npublic:\n    virtual void foo() { cout &lt;&lt; \"B::foo\\n\"; }\n};\n\nint main()\n{\n    void (A::*bar)() = &amp;A::foo;\n    (A().*bar)();\n    (B().*bar)();\n    return 0;\n}\n</code></pre>\n", "OwnerDisplayName": "Matt Price", "LastActivityDate": "2008-09-12T21:42:07.803", "Score": "9", "CreationDate": "2008-09-12T21:42:07.803", "ParentId": "60000", "CommentCount": "0", "OwnerUserId": "852"}, "2688154": {"Id": "2688154", "PostTypeId": "2", "Body": "<p>Assume that we have <code>class X, class Y : public X, and class Z : public Y</code></p>\n<p>You should be able to assign methods for both X, Y to pointers of type void (Y::*p)() but not methods for Z. To see why consider the following:</p>\n<pre><code>void (Y::*p)() = &amp;Z::func; // we pretend this is legal\nY * y = new Y; // clearly legal\n(y-&gt;*p)(); // okay, follows the rules, but what would this mean?\n</code></pre>\n<p>By allowing that assignment we permit the invocation of a method for Z on a Y object which could lead to who knows what. You can make it all work by casting the pointers but that is not safe or guaranteed to work.</p>\n", "LastEditorUserId": "322806", "LastActivityDate": "2010-11-28T15:04:10.950", "Score": "1", "CreationDate": "2010-04-22T04:01:20.723", "ParentId": "60000", "CommentCount": "2", "OwnerUserId": "322806", "LastEditDate": "2010-11-28T15:04:10.950"}});