post_cb({"bq_ids": {"n4140": {"so_18304120_18304993_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 1221}, "so_18304120_18304993_0": {"length": 13, "quality": 1.0, "section_id": 3919}}, "n3337": {"so_18304120_18304993_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 1219}, "so_18304120_18304993_0": {"length": 13, "quality": 1.0, "section_id": 3779}}, "n4659": {"so_18304120_18304993_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 1310}, "so_18304120_18304993_0": {"length": 13, "quality": 1.0, "section_id": 4805}}}, "18304993": {"Id": "18304993", "PostTypeId": "2", "Body": "<p>Section <strong>6.7.4</strong> of C++11 states that variables with static storage duration are initialized thread-safe:</p>\n<blockquote>\n<p id=\"so_18304120_18304993_0\">If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.</p>\n</blockquote>\n<p>But neither of VC++ 2012 or 2013 Preview implement this, so yes, you'll need some protection to make your function thread-safe.</p>\n<p>C++11 also says this about <code>ATOMIC_FLAG_INIT</code>, in section <strong>29.7.4</strong>:</p>\n<blockquote>\n<p id=\"so_18304120_18304993_1\">The macro <code>ATOMIC_FLAG_INIT</code> shall be defined in such a way that it can be used to initialize an object of type <code>atomic_flag</code> to the clear state. For a static-duration object, that initialization shall be static.</p>\n</blockquote>\n<p>VC++ <em>does</em> happen to implement this properly. <code>ATOMIC_FLAG_INIT</code> is <code>0</code> in VC++, and VC++ zero-initializes all statics at application start, not in the function call. So, your use of this is safe and there will be no race to initialize <code>lock</code>.</p>\n<p><strong>Test Code:</strong></p>\n<pre><code>struct nontrivial\n{\n    nontrivial() : x(123) {}\n    int x;\n};\n\n__declspec(dllexport) int next_x()\n{\n    static nontrivial x;\n    return ++x.x;\n}\n\n__declspec(dllexport) int next_x_ts()\n{\n    static std::atomic_flag flag = ATOMIC_FLAG_INIT;\n\n    while(flag.test_and_set());\n    static nontrivial x;\n    flag.clear();\n\n    return ++x.x;\n}\n</code></pre>\n<p><strong><code>next_x</code>:</strong></p>\n<pre><code>                mov     eax, cs:dword_1400035E4\n                test    al, 1                   ; checking if x has been initialized.\n                jnz     short loc_140001021     ; if it has, go down to the end.\n                or      eax, 1\n                mov     cs:dword_1400035E4, eax ; otherwise, set it as initialized.\n                mov     eax, 7Bh                 \n                inc     eax                     ; /O2 is on, how'd this inc sneak in!?\n                mov     cs:dword_1400035D8, eax ; init x.x to 124 and return.\n                retn\nloc_140001021:\n                mov     eax, cs:dword_1400035D8\n                inc     eax\n                mov     cs:dword_1400035D8, eax\n                retn\n</code></pre>\n<p><strong><code>next_x_ts</code>:</strong></p>\n<pre><code>loc_140001032:\n                lock bts cs:dword_1400035D4, 0  ; flag.test_and_set().\n                jb      short loc_140001032     ; spin until set.\n                mov     eax, cs:dword_1400035E0\n                test    al, 1                   ; checking if x has been initialized.\n                jnz     short loc_14000105A     ; if it has, go down to end.\n                or      eax, 1                  ; otherwise, set is as initialized.\n                mov     cs:dword_1400035E8, 7Bh ; init x.x with 123.\n                mov     cs:dword_1400035E0, eax\n\nloc_14000105A:\n                lock btr cs:dword_1400035D4, 0  ; flag.clear().\n                mov     eax, cs:dword_1400035E8\n                inc     eax\n                mov     cs:dword_1400035E8, eax\n                retn\n</code></pre>\n<p>You can see here that <code>next_x</code> is definitely not thread-safe, but <code>next_x_ts</code> never initializes the <code>flag</code> variable at <code>cs:dword_1400035D4</code> -- it is zero-initialized at application start, so there are no races and <code>next_x_ts</code> is thread-safe.</p>\n", "LastEditorUserId": "209199", "LastActivityDate": "2013-08-19T05:42:06.530", "Score": "5", "CreationDate": "2013-08-19T00:29:16.797", "ParentId": "18304120", "CommentCount": "4", "OwnerUserId": "209199", "LastEditDate": "2013-08-19T05:42:06.530"}, "18304120": {"ViewCount": "1300", "Body": "<p>Visual Studio 2012 does not implement the C++11 standard for thread safe static initialization (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2660.htm\" rel=\"noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2660.htm</a>).  I have a function local static that I need to guarantee will be initialized in a thread safe way.  The following is <strong><em>not</em></strong> thread safe in Visual Studio 2012:</p>\n<pre><code>struct MyClass\n{\n    int a;\n    MyClass()\n    {\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n        a = 5;\n    }\n};\n\nvoid foo()\n{\n    static MyClass instance;\n    std::cout &lt;&lt; instance.a &lt;&lt; '\\n';\n}\n\nint main()\n{\n    std::thread a(foo);\n    std::thread b(foo);\n    a.join();\n    b.join();\n\n    system(\"pause\");\n}\n</code></pre>\n<p>The output of the above program on Visual Studio 2012 will most likely be:</p>\n<pre><code>0\n5\n</code></pre>\n<p>I need to work around this problem and I am trying to find a way to do it with function local statics only (no globals or class level statics).</p>\n<p>My initial thought was to use a mutex, but it suffers from the same problem of static initialization thread safety.  If I have a static st::mutex inside of foo it is possible that the second thread will get a copy of the mutex while it is in an invalid state.</p>\n<p>Another option is to add an std::atomic_flag spin-lock.  The question is, is std::atomic_flag initialization thread safe in Visual Studio 2012?</p>\n<pre><code>void foo()\n{\n    // is this line thread safe?\n    static std::atomic_flag lock = ATOMIC_FLAG_INIT;\n    // spin lock before static construction\n    while (lock.test_and_set(std::memory_order_acquire));\n    // construct an instance of MyClass only once\n    static MyClass instance;\n    // end spin lock\n    lock.clear(std::memory_order_release);\n    // the following is not thread safe\n    std::cout &lt;&lt; instance.a &lt;&lt; '\\n';\n}\n</code></pre>\n<p>In the above code, is it possible for both threads to get past the spin lock or is it guaranteed that only one of them will?  Unfortunately I can't think of an easy way to test this since I can't put something inside the atomic_flag initializer to slow it down like I can with a class.  However, I want to be sure that my program won't crash once in a blue moon because I made an invalid assumption.</p>\n", "AcceptedAnswerId": "18304993", "Title": "Is std::atomic_flag static initialization thread safe in Visual Studio 2012?", "CreationDate": "2013-08-18T22:07:30.493", "Id": "18304120", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-08-19T05:42:06.530", "Score": "5", "OwnerUserId": "879046", "Tags": "<c++><visual-studio-2012><c++11>", "AnswerCount": "1"}});