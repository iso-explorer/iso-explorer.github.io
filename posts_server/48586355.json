post_cb({"bq_ids": {"n4140": {"so_48586355_48613192_0": {"length": 49, "quality": 0.98, "section_id": 216}, "so_48586355_48613192_6": {"length": 33, "quality": 0.9166666666666666, "section_id": 224}, "so_48586355_48613192_7": {"length": 12, "quality": 0.8571428571428571, "section_id": 7106}, "so_48586355_48613192_9": {"length": 14, "quality": 0.8235294117647058, "section_id": 7105}, "so_48586355_48613192_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 224}, "so_48586355_48613192_3": {"length": 16, "quality": 0.8888888888888888, "section_id": 224}, "so_48586355_48613192_4": {"length": 19, "quality": 0.95, "section_id": 222}, "so_48586355_48613192_12": {"length": 5, "quality": 0.8333333333333334, "section_id": 603}, "so_48586355_48587549_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 7094}, "so_48586355_48613192_5": {"length": 70, "quality": 0.958904109589041, "section_id": 223}, "so_48586355_48613192_8": {"length": 4, "quality": 0.8, "section_id": 7106}, "so_48586355_48613192_2": {"length": 11, "quality": 0.7857142857142857, "section_id": 224}, "so_48586355_48613192_11": {"length": 4, "quality": 1.0, "section_id": 7105}}, "n3337": {"so_48586355_48613192_0": {"length": 49, "quality": 0.98, "section_id": 210}, "so_48586355_48613192_6": {"length": 33, "quality": 0.9166666666666666, "section_id": 217}, "so_48586355_48613192_7": {"length": 12, "quality": 0.8571428571428571, "section_id": 6850}, "so_48586355_48613192_5": {"length": 70, "quality": 0.958904109589041, "section_id": 216}, "so_48586355_48613192_1": {"length": 10, "quality": 0.5882352941176471, "section_id": 217}, "so_48586355_48613192_3": {"length": 16, "quality": 0.8888888888888888, "section_id": 217}, "so_48586355_48613192_4": {"length": 19, "quality": 0.95, "section_id": 215}, "so_48586355_48613192_12": {"length": 5, "quality": 0.8333333333333334, "section_id": 593}, "so_48586355_48587549_0": {"length": 21, "quality": 0.875, "section_id": 6837}, "so_48586355_48613192_9": {"length": 14, "quality": 0.8235294117647058, "section_id": 6849}, "so_48586355_48613192_8": {"length": 4, "quality": 0.8, "section_id": 6850}, "so_48586355_48613192_2": {"length": 11, "quality": 0.7857142857142857, "section_id": 217}, "so_48586355_48613192_11": {"length": 4, "quality": 1.0, "section_id": 6849}}, "n4659": {"so_48586355_48613192_0": {"length": 49, "quality": 0.98, "section_id": 224}, "so_48586355_48613192_6": {"length": 33, "quality": 0.9166666666666666, "section_id": 232}, "so_48586355_48613192_7": {"length": 12, "quality": 0.8571428571428571, "section_id": 8607}, "so_48586355_48613192_5": {"length": 70, "quality": 0.958904109589041, "section_id": 231}, "so_48586355_48613192_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 232}, "so_48586355_48613192_3": {"length": 16, "quality": 0.8888888888888888, "section_id": 232}, "so_48586355_48613192_4": {"length": 19, "quality": 0.95, "section_id": 230}, "so_48586355_48613192_12": {"length": 6, "quality": 1.0, "section_id": 8606}, "so_48586355_48587549_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 8595}, "so_48586355_48613192_9": {"length": 14, "quality": 0.8235294117647058, "section_id": 8606}, "so_48586355_48613192_8": {"length": 4, "quality": 0.8, "section_id": 8607}, "so_48586355_48613192_2": {"length": 11, "quality": 0.7857142857142857, "section_id": 232}, "so_48586355_48613192_11": {"length": 4, "quality": 1.0, "section_id": 8606}}}, "48586355": {"ViewCount": "264", "Body": "<p>Consider a simple example:</p>\n<pre><code>template &lt;class T&gt;\nstruct tag { };\n\nint main() {\n    auto foo = [](auto x) -&gt; decltype(bar(x)) { return {}; };\n    tag&lt;int&gt; bar(tag&lt;int&gt;);\n    bar(tag&lt;int&gt;{}); // &lt;- compiles OK\n    foo(tag&lt;int&gt;{}); // 'bar' was not declared in this scope ?!\n}\n\ntag&lt;int&gt; bar(tag&lt;int&gt;) { return {}; }\n</code></pre>\n<p>Both <a href=\"https://wandbox.org/permlink/9t2gQBsRgECBaURN\" rel=\"noreferrer\">[gcc]</a> and <a href=\"https://wandbox.org/permlink/wShxVQto8Vj9gLgU\" rel=\"noreferrer\">[clang]</a> refuses to compile the code. Is this code ill-formed in some way?</p>\n", "AcceptedAnswerId": "48587549", "Title": "Why doesn't function declared inside other function participate in argument dependent lookup?", "CreationDate": "2018-02-02T15:55:08.167", "LastActivityDate": "2018-02-05T16:16:43.343", "CommentCount": "10", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2018-02-05T16:16:43.343", "LastEditorUserId": "1362568", "Id": "48586355", "Score": "7", "OwnerUserId": "4324224", "Tags": "<c++><templates><c++14><language-lawyer><argument-dependent-lookup>", "AnswerCount": "2"}, "48587549": {"Id": "48587549", "PostTypeId": "2", "Body": "<p>From unqualified lookup rules ([basic.lookup.unqual]):</p>\n<blockquote>\n<p id=\"so_48586355_48587549_0\">For the members of a class <code>X</code>, a name used in a member function body, [...], shall be declared in one of the\n  following ways <br/>\n  \u2014 if <code>X</code> is a local class or is a nested class of a local class, before the definition of class <code>X</code> in a block\n  enclosing the definition of class <code>X</code></p>\n</blockquote>\n<p>Your generic lambda is a local class within <code>main</code>, so to use <code>bar</code>, the name <code>bar</code> must appear in a declaration beforehand.</p>\n", "LastActivityDate": "2018-02-02T17:04:06.153", "CommentCount": "5", "CreationDate": "2018-02-02T17:04:06.153", "ParentId": "48586355", "Score": "5", "OwnerUserId": "27678"}, "48613192": {"Id": "48613192", "PostTypeId": "2", "Body": "<p><code>foo(tag&lt;int&gt;{});</code> triggers the implicit instantiation of a specialization of the function call operator member function template of <code>foo</code>'s closure type with the template argument <code>tag&lt;int&gt;</code>. This creates a <em>point of instantiation</em> for this member function template specialization. According to [temp.point]/1:</p>\n<blockquote>\n<p id=\"so_48586355_48613192_0\">For a function template specialization, <strong>a member function template\n  specialization</strong>, or a specialization for a member function or static\n  data member of a class template, if the specialization is implicitly\n  instantiated because it is referenced from within another template\n  specialization and the context from which it is referenced depends on\n  a template parameter, the point of instantiation of the specialization\n  is the point of instantiation of the enclosing specialization.\n  Otherwise, <strong>the point of instantiation for such a specialization\n  immediately follows the namespace scope declaration or definition</strong>\n  that refers to the specialization.</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>So, the point of instantiation is immediately after <code>main</code>'s definition, before the namespace-scope definition of <code>bar</code>.</p>\n<p>Name lookup for <code>bar</code> used in <code>decltype(bar(x))</code> proceeds according to [temp.dep.candidate]/1:</p>\n<blockquote>\n<p id=\"so_48586355_48613192_1\">For a function call where the <em>postfix-expression</em> is a dependent\n  name, the candidate functions are found using the usual lookup rules\n  (6.4.1, 6.4.2) except that:</p>\n<p id=\"so_48586355_48613192_2\">(1.1) \u2014 For the part of the lookup using unquali\ufb01ed name lookup\n  (6.4.1), only function declarations from the template definition\n  context are found.</p>\n<p id=\"so_48586355_48613192_3\">(1.2) \u2014 For the part of the lookup using associated namespaces\n  (6.4.2), only function declarations found in either the template\n  definition context or the template instantiation context are found. [...]</p>\n</blockquote>\n<p>Plain unqualified lookup in the definition context doesn't find anything. ADL in the definition context doesn't find anything either. ADL in the instantiation context, according to [temp.point]/7:</p>\n<blockquote>\n<p id=\"so_48586355_48613192_4\">The instantiation context of an expression that depends on the\n  template arguments is the set of declarations with external linkage\n  declared prior to the point of instantiation of the template\n  specialization in the same translation unit.</p>\n</blockquote>\n<p>Again, nothing, because <code>bar</code> hasn't been declared at namespace scope yet.</p>\n<p>So, the compilers are correct. Moreover, note [temp.point]/8:</p>\n<blockquote>\n<p id=\"so_48586355_48613192_5\">A specialization for a function template, a member function template,\n  or of a member function or static data member of a class template may\n  have multiple points of instantiations within a translation unit, and\n  in addition to the points of instantiation described above, for any\n  such specialization that has a point of instantiation within the\n  translation unit, <strong>the end of the translation unit is also considered\n  a point of instantiation</strong>. A specialization for a class template has\n  at most one point of instantiation within a translation unit. A\n  specialization for any template may have points of instantiation in\n  multiple translation units.\n  <strong>If two di\ufb00erent points of instantiation give a template specialization di\ufb00erent meanings according to the one-de\ufb01nition rule\n  (6.2), the program is ill-formed, no diagnostic required.</strong></p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>and the second part of [temp.dep.candidate]/1:</p>\n<blockquote>\n<p id=\"so_48586355_48613192_6\">[...] If the call would be ill-formed or would \ufb01nd a better match had\n  the lookup within the associated namespaces considered all the\n  function declarations with external linkage introduced in those\n  namespaces in all translation units, not just considering those\n  declarations found in the template de\ufb01nition and template\n  instantiation contexts, then the program has unde\ufb01ned behavior.</p>\n</blockquote>\n<p>So, ill-formed NDR or undefined behavior, take your pick. </p>\n<hr>\n<p>Let's consider the example from <a href=\"https://stackoverflow.com/questions/48586355/why-doesnt-function-declared-inside-other-function-participate-in-argument-depe#comment84170058_48586355\">your comment</a> above:</p>\n<pre><code>template &lt;class T&gt;\nstruct tag { };\n\nauto build() {\n    auto foo = [](auto x) -&gt; decltype(bar(x)) { return {}; };\n    return foo;\n}\n\ntag&lt;int&gt; bar(tag&lt;int&gt;) { return {}; }\n\nint main() {\n    auto foo = build();\n    foo(tag&lt;int&gt;{});\n}\n</code></pre>\n<p>Lookup in the definition context still doesn't find anything, but the instantiation context is immediately after <code>main</code>'s definition, so ADL in that context finds <code>bar</code> in the global namespace (associated with <code>tag&lt;int&gt;</code>) and the code compiles.</p>\n<hr>\n<p>Let's also consider AndyG's example from <a href=\"https://stackoverflow.com/questions/48586355/why-doesnt-function-declared-inside-other-function-participate-in-argument-depe#comment84170806_48586355\">his comment</a> above:</p>\n<pre><code>template &lt;class T&gt;\nstruct tag { };\n\n//namespace{\n//tag&lt;int&gt; bar(tag&lt;int&gt;) { return {}; }\n//}\n\nauto build() {\n    auto foo = [](auto x) -&gt; decltype(bar(x)) { return {}; };\n    return foo;\n}\n\nnamespace{\ntag&lt;int&gt; bar(tag&lt;int&gt;) { return {}; }\n}\n\nint main() {\n    auto foo = build();\n    foo(tag&lt;int&gt;{});\n}\n</code></pre>\n<p>Again, the instantiation point is immediately after <code>main</code>'s definition, so why isn't <code>bar</code> visible? An unnamed namespace definition introduces a <em>using-directive</em> for that namespace in its enclosing namespace (the global namespace in this case). This would make <code>bar</code> visible to plain unqualified lookup, but not to ADL according to [basic.lookup.argdep]/4:</p>\n<blockquote>\n<p id=\"so_48586355_48613192_7\">When considering an associated namespace, the lookup is the same as\n  the lookup performed when the associated namespace is used as a\n  quali\ufb01er (6.4.3.2) except that:</p>\n<p id=\"so_48586355_48613192_8\">(4.1) \u2014 Any <em>using-directives</em> in the associated namespace are\n  ignored. [...]</p>\n</blockquote>\n<p>Since only the ADL part of the lookup is performed in the instantiation context, <code>bar</code> in the unnamed namespace is not visible.</p>\n<p>Commenting out the lower definition and uncommenting the upper one makes <code>bar</code> in the unnamed namespace visible to plain unqualified lookup in the definition context, so the code compiles.</p>\n<hr>\n<p>Let's also consider the example from your <a href=\"https://stackoverflow.com/questions/48586355/why-doesnt-function-declared-inside-other-function-participate-in-argument-depe/48613192#comment84178721_48587549\">other comment</a> above:</p>\n<pre><code>template &lt;class T&gt;\nstruct tag { };\n\nint main() {\n    void bar(int);\n    auto foo = [](auto x) -&gt; decltype(bar(decltype(x){})) { return {}; };\n    tag&lt;int&gt; bar(tag&lt;int&gt;);\n    bar(tag&lt;int&gt;{});\n    foo(tag&lt;int&gt;{});\n}\n\ntag&lt;int&gt; bar(tag&lt;int&gt;) { return {}; }\n</code></pre>\n<p>This is accepted by GCC, but rejected by Clang. While I was initially quite sure that this is a bug in GCC, the answer may actually not be so clear-cut.</p>\n<p>The block-scope declaration <code>void bar(int);</code> disables ADL according to [basic.lookup.argdep]/3:</p>\n<blockquote>\n<p id=\"so_48586355_48613192_9\">Let X be the lookup set produced by unquali\ufb01ed lookup (6.4.1) and let\n  Y be the lookup set produced by argument dependent lookup (de\ufb01ned as\n  follows). If X contains</p>\n<p id=\"so_48586355_48613192_10\">(3.1) \u2014 a declaration of a class member, or</p>\n<p id=\"so_48586355_48613192_11\">(3.2) \u2014 <strong>a block-scope function declaration that is not a\n  using-declaration</strong>, or</p>\n<p id=\"so_48586355_48613192_12\">(3.3) \u2014 a declaration that is neither a function nor a function\n  template</p>\n<p id=\"so_48586355_48613192_13\"><strong>then Y is empty</strong>. [...]</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>Now, the question is whether this disables ADL in both the definition and instantiation contexts, or only in the definition context. </p>\n<p>If we consider ADL disabled in both contexts, then:</p>\n<ul>\n<li>The block-scope declaration, visible to plain unqualified lookup in the definition context, is the only one visible for all instantiations of the closure type's member function template specializations. Clang's error message, that there's no viable conversion to <code>int</code>, is correct and required - the two quotes above regarding ill-formed NDR and undefined behavior don't apply, since the instantiation context doesn't influence the result of name lookup in this case.</li>\n<li>Even if we move <code>bar</code>'s namespace-scope definition above <code>main</code>, the code still doesn't compile, for the same reason as above: plain unqualified lookup stops when it finds the block-scope declaration <code>void bar(int);</code> and ADL is not performed.</li>\n</ul>\n<p>If we consider ADL disabled only in the definition context, then:</p>\n<ul>\n<li>As far as the instantiation context is concerned, we're back to the first example; ADL still can't find the namespace-scope definition of <code>bar</code>. The two quotes above (ill-formed NDR and UB) do apply however, and so we can't blame a compiler for not issuing an error message.</li>\n<li>Moving <code>bar</code>'s namespace-scope definition above <code>main</code> makes the code well-formed.</li>\n<li>This would also mean that ADL in the instantiation context is always performed for dependent names, unless we have somehow determined that the expression is not a function call (which usually involves the definition context...).</li>\n</ul>\n<p>Looking at how [temp.dep.candidate]/1 is worded, it seems to say that plain unqualified lookup is performed only in the definition context as a first step, and then ADL is performed according to the rules in [basic.lookup.argdep] in both contexts as a second step. This would imply that the result of plain unqualified lookup influences this second step as a whole, which makes me lean towards the first option. </p>\n<p>Also, an even stronger argument in favor of the first option is that performing ADL in the instantiation context when either [basic.lookup.argdep]/3.1 or 3.3 apply in the definition context doesn't seem to make sense. </p>\n<p>Still... it may be worth asking about this one on <a href=\"https://groups.google.com/a/isocpp.org/forum/#!forum/std-discussion\" rel=\"nofollow noreferrer\">std-discussion</a>.</p>\n<hr>\n<p>All quotes are from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4713.pdf\" rel=\"nofollow noreferrer\">N4713</a>, the current standard draft.</p>\n</hr></hr></hr></hr>", "LastEditorUserId": "4326278", "LastActivityDate": "2018-02-05T11:03:35.073", "Score": "7", "CreationDate": "2018-02-04T21:29:59.090", "ParentId": "48586355", "CommentCount": "1", "OwnerUserId": "4326278", "LastEditDate": "2018-02-05T11:03:35.073"}});