post_cb({"7321993": {"ViewCount": "1285", "Body": "<p>What's the difference between</p>\n<pre><code>typedef void (&amp;FunctionTypeR)();\n</code></pre>\n<p>vs</p>\n<pre><code>typedef void (FunctionType)();\n</code></pre>\n<p>Is the second also a reference to function?  Is <code>FunctionTypeR</code> equivalent to <code>FunctionType&amp;</code> when used as the type of an argument?  </p>\n<p>For</p>\n<pre><code>void foo(FunctionType bar)\n</code></pre>\n<p>Does the runtime makes a copy of the argument bar (a function) when foo is invoked?</p>\n", "AcceptedAnswerId": "7322098", "Title": "Reference to Function syntax - with and without &", "CreationDate": "2011-09-06T15:01:30.847", "Id": "7321993", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-09-06T15:08:28.970", "LastEditorUserId": "264140", "LastActivityDate": "2011-09-06T17:32:45.520", "Score": "7", "OwnerUserId": "264140", "Tags": "<c++>", "AnswerCount": "1"}, "7322098": {"Id": "7322098", "PostTypeId": "2", "Body": "<p>The difference is that you <strong>cannot</strong> create objects of function type, but you can create of objects of function <em>pointer</em> type, and function <em>reference</em> type.</p>\n<p>That means if you've a function, say <code>f()</code> as:</p>\n<pre><code> void f(){}\n</code></pre>\n<p>then here is what you can do, and what you cannot do:</p>\n<pre><code>FunctionType  fun1 = f; //error - cannot create object of function type\nFunctionType *fun2 = f; //ok \nFunctionTypeR fun3 = f; //ok\n</code></pre>\n<p>Test code:</p>\n<pre><code>typedef void (&amp;FunctionTypeR)();\ntypedef void FunctionType();\n\nvoid f(){}\n\nint main() {\n        FunctionType  fun1 = f; //error - cannot create object of function type\n        FunctionType *fun2 = f; //ok \n        FunctionTypeR fun3 = f; //ok\n        return 0;\n}\n</code></pre>\n<p>Now see the compilation error (and warnings):</p>\n<pre><code> prog.cpp: In function \u2018int main()\u2019:\n prog.cpp:7: error: function \u2018void fun1()\u2019 is initialized like a variable\n prog.cpp:8: warning: unused variable \u2018fun2\u2019\n prog.cpp:9: warning: unused variable \u2018fun3\u2019\n</code></pre>\n<p>Online demo : <a href=\"http://ideone.com/hpTEv\">http://ideone.com/hpTEv</a> </p>\n<hr>\n<p>However, if you use <code>FunctionType</code> (which is a function type) in a function parameter list as:</p>\n<pre><code>void foo(FunctionType bar);\n</code></pre>\n<p>then it's equivalent to </p>\n<pre><code>void foo(FunctionType * bar);\n</code></pre>\n<p>That means, no matter what you write, you can call the function using <code>bar</code> as:</p>\n<pre><code>   bar();  //ok\n (*bar)(); //ok \n</code></pre>\n<p>That is, you can write this:</p>\n<pre><code>void h(FunctionType fun) { fun(); }\nvoid g(FunctionType fun) { (*fun)(); }\n</code></pre>\n<p>Demo : <a href=\"http://ideone.com/kwUE9\">http://ideone.com/kwUE9</a></p>\n<p>This is due to <em>function type to function pointer type</em> adjustment; that is, the <em>function type</em> is <strong>adjusted</strong> to become a <em>pointer to function type</em>:</p>\n<pre><code>Function type     |  Function pointer type (adjusted type)\n   void ()        |     void (*)()\n   void (int)     |     void (*)(int)\n   int  (int,int) |     int  (*)(int,int)\n   ....           |      ... so on\n</code></pre>\n<p>The C++03 Standard says in \u00a713.1/3,</p>\n<blockquote>\n<p id=\"so_7321993_7322098_0\">Parameter declarations that differ only in that one is a function type and the other is a pointer to the same function type are <strong>equivalent</strong>. <strong>That is, the function type is adjusted to become a pointer to function type (8.3.5)</strong>.</p>\n</blockquote>\n<pre><code>[Example:\n    void h(int());\n    void h(int (*)()); // redeclaration of h(int())\n    void h(int x()) { } // definition of h(int())\n    void h(int (*x)()) { } // ill-formed: redefinition of h(int())\n]\n</code></pre>\n<p>And if you use <code>`FunctionTypeR</code> (which is a function <em>reference</em> type) as:</p>\n<pre><code>void foo(FunctionTypeR bar);\n</code></pre>\n<p>then it's equivalent to:</p>\n<pre><code>void foo(FunctionType * &amp; bar);\n</code></pre>\n<p>And,</p>\n<pre><code>void h(FunctionTypeR fun) { fun(); }\nvoid g(FunctionTypeR fun) { (*fun)(); }\n</code></pre>\n<p>Demo : <a href=\"http://ideone.com/SmtQv\">http://ideone.com/SmtQv</a></p>\n<hr>\n<h1>Interesting part...</h1>\n<p>You can use FunctionType to <em>declare</em> a function (but not to define it).</p>\n<p>For example,</p>\n<pre><code>struct A\n{\n   //member function declaration. \n    FunctionType f; //equivalent to : void f();\n};\n\nvoid A::f() //definition\n{\n  std::cout &lt;&lt; \"haha\" &lt;&lt; std::endl;\n}\n\n//forward declaration\nFunctionType h; //equivalent to : void h();\n\nint main() {\n        A a;\n        a.f(); //call member function\n        h();   //call non-member function\n}\n\nvoid h() //definition goes below main()\n{\n   std::cout &lt;&lt;\"hmmm..\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Demo : <a href=\"http://ideone.com/W4ED2\">http://ideone.com/W4ED2</a></p>\n</hr></hr>", "LastEditorUserId": "415784", "LastActivityDate": "2011-09-06T17:32:45.520", "Score": "11", "CreationDate": "2011-09-06T15:09:17.757", "ParentId": "7321993", "CommentCount": "13", "OwnerUserId": "415784", "LastEditDate": "2011-09-06T17:32:45.520"}, "bq_ids": {"n4140": {"so_7321993_7322098_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 558}}, "n3337": {"so_7321993_7322098_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 549}}, "n4659": {"so_7321993_7322098_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 581}}}});