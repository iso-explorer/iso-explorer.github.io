post_cb({"7444790": {"CommentCount": "8", "ViewCount": "120", "PostTypeId": "1", "LastEditorUserId": "514235", "CreationDate": "2011-09-16T12:39:41.323", "LastActivityDate": "2011-09-16T13:08:05.463", "Title": "How to write a different version of stl algorithms in c++?", "AcceptedAnswerId": "7444919", "LastEditDate": "2011-09-16T12:42:42.120", "Id": "7444790", "Score": "-2", "Body": "<p>For practice, I wrote some <code>template</code> functions whose names are the same as the stl algorithms. But my code can not compile</p>\n<blockquote>\n<p id=\"so_7444790_7444790_0\">error: Call to &lt; algorithm_name &gt; is ambiguous.</p>\n</blockquote>\n<p>I only included <code>using std::necessary_names;</code> in my code rather than <code>using namespace std;</code>. </p>\n", "Tags": "<c++><stl><compiler-errors>", "OwnerUserId": "561847", "AnswerCount": "3"}, "7444919": {"ParentId": "7444790", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Usually when you have <code>using</code>, <a href=\"http://codepad.org/5MfEeLkr\" rel=\"nofollow\">the \"used\" name takes precedence</a>:</p>\n<pre><code>namespace N { int x = 0; }\nint x = 1;\n\nint main() {\n   using N::x;\n   cout &lt;&lt; x;\n}\n\n// Output: 0\n</code></pre>\n<p>However, Argument-Dependent Lookup <a href=\"http://codepad.org/jBhl14Vg\" rel=\"nofollow\">can mess this up</a>:</p>\n<pre><code>namespace N {\n   struct T {};\n   void f(T) {}\n}\n\nnamespace M {\n    void f(N::T) {}\n}\n\nint main() {\n   using M::f;\n   N::T o;\n   f(o);       // &lt;--- error: call of overloaded 'f(N::T&amp;)' is ambiguous\n}\n</code></pre>\n<p>So, if you are having trouble, <a href=\"http://codepad.org/0qAcOFTx\" rel=\"nofollow\">qualify your own namespace (in this example, <code>M</code>) explicitly</a>:</p>\n<pre><code>namespace N {\n   struct T {};\n   void f(T)     { cout &lt;&lt; \"N::f\"; }\n}\n\nnamespace M {\n    void f(N::T) { cout &lt;&lt; \"M::f\"; }\n}\n\nint main() {\n   using M::f;\n   N::T o;\n   M::f(o);    // &lt;--- Output: \"M::f\"\n}\n</code></pre>\n<p>In a somewhat bizarre twist, <a href=\"http://codepad.org/A3sPjrcw\" rel=\"nofollow\">you can also use parentheses to prevent ADL</a>:</p>\n<pre><code>namespace N {\n   struct T {};\n   void f(T)     { cout &lt;&lt; \"N::f\"; }\n}\n\nnamespace M {\n    void f(N::T) { cout &lt;&lt; \"M::f\"; }\n}\n\nint main() {\n   using M::f;\n   N::T o;\n   (f)(o);     // &lt;--- Output: \"M::f\"\n}\n</code></pre>\n<hr>\n<h3>Explanation</h3>\n<blockquote>\n<p id=\"so_7444790_7444919_0\"><code>[n3290: 3.4.1/1]:</code> <em>[re: unqualified name lookup]</em> In all the cases\n  listed in 3.4.1, <strong>the scopes are searched for a declaration in the\n  order listed in each of the respective categories; name lookup ends\n  as soon as a declaration is found for the name</strong>. If no declaration is\n  found, the program is ill-formed.</p>\n<p id=\"so_7444790_7444919_1\"><code>[n3290: 3.4.1/2]:</code> <em>[i.e. first priority]</em> The declarations from the\n  namespace nominated by a <em>using-directive</em> become visible in a namespace\n  enclosing the <em>using-directive</em>; see 7.3.4. For the purpose of the\n  unqualified name lookup rules described in 3.4.1, the declarations\n  from the namespace nominated by the <em>using-directive</em> are considered\n  members of that enclosing namespace.</p>\n<p id=\"so_7444790_7444919_2\"><code>[n3290: 3.4.2/1]:</code> <em>[re: argument-dependent lookup]</em> When the <em>postfix-expression</em> in a function call\n  (5.2.2) is an <em>unqualified-id</em>, <strong>other namespaces not considered during\n  the usual unqualified lookup</strong> (3.4.1) <strong>may be searched</strong>, and in those\n  namespaces, namespace-scope friend function declarations (11.3) not\n  otherwise visible may be found. These modifications to the search\n  depend on the types of the arguments (and for template template\n  arguments, the namespace of the template argument).</p>\n</blockquote>\n<p>i.e. Normal lookup stops at the name that you brought into scope with <code>using</code>, but when ADL comes into play, other names are also added to the candidate set, causing an ambiguity between two names.</p>\n</hr>", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2011-09-16T13:08:05.463", "Id": "7444919", "Score": "2", "CreationDate": "2011-09-16T12:50:36.083", "LastActivityDate": "2011-09-16T13:08:05.463"}, "7444849": {"ParentId": "7444790", "CommentCount": "1", "Body": "<p>It's better to declare your own version in a <code>namespace</code>; so that such problem would not occur.</p>\n<pre><code>namespace MySTL\n{\n  template&lt;typename T, ... &gt; // ... means other template params\n  class vector;\n\n  template&lt;typename T, ... &gt;\n  class queue;\n...\n}\n</code></pre>\n<p>now you can do,</p>\n<pre><code>using std::vector;\n</code></pre>\n<p>which will not collide with <code>MySTL::vector</code>.</p>\n", "OwnerUserId": "514235", "PostTypeId": "2", "Id": "7444849", "Score": "0", "CreationDate": "2011-09-16T12:44:34.837", "LastActivityDate": "2011-09-16T12:44:34.837"}, "bq_ids": {"n4140": {"so_7444790_7444919_1": {"section_id": 7088, "quality": 0.7419354838709677, "length": 23}, "so_7444790_7444919_2": {"section_id": 7103, "quality": 0.8095238095238095, "length": 34}, "so_7444790_7444919_0": {"section_id": 7087, "quality": 0.7777777777777778, "length": 21}}, "n3337": {"so_7444790_7444919_1": {"section_id": 6832, "quality": 0.7419354838709677, "length": 23}, "so_7444790_7444919_2": {"section_id": 6847, "quality": 0.8095238095238095, "length": 34}, "so_7444790_7444919_0": {"section_id": 6831, "quality": 0.7777777777777778, "length": 21}}, "n4659": {"so_7444790_7444919_1": {"section_id": 8589, "quality": 0.7419354838709677, "length": 23}, "so_7444790_7444919_2": {"section_id": 8604, "quality": 0.8095238095238095, "length": 34}, "so_7444790_7444919_0": {"section_id": 8588, "quality": 0.8148148148148148, "length": 22}}}, "7444938": {"ParentId": "7444790", "CommentCount": "0", "Body": "<p>Chances are that you are hitting a problem with Argument Dependent Lookup. When you pass a type that is defined within a namespace to an unqualified function, the namespaces of all the arguments are implicitly added to the lookup set, and that might cause collisions. You can try to qualify your own algorithm calls to inhibit ADL from kicking in.</p>\n<pre><code>namespace n {\n   struct test {};\n   void foo( test const &amp; ) {}\n};\nint main() {\n   n::test t;\n   foo( t );    // Will find n::foo as the argument belongs to n namespace\n}\n</code></pre>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "7444938", "Score": "0", "CreationDate": "2011-09-16T12:52:00.940", "LastActivityDate": "2011-09-16T12:52:00.940"}});