post_cb({"bq_ids": {"n4140": {"so_47520748_47522708_1": {"length": 7, "quality": 0.875, "section_id": 1150}, "so_47520748_47522708_2": {"length": 22, "quality": 0.8461538461538461, "section_id": 1148}}, "n3337": {"so_47520748_47522708_1": {"length": 7, "quality": 0.875, "section_id": 1147}, "so_47520748_47522708_2": {"length": 22, "quality": 0.8461538461538461, "section_id": 1145}}, "n4659": {"so_47520748_47522708_1": {"length": 7, "quality": 0.875, "section_id": 1244}, "so_47520748_47522708_2": {"length": 22, "quality": 0.8461538461538461, "section_id": 1242}}}, "47520748": {"ViewCount": "85", "Body": "<p>In the C++ memory model, there is a total order on all loads and stores of all sequentially consistent operations. I'm wondering how this interacts with operations that have other memory orderings that are sequenced before/after sequentially consistent loads.</p>\n<p>For example, consider two threads:</p>\n<pre><code>std::atomic&lt;int&gt; a(0);\nstd::atomic&lt;int&gt; b(0);\nstd::atomic&lt;int&gt; c(0);\n\n//////////////\n// Thread T1\n//////////////\n\n// Signal that we've started running.\na.store(1, std::memory_order_relaxed);\n\n// If T2's store to b occurs before our load below in the total\n// order on sequentially consistent operations, set flag c.\nif (b.load(std::memory_order_seq_cst) == 1) {\n  c.store(1, std::memory_order_relaxed)\n}\n\n\n//////////////\n// Thread T2\n//////////////\n\n// Blindly write to b.\nb.store(1, std::memory_order_seq_cst)\n\n// Has T1 set c? If so, then we know our store to b occurred before T1's load\n// in the total order on sequentially consistent operations.\nif (c.load(1, std::memory_order_relaxed)) {\n  // But is this guaranteed to be visible yet?\n  assert(a.load(1, std::memory_order_relaxed) == 1);\n}\n</code></pre>\n<p>Is it guaranteed that the assertion in T2 cannot fire?</p>\n<p>I'm looking for detailed citations of the standard here. In particular I think this this would require showing that the load from <code>b</code> in T1  <em>synchronizes with</em> the store to <code>b</code> in T2 in order to establish that the store to <code>a</code> inter-thread happens before the load from <code>a</code>, but as far as I can tell the standard says that <code>memory_order_seq_cst</code> stores synchronize with loads, but not the other way around.</p>\n", "Title": "C++ memory model: do seq_cst loads synchronize with seq_cst stores?", "CreationDate": "2017-11-27T22:15:21.920", "LastActivityDate": "2017-11-30T19:06:39.847", "CommentCount": "0", "PostTypeId": "1", "Id": "47520748", "Score": "3", "OwnerUserId": "1505451", "Tags": "<c++><language-lawyer><atomic><memory-model><stdatomic>", "AnswerCount": "1"}, "47522708": {"Id": "47522708", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_47520748_47522708_0\">Do seq_cst loads synchronize with seq_cst stores?</p>\n</blockquote>\n<p>They do if all necessary requirements are met; in your example code, the <code>assert</code> can fire  </p>\n<blockquote>\n<p id=\"so_47520748_47522708_1\">\u00a729.3.3<br>\n  There shall be a single total order S on all memory_order_seq_cst operations</br></p>\n</blockquote>\n<p>This total order applies to the <code>seq_cst</code> operations themselves.. In isolation, a <code>store(seq_cst)</code> has release semantics, whereas a <code>load(seq_cst)</code> has acquire semantics.</p>\n<blockquote>\n<p id=\"so_47520748_47522708_2\">\u00a729.3.1-2  [atomics.order]<br>\n  memory_order_release, memory_order_acq_rel, and memory_order_seq_cst:<br>\n  a store operation performs a release operation on the affected memory location.<br>\n  .....<br>\n  \u00a729.3.1-4  [atomics.order]<br>\n  memory_order_acquire, memory_order_acq_rel, and memory_order_seq_cst:<br>\n  a load operation performs an acquire operation on the affected memory location.</br></br></br></br></br></br></p>\n</blockquote>\n<p>Therefore, atomic operations with non-<code>seq_cst</code> ordering (or non-atomic operations) are ordered with respect to <code>seq_cst</code> operations per the acquire/release ordering rules:</p>\n<ul>\n<li>a <code>store(seq_cst)</code> operation cannot be reordered with any memory operation that is sequenced before it (i.e. comes earlier in program order)..</li>\n<li>a <code>load(seq_cst)</code> operation cannot be reordered with any memory operation that is sequenced after it.  </li>\n</ul>\n<p>In your example, although <code>c.store(relaxed)</code> in <code>T1</code> is ordered (inter-thread) after <code>b.load(seq_cst)</code> (the <code>load</code> is an acquire operation),\n<code>c.load(relaxed)</code> in <code>T2</code> is unordered with respect to <code>b.store(seq_cst)</code> (which is a release operation, but it does not prevent the reordering).</p>\n<p>You can also look at the operations on <code>a</code>. Since those are not ordered with respect to anything, <code>a.load(relaxed)</code> can return <code>0</code>, causing the <code>assert</code> to fire.</p>\n", "LastEditorUserId": "6651824", "LastActivityDate": "2017-11-30T19:06:39.847", "Score": "5", "CreationDate": "2017-11-28T01:53:40.717", "ParentId": "47520748", "CommentCount": "18", "LastEditDate": "2017-11-30T19:06:39.847", "OwnerUserId": "6651824"}});