post_cb({"16934997": {"Id": "16934997", "PostTypeId": "2", "Body": "<p>Initialize <code>bar</code> to <code>nullptr</code>/<code>NULL</code> (<a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b11\" rel=\"tag\" title=\"show questions tagged 'c++11'\">c++11</a>/<a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a>), You can delete it without any checks in the destructor.</p>\n<p>Your class definition will contain <code>char *bar=nullptr;</code>.</p>\n", "LastEditorUserId": "2148672", "LastActivityDate": "2013-06-05T08:33:17.493", "Score": "1", "CreationDate": "2013-06-05T08:27:59.000", "ParentId": "16934982", "CommentCount": "1", "OwnerUserId": "2148672", "LastEditDate": "2013-06-05T08:33:17.493"}, "bq_ids": {"n4140": {"so_16934982_16935018_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 7182}}, "n3337": {"so_16934982_16935018_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 6926}}, "n4659": {"so_16934982_16935018_1": {"length": 16, "quality": 0.8888888888888888, "section_id": 8690}}}, "16935018": {"Id": "16935018", "PostTypeId": "2", "Body": "<p>If <code>bar</code> is nullptr, then you can safely call delete on it:</p>\n<pre><code>bar = nullptr;\ndelete bar;\n</code></pre>\n<p>so you don't need to test, just delete.</p>\n<blockquote>\n<p id=\"so_16934982_16935018_0\">3.7.4.2/3:</p>\n<p id=\"so_16934982_16935018_1\">The value of the \ufb01rst argument supplied to a deallocation function may be a null pointer value; if so, and if the deallocation function is one supplied in the standard library, the call has no effect.</p>\n</blockquote>\n", "LastActivityDate": "2013-06-05T08:28:47.503", "CommentCount": "0", "CreationDate": "2013-06-05T08:28:47.503", "ParentId": "16934982", "Score": "7", "OwnerUserId": "390913"}, "16935032": {"Id": "16935032", "PostTypeId": "2", "Body": "<p><code>delete</code>ing a null pointer is safe. That's why you should always set your pointer to <code>NULL</code> or <code>nullptr</code> when not in use:</p>\n<pre><code>struct foo{\n    foo() : bar(NULL) {}\n        //  ^ Initialize bar to NULL\n\n    ~foo() {\n       delete bar;\n    }\n\n    void some_method() {\n        bar = new char;\n        ...\n        delete bar;\n        bar = NULL;  // Immediately set bar back to NULL\n    }\n\n    private:\n        char *bar;\n};\n</code></pre>\n<p>Please note that when you set a pointer to the one returned by <code>new</code>, you must match it with <code>delete</code>, while if you set it using the pointer returned by <code>new[]</code>, be sure to use <code>delete[]</code> on it.</p>\n<p>Anyway, if you have access to C++11 smart pointers <code>std::shared_ptr</code> or <code>std::unique_ptr</code>, then they are your best bet.</p>\n", "LastEditorUserId": "1619294", "LastActivityDate": "2013-06-05T08:36:35.903", "Score": "4", "CreationDate": "2013-06-05T08:29:51.190", "ParentId": "16934982", "CommentCount": "5", "OwnerUserId": "1619294", "LastEditDate": "2013-06-05T08:36:35.903"}, "16934982": {"ViewCount": "256", "Body": "<p>Suppose I have the following class:</p>\n<pre><code>foo{\n    ~foo();\n\n    private:\n        char *bar;\n};\n</code></pre>\n<p>Under certain conditions bar will create a new char array so what would be the correct way to handle the deletion of it? Would a simple bool do or would that be considered bad practice?</p>\n", "AcceptedAnswerId": "16935032", "Title": "Calling delete upon a conditional call to new", "CreationDate": "2013-06-05T08:26:31.920", "Id": "16934982", "CommentCount": "0", "LastEditDate": "2015-07-10T14:15:16.683", "PostTypeId": "1", "LastEditorUserId": "4370109", "LastActivityDate": "2015-07-10T14:15:16.683", "Score": "1", "OwnerUserId": "1959534", "Tags": "<c++><delete-operator>", "AnswerCount": "3"}});