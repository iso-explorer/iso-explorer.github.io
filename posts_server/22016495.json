post_cb({"22016495": {"CommentCount": "6", "AcceptedAnswerId": "22032011", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-02-25T14:03:25.883", "LastActivityDate": "2014-02-26T10:53:58.817", "LastEditDate": "2017-05-23T11:50:24.707", "ViewCount": "301", "FavoriteCount": "0", "Title": "When does `decltype` with a function call expression require the function to be defined?", "Id": "22016495", "Score": "4", "Body": "<p>In clang I get this warning </p>\n<pre><code>warning: inline function 'detail::selector&lt;2, int&gt;::select' is not defined [-Wundefined-inline]\n    static constexpr auto select(T const&amp;) -&gt; std::integral_constant&lt;int, Which&gt;;\n                          ^\n\nnote: used here\nstatic_assert( decltype(Selector::select(int()))::value == 2, \"\");\n                                  ^\n</code></pre>\n<p>in the code below.</p>\n<p>Is NOT defining the function here harmful? (I strongly believe, it doesn't matter here and in my application, since it's used in unevaluated context, in std::enable_if).</p>\n<p>Now, I'm wondering <em>when</em> the compiler thinks it should issue a warning.</p>\n<pre><code>#include &lt;type_traits&gt;\n\nnamespace detail {\n\n    template &lt;int Which, typename...&gt; struct selector;\n\n    template &lt;int Which&gt;\n    struct selector&lt;Which&gt; {\n        static constexpr void select();  // never select\n    };\n\n    template &lt;int Which, typename T, typename... Ts&gt;\n    struct selector&lt;Which, T, Ts...&gt; : selector&lt;Which+1, Ts...&gt;\n    {\n        using selector&lt;Which+1, Ts...&gt;::select;\n        static constexpr auto select(T const&amp;) -&gt; std::integral_constant&lt;int, Which&gt;;\n    };\n}\n\nint main(int argc, const char * argv[])\n{\n    using Selector = detail::selector&lt;0, char, short, int&gt;;\n    static_assert( decltype(Selector::select(int()))::value == 2, \"\");    \n    return 0;\n}\n</code></pre>\n<h3>Edit:</h3>\n<p>Notes: </p>\n<ul>\n<li><p>gcc-4.8.1 on ideone.com does not issue a warning.</p></li>\n<li><p>The simplest way to get rid of the warning is providing an implementation, e.g.:</p>\n<pre><code>static constexpr auto select(T const&amp;) \n-&gt; std::integral_constant&lt;int, Which&gt; \n{ return {}; }\n</code></pre>\n<p>(thanks @Yakk)</p></li>\n</ul>\n<hr>\n<p><strong>Solution</strong>:</p>\n<p>As explained in the answer provided by <a href=\"https://stackoverflow.com/users/1090079\">@Filip Ros\u00e9en</a> the <code>constexpr</code> specifier will implicitly declare that function inline, which requires a definition WHEN it is evaluated. The function is <em>not</em> used in my code, though - but nonetheless clang will issue that warning (indicating a minor issue in the compiler). clang will not issue this warning anymore, when the <code>constexpr</code> specifier is omitted. The <code>constexpr</code> specifier seems to be inappropriate anyway, (thanks <a href=\"https://stackoverflow.com/users/1774667/yakk\">@Yakk</a>).</p>\n</hr>", "Tags": "<templates><c++11><clang><sfinae><decltype>", "OwnerUserId": "465677", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_22016495_22032011_6": {"section_id": 5404, "quality": 1.0, "length": 13}, "so_22016495_22032011_1": {"section_id": 5404, "quality": 1.0, "length": 13}, "so_22016495_22032011_9": {"section_id": 5404, "quality": 1.0, "length": 13}, "so_22016495_22032011_4": {"section_id": 7039, "quality": 0.8333333333333334, "length": 5}, "so_22016495_22032011_7": {"section_id": 7039, "quality": 0.8333333333333334, "length": 5}, "so_22016495_22032011_8": {"section_id": 7040, "quality": 1.0, "length": 7}, "so_22016495_22032011_5": {"section_id": 7040, "quality": 1.0, "length": 7}, "so_22016495_22032011_2": {"section_id": 5404, "quality": 1.0, "length": 13}}, "n3337": {"so_22016495_22032011_6": {"section_id": 5199, "quality": 1.0, "length": 13}, "so_22016495_22032011_1": {"section_id": 5199, "quality": 1.0, "length": 13}, "so_22016495_22032011_9": {"section_id": 5199, "quality": 1.0, "length": 13}, "so_22016495_22032011_4": {"section_id": 6785, "quality": 0.8333333333333334, "length": 5}, "so_22016495_22032011_7": {"section_id": 6785, "quality": 0.8333333333333334, "length": 5}, "so_22016495_22032011_8": {"section_id": 6785, "quality": 1.0, "length": 7}, "so_22016495_22032011_5": {"section_id": 6785, "quality": 1.0, "length": 7}, "so_22016495_22032011_2": {"section_id": 5199, "quality": 1.0, "length": 13}}, "n4659": {"so_22016495_22032011_6": {"section_id": 6853, "quality": 1.0, "length": 13}, "so_22016495_22032011_1": {"section_id": 6853, "quality": 1.0, "length": 13}, "so_22016495_22032011_9": {"section_id": 6853, "quality": 1.0, "length": 13}, "so_22016495_22032011_4": {"section_id": 8536, "quality": 0.8333333333333334, "length": 5}, "so_22016495_22032011_7": {"section_id": 8536, "quality": 0.8333333333333334, "length": 5}, "so_22016495_22032011_8": {"section_id": 8537, "quality": 1.0, "length": 7}, "so_22016495_22032011_5": {"section_id": 8537, "quality": 1.0, "length": 7}, "so_22016495_22032011_2": {"section_id": 6853, "quality": 1.0, "length": 13}}}, "22032011": {"ParentId": "22016495", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-02-26T04:47:43.840", "Score": "1", "LastEditorUserId": "1090079", "LastEditDate": "2014-02-26T05:08:13.820", "Id": "22032011", "OwnerUserId": "1090079", "Body": "<p><sup><strong>Note</strong>; as stated the diagnostic issued by <em>clang</em> is a mere warning and not an error, which means that it's just there to attract our attention to a segment which might be misused if not handled correctly.</sup></p>\n<hr>\n<p><strong>What might potentially go wrong?</strong></p>\n<p>Entities marked as <em>constexpr</em> are implicitly <code>inline</code> (which is also true for functions defined directly within a class), as stated in <code>[dcl.fct.spec]p3</code>.</p>\n<p>Functions having the <code>inline</code> specifier, implicitly or not, must follow the rules applied to such. The warning issued by <em>clang</em> is there to warn developers of writing code that violates the following (among others):</p>\n<blockquote>\n<p id=\"so_22016495_22032011_0\">[<strong>dcl.fct.spec</strong>]</p>\n<blockquote>\n<p id=\"so_22016495_22032011_2\">4) An inline function shall be defined in every translation unit in which it is <em>odr-used</em> and shall have exactly the same definition in every case (3.2).</p>\n</blockquote>\n</blockquote>\n<p><sup></sup></p>\n<blockquote>\n<p id=\"so_22016495_22032011_3\">[<strong>basic.def.odr</strong>]</p>\n<blockquote>\n<p id=\"so_22016495_22032011_7\">2) An expression is <em>potentially evaluated</em> unless it is an unevaluated operand (Clause 5) ...</p>\n<p id=\"so_22016495_22032011_8\">3) A variable <code>x</code> whose name appears as a <em>potentially-evaluated</em> expression <code>ex</code> is <em>odr-used</em> ...</p>\n<p id=\"so_22016495_22032011_9\">4) ... An inline function shall be defined in every translation unit in which it is <em>odr-used</em> and shall have exactly the same definition in every case (3.2).</p>\n</blockquote>\n</blockquote>\n<hr>\n<p><strong>Is clang correct to issue <code>-Wundefined-inline</code> in our context?</strong></p>\n<p>Technically... <strong>No</strong>, the warning is of no value since our usage of <code>select</code> doesn't violate the <em>one definition rule</em> in an unevaluated context.</p>\n<p>You could supress the warning by passing <code>-Wno-undefined-inline</code> when invoking <em>clang</em>, and if this bothers you greatly please <a href=\"http://llvm.org/bugs/\" rel=\"nofollow\">file a bug report</a>.</p>\n</hr></hr>", "LastActivityDate": "2014-02-26T05:08:13.820"}});