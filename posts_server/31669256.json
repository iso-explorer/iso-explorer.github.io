post_cb({"31669342": {"ParentId": "31669256", "CommentCount": "0", "Body": "<p>You're copying <code>sizeof(abc)</code> bytes of data but the pointers you give memcpy point to <code>a</code> and <code>b</code>'s pointers, not the objects - the address-of in this <code>(void*)&amp;a</code> is definitely wrong.</p>\n<p>However you really should not be doing this because copying objects like that instead of using they copy ctor or other proper method will lead to crashes and undefined behaviour. In this specific case what might happen if the string is a bit longer is you end up with two <code>string</code> objects pointing to the same heap block therefore you will get double delete exiting the scope which is a non-recoverable crash.</p>\n", "OwnerUserId": "4999494", "PostTypeId": "2", "Id": "31669342", "Score": "2", "CreationDate": "2015-07-28T06:57:25.103", "LastActivityDate": "2015-07-28T06:57:25.103"}, "31669370": {"ParentId": "31669256", "CommentCount": "0", "Body": "<p>Your code triggers undefined behavior because you are copying towards the address of pointer <code>b</code> more bytes than the size of the pointer: you are copying <code>sizeof(abc)</code> instead of <code>sizeof(a)</code>.</p>\n", "OwnerUserId": "1915854", "PostTypeId": "2", "Id": "31669370", "Score": "2", "CreationDate": "2015-07-28T06:58:52.237", "LastActivityDate": "2015-07-28T06:58:52.237"}, "31669256": {"CommentCount": "5", "ViewCount": "249", "PostTypeId": "1", "LastEditorUserId": "5133882", "CreationDate": "2015-07-28T06:52:30.990", "LastActivityDate": "2015-07-28T10:37:56.133", "Title": "memcpy on new std::string implementation (gcc 5.1)", "FavoriteCount": "0", "LastEditDate": "2015-07-28T07:12:20.613", "Id": "31669256", "Score": "-3", "Body": "<p>I have written the following code which seems to be working fine with old std::string implentation. But with gcc 5.1, it crashes.</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nstruct abc\n{\n   public:\n   abc() {}\n   abc(const std::string&amp; x)\n      : gullu(x)\n   {\n   }\n   std::string gullu;\n};\n\nint main()\n{\n   abc *a = new abc(\"dhfghdf\");\n   abc *b = new abc();\n   memcpy((void *)&amp;b, (void *)&amp;a, sizeof(abc));\n   std::cout &lt;&lt; a-&gt;gullu.data() &lt;&lt; std::endl;\n   std::cout &lt;&lt; b-&gt;gullu.data();\n   return 0;\n}\n</code></pre>\n<p><strong>Debugging it, I found that after doing memcpy the content of object 'a' becomes garbage.</strong></p>\n<p>After a's construction,</p>\n<blockquote>\n<p id=\"so_31669256_31669256_0\">(gdb) p *a $1 = {gullu = {static npos = 4294967295, _M_dataplus =\n  {&gt; = {&lt;__gnu_cxx::new_allocator&gt; = {}, },\n        _M_p = 0x804ea18 \"dhfghdf\"}, _M_string_length = 7, {_M_local_buf = \"dhfghdf\\000\\000\\000\\000\\000\\000\\000\\000\", _M_allocated_capacity = 1734764644}}}</p>\n</blockquote>\n<p>After b's construction</p>\n<blockquote>\n<p id=\"so_31669256_31669256_1\">(gdb) p *b $2 = {gullu = {static npos = 4294967295, _M_dataplus =\n  {&gt; = {&lt;__gnu_cxx::new_allocator&gt; = {}, }, _M_p = 0x804ea38 \"\"},\n      _M_string_length = 0, {_M_local_buf = '\\000' , _M_allocated_capacity = 0}}}</p>\n</blockquote>\n<p>After memcpy</p>\n<blockquote>\n<p id=\"so_31669256_31669256_2\">(gdb) p *a $4 = {gullu = {static npos = 4294967295, _M_dataplus =\n  {&gt; = {&lt;__gnu_cxx::new_allocator&gt; = {}, },\n        _M_p = 0x666468 }, _M_string_length = 2572404, {_M_local_buf =\n  \"t@'\\000\\030\u00d9\u00ff\u00bfI\\215\\004\\b\\001\\000\\000\",\n        _M_allocated_capacity = 2572404}}}</p>\n<p id=\"so_31669256_31669256_3\">(gdb) p *b $5 = {gullu = {static npos = 4294967295, _M_dataplus =\n  {&gt; = {&lt;__gnu_cxx::new_allocator&gt; = {}, },\n        _M_p = 0x804ea18 \"dhfghdf\"}, _M_string_length = 7, {_M_local_buf = \"dhfghdf\\000\\000\\000\\000\\000\\000\\000\\000\", _M_allocated_capacity = 1734764644}}}</p>\n</blockquote>\n<p>I am using a thirdparty library which seems to be doing a memcpy, which was working with previous compiler and not working with gcc 5.1 because of this issue</p>\n<p>Can someone help me with this?</p>\n", "Tags": "<c++><gcc><g++><stdstring>", "OwnerUserId": "5133882", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_31669256_31669383_0": {"section_id": 7189, "quality": 0.8857142857142857, "length": 62}}, "n3337": {"so_31669256_31669383_0": {"section_id": 6933, "quality": 0.8857142857142857, "length": 62}}, "n4659": {"so_31669256_31669383_0": {"section_id": 8697, "quality": 0.8, "length": 56}}}, "31669383": {"ParentId": "31669256", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Well, you are not doing what you want. While you are clearly trying to copy the content of a <code>string</code> to another, what you are doing is just copy the value of a pointer (<code>a</code>) to another (<code>b</code>), but copying a wrong size!</p>\n<p>By the way, what you intended is <code>memcpy(b, a, sizeof(abc));</code>, but this is not supposed to work too (it will work on several cases though)! As I've learned on my skin (and thanks to <a href=\"https://stackoverflow.com/a/29777728/2508150\">this answer</a>), you can't <code>memcpy</code> an object that has <em>non-trivial initialization</em>. By reusing the storage of such an object you end its lifetime, but just <code>memcpy</code>ing to it you do not <em>resurrect</em> it, so the object pointed by <code>b</code> would be not alive.</p>\n<p>Quotes from the C++11 standard (<em>\u00a73.8 Object lifetime</em> <strong>[basic.life]</strong>):</p>\n<blockquote>\n<p id=\"so_31669256_31669383_0\">The lifetime of an object is a runtime property of the object. An object is said to have non-trivial initialization\n  if it is of a class or aggregate type and it or one of its members is initialized by a constructor other than a trivial\n  default constructor. [ Note: initialization by a trivial copy/move constructor is non-trivial initialization. \u2014\n  end note ] The lifetime of an object of type T begins when:\n  \u2014 storage with the proper alignment and size for type T is obtained, <strong><em>and\n  \u2014 if the object has non-trivial initialization, its initialization is complete.</em></strong>\n  The lifetime of an object of type T ends when:\n  \u2014 if T is a class type with a non-trivial destructor (12.4), the destructor call starts, or\n  \u2014 <strong><em>the storage which the object occupies is reused or released</em></strong>.\n  \u00a7</p>\n</blockquote>\n", "OwnerUserId": "2508150", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:03:52.487", "Id": "31669383", "Score": "3", "CreationDate": "2015-07-28T06:59:28.067", "LastActivityDate": "2015-07-28T10:37:56.133"}});