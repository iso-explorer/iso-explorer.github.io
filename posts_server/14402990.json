post_cb({"14513865": {"ParentId": "14402990", "CommentCount": "0", "Body": "<p>Ideal thing to do is to provide a public swap member function only when you think that the std::swap would be inefficient for your type. \nIn case you provide a swap member function, it is recommended that you also provide a non-member swap that calls this member function. This makes it easier for other people to call your more efficient template-specific version.</p>\n", "OwnerUserId": "1173966", "PostTypeId": "2", "Id": "14513865", "Score": "0", "CreationDate": "2013-01-25T01:22:54.127", "LastActivityDate": "2013-01-25T01:22:54.127"}, "14402990": {"CommentCount": "11", "AcceptedAnswerId": "14403772", "CreationDate": "2013-01-18T16:14:41.950", "LastActivityDate": "2014-06-10T01:19:48.547", "PostTypeId": "1", "ViewCount": "2483", "FavoriteCount": "3", "Title": "Should you overload swap in the std namespace?", "Id": "14402990", "Score": "19", "Body": "<p>I read something interesting today that said the 'standard' way to call swap on a user provided type (provided as a template argument) is...</p>\n<pre><code>using std::swap;\nswap(something, soemthingelse);\n</code></pre>\n<p>The reason for this is to use argument dependent look-up to either use a <code>swap</code> function in a user namespace or <code>swap</code> in the <code>std</code> namespace. This raised an interested question for me. When I overload <code>std::swap</code> for one of my classes I had actually been defining it in the <code>std</code> namespace... <code>namespace std { void swap(/*...*/){/*...*/} }</code>. Is this practice <em>wrong</em>? Should I define my own <code>swap</code>s in <code>std</code> or my own namespace (and why)?</p>\n", "Tags": "<c++><stl>", "OwnerUserId": "369872", "AnswerCount": "5"}, "14404776": {"ParentId": "14402990", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I believe <a href=\"https://stackoverflow.com/a/2684544/1290731\">this is the answer you're looking for</a>, and the entire set of answers to that question explain all.  Howard Hinnant and Dave Abrahams have been on the C++ standards committee for more than a decade I think.</p>\n", "OwnerUserId": "1290731", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:54:15.993", "Id": "14404776", "Score": "4", "CreationDate": "2013-01-18T17:57:39.103", "LastActivityDate": "2013-01-18T17:57:39.103"}, "14403368": {"ParentId": "14402990", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>First of all, you are not allowed to add things to <code>std</code> (be it just an overload), so overloading the <code>std::swap</code> is bad practice in the first place. What you can do is specialize existing templates. So you should rather specialize than overload:</p>\n<pre><code>namespace std\n{\n    template&lt;&gt; void swap&lt;MyType&gt;(...) {...}\n}\n</code></pre>\n<p>But still the question stands if an own-namespace version is to be preferred over a <code>std</code>-specialization. The idomatic recommended way is to provide a free <code>swap</code> in your own namespace and let ADL resolve it, like <em>David</em> already suggests. The problem with this is, that if someone (the client of your library) is not that well-versed in idiomatic C++ and just explicitly calls <code>std::swap(...)</code> all over the place, you might end up with sub-optimal swapping behaviour. This is the case why I for myself usually went the safe way of doing both (own-namespace function + <code>std</code>-specialization), even if that always has a bad taste to me.</p>\n<p>But fortunately C++11 simplifies things, since efficiently moveable types (which are usually also the effieciently swappable ones) can be swapped quite efficiently with the default <code>std::swap</code>, which uses move-semantics. So the possible usage of the default <code>std::swap</code> over your own <code>swap</code> function becomes less of a disadvantage (and you might even consider not bothering to provide one anyway).</p>\n<p>So if you have C++11, the best way is indeed to not bother extending <code>std</code> but just define your own <code>swap</code> in your types' namespace, while in C++03 you might want to be on the safe side with a <code>std::swap</code> specialization, even if being less idiomatic.</p>\n", "OwnerUserId": "743214", "LastEditorUserId": "743214", "LastEditDate": "2013-01-18T17:05:58.193", "Id": "14403368", "Score": "3", "CreationDate": "2013-01-18T16:36:01.293", "LastActivityDate": "2013-01-18T17:05:58.193"}, "14403278": {"ParentId": "14402990", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>It is legal to provide specializations of standard templates for your own types, and those must go inside the <code>std</code> namespace. So both approaches are legal C++.</p>\n<p>That being said, the recommended way is to provide the <code>swap</code> free function in the same namespace as your own type and have ADL pickup your overload from there.</p>\n<hr>\n<p><strong>EDIT</strong>: After some of the comments I reread the question and noticed that it mentions <em>overloads</em> in the <code>std</code> namespace. It is <strong>illegal</strong> to provide overloads in the <code>std</code> namespace, only <em>specializations</em> are allowed.</p>\n</hr>", "OwnerUserId": "36565", "LastEditorUserId": "36565", "LastEditDate": "2013-01-18T17:17:46.997", "Id": "14403278", "Score": "6", "CreationDate": "2013-01-18T16:30:42.313", "LastActivityDate": "2013-01-18T17:17:46.997"}, "14403772": {"ParentId": "14402990", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You're doing it  wrong :)</p>\n<blockquote>\n<p id=\"so_14402990_14403772_0\"><strong>17.6.2.4.1 [namespace.std]</strong></p>\n<blockquote id=\"so_14402990_14403772_1\">\n<ol>\n<li>The behavior of a C++ program is undefined if it adds declarations or definitions to namespace <code>std</code> or to a namespace within namespace <code>std</code> unless otherwise specified. A program may add a template specialization for any standard library template to namespace <code>std</code> only if the declaration depends on a user-defined type and the specialization meets the standard library requirements for the original template and is not explicitly prohibited.</li>\n</ol>\n</blockquote>\n</blockquote>\n<p>That pretty clearly says you may not add overloads to namespace <code>std</code>. You <em>could</em> specialize <code>std::swap&lt;MyType&gt;</code> for your type, but if your type is a template you'd need a partial specialization, <code>std::swap&lt;MyContainer&lt;T&gt;&gt;</code> and you can't partially specialize a function template, so that won't work, so it's not a good approach in general.</p>\n<p>C++11 also defines the requirements for a type to be <em>swappable</em> which include:</p>\n<blockquote>\n<p id=\"so_14402990_14403772_2\"><strong>17.6.3.2 [swappable.requirements]</strong></p>\n<blockquote id=\"so_14402990_14403772_3\">\n<ol>\n<li>...  </li>\n<li>...  </li>\n<li>The context in which <code>swap(t, u)</code> and <code>swap(u, t)</code> are evaluated shall ensure that a binary non-member function named \"swap\" is selected via overload resolution (13.3) on a candidate set that includes:</li>\n</ol>\n<blockquote id=\"so_14402990_14403772_4\">\n<ul>\n<li>the two swap function templates defined in <code>&lt;utility&gt;</code> (20.2) and</li>\n<li>the lookup set produced by argument-dependent lookup (3.4.2).</li>\n</ul>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>So calling <code>swap</code> on two objects of swappable type should be able to find <code>std::swap</code> and should be able to find other overloads by ADL.  Calling it unqualified (and without an explicit template argument list) ensures ADL happens, and including <code>&lt;utility&gt;</code> and adding the using-declaration for <code>std::swap</code> ensures the standard overloads can be found. So doing it the way you show in your question meets those requirements.</p>\n<p>That pretty clearly defines what it takes to be <em>swappable</em> in the sense used by the standard, which is what is required by the standard library e.g. by the functions in <code>&lt;algorithm&gt;</code>.</p>\n<p>If you put <code>swap</code> overloads for your type in your type's namespace then they can be found by ADL.  That is the right thing to do anyway, functions related to your type belong in the same namespace as your type, see Item 57 in <a href=\"http://www.gotw.ca/publications/c++cs.htm\" rel=\"noreferrer\">C++ Coding Standards</a> by Sutter and Alexandrescu for more details on that topic.</p>\n<p>So in short, you have been doing it wrong. What you read is correct.  Doing <code>using std::swap</code> and relying on ADL always works (for templates and non-templates) and avoids undefined behaviour. Yay.</p>\n<p>N.B. The C++03 standard was less clear about how user-defined types should be swapped. For some history around this area see <a href=\"http://www.boostpro.com/writing/n1691.html#problem-2-name-reservation\" rel=\"noreferrer\">N1691 2.2</a> which defines the term <em>customization point</em> and shows different ways to define them in APIs.  The protocol used in C++11 for swapping types uses one of those ways, and is now clearly and unambiguously blessed as the \"correct way\" to provide a swap function for your type. Other customization points in other libraries can use other approaches, but to be swappable in C++11 terms means <code>using std::swap;</code> and relying on ADL.</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "701092", "LastEditDate": "2014-06-10T01:19:48.547", "Id": "14403772", "Score": "17", "CreationDate": "2013-01-18T16:57:09.213", "LastActivityDate": "2014-06-10T01:19:48.547"}, "bq_ids": {"n4140": {"so_14402990_14403772_1": {"section_id": 6299, "quality": 0.9705882352941176, "length": 33}, "so_14402990_14403772_4": {"section_id": 6279, "quality": 0.8461538461538461, "length": 11}, "so_14402990_14403772_3": {"section_id": 6279, "quality": 0.875, "length": 28}}, "n3337": {"so_14402990_14403772_1": {"section_id": 6056, "quality": 0.9705882352941176, "length": 33}, "so_14402990_14403772_4": {"section_id": 6039, "quality": 0.8461538461538461, "length": 11}, "so_14402990_14403772_3": {"section_id": 6039, "quality": 0.875, "length": 28}}, "n4659": {"so_14402990_14403772_1": {"section_id": 7808, "quality": 0.9705882352941176, "length": 33}, "so_14402990_14403772_4": {"section_id": 7786, "quality": 0.8461538461538461, "length": 11}, "so_14402990_14403772_3": {"section_id": 7786, "quality": 0.875, "length": 28}}}});