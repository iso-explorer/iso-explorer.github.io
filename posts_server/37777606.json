post_cb({"bq_ids": {"n4140": {"so_37777606_37778582_1": {"section_id": 7019, "quality": 0.8888888888888888, "length": 8}, "so_37777606_37778582_0": {"section_id": 405, "quality": 0.9230769230769231, "length": 24}}, "n3337": {"so_37777606_37778582_1": {"section_id": 6765, "quality": 0.8888888888888888, "length": 8}, "so_37777606_37778582_0": {"section_id": 396, "quality": 0.9230769230769231, "length": 24}}, "n4659": {"so_37777606_37778582_1": {"section_id": 8516, "quality": 0.8888888888888888, "length": 8}, "so_37777606_37778582_0": {"section_id": 423, "quality": 0.9230769230769231, "length": 24}}}, "37778719": {"ParentId": "37777606", "CommentCount": "1", "Body": "<p>Variant 1 will allow you to have an instance of the class. Variant 2.1, 2.2 won't allow instances, but allows instances of descendants. This, for example works (and is able to confuse many people), while removing the marked line will make compile fail:</p>\n<pre><code>class I21 {\npublic:\n    virtual ~I21() = 0;\n};\n\nI21::~I21() {} // remove this and it'll not compile\n\nclass I22 : public I21\n{\npublic:\n    virtual ~I22() {}\n};\n\nint main() {\n    I22 i;\n    return 0;\n}\n</code></pre>\n<p>The reason behind, the destructor chain calls I21::~I21() directly and not via interface. That said, it's not clear what your <em>goal</em> is with pure virtual destructors. If you'd like to avoid instantiation (i.e., static class), you might consider deleting the constructor instead; if you'd like descendants that can be instantiated but not this class, perhaps you need a pure virtual member function that's implemented in descendants.</p>\n", "OwnerUserId": "6292621", "PostTypeId": "2", "Id": "37778719", "Score": "1", "CreationDate": "2016-06-12T20:21:18.587", "LastActivityDate": "2016-06-12T20:21:18.587"}, "37777606": {"CommentCount": "1", "AcceptedAnswerId": "37849364", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-06-12T18:19:04.500", "LastActivityDate": "2016-06-18T05:54:29.900", "LastEditDate": "2017-05-23T10:30:54.447", "ViewCount": "1027", "FavoriteCount": "2", "Title": "C++11 interface pure virtual destructor", "Id": "37777606", "Score": "2", "Body": "<p><strong>UPD</strong>. There is a mark that it is a duplicate of <a href=\"https://stackoverflow.com/questions/11494422/default-pure-virtual-destructor\">this question</a>. But in that question OP asks HOW to use <code>default</code> to define pure virtual destructor. This question is about <em>what the difference</em>.</p>\n<p>In C++ (latest standard if possible) what the <strong>real</strong> difference between defining pure virtual destructor with empty body implementation and just a empty body (or default)?</p>\n<p>Variant 1:</p>\n<pre><code>class I1 {\npublic:\n    virtual ~I1() {}\n};\n</code></pre>\n<p>Variant 2.1:</p>\n<pre><code>class I21 {\npublic:\n    virtual ~I21() = 0;\n};\n\nI21::~I21() {}\n</code></pre>\n<p>Variant 2.2:</p>\n<pre><code>class I22 {\npublic:\n    virtual ~I22() = 0;\n};\n\nI22::~I22() = default;\n</code></pre>\n<p><strong>Update</strong> I found at least 1 difference between Variant 1 and Variants 2.1/2.2:</p>\n<p><code>std::is_abstract::value</code> is <code>false</code> for Variant 1, and <code>true</code> for Variants 2.1 and 2.2.</p>\n<p><a href=\"http://ideone.com/HL7OKe\" rel=\"nofollow noreferrer\"><kbd><strong>Demo</strong></kbd></a></p>\n<p>May be someone can found difference between 2.1 and 2.2?</p>\n", "Tags": "<c++><language-lawyer><pure-virtual><virtual-destructor>", "OwnerUserId": "1555823", "AnswerCount": "3"}, "37778582": {"ParentId": "37777606", "CommentCount": "2", "Body": "<p>All I could find was:</p>\n<p>\u00a712.4 (5.9)</p>\n<blockquote>\n<p id=\"so_37777606_37778582_0\">A destructor can be declared virtual (10.3) or pure virtual (10.4); if any objects of that class or any\n  derived class are created in the program, the destructor shall be defined. If a class has a base class with a\n  virtual destructor, its destructor (whether user- or implicitly-declared) is virtual.</p>\n</blockquote>\n<p>leading to:</p>\n<p>\u00a710.4 (the class is now abstract)</p>\n<p>10.4 (2) says:</p>\n<blockquote>\n<p id=\"so_37777606_37778582_1\">A pure virtual function need be defined only if called with, or as if with (12.4), the qualified-id syntax (5.1).</p>\n</blockquote>\n<p>But the narrative on destructors in \u00a712.4 talks about destructors always being called as if by their fully qualified name (in order to prevent ambiguity).</p>\n<p>Which means that:</p>\n<ul>\n<li><p>the destructor must be defined, even if pure virtual, and</p></li>\n<li><p>the class is now abstract.</p></li>\n</ul>\n", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "37778582", "Score": "3", "CreationDate": "2016-06-12T20:06:41.607", "LastActivityDate": "2016-06-12T20:06:41.607"}, "37849364": {"ParentId": "37777606", "CommentCount": "1", "Body": "<p>The difference between I1 and I2*, as you pointed out, is that adding <code>= 0</code> makes the class abstract. In fact, making the destructor pure virtual is a <em>trick</em> to make a class abstract when you don't have any other function to be pure virtual. And I said it's a trick because the destructor cannot be left undefined if you ever want to destruct any derived class of it (and here you will), then you still need to define the destructor, either empty or defaulted.</p>\n<p>Now the difference between empty or defaulted destructor/constructor (I21 and I22) is way more obscure, there isn't much written out there. The recommended one is to use <code>default</code>, both as a new idiom to make your intentions clearer, and apparently, to give the compiler a chance for optimization. Quoting <a href=\"https://msdn.microsoft.com/en-us/library/dn457344.aspx#Anchor_1\" rel=\"nofollow\">msdn</a></p>\n<blockquote>\n<p id=\"so_37777606_37849364_0\">Because of the performance benefits of trivial special member functions, we recommend that you prefer automatically generated special member functions over empty function bodies when you want the default behavior.</p>\n</blockquote>\n<p>There are no visible differences between the two, apart from this possible performance improvement. <code>= default</code> is the way to go from C++11 on.</p>\n", "OwnerUserId": "5308925", "PostTypeId": "2", "Id": "37849364", "Score": "4", "CreationDate": "2016-06-16T03:22:48.893", "LastActivityDate": "2016-06-16T03:22:48.893"}});