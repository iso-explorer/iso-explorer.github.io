post_cb({"8634174": {"ParentId": "8634134", "CommentCount": "0", "CreationDate": "2011-12-26T08:42:27.567", "OwnerUserId": "343443", "PostTypeId": "2", "Id": "8634174", "Score": "1", "Body": "<p>No, because you can return anything from <code>operator=</code>, even if you define its implementation.</p>\n", "LastActivityDate": "2011-12-26T08:42:27.567"}, "8634134": {"CommentCount": "1", "ViewCount": "509", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-12-26T08:36:10.983", "LastActivityDate": "2011-12-29T01:50:23.850", "Title": "Does \"operator=\" return type matter if I want to make the class non-copyable?", "AcceptedAnswerId": "8634541", "LastEditDate": "2017-05-23T11:48:06.637", "Id": "8634134", "Score": "5", "Body": "<p>Suppose I have a class that doesn't support memberwise copying so I don't want to preserve compiler-implemented copy-constructor and assignment operator. I also don't want to implement those because either</p>\n<ol>\n<li>doing so takes extra effort and I don't need those operations in my class or</li>\n<li>those operations won't make sense in my class</li>\n</ol>\n<p>so I want to prohibit them. To do so <a href=\"https://stackoverflow.com/q/5702100/57428\">I'll declare them private and provide no implementation</a>:</p>\n<pre><code>class NonCopyable {\nprivate:\n   NonCopyable( const NonCopyable&amp; ); //not implemented anywhere\n   void operator=( const NonCopyable&amp; ); //not implemented anywhere\n};\n</code></pre>\n<p>Now I can select any return type for <code>operator=()</code> member function. Will it matter which return type I select?</p>\n", "Tags": "<c++><operators><operator-overloading>", "OwnerUserId": "57428", "AnswerCount": "5"}, "8634182": {"ParentId": "8634134", "CommentCount": "0", "CreationDate": "2011-12-26T08:43:30.570", "OwnerUserId": "78845", "PostTypeId": "2", "Id": "8634182", "Score": "1", "Body": "<p>No, it does not matter, since you never implement a <code>return</code> statement. If you try to invoke the operator, the compiler won't be able to find an implementation (with <em>any</em> <code>return</code> type, so the return type is irrelevant).</p>\n<p>Interestingly, <a href=\"http://www.boost.org/doc/libs/1_48_0/boost/noncopyable.hpp\" rel=\"nofollow\"><code>boost::noncopyable</code></a>'s copy assignment operator is declared to return a <code>const noncopyable&amp;</code>, but I guess that's just convention.</p>\n", "LastActivityDate": "2011-12-26T08:43:30.570"}, "8634541": {"ParentId": "8634134", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2011-12-26T09:41:21.140", "Score": "1", "LastEditorUserId": "410767", "LastEditDate": "2011-12-29T01:50:23.850", "Id": "8634541", "OwnerUserId": "410767", "Body": "<p>It matters a tiny, tiny bit:</p>\n<ul>\n<li><p><code>void</code> ensures a small percentage of accidental/misguided calls (a = b = c / f(d = e)) from within the class's implementation produce compile time errors rather than link time errors, which may save compile time and be more understandable (minimally relevant for large classes touched by many developers, some with limited prior familiarity).</p></li>\n<li><p><code>void</code> would ring an alarm bell for me (and hopefully most developers), wondering whether you:</p>\n<ul>\n<li>wanted to remove the default-generated <code>operator=</code></li>\n<li>were just lazy about the extra typing, or</li>\n<li>were unfamiliar/uncaring re the generally expected semantics of <code>operator=</code>.</li>\n</ul></li>\n</ul>\n<blockquote>\n<blockquote>\n<blockquote>\n<p id=\"so_8634134_8634541_2\"><em>With the open question in mind, other programmer are less likely to come along and think you just didn't get around to providing the implementation and add it casually (you may feel comments are adequate).</em></p>\n</blockquote>\n</blockquote>\n</blockquote>\n<ul>\n<li>returning a reference to type may make the overall function signature more instantaneously recognisable, or visually searching past a complicated type to find <code>operator=</code> could have the opposite effect - all in the eye (and mind) of the beholder....</li>\n</ul>\n", "LastActivityDate": "2011-12-29T01:50:23.850"}, "8634149": {"ParentId": "8634134", "CommentCount": "0", "CreationDate": "2011-12-26T08:39:25.820", "OwnerUserId": "1030547", "PostTypeId": "2", "Id": "8634149", "Score": "2", "Body": "<p>No, since you'll never call this operator in your code. I tend to keep the return type NonCopyable&amp;, for clarity and consistency.</p>\n", "LastActivityDate": "2011-12-26T08:39:25.820"}, "bq_ids": {"n4140": {"so_8634134_8634157_1": {"section_id": 466, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_8634134_8634157_1": {"section_id": 457, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_8634134_8634157_1": {"section_id": 489, "quality": 0.9444444444444444, "length": 17}}}, "8634157": {"ParentId": "8634134", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-12-26T08:40:20.560", "Score": "7", "LastEditorUserId": "308661", "LastEditDate": "2011-12-26T09:03:12.037", "Id": "8634157", "OwnerUserId": "308661", "Body": "<p><strong>No, the return type doesn't matter.</strong><sup>\u2020</sup></p>\n<p>The C++ standard does not impose any requirements on the return type for copy assignment special member functions that you declare yourself. It just needs to be an <code>operator=()</code> that acccepts \"exactly one parameter of type <code>X</code>, <code>X&amp;</code>, <code>const X&amp;</code>, <code>volatile X&amp;</code> or <code>const volatile X&amp;</code>\".<sup>\u2020\u2020</sup> Therefore, <code>void operator=( const NonCopyable&amp; );</code> is still a copy assignment operator (a user-declared one, to be specific).</p>\n<p>Because you have in fact supplied your own copy assignment operator, it will surpress the generation of the default copy assignment operator. This forces all calls to <code>NonCopyable</code>'s copy assignment operator to resolve to yours, causing any attempts to use the copy assignment operator to fail to compile since it's declared <code>private</code>.</p>\n<pre><code>class Foo : NonCopyable\n{\n};\n\nint main()\n{\n    Foo a;\n    Foo b;\n    // Compiler complains about `operator=(const NonCopyable&amp;)`\n    // not accessible or something like that.\n    a = b;\n}\n</code></pre>\n<p>And since I'll never be able to actually use it, it doesn't matter that it's not exactly the canonical copy assignment operator. If I tried to use the copy assignment operator it would result in a compiler error, which is exactly what you want. </p>\n<hr>\n<p>\u2020 Of course, it does matter, stylistically speaking, if the copy assignment operator actually does something. Generally you want your operators to behave just like the built-in ones, so returning a <code>X&amp;</code> is good practice when you're actually doing assignment.</p>\n<blockquote>\n<p id=\"so_8634134_8634157_0\">\u2020\u2020 <strong>C++ Standard: 12.8 Copying class objects [class.copy]</strong></p>\n<p id=\"so_8634134_8634157_1\"><em>9</em> A user-declared <em>copy</em> assignment operator <code>X::operator=</code> is a non-static non-template member function of class <code>X</code> with exactly one\n  parameter of type <code>X</code>, <code>X&amp;</code>, <code>const X&amp;</code>, <code>volatile X&amp;</code> or <code>const\n  volatile X&amp;</code>.</p>\n</blockquote>\n</hr>", "LastActivityDate": "2011-12-26T09:03:12.037"}});