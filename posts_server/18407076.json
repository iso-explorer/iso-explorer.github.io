post_cb({"18407076": {"ViewCount": "233", "Body": "<p>why does creation of an object needs a constructor?\nEven if I don't define a constructor a default constructor is generated ..but why a constructor necessary?</p>\n", "Title": "why can't objects be created without a constructor?", "CreationDate": "2013-08-23T15:56:27.767", "LastActivityDate": "2016-02-26T09:33:41.417", "CommentCount": "5", "LastEditDate": "2016-02-26T09:33:41.417", "PostTypeId": "1", "LastEditorUserId": "2711672", "Id": "18407076", "Score": "-1", "OwnerUserId": "2711672", "Tags": "<c++><constructor>", "AnswerCount": "5"}, "18407244": {"Id": "18407244", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_18407076_18407244_0\">why can't objects be created without a constructor?</p>\n</blockquote>\n<p>This is more of a discussion on terminology than a real argument about the behavior. As you mention, in some cases there is nothing to be done during construction, so there should be no need for a constructor, right? Well, there is the concept of a <em>trivial-constructor</em> which is a constructor that does not do anything at all. For the sake of the standard document, it is easier to treat everything as having a (possibly trivial) constructor than to have to provide all the cases and exceptions in all places where it currently just states 'constructor'.</p>\n<p>Consider that every use of 'constructor' would have to be replaced by 'constructor or nothing if the type does not have any virtual functions or bases and no members that require the generation of a constructor'.</p>\n<p>This is the same reason why all virtual functions are called <em>overrider</em> even the first one in the hierarchy that by definition does not <em>override</em> anything. This form of generalization makes the language slightly easier to interpret, although not too many people will claim that section 8.5 on initialization is simple...</p>\n<p>Also note that, while all user defined types by definition have a constructor, the constructor is not <em>required</em> for the creation of objects. In particular for objects with <em>trivial-constructor</em> the lifetime starts when the memory for the object is allocated (the standard, knowing that <em>trivial</em> means nothing to be done does not even go through the hop of requiring that the constructor is run in that case.</p>\n<hr>\n<p>3.8 [basic.life]/1</p>\n<blockquote>\n<p id=\"so_18407076_18407244_1\">The lifetime of an object is a runtime property of the object. An object is said to have non-trivial initialization if it is of a class or aggregate type and it or one of its members is initialized by a constructor other than a trivial default constructor. [ Note: initialization by a trivial copy/move constructor is non-trivial initialization. \u2014 end note ] The lifetime of an object of type T begins when:</p>\n<p id=\"so_18407076_18407244_2\">-- storage with the proper alignment and size for type T is obtained, and</p>\n<p id=\"so_18407076_18407244_3\">-- if the object has non-trivial initialization, its initialization is complete.</p>\n</blockquote>\n<p>That second bullet used to read (C++03): <em>if T is a class type with a non-trivial constructor (12.1), the constructor call has completed.</em> Which more clearly stated that the constructor need not be executed. But the new wording expresses the intent in basically the same way. Only if the object has <em>non-trivial initialization</em>, the initialization needs to complete. For objects with <em>trivial-constructor</em> (trivial initialization) allocating the storage creates the object. Where does it matter?</p>\n<pre><code>struct T { int x; }; // implicitly defined trivial-constructor\nT *p = static_cast&lt;T*&gt;(malloc(sizeof *p));\n\n// *p is alive at this point, no need to do\nT *q;\n{ void *tmp = malloc(sizeof T);\n  q = new (tmp) T;              // call constructor\n}\n</code></pre>\n</hr>", "LastEditorUserId": "36565", "LastActivityDate": "2013-08-23T16:55:26.423", "Score": "8", "CreationDate": "2013-08-23T16:04:54.933", "ParentId": "18407076", "CommentCount": "7", "OwnerUserId": "36565", "LastEditDate": "2013-08-23T16:55:26.423"}, "18407594": {"Id": "18407594", "PostTypeId": "2", "Body": "<p>In a way, this is a slightly philosophical question. You can think of a constructor as a subroutine that turns some uninitialized memory into an object. Or you can think of it as a language feature that makes initialization easier to follow, write, and understand. You could even answer the question circularly: why does creation of an object needs a constructor? Because that's what creation of an object <em>is</em>, in a sense. If you don't have a constructor, what you're creating isn't an object.</p>\n<p>It may be that a particular constructor does nothing, but that's an implementation detail of that class. The fact that every class has a constructor means that the class <em>encapsulates</em> what initialization is necessary: to use the class safely, you don't need to know whether the constructor does anything. In fact, in the presence of inheritance, vtables, debug-tracking, and other compiler features, you might not even know whether the constructor does anything. (C++ complicates this slightly by calling some classes POD types, but the encapsulation holds as long as you don't need to know that something is of POD type.)</p>\n<p>The invocation of a constructor defines the point at which an object is created. In terms of language semantics, when the constructor finishes, the constructed object exists: before that, the object does not exist, and it is an error to use it as if it did. This is why <em>construction order</em> (that is, the order that member object and base class sub-object constructors are called) is so important in C++ and similar languages: if your constructor can throw an exception, it's necessary to destroy exactly those objects that have been constructed.</p>\n<p>To end up with a working program, the programmer, anyone who tries to understand the source code, the compiler and linker, the runtime library, and any other compilation tools, all need to have a shared idea of what the program means: the <em>semantics</em> of the program. Agreeing on the <em>lifetime</em> of an object\u2014when the compiler can run extra code to help create it, and when you can safely use it\u2014is actually a big part of this agreement. Constructors and destructors are part of defining this lifetime. Even if they happen to be empty sometimes, they provide a way for us to agree when an object is valid, thus making it easier (possible) to <em>specify</em> and <em>understand</em> the language.</p>\n", "LastActivityDate": "2013-08-23T16:25:48.867", "CommentCount": "3", "CreationDate": "2013-08-23T16:25:48.867", "ParentId": "18407076", "Score": "1", "OwnerUserId": "967945"}, "bq_ids": {"n4140": {"so_18407076_18407244_3": {"length": 6, "quality": 1.0, "section_id": 7189}, "so_18407076_18407244_2": {"length": 6, "quality": 1.0, "section_id": 7189}, "so_18407076_18407244_1": {"length": 33, "quality": 0.8461538461538461, "section_id": 7189}}, "n3337": {"so_18407076_18407244_3": {"length": 6, "quality": 1.0, "section_id": 6933}, "so_18407076_18407244_2": {"length": 6, "quality": 1.0, "section_id": 6933}, "so_18407076_18407244_1": {"length": 33, "quality": 0.8461538461538461, "section_id": 6933}}, "n4659": {"so_18407076_18407244_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 8697}, "so_18407076_18407244_2": {"length": 6, "quality": 1.0, "section_id": 8697}, "so_18407076_18407244_1": {"length": 29, "quality": 0.7435897435897436, "section_id": 8697}}}, "18407150": {"Id": "18407150", "PostTypeId": "2", "Body": "<p>Say you have a simple class :</p>\n<pre><code>class Foo\n{\n    int bar;\n}\n</code></pre>\n<p>What is the value of <code>bar</code> exactly? Maybe <em>you</em> don't care when your object gets its memory allocated, but the machine running your program needs to give it some value. That's what the constructor is for : initializing class members to some value.</p>\n", "LastActivityDate": "2013-08-23T16:00:32.293", "CommentCount": "4", "CreationDate": "2013-08-23T16:00:32.293", "ParentId": "18407076", "Score": "0", "OwnerUserId": "20043"}, "18407250": {"Id": "18407250", "PostTypeId": "2", "Body": "<p>Constructor is necessary to call the constructors on class members, except built-in types <a href=\"https://stackoverflow.com/questions/6773723/what-does-default-constructor-do-when-its-empty\">see</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-08-23T16:05:19.357", "Score": "0", "CreationDate": "2013-08-23T16:05:19.357", "ParentId": "18407076", "CommentCount": "3", "OwnerUserId": "2606524", "LastEditDate": "2017-05-23T10:28:05.593"}, "18407598": {"Id": "18407598", "PostTypeId": "2", "Body": "<p>Parametrized Constructors can take arguments. For example:</p>\n<pre><code>class example\n{\n     int p, q;\n   public:\n     example();\n     example(int a, int b);                         //parameterized constructor\n};\nexample :: example()\n{\n}\nexample :: example(int a, int b)\n{\n     p = a;\n     q = b;\n}\n</code></pre>\n<p>When an object is declared in a parameterized constructor, the initial values have to be passed as arguments to the constructor function. The normal way of object declaration may not work. The constructors can be called explicitly or implicitly. The method of calling the constructor implicitly is also called the shorthand method.</p>\n<pre><code>example e = example(0, 50);                     //explicit call\n\nexample e(0, 50);                               //implicit call\n</code></pre>\n<p>This is particularly useful to provide initial values to the object. \nAlso you will find important stuff on this page :\n<a href=\"http://en.wikipedia.org/wiki/Constructor_%28object-oriented_programming%29\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Constructor_%28object-oriented_programming%29</a></p>\n", "LastActivityDate": "2013-08-23T16:25:56.163", "CommentCount": "15", "CreationDate": "2013-08-23T16:25:56.163", "ParentId": "18407076", "Score": "0", "OwnerUserId": "2645870"}});