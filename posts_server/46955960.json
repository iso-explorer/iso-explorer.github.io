post_cb({"46955960": {"CommentCount": "8", "AcceptedAnswerId": "46956700", "CreationDate": "2017-10-26T13:41:09.193", "LastActivityDate": "2017-10-26T14:20:16.950", "PostTypeId": "1", "ViewCount": "59", "FavoriteCount": "0", "Title": "C++ How to assign ifstream content (from file) to string with offset (istreambuf_iterator)", "Id": "46955960", "Score": "4", "Body": "<p>i try to read parts of a binary file content into a string. Why a string? I need this for my message protocol (with protobuf).</p>\n<p>The following works very well:</p>\n<pre><code>std::string* data = new std::string();\nstd::ifstream ifs(\"C:\\\\data.bin\", std::ios::binary);\ndata-&gt;assign((std::istreambuf_iterator&lt;char&gt;(ifs)), (std::istreambuf_iterator&lt;char&gt;()));\n</code></pre>\n<p>But this is for reading the file from the beginning to end.\nI would like to read only parts at given position. For example begin at position byte 10:</p>\n<pre><code>std::string* data = new std::string();\nstd::ifstream ifs(\"C:\\\\data.bin\", std::ios::binary);\nifs.seekg((10);\ndata-&gt;assign((std::istreambuf_iterator&lt;char&gt;(ifs)), ???????);\n</code></pre>\n<p>But how to adjust the end or the offset? I did not find any example. I know there are examples with ifstream.read() into buffers. I used the assign into string method in my whole program and would really love to find a way doing this with offset.</p>\n<p>Can anyone help me? Thanks </p>\n", "Tags": "<c++><iterator><offset><ifstream><assign>", "OwnerUserId": "8837939", "AnswerCount": "1"}, "46956700": {"ParentId": "46955960", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-10-26T14:14:42.153", "Score": "2", "LastEditorUserId": "179910", "LastEditDate": "2017-10-26T14:20:16.950", "Id": "46956700", "OwnerUserId": "179910", "Body": "<p>Sorry, but this isn't generally possible.</p>\n<p>The standard only defines two circumstances under which <code>istreambuf_iterator</code>s will compare equal to each other:</p>\n<ol>\n<li>Immediately after constructing two iterators from the same stream, and</li>\n<li>when they're both end-of-stream iterators.</li>\n</ol>\n<p>Just to give an idea of what this means, consider that the sample code in the standard implements its <code>equal()</code> as follows (N4659, \u00a7[istreambuf.iterator.ops]/5):</p>\n<blockquote>\n<p id=\"so_46955960_46956700_0\">Returns: <code>true</code> if and only if both iterators are at end-of-stream, or neither is at end-of-stream, regardless of what <code>streambuf</code> object they use.</p>\n</blockquote>\n<p>So, for <em>any</em> pair of iterators they will compare not-equal if one is at end of stream, and the other is not and end of stream. For all other cases (both at end of stream, or neither at end of stream) they will compare equal (even if, for example, they aren't even derived from the same stream).</p>\n<p>It's not entirely clear to me that this is <em>required</em> behavior, but it's clearly <em>allowed</em> behavior--and not just allowed as an odd corner case that happened by accident, but as clearly documented, intended behavior.</p>\n", "LastActivityDate": "2017-10-26T14:20:16.950"}, "bq_ids": {"n4140": {"so_46955960_46956700_0": {"section_id": 5731, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_46955960_46956700_0": {"section_id": 5514, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_46955960_46956700_0": {"section_id": 7178, "quality": 0.9230769230769231, "length": 12}}}});