post_cb({"bq_ids": {"n4140": {"so_32308742_32308828_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 5962}}, "n3337": {"so_32308742_32308828_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 5731}}, "n4659": {"so_32308742_32308828_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 7451}}}, "32308742": {"ViewCount": "1035", "Body": "<p>I am trying to assign a pointer to lambda function to pointer to another lambda function. The code will speak for itself:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main(int argc, char *argv[]) {\n\n    auto l1 = []() { std::cout &lt;&lt; \"Lambda 1!\" &lt;&lt; std::endl; };\n    auto l2 = [] { std::cout &lt;&lt; \"Lambda 2!\" &lt;&lt; std::endl; };\n\n    auto l1p = &amp;l1;\n    l1p = &amp;l2; // Why can't I do this assignment?\n    return 0;\n}\n</code></pre>\n<p>Since the return types and argument of both lambda functions are the same, why can't I do this assignment?</p>\n", "AcceptedAnswerId": "32308828", "Title": "Assigning pointer to lambda function to pointer to another lambda function", "CreationDate": "2015-08-31T10:05:25.730", "Id": "32308742", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-08-31T17:50:01.040", "LastEditorUserId": "963881", "LastActivityDate": "2015-08-31T17:50:01.040", "Score": "12", "OwnerUserId": "963881", "Tags": "<c++><pointers><c++11><lambda>", "AnswerCount": "3"}, "32308828": {"Id": "32308828", "PostTypeId": "2", "Body": "<p>[expr.prim.lambda]/2:</p>\n<blockquote>\n<p id=\"so_32308742_32308828_0\">The type of the <em>lambda-expression</em> (which is also the type of the\n  closure object) is a <strong>unique</strong>, unnamed non-union class type \u2014 called\n  the <em>closure type</em> \u2014 whose properties are described below.</p>\n</blockquote>\n<p>That is, two closure types are always entirely distinct and unrelated. However, in your example, as neither of both lambdas captures anything, they can be converted to a function pointer of type <code>void(*)()</code>.<br>\nSo perhaps you meant to do</br></p>\n<pre><code>void (*l1p)() = l1;\nl1p = l2;\n</code></pre>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-08-31T12:05:00.957", "Score": "16", "CreationDate": "2015-08-31T10:09:30.120", "ParentId": "32308742", "CommentCount": "6", "OwnerUserId": "3647361", "LastEditDate": "2015-08-31T12:05:00.957"}, "32310955": {"Id": "32310955", "PostTypeId": "2", "Body": "<p>As an addition to <a href=\"https://stackoverflow.com/a/32308828/3233393\">Columbo's answer</a>, you can have both type deduction and lambda-to-function-pointer decaying by using <code>operator +</code> :</p>\n<pre><code>auto l1p = +l1; // l1p is void (*)()\n//         ^\nl1p = l2;\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-08-31T13:25:16.380", "Score": "9", "CreationDate": "2015-08-31T12:11:30.757", "ParentId": "32308742", "CommentCount": "0", "OwnerUserId": "3233393", "LastEditDate": "2017-05-23T11:44:46.360"}, "32308929": {"Id": "32308929", "PostTypeId": "2", "Body": "<p>Let's remove the syntactic sugar that the lambda functions provide us:</p>\n<pre><code>struct lambda1 {\n  void operator () {\n    std::cout &lt;&lt; \"Lambda 1!\" &lt;&lt; std::endl;\n  }\n};\nstruct lambda2 {\n  void operator () {\n    std::cout &lt;&lt; \"Lambda 2!\" &lt;&lt; std::endl;\n  }\n};\nint main(int argc, char *argv[]) {\n\n    auto l1 = Lambda1{};\n    auto l2 = Lambda2{};\n\n    auto l1p = &amp;l1; // l1p is a Lambda1 *\n    l1p = &amp;l2; // &amp;l2 is a Lambda2 *\n    return 0;\n}\n</code></pre>\n<p>This isn't the exact transformation done by the compiler, but I think it suffices to examine the issue:</p>\n<p>The two lambdas have each an own type, that is totally unrelated to their arguments, captured variables or return type. And of course, the types of lambdas are to each other unrelated, so you can obviously not assign a pointer to one from the address of the other.</p>\n<hr>\n<p>The solution in the other answer with the function pointer is pretty nice. If there weren't a \"you only pay for it when you use it\" doctrine for C++, we could have made lambda functions like</p>\n<pre><code>struct SomeLambda\n  : public LambdaBase&lt;\n        Capture&lt;int&gt;,\n        Arguments&lt;bool&gt;,\n        Return&lt;void&gt;&gt; {\n  // ...\n};\n/*\n  [integer]\n  (bool flag) {\n    if (flag) cout &lt;&lt; integer;\n  }\n*/\n</code></pre>\n<p>But for that to make any sense the base would need to be polymorphic (has a virtual member function), and that's a cost you don't need if you don't intend to do what you wanted.</p>\n</hr>", "LastEditorUserId": "1116364", "LastActivityDate": "2015-08-31T10:36:13.803", "Score": "7", "CreationDate": "2015-08-31T10:15:09.837", "ParentId": "32308742", "CommentCount": "2", "OwnerUserId": "1116364", "LastEditDate": "2015-08-31T10:36:13.803"}});