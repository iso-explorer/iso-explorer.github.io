post_cb({"18771299": {"ViewCount": "182", "Body": "<p>Using C++03:</p>\n<p>In foo.h:</p>\n<pre><code>class Foo {\n    public:\n        // Declare integral static constant with an initializer\n        static const int some_constant = 42;\n};\n</code></pre>\n<p>In foo.cc:</p>\n<pre><code>// Define and reserve storage for Foo::some_constant\nconst int Foo::some_constant;\n</code></pre>\n<p>In bar.cc:</p>\n<pre><code>#include &lt;foo.h&gt;\n// stuff that uses Foo::some_constant;\n</code></pre>\n<p>It has long been my understanding that the above is the correct way to do this. A class-scoped static is permitted to have an initializer if it is of integral type and the initializer is a constant expression. Similarly, you must always declare storage for a static in exactly one translation unit (mod templates, but lets ignore that).</p>\n<p>However, MSVC 2010, 2012, and apparently 2013 RC all fail to link a program containing both foo.cc and bar.cc, claiming that Foo::some_constant is multiply defined.</p>\n<p>Have I misunderstood something and done this wrong, or is VC in error here? If the latter, does anyone have a reference to a bug report or something similar?</p>\n<p>Please don't tell me to move the initializer into the .cpp file. I know I can do that, but for now I'm more interested in this from a language rules and compiler quality-of-implementation standpoint, rather than workarounds.</p>\n", "AcceptedAnswerId": "18774193", "Title": "Does MSVC mishandle the linkage of class-scoped statics with integral constant initializers?", "CreationDate": "2013-09-12T18:01:59.487", "Id": "18771299", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-09-13T11:25:50.107", "Score": "3", "OwnerUserId": "776473", "Tags": "<c++><visual-c++>", "AnswerCount": "4"}, "18774193": {"Id": "18774193", "PostTypeId": "2", "Body": "<p>You're right; the way you wrote it is correct and VS is wrong.</p>\n<p>However, VS probably gets it wrong because you haven't disabled compiler extensions. If you compile with the <code>/Za</code> flag then it should work correctly.</p>\n<p>Alternatively, you can wrap the definition in a preprocessor <code>#if</code> block:</p>\n<pre><code>#if !_MSC_EXTENSIONS\n// Define and reserve storage for Foo::some_constant\nconst int Foo::some_constant;\n#endif\n</code></pre>\n", "LastActivityDate": "2013-09-12T20:56:35.880", "CommentCount": "3", "CreationDate": "2013-09-12T20:56:35.880", "ParentId": "18771299", "Score": "2", "OwnerUserId": "2491746"}, "bq_ids": {"n4140": {"so_18771299_18785180_0": {"length": 35, "quality": 0.6862745098039216, "section_id": 7034}}, "n3337": {"so_18771299_18785180_0": {"length": 35, "quality": 0.6862745098039216, "section_id": 6780}}, "n4659": {"so_18771299_18785180_0": {"length": 35, "quality": 0.6862745098039216, "section_id": 8531}}}, "18774072": {"Id": "18774072", "PostTypeId": "2", "Body": "<p>Move the initialization from the declaration to the definition, i.e. from foo.h into foo.cc.</p>\n<p>foo.cc:</p>\n<pre><code>// Define and reserve storage for Foo::some_constant\nconst int Foo::some_constant = 42;\n</code></pre>\n<p>If both foo.cc and bar.cc <code>#include \"foo.h\"</code> the compiler sees the initialization twice and complains about multiple definitions. foo.h should read</p>\n<pre><code>class Foo {\npublic:\n    // Declare integral static constant here, initialize outside\n    static const int some_constant;\n};\n</code></pre>\n", "LastActivityDate": "2013-09-12T20:49:30.650", "CommentCount": "2", "CreationDate": "2013-09-12T20:49:30.650", "ParentId": "18771299", "Score": "0", "OwnerUserId": "2750373"}, "18771598": {"Id": "18771598", "PostTypeId": "2", "Body": "<p>If you use an initializer to initialize a static const member, the declaration outside the class is not needed. For example:</p>\n<pre><code>namespace std\n{\n    template&lt;typename T , T val&gt;\n    struct integral_constant\n    {\n        typedef T value_type;\n        static const T value = val;\n    };\n}\n</code></pre>\n", "LastActivityDate": "2013-09-12T18:18:14.810", "CommentCount": "6", "CreationDate": "2013-09-12T18:18:14.810", "ParentId": "18771299", "Score": "1", "OwnerUserId": "1609356"}, "18785180": {"Id": "18785180", "PostTypeId": "2", "Body": "<p>MSVC is incorrect base on the C++ standard. The static member <code>some_constant</code> in header file is not an definition when included in other CPP. So there shouldn't be multiple symbole defintion. Following is quote from C++ standard (emphasis mine).</p>\n<blockquote>\n<p id=\"so_18771299_18785180_0\"><strong>A declaration is a de\ufb01nition unless</strong> it declares a function without\n  specifying the function\u2019s body (8.4), it contains the extern speci\ufb01er\n  (7.1.1) or a linkage-speci\ufb01cation25 (7.5) and neither an initializer\n  nor a function- body, <strong>it declares a static data member in a class\n  de\ufb01nition</strong> (9.2, 9.4), it is a class name declaration (9.1), it is an\n  opaque-enum-declaration (7.2), it is a template-parameter (14.1), it\n  is a parameter-declaration (8.3.5) in a function declarator that is\n  not the declarator of a function-de\ufb01nition, or it is a typedef\n  declaration (7.1.3), an alias-declaration (7.1.3), a using-declaration\n  (7.3.3), a static_assert-declaration (Clause 7), an attribute-\n  declaration (Clause 7), an empty-declaration (Clause 7), or a\n  using-directive (7.3.4).</p>\n</blockquote>\n", "LastActivityDate": "2013-09-13T11:25:50.107", "CommentCount": "0", "CreationDate": "2013-09-13T11:25:50.107", "ParentId": "18771299", "Score": "1", "OwnerUserId": "2428052"}});