post_cb({"46963794": {"CommentCount": "0", "ViewCount": "35", "CreationDate": "2017-10-26T21:05:07.273", "LastActivityDate": "2017-10-26T21:39:56.413", "Title": "How to use the current class template as template parameter for another template?", "AcceptedAnswerId": "46964265", "PostTypeId": "1", "Id": "46963794", "Score": "0", "Body": "<p>I'm using recursive templates classes that inherit recursively.<br>\nI'm trying to define an abstract way of getting the n-th base (like base 0 is the current class, base 1 is its base, base 2 is the base's base etc.).  </br></p>\n<p>(In this example the template parameters are <code>size_t</code> but the same principle applies with <code>typename</code> or <code>class</code>.)</p>\n<p>I can do this fine using a helper struct, partially specialized. But I want to make it independent of the template (and not make a helper struct whenever I have a recursive template), as follows:</p>\n<pre><code>namespace helper\n{\n    template&lt;template&lt;size_t...&gt; typename templ, size_t pos, size_t s0, size_t... rest&gt;\n    struct getter\n    {\n        typedef typename getter&lt;templ, pos - 1, rest...&gt;::type type;\n        type &amp;operator()(templ&lt;s0, rest...&gt; &amp;s)\n        {\n            getter&lt;templ, pos - 1, rest...&gt; getter;\n            return getter(static_cast&lt;templ&lt;rest...&gt;&amp;&gt; (s));\n        }\n    };\n    template&lt;template&lt;size_t...&gt; typename templ, size_t s0, size_t... rest&gt;\n    struct getter&lt;templ, 0, s0, rest...&gt;\n    {\n        typedef templ&lt;s0, rest...&gt; type;\n        type &amp;operator()(templ&lt;s0, rest...&gt; &amp;s)\n        {\n            return s;\n        }\n    };\n}\n</code></pre>\n<p>Now, in my template class, I want to use this helper to make a function <code>get&lt;size_t n&gt;()</code> that returns me a reference to the n-th base (code fails to compile at <code>get</code> declaration):</p>\n<pre><code>template&lt;size_t...&gt;\nstruct record {};\n\ntemplate&lt;size_t n, size_t... rest&gt;\nstruct record&lt;n, rest...&gt; : record&lt;rest...&gt;, value&lt;n&gt;\n{\n    template&lt;size_t pos&gt;\n    typename helper::getter&lt;record, pos, n, rest...&gt;::type::value_type &amp;get()\n    {\n        helper::getter&lt;record, pos, n, rest...&gt; getter;\n        return static_cast&lt;typename helper::getter&lt;record, pos, n, rest...&gt;::type::value_type&amp;&gt;(getter(*this));\n    }\n};\n</code></pre>\n<p>This fails because, inside the <code>record</code> template, <code>record</code> is the final class and not the template. I would like to use something like \"current template\" instead of \"currently instantiated class\".  </p>\n<p>The only workaround I've found (which works under Visual Studio 2015) is to use a global alias to replicate the template:</p>\n<pre><code>template&lt;size_t...s&gt;\nusing g_record = record&lt;s...&gt;;\n</code></pre>\n<p>and then modify the get declaration to call the global alias (which points to the same type):</p>\n<pre><code>...\ntemplate&lt;size_t pos&gt;\ntypename helper::getter&lt;g_record, pos, n, rest...&gt;::type::value_type &amp;get()\n{\n    helper::getter&lt;g_record, pos, n, rest...&gt; getter;\n    return static_cast&lt;typename helper::getter&lt;g_record, pos, n, rest...&gt;::type::value_type&amp;&gt;(getter(*this));\n}\n...\n</code></pre>\n<p>Is there a more direct or a \"correct\" way to do this?</p>\n", "Tags": "<c++><templates><recursion><metaprogramming>", "OwnerUserId": "1394947", "AnswerCount": "2"}, "46964265": {"ParentId": "46963794", "CommentCount": "0", "Body": "<p>It should not be necessary to use any tricks to get the compiler to realize you are using <code>record</code> as a template name instead of a type name referring to the current instantiation. See [temp.local]/1, emphasis mine:</p>\n<blockquote>\n<p id=\"so_46963794_46964265_0\">Like normal (non-template) classes, class templates have an <em>injected-class-name</em> (Clause 9). The <em>injected-class-name</em> can be used as a <em>template-name</em> or a <em>type-name</em>. When it is used with a <em>template-argument-list</em>,\n  <strong>as a <em>template-argument</em> for a template <em>template-parameter</em></strong>, or as the final identifier in the <em>elaborated-type-specifier</em> of a friend class template declaration, <strong>it refers to the class template itself</strong>. Otherwise, it is equivalent to the <em>template-name</em> followed by the <em>template-parameters</em> of the class template enclosed in <code>&lt;&gt;</code>.</p>\n</blockquote>\n<p>The workaround you posted is correct, but it should not be needed; this is a bug in the compiler.</p>\n", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "46964265", "Score": "1", "CreationDate": "2017-10-26T21:39:56.413", "LastActivityDate": "2017-10-26T21:39:56.413"}, "46963928": {"ParentId": "46963794", "CommentCount": "0", "Body": "<p>Looks like I was a bit hasty in my digging.</p>\n<p>Apparently using the template's fully qualified name works (in my example it's <code>::record</code>):</p>\n<pre><code>    template&lt;size_t pos&gt;\n    typename helper::getter&lt;::record, pos, n, rest...&gt;::type::value_type &amp;get()\n    {\n        helper::getter&lt;::record, pos, n, rest...&gt; getter;\n        return static_cast&lt;typename helper::getter&lt;::record, pos, n, rest...&gt;::type::value_type&amp;&gt;(getter(*this));\n    }\n</code></pre>\n", "OwnerUserId": "1394947", "PostTypeId": "2", "Id": "46963928", "Score": "2", "CreationDate": "2017-10-26T21:15:18.683", "LastActivityDate": "2017-10-26T21:15:18.683"}, "bq_ids": {"n4140": {"so_46963794_46964265_0": {"section_id": 179, "quality": 0.9736842105263158, "length": 37}}, "n3337": {"so_46963794_46964265_0": {"section_id": 173, "quality": 0.9736842105263158, "length": 37}}, "n4659": {"so_46963794_46964265_0": {"section_id": 184, "quality": 0.9736842105263158, "length": 37}}}});