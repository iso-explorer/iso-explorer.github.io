post_cb({"42596389": {"ParentId": "42596060", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_42596060_42596389_0\"><strong>[class.copy]/9</strong> If the definition of a class <code>X</code> does not explicitly declare a move constructor, one will be implicitly declared as defaulted if and only if</p>\n<p id=\"so_42596060_42596389_1\">(9.4) \u2014 <code>X</code> does not have a user-declared destructor.</p>\n</blockquote>\n<p><code>Base1</code> has a user-declared destructor, so no move constructor for it. And copy constructor is implicitly declared as deleted due to non-copyable member. So <code>Base1</code> can be neither copied nor moved, and of course <code>Base2</code> and <code>Derived</code> together with it.</p>\n", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "42596389", "Score": "6", "CreationDate": "2017-03-04T13:08:03.080", "LastActivityDate": "2017-03-04T13:08:03.080"}, "42596060": {"CommentCount": "8", "ViewCount": "278", "PostTypeId": "1", "LastEditorUserId": "5538150", "CreationDate": "2017-03-04T12:32:17.263", "LastActivityDate": "2017-03-04T13:08:03.080", "Title": "Unreasonably deleted move constructor", "AcceptedAnswerId": "42596389", "LastEditDate": "2017-03-04T12:40:34.377", "Id": "42596060", "Score": "1", "Body": "<p>I have a class with explicitely deleted copy constructor named, let's say, <code>NonCopyable</code>. Then there's a class <code>Base1</code> with a member of type <code>NonCopyable</code>. And another class <code>Base2</code> with <code>Base1</code> as parent. And finally - a <code>Derivative</code> class which parent is <code>Base2</code>.  </p>\n<p>Since <code>NonCopyable</code> is non-copyable, it's obvious that <code>Base1</code>, <code>Base2</code> and <code>Derivative</code> will be also non-copyable. But it seems like there's been also move constructor (and assign operator) deleted.  </p>\n<p>Test it here:</p>\n<ul>\n<li><a href=\"http://coliru.stacked-crooked.com/a/f55648a83a53211f\" rel=\"nofollow noreferrer\">GCC</a></li>\n<li><a href=\"http://rextester.com/HAX71321\" rel=\"nofollow noreferrer\">MSVC</a></li>\n</ul>\n<p>Following line gives those errors:<br>\n<code>Derived d1, d2 = std::move(d1);</code> </br></p>\n<blockquote>\n<p id=\"so_42596060_42596060_0\"><strong>GCC:</strong> 'Derived::Derived(Derived&amp;&amp;)' is implicitly deleted because the default definition would be ill-formed:\n     class Derived :<br>\n<em>the rest of errors just claims that <code>Base1</code> and <code>Base2</code> copy ctors are implicitly deleted which is not weird</em></br></p>\n<p id=\"so_42596060_42596060_1\"><strong>MSVC:</strong> error C2280: 'Derived::Derived(const Derived &amp;)': attempting to reference a deleted function  </p>\n</blockquote>\n<p>In provided links there's also commented lines which gives similar errors. Please uncomment them to see more errors I'd like to show you (e.g. with <code>remove_if</code> uncommented it complains about deleted move <em>(on GCC)</em> /copy <em>(on MSVC)</em> assign operator).<br>\nWhat I want to achieve is make Derivative (and its bases also) moveable, but not copyable.  </br></p>\n<p>I'm working with Visual Studio 2015 and getting exactly the same error as in the msvc link I provided, but I'm not sure what version of MSVC is used to compile on <em>rextester.com</em>.  </p>\n<p>I'm pasting the code also here at the request of @Richard Critten:  </p>\n<pre><code>    class NonCopyable\n    {\n    public:\n       NonCopyable() { }\n       NonCopyable(const NonCopyable &amp;) = delete;\n       NonCopyable &amp; operator=(const NonCopyable &amp;) = delete;\n       NonCopyable(NonCopyable &amp;&amp;) { }\n       NonCopyable &amp; operator=(NonCopyable &amp;&amp;) { return *this; }\n    };\n\n     class Base1\n     {\n     public:\n          virtual ~Base1() = default;\n\n     private:\n          NonCopyable m;\n     };\n\n     class Base2 :\n        public Base1\n     {\n     public:\n          virtual ~Base2() = default;\n     };\n\n     class Derived :\n        public Base2\n     {\n     };\n\n\n\nint main()\n{\n    std::vector&lt;Derived&gt; v;\n    //std::remove_if(v.begin(), v.end(), [](const Derived &amp;) { return true; });\n    //v.emplace_back();\n    Derived d1, d2 = std::move(d1);\n}\n</code></pre>\n", "Tags": "<c++><c++11><inheritance><move-semantics>", "OwnerUserId": "5538150", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_42596060_42596389_1": {"section_id": 458, "quality": 1.0, "length": 4}, "so_42596060_42596389_0": {"section_id": 458, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_42596060_42596389_1": {"section_id": 449, "quality": 1.0, "length": 4}, "so_42596060_42596389_0": {"section_id": 449, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_42596060_42596389_1": {"section_id": 481, "quality": 1.0, "length": 4}, "so_42596060_42596389_0": {"section_id": 481, "quality": 0.9230769230769231, "length": 12}}}});