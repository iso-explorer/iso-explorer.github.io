post_cb({"bq_ids": {"n4140": {"so_46738487_46743940_1": {"length": 13, "quality": 0.8125, "section_id": 7202}, "so_46738487_46743940_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 6076}, "so_46738487_46743940_4": {"length": 10, "quality": 0.9090909090909091, "section_id": 3228}, "so_46738487_46743940_3": {"length": 19, "quality": 0.7916666666666666, "section_id": 5791}}, "n3337": {"so_46738487_46743940_1": {"length": 13, "quality": 0.8125, "section_id": 6946}, "so_46738487_46743940_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 5844}, "so_46738487_46743940_4": {"length": 10, "quality": 0.9090909090909091, "section_id": 3101}, "so_46738487_46743940_3": {"length": 19, "quality": 0.7916666666666666, "section_id": 5564}}, "n4659": {"so_46738487_46743940_1": {"length": 13, "quality": 0.8125, "section_id": 8711}, "so_46738487_46743940_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 7572}, "so_46738487_46743940_4": {"length": 10, "quality": 0.9090909090909091, "section_id": 3985}, "so_46738487_46743940_3": {"length": 19, "quality": 0.7916666666666666, "section_id": 7248}}}, "46743940": {"Id": "46743940", "PostTypeId": "2", "Body": "<p><strong>General case</strong></p>\n<p>Yes, the pointer to the object-representation of a suboject is also a pointer to <strong>a part of</strong> the object-representation of the containing complete object.  </p>\n<p>This can be deduced from:  </p>\n<blockquote>\n<p id=\"so_46738487_46743940_0\"><strong>1.8/1:</strong> An object is a region of storage. </p>\n<p id=\"so_46738487_46743940_1\"><strong>3.9/4:</strong> The object representation of an object of type T is the sequence of N unsigned char objects taken up by the object of type T, where N equals sizeof(T). </p>\n<p id=\"so_46738487_46743940_2\"><strong>5.3.3/1:</strong> The sizeof operator yields the number of bytes in the object representation of its operand.</p>\n<p id=\"so_46738487_46743940_3\"><strong>1.8/2:</strong> Objects can <strong>contain</strong> other objects, called subobjects. A subobject can be a member subobject, a base class subobject,\n  or an array element. An object that is not a subobject of\n  any other object is called a complete object.</p>\n</blockquote>\n<p>The fact that an object is a region of storage and that the subobject is contained within the region of storage means that the suboject representation is contained in the object representation.  </p>\n<p>As explained in <a href=\"https://stackoverflow.com/a/46736040/3723423\">this other answer</a>, the pointer to the object representation is in fact the pointer to the object.    </p>\n<p><strong>Specific case of the array</strong></p>\n<p>Yes, the pointer to the object representation of a subobject (i.e. in this case an array element) is a pointer to <strong>an element of</strong> the object-representation of the containing complete object (i.e. in this case the array).  </p>\n<blockquote>\n<p id=\"so_46738487_46743940_4\"><strong>8.4.3/1:</strong> (...) An object of array type contains a <strong>contiguously</strong> allocated non-empty set of N subobjects of type T.  (...)</p>\n</blockquote>\n<p>So by definition: </p>\n<ul>\n<li><p>the elements of the array are contiguously allocated, meaning that there is no empty space between the elements.  </p></li>\n<li><p>the object representation of each element is a sequence of sizeof(T) unsigned chars, and the object representation of the complete array is the resulting N*sizeof(T) unsigned chars.  </p></li>\n</ul>\n<p>We can then deduce:  </p>\n<ul>\n<li><p>As explained in <a href=\"https://stackoverflow.com/a/46736040/3723423\">this other answer</a>, the pointer to the object representation is in fact the pointer to the object.</p></li>\n<li><p>the address of the k-th element in the array corresponds to the k-th element in the object representation of the array, and is by construction at an offset of k*sizeof(T) unsigned chars of the address of the array representation.</p></li>\n</ul>\n<p>So the last 2 statements of your code are not undefined behavior, as long as you remain within the boundaries of <code>is</code> </p>\n", "LastActivityDate": "2017-10-14T11:20:34.157", "CommentCount": "0", "CreationDate": "2017-10-14T11:20:34.157", "ParentId": "46738487", "Score": "3", "OwnerUserId": "3723423"}, "46738487": {"ViewCount": "98", "Body": "<p>Let's consider this code:</p>\n<pre><code>int i;\nint is[10]{};\n\nunsigned char * p = reinterpret_cast&lt;unsigned char*&gt;(&amp;i);\n//p defined to point to the object-representation of the first element of array ints\nunsigned char * ps = reinterpret_cast&lt;unsigned char*&gt;(&amp;is[0]);\n\np += sizeof(int);\nps += sizeof(int);\n//now ps points to the end of ints[0] and p point to the end of i;\n\np += sizeof(int); //Undefined behavior according to [expr.add]\n\nps += sizeof(int); //Undefined behavior?\nunsigned char c = *ps;//Undefined behavior?\n</code></pre>\n<p>If we consider that <code>ps</code> points to the <a href=\"http://eel.is/c++draft/basic.types#4\" rel=\"nofollow noreferrer\">object-representation</a> of <code>is[0]</code> then according to pointer arithmetic rule, the behavior is undefined at the two last code line.</p>\n<p>Nevertheless, if <code>ps</code> is also a pointer to the <em>object-representation</em> of the array of int <code>is</code> the behavior is defined.</p>\n<p>So my question is: does a pointer to the <em>object-representation</em> of a <a href=\"http://eel.is/c++draft/intro.object#2\" rel=\"nofollow noreferrer\">suboject</a> is also a pointer to an element of the <em>object-representation</em> of the containing complete object?</p>\n", "AcceptedAnswerId": "46743940", "Title": "Can one get a pointer to a complete object representation element from a pointer to a suboject?", "CreationDate": "2017-10-13T21:49:52.377", "Id": "46738487", "CommentCount": "12", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-10-14T13:48:22.103", "LastEditorUserId": "5632316", "LastActivityDate": "2017-10-14T13:48:22.103", "Score": "4", "OwnerUserId": "5632316", "Tags": "<c++><language-lawyer><pointer-arithmetic>", "AnswerCount": "2"}, "46740758": {"Id": "46740758", "PostTypeId": "2", "Body": "<p>There's no such thing as a \"pointer to the object representation\".  You have a pointer which holds the object's address, and that pointer can be derived safely or unsafely.</p>\n<p>The \"object representation\" comes into play when you read within the object's address range using an lvalue of narrow character type, not when the pointer is formed or converted.</p>\n<p>Nothing in the rules for <code>reinterpret_cast&lt;unsigned char*&gt;(p)</code> says anything about the result being some special \"pointer to object representation\".  It's still just another alias for the same object.</p>\n", "LastActivityDate": "2017-10-14T04:04:51.507", "CommentCount": "3", "CreationDate": "2017-10-14T04:04:51.507", "ParentId": "46738487", "Score": "1", "OwnerUserId": "103167"}});