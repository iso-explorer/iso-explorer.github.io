post_cb({"19126975": {"ParentId": "19126609", "CommentCount": "1", "Body": "<p>Although it helps understanding, demonstrating this problem doesn't require an <code>extern</code> variable defined in another translation unit. Anything that may not appear in a constant expression is sufficient:</p>\n<pre><code>int i = 42;\n// neither const nor constexpr\n// lvalue-to-rvalue conversion of it may not appear in a constant expression\n\nconstexpr int j = i; // error\n\ntemplate&lt;class T&gt;\nconstexpr int func_templ() { return i; }\nconstexpr int func      () { return i; }  // error\n\nint main() {\n    // constexpr int rest = func_templ&lt;void&gt;();  // OK, it is compile error\n    int result = func_templ&lt;void&gt;();\n        result = func();\n}\n</code></pre>\n<p>The function <code>func</code> itself makes the program ill-formed because of [dcl.constexpr]/5:</p>\n<blockquote>\n<p id=\"so_19126609_19126975_0\">For a <code>constexpr</code> function, if no function argument values exist such that the function invocation substitution would produce a constant expression (5.19), the program is ill-formed; no diagnostic required.</p>\n</blockquote>\n<p>A <code>constexpr</code> function is <strong>not</strong> required to contain only constant expressions. But in this case, it always yields a non-constant-expression. Therefore the program is ill-formed. For the function template <code>func_temp</code>, it's the same problem. However, g++ and clang++ don't produce a diagnostic message. Maybe because name lookup is more complicated for templates, even if it is an ordinary non-dependent lookup in this case.</p>\n<p>To demonstrate the error, here's a version that compiles fine:</p>\n<pre><code>int i = 42;\n\nconstexpr int func(bool p)\n{ return p ? 42 : i; }\n\nint main() {\n      constexpr int result0 = func(true);   // works\n    //constexpr int result1 = func(false);  // error\n                int result2 = func(false);  // works\n}\n</code></pre>\n", "OwnerUserId": "420683", "PostTypeId": "2", "Id": "19126975", "Score": "2", "CreationDate": "2013-10-01T22:20:33.633", "LastActivityDate": "2013-10-01T22:20:33.633"}, "19126609": {"CommentCount": "1", "AcceptedAnswerId": "19126975", "PostTypeId": "1", "LastEditorUserId": "2697065", "CreationDate": "2013-10-01T21:51:38.033", "LastActivityDate": "2013-10-01T22:33:58.810", "LastEditDate": "2013-10-01T22:33:58.810", "ViewCount": "201", "FavoriteCount": "1", "Title": "C++11 non-const constexpr func with template: OK, without template: error", "Id": "19126609", "Score": "4", "Body": "<p>I use g++ 4.8.1.\nCompile:<br>\ng++ -std=c++11 test23.cpp test24.cpp -o a</br></p>\n<hr>\n<p>test24.cpp:</p>\n<pre><code>int gi1=98;\n</code></pre>\n<hr>\n<p>test23.cpp:</p>\n<pre><code>extern int gi1;   // compiler cannot predict the value\n\ntemplate&lt;class T&gt;\nconstexpr bool f8() {\n   return (gi1 &gt; 5);\n}\n\n// constexpr bool ce = f8&lt;float&gt;();  // OK, it is compile error\n\nint main() {\n  bool bz1 = f8&lt;float&gt;();\n}\n</code></pre>\n<hr>\n<p>Compiles without error. Shouldn't it be error ?<br>\nNow without template:</br></p>\n<hr>\n<p>test23.cpp:</p>\n<pre><code>extern int gi1;\n\nconstexpr bool f8() {\n   return gi1 &gt; 5;\n}\n\nint main() {\n  bool bz1 = f8();\n}\n</code></pre>\n<hr>\n<p>OK, Compile error:\ntest23.cpp:4:1: error: the value of \u2018gi1\u2019 is not usable in a constant expression<br>\ntest23.cpp:1:12: note: \u2018int gi1\u2019 is not const</br></p>\n<hr>\n<p>Thank you in advance</p>\n</hr></hr></hr></hr></hr></hr>", "Tags": "<templates><c++11>", "OwnerUserId": "2697065", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_19126609_19126975_0": {"section_id": 5421, "quality": 0.631578947368421, "length": 12}}, "n3337": {"so_19126609_19126975_0": {"section_id": 5216, "quality": 0.8947368421052632, "length": 17}}, "n4659": {"so_19126609_19126975_0": {"section_id": 6843, "quality": 0.631578947368421, "length": 12}}}});