post_cb({"bq_ids": {"n4140": {"so_24788262_24788262_0": {"length": 13, "quality": 0.5652173913043478, "section_id": 7240}, "so_24788262_24788755_0": {"length": 40, "quality": 0.5405405405405406, "section_id": 7240}}, "n3337": {"so_24788262_24788262_0": {"length": 13, "quality": 0.5652173913043478, "section_id": 6984}, "so_24788262_24788755_0": {"length": 40, "quality": 0.5405405405405406, "section_id": 6984}}}, "24788262": {"ViewCount": "1099", "Body": "<p>There is a quote from <a href=\"http://en.cppreference.com/w/cpp/language/object#Alignment\" rel=\"noreferrer\">cppreference</a>:</p>\n<blockquote>\n<p id=\"so_24788262_24788262_0\">Every object type has the property called alignment requirement, which\n  is an integer value (of type std::size_t, always a power of 2)\n  representing the number of bytes between successive addresses at which\n  objects of this type can be allocated.</p>\n</blockquote>\n<p>I understand, this reference is non-normative. But there is no something about value of <code>alignof(T)</code> in the standard, rather than it is no more than <code>alignof(std::max_align_t)</code>.</p>\n<p>It is not obviously, that alignment is power of 2. Why does alignment not be a 3?</p>\n", "AcceptedAnswerId": "24788755", "Title": "Why alignment is power of 2?", "CreationDate": "2014-07-16T18:39:14.203", "Id": "24788262", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-07-16T19:30:47.233", "Score": "9", "OwnerUserId": "2786156", "Tags": "<c++><memory-alignment>", "AnswerCount": "2"}, "24788755": {"PostTypeId": "2", "Body": "<p>The standard has the final word for the language, so here a quote of that section. I bolded the power-of-2 requirement:</p>\n<blockquote>\n<h3>3.11 Alignment <code>[basic.align]</code></h3>\n<p id=\"so_24788262_24788755_0\">1 Object types have alignment requirements (3.9.1, 3.9.2) which place restrictions on the addresses at which an object of that type may be allocated. An alignment is an implementation-defined integer value representing the number of bytes between successive addresses at which a given object can be allocated. An object type imposes an alignment requirement on every object of that type; stricter alignment can be requested using the alignment specifier (7.6.2).<br>\n  2 A fundamental alignment is represented by an alignment less than or equal to the greatest alignment supported by the implementation in all contexts, which is equal to alignof(std::max_align_t) (18.2). The alignment required for a type might be different when it is used as the type of a complete object and when it is used as the type of a subobject. <em>[ Example:</em></br></p>\n<pre><code>struct B { long double d; };\nstruct D : virtual B { char c; }\n</code></pre>\n<p id=\"so_24788262_24788755_1\">When D is the type of a complete object, it will have a subobject of type B, so it must be aligned\n  appropriately for a long double. If D appears as a subobject of another object that also has B as a virtual base class, the B subobject might be part of a different subobject, reducing the alignment requirements on the D subobject. <em>\u2014end example ]</em> The result of the alignof operator reflects the alignment requirement of the type in the complete-object case.<br>\n  3 An extended alignment is represented by an alignment greater than alignof(std::max_align_t). It is\n  implementation-defined whether any extended alignments are supported and the contexts in which they\n  are supported (7.6.2). A type having an extended alignment requirement is an over-aligned type. <em>[ Note:</em> every over-aligned type is or contains a class type to which extended alignment applies (possibly through a non-static data member). <em>\u2014end note ]</em><br>\n  4 Alignments are represented as values of the type <code>std::size_t</code>. Valid alignments include only those values returned by an alignof expression for the fundamental types plus an additional implementation-defined set of values, which may be empty. <strong>Every alignment value shall be a non-negative integral power of two.</strong><br>\n  5 Alignments have an order from weaker to stronger or stricter alignments. Stricter alignments have larger alignment values. An address that satisfies an alignment requirement also satisfies any weaker valid alignment requirement.</br></br></br></p>\n</blockquote>\n<p>Why did all implementations conform to that requirement (That's part of the reason it could be included at all)?</p>\n<p>Well, because it is natural to multiply / divide / mask powers of 2 in <strong>binary</strong>, and all systems were (excluding some really ancient ones), are, and for the foreseeable future will stay <strong>fundamentally binary</strong>.<br>\nBeing natural means it is much more efficient than any other multiplications / divisions / modulo arithmetic, sometimes by orders of magnitude.</br></p>\n<p>As <a href=\"https://stackoverflow.com/questions/24788262/why-alignment-is-power-of-2/24788755?noredirect=1#comment38472446_24788755\">@MooingDuck</a> points out, this fundamental binary nature of computing platforms has already pervaded the language and its standard to such an extent, trying to build a non-binary conforming implementation is about on-par with untying the gordian knot without just cutting it. There are really few computer languages where that's not true.</p>\n<p>Related, a table of word sizes on wikipedia: <a href=\"http://en.wikipedia.org/wiki/Word_(computer_architecture)#Table_of_word_sizes\" rel=\"nofollow noreferrer\">http://en.wikipedia.org/wiki/Word_(computer_architecture)#Table_of_word_sizes</a></p>\n", "LastActivityDate": "2014-07-16T19:30:47.233", "LastEditorUserId": "-1", "Id": "24788755", "CommentCount": "1", "CreationDate": "2014-07-16T19:09:18.863", "ParentId": "24788262", "Score": "7", "OwnerUserId": "3204551", "LastEditDate": "2017-05-23T12:16:59.327"}, "24788331": {"PostTypeId": "2", "Body": "<p>That's how computers are built. </p>\n<p>A computer has a natural 'word' size that is handled more easily than other sizes. On 64-bit CPUs, the size is 8-bytes. Operating on 8-bytes is most efficient. The hardware is built in a way that fetching memory that is aligned to this word size is also more efficient. So alignment is usually based on the CPU's word size.</p>\n<p>Word sizes are powers of two because, again, that's how computers are built. Everything comes down to bits - so does the number of bits in a word. It's easier to design the hardware where the number of bits in a word is itself a power of two.</p>\n", "LastActivityDate": "2014-07-16T18:43:46.353", "Id": "24788331", "CommentCount": "14", "CreationDate": "2014-07-16T18:43:46.353", "ParentId": "24788262", "Score": "4", "OwnerUserId": "871910"}});