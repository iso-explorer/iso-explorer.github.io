post_cb({"11800201": {"Id": "11800201", "PostTypeId": "2", "Body": "<p>1) Ilya's example should be invalid code based on the fact that the <strong>static constexpr data member bar</strong> is initialized out-of-line violating the following statement in the standard:</p>\n<blockquote>\n<p id=\"so_11522399_11800201_0\">9.4.2 [class.static.data] p3: ... A static data member of literal type can be declared in the class definition with the constexpr specifier;\n  if so, its declaration shall specify a brace-or-equal-initializer in\n  which every initializer-clause that is an assignment-expression is a\n  constant expression.</p>\n</blockquote>\n<p>2) The code in MvG's question:</p>\n<pre><code>class C1 {\n  constexpr static int foo(int x) { return x + 1; }\n  constexpr static int bar = foo(sizeof(int));\n};\n</code></pre>\n<p>is valid as far as I see and intuitively one would expect it to work because the <em>static member foo(int)</em> is defined by the time processing of <em>bar</em> starts (assuming top-down processing).\nSome facts:</p>\n<p><ul>\n<li>I do agree though that <em>class C1</em> is not complete at the point of invocation of foo (based on 9.2p2) <strong>but</strong> completeness or incompleteness of the <em>class C1</em> says nothing about whether foo is defined as far as the standard is concerned. </li>\n<li>I did search the standard for the definedness of member functions but didn't find anything.</li>\n<li>So the statement mentioned by Ben doesn't apply here if my logic is valid:</li></ul></p>\n<blockquote>\n<p id=\"so_11522399_11800201_1\">an invocation of an undefined constexpr function or an undefined\n  constexpr constructor outside the definition of a constexpr function\n  or a constexpr constructor;</p></blockquote>\n\n  3) The last example given by Ben, simplified:\n\n<pre><code>class C1\n{\n  constexpr static int foo() { return bar; }\n  constexpr static int bar = foo();\n};\n</code></pre>\n<p>looks invalid but for different reasons and not simply because <em>foo</em> is called in the initializer of <em>bar</em>. The logic goes as follows:</p>\n<p><ul>\n<li><em>foo()</em> is called in the initializer of the <em>static constexpr member bar</em>, so it has to be a constant expression (by 9.4.2 p3).</li>\n<li>since it's an invocation of a constexpr function, the <em>Function invocation substitution</em> (7.1.5 p5) kicks in. </li>\n<li>Their are no parameters to the function, so what's left is \"implicitly converting the resulting returned expression or braced-init-list to the return type of the function as if by copy-initialization.\" (7.1.5 p5)</li>\n<li>the return expression is just <em>bar</em>, which is a lvalue and the lvalue-to-rvalue conversion is needed.</li>\n<li><p>but by bullet 9 in (5.19 p2) which <em>bar</em> <strong>does not</strong> satisfy because it is not yet initialized: </p></li></ul></p>\n<blockquote id=\"so_11522399_11800201_2\">\n<ul>\n<li>an lvalue-to-rvalue conversion (4.1) unless it is applied to:\n  <ul>\n<li>a glvalue of integral or enumeration type that refers to a non-volatile const object with a preceding initialization, initialized with a constant expression.</li>\n</ul></li>\n</ul>\n</blockquote>\n<li><p>hence the lvalue-to-rvalue conversion of <em>bar</em> does not yield a constant expression failing the requirement in (9.4.2 p3).</p></li>\n<li>so by bullet 4 in (5.19 p2), the call to <em>foo()</em> is not a constant expression:\n\n<blockquote>\n<p id=\"so_11522399_11800201_3\">an invocation of a constexpr function with arguments that, when substituted by function invocation substitution (7.1.5), do not produce a constant expression</p></blockquote></li>\n", "LastActivityDate": "2012-08-03T17:06:39.103", "CommentCount": "0", "CreationDate": "2012-08-03T17:06:39.103", "ParentId": "11522399", "Score": "4", "OwnerUserId": "1574647"}, "38324147": {"Id": "38324147", "PostTypeId": "2", "Body": "<p>Probably, the problem here is related to the order of declaration/definitions in a class. As you all know, you can use any member even before it is declared/defined in a class.</p>\n<p>When you define de constexpr value in the class, the compiler does not have the constexpr function available to be used because it is inside the class.</p>\n<p>Perhaps, <a href=\"https://stackoverflow.com/a/13095136/6578349\">Philip</a> answer, related to this idea, is a good point to understand the question.</p>\n<p>Note this code which compiles without problems:</p>\n<pre><code>constexpr int fooext(int x) { return x + 1; }\nstruct C1 {\n  constexpr static int foo(int x) { return x + 1; }\n  constexpr static int bar = fooext(5);\n};\n\nconstexpr static int barext = C1::foo(5);\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-07-12T08:54:23.487", "Score": "1", "CreationDate": "2016-07-12T08:54:23.487", "ParentId": "11522399", "CommentCount": "0", "OwnerUserId": "6578349", "LastEditDate": "2017-05-23T12:02:45.600"}, "11522578": {"Id": "11522578", "PostTypeId": "2", "Body": "<pre><code>#include &lt;iostream&gt;\n\nclass C1 \n{\npublic:\n    constexpr static int foo(constexpr int x)\n    { \n        return x + 1;\n    }\n\n    static constexpr int bar;\n};\n\nconstexpr int C1::bar = C1::foo(sizeof(int));\n\nint main()\n{\n    std::cout &lt;&lt; C1::bar &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Such initialization works well but only on clang</p>\n", "LastActivityDate": "2012-07-17T12:36:17.643", "CommentCount": "2", "CreationDate": "2012-07-17T12:36:17.643", "ParentId": "11522399", "Score": "3", "OwnerUserId": "1528866"}, "11522399": {"ViewCount": "19650", "Body": "<h1>Requirements</h1>\n<p>I want a <code>constexpr</code> value (i.e. a compile-time constant) computed from a <code>constexpr</code> function. And I want both of these scoped to the namespace of a class, i.e. a static method and a static member of the class.</p>\n<h1>First attempt</h1>\n<p>I first wrote this the (to me) obvious way:</p>\n<pre><code>class C1 {\n  constexpr static int foo(int x) { return x + 1; }\n  constexpr static int bar = foo(sizeof(int));\n};\n</code></pre>\n<p><code>g++-4.5.3 -std=gnu++0x</code> says to that:</p>\n<pre><code>error: \u2018static int C1::foo(int)\u2019 cannot appear in a constant-expression\nerror: a function call cannot appear in a constant-expression\n</code></pre>\n<p><code>g++-4.6.3 -std=gnu++0x</code> complains:</p>\n<pre><code>error: field initializer is not constant\n</code></pre>\n<h1>Second attempt</h1>\n<p>OK, I thought, perhaps I have to move things out of the class body. So I tried the following:</p>\n<pre><code>class C2 {\n  constexpr static int foo(int x) { return x + 1; }\n  constexpr static int bar;\n};\nconstexpr int C2::bar = C2::foo(sizeof(int));\n</code></pre>\n<p><code>g++-4.5.3</code> will compile that without complaints. Unfortunately, my other code uses some range-based <code>for</code> loops, so I have to have at least 4.6. Now that I look closer at the <a href=\"http://gcc.gnu.org/projects/cxx0x.html\" rel=\"noreferrer\">support list</a>, it appears that <code>constexpr</code> would require 4.6 as well. And with <code>g++-4.6.3</code> I get</p>\n<pre><code>3:24: error: constexpr static data member \u2018bar\u2019 must have an initializer\n5:19: error: redeclaration \u2018C2::bar\u2019 differs in \u2018constexpr\u2019\n3:24: error: from previous declaration \u2018C2::bar\u2019\n5:19: error: \u2018C2::bar\u2019 declared \u2018constexpr\u2019 outside its class\n5:19: error: declaration of \u2018const int C2::bar\u2019 outside of class is not definition [-fpermissive]\n</code></pre>\n<p>This sounds really strange to me. How do things \u201cdiffer in <code>constexpr</code>\u201d here? I don't feel like adding <code>-fpermissive</code> as I prefer my other code to be rigurously checked. Moving the <code>foo</code> implementation outside the class body had no visible effect.</p>\n<h1>Expected answers</h1>\n<p>Can someone explain what is going on here? How can I achieve what I'm attempting to do? I'm mainly interested in answers of the following kinds:</p>\n<ul>\n<li>A way to make this work in gcc-4.6</li>\n<li>An observation that later gcc versions can deal with one of the versions correctly</li>\n<li>A pointer to the spec according to which at least one of my constructs <em>should</em> work, so that I can bug the gcc developers about actually getting it to work</li>\n<li>Information that what I want is impossible according to the specs, preferrably with some insigt as to the rationale behind this restriction</li>\n</ul>\n<p>Other useful answers are welcome as well, but perhaps won't be accepted as easily.</p>\n", "AcceptedAnswerId": "11523155", "Title": "constexpr initializing static member using static function", "CreationDate": "2012-07-17T12:26:00.113", "Id": "11522399", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-07-17T13:06:09.237", "LastEditorUserId": "1468366", "LastActivityDate": "2016-07-12T08:54:23.487", "Score": "22", "OwnerUserId": "1468366", "Tags": "<c++><gcc><g++><static-members><constexpr>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_11522399_11523155_1": {"length": 8, "quality": 0.6153846153846154, "section_id": 5422}, "so_11522399_11800201_1": {"length": 8, "quality": 0.6153846153846154, "section_id": 5422}, "so_11522399_11800201_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 5908}, "so_11522399_11523155_0": {"length": 20, "quality": 1.0, "section_id": 5908}, "so_11522399_11800201_2": {"length": 16, "quality": 1.0, "section_id": 6185}}, "n3337": {"so_11522399_11523155_1": {"length": 13, "quality": 1.0, "section_id": 5946}, "so_11522399_11800201_2": {"length": 16, "quality": 1.0, "section_id": 5946}, "so_11522399_11800201_1": {"length": 13, "quality": 1.0, "section_id": 5946}, "so_11522399_11800201_3": {"length": 12, "quality": 0.9230769230769231, "section_id": 5946}, "so_11522399_11800201_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 5680}, "so_11522399_11523155_0": {"length": 20, "quality": 1.0, "section_id": 5680}}, "n4659": {"so_11522399_11523155_1": {"length": 11, "quality": 0.8461538461538461, "section_id": 7687}, "so_11522399_11800201_2": {"length": 16, "quality": 1.0, "section_id": 7687}, "so_11522399_11800201_1": {"length": 11, "quality": 0.8461538461538461, "section_id": 7687}, "so_11522399_11800201_3": {"length": 7, "quality": 0.5384615384615384, "section_id": 7687}, "so_11522399_11800201_0": {"length": 13, "quality": 0.5909090909090909, "section_id": 7390}, "so_11522399_11523155_0": {"length": 13, "quality": 0.65, "section_id": 7390}}}, "11523155": {"Id": "11523155", "PostTypeId": "2", "Body": "<p>The Standard requires (section 9.4.2):</p>\n<blockquote>\n<p id=\"so_11522399_11523155_0\">A <code>static</code> data member of literal type can be declared in the class definition with the <code>constexpr</code> specifier; if so, its declaration shall specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression.</p>\n</blockquote>\n<p>In your \"second attempt\" and the code in Ilya's answer, the declaration doesn't have a <em>brace-or-equal-initializer</em>.</p>\n<p><strike>Your first code is correct.  It's unfortunate that gcc 4.6 isn't accepting it, and I don't know anywhere to conveniently try 4.7.x (e.g. ideone.com is still stuck on gcc 4.5).</strike></p>\n<p>This isn't possible, because unfortunately the Standard precludes initializing a static <code>constexpr</code> data member in any context where the class is complete.  The special rule for <em>brace-or-equal-initializers</em> in 9.2p2 only applies to <strong>non-static</strong> data members, but this one is static.</p>\n<p>The most likely reason for this is that <code>constexpr</code> variables have to be available as compile-time constant expressions from inside the bodies of member functions, so the variable initializers are completely defined before the function bodies -- which means the function is still incomplete (undefined) in the context of the initializer, and then this rule kicks in, making the expression not be a constant expression:</p>\n<blockquote>\n<p id=\"so_11522399_11523155_1\">an invocation of an undefined <code>constexpr</code> function or an undefined <code>constexpr</code> constructor outside the definition of a <code>constexpr</code> function or a <code>constexpr</code> constructor;</p>\n</blockquote>\n<p>Consider:</p>\n<pre><code>class C1\n{\n  constexpr static int foo(int x) { return x + bar; }\n  constexpr static int bar = foo(sizeof(int));\n};\n</code></pre>\n", "LastEditorUserId": "103167", "LastActivityDate": "2012-07-17T21:33:08.943", "Score": "14", "CreationDate": "2012-07-17T13:06:46.397", "ParentId": "11522399", "CommentCount": "9", "OwnerUserId": "103167", "LastEditDate": "2012-07-17T21:33:08.943"}});