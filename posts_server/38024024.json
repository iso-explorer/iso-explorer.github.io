post_cb({"38024297": {"ParentId": "38024024", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Well, that code will compile, but the problem is that you will be unable to <em>default</em> construct any object of that class<sup>1</sup>, because the <em>constructor of the lambda</em> isn't accessible <em>(other than copy/move constructors)</em>. The only constructors guaranteed by a <code>lambda</code> type is a <em>defaulted</em> copy/move constructor. And there's no default constructor</p>\n<p><a href=\"http://eel.is/c++draft/expr.prim.lambda#21\" rel=\"nofollow noreferrer\">[expr.prim.lambda/21]</a></p>\n<blockquote>\n<p id=\"so_38024024_38024297_0\">The closure type associated with a lambda-expression has no default\n  constructor and a deleted copy assignment operator. It has a defaulted\n  copy constructor and a defaulted move constructor ([class.copy]). [\n  Note: These special member functions are implicitly defined as usual,\n  and might therefore be defined as deleted.  \u2014 end note ]</p>\n</blockquote>\n<p>or from <a href=\"http://en.cppreference.com/w/cpp/language/lambda#ClosureType::ClosureType.28.29\" rel=\"nofollow noreferrer\">cppreference</a>:</p>\n<pre><code>//ClosureType() = delete;                     //(until C++14)\nClosureType(const ClosureType&amp; ) = default;   //(since C++14)\nClosureType(ClosureType&amp;&amp; ) = default;        //(since C++14)\n</code></pre>\n<hr>\n<p>The history of the lambda constructor being inaccessible dates back to its early days proposal, found <a href=\"http://www.stroustrup.com/N1968-lambda-expressions.pdf\" rel=\"nofollow noreferrer\">here</a></p>\n<p>In section 3, second paragraph, and I quote:</p>\n<blockquote>\n<p id=\"so_38024024_38024297_1\">In this translation, <code>__some_unique_name</code> is a new name, not used\n  elsewhere in the program in a way that would cause conflicts with its\n  use as a closure type. This name, and the constructor for the class,\n  do not need to be exposed to the user\u2014the only features that the user\n  can rely on in the closure type are a copy constructor (and a move\n  constructor if that proposal is approved) and the function call\n  operator. Closure types do not need default constructors, assignment\n  operators, or any other means of access beyond function calls. It may\n  be worthwhile for implementability to forbid creating derived classes\n  from closure types. ...</p>\n</blockquote>\n<p>As you can see, the proposal even suggested that creating derived classes from closure types should be forbidden.</p>\n<hr>\n<p><sup>1</sup>\u00a0of course you can copy-initialize the base class with <code>a</code> in order to initialize an object of type <code>B</code>. See <a href=\"http://coliru.stacked-crooked.com/a/689bbba67ec0fc9b\" rel=\"nofollow noreferrer\">this</a></p>\n<hr>\n<p><strong>Now, to your question:</strong></p>\n<blockquote>\n<p id=\"so_38024024_38024297_2\">Can this be useful in any way?</p>\n</blockquote>\n<p>Not in your exact form. Your's will only be instantiable with the instance <code>a</code>.\nHowever, if you inherit from a generic Callable Class such as a lambda type, there are two cases I can think of.</p>\n<ol>\n<li><p><strong>Create a Functor that calls a group of functors in a given inheritance sequence:</strong></p>\n<p>A simplified example:</p>\n<pre><code>template&lt;typename TFirst, typename... TRemaining&gt;\nclass FunctionSequence : public TFirst, FunctionSequence&lt;TRemaining...&gt;\n{\n    public:\n    FunctionSequence(TFirst first, TRemaining... remaining)\n        : TFirst(first), FunctionSequence&lt;TRemaining...&gt;(remaining...)\n    {}\n\n    template&lt;typename... Args&gt;\n    decltype(auto) operator () (Args&amp;&amp;... args){\n        return FunctionSequence&lt;TRemaining...&gt;::operator()\n            (    TFirst::operator()(std::forward&lt;Arg&gt;(args)...)     );\n    }\n};\n\ntemplate&lt;typename T&gt;\nclass FunctionSequence&lt;T&gt; : public T\n{\n    public:\n    FunctionSequence(T t) : T(t) {}\n\n    using T::operator();\n};\n\n\ntemplate&lt;typename... T&gt;\nauto make_functionSequence(T... t){\n    return FunctionSequence&lt;T...&gt;(t...);\n}\n</code></pre>\n<p>example usage:</p>\n<pre><code>int main(){\n\n    //note: these lambda functions are bug ridden. Its just for simplicity here.\n    //For correct version, see the one on coliru, read on.\n    auto trimLeft = [](std::string&amp; str) -&gt; std::string&amp; { str.erase(0, str.find_first_not_of(' ')); return str; };\n    auto trimRight = [](std::string&amp; str) -&gt; std::string&amp; { str.erase(str.find_last_not_of(' ')+1); return str; };\n    auto capitalize = [](std::string&amp; str) -&gt; std::string&amp; { for(auto&amp; x : str) x = std::toupper(x); return str; };\n\n    auto trimAndCapitalize = make_functionSequence(trimLeft, trimRight, capitalize);\n    std::string str = \" what a Hullabaloo     \";\n\n    std::cout &lt;&lt; \"Before TrimAndCapitalize: str = \\\"\" &lt;&lt; str &lt;&lt; \"\\\"\\n\";\n    trimAndCapitalize(str);\n    std::cout &lt;&lt; \"After TrimAndCapitalize:  str = \\\"\" &lt;&lt; str &lt;&lt; \"\\\"\\n\";\n\n    return 0;\n}\n</code></pre>\n<p>output</p>\n<pre><code>Before TrimAndCapitalize: str = \" what a Hullabaloo     \"\nAfter TrimAndCapitalize:  str = \"WHAT A HULLABALOO\"\n</code></pre>\n<p>See it <a href=\"http://coliru.stacked-crooked.com/a/08c86d1549908b56\" rel=\"nofollow noreferrer\">Live on Coliru</a></p></li>\n<li><p><strong>Create a Functor with an overloaded <code>operator()(...)</code>, overloaded with all base classes' <code>operator()(...)</code>:</strong></p>\n<ul>\n<li>Nir Friedman has already given a good instance of that in his <a href=\"https://stackoverflow.com/a/38024314/1621391\">answer</a> to this question. </li>\n<li>I have also drafted out a similar and simplified example, drawn from His. See it <a href=\"http://coliru.stacked-crooked.com/a/4cec30cafedd9bbd\" rel=\"nofollow noreferrer\">on Coliru</a></li>\n<li>Jason Lucas also demonstrated its practical applications in his <a href=\"https://www.youtube.com/watch?v=uii2AfiMA0o\" rel=\"nofollow noreferrer\">CppCon 2014 presentation \"Polymorphism with Unions\"</a>. You can find the Repo <a href=\"https://github.com/JasonL9000/cppcon14\" rel=\"nofollow noreferrer\">here</a>, one of exact location in source code <a href=\"https://github.com/JasonL9000/cppcon14/blob/master/variant.h#L113\" rel=\"nofollow noreferrer\">here</a> (Thanks Cameron DaCamara)</li>\n</ul></li>\n</ol>\n<hr>\n<p>Another cool trick: Since the resulting type from <code>make_functionSequence(...)</code> is a callable class. You can append more lambda's or callable to it at a later time.</p>\n<pre><code>    //.... As previously seen\n\n    auto trimAndCapitalize = make_functionSequence(trimLeft, trimRight, capitalize);\n\n    auto replace = [](std::string&amp; str) -&gt; std::string&amp; { str.replace(0, 4, \"Whaaaaat\"); return str; };\n\n    //Add more Functors/lambdas to the original trimAndCapitalize\n    auto replaced = make_functionSequence(trimAndCapitalize, replace /*, ... */);\n    replaced(str2);\n</code></pre>\n</hr></hr></hr></hr>", "OwnerUserId": "1621391", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:29:23.027", "Id": "38024297", "Score": "28", "CreationDate": "2016-06-25T02:08:23.133", "LastActivityDate": "2016-06-29T20:22:15.523"}, "bq_ids": {"n4140": {"so_38024024_38024297_0": {"section_id": 5979, "quality": 0.53125, "length": 17}}, "n3337": {"so_38024024_38024297_0": {"section_id": 5747, "quality": 0.53125, "length": 17}}, "n4659": {"so_38024024_38024297_0": {"section_id": 7461, "quality": 0.8125, "length": 26}}}, "38024123": {"ParentId": "38024024", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><a href=\"https://stackoverflow.com/a/7627218/5922757\">Lambdas</a> are <a href=\"http://en.cppreference.com/w/cpp/utility/functional\" rel=\"nofollow noreferrer\">function objects</a> underneath, with additional syntatic sugar. <code>a</code> evaluates to something like that (with the <code>MyLambda</code> name being a random name, just like when you make <code>namespace {}</code> - namespace name will be random):</p>\n<pre><code>class MyLambda {\npublic:\n    void operator()() {\n    }\n}\n</code></pre>\n<p>So when you inherit from a lambda, what you're doing is inheriting from an anonymous class / structure.</p>\n<p>As for usefulness, well, it's as useful as any other inheritance. You can have the functionality of multiple lambdas with multiple inheritance in one object, you can add new methods to it to extend it. I can't think of any real application at the moment, but I'm sure there are many.</p>\n<p>Refer to <a href=\"https://stackoverflow.com/q/18432260/5922757\">this question</a> for more information.</p>\n", "OwnerUserId": "5922757", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:10:51.030", "Id": "38024123", "Score": "8", "CreationDate": "2016-06-25T01:31:33.327", "LastActivityDate": "2016-06-25T01:53:16.573"}, "38024314": {"ParentId": "38024024", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>This can actually be quite useful, but it depends how direct you want to be about the whole thing. Consider the following code:</p>\n<pre><code>#include &lt;boost/variant.hpp&gt;\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n\ntemplate &lt;class R, class T, class ... Ts&gt;\nstruct Inheritor : public  T, Inheritor&lt;R, Ts...&gt;\n{\n  using T::operator();\n  using Inheritor&lt;R, Ts...&gt;::operator();\n  Inheritor(T t, Ts ... ts) : T(t), Inheritor&lt;R, Ts...&gt;(ts...) {}\n};\n\ntemplate &lt;class R, class T&gt;\nstruct Inheritor&lt;R, T&gt; : public boost::static_visitor&lt;R&gt;, T\n{\n  using T::operator();\n  Inheritor(T t) : T(t) {}\n};\n\ntemplate &lt;class R, class V, class ... T&gt;\nauto apply_visitor_inline(V&amp; v, T ... t)\n{\n  Inheritor&lt;R, T...&gt; i(t...);\n  return boost::apply_visitor(i, v);\n}\n\nint main()\n{\n  boost::variant&lt; int, std::string &gt; u(\"hello world\");\n  boost::variant&lt; int, std::string &gt; u2(5);\n\n  auto result = apply_visitor_inline&lt;int64_t&gt;(u, [] (int i) { return i;}, [] (const std::string&amp; s) { return s.size();});\n  auto result2 = apply_visitor_inline&lt;int64_t&gt;(u2, [] (int i) { return i;}, [] (const std::string&amp; s) { return s.size();});\n  std::cout &lt;&lt; result;\n  std::cout &lt;&lt; result2;\n}\n</code></pre>\n<p>The snippet in your question does not show up in exact form anywhere. But you can see that the types of lambdas are being inferred in <code>apply_visitor_inline</code>. A class is then instantiated that inherits from all of these lambdas. The purpose? We are able to combine multiple lambdas into a single one, for the purpose of things like <code>apply_visitor</code>. This function expects to receive a single function object that defines multiple <code>operator()</code> and distinguish between them based on overloading. But sometimes it's more convenient to define a lambda that operates on each of the types we have to cover. In that case, inheritance from lambdas provides a mechanism for combining.</p>\n<p>I got the inline visitor idea from here: <a href=\"https://github.com/exclipy/inline_variant_visitor\" rel=\"nofollow noreferrer\">https://github.com/exclipy/inline_variant_visitor</a>, though I did not look at the implementation there, so this implementation is my own (but I guess its very similar).</p>\n<p>Edit: the originally posted code only worked due to a bug in clang. According to this question (<a href=\"https://stackoverflow.com/questions/29661253/overloaded-lambdas-in-c-and-differences-between-clang-and-gcc\">Overloaded lambdas in C++ and differences between clang and gcc</a>), the lookup for multiple <code>operator()</code> in base classes is ambiguous, and indeed the code I posted originally did not compile in gcc. The new code compiles in both and should be compliant. Sadly, there is no way seemingly to do a variadic using statement, so recursion must be used.</p>\n", "OwnerUserId": "1908347", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:55:16.410", "Id": "38024314", "Score": "6", "CreationDate": "2016-06-25T02:11:30.777", "LastActivityDate": "2016-06-25T15:43:00.473"}, "38024024": {"CommentCount": "10", "ViewCount": "2538", "CreationDate": "2016-06-25T01:11:35.243", "LastActivityDate": "2016-06-29T20:22:15.523", "Title": "What does it mean to inherit from lambda?", "FavoriteCount": "10", "PostTypeId": "1", "Id": "38024024", "Score": "56", "Body": "<p>Found this code which looks to be interesting:</p>\n<pre><code>auto a = [](){};\n\nclass B : decltype(a)\n{\n};\n</code></pre>\n<p>I want to know what it does. Can this be useful in any way?</p>\n", "Tags": "<c++>", "OwnerUserId": "6511134", "AnswerCount": "3"}});