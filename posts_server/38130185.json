post_cb({"bq_ids": {"n4140": {"so_38130185_38132601_1": {"length": 20, "quality": 0.8, "section_id": 3920}, "so_38130185_38132601_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 7169}, "so_38130185_38132601_0": {"length": 54, "quality": 0.9310344827586207, "section_id": 7156}}, "n3337": {"so_38130185_38132601_1": {"length": 20, "quality": 0.8, "section_id": 3780}, "so_38130185_38132601_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 6913}, "so_38130185_38132601_0": {"length": 54, "quality": 0.9310344827586207, "section_id": 6900}}, "n4659": {"so_38130185_38132601_1": {"length": 20, "quality": 0.8, "section_id": 4806}, "so_38130185_38132601_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 8677}, "so_38130185_38132601_0": {"length": 36, "quality": 0.6206896551724138, "section_id": 8662}}}, "38132601": {"Id": "38132601", "PostTypeId": "2", "Body": "<p>The Standard does not cover this case; the strictest reading would be that it is legal to initialize a <code>thread_local</code> in the destructor of an object with static storage duration, but it is illegal to allow the program to continue to normal completion.</p>\n<p>The problem arises in <a href=\"http://eel.is/c++draft/basic.start.term\" rel=\"nofollow noreferrer\">[basic.start.term]</a>:</p>\n<blockquote>\n<p id=\"so_38130185_38132601_0\">1 - Destructors ([class.dtor]) for initialized objects (that is, objects whose lifetime ([basic.life]) has begun) with static storage duration are called as a result of returning from main and as a result of calling std::exit ([support.start.term]). Destructors for initialized objects with thread storage duration within a given thread are called as a result of returning from the initial function of that thread and as a result of that thread calling std::exit. The completions of the destructors for all initialized objects with thread storage duration within that thread are sequenced before the initiation of the destructors of any object with static storage duration. [...]</p>\n</blockquote>\n<p>So the completion of <code>bar::~Bar::foo::~Foo</code> is sequenced before the initiation of <code>bar::~Bar</code>, which is a contradiction. </p>\n<p>The only get-out could be to argue that [basic.start.term]/1 only applies to objects whose lifetime has begun at the point of program/thread termination, but <em>contra</em> <a href=\"http://eel.is/c++draft/stmt.dcl\" rel=\"nofollow noreferrer\">[stmt.dcl]</a> has:</p>\n<blockquote>\n<p id=\"so_38130185_38132601_1\">5 - The destructor for a block-scope object with static or thread storage duration will be executed if and only if it was constructed. [ Note: [basic.start.term] describes the order in which block-scope objects with static and thread storage duration are destroyed.  \u2014 end note ]</p>\n</blockquote>\n<p>This is clearly intended to apply only to normal thread and program termination, by return from main or from a thread function, or by calling <code>std::exit</code>.</p>\n<p>Also, <a href=\"http://eel.is/c++draft/basic.stc.thread\" rel=\"nofollow noreferrer\">[basic.stc.thread]</a> has:</p>\n<blockquote>\n<p id=\"so_38130185_38132601_2\">A variable with thread storage duration shall be initialized before its first odr-use ([basic.def.odr]) and, if constructed, shall be destroyed on thread exit.</p>\n</blockquote>\n<p>The \"shall\" here is an instruction to the implementor, not to the user.</p>\n<p>Note that there is nothing wrong with beginning the lifetime of the destructor-scoped <code>thread_local</code>, since [basic.start.term]/2 does not apply (it is not previously destroyed). That is why I believe that undefined behavior occurs when you allow the program to continue to normal completion.</p>\n<p>Similar questions have been asked before, though about static vs. static storage duration rather than <code>thread_local</code> vs. static; <a href=\"https://stackoverflow.com/questions/3736212\">Destruction of objects with static storage duration</a> (and <a href=\"https://groups.google.com/forum/#!topic/comp.std.c++/Tunyu2IJ6w0\" rel=\"nofollow noreferrer\">https://groups.google.com/forum/#!topic/comp.std.c++/Tunyu2IJ6w0</a>), and <a href=\"https://stackoverflow.com/questions/14278006\">Destructor of a static object constructed within the destructor of another static object</a>. I'm inclined to agree with James Kanze on the latter question that <a href=\"http://eel.is/c++draft/defns.undefined\" rel=\"nofollow noreferrer\">[defns.undefined]</a> applies here, and the behavior is undefined because the Standard does not define it. The best way forward would be for someone with standing to open a defect report (covering all the combinations of <code>static</code>s and <code>thread_local</code>s initialized within the destructors of <code>static</code>s and <code>thread_local</code>s), to hope for a definitive answer.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-06-30T20:24:01.683", "Score": "9", "CreationDate": "2016-06-30T20:24:01.683", "ParentId": "38130185", "CommentCount": "1", "OwnerUserId": "567292", "LastEditDate": "2017-05-23T12:00:10.877"}, "38130185": {"ViewCount": "1562", "Body": "<p>This program:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Foo {\n    Foo() {\n        std::cout &lt;&lt; \"Foo()\\n\";\n    }\n\n    ~Foo() {\n        std::cout &lt;&lt; \"~Foo()\\n\";\n    }\n};\n\nstruct Bar {\n    Bar() {\n        std::cout &lt;&lt; \"Bar()\\n\";\n    }\n\n    ~Bar() {\n        std::cout &lt;&lt; \"~Bar()\\n\";\n        thread_local Foo foo;\n    }\n};\n\nBar bar;\n\nint main() {\n    return 0;\n}\n</code></pre>\n<p>Prints</p>\n<pre><code>Bar()\n~Bar()\nFoo()\n</code></pre>\n<p>for me (GCC 6.1, Linux, x86-64).  ~Foo() is never called.  Is that the expected behaviour?</p>\n", "AcceptedAnswerId": "38132601", "Title": "Is it legal to initialize a thread_local variable in the destructor of a global variable?", "CreationDate": "2016-06-30T17:55:32.277", "Id": "38130185", "CommentCount": "16", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-06-30T19:30:12.937", "LastEditorUserId": "502399", "LastActivityDate": "2016-06-30T20:24:01.683", "Score": "15", "OwnerUserId": "502399", "Tags": "<c++><multithreading><c++11><language-lawyer><thread-local-storage>", "AnswerCount": "1"}});