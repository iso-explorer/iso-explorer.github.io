post_cb({"3047780": {"ParentId": "3047511", "CommentCount": "3", "Body": "<p>You should be able to access <code>Base::Enum</code> by fully qualifying it:</p>\n<pre><code>class Child : public Middle\n{\npublic:\n    void Method()\n    {\n        ::Base::Enum e = ::Base::value;\n    }\n};\n</code></pre>\n<p>This is the behavior specified by the language (C++03 \u00a711.2/3):</p>\n<blockquote>\n<p id=\"so_3047511_3047780_0\">Note:  A member of a private base class might be inaccessible as an inherited member name, but accessible directly.</p>\n</blockquote>\n<p>This is followed by an extended example that is effectively similar to your example code.</p>\n<p>However, it appears that neither Visual C++ 2008 nor Visual C++ 2010 correctly implements this, so while you can use the type <code>::Base::Enum</code>, you still can't access <code>::Base::value</code>.  (Actually, Visual C++ seems to have gotten a lot of this wrong, as it incorrectly allows you to use the not-fully-qualified <code>Base::Enum</code>).  </p>\n<p>To \"get around\" the problem, you can add using declarations to the <code>Middle</code> class:</p>\n<pre><code>class Middle : private Base\n{ \nprotected:\n\n    using Base::Enum;\n    using Base::value;\n};\n</code></pre>\n<p>This won't let you use <code>Base::Enum</code> or <code>Base::value</code> in your <code>Child</code> class, but it will allow you to use an <code>Enum</code> and <code>value</code> or <code>Middle::Enum</code> and <code>Middle::value</code>.</p>\n", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "3047780", "Score": "6", "CreationDate": "2010-06-15T18:06:19.197", "LastActivityDate": "2010-06-15T18:06:19.197"}, "3047511": {"CommentCount": "1", "AcceptedAnswerId": "3047780", "CreationDate": "2010-06-15T17:31:42.013", "LastActivityDate": "2010-06-16T06:47:22.613", "PostTypeId": "1", "ViewCount": "1064", "FavoriteCount": "1", "Title": "C++ private inheritance and static members/types", "Id": "3047511", "Score": "5", "Body": "<p>I am trying to stop a class from being able to convert its 'this' pointer into a pointer of one of its interfaces. I do this by using private inheritance via a middle proxy class. The problem is that I find private inheritance makes all public static members and types of the base class inaccessible to all classes under the inheriting class in the hierarchy. </p>\n<pre><code>class Base\n{\npublic:\n    enum Enum\n    {\n        value\n    };\n};\n\nclass Middle : private Base\n{ \n};\n\nclass Child : public Middle\n{\npublic:\n    void Method()\n    {\n        Base::Enum e = Base::value; // doesn't compile BAD!     \n        Base* base = this; // doesn't compile GOOD!\n    }\n};\n</code></pre>\n<p>I've tried this in both VS2008 (the required version) and VS2010, neither work.</p>\n<p>Can anyone think of a workaround? Or a different approach to stopping the conversion?</p>\n<p>Also I am curios of the behavior, is it just a side effect of the compiler implementation, or is it by design? If by design, then why? I always thought of private inheritance to mean that nobody knows Middle inherits from Base. However, the exhibited behavior implies private inheritance means a lot more than that, in-fact Child has less access to Base than any namespace not in the class hierarchy! </p>\n", "Tags": "<c++><inheritance><static>", "OwnerUserId": "254832", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_3047511_3047780_0": {"section_id": 6680, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_3047511_3047780_0": {"section_id": 6435, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_3047511_3047780_0": {"section_id": 8155, "quality": 0.9230769230769231, "length": 12}}}, "3051191": {"ParentId": "3047511", "CommentCount": "3", "Body": "<p>I only have one question: why you private inheritance at all ?</p>\n<p>Inheritance is quite a broken concept, in my opinion, because it violates the One Responsibility principle:</p>\n<ul>\n<li>you inherit the interface</li>\n<li>you inherit the implementation</li>\n</ul>\n<p>Unfortunately inheritance is required for polymorphism in Object-Oriented code, so you can't shy away from it in this case.</p>\n<p>But here you explicitly wish NOT to use polymorphism, so I find myself wondering why using inheritance at all, since it's its sole interesting use (imo).</p>\n<p>Instead, in C++, you can use:</p>\n<ul>\n<li>Composition, for code reuse</li>\n<li>Free functions (defined in their own namespace)</li>\n<li><code>using</code>, <code>typedef</code> etc... to bring objects from outside the class</li>\n</ul>\n<p>Your example seems constrained here, but I too wrap my enums into <code>struct</code> to prevent namespace pollution by a thousand symbols (and because <code>struct</code> can be used as template parameters wheres namespaces cannot).</p>\n<pre><code>struct MyEnum\n{\n  enum type\n  {\n    value\n  };\n};\n\nclass Child\n{\npublic:\n  typedef MyEnum::type Enum;\n\n  Child(Enum e = MyEnum::value);\n\nprivate:\n};\n</code></pre>\n<p>I don't see anything wrong with qualifying the name, instead I feel it makes it easier to read again, since you know which enum we are talking about...</p>\n<p>Really, <code>private</code> inheritance is best avoided (and usually replaced by Composition). The only valid case (imo) is for Empty Base Optimization... and frankly it's not often you need it (as usual with optimizations).</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "3051191", "Score": "1", "CreationDate": "2010-06-16T06:47:22.613", "LastActivityDate": "2010-06-16T06:47:22.613"}});