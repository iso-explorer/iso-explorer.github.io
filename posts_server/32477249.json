post_cb({"32479159": {"ParentId": "32477249", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2015-09-09T12:07:30.713", "Score": "3", "LastEditorUserId": "1708801", "LastEditDate": "2015-09-09T18:26:08.403", "Id": "32479159", "OwnerUserId": "1708801", "Body": "<p>The binary arithmetic operators will perform the <a href=\"http://en.cppreference.com/w/cpp/language/operator_arithmetic#Conversions\" rel=\"nofollow\">usual arithmetic conversions</a> on their operands to bring them to a common type.</p>\n<p>In the case of <code>i1</code>, <code>i3</code> and <code>i5</code> the common type will be <em>unsigned int</em> and so the result will also be <em>unsigned int</em>. Unsigned numbers will wrap via modulo arithmetic and so subtracting a slightly larger unsigned value will result in a number close to unsigned int max which can not be represented by an int.</p>\n<p>So in the case of <code>i1</code> we end up with an implementation defined conversion since the value can not be represented. In the case of <code>i3</code> dividing by <code>2</code> brings the unsigned value back into the range of int and so we end up with a large signed int value after conversion.</p>\n<p>The relevant sections form the C++ draft standard are as follows. Section <code>5.7</code> <em>[expr.add]</em>:</p>\n<blockquote>\n<p id=\"so_32477249_32479159_0\">The additive operators + and - group left-to-right. The usual arithmetic conversions are performed for\n  operands of arithmetic or enumeration type.</p>\n</blockquote>\n<p>The usual arithmetic conversions are covered in section <code>5</code> and it says:</p>\n<blockquote>\n<p id=\"so_32477249_32479159_1\">Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield\n  result types in a similar way. The purpose is to yield a common type, which is also the type of the result.\n  This pattern is called the usual arithmetic conversions, which are defined as follows:</p>\n<p id=\"so_32477249_32479159_2\">[...]</p>\n<ul>\n<li>Otherwise, if the operand that has unsigned integer type has rank greater than or equal to the\n  rank of the type of the other operand, the operand with signed integer type shall be converted to\n  the type of the operand with unsigned integer type.</li>\n</ul>\n</blockquote>\n<p>and for the conversion from a value that can not be represented for a signed type, section <code>4.7</code> <em>[conv.integral]</em>:</p>\n<blockquote>\n<p id=\"so_32477249_32479159_3\">If the destination type is signed, the value is unchanged if it can be represented in the destination type (and\n  bit-field width); otherwise, the value is implementation-defined.</p>\n</blockquote>\n<p>and for unsigned integers obeys modulo arithmetic section <code>3.9.1</code> <em>[basic.fundamental]</em>:</p>\n<blockquote>\n<p id=\"so_32477249_32479159_4\">Unsigned integers shall obey the laws of arithmetic modulo 2n where n is the number of bits in the value\n  representation of that particular size of integer.48</p>\n</blockquote>\n", "LastActivityDate": "2015-09-09T18:26:08.403"}, "32477537": {"ParentId": "32477249", "CommentCount": "3", "CreationDate": "2015-09-09T10:50:44.367", "OwnerUserId": "1989425", "PostTypeId": "2", "Id": "32477537", "Score": "10", "Body": "<blockquote id=\"so_32477249_32477537_0\">\n<pre><code>int i1 = 20-80u;    // -60\n</code></pre>\n</blockquote>\n<p>The operands are different, so a conversion is necessary. Both operands are converted to a common type (an <code>unsigned int</code>, in this case). The result, which will be a large <code>unsigned int</code> value (60 less than <code>UINT_MAX + 1</code> if my calculations are correct) will be converted to an <code>int</code> before it's stored in <code>i1</code>. Since that value is out of range of <code>int</code>, the result will be implementation defined, might be a trap representation and thus might cause undefined behaviour when you attempt to use it. However, in your case it coincidentally converts to <code>-60</code>.</p>\n<hr>\n<blockquote id=\"so_32477249_32477537_1\">\n<pre><code>int i3 =(20-80u)/2; // 2147483618\n</code></pre>\n</blockquote>\n<p>Continuing on from the first example, my guess was that the result of <code>20-80u</code> would be 60 less than <code>UINT_MAX + 1</code>. If <code>UINT_MAX</code> is 4294967295 (a common value for <code>UINT_MAX</code>), that would mean <code>20-80u</code> is <code>4294967236</code>... and <code>4294967236 / 2</code> is 2147483618.</p>\n<hr>\n<p>As for <code>i2</code> and the others, there should be no surprises. They follow conventional mathematical calculations with no conversions, truncations or overflows.</p>\n</hr></hr>", "LastActivityDate": "2015-09-09T10:50:44.367"}, "32477249": {"CommentCount": "0", "AcceptedAnswerId": "32477317", "PostTypeId": "1", "LastEditorUserId": "1989425", "CreationDate": "2015-09-09T10:35:38.017", "LastActivityDate": "2016-01-16T01:28:18.083", "LastEditDate": "2016-01-16T01:28:18.083", "ViewCount": "900", "FavoriteCount": "3", "Title": "Subtraction between signed and unsigned followed by division", "Id": "32477249", "Score": "23", "Body": "<p>The following results make me really confused:</p>\n<pre><code>int i1 = 20-80u;    // -60\nint i2 = 20-80;     // -60\nint i3 =(20-80u)/2; // 2147483618\nint i4 =(20-80)/2;  // -30\nint i5 =i1/2;       // -30\n</code></pre>\n<ol>\n<li><code>i3</code> seems to be computed as <code>(20u-80u)/2</code>, instead of <code>(20-80u)/2</code></li>\n<li>supposedly <code>i3</code> is the same as <code>i5</code>.</li>\n</ol>\n", "Tags": "<c++><unsigned><integer-overflow><arithmetic-expressions>", "OwnerUserId": "1757356", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_32477249_32479159_4": {"section_id": 7213, "quality": 0.9285714285714286, "length": 13}, "so_32477249_32479159_0": {"section_id": 6138, "quality": 0.8571428571428571, "length": 12}, "so_32477249_32479159_1": {"section_id": 5943, "quality": 0.9032258064516129, "length": 28}, "so_32477249_32479159_3": {"section_id": 32, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_32477249_32479159_4": {"section_id": 6957, "quality": 0.9285714285714286, "length": 13}, "so_32477249_32479159_0": {"section_id": 5902, "quality": 0.8571428571428571, "length": 12}, "so_32477249_32479159_1": {"section_id": 5714, "quality": 0.9032258064516129, "length": 28}, "so_32477249_32479159_3": {"section_id": 29, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_32477249_32479159_4": {"section_id": 8722, "quality": 0.9285714285714286, "length": 13}, "so_32477249_32479159_0": {"section_id": 7635, "quality": 0.8571428571428571, "length": 12}, "so_32477249_32479159_1": {"section_id": 7428, "quality": 0.9032258064516129, "length": 28}, "so_32477249_32479159_3": {"section_id": 32, "quality": 0.7857142857142857, "length": 11}}}, "32477317": {"ParentId": "32477249", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-09-09T10:39:19.963", "Score": "12", "LastEditorUserId": "1084944", "LastEditDate": "2015-09-09T11:10:54.653", "Id": "32477317", "OwnerUserId": "1084944", "Body": "<p>IIRC, an arithmetic operation between signed and unsigned int will produce an unsigned result.</p>\n<p>Thus, <code>20 - 80u</code> produces the unsigned result equivalent to <code>-60</code>: if <code>unsigned int</code> is a 32-bit type, that result is 4294967236.</p>\n<p>Incidentally, assigning that to <code>i1</code> produces an <em>implementation-defined</em> result because the number is too large to fit. Getting <code>-60</code> is typical, but not guaranteed.</p>\n", "LastActivityDate": "2015-09-09T11:10:54.653"}});