post_cb({"15777133": {"CommentCount": "2", "AcceptedAnswerId": "15779613", "CreationDate": "2013-04-03T01:01:37.127", "LastActivityDate": "2013-04-03T11:45:09.247", "PostTypeId": "1", "ViewCount": "260", "FavoriteCount": "1", "Title": "C++ scoped variables re-ordering and timers", "Id": "15777133", "Score": "4", "Body": "<p>I am very much trilled with the how a scoped_lock works and was wondering weather a similar implementation can be done as to time a particular code of execution</p>\n<p>If say I implement a simple class scoped_timer which on construction initiates a timer and on deletion it stops and report the time elapsed, then would this sample code be timed correctly</p>\n<pre><code>func()\n{\n    //some code\n    {\n       scoped_timer a;\n       //some code that does not include a\n     }\n     //some code\n }\n</code></pre>\n<p>In practice am I guaranteed that <code>scoped_time a</code> is constructed at the beginning  and destructed exactly when it is out of scope. Can the compiler decide to reorder the code in such a way as not to destruct it exactly at the end of scope or construct it at the beginning since there is no dependence on the <code>object a</code>? Are there guarantees from C++ standard?</p>\n<p>Thanks</p>\n<p>Daniel</p>\n", "Tags": "<c++>", "OwnerUserId": "1750561", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_15777133_15779613_3": {"section_id": 5809, "quality": 0.8208955223880597, "length": 55}, "so_15777133_15779613_5": {"section_id": 7172, "quality": 0.9310344827586207, "length": 27}, "so_15777133_15779613_10": {"section_id": 3881, "quality": 1.0, "length": 5}, "so_15777133_15779613_2": {"section_id": 5797, "quality": 0.9285714285714286, "length": 39}, "so_15777133_15779613_9": {"section_id": 3881, "quality": 0.9285714285714286, "length": 13}, "so_15777133_15779613_4": {"section_id": 5810, "quality": 0.8181818181818182, "length": 18}, "so_15777133_15779613_6": {"section_id": 7170, "quality": 0.8695652173913043, "length": 20}, "so_15777133_15779613_8": {"section_id": 3917, "quality": 0.9047619047619048, "length": 19}, "so_15777133_15779613_1": {"section_id": 5797, "quality": 0.8461538461538461, "length": 33}}, "n3337": {"so_15777133_15779613_3": {"section_id": 5582, "quality": 0.8208955223880597, "length": 55}, "so_15777133_15779613_5": {"section_id": 6916, "quality": 0.9310344827586207, "length": 27}, "so_15777133_15779613_10": {"section_id": 3741, "quality": 1.0, "length": 5}, "so_15777133_15779613_2": {"section_id": 5570, "quality": 0.9285714285714286, "length": 39}, "so_15777133_15779613_9": {"section_id": 3741, "quality": 0.9285714285714286, "length": 13}, "so_15777133_15779613_4": {"section_id": 5583, "quality": 0.8181818181818182, "length": 18}, "so_15777133_15779613_6": {"section_id": 6914, "quality": 0.8695652173913043, "length": 20}, "so_15777133_15779613_8": {"section_id": 3777, "quality": 0.9047619047619048, "length": 19}, "so_15777133_15779613_1": {"section_id": 5570, "quality": 0.8461538461538461, "length": 33}}, "n4659": {"so_15777133_15779613_3": {"section_id": 7270, "quality": 0.8208955223880597, "length": 55}, "so_15777133_15779613_5": {"section_id": 8680, "quality": 0.8620689655172413, "length": 25}, "so_15777133_15779613_10": {"section_id": 4770, "quality": 1.0, "length": 5}, "so_15777133_15779613_2": {"section_id": 7256, "quality": 0.9285714285714286, "length": 39}, "so_15777133_15779613_9": {"section_id": 4770, "quality": 0.9285714285714286, "length": 13}, "so_15777133_15779613_8": {"section_id": 4803, "quality": 0.9047619047619048, "length": 19}, "so_15777133_15779613_6": {"section_id": 8678, "quality": 0.7391304347826086, "length": 17}, "so_15777133_15779613_4": {"section_id": 7271, "quality": 0.8181818181818182, "length": 18}, "so_15777133_15779613_1": {"section_id": 7256, "quality": 0.8461538461538461, "length": 33}}}, "15779613": {"ParentId": "15777133", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The code is guaranteed to behave as you would like.</p>\n<p>This guarantee is important in C++, because C++ is not a <a href=\"http://en.wikipedia.org/wiki/Functional_programming\" rel=\"nofollow\">functional programming language</a>, due to the fact that almost any function in C++ can have side effects (either from the flow of execution of the current thread, or from other threads or even other processes, whether or not the data is declared as <code>volatile</code>).  Because of this, the language specification makes guarantees about the sequencing of full expressions.</p>\n<p>To piece this together from the C++11 standard, there are a number of clauses that must be considered together.</p>\n<p>The most important clause is \u00a71.9:</p>\n<blockquote>\n<p id=\"so_15777133_15779613_0\"><strong>\u00a71.9</strong> Program execution [intro.execution]</p>\n<p id=\"so_15777133_15779613_1\">1 The semantic descriptions in this International Standard define a\n  parameterized nondeterministic abstract machine. This International\n  Standard places no requirement on the structure of conforming\n  implementations. In particular, they need not copy or emulate the\n  structure of the abstract machine. Rather, conforming implementations\n  are required to emulate (only) the observable behavior of the abstract\n  machine as explained below. * (&lt;-- the footnote is in the standard itself)</p>\n<p id=\"so_15777133_15779613_2\">* This provision is sometimes called the \u201cas-if\u201d rule, because an implementation is free to disregard any requirement of this\n  International Standard as long as the result is as if the requirement\n  had been obeyed, as far as can be determined from the observable\n  behavior of the program. For instance, an actual implementation need\n  not evaluate part of an expression <strong>if it can deduce that its value is\n  not used and that no side effects affecting the observable behavior of\n  the program are produced</strong>.</p>\n</blockquote>\n<p>(The bolding of the text is mine.)</p>\n<p>This clause imposes two important requirements that are relevant for this question.</p>\n<ol>\n<li><p>If an expression may have side effects, it will be evaluated.  In your case, the expression <code>scoped_timer a;</code> may have side effects, so it will be evaluated.</p></li>\n<li><p>\"<em>...conforming implementations are required to emulate (only) the observable behavior of the abstract machine as explained below.</em>\", where \"below\" includes Clauses 13 and 14 of the same section:</p></li>\n</ol>\n<blockquote>\n<p id=\"so_15777133_15779613_3\"><strong>\u00a71.9.13</strong> Sequenced before is an asymmetric, transitive, pair-wise\n  relation between evaluations executed by a single thread (1.10), which\n  induces a partial order among those evaluations. Given any two\n  evaluations A and B, if A is sequenced before B, then the execution of\n  A shall precede the execution of B. If A is not sequenced before B and\n  B is not sequenced before A, then A and B are unsequenced. [ Note: The\n  execution of unsequenced evaluations can overlap. \u2014end note ]\n  Evaluations A and B are indeterminately sequenced when either A is\n  sequenced before B or B is sequenced before A, but it is unspecified\n  which. [ Note: Indeterminately sequenced evaluations cannot overlap,\n  but either could be executed first. \u2014end note ]</p>\n<p id=\"so_15777133_15779613_4\"><strong>\u00a71.9.14</strong> Every value computation and side effect associated with a\n  full-expression is sequenced before every value computation and side\n  effect associated with the next full-expression to be evaluated. * (&lt;-- the footnote here is not relevant)</p>\n</blockquote>\n<p>Therefore, your expression <code>scoped_timer a;</code> (which is a full expression) may have side effects and will be evaluated; so the computation of the value of <code>a</code> will be sequenced before any of the following statements in the block.</p>\n<p>Regarding destruction of the object <code>a</code>, that is simpler.</p>\n<blockquote>\n<p id=\"so_15777133_15779613_5\"><strong>\u00a73.7.3.3</strong> If a variable with automatic storage duration has initialization or a destructor with side effects, it shall not be\n  destroyed before the end of its block, nor shall it be eliminated as\n  an optimization even if it appears to be unused, except that a class\n  object or its copy/move may be eliminated as specified in 12.8.</p>\n</blockquote>\n<p>This makes clear that the destructor will not be called until the block exits.</p>\n<p><strong>ADDENDUM</strong> And to confirm that all block-level variables <em>are</em> destroyed (and their destructor called) at the end of block scope, here it is in the C++11 standard:</p>\n<blockquote>\n<p id=\"so_15777133_15779613_6\"><strong>\u00a73.7.3.1</strong> Block-scope variables explicitly declared register or not explicitly declared static or extern have automatic storage duration.\n  The storage for these entities lasts until the block in which they are\n  created exits.</p>\n<p id=\"so_15777133_15779613_7\"><strong>\u00a73.7.3.2</strong> [ Note: These variables are initialized and destroyed as described in 6.7. \u2014end note ]</p>\n</blockquote>\n<p>... and the above-mentioned \u00a76.7:</p>\n<blockquote>\n<p id=\"so_15777133_15779613_8\"><strong>\u00a76.7.2</strong> Variables with automatic storage duration (3.7.3) are initialized each time their declaration-statement is executed.\n  Variables with automatic storage duration declared in the block are\n  destroyed on exit from the block (6.6).</p>\n</blockquote>\n<p>The block is defined as all code between a pair of curly braces <code>{}</code> here:</p>\n<blockquote>\n<p id=\"so_15777133_15779613_9\"><strong>\u00a76.3.1</strong> So that several statements can be used where one is expected, the compound statement (also, and equivalently, called \u201cblock\u201d) is provided.</p>\n<pre><code>compound-statement:\n\n    { statement-seq }\n\nstatement-seq:\n\n    statement\n\n    statement-seq statement\n</code></pre>\n<p id=\"so_15777133_15779613_10\">A compound statement defines a block scope (3.3).</p>\n</blockquote>\n<p>Note: The <code>compount-statement</code> (etc) section takes a while to get used to, but the important point is that here, the open curly brace <code>{</code> and close curly brace <code>}</code> actually mean a literal open curly brace and close curly brace in the code.  This is the exact place in the C++11 standard where <code>block</code> scope is defined as the sequence of statements between curly braces.</p>\n<p>Putting the pieces together: Because the standard, as quoted above, says <code>The storage for these entities lasts until the block in which they are created exits</code> and that <code>Variables with automatic storage duration declared in the block are destroyed on exit from the block</code>, you are assured that the object <code>a</code> in your question (and ANY block-level object) will last until the end of the block, and will be destroyed and have its destructor called when the block exits.</p>\n", "OwnerUserId": "368896", "LastEditorUserId": "368896", "LastEditDate": "2013-04-03T11:45:09.247", "Id": "15779613", "Score": "5", "CreationDate": "2013-04-03T05:35:51.543", "LastActivityDate": "2013-04-03T11:45:09.247"}});