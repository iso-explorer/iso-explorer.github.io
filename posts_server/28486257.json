post_cb({"28486257": {"CommentCount": "3", "ViewCount": "82", "PostTypeId": "1", "LastEditorUserId": "225074", "CreationDate": "2015-02-12T19:35:24.510", "LastActivityDate": "2015-02-12T20:41:48.643", "Title": "What happen to stack when i declare a reference variable? C++", "LastEditDate": "2015-02-12T19:37:56.443", "Id": "28486257", "Score": "1", "Body": "<p>When i declare a variable, it will be allocated in stack at a certain index of memory right?  </p>\n<p>But when i declare a reference variable it will point to the same index of the other one, so no new space have to be allocated in stack...  </p>\n<p>How does the c++ handle this situation?  </p>\n<p>i mean pratically, it have a table that contains the association between names and indexes?   </p>\n<p>The compiler do all the work?  </p>\n<p>I hope to be clear... If anybody have some manuals or stuff about that i'll be very pleased!</p>\n<p>Thanks to all and sorry if i wrote in a bad english!</p>\n", "Tags": "<c++><reference><stack><aliasing>", "OwnerUserId": "4244128", "AnswerCount": "3"}, "28486496": {"ParentId": "28486257", "CommentCount": "0", "Body": "<p>On a typical implementation, the allocation of the variable depends on how you declare it and where you declare it.  </p>\n<p>Commonly, variables defined outside of a function are placed in one area of memory (neither stack nor heap).  Constants may be placed in a different area or in the executable.  </p>\n<p>Variables defined inside a function that are not <code>static</code> may be allocated on the stack.  They could be placed in registers and not on the stack.  Depends on the compiler and the optimization settings.  The variables could be \"optimized away\" and not exist in the final executable.  </p>\n<p>Many compilers treat references like pointers.  So when you pass a variable by reference, the compiler may pass by pointer.  </p>\n", "OwnerUserId": "225074", "PostTypeId": "2", "Id": "28486496", "Score": "1", "CreationDate": "2015-02-12T19:49:10.063", "LastActivityDate": "2015-02-12T19:49:10.063"}, "28486311": {"ParentId": "28486257", "CommentCount": "0", "Body": "<p>The C++ standard does not specify ABI so this is implementation-defined. But the usual approach is that a reference is implemented as a pointer and so a pointer is allocated on stack. However if this reference is not passed anywhere, it may be optimized away and simply replaced by the variable it points to.</p>\n", "OwnerUserId": "4538344", "PostTypeId": "2", "Id": "28486311", "Score": "1", "CreationDate": "2015-02-12T19:38:15.830", "LastActivityDate": "2015-02-12T19:38:15.830"}, "bq_ids": {"n4140": {"so_28486257_28487370_0": {"section_id": 3221, "quality": 1.0, "length": 5}}, "n3337": {"so_28486257_28487370_0": {"section_id": 3095, "quality": 1.0, "length": 5}}, "n4659": {"so_28486257_28487370_0": {"section_id": 3978, "quality": 1.0, "length": 5}}}, "28487370": {"ParentId": "28486257", "CommentCount": "0", "Body": "<p>C++14 [dcl.ref]/4 says:</p>\n<blockquote>\n<p id=\"so_28486257_28487370_0\">It is unspecified whether or not a reference requires storage</p>\n</blockquote>\n<p>For a situation like <code>int a; int &amp;b = a;</code> the compiler may indeed just store two identifiers that both refer to the same address in its table of identifiers while compiling.  There would probably be no extra runtime storage required here.  Indeed, the rules of C++ say that <code>int b; int &amp;a = b;</code> results in exactly the same situation.</p>\n<p>When a function accepts a parameter by reference: if the compiler was not able to optimize over the function call then it is likely that an address will be passed.</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "28487370", "Score": "0", "CreationDate": "2015-02-12T20:41:48.643", "LastActivityDate": "2015-02-12T20:41:48.643"}});