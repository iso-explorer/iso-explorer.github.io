post_cb({"37116610": {"Id": "37116610", "PostTypeId": "2", "Body": "<p>The first problem is (I think) from <em>\u00a79.3/7 [class.mfct]</em> and probably some other places in the standard (see clang message below and 101010's answer):</p>\n<blockquote>\n<p id=\"so_37115503_37116610_0\">Previously declared member functions may be mentioned in friend declarations.</p>\n</blockquote>\n<p>This problem is similar to the one from <a href=\"https://stackoverflow.com/questions/36821049/member-function-of-incomplete-class-as-friend-formally-valid/36821822\">this question</a>.</p>\n<p>Since you did not declare <code>A&lt;T&gt;::f</code> before <code>C</code>, you cannot declare it has a friend of <code>C</code>.</p>\n<p>But <strong>there is an hidden problem behing clang's message</strong>, if you make <code>A</code> a non-templated class, the message is different:</p>\n<blockquote>\n<p id=\"so_37115503_37116610_1\">Incomplete type <code>A</code> in nested name specifier.</p>\n</blockquote>\n<p>Which is closer to gcc message than the actual one, this is because clang's warning is about something else. Per <strong>\u00a714.5.4/5 [temp.friend]</strong>, the standard allows member of class template to be friend, so this must be valid:</p>\n<pre><code>template &lt;typename T&gt;\nstruct A {\n    void f ();\n};\n\nclass C {\n    template &lt;typename T&gt;\n    friend void A&lt;T&gt;::f(); // Ok, A&lt;T&gt;::f is already declared\n\n    void private_member (); // See below\n};\n</code></pre>\n<p>But clang still complains:</p>\n<blockquote>\n<p id=\"so_37115503_37116610_2\">warning: dependent nested name specifier 'A::' for friend class declaration \n  is not supported; turning off access control for 'C' [-Wunsupported-friend]</p>\n</blockquote>\n<p>clang does not support such <code>friend</code> declaration, so it simply <strong>turns off</strong> access control for <code>C</code>, meaning that:</p>\n<pre><code>C c;\nc.private_member();\n</code></pre>\n<p>Will be \"valid\" everywhere, which may not be what you want.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-05-09T13:21:43.260", "Score": "0", "CreationDate": "2016-05-09T13:06:18.583", "ParentId": "37115503", "CommentCount": "0", "OwnerUserId": "2666289", "LastEditDate": "2017-05-23T11:51:33.273"}, "37115963": {"Id": "37115963", "PostTypeId": "2", "Body": "<h2>Solution</h2>\n<p>You can declare <code>f</code> as a friend of <code>C</code> in the following way:</p>\n<pre><code>class C;\n\ntemplate &lt;class T&gt; struct A {\n  void f(C const &amp;c);\n};\n\nclass C {\n  int i = 42;\npublic:\n  static void foo();\n  template &lt;class T&gt; friend void A&lt;T&gt;::f(C const &amp;c);\n};\n\ntemplate &lt;class T&gt; void A&lt;T&gt;::f(C const &amp;c) { std::cout &lt;&lt; c.i &lt;&lt; std::endl; }\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/89da7e41aa2f9f71\" rel=\"nofollow\"><strong>Live Demo</strong></a></p>\n<h2>Justification</h2>\n<p>According to the standard <em>\u00a73.3.2/p6 Point of declaration [basic.scope.pdecl]</em>:</p>\n<blockquote>\n<p id=\"so_37115503_37115963_0\">After the point of declaration of a class member, the member name can\n  be looked up in the scope of its class. [ Note: this is true even if\n  the class is an incomplete class. For example,</p>\n<pre><code>struct X {\nenum E { z = 16 };\nint b[X::z]; // OK\n};\n</code></pre>\n<p id=\"so_37115503_37115963_1\">\u2014 end note ]</p>\n</blockquote>\n<p>The diagnostic is rather misleading both for GCC and CLANG. The real problem with your code is not the fact that you're trying to access the definition of an incomplete type, but rather is that you can only refer to a class member name only after it has been declared.</p>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2016-05-09T13:10:03.917", "Score": "2", "CreationDate": "2016-05-09T12:33:38.247", "ParentId": "37115503", "CommentCount": "3", "OwnerUserId": "2352671", "LastEditDate": "2016-05-09T13:10:03.917"}, "37116466": {"Id": "37116466", "PostTypeId": "2", "Body": "<p>Firstly, Forward declaration of a class is not sufficient if you need to use the actual class type, for example, if you need to use it as a base class, or if you need to use the methods of the class in a method.</p>\n<p>Since here you try to use its details \"foo()\", there is no way compiler knows what is A::foo().. Compiler cannot distinguish if it is a typo (or) actual function.. it needs to know the declaration of A::foo() before you can use it. </p>\n<p>If you still want to only to forward declare the class and make it a friend, see if friend classes fit your situation</p>\n<pre><code>template &lt;class T&gt; struct A;\n\nclass C{\n   template &lt;class T&gt; friend struct A;\n};\n</code></pre>\n", "LastActivityDate": "2016-05-09T12:58:48.550", "CommentCount": "0", "CreationDate": "2016-05-09T12:58:48.550", "ParentId": "37115503", "Score": "0", "OwnerUserId": "4248850"}, "37115503": {"ViewCount": "279", "Body": "<p>Is this code invalid:</p>\n<pre><code>template &lt;class T&gt; struct A;\n\nclass C {\n    template &lt;class T&gt; friend void A&lt;T&gt;::foo();\n};\n</code></pre>\n<p>In GCC 6.1.0 it says:</p>\n<pre><code>error: member 'void A&lt;T&gt;::foo()' declared as friend before type 'A&lt;T&gt;' defined\n\n     template &lt;class T&gt; friend void A&lt;T&gt;::foo();\n</code></pre>\n<p>Clang 3.8.0:</p>\n<pre><code>warning: dependent nested name specifier 'A&lt;T&gt;::' for friend class declaration \nis not supported; turning off access control for 'C' [-Wunsupported-friend]\n</code></pre>\n<p>And Visual Studio 2015 crashes:</p>\n<pre><code>fatal error C1001: An internal error has occurred in the compiler.\n(compiler file 'f:\\dd\\vctools\\compiler\\cxxfe\\sl\\p1\\c\\template.cpp', line 8952)\n        template &lt;class T&gt; friend void A&lt;T&gt;::foo();\n</code></pre>\n<p>More specifically, is <code>A</code> required to be defined before the friend declaration?</p>\n<pre><code>  template &lt;class T&gt; struct A;\n\n  class C {\n    static void foo();\n    template &lt;class T&gt; friend void A&lt;T&gt;::f();\n  };\n\n  template &lt;class T&gt; struct A {\n    void f() { }\n  };\n</code></pre>\n<p>If so, why?</p>\n", "Title": "Friend of function in dependent scope", "CreationDate": "2016-05-09T12:11:30.777", "LastActivityDate": "2016-05-09T13:21:43.260", "CommentCount": "2", "LastEditDate": "2016-05-09T12:22:51.007", "PostTypeId": "1", "LastEditorUserId": "6292850", "Id": "37115503", "Score": "7", "OwnerUserId": "6292850", "Tags": "<c++>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_37115503_37115963_0": {"length": 18, "quality": 0.9, "section_id": 7054}, "so_37115503_37116610_0": {"length": 8, "quality": 1.0, "section_id": 5886}}, "n3337": {"so_37115503_37116610_0": {"length": 8, "quality": 1.0, "section_id": 5657}, "so_37115503_37115963_0": {"length": 18, "quality": 0.9, "section_id": 6798}}, "n4659": {"so_37115503_37116610_0": {"length": 8, "quality": 1.0, "section_id": 7369}, "so_37115503_37115963_0": {"length": 18, "quality": 0.9, "section_id": 8551}}}, "37115844": {"Id": "37115844", "PostTypeId": "2", "Body": "<p>You refer to <code>A</code>'s member function <code>foo</code>. This function is not known to exist yet, because you only forward declare <code>A</code>.</p>\n<p>In other words, you'll have to declare <code>A&lt;T&gt;::foo</code> before <code>C</code>, as the GCC message tries to tell you (the other two are rather cryptic). This means you have to declare the complete interface of <code>A</code> before <code>C</code>, instead of only forward declaring it.</p>\n", "LastActivityDate": "2016-05-09T12:28:30.060", "CommentCount": "1", "CreationDate": "2016-05-09T12:28:30.060", "ParentId": "37115503", "Score": "4", "OwnerUserId": "2386170"}});