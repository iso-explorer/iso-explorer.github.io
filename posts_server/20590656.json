post_cb({"bq_ids": {"n4140": {"so_20590656_20602159_0": {"length": 20, "quality": 1.0, "section_id": 6299}}, "n3337": {"so_20590656_20602159_0": {"length": 20, "quality": 1.0, "section_id": 6056}}, "n4659": {"so_20590656_20602159_0": {"length": 20, "quality": 1.0, "section_id": 7808}}}, "20602159": {"Id": "20602159", "PostTypeId": "2", "Body": "<p>Unfortunately, this program has undefined behavior. C++11 \u00a717.6.4.2.1:</p>\n<blockquote>\n<p id=\"so_20590656_20602159_0\">A program may add a template specialization for any standard library template to namespace std only if the declaration depends on a user-defined type and the specialization meets the standard library requirements for the original template and is not explicitly prohibited.</p>\n</blockquote>\n<p><code>hash&lt;pair&lt;int,int&gt;&gt;</code> depends on primitive and standard library types only. This is easily worked around by defining your hash class outside of namespace <code>std</code>, and using that hash explicitly in your map declaration:</p>\n<pre><code>struct pairhash {\npublic:\n  template &lt;typename T, typename U&gt;\n  std::size_t operator()(const std::pair&lt;T, U&gt; &amp;x) const\n  {\n    return std::hash&lt;T&gt;()(x.first) ^ std::hash&lt;U&gt;()(x.second);\n  }\n};\n\nclass abc {\n  std::unordered_map&lt;std::pair&lt;int,int&gt;, int, pairhash&gt; rules;\n};\n</code></pre>\n<p>EDIT: I've used xor to combine the hashes of the pair members here because I'm lazy, but for serious use <a href=\"https://stackoverflow.com/questions/5889238/why-is-xor-the-default-way-to-combine-hashes\">xor is a fairly crappy hash combining function</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-03-26T15:46:59.580", "Score": "32", "CreationDate": "2013-12-16T01:35:29.360", "ParentId": "20590656", "CommentCount": "8", "OwnerUserId": "923854", "LastEditDate": "2017-05-23T11:54:17.563"}, "20590656": {"ViewCount": "17357", "Body": "<p>I have the following class with an <code>unordered_map</code> member, and a hash function defined for <code>pair&lt;int,int&gt;</code> </p>\n<pre><code>class abc\n{public :\n    unordered_map &lt; pair&lt;int,int&gt; , int &gt; rules ;\n    unsigned nodes;\n    unsigned packet ;     \n};\n\nnamespace std {\ntemplate &lt;&gt;\n    class hash &lt; std::pair&lt; int,int&gt; &gt;{\n    public :\n        size_t operator()(const pair&lt; int, int&gt; &amp;x ) const\n        {\n            size_t h =   std::hash&lt;int&gt;()(x.first) ^ std::hash&lt;int&gt;()(x.second);\n            return  h ;\n        }\n    };\n}\n</code></pre>\n<p>But I am getting the following errors : </p>\n<pre><code>error: invalid use of incomplete type \u2018struct std::hash&lt;std::pair&lt;int, int&gt; &gt;\n\nerror: declaration of \u2018struct std::hash&lt;std::pair&lt;int, int&gt; &gt;\n\nerror: type \u2018std::__detail::_Hashtable_ebo_helper&lt;1, std::hash&lt;std::pair&lt;int, int&gt; &gt;, true&gt;\u2019 is not a direct base of \u2018std::__detail::_Hash_code_base&lt;std::pair&lt;int, int&gt;, std::pair&lt;const std::pair&lt;int, int&gt;, int&gt;, std::__detail::_Select1st, std::hash&lt;std::pair&lt;int, int&gt; &gt;, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, true&gt;\u2019\n</code></pre>\n", "AcceptedAnswerId": "20602159", "Title": "error for hash function of pair of ints", "CreationDate": "2013-12-15T02:42:03.260", "Id": "20590656", "CommentCount": "3", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2016-04-05T18:47:40.553", "LastEditorUserId": "3863903", "LastActivityDate": "2016-04-05T18:47:40.553", "Score": "24", "OwnerUserId": "2298415", "Tags": "<c++><c++11><hash><stl><unordered-map>", "AnswerCount": "1"}});