post_cb({"39376848": {"Id": "39376848", "PostTypeId": "2", "Body": "<p><code>std::array</code> provides method <a href=\"http://en.cppreference.com/w/cpp/container/array/data\">data()</a> which can be used to copy to/from c-style array of proper size:</p>\n<pre><code>const size_t size = 123;\nint carray[size];\nstd::array&lt;int,size&gt; array;\n\nmemcpy( carray, array.data(), sizeof(int) * size );\nmemcpy( array.data(), carray, sizeof(int) * size );\n</code></pre>\n<p>As stated on <a href=\"http://en.cppreference.com/w/cpp/container/array\">documentation</a></p>\n<blockquote>\n<p id=\"so_39376813_39376848_0\">This container is an aggregate type with the same semantics as a struct holding a C-style array T[N] as its only non-static data member.</p>\n</blockquote>\n<p>so it seems that memory footprint would be compatible with c-style array, though it is not clear why you want to use \"hacks\" with <code>reinterpret_cast</code> when there is a proper way which does not have any overhead.</p>\n", "LastEditorUserId": "432358", "LastActivityDate": "2016-09-07T18:39:36.697", "Score": "12", "CreationDate": "2016-09-07T18:27:39.523", "ParentId": "39376813", "CommentCount": "2", "OwnerUserId": "432358", "LastEditDate": "2016-09-07T18:39:36.697"}, "39377268": {"Id": "39377268", "PostTypeId": "2", "Body": "<p>The requirement on the <code>data()</code> method is that it return a pointer <code>T*</code> such that:</p>\n<blockquote>\n<p id=\"so_39376813_39377268_0\"><code>[data(), data() + size())</code> is a valid range, and <code>data() == addressof(front())</code>.</p>\n</blockquote>\n<p>This implies that you can access each element sequentially via the <code>data()</code> pointer, and so if <code>T</code> is trivially copyable you can indeed use <code>memcpy</code> to copy <code>sizeof(T) * size()</code> bytes to/from an array <code>T[size()]</code>, since this is equivalent to <code>memcpy</code>ing each element individually.</p>\n<p>However, you cannot use <code>reinterpret_cast</code>, since that would violate strict aliasing, as <code>data()</code> is not required to <em>actually</em> be backed by an array - and also, even if you were to guarantee that <code>std::array</code> contains an array, since C++17 you cannot (even using <code>reinterpret_cast</code>) cast a pointer to an array to/from a pointer to its first member (you have to use <code>std::launder</code>).</p>\n", "LastActivityDate": "2016-09-07T18:55:48.410", "CommentCount": "18", "CreationDate": "2016-09-07T18:55:48.410", "ParentId": "39376813", "Score": "9", "OwnerUserId": "567292"}, "39379359": {"Id": "39379359", "PostTypeId": "2", "Body": "<p>I say yes (but the standard does not guarantee it).</p>\n<p>According to [array]/2:</p>\n<blockquote>\n<p id=\"so_39376813_39379359_0\">An array is an <em>aggregate</em> ([<a href=\"http://eel.is/c++draft/dcl.init.aggr\" rel=\"noreferrer\">dcl.init.aggr</a>]) that can be\n  list-initialized with up to N elements whose types are convertible to\n  T.</p>\n</blockquote>\n<p>And [dcl.init.aggr]:</p>\n<blockquote>\n<p id=\"so_39376813_39379359_1\">An <em>aggregate</em> is an array or a class (Clause [class]) with</p>\n<ul>\n<li><p id=\"so_39376813_39379359_2\">no user-provided, explicit, or inherited constructors ([class.ctor]),</p></li>\n<li><p id=\"so_39376813_39379359_3\">no private or protected non-static data members (Clause\n  [class.access]),</p></li>\n<li><p id=\"so_39376813_39379359_4\">no virtual functions ([class.virtual]), and</p></li>\n<li><p id=\"so_39376813_39379359_5\">no virtual, private, or protected base classes ([class.mi]).</p></li>\n</ul>\n</blockquote>\n<p>In light of this, <em>\"can be list-initialized\"</em> is only possible if there are no other members in the beginning of the class and no vtable.</p>\n<p>Then, <code>data()</code> is specified as:</p>\n<blockquote>\n<p id=\"so_39376813_39379359_6\"><code>constexpr T* data() noexcept;</code>\n<br><br>\n<em>Returns</em>: A pointer such that <code>[data(), data() + size())</code> is a valid range, and <code>data() == addressof(front())</code>.</br></br></p>\n</blockquote>\n<p>The standard basically wants to say \"it returns an array\" but leaves the door open for other implementations.</p>\n<p>The only possible other implementation is a structure with individual elements, in which case you <em>can</em> run into aliasing problems. But in my view this approach does not add anything but complexity. There is nothing to gain by unrolling an array into a struct.</p>\n<p>So it makes <strong>no sense</strong> <em>not</em> to implement <code>std::array</code> as an array.</p>\n<p>But a loophole does exist.</p>\n", "LastEditorUserId": "485343", "LastActivityDate": "2016-09-08T09:05:43.333", "Score": "8", "CreationDate": "2016-09-07T21:34:44.313", "ParentId": "39376813", "CommentCount": "5", "OwnerUserId": "485343", "LastEditDate": "2016-09-08T09:05:43.333"}, "bq_ids": {"n4140": {"so_39376813_39379359_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 775}, "so_39376813_39379359_5": {"length": 4, "quality": 0.6666666666666666, "section_id": 3298}, "so_39376813_39377033_0": {"length": 14, "quality": 0.7368421052631579, "section_id": 777}, "so_39376813_39379359_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 3298}, "so_39376813_39377268_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 984}, "so_39376813_39379359_1": {"length": 4, "quality": 0.8, "section_id": 3298}}, "n3337": {"so_39376813_39379359_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 762}, "so_39376813_39379359_5": {"length": 4, "quality": 0.6666666666666666, "section_id": 3168}, "so_39376813_39377033_0": {"length": 14, "quality": 0.7368421052631579, "section_id": 764}, "so_39376813_39379359_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 3168}, "so_39376813_39377268_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 969}, "so_39376813_39379359_1": {"length": 4, "quality": 0.8, "section_id": 3168}}, "n4659": {"so_39376813_39379359_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 836}, "so_39376813_39379359_2": {"length": 4, "quality": 0.8, "section_id": 4063}, "so_39376813_39379359_3": {"length": 6, "quality": 0.8571428571428571, "section_id": 4063}, "so_39376813_39379359_6": {"length": 7, "quality": 0.5384615384615384, "section_id": 1047}, "so_39376813_39377268_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 1047}, "so_39376813_39379359_1": {"length": 5, "quality": 1.0, "section_id": 6103}, "so_39376813_39379359_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 4063}}}, "39376813": {"ViewCount": "2423", "Body": "<p>Is the underlying <em>bit representation</em> for an <code>std::array&lt;T,N&gt; v</code> and a <code>T u[N]</code> the same?</p>\n<p>In other words, is it safe to copy <code>N*sizeof(T)</code> bytes from one to the other? (Either through <code>reinterpret_cast</code> or <code>memcpy</code>.)</p>\n<p><strong>Edit:</strong></p>\n<p>For clarification, the emphasis is on <em>same bit representation</em> and <code>reinterpret_cast</code>.</p>\n<p>For example, let's suppose I have these two classes over some trivially copyable type <code>T</code>, for some <code>N</code>:</p>\n<pre><code>struct VecNew {\n    std::array&lt;T,N&gt; v;\n};\n\nstruct VecOld {\n    T v[N];\n};\n</code></pre>\n<p>And there is the legacy function</p>\n<pre><code>T foo(const VecOld&amp; x);\n</code></pre>\n<p>If the representations are the same, then this call is safe and avoids copying:</p>\n<pre><code>VecNew x;\nfoo(reinterpret_cast&lt;const VecOld&amp;&gt;(x));\n</code></pre>\n", "AcceptedAnswerId": "39379359", "Title": "Is the std::array bit compatible with the old C array?", "CreationDate": "2016-09-07T18:24:43.340", "Id": "39376813", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-09-07T20:38:53.703", "LastEditorUserId": "369450", "LastActivityDate": "2016-09-08T09:05:43.333", "Score": "29", "OwnerUserId": "190806", "Tags": "<c++><c++11><memcpy><reinterpret-cast>", "AnswerCount": "5"}, "39377033": {"Id": "39377033", "PostTypeId": "2", "Body": "<p><code>array</code> doesn't mandate much about the underlying type over which you instantiate it.</p>\n<p>To have <em>any</em> possibility of useful results from using <code>memcpy</code> or <code>reinterpret_cast</code> to do a copy, the type you instantiated it over would have to be trivially copyable. Storing those items in an <code>array</code> doesn't affect the requirement that <code>memcpy</code> (and such) only work with trivially copyable types.</p>\n<p><code>array</code> is required to be a <em>contiguous container</em> and an aggregate, which pretty much means that the storage for the elements must be an array. The standard shows it as:</p>\n<pre><code>T elems[N]; // exposition only\n</code></pre>\n<p>It later, however, has a note that at least implies that it's being an array is required (\u00a7[array.overview]/4):</p>\n<blockquote>\n<p id=\"so_39376813_39377033_0\">[Note: The member variable <code>elems</code> is shown for exposition only, to emphasize that <code>array</code> is a class aggregate.\n  <strong>The name <code>elems</code> is not part of array\u2019s interface.</strong> \u2014end note]</p>\n</blockquote>\n<p>[emphasis added]</p>\n<p>Note how it's really only the specific name <code>elems</code> that isn't required.</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2016-09-07T18:57:33.423", "Score": "6", "CreationDate": "2016-09-07T18:40:12.680", "ParentId": "39376813", "CommentCount": "7", "OwnerUserId": "179910", "LastEditDate": "2016-09-07T18:57:33.423"}, "39377145": {"Id": "39377145", "PostTypeId": "2", "Body": "<p>This doesn't directly answer your question, but you should simply use <a href=\"http://en.cppreference.com/w/cpp/algorithm/copy\" rel=\"noreferrer\"><code>std::copy</code></a>:</p>\n<pre><code>T c[N];\nstd::array&lt;T, N&gt; cpp;\n\n// from C to C++\nstd::copy(std::begin(c), std::end(c), std::begin(cpp));\n\n// from C++ to C\nstd::copy(std::begin(cpp), std::end(cpp), std::begin(c));\n</code></pre>\n<p>If <code>T</code> is a trivially copyable type, this'll compile down to <code>memcpy</code>. If it's not, then this'll do element-wise copy assignment and be correct. Either way, this does the Right Thing and is quite readable. No manual byte arithmetic necessary. </p>\n", "LastActivityDate": "2016-09-07T18:48:14.117", "CommentCount": "2", "CreationDate": "2016-09-07T18:48:14.117", "ParentId": "39376813", "Score": "20", "OwnerUserId": "2069064"}});