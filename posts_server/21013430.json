post_cb({"bq_ids": {"n4140": {"so_21013430_21013943_0": {"length": 27, "quality": 1.0, "section_id": 456}, "so_21013430_21013852_1": {"length": 38, "quality": 0.9743589743589743, "section_id": 467}, "so_21013430_21013852_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 456}, "so_21013430_21013943_1": {"length": 29, "quality": 1.0, "section_id": 467}}, "n3337": {"so_21013430_21013943_0": {"length": 27, "quality": 1.0, "section_id": 447}, "so_21013430_21013852_1": {"length": 38, "quality": 0.9743589743589743, "section_id": 458}, "so_21013430_21013852_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 447}, "so_21013430_21013943_1": {"length": 29, "quality": 1.0, "section_id": 458}}, "n4659": {"so_21013430_21013943_0": {"length": 27, "quality": 1.0, "section_id": 479}, "so_21013430_21013852_1": {"length": 38, "quality": 0.9743589743589743, "section_id": 490}, "so_21013430_21013852_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 479}, "so_21013430_21013943_1": {"length": 29, "quality": 1.0, "section_id": 490}}}, "21013430": {"ViewCount": "2983", "Body": "<p>Let's say I have this class:</p>\n<pre><code>class Test\n{\npublic:\n    Test();\n};\n</code></pre>\n<p>AFAIK, compiler provides default copy constructor and assignment operators, which assign every member of other instance to the current instance. Now I add move constructor and assignment:</p>\n<pre><code>class Test\n{\npublic:\n    Test();\n    Test(Test&amp;&amp; other);\n    Test&amp; operator=(Test&amp;&amp; other);\n};\n</code></pre>\n<p>Does this class still contain compiler-generated copy constructor and assignment operators, or I need to implement them?</p>\n<p><strong>Edit</strong>. This is my test:</p>\n<pre><code>class Test\n{\npublic:\n    Test(){}\n\n    Test(Test&amp;&amp; other){}\n    Test&amp; operator=(Test&amp;&amp; other)\n    {\n        return *this;\n    }\n\n    int n;\n    char str[STR_SIZE];\n};\n\nint main()\n{\n    Test t1;\n    t1.n = 2;\n    strcpy(t1.str, \"12345\");\n\n    Test t2(t1);\n\n    Test t3;\n    t3 = t1;\n\n    cout &lt;&lt; t2.n &lt;&lt; \" \" &lt;&lt; t2.str &lt;&lt; \" \" &lt;&lt; t3.n &lt;&lt; \" \" &lt;&lt; t3.str &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>Prints <code>2 12345 2 12345</code>. Compiler: VC++ 2010. According to this test, copy constructor and assignment are still here. Is this standard behavior, can I be sure that this will work on every C++ compiler?</p>\n", "AcceptedAnswerId": "21013852", "Title": "Default copy constructor and assignment for class with move constructor and assignment", "CreationDate": "2014-01-09T06:50:01.790", "Id": "21013430", "CommentCount": "0", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2014-01-09T07:24:59.723", "LastEditorUserId": "279313", "LastActivityDate": "2014-01-09T07:42:17.557", "Score": "5", "OwnerUserId": "279313", "Tags": "<c++><c++11><move-semantics>", "AnswerCount": "2"}, "21013943": {"Id": "21013943", "PostTypeId": "2", "Body": "<p>According to section 12.8 Copying and moving class objects of the C++ Standard</p>\n<blockquote>\n<p id=\"so_21013430_21013943_0\">7 If the class definition does not explicitly declare a copy\n  constructor, one is declared implicitly. If the class definition\n  declares a move constructor or move assignment operator, the\n  implicitly declared copy constructor is defined as deleted; otherwise,\n  it is defined as defaulted (8.4).</p>\n<p id=\"so_21013430_21013943_1\">18 If the class definition does not explicitly declare a copy\n  assignment operator, one is declared implicitly. If the class\n  definition declares a move constructor or move assignment operator,\n  the implicitly declared copy assignment operator is defined as\n  deleted; otherwise, it is defined as defaulted (8.4).</p>\n</blockquote>\n<p>So in your case and the copy constructor and the copy assignment operator are implicitly declared by the compiler but defined as deleted.</p>\n", "LastActivityDate": "2014-01-09T07:19:27.217", "CommentCount": "0", "CreationDate": "2014-01-09T07:19:27.217", "ParentId": "21013430", "Score": "1", "OwnerUserId": "2877241"}, "21013852": {"Id": "21013852", "PostTypeId": "2", "Body": "<p>From <strong>12.8-7 Copying and moving class objects [class.copy]</strong></p>\n<blockquote>\n<p id=\"so_21013430_21013852_0\">If the class definition does not explicitly declare a copy constructor, one is declared <em>implicitly</em>. If the class definition declares a move constructor or move assignment operator, the implicitly declared copy constructor is defined as deleted; otherwise, it is defined as defaulted (8.4). The latter case is deprecated if the class has a user-declared copy assignment operator or a user-declared destructor...</p>\n</blockquote>\n<p>From <strong>12.8-18</strong></p>\n<blockquote>\n<p id=\"so_21013430_21013852_1\">If the class definition does not explicitly declare a copy assignment operator, one is declared implicitly. If the class definition declares a move constructor or move assignment operator, the implicitly declared copy assignment operator is defined as deleted; otherwise, it is defined as defaulted (8.4). The latter case is deprecated if the class has a user-declared copy constructor or a user-declared destructor...</p>\n</blockquote>\n<p>According to this, since you have declared a move constructor <em>and</em> a move assignment operator, but no copy assignment operator, copy constructor or destructor, you do <strong>not</strong> get the implicitly generated copy constructor or assignment operator. The compiler gives you their <em>declarations</em>, but they are declared as <code>deleted</code>.</p>\n<p>Here is a simplified version of your example:</p>\n<pre><code>struct Test\n{\npublic:\n    Test(){}\n    Test(Test&amp;&amp; other){}\n    Test&amp; operator=(Test&amp;&amp; other) { return *this;}\n};\n\nint main()\n{\n  Test t1;\n  Test t2(t1);\n}\n</code></pre>\n<p>And the error produced by g++ 4.8.1</p>\n<blockquote>\n<p id=\"so_21013430_21013852_2\">ctors.cpp:13:13: error: use of deleted function 'constexpr Test::Test(const Test&amp;)'</p>\n<p id=\"so_21013430_21013852_3\">Test t2(t1);</p>\n<p id=\"so_21013430_21013852_4\">ctors.cpp:1:8: note: 'constexpr Test::Test(const Test&amp;)' is implicitly declared as deleted <em>because 'Test' declares a move constructor or move assignment operator</em></p>\n<p id=\"so_21013430_21013852_5\">struct Test</p>\n</blockquote>\n<p>(emphasis mine)</p>\n", "LastEditorUserId": "661519", "LastActivityDate": "2014-01-09T07:42:17.557", "Score": "5", "CreationDate": "2014-01-09T07:14:11.227", "ParentId": "21013430", "CommentCount": "6", "OwnerUserId": "661519", "LastEditDate": "2014-01-09T07:42:17.557"}});