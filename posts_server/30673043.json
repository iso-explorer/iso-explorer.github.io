post_cb({"30673043": {"CommentCount": "11", "ViewCount": "322", "PostTypeId": "1", "LastEditorUserId": "1858225", "CreationDate": "2015-06-05T18:04:42.757", "LastActivityDate": "2015-06-05T18:26:09.493", "Title": "Get similar behavior between Clang and GCC for uninstantiated templates?", "LastEditDate": "2015-06-05T18:19:11.510", "Id": "30673043", "Score": "1", "Body": "<p>GCC seems to be much more permissive regarding template code that is never instantiated than Clang is. I have a codebase that compiles without warning or error using <code>g++-5.1</code> (using <code>-Wall -Wextra -Wdeprecated -Wno-comment -Wnoexcept</code>), but emits many errors regarding template code using <code>clang++-3.7</code> unless I specify <code>-fdelayed-template-parsing</code>. The documentation on this flag is pretty scarce; all I can find is a <a href=\"http://clang.llvm.org/docs/UsersManual.html#microsoft-extensions\" rel=\"nofollow\">single sentence</a> describing its behavior:</p>\n<blockquote>\n<p id=\"so_30673043_30673043_0\"><code>-fdelayed-template-parsing</code> lets clang delay parsing of function template definitions until the end of a translation unit.</p>\n</blockquote>\n<p>Even this seems like it might be incorrect--I <em>think</em> the problem is that the templates are being parsed <em>at all</em>, and that the flag is actually allowing Clang to complete the compile without <em>ever</em> parsing the templates in question.</p>\n<p>So I'd like to know:</p>\n<ol>\n<li>How similar is the behavior of <code>-fdelayed-template-parsing</code> to the default behavior of GCC? The option itself is based on MSVC, which, as the flag-name implies, doesn't even check for basic syntax issues such as missing semicolons in uninstantiated template code. I believe GCC goes a little further than MSVC here, so does this flag actually make Clang <em>less</em> restrictive than GCC?</li>\n<li>Going the other way, is there a way to make GCC behave more like Clang in this respect, by issuing an error, or at least a warning, for illegal code inside of uninstantiated templates?</li>\n</ol>\n<p><strong>EDIT:</strong> As requested, here's a trivial example of a template that (if not instantiated) does <em>not</em> cause an error with GCC but <em>does</em> cause an error with Clang:</p>\n<pre><code>template &lt;typename T&gt;\nstd::string neverInstantiated(void)\n{\n    return 3;\n}\n</code></pre>\n<p>Obviously, since the template parameter is unused, this would be flagrantly incorrect regardless of how it is instantiated.</p>\n", "Tags": "<c++><templates><c++11><g++><clang++>", "OwnerUserId": "1858225", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_30673043_30673381_0": {"section_id": 175, "quality": 1.0, "length": 11}}, "n3337": {"so_30673043_30673381_0": {"section_id": 169, "quality": 1.0, "length": 11}}, "n4659": {"so_30673043_30673381_0": {"section_id": 180, "quality": 0.8181818181818182, "length": 9}}}, "30673381": {"ParentId": "30673043", "CommentCount": "3", "Body": "<p>From [temp.res]:</p>\n<blockquote>\n<p id=\"so_30673043_30673381_0\">If no valid specialization can be generated for a template, and that template is not instantiated, the template is ill-formed, no diagnostic\n  required.</p>\n</blockquote>\n<p>So both compilers have valid behavior in this respect. </p>\n<p>However, rather than trying to get clang to not issue a diagnostic, or trying to get GCC <em>to</em> issue one... I think it'd be better to take advantage of clang's additional diagnostic here and simply <strong>delete</strong> the ill-formed templates! Why would you want to pollute your codebase with invalid code anyway?</p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "30673381", "Score": "2", "CreationDate": "2015-06-05T18:26:09.493", "LastActivityDate": "2015-06-05T18:26:09.493"}});