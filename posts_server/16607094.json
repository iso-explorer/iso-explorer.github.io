post_cb({"bq_ids": {"n4140": {"so_16607094_16608475_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 7223}}, "n3337": {"so_16607094_16608475_1": {"length": 4, "quality": 0.5714285714285714, "section_id": 6967}}}, "16608475": {"LastActivityDate": "2013-05-18T16:15:32.330", "CommentCount": "15", "Body": "<p><strong>1.</strong> The answer to the original question for which the central code part was this:</p>\n<pre><code>else if( strcmp( pszToken, \"TJ\" ) == 0 ) \n{\n    PdfArray array = stack.top().GetArray();\n    stack.pop();\n\n    for( int i=0; i&lt;static_cast&lt;int&gt;(array.GetSize()); i++ ) \n    {\n        if( array[i].IsString() )\n            AddTextElement( dCurPosX, dCurPosY, pCurFont, array[i].GetString() );\n        }\n    }\n}\n</code></pre>\n<p>and the question was:</p>\n<blockquote>\n<p id=\"so_16607094_16608475_0\">I've noticed that the the <code>array[i].IsString()</code> never gets to be true. Is this the right way to get the text from a <strong><em>TJ</em></strong> operator? </p>\n</blockquote>\n<p><strong>The short answer:</strong></p>\n<p>Hexadecimal strings in PoDoFo <code>PdfVariants</code> are recognized by <code>IsHexString()</code> instead of <code>IsString()</code>. Thus, you have to test for both string flavors:</p>\n<pre><code>if( array[i].IsString() || array[i].IsHexString() )\n</code></pre>\n<p><strong>The long answer:</strong></p>\n<p>There are two basic flavors of strings in PDF:</p>\n<blockquote>\n<p id=\"so_16607094_16608475_1\">String objects shall be written in one of the following two ways:</p>\n<ul>\n<li><p id=\"so_16607094_16608475_2\">As a sequence of literal characters enclosed in parentheses ( ) (using LEFT PARENTHESIS (28h) and RIGHT PARENThESIS (29h)); see 7.3.4.2, \"Literal Strings.\"</p></li>\n<li><p id=\"so_16607094_16608475_3\">As hexadecimal data enclosed in angle brackets &lt; &gt; (using LESS-THAN SIGN (3Ch) and GREATER-THAN SIGN (3Eh)); see 7.3.4.3, \"Hexadecimal Strings.\"</p></li>\n</ul>\n<p id=\"so_16607094_16608475_4\"><em>(section 7.3.4 in <a href=\"http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/PDF32000_2008.pdf\" rel=\"nofollow\">ISO 32000-1</a>)</em></p>\n</blockquote>\n<p>PoDoFo models both using the <code>PdfString</code> class which in the context of parsing often is wrapped inside a <code>PdfVariant</code> or even more specifically in a <code>PdfObject</code>.</p>\n<p>When determining the type of the object contained in it, though, the <code>PdfVariant</code> differentiates between literal strings and hexadecimal strings:</p>\n<pre><code>/** \\returns true if this variant is a string (i.e. GetDataType() == ePdfDataType_String)\n */\ninline bool IsString() const { return GetDataType() == ePdfDataType_String; }\n\n/** \\returns true if this variant is a hex-string (i.e. GetDataType() == ePdfDataType_HexString)\n */\ninline bool IsHexString() const { return GetDataType() == ePdfDataType_HexString; }\n</code></pre>\n<blockquote>\n<p id=\"so_16607094_16608475_5\"><em>(<a href=\"http://svn.code.sf.net/p/podofo/code/podofo/trunk/src/base/PdfVariant.h\" rel=\"nofollow\">PdfVariant.h</a>)</em></p>\n</blockquote>\n<p>The type of the <code>PdfString</code> inside a <code>PdfVariant</code> is determined when wrapped:</p>\n<pre><code>PdfVariant::PdfVariant( const PdfString &amp; rsString )\n{\n    Init();\n    Clear();\n\n    m_eDataType  = rsString.IsHex() ? ePdfDataType_HexString : ePdfDataType_String;\n    m_Data.pData = new PdfString( rsString );\n}\n</code></pre>\n<blockquote>\n<p id=\"so_16607094_16608475_6\"><em>(<a href=\"http://svn.code.sf.net/p/podofo/code/podofo/trunk/src/base/PdfVariant.cpp\" rel=\"nofollow\">PdfVariant.cpp</a>)</em></p>\n</blockquote>\n<p>In case of your <strong>TJ</strong> argument array components, the strings in question are read as hexadecimal strings.</p>\n<p>In your code, therefore, you have to consider both <code>IsHexString()</code> and <code>IsString()</code>:</p>\n<pre><code>if( array[i].IsString() || array[i].IsHexString() )\n</code></pre>\n<p><strong>2.</strong> Thereafter, and after the code was revised to check using <code>IsHexString(),</code> the question centered on</p>\n<pre><code>PdfString s = array[i].GetString();\n_RPT1(_CRT_WARN, \" : valid :%s   \", s.IsValid()?\"yes\":\"not\");\n_RPT1(_CRT_WARN, \" ;hex :%s   \", s.IsHex()?\"yes\":\"not\");\n_RPT1(_CRT_WARN, \" ;unicode: %s   \", s.IsUnicode()?\"yes\":\"not\");\n\nPdfString unicode = pCurFont-&gt;GetEncoding()-&gt;ConvertToUnicode(s,pCurFont);\nconst char* szText = unicode.GetStringUtf8().c_str();\n_RPT1(_CRT_WARN, \" : %s\\n\", strlen(szText)&gt; 0? szText: \"nothing\");\n</code></pre>\n<p>and the problem (as stated in comments) that</p>\n<blockquote>\n<p id=\"so_16607094_16608475_7\">the <code>s.GetLength()</code> returns 2 and <code>unicode.GetLength()</code> returns 0, the conversion didn't work?</p>\n</blockquote>\n<p>An analysis of the example documents <a href=\"http://www.filedropper.com/document2\" rel=\"nofollow\">Document2.pdf</a> shows that the document in question does contain the required informations for text extraction. The only font present in that document which is used with hexadecimal encoding is <strong>/F1</strong>, and its font dictionary does contain an appropriate <strong>/ToUnicode</strong> map for reliable text extraction.</p>\n<p>Unfortunately, though, PoDoFo does not yet seem to have implemented properly using that map for parsing purposes. I do not see it anywhere retrieving the <strong>/ToUnicode</strong> map to make the contained informations available for text parsing. It looks like PoDoFo cannot be used to properly parse the text of documents using Type0 aka composite font.</p>\n", "CreationDate": "2013-05-17T11:59:54.620", "LastEditDate": "2013-05-18T16:15:32.330", "ParentId": "16607094", "Id": "16608475", "LastEditorUserId": "1729265", "PostTypeId": "2", "Score": "4", "OwnerUserId": "1729265"}, "16607094": {"CreationDate": "2013-05-17T10:43:54.797", "ViewCount": "2827", "FavoriteCount": "2", "Id": "16607094", "AcceptedAnswerId": "16608475", "Score": "1", "Title": "Extract text from array TJ in PDF operator using PoDoFo lib", "LastEditorUserId": "376249", "CommentCount": "0", "Body": "<p>I am trying to extract text from a PDF file usind the PoDoFo library, it is working for the <strong><em>Tj</em></strong> operator and fails to do so for the <em>(array) <strong>TJ</strong></em></p>  operator. I ve found this piece of code(with my small modification) <a href=\"http://libpodofo.sourcearchive.com/documentation/0.8.4/dir_385d570d5b330000523c59e421af4f6c.html\" rel=\"nofollow\">here</a> : \n<pre><code> const char*      pszToken = NULL;\n    PdfVariant       var;\n    EPdfContentsType eType;\n\n    PdfContentsTokenizer tokenizer( pPage );\n\n    double dCurPosX     = 0.0;\n    double dCurPosY     = 0.0;\n    double dCurFontSize = 0.0;\n    bool   bTextBlock   = false;\n    PdfFont* pCurFont   = NULL;\n\n    std::stack&lt;PdfVariant&gt; stack;\n\n\n\nwhile( tokenizer.ReadNext( eType, pszToken, var ) )\n{\n\n    if( eType == ePdfContentsType_Keyword )\n    {\n        // support 'l' and 'm' tokens\n\n        _RPT1(_CRT_WARN, \" %s\\n\", pszToken);\n\n        if( strcmp( pszToken, \"l\" ) == 0 || \n            strcmp( pszToken, \"m\" ) == 0 )\n        {\n            dCurPosX = stack.top().GetReal();\n            stack.pop();\n            dCurPosY = stack.top().GetReal();\n            stack.pop();\n        }\n        else if (strcmp(pszToken, \"Td\") == 0)\n        {\n            dCurPosY = stack.top().GetReal();\n            stack.pop();\n            dCurPosX = stack.top().GetReal();\n            stack.pop();\n        }\n        else if (strcmp(pszToken, \"Tm\") == 0)\n        {\n            dCurPosY = stack.top().GetReal();\n            stack.pop();\n            dCurPosX = stack.top().GetReal(); \n            stack.pop();\n        }\n        else if( strcmp( pszToken, \"BT\" ) == 0 ) \n        {\n            bTextBlock   = true;     \n            // BT does not reset font\n            // dCurFontSize = 0.0;\n            // pCurFont     = NULL;\n        }\n        else if( strcmp( pszToken, \"ET\" ) == 0 ) \n        {\n            if( !bTextBlock ) \n                fprintf( stderr, \"WARNING: Found ET without BT!\\n\" );\n        }\n\n        if( bTextBlock ) \n        {\n            if( strcmp( pszToken, \"Tf\" ) == 0 ) \n            {\n                dCurFontSize = stack.top().GetReal();\n                stack.pop();\n                PdfName fontName = stack.top().GetName();\n                PdfObject* pFont = pPage-&gt;GetFromResources( PdfName(\"Font\"), fontName );\n                if( !pFont ) \n                {\n                    PODOFO_RAISE_ERROR_INFO( ePdfError_InvalidHandle, \"Cannot create font!\" );\n                }\n\n                pCurFont = pDocument-&gt;GetFont( pFont );\n                if( !pCurFont ) \n                {\n                    fprintf( stderr, \"WARNING: Unable to create font for object %i %i R\\n\",\n                        pFont-&gt;Reference().ObjectNumber(),\n                        pFont-&gt;Reference().GenerationNumber() );\n                }\n            }\n            else if( strcmp( pszToken, \"Tj\" ) == 0 ||\n                strcmp( pszToken, \"'\" ) == 0 ) \n            {\n                AddTextElement( dCurPosX, dCurPosY, pCurFont, stack.top().GetString() );\n                stack.pop();\n            }\n            else if( strcmp( pszToken, \"\\\"\" ) == 0 )\n            {\n                AddTextElement( dCurPosX, dCurPosY, pCurFont, stack.top().GetString() );\n                stack.pop();\n                stack.pop(); // remove char spacing from stack\n                stack.pop(); // remove word spacing from stack\n            }\n            else if( strcmp( pszToken, \"TJ\" ) == 0 ) \n            {\n                PdfArray array = stack.top().GetArray();\n                stack.pop();\n\n                for( int i=0; i&lt;static_cast&lt;int&gt;(array.GetSize()); i++ ) \n                {\n                    _RPT1(_CRT_WARN, \" variant: %s\", array[i].GetDataTypeString());\n                    if(array[i].IsHexString()) {\n                        if(!pCurFont) {\n                            _RPT1(_CRT_WARN, \" : Could not Get font!!%d\\n\", i);\n                        }\n                        else {\n                            if(!pCurFont-&gt;GetEncoding()) {\n                                _RPT1(_CRT_WARN, \": could not get encoding\\n\",0);\n                            } else {\n                                PdfString s = array[i].GetString();\n                                _RPT1(_CRT_WARN, \" : valid :%s   \", s.IsValid()?\"yes\":\"not\");\n                                _RPT1(_CRT_WARN, \" ;hex :%s   \", s.IsHex()?\"yes\":\"not\");\n                                _RPT1(_CRT_WARN, \" ;unicode: %s   \", s.IsUnicode()?\"yes\":\"not\");\n\n                                PdfString unicode = pCurFont-&gt;GetEncoding()-&gt;ConvertToUnicode(s,pCurFont);\n                                const char* szText = unicode.GetStringUtf8().c_str();\n                                _RPT1(_CRT_WARN, \" : %s\\n\", strlen(szText)&gt; 0? szText: \"nothing\");\n\n                            }\n\n                        }\n                    }\n                    else if(array[i].IsNumber()) {\n                        _RPT1(_CRT_WARN, \" : %d\\n\", array[i].GetNumber());\n                    }\n\n                    if( array[i].IsString() )//|| array[i].IsHexString())\n                        AddTextElement( dCurPosX, dCurPosY, pCurFont, array[i].GetString() );\n                }\n            }\n        }\n    }\n    else if ( eType == ePdfContentsType_Variant )\n    {\n        stack.push( var );\n\n        _RPT1(_CRT_WARN, \" variant: %s\\n\", var.GetDataTypeString());\n    }\n    else\n    {\n        // Impossible; type must be keyword or variant\n        PODOFO_RAISE_ERROR( ePdfError_InternalLogic );\n    }\n}\n</code></pre>\n<p>and for the code I get this output:</p>\n<pre><code>    BT\n variant: Name\n variant: Real\n Tf\n variant: Number\n variant: Number\n variant: Number\n rg\n variant: Real\n variant: Number\n variant: Number\n variant: Number\n variant: Real\n variant: Real\n Tm\n variant: Array\n TJ\n variant: HexString : valid :yes    ;hex :yes    ;unicode: not    : nothing\n variant: Number : -7\n variant: HexString : valid :yes    ;hex :yes    ;unicode: not    : nothing\n variant: Number : -15\n variant: HexString : valid :yes    ;hex :yes    ;unicode: not    : nothing\n variant: Number : -15\n variant: HexString : valid :yes    ;hex :yes    ;unicode: not    : nothing\n variant: Number : -11\n variant: HexString : valid :yes    ;hex :yes    ;unicode: not    : nothing\n variant: Number : -11\n variant: HexString : valid :yes    ;hex :yes    ;unicode: not    : nothing\n variant: Number : -19\n variant: HexString : valid :yes    ;hex :yes    ;unicode: not    : nothing\n variant: Number : -11\n variant: HexString : valid :yes    ;hex :yes    ;unicode: not    : nothing\n variant: Number : -15\n variant: HexString : valid :yes    ;hex :yes    ;unicode: not    : nothing\n variant: Number : -11\n variant: HexString : valid :yes    ;hex :yes    ;unicode: not    : nothing\n ET\n</code></pre>\n<p>The PDF stream object would like this (I'm sorry but I m not allowed to give you the pdf file):</p>\n<pre><code>    q\nQ\nq\nQ\nq\nq\nq\n1 0 0 1 37.68 785.28 cm\n91.92 0 0 31.44 0 0 cm\n/Img1 Do\nQ\nQ\nq\nq\n1 0 0 1 431.28 780.24 cm\n42.72 0 0 7.2 0 0 cm\n/Img2 Do\nQ\nQ\nq\nBT\n/F1 8.88 Tf\n0 0 0 rg\n0.9998 0 0 1 377.28 704.4 Tm\n[&lt;0026&gt;-7&lt;004F&gt;-15&lt;004C&gt;-15&lt;0048&gt;-11&lt;0051&gt;-11&lt;0057&gt;-19&lt;0058&gt;-11&lt;004F&gt;-15&lt;0058&gt;-11&lt;004C&gt;] TJ\nET\nQ\nq\n1 0 0 1 0 0 cm\n0.4799 w\n0 0 0 RG\n377.28 703.44 m\n415.2 703.44 l\nS\nQ\nq\nBT\n/F1 8.16 Tf\n0 0 0 rg\n0.9998 0 0 1 377.28 687.36 Tm\n[&lt;0030&gt;9&lt;0027&gt;-13&lt;002C&gt;-16&lt;0003&gt;1&lt;0026&gt;-13&lt;0032&gt;13&lt;0031&gt;-13&lt;0036&gt;-9&lt;0037&gt;-6&lt;0035&gt;-13&lt;0038&gt;-13&lt;0026&gt;-13&lt;0037&gt;-6&lt;0003&gt;1&lt;0037&gt;-6&lt;0035&gt;-13&lt;0024&gt;-9&lt;0031&gt;-13&lt;0036&gt;-9&lt;0003&gt;1&lt;0028&gt;-9&lt;003B&gt;-9&lt;0033&gt;-9&lt;0028&gt;-9&lt;0035&gt;-13&lt;0037&gt;-6&lt;0003&gt;1&lt;0036&gt;-9&lt;0035&gt;-13&lt;002F&gt;] TJ\nET\n</code></pre>\n<p>The PDF file should be found <a href=\"http://www.filedropper.com/document2\" rel=\"nofollow\">here</a> or <a href=\"http://www.fileswap.com/dl/iEsq7fojFn/\" rel=\"nofollow\">here</a></p>\n", "Tags": "<c++><c><pdf><podofo>", "LastEditDate": "2013-12-17T22:14:03.830", "LastActivityDate": "2013-12-17T22:14:03.830", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "1083913"}});