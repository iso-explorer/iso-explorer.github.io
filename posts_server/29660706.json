post_cb({"bq_ids": {"n4140": {"so_29660706_29660804_0": {"length": 7, "quality": 1.0, "section_id": 5404}}, "n3337": {"so_29660706_29660804_0": {"length": 7, "quality": 1.0, "section_id": 5199}}, "n4659": {"so_29660706_29660804_0": {"length": 7, "quality": 1.0, "section_id": 6853}}}, "29660804": {"Id": "29660804", "PostTypeId": "2", "Body": "<p>If you want to declare the member functions of <code>AccountRepository</code> as <code>inline</code>, you have to make them known in all translation units that use them, as per [basic.def.odr]/3:</p>\n<blockquote>\n<p id=\"so_29660706_29660804_0\">(...) An inline function shall be defined in every translation unit in which it is odr-used.</p>\n</blockquote>\n<p>Either remove the <code>inline</code> from the function definitions or move them all to the header.</p>\n", "LastActivityDate": "2015-04-15T20:59:35.627", "Score": "0", "CreationDate": "2015-04-15T20:59:35.627", "ParentId": "29660706", "CommentCount": "0", "OwnerUserId": "4301306"}, "29660820": {"Id": "29660820", "PostTypeId": "2", "Body": "<p>You're misusing the <code>inline</code> keyword.  Treat it as if it means \"the implementation for this function is in the header\".  </p>\n<p>This immediately reveals the problem: You have a lot of <code>inline</code> functions in one of your cpp files, which is not a header.  Each cpp file that uses an <code>inline</code> function is <em>required</em> to either contain or include a definition of that function.  The problem is that the linkers do magic things with <code>inline</code> functions because they're supposed to be one copy in each of many cpp files.  So the compiler compiles <code>main.cpp</code>, and (since main doesn't know the function is inlined, notes that later the linker should link in the default constructor).  The compiler then compiles <code>AccountReposity.cpp</code>, sees that an inline function is not used, and so just skips it. Later then the linker has trouble finding a copy of <code>AccountRepository()</code> to use, and it reports an error. If the function body was defined in the header properly, it would have been instantiated into <code>main.cpp</code> during the compilation step, before it gets to the linking stage.</p>\n<p>The fact that <em>some</em> compilers treat <code>inline</code> functions special doesn't really affect the rule-of-thumb at all.  Other compilers don't give <code>inline</code> functions any special optimization, and thinking of it as an optimization causes the error you encountered.  Ignoring the optimization makes it clearer where the keyword goes.</p>\n", "LastEditorUserId": "845092", "LastActivityDate": "2015-04-15T21:36:04.357", "Score": "2", "CreationDate": "2015-04-15T21:00:23.883", "ParentId": "29660706", "CommentCount": "4", "LastEditDate": "2015-04-15T21:36:04.357", "OwnerUserId": "845092"}, "29660706": {"ViewCount": "66", "Body": "<p>I'm trying to write something like a C# interface in C++ with a generic object but i can't get it work.\nevery time i create a new instance in the main i get the following error:\nError   1   error LNK2019: unresolved external symbol \"public: __thiscall AccountRepository::AccountRepository(void)\"</p>\n<p><em>main.cpp</em></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n#include \"AccountRepository.h\"\n\nusing namespace std;\n\nint main(){\n\n    AccountRepository repo;\n\n    return 0;\n}\n</code></pre>\n<p><em>IRepository.h</em></p>\n<pre><code>#pragma once\n#include &lt;vector&gt;\nusing namespace std;\n\ntemplate &lt;class Entity&gt;\nclass IRepository\n{\npublic:\n    virtual bool add(Entity entity) = 0;\n    virtual bool update(Entity entity) = 0;\n    virtual Entity getById(int Id) = 0;\n    virtual bool remove(Entity entity) = 0;\n    virtual vector&lt;Entity&gt; getAll() = 0;\n};\n</code></pre>\n<p><em>AccountRepository.h</em></p>\n<pre><code>#pragma once\n#include \"IRepository.h\"\n#include \"Account.h\"\n#include &lt;vector&gt;\n\nclass AccountRepository : public IRepository&lt;Account&gt;{\nprivate:\n    vector&lt;Account&gt; _accounts;\n\npublic:\n    AccountRepository();\n    ~AccountRepository();\n\n    virtual bool add(Account entity) override;\n    virtual bool update(Account entity) override;\n    virtual Account getById(int Id) override;\n    virtual bool remove(Account entity) override;\n    virtual vector&lt;Account&gt; getAll() override;\n\n};\n</code></pre>\n<p><em>AccountReposity.cpp</em></p>\n<pre><code>#include \"AccountRepository.h\"\n\ninline AccountRepository::AccountRepository()\n{\n\n}\n\ninline AccountRepository::~AccountRepository()\n{\n\n}\n\ninline bool AccountRepository::add(Account entity)\n{\n    _accounts.push_back(entity);\n    return true;\n}\n\ninline bool AccountRepository::update(Account entity)\n{\n    for (Account account : _accounts){\n        if (account.getId() == entity.getId()){\n            account.setName(entity.getName());\n            account.setDescription(entity.getDescription());\n            return true;\n        }\n    }\n\n    return false;\n}\n\ninline Account AccountRepository::getById(int Id)\n{\n    for (Account account: _accounts)\n    {\n        if (account.getId() == Id)\n            return account;\n    }\n}\n\ninline bool AccountRepository::remove(Account entity)\n{\n    vector&lt;Account&gt;::iterator it;\n    for (it = _accounts.begin(); it != _accounts.end(); ++it){\n        if (it-&gt;getId() == entity.getId())\n        {\n            _accounts.erase(it);\n            return true;\n        }\n    }\n\n    return false;\n}\n\ninline vector&lt;Account&gt; AccountRepository::getAll()\n{\n    return _accounts;\n}\n</code></pre>\n", "Title": "Can't get this class with template to work?", "CreationDate": "2015-04-15T20:54:10.110", "LastActivityDate": "2015-04-15T21:36:04.357", "CommentCount": "2", "PostTypeId": "1", "Id": "29660706", "Score": "2", "OwnerUserId": "4143938", "Tags": "<c++>", "AnswerCount": "2"}});