post_cb({"7721197": {"Id": "7721197", "PostTypeId": "2", "Body": "<p>sizeof(*ptr) is the same as sizeof(int) in this case.</p>\n", "LastActivityDate": "2011-10-11T03:50:57.623", "CommentCount": "2", "CreationDate": "2011-10-11T03:50:57.623", "ParentId": "7721184", "Score": "3", "OwnerUserId": "450708"}, "7721284": {"Id": "7721284", "PostTypeId": "2", "Body": "<p>In most cases (in C at least), you will find that <code>sizeof(*x)</code> does not actually evaluate <code>*x</code> at all. The C99 standard has this to say in <code>6.5.3.4 The sizeof operator</code>, part <code>/2</code> (my bolding):</p>\n<blockquote>\n<p id=\"so_7721184_7721284_0\">The sizeof operator yields the size (in bytes) of its operand, which may be an expression or the parenthesized name of a type. The size is determined from the <strong>type</strong> of the operand. The result is an integer. If the type of the operand is a variable length array type, the operand is evaluated; otherwise, <strong>the operand is not evaluated</strong> and the result is an integer constant.</p>\n</blockquote>\n<p>So, for all non-VLAs, no dereferencing takes place. If the type of <code>*x</code> <em>is</em> a VLA, that's considered an execution-phase <code>sizeof</code>, something that needs to be worked out while the code is running - all others can be calculated at compile time.</p>\n<p>C++ has slightly different rules, as shown in <code>5.3.3. Sizeof</code>, part <code>/1</code>:</p>\n<blockquote>\n<p id=\"so_7721184_7721284_1\">The sizeof operator yields the number of bytes in the object representation of its operand. The operand is either an expression, which is an unevaluated operand (Clause 5), or a parenthesized type-id.</p>\n</blockquote>\n<p><code>5. Expressions</code> defines the term \"unevaluated operand\" in part <code>/8</code>:</p>\n<blockquote>\n<p id=\"so_7721184_7721284_2\">In some contexts, unevaluated operands appear. An unevaluated operand is not evaluated.</p>\n</blockquote>\n<p>(perhaps one of the most useless, redundant phrases I've read for a while, but I don't know what was going through the mind of the ISO people when they wrote it).</p>\n", "LastEditorUserId": "14860", "LastActivityDate": "2013-06-14T01:47:04.137", "Score": "19", "CreationDate": "2011-10-11T04:08:34.110", "ParentId": "7721184", "CommentCount": "2", "OwnerUserId": "14860", "LastEditDate": "2013-06-14T01:47:04.137"}, "7721204": {"Id": "7721204", "PostTypeId": "2", "Body": "<p><code>sizeof</code> and <code>decltype</code> do not evaluate their operands, computing types only.</p>\n", "LastActivityDate": "2011-10-11T03:52:38.040", "CommentCount": "0", "CreationDate": "2011-10-11T03:52:38.040", "ParentId": "7721184", "Score": "3", "OwnerUserId": "246886"}, "bq_ids": {"n4140": {"so_7721184_7721284_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 6076}, "so_7721184_7721284_2": {"length": 6, "quality": 0.75, "section_id": 5941}}, "n3337": {"so_7721184_7721284_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 5844}, "so_7721184_7721284_2": {"length": 6, "quality": 0.75, "section_id": 5712}}, "n4659": {"so_7721184_7721284_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 7572}, "so_7721184_7721284_2": {"length": 6, "quality": 0.75, "section_id": 7425}}}, "7721189": {"Id": "7721189", "PostTypeId": "2", "Body": "<p>No. <code>sizeof</code> is an operator, and works on types, not the actual value (which is not evaluated).</p>\n<p>To remind you that it's an operator, I suggest you get in the habit of omitting the brackets where practical.</p>\n<pre><code>int* ptr = 0;\nsize_t size = sizeof *ptr;\nsize = sizeof (int);   /* brackets still required when naming a type */\n</code></pre>\n", "LastActivityDate": "2011-10-11T03:50:28.953", "CommentCount": "4", "CreationDate": "2011-10-11T03:50:28.953", "ParentId": "7721184", "Score": "10", "OwnerUserId": "13"}, "7721234": {"Id": "7721234", "PostTypeId": "2", "Body": "<p>The answer may well be different for C, where <code>sizeof</code> is not necessarily a compile-time construct, but in C++ the expression provided to <code>sizeof</code> is never evaluated.  As such, there is never a possibility for undefined behavior to exhibit itself.  By similar logic, you can also \"call\" functions that are never defined [because the function is never actually called, no definition is necessary], a fact that is frequently used in SFINAE rules.</p>\n", "LastActivityDate": "2011-10-11T03:58:15.190", "CommentCount": "0", "CreationDate": "2011-10-11T03:58:15.190", "ParentId": "7721184", "Score": "4", "OwnerUserId": "293791"}, "7721184": {"ViewCount": "894", "Body": "<p>We all know that dereferencing an null pointer or a pointer to unallocated memory invokes undefined behaviour.</p>\n<p>But what's the rule when used within an expression passed to sizeof?</p>\n<p>For example:</p>\n<pre><code>int* ptr = 0;\nint size = sizeof(*ptr);\n</code></pre>\n<p>Is this also undefined?</p>\n", "AcceptedAnswerId": "7721284", "Title": "Is sizeof(*ptr) undefined behavior when pointing to invalid memory?", "CreationDate": "2011-10-11T03:48:36.113", "Id": "7721184", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-01-16T19:32:33.883", "LastEditorDisplayName": "user166390", "LastActivityDate": "2013-06-14T01:47:04.137", "Score": "11", "OwnerUserId": "366817", "Tags": "<c++><c>", "AnswerCount": "5"}});