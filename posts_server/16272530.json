post_cb({"16272588": {"ParentId": "16272530", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>It <em>can</em> be undefined behaviour depending on whether or not destructors would be called were an exception to execute the same transfer of control. In C++03. From section <code>18.7 Other runtime support</code>, <code>paragraph 4</code>:</p>\n<blockquote>\n<p id=\"so_16272530_16272588_0\">The function signature <code>longjmp(jmp_buf jbuf, int val)</code> has more restricted behavior in this International Standard. If any automatic objects would be destroyed by a thrown exception transferring control to another (destination) point in the program, then a call to <code>longjmp(jbuf, val)</code> at the throw point that transfers control to the same (destination) point has undefined behavior.</p>\n</blockquote>\n<p>There's similar language in c++11:</p>\n<blockquote>\n<p id=\"so_16272530_16272588_1\">The function signature <code>longjmp(jmp_buf jbuf, int val)</code> has more restricted behavior in this International Standard. A <code>setjmp/longjmp</code> call pair has undefined behavior if replacing the <code>setjmp</code> and <code>longjmp</code> by <code>catch</code> and <code>throw</code> would invoke any non-trivial destructors for any automatic objects.</p>\n</blockquote>\n<p>However, there appear to be no destructors that are called in transition for this <em>particular</em> piece of code, so I believe it's safe.</p>\n<hr>\n<p>Now, if you were to change the code to move the creation to <em>after</em> the <code>setjmp</code>, that becomes undefined behaviour. In my setup (gcc 4.4.5 under Debian), the following code (with everything else identical to your question):</p>\n<pre><code>int main() {\n    int count = setjmp (jump_buffer);\n    A obj;\n    if (count != 4) a (count);\n}\n</code></pre>\n<p>results in the output:</p>\n<pre><code>A()\na(0) called\nA()\na(1) called\nA()\na(2) called\nA()\na(3) called\nA()\n~A()\n</code></pre>\n<p>and you can see the destructor is <em>not</em> being called as part of the jump although, being undefined, it may be on some systems.</p>\n<hr>\n<p>The bottom line is, you shouldn't be jumping from region A to region B where the equivalent <code>throw/catch</code> would properly destruct an object, because there's no guarantee the <code>longjmp</code> will call the destructor.</p>\n<p>Actually, there are some who would say you shouldn't use <code>setjmp/longjmp</code> in C++ <em>at all,</em> and I tend to lean that way myself. I have a hard time seeing a need for that even in C. </p>\n<p>I think I used it <em>once</em> in my entire career (and that's a <em>long</em> career), to implement co-operative threading in Turbo C under MS-DOS. I can't think of one other time I've ever used it. Not to say there <em>aren't</em> any uses, but they'd be pretty rare.</p>\n</hr></hr>", "OwnerUserId": "14860", "LastEditorUserId": "14860", "LastEditDate": "2013-04-29T07:49:06.423", "Id": "16272588", "Score": "7", "CreationDate": "2013-04-29T06:37:30.403", "LastActivityDate": "2013-04-29T07:49:06.423"}, "bq_ids": {"n4140": {"so_16272530_16272588_1": {"section_id": 6967, "quality": 0.9285714285714286, "length": 26}}, "n3337": {"so_16272530_16272588_1": {"section_id": 6714, "quality": 0.9285714285714286, "length": 26}}, "n4659": {"so_16272530_16272588_1": {"section_id": 8467, "quality": 0.9285714285714286, "length": 26}}}, "16272530": {"CommentCount": "0", "ViewCount": "240", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-04-29T06:33:28.233", "LastActivityDate": "2013-04-29T07:49:06.423", "Title": "Are objects created before setjmp destructed?", "AcceptedAnswerId": "16272588", "LastEditDate": "2017-05-23T12:28:09.600", "Id": "16272530", "Score": "3", "Body": "<p>In <a href=\"http://libjpeg.sourceforge.net/\" rel=\"nofollow noreferrer\">jpeglib</a>, one has to use setjmp/longjmp to implement custom error handling. </p>\n<p>There are lots of resources where it is said that setjmp/longjmp do not play well with c++ (for example answers in <a href=\"https://stackoverflow.com/q/1376085/476681\">this question</a> tell they do go along with RAII), but the answers to <a href=\"https://stackoverflow.com/q/7262818/476681\">this question</a> say that the destructor is called.</p>\n<p>I have this example (taken from <a href=\"http://en.cppreference.com/w/cpp/utility/program/longjmp\" rel=\"nofollow noreferrer\">here</a> and modified a bit):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;csetjmp&gt;\n\nstd::jmp_buf jump_buffer;\n\nstruct A\n{\n    A(){std::cout&lt;&lt;\"A()\"&lt;&lt;std::endl;}\n    ~A(){std::cout&lt;&lt;\"~A()\"&lt;&lt;std::endl;}\n};\n\nvoid a(int count) \n{\n    std::cout &lt;&lt; \"a(\" &lt;&lt; count &lt;&lt; \") called\\n\";\n    std::longjmp(jump_buffer, count+1);  // setjump() will return count+1\n}\n\nint main()\n{\n    // is this object safely destroyed?\n    A obj;\n\n    int count = setjmp(jump_buffer);\n    if (count != 9) {\n        a(count);\n    }\n}\n</code></pre>\n<p>In this example, the destructor is called (as I expected), but is it the standard behaviour? Or is it compiler's extension, or simple UB?</p>\n<hr>\n<p>The output:</p>\n<pre><code>A()\na(0) called\na(1) called\na(2) called\na(3) called\na(4) called\na(5) called\na(6) called\na(7) called\na(8) called\n~A()\n</code></pre>\n</hr>", "Tags": "<c++><c++11><language-lawyer><longjmp>", "OwnerUserId": "476681", "AnswerCount": "1"}});