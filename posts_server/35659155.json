post_cb({"35659155": {"CommentCount": "4", "AcceptedAnswerId": "35659573", "PostTypeId": "1", "LastEditorUserId": "598696", "CreationDate": "2016-02-26T18:31:38.780", "LastActivityDate": "2016-02-26T18:56:52.540", "LastEditDate": "2016-02-26T18:45:54.363", "ViewCount": "191", "FavoriteCount": "2", "Title": "Using a lambda in a `constexpr` function in a non-`constexpr` context: clang vs gcc", "Id": "35659155", "Score": "5", "Body": "<p>Consider the following code <em>(<a href=\"https://goo.gl/a7ZZ8Z\" rel=\"nofollow\">available on gcc.godbolt.org</a>)</em>:</p>\n<pre><code>template &lt;typename TF&gt;\nconstexpr auto fn_x(TF f)\n{\n    return f();\n}\n\nconstexpr auto get_x()\n{\n    return fn_x([]{ return 0; });\n}\n\nint main()\n{\n    auto res = get_x();\n}\n</code></pre>\n<p>It compiles under <strong>g++ 5.3.x</strong> and newer <em>(including <strong>g++ 6.x.x</strong>)</em>.</p>\n<p>It does not compile under <strong>clang++ 3.7.x</strong> and newer with the following error:</p>\n<pre><code>error: constexpr function never produces a constant expression [-Winvalid-constexpr]\nconstexpr auto get_x()\n               ^\nnote: subexpression not valid in a constant expression\n        return fn_x([]{ return 0; });                        \n</code></pre>\n<p>A possible solution to make the code compile with both gcc and clang is using a \"layer of indirection\" with <code>decltype</code>, also getting rid of the <code>constexpr</code> in the function where the lambda is defined: <a href=\"https://goo.gl/ecE1Km\" rel=\"nofollow\">gcc.godbolt.org link</a>.</p>\n<p><strong>Which compiler is correct here according to the standard?</strong> </p>\n", "Tags": "<c++><lambda><language-lawyer><c++14><constexpr>", "OwnerUserId": "598696", "AnswerCount": "1"}, "35659573": {"ParentId": "35659155", "CommentCount": "2", "Body": "<p>Both of the compilers are in agreement that <code>get_x()</code> can't be used in a constant expression. You can tell by changing <code>auto res = get_x();</code> to <code>constexpr auto res = get_x();</code>, where GCC will reject it equally.</p>\n<p>As for detecting it at function definition time like clang does rather than at function use like gcc does, both are allowed: (emphasis mine)</p>\n<blockquote>\n<p id=\"so_35659155_35659573_0\"><strong>7.1.5 The constexpr specifier [dcl.constexpr]</strong></p>\n<p id=\"so_35659155_35659573_1\">5 For a non-template, non-defaulted <code>constexpr</code> function or a non-template, non-defaulted, non-inheriting <code>constexpr</code> constructor, if no argument values exist such that an invocation of the function or constructor could be an evaluated subexpression of a core constant expression (5.19), the program is <strong><em>ill-formed; no diagnostic required</em></strong>. [...]</p>\n</blockquote>\n<p>It is impossible in the general case to reliably detect whether a function invocation exists that allows the result to be used in a constant expression, which is why the diagnostic is optional.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "35659573", "Score": "6", "CreationDate": "2016-02-26T18:56:38.180", "LastActivityDate": "2016-02-26T18:56:38.180"}, "bq_ids": {"n4140": {"so_35659155_35659573_1": {"section_id": 5421, "quality": 0.9259259259259259, "length": 25}}, "n3337": {"so_35659155_35659573_1": {"section_id": 5216, "quality": 0.5925925925925926, "length": 16}}, "n4659": {"so_35659155_35659573_1": {"section_id": 6843, "quality": 0.7407407407407407, "length": 20}}}});