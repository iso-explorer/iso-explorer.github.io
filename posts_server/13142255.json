post_cb({"13142514": {"Id": "13142514", "PostTypeId": "2", "Body": "<p>Your question and other answers have all repeated the difference; that <code>wait_for</code> waits for a specified amount of time and <code>wait_until</code> waits until a specified point in time, but the implications are not spelled out.</p>\n<p>A <code>time_point</code> has an associated clock, and that clock is what's used to determine if the appropriate time has come. That means that clock adjustments are taken into account by the <code>wait_until</code> function. <code>wait_until(..., system_clock::now() + std::chrono::seconds(10))</code> could end up waiting an hour and 10 seconds if the clock happens to be adjusted back by an hour before the wait is up.</p>\n<p>A duration does not have any associated clock and therefore <code>wait_for</code> chooses its own clock. The standard specifies that it uses std::steady_clock, which cannot be adjusted and advances at a steady rate relative to real time. This means that <code>wait_for</code> will wait for the specified time regardless of any adjustments made to any clocks. <code>wait_for(..., std::chrono::seconds(10))</code> is guaranteed to wait 10 seconds (+ some time for the implementation to work and for scheduling issues).</p>\n<p>There is no difference with regard to spinning vs. sleeping the thread; as <code>wait_for</code> is specified to behave as if it called <code>wait_until</code> with <code>steady_clock::now() + duration</code>.</p>\n<hr>\n<p>Here's the part of the standard where this is spelled out:</p>\n<h3>[thread.req.timing] 30.2.4/2-4</h3>\n<blockquote>\n<p id=\"so_13142255_13142514_0\"><sup>2</sup> Implementations necessarily have some delay in returning\n  from a timeout. Any overhead in interrupt response, function return,\n  and scheduling induces a \u201cquality of implementation\u201d delay, expressed\n  as duration <em>D</em><sub>i</sub>. Ideally, this delay would be zero.\n  Further, any contention for processor and memory resources induces a\n  \u201cquality of management\u201d delay, expressed as duration <em>D</em><sub>m</sub>.\n  The delay durations may vary from timeout to timeout, but in all cases\n  shorter is better.</p>\n<p id=\"so_13142255_13142514_1\"><sup>3</sup> The member functions whose names end in <code>_for</code> take an\n  argument that specifies a duration. These functions produce relative\n  timeouts. Implementations should use a steady clock to measure time\n  for these functions. Given a duration argument <em>D</em><sub>t</sub>, the\n  real-time duration of the timeout is <em>D</em><sub>t</sub>\u00a0+\u00a0<em>D</em><sub>i</sub>\u00a0+\u00a0<em>D</em><sub>m</sub>.</p>\n<p id=\"so_13142255_13142514_2\"><sup>4</sup> The member functions whose names end in <code>_until</code> take an\n  argument that specifies a time point. These functions produce absolute\n  timeouts. Implementations should use the clock specified in the time\n  point to measure time for these functions. Given a clock time point\n  argument <em>C</em><sub>t</sub>, the clock time point of the return from timeout should be\n  <em>C</em><sub>t</sub> + <em>D</em><sub>i</sub> +  <em>D</em><sub>m</sub> when the clock is not adjusted during the timeout. If the\n  clock is adjusted to the time <em>C</em><sub>a</sub> during the timeout, the behavior\n  should be as follows:<br/>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u2014 if <em>C</em><sub>a</sub> &gt; <em>C</em><sub>t</sub>, the waiting function should wake\n  as soon as possible, i.e. <em>C</em><sub>a</sub> + <em>D</em><sub>i</sub> + <em>D</em><sub>m</sub>, since the timeout is already\n  satisfied. [ <em>Note:</em> This specification may result in the total duration\n  of the wait decreasing when measured against a steady clock. <em>\u2014end note</em>\n  ]<br/><br/>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2014 if <em>C</em><sub>a</sub> &lt;= <em>C</em><sub>t</sub>, the waiting function should not time out until\n  <code>Clock::now()</code> returns a time <em>C</em><sub>n</sub> &gt;= <em>C</em><sub>t</sub>, i.e. waking at <em>C</em><sub>t</sub> + <em>D</em><sub>i</sub> + <em>D</em><sub>m</sub>. [\n  <em>Note:</em> When the clock is adjusted backwards, this specification may\n  result in the total duration of the wait increasing when measured\n  against a steady clock. When the clock is adjusted forwards, this\n  specification may result in the total duration of the wait decreasing\n  when measured against a steady clock. <em>\u2014end note</em> ]<br/><br/>An implementation\n  shall return from such a timeout at any point from the time specified\n  above to the time it would return from a steady-clock relative timeout\n  on the difference between <em>C</em><sub>t</sub> and the time point of the call to the\n  <code>_until</code> function. [ <em>Note:</em> Implementations should decrease the duration of the wait when the clock is adjusted forwards. <em>\u2014end note</em> ]</p>\n</blockquote>\n</hr>", "LastEditorUserId": "365496", "LastActivityDate": "2013-08-13T16:04:42.500", "Score": "24", "CreationDate": "2012-10-30T15:36:46.197", "ParentId": "13142255", "CommentCount": "1", "OwnerUserId": "365496", "LastEditDate": "2013-08-13T16:04:42.500"}, "46382993": {"Id": "46382993", "PostTypeId": "2", "Body": "<p>Here is one important difference in their usage as explained in Anthony Williams's <a href=\"https://rads.stackoverflow.com/amzn/click/1933988770\" rel=\"nofollow noreferrer\">book</a>:</p>\n<p>Consider this example where a condition variable is waited with a timeout:</p>\n<pre><code>std::condition_variable cv;\nbool done;\nstd::mutex m;\n\nbool wait_loop()\n{\n    auto const timeout= std::chrono::steady_clock::now()+\n    std::chrono::milliseconds(500);\n    std::unique_lock&lt;std::mutex&gt; lk(m);\n    while(!done)\n    {\n       if(cv.wait_until(lk,timeout)==std::cv_status::timeout)\n          break;\n    }\n    return done;\n}\n</code></pre>\n<blockquote>\n<p id=\"so_13142255_46382993_0\">This is the recommended way to wait for condition variables with a\n  time limit, if you\u2019re not passing a predicate to the wait. This way,\n  the overall length of the loop is <strong>bounded</strong>. As you saw in section\n  4.1.1, you need to loop when using condition variables if you don\u2019t pass in the predicate, in order to handle spurious wakeups. If you use\n  <code>wait_for()</code> in a loop, you might end up waiting almost the full length\n  of time before a spurious wake, and the next time through the wait\n  time starts again. This may repeat any number of times, making the\n  total wait time <strong>unbounded</strong>.</p>\n</blockquote>\n<p>IMO, this is one such scenario where <code>wait_for</code> can't replace <code>wait_until</code> so easily, because of its resetting nature.</p>\n", "LastEditorUserId": "1465553", "LastActivityDate": "2017-09-23T18:40:43.727", "Score": "1", "CreationDate": "2017-09-23T18:32:35.220", "ParentId": "13142255", "CommentCount": "0", "OwnerUserId": "1465553", "LastEditDate": "2017-09-23T18:40:43.727"}, "bq_ids": {"n4140": {"so_13142255_13142514_0": {"length": 45, "quality": 0.9574468085106383, "section_id": 2663}, "so_13142255_13142514_2": {"length": 137, "quality": 0.9194630872483222, "section_id": 2665}, "so_13142255_13142514_1": {"length": 27, "quality": 0.9310344827586207, "section_id": 2664}}, "n3337": {"so_13142255_13142514_0": {"length": 45, "quality": 0.9574468085106383, "section_id": 2627}, "so_13142255_13142514_2": {"length": 137, "quality": 0.9194630872483222, "section_id": 2629}, "so_13142255_13142514_1": {"length": 27, "quality": 0.9310344827586207, "section_id": 2628}}, "n4659": {"so_13142255_13142514_0": {"length": 45, "quality": 0.9574468085106383, "section_id": 3403}, "so_13142255_13142514_2": {"length": 137, "quality": 0.9194630872483222, "section_id": 3405}, "so_13142255_13142514_1": {"length": 27, "quality": 0.9310344827586207, "section_id": 3404}}}, "13142324": {"Id": "13142324", "PostTypeId": "2", "Body": "<p>The difference is in how the wait duration is represented: <code>wait_for</code> takes a relative time (\"wait for up to 10 seconds\"), whereas <code>wait_until</code> takes an absolute time (\"wait until 12:00 on October 30, 2012\").</p>\n<p>Compare the declarations of the time parameters:</p>\n<pre><code>// wait_for:\nconst std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time\n\n// wait_until:\nconst std::chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time\n</code></pre>\n", "LastActivityDate": "2012-10-30T15:28:07.733", "CommentCount": "1", "CreationDate": "2012-10-30T15:28:07.733", "ParentId": "13142255", "Score": "31", "OwnerUserId": "9530"}, "13142321": {"Id": "13142321", "PostTypeId": "2", "Body": "<ul>\n<li><code>wait_for</code> will wait for a certain amount of time. It will for example wait for two seconds.</li>\n<li><code>wait_until</code> will wait until some time is reached. It will for example wait until 23rd of July 2013 11:22:34 p.m. is reached on the clock.</li>\n</ul>\n", "LastEditorUserId": "1173513", "LastActivityDate": "2012-10-30T15:29:13.470", "Score": "5", "CreationDate": "2012-10-30T15:28:03.207", "ParentId": "13142255", "CommentCount": "1", "OwnerUserId": "1173513", "LastEditDate": "2012-10-30T15:29:13.470"}, "13142255": {"ViewCount": "3785", "Body": "<p>The <a href=\"http://en.cppreference.com/w/cpp/thread/condition_variable\" rel=\"noreferrer\">reference I'm using</a> explains the two in the following way:</p>\n<ul>\n<li><p><code>wait_for</code> \"blocks the current thread until the condition variable is woken up or after the specified timeout duration\"</p></li>\n<li><p><code>wait_until</code> \"blocks the current thread until the condition variable is woken up or until specified time point has been reached\"</p></li>\n</ul>\n<p>What is the difference? Will <code>wait_until</code> spin so that the thread can continue exactly (more or less) when it is signaled, whereas <code>wait_for</code> just adds the thread back into scheduling at that point?</p>\n", "AcceptedAnswerId": "13142324", "Title": "What is the difference between std::condition_variable::wait_for and std::condition_variable::wait_until?", "CreationDate": "2012-10-30T15:25:00.273", "Id": "13142255", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-09-23T18:40:43.727", "Score": "21", "OwnerUserId": "713961", "Tags": "<c++><multithreading><c++11><condition-variable>", "AnswerCount": "4"}});