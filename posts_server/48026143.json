post_cb({"bq_ids": {"n4140": {"so_48026143_48026940_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 435}, "so_48026143_48026940_3": {"length": 12, "quality": 0.6, "section_id": 5879}, "so_48026143_48026296_1": {"length": 44, "quality": 0.8979591836734694, "section_id": 6046}}, "n3337": {"so_48026143_48026940_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 5913}, "so_48026143_48026296_1": {"length": 40, "quality": 0.8163265306122449, "section_id": 5814}}, "n4659": {"so_48026143_48026940_4": {"length": 6, "quality": 1.0, "section_id": 8733}, "so_48026143_48026940_5": {"length": 28, "quality": 0.9032258064516129, "section_id": 8733}, "so_48026143_48026940_2": {"length": 8, "quality": 0.8888888888888888, "section_id": 8733}, "so_48026143_48026940_3": {"length": 19, "quality": 0.95, "section_id": 8733}, "so_48026143_48026296_1": {"length": 43, "quality": 0.8775510204081632, "section_id": 7545}}}, "48026940": {"Id": "48026940", "PostTypeId": "2", "Body": "<p>Unfortunately this is forbidden by the standard. In the C++ standard <code>reinterpret_cast</code> from one pointer to an object <em>a</em> to another object <em>b</em> of different type is stated to be valid only when the two object are <em>pointer interconvertible</em>, <a href=\"http://eel.is/c++draft/basic.compound#4\" rel=\"nofollow noreferrer\">[basic.compound]/4</a>:</p>\n<blockquote>\n<p id=\"so_48026143_48026940_0\">Two objects a and b are <em>pointer-interconvertible</em> if:</p>\n<ul>\n<li><p id=\"so_48026143_48026940_1\">they are the same object, or</p></li>\n<li><p id=\"so_48026143_48026940_2\">one is a union object and the other is a non-static data member of that object ([class.union]), or</p></li>\n<li><p id=\"so_48026143_48026940_3\">one is a standard-layout class object and the other is the first non-static data member of that object, or, if the object has no non-static data members, the first base class subobject of that object ([class.mem]), or</p></li>\n<li><p id=\"so_48026143_48026940_4\">there exists an object c such that a and c are pointer-interconvertible, and c and b are pointer-interconvertible.</p></li>\n</ul>\n<p id=\"so_48026143_48026940_5\">If two objects are pointer-interconvertible, then they have the same address, and it is possible to obtain a pointer to one from a pointer to the other via a <code>reinterpret_\u00adcast</code>. [\u2009Note: An array object and its first element are not pointer-interconvertible, even though they have the same address. \u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>The fact that a pointer has the right type and right value (memory address) does not make it a valid pointer. The canonical example of such surprising behavior is this:</p>\n<pre><code>alignas(int) unsigned char buff[2*sizeof(int)];\nauto p1 = new(buff) int{};\nauto p2 = new(buff+sizeof(int)) int{};\n*(p1+1) = 10;//Undefined behavior\n//p1+1 does not point to *p2 even if p1 and p2 have same type and value.\n</code></pre>\n<p>So, to be standard compliant, you must store the value of the pointer returned by <code>new</code>. </p>\n<hr>\n<p>I found a good solution that consists to cast the pointer to an integer type and that to an other pointer type, that will cause an <em>implementation defined behavior</em> (<a href=\"http://eel.is/c++draft/expr.reinterpret.cast#5\" rel=\"nofollow noreferrer\">[expr.reinterpret_cast]/5</a>):</p>\n<pre><code>reinterpret_cast&lt;MyStruct*&gt;(reinterpret_cast&lt;std::uintptr_t&gt;(addressof(g_storage));\n</code></pre>\n</hr>", "LastEditorUserId": "5632316", "LastActivityDate": "2018-01-02T17:36:50.140", "Score": "1", "CreationDate": "2017-12-29T18:37:38.683", "ParentId": "48026143", "CommentCount": "3", "OwnerUserId": "5632316", "LastEditDate": "2018-01-02T17:36:50.140"}, "48026143": {"ViewCount": "78", "Body": "<p>I want to construct using placement-new an object of arbitrary type inside a <code>std::aligned_union_t</code>. Once constructed successfully, I want to be able to get back the pointer to the constructed object without storing it separately. Is it legal to do so by simply <code>reinterpret_cast</code>'ing the <code>std::aligned_union_t</code>, as long as I ensure that I cast it to the original type that was constructed?</p>\n<p>Is the following code that exemplifies the above, legal? Are there any type trait requirements that <code>MyStruct</code> should satisfy for it to be so? For instance, does it have to be a POD?</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;memory&gt;\n#include &lt;cstddef&gt;\n#include &lt;exception&gt;\n\nstruct MyStruct\n{\n    int value = 0;\n};\n\nconstexpr size_t c_alignedUnionSize = 10;\nstd::aligned_union_t&lt;c_alignedUnionSize, std::max_align_t&gt; g_storage;\n\nMyStruct* GetPtr()\n{\n    return reinterpret_cast&lt;MyStruct*&gt;(std::addressof(g_storage));\n}\n\nvoid Construct()\n{\n    if (sizeof(MyStruct) &gt; sizeof(g_storage))\n    {\n        std::terminate();\n    }\n\n    auto ptr = new (std::addressof(g_storage)) MyStruct{};\n    if (!ptr)\n    {\n        std::terminate();\n    }\n\n    GetPtr()-&gt;value = 123;\n}\n\nvoid Destroy()\n{\n    GetPtr()-&gt;~MyStruct();\n}\n\nint GetValue()\n{\n    return GetPtr()-&gt;value;\n}\n\nint main()\n{\n    Construct();\n    auto value = GetValue();\n    Destroy();\n    return value;\n}\n</code></pre>\n", "Title": "Getting pointer to contained object from std::aligned_union_t", "CreationDate": "2017-12-29T17:23:56.997", "LastActivityDate": "2018-01-02T17:36:50.140", "CommentCount": "1", "PostTypeId": "1", "Id": "48026143", "Score": "4", "OwnerUserId": "179895", "Tags": "<c++>", "AnswerCount": "2"}, "48026296": {"Id": "48026296", "PostTypeId": "2", "Body": "<p><code>reinterpret_cast</code> here should be safe. The latest Standard draft says:</p>\n<blockquote>\n<p id=\"so_48026143_48026296_0\"><a href=\"http://eel.is/c++draft/expr.reinterpret.cast\" rel=\"nofollow noreferrer\">[expr.reinterpret.cast]</a></p>\n<p id=\"so_48026143_48026296_1\">An object pointer can be explicitly converted to an object pointer of a different type. When a prvalue <code>v</code> of object pointer type is converted to the object pointer type \u201cpointer to cv <code>T</code>\u201d, the result is <code>static_\u00adcast&lt;cv T*&gt;(static_\u00adcast&lt;cv void*&gt;(v))</code>. [\u2009Note: Converting a prvalue of type \u201cpointer to <code>T1</code>\u201d to the type \u201cpointer to <code>T2</code>\u201d (where <code>T1</code> and <code>T2</code> are object types and where the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>) and back to its original type yields the original pointer value. \u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>Related questions:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/13466556/aligned-storage-and-strict-aliasing\">aligned_storage and strict aliasing</a></li>\n</ul>\n", "LastEditorUserId": "598696", "LastActivityDate": "2017-12-29T17:45:08.850", "Score": "1", "CreationDate": "2017-12-29T17:36:48.520", "ParentId": "48026143", "CommentCount": "1", "OwnerUserId": "598696", "LastEditDate": "2017-12-29T17:45:08.850"}});