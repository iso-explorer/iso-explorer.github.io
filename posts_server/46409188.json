post_cb({"46409188": {"CommentCount": "12", "ViewCount": "97", "PostTypeId": "1", "LastEditorUserId": "285352", "CreationDate": "2017-09-25T15:44:48.897", "LastActivityDate": "2017-09-25T21:31:23.037", "Title": "Does C++11 standard require implementers to prioritize noexcept move constructor over const copy constructor for std::vector?", "FavoriteCount": "2", "LastEditDate": "2017-09-25T21:31:23.037", "Id": "46409188", "Score": "5", "Body": "<p>Reading <a href=\"https://stackoverflow.com/questions/28627348\">this</a> and <a href=\"https://stackoverflow.com/questions/26224112\">this</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">23.3.6.5/1</a> of the standard, where in the latest C++ standard draft is it specified that implementers should prioritize the use of non-throwing move-constructor <code>T(T &amp;&amp;t) noexcept</code> over a const copy-constructor <code>T(const T &amp;t)</code> when <code>std::vector&lt;T&gt;</code> re-allocates its element as a result of a <code>push_back</code> operation?  Is it <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">13.3.3.1.4/1</a> on overload resolution of reference binding?</p>\n<p><strong>EDIT 1</strong></p>\n<p>I argue on <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">13.3.3.1.4/1</a> because of the following reasons:</p>\n<ul>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">13.3/2</a>\n<blockquote>\n<p id=\"so_46409188_46409188_0\">Overload resolution selects the function to call in seven distinct contexts within the language. [...] <strong>invocation of a constructor for direct-initialization (8.5) of a class object (13.3.1.3)</strong>; [...] Each of these contexts defines the set of candidate functions and the list of arguments in its own unique way. But, once the candidate functions and argument lists have been identified, the selection of the best function is the same in all cases: First, a subset of the candidate functions (those that have the proper number of arguments and meet certain other conditions) is selected to form a set of viable functions (<strong>13.3.2</strong>). Then the best viable function is selected based on the implicit conversion sequences (<strong>13.3.3.1</strong>) needed to match each argument to the corresponding parameter of each viable function.</p>\n</blockquote></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">13.3.2/1</a>\n<blockquote>\n<p id=\"so_46409188_46409188_1\">From the set of candidate functions constructed for a given context (<strong>13.3.1</strong>), a set of viable functions is chosen, from which the best function will be selected by comparing argument conversion sequences for the best fit (<strong>13.3.3</strong>). The selection of viable functions considers relationships between arguments and function parameters other than the ranking of conversion sequences.</p>\n</blockquote></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">13.3.1.3/1</a>\n<blockquote>\n<p id=\"so_46409188_46409188_2\">When objects of class type are direct-initialized (8.5), or copy-initialized from an expression of the <strong>same</strong> or a derived class type (8.5), <strong>overload resolution selects the constructor</strong>.</p>\n</blockquote></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">13.3.3.1/5</a>\n<blockquote>\n<p id=\"so_46409188_46409188_3\">For the case where the parameter type is a <strong>reference</strong>, see <strong>13.3.3.1.4</strong>.</p>\n</blockquote></li>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">13.3.3.1.4/1</a>\n<blockquote>\n<p id=\"so_46409188_46409188_4\">When a parameter of reference type binds directly (8.5.3) to an argument expression, the implicit conversion sequence is <strong>the identity conversion</strong>, [...]</p>\n</blockquote></li>\n</ul>\n<p>And therefore, I conclude that the requirement of identity conversion results in requiring the prioritization of <code>T(T &amp;&amp;t) noexcept</code> over <code>T(const T &amp;t)</code>.  But, the other party I am arguing with is not convinced.  So, I ask here.</p>\n<p><strong>EDIT 2</strong></p>\n<p>The following is the link between <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">23.3.6.5</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">13.3.3.1.4</a>:</p>\n<p>First, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">23.3.6.5</a> requires the following of <code>std::vector</code>:</p>\n<blockquote>\n<p id=\"so_46409188_46409188_5\">[...]\n  <code>void push_back(const T&amp; x);</code>\n<code>void push_back(T&amp;&amp; x);</code>\n  Remarks: [...] If an exception is thrown <strong>other than</strong> by the copy constructor, move constructor, assignment operator, or move assignment operator of T or by any InputIterator operation there are <strong>no</strong> effects. [...]</p>\n</blockquote>\n<p>That is covered by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">23.3.6.1/2</a> that requires the following:</p>\n<blockquote>\n<p id=\"so_46409188_46409188_6\">A <strong>vector</strong> satisfies <strong>all</strong> of the requirements of a container and of a reversible container (given in two tables in 23.2), [...]</p>\n</blockquote>\n<p>That is, <code>std::vector</code> is expected to comply with <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">23.2.1/7</a> that specifies the following:</p>\n<blockquote>\n<p id=\"so_46409188_46409188_7\">Unless otherwise specified, <strong>all</strong> containers defined in this clause obtain memory <em>using an allocator</em> (see 17.6.3.5).</p>\n</blockquote>\n<p>and with <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">23.2.1/3</a> that specifies the following:</p>\n<blockquote>\n<p id=\"so_46409188_46409188_8\">For the components affected by this subclause that declare an <code>allocator_type</code>, objects stored in these components <strong>shall be constructed using the <code>allocator_traits&lt;allocator_type&gt;::construct</code> function</strong> and destroyed using the allocator_traits&lt;allocator_type&gt;::destroy function (<strong>20.7.8.2</strong>). These functions are called only for the container\u2019s element type, not for internal types used by the container.</p>\n</blockquote>\n<p>Since <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">20.7.8.2</a> specifies only one <code>construct</code> function as follows:</p>\n<pre><code>template &lt;class T, class... Args&gt;\nstatic void construct(Alloc&amp; a, T* p, Args&amp;&amp;... args);\n</code></pre>\n<p>with <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">20.7.8.2/5</a> requiring the following:</p>\n<blockquote>\n<p id=\"so_46409188_46409188_9\">Effects: calls <code>a.construct(p, std::forward&lt;Args&gt;(args)...)</code> if that call is well-formed; otherwise, invokes <strong><code>::new (static_cast&lt;void*&gt;(p)) T(std::forward&lt;Args&gt;(args)...)</code></strong>.</p>\n</blockquote>\n<p>and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">20.7.9.2/12</a> requiring the following of the default allocator:</p>\n<blockquote>\n<p id=\"so_46409188_46409188_10\">Effects: <strong><code>::new((void *)p) U(std::forward&lt;Args&gt;(args)...)</code></strong></p>\n</blockquote>\n<p>, both <code>T(std::forward&lt;Args&gt;(args)...)</code> in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">20.7.8.2/5</a> and <code>U(std::forward&lt;Args&gt;(args)...)</code> in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">20.7.9.2/12</a> will follow the constructor overload resolution requirement in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">13.3.3.1.4/1</a>.</p>\n<p>The standard therefore requires the implementers to prioritize the use of move-constructor <code>T(T &amp;&amp;t) noexcept</code> over copy-constructor <code>T(const T &amp;t)</code> when <code>std::vector&lt;T&gt;</code> re-allocates its elements due to <code>push_back</code> operations.</p>\n", "Tags": "<c++><c++11><vector><copy-constructor><move-constructor>", "OwnerUserId": "285352", "AnswerCount": "0"}, "bq_ids": {"n4140": {"so_46409188_46409188_0": {"section_id": 563, "quality": 0.9629629629629629, "length": 78}, "so_46409188_46409188_1": {"section_id": 600, "quality": 0.8947368421052632, "length": 34}, "so_46409188_46409188_8": {"section_id": 704, "quality": 0.8888888888888888, "length": 24}, "so_46409188_46409188_5": {"section_id": 986, "quality": 0.7727272727272727, "length": 17}, "so_46409188_46409188_2": {"section_id": 592, "quality": 1.0, "length": 15}, "so_46409188_46409188_7": {"section_id": 709, "quality": 0.8461538461538461, "length": 11}, "so_46409188_46409188_3": {"section_id": 610, "quality": 0.75, "length": 6}, "so_46409188_46409188_4": {"section_id": 625, "quality": 0.9285714285714286, "length": 13}, "so_46409188_46409188_9": {"section_id": 4231, "quality": 0.9090909090909091, "length": 10}, "so_46409188_46409188_6": {"section_id": 956, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_46409188_46409188_4": {"section_id": 615, "quality": 0.9285714285714286, "length": 13}, "so_46409188_46409188_0": {"section_id": 554, "quality": 0.9629629629629629, "length": 78}, "so_46409188_46409188_1": {"section_id": 590, "quality": 0.8947368421052632, "length": 34}, "so_46409188_46409188_5": {"section_id": 971, "quality": 0.7727272727272727, "length": 17}, "so_46409188_46409188_2": {"section_id": 582, "quality": 1.0, "length": 15}, "so_46409188_46409188_7": {"section_id": 698, "quality": 0.8461538461538461, "length": 11}, "so_46409188_46409188_3": {"section_id": 600, "quality": 0.75, "length": 6}, "so_46409188_46409188_8": {"section_id": 694, "quality": 0.8888888888888888, "length": 24}, "so_46409188_46409188_9": {"section_id": 4072, "quality": 0.9090909090909091, "length": 10}, "so_46409188_46409188_6": {"section_id": 944, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_46409188_46409188_0": {"section_id": 586, "quality": 0.9629629629629629, "length": 78}, "so_46409188_46409188_1": {"section_id": 626, "quality": 0.8947368421052632, "length": 34}, "so_46409188_46409188_5": {"section_id": 1049, "quality": 0.7727272727272727, "length": 17}, "so_46409188_46409188_7": {"section_id": 738, "quality": 0.8461538461538461, "length": 11}, "so_46409188_46409188_2": {"section_id": 615, "quality": 1.0, "length": 15}, "so_46409188_46409188_4": {"section_id": 651, "quality": 0.9285714285714286, "length": 13}, "so_46409188_46409188_3": {"section_id": 636, "quality": 0.75, "length": 6}, "so_46409188_46409188_8": {"section_id": 733, "quality": 0.8148148148148148, "length": 22}, "so_46409188_46409188_9": {"section_id": 5492, "quality": 0.8181818181818182, "length": 9}, "so_46409188_46409188_6": {"section_id": 1017, "quality": 0.9090909090909091, "length": 10}}}});