post_cb({"bq_ids": {"n4140": {"so_44773631_44773683_0": {"length": 9, "quality": 1.0, "section_id": 6100}, "so_44773631_44773683_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 3342}}, "n3337": {"so_44773631_44773683_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 5866}, "so_44773631_44773683_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 3212}}, "n4659": {"so_44773631_44773683_0": {"length": 9, "quality": 1.0, "section_id": 7597}, "so_44773631_44773683_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 7674}}}, "44773631": {"ViewCount": "843", "Body": "<p>I recently ran into this problem at work. A library I'm using makes use of reference counted objects and implements its own way of handling it. Part of the implementation is that each class of the library has a private destructor. Im guessing this is to prevent creation of objects on the stack as the library manages objects lifetime automatically (Its a scene graph).</p>\n<p>Anyways, I wanted to allocate an array of such a class on the heap and ran into the following problem:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n    class test\n    {\n    public:\n        test() {\n            cout &lt;&lt; \"ctor\" &lt;&lt; endl;\n        }\n\n        //~test() = delete; also doesnt work\n\n    private:\n        ~test()\n        {\n            cout &lt;&lt; \"dtor\" &lt;&lt; endl;\n        }\n\n    };\n\n    int main()\n    {\n        //works\n        auto oneInstance = new test;\n\n        //doesnt work\n        auto manyInstances = new test[3];\n    }\n</code></pre>\n<p>The array allocation produces the following error using GCC:</p>\n<pre><code>source_file.cpp: In function \u2018int main()\u2019:\nsource_file.cpp:15:5: error: \u2018test::~test()\u2019 is private\n     ~test()\n     ^\nsource_file.cpp:26:36: error: within this context\n     auto manyInstances = new test[3];\n                                    ^\n</code></pre>\n<p>Why does the destructor need to be public/available in order to allocate an array of this class on the heap? It works fine when only allocating a single instance like in the line before. I also tried using the more modern \"delete\" syntax, but it produced the same result.</p>\n<p>Is there any kind of magic in the new[] operator that I'm not aware of?</p>\n<p>EDIT:</p>\n<p>Thanks for the quick help. Im wondering why this code doesnt print \"dtor\" twice though:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass test\n{\npublic:\n    test() {\n        static int allocations = 0;\n        ++allocations;\n\n        if(allocations == 3)\n        {\n            //produce exception\n            throw 1;\n        }\n        cout &lt;&lt; \"ctor\" &lt;&lt; endl;\n    }\n\n    ~test()\n    {\n        cout &lt;&lt; \"dtor\" &lt;&lt; endl;\n    }\n\n};\n\nint main()\n{\n    //works\n    auto oneInstance = new test;\n\n    //doesnt work\n    try {\n    auto manyInstances = new test[3];\n    }\n    catch(...)\n    {\n            cout &lt;&lt; \"error?\";\n    }\n}\n</code></pre>\n<p>This prints:</p>\n<pre><code>ctor ctor dtor error?\n</code></pre>\n", "AcceptedAnswerId": "44773683", "Title": "Why can't I allocate an array of a class with deleted or private destructor?", "CreationDate": "2017-06-27T06:32:49.390", "Id": "44773631", "CommentCount": "14", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-06-27T07:38:59.307", "LastEditorUserId": "2072269", "LastActivityDate": "2017-06-28T07:21:27.433", "ClosedDate": "2017-06-27T12:54:20.433", "Score": "9", "OwnerUserId": "8218877", "Tags": "<c++><heap><destructor><private>", "AnswerCount": "1"}, "44773683": {"Id": "44773683", "PostTypeId": "2", "Body": "<p>It's because of exceptions, the array version of <code>new[]</code> has to go and call the destructor on elements that have been previously allocated when an exception propagates to ensure exception safety.  The single element <code>new</code> does not need to do that.  If allocation fails, it just fails, no need to destroy anything.  </p>\n<p><strong>\u00a7 8.3.4 New [expr.new/20]</strong></p>\n<blockquote>\n<p id=\"so_44773631_44773683_0\">If the new-expression creates an array of objects of class type, the destructor is potentially invoked</p>\n</blockquote>\n<hr>\n<p>Regarding your edit, see the following quote from the C++17 standard</p>\n<p><strong>\u00a7 8.17 Throwing an exception [expr.throw/4]</strong></p>\n<blockquote>\n<p id=\"so_44773631_44773683_1\">If no exception is presently being handled, evaluating a throw-expression with no operand calls <code>std::terminate()</code></p>\n</blockquote>\n<hr>\n<p>Regarding your second edit, you have missed counting an instance of <code>test</code> that you created via <code>new</code> (not <code>new[]</code>), that leads to the first instance of <code>test</code> being created, that's where the confusion about number of constructions comes from.  </p>\n</hr></hr>", "LastEditorUserId": "5501675", "LastActivityDate": "2017-06-28T07:21:27.433", "Score": "13", "CreationDate": "2017-06-27T06:36:21.597", "ParentId": "44773631", "CommentCount": "7", "LastEditDate": "2017-06-28T07:21:27.433", "OwnerUserId": "5501675"}});