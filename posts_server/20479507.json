post_cb({"20479933": {"Id": "20479933", "PostTypeId": "2", "Body": "<p>Your class position has no explicitly defined copy-assignment operator. When this statement </p>\n<p>vec2 = vec1;</p>\n<p>is executed the copy assignment operator for elements the number of which is common for the both vectors is called. So vec2[0] is substituted for vec1[0] (that is vec1[0] is assigned to vec2[0]). It means that old element vec2[0] gets id equal to 1. Nothing is deleted.</p>\n<p>When destructors are called vec2[0] has id equal to 1 and vec1[0] has id equal to 1 because this element was assigned to vec2[0]. The output shows this. </p>\n", "LastActivityDate": "2013-12-09T20:20:17.790", "CommentCount": "0", "CreationDate": "2013-12-09T20:20:17.790", "ParentId": "20479507", "Score": "0", "OwnerUserId": "2877241"}, "20479967": {"Id": "20479967", "PostTypeId": "2", "Body": "<p>Adding more print statements for compiler generated functions.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\n// Don't have this on my machine so added\n// to make it similar to the original\nstd::ostream&amp; qDebug()\n{\n    return std::cout;\n}\n\nstruct Position{\n    int id;\n    Position(int _id){\n        id = _id;\n        qDebug()&lt;&lt;\"Position\"&lt;&lt;id &lt;&lt;\"\\n\";\n    }\n\n    ~Position(){\n        qDebug()&lt;&lt;\"~Position \"&lt;&lt;id &lt;&lt;\"\\n\";\n    }\n\n\n    // Added this. Because if you don't define one\n    // the compiler will.\n    // Made it do the default action and print\n    Position(Position const&amp; rhs)\n        : id(rhs.id)\n    {\n        qDebug() &lt;&lt;\"Copy: \" &lt;&lt; id &lt;&lt;\"\\n\";\n    }\n\n    // Added this. Because if you don't define one\n    // the compiler will.\n    // Made it do the default action and print\n    Position&amp; operator=(Position const&amp; rhs)\n    {\n        qDebug() &lt;&lt; \"Assign: Old(\" &lt;&lt; id &lt;&lt; \")  New(\" &lt;&lt; rhs.id &lt;&lt; \")\\n\";\n        id = rhs.id;\n        return *this;\n    }\n};\n\n\n\nint main()\n{\n    qDebug()&lt;&lt;\"Init\\n\";\n    std::vector&lt;Position&gt; vec1;\n    vec1.emplace_back(1);\n    std::vector&lt;Position&gt; vec2;\n    vec2.emplace_back(2);\n    std::vector&lt;Position&gt; vec3;\n    vec3.emplace_back(3);\n\n    qDebug()&lt;&lt;\"Move\\n\";\n    vec2 = vec1;\n\n    qDebug()&lt;&lt;\"---------------------------------\\n\";\n}\n</code></pre>\n<p>Now we run it:</p>\n<pre><code>&gt; ./a.out\nInit\nPosition1\nPosition2\nPosition3\nMove\nAssign: Old(2)  New(1)\n---------------------------------\n~Position 3\n~Position 1\n~Position 1\n</code></pre>\n<p>So we can see that Position(2) got overwritten by an assignment that placed (1) into the value. The most important thing to note is that the number of constructors and destructors match.</p>\n", "LastActivityDate": "2013-12-09T20:21:52.467", "CommentCount": "5", "CreationDate": "2013-12-09T20:21:52.467", "ParentId": "20479507", "Score": "2", "OwnerUserId": "14065"}, "20479549": {"Id": "20479549", "PostTypeId": "2", "Body": "<p>When you write <code>vec2 = vec1</code>, <code>vec2</code> takes on copies of all the elements of <code>vec1</code>. How could it do that if it ceased to exist?</p>\n<p>Now, as for <code>vec2</code>'s <em>elements</em>, they don't need to be destroyed when they can be copied/moved<sup>\u2020</sup> over instead. The language allows either to happen.</p>\n<p>If you write your own copy/move assignment operators and put debug output in those, you'll see what's <em>really</em> going on.</p>\n<p><sup><sup>\u2020</sup> Depending on C++ version.</sup></p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2013-12-09T20:04:11.883", "Score": "4", "CreationDate": "2013-12-09T19:58:51.683", "ParentId": "20479507", "CommentCount": "14", "OwnerUserId": "560648", "LastEditDate": "2013-12-09T20:04:11.883"}, "bq_ids": {"n4140": {"so_20479507_20479633_0": {"length": 7, "quality": 1.0, "section_id": 705}, "so_20479507_20479633_1": {"length": 11, "quality": 1.0, "section_id": 710}}, "n3337": {"so_20479507_20479633_0": {"length": 7, "quality": 1.0, "section_id": 695}, "so_20479507_20479633_1": {"length": 11, "quality": 1.0, "section_id": 699}}, "n4659": {"so_20479507_20479633_0": {"length": 7, "quality": 1.0, "section_id": 734}, "so_20479507_20479633_1": {"length": 11, "quality": 1.0, "section_id": 739}}}, "20479633": {"Id": "20479633", "PostTypeId": "2", "Body": "<p>The container requirements (C++11 23.2.1) for assignment say:</p>\n<blockquote>\n<p id=\"so_20479507_20479633_0\">All existing elements of a are either move assigned to or destroyed</p>\n</blockquote>\n<p>(Actually that is only for assignment of an rvalue. For assignment of an lvalue, there's no specification at all other than that the two containers shall be equal afterwards.)</p>\n<p>So it's up to the implementation whether the original elements are destroyed, or overwritten element-wise.</p>\n<p>If you want to destroy the original container and replace it with a copy of another container unconditionally, you can use <code>swap</code> like so:</p>\n<pre><code>// instead of \"x = y\"\n\nstd::vector&lt;Position&gt;(y).swap(x);\n</code></pre>\n<p>This constructs a new vector as a copy of <code>y</code> and swaps that with <code>x</code>, and swapping doesn't touch the actual container elements - again from the container requirements:</p>\n<blockquote>\n<p id=\"so_20479507_20479633_1\"><code>a.swap(b)</code> shall exchange the values of a and b without invoking any move, copy, or swap operations on the individual container elements</p>\n</blockquote>\n", "LastEditorUserId": "596781", "LastActivityDate": "2013-12-09T21:03:43.913", "Score": "3", "CreationDate": "2013-12-09T20:03:39.617", "ParentId": "20479507", "CommentCount": "0", "OwnerUserId": "596781", "LastEditDate": "2013-12-09T21:03:43.913"}, "20479507": {"ViewCount": "182", "Body": "<p>I have the following code:</p>\n<pre><code>struct Position{\n   int id;\n   Position(int _id){\n       id = _id;\n       qDebug()&lt;&lt;\"Position\"&lt;&lt;id;\n   }\n\n   ~Position(){\n       qDebug()&lt;&lt;\"~Position \"&lt;&lt;id;\n   }\n};\n\n    qDebug()&lt;&lt;\"Init\";\n    std::vector&lt;Position&gt; vec1;\n    vec1.emplace_back(1);\n    std::vector&lt;Position&gt; vec2;\n    vec2.emplace_back(2);\n    std::vector&lt;Position&gt; vec3;\n    vec3.emplace_back(3);\n\n    qDebug()&lt;&lt;\"Move\";\n    vec2 = vec1;\n\n    qDebug()&lt;&lt;\"---------------------------------\";\n</code></pre>\n<p>What happens when I do = ? Shouldn't previous object vec2 be destructed?\nI read this <a href=\"http://www.cplusplus.com/reference/vector/vector/operator=/\" rel=\"nofollow\">http://www.cplusplus.com/reference/vector/vector/operator=/</a>, but still not undestand what should happend with old vec2 object.</p>\n<p><strong>Output:</strong></p>\n<pre><code>Init\nPosition 1\nPosition 2\nPosition 3\nMove\n---------------------------------\n~Position  3\n~Position  1\n~Position  1\n</code></pre>\n<p>Why Position  2 not destructed at all?</p>\n", "AcceptedAnswerId": "20479549", "Title": "What happened when do std::vector = std::vector?", "CreationDate": "2013-12-09T19:56:34.327", "Id": "20479507", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-12-09T21:03:43.913", "Score": "0", "OwnerUserId": "1559666", "Tags": "<c++><vector>", "AnswerCount": "4"}});