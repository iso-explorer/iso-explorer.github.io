post_cb({"40498405": {"ParentId": "40476058", "CommentCount": "0", "Body": "<p>No-padding is safe to assume in practice, unless you're compiling for a non-standard ABI.</p>\n<p>All compilers targeting the same ABI must make the same choice about struct/class sizes / layouts, and all the standard ABIs / calling conventions will have no padding in your struct.  (i.e. x86-32 and x86-64 System V and Windows, see the <a class=\"post-tag\" href=\"/questions/tagged/x86\" rel=\"tag\" title=\"show questions tagged 'x86'\">x86</a> tag wiki for links).  Your experiments with one compiler confirm it for all compilers targeting the same platform/ABI.</p>\n<p>Note that the scope of this question is limited to x86 compilers that support Intel's intrinsics and the <code>__m128i</code> type, which means we have much stronger guarantees than what you get from just the ISO C++ standard without any implementation-specific stuff.</p>\n<hr>\n<p>As @zneak points out, you can <code>static_assert(std::is_standard_layout&lt;Wrapper&gt;::value)</code> in the class def to remind people not to add any virtual methods, which would add a vtable pointer to each instance.</p>\n</hr>", "OwnerUserId": "224132", "PostTypeId": "2", "Id": "40498405", "Score": "1", "CreationDate": "2016-11-08T23:54:24.607", "LastActivityDate": "2016-11-08T23:54:24.607"}, "40476409": {"ParentId": "40476058", "LastEditDate": "2017-05-23T12:30:37.427", "CommentCount": "3", "CreationDate": "2016-11-07T23:15:26.663", "OwnerUserId": "6179296", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "40476409", "Score": "1", "Body": "<p>It isn't guaranteed.  <a href=\"https://stackoverflow.com/a/40476277/6179296\">Galik's answer</a> quotes the standard, so I'll focus on some of the risks of assuming that it will be contiguous.</p>\n<p>I wrote this small program and compiled with gcc, and it did put the integers contiguously:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nclass A\n{\npublic:\n  int a;\n  int method() { return 1;}\n  float method2() { return 5.5; }\n};\n\nint main()\n{\n  std::vector&lt;A&gt; as;\n  for(int i = 0; i &lt; 10; i++)\n  {\n     as.push_back(A()); \n  }\n  for(int i = 0; i &lt; 10; i++)\n  {\n     std::cout &lt;&lt; &amp;as[i] &lt;&lt; std::endl; \n  }\n}\n</code></pre>\n<p>However with one small change, the gaps started appearing:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nclass A\n{\npublic:\n  int a;\n  int method() { return 1;}\n  float method2() { return 5.5; }\n  virtual double method3() { return 0.1; } //this is the only change\n};\n\nint main()\n{\n  std::vector&lt;A&gt; as;\n  for(int i = 0; i &lt; 10; i++)\n  {\n     as.push_back(A()); \n  }\n  for(int i = 0; i &lt; 10; i++)\n  {\n     std::cout &lt;&lt; &amp;as[i] &lt;&lt; std::endl; \n  }\n}\n</code></pre>\n<p>Objects with virtual methods (or that inherit from objects with virtual methods) need to store a little extra information to know where to find the appropriate method, because it doesn't know which between the base class or any of the overrides until runtime.  This is why it is advised to <a href=\"https://stackoverflow.com/questions/12902651/how-to-do-the-equivalent-of-memsetthis-without-clobbering-the-vtbl\">never use <code>memset</code> on a class</a>.  As other answers point out, there may be padding there too, which isn't guaranteed to be consistent across compilers or even different versions of the same compiler.</p>\n<p>In the end, it probably is just not worth it to assume that it will be continuous on a given compiler, and even if you test it and it works, simple things like adding a virtual method later will cause you a massive headache.</p>\n", "LastActivityDate": "2016-11-07T23:15:26.663"}, "40476058": {"CommentCount": "8", "ViewCount": "116", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-11-07T22:46:50.263", "LastActivityDate": "2016-11-09T16:21:22.667", "Title": "Does std::vector<Simd_wrapper> have contiguous data in memory?", "AcceptedAnswerId": "40498405", "LastEditDate": "2017-05-23T12:30:37.427", "Id": "40476058", "Score": "1", "Body": "<pre><code>class Wrapper {\npublic:\n    // some functions operating on the value_\n    __m128i value_;\n};\n\nint main() {\n    std::vector&lt;Wrapper&gt; a;\n    a.resize(100);\n}\n</code></pre>\n<p>Would the <code>value_</code> attribute of the <code>Wrapper</code> objects in the <code>vector a</code> always occupy contiguous memory without any gaps between the <code>__m128i values</code> ?</p>\n<p>I mean:</p>\n<pre><code>[128 bit for 1st Wrapper][no gap here][128bit for 2nd Wrapper] ...\n</code></pre>\n<p>So far, this seems to be true for g++ and the Intel cpu I am using, and gcc godbolt.</p>\n<p>Since there is only a single __m128i attribute in the <code>Wrapper</code> object, does that mean the compiler <strong>always</strong> do not need to add any kind of padding in memory? (<a href=\"https://stackoverflow.com/questions/30168069/memory-layout-of-vector-of-pod-objects\">Memory layout of vector of POD objects</a>)</p>\n<p>Test code 1:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;x86intrin.h&gt;\n\nint main()\n{\n  static constexpr size_t N = 1000;\n  std::vector&lt;__m128i&gt; a;\n  a.resize(1000);\n  //__m128i a[1000];\n  uint32_t* ptr_a = reinterpret_cast&lt;uint32_t*&gt;(a.data());\n  for (size_t i = 0; i &lt; 4*N; ++i)\n    ptr_a[i] = i;\n  for (size_t i = 1; i &lt; N; ++i){\n    a[i-1] = _mm_and_si128 (a[i], a[i-1]);\n  }\n  for (size_t i = 0; i &lt; 4*N; ++i)\n    std::cout &lt;&lt; ptr_a[i];\n}\n</code></pre>\n<p>Warning:</p>\n<pre><code>warning: ignoring attributes on template argument \n'__m128i {aka __vector(2) long long int}'\n[-Wignored-attributes]\n</code></pre>\n<p>Assembly (<a href=\"https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,options:(colouriseAsm:'0',compileOnChange:'0'),source:'//+Type+your+code+here,+or+load+an+example.%0A%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Cx86intrin.h%3E%0A%0Aint+main()%0A%7B%0A++static+constexpr+size_t+N+%3D+1000%3B%0A++std::vector%3C__m128i%3E+a%3B%0A++a.resize(1000)%3B%0A++//__m128i+a%5B1000%5D%3B%0A++uint32_t*+ptr_a+%3D+reinterpret_cast%3Cuint32_t*%3E(a.data())%3B%0A++for+(size_t+i+%3D+0%3B+i+%3C+4*N%3B+%2B%2Bi)%0A++++ptr_a%5Bi%5D+%3D+i%3B%0A++for+(size_t+i+%3D+1%3B+i+%3C+N%3B+%2B%2Bi)%7B%0A++++a%5Bi-1%5D+%3D+_mm_and_si128+(a%5Bi%5D,+a%5Bi-1%5D)%3B%0A++%7D%0A++for+(size_t+i+%3D+0%3B+i+%3C+4*N%3B+%2B%2Bi)%0A++++std::cout+%3C%3C+ptr_a%5Bi%5D%3B%0A%7D'),l:'5',n:'1',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:g62,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),options:'-Ofast'),l:'5',n:'0',o:'%231+with+x86-64+gcc+6.2',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4\" rel=\"nofollow noreferrer\">gcc god bolt</a>):</p>\n<pre><code>.L9:\n        add     rax, 16\n        movdqa  xmm1, XMMWORD PTR [rax]\n        pand    xmm0, xmm1\n        movaps  XMMWORD PTR [rax-16], xmm0\n        cmp     rax, rdx\n        movdqa  xmm0, xmm1\n        jne     .L9\n</code></pre>\n<p>I guess this means the data is contiguous because the loop just add 16 bytes to the memory address it reads in every cycle of the loop. It is using <code>pand</code> to do the bitwise and.</p>\n<p>Test code 2:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;x86intrin.h&gt;\nclass Wrapper {\npublic:\n    __m128i value_;\n    inline Wrapper&amp; operator &amp;= (const Wrapper&amp; rhs)\n    {\n        value_ = _mm_and_si128(value_, rhs.value_);\n    }\n}; // Wrapper\nint main()\n{\n  static constexpr size_t N = 1000;\n  std::vector&lt;Wrapper&gt; a;\n  a.resize(N);\n  //__m128i a[1000];\n  uint32_t* ptr_a = reinterpret_cast&lt;uint32_t*&gt;(a.data());\n  for (size_t i = 0; i &lt; 4*N; ++i) ptr_a[i] = i;\n  for (size_t i = 1; i &lt; N; ++i){\n    a[i-1] &amp;=a[i];\n    //std::cout &lt;&lt; ptr_a[i];\n  }\n  for (size_t i = 0; i &lt; 4*N; ++i)\n    std::cout &lt;&lt; ptr_a[i];\n}\n</code></pre>\n<p>Assembly (<a href=\"https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,options:(colouriseAsm:'0',compileOnChange:'0'),source:'//+Type+your+code+here,+or+load+an+example.%0A%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Cx86intrin.h%3E%0Aclass+Wrapper+%7B%0Apublic:%0A++++__m128i+value_%3B%0A++++inline+Wrapper%26+operator+%26%3D+(const+Wrapper%26+rhs)%0A++++%7B%0A++++++++value_+%3D+_mm_and_si128(value_,+rhs.value_)%3B%0A++++%7D%0A%7D%3B+//+Wrapper%0Aint+main()%0A%7B%0A++static+constexpr+size_t+N+%3D+1000%3B%0A++std::vector%3CWrapper%3E+a%3B%0A++a.resize(N)%3B%0A++//__m128i+a%5B1000%5D%3B%0A++uint32_t*+ptr_a+%3D+reinterpret_cast%3Cuint32_t*%3E(a.data())%3B%0A++for+(size_t+i+%3D+0%3B+i+%3C+4*N%3B+%2B%2Bi)+ptr_a%5Bi%5D+%3D+i%3B%0A++for+(size_t+i+%3D+1%3B+i+%3C+N%3B+%2B%2Bi)%7B%0A++++a%5Bi-1%5D+%26%3Da%5Bi%5D%3B%0A++%09//std::cout+%3C%3C+ptr_a%5Bi%5D%3B%0A++%7D%0A++for+(size_t+i+%3D+0%3B+i+%3C+4*N%3B+%2B%2Bi)%0A++++std::cout+%3C%3C+ptr_a%5Bi%5D%3B%0A%7D'),l:'5',n:'1',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:g62,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),options:'-Ofast'),l:'5',n:'0',o:'%231+with+x86-64+gcc+6.2',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4\" rel=\"nofollow noreferrer\">gcc god bolt</a>)</p>\n<pre><code>.L9:\n        add     rdx, 2\n        add     rax, 32\n        movdqa  xmm1, XMMWORD PTR [rax-16]\n        pand    xmm0, xmm1\n        movaps  XMMWORD PTR [rax-32], xmm0\n        movdqa  xmm0, XMMWORD PTR [rax]\n        pand    xmm1, xmm0\n        movaps  XMMWORD PTR [rax-16], xmm1\n        cmp     rdx, 999\n        jne     .L9\n</code></pre>\n<p>Looks like no padding too. <code>rax</code> increases by 32 in each step, and that is 2 x 16. That extra <code>add rdx,2</code> is definitely not as good as the loop from test code 1.</p>\n<p>Test auto-vectorization </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;x86intrin.h&gt;\n\nint main()\n{\n  static constexpr size_t N = 1000;\n  std::vector&lt;__m128i&gt; a;\n  a.resize(1000);\n  //__m128i a[1000];\n  uint32_t* ptr_a = reinterpret_cast&lt;uint32_t*&gt;(a.data());\n  for (size_t i = 0; i &lt; 4*N; ++i)\n    ptr_a[i] = i;\n  for (size_t i = 1; i &lt; N; ++i){\n    a[i-1] = _mm_and_si128 (a[i], a[i-1]);\n  }\n  for (size_t i = 0; i &lt; 4*N; ++i)\n    std::cout &lt;&lt; ptr_a[i];\n}\n</code></pre>\n<p>Assembly (<a href=\"https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,options:(colouriseAsm:'0',compileOnChange:'0'),source:'//+Type+your+code+here,+or+load+an+example.%0A%23include+%3Ciostream%3E%0A%23include+%3Cvector%3E%0A%23include+%3Cx86intrin.h%3E%0Aclass+Wrapper+%7B%0Apublic:%0A++++__m128i+value_%3B%0A++++inline+Wrapper%26+operator+%26%3D+(const+Wrapper%26+rhs)%0A++++%7B%0A++++++++value_+%3D+_mm_and_si128(value_,+rhs.value_)%3B%0A++++%7D%0A%7D%3B+//+Wrapper%0Aint+main()%0A%7B%0A++static+constexpr+size_t+N+%3D+1000%3B%0A++std::vector%3CWrapper%3E+a%3B%0A++a.resize(N)%3B%0A++//__m128i+a%5B1000%5D%3B%0A++uint32_t*+ptr_a+%3D+reinterpret_cast%3Cuint32_t*%3E(a.data())%3B%0A++for+(size_t+i+%3D+0%3B+i+%3C+4*N%3B+%2B%2Bi)+ptr_a%5Bi%5D+%3D+i%3B%0A++for+(size_t+i+%3D+0%3B+i+%3C+N%3B+%2B%2Bi)%7B%0A++++a%5Bi-1%5D+%26%3Da%5Bi%5D%3B%0A++%09//std::cout+%3C%3C+ptr_a%5Bi%5D%3B%0A++%7D%0A++for+(size_t+i+%3D+0%3B+i+%3C+4*N%3B+%2B%2Bi)%0A++++std::cout+%3C%3C+ptr_a%5Bi%5D%3B%0A%7D'),l:'5',n:'1',o:'C%2B%2B+source+%231',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:g62,filters:(b:'0',commentOnly:'0',directives:'0',intel:'0'),options:'-Ofast'),l:'5',n:'0',o:'%231+with+x86-64+gcc+6.2',t:'0')),k:50,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4\" rel=\"nofollow noreferrer\">god bolt</a>):</p>\n<pre><code>.L21:\n        movdqu  xmm0, XMMWORD PTR [r10+rax]\n        add     rdi, 1\n        pand    xmm0, XMMWORD PTR [r8+rax]\n        movaps  XMMWORD PTR [r8+rax], xmm0\n        add     rax, 16\n        cmp     rsi, rdi\n        ja      .L21\n</code></pre>\n<p>... I just don't know if this is always true for intel cpu and g++/intel c++ compilers/(insert compiler name here) ...</p>\n", "Tags": "<c++><vector><simd>", "OwnerUserId": "7028009", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_40476058_40476277_1": {"section_id": 5879, "quality": 0.5263157894736842, "length": 20}, "so_40476058_40476277_3": {"section_id": 6077, "quality": 1.0, "length": 24}}, "n3337": {"so_40476058_40476277_1": {"section_id": 5650, "quality": 0.9210526315789473, "length": 35}, "so_40476058_40476277_3": {"section_id": 5845, "quality": 1.0, "length": 24}}, "n4659": {"so_40476058_40476277_1": {"section_id": 7363, "quality": 0.5263157894736842, "length": 20}, "so_40476058_40476277_3": {"section_id": 7573, "quality": 1.0, "length": 24}}}, "40476277": {"ParentId": "40476058", "LastEditDate": "2016-11-07T23:08:41.027", "CommentCount": "3", "CreationDate": "2016-11-07T23:04:13.920", "OwnerUserId": "3807729", "LastEditorUserId": "3807729", "PostTypeId": "2", "Id": "40476277", "Score": "2", "Body": "<p>There is no guarantee that there won't be padding at the end of the <code>class Wrapper</code> only that there won't be padding at its <em>beginning</em>.</p>\n<p>According to the <code>C++11</code> Standard:</p>\n<blockquote>\n<p id=\"so_40476058_40476277_0\"><strong>9.2</strong> Class members <strong>[</strong> class.mem <strong>]</strong></p>\n<p id=\"so_40476058_40476277_1\"><strong>20</strong> A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [ Note: There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning, as necessary to achieve appropriate alignment. \u2014 end note ]</p>\n</blockquote>\n<p>Also under <code>sizeof</code>:</p>\n<blockquote>\n<p id=\"so_40476058_40476277_2\"><strong>5.3.3</strong> Sizeof <strong>[</strong> expr.sizeof <strong>]</strong></p>\n<p id=\"so_40476058_40476277_3\"><strong>2</strong> When applied to a reference or a reference type, the result is the size of the referenced type. When applied\n  to a class, the result is the number of bytes in an object of that class including any padding required for\n  placing objects of that type in an array.</p>\n</blockquote>\n", "LastActivityDate": "2016-11-07T23:08:41.027"}});