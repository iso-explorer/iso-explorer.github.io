post_cb({"1139100": {"ParentId": "1139063", "CommentCount": "0", "Body": "<p>Very strange, I copied and pasted directly to VS 2005 and I get an error, which I expected:</p>\n<p>Error   1   error LNK2001: unresolved external symbol \"void __cdecl B::F(class A::H)\" </p>\n<p>Because we haven't actually defined F(x) in namespace B... not sure why Gcc is giving this error.</p>\n", "OwnerUserId": "132961", "PostTypeId": "2", "Id": "1139100", "Score": "1", "CreationDate": "2009-07-16T17:33:27.150", "LastActivityDate": "2009-07-16T17:33:27.150"}, "1139115": {"ParentId": "1139063", "CommentCount": "0", "Body": "<p>I just tried compiling it on Visual Studio 2005 and it worked fine. I wonder if it's a broken implementation of Argument Dependent Lookup where the namespace from the arguments was accidentally brought in?</p>\n", "OwnerUserId": "852", "PostTypeId": "2", "Id": "1139115", "Score": "0", "CreationDate": "2009-07-16T17:36:01.013", "LastActivityDate": "2009-07-16T17:36:01.013"}, "1139083": {"ParentId": "1139063", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>That's because compiler will search function in the same namespace its arguments from. Compiler found there <code>A::F</code> identifier but it is not a function. In result you'll get the error.</p>\n<p>It is standard behaviour as far as I can remember. </p>\n<blockquote>\n<p id=\"so_1139063_1139083_0\"><strong>3.4.2  Argument-dependent name lookup</strong>\n  When an unqualified name is used as the postfix-expression in a function call (5.2.2), other namespaces not considered during the usual unqualified lookup (3.4.1) may be searched, and namespace-scope friend function declarations (11.4) not otherwise visible may be found.  These modifications to the search depend on the types of the arguments (and for template template arguments, the namespace of the template argument).</p>\n<p id=\"so_1139063_1139083_1\">For each argument type T in the function call, there is a set of zero or more associated namespaces and a set of zero or more associated classes to be considered.  The sets of namespaces and classes is determined entirely by the types of the function arguments (and the namespace of any template template argument).\n  Typedef names and using-declarations used to specify the types do not contribute to this set. The sets of namespaces and classes are determined in the following way...</p>\n</blockquote>\n<p>This rule allows you to write the following code:</p>\n<pre><code>std::vector&lt;int&gt; x;\n// adding some data to x\n//...\n\n// now sort it\nsort( x.begin(), x.end() ); // no need to write std::sort\n</code></pre>\n<p><strong>And finally: Because of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#218\" rel=\"nofollow noreferrer\">Core Issue 218</a> some compilers would compile the code in question without any errors.</strong></p>\n", "OwnerUserId": "123111", "LastEditorUserId": "123111", "LastEditDate": "2009-07-16T18:18:55.763", "Id": "1139083", "Score": "11", "CreationDate": "2009-07-16T17:31:07.480", "LastActivityDate": "2009-07-16T18:18:55.763"}, "1139099": {"ParentId": "1139063", "CommentCount": "6", "Body": "<p>Have you tried using other compilers yet? There is a <a href=\"http://gcc.gnu.org/ml/gcc-bugs/2006-01/msg02891.html\" rel=\"nofollow noreferrer\">gcc bug report</a> here which is suspended (whatever that means).</p>\n<p>EDIT: After some research, I found this <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=17365\" rel=\"nofollow noreferrer\">more official bug</a>.</p>\n", "OwnerUserId": "34065", "PostTypeId": "2", "Id": "1139099", "Score": "4", "CreationDate": "2009-07-16T17:33:06.650", "LastActivityDate": "2009-07-16T17:33:06.650"}, "bq_ids": {"n4140": {"so_1139063_1139083_1": {"section_id": 7104, "quality": 0.9318181818181818, "length": 41}, "so_1139063_1139083_0": {"section_id": 7103, "quality": 0.7560975609756098, "length": 31}}, "n3337": {"so_1139063_1139083_1": {"section_id": 6848, "quality": 0.9318181818181818, "length": 41}, "so_1139063_1139083_0": {"section_id": 6847, "quality": 0.7560975609756098, "length": 31}}, "n4659": {"so_1139063_1139083_1": {"section_id": 8605, "quality": 0.8409090909090909, "length": 37}, "so_1139063_1139083_0": {"section_id": 8604, "quality": 0.7560975609756098, "length": 31}}}, "1139063": {"CommentCount": "0", "ViewCount": "532", "PostTypeId": "1", "LastEditorUserId": "16587", "CreationDate": "2009-07-16T17:26:38.113", "LastActivityDate": "2009-07-17T12:49:11.743", "Title": "Namespace Clashing in C++", "AcceptedAnswerId": "1139083", "LastEditDate": "2009-07-17T12:49:11.743", "Id": "1139063", "Score": "7", "Body": "<p>I cannot understand why this piece of code does not compile:</p>\n<pre><code>namespace A {\n        class F {};             // line 2\n        class H : public F {};\n}\n\nnamespace B {\n        void F(A::H x);         // line 7\n        void G(A::H x) {\n                F(x);           // line 9\n        }\n}\n</code></pre>\n<p>I am using <code>gcc 4.3.3</code>, and the error is:</p>\n<pre><code>s3.cpp: In function \u2018void B::G(A::H)\u2019:\ns3.cpp:2: error: \u2018class A::F\u2019 is not a function,\ns3.cpp:7: error:   conflict with \u2018void B::F(A::H)\u2019\ns3.cpp:9: error:   in call to \u2018F\u2019\n</code></pre>\n<p>I think that because in line 9 there is no namespace prefix, <code>F(x)</code> should definitively mean only <code>B::F(x)</code>. The compiler tries to cast <code>x</code> into its own superclass. In my understanding it should not. Why does it do that?</p>\n", "Tags": "<c++><namespaces><polymorphism>", "OwnerUserId": "42610", "AnswerCount": "4"}});