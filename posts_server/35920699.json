post_cb({"bq_ids": {"n4140": {"so_35920699_35922261_1": {"length": 20, "quality": 1.0, "section_id": 3240}}, "n3337": {"so_35920699_35922261_1": {"length": 13, "quality": 0.65, "section_id": 3113}}, "n4659": {"so_35920699_35922261_1": {"length": 20, "quality": 1.0, "section_id": 3996}}}, "35920699": {"ViewCount": "94", "Body": "<p>I want to register callback functions, and store them in a vector to call them. It should also be allowed to use member functions as callback functions. </p>\n<p>My initial was approach was using <code>&lt;functional&gt;</code> in the following way:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\n\nstd::vector&lt;std::function&lt;void()&gt;&gt; functions;\n\nstruct Foo {\n    void Bar() {\n        std::cout &lt;&lt; \"Hello\" &lt;&lt; std::endl;\n    }\n};\n\ntemplate&lt;class T&gt;\nvoid Register( T* obj, std::function&lt;void(T*)&gt; function ) {\n    functions.push_back( std::bind( function, obj ) );\n}\n\nvoid main(){\n    Foo foo;\n    Register(&amp;foo, &amp;Foo::Bar);\n}\n</code></pre>\n<p>This doesn't work since the compiler cannot deduce the parameter type. It only works if I specify the type explicitly: <code>Register&lt;Foo&gt;(&amp;foo, &amp;Foo::Bar);</code>. This is not what I wanted, so I tried using the old function pointers:</p>\n<pre><code>template&lt;class T&gt;\nvoid Register( T* obj, void(T::* function)() ) {\n    functions.push_back( std::bind( function, obj ) );\n}\n</code></pre>\n<p>And it worked. Since I dislike this form of function pointers I made a type for Memberfunction pointers:</p>\n<pre><code>template&lt;class Owner&gt;\nusing Memberfunction = void( Owner::* )();\n\ntemplate&lt;class T&gt;\nvoid Register( T* obj, Memberfunction&lt;T&gt; function ) {\n    functions.push_back( std::bind( function, obj ) );\n}\n</code></pre>\n<p>This worked just fine. But now I wanted to support functions with one single parameter, since I didn't want to specify a Memberfunction for each parameter type I wanted to again use templates.</p>\n<pre><code>template&lt;class Owner, class Param&gt;\nusing Memberfunction = void( Owner::* )( Param );\n\ntemplate&lt;class T&gt;\nvoid Register( T* obj, Memberfunction&lt;T,float&gt; function ) {\n    using namespace std::placeholders;\n    functions.push_back( std::bind( function, obj, _1 ) );\n}\n</code></pre>\n<p>This worked good so far, but I didn't want to have to to specify a member function for one or no parameter, so I wanted to use <code>void</code> as second parameter of <code>Memberfunction</code>, but this lead to an internal compiler error, so I guess this doesn't work.</p>\n<p>Interestingly <code>Memberfunction&lt;Foo,void&gt; bar = &amp;Foo::Bar;</code> lead to the following error:</p>\n<pre><code>cannot convert from 'void (__thiscall Foo::* )(void)' to 'void (__thiscall Foo::* )(void)'\n</code></pre>\n<p>So now to my questions: </p>\n<p>Is it somehow possible to use <code>std::function</code> for this?</p>\n<p>If this doesn't work can I avoid having to specify at least two member function types?</p>\n<p>Thanks in advance for your help. </p>\n", "AcceptedAnswerId": "35922261", "Title": "Member function as parameter for a function template", "CreationDate": "2016-03-10T15:29:24.733", "Id": "35920699", "CommentCount": "3", "LastEditDate": "2016-03-10T15:38:12.867", "PostTypeId": "1", "LastEditorUserId": "6045314", "LastActivityDate": "2016-03-10T16:39:29.313", "Score": "4", "OwnerUserId": "6045314", "Tags": "<c++><function><templates><callback><member>", "AnswerCount": "2"}, "35921319": {"Id": "35921319", "PostTypeId": "2", "Body": "<p>You can make this work by hiding the type of <code>function&lt;void(T*)</code> in a struct. This avoid the problem of non-deduced contexts:</p>\n<pre><code>template&lt;typename T&gt;\nstruct void_fn_type\n{\n    using type = std::function&lt;void(T)&gt;;\n};\n\ntemplate&lt;class T&gt;\nvoid Register(T* obj, typename void_fn_type&lt;T*&gt;::type function) {\n    functions.push_back( std::bind( function, obj ));\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/e7426f72ae33fb83\" rel=\"nofollow\">Demo</a></p>\n<p>I feel compelled to also recommend the use of a lambda instead of <code>std::bind</code></p>\n<p>(<strong>Edit</strong>: not sure if it's a non-deduced context in this scenario. Perhaps an issue with the fact that <code>Foo::Bar</code> is only convertible to <code>std::function&lt;void(Foo*)&gt;</code>)</p>\n", "LastEditorUserId": "27678", "LastActivityDate": "2016-03-10T16:06:08.800", "Score": "2", "CreationDate": "2016-03-10T15:56:12.407", "ParentId": "35920699", "CommentCount": "0", "OwnerUserId": "27678", "LastEditDate": "2016-03-10T16:06:08.800"}, "35922261": {"Id": "35922261", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_35920699_35922261_0\">Interestingly <code>Memberfunction&lt;Foo,void&gt; bar = &amp;Foo::Bar;</code> lead to the following error:</p>\n<pre><code>cannot convert from 'void (__thiscall Foo::* )(void)' to 'void (__thiscall Foo::* )(void)'\n</code></pre>\n</blockquote>\n<p>That's because your compiler is giving you a bad error message. The code itself is invalid, but it has to do with the the creation of the type <code>Memberfunction&lt;Foo,void&gt;</code>. You can use <code>void</code> as the parameter list of a function only in the special case that it's non-dependent. From <a href=\"http://eel.is/c++draft/dcl.fct#4\" rel=\"nofollow\">[dcl.fct]</a>:</p>\n<blockquote>\n<p id=\"so_35920699_35922261_1\">A parameter list consisting of a single unnamed parameter of non-dependent type <code>void</code> is equivalent to an empty parameter list. Except for this special case, a parameter shall not have type <em>cv</em> <code>void</code>.</p>\n</blockquote>\n<p>I can write the type <code>void(void)</code>. But I cannot write the type <code>template &lt;class T&gt; using F = void(T); F&lt;void&gt;</code>. In this case, you're trying to create a pointer-to-member function using a dependent <code>void</code> type as the parameter list. </p>\n<p>You don't need <code>std::function</code> though. Just fix your alias declaration to allow for passing in no arguments:</p>\n<pre><code>template&lt;class Owner, class... Params&gt;\nusing Memberfunction = void( Owner::* )( Params... );\n\nMemberfunction&lt;Foo&gt; bar = &amp;Foo::Bar;\n</code></pre>\n<hr/>\n<p>That said, this doesn't make much sense:</p>\n<pre><code>template&lt;class T&gt;\nvoid Register( T* obj, Memberfunction&lt;T,float&gt; function ) {\n    using namespace std::placeholders;\n    functions.push_back( std::bind( function, obj, _1 ) );\n}\n</code></pre>\n<p><code>functions</code> is a container of <code>std::function&lt;void()&gt;</code> -- that is, nullary function objects -- but <code>std::bind(function, obj, _1)</code> is a function that requires one parameter. This won't work. You'd have to pass in the float too:</p>\n<pre><code>template&lt;class T&gt;\nvoid Register( T* obj, Memberfunction&lt;T,float&gt; function, float var ) {\n    functions.push_back( std::bind( function, obj, var ) );\n}\n</code></pre>\n<p>otherwise it won't be nullary. Or, more generally:</p>\n<pre><code>template &lt;class T, class MF, class... Args&gt;\nvoid Register(T* obj, MF mem_fun, Args&amp;&amp;... args) {\n    functions.push_back(std::bind(obj, mem_fun, std::forward&lt;Args&gt;(args)...));\n}\n</code></pre>\n", "LastActivityDate": "2016-03-10T16:39:29.313", "CommentCount": "0", "CreationDate": "2016-03-10T16:39:29.313", "ParentId": "35920699", "Score": "1", "OwnerUserId": "2069064"}});