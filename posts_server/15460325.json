post_cb({"15460400": {"Id": "15460400", "PostTypeId": "2", "Body": "<p>You could use SFINAE to rule out the instantiation of the signature of your comparison operators (and therefore the instantiation of <code>std::underlying_type&lt;T&gt;</code>) when the corresponding argument is <em>not</em> an enumeration:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt;typename E, \n    typename std::enable_if&lt;std::is_enum&lt;E&gt;::value&gt;::type* = nullptr&gt;\nbool operator != (E e, typename std::underlying_type&lt;E&gt;::type n)\n{\n    return static_cast&lt;typename std::underlying_type&lt;E&gt;::type&gt;(e) != n;\n}\n\ntemplate&lt;typename E, \n    typename std::enable_if&lt;std::is_enum&lt;E&gt;::value&gt;::type* = nullptr&gt;\nbool operator != (typename std::underlying_type&lt;E&gt;::type n, E e)\n{\n    return static_cast&lt;typename std::underlying_type&lt;E&gt;::type&gt;(e) != n;\n}\n</code></pre>\n<p>Here is a <a href=\"http://liveworkspace.org/code/4cvdpz%2459\" rel=\"nofollow\">live example</a>.</p>\n<p><strong>EDIT:</strong></p>\n<p>Since VC11 seems to lack support for default arguments on template parameters of a function template, here is an alternative solution:</p>\n<pre><code>template&lt;typename E&gt;\ntypename std::enable_if&lt;std::is_enum&lt;E&gt;::value, bool&gt;::type\noperator != (E e, typename std::underlying_type&lt;E&gt;::type n)\n{\n    return static_cast&lt;typename std::underlying_type&lt;E&gt;::type&gt;(e) != n;\n}\n\ntemplate&lt;typename E&gt;\ntypename std::enable_if&lt;std::is_enum&lt;E&gt;::value, bool&gt;::type\noperator != (typename std::underlying_type&lt;E&gt;::type n, E e)\n{\n    return static_cast&lt;typename std::underlying_type&lt;E&gt;::type&gt;(e) != n;\n}\n</code></pre>\n<p>And a <a href=\"http://liveworkspace.org/code/4cvdpz%2461\" rel=\"nofollow\">live example</a> of course.</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-03-17T13:38:43.197", "Score": "4", "CreationDate": "2013-03-17T11:46:40.090", "ParentId": "15460325", "CommentCount": "6", "OwnerUserId": "1932150", "LastEditDate": "2013-03-17T13:38:43.197"}, "15462180": {"Id": "15462180", "PostTypeId": "2", "Body": "<p>Section 14.8.2 paragraph 8 of the C++11 standard states:</p>\n<blockquote>\n<p id=\"so_15460325_15462180_0\">If a substitution results in an invalid type or expression, type deduction fails. An invalid type or expression\n      is one that would be ill-formed if written using the substituted arguments. [ Note: Access checking is done as\n      part of the substitution process. \u2014 end note ] <strong>Only invalid types and expressions in the immediate context of\n      the function type and its template parameter types can result in a deduction failure.</strong> [ Note: The evaluation\n      of the substituted types and expressions can result in side effects such as the instantiation of class template\n      specializations and/or function template specializations, the generation of implicitly-defined functions, etc.\n      Such side effects are not in the \u201cimmediate context\u201d and can result in the program being ill-formed. \u2014 end\n      note ]</p>\n</blockquote>\n<p>In your case, instantiating <code>underlying_type</code> causes a failure, but not in the immediate context, so it is not a type deduction failure, so SFINAE does not apply.</p>\n", "LastEditorUserId": "951890", "LastActivityDate": "2013-03-17T15:04:36.243", "Score": "1", "CreationDate": "2013-03-17T14:58:15.710", "ParentId": "15460325", "CommentCount": "0", "OwnerUserId": "951890", "LastEditDate": "2013-03-17T15:04:36.243"}, "bq_ids": {"n4140": {"so_15460325_15462180_0": {"length": 69, "quality": 0.8961038961038961, "section_id": 300}, "so_15460325_15460325_0": {"length": 35, "quality": 0.9210526315789473, "section_id": 355}}, "n3337": {"so_15460325_15462180_0": {"length": 69, "quality": 0.8961038961038961, "section_id": 291}, "so_15460325_15460325_0": {"length": 35, "quality": 0.9210526315789473, "section_id": 345}}, "n4659": {"so_15460325_15462180_0": {"length": 65, "quality": 0.8441558441558441, "section_id": 307}, "so_15460325_15460325_0": {"length": 35, "quality": 0.9210526315789473, "section_id": 365}}}, "15460325": {"ViewCount": "322", "Body": "<p>I am trying to make scoped enumerations in my program comparable to underlying type but the following code does not work. Is it because of poor C++11 standard support in the compiler I am using (VC11) or is it because the code breaks some rules from C++11 standard? In latter case which rules exactly are being broken (references to specific standard clauses are welcome)?</p>\n<pre><code>#include &lt;type_traits&gt;\nenum class Test: short int { A,B,C };\ntemplate&lt;typename E&gt; bool operator != (E e, typename std::underlying_type&lt;E&gt;::type n)\n{\n    return static_cast&lt;typename std::underlying_type&lt;E&gt;::type&gt;(e) != n;\n}\ntemplate&lt;typename E&gt; bool operator != (typename std::underlying_type&lt;E&gt;::type n, E e)\n{\n    return static_cast&lt;typename std::underlying_type&lt;E&gt;::type&gt;(e) != n;\n}\nint main()\n{\n    short int x = 123;\n    x != Test::B; // compilation error\n}\n</code></pre>\n<p>Here is why I think my code should be C++11 compliant. A quote from C++11 standard (14.8.3.1):</p>\n<blockquote>\n<p id=\"so_15460325_15460325_0\">For each function template, if the argument deduction and checking succeeds, the template arguments\n  (deduced and/or explicit) are used to synthesize the declaration of a single function template\n  specialization which is added to the candidate functions set to be used in overload resolution. If, &gt;for a given function template, argument deduction fails, no such function is added to the set of &gt;candidate functions for that template.</p>\n</blockquote>\n<p>EDIT. My code is not C++11 compliant (thanks Vaughn Cato and Andy Prowl for explanation). The alternative working code is provided in Andy Prowl's answer.</p>\n<p>P.S. After all I ended up making unscoped enums scoped using namespaces:</p>\n<pre><code>namespace Test_ {\n    enum Test { A,B,C };\n};\nusing Test_::Test;\n\nnamespace Test2_ {\n    enum Test2 { Z,Y,B };\n};\nusing Test2_::Test2;\n</code></pre>\n", "AcceptedAnswerId": "15462180", "Title": "Making scoped enumerations comparable to underlying type", "CreationDate": "2013-03-17T11:37:55.860", "Id": "15460325", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-03-17T16:46:32.273", "LastEditorUserId": "1997715", "LastActivityDate": "2013-03-17T16:46:32.273", "Score": "4", "OwnerUserId": "1997715", "Tags": "<c++><templates><c++11><enums><sfinae>", "AnswerCount": "2"}});