post_cb({"18870549": {"CommentCount": "0", "ViewCount": "198", "CreationDate": "2013-09-18T11:04:37.580", "LastActivityDate": "2014-12-21T10:10:47.903", "Title": "C++11 Multithreading: Display to console", "AcceptedAnswerId": "18870594", "PostTypeId": "1", "Id": "18870549", "Score": "1", "Body": "<p>Consider a function that takes array of 100 data elements does something prints those to console.</p>\n<p>Now say I launch two threads of the function on a multicore machine. Since it's a multicore machine there is good probability that two threads run on two cores. Since both of them need to display data there's a race for console window.</p>\n<p>Now how is the console shared between the threads.?</p>\n<p>The one which reaches the <code>std::cout</code> first gets to display entire data, stalling other thread .?\nor Is the console window time shared between threads.?  if so what determines the amount of time sharing by the threads .?</p>\n", "Tags": "<c++><multithreading><c++11>", "OwnerUserId": "2693266", "AnswerCount": "4"}, "19184084": {"ParentId": "18870549", "CommentCount": "0", "Body": "<p>If you use a function like this:</p>\n<pre><code>void justam(){\n   std::cout &lt;&lt; \"One \" &lt;&lt; \"two \";\n}\n</code></pre>\n<p>and you call it from 2 threads you will get a more or less ordered mix of \"One \" and \"two \". It is like you would write it in 2 separate std::cout calls and while you can be lucky and 1 thread can be scheduled for both outputs, you can also be not so lucky and end up with something like: \"one \" \"one \" \"two \" \"one \". \n    Since the others' answers are covering C++/the standard and since C++ is more or less dependent on the OS and the thread scheduling is the task of the operating system, bellow is a very good short description of how it works:</p>\n<p><a href=\"http://en.wikipedia.org/wiki/Scheduling_%28computing%29\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Scheduling_%28computing%29</a></p>\n<p>Furthermore, please check this article to understand the 3 models of threading if you are really curious what's going on:</p>\n<p><a href=\"http://en.wikipedia.org/wiki/Thread_%28computing%29#Models\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Thread_%28computing%29#Models</a></p>\n<p>These 2 articles will give you an idea of how multithreading stuff works, including output buffer which in the end is an I/O resource and along with the other answers should form a complete picture of what's going on and what to expect.</p>\n", "OwnerUserId": "2845612", "PostTypeId": "2", "Id": "19184084", "Score": "0", "CreationDate": "2013-10-04T14:41:10.390", "LastActivityDate": "2013-10-04T14:41:10.390"}, "18870842": {"ParentId": "18870549", "CommentCount": "4", "Body": "<p>It depends on how you access input/output stream:</p>\n<p>\u00a7 27.2.3 Thread safety [iostreams.threadsafety]</p>\n<blockquote>\n<p id=\"so_18870549_18870842_0\">1 Concurrent access to a <strong>stream object</strong> (27.8, 27.9), stream buffer object (27.6), or C Library stream (27.9.2) <strong>by multiple threads may result in a data race</strong> (1.10) unless otherwise specified (27.4). [ Note: Data racesresult in undefined behavior (1.10). \u2014end note ]</p>\n<p id=\"so_18870549_18870842_1\">2 If one thread makes a library call a that writes a value to a stream and, as a result, another thread reads this value from the stream through a library call b such that this does not result in a data race, then a\u2019s write synchronizes with b\u2019s read.</p>\n</blockquote>\n<p>also \u00a7 27.4.1</p>\n<blockquote>\n<p id=\"so_18870549_18870842_2\">Concurrent access to a synchronized (27.5.3.4) standard iostream object\u2019s formatted and unformatted input (27.7.2.1) and output (27.7.3.1) functions or a standard C stream by multiple threads shall not result in a data race (1.10). [ Note: Users must still synchronize concurrent use of these objects and streams by multiple threads if they wish to avoid interleaved characters. \u2014end note ]</p>\n</blockquote>\n", "OwnerUserId": "951757", "PostTypeId": "2", "Id": "18870842", "Score": "2", "CreationDate": "2013-09-18T11:19:19.990", "LastActivityDate": "2013-09-18T11:19:19.990"}, "27588411": {"ParentId": "18870549", "CommentCount": "0", "Body": "<p>It is usually not recommended to use cout in large programs, people prefer to use a dedicated logging where you can redirect the output where you like.</p>\n<p>As often, Boost is a natural candidate for that, supporting thread safe and non-thread safe loggers, and being <strong>almost</strong> standard.</p>\n<p><a href=\"http://www.boost.org/doc/libs/1_55_0/libs/log/doc/html/log/tutorial/sources.html\" rel=\"nofollow\">http://www.boost.org/doc/libs/1_55_0/libs/log/doc/html/log/tutorial/sources.html</a></p>\n", "OwnerUserId": "2229099", "PostTypeId": "2", "Id": "27588411", "Score": "0", "CreationDate": "2014-12-21T10:10:47.903", "LastActivityDate": "2014-12-21T10:10:47.903"}, "18870594": {"ParentId": "18870549", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>No, <code>cout</code> is not threadsafe in C++11. You have to arrange that yourself. </p>\n<p>[To be accurate, <code>cout</code> itself is threadsafe, but only for the actual duration of the call itself, and a typical line of <code>cout &lt;&lt; x &lt;&lt; y &lt;&lt; endl;</code> will be three different calls to member-function within the <code>cout</code> object. So you don't need mutex protection for the <code>cout</code> functionality itself, but you do need it to guarantee that a \"line\" of calls to <code>cout</code> are performed as one unit]. </p>\n", "OwnerUserId": "1919155", "LastEditorUserId": "1919155", "LastEditDate": "2013-09-18T11:20:48.257", "Id": "18870594", "Score": "5", "CreationDate": "2013-09-18T11:06:51.243", "LastActivityDate": "2013-09-18T11:20:48.257"}, "bq_ids": {"n4140": {"so_18870549_18870842_1": {"section_id": 1908, "quality": 1.0, "length": 26}, "so_18870549_18870842_0": {"section_id": 1907, "quality": 0.6451612903225806, "length": 20}, "so_18870549_18870842_2": {"section_id": 1922, "quality": 0.8157894736842105, "length": 31}}, "n3337": {"so_18870549_18870842_1": {"section_id": 1897, "quality": 1.0, "length": 26}, "so_18870549_18870842_0": {"section_id": 1896, "quality": 0.6451612903225806, "length": 20}, "so_18870549_18870842_2": {"section_id": 1911, "quality": 0.8157894736842105, "length": 31}}, "n4659": {"so_18870549_18870842_1": {"section_id": 2178, "quality": 1.0, "length": 26}, "so_18870549_18870842_0": {"section_id": 2177, "quality": 0.6451612903225806, "length": 20}, "so_18870549_18870842_2": {"section_id": 2193, "quality": 0.8157894736842105, "length": 31}}}});