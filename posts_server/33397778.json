post_cb({"bq_ids": {"n4140": {"so_33397778_33398162_0": {"length": 10, "quality": 1.0, "section_id": 3919}}, "n3337": {"so_33397778_33398162_0": {"length": 10, "quality": 1.0, "section_id": 3779}}, "n4659": {"so_33397778_33398162_0": {"length": 10, "quality": 1.0, "section_id": 4805}}}, "33397778": {"ViewCount": "602", "Body": "<p>I came across an interesting secure coding rule in C++ which states:</p>\n<blockquote>\n<p id=\"so_33397778_33397778_0\">Do not reenter a function during the initialization of a static variable declaration. If a function is reentered during the constant initialization of a static object inside that function, the behavior of the program is undefined. Infinite recursion is not required to trigger undefined behavior, the function need only recur once as part of the initialization.</p>\n</blockquote>\n<p>The non_compliant example of the same is:</p>\n<pre><code>#include &lt;stdexcept&gt;\n\nint fact(int i) noexcept(false) {\n  if (i &lt; 0) {\n    // Negative factorials are undefined.\n    throw std::domain_error(\"i must be &gt;= 0\");\n  }\n\n  static const int cache[] = {\n    fact(0), fact(1), fact(2), fact(3), fact(4), fact(5),\n    fact(6), fact(7), fact(8), fact(9), fact(10), fact(11),\n    fact(12), fact(13), fact(14), fact(15), fact(16)\n  };\n\n  if (i &lt; (sizeof(cache) / sizeof(int))) {\n    return cache[i];\n  }\n\n  return i &gt; 0 ? i * fact(i - 1) : 1;\n}\n</code></pre>\n<p>which according to the source gives the error:</p>\n<pre><code>terminate called after throwing an instance of '__gnu_cxx::recursive_init_error'\n  what():  std::exception\n</code></pre>\n<p>when executed in <a href=\"http://en.wikipedia.org/wiki/Microsoft_Visual_Studio#Visual_Studio_2013\" rel=\"nofollow\">Visual\u00a0Studio\u00a02013</a>. I tried similar code of my own and got the same error (compiled using g++ and executed, on <a href=\"http://en.wikipedia.org/wiki/Ubuntu_%28operating_system%29\" rel=\"nofollow\">Ubuntu</a>).</p>\n<p>I am doubtful if my understanding is correct with respect to this concept as I am not well-versed with C++. According to me, since the cache array is constant, which means it can be read-only and needs to be initialized only once as static, it is getting initialized again and again as the values for this array is the value returned by each of the comma-separated recursive function calls which is against the behavior of the declared array. Thus, it gives undefined behavior which is also stated in the rule.</p>\n<p>What is a better explanation for this?</p>\n", "AcceptedAnswerId": "33397923", "Title": "C++ code with undefined behavior, compiler generates std::exception", "CreationDate": "2015-10-28T17:33:29.993", "Id": "33397778", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-10-28T21:40:27.230", "LastEditorUserId": "63550", "LastActivityDate": "2015-10-28T21:40:27.230", "Score": "14", "OwnerUserId": "1493850", "Tags": "<c++><arrays><static>", "AnswerCount": "2"}, "33397923": {"Id": "33397923", "PostTypeId": "2", "Body": "<p>In order to execute <code>fact()</code>, you need to first statically initialize <code>fact::cache[]</code>. In order to initially <code>fact::cache</code>, you need to execute <code>fact()</code>. There's a circular dependency there, which leads to the behavior you see. <code>cache</code> will only be initialized once, but it requires itself to be initialized in order to initialize itself. Even typing this makes my head spin. </p>\n<p>The right way to introduce a cache table like this is to separate it into a different function:</p>\n<pre><code>int fact(int i) noexcept(false) {\n  if (i &lt; 0) {\n    // Negative factorials are undefined.\n    throw std::domain_error(\"i must be &gt;= 0\");\n  }\n\n  return i &gt; 0 ? i * fact(i - 1) : 1;\n} \n\nint memo_fact(int i) noexcept(false) {\n  static const int cache[] = {\n    fact(0), fact(1), fact(2), fact(3), fact(4), fact(5),\n    fact(6), fact(7), fact(8), fact(9), fact(10), fact(11),\n    fact(12), fact(13), fact(14), fact(15), fact(16)\n  };\n\n  if (i &lt; (sizeof(cache) / sizeof(int))) {\n    return cache[i];\n  }\n  else {\n    return fact(i);\n  }    \n} \n</code></pre>\n<p>Here, <code>memo_fact::cache[]</code> will only be initialized once - but its initialization is no longer dependent on itself. So we have no issue. </p>\n", "LastEditorUserId": "3494013", "LastActivityDate": "2015-10-28T17:41:04.117", "Score": "17", "CreationDate": "2015-10-28T17:40:08.563", "ParentId": "33397778", "CommentCount": "1", "OwnerUserId": "2069064", "LastEditDate": "2015-10-28T17:41:04.117"}, "33398162": {"Id": "33398162", "PostTypeId": "2", "Body": "<p>The C++ standard, \u00a76.7/4, says the following about the initialisation of block-scope variables with static storage duration:</p>\n<blockquote>\n<p id=\"so_33397778_33398162_0\">If control re-enters the declaration recursively while the variable is\n  being initialized, the behavior is undefined.</p>\n</blockquote>\n<p>The following informative example is given:</p>\n<blockquote id=\"so_33397778_33398162_1\">\n<pre><code>int foo(int i) {\nstatic int s = foo(2*i); // recursive call - undefined\nreturn i+1;\n}\n</code></pre>\n</blockquote>\n<p>This applies to your example as well. <code>fact(0)</code> is a recursive call, so the declaration of <code>cache</code> is re-entered. Undefined behaviour is invoked.</p>\n<p>It's important to recall what undefined behaviour means. Undefined behaviour means that <strong>everything</strong> can happen, and \"everything\" quite naturally includes exceptions being thrown.</p>\n<p>Undefined behaviour also means that you can no longer reason about anything else in the code, except when you really want to get down to compiler-implementation details. But then you are no longer talking about C++ in terms of using a programming language but in terms of how to implement that language.</p>\n", "LastActivityDate": "2015-10-28T17:51:02.887", "CommentCount": "1", "CreationDate": "2015-10-28T17:51:02.887", "ParentId": "33397778", "Score": "6", "OwnerUserId": "3313064"}});