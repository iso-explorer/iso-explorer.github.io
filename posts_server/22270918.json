post_cb({"bq_ids": {"n4140": {"so_22270918_22271436_9": {"length": 14, "quality": 1.0, "section_id": 7210}, "so_22270918_22271436_15": {"length": 7, "quality": 0.7777777777777778, "section_id": 6076}, "so_22270918_22271436_10": {"length": 28, "quality": 0.9333333333333333, "section_id": 7210}, "so_22270918_22271436_14": {"length": 5, "quality": 1.0, "section_id": 6076}, "so_22270918_22271436_12": {"length": 5, "quality": 1.0, "section_id": 6076}, "so_22270918_22271436_7": {"length": 14, "quality": 1.0, "section_id": 7210}, "so_22270918_22271436_2": {"length": 35, "quality": 0.9722222222222222, "section_id": 7210}, "so_22270918_22271436_13": {"length": 7, "quality": 0.7777777777777778, "section_id": 6076}, "so_22270918_22271436_1": {"length": 35, "quality": 0.9722222222222222, "section_id": 7210}, "so_22270918_22271436_8": {"length": 28, "quality": 0.9333333333333333, "section_id": 7210}}, "n3337": {"so_22270918_22271436_9": {"length": 11, "quality": 0.7857142857142857, "section_id": 6954}, "so_22270918_22271436_15": {"length": 7, "quality": 0.7777777777777778, "section_id": 5844}, "so_22270918_22271436_14": {"length": 5, "quality": 1.0, "section_id": 5844}, "so_22270918_22271436_12": {"length": 5, "quality": 1.0, "section_id": 5844}, "so_22270918_22271436_7": {"length": 11, "quality": 0.7857142857142857, "section_id": 6954}, "so_22270918_22271436_2": {"length": 35, "quality": 0.9722222222222222, "section_id": 6954}, "so_22270918_22271436_13": {"length": 7, "quality": 0.7777777777777778, "section_id": 5844}, "so_22270918_22271436_1": {"length": 35, "quality": 0.9722222222222222, "section_id": 6954}, "so_22270918_22271436_10": {"length": 27, "quality": 0.9, "section_id": 6954}, "so_22270918_22271436_8": {"length": 27, "quality": 0.9, "section_id": 6954}}, "n4659": {"so_22270918_22271436_9": {"length": 14, "quality": 1.0, "section_id": 8719}, "so_22270918_22271436_15": {"length": 7, "quality": 0.7777777777777778, "section_id": 7572}, "so_22270918_22271436_14": {"length": 5, "quality": 1.0, "section_id": 7572}, "so_22270918_22271436_12": {"length": 5, "quality": 1.0, "section_id": 7572}, "so_22270918_22271436_7": {"length": 14, "quality": 1.0, "section_id": 8719}, "so_22270918_22271436_2": {"length": 35, "quality": 0.9722222222222222, "section_id": 8719}, "so_22270918_22271436_13": {"length": 7, "quality": 0.7777777777777778, "section_id": 7572}, "so_22270918_22271436_1": {"length": 35, "quality": 0.9722222222222222, "section_id": 8719}, "so_22270918_22271436_10": {"length": 28, "quality": 0.9333333333333333, "section_id": 8719}, "so_22270918_22271436_8": {"length": 28, "quality": 0.9333333333333333, "section_id": 8719}}}, "22270958": {"Id": "22270958", "PostTypeId": "2", "Body": "<p>The reason is that you don't know, at least portably, if plain <code>char</code> variables are signed or unsigned. Different implementations have different approaches, a plain <code>char</code> may be signed in one platform and unsigned in another.</p>\n<p>If you want to store negative values in a variable of type <code>char</code>, you absolutely must declare it as <code>signed char</code>, because only then you can be sure that every platform will be able to store negative values in there. Yes, you can use <code>[u]int8</code> type, but this was not always the case (it was only introduced in C++11), and in fact, <code>int8</code> is most likely an alias for <code>signed char</code>.</p>\n<p>Moreover, <code>uint8_t</code> and <code>int8_t</code> are defined to be <em>optional</em> types, meaning you can't always rely on its existence (contrary to <code>signed char</code>). In particular, if a machine has a byte unit with more than 8 bits, it is not very likely that <code>uint8_t</code> and <code>int8_t</code> are defined (although they can; a compiler is always free to provide it and do the appropriate calculations). See this related question: <a href=\"https://stackoverflow.com/questions/8509453/what-is-int8-t-if-a-machine-has-8-bits-per-byte\">What is int8_t if a machine has &gt; 8 bits per byte?</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-03-08T15:19:16.760", "Score": "21", "CreationDate": "2014-03-08T15:04:51.940", "ParentId": "22270918", "CommentCount": "2", "OwnerUserId": "2793118", "LastEditDate": "2017-05-23T11:33:16.553"}, "22271436": {"Id": "22271436", "PostTypeId": "2", "Body": "<p><strong>Is <code>char</code> <em>signed</em> or <em>unsigned</em>?</strong></p>\n<p>Actually it is neither, it's implementation defined if a variable of type <code>char</code> can hold negative values. So if you are looking for a portable way to store negative values in a <em>narrow character type</em> explicitly declare it as <code>signed char</code>.</p>\n<blockquote>\n<p id=\"so_22270918_22271436_0\">\u00a7 3.9.1 - <strong>Fundamental Types</strong> - <code>[basic.fundamental]</code></p>\n<blockquote>\n<p id=\"so_22270918_22271436_2\"><sup>1</sup> Objects declared as characters (<code>char</code>) shall be large enough to store any member of the implementation's basic character set. If a character from this set is stored in a character object, the integral value of that character object is equal to the value of the single character literal form of that character. <strong>It is implementation-defined whether a <code>char</code> object can hold negative values</strong>.</p>\n</blockquote>\n</blockquote>\n<hr>\n<p><strong>I'd like to use the smallest <em>signed integer type</em> available, which one is it?</strong></p>\n<p>c++11 introduced several fixed with integer types, but a common misunderstanding is that these types are guaranteed to be available, something which <strong>isn't</strong> true. </p>\n<blockquote>\n<p id=\"so_22270918_22271436_3\">\u00a7 18.4.1 - <strong>Header <code>&lt;cstdint&gt;</code> synopsis</strong> - <code>[cstdint.syn]</code></p>\n<blockquote>\n<p id=\"so_22270918_22271436_5\"><code>typedef</code><em><code>signed integer type</code></em><code>int8_t; // optional</code></p>\n</blockquote>\n</blockquote>\n<p><sub>To preserve space in this post most of the section has been left out, but the <em>optional</em> rationale applies to all <code>{,u}int{8,16,32,64}_t</code> types. An implementation is <strong>not</strong> required to implement them.</sub></p>\n<hr>\n<p>The standard mandates that <code>int_least8_t</code> is available, but as the name implies this type is only guaranteed to have a width <strong>equal or larger</strong> than 8 bits.</p>\n<p>However, the standard guarantees that even though <code>signed char</code>, <code>char</code>, and <code>unsigned char</code> are three distinct types<sup>[1]</sup> they must occupy the same amount of storage and have the same alignment requirements.</p>\n<p>After inspecting the standard further we will also find that <code>sizeof(char)</code> is <strong>guaranteed</strong> to be <code>1</code><sup>[2]</sup> , which means that this type is guaranteed to occupy the smallest amount of space that a C++ variable can occupy under the given implementation.</p>\n<hr>\n<p><strong>Conclusion</strong></p>\n<p>Remember that <code>unsigned char</code> and <code>signed char</code> must occupy the same amount of storage as a <code>char</code>?</p>\n<p>The smallest <em>signed integer type</em> that is guaranteed to be available is therefore <code>signed char</code>.</p>\n<hr>\n<hr>\n<p><sup>[<strong>note 1</strong>]</sup></p>\n<blockquote>\n<p id=\"so_22270918_22271436_6\">\u00a7 3.9.1 - <strong>Fundamental Types</strong> - <code>[basic.fundamental]</code></p>\n<blockquote>\n<p id=\"so_22270918_22271436_9\"><sup>1</sup> Plain <code>char</code>, <code>signed char</code>, and <code>unsigned char</code> are <strong>three distinct types</strong>, collectively called narrow character types.</p>\n<p id=\"so_22270918_22271436_10\">A <code>char</code>, a <code>signed char</code>, and an <code>unsigned char</code> <strong>occupy the same amount of storage and have the same alignment requirements</strong> (<code>3.11</code>); that is, they have the same object representation. For narrow character types, all bits of the object representation participate in the value representation.</p>\n</blockquote>\n</blockquote>\n<p><sup>[<strong>note 2</strong>]</sup></p>\n<blockquote>\n<p id=\"so_22270918_22271436_11\">\u00a7 5.3.3 - <strong>Sizeof</strong> - <code>[expr.sizeof]</code></p>\n<blockquote>\n<p id=\"so_22270918_22271436_14\"><code>sizeof(char)</code>, <code>sizeof(signed char)</code>, and <code>sizeof(unsigned char)</code> are 1.</p>\n<p id=\"so_22270918_22271436_15\">The result of <code>sizeof</code> applied to any other fundamental type (3.9.1) is implementation-defined.</p>\n</blockquote>\n</blockquote>\n</hr></hr></hr></hr></hr>", "LastEditorUserId": "1090079", "LastActivityDate": "2014-03-08T16:51:11.813", "Score": "10", "CreationDate": "2014-03-08T15:47:36.687", "ParentId": "22270918", "CommentCount": "0", "OwnerUserId": "1090079", "LastEditDate": "2014-03-08T16:51:11.813"}, "22270918": {"ViewCount": "2057", "Body": "<p>In most situations, one would declare a <code>char</code> object to assign one of the character values on the ascii table ranging from 0 - 127. Even the extended character sets range from 128 - 255 (still positive). So i'm assuming that when dealing with the printing of characters, one only needs to use an <code>unsigned char</code>. </p>\n<p>Now, based on some research on SO, people use a <code>signed char</code> when they need to use really small integers, but for that we can utilize the <code>[u]int8</code> type. So i'm having trouble coming to terms with why one would need to use a <code>signed char</code> ? You can use it if you are dealing with the basic character ascii table (which <code>unsigned char</code> is already capable of doing) or you can use it to represent small integers (which <code>[u]int8</code> already takes care of).</p>\n<p>Can someone please provide a programming example in which a <code>signed char</code> is preferred over the other types ?</p>\n", "AcceptedAnswerId": "22270958", "Title": "Under what circumstances would one use a signed char in C++?", "CreationDate": "2014-03-08T15:01:22.117", "Id": "22270918", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-03-08T16:51:11.813", "Score": "23", "OwnerUserId": "3357481", "Tags": "<c++><char>", "AnswerCount": "3"}, "22271010": {"Id": "22271010", "PostTypeId": "2", "Body": "<p>You can use <code>char</code> for arithmetic operations with small integers. <code>unsigned char</code> will give you greater range, while <code>signed char</code> will give you a smaller absolute range and the ability to work with negative numbers. </p>\n<p>There are situations where <code>char</code>'s small size is of importance and is preffered for these operations, <a href=\"http://ideone.com/7sStFn\" rel=\"nofollow\">see here</a>, so when one has negative numbers to deal with, <code>signed char</code> is the way to go.</p>\n", "LastEditorUserId": "2567683", "LastActivityDate": "2014-03-08T15:16:50.203", "Score": "5", "CreationDate": "2014-03-08T15:09:57.757", "ParentId": "22270918", "CommentCount": "6", "OwnerUserId": "2567683", "LastEditDate": "2014-03-08T15:16:50.203"}});