post_cb({"6470094": {"ParentId": "6469954", "CommentCount": "0", "Body": "<p>The user-facing API of the library should be standard; the implementation is not required to be, however.  You're seeing an example of this, where the standard version of a function is replaced with an optimized variant (with a different name because sometimes the replacement is only possible in some circumstances, such as when appropriate alignment can be proven).  This also means that the implementation of one compiler's standard library might not be buildable by a different compiler (which can lead to bootstrapping issues when porting, but that's another issue).</p>\n", "OwnerUserId": "643977", "PostTypeId": "2", "Id": "6470094", "Score": "1", "CreationDate": "2011-06-24T15:29:29.957", "LastActivityDate": "2011-06-24T15:29:29.957"}, "6470124": {"ParentId": "6469954", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The standard places restrictions on the interface of the standard library, not the implementation.  It goes out of its way to make it clear that standard library headers can do things user code can not... <code>__MACRO__NAME__</code> is reserved for the implementation, for instance.  And obviously, only the implementation can actually put all these functions and types into namespace std.</p>\n<p>Mostly, a \"portable\" implementation could be written.  But it would likely be less performant... as an easy example, consider the traditional implementation of the <code>offsetof</code> macro.  It generally involves dereferencing a null pointer, which is formally undefined behavior, but because the implementation knows how its platform works, that's okay.  A portable version can not do this, so it would have to actually create a new instance of the provided type to keep everything on the up and up.</p>\n<p>Quite a few type traits in C++0x likely require compiler support, which makes a \"portable\" implementation somewhere between difficult and impossible.  There's no standard way to analyze if an arbitrary type is POD, for instance, which is why <code>boost::is_pod</code> requires user support via specialization on some platforms.</p>\n<p>There is also the consideration that a lot of the standard library is not header-only.  The other bits can be written in a completely different language... so long as it all links together properly, it doesn't matter.  If the runtime is implemented in Lisp, obviously it won't be C++ compliant code that can be reliably dropped into a different compiler toolchain.</p>\n", "OwnerUserId": "293791", "LastEditorUserId": "293791", "LastEditDate": "2011-06-24T15:54:00.257", "Id": "6470124", "Score": "0", "CreationDate": "2011-06-24T15:32:01.113", "LastActivityDate": "2011-06-24T15:54:00.257"}, "6470072": {"ParentId": "6469954", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The standard library is a detail of implementation. It may not even be 'compiled' in the sense that the standard doesn't require it to consist of 'files' [headers]:</p>\n<blockquote>\n<p id=\"so_6469954_6470072_0\">174) A header is not necessarily a source file, nor are the sequences delimited by &lt; and &gt; in header names necessarily valid\n  source file names (16.2).</p>\n</blockquote>\n<p>The standard carefully eases the requirements on the implementation, so that the library may be 'built-in' to the compiler (a.k.a intrinsics). For example, extending the <code>std</code> namespace, or #defining a name used in the standard library gives you undefined behavior.</p>\n", "OwnerUserId": "277176", "LastEditorUserId": "277176", "LastEditDate": "2011-06-24T15:50:31.467", "Id": "6470072", "Score": "5", "CreationDate": "2011-06-24T15:28:19.697", "LastActivityDate": "2011-06-24T15:50:31.467"}, "6470086": {"ParentId": "6469954", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The Standard library only has to meet a minimum interface. In it's implementation it can do whatever it wants, because, well, it's the implementation, although I'm pretty sure there are some identifier restrictions and such to prevent clashes. </p>\n<p>The Standard library <em>implementation</em> does not have to be portable in any way. They can be, but far from necessarily.</p>\n", "OwnerUserId": "298661", "LastEditorUserId": "298661", "LastEditDate": "2011-06-24T15:29:49.907", "Id": "6470086", "Score": "0", "CreationDate": "2011-06-24T15:29:06.193", "LastActivityDate": "2011-06-24T15:29:49.907"}, "6469954": {"CommentCount": "1", "ViewCount": "198", "CreationDate": "2011-06-24T15:21:32.500", "LastActivityDate": "2011-06-25T17:28:30.397", "Title": "Are standard library required to be standard conformant?", "AcceptedAnswerId": "6470036", "PostTypeId": "1", "Id": "6469954", "Score": "4", "Body": "<p>Are standard library <em>required</em> to be standard conformant? I've this feeling that standard library aren't standard conformant. The basis of this feeling is the error messages generated by the compiler(s). For example, sometime GCC gives error messages which starts with prefix <code>__gxx</code> and many others which I don't remember as of now. But seeing them gives me  feeling that these are very compiler specific messages, and different compilers wouldn't be able to compile standard library provided by GCC, and vice-versa. Is it true?</p>\n<p>The question can be asked in other words as:</p>\n<ul>\n<li>Can standard library provided by one compiler be compiled with other compilers?</li>\n<li>When we say a particular compiler is standard conformant, does it <em>automatically</em> mean that the stdlib which comes with it is also standard-conformant? Or it simply means that this compiler can compile <em>standard-conformant code</em> written by us, programmers?</li>\n<li><strong>Can I use standard library provided by one compiler, in my project which uses a <em>different</em> compiler to compile the project?</strong> Is portability same as standard-conformance?</li>\n</ul>\n<p>These questions are different angles to look at the same <em>big</em> question. So, please help me understanding what does it exactly mean when we say <em>compiler X is standard-conformant</em>.  </p>\n", "Tags": "<c++><gcc><compiler-construction><standards-compliance><standard-library>", "OwnerUserId": "415784", "AnswerCount": "8"}, "6470131": {"ParentId": "6469954", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_6469954_6470131_0\">Can standard library provided by one compiler be compiled with other\n  compilers?</p>\n</blockquote>\n<p>Assuming that the library is standards conforming, yes (I know this is kind of chicken-and-egg).</p>\n<blockquote>\n<p id=\"so_6469954_6470131_1\">When we say a particular compiler is standard conformant, does\n  it automatically mean that the stdlib\n  which comes with it is also\n  standard-conformant? Or it simply\n  means that this compiler can compile\n  standard-conformant code written by\n  us, programmers?</p>\n</blockquote>\n<p>Yes, although I'm not aware of any fully confirming compiler. Note that standards conforming for us as programmers is <em>different</em> from the standard library. For example the implementation is allowed to use identifiers containing <code>__</code> (double underscore).</p>\n<blockquote>\n<p id=\"so_6469954_6470131_2\">Can I use standard library provided by one compiler, in my\n  project which uses a different\n  compiler to compile the project? Is\n  portability same as\n  standard-conformance?</p>\n</blockquote>\n<p>You should be able to <em>compile</em> and use such a library. You almost certainly wouldn't be able to use any compiled library files (static or dynamic) file because name mangling would be different.</p>\n", "OwnerUserId": "251738", "LastEditorUserId": "560648", "LastEditDate": "2011-06-25T17:28:30.397", "Id": "6470131", "Score": "0", "CreationDate": "2011-06-24T15:32:34.423", "LastActivityDate": "2011-06-25T17:28:30.397"}, "6470058": {"ParentId": "6469954", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_6469954_6470058_0\">Are standard library required to be standard conformant? I've this feeling that standard library aren't standard conformant.</p>\n</blockquote>\n<p>By definition, an implementation must conform to the standard to be standard-conformant, yes.</p>\n<p>Otherwise it's not an implementation of the C++ Standard Library, but of some other thing.</p>\n<blockquote>\n<p id=\"so_6469954_6470058_1\">When we say a particular compiler is standard conformant, does it automatically mean that the stdlib which comes with it is also standard-conformant?</p>\n</blockquote>\n<p>This would depend on the wording, wouldn't it? If the <em>toolchain</em> purports to include an implementation of the Standard Library, one may reasonably assume that it's compliant. That the compiler executable itself is compliant is not the same thing, unless the library implementation is built into the compiler executable.</p>\n<p>But this is all just wordplay.</p>\n<blockquote>\n<p id=\"so_6469954_6470058_2\">Can I use standard library provided by one compiler, in my project which uses a different compiler to compile the project? Is portability same as standard-conformance?</p>\n</blockquote>\n<p>Of course not. Two conformant implementations may be completely incompatible with each other.</p>\n<blockquote>\n<p id=\"so_6469954_6470058_3\">For example, sometime GCC gives error messages which starts with prefix <code>__gxx</code> and many others which I don't remember as of now.</p>\n</blockquote>\n<p>That's fine. The toolchain may <em>implement</em> the library however it chooses, as long as the <em>interface</em> conforms to the standard. The standard does not say that the implementation cannot use a symbol <code>__gxx</code> in its work.</p>\n<hr>\n<h3>BTW</h3>\n<p>Though, it <em>does</em> say that the programmer may not use symbols with leading underscores, in some cases!</p>\n<p>You aren't allowed <sup>(<code>[lib.requirements]</code>/<code>[requirements]</code>)</sup> to use any name which:</p>\n<ol>\n<li>contains two consecutive underscores,</li>\n<li>begins with an underscore followed by an uppercase letter</li>\n<li>begins with an underscore and is in the global namespace </li>\n</ol>\n<p>Also, in C++0x, literal suffixes that do not start with an underscore are reserved.</p>\n</hr>", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2011-06-25T17:27:27.463", "Id": "6470058", "Score": "3", "CreationDate": "2011-06-24T15:27:08.017", "LastActivityDate": "2011-06-25T17:27:27.463"}, "6470096": {"ParentId": "6469954", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_6469954_6470096_0\">what does it exactly mean when we say compiler X is standard-conformant</p>\n</blockquote>\n<p>It means that the compiler provides the standard library with all the requirements layed upon by the standard and that the implementation itself conformes to all requirements in the standard. The thing is, the \"requirements\" for the standard library are quite liberal after the general interface.</p>\n", "OwnerUserId": "500104", "PostTypeId": "2", "Id": "6470096", "Score": "1", "CreationDate": "2011-06-24T15:29:37.773", "LastActivityDate": "2011-06-24T15:29:37.773"}, "bq_ids": {"n4140": {"so_6469954_6470072_0": {"section_id": 6256, "quality": 0.875, "length": 14}}, "n3337": {"so_6469954_6470072_0": {"section_id": 6016, "quality": 0.875, "length": 14}}, "n4659": {"so_6469954_6470072_0": {"section_id": 7760, "quality": 0.875, "length": 14}}}, "6470036": {"ParentId": "6469954", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, standard libraries must adhere to the standard, but there is quite a bit of flexibility in that. The standard does not require a particular implementation of the functions, and the implementation is free to add internal functions, attributes... as long as the requirements are met.</p>\n<p>Note that there is a different concept of the library conforming with the standard and the library being implemented using <em>only</em> standard features.</p>\n<p>On the particular questions below: </p>\n<blockquote>\n<p id=\"so_6469954_6470036_0\">Can standard library provided by one compiler be compiled with other compilers?</p>\n</blockquote>\n<p>Some will, some won't. The <em>implementation</em> of the standard library can use compiler intrinsics for some operations, of features present only in one platform and not others... Some STL implementations can be compiled with different compilers though, like STLPort, Dinkumware (which is also the one shipped in VS, with some VS modifications)</p>\n<blockquote>\n<p id=\"so_6469954_6470036_1\">When we say a particular compiler is standard conformant, does it automatically mean that the stdlib which comes with it is also standard-conformant? Or it simply means that this compiler can compile standard-conformant code written by us, programmers?</p>\n</blockquote>\n<p>It means that the library must be conformant, but again, the standard does not mandate the implementation of the library, and these can use non-standard extensions and the like, which will work in one compiler but possibly not in other compilers. Consider, for example, an implementation of <code>shared_ptr</code>, the reference count has to be updated atomically but there was no atomic operations on integers in the current standard, so it has to be implemented in terms of non-standard features.</p>\n<blockquote>\n<p id=\"so_6469954_6470036_2\">Can I use standard library provided by one compiler, in my project which uses a different compiler to compile the project? Is portability same as standard-conformance?</p>\n</blockquote>\n<p>Not necessarily.</p>\n", "OwnerUserId": "36565", "LastEditorUserId": "36565", "LastEditDate": "2011-06-24T15:31:35.220", "Id": "6470036", "Score": "4", "CreationDate": "2011-06-24T15:25:31.480", "LastActivityDate": "2011-06-24T15:31:35.220"}});