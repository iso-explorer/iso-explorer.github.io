post_cb({"22115996": {"CommentCount": "5", "ViewCount": "1916", "LastActivityDate": "2014-03-01T15:46:54.090", "Body": "<p>I need to include the header of a C library into my C++11 code. Now, the header provides routines and data structures that involve plenty of <code>double complex</code> all over the place. E.g.,</p>\n<pre><code>#include &lt;complex.h&gt;\n//..\ntypedef struct parameters\n{\n    // ...\n    double complex Vud;\n} parameters;\n// ...\ndouble complex polylog(int n, int m, double x);\n</code></pre>\n<p>I bring this file into my C++11 source wrapped in <code>extern \"C\" { #include \"include.h\" }</code> (that's the actual filename, believe it or not). And g++ (tried 4.7.3 and 4.8.2) and clang (3.3) go nuts if I have -std=c++11 added.</p>\n<p>The millions of lines of g++ errors include plenty of:</p>\n<pre><code>include/g++-v4/cmath:98:3: error: template with C linkage\n</code></pre>\n<p>And clang gives:</p>\n<pre><code>cmath:84:3: error: declaration conflicts with target of using declaration already in scope\n  abs(double __x)\n  ^\n/usr/include/stdlib.h:773:12: note: target of using declaration\nextern int abs (int __x) __THROW __attribute__ ((__const__)) __wur;\n           ^\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.7.3/include/g++-v4/cstdlib:245:14: note: using declaration\n  using std::abs;\n             ^\n</code></pre>\n<p>I am not sure how to get around this. What is the correct way to do this? Clearly these must be inter-operable, but I do not know the trick.</p>\n", "PostTypeId": "1", "AcceptedAnswerId": "22116498", "FavoriteCount": "1", "Title": "Complex type with C linkage in C++11", "Id": "22115996", "Score": "3", "CreationDate": "2014-03-01T15:03:45.427", "Tags": "<c++><c><c++11><complex-numbers><complextype>", "OwnerUserId": "3368482", "AnswerCount": "1"}, "22116498": {"ParentId": "22115996", "CommentCount": "3", "Body": "<p>In 100% standard C++, you just plain cannot include standard headers in an <code>extern \"C\"</code> block. You would need to modify your <code>include.h</code> header to be C++-friendly, by first including its required headers outside of <code>extern \"C\"</code>, and declaring its own names inside an <code>extern \"C\"</code> block.</p>\n<blockquote>\n<p id=\"so_22115996_22116498_0\"><strong>17.6.2.2 Headers [using.headers]</strong></p>\n<p id=\"so_22115996_22116498_1\">[...]</p>\n<p id=\"so_22115996_22116498_2\">3 A translation unit shall include a header only outside of any external declaration or definition, and shall include the header lexically before the first reference in that translation unit to any of the entities declared in that header.</p>\n</blockquote>\n<p>Doing</p>\n<pre><code>extern \"C\" {\n#include &lt;complex.h&gt;\n}\n</code></pre>\n<p>is invalid, because the header is then included inside of a declaration. This applies even if it's another header that only indirectly includes <code>&lt;complex.h&gt;</code>.</p>\n<p>What may work on common implementations, as a workaround if modifying <code>include.h</code> is impractical, is to first manually include all the headers that <code>include.h</code> would include itself. Assuming those headers use the appropriate guards to make a second inclusion a no-op, the fact that <code>include.h</code> includes them will then not cause any errors.</p>\n", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "22116498", "Score": "6", "CreationDate": "2014-03-01T15:46:54.090", "LastActivityDate": "2014-03-01T15:46:54.090"}, "bq_ids": {"n4140": {"so_22115996_22116498_2": {"section_id": 6270, "quality": 1.0, "length": 19}}, "n3337": {"so_22115996_22116498_2": {"section_id": 6030, "quality": 1.0, "length": 19}}, "n4659": {"so_22115996_22116498_2": {"section_id": 7776, "quality": 0.9473684210526315, "length": 18}}}});