post_cb({"47113740": {"ParentId": "47113457", "LastEditDate": "2017-11-04T18:07:38.137", "CommentCount": "3", "CreationDate": "2017-11-04T17:53:40.773", "OwnerUserId": "7703564", "LastEditorUserId": "7703564", "PostTypeId": "2", "Id": "47113740", "Score": "2", "Body": "<p>The standard doesn't state in its specification (\u00a725.4.1.1 [alg.sort]) that <code>std::sort</code> actually is guaranteed to call <code>swap</code>, it only mentions that the type must fulfill certain concepts which I wouldn't interpret as a guarantee:</p>\n<blockquote>\n<p id=\"so_47113457_47113740_0\">Requires:\n  RandomAccessIterator\n  shall satisfy the requirements of\n  ValueSwappable\n  (17.6.3.2). The\n  type of\n  *first\n  shall satisfy the requirements of\n  MoveConstructible\n  (Table 20) and of\n  MoveAssignable\n  (Table 22).</p>\n</blockquote>\n<p>It therefore rather just <i>may</i> call it, depending on the implementation. <a href=\"https://stackoverflow.com/questions/8219525/does-stl-sort-use-swap-or-binary-copy\">This answer</a> may also provide some information on that.</p>\n", "LastActivityDate": "2017-11-04T18:07:38.137"}, "bq_ids": {"n4140": {"so_47113457_47113740_0": {"section_id": 1401, "quality": 0.6666666666666666, "length": 10}}, "n3337": {"so_47113457_47113740_0": {"section_id": 1395, "quality": 0.6666666666666666, "length": 10}}, "n4659": {"so_47113457_47113740_0": {"section_id": 1518, "quality": 0.6666666666666666, "length": 10}}}, "47113457": {"CommentCount": "9", "ViewCount": "92", "PostTypeId": "1", "LastEditorUserId": "5538150", "CreationDate": "2017-11-04T17:25:48.483", "LastActivityDate": "2017-11-04T18:37:14.467", "Title": "Ignoring overload of swap function", "LastEditDate": "2017-11-04T18:37:14.467", "Id": "47113457", "Score": "4", "Body": "<p>I overloaded swap function for my class as in <a href=\"https://stackoverflow.com/a/2684544/5538150\">this answer</a>, but while sorting (<code>std::sort</code>) compiler is still using <code>std::swap</code>. I don't see any difference between my approach and the one stated in linked answer. Here's reproduction of my code:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iterator&gt;\n#include &lt;algorithm&gt;\n#include &lt;iostream&gt;\n\nstruct B\n{\nstruct A\n{\n    friend void swap(A &amp; a, A &amp; b)\n    {\n        std::swap(a.a, b.a);\n        std::cout &lt;&lt; \"my swap\\n\";   \n    }\n\n    A(int _a) : a(_a) {}\n    bool operator&lt;(const A &amp; other) { return a &lt; other.a; }\n    int a;\n};\n};\n\nint main()\n{\n    std::vector&lt;B::A&gt; v{1, 2, 3, 5, 4};\n    std::sort(std::begin(v), std::end(v));\n}\n</code></pre>\n<p>Also executable example provided <a href=\"https://wandbox.org/permlink/KZ5Aclm2TDA76oPB\" rel=\"nofollow noreferrer\">here</a>.</p>\n", "Tags": "<c++><stl>", "OwnerUserId": "5538150", "AnswerCount": "1"}});