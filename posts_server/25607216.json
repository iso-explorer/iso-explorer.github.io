post_cb({"25608472": {"ParentId": "25607216", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_25607216_25608472_0\">Can anyone tell me, why it is advantageous to use this idiom?</p>\n</blockquote>\n<p>The reason I can think of: because it is explicit. Consider how you would (instinctively) read this code (i.e., whithout knowing what <code>features</code> does):</p>\n<pre><code>bool priority = features(w)[5];\n</code></pre>\n<p>\"Features returns an indexable sequence of some generic \"boolean\" values; we read the fifth one into <code>priority</code>\".</p>\n<pre><code>auto priority = static_cast&lt;bool&gt;(features(w)[5]);\n</code></pre>\n<p>\"Features returns an indexable sequence of values explicitly convertible to <code>bool</code>; we read the fifth one into <code>priority</code>\".</p>\n<p>This code is not written to optimize for shortest flexible code, but for explicitness of the result (and apparently consistency - since I assume it would not be the only variable declared with auto).</p>\n<p>The use of auto in the declaration of <code>priority</code> is for keeping the code flexible to whatever expression is on the right-hand-side.</p>\n<p>That said, I would prefer the version without an explicit cast.</p>\n", "OwnerUserId": "186997", "LastEditorUserId": "186997", "LastEditDate": "2014-09-01T17:59:45.547", "Id": "25608472", "Score": "3", "CreationDate": "2014-09-01T14:54:11.360", "LastActivityDate": "2014-09-01T17:59:45.547"}, "25609753": {"ParentId": "25607216", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Following the C++ Standard:</p>\n<blockquote>\n<h3><strong>\u00a7 8.5 Initializers <code>[dcl.init]</code></strong></h3>\n<ol start=\"15\">\n<li><p id=\"so_25607216_25609753_0\">The initialization that occurs in the form</p>\n<pre><code>T x = a;\n</code></pre>\n<p id=\"so_25607216_25609753_1\">as well as in argument passing, function return, throwing an exception (15.1), handling an exception (15.3), and aggregate member initialization (8.5.1) is called <em>copy-initialization</em>.</p></li>\n</ol>\n</blockquote>\n<p>I can think of the example given in the book:</p>\n<pre><code>auto x = features(w)[5];\n</code></pre>\n<p>as the one that represents any form of <em>copy-initialization</em> with auto / template type (<em>deduced type</em> in general), just like:</p>\n<pre><code>template &lt;typename A&gt;\nvoid foo(A x) {}\n\nfoo(features(w)[5]);\n</code></pre>\n<p>as well as:</p>\n<pre><code>auto bar()\n{\n    return features(w)[5];\n}\n</code></pre>\n<p>as well as:</p>\n<pre><code>auto lambda = [] (auto x) {};\nlambda(features(w)[5]);\n</code></pre>\n<p>So the point is, we cannot always just <em>\"move type T from <code>static_cast&lt;T&gt;</code> to the left-hand side of assignment\"</em>.</p>\n<p>Instead, in any of the above examples we need to explicitly specify the desired type rather than allowing compiler deduce one on its own, if the latter can lead to <em>undefined behavior</em>:</p>\n<p>Respectively to my examples that would be:</p>\n<pre><code>/*1*/ foo(static_cast&lt;bool&gt;(features(w)[5]));\n\n/*2*/ return static_cast&lt;bool&gt;(features(w)[5]);\n\n/*3*/ lambda(static_cast&lt;bool&gt;(features(w)[5]));\n</code></pre>\n<p>As such, using <code>static_cast&lt;T&gt;</code> is an elegant way of forcing a desired type, which alternatively can be expressed by explicit contructor call:</p>\n<pre><code>foo(bool{features(w)[5]});\n</code></pre>\n<hr>\n<p>To summarize, I don't think the book says:</p>\n<blockquote>\n<p id=\"so_25607216_25609753_2\">Whenever you want to force the type of a variable, use <code>auto x = static_cast&lt;T&gt;(y);</code> instead of <code>T x{y};</code>.</p>\n</blockquote>\n<p>To me it sounds more like a word of warning:</p>\n<blockquote>\n<p id=\"so_25607216_25609753_3\">The type inference with <code>auto</code> is cool, but may end up with undefined behavior if used unwisely.</p>\n</blockquote>\n<p>And as a solution for the scenarios <em>involving type deduction</em>, the following is proposed:</p>\n<blockquote>\n<p id=\"so_25607216_25609753_4\">If the compiler's regular type-deduction mechanism is not what you want, use <code>static_cast&lt;T&gt;(y)</code>.</p>\n</blockquote>\n<hr>\n<p><strong>UPDATE</strong></p>\n<p>And answering your updated question, <em>which of the below initializations should one prefer</em>:</p>\n<pre><code>bool priority = features(w)[5];\n\nauto priority = static_cast&lt;bool&gt;(features(w)[5]);\n\nauto priority = bool(features(w)[5]);\n\nauto priority = bool{features(w)[5]};\n</code></pre>\n<p><strong>Scenario 1</strong></p>\n<p>First, imagine the <code>std::vector&lt;bool&gt;::reference</code> is <strong>not implicitly</strong> convertible to <code>bool</code>:</p>\n<pre><code>struct BoolReference\n{\n    explicit operator bool() { /*...*/ }\n};\n</code></pre>\n<p>Now, the <code>bool priority = features(w)[5];</code> will <strong>not compile</strong>, as it is not an explicit boolean context. The others will work fine (as long as the <code>operator bool()</code> is accessible).</p>\n<p><strong>Scenario 2</strong></p>\n<p>Secondly, let's assume the <code>std::vector&lt;bool&gt;::reference</code> is implemented in an <em>old fashion</em>, and although the <em>conversion operator</em> is not <code>explicit</code>, it returns <code>int</code> instead:</p>\n<pre><code>struct BoolReference\n{\n    operator int() { /*...*/ }\n};\n</code></pre>\n<p>The change in signature <strong>turns off</strong> the <code>auto priority = bool{features(w)[5]};</code> initialization, as using <code>{}</code> prevents the <em>narrowing</em> (which converting an <code>int</code> to <code>bool</code> is).</p>\n<p><strong>Scenario 3</strong></p>\n<p>Thirdly, what if we were talking not about <code>bool</code> at all, but about some <em>user-defined</em> type, that, to our surprise, declares <code>explicit</code> constructor:</p>\n<pre><code>struct MyBool\n{\n    explicit MyBool(bool b) {}\n};\n</code></pre>\n<p>Surprisingly, once again the <code>MyBool priority = features(w)[5];</code> initialization will <strong>not compile</strong>, as the copy-initialization syntax requires non-explicit constructor. Others will work though.</p>\n<p><strong>Personal attitude</strong></p>\n<p>If I were to choose one initialization from the listed four candidates, I would go with:</p>\n<pre><code>auto priority = bool{features(w)[5]};\n</code></pre>\n<p>because it introduces an explicit boolean context (which is fine in case we want to assign this value to boolean variable) and prevents narrowing (in case of other types, not-easily-convertible-to-bool), so that when an error/warning is triggered, we can diagnose what <code>features(w)[5]</code> <strong>really is</strong>.</p>\n<hr>\n<p><strong>UPDATE 2</strong></p>\n<p>I have recently watched Herb Sutter's speech from <em>CppCon 2014</em> titled <a href=\"https://www.youtube.com/watch?v=xnqTKD8uD64\" rel=\"noreferrer\"><em>Back to the Basics! Essentials of Modern C++ Style</em></a>, where he presents some points on why should one prefer the <em>explicit type initializer</em> of <code>auto x = T{y};</code> form (though it is not the same as with <code>auto x = static_cast&lt;T&gt;(y)</code>, so not all arguments apply) over <code>T x{y};</code>, which are:</p>\n<ol>\n<li><p><code>auto</code> variables must always be initialized. That is, you can't write <code>auto a;</code>, just like you can write error-prone <code>int a;</code></p></li>\n<li><p>The <em>modern C++</em> style prefers the type on the right side, just like in:</p>\n<p>a) Literals:</p>\n<pre><code>auto f = 3.14f;\n//           ^ float\n</code></pre>\n<p>b) User-defined literals:</p>\n<pre><code>auto s = \"foo\"s;\n//            ^ std::string\n</code></pre>\n<p>c) Function declarations:</p>\n<pre><code>auto func(double) -&gt; int;\n</code></pre>\n<p>d) Named lambdas:</p>\n<pre><code>auto func = [=] (double) {};\n</code></pre>\n<p>e) Aliases:</p>\n<pre><code>using dict = set&lt;string&gt;;\n</code></pre>\n<p>f) Template aliases:</p>\n<pre><code>template &lt;class T&gt;\nusing myvec = vector&lt;T, myalloc&gt;;\n</code></pre>\n<p><strong>so as such</strong>, adding one more:</p>\n<pre><code>auto x = T{y};\n</code></pre>\n<p>is consistent with the style where we have name on the left side, and type with initializer on the right side, what can be briefly described as:</p>\n<pre><code>&lt;category&gt; name = &lt;type&gt; &lt;initializer&gt;;\n</code></pre></li>\n<li><p>With copy-elision and non-explicit copy/move constructors it has <em>zero-cost</em> compared to <code>T x{y}</code> syntax.</p></li>\n<li><p>It is more explicit when there are subtle differences between the types:</p>\n<pre><code> unique_ptr&lt;Base&gt; p = make_unique&lt;Derived&gt;(); // subtle difference\n\n auto p = unique_ptr&lt;Base&gt;{make_unique&lt;Derived&gt;()}; // explicit and clear\n</code></pre></li>\n<li><p><code>{}</code> guarantees no implicit conversions and no narrowing.</p></li>\n</ol>\n<p>But he also mentions some drawbacks of the <code>auto x = T{}</code> form in general, which has already been described in this post:</p>\n<ol>\n<li><p>Even though the compiler can elide the right-hand side's temporary, it requires an accessible, non-deleted and non-explicit copy-constructor:</p>\n<pre><code> auto x = std::atomic&lt;int&gt;{}; // fails to compile, copy constructor deleted\n</code></pre></li>\n<li><p>If the elision is not enabled (e.g. <code>-fno-elide-constructors</code>), then moving non-movable types results in expensive copy:</p>\n<pre><code> auto a = std::array&lt;int,50&gt;{};\n</code></pre></li>\n</ol>\n</hr></hr></hr>", "OwnerUserId": "3953764", "LastEditorUserId": "3953764", "LastEditDate": "2014-10-06T14:48:20.503", "Id": "25609753", "Score": "21", "CreationDate": "2014-09-01T16:18:48.720", "LastActivityDate": "2014-10-06T14:48:20.503"}, "25608844": {"ParentId": "25607216", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Context from the book:</p>\n<blockquote>\n<p id=\"so_25607216_25608844_0\">Though <code>std::vector&lt;bool&gt;</code> conceptually holds <code>bool</code>s, <code>operator[]</code> for <code>std::vector&lt;bool&gt;</code> doesn\u2019t return a reference to an element of the container (which is what <code>std::vector::operator[]</code> returns  for every type except <code>bool</code>). Instead, it returns an object of type <code>std::vector&lt;bool&gt;::reference</code> (a class nested inside <code>std::vector&lt;bool&gt;</code>).</p>\n</blockquote>\n<p>There is no advantage, it is more error prevention, when you using auto with external library.</p>\n<p>I think, this is the main idea of such idiom. You should be explicit and force auto to behave correctly.</p>\n<p>BTW, here the nice article on <a href=\"http://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/\" rel=\"nofollow\">GotW</a> about auto.</p>\n", "OwnerUserId": "350527", "LastEditorUserId": "68587", "LastEditDate": "2014-09-01T23:25:08.687", "Id": "25608844", "Score": "8", "CreationDate": "2014-09-01T15:15:38.660", "LastActivityDate": "2014-09-01T23:25:08.687"}, "25607216": {"CommentCount": "8", "AcceptedAnswerId": "25609753", "PostTypeId": "1", "LastEditorUserId": "2489745", "CreationDate": "2014-09-01T13:45:21.677", "LastActivityDate": "2014-10-06T14:48:20.503", "LastEditDate": "2014-09-01T17:26:11.107", "ViewCount": "1915", "FavoriteCount": "4", "Title": "Why should I prefer the \"explicitly typed initializer\" idiom over explicitly giving the type", "Id": "25607216", "Score": "40", "Body": "<p>I've recently bought the new Effective modern C++ from Scott Meyers and reading through it now. But I encounter one thing, that totally bugs me.</p>\n<p>In item 5 Scott is telling, that using <code>auto</code> is a great thing. It saves typing, gives you in most cases the correct type and it might be immune to type mismatches. I totally understand this and think of <code>auto</code> as a good thing too.</p>\n<p>But then in item 6 Scott is telling, that every coin has two sides. And likewise there might be cases, when <code>auto</code> deduces a totally wrong type, e.g. for proxy objects.</p>\n<p>You may already know this example:</p>\n<pre><code>class Widget;\nstd::vector&lt;bool&gt; features(Widget w);\n\nWidget w;\n\nbool priority = features(w)[5]; // this is fine\n\nauto priority = features(w)[5]; // this result in priority being a proxy\n                                // to a temporary object, which will result\n                                // in undefined behavior on usage after that\n                                // line\n</code></pre>\n<p>So far, so good.</p>\n<p>But Scott's solution to this, is the so called \"explicitly typed initializer idiom\". The idea is, to use static_cast on the initializer like this:</p>\n<pre><code>auto priority = static_cast&lt;bool&gt;(features(w)[5]);\n</code></pre>\n<p>But this is not only leading to more typing, but you also explicitly state the type, which should be deduced. You basically lost both advantages of <code>auto</code> over an explicit given type.</p>\n<p>Can anyone tell me, why it is advantageous to use this idiom?</p>\n<hr>\n<p>First to clear things up, my questions aims to why I should write:</p>\n<pre><code>auto priority = static_cast&lt;bool&gt;(features(w)[5]);\n</code></pre>\n<p>instead of:</p>\n<pre><code>bool priority = features(w)[5];\n</code></pre>\n<p>@Sergey brought up a link to a nice article on <a href=\"http://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/\">GotW</a> about this topic, which partly answers my question. </p>\n<blockquote>\n<p id=\"so_25607216_25607216_0\">Guideline: Consider declaring local variables auto x = type{ expr }; when you do want to explicitly commit to a type. It is self-documenting to show that the code is explicitly requesting a conversion, it guarantees the variable will be initialized, and it won\u2019t allow an accidental implicit narrowing conversion. Only when you do want explicit narrowing, use ( ) instead of { }.</p>\n</blockquote>\n<p>Which basically brings me to a related question. Which of these <em>four</em> alternatives should I choose?</p>\n<pre><code>bool priority = features(w)[5];\n\nauto priority = static_cast&lt;bool&gt;(features(w)[5]);\n\nauto priority = bool(features(w)[5]);\n\nauto priority = bool{features(w)[5]};\n</code></pre>\n<p>Number one is still my favorite. It's less typing and as explicit as the three other ones. </p>\n<p>The point about the guaranteed initialization don't really hold, as I'm anyways declaring variables not before I can initialize them somehow. And the other argument about the narrowing didn't worked out well in an quick test (see <a href=\"http://ideone.com/GXvIIr\">http://ideone.com/GXvIIr</a>).</p>\n</hr>", "Tags": "<c++><c++11><effective-c++>", "OwnerUserId": "2489745", "AnswerCount": "4"}, "25608277": {"ParentId": "25607216", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I don't have the book in front of me, so I can't tell if there's more context.</p>\n<p>But to answer your question, no, using <code>auto</code>+<code>static_cast</code> in this particular example is not a good solution.  It violates another guideline (one for which I've never seen any exceptions justified):</p>\n<ul>\n<li><strong>Use the weakest cast/conversion possible.</strong></li>\n</ul>\n<p>Unnecessarily strong casts subvert the type system and prevent the compiler from generating diagnostic messages in case a change occurs elsewhere in the program that affects the conversion in an incompatible way.  (action at a distance, the boogey-man of maintenance programming)</p>\n<p>Here the <code>static_cast</code> is unnecessarily strong.  An implicit conversion will do just fine.  So avoid the cast.</p>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2014-09-01T15:53:11.550", "Id": "25608277", "Score": "15", "CreationDate": "2014-09-01T14:43:22.897", "LastActivityDate": "2014-09-01T15:53:11.550"}, "bq_ids": {"n4140": {"so_25607216_25609753_1": {"section_id": 3294, "quality": 0.7647058823529411, "length": 13}}, "n3337": {"so_25607216_25609753_1": {"section_id": 3164, "quality": 0.7647058823529411, "length": 13}}, "n4659": {"so_25607216_25609753_1": {"section_id": 4056, "quality": 0.7647058823529411, "length": 13}}}});