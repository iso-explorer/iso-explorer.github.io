post_cb({"27575756": {"ParentId": "27573012", "PostTypeId": "2", "CommentCount": "5", "Body": "<p><strong>Don't do that</strong>.\nYes, of course you <em>can</em> do that, but should you? IHMO, it makes your code less readable, since everybody knows what <code>std::unique_ptr&lt;&gt;</code> is, but nobody knows what <code>uptr&lt;&gt;</code> is, except for whoever wrote that strange code ...</p>\n<p>Well maintainable code is easily readable, uses names for types and values that express their purpose and intent, and hence needs only minimal comments (avoid comments, because they are hard to maintain). With your shorter <code>uptr&lt;&gt;</code>, you're leaving this path of wisdom ...</p>\n<hr>\n<p>Of course, you can use more descriptive names, such as <code>unique_pointer</code> (suggested in the comments) and use typedefs to implement that via <code>std::unique_ptr</code> or, if that is not available, <code>boost::unique_ptr</code> (though if you don't have <code>std::unique_ptr</code> I would have thought you don't have move semantics either and hence the whole point of <code>unique_pointer</code> is lost). But that will <strong>not help</strong> you <em>cutting down on typing</em>.</p>\n</hr>", "OwnerUserId": "1023390", "LastEditorUserId": "1023390", "LastEditDate": "2014-12-22T09:02:51.603", "Id": "27575756", "Score": "-2", "CreationDate": "2014-12-20T00:22:18.603", "LastActivityDate": "2014-12-22T09:02:51.603"}, "27573012": {"CommentCount": "0", "AcceptedAnswerId": "27573166", "PostTypeId": "1", "LastEditorUserId": "3561240", "CreationDate": "2014-12-19T19:52:50.880", "LastActivityDate": "2014-12-22T09:02:51.603", "LastEditDate": "2014-12-19T20:25:42.023", "ViewCount": "393", "FavoriteCount": "3", "Title": "Are there any gotchas or limitations when template aliasing shared_ptr and unique_ptr?", "Id": "27573012", "Score": "4", "Body": "<p>For the simple reason of cutting down on typing something like:</p>\n<pre><code>std::shared_ptr&lt;...&gt;;\nstd::unique_ptr&lt;...&gt;;\n</code></pre>\n<p>every time I want to use smart pointers, I thought about using template aliases:</p>\n<pre><code>template &lt;typename T&gt; using sptr = std::shared_ptr&lt;T&gt;;\ntemplate &lt;typename T&gt; using uptr = std::unique_ptr&lt;T&gt;;\n</code></pre>\n<p>So I could use them like:</p>\n<pre><code>sptr&lt;...&gt;;\nuptr&lt;...&gt;;\n</code></pre>\n<p>Assuming I guard them in my own namespace, are there any gotchas or limitations in using a template alias with shared/unique_ptr this way? Will I ever be unable to do something I can do with the direct template syntax that I can't with the alias? Is this a bad idea for other reasons?</p>\n", "Tags": "<c++><c++11><smart-pointers><using-directives>", "OwnerUserId": "1004211", "AnswerCount": "4"}, "27575596": {"ParentId": "27573012", "CommentCount": "0", "Body": "<p>The answer has been given already and in your case, it will be the same, but template aliasing may sometimes really introduce new names, here an example</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;typename T&gt; class A {};\ntemplate &lt;typename T&gt; using B = A&lt;T&gt;;\n\ntemplate &lt; template &lt;typename T&gt; class S&gt; class C {};\n\nstatic_assert( std::is_same&lt; A&lt;int&gt;, B&lt;int&gt; &gt;::value, \"same :)\"); // they are the same\nstatic_assert( std::is_same&lt; C&lt;A&gt;, C&lt;B&gt; &gt;::value, \"not the same :(\"); // error, not the same\n</code></pre>\n<p>Here, even if <code>A</code> and <code>B</code> are the same, <code>C&lt;A&gt;</code> and <code>C&lt;B&gt;</code> are different.</p>\n", "OwnerUserId": "2694444", "PostTypeId": "2", "Id": "27575596", "Score": "1", "CreationDate": "2014-12-19T23:59:16.153", "LastActivityDate": "2014-12-19T23:59:16.153"}, "27579748": {"ParentId": "27573012", "CommentCount": "0", "Body": "<p>For a <code>std::shared_ptr&lt;T</code>, there will be never any issue with giving it a different name via</p>\n<pre><code>template &lt;typename T&gt;\nusing sptr = std::shared_ptr&lt;T&gt;;\n</code></pre>\n<p>as the names are by definition equivalent.</p>\n<p>Unique pointers are a different thing, because you ignore a template argument. Hence, you only ever get the default template arguments for your <code>uptr</code>, which limits the use cases of <code>uptr</code> over <code>unique_ptr</code>.</p>\n<p>Consider this little piece of code:</p>\n<pre><code>std::unique_ptr&lt;FILE, void (*)(FILE*)&gt; file(fopen(\"myfile.txt\", \"r\"), [](FILE* f)\n                                                                      {\n                                                                         fclose(f);\n                                                                      });\n// use file here to perform input operations\n// automatic call to fclose at the end of scope (or any scope exit)\n</code></pre>\n<p>Here, the default type of the deleter (i.e. <code>std::default_delete&lt;T&gt;</code>) was replaced to correctly close the <code>FILE*</code>. This is important, because the <code>FILE*</code> wasn't <code>new</code>ed. This is also applicable for any C interface, where you need to <code>free</code> instead of <code>delete</code>, because the default deleter <code>delete</code>s, which is a different thing than <code>free</code>ing.</p>\n<p>Your <code>uptr&lt;T&gt;</code> cannot support that, because it's a <code>template &lt;typename T&gt; using uptr&lt;T&gt; = ...</code> rather than a <code>template &lt;typename T, typename D = std::default_deleter&lt;T&gt;&gt; using uptr&lt;T, D&gt; = ...</code>.</p>\n<p>If you are never interested in having a different deleter, there is no harm in renaming <code>unique_ptr</code> to <code>uptr</code>, as the types are exactly the same.</p>\n", "OwnerUserId": "985296", "PostTypeId": "2", "Id": "27579748", "Score": "0", "CreationDate": "2014-12-20T11:29:31.400", "LastActivityDate": "2014-12-20T11:29:31.400"}, "bq_ids": {"n4140": {"so_27573012_27573166_0": {"section_id": 5407, "quality": 1.0, "length": 37}, "so_27573012_27573166_1": {"section_id": 5408, "quality": 0.967741935483871, "length": 30}}, "n3337": {"so_27573012_27573166_0": {"section_id": 5202, "quality": 1.0, "length": 37}, "so_27573012_27573166_1": {"section_id": 5203, "quality": 0.967741935483871, "length": 30}}, "n4659": {"so_27573012_27573166_0": {"section_id": 6829, "quality": 1.0, "length": 37}, "so_27573012_27573166_1": {"section_id": 6830, "quality": 0.9032258064516129, "length": 28}}}, "27573166": {"ParentId": "27573012", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This is fine, and will have no unforseen consequences on your code.</p>\n<p>In your example, <code>std::unique_ptr&lt;T&gt;</code> and <code>std::shared_ptr&lt;T&gt;</code> will be the same as <code>uptr&lt;T&gt;</code> and <code>sptr&lt;T&gt;</code>. You can even verify this with a static assertion:</p>\n<pre><code>static_assert(std::is_same&lt;std::shared_ptr&lt;T&gt;, sptr&lt;T&gt;&gt;::value, \"\");\n</code></pre>\n<p><em>Using an alias declaration is considered to be the exact same type.</em> Not just \"similar\", but exactly the same. And that is what makes it ok to go ahead with this without worrying about any consequences later on.</p>\n<p>The only thing that your alias declaration will limit in the future is your ability to pass other parameters to the smart pointers other than the type, e.g. <code>std::unique_ptr</code> can accept a deleter. You could modify your using declaration to include a fuller definition with an optional deleter parameter if you'd like, though I would expect most people will never use this feature.</p>\n<p>On another note, one other thing to keep in mind with this is the question of who else will be reading your code? <code>std::shared_ptr</code> is clear and obvious what it is, however <code>sptr</code> is less clear. Or rather, maybe not \"less clear\", but that it needs to be understood. It adds a speed bump to someone sitting down to take a look at your code as they will need to internally translate <code>uptr</code> and <code>sptr</code> to <code>unique_ptr</code> and <code>shared_ptr</code>.</p>\n<p>Quoting the standard (7.1.3)</p>\n<blockquote>\n<p id=\"so_27573012_27573166_0\">A name declared with the typedef specifier becomes a typedef-name.\n  Within the scope of its declaration, a typedef-name is syntactically\n  equivalent to a keyword and names the type associated with the\n  identifier in the way described in Clause 8. <strong>A typedef-name is thus a\n  synonym for another type. A typedef-name does not introduce a new type\n  the way a class declaration (9.1) or enum declaration does</strong>.</p>\n<p id=\"so_27573012_27573166_1\"><strong>A typedef-name can also be introduced by an alias-declaration. The\n  identifier following the using keyword becomes a typedef-name and the\n  optional attribute-specifier-seq following the identifier appertains\n  to that typedef-name.</strong> It has the same semantics as if it were\n  introduced by the typedef specifier. In particular, it does not define\n  a new type and it shall not appear in the type-id.</p>\n</blockquote>\n", "OwnerUserId": "3561240", "LastEditorUserId": "3561240", "LastEditDate": "2014-12-19T20:12:24.010", "Id": "27573166", "Score": "4", "CreationDate": "2014-12-19T20:05:15.490", "LastActivityDate": "2014-12-19T20:12:24.010"}});