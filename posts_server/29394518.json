post_cb({"29394518": {"ViewCount": "3977", "Body": "<p>This is awkward, but the bitwise AND operator is defined in the C++ standard as follows (emphasis mine).</p>\n<blockquote>\n<p id=\"so_29394518_29394518_0\">The usual arithmetic conversions are performed; <strong>the result is the bitwise AND function of its operands</strong>. The operator applies only to integral or unscoped enumeration operands.</p>\n</blockquote>\n<p>This looks kind of meaningless to me. The \"bitwise AND function\" is not defined anywhere in the standard, as far as I can see.</p>\n<p>I get that the AND function is well-understood and thus may not require explanation. The meaning of the word \"bitwise\" should also be rather clear: the function is applied to corresponding bits of its operands. However, what constitute the bits of the operands is not clear.</p>\n<p>What gives?</p>\n", "AcceptedAnswerId": "29394804", "Title": "What's the result of a & b?", "CreationDate": "2015-04-01T15:13:35.963", "Id": "29394518", "CommentCount": "9", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2015-04-01T22:43:04.557", "LastEditorUserId": "950427", "LastActivityDate": "2015-12-08T15:43:37.690", "Score": "34", "OwnerUserId": "46642", "Tags": "<c++><language-lawyer><bitwise-operators>", "AnswerCount": "4"}, "29394804": {"Id": "29394804", "PostTypeId": "2", "Body": "<p>This is underspecified. The issue of what the standard means when it refers to bit-wise operations is the subject of a few defect reports.</p>\n<p>For example <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1857\" rel=\"nofollow noreferrer\">defect report 1857:  Additional questions about bits</a>:</p>\n<blockquote>\n<p id=\"so_29394518_29394804_0\">The specification of the bitwise operations in 5.11 [expr.bit.and],\n  5.12 [expr.xor], and 5.13 [expr.or] uses the undefined term \u201cbitwise\u201d in describing the operations, without specifying whether it is the\n  value or object representation that is in view.</p>\n<p id=\"so_29394518_29394804_1\">Part of the resolution of this might be to define \u201cbit\u201d (which is\n  otherwise currently undefined in C++) as a value of a given power of\n  2.</p>\n</blockquote>\n<p>and the response was:</p>\n<blockquote>\n<p id=\"so_29394518_29394804_2\">CWG decided to reformulate the description of the operations\n  themselves to avoid references to bits, splitting off the larger\n  questions of defining \u201cbit\u201d and the like to issue 1943 for further\n  consideration.</p>\n</blockquote>\n<p>and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1943\" rel=\"nofollow noreferrer\">defect report 1943</a> says:</p>\n<blockquote>\n<p id=\"so_29394518_29394804_3\">CWG decided at the 2014-06 (Rapperswil) meeting to address only a\n  limited subset of the questions raised by issues 1857 and 1861. This\n  issue is a placeholder for the remaining questions, such as defining a\n  \u201cbit\u201d in terms of a value of 2<sup>n</sup>, specifying whether a bit-field has a\n  sign bit, etc.</p>\n</blockquote>\n<p>We can see from this <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1796\" rel=\"nofollow noreferrer\">defect report 1796: Is all-bits-zero for null characters a meaningful requirement?</a>, that this issue of what the standard means when it refers to bits affected/affects other sections as well:</p>\n<blockquote>\n<p id=\"so_29394518_29394804_4\">According to 2.3 [lex.charset] paragraph 3,</p>\n<blockquote>\n<p id=\"so_29394518_29394804_8\">The basic execution character set and the basic execution wide-character set shall each contain all the members of the basic\n    source character set, plus control characters representing alert,\n    backspace, and carriage return, plus a null character (respectively,\n    null wide character), whose representation has all zero bits. </p>\n</blockquote>\n<p id=\"so_29394518_29394804_6\">It is not clear that a portable program can examine the bits of the\n  representation; instead, it would appear to be limited to examining\n  the bits of the numbers corresponding to the value representation\n  (3.9.1 [basic.fundamental] paragraph 1). It might be more appropriate\n  to require that the null character value compare equal to 0 or '\\0'\n  rather than specifying the bit pattern of the representation.</p>\n<p id=\"so_29394518_29394804_7\">There is a similar issue for the definition of shift, bitwise and, and\n  bitwise or operators: are those specifications constraints on the bit\n  pattern of the representation or on the values resulting from the\n  interpretation of those patterns as numbers?</p>\n</blockquote>\n<p>In this case the resolution was to change:</p>\n<blockquote>\n<p id=\"so_29394518_29394804_9\">representation has all zero bits</p>\n</blockquote>\n<p>to:</p>\n<blockquote>\n<p id=\"so_29394518_29394804_10\">value is 0.</p>\n</blockquote>\n<p>Note that <a href=\"https://stackoverflow.com/a/29394674/1708801\">as mentioned in ecatmur's answer</a> the draft C++ standard does defer to C standard section <code>5.2.4.2.1</code> in section <code>3.9.1</code> <em>[basic.fundamental]</em> in paragraph <code>3</code> it does not refer to section <code>6.5/4</code> from the C standard which would at least tell us that the results are implementation defined. I explain in my comment below that C++ standard can only incorporate text from normative references explicitly. </p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-06T15:10:35.433", "Score": "39", "CreationDate": "2015-04-01T15:25:42.050", "ParentId": "29394518", "CommentCount": "6", "LastEditDate": "2017-05-23T12:10:36.177", "OwnerUserId": "1708801"}, "29394559": {"Id": "29394559", "PostTypeId": "2", "Body": "<p>Legally, we could consider all bitwise operations to have undefined behaviour as they are not actually defined.</p>\n<p>More reasonably, we are expected to apply common sense and refer to the common meanings of these operations, applying them to the <em>bits</em> of the operands (hence the term \"bitwise\").</p>\n<p>But nothing actually states that. Shame my answer can't be considered normative wording.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2015-04-01T15:23:24.657", "Score": "2", "CreationDate": "2015-04-01T15:14:53.607", "ParentId": "29394518", "CommentCount": "4", "LastEditDate": "2015-04-01T15:23:24.657", "OwnerUserId": "560648"}, "bq_ids": {"n4140": {"so_29394518_29394804_5": {"length": 36, "quality": 0.972972972972973, "section_id": 5316}, "so_29394518_29394804_8": {"length": 36, "quality": 0.972972972972973, "section_id": 5316}, "so_29394518_29394518_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 6162}, "so_29394518_29394720_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 7216}, "so_29394518_29394804_9": {"length": 4, "quality": 1.0, "section_id": 5316}, "so_29394518_29394720_0": {"length": 9, "quality": 0.75, "section_id": 7216}}, "n3337": {"so_29394518_29394804_5": {"length": 36, "quality": 0.972972972972973, "section_id": 5113}, "so_29394518_29394804_8": {"length": 36, "quality": 0.972972972972973, "section_id": 5113}, "so_29394518_29394518_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 5923}, "so_29394518_29394720_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 6960}, "so_29394518_29394804_9": {"length": 4, "quality": 1.0, "section_id": 5113}, "so_29394518_29394720_0": {"length": 9, "quality": 0.75, "section_id": 6960}}, "n4659": {"so_29394518_29394720_0": {"length": 9, "quality": 0.75, "section_id": 8725}, "so_29394518_29394804_5": {"length": 24, "quality": 0.6486486486486487, "section_id": 6740}, "so_29394518_29394804_8": {"length": 24, "quality": 0.6486486486486487, "section_id": 6740}, "so_29394518_29394720_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 8725}, "so_29394518_29394518_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 7659}}}, "29394674": {"Id": "29394674", "PostTypeId": "2", "Body": "<p><strong>[basic.fundamental]</strong>/3 defers to C  5.2.4.2.1. It seems reasonable that the bitwise operators in C++ being underspecified should similarly defer to C, in this case 6.5.10/4:</p>\n<blockquote>\n<p id=\"so_29394518_29394674_0\">The result of the binary &amp; operator is the bitwise AND of the operands (that is, each bit in\n  the result is set if and only if each of the corresponding bits in the converted operands is\n  set).</p>\n</blockquote>\n<p>Note that C 6.5/4 has:</p>\n<blockquote>\n<p id=\"so_29394518_29394674_1\">Some operators (the unary operator <code>~</code>, and the binary operators <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&amp;</code>, <code>^</code>, and <code>|</code>,\n  collectively described as <em>bitwise operators</em>) are required to have operands that have\n  integer type. These operators yield values that depend on the internal representations of\n  integers, and have implementation-defined and undefined aspects for signed types.</p>\n</blockquote>\n<p>The internal representations of the integers are of course described in 6.2.6.2/1, /2.</p>\n", "LastActivityDate": "2015-04-01T15:19:54.383", "CommentCount": "4", "CreationDate": "2015-04-01T15:19:54.383", "ParentId": "29394518", "Score": "9", "OwnerUserId": "567292"}, "29394720": {"Id": "29394720", "PostTypeId": "2", "Body": "<p>C++ Standard defines <em>storage</em> as a certain amount of bits. The implementation might decide what meaning to attribute to a particular bit; that being said, binary AND is supposed to work on conceptual 0s and 1s forming a particular type's representation.</p>\n<blockquote>\n<p id=\"so_29394518_29394720_0\"><strong>3.9.1.7.</strong> (...) The representations of integral types shall define values by use of a pure binary numeration system.<sup>49</sup> (...)</p>\n<p id=\"so_29394518_29394720_1\"><strong>3.9.1, footnote 49)</strong>  A positional representation for integers that uses the binary digits 0 and 1, in which the values represented by successive\n  bits are additive, begin with 1, and are multiplied by successive integral power of 2, except perhaps for the bit with the highest\n  position</p>\n</blockquote>\n<p>That means that for whatever physical representation used, binary AND acts according to the truth table for the AND function (for each bit number i, take bits A<sub>i</sub> and B<sub>i</sub> from appropriate operands and produce a value of 1 only if both are 1, otherwise produce a 0 for the bit R<sub>i</sub>).. Resulting value is left to interpret by the implementation, but whatever is chosen, it has to be in line with other expectations with regard to other binary operations like OR and XOR.</p>\n", "LastEditorUserId": "752976", "LastActivityDate": "2015-04-01T15:30:43.333", "Score": "6", "CreationDate": "2015-04-01T15:21:48.713", "ParentId": "29394518", "CommentCount": "0", "LastEditDate": "2015-04-01T15:30:43.333", "OwnerUserId": "752976"}});