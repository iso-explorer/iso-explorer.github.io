post_cb({"31464666": {"CommentCount": "2", "ViewCount": "452", "PostTypeId": "1", "LastEditorUserId": "1033581", "CreationDate": "2015-07-16T21:15:43.253", "LastActivityDate": "2017-04-05T14:36:25.203", "Title": "Why variadic template constructor matches better than copy constructor?", "AcceptedAnswerId": "31465009", "LastEditDate": "2017-04-05T14:36:25.203", "Id": "31464666", "Score": "6", "Body": "<p>The following code does not compile:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\nstruct Foo\n{\n    Foo() { std::cout &lt;&lt; \"Foo()\" &lt;&lt; std::endl; }\n    Foo(int) { std::cout &lt;&lt; \"Foo(int)\" &lt;&lt; std::endl; }\n};\n\ntemplate &lt;typename T&gt;\nstruct Bar\n{\n    Foo foo;\n\n    Bar(const Bar&amp;) { std::cout &lt;&lt; \"Bar(const Bar&amp;)\" &lt;&lt; std::endl; }\n\n    template &lt;typename... Args&gt;\n    Bar(Args&amp;&amp;... args) : foo(std::forward&lt;Args&gt;(args)...)\n    {\n        std::cout &lt;&lt; \"Bar(Args&amp;&amp;... args)\" &lt;&lt; std::endl;\n    }\n};\n\nint main()\n{\n    Bar&lt;Foo&gt; bar1{};\n    Bar&lt;Foo&gt; bar2{bar1};\n}\n</code></pre>\n<p>Compiler error suggest to me that compiler was trying to use variadic template constructor instead of copy constructor:</p>\n<pre><code>prog.cpp: In instantiation of 'Bar&lt;T&gt;::Bar(Args&amp;&amp; ...) [with Args = {Bar&lt;Foo&gt;&amp;}; T = Foo]':\nprog.cpp:27:20:   required from here\nprog.cpp:18:55: error: no matching function for call to 'Foo::Foo(Bar&lt;Foo&gt;&amp;)'\n  Bar(Args&amp;&amp;... args) : foo(std::forward&lt;Args&gt;(args)...)\n</code></pre>\n<p>Why compiler does that and how to fix it?</p>\n", "Tags": "<c++><templates><c++11><variadic-templates><overload-resolution>", "OwnerUserId": "1256847", "AnswerCount": "3"}, "31465009": {"ParentId": "31464666", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This call:</p>\n<pre><code>Bar&lt;Foo&gt; bar2{bar1};\n</code></pre>\n<p>has two candidates in its overload set:</p>\n<pre><code>Bar(const Bar&amp;);\nBar(Bar&amp;);       // Args... = {Bar&amp;}\n</code></pre>\n<p>One of the ways to determine if one conversion sequence is better than the other is, from [over.ics.rank]:</p>\n<blockquote>\n<p id=\"so_31464666_31465009_0\">Standard conversion sequence S1 is a better conversion sequence than standard conversion sequence\n  S2 if  </p>\n<p id=\"so_31464666_31465009_1\">\u2014 [...]<br>\n  \u2014 S1 and S2 are reference bindings (8.5.3), and the types to which the references refer are the same\n  type except for top-level <em>cv</em>-qualifiers, and the type to which the reference initialized by S2 refers\n  is more <em>cv</em>-qualified than the type to which the reference initialized by S1 refers. <em>[ Example:</em></br></p>\n<pre><code>int f(const int &amp;);\nint f(int &amp;);\nint g(const int &amp;);\nint g(int);\n\nint i;\nint j = f(i);    // calls f(int &amp;)\nint k = g(i);    // ambiguous\n</code></pre>\n<p id=\"so_31464666_31465009_2\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p>The forwarding reference variadic constructor is a better match because its reference binding (<code>Bar&amp;</code>) is less <em>cv</em>-qualified than the copy constructor's reference binding (<code>const Bar&amp;</code>).</p>\n<p>As far as solutions, you could simply exclude from the candidate set anytime <code>Args...</code> is something that you should call the copy or move constructor with SFINAE:</p>\n<pre><code>template &lt;typename... &gt; struct typelist;\n\ntemplate &lt;typename... Args,\n          typename = std::enable_if_t&lt;\n              !std::is_same&lt;typelist&lt;Bar&gt;,\n                            typelist&lt;std::decay_t&lt;Args&gt;...&gt;&gt;::value\n          &gt;&gt;\nBar(Args&amp;&amp;... args)\n</code></pre>\n<p>If <code>Args...</code> is one of <code>Bar</code>, <code>Bar&amp;</code>, <code>Bar&amp;&amp;</code>, <code>const Bar&amp;</code>, then <code>typelist&lt;decay_t&lt;Args&gt;...&gt;</code> will be <code>typelist&lt;Bar&gt;</code> - and that's a case we want to exclude. Any other set of <code>Args...</code> will be allowed just fine. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-07-16T22:05:27.130", "Id": "31465009", "Score": "8", "CreationDate": "2015-07-16T21:40:27.140", "LastActivityDate": "2015-07-16T22:05:27.130"}, "31464753": {"ParentId": "31464666", "CommentCount": "0", "Body": "<p>While I agree that it's counter-intuitive, the reason is that your copy constructor takes a <code>const Bar&amp;</code> but <code>bar1</code> is not const.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/2622b4871d6407da\">http://coliru.stacked-crooked.com/a/2622b4871d6407da</a></p>\n<p>Since the universal reference can bind anything it is chosen over the more restrictive constructor with the const requirement.</p>\n", "OwnerUserId": "1738399", "PostTypeId": "2", "Id": "31464753", "Score": "6", "CreationDate": "2015-07-16T21:20:58.750", "LastActivityDate": "2015-07-16T21:20:58.750"}, "bq_ids": {"n4140": {"so_31464666_31465009_1": {"section_id": 639, "quality": 0.9130434782608695, "length": 21}, "so_31464666_31465009_0": {"section_id": 603, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_31464666_31465009_1": {"section_id": 629, "quality": 0.9130434782608695, "length": 21}, "so_31464666_31465009_0": {"section_id": 593, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_31464666_31465009_1": {"section_id": 667, "quality": 0.9130434782608695, "length": 21}, "so_31464666_31465009_0": {"section_id": 629, "quality": 0.8888888888888888, "length": 8}}}, "43001985": {"ParentId": "31464666", "CommentCount": "0", "Body": "<p>Another way to avoid the variadic constructor being selected is to supply all forms of the <code>Bar</code> constructor.</p>\n<p>It's a little more work, but avoids the complexity of enable_if, if that's important to you:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\nstruct Foo\n{\n    Foo() { std::cout &lt;&lt; \"Foo()\" &lt;&lt; std::endl; }\n    Foo(int) { std::cout &lt;&lt; \"Foo(int)\" &lt;&lt; std::endl; }\n};\n\ntemplate &lt;typename T&gt;\nstruct Bar\n{\n    Foo foo;\n\n    Bar(const Bar&amp;) { std::cout &lt;&lt; \"Bar(const Bar&amp;)\" &lt;&lt; std::endl; }\n    Bar(Bar&amp;) { std::cout &lt;&lt; \"Bar(Bar&amp;)\" &lt;&lt; std::endl; }\n    Bar(Bar&amp;&amp;) { std::cout &lt;&lt; \"Bar(Bar&amp;&amp;)\" &lt;&lt; std::endl; }\n\n    template &lt;typename... Args&gt;\n    Bar(Args&amp;&amp;... args) : foo(std::forward&lt;Args&gt;(args)...)\n    {\n        std::cout &lt;&lt; \"Bar(Args&amp;&amp;... args)\" &lt;&lt; std::endl;\n    }\n};\n\nint main()\n{\n    Bar&lt;Foo&gt; bar1{};\n    Bar&lt;Foo&gt; bar2{bar1};\n}\n</code></pre>\n", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "43001985", "Score": "0", "CreationDate": "2017-03-24T14:23:20.667", "LastActivityDate": "2017-03-24T14:23:20.667"}});