post_cb({"38597778": {"ParentId": "38597274", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>First off, as touched on in several other answers but not, to my mind, spelled out clearly enough: It <em>does</em> work to provide an integer in <em>most</em> contexts where a library function takes a <code>double</code> or <code>float</code> argument.  The compiler will automatically insert a conversion.  For instance, <code>sqrt(0)</code> is well-defined and will behave exactly as <code>sqrt((double)0)</code>, and the same is true for any other integer-type expression used there.</p>\n<p><code>printf</code> is different.  It's different because it takes a variable number of arguments.  Its function prototype is</p>\n<pre><code>extern int printf(const char *fmt, ...);\n</code></pre>\n<p>Therefore, when you write</p>\n<pre><code>printf(message, 0);\n</code></pre>\n<p>the compiler does not have any information about what type <code>printf</code> <em>expects</em> that second argument to be.  It has only the type of the argument expression, which is <code>int</code>, to go by.  Therefore, unlike most library functions, it is on you, the programmer, to make sure the argument list matches the expectations of the format string.</p>\n<p>(Modern compilers <em>can</em> look into a format string and tell you that you've got a type mismatch, but they're not going to start inserting conversions to accomplish what you meant, because better your code should break now, when you'll notice, than years later when rebuilt with a less helpful compiler.)</p>\n<p>Now, the other half of the question was: Given that (int)0 and (float)0.0 are, on most modern systems, both represented as 32 bits all of which are zero, why doesn't it work anyway, by accident?  The C standard just says \"this isn't required to work, you're on your own\", but let me spell out the two most common reasons why it wouldn't work; that will probably help you understand <em>why</em> it's not required.</p>\n<p>First, for historical reasons, when you pass a <code>float</code> through a variable argument list it gets <em>promoted</em> to <code>double</code>, which, on most modern systems, is <em>64</em> bits wide.  So <code>printf(\"%f\", 0)</code> passes only 32 zero bits to a callee expecting 64 of them.</p>\n<p>The second, equally significant reason is that floating-point function arguments may be passed in a different <em>place</em> than integer arguments.  For instance, most CPUs have separate register files for integers and floating-point values, so it might be a rule that arguments 0 through 4 go in registers r0 through r4 if they are integers, but f0 through f4 if they are floating-point.  So <code>printf(\"%f\", 0)</code> looks in register f1 for that zero, but it's not there at all.</p>\n", "OwnerUserId": "388520", "LastEditorUserId": "388520", "LastEditDate": "2016-07-26T19:20:42.860", "Id": "38597778", "Score": "57", "CreationDate": "2016-07-26T18:53:46.793", "LastActivityDate": "2016-07-26T19:20:42.860"}, "38597340": {"ParentId": "38597274", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_38597274_38597340_0\">Why does using an integer literal instead of a float literal cause this behavior?</p>\n</blockquote>\n<p>Because <code>printf()</code> doesn't have typed parameters besides the <code>const char* formatstring</code> as the 1st one. It uses a c-style ellipsis (<code>...</code>) for all the rest. </p>\n<p>It's just decides how to interpret the values passed there according to the formatting types given in the format string.</p>\n<p>You would have the same kind of undefined behavior as when trying</p>\n<pre><code> int i = 0;\n const double* pf = (const double*)(&amp;i);\n printf(\"%f\\n\",*pf); // dereferencing the pointer is UB\n</code></pre>\n", "OwnerUserId": "1413395", "LastEditorUserId": "1413395", "LastEditDate": "2016-07-26T19:09:04.983", "Id": "38597340", "Score": "14", "CreationDate": "2016-07-26T18:27:13.927", "LastActivityDate": "2016-07-26T19:09:04.983"}, "38617737": {"ParentId": "38597274", "CommentCount": "0", "Body": "<p>This is one of those great opportunities to learn from your compiler warnings.</p>\n<pre><code>$ gcc -Wall -Wextra -pedantic fnord.c \nfnord.c: In function \u2018main\u2019:\nfnord.c:8:2: warning: format \u2018%f\u2019 expects argument of type \u2018double\u2019, but argument 2 has type \u2018int\u2019 [-Wformat=]\n  printf(\"%f\\n\",0);\n  ^\n</code></pre>\n<p>or</p>\n<pre><code>$ clang -Weverything -pedantic fnord.c \nfnord.c:8:16: warning: format specifies type 'double' but the argument has type 'int' [-Wformat]\n        printf(\"%f\\n\",0);\n                ~~    ^\n                %d\n1 warning generated.\n</code></pre>\n<p>So, <code>printf</code> is producing undefined behavior because you are passing it an incompatible type of argument.</p>\n", "OwnerUserId": "3942165", "PostTypeId": "2", "Id": "38617737", "Score": "9", "CreationDate": "2016-07-27T15:46:38.473", "LastActivityDate": "2016-07-27T15:46:38.473"}, "38598781": {"ParentId": "38597274", "CommentCount": "0", "Body": "<p><code>\"%f\\n\"</code> guarantees predictable result only when the second <code>printf()</code> parameter has type of <code>double</code>. Next, an extra arguments of variadic functions are subject of default argument promotion. Integer arguments fall under integer promotion, which never results in floating-point typed values. And <code>float</code> parameters are promoted to <code>double</code>.</p>\n<p>To top it off: standard allows the second argument to be or <code>float</code> or <code>double</code> and nothing else.</p>\n", "OwnerUserId": "2878070", "PostTypeId": "2", "Id": "38598781", "Score": "4", "CreationDate": "2016-07-26T19:53:56.230", "LastActivityDate": "2016-07-26T19:53:56.230"}, "bq_ids": {"n4140": {"so_38597274_38597324_0": {"section_id": 7043, "quality": 0.625, "length": 5}}, "n3337": {"so_38597274_38597324_0": {"section_id": 6788, "quality": 0.625, "length": 5}}, "n4659": {"so_38597274_38597324_0": {"section_id": 7612, "quality": 0.625, "length": 5}}}, "38597827": {"ParentId": "38597274", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Using a mis-matched <code>printf()</code> specifier <code>\"%f\"</code>and type <code>(int) 0</code> leads to undefined behavior.</p>\n<blockquote>\n<p id=\"so_38597274_38597827_0\">If a conversion specification is invalid, the behavior is undefined. C11dr \u00a77.21.6.1 9</p>\n</blockquote>\n<p>Candidate causes of UB.</p>\n<ol>\n<li><p>It is UB per spec and the compile is ornery - 'nuf said.</p></li>\n<li><p><code>double</code> and <code>int</code> are of different sizes.  </p></li>\n<li><p><code>double</code> and <code>int</code> may pass their values using different stacks  (general vs. <a href=\"https://en.wikipedia.org/wiki/Floating-point_unit\">FPU</a> stack.)</p></li>\n<li><p>A <code>double 0.0</code> <em>might</em> not be defined by an all zero bit pattern. (rare)</p></li>\n</ol>\n", "OwnerUserId": "2410359", "LastEditorUserId": "1257035", "LastEditDate": "2016-07-26T20:27:12.823", "Id": "38597827", "Score": "11", "CreationDate": "2016-07-26T18:56:41.983", "LastActivityDate": "2016-07-26T20:27:12.823"}, "38606192": {"ParentId": "38597274", "CommentCount": "0", "Body": "<p>Why it is formally UB has now been discussed in several answers.</p>\n<p>The reason why you get specifically this behaviour is platform-dependent, but probably is the following:</p>\n<ul>\n<li><code>printf</code> expects its arguments according to standard vararg propagation. That means a <code>float</code> will be a <code>double</code> and anything smaller than an <code>int</code> will be an <code>int</code>.</li>\n<li>You are passing an <code>int</code> where the function expects a <code>double</code>. Your <code>int</code> is probably 32 bit, your <code>double</code> 64 bit. That means that the four stack bytes starting at the place where the argument is supposed to sit are <code>0</code>, but the following four bytes have arbitrary content. That's what is used for constructing the value which is displayed.</li>\n</ul>\n", "OwnerUserId": "296974", "PostTypeId": "2", "Id": "38606192", "Score": "4", "CreationDate": "2016-07-27T07:14:33.210", "LastActivityDate": "2016-07-27T07:14:33.210"}, "38597358": {"ParentId": "38597274", "CommentCount": "2", "Body": "<p>Ordinarily when you call a function that expects a <code>double</code>, but you provide an <code>int</code>, the compiler will automatically convert to a <code>double</code> for you. That doesn't happen with <code>printf</code>, because the types of the arguments aren't specified in the function prototype - the compiler doesn't know that a conversion should be applied.</p>\n", "OwnerUserId": "5987", "PostTypeId": "2", "Id": "38597358", "Score": "13", "CreationDate": "2016-07-26T18:28:08.663", "LastActivityDate": "2016-07-26T18:28:08.663"}, "38597274": {"CommentCount": "25", "AcceptedAnswerId": "38597324", "PostTypeId": "1", "LastEditorUserId": "908939", "CreationDate": "2016-07-26T18:23:10.583", "LastActivityDate": "2016-08-03T18:50:18.227", "LastEditDate": "2016-07-27T07:01:59.620", "ViewCount": "6229", "FavoriteCount": "10", "Title": "Why does printf(\"%f\",0); give undefined behavior?", "Id": "38597274", "Score": "85", "Body": "<p>The statement <code>printf(\"%f\\n\",0.0f);</code> prints 0.<br>\nHowever, the statement <code>printf(\"%f\\n\",0);</code> prints random values.  </br></p>\n<p>I realize I'm exhibiting some kind of undefined behaviour, but I can't figure out why specifically.  </p>\n<p>A floating point value in which all the bits are 0 is still a valid <code>float</code> with value of 0.<br>\n<code>float</code> and <code>int</code> are the same size on my machine (if that is even relevant).  </br></p>\n<p>Why does using an integer literal instead of a floating point literal in <code>printf</code> cause this behavior?</p>\n", "Tags": "<c++><c><printf><implicit-conversion><undefined-behavior>", "OwnerUserId": "908939", "AnswerCount": "10"}, "38597315": {"ParentId": "38597274", "CommentCount": "20", "Body": "<p>I'm not sure what's confusing.</p>\n<p>Your format string expects a <code>double</code>; you provide instead an <code>int</code>.</p>\n<p>Whether the two types have the same bit width is utterly irrelevant, except that it may help you avoid getting hard memory violation exceptions from broken code like this.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "38597315", "Score": "8", "CreationDate": "2016-07-26T18:25:58.310", "LastActivityDate": "2016-07-26T18:25:58.310"}, "38597324": {"ParentId": "38597274", "PostTypeId": "2", "CommentCount": "15", "Body": "<p>The <code>\"%f\"</code> format requires an argument of type <code>double</code>. You're giving it an argument of type <code>int</code>. That's why the behavior is undefined.</p>\n<p>The standard does not guarantee that all-bits-zero is a valid representation of <code>0.0</code> (though it often is), or of any <code>double</code> value, or that <code>int</code> and <code>double</code> are the same size (remember it's <code>double</code>, not <code>float</code>), or, even if they are the same size, that they're passed as arguments to a variadic function in the same way.</p>\n<p>It might happen to \"work\" on your system. That's the worst possible symptom of undefined behavior, because it makes it difficult to diagnose the error.</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\">N1570</a> 7.21.6.1 paragraph 9:</p>\n<blockquote>\n<p id=\"so_38597274_38597324_0\">... If any argument is not the correct type for the corresponding\n  conversion specification, the behavior is undefined.</p>\n</blockquote>\n<p>Arguments of type <code>float</code> are promoted to <code>double</code>, which is why <code>printf(\"%f\\n\",0.0f)</code> works. Arguments of integer types narrower than <code>int</code> are promoted to <code>int</code> or to <code>unsigned int</code>. These promotion rules (specified by N1570 6.5.2.2 paragraph 6) do not help in the case of <code>printf(\"%f\\n\", 0)</code>.</p>\n", "OwnerUserId": "827263", "LastEditorUserId": "827263", "LastEditDate": "2016-07-26T23:55:03.197", "Id": "38597324", "Score": "118", "CreationDate": "2016-07-26T18:26:17.020", "LastActivityDate": "2016-07-26T23:55:03.197"}, "38741563": {"ParentId": "38597274", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The main cause of this \"undetermined value\" issue stands in the cast of the pointer at the <code>int</code> value passed to the <code>printf</code> variable parameters section to a pointer at <code>double</code> types that <code>va_arg</code> macro carries out. </p>\n<p>This causes a referencing to a memory area that was not completely initialized with value passed as parameter to the printf, because <code>double</code> size memory buffer area is greater than <code>int</code> size. </p>\n<p>Therefore, when this pointer is dereferenced, it is returned an undetermined value, or better a \"value\" that contains in part the value passed as parameter to <code>printf</code>, and for the remaining part could came from another stack buffer area or even a code area (raising a memory fault exception),  <strong>a real buffer overflow</strong>.\n<br><br><br>\n<em>It can consider these specific portions of semplificated code implementations of \"printf\" and \"va_arg\"...</em>\n<br><br>\n<strong>printf</strong> </br></br></br></br></br></p>\n<pre><code>va_list arg;\n....\ncase('%f')\n      va_arg ( arg, double ); //va_arg is a macro, and so you can pass it the \"type\" that will be used for casting the int pointer argument of printf..\n.... \n</code></pre>\n<p><br/></p>\n<blockquote>\n<p id=\"so_38597274_38741563_0\"><em>the real implementation in vprintf (considering gnu impl.) of double value parameters code case\n  management is:</em></p>\n<pre><code>if (__ldbl_is_dbl)\n{\n   args_value[cnt].pa_double = va_arg (ap_save, double);\n   ...\n}\n</code></pre>\n</blockquote>\n<p><br><br>\n<strong>va_arg</strong></br></br></p>\n<pre><code>char *p = (double *) &amp;arg + sizeof arg;  //printf parameters area pointer\n\ndouble i2 = *((double *)p); //casting to double because va_arg(arg, double)\n   p += sizeof (double);\n</code></pre>\n<p><br><br/></br></p>\n<blockquote>\n<p id=\"so_38597274_38741563_1\"><strong><em>references</em></strong></p>\n</blockquote>\n<ol>\n<li><a href=\"https://sourceware.org/git/?p=glibc.git;a=blob;f=stdio-common/vfprintf.c;h=fc370e8cbc4e9652a2ed377b1c6f2324f15b1bf9;hb=3321010338384ecdc6633a8b032bb0ed6aa9b19a\" rel=\"nofollow noreferrer\">gnu project glibc implementation of \"printf\"(vprintf))</a></li>\n<li><a href=\"http://www.firmcodes.com/write-printf-function-c/\" rel=\"nofollow noreferrer\">example of semplification code of printf</a></li>\n<li><a href=\"https://stackoverflow.com/questions/12371450/how-are-variable-arguments-implemented-in-gcc\">example of semplification code of va_arg</a></li>\n</ol>\n", "OwnerUserId": "3762855", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:24:19.710", "Id": "38741563", "Score": "0", "CreationDate": "2016-08-03T10:54:09.190", "LastActivityDate": "2016-08-03T18:50:18.227"}});