post_cb({"26500905": {"CommentCount": "1", "ViewCount": "65", "PostTypeId": "1", "LastEditorUserId": "2046453", "CreationDate": "2014-10-22T05:35:42.263", "LastActivityDate": "2014-10-22T05:58:38.817", "LastEditDate": "2014-10-22T05:41:04.073", "AcceptedAnswerId": "26501135", "OwnerDisplayName": "user2953119", "Title": "Memory reusing and UB", "Id": "26500905", "Score": "1", "Body": "<p>Does the following code produce UB?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;climits&gt;\n\nstruct A\n{\n    ~A(){ std::cout &lt;&lt; \"Non-trivial\" &lt;&lt; std::endl; }\n};\n\nint main()\n{\n    A a;\n    new (&amp;a) A; \n}   //UB?\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/85a7cf7c5483570f\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>The Standard <code>N3797::3.8/8 [basic.life]</code></p>\n<blockquote>\n<p id=\"so_26500905_26500905_0\">If a program ends the lifetime of an object of type T with static\n  (3.7.1), thread (3.7.2), or automatic (3.7.3) storage duration and if\n  T has a non-trivial destructor, the program must ensure that an\n  <em>object of the original type</em> occupies that same storage location when\n  the implicit destructor call takes place; otherwise the behavior of\n  the program is  undefined.</p>\n</blockquote>\n<p>I think there is no UB at the leaving of main function because <code>&amp;a</code> points to the same type as it allocated initially.</p>\n", "Tags": "<c++>", "AnswerCount": "2"}, "26501135": {"ParentId": "26500905", "CommentCount": "0", "Body": "<p>It's undefined behavior, but not for the reason you cite:</p>\n<blockquote>\n<p id=\"so_26500905_26501135_0\">[basic.life]/4 </p>\n<p id=\"so_26500905_26501135_1\">[...] if there is no explicit call to the destructor or\n  if a delete-expression (5.3.5) is not used to release the storage, the\n  destructor shall not be implicitly called and any program that depends\n  on the side effects produced by the destructor has undefined behavior.</p>\n</blockquote>\n<p>Since you have a side-effect in your destructor you must explicitly call the destructor before reusing the memory</p>\n<pre><code>A a;\na.~A();\nnew (&amp;a) A;\n</code></pre>\n", "OwnerUserId": "657267", "PostTypeId": "2", "Id": "26501135", "Score": "0", "CreationDate": "2014-10-22T05:57:55.640", "LastActivityDate": "2014-10-22T05:57:55.640"}, "26501139": {"ParentId": "26500905", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_26500905_26501139_0\">[3.8/4] A program may end the lifetime of any object by reusing the storage which the object occupies or by explicitly calling the destructor for an object of a class type with a non-trivial destructor. For an object of a class type with a non-trivial destructor, the program is not required to call the destructor explicitly before the storage which the object occupies is reused or released; however, if there is no explicit call to the destructor or if a <em>delete-expression</em> (5.3.5) is not used to release the storage, the destructor shall not be implicitly called and <strong><em>any program that depends on the side effects produced by the destructor has undefined behavior</em></strong>.</p>\n</blockquote>\n<p>Does your program \"depend\" upon the side effects produced by the destructor?  Clearly:</p>\n<ul>\n<li><p>the observable program <em>output</em> depends - in the sense of varying - on whether that destructor runs or not</p></li>\n<li><p>the state of the <code>cout</code> buffer, position etc. will be different if the destructor doesn't run, and</p></li>\n<li><p>the flushing actions left to do at program termination may differ.</p></li>\n</ul>\n<p>You could reasonably say that the later program behaviour/flow is dependent on whether the destructor runs, implying technically undefined behaviour.</p>\n<p>Still, I'd hazard that the intent of the Standard is to warn that destructor actions like not releasing locks or decrementing reference counters might have unpleasant consequence like later hangs or leaks, and that in practice on all actual compilers your posted program will behave as you'd expect.</p>\n<p>It's also noteworthy that in general the practice is dangerous if the constructor throws and the scope is unwound without a valid object at that memory location.</p>\n", "OwnerUserId": "410767", "PostTypeId": "2", "Id": "26501139", "Score": "1", "CreationDate": "2014-10-22T05:58:38.817", "LastActivityDate": "2014-10-22T05:58:38.817"}, "bq_ids": {"n4140": {"so_26500905_26500905_0": {"section_id": 7196, "quality": 0.90625, "length": 29}, "so_26500905_26501139_0": {"section_id": 7192, "quality": 0.9423076923076923, "length": 49}, "so_26500905_26501135_1": {"section_id": 7192, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_26500905_26500905_0": {"section_id": 6940, "quality": 0.90625, "length": 29}, "so_26500905_26501139_0": {"section_id": 6936, "quality": 0.9423076923076923, "length": 49}, "so_26500905_26501135_1": {"section_id": 6936, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_26500905_26500905_0": {"section_id": 8705, "quality": 0.90625, "length": 29}, "so_26500905_26501139_0": {"section_id": 8701, "quality": 0.9423076923076923, "length": 49}, "so_26500905_26501135_1": {"section_id": 8701, "quality": 0.9444444444444444, "length": 17}}}});