post_cb({"24677389": {"Id": "24677389", "PostTypeId": "2", "Body": "<p>The <code>i</code> declared in the inner loop hides the <code>i</code> declared in the outer loop for the duration of its scope. I was curious (never knew that was allowed!), so I dug up the relevant part of the standard:</p>\n<blockquote>\n<p id=\"so_24676876_24677389_0\">(<strong>3.3.1</strong>)\n  The scope of a declaration is the same as its potential scope unless\n  the potential scope contains another declaration of the same name. In\n  that case, the potential scope of the declaration in the inner\n  (contained) declarative region is excluded from the scope of the\n  declaration in the outer (containing) declarative region.</p>\n</blockquote>\n<p>While this is allowed by the standard (and thus all conforming compilers), it is bad practice because you, as the programmer, have to keep track of which variable named <code>i</code> you are referring to at different points in the code! Additionally, you have no way of accessing the outer loop's <code>i</code> in the inner loop. </p>\n", "LastEditorUserId": "3812647", "LastActivityDate": "2014-07-10T13:13:59.083", "Score": "2", "CreationDate": "2014-07-10T13:07:55.780", "ParentId": "24676876", "CommentCount": "0", "OwnerUserId": "3812647", "LastEditDate": "2014-07-10T13:13:59.083"}, "24677865": {"Id": "24677865", "PostTypeId": "2", "Body": "<p>On the one hand according to the C++ Standard</p>\n<pre><code>If the name is re-declared in the outermost block of a substatement controlled by the\ncondition, the declaration that re-declares the name is ill-formed\n</code></pre>\n<p>On the other hand </p>\n<blockquote>\n<p id=\"so_24676876_24677865_0\">1 The for statement for ( for-init-statement conditionopt;\n  expressionopt) statement is equivalent to</p>\n</blockquote>\n<pre><code>{\nfor-init-statement\nwhile ( condition ) {\nstatement\nexpression ;\n}\n}\n</code></pre>\n<p>As it seen the for-init-statement and the condition are not declared in the outermost block of the preceding for statement if to nest one for statement inside the other for statement.</p>\n", "LastActivityDate": "2014-07-10T13:30:35.367", "CommentCount": "0", "CreationDate": "2014-07-10T13:30:35.367", "ParentId": "24676876", "Score": "0", "OwnerUserId": "2877241"}, "bq_ids": {"n4140": {"so_24676876_24677389_0": {"length": 28, "quality": 0.9333333333333333, "section_id": 7044}, "so_24676876_24677865_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 3903}}, "n3337": {"so_24676876_24677389_0": {"length": 28, "quality": 0.9333333333333333, "section_id": 6789}, "so_24676876_24677865_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 3763}}, "n4659": {"so_24676876_24677389_0": {"length": 28, "quality": 0.9333333333333333, "section_id": 8541}}}, "24677107": {"Id": "24677107", "PostTypeId": "2", "Body": "<p>That is because of the scope of these two <em>different</em> variables. Inside one has the scope limited to the innermost for loop and outside one has the scope till its for loop. But outside <code>i</code> doesn't interfere while creating a local (inside) <code>i</code> because inside, whenever <code>i</code> is called, it calls the local one relative to itself primarily, not the outside/global one. It somehow follows the hierarchy this way since you have redefined the variable.</p>\n<p>So, to call the global <code>i</code>, use this operator <code>::</code>, which is scope resolution operator before the variable.</p>\n", "LastEditorUserId": "2274442", "LastActivityDate": "2014-07-10T13:01:03.920", "Score": "0", "CreationDate": "2014-07-10T12:53:50.140", "ParentId": "24676876", "CommentCount": "3", "OwnerUserId": "2274442", "LastEditDate": "2014-07-10T13:01:03.920"}, "24676954": {"Id": "24676954", "PostTypeId": "2", "Body": "<p>The inner i just hides outer variable i. It's not an error, just discouraged.</p>\n<p>You have no way to access outer \"int i\" in the third for loop.</p>\n", "LastActivityDate": "2014-07-10T12:46:45.497", "CommentCount": "0", "CreationDate": "2014-07-10T12:46:45.497", "ParentId": "24676876", "Score": "1", "OwnerUserId": "496657"}, "24676935": {"Id": "24676935", "PostTypeId": "2", "Body": "<p>The <code>i</code>  declared in inner loop hides the declaration of <code>i</code> in the second <code>for</code> loop.</p>\n", "LastActivityDate": "2014-07-10T12:45:42.720", "CommentCount": "4", "CreationDate": "2014-07-10T12:45:42.720", "ParentId": "24676876", "Score": "1", "OwnerUserId": "2455888"}, "24676876": {"ViewCount": "89", "Body": "<pre><code>for (int k = 0; k &lt;= CONST; k++) {\nfor (int i = 0; i &lt; CONST; i++) {                   &lt;=== THIS ROW\n  if (...){\n    for (unsigned int i = 0; i &lt; CONST; i++) {      &lt;=== AND THIS ONE \n      if (...) {\n       ...\n      }\n    }\n    if (...) {\n     ...\n    }\n    else {\n    ...\n    }\n  }\n}\n</code></pre>\n<p>}</p>\n<p>the two rows I mentioned were not reconized as a compilation error, why is that?\nthanks</p>\n", "Title": "nested loop with the same iterator is being compiled, why is that?", "CreationDate": "2014-07-10T12:42:44.420", "LastActivityDate": "2014-07-10T13:30:35.367", "CommentCount": "1", "PostTypeId": "1", "Id": "24676876", "Score": "0", "OwnerUserId": "3825461", "Tags": "<c++><loops><compilation><nested>", "AnswerCount": "5"}});