post_cb({"bq_ids": {"n4140": {"so_18218475_18218475_0": {"section_id": 7129, "quality": 0.8888888888888888, "length": 32}, "so_18218475_18218475_5": {"section_id": 194, "quality": 1.0, "length": 4}, "so_18218475_18218475_4": {"section_id": 188, "quality": 0.9333333333333333, "length": 14}, "so_18218475_18218475_7": {"section_id": 195, "quality": 0.8888888888888888, "length": 8}, "so_18218475_18218475_9": {"section_id": 195, "quality": 1.0, "length": 6}, "so_18218475_18218475_8": {"section_id": 195, "quality": 1.0, "length": 24}, "so_18218475_18218475_1": {"section_id": 7132, "quality": 1.0, "length": 25}, "so_18218475_18218475_2": {"section_id": 188, "quality": 0.9782608695652174, "length": 45}}, "n3337": {"so_18218475_18218475_0": {"section_id": 6873, "quality": 0.8888888888888888, "length": 32}, "so_18218475_18218475_5": {"section_id": 188, "quality": 1.0, "length": 4}, "so_18218475_18218475_4": {"section_id": 182, "quality": 0.9333333333333333, "length": 14}, "so_18218475_18218475_9": {"section_id": 189, "quality": 1.0, "length": 6}, "so_18218475_18218475_7": {"section_id": 189, "quality": 0.8888888888888888, "length": 8}, "so_18218475_18218475_8": {"section_id": 189, "quality": 1.0, "length": 24}, "so_18218475_18218475_1": {"section_id": 6876, "quality": 1.0, "length": 25}, "so_18218475_18218475_2": {"section_id": 182, "quality": 0.9782608695652174, "length": 45}}, "n4659": {"so_18218475_18218475_5": {"section_id": 74, "quality": 1.0, "length": 4}, "so_18218475_18218475_0": {"section_id": 8630, "quality": 0.8611111111111112, "length": 31}, "so_18218475_18218475_4": {"section_id": 193, "quality": 0.9333333333333333, "length": 14}, "so_18218475_18218475_9": {"section_id": 201, "quality": 1.0, "length": 6}, "so_18218475_18218475_7": {"section_id": 201, "quality": 0.8888888888888888, "length": 8}, "so_18218475_18218475_8": {"section_id": 201, "quality": 1.0, "length": 24}, "so_18218475_18218475_1": {"section_id": 8633, "quality": 1.0, "length": 25}, "so_18218475_18218475_2": {"section_id": 193, "quality": 0.8695652173913043, "length": 40}}}, "18220574": {"ParentId": "18218475", "PostTypeId": "2", "CommentCount": "4", "Body": "<h3>1</h3>\n<p>Here is how I think your first case, <code>t.Dependent::f</code> works. First, I believe (means, I am not totally sure) that 14.6.2.1p5 should say \"unqualified-id\" instead of \"id-expression\". But independent of that, your name <code>Dependent::f</code> is actually composed out of two names (in the Standard, each nested nested-name-specifier followed by a member name is called \"qualified-id\", even if grammatically, these are not qualified-id productions. So a name <code>foo::bar::baz</code> is a qualified-id but also contains 1 other \"qualified-id\" aswell). </p>\n<p><code>Dependent</code> and <code>Dependent::f</code>. The former is not \"An id-expression denoting the member in a class member access expression\", so you can't simply apply the rule that applies to <code>Dependent::f</code> to apply also to <code>Dependent</code>. </p>\n<p><code>Dependent</code> is therefor non-dependent and albeit it will need to be looked up within a dependent type will have to be found at definition time. I personally think that we should have a clause that says \"When looking up a qualified-id where the qualifier is type-dependent, name lookup yields an empty result.\", to handle these \"force name-lookup to be done immediately\" gracefully. So anyway, in the end, I think your first case is ill-formed by not finding <code>Dependent</code> (clause 3.4 can't just decide by itself over the head of clause 14 that the name is actually dependent anyway). </p>\n<h3>2</h3>\n<p>For your other case, <code>operator Dependent</code>, things are easier. You again have two names, <code>Dependent</code> and <code>operator Dependent</code>. Again, I found nothing that says that <code>Dependent</code> is a dependent name here (I am not sure whether that would be wrong or not. That's beyond me). </p>\n<p>Name lookup comparison (say, the equality function of the name lookup hash table) for operator function names is \"they are conversion-function-ids formed with the same type\" (3.8). This means that in order to form the name itself (not yet doing name lookup!), you not only have to give the lexical spelling as is the case for identifiers, but you have to provide a type identity, which needs to be provided by <code>Dependent</code>. </p>\n<p>That the lookup of the dependent id-expression in <code>t.operator Dependent*</code> is delayed simply means that the semantic type comparison is delayed. Try this one, which should work fine</p>\n<pre><code>struct Dependent; // forward decl at global scope\nt.operator Dependent*(); // in function template\n</code></pre>\n<h3>Your followup</h3>\n<blockquote>\n<p id=\"so_18218475_18220574_0\">If it is intended that such a name is not dependent, what is the rationale for this decision? I can see that it makes life easier for the implementor if they do not have to defer evaluation of a construct like t.operator X::Dependent* or t.X::Dependent::f where X could be either a namespace or a type name.</p>\n</blockquote>\n<p>I don't know the rationale, but I think you already have given a good point. This looks very much to the rule that skips dependent base classes when looking up unqualified names. And I think what rationale applies for that case applies for this case aswell. It makes it easier to reason on the function template for the <em>programmer</em>, especially. </p>\n<pre><code>struct Dependent;\n\ntemplate&lt;typename T&gt;\nvoid f(T t)\n{\n    t.Dependent::f();\n    t.operator Dependent*();\n}\n</code></pre>\n<p>The code looks fine, but if <code>T</code> happens to have a <code>Dependent</code> member, suddenly <code>Dependent</code> would have a different binding (because first we are told to look into <code>t</code>'s class, and then into the surrounding scope). Under my current understanding of the templating rules, the above always refers to the surrounding scope's <code>Dependent</code>, so the above code is \"safe\", regarding to that pitfall. </p>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2013-08-14T21:46:52.463", "Id": "18220574", "Score": "1", "CreationDate": "2013-08-13T22:53:20.327", "LastActivityDate": "2013-08-14T21:46:52.463"}, "18218475": {"CommentCount": "8", "ViewCount": "203", "PostTypeId": "1", "CommunityOwnedDate": "2013-08-14T09:43:00.800", "LastEditorUserId": "1690864", "CreationDate": "2013-08-13T20:19:35.343", "LastActivityDate": "2013-08-14T21:46:52.463", "LastEditDate": "2013-08-14T21:08:31.723", "AcceptedAnswerId": "18220574", "Title": "Should name lookup be deferred for a dependent class/namespace-name in a class-member-access expression?", "Id": "18218475", "Score": "4", "Body": "<p>The following code is rejected by both clang and gcc</p>\n<pre><code>template&lt;typename T&gt;\nvoid f(T t)\n{\n    t.Dependent::f(); // clang accepts, gcc rejects\n    t.operator Dependent*(); // both reject\n}\n\nstruct Dependent\n{\n     void f();\n};\n\nstruct A : Dependent\n{\n     operator Dependent*();\n};\n\ntemplate void f&lt;A&gt;(A);\n</code></pre>\n<p>My reading of the standard suggests both expressions should be accepted.</p>\n<p>In both cases, <code>Dependent</code> can only be a type name.</p>\n<p>In both cases, the name <code>Dependent</code> is to be \"looked up in the class of the object expression\" <code>t</code>. As <code>t</code> is a type-dependent expression, the lookup should be deferred until the template is instantiated.</p>\n<p>Is there something I'm missing?</p>\n<p><strong>EDIT</strong>: If it is intended that such a name is not dependent, what is the rationale for this decision? I can see that it makes life easier for the implementor if they do not have to defer evaluation of a construct like <code>t.operator X::Dependent*</code> or <code>t.X::Dependent::f</code> where <code>X</code> could be either a namespace or a type name. I'm not clear on whether this is an intended or unintended side-effect of the current wording.</p>\n<p>Relevant quotes from C++ Working Draft N3337:</p>\n<blockquote>\n<h3>3.4.5 Class member access [basic.lookup.classref]</h3>\n<p id=\"so_18218475_18218475_0\">If the id-expression in a class member access is a qualified-id of the form\n  class-name-or-namespace-name::...\n  the class-name-or-namespace-name following the . or -&gt; operator is <strong>first looked up in the class of the\n  object expression</strong> and the name, if found, is used. Otherwise it is looked up in the context of the entire\n  postfix-expression. [ Note: See 3.4.3, which describes the lookup of a name before ::, which <strong>will only find a\n  type or namespace name</strong>. \u2014end note ]</p>\n<p id=\"so_18218475_18218475_1\">If the id-expression is a conversion-function-id, its conversion-type-id is <strong>first looked up in the class of the\n  object expression</strong> and the name, if found, is used. Otherwise it is looked up in the context of the entire\n  postfix-expression. In each of these lookups, <strong>only names that denote types or templates whose specializations\n  are types are considered</strong>.</p>\n<h3>14.6.2 Dependent names [temp.dep]</h3>\n<p id=\"so_18218475_18218475_2\">Inside a template, some constructs have semantics which may differ from one instantiation to another. Such a\n  construct depends on the template parameters. In particular, types and expressions may depend on the type\n  and/or value of template parameters (as determined by the template arguments) and this determines the\n  context for name lookup for certain names. Expressions may be type-dependent (on the type of a template\n  parameter) or value-dependent (on the value of a non-type template parameter).</p>\n<p id=\"so_18218475_18218475_3\">[...] </p>\n<p id=\"so_18218475_18218475_4\"><strong>Such names are unbound and are looked up at the point of the template instantiation</strong> (14.6.4.1) in both the\n  context of the template definition and the context of the point of instantiation.</p>\n<h3>14.6.2.1 Dependent types [temp.dep.type]</h3>\n<p id=\"so_18218475_18218475_5\"><strong>A name is a member of an unknown specialization if it is</strong></p>\n<p id=\"so_18218475_18218475_6\">[...]</p>\n<p id=\"so_18218475_18218475_7\">\u2014 <strong>An id-expression denoting the member in a class member access expression</strong> (5.2.5) in which either</p>\n<p id=\"so_18218475_18218475_8\">\u2014 the type of the object expression is the current instantiation, the current instantiation has at least\n  one dependent base class, and name lookup of the id-expression does not find a member of the\n  current instantiation or a non-dependent base class thereof; or</p>\n<p id=\"so_18218475_18218475_9\">\u2014 <strong>the type of the object expression is dependent and is not the current instantiation</strong>.</p>\n<p id=\"so_18218475_18218475_10\">[...]</p>\n<p id=\"so_18218475_18218475_11\"><strong>A type is dependent if it is</strong></p>\n<p id=\"so_18218475_18218475_12\">\u2014 <strong>a member of an unknown specialization</strong>,</p>\n</blockquote>\n", "Tags": "<c++><templates><language-lawyer>", "OwnerUserId": "1690864", "AnswerCount": "1"}});