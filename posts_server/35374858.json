post_cb({"35374858": {"ViewCount": "750", "Body": "<p>If I define a macro as <code>#define LOGIC_ONE 1</code> and want to use the <code>LOGIC_ONE</code> in a case statement, what type is <code>LOGIC_ONE</code> considered?</p>\n<p>Is it recognized as an <code>int</code> since I am defining it for value 1?</p>\n", "AcceptedAnswerId": "35374875", "Title": "What type is a macro considered?", "CreationDate": "2016-02-13T01:08:13.250", "LastActivityDate": "2016-02-13T13:16:22.743", "CommentCount": "1", "LastEditDate": "2016-02-13T09:51:06.557", "PostTypeId": "1", "Tags": "<c++><macros>", "Id": "35374858", "AnswerCount": "4", "Score": "9", "OwnerUserId": "5600745", "ClosedDate": "2016-02-13T19:50:52.193", "LastEditorUserId": "63550"}, "35374875": {"Id": "35374875", "PostTypeId": "2", "Body": "<p>C++ macros are simple text replacements.</p>\n<p>At the time the compiler starts, your <code>LOGIC_ONE</code> has already been replaced by <code>1</code>by the precompiler. Its just the same as if you would have written <code>1</code>right away. (Which, in this case, is an int literal...)</p>\n<p>Edit to include the discussion in the comments:<br>\nIf you (or someone else with access to your code) changes your <code>#define LOGIC_ONE 1</code> to <code>#define LOGIC_ONE \"1\"</code>it would change its behaviour in your program and become a <code>const char[]</code> literal.</br></p>\n<p><strong>Edit:</strong><br>\nSince this post got more attention than i expected, i thought i add the references to the <a href=\"https://isocpp.org/std/the-standard\">C++ 14 Standard</a> for those curious:</br></p>\n<blockquote>\n<p id=\"so_35374858_35374875_0\"><strong>2.2 Phases of translation</strong>  [lex.phases]<br>\n  (...)<br>\n  4. Preprocessing directives are executed, macro invocations are expanded, and\n  _Pragma unary operator expressions are executed. (...) All preprocessing directives are then deleted.<br>\n  (...)<br>\n  7. White-space characters separating tokens are no longer significant. Each preprocessing token is converted into a token. (2.6). The resulting tokens are syntactically and semantically analyzed and translated as a translation unit.</br></br></br></br></p>\n</blockquote>\n<p>As stated, macros are replaced in phase 4 and no  longer present afterwards. \"Syntactical and semantical\" analysation take place in phase 7, where the code gets compiled (\"translated\").</p>\n<p>Integer literals are specified in</p>\n<blockquote>\n<p id=\"so_35374858_35374875_1\"><strong>2.13.2 Integer literals</strong> [lex.icon]<br>\n  (...)<br>\n  An integer literal is a sequence of digits that has no period or exponent part, with optional separating single quotes that are ignored when determining its value. An integer literal may have a prefix that specifies its base and a suffix that specifies its type.<br>\n  (...)</br></br></br></p>\n<p id=\"so_35374858_35374875_2\">Table 5 \u2014 Types of integer literals</p>\n<pre><code>   Suffix    |    Decimal literal     | Binary, octal, or hexadecimal literal  \n-----------------------------------------------------------------------------\nnone         | int                    | int\n             | long int               | unsigned int\n             | long long int          | long int\n             |                        | unsigned long int\n             |                        | long long int\n             |                        | unsigned long long int\n-----------------------------------------------------------------------------\nu or U       | unsigned int           | unsigned int\n             | unsigned long int      | unsigned long int\n             | unsigned long long int | unsigned long long int\n-----------------------------------------------------------------------------\nl or L       | long int               | long int\n             | long long int          | unsigned long int\n             |                        | long long int\n             |                        | unsigned long long int\n-----------------------------------------------------------------------------\nBoth u or U  | unsigned long int      | unsigned long int\nand l or L   | unsigned long long int | unsigned long long int \n-----------------------------------------------------------------------------\nll or LL     | long long int          | long long int\n                                      | unsigned long long int\n-----------------------------------------------------------------------------\nBoth u or U  |unsigned long long int  | unsigned long long int\nand ll or LL |                        |\n</code></pre>\n</blockquote>\n<p>String literals are specified in</p>\n<blockquote>\n<p id=\"so_35374858_35374875_3\"><strong>2.13.5 String literals</strong> [lex.string]<br>\n  (...)<br>\n  1 A string-literal is a sequence of characters (as defined in 2.13.3) surrounded by double quotes, optionally prefixed by R, u8, u8R, u, uR, U, UR, L, rLR, as in \"...\", R\"(...)\", u8\"...\", u8R\"**(...)**\", u\"...\", uR\"*~(...)*~\", U\"...\", UR\"zzz(...)zzz\", L\"...\", or LR\"(...)\", respectively.<br>\n  (...)<br>\n  6 After translation phase 6, a string-literal that does not begin with an encoding-prefix is an ordinary string literal, and is initialized with the given characters.<br>\n  7 A string-literal that begins with u8, such as u8\"asdf\", is a UTF-8 string literal.<br>\n  8 Ordinary string literals and UTF-8 string literals are also referred to as narrow string literals. A narrow string literal has type \u201carray of n <code>const char</code>\u201d, where n is the size of the string as defined below, and has\n  static storage duration (3.7).</br></br></br></br></br></br></p>\n</blockquote>\n", "LastEditorUserId": "3193464", "LastActivityDate": "2016-02-13T10:29:10.373", "Score": "19", "CreationDate": "2016-02-13T01:10:37.707", "ParentId": "35374858", "CommentCount": "8", "LastEditDate": "2016-02-13T10:29:10.373", "OwnerUserId": "3193464"}, "bq_ids": {"n4140": {"so_35374858_35374875_0": {"length": 37, "quality": 0.925, "section_id": 5313}, "so_35374858_35374875_1": {"length": 28, "quality": 0.875, "section_id": 5340}}, "n3337": {"so_35374858_35374875_0": {"length": 37, "quality": 0.925, "section_id": 5110}, "so_35374858_35374875_1": {"length": 19, "quality": 0.59375, "section_id": 5137}}, "n4659": {"so_35374858_35374875_0": {"length": 37, "quality": 0.925, "section_id": 6737}, "so_35374858_35374875_1": {"length": 27, "quality": 0.84375, "section_id": 6761}}}, "35374984": {"Id": "35374984", "PostTypeId": "2", "Body": "<p>Preprocessor defines have no type - they are fundamentally just \"pasted\" in to the code where they appear.   If for example, you use it in the statement;</p>\n<pre><code>int foo = LOGIC_ONE;\n</code></pre>\n<p>Then it'll be interpreted as integer.  (The compiler, which runs after the preprocessor, just sees that code as <code>int foo = 1;</code>)  You can even use it in a grotty statement such as;</p>\n<pre><code>int foo##LOGIC_ONE;\n</code></pre>\n<p>Then you'll be creating a variable <code>foo1</code>.  Yuk!</p>\n<p>Take an alternative example of macro definition;</p>\n<pre><code>#define LOGIC_ONE hello\nint LOGIC_ONE = 5;\nprintf(\"%d\\n\", hello);\n</code></pre>\n<p>That's perfectly valid, and declares an int called hello, but shows that there is no \"type\" for defines - <code>hello</code> was merely substituted wherever <code>LOGIC_ONE</code> was encountered in the code.</p>\n<p>Avoid using preprocessor macros unless absolutely necessary.  Professional coding standards often prohibit or severely restrict the use of the preprocessor.  There are generally always better ways to do things than use macros.   For example, consider these alternatives;</p>\n<pre><code>static const int LOGIC_ONE = 1;\nenum { LOGIC_ONE = 1 };\n</code></pre>\n<p>The preprocessor is a quick way for a learner to get in a real mess in C.</p>\n", "LastEditorUserId": "5716332", "LastActivityDate": "2016-02-13T13:16:22.743", "Score": "11", "CreationDate": "2016-02-13T01:26:28.583", "ParentId": "35374858", "CommentCount": "3", "LastEditDate": "2016-02-13T13:16:22.743", "OwnerUserId": "864065"}, "35374930": {"Id": "35374930", "PostTypeId": "2", "Body": "<p>A macro is a text replacement. <code>1</code> is of type <code>constexpr int</code>.</p>\n", "LastActivityDate": "2016-02-13T01:17:51.903", "Score": "6", "CreationDate": "2016-02-13T01:17:51.903", "ParentId": "35374858", "CommentCount": "0", "OwnerUserId": "1084774"}, "35374899": {"Id": "35374899", "PostTypeId": "2", "Body": "<p>LOGIC_ONE is replaced by 1 everywhere it appears. As far as the compiler is concerned LOGIC_ONE doesn't exist , it just sees 1. So your question is 'is 1 an int?'. The answer to that is -&gt; it depends where you type the 1</p>\n", "LastActivityDate": "2016-02-13T01:14:39.657", "Score": "8", "CreationDate": "2016-02-13T01:14:39.657", "ParentId": "35374858", "CommentCount": "1", "OwnerUserId": "173397"}});