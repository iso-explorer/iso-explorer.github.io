post_cb({"16186387": {"Id": "16186387", "PostTypeId": "2", "Body": "<p>Since your destructors are (correctly) virtual here, the compiler has no problem at all. It just calls the right destructor (<code>~Derived()</code> in this case) and everything works fine.</p>\n<p>The standard does not force any implementation, but a popular one used in many computers is a virtual table. All objects that belong to a class with at least one virtual function (as is the case here) have a pointer (<code>vptr</code>) to the virtual table (<code>vtbl</code>) corresponding to their class. This <code>vtbl</code> has references to the correct overrides of all virtual functions for the object class. Here I am talking about dynamic class (i.e.: the real class of the object), not static class (the class of the pointer). In this case:</p>\n<ul>\n<li>The dynamic type of <code>pb</code> is <code>Derived</code>, since it points to a <code>Derived</code> instance</li>\n<li>The static type of <code>pb</code> is <code>B</code>, since it was declared as <code>B*</code></li>\n</ul>\n<p>As you can see, the compiler does not care about the static type in this case. It interprets the instruction <code>delete pb</code> as this (pseudocode):</p>\n<pre><code>pb-&gt;vptr-&gt;destructor();\noperator delete(pb); // Not exactly, but this is immaterial in this case\n</code></pre>\n<p>You can disregard the second line for our purposes. The runtime will go through this chain and find the right destructor to call (<code>Derived()</code>). <code>Derived()</code> will in turn call <code>~A()</code> and <code>~B()</code> in the right order.</p>\n", "LastEditorUserId": "25824", "LastActivityDate": "2013-04-24T08:23:31.150", "Score": "0", "CreationDate": "2013-04-24T07:49:35.093", "ParentId": "16185945", "CommentCount": "2", "OwnerUserId": "25824", "LastEditDate": "2013-04-24T08:23:31.150"}, "16186270": {"Id": "16186270", "PostTypeId": "2", "Body": "<p>Source from a french site : <a href=\"http://cpp.developpez.com/faq/cpp/?page=heritage#CONSTRUCTEUR_ordre\" rel=\"nofollow\">C++ FAQ</a></p>\n<blockquote>\n<p id=\"so_16185945_16186270_0\">Les constructeurs sont appel\u00e9s dans l'ordre suivant :</p>\n<pre><code>le constructeur des classes de base h\u00e9rit\u00e9es virtuellement en profondeur croissante et de gauche \u00e0 droite ;\nle constructeur des classes de base h\u00e9rit\u00e9es non virtuellement en profondeur croissante et de gauche \u00e0 droite ;\nle constructeur des membres dans l'ordre de leur d\u00e9claration ;\nle constructeur de la classe.\n</code></pre>\n<p id=\"so_16185945_16186270_1\">Order of constructors' calls :</p>\n<pre><code>base class constructors from virtual inheritance (BFS style and from left to rigth);\nbase class constructors from non virtual inheritance (BFS style and from left to rigth);\ninstances constructor in the order of their declaration;\nClass constructor\n</code></pre>\n</blockquote>\n<p>I'm guessing the destructors' calls order is the reverse of this order.</p>\n", "LastActivityDate": "2013-04-24T07:43:41.727", "CommentCount": "0", "CreationDate": "2013-04-24T07:43:41.727", "ParentId": "16185945", "Score": "0", "OwnerUserId": "1741450"}, "16185945": {"ViewCount": "758", "Body": "<p>Given the following code: </p>\n<pre><code>namespace Example1 {\n\nclass A {\npublic:\n    A() {}\n    virtual ~A() {}\nprivate:\n    float data_A;\n};\n\nclass B {\npublic:\n    B() {}\n    virtual ~B() {}\nprotected:\n    float data_B;\n};\n\nclass Derived : public A, public B {\npublic:\n    Derived() {}\n    virtual ~Derived() {}\nprotected:\n    float data_Derived;\n};\n\n}\n\nint main (void)\n{\nusing namespace Example1;\nB* pb = new Derived;\ndelete pb;\n}\n</code></pre>\n<p><code>pb</code> should now point to the <code>B</code> part of the <code>Derived</code> object.\nBut the derived object also derives from <code>A</code>, means it has <code>A</code> sub-object.. and that <code>A</code> sub-object should be \"first\" because the <code>Derived</code> class first inherits from <code>A</code>.</p>\n<p>How does the compiler approves that? what does it add in order to make it work correctly?</p>\n<p>and also, how does it free the memory correctly when deleting the object?</p>\n", "AcceptedAnswerId": "16186222", "Title": "Multiple inheritance and pointer implementation", "CreationDate": "2013-04-24T07:28:23.620", "Id": "16185945", "CommentCount": "1", "LastEditDate": "2013-04-24T07:54:40.453", "PostTypeId": "1", "LastEditorUserId": "952747", "LastActivityDate": "2017-05-14T19:21:57.670", "Score": "3", "OwnerUserId": "2042801", "Tags": "<c++>", "AnswerCount": "6"}, "16186258": {"Id": "16186258", "PostTypeId": "2", "Body": "<p>It doesn't matter, which class you type first in derived class declaration. \"A should be first\" is not correct, as they are equally base classes. The only difference is, which constructor / destructor is called first (in the order / reversed order they were declared as base classes).</p>\n<p>You can refer to <a href=\"https://stackoverflow.com/questions/406081/why-should-i-avoid-multiple-inheritance-in-c\">why multiple inheritance is a bad idea</a></p>\n<p>Perhaps what could be well suited for you is single inheritance, with B class deriving from A and C deriving from B.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-04-24T07:43:04.610", "Score": "0", "CreationDate": "2013-04-24T07:43:04.610", "ParentId": "16185945", "CommentCount": "0", "OwnerUserId": "2198692", "LastEditDate": "2017-05-23T11:54:46.753"}, "16186222": {"Id": "16186222", "PostTypeId": "2", "Body": "<p>The short answer is: By magic.</p>\n<p>The medium answer is: It's not for you to worry about. The Standard says that this works, and it's up to the compiler to figure out a way to make it work.</p>\n<p>The long answer: Since this depends on your compiler, read up your compiler's documentation! Many C++ compilers implement the Itanium C++ ABI, so that's a start. As part of polymorphic inheritance, each class usually has a so-called <em>vtable</em>, which stores a bunch of function pointers, but it also stores RTTI information and joined virtual-destruction and memory-deallocation logic. Think about it: <code>delete pb;</code> doesn't just have to call the right destructors in the right order, but it also has to pass the <em>correct</em> pointer to the deallocation function. All this information is included in the various vtables of the class hierarchy. </p>\n", "LastEditorUserId": "4099593", "LastActivityDate": "2017-05-14T19:21:57.670", "Score": "7", "CreationDate": "2013-04-24T07:40:58.840", "ParentId": "16185945", "CommentCount": "3", "OwnerUserId": "596781", "LastEditDate": "2017-05-14T19:21:57.670"}, "16186132": {"Id": "16186132", "PostTypeId": "2", "Body": "<p>Paragraph <code>\u00a710.1/2</code></p>\n<blockquote>\n<p id=\"so_16185945_16186132_0\">[Note: The order of derivation is not significant except as specified\n  by the semantics of initialization by constructor (12.6.2), cleanup\n  (12.4), and storage layout (9.2, 11.1). \u2014end note ]</p>\n</blockquote>\n<p>therefore</p>\n<pre><code>class Derived : public A, public B {\n                ^^^^^^^^  ^^^^^^^^\n                  first    second\n</code></pre>\n<p>Then calls derived constructor. Also, destructors will invoked in reverse order.</p>\n<pre><code>Construction\nA()\nB()\nD()\n\nDestruction\n~D()\n~B()\n~A()\n</code></pre>\n", "LastEditorUserId": "952747", "LastActivityDate": "2013-04-24T07:53:02.353", "Score": "0", "CreationDate": "2013-04-24T07:37:12.387", "ParentId": "16185945", "CommentCount": "0", "OwnerUserId": "952747", "LastEditDate": "2013-04-24T07:53:02.353"}, "16186532": {"Id": "16186532", "PostTypeId": "2", "Body": "<p>The general answer is that it works, but the actual implementation is compiler dependant and you shouldn't rely on the details (but it is still a good thing to keep in mind so you don't make incorrect assumptions when dealing with pointers).</p>\n<p>When multiple inheritance is used, simple line such as <code>B* pb = new Derived</code> implicitly changes the actual value of the pointer. In this particular case, since the compiler knows it has to convert a <code>Derived</code> pointer to <code>B*</code>, it knows exactly by how much it needs to change the pointer (e.g. <code>sizeof(A)</code>, of course the actual value is probably different).</p>\n<p>If you are using virtual inheritance (which is guarantees that a common base class is only included once, e.g. if both <code>A</code> and <code>B</code> inherited from <code>CommonBase</code>), then simple pointer conversion becomes even more complex, and the compiler does a vtable lookup to find the actual offset it should use for pointer conversion.</p>\n<p>If you are using Visual Studio, you can make a breakpoint on this line and press Alt+8 to see the disassembly, which will reveal the 'magic' behind pointer conversion.</p>\n", "LastActivityDate": "2013-04-24T07:58:16.947", "CommentCount": "0", "CreationDate": "2013-04-24T07:58:16.947", "ParentId": "16185945", "Score": "0", "OwnerUserId": "1537403"}, "bq_ids": {"n4140": {"so_16185945_16186132_0": {"length": 11, "quality": 0.6111111111111112, "section_id": 6983}}, "n3337": {"so_16185945_16186132_0": {"length": 11, "quality": 0.6111111111111112, "section_id": 6729}}, "n4659": {"so_16185945_16186132_0": {"length": 11, "quality": 0.6111111111111112, "section_id": 8481}}}});