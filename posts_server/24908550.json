post_cb({"24908991": {"ParentId": "24908550", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>If the constructor throws an exception during a new call, the similarly declared delete with the same parameters will be called. For this reason, placement new and delete should always be declared in matching pairs.</p>\n<p>In this case, the delete will have the same signature as the array delete and the compiler will not be able to choose between them.</p>\n<p>Edited to add sample code and output.</p>\n<p>Your code did not implement the global array placement new that is forbidden:</p>\n<pre><code>void * operator new( size_t bytes, size_t )\n</code></pre>\n<p>This program will illustrate how the global new and delete are called.</p>\n<pre><code>#include &lt;stdint.h&gt;\n#include &lt;malloc.h&gt;\n#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n\nusing namespace std;\n\nstruct A\n{\n    int a;\n\n    A( void )\n        : a( 1 )\n    {\n        cout &lt;&lt; __LINE__ &lt;&lt; \" : A::A()\" &lt;&lt; endl;\n        throw logic_error( \"That is .. illogical\" );\n    }\n};\n\n// Placement new with size_t parameter\nvoid * operator new( size_t bytes, size_t )\n{\n    cout &lt;&lt; __LINE__ &lt;&lt; \" : void * A::operator new( size_t bytes = \" &lt;&lt; bytes &lt;&lt; \", size_t )\";\n    void *p = malloc( bytes );\n    cout &lt;&lt; \" -&gt; \" &lt;&lt; p &lt;&lt; endl;\n    return p;\n}\n\n// C++11 : Array placement delete with size_t parameter\n// C++14 : Array delete\nvoid operator delete( void *p, std::size_t n ) \n{\n    cout &lt;&lt; __LINE__ &lt;&lt; \" : void A::operator delete( void *p = \" &lt;&lt; p &lt;&lt; \", size_t n = \" &lt;&lt; n &lt;&lt; \" )\" &lt;&lt; endl;\n    if (p)\n        free( p );\n}\n\n// Non-array new\nvoid * operator new( size_t bytes )\n{\n    cout &lt;&lt; __LINE__ &lt;&lt; \" : void * A::operator new( size_t bytes = \" &lt;&lt; bytes &lt;&lt; \" )\";\n    void *p = malloc( bytes );\n    cout &lt;&lt; \" -&gt; \" &lt;&lt; p &lt;&lt; endl;\n    return p;\n}\n\n// Non-array delete\nvoid operator delete( void *p ) noexcept\n{\n    cout &lt;&lt; __LINE__ &lt;&lt; \" : void A::operator delete( void *p = \" &lt;&lt; p &lt;&lt; \" )\" &lt;&lt; endl;\n    if (p)\n        free( p );\n}\n\n// Array new\nvoid * operator new[]( size_t bytes )\n{\n    cout &lt;&lt; __LINE__ &lt;&lt; \" : void * A::operator new[]( size_t bytes = \" &lt;&lt; bytes &lt;&lt; \" )\";\n    void *p = malloc( bytes );\n    cout &lt;&lt; \" -&gt; \" &lt;&lt; p &lt;&lt; endl;\n    return p;\n}\n\n// Array placement new with size_t parameter\nvoid * operator new[]( size_t bytes, size_t n )\n{\n    cout &lt;&lt; __LINE__ &lt;&lt; \" : void * A::operator new[]( size_t bytes = \" &lt;&lt; bytes &lt;&lt; \", size_t n = \" &lt;&lt; n &lt;&lt; \" )\";\n    void *p = malloc( bytes );\n    cout &lt;&lt; \" -&gt; \" &lt;&lt; p &lt;&lt; endl;\n    return p;\n}\n\n// C++11 : Array placement delete with size_t parameter\n// C++14 : Array delete\nvoid operator delete[]( void *p, std::size_t n ) \n{\n    cout &lt;&lt; __LINE__ &lt;&lt; \" : void A::operator delete[]( void *p = \" &lt;&lt; p &lt;&lt; \", size_t n = \" &lt;&lt; n &lt;&lt; \" )\" &lt;&lt; endl;\n    if (p)\n        free( p );\n}\n\nint main( int, char ** )\n{\n\n    A *p = nullptr;\n#if 1\n    try\n    {\n        cout &lt;&lt; __LINE__ &lt;&lt; \" : ===== Array placement new allocate with size_t parameter. =====\" &lt;&lt; endl;\n        p = new( (size_t)4 ) A[ 3 ];\n\n        cout &lt;&lt; __LINE__ &lt;&lt; \" : ===== Array placement new succeeded. =====\" &lt;&lt; endl;\n    }\n    catch (...)\n    {\n    }\n\n    cout &lt;&lt; __LINE__ &lt;&lt; \" : ===== Array placement delete. =====\" &lt;&lt; endl;\n    delete[] p;\n    p = nullptr;\n\n#endif\n\n    try\n    {\n        cout &lt;&lt; __LINE__ &lt;&lt; \" : ===== Array new. =====\" &lt;&lt; endl;\n        p = new A[ 3 ];\n\n        cout &lt;&lt; __LINE__ &lt;&lt; \" : ===== Array new succeeded. =====\" &lt;&lt; endl;\n    }\n    catch (...)\n    {\n    }\n\n    cout &lt;&lt; __LINE__ &lt;&lt; \" : ===== Array delete. =====\" &lt;&lt; endl;\n    delete[] p;\n    p = nullptr;\n\n    cout &lt;&lt; __LINE__ &lt;&lt; \" : ===== Complete. =====\" &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>Compiling with clang 3.4.2 for C++11 gives this result:</p>\n<pre class=\"lang-none prettyprint-override\"><code>$ clang++ --std=c++11 -o replace_new main.cpp &amp;&amp; ./replace_new\n88 : ===== Array placement new allocate with size_t parameter. =====\n66 : void * A::operator new[]( size_t bytes = 12, size_t n = 4 ) -&gt; 0x80048358\n14 : A::A()\n40 : void * A::operator new( size_t bytes = 33 ) -&gt; 0x800483d8\n76 : void A::operator delete[]( void *p = 0x80048358, size_t n = 4 )\n49 : void A::operator delete( void *p = 0x800483d8 )\n97 : ===== Array placement delete. =====\n105 : ===== Array new. =====\n57 : void * A::operator new[]( size_t bytes = 12 ) -&gt; 0x80048358\n14 : A::A()\n40 : void * A::operator new( size_t bytes = 33 ) -&gt; 0x800483d8\n49 : void A::operator delete( void *p = 0x80048358 )\n49 : void A::operator delete( void *p = 0x800483d8 )\n114 : ===== Array delete. =====\n118 : ===== Complete. =====\n</code></pre>\n<p>The allocation of 33 bytes is the exception. The exception and the array are both deleted with the same delete function.</p>\n<p>Compiling with C++14 rules gives this result:</p>\n<pre class=\"lang-none prettyprint-override\"><code>$ clang++ --std=c++1y -o replace_new main.cpp &amp;&amp; ./replace_new\nmain.cpp:89:17: error: 'new' expression with placement arguments refers to non-placement 'operator delete'\n            p = new( (size_t)4 ) A[ 3 ];\n                ^    ~~~~~~~~~\nmain.cpp:74:10: note: 'operator delete[]' declared here\n    void operator delete[]( void *p, std::size_t n )\n         ^\n1 error generated.\n</code></pre>\n<p>Disabling the invalid section and compiling with C++14 rules gives this result:</p>\n<pre class=\"lang-none prettyprint-override\"><code>$ clang++ --std=c++1y -o replace_new main.cpp &amp;&amp; ./replace_new\n105 : ===== Array new. =====\n57 : void * A::operator new[]( size_t bytes = 12 ) -&gt; 0x80048358\n14 : A::A()\n40 : void * A::operator new( size_t bytes = 33 ) -&gt; 0x800483d8\n76 : void A::operator delete[]( void *p = 0x80048358, size_t n = 12 )\n49 : void A::operator delete( void *p = 0x800483d8 )\n114 : ===== Array delete. =====\n118 : ===== Complete. =====\n</code></pre>\n<p>Notice that the array is now deleted with a different delete function. It is the same delete function at line 76 that deleted the array placement new when compiled as C++11.</p>\n", "OwnerUserId": "3849688", "LastEditorUserId": "3849688", "LastEditDate": "2014-07-23T20:12:25.193", "Id": "24908991", "Score": "1", "CreationDate": "2014-07-23T11:15:07.277", "LastActivityDate": "2014-07-23T20:12:25.193"}, "24908550": {"CommentCount": "8", "ViewCount": "129", "OwnerDisplayName": "user2953119", "CreationDate": "2014-07-23T10:54:45.897", "LastActivityDate": "2014-07-23T20:12:25.193", "PostTypeId": "1", "AcceptedAnswerId": "24908991", "Title": "Deallocation function precludes use of an allocation with two parameter", "Id": "24908550", "Score": "0", "Body": "<p>Here is from 3.7.4.2 N3797:</p>\n<blockquote>\n<p id=\"so_24908550_24908550_0\">The global operator delete[] with exactly two parameters, the second\n  of which has type std::size_t, is a usual deallocation function.37</p>\n<p id=\"so_24908550_24908550_1\">37) This deallocation function precludes use of an allocation function\n  void operator new(std::size_t, std::size_t) as a placement allocation\n  function</p>\n</blockquote>\n<p>This note is not clear for me. I would like to look at the real example of that preclusion. Compiler will throw a warning or we have a runtime error? I've been trying to write something like the following:</p>\n<pre><code>using std::cout;\nstruct A\n{\n    int a;\n    A(){ a = 5; }\n    void * operator new(std::size_t t, std::size_t)\n    {\n        void *p = ::operator new(t);\n        return p;\n    }\n};\n\nint main(){ }\n</code></pre>\n<p>And I have no idea about example which reflects this preclusion. Could you help me provided one?</p>\n", "Tags": "<c++><memory-management>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24908550_24908550_1": {"section_id": 7181, "quality": 0.9285714285714286, "length": 13}, "so_24908550_24908550_0": {"section_id": 7181, "quality": 0.8461538461538461, "length": 11}}, "n3337": {"so_24908550_24908550_0": {"section_id": 6925, "quality": 0.7692307692307693, "length": 10}}, "n4659": {"so_24908550_24908550_1": {"section_id": 8689, "quality": 0.9285714285714286, "length": 13}, "so_24908550_24908550_0": {"section_id": 8689, "quality": 0.6153846153846154, "length": 8}}}});