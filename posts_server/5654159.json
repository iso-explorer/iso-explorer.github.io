post_cb({"5654210": {"ParentId": "5654159", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>I suppose it is because the Standard says, in <code>3.9.1[basic.fundamental]/7</code></p>\n<blockquote>\n<p id=\"so_5654159_5654210_0\">this International Standard permits 2\u2019s complement, 1\u2019s complement and signed magnitude representations for integral types.</p>\n</blockquote>\n<p>which, I am willing to bet, came along from the C programming language, which lists <em>sign and magnitude</em>, <em>two's complement</em>, and <em>one's complement</em> as the only allowed representations in <code>6.2.6.2/2</code>. And there sure were 1's complement systems around when C was wide-spread: UNIVACs are the most often mentioned, it seems.</p>\n", "OwnerUserId": "273767", "LastEditorUserId": "273767", "LastEditDate": "2011-04-13T19:28:49.803", "Id": "5654210", "Score": "3", "CreationDate": "2011-04-13T19:03:56.910", "LastActivityDate": "2011-04-13T19:28:49.803"}, "26559415": {"ParentId": "5654159", "CommentCount": "0", "Body": "<p>Many aspects of the language standard are as they are because the Standards Committee has been extremely loath to forbid compilers from behaving in ways that existing code may rely upon.  If code exists which would rely upon one's complement behavior, then requiring that compilers behave as though the underlying hardware uses two's complement would make it impossible for the older code to run using newer compilers.</p>\n<p>The solution, which the Standards Committee has alas not yet seen fit to implement, would be to allow code to specify the desired semantics for things in a fashion independent of the machine's word size or hardware characteristics.  If support for code which relies upon ones'-complement behavior is deemed important, design a means by which code could expressly demand one's-complement behavior regardless of the underlying hardware platform.  If desired, to avoid overly complicating every single compiler, specify that certain aspects of the standard are optional, but conforming compilers must document which aspects they support.  Such a design would allow compilers for ones'-complement machines to support both two's-complement behavior and ones'-complement behavior depending upon the needs of the program.  Further, it would make it possible to port the code to two's-complement machines with compilers that happened to include ones'-complement support.</p>\n<p>I'm not sure exactly why the Standards Committee has as yet not allowed any way by which code can specify behavior in a fashion independent of the underlying architecture and word size (so that code wouldn't have some machines use signed semantics for comparisons where other machines would use unsigned semantics), but for whatever reason they have yet to do so.  Support for ones'-complement representation is but a part of that.</p>\n", "OwnerUserId": "363751", "PostTypeId": "2", "Id": "26559415", "Score": "1", "CreationDate": "2014-10-25T04:45:32.680", "LastActivityDate": "2014-10-25T04:45:32.680"}, "5654256": {"ParentId": "5654159", "CommentCount": "1", "Body": "<p>It seems to me that, even today, if you are writing a broadly-applicable C++ library that you expect to run on any machine, then 2's complement cannot be assumed. C++ is just too widely used to be making assumptions like that.</p>\n<p>Most people don't write those sorts of libraries, though, so if you want to take a dependency on 2's complement you should just go ahead.</p>\n", "OwnerUserId": "10174", "PostTypeId": "2", "Id": "5654256", "Score": "4", "CreationDate": "2011-04-13T19:07:36.123", "LastActivityDate": "2011-04-13T19:07:36.123"}, "5654289": {"ParentId": "5654159", "PostTypeId": "2", "CommentCount": "6", "Body": "<ul>\n<li><p>A major problem in defining something which isn't, is that compilers were built assuming that is undefined.  Changing the standard won't change the compilers and reviewing those to find out where the assumption was made is a difficult task.</p></li>\n<li><p>Even on 2 complement machine, you may have more variety than you think.  Two examples: some don't have a sign preserving right shift, just a right shift which introduce zeros; a common feature in DSP is saturating arithmetic, there assigning an out of range value will clip it at the maximum, not just drop the high order bits.</p></li>\n</ul>\n", "OwnerUserId": "136208", "LastEditorUserId": "1127571", "LastEditDate": "2016-03-09T06:58:31.747", "Id": "5654289", "Score": "19", "CreationDate": "2011-04-13T19:09:41.403", "LastActivityDate": "2016-03-09T06:58:31.747"}, "bq_ids": {"n4140": {"so_5654159_5654210_0": {"section_id": 7216, "quality": 0.9, "length": 9}}, "n3337": {"so_5654159_5654210_0": {"section_id": 6960, "quality": 0.9, "length": 9}}, "n4659": {"so_5654159_5654210_0": {"section_id": 8725, "quality": 0.9, "length": 9}}}, "5654159": {"CommentCount": "28", "AcceptedAnswerId": "5654289", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-04-13T18:59:52.977", "LastActivityDate": "2016-03-09T06:58:31.747", "LastEditDate": "2017-05-23T11:33:17.723", "ViewCount": "2756", "FavoriteCount": "2", "Title": "Why not enforce 2's complement in C++?", "Id": "5654159", "Score": "20", "Body": "<p>The new C++ standard still refuses to specify the binary representation of integer types. Is this because there are real-world implementations of C++ that don't use 2's complement arithmetic? I find that hard to believe. Is it because the committee feared that future advances in hardware would render the notion of 'bit' obsolete? Again hard to believe. Can anyone shed any light on this?</p>\n<p><strong>Background:</strong> I was surprised twice in one comment thread (Benjamin Lindley's answer to <a href=\"https://stackoverflow.com/questions/5639210/splitting-long-long\">this question</a>). First, from piotr's comment:  </p>\n<blockquote>\n<p id=\"so_5654159_5654159_0\">Right shift on signed type is undefined behaviour</p>\n</blockquote>\n<p>Second, from James Kanze's comment:</p>\n<blockquote>\n<p id=\"so_5654159_5654159_1\">when assigning to a long, if the value doesn't fit in a long, the results are\n  implementation defined</p>\n</blockquote>\n<p>I had to look these up in the standard before I believed them. The only reason for them is to accommodate non-2's-complement integer representations. WHY?</p>\n", "Tags": "<c++><binary><standards>", "OwnerUserId": "428857", "AnswerCount": "4"}});