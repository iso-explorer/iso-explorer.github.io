post_cb({"14613025": {"ParentId": "14612933", "CommentCount": "0", "Body": "<p>The declarations of <code>foo3</code> and <code>foo4</code> are legal because the argument to those functions is not a reference.</p>\n<p>The declaration of <code>foo2</code> is illegal because you can't bind a non-const reference to a temporary.</p>\n<p>So why is the declaration of <code>foo1</code> legal? It's that very important <code>const</code> qualifier that makes this declaration legal.</p>\n", "OwnerUserId": "774499", "PostTypeId": "2", "Id": "14613025", "Score": "0", "CreationDate": "2013-01-30T20:25:38.343", "LastActivityDate": "2013-01-30T20:25:38.343"}, "14612972": {"ParentId": "14612933", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>You can't take a non-const reference to a temporary like foo2 does.</p>\n<p>Notice that this isn't specifically default parameters. You get the same error for function variables: <a href=\"http://ideone.com/g7Tf7L\" rel=\"noreferrer\">http://ideone.com/g7Tf7L</a></p>\n<pre><code>#include &lt;string&gt;\nusing std::string;\n\n#include &lt;iostream&gt;\nusing std::cout; using std::endl;\n\nint main()\n{\n    string s1        = string(\"s1\"); // OK, copy it\n    const string&amp; s2 = string(\"s2\"); // OK, const reference to it\n    string&amp; s3       = string(\"s3\"); // ERROR! non-const reference not allowed!\n\n    cout\n            &lt;&lt; s1 &lt;&lt; \", \"\n            &lt;&lt; s2 &lt;&lt; \", \"\n            &lt;&lt; s3 &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>When you take a const reference to a temporary, the lifetime of the temporary is extended to the lifetime of the reference (\u00a712.2, quoted from my copy of C++11 draft n3337):</p>\n<blockquote>\n<p id=\"so_14612933_14612972_0\">There are two contexts in which temporaries are destroyed at a different point than the end of the fullexpression. </p>\n<p id=\"so_14612933_14612972_1\">...</p>\n<p id=\"so_14612933_14612972_2\">The second context is when a reference is bound to a temporary. The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference except: </p>\n<ul>\n<li>A temporary bound to a reference member in a constructor\u2019s ctor-initializer (12.6.2) persists until the constructor exits. </li>\n<li>A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full-expression containing the call. </li>\n<li>The lifetime of a temporary bound to the returned value in a function return statement (6.6.3) is not extended; the temporary is destroyed at the end of the full-expression in the return statement. </li>\n<li>A temporary bound to a reference in a new-initializer (5.3.4) persists until the completion of the full-expression containing the new-initializer.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "102", "LastEditorUserId": "34509", "LastEditDate": "2013-01-30T21:45:21.757", "Id": "14612972", "Score": "19", "CreationDate": "2013-01-30T20:22:25.737", "LastActivityDate": "2013-01-30T21:45:21.757"}, "14612933": {"CommentCount": "5", "AcceptedAnswerId": "14612972", "PostTypeId": "1", "ClosedDate": "2013-01-31T01:36:36.100", "LastEditorUserId": "-1", "CreationDate": "2013-01-30T20:20:52.423", "LastActivityDate": "2013-01-30T21:45:21.757", "LastEditDate": "2017-05-23T12:19:14.880", "ViewCount": "14995", "FavoriteCount": "2", "Title": "const reference default-value", "Id": "14612933", "Score": "12", "Body": "<blockquote>\n<p id=\"so_14612933_14612933_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/4238141/how-to-initialize-function-arguments-that-are-classes-with-default-value\">how to initialize function arguments that are classes with default value</a> </br></p>\n</blockquote>\n<pre><code>#include &lt;string&gt;\n\nvoid foo1(const std::string&amp; s = std::string());\n\nvoid foo2(std::string&amp; s = std::string());\n\nvoid foo3(const std::string s = std::string());\n\nvoid foo4(std::string s = std::string());\n</code></pre>\n<p><code>error at foo2(): default argument for \u2018std::string&amp; s\u2019 has type \u2018std::string {aka std::basic_string&lt;char&gt;}\u2019</code></p>\n<p>I understand the compiler's point, but I don't get how this does not apply to <code>foo1()</code> as well.</p>\n", "Tags": "<c++><reference><const><default-value>", "OwnerUserId": "1009248", "AnswerCount": "3"}, "14613038": {"ParentId": "14612933", "CommentCount": "3", "Body": "<p>It may come as a surprise to you, but you <em>can</em> bind the value of a temporary expression to a <em>constant</em> reference, and the lifetime of the expression is extended to that of the reference. But you cannot do this with a non-constant (lvalue) reference.</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "14613038", "Score": "2", "CreationDate": "2013-01-30T20:26:10.950", "LastActivityDate": "2013-01-30T20:26:10.950"}, "bq_ids": {"n4140": {"so_14612933_14612972_2": {"section_id": 382, "quality": 0.9047619047619048, "length": 19}, "so_14612933_14612972_0": {"section_id": 381, "quality": 1.0, "length": 10}}, "n3337": {"so_14612933_14612972_0": {"section_id": 372, "quality": 1.0, "length": 10}, "so_14612933_14612972_2": {"section_id": 373, "quality": 0.9047619047619048, "length": 19}}, "n4659": {"so_14612933_14612972_0": {"section_id": 396, "quality": 0.9, "length": 9}, "so_14612933_14612972_2": {"section_id": 397, "quality": 0.8571428571428571, "length": 18}}}});