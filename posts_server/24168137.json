post_cb({"bq_ids": {"n4140": {"so_24168137_24168426_0": {"length": 24, "quality": 0.8, "section_id": 651}, "so_24168137_24168426_3": {"length": 9, "quality": 0.5294117647058824, "section_id": 7027}, "so_24168137_24168426_2": {"length": 17, "quality": 0.8947368421052632, "section_id": 7070}}, "n3337": {"so_24168137_24168426_0": {"length": 24, "quality": 0.8, "section_id": 641}, "so_24168137_24168426_3": {"length": 9, "quality": 0.5294117647058824, "section_id": 6773}, "so_24168137_24168426_2": {"length": 17, "quality": 0.8947368421052632, "section_id": 6814}}, "n4659": {"so_24168137_24168426_0": {"length": 24, "quality": 0.8, "section_id": 679}, "so_24168137_24168426_3": {"length": 9, "quality": 0.5294117647058824, "section_id": 8524}, "so_24168137_24168426_2": {"length": 17, "quality": 0.8947368421052632, "section_id": 8569}}}, "24168137": {"ViewCount": "91", "Body": "<p>I think this example best illustrates my question:</p>\n<pre><code>namespace N {\n\n    class C {\n    public:\n        friend bool operator==(const C&amp; c, const C&amp; x) {\n            return true;\n        }\n        friend bool f(const C&amp; c, const C&amp; x) {\n            return true;\n        }\n    };\n\n    class D {\n    public:\n        bool operator==(const D&amp; x) {\n            bool a = C{} == C{};      // this works\n            return true;\n        }\n        bool f(const D&amp; x) {\n            bool a = f(C{}, C{});     // this does not work\n            return true;\n        }\n    };\n}\n</code></pre>\n<p>I have always viewed overloaded operators as being just like function except for the 'calling syntax' if you will. I just noticed the above difference however in ADL or name lookup rules (I don't know which one). </p>\n<p>Can someone explain why the <code>bool operator==(const C&amp; c, const C&amp; x)</code> is found but the <code>bool f(const C&amp; c, const C&amp; x)</code> is not?</p>\n", "AcceptedAnswerId": "24168426", "Title": "Are there different rules regarding ADL or naming clashes with regard to overloaded operators?", "CreationDate": "2014-06-11T16:37:21.777", "Id": "24168137", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-06-11T16:51:32.390", "LastEditorUserId": "560648", "LastActivityDate": "2014-06-11T17:03:40.057", "Score": "2", "OwnerUserId": "893819", "Tags": "<c++><argument-dependent-lookup><name-resolution>", "AnswerCount": "1"}, "24168426": {"Id": "24168426", "PostTypeId": "2", "Body": "<p>Your <code>D::f</code> is <em>hiding</em> <code>C::f</code>; if you rename the latter to <code>C::g</code> and adjust the call then it works fine (showing that the function can be <em>found</em> and <em>accessed</em> just fine).</p>\n<p>Your code isn't actually directly calling the operator functions, but this is done for you by the language. Consequently you're not using the <em>name</em> of the operator function, so no name hiding applies.</p>\n<p>If you write <code>operator==(C{}, C{})</code> (instead of <code>C{} == C{}</code>), then you'll see the same behaviour as <code>f(C{}, C{})</code> (<a href=\"http://coliru.stacked-crooked.com/a/4658c249feb00f3b\" rel=\"nofollow\">demo</a>).</p>\n<p>So, when you say \"I have always viewed overloaded operators as being just like function except for the 'calling syntax' if you will\", you've already hit the nail on the head.</p>\n<hr>\n<p>Here's some standardese for you:</p>\n<blockquote>\n<p id=\"so_24168137_24168426_0\"><code>[C++11: 13.5/4]:</code> Operator functions are usually not called directly; instead they are invoked to evaluate the operators they implement (13.5.1 \u2013 13.5.7). They can be explicitly called, however, using the <em>operator-function-id</em> as the name of the function in the function call syntax (5.2.2). <em>[ Example:</em></p>\n<pre><code>complex z = a.operator+(b); // complex z = a+b;\nvoid* p = operator new(sizeof(int)*n);\n</code></pre>\n<p id=\"so_24168137_24168426_1\"><em>\u2014end example ]</em></p>\n<p id=\"so_24168137_24168426_2\"><code>[C++11: 3.3.7/4]:</code> <em>[..]</em> 4) A name declared within a member function hides a declaration of the same name whose scope extends to or past the end of the member function\u2019s class. <em>[..]</em></p>\n<p id=\"so_24168137_24168426_3\"><code>[C++11: 3/4]:</code> A name is a use of an <em>identifier</em> (2.11), <em>operator-function-id</em> (13.5), <em>literal-operator-id</em> (13.5.8), <em>conversion-function-id</em> (12.3.2), or <em>template-id</em> (14.2) that denotes an entity or <em>label</em> (6.6.4, 6.1).</p>\n</blockquote>\n<p>(The [qualified] <em>operator-function-id</em> here is <code>::N::C::operator==</code>.)</p>\n</hr>", "LastEditorUserId": "560648", "LastActivityDate": "2014-06-11T17:03:40.057", "Score": "2", "CreationDate": "2014-06-11T16:53:36.930", "ParentId": "24168137", "CommentCount": "0", "OwnerUserId": "560648", "LastEditDate": "2014-06-11T17:03:40.057"}});