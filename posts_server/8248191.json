post_cb({"8248258": {"ParentId": "8248191", "CommentCount": "0", "Body": "<p><code>myfunc(*this)</code> is fine, so long as <code>myfunc</code> is declared to take a reference -- which it is.</p>\n<p>This will not copy the object.  It will pass a reference to the original object.  Furthermore, it will not slice the object.  The reference will be of type <code>Base&amp;</code>, but the object to which it refers will be unchanged.</p>\n<p>Just so you know, if you were then to call polymorphic (eg, <code>virtual</code>) methods on this <code>Base&amp;</code>, polymorphism will still work right and do what you'd expect -- just like if you were to call through a pointer.  In other words:</p>\n<pre><code>Base&amp; b = *derived;\nb.SomeVirtualFoo();\n</code></pre>\n<p>...will have the same effect as:</p>\n<pre><code>Base* b = derived;\nb-&gt;SomeVirtualFoo();\n</code></pre>\n", "OwnerUserId": "241536", "PostTypeId": "2", "Id": "8248258", "Score": "9", "CreationDate": "2011-11-23T19:52:21.013", "LastActivityDate": "2011-11-23T19:52:21.013"}, "8248235": {"ParentId": "8248191", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2011-11-23T19:50:41.190", "Score": "5", "LastEditorUserId": "14065", "LastEditDate": "2011-11-23T19:59:58.047", "Id": "8248235", "OwnerUserId": "14065", "Body": "<p>No the first version is correct:</p>\n<pre><code> myfunc(*this);\n</code></pre>\n<p>The second version will probably work in this case but I am not convinced it will work in all cases if multiple inheritance is involved (as you are using a C-Style cast). I have to pull out my standard to look at the exact behavior of C-Style cast. </p>\n<p>If it worked passing by pointer the same technique will work if you convert to using references.</p>\n<h3>Update:</h3>\n<p>Now that I have read the standard I see the C-Cast will do the correct thing (as a static_cast&lt;&gt; can be used to cast up the class hierarchy from child to parent).</p>\n<h3>5.4  Explicit type conversion (cast notation)</h3>\n<blockquote>\n<p id=\"so_8248191_8248235_0\">4 The conversions performed by<br>\n  \u2014 a const_cast (5.2.11),<br>\n  \u2014 a static_cast (5.2.9),<br>\n  \u2014 a static_cast followed by a const_cast,<br>\n  \u2014 a reinterpret_cast (5.2.10), or<br>\n  \u2014 a reinterpret_cast followed by a const_cast,  </br></br></br></br></br></p>\n<p id=\"so_8248191_8248235_1\">can be performed using the cast notation of explicit type conversion. The same semantic restrictions and be- haviors apply, with the exception that in performing a static_cast in the following situations the conversion is valid even if the base class is inaccessible:  </p>\n<p id=\"so_8248191_8248235_2\">\u2014 a pointer to an object of derived class type or an lvalue or rvalue of derived class type may be explicitly converted to a pointer or reference to an unambiguous base class type, respectively;<br>\n  \u2014 a pointer to member of derived class type may be explicitly converted to a pointer to member of an unambiguous non-virtual base class type;<br>\n  \u2014 a pointer to an object of an unambiguous non-virtual base class type, a glvalue of an unambiguous non-virtual base class type, or a pointer to member of an unambiguous non-virtual base class type may be explicitly converted to a pointer, a reference, or a pointer to member of a derived class type, respectively.  </br></br></p>\n<p id=\"so_8248191_8248235_3\">If a conversion can be interpreted in more than one of the ways listed above, the interpretation that appears first in the list is used, even if a cast resulting from that interpretation is ill-formed. If a conversion can be interpreted in more than one way as a static_cast followed by a const_cast, the conversion is ill-formed.</p>\n</blockquote>\n", "LastActivityDate": "2011-11-23T19:59:58.047"}, "8248191": {"CommentCount": "0", "ViewCount": "3177", "CreationDate": "2011-11-23T19:47:24.377", "LastActivityDate": "2011-11-23T19:59:58.047", "Title": "Passing parent object by reference", "AcceptedAnswerId": "8248258", "PostTypeId": "1", "Id": "8248191", "Score": "5", "Body": "<p>I have this code in a library:</p>\n<pre><code>class Parent\n{\n    //some data and functions\n};\n\nvoid myfunc(Parent&amp; ref);\n</code></pre>\n<p>and I want to do this code in my application:</p>\n<pre><code>class Child : public Parent\n{\n   // some other data and functions\n   void dostuff()\n   {\n       myfunc(*this);\n   }\n};\n</code></pre>\n<p>Is it safe to pass *this? (no slicing, no copying, ...)\nIs it better to call myfunc like this:</p>\n<pre><code>myfunc( * ((Parent*)this) )\n</code></pre>\n<p>Note that I don't have control on what happens inside myfunc, in some cases I don't even know what happens inside there.</p>\n<p>I used passing-parent-by-pointer many times and I am used to it, but have never used passing-parent-by-reference before.</p>\n", "Tags": "<c++><oop><inheritance><pass-by-reference>", "OwnerUserId": "231388", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_8248191_8248235_3": {"section_id": 6126, "quality": 1.0, "length": 30}, "so_8248191_8248235_0": {"section_id": 6126, "quality": 0.7333333333333333, "length": 11}, "so_8248191_8248235_1": {"section_id": 6126, "quality": 0.92, "length": 23}, "so_8248191_8248235_2": {"section_id": 6126, "quality": 1.0, "length": 66}}, "n3337": {"so_8248191_8248235_3": {"section_id": 5890, "quality": 1.0, "length": 30}, "so_8248191_8248235_0": {"section_id": 5890, "quality": 0.7333333333333333, "length": 11}, "so_8248191_8248235_1": {"section_id": 5890, "quality": 0.92, "length": 23}, "so_8248191_8248235_2": {"section_id": 5890, "quality": 1.0, "length": 66}}, "n4659": {"so_8248191_8248235_3": {"section_id": 7623, "quality": 1.0, "length": 30}, "so_8248191_8248235_0": {"section_id": 7623, "quality": 0.7333333333333333, "length": 11}, "so_8248191_8248235_2": {"section_id": 7623, "quality": 1.0, "length": 66}, "so_8248191_8248235_1": {"section_id": 7623, "quality": 0.92, "length": 23}}}});