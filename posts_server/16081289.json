post_cb({"16081662": {"Id": "16081662", "PostTypeId": "2", "Body": "<p>[basic.scope.declaration] says that a local variable hides the global, after it's declaration</p>\n<pre><code>int j = 24;\nint main() {\nint i = j, j;\nj = 42;\n}\n</code></pre>\n<blockquote>\n<p id=\"so_16081289_16081662_0\">the identifier j is declared twice as a name (and used twice). The declarative region of the first j includes the entire example. The potential scope of the first j begins immediately after that j and extends to the end of the program, but its (actual) scope excludes the text between the , and the }. The declarative region of the second declaration of j (the j immediately before the semicolon) includes all the text between { and }, but its potential scope excludes the declaration of i. The scope of the second declaration of j is the same as its potential scope.  </p>\n</blockquote>\n<p>This explains why there isn't an error when you declare a local variable.</p>\n<p>When the local variable is not declared, then you have a name clash. The compiler can not decide which <code>fetch</code> to pick, and throws an error.</p>\n", "LastActivityDate": "2013-04-18T11:26:08.093", "CommentCount": "0", "CreationDate": "2013-04-18T11:26:08.093", "ParentId": "16081289", "Score": "2", "OwnerUserId": "476681"}, "16081424": {"Id": "16081424", "PostTypeId": "2", "Body": "<p><code>using namespace</code> will not give priority to names it imports resulting in what you already observed.</p>\n<p>Getting ambiguity error here is language design decision: it would be rather dangerous for such prioritization to exist. Imagine that the <code>Jill</code> namespace is a large one maintained by several developers probably from different organization. You have no or limited control to its contents and still changes to it might silently change the meaning of your program.</p>\n", "LastEditorUserId": "1587418", "LastActivityDate": "2013-04-18T15:02:50.763", "Score": "3", "CreationDate": "2013-04-18T11:15:42.043", "ParentId": "16081289", "CommentCount": "0", "OwnerUserId": "1587418", "LastEditDate": "2013-04-18T15:02:50.763"}, "bq_ids": {"n4140": {"so_16081289_16081535_1": {"length": 17, "quality": 1.0, "section_id": 5514}, "so_16081289_16081535_0": {"length": 7, "quality": 1.0, "section_id": 5511}, "so_16081289_16081662_0": {"length": 50, "quality": 0.9259259259259259, "section_id": 7045}, "so_16081289_16083098_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5510}}, "n3337": {"so_16081289_16081535_1": {"length": 17, "quality": 1.0, "section_id": 5300}, "so_16081289_16081535_0": {"length": 7, "quality": 1.0, "section_id": 5297}, "so_16081289_16081662_0": {"length": 50, "quality": 0.9259259259259259, "section_id": 6790}, "so_16081289_16083098_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5296}}, "n4659": {"so_16081289_16081535_1": {"length": 17, "quality": 1.0, "section_id": 6949}, "so_16081289_16081535_0": {"length": 7, "quality": 1.0, "section_id": 6946}, "so_16081289_16081662_0": {"length": 50, "quality": 0.9259259259259259, "section_id": 8542}, "so_16081289_16083098_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 6945}}}, "16083098": {"Id": "16083098", "PostTypeId": "2", "Body": "<p>The using directive modifies name lookup in a way that isn't exactly intuitive to most programmers. The standard says this in [namespace.udir]p2:</p>\n<blockquote>\n<p id=\"so_16081289_16083098_0\">During unqualified name lookup (3.4.1), the names appear as if they were declared in the nearest enclosing namespace which contains both the using-directive and the nominated namespace.</p>\n</blockquote>\n<p>This wording means that names from the namespace do not appear in the current scope, <em>but in some outer scope</em>. In your example the using directive is in the function which is in the global namespace, and the Jill is also in the global namespace, so the names from Jill appears as if they are in the global namespace. (As Joachim said, the names aren't actually introduced there, so they don't immediately conflict with existing names and <strong>you only get ambiguous lookups when you actually use them</strong>.)</p>\n<p>This is a simple case and the compiler gives you an error, which is good. It can actually get more complicated than that.</p>\n<pre><code>namespace Outer {\n  namespace Mid1 { int i = 1; }\n  namespace Mid2 {\n    namespace Tricky {\n      int i = 2;\n      namespace Inner {\n        void f() {\n          using namespace Mid1;\n          std::cout &lt;&lt; i;\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>This will output 2, not 1, even though you had the using directive right next to the line referring to i. But the nearest enclosing namespace that contains both <code>Mid1</code> and the using directive is <code>Outer</code>, so <code>Mid1::i</code> acts as if it was declared in <code>Outer</code>. If you had an <code>Outer::i</code> it would be shadowed by <code>Tricky::i</code>, and <code>Mid1::i</code> fares no better.</p>\n<p>An easy solution is to ban using directives and only use using declarations and namespace aliases. They're far more intuitive.</p>\n", "LastEditorUserId": "2087705", "LastActivityDate": "2013-04-29T11:52:30.327", "Score": "3", "CreationDate": "2013-04-18T12:33:24.227", "ParentId": "16081289", "CommentCount": "0", "OwnerUserId": "8922", "LastEditDate": "2013-04-29T11:52:30.327"}, "16081535": {"Id": "16081535", "PostTypeId": "2", "Body": "<p>When you declare a local variable shadowing a global/namespace variable, you <em>explicitly</em> tell the compiler about that. However, when you are using <code>using</code> the variables of the namespace doesn't actually end up in the local scope.</p>\n<p>From the specification (section 7.3.4, point 3):</p>\n<blockquote>\n<p id=\"so_16081289_16081535_0\">A <em>using-directive</em> does not add any members to the declarative region in which it appears.</p>\n</blockquote>\n<p>Also (from same section, point 6):</p>\n<blockquote>\n<p id=\"so_16081289_16081535_1\">If name lookup finds a declaration for a name in two different namespaces, and the declarations do not declare the same entity and do not declare functions, the use of the name is ill-formed. </p>\n</blockquote>\n", "LastEditorUserId": "440558", "LastActivityDate": "2013-04-18T11:25:56.493", "Score": "4", "CreationDate": "2013-04-18T11:20:30.557", "ParentId": "16081289", "CommentCount": "0", "OwnerUserId": "440558", "LastEditDate": "2013-04-18T11:25:56.493"}, "16081289": {"ViewCount": "353", "Body": "<p>I am new to namespaces and was trying this from <em>C++ Primer</em></p>\n<pre><code>#include&lt;iostream&gt;\nnamespace Jill \n{\n double bucket;\n double fetch;\n struct Hill{ };\n}\n\ndouble fetch;\n\nint main()\n{\n using namespace Jill;\n Hill Thrill;\n double water = bucket; \n //double fetch; //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;//\n std::cin&gt;&gt; fetch;\n std::cin&gt;&gt; ::fetch;\n std::cin&gt;&gt; Jill::fetch;\n std::cout&lt;&lt;\"fetch is \"&lt;&lt;fetch;\n std::cout&lt;&lt;\"::fetch is \"&lt;&lt; ::fetch;\n std::cout&lt;&lt;\"Jill::fetch is \"&lt;&lt; Jill::fetch;\n}\n\nint foom()\n{\n Jill::Hill top;\n Jill::Hill crest;\n}\n</code></pre>\n<p>When the line marked <code>//&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;//</code> is not commented I get expected results. i.e. the \n<code>local</code> variable hides the <code>global</code> and <code>Jill::fetch</code>. But when I comment it out, there are 2 fetch left . <code>global fetch</code> and <code>Jill::fetch</code>. And the compiler gives the error</p>\n<pre><code>namespaceTrial1.cpp:17:13: error: reference to \u2018fetch\u2019 is ambiguous\nnamespaceTrial1.cpp:9:8: error: candidates are: double fetch\nnamespaceTrial1.cpp:5:9: error:                 double Jill::fetch\nnamespaceTrial1.cpp:20:26: error: reference to \u2018fetch\u2019 is ambiguous\nnamespaceTrial1.cpp:9:8: error: candidates are: double fetch\nnamespaceTrial1.cpp:5:9: error:                 double Jill::fetch\n</code></pre>\n<p>My <strong>question</strong> is why does <strike>the compiler get confused</strike> this lead to ambiguity? Why does it not assume <code>fetch</code> as just <code>Jill::fetch</code> , since I have added <code>using namespace Jill</code> at the start of <code>main()</code> </p>\n<p>If I use declarative <code>using Jill::fetch;</code> at the start of main, the issue gets solved. because <code>using Jill::fetch</code> makes it as if it has been declared at that location. So, its like there is a <code>local fetch</code> variable. [Am i correct?]  Why does <code>using declaration</code> behave as if the variable was declared at that location and <code>using directive</code> doesnt?</p>\n", "AcceptedAnswerId": "16083098", "Title": "Namespaces confusion", "CreationDate": "2013-04-18T11:08:43.277", "Id": "16081289", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2013-04-18T11:20:18.467", "LastEditorUserId": "2087705", "LastActivityDate": "2013-04-29T11:52:30.327", "Score": "5", "OwnerUserId": "2087705", "Tags": "<c++><namespaces>", "AnswerCount": "4"}});