post_cb({"2499999": {"Id": "2499999", "PostTypeId": "2", "Body": "<p>One purpose is that they can be separately defined by the user. So if I want to initialize memory in single heap-allocated objects to 0xFEFEFEFE and memory in heap-allocated arrays to 0xEFEFEFEF, because I think it will help me with debugging, then I can.</p>\n<p>Whether that's worth it is another matter. I guess if your particular program mostly uses quite small objects, and quite large arrays, then you could allocate off different heaps in the hope that this will reduce fragmentation. But equally you could identify the classes which you allocate large arrays of, and just override <code>operator new[]</code> for those classes. Or <code>operator new</code> could switch between different heaps based on the size.</p>\n<p>There is actually a difference in the wording of the requirements. One allocates memory aligned for any object of the specified size, the other allocates memory aligned for any array of the specified size. I don't think there's any difference - an array of size 1 surely has the same alignment as an object - but I could be mistaken. The fact that by default the array version returns the same as the object version strongly suggests there is no difference. Or at least that the alignment requirements on an object are stricter than those on an array, which I can't make any sense of...</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2010-03-23T13:23:30.013", "Score": "5", "CreationDate": "2010-03-23T12:58:06.903", "ParentId": "2499895", "CommentCount": "9", "OwnerUserId": "13005", "LastEditDate": "2010-03-23T13:23:30.013"}, "2499895": {"ViewCount": "682", "Body": "<p>Looks like <code>operator new</code> and <code>operator new[]</code> have exactly the same signature:</p>\n<pre><code>void* operator new( size_t size );\nvoid* operator new[]( size_t size );\n</code></pre>\n<p>and do exactly the same: either return a pointer to a big enough block of raw (not initialized in any way) memory or throw an exception.</p>\n<p>Also <code>operator new</code> is called internally when I create an object with <code>new</code> and <code>operator new[]</code> - when I create an array of objects with <code>new[]</code>. Still the above two special functions are called by C++ internally in exactly the same manner and I don't see how the two calls can have different meanings.</p>\n<p>What's the purpose of having two different functions with exactly the same signatures and exactly the same behavior?</p>\n", "AcceptedAnswerId": "2500544", "Title": "What's the purpose of having a separate \"operator new[]\"?", "CreationDate": "2010-03-23T12:43:03.417", "Id": "2499895", "CommentCount": "0", "LastEditDate": "2010-03-25T11:12:38.950", "PostTypeId": "1", "LastEditorUserId": "57428", "LastActivityDate": "2010-03-25T11:12:38.950", "Score": "12", "OwnerUserId": "57428", "Tags": "<c++><memory-management>", "AnswerCount": "5"}, "2499977": {"Id": "2499977", "PostTypeId": "2", "Body": "<p>The operators can be overridden (for a specific class, or within a namespace, or globally), and this allows you to provide separate versions if you want to treat object allocations differently from array allocations. For example, you might want to allocate from different memory pools.</p>\n", "LastActivityDate": "2010-03-23T12:55:05.637", "CommentCount": "0", "CreationDate": "2010-03-23T12:55:05.637", "ParentId": "2499895", "Score": "7", "OwnerUserId": "204847"}, "bq_ids": {"n4140": {"so_2499895_2500002_0": {"length": 41, "quality": 0.8723404255319149, "section_id": 7174}}, "n3337": {"so_2499895_2500002_0": {"length": 41, "quality": 0.8723404255319149, "section_id": 6918}}, "n4659": {"so_2499895_2500002_0": {"length": 41, "quality": 0.8723404255319149, "section_id": 8682}}}, "2499987": {"Id": "2499987", "PostTypeId": "2", "Body": "<p>I've had a reasonably good look at this, and to be blunt there's no reason from an interface standpoint.</p>\n<p>The only possible reason that I can think of is to allow an optimization hint for the implementation, <code>operator new[]</code> is <em>likely</em> to be called upon to allocate larger blocks of memory; but that is a really, really tenuous supposition as you could <code>new</code> a very large structure or <code>new char[2]</code> which doesn't really count as large.</p>\n<p>Note that <code>operator new[]</code> doesn't add any magic extra storage for the array count or anything. It is the job of the <code>new[]</code> operator to work out how much overhead (if any) is needed and to pass the correct byte count to <code>operator new[]</code>.</p>\n<p>[A test with gcc indicates that no extra storage is needed by <code>new[]</code> unless the type of the array members being constructed have a non-trivial desctructor.]</p>\n<p>From an interface and contract standpoint (other than require the use of the correct corresponding deallocation function) <code>operator new</code> and <code>operator new[]</code> are identical.</p>\n", "LastActivityDate": "2010-03-23T12:56:40.193", "CommentCount": "2", "CreationDate": "2010-03-23T12:56:40.193", "ParentId": "2499895", "Score": "7", "OwnerUserId": "19563"}, "2500544": {"Id": "2500544", "PostTypeId": "2", "Body": "<p>In Design and Evolution of C++ (section 10.3), Stroustrup mentions that if the new operator for object X was itself used for allocating an array of object X, then the writer of X::operator new() would have to deal with array allocation too, which is not the common usage for new() and add complexity. So, it was not considered to use new() for array allocation. Then, there was no easy way to allocate different storage areas for dynamic arrays. The solution was to provide separate allocator and deallocator methods for arrays: new[] and delete[].</p>\n", "LastActivityDate": "2010-03-23T14:11:27.440", "CommentCount": "1", "CreationDate": "2010-03-23T14:11:27.440", "ParentId": "2499895", "Score": "6", "OwnerUserId": "105936"}, "2500002": {"Id": "2500002", "PostTypeId": "2", "Body": "<p>Standard says that <code>new T</code> calls <code>operator new( )</code> and <code>new T[ ]</code> results in a call of <code>operator new[]( )</code>. You could overload them if you want. I believe that there is no difference between them by default. Standard says that they are replaceable (3.7.3/2):</p>\n<blockquote>\n<p id=\"so_2499895_2500002_0\">The library provides default definitions for the global allocation and deallocation functions. Some global\n  allocation and deallocation functions are replaceable (18.4.1). A C + + program shall provide at most one\n  definition of a replaceable allocation or deallocation function. Any such function definition replaces the\n  default version provided in the library (17.4.3.4). The following allocation and deallocation functions\n  (18.4) are implicitly declared in global scope in each translation unit of a program  </p>\n<pre><code>void* operator new(std::size_t) throw(std::bad_alloc);  \nvoid* operator new[](std::size_t) throw(std::bad_alloc);  \nvoid operator delete(void*) throw();  \nvoid operator delete[](void*) throw();  \n</code></pre>\n</blockquote>\n", "LastEditorUserId": "123111", "LastActivityDate": "2010-03-23T13:10:36.303", "Score": "1", "CreationDate": "2010-03-23T12:58:36.547", "ParentId": "2499895", "CommentCount": "0", "OwnerUserId": "123111", "LastEditDate": "2010-03-23T13:10:36.303"}});