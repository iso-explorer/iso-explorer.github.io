post_cb({"34700396": {"ParentId": "34699569", "CommentCount": "0", "Body": "<p>There is no good reason to allow it, although I am not sure whether there is or not a strong technical reason for the limitation. In C++98 restrictions were added on types that can be used as template arguments that might have been stronger than needed, partly due to fear of unknown (<em>how can we handle mangling of types that have no name?</em>).</p>\n<p>C++11 added lambdas to the language, which can be used in templates. Lambdas are local types, and thus the limitation on local types has been lifted. But they are not <em>unnamed</em>, their names are just <em>unutterable</em> and generated by the compiler. </p>\n<p>The same techniques to generate those names and use them for mangling may be usable in your particular case, although they may not be generalizable for all unnamed types --compilers generate lambda names using among other information the function name, which due to ODR is guaranteed to allow for unique names. In the general case an unnamed type could be created at namespace level, where it would be harder to determine the right way of mangling the type.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "34700396", "Score": "0", "CreationDate": "2016-01-09T23:57:39.120", "LastActivityDate": "2016-01-09T23:57:39.120"}, "34699569": {"CommentCount": "3", "ViewCount": "563", "PostTypeId": "1", "LastEditorUserId": "2604712", "CreationDate": "2016-01-09T22:16:02.430", "LastActivityDate": "2016-01-10T05:40:30.853", "Title": "Defining a class in a template argument, why is it invalid?", "LastEditDate": "2016-01-09T22:19:34.577", "Id": "34699569", "Score": "2", "Body": "<p>Suppose the code:</p>\n<pre><code>template &lt;class T&gt;\nclass X {  };\n\nint main(void) {\n    X&lt;class {\n        int a;\n    }&gt; x;\n    return 0;\n}\n</code></pre>\n<p>g++ 5.1 gives the following error message:</p>\n<pre><code>prog.cpp: In function 'int main()':\nprog.cpp:5:10: error: types may not be defined in template arguments\n  X&lt;class {\n          ^\nprog.cpp:7:2: error: expected ';' after class definition\n  }&gt; x;\n  ^\nprog.cpp:7:2: error: expected template-argument before ';' token\nprog.cpp:7:2: error: expected '&gt;' before ';' token\nprog.cpp:7:2: error: 'main()::&lt;anonymous class&gt;' is/uses anonymous type\nprog.cpp:7:2: error:   trying to instantiate 'template&lt;class T&gt; class X'\nprog.cpp:7:2: error: expected '::' before ';' token\nprog.cpp:7:2: error: expected identifier before ';' token\nprog.cpp:7:3: error: expected primary-expression before '&gt;' token\n  }&gt; x;\n   ^\nprog.cpp:7:5: error: 'x' was not declared in this scope\n  }&gt; x;\n     ^\n</code></pre>\n<p>The second line of the error output says that we can't define types in template arguments. Why is it invalid? (I mean, I know it's invalid in the standard, but what's the reason for that?)</p>\n", "Tags": "<c++>", "OwnerUserId": "2604712", "AnswerCount": "3"}, "34699705": {"ParentId": "34699569", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>There are several errors in the lines:</p>\n<pre><code>X&lt;class {\n    int a;\n}&gt; x;\n</code></pre>\n<ol>\n<li>You are trying to define a class in a place where it is not legal.</li>\n<li>You are not giving a typename to instantiate <code>X</code>.</li>\n<li>You are trying to use an unnamed class to instantiate <code>X</code>.</li>\n</ol>\n<p>The simplest fix is to use:</p>\n<pre><code>struct A { int a; };\nX&lt;A&gt; x;\n</code></pre>\n<p>if you are able to use a C++11 compiler. If you don't have access to a C++11 compiler, you need to move the definition of <code>struct A</code> outside <code>main</code>.</p>\n<p><strong>Update, in response to OP's comment</strong></p>\n<p>Allowing the syntax you are suggesting involves a significant change to the syntax for defining a class. Currently, you need a statement to define a class, even an unnamed class.</p>\n<pre><code>struct A { ... } ;\n            //   ^^ Need this to define a class/struct\n\nstruct { ... } obj ;\n               //  ^^ Need this to define an unnamed class/struct too.\n</code></pre>\n<p>With your code</p>\n<pre><code>X&lt;class {int a} &gt; x;\n          //  ^^ There is no scope for a statement.         \n</code></pre>\n", "OwnerUserId": "434551", "LastEditorUserId": "434551", "LastEditDate": "2016-01-10T05:40:30.853", "Id": "34699705", "Score": "0", "CreationDate": "2016-01-09T22:31:16.910", "LastActivityDate": "2016-01-10T05:40:30.853"}, "bq_ids": {"n4140": {"so_34699569_34699606_0": {"section_id": 7141, "quality": 0.6666666666666666, "length": 8}}, "n3337": {"so_34699569_34699606_0": {"section_id": 6885, "quality": 0.6666666666666666, "length": 8}}, "n4659": {"so_34699569_34699606_0": {"section_id": 8642, "quality": 0.6666666666666666, "length": 8}}}, "34699606": {"ParentId": "34699569", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>\u00a714.3.1/2 from the C++ 03 standard says:</p>\n<blockquote>\n<p id=\"so_34699569_34699606_0\">A local type, a type with no linkage, an unnamed type or a type\n  compounded from any of these types shall not be used as a\n  template-argument for a template type-parameter.</p>\n</blockquote>\n<p>Which basically means you can't do what you tried to do - using an unnamed type as a template argument.</p>\n<p>I'm pretty sure the C++ 11 and C++ 14 standards did not revise that paragraph, but feel free to verify that.</p>\n<p>Update: C++ 11 did lift the local type restriction - that's allowed for template parameters now, but not the anonymous type: <a href=\"https://stackoverflow.com/a/4573104/634821\">https://stackoverflow.com/a/4573104/634821</a></p>\n", "OwnerUserId": "634821", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:33:19.053", "Id": "34699606", "Score": "4", "CreationDate": "2016-01-09T22:19:20.543", "LastActivityDate": "2016-01-09T22:27:47.670"}});