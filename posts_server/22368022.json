post_cb({"22368022": {"CommentCount": "1", "AcceptedAnswerId": "22368023", "PostTypeId": "1", "LastEditorUserId": "1090079", "CreationDate": "2014-03-13T02:38:22.433", "LastActivityDate": "2015-05-13T14:35:27.243", "LastEditDate": "2014-03-15T09:19:20.273", "ViewCount": "2594", "FavoriteCount": "14", "Title": "Why does the order of template argument substitution matter?", "Id": "22368022", "Score": "55", "Body": "<p><strong>C++11</strong></p>\n<blockquote>\n<p id=\"so_22368022_22368022_0\">14.8.2 - <strong>Template Argument Deduction</strong> - <code>[temp.deduct]</code><br/></p>\n<blockquote>\n<p id=\"so_22368022_22368022_2\"><sup>7</sup> The substitution occurs in all types and expressions that are used in the function type and in template parameter declarations. The expressions include not only constant expressions such as those that appear in array bounds or as nontype template arguments but also general expressions (ie. non-constant expressions) inside <code>sizeof</code>, <code>decltype</code>, and other contexts that allow non-constant expressions.</p>\n</blockquote>\n</blockquote>\n<hr>\n<p><strong>C++14</strong></p>\n<blockquote>\n<p id=\"so_22368022_22368022_3\">14.8.2 - <strong>Template Argument Deduction</strong> - <code>[temp.deduct]</code><br/></p>\n<blockquote>\n<p id=\"so_22368022_22368022_5\"><sup>7</sup> The substitution occurs in all types and expressions that are used in the function type and in template parameter declarations. The expressions include not only constant expressions such as those that appear in array bounds or as nontype template arguments but also general expressions (ie. non-constant expressions) inside <code>sizeof</code>, <code>decltype</code>, and other contexts that allow non-constant expressions. <strong>The substitution proceeds in lexical order and stops when a condition that causes deduction to fail is encountered</strong>.</p>\n</blockquote>\n</blockquote>\n<hr>\n<hr>\n<p>The added sentence explicitly states the order of substitution when dealing with template parameters in C++14.</p>\n<p>The order of substitution is something that most often isn't given a lot of attention. I have yet to find a single paper on why this matters. Maybe this is because C++1y hasn't been fully standardized yet, but I'm assuming such a change must have been introduced for a reason. </p>\n<p><strong>The question:</strong></p>\n<ul>\n<li>Why, and when, does the order of template argument substitution matter?</li>\n</ul>\n</hr></hr></hr>", "Tags": "<c++><templates><c++11><language-lawyer><c++14>", "OwnerUserId": "1090079", "AnswerCount": "1"}, "22368023": {"ParentId": "22368022", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>As stated C++14 explicitly says that the order of template argument substitution is well-defined; more specifically it will be guaranteed to proceed in <em>\"lexical order</em> and halt whenever a substitution causes the deduction to fail. </p>\n<p>Compared to C++11 it will be much easier to write <em>SFINAE</em>-code that consists of one rule depending on another in C++14, we will also move away from cases where undefined ordering of template substitution can make our entire application suffer from undefined-behaviour.</p>\n<p><sup><strong>Note</strong>: It's important to note that the behavior described in C++14 has always been the intended behavior, even in C++11, just that it hasn't been worded in such an explicit way.</sup></p>\n<hr>\n<hr>\n<h2>What is the rationale behind such change?</h2>\n<p>The original reason behind this change can be found in a <em>defect report</em> originally submitted by <em>Daniel Kr\u00fcgler</em>:</p>\n<ul>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html\"><strong>C++ Standard Core Language Defect Reports and Accepted Issues, Revision 88</strong></a>\n<ul>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1227\">1227. Mixing immediate and non-immediate contexts in deduction failure </a></li>\n</ul></li>\n</ul>\n<hr>\n<p><strong>FURTHER EXPLANATION</strong></p>\n<p>When writing <em>SFINAE</em> we as developers depend on the compiler to find any substitution that would yield an invalid <em>type</em> or <em>expression</em> in our template when used. If such invalid entity is found we'd like to disregard whatever the template is declaring and move on to hopefully find a suitable match.</p>\n<p><em>Substitution Failure Is Not An Error</em>, but a mere.. <em>\"aw, this didn't work.. please move on\"</em>.</p>\n<p>The problem is that potential invalid types and expressions are only looked for in the <em>immediate context</em> of the substitution.</p>\n<blockquote>\n<p id=\"so_22368022_22368023_0\">14.8.2 - <strong>Template Argument Deduction</strong> - <code>[temp.deduct]</code></p>\n<blockquote>\n<p id=\"so_22368022_22368023_5\"><sup>8</sup> If a substitution results in an invalid type or expression, type deduction fails. An invalid type or expression is one that would be ill-formed if written using the substituted arguments.</p>\n<p id=\"so_22368022_22368023_6\"><sup>[ <strong>Note:</strong> Access checking is done as part of the substitution process. <strong>--end note</strong> ]</sup></p>\n<p id=\"so_22368022_22368023_7\"><strong>Only invalid types and expressions in the immediate context of the function type and its template parameter types can result in a deduction failure.</strong></p>\n<p id=\"so_22368022_22368023_8\"><sup>[ <strong>Note:</strong> The evaluation of the substituted types and expressions can result in side effects such as the instantiation of class template specializations and/or function template specializations, the generation of implicitly-defined functions, etc. Such side effects are not in the \"immediate context\" and can result in the program being ill-formed. <strong>--end note</strong>]</sup></p>\n</blockquote>\n</blockquote>\n<p>In other words a substitution that occurs in a <em>non-immediate context</em> will still render the program ill-formed, which is why the order of template substitutions is important; it can change the whole meaning of a certain template.</p>\n<p>More specifically it can be the difference between having a template which <strong>is</strong> usable in SFINAE, and a template which <strong>isn't</strong>.</p>\n<hr>\n<p><strong>SILLY EXAMPLE</strong></p>\n<pre><code>template&lt;typename SomeType&gt;\nstruct inner_type { typedef typename SomeType::type type; };\n</code></pre>\n<p><sup></sup></p>\n<pre><code>template&lt;\n  class T,\n  class   = typename T::type,            // (E)\n  class U = typename inner_type&lt;T&gt;::type // (F)\n&gt; void foo (int);                        // preferred\n</code></pre>\n<p><sup></sup></p>\n<pre><code>template&lt;class&gt; void foo (...);          // fallback\n</code></pre>\n<p><sup></sup></p>\n<pre><code>struct A {                 };  \nstruct B { using type = A; };\n\nint main () {\n  foo&lt;A&gt; (0); // (G), should call \"fallback \"\n  foo&lt;B&gt; (0); // (H), should call \"preferred\"\n}\n</code></pre>\n<p>On the line marked <code>(G)</code> we want the compiler to first check <code>(E)</code> and if that succeeds evaluate <code>(F)</code>, but before the standard change discussed in this post there was no such guarantee.</p>\n<p><br/></p>\n<p>The immediate context of the substitutions in <code>foo(int)</code> includes;</p>\n<ul>\n<li><code>(E)</code> making sure that the passed in <code>T</code> has <code>::type</code></li>\n<li><code>(F)</code> making sure that <code>inner_type&lt;T&gt;</code> has <code>::type</code></li>\n</ul>\n<p><br/></p>\n<p>If <code>(F)</code> is evaluated even though <code>(E)</code> results in an invalid substitution, or if <code>(F)</code> is evaluated before <code>(E)</code> our short (silly) example won't make use of SFINAE and we will get an diagnostic saying that our application is ill-formed.. even though we intended for <code>foo(...)</code> to be used in such case.</p>\n<p><br/></p>\n<p><sup><strong>Note:</strong> Notice that <code>SomeType::type</code> is not in the <em>immediate context</em> of the template; a failure in the <em>typedef</em> inside <code>inner_type</code> will render the application ill-formed and prevent the template from making use of <em>SFINAE</em>.</sup></p>\n<hr>\n<hr>\n<h2>What implications will this have on code development in C++14?</h2>\n<p>The change will dramatically ease the life of <em>language-lawyers</em> trying to implement something which is guaranteed to be evaluated in a certain way (and order), no matter what conforming compiler they are using.</p>\n<p>It will also make template argument substitution behave in a more natural way to <em>non-language-lawyers</em>; having the substitution occur from <em>left-to-right</em> is far more intuitive than <em>erhm-like-any-way-the-compiler-wanna-do-it-like-erhm-...</em>.</p>\n<hr>\n<p><strong>Isn't there any negative implication?</strong></p>\n<p>The only thing I can think of is that since the order of substitution will occur from <em>left-to-right</em> a compiler is not permitted to handle multiple substitutions at once using an asynchronous implementation.</p>\n<p>I have yet to stumble across such implementation, and I doubt that it would result in any major performance gain, but at least the thought (in theory) kinda fits on the \"negative\" side of things.</p>\n<p>As an example: A compiler will not be able to use two threads that simultaneously does substitutions when instantating a certain template without any mechanism to act like the substitutions that occured after a certain point never happened, if that is required.</p>\n<hr>\n<hr>\n<h2>The story</h2>\n<p><sup><strong>Note</strong>: An example that could have been taken from real life will be presented in this section to describe when and why the order of template argument substitution matters. Please let me know (using the comment section) if anything is not clear enough, or maybe even wrong.</sup></p>\n<p>Imagine that we are working with <em>enumerators</em> and that we'd like a way to easily obtain the <em><strong>underlying</strong> value</em> of the specified <em><strong>enumeration</strong></em>.</p>\n<p>Basically we are sick and tired of always having to write <code>(A)</code>, when we would ideally want something closer to <code>(B)</code>.</p>\n<pre><code>auto value = static_cast&lt;std::underlying_type&lt;EnumType&gt;::type&gt; (SOME_ENUM_VALUE); // (A)\n</code></pre>\n<p><sup></sup></p>\n<pre><code>auto value = underlying_value (SOME_ENUM_VALUE);                                  // (B)\n</code></pre>\n<hr>\n<p><strong>THE ORIGINAL IMPLEMENTATION</strong></p>\n<p>Said and done, we decide to write an implementation of <code>underlying_value</code> looking as the below.</p>\n<pre><code>template&lt;class T, class U = typename std::underlying_type&lt;T&gt;::type&gt; \nU underlying_value (T enum_value) { return static_cast&lt;U&gt; (enum_value); }\n</code></pre>\n<p>This will ease our pain, and seems to do exactly what we want; we pass in an enumerator, and get the underlying value back.</p>\n<p>We tell ourselves that this implementation is awesome and ask a colleague of ours (<em>Don Quixote</em>) to sit down and review our implementation before pushing it out into production.</p>\n<hr>\n<p><strong>THE CODE REVIEW</strong></p>\n<p><em>Don Quixote</em> is an experienced C++ developer that has a cup of coffee in one hand, and the C++ standard in the other. It's a mystery how he manages to write a single line of code with both hands busy, but that's a different story.</p>\n<p>He reviews our code and comes to the conclusion that the implementation is unsafe, we need to guard <code>std::underlying_type</code> from undefined-behaviour since we can pass in a <code>T</code> which is not of <em>enumeration type</em>.</p>\n<blockquote>\n<p id=\"so_22368022_22368023_9\">20.10.7.6 - <strong>Other Transformations</strong> - <code>[meta.trans.other]</code></p>\n<blockquote>\n<pre><code>template&lt;class T&gt; struct underlying_type;\n</code></pre>\n<p id=\"so_22368022_22368023_11\"><strong>Condition:</strong> <code>T</code> shall be an enumeration type (7.2) <br/>\n<strong>Comments:</strong> The member typedef <code>type</code> shall name the underlying type of <code>T</code>.</p>\n</blockquote>\n</blockquote>\n<p><sup> <strong>Note:</strong> The standard specifies a <em>condition</em> for <code>underlying_type</code>, but it doesn't go any further to specifiy what will happen if it's instantiated with a <em>non-enum</em>. Since we don't know what will happen in such case the usage falls under <em>undefined-behavior</em>; it could be pure <em>UB</em>, make the application ill-formed, or order edible underwear online.</sup></p>\n<hr>\n<p><strong>THE KNIGHT IN SHINING ARMOUR</strong></p>\n<p>Don yells something about how we always should honor the C++ standard, and that we should feel tremendous shame for what we have done.. it's unacceptable.</p>\n<p>After he has calmed down, and had a few more sips of coffee, he suggests that we change the implementation to add protection against instantiating <code>std::underlying_type</code> with something which isn't allowed. </p>\n<pre><code>template&lt;\n  typename T,\n  typename   = typename std::enable_if&lt;std::is_enum&lt;T&gt;::value&gt;::type,  // (C)\n  typename U = typename std::underlying_type&lt;T&gt;::type                  // (D)\n&gt;\nU underlying_value (T value) { return static_cast&lt;U&gt; (value); }\n</code></pre>\n<hr>\n<p><strong>THE WINDMILL</strong></p>\n<p>We thank Don for his discoveries and are now satisfied with our implementation, but only until we realize that the order of template argument substitution isn't well-defined in C++11 (nor is it stated when the substitution will stop).</p>\n<p>Compiled as C++11 our implementation can still cause an instantiation of <code>std::underlying_type</code> with a <code>T</code> that isn't of <em>enumeration</em> type because of two reasons:</p>\n<ol>\n<li><p>The compiler is free to evaluate <code>(D)</code> before <code>(C)</code> since the substitution order isn't well-defined, and;</p></li>\n<li><p>even if the compiler evaluates <code>(C)</code> before <code>(D)</code>, it's not guaranteed that it won't evaluate <code>(D)</code>, C++11 doesn't have a clause explicitly saying when the substitution chain must stop.</p></li>\n</ol>\n<hr>\n<p>The implementation by Don will be free from <em>undefined-behavior</em> in C++14, but only because C++14 explicitly states that the substitution will <em>proceed in lexical order</em>, and that it will <em>halt whenever a substitution causes deduction to fail</em>.</p>\n<p>Don might not be fighting windmills on this one, but he surely missed a very important dragon in the C++11 standard.</p>\n<p>A valid implementation in C++11 would need to make sure that no matter the order in which the substitution of template parameters occur the instantation of <code>std::underlying_type</code> won't be with an invalid type.</p>\n<pre><code>#include &lt;type_traits&gt;\n\nnamespace impl {\n  template&lt;bool B, typename T&gt;\n  struct underlying_type { };\n\n  template&lt;typename T&gt;\n  struct underlying_type&lt;true, T&gt;\n    : std::underlying_type&lt;T&gt;\n  { };\n}\n\ntemplate&lt;typename T&gt;\nstruct underlying_type_if_enum\n  : impl::underlying_type&lt;std::is_enum&lt;T&gt;::value, T&gt;\n{ };\n\ntemplate&lt;typename T, typename U = typename underlying_type_if_enum&lt;T&gt;::type&gt;\nU get_underlying_value (T value) {\n  return static_cast&lt;U&gt; (value);  \n}\n</code></pre>\n<hr>\n<p><sup><strong>Note:</strong> <code>underlying_type</code> was used because it's a simple way to use something in the standard against what is in the standard; the important bit is that instantiating it with a <em>non-enum</em> is <em>undefined behavior</em>.</sup></p>\n<p><sup>The <em>defect-report</em> previously linked in this post uses a much more complex example which assumes extensive knowledge about the matter. I hope this story is a more suitable explanation for those who are not well read up on the subject.</sup></p>\n</hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr>", "OwnerUserId": "1090079", "LastEditorUserId": "90002", "LastEditDate": "2015-05-13T14:35:27.243", "Id": "22368023", "Score": "57", "CreationDate": "2014-03-13T02:38:22.433", "LastActivityDate": "2015-05-13T14:35:27.243"}, "bq_ids": {"n4140": {"so_22368022_22368023_6": {"section_id": 300, "quality": 0.6666666666666666, "length": 6}, "so_22368022_22368022_2": {"section_id": 299, "quality": 0.9473684210526315, "length": 36}, "so_22368022_22368023_7": {"section_id": 300, "quality": 0.9375, "length": 15}, "so_22368022_22368023_3": {"section_id": 300, "quality": 0.9375, "length": 15}, "so_22368022_22368023_4": {"section_id": 300, "quality": 0.8823529411764706, "length": 30}, "so_22368022_22368022_5": {"section_id": 299, "quality": 0.94, "length": 47}, "so_22368022_22368022_1": {"section_id": 299, "quality": 0.9473684210526315, "length": 36}, "so_22368022_22368023_1": {"section_id": 300, "quality": 1.0, "length": 18}, "so_22368022_22368022_4": {"section_id": 299, "quality": 0.94, "length": 47}, "so_22368022_22368023_5": {"section_id": 300, "quality": 1.0, "length": 18}, "so_22368022_22368023_2": {"section_id": 300, "quality": 0.6666666666666666, "length": 6}, "so_22368022_22368023_8": {"section_id": 300, "quality": 0.8823529411764706, "length": 30}}, "n3337": {"so_22368022_22368023_6": {"section_id": 291, "quality": 0.6666666666666666, "length": 6}, "so_22368022_22368022_2": {"section_id": 290, "quality": 0.9473684210526315, "length": 36}, "so_22368022_22368023_7": {"section_id": 291, "quality": 0.9375, "length": 15}, "so_22368022_22368023_3": {"section_id": 291, "quality": 0.9375, "length": 15}, "so_22368022_22368023_4": {"section_id": 291, "quality": 0.8823529411764706, "length": 30}, "so_22368022_22368022_5": {"section_id": 290, "quality": 0.76, "length": 38}, "so_22368022_22368022_1": {"section_id": 290, "quality": 0.9473684210526315, "length": 36}, "so_22368022_22368023_1": {"section_id": 291, "quality": 1.0, "length": 18}, "so_22368022_22368022_4": {"section_id": 290, "quality": 0.76, "length": 38}, "so_22368022_22368023_5": {"section_id": 291, "quality": 1.0, "length": 18}, "so_22368022_22368023_2": {"section_id": 291, "quality": 0.6666666666666666, "length": 6}, "so_22368022_22368023_8": {"section_id": 291, "quality": 0.8823529411764706, "length": 30}}, "n4659": {"so_22368022_22368023_6": {"section_id": 307, "quality": 0.6666666666666666, "length": 6}, "so_22368022_22368022_2": {"section_id": 306, "quality": 0.9473684210526315, "length": 36}, "so_22368022_22368023_7": {"section_id": 307, "quality": 0.9375, "length": 15}, "so_22368022_22368023_8": {"section_id": 307, "quality": 0.7941176470588235, "length": 27}, "so_22368022_22368023_3": {"section_id": 307, "quality": 0.9375, "length": 15}, "so_22368022_22368023_4": {"section_id": 307, "quality": 0.7941176470588235, "length": 27}, "so_22368022_22368022_5": {"section_id": 306, "quality": 0.94, "length": 47}, "so_22368022_22368022_1": {"section_id": 306, "quality": 0.9473684210526315, "length": 36}, "so_22368022_22368023_1": {"section_id": 307, "quality": 1.0, "length": 18}, "so_22368022_22368022_4": {"section_id": 306, "quality": 0.94, "length": 47}, "so_22368022_22368023_5": {"section_id": 307, "quality": 1.0, "length": 18}, "so_22368022_22368023_2": {"section_id": 307, "quality": 0.6666666666666666, "length": 6}}}});