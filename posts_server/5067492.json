post_cb({"5067749": {"ParentId": "5067492", "LastEditDate": "2011-02-21T16:12:44.630", "CommentCount": "1", "CreationDate": "2011-02-21T15:25:20.363", "OwnerUserId": "179910", "LastEditorUserId": "179910", "PostTypeId": "2", "Id": "5067749", "Score": "22", "Body": "<p>As @MSalters pointed out, some platforms work more efficiently with larger data items. </p>\n<p>Many \"RISC\" CPUs (e.g., MIPS, PowerPC, early versions of the Alpha) have/had a considerably more difficult time working with data smaller than one word, so they do the same. IIRC, with at least some compilers on the Alpha a bool actually occupied 64 bits.</p>\n<p>gcc for PowerPC Macs defaulted to using 4 bytes for a bool, but had a switch to change that to one byte if you wanted to.</p>\n<p>Even for the x86, there's some advantage to using a 32-bit data item. gcc for the x86 has (or at least used to have -- I haven't looked recently at all) a define in one of its configuration files for <code>BOOL_TYPE_SIZE</code> (going from memory, so I could have that name a little wrong) that you could set to 1 or 4, and then re-compile the compiler to get a bool of that size.</p>\n<p>Edit: As for the reason behind this, I'd say it's a simple reflection of a basic philosophy of C and C++: leave as much room for the implementation to optimize/customize its behavior as reasonable. Require specific behavior only when/if there's an obvious, tangible benefit, and unlikely to be any major liability, especially if the change would make it substantially more difficult to support C++ on some particular platform (though, of course, if the platform is sufficiently obscure, it might get ignored).</p>\n", "LastActivityDate": "2011-02-21T16:12:44.630"}, "21146344": {"ParentId": "5067492", "CommentCount": "3", "Body": "<p>The operation resulted in 'sizeof' is MADUs (minimal addresible unit), not bytes. So family processors C54 *. C55 * Texas Instuments, the expression 1 MADU = 2 bytes. </p>\n<p>For this platform sizeof (bool) = sizeof (char) = 1 MADUs = 2 bytes.\nThis does not violate the C + + standard, but clarifies the situation.</p>\n", "OwnerUserId": "2697341", "PostTypeId": "2", "Id": "21146344", "Score": "1", "CreationDate": "2014-01-15T19:21:57.550", "LastActivityDate": "2014-01-15T19:21:57.550"}, "5067535": {"ParentId": "5067492", "CommentCount": "0", "Body": "<p>The other likely size for it is that of <code>int</code>, being the \"efficient\" integer type for the platform.</p>\n<p>On architectures where it makes any difference whether the implementation chooses 1 or <code>sizeof(int)</code> there could be a trade-off between size (but if you're happy to waste 7 bits per <code>bool</code>, why shouldn't you be happy to waste 31? Use bitfields when size matters) vs. performance (but when is storing and loading bool values going to be a genuine performance issue? Use <code>int</code> explicitly when speed matters). So implementation flexibility wins - if for some reason <code>1</code> would be atrocious in terms of performance or code size, it can avoid it.</p>\n", "OwnerUserId": "13005", "PostTypeId": "2", "Id": "5067535", "Score": "27", "CreationDate": "2011-02-21T15:05:30.293", "LastActivityDate": "2011-02-21T15:05:30.293"}, "5067492": {"CommentCount": "6", "CreationDate": "2011-02-21T15:01:57.380", "PostTypeId": "1", "AcceptedAnswerId": "5067545", "LastEditorUserId": "-1", "LastActivityDate": "2014-01-15T19:21:57.550", "LastEditDate": "2017-05-23T12:26:09.273", "ViewCount": "12469", "FavoriteCount": "2", "Title": "Why the sizeof(bool) is not defined to be one, by the Standard itself?", "Id": "5067492", "Score": "32", "Body": "<p>Size of <code>char</code>, <code>signed char</code> and <code>unsigned char</code> is defined to be 1 byte, by the C++ Standard itself. I'm wondering why it didn't define the <code>sizeof(bool)</code> also?</p>\n<p>C++03 Standard $5.3.3/1 says,</p>\n<blockquote>\n<p id=\"so_5067492_5067492_0\">sizeof(char), sizeof(signed char) and\n  sizeof(unsigned char) are 1; the\n  result of sizeof applied to <strong>any other</strong>\n  fundamental type (3.9.1) is\n  implementation-defined. [Note: <strong>in\n  particular,sizeof(bool) and\n  sizeof(wchar_t) are\n  implementation-defined</strong>.69)</p>\n</blockquote>\n<p>I understand the rationale that <a href=\"https://stackoverflow.com/questions/4626815/why-is-a-boolean-1-byte-and-not-1-bit-of-size/4626993#4626993\">sizeof(bool) cannot be less than one byte</a>. But is there any rationale why it should be greater than 1 byte either? I'm not saying that implementations define it to be greater than 1, but the Standard left it to be defined by implementation <strong>as if it may be greater than 1.</strong> </p>\n<p>If there is no reason <code>sizeof(bool)</code> to be greater than 1, then I don't understand why the Standard didn't define it as just <code>1 byte</code>, as it has defined <code>sizeof(char)</code>, and it's all variants.</p>\n", "Tags": "<c++><boolean><standards><sizeof>", "OwnerUserId": "415784", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_5067492_5067492_0": {"section_id": 6076, "quality": 0.7058823529411765, "length": 12}}, "n3337": {"so_5067492_5067492_0": {"section_id": 5844, "quality": 0.7058823529411765, "length": 12}}, "n4659": {"so_5067492_5067492_0": {"section_id": 7572, "quality": 0.7058823529411765, "length": 12}}}, "5067545": {"ParentId": "5067492", "CommentCount": "4", "Body": "<p>Many platforms cannot effectively load values smaller than 32 bits. They have to load 32 bits, and use a shift-and-mask operation to extract 8 bits. You wouldn't want this for single <code>bool</code>s, but it's OK for strings. </p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "5067545", "Score": "18", "CreationDate": "2011-02-21T15:06:08.683", "LastActivityDate": "2011-02-21T15:06:08.683"}});