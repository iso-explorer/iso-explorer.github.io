post_cb({"bq_ids": {"n4140": {"so_28884791_28884981_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 6823}}, "n3337": {"so_28884791_28884981_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 6578}}, "n4659": {"so_28884791_28884981_0": {"length": 17, "quality": 0.7391304347826086, "section_id": 8315}}}, "28884791": {"ViewCount": "83", "Body": "<p>Theoretically, if space in memory was allocated using <code>operator new</code>, would it be possible to free that memory in a piecemeal fashion? For instance, if <code>void *mem = operator new(sizeof(int)*2)</code> was used to assign a memory address to two <code>int*</code> variables, one at <code>mem</code> and the other at <code>mem+sizeof(int)</code>, is it possible to free the memory of one, but not the other?</p>\n<p>It's my understanding that <code>operator new</code> only allocates memory, and doesn't call any constructors, so placement <code>new</code> is used to call the constructor at an exact space in memory. If the memory addresses of these allocations are known, but aren't necessarily linear in memory (stored in a linked list in a memory pool class, for example), I would imagine that there would be an appropriate way to free the allocated memory by iterating through the linked list of memory addresses and freeing the memory of the size of the allocation. However, by assigning the memory to a pointer to a data type of the appropriate size, a runtime error is always thrown.</p>\n<p>Is there an appropriate method for doing this?</p>\n<p>Theoretical example:</p>\n<pre><code>// This works fine\nuintptr_t mem1 = reinterpret_cast&lt;uintptr_t&gt;(operator new(sizeof(int)));\nint *a = new(reinterpret_cast&lt;void*&gt;(mem1)) int(1);\nprintf(\"a|*a\\t\\t%p|%d\\n\", a, *a);\ndelete a;\n\n// Both of the pointers can be assigned to the appropriate positions...\nuintptr_t mem2 = reinterpret_cast&lt;uintptr_t&gt;(operator new(sizeof(int) * 2));\nint *b = new(reinterpret_cast&lt;void*&gt;(mem2)) int(2);\nprintf(\"b|*b\\t\\t%p|%d\\n\", b, *b);\nint *c = new(reinterpret_cast&lt;void*&gt;(mem2+sizeof(int))) int(3);\nprintf(\"c|*c\\t\\t%p|%d\\n\", c, *c);\n\n// ...but attempting to delete them results in a runtime error.\noperator delete(b);\noperator delete(c);\n//using \"operator delete(reinterpret_cast&lt;void*&gt;(mem2));\" works just fine, but I'm operating on the assumption that the addresses may be non-linear, in a linked-list of addresses of a constant size\n</code></pre>\n", "AcceptedAnswerId": "28884981", "Title": "Freeing only a portion of memory allocated with \"operator new\"", "CreationDate": "2015-03-05T18:12:15.823", "Id": "28884791", "CommentCount": "3", "LastEditDate": "2015-03-05T18:17:14.323", "PostTypeId": "1", "LastEditorUserId": "4612763", "LastActivityDate": "2015-03-05T18:29:16.020", "Score": "2", "OwnerUserId": "4612763", "Tags": "<c++><memory><memory-management><memory-leaks>", "AnswerCount": "2"}, "28885118": {"Id": "28885118", "PostTypeId": "2", "Body": "<p>If you mean \"can the new operator allocate a huge chunk of memory and then return part of it to the caller making memory allocation really efficient\" then generally, yes... that's already what happens. With modern systems, you don't even get any memory allocated - what happens is you are allocated a chunk of virtual address space that is backed by real memory only when you write to it, the CPUs MMU handling all this for you.</p>\n<p>What is not supported is allocating memory at the applications code level and trying to free it partially, what you get from new is what you have to use as a single chunk.</p>\n", "LastActivityDate": "2015-03-05T18:29:16.020", "CommentCount": "0", "CreationDate": "2015-03-05T18:29:16.020", "ParentId": "28884791", "Score": "0", "OwnerUserId": "13744"}, "28884981": {"Id": "28884981", "PostTypeId": "2", "Body": "<p>18.6.1.1/12 (<code>void operator delete(void* ptr) noexcept</code>):</p>\n<blockquote>\n<p id=\"so_28884791_28884981_0\">Requires: <code>ptr</code> shall be a null pointer or its value shall be a value returned by an earlier call to the (possibly replaced) <code>operator new(std::size_t</code>) or <code>operator new(std::size_t,const std::nothrow_t&amp;)</code> which has not been invalidated by an intervening call to <code>operator delete(void*)</code>.</p>\n</blockquote>\n<p>I don't think you can get much more explicit than that with respect to destroying allocated memory in pieces: It's disallowed by the standard.</p>\n", "LastEditorUserId": "701092", "LastActivityDate": "2015-03-05T18:24:14.270", "Score": "6", "CreationDate": "2015-03-05T18:21:59.390", "ParentId": "28884791", "CommentCount": "0", "OwnerUserId": "251738", "LastEditDate": "2015-03-05T18:24:14.270"}});