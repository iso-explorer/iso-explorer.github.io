post_cb({"bq_ids": {"n4140": {"so_16629743_16629824_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 1758}, "so_16629743_16629824_4": {"length": 16, "quality": 0.7619047619047619, "section_id": 1657}}, "n3337": {"so_16629743_16629824_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 1752}, "so_16629743_16629824_4": {"length": 16, "quality": 0.7619047619047619, "section_id": 1653}}, "n4659": {"so_16629743_16629824_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 1924}, "so_16629743_16629824_4": {"length": 11, "quality": 0.5238095238095238, "section_id": 1801}}}, "16629743": {"ViewCount": "719", "Body": "<p>I just found out that the two swap functions for basic_string (member function and function in namespace std) are not declared with <em>noexcept</em> - neither in the standard library of GCC-4.8 nor in the most recent C++ draft N3690.</p>\n<p>On the other hand, the move constructor as well as the move assignment operator are declared with <em>noexcept</em>. That shows that is should be possible to provide <em>noexcept</em> swap functions.</p>\n<p><strong>Question:</strong> What's the reason for not having the swap functions declared with <em>noexcept</em>?</p>\n<p><strong>Update:</strong> The problem is that I want to use a template function within my own swap functions, that uses static_assert to check that the swap is actually <em>noexcept</em>, e.g.:</p>\n<pre><code>struct foo {\n    bar_t bar;\n    baz_t baz;\n    void swap(foo&amp; rhs) noexcept {\n        swap_noexcept(bar, rhs.bar);\n        swap_noexcept(baz, rhs.baz);\n    }\n};\n</code></pre>\n<p>However, that works only if the swap functions are declared with <em>noexcept</em>, and that's not the case for <code>basic_string</code>.</p>\n", "AcceptedAnswerId": "16629824", "Title": "Why is basic_string::swap not noexcept?", "CreationDate": "2013-05-18T22:51:44.743", "Id": "16629743", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-03-20T08:06:28.227", "LastEditorUserId": "573032", "LastActivityDate": "2016-03-20T08:06:28.227", "Score": "19", "OwnerUserId": "1305501", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "16629824": {"Id": "16629824", "PostTypeId": "2", "Body": "<p>Paragraph 21.4.6.8 of the C++11 Standard specifies:</p>\n<blockquote>\n<p id=\"so_16629743_16629824_0\">21.4.6.8 <code>basic_string::swap</code> [string::swap]</p>\n<pre><code>void swap(basic_string&amp; s);\n</code></pre>\n<p id=\"so_16629743_16629824_1\">1 <em>Postcondition</em>: *this contains the same sequence of characters that was in s, s contains the same\n  sequence of characters that was in *this.</p>\n<p id=\"so_16629743_16629824_2\">2 <strong><em>Throws</em>: Nothing</strong>.</p>\n<p id=\"so_16629743_16629824_3\">3 <em>Complexity</em>: constant time.</p>\n</blockquote>\n<p>Therefore, one must conclude the absence of <code>noexcept</code> is an oversight.</p>\n<p>Another clue is given by paragraph 21.4.6.3 on the <code>assign()</code> member function:</p>\n<blockquote>\n<pre><code>basic_string&amp; assign(basic_string&amp;&amp; str) noexcept;\n</code></pre>\n<p id=\"so_16629743_16629824_4\"><em>Effects</em>: The function replaces the string controlled by <code>*this</code> with a string of length <code>str.size()</code> whose\n  elements are a copy of the string controlled by <code>str</code>. [ <strong>Note: A valid implementation is <code>swap(str)</code></strong>. \u2014\n  end note ]</p>\n<p id=\"so_16629743_16629824_5\">3 <em>Returns</em>: <code>*this.</code></p>\n</blockquote>\n<p>If <code>swap(str)</code> is supposed to be a valid implementation for <code>assign()</code>, and <code>assign()</code> is marked as unconditionally <code>noexcept</code>, then it makes sense to assume <code>swap()</code> to be <code>noexcept</code> as well.</p>\n", "LastActivityDate": "2013-05-18T23:02:03.757", "CommentCount": "3", "CreationDate": "2013-05-18T23:02:03.757", "ParentId": "16629743", "Score": "18", "OwnerUserId": "1932150"}});