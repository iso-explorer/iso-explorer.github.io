post_cb({"20197636": {"CommentCount": "5", "AcceptedAnswerId": "20197637", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-11-25T16:06:58.897", "LastActivityDate": "2013-11-25T16:15:38.810", "LastEditDate": "2017-05-23T11:43:44.720", "ViewCount": "390", "FavoriteCount": "5", "Title": "Is it UB to re-use an object's storage without destroying it first?", "Id": "20197636", "Score": "14", "Body": "<p>Given non-POD type <code>T</code>:</p>\n<pre><code>auto p = new T();\n::new (p) T();\n/* ... */\ndelete p;\n</code></pre>\n<p>This is UB, right?</p>\n<p>Clearly I'm not directly leaking the memory allocated for that first <code>T</code> (and if it has no indirect members then I'm not leaking anything at all), but it never got destructed, which seems to me to be a great candidate for spontaneous annihilation of galaxies populated by sentient cat-like beings.</p>\n<p><sub>Thanks to <a href=\"https://stackoverflow.com/users/500104/xeo\">@Xeo</a> for, um, \"inspiring\" this question in the C++ Lounge.</sub></p>\n", "Tags": "<c++><memory-management><c++11>", "OwnerUserId": "560648", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_20197636_20197637_2": {"section_id": 7197, "quality": 0.9285714285714286, "length": 26}, "so_20197636_20197637_1": {"section_id": 7192, "quality": 0.9245283018867925, "length": 49}, "so_20197636_20197637_0": {"section_id": 7189, "quality": 0.625, "length": 5}}, "n3337": {"so_20197636_20197637_2": {"section_id": 6941, "quality": 0.9285714285714286, "length": 26}, "so_20197636_20197637_1": {"section_id": 6936, "quality": 0.9245283018867925, "length": 49}, "so_20197636_20197637_0": {"section_id": 6933, "quality": 0.625, "length": 5}}, "n4659": {"so_20197636_20197637_2": {"section_id": 8706, "quality": 0.8571428571428571, "length": 24}, "so_20197636_20197637_1": {"section_id": 8701, "quality": 0.9245283018867925, "length": 49}, "so_20197636_20197637_0": {"section_id": 8697, "quality": 0.625, "length": 5}}}, "20197637": {"ParentId": "20197636", "CommentCount": "10", "Body": "<p>It rather depends.</p>\n<blockquote>\n<p id=\"so_20197636_20197637_0\"><code>[C++11: 3.8/1]:</code> <strong>The lifetime of an object of type <code>T</code> ends when:</strong></p>\n<ul>\n<li>if <code>T</code> is a class type with a non-trivial destructor (12.4), the destructor call starts, or</li>\n<li><strong>the storage which the object occupies is reused or released</strong>.</li>\n</ul>\n</blockquote>\n<p>Clearly, this is a case of re-use.</p>\n<p>And:</p>\n<blockquote>\n<p id=\"so_20197636_20197637_1\"><code>[C++11: 3.8/4]:</code> <strong>A program may end the lifetime of any object by reusing the storage which the object occupies</strong> or by explicitly calling the destructor for an object of a class type with a non-trivial destructor. <strong>For an object of a class type with a non-trivial destructor, the program is not required to call the destructor explicitly</strong> before the storage which the object occupies is reused or released; <strong>however, if there is no explicit call to the destructor or if a <em>delete-expression</em> (5.3.5) is not used to release the storage, the destructor shall not be implicitly called and any program that depends on the side effects produced by the destructor has undefined behavior.</strong></p>\n</blockquote>\n<p>So, even for a non-POD type <code>T</code>, it's valid <em>iff</em> nothing in your program actually relied on what the destructor was doing.</p>\n<p>It's a bit airy-fairy, but it does potentially allow what you're doing.</p>\n<hr>\n<p>Note that this leniency does <em>not</em> extend to some only slightly more bizarre cases:</p>\n<blockquote>\n<p id=\"so_20197636_20197637_2\"><code>[C++11: 3.8/9]</code>: Creating a new object at the storage location that a const object with static, thread, or automatic storage duration occupies or, at the storage location that such a const object used to occupy before its lifetime ended results in undefined behavior</p>\n</blockquote>\n</hr>", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "20197637", "Score": "20", "CreationDate": "2013-11-25T16:06:58.897", "LastActivityDate": "2013-11-25T16:06:58.897"}});