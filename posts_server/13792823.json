post_cb({"13792823": {"CommentCount": "7", "ViewCount": "87", "CreationDate": "2012-12-09T23:05:44.997", "LastActivityDate": "2012-12-09T23:54:51.050", "Title": "Is casting the first field of an object to the object's type actually safe?", "AcceptedAnswerId": "13792888", "PostTypeId": "1", "Id": "13792823", "Score": "3", "Body": "<p>At first glance, this looks like undefined behavior...</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct SomeBaseClass\n{\n    // ...\n};\n\nstruct MyFakerClass\n{\n    SomeBaseClass base;\n    void foo() { std::cout &lt;&lt; \"hello\" &lt;&lt; std::endl; }\n};\n\nint main()\n{\n    MyFakerClass c;\n    MyFakerClass *p = static_cast&lt;MyFakerClass *&gt;(static_cast&lt;void *&gt;(&amp;c.base));\n    p-&gt;foo();\n}\n</code></pre>\n<p>... but if the first field of an object is guaranteed to have the same address as the object, then this must be safe, right? Or is there some other rule that intervenes?</p>\n", "Tags": "<c++><casting><undefined-behavior>", "OwnerUserId": "541686", "AnswerCount": "1"}, "13792888": {"ParentId": "13792823", "LastEditDate": "2012-12-09T23:54:51.050", "CommentCount": "7", "CreationDate": "2012-12-09T23:15:08.107", "OwnerUserId": "214671", "LastEditorUserId": "214671", "PostTypeId": "2", "Id": "13792888", "Score": "5", "Body": "<blockquote>\n<p id=\"so_13792823_13792888_0\">A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. <i>[ Note: There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning, as necessary to achieve appropriate alignment. \u2014 end note ]</i></p>\n</blockquote>\n<p>(C++11, \u00a79.2, \u00b621)</p>\n<p>So, this is safe as long as a class is \"standard-layout\", i.e.:</p>\n<blockquote>\n<p id=\"so_13792823_13792888_1\">A standard-layout class is a class that:</p>\n<ul>\n<li>has no non-static data members of type non-standard-layout class (or array of such types) or reference,</li>\n<li>has no virtual functions (10.3) and no virtual base classes (10.1),</li>\n<li>has the same access control (Clause 11) for all non-static data members,</li>\n<li>has no non-standard-layout base classes,</li>\n<li>either has no non-static data members in the most derived class and at most one base class with non-static data members, or has no base classes with non-static data members, and</li>\n<li>has no base classes of the same type as the first non-static data member.</li>\n</ul>\n</blockquote>\n<p>(C++11, \u00a79, \u00b67)</p>\n<p>All the requirements about the virtual stuff are because of the vptr: as said above, many compilers put it as a first hidden member, but they are allowed to put it anywhere or, if they are able, to omit it at all or implement virtual dispatch in other ways, so <em>virtual</em> in general alters the layout of the class in an unspecified way.</p>\n<p>The \"same access control clause\" is because</p>\n<blockquote>\n<p id=\"so_13792823_13792888_2\">The order of allocation of non-static data members with different access control is unspecified.</p>\n</blockquote>\n<p>(C++11, \u00a79.2, \u00b615)</p>\n<p>I suppose that this may be to allow compilers to reorder/group the members of a class by access-control (i.e. inside the compiler the IR of a class may contain a list for the members under each access-control specifier, which does not allow to keep the original ordering - all the interleaved public/private/protected sections would be grouped and e.g. the private members may be put in front of the class by default).</p>\n<p>The no non-standard-layout members/base classes \"recursive\" clauses are to ensure that the class is standard-layout as a whole (base classes and members are a part of it).</p>\n<p>Additional details on why the rest of this stuff can affect the layout of the class may be found in \u00a79.2.</p>\n<hr>\n<p>Notice that this is a weaker condition than the class being POD (as I incorrectly said in the comment above), since a class is POD if it is both standard layout and <em>trivial</em> (\u00a79 \u00b610)</p>\n</hr>", "LastActivityDate": "2012-12-09T23:54:51.050"}, "bq_ids": {"n4140": {"so_13792823_13792888_0": {"section_id": 5879, "quality": 0.5263157894736842, "length": 20}, "so_13792823_13792888_2": {"section_id": 5873, "quality": 0.9, "length": 9}}, "n3337": {"so_13792823_13792888_0": {"section_id": 5650, "quality": 0.9210526315789473, "length": 35}, "so_13792823_13792888_2": {"section_id": 5644, "quality": 0.9, "length": 9}}, "n4659": {"so_13792823_13792888_0": {"section_id": 7363, "quality": 0.5263157894736842, "length": 20}, "so_13792823_13792888_2": {"section_id": 7356, "quality": 0.9, "length": 9}}}});