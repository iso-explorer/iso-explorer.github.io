post_cb({"21649810": {"ParentId": "21644735", "LastEditDate": "2014-02-08T18:18:03.187", "CommentCount": "2", "CreationDate": "2014-02-08T18:08:51.803", "OwnerUserId": "576911", "LastEditorUserId": "576911", "PostTypeId": "2", "Id": "21649810", "Score": "4", "Body": "<p>Section 18.8.1 [exception]/p1 specifies:</p>\n<pre><code>namespace std {\n    class exception {\n    public:\n      exception() noexcept;\n      exception(const exception&amp;) noexcept;\n      exception&amp; operator=(const exception&amp;) noexcept;\n      virtual ~exception();\n      virtual const char* what() const noexcept;\n  };\n}\n</code></pre>\n<p>I.e. the copy constructor and copy assignment of std::exception shall be <code>noexcept</code>, and this is testable with:</p>\n<pre><code>static_assert(std::is_nothrow_copy_constructible&lt;std::exception&gt;::value, \"\");\nstatic_assert(std::is_nothrow_copy_assignable&lt;std::exception&gt;::value, \"\");\n</code></pre>\n<p>I.e. if an implementation does not make these members noexcept, then it is not conforming in this regard.</p>\n<p>Similarly, 18.6.2.1 [bad.alloc]/p1 also specifies noexcept copy:</p>\n<pre><code>namespace std {\n       class bad_alloc : public exception {\n       public:\n         bad_alloc() noexcept;\n         bad_alloc(const bad_alloc&amp;) noexcept;\n         bad_alloc&amp; operator=(const bad_alloc&amp;) noexcept;\n         virtual const char* what() const noexcept;\n  };\n}\n</code></pre>\n<p>Additionally, <strong>all</strong> of the std-defined exception types have noexcept copy members, either explicitly, or implicitly.  For the types defined in <code>&lt;stdexcept&gt;</code> this is usually implemented with a reference-counted buffer for the <code>what()</code> string.  This is made clear in [exception]/p2:</p>\n<blockquote>\n<p id=\"so_21644735_21649810_0\">Each standard library class <code>T</code> that derives from class exception\n  shall have a publicly accessible copy constructor and a publicly\n  accessible copy assignment operator that do not exit with an\n  exception. ...</p>\n</blockquote>\n<p>That is, in a quality implementation (and it does not take heroics to create a quality implementation in this regard), not only will the copy members of exception types not throw an exception (naturally because they are marked <code>noexcept</code>), they also will not call <code>terminate()</code>.</p>\n<p>There is no failure mode for copying the std-defined exception types.  Either there is no data to copy, or the data is reference counted and immutable.</p>\n", "LastActivityDate": "2014-02-08T18:18:03.187"}, "21645818": {"ParentId": "21644735", "LastEditDate": "2014-02-08T12:15:53.543", "CommentCount": "0", "CreationDate": "2014-02-08T12:10:17.307", "OwnerUserId": "819272", "LastEditorUserId": "819272", "PostTypeId": "2", "Id": "21645818", "Score": "3", "Body": "<p>Memory allocation for exceptions is done outside the regular channels:</p>\n<p><strong>15.1 Throwing an exception [except.throw]</strong></p>\n<blockquote>\n<p id=\"so_21644735_21645818_0\">3 <strong>Throwing an exception copy-initializes (8.5, 12.8) a temporary\n  object, called the exception object.</strong> [...] </p>\n<p id=\"so_21644735_21645818_1\">4 <strong>The memory for the exception object is\n  allocated in an unspecified way, except as noted in 3.7.4.1.</strong> [...]</p>\n</blockquote>\n<p><strong>3.7.4.1 Allocation functions [basic.stc.dynamic.allocation]</strong></p>\n<blockquote>\n<p id=\"so_21644735_21645818_2\">4 A global allocation function is only called as the result of a new\n  expression (5.3.4), or called directly using the function call syntax\n  (5.2.2), or called indirectly through calls to the functions in the\n  C++ standard library. [ Note: In particular, <strong>a global allocation\n  function is not called to allocate storage for</strong> [...] <strong>for an exception object (15.1).</strong> \u2014end note ]</p>\n</blockquote>\n<p>Most implementations have a separate memory region from which exception objects are allocated so that even if you are re-throwing a <code>std::bad_alloc</code> exception object, the exhausted free store itself is not being asked to allocate the copied exception object. So there should not be a reason for the copying itself to generate another exception.</p>\n", "LastActivityDate": "2014-02-08T12:15:53.543"}, "21644735": {"CommentCount": "0", "ViewCount": "1075", "CreationDate": "2014-02-08T10:16:30.810", "LastActivityDate": "2014-02-08T18:18:03.187", "Title": "Should I declare the copy constructor of my exceptions noexcept?", "AcceptedAnswerId": "21649810", "PostTypeId": "1", "Id": "21644735", "Score": "10", "Body": "<p>In <em>More Effective C++</em>, Scott Meyers says</p>\n<blockquote>\n<p id=\"so_21644735_21644735_0\">C++ specifies that an object thrown as an exception is copied.</p>\n</blockquote>\n<p>I suppose then, that if the copy constructor throws an exception in turn, <code>std::terminate</code> is called, so this is a good reason for declaring all my exceptions' copy constructors <code>noexcept</code> (and also, I guess, to not throw objects which allocate memory from the heap, like <code>std::string</code>).</p>\n<p>Yet I\u00a0was surprised to see that the standard library implementation shipped with GCC 4.7.1 doesn\u2019t define those copy constructor for <code>std::bad_alloc</code> and <code>std::exception</code>. Shouldn\u2019t they define them <code>noexcept</code>?</p>\n", "Tags": "<c++><exception><c++11><copy-constructor><noexcept>", "OwnerUserId": "748175", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_21644735_21644735_0": {"section_id": 6290, "quality": 0.8, "length": 4}, "so_21644735_21645818_1": {"section_id": 3337, "quality": 0.8, "length": 8}, "so_21644735_21649810_0": {"section_id": 6909, "quality": 1.0, "length": 18}, "so_21644735_21645818_2": {"section_id": 7179, "quality": 0.8235294117647058, "length": 28}, "so_21644735_21645818_0": {"section_id": 3336, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_21644735_21644735_0": {"section_id": 6050, "quality": 0.8, "length": 4}, "so_21644735_21645818_1": {"section_id": 3207, "quality": 0.8, "length": 8}, "so_21644735_21649810_0": {"section_id": 6655, "quality": 1.0, "length": 18}, "so_21644735_21645818_2": {"section_id": 6923, "quality": 0.7941176470588235, "length": 27}, "so_21644735_21645818_0": {"section_id": 371, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_21644735_21644735_0": {"section_id": 7797, "quality": 0.8, "length": 4}, "so_21644735_21645818_2": {"section_id": 8687, "quality": 0.8235294117647058, "length": 28}, "so_21644735_21649810_0": {"section_id": 8407, "quality": 1.0, "length": 18}, "so_21644735_21645818_0": {"section_id": 4103, "quality": 0.8888888888888888, "length": 8}, "so_21644735_21645818_1": {"section_id": 4104, "quality": 0.8, "length": 8}}}, "21644812": {"ParentId": "21644735", "CommentCount": "2", "Body": "<p>Well, it's all fine and good to declare it <code>noexcept</code>, but it requires that you can GUARANTEE that it won't throw an exception (and for portable code, in all it's implementations!). Which I expect the is the reason that the standard ones aren't declared that way. </p>\n<p>There is clearly no harm in declaring the copy constructor <code>noexcept</code>, but it can be pretty restrictive to try to achieve that.</p>\n", "OwnerUserId": "1919155", "PostTypeId": "2", "Id": "21644812", "Score": "1", "CreationDate": "2014-02-08T10:23:10.603", "LastActivityDate": "2014-02-08T10:23:10.603"}});