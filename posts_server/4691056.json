post_cb({"4691159": {"ParentId": "4691056", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The return type of the ?: operator has to be deduced from it's two operands, and the rules for determining this type are quite complex. Lambdas don't satisfy them because they can't be converted to each other. So when the compiler tries to work out what the result of that ?: is, then there can't be a result, because those two lambdas aren't convertible to each other.</p>\n<p>However, when you try to compute the functions, then you actually <em>called</em> them, but you didn't <em>call</em> the lambdas. So when you call the functions, they both have void, so the return type of ?: is void.</p>\n<p>This</p>\n<pre><code>void left()\n{}\nvoid right()\n{}\n\nint myVar = 0;\nmyVar ? left() : right();\n</code></pre>\n<p>is equivalent to</p>\n<pre><code>int myVar = 0;\nmyVar ? [](){}() : [](){}();\n</code></pre>\n<p>Note the extra () on the end- I actually called the lambda.</p>\n<p>What you had originally is equivalent to</p>\n<pre><code>compiler_deduced_type var;\nif (myVar)\n    var = [](){};\nelse\n    var = [](){};\n</code></pre>\n<p>But- no type exists that can be both lambdas. The compiler is well within it's rights to make both lambdas different types.</p>\n<p>EDIT:</p>\n<p>I remembered something. In the latest Standard draft, lambdas with no captures can be implicitly converted into function pointers of the same signature. That is, in the above code, compiler_deduced_type could be void(*)(). However, I know for a fact that MSVC does not include this behaviour because that was not defined at the time that they implemented lambdas. This is likely why GCC allows it and MSVC does not- GCC's lambda support is substantially newer than MSVC's.</p>\n", "OwnerUserId": "298661", "LastEditorUserId": "298661", "LastEditDate": "2011-01-14T13:14:32.593", "Id": "4691159", "Score": "9", "CreationDate": "2011-01-14T12:42:10.527", "LastActivityDate": "2011-01-14T13:14:32.593"}, "4691075": {"ParentId": "4691056", "CommentCount": "0", "Body": "<p>Both snippets compile just fine with GCC 4.5.2.</p>\n<p>Maybe your compiler has no (or partial/broken) support to C++0x features such as lambda?</p>\n", "OwnerUserId": "300805", "PostTypeId": "2", "Id": "4691075", "Score": "2", "CreationDate": "2011-01-14T12:34:00.217", "LastActivityDate": "2011-01-14T12:34:00.217"}, "4691288": {"ParentId": "4691056", "CommentCount": "0", "Body": "<p>Because every lambda is a unique type. It is basically syntactic sugar for a functor, and two separately implemented functors aren't the same type, even if they contain identical code.</p>\n<p>The standard does specify that lambdas can be converted to function pointers if they don't capture anything, but that rule was added after MSVC's lambda support was implemented.</p>\n<p>With that rule, however, two lambdas can be converted to the same type, and so I believe your code would be valid with a compliant compiler.</p>\n", "OwnerUserId": "33213", "PostTypeId": "2", "Id": "4691288", "Score": "3", "CreationDate": "2011-01-14T12:56:25.490", "LastActivityDate": "2011-01-14T12:56:25.490"}, "4691274": {"ParentId": "4691056", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Rules for conditional operator in the draft n3225 says at one point</p>\n<blockquote>\n<p id=\"so_4691056_4691274_0\">Otherwise, the result is a prvalue. If the second and third operands do not have the same type, and either\n  has (possibly cv-quali\ufb01ed) class type, overload resolution is used to determine the conversions (if any) to be\n  applied to the operands (13.3.1.2, 13.6). If the overload resolution fails, the program is ill-formed. Otherwise,\n  the conversions thus determined are applied, and the converted operands are used in place of the original\n  operands for the remainder of this section.</p>\n</blockquote>\n<p>Up to that point, every other alternative (like, convert one to the other operand) failed, so we will now do what that paragraph says. The conversions we will apply are determined by overload resolution by transforming <code>a ? b : c</code> into <code>operator?(a, b, c)</code> (an imaginary function call to a so-named function). If you look what the candidates for the imaginary <code>operator?</code> are, you find (among others)</p>\n<blockquote>\n<p id=\"so_4691056_4691274_1\">For every type T , where T is a pointer, pointer-to-member, or scoped enumeration type, there exist candidate operator functions of the form</p>\n<pre><code>T operator?(bool, T , T );\n</code></pre>\n</blockquote>\n<p>And this includes a candidate for which <code>T</code> is the type <code>void(*)()</code>. This is important, because lambda expressions yield an object of a class that can be converted to such a type. The spec says</p>\n<blockquote>\n<p id=\"so_4691056_4691274_2\">The closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type\u2019s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type\u2019s function call operator.</p>\n</blockquote>\n<p>The lambda expressions can't be convert to any other of the parameter types listed, which means overload resolution succeeds, finds a single <code>operator?</code> and will convert both lambda expressions to function pointers. The remainder of the conditional opreator section will then proceed as usual, now having two branches for the conditional operator having the same type. </p>\n<p>That's why also your first version is OK, and why GCC is right accepting it. However I don't really understand why you show the second version at all - as others explained, it's doing something different and it's not surprising that it works while the other doesn't (on your compiler). Next time, best try not to include useless code into the question. </p>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2011-01-14T14:09:48.793", "Id": "4691274", "Score": "5", "CreationDate": "2011-01-14T12:54:14.777", "LastActivityDate": "2011-01-14T14:09:48.793"}, "4691056": {"CommentCount": "6", "AcceptedAnswerId": "4691274", "PostTypeId": "1", "LastEditorUserId": "912144", "CreationDate": "2011-01-14T12:31:27.163", "LastActivityDate": "2012-06-01T11:55:13.420", "LastEditDate": "2012-06-01T11:55:13.420", "ViewCount": "876", "FavoriteCount": "0", "Title": "Why won't this c++ lamba function compile?", "Id": "4691056", "Score": "3", "Body": "<p>Why does this fail to compile:  </p>\n<pre><code>int myVar = 0;\nmyVar ? []()-&gt;void{} : []()-&gt;void{};\n</code></pre>\n<p>with following error msg:</p>\n<blockquote>\n<p id=\"so_4691056_4691056_0\">Error 2   error C2446: ':' : no conversion from 'red_black_core::`anonymous-namespace'::&lt; lambda1&gt;' to red_black_core::anonymous-namespace::&lt; lambda0&gt; </p>\n</blockquote>\n<p>While this complies correctly:</p>\n<pre><code>void left()\n{}\nvoid right()\n{}\n\nint myVar = 0;\nmyVar ? left() : right();\n</code></pre>\n", "Tags": "<c++><lambda><c++11>", "OwnerUserId": "207177", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_4691056_4691274_0": {"section_id": 6171, "quality": 0.9210526315789473, "length": 35}, "so_4691056_4691274_1": {"section_id": 699, "quality": 0.9333333333333333, "length": 14}, "so_4691056_4691274_2": {"section_id": 5965, "quality": 0.95, "length": 38}}, "n3337": {"so_4691056_4691274_0": {"section_id": 5932, "quality": 0.9210526315789473, "length": 35}, "so_4691056_4691274_1": {"section_id": 689, "quality": 0.9333333333333333, "length": 14}, "so_4691056_4691274_2": {"section_id": 5734, "quality": 0.95, "length": 38}}, "n4659": {"so_4691056_4691274_0": {"section_id": 7669, "quality": 0.9210526315789473, "length": 35}, "so_4691056_4691274_1": {"section_id": 728, "quality": 0.9333333333333333, "length": 14}, "so_4691056_4691274_2": {"section_id": 7456, "quality": 0.85, "length": 34}}}, "4691088": {"ParentId": "4691056", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>It doesn't fail to compile. It works just fine. <strike>You probably don't have C++0x enabled in your compiler.</strike></p>\n<p><strong>Edit:</strong>\nAn error message has now been added to the original question! It seems that you do have C++0x support, but that it is not complete in your compiler. This is not surprising.</p>\n<p>The code is still valid C++0x, but I recommend only using C++0x features when you really have to, until it's standardised and there is full support across a range of toolchains. You have a viable C++03 alternative that you gave in your answer, and I suggest using it for the time being.</p>\n<p><strong>Possible alternative explanation:</strong></p>\n<p>Also note that you probably didn't write what you actually meant to write. <code>[]()-&gt;void{}</code> is a lambda. <code>[]()-&gt;void{}()</code> executes the lambda and evaluates to its result. Depending what you're doing with this result, your problem could be that the result of calling your lambda is <code>void</code>, and you can't do much with <code>void</code>.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2011-01-14T13:27:46.513", "Id": "4691088", "Score": "0", "CreationDate": "2011-01-14T12:35:03.847", "LastActivityDate": "2011-01-14T13:27:46.513"}});