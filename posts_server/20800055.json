post_cb({"20800497": {"LastActivityDate": "2013-12-27T12:11:01.133", "ParentId": "20800055", "Id": "20800497", "Score": "1", "Body": "<p>sighandler_t is defined to be a pointer to a function with the following definition:</p>\n<pre><code>void func(int);\n</code></pre>\n<p>Since std::bind and lambdas return functors, it is not possible to directly use them as signal handler. As a workaround you can use your own wrapper functions like</p>\n<pre><code>class SignalHandlerBase\n{\npublic:\n  virtual void operator(int) = 0;\n};\n\ntemplate &lt;class T&gt;\nclass SignalHandler : public SignalHandlerBase\n{\n  T t;\npublic:\n  SignalHandler(T _t) : t(_t) { }\n  void operator(int i)\n  {\n    t(i);\n  } \n};\n\nclass SignalManager\n{\n  int sig;\n  SignalHandlerBase *shb;\n  static void handlerFunction(int i)\n  {\n    shb(i);\n  }\npublic:\n  SignalManager(int signal) : sig(signal), shb(nullptr) { signal(signal, &amp;handlerFunction); }\n  template &lt;class T&gt;\n  void installHandler(T t)\n  {\n    delete shb;\n    shb = new SignalHandler&lt;T&gt;(t);\n  }\n};\n</code></pre>\n<p>Use global instances of <code>SignalManager</code> to manage individual signals</p>\n", "CommentCount": "3", "PostTypeId": "2", "OwnerUserId": "1781290", "CreationDate": "2013-12-27T12:11:01.133"}, "20800055": {"AcceptedAnswerId": "20800100", "Tags": "<c++><c++11><lambda><function-pointers>", "AnswerCount": "3", "OwnerUserId": "940912", "Body": "<p>How to specify lambda, std::bind result or any other std::function as argument for unix signal function?</p>\n<p>I'm trying the following</p>\n<pre><code>std::function&lt;void(int)&gt; handler1 = std::bind(&amp;cancellation_token::cancel, &amp;c);\nstd::function&lt;void(int)&gt; handler2 = [&amp;c](int) { c.cancel(); };\n</code></pre>\n<p>but it doesn't work, because both</p>\n<pre><code>handler1.target&lt;void(int)&gt;()\n</code></pre>\n<p>and</p>\n<pre><code>handler2.target&lt;void(int)&gt;()\n</code></pre>\n<p><code>return null</code></p>\n<p>It works if I initialize handler with free function pointer</p>\n<pre><code>void foo(int) { ... }\nstd::function&lt;void(int)&gt; handler = foo;\n</code></pre>\n<p>but this is absolutely useless. I need to capture some local variables, so I need either bind or lambda.</p>\n<p>Actually I understand why it doesn't work. Documentation says that <code>target</code> function returns a pointer to the stored function if <code>target_type() == typeid(T)</code>, otherwise a null pointer. I don't understand how to make it work.</p>\n<p>Any suggestions?</p>\n", "CommentCount": "0", "PostTypeId": "1", "CreationDate": "2013-12-27T11:39:33.893", "LastActivityDate": "2014-01-04T21:17:39.683", "Id": "20800055", "Title": "std::function as sighandler_t", "Score": "1", "ViewCount": "928"}, "20800100": {"LastActivityDate": "2013-12-27T11:48:50.073", "LastEditorUserId": "1498580", "ParentId": "20800055", "LastEditDate": "2013-12-27T11:48:50.073", "Id": "20800100", "Score": "2", "Body": "<p>Since it's constructed by <code>bind</code>, or lambda with captured-data, you cannot convert it to free function, since <code>target</code> function works by <code>typeid</code>, <code>std::function</code> saves it in runtime, not for type <code>T</code>, with which <code>function</code> is templated. For <code>std::bind</code> it will be some library-type and for lambda it will be some unnamed type.</p>\n", "CommentCount": "3", "PostTypeId": "2", "OwnerUserId": "1498580", "CreationDate": "2013-12-27T11:42:41.010"}, "bq_ids": {"n3337": {"so_20800055_20805320_1": {"section_id": 5575, "quality": 1.0, "length": 4}, "so_20800055_20805320_0": {"section_id": 5575, "quality": 1.0, "length": 10}, "so_20800055_20805320_3": {"section_id": 5575, "quality": 1.0, "length": 14}}}, "20805320": {"LastActivityDate": "2014-01-04T21:17:39.683", "LastEditorUserId": "923854", "ParentId": "20800055", "LastEditDate": "2014-01-04T21:17:39.683", "Id": "20805320", "Score": "1", "Body": "<p>C++11 1.9 [intro.execution]/6:</p>\n<blockquote>\n<p id=\"so_20800055_20805320_0\">When the processing of the abstract machine is interrupted by receipt of a signal, the values of objects which\n  are neither</p>\n<ul>\n<li><p id=\"so_20800055_20805320_1\">of type <code>volatile std::sig_atomic_t</code> nor</p></li>\n<li><p id=\"so_20800055_20805320_2\">lock-free atomic objects (29.4)</p></li>\n</ul>\n<p id=\"so_20800055_20805320_3\">are unspecified during the execution of the signal handler, and the value of any \n  object not in either of these\n  two categories that is modified by the handler becomes undefined.</p>\n</blockquote>\n<p>The only action you can realistically take portably in a signal handler is to change the value of a flag whose type is <code>volatile std::sig_atomic_t</code> or a <strong>lock-free</strong> <code>std::atomic</code> (Note that not all <code>std::atomic</code> objects are lock-free). Non-signal handling code can then poll that flag to respond to the occurrence of the signal.</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3787.html\" rel=\"nofollow\">N3787</a> has some interesting discussion about how to fix C++11 basically breaking signal handlers as a concept.</p>\n", "CommentCount": "1", "PostTypeId": "2", "OwnerUserId": "923854", "CreationDate": "2013-12-27T17:47:19.803"}});