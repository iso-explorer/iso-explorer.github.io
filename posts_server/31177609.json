post_cb({"31599733": {"ParentId": "31177609", "CommentCount": "0", "Body": "<p>The first form is incorrect and should not compile.  To see why, consider what would happen if you multiply inherited from <code>Base&lt;Foo&gt;</code> and <code>Base&lt;Bar&gt;</code> (or <code>Base&lt;T&gt;</code> and <code>Base&lt;Base&lt;T&gt;&gt;</code> or whatever).  How could it resolve the ambiguity?</p>\n<p>The idea that the first form would work may be derived from mistaken application of the rule that, within a class template definition, you don't need to provide the template param(s) when mentioning the class name.  This doesn't apply to a templated base class, though.</p>\n", "OwnerUserId": "341622", "PostTypeId": "2", "Id": "31599733", "Score": "0", "CreationDate": "2015-07-23T23:26:01.160", "LastActivityDate": "2015-07-23T23:26:01.160"}, "32401503": {"ParentId": "31177609", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This question relies on something called <em>injected-class-name</em>. From [class]</p>\n<blockquote>\n<p id=\"so_31177609_32401503_0\">A <em>class-name</em> is inserted into the scope in which it is declared immediately after the <em>class-name</em> is seen. The <em>class-name</em> is also inserted into the scope of the class itself; this is known as the <em>injected-class-name</em>.\n  For purposes of access checking, the <em>injected-class-name</em> is treated as if it were a public member name.</p>\n</blockquote>\n<p>And from [temp.local]:</p>\n<blockquote>\n<p id=\"so_31177609_32401503_1\">Like normal (non-template) classes, class templates have an <em>injected-class-name</em> (Clause 9). The <em>injected-class-name</em> can be used as a <em>template-name</em> or a <em>type-name</em>. When it is used with a <em>template-argument-list</em>,\n  as a <em>template-argument</em> for a template <em>template-parameter</em>, or as the final identifier in the <em>elaborated-type-specifier</em> of a friend class template declaration, it refers to the class template itself. Otherwise, it is equivalent\n  to the <em>template-name</em> followed by the <em>template-parameters</em> of the class template enclosed in <code>&lt;&gt;</code>.</p>\n</blockquote>\n<p>That is, within the definitions <code>Bar1&lt;T&gt;</code> or <code>Bar2&lt;T&gt;</code>, you can use <code>Bar1</code> or <code>Bar2</code> to refer to the full class type. That is, these declarations are equivalent:</p>\n<pre><code>void Foo(Bar2&lt;T&gt; const &amp; other);\nvoid Foo(Bar2 const &amp; other);\n</code></pre>\n<p>However, the rules for lookup apply as normal. While there <em>is</em> an injected-class-name for <code>Base</code>, that is a dependent name and so cannot be found via normal unqualified lookup. From [temp.dep]:</p>\n<blockquote>\n<p id=\"so_31177609_32401503_2\">In the definition of a class or class template, the scope of a dependent base class (14.6.2.1) is not examined\n  during unqualified name lookup either at the point of definition of the class template or member or during an instantiation of the class template or member.</p>\n</blockquote>\n<p>which makes this:</p>\n<pre><code>Bar1() : Base() {}\n</code></pre>\n<p>ill-formed. <code>Base</code> is unqualified lookup, and there is no such name <code>Base</code>. There is a <code>Base&lt;T&gt;::Base</code> (the injected-class-name there), but that scope is unexamined. You would have to either do qualified lookup:</p>\n<pre><code>Bar1() : Bar1&lt;T&gt;::Base() {}\nBar1() : Bar1::Base() { }\n</code></pre>\n<p>or not rely on the injected-class-name of <code>Base</code>:</p>\n<pre><code>Bar1() : Base&lt;T&gt;() { }\n</code></pre>\n<p>VS is wrong in accepting <code>Bar1</code>. <code>Bar2</code> is perfectly OK, if more verbose than strictly possible. Nothing wrong with that. </p>\n<p>Worth noting also that if the base weren't dependent, you could still use its injected-class-name even if it were a template:</p>\n<pre><code>template &lt;class T&gt; struct Base { };\n\nstruct Derived : Base&lt;int&gt; {\n    Derived() : Base() { } // OK, lookup finds Base&lt;int&gt;::Base\n};\n</code></pre>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-09-04T15:37:52.657", "Id": "32401503", "Score": "2", "CreationDate": "2015-09-04T15:20:47.733", "LastActivityDate": "2015-09-04T15:37:52.657"}, "31177609": {"CommentCount": "7", "ViewCount": "169", "PostTypeId": "1", "LastEditorUserId": "509868", "CreationDate": "2015-07-02T07:00:26.640", "LastActivityDate": "2015-09-04T15:37:52.657", "Title": "C++ idioms when declaring template class members and constructors", "AcceptedAnswerId": "32401503", "LastEditDate": "2015-07-02T10:03:33.607", "Id": "31177609", "Score": "6", "Body": "<p>Although both of the following compile (with Visual Studio 2013), is one of them more \"correct\" with respect to C++ idioms?  I speak particularly with respect to explicit template parameters when calling base class constructors and declaring members.  Does The Standard have a view on this?  Is there a good practical reason to prefer one over the other?</p>\n<pre><code>template&lt;class T&gt;\nclass Bar1 : public Base&lt;T&gt;\n{\npublic:\n\n    Bar1() : Base() {}\n    Bar1(T value) : Base(value) {}\n    Bar1(Bar1 const &amp; other) : Base(other.value) {} \n\n    void Foo(Bar1 const &amp; other)\n    {\n        // Some foo related activity.\n    }\n};\n\ntemplate&lt;class T&gt;\nclass Bar2 : public Base&lt;T&gt;\n{\npublic:\n\n    Bar2() : Base&lt;T&gt;() {}\n    Bar2(T value) : Base&lt;T&gt;(value) {}\n    Bar2(Bar2&lt;T&gt; const &amp; other) : Base&lt;T&gt;(other.value) {}\n\n    void Foo(Bar2&lt;T&gt; const &amp; other)\n    {\n        // Some foo related activity.\n    }\n};\n</code></pre>\n", "Tags": "<c++><visual-studio><templates><syntax>", "OwnerUserId": "416274", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_31177609_32401503_2": {"section_id": 190, "quality": 0.88, "length": 22}, "so_31177609_32401503_0": {"section_id": 5846, "quality": 0.9310344827586207, "length": 27}, "so_31177609_32401503_1": {"section_id": 179, "quality": 0.9736842105263158, "length": 37}}, "n3337": {"so_31177609_32401503_2": {"section_id": 184, "quality": 0.88, "length": 22}, "so_31177609_32401503_0": {"section_id": 5616, "quality": 0.9310344827586207, "length": 27}, "so_31177609_32401503_1": {"section_id": 173, "quality": 0.9736842105263158, "length": 37}}, "n4659": {"so_31177609_32401503_2": {"section_id": 195, "quality": 0.96, "length": 24}, "so_31177609_32401503_1": {"section_id": 184, "quality": 0.9736842105263158, "length": 37}, "so_31177609_32401503_0": {"section_id": 7325, "quality": 0.9310344827586207, "length": 27}}}});