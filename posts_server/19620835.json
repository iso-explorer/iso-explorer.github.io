post_cb({"bq_ids": {"n4140": {"so_19620835_19621107_0": {"length": 23, "quality": 0.92, "section_id": 7230}}, "n3337": {"so_19620835_19621107_0": {"length": 23, "quality": 0.92, "section_id": 6974}}}, "19620865": {"CommentCount": "0", "Body": "<p><code>f1()</code> returns an instance of <code>A</code>. Since you haven't overwritten the copy/move-assignment operator, the compiler generates one for you. You're essentially calling a member function:</p>\n<pre><code>f1() = A(); // calls A&amp; operator=(A&amp;&amp;)\n</code></pre>\n<p>The second doesn't work because <code>int</code> is not of class type.</p>\n", "CreationDate": "2013-10-27T17:09:39.393", "ParentId": "19620835", "Id": "19620865", "LastActivityDate": "2013-10-27T17:09:39.393", "PostTypeId": "2", "Score": "3", "OwnerUserId": "701092"}, "19621107": {"CommentCount": "1", "Body": "<p>The function f1 returns a rvalue, which might become an xvalue (an \u201ceXpiring\u201d value). The function f2 returns a builtin type which is an rvalue becomming an prvalue (\u201cpure\u201d rvalue).</p>\n<p>From 3.10 [Lvalues and rvalues]</p>\n<blockquote>\n<p id=\"so_19620835_19621107_0\">\u2014 An xvalue (an \u201ceXpiring\u201d value) also refers to an object, usually\n  near the end of its lifetime (so that its resources may be moved, for\n  example). An xvalue is the result of certain kinds of expressions\n  involving rvalue references (8.3.2).</p>\n</blockquote>\n<p>Hence, due to an implicit move operation the assignment of A becomes valid.</p>\n<p>Changing A to:</p>\n<pre><code>struct A {\n    A() {}\n    A(A&amp;&amp;) = delete;\n    A&amp; operator = (const A&amp;) { return *this; }\n};\n</code></pre>\n<p>produces: error: use of deleted function \u2018A::A(A&amp;&amp;)\u2019 with g++ (Ubuntu/Linaro 4.7.2-2ubuntu1) 4.7.2</p>\n", "CreationDate": "2013-10-27T17:31:45.580", "ParentId": "19620835", "Id": "19621107", "LastActivityDate": "2013-10-27T17:31:45.580", "PostTypeId": "2", "Score": "2", "OwnerUserId": "2249683"}, "19620835": {"CreationDate": "2013-10-27T17:06:43.433", "ViewCount": "108", "Id": "19620835", "AcceptedAnswerId": "19621107", "Score": "4", "Title": "Why can int not be used as an l-value of a return type while a user-defined class can?", "CommentCount": "2", "Body": "<pre><code>struct A {};\n\nA f1()\n{\n    return A();\n}\n\nint f2()\n{\n    return int();\n}\n\nint main()\n{\n    f1() = A();   // OK\n    f2() = int(); // error C2106: '=' : left operand must be l-value\n}\n</code></pre>\n<p>Why is <code>f1() = A();</code> OK while <code>f2() = int();</code> is failed?</p>\n", "Tags": "<c++><function><types><return-type><lvalue>", "LastActivityDate": "2013-10-27T17:31:45.580", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "508343"}});