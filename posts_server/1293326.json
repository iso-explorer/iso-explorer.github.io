post_cb({"1293456": {"Id": "1293456", "PostTypeId": "2", "Body": "<p>Thanks for extra code. Now we can see a problem -</p>\n<p>in getNextJob</p>\n<pre><code>if (!this-&gt;jobs.empty())\n{\n    job = &amp;(this-&gt;jobs.front());\n    this-&gt;jobs.pop();\n</code></pre>\n<p>After the \"pop\", the memory pointed to by 'job'  is <strong>undefined</strong>. Don't use a reference, copy the actual data!</p>\n<p>Try something like this (it's still generic, because JobData is generic):</p>\n<pre><code>jobData ThreadPool::getNextJob()    // get the data of the next job\n{\n  jobData job;\n\n  WaitForSingleObject(this-&gt;mutex, INFINITE);\n\n  if (!this-&gt;jobs.empty())\n  {\n    job = (this-&gt;jobs.front());\n    this-&gt;jobs.pop();\n  }\n\n  // we're done with the exclusive part !\n  ReleaseMutex(this-&gt;mutex);\n\n  return job;\n</code></pre>\n<p>}</p>\n<p>Also, while you're adding jobs to the queue you must ALSO lock the mutex, to prevent list corruption. AFAIK std::lists are NOT inherently thread-safe...?</p>\n", "LastEditorUserId": "4023", "LastActivityDate": "2009-08-18T12:51:01.787", "Score": "4", "CreationDate": "2009-08-18T12:09:32.033", "ParentId": "1293326", "CommentCount": "2", "OwnerUserId": "1737", "LastEditDate": "2009-08-18T12:51:01.787"}, "1708737": {"Id": "1708737", "PostTypeId": "2", "Body": "<p>Using operator delete on pointer to void results in undefined behavior according to the specification.</p>\n<p>Chapter 5.3.5 of the draft of the C++ specification. Paragraph 3.</p>\n<blockquote>\n<p id=\"so_1293326_1708737_0\">In the first alternative (delete object), if the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand\u2019s dynamic type and the static type shall have a virtual destructor or the behavior is undefined. In the second alternative (delete array) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined.73)</p>\n</blockquote>\n<p>And corresponding footnote.</p>\n<blockquote>\n<p id=\"so_1293326_1708737_1\">This implies that an object cannot be deleted using a pointer of type void* because there are no objects of type void</p>\n</blockquote>\n", "LastActivityDate": "2009-11-10T15:19:00.570", "CommentCount": "0", "CreationDate": "2009-11-10T15:19:00.570", "ParentId": "1293326", "Score": "2", "OwnerUserId": "99365"}, "1293351": {"Id": "1293351", "PostTypeId": "2", "Body": "<p>All access to the job queue must be synchronized, i.e. performed only from 1 thread at a time by locking the job queue prior to access. Do you already have a critical section or some similar pattern to guard the shared resource? Synchronization issues often lead to weird behaviour and bugs which are hard to reproduce.</p>\n", "LastActivityDate": "2009-08-18T11:44:47.980", "CommentCount": "0", "CreationDate": "2009-08-18T11:44:47.980", "ParentId": "1293326", "Score": "1", "OwnerUserId": "128900"}, "bq_ids": {"n4140": {"so_1293326_1708737_0": {"length": 36, "quality": 0.9230769230769231, "section_id": 6107}, "so_1293326_1708737_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 6105}}, "n3337": {"so_1293326_1708737_0": {"length": 36, "quality": 0.9230769230769231, "section_id": 5873}, "so_1293326_1708737_1": {"length": 10, "quality": 0.7142857142857143, "section_id": 5871}}, "n4659": {"so_1293326_1708737_0": {"length": 36, "quality": 0.9230769230769231, "section_id": 7604}, "so_1293326_1708737_1": {"length": 11, "quality": 0.7857142857142857, "section_id": 7602}}}, "1293357": {"Id": "1293357", "PostTypeId": "2", "Body": "<p>It's hard to give a definitive answer with this amount of code.  But generally speaking, multithreaded programming is all about synchronizing access to data that might be accessed from multiple threads.  If there is no long or other synchronization primitive protecting access to the threadpool class itself, then you can potentially have multiple threads reaching your deletion loop at the same time, at which point you're pretty much guaranteed to be double-freeing memory.</p>\n<p>The reason you're getting no crash when you delete a job's params at the end of the job function might be because access to a single job's params is already implicitly serialized by your work queue.  Or you might just be getting lucky.  In either case, it's best to think about locks and synchronization primitive as not being something that protects <em>code</em>, but as being something that protects <em>data</em> (I've always thought the term \"critical section\" was a bit misleading here, as it tends to lead people to think of a 'section of lines of code' rather than in terms of data access)..  In this case, since you want to access your jobs data from multiple thread, you need to be protecting it via a lock or some other synchronization primitive.</p>\n", "LastActivityDate": "2009-08-18T11:46:15.810", "CommentCount": "1", "CreationDate": "2009-08-18T11:46:15.810", "ParentId": "1293326", "Score": "1", "OwnerUserId": "157781"}, "1293326": {"ViewCount": "2646", "Body": "<p>I have a multithreaded application that runs using a custom thread pool class. The threads all execute the same function, with different parameters.</p>\n<p>These parameters are given to the threadpool class the following way:</p>\n<pre><code>// jobParams is a struct of int, double, etc...\njobParams* params = new jobParams;\nparams.value1 = 2;\nparams.value2 = 3;\n\nint jobId = 0;\n\nthreadPool.addJob(jobId, params);\n</code></pre>\n<p>As soon as a thread has nothing to do, it gets the next parameters and runs the job function. I decided to take care of the deletion of the parameters in the threadpool class:</p>\n<pre><code>ThreadPool::~ThreadPool() {\n    for (int i = 0; i &lt; this-&gt;jobs.size(); ++i) {\n        delete this-&gt;jobs[i].params;\n    }\n}\n</code></pre>\n<p>However, when doing so, I sometimes get a heap corruption error:</p>\n<blockquote>\n<p id=\"so_1293326_1293326_0\">Invalid Address specified to RtlFreeHeap</p>\n</blockquote>\n<p>The strange thing is that in one case it works perfectly, but in another program it crashes with this error. I tried deleting the pointer at other places: in the thread after the execution of the job function (I get the same heap corruption error) or at the end of the job function itself (no error in this case).</p>\n<p>I don't understand how deleting the same pointers (I checked, the addresses are the same) from different places changes anything. Does this have anything to do with the fact that it's multithreaded?</p>\n<p>I do have a critical section that handles the access to the parameters. I don't think the problem is about synchronized access. Anyway, the destructor is called only once all threads are done, and I don't delete any pointer anywhere else. Can pointer be deleted automatically?</p>\n<p>As for my code. The list of jobs is a queue of a structure, composed of the id of a job (used to be able to get the output of a specific job later) and the parameters.</p>\n<p><code>getNextJob()</code> is called by the threads (they have a pointer to the ThreadPool) each time they finished to execute their last job.</p>\n<pre><code>void ThreadPool::addJob(int jobId, void* params) {\n    jobData job; // jobData is a simple struct { int, void* }\n    job.ID = jobId;\n    job.params = params;\n\n    // insert parameters in the list\n    this-&gt;jobs.push(job);\n}\n\njobData* ThreadPool::getNextJob() {    \n    // get the data of the next job\n    jobData* job = NULL;\n\n    // we don't want to start a same job twice,\n    // so we make sure that we are only one at a time in this part\n    WaitForSingleObject(this-&gt;mutex, INFINITE);\n\n    if (!this-&gt;jobs.empty())\n    {\n        job = &amp;(this-&gt;jobs.front());\n        this-&gt;jobs.pop();\n    }\n\n    // we're done with the exclusive part !\n    ReleaseMutex(this-&gt;mutex);\n\n    return job;\n}\n</code></pre>\n", "AcceptedAnswerId": "1293421", "Title": "Deleting pointer sometimes results in heap corruption", "CreationDate": "2009-08-18T11:38:49.913", "Id": "1293326", "CommentCount": "12", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-08-12T08:22:29.410", "LastEditorUserId": "2246344", "LastActivityDate": "2014-08-12T08:22:29.410", "Score": "2", "OwnerUserId": "56761", "Tags": "<c++><multithreading><pointers><memory-management><heap>", "AnswerCount": "7"}, "1293421": {"Id": "1293421", "PostTypeId": "2", "Body": "<p>Let's turn this on its head: <em>Why are you using pointers at all?</em></p>\n<pre><code>class Params\n{\nint value1, value2; // etc...\n}\n\nclass ThreadJob\n{\n  int jobID;  // or whatever...\n  Params params;\n}\n\nclass ThreadPool\n{\n  std::list&lt;ThreadJob&gt; jobs;\n\n  void addJob(int job, const Params &amp; p)\n  {\n     ThreadJob j(job, p);\n     jobs.push_back(j);\n  }\n}\n</code></pre>\n<p>No new, delete or pointers... Obviously some of the implementation details may be cocked, but you get the overall picture.</p>\n", "LastActivityDate": "2009-08-18T12:02:17.370", "CommentCount": "11", "CreationDate": "2009-08-18T12:02:17.370", "ParentId": "1293326", "Score": "5", "OwnerUserId": "1737"}, "1293517": {"Id": "1293517", "PostTypeId": "2", "Body": "<p>Use <a href=\"http://www.boost.org/doc/libs/1_39_0/libs/smart_ptr/smart_ptr.htm\" rel=\"nofollow noreferrer\">smart pointers</a> or other <a href=\"http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\" rel=\"nofollow noreferrer\">RAII</a> to handle your memory.</p>\n<hr>\n<p>If you have access to boost or tr1 lib you can do something like this.</p>\n<pre><code>class ThreadPool\n{\n    typedef pair&lt;int, function&lt;void (void)&gt; &gt; Job;\n    list&lt; Job &gt; jobList;\n    HANDLE mutex;\n\npublic:\n    void addJob(int jobid, const function&lt;void (void)&gt;&amp; job) {\n        jobList.push_back( make_pair(jobid, job) );\n    }\n\n    Job getNextJob() {    \n\n        struct MutexLocker {\n            HANDLE&amp; mutex;\n            MutexLocker(HANDLE&amp; mutex) : mutex(mutex){ \n                WaitForSingleObject(mutex, INFINITE); \n            }\n            ~MutexLocker() { \n                ReleaseMutex(mutex); \n            }\n        };\n\n        Job job = make_pair(-1, function&lt;void (void)&gt;());\n        const MutexLocker locker(this-&gt;mutex);\n        if (!this-&gt;jobList.empty()) {\n            job = this-&gt;jobList.front();\n            this-&gt;jobList.pop();\n        }\n        return job;\n    }\n};\n\n\nvoid workWithDouble( double value );\nvoid workWithInt( int value );\nvoid workWithValues( int, double);\n\nvoid test() {\n    ThreadPool pool;\n    //...\n    pool.addJob( 0, bind(&amp;workWithDouble, 0.1));\n    pool.addJob( 1, bind(&amp;workWithInt, 1));\n    pool.addJob( 2, bind(&amp;workWithValues, 1, 0.1));\n}\n</code></pre>\n</hr>", "LastEditorUserId": "106064", "LastActivityDate": "2009-08-18T13:42:29.570", "Score": "1", "CreationDate": "2009-08-18T12:27:57.260", "ParentId": "1293326", "CommentCount": "3", "OwnerUserId": "106064", "LastEditDate": "2009-08-18T13:42:29.570"}, "1293360": {"Id": "1293360", "PostTypeId": "2", "Body": "<p>If you try to delete an object twice, the second time will fail, because the heap is already freed. This is the normal behavior.</p>\n<p>Now, since you are in a multithreading context... it might be that the deletions are done \"almost\" in parallel, which might avoid the error on the second deletion, because the first one is not yet finalized.</p>\n", "LastActivityDate": "2009-08-18T11:46:20.257", "CommentCount": "0", "CreationDate": "2009-08-18T11:46:20.257", "ParentId": "1293326", "Score": "1", "OwnerUserId": "83153"}});