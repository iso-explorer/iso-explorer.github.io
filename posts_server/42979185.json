post_cb({"42979185": {"CommentCount": "0", "AcceptedAnswerId": "42980537", "PostTypeId": "1", "LastEditorUserId": "1317944", "CreationDate": "2017-03-23T14:36:52.753", "LastActivityDate": "2017-07-30T14:26:17.347", "LastEditDate": "2017-03-23T15:39:59.723", "ViewCount": "204", "FavoriteCount": "4", "Title": "Consequences of changing inheritance to virtual?", "Id": "42979185", "Score": "9", "Body": "<p>I'm working on a huge project that I didn't start. My task is to add some additional functionality to what already is there. I'm in a situation where I have to use virtual inheritance because I have a diamond model. The situation is depicted in the following illustration:</p>\n<pre><code>     Base class\n    /           \\\n   /             \\\nMy new class      A class that was there before (OldClass)\n   \\             /\n    \\           /\n     \\         /\n      \\       /\n    My other new class\n</code></pre>\n<p>For this to work, both the classes in the middle <a href=\"http://www.cprogramming.com/tutorial/virtual_inheritance.html\" rel=\"nofollow noreferrer\">have to</a> inherit from the base through <code>public virtual</code> instead of just <code>public</code>. So:</p>\n<pre><code>class OldClass: public BaseClass {}\n</code></pre>\n<p>has to become:</p>\n<pre><code>class OldClass: public virtual BaseClass {}\n</code></pre>\n<p>Since this project is really huge and I'm working on a small part of it, I don't want to break it by doing this. My adhoc tests worked and the program seems to work fine, but I'm still skeptic. </p>\n<p><strong>So my question is:</strong> What side effects and consequences should I expect by adding the <code>virtual</code> keyword? Is there anything to worry about?</p>\n", "Tags": "<c++><class><inheritance><multiple-inheritance><diamond-problem>", "OwnerUserId": "1317944", "AnswerCount": "4"}, "42980327": {"ParentId": "42979185", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-03-23T15:23:57.997", "Score": "3", "LastEditorUserId": "2445184", "LastEditDate": "2017-07-30T14:26:17.347", "Id": "42980327", "OwnerUserId": "2445184", "Body": "<p>In addition to what <a href=\"https://stackoverflow.com/a/42980537/2445184\">Simon Richter</a> said about calling constructors, using virtual inheritance means that you should be a bit more careful with your casts: You need to use <code>dynamic_cast&lt;&gt;</code> whenever you downcast a pointer in a hierarchy that includes virtual inheritance, as the relative offset between the base object and the goal type of the cast depends on the concrete actual type of the object. Other than that, everything else should work as expected.</p>\n", "LastActivityDate": "2017-07-30T14:26:17.347"}, "42980537": {"ParentId": "42979185", "CommentCount": "0", "CreationDate": "2017-03-23T15:32:34.150", "OwnerUserId": "613064", "PostTypeId": "2", "Id": "42980537", "Score": "7", "Body": "<p>The immediate consequence is that for regular inheritance, derived classes invoke the constructor of the immediate base, while for virtual inheritance, the most derived class (i.e. the one being instantiated directly) does, as this is the only place that would know all the virtual bases.</p>\n<p>Compare:</p>\n<pre><code>struct A { A(int) { } };\nstruct B : A { B(int i) : A(i) { } };\nstruct C : B { C(int i) : B(i) { } };\n</code></pre>\n<p>vs</p>\n<pre><code>struct A { A(int) { } };\nstruct B : virtual A { B(int i) : A(i) { } };\n// wrong: struct C : B { C(int i) : B(i) { } };\nstruct C : B { C(int i) : A(i), B(i) { } }; // correct\n</code></pre>\n<p>Also, the initializer behaviour is different, because the initializer for <code>A</code> in <code>B</code> is ignored if <code>B</code> is not the most derived class:</p>\n<pre><code>struct A { A(int i) { cout &lt;&lt; 'A' &lt;&lt; i; } };\nstruct B : virtual A { B(int i) : A(i+1) { cout &lt;&lt; 'B' &lt;&lt; i; } };\nstruct C : B { C(int i) : A(i+1), B(i+1) { cout &lt;&lt; 'C' &lt;&lt; i; } };\n\nA a(0);        // prints A0\nB b(0);        // prints A1B0\nC c(0);        // prints A1B1C0\n</code></pre>\n<p>If you had non-virtual inheritance here (which would force you to remove the <code>A</code> initializer in the <code>C</code> constructor, the third line would output <code>A2B1C0</code>.</p>\n", "LastActivityDate": "2017-03-23T15:32:34.150"}, "42979939": {"ParentId": "42979185", "CommentCount": "0", "CreationDate": "2017-03-23T15:07:43.200", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "42979939", "Score": "1", "Body": "<p>This is hard to answer in this abstract way, because it all depends on what the classes are doing and how you use them. </p>\n<p>Having virtual inheritance means that your two middle classes will share the same <code>Base</code>. Is that what you want?</p>\n<p>There is no language rule against actually having two separate <code>Base</code> classes in the hierarchy. It's just a bit harder to call member functions, because you have to explicitly indicate which copy you want to call by prefixing the function name <code>p-&gt;NewClass::base_function()</code>or <code>p-&gt;OldClass::base_function();</code>. That works if sharing <code>Base</code> data is not what you need.</p>\n<p>And like Serge says, if some other class only inherits one <code>Base</code>, it will still just contain one Base.</p>\n", "LastActivityDate": "2017-03-23T15:07:43.200"}, "42979681": {"ParentId": "42979185", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-03-23T14:56:22.897", "Score": "0", "LastEditorUserId": "3545273", "LastEditDate": "2017-03-23T15:13:48.047", "Id": "42979681", "OwnerUserId": "3545273", "Body": "<p>According to the standard, virtual inheritance is exactly the same as non virtual one except that only one single instance of the virtualy inherited class exists in the derived object.</p>\n<p>So in nothing in original code had multiple inheritance on classes derived from <code>Base</code>, changing the inheritance of <code>Base</code> to be virtual should not change behaviour. But you must consult of build the class hierachy to be sure of it.</p>\n<hr>\n<p>Refs from n4096 draft:</p>\n<blockquote>\n<p id=\"so_42979185_42979681_0\">10.1 Multiple base classes [class.mi]<br/>...<br/>\n  4 A base class specifier that does not contain the keyword virtual, specifies a non-virtual base class. A base\n  class specifier that contains the keyword virtual, specifies a virtual base class. For each distinct occurrence\n  of a non-virtual base class in the class lattice of the most derived class, the most derived object (1.8) shall\n  contain a corresponding distinct base class subobject of that type. For each distinct base class that is\n  specified virtual, the most derived object shall contain a single base class subobject of that type.</p>\n</blockquote>\n<p>And except from the examples following that paragraph, I could find no other reference to virtual inheritance in [class.mi].</p>\n</hr>", "LastActivityDate": "2017-03-23T15:13:48.047"}, "bq_ids": {"n4140": {"so_42979185_42979681_0": {"section_id": 6985, "quality": 0.875, "length": 56}}, "n3337": {"so_42979185_42979681_0": {"section_id": 6731, "quality": 0.875, "length": 56}}, "n4659": {"so_42979185_42979681_0": {"section_id": 8483, "quality": 0.828125, "length": 53}}}});