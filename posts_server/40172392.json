post_cb({"40172392": {"ViewCount": "221", "Body": "<p>Given a lambda:</p>\n<pre><code>auto f = [](const T&amp; var){ return var; };\n</code></pre>\n<p>Why return type of <code>f</code> is <code>T</code> (not <code>const T&amp;</code>)? Where is this in the Standard?</p>\n", "Title": "Why lambda removes cv and ref?", "CreationDate": "2016-10-21T08:59:23.443", "LastActivityDate": "2016-10-21T11:54:46.190", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-10-21T10:21:07.950", "LastEditorUserId": "3309790", "Id": "40172392", "Score": "5", "OwnerUserId": "1555823", "Tags": "<c++><c++11><lambda><language-lawyer><return-type-deduction>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_40172392_40173491_0": {"length": 45, "quality": 0.8823529411764706, "section_id": 5451}, "so_40172392_40173491_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 5938}}, "n3337": {"so_40172392_40173491_0": {"length": 35, "quality": 0.6862745098039216, "section_id": 5245}, "so_40172392_40173491_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 5710}}, "n4659": {"so_40172392_40173491_0": {"length": 49, "quality": 0.9607843137254902, "section_id": 6889}, "so_40172392_40173491_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 7422}}}, "40174800": {"Id": "40174800", "PostTypeId": "2", "Body": "<p>Return type deduction of <code>auto</code> return functions with no trailing return type in C++11 or 14 is done as if you did</p>\n<pre><code>auto retval = /* return expression */\n</code></pre>\n<p>and <code>auto</code> <em>always</em> deduces a value type.</p>\n<p>Lambdas are the only <code>auto</code> return functions in C++11.   In C++14 it was extended to other functions (following similar rules).</p>\n<p>In C++11 you can fix this with a <code>-&gt;decltype(var)</code> or a <code>-&gt;int const&amp;</code> trailing return type on your lambda.</p>\n<p>In C++14 you can simply <code>-&gt;decltype(auto)</code>, which changes the return type deduction rules from</p>\n<pre><code>auto retval = /* return expression */\n</code></pre>\n<p>to be more like</p>\n<pre><code>decltype(/* return expression */) retval = /* return expression */\n</code></pre>\n<p>which, in your case, means not dropping the <code>&amp;</code> or the <code>const</code>.</p>\n<p>Note that returning <code>const&amp;</code> parameters is exceedingly dangerous, as rvalues can be turned into <code>const&amp;</code> implicitly, and reference lifetime extension does not commute past a function call.  So:</p>\n<pre><code>auto&amp;&amp; x = some_function();\n// or\nint const&amp; x = some_function();\n</code></pre>\n<p>is safe even if <code>some_function()</code> returns a temporary, while assuming <code>f</code> behaves the way you want <code>f</code> to behave:</p>\n<pre><code>auto&amp;&amp; x = f( some_function() );\n// or\nint const&amp; x = f( some_function() );\n</code></pre>\n<p>generates <code>x</code> a dangling reference to the temporary returned by <code>some_function()</code>.</p>\n<p>This can break things surprisingly, like the fact that <code>for(:)</code> loops implicitly use <code>auto&amp;&amp;</code> parameters behind the scene, and clean up temporaries between the initialization of the range expression and the execution of the iteration.</p>\n<p>This answer is not yet complete, as I have not added references into the standard.</p>\n", "LastActivityDate": "2016-10-21T10:54:03.067", "Score": "2", "CreationDate": "2016-10-21T10:54:03.067", "ParentId": "40172392", "CommentCount": "0", "OwnerUserId": "1774667"}, "40173491": {"Id": "40173491", "PostTypeId": "2", "Body": "<p>The point is:</p>\n<ol>\n<li>The use of auto for return type deduction employ template type deduction rule.</li>\n<li>The return type is delcared as passed-by-value; which means that the reference-ness and top-level cv-qualifiers of expression used for deduction (i.e. <code>var</code>) are ignored.</li>\n</ol>\n<p>Quotes from the standard:</p>\n<p>About <a href=\"http://eel.is/c++draft/dcl.spec.auto#dcl.type.auto.deduct-4\" rel=\"nofollow\">auto</a>:</p>\n<blockquote>\n<p id=\"so_40172392_40173491_0\">If the placeholder is the auto type-specifier, the deduced type T' replacing T is determined using the rules for template argument deduction. Obtain P from T by replacing the occurrences of auto with either a new invented type template parameter U or, if the initialization is copy-list-initialization, with std::initializer_list. Deduce a value for U using the rules of template argument deduction from a function call ([temp.deduct.call]), where P is a function template parameter type and the corresponding argument is e. If the deduction fails, the declaration is ill-formed. Otherwise, T' is obtained by substituting the deduced U into P.</p>\n</blockquote>\n<p>About the rule of <a href=\"http://eel.is/c++draft/temp.deduct.call#2\" rel=\"nofollow\">template argument deduction from a function call</a>:</p>\n<blockquote>\n<p id=\"so_40172392_40173491_1\">If P is not a reference type:</p>\n<ul>\n<li>If A is a cv-qualified type, the top-level cv-qualifiers of A's type are ignored for type deduction.</li>\n</ul>\n</blockquote>\n<p>About <a href=\"http://eel.is/c++draft/expr#5\" rel=\"nofollow\">reference</a>:</p>\n<blockquote>\n<p id=\"so_40172392_40173491_2\">If an expression initially has the type \u201creference to T\u201d ([dcl.ref], [dcl.init.ref]), the type is adjusted to T prior to any further analysis.</p>\n</blockquote>\n<p>So for <code>var</code>(i.e. <code>A</code>) is <code>const T&amp;</code>, the deduced return type would be <code>T</code> here.</p>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2016-10-21T10:56:43.250", "Score": "5", "CreationDate": "2016-10-21T09:51:18.113", "ParentId": "40172392", "CommentCount": "0", "LastEditDate": "2016-10-21T10:56:43.250", "OwnerUserId": "3309790"}, "40174026": {"Id": "40174026", "PostTypeId": "2", "Body": "<p>This is a much more fundamental issue about C++. Nothing to do with specifically with lambdas or <code>auto</code>.</p>\n<p>In C++, a reference behaves the same as a non-reference in almost all situations. This is deliberate, and is based on the idea that a reference to an object really should be equivalent to the object itself. In the following code, there is no real difference between <code>x</code> and <code>y</code>:</p>\n<pre><code>int x  = 3;\nint &amp;y = x;\n</code></pre>\n<p>In fact, it is impossible to distinguish them (except via <code>decltype</code>). The are both lvalues of type <code>int</code>. If you call <code>foo(x)</code> and <code>foo(y)</code>, the compiler will treat them both as having the same type and value category and therefore the same overload is selected.</p>\n<p>I would interpret <code>x</code> and <code>y</code> by saying that both of them are references to the same object. They are two different 'names' for the same object.</p>\n<p>Therefore <code>return x</code> and <code>return y</code> are equivalent to each other, and therefore the lambda won't care about the <code>&amp;</code> when deducing its return type.</p>\n<p>This explains why the <code>&amp;</code> is ignored. C++ tries to \"ignore\" the <code>&amp;</code> as much as possible, precisely in order that references can be treated as fully equivalent to the original object.</p>\n<p>Now that it is established that we are returning by value, not by reference, then we can understand why the <code>const</code> is also ignored. A copy of an object doesn't need to be <code>const</code>. Consider this in reverse also: we can pass a <code>const int</code> argument as an <code>int</code> parameter of a function.</p>\n", "LastEditorUserId": "146041", "LastActivityDate": "2016-10-21T11:54:46.190", "Score": "4", "CreationDate": "2016-10-21T10:17:26.140", "ParentId": "40172392", "CommentCount": "2", "LastEditDate": "2016-10-21T11:54:46.190", "OwnerUserId": "146041"}});