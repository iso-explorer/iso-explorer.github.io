post_cb({"5523372": {"ParentId": "5523244", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2011-04-02T13:14:48.583", "Score": "5", "LastEditorUserId": "34509", "LastEditDate": "2011-04-02T14:11:01.100", "Id": "5523372", "OwnerUserId": "34509", "Body": "<blockquote>\n<p id=\"so_5523244_5523372_0\">If f() and g() both have side effects on some shared object then the behaviour is undefined because the order of execution is unknown. </p>\n</blockquote>\n<p>This is not true. Function invocations do not interleave, and there is a sequence point before entering functions, and before leaving functions. All side effects in <code>g</code> respective to side effects in <code>f</code> are separated by at least one sequence point. Behavior is not undefined. </p>\n<p>As a consequence, the order of execution of the functions <code>f</code> and <code>g</code> is not determined, but once one function is executed, only that function's evaluations are executed, and the other function \"has to wait\". Different observable results are possible, but this does not imply that undefined behavior has happened. </p>\n<blockquote>\n<p id=\"so_5523244_5523372_1\">Now I was wondering what happens when you chain member functions on an object.</p>\n</blockquote>\n<p>If you have <code>obj.foo().bar()</code> then you need to first evaluate <code>obj.foo()</code> to know what object you call function <code>bar</code> on, which means you have to wait for <code>obj.foo()</code> to return and yield a value. This however does not necessarily mean that all side effects initiated by evaluation of <code>obj.foo()</code> are finished. After evaluating an expression, you need a <em>sequence point</em> for those side effects to be considered complete. Because there is a sequence point before returning from <code>obj.foo()</code> and also before calling <code>bar()</code>, you have effectively a determined order for executing side effects initiated by evaluating expressions in <code>foo</code> and <code>bar</code> respectively. </p>\n<p>To explain a bit more, the reason <code>foo</code> is called before <code>bar</code> in your example is the same to why <code>i++</code> is first incremented before the function <code>f</code> is called in the following.</p>\n<pre><code>int i = 0;\nvoid f() {\n  std::cout &lt;&lt; i &lt;&lt; std::endl;\n}\n\ntypedef void (*fptype)();\nfptype fs[] = { f };\n\nint main() {\n  fs[i++]();\n}\n</code></pre>\n<p>The question to ask here is: Will this program print <code>0</code>, <code>1</code> or is its behavior undefined or unspecified? The answer is, because the expression <code>fs[i++]</code> necessarily has to be first evaluated before the function call, and there is a sequence point before entering <code>f</code>, the value of <code>i</code> inside <code>f</code> is <code>1</code>.</p>\n<p>I don't think you need to extend the scope of the implicit object parameter to sequence points to explain your case, and you certainly cannot extend it to explain this case (which I hope is defined behavior). </p>\n<hr>\n<p>The C++0x draft (which doesn't have sequence points anymore) has a more explicit wording of this (emphasize mine)</p>\n<blockquote>\n<p id=\"so_5523244_5523372_2\">When calling a function (whether or not the function is inline), every value computation and side effect associated with any argument expression, <strong>or with the postfix expression designating the called function</strong>, is sequenced before execution of every expression or statement in the body of the called function.</p>\n</blockquote>\n</hr>", "LastActivityDate": "2011-04-02T14:11:01.100"}, "5523244": {"CommentCount": "6", "ViewCount": "854", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2011-04-02T12:48:47.153", "LastActivityDate": "2011-12-22T11:37:55.480", "Title": "Sequence Points and Method Chaining", "AcceptedAnswerId": "5523366", "LastEditDate": "2011-12-22T11:37:55.480", "Id": "5523244", "Score": "12", "Body": "<p>The following expression is often used to demonstrate <strike>undefined</strike> unspecified behaviour:</p>\n<pre><code>f() + g()\n</code></pre>\n<p>If <code>f()</code> and <code>g()</code> both have side effects on some shared object then the behaviour is <strike>undefined</strike> unspecified because the order of execution is unknown. <code>f()</code> may be evaluated before <code>g()</code> or vice versa.</p>\n<p>Now I was wondering what happens when you chain member functions on an object. Let's say I have an instance of a class, the instance called <code>obj</code> and it has two member functions, <code>foo()</code> and <code>bar()</code> which both modify the object. The order of execution of these functions is not commutative. The effect of calling one before the other is not the same effect as calling them the other way around. Both methods return a reference to <code>*this</code> so that they can be chained like so:</p>\n<pre><code>obj.foo().bar()\n</code></pre>\n<p>But is this unspecified behaviour? I can't find anything in the standard (admittedly just scanning through) that differentiates between this expression and the expression I gave at the top of the post. Both function calls are subexpressions of the full-expression and so their order of execution is unspecified. But surely <code>foo()</code> <strong>must</strong> be evaluated first so that <code>bar()</code> knows which object to modify.</p>\n<p>Perhaps I'm missing something obvious, but I can't see where a sequence point is created.</p>\n", "Tags": "<c++><method-chaining><sequence-points>", "OwnerUserId": "150634", "AnswerCount": "3"}, "5523366": {"ParentId": "5523244", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2011-04-02T13:13:27.587", "Score": "10", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:00:46.997", "Id": "5523366", "OwnerUserId": "415784", "Body": "<pre><code>f() + g()\n</code></pre>\n<p>Here the behavior is <strong>unspecified</strong> (not <em>undefined</em>), because the order in which each operand is evaluated (that is, each function is called) is <em>unspecified</em>.</p>\n<pre><code> obj.foo().bar();\n</code></pre>\n<p>This is well-defined in C++.</p>\n<p>The relevant section \u00a71.9.17 from the C++ ISO standard reads,</p>\n<blockquote>\n<p id=\"so_5523244_5523366_0\">When calling a function (whether or\n  not the function is inline), there is\n  <strong>a sequence point after the evaluation\n  of all function arguments</strong> (if any)\n  <em>which takes place before execution of\n  any expressions or statements in the\n  function body</em>. There is also a\n  <strong>sequence point</strong> after the copying of a\n  returned value and <strong>before the\n  execution of any expressions outside\n  the function</strong>.</p>\n</blockquote>\n<p>Similar cases has been discussed in great detail, in these topics:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/4638364/undefined-behavior-and-sequence-points-reloaded\">Undefined behavior and sequence points reloaded</a></li>\n<li><a href=\"https://stackoverflow.com/questions/4709727/is-this-code-well-defined\">Is this code well-defined?</a></li>\n</ul>\n", "LastActivityDate": "2011-04-02T13:22:27.823"}, "bq_ids": {"n4140": {"so_5523244_5523372_2": {"section_id": 5811, "quality": 1.0, "length": 28}}, "n3337": {"so_5523244_5523372_2": {"section_id": 5584, "quality": 1.0, "length": 28}}, "n4659": {"so_5523244_5523372_2": {"section_id": 7273, "quality": 1.0, "length": 28}}}, "5523338": {"ParentId": "5523244", "CommentCount": "0", "CreationDate": "2011-04-02T13:06:21.157", "OwnerUserId": "688906", "PostTypeId": "2", "Id": "5523338", "Score": "1", "Body": "<p>Foo() will be executed before bar(). We have to determine Foo() first, or else we won't know what bar() should act on ( we wont even know what type of class bar() belongs to. It might be more intuitive to you if you think, what would we have to do if foo returned a new instance of obj, instead of this. Or if foo returned an instance of an entirely different class that also has a bar() method defined.</p>\n<p>You can test this yourself by using breakpoints in foo and bar and seeing which gets hit first.</p>\n", "LastActivityDate": "2011-04-02T13:06:21.157"}});