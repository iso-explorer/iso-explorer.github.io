post_cb({"bq_ids": {"n4140": {"so_33959802_33961058_0": {"length": 9, "quality": 1.0, "section_id": 7104}, "so_33959802_33961058_1": {"length": 24, "quality": 0.9230769230769231, "section_id": 7104}}, "n3337": {"so_33959802_33961058_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 6848}, "so_33959802_33961058_1": {"length": 24, "quality": 0.9230769230769231, "section_id": 6848}}, "n4659": {"so_33959802_33961058_0": {"length": 9, "quality": 1.0, "section_id": 8605}, "so_33959802_33961058_1": {"length": 24, "quality": 0.9230769230769231, "section_id": 8605}}}, "33959802": {"ViewCount": "197", "Body": "<p>I have this example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;tuple&gt;\n#include &lt;string&gt;\n\ntemplate &lt;typename T&gt;\nclass A {\npublic:\n    A(const T &amp;t) : m_t(t) {}\n    void foo() {\n        std::cout &lt;&lt; m_t &lt;&lt; std::endl;\n    }\n\nprivate:\n    T m_t;\n};\n\ntypedef std::tuple&lt;std::string, std::string&gt; Type;\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Type &amp;t) {\n    os &lt;&lt; std::get&lt;0&gt;(t) &lt;&lt; \" \" &lt;&lt; std::get&lt;1&gt;(t);\n    return os;\n}\n\nint main() {\n    A&lt;Type&gt; a(Type{\"ala\", \" ma kota\"});\n    a.foo();\n    return 0;\n}\n</code></pre>\n<p>which with clang++ (3.6) produces:</p>\n<pre><code>test_clang.cpp:10:19: error: call to function 'operator&lt;&lt;' that is neither visible in the template definition nor found by argument-dependent lookup\n        std::cout &lt;&lt; m_t &lt;&lt; std::endl;\n              ^\ntest_clang.cpp:26:7: note: in instantiation of member function 'A&lt;std::tuple&lt;std::basic_string&lt;char&gt;, std::basic_string&lt;char&gt; &gt; &gt;::foo' requested here\n    a.foo();\n      ^\ntest_clang.cpp:19:15: note: 'operator&lt;&lt;' should be declared prior to the call site\nstd::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Type &amp;t) {\n</code></pre>\n<p>No errors occurred during g++-4.8 with C++11 and g++-5.2.1 with C++17 builds. clang++-3.6 needs <code>std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const Type &amp;t)</code> to be defined <em>before</em> <code>A::foo&lt;T&gt;</code>.</p>\n<p>From my perspective member <code>m_t</code> depends on template argument type and used <code>operator&lt;&lt;</code> for this type shouldn't be needed during template definition. Why clang has compilation error and g++ doesn't?</p>\n", "AcceptedAnswerId": "33961058", "Title": "Operator << on template argument type member causes error only in clang", "CreationDate": "2015-11-27T14:44:27.803", "Id": "33959802", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-11-27T15:09:49.130", "LastEditorUserId": "2963099", "LastActivityDate": "2015-11-29T10:29:29.347", "Score": "10", "OwnerUserId": "2641513", "Tags": "<c++><templates><g++><language-lawyer><clang++>", "AnswerCount": "1"}, "33961058": {"Id": "33961058", "PostTypeId": "2", "Body": "<pre><code>std::tuple&lt;std::string, std::string&gt;\n</code></pre>\n<p>Let's look at the associated namespaces of this type. [basic.lookup.argdep]/(2.2):</p>\n<blockquote>\n<p id=\"so_33959802_33961058_0\">Its associated namespaces are the\n  innermost enclosing namespaces of its associated classes.</p>\n</blockquote>\n<p>That would be namespace <code>std</code> or auxiliary ones, but certainly not the global namespace. </p>\n<blockquote>\n<p id=\"so_33959802_33961058_1\">Furthermore, if <code>T</code> is a class template specialization, its associated\n  namespaces and classes also include: the namespaces and classes\n  associated with the types of the template arguments provided for\n  template type parameters (excluding template template parameters); [\u2026 inapplicable rules\u2026]</p>\n</blockquote>\n<p>Recursively applying the above to <code>std::string</code> gives namespace <code>std</code> (and, again, auxiliary ones) for the associated namespaces. Certainly not the global namespace. Clearly, the same argumentation can be repeated for <code>std::cout</code>, giving the same conclusion.</p>\n<p>Thus <strong>ADL won't look in the global namespace, which is precisely where your overload is declared in</strong>. </p>\n<p>Finally, as per [temp.dep.candidate]/1, name resolution is unsuccessful:</p>\n<p><a href=\"https://i.stack.imgur.com/RSJv9.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/RSJv9.png\"/></a></p>\n<p>GCC behaves non-conforming here; see <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51577\" rel=\"nofollow noreferrer\"><strong>#51577</strong></a>.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-11-29T10:29:29.347", "Score": "1", "CreationDate": "2015-11-27T16:01:44.610", "ParentId": "33959802", "CommentCount": "5", "LastEditDate": "2015-11-29T10:29:29.347", "OwnerUserId": "3647361"}});