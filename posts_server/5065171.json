post_cb({"5065363": {"PostTypeId": "2", "Body": "<p>Wow, this is confusing beyond belief. It defines <code>v1</code> as <code>tid</code> and it as the following (<code>ti</code> is the i-th perfect forwarding bind parameter, and <code>TiD</code> is the decayed type of that parameter - i.e an array becomes a pointer etc). </p>\n<blockquote>\n<p id=\"so_5065171_5065363_0\"><code>tid</code> is an lvalue of type <code>TiD</code> constructed from <code>std::forward&lt;Ti&gt;(ti)</code></p>\n</blockquote>\n<p>Alright, I did say, this <code>tid</code> is <code>std::forward&lt;Ti&gt;(ti)</code> and it's an lvalue! But this is not what it really means to say. It means</p>\n<blockquote>\n<p id=\"so_5065171_5065363_1\"><code>tid</code> is an lvalue of type <code>TiD</code> that refers to an object constructed from <code>std::forward&lt;Ti&gt;(ti)</code></p>\n</blockquote>\n<p>It makes much more sense now. Because what if <code>std::forward&lt;Ti&gt;(ti)</code> is actually an rvalue? The \"lvalue ... constructed from ...\" is meant to mean that we create a new object from \"...\" and make the lvalue refer to it. </p>\n", "LastActivityDate": "2011-02-21T11:26:12.287", "Id": "5065363", "CommentCount": "0", "CreationDate": "2011-02-21T11:26:12.287", "ParentId": "5065171", "Score": "2", "OwnerUserId": "34509"}, "bq_ids": {"n4140": {"so_5065171_5065363_1": {"length": 5, "quality": 0.625, "section_id": 4632}, "so_5065171_5065363_0": {"length": 6, "quality": 1.0, "section_id": 4632}}, "n3337": {"so_5065171_5065363_1": {"length": 5, "quality": 0.625, "section_id": 4443}, "so_5065171_5065363_0": {"length": 6, "quality": 1.0, "section_id": 4443}}}, "5065171": {"ViewCount": "949", "Body": "<p>I'm stuck reading the description of <code>std::bind</code> in N3225, in subsection <code>20.8.10.1</code>. It says the following should print <code>1</code>, but I thought that <code>bind</code> is supposed to copy its arguments and therefor it should print <code>0</code>. If one wants to refer to the passed argument, one needs to use <code>std::ref</code>, right?</p>\n<pre><code>void f(int &amp;a) { a = 1; }\n\nint main() {\n  int a = 0;\n  std::bind(f, a)();\n  std::cout &lt;&lt; a &lt;&lt; std::endl;\n}\n</code></pre>\n<p>GCC outputs <code>0</code>, agreeing with what I thought things work. But N3225 says that <code>std::bind(f, a1)</code> shall return a call wrapper that when called by <code>wrapper()</code> will call <code>INVOKE(f, v1)</code>, where <code>v1</code> shall be <code>a</code> (the argument I passed in, in other words, using <code>binds</code>'s incoming parameter which is a perfect forwarding parameter, <code>std::forward&lt;A1&gt;(a1)</code>).</p>\n<p><code>INVOKE(f, a)</code> is defined by 20.8.2 to <code>f(a)</code>. So, this defines that the call to the returned call wrapper <em>passes the original argument</em>. What am I missing?</p>\n", "AcceptedAnswerId": "5065363", "Title": "What the heck does std::bind(x, y) do?", "CreationDate": "2011-02-21T11:04:45.423", "Id": "5065171", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2011-10-02T10:44:41.010", "LastEditorUserId": "34509", "LastActivityDate": "2011-10-02T10:44:41.010", "Score": "13", "OwnerUserId": "34509", "Tags": "<c++><c++11><stdbind>", "AnswerCount": "3"}, "5066384": {"Id": "5066384", "PostTypeId": "2", "Body": "<p>It prints a 0 at present because at the point you call std::bind it doesn't know you want to pass a reference. It doesn't look at the signature of the function to see what parameter types it takes and adjust accordingly.</p>\n<p>To make it work properly call</p>\n<pre><code>void f(int &amp;a) { a = 1; }\n\nint main() {\n  int a = 0;\n  std::bind(f, std::ref(a))();\n  std::cout &lt;&lt; a &lt;&lt; std::endl;\n}\n</code></pre>\n<p>C++0x is suggesting \"perfect binding\" but there is a huge danger with this, which could badly break existing code silently that relies on the present behaviour. Here is a very simple example.</p>\n<pre><code>void myCallback( const std::string&amp; str, int i );\n\nfunction&lt; void(int) &gt; makeCallback( const std::string &amp; str )\n{\n    return bind( myCallback, str, _1 );\n}\n</code></pre>\n<p>At present you can rely on bind copying the string that you pass in with <code>str</code> and thus the fact it will be valid come the callback's invocation.</p>\n<p>If it \"smartly\" used \"perfect binding\" to store it as a reference, it would break situations like this. </p>\n", "LastEditorUserId": "442284", "LastActivityDate": "2011-02-24T16:45:03.297", "CommentCount": "2", "CreationDate": "2011-02-21T13:14:18.127", "ParentId": "5065171", "Score": "3", "OwnerUserId": "442284", "LastEditDate": "2011-02-24T16:45:03.297"}, "5066987": {"PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_5065171_5066987_0\">It says the following should print 1</p>\n</blockquote>\n<p>No, it does not say that.</p>\n<blockquote>\n<p id=\"so_5065171_5066987_1\">If one wants to refer to the passed argument, one needs to use std::ref, right?</p>\n</blockquote>\n<p>Yes.</p>\n<blockquote>\n<p id=\"so_5065171_5066987_2\">But N3225 says that std::bind(f, a1) shall return a call wrapper that when called by wrapper() will call INVOKE(f, v1), where v1 shall be a (the argument I passed in, in other words, using binds's incoming parameter which is a perfect forwarding parameter, std::forward(a1)).</p>\n</blockquote>\n<p>That's where you are wrong. The \"bound arguments\" you passed in at the bind-call are stored in form of newly created objects of type <code>TiD</code> which are each <em>constructed</em> from <code>forward&lt;Ti&gt;(ti)</code>. This is made reasonably clear by saying \"tid is an lvalue of type TiD <em>constructed</em> from <code>std::forward&lt;Ti&gt;(ti)</code>\". Due to the special treatment of reference wrappers, there is an additional \"transformation layer\". See 20.8.10.1.2/10 which explains how <code>vi</code> and <code>Vi</code> relate to <code>tid</code> and <code>TiD</code>.</p>\n", "LastActivityDate": "2011-02-21T14:11:54.040", "Id": "5066987", "CommentCount": "6", "CreationDate": "2011-02-21T14:11:54.040", "ParentId": "5065171", "Score": "5", "OwnerUserId": "172531"}});