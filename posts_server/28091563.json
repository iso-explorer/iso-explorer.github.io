post_cb({"28094135": {"ParentId": "28091563", "CommentCount": "0", "CreationDate": "2015-01-22T16:43:06.320", "OwnerUserId": "4083309", "PostTypeId": "2", "Id": "28094135", "Score": "12", "Body": "<p>No, because of operator overloading. This has been mentioned before, but I can give the real life example of <a href=\"https://en.wikipedia.org/wiki/Expression_templates\">expression templates</a>. The idea, generally, is to allow writing \"lazy\" expressions (that is, really, function objects or <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">AST</a>s) with syntax that is very similar to the normal, eager use of logical operators. Typically, many other operators, in particular arithmetic operators are also, overloaded.</p>\n<p>For instance, one design goal of Boost.Lambda was to simplify the use of algorithms:</p>\n<pre><code>std::string str;\n// ...\nstd:.string::iterator firstA = std::find_if(str.begin(), str.end(), _1 == 'a' || _1 == 'A');\n</code></pre>\n<p>Previously, in \"pure\" C++98, it was generally necessary to write numerous named functions or function objects before many standard algorithms could be used effectively.</p>\n<p>Since C++11, Boost.Lambda is not as useful any more since lambda expressions have been added to the core language. There are still numerous EDSLs (embedded domain-specific languages) where C++11 lambdas cannot replace expression templates though, e.g. you may want to generate SQL command strings directly from a C++ EDSL in a way similar to LINQ in .NET, but as a portable library solution. Another example: the <a href=\"https://ddemidov.github.io/vexcl/\">VexCL</a> library uses expression templates to generate GPU kernels.</p>\n<p>This is probably the only legitimate use of non-bool return types for overloaded logical operators, but it's not generally considered esoteric.</p>\n", "LastActivityDate": "2015-01-22T16:43:06.320"}, "28091563": {"CommentCount": "0", "AcceptedAnswerId": "28091743", "PostTypeId": "1", "LastEditorUserId": "15168", "CreationDate": "2015-01-22T14:45:12.083", "LastActivityDate": "2015-01-22T23:23:13.280", "LastEditDate": "2015-01-22T14:57:08.123", "ViewCount": "945", "FavoriteCount": "1", "Title": "Are conditional expressions in C++ always of bool type?", "Id": "28091563", "Score": "14", "Body": "<p>In C conditional-oriented operators evaluate to either <code>1</code> or <code>0</code> of type <code>int</code> (even if it does have dedicated <code>_Bool</code> type). Referring to <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\">C11 N1570 draft</a>:</p>\n<blockquote>\n<h3>C11 \u00a76.5.8/6 <em>Relational operators</em></h3>\n<p id=\"so_28091563_28091563_0\">Each of the operators <code>&lt;</code> (less than), <code>&gt;</code> (greater than), <code>&lt;=</code> (less than\n  or equal to), and <code>&gt;=</code> (greater than or equal to) shall yield 1 if the\n  specified relation is true and 0 if it is false.<sup>107)</sup> The result has\n  type <code>int</code>.</p>\n<h3>C11 \u00a76.5.9/3 <em>Equality operators</em></h3>\n<p id=\"so_28091563_28091563_1\">The <code>==</code> (equal to) and <code>!=</code> (not equal to) operators are analogous to the\n  relational operators except for their lower precedence.<sup>108)</sup> Each of\n  the operators yields 1 if the specified relation is true and 0 if it\n  is false. The result has type <code>int</code>. For any pair of operands, exactly\n  one of the relations is true.</p>\n<h3>C11 6.5.13/3 <em>Logical AND operator</em></h3>\n<p id=\"so_28091563_28091563_2\">The <code>&amp;&amp;</code> operator shall yield 1 if both of its operands compare unequal\n  to 0; otherwise, it yields 0. The result has type <code>int</code>.</p>\n<h3>C11 6.5.14/3 <em>Logical OR operator</em></h3>\n<p id=\"so_28091563_28091563_3\">The <code>||</code> operator shall yield 1 if either of its operands compare\n  unequal to 0; otherwise, it yields 0. The result has type <code>int</code>.</p>\n</blockquote>\n<p>As I checked C++ seems to be different in this matter, as in following example (see <a href=\"http://ideone.com/u3NxfW\">http://ideone.com/u3NxfW</a>):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n\nint main() {\n    double x = 10.0;\n\n    std::cout &lt;&lt; typeid(x &lt;= 10.0).name() &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>outputs <code>b</code>, which as I guess indicates <code>bool</code> type. Does C++ guarantee that all of these operators always evaluate to <code>bool</code> type (in contrast to C)? </p>\n", "Tags": "<c++><c><c++11><language-lawyer><c++03>", "OwnerUserId": "586873", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_28091563_28091563_0": {"section_id": 6149, "quality": 0.6666666666666666, "length": 14}}, "n3337": {"so_28091563_28091563_0": {"section_id": 5912, "quality": 0.6666666666666666, "length": 14}}, "n4659": {"so_28091563_28091563_0": {"section_id": 7646, "quality": 0.6666666666666666, "length": 14}}}, "28091743": {"ParentId": "28091563", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2015-01-22T14:53:24.100", "Score": "11", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:43:30.780", "Id": "28091743", "OwnerUserId": "1119701", "Body": "<p>Contrary to C, in C++, relational operators, equality operators and logical operators (logical AND, logical OR and logical negation) all yield a value of type <code>bool</code>.</p>\n<p>For example:</p>\n<blockquote>\n<p id=\"so_28091563_28091743_0\">(C++11, 5.9p1 Relational operators) \"[...] The type of the result is bool.\"</p>\n</blockquote>\n<p><strong>EDIT:</strong> for the sake of completeness, all the operators listed above can be overloaded and thus the resulting type can be changed. See Arne Vogel answer for real life <a href=\"https://stackoverflow.com/a/28094135/1119701\">example</a>.</p>\n", "LastActivityDate": "2015-01-22T23:23:13.280"}});