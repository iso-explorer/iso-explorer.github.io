post_cb({"bq_ids": {"n4140": {"so_6315670_6315670_1": {"section_id": 382, "quality": 0.9047619047619048, "length": 19}, "so_6315670_6315670_0": {"section_id": 381, "quality": 0.972972972972973, "length": 36}}, "n3337": {"so_6315670_6315670_1": {"section_id": 373, "quality": 0.9047619047619048, "length": 19}, "so_6315670_6315670_0": {"section_id": 372, "quality": 0.972972972972973, "length": 36}}, "n4659": {"so_6315670_6315670_1": {"section_id": 397, "quality": 0.8571428571428571, "length": 18}, "so_6315670_6315670_0": {"section_id": 396, "quality": 0.9459459459459459, "length": 35}}}, "6315670": {"CommentCount": "4", "ViewCount": "350", "PostTypeId": "1", "LastEditorUserId": "34509", "CreationDate": "2011-06-11T11:38:30.883", "LastActivityDate": "2017-08-19T10:21:19.827", "Title": "When an array is created by a subexpression, what happens with the temporaries therein?", "FavoriteCount": "2", "LastEditDate": "2011-10-03T13:11:14.677", "Id": "6315670", "Score": "18", "Body": "<p>I was reading these two paragraphs of the FDIS (12.2p{4,5}):</p>\n<blockquote>\n<p id=\"so_6315670_6315670_0\">There are two contexts in which temporaries are destroyed at a different point than the end of the full-expression. The first context is when a default constructor is called to initialize an element of an array. If the constructor has one or more default arguments, the destruction of every temporary created in a default argument is sequenced before the construction of the next array element, if any.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_6315670_6315670_1\">The second context is when a reference is bound to a temporary. The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference except:\n  [...]</p>\n<ul>\n<li>A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of the full-expression containing the call.</li>\n</ul>\n</blockquote>\n<p>These two two seem to contradict for the following case</p>\n<pre><code>struct A {\n  A() { std::cout &lt;&lt; \"C\" &lt;&lt; std::endl; }\n  ~A() { std::cout &lt;&lt; \"D\" &lt;&lt; std::endl; }\n};\n\nstruct B {\n  B(A const&amp; a = A()) { }\n};\n\ntypedef B array[2];\n\nint main() {\n  array{};\n}\n</code></pre>\n<p>Will this output <code>CDCD</code> as required by the first context, or will this output <code>CCDD</code> as required by the second context? GCC seems to follow the second context description and outputs <code>CCDD</code>. Have I overlooked something important? </p>\n<hr>\n<p>EDIT: I don't think it needs C++0x. This <code>new</code>-expression is affected too by my question:</p>\n<pre><code>new array(); /* CDCD or CCDD ?? */\n</code></pre>\n<p>In this case though, GCC follows the first context, and outputs <code>CDCD</code>.</p>\n</hr>", "Tags": "<c++><standards><c++11><temporary><lifetime>", "OwnerUserId": "34509", "AnswerCount": "1"}, "6317895": {"ParentId": "6315670", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>I don't think there's a contradiction. </p>\n<p>5.2.2 clearly says what a function call is. A function call is a postfix expression followed by parentheses\ncontaining a possibly empty,\ncomma-separated list of expressions\nwhich constitute the arguments to the\nfunction.</p>\n<p>There doesn't seem to be a function call to <code>B::B(A const&amp;)</code> anywhere in your program, so I don't see how the second passage applies.</p>\n<p>EDIT the above is probably incorrect, given 1.9p10 etc.</p>\n", "OwnerUserId": "775806", "LastEditorUserId": "775806", "LastEditDate": "2017-08-19T10:21:19.827", "Id": "6317895", "Score": "2", "CreationDate": "2011-06-11T18:56:54.240", "LastActivityDate": "2017-08-19T10:21:19.827"}});