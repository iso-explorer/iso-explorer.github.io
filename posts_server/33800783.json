post_cb({"33801155": {"Id": "33801155", "PostTypeId": "2", "Body": "<p>To understand the <code>enum</code>, start with considering the destructor without it:</p>\n<pre><code>~scoped_ptr() {\n    delete ptr_;\n}\n</code></pre>\n<p>where <code>ptr_</code> is a <code>C*</code>. If type <code>C</code> is incomplete at this point, i.e. all that the compiler knows is <code>struct C;</code>, then <sup>(1)</sup>a <em>default-generated</em> do-nothing destructor is used for the C instance pointed to. That's unlikely to be the right thing to do for an object managed by a smart pointer.</p>\n<p>If deleting via a pointer to incomplete type had always had Undefined Behavior, then the standard could just require the compiler to diagnose it and fail. But it's well-defined when the real destructor is trivial: knowledge that the programmer can have, but the compiler doesn't have. Why the language defines and allows this is beyond me, but C++ supports many practices that today are not regarded as best practices.</p>\n<p>A complete type has a known size, and hence, <code>sizeof(C)</code> will compile if and only if <code>C</code> is a complete type -- with known destructor. So it can be used as a guard. One way would be simply</p>\n<pre><code>(void) sizeof(C);  // Type must be complete\n</code></pre>\n<p>I would <em>guess</em> that with some compiler and options the compiler optimizes it away before it could notice that it shouldn't compile, and that the <code>enum</code> is a way to avoid such non-conforming compiler behavior:</p>\n<pre><code>enum { type_must_be_complete = sizeof(C) };\n</code></pre>\n<p>An alternative explanation for the choice of <code>enum</code> rather than just a discarded expression, is simply personal preference.</p>\n<p>Or as James T. Hugget suggests <a href=\"https://stackoverflow.com/questions/33800783/weird-enum-in-destructor/33801155?noredirect=1#comment55372517_33801155\">in a comment</a> to this answer, \u201cThe enum may be a way of creating a pseudo-portable error message at compile time\u201d.</p>\n<hr>\n<p><sup>\n<sup>(1)</sup> The default-generated do-nothing destructor for an incomplete type was a problem with old <code>std::auto_ptr</code>. It was so insidious that it made its way into <a href=\"http://www.gotw.ca/publications/using_auto_ptr_effectively.htm\" rel=\"nofollow noreferrer\">a GOTW item about the PIMPL idiom</a>, written by the chair of the international C++ standardization committee Herb Sutter. Of course, nowadays that <code>std::auto_ptr</code> is deprecated, one will instead use some other mechanism.\n</sup></p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-19T13:09:28.787", "Score": "28", "CreationDate": "2015-11-19T10:24:39.617", "ParentId": "33800783", "CommentCount": "6", "OwnerUserId": "464581", "LastEditDate": "2017-05-23T12:33:35.060"}, "33800783": {"ViewCount": "3287", "Body": "<p>Currently, I am reading the source code of <code>Protocol Buffer</code>, and I found one weird <code>enum</code> codes defined <a href=\"https://github.com/google/protobuf/blob/master/src/google/protobuf/stubs/scoped_ptr.h#L72-L75\" rel=\"noreferrer\">here</a></p>\n<pre><code>  ~scoped_ptr() {\n    enum { type_must_be_complete = sizeof(C) };\n    delete ptr_;\n  }\n\n  void reset(C* p = NULL) {\n    if (p != ptr_) {\n      enum { type_must_be_complete = sizeof(C) };\n      delete ptr_;\n      ptr_ = p;\n    }\n  }\n</code></pre>\n<p>Why the <code>enum { type_must_be_complete = sizeof(C) };</code> is defined here? what is it used for?</p>\n", "Title": "Weird enum in destructor", "CreationDate": "2015-11-19T10:09:07.090", "LastActivityDate": "2015-11-20T05:00:16.377", "CommentCount": "1", "FavoriteCount": "13", "PostTypeId": "1", "Id": "33800783", "Score": "83", "OwnerUserId": "3011380", "Tags": "<c++><enums>", "AnswerCount": "4"}, "33800866": {"Id": "33800866", "PostTypeId": "2", "Body": "<p>This trick avoids UB by ensuring that definition  of C is available when this destructor is compiled. Otherwise the compilation would fail as the <code>sizeof</code> incomplete type (forward declared types) can not be determined but the pointers can be used.</p>\n<p>In compiled binary, this code would be optimized out and would have no effect.</p>\n<p>Note that: <strong>Deleting incomplete type may be undefined behavior</strong> from 5.3.5/5:.</p>\n<blockquote>\n<p id=\"so_33800783_33800866_0\">if the object being deleted has <strong>incomplete class</strong> type at the point of\n  deletion and the complete class has a <strong>non-trivial destructor</strong> or a\n  deallocation function, the <strong>behavior is undefined</strong>.</p>\n</blockquote>\n<p><code>g++</code> even issues the following warning:</p>\n<blockquote>\n<p id=\"so_33800783_33800866_1\">warning: possible problem detected in invocation of delete\n  operator:<br> warning: 'p' has incomplete type<br> warning: forward\n  declaration of 'struct C'</br></br></p>\n</blockquote>\n", "LastEditorUserId": "2659313", "LastActivityDate": "2015-11-20T05:00:16.377", "Score": "80", "CreationDate": "2015-11-19T10:12:01.230", "ParentId": "33800783", "CommentCount": "2", "OwnerUserId": "2659313", "LastEditDate": "2015-11-20T05:00:16.377"}, "33800854": {"Id": "33800854", "PostTypeId": "2", "Body": "<p><code>sizeof(C)</code> will fail at <em>compile time</em> if <code>C</code> is not a complete type. Setting a local scope <code>enum</code> to it makes the statement benign at runtime.</p>\n<p>It's a way of the programmer protecting themselves from themselves: the behaviour of a subsequent <code>delete ptr_</code> on an incomplete type is undefined if it has a non-trivial destructor.</p>\n", "LastEditorUserId": "2380830", "LastActivityDate": "2015-11-19T10:34:52.370", "Score": "31", "CreationDate": "2015-11-19T10:11:32.053", "ParentId": "33800783", "CommentCount": "9", "OwnerUserId": "2380830", "LastEditDate": "2015-11-19T10:34:52.370"}, "bq_ids": {"n4140": {"so_33800783_33800866_0": {"length": 16, "quality": 1.0, "section_id": 6109}}, "n3337": {"so_33800783_33800866_0": {"length": 16, "quality": 1.0, "section_id": 5875}}, "n4659": {"so_33800783_33800866_0": {"length": 16, "quality": 1.0, "section_id": 7606}}}, "33800881": {"Id": "33800881", "PostTypeId": "2", "Body": "<p>Maybe a trick to be sure <code>C</code> is defined.</p>\n", "LastActivityDate": "2015-11-19T10:12:29.030", "CommentCount": "1", "CreationDate": "2015-11-19T10:12:29.030", "ParentId": "33800783", "Score": "3", "OwnerUserId": "5534341"}});