post_cb({"27423500": {"Id": "27423500", "PostTypeId": "2", "Body": "<pre><code>TestClass(const std::string &amp;d1)\n    : d(d1) {\n\nTestClass dut(\"d\");\n</code></pre>\n<p>I guess following is happening logically:-</p>\n<p>1) Your string literal <code>(\"d\")</code> would be implicitly converted to std::string (  Let's give it a name <code>'x'</code> ).</p>\n<p>2) So, <code>'x'</code> is a temporary which is bound to <code>d1</code> here. Lifetime of this temporary is extended to lifetime of your <code>d1</code>. Although that string literal would always be alive till the end of program.</p>\n<p>3) Now you're making <code>'d' refer to 'd1'</code>.</p>\n<p>4) At the end of your constructor <code>d1's</code> lifetime is over and so is <code>d's</code>.</p>\n<p>All compiler's are not so clever to figure out these minor glitches...</p>\n", "LastEditorUserId": "4047092", "LastActivityDate": "2014-12-11T13:29:48.263", "Score": "1", "CreationDate": "2014-12-11T12:59:09.180", "ParentId": "27423364", "CommentCount": "0", "OwnerUserId": "4047092", "LastEditDate": "2014-12-11T13:29:48.263"}, "27423456": {"Id": "27423456", "PostTypeId": "2", "Body": "<p>Binding a <code>const &amp;</code> to a temporary is valid and the compiler will ensure that the temporary will live at least as long as the reference. This allows you to do things like pass string literals into functions expecting a <code>const std::string &amp;</code>.</p>\n<p>In your case however you are copying that reference and thus the lifetime guarantee no longer holds. Your constructor exits and the temporary is destroyed and you are left with a reference to invalid memory.</p>\n", "LastActivityDate": "2014-12-11T12:56:14.407", "CommentCount": "1", "CreationDate": "2014-12-11T12:56:14.407", "ParentId": "27423364", "Score": "3", "OwnerUserId": "2558027"}, "bq_ids": {"n4140": {"so_27423364_27423503_0": {"length": 40, "quality": 0.8, "section_id": 382}}, "n3337": {"so_27423364_27423503_0": {"length": 40, "quality": 0.8, "section_id": 373}}, "n4659": {"so_27423364_27423503_0": {"length": 29, "quality": 0.58, "section_id": 397}}}, "27423502": {"Id": "27423502", "PostTypeId": "2", "Body": "<p>The problem is that there is no single point in which a warning would be warranted. It's only the combination of the call of the constructor and its implementation that leads to Undefined Behaviour.</p>\n<p>If you consider just the constructor:</p>\n<pre><code>class TestClass {\n  public:\n    const std::string &amp;d;\n\n    TestClass(const std::string &amp;d)\n        : d(d)\n    {}\n};\n</code></pre>\n<p>There's nothing wrong here, you got a reference and you're storing one. Here's an example of perfectly valid use:</p>\n<pre><code>class Widget {\n  std::string data;\n  TestClass test;\n\npublic:\n  Widget() : data(\"widget\"), test(data)\n  {}\n};\n</code></pre>\n<p>If you consider just the call site:</p>\n<pre><code>//Declaration visible is:\nTestClass(const std::string &amp;d);\n\nint main() {\n    TestClass dut(\"d\");\n}\n</code></pre>\n<p>Here, the compiler doesn't \"see\" (in the general case) the <em>definition</em> of the constructor. Imagine an alternative:</p>\n<pre><code>struct Gadget {\n  std::string d;\n\n  Gadget(cosnt std::string &amp;d) : d(d) {}\n};\n\nint main()\n{\n  Gadget g(\"d\");\n}\n</code></pre>\n<p>Surely you wouldn't want a warning here either.</p>\n<p>To summarise, both the call site and the constructor implementation are perfectly usable as-is. It's only their combination which causes issues, but that combination is beyond the context a compiler can reasonably use to emit warnings.</p>\n", "LastActivityDate": "2014-12-11T12:59:16.000", "CommentCount": "4", "CreationDate": "2014-12-11T12:59:16.000", "ParentId": "27423364", "Score": "2", "OwnerUserId": "1782465"}, "27423503": {"Id": "27423503", "PostTypeId": "2", "Body": "<p>No warning as no offense: </p>\n<p>local <code>const</code> references prolong the lifespan of the variable.</p>\n<p>The standard specifies such behavior in \u00a78.5.3/5, [dcl.init.ref], the section on initializers of reference declarations. The lifetime extension is not transitive through a function argument. \u00a712.2/5 [class.temporary]:</p>\n<blockquote>\n<p id=\"so_27423364_27423503_0\">The second context is when a reference is bound to a temporary. The temporary to which the reference is bound or the temporary that is\n  the complete object to a subobject of which the temporary is bound\n  persists for the lifetime of the reference except as specified below.\n  A temporary bound to a reference member in a constructor\u2019s\n  ctor-initializer (\u00a712.6.2 [class.base.init]) persists until the\n  constructor exits. A temporary bound to a reference parameter in a\n  function call (\u00a75.2.2 [expr.call]) persists until the completion of\n  the full expression containing the call.</p>\n</blockquote>\n<p>You can have a look at <a href=\"http://herbsutter.com/2008/01/01/gotw-88-a-candidate-for-the-most-important-const/\" rel=\"nofollow noreferrer\">gotw-88</a> for an extended and more readable discussion on this topic.</p>\n<h2>Undefined Behaviour</h2>\n<p>So is it your code correct? Nope, and its execution will lead to undefined behaviour. The real problem in your code snapshot is that the Undefined Behaviour is caused by the mix of two perfectly <strong>legal</strong> operations: the call of the constructor passing a temporary object (whose life spans inside the constructor block) and the binding of the reference in the constructor definition.</p>\n<p>The compiler is not <em>smart enough</em> to detect this explosive statement combination, so this is why you don't get any warning.</p>\n", "LastEditorUserId": "2200058", "LastActivityDate": "2014-12-11T18:46:02.203", "Score": "9", "CreationDate": "2014-12-11T12:59:16.977", "ParentId": "27423364", "CommentCount": "10", "OwnerUserId": "2200058", "LastEditDate": "2014-12-11T18:46:02.203"}, "27423364": {"ViewCount": "658", "Body": "<p>I have a <code>TestClass</code> with a <code>const&amp;</code> member variable. I know from various places and own experiences that it is a bad idea to initialize this <code>const&amp;</code> with the reference to a temporary value. So I was quite suprised that the following code will compile fine (tested with <code>gcc-4.9.1</code>, <code>clang-3.5</code>, and <code>scan-build-3.5</code>) but fail to run properly.</p>\n<pre><code>class TestClass {\n  public:\n    // removing the \"reference\" would remove the temporary-problem\n    const std::string &amp;d;\n\n    TestClass(const std::string &amp;d)\n        : d(d) {\n        // \"d\" is a const-ref, cannot be changed at all... if it is assigned some\n        // temporary value it is mangled up...\n    }\n};\n\nint main() {\n\n    // NOTE: the variable \"d\" is a\n    // temporary, whose reference is not valid... what I don't get in the\n    // moment: why does no compiler warn me?\n    TestClass dut(\"d\");\n\n    // and printing what we got:\n    std::cout &lt;&lt; \"beginning output:\\n\\n\";\n    // this will silently abort the program (gcc-4.9.1) or be empty\n    // (clang-3.5) -- don't know whats going on here...\n    std::cout &lt;&lt; \"dut.d: '\" &lt;&lt; dut.d &lt;&lt; \"'\\n\";\n    std::cout &lt;&lt; \"\\nthats it!\\n\";\n\n    return 0;\n}\n</code></pre>\n<p>Why does none of the two compilers warn me at compile-time? See also this <a href=\"http://ideone.com/NDI9Gw\" rel=\"nofollow\">ideone</a>, with some more testing going on.</p>\n", "AcceptedAnswerId": "27423503", "Title": "Binding const& of temporary: No compiler warning?", "CreationDate": "2014-12-11T12:51:04.563", "Id": "27423364", "CommentCount": "7", "LastEditDate": "2014-12-11T16:19:22.990", "PostTypeId": "1", "LastEditorUserId": "19405", "LastActivityDate": "2014-12-11T18:46:02.203", "Score": "11", "OwnerUserId": "3520187", "Tags": "<c++><const-reference>", "AnswerCount": "4"}});