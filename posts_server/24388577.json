post_cb({"24388917": {"ParentId": "24388577", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_24388577_24388917_0\">But inside a lambda, <code>this</code> pointer points to the lambda instead of the outter class.</p>\n</blockquote>\n<p>No, inside the lambda <code>this</code> has the same value as outside. The only problem in your code is accessing <code>this</code> with <code>.</code> instead of <code>-&gt;</code>. This program:</p>\n<pre><code>void MyClass::myFunction() {\n    std::cout &lt;&lt; this &lt;&lt; std::endl;\n    // call the lambda1\n    connect(action, trigger, [this]() {\n        std::cout &lt;&lt; this &lt;&lt; std::endl;\n        // in the lambda1, call lambda2\n        sendCommand([this]() {      // &lt;-- I want `this` point to the outter class\n            std::cout &lt;&lt; this &lt;&lt; std::endl;\n            this-&gt;myMember.log(\"something\");  // myMember is the member of class MyClass\n        });\n    });\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/8675eeb13b245db0\" rel=\"nofollow\">Prints the same value for this in all three places</a>:</p>\n<pre>\ng++ -std=c++11 -O3 -Wall -Wextra -pedantic -pthread main.cpp &amp;&amp; ./a.out\n0x7fff4286c80f\n0x7fff4286c80f\n0x7fff4286c80f\n</pre>\n<p>N3936 (C++14 Working Draft) [expr.prim.lambda]/18 states:</p>\n<blockquote>\n<p id=\"so_24388577_24388917_1\">Every <em>id-expression</em> within the <em>compound-statement</em> of a <em>lambda-expression</em> that is an odr-use (3.2) of an entity captured by copy is transformed into an access to the corresponding unnamed data member of the closure type. [ <em>Note:</em> An <em>id-expression</em> that is not an odr-use refers to the original entity, never to a member of the closure type. Furthermore, such an <em>id-expression</em> does not cause the implicit capture of the entity. \u2014<em>end note</em> ] If <code>this</code> is captured, each odr-use of <code>this</code> is transformed into an access to the corresponding unnamed data member of the closure type, cast (5.4) to the type of <code>this</code>. [ <em>Note:</em> The cast ensures that the transformed expression is a prvalue. \u2014<em>end note</em> ]</p>\n</blockquote>\n", "OwnerUserId": "923854", "LastEditorUserId": "923854", "LastEditDate": "2014-06-24T14:21:47.890", "Id": "24388917", "Score": "3", "CreationDate": "2014-06-24T14:14:14.710", "LastActivityDate": "2014-06-24T14:21:47.890"}, "24388680": {"ParentId": "24388577", "CommentCount": "0", "Body": "<p>You simply capture outer lambda's context:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Omg\n{\n  int lol= 42;\n\n  Omg()\n  {\n    [this]{ [&amp;]{ std::cout&lt;&lt; this-&gt; lol; }(); }();\n  }\n};\n\nint main(){ Omg(); }\n</code></pre>\n", "OwnerUserId": "227755", "PostTypeId": "2", "Id": "24388680", "Score": "2", "CreationDate": "2014-06-24T14:03:16.217", "LastActivityDate": "2014-06-24T14:03:16.217"}, "bq_ids": {"n4140": {"so_24388577_24388917_1": {"section_id": 5977, "quality": 0.8852459016393442, "length": 54}}, "n3337": {"so_24388577_24388917_1": {"section_id": 5745, "quality": 0.8360655737704918, "length": 51}}, "n4659": {"so_24388577_24388917_1": {"section_id": 7474, "quality": 0.8688524590163934, "length": 53}}}, "24388577": {"CommentCount": "4", "ViewCount": "1574", "PostTypeId": "1", "LastEditorUserId": "420683", "CreationDate": "2014-06-24T13:58:18.373", "LastActivityDate": "2014-06-24T15:19:17.827", "Title": "C++11 variable capture with lambda inside another lambda", "LastEditDate": "2014-06-24T15:19:17.827", "Id": "24388577", "Score": "0", "Body": "<p>In node.js I can write lambda inside lambda and capture whichever variable I want. But in C++11, as lambda functions are actually functor object, variable capturing is not so easy with nested lambdas.</p>\n<p>I'm using <code>[this]</code> to capture this pointer so I can use class members. But inside a lambda, <code>this</code> pointer points to the lambda instead of the outter class.</p>\n<pre><code>void MyClass::myFunction() {\n    // call the lambda1\n    connect(action, trigger, [this]() {\n        // in the lambda1, call lambda2\n        sendCommand([this]() {      // &lt;-- I want `this` point to the outter class\n            this-&gt;myMember.log(\"something\");  // myMember is the member of class MyClass\n        });\n    });\n}\n</code></pre>\n<p>I know it can be done by rename this to another pointer variable and capture that variable instead of <code>this</code>, but I think that way is ugly.</p>\n<p>Is there any better way to capture outter <code>this</code>?</p>\n", "Tags": "<c++><c++11><lambda>", "OwnerUserId": "2422527", "AnswerCount": "2"}});