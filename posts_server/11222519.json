post_cb({"bq_ids": {"n4140": {"so_11222519_11222807_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 89}}, "n3337": {"so_11222519_11222807_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 84}}}, "11222807": {"PostTypeId": "2", "Body": "<p>The answer lies in the C++ Standard. Sorry for being outdated, but my version (ISO/IEC 14882, 2nd Ed. 2003) says (page 246):</p>\n<blockquote>\n<p id=\"so_11222519_11222807_0\">\u00a714.3.2 Template non-type arguments  </p>\n<pre><code>   [..]\n</code></pre>\n<p id=\"so_11222519_11222807_1\">3 [Note: Addresses of array elements and names or \n           addresses of non-static class members are not acceptable template-arguments.[..]]</p>\n</blockquote>\n", "LastActivityDate": "2012-06-27T09:05:22.370", "Id": "11222807", "CommentCount": "7", "CreationDate": "2012-06-27T09:05:22.370", "ParentId": "11222519", "Score": "1", "OwnerUserId": "989510"}, "11222519": {"ViewCount": "103", "Body": "<p>I try to reference to an child element of an global variable by using an template parameter - it does work for globals but not for childs of globals - why is the position resolving of an child not possible at compile-time?</p>\n<pre><code>typedef unsigned char byte_t;\ntypedef unsigned short word_t;\n\nstruct byte_reg_t\n{\n     byte_t low;\n     byte_t high;\n};\n\nunion word_reg_t\n{\n     word_t value;\n     byte_reg_t part;\n};\n\nword_t rax;\nbyte_t rah;\nword_reg_t r16;\nbyte_reg_t r8;\n\ntemplate&lt;typename ValueType, ValueType&amp; Ref&gt;\nValueType ret_ref()\n{\n     return Ref;\n}\n\nint main()\n{\n    word_t x = ret_ref&lt;word_t,rax&gt;();\n    byte_t h = ret_ref&lt;byte_t,rah&gt;();\n    //word_t sx = ret_ref&lt;word_t,r16.value&gt;(); // compile error\n    //byte_t sh = ret_ref&lt;byte_t,r16.part.low&gt;(); // compile error\n    //byte_t sh2 = ret_ref&lt;byte_t,r8.low&gt;(); // compile error\n\n    return 0;\n} \n</code></pre>\n<p>the VS2010 and clang 3.1 compiler does not allow the // compile error lines</p>\n<p>thx for any clear description because i don't see any technical reason for that behavior of the compilers</p>\n", "AcceptedAnswerId": "11222807", "Title": "why are struct/union childs of global not allowed as template reference parameter - but the globals itself?", "CreationDate": "2012-06-27T08:48:07.823", "Id": "11222519", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2012-06-27T09:05:22.370", "Score": "2", "OwnerUserId": "951272", "Tags": "<c++><templates><globals>", "AnswerCount": "1"}});