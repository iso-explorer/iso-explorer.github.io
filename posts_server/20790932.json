post_cb({"20791007": {"ParentId": "20790932", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>In C++11, the <code>using</code> keyword when used for <code>type alias</code> is identical to <code>typedef</code>.</p>\n<p>7.1.3.2</p>\n<blockquote>\n<p id=\"so_20790932_20791007_0\">A typedef-name can also be introduced by an alias-declaration. The\n  identifier following the using keyword becomes a typedef-name and the\n  optional attribute-specifier-seq following the identifier appertains\n  to that typedef-name. It has the same semantics as if it were\n  introduced by the typedef specifier. In particular, it does not define\n  a new type and it shall not appear in the type-id.</p>\n</blockquote>\n<p>Bjarne Stroustrup provides a practical example:</p>\n<pre><code>typedef void (*PFD)(double);    // C style\nusing PF = void (*)(double);    // using plus C-style type\nusing P = [](double)-&gt;void; // using plus suffix return type, syntax error\nusing P = auto(double)-&gt;void // Fixed thanks to DyP\n</code></pre>\n<p>Pre-C++11, the <code>using</code> keyword can bring member functions into scope. In C++11, you can now do this for constructors (another Bjarne Stroustrup example):</p>\n<pre><code>class Derived : public Base { \npublic: \n    using Base::f;    // lift Base's f into Derived's scope -- works in C++98\n    void f(char);     // provide a new f \n    void f(int);      // prefer this f to Base::f(int) \n\n    using Base::Base; // lift Base constructors Derived's scope -- C++11 only\n    Derived(char);    // provide a new constructor \n    Derived(int);     // prefer this constructor to Base::Base(int) \n    // ...\n}; \n</code></pre>\n<hr/>\n<p>Ben Voight provides a pretty good reason behind the rationale of not introducing a new keyword or new syntax. The standard wants to avoid breaking old code as much as possible. This is why in proposal documents you will see sections like <code>Impact on the Standard</code>, <code>Design decisions</code>, and how they might affect older code. There are situations when a proposal seems like a really good idea but might not have traction because it would be too difficult to implement, too confusing, or would contradict old code.</p>\n<hr/>\n<p>Here is an old paper from 2003 <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1449.pdf\" rel=\"noreferrer\">n1449</a>. The rationale seems to be related to templates. Warning: there may be typos due to copying over from PDF.</p>\n<blockquote>\n<p id=\"so_20790932_20791007_1\">First let\u2019s consider a toy example:</p>\n<pre><code>template &lt;typename T&gt;\nclass MyAlloc {/*...*/};\n\ntemplate &lt;typename T, class A&gt;\nclass MyVector {/*...*/};\n\ntemplate &lt;typename T&gt;\n\nstruct Vec {\ntypedef MyVector&lt;T, MyAlloc&lt;T&gt; &gt; type;\n};\nVec&lt;int&gt;::type p; // sample usage\n</code></pre>\n<p id=\"so_20790932_20791007_2\">The fundamental problem with this idiom, and the main motivating fact\n  for this proposal, is that the idiom causes the template parameters to\n  appear in non-deducible context. That is, it will not be possible to\n  call the function foo below without explicitly specifying template\n  arguments.</p>\n<pre><code>template &lt;typename T&gt; void foo (Vec&lt;T&gt;::type&amp;);\n</code></pre>\n<p id=\"so_20790932_20791007_3\">So, the syntax is somewhat ugly. We would rather avoid the nested <code>::type</code>\n  We\u2019d prefer something like the following:</p>\n<pre><code>template &lt;typename T&gt;\nusing Vec = MyVector&lt;T, MyAlloc&lt;T&gt; &gt;; //defined in section 2 below\nVec&lt;int&gt; p; // sample usage\n</code></pre>\n<p id=\"so_20790932_20791007_4\">Note that we specifically avoid the term \u201ctypedef template\u201d and intr\n  oduce the new syntax involving the pair \u201cusing\u201d and \u201c=\u201d to help avoid\n  confusion: we are not defining any types here, we are introducing a\n  synonym (i.e. alias) for an abstraction of a type-id (i.e. type\n  expression) involving template parameters. If the template parameters\n  are used in deducible contexts in the type expression then whenever\n  the template alias is used to form a template-id, the values of the\n  corresponding template parameters can be deduced \u2013 more on this will\n  follow. In any case, it is now possible to write generic functions\n  which operate on <code>Vec&lt;T&gt;</code> in deducible context, and the syntax is\n  improved as well. For example we could rewrite foo as:</p>\n<pre><code>template &lt;typename T&gt; void foo (Vec&lt;T&gt;&amp;);\n</code></pre>\n<p id=\"so_20790932_20791007_5\">We underscore here that one of the primary reasons for proposing\n  template aliases was so that argument deduction and the call to <code>foo(p)</code>\n  will succeed.</p>\n</blockquote>\n<hr/>\n<p>The follow-up paper <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1489.pdf\" rel=\"noreferrer\">n1489</a> explains why <code>using</code> instead of using <code>typedef</code>:</p>\n<blockquote>\n<p id=\"so_20790932_20791007_6\">It has been suggested to (re)use the keyword typedef \u2014 as done in the\n  paper [4] \u2014 to introduce template aliases:</p>\n<pre><code>template&lt;class T&gt; \n    typedef std::vector&lt;T, MyAllocator&lt;T&gt; &gt; Vec;\n</code></pre>\n<p id=\"so_20790932_20791007_7\">That notation has the advantage of using a keyword already known to\n  introduce a type alias. However, it also displays several\n  disavantages among which the confusion of using a keyword known to\n  introduce an alias for a type-name in a context where the alias does\n  not designate a type, but a template; <code>Vec</code> is not an alias for a\n  type, and should not be taken for a typedef-name. The name <code>Vec</code> is a\n  name for the family <code>std::vector&lt; [bullet] , MyAllocator&lt; [bullet] &gt; &gt;</code>\n  \u2013 where the bullet is a placeholder for a type-name. Consequently we\n  do not propose the \u201ctypedef\u201d syntax. On the other hand the sentence</p>\n<pre><code>template&lt;class T&gt;\n    using Vec = std::vector&lt;T, MyAllocator&lt;T&gt; &gt;;\n</code></pre>\n<p id=\"so_20790932_20791007_8\">can be read/interpreted as: from now on, I\u2019ll be using <code>Vec&lt;T&gt;</code> as a\n  synonym for <code>std::vector&lt;T, MyAllocator&lt;T&gt; &gt;</code>. With that reading, the\n  new syntax for aliasing seems reasonably logical.</p>\n</blockquote>\n<p>I think the important distinction is made here, <em>alias</em>es instead of <em>type</em>s. Another quote from the same document:</p>\n<blockquote>\n<p id=\"so_20790932_20791007_9\">An alias-declaration is a declaration, and not a definition. An alias-\n  declaration introduces a name into a declarative region as an alias\n  for the type designated by the right-hand-side of the declaration. The\n  core of this proposal concerns itself with type name aliases, but the\n  notation can obviously be generalized to provide alternate spellings\n  of namespace-aliasing or naming set of overloaded functions (see \u2701\n   2.3 for further discussion). [<b>My note: That section discusses what that syntax can look like and reasons why it isn't part of the proposal.</b>] It may be noted that the grammar production alias-declaration is acceptable anywhere a typedef\n  declaration or a namespace-alias-definition is acceptable.</p>\n</blockquote>\n<p>Summary, for the role of <code>using</code>:</p>\n<ul>\n<li>template aliases (or template typedefs, the former is preferred namewise)</li>\n<li>namespace aliases (i.e., <code>namespace PO = boost::program_options</code> and <code>using PO = ...</code> equivalent)</li>\n<li>the document says <code>A typedef declaration can be viewed as a special case of non-template alias-declaration</code>. It's an aesthetic change, and is considered identical in this case.</li>\n<li>bringing something into scope (for example, <code>namespace std</code> into the global scope), member functions, inheriting constructors</li>\n</ul>\n<p>It <b>cannot</b> be used for:</p>\n<pre><code>int i;\nusing r = i; // compile-error\n</code></pre>\n<p>Instead do:</p>\n<pre><code>using r = decltype(i);\n</code></pre>\n<p>Naming a set of overloads.</p>\n<pre><code>// bring cos into scope\nusing std::cos;\n\n// invalid syntax\nusing std::cos(double);\n\n// not allowed, instead use Bjarne Stroustrup function pointer alias example\nusing test = std::cos(double);\n</code></pre>\n", "Id": "20791007", "LastEditDate": "2013-12-26T22:28:42.393", "OwnerDisplayName": "user1508519", "Score": "49", "CreationDate": "2013-12-26T20:44:40.867", "LastActivityDate": "2013-12-26T22:28:42.393", "LastEditorDisplayName": "user1508519"}, "bq_ids": {"n4140": {"so_20790932_20791007_0": {"section_id": 5408, "quality": 0.967741935483871, "length": 30}}, "n3337": {"so_20790932_20791007_0": {"section_id": 5203, "quality": 0.967741935483871, "length": 30}}, "n4659": {"so_20790932_20791007_0": {"section_id": 6830, "quality": 0.9032258064516129, "length": 28}}}, "20790932": {"CommentCount": "7", "AcceptedAnswerId": "20791007", "CreationDate": "2013-12-26T20:37:14.943", "LastActivityDate": "2013-12-26T22:28:42.393", "PostTypeId": "1", "ViewCount": "33044", "FavoriteCount": "19", "Title": "What is the logic behind the \"using\" keyword in C++?", "Id": "20790932", "Score": "50", "Body": "<p>What is the logic behind the \"using\" keyword in C++?</p>\n<p>It is used in different situations and I am trying to find\nif all those have something in common and there is a reason\nwhy the \"using\" keyword is used as such.</p>\n<pre><code>using namespace std; // to import namespace in the current namespace\nusing T = int; // type alias\nusing SuperClass::X; // using super class methods in derived class\n</code></pre>\n", "Tags": "<c++><c++11>", "OwnerUserId": "3111311", "AnswerCount": "1"}});