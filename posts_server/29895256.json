post_cb({"29895468": {"ParentId": "29895256", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_29895256_29895468_0\"><code>[C++11: 20.7.1.2/3]</code> If the type <code>remove_reference&lt;D&gt;::type::pointer</code> exists, then <code>unique_ptr&lt;T, D&gt;::pointer</code> shall be a synonym for <code>remove_reference&lt;D&gt;::type::pointer</code>. Otherwise <code>unique_ptr&lt;T, D&gt;::pointer</code> shall be a synonym for <code>T*</code>. The type <code>unique_ptr&lt;T, D&gt;::pointer</code> shall satisfy the requirements of <em>NullablePointer</em> (17.6.3.3).</p>\n</blockquote>\n<p>It's required here because you have no <code>operator()(int*)</code> \u2014 you are \"hacking\" around that to allow <code>operator()(void*)</code> to be used instead by making the deleter pretend it's a deleter for <code>void*</code>.</p>\n<p>Whether your deleter as a whole remains strictly valid even when it compiles, I wouldn't like to say.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "29895468", "Score": "1", "CreationDate": "2015-04-27T12:14:27.010", "LastActivityDate": "2015-04-27T12:14:27.010"}, "29895256": {"CommentCount": "0", "ViewCount": "167", "CreationDate": "2015-04-27T12:04:25.970", "LastActivityDate": "2015-04-27T12:16:15.887", "Title": "Smart pointer deleter and \"using\" keyword with a name \"pointer\"", "AcceptedAnswerId": "29895471", "PostTypeId": "1", "Id": "29895256", "Score": "7", "Body": "<p>Sometimes ago I saw a code like this:</p>\n<pre><code>void* Create()\n{\n    int* t{new int{10}};\n    return t;\n}\n\nclass Deleter\n{\n    //uncomment in order to compile\n    //using pointer = void*;\npublic:\n    void operator()(void* t)\n    {\n        delete t;\n    }\n};\n\nunique_ptr&lt;int, Deleter&gt; ptr{Create()};\n</code></pre>\n<p>It doesn't compiles. With VS2013 it says:</p>\n<blockquote>\n<p id=\"so_29895256_29895256_0\">error: C2440: 'initializing' : cannot convert from 'initializer-list'\n  to 'std::unique_ptr' No constructor could take the source\n  type, or constructor overload resolution was ambiguous</p>\n</blockquote>\n<p>But if I uncomment line <code>using pointer = void*;</code> it works! Also if I change a name of alias to something different than <code>pointer</code> I get the same error. So it seems that having a <code>using</code> directive with exact name <code>pointer</code> is crucial. But why? I couldn't find any explanation.</p>\n", "Tags": "<c++><smart-pointers>", "OwnerUserId": "1341942", "AnswerCount": "2"}, "29895471": {"ParentId": "29895256", "CommentCount": "0", "Body": "<p>Your <code>unique_ptr</code> declared with <code>T=int</code>. However, <a href=\"http://en.cppreference.com/w/cpp/memory/unique_ptr/unique_ptr\">constructors in <code>std::unique_ptr</code></a> take not <code>T*</code>, but <code>pointer</code> argument instead.</p>\n<p>This <code>pointer</code> type defined as</p>\n<pre><code>std::remove_reference&lt;Deleter&gt;::type::pointer if that type exists, otherwise T*\n</code></pre>\n<p>And when you don't provide <code>Deleter::pointer</code> it ends up as <code>int*</code>, and of course can't be initialized from <code>void*</code> (from <code>Create</code>). </p>\n", "OwnerUserId": "2512323", "PostTypeId": "2", "Id": "29895471", "Score": "6", "CreationDate": "2015-04-27T12:14:48.603", "LastActivityDate": "2015-04-27T12:14:48.603"}, "bq_ids": {"n4140": {"so_29895256_29895468_0": {"section_id": 4292, "quality": 0.7272727272727273, "length": 16}}, "n3337": {"so_29895256_29895468_0": {"section_id": 4133, "quality": 0.8181818181818182, "length": 18}}, "n4659": {"so_29895256_29895468_0": {"section_id": 5550, "quality": 0.6818181818181818, "length": 15}}}});