post_cb({"bq_ids": {"n4140": {"so_4607418_4608296_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 4605}}, "n3337": {"so_4607418_4608296_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 4423}}, "n4659": {"so_4607418_4608296_0": {"length": 11, "quality": 0.7333333333333333, "section_id": 5962}}}, "4607440": {"Id": "4607440", "PostTypeId": "2", "Body": "<p>In C++, you can't compare just any pointers using the relational operators.  You can only compare two pointers that point to elements in the same array or two pointers that point to members of the same object.  (You can also compare a pointer with itself, of course.)</p>\n<p>You can, however, use <code>std::less</code> and the other relational comparison function objects to compare any two pointers.  The results are implementation-defined, but it is guaranteed that there is a total ordering.</p>\n<p>If you have a flat address space, it's likely that pointer comparisons just compare addresses as if they are integers.</p>\n<p>(I believe the rules are the same in C, without the comparison function objects, but someone will have to confirm that; I'm not nearly as familiar with C as I am with C++.)</p>\n", "LastActivityDate": "2011-01-05T17:56:06.423", "CommentCount": "19", "CreationDate": "2011-01-05T17:56:06.423", "ParentId": "4607418", "Score": "15", "OwnerUserId": "151292"}, "4607439": {"Id": "4607439", "PostTypeId": "2", "Body": "<p>Yes, they just compare memory address.</p>\n", "LastActivityDate": "2011-01-05T17:55:52.640", "CommentCount": "0", "CreationDate": "2011-01-05T17:55:52.640", "ParentId": "4607418", "Score": "1", "OwnerUserId": "476716"}, "4608296": {"Id": "4608296", "PostTypeId": "2", "Body": "<p>This is just a supplementation.</p>\n<p>In C++ 20.3.3/8:</p>\n<blockquote>\n<p id=\"so_4607418_4608296_0\">For templates greater, less,\n  greater_equal, and less_equal, the\n  specializations for any pointer type\n  yield a total order, even if the\n  built-in operators &lt;, &gt;, &lt;=, &gt;= do\n  not.</p>\n</blockquote>\n<p>In C 6.5.8/5:</p>\n<blockquote>\n<p id=\"so_4607418_4608296_1\">If two pointers to object or\n  incomplete types both point to the\n  same object, or both point one past\n  the last element of the same array\n  object, they compare equal. If the\n  objects pointed to are members of the\n  same aggregate object, pointers to\n  structure members declared later\n  compare greater than pointers to\n  members declared earlier in the\n  structure, and pointers to array\n  elements with larger subscript values\n  compare greater than pointers to\n  elements of the same array with lower\n  subscript values. All pointers to\n  members of the same union object\n  compare equal. If the expression P\n  points to an element of an array\n  object and the expression Q points to\n  the last element of the same array\n  object, the pointer expression Q+1\n  compares greater than P. <strong>In all other\n  cases, the behavior is undefined</strong>.</p>\n</blockquote>\n<p>So, I think comparing <code>char const*</code> which belong to two different '\\0'-terminated-string as in the question is an undefined behavior (in C).</p>\n", "LastEditorUserId": "547710", "LastActivityDate": "2011-01-05T19:30:55.910", "Score": "6", "CreationDate": "2011-01-05T19:20:42.903", "ParentId": "4607418", "CommentCount": "0", "OwnerUserId": "547710", "LastEditDate": "2011-01-05T19:30:55.910"}, "4607418": {"ViewCount": "5710", "Body": "<p>Just for fun, I had a <code>std::list</code> of <code>const char*</code>, each element pointing to a null-terminated text string, and ran a <code>std::list::sort()</code> on it. As it happens, it sort of (no pun intended) did not sort the strings. Considering that it was working on pointers, that makes sense.</p>\n<p>According to the <a href=\"http://www.cplusplus.com/reference/stl/list/sort/\" rel=\"nofollow noreferrer\">documentation</a> of <code>std::list::sort()</code>, it (by default) uses the <code>operator &lt;</code> between the elements to compare.</p>\n<p>Forgetting about the list for a moment, my actual question is: How do these (&gt;, &lt;, &gt;=, &lt;=) operators work on pointers in C++ and C? Do they simply compare the actual memory addresses?</p>\n<pre><code>char* p1 = (char*) 0xDAB0BC47;\nchar* p2 = (char*) 0xBABEC475;\n</code></pre>\n<p>e.g. on a 32-bit, little-endian system, <code>p1</code> &gt; <code>p2</code> because <code>0xDAB0BC47</code> &gt; <code>0xBABEC475</code>?</p>\n<p>Testing seems to confirm this, but I thought it'd be good to put it on StackOverflow for future reference. C and C++ both do some <a href=\"https://stackoverflow.com/questions/4111495/why-is-there-an-implicit-type-conversion-from-pointers-to-bool-in-c\">weird things</a> to pointers, so you never really know...</p>\n", "AcceptedAnswerId": "4607440", "Title": "How do the operators < and > work with pointers?", "CreationDate": "2011-01-05T17:53:10.590", "Id": "4607418", "CommentCount": "4", "LastEditDate": "2017-05-23T12:00:20.313", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2011-01-05T19:30:55.910", "Score": "8", "OwnerUserId": "1481860", "Tags": "<c++><c><pointers><comparison><operators>", "AnswerCount": "3"}});