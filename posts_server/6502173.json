post_cb({"6502393": {"Id": "6502393", "PostTypeId": "2", "Body": "<p>The conventional technique is using a program like bin2c, usually hastily written. Another method is using objcopy from GNU binutils:</p>\n<pre><code>$ objcopy -I binary extensions.cfg -O elf32-little -B i386 --rename-section .data=.rodata extensions.o\n$ objdump -x extensions.o\n\nextensions.o:     file format elf32-i386\nextensions.o\narchitecture: i386, flags 0x00000010:\nHAS_SYMS\nstart address 0x00000000\n\nSections:\nIdx Name          Size      VMA       LMA       File off  Algn\n  0 .rodata       00000447  00000000  00000000  00000034  2**0\n                  CONTENTS, ALLOC, LOAD, DATA\nSYMBOL TABLE:\n00000000 l    d  .rodata        00000000 .rodata\n00000000 g       .rodata        00000000 _binary_extensions_cfg_start\n00000447 g       .rodata        00000000 _binary_extensions_cfg_end\n00000447 g       *ABS*  00000000 _binary_extensions_cfg_size\n</code></pre>\n<p>The -O and -B flags have to match the objdump output for one of your compiled object files, to satisfy the linker, while the section renaming is just to inform the runtime linker this data is read-only. Note the symbols, mapping to start address, end address and data size. They each count as addresses, so in C you'd use them with something like:</p>\n<pre><code>extern const char _binary_extensions_cfg_start, _binary_extensions_cfg_end;\nextern const char _binary_extensions_cfg_size;\nfor (const char *p=&amp;_binary_extensions_cfg_start; p&lt;&amp;_binary_extensions_cfg_end; p++)\n    do_something(p);\nmemcpy(somewhere, &amp;_binary_extensions_cfg_start, (intptr_t)&amp;_binary_extensions_cfg_size);\n</code></pre>\n<p>I realize neither of these is the preprocessor thing you're asking for, but it simply wasn't designed to do that. Nevertheless, I would be interested to know if it can.</p>\n", "LastActivityDate": "2011-06-28T06:23:11.150", "CommentCount": "0", "CreationDate": "2011-06-28T06:23:11.150", "ParentId": "6502173", "Score": "1", "OwnerUserId": "379311"}, "6502494": {"Id": "6502494", "PostTypeId": "2", "Body": "<p>The most relevant part of the Standard is \u00a716.3/10:</p>\n<blockquote>\n<p id=\"so_6502173_6502494_0\">The sequence of preprocessing tokens bounded by the outside-most matching parentheses forms the list of arguments for the function-like macro. The individual arguments within the list are separated by comma preprocessing tokens, but comma preprocessing tokens between matching inner parentheses do not separate arguments. If (before argument substitution) any argument consists of no preprocessing tokens, the behavior is undefined. If there are sequences of preprocessing tokens within the list of arguments that would otherwise act as preprocessing directives, the behavior is undefined.</p>\n</blockquote>\n<p>Extracting the key points:</p>\n<ul>\n<li>You need to enclose the header files within a pair of parentheses so the macro doesn't think that every comma character in the file introduces another argument. These parentheses will also be stringized, but shouldn't be hard to work around.</li>\n<li>Putting <code>#include</code> in an argument list at all is officially undefined behavior, so this is going to be unportable. The compiler officially doesn't know whether you want the resulting string to be <code>\"#include \\\"kernels/util.cl\\\"\"</code>.</li>\n</ul>\n", "LastActivityDate": "2011-06-28T06:35:14.057", "CommentCount": "1", "CreationDate": "2011-06-28T06:35:14.057", "ParentId": "6502173", "Score": "4", "OwnerUserId": "153285"}, "bq_ids": {"n4140": {"so_6502173_6502494_0": {"length": 44, "quality": 0.8, "section_id": 521}}, "n3337": {"so_6502173_6502494_0": {"length": 44, "quality": 0.8, "section_id": 512}}, "n4659": {"so_6502173_6502494_0": {"length": 44, "quality": 0.8, "section_id": 542}}}, "6793185": {"Id": "6793185", "PostTypeId": "2", "Body": "<p>Here's what I do in xcode C:</p>\n<pre><code>const char oursource[60000];\nconst char * oursourceptr = oursource;\nconst char * * oursourceptrptr = &amp; oursourceptr;\n\n// in function \"readfileintostring\":\n\nchar *fylnm = \"/Developer/projs/myproj/mykernel.cl\";\n\nlong enby; short pathref;\n\nFSRef dink; FSPathMakeRef( (const UInt8 *) &amp;fylnm, &amp;dink, NULL );\nSInt16 forkRefNum;  HFSUniStr255 dataForkName;  FSGetDataForkName(&amp;dataForkName);\nFSOpenFork( &amp;dink, dataForkName.length, dataForkName.unicode, fsRdPerm, (FSIORefNum *) &amp;pathref );\n\nenby = 100000;  FSRead( pathref, &amp;enby, (void *) oursourceptr );\n\n// .. then later ..\n\nprogram = clCreateProgramWithSource(context, 1, (const char **) oursourceptrptr, NULL, &amp;err);\n</code></pre>\n<p>... it's not preprocessor voodoo, but it works for me, I can see syntax highlighted in my .cl file, and I can even copy my .cl over into a .c, change one #define, and it runs as xcode C....</p>\n", "LastActivityDate": "2011-07-22T16:37:24.477", "CommentCount": "1", "CreationDate": "2011-07-22T16:37:24.477", "ParentId": "6502173", "Score": "-2", "OwnerUserId": "744041"}, "6502173": {"ViewCount": "5532", "Body": "<p>Note: This question has nothing to do with OpenCL per se... check the last paragraph for a succinct statement of my question. But to provide some background:</p>\n<p>I'm writing some C++ code that makes use of OpenCL. I like to keep the source for my OpenCL kernels in their own files, to keep coding and maintenance easy (as opposed to embedding the sources directly as string constants in associated C++ code). This inevitably leads to the question of how to load them into the OpenCL runtime once it comes time to distribute binaries---ideally, the OpenCL source is included in the binary, so that the binary doesn't need to be in a specific place within some directory structure to know where the OpenCL source code is.</p>\n<p>I'd like to include the OpenCL files as string constants somewhere, and preferably without the use of additional build steps or external tools (for cross-compiler/cross-platform ease of use... i.e., no to <code>xxd</code> and the like). I thought I'd stumbled on a technique based on the second answer in <a href=\"https://stackoverflow.com/questions/1415538/using-include-to-load-opencl-code\">this</a> thread, like so:</p>\n<pre><code>#define STRINGIFY(src) #src\n\ninline const char* Kernels() {\n  static const char* kernels = STRINGIFY(\n    #include \"kernels/util.cl\"\n    #include \"kernels/basic.cl\"\n  );\n  return kernels;\n}\n</code></pre>\n<p>Note that I'd prefer not to embed the <code>STRINGIFY</code> macro in my OpenCL code if at all possible (as was done in the above referenced SO question). Now, this works wonderfully on the Clang/LLVM compiler, but GCC dies a horrible death (\"Unterminated argument list invoking macro STRINGIFY\" and various syntax \"errors\" related to the contents of the .cl files appear). So, clearly this exact technique isn't usable across compilers (haven't tried MSVC, but I'd like it to work there too)... How could I massage it minimally so that it works across compilers?</p>\n<p>In summary, I'd like a standards-compliant technique for including the contents of a file as a C/C++ string constant without invoking external tools or polluting the files with extraneous code. Ideas?</p>\n<p><strong>EDIT</strong>: As Potatoswatter pointed out, the behavior of the above is undefined, so a truly cross-compiler preprocessor technique that doesn't involve touching the files-to-be-stringified probably isn't possible (first person to figure out a heinous hack that <em>does</em> work for most/all compilers gets the answer points). For the curious, I ended up doing what was suggested in the second response <a href=\"https://stackoverflow.com/questions/1415538/using-include-to-load-opencl-code\">here</a>... that is, I added the <code>STRINGIFY</code> macro directly to the OpenCL files I was including:</p>\n<p>In <code>somefile.cl</code>:</p>\n<pre><code>STRINGIFY(\n  ... // Lots of OpenCL code\n)\n</code></pre>\n<p>In <code>somefile.cpp</code>:</p>\n<pre><code>#define STRINGIFY(src) #src\n\ninline const char* Kernels() {\n  static const char* kernels =\n    #include \"somefile.cl\"\n    ;\n  return kernels;\n}\n</code></pre>\n<p>This works in the compilers I've tried it in (Clang and GCC as well, since it doesn't have preprocessor directives inside the macro), and isn't too large a burden at least in my context (i.e., it doesn't interfere with syntax highlighting/editing the OpenCL files). One feature of preprocessor approaches like this one is that, since adjacent strings get concatenated, you can write</p>\n<pre><code>inline const char* Kernels() {\n  static const char* kernels =\n    #include \"utility_functions.cl\"\n    #include \"somefile.cl\"\n    ;\n  return kernels;\n}\n</code></pre>\n<p>and as long as the STRINGIFY macro is in both <code>.cl</code> files, the strings get concatenated, allowing you to modularize your OpenCL code.</p>\n", "AcceptedAnswerId": "6502494", "Title": "Preprocessor tomfoolery (stringifying a #include)", "CreationDate": "2011-06-28T05:54:36.737", "Id": "6502173", "CommentCount": "3", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:58:50.147", "LastEditorUserId": "-1", "LastActivityDate": "2016-06-22T08:29:51.640", "Score": "16", "OwnerUserId": "89451", "Tags": "<c++><include><opencl><c-preprocessor><stringification>", "AnswerCount": "4"}, "6502246": {"Id": "6502246", "PostTypeId": "2", "Body": "<p>You can't do it that way; I'm surprised it worked in clang. If you want to include text files directly in your binary, you have some options:</p>\n<p>1: A preprocess that runs before compilation that converts your .cl files into a .cpp file that defines the string.</p>\n<p>2: Storing the string data via compiler-specific storage in your compiled executable. This is how tools like Visual Studio include .rc, .ico, and other files that are used to build Windows applications. Of course, as stated, these are compiler-specific.</p>\n<p>The safest way is option 1.</p>\n", "LastActivityDate": "2011-06-28T06:03:18.983", "CommentCount": "1", "CreationDate": "2011-06-28T06:03:18.983", "ParentId": "6502173", "Score": "0", "OwnerUserId": "734069"}});