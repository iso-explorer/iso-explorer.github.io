post_cb({"28824330": {"CommentCount": "0", "ViewCount": "32", "OwnerDisplayName": "user2953119", "CreationDate": "2015-03-03T04:51:31.223", "LastActivityDate": "2015-03-03T05:36:29.377", "PostTypeId": "1", "AcceptedAnswerId": "28824795", "Title": "Linker error during calling instantiated function", "Id": "28824330", "Score": "2", "Body": "<p>The following code produces the linker error:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class T&gt;\nclass A\n{\npublic:\n    void foo(int);\n    template&lt;class V&gt; void foo(V v){ std::cout &lt;&lt; \"foo\" &lt;&lt; std::endl; }\n};\n\nA&lt;int&gt; a;\nint main(){ a.foo(3); } //Here is the error.\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/d25ba301cd563bf8\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>But the following code works fine:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class T&gt;\nclass A\n{\npublic:\n    template&lt;class V&gt; void foo(V v){ std::cout &lt;&lt; \"foo\" &lt;&lt; std::endl; }\n};\n\nA&lt;int&gt; a;\nint main(){ a.foo(3); } //OK, call to foo&lt;int&gt;\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/31479c8ea1034ce6\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>Why didn't the first example cause implicit instatiation of the member, but the second did.</p>\n", "Tags": "<c++><templates>", "AnswerCount": "2"}, "28824795": {"ParentId": "28824330", "CommentCount": "6", "Body": "<p>All other things being equal, non-template functions are preferred over function templates in overload resolution. In your first example, in <code>A&lt;int&gt;.foo(3);</code>, the candidates are the non-template <code>void foo(int)</code> and the template <code>template&lt;class V&gt; void foo(V)</code> with <code>V = int</code>. After substitution, the signatures are identical, and so the tiebreaker in [over.match.best]/p1.6 applies:</p>\n<blockquote>\n<p id=\"so_28824330_28824795_0\">a viable function <code>F1</code> is defined to be a better function than another\n  viable function <code>F2</code> if for all arguments <code>i</code>, <code>ICSi(F1)</code> is not a\n  worse conversion sequence than <code>ICSi(F2)</code>, and then</p>\n<ul>\n<li>[several inapplicable bullets omitted]</li>\n<li><code>F1</code> is not a function template specialization and <code>F2</code> is a function template specialization</li>\n<li>[inapplicable bullet omitted]</li>\n</ul>\n</blockquote>\n<p>Hence, <code>A&lt;int&gt;.foo(3);</code> unambiguously resolves to the non-template <code>foo()</code>, for which you didn't provide a definition, thus the linker error.</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "28824795", "Score": "2", "CreationDate": "2015-03-03T05:35:45.550", "LastActivityDate": "2015-03-03T05:35:45.550"}, "28824413": {"ParentId": "28824330", "CommentCount": "2", "Body": "<p>Well I think that in the first case, compiler does not know which foo function you want. foo(3) can match to both <code>void foo(int);</code> and <code>template&lt;class V&gt; void foo(V v)</code>. To correct this, in main just explicitly tell that you want the template version:</p>\n<pre><code> a.foo&lt;int&gt;(3); // or just  a.foo&lt;&gt;(3);\n</code></pre>\n<p>In the second case, you have only one foo function. So there is no problem.</p>\n", "OwnerUserId": "248823", "PostTypeId": "2", "Id": "28824413", "Score": "1", "CreationDate": "2015-03-03T04:58:47.917", "LastActivityDate": "2015-03-03T04:58:47.917"}, "bq_ids": {"n4140": {"so_28824330_28824795_0": {"section_id": 603, "quality": 0.8333333333333334, "length": 15}}, "n3337": {"so_28824330_28824795_0": {"section_id": 593, "quality": 0.8333333333333334, "length": 15}}, "n4659": {"so_28824330_28824795_0": {"section_id": 629, "quality": 0.8333333333333334, "length": 15}}}});