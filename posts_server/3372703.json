post_cb({"3375403": {"Id": "3375403", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_3372703_3375403_0\">Now will the code behave as expected or will we need to make ready volatile to get this to work?</p>\n</blockquote>\n<p>I would advise to use the <code>volatile</code> in the situation. Though in the case it seems it is not needed.</p>\n<p>IOW, Personally I would have added <code>volatile</code> and removed the locking: it is not needed for setting/reading the variable's value.</p>\n<blockquote>\n<p id=\"so_3372703_3375403_1\">Will different compilers and libraries handle this differently?\n  I am hoping that there might be something round the mutex functions that will prevent optimization around itself or that the compiler generally does not optimize round function calls.</p>\n</blockquote>\n<p>In your case the call to the function (pthread_mutex_lock()) has <em>side effects</em> and changes the <em>execution environment</em>. Thus compiler has to reread the global variable which might have being change by the call to the function.</p>\n<p>To be really sure, you want to consult with C99's <code>5.1.2.3 Program execution</code> where from I have borrowed the terminology. To give you the taste:</p>\n<blockquote>\n<p id=\"so_3372703_3375403_2\">[...] Accessing a volatile object, modifying an object, modifying a \ufb01le, or calling a function that does any of those operations are all <em>side effects</em>, which are changes in the state of the execution environment. Evaluation of an expression may produce side effects. At certain speci\ufb01ed points in the execution sequence called <em>sequence points</em>, all side effects of previous evaluations shall be complete and no side effects of subsequent evaluations shall have taken place. (A summary of the sequence points is given in annex C.)</p>\n<p id=\"so_3372703_3375403_3\">In the abstract machine, all expressions are evaluated as speci\ufb01ed by the semantics. An actual implementation need not evaluate part of an expression if it can deduce that its value is not used and that no needed side effects are produced (including any caused by calling a function or accessing a volatile object). [...]</p>\n</blockquote>\n<p>Excerpt from the annex C:</p>\n<blockquote>\n<p id=\"so_3372703_3375403_4\">The following are the sequence points described in 5.1.2.3:<br>\n  \u2014 The call to a function, after the arguments have been evaluated (6.5.2.2).</br></p>\n</blockquote>\n<p>And from there on.</p>\n<p>In my experience, compilers are sufficiently smart nowadays and even when optimizing aggressively wouldn't do anything fancy with loop control variable which is a global variable.</p>\n", "LastActivityDate": "2010-07-30T21:14:48.280", "CommentCount": "4", "CreationDate": "2010-07-30T21:14:48.280", "ParentId": "3372703", "Score": "0", "OwnerUserId": "360695"}, "3372739": {"Id": "3372739", "PostTypeId": "2", "Body": "<p>yes, <code>volatile int ready = 0;</code> is always needed here.</p>\n<p><strong>Update</strong><br>\nIf you would like no optimization around some code snippet, you can either use <code>#pragma</code> directives around that code (if your compiler supports them) or - which is totally portable - move the code to separate files and compile these files with no or little optimizations.<br>\nThe latter approach might still require usage of the <code>volatile</code> keyword, since the <code>ready</code> variable might be used by other modules which you might want to optimize.</br></br></p>\n", "LastEditorUserId": "362372", "LastActivityDate": "2010-07-30T15:32:42.433", "Score": "-1", "CreationDate": "2010-07-30T15:04:37.533", "ParentId": "3372703", "CommentCount": "2", "OwnerUserId": "362372", "LastEditDate": "2010-07-30T15:32:42.433"}, "3372767": {"Id": "3372767", "PostTypeId": "2", "Body": "<p>Volatile is needed here in the presence of optimization.  Otherwise the read of ready can be legally moved out of the while loop.</p>\n<p>Assuming limitations to optimization that are not promised by the standard may be fine now, but cause great grief to future maintainers as compilers improve.</p>\n", "LastEditorUserId": "22704", "LastActivityDate": "2010-07-30T15:17:44.917", "Score": "-1", "CreationDate": "2010-07-30T15:07:14.707", "ParentId": "3372703", "CommentCount": "1", "OwnerUserId": "22704", "LastEditDate": "2010-07-30T15:17:44.917"}, "bq_ids": {"n4140": {"so_3372703_3375403_3": {"length": 15, "quality": 0.5357142857142857, "section_id": 5797}}, "n3337": {"so_3372703_3375403_3": {"length": 15, "quality": 0.5357142857142857, "section_id": 5570}}, "n4659": {"so_3372703_3375403_3": {"length": 15, "quality": 0.5357142857142857, "section_id": 7256}}}, "3375471": {"Id": "3375471", "PostTypeId": "2", "Body": "<p>Some perspective from the kernel kings:</p>\n<p><a href=\"http://kernel.org/doc/Documentation/volatile-considered-harmful.txt\" rel=\"nofollow noreferrer\">http://kernel.org/doc/Documentation/volatile-considered-harmful.txt</a></p>\n", "LastActivityDate": "2010-07-30T21:26:06.067", "CommentCount": "0", "CreationDate": "2010-07-30T21:26:06.067", "ParentId": "3372703", "Score": "1", "OwnerUserId": "144213"}, "7250848": {"Id": "7250848", "PostTypeId": "2", "Body": "<p>Volatile is neither required nor sufficient. So there is no reason to use it. It is not sufficient because no standard specifies that it will provide visibility between threads. It is not necessary because the pthreads standard says mutexes are sufficient.</p>\n<p>Worse, using it suggests that you are an incompetent programmer who tries to sprinkle magic dust over your code to get it to work. It smacks of cargo cult programming and anyone looking at the code will infer that you didn't know it wasn't required. Worse, they may think that you felt it was sufficient, and they'll be suspicious of any other code you have written, fearing you used \"volatile\" to hide multi-threading bugs rather than fixing them.</p>\n", "LastActivityDate": "2011-08-30T23:12:56.373", "CommentCount": "2", "CreationDate": "2011-08-30T23:12:56.373", "ParentId": "3372703", "Score": "1", "OwnerUserId": "721269"}, "3372703": {"ViewCount": "1327", "Body": "<p>In the following code:</p>\n<pre><code>#include &lt;pthread.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;stdio.h&gt;\n\npthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;\nint ready = 0;\n\nwait()\n{\n    int i;\n    do\n    {\n        usleep(1000);\n        pthead_mutex_lock(&amp;mutex);\n        i = ready;\n        pthread_mutex_unlock(&amp;mutex);\n    } while (i == 0);   \n    printf(\"Finished\\n\");\n}\n\nsignal()\n{\n    pthead_mutex_lock(&amp;mutex);\n    ready = 1;\n    pthread_mutex_unlock(&amp;mutex);\n}\n</code></pre>\n<p>We spawn two threads we call wait in one thread and then call signal in the other We also get the compiler to optimize aggressively.</p>\n<p>Now will the code behave as expected or will we need to make ready volatile to get this to work? Will different compilers and libraries handle this differently?</p>\n<p><strong>Edit:</strong> I am hoping that there might be something round the mutex functions that will prevent optimization around itself or that the compiler generally does not optimize round function calls.</p>\n<p><strong>Note:</strong> I have not compiled and tested the code yet, will do so when I have a chance.</p>\n", "AcceptedAnswerId": "3375471", "Title": "volatile and multithreading?", "CreationDate": "2010-07-30T15:00:51.920", "Id": "3372703", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2010-07-31T12:42:33.000", "LastEditorUserId": "232918", "LastActivityDate": "2011-08-30T23:12:56.373", "Score": "2", "OwnerUserId": "232918", "Tags": "<c++><c><multithreading><pthreads>", "AnswerCount": "6"}, "3372760": {"Id": "3372760", "PostTypeId": "2", "Body": "<p>I'd be surprised if the compiler assumes anything about a global variable in the presence of library function calls. That being said, volatile will not cost you anything, and it shows your intentions. I'd put it there.</p>\n", "LastActivityDate": "2010-07-30T15:06:27.707", "CommentCount": "9", "CreationDate": "2010-07-30T15:06:27.707", "ParentId": "3372703", "Score": "2", "OwnerUserId": "3458"}});