post_cb({"16585719": {"ParentId": "16585033", "CommentCount": "2", "CreationDate": "2013-05-16T11:02:02.347", "OwnerUserId": "1322972", "PostTypeId": "2", "Id": "16585719", "Score": "3", "Body": "<p>You're fine if implemented as you present in your explanation. Without going into entire sections on abstract base classes and virtual functions, the standard dictates:</p>\n<blockquote>\n<p id=\"so_16585033_16585719_0\"><strong>C++ \u00a7 10.4p2</strong></p>\n<p id=\"so_16585033_16585719_1\">An abstract class is a class that can be used only as a base class of some other class; no objects of an abstract class can be created except as subobjects of a class derived from it. A class is abstract if it has at least one pure virtual function. [ Note: Such a function might be inherited: see below. \u2014 end note ] A virtual function is specified pure by using a pure-specifier (9.2) in the function declaration in the class definition. A pure virtual function need be defined only if called with, or as if with (12.4), the qualified-id syntax (5.1)</p>\n</blockquote>\n<p>The \"below\" referenced above leads to this note:</p>\n<blockquote>\n<p id=\"so_16585033_16585719_2\"><strong>C++11 \u00a7 10.4p5</strong></p>\n<p id=\"so_16585033_16585719_3\">[<em>Note:</em> An abstract class can be derived from a class that is not abstract, and a pure virtual function may override a virtual function which is not pure. - <em>end note</em>]</p>\n</blockquote>\n", "LastActivityDate": "2013-05-16T11:02:02.347"}, "16585773": {"ParentId": "16585033", "CommentCount": "2", "CreationDate": "2013-05-16T11:04:50.927", "OwnerUserId": "514235", "PostTypeId": "2", "Id": "16585773", "Score": "0", "Body": "<blockquote>\n<p id=\"so_16585033_16585773_0\">a non-pure virtual function is present in <code>ClassA</code> but not implemented;</p>\n</blockquote>\n<p>That results in <strong>linker error</strong>. When creating an objects of <code>ClassA</code> or its subclasses, all <code>virtual</code> methods must be implemented. Only for pure <code>virtual</code> methods the body of the method is optional.</p>\n<blockquote>\n<p id=\"so_16585033_16585773_1\">But to ensure that <code>ClassC</code> does in fact implement that function,\n  forcing the user of that class to do so, I make this function pure\n  <code>virtual</code> in <code>ClassB</code>.</p>\n</blockquote>\n<p>Yes, this way is correct. But, you should also evaluate that, is it worth having a new class just to make sure that few methods are implemented or not?<br>\nFor C++11, you can think of making smart use of <code>override</code> identifier as well.</br></p>\n<p>Also, you should not worry about the internal details of <code>vtable</code>, as they are implementation defined.</p>\n", "LastActivityDate": "2013-05-16T11:04:50.927"}, "bq_ids": {"n4140": {"so_16585033_16585719_1": {"section_id": 7019, "quality": 0.8679245283018868, "length": 46}, "so_16585033_16585719_3": {"section_id": 7022, "quality": 0.8235294117647058, "length": 14}}, "n3337": {"so_16585033_16585719_1": {"section_id": 6765, "quality": 0.8679245283018868, "length": 46}, "so_16585033_16585719_3": {"section_id": 6768, "quality": 0.8235294117647058, "length": 14}}, "n4659": {"so_16585033_16585719_1": {"section_id": 8516, "quality": 0.8679245283018868, "length": 46}, "so_16585033_16585719_3": {"section_id": 8519, "quality": 0.8235294117647058, "length": 14}}}, "16585033": {"CommentCount": "0", "ViewCount": "480", "PostTypeId": "1", "LastEditorUserId": "3758484", "CreationDate": "2013-05-16T10:30:02.153", "LastActivityDate": "2013-05-16T11:07:53.723", "Title": "Turning a non-pure virtual function into pure in a subclass", "AcceptedAnswerId": "16585719", "LastEditDate": "2013-05-16T11:07:53.723", "Id": "16585033", "Score": "4", "Body": "<p>So, I have this polymorphic hierarchy:</p>\n<pre><code>ClassA\nIs not abstract, no pure virtual functions, but a few virtual functions\n\nClassB:public ClassA\nDefines an extended interface for a certain type of subclass; \n is abstract with pure virtual functions\n\nClassC:public ClassB\nUsable class, no more subclassing\n</code></pre>\n<p>Here's the deal, I will have objects of <code>ClassA</code> and <code>ClassC</code> thrown together into containers and iterated through. To perform this iteration, a non-pure virtual function is present in <code>ClassA</code> but is empty with just <code>{}</code>; that is, it is empty, made available only if the iteration encounters a <code>ClassC</code> in which case it is invoked, otherwise it does nothing. I can't have it be pure otherwise I cannot have objects of <code>ClassA</code>.</p>\n<p>But to ensure that <code>ClassC</code> does in fact implement that function, forcing the user of that class to do so, I make this function pure virtual in <code>ClassB</code>.</p>\n<p>Is this acceptable? Nothing will \"break\" if I take a non-pure virtual function, make it pure, then make it non-pure again in <code>ClassC</code> ?</p>\n", "Tags": "<c++><polymorphism><virtual>", "OwnerUserId": "3758484", "AnswerCount": "2"}});