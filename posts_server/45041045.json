post_cb({"45052333": {"ParentId": "45041045", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Gathering from the hints throughout the countless helpful comments, here is my interpretation of what's happening.</p>\n<p>TLDR <strike>its well-formed</strike><sup>\u2021see edit</sup></p>\n<hr>\n<p>Quoting in the order I find more logical from <a href=\"http://eel.is/c++draft/basic.life\" rel=\"nofollow noreferrer\">[basic.life]</a><sup>\u2020</sup></p>\n<blockquote>\n<p id=\"so_45041045_45052333_0\">The properties ascribed to objects and references throughout this International Standard apply for a given object or reference only during its lifetime.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_45041045_45052333_1\">An object is said to have non-vacuous initialization if it is of a class or aggregate type and it or one of its subobjects is initialized by a constructor other than a trivial default constructor. [...] The lifetime of an object of type <code>T</code> begins when:  </p>\n<ul>\n<li><p id=\"so_45041045_45052333_2\">storage with the proper alignment and size for type <code>T</code> is obtained, and  </p></li>\n<li><p id=\"so_45041045_45052333_3\">if the object has non-vacuous initialization, its initialization is complete.  </p></li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_45041045_45052333_4\">The lifetime of an object o of type <code>T</code> ends when:  </p>\n<ul>\n<li><p id=\"so_45041045_45052333_5\">if T is a class type with a non-trivial destructor , the destructor call starts, or  </p></li>\n<li><p id=\"so_45041045_45052333_6\">the storage which the object occupies is released, or is reused by an object that is not nested within <code>o</code></p></li>\n</ul>\n</blockquote>\n<p>From <a href=\"http://eel.is/c++draft/basic.lval\" rel=\"nofollow noreferrer\">[basic.lval]</a><sup>\u2020</sup></p>\n<blockquote>\n<p id=\"so_45041045_45052333_7\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined  </p>\n<ul>\n<li><p id=\"so_45041045_45052333_8\">the dynamic type of the object,  </p></li>\n<li><p id=\"so_45041045_45052333_9\">a cv-qualified version of the dynamic type of the object,  </p></li>\n<li><p id=\"so_45041045_45052333_10\">a type similar to the dynamic type of the object,  </p></li>\n<li><p id=\"so_45041045_45052333_11\">a type that is the signed or unsigned type corresponding to the dynamic type of the object,  </p></li>\n<li><p id=\"so_45041045_45052333_12\">a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type of the object,  </p></li>\n<li><p id=\"so_45041045_45052333_13\">an aggregate or union type that includes one of the aforementioned types among its elements or non-static data members (including, recursively, an element or non-static data member of a subaggregate or contained union),  </p></li>\n<li><p id=\"so_45041045_45052333_14\">a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,  </p></li>\n<li><p id=\"so_45041045_45052333_15\">a <code>char</code>, <code>unsigned char</code>, or <code>std\u200b::\u200bbyte</code> type.</p></li>\n</ul>\n</blockquote>\n<p>We deduce that</p>\n<ol>\n<li><p>The lifetime of the <code>char</code>s in the <code>char[]</code> ends when another object reuses that space.</p></li>\n<li><p>The lifetime of an object of type <code>T</code> started when <code>push_back</code> is called.</p></li>\n<li><p>Since the address <code>((T*)data.get() + --sz)</code> is always that of an object with type <code>T</code> whose lifetime has started and not yet ended, it is valid to call <code>~T()</code> with it.</p></li>\n<li><p>During this process, the <code>char[]</code> and <code>char*</code> in <code>aligned_memory</code> aliases objects of type <code>T</code> but it is legal to do so. Also, no glvalue is obtained from them, so they could have been pointers of any type.</p></li>\n</ol>\n<p>To answer my own question in the comments whether using <em>any</em> memory as storage is also well-formed</p>\n<pre><code>U u;\nu-&gt;~U();\nnew (&amp;u) T;\n((T*)&amp;u)-&gt;~T();\nnew (&amp;u) U;\n</code></pre>\n<p>Following the 4 points above, the answer is <strike><strong>yes</strong></strike><sup>\u2021see edit</sup>, as long as the alignment of <code>U</code> is not weaker than <code>T</code>.</p>\n<p>\u2021 EDIT: I've neglected another paragraph of <a href=\"http://eel.is/c++draft/basic.life#8\" rel=\"nofollow noreferrer\">[basic.life]</a></p>\n<blockquote>\n<p id=\"so_45041045_45052333_16\">If, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, a new object is created at the storage location which the original object occupied, a pointer that pointed to the original object, a reference that referred to the original object, or the name of the original object will automatically refer to the new object and, once the lifetime of the new object has started, can be used to manipulate the new object, if:</p>\n<ul>\n<li><p id=\"so_45041045_45052333_17\">the storage for the new object exactly overlays the storage location which the original object occupied, and</p></li>\n<li><p id=\"so_45041045_45052333_18\">the new object is of the same type as the original object (ignoring the top-level cv-qualifiers), and</p></li>\n<li><p id=\"so_45041045_45052333_19\">the type of the original object is not const-qualified, and, if a class type, does not contain any non-static data member whose type is const-qualified or a reference type, and</p></li>\n<li><p id=\"so_45041045_45052333_20\">the original object was a most derived object of type <code>T</code> and the new object is a most derived object of type <code>T</code> (that is, they are not base class subobjects).</p></li>\n</ul>\n</blockquote>\n<p>Which means even though using the object is well-formed, the means which the object is obtained is not. Specifically, post C++17, <code>std::launder</code> has to be called</p>\n<pre><code>(std::launder((T*)data.get()) + --sz)-&gt;~T();\n</code></pre>\n<p>Prior C++17, a workaround would be to use the pointer acquired from the placement new instead</p>\n<pre><code>T* p = new (data.get() + sz++ * sizeof(T)) T(t);  // store p somewhere\n</code></pre>\n<p><sub> \u2020 Quoted from n4659, as far as I can see, same holds for n1905 </sub></p>\n</hr></hr></hr>", "OwnerUserId": "4832499", "LastEditorUserId": "4832499", "LastEditDate": "2017-08-02T11:48:22.067", "Id": "45052333", "Score": "2", "CreationDate": "2017-07-12T08:27:00.500", "LastActivityDate": "2017-08-02T11:48:22.067"}, "45124988": {"ParentId": "45041045", "CommentCount": "0", "Body": "<p>Placement-new creates an object at the specified location (C++14 expr.new/1), and ends the lifetime of any other object that was occupying the location (basic.life/1.4).</p>\n<p>The code <code>((T*)data.get() + --sz)-&gt;~T();</code> accesses an object of type <code>T</code> at the location where there is an object of type <code>T</code>. This is fine. It is irrelevant if there used to be a char array at the location.</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "45124988", "Score": "0", "CreationDate": "2017-07-16T04:29:20.923", "LastActivityDate": "2017-07-16T04:29:20.923"}, "45041045": {"CommentCount": "13", "AcceptedAnswerId": "45052333", "PostTypeId": "1", "LastEditorUserId": "4832499", "CreationDate": "2017-07-11T17:25:32.633", "LastActivityDate": "2017-08-02T11:48:22.067", "LastEditDate": "2017-07-11T17:47:42.233", "ViewCount": "97", "FavoriteCount": "0", "Title": "Is constructing objects in a char array well-formed", "Id": "45041045", "Score": "3", "Body": "<p>This is almost standard textbook use of placement new</p>\n<pre><code>template&lt;size_t Len, size_t Align&gt;\nclass aligned_memory\n{\npublic:\n    aligned_memory() : data((char*)(((std::uintptr_t)mem + Align - 1) &amp; -Align)) {}\n    char* get() const {return data;}\nprivate:\n    char mem[Len + Align - 1];\n    char* data;\n};\n\ntemplate&lt;typename T, size_t N&gt;\nclass Array\n{\npublic:\n    Array() : sz(0) {}\n    void push_back(const T&amp; t)\n    {\n        new (data.get() + sz++ * sizeof(T)) T(t);\n    }\n    void pop_back()\n    {\n        ((T*)data.get() + --sz)-&gt;~T();\n    }\n\nprivate:\n    aligned_memory&lt;N * sizeof(T), alignof(T)&gt; data;\n    size_t sz;\n};\n</code></pre>\n<p>Seems pretty fine, until we look into strict-aliasing, there seems to be some conflict in whether this is well-formed</p>\n<h3>Camp ill-formed</h3>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/37259909/cs-strict-aliasing-rule-is-the-char-aliasing-exemption-a-2-way-street\">C++'s Strict Aliasing Rule - Is the 'char' aliasing exemption a 2-way street?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/23848188/strict-aliasing-rule-and-char-pointers\">Strict aliasing rule and 'char *' pointers</a></li>\n</ul>\n<h3>Camp well-formed</h3>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/10965325/does-encapsulated-char-array-used-as-object-breaks-strict-aliasing-rule\">Does encapsulated char array used as object breaks strict aliasing rule</a></li>\n<li><a href=\"https://stackoverflow.com/questions/19217364/how-to-avoid-strict-aliasing-errors-when-using-aligned-storage\">How to avoid strict aliasing errors when using aligned_storage</a></li>\n</ul>\n<p>They all agree on <code>char*</code> may always reference another object, but some point out its ill-formed to do so the other way round.</p>\n<p>Clearly our <code>char[]</code> converts to <code>char*</code> then casted to <code>T*</code>, with which it is used to call its destructor.</p>\n<p>So, does the above program break the strict-aliasing rule? Specifically, where in the standard does it says it is well-formed or ill-formed?</p>\n<p>EDIT: as background info, this is written for C++0x, before the advent of <code>alignas</code> and <code>std::launder</code>. Not asking specifically for a C++0x solution, but it is preferred.</p>\n<p><code>alignof</code> is cheating, but its here for example purposes.</p>\n", "Tags": "<c++><language-lawyer><c++03>", "OwnerUserId": "4832499", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_45041045_45052333_10": {"section_id": 416, "quality": 1.0, "length": 5}, "so_45041045_45052333_9": {"section_id": 7239, "quality": 1.0, "length": 5}, "so_45041045_45052333_3": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}, "so_45041045_45052333_18": {"section_id": 7195, "quality": 1.0, "length": 9}, "so_45041045_45052333_5": {"section_id": 7189, "quality": 1.0, "length": 7}, "so_45041045_45052333_1": {"section_id": 7189, "quality": 0.875, "length": 21}, "so_45041045_45052333_0": {"section_id": 7191, "quality": 0.7333333333333333, "length": 11}, "so_45041045_45052333_12": {"section_id": 7239, "quality": 1.0, "length": 10}, "so_45041045_45052333_14": {"section_id": 7239, "quality": 1.0, "length": 9}, "so_45041045_45052333_17": {"section_id": 7195, "quality": 1.0, "length": 10}, "so_45041045_45052333_4": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}, "so_45041045_45052333_20": {"section_id": 7195, "quality": 1.0, "length": 17}, "so_45041045_45052333_11": {"section_id": 7239, "quality": 1.0, "length": 8}, "so_45041045_45052333_7": {"section_id": 7239, "quality": 1.0, "length": 14}, "so_45041045_45052333_2": {"section_id": 7189, "quality": 1.0, "length": 6}, "so_45041045_45052333_16": {"section_id": 7195, "quality": 1.0, "length": 43}, "so_45041045_45052333_15": {"section_id": 45, "quality": 0.8, "length": 4}, "so_45041045_45052333_13": {"section_id": 7239, "quality": 1.0, "length": 22}, "so_45041045_45052333_19": {"section_id": 7195, "quality": 1.0, "length": 16}}, "n3337": {"so_45041045_45052333_10": {"section_id": 407, "quality": 1.0, "length": 5}, "so_45041045_45052333_15": {"section_id": 42, "quality": 0.8, "length": 4}, "so_45041045_45052333_3": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}, "so_45041045_45052333_18": {"section_id": 6939, "quality": 1.0, "length": 9}, "so_45041045_45052333_5": {"section_id": 6933, "quality": 1.0, "length": 7}, "so_45041045_45052333_1": {"section_id": 6933, "quality": 0.875, "length": 21}, "so_45041045_45052333_0": {"section_id": 6935, "quality": 0.7333333333333333, "length": 11}, "so_45041045_45052333_12": {"section_id": 6983, "quality": 1.0, "length": 10}, "so_45041045_45052333_14": {"section_id": 6983, "quality": 1.0, "length": 9}, "so_45041045_45052333_17": {"section_id": 6939, "quality": 1.0, "length": 10}, "so_45041045_45052333_4": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}, "so_45041045_45052333_20": {"section_id": 6939, "quality": 1.0, "length": 17}, "so_45041045_45052333_11": {"section_id": 6983, "quality": 1.0, "length": 8}, "so_45041045_45052333_7": {"section_id": 6983, "quality": 1.0, "length": 14}, "so_45041045_45052333_2": {"section_id": 6933, "quality": 1.0, "length": 6}, "so_45041045_45052333_9": {"section_id": 6983, "quality": 1.0, "length": 5}, "so_45041045_45052333_16": {"section_id": 6939, "quality": 1.0, "length": 43}, "so_45041045_45052333_13": {"section_id": 6983, "quality": 1.0, "length": 22}, "so_45041045_45052333_19": {"section_id": 6939, "quality": 1.0, "length": 16}}, "n4659": {"so_45041045_45052333_1": {"section_id": 8697, "quality": 0.875, "length": 21}, "so_45041045_45052333_15": {"section_id": 7588, "quality": 1.0, "length": 5}, "so_45041045_45052333_5": {"section_id": 8697, "quality": 1.0, "length": 7}, "so_45041045_45052333_3": {"section_id": 8697, "quality": 1.0, "length": 6}, "so_45041045_45052333_7": {"section_id": 8748, "quality": 1.0, "length": 14}, "so_45041045_45052333_6": {"section_id": 8697, "quality": 1.0, "length": 8}, "so_45041045_45052333_10": {"section_id": 434, "quality": 1.0, "length": 5}, "so_45041045_45052333_0": {"section_id": 8700, "quality": 0.8666666666666667, "length": 13}, "so_45041045_45052333_12": {"section_id": 8748, "quality": 1.0, "length": 10}, "so_45041045_45052333_14": {"section_id": 8748, "quality": 1.0, "length": 9}, "so_45041045_45052333_17": {"section_id": 8704, "quality": 1.0, "length": 10}, "so_45041045_45052333_4": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}, "so_45041045_45052333_20": {"section_id": 8704, "quality": 1.0, "length": 17}, "so_45041045_45052333_11": {"section_id": 8748, "quality": 1.0, "length": 8}, "so_45041045_45052333_18": {"section_id": 8704, "quality": 1.0, "length": 9}, "so_45041045_45052333_2": {"section_id": 8697, "quality": 1.0, "length": 6}, "so_45041045_45052333_9": {"section_id": 8748, "quality": 1.0, "length": 5}, "so_45041045_45052333_16": {"section_id": 8704, "quality": 1.0, "length": 43}, "so_45041045_45052333_13": {"section_id": 8748, "quality": 1.0, "length": 22}, "so_45041045_45052333_19": {"section_id": 8704, "quality": 1.0, "length": 16}}}});