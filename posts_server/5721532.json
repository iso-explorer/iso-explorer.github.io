post_cb({"5721788": {"ParentId": "5721532", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The result of a new expression does not have to be at the same address passed to the placement new operator. And, you are not guaranteed that the size required to allocate an array is strictly the size of a single element times the number of elements.</p>\n<p>5.3.4: </p>\n<blockquote>\n<p id=\"so_5721532_5721788_0\">A <em>new-expression</em> passes the amount\n  of space requested to the allocation\n  function as the first argument of type\n  <code>std::size_t</code>. That argument shall be\n  no less than the size of the object\n  being created; <strong>it may be greater\n  than the size of the object being\n  created only if the object is an\n  array</strong>.</p>\n</blockquote>\n<p>So, the more correct version of your code would be: </p>\n<pre><code>     void *ppstorage= malloc(sizeof(vector&lt;int&gt;)*20);\n    pp= new (ppstorage) vector&lt;int&gt;[20];\n\n    for(int i = 0; i &lt; 20; ++i) \n        pp[i].~vector&lt;int&gt;();\n</code></pre>\n<p>Although you will almost certainly write past the end of <code>ppstorage</code>. The compiler has to store the count of the array somewhere to properly destruct each element, and for MSVC that is stored before the address returned by the new expression.</p>\n<p>In theory, you could overload <code>operator new[]</code> to get the actual allocation size of an array:</p>\n<pre><code>void *operator new[](size_t *allocation_size, size_t size)\n{\n    *allocation_size= size;\n    return nullptr;\n}\n</code></pre>\n<p>But I have never tried this.</p>\n", "OwnerUserId": "6210", "LastEditorUserId": "6210", "LastEditDate": "2011-04-19T20:38:14.427", "Id": "5721788", "Score": "1", "CreationDate": "2011-04-19T19:45:32.787", "LastActivityDate": "2011-04-19T20:38:14.427"}, "5732251": {"ParentId": "5721532", "CommentCount": "0", "Body": "<p>When you use <code>operator new[]</code> you must deallocate with <code>operator delete[]</code>. You cannot allocate with <code>new[]</code> and then deallocate one by one. So instead of your deallocation loop, you would do this:</p>\n<pre><code>delete [] pp;\n</code></pre>\n", "OwnerUserId": "691399", "PostTypeId": "2", "Id": "5732251", "Score": "0", "CreationDate": "2011-04-20T14:46:45.903", "LastActivityDate": "2011-04-20T14:46:45.903"}, "5721532": {"CommentCount": "11", "ViewCount": "245", "PostTypeId": "1", "LastEditorUserId": "503776", "CreationDate": "2011-04-19T19:21:07.733", "LastActivityDate": "2012-08-09T23:10:40.063", "Title": "Placement new strange behaviours", "AcceptedAnswerId": "5722017", "LastEditDate": "2012-08-09T23:10:40.063", "Id": "5721532", "Score": "1", "Body": "<p><strong>Do not ask me what I'm trying to do, this is just a quick test and its only purpose is to see if there is something wrong with placement new.</strong></p>\n<p>I've found an issue, or I just misunderstood something.</p>\n<pre><code>#include &lt;vector&gt;\n\nusing namespace std;\n\n#define WORKS \nint main(int argc, char** argv) {\n    vector&lt;int&gt;* pp = (vector&lt;int&gt;*)malloc(sizeof(vector&lt;int&gt;)*20);\n\n#ifdef WORKS\n    for(int i = 0; i &lt; 20; ++i)\n    new (pp+i) vector&lt;int&gt;;\n#else\n    new (pp) vector&lt;int&gt;[20];\n#endif\n\n    for(int i = 0; i &lt; 20; ++i) \n        pp[i].~vector&lt;int&gt;();\n\n}\n</code></pre>\n<p>when you remove the \"#define WORKS\" it will give you access violation, like </p>\n<pre><code>    for(int i = 0; i &lt; 20; ++i)\n    new (pp+i) vector&lt;int&gt;;\n</code></pre>\n<p>which works good, was different from</p>\n<pre><code>    new (pp) vector&lt;int&gt;[20];\n</code></pre>\n<p>which is the cause of throwing exceptions at the destruction stage. What's going on here?\nI'm working on Windows XP and building with VC++ Express 2010.</p>\n", "Tags": "<c++><placement-new>", "OwnerUserId": "503776", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_5721532_5722017_0": {"section_id": 6095, "quality": 1.0, "length": 5}, "so_5721532_5721788_0": {"section_id": 6092, "quality": 0.9285714285714286, "length": 26}, "so_5721532_5722017_2": {"section_id": 6095, "quality": 0.9148936170212766, "length": 43}}, "n3337": {"so_5721532_5722017_0": {"section_id": 5861, "quality": 1.0, "length": 5}, "so_5721532_5721788_0": {"section_id": 5859, "quality": 0.9285714285714286, "length": 26}, "so_5721532_5722017_2": {"section_id": 5861, "quality": 0.9148936170212766, "length": 43}}, "n4659": {"so_5721532_5721788_0": {"section_id": 7588, "quality": 0.9642857142857143, "length": 27}, "so_5721532_5722017_2": {"section_id": 7592, "quality": 0.8936170212765957, "length": 42}}}, "5722017": {"ParentId": "5721532", "CommentCount": "0", "Body": "<p>\u00a75.3.4/12: </p>\n<blockquote>\n<p id=\"so_5721532_5722017_0\">-- <code>new T[5]</code> results in a call of <code>operator new[](sizeof(T)*5+x)</code></p>\n<p id=\"so_5721532_5722017_1\">[ ... ]</p>\n<p id=\"so_5721532_5722017_2\">Here, x and y are non-negative unspecified values representing array allocation overhead; the result of the new-expression will be offset by this amount from the value returned by operator new[]. This overhead may be applied in <strong>all</strong> array new-expressions, <strong>including</strong> those referencing the library function operator new[](std::size_t, void*) and other placement allocation functions. The amount of overhead may vary from one invocation of new to another. [ emphasis added ] </p>\n</blockquote>\n<p>To summarize, trying to place the array may require some unspecified amount of overhead that you're not allocating. As long as you place the elements individually, no such overhead is allowed, so the placement new works.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "5722017", "Score": "10", "CreationDate": "2011-04-19T20:05:16.857", "LastActivityDate": "2011-04-19T20:05:16.857"}});