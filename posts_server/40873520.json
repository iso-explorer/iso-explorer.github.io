post_cb({"40873999": {"ParentId": "40873520", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2016-11-29T19:15:17.820", "Score": "3", "LastEditorUserId": "179910", "LastEditDate": "2016-11-29T21:42:01.287", "Id": "40873999", "OwnerUserId": "179910", "Body": "<p>This analysis is based on n4567, and uses section numbers from it.</p>\n<p>\u00a75.2.10/7: When a prvalue <code>v</code> of object pointer type is converted to the object pointer type \u201cpointer to <em>cv</em> T\u201d, the result is <code>static_cast&lt;cv T*&gt;(static_cast&lt;cv void*&gt;(v))</code>.</p>\n<p>So, in this case, the <code>reinterpret_cast&lt;X*&gt;(buffer)</code> is the same as <code>static_cast&lt;X *&gt;(static_cast&lt;void *&gt;(buffer))</code>. That leads us to look at the relevant parts about <code>static_cast</code>:</p>\n<p>\u00a75.2.9/13: A prvalue of type \u201cpointer to <em>cv1</em> void\u201d can be converted to a prvalue of type \u201cpointer to <em>cv2</em> T\u201d, where T is an object type and <em>cv2</em> is the same cv-qualification as, or greater cv-qualification than, <em>cv1</em>. The null pointer value is converted to the null pointer value of the destination type. If the original pointer value represents the address <code>A</code> of a byte in memory and <code>A</code> satisfies the alignment requirement of <code>T</code>, then the resulting pointer value represents the same address as the original pointer value, that is, <code>A</code>.</p>\n<p>I believe that's enough to say that the original quote is sort of correct--this conversion gives defined results.</p>\n<p>As to lifetime, it depends on what lifetime you're talking about. The cast creates a new object of pointer type--a temporary, which has a lifetime starting from the line where the cast is located, and ending whenever it goes out of scope. If you have two different conversions that happen conditionally, each pointer has a lifetime that starts from the location of the cast that created it.</p>\n<p>Neither of these affects the lifetime of the object providing the underlying storage, which is still <code>buffer</code>, and has exactly the same lifetime, regardless of whether you create a pointer (of the same or converted type) to that storage or not.</p>\n", "LastActivityDate": "2016-11-29T21:42:01.287"}, "40873520": {"CommentCount": "12", "AcceptedAnswerId": "40874245", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2016-11-29T18:48:51.877", "LastActivityDate": "2017-01-20T01:04:48.543", "LastEditDate": "2016-11-29T21:18:15.577", "ViewCount": "1215", "FavoriteCount": "11", "Title": "reinterpret_cast creating a trivially default-constructible object", "Id": "40873520", "Score": "44", "Body": "<p><a href=\"http://en.cppreference.com/mwiki/index.php?title=cpp/language/default_constructor&amp;oldid=86081#Trivial_default_constructor\" rel=\"noreferrer\">cppreference</a><sup>\u2020</sup> states that:</p>\n<blockquote>\n<p id=\"so_40873520_40873520_0\">Objects with trivial default constructors can be created by using <code>reinterpret_cast</code> on any suitably aligned storage, e.g. on memory allocated with <code>std::malloc</code>.</p>\n</blockquote>\n<p>This implies that the following is well-defined code:</p>\n<pre><code>struct X { int x; };\nalignas(X) char buffer[sizeof(X)];    // (A)\nreinterpret_cast&lt;X*&gt;(buffer)-&gt;x = 42; // (B)\n</code></pre>\n<p>Three questions follow:</p>\n<ol>\n<li>Is that quote correct? </li>\n<li>If yes, at what point does the lifetime of the <code>X</code> begin? If on line <code>(B)</code>, is it the cast itself that is considered acquiring storage? If on line <code>(A)</code>, what if there were a branch between <code>(A)</code> and <code>(B)</code> that would conditionally construct an <code>X</code> or some other pod, <code>Y</code>?</li>\n<li>Does anything change between C++11 and C++1z in this regard?</li>\n</ol>\n<hr/>\n<p><sup>\u2020</sup>Note that this is an old link. The wording was changed in response to this question. It now reads:</p>\n<blockquote>\n<p id=\"so_40873520_40873520_1\">Unlike in C, however, objects with trivial default constructors cannot be created by simply reinterpreting suitably aligned storage, such as memory allocated with <code>std::malloc</code>: placement-new is required to formally introduce a new object and avoid potential undefined behavior.</p>\n</blockquote>\n", "Tags": "<c++><c++11><language-lawyer><c++1z>", "OwnerUserId": "2069064", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_40873520_40874245_1": {"section_id": 5795, "quality": 1.0, "length": 25}}, "n3337": {"so_40873520_40874245_1": {"section_id": 5568, "quality": 1.0, "length": 25}}, "n4659": {"so_40873520_40874245_0": {"section_id": 7247, "quality": 0.6842105263157895, "length": 13}, "so_40873520_40874245_1": {"section_id": 7254, "quality": 0.96, "length": 24}}}, "40874245": {"ParentId": "40873520", "PostTypeId": "2", "CommentCount": "28", "CreationDate": "2016-11-29T19:29:40.890", "Score": "24", "LastEditorUserId": "2756719", "LastEditDate": "2016-11-30T23:54:24.673", "Id": "40874245", "OwnerUserId": "2756719", "Body": "<p>There is no <code>X</code> object, living or otherwise, so pretending that there is one results in undefined behavior.</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/intro.object#1\" rel=\"noreferrer\">[intro.object]/1</a> spells out exhaustively when objects are created:</p>\n<blockquote>\n<p id=\"so_40873520_40874245_0\">An <em>object</em> is created by a definition ([basic.def]), by a\n  <em>new-expression</em> ([expr.new]), when implicitly changing the active\n  member of a union ([class.union]), or when a temporary object is\n  created ([conv.rval], [class.temporary]).</p>\n</blockquote>\n<p>With the adoption of <a href=\"http://wg21.link/p0137\" rel=\"noreferrer\">P0137R1</a>, this paragraph is the definition of the term \"object\".</p>\n<p>Is there a definition of an <code>X</code> object? No. Is there a <em>new-expression</em>? No. Is there a union? No. Is there a language construct in your code that creates a temporary <code>X</code> object? No.</p>\n<p>Whatever [basic.life] says about the lifetime of an object with vacuous initialization is irrelevant. For that to apply, you have to have an object in the first place. You don't.</p>\n<p>C++11 has roughly the same paragraph, but doesn't use it as the definition of \"object\". Nonetheless, the interpretation is the same. The alternative interpretation - treating [basic.life] as creating an object as soon as suitable storage is obtained - means that you are creating Schr\u00f6dinger's objects<sup>*</sup>, which contradicts <a href=\"https://timsong-cpp.github.io/cppwp/n3337/intro.object#6\" rel=\"noreferrer\">N3337 [intro.object]/6</a>:</p>\n<blockquote>\n<p id=\"so_40873520_40874245_1\">Two objects that are not bit-fields may have the same address if one\n  is a subobject of the other, or if at least one is a base class\n  subobject of zero size and they are of different types; otherwise,\n  they shall have distinct addresses.</p>\n</blockquote>\n<hr>\n<p><sub><sup>*</sup> Storage with the proper alignment and size for a type <code>T</code> is by definition storage with the proper alignment and size for <em>every other type</em> whose size and alignment requirements are equal to or less than those of <code>T</code>. Thus, that interpretation means that obtaining the storage simultaneously creates an infinite set of objects with different types in said storage, all having the same address. </sub></p>\n</hr>", "LastActivityDate": "2016-11-30T23:54:24.673"}});