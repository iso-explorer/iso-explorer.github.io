post_cb({"25717678": {"Id": "25717678", "PostTypeId": "2", "Body": "<p>According to N3936, \u00a73.7.4.1/1:</p>\n<blockquote>\n<p id=\"so_25717639_25717678_0\">An allocation function shall be a class member function or a global function; a program is ill-formed if an\n  allocation function is declared in a namespace scope other than global scope or declared static in global\n  scope. The return type shall be <code>void*</code>.</p>\n</blockquote>\n<p>This makes sense, since <code>::operator new</code> doesn't know what type it's being used to allocate; it only knows the size. So it has to return <code>void*</code> because what else could it return?</p>\n<p>In C++ (unlike in C), there is no implicit conversion from <code>void*</code> to pointer to object. That's why <code>malloc</code> doesn't need a cast in C, but <code>malloc</code> and <code>operator new</code> need a cast in C++.</p>\n<p>In this particular case the cast is actually a <code>static_cast</code> since the conversion from <code>void*</code> to pointer to object is the reverse of a standard conversion. Prefer <code>static_cast</code> over the C-style cast as it is more explicit.</p>\n", "LastActivityDate": "2014-09-08T04:56:37.820", "CommentCount": "0", "CreationDate": "2014-09-08T04:56:37.820", "ParentId": "25717639", "Score": "6", "OwnerUserId": "481267"}, "25717639": {"ViewCount": "200", "Body": "<p>So this statement allocates memory but does not call MyClass's constructur </p>\n<pre><code>  MyClass *ptr = (MyClass*)::operator new (sizeof(MyClass));\n</code></pre>\n<p>Why does <code>(MyClass*)</code> have to be cast, or is that not what's going on here?</p>\n", "AcceptedAnswerId": "25717688", "Title": "why does operator new function need cast", "CreationDate": "2014-09-08T04:51:16.933", "Id": "25717639", "CommentCount": "2", "LastEditDate": "2014-09-08T04:56:06.937", "PostTypeId": "1", "LastEditorUserId": "559085", "LastActivityDate": "2014-09-08T04:58:13.257", "Score": "0", "OwnerUserId": "1724401", "Tags": "<c++><new-operator>", "AnswerCount": "3"}, "25717676": {"Id": "25717676", "PostTypeId": "2", "Body": "<p>The function <code>::operator new()</code> has return type <code>void *</code>.</p>\n<p>In C++ there is no implicit conversion from <code>void *</code> to other pointer types, a cast is required.  It is similar to trying to use <code>malloc</code> in C++.</p>\n<p>In fact, a reasonable implementation for <code>::operator new</code> would just be <code>return malloc(sz);</code></p>\n", "LastActivityDate": "2014-09-08T04:56:14.340", "CommentCount": "0", "CreationDate": "2014-09-08T04:56:14.340", "ParentId": "25717639", "Score": "5", "OwnerUserId": "1505939"}, "bq_ids": {"n4140": {"so_25717639_25717678_0": {"length": 24, "quality": 0.96, "section_id": 7176}}, "n3337": {"so_25717639_25717678_0": {"length": 24, "quality": 0.96, "section_id": 6920}}, "n4659": {"so_25717639_25717678_0": {"length": 24, "quality": 0.96, "section_id": 8684}}}, "25717688": {"Id": "25717688", "PostTypeId": "2", "Body": "<p>What Matt McNabb and Brian Bi said, but also, this is For Your Own Good\u2122. You shouldn't cast the pointer, but should keep it as <code>void*</code>. That way, you won't accidentally use it as the target type without constructing it first (by using a placement <code>new</code>). e.g.,</p>\n<pre><code>void* p = ::operator new(sizeof (MyClass));\nMyClass* pmc = new (p) MyClass;\n</code></pre>\n", "LastActivityDate": "2014-09-08T04:58:13.257", "CommentCount": "1", "CreationDate": "2014-09-08T04:58:13.257", "ParentId": "25717639", "Score": "8", "OwnerUserId": "13"}});