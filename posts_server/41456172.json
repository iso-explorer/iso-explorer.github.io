post_cb({"41456172": {"ViewCount": "104", "Body": "<p>Updated below: In clang, using an lvalue of a polymorphic object through its name does not activate virtual dispatch, but it does through its address.</p>\n<p>For the following base class <code>B</code> and derived <code>D</code>, virtual function <code>something</code>, union <code>Space</code></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct B {\n    void *address() { return this; }\n    virtual ~B() { cout &lt;&lt; \"~B at \" &lt;&lt; address() &lt;&lt; endl; }\n    virtual void something() { cout &lt;&lt; \"B::something\"; }\n};\n\nstruct D: B {\n    ~D() { cout &lt;&lt; \"~D at \" &lt;&lt; address() &lt;&lt; endl; }\n     void something() override { cout &lt;&lt; \"D::something\"; }\n};\n\nunion Space {\n    B b;\n    Space(): b() {}\n    ~Space() { b.~B(); }\n};\n</code></pre>\n<p>If you have a value <code>s</code> of <code>Space</code>, in Clang++: (<em>update: incorrectly claimed g++ had the same behavior</em>)\nIf you do <code>s.b.something()</code>, <code>B::something()</code> will be called, not doing the <em>dynamic binding</em> on s.b, however, if you call <code>(&amp;s.b)-&gt;something()</code> will do the dynamic binding to what <code>b</code> really contains (either a <code>B</code> or <code>D</code>).\nThe completion code is this:</p>\n<pre><code>union SpaceV2 {\n    B b;\n    SpaceV2(): b() {}\n    ~SpaceV2() { (&amp;b)-&gt;~B(); }\n};\n\nstatic_assert(sizeof(D) == sizeof(B), \"\");\nstatic_assert(alignof(D) == alignof(B), \"\");\n\n#include &lt;new&gt;\n\nint main(int argc, const char *argv[]) {\n    {\n        Space s;\n        cout &lt;&lt; \"Destroying the old B: \";\n        s.b.~B();\n        new(&amp;s.b) D;\n        cout &lt;&lt; \"\\\"D::something\\\" expected, but \\\"\";\n        s.b.something();\n        cout &lt;&lt; \"\\\" happened\\n\";\n        auto &amp;br = s.b;\n        cout &lt;&lt; \"\\\"D::something\\\" expected, and \\\"\";\n        br.something();\n        cout &lt;&lt; \"\\\" happened\\n\";\n        cout &lt;&lt; \"Destruction of D expected:\\n\";\n    }\n    cout &lt;&lt; \"But did not happen!\\n\";\n    SpaceV2 sv2;\n    new(&amp;sv2.b) D;\n    cout &lt;&lt; \"Destruction of D expected again:\\n\";\n    return 0;    \n}\n</code></pre>\n<p>When compile with -O2 optimization and I run the program, this is the output:</p>\n<pre><code>$./a.out \nDestroying the old B: ~B at 0x7fff4f890628\n\"D::something\" expected, but \"B::something\" happened\n\"D::something\" expected, and \"D::something\" happened\nDestruction of D expected:\n~B at 0x7fff4f890628\nBut did not happen!\nDestruction of D expected again:\n~D at 0x7fff4f890608\n~B at 0x7fff4f890608\n</code></pre>\n<p>What surprises me is that setting the dynamic type of <code>s.b</code> using placement new leads to a difference calling <code>something</code> on the very same l-value through its name or through its address.  The first question is essential, but I have not been able to find an answer:</p>\n<ol>\n<li>Is doing <em>placement new</em> to a derived class, like <code>new(&amp;s.b) D</code> <strong>undefined behavior</strong> according to the C++ standard?</li>\n<li>If it is not undefined behavior, is this choice of not activating virtual dispatch through the l-value of the named member something specified in the standard or a choice in G++, Clang?</li>\n</ol>\n<p>Thanks, my first question in S.O. ever.</p>\n<p><strong>UPDATE</strong>\nThe answer and the comment that refers to the standard are accurate: According to the standard, <code>s.b</code> will forever refer to an object of exact type <code>B</code>, the <em>memory</em> is allowed to change type, but then any use of that memory through <code>s.b</code> is \"undefined behavior\", that is, prohibited, or that the compiler can translate however it pleases.  If <code>Space</code> was just a buffer of chars, it would be valid to in-place construct, destruct, change the type.  Did exactly that in the code that led to this question and it works with standards-compliance AFAIK.\nThanks.</p>\n", "AcceptedAnswerId": "41457116", "Title": "Difference calling virtual through named member versus address or reference", "CreationDate": "2017-01-04T04:21:55.140", "Id": "41456172", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-01-05T04:09:02.053", "LastEditorUserId": "4988044", "LastActivityDate": "2017-01-05T04:09:02.053", "Score": "4", "OwnerUserId": "4988044", "Tags": "<c++><c++11><undefined-behavior><standards-compliance><dynamic-binding>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_41456172_41457116_0": {"length": 43, "quality": 1.0, "section_id": 7195}, "so_41456172_41457116_1": {"length": 10, "quality": 1.0, "section_id": 7195}, "so_41456172_41457116_2": {"length": 9, "quality": 1.0, "section_id": 7195}}, "n3337": {"so_41456172_41457116_0": {"length": 43, "quality": 1.0, "section_id": 6939}, "so_41456172_41457116_1": {"length": 10, "quality": 1.0, "section_id": 6939}, "so_41456172_41457116_2": {"length": 9, "quality": 1.0, "section_id": 6939}}, "n4659": {"so_41456172_41457116_0": {"length": 43, "quality": 1.0, "section_id": 8704}, "so_41456172_41457116_1": {"length": 10, "quality": 1.0, "section_id": 8704}, "so_41456172_41457116_2": {"length": 9, "quality": 1.0, "section_id": 8704}}}, "41457116": {"Id": "41457116", "PostTypeId": "2", "Body": "<p>The expression <code>new(&amp;s.b) D;</code> re-uses the storage named <code>s.b</code> and formerly occupied by a <code>B</code> for for storage of a new <code>D</code>.</p>\n<p>However you then write <code>s.b.something();</code> . This causes undefined behaviour because <code>s.b</code> denotes a <code>B</code> but the actual object stored in that location is a <code>D</code>. See C++14 [basic.life]/7:</p>\n<blockquote>\n<p id=\"so_41456172_41457116_0\">If, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, a new object is created at the storage location which the original object occupied, a pointer that pointed to the original object, a reference that referred to the original object, or the name of the original object will automatically refer to the new object and, once the lifetime of the new object has started, can be used to manipulate the new object, if:</p>\n<ul>\n<li><p id=\"so_41456172_41457116_1\">the storage for the new object exactly overlays the storage location which the original object occupied, and</p></li>\n<li><p id=\"so_41456172_41457116_2\">the new object is of the same type as the original object (ignoring the top-level cv-qualifiers), and</p>\n<p id=\"so_41456172_41457116_3\">[...]</p></li>\n</ul>\n</blockquote>\n<p>The last bullet point is not satisfied because the new type differs. </p>\n<p>(There are other potential issues later in the code too but since undefined behaviour is caused here, they're moot; you'd need to have a major design change to avoid this problem).</p>\n", "LastActivityDate": "2017-01-04T05:59:49.280", "CommentCount": "2", "CreationDate": "2017-01-04T05:59:49.280", "ParentId": "41456172", "Score": "2", "OwnerUserId": "1505939"}});