post_cb({"5303368": {"ParentId": "5303324", "CommentCount": "0", "Body": "<p>It is not possible in C++03 to provide such a thing without manually overloading for every combination of const and non-const parameters.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "5303368", "Score": "1", "CreationDate": "2011-03-14T19:22:13.457", "LastActivityDate": "2011-03-14T19:22:13.457"}, "5305219": {"ParentId": "5303324", "CommentCount": "0", "Body": "<p>No expression ever has reference type. Therefor, when argument deduction deduces against the argument expression type, it cannot make a distinction between <code>a</code> and <code>b</code> because the arguments <code>a</code> and <code>b</code> both have the same type. </p>\n<p>Refer to [expr]p5 in the spec</p>\n<blockquote>\n<p id=\"so_5303324_5305219_0\">If an expression initially has the type \"reference to T\" (8.3.2, 8.5.3), the type is adjusted to T prior to any further analysis. </p>\n</blockquote>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "5305219", "Score": "1", "CreationDate": "2011-03-14T22:12:21.967", "LastActivityDate": "2011-03-14T22:12:21.967"}, "5303324": {"CommentCount": "1", "ViewCount": "1117", "CreationDate": "2011-03-14T19:18:06.020", "LastActivityDate": "2011-06-16T23:24:46.693", "Title": "Type deduction of function template parameters", "PostTypeId": "1", "Id": "5303324", "Score": "2", "Body": "<p>I have some questions concerning function templates. </p>\n<p>My plan was to build a wrapper which derives from a user-defined class and \nnot only exports the public functions of that class but also its constructors.\nSo I decided I would use multiple constructor templates (which I presume work exactly \nthe same as function templates) with 1 to n parameters to satisfy most constructors needs. </p>\n<p>These would than simply call the constructor and do something else afterwards, like \nthis:</p>\n<pre><code>template &lt;class T&gt;\nclass Wrapper : public T\n{\n    public:\n        template &lt;class U&gt;\n        Wrapper(U &amp;u) : T(u) { doSomething(); }\n\n        template &lt;class U, class V&gt;\n        Wrapper(U &amp;u, V &amp;v) : T(u,v) { doSomething(); }\n\n        ...\n};\n</code></pre>\n<p>My intent is to register the instance within the Wrapper-Ctor somewhere else and, \nfrom that point on, it can receive calls to virtual functions defined in T.</p>\n<p>I had to use the reference operator in the code above, in order to guarantee that\nmy Wrapper-Ctor does not have any side-effects on the parameters that were passed \n(copy-construction).</p>\n<p>To my surprise this always worked, except for temporaries, which is the reason why\nI am confused about the types that are inferred by the compiler in this situation. \nTo simplify the situation I tried to do something similiar via a template function:</p>\n<pre><code>template &lt;class T&gt;\nvoid foo(T &amp;t)\n{\n    int x = \"\"; // intentional error\n}\n</code></pre>\n<p>Calling the function like this:</p>\n<pre><code>std::string a; \nstd::string &amp;b = a;\nfoo(b);\n</code></pre>\n<p>To my surprise the compiler denotes [T = std::string] in its error message.\nI would have expected for this to be [T = std::string&amp;], which would have caused\npassing a reference-to-reference, which is invalid. </p>\n<p>So, why does the compiler deduce a value-type in this situation? \nIs it even possible to create a Wrapper-Ctor that does what I want, does not \nhave any side-effects on the parameters and also accepts temporaries?</p>\n<p>Thanks alot!</p>\n", "Tags": "<c++><templates><function><types><inference>", "OwnerUserId": "659403", "AnswerCount": "4"}, "5303391": {"ParentId": "5303324", "CommentCount": "0", "Body": "<p>It looks like the C++ spec explicitly states that this is the intended behavior.  Specifically, if you have a template function that takes in a parameter <code>P</code> that depends on a template type argument, if <code>P</code> is a reference, then the underlying type of the reference, rather than the reference type, is used to determine what type should be used for <code>P</code> (see \u00a714.8.2.1/2).  Moreover, this same section says that <code>const</code> and <code>volatile</code> qualifiers are ignored during this step, so the <code>const</code>ness can be inferred automatically.</p>\n", "OwnerUserId": "501557", "PostTypeId": "2", "Id": "5303391", "Score": "2", "CreationDate": "2011-03-14T19:23:30.973", "LastActivityDate": "2011-03-14T19:23:30.973"}, "6379776": {"ParentId": "5303324", "CommentCount": "0", "Body": "<p>Somewhat late, but since I don't think this was answered completely... </p>\n<p>For template parameter deduction, see the previous answers.</p>\n<p>For your problem with temporaries, make the parameters const references (as in Wrapper(const U&amp;)). </p>\n<p>The thing is, temporaries are rvalues. The standard states that non-const references can only be bound to lvalues. Therefore, a standards compliant compiler won't let you pass temporaries(rvalues) as arguments to non-const reference parameters. (This doesn't have anything to do with templates in particular, it's a general rule).</p>\n<p>This is to the best of my knowledge, so take it with a bit of scepticism.</p>\n", "OwnerUserId": "802441", "PostTypeId": "2", "Id": "6379776", "Score": "1", "CreationDate": "2011-06-16T23:24:46.693", "LastActivityDate": "2011-06-16T23:24:46.693"}, "bq_ids": {"n4140": {"so_5303324_5305219_0": {"section_id": 5938, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_5303324_5305219_0": {"section_id": 5710, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_5303324_5305219_0": {"section_id": 7422, "quality": 0.8181818181818182, "length": 9}}}});