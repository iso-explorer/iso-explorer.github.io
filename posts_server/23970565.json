post_cb({"23970565": {"CommentCount": "3", "AcceptedAnswerId": "23970566", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-05-31T13:23:24.570", "LastActivityDate": "2014-06-01T06:14:29.903", "LastEditDate": "2017-05-23T11:51:09.327", "ViewCount": "172", "FavoriteCount": "2", "Title": "Extending temporary's lifetime, works with block-scoped aggregate, but not through `new`; why?", "Id": "23970565", "Score": "10", "Body": "<p><sub><strong>Note</strong>: This question was originally asked as <a href=\"https://stackoverflow.com/questions/23892018/extending-temporarys-lifetime-through-rvalue-data-member-works-with-aggregate/23965233#comment36922467_23965233\">a comment</a> by <a href=\"https://stackoverflow.com/users/1013719/ryan-haining\">\nRyan Haining</a> on <a href=\"https://stackoverflow.com/a/23965233/1090079\">this answer</a>.</sub></p>\n<hr>\n<pre><code>struct A { std::string const&amp; ref; };\n</code></pre>\n<p><sup></sup></p>\n<pre><code>// (1)\n\nA a { \"hello world\" };              // temporary's lifetime is extended to that of `a`\nstd::cout &lt;&lt; a.ref &lt;&lt; std::endl;    // safe\n</code></pre>\n<p><sup></sup></p>\n<pre><code>// (2)\n\nA * ptr = new A { \"hello world\" };  // lifetime of temporary not extended?\nstd::cout &lt;&lt; ptr-&gt;ref &lt;&lt; std::endl; // UB: dangling reference\n</code></pre>\n<p><br/></p>\n<p><strong>Question</strong></p>\n<ul>\n<li>Why is the lifetime of the temporary extended in <em>(1)</em>, but not in <em>(2)</em>?</li>\n</ul>\n</hr>", "Tags": "<c++><c++11><language-lawyer><object-lifetime>", "OwnerUserId": "1090079", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_23970565_23970566_5": {"section_id": 382, "quality": 0.7857142857142857, "length": 11}, "so_23970565_23970566_4": {"section_id": 382, "quality": 0.9090909090909091, "length": 10}, "so_23970565_23970566_2": {"section_id": 382, "quality": 0.9285714285714286, "length": 13}, "so_23970565_23970566_8": {"section_id": 382, "quality": 0.9090909090909091, "length": 10}, "so_23970565_23970566_6": {"section_id": 382, "quality": 0.9285714285714286, "length": 13}, "so_23970565_23970566_9": {"section_id": 382, "quality": 0.7857142857142857, "length": 11}}, "n3337": {"so_23970565_23970566_5": {"section_id": 373, "quality": 0.7857142857142857, "length": 11}, "so_23970565_23970566_4": {"section_id": 373, "quality": 0.9090909090909091, "length": 10}, "so_23970565_23970566_2": {"section_id": 373, "quality": 0.9285714285714286, "length": 13}, "so_23970565_23970566_8": {"section_id": 373, "quality": 0.9090909090909091, "length": 10}, "so_23970565_23970566_6": {"section_id": 373, "quality": 0.9285714285714286, "length": 13}, "so_23970565_23970566_9": {"section_id": 373, "quality": 0.7857142857142857, "length": 11}}, "n4659": {"so_23970565_23970566_5": {"section_id": 397, "quality": 0.7142857142857143, "length": 10}, "so_23970565_23970566_4": {"section_id": 397, "quality": 0.9090909090909091, "length": 10}, "so_23970565_23970566_2": {"section_id": 397, "quality": 0.9285714285714286, "length": 13}, "so_23970565_23970566_8": {"section_id": 397, "quality": 0.9090909090909091, "length": 10}, "so_23970565_23970566_6": {"section_id": 397, "quality": 0.9285714285714286, "length": 13}, "so_23970565_23970566_9": {"section_id": 397, "quality": 0.7142857142857143, "length": 10}}}, "23970566": {"ParentId": "23970565", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_23970565_23970566_0\"><sup><strong>LONG STORY, SHORT</strong><br/><br/>The compiler cannot extend the lifetime of the temporary involved in <code>new A { \"temporary \" }</code>, because the <code>A</code> created, and the temporary, has different <em>storage durations</em>.<br/><br/>A refence to what the Standard says can be found at the end of this post. The Standard explicitly says that the lifetime will not be extended, but it doesn't go into detail to why this is.<br/><br/>This post will try explain the reason in a way that is understandable for a broader audience, not only to the average <em><a href=\"https://stackoverflow.com/tags/language-lawyer/info\">language-lawyer</a></em>.</sup></p>\n</blockquote>\n<hr>\n<h2>Introduction</h2>\n<p>In C++ there are several types of different <em>storage durations</em> an object can have, among them are <em>automatic-</em> and <em>dynamic storage duration</em>, explained briefly below:</p>\n<p><strong>Automatic storage duration</strong></p>\n<p>The storage for an object with <em>automatic storage duration</em> will persist until the block in which they are created exits.</p>\n<ul>\n<li><p>Objects declared in block-scope has <em>automatic storage duration</em> (unless they are declared <code>static</code> or <code>extern</code>, but not <code>register</code>).</p></li>\n<li><p>Temporaries are, by definition, declared at block-scope so they too have <em>automatic storage duration</em>.</p></li>\n</ul>\n<p><br/></p>\n<p><strong>Dynamic storage duration</strong></p>\n<p>The storage for an object with <em>dynamic storage duration</em> will persist until it is explicitly stated that it should be released; such storage is, in other words, not bound to any specific scope.</p>\n<ul>\n<li><p>Objects created dynamically through <code>operator new</code> have, as hinted, <em>dynamic storage duration</em>.</p>\n<p>The storage will be persist until a matching call to <code>operator delete</code> has been made.</p></li>\n</ul>\n<p><br/></p>\n<hr>\n<hr>\n<h2>Aggregate initialization with <em>automatic storage duration</em></h2>\n<p>As stated in the previous section, a temporary has <em>automated storage duration</em>.</p>\n<p>If we construct an <em>aggregate</em> with <em>automatic storage duration</em>, this too will have storage bound to the current scope; meaning that the lifetime of the <em>temporary</em> can easily be extended to match that of the <em>aggregate</em>.</p>\n<p><sub><strong>Note</strong>: We can imagine them living in the same <em>\"box\"</em>, and at the end of the scope we discard this <em>box</em>, which is fine; neither the temporary, nor the <em>aggregate</em>, will outlive the lifetime of the <em>box</em>.</sub></p>\n<hr>\n<p><strong>Our implementation</strong> <em>(A)</em></p>\n<pre><code>struct A { std::string const&amp; ref; };\n</code></pre>\n<p><sup></sup></p>\n<pre><code>void func () {\n  A x { {\"hello world\"} };\n}\n</code></pre>\n<hr>\n<p><strong>Behind the scenes</strong> <em>(A)</em></p>\n<p>Since both <code>x</code>, and the temporary, have <em>automatic storage duration</em>, the compiler can implement the function as the following, semantically equivalent, snippet:</p>\n<pre><code>void  __func () {\n  std::string __unnamed_temporary { \"hello world\" };\n  A x { __unnamed_temporary };\n}\n</code></pre>\n<p><sub> <strong>Note</strong>: Both the temporary and the <em>aggregate</em> has their lifetime bound to the current scope, awesome!</sub></p>\n<hr>\n<hr>\n<h2>Aggregate initialization with <em>dynamic storage duration</em></h2>\n<p><strong>Our implementation</strong> <em>(B)</em></p>\n<pre><code>A* gunc () {\n  A *    ptr = new A { { \"hello world\" } };\n  return ptr;\n}\n\nint main () {\n  A * p = gunc ();\n\n  std::cout &lt;&lt; p-&gt;ref &lt;&lt; std::endl; // DANGER, WILL ROBINSON!\n\n  delete p;\n}\n</code></pre>\n<p>In the previous sections it has been stated that temporaries have <em>automatic storage duration</em>, which means that our temporary, bound to <code>A::ref</code>, will be constructed on storage that resides in the current scope.</p>\n<hr>\n<p><strong>Behind the scene</strong> <em>(B)</em></p>\n<p>The semantically equivalence of <code>gunc</code> can look as the below implementation:</p>\n<pre><code>A* gunc () {\n  A __unnamed_temporary { \"hello world \" };\n\n  A * ptr = new A { __unnamed_temporary }; // (1)\n\n  return ptr;\n}\n</code></pre>\n<hr>\n<p><strong>You are thinking it too, aren't you?</strong></p>\n<p>No longer can we extend the lifetime of our temporary to match that of the <code>A</code> created with <em>dynamic storage duration</em>, at <em>(1)</em>.</p>\n<p>The problem is that automatic storage for <code>__unnamed_temporary</code> will disappear as soon as we return from <code>gunc</code>, effectively killing our temporary.</p>\n<p>The dynamically created <code>A</code> will however still be alive, leaving us with a dangling reference in <code>main</code>.</p>\n<hr>\n<hr>\n<h2>Conclusion</h2>\n<p>The compiler is unable to extend the lifetime of any temporaries involved when creating an object through a <em>new-initializer</em> because the <em>new</em>ed object, and the temporaries, will have different storage duration.</p>\n<hr>\n<hr>\n<h2>What does the Standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">n3797</a>) say?</h2>\n<blockquote>\n<p id=\"so_23970565_23970566_1\"><code>12.2p5</code> <strong>Temporary objects</strong> <code>[class.temporary]</code></p>\n<blockquote>\n<p id=\"so_23970565_23970566_6\">The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference except:</p>\n<p id=\"so_23970565_23970566_7\">...</p>\n<ul>\n<li><p id=\"so_23970565_23970566_8\">A temporary bound to a reference in a <em>new-initializer</em> (5.3.4) persists until the completion of the full-expression containing the <em>new-initializer</em>.</p>\n<p id=\"so_23970565_23970566_9\">[ <em>Note</em>: This may introduce a dangling reference, and implementations are encouraged to issue a warning in such case. -- <em>end note</em> ]</p></li>\n</ul>\n</blockquote>\n</blockquote>\n</hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr></hr>", "OwnerUserId": "1090079", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:58:34.770", "Id": "23970566", "Score": "6", "CreationDate": "2014-05-31T13:23:24.570", "LastActivityDate": "2014-06-01T06:14:29.903"}});