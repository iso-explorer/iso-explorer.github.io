post_cb({"44288439": {"ParentId": "44247151", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-05-31T15:10:09.760", "Score": "1", "LastEditorUserId": "27678", "LastEditDate": "2017-05-31T15:22:56.313", "Id": "44288439", "OwnerUserId": "27678", "Body": "<p>From what I can tell, the value of the expression contained within the <code>noexcept</code> specifier does not become part of a function's type.*</p>\n<p>N4618 \u00a78.3.5/1 [dcl.fct] states (<strong>emphasis mine</strong>)</p>\n<blockquote>\n<p id=\"so_44247151_44288439_0\">In a declaration <code>T D</code> where <code>D</code> has the form <br/>\n  \u00a0\u00a0 \u00a0 <code>D1</code> ( <em>parameter-declaration-clause</em> ) <em>cv-qualifier-seq<sub>opt</sub> ref-qualifier<sub>opt</sub> noexcept-specifier<sub>opt</sub>attribute-specifier-seq<sub>opt</sub></em> <br/><br/>\n   and the type of the contained <em>declarator-id</em> in the declaration <code>T D1</code> is \u201c<em>derived-declarator-type-list</em> <code>T</code>\u201d, the type of the <em>declarator-id</em> in <code>D</code> is \u201c<em>derived-declarator-type-list</em> <code>noexcept</code><sub>opt</sub> function of (<em>parameter-declaration-clause</em> ) <em>cv-qualifier-seq<sub>opt</sub> ref-qualifier<sub>opt</sub></em> returning <code>T</code>\u201d, where the optional <strong><code>noexcept</code> is present if and only if the exception specification (15.4) is non-throwing</strong>. The optional <em>attribute-specifier-seq</em> appertains to the function type.</p>\n</blockquote>\n<p>So this means that the type of a function either includes <code>noexcept</code> or not; if the expression <em>expr</em> within <code>noexcept(expr)</code> evaluates to <code>false</code>, then the function's type will exclude the keyword <code>noexcept</code> altogether.</p>\n<p>So you're forced to do something like this instead:</p>\n<pre><code>template&lt;typename T&gt;\nstruct is_noexcept\n{\n    static constexpr bool value = false;\n};\n\ntemplate&lt;&gt;\nstruct is_noexcept&lt;void() noexcept&gt; {\n    static constexpr auto value = true;\n};\n</code></pre>\n<p>However, I think that the fact that code like this compiles is misleading:</p>\n<pre><code>void (*fp)() noexcept(false);\n</code></pre>\n<p>Because the type of the following function:</p>\n<pre><code>void foo() noexcept(false)\n{\n}\n</code></pre>\n<p>Is <code>void()</code>.</p>\n<p>And the type of the following function:</p>\n<pre><code>void bar() noexcept(true)\n{\n}\n</code></pre>\n<p>is <code>void() noexcept</code></p>\n<p>BUT, we can do this:</p>\n<pre><code>void (*fp)() noexcept(false) = &amp;bar;\nfp();\n</code></pre>\n<p>Even though <code>bar</code> is declared <code>noexcept</code>, we're allowed to assign the function pointer to it! So it's misleading; <strike>I can't find a standard reference for it, but it appears that the rules allow such conversions implicitly in order to accommodate an incredible amount of backwards compatibility.</strike> \u00a75/14.2 [expr] talks about this wrt to <em>composite pointer types</em>. </p>\n<p>Thankfully, though, this is illegal:</p>\n<pre><code>void (*fp)() noexcept(true) = &amp;foo;\n</code></pre>\n<p>(See the example at N4618 \u00a74.13 [conv.fctptr] for reference).</p>\n<p>*integration of exception specifiers into the type system was proposed in <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2014/n4320.html\" rel=\"nofollow noreferrer\">N4320</a> (which was adopted into the C++17 standard)</p>\n", "LastActivityDate": "2017-05-31T15:22:56.313"}, "44323196": {"ParentId": "44247151", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2017-06-02T07:28:46.963", "Score": "3", "LastEditorUserId": "2756719", "LastEditDate": "2017-06-02T16:53:33.250", "Id": "44323196", "OwnerUserId": "2756719", "Body": "<ol>\n<li><a href=\"https://timsong-cpp.github.io/cppwp/temp.deduct.type#8\" rel=\"nofollow noreferrer\">[temp.deduct.type]/8</a> lists all forms of types from which a template argument can be deduced. The <em>exception-specification</em> is not in the list and hence is not deducible.</li>\n<li>As <a href=\"https://gcc.gnu.org/ml/gcc-patches/2016-11/msg00665.html\" rel=\"nofollow noreferrer\">an extension</a>, GCC permits deducing from <code>noexcept</code> to ease the implementation of <code>std::is_function</code>. It looks like the extension is only very lightly tested.</li>\n<li>The extension was first suggested by Clang's maintainer and appeared to have some support in the committee, but <a href=\"https://bugs.llvm.org/show_bug.cgi?id=32974\" rel=\"nofollow noreferrer\">it's not clear if it will eventually make its way into the standard</a>.</li>\n<li><p>This is not a conforming extension because it changes the meaning of well-defined code, e.g., the value of <code>g(f)</code> with the following snippet:</p>\n<pre><code>void f() noexcept;\n\ntemplate&lt;bool E = false, class R&gt;\nconstexpr bool g(R (*)() noexcept(E)){\n    return E;\n}\n</code></pre></li>\n</ol>\n", "LastActivityDate": "2017-06-02T16:53:33.250"}, "44247151": {"CommentCount": "7", "AcceptedAnswerId": "44323196", "CreationDate": "2017-05-29T16:43:54.573", "LastActivityDate": "2017-06-02T16:53:33.250", "PostTypeId": "1", "ViewCount": "158", "FavoriteCount": "1", "Title": "Is noexcept deduction allowed in class template partial specialization?", "Id": "44247151", "Score": "6", "Body": "<p>For the program below, Clang 5 (trunk) reports that <code>IsNoexcept</code> is not deducible, while GCC 7.1 segfaults. <strong>What does the standard (draft) say about this?</strong> Is this a compiler QOI issue?</p>\n<pre><code>static_assert(__cpp_noexcept_function_type, \"requires c++1z\");\n\ntemplate&lt;typename T&gt;\nstruct is_noexcept;\n\ntemplate&lt;bool IsNoexcept&gt;\nstruct is_noexcept&lt;void() noexcept(IsNoexcept)&gt; {\n    static constexpr auto value = IsNoexcept;\n};\n\nstatic_assert(is_noexcept&lt;void() noexcept&gt;::value);\nstatic_assert(!is_noexcept&lt;void()&gt;::value);\n\nint main() {}\n</code></pre>\n<p>Relates to proposal P0012.</p>\n", "Tags": "<c++><language-lawyer><c++1z><typetraits>", "OwnerUserId": "2397809", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_44247151_44288439_0": {"section_id": 3238, "quality": 0.5428571428571428, "length": 19}}, "n3337": {"so_44247151_44288439_0": {"section_id": 3111, "quality": 0.5428571428571428, "length": 19}}, "n4659": {"so_44247151_44288439_0": {"section_id": 3993, "quality": 0.6857142857142857, "length": 24}}}});