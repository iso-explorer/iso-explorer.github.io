post_cb({"46974736": {"CommentCount": "1", "AcceptedAnswerId": "46974873", "CreationDate": "2017-10-27T12:11:08.597", "LastActivityDate": "2017-10-28T16:28:12.543", "Title": "Filling `std::optional<T>` via API taking output `T*` parameter", "ViewCount": "75", "PostTypeId": "1", "Id": "46974736", "Score": "2", "Body": "<p>I have a legacy non-blocking dequeue API that looks like this:</p>\n<pre><code>template &lt;typename T&gt;\nbool bad_queue&lt;T&gt;::try_dequeue(T* out);\n    // Returns 'false' if there was nothing to dequeue.\n    // Returns 'true' and sets '*out' to the dequeued item otherwise.\n</code></pre>\n<p>I would like to wrap <code>bad_queue&lt;T&gt;</code> into my own <code>cool_queue&lt;T&gt;</code> which returns an <code>std::optional&lt;T&gt;</code> from its <code>try_dequeue</code> member function:</p>\n<pre><code>template &lt;typename T&gt;\nclass cool_queue\n{\nprivate:\n    bad_queue&lt;T&gt; _q;\n\npublic:\n    std::optional&lt;T&gt; try_dequeue();\n};\n</code></pre>\n<p>This is the way I currently implement <code>try_dequeue</code>:</p>\n<pre><code>template &lt;typename T&gt;\nstd::optional&lt;T&gt; cool_queue&lt;T&gt;::try_dequeue()\n{\n    T temp;\n    const auto ok = _q.try_dequeue(&amp;temp);\n    if(!ok) { return std::nullopt; }\n    return {std::move(temp)};\n} \n</code></pre>\n<p><strong>Is there any way of avoiding the temporary <code>temp</code> buffer and directly construct the value returned by <code>_q.try_dequeue</code> inside the optional?</strong> Example:</p>\n<pre><code>// PSEUDOCODE\ntemplate &lt;typename T&gt;\nstd::optional&lt;T&gt; cool_queue&lt;T&gt;::try_dequeue()\n{\n    std::optional&lt;T&gt; temp;\n    const auto ok = _q.try_dequeue(&amp;temp.storage());\n    if(!ok) { return std::nullopt; }\n\n    temp.assume_has_object();\n    return temp;\n} \n</code></pre>\n", "Tags": "<c++><optional><c++1z>", "OwnerUserId": "598696", "AnswerCount": "2"}, "46991954": {"ParentId": "46974736", "CommentCount": "0", "Body": "<p>From your description, it would appear that the legacy <code>try_dequeue</code> function does not have any responsibility of initializing the memory allocated for the target object  (<em>\"... sets '<code>*out</code>' to the ...\"</em>), so the target object will need to have been constructed prior to the the legacy (possibly object-assigning) invocation. Specifically, for the target object being the value wrapped by an <code>std::optional</code> instance, the instance must contain a (wrapped) value if we are to access its address. </p>\n<p>The requirements to the observers of <code>std::optional</code> (<a href=\"https://timsong-cpp.github.io/cppwp/optional.observe\" rel=\"nofollow noreferrer\">[optional.observe]</a>) implicitly specify UB if <code>*someOptional</code> does not contain a value; and from <a href=\"https://timsong-cpp.github.io/cppwp/optional.optional\" rel=\"nofollow noreferrer\">[optional.optional]/1</a>:</p>\n<blockquote>\n<p id=\"so_46974736_46991954_0\">Any instance of <code>optional&lt;T&gt;</code> at any given time either contains a\n  value or does not contain a value. When an instance of optional\n  contains a value, it means that an object of type T, referred to as\n  the optional object's contained value, is allocated within the storage\n  of the optional object.</p>\n</blockquote>\n<p>The only way you'd circumvent this is to change the legacy API.</p>\n<p>As <a href=\"https://stackoverflow.com/questions/46974736/filling-stdoptionalt-via-api-taking-output-t-parameter#comment80900930_46974873\">mentioned in a comment by @Casey</a>, you could value-initialize the target object in place, and refactor the <code>cool_queue&lt;T&gt;::try_dequeue()</code> accordingly, e.g.:</p>\n<pre><code>template &lt;typename T&gt;\nstd::optional&lt;T&gt; cool_queue&lt;T&gt;::try_dequeue()\n{  \n    std::optional&lt;T&gt; temp{std::in_place};\n    return _q.try_dequeue(&amp;*temp) ? temp : std::nullopt;\n}\n</code></pre>\n", "OwnerUserId": "4573247", "PostTypeId": "2", "Id": "46991954", "Score": "1", "CreationDate": "2017-10-28T16:28:12.543", "LastActivityDate": "2017-10-28T16:28:12.543"}, "46974873": {"ParentId": "46974736", "CommentCount": "8", "Body": "<p>You can't really <em>construct</em> the value in optional via pointer, but your legacy api does not allow that anyway. You can instead default-construct a value in optional and pass a pointer to that:  </p>\n<pre><code>template &lt;typename T&gt;\nstd::optional&lt;T&gt; cool_queue&lt;T&gt;::try_dequeue()\n{\n    std::optional&lt;T&gt; temp;\n    const auto ok = _q.try_dequeue(&amp;temp.emplace());\n    if (!ok) { temp.reset(); }\n    return temp;\n}\n</code></pre>\n", "OwnerUserId": "1554020", "PostTypeId": "2", "Id": "46974873", "Score": "5", "CreationDate": "2017-10-27T12:19:11.693", "LastActivityDate": "2017-10-27T12:19:11.693"}, "bq_ids": {"n4659": {"so_46974736_46991954_0": {"section_id": 5016, "quality": 0.8620689655172413, "length": 25}}}});