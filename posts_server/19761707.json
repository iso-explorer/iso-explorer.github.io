post_cb({"bq_ids": {"n4140": {"so_19761707_19764768_0": {"length": 26, "quality": 0.896551724137931, "section_id": 5787}}, "n3337": {"so_19761707_19764768_0": {"length": 26, "quality": 0.896551724137931, "section_id": 5560}}, "n4659": {"so_19761707_19764768_0": {"length": 25, "quality": 0.8620689655172413, "section_id": 7244}}}, "19761707": {"ViewCount": "206", "Body": "<p><a href=\"http://www.stroustrup.com/C++11FAQ.html#memory-model\" rel=\"nofollow\">http://www.stroustrup.com/C++11FAQ.html#memory-model</a></p>\n<p>the page describe that :</p>\n<pre><code>// thread 1:\nchar c;\nc = 1;\nint x = c;\n\n// thread 2:\nchar b;\nb = 1;\nint y = b;\n</code></pre>\n<p>.....</p>\n<p><strong>However, most modern processors cannot read or write a single character, it must read or write a whole word, so the assignment to c really is ``read the word containing c, replace the c part, and write the word back again.'' Since the assignment to b is similar, there are plenty of opportunities for the two threads to clobber each other even though the threads do not (according to their source text) share data!</strong> </p>\n<p>I have a struct :</p>\n<pre><code>struct data_\n{\n    volatile char c ;\n    volatile char b ;\n}  __attribute__(( aligned(2) ));\ntypedef struct data_ data ;\n</code></pre>\n<p>and global vars:</p>\n<pre><code>data dx ; \nint x,y ;\n</code></pre>\n<p>Thread1 :</p>\n<pre><code>    dx.c = 1 ;\n    x = dx.c ;\n</code></pre>\n<p>Thread2 :</p>\n<pre><code>    dx.b = 1 ;\n    y = dx.b ;\n</code></pre>\n<p>Compiled at gcc 4.4.6 ,  and run it 1,000,000 times ,\n look like I don't get any value that not (x==1 &amp;&amp; y==1) !!!!</p>\n<pre><code>struct data_\n{\n    volatile char c ;\n    volatile char b ;\n}  __attribute__(( aligned(2) ));\n</code></pre>\n<p>I put char c and char b in a structure aligned(2) on purpose so that they both belong to \nthe same word ,  and according to the webpage describe , I might have the chance \nto get results not (x==1 &amp;&amp; y==1) , the fact is that run the test 1,000,000 time ,\nall get (x==1 &amp;&amp; y==1)  , is that because gcc do any tricks ? or something I missed ?</p>\n<p>Edit :</p>\n<p>Thread1 :</p>\n<pre><code>int ilocal ;\nwhile(1)\n{\n    sem_wait(sem1) ;\n    dx.c = 1 ;\n    x = dx.c ;\n    ilocal = __sync_add_and_fetch(&amp;icnt,1) ;\n    if(ilocal == 2)\n        sem_post(sem3) ;\n    ++icnt1 ;\n}\n</code></pre>\n<p>Thread2 :</p>\n<pre><code>int ilocal ;\nwhile(1)\n{\n    sem_wait(sem2) ;\n    dx.b = 1 ;\n    y = dx.b ;\n    ilocal = __sync_add_and_fetch(&amp;icnt,1) ;\n    if(ilocal == 2)\n        sem_post(sem3) ;\n    ++icnt2 ;\n}\n</code></pre>\n<p>Main :</p>\n<pre><code>int idx,iflag1=0,iflag2=0 ;\nfor(idx=0;idx&lt;1000000;idx++)\n{\n    icnt = 0 ; dx.c=0 ; dx.b=0 ;\n    sem_post(sem1) ;\n    sem_post(sem2) ;\n    sem_wait(sem3) ;\n    if( ! ((x==1)&amp;&amp;(y==1))  )\n    {\n        printf(\"result that (x==%d &amp;&amp; y==%d) \\n\",x,y) ;\n        ++iflag1 ;\n    }else{\n        ++iflag2 ;\n    }\n} //while\nprintf(\"iflag1=(%d),iflag2=(%d)\\n\",iflag1,iflag2) ;\nprintf(\"icnt1=(%d),icnt2=(%d) \\n\",icnt1,icnt2) ;\n</code></pre>\n<p>gcc   memorylocate.c -lpthread -o memorylocate.exe</p>\n<pre><code>sizeof data=(64) //source already change to __attribute__(( aligned(64) )\niflag1=(0),iflag2=(1000000)\nicnt1=(1000000),icnt2=(1000000)\n</code></pre>\n<p>Edit2 :</p>\n<p>I think I finally figure it out !! </p>\n<pre><code>struct { char c ; char b ;}\n</code></pre>\n<p>c and b would be different memory location , so that they can be thread-safe access !!\nthe cpu can access single-byte char atomiclly !!!!!</p>\n<p>I change code to :</p>\n<pre><code>struct data_\n{\n    unsigned char c:4 ;\n    unsigned char b:4 ;\n} ;\n</code></pre>\n<p>and in main :</p>\n<pre><code>for(idx=0;idx&lt;1000000;idx++)\n{\n    icnt = 0 ; dx.c=0 ; dx.b=0 ;\n    sem_post(sem1) ;\n    sem_post(sem2) ;\n    sem_wait(sem3) ;\n    if( ! ((dx.c==1)&amp;&amp;(dx.b==1))  )\n    {\n        printf(\"result that (x==%d &amp;&amp; y==%d) \\n\",x,y) ;\n        ++iflag1 ;\n    }else{\n        ++iflag2 ;\n    }\n} //while\n</code></pre>\n<p>I observe there are results that not (dx.c==1)&amp;&amp;(dx.b==1)  !! This is because the dx.c and dx.b is in the same memory location in this case !!!!</p>\n<p>So I make a mistake , the most important thing to decide is memory location , struct {char c; char b;}  , char c and char b is in different memory location , the  test result is correct !!!!</p>\n", "AcceptedAnswerId": "19764768", "Title": "memory location and data race in c", "CreationDate": "2013-11-04T04:35:32.100", "Id": "19761707", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-11-04T08:34:05.970", "LastEditorUserId": "952268", "LastActivityDate": "2013-11-04T09:27:49.130", "Score": "1", "OwnerUserId": "952268", "Tags": "<c++><c><multithreading><gcc>", "AnswerCount": "1"}, "19764768": {"Id": "19764768", "PostTypeId": "2", "Body": "<p>see 1.7 [intro.memory] p3 in the C++ Standard:</p>\n<blockquote>\n<p id=\"so_19761707_19764768_0\">A memory location is either an object of scalar type or a maximal\n  sequence of adjacent bit-fields all having non-zero width. [ Note:\n  ... ] Two or more threads of execution (1.10) can update and access\n  separate memory locations without interfering with each other.</p>\n</blockquote>\n<p>So a conforming compiler just has to ensure that a char can be updated without affecting other memory locations.</p>\n", "LastActivityDate": "2013-11-04T09:27:49.130", "CommentCount": "1", "CreationDate": "2013-11-04T09:27:49.130", "ParentId": "19761707", "Score": "3", "OwnerUserId": "76919"}});