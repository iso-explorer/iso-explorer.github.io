post_cb({"bq_ids": {"n4140": {"so_46162766_46163082_1": {"length": 17, "quality": 0.5483870967741935, "section_id": 7233}, "so_46162766_46163082_2": {"length": 21, "quality": 0.875, "section_id": 3296}, "so_46162766_46163082_0": {"length": 31, "quality": 0.8157894736842105, "section_id": 6123}}, "n3337": {"so_46162766_46163082_1": {"length": 29, "quality": 0.9354838709677419, "section_id": 6977}, "so_46162766_46163082_2": {"length": 21, "quality": 0.875, "section_id": 3166}, "so_46162766_46163082_0": {"length": 32, "quality": 0.8421052631578947, "section_id": 5887}}, "n4659": {"so_46162766_46163082_2": {"length": 21, "quality": 0.875, "section_id": 4058}, "so_46162766_46163082_0": {"length": 31, "quality": 0.8157894736842105, "section_id": 7620}}}, "46162766": {"ViewCount": "59", "Body": "<p>I am trying to word this as best as possible, but an example is a good way to demonstrate my question. Consider the following scenario where variable <code>long a</code> goes into a narrower array element - essentially <code>const int b[0]</code>:</p>\n<pre><code>long a = 584;\nconst int b[4] = {(const int) a, 0, 0, 0};\n</code></pre>\n<p>Is the following snippet equivalent considering that the const isn't explicitly defined:</p>\n<pre><code>long a = 584;\nconst int b[4] = {(int) a, 0, 0, 0};\n</code></pre>\n<p>Both compile, but does the standard define this scenario and outcomes?</p>\n", "AcceptedAnswerId": "46163082", "Title": "Is casting to const implied when casting to a narrower const location?", "CreationDate": "2017-09-11T19:05:43.947", "Id": "46162766", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2017-09-11T19:26:39.127", "Score": "0", "OwnerUserId": "8585867", "Tags": "<c++>", "AnswerCount": "2"}, "46162836": {"Id": "46162836", "PostTypeId": "2", "Body": "<p>No, <code>const</code> is not implicitly added by the compiler, because it doesn't change anything. Both of your snippets are equivalent.</p>\n<p>I don't think the standard defines this scenario, because it's a bit contrived.</p>\n<p>Your question is equivalent whether it matters whether <code>a</code> is <code>const</code> here or not (in the example bellow). The answer is no, it doesn't, because you are copying <code>a</code>. It doesn't matter that you can't write to <code>a</code>, because you are only doing a read, not a write.</p>\n<pre><code>/*const*/ int a = 10;\nconst int b = a;\n</code></pre>\n", "LastActivityDate": "2017-09-11T19:10:56.330", "Score": "2", "CreationDate": "2017-09-11T19:10:56.330", "ParentId": "46162766", "CommentCount": "2", "OwnerUserId": "3980929"}, "46163082": {"Id": "46163082", "PostTypeId": "2", "Body": "<p>Casting to <code>const int</code> produces a value of type <code>int</code>. There are no cv-qualified prvalues of non-class type. See [expr.cast]/1:</p>\n<blockquote>\n<p id=\"so_46162766_46163082_0\">The result of the expression <code>(T)</code> <em>cast-expression</em> is of type <code>T</code>. The result is an lvalue if <code>T</code> is an lvalue reference\n  type or an rvalue reference to function type and an xvalue if <code>T</code> is an rvalue reference to object type; otherwise\n  the result is a prvalue. [ <em>Note:</em> if <code>T</code> is a non-class type that is cv-qualified, <strong>the cv-qualifiers are ignored when\n  determining the type of the resulting prvalue</strong>; see 3.10. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>and [basic.lval]/4:</p>\n<blockquote>\n<p id=\"so_46162766_46163082_1\">Class prvalues can have cv-qualified types; <strong>non-class prvalues always have cv-unqualified types</strong>. Unless\n  otherwise indicated (5.2.2), prvalues shall always have complete types or the void type; in addition to these\n  types, glvalues can also have incomplete types.</p>\n</blockquote>\n<p>So even though you write a cast to <code>const int</code>, the resulting value will have type <code>int</code>.</p>\n<p>However, a language lawyer might ask whether the <code>(int)</code> cast and the <code>(const int)</code> cast are guaranteed to produce <em>the same value.</em> Obviously in your case <code>584</code> fits into <code>int</code> so the value is guaranteed to be <code>584</code>. In the general case where the <code>long</code> value might not fit into an <code>int</code>, the last bullet point of [dcl.init]/16 guarantees that the result of casting to <code>const int</code> will still be the same as casting to <code>int</code>:</p>\n<blockquote>\n<p id=\"so_46162766_46163082_2\">... Otherwise, the initial value of the object being initialized is the (possibly converted) value of the ini-\n  tializer expression. Standard conversions (Clause 4) will be used, if necessary, to convert the initializer\n  expression to the <strong>cv-unqualified version of the destination type</strong>;</p>\n</blockquote>\n<p>(All wording is from the C++14 standard; emphasis is mine.)</p>\n", "LastActivityDate": "2017-09-11T19:26:39.127", "Score": "3", "CreationDate": "2017-09-11T19:26:39.127", "ParentId": "46162766", "CommentCount": "0", "OwnerUserId": "481267"}});