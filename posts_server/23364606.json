post_cb({"23365063": {"Id": "23365063", "PostTypeId": "2", "Body": "<p>clang is correct. Since C++11, the conversion from <code>std::basic_ios</code> to <code>bool</code> is indeed required to be <code>explicit</code>.</p>\n<p>C++11, <code>[ios.overview]</code>:</p>\n<pre><code>explicit operator bool() const;\n</code></pre>\n", "LastActivityDate": "2014-04-29T12:45:19.443", "CommentCount": "0", "CreationDate": "2014-04-29T12:45:19.443", "ParentId": "23364606", "Score": "5", "OwnerUserId": "1782465"}, "23364606": {"ViewCount": "793", "Body": "<p>This simple code </p>\n<pre><code>bool foo(std::istringstream&amp;stream, std::string&amp;single, char del)\n{ return std::getline(stream,single,del); }\n</code></pre>\n<p>compiles with gcc (4.8.2) but not with clang (3.4, using libc++), which complains that there is no viable conversion from <code>std::basic_istream&lt;char, std::char_traits&lt;char&gt; &gt;</code> to <code>bool</code>. However, when I wrap argument to the return statement in a <code>static_cast&lt;bool&gt;()</code>, clang is happy.</p>\n<p>This confused me made me wonder whether the above code is well formed or not, i.e. whether gcc or clang is correct. According to <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/getline\" rel=\"nofollow\">cpprefernce</a> <code>std::getline</code> returns a <code>std::basic_istream&lt;char, std::char_traits&lt;char&gt; &gt;</code>, which is inherited from a <code>std::basic_ios</code> which has the type conversion <code>operator bool</code> (since C++11, before it was a type conversion to <code>void*</code>). Shouldn't this conversion operator get selected automatically? (for some reason, I'm more ready to accept that gcc is wrong than clang).</p>\n<p><strong>Edit</strong> I just figured out that apparently libc++ of llvm declares the conversion operator in question <code>explicit</code>, deeming it invalid for the implicit conversion. Is this in line with the standard?</p>\n", "AcceptedAnswerId": "23365063", "Title": "istream to bool conversion: when is it available?", "CreationDate": "2014-04-29T12:24:52.507", "Id": "23364606", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2014-04-29T13:17:21.650", "Score": "2", "OwnerUserId": "1023390", "Tags": "<c++><gcc><c++11><type-conversion><clang>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_23364606_23365816_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 392}}, "n3337": {"so_23364606_23365816_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 383}}, "n4659": {"so_23364606_23365816_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 409}}}, "23365816": {"Id": "23365816", "PostTypeId": "2", "Body": "<p>As the initialization that occurs in function return is the copy-initialization then the explicit conversion <code>operator bool</code> may not be applied implicitly. \nFrom the C++ Standard</p>\n<blockquote>\n<p id=\"so_23364606_23365816_0\">2 A conversion function may be explicit (7.1.2), in which case it is\n  only considered as a user-defined conversion for direct-initialization\n  (8.5).</p>\n</blockquote>\n<p>So GCC has a bug.</p>\n<p>The operator may be applied implicitly when the direct-initialization is used or in special context as the context of  the if condition.</p>\n", "LastActivityDate": "2014-04-29T13:17:21.650", "CommentCount": "0", "CreationDate": "2014-04-29T13:17:21.650", "ParentId": "23364606", "Score": "1", "OwnerUserId": "2877241"}});