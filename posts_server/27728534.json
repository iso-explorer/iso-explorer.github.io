post_cb({"bq_ids": {"n4140": {"so_27728534_27728534_0": {"length": 34, "quality": 0.8717948717948718, "section_id": 556}}, "n3337": {"so_27728534_27728534_0": {"length": 34, "quality": 0.8717948717948718, "section_id": 547}}, "n4659": {"so_27728534_27728534_0": {"length": 34, "quality": 0.8717948717948718, "section_id": 579}}}, "27728534": {"ViewCount": "67", "Body": "<p>The Standard at <code>N4296:13.1/1 [over.load]</code> says:</p>\n<blockquote>\n<p id=\"so_27728534_27728534_0\">A program is ill-formed if it contains two such non-overloadable\n  declarations in the same scope. [ Note: This restriction applies to\n  explicit declarations in a scope, and between such declarations and\n  declarations made through a using-declaration (7.3.3). It does not\n  apply to sets of functions fabricated as a result of name lookup\n  (e.g., because of using-directives) or <em>overload resolution</em> (e.g., for\n  operator functions). \u2014end note ]</p>\n</blockquote>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace A\n{\n    int foo(){ return 1; };\n}\n\nusing namespace A;\n\nint foo(){ return 1; }\n\nint main(){ }\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/573bb399bc207535\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>This will be well-formed untill foo is not odr-used. This is clear and this reperesent the first piece of the note I provided in the quote (about <code>using-directive</code>). But I have no idea what the Standard meant about overload resolution for operator functions that I emphasized in the quote. Could you give me an example?</p>\n", "AcceptedAnswerId": "27734442", "Title": "Overload resolution not applicable to operator overloading", "CreationDate": "2015-01-01T05:38:38.640", "Id": "27728534", "CommentCount": "3", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "LastActivityDate": "2015-01-01T20:37:21.960", "Score": "0", "Tags": "<c++><overloading>", "AnswerCount": "1"}, "27734442": {"Id": "27734442", "PostTypeId": "2", "Body": "<pre><code>namespace A {\n    struct Foo{};\n}\n\nnamespace B {\n    struct Bar{};\n}\n\nnamespace A {\n    int operator+(const A::Foo&amp;, const B::Bar&amp;);\n}\n\nnamespace B {\n    char operator+(const A::Foo&amp;, const B::Bar&amp;);\n}\n\nint main() { A::Foo() + B::Bar(); }\n</code></pre>\n<p>ADL finds both <code>A::operator+()</code> and <code>B::operator+()</code>. The two signatures are different only in their return type.</p>\n", "LastActivityDate": "2015-01-01T20:37:21.960", "CommentCount": "0", "CreationDate": "2015-01-01T20:37:21.960", "ParentId": "27728534", "Score": "1", "OwnerUserId": "2756719"}});