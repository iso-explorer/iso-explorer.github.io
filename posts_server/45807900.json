post_cb({"45828592": {"ParentId": "45807900", "CommentCount": "0", "CreationDate": "2017-08-22T23:58:17.730", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "45828592", "Score": "1", "Body": "<p>In both <code>foo</code> and <code>bar</code>,  the expression <code>a</code> is an lvalue. The statement <code>return a;</code> means to initialize the <em>return value</em> object from the initializer <code>a</code>, and return that object.</p>\n<p>The difference between the two cases is that overload resolution for this initialization is performed differently depending on whether or not <code>a</code> declared as a non-volatile automatic object within the innermost enclosing block, or a function parameter. </p>\n<p>Which it is for <code>foo</code> but not <code>bar</code>. (In <code>bar</code> , <code>a</code> is declared as a reference). So <code>return a;</code> in <code>foo</code> selects the move constructor to initialize the return value, but <code>return a;</code> in <code>bar</code> selects the copy constructor.</p>\n<p>The full text is C++14 [class.copy]/32:</p>\n<blockquote>\n<p id=\"so_45807900_45828592_0\">When the criteria for elision of a copy/move operation are met, but not for an exception-declaration , and the object to be copied is designated by an lvalue, or when the expression in a return statement is a (possibly parenthesized) id-expression that names an object with automatic storage duration declared in the body or parameter-declaration-clause of the innermost enclosing function or lambda-expression, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue. If the first overload resolution fails or was not performed, or if the type of the first parameter of the selected constructor is not an rvalue reference to the object\u2019s type (possibly cv-qualified), overload resolution is performed again, considering the object as an lvalue. [Note: This two-stage overload resolution must be performed regardless of whether copy elision will occur. It determines the constructor to be called if elision is not performed, and the selected constructor must be accessible even if the call is elided. \u2014end note ]</p>\n</blockquote>\n<p>where \"criteria for elision of a copy/move operation are met\"  refers to [class.copy]/31.1:</p>\n<blockquote id=\"so_45807900_45828592_1\">\n<ul>\n<li>in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (other than a function or catch-clause parameter) with the same cv-unqualified type as the function return type, the copy/move operation can be omitted by constructing\n  the automatic object directly into the function\u2019s return value</li>\n</ul>\n</blockquote>\n<p>Note, these texts will change for C++17.</p>\n", "LastActivityDate": "2017-08-22T23:58:17.730"}, "45826490": {"ParentId": "45807900", "CommentCount": "0", "CreationDate": "2017-08-22T20:32:48.990", "OwnerUserId": "448839", "PostTypeId": "2", "Id": "45826490", "Score": "1", "Body": "<p>yeah, very confusing. I would like to cite another SO post here <a href=\"https://stackoverflow.com/questions/9779079/why-does-c11-have-implicit-moves-for-value-parameters-but-not-for-rvalue-para\">implicite move</a>. where I find the following comments a bit convincing, </p>\n<blockquote>\n<p id=\"so_45807900_45826490_0\">And therefore, the standards committee decided that you had to be\n  explicit about the move for any named variable, regardless of its\n  reference type</p>\n</blockquote>\n<p>Actually \"&amp;&amp;\" is already indicating let-go and at the time when you do \"return\", it is safe enough to do move. </p>\n<p>probably it is just the choice from standard committee.  </p>\n<p>item 25 of \"effective modern c++\" by scott meyers, also summarized this, without giving much explanations. </p>\n<pre><code>Alpha foo() {\n  Alpha a\n  return a; // RVO by decent compiler\n}\nAlpha foo(Alpha a) {\n  return a; // implicit std::move by compiler\n}\n\nAlpha bar(Alpha &amp;&amp;a) {\n  return a; // Copy ctor due to lvalue\n}\n\nAlpha bar(Alpha &amp;&amp;a) {\n  return std:move(a); // has to be explicit by developer\n}\n</code></pre>\n", "LastActivityDate": "2017-08-22T20:32:48.990"}, "45808170": {"ParentId": "45807900", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2017-08-22T02:49:00.730", "Score": "4", "LastEditorUserId": "2648745", "LastEditDate": "2017-08-22T03:24:35.933", "Id": "45808170", "OwnerUserId": "2648745", "Body": "<p>There are 2 things to understand in this situation:</p>\n<ol>\n<li><code>a</code> in <code>bar(Alpha &amp;&amp;a)</code> is a named rvalue reference; therefore, treated as an lvalue.</li>\n<li><code>a</code> is still a reference.</li>\n</ol>\n<p><strong>Part 1</strong></p>\n<p>Since <code>a</code> in <code>bar(Alpha &amp;&amp;a)</code> is a named rvalue reference, its treated as an lvalue. The motivation behind treating named rvalue references as lvalues is to provide safety. Consider the following,</p>\n<pre><code>Alpha bar(Alpha &amp;&amp;a) {\n  baz(a);\n  qux(a);\n  return a;\n}\n</code></pre>\n<p>If <code>baz(a)</code> considered <code>a</code> as an rvalue then it is free to call the move constructor and <code>qux(a)</code> may be invalid. The standard avoids this problem by treating named rvalue references as lvalues.</p>\n<p><strong>Part 2</strong></p>\n<p>Since <code>a</code> is still a reference (and may refer to an object outside of the scope of <code>bar</code>), <code>bar</code> calls the copy constructor when returning. The motivation behind this behavior is to provide safety.</p>\n<p><strong>References</strong></p>\n<ol>\n<li><a href=\"https://stackoverflow.com/questions/13430831/return-by-rvalue-reference\">SO Q&amp;A - return by rvalue reference</a></li>\n<li>Comment by Kerrek SB</li>\n</ol>\n", "LastActivityDate": "2017-08-22T03:24:35.933"}, "45827838": {"ParentId": "45807900", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-08-22T22:18:35.977", "Score": "1", "LastEditorUserId": "1908347", "LastEditDate": "2017-08-22T22:30:51.590", "Id": "45827838", "OwnerUserId": "1908347", "Body": "<p>This is a very very common mistake to make as people first learn about rvalue references. The basic problem is a confusion between <strong>type</strong> and <strong>value category</strong>.</p>\n<p><code>int</code> is a type. <code>int&amp;</code> is a different type. <code>int&amp;&amp;</code> is yet another type. These are all different types.</p>\n<p>lvalues and rvalues are things called value categories. Please check out the fantastic chart here: <a href=\"https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues\">What are rvalues, lvalues, xvalues, glvalues, and prvalues?</a>. You can see that in addition to lvalues and rvalues, we also have prvalues and glvalues and xvalues, and they form a various venn diagram sort of relation.</p>\n<p>C++ has rules that say that variables of various types can bind to expressions. An expressions reference type however, is discarded (people often say that expressions do not have reference type). Instead, the expression have a value category, which determines which variables can bind to it.</p>\n<p>Put another way: rvalue references and lvalue references are only directly relevant on the left hand of the assignment, the variable being created/bound. On the right side, we are talking about expressions and not variables, and rvalue/lvalue reference-ness is only relevant in the context of determining value category.</p>\n<p>A very simple example to start with is simple looking at things of purely type <code>int</code>. A variable of type <code>int</code> as an expression, is an lvalue. However, an expression consisting of evaluating a function that returns an <code>int</code>, is an rvalue. This makes intuitive sense to most people; the key thing though is to separate out the type of an expression (even before references are discarded) and its value category.</p>\n<p>What this is leading to, is that even though variables of type <code>int&amp;&amp;</code> can only <strong>bind</strong> to rvalues, does not mean that all expressions with type <code>int&amp;&amp;</code>, <strong>are</strong> rvalues. In fact, as the rules at <a href=\"http://en.cppreference.com/w/cpp/language/value_category\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/value_category</a> say, any expression consisting of naming a variable, is always an lvalue, <em>no matter the type</em>.</p>\n<p>That's why you need <code>std::move</code> in order to pass along rvalue references into subsequent functions that take by rvalue reference. It's because rvalue references do <em>not</em> bind to other rvalue references. They bind to rvalues. If you want to get the move constructor, you need to give it an rvalue to bind to, and a named rvalue reference is not an rvalue.</p>\n<p><code>std::move</code> is a function that returns an rvalue reference. And what's the value category of such an expression? An rvalue? Nope. It's an xvalue. Which is basically an rvalue, with some additional properties.</p>\n", "LastActivityDate": "2017-08-22T22:30:51.590"}, "45807900": {"CommentCount": "8", "AcceptedAnswerId": "45808170", "CreationDate": "2017-08-22T02:09:52.857", "LastActivityDate": "2017-08-22T23:58:17.730", "PostTypeId": "1", "ViewCount": "87", "FavoriteCount": "1", "Title": "Copy ctor called instead of move ctor", "Id": "45807900", "Score": "5", "Body": "<p>Why is the copy constructor called when returning from <code>bar</code> instead of the move constructor?</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Alpha {\npublic:\n  Alpha() { cout &lt;&lt; \"ctor\" &lt;&lt; endl; }\n  Alpha(Alpha &amp;) { cout &lt;&lt; \"copy ctor\" &lt;&lt; endl; }\n  Alpha(Alpha &amp;&amp;) { cout &lt;&lt; \"move ctor\" &lt;&lt; endl; }\n  Alpha &amp;operator=(Alpha &amp;) { cout &lt;&lt; \"copy asgn op\" &lt;&lt; endl; }\n  Alpha &amp;operator=(Alpha &amp;&amp;) { cout &lt;&lt; \"move asgn op\" &lt;&lt; endl; }\n};\n\nAlpha foo(Alpha a) {\n  return a; // Move ctor is called (expected).\n}\n\nAlpha bar(Alpha &amp;&amp;a) {\n  return a; // Copy ctor is called (unexpected).\n}\n\nint main() {\n  Alpha a, b;\n  a = foo(a);\n  a = foo(Alpha());\n  a = bar(Alpha());\n  b = a;\n  return 0;\n}\n</code></pre>\n<p>If <code>bar</code> does <code>return move(a)</code> then the behavior is as expected. I do not understand why a call to <code>std::move</code> is necessary given that <code>foo</code> calls the move constructor when returning.</p>\n", "Tags": "<c++><c++11><constructor><copy-constructor><move-constructor>", "OwnerUserId": "2648745", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_45807900_45828592_1": {"section_id": 480, "quality": 1.0, "length": 35}, "so_45807900_45828592_0": {"section_id": 481, "quality": 0.946236559139785, "length": 88}}, "n3337": {"so_45807900_45828592_1": {"section_id": 471, "quality": 1.0, "length": 35}, "so_45807900_45828592_0": {"section_id": 472, "quality": 0.6881720430107527, "length": 64}}, "n4659": {"so_45807900_45828592_1": {"section_id": 502, "quality": 0.8857142857142857, "length": 31}, "so_45807900_45828592_0": {"section_id": 504, "quality": 0.8279569892473119, "length": 77}}}});