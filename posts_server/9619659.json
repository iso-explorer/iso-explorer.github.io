post_cb({"9619659": {"ViewCount": "1252", "Body": "<p>Let\u2019s consider that snippet, and please suppose that a, b, c and d are non-empty strings.</p>\n<pre><code>    std::string a, b, c, d;\n    d = a + b + c;\n</code></pre>\n<p>When computing the sum of those 3\u00a0<code>std::string</code> instances, the standard library implementations create a first temporary <code>std::string</code> object, copy in its internal buffer the concatenated buffers of <code>a</code> and <code>b</code>, then perform the same operations between the temporary string and the <code>c</code>. </p>\n<p>A fellow programmer was stressing that instead of this behaviour, <code>operator+(std::string, std::string)</code> could be defined to return a <code>std::string_helper</code>.</p>\n<p>This object\u2019s very role would be to defer the actual concatenations to the moment where it\u2019s casted into a <code>std::string</code>. Obviously, <code>operator+(std::string_helper, std::string)</code> would be defined to return the same helper, which would \"keep in mind\" the fact that it has an additional concatenation to carry out.</p>\n<p>Such a behavior would save the CPU cost of creating n-1 temporary objects, allocating their buffer, copying them, etc. So my question is: why doesn\u2019t it already work like that ?I can\u2019t think of any drawback or limitation.</p>\n", "AcceptedAnswerId": "9620134", "Title": "std::string and multiple concatenations", "CreationDate": "2012-03-08T14:59:30.700", "Id": "9619659", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2012-03-08T16:12:02.930", "Score": "4", "OwnerUserId": "748175", "Tags": "<c++><string><optimization><std>", "AnswerCount": "6"}, "9619916": {"Id": "9619916", "PostTypeId": "2", "Body": "<p>The main reason for not doing a string of individual <code>+</code> concatenations, and especially not doing that in a loop, is that is has O(<i>n</i><sup>2</sup>) complexity.</p>\n<p>A reasonable alternative with O(<i>n</i>) complexity is to use a simple string builder, like</p>\n<pre><code>template&lt; class Char &gt;\nclass ConversionToString\n{\npublic:\n    // Visual C++ 10.0 has some DLL linking problem with other types:\n    CPP_STATIC_ASSERT((\n        std::is_same&lt; Char, char &gt;::value || std::is_same&lt; Char, wchar_t &gt;::value\n        ));\n\n    typedef std::basic_string&lt; Char &gt;           String;\n    typedef std::basic_ostringstream&lt; Char &gt;    OutStringStream;\n\n    // Just a default implementation, not particularly efficient.\n    template&lt; class Type &gt;\n    static String from( Type const&amp; v )\n    {\n        OutStringStream stream;\n        stream &lt;&lt; v;\n        return stream.str();\n    }\n\n    static String const&amp; from( String const&amp; s )\n    {\n        return s;\n    }\n};\n\n\ntemplate&lt; class Char, class RawChar = Char &gt;\nclass StringBuilder;\n\n\ntemplate&lt; class Char, class RawChar &gt;\nclass StringBuilder\n{\nprivate:\n    typedef std::basic_string&lt; Char &gt;       String;\n    typedef std::basic_string&lt; RawChar &gt;    RawString;\n    RawString   s_;\n\n    template&lt; class Type &gt;\n    static RawString fastStringFrom( Type const&amp; v )\n    {\n        return ConversionToString&lt; RawChar &gt;::from( v );\n    }\n\n    static RawChar const* fastStringFrom( RawChar const* s )\n    {\n        assert( s != 0 );\n        return s;\n    }\n\n    static RawChar const* fastStringFrom( Char const* s )\n    {\n        assert( s != 0 );\n        CPP_STATIC_ASSERT( sizeof( RawChar ) == sizeof( Char ) );\n        return reinterpret_cast&lt; RawChar const* &gt;( s );\n    }\n\npublic:\n    enum ToString { toString };\n    enum ToPointer { toPointer };\n\n    String const&amp;   str() const             { return reinterpret_cast&lt; String const&amp; &gt;( s_ ); }\n    operator String const&amp; () const         { return str(); }\n    String const&amp; operator&lt;&lt;( ToString )    { return str(); }\n\n    RawChar const*     ptr() const          { return s_.c_str(); }\n    operator RawChar const* () const        { return ptr(); }\n    RawChar const* operator&lt;&lt;( ToPointer )  { return ptr(); }\n\n    template&lt; class Type &gt;\n    StringBuilder&amp; operator&lt;&lt;( Type const&amp; v )\n    {\n        s_ += fastStringFrom( v );\n        return *this;\n    }\n};\n\ntemplate&lt; class Char &gt;\nclass StringBuilder&lt; Char, Char &gt;\n{\nprivate:\n    typedef std::basic_string&lt; Char &gt;   String;\n    String  s_;\n\n    template&lt; class Type &gt;\n    static String fastStringFrom( Type const&amp; v )\n    {\n        return ConversionToString&lt; Char &gt;::from( v );\n    }\n\n    static Char const* fastStringFrom( Char const* s )\n    {\n        assert( s != 0 );\n        return s;\n    }\n\npublic:\n    enum ToString { toString };\n    enum ToPointer { toPointer };\n\n    String const&amp;   str() const             { return s_; }\n    operator String const&amp; () const         { return str(); }\n    String const&amp; operator&lt;&lt;( ToString )    { return str(); }\n\n    Char const*     ptr() const             { return s_.c_str(); }\n    operator Char const* () const           { return ptr(); }\n    Char const* operator&lt;&lt;( ToPointer )     { return ptr(); }\n\n    template&lt; class Type &gt;\n    StringBuilder&amp; operator&lt;&lt;( Type const&amp; v )\n    {\n        s_ += fastStringFrom( v );\n        return *this;\n    }\n};\n\nnamespace narrow {\n    typedef StringBuilder&lt;char&gt;     S;\n}  // namespace narrow\n\nnamespace wide {\n    typedef StringBuilder&lt;wchar_t&gt;  S;\n}  // namespace wide\n</code></pre>\n<p>Then you can write efficient and clear things like \u2026</p>\n<pre><code>using narrow::S;\n\nstd::string a = S() &lt;&lt; \"The answer is \" &lt;&lt; 6*7;\nfoo( S() &lt;&lt; \"Hi, \" &lt;&lt; username &lt;&lt; \"!\" );\n</code></pre>\n", "LastEditorUserId": "464581", "LastActivityDate": "2012-03-08T15:21:57.877", "Score": "0", "CreationDate": "2012-03-08T15:13:50.173", "ParentId": "9619659", "CommentCount": "0", "OwnerUserId": "464581", "LastEditDate": "2012-03-08T15:21:57.877"}, "9620134": {"Id": "9620134", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_9619659_9620134_0\">why doesn\u2019t it already work like that?</p>\n</blockquote>\n<p>I can only speculate about why it was originally designed like that. Perhaps the designers of the string library simply didn't think of it; perhaps they thought the extra type conversion (see below) might make the behaviour too surprising in some situations. It is one of the oldest C++ libraries, and a lot of wisdom that we take for granted simply didn't exist in past decades.</p>\n<p>As to why it hasn't been changed to work like that: it could break existing code, by adding an extra user-defined type conversion. Implicit conversions can only involve at most one user-defined conversion. This is specified by C++11, 13.3.3.1.2/1:</p>\n<blockquote>\n<p id=\"so_9619659_9620134_1\">A user-defined conversion sequence consists of an initial standard conversion sequence followed by <strong>a user-defined conversion</strong> followed by a second standard conversion sequence.</p>\n</blockquote>\n<p>Consider the following:</p>\n<pre><code>struct thingy {\n    thingy(std::string);\n};\n\nvoid f(thingy);\n\nf(some_string + another_string);\n</code></pre>\n<p>This code is fine if the type of <code>some_string + another_string</code> is <code>std::string</code>. That can be implicitly converted to <code>thingy</code> via the conversion constructor. However, if we were to change the definition of <code>operator+</code> to give another type, then it would need two conversions (<code>string_helper</code> to <code>string</code> to <code>thingy</code>), and so would fail to compile.</p>\n<p>So, if the speed of string building is important, you'll need to use alternative methods like concatenation with <code>+=</code>. Or, according to Matthieu's answer, don't worry about it because C++11 fixes the inefficiency in a different way.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2012-03-08T16:04:59.903", "Score": "6", "CreationDate": "2012-03-08T15:26:06.883", "ParentId": "9619659", "CommentCount": "5", "OwnerUserId": "204847", "LastEditDate": "2012-03-08T16:04:59.903"}, "bq_ids": {"n4140": {"so_9619659_9620134_1": {"length": 14, "quality": 1.0, "section_id": 620}}, "n3337": {"so_9619659_9620134_1": {"length": 14, "quality": 1.0, "section_id": 610}}, "n4659": {"so_9619659_9620134_1": {"length": 14, "quality": 1.0, "section_id": 646}}}, "9620055": {"Id": "9620055", "PostTypeId": "2", "Body": "<p>It depends.</p>\n<p>In C++03, it is exact that there may be a slight inefficiency there (comparable to Java and C# as they use string interning by the way). This can be alleviated using:</p>\n<pre><code>d = std::string(\"\") += a += b +=c;\n</code></pre>\n<p>which is not really... idiomatic.</p>\n<p>In C++11, <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/operator+\" rel=\"nofollow\"><code>operator+</code></a> is overloaded for rvalue references. Meaning that:</p>\n<pre><code>d = a + b + c;\n</code></pre>\n<p>is transformed into:</p>\n<pre><code>d.assign(std::move(operator+(a, b).append(c)));\n</code></pre>\n<p>which is (nearly) as efficient as you can get.</p>\n<p>The only inefficiency left in the C++11 version is that the memory is not reserved once and for all at the beginning, so there might be reallocation and copies up to 2 times (for each new string). Still, because appending is amortized O(1), unless C is quite longer than B, then at worst a single reallocation + copy should take place. And of course, we are talking POD copy here (so a <code>memcpy</code> call).</p>\n", "LastEditorUserId": "147192", "LastActivityDate": "2012-03-08T16:12:02.930", "Score": "4", "CreationDate": "2012-03-08T15:21:39.693", "ParentId": "9619659", "CommentCount": "2", "OwnerUserId": "147192", "LastEditDate": "2012-03-08T16:12:02.930"}, "9619719": {"Id": "9619719", "PostTypeId": "2", "Body": "<p>Sounds to me like something like this already exists: <a href=\"http://www.cplusplus.com/reference/iostream/stringstream/\" rel=\"nofollow\"><code>std::stringstream</code></a>.</p>\n<p>Only you have <code>&lt;&lt;</code> instead of <code>+</code>. Just because <code>std::string::operator +</code> exists, it doesn't make it the most efficient option.</p>\n", "LastEditorUserId": "673730", "LastActivityDate": "2012-03-08T15:08:41.930", "Score": "2", "CreationDate": "2012-03-08T15:02:46.037", "ParentId": "9619659", "CommentCount": "0", "OwnerUserId": "673730", "LastEditDate": "2012-03-08T15:08:41.930"}, "9619752": {"Id": "9619752", "PostTypeId": "2", "Body": "<p>I think if you use <code>+=</code>, then it will be little faster:</p>\n<pre><code>d += a;\nd += b;\nd += c;\n</code></pre>\n<p>It should be faster, as it doesn't create temporary objects.Or simply this,</p>\n<pre><code>d.append(a).append(b).append(c); //same as above: i.e using '+=' 3 times.\n</code></pre>\n", "LastActivityDate": "2012-03-08T15:04:45.513", "CommentCount": "3", "CreationDate": "2012-03-08T15:04:45.513", "ParentId": "9619659", "Score": "0", "OwnerUserId": "415784"}, "9620219": {"Id": "9620219", "PostTypeId": "2", "Body": "<p>The obvious answer: because the standard doesn't allow it.  It impacts code by introducing an additional user defined conversion in some cases: if <code>C</code> is a type having a user defined constructor taking an <code>std::string</code>, then it would make:</p>\n<pre><code>C obj = stringA + stringB;\n</code></pre>\n<p>illegal.</p>\n", "LastActivityDate": "2012-03-08T15:31:55.220", "CommentCount": "4", "CreationDate": "2012-03-08T15:31:55.220", "ParentId": "9619659", "Score": "6", "OwnerUserId": "649665"}});