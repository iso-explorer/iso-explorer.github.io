post_cb({"25416912": {"ParentId": "25416651", "CommentCount": "1", "Body": "<p>The linear address of location [i,j] in a 2d matrix is calculated by:</p>\n<pre><code>linear_position = i * (capacity of column 0) + j;\n</code></pre>\n<p>The address is calculated from the linear position by using the size of array type and using the starting address of the array:</p>\n<pre><code>cell_address = &amp;array[0][0] + linear_position * sizeof(array[0][0]);\n</code></pre>\n<p>Plugging in your values into the above equations should give you an indication of the differences in addresses.</p>\n", "OwnerUserId": "225074", "PostTypeId": "2", "Id": "25416912", "Score": "1", "CreationDate": "2014-08-21T01:19:20.053", "LastActivityDate": "2014-08-21T01:19:20.053"}, "25416928": {"ParentId": "25416651", "CommentCount": "0", "Body": "<p>(1)The memory address of all 5*5 elements of arr[5][5] is  &amp;arr[0][0], &amp;arr[0][1] ... &amp; arr[0][4], &amp;arr[1][0], ... &amp;arr[1][4], ... &amp;arr[4][4]. They are all arranged in sequence with the difference of sizeof (int). In your os, sizeof (int) = 4. </p>\n<p>(2) From the perspective of address,\narr+1 = &amp;arr[1][0], arr+2 = &amp;arr[2][0]. They are just different representation. The former is pointer form, the later is array form. </p>\n", "OwnerUserId": "2579005", "PostTypeId": "2", "Id": "25416928", "Score": "1", "CreationDate": "2014-08-21T01:21:36.743", "LastActivityDate": "2014-08-21T01:21:36.743"}, "25416680": {"ParentId": "25416651", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_25416651_25416680_0\">I'm wondering why the difference between each of address is 14(in Hexadecimal) or 20 (in decimal).</p>\n</blockquote>\n<p>Perhaps because on your system the size of <code>int</code> is <code>4</code> and there are <code>5</code> ints in the inner array.</p>\n<p>To get the idea about layout, try the following code:</p>\n<pre><code>int a[5][5];\nint k = 0;\nfor (int i = 0; i &lt; 5; i++)\n    for (int j = 0; j &lt; 5; j++)\n        a[i][j] = ++k;\nint* p = &amp;a[0][0];\nfor (int n = 0; n &lt; 25; n++, p++)\n    printf(\"%d \", *p);\n</code></pre>\n<p>Output is</p>\n<pre><code>1 2 3 4 ... 25\n</code></pre>\n<hr>\n<p>There is a note in the <code>C++</code> standard (in <strong>8.3.4 Arrays [dcl.arrays]</strong>):</p>\n<blockquote>\n<p id=\"so_25416651_25416680_1\">[ Note: It follows from all this that arrays in C++ are stored row-wise (last subscript varies fastest) and that\n  the first subscript in the declaration helps determine the amount of storage consumed by an array but plays\n  no other part in subscript calculations. \u2014end note ]</p>\n</blockquote>\n</hr>", "OwnerUserId": "3246555", "LastEditorUserId": "3246555", "LastEditDate": "2014-08-21T01:06:46.700", "Id": "25416680", "Score": "3", "CreationDate": "2014-08-21T00:48:22.260", "LastActivityDate": "2014-08-21T01:06:46.700"}, "25419063": {"ParentId": "25416651", "CommentCount": "0", "Body": "<p>Array is a collection of similar data elements stored in contiguous memory location.</p>\n<pre><code>int arr[5][5];\n</code></pre>\n<p>In this declaration, it will allocate contiguous memory location for all elements. say starting memory location is 1000.</p>\n<pre><code>array  starting   array elements\n       address\narr[0]--&gt; 1000 --&gt; arr[0][0] arr[0][1] ... arr[0][4]\narr[1]--&gt; 1020 --&gt; arr[1][0] arr[1][1] ... arr[1][4]\narr[2]--&gt; 1040 --&gt; arr[2][0] arr[2][1] ... arr[2][4]\narr[3]--&gt; 1060 --&gt; arr[3][0] arr[3][1] ... arr[3][4]\narr[4]--&gt; 1080 --&gt; arr[4][0] arr[4][1] ... arr[4][4]\n</code></pre>\n<hr>\n<pre><code>I'm wondering why the difference between each of address is 14(in Hexadecimal) or 20 (in decimal).\n</code></pre>\n<p>Each array has 5 integer, <code>sizeof(int)</code> is 4. So for 5 integers it will allocate 20 bytes of memory. Due to this only you are getting the difference between each array address is 20 bytes(in decimal. In hexadecimal it is 14)</p>\n<hr>\n<pre><code>1. Allocate a pointer `arr` on stack.\n</code></pre>\n<p>-No. Allocate a pointer to pointer to a integer (<code>arr</code>) on stack. That is <code>int **arr;</code></p>\n<pre><code>2. The arr pointer holds the address to the starting location of an array of pointers.\n3. That array of pointers contains the starting location of a row in the 2-D array.\n</code></pre>\n<p>Now it is correct! But This is dynamic memory allocation not static!</p>\n</hr></hr>", "OwnerUserId": "3782727", "PostTypeId": "2", "Id": "25419063", "Score": "1", "CreationDate": "2014-08-21T05:49:48.380", "LastActivityDate": "2014-08-21T05:49:48.380"}, "25416651": {"CommentCount": "3", "ViewCount": "482", "PostTypeId": "1", "LastEditorUserId": "3521929", "CreationDate": "2014-08-21T00:44:52.090", "LastActivityDate": "2016-04-01T21:13:40.573", "Title": "2D array pointer arithmetic", "LastEditDate": "2014-08-22T01:28:55.413", "Id": "25416651", "Score": "0", "Body": "<p>Say I have an int array: <code>int arr[5][5]</code> and assume C language memory management. </p>\n<p>I want to access a particular element of the array using only pointer arithmetic and dereferencing. </p>\n<p>Suppose I wanted to access the element in:  <code>arr[i][j]</code></p>\n<p>I tried printing a few things at first to understand how the addresses worked. \nI printed the address of <code>arr</code>, <code>arr+1</code>, and <code>arr+2</code>, and <code>arr+5</code>.</p>\n<p>These were the results:</p>\n<pre><code>0x7fff58475b80\n0x7fff58475b94\n0x7fff58475ba8\n0x7fff58475be4\n</code></pre>\n<p>I'm wondering why the difference between each of address is 14(in Hexadecimal) or 20 (in decimal). </p>\n<p>Also, when you create a 2-D array on the stack, is a pointer to an array of pointers to memory blocks created? This is how I assume we allocate space for the array:</p>\n<ol>\n<li>Allocate a pointer <code>arr</code> on stack.</li>\n<li>The <code>arr</code> pointer holds the address to the starting location of an array of pointers.</li>\n<li>That array of pointers contains the starting location of a row in the 2-D array.</li>\n</ol>\n<p>Is this correct?</p>\n<p>EDIT: Also, assume you wanted to access arr[i][j] through pointer arithmetic. How would this be done? If the array is allocated dynamically, I think you can do *( * (arr+i)+j). I'm not sure how you do this for static allocations? My guess is *(arr + ((row_size * (i))+j)). Is this correct?</p>\n", "Tags": "<c++><c><arrays><pointers>", "OwnerUserId": "3521929", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_25416651_25416680_1": {"section_id": 3236, "quality": 0.8888888888888888, "length": 24}}, "n3337": {"so_25416651_25416680_1": {"section_id": 3109, "quality": 0.8888888888888888, "length": 24}}, "n4659": {"so_25416651_25416680_1": {"section_id": 3992, "quality": 0.8888888888888888, "length": 24}}}});