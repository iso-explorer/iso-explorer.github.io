post_cb({"46961420": {"ParentId": "46960774", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast\" rel=\"nofollow noreferrer\">cppreference</a>:</p>\n<blockquote>\n<p id=\"so_46960774_46961420_0\">Type aliasing</p>\n<p id=\"so_46960774_46961420_1\">Whenever an attempt is made to read or modify the stored value of an\n  object of type DynamicType through a glvalue of type AliasedType, the\n  behavior is undefined unless one of the following is true:</p>\n<ul>\n<li>AliasedType and DynamicType are similar.</li>\n<li>AliasedType is the (possibly cv-qualified) signed or unsigned variant of DynamicType.</li>\n<li>AliasedType is std::byte, (since C++17)char, or unsigned char: this permits examination of the object representation of any object as\n  an array of bytes.</li>\n</ul>\n<p id=\"so_46960774_46961420_2\">Informally, two types are similar if, after stripping away cv-qualifications at\n  every level (but excluding anything inside a function type), they are the same \n  type. </p>\n<p id=\"so_46960774_46961420_3\">For example: [...some examples...]</p>\n</blockquote>\n<p>Also <a href=\"http://en.cppreference.com/w/cpp/language/value_category\" rel=\"nofollow noreferrer\">cppreference</a>:</p>\n<blockquote>\n<p id=\"so_46960774_46961420_4\">a glvalue is an expression whose evaluation determines the identity of\n  an object, bit-field, or function;</p>\n</blockquote>\n<p>The above is relevant for all example except (c). Types are neither similar nor signed/unsigned variants. Also the <code>AliasedType</code> (the type you cast to) is neither of <code>char</code>, <code>unsigned char</code> or <code>std::byte</code>. Hence all of them (but c) exhibit undefined behaviour. </p>\n<p><strong>Disclaimer:</strong> First of all cppreference is not an official reference, but only the standard is. Secondly, unfortunately I am not even 100% certain if my interpretation of what I read on cppreference is correct.</p>\n", "OwnerUserId": "4117728", "LastEditorUserId": "4117728", "LastEditDate": "2017-10-27T09:46:23.187", "Id": "46961420", "Score": "1", "CreationDate": "2017-10-26T18:30:50.057", "LastActivityDate": "2017-10-27T09:46:23.187"}, "46961291": {"ParentId": "46960774", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Even though it's a discussion between the OP and I that spawned this question, I'll still put my interpretation here.</p>\n<p>I believe that all of these save for <code>c()</code> contain strict aliasing violations as formally defined by the standard.</p>\n<p>I base this on section 1.8.1 of the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">standard</a> </p>\n<blockquote>\n<p id=\"so_46960774_46961291_0\">... An object is created by a definition (3.1), by a new-expression (5.3.4)\n  or by the implementation (12.2) when needed. ...</p>\n</blockquote>\n<p><code>reinterpret_cast&lt;&gt;</code>ing memory does not fall under either of these cases.</p>\n", "OwnerUserId": "4442671", "LastEditorUserId": "4442671", "LastEditDate": "2017-10-26T18:30:00.750", "Id": "46961291", "Score": "1", "CreationDate": "2017-10-26T18:22:17.353", "LastActivityDate": "2017-10-26T18:30:00.750"}, "46964755": {"ParentId": "46960774", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Preamble: <em>storage</em> and <em>objects</em> are different concepts in C++. <em>Storage</em> refers to memory space,  and <em>objects</em> are entities with lifetimes, that may be created and destroyed within a piece of storage. Storage may be re-used for hosting multiple objects over time.  All objects require storage, but there can be storage with no objects in it.</p>\n<hr>\n<p><strong>c</strong> is correct. Placement-new is one of the valid methods of creating an object in storage (C++14 [intro.object]/1), even if there were pre-existing objects in that storage. The old objects are implicitly destroyed by the re-use of the storage, and this is perfectly fine so long as they did not have non-trivial destructors ([basic.life]/4). <code>new(a) float;</code> creates an object of type <code>float</code> and dynamic storage duration within the existing storage ([expr.new]/1). </p>\n<p><strong>d</strong> and <strong>e</strong> are undefined by omission in the current object model rules: the effect of accessing memory via a glvalue expression is only defined when that expression refers to an object; and not for when the expression refers to storage containing no objects. (Note: please do not leave non-constructive comments regarding the obvious inadequacy of the existing definitions).</p>\n<p>This does not mean \"malloc is useless\"; the effect of <code>malloc</code> and <code>operator new</code> is to obtain <em>storage</em>. Then you can create objects in the storage and use those objects.  This is in fact exactly how standard allocators, and the <code>new</code> expression, work.</p>\n<p><strong>a</strong> and <strong>b</strong> are strict aliasing violations: a glvalue of type <code>float</code> is used to access objects of incompatible type <code>char</code>. ([basic.lval]/10)</p>\n<hr>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0593r1.html\" rel=\"nofollow noreferrer\">There is a proposal</a> which would make all of the cases well-defined (other than the alignment of <strong>a</strong> mentioned below): under this proposal, using <code>*f</code> implicitly creates an object of that type in the location, with some caveats.</p>\n<hr>\n<p>Note: There is no alignment problem in cases <strong>b</strong> through <strong>e</strong>, because the new-expression and <code>::operator new</code> are guaranteed to allocate storage correctly aligned for any type ([new.delete.single]/1).  </p>\n<p>However, in the case of <code>std::vector&lt;char&gt;</code>, even though the standard specifies that <code>::operator new</code> be called to obtain storage, the standard doesn't require that the first vector element be placed in the first byte of that storage; e.g. the vector could decide to allocate 3 extra bytes on the front and use those for some book-keeping.</p>\n</hr></hr></hr>", "OwnerUserId": "1505939", "LastEditorUserId": "1505939", "LastEditDate": "2017-10-26T23:14:12.173", "Id": "46964755", "Score": "6", "CreationDate": "2017-10-26T22:24:37.650", "LastActivityDate": "2017-10-26T23:14:12.173"}, "bq_ids": {"n4140": {"so_46960774_46961291_0": {"section_id": 5790, "quality": 0.7777777777777778, "length": 7}, "so_46960774_46961420_4": {"section_id": 5808, "quality": 0.5555555555555556, "length": 5}}, "n3337": {"so_46960774_46961291_0": {"section_id": 5563, "quality": 0.7777777777777778, "length": 7}, "so_46960774_46961420_4": {"section_id": 5581, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_46960774_46961420_4": {"section_id": 8741, "quality": 0.8888888888888888, "length": 8}}}, "46960774": {"CommentCount": "11", "AcceptedAnswerId": "46964755", "PostTypeId": "1", "LastEditorUserId": "963864", "CreationDate": "2017-10-26T17:51:12.903", "LastActivityDate": "2017-10-27T09:46:23.187", "LastEditDate": "2017-10-26T21:03:59.610", "ViewCount": "358", "FavoriteCount": "8", "Title": "Is using the result of new char[] or malloc to casted float * is UB (strict aliasing violation)?", "Id": "46960774", "Score": "13", "Body": "<p>Which code of these has UB (specifically, which violates strict aliasing rule)?</p>\n<pre><code>void a() {\n    std::vector&lt;char&gt; v(sizeof(float));\n    float *f = reinterpret_cast&lt;float *&gt;(v.data());\n    *f = 42;\n}\n\nvoid b() {\n    char *a = new char[sizeof(float)];\n    float *f = reinterpret_cast&lt;float *&gt;(a);\n    *f = 42;\n}\n\nvoid c() {\n    char *a = new char[sizeof(float)];\n    float *f = new(a) float;\n    *f = 42;\n}\n\nvoid d() {\n    char *a = (char*)malloc(sizeof(float));\n    float *f = reinterpret_cast&lt;float *&gt;(a);\n    *f = 42;\n}\n\nvoid e() {\n    char *a = (char*)operator new(sizeof(float));\n    float *f = reinterpret_cast&lt;float *&gt;(a);\n    *f = 42;\n}\n</code></pre>\n<p>I ask this, because of <a href=\"https://stackoverflow.com/questions/46960015/efficiently-generating-byte-buffer-without-breaking-strict-aliasing\">this</a> question.</p>\n<p>I think, that <code>d</code> doesn't have UB (or else <code>malloc</code> would be useless in C++). And because of this, it seems logical, that <code>b</code>, <code>c</code> &amp; <code>e</code>  doesn't have it either. Am I wrong somewhere? Maybe <code>b</code> is UB, but <code>c</code> is not?</p>\n", "Tags": "<c++><malloc><language-lawyer><strict-aliasing><object-lifetime>", "OwnerUserId": "8157187", "AnswerCount": "3"}});