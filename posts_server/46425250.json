post_cb({"46426533": {"ParentId": "46425250", "CommentCount": "1", "Body": "<p>According to the letter of the law, size and alignment of types is implementation-defined and the standard gives you few if any guarantees about what <code>sizeof</code> and <code>alignof</code> will return. </p>\n<pre><code>template &lt;typename T, typename P&gt;\nstruct Tagged {\n    T value;\n};\n</code></pre>\n<p><em>In theory</em>, the compiler is permitted to add padding to the end of this struct, which would obviously alter the size and probably the alignment as well. In practise, the only time I could envisage this happening is if <code>T</code> was given some sort of compiler-specific \"packed\" attribute, but <code>Tagged</code> was not (but even then, <a href=\"https://godbolt.org/g/UHE7kh\" rel=\"noreferrer\">GCC seems to work okay</a>).</p>\n<p>In any case, I'd say it would be a good idea to add some static asserts to ensure that the compiler is being sensible -- which is exactly what you've done :).</p>\n", "OwnerUserId": "2797826", "PostTypeId": "2", "Id": "46426533", "Score": "7", "CreationDate": "2017-09-26T12:25:23.057", "LastActivityDate": "2017-09-26T12:25:23.057"}, "46425250": {"CommentCount": "7", "AcceptedAnswerId": "46426307", "PostTypeId": "1", "LastEditorUserId": "2411320", "CreationDate": "2017-09-26T11:27:21.397", "LastActivityDate": "2017-10-10T22:09:08.447", "LastEditDate": "2017-10-10T15:40:20.230", "ViewCount": "420", "FavoriteCount": "5", "Title": "Does a phantom type have the same alignment as the original one?", "Id": "46425250", "Score": "26", "Body": "<p>Consider the following struct that contains some environment values:</p>\n<pre><code>struct environment_values {\n  uint16_t humidity;\n  uint16_t temperature;\n  uint16_t charging;\n};\n</code></pre>\n<p>I would like to add some additional information to those values with a phantom type* and make their types distinct at the same time:</p>\n<pre><code>template &lt;typename T, typename P&gt;\nstruct Tagged {\n    T value;\n};\n\n// Actual implementation will contain some more features\nstruct Celsius{};\nstruct Power{};\nstruct Percent{};\n\nstruct Environment {\n  Tagged&lt;uint16_t,Percent&gt; humidity;\n  Tagged&lt;uint16_t,Celsius&gt; temperature;\n  Tagged&lt;uint16_t,Power&gt;   charging;\n};\n</code></pre>\n<p>Is the memory-layout of <code>Environment</code> the same as <code>environment_values</code>? Does this also hold for mixed type layouts, e.g.:</p>\n<pre><code>struct foo {\n    uint16_t value1;\n    uint8_t  value2;\n    uint64_t value3;\n}\n\nstruct Foo {\n    Tagged&lt;uint16_t, Foo&gt;  Value1;\n    Tagged&lt;uint8_t , Bar&gt;  Value2;\n    Tagged&lt;uint64_t, Quux&gt; Value3;\n}\n</code></pre>\n<p>For all types I've tried so far, the following assertions held:</p>\n<pre><code>template &lt;typename T, typename P = int&gt;\nconstexpr void check() {\n    static_assert(alignof(T) == alignof(Tagged&lt;T,P&gt;), \"alignment differs\");\n    static_assert(sizeof(T)  == sizeof(Tagged&lt;T,P&gt;),  \"size differs\");\n}\n\n// check&lt;uint16_t&gt;(), check&lt;uint32_t&gt;(), check&lt;char&gt;() \u2026\n</code></pre>\n<p>Since the size of the tagged and untagged variants is also the same, I <em>guess</em> the answer should be yes, but I would like to have some certainty.</p>\n<p><sup>* I have no idea how those tagged values are called in C++. \"Strongly typed typedefs\"? I've taken the name from Haskell.</sup></p>\n", "Tags": "<c++><struct><types><language-lawyer><memory-alignment>", "OwnerUserId": "1139697", "AnswerCount": "3"}, "46426307": {"ParentId": "46425250", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The Standard mentions in <a href=\"http://eel.is/c++draft/basic.align\" rel=\"nofollow noreferrer\">[basic.align]/1</a>:</p>\n<blockquote>\n<p id=\"so_46425250_46426307_0\">Object types have alignment requirements (3.9.1, 3.9.2) which place\n  restrictions on the addresses at which an object of that type may be\n  allocated. <strong>An alignment is an implementation-defined integer value</strong>\n  representing the number of bytes between successive addresses at which\n  a given object can be allocated. An object type imposes an alignment\n  requirement on every object of that type; stricter alignment can be\n  requested using the alignment specifier (7.6.2).</p>\n</blockquote>\n<p>Moreover, <a href=\"http://eel.is/c++draft/basic.compound#3\" rel=\"nofollow noreferrer\">[basic.compound]/3</a>, mentions:</p>\n<blockquote>\n<p id=\"so_46425250_46426307_1\">The value representation of pointer types is implementation-defined.\n  Pointers to <strong>layout-compatible types shall have the same value\n  representation and alignment requirements</strong> (6.11). [Note: Pointers to\n  over-aligned types (6.11) have no special representation, but their\n  range of valid values is restricted by the extended alignment\n  requirement].</p>\n</blockquote>\n<p>As a result, there is a guarantee that layout-compatible types have the same alignment.</p>\n<p><code>struct { T m; }</code> and <code>T</code> are not layout-compatible.</p>\n<p>As pointed <a href=\"https://stackoverflow.com/questions/45332326/are-structs-of-variables-of-the-same-type-layout-compatible-with-a-struct-contai/45332881#45332881\">here</a>, in order for two elements to be layout compatible then they both have to be standard-layout types, and their non-static data members must occur with the same types and in the same order.</p>\n<p><code>struct { T m; }</code> contains just a <code>T</code>, but <code>T</code> is a <code>T</code> so it cannot contain a <code>T</code> as its first non-static data member.</p>\n", "OwnerUserId": "2411320", "LastEditorUserId": "2411320", "LastEditDate": "2017-10-10T15:57:41.270", "Id": "46426307", "Score": "10", "CreationDate": "2017-09-26T12:16:20.047", "LastActivityDate": "2017-10-10T15:57:41.270"}, "46671292": {"ParentId": "46425250", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>As mentioned by gsamaras, the standard guarantees the same alignment for <em>layout compatible</em> classes.</p>\n<p>Unfortunately, <code>struct { T m; }</code> and <code>T</code> are not <em>layout compatible</em>.</p>\n<p>In 12.2.21 the standard lays out the requirements for a <em>layout compatible</em> class:</p>\n<blockquote>\n<p id=\"so_46425250_46671292_0\">Two standard-layout struct (Clause 12) types are <em>layout-compatible classes</em> if their <em>common initial sequence</em> comprises all members and bit-fields of both classes (6.9).</p>\n</blockquote>\n<p>And the definition of <em>common initial sequence</em> is in 12.2.20:</p>\n<blockquote>\n<p id=\"so_46425250_46671292_1\">The <em>common initial sequence</em> of two <em>standard-layout</em> struct (Clause 12) types is the longest sequence of non-static data members and bit-fields in declaration order, starting with the first such entity in each of the structs, such that corresponding entities have <em>layout-compatible</em> types and either neither entity is a bit-field or both are bit-fields with the same width. [Example:<br>\n<code>struct A { int a; char b; };</code><br>\n<code>struct B { const int b1; volatile char b2; };</code><br>\n<code>struct C { int c; unsigned : 0; char b; };</code><br>\n<code>struct D { int d; char b : 4; };</code><br>\n<code>struct E { unsigned int e; char b; };</code><br>\n  The <em>common initial sequence</em> of <code>A</code> and <code>B</code> comprises all members of either class. The <em>common initial sequence</em> of <code>A</code> and <code>C</code> and of <code>A</code> and <code>D</code> comprises the first member in each case. The <em>common initial sequence</em> of <code>A</code> and <code>E</code> is empty.<br>\n  \u2014 end example]</br></br></br></br></br></br></br></p>\n</blockquote>\n<p>So from this we can make the following important observations:</p>\n<ol>\n<li>Layout compatibility is limited strictly to standard layout classes. (Or enums use the same underlying type or the trivial case when <code>T</code> and <code>T2</code> are literally the exact same type.  See 6.9.11.) In the general case, <code>T</code> is not a standard layout class.  In fact, <code>T</code> is not even a class in your example (it is a <code>uint16_t</code>, believe it or not, this matters according to the standard.)*</li>\n<li>Even if <code>T</code> is guaranteed to be a standard layout class, <code>struct { T m; }</code> does not have a common initial sequence with <code>T</code>.  The sequence of <code>struct { T m; }</code> begins with <code>T</code>, whereas the sequence of <code>T</code> begins with whatever <code>T</code>'s non-static data members are.  This is actually strictly guaranteed not to be a <code>T</code> as a class cannot contain itself by value.</li>\n</ol>\n<p>Therefore, the guarantee cannot be held by the letter of the standard.  You should continue to perform the <code>static_assert</code>ions to ensure your compiler is behaving in the fashion you expect.</p>\n<p>* See most questions on union type punning.</p>\n", "OwnerUserId": "483486", "LastEditorUserId": "483486", "LastEditDate": "2017-10-10T22:09:08.447", "Id": "46671292", "Score": "3", "CreationDate": "2017-10-10T16:12:11.367", "LastActivityDate": "2017-10-10T22:09:08.447"}, "bq_ids": {"n4140": {"so_46425250_46426307_1": {"section_id": 7223, "quality": 0.8484848484848485, "length": 28}, "so_46425250_46426307_0": {"section_id": 7240, "quality": 0.8636363636363636, "length": 38}}, "n3337": {"so_46425250_46426307_1": {"section_id": 6967, "quality": 0.8484848484848485, "length": 28}, "so_46425250_46426307_0": {"section_id": 6984, "quality": 0.8636363636363636, "length": 38}}, "n4659": {"so_46425250_46671292_0": {"section_id": 7360, "quality": 0.8823529411764706, "length": 15}, "so_46425250_46426307_1": {"section_id": 8732, "quality": 0.8484848484848485, "length": 28}, "so_46425250_46426307_0": {"section_id": 8749, "quality": 0.8409090909090909, "length": 37}, "so_46425250_46671292_1": {"section_id": 7359, "quality": 0.6707317073170732, "length": 55}}}});