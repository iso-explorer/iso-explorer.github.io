post_cb({"46555969": {"ParentId": "46555186", "CommentCount": "0", "Body": "<p>gcc is right. This is exactly <a href=\"http://eel.is/c++draft/temp#deduct.type-18\" rel=\"noreferrer\">[temp.deduct.type]/18</a>:</p>\n<blockquote>\n<p id=\"so_46555186_46555969_0\">If <code>P</code> has a form that contains <code>&lt;i&gt;</code>, and if the type of <code>i</code> differs from the type of the corresponding template parameter of the template named by the enclosing <em>simple-template-id</em>, deduction fails. If <code>P</code> has a form that contains <code>[i]</code>, and if the type of <code>i</code> is not an integral type, deduction fails. <em>[\u2009Example:</em></p>\n<pre><code>template&lt;int i&gt; class A { /* ... */ };\ntemplate&lt;short s&gt; void f(A&lt;s&gt;);\nvoid k1() {\n  A&lt;1&gt; a;\n  f(a);             // error: deduction fails for conversion from int to short\n  f&lt;1&gt;(a);          // OK\n}\n\ntemplate&lt;const short cs&gt; class B { };\ntemplate&lt;short s&gt; void g(B&lt;s&gt;);\nvoid k2() {\n  B&lt;1&gt; b;\n  g(b);             // OK: cv-qualifiers are ignored on template parameter types\n}\n</code></pre>\n<p id=\"so_46555186_46555969_1\"><em>\u2014\u2009end example\u2009]</em></p>\n</blockquote>\n<p>Mirroring the example and simplifying the original question:</p>\n<pre><code>template &lt;class T&gt; struct Wot { };\n\ntemplate &lt;int... ints&gt;\nvoid foo(Wot&lt;std::index_sequence&lt;ints...&gt;&gt; ) { }\n\nint main() {\n    foo(Wot&lt;std::index_sequence&lt;1, 2, 3&gt;&gt;{}); // error\n    foo&lt;1, 2, 3&gt;({}); // ok\n}\n</code></pre>\n<p>I think this is clang bug <a href=\"https://bugs.llvm.org/show_bug.cgi?id=16279\" rel=\"noreferrer\">16279</a></p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "46555969", "Score": "11", "CreationDate": "2017-10-04T02:09:19.847", "LastActivityDate": "2017-10-04T02:09:19.847"}, "46555186": {"CommentCount": "0", "ViewCount": "199", "PostTypeId": "1", "LastEditorUserId": "5501675", "CreationDate": "2017-10-04T00:07:11.857", "LastActivityDate": "2017-10-04T02:09:19.847", "Title": "Partial template specialization with mismatching `int` and `size_t` not compiling", "AcceptedAnswerId": "46555969", "LastEditDate": "2017-10-04T00:21:23.457", "Id": "46555186", "Score": "9", "Body": "<p>With reference to the following code </p>\n<pre><code>#include &lt;utility&gt;\n#include &lt;cassert&gt;\n\ntemplate &lt;typename T&gt;\nstruct Wot;\ntemplate &lt;int... ints&gt;\nstruct Wot&lt;std::index_sequence&lt;ints...&gt;&gt; {};\n\nint main() {\n    assert(sizeof(Wot&lt;std::index_sequence&lt;1, 2, 3&gt;&gt;) == 1);\n}\n</code></pre>\n<p>This works on clang but does not work on gcc, when I change the type of the partial specialization to accept <code>std::size_t</code> in the index sequence however it works.  </p>\n<p>Who is right?  Clang or gcc?  </p>\n<hr>\n<p>See this in action here <a href=\"https://wandbox.org/permlink/5YkuimK1pH3aKJT4\" rel=\"noreferrer\">https://wandbox.org/permlink/5YkuimK1pH3aKJT4</a></p>\n</hr>", "Tags": "<c++><templates><c++14><language-lawyer><partial-specialization>", "OwnerUserId": "5501675", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_46555186_46555969_0": {"section_id": 348, "quality": 0.6363636363636364, "length": 14}}, "n3337": {"so_46555186_46555969_0": {"section_id": 331, "quality": 0.5454545454545454, "length": 12}}, "n4659": {"so_46555186_46555969_0": {"section_id": 358, "quality": 0.9545454545454546, "length": 21}}}});