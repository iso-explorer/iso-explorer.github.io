post_cb({"16127941": {"Id": "16127941", "PostTypeId": "2", "Body": "<p>Trying to answer your questions:</p>\n<ol>\n<li><p>Different compilers across vendors and versions generate different diagnostics.  You cannot rely on exact messages from one to another.</p></li>\n<li><p>\"injected class name\" is defined in the standard under \u00a79, paragraph 2:</p></li>\n</ol>\n<blockquote>\n<p id=\"so_16127770_16127941_0\">A class-name is inserted into the scope in which it is declared\n  immediately after the class-name is seen. The class-name is also\n  inserted into the scope of the class itself; this is known as the\n  injected-class-name. For purposes of access checking, the\n  injected-class-name is treated as if it were a public member name. A\n  class-specifier is commonly referred to as a class definition. A class\n  is considered defined after the closing brace of its class-specifier\n  has been seen even though its member functions are in general not yet\n  defined. The optional attribute-specifier-seq appertains to the class;\n  the attributes in the attribute-specifier-seq are thereafter\n  considered attributes of the class whenever it is named.</p>\n</blockquote>\n<ol>\n<li>The reason <code>C* a</code> is the same as <code>C&lt;T&gt;* a</code> is due to context: both occur within the declaration of <code>C</code>. C++ allows a \"shortcut\" in that a templated class can be refer it's own instantiation without the template arguments within a context in which the arguments can be assumed (this is one of them). If you wanted to refer to an instantiation of <code>C</code> with different template arguments, you would need to be explicit about it.</li>\n</ol>\n<p>The reason you're getting your particular error is that <code>C&lt;void&gt;</code> is an incomplete type at the time at which you're trying to instantiate a <code>C</code> with different template arguments.</p>\n<p>What I find really odd, looking at the code, is that I think it should compile cleanly because you're never actually instantiating either template, so type completeness of <code>C</code> shouldn't matter.</p>\n", "LastActivityDate": "2013-04-21T04:21:10.040", "CommentCount": "1", "CreationDate": "2013-04-21T04:21:10.040", "ParentId": "16127770", "Score": "1", "OwnerUserId": "311314"}, "16127894": {"Id": "16127894", "PostTypeId": "2", "Body": "<p>I think the book forgot <code>*</code> there</p>\n<pre><code>C&lt;void&gt; *b;\n</code></pre>\n<p>Otherwise the declaration is not valid even with out templates. Because C is not completely declared yet when the compiler reaches that line. It is the same as trying to use a forward declare class.</p>\n<p>For example this is not valid.</p>\n<pre><code>class A {\n    A a;\n    ^// A has incomplete type here\n};\n</code></pre>\n<p>However this is valid.</p>\n<pre><code>class A {\n    A *a;\n};\n</code></pre>\n<hr>\n<p>Injected class name is when the template argument of a class is injected <strong>with in the class's own scope</strong> to its uses.</p>\n<pre><code>tempalte&lt;typename T&gt;\nclass C {\n    C* a;  // same as C&lt;T&gt;* a;\n};\n</code></pre>\n<p>I think the book explains it completely.</p>\n<hr>\n<blockquote>\n<p id=\"so_16127770_16127894_0\">so is <code>C* a</code> a shorthand for <code>C&lt;T&gt;* a</code>?</p>\n</blockquote>\n<p>Only within the class's own scope. (including member definition scopes) e.g.</p>\n<pre><code>template &lt;typename T&gt;\nvoid C&lt;T&gt;::f() {\n    C a;            // Same as C&lt;T&gt; a;\n}\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_16127770_16127894_1\">Why the compiler generates totally different error messages? the book\n  says b is OK, but gcc gave the error; meanwhile, other errors listed\n  in the book are not detected? Why, is this a possible compiler bug or\n  error in book?</p>\n</blockquote>\n<p>Apart from the things explained above, the reason can be that the book is relatively old and compilers have changed since then. You can't expect error messages to be exactly the same.</p>\n</hr></hr></hr>", "LastEditorUserId": "6271971", "LastActivityDate": "2013-04-21T04:29:37.813", "Score": "0", "CreationDate": "2013-04-21T04:11:20.113", "ParentId": "16127770", "CommentCount": "0", "OwnerUserId": "6271971", "LastEditDate": "2013-04-21T04:29:37.813"}, "16128324": {"Id": "16128324", "PostTypeId": "2", "Body": "<p>Note: An <em>injected-class-name</em> is just the identifier used to declare the class (as opposed to other names which also refer to the same class, such as typedef names).</p>\n<p>Here's the relevant quote from the C++11 Standard, section 14.6.1p1:</p>\n<blockquote>\n<p id=\"so_16127770_16128324_0\">Like normal (non-template) classes, class templates have an injected-class-name (Clause 9). The injected-class-name can be used as a <em>template-name</em> or a <em>type-name</em>. <strong>When it is used</strong> with a <em>template-argument-list</em>, <strong>as a <em>template-argument</em> for a template <em>template-parameter</em></strong>, or as the final identifier in the <em>elaborated-type-specifier</em> of a friend class template declaration, <strong>it refers to the class template itself</strong>. Otherwise, it is equivalent to the <em>template-name</em> followed by the <em>template-parameters</em> of the class template enclosed in <code>&lt;&gt;</code>.</p>\n</blockquote>\n<p>So clearly this is legal in C++11.</p>\n<p>However, the book correctly describes the behavior of C++03:</p>\n<blockquote>\n<p id=\"so_16127770_16128324_1\">Like normal (non-template) classes, class templates have an injected-class-name (clause 9).  The injected-class-name  can  be  used  with  or  without  a <em>template-argument-list</em>.  <strong>When  it  is  used  without a <em>template-argument-list</em>, it is equivalent to the injected-class-name followed by the <em>template-parameters</em> of the class template  enclosed  in <code>&lt;&gt;</code>.</strong>  When  it  is  used  with  a <em>template-argument-list</em>,  it  refers to the specified class template specialization, which could be the current specialization or another specialization.</p>\n</blockquote>\n<p>Aside from reversing the logic, we see that C++03 contained one case where the identifier referred to the template (when template arguments were provided) and C++11 adds two additional cases, one of which affects this code.</p>\n<p>So in C++03, the code was equivalent to <code>X&lt;C&lt;T&gt;&gt; c;</code>, which is an error because <code>X</code> needs to be passed a template and not a type.</p>\n<p>Bottom line: For learning about the language, templates especially, you need <a href=\"http://tinyurl.com/so-cxxbooks\" rel=\"nofollow\">a book on C++11</a>.  Older books remain useful with respect to architecture and high level design, but can't explain language intricacies which changed after they were published.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2013-04-21T05:55:43.417", "Score": "2", "CreationDate": "2013-04-21T05:43:48.170", "ParentId": "16127770", "CommentCount": "0", "OwnerUserId": "103167", "LastEditDate": "2013-04-21T05:55:43.417"}, "16127770": {"ViewCount": "360", "Body": "<p>Recently, I was reading the book: <code>C++ templates: the complete guide</code> written by David Vandevoorde and Nicolai M. Josuttis.</p>\n<p>Specifically about template parsing quoting from the book pp 126.</p>\n<blockquote>\n<p id=\"so_16127770_16127770_0\">Class templates also have injected class names, However, they are stranger than ordinary injected class names: They can be followed by template arguments (in which case they are injected class template names ), but if they are not followed by template arguments they represent the class with its parameters as its arguments (or, for a partial specialization, its specialization arguments).</p>\n</blockquote>\n<p>The relevant codes are excepted from the book as follows:</p>\n<pre><code>template&lt;template&lt;typename&gt; class TT&gt; \nclass X\n{\n};\n\ntemplate &lt;typename T&gt;\nclass C\n{\n  C* a; //OK, same as \"C&lt;T&gt;* a\"\n  C&lt;void&gt; b; // OK\n  X&lt;C&gt; c;  //Error, C without a template argument list does not denote a template\n  X&lt; ::C&gt;d; \n};\n\nint main()\n{  \n   return 0;\n}\n</code></pre>\n<p>The above code example tries to explain the whole quoted paragraph.</p>\n<p>I compiled the above code in gcc 4.5.3, it outputs:</p>\n<pre><code>error: field \u2018b\u2019 has incomplete type\n</code></pre>\n<p>Therefore, I have the following questions:</p>\n<ol>\n<li>Why the compiler generates totally different error messages? the book says <code>b</code> is OK, but gcc gave the error; meanwhile, other errors listed in the book are not detected? Why, is this a possible compiler bug or error in book?</li>\n<li>What does <code>injected class names</code> mean? How can I identify what names are <code>injected class names</code> and what are not?</li>\n<li>why <code>C*a</code> is the same as <code>C&lt;T&gt;* a</code>? I tried to replace <code>C*a</code> with <code>C&lt;T&gt;* a</code>, no error is reported, so is <code>C* a</code> a shorthand for <code>C&lt;T&gt;* a</code>?</li>\n</ol>\n<p>Thanks a lot!</p>\n", "AcceptedAnswerId": "16128324", "Title": "gcc compiler does not show correct errors with class templates injected names", "CreationDate": "2013-04-21T03:48:42.620", "Id": "16127770", "CommentCount": "5", "LastEditDate": "2013-04-21T04:00:31.700", "PostTypeId": "1", "LastEditorUserId": "1760345", "LastActivityDate": "2013-04-21T05:55:43.417", "Score": "3", "OwnerUserId": "1760345", "Tags": "<c++><templates><name-lookup>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_16127770_16127941_0": {"length": 60, "quality": 0.9523809523809523, "section_id": 5846}, "so_16127770_16128324_1": {"length": 18, "quality": 0.5294117647058824, "section_id": 179}, "so_16127770_16128324_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 179}}, "n3337": {"so_16127770_16127941_0": {"length": 60, "quality": 0.9523809523809523, "section_id": 5616}, "so_16127770_16128324_1": {"length": 18, "quality": 0.5294117647058824, "section_id": 173}, "so_16127770_16128324_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 173}}, "n4659": {"so_16127770_16127941_0": {"length": 60, "quality": 0.9523809523809523, "section_id": 7325}, "so_16127770_16128324_1": {"length": 18, "quality": 0.5294117647058824, "section_id": 184}, "so_16127770_16128324_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 184}}}});