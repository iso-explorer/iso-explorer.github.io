post_cb({"bq_ids": {"n4140": {"so_31391172_31391456_1": {"length": 4, "quality": 1.0, "section_id": 603}, "so_31391172_31391456_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 603}, "so_31391172_31391456_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 603}, "so_31391172_31391456_3": {"length": 6, "quality": 1.0, "section_id": 147}, "so_31391172_31391456_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 603}}, "n3337": {"so_31391172_31391456_1": {"length": 4, "quality": 1.0, "section_id": 593}, "so_31391172_31391456_2": {"length": 6, "quality": 0.5454545454545454, "section_id": 2}, "so_31391172_31391456_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 593}, "so_31391172_31391456_3": {"length": 6, "quality": 1.0, "section_id": 141}, "so_31391172_31391456_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 593}}, "n4659": {"so_31391172_31391456_1": {"length": 4, "quality": 1.0, "section_id": 629}, "so_31391172_31391456_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 629}, "so_31391172_31391456_0": {"length": 22, "quality": 0.8461538461538461, "section_id": 629}, "so_31391172_31391456_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 629}, "so_31391172_31391456_3": {"length": 6, "quality": 1.0, "section_id": 151}}}, "31391456": {"Id": "31391456", "PostTypeId": "2", "Body": "<p>Once we get our candidate functions set (both <code>bar</code>s), and then whittle it down to the viable functions (still both <code>bar</code>s) we have to determine the <em>best</em> viable function. If there is more than one, we get an ambiguity error. The steps we take to determine the best one are laid out in [over.match.best]:</p>\n<blockquote>\n<p id=\"so_31391172_31391456_0\">[A] viable function F1 is defined to be a better function than another viable function F2 if for all arguments <em>i</em>, ICS<sub>i</sub>(F1) is not a worse conversion sequence than ICS<sub>i</sub>(F2), and then<br>\n  \u2014 for some argument <em>j</em>, ICS<sub>j</sub>(F1) is a better conversion sequence than ICS<sub>j</sub>(F2), or, if not that,</br></p>\n</blockquote>\n<p>Both functions take an argument of type <code>int</code>, so both conversion sequences are identical. We continue.</p>\n<blockquote>\n<p id=\"so_31391172_31391456_1\">\u2014 the context is an initialization by user-defined conversion [...]</p>\n</blockquote>\n<p>Does not apply.</p>\n<blockquote>\n<p id=\"so_31391172_31391456_2\">\u2014 the context is an initialization by conversion function for direct reference binding (13.3.1.6) of a reference to function type, [...]</p>\n</blockquote>\n<p>Does not apply.</p>\n<blockquote>\n<p id=\"so_31391172_31391456_3\">\u2014 F1 is not a function template specialization and F2 is a function template specialization, or, if not that,</p>\n</blockquote>\n<p>Both <code>bar&lt;int&gt;</code>s are function template specializations. So we move onto the very last bullet point to to determine the best viable function. </p>\n<blockquote>\n<p id=\"so_31391172_31391456_4\">\u2014 F1 and F2 are function template specializations, and the function template for F1 is more specialized\n  than the template for F2 according to the partial ordering rules described in 14.5.6.2.</p>\n</blockquote>\n<p>The partial ordering rules basically boil down to us synthesizing new unique types for the arguments of both <code>bar</code> overloads and performing template deduction on the other overload. </p>\n<p>Consider the \"b\" overload first. Synthesize a type <code>typename identity&lt;Unique1&gt;::type</code> and attempt to perform template deduction against <code>T</code>. That succeeds. Simplest cast of template deduction there is.</p>\n<p>Next, consider the \"a\" overload. Synthesize a type <code>Unique2</code> and attempt to perform template deduction against <code>typename identity&lt;T&gt;::type</code>. This <em>fails</em>! This is a non-deduced context - no deduction can succeed. </p>\n<p>Since template type deduction only succeeds in a single direction, the <code>bar(typename identity&lt;T&gt;::type)</code> overload is considered more specialized, and is chosen as the best viable candidate. </p>\n<hr>\n<p><a href=\"https://stackoverflow.com/questions/31391172/this-case-of-template-function-overloading-eludes-my-understanding/31391456#comment50762761_31391456\">bogdan</a> presents another interesting case for looking at partial ordering. Consider instead comparing:</p>\n<pre><code>template &lt;typename T&gt; void bar(T, T); // \"c\"\ntemplate &lt;typename T&gt; void bar(T, typename identity&lt;T&gt;::type ); // \"d\"\n\nbar(5,5);\nbar&lt;int&gt;(5, 5);\n</code></pre>\n<p>Again, both candidates are viable (this time even without explicitly specifying <code>T</code>) so we look at the partial ordering rule. </p>\n<p>For the \"c\" overload, we synthesize arguments of type <code>UniqueC, UniqueC</code> and attempt to perform deduction against <code>T, typename identity&lt;T&gt;::type</code>. This succeeds (with <code>T == UniqueC</code>). So \"c\" is at least as specialized as \"d\".</p>\n<p>For the \"d\" overload, we synthesize arguments of type <code>UniqueD, typename identity&lt;UniqueD&gt;::type</code> and attempt to perform deduction against <code>T, T</code>. This fails! The arguments are of different types! So \"d\" is not at least as specialized as \"c\". </p>\n<p>Thus, the \"c\" overload is called. </p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-13T21:44:55.280", "Score": "17", "CreationDate": "2015-07-13T19:06:55.870", "ParentId": "31391172", "CommentCount": "6", "OwnerUserId": "2069064", "LastEditDate": "2017-05-23T12:00:02.090"}, "31391172": {"ViewCount": "412", "Body": "<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nstruct identity\n{\n    typedef T type;\n};\n\ntemplate&lt;typename T&gt; void bar(T) { std::cout &lt;&lt; \"a\" &lt;&lt; std::endl; }\ntemplate&lt;typename T&gt; void bar(typename identity&lt;T&gt;::type) { std::cout &lt;&lt; \"b\" &lt;&lt; std::endl; }\n\nint main ()\n{\n    bar(5); // prints \"a\" because of template deduction rules\n    bar&lt;int&gt;(5); // prints \"b\" because of ...?\n\n    return EXIT_SUCCESS;\n}\n</code></pre>\n<p>I expected <code>bar&lt;int&gt;(5)</code> to result in an ambiguity, at the very least. What crazy rule about template function overload resolution is involved here?</p>\n", "AcceptedAnswerId": "31391456", "Title": "This case of template function overloading eludes my understanding", "CreationDate": "2015-07-13T18:50:13.047", "Id": "31391172", "CommentCount": "3", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2015-07-13T19:07:58.963", "LastEditorUserId": "2069064", "LastActivityDate": "2015-07-13T21:44:55.280", "Score": "30", "OwnerUserId": "671092", "Tags": "<c++><templates><language-lawyer><overload-resolution>", "AnswerCount": "1"}});