post_cb({"33275718": {"CommentCount": "4", "ViewCount": "183", "PostTypeId": "1", "LastEditorUserId": "2037439", "CreationDate": "2015-10-22T07:42:57.543", "LastActivityDate": "2016-01-04T02:31:29.207", "Title": "Regarding differences between how MSVC and g++ treat C++ template code", "LastEditDate": "2015-10-22T08:55:46.723", "Id": "33275718", "Score": "1", "Body": "<p>I stumbled across this piece of code from ACCU (<a href=\"http://accu.org/index.php/journals/1916\" rel=\"nofollow\">http://accu.org/index.php/journals/1916</a>) and is interested in applying AOP in C++ by using CRTP for a fun project. The code given by the author is as follows:</p>\n<pre><code>namespace aop\n{\n\ntemplate &lt;class A&gt;\nclass NullAspect\n{};\n\ntemplate &lt;template &lt;template &lt;class&gt; class&gt; class Base&gt;\nstruct Decorate\n{\nprivate:\n    struct None {};\n\n    template &lt;template &lt;class&gt; class ... Aspects&gt;\n    struct Apply;\n\n    template &lt;template &lt;class&gt; class T&gt;\n    struct Apply&lt;T&gt;\n    {\n        template &lt;class E&gt;\n        using Type = T&lt;E&gt;;\n    };\n\n    template&lt;template &lt; class &gt; class A1, template &lt; class &gt; class ... Aspects&gt;\n    struct Apply&lt;A1, Aspects...&gt;\n    {\n        template &lt;class T&gt;\n        using Type = A1&lt;typename Apply&lt;Aspects...&gt;::template Type&lt;T&gt;&gt;; // the errors point to this line and the 'Type' refers to the 'template Type&lt;T&gt;'\n    };\n\npublic:\n    template&lt;template &lt;class&gt; class ... Aspects&gt;\n    struct with\n    {\n        template &lt;class T&gt;\n        using AspectsCombination = typename Apply&lt;Aspects...&gt;::template Type&lt;T&gt;;\n\n        typedef AspectsCombination&lt;Base&lt;AspectsCombination&gt;&gt; Type;\n    };\n};\n}\n</code></pre>\n<p>I tried compiling it in Microsoft VS2015 and it gave me the following set of errors:</p>\n<pre><code>Error   C2146   syntax error: missing '&gt;' before identifier 'Type'  \nError   C2947   expecting '&gt;' to terminate template-argument-list, found '&lt;'    \nError   C2061   syntax error: identifier 'T'    \nError   C2238   unexpected token(s) preceding ';'   \nError   C1201   unable to continue after syntax error in class template definition  \nError   C2143   syntax error: missing ';' before '}'    \nError   C2238   unexpected token(s) preceding ';'   \n</code></pre>\n<p>I took the same code, checked the syntax and compiled it in g++ and it compiled fine. Are there any discrepancy between the 2 compilers that I should be aware of? What is the issue here that makes cl.exe generate these errors? Are they due to the fact that how cl.exe parse any template based code? What changes are needed to get this code to work on msvc?</p>\n<p>Edit:</p>\n<p>Here's the complete code for test.cpp as provided by the author to help you guys get a clearer picture:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n#include \"aop.h\"\n\n//#define INHERITING_CTORS  as of g++ 6.4.3, inheriting ctors was not implemented\n\ntemplate &lt;typename _UnderlyingType&gt;\nstruct Number\n{\n    template &lt;template &lt;class&gt; class A = aop::NullAspect&gt;\n    class Type\n    {\n    public:\n        typedef _UnderlyingType UnderlyingType;\n        typedef A&lt;Number::Type&lt;A&gt;&gt; FullType;\n\n        Type(UnderlyingType n)\n            : n(n)\n        {}\n\n        friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Type&amp; number)\n        {\n            return out &lt;&lt; number.n;\n        }\n    protected:\n        UnderlyingType n;\n    };\n};\n\ntemplate &lt;class A&gt;\nclass ArithmeticAspect: public A\n{\npublic:\n    typedef typename A::FullType FullType;\n\n#ifdef INHERITING_CTORS\n    using A::A;\n#else\n    ArithmeticAspect(typename A::UnderlyingType n)\n        : A(n)\n    {}\n\n    ArithmeticAspect(const A&amp; a)\n        : A(a)\n    {}\n#endif\n\n    FullType operator+(const FullType&amp; other) const\n    {\n        FullType tmp(*this);\n        return tmp += other;\n    }\n\n    FullType operator-(const FullType&amp; other) const\n    {\n        FullType tmp(*this);\n        return tmp -= other;\n    }\n\n    FullType operator+=(const FullType&amp; other)\n    {\n        A::n += other.n;\n        return A::n;\n    }\n\n    FullType operator-=(const FullType&amp; other)\n    {\n        A::n -= other.n;\n        return A::n;\n    }\n\n    // same for *, *=, /, /=\n};\n\ntemplate &lt;class A&gt;\nclass IncrementalAspect: public A\n{\npublic:\n    typedef typename A::FullType FullType;\n\n#ifdef INHERITING_CTORS\n    using A::A;\n#else\n    IncrementalAspect(typename A::UnderlyingType n)\n        : A(n)\n    {}\n\n    IncrementalAspect(const A&amp; a)\n        : A(a)\n    {}\n#endif\n\n    FullType operator++(int)\n    {\n        FullType tmp(*this);\n        operator++();\n        return tmp;\n    }\n\n    FullType operator++()\n    {\n        ++A::n;\n        return *this;\n    }\n\n    FullType operator--(int)\n    {\n        FullType tmp(*this);\n        operator--();\n        return tmp;\n    }\n\n    FullType operator--()\n    {\n        --A::n;\n        return *this;\n    }\n};\n\n/*\n* Configurable Aspect sumExample\n*/\ntemplate &lt;unsigned int PRECISION&gt;\nstruct RoundAspect\n{\n    template &lt;class A&gt;\n    class Type : public A\n    {\n    public:\n        typedef typename A::FullType FullType;\n\n#ifdef INHERITING_CTORS\n        using A::A;\n#else\n        Type(typename A::UnderlyingType n)\n            : A(n)\n        {}\n\n        Type(const A&amp; a)\n            : A(a)\n        {}\n#endif\n\n        FullType operator+(const FullType&amp; other) const\n        {\n            return FullType(round(A::operator+(other).n));\n        }\n\n    private:\n        static float round(float f)\n        {\n            const unsigned int e = std::pow(10, PRECISION);\n            return float(int(f * e)) / e;\n        }\n    };\n};\n\ntemplate &lt;class A&gt;\nclass LogicalAspect: public A\n{\npublic:\n    typedef typename A::FullType FullType;\n\n#ifdef INHERITING_CTORS\n    using A::A;\n#else\n    LogicalAspect(typename A::UnderlyingType n)\n        : A(n)\n    {}\n\n    LogicalAspect(const A&amp; a)\n        : A(a)\n    {}\n#endif\n\n    bool operator!() const\n    {\n        return !A::n;\n    }\n\n    bool operator&amp;&amp;(const FullType&amp; other) const\n    {\n        return A::n &amp;&amp; other.n;\n    }\n\n    bool operator||(const FullType&amp; other) const\n    {\n        return A::n || other.n;\n    }\n};\n\ntemplate &lt;class A&gt;\nclass BitwiseAspect: public A\n{\npublic:\n    typedef typename A::FullType FullType;\n\n#ifdef INHERITING_CTORS\n    using A::A;\n#else\n    BitwiseAspect(typename A::UnderlyingType n)\n        : A(n)\n    {}\n\n    BitwiseAspect(const A&amp; a)\n        : A(a)\n    {}\n#endif\n\n    bool operator~() const\n    {\n        return ~A::n;\n    }\n\n    FullType operator&amp;(const FullType&amp; mask) const\n    {\n        return A::n &amp; mask.n;\n    }\n\n    FullType operator|(const FullType&amp; mask) const\n    {\n        return A::n | mask.n;\n    }\n\n    FullType operator&lt;&lt;(const FullType&amp; bitcount) const\n    {\n        return A::n &lt;&lt; bitcount.n;\n    }\n\n    FullType operator&gt;&gt;(const FullType&amp; bitcount) const\n    {\n        return A::n &gt;&gt; bitcount.n;\n    }\n\n    FullType&amp; operator&gt;&gt;=(const FullType&amp; bitcount)\n    {\n        A::n &gt;&gt;= bitcount.n;\n        return *static_cast&lt;FullType*&gt;(this);\n    }\n};\n\ntemplate &lt;class N&gt;\nvoid sumExample(typename N::UnderlyingType n1, typename N::UnderlyingType n2)\n{\n    N a(n1);\n    N b(n2);\n    N c = a + b;\n    std::cout &lt;&lt; c &lt;&lt; std::endl;\n}\n\ntemplate &lt;class N&gt;\nvoid orExample(typename N::UnderlyingType n1, typename N::UnderlyingType n2)\n{\n    N a(n1);\n    N b(n2);\n    std::cout &lt;&lt; (a || b) &lt;&lt; std::endl;\n}\n\ntemplate &lt;class N&gt;\nvoid bitwiseExample(typename N::UnderlyingType n1, typename N::UnderlyingType n2)\n{\n    N a(n1);\n    N b(n2);\n    std::cout &lt;&lt; (a + ((b &gt;&gt;= 1) &lt;&lt; 3)) &lt;&lt; std::endl;\n}\n\nint main()\n{\n\n    typedef aop::Decorate&lt;Number&lt;unsigned int&gt;::Type&gt;::with&lt;ArithmeticAspect, IncrementalAspect, LogicalAspect, BitwiseAspect&gt;::Type IntegralNumber;\n    bitwiseExample&lt;IntegralNumber&gt;(1, 2);\n    sumExample&lt;IntegralNumber&gt;(1, 2);\n\n    typedef aop::Decorate&lt;Number&lt;float&gt;::Type&gt;::with&lt;RoundAspect&lt;2&gt;::Type, ArithmeticAspect, LogicalAspect&gt;::Type FloatRoundLogicalNumber;\n    orExample&lt;FloatRoundLogicalNumber&gt;(1, 0);\n\n    typedef aop::Decorate&lt;Number&lt;int&gt;::Type&gt;::with&lt;LogicalAspect&gt;::Type IntLogicalNumber;\n    orExample&lt;IntLogicalNumber&gt;(1, 0);\n\n    typedef aop::Decorate&lt;Number&lt;float&gt;::Type&gt;::with&lt;RoundAspect&lt;2&gt;::Type, ArithmeticAspect&gt;::Type FloatRoundNumber;\n    sumExample&lt;FloatRoundNumber&gt;(1.339, 1.1233);\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><templates><c++11><variadic-templates>", "OwnerUserId": "2037439", "AnswerCount": "2"}, "33277159": {"ParentId": "33275718", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-10-22T09:01:23.727", "Score": "3", "LastEditorUserId": "3545273", "LastEditDate": "2015-10-22T09:35:03.717", "Id": "33277159", "OwnerUserId": "3545273", "Body": "<p>IMHO it is the  <code>&gt;&gt;</code> syndrom on templated templates. Before C++11, a space was required to have to separate <code>&gt;</code> token and not one <code>&gt;&gt;</code> token.</p>\n<p>Starting from C++ 11 n4296 draft says in 14.2 Names of template specializations [temp.names] \u00a73:</p>\n<blockquote>\n<p id=\"so_33275718_33277159_0\">... Similarly, the first non-nested &gt;&gt; is treated as two consecutive but\n  distinct &gt; tokens, the first of which is taken as the end of the template-argument-list and completes the\n  template-id.</p>\n</blockquote>\n<p>It looks like MSVC2015 has not still implemented that part of standard (or you may have forgotten to declare the C++ version of the source*)</p>\n<p>For sake of completeness, when compiling with CLang 3.4.1 without specifying <code>std=c++11</code> it show this error:</p>\n<blockquote id=\"so_33275718_33277159_1\">\n<pre><code>error: a space is required between consecutive right angle brackets (use '&gt; &gt;')\n    using Type = A1&lt;typename Apply&lt;Aspects...&gt;::template Type&lt;T&gt;&gt;; // the er...\n</code></pre>\n</blockquote>\n<p>and hopefully not even a warning in C++11 mode...</p>\n<p>(*) unfortunately, I have no access to a VS2015, by Microsoft declares int their <a href=\"http://blogs.msdn.com/b/vcblog/archive/2015/06/19/c-11-14-17-features-in-vs-2015-rtm.aspx\" rel=\"nofollow\">C++11/14/17 Features</a> page that <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1757.html\" rel=\"nofollow\">Right angle brackets</a> is implemented by VS2013 and 2015. So I assume there should be somewhere in the project properties a <em>code level</em> indication.</p>\n", "LastActivityDate": "2015-10-22T09:35:03.717"}, "34583901": {"ParentId": "33275718", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-01-04T02:23:43.997", "Score": "0", "LastEditorUserId": "2037439", "LastEditDate": "2016-01-04T02:31:29.207", "Id": "34583901", "OwnerUserId": "2037439", "Body": "<p>So after fiddling around and reading whatever I can, I finally sent the original author an email. So all credit goes to him, Mr. Hugo Arregui.</p>\n<p>With respect to the line that cl is complaining, the fix is the following:</p>\n<pre><code>template &lt; template &lt;class&gt; class A1, template &lt;class&gt; class A2, template &lt;class&gt; class... Aspects&gt;\nstruct Apply&lt;A1,A2,Aspects...&gt;\n{\n    template&lt;class T&gt;\n    using Type = A1&lt; typename Apply&lt;A2, Aspects...&gt;::template Type&lt;T&gt; &gt;;\n};\n</code></pre>\n<p>It would be great if anyone knows why Microsoft's compiler requires us to expand at least 2 template class in the template argument and give an explanation here. Was talking to the author this and he was surprised as well.</p>\n", "LastActivityDate": "2016-01-04T02:31:29.207"}, "bq_ids": {"n4140": {"so_33275718_33277159_0": {"section_id": 71, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_33275718_33277159_0": {"section_id": 66, "quality": 0.8666666666666667, "length": 13}}, "n4659": {"so_33275718_33277159_0": {"section_id": 73, "quality": 1.0, "length": 15}}}});