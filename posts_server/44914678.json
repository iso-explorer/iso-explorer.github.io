post_cb({"44914988": {"ParentId": "44914678", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Let us first check the rule that allows empty base class optimization to acquaint ourselves with the terminology:</p>\n<blockquote>\n<p id=\"so_44914678_44914988_0\">N4659 standard draft [intro.object]</p>\n<p id=\"so_44914678_44914988_1\">7 Unless it is a bit-field (12.2.4), a most derived object shall have a nonzero size and shall occupy one or more\n  bytes of storage. Base class subobjects may have zero size. [snip]</p>\n</blockquote>\n<p>Then a requirement about distinct addresses:</p>\n<blockquote>\n<p id=\"so_44914678_44914988_2\">8 Unless an object is a bit-field or a base class subobject of zero size, the address of that object is the address\n  of the first byte it occupies. Two objects a and b with overlapping lifetimes that are not bit-fields may have\n  the same address if one is nested within the other, or if at least one is a base class subobject of zero size <strong>and\n  they are of different types</strong>; otherwise, they have distinct addresses.</p>\n</blockquote>\n<p>The empty base subobject and the first element of the member array may not have the same address because they are of same type.</p>\n<p>Therefore, if we assume that the base subobject must be ordered before the members and that the members must be in declaration order, padding is required to achieve distinct addresses. However, I cannot find a rule in the standard that would require such order.</p>\n<p>The portable <em>Itanium</em> C++ ABI (used by Clang and GCC) does specify the order, and under that specification, padding is indeed required:</p>\n<blockquote>\n<p id=\"so_44914678_44914988_3\">2.4 Non-POD Class Types</p>\n<p id=\"so_44914678_44914988_4\">II. Allocation of Members Other Than Virtual Bases</p>\n<p id=\"so_44914678_44914988_5\">For each data component D (first the primary base of C, if any, then the non-primary, non-virtual direct base classes in declaration order, then the non-static data members and unnamed bitfields in declaration order), allocate as follows:</p>\n</blockquote>\n<p>A different ABI might be able to exploit EBCO here, if it allows non-declaration order sub-objects or member subobjects before bases in the memory layout. At least as a special case with empty bases. I don't know if such ABI exist.</p>\n", "OwnerUserId": "2079303", "LastEditorUserId": "2079303", "LastEditDate": "2017-07-05T00:02:14.680", "Id": "44914988", "Score": "4", "CreationDate": "2017-07-04T23:05:49.373", "LastActivityDate": "2017-07-05T00:02:14.680"}, "44917653": {"ParentId": "44914678", "CommentCount": "0", "Body": "<p>Is it possible from the specification? Yes. [class.mem]/24 tells us about the relationship between the address of a standard layout class and its first base class subobject. But the standard makes no statement about this relationship for non-standard layout types. And since your type is not standard layout, the standard says nothing about that location.</p>\n<p>There are generally two ABI forms for base class assignment: put them before the members or put them after the members (for non-standard layout types). ABIs that assign base classes after the members would be free to assign empty base classes the last valid address with an appropriate alignment in the class's region of storage. If that happens to land in such a way as to avoid violating [intro.object]/8 (unique identity of subobjects), then it can perform that assignment.</p>\n<p>The two most common ABIs, Windows and Itanium, both assign base classes before members. While such ABIs could assign base classes more arbitrarily, they don't bother doing that. This would only ever come up in template code anyway, since empty classes are <em>empty</em>. They all behave the same, so there's no reason to deliberately make them both a base class and a member.</p>\n<p>So why bother having complex ABI rules for a case that is so rare?</p>\n", "OwnerUserId": "734069", "PostTypeId": "2", "Id": "44917653", "Score": "2", "CreationDate": "2017-07-05T05:29:24.627", "LastActivityDate": "2017-07-05T05:29:24.627"}, "bq_ids": {"n4140": {"so_44914678_44914988_2": {"section_id": 5795, "quality": 0.8809523809523809, "length": 37}, "so_44914678_44914988_1": {"section_id": 5794, "quality": 0.8636363636363636, "length": 19}}, "n3337": {"so_44914678_44914988_2": {"section_id": 5568, "quality": 0.8809523809523809, "length": 37}, "so_44914678_44914988_1": {"section_id": 5567, "quality": 0.8636363636363636, "length": 19}}, "n4659": {"so_44914678_44914988_2": {"section_id": 7254, "quality": 0.9761904761904762, "length": 41}, "so_44914678_44914988_1": {"section_id": 7253, "quality": 0.8636363636363636, "length": 19}}}, "44914678": {"CommentCount": "9", "AcceptedAnswerId": "44914988", "PostTypeId": "1", "LastEditorUserId": "3204551", "CreationDate": "2017-07-04T22:23:53.740", "LastActivityDate": "2017-07-05T05:29:24.627", "LastEditDate": "2017-07-04T22:35:03.520", "ViewCount": "106", "FavoriteCount": "1", "Title": "Can the compiler optimize out the empty base if the class contains a member of base class type as first element, followed by other members?", "Id": "44914678", "Score": "3", "Body": "<p>Consider:</p>\n<pre><code>struct empty {};\nstruct child : empty {\n    empty a[sizeof(int) / sizeof(empty)];\n    int b;\n};\n// Assume sizeof(int) &gt;= sizeof(empty)\n</code></pre>\n<p>Does the standard mandate that <code>sizeof(child)</code> is more than <code>2 * sizeof(int)</code>?</p>\n<p>The way I see it, nothing prohibits the baseclass-subobject from sharing its address with member <code>b</code>.</p>\n<p>If not, are there any common ABIs exploiting that at all?</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "3204551", "AnswerCount": "2"}});