post_cb({"41171260": {"CommentCount": "6", "ViewCount": "109", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-12-15T18:45:55.513", "LastActivityDate": "2016-12-15T21:33:45.733", "Title": "pointer adjustment with no multiple inheritance", "AcceptedAnswerId": "41171504", "LastEditDate": "2017-05-23T12:13:55.203", "Id": "41171260", "Score": "3", "Body": "<p>Consider a class layout :</p>\n<pre><code>| A | B | ( class B is derived from A )\n0x0 0x8\n</code></pre>\n<p>of course, there is nothing to adjust on downcasting or upcasting.\nbut is behaviour of compiler defined for this case in Standard.?</p>\n<p>if not, then, in general, is static_casting of nullptr safe when there is no multiple inheritance.?</p>\n<hr>\n<pre><code>A * volatile a_ptr = nullptr ; // or change with B * and cast to A * \nassert( ! static_cast&lt; B * &gt;( a_ptr ) ) ; // is that guaranteed by Standard.? \n</code></pre>\n<p>Does compiler <strong>always</strong> ( in all implementations ) do not perform adjustment.?</p>\n<p>and more generally (for case of multiple inheritance), can compiler adjust nullptr within static_cast.?</p>\n<hr>\n<p>related <a href=\"https://stackoverflow.com/questions/34993934/should-i-expect-that-upcasts-and-downcasts-in-single-inheritance-dont-adjust-th\">question</a>, also unanswered.</p>\n</hr></hr>", "Tags": "<c++><multiple-inheritance><static-cast><nullptr>", "OwnerUserId": "4625005", "AnswerCount": "1"}, "41171504": {"ParentId": "41171260", "PostTypeId": "2", "CommentCount": "11", "CreationDate": "2016-12-15T19:01:36.487", "Score": "4", "LastEditorUserId": "5245033", "LastEditDate": "2016-12-15T21:33:45.733", "Id": "41171504", "OwnerUserId": "5245033", "Body": "<p><code>static_cast</code> of <code>nullptr</code> is always safe. No matter what is your class layout, you can always <code>static_cast</code> nullptr within class hierarchy and will have defined results - <code>nullptr</code> of the cast type.</p>\n<p>Guarantee that any type cast from <code>nullptr</code> will result in <code>nullptr</code> can be found in Standard 5.2.9:</p>\n<blockquote>\n<p id=\"so_41171260_41171504_0\">A prvalue of type \u201cpointer to cv1 B,\u201d where B is a class type, can be\n  converted to a prvalue of type \u201cpointerto cv2 D,\u201d where D is a class\n  derived (Clause 10) from B, if a valid standard conversion from\n  \u201cpointer to D\u201d to \u201cpointer to B\u201d exists (4.10), cv2 is the same\n  cv-qualification as, or greater cv-qualification than, cv1, and B is\n  neither a virtual base class of D nor a base class of a virtual base\n  class of D. <strong>The null pointer value (4.10) is converted to the null\n  pointer value of the destination type</strong>.</p>\n</blockquote>\n<p>Although <code>nullptr</code> can be implictly converted to any pointer type, you might want an explicit cast in some cases, for example, when dealing with templates.</p>\n", "LastActivityDate": "2016-12-15T21:33:45.733"}, "bq_ids": {"n4140": {"so_41171260_41171504_0": {"section_id": 6037, "quality": 0.8431372549019608, "length": 43}}, "n3337": {"so_41171260_41171504_0": {"section_id": 5805, "quality": 0.8431372549019608, "length": 43}}, "n4659": {"so_41171260_41171504_0": {"section_id": 7536, "quality": 0.7058823529411765, "length": 36}}}});