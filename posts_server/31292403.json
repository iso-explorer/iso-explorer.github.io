post_cb({"bq_ids": {"n4140": {"so_31292403_31293774_0": {"length": 18, "quality": 1.0, "section_id": 302}, "so_31292403_31293774_2": {"length": 35, "quality": 1.0, "section_id": 305}, "so_31292403_31293774_1": {"length": 6, "quality": 1.0, "section_id": 304}}, "n3337": {"so_31292403_31293774_0": {"length": 18, "quality": 1.0, "section_id": 293}, "so_31292403_31293774_2": {"length": 35, "quality": 1.0, "section_id": 296}, "so_31292403_31293774_1": {"length": 6, "quality": 1.0, "section_id": 295}}, "n4659": {"so_31292403_31293774_0": {"length": 18, "quality": 1.0, "section_id": 309}, "so_31292403_31293774_2": {"length": 35, "quality": 1.0, "section_id": 312}, "so_31292403_31293774_1": {"length": 6, "quality": 1.0, "section_id": 311}}}, "31292478": {"Id": "31292478", "PostTypeId": "2", "Body": "<p>Here <code>f</code> will be instantiated one time, for type <code>int</code>, since all 3 calls call just <code>f&lt;int&gt;</code>.</p>\n", "LastEditorUserId": "1498580", "LastActivityDate": "2015-07-08T12:27:06.570", "Score": "5", "CreationDate": "2015-07-08T12:19:24.380", "ParentId": "31292403", "CommentCount": "2", "OwnerUserId": "1498580", "LastEditDate": "2015-07-08T12:27:06.570"}, "31292403": {"ViewCount": "150", "Body": "<p>Consider this peace of code:</p>\n<pre><code>template&lt;class T&gt;\nvoid f(const T&amp; t)\n{\n    static int x = 0;\n    cout&lt;&lt;++x&lt;&lt;endl;\n}\n\nint main()\n{\n    int j = 0;\n    const int i = 0;\n    f(5);\n    f(i);\n    f(j);\n}\n</code></pre>\n<p>I have called the function for 3 types. Although 5 and j can be the same thing, just int, const int i is definitely different type.<br>\nBut anyway my output is:</br></p>\n<pre><code>1\n2\n3\n</code></pre>\n<p>So that means that compiler instantiates the same function for different types.<br>\nAm I correct? Can anybody explain why?</br></p>\n", "AcceptedAnswerId": "31293774", "Title": "Template deduction interesting case, c++", "CreationDate": "2015-07-08T12:16:21.630", "Id": "31292403", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-07-08T13:21:54.537", "Score": "4", "OwnerUserId": "1856429", "Tags": "<c++><templates><instantiation><type-deduction>", "AnswerCount": "3"}, "31293774": {"Id": "31293774", "PostTypeId": "2", "Body": "<p>From [temp.deduct.call]:</p>\n<blockquote>\n<p id=\"so_31292403_31293774_0\">Template argument deduction is done by comparing each function template parameter type (call it P) with\n  the type of the corresponding argument of the call (call it A) as described below.</p>\n</blockquote>\n<p><code>P</code> is <code>const T&amp;</code> and <code>A</code> is <code>int</code>, <code>int</code>, and <code>const int</code> in the three calls. </p>\n<p>We then have:</p>\n<blockquote>\n<p id=\"so_31292403_31293774_1\">If P is a reference type, the type referred to by P is used for type deduction.</p>\n</blockquote>\n<p><code>P</code> is a reference type, so we use <code>P' == const T</code> for deduction against <code>A == int</code> or <code>A == const int</code>. In both cases, we deduce <code>T == int</code> so that <code>P' == const int</code> (and <code>P == const int&amp;</code>) and the deduced <code>A == const int</code>. This is more <em>cv</em>-qualified than the original <code>A</code> for the first two calls, but that's explicitly made OK:</p>\n<blockquote>\n<p id=\"so_31292403_31293774_2\">In general, the deduction process attempts to find template argument values that will make the deduced A\n  identical to A (after the type A is transformed as described above). However, there are three cases that allow\n  a difference:<br>\n  \u2014 If the original P is a reference type, the deduced A (i.e., the type referred to by the reference) can be\n  more cv-qualified than the transformed A.</br></p>\n</blockquote>\n<p>Thus, all three cases just call <code>f&lt;int&gt;</code>.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-07-08T13:21:54.537", "Score": "5", "CreationDate": "2015-07-08T13:12:28.323", "ParentId": "31292403", "CommentCount": "6", "OwnerUserId": "2069064", "LastEditDate": "2015-07-08T13:21:54.537"}, "31292936": {"Id": "31292936", "PostTypeId": "2", "Body": "<p>It's correct as soon as type deduction is valid.</p>\n<p>Consider this:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class T&gt;\nvoid f(const T&amp; t)\n{\n    static int x = 0;\n    std::cout&lt;&lt; \"x=\" &lt;&lt; ++x&lt;&lt;std::endl;\n}\n\ntemplate&lt;class T&gt;\nvoid f(T&amp;&amp; t)\n{\n    static int y = 0;\n    std::cout&lt;&lt; \"y=\" &lt;&lt; ++y&lt;&lt;std::endl;\n}\n\ntemplate&lt;class T&gt;\nvoid f(T&amp; t)\n{\n    static int z = 0;\n    std::cout&lt;&lt; \"z=\" &lt;&lt; ++z&lt;&lt;std::endl;\n}\n\nint main()\n{\n    int j = 0;\n    const int i = 0;\n    f(5);\n    f(i);\n    f(j);\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>y=1\nx=1\nz=1\n</code></pre>\n", "LastActivityDate": "2015-07-08T12:38:16.960", "CommentCount": "0", "CreationDate": "2015-07-08T12:38:16.960", "ParentId": "31292403", "Score": "0", "OwnerUserId": "2769167"}});