post_cb({"21274897": {"ParentId": "21273570", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The problem here is the statement \"If temporaries are supposed to live as long as there are references to them.\" This is true only in limited circumstances, your program isn't a demonstration of one of those cases. You are storing a tuple containing references to temporaries that are destroyed at the end of the full expression. This program demonstrates it very clearly (<a href=\"http://coliru.stacked-crooked.com/a/58d31327d0746b8e\" rel=\"nofollow\">Live code at Coliru</a>):</p>\n<pre><code>struct foo {\n    int value;\n    foo(int v) : value(v) {\n        std::cout &lt;&lt; \"foo(\" &lt;&lt; value &lt;&lt; \")\\n\" &lt;&lt; std::flush;\n    }\n    ~foo() {\n        std::cout &lt;&lt; \"~foo(\" &lt;&lt; value &lt;&lt; \")\\n\" &lt;&lt; std::flush;\n    }\n    foo(const foo&amp;) = delete;\n    foo&amp; operator = (const foo&amp;) = delete;\n    friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; os,\n                                      const foo&amp; f) {\n        os &lt;&lt; f.value;\n        return os;\n    }\n};\n\ntemplate &lt;typename A, typename B&gt;\nstruct node { A a; B b; };\n\ntemplate &lt;typename... A&gt;\nnode &lt;A&amp;&amp;...&gt; make(A&amp;&amp;... a)\n{\n    return node &lt;A&amp;&amp;...&gt;{std::forward &lt;A&gt;(a)...};\n}\n\ntemplate &lt;typename N&gt;\nauto fst(N&amp;&amp; n)\n-&gt; decltype((std::forward &lt;N&gt;(n).a))\n    { return std::forward &lt;N&gt;(n).a; }\n\ntemplate &lt;typename N&gt;\nauto snd(N&amp;&amp; n)\n-&gt; decltype((std::forward &lt;N&gt;(n).b))\n    { return std::forward &lt;N&gt;(n).b; }\n\nint main() {\n    using namespace std;\n    // A: works fine (prints '2')\n    cout &lt;&lt; fst(snd(make(foo(3), make(foo(2), foo(0))))) &lt;&lt; endl;\n\n    // B: fine in Clang, segmentation fault in GCC with -Os\n    auto z = make(foo(3), make(foo(2), foo(0)));\n    cout &lt;&lt; \"referencing: \" &lt;&lt; flush;\n    cout &lt;&lt; fst(snd(z)) &lt;&lt; endl;\n}\n</code></pre>\n<p><code>A</code> works fine because it accesses the references stored in the tuple in the same full expression, <code>B</code> has undefined behavior since it stores the tuple and accesses the references later. Note that <a href=\"http://coliru.stacked-crooked.com/a/a623127dc4fe79c0\" rel=\"nofollow\">although it may not crash when compiled with clang</a>, it's clearly undefined behavior nonetheless due to accessing an object after the end of its lifetime.</p>\n<p>If you want to make this usage safe, you can quite easily alter the program to store references to lvalues, but move rvalues into the tuple itself (<a href=\"http://coliru.stacked-crooked.com/a/7003d82335856254\" rel=\"nofollow\">Live demo at Coliru</a>):</p>\n<pre><code>template &lt;typename... A&gt;\nnode&lt;A...&gt; make(A&amp;&amp;... a)\n{\n    return node&lt;A...&gt;{std::forward &lt;A&gt;(a)...};\n}\n</code></pre>\n<p>Replacing <code>node&lt;A&amp;&amp;...&gt;</code> with <code>node&lt;A...&gt;</code> is the trick: since <code>A</code> is a universal reference, the actual type of <code>A</code> will be an lvalue reference for lvalue arguments, and a non-reference type for rvalue arguments. The reference collapsing rules work in our favor for this usage as well as for perfect forwarding.</p>\n<p>EDIT: As for <em>why</em> the temporaries in this scenario don't have their lifetimes extended to the lifetime of the references, we have to look at C++11 12.2 Temporary Objects [class.temporary] paragraph 4:</p>\n<blockquote>\n<p id=\"so_21273570_21274897_0\">There are two contexts in which temporaries are destroyed at a different point than the end of the full-expression. The first context is when a default constructor is called to initialize an element of an array. If the constructor has one or more default arguments, the destruction of every temporary created in a default argument is sequenced before the construction of the next array element, if any.</p>\n</blockquote>\n<p>and the <em>much</em> more involved paragraph 5:</p>\n<blockquote>\n<p id=\"so_21273570_21274897_1\">The second context is when a reference is bound to a temporary. The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference except:</p>\n<ul>\n<li><p id=\"so_21273570_21274897_2\">A temporary bound to a reference member in a constructor\u2019s ctor-initializer (12.6.2) persists until the\n  constructor exits.</p></li>\n<li><p id=\"so_21273570_21274897_3\">A temporary bound to a reference parameter in a function call (5.2.2) persists until the completion of\n  the full-expression containing the call.</p></li>\n<li><p id=\"so_21273570_21274897_4\">The lifetime of a temporary bound to the returned value in a function return statement (6.6.3) is not\n  extended; the temporary is destroyed at the end of the full-expression in the return statement.</p></li>\n<li><p id=\"so_21273570_21274897_5\">A temporary bound to a reference in a <em>new-initializer</em> (5.3.4) persists until the completion of the full-expression containing the <em>new-initializer</em>. [ Example:</p></li>\n</ul>\n</blockquote>\n<pre><code>struct S { int mi; const std::pair&lt;int,int&gt;&amp; mp; };\nS a { 1, {2,3} };\nS* p = new S{ 1, {2,3} }; // Creates dangling reference\n</code></pre>\n<blockquote>\n<p id=\"so_21273570_21274897_6\">\u2014end example ] [ Note: This may introduce a dangling reference, and implementations are encouraged to issue a warning in such a case. \u2014end note ]</p>\n<p id=\"so_21273570_21274897_7\">The destruction of a temporary whose lifetime is not extended by being bound to a reference is sequenced before the destruction of every temporary which is constructed earlier in the same full-expression. If the lifetime of two or more temporaries to which references are bound ends at the same point, these temporaries are destroyed at that point in the reverse order of the completion of their construction. In addition, the destruction of temporaries bound to references shall take into account the ordering of destruction of objects\n  with static, thread, or automatic storage duration (3.7.1, 3.7.2, 3.7.3); that is, if <code>obj1</code> is an object with the same storage duration as the temporary and created before the temporary is created the temporary shall be destroyed before <code>obj1</code> is destroyed; if <code>obj2</code> is an object with the same storage duration as the temporary and created after the temporary is created the temporary shall be destroyed after <code>obj2</code> is destroyed. [ Example:</p>\n<pre><code>struct S {\n  S();\n  S(int);\n  friend S operator+(const S&amp;, const S&amp;);\n  ~S();\n};\nS obj1;\nconst S&amp; cr = S(16)+S(23);\nS obj2;\n</code></pre>\n<p id=\"so_21273570_21274897_8\">the expression <code>S(16) + S(23)</code> creates three temporaries: a first temporary <code>T1</code> to hold the result of the expression <code>S(16)</code>, a second temporary <code>T2</code> to hold the result of the expression S(23), and a third temporary <code>T3</code> to hold the result of the addition of these two expressions. The temporary <code>T3</code> is then bound to the reference <code>cr</code>. It is unspecified whether <code>T1</code> or <code>T2</code> is created first. On an implementation where <code>T1</code> is created before <code>T2</code>, it is guaranteed that <code>T2</code> is destroyed before <code>T1</code>. The temporaries <code>T1</code> and <code>T2</code> are bound to the reference parameters of <code>operator+</code>; these temporaries are destroyed at the end of the full-expression containing the call to <code>operator+</code>. The temporary <code>T3</code> bound to the reference <code>cr</code> is destroyed at the end of <code>cr</code>\u2019s lifetime,\n  that is, at the end of the program. In addition, the order in which <code>T3</code> is destroyed takes into account the destruction order of other objects with static storage duration. That is, because <code>obj1</code> is constructed before <code>T3</code>, and <code>T3</code> is constructed before <code>obj2</code>, it is guaranteed that <code>obj2</code> is destroyed before T3, and that <code>T3</code> is destroyed before <code>obj1</code>. \u2014end example ]</p>\n</blockquote>\n<p>You are binding a temporary \"to a reference member in a constructor's ctor-initializer\".</p>\n", "OwnerUserId": "923854", "LastEditorUserId": "923854", "LastEditDate": "2014-01-22T08:40:59.443", "Id": "21274897", "Score": "1", "CreationDate": "2014-01-22T05:26:16.030", "LastActivityDate": "2014-01-22T08:40:59.443"}, "21273570": {"CommentCount": "0", "ViewCount": "342", "CreationDate": "2014-01-22T03:23:39.737", "LastActivityDate": "2014-01-22T08:40:59.443", "Title": "nested std::forward_as_tuple and segmentation fault", "AcceptedAnswerId": "21274897", "PostTypeId": "1", "Id": "21273570", "Score": "2", "Body": "<p>My actual problem is a lot more complicated and it seems extremely difficult to give a short concrete example here to reproduce it. So I am posting here a different small example that may be relevant, and its discussion may help in the actual problem as well:</p>\n<pre><code>// A: works fine (prints '2')\ncout &lt;&lt; std::get &lt;0&gt;(std::get &lt;1&gt;(\n    std::forward_as_tuple(3, std::forward_as_tuple(2, 0)))\n) &lt;&lt; endl;\n\n// B: fine in Clang, segmentation fault in GCC with -Os\nauto x = std::forward_as_tuple(3, std::forward_as_tuple(2, 0));\ncout &lt;&lt; std::get &lt;0&gt;(std::get &lt;1&gt;(x)) &lt;&lt; endl;\n</code></pre>\n<p>The actual problem does not involve <code>std::tuple</code>, so to make the example independent, here's a custom, minimal rough equivalent:</p>\n<pre><code>template &lt;typename A, typename B&gt;\nstruct node { A a; B b; };\n\ntemplate &lt;typename... A&gt;\nnode &lt;A&amp;&amp;...&gt; make(A&amp;&amp;... a)\n{\n    return node &lt;A&amp;&amp;...&gt;{std::forward &lt;A&gt;(a)...};\n}\n\ntemplate &lt;typename N&gt;\nauto fst(N&amp;&amp; n)\n-&gt; decltype((std::forward &lt;N&gt;(n).a))\n    { return std::forward &lt;N&gt;(n).a; }\n\ntemplate &lt;typename N&gt;\nauto snd(N&amp;&amp; n)\n-&gt; decltype((std::forward &lt;N&gt;(n).b))\n    { return std::forward &lt;N&gt;(n).b; }\n</code></pre>\n<p>Given these definitions, I get exactly the same behaviour:</p>\n<pre><code>// A: works fine (prints '2')\ncout &lt;&lt; fst(snd(make(3, make(2, 0)))) &lt;&lt; endl;\n\n// B: fine in Clang, segmentation fault in GCC with -Os\nauto z = make(3, make(2, 0));\ncout &lt;&lt; fst(snd(z)) &lt;&lt; endl;\n</code></pre>\n<p>In general, it appears that behaviour depends on compiler and optimization level. I have not been able to find out anything by debugging. It appears that in all cases everything is inlined and optimized out, so I can't figure out the specific line of code causing the problem.</p>\n<p>If temporaries are supposed to live as long as there are references to them (and I am not returning references to local variables from within a function body), I do not see any fundamental reason why the code above may cause problems and why cases A and B should differ.</p>\n<p>In my actual problem, both Clang and GCC give segmentation faults even for one-liner versions (case A) and regardless of optimization level, so the problem is quite serious.</p>\n<p>The problem disappears when using values instead or rvalue references (e.g. <code>std::make_tuple</code>, or <code>node &lt;A...&gt;</code> in the custom version). It also disappears when tuples are not nested.</p>\n<p>But none of the above helps. What I am implementing is is a kind of expression templates for views and lazy evaluation on a number of structures, including tuples, sequences, and combinations. So I definitely need rvalue references to temporaries. Everything works fine for nested tuples, e.g. <code>(a, (b, c))</code>, for expressions with nested operations, e.g. <code>u + 2 * v</code>, but not both.</p>\n<p>I would appreciate any comment that would help understand if the code above is valid, if a segmentation fault is expected, how I could avoid it, and what might be going on with compilers and optimization levels.</p>\n", "Tags": "<c++11><segmentation-fault><rvalue-reference><expression-templates><stdtuple>", "OwnerUserId": "2644390", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_21273570_21274897_8": {"section_id": 382, "quality": 0.9139784946236559, "length": 85}, "so_21273570_21274897_2": {"section_id": 382, "quality": 0.9090909090909091, "length": 10}, "so_21273570_21274897_6": {"section_id": 382, "quality": 0.75, "length": 12}, "so_21273570_21274897_5": {"section_id": 382, "quality": 0.8333333333333334, "length": 10}, "so_21273570_21274897_1": {"section_id": 382, "quality": 0.9047619047619048, "length": 19}, "so_21273570_21274897_4": {"section_id": 382, "quality": 0.8823529411764706, "length": 15}, "so_21273570_21274897_0": {"section_id": 381, "quality": 0.972972972972973, "length": 36}, "so_21273570_21274897_3": {"section_id": 382, "quality": 0.9230769230769231, "length": 12}, "so_21273570_21274897_7": {"section_id": 382, "quality": 0.9411764705882353, "length": 80}}, "n3337": {"so_21273570_21274897_8": {"section_id": 373, "quality": 0.9354838709677419, "length": 87}, "so_21273570_21274897_2": {"section_id": 373, "quality": 0.9090909090909091, "length": 10}, "so_21273570_21274897_6": {"section_id": 373, "quality": 0.75, "length": 12}, "so_21273570_21274897_5": {"section_id": 373, "quality": 0.8333333333333334, "length": 10}, "so_21273570_21274897_0": {"section_id": 372, "quality": 0.972972972972973, "length": 36}, "so_21273570_21274897_4": {"section_id": 373, "quality": 0.8823529411764706, "length": 15}, "so_21273570_21274897_1": {"section_id": 373, "quality": 0.9047619047619048, "length": 19}, "so_21273570_21274897_3": {"section_id": 373, "quality": 0.9230769230769231, "length": 12}, "so_21273570_21274897_7": {"section_id": 373, "quality": 0.9411764705882353, "length": 80}}, "n4659": {"so_21273570_21274897_8": {"section_id": 399, "quality": 0.9139784946236559, "length": 85}, "so_21273570_21274897_6": {"section_id": 397, "quality": 0.6875, "length": 11}, "so_21273570_21274897_4": {"section_id": 397, "quality": 0.8823529411764706, "length": 15}, "so_21273570_21274897_0": {"section_id": 396, "quality": 0.9459459459459459, "length": 35}, "so_21273570_21274897_7": {"section_id": 398, "quality": 0.9411764705882353, "length": 80}, "so_21273570_21274897_1": {"section_id": 397, "quality": 0.8571428571428571, "length": 18}, "so_21273570_21274897_3": {"section_id": 397, "quality": 0.9230769230769231, "length": 12}, "so_21273570_21274897_5": {"section_id": 397, "quality": 0.8333333333333334, "length": 10}}}});