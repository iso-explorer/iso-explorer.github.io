post_cb({"bq_ids": {"n4140": {"so_10731131_10731415_1": {"length": 49, "quality": 0.9423076923076923, "section_id": 3376}, "so_10731131_10731415_0": {"length": 19, "quality": 0.95, "section_id": 3271}, "so_10731131_10731325_0": {"length": 12, "quality": 1.0, "section_id": 3376}}, "n3337": {"so_10731131_10731415_1": {"length": 52, "quality": 1.0, "section_id": 3246}, "so_10731131_10731415_0": {"length": 19, "quality": 0.95, "section_id": 3143}, "so_10731131_10731325_0": {"length": 12, "quality": 1.0, "section_id": 3246}}, "n4659": {"so_10731131_10731415_0": {"length": 11, "quality": 0.55, "section_id": 4029}}}, "10731415": {"Id": "10731415", "PostTypeId": "2", "Body": "<p>The standardese starts nicely in <strong>C++11 \u00a78.4.2/2</strong>,</p>\n<blockquote>\n<p id=\"so_10731131_10731415_0\">If a function is explicitly defaulted on its first declaration,<br>\n  \u2014 it is implicitly considered to be constexpr if the implicit declaration would be,<br>\n  \u2014 it is implicitly considered to have the same exception-specification as if it had been implicitly declared (15.4), \u2026</br></br></p>\n</blockquote>\n<p>But then, over in <strong>C++11 \u00a715.4/14</strong>, the logic rapidly devolves,</p>\n<blockquote>\n<p id=\"so_10731131_10731415_1\">An implicitly declared special member function (Clause 12) shall have an <em>exception-specification</em>. If <code>f</code> is an implicitly declared default constructor, copy constructor, move constructor, destructor, copy assignment operator, or move assignment operator, its implicit exception-specification specifies the type-id <code>T</code> if and only\n  if <code>T</code> is allowed by the exception-specification of a function directly invoked by <code>f</code>\u2019s implicit definition; <code>f</code> shall allow all exceptions if any function it directly invokes allows all exceptions, and <code>f</code> shall allow no exceptions if every function it directly invokes allows no exceptions.</p>\n</blockquote>\n<p>In the standard's meaning of \"allow\" it is about explicitly allowing, through an exception specification.</p>\n<p>If <code>f</code> calls two functions, one of which specifies and therefore allows <code>T</code>, and one of which allows all exceptions, then <code>f</code> must both specify <code>T</code> <em>and</em> allow all exceptions, which isn\u2019t possible.</p>\n<p>So this definitely looks like a defect in the standard.</p>\n<p>I found a related Defect Report, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1351\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1351</a>.</p>\n<p>However, it looks like this area is just a Big Mess. :-(</p>\n", "LastActivityDate": "2012-05-24T05:01:35.757", "CommentCount": "8", "CreationDate": "2012-05-24T05:01:35.757", "ParentId": "10731131", "Score": "2", "OwnerUserId": "464581"}, "10731325": {"Id": "10731325", "PostTypeId": "2", "Body": "<p>Back up to earlier in the same sentence (\u00a715.4/14): </p>\n<blockquote>\n<p id=\"so_10731131_10731325_0\">...its implicit exception-specification specifies the type-id T if and only if T is allowed by the exception-specification of a function directly invoked by f\u2019s implicit definition;...\" </p>\n</blockquote>\n<p>Therefore, if <code>~Foo</code> doesn't invoke any functions, it has an implicit declaration that allows no exceptions to be thrown.</p>\n<p>According to \u00a715.4/3: </p>\n<blockquote>\n<p id=\"so_10731131_10731325_1\">Two exception-specifications are compatible if:</p>\n<ul>\n<li>both are non-throwing (see below), regardless of their form,</li>\n</ul>\n</blockquote>\n<p>That's the case here, so it doesn't really matter whether the declaration is <code>throw()</code> or <code>noexcept</code> -- the two are compatible in any case.</p>\n", "LastActivityDate": "2012-05-24T04:49:39.413", "CommentCount": "4", "CreationDate": "2012-05-24T04:49:39.413", "ParentId": "10731131", "Score": "4", "OwnerUserId": "179910"}, "10731131": {"ViewCount": "2242", "Body": "<p>Suppose I have:</p>\n<pre><code>class Foo\n{\npublic:\n   virtual ~Foo()=default;\n};\n</code></pre>\n<p>What is the exception-specification on the defaulted destructor?  Is the defaulted destructor equivalent to:</p>\n<pre><code>   virtual ~Foo() {};\nor\n   virtual ~Foo() throw() {};\nor\n   virtual ~Foo() noexcept {};\n</code></pre>\n<p>Section 15.4 of the C++11 standard says it depends on the exception specifications of the functions directly invoked by the destructor's implicit definition.  In this case there are no members, and no base classes, so AFAIK there are no functions directly invoked by the implicit destructor.  Is this an ambiguity (or omission) in the standard?</p>\n<p>It matters, of course, because if it implicitly has throw(), then all subclasses must declare their destructors with throw().  Don't tell me it's a bad idea to throw exceptions in destructors, I know that.  I deal with lots of legacy code where exception specs were not used at all.</p>\n<p>As a point of information, when I tried:</p>\n<pre><code>class SubFoo : public Foo\n{\npublic:\n   virtual ~SubFoo();\n};\n</code></pre>\n<p>I got an error (mismatched exception specs) in GCC 4.4 (although I admit I may not have had the right command line switches), but not in XCode 4.3 using the \"11\" compilers.</p>\n", "Title": "What is the exception specification for a defaulted virtual destructor in C++11?", "CreationDate": "2012-05-24T04:25:05.653", "LastActivityDate": "2012-05-24T05:01:35.757", "CommentCount": "0", "PostTypeId": "1", "Id": "10731131", "Score": "9", "OwnerUserId": "1414050", "Tags": "<c++><default><exception-specification>", "AnswerCount": "2"}});