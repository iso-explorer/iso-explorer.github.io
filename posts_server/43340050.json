post_cb({"43352552": {"ParentId": "43340050", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Whether this has defined behaviour is unclear, but I believe it does.</p>\n<p>There appears to be no specific prohibition in the description of <code>std::set</code> on modifying the values, other than the restriction you already hinted at that the comparer must return the same result when passed the same inputs ([associative.reqmts]p3).</p>\n<p>However, the general rule on modifying objects defined as <code>const</code> does apply. Whether <code>set</code> defines its elements as <code>const</code> is not spelt out. If it does, then modifying the elements is not allowed ([dcl.type.cv]p4).</p>\n<p>But [container.requirements.general]p3 reads:</p>\n<blockquote>\n<p id=\"so_43340050_43352552_0\">For the components affected by this subclause that declare an <code>allocator_type</code>, objects stored in these components shall be constructed using the <code>allocator_traits&lt;allocator_type&gt;::construct</code> function and\n  destroyed using the <code>allocator_traits&lt;allocator_type&gt;::destroy</code> function (20.7.8.2).</p>\n</blockquote>\n<p><code>std::set&lt;T&gt;</code> declares an <code>allocator_type</code>, which defaults to <code>std::allocator&lt;T&gt;</code>. <code>std::allocator_traits&lt;allocator_type&gt;::construct</code> passes it a <code>T *</code>, causing a <code>T</code> to be constructed, not a <code>const T</code>.</p>\n<p>I believe this means <code>std::set&lt;T&gt;</code> is not permitted to define its elements as <code>const</code>, and for lack of any other prohibition, means modifying the elements through <code>const_cast</code> is allowed.</p>\n<hr>\n<p>Personally, if I couldn't find any better alternative, I would consider avoiding the issue by putting the whole thing in a wrapper struct, which defines a member <code>mutable X x;</code>. This would allow modifications without <code>const_cast</code>, so long as you take care to avoid changing the relative order of elements already in the set. It would additionally serve as documentation to other readers of your code that the elements of your set can and will be modified.</p>\n</hr>", "OwnerUserId": "743382", "LastEditorUserId": "743382", "LastEditDate": "2017-04-12T16:36:39.743", "Id": "43352552", "Score": "2", "CreationDate": "2017-04-11T17:26:51.230", "LastActivityDate": "2017-04-12T16:36:39.743"}, "43340050": {"CommentCount": "0", "ViewCount": "41", "PostTypeId": "1", "LastEditorUserId": "2666289", "CreationDate": "2017-04-11T08:01:44.703", "LastActivityDate": "2017-04-12T16:36:39.743", "Title": "Modification of elements of std::set - Defined behavior?", "LastEditDate": "2017-04-11T15:32:07.313", "Id": "43340050", "Score": "2", "Body": "<p>Given the following code:</p>\n<pre><code>#include &lt;set&gt;\n\nstruct X {\n    int a, b;\n    friend bool operator&lt;(X const&amp; lhs, X const&amp; rhs) {\n        return lhs.a &lt; rhs.a;\n    }\n};\n\nint main() {\n    std::set&lt;X&gt; xs;\n    // some insertion...\n    auto it = xs.find({0, 0}); // assume it != xs.end()\n\n    const_cast&lt;X&amp;&gt;(*it).b = 4; // (1)\n}\n</code></pre>\n<p>Is <code>(1)</code> defined behavior? I.e., am I allowed to <code>const_cast</code> a reference to an element obtain from a <code>const_iterator</code> of a <code>std::set</code> and modify it if the modification does not alter the ordering?</p>\n<p>I have read some posts here and there proposing this kind of <code>const_cast</code>, but I was wondering if this was actually defined behavior.</p>\n", "Tags": "<c++><set><const-cast>", "OwnerUserId": "2666289", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_43340050_43352552_0": {"section_id": 704, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_43340050_43352552_0": {"section_id": 694, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_43340050_43352552_0": {"section_id": 733, "quality": 0.7777777777777778, "length": 14}}}});