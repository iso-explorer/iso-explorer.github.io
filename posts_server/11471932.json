post_cb({"19392349": {"Id": "19392349", "PostTypeId": "2", "Body": "<p>This is now <a href=\"http://cplusplus.github.io/LWG/lwg-active.html#2338\" rel=\"nofollow\">LWG issue #2338</a>, I will update the answer with the resolution.</p>\n", "LastActivityDate": "2013-10-15T22:42:41.887", "CommentCount": "0", "CreationDate": "2013-10-15T22:42:41.887", "ParentId": "11471932", "Score": "0", "OwnerUserId": "273767"}, "bq_ids": {"n4140": {"so_11471932_11471932_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 5070}}, "n3337": {"so_11471932_11471932_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 4867}}, "n4659": {"so_11471932_11471932_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 6491}}}, "11471932": {"ViewCount": "689", "Body": "<p>To give context of what I'm talking about, the following program correctly prints <code>true</code> when compiled with clang++/libc++</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;regex&gt;\nint main()\n{\n    std::locale::global(std::locale(\"en_US.UTF-8\"));\n    std::wstring str = L\"A\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5a\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\";\n    std::wregex re(L\"[[=a=]]*\", std::regex::basic);\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::regex_match(str, re) &lt;&lt; '\\n';\n}\n</code></pre>\n<p>however, I can't quite understand the description of <code>std::regex_traits::transform_primary()</code> in the standard (through which <code>[=a=]</code> is handled). To quote 28.7[re.traits]/7: </p>\n<blockquote>\n<p id=\"so_11471932_11471932_0\">if <code>typeid(use_facet&lt;collate&lt;charT&gt; &gt;) == typeid(collate_byname&lt;charT&gt;)</code> and the\n  form of the sort key returned by <code>collate_byname&lt;charT&gt;::transform(first, last)</code> is known and can be converted into a primary sort key then returns that key, otherwise returns an empty string.</p>\n</blockquote>\n<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2003/n1429.htm\">original proposal</a> explains that the standard <code>regex_traits::transform_primary()</code> can only work if the <code>collate</code> facet in the imbued locale was not replaced by the user (that's the only way it can know how to convert the result of <code>collate::transform()</code> to the equivalence key).</p>\n<p>My question is, how is the <code>typeid</code> comparison in the standard supposed to ensure that? Does it imply that all system-supplied facets pulled out of locales with <code>use_facet</code> have <code>_byname</code> as their true dynamic types?</p>\n", "Title": "transform_primary() and collate_byname()", "CreationDate": "2012-07-13T13:55:28.400", "LastActivityDate": "2013-10-15T22:42:41.887", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "Id": "11471932", "Score": "24", "OwnerUserId": "273767", "Tags": "<c++><c++11><locale>", "AnswerCount": "2"}, "11594898": {"Id": "11594898", "PostTypeId": "2", "Body": "<p>\"My question is, how is the typeid comparison in the standard supposed to ensure that? Does it imply that all system-supplied facets pulled out of locales with use_facet have _byname as their true dynamic types?\"</p>\n<p>to answer the first half of your question, the typeid comparison ensures this because if the user has instantiated the template with a different value for <code>use_facet</code>, the typeid comparison will fail.  if the typeid's do match, it will be guaranteed that the function to be dispatched will not have been overridden by the user.  thus you'll get the system collate_byname class, and the proper transform will get called.</p>\n<p>to answer the second part of your question, it does simply mean that all system-supplied facets associated with locales expected to be used by regex conform to this implementation requirement.  find earlier in that same document from where you pulled the cited reference to 28.7</p>\n<blockquote>\n<p id=\"so_11471932_11594898_0\">Note also that there is no portable way to implement transform_primary\n  in terms of std::locale, since even if the sort key format returned by\n  std::collate_byname&lt;&gt;::transform is known and can be converted into a\n  primary sort key, the user can still install their own custom\n  std::collate implementation into the locale object used, and that can\n  use any sort key format they see fit. The transform_primary member\n  function is therefore more of use to custom traits classes, and should\n  throw an exception if it cannot be implemented for a particular\n  locale.</p>\n</blockquote>\n<p>in short, this is telling us that if there is anything but an expected (i.e. system-supplied) value for that type/typeid, the results could be unpredictable because the user could supply a different sort key format.  by sticking with the system supplied value, the typeid for that facet will be known, and thus the sort-key will be known and predictable.</p>\n", "LastActivityDate": "2012-07-21T18:39:01.593", "CommentCount": "1", "CreationDate": "2012-07-21T18:39:01.593", "ParentId": "11471932", "Score": "1", "OwnerUserId": "774691"}});