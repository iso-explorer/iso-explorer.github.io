post_cb({"25697111": {"ParentId": "25697057", "CommentCount": "0", "Body": "<p>You need to handle synchronization only if you are accessing the same memory and modifying it. If you are only reading then also you don't need to take care about the synchronization.</p>\n<p>As you are saying Each thread will access different indices then you don't require synchronization here. but you need to make sure that the two thread should not modify the same indice at the same time.</p>\n", "OwnerUserId": "3404637", "PostTypeId": "2", "Id": "25697111", "Score": "0", "CreationDate": "2014-09-06T05:23:45.597", "LastActivityDate": "2014-09-06T05:23:45.597"}, "25697057": {"CommentCount": "3", "AcceptedAnswerId": "25697173", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-09-06T05:16:41.113", "LastActivityDate": "2014-09-06T06:31:38.567", "LastEditDate": "2017-05-23T12:25:36.667", "ViewCount": "517", "FavoriteCount": "3", "Title": "When manipulating different array indices in C/C++ with two threads, is synchronization needed?", "Id": "25697057", "Score": "9", "Body": "<p>Suppose I have an array defined as follows:</p>\n<pre><code>volatile char v[2];\n</code></pre>\n<p>And I have two threads (denoted by A, B respectively) manipulating array <code>v</code>. If I ensure that A, B use different indices at any time, that is to say, if A is now manipulating <code>v[i]</code>, then B is either doing nothing, or manipulating <code>v[1-i]</code>. I wonder is synchronization needed for this situation?</p>\n<p>I have referred to <a href=\"https://stackoverflow.com/questions/940139/is-synchronization-needed-when-manipulating-different-arrayobject-array-indice\">this question</a>, however I think it is limited in Java. The reason why I ask this question is that I have been struggling with a strange and rare bug in a large project for days, and up to now, the only reason I could come up with to explain the bug is that synchronization is needed for the above manipulation. (Since the bug is very rare, it is hard for me to prove whether my conjecture is true)</p>\n<p>Edit: both reading and modifying are possible for <code>v</code>.</p>\n", "Tags": "<c++><c><arrays><multithreading><synchronization>", "OwnerUserId": "3881143", "AnswerCount": "3"}, "25697207": {"ParentId": "25697057", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>As far as the C++11 and C11 standards are concerned, your code is safe. C++11 \u00a71.7 [intro.memory]/p2, irrelevant note omitted:</p>\n<blockquote>\n<p id=\"so_25697057_25697207_0\">A <em>memory location</em> is either an object of scalar type or a maximal\n  sequence of adjacent bit-fields all having non-zero width. Two or more\n  threads of execution (1.10) can update and access separate memory\n  locations without interfering with each other.</p>\n</blockquote>\n<p><code>char</code> is a integral type, which means it's an arithmetic type, which means that <code>volatile char</code> is a scalar type, so <code>v[0]</code> and <code>v[1]</code> are separate memory locations.</p>\n<p>C11 has a similar definition in \u00a73.14.</p>\n<p>Before C++11 and C11, the language itself has no concept of threads, so you are left to the mercy of the particular implementation you are using.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2014-09-06T05:45:27.937", "Id": "25697207", "Score": "6", "CreationDate": "2014-09-06T05:39:59.810", "LastActivityDate": "2014-09-06T05:45:27.937"}, "bq_ids": {"n4140": {"so_25697057_25697207_0": {"section_id": 5787, "quality": 0.9285714285714286, "length": 26}}, "n3337": {"so_25697057_25697207_0": {"section_id": 5560, "quality": 0.9285714285714286, "length": 26}}, "n4659": {"so_25697057_25697207_0": {"section_id": 7244, "quality": 0.8928571428571429, "length": 25}}}, "25697173": {"ParentId": "25697057", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>It might be a compiler bug or a hardware limitation. </p>\n<p>Sometimes, when a less than 32-bit/64-bit variable is accesses from memory, the processor will read 32 bits, set the apprpriate 8 or 16 bits, then write back the whole register. That means it will read/write the adjacent memory as well, leading to a data race.</p>\n<p>Solutions are </p>\n<ul>\n<li><p>use byte-access instructions. They may not be available for your processor or your compiler does not know to use them.</p></li>\n<li><p>pad your elements to avoid this kind of sharing. The compiler should do it automatically if your target platform does not support byte access. But in an array, this conflicts with the memory layout reqiurements.</p></li>\n<li>synchronize the whole structure</li>\n</ul>\n<p><strong>C++03/C++11 debate</strong></p>\n<p>In classic C++ it's up to you to avoid/mitigate this kind of behaviour. In C++11 this violates memry model requitements, as stated in other answers.</p>\n", "OwnerUserId": "981773", "LastEditorUserId": "981773", "LastEditDate": "2014-09-06T06:31:38.567", "Id": "25697173", "Score": "2", "CreationDate": "2014-09-06T05:34:38.377", "LastActivityDate": "2014-09-06T06:31:38.567"}});