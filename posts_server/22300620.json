post_cb({"bq_ids": {"n4140": {"so_22300620_22415912_0": {"length": 18, "quality": 1.0, "section_id": 302}}, "n3337": {"so_22300620_22415912_0": {"length": 18, "quality": 1.0, "section_id": 293}}, "n4659": {"so_22300620_22415912_0": {"length": 18, "quality": 1.0, "section_id": 309}}}, "22415912": {"Id": "22415912", "PostTypeId": "2", "Body": "<p>What I've summarized is the process described at 14.8.2.1p1</p>\n<blockquote>\n<p id=\"so_22300620_22415912_0\">Template argument deduction is done by comparing each function template parameter type (call it P) with the type of the corresponding argument of the call (call it A) as described below.</p>\n</blockquote>\n<p>In our case, we have for P <code>(T, int)</code> and for A, we have <code>(int)</code>. For the first pair of P/A, which is <code>T</code> against <code>int</code>, we can match <code>T</code> to <code>int</code> (by the process described in 14.8.2.5). But for the second \"pair\", we have <code>int</code> but have no counterpart. Thus deduction cannot be made for this \"pair\". </p>\n<p>Thereby, by 14.8.2.5p2, \"If type deduction cannot be done for any P/A pair, ..., template\nargument deduction fails.\".</p>\n<p>You then won't ever come to the point where you substitute template arguments into the function template.</p>\n<p>This can all probably described more precisely in the Standard (IMO), but I believe this is how one could implement things to match the actual behavior of Clang and GCC and it seems a reasonable interpretation of the Standardese.</p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2014-03-14T21:25:31.517", "Score": "2", "CreationDate": "2014-03-14T21:18:37.363", "ParentId": "22300620", "CommentCount": "5", "OwnerUserId": "34509", "LastEditDate": "2014-03-14T21:25:31.517"}, "22300620": {"ViewCount": "118", "Body": "<p>In <a href=\"https://stackoverflow.com/a/22259156/420683\">his answer</a> to <a href=\"https://stackoverflow.com/q/22258054/420683\">this question</a> and the comment section, <a href=\"https://stackoverflow.com/users/34509/johannes-schaub-litb\">Johannes Schaub</a> says there's a \"match error\" when trying to do template type deduction for a function template that requires more arguments than have been passed:</p>\n<pre><code>template&lt;class T&gt;\nvoid foo(T, int);\n\nfoo(42); // the template specialization foo&lt;int&gt;(int, int) is not viable\n</code></pre>\n<p>In the context of the other question, what's relevant is whether or not type deduction for the function template succeeds (and substitution takes place):</p>\n<pre><code>template&lt;class T&gt;\nstruct has_no_nested_type {};\n\n// I think you need some specialization for which the following class template\n// `non_immediate_context` can be instantiated, otherwise the program is\n// ill-formed, NDR\ntemplate&lt;&gt;\nstruct has_no_nested_type&lt;double&gt;\n{ using type = double; };\n\n// make the error appear NOT in the immediate context\ntemplate&lt;class T&gt;\nstruct non_immediate_context\n{\n    using type = typename has_no_nested_type&lt;T&gt;::type;\n};\n\n\ntemplate&lt;class T&gt;\ntypename non_immediate_context&lt;T&gt;::type\nfoo(T, int) { return {}; }\n\ntemplate&lt;class T&gt;\nbool foo(T) { return {}; }\n\n\nint main()\n{\n    foo(42);      // well-formed? clang++3.5 and g++4.8.2 accept it\n    foo&lt;int&gt;(42); // well-formed? clang++3.5 accepts it, but not g++4.8.2\n}\n</code></pre>\n<p>When instantiating the first function template <code>foo</code> for <code>T == int</code>, the substitution produces an invalid type not in the immediate context of <code>foo</code>. This leads to a hard error (this is what <a href=\"https://stackoverflow.com/q/22258054/420683\">the related question</a> is about.)</p>\n<p>However, when letting <code>foo</code> deduce its template-argument, g++ and clang++ agree that no instantiation takes place. As <a href=\"https://stackoverflow.com/questions/22258054/c-inconsistency-between-gcc-and-clang#comment33810551_22259156\">Johannes Schaub explains</a>, this is because there is a \"match error\".</p>\n<p><strong>Question: What is a \"match error\", and where and how is it specified in the Standard?</strong></p>\n<p><strong>Altenative question: Why is there a difference between <code>foo(42)</code> and <code>foo&lt;int&gt;(42)</code> for g++?</strong></p>\n<hr>\n<p>What I've found / tried so far:</p>\n<p>[over.match.funcs]/7 and [temp.over] seem to describe the overload resolution specifics for function templates. The latter seem to mandate the substitution of template parameters for <code>foo</code>.</p>\n<p>Interestingly, [over.match.funcs]/7 triggers the process described in [temp.over] <em>before</em> checking for viability of the function template (specialization).\nSimilarly, type deduction does not to take into account, say, default function arguments (other than making them a non-deduced context). It seems not to be concerned with viability, as far as I can tell.</p>\n<p>Another possibly important aspect is how type deduction is specified. It acts on single function parameters, but I don't see where the distinction is made between parameter types that contain / are dependent on template parameters (like <code>T const&amp;</code>) and those which aren't (like <code>int</code>).</p>\n<p>Yet, g++ makes a difference between explicitly specifying the template parameter (hard error) and letting them be deduced (deduction failure / SFINAE). Why?</p>\n</hr>", "Title": "Type deduction for non-viable function templates", "CreationDate": "2014-03-10T12:51:14.283", "LastActivityDate": "2014-03-14T21:25:31.517", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:05:29.167", "LastEditorUserId": "-1", "Id": "22300620", "Score": "3", "OwnerUserId": "420683", "Tags": "<c++><templates><overload-resolution><argument-deduction>", "AnswerCount": "1"}});