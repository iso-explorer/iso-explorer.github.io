post_cb({"35233561": {"ParentId": "35233468", "CommentCount": "6", "Body": "<p>The linker just has to figure out how to deduplicate all the definitions. That is of course provided that any function definitions have been emitted at all; inline functions may well be inlined. But should you take the address of an inline function with external linkage, you always get the same address (cf. [dcl.fct.spec]/4).</p>\n<p>Inline functions aren't the only construction which require linker support; templates are another, as are inline variables (in C++17).</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "35233561", "Score": "3", "CreationDate": "2016-02-05T21:09:22.500", "LastActivityDate": "2016-02-05T21:09:22.500"}, "35233651": {"ParentId": "35233468", "CommentCount": "1", "Body": "<p>If the function is, in fact, inlined, then there's nothing to link. It's only when, for whatever reason, the compiler decides <strong>not</strong> to expand the function inline that it has to generate an out-of-line version of the function. If the compiler generates an out-of-line version of the function for more than one translation unit you end up with more than one object file having definitions for the same \"inline\" function.</p>\n<p>The out-of-line definition gets compiled into the object file, and it's marked so that the linker won't complain if there is more than one definition of that name. If there is more than one, the linker simply picks one. Usually the first one it saw, but that's not required, and if the definitions are all the same, it doesn't matter. And that's why it's undefined behavior to have two or more different definitions of the same inline function: there's no rule for which one to pick. Anything can happen.</p>\n", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "35233651", "Score": "2", "CreationDate": "2016-02-05T21:15:24.740", "LastActivityDate": "2016-02-05T21:15:24.740"}, "35234109": {"ParentId": "35233468", "CommentCount": "6", "Body": "<p>I think the correct answer to your question is \"it depends\".</p>\n<p>Consider following pieces of code:</p>\n<p>File x.c (or x.cc):</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nvoid otherfunction(void);\n\ninline void inlinefunction(void) {\n    printf(\"inline 1\\n\");\n}\n\nint main(void) {\n    inlinefunction();\n    otherfunction();\n    return 0;\n}\n</code></pre>\n<p>File y.c (or y.cc)</p>\n<pre><code>#include &lt;stdio.h&gt;\n\ninline void inlinefunction(void) {\n    printf(\"inline 2\\n\");\n}\n\nvoid otherfunction(void) {\n    printf(\"otherfunction\\n\");\n    inlinefunction();\n}\n</code></pre>\n<p>As <code>inline</code> keyword is only a \"suggestion\" for the compile to inline the function different compilers with different flags behave differently. E.g. looks like C compiler always \"exports\" inline functions and does not allow for multiple definitions:</p>\n<pre><code>$ gcc x.c y.c &amp;&amp; ./a.out \n/tmp/ccy5GYHp.o: In function `inlinefunction':\ny.c:(.text+0x0): multiple definition of `inlinefunction'\n/tmp/ccQkn7m4.o:x.c:(.text+0x0): first defined here\ncollect2: ld returned 1 exit status\n</code></pre>\n<p>while C++ allows it:</p>\n<pre><code>$ g++ x.cc y.cc &amp;&amp; ./a.out \ninline 1\notherfunction\ninline 1\n</code></pre>\n<p>More interesting - let's try to switch order of files (and so - switch the order of linking):</p>\n<pre><code>$ g++ y.cc x.cc &amp;&amp; ./a.out \ninline 2\notherfunction\ninline 2\n</code></pre>\n<p>Well... it looks that first one counts! But... let's add some optimization flags:</p>\n<pre><code>$ g++ y.cc x.cc -O1 &amp;&amp; ./a.out \ninline 1\notherfunction\ninline 2\n</code></pre>\n<p>And that's the behavior we'd expect. Function got inlined. Different order of files changes nothing:</p>\n<pre><code>$ g++ x.cc y.cc -O1 &amp;&amp; ./a.out \ninline 1\notherfunction\ninline 2\n</code></pre>\n<p>Next we can extend our x.c (x.cc) source with prototype of <code>void anotherfunction(void)</code> and call it in our <code>main</code> function. Let's place <code>anotherfunction</code> definition in z.c (z.cc) file:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nvoid inlinefunction(void);\n\nvoid anotherfunction(void) {\n    printf(\"anotherfunction\\n\");\n    inlinefunction();\n}\n</code></pre>\n<p>We do not define the body of <code>inlinefunction</code> this time. Compilation/execution for c++ gives following results:</p>\n<pre><code>$ g++ x.cc y.cc z.cc &amp;&amp; ./a.out \ninline 1\notherfunction\ninline 1\nanotherfunction\ninline 1\n</code></pre>\n<p>Different order:</p>\n<pre><code>$ g++ y.cc x.cc z.cc &amp;&amp; ./a.out \ninline 2\notherfunction\ninline 2\nanotherfunction\ninline 2\n</code></pre>\n<p>Optimization:</p>\n<pre><code>$ g++ x.cc y.cc z.cc -O1 &amp;&amp; ./a.out \n/tmp/ccbDnQqX.o: In function `anotherfunction()':\nz.cc:(.text+0xf): undefined reference to `inlinefunction()'\ncollect2: ld returned 1 exit status\n</code></pre>\n<p>So conclusion is: the best is to declare <code>inline</code> together with <code>static</code>, which narrows the scope of the function usage, because \"exporting\" the function which we'd like to be used inline makes no sense.</p>\n", "OwnerUserId": "5128826", "PostTypeId": "2", "Id": "35234109", "Score": "1", "CreationDate": "2016-02-05T21:46:59.490", "LastActivityDate": "2016-02-05T21:46:59.490"}, "35234495": {"ParentId": "35233468", "LastEditDate": "2016-02-05T22:41:13.517", "CommentCount": "7", "CreationDate": "2016-02-05T22:16:00.670", "OwnerUserId": "2402272", "LastEditorUserId": "2402272", "PostTypeId": "2", "Id": "35234495", "Score": "2", "Body": "<p><code>inline</code> or no <code>inline</code>, C does not permit multiple external definitions of the same name among the translation units contributing to the same program or library.  Furthermore, it does not permit multiple definitions of the same name in the same translation unit, whether internal, external, or inline.  Therefore, there can be at most two available definitions of a given function in scope in any given translation unit: one internal and/or inline, and one external.</p>\n<p>C 2011, 6.7.4/7 has this to say:</p>\n<blockquote>\n<p id=\"so_35233468_35234495_0\">Any function with internal linkage can be an inline function.  For a function with external\n  linkage, the following restrictions apply: If a function is declared with an\n  <code>inline</code>\n  function specifier, then it shall also be defined in the same translation unit.  If all of the\n  file scope declarations for a function in a translation unit include the\n  <code>inline</code>\n  function\n  specifier without\n  <code>extern</code>\n  ,  then the definition in that translation unit is an\n  inline\n  definition\n  .  <strong>An inline definition does not provide an external definition for the function,</strong>\n  and does not forbid an external definition in another translation unit.  An inline definition\n  provides an alternative to an external definition, which a translator may use to implement\n  any call to the function in the same translation unit.  <strong>It is unspecified whether a call to the\n  function uses the inline definition or the external definition.</strong></p>\n</blockquote>\n<p>(Emphasis added.)</p>\n<p>In specific answer to your questions, then, as they pertain to C:</p>\n<blockquote>\n<p id=\"so_35233468_35234495_1\">Are all definitions included in the final executable or shared-library?</p>\n</blockquote>\n<p>Inline definitions are not external definitions.  They may or may not be included as actual functions, as inlined code, both, or neither, depending on the foibles of the compiler and linker and on details of their usage.  They are not in any case callable by name by functions from different translation units, so whether they should be considered \"included\" is a bit of an abstract question.</p>\n<blockquote>\n<p id=\"so_35233468_35234495_2\">Do all invocations of the function link against the same definition?</p>\n</blockquote>\n<p>C does not specify, but it allows for the answer to be \"no\", even for different calls within the same translation unit.  Moreover, inline functions are not external, so no inline function defined in one translation unit is ever called (directly) by a function defined in a different translation unit.</p>\n<blockquote>\n<p id=\"so_35233468_35234495_3\">Are the answers to the above questions required by one or more of the C and C++ ISO standards, and if not, do most common platforms do the same thing?</p>\n</blockquote>\n<p>My answers are based on the current C standard to the extent that it addresses the questions, but as you will have seen, those answers are not entirely prescriptive.  Moreover, the standard does not directly address any question of object code or linking, so you may have noticed that my answers are not, for the most part, couched in those terms.</p>\n<p>In any case, it is not safe to assume that any given C system is consistent even with itself in these regards for different functions or in different contexts.  Under some circumstances it may inline every call to an internal or inline function, so that that function does not appear as a separate function at all.  At other times it may indeed emit a function with internal linkage, but that does not prevent it from inlining some calls to that function anyway.  In any case, internal functions are not eligible to be linked to functions from other translation units, so the linker is not necessarily involved with linking them at all.</p>\n", "LastActivityDate": "2016-02-05T22:41:13.517"}, "35233468": {"CommentCount": "9", "ViewCount": "531", "PostTypeId": "1", "LastEditorUserId": "1858225", "LastActivityDate": "2016-02-06T00:26:45.817", "Body": "<p>In both C and C++, <code>inline</code> functions with external linkage can of course have multiple definitions available at link-time, the assumption being that these definitions are all (hopefully) identical. (I am of course referring to functions declared with the <code>inline</code> linkage specification, not to functions that the compiler or link-time-optimizer actually inlines.)</p>\n<p>So what do common linkers typically <em>do</em> when they encounter multiple definitions of a function? In particular:</p>\n<ul>\n<li>Are all definitions included in the final executable or shared-library?</li>\n<li>Do all invocations of the function link against the same definition?</li>\n<li>Are the answers to the above questions required by one or more of the C and C++ ISO standards, and if not, do most common platforms do the same thing?</li>\n</ul>\n<p>P.S. Yes, I know C and C++ are separate languages, but they both support <code>inline</code>, and their compiler-output can typically be linked by the same linker (e.g. GCC's <code>ld</code>), so I believe there cannot be any difference between them in this aspect.</p>\n", "Title": "What do linkers actually do with multiply-defined `inline` functions?", "FavoriteCount": "0", "LastEditDate": "2016-02-06T00:26:45.817", "Id": "35233468", "Score": "6", "CreationDate": "2016-02-05T21:03:51.713", "Tags": "<c++><c><linker><inline>", "OwnerUserId": "1858225", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_35233468_35234495_2": {"section_id": 3512, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_35233468_35234495_2": {"section_id": 3377, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_35233468_35234495_2": {"section_id": 4275, "quality": 0.5714285714285714, "length": 4}}}});