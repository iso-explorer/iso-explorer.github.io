post_cb({"bq_ids": {"n4140": {"so_28136547_28136600_0": {"length": 9, "quality": 1.0, "section_id": 6133}}, "n3337": {"so_28136547_28136600_0": {"length": 9, "quality": 1.0, "section_id": 5897}}, "n4659": {"so_28136547_28136600_0": {"length": 9, "quality": 1.0, "section_id": 7630}}}, "28136547": {"ViewCount": "1077", "Body": "<p>I'm wondering if it's possible in c++ to get pure function pointer from member function of an object.</p>\n<pre><code>class AS\n{\n    int x;\npublic:\n    AS(int xx)\n    {\n        x = xx;\n    }\n\n    void ww(void* p)\n    {\n        std::cerr &lt;&lt; \"AS::ww \" &lt;&lt; x &lt;&lt; std::endl;\n    }\n};\n\nvoid exp()\n{\n    void* pp = 0;\n    AS aa(9);\n    ((aa).*(&amp;AS::ww))(pp);//compiles and work fine\n    auto ff = ((aa).*(&amp;AS::ww));//not compiling\n}\n</code></pre>\n<p>I've tried just keeping the calling part:</p>\n<pre><code>    auto ff = ((aa).*(&amp;AS::ww));\n</code></pre>\n<p>but this gives me <code>error: unable to deduce \u2018auto\u2019 from \u2018aa.*&amp;AS::ww\u2019</code></p>\n<p>so why is that? It has no type?</p>\n<p>How do you call one who has no type?</p>\n", "AcceptedAnswerId": "28136600", "Title": "Member function, unable to deduce \u2018auto\u2019", "CreationDate": "2015-01-25T12:47:02.050", "Id": "28136547", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-01-25T14:35:16.190", "Score": "1", "OwnerUserId": "620029", "Tags": "<c++><function-pointers><auto>", "AnswerCount": "2"}, "28137556": {"Id": "28137556", "PostTypeId": "2", "Body": "<p>This particular problem is typically caused by interfacing with C callbacks (the `void* argument is a giveaway). The solution is to realize that in these cases, <em>you</em> control the void*. </p>\n<p>Thus:</p>\n<pre><code>class AS\n{\n    int x;\npublic:\n    AS(int xx)\n    {\n        x = xx;\n    }\n    void ww()\n    {\n        std::cerr &lt;&lt; \"AS::ww \" &lt;&lt; this &lt;&lt; std::endl;\n    }\n    static void ww(void* p)\n    {\n        static_cast&lt;AS*&gt;(p)-&gt;ww();\n    }\n};\nsetupCcallback(&amp;AS::ww, static_cast&lt;void*&gt;(&amp;aa));\n</code></pre>\n", "LastActivityDate": "2015-01-25T14:35:16.190", "CommentCount": "0", "CreationDate": "2015-01-25T14:35:16.190", "ParentId": "28136547", "Score": "0", "OwnerUserId": "15416"}, "28136600": {"Id": "28136600", "PostTypeId": "2", "Body": "<p>IIRC some implementations support to keep such closures in objects, but it isn't standard compliant. [expr.mptr.oper]/6:</p>\n<blockquote>\n<p id=\"so_28136547_28136600_0\">If the result of <code>.*</code> or <code>-&gt;*</code> is a function, then <strong>that result can be used\n  only as the operand for the function call operator <code>()</code>.</strong></p>\n</blockquote>\n<p>However, as of C++11 (which you must be using since you're using <code>auto</code>), use <code>std::bind</code> or a lambda:</p>\n<pre><code>auto ff = [&amp;] (void* p) {return aa.ww(p);};\n</code></pre>\n", "LastActivityDate": "2015-01-25T12:52:25.550", "CommentCount": "5", "CreationDate": "2015-01-25T12:52:25.550", "ParentId": "28136547", "Score": "4", "OwnerUserId": "3647361"}});