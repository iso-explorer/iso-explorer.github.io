post_cb({"28137556": {"ParentId": "28136547", "CommentCount": "0", "Body": "<p>This particular problem is typically caused by interfacing with C callbacks (the `void* argument is a giveaway). The solution is to realize that in these cases, <em>you</em> control the void*. </p>\n<p>Thus:</p>\n<pre><code>class AS\n{\n    int x;\npublic:\n    AS(int xx)\n    {\n        x = xx;\n    }\n    void ww()\n    {\n        std::cerr &lt;&lt; \"AS::ww \" &lt;&lt; this &lt;&lt; std::endl;\n    }\n    static void ww(void* p)\n    {\n        static_cast&lt;AS*&gt;(p)-&gt;ww();\n    }\n};\nsetupCcallback(&amp;AS::ww, static_cast&lt;void*&gt;(&amp;aa));\n</code></pre>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "28137556", "Score": "0", "CreationDate": "2015-01-25T14:35:16.190", "LastActivityDate": "2015-01-25T14:35:16.190"}, "28136600": {"ParentId": "28136547", "CommentCount": "5", "Body": "<p>IIRC some implementations support to keep such closures in objects, but it isn't standard compliant. [expr.mptr.oper]/6:</p>\n<blockquote>\n<p id=\"so_28136547_28136600_0\">If the result of <code>.*</code> or <code>-&gt;*</code> is a function, then <strong>that result can be used\n  only as the operand for the function call operator <code>()</code>.</strong></p>\n</blockquote>\n<p>However, as of C++11 (which you must be using since you're using <code>auto</code>), use <code>std::bind</code> or a lambda:</p>\n<pre><code>auto ff = [&amp;] (void* p) {return aa.ww(p);};\n</code></pre>\n", "OwnerUserId": "3647361", "PostTypeId": "2", "Id": "28136600", "Score": "4", "CreationDate": "2015-01-25T12:52:25.550", "LastActivityDate": "2015-01-25T12:52:25.550"}, "28136547": {"CommentCount": "2", "ViewCount": "1077", "CreationDate": "2015-01-25T12:47:02.050", "LastActivityDate": "2015-01-25T14:35:16.190", "Title": "Member function, unable to deduce \u2018auto\u2019", "AcceptedAnswerId": "28136600", "PostTypeId": "1", "Id": "28136547", "Score": "1", "Body": "<p>I'm wondering if it's possible in c++ to get pure function pointer from member function of an object.</p>\n<pre><code>class AS\n{\n    int x;\npublic:\n    AS(int xx)\n    {\n        x = xx;\n    }\n\n    void ww(void* p)\n    {\n        std::cerr &lt;&lt; \"AS::ww \" &lt;&lt; x &lt;&lt; std::endl;\n    }\n};\n\nvoid exp()\n{\n    void* pp = 0;\n    AS aa(9);\n    ((aa).*(&amp;AS::ww))(pp);//compiles and work fine\n    auto ff = ((aa).*(&amp;AS::ww));//not compiling\n}\n</code></pre>\n<p>I've tried just keeping the calling part:</p>\n<pre><code>    auto ff = ((aa).*(&amp;AS::ww));\n</code></pre>\n<p>but this gives me <code>error: unable to deduce \u2018auto\u2019 from \u2018aa.*&amp;AS::ww\u2019</code></p>\n<p>so why is that? It has no type?</p>\n<p>How do you call one who has no type?</p>\n", "Tags": "<c++><function-pointers><auto>", "OwnerUserId": "620029", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_28136547_28136600_0": {"section_id": 6133, "quality": 1.0, "length": 9}}, "n3337": {"so_28136547_28136600_0": {"section_id": 5897, "quality": 1.0, "length": 9}}, "n4659": {"so_28136547_28136600_0": {"section_id": 7630, "quality": 1.0, "length": 9}}}});