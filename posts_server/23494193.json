post_cb({"23494499": {"Id": "23494499", "PostTypeId": "2", "Body": "<p>There are actually two different flavors of the One Definition Rule.</p>\n<p>One flavor, which applies to global and namespace variables, static class members, and functions without the <code>inline</code> keyword, says that there can only be one definition in the entire program.  These are the things that typically go in *.cpp files.</p>\n<p>The other flavor, which applies to type definitions, functions ever declared with the <code>inline</code> keyword, and anything with a template parameter, says that the definition can appear once per translation unit but must be defined with the same source and have the same meaning in each.  It's legal to copy-paste into two *.cpp files as you did, but typically you would put these things in a header file and <code>#include</code> that header from all the *.cpp files that need them.</p>\n", "LastActivityDate": "2014-05-06T12:17:37.477", "CommentCount": "1", "CreationDate": "2014-05-06T12:17:37.477", "ParentId": "23494193", "Score": "0", "OwnerUserId": "459640"}, "23494475": {"Id": "23494475", "PostTypeId": "2", "Body": "<p>Classes can't be used (except in very limited ways) unless the definition is available within the translation unit that uses it. This means that you need multiple definitions in order to use it in multiple units, and so the language allows that - as long as all the definitions are identical. The same rules apply to various other entities (such as templates and inline functions) for which a definition is needed at the point of use.</p>\n<p>Usually, you would share the definition by putting it in a header, and including that wherever it's needed.</p>\n<p>Variables can be used with only a declaration, not the definition, so there's no need to allow multiple definitions. In your case, you could fix the error by making one of them a pure declaration:</p>\n<pre><code>extern int a;\n</code></pre>\n<p>so that there is only one definition. Again, it's common for such declarations to go in headers, to make sure they're the same in every file that uses them.</p>\n<p>For the full, gory details of the One Definition Rule, see C++11 3.2, [basic.def.odr].</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2014-05-06T12:38:01.830", "Score": "0", "CreationDate": "2014-05-06T12:16:36.913", "ParentId": "23494193", "CommentCount": "2", "OwnerUserId": "204847", "LastEditDate": "2014-05-06T12:38:01.830"}, "23494193": {"ViewCount": "479", "Body": "<p>Let I've two cpp files:</p>\n<pre><code>//--a.cpp--//\nclass A\n{\npublic:\n    void bar()\n    {\n        printf(\"class A\");\n    }\n};\n//--b.cpp--//\nclass A\n{\npublic:\n    void bar()\n    {\n        printf(\"class A\");\n    }\n};\n</code></pre>\n<p>When I'm compling and linking this files together I have no errors. But if I'll write the following:</p>\n<pre><code>//--a.cpp--//\nint a;\n//--b.cpp--//\nint a;\n</code></pre>\n<p>After compiling and linking this sources I've an error as the redefiniton of <code>a</code>. But in the case of classes I've redefinition to, but there is no error is raised. I'm confused.</p>\n", "AcceptedAnswerId": "23494320", "Title": "Why class redefinition in a several cpp files is permitted", "CreationDate": "2014-05-06T12:02:41.533", "LastActivityDate": "2014-05-06T13:12:25.047", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-05-06T12:37:56.187", "OwnerDisplayName": "user2953119", "LastEditorUserId": "147192", "Id": "23494193", "ClosedDate": "2014-05-06T17:30:09.783", "Score": "7", "Tags": "<c++><class><definition>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_23494193_23494320_1": {"length": 13, "quality": 1.0, "section_id": 7042}, "so_23494193_23494320_0": {"length": 14, "quality": 1.0, "section_id": 7038}, "so_23494193_23494320_2": {"length": 46, "quality": 1.0, "section_id": 7043}}, "n3337": {"so_23494193_23494320_1": {"length": 13, "quality": 1.0, "section_id": 6787}, "so_23494193_23494320_0": {"length": 14, "quality": 1.0, "section_id": 6784}, "so_23494193_23494320_2": {"length": 46, "quality": 1.0, "section_id": 6788}}, "n4659": {"so_23494193_23494320_1": {"length": 13, "quality": 1.0, "section_id": 8539}, "so_23494193_23494320_0": {"length": 14, "quality": 1.0, "section_id": 8535}, "so_23494193_23494320_2": {"length": 46, "quality": 1.0, "section_id": 8540}}}, "23494320": {"Id": "23494320", "PostTypeId": "2", "Body": "<p>Classes are types. For the most part, they are compile-time artifacts; global variables, on the other hand, are runtime artifacts.</p>\n<p>In your first example, each translation unit has its own definition of <code>class a</code>. Since the translation units are separate from each other, and because they do not produce global runtime artifacts with identical names, this is OK. The standard requires that there be exactly one definition of a class per translation unit - see sections 3.2.1 and 3.2.4:</p>\n<blockquote>\n<p id=\"so_23494193_23494320_0\">No translation unit shall contain more than one definition of any variable, function, class type, enumeration type, or template.</p>\n<p id=\"so_23494193_23494320_1\">Exactly one definition of a class is required in a translation unit if the class is used in a way that requires the class type to be complete.</p>\n</blockquote>\n<p>However, the standard permits multiple class definitions in separate translation units - see section 3.2.6:</p>\n<blockquote>\n<p id=\"so_23494193_23494320_2\">There can be more than one definition of a class type, enumeration type, inline function with external linkage, class template, non-static function template, static data member of a class template, member function of a class template, or template specialization for\n  which some template parameters are not specified in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. [...]</p>\n</blockquote>\n<p>What follows is a long list of requirements, which boils down to that the two class definitions need to be the same; otherwise, the program is considered ill-formed.</p>\n<p>In your second example you are defining a global runtime artifact (variable <code>int a</code>) in two translation units. When the linker tries to produce the final output (an executable or a library) it finds both of these, and issues a redefinition error. Note that the rule 3.2.6 above does not include variables with external linkage.</p>\n<p>If you declare your variables <code>static</code>, your program will compile, because static variables are local to a translation unit in which they are defined.</p>\n<p>Although both programs would compile, the reasons why they compile are different: in case of multiple class definitions the compiler assumes that the two classes are the same; in the second case, the compiler considers the two variables independent of each other.</p>\n", "LastEditorUserId": "335858", "LastActivityDate": "2014-05-06T13:12:25.047", "Score": "10", "CreationDate": "2014-05-06T12:09:46.273", "ParentId": "23494193", "CommentCount": "5", "OwnerUserId": "335858", "LastEditDate": "2014-05-06T13:12:25.047"}, "23494256": {"Id": "23494256", "PostTypeId": "2", "Body": "<p>The <code>.cpp</code> files compile in separated translation units. There is no conflict.</p>\n<p>The problem comes when you declare them in one translation unit beside each other. For example writing them in <code>.h</code> files and include them beside each other.</p>\n<p>Defining <code>a</code> in separated <code>.cpp</code> files also has no problem unless you declare them in their corresponding <code>.h</code> files and including them in a single translation unit which I guess you're doing it in your case.</p>\n", "LastActivityDate": "2014-05-06T12:06:28.457", "CommentCount": "0", "CreationDate": "2014-05-06T12:06:28.457", "ParentId": "23494193", "Score": "0", "OwnerUserId": "952747"}});