post_cb({"bq_ids": {"n4140": {"so_17551256_17551739_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 2753}, "so_17551256_17551739_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 2777}}, "n3337": {"so_17551256_17551739_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 2714}, "so_17551256_17551739_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 2738}}, "n4659": {"so_17551256_17551739_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 3491}, "so_17551256_17551739_1": {"length": 18, "quality": 0.8571428571428571, "section_id": 3515}}}, "17552237": {"Id": "17552237", "PostTypeId": "2", "Body": "<p>It's safe to assume that the mutex won't throw if you can <em>guarantee</em> that none of the error conditions (as outlined in hmjd's answer) are present. How to put that call into a noexcept function depends on how you want to handle an (pretty impossible) failure. If the default of noexcept (to call <a href=\"http://en.cppreference.com/w/cpp/error/terminate\" rel=\"nofollow\"><code>std::terminate</code></a> is acceptable, you don't need to do anything. If you want to do log the impossible error, wrap the function in a try/catch clause.</p>\n", "OwnerDisplayName": "user283145", "LastActivityDate": "2013-07-09T15:30:22.403", "Score": "1", "CreationDate": "2013-07-09T15:30:22.403", "ParentId": "17551256", "CommentCount": "0"}, "17551256": {"ViewCount": "1774", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/thread/mutex/lock\" rel=\"nofollow\">CPPReference</a>, it isn't said explicitly that the lock function of <code>std::mutex</code> won't throw if the lock won't result in a dead lock.</p>\n<p><a href=\"http://www.sourceware.org/pthreads-win32/manual/pthread_mutex_init.html\" rel=\"nofollow\">PThread's lock</a> only have a deadlock error. I don't know for window's implementation of thread. I also don't know if they are other implementation of thread used as backend of <code>std::thread</code>/<code>std::mutex</code>.</p>\n<p>So my question is \"Should I write my code as if, some times, for no special reason, a lock may fail?\".</p>\n<p>I actually need to lock a mutex in some noexcept methods, and I want to be sure that they are noexcept.</p>\n", "AcceptedAnswerId": "17551739", "Title": "Could std::mutex::lock throw event if everything looks \"good\"?", "CreationDate": "2013-07-09T14:45:15.563", "Id": "17551256", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-10-13T17:10:10.660", "LastEditorUserId": "3204551", "LastActivityDate": "2015-10-13T17:10:10.660", "Score": "4", "OwnerUserId": "2535207", "Tags": "<c++><c++11><exception><locking><mutex>", "AnswerCount": "2"}, "17551739": {"Id": "17551739", "PostTypeId": "2", "Body": "<p>The <code>std::mutex::lock()</code> member function is not declared as <code>noexcept</code> and from section <em>30.4.1.2 Mutex types</em> of the c++11 standard (draft n3337), clause 6:</p>\n<blockquote>\n<p id=\"so_17551256_17551739_0\">The expression <code>m.lock()</code> shall be well-formed and have the following semantics:</p>\n<ul>\n<li>...</li>\n<li>Throws: <code>system_error</code> when an exception is required (30.2.2).</li>\n<li>Error conditions:\n  <ul>\n<li><code>operation_not_permitted</code> \u2014 if the thread does not have the privilege to perform the operation.</li>\n<li><code>resource_deadlock_would_occur</code> \u2014 if the implementation detects that a deadlock would occur.</li>\n<li><code>device_or_resource_busy</code> \u2014 if the mutex is already locked and blocking is not possible.</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>This implies that any function that uses <code>mutex::lock()</code> cannot be marked <code>noexcept</code>, unless that function is capable of handling the exception itself and prevents it from propogating to the caller.</p>\n<hr>\n<p>I am unable to comment on the likelihood of these error conditions occuring, but in relation to <code>std::mutex</code> and <code>resource_deadlock_would_occur</code> (which <em>might</em> be thrown) it indicates a bug in the code as opposed to a runtime a failure as this error <em>might</em> be raised if a thread attempts to lock a <code>std::mutex</code> it already owns. From section <em>30.4.1.2.1 Class mutex</em>, clause 4:</p>\n<blockquote>\n<p id=\"so_17551256_17551739_1\">[ Note: A program may deadlock if the thread that owns a mutex object calls lock() on that object. If the implementation can detect the deadlock, a resource_deadlock_would_occur error condition may be observed. \u2014end note ]</p>\n</blockquote>\n<p>By selecting <code>std::mutex</code> as the lock type the programmer is explicitly stating that an attempt by the same thread to lock a <code>mutex</code> it already has locked is not possible.\nIt if is a legal path of execution for a thread to re-lock a <code>mutex</code> then a <a href=\"http://en.cppreference.com/w/cpp/thread/recursive_mutex\" rel=\"noreferrer\"><code>std:recursive_mutex</code></a> is the more appropriate choice (but changing to a <code>recursive_lock</code> does not mean the <code>lock()</code> function is exception free).</p>\n</hr>", "LastEditorUserId": "1033896", "LastActivityDate": "2013-07-09T15:42:00.140", "Score": "7", "CreationDate": "2013-07-09T15:06:47.117", "ParentId": "17551256", "CommentCount": "1", "OwnerUserId": "1033896", "LastEditDate": "2013-07-09T15:42:00.140"}});