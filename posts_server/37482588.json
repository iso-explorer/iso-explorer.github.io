post_cb({"bq_ids": {"n4140": {"so_37482588_37502709_1": {"length": 20, "quality": 1.0, "section_id": 599}, "so_37482588_37502709_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 6181}}, "n3337": {"so_37482588_37502709_1": {"length": 20, "quality": 1.0, "section_id": 589}, "so_37482588_37502709_0": {"length": 17, "quality": 1.0, "section_id": 5942}}, "n4659": {"so_37482588_37502709_1": {"length": 20, "quality": 1.0, "section_id": 622}, "so_37482588_37502709_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 7683}}}, "37502709": {"Id": "37502709", "PostTypeId": "2", "Body": "<p>Digging through Section 8.5.4 of the standard and following various cross references therein, I think I understand what's going on.  Of course, IANAL, so I might be wrong; this is my best effort.</p>\n<p><strong>Update:</strong> The previous version of the answer actually used multiple conversions.  I've updated it to reflect my current understanding.</p>\n<p>The key to unraveling the mess is the fact that a braced-init-list is <strong>not</strong> an expression (which also explains why <code>d &lt;&lt; {{\"char *\"}}</code> won't compile).  What it is is special syntax, governed by special rules, that is allowed in a number of specific contexts.  Of these contexts, the relevant ones for our discussion are: rhs of assignment, argument in a function call, and argument in a constructor invocation.</p>\n<p>So what happens when the compiler sees <code>b = {{\"char *\"}}</code>?  This is a case of rhs of assignment.  The applicable rule is:</p>\n<blockquote>\n<p id=\"so_37482588_37502709_0\">A <em>braced-init-list</em> may appear on the right-hand side of ... an assignment defined by a user-defined assignment operator, in which case the initializer list is passed\n  as the argument to the operator function.</p>\n</blockquote>\n<p>(Presumably, the default copy assignment operator is considered a <em>user-defined assignment operator</em>.  I couldn't find a definition of that term anywhere, and there doesn't seem to be any language allowing the brace syntax specifically for default copy assignment.)</p>\n<p>So we are reduced to argument passing to the default copy assignment operator <code>B::operator=(const B&amp;)</code>, where the argument being passed is <code>{{\"char *\"}}</code>.  Because a braced-init-list is not an expression, there is no issue of conversion here, but rather a form of initialization of a temporary of type <code>B</code>, specifically, so called <em>list initialization</em>.</p>\n<blockquote>\n<p id=\"so_37482588_37502709_1\">If no viable initializer-list constructor is found, overload resolution is performed again, where the\n  candidate functions are all the constructors of the class T and the argument list consists of the elements\n  of the initializer list.</p>\n</blockquote>\n<p>So the compiler strips off the outer pair of braces and performs overload resolution using <code>{\"char *\"}</code> as the argument.  This succeeds, matching the constructor <code>B::B(const A&amp;)</code> because there is again list initialization of a temporary of type <code>A</code> in which overload resolution succeeds to match <code>A::A(const string&amp;)</code> for the argument <code>\"char *\"</code>, which is possible through the one alloted user-defined conversion, namely, from <code>char*</code> to <code>string</code>.</p>\n<p>Now, in the case of <code>c = {{\"char *\"}}</code> the process is similar, but when we try to list-initialize a temporary of type <code>C</code> with <code>{{\"char *\"}}</code>, overload resolution fails to find a constructor that matches.  The point is that by definition list-initialization only works through a constructor whose parameter list can be made to match the contents of the list.</p>\n", "LastEditorUserId": "82570", "LastActivityDate": "2016-05-29T06:36:30.967", "Score": "0", "CreationDate": "2016-05-28T18:50:56.467", "ParentId": "37482588", "CommentCount": "0", "LastEditDate": "2016-05-29T06:36:30.967", "OwnerUserId": "82570"}, "37482588": {"ViewCount": "315", "Body": "<p>I've recently read somewhere (can't remember where) about using braces to allow multiple user-defined conversions, but there seems to be a difference between conversion by constructor and conversion by conversion method that I don't understand.</p>\n<p>Consider:</p>\n<pre><code>#include &lt;string&gt;\n\nusing ::std::string;\n\nstruct C {\n  C() {}\n};\n\nstruct A {\n  A(const string&amp; s) {}  // Make std::string convertible to A.\n  operator C() const { return C(); }  // Makes A convertible to C.\n};\n\nstruct B {\n  B() {}\n  B(const A&amp; a) {}  // Makes A convertible to B.\n};\n\nint main() {\n  B b;\n  C c;\n\n  // This works.\n  // Conversion chain (all thru ctors): char* -&gt; string -&gt; A -&gt; B\n  b = {{\"char *\"}};\n\n  // These two attempts to make the final conversion through A's\n  // conversion method yield compiler errors.\n  c = {{\"char *\"}};\n  c = {{{\"char *\"}}};\n  // On the other hand, this does work (not surprisingly).\n  c = A{\"char *\"};\n}\n</code></pre>\n<p>Now, I may be misinterpreting what the compiler is doing, but (based on the above and additional experimentation) it seems to me that it's not considering conversions by conversion-method.  Reading through Sections 4 and 13.3.3.1 of the standard, however, I wasn't able to find a clue why this is.  What is the explanation?</p>\n<p><strong>Update</strong></p>\n<p>Here's another interesting phenomenon I'd like explained.  If I add</p>\n<pre><code>struct D {\n  void operator&lt;&lt;(const B&amp; b) {}\n};\n</code></pre>\n<p>and in <code>main</code>:</p>\n<pre><code>  D d;\n  d &lt;&lt; {{ \"char *\" }};\n</code></pre>\n<p>I get an error, but if instead I write <code>d.operator&lt;&lt;({{ \"char *\" }});</code> it works fine.</p>\n<p><strong>Update 2</strong></p>\n<p>Looks like Section 8.5.4 in the standard may hold some answers.  I'll report my findings.</p>\n", "Title": "C++ implicit conversions with brace initializers", "CreationDate": "2016-05-27T11:40:01.887", "LastActivityDate": "2016-05-29T06:36:30.967", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-05-28T11:21:33.020", "LastEditorUserId": "82570", "Id": "37482588", "Score": "8", "OwnerUserId": "82570", "Tags": "<c++><c++11><implicit-conversion><brace-initialization>", "AnswerCount": "2"}, "37482984": {"Id": "37482984", "PostTypeId": "2", "Body": "<p>There is one user conversion possible.</p>\n<p>In <code>b = {{\"char *\"}};</code></p>\n<p>we actually do</p>\n<pre><code>b = B{{\"char*\"}}; // B has constructor with A (and a copy constructor not viable here)\n</code></pre>\n<p>so</p>\n<pre><code>b = B{A{\"char*\"}}; // One implicit conversion const char* -&gt; std::string\n</code></pre>\n<p>in <code>c = {{\"const char*\"}}</code>, we try</p>\n<pre><code>c = C{{\"char *\"}}; // but nothing to construct here.\n</code></pre>\n", "LastActivityDate": "2016-05-27T11:59:49.983", "CommentCount": "5", "CreationDate": "2016-05-27T11:59:49.983", "ParentId": "37482588", "Score": "5", "OwnerUserId": "2684539"}});