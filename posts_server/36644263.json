post_cb({"36644696": {"ParentId": "36644263", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2016-04-15T10:29:22.633", "Score": "4", "LastEditorUserId": "3435400", "LastEditDate": "2016-04-15T12:01:33.407", "Id": "36644696", "OwnerUserId": "3435400", "Body": "<p>You could 'abuse' <code>shared_ptr</code> for this:</p>\n<pre><code>m_theVariableToChange = true;\nstd::shared_ptr&lt;void&gt; resetFalse(nullptr, [&amp;](void*){ m_theVariableToChange = false; });\n</code></pre>\n<hr>\n<p>If there are concerns about using <code>void</code> as template parameter <code>T</code>, I found the following in the C++ standard:</p>\n<p>20.8.2.2\u00a72:</p>\n<blockquote>\n<p id=\"so_36644263_36644696_0\">... The template parameter T of shared_ptr may be an incomplete type.</p>\n</blockquote>\n<p>This indicates that <code>T</code> is only used as a pointer, therefore using <code>void</code> should be fine.</p>\n</hr>", "LastActivityDate": "2016-04-15T12:01:33.407"}, "36644501": {"ParentId": "36644263", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2016-04-15T10:20:48.157", "Score": "8", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:54:22.457", "Id": "36644501", "OwnerUserId": "3747990", "Body": "<p>Not yet (there have been proposals for this). But implementing a generic one is simple enough;</p>\n<pre><code>struct scope_exit {\n  std::function&lt;void()&gt; f_;\n  explicit scope_exit(std::function&lt;void()&gt; f) noexcept : f_(std::move(f)) {}\n  ~scope_exit() { if (f_) f_(); }\n};\n// ...\nm_theVariableToChange = true;\nscope_exit resetFalse([&amp;m_theVariableToChange]() { m_theVariableToChange = false; });\n</code></pre>\n<p><em>For simplicity above, I've redacted the copy and move constructors etc...</em></p>\n<p>Marking them as <code>= delete</code> will make the above a minimal solution. Further; moving could be allowed if desired, but copying should be prohibited.</p>\n<hr>\n<p>A more complete <code>scope_exit</code> would look like (<a href=\"http://coliru.stacked-crooked.com/a/f5f75588e2fcba91\" rel=\"nofollow noreferrer\">online demo here</a>);</p>\n<pre><code>template &lt;typename F&gt;\nstruct scope_exit {\n  F f_;\n  bool run_;\n  explicit scope_exit(F f) noexcept : f_(std::move(f)), run_(true) {}\n  scope_exit(scope_exit&amp;&amp; rhs) noexcept : f_((rhs.run_ = false, std::move(rhs.f_))), run_(true) {}\n  ~scope_exit()\n  {\n    if (run_)\n      f_(); // RAII semantics apply, expected not to throw\n  }\n\n  // \"in place\" construction expected, no default ctor provided either\n  // also unclear what should be done with the old functor, should it\n  // be called since it is no longer needed, or not since *this is not\n  // going out of scope just yet...\n  scope_exit&amp; operator=(scope_exit&amp;&amp; rhs) = delete;\n  // to be explicit...\n  scope_exit(scope_exit const&amp;) = delete;\n  scope_exit&amp; operator=(scope_exit const&amp;) = delete;\n};\n\ntemplate &lt;typename F&gt;\nscope_exit&lt;F&gt; make_scope_exit(F&amp;&amp; f) noexcept\n{\n  return scope_exit&lt;F&gt;{ std::forward&lt;F&gt;(f) };\n}\n</code></pre>\n<p>Notes on the implementation;</p>\n<ul>\n<li><code>std::function&lt;void()&gt;</code> can be used to erase the type of the functor. <code>std::function&lt;void()&gt;</code> offers exception guarantees on the move constructors based on the exception specific of the held function. A sample of this implementation is found <a href=\"http://coliru.stacked-crooked.com/a/64d5b3a0422d6142\" rel=\"nofollow noreferrer\">here</a></li>\n<li>These exception specifications are consistent the C++ proposal and GSL implementations</li>\n<li>I've redacted most of the motivation for the <code>noexcept</code>, more substantial detail is found in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0052r1.pdf\" rel=\"nofollow noreferrer\">C++ proposal</a></li>\n<li>The \"usual\" RAII semantics of the destructor, hence the \"scope exit\" function is applicable; it will not <code>throw</code>, this is also consistent with the C++11 specification on the default exception specification for a destructor. See <a href=\"http://en.cppreference.com/w/cpp/language/destructor\" rel=\"nofollow noreferrer\">cppreference</a>, <a href=\"https://stackoverflow.com/q/130117/3747990\">SO Q&amp;A</a>, <a href=\"http://www.gotw.ca/gotw/047.htm\" rel=\"nofollow noreferrer\">GotW#47</a> and <a href=\"http://www.codingstandard.com/rule/15-2-1-do-not-throw-an-exception-from-a-destructor/\" rel=\"nofollow noreferrer\">HIC++</a></li>\n</ul>\n<p>Other implementations can be found;</p>\n<ul>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4189.pdf\" rel=\"nofollow noreferrer\">The C++ proposal</a> mentioned above and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0052r1.pdf\" rel=\"nofollow noreferrer\">its revision (as of this writing)</a></li>\n<li><a href=\"http://www.boost.org/doc/libs/1_60_0/libs/scope_exit/doc/html/index.html\" rel=\"nofollow noreferrer\">Boost.ScopeExit</a></li>\n<li><a href=\"https://github.com/Microsoft/GSL/blob/master/gsl/gsl_util\" rel=\"nofollow noreferrer\">The Microsoft GSL implementation</a></li>\n</ul>\n</hr>", "LastActivityDate": "2016-12-04T18:39:16.100"}, "36644263": {"CommentCount": "12", "ViewCount": "881", "PostTypeId": "1", "LastEditorUserId": "212063", "CreationDate": "2016-04-15T10:10:14.460", "LastActivityDate": "2016-12-04T18:39:16.100", "Title": "Is there a C++ standard class to set a variable to a value at scope exit", "AcceptedAnswerId": "36644501", "LastEditDate": "2016-04-15T10:16:04.913", "Id": "36644263", "Score": "10", "Body": "<p>Within the scope of a member function, I want to temporarly set a member variable to a certain value.</p>\n<p>Then, when this function returns, I want to reset this member variable to a given known value.</p>\n<p>To bo safe against exceptions and multiple returns, and I've done it with a simple RAII like class. It's defined within the scope of the member function.</p>\n<pre><code>void MyClass::MyMemberFunction() {\n    struct SetBackToFalse {\n        SetBackToFalse(bool* p): m_p(p) {}\n        ~SetBackToFalse() {*m_p=false;}\n    private:\n        bool* m_p;\n    };\n\n    m_theVariableToChange = true;\n    SetBackToFalse resetFalse( &amp;m_theVariableToChange ); // Will reset the variable to false.\n\n    // Function body that may throw.\n}\n</code></pre>\n<p>It seems so obviously commonplace, that I was wondering if there was any such template class doing this in the C++ standard library?</p>\n", "Tags": "<c++><return><raii><exception-safety>", "OwnerUserId": "212063", "AnswerCount": "4"}, "36644779": {"ParentId": "36644263", "CommentCount": "0", "CreationDate": "2016-04-15T10:33:23.693", "OwnerUserId": "3807729", "PostTypeId": "2", "Id": "36644779", "Score": "1", "Body": "<p>There is no standard version of this.</p>\n<p>The <a href=\"https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md\" rel=\"nofollow\">CppGoreGuidelines</a> Support Library (<a href=\"https://github.com/Microsoft/GSL\" rel=\"nofollow\">GSL</a>) has a generalized version of this called <a href=\"https://github.com/Microsoft/GSL/blob/master/include/gsl_util.h\" rel=\"nofollow\">finally</a> but that library is not production quality yet. Its definitely recommended practice.</p>\n<h3><a href=\"https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#e19-use-a-final_action-object-to-express-cleanup-if-no-suitable-resource-handle-is-available\" rel=\"nofollow\">E.19</a>: Use a <code>final_action</code> object to express cleanup if no suitable resource handle is available</h3>\n<h3>Reason</h3>\n<p><code>finally</code> is less verbose and harder to get wrong than <code>try</code>/<code>catch</code>.</p>\n<h3>Example</h3>\n<pre><code>void f(int n)\n{\n    void* p = malloc(1, n);\n    auto _ = finally([p] { free(p); });\n    // ...\n}\n</code></pre>\n<h3>Note</h3>\n<p><code>finally</code> is not as messy as <code>try</code>/<code>catch</code>, but it is still ad-hoc.\nPrefer proper resource management objects.</p>\n", "LastActivityDate": "2016-04-15T10:33:23.693"}, "bq_ids": {"n4140": {"so_36644263_36644696_0": {"section_id": 4375, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_36644263_36644696_0": {"section_id": 4212, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_36644263_36644696_0": {"section_id": 5638, "quality": 0.8571428571428571, "length": 6}}}, "36692887": {"ParentId": "36644263", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-04-18T11:36:42.283", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:25:31.013", "Id": "36692887", "OwnerUserId": "1505939", "Body": "<p>Similar question: <a href=\"https://stackoverflow.com/a/28413370/1505939\">The simplest and neatest c++11 ScopeGuard</a></p>\n<p>On that thread is described a similar guard for invoking an arbitrary function. To solve your problem, invoke a lambda that resets your variable.</p>\n<p>For example, the solution from <a href=\"https://stackoverflow.com/a/28413370/1505939\">this answer</a> for your code would be:</p>\n<pre><code>scope_guard guard1 = [&amp;]{ m_theVariableToChange = false; };\n</code></pre>\n<p>Another answer on that thread notes that a similar concept has been proposed for C++17 standardization; and there is also a C++03 solution presented.</p>\n", "LastActivityDate": "2016-04-18T11:36:42.283"}});