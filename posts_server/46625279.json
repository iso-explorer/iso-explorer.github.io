post_cb({"46625553": {"Id": "46625553", "PostTypeId": "2", "Body": "<p>I see a couple of problems. A minor one:</p>\n<pre><code>*(T*)dest = source;\n</code></pre>\n<p>IIRC, this is UB, because of aliasing rules violation (<code>char *</code> can alias any other pointer, but this means that you can access some object via a <code>char *</code> pointer, but not vice-versa, as in your example).</p>\n<blockquote>\n<p id=\"so_46625279_46625553_0\">In other words, will the code:\n   ...\n   Ever return false?</p>\n</blockquote>\n<p>Probably not, but you mentioned serializing not just a single object.</p>\n<p>So, the major problem is <strong>alignment</strong>:</p>\n<pre><code>std::unique_ptr&lt;char[]&gt; buffer { new char[sizeof(int) + 1] };\nchar x = 0;\nint y = 0;\nserialize(x, buffer);\nserialize(y, buffer); // may crash or write into wrong location\n</code></pre>\n<p>The faulty line is the same (but <code>deserialize</code> is also affected):</p>\n<pre><code>*(T*)dest = source; // source is int, dest is not aligned\n</code></pre>\n<p>The compiler will assume that dest is properly aligned and use CPU instructions for aligned store (on ARM architectures this will cause real problems).</p>\n<p>The solution is to use memcpy instead:</p>\n<pre><code>memcpy(dest, &amp;source, sizeof(T));\n</code></pre>\n<p>There is not need to worry about performance. Modern compilers are able to optimize memcpy of objects with known sizes very well.</p>\n", "LastEditorUserId": "4142343", "LastActivityDate": "2017-10-07T22:29:45.243", "Score": "2", "CreationDate": "2017-10-07T22:02:02.623", "ParentId": "46625279", "CommentCount": "2", "OwnerUserId": "4142343", "LastEditDate": "2017-10-07T22:29:45.243"}, "bq_ids": {"n4140": {"so_46625279_46629589_0": {"length": 37, "quality": 0.9024390243902439, "section_id": 7200}}, "n3337": {"so_46625279_46629589_0": {"length": 37, "quality": 0.9024390243902439, "section_id": 6944}}, "n4659": {"so_46625279_46629589_0": {"length": 37, "quality": 0.9024390243902439, "section_id": 8709}}}, "46629589": {"Id": "46629589", "PostTypeId": "2", "Body": "<p>Yes, you can do it as long as the buffer is an array of char, unsigned char or std::byte, C++ standard [basic.type]:</p>\n<blockquote>\n<p id=\"so_46625279_46629589_0\">For any object (other than a base-class subobject) of trivially copyable type T\n  , whether or not the object holds a valid value of type T, the underlying bytes (4.4) making up the object can be copied into an array of char, unsigned char, orstd::byte (21.2.1). If the content of that array is copied back into the object, the object shall subsequently hold its original value. [<em>Example</em>:</p>\n</blockquote>\n<pre><code>#define N sizeof(T)\nchar buf[N];\nT obj; //obj initialized to its original value\nstd::memcpy(buf, &amp;obj, N);// between these two calls to std::memcpy,obj might be modified\nstd::memcpy(&amp;obj, buf, N); // at this point, each subobject of obj of scalar type holds its original value\n</code></pre>\n<blockquote>\n<p id=\"so_46625279_46629589_1\">\u2014 end <em>example]</em></p>\n</blockquote>\n<p>Nota: There are no requirement on the alignment of the buffer.</p>\n", "LastActivityDate": "2017-10-08T09:32:05.227", "CommentCount": "0", "CreationDate": "2017-10-08T09:32:05.227", "ParentId": "46625279", "Score": "0", "OwnerUserId": "5632316"}, "46625976": {"Id": "46625976", "PostTypeId": "2", "Body": "<p><code>*(T*)dest = source;</code> is a strict aliasing violation.</p>\n<p>Instead you should write:</p>\n<pre><code>memcpy(dest, &amp;source, sizeof source);\n</code></pre>\n<p>You can copy POD objects around successfully using <code>memcpy</code>.</p>\n<p>In your <code>check_sanity</code> function it will fail to compile, since <code>operator==</code> is not defined for <code>T</code>. (There are no implicitly-generated comparison operators)</p>\n", "LastEditorUserId": "1505939", "LastActivityDate": "2017-10-07T23:18:46.250", "Score": "1", "CreationDate": "2017-10-07T23:10:09.713", "ParentId": "46625279", "CommentCount": "0", "OwnerUserId": "1505939", "LastEditDate": "2017-10-07T23:18:46.250"}, "46625279": {"ViewCount": "74", "Body": "<p>Suppose that <code>T</code> is a POD type that doesn't contain a pointer, and I want to serialize T (in addition to some other data too). I've created the below functions to do this:</p>\n<pre><code>template&lt;class T&gt; void serialize(const T&amp; source, char*&amp; dest)\n{\n  *(T*)dest = source;\n  dest += sizeof(T);\n}\ntemplate&lt;class T&gt; void deserialize(T&amp; dest, char*&amp; source)\n{\n  dest = *(T*)source;\n  source += sizeof(T);\n}\n</code></pre>\n<p>Will this cause any problems, or are there any compilers where this won't work? In other words, will the code:</p>\n<pre><code>template&lt;class T&gt; bool check_sanity(const T&amp; obj)\n{\n  std::unique_ptr&lt;char[]&gt; buffer { new int[sizeof(T)] };\n  serialize(obj, buffer);\n  T new_obj;\n  deserialize(new_obj, buffer); \n  return new_obj == obj;\n}\n</code></pre>\n<p>Ever return false? (Assume T is POD and no one's overloaded the == operator). </p>\n<p>I'm writing these serialization methods for use in conjunction with MPI, where they'll be used at the start of the program to distribute some of the data needed for bookkeeping, so the same program will always be serializing and deserializing data. </p>\n", "Title": "Is it safe to serialize POD data by casting directly to char array?", "CreationDate": "2017-10-07T21:26:11.047", "LastActivityDate": "2017-10-08T09:32:05.227", "CommentCount": "1", "PostTypeId": "1", "Id": "46625279", "Score": "5", "OwnerUserId": "4967403", "Tags": "<c++><serialization><mpi>", "AnswerCount": "3"}});