post_cb({"39963032": {"ParentId": "39962999", "LastEditDate": "2016-10-11T19:23:51.123", "CommentCount": "4", "CreationDate": "2016-10-10T16:47:41.650", "OwnerUserId": "734069", "LastEditorUserId": "734069", "PostTypeId": "2", "Id": "39963032", "Score": "29", "Body": "<blockquote>\n<p id=\"so_39962999_39963032_0\">Is stack unwinding for uncaught exceptions guaranteed by the standard?</p>\n</blockquote>\n<p>Stack unwinding is guaranteed to happen only for <em>caught</em> exceptions ([except.handle]/9):</p>\n<blockquote>\n<p id=\"so_39962999_39963032_1\">If no matching handler is found, the function <code>std::terminate()</code> is called; whether or not the stack is unwound before this call to <code>std::terminate()</code> is implementation-defined.</p>\n</blockquote>\n<p>So it's implementation-defined, otherwise.</p>\n<blockquote>\n<p id=\"so_39962999_39963032_2\">If not, why?</p>\n</blockquote>\n<p>In the event of an uncaught exception, the standard causes <code>std::terminate</code> to be called. That represents the end of the execution of the program. If you have some platform-specific way of logging information about the state of the system at that time, you may not want that state to be disturbed by stack unwinding.</p>\n<p>And if you're not doing that... then you don't care either way.</p>\n<p>If you truly need the stack to always be unwound, then you can put your <code>main</code> code (and any thread functions) in a <code>try {} catch(...) {throw;}</code> block.</p>\n", "LastActivityDate": "2016-10-11T19:23:51.123"}, "bq_ids": {"n4140": {"so_39962999_39963032_1": {"section_id": 3354, "quality": 0.9230769230769231, "length": 12}, "so_39962999_39962999_0": {"section_id": 3388, "quality": 0.7222222222222222, "length": 13}}, "n3337": {"so_39962999_39963032_1": {"section_id": 3224, "quality": 0.9230769230769231, "length": 12}, "so_39962999_39962999_0": {"section_id": 3257, "quality": 0.7222222222222222, "length": 13}}, "n4659": {"so_39962999_39963032_1": {"section_id": 4121, "quality": 0.9230769230769231, "length": 12}, "so_39962999_39963032_0": {"section_id": 4144, "quality": 0.8, "length": 4}, "so_39962999_39962999_0": {"section_id": 4144, "quality": 0.8333333333333334, "length": 15}}}, "39962999": {"CommentCount": "1", "ViewCount": "1268", "LastActivityDate": "2016-10-11T19:23:51.123", "Body": "<p>Concerning the stack unwinding, the c++ standard says:  </p>\n<blockquote>\n<p id=\"so_39962999_39962999_0\">An exception is considered uncaught after completing the initialization of the exception object ([except.throw]) until completing the activation of a handler for the exception ([except.handle]). This includes stack unwinding.   </p>\n</blockquote>\n<p>at <a href=\"http://eel.is/c++draft/except#uncaught-1\">par 15.5.3</a> of the current standard. I was trying to understand what the latest sentence (<code>This includes stack unwindings</code>) is referring to:</p>\n<ul>\n<li>is it supposed that the compiler must take care of unwinding the stack?</li>\n<li>or, is it saying that it is compiler-dependent whether to unwind or not the stack?</li>\n</ul>\n<p>The question arises from the following snippet:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;exception&gt;\n\nstruct S{\n    S() { std::cout &lt;&lt; \" S constructor\" &lt;&lt; std::endl; }\n    virtual ~S() { std::cout &lt;&lt; \" S destructor\" &lt;&lt; std::endl; }\n};\n\nvoid f() {\n    try{throw(0);}\n    catch(...){}\n}\n\nvoid g() {\n    throw(10);\n}\n\nint main() {\n    S s;\n    f();\n    //g();\n}\n</code></pre>\n<p>Now: </p>\n<ol>\n<li>if you run it as-is (catching the exception), you have a hint of the stack unwinding</li>\n<li>if you comment <code>f();</code> and uncomment <code>g();</code> (not catching the exception), you have hint of stack not being unwound</li>\n</ol>\n<p>So, the two experiments seem to be in favor of the first bullet above; both clang++ and g++ agree on the result (but it is not a discriminant). </p>\n<p>Also, it seems to me very strange that the standard, which is really careful in specifying the object <em>live time</em> and <em>duration</em> is leaving a shadow here.</p>\n<p>May anyone clarify? Is stack unwinding for uncaught exceptions guaranteed by the standard? If yes, where? If not, why?</p>\n", "PostTypeId": "1", "AcceptedAnswerId": "39963032", "FavoriteCount": "3", "Title": "Is stack unwinding with exceptions guaranteed by c++ standard?", "Id": "39962999", "Score": "18", "CreationDate": "2016-10-10T16:45:21.497", "Tags": "<c++><c++11><language-lawyer>", "OwnerUserId": "2870029", "AnswerCount": "1"}});