post_cb({"bq_ids": {"n4140": {"so_15260685_15260685_1": {"length": 29, "quality": 0.8787878787878788, "section_id": 300}, "so_15260685_15260685_0": {"length": 39, "quality": 0.9069767441860465, "section_id": 300}}, "n3337": {"so_15260685_15260685_1": {"length": 29, "quality": 0.8787878787878788, "section_id": 291}, "so_15260685_15260685_0": {"length": 39, "quality": 0.9069767441860465, "section_id": 291}}, "n4659": {"so_15260685_15260685_1": {"length": 26, "quality": 0.7878787878787878, "section_id": 307}, "so_15260685_15260685_0": {"length": 39, "quality": 0.9069767441860465, "section_id": 307}}}, "15261234": {"Id": "15261234", "PostTypeId": "2", "Body": "<p>If you consider all the templates and implicitly-defined functions that are needed to determine the result of the template argument substitution, and imagine they are generated first, before substitution starts, then any errors occurring in that first step are not in the immediate context, and result in hard errors.</p>\n<p>If all those instantiations and implicitly-definitions (which might include defining functions as deleted) can be done without error, then any further \"errors\" that occur during substitution (i.e. while referring to the instantiated templates and implicitly-defined functions in the function template's signature) are not errors, but result in deduction failures.</p>\n<p>So given a function template like this:</p>\n<pre><code>template&lt;typename T&gt;\nvoid\nfunc(typename T::type* arg);\n</code></pre>\n<p>and a \"fall-back\" that will be used if deduction fails for the other function:</p>\n<pre><code>template&lt;typename&gt;\nvoid\nfunc(...);\n</code></pre>\n<p>and a class template like this:</p>\n<pre><code>template&lt;typename T&gt;\n  struct A\n  {\n    typedef T* type;\n  };\n</code></pre>\n<p>A call to <code>func&lt;A&lt;int&amp;&gt;&gt;(nullptr)</code> will substitute <code>A&lt;int&amp;&gt;</code> for <code>T</code> and in order to check if <code>T::type</code> exists it must instantiate <code>A&lt;int&amp;&gt;</code>.  If we imagine putting an explicit instantiation before the call to <code>func&lt;A&lt;int&amp;&gt;(nullptr)</code>:</p>\n<pre><code>template class A&lt;int&amp;&gt;;\n</code></pre>\n<p>then that would fail, because it tries to create the type <code>int&amp;*</code> and pointers to references are not allowed.  We don't get to the point of checking if substitution succeeds, because there is a hard error from instantiating <code>A&lt;int&amp;&gt;</code>.</p>\n<p>Now let's say there's an explicit specialization of <code>A</code>:</p>\n<pre><code>template&lt;&gt;\n  struct A&lt;char&gt;\n  {\n  };\n</code></pre>\n<p>A call to <code>func&lt;A&lt;char&gt;&gt;(nullptr)</code> requires the instantiation of <code>A&lt;char&gt;</code>, so imagine an explicit instantiation somewhere in the program before the call:</p>\n<pre><code>template class A&lt;char&gt;;\n</code></pre>\n<p>This instantiation is OK, there's no error from this, so we proceed to argument substitution. The instantiation of <code>A&lt;char&gt;</code> worked, but <code>A&lt;char&gt;::type</code> doesn't exist, but that's OK because it's only referenced in the declaration of <code>func</code>, so only causes argument deduction to fail, and the fall-back <code>...</code> function gets called instead.</p>\n<p>In other situations substitution might cause special member functions to be implicitly-defined, possibly as deleted, which might trigger other instantiations or implicit definitions. If errors occur during that \"generating instantiations and implicit definitions\" stage then they're errors, but if that succeeds but during substitution an expression in the function template signature turns out to be invalid e.g. because it uses a member that doesn't exist or something that got implicitly defined as deleted, that's not an error, just a deduction failure.</p>\n<p>So the mental model I use is that substitution needs to do a \"preparation\" step first to generate types and members, which might cause hard errors, but once we have all the necessary generation done, any further invalid uses are not errors. Of course all this does is move the problem from \"what does <em>immediate context</em> mean?\" to \"Which types and members need to be generated before this substitution can be checked?\" so it may or may not help you!</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2013-03-07T01:26:16.413", "Score": "23", "CreationDate": "2013-03-07T01:04:06.283", "ParentId": "15260685", "CommentCount": "10", "LastEditDate": "2013-03-07T01:26:16.413", "OwnerUserId": "981959"}, "15260803": {"Id": "15260803", "PostTypeId": "2", "Body": "<p>The <em>immediate context</em> is basically what you see in the template declaration itself. Everything outside of that is a hard error. Hard-error examples:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt;class T&gt;\nstruct trait{ using type = typename T::type; };\n\ntemplate&lt;class T, class U = typename trait&lt;T&gt;::type&gt;\nvoid f(int);\nvoid f(...);\n\ntemplate&lt;class T, class U = typename T::type&gt;\nvoid g(int);\nvoid g(...);\n\ntemplate&lt;class&gt;\nstruct dependent_false : std::false_type{};\n\ntemplate&lt;class T&gt;\nstruct X{\n    static_assert(dependent_false&lt;T&gt;(), \"...\");\n    using type = void;\n};\n\nint main(){\n    f&lt;int&gt;(0);\n    g&lt;X&lt;int&gt;&gt;(0);\n}\n</code></pre>\n<p><a href=\"https://ideone.com/De8ega\" rel=\"nofollow\">Live version.</a></p>\n", "LastActivityDate": "2013-03-07T00:18:41.107", "Score": "5", "CreationDate": "2013-03-07T00:18:41.107", "ParentId": "15260685", "CommentCount": "8", "OwnerUserId": "500104"}, "15260685": {"ViewCount": "1670", "Body": "<p>Paragraph 14.8.2/8 of the C++11 Standard specifies the conditions under which a substitution failure shall or shall not result in a \"hard\" compilation error (thereby causing compilation to fail) or in a \"soft\" error which would just cause the compiler to discard a template from a set of candidates for overload resolution (without making compilation fail and enabling the well-known SFINAE idiom):</p>\n<blockquote>\n<p id=\"so_15260685_15260685_0\">If a substitution results in an invalid type or expression, type deduction fails. An invalid type or expression\n  is one that would be ill-formed if written using the substituted arguments. [ Note: Access checking is done as\n  part of the substitution process. \u2014end note ] <strong>Only invalid types and expressions in the immediate context of\n  the function type and its template parameter types can result in a deduction failure</strong>. [...]</p>\n</blockquote>\n<p>The words \"<em>immediate context</em>\" appear only 8 times in the whole C++11 Standard, and each time they are followed by (or occur as part of) an instance of the following (non-normative) text:</p>\n<blockquote>\n<p id=\"so_15260685_15260685_1\">[Note: <em>The evaluation\n  of the substituted types and expressions can result in side effects such as the instantiation of class template\n  specializations and/or function template specializations, the generation of implicitly-defined functions, etc.\n  Such side effects are not in the \u201cimmediate context\u201d and can result in the program being ill-formed.</em>\u2014end\n  note ]</p>\n</blockquote>\n<p>The note gives a (not very generous) hint on what is meant by <em>immediate context</em>, but at least for me this is often not enough to decide whether a substitution is or is not supposed to cause a \"hard\" compilation error.</p>\n<p><strong>QUESTION:</strong></p>\n<p>Could you provide an explanation, a decision procedure, and/or some concrete examples to help figuring out in what cases a substitution error does and does not occur in the \"<em>immediate context</em>\" of the function type and its template parameter types? </p>\n", "AcceptedAnswerId": "15261234", "Title": "What exactly is the \"immediate context\" mentioned in the C++11 Standard for which SFINAE applies?", "CreationDate": "2013-03-07T00:06:31.283", "Id": "15260685", "CommentCount": "2", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2015-07-03T15:03:44.867", "LastEditorUserId": "15055", "LastActivityDate": "2015-07-03T15:03:44.867", "Score": "29", "OwnerUserId": "1932150", "Tags": "<c++><templates><c++11><language-lawyer><sfinae>", "AnswerCount": "2"}});