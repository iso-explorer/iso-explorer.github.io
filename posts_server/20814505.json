post_cb({"20814544": {"ParentId": "20814505", "CommentCount": "4", "Body": "<p>It is due to the syntax of the expression.</p>\n<p>Just like some words can be either a noun or verb - depends on the location in the sentence</p>\n", "OwnerUserId": "892256", "PostTypeId": "2", "Id": "20814544", "Score": "1", "CreationDate": "2013-12-28T12:27:42.750", "LastActivityDate": "2013-12-28T12:27:42.750"}, "20814545": {"ParentId": "20814505", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The variable name <em>hides</em> the struct name (\u00a73.3.10):</p>\n<blockquote>\n<p id=\"so_20814505_20814545_0\">A name can be hidden by an explicit declaration of that same name in a nested declarative region or derived class (10.2).</p>\n</blockquote>\n<p>If you need to refer to the struct name specifically, you need to use an elaborated type specifier, <code>struct XX</code> (\u00a73.4.4):</p>\n<blockquote>\n<p id=\"so_20814505_20814545_1\">An elaborated-type-specifier (7.1.6.3) may be used to refer to a previously declared class-name or enum-name even though the name has been hidden by a non-type declaration (3.3.10).</p>\n</blockquote>\n<p>So the compiler knows that <code>XX</code> refers to the variable here because that's all it <em>can</em> correspond to. It won't even consider the possibility of it referring to the struct. In fact, let's see what happens if we try to use it as a type:</p>\n<pre><code>struct XX {\n    int elemnent;\n};\n\nint main ()\n{\n    XX XX, prev_XX;\n    XX XX2; // Can we continue to use XX as a type?\n}\n</code></pre>\n<p>We actually get an error:</p>\n<pre><code>error: expected \u2018;\u2019 before \u2018XX2\u2019\n</code></pre>\n<p>So instead, we have to do <code>struct XX XX2;</code>, which gives no error.</p>\n", "OwnerUserId": "150634", "LastEditorUserId": "150634", "LastEditDate": "2013-12-28T12:34:11.520", "Id": "20814545", "Score": "10", "CreationDate": "2013-12-28T12:28:03.587", "LastActivityDate": "2013-12-28T12:34:11.520"}, "20814505": {"CommentCount": "4", "ViewCount": "95", "PostTypeId": "1", "LastEditorUserId": "1870232", "CreationDate": "2013-12-28T12:22:34.463", "LastActivityDate": "2013-12-28T12:39:20.110", "Title": "Why does the compiler allow this?", "AcceptedAnswerId": "20814545", "LastEditDate": "2013-12-28T12:39:20.110", "Id": "20814505", "Score": "1", "Body": "<p>The following compiles successfully:</p>\n<pre><code>struct XX {\n  int element;\n};\n\nint main ()\n{\n  XX  XX, prev_XX  ;\n  prev_XX = XX;\n  XX = prev_XX;  //  ??? NO error: expected unqualified-id before '=' token\n}\n</code></pre>\n<p>How does compiler know whether it's a type or a variable?</p>\n<p><strong>Edit :</strong> </p>\n<p>An error for this : (from sftrabbit's example)</p>\n<pre><code>int main ()\n{\n    XX XX, prev_XX;\n    XX XX2; // error: expected ';' before 'XX2'\n}\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "1870232", "AnswerCount": "4"}, "20814559": {"ParentId": "20814505", "CommentCount": "0", "Body": "<p>The name of the object hides the name of the structure. If you want to specify the structure you should use elaborated name for example</p>\n<pre><code>XX XX;\nstruct XX YY;\n</code></pre>\n<p>It was introduced in C++ because in C structure names and variables names belong to different name spaces due to the fact that in C you must always specify keyword struct with structures. In C++ it is allowed to use structure names without keyword struct but variable names hides structure names if they coinside.</p>\n", "OwnerUserId": "2877241", "PostTypeId": "2", "Id": "20814559", "Score": "1", "CreationDate": "2013-12-28T12:29:21.587", "LastActivityDate": "2013-12-28T12:29:21.587"}, "bq_ids": {"n4140": {"so_20814505_20814545_1": {"section_id": 7123, "quality": 0.875, "length": 14}, "so_20814505_20814545_0": {"section_id": 7078, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_20814505_20814545_1": {"section_id": 6867, "quality": 0.875, "length": 14}, "so_20814505_20814545_0": {"section_id": 6822, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_20814505_20814545_1": {"section_id": 8624, "quality": 0.875, "length": 14}, "so_20814505_20814545_0": {"section_id": 8579, "quality": 0.9230769230769231, "length": 12}}}, "20814566": {"ParentId": "20814505", "CommentCount": "0", "Body": "<p>This is a subtle issue harking back to the days of C.</p>\n<p>When you declare <code>XX XX;</code> the second <code>XX</code> (variable) shadows the first <code>XX</code> (type). You can still access the type by using <code>struct XX</code> to name it.</p>\n<pre><code>struct XX {};\n\nint main() {\n    XX XX;\n\n    XX other; // error: expected \u2018;\u2019 before \u2018other\u2019\n\n    struct XX another; // OK\n\n    another = XX; // OK\n\n    return 0;\n}\n</code></pre>\n<p>You can check it out <a href=\"http://ideone.com/PT6UUp\" rel=\"nofollow\">here</a>.</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "20814566", "Score": "1", "CreationDate": "2013-12-28T12:30:10.093", "LastActivityDate": "2013-12-28T12:30:10.093"}});