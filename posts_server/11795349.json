post_cb({"11795458": {"Id": "11795458", "PostTypeId": "2", "Body": "<p>But, how would the compiler know that you are inside a class derived from B once you apply <code>static_cast</code> on <code>this</code>? In my (humble) opinion, if I create a <code>B</code> object, I expect not to be allowed to call private or protected <code>B</code> methods on the <code>B</code> object, since we don't want to violate encapsulation. It would not matter where the <code>B</code> object is created, as long as it's outside of the <code>B</code> class methods.</p>\n", "LastActivityDate": "2012-08-03T12:08:32.637", "CommentCount": "1", "CreationDate": "2012-08-03T12:08:32.637", "ParentId": "11795349", "Score": "0", "OwnerUserId": "1174378"}, "bq_ids": {"n4140": {"so_11795349_11795528_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 4560}, "so_11795349_11795443_1": {"length": 21, "quality": 0.8076923076923077, "section_id": 6695}}, "n3337": {"so_11795349_11795528_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 4390}, "so_11795349_11795443_1": {"length": 21, "quality": 0.8076923076923077, "section_id": 6450}}, "n4659": {"so_11795349_11795528_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 7474}, "so_11795349_11795443_1": {"length": 21, "quality": 0.8076923076923077, "section_id": 8170}}}, "11795443": {"Id": "11795443", "PostTypeId": "2", "Body": "<p>The compiler is correct.  To explicitly access the <code>B::f</code> member function, you can write:</p>\n<pre><code>this-&gt;B::f();\n</code></pre>\n<p>The relevant language is:</p>\n<blockquote>\n<p id=\"so_11795349_11795443_0\"><a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b11\" rel=\"tag\" title=\"show questions tagged 'c++11'\">c++11</a></p>\n<h3>11.4 Protected member access [class.protected]</h3>\n<p id=\"so_11795349_11795443_1\">[...] Access to a protected member is granted because the reference occurs in a friend or member of some\n  class C. [...] Access to a protected member [...] involve[s] a (possibly implicit) object expression (5.2.5). In this case,\n  the class of the object expression shall be C or a class derived from C.</p>\n</blockquote>\n<p>Thus protected member access via a cast to the base class <code>B</code> violates this grant, and is disallowed.  It is also unnecessary for the reason that you can use <code>this-&gt;B::f()</code> as above.</p>\n<hr/>\n<p>In the case with your actual CRTP motivation, you are correct that you cannot call <code>f()</code> without a <code>static_cast</code>, since <code>D</code> is not a base class of <code>B&lt;D&gt;</code> (the inheritance relationship is in the other direction).  Since <code>D</code> is not a base class of <code>B&lt;D&gt;</code>, you cannot call its <code>protected</code> methods from <code>B&lt;D&gt;</code> anyway.  One simple workaround is to <code>friend</code> <code>B&lt;D&gt;</code> to <code>D</code> and use the <code>static_cast</code> on the <code>this</code> pointer:</p>\n<pre><code>template&lt;typename T&gt;\nclass B {\npublic:\n    void g() {\n        static_cast&lt;T *&gt;(this)-&gt;f();\n    }\n};\n\nclass D : public B&lt;D&gt;\n{\n    friend class B&lt;D&gt;;\n    ...\n</code></pre>\n<p>If giving <code>B</code> access to the <code>private</code> parts of <code>D</code> worries you, you can move the <code>private</code> parts to another base class and isolate the CRTP mechanism in <code>D</code>:</p>\n<pre><code>template&lt;class T&gt; class B {\npublic:\n    void g() {\n        static_cast&lt;T*&gt;(this)-&gt;f();\n    }\n};\n\nclass C {\nprivate:\n    void h();\nprotected:\n    void f(){ std::cout &lt;&lt; \"D::f\\n\"; }\n};\n\nclass D: protected C, public B&lt;D&gt;\n{\n    friend class B&lt;D&gt;;\n};\n</code></pre>\n<p>Here <code>B&lt;D&gt;</code> is prevented from calling <code>C::h</code> as friendship is neither inherited nor transitive.</p>\n", "LastEditorUserId": "567292", "LastActivityDate": "2012-08-03T13:10:16.717", "Score": "13", "CreationDate": "2012-08-03T12:07:36.147", "ParentId": "11795349", "CommentCount": "5", "OwnerUserId": "567292", "LastEditDate": "2012-08-03T13:10:16.717"}, "11795528": {"Id": "11795528", "PostTypeId": "2", "Body": "<p>I think the compiler is right.</p>\n<p>Suppose the following:</p>\n<pre><code>void g()\n{\n    B *b1 = this;\n    B *b2 = GetUnrelatedB();\n    b1-&gt;f(); //Error?\n    b2-&gt;f(); //Error!\n}\n</code></pre>\n<p>The <code>b1</code> case is equivalent to your <code>static_cast</code> but it would be very strange that <code>b1</code> will be allowed and <code>b2</code> will not.</p>\n<p>Citing your paragraph 11.5:</p>\n<blockquote>\n<p id=\"so_11795349_11795528_0\">[...] the access must be through a pointer to, reference to, or object of the derived class itself.</p>\n</blockquote>\n<p>But <code>static_cast&lt;B*&gt;(this)</code> is of type <code>B*</code>, not <code>D*</code>, no matter that the object itself is the same. Actually, the value of the pointer is irrelevant to this issue, only the type of the expression:</p>\n<pre><code>void g()\n{\n    B *b2 = GetUnrelatedB();\n    static_cast&lt;D*&gt;(b2)-&gt;f(); //ok!\n}\n</code></pre>\n", "LastEditorUserId": "865874", "LastActivityDate": "2012-08-03T12:19:49.603", "Score": "1", "CreationDate": "2012-08-03T12:13:36.797", "ParentId": "11795349", "CommentCount": "3", "OwnerUserId": "865874", "LastEditDate": "2012-08-03T12:19:49.603"}, "11795349": {"ViewCount": "1586", "Body": "<p>To begin with, I know about <em>C++ Standard (ISO/IEC 14882:2003): Section 11.5, Paragraph 1</em>, and this is not that case (but compliler apparently does not think so).</p>\n<p>I try to call protected base class method in derived class method through <strong>this</strong> pointer, static-casted to base class pointer and have in MSVC2008 <em>error C2248: 'A::f' : cannot access protected member declared in class 'A'</em>.</p>\n<p>I <em>have</em> to do this in context of 'curiously recurring template pattern', but I can reproduce this error in simplier code, as follows:</p>\n<pre><code>class B\n{\nprotected:\n    void f(){}\n};\n\nclass D : public B\n{\npublic:\n    void g()\n    {\n        f(); // ok\n        this-&gt;f(); // ok\n        static_cast&lt;B*&gt;(this)-&gt;f(); // C2248 in MSVC2008\n        dynamic_cast&lt;B*&gt;(this)-&gt;f(); // C2248\n        ((B*)this)-&gt;f(); // C2248\n    }\n};\nD d; d.g();\n</code></pre>\n<p>It seems that compiler think of casted <strong>this</strong> pointer as a pointer to other instance, yeah?</p>\n<p>The compiler is wrong in this case, what do you think?</p>\n<hr>\n<p>Ok, my real code is more like that:</p>\n<pre><code>template&lt;class T&gt;\nclass B\n{\npublic:\n    void g()\n    {\n        f(); // error C3861: 'f': identifier not found\n        this-&gt;f(); // error C3861: 'f': identifier not found\n\n        // static_cast to derived class\n        static_cast&lt;T*&gt;(this)-&gt;f(); // C2248 in MSVC2008\n    }\n};\n\nclass D : public B&lt;D&gt;\n{\nprotected:\n    void f(){}\n};\n</code></pre>\n<p>I cast <strong>this</strong> to <em>derived</em> class, and I <em>can't</em> use <strong>this-&gt;f();</strong></p>\n<hr>\n<p>By the way, I see that this code is unsafe for usage like <code>class E : public B&lt;D&gt; {...};</code>: compilable, but static_cast makes wrong cast.</p>\n</hr></hr>", "AcceptedAnswerId": "11795443", "Title": "Calling protected base class method via this pointer casted to base class in derived class (C++)", "CreationDate": "2012-08-03T12:01:31.797", "Id": "11795349", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-08-03T13:18:30.527", "LastEditorUserId": "1573955", "LastActivityDate": "2012-08-03T13:18:30.527", "Score": "5", "OwnerUserId": "1573955", "Tags": "<c++><inheritance><compiler-errors><protected>", "AnswerCount": "3"}});