post_cb({"bq_ids": {"n4140": {"so_27431916_27433549_2": {"length": 5, "quality": 0.7142857142857143, "section_id": 2724}, "so_27431916_27433549_3": {"length": 8, "quality": 0.5333333333333333, "section_id": 2725}}, "n3337": {"so_27431916_27433549_2": {"length": 5, "quality": 0.7142857142857143, "section_id": 2685}, "so_27431916_27433549_3": {"length": 8, "quality": 0.5333333333333333, "section_id": 2686}}, "n4659": {"so_27431916_27433549_2": {"length": 5, "quality": 0.7142857142857143, "section_id": 3463}, "so_27431916_27433549_3": {"length": 8, "quality": 0.5333333333333333, "section_id": 3464}}}, "27433549": {"Id": "27433549", "PostTypeId": "2", "Body": "<p>A (non detached) thread will be joignable, even after having returned from the function it was set to run, until it has been joined.\nExample:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;chrono&gt;\n\nusing namespace std;\n\nvoid foo(){\n    std::cout &lt;&lt; \"helper: I'm done\\n\";\n}\n\n int main(){\n\n    cout &lt;&lt; \"starting helper...\\n\";\n    thread helper(foo);\n\n    this::thread::sleep_for(std::chrono::seconds(5));\n\n     cout &lt;&lt; \"helper still joignable?...\" &lt;&lt; (helper.joignable()?\"yes!\":\"no...:(\") &lt;&lt; \"\\n\";\n\n    helper.join();\n    cout &lt;&lt; \"helper joined!\";\n\n    cout &lt;&lt; \"helper still joignable?...\" &lt;&lt; (helper.joignable()?\"really?\":\"not anymore!\") &lt;&lt; \"\\n\";\n\n    cout &lt;&lt; \"done!\\n\";\n\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>starting helper...\nhelper: I'm done\nstill joinable?...yes!\nhelper joined!\nstill joinable?...not anymore!\ndone!\n</code></pre>\n<p>As for how much time the <code>join</code> method takes, I don't think this is specified, but surely it doesn't't have to wait for all the other threads to finish, or it would mean that only <em>one</em> thread would be able to join all the others.</p>\n<p>From \u00a730.3.5:</p>\n<blockquote>\n<p id=\"so_27431916_27433549_0\">void Join();</p>\n<p id=\"so_27431916_27433549_1\"><em>Requires:</em> <code>joinable()</code> is <code>true</code></p>\n<p id=\"so_27431916_27433549_2\"><em>Effects:</em> Blocks until the thread represented by <code>*this</code> had completed.</p>\n<p id=\"so_27431916_27433549_3\"><em>Synchronization:</em> The completion of the thread represented by <code>*this</code> synchronises with the corresponding successful <code>join()</code> return. [<em>Note:</em> Operations on <code>*this</code> are not synchronised. * -- end note*]</p>\n<p id=\"so_27431916_27433549_4\">[...]</p>\n</blockquote>\n", "LastEditorUserId": "1769720", "LastActivityDate": "2014-12-11T22:51:12.970", "Score": "1", "CreationDate": "2014-12-11T22:23:49.547", "ParentId": "27431916", "CommentCount": "0", "LastEditDate": "2014-12-11T22:51:12.970", "OwnerUserId": "1769720"}, "27431916": {"ViewCount": "188", "Body": "<p>I have a C++ class that does some multi-threading.  Consider the pseudo-code below:</p>\n<pre><code>void MyClass::Open() {\n  loop_flag =  true;\n  // create consumer_thread (infinite loop)\n  // create producer_thread (infinite loop)\n}\nvoid MyClass::Close() {\n  loop_flag = false;\n  // join producer_thread\n  // join consumer_thread\n}\nMyClass::~MyClass() {\n  Close();\n  // do other stuff here\n}\n</code></pre>\n<p>Note that consumer_thread, producer_thread, and their associated functions are all encapsulated in MyClass.  The caller has no clue that their calls are multi-threaded and what's going on in the background.</p>\n<p>Now, the class is part of a larger program.  The program has some initial multi-threading to handle configuration of the system since there's a ton of stuff happening at once.</p>\n<p>Like this (pseudo-code):</p>\n<pre><code>int main() {\n  // create config_thread1 (unrelated to MyClass)\n  // create thread for MyClass::Open()\n  // ...\n  // join all spawned configuration threads\n}\n</code></pre>\n<p>So my question is, when I call join() for the thread linked to MyClass::Open() (i.e., the configuration thread spawned in main()), what happens?  Does it join() immediately (since the MyClass::Open() function just returns after creation of producer_thread and consumer_thread) or does it wait for producer_thread and consumer_thread to finish (and therefore hangs my program).</p>\n<p>Thanks in advance for the help.  In terms of implementation details, I'm using Boost threads on a Linux box.</p>\n<p>Edited to add this diagram:</p>\n<pre><code> main()\n |\n |\n |\n |---&gt;configuration_thread (that runs MyClass::Open())\n   |\n   |\n   |----&gt; producer_thread\n   |----&gt; consumer_thread\n</code></pre>\n<p>If I call join() on configuration_thread(), does it wait until producer_thread() and consumer_thread() are finished or does it return immediately (and producer_thread() and consumer_thread() continue to run)?</p>\n", "AcceptedAnswerId": "27433549", "Title": "Parent thread join(): Blocks Until Children Finish?", "CreationDate": "2014-12-11T20:35:46.873", "Id": "27431916", "CommentCount": "5", "LastEditDate": "2014-12-11T21:13:19.567", "PostTypeId": "1", "LastEditorUserId": "2457733", "LastActivityDate": "2014-12-11T22:51:12.970", "Score": "1", "OwnerUserId": "2457733", "Tags": "<c++><multithreading><boost-thread>", "AnswerCount": "1"}});