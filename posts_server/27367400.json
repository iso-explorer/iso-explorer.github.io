post_cb({"bq_ids": {"n4140": {"so_27367400_27367400_3": {"length": 26, "quality": 1.0, "section_id": 7149}, "so_27367400_27367400_2": {"length": 7, "quality": 1.0, "section_id": 7146}, "so_27367400_27367400_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 7146}, "so_27367400_27367692_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 5454}, "so_27367400_27367692_0": {"length": 39, "quality": 0.9512195121951219, "section_id": 5446}}, "n3337": {"so_27367400_27367400_3": {"length": 26, "quality": 1.0, "section_id": 6893}, "so_27367400_27367400_2": {"length": 6, "quality": 0.8571428571428571, "section_id": 3073}, "so_27367400_27367400_0": {"length": 17, "quality": 0.8095238095238095, "section_id": 6890}}, "n4659": {"so_27367400_27367400_3": {"length": 21, "quality": 0.8076923076923077, "section_id": 8650}, "so_27367400_27367400_2": {"length": 7, "quality": 1.0, "section_id": 8647}, "so_27367400_27367400_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 8647}, "so_27367400_27367692_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 6880}, "so_27367400_27367692_0": {"length": 39, "quality": 0.9512195121951219, "section_id": 6873}}}, "27367692": {"Id": "27367692", "PostTypeId": "2", "Body": "<p>It appears that <code>auto main() { }</code> is not legal in C++14. </p>\n<p>[dcl.spec.auto]</p>\n<blockquote>\n<p id=\"so_27367400_27367692_0\"><code>2</code> The placeholder type can appear with a function declarator in the\n  <em>decl-specifier-seq</em>, <em>type-specifier-seq</em>, <em>conversion-function-id</em>, or <em>trailing-return-type</em>, in any context where such a declarator is\n  valid. If the function declarator includes a <em>trailing-return-type</em>\n  (8.3.5), that specifies the declared return type of the function. If\n  the declared return type of the function contains a placeholder type,\n  the return type of the function is deduced from <code>return</code> statements in\n  the body of the function, if any.</p>\n<p id=\"so_27367400_27367692_1\"><code>10</code> If a function with a declared return type that uses a placeholder\n  type has no <code>return</code> statements, the <code>return</code> type is deduced as\n  though from a return statement with no operand at the closing brace of\n  the function body. [ <em>Example:</em></p>\n<pre><code>auto  f() { } // OK, return type is void\nauto* g() { } // error, cannot deduce auto* from void()\n</code></pre>\n<p id=\"so_27367400_27367692_2\">\u2014 <em>end example</em> ]</p>\n</blockquote>\n<p>This seems to imply that since there are no <code>return</code> statements, <code>main()</code> is deduced to be <code>void</code> and therefore the program is ill-formed. Yet, it leaves an ambiguity open that seems to allow the implicit <code>return 0</code> to be deduced to <code>int</code>. Oh well.</p>\n", "LastActivityDate": "2014-12-08T21:54:12.760", "CommentCount": "0", "CreationDate": "2014-12-08T21:54:12.760", "ParentId": "27367400", "Score": "0", "OwnerUserId": "4338919"}, "27367400": {"ViewCount": "159", "Body": "<p>N3936 [basic.start.main]</p>\n<blockquote>\n<p id=\"so_27367400_27367400_0\"><code>2</code> An implementation shall not predefine the <code>main</code> function. This\n  function shall not be overloaded. It shall have a declared return type\n  of type <code>int</code>, but otherwise its type is implementation-defined. An\n  implementation shall allow both</p>\n<p id=\"so_27367400_27367400_1\">\u2014 a function of <code>()</code> returning <code>int</code> and</p>\n<p id=\"so_27367400_27367400_2\">\u2014 a function of (<code>int</code>, pointer to pointer to <code>char</code>) returning <code>int</code></p>\n<p id=\"so_27367400_27367400_3\"><code>5</code> A return statement in <code>main</code> has the effect of leaving the main\n  function (destroying any objects with automatic storage duration) and\n  calling <code>std::exit</code> with the return value as the argument. If control\n  reaches the end of main without encountering a return statement, the\n  effect is that of executing </p>\n<pre><code>return 0;\n</code></pre>\n</blockquote>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1669\" rel=\"nofollow\">DR 1669</a> added the word <strong>declared</strong> to the wording, implying that if <code>main</code> were to be declared <code>auto</code>, a trailing return type is necessary. However, the wording introduced by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1003\" rel=\"nofollow\">DR 1003</a> says, as in the quote above, that \"an implementation shall allow both a function of ... returning <code>int</code> ... \" This wording is a lot less strict when it comes to what the declaration of <code>main</code> should look like.</p>\n<p>So, given the rules of <code>auto</code>, is an implicit <code>return 0;</code> enough to make </p>\n<pre><code>auto main() { }\n</code></pre>\n<p>legal?</p>\n", "Title": "How does implicit return 0 tie into main's return type deduction?", "CreationDate": "2014-12-08T21:35:22.443", "LastActivityDate": "2014-12-08T21:54:12.760", "CommentCount": "6", "PostTypeId": "1", "ClosedDate": "2014-12-11T13:28:40.657", "Id": "27367400", "Score": "1", "OwnerUserId": "4338919", "Tags": "<c++><language-lawyer><c++14>", "AnswerCount": "1"}});