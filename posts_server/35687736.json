post_cb({"bq_ids": {"n4140": {"so_35687736_35687838_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 3312}}, "n3337": {"so_35687736_35687838_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 3182}}, "n4659": {"so_35687736_35687838_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 4078}}}, "35687736": {"ViewCount": "59", "Body": "<p>I have a feeling the answer to this question is no, but is it possible to initialise a specific member of a union?  For example the following:</p>\n<pre><code>#include &lt;cassert&gt;\n#include &lt;Windows.h&gt;\n\nint _tmain(int argc, _TCHAR* argv[])\n{\n    auto time = 20090520145024798ull;\n\n    auto large = ULARGE_INTEGER() = {           \n        { time }\n    };\n\n    assert(large.QuadPart == time);\n\n    return 0;\n}\n</code></pre>\n<p>(Visual Studio 2013, Windows 10), produces a compiler \"conversion from 'unsigned __int64' to 'DWORD'\", implying it's going to try to shoe-horn the uint64_t into the DWORD. </p>\n<p>ULARGE_INTEGER is the union:</p>\n<pre><code>typedef union _ULARGE_INTEGER {\n    struct {\n        DWORD LowPart;\n        DWORD HighPart;\n    } u;\n    ULONGLONG QuadPart;\n} ULARGE_INTEGER;\n</code></pre>\n<p>What does the standard say about order of initialisation in cases like this?  I had hoped the compiler would see that QuadPart was the appropriate member to assign.</p>\n", "AcceptedAnswerId": "35687838", "Title": "Initialiser, specific member of a union", "CreationDate": "2016-02-28T20:16:41.247", "Id": "35687736", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-02-28T20:30:54.827", "Score": "0", "OwnerUserId": "416274", "Tags": "<c++><winapi><unions>", "AnswerCount": "2"}, "35687828": {"Id": "35687828", "PostTypeId": "2", "Body": "<p>Keeping it simple:</p>\n<pre><code>ULARGE_INTEGER large;\nlarge.QuadPart = time;\n</code></pre>\n<p>Or if you want to use auto and initialize it in one line, make a little helper perhaps?</p>\n<pre><code>inline auto MAKE_ULARGE_INTEGER(ULONGLONG t)\n{\n    ULARGE_INTEGER result;\n    result.QuadPart = t;\n    return result;\n}\n\nauto large = MAKE_ULARGE_INTEGER(time);\n</code></pre>\n", "LastEditorUserId": "5866175", "LastActivityDate": "2016-02-28T20:30:54.827", "Score": "3", "CreationDate": "2016-02-28T20:25:05.887", "ParentId": "35687736", "CommentCount": "5", "OwnerUserId": "5866175", "LastEditDate": "2016-02-28T20:30:54.827"}, "35687838": {"Id": "35687838", "PostTypeId": "2", "Body": "<p>With unions, you can use list-initialization to initialize the first member only, as per [dcl.init.aggr]:</p>\n<blockquote>\n<p id=\"so_35687736_35687838_0\">When a union is initialized with a brace-enclosed initializer, the braces shall only contain an <em>initializer-clause</em>\n  for the first non-static data member of the union. <em>[ Example:</em></p>\n<pre><code>union u { int a; const char* b; };\nu a = { 1 };\nu b = a;\nu c = 1; // error\nu d = { 0, \"asdf\" }; // error\nu e = { \"asdf\" }; // error\n</code></pre>\n<p id=\"so_35687736_35687838_1\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p>So, in your example, the following:</p>\n<pre><code>ULARGE_INTEGER large{time};\n</code></pre>\n<p>would initialize <code>u.LowPart</code>, not <code>QuadPart</code>, regardless of what the types of the various members are.</p>\n<p>If you want to do anything else, you'll have to be explicit about it:</p>\n<pre><code>ULARGE_INTEGER large;\nlarge.QuadPart = time;\n</code></pre>\n<p>Or write a better <code>union</code> type that actually has a constructor. </p>\n", "LastActivityDate": "2016-02-28T20:26:17.137", "CommentCount": "1", "CreationDate": "2016-02-28T20:26:17.137", "ParentId": "35687736", "Score": "4", "OwnerUserId": "2069064"}});