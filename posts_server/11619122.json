post_cb({"bq_ids": {"n4140": {"so_11619122_11619122_3": {"length": 4, "quality": 0.8, "section_id": 7106}, "so_11619122_11619122_1": {"length": 30, "quality": 0.7692307692307693, "section_id": 7104}, "so_11619122_11619310_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 7104}, "so_11619122_11619122_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 7106}}, "n3337": {"so_11619122_11619122_3": {"length": 4, "quality": 0.8, "section_id": 6850}, "so_11619122_11619122_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 6850}, "so_11619122_11619310_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 6848}, "so_11619122_11619122_1": {"length": 31, "quality": 0.7948717948717948, "section_id": 6848}}, "n4659": {"so_11619122_11619122_3": {"length": 4, "quality": 0.8, "section_id": 8607}, "so_11619122_11619122_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 8607}, "so_11619122_11619310_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 8605}, "so_11619122_11619122_1": {"length": 30, "quality": 0.7692307692307693, "section_id": 8605}}}, "11619310": {"Id": "11619310", "PostTypeId": "2", "Body": "<p>From n3337, which is basically C++11 with minor editorial changes, the 3.4.2/2 reads:</p>\n<blockquote>\n<p id=\"so_11619122_11619310_0\">For each argument type T in the function call [...] The sets of\n  namespaces and classes are determined in the following way: [...] </p>\n<ul>\n<li>If T is a class type (including unions), its associated classes are: the class itself; the class of which it is a member, if any; and <strong>its direct and indirect base classes</strong>. Its associated namespaces are the namespaces of which its associated classes are members. <strong>Furthermore</strong>, if T is a class template specialization, ...</li>\n</ul>\n</blockquote>\n<p>And it then continues with basically the same quote you posted in the question. The important difference here is the <strong>furthermore</strong>, which means that the list that you quoted (and I omitted) is in addition to the already mentioned namespaces, and that includes the namespaces of which the base class is a member.</p>\n<ol>\n<li><p>Gcc and comeau are right, and clang++ is wrong in rejecting the code.</p></li>\n<li><p>&lt; does not apply &gt;</p></li>\n<li><p>Clang++ is wrong in rejecting it without the <code>using NA::add_ref</code>.</p></li>\n<li><p><strike>Yes, you should probably report a bug.</strike> It seems that it has already been reported and fixed.</p></li>\n</ol>\n", "LastEditorUserId": "36565", "LastActivityDate": "2012-07-23T21:19:01.387", "Score": "6", "CreationDate": "2012-07-23T19:37:52.447", "ParentId": "11619122", "CommentCount": "3", "OwnerUserId": "36565", "LastEditDate": "2012-07-23T21:19:01.387"}, "11619122": {"ViewCount": "673", "Body": "<p>I have a template class <code>NB::B&lt;T&gt;</code> derived from a non-template class <code>NA::A</code> in a namespace. <code>act&lt;T&gt;</code> is a template function calling <code>add_ref</code> function on an instance of its template argument. Specifically, <code>act&lt;NB::B&lt;int&gt;&gt;</code> wants to find <code>add_ref</code> defined in the namespace of <code>NB::B</code>'s base using ADL. The complete example is following:</p>\n<pre><code>template&lt;class T&gt;\nvoid act() {\n  T* p = 0;\n  add_ref(p); // the failing line\n}\n\nnamespace NA\n{\n  struct A { };\n\n  // I want ADL to find this:\n  void add_ref(A* p) {\n  }\n}\n\nnamespace NB\n{\n  // template class with non-template base\n  template &lt;class T&gt;\n  struct B: NA::A { };\n\n  typedef B&lt;int&gt; Bi;\n\n  // using NA::add_ref; // fixes the problem\n}\n\nint main()\n{\n  act&lt;NB::Bi&gt;();\n}\n</code></pre>\n<p>This compiles okay in <code>gcc</code> (4.7.0). And in <code>Comeau</code> online. However <code>clang</code> (3.1) fails:</p>\n<pre><code>a.cpp:4:3: error: use of undeclared identifier 'add_ref'\n</code></pre>\n<p>At the same time, the standard reads:</p>\n<blockquote>\n<p id=\"so_11619122_11619122_0\">3.4.2/2 \u2026</p>\n<p id=\"so_11619122_11619122_1\">\u2014 If T is a template-id, its associated namespaces and classes are the namespace in which the template is defined; for member templates, the member template\u2019s class; the namespaces and classes associated with the types of the template arguments provided for template type parameters (excluding template template parameters); the namespaces in which any template template arguments are defined; and the classes in which any member templates used as template template arguments are defined.</p>\n</blockquote>\n<p>Surprisingly, template's bases aren't listed as paths to associated namespaces. Thus <code>clang</code>'s behavior appears to be correct. And <code>Comeau</code> and <code>gcc</code> are accepting incorrect program.</p>\n<p>At the same time, <code>3.4.2/3</code> states that <code>using</code>'s in argument's namespaces have no effect:</p>\n<blockquote>\n<p id=\"so_11619122_11619122_2\">When considering an associated namespace, the lookup is the same as the lookup performed when the associated namespace is used as a qualifier (3.4.3.2) except that:</p>\n<p id=\"so_11619122_11619122_3\">\u2014 Any using-directives in the associated namespace are ignored.</p>\n</blockquote>\n<p>But when I uncomment the <code>using NA::add_ref</code> line <code>clang</code> is happy to compile the test.</p>\n<p>To put my example into practical perspective, you can think that <code>act</code> was a method of <code>boost::intrusive_ptr</code>, <code>add_ref(A*)</code> was <code>intrusive_ptr_add_ref(CBase*)</code> and <code>B</code> was some template, deriving from base <code>CBase</code>.</p>\n<p>Regarding this I have several questions:</p>\n<ol>\n<li><p>Am I right that <code>clang</code>'s is correct rejecting my test program, and <code>gcc</code> and <code>Comeau</code> don't follow the standard?</p></li>\n<li><p>Is there a reason why the standard specifies such an impractical behavior (disallows template class bases as associated namespaces)?</p></li>\n<li><p>Is <code>clang</code> wrong accepting my test program with the <code>using NA::add_ref</code> directive on the grounds of <code>3.4.2/3</code>?</p></li>\n<li><p>Should I report a bug? :)</p></li>\n</ol>\n<p>P.S. I have read <a href=\"http://clang.llvm.org/compatibility.html\" rel=\"nofollow\">clang Language Compatibility FAQ</a> and didn't find an answer there.</p>\n", "AcceptedAnswerId": "11619310", "Title": "Argument-dependent lookup through base of a template class", "CreationDate": "2012-07-23T19:25:29.827", "Id": "11619122", "CommentCount": "6", "LastEditDate": "2012-07-24T16:29:46.453", "PostTypeId": "1", "LastEditorUserId": "1065190", "LastActivityDate": "2012-07-24T16:29:46.453", "Score": "8", "OwnerUserId": "242791", "Tags": "<c++><templates><gcc><clang><argument-dependent-lookup>", "AnswerCount": "1"}});