post_cb({"bq_ids": {"n4140": {"so_15769226_15769395_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 5341}}, "n3337": {"so_15769226_15769395_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 5138}}, "n4659": {"so_15769226_15769395_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 6762}}}, "15769959": {"Id": "15769959", "PostTypeId": "2", "Body": "<p>To reduce what Andy says to the essentials: if the implementation has one or more standard integer types that is capable of representing <code>0xFFFFFFFFFFFFFFFF</code>, then the literal <code>0xFFFFFFFFFFFFFFFF</code> has <em>one</em> of those types.</p>\n<p>It doesn't really matter to you which once, since no matter which it is the result of the conversion of <code>uint64_t</code> is the same.</p>\n<p>If the (pre-C++11) implementation doesn't have any integer type big enough then (a) the program is ill-formed, so you should get a diagnostic; and (b) it <em>probably</em> won't have <code>uint64_t</code> anyway.</p>\n<p>You are correct that the <code>static_cast</code> is unnecessary. It does the same conversion that assigning to <code>uint64_t</code> would do anyway. Sometimes a cast will suppress compiler warnings that you get for certain implicit integer conversions, but I think it's unlikely that any compiler would warn for an implicit conversion in this case. Often there won't be one, since <code>0xFFFFFFFFFFFFFFFF</code> will commonly have type <code>uint64_t</code> already.</p>\n<p>As an aside, it's probably better to write <code>static_cast&lt;uint64_t&gt;(-1)</code>, or just <code>uint64_t a = -1;</code>. It's guaranteed to be equal to <code>0xFFFFFFFFFFFFFFFF</code>, but it's much easier for a reader to see the difference between <code>-1</code> and <code>0xFFFFFFFFFFFFFFF</code> than it is to see the difference between <code>0xFFFFFFFFFFFFFFFF</code> and <code>0xFFFFFFFFFFFFFFF</code>.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2013-04-02T17:13:23.293", "Score": "4", "CreationDate": "2013-04-02T17:01:44.843", "ParentId": "15769226", "CommentCount": "1", "OwnerUserId": "13005", "LastEditDate": "2013-04-02T17:13:23.293"}, "15769395": {"Id": "15769395", "PostTypeId": "2", "Body": "<p>Per Paragraph 2.1.14/2 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15769226_15769395_0\">The type of an integer literal is the first of the corresponding list in Table 6 in which its value can be\n  represented</p>\n</blockquote>\n<p>Table 6 specifies that for hexadecimal literal constants, the type of the literal should be:</p>\n<ul>\n<li><code>int</code>; or (if it doesn't fit)</li>\n<li><code>unsigned int</code>; or (if it doesn't fit)</li>\n<li><code>long int</code>; or (if it doesn't fit)</li>\n<li><code>unsigned long int</code>; or (if it doesn't fit)</li>\n<li><code>long long int</code>; or (if it doesn't fit)</li>\n<li><code>unsigned long long int</code>.</li>\n</ul>\n<p>If we make the reasonable assumption that <code>0xFFFFFFFFFFFFFFFF</code> will not fit in any of the first 5 types from the above list, its type should be <code>unsigned long long int</code>. As long as you are working with a 64 bit compiler, it is reasonable to assume that values of this type will have a size of 64 bit, and the constant will be interpreted as a 64-bit <code>unsigned long long int</code>, as you hoped.</p>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-04-02T16:43:50.630", "Score": "5", "CreationDate": "2013-04-02T16:32:17.733", "ParentId": "15769226", "CommentCount": "8", "OwnerUserId": "1932150", "LastEditDate": "2013-04-02T16:43:50.630"}, "15769226": {"ViewCount": "516", "Body": "<p>I am modifying legacy code that utilizes a \"long long\" (<code>LL</code>) data type definition for a hard-coded constant, as follows:</p>\n<pre><code>0xFFFFFFFFFFFFFFFFLL\n</code></pre>\n<p>I trust that the <code>LL</code> appended to the constant guarantees that this constant will be interpreted as a <code>long long</code>.</p>\n<p>However, I do not want to depend on <code>long long</code> having any particular compiler-dependent interpretation in terms of the number of bits.</p>\n<p>Therefore, I would like my variable declaration to do without the <code>LL</code> in the constant, and instead use:</p>\n<pre><code>uint64_t a = static_cast&lt;uint64_t&gt;(0xFFFFFFFFFFFFFFFF);\n</code></pre>\n<p>I would like to think that the constant <code>0xFFFFFFFFFFFFFFFF</code> is not interpreted by the compiler as a 32-bit integer BEFORE the cast to <code>uint64_t</code>, which would result in <code>a</code> being a 64-bit integer that contained the value <code>0xFFFFFFFF</code>, rather than the desired value.</p>\n<p>(My current 64-bit compilers of interest are VS 2010, and Ubuntu 12.04 LTS GCC.  However, I would hope that this code behaves in the desired way for any modern compiler.)</p>\n<p>Will the above code work as desired for most or all modern compilers, so the the value of <code>a</code> is properly set to include all digits, as desired, from the constant <code>0xFFFFFFFFFFFFFFFF</code>, WITHOUT including the <code>LL</code> at the end of the constant?</p>\n<p>(Note: Including <code>I64</code> at the end of the constant gives a compiler error.  Perhaps there is another token that needs (or can) be included at the end of the constant to tell the compiler to interpret the constant as a 64-bit integer?) </p>\n<p>(Also: Perhaps even the <code>static_cast&lt;uint64_t&gt;</code> is unnecessary, since the variable is explicitly being defined as uint64_t?)</p>\n", "AcceptedAnswerId": "15769959", "Title": "Can \"LL\" be removed from a hard-coded integer constant, and be replaced by \"static_cast<uint64_t>(...)\"?", "CreationDate": "2013-04-02T16:23:30.703", "Id": "15769226", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-04-02T17:15:44.773", "Score": "3", "OwnerUserId": "368896", "Tags": "<c++>", "AnswerCount": "2"}});