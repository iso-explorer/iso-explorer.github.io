post_cb({"21052932": {"PostTypeId": "2", "ParentId": "21052836", "Body": "<p>Generally, in portable C++, no; because the system (compiler, runtime, etc) is free to order and space struct/class members as it pleases. For example, to align members on CPU word boundaries.</p>\n<p>If you control the compiler used to build the project you <em>can</em> get away with it. If you're using VC you'll need to use <code>#pragma pack</code>: <a href=\"http://msdn.microsoft.com/en-us/library/2e70t5y1.aspx\" rel=\"nofollow\">http://msdn.microsoft.com/en-us/library/2e70t5y1.aspx</a></p>\n", "CreationDate": "2014-01-10T19:35:44.820", "Score": "0", "CommentCount": "1", "Id": "21052932", "OwnerUserId": "159145", "LastActivityDate": "2014-01-10T19:35:44.820"}, "21053383": {"PostTypeId": "2", "ParentId": "21052836", "Body": "<p>It's safe, but beware <a href=\"https://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule\">breaking strict aliasing</a>!</p>\n<p>In C++11 jargon your struct is <a href=\"http://en.cppreference.com/w/cpp/concept/StandardLayoutType\" rel=\"nofollow noreferrer\">Standard Layout</a>, hence it's safe to cast it via <code>reinterpret_cast</code> to its first member: </p>\n<blockquote>\n<p id=\"so_21052836_21053383_0\"><strong>\u00a7 9.2.20 Class members [class.mem]</strong></p>\n<p id=\"so_21052836_21053383_1\">A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa.</p>\n</blockquote>\n<p>The subsequent floats are then contiguous in memory, just like an array.</p>\n<hr>\n<p>Why dont you provide an <code>operator[]</code>?</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2014-01-10T20:00:36.700", "LastEditDate": "2017-05-23T11:49:41.733", "CommentCount": "1", "Id": "21053383", "OwnerUserId": "1873944", "Score": "1", "CreationDate": "2014-01-10T20:00:36.700"}, "21052836": {"AcceptedAnswerId": "21053383", "Body": "<p>I've got a non-virtual final class that declares only same type fields. </p>\n<pre><code>struct Vector3 final\n{\n    float X, Y, Z;\n    Vector3(float x, float y, float z) : X(x), Y(y), Z(z)\n    {\n\n    }\n\n    float Sum()\n    {\n        return X + Y + Z;\n    }\n};\n</code></pre>\n<p>Is it safe to reinterpret pointer to instance of this class to array of floats?</p>\n<pre><code>int main(int argc, const char *argv[])\n{\n    Vector3 v(10, 20, 30);\n    Vector3 *pV = &amp;v;\n    float *ff = reinterpret_cast&lt;float*&gt;(pV);\n\n    std::cout &lt;&lt; ff[0] &lt;&lt; std::endl &lt;&lt; ff[1] &lt;&lt; std::endl &lt;&lt; ff[2] &lt;&lt; std::endl;\n\n    char c;\n    std::cin &gt;&gt; c;\n\n    return 0;\n}\n</code></pre>\n", "CreationDate": "2014-01-10T19:30:42.413", "Score": "0", "CommentCount": "3", "OwnerUserId": "796078", "Title": "Is c++ final non-virtual class reinterpreted as array safe for use?", "LastActivityDate": "2014-01-10T20:00:36.700", "PostTypeId": "1", "Tags": "<c++><arrays><pointers><c++11><reinterpret-cast>", "AnswerCount": "3", "FavoriteCount": "1", "Id": "21052836", "ViewCount": "149"}, "21052891": {"PostTypeId": "2", "ParentId": "21052836", "Body": "<p>No, it isn't -- there may be padding between the data members.</p>\n", "CreationDate": "2014-01-10T19:33:22.843", "Id": "21052891", "CommentCount": "9", "OwnerDisplayName": "user529758", "Score": "6", "LastActivityDate": "2014-01-10T19:33:22.843"}, "bq_ids": {"n3337": {"so_21052836_21053383_1": {"quality": 1.0, "length": 19, "section_id": 5650}}}});