post_cb({"bq_ids": {"n4140": {"so_34714752_34714752_3": {"length": 44, "quality": 1.0, "section_id": 332}, "so_34714752_35725616_2": {"length": 6, "quality": 1.0, "section_id": 143}, "so_34714752_34716639_1": {"length": 16, "quality": 0.8421052631578947, "section_id": 76}, "so_34714752_35725616_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 144}, "so_34714752_35725616_3": {"length": 8, "quality": 1.0, "section_id": 143}, "so_34714752_35725616_0": {"length": 30, "quality": 0.967741935483871, "section_id": 143}, "so_34714752_34714752_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 144}}, "n3337": {"so_34714752_34714752_3": {"length": 44, "quality": 1.0, "section_id": 322}, "so_34714752_35725616_2": {"length": 6, "quality": 1.0, "section_id": 137}, "so_34714752_34716639_1": {"length": 16, "quality": 0.8421052631578947, "section_id": 71}, "so_34714752_35725616_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 138}, "so_34714752_35725616_3": {"length": 8, "quality": 1.0, "section_id": 137}, "so_34714752_35725616_0": {"length": 30, "quality": 0.967741935483871, "section_id": 137}, "so_34714752_34714752_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 138}}, "n4659": {"so_34714752_34714752_3": {"length": 44, "quality": 1.0, "section_id": 341}, "so_34714752_35725616_2": {"length": 6, "quality": 1.0, "section_id": 147}, "so_34714752_34716639_1": {"length": 16, "quality": 0.8421052631578947, "section_id": 78}, "so_34714752_35725616_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 148}, "so_34714752_35725616_3": {"length": 8, "quality": 1.0, "section_id": 147}, "so_34714752_35725616_0": {"length": 30, "quality": 0.967741935483871, "section_id": 147}, "so_34714752_34714752_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 148}}}, "34716639": {"Id": "34716639", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_34714752_34716639_0\">In my understanding the int in S is not specified in terms of template parameters, so 14.8.2.5 does not apply.</p>\n</blockquote>\n<p>No, <code>14.8.2.5</code> explains <i>how</i> to deduce the type, <code>14.3</code> deals with template arguments and the code you have posted fails <code>14.3p1</code>: </p>\n<blockquote>\n<p id=\"so_34714752_34716639_1\">14.3p1\n  ... The type and form of each template-argument specified in a template-id shall match the type and form specified for the corresponding parameter declared by the template in its template parameter-list. </p>\n</blockquote>\n<pre><code>template&lt;class T, class U&gt;\nstruct S&lt;int, U&gt; {}; \n// compiler error, template parameters not used in partial specialization\n</code></pre>\n<p>should be</p>\n<pre><code>template&lt;class U&gt;\nstruct S&lt;int, U&gt; {};\n</code></pre>\n<p>So, </p>\n<pre><code>#1\ntemplate&lt;class T, class U&gt;\nstruct S{};\n\n#2\ntemplate&lt;class U&gt;\nstruct S&lt;int, U&gt; {};\n\nS&lt;char, int&gt; s; // uses #1\nS&lt;int, char&gt; c; // uses #2 since S&lt;int, U&gt; matches more closely than S&lt;T, U&gt;\n</code></pre>\n<p>You mention that <code>gcc</code> rejected the template while <code>clang</code> accepted it. In my tests, <code>VC++</code> and <code>gcc</code> gave a compiler error by default and did not compile the code at all, <code>clang</code>, however, gave a warning instead stating that <code>this partial specialization will never be used</code> and built the binary anyways. So in all instances it's giving the notice of non-conformity, it's just a matter of what compiler settings are on by default and how the compiler implementation handles non-conforming code.</p>\n<p>Hope that can help.</p>\n", "LastEditorUserId": "1152524", "LastActivityDate": "2016-01-11T08:28:02.257", "Score": "4", "CreationDate": "2016-01-11T08:03:04.410", "ParentId": "34714752", "CommentCount": "1", "OwnerUserId": "1152524", "LastEditDate": "2016-01-11T08:28:02.257"}, "34714752": {"ViewCount": "263", "Body": "<blockquote>\n<p id=\"so_34714752_34714752_0\">n4567 [temp.class.spec.match]p2</p>\n<p id=\"so_34714752_34714752_1\">A partial specialization matches a given actual template argument list if the template arguments of the partial specialization can be deduced from the actual template argument list (14.8.2).</p>\n</blockquote>\n<pre><code>template&lt;class T, class U&gt;\nstruct S{};\n\ntemplate&lt;class U&gt;\nstruct S&lt;int, U&gt;{};\n\nS&lt;char, int&gt; s;\n</code></pre>\n<p>I know partial specialization <code>S&lt;int, U&gt;</code> do not match the actual template argument list <code>char, int</code>, and the second argument <code>U</code> can be deduced frome <code>int</code> accroding to 14.8.2.5. </p>\n<p>But I don't know which rules in 14.8.2 apply for the first argument <code>int</code>.</p>\n<blockquote>\n<p id=\"so_34714752_34714752_2\">14.8.2.5 [temp.deduct.type]p1</p>\n<p id=\"so_34714752_34714752_3\">Template arguments can be deduced in several different contexts, but in each case <strong>a type that is specified in terms of template parameters</strong> (call it <code>P</code>) is compared with an actual type (call it <code>A</code>), and an attempt is made to find template argument values (a type for a type parameter, a value for a non-type parameter, or a template for a template parameter) that will make <code>P</code>, after substitution of the deduced values (call it the\n  deduced <code>A</code>), compatible with <code>A</code>.</p>\n</blockquote>\n<p>In my understanding the <code>int</code> in <code>S&lt;int, U&gt;</code> is <strong>not</strong> specified in terms of template parameters, so 14.8.2.5 does <strong>not</strong> apply.</p>\n<p>I want to know which rules handle this case or you can correct me about 14.8.2.5</p>\n<hr>\n<p>In other words:\nIntuitively, the partial specialization <code>S&lt;int, U&gt;</code> does not match <code>char,int</code> because <code>char</code> does not match <code>int</code>. </p>\n<p>I want to know which rules determine <code>char</code> does not match <code>int</code>.</p>\n</hr>", "AcceptedAnswerId": "35725616", "Title": "Which rules apply when an argument of partial specialization does not use any of its template parameters", "CreationDate": "2016-01-11T05:30:38.333", "Id": "34714752", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-03-01T20:06:43.477", "LastEditorUserId": "4958516", "LastActivityDate": "2016-03-01T20:06:43.477", "Score": "3", "OwnerUserId": "4958516", "Tags": "<c++><templates><language-lawyer><partial-specialization>", "AnswerCount": "2"}, "35725616": {"Id": "35725616", "PostTypeId": "2", "Body": "<p>When considering what happens here:</p>\n<pre><code>template&lt;class T, class U&gt; struct S{}; // (1)\ntemplate&lt;class U&gt; struct S&lt;int, U&gt;{};  // (2)\n\nS&lt;char, int&gt; s; // (1) or (2)?\n</code></pre>\n<p>To determine which specialization we use for <code>s</code>, we go into [temp.class.spec.match]:</p>\n<blockquote>\n<p id=\"so_34714752_35725616_0\">When a class template is used in a context that requires an instantiation of the class, it is necessary to\n  determine whether the instantiation is to be generated using the primary template or one of the partial\n  specializations. This is done by matching the template arguments of the class template specialization with\n  the template argument lists of the partial specializations.</p>\n</blockquote>\n<p>In this case, we're matching <code>&lt;char, int&gt;</code> against <code>&lt;int, U&gt;</code>. What does matches mean?</p>\n<blockquote>\n<p id=\"so_34714752_35725616_1\">A partial specialization matches a given actual template argument list if the template arguments of the\n  partial specialization can be deduced from the actual template argument list (14.8.2).</p>\n</blockquote>\n<p>Basically, we're deducing <code>U</code> to match <code>int == char</code> and <code>U == int</code>. Equivalently, we're looking at deducing <code>U</code> in:</p>\n<pre><code>template &lt;class U&gt; void f(S&lt;int, U&gt; );\nf(S&lt;char, int&gt;{} );\n</code></pre>\n<p>There is no such deduction. </p>\n<p>This leads us to:</p>\n<blockquote>\n<p id=\"so_34714752_35725616_2\">\u2014 If no matches are found, the instantiation is generated from the primary template.</p>\n</blockquote>\n<p>That leads us to <code>(1)</code>. </p>\n<p>Let's take a more interesting case:</p>\n<pre><code>S&lt;int, char&gt; s2;\n</code></pre>\n<p>Now, <code>&lt;int, char&gt;</code> matches against <code>&lt;int, U&gt;</code>, because we can deduce <code>U=char</code>. Hence:</p>\n<blockquote>\n<p id=\"so_34714752_35725616_3\">\u2014 If exactly one matching specialization is found, the instantiation is generated from that specialization.</p>\n</blockquote>\n<p>That leads us to <code>(2)</code>.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-03-01T16:45:22.240", "Score": "0", "CreationDate": "2016-03-01T14:32:29.577", "ParentId": "34714752", "CommentCount": "8", "OwnerUserId": "2069064", "LastEditDate": "2016-03-01T16:45:22.240"}});