post_cb({"1736654": {"CommentCount": "0", "ViewCount": "1101", "PostTypeId": "1", "LastEditorUserId": "168225", "CreationDate": "2009-11-15T05:11:35.190", "LastActivityDate": "2016-02-18T13:22:24.463", "Title": "Macros as arguments to preprocessor directives", "AcceptedAnswerId": "1736711", "LastEditDate": "2016-02-18T13:22:24.463", "Id": "1736654", "Score": "3", "Body": "<p>Being faced with the question whether it's possible to choose <code>#include</code>s in the preprocessor I immediately thought <em>not possible</em>.<br>\n.. Only to later find out that it is indeed possible and you only need to watch out for argument expansions (which e.g. Boost.Preprocessor can take care of).</br></p>\n<p>While I'd avoid actually doing that for includes if possible, I'd like to know why this works. At the moment I fail to get a useful understanding in the C++ or <strong>C</strong> standard.<br>\nAre parameterized macros allowed for any preprocessor-directive? (except <code>#define</code>/<code>#undef</code>)<br>\nCan someone reference where this is allowed and summarize it?  </br></br></p>\n<p><em>Example for the curious utilizing Boost.Preprocessor for simplicity:</em></p>\n<pre><code>#include &lt;boost/preprocessor/cat.hpp&gt;\n#include &lt;boost/preprocessor/stringize.hpp&gt;\n\n#define INC_LOCAL(a,b)  BOOST_PP_STRINGIZE(BOOST_PP_CAT(BOOST_PP_CAT(a,b),.h))\n#define INC_GLOBAL(a,b) BOOST_PP_CAT(BOOST_PP_CAT(&lt;,a),BOOST_PP_CAT(b,&gt;))\n\n#include INC_LOCAL(loc,al)   // #include \"local.h\"\n#include INC_GLOBAL(vect,or) // #include &lt;vector&gt;\n</code></pre>\n<p><em>Update</em>: \nReferenced <strong>C</strong> standard, clarified question.</p>\n", "Tags": "<c++><macros><c-preprocessor>", "OwnerUserId": "168225", "AnswerCount": "2"}, "1736711": {"ParentId": "1736654", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>From \u00a7 16.2-4 (\"Source file inclusion\") of C++ 2003 draft:</p>\n<blockquote>\n<p id=\"so_1736654_1736711_0\">A preprocessing directive of the form </p>\n<pre><code># include pp-tokens new-line \n</code></pre>\n<p id=\"so_1736654_1736711_1\">(that does not match one of the two previous forms) is permitted. The preprocessing tokens after <code>include</code> in the directive are processed just as in normal text (each identifier currently defined as a macro name is replaced by its replacement list of preprocessing tokens). </p>\n</blockquote>\n<p>\u00a7 6.10.2-4 of C99 says the same.</p>\n<p>The \"two previous forms\" mentioned above are <code># include &lt;h-char-sequence&gt;</code> and <code># include \"q-char-sequence\"</code>. The section seems too simple to summarize.</p>\n<p>For other directives, macro expansion isn't performed on any <code>identifier</code> preprocessing token (note this behavior is not defined by the grammar, but by C++ \u00a7 16 / C \u00a7 6.10):</p>\n<pre><code># if constant-expression new-line [group] \n# ifdef identifier new-line [group] \n# ifndef identifier new-line [group] \n# elif constant-expression new-line [group] \n# else new-line [group] \n# endif new-line \n# include pp-tokens new-line \n# define identifier replacement-list new-line \n# define identifier lparen [identifier-list] ) replacement-list new-line \n# undef identifier new-line \n# line pp-tokens new-line \n# error [pp-tokens] new-line \n# pragma [pp-tokens] new-line \n# new-line \n</code></pre>\n<p><code>#line</code> is explicitly macro-expanded by C++ \u00a7 16.4-5 / C \u00a7 6.10.4-5. Expansion for <code>#error</code> (C++ \u00a7 16.5 / C \u00a7 6.10.5) and <code>#pragma</code> (C++ \u00a7 16.6 / C \u00a7 6.10.6) isn't mentioned. C++ \u00a7 16.3-7 / C 6.10.3-8 states:</p>\n<blockquote>\n<p id=\"so_1736654_1736711_2\">If a # preprocessing token, followed by an identifier, occurs lexically at the point at which a preprocessing directive could begin, the identifier is not subject to macro replacement. </p>\n</blockquote>\n<p>C++ \u00a7 16.3.1 / C \u00a7 6.10.3.1-1 tells us that when the arguments to a macro function are substituted into the <code>replacement-list</code>, they are first macro expanded. Similarly, C++ \u00a7 16.3.4 / C \u00a7 6.10.3.4 has the preprocessor macro-expand the <code>replacement-list</code> after substitution.</p>\n<p>In summary, macro expansion is done for <code>#if</code>, <code>#elif</code>, <code>#include</code>, <code>#line</code>, the arguments to a macro function and the body of a macro function when substituted. I think that's everything.</p>\n", "OwnerUserId": "90527", "LastEditorUserId": "90527", "LastEditDate": "2009-11-15T06:26:55.923", "Id": "1736711", "Score": "7", "CreationDate": "2009-11-15T05:39:40.200", "LastActivityDate": "2009-11-15T06:26:55.923"}, "bq_ids": {"n4140": {"so_1736654_1736711_2": {"section_id": 518, "quality": 1.0, "length": 15}, "so_1736654_1736711_1": {"section_id": 506, "quality": 0.9655172413793104, "length": 28}}, "n3337": {"so_1736654_1736711_2": {"section_id": 509, "quality": 1.0, "length": 15}, "so_1736654_1736711_1": {"section_id": 497, "quality": 0.9310344827586207, "length": 27}}, "n4659": {"so_1736654_1736711_2": {"section_id": 539, "quality": 1.0, "length": 15}, "so_1736654_1736711_1": {"section_id": 527, "quality": 0.9655172413793104, "length": 28}}}, "1736665": {"ParentId": "1736654", "CommentCount": "1", "Body": "<p>It's a very fundamental feature of the C preprocessor -- for example, a directive such as <code>#ifdef</code> makes zero sense <strong>except</strong> when used with an argument that's possibly a macro (if you had to know that the argument is not allowed to be a macro, what could the purpose of <code>#ifdef</code> possibly <strong>be</strong>?!).</p>\n<p>I'm not sure how chapter and verse of the ISO C standard would help you -- the C++ standard, as I recall, does not change the preprocessor's operation anyway.</p>\n", "OwnerUserId": "95810", "PostTypeId": "2", "Id": "1736665", "Score": "2", "CreationDate": "2009-11-15T05:17:15.770", "LastActivityDate": "2009-11-15T05:17:15.770"}});