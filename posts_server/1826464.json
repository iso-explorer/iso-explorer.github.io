post_cb({"7420711": {"ParentId": "1826464", "LastEditDate": "2011-09-14T17:54:44.063", "CommentCount": "3", "CreationDate": "2011-09-14T17:49:00.587", "OwnerUserId": "168175", "LastEditorUserId": "168175", "PostTypeId": "2", "Id": "7420711", "Score": "5", "Body": "<p>With C++11 you can fairly sanely represent string literals as variadic template arguments, i.e. a collection of int template parameters. I've put together a proof of concept example that sets up one such template without manually having to write <code>foo&lt;16, 73, 51 ...&gt;</code> for every such string. </p>\n<p>Example:</p>\n<pre><code>// The template we want to pass a string to\ntemplate &lt;int... Args&gt;\nstruct foo {\n  // It needs one helper function for decltype magic, this could be avoided though\n  template &lt;int N&gt;\n  static foo&lt;N, Args...&gt;  add_one();\n};\n\n// This is the string we want to use with foo, simulating foo&lt;\"Hello world!\" __FILE__&gt;:\nconstexpr const char *teststr = \"Hello world!\" __FILE__;\n\n// Get char N of a string literal\nconstexpr int strchr(const char *str, int N) { return str[N]; }\n\n// recursive helper to build the typedef from teststr\ntemplate &lt;int N, int P=0&gt;\nstruct builder {\n   typedef typename builder&lt;N, P+1&gt;::type child;\n   typedef decltype(child::template add_one&lt;strchr(teststr,P)&gt;()) type;\n};\n\ntemplate &lt;int N&gt;\nstruct builder&lt;N,N&gt; {\n  typedef foo&lt;strchr(teststr, N)&gt; type;\n};\n\n// compile time strlen\nconstexpr int slen(const char *str) {\n  return *str ? 1 + slen(str+1) : 0;\n}\n\nint main() {\n  builder&lt;slen(teststr)&gt;::type test;\n  // compile error to force the type to be printed:\n  int foo = test;\n}\n</code></pre>\n<p>You'll need at least gcc 4.6 for <code>constexpr</code> and it could use some polish still but the compiler error I get indicates the type is being built sanely:</p>\n<pre><code>error: cannot convert \u2018builder&lt;19&gt;::type {aka foo&lt;72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33, 115, 108, 105, 116, 46, 99, 99, 0&gt;}\u2019 to \u2018int\u2019 in initializatio\n</code></pre>\n", "LastActivityDate": "2011-09-14T17:54:44.063"}, "1826574": {"ParentId": "1826464", "CommentCount": "0", "Body": "<p>You can use address of string with external linkage as a template parameter, e.g.:</p>\n<pre><code>template &lt;const char** T&gt; class My {\npublic:\n    void do_stuff() {\n      std::cout &lt;&lt; \"zzz\";\n    }\n};\n\nconst char* str;\n\nint main()\n{\n  My&lt;&amp;str&gt; zz;\n    zz.do_stuff();\n\n    printf(\"Result: %d %d \\n\",  60 % 10 + 1, (60 % 10 ) + 1 );\n}\n</code></pre>\n<p></p>\n", "OwnerUserId": "74142", "PostTypeId": "2", "Id": "1826574", "Score": "1", "CreationDate": "2009-12-01T14:35:06.850", "LastActivityDate": "2009-12-01T14:35:06.850"}, "28209546": {"ParentId": "1826464", "LastEditDate": "2015-08-10T19:33:00.833", "CommentCount": "6", "CreationDate": "2015-01-29T07:55:06.993", "OwnerUserId": "306149", "LastEditorUserId": "306149", "PostTypeId": "2", "Id": "28209546", "Score": "7", "Body": "<p>Sorry to post on such an old question, but here's what I feel is the cleanest approach to actually pass a literal as the argument without using storage.</p>\n<p>Encode the string as a type:</p>\n<pre><code>template &lt;char... chars&gt;\nusing tstring = std::integer_sequence&lt;char, chars...&gt;;\n</code></pre>\n<p>Create a user defined literal operator:</p>\n<pre><code>template &lt;typename T, T... chars&gt;\nconstexpr tstring&lt;chars...&gt; operator\"\"_tstr() { return { }; }\n</code></pre>\n<p>And use partial specialization to recover the character data as needed:</p>\n<pre><code>template &lt;typename&gt;\nstruct X;\n\ntemplate &lt;char... elements&gt;\nstruct X&lt;tstring&lt;elements...&gt;&gt; {\n    const char* GetString() const\n    {\n        static constexpr char str[sizeof...(elements) + 1] = { elements..., '\\0' };\n        return str;\n    }\n};\n</code></pre>\n<p>This allows you to write:</p>\n<pre><code>X&lt;decltype(\"my_string\"_tstr)&gt;\n</code></pre>\n<p>The user defined literal uses non-standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3599.html\" rel=\"noreferrer\">n3599</a>) functionality not in C++14 but that is supported by recent GCC and Clang builds, and hopefully will be reconsidered for C++1z.</p>\n", "LastActivityDate": "2015-08-10T19:33:00.833"}, "18418071": {"ParentId": "1826464", "LastEditDate": "2017-07-23T20:29:24.823", "CommentCount": "1", "CreationDate": "2013-08-24T11:27:49.127", "OwnerUserId": "2713470", "LastEditorUserId": "3885376", "PostTypeId": "2", "Id": "18418071", "Score": "12", "Body": "<p>I known, this topic is a bit old but I put this comment if anyone is interested. I achieved templates with passing literal string as argument with combination of MACROS.  </p>\n<p>I made a code example,</p>\n<p><pre>\n\n<code>#include &lt;stdio.h&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;memory&gt;\n#include &lt;string.h&gt;\n\nusing namespace std;\n\n#define MAX_CONST_CHAR 100\n\n#define MIN(a,b) (a)&lt;(b)?(a):(b)\n\n#define _T(s)\\\ngetChr(s,0),\\\ngetChr(s,1),\\\ngetChr(s,2),\\\ngetChr(s,3),\\\ngetChr(s,4),\\\ngetChr(s,5),\\\ngetChr(s,6),\\\ngetChr(s,7),\\\ngetChr(s,8),\\\ngetChr(s,9),\\\ngetChr(s,10),\\\ngetChr(s,11),\\\ngetChr(s,12),\\\ngetChr(s,13),\\\ngetChr(s,14),\\\ngetChr(s,15),\\\ngetChr(s,16),\\\ngetChr(s,17),\\\ngetChr(s,18),\\\ngetChr(s,19),\\\ngetChr(s,20),\\\ngetChr(s,21),\\\ngetChr(s,22),\\\ngetChr(s,23),\\\ngetChr(s,24),\\\ngetChr(s,25),\\\ngetChr(s,26),\\\ngetChr(s,27),\\\ngetChr(s,28),\\\ngetChr(s,29),\\\ngetChr(s,30),\\\ngetChr(s,31),\\\ngetChr(s,32),\\\ngetChr(s,33),\\\ngetChr(s,34),\\\ngetChr(s,35),\\\ngetChr(s,36),\\\ngetChr(s,37),\\\ngetChr(s,38),\\\ngetChr(s,39),\\\ngetChr(s,40),\\\ngetChr(s,41),\\\ngetChr(s,42),\\\ngetChr(s,43),\\\ngetChr(s,44),\\\ngetChr(s,45),\\\ngetChr(s,46),\\\ngetChr(s,47),\\\ngetChr(s,48),\\\ngetChr(s,49),\\\ngetChr(s,50),\\\ngetChr(s,51),\\\ngetChr(s,52),\\\ngetChr(s,53),\\\ngetChr(s,54),\\\ngetChr(s,55),\\\ngetChr(s,56),\\\ngetChr(s,57),\\\ngetChr(s,58),\\\ngetChr(s,59),\\\ngetChr(s,60),\\\ngetChr(s,61),\\\ngetChr(s,62),\\\ngetChr(s,63),\\\ngetChr(s,64),\\\ngetChr(s,65),\\\ngetChr(s,66),\\\ngetChr(s,67),\\\ngetChr(s,68),\\\ngetChr(s,69),\\\ngetChr(s,70),\\\ngetChr(s,71),\\\ngetChr(s,72),\\\ngetChr(s,72),\\\ngetChr(s,72),\\\ngetChr(s,73),\\\ngetChr(s,74),\\\ngetChr(s,75),\\\ngetChr(s,76),\\\ngetChr(s,77),\\\ngetChr(s,78),\\\ngetChr(s,79),\\\ngetChr(s,80),\\\ngetChr(s,81),\\\ngetChr(s,82),\\\ngetChr(s,83),\\\ngetChr(s,84),\\\ngetChr(s,85),\\\ngetChr(s,86),\\\ngetChr(s,87),\\\ngetChr(s,88),\\\ngetChr(s,89),\\\ngetChr(s,90),\\\ngetChr(s,91),\\\ngetChr(s,92),\\\ngetChr(s,93),\\\ngetChr(s,94),\\\ngetChr(s,95),\\\ngetChr(s,96),\\\ngetChr(s,97),\\\ngetChr(s,98),\\\ngetChr(s,99),\\\ngetChr(s,100)\n\n#define getChr(name, ii) ((MIN(ii,MAX_CONST_CHAR))&lt;strlen(name)?name[ii]:0)\n\ntemplate &lt;char... Chars_&gt;\n class E {\n\n    public:\n    string *str;\n\n    E(){\n        std::vector&lt;char&gt; vec = {Chars_...};\n        str = new string(vec.begin(),vec.end());\n    }\n\n    ~E()\n     {\n        delete str;\n     }\n };\n\nint main(int argc, char *argv[])\n{\n\n    E&lt;_T(\"Any template can pass const strings literals\")&gt; e;\n\n    printf(\"%s\",e.str-&gt;c_str());\n\n}\n</code></pre>\n<p>This works with g++ 4.6 and passing argument -std=c++0x, and have a limit of 100 char but, of course, can be as greater as you want. Maybe this technique is not well optimized, but it will be more productive than declare the needed external variables (I'm sure ;) )</p>\n<p>Constraints: The literal string must be one and last argument of the template due the passing of variadics arguments.</p>\n</p>", "LastActivityDate": "2017-07-23T20:29:24.823"}, "1826464": {"CreationDate": "2009-12-01T14:18:44.513", "CommentCount": "0", "ViewCount": "44607", "PostTypeId": "1", "ClosedDate": "2017-01-20T06:40:13.037", "LastEditorUserId": "2008463", "LastActivityDate": "2017-07-23T20:29:24.823", "LastEditDate": "2014-02-11T07:25:22.540", "AcceptedAnswerId": "1826505", "FavoriteCount": "9", "Title": "C-Style Strings as template arguments?", "Id": "1826464", "Score": "33", "Body": "<p>Can C-Style strings be used as template arguments?</p>\n<p>I tried:</p>\n<pre><code>template &lt;char *str&gt;\nstruct X\n{\n    const char *GetString() const\n    {\n         return str;\n    }\n};\n\nint main()\n{\n    X&lt;\"String\"&gt; x;\n    cout&lt;&lt;x.GetString();\n}\n</code></pre>\n<p>And although I get no complaints about the class definition, the instantiation yields <code>'X' : invalid expression as a template argument for 'str'</code> (VC).</p>\n", "Tags": "<c++><templates><string>", "OwnerUserId": "219572", "AnswerCount": "9"}, "1826530": {"ParentId": "1826464", "CommentCount": "0", "Body": "<p>No. According to C++ Standard 14.3.2/1:</p>\n<blockquote>\n<p id=\"so_1826464_1826530_0\">A template-argument for a non-type, non-template template-parameter shall be one of:<br>\n  \u2014 an integral constant-expression of integral or enumeration type; or<br>\n  \u2014 the name of a non-type template-parameter; or<br>\n  \u2014 the address of an object or function with external linkage, including function templates and function template-ids but excluding non-static class members, expressed as &amp; id-expression where the &amp; is optional if the name refers to a function or array, or if the corresponding template-parameter is a reference;or<br>\n  \u2014 a pointer to member expressed as described in 5.3.1 .</br></br></br></br></p>\n</blockquote>\n<p>Strings are not in the list.</p>\n", "OwnerUserId": "123111", "PostTypeId": "2", "Id": "1826530", "Score": "2", "CreationDate": "2009-12-01T14:28:43.290", "LastActivityDate": "2009-12-01T14:28:43.290"}, "1826484": {"ParentId": "1826464", "LastEditDate": "2009-12-01T14:53:20.417", "CommentCount": "2", "CreationDate": "2009-12-01T14:22:14.443", "OwnerUserId": "168225", "LastEditorUserId": "168225", "PostTypeId": "2", "Id": "1826484", "Score": "5", "Body": "<p>No, you can't work with string literals at compile time. The best you can get are the weird multicharacter literals (e.g. <code>'abcd'</code>) which some compile-time parsers use. They are mentioned in <em>\u00a72.13.2.1</em>:</p>\n<blockquote>\n<p id=\"so_1826464_1826484_0\">An ordinary character literal that\n  contains more than one c-char is a\n  multicharacter literal. A multicharac-\n  ter literal has type int and\n  implementation-defined value.</p>\n</blockquote>\n<p>In C++0x there might be ways around this limitations though with the <a href=\"http://en.wikipedia.org/wiki/C%2B%2B0x#New_string_literals\" rel=\"nofollow noreferrer\">new string literals</a>, <a href=\"http://arcticinteractive.com/2009/08/15/cpp-compile-time-string-parser-prototype/\" rel=\"nofollow noreferrer\">Arctic Interactive</a> has an interesting article on that.</p>\n", "LastActivityDate": "2009-12-01T14:53:20.417"}, "1826523": {"ParentId": "1826464", "CommentCount": "1", "Body": "<p>C++ does not know about strings. It only knowns about \"arrays of characters\" and there the literal would be the pointer to the array. So if you would use the \"value\" of your string as template parameter you would actually use the pointer value.</p>\n", "OwnerUserId": "222044", "PostTypeId": "2", "Id": "1826523", "Score": "-5", "CreationDate": "2009-12-01T14:27:57.537", "LastActivityDate": "2009-12-01T14:27:57.537"}, "1826510": {"ParentId": "1826464", "CommentCount": "0", "Body": "<p>Take a look at this:</p>\n<p><a href=\"http://www.comeaucomputing.com/techtalk/templates/#stringliteral\" rel=\"noreferrer\">Comeau C++ Template FAQ: How can I pass a \"string literal\" to a template?</a></p>\n", "OwnerUserId": "184968", "PostTypeId": "2", "Id": "1826510", "Score": "16", "CreationDate": "2009-12-01T14:25:30.930", "LastActivityDate": "2009-12-01T14:25:30.930"}, "1826505": {"ParentId": "1826464", "LastEditDate": "2017-05-23T10:30:45.720", "CommentCount": "5", "CreationDate": "2009-12-01T14:24:19.480", "OwnerUserId": "11834", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "1826505", "Score": "35", "Body": "<p><a href=\"http://www.devx.com/tips/Tip/5669\" rel=\"nofollow noreferrer\">A string literal cannot be used as a template argument</a>.</p>\n<p><em>Update: Nowadays, a few years this question was asked and answered, it is possible to use string literals as template arguments. With C++11, we can use characters packs as template arguments (<code>template&lt;char ...c&gt;</code>) and it <a href=\"https://stackoverflow.com/a/15863804/146041\">is possible</a> to pass a literal string to such a template.</em></p>\n<p>This would work, however:</p>\n<pre><code>template &lt;char const *str&gt;\nstruct X\n{\n    const char *GetString() const\n    {\n         return str;\n    }\n};\n\nchar global_string[] = \"String\";\n\nint main()\n{\n    X&lt;global_string&gt; x;\n    cout&lt;&lt;x.GetString();\n}\n</code></pre>\n", "LastActivityDate": "2015-07-13T22:08:27.980"}, "bq_ids": {"n4140": {"so_1826464_1826530_0": {"section_id": 87, "quality": 0.8863636363636364, "length": 39}, "so_1826464_1826484_0": {"section_id": 5343, "quality": 0.7647058823529411, "length": 13}}, "n3337": {"so_1826464_1826530_0": {"section_id": 82, "quality": 0.8636363636363636, "length": 38}, "so_1826464_1826484_0": {"section_id": 5140, "quality": 0.7647058823529411, "length": 13}}, "n4659": {"so_1826464_1826484_0": {"section_id": 6765, "quality": 0.7647058823529411, "length": 13}}}});