post_cb({"13019129": {"ViewCount": "161", "Body": "<p>I read that that virtual destructors must be declared in classes that have virtual methods. I just cant understand why they must be declared virtual. I know why we need to have virtual destructors as from the following example. I just wanted to know why compilers dont manage virtual destructors for us. Is there something I need to know about working of virtual destructors ?\nThe following example shows that if destructors are not declared virtual the destructors of derived class are not called why is that ?</p>\n<pre><code>class Base \n{\n    // some virtual methods\npublic:\n    Base()\n    {std::cout &lt;&lt; \"Base Constructor\\n\";}\n    ~Base()\n    {std::cout &lt;&lt; \"Base De-structor\\n\";}\n\n};\n\nclass Derived : public Base\n{\npublic:\n    Derived()\n    {std::cout &lt;&lt; \"Der constructor\\n\";}\n    ~Derived()\n    { std::cout &lt;&lt; \"Der De-structor\\n\";}\n} ;         \nvoid main()\n{\n\n    Base *b = new Derived();\n    delete b;\n}\n</code></pre>\n", "AcceptedAnswerId": "13019208", "Title": "Why do virtual destructors behave the way they do?", "CreationDate": "2012-10-22T20:16:38.753", "Id": "13019129", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2012-10-22T20:32:17.650", "Score": "3", "OwnerUserId": "884745", "Tags": "<c++>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_13019129_13019364_4": {"length": 5, "quality": 0.625, "section_id": 404}, "so_13019129_13019208_3": {"length": 41, "quality": 0.9534883720930233, "section_id": 6107}}, "n3337": {"so_13019129_13019364_4": {"length": 5, "quality": 0.625, "section_id": 395}, "so_13019129_13019208_3": {"length": 41, "quality": 0.9534883720930233, "section_id": 5873}}, "n4659": {"so_13019129_13019364_4": {"length": 5, "quality": 0.625, "section_id": 422}, "so_13019129_13019208_3": {"length": 41, "quality": 0.9534883720930233, "section_id": 7604}}}, "13019208": {"Id": "13019208", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_13019129_13019208_0\">I just wanted to know why compilers dont manage virtual destructors for us.</p>\n</blockquote>\n<p>Because in C++, you pay for what you use. Having a <code>virtual</code> destructor by default involves the compiler adding a virtual table pointer to the class, which increases its size. This is not always desirable. </p>\n<blockquote>\n<p id=\"so_13019129_13019208_1\">The following example shows that if destructors are not declared virtual the destructors of derived class are not called why is that ?</p>\n</blockquote>\n<p>The example exibits <strong>undefined behavior</strong>. It's simply against the rules. The fact that not all destructors are called is just one possible manifestation. It could possibly crash.</p>\n<blockquote>\n<p id=\"so_13019129_13019208_2\">Is there something I need to know about working of virtual destructors ?</p>\n</blockquote>\n<p>Yes. They are required if you're deleting an object through a pointer to a base class. Otherwise it's undefined behavior.</p>\n<h3>5.3.5 Delete [expr.delete]</h3>\n<blockquote>\n<p id=\"so_13019129_13019208_3\">3) In the first alternative (delete object), <strong>if the static type of the object to be deleted is different from its\n  dynamic type</strong>, the static type shall be a base class of the dynamic type of the object to be deleted and <strong>the\n  static type shall have a virtual destructor or the behavior is undefined</strong>. In the second alternative (delete\n  array) if the dynamic type of the object to be deleted differs from its static type, the behavior is undefined. (emphasis mine)</p>\n</blockquote>\n", "LastEditorUserId": "673730", "LastActivityDate": "2012-10-22T20:32:00.967", "Score": "4", "CreationDate": "2012-10-22T20:21:19.433", "ParentId": "13019129", "CommentCount": "5", "OwnerUserId": "673730", "LastEditDate": "2012-10-22T20:32:00.967"}, "13019364": {"Id": "13019364", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_13019129_13019364_0\">I read that that virtual destructors must be declared in classes that have virtual methods.</p>\n</blockquote>\n<p>Yes. But that is an oversimplification.<br>\nIts not that a class with virtual methods needs a virtual destructor. But the way a class with virtual methods is used means that it will usually need a virtual destructor. A virtual destructor is <strong>ONLY</strong> needed if you delete an object via a pointer to its base class. The problem is that when an object has virtually methods you are usually working with a pointer to its base class even though the actual object is slightly different.</br></p>\n<blockquote>\n<p id=\"so_13019129_13019364_1\">I just cant understand why they must be declared virtual.</p>\n</blockquote>\n<p>It's not that they must. As explained above. This is a result of the usual usage patterns.</p>\n<blockquote>\n<p id=\"so_13019129_13019364_2\">I just wanted to know why compilers dont manage virtual destructors for us.</p>\n</blockquote>\n<p>Because it is not always needed. And the ethos of C++ is you don't have to pay for something you don't need it. If the compiler always added virtual destructors to a class with virtual methods then I would have to pay the price of using a virtual destructor even in situations I can prove in my code base that I don't need it.</p>\n<blockquote>\n<p id=\"so_13019129_13019364_3\">Is there something I need to know about working of virtual destructors ? </p>\n</blockquote>\n<p>Just that there is a slight cost to using them.</p>\n<blockquote>\n<p id=\"so_13019129_13019364_4\">if destructors are not declared virtual the destructors of derived class are not called why is that ?</p>\n</blockquote>\n<p>That is why we have virtual destructors to cause this behavior. If you need this behavior you need to add virtual destructors. But there are cases were virtual destructors may not be required which allows the user of this method not to pay the price.</p>\n", "LastActivityDate": "2012-10-22T20:32:17.650", "CommentCount": "0", "CreationDate": "2012-10-22T20:32:17.650", "ParentId": "13019129", "Score": "3", "OwnerUserId": "14065"}, "13019324": {"Id": "13019324", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_13019129_13019324_0\">I read that that virtual destructors must be declared in classes that have virtual methods.</p>\n</blockquote>\n<p>\"must\" is too strong a word: \"should\" fits much better into that advise.</p>\n<blockquote>\n<p id=\"so_13019129_13019324_1\">I just wanted to know why compilers dont manage virtual destructors for us.</p>\n</blockquote>\n<p>C++ designers tried to avoid compiler doing things that you did not ask it to do only under the most extreme circumstances. Language designers recognized that the decision to make a class polymorphic should rest with the designer of the program, so they refused to re-assign this responsibility to the compiler.</p>\n<blockquote>\n<p id=\"so_13019129_13019324_2\">The following example shows that if destructors are not declared virtual the destructors of derived class are not called why is that?</p>\n</blockquote>\n<p>Because your code is invalid: by declaring the destructor of <code>Derived</code> non-virtual you made a promise to never destroy <code>Derived</code> through a pointer to <code>Base</code>; your <code>main</code> breaks this promise, invoking undefined behavior.</p>\n<p>Note that by merely declaring your <code>b</code> variable with the exact type you would have avoided the problem associated with the non-virtual destructor (<a href=\"http://ideone.com/dkR1cN\" rel=\"nofollow\">link to ideone</a>). However, this leads to a rather shaky design, so you should avoid inheritance hierarchies with virtual functions and non-virtual destructors.</p>\n", "LastActivityDate": "2012-10-22T20:29:26.000", "CommentCount": "1", "CreationDate": "2012-10-22T20:29:26.000", "ParentId": "13019129", "Score": "3", "OwnerUserId": "335858"}});