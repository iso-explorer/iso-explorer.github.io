post_cb({"bq_ids": {"n4140": {"so_16467802_16467846_0": {"length": 58, "quality": 0.9206349206349206, "section_id": 5908}}, "n3337": {"so_16467802_16467846_0": {"length": 58, "quality": 0.9206349206349206, "section_id": 5680}}}, "16467802": {"CreationDate": "2013-05-09T17:40:59.493", "ViewCount": "176", "Id": "16467802", "AcceptedAnswerId": "16467846", "Score": "1", "Title": "Undefined reference with g++4.7.3 and g++4.8?", "LastEditorUserId": "882932", "CommentCount": "0", "Body": "<p>Consider this code :</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\ntemplate &lt;typename Type&gt;\nstruct Constant\n{\n    constexpr Constant(const Type source) : _data({{source}}) {;}\n    constexpr Constant(const std::array&lt;Type, 1&gt; source) : _data(source) {;}\n    constexpr Constant&lt;Type&gt; operator()() const {return _data;}\n    constexpr operator Type() const {return _data[0];}\n    const std::array&lt;Type, 1&gt; _data;\n    static constexpr Constant&lt;Type&gt; pi = 3.1415926535897932384626433832795028841971693993751058209749445L;\n};\n\nint main(int argc, char* argv[])\n{\n    std::cout&lt;&lt;Constant&lt;double&gt;::pi()&lt;&lt;std::endl;\n    return 0;\n}\n</code></pre>\n<p>I get a compiler error with <code>g++4.7.3</code> and <code>g++4.8.0</code> (which is an undefined reference to <code>pi</code> (sorry it's in French)) :</p>\n<pre><code>/tmp/cctdvPfq.o: dans la fonction \u00ab main \u00bb:\nmain.cpp:(.text.startup+0xd): r\u00e9f\u00e9rence ind\u00e9finie vers \u00ab Constant&lt;double&gt;::pi \u00bb\ncollect2: erreur: ld a retourn\u00e9 1 code d'\u00e9tat d'ex\u00e9cution\n</code></pre>\n<p>As my system is a fresh install (first time with <code>g++4.7.3</code> and <code>g++4.8.0</code>), I do not know whether it comes from my system configuration or from the compiler. If it comes from the compiler, where is the problem ?</p>\n<p>EDIT: and why this is working ? (version with no array)</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\ntemplate &lt;typename Type&gt;\nstruct Constant\n{\n    constexpr Constant(const Type source) : _data(source) {;}\n    constexpr Constant&lt;Type&gt; operator()() const {return _data;}\n    constexpr operator Type() const {return _data;}\n    const Type _data;\n    static constexpr Constant&lt;Type&gt; pi = 3.1415926535897932384626433832795028841971693993751058209749445L;\n};\n\nint main(int argc, char* argv[])\n{\n    std::cout&lt;&lt;Constant&lt;double&gt;::pi()&lt;&lt;std::endl;\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><c++11><compiler-errors><g++><undefined-reference>", "LastEditDate": "2013-05-09T17:51:01.610", "LastActivityDate": "2013-05-09T18:42:46.583", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "882932"}, "16467846": {"CreationDate": "2013-05-09T17:43:31.420", "CommentCount": "10", "Body": "<p>You could avoid invoking the call operator on <code>pi</code>, so that it is not <strong>odr-used</strong> by your program, and the compiler can treat <code>pi</code> just like a value that can be inlined, thus not requiring a <em>definition</em> for that <code>static</code> data member:</p>\n<pre><code>std::cout &lt;&lt; Constant&lt;double&gt;::pi &lt;&lt; std::endl;\n//                             ^^\n</code></pre>\n<p>Alternatively, you could keep invoking <code>pi</code>'s call operator, and provide a <em>definition</em> of your static data member at namespace scope, and use the call operator of <code>Constant&lt;double&gt;</code> as in your original code:</p>\n<pre><code>template &lt;typename Type&gt;\nstruct Constant\n{\n    // ...\n    static constexpr Constant&lt;Type&gt; pi = /* ... */;\n};\n\ntemplate&lt;typename Type&gt;\nconstexpr Constant&lt;Type&gt; Constant&lt;Type&gt;::pi;\n</code></pre>\n<p>Per paragraph 9.4.2/3 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16467802_16467846_0\">If a non-volatile <code>const</code> static data member is of integral or enumeration type, its declaration in the class\n  definition can specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em>\n  is a constant expression (5.19). A static data member of literal type can be declared in the\n  class definition with the <code>constexpr</code> specifier; if so, its declaration shall specify a <em>brace-or-equal-initializer</em>\n  in which every <em>initializer-clause</em> that is an assignment-expression is a constant expression. [ Note: In both\n  these cases, the member may appear in constant expressions. \u2014end note ] <strong>The member shall still be defined\n  in a namespace scope if it is odr-used (3.2) in the program and the namespace scope definition shall not\n  contain an initializer</strong>.</p>\n</blockquote>\n", "Id": "16467846", "OwnerUserId": "1932150", "LastEditDate": "2013-05-09T17:57:17.317", "ParentId": "16467802", "LastActivityDate": "2013-05-09T17:57:17.317", "PostTypeId": "2", "Score": "6", "LastEditorUserId": "1932150"}});