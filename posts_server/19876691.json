post_cb({"19876691": {"CommentCount": "0", "ViewCount": "221", "PostTypeId": "1", "LastEditorUserId": "41661", "CreationDate": "2013-11-09T13:46:48.500", "LastActivityDate": "2016-02-18T23:46:17.537", "LastEditDate": "2016-02-18T23:46:17.537", "AcceptedAnswerId": "19877048", "FavoriteCount": "2", "Title": "Metafunction to compute x^n and return the integer limit without overflow if not possible?", "Id": "19876691", "Score": "7", "Body": "<p>Consider the following code:</p>\n<pre><code>template &lt;std::intmax_t Base, std::intmax_t Exponent&gt; \nstruct integer_power_bounded\n{\n    static_assert(Exponent &gt;= 0, \n                  \"Error in 'integer_power_bounded': 'Exponent &gt;= 0' is false\");\n    static constexpr std::intmax_t value = /* something */;\n};\n\ntemplate &lt;std::intmax_t Base&gt; \nstruct integer_power_bounded&lt;Base, 0&gt;\n{\n    static constexpr std::intmax_t value = 1;\n};\n</code></pre>\n<p>Instead of <code>/* something */</code>, I would like to return <code>std::numeric_limits&lt;std::intmax_t&gt;::min()</code> or <code>std::numeric_limits&lt;std::intmax_t&gt;::max()</code> if <code>Base^Exponent</code> cannot be represented by a <code>std::intmax_t</code>. The difficult thing is to avoid overflows during computation because they create errors at compilation. </p>\n<p>How to do that (without boost) ?</p>\n", "Tags": "<c++><c++11><metaprogramming><template-meta-programming><integer-overflow>", "OwnerUserId": "882932", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_19876691_19877048_0": {"section_id": 6185, "quality": 0.8095238095238095, "length": 17}}, "n4659": {"so_19876691_19877048_0": {"section_id": 7687, "quality": 0.8095238095238095, "length": 17}}}, "19877048": {"ParentId": "19876691", "LastEditDate": "2013-11-09T15:33:18.620", "CommentCount": "4", "CreationDate": "2013-11-09T14:22:46.033", "Score": "18", "LastEditorUserId": "420683", "PostTypeId": "2", "Id": "19877048", "OwnerUserId": "420683", "Body": "<p>A version based on SFINAE:</p>\n<pre><code>#include &lt;cstdint&gt;\n#include &lt;cmath&gt;\n#include &lt;limits&gt;\n#include &lt;type_traits&gt;\n\nconstexpr std::intmax_t integer_power(std::intmax_t base,\n                                      std::intmax_t exponent)\n{\n    return (exponent == 0) ? 1 :\n           (exponent % 2 == 0) ?  integer_power(base, exponent/2)\n                                 *integer_power(base, exponent/2) :\n           base*integer_power(base, exponent-1);\n}\n\nnamespace detail\n{\n    template&lt;std::intmax_t base, std::intmax_t exponent,\n             std::intmax_t res = integer_power(base,exponent)&gt;\n    constexpr std::intmax_t pow_helper(int)\n    {\n        return res;\n    }\n\n    template&lt;std::intmax_t base, std::intmax_t exponent&gt;\n    constexpr std::intmax_t pow_helper(...)\n    {\n        return (exponent%2 == 0 || base &gt; 0)\n               ? std::numeric_limits&lt;std::intmax_t&gt;::max()\n               : std::numeric_limits&lt;std::intmax_t&gt;::min();\n    }\n}\n\ntemplate&lt;std::intmax_t base, std::intmax_t exponent&gt;\nconstexpr std::intmax_t integer_power_bounded()\n{\n    return detail::pow_helper&lt;base,exponent&gt;(0);\n}\n</code></pre>\n<p>Usage example:</p>\n<pre><code>#include &lt;iostream&gt;\nint main()\n{\n    std::cout &lt;&lt; sizeof(std::intmax_t) &lt;&lt; '\\n';\n\n    constexpr auto p2t6 = integer_power_bounded&lt;2, 6&gt;();\n    constexpr auto p2t62 = integer_power_bounded&lt;2, 62&gt;();\n    constexpr auto p2t63 = integer_power_bounded&lt;2, 63&gt;();\n    constexpr auto p2t64 = integer_power_bounded&lt;2, 64&gt;();\n    constexpr auto p2t65 = integer_power_bounded&lt;2, 65&gt;();\n\n    std::cout &lt;&lt; \"2^6 == \" &lt;&lt; p2t6 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"2^62 == \" &lt;&lt; p2t62 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"2^63 == \" &lt;&lt; p2t63 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"2^64 == \" &lt;&lt; p2t64 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"2^65 == \" &lt;&lt; p2t65 &lt;&lt; '\\n';\n\n    constexpr auto pm2t6 = integer_power_bounded&lt;-2, 6&gt;();\n    constexpr auto pm2t62 = integer_power_bounded&lt;-2, 62&gt;();\n    constexpr auto pm2t63 = integer_power_bounded&lt;-2, 63&gt;();\n    constexpr auto pm2t64 = integer_power_bounded&lt;-2, 64&gt;();\n    constexpr auto pm2t65 = integer_power_bounded&lt;-2, 65&gt;();\n\n    std::cout &lt;&lt; \"-2^6 == \" &lt;&lt; pm2t6 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"-2^62 == \" &lt;&lt; pm2t62 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"-2^63 == \" &lt;&lt; pm2t63 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"-2^64 == \" &lt;&lt; pm2t64 &lt;&lt; '\\n';\n    std::cout &lt;&lt; \"-2^65 == \" &lt;&lt; pm2t65 &lt;&lt; '\\n';\n}\n</code></pre>\n<p>Output:</p>\n<pre>\n8\n2^6 == 64\n2^62 == 4611686018427387904\n2^63 == 9223372036854775807\n2^64 == 9223372036854775807\n2^65 == 9223372036854775807\n-2^6 == 64\n-2^62 == 4611686018427387904\n-2^63 == -9223372036854775808\n-2^64 == 9223372036854775807\n-2^65 == -9223372036854775808</pre>\n<hr>\n<p>Explanation:</p>\n<p>A constant expression may not contain Undefined Behaviour [expr.const]/2:</p>\n<blockquote id=\"so_19876691_19877048_0\">\n<ul>\n<li>an operation that would have undefined behavior [<em>Note:</em> including, for example, signed integer overflow, certain pointer arithmetic, division by zero, or certain shift operations\n  \u2014 <em>end note</em>];</li>\n</ul>\n</blockquote>\n<p>Therefore, whenever the <em>unbounded</em> <code>integer_power</code> produces an overflow, the expression used to declare the <code>std::integral_constant</code> is no valid constant expression; substitution fails and the fall-back function is used.</p>\n</hr>", "LastActivityDate": "2013-11-09T15:33:18.620"}});