post_cb({"bq_ids": {"n4140": {"so_46700013_46700128_0": {"length": 17, "quality": 1.0, "section_id": 3919}, "so_46700013_46700162_0": {"length": 32, "quality": 0.8648648648648649, "section_id": 3919}}, "n3337": {"so_46700013_46700128_0": {"length": 17, "quality": 1.0, "section_id": 3779}, "so_46700013_46700162_0": {"length": 32, "quality": 0.8648648648648649, "section_id": 3779}}, "n4659": {"so_46700013_46700128_0": {"length": 17, "quality": 1.0, "section_id": 4805}, "so_46700013_46700162_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 4805}}}, "46700128": {"Id": "46700128", "PostTypeId": "2", "Body": "<p>Narrowing in on the problem:</p>\n<pre><code>inline B&amp; B::GetInstance()\n{\n   static B b;\n   return b;\n}\n\ninline B::B()\n: A(B::GetInstance(), 0)\n{ \n}\n</code></pre>\n<p>The line <code>static B b;</code> creates a <code>B</code> object the first time the function is called. However, the construction of <code>b</code> then calls <code>GetInstance</code>, which reaches the line <code>static B b;</code> while <code>b</code> is still under construction.</p>\n<p>This case is covered by C++14 [stmt.dcl]/4:</p>\n<blockquote>\n<p id=\"so_46700013_46700128_0\">[...]  such a variable is considered initialized upon the completion of its initialization. [...] If control re-enters the declaration recursively while the variable is being initialized, <strong>the behavior is undefined</strong>.</p>\n</blockquote>\n<p>I excised a part talking about what happens if an exception is thrown, or if two differently threads concurrently try to initialize the static variable. The standard does permit local static variables to be initialized prior to the first call of the function, but even if the implementation did that, the same problem would arise of control re-entering the declaration recursively.</p>\n<hr>\n<p>Being undefined behaviour, anything can happen. One possible result is it appearing to work as intended. The standard does not require this to be diagnosed at compile-time -- a difficult thing to analyze.  As indicated in comments, one version of gcc detects this at runtime and throws an exception. Perhaps your original compiler implements local statics by having a flag to indicate whether execution has reached that line yet, and it sets the flag before calling the constructor.  </p>\n<p>The rationale for having undefined behaviour in the standard is to avoid placing constraints on the way an implementation implements the well-defined behaviour (in this case, the method of ensuring local statics are only initialized once).  </p>\n<p>Of course, you should find a way to fix the problem as the undefined behaviour may manifest itself differently in future in ways that are hard to predict.</p>\n</hr>", "LastEditorUserId": "1505939", "LastActivityDate": "2017-10-12T01:52:48.927", "Score": "2", "CreationDate": "2017-10-12T01:46:16.743", "ParentId": "46700013", "CommentCount": "0", "LastEditDate": "2017-10-12T01:52:48.927", "OwnerUserId": "1505939"}, "46700013": {"ViewCount": "59", "Body": "<p>A while ago I wrote some code with a set of nested classes. Looking over it today I'm wondering why it compiles when I instantiate an object of type C.</p>\n<p>My confusion is this. B has a private constructor. The implementation of this constructor takes care of the construction of A, but the construction of A requires an instance of B. I feel like it's a chicken and the egg scenario. The construction of B requires the construction of A which requires the construction of B etc etc ad infinitum.</p>\n<p>I have the following classes - stripped right back to demo the issue:</p>\n<pre><code>// ******* A ******** //\nclass A {\npublic:\n   A(A&amp; _Parent, int id);\nprivate:\n   A&amp; Parent;\n};\n\ninline A::A(A&amp; _Parent, int id)\n: Parent(_Parent)\n{\n}\n\n\n// ******* B ******** //\nclass B:public A {\npublic:\n   static B&amp; GetInstance();\nprivate:\n   B();\n};\n\ninline B::B()\n: A(B::GetInstance(), 0)\n{\n}\n\ninline B&amp; B::GetInstance()\n{\n   static B b;\n   return b;\n}\n\n\n// ******* C ******** //\nclass C:public A {\npublic:\n   C();\n};\n\ninline C::C()\n: A(B::GetInstance(), 0)\n{\n}   \n</code></pre>\n", "AcceptedAnswerId": "46700128", "Title": "Why does this code compile without complaining about constructors?", "CreationDate": "2017-10-12T01:31:47.347", "Id": "46700013", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-10-12T01:52:48.927", "Score": "2", "OwnerUserId": "4200424", "Tags": "<c++>", "AnswerCount": "2"}, "46700162": {"Id": "46700162", "PostTypeId": "2", "Body": "<p>Although you didn't show any such code, let's assume something attempts to call the default constructor of <code>C</code> or in some other way calls <code>B::GetInstance()</code>.</p>\n<p>The first statement in <code>GetInstance()</code> is <code>static B b;</code>.  Since this is the first time we've arrived here, the object <code>b</code> needs to be initialized by calling the default constructor <code>B::B()</code>.</p>\n<p>The first thing <code>B::B()</code> does is call <code>GetInstance()</code>, intending to then pass the result of that to the <code>A::A(A&amp;, int)</code> constructor.</p>\n<p>Which puts us back again at the statement <code>static B b;</code>.  And the C++ Standard says ([stmt.dcl]/4):</p>\n<blockquote>\n<p id=\"so_46700013_46700162_0\">Dynamic initialization of a block-scope variable with static storage duration ([basic.stc.static]) or thread storage duration ([basic.stc.thread]) is performed the first time control passes through its declaration; such a variable is considered initialized upon the completion of its initialization.... If control enters the declaration recursively while the variable is being initialized, the behavior is undefined.</p>\n</blockquote>\n<p>Undefined behavior means anything could happen. It might appear to work, it might crash or hang your program, or it might initialize incorrectly and continue.</p>\n", "LastActivityDate": "2017-10-12T01:51:20.263", "Score": "1", "CreationDate": "2017-10-12T01:51:20.263", "ParentId": "46700013", "CommentCount": "0", "OwnerUserId": "459640"}});