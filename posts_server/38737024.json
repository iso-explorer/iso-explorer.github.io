post_cb({"38737630": {"Id": "38737630", "PostTypeId": "2", "Body": "<p>The first thing to realize is that binary operators like <code>a&amp;b</code> for built-in types only work if both sides have the same type. (With user-defined types and overloads, anything goes). This might be realized via implicit conversions. </p>\n<p>Now, in your case, there definitely is such a conversion, because there simply isn't a binary operator <code>&amp;</code> that takes a type smaller than <code>int</code>. Both sides are converted to at least <code>int</code> size, but what exact types?</p>\n<p>As it happens, on your GCC <code>int</code> is indeed 32 bits. This is important, because it means that all values of <code>uint16_t</code> can be represented as an <code>int</code>. There is no overflow.</p>\n<p>Hence, <code>check &amp; 0xFFFF</code> is a simple case. The right side is already an <code>int</code>, the left side promotes to <code>int</code>, so the result is <code>int(0x8123)</code>. This is perfectly fine.</p>\n<p>Now, the next operation is <code>0x8123 &lt;&lt; 16</code>. Remember, on your system <code>int</code> is 32 bits, and <code>INT_MAX</code> is <code>0x7FFF'FFFF</code>. In the absence of overflow, <code>0x8123 &lt;&lt; 16</code> would be <code>0x81230000</code>, but that clearly is bigger than <code>INT_MAX</code> so there is in fact overflow.</p>\n<p><a href=\"https://stackoverflow.com/a/7401975/15416\">Signed integer overflow in C++11 is Undefined Behavior</a>. Literally any outcome is correct, including <code>purple</code> or no output at all. At least you got a numerical value, but GCC is known to outright eliminate code paths which unavoidably cause overflow.</p>\n<p>[edit]\nNewer GCC versions support C++14, where <em>this particular form of overflow</em> has become implementation-defined - see Serge's answer.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-08-03T08:35:57.380", "Score": "10", "CreationDate": "2016-08-03T07:55:35.477", "ParentId": "38737024", "CommentCount": "3", "OwnerUserId": "15416", "LastEditDate": "2017-05-23T12:24:45.347"}, "38737096": {"Id": "38737096", "PostTypeId": "2", "Body": "<p>This is the result of integer promotion. Before the <code>&amp;</code> operation happens, if the operands are \"smaller\" than an <code>int</code> (for that architecture), compiler will promote both operands to <code>int</code>, because they both fit into a <code>signed int</code>:</p>\n<p>This means that the first expression will be equivalent to (on a 32-bit architecture):</p>\n<pre><code>// check is uint16_t, but it fits into int32_t.\n// the constant is signed, so it's sign-extended into an int\n((int32_t)check &amp; (int32_t)0xFFFFFFFF)\n</code></pre>\n<p>while the other one will have the second operand promoted to:</p>\n<pre><code>// check is uint16_t, but it fits into int32_t.\n// the constant is unsigned, so the upper 16 bits are zero\n((int32_t)check &amp; (int32_t)0x0000FFFFU)\n</code></pre>\n<p>If you explicitly cast <code>check</code> to an <code>unsigned int</code>, then the result will be the same in both cases (<code>unsigned * signed</code> will result in <code>unsigned</code>):</p>\n<pre><code>((uint32_t)check &amp; 0xFFFF) &lt;&lt; 16\n</code></pre>\n<p>will be equal to:</p>\n<pre><code>((uint32_t)check &amp; 0xFFFFU) &lt;&lt; 16\n</code></pre>\n", "LastEditorUserId": "69809", "LastActivityDate": "2016-08-03T07:59:19.690", "Score": "1", "CreationDate": "2016-08-03T07:29:10.770", "ParentId": "38737024", "CommentCount": "2", "OwnerUserId": "69809", "LastEditDate": "2016-08-03T07:59:19.690"}, "38738113": {"Id": "38738113", "PostTypeId": "2", "Body": "<p>Your platform has 32-bit <code>int</code>.</p>\n<p>Your code is exactly equivalent to</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdint&gt;\n\nint main()\n{\n    uint16_t check = 0x8123U;\n    auto a1 = (check &amp; 0xFFFF) &lt;&lt; 16\n    uint64_t new_check = a1;\n    std::cout &lt;&lt; std::hex &lt;&lt; new_check &lt;&lt; std::endl;\n\n    auto a2 = (check &amp; 0xFFFFU) &lt;&lt; 16;\n    new_check = a2;\n    std::cout &lt;&lt; std::hex &lt;&lt; new_check &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>What's the type of <code>a1</code> and <code>a2</code>?</p>\n<ul>\n<li>For <code>a2</code>, the result is promoted to <code>unsigned int</code>.</li>\n<li>More interestingly, for <code>a1</code> the result is promoted to <code>int</code>, and then it gets sign-extended as it's widened to <code>uint64_t</code>.</li>\n</ul>\n<p>Here's a shorter demonstration, in decimal so that the difference between signed and unsigned types is apparent:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdint&gt;\n\nint main()\n{\n    uint16_t check = 0;\n    std::cout &lt;&lt; check\n              &lt;&lt; \"  \" &lt;&lt; (int)(check + 0x80000000)\n              &lt;&lt; \"  \" &lt;&lt; (uint64_t)(int)(check + 0x80000000) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>On my system (also 32-bit <code>int</code>), I get</p>\n<pre><code>0  -2147483648  18446744071562067968\n</code></pre>\n<p>showing where the promotion and sign-extension happens. </p>\n", "LastActivityDate": "2016-08-03T08:16:38.570", "CommentCount": "1", "CreationDate": "2016-08-03T08:16:38.570", "ParentId": "38737024", "Score": "1", "OwnerUserId": "4850040"}, "38737577": {"Id": "38737577", "PostTypeId": "2", "Body": "<p>The &amp; operation has two operands. The first is an unsigned short, which will undergo the usual promotions to become an int. The second is a constant, in one case of type int, in the other case of type unsigned int. The result of the &amp; is therefore int in one case, unsigned int in the other case. That value is shifted to the left, resulting either in an int with the sign bit set, or an unsigned int. Casting a negative int to uint64_t will give a large negative integer. </p>\n<p>Of course you should always follow the rule: If you do something, and you don't understand the result, then don't do that!</p>\n", "LastActivityDate": "2016-08-03T07:52:39.987", "CommentCount": "0", "CreationDate": "2016-08-03T07:52:39.987", "ParentId": "38737024", "Score": "0", "OwnerUserId": "3255455"}, "bq_ids": {"n4140": {"so_38737024_38738152_2": {"length": 11, "quality": 0.7333333333333333, "section_id": 32}, "so_38737024_38738152_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 6147}, "so_38737024_38738152_0": {"length": 65, "quality": 0.9558823529411765, "section_id": 5943}, "so_38737024_38738152_1": {"length": 17, "quality": 0.8095238095238095, "section_id": 6147}, "so_38737024_38738152_3": {"length": 18, "quality": 0.8571428571428571, "section_id": 31}}, "n3337": {"so_38737024_38738152_2": {"length": 11, "quality": 0.7333333333333333, "section_id": 29}, "so_38737024_38738152_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 5910}, "so_38737024_38738152_0": {"length": 65, "quality": 0.9558823529411765, "section_id": 5714}, "so_38737024_38738152_3": {"length": 18, "quality": 0.8571428571428571, "section_id": 28}}, "n4659": {"so_38737024_38738152_2": {"length": 11, "quality": 0.7333333333333333, "section_id": 32}, "so_38737024_38738152_4": {"length": 14, "quality": 0.9333333333333333, "section_id": 7643}, "so_38737024_38738152_0": {"length": 65, "quality": 0.9558823529411765, "section_id": 7428}, "so_38737024_38738152_1": {"length": 17, "quality": 0.8095238095238095, "section_id": 7643}, "so_38737024_38738152_3": {"length": 18, "quality": 0.8571428571428571, "section_id": 31}}}, "38738152": {"Id": "38738152", "PostTypeId": "2", "Body": "<p>That's indeed an interesting corner case. It only occurs here because you use <code>uint16_t</code> for the unsigned type when you architecture use 32 bits for <code>\u00ecnt</code></p>\n<p>Here is a extract from <em>Clause 5 Expressions</em> from draft n4296 for C++14 (emphasize mine):</p>\n<blockquote>\n<p id=\"so_38737024_38738152_0\">10 Many binary operators that expect operands of arithmetic or enumeration type cause conversions ...\n  This pattern is called the usual arithmetic conversions, which are defined as follows:\n  <br/> ...<br>(10.5.3) \u2014 Otherwise, if the operand that has <strong>unsigned integer type has rank greater than or equal to the\n  rank of the type of the other operand</strong>, the operand with signed integer type shall be converted to\n  the type of the operand with unsigned integer type.<br/>\n  (10.5.4) \u2014 Otherwise, if the type of the operand with <strong>signed integer type can represent all of the values of\n  the type of the operand with unsigned integer type</strong>, the operand with unsigned integer type shall\n  be converted to the type of the operand with signed integer type.</br></p>\n</blockquote>\n<p>You are in the 10.5.4 case:</p>\n<ul>\n<li><code>uint16_t</code> is only 16 bits while <code>int</code> is 32</li>\n<li><code>int</code> can represent all the values of <code>uint16_t</code></li>\n</ul>\n<p>So the <code>uint16_t check = 0x8123U</code> operand is converted to the signed <code>0x8123</code> and result of the bitwise <code>&amp;</code> is still 0x8123.</p>\n<p>But the shift (bitwise so it happens at the representation level) causes the result to be the intermediate unsigned 0x81230000 which converted to an int gives a negative value (technically it is implementation defined, but this conversion is a common usage)</p>\n<blockquote>\n<p id=\"so_38737024_38738152_1\">5.8 Shift operators [expr.shift]<br/>...<br/>Otherwise, if E1 has a signed type and non-negative value, and E1\u00d72<sup>E2</sup> is <strong>representable\n  in the corresponding unsigned type</strong> of the result type, then that value, converted to the result type, is the\n  resulting value;...</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_38737024_38738152_2\">4.7 Integral conversions [conv.integral]<br/>...<br/>\n  3 If the destination type is signed, the value is unchanged if it can be represented in the destination type;\n  otherwise, the value is <strong>implementation-defined</strong>.</p>\n</blockquote>\n<p>(beware this was true undefined behaviour in C++11...)</p>\n<p>So you end with a conversion of the signed int 0x81230000 to an <code>uint64_t</code> which as expected gives 0xFFFFFFFF81230000, because</p>\n<blockquote>\n<p id=\"so_38737024_38738152_3\">4.7 Integral conversions [conv.integral]<br/>...<br/>\n  2 If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source\n  integer (modulo 2n where n is the number of bits used to represent the unsigned type).</p>\n</blockquote>\n<p>TL/DR: There is no undefined behaviour here, what causes the result is the conversion of signed 32 bits int to unsigned 64 bits int. The only part part that is <em>undefined behaviour</em> is a shift that would cause a sign overflow but all common implementations share this one and it is <em>implementation defined</em> in C++14 standard.</p>\n<p>Of course, if you force the second operand to be unsigned everything is unsigned and you get evidently the correct <code>0x81230000</code> result.</p>\n<p>[EDIT] As explained by MSalters, the result of the shift is only <em>implementation defined</em> since C++14, but was indeed <em>undefined behaviour</em> in C++11. The shift operator paragraph said:</p>\n<blockquote>\n<p id=\"so_38737024_38738152_4\">...<br/>Otherwise, if E1 has a signed type and non-negative value, and E1\u00d72<sup>E2</sup> is <strong>representable\n  in the result type</strong>, then that is the resulting value; <strong>otherwise, the behavior is undefined</strong>.</p>\n</blockquote>\n", "LastEditorUserId": "3545273", "LastActivityDate": "2016-08-03T08:48:13.770", "Score": "20", "CreationDate": "2016-08-03T08:18:51.310", "ParentId": "38737024", "CommentCount": "5", "OwnerUserId": "3545273", "LastEditDate": "2016-08-03T08:48:13.770"}, "38737550": {"Id": "38737550", "PostTypeId": "2", "Body": "<p><code>0xFFFF</code> is a signed int. So after the <code>&amp;</code> operation, we have a 32-bit signed value:</p>\n<pre><code>#include &lt;stdint.h&gt;\n#include &lt;type_traits&gt;\n\nuint64_t foo(uint16_t a) {\n  auto x = (a &amp; 0xFFFF);\n  static_assert(std::is_same&lt;int32_t, decltype(x)&gt;::value, \"not an int32_t\")\n  static_assert(std::is_same&lt;uint16_t, decltype(x)&gt;::value, \"not a uint16_t\");\n  return x;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/tEQmbP\" rel=\"nofollow\">http://ideone.com/tEQmbP</a></p>\n<p>Your original 16 bits are then left-shifted which results in 32-bit value with the high-bit set (0x80000000U) so it has a negative value. During the 64-bit conversion sign-extension occurs, populating the upper words with 1s.</p>\n", "LastActivityDate": "2016-08-03T07:51:25.360", "CommentCount": "0", "CreationDate": "2016-08-03T07:51:25.360", "ParentId": "38737024", "Score": "2", "OwnerUserId": "257645"}, "38737253": {"Id": "38737253", "PostTypeId": "2", "Body": "<p>Let's take a look at</p>\n<pre><code>uint64_t new_check = (check &amp; 0xFFFF) &lt;&lt; 16;\n</code></pre>\n<p>Here, <code>0xFFFF</code> is a signed constant, so <code>(check &amp; 0xFFFF)</code> gives us a signed integer by the rules of integer promotion. </p>\n<p>In your case, with 32-bit <code>int</code> type, the MSbit for this integer after the left shift is 1, and so the extension to 64-bit unsigned will do a sign extension, filling the bits to the left with 1's. Interpreted as a two's complement representation that gives the same negative value.</p>\n<p>In the second case, <code>0xFFFFU</code> is unsigned, so we get unsigned integers and the left shift operator works as expected.</p>\n<p>If your toolchain supports <code>__PRETTY_FUNCTION__</code>, a most-handy feature, you can quickly determine how the compiler perceives expression types:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdint&gt;\n\ntemplate&lt;typename T&gt;\nvoid typecheck(T const&amp; t)\n{\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; '\\n';\n    std::cout &lt;&lt; t &lt;&lt; '\\n';\n}\nint main()\n{\n    uint16_t check = 0x8123U;\n\n    typecheck(0xFFFF);\n    typecheck(check &amp; 0xFFFF);\n    typecheck((check &amp; 0xFFFF) &lt;&lt; 16);\n\n    typecheck(0xFFFFU);\n    typecheck(check &amp; 0xFFFFU);\n    typecheck((check &amp; 0xFFFFU) &lt;&lt; 16);\n\n    return 0;\n}\n</code></pre>\n<h3>Output</h3>\n<pre class=\"lang-none prettyprint-override\"><code>void typecheck(const T &amp;) [T = int]\n65535\nvoid typecheck(const T &amp;) [T = int]\n33059\nvoid typecheck(const T &amp;) [T = int]\n-2128412672\nvoid typecheck(const T &amp;) [T = unsigned int]\n65535\nvoid typecheck(const T &amp;) [T = unsigned int]\n33059\nvoid typecheck(const T &amp;) [T = unsigned int]\n2166554624\n</code></pre>\n", "LastEditorUserId": "4850040", "LastActivityDate": "2016-08-03T08:19:10.913", "Score": "9", "CreationDate": "2016-08-03T07:36:05.440", "ParentId": "38737024", "CommentCount": "4", "OwnerUserId": "3555525", "LastEditDate": "2016-08-03T08:19:10.913"}, "38737024": {"ViewCount": "1567", "Body": "<p>I faced an interesting scenario in which I got different results depending on the right operand type, and I can't really understand the reason for it.</p>\n<p>Here is the minimal code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdint&gt;\n\nint main()\n{\n    uint16_t check = 0x8123U;\n\n    uint64_t new_check = (check &amp; 0xFFFF) &lt;&lt; 16;\n\n    std::cout &lt;&lt; std::hex &lt;&lt; new_check &lt;&lt; std::endl;\n\n    new_check = (check &amp; 0xFFFFU) &lt;&lt; 16;\n\n    std::cout &lt;&lt; std::hex &lt;&lt; new_check &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>I compiled this code with g++ (gcc version 4.5.2) on Linux 64bit: <em>g++ -std=c++0x -Wall example.cpp -o example</em></p>\n<p>The output was:</p>\n<blockquote>\n<p id=\"so_38737024_38737024_0\">ffffffff81230000 </p>\n<p id=\"so_38737024_38737024_1\">81230000</p>\n</blockquote>\n<p>I can't really understand the reason for the output in the first case.</p>\n<p>Why at some point would any of the temporal calculation results be promoted to a <strong>signed 64bit</strong> value (<code>int64_t</code>) resulting in the sign extension?</p>\n<p>I would accept a result of '0' in both cases if a 16bit value is shifted 16 bits left in the first place and then promoted to a 64bit value. I also do accept the second output if the compiler first promotes the <code>check</code> to <code>uint64_t</code> and then performs the other operations.</p>\n<p>But how come <code>&amp;</code> with 0xFFFF (<code>int32_t</code>) vs. 0xFFFFU (<code>uint32_t</code>) would result in those two different outputs?</p>\n", "AcceptedAnswerId": "38738152", "Title": "Bit wise '&' with signed vs unsigned operand", "CreationDate": "2016-08-03T07:25:06.210", "Id": "38737024", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-08-03T15:40:07.953", "LastEditorUserId": "209139", "LastActivityDate": "2016-08-03T15:40:07.953", "Score": "26", "OwnerUserId": "5218277", "Tags": "<c++><c++11><bitwise-and><type-promotion><sign-extension>", "AnswerCount": "7"}});