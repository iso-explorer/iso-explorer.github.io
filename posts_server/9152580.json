post_cb({"9152753": {"ParentId": "9152580", "CommentCount": "3", "Body": "<p>This is what I get from Clang 3.1 ToT:</p>\n<blockquote>\n<p id=\"so_9152580_9152753_0\">error: constexpr function never produces a constant expression</p>\n</blockquote>\n<p><code>\u00a75.19 [expr.const]</code></p>\n<blockquote>\n<p id=\"so_9152580_9152753_1\">p1 Certain contexts require expressions that satisfy additional requirements as detailed in this sub-clause; other contexts have different semantics depending on whether or not an expression satisfies these requirements. <strong>Expressions that satisfy these requirements are called <em>constant expressions</em>.</strong></p>\n<p id=\"so_9152580_9152753_2\">p2 A <em>conditional-expression</em> is a <em>core constant expression</em> unless it involves one of the following as a potentially evaluated subexpression:</p>\n<ul>\n<li>[...]</li>\n<li>a <code>reinterpret_cast</code> (5.2.10);</li>\n</ul>\n</blockquote>\n<p>So, <code>(char*)&amp;(a)</code> evaluates to a <code>reinterpret_cast</code>, as such the function is never a valid <code>constexpr</code> function.</p>\n", "OwnerUserId": "500104", "PostTypeId": "2", "Id": "9152753", "Score": "10", "CreationDate": "2012-02-05T20:32:33.427", "LastActivityDate": "2012-02-05T20:32:33.427"}, "19736332": {"ParentId": "9152580", "CommentCount": "0", "Body": "<p>If N3620 - Network Byte Order Conversion is implemented, you'll be able to use the constexpr <code>ntoh</code> to check for endianness, but remember there are rare architectures like middle-endian and you'll never be able to support all of them.</p>\n", "OwnerUserId": "111160", "PostTypeId": "2", "Id": "19736332", "Score": "0", "CreationDate": "2013-11-01T22:20:50.970", "LastActivityDate": "2013-11-01T22:20:50.970"}, "9152580": {"CommentCount": "9", "ViewCount": "1404", "CreationDate": "2012-02-05T20:10:54.940", "LastActivityDate": "2013-11-01T22:20:50.970", "Title": "Testing endianess at compile-time: is this constexpr function correct according to the standard?", "AcceptedAnswerId": "9152753", "PostTypeId": "1", "Id": "9152580", "Score": "13", "Body": "<p>After some search for a way to check endianess at compile-time I've come up with the following solution: </p>\n<pre><code>static const int a{1};\n\nconstexpr bool is_big_endian()\n{\n    return *((char*)&amp;(a)) == 1;\n}\n</code></pre>\n<p>GCC accepts this code only in some contexts where constexpr is required:</p>\n<pre><code>int b[is_big_endian() ? 12 : 25]; //works\nstd::array&lt;int, testendian() ? 12 : 25&gt; c;  //fails\n</code></pre>\n<p>For the second case, GCC says <code>error: accessing value of \u2018a\u2019 through a \u2018char\u2019 glvalue in a constant expression</code>. I couldn't find anything in the standard that forbids such thing. Maybe someone could clarify in which case GCC is correct?</p>\n", "Tags": "<c++><c++11><constexpr>", "OwnerUserId": "1356084", "AnswerCount": "3"}, "9986985": {"ParentId": "9152580", "CommentCount": "0", "Body": "<p>You should look into <a href=\"http://www.boost.org/doc/libs/release/boost/detail/endian.hpp\" rel=\"nofollow\">Boost.Detail.Endian</a></p>\n<p>It is a mapping of several architectures to their endianness (through the macros BOOST_BIG_ENDIAN, BOOST_LITTLE_ENDIAN, and BOOST_PDP_ENDIAN). As far as I know, there is no actual way to determine the endianness at compile time, other than a list like this.</p>\n<p>For an example implementation that uses Boost.Detail.Endian, you can see the library I'm hoping to get reviewed for submission to Boost: <a href=\"https://bitbucket.org/davidstone/endian/\" rel=\"nofollow\">https://bitbucket.org/davidstone/endian/</a> (the relevant file is <code>byte_order.hpp</code>, but <code>unsigned.hpp</code> is necessary as well if you want to just use my implementation).</p>\n", "OwnerUserId": "852254", "PostTypeId": "2", "Id": "9986985", "Score": "2", "CreationDate": "2012-04-03T04:10:03.130", "LastActivityDate": "2012-04-03T04:10:03.130"}, "bq_ids": {"n4140": {"so_9152580_9152753_2": {"section_id": 6185, "quality": 0.6, "length": 6}, "so_9152580_9152753_0": {"section_id": 5423, "quality": 0.7142857142857143, "length": 5}, "so_9152580_9152753_1": {"section_id": 6184, "quality": 0.96, "length": 24}}, "n3337": {"so_9152580_9152753_2": {"section_id": 5946, "quality": 0.9, "length": 9}, "so_9152580_9152753_0": {"section_id": 5218, "quality": 0.7142857142857143, "length": 5}, "so_9152580_9152753_1": {"section_id": 5945, "quality": 0.96, "length": 24}}, "n4659": {"so_9152580_9152753_0": {"section_id": 6845, "quality": 0.7142857142857143, "length": 5}, "so_9152580_9152753_1": {"section_id": 7686, "quality": 0.96, "length": 24}}}});