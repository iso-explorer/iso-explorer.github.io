post_cb({"bq_ids": {"n4140": {"so_29476666_29476950_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 5579}}, "n3337": {"so_29476666_29476950_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 5361}}}, "29476950": {"PostTypeId": "2", "Body": "<p>No, it's incorrect. Decrementing iterator equal to <code>begin()</code> is undefined behavior. See [bidirectional.iterators]/1, Table 110:</p>\n<blockquote>\n<p id=\"so_29476666_29476950_0\"><strong>Expression</strong><br>\n<code>--r</code><br>\n<strong>Assertion/note pre-/post-condition</strong><br>\n     pre: there exists <code>s</code> such that <code>r == ++s</code>.<br>\n     post: <code>r</code> is dereferenceable.</br></br></br></br></p>\n</blockquote>\n<p>So the correct way is to compare <code>it</code> with <code>int_set.begin()</code>:</p>\n<pre><code>// Now find the next lowest value -- how?\nif ( it == int_set.begin() )\n{\n    std::cout &lt;&lt; \"Nothing prior.\\n\";\n}\nelse\n{\n    auto it_back = it;\n    --it_back;\n    std::cout &lt;&lt; \"Prior value:  \" &lt;&lt; *it_back &lt;&lt; \".\\n\";\n}\n</code></pre>\n<p>That said, I would instead advise using <code>std::set&lt;int, std::greater&lt;int&gt;&gt;</code> together with <code>lower_bound</code>:</p>\n<pre><code>template &lt;typename Set&gt;\nvoid exploreSet(const Set&amp; int_set, int key) {\n    auto it = int_set.lower_bound(key);\n    if (it == int_set.end())\n        std::cout &lt;&lt; \"Nothing found.\\n\";\n    else\n        std::cout &lt;&lt; \"Found \" &lt;&lt; *it &lt;&lt; \".\\n\";\n}\n\nint main() {\n    std::set&lt;int, std::greater&lt;int&gt;&gt; int_set { 5, 10, 12, 17, 19 };\n    exploreSet(int_set, 15);\n    exploreSet(int_set, 4);\n}\n</code></pre>\n", "LastActivityDate": "2015-04-06T22:37:34.750", "LastEditorUserId": "2756719", "Id": "29476950", "CommentCount": "1", "CreationDate": "2015-04-06T18:12:02.517", "ParentId": "29476666", "Score": "2", "OwnerUserId": "3959454", "LastEditDate": "2015-04-06T22:37:34.750"}, "29476666": {"ViewCount": "317", "Body": "<p>I had a lookup problem to code and was unsure about correct interpretation of iterator testing.  The problem is this:  I have a set and do a lookup using upper_bound, then want to find the next lowest element.  Like this:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;algorithm&gt;\n\nvoid exploreSet(std::set&lt;int&gt; &amp;int_set, int key);\n\nint main()\n{\n    std::set&lt;int&gt; int_set { 5, 10, 12, 17, 19 };\n    exploreSet(int_set, 15);\n    exploreSet(int_set, 4);\n    return 0;\n}\n\n\nvoid exploreSet(std::set&lt;int&gt; &amp;int_set, int key)\n{\n    auto it = int_set.upper_bound(key);\n    if ( it==int_set.end() )\n    {\n        std::cout &lt;&lt; \"Nothing found.\\n\";\n    }\n    else\n    {\n        std::cout &lt;&lt; \"Found \" &lt;&lt; *it &lt;&lt; \".\\n\";\n        // Now find the next lowest value -- how?\n        auto it_back = it;\n        --it_back;\n        if ( it_back==int_set.end() )\n        {\n            std::cout &lt;&lt; \"Nothing prior.\\n\";\n        }\n        else\n        {\n            std::cout &lt;&lt; \"Prior value:  \" &lt;&lt; *it_back &lt;&lt; \".\\n\";\n        }\n    }\n}\n</code></pre>\n<p>Resulting output of running this on gcc 4.9.2 with std=c++14:</p>\n<pre><code>Found 17.\nPrior value:  12.\nFound 5.\nNothing prior.\n</code></pre>\n<p>This works.  But why?</p>\n<p>Is it correct to compare against std::set::end() when going backwards on an iterator obtained through upper_bound?  Why or why not?</p>\n", "Title": "C++ std::set upper_bound iterator behaviour", "CreationDate": "2015-04-06T17:54:14.557", "LastActivityDate": "2015-04-06T22:37:34.750", "CommentCount": "7", "PostTypeId": "1", "Id": "29476666", "Score": "2", "OwnerUserId": "4755467", "Tags": "<c++11><stl><iterator><set>", "AnswerCount": "1"}});