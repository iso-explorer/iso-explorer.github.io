post_cb({"bq_ids": {"n4140": {"so_27609522_27609623_0": {"section_id": 259, "quality": 0.9166666666666666, "length": 55}}, "n3337": {"so_27609522_27609623_0": {"section_id": 250, "quality": 0.6833333333333333, "length": 41}}, "n4659": {"so_27609522_27609623_0": {"section_id": 266, "quality": 0.9166666666666666, "length": 55}}}, "27609623": {"ParentId": "27609522", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The effects of <em>instantiation declarations</em>, i.e., a guarantee that the template is not instantiated implicitly, does not apply to <code>inline</code> functions according to 14.7.2 [temp.explicit] paragraph 10:</p>\n<blockquote>\n<p id=\"so_27609522_27609623_0\">Except for inline functions, declarations with types deduced from their initializer or return value (7.1.6.4), const variables of literal types, variables of reference types, and class template specializations, explicit instantiation declarations have the effect of suppressing the implicit instantiation of the entity to which they refer. [ Note: The intent is that an inline function that is the subject of an explicit instantiation declaration will still be implicitly instantiated when odr-used (3.2) so that the body can be considered for inlining, but that no out-of-line copy of the inline function would be generated in the translation unit.\u2014end note ]</p>\n</blockquote>\n<p>The standard library is clearly free to declare any of its functions as <code>inline</code>. That is, using an instantiation declaration doesn't affect the requirement on types being defined with standard library template class (unless otherwise specified, of course). gcc defines the destructor for <code>std::unique_ptr&lt;...&gt;</code> in the definition of this class template making it implicitly inline. Here is an example source demonstrating the problem: depending on whether <code>DECL_ONY</code> is defined it compiler or not:</p>\n<pre><code>template &lt;typename T&gt;\nstruct foo\n{\n    ~foo()\n#ifdef DECL_ONLY\n        ;\n#else\n    { static_assert(sizeof(T), \"defined!\"); }\n#endif\n};\n\n#ifdef DECL_ONLY\ntemplate &lt;typename T&gt;\nfoo&lt;T&gt;::~foo() { static_assert(sizeof(T), \"defined!\"); }\n#endif\n\nclass MyClass;\nextern template struct foo&lt;MyClass&gt;;\n\nint main(int , char* []) {\n    foo&lt;MyClass&gt; f;\n}\n</code></pre>\n", "OwnerUserId": "1120273", "LastEditorUserId": "1120273", "LastEditDate": "2014-12-22T20:44:33.423", "Id": "27609623", "Score": "6", "CreationDate": "2014-12-22T20:02:56.383", "LastActivityDate": "2014-12-22T20:44:33.423"}, "27609522": {"CommentCount": "3", "ViewCount": "444", "PostTypeId": "1", "LastEditorUserId": "2551720", "CreationDate": "2014-12-22T19:54:19.447", "LastActivityDate": "2014-12-22T20:44:33.423", "Title": "Extern template for template parametrized with incompete type", "FavoriteCount": "1", "LastEditDate": "2014-12-22T20:12:49.337", "Id": "27609522", "Score": "7", "Body": "<p>A compilable example:</p>\n<p><strong>main.cpp</strong></p>\n<pre><code>#include \"test.h\"\n\nint main(int argc, char* argv[]) {\n    auto myPtr = std::unique_ptr&lt;MyClass&gt;(getMyPtr());\n}\n</code></pre>\n<p><strong>test.h</strong></p>\n<pre><code>#ifndef TEST_H\n#define TEST_H\n\n#include &lt;memory&gt;\n\nclass MyClass;\nextern template class std::unique_ptr&lt;MyClass&gt;;\nMyClass* getMyPtr();\n\n#endif\n</code></pre>\n<p><strong>test.cpp</strong></p>\n<pre><code>#include \"test.h\"\n\nclass MyClass {};\ntemplate class std::unique_ptr&lt;MyClass&gt;;\nMyClass* getMyPtr() { return new MyClass; }\n</code></pre>\n<p>g++ 4.9.2 complains </p>\n<pre><code>In file included from c:/devel/mingw32/i686-w64-mingw32/include/c++/memory:81:0,\n                 from main.cpp:4:\nc:/devel/mingw32/i686-w64-mingw32/include/c++/bits/unique_ptr.h: In instantiation of 'void std::default_delete&lt;_Tp&gt;::operator()(_Tp*) const [with _Tp = MyClass]':\nc:/devel/mingw32/i686-w64-mingw32/include/c++/bits/unique_ptr.h:236:16:   required from 'std::unique_ptr&lt;_Tp, _Dp&gt;::~unique_ptr() [with _Tp = MyClass; _Dp = std::default_delete&lt;MyClass&gt;]'\nmain.cpp:64:53:   required from here\nc:/devel/mingw32/i686-w64-mingw32/include/c++/bits/unique_ptr.h:74:22: error: invalid application of 'sizeof' to incomplete type 'MyClass'\n  static_assert(sizeof(_Tp)&gt;0,\n                      ^\n</code></pre>\n<p>even though MyClass should be visible at the point of template instantiation. Why?</p>\n<p><strong>Edit:</strong>\nfixed a typo in example.</p>\n", "Tags": "<c++><templates><c++11><forward-declaration><incomplete-type>", "OwnerUserId": "2551720", "AnswerCount": "1"}});