post_cb({"23918872": {"CommentCount": "10", "ViewCount": "2063", "PostTypeId": "1", "LastEditorUserId": "241631", "CreationDate": "2014-05-28T18:09:21.083", "LastActivityDate": "2014-05-28T19:16:09.230", "Title": "Capturing pointers in lambda expression?", "AcceptedAnswerId": "23919791", "LastEditDate": "2014-05-28T18:55:31.833", "Id": "23918872", "Score": "1", "Body": "<p>I have a function that uses a lambda expression.</p>\n<pre><code>std::vector&lt;Bar*&gt; mBars;\n\nvoid foo(Bar* bar)\n{\n    auto duplicateBars = std::remove_if(mBars.begin(), mBars.end(),\n        [bar] (const Bar* const &amp;element)\n        {\n            return bar == element;\n        });\n\n    mBars.erase(duplicateBars, mBars.end());\n}\n</code></pre>\n<p>Later, I reviewed the code and realized I could add two consts to foo's signature.</p>\n<pre><code>void foo(const Bar* const bar);\n</code></pre>\n<p><code>bar</code>'s pointer and data is now constant, but for the purpose of the lambda expression the pointer itself is constant, because I captured by value.  However, the data pointed to can be changed and there is no way to change this, because <code>const</code> is not allowed in the lambda capture.</p>\n<p>This is unintuitive to me.  Is my interpretation correct?  I can use the second signature, but I cannot protect the data from being changed in the lambda expression.</p>\n", "Tags": "<c++><c++11><lambda>", "OwnerUserId": "870130", "AnswerCount": "2"}, "23919639": {"ParentId": "23918872", "CommentCount": "0", "Body": "<p>Your question seems to arise from a misunderstanding of how capturing of variables in lambda expressions works. When you capture a variable by copy, the corresponding data member created in the closure type generated from the lambda expression will have the <em>same type</em> as the original object. This preserves <code>const</code>-ness, and you cannot go modify whatever <code>bar</code> points to within the body of the lambda.</p>\n<p>From <em>\u00a75.1.2/15 [expr.prim.lambda]</em></p>\n<blockquote>\n<p id=\"so_23918872_23919639_0\">An entity is <em>captured by copy</em> if it is implicitly captured and the <em>capture-default</em> is <code>=</code> or if it is explicitly captured with a capture that is not of the form <em><code>&amp; identifier</code></em> or <em><code>&amp; identifier initializer</code></em>. For each entity captured by copy, an unnamed non-static data member is declared in the closure type. The declaration order of these members is unspecified. <strong>The type of such a data member is the type of the corresponding\n  captured entity</strong> if the entity is not a reference to an object, or the referenced type otherwise.</p>\n</blockquote>\n<p><a href=\"http://coliru.stacked-crooked.com/a/d5ce2e4d509449d3\" rel=\"nofollow\">Live demo</a></p>\n", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "23919639", "Score": "1", "CreationDate": "2014-05-28T18:52:54.150", "LastActivityDate": "2014-05-28T18:52:54.150"}, "bq_ids": {"n4140": {"so_23918872_23919639_0": {"section_id": 5974, "quality": 0.9111111111111111, "length": 41}}, "n3337": {"so_23918872_23919639_0": {"section_id": 5742, "quality": 0.8222222222222222, "length": 37}}, "n4659": {"so_23918872_23919639_0": {"section_id": 7473, "quality": 0.8444444444444444, "length": 38}}}, "23919791": {"ParentId": "23918872", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_23918872_23919791_0\">However, the data pointed to can be changed and there is no way to change this, because const is not allowed in the lambda capture.</p>\n</blockquote>\n<p>No, when capturing by value in a lambda expression constness is preserved, i.e. capturing a pointer to <code>const</code> data will prevent changes to the data inside the lambda.</p>\n<pre><code>int i = 1;\nconst int* ptr = &amp;i;\n\nauto func = [ptr] {\n    ++*ptr; // ERROR, ptr is pointer to const data.\n}\n</code></pre>\n<p>A lambda will also add <em>top-level</em> constness to pointers when capturing by value (unless using <code>mutable</code>).</p>\n<pre><code>auto func = [ptr] {\n    ptr = nullptr; // ERROR, ptr is const pointer (const int* const).\n}\n\nauto func = [ptr] () mutable { // Mutable, will not add top-level const.\n    ptr = nullptr; // OK\n}\n</code></pre>\n<blockquote>\n<p id=\"so_23918872_23919791_1\">I can use the second signature, but I cannot protect the data from being changed in the lambda expression.</p>\n</blockquote>\n<p>You can protect the data from being changed inside the lambda by using <code>const</code>.</p>\n<pre><code>const Bar* bar = &amp;bar_data;\nauto b = [bar] (const Bar* element) { // Data pointed to by bar is read-only.\n    return bar == element;\n};\n</code></pre>\n<p>Also the lambda expression takes a parameter of type <code>const Bar* const &amp;</code>, i.e. <em>reference</em> to const pointer to const data. No need to take a reference, simply take a <code>const Bar*</code>.</p>\n<p>More info about pointers and <code>const</code>: <a href=\"https://stackoverflow.com/questions/1143262/what-is-the-difference-between-const-int-const-int-const-int-const\">What is the difference between const int*, const int * const, and int const *?</a></p>\n", "OwnerUserId": "873025", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:20:55.463", "Id": "23919791", "Score": "3", "CreationDate": "2014-05-28T19:00:55.590", "LastActivityDate": "2014-05-28T19:16:09.230"}});