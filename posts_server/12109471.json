post_cb({"bq_ids": {"n4140": {"so_12109471_12110635_0": {"length": 50, "quality": 0.8928571428571429, "section_id": 601}}, "n3337": {"so_12109471_12110635_0": {"length": 50, "quality": 0.8928571428571429, "section_id": 591}}, "n4659": {"so_12109471_12110635_0": {"length": 50, "quality": 0.8928571428571429, "section_id": 627}}}, "12109471": {"ViewCount": "583", "Body": "<p>Consider the following typical SFINAE test function (it checks if a type has a <code>begin()</code> member function)</p>\n<pre><code>    template &lt;class&gt; constexpr bool\nhas_begin_member (...) { return false; }\n\n    template &lt;class T&gt; constexpr bool\nhas_begin_member (decltype (std::declval &lt;T&gt;().begin ())* = 0) { \n    return true;\n}\n</code></pre>\n<p>I can call it with an argument:</p>\n<pre><code>has_begin_member &lt;int&gt; (0); // yields false\n</code></pre>\n<p>but without any arguments:</p>\n<pre><code>has_begin_member &lt;int&gt; (); // compilation error\n</code></pre>\n<p>it leads to the following ambiguity:</p>\n<pre><code>error: call of overloaded 'has_begin_member()' is ambiguous\nnote: candidates are:\nnote: constexpr bool has_begin_member(...)\nnote: constexpr bool has_begin_member(decltype (declval&lt;T&gt;().begin())*)\n</code></pre>\n<p>Why doesn't the \"ellipsis trick\" work in that case?</p>\n<p>Edit: full program: </p>\n<pre><code>#include &lt;utility&gt;\n#include &lt;vector&gt;\n\n    template &lt;class&gt; constexpr bool\nhas_begin_member (...) { return false; }\n\n    template &lt;class T&gt; constexpr bool\nhas_begin_member (decltype (std::declval &lt;T&gt;().begin ())* = 0) { \n    return true;\n}\n\n\nstatic_assert (!has_begin_member &lt;int&gt; (0), \"broken\");\nstatic_assert (has_begin_member &lt;std::vector &lt;int&gt;&gt; (0), \"broken\");\n\nstatic_assert (!has_begin_member &lt;int&gt; (), \"broken\");\nstatic_assert (has_begin_member &lt;std::vector &lt;int&gt;&gt; (), \"broken\");\n\n    int \nmain (){}\n</code></pre>\n<p>Compilation: </p>\n<pre><code>g++ -std=c++11 -o toto ./toto.cpp\n./toto.cpp:17:58: error: call of overloaded 'has_begin_member()' is ambiguous\n./toto.cpp:17:58: note: candidates are:\n./toto.cpp:5:5: note: constexpr bool has_begin_member(...) [with &lt;template-parameter-1-1&gt; = std::vector&lt;int&gt;]\n./toto.cpp:8:5: note: constexpr bool has_begin_member(decltype (declval&lt;T&gt;().begin())*) [with T = std::vector&lt;int&gt;; decltype (declval&lt;T&gt;().begin()) = __gnu_cxx::__normal_iterator&lt;int*, std::vector&lt;int&gt; &gt;]\n</code></pre>\n", "AcceptedAnswerId": "12110635", "Title": "SFINAE: ambiguous overload if called with no arguments", "CreationDate": "2012-08-24T12:32:47.330", "Id": "12109471", "CommentCount": "8", "LastEditDate": "2012-08-24T16:28:49.840", "PostTypeId": "1", "LastEditorUserId": "636019", "LastActivityDate": "2012-08-24T16:28:49.840", "Score": "4", "OwnerUserId": "1622545", "Tags": "<c++><c++11><sfinae>", "AnswerCount": "1"}, "12110635": {"Id": "12110635", "PostTypeId": "2", "Body": "<p>For the <code>has_begin_member&lt;int&gt;()</code> case the second overload is not viable because template argument substitution fails, so only the first overload is viable, so no ambiguity.</p>\n<p>For the <code>has_begin_member&lt;std::vector&lt;int&gt;&gt;()</code> case substitution succeeds so there are two viable functions.</p>\n<p>13.3.2 [over.match.viable]:</p>\n<blockquote id=\"so_12109471_12110635_0\">\n<ul>\n<li>If there are <em>m</em> arguments in the list, all candidate functions having exactly <em>m</em> parameters are viable.</li>\n<li>A candidate function having fewer than <em>m</em> parameters is viable only if it has an ellipsis in its parameter\n  list (8.3.5). For the purposes of overload resolution, any argument for which there is no corresponding\n  parameter is considered to \u201cmatch the ellipsis\u201d (13.3.3.1.3) .</li>\n<li>A candidate function having more than <em>m</em> parameters is viable only if the <em>(m+1)</em>-st parameter has a\n  default argument (8.3.6). For the purposes of overload resolution, the parameter list is truncated\n  on the right, so that there are exactly <em>m</em> parameters.</li>\n</ul>\n</blockquote>\n<p>In this case <em>m</em> is zero, the first overload is viable (by the second bullet) and the second overload is also viable (by the third bullet) but for the purposes of overload resolution the parameter with a default argument is ignored, and so the best viable functions is found by comparing:</p>\n<pre><code>template&lt;&gt; constexpr bool has_begin_member&lt;vector&lt;int&gt;&gt;(...);\ntemplate&lt;&gt; constexpr bool has_begin_member&lt;vector&lt;int&gt;&gt;();\n</code></pre>\n<p>Which is obviously ambiguous, just like this is:</p>\n<pre><code>int f(...);\nint f();\n\nint i = f();  // error\n</code></pre>\n<p>There is no conversion sequence needed to call either function, so they cannot be ranked in terms of which has a \"better conversion sequence\" than the other (using the rules in 13.3.3.2 [over.ics.rank],) which means they are ambiguous.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2012-08-24T15:06:28.957", "Score": "3", "CreationDate": "2012-08-24T13:43:57.000", "ParentId": "12109471", "CommentCount": "2", "OwnerUserId": "981959", "LastEditDate": "2012-08-24T15:06:28.957"}});