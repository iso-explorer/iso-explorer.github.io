post_cb({"bq_ids": {"n4140": {"so_39319862_39332627_0": {"length": 20, "quality": 0.7692307692307693, "section_id": 6043}}, "n3337": {"so_39319862_39332627_0": {"length": 20, "quality": 0.7692307692307693, "section_id": 5811}}, "n4659": {"so_39319862_39332627_0": {"length": 20, "quality": 0.7692307692307693, "section_id": 7542}}}, "39320001": {"Id": "39320001", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_39319862_39320001_0\">I need to convert \"void*\" to int</p>\n</blockquote>\n<p>no you don't.</p>\n<blockquote>\n<p id=\"so_39319862_39320001_1\">I really do...</p>\n</blockquote>\n<p>no, you need to represent a pointer as some kind of integer type which is guaranteed not to lose information.</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n#include &lt;utility&gt;\n#include &lt;cinttypes&gt;\n\nvoid dummy(void *p) {\n    std::intptr_t x = reinterpret_cast&lt;std::intptr_t&gt;(p);\n    printf(\"x = %\" PRIiPTR \"\\n\", x);\n// ^^ see here: http://en.cppreference.com/w/cpp/types/integer\n}\n\nint main(int argc, char *argv[]) {\n    void *p = (void*)5;\n    dummy(p);\n    return 0;\n}\n</code></pre>\n<blockquote>\n<p id=\"so_39319862_39320001_2\">ok, what I really want to do is work with 32-bit values in a standards-compliant way.</p>\n</blockquote>\n<p>This is what <code>std::uint32_t</code> is for:</p>\n<pre><code>#include &lt;cstdint&gt;\n#include &lt;iostream&gt;\n\nvoid dummy(std::uint32_t x) {\n  std::cout &lt;&lt; x &lt;&lt; '\\n';\n}\n\nint main(int argc, char *argv[]) {\n    auto x = std::uint32_t(5);\n    dummy(x);\n    return 0;\n}\n</code></pre>\n<p><code>std::uint32_t</code> - guaranteed to be unsigned 32 bits</p>\n<p><code>std::int32_t</code> - guaranteed to be signed 32 bits</p>\n", "LastEditorUserId": "2015579", "LastActivityDate": "2016-09-04T20:37:52.493", "Score": "6", "CreationDate": "2016-09-04T18:09:43.393", "ParentId": "39319862", "CommentCount": "2", "OwnerUserId": "2015579", "LastEditDate": "2016-09-04T20:37:52.493"}, "39332627": {"Id": "39332627", "PostTypeId": "2", "Body": "<p>You are probably looking for something along the lines of</p>\n<pre><code>int x = static_cast&lt;int&gt;(reinterpret_cast&lt;std::uintptr_t&gt;(p));\n</code></pre>\n<p>This is not strictly guaranteed to work: perhaps surprisingly, the standard guarantees that a pointer converted to a large enough integer and back to a pointer results in the same value; but doesn't provide a similar guarantee for when an integer is converted to a pointer and back to the integer. All it says about the latter case is</p>\n<blockquote>\n<p id=\"so_39319862_39332627_0\"><strong>[expr.reinterpret.cast]/4</strong> A pointer can be explicitly converted to any integral type large enough to hold it. The mapping function is implementation-defined. [ <em>Note:</em> It is intended to be unsurprising to those who know the addressing structure of the underlying machine. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>Hopefully, you know the addressing structure of your machine, and won't be surprised.</p>\n", "LastActivityDate": "2016-09-05T14:21:04.247", "CommentCount": "0", "CreationDate": "2016-09-05T14:21:04.247", "ParentId": "39319862", "Score": "2", "OwnerUserId": "1670129"}, "39319862": {"ViewCount": "882", "Body": "<p>I need to convert \"void*\" to int, but compiler keeps giving me warning.\nWonder if there is a way to change the code so that compiler will not complain. This occurs a lot in the code base, especially when passing an argument to starting a new thread.</p>\n<pre><code>$ g++ -fpermissive te1.cc\nte1.cc: In function \u2018void dummy(void*)\u2019:\nte1.cc:4:15: warning: cast from \u2018void*\u2019 to \u2018int\u2019 loses precision [-fpermissive]\n  int x = (int)p;\n               ^\n</code></pre>\n<p>Here is the simple code \"te1.cc\":</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nextern void someFunc(int);\nvoid dummy(int type, void *p) {\n    if (type == 0) {\n        int x = (int)p;\n        someFunc(x);\n    } else if (type == 1) {\n        printf(\"%s\\n\", (char*)p);\n    }\n}\n\nint main(int argc, char *argv[]) {\n    void *p = (void*)5;\n    dummy(p);\n    return 0;\n}\n</code></pre>\n<p><strong>UDPATE1</strong></p>\n<p>I understand that I will lose precision. It's intended sometimes. What I need is to have a way to remove the warning in places I know for sure it's safe.  Sorry for not making it clear earlier.</p>\n<p><strong>UDPATE2</strong></p>\n<p>Updated the code snippet to be a little less non-trivial to illustrate the point. The parameter needs to pass different type of values. I need a way to cast without generating warning.  </p>\n", "AcceptedAnswerId": "39332627", "Title": "Convert \"void*\" to int without warning", "CreationDate": "2016-09-04T17:54:36.633", "Id": "39319862", "CommentCount": "13", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-09-04T21:56:29.663", "LastEditorUserId": "3337677", "LastActivityDate": "2016-09-05T14:21:04.247", "Score": "1", "OwnerUserId": "3337677", "Tags": "<c++>", "AnswerCount": "2"}});