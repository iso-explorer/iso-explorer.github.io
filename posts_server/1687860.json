post_cb({"1687931": {"ParentId": "1687860", "CommentCount": "1", "CreationDate": "2009-11-06T14:23:33.187", "OwnerUserId": "41747", "PostTypeId": "2", "Id": "1687931", "Score": "0", "Body": "<p>Because Visual Studio does all sorts of tricks to allow for legacy code to work.  IIRC, the Standard only states that <code>type_info</code> exist within the <code>std</code> namespace.  It does not mandate that it not exist within the global namespace - that is really an implementation decision.</p>\n<p><em>Caveat Emptor:</em> I haven't verified this in the Standard.</p>\n", "LastActivityDate": "2009-11-06T14:23:33.187"}, "1687897": {"ParentId": "1687860", "CommentCount": "2", "CreationDate": "2009-11-06T14:18:26.020", "OwnerUserId": "140719", "PostTypeId": "2", "Id": "1687897", "Score": "1", "Body": "<p>With the <code>using</code> declaration, actually, there <em>is</em> a <code>std::type_info</code>. There might be scenarios where the fact that it isn't defined inside of <code>std</code> might be a problem, but I'd wonder if you have ran into one of them. </p>\n<p>What's your problem? </p>\n", "LastActivityDate": "2009-11-06T14:18:26.020"}, "1687860": {"CommentCount": "0", "ViewCount": "1986", "PostTypeId": "1", "LastEditorUserId": "91683", "CreationDate": "2009-11-06T14:12:30.703", "LastActivityDate": "2009-11-06T15:35:37.430", "Title": "Why is type_info declared outside namespace std?", "AcceptedAnswerId": "1688142", "LastEditDate": "2009-11-06T14:38:29.760", "Id": "1687860", "Score": "1", "Body": "<p>I'm using VS2005 and the MS implementation of STL. However, the class type_info in  is declared outside of \"namespace std\". This creates some problems for third party libs that excepts to find a std::type_info. Why is this so, and is there any workaround? Here is a sample from the beginning of typeinfo:</p>\n<pre><code>class type_info {\n...\n};\n\n\n_STD_BEGIN // = namespace std  {\n</code></pre>\n", "Tags": "<c++><stl><windows-ce><rtti>", "OwnerUserId": "91683", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_1687860_1688142_0": {"section_id": 6254, "quality": 1.0, "length": 18}, "so_1687860_1688142_1": {"section_id": 6020, "quality": 0.7307692307692307, "length": 19}}, "n3337": {"so_1687860_1688142_0": {"section_id": 6014, "quality": 1.0, "length": 18}, "so_1687860_1688142_1": {"section_id": 5788, "quality": 0.7307692307692307, "length": 19}}, "n4659": {"so_1687860_1688142_0": {"section_id": 7758, "quality": 0.9444444444444444, "length": 17}, "so_1687860_1688142_1": {"section_id": 7519, "quality": 0.7692307692307693, "length": 20}}}, "1688142": {"ParentId": "1687860", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2009-11-06T14:59:51.513", "Score": "3", "LastEditorUserId": "12711", "LastEditDate": "2009-11-06T15:35:37.430", "Id": "1688142", "OwnerUserId": "12711", "Body": "<p>That's interesting - the standard does say that (17.4.1.1. Library contents)</p>\n<blockquote>\n<p id=\"so_1687860_1688142_0\">All library entities except  macros, operator new and operator delete are defined within the namespace std or namespaces nested within namespace std.</p>\n</blockquote>\n<p>And clearly says that (5.2.8 Type identification)</p>\n<blockquote>\n<p id=\"so_1687860_1688142_1\">The result of a typeid expression is an lvalue of static type const std::type_info (18.5.1) and dynamic type const std::type_info or const name where name is an implementation-defined class derived from std::type_info which preserves the behavior described in 18.5.1.</p>\n</blockquote>\n<p>Ans, of course, the descriptin of header <code>&lt;typeinfo?&gt;</code> indicate the it should be in namespace <code>std</code> (18.5 Type identification):</p>\n<blockquote>\n<p id=\"so_1687860_1688142_2\">Header <code>&lt;typeinfo&gt;</code> synopsis</p>\n<pre><code>namespace std {\n    class type_info;\n    class bad_cast;\n    class bad_typeid;\n}\n</code></pre>\n</blockquote>\n<p>So <code>type_info</code> should be in the <code>std</code> namespace (and not outside of it).  I guess that either this is a bug or there's some large set of code (or small set of important code) that needs it outside of the <code>std</code> namespace. I'd have thought they'd use some preprocessor magic to make it so you could force it to be in the <code>std</code> namespace if desired (or the other way around - make it in <code>std</code> by default and allow a macro or something to force it to the global namespace).</p>\n<p>However, one additional wrinkle for <code>type_info</code> is that it's the result of the <code>typeid</code> operator (more precisely, something derived from <code>type_info</code> is the result), so there's probably a tight dependency on what the compiler does for the <code>typeid</code> operator that the library  needs to be in line with. So the fact that <code>type_info</code> isn't in namespace <code>std</code> is possibly due to what the compiler does with <code>typeid</code> expressions, and the library writers probably have little direct control over that (and I'd guess that's one reason why there's no preprocssor workaround for the problem). Someone who knows a lot more about how compilers work than I do would have to explain this better (or take it beyond speculation).</p>\n<p>But I think you'll have to ask someone at Microsoft (or PJ Plauger/Dinkumware) for a real answer to \"why\".</p>\n", "LastActivityDate": "2009-11-06T15:35:37.430"}});