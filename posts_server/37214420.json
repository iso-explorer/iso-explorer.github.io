post_cb({"37214551": {"ParentId": "37214420", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>As published, C++ 11 has the rule \"an integral constant expression prvalue of integer type which evaluates to <code>0</code> can be converted to any pointer type, yielding the null pointer value of that type.\" (C++98/03 had a similarly worded rule with the same net effect).</p>\n<p><code>bool</code> is an integer type, and <code>false</code> evaluates to <code>0</code>. So <code>false</code> is a valid null pointer constant.</p>\n<p>Apart from this extra rule, C++ has no implicit conversions from integral types to pointers. Which is why <code>true</code> cannot implicitly be converted to a pointer.</p>\n<p>However, C++14 changed the definition of a null pointer constant so that only integer literals (and not integral constant expressions) qualify. <code>false</code> is a boolean literal, not an integer one, so under C++14, the code will not compile.</p>\n<p>Furthermore, since the issue was recognised by the standard committee as a defect in C++11, newer C++11 compilers are likely to obey the C++14 rules in this regard and not treat <code>false</code> as a null pointer constant. Thanks to <a href=\"https://stackoverflow.com/users/3777958/destructor\">@Destructor</a> for tracking down the <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#903\" rel=\"nofollow noreferrer\">issue status</a>.</p>\n<hr>\n<p>As to why two implicit conversions seem to be allowed here: the rule is not \"at most one implicit conversion is allowed.\" The rule is \"at most one <strong>user-defined</strong> conversion is allowed.\" Pointer conversions (such as converting a null pointer constant to a null pointer value) are not classified as user-defined conversions. So the conversion sequence in your case is a pointer conversion (<code>bool</code> to <code>const char *</code>) followed by a user-defined conversion (<code>const char *</code> to <code>A</code>).</p>\n</hr>", "OwnerUserId": "1782465", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:31:46.050", "Id": "37214551", "Score": "5", "CreationDate": "2016-05-13T16:02:16.600", "LastActivityDate": "2016-05-16T08:32:39.480"}, "37214902": {"ParentId": "37214420", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The OP 's program fails in compilation in g++ &amp; clang++ when use <code>-std=c++11</code>,      <code>-std=c++14</code>. </p>\n<p>See live demo <a href=\"http://melpon.org/wandbox/permlink/DbV4qu0qllkMJh4Z\" rel=\"nofollow noreferrer\">here</a> on g++ 6.1.0. It gives following error</p>\n<pre><code>prog.cc: In function 'A foo()':\nprog.cc:17:12: error: could not convert 'false' from 'bool' to 'A'\n     return false;\n            ^~~~~ \n</code></pre>\n<p>See live demo <a href=\"http://coliru.stacked-crooked.com/a/cb3299e6197ca2ca\" rel=\"nofollow noreferrer\">here</a> on clang++. It gives following diagnosis.</p>\n<pre><code>main.cpp:17:12: error: no viable conversion from returned value of type 'bool' to function return type 'A'\n    return false;\n           ^~~~~\nmain.cpp:1:7: note: candidate constructor (the implicit copy constructor) not viable: no known conversion from 'bool' to 'const A &amp;' for 1st argument\nclass A\n      ^\nmain.cpp:1:7: note: candidate constructor (the implicit move constructor) not viable: no known conversion from 'bool' to 'A &amp;&amp;' for 1st argument\nclass A\n      ^\nmain.cpp:10:4: note: candidate constructor not viable: no known conversion from 'bool' to 'const char *' for 1st argument\nA::A(const char *s)\n   ^\nmain.cpp:22:12: error: no viable conversion from returned value of type 'bool' to function return type 'A'\n    return true;\n           ^~~~\nmain.cpp:1:7: note: candidate constructor (the implicit copy constructor) not viable: no known conversion from 'bool' to 'const A &amp;' for 1st argument\nclass A\n      ^\nmain.cpp:1:7: note: candidate constructor (the implicit move constructor) not viable: no known conversion from 'bool' to 'A &amp;&amp;' for 1st argument\nclass A\n      ^\nmain.cpp:10:4: note: candidate constructor not viable: no known conversion from 'bool' to 'const char *' for 1st argument\nA::A(const char *s)\n   ^\nmain.cpp:7:21: warning: private field 'p' is not used [-Wunused-private-field]\n        const char *p;\n                    ^\n</code></pre>\n<p><strong>false</strong> should not convert to pointer type since C++11. See similar question <a href=\"https://stackoverflow.com/questions/32009694/why-implicit-conversion-of-bool-to-string-isnt-an-error\">here</a> which I've asked sometimes ago. </p>\n", "OwnerUserId": "3777958", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:31:46.050", "Id": "37214902", "Score": "2", "CreationDate": "2016-05-13T16:21:03.473", "LastActivityDate": "2016-05-19T18:50:35.727"}, "bq_ids": {"n4140": {"so_37214420_37214756_2": {"section_id": 39, "quality": 1.0, "length": 7}, "so_37214420_37214756_0": {"section_id": 26, "quality": 0.9, "length": 9}, "so_37214420_37214756_1": {"section_id": 39, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_37214420_37214756_2": {"section_id": 36, "quality": 1.0, "length": 7}, "so_37214420_37214756_0": {"section_id": 23, "quality": 0.9, "length": 9}, "so_37214420_37214756_1": {"section_id": 5947, "quality": 0.7272727272727273, "length": 8}}, "n4659": {"so_37214420_37214756_2": {"section_id": 39, "quality": 1.0, "length": 7}, "so_37214420_37214756_0": {"section_id": 26, "quality": 0.9, "length": 9}, "so_37214420_37214756_1": {"section_id": 39, "quality": 0.8181818181818182, "length": 9}}}, "37214420": {"CommentCount": "2", "ViewCount": "143", "CreationDate": "2016-05-13T15:54:59.180", "LastActivityDate": "2016-05-19T18:50:35.727", "Title": "Conversion of false to object via const char * constructor", "PostTypeId": "1", "Id": "37214420", "Score": "3", "Body": "<p>I have built the following minimal example:</p>\n<pre><code>class A\n{\n    public:\n        A(const char *s);\n\n    private:\n        const char *p;\n};\n\nA::A(const char *s)\n  : p(s)\n{\n}\n\nA foo()\n{\n    return false;\n}\n\nA bar()\n{\n    return true;\n}\n</code></pre>\n<p>Compiling with <code>g++ (Debian 4.7.2-5) 4.7.2</code> I get the following:</p>\n<pre><code>t.cc: In function 'A foo()':\nt.cc:17:10: warning: converting 'false' to pointer type for argument 1 of 'A::A(const char*)' [-Wconversion-null]\nt.cc: In function 'A bar()':\nt.cc:23:10: error: could not convert 'true' from 'bool' to 'A'\n</code></pre>\n<p>As far as I know, it is possible to use one type <code>T</code> instead of an instance of class <code>A</code>, if class <code>A</code> has a constructor <code>A(T)</code>. In this case, the value / instance of T is wrapped by the compiler inside a call to the <code>A(T)</code> constructor.</p>\n<p>Also, only one direct implicit conversion is allowed, i.e. no chain <code>A(B(c))</code> is inserted to convert a value <code>c</code> of type <code>C</code>, even if constructors <code>A(B)</code> and <code>B(C)</code> exist.</p>\n<p>So, my questions:</p>\n<ol>\n<li>Why is <code>false</code> converted to a pointer in my example? Sure, a pointer is not an object, but there are still two implicit conversions here. What rule is being applied?</li>\n<li>Why does the conversion not work with <code>true</code>? My intuition is that <code>false</code> can be reasonably converted to a <code>nullptr</code> (see also the warning), whereas there is no meaningful pointer value for <code>true</code>.</li>\n</ol>\n<p>So, could someone explain what conversion rules apply / do not apply to the two examples above?</p>\n", "Tags": "<c++><type-conversion><implicit-conversion>", "OwnerUserId": "815409", "AnswerCount": "3"}, "37214756": {"ParentId": "37214420", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>For 1), <code>false</code> is of type <code>bool</code>, and it can be <a href=\"http://en.cppreference.com/w/cpp/language/implicit_conversion\" rel=\"nofollow\"><b>promoted</b></a> to an <code>int</code> implicitely:</p>\n<blockquote id=\"so_37214420_37214756_0\">\n<ul>\n<li>the type <code>bool</code> can be converted to <code>int</code> with the value <code>false</code> becoming \u200b<code>0</code>\u200b and <code>true</code> becoming <code>1</code>.</li>\n</ul>\n</blockquote>\n<p>So, <code>false</code> is basically promoted to <code>NULL</code>/<code>0</code> (or <code>nullptr</code>), which can be assigned to a pointer.</p>\n<p>For 2), \u00a74.10 states that:</p>\n<blockquote>\n<p id=\"so_37214420_37214756_1\">A <b>null pointer constant is an integer literal (2.14.2) with value zero</b> or a prvalue of type std::nullptr_t.</p>\n<p id=\"so_37214420_37214756_2\"><b>A null pointer constant can be converted to a pointer type</b>; [...]</p>\n</blockquote>\n<p>Only a <code>Null pointer constant</code> can be converted to a pointer, and a null pointer constant is either an intergral with value <code>0</code> or <code>std::nullptr_t</code>. <code>true</code> (or <code>1</code> for that matter) aren't specified, and thus they can't be converted to a pointer.</p>\n", "OwnerUserId": "3980929", "LastEditorUserId": "3980929", "LastEditDate": "2016-05-13T16:24:19.553", "Id": "37214756", "Score": "0", "CreationDate": "2016-05-13T16:13:29.423", "LastActivityDate": "2016-05-13T16:24:19.553"}});