post_cb({"35711773": {"Id": "35711773", "PostTypeId": "2", "Body": "<p>It is not undefined behavior according to the Standard.</p>\n<p>Here is the official discussion and explanation from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#232\" rel=\"nofollow\">the open-std review page</a>.</p>\n<blockquote>\n<p id=\"so_35711301_35711773_0\">We agreed that the approach in the standard seems okay: p = 0; *p; is not inherently an error. An lvalue-to-rvalue conversion would give it undefined behavior.</p>\n</blockquote>\n<p>Additionally in the standard [Section 4.10.2], it says:</p>\n<blockquote>\n<p id=\"so_35711301_35711773_1\">A prvalue of type \u201cpointer to cv T,\u201d where T is an object type, can be converted to a prvalue of type \u201cpointer\n  to cv void\u201d. The result of converting a non-null pointer value of a pointer to object type to a \u201cpointer to\n  cv void\u201d represents the address of the same byte in memory as the original pointer value. The null pointer\n  value is converted to the null pointer value of the destination type.</p>\n</blockquote>\n", "LastEditorUserId": "4975646", "LastActivityDate": "2016-02-29T23:36:50.630", "Score": "-2", "CreationDate": "2016-02-29T23:24:04.960", "ParentId": "35711301", "CommentCount": "5", "OwnerUserId": "4975646", "LastEditDate": "2016-02-29T23:36:50.630"}, "35711518": {"Id": "35711518", "PostTypeId": "2", "Body": "<p>You're reading the value of an uninitialized variable (the pointer). That is undefined behavior.</p>\n<p>Interestingly, because <code>*ptr</code> is a discarded value expression, it isn't going to undergo lvalue to rvalue conversion. So if <code>*ptr</code> was uninitialized, it would be safe.</p>\n", "LastActivityDate": "2016-02-29T23:04:02.180", "CommentCount": "2", "CreationDate": "2016-02-29T23:04:02.180", "ParentId": "35711301", "Score": "1", "OwnerUserId": "4756309"}, "bq_ids": {"n4140": {"so_35711301_35711873_1": {"length": 12, "quality": 0.8, "section_id": 5559}, "so_35711301_35711773_1": {"length": 39, "quality": 0.9512195121951219, "section_id": 40}}, "n3337": {"so_35711301_35711873_1": {"length": 12, "quality": 0.8, "section_id": 5341}, "so_35711301_35711773_1": {"length": 26, "quality": 0.6341463414634146, "section_id": 37}, "so_35711301_35711594_0": {"length": 30, "quality": 0.8333333333333334, "section_id": 5}}, "n4659": {"so_35711301_35711873_1": {"length": 12, "quality": 0.8, "section_id": 7006}, "so_35711301_35711773_1": {"length": 22, "quality": 0.5365853658536586, "section_id": 43}}}, "35711301": {"ViewCount": "267", "Body": "<p>Consider the following piece of C++ code:</p>\n<pre><code>int main() {\n    int* ptr; // Deliberately uninitialized\n    (void) *ptr;     // Dereference, do not use result\n}\n</code></pre>\n<p>Does this code result in undefined behavior? I assume that the answer is \"yes\" even though the value of <code>*ptr</code> is not actually used anywhere. Is there a particular part of the spec that guarantees this?</p>\n<p>(I apologize if this is a duplicate, but I can't seem to find anything else on the site that specifically asks this question.)</p>\n", "AcceptedAnswerId": "35711873", "Title": "Is it undefined behavior in C++ to dereference an invalid pointer but not use the result?", "CreationDate": "2016-02-29T22:48:34.703", "Id": "35711301", "CommentCount": "15", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-03-01T05:30:30.523", "Score": "2", "OwnerUserId": "501557", "Tags": "<c++><pointers><language-lawyer>", "AnswerCount": "4"}, "35711594": {"Id": "35711594", "PostTypeId": "2", "Body": "<p>According to the standard, dereferencing a non-initialised pointer is undefined behaviour. However, in real life this is rarely the case: compilers are clever enough to remove code like this since it's not actually used anywhere.. So even if dereferencing the pointer is undefined behaviour, if you don't use the result the chances are that you don't actually dereference it. I tested your code with clang++ and NO CODE has been generated. </p>\n<p>from the standard (4.1): </p>\n<blockquote>\n<p id=\"so_35711301_35711594_0\">An lvalue (3.10) of a non-function, non-array type T can be converted\n  to an rvalue. If T is an incomplete type, a program that necessitates\n  this conversion is ill-formed. If the object to which the lvalue\n  refers is not an object of type T and is not an object of a type\n  derived from T, or if the object is uninitialized, a program that\n  necessitates this conversion has undefined behavior. If T is a\n  non-class type, the type of the rvalue is the cv-unqualified version\n  of T. Otherwise, the type of the rvalue is T.</p>\n</blockquote>\n", "LastEditorUserId": "5082337", "LastActivityDate": "2016-03-01T05:30:30.523", "Score": "-1", "CreationDate": "2016-02-29T23:09:48.993", "ParentId": "35711301", "CommentCount": "4", "OwnerUserId": "5082337", "LastEditDate": "2016-03-01T05:30:30.523"}, "35711873": {"Id": "35711873", "PostTypeId": "2", "Body": "<p>Simply dereferencing a pointer that has not been allocated or is marked as <em>read-only</em> can cause a hardware exception in the <code>CPUs</code> memory management unit. So even if you don't use whatever garbage value would be returned by dereferencing a pointer that contains a random value, there is no guarantee the <code>CPU</code> would return from such an event.</p>\n<p>However, according to the <code>ISO C++11 Standard</code> a pointer that is declared uninitialized must have a <em>singular value</em>. So the value of an uninitialized pointer is not <em>undefined</em> as in it is not garbage.</p>\n<p>However the Standard states that most operations on such a <em>singular value</em> pointer are undefined with the exception of overwriting the <em>singular value</em> with a <em>non singular value</em>:</p>\n<blockquote>\n<p id=\"so_35711301_35711873_0\"><strong>24.2.1</strong> In general <strong>[</strong> iterator.requirements.general <strong>]</strong></p>\n<p id=\"so_35711301_35711873_1\"><strong>5</strong> <strong><em>[</em></strong> Example: After the declaration of an uninitialized pointer x (as with int* x;), x must always be assumed to have a singular value of a pointer. \u2014 end example <strong>]</strong></p></blockquote> Results of most expressions are undefined for singular values; the only exceptions are destroying an iterator that holds a singular value, the assignment of a non-singular value to an iterator that holds a singular value, and, for iterators that satisfy the DefaultConstructible requirements, using a value-initialized iterator as the source of a copy or move operation. <strong><em>[</em></strong> Note: This guarantee is not offered for default initialization, although the distinction only matters for types with trivial default constructors such as pointers or aggregates holding pointers. \u2014 end note <strong></strong>] In these cases the singular value is overwritten the same way as any other value. Dereferenceable values are always non-singular.\n\n", "LastEditorUserId": "3807729", "LastActivityDate": "2016-02-29T23:53:41.927", "Score": "7", "CreationDate": "2016-02-29T23:30:51.210", "ParentId": "35711301", "CommentCount": "0", "OwnerUserId": "3807729", "LastEditDate": "2016-02-29T23:53:41.927"}});