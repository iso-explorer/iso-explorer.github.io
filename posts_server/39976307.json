post_cb({"39976392": {"ParentId": "39976307", "CommentCount": "1", "Body": "<p>You've violated the <em>one definition rule</em> \u2014 your program contains <em>two</em> definitions of <code>foo&lt;float&gt;::init</code>.</p>\n<p>One definition occurs in the compilation unit <code>foo_float.cpp</code>, and the other appears in the compilation unit <code>main.cpp</code>.</p>\n<p>Violating the one definition rule means undefined behavior \u2014 in this case, what likely happens is:</p>\n<ul>\n<li>With optimizations off, the program generates an actual function call, and the linker happened to put <code>foo_float.cpp</code>'s version of the function in the executable.</li>\n<li>With optimizations on, when compiling <code>main.cpp</code> the compiler inlined the function \u2014 naturally, it would inline <code>main.cpp</code>'s version of the function.</li>\n</ul>\n", "OwnerUserId": "1084944", "PostTypeId": "2", "Id": "39976392", "Score": "3", "CreationDate": "2016-10-11T11:37:17.627", "LastActivityDate": "2016-10-11T11:37:17.627"}, "39976548": {"ParentId": "39976307", "CommentCount": "1", "Body": "<p>The language definition requires that you declare an explicit specialization before it is used:</p>\n<blockquote>\n<p id=\"so_39976307_39976548_0\">If a template, a member template or a member of a class template is\n  explicitly specialized then that specialization shall be declared\n  before the first use of that specialization that would cause an\n  implicit instantiation to take place, in every translation unit in\n  which such a use occurs; no diagnostic is required. [temp.expl.spec]/6.</p>\n</blockquote>\n<p>There is no declaration of the explicit specialization of <code>foo&lt;float&gt;::init()</code> at the point where it is called from <code>main</code>, but there is an explicit specialization in <code>foo_float.cpp</code>, so the behavior of the program is undefined.</p>\n", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "39976548", "Score": "3", "CreationDate": "2016-10-11T11:46:17.557", "LastActivityDate": "2016-10-11T11:46:17.557"}, "bq_ids": {"n4140": {"so_39976307_39976548_0": {"section_id": 268, "quality": 0.9666666666666667, "length": 29}}, "n3337": {"so_39976307_39976548_0": {"section_id": 259, "quality": 0.9666666666666667, "length": 29}}, "n4659": {"so_39976307_39976548_0": {"section_id": 275, "quality": 0.9666666666666667, "length": 29}}}, "39976307": {"CommentCount": "4", "ViewCount": "95", "PostTypeId": "1", "LastEditorUserId": "717732", "CreationDate": "2016-10-11T11:32:18.120", "LastActivityDate": "2016-10-11T11:46:17.557", "Title": "My template specialization differs debug version from release version, is this gcc bug?", "AcceptedAnswerId": "39976392", "LastEditDate": "2016-10-11T11:35:50.750", "Id": "39976307", "Score": "3", "Body": "<p>First of all, I've got a header file for a class, an specialization declaration without definition(code samples from internet)</p>\n<p>$ cat foo.h</p>\n<pre><code>template&lt;typename T&gt;\nclass foo{\npublic:\n  static void init(){\n      return;\n  }\n\n};\n\ntemplate&lt;&gt;  void foo&lt;int&gt;::init();\n</code></pre>\n<p>Then there're 2 implementation files for template specialization</p>\n<pre><code>$ cat foo_int.cpp \n#include \"foo.h\"\n#include&lt;stdio.h&gt;\ntemplate&lt;&gt;\nvoid foo&lt;int&gt;::init(){\n    printf(\"init int foo\\n\");\n}\n\n$ cat foo_float.cpp \n#include \"foo.h\"\n#include&lt;stdio.h&gt;\ntemplate&lt;&gt;\nvoid foo&lt;float&gt;::init(){\n    printf(\"init float foo\\n\");\n}\n</code></pre>\n<p>Finally I got a main file</p>\n<pre><code>$ cat main.cpp\n#include \"foo.h\"\n\nint main(){\n  foo&lt;int&gt;::init();\n  foo&lt;float&gt;::init();\n}\n</code></pre>\n<p>If I compile it without optimization and run it, it gives:</p>\n<blockquote>\n<p id=\"so_39976307_39976307_0\">g++ foo_int.cpp foo_float.cpp main.cpp &amp;&amp; a.out<br>\n  init int foo<br>\n  init float foo  </br></br></p>\n</blockquote>\n<p>If I add optimization, then the result is different:</p>\n<blockquote>\n<p id=\"so_39976307_39976307_1\">$ g++ foo_int.cpp foo_float.cpp main.cpp -O2 &amp;&amp; a.out<br>\n  init int foo</br></p>\n</blockquote>\n<p>The result is different. Some explanation from internet said this is due to some internal mechanism of \"weak symbol\" in gcc implementation, but my question:</p>\n<blockquote>\n<ol>\n<li><p id=\"so_39976307_39976307_2\">Is \"weak symbol\"/\"strong symbol\" a concept of gcc/g++, or it's part of the c/c++ language specification.</p></li>\n<li><p id=\"so_39976307_39976307_3\">If debug and release results are different, should I say this is a bug/issue of gcc/g++, in regard with \"weak symbol\" mechanism? As a developer, I wouldn't expect my debug version to behave differently from release version.</p></li>\n</ol>\n</blockquote>\n<p>I tried clang, unfortunately same error. Is this an \"acceptable\" case for C/C++ that debug/release \"should\" behave so differently?</p>\n", "Tags": "<c++><templates><symbol><specialization><weak>", "OwnerUserId": "6164172", "AnswerCount": "2"}});