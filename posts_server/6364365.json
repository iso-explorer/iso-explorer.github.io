post_cb({"6364453": {"ParentId": "6364365", "CommentCount": "1", "CreationDate": "2011-06-15T21:12:40.987", "OwnerUserId": "293791", "PostTypeId": "2", "Id": "6364453", "Score": "12", "Body": "<p>Floating point calculations are a ripe source for differences.  Depending on how the individual operations are ordered, you can get more/less rounding errors.</p>\n<p>Less than safe multi-threaded code can also have different results depending on how memory accesses are optimized, but that's essentially a bug in your code anyhow.</p>\n<p>And as you mentioned, side effects in copy constructors can vanish when optimization levels change.</p>\n", "LastActivityDate": "2011-06-15T21:12:40.987"}, "6364918": {"ParentId": "6364365", "CommentCount": "1", "CreationDate": "2011-06-15T21:59:29.553", "OwnerUserId": "164277", "PostTypeId": "2", "Id": "6364918", "Score": "2", "Body": "<p>Since copy constructor calls can be optimized away, even if they have side effects, having copy constructors with side-effects will cause unoptimized and optimized code to behave differently.</p>\n", "LastActivityDate": "2011-06-15T21:59:29.553"}, "6364508": {"ParentId": "6364365", "CommentCount": "4", "CreationDate": "2011-06-15T21:17:02.250", "OwnerUserId": "371250", "PostTypeId": "2", "Id": "6364508", "Score": "4", "Body": "<p>Anything that is Undefined Behavior according to the standard can change its behavior depending on optimization level (or moon-phase, for that matter).</p>\n", "LastActivityDate": "2011-06-15T21:17:02.250"}, "6364365": {"CommentCount": "14", "AcceptedAnswerId": "6364568", "PostTypeId": "1", "LastEditorUserId": "72178", "CreationDate": "2011-06-15T21:05:05.043", "LastActivityDate": "2013-06-24T19:43:08.797", "LastEditDate": "2013-06-24T19:43:08.797", "ViewCount": "3233", "FavoriteCount": "8", "Title": "Can different optimization levels lead to functionally different code?", "Id": "6364365", "Score": "39", "Body": "<p>I am curious about the liberties that a compiler has when optimizing. Let's limit this question to GCC and C/C++ (any version, any flavour of standard):</p>\n<p>Is it possible to write code which <em>behaves</em> differently depending on which optimization level it was compiled with?</p>\n<p>The example I have in mind is printing different bits of text in various constructors in C++ and getting a difference depending on whether copies are elided (though I've not been able to make such a thing work).</p>\n<p>Counting clock cycles is not permitted. If you have an example for a non-GCC compiler, I'd be curious, too, but I can't check it. Bonus points for an example in C. :-)</p>\n<p><em>Edit:</em> The example code should be standard compliant and not contain undefined behaviour from the outset.</p>\n<p><em>Edit 2:</em> Got some great answers already! Let me up the stakes a bit: The code must constitute a well-formed program and be standards-compliant, and it must compile to correct, deterministic programs in every optimization level. (That excludes things like race-conditions in ill-formed multithreaded code.) Also I appreciate that floating point rounding may be affected, but let's discount that.</p>\n<p>I just hit 800 reputation, so I think I shall blow 50 reputation as bounty on the first complete example to conform to (the spirit) of those conditions; 25 if it involves abusing strict aliasing. (Subject to someone showing me how to send bounty to someone else.)</p>\n", "Tags": "<c++><c><gcc><compiler-optimization>", "OwnerUserId": "596781", "AnswerCount": "10"}, "7097796": {"ParentId": "6364365", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2011-08-17T18:42:33.963", "Score": "8", "LastEditorUserId": "13005", "LastEditDate": "2011-08-18T00:30:38.997", "Id": "7097796", "OwnerUserId": "13005", "Body": "<p>OK, my flagrant play for the bounty, by providing a concrete example. I'll put together the bits from other people's answers and my comments.</p>\n<p>For the purpose of different behaviour at different optimizations levels, \"optimization level A\" shall denote <code>gcc -O0</code> (I'm using version 4.3.4, but it doesn't matter much, I think any even vaguely recent version will show the difference I'm after), and \"optimization level B\" shall denote <code>gcc -O0 -fno-elide-constructors</code>.</p>\n<p>Code is simple:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Foo {\n    ~Foo() { std::cout &lt;&lt; \"~Foo\\n\"; }\n};\n\nint main() {\n    Foo f = Foo();\n}\n</code></pre>\n<p>Output at optimization level A:</p>\n<pre><code>~Foo\n</code></pre>\n<p>Output at optimization level B:</p>\n<pre><code>~Foo\n~Foo\n</code></pre>\n<p>The code is totally legal, but the output is implementation-dependent because of copy constructor elision, and in particular it's sensitive to gcc's optimization flag that disables copy ctor elision.</p>\n<p>Note that generally speaking, \"optimization\" refers to compiler transformations that can alter behavior that is undefined, unspecified or implementation-defined, but not behavior that is defined by the standard. So any example that satisfies your criteria necessarily is a program whose output is either unspecified or implementation-defined. In this case it's unspecified by the standard whether copy ctors are elided, I just happen to be lucky that GCC reliably elides them pretty much whenever allowed, but has an option to disable that.</p>\n", "LastActivityDate": "2011-08-18T00:30:38.997"}, "6364568": {"ParentId": "6364365", "PostTypeId": "2", "CommentCount": "15", "CreationDate": "2011-06-15T21:22:24.943", "Score": "16", "LastEditorUserId": "8747", "LastEditDate": "2011-06-15T22:54:02.340", "Id": "6364568", "OwnerUserId": "8747", "Body": "<p>The portion of the C++ standard that applies is \u00a71.9 \"Program execution\". It reads, in part:</p>\n<blockquote>\n<p id=\"so_6364365_6364568_0\">conforming implementations are required to emulate (only) the observable behavior of the abstract machine as explained below. ...</p>\n<p id=\"so_6364365_6364568_1\">A conforming implementation executing a well-formed program shall produce the same observable behavior as one of the possible execution sequences of the corresponding instance of the abstract machine with the same program and the same input. ...</p>\n<p id=\"so_6364365_6364568_2\">The observable behavior of the abstract machine is its sequence of reads and writes to volatile data and calls to library I/O functions. ...</p>\n</blockquote>\n<p>So, yes, code may <em>behave</em> differently at different optimization levels, but (assuming that all levels produce a conforming compiler), but they cannot behave <em>observably differently</em>.</p>\n<p>EDIT: Allow me to correct my conclusion: Yes, code may behave differently at different optimization levels as long as each behavior is observably identical to one of the behaviors of the standard's abstract machine.</p>\n", "LastActivityDate": "2011-06-15T22:54:02.340"}, "6364611": {"ParentId": "6364365", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-06-15T21:27:25.533", "Score": "7", "LastEditorUserId": "366377", "LastEditDate": "2011-06-17T07:15:14.967", "Id": "6364611", "OwnerUserId": "366377", "Body": "<p>For C, almost all operations are strictly defined in the abstract machine and optimizations are only allowed if the observable result is exactly that of that abstract machine. Exceptions of that rule that come to mind:</p>\n<ul>\n<li>undefined behavior don't has to be\nconsistent between different compiler\nruns or executions of the faulty code</li>\n<li>floating point operations may cause\ndifferent rounding</li>\n<li>arguments to function calls can be\nevaluated in any order</li>\n<li>expressions with <code>volatile</code> qualified\ntype may or may not be evaluated just\nfor their side effects</li>\n<li>identical <code>const</code> qualified compound literals may or may be not folded into one static memory location</li>\n</ul>\n", "LastActivityDate": "2011-06-17T07:15:14.967"}, "6364377": {"ParentId": "6364365", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2011-06-15T21:06:02.377", "Score": "15", "LastEditorUserId": "476681", "LastEditDate": "2011-06-15T21:15:09.520", "Id": "6364377", "OwnerUserId": "476681", "Body": "<blockquote>\n<p id=\"so_6364365_6364377_0\">Is it possible to write code which\n  behaves differently depending on which\n  optimization level it was compiled\n  with?</p>\n</blockquote>\n<p>Only if you trigger a compiler's bug.</p>\n<p><strong>EDIT</strong></p>\n<p>This example behaves differently on gcc 4.5.2:</p>\n<pre><code>void foo(int i) {\n  foo(i+1);\n}\n\nmain() {\n  foo(0);\n}\n</code></pre>\n<p>Compiled with <code>-O0</code> creates a program crashing with a segmentation fault.<br>\nCompiled with <code>-O2</code> creates a program entering an endless loop.  </br></p>\n", "LastActivityDate": "2011-06-15T21:15:09.520"}, "bq_ids": {"n4140": {"so_6364365_6364568_1": {"section_id": 5801, "quality": 0.8947368421052632, "length": 17}, "so_6364365_6364568_0": {"section_id": 5797, "quality": 1.0, "length": 10}}, "n3337": {"so_6364365_6364568_1": {"section_id": 5574, "quality": 0.8947368421052632, "length": 17}, "so_6364365_6364568_0": {"section_id": 5570, "quality": 1.0, "length": 10}}, "n4659": {"so_6364365_6364568_1": {"section_id": 7260, "quality": 0.8947368421052632, "length": 17}, "so_6364365_6364568_0": {"section_id": 7256, "quality": 1.0, "length": 10}}}, "6388718": {"ParentId": "6364365", "CommentCount": "5", "CreationDate": "2011-06-17T16:21:57.533", "OwnerUserId": "8747", "PostTypeId": "2", "Id": "6388718", "Score": "1", "Body": "<p>This C program invokes undefined behavior, but does display different results in different optimization levels:</p>\n<pre><code>#include &lt;stdio.h&gt;\n/*\n$ for i in 0 1 2 3 4 \n    do echo -n \"$i: \" &amp;&amp; gcc -O$i x.c &amp;&amp; ./a.out \n  done\n0: 5\n1: 5\n2: 5\n3: -1\n4: -1\n*/\n\nvoid f(int a) {\n  int b;\n  printf(\"%d\\n\", (int)(&amp;a-&amp;b));\n}\nint main() {\n f(0);\n return 0;\n}\n</code></pre>\n", "LastActivityDate": "2011-06-17T16:21:57.533"}, "6364497": {"ParentId": "6364365", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2011-06-15T21:16:06.867", "Score": "2", "LastEditorUserId": "97248", "LastEditDate": "2011-06-15T21:20:53.077", "Id": "6364497", "OwnerUserId": "5987", "Body": "<p>The <code>-fstrict-aliasing</code> option can easily cause changes in behavior if you have two pointers to the same block of memory. This is supposed to be invalid but is actually quite common.</p>\n", "LastActivityDate": "2011-06-15T21:20:53.077"}, "6364419": {"ParentId": "6364365", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2011-06-15T21:09:51.943", "Score": "-1", "LastEditorUserId": "760746", "LastEditDate": "2011-06-15T21:15:07.040", "Id": "6364419", "OwnerUserId": "760746", "Body": "<p>Got some interesting example in my OS course today.\nWe analized some software mutex that could be damaged on optimization because the compiler does not know about the parallel execution.</p>\n<p>The compiler can reorder statements that do not operate on dependent data.\nAs I already statet in parallelized code this dependencie is hidden for the compiler so it could break.\nThe example I gave would lead to some hard times in debugging as the threadsafety is broken and your code behaves unpredictable because of OS-scheduling issues and concurrent access errors.</p>\n", "LastActivityDate": "2011-06-15T21:15:07.040"}});