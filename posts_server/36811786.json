post_cb({"bq_ids": {"n4140": {"so_36811786_36811858_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 5530}, "so_36811786_36811858_1": {"length": 11, "quality": 0.6875, "section_id": 5528}}, "n3337": {"so_36811786_36811858_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 5316}, "so_36811786_36811858_1": {"length": 11, "quality": 0.6875, "section_id": 5314}}, "n4659": {"so_36811786_36811858_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 6966}, "so_36811786_36811858_1": {"length": 9, "quality": 0.5625, "section_id": 6966}}}, "36811858": {"Id": "36811858", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_36811786_36811858_0\"><strong>7.6.1</strong>/3</p>\n<p id=\"so_36811786_36811858_1\"><em>[...]</em> The use of an attribute-scoped-token is conditionally-supported, with implementation-defined behavior. [ Note: <em>Each implementation should choose a distinctive name for the attribute-namespace in an attribute-scoped-token</em>. \u2014end note ]</p>\n<p id=\"so_36811786_36811858_2\"><strong>7.6.1</strong>/5</p>\n<p id=\"so_36811786_36811858_3\">For an attribute-token not specified in this International Standard, the behavior is implementation-defined.</p>\n</blockquote>\n<p>In short, answer is: check compiler documentation.</p>\n", "LastActivityDate": "2016-04-23T14:08:50.020", "CommentCount": "0", "CreationDate": "2016-04-23T14:08:50.020", "ParentId": "36811786", "Score": "2", "OwnerUserId": "3410396"}, "36811848": {"Id": "36811848", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_36811786_36811848_0\"><code>[C++14: 7.6.1/5]:</code> For an <em>attribute-token</em> not specified in this International Standard, the behavior is implementation-defined.</p>\n</blockquote>\n<p>So, you will have to consult your implementation's documentation if you want any \"guaranteed\" behaviour when unrecognised attributes are encountered.</p>\n", "LastActivityDate": "2016-04-23T14:07:53.350", "CommentCount": "0", "CreationDate": "2016-04-23T14:07:53.350", "ParentId": "36811786", "Score": "1", "OwnerUserId": "560648"}, "36811786": {"ViewCount": "85", "Body": "<p>C++11 brought support for so-called \"generalized attributes\", along with two standard ones, <code>noreturn</code> and <code>carries_dependency</code>. C++14 added <code>deprecated</code> to the table. However, I cannot find anything clear on <strong>what are implementations mandated to do by the standard upon finding an attribute that's unknown to them</strong>. Perhaps it's just that the standard doesn't say anything on the matter. Nevertheless, I would like to know.</p>\n<p>In practice, both gcc and clang have warnings regarding this situation that may be disabled. In particular, gcc gives the warning <code>'some_attribute' attribute directive ignored</code> (<code>-Wattributes</code>), while clang complains with <code>unknown attribute 'some_attribute' ignored</code> (<code>-Wunknown-attributes</code>). I haven't been able to find documentation for those options, though; the <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html\" rel=\"nofollow\">Warning Options</a> page for GCC merely mentions <code>-Wattributes</code>, while there doesn't even seem to be a similar list for Clang.</p>\n<p><strong>Why do I ask this?</strong> Well, some implementation-specific attributes are interesting. Take, for example, GCC's <a href=\"https://gcc.gnu.org/onlinedocs/gcc-4.0.0/gcc/Function-Attributes.html\" rel=\"nofollow\"><code>nonnull</code></a> attribute. We could happily annotate some functions with it:</p>\n<pre><code>[[gnu::nonnull]] void my_function ( char * a , int * b );\n</code></pre>\n<p>If the implementation knows about the attribute, everything's fine. But what can we expect if it doesn't?</p>\n<ul>\n<li><p><strong>It ignores it and this behavior is backed by the standard.</strong> We can go on and add every interesting attribute we find in online docs. In particular, this would allow mixing <code>visibility</code> and <code>dllexport</code> without as many <code>#if</code>s ~yay!</p>\n<pre><code>#if BUILDING_DLL\n#define DLLEXIMPORT dllexport\n#else\n#define DLLEXIMPORT dllimport\n#endif\n\n// even if MSVC doesn't support specifying dllexport this way, Clang does, and it can\n// compile MSVC-compatible objects\n[[gnu::visibility(\"default\"),DLLEXIMPORT]] void api_function ();\n</code></pre></li>\n<li><p><strong>It complains about it and this behavior is backed by the standard.</strong> D'oh! We'll have to roll some ugly machinery to keep unknown attributes from the hands of those pesky implementations.</p>\n<p>With just one attribute, it's easy, as empty attribute lists are allowed by the standard:</p>\n<pre><code>#if SOMETHING\n#define ATTRIBUTE_GNU_NONNULL gnu::nonnull\n#else\n#define ATTRIBUTE_GNU_NONNULL\n#endif\n\n// if ATTRIBUTE_GNU_NONNULL is defined to nothing, all that happens is that we get\n// an empty attribute list, which is 'standardly valid'\n[[ATTRIBUTE_GNU_NONNULL]] void my_function ( char * a , int * b );\n</code></pre>\n<p>However, with more than one attribute, things become more tricky:</p>\n<pre><code>#if SOMETHING\n#define ATTRIBUTE_GNU_NONNULL gnu::nonnull\n#else\n#define ATTRIBUTE_GNU_NONNULL\n#endif\n\n#if SOMETHING\n#define ATTRIBUTE_GNU_VISIBILITY( visibility_type ) gnu::visibility(#visibility_type)\n#else\n#define ATTRIBUTE_GNU_VISIBILITY( visibility_type )\n#endif\n\n// if any of the two macros is defined to nothing, it expands to [[,blah_blah]]\n// or [[blah_blah,]]  -  both of which are invalid\n[[ATTRIBUTE_GNU_NONNULL,ATTRIBUTE_GNU_VISIBILITY(default)]] void my_function\n( char * a , int * b );\n</code></pre>\n<p>The even-uglier solution that comes to mind is to have macros that combine attributes, like this:</p>\n<pre><code>#if SOMETHING\n#define ATTRIBUTES_GNU_NONNULL_AND_GNU_VISIBILITY( visibility_type ) \\\n    gnu::nonnull,gnu::visibility(#visibility_type)\n#else\n#define ATTRIBUTES_GNU_NONNULL_AND_GNU_VISIBILITY( visibility_type )\n#endif\n\n[[ATTRIBUTES_GNU_NONNULL_AND_GNU_VISIBILITY(default)]] void my_function\n( char * a , int * b );\n</code></pre>\n<p>But I would be shot in the head for this <code>:)</code>.</p></li>\n</ul>\n<p>Thus, if the standard mandated that implementations ignore unknown attributes, I could pick every relevant attribute I found in online docs without fear and without ugly solutions \u2014 hence my interest.</p>\n", "AcceptedAnswerId": "36811848", "Title": "What does the standard say implementations should do upon finding unknown attributes?", "CreationDate": "2016-04-23T14:02:49.977", "Id": "36811786", "CommentCount": "6", "PostTypeId": "1", "LastActivityDate": "2016-04-23T14:08:50.020", "Score": "0", "OwnerUserId": "2207421", "Tags": "<c++><c++14>", "AnswerCount": "2"}});