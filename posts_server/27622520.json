post_cb({"27623698": {"ParentId": "27622520", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>The constructor with the <code>const</code> only promises not to change the parameter it receives. That is, it promises that the following code will write <code>String</code>:</p>\n<pre><code>char mystring[] = \"String\";\nMarray n(mystring);\nstd::cout &lt;&lt; mystring;\n</code></pre>\n<p>However, your class <em>wants</em> to provide the service of changing its contents <em>even when passed an immutable string</em> - so it <em>must</em> copy the string into another storage, which is mutable.</p>\n<p>If you want to have the effect you described, you can make an immutable object:</p>\n<pre><code>char mystring[] = \"String\";\nconst Marray n(mystring);\nn[3]='d'; // compilation error\n</code></pre>\n<hr>\n<p>Update: As noted by hvd in a comment, to make the compiler issue an error, you will need to fix the declaration of <code>operator[]</code>:</p>\n<pre><code>char&amp; Marray::operator[] (int i) { return text[i];} // non-const version\nconst char&amp; Marray::operator[] (int i) const { return text[i];} // const version\n</code></pre>\n<p>or (better)</p>\n<pre><code>char&amp; Marray::operator[] (int i) { return text[i];} // non-const version\nchar Marray::operator[] (int i) const { return text[i];} // const version\n</code></pre>\n<p>(see e.g. <a href=\"https://stackoverflow.com/a/19237455/509868\">this answer</a> to find out why you need 2 versions of the same operator).</p>\n</hr>", "OwnerUserId": "509868", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:26:07.690", "Id": "27623698", "Score": "1", "CreationDate": "2014-12-23T15:52:27.810", "LastActivityDate": "2014-12-23T16:18:45.647"}, "27623121": {"ParentId": "27622520", "CommentCount": "0", "Body": "<p>First off, according to 8.5.3 [dcl.fct] paragaph 5 the function argument types are adjusted to be pointer types:</p>\n<blockquote>\n<p id=\"so_27622520_27623121_0\">... After determining the type of each parameter, any parameter of type \u201carray of T\u201d or \u201cfunction returning T\u201d is adjusted to be \u201cpointer to T\u201d or \u201cpointer to function returning T,\u201d respectively.</p>\n</blockquote>\n<p>That is, the question becomes \"What's the difference between passing <code>T*</code> and <code>T const*</code>?\" and the obvious answer is, the <code>const</code>ness of the objects pointed to.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "27623121", "Score": "2", "CreationDate": "2014-12-23T15:15:09.530", "LastActivityDate": "2014-12-23T15:15:09.530"}, "27622568": {"ParentId": "27622520", "PostTypeId": "2", "CommentCount": "17", "Body": "<blockquote>\n<p id=\"so_27622520_27622568_0\">I was reading about difference between <code>const char*</code> and <code>char*</code>. Is it the same with <code>char[]</code> and <code>const char []</code>?</p>\n</blockquote>\n<p>For most practical purposes, the answer is \"yes\". Although generally <code>char const*</code> and <code>char const[]</code> are two different types, one can become the other based on the context. In this specific context (a declaration of a function parameter) they do mean the same thing.</p>\n<blockquote>\n<p id=\"so_27622520_27622568_1\">So I was expecting the same with <code>const char []</code>, but the string is mutable</p>\n</blockquote>\n<p>No, the C string passed into the function remains constant due to the <code>const</code> qualifier (<a href=\"http://ideone.com/LyEMBk\" rel=\"nofollow\">demo</a>). An attempt to modify <code>const char MyString[]</code> inside <code>Array</code> would produce a compile-time error:</p>\n<blockquote>\n<p id=\"so_27622520_27622568_2\">error: assignment of read-only location \u2018* s\u2019</p>\n</blockquote>\n", "OwnerUserId": "335858", "LastEditorUserId": "335858", "LastEditDate": "2014-12-23T14:58:13.733", "Id": "27622568", "Score": "3", "CreationDate": "2014-12-23T14:42:14.100", "LastActivityDate": "2014-12-23T14:58:13.733"}, "27622520": {"CommentCount": "6", "ViewCount": "273", "PostTypeId": "1", "LastEditorUserId": "509868", "CreationDate": "2014-12-23T14:39:36.313", "LastActivityDate": "2014-12-23T16:18:45.647", "Title": "Difference between const char[] and char[]", "FavoriteCount": "0", "LastEditDate": "2014-12-23T15:40:41.990", "Id": "27622520", "Score": "2", "Body": "<pre><code>Marray(char MyString [])\nMarray(const char MyString [])\n</code></pre>\n<p>What is the difference between these two lines? I was reading about difference between <code>const char*</code> and <code>char*</code>. Is it the same with <code>char[]</code> and <code>const char []</code>?\nI am confused, since in both cases, when I overload operator [], change of the string literal is possible. <strong><code>const char*</code> is a mutable pointer to an immutable character/string.</strong> -- So I was expecting the same with <code>const char []</code>, but the string is mutable... </p>\n<p>more code:</p>\n<p>constructor:</p>\n<pre><code>Marray::Marray(const char MyString []){\n    length = 0;\n\n    while(MyString[length]!=NULL){  \n        length ++;\n    }\n\n    text= new char [length+1];\n\n    int i;\n    for (i=0; i&lt;length; i++)\n        *(text+i)=MyString[i];\n    text[length]=NULL;\n}\n\nchar &amp; Marray::operator[] (int i) const { return text[i];}\n\nint main () {\n\n    Marray n(\"String\");\n\n    n[3]='d';\n\n    n.getMarray();\n\n    system(\"pause\");\n    return 0;\n}\n</code></pre>\n<p>And this is what I got after running:</p>\n<blockquote>\n<p id=\"so_27622520_27622520_0\">Strdng</p>\n</blockquote>\n<p>So, the string is changed, even though there is <code>const char[]</code>.</p>\n", "Tags": "<c++><arrays><string><const>", "OwnerUserId": "4357575", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_27622520_27623121_0": {"section_id": 3241, "quality": 1.0, "length": 16}}, "n3337": {"so_27622520_27623121_0": {"section_id": 3114, "quality": 1.0, "length": 16}}, "n4659": {"so_27622520_27623121_0": {"section_id": 3997, "quality": 0.75, "length": 12}}}});