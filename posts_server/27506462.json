post_cb({"bq_ids": {"n4140": {"so_27506462_27506551_3": {"length": 23, "quality": 0.92, "section_id": 5921}}, "n3337": {"so_27506462_27506551_3": {"length": 23, "quality": 0.92, "section_id": 5693}}, "n4659": {"so_27506462_27506551_3": {"length": 23, "quality": 0.92, "section_id": 7395}}}, "27506551": {"Id": "27506551", "PostTypeId": "2", "Body": "<p>Yes, this is <code>bitfield</code>, indeed.</p>\n<p><del>Well, i'm not very much sure about <code>c++</code>, but</del> In <code>c99</code> standard, as per  chapter 6.7.2.1 (10):</p>\n<blockquote>\n<p id=\"so_27506462_27506551_0\">An implementation may allocate any addressable storage unit large enough to hold a bit-field. If enough space remains, a bit-field that immediately follows another bit-field in a structure shall be packed into adjacent bits of the same unit. If insufficient space remains, whether a bit-field that does not fit is put into the next bits or overlaps adjacent units is implementation-defined. The order of allocation of bit-fields within a unit (high-order to low-order or low-order to high-order) is implementation-defined. The alignment of the addressable storage unit is unspecified.</p>\n</blockquote>\n<p>That makes your structure size (1 bit + 1 bit + 14 bits) = 16 bits = 2 bytes.</p>\n<p>Note: No structure padding is considered here.</p>\n<hr>\n<p>Edit:</p>\n<p>As per <code>C++14</code> standard, chapter \u00a79.7, </p>\n<blockquote>\n<p id=\"so_27506462_27506551_1\">A member-declarator of the form</p>\n<p id=\"so_27506462_27506551_2\">identifier<sub>opt</sub> attribute-specifier-seq<sub>opt</sub>: constant-expression<br/></p>\n<p id=\"so_27506462_27506551_3\">specifies a bit-field; its length is set off from the bit-field name by a colon. [...] Allocation of bit-fields within a class object is\n  implementation-defined. Alignment of bit-fields is implementation-defined. Bit-fields are packed into some addressable allocation unit.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "2173917", "LastActivityDate": "2015-07-29T20:36:44.803", "Score": "5", "CreationDate": "2014-12-16T14:09:04.280", "ParentId": "27506462", "CommentCount": "2", "OwnerUserId": "2173917", "LastEditDate": "2015-07-29T20:36:44.803"}, "27506462": {"ViewCount": "231", "Body": "<p>I was surfing in one of our organisational data documents and I came across the following piece of code. </p>\n<pre><code>struct A {\n unsigned short int i:1;\n unsigned short int j:1;\n unsigned short int k:14;\n};\n\n\nint main(){\n A aa;\n int n = sizeof(aa);\n cout &lt;&lt; n;\n}\n</code></pre>\n<p>Initially I thought the size will be 6 bytes as the size of the unsigned short int is 2 bytes. but the output of the above code was 2 bytes(On visual studio 2008).</p>\n<p>Is there a slight possibility that the <code>i:1</code>, <code>j:1</code> and <code>k:14</code> makes it a bit field or something? Its just a guess and I am not very sure about it. Can somebody please help me in this?</p>\n", "AcceptedAnswerId": "27506551", "Title": "Size of a structure having unsigned short ints", "CreationDate": "2014-12-16T14:05:06.310", "Id": "27506462", "CommentCount": "3", "LastEditDate": "2015-07-29T20:36:53.637", "PostTypeId": "1", "LastEditorUserId": "2173917", "LastActivityDate": "2015-07-29T20:36:53.637", "Score": "-4", "OwnerUserId": "2436493", "Tags": "<c++><c><bit-fields>", "AnswerCount": "1"}});