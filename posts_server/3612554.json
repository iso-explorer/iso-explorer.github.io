post_cb({"3612696": {"Id": "3612696", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_3612554_3612696_0\">a[i] = 10;<br>\n  i[a] = 10;<br>\n  because a[i] is a postfix expression that is *(a+i) or *(i+a) because commutative property of addition.</br></br></p>\n</blockquote>\n<p>Yes. But <code>a[i] == i[a] == *(a+i) == *(i+a)</code> is because the notation <code>a[i]</code> in C is a <a href=\"http://en.wikipedia.org/wiki/Syntactic_sugar\" rel=\"nofollow noreferrer\">syntactic sugar</a> for the latter pointer arithmetic. Keyword here \"in C\". C++ in large tries to part ways from the pointer arithmetic. Thus the <code>a[i]</code> as a syntactic sugar is only supported on the <a href=\"http://en.wikipedia.org/wiki/Plain_old_data_structure\" rel=\"nofollow noreferrer\">POD</a> for backward compatibility with the C. But that does not work on any C++ objects since the operations <code>[]</code> has clear semantic specified and it doesn't allow the C-like syntax tricks.</p>\n<p>In the end, do not do it. The trick is an obscure remnant of the older times and doesn't have a single good reason to be reincarnated.</p>\n", "LastEditorUserId": "360695", "LastActivityDate": "2010-08-31T21:12:55.790", "Score": "2", "CreationDate": "2010-08-31T19:55:25.210", "ParentId": "3612554", "CommentCount": "8", "LastEditDate": "2010-08-31T21:12:55.790", "OwnerUserId": "360695"}, "3613213": {"Id": "3613213", "PostTypeId": "2", "Body": "<p>With C++, nothing is <em>impossible</em>.  It is however, a terrible terrible idea.  Don't do this.</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\nvoid *aligned_malloc( size_t bytes, size_t alignment ) {\n    void *p = malloc( bytes + alignment ), *pa = reinterpret_cast&lt;void*&gt;( reinterpret_cast&lt;size_t&gt;(p) + alignment &amp;- alignment );\n    reinterpret_cast&lt;void**&gt;(pa)[-1] = p;\n    return pa;\n}\n\nvoid aligned_free( void *pa ) {\n    void *p = reinterpret_cast&lt;void**&gt;(pa)[-1];\n    free( p );\n}\n\nstruct SupportReverseIndexer\n{\n    class IndexerReversal\n    {\n        static const size_t alignment;\n        friend struct SupportReverseIndexer;\n        friend class std::auto_ptr&lt;IndexerReversal&gt;;\n        struct SupportReverseIndexer* const m_parent;\n        IndexerReversal(struct SupportReverseIndexer* parent) : m_parent(parent) {}\n        void* operator new(size_t bytes) { return aligned_malloc(bytes, alignment); }\n        void operator delete(void* p) { aligned_free(p); }\n        static struct SupportReverseIndexer* getParent(IndexerReversal* pThis)\n        {\n            size_t iThis = reinterpret_cast&lt;size_t&gt;(pThis);\n            iThis += alignment &gt;&gt; 1;\n            iThis &amp;= ~(alignment  - 1);\n            return reinterpret_cast&lt;IndexerReversal*&gt;(iThis)-&gt;m_parent;\n        }\n    public:\n        operator size_t() { struct SupportReverseIndexer* const parent = getParent(this); return parent-&gt;indexer(this-parent-&gt;ir.get()); }\n    };\n\n    SupportReverseIndexer() : ir(new IndexerReversal(this)) {}\n\n    operator IndexerReversal*() { return ir.get(); }\n\nprivate:\n    std::auto_ptr&lt;IndexerReversal&gt; ir;\n    size_t indexer(size_t index) { printf(\"Custom operator[] called, index = %i\\n\", index); return index; }\n};\n\nconst size_t SupportReverseIndexer::IndexerReversal::alignment = 0x10000 * sizeof(SupportReverseIndexer::IndexerReversal);\n\nint main(void)\n{\n    SupportReverseIndexer sri;\n    int a = sri[2];\n    a = 3[sri];\n    a = (-5)[sri];\n\n    return 0;\n}\n</code></pre>\n<p>No, really, DON'T DO THIS!!!!!</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2010-08-31T21:52:02.620", "Score": "3", "CreationDate": "2010-08-31T21:02:36.810", "ParentId": "3612554", "CommentCount": "6", "LastEditDate": "2010-08-31T21:52:02.620", "OwnerUserId": "103167"}, "3612591": {"Id": "3612591", "PostTypeId": "2", "Body": "<p>It is impossible because \"<code>operator[]</code> shall be a non-static member function with exactly one parameter\" (standard \u00a713.5.5/1), so you cannot define it such that the first argument is of native scalar type.</p>\n<p>(Furthermore, a nonstatic operator overload call is interpreted as a member call, so the first operand cannot  be implicitly converted, unlike a free function overload. This is one reason why free function overloads are preferred when possible.)</p>\n<p>For better or worse, <code>index[ object ]</code> is a way to ensure that no <code>operator[]</code> overload gets called.</p>\n<hr>\n<h1>However.</h1>\n<p>\"The expression <code>E1[E2]</code> is identical (by definition) to <code>*((E1)+(E2))</code>\" (\u00a75.2.1) and <code>operator+</code> <em>can</em> be overloaded so long as one side is not native type. This leaves two <s>options</s> vulnerabilities: the \"array\" must be a class, or the \"index\" must be a class or <code>enum</code>.</p>\n<p>You would then have to define a proxy type to hold the result of \"addition,\" which defines an <code>operator*</code> overload. GCC does not support this, however. I'll look deeper into other platforms and references.</p>\n<p>Edit: Ah, \u00a713.6/13 overrides 5.2.1 and declares that, for the sake of interpreting an expression involving class or enumeration type, there are functions <code>T&amp;   operator[](std::ptrdiff_t, T*);</code> and <code>T&amp;    operator[](T*, std::ptrdiff_t);</code>. So that's that.</p>\n</hr>", "LastEditorUserId": "153285", "LastActivityDate": "2010-08-31T21:04:35.213", "Score": "15", "CreationDate": "2010-08-31T19:42:35.083", "ParentId": "3612554", "CommentCount": "8", "LastEditDate": "2010-08-31T21:04:35.213", "OwnerUserId": "153285"}, "3612966": {"Id": "3612966", "PostTypeId": "2", "Body": "<p>It is completely impossible to do. Potatoswatter <a href=\"https://stackoverflow.com/questions/3612554/commutative-property-ai-ia/3612591#3612591\">correctly points out</a> you couldn't possibly define any operator such as <code>operator[](int, T)</code>, so overloading for an integer on the left is impossible.</p>\n<p>But consider that this works:</p>\n<pre><code>struct foo\n{\n    operator const foo*() const\n    {\n        return this;\n    }\n};\n\nint main()\n{\n    foo f;\n    5[f]; // UB\n}\n</code></pre>\n<p>Is there a way to utilize this? No:</p>\n<blockquote>\n<p id=\"so_3612554_3612966_0\">5.2.1 Subscripting<br>\n  A postfix expression followed by an expression in square brackets is a postfix expression. One of the expressions shall have the type \u201cpointer to T\u201d and the other shall have enumeration or integral type. The result is an lvalue of type \u201cT.\u201d The type \u201cT\u201d shall be a completely-defined object type.56) The expression <code>E1[E2]</code> is identical (by definition) to <code>*((E1)+(E2))</code>.</br></p>\n</blockquote>\n<p>With <code>E1</code> being an integral type, <code>E2</code> <em>must</em> be a pointer type. So we can't inject user-behavior there.</p>\n<p>The only thing left is <code>+</code> and <code>*</code>. We can't change <code>operator+</code> for an integral type and a pointer, because that's defined by the language. The result of <code>E1 + E2</code> is going to be a pointer, and we can't define <code>operator*</code> for a pointer either.</p>\n<p>Therefore, injecting user-defined behavior is impossible.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-08-31T20:29:27.203", "Score": "2", "CreationDate": "2010-08-31T20:29:27.203", "ParentId": "3612554", "CommentCount": "3", "LastEditDate": "2017-05-23T11:47:48.067", "OwnerUserId": "87234"}, "bq_ids": {"n4140": {"so_3612554_3612696_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 7230}, "so_3612554_3612966_0": {"length": 28, "quality": 0.8, "section_id": 5986}}, "n3337": {"so_3612554_3612696_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 6974}, "so_3612554_3612966_0": {"length": 29, "quality": 0.8285714285714286, "section_id": 5754}}, "n4659": {"so_3612554_3612966_0": {"length": 26, "quality": 0.7428571428571429, "section_id": 7486}}}, "3612554": {"ViewCount": "1187", "Body": "<p>For a built in type integer array say</p>\n<pre><code>int a[10];\nint i = 2;\na[i] = 10;\n</code></pre>\n<p>alternatively</p>\n<pre><code>i[a] = 10;\n</code></pre>\n<p>because </p>\n<p><code>a[i]</code> is a postfix expression that is <code>*(a+i)</code> or <code>*(i+a)</code> because commutative property of addition.</p>\n<p>I want to achieve that for a userdefined type say</p>\n<pre><code>class Dummy\n{\n//\n};\n</code></pre>\n<p>Is it possible?\nIf yes then how?\nIf no then why?</p>\n<p>EDIT :-\nI know it is ugly but following code compiles :-\ng++ -dumpversion\n4.3.3</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include&lt;iostream&gt;\n#include &lt;string.h&gt;\n#include &lt;malloc.h&gt;\nusing namespace std;\n\nint main()\n{\n    string ArrayS[10];\n    2[ArrayS] = \"ADASD\" ;\n    cout &lt;&lt;  2[ArrayS] &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "3612591", "Title": "Commutative property a[i] == i[a]", "CreationDate": "2010-08-31T19:38:06.757", "Id": "3612554", "CommentCount": "7", "LastEditDate": "2010-09-09T15:20:02.493", "PostTypeId": "1", "LastEditorUserId": "434946", "LastActivityDate": "2010-09-09T15:20:02.493", "Score": "3", "OwnerUserId": "434946", "Tags": "<c++>", "AnswerCount": "6"}, "3612619": {"Id": "3612619", "PostTypeId": "2", "Body": "<p>Any Dummy that was declared and used as an array will work the same way, if Dummy can be implicitly cast to an integer.</p>\n", "LastActivityDate": "2010-08-31T19:45:16.873", "Score": "0", "CreationDate": "2010-08-31T19:45:16.873", "ParentId": "3612554", "CommentCount": "0", "OwnerUserId": "237091"}, "3612609": {"Id": "3612609", "PostTypeId": "2", "Body": "<p>You will need to define the <code>Dummy::operator[](const Dummy&amp; ref)</code> to exhibit the desired property.  For instance:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass dummy\n{\npublic:\n    int operator[](const dummy&amp; ref) { return 0; }\n};\n\nint main(int argc, char *argv[])\n{\n    dummy d1, d2;\n\n    std::cout &lt;&lt; (d1[d2] == d2[d1] ? \"Yes\" : \"No\");\n}\n</code></pre>\n<p>Of course this is probably not exactly what you're looking for, but the tricky bit will be to replace the <code>return 0;</code> and possibly the return type with something that you have to define and that satisfies your intent.</p>\n<p>Why exactly would you want this?  Is it just a mental exercise?</p>\n", "LastEditorUserId": "248123", "LastActivityDate": "2010-08-31T20:19:51.750", "Score": "0", "CreationDate": "2010-08-31T19:44:41.157", "ParentId": "3612554", "CommentCount": "3", "LastEditDate": "2010-08-31T20:19:51.750", "OwnerUserId": "248123"}});