post_cb({"bq_ids": {"n4140": {"so_48499000_48499578_0": {"length": 101, "quality": 0.8859649122807017, "section_id": 5812}, "so_48499000_48499578_2": {"length": 13, "quality": 0.7222222222222222, "section_id": 2690}}, "n3337": {"so_48499000_48499578_0": {"length": 101, "quality": 0.8859649122807017, "section_id": 5585}, "so_48499000_48499578_2": {"length": 13, "quality": 0.7222222222222222, "section_id": 2652}}, "n4659": {"so_48499000_48499578_0": {"length": 102, "quality": 0.8947368421052632, "section_id": 7275}, "so_48499000_48499578_2": {"length": 13, "quality": 0.7222222222222222, "section_id": 3430}, "so_48499000_48499578_1": {"length": 20, "quality": 0.8333333333333334, "section_id": 7307}}}, "48499000": {"ViewCount": "147", "Body": "<p>C++11 has keyword thread_local. I wanted to know whether this keyword works as expected only with threads created using standard library (std::thread) or it is guaranteed to work with other threading libraries e.g. Windows CreateThread function or Unix pthread.</p>\n<p><a href=\"https://docs.microsoft.com/en-us/cpp/cpp/thread\" rel=\"nofollow noreferrer\">Microsoft documentation for visual studio</a> states that:</p>\n<blockquote>\n<p id=\"so_48499000_48499000_0\">The thread extended storage-class modifier is used to declare a thread local variable. For the portable equivalent in C++11 and later, use the thread_local storage class specifier for portable code. On Windows thread_local is implemented with __declspec(thread).</p>\n</blockquote>\n<p>So thread_local works as expected in MS Visual Studio. I still wonder if the situation is true for other compilers and platforms.</p>\n", "Title": "C++ thread_local with different threading library than std::thread", "CreationDate": "2018-01-29T10:24:26.573", "LastActivityDate": "2018-01-29T11:01:27.607", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-01-29T11:01:27.607", "LastEditorUserId": "1169741", "Id": "48499000", "Score": "7", "OwnerUserId": "1169741", "Tags": "<c++><multithreading>", "AnswerCount": "1"}, "48499578": {"Id": "48499578", "PostTypeId": "2", "Body": "<p>The C++ standard defines a thread as follows at <a href=\"https://timsong-cpp.github.io/cppwp/n4659/intro.multithread#1\" rel=\"nofollow noreferrer\">[intro.multithread]/1</a>:</p>\n<blockquote>\n<p id=\"so_48499000_48499578_0\">A <em>thread of execution</em> (also known as a <em>thread</em>) is a single flow of\n  control within a program, including the initial invocation of a\n  specific top-level function, and recursively including every function\n  invocation subsequently executed by the thread. [\u2009Note: When one\n  thread creates another, the initial call to the top-level function of\n  the new thread is executed by the new thread, not by the creating\n  thread. \u2009\u2014\u2009end note\u2009] Every thread in a program can potentially access\n  every object and function in a program. Under a hosted\n  implementation, a C++ program can have more than one thread running\n  concurrently. The execution of each thread proceeds as defined by the\n  remainder of this International Standard. The execution of the entire\n  program consists of an execution of all of its threads. [\u2009Note:\n  Usually the execution can be viewed as an interleaving of all its\n  threads. However, some kinds of atomic operations, for example, allow\n  executions inconsistent with a simple interleaving, as described\n  below. \u2009\u2014\u2009end note\u2009] Under a freestanding implementation, it is\n  implementation-defined whether a program can have more than one thread\n  of execution.</p>\n</blockquote>\n<p>Note how the above is not at all limited to threads created by <code>std::thread</code>. Moreover, the standard even acknowledges the existence of <strong>at least one</strong> thread of execution that is not necessarily created by <code>std::thread</code>, over at <a href=\"https://timsong-cpp.github.io/cppwp/n4659/intro.progress#8\" rel=\"nofollow noreferrer\">[intro.progress]/8</a>:</p>\n<blockquote>\n<p id=\"so_48499000_48499578_1\">It is implementation-defined whether the <strong>implementation-created thread\n  of execution</strong> that executes main and the threads of execution created\n  by std\u200b::\u200bthread provide concurrent forward progress guarantees.\n  [\u2009Note: General-purpose implementations are encouraged to provide\n  these guarantees. \u2009\u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>Furthermore, while the following is a note, and cannot be considered normative, it's still encouraging to read <a href=\"https://timsong-cpp.github.io/cppwp/n4659/thread.threads#1\" rel=\"nofollow noreferrer\">[thread.threads]/1</a>:</p>\n<blockquote>\n<p id=\"so_48499000_48499578_2\">[thread.threads] describes components that can be used to create and\n  manage threads. [\u2009Note: <strong>These threads are intended to map one-to-one\n  with operating system threads.</strong> \u2009\u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>Which to me all indicates that any <code>thread_local</code> storage can be used in any \"thread of execution\" that conforms to the above definition, regardless of whether it's created by <code>std::thread</code> or some implementation defined manner. I wouldn't expect a sane hosted implementation to behave otherwise.</p>\n", "LastActivityDate": "2018-01-29T10:56:12.677", "CommentCount": "6", "CreationDate": "2018-01-29T10:56:12.677", "ParentId": "48499000", "Score": "4", "OwnerUserId": "817643"}});