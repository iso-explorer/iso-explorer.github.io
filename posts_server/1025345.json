post_cb({"1025345": {"ViewCount": "20302", "Body": "<p>Just want to confirm in Windows environment, VSTS 2008 + C++ project, we could only apply extern C to function level, not be able to apply to class level (so that all member functions from the class use C language name mangling)? I have tried several ways, but always compile error.</p>\n<p>thanks in advance,\nGeorge</p>\n", "Title": "extern C can not be used at class level?", "CreationDate": "2009-06-22T03:11:45.587", "LastActivityDate": "2009-12-23T00:58:18.570", "CommentCount": "7", "FavoriteCount": "5", "PostTypeId": "1", "Id": "1025345", "Score": "8", "OwnerUserId": "63235", "Tags": "<c++><c><visual-studio-2008><extern>", "AnswerCount": "5"}, "1025359": {"Id": "1025359", "PostTypeId": "2", "Body": "<p>Ummm... <code>extern \"C\"</code> forces C-style linkage. It cannot be used with classes AFAIK.</p>\n", "LastActivityDate": "2009-06-22T03:19:02.780", "CommentCount": "4", "CreationDate": "2009-06-22T03:19:02.780", "ParentId": "1025345", "Score": "2", "OwnerUserId": "41747"}, "bq_ids": {"n4140": {"so_1025345_1950150_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 5888}, "so_1025345_1950150_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 5520}}, "n3337": {"so_1025345_1950150_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 5659}, "so_1025345_1950150_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 5306}}, "n4659": {"so_1025345_1950150_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 7371}, "so_1025345_1950150_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 6955}}}, "1025376": {"Id": "1025376", "PostTypeId": "2", "Body": "<p>extern \"c\" uses c-style linking; that is, the raw function name is what exposed from the library. Because it is just a raw function name, none of the C++-only features will work with it, including methods or extern data members in namespaces, classes, structs or unions.</p>\n<p><strong>Clarifying</strong>: Structs and unions are in C, but have no member functions, so their member functions in C++ cannot be exported in a c-style (and the struct and union definitions need not be exported, since it is already in the header)</p>\n", "LastEditorUserId": "54858", "LastActivityDate": "2009-06-22T03:45:32.477", "Score": "4", "CreationDate": "2009-06-22T03:32:55.187", "ParentId": "1025345", "CommentCount": "2", "OwnerUserId": "54858", "LastEditDate": "2009-06-22T03:45:32.477"}, "1950150": {"Id": "1950150", "PostTypeId": "2", "Body": "<p>You can sort of apply <code>extern \"C\"</code> to a member function via a very convoluted (but entirely legal) hack:</p>\n<pre><code>extern \"C\" typedef int bar_t(int x);\n\nstruct foo {\n     bar_t bar; // yes, this declares a nonstatic member function!\n};\n\nint foo::bar(int x) { return x; } // definition\n</code></pre>\n<p>This is possible according to ISO C++03 9.3[class.mfct]/9:</p>\n<blockquote>\n<p id=\"so_1025345_1950150_0\">a member function can be declared (but not defined) using a typedef for a function type. The resulting member function has exactly the same type as it would have if the function declarator were provided explicitly, see 8.3.5.</p>\n</blockquote>\n<p>However, this doesn't really buy you anything, because of ISO C++03 7.5[dcl.link]/4:</p>\n<blockquote>\n<p id=\"so_1025345_1950150_1\">A C language linkage is ignored for the names of class members and the member function\n  type of class member functions.</p>\n</blockquote>\n", "LastActivityDate": "2009-12-23T00:58:18.570", "CommentCount": "1", "CreationDate": "2009-12-23T00:58:18.570", "ParentId": "1025345", "Score": "9", "OwnerUserId": "111335"}, "1025378": {"Id": "1025378", "PostTypeId": "2", "Body": "<p>I'm afraid not. But if you want to pass an object of C++ to C functions, you may refer to this link: <a href=\"http://www.parashift.com/c++-faq-lite/mixing-c-and-cpp.html#faq-32.8\" rel=\"nofollow noreferrer\">http://www.parashift.com/c++-faq-lite/mixing-c-and-cpp.html#faq-32.8</a></p>\n", "LastActivityDate": "2009-06-22T03:33:31.177", "CommentCount": "7", "CreationDate": "2009-06-22T03:33:31.177", "ParentId": "1025345", "Score": "4", "OwnerUserId": "111896"}, "1025418": {"Id": "1025418", "PostTypeId": "2", "Body": "<p>Looking at a comment you placed on a previous answer (\"[M]y question is just whether we could apply <code>extern C</code> at class level so that all functions in the class automatically has C style name mangling?\", the answer is '<code>extern \"C\"</code> doesn't quite work that way.'</p>\n<p>Syntactically, <code>extern \"C\"</code> can be applied to either a single statement of a curly-delimited block:</p>\n<pre><code>extern \"C\" int my_foo(int i)\n{\n    ...\n}\n\nextern \"C\" {\n    int my_bar(int i)\n    {\n        ...\n    }\n\n    int my_baz(int i)\n    {\n        ...\n    }\n}\n</code></pre>\n<p>It's common to use <code>extern \"C\"</code> with the appropriate <code>#ifdef __cplusplus</code> guards on entire C headers.</p>\n<p>Semantically, the actual effect of applying <code>extern \"C\"</code> will only apply to \"normal\" (i.e., non-class) functions and pointers to functions.  Of course you cannot apply it to a C++ template.  Nor can you apply it to class methods (because a class method needs to know which object it was called on, and C-style linkage does not have any way to pass that information in to the function).</p>\n<p>It <em>is</em> possible to apply <code>extern \"C\"</code> on functions that exist in a namespace, but the namespace information will simply disappear when used via C.</p>\n<hr>\n<h3>Update</h3>\n<p>If you already have a class (we'll use a <a href=\"http://www.fnal.gov/docs/working-groups/fpcltf/Pkg/ISOcxx/doc/POD.html\" rel=\"nofollow noreferrer\">POD class</a> for simplicity), and you want to make it usable from C, you'll need to apply <code>extern \"C\"</code> to a function callable in C.  Unfortunately this gets ugly even in simple cases:</p>\n<pre><code>// in the header file\n#ifdef __cplusplus\nnamespace X {\n#endif\n    struct A\n    {\n        int x;\n#ifdef __cplusplus\n        A() : x(5) { }\n        int foo()\n        {\n             return x += 5;\n        }\n#endif\n    };\n#ifdef __cplusplus\n    extern \"C\" {\n#endif\n        int A_foo(struct A a);\n        struct A A_create();\n#ifdef __cplusplus\n    }\n}\n#endif\n\n\n// in the .cc file\n#include \"try.h\"\n\nnamespace X {\n    extern \"C\" {\n        int A_foo(A* a)\n        {\n            return a.foo();\n        }\n\n        A A_create()\n        {\n            return A();\n        }\n    }\n}\n\n// in the .c file\n#include &lt;stdio.h&gt;\n#include \"try.h\"\n\nint main()\n{\n    struct A a = A_create();\n    printf(\"%d\", A_foo(a));\n}\n</code></pre>\n<p>Using gcc you would compile this as follows:</p>\n<ul>\n<li>the C++ file: <code>g++ try.cc -c -o try.o</code></li>\n<li>the C file : <code>gcc try.c try.o</code></li>\n</ul>\n<p>There are a few important points:</p>\n<ul>\n<li>If your C++ file calls into the STL behind the scenes, or calls <code>new</code> or <code>delete</code> (or <code>new[]</code> or <code>delete[]</code>) you will need to link the final program to the C++ runtime library (the command line switch for this in gcc is <code>-lstdc++</code>.</li>\n<li>You're probably going to want to pass identical optimization flags when compiling both the C and C++ code (optimization can affect the size of the objects, and if the size doesn't match you can get into a lot of trouble).  Ditto for multithreading.</li>\n<li>You can use exceptions all you want in the C++ code, but <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/Code-Gen-Options.html#index-fexceptions-1951\" rel=\"nofollow noreferrer\">once they cross C code all bets are off</a>.</li>\n<li>If you want something more complex you'll probably want to look at the PIMPL pattern.</li>\n<li>When a struct falls out of scope in C code the C++ destructor is <strong>not</strong> called (some compilers may promise to do so, but it's not standard).  If you need to do any clean up on these objects you'll need to call an extern \"C\" function that calls the destructor.</li>\n</ul>\n<p>To call the destructor explicitly:</p>\n<pre><code>extern \"C\" void A_destroy(struct A a)\n{\n    a.~A();\n}\n</code></pre>\n</hr>", "LastEditorUserId": "10593", "LastActivityDate": "2009-12-23T00:06:27.423", "Score": "3", "CreationDate": "2009-06-22T04:02:53.367", "ParentId": "1025345", "CommentCount": "2", "OwnerUserId": "10593", "LastEditDate": "2009-12-23T00:06:27.423"}});