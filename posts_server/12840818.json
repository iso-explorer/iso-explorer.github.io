post_cb({"bq_ids": {"n4140": {"so_12840818_12840945_0": {"section_id": 6169, "quality": 0.9545454545454546, "length": 63}}, "n3337": {"so_12840818_12840945_0": {"section_id": 5930, "quality": 0.9545454545454546, "length": 63}}, "n4659": {"so_12840818_12840945_0": {"section_id": 7667, "quality": 0.7121212121212122, "length": 47}}}, "12840818": {"CommentCount": "0", "ViewCount": "629", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2012-10-11T13:36:10.680", "LastActivityDate": "2014-04-16T15:52:15.010", "Title": "Why is the ternary operator not the same as an if-else here?", "AcceptedAnswerId": "12840945", "LastEditDate": "2012-10-11T19:15:15.893", "Id": "12840818", "Score": "0", "Body": "<p>I'm using TR1's <code>std::function</code> to implement a simple callback mechanism. If I don't want to get called back, I register <code>nullptr</code> as the callback handler. This compiles and works fine:</p>\n<pre><code>void Foo::MessageHandlingEnabled( bool enable ){\n    if( enable )\n        m_Bar.RegisterMessageHandler( std::bind(&amp;Foo::BarMessageHandler, this, std::placeholders::_1) );\n    else\n        m_Bar.RegisterMessageHandler( nullptr );\n}\n</code></pre>\n<p>If I rewrite this using the ternary operator...</p>\n<pre><code>void Foo::MessageHandlingEnabled( bool enable ){\n        m_Bar.RegisterMessageHandler( enable?\n                                      std::bind(&amp;Foo::BarMessageHandler, this, std::placeholders::_1) :\n                                      nullptr );   \n\n }\n</code></pre>\n<p>... VC++'s compiler says:</p>\n<blockquote>\n<p id=\"so_12840818_12840818_0\">error C2446: ':' : no conversion from 'nullptr' to\n  'std::tr1::_Bind&lt;_Result_type,_Ret,_BindN&gt;' 1&gt;          with 1&gt;<br>\n  [ 1&gt;              _Result_type=void, 1&gt;              _Ret=void, 1&gt;<br>\n  _BindN=std::tr1::_Bind2,Foo\n  *,std::tr1::_Ph&lt;1&gt;&gt; 1&gt;          ] 1&gt;          No constructor could take the source type, or constructor overload resolution was ambiguous</br></br></p>\n</blockquote>\n<p>Is this a limitation of the compiler, or am I doing something stupid? I know I might not gain any benefit, in this particular case, from using the ternary operator, but I'm just curious.</p>\n", "Tags": "<c++><visual-studio-2010><c++11><std-function><nullptr>", "OwnerUserId": "756200", "AnswerCount": "3"}, "12840945": {"ParentId": "12840818", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2012-10-11T13:41:28.337", "Score": "7", "LastEditorUserId": "412080", "LastEditDate": "2012-10-11T14:01:16.173", "Id": "12840945", "OwnerUserId": "412080", "Body": "<p>Both branches of the ternary operator must return values of the same type, or the type of one value must be convertible to the other. </p>\n<blockquote>\n<p id=\"so_12840818_12840945_0\">5.16.3 ... if the second and third operand have different types, and either has (possibly cv-qualified) class type, an attempt is made to convert each of those operands to the type of the other... [details omitted] Using this process, it is determined whether the second operand can be converted to match the third operand, and whether the third operand can be converted to match the second operand. If both can be converted, or one can be converted but the conversion is ambiguous, the program is ill-formed. If exactly one conversion is possible, that conversion is applied to the chosen operand and the converted operand is used in place of the original operand for the remainder of this section.</p>\n</blockquote>\n<p>This is why the compiler error says <code>...no conversion from 'nullptr' to 'std::tr1::_Bind&lt;_Result_type,_Ret,_BindN&gt;' 1&gt;...</code></p>\n<p><code>nullptr</code> has the type of <code>std::nullptr_t</code> and <code>std::function&lt;&gt;</code> has a constructor that accepts <code>std::nullptr_t</code>. <code>std::tr1::_Bind</code> can't be converted to <code>std::nullptr_t</code> or the other way around in the context of the ternary operator.</p>\n<p><code>if/else</code> on the other hand, doesn't return anything at all.</p>\n", "LastActivityDate": "2012-10-11T14:01:16.173"}, "23114330": {"ParentId": "12840818", "CommentCount": "0", "CreationDate": "2014-04-16T15:52:15.010", "OwnerUserId": "316875", "PostTypeId": "2", "Id": "23114330", "Score": "0", "Body": "<p>Maxim Yegorushkin's answer is right. Here's a simple workaround with example code that better illustrates your problem:</p>\n<pre><code>struct Base{};\nstruct DerivedA:public Base{};\nstruct DerivedB:public Base{};\n\nDerivedA a;\nDerivedB b;\n\ndoesNotWork()\n{\n   bool chooseA = true;\n   Base&amp; base = chooseA?a:b; // Error: compiler tries to convert b to DerivedA (the type of a).\n}\n\nBase&amp; choose(bool x)\n{\n   if(x) return a;\n   return b;\n}\n\nworks()\n{\n   bool chooseA = true;\n   Base&amp; base = choose(chooseA); //Helper function converts a or b to parent class Base.\n}\n</code></pre>\n", "LastActivityDate": "2014-04-16T15:52:15.010"}, "12840951": {"ParentId": "12840818", "CommentCount": "4", "CreationDate": "2012-10-11T13:41:45.933", "OwnerUserId": "109814", "PostTypeId": "2", "Id": "12840951", "Score": "0", "Body": "<p>Here i suppose the registerHandler has polymorphic declaration.</p>\n<p>My guess is ,when meeting the ternary operator ,the compiler will assume both part of the : are same type.</p>\n<p>Thus resolving the polymorphism of registerHandler to match the one that takes a bind result compatible argument.</p>\n<p>With the if, each registerHandler call is resolved separately, so choosing correcly the good registerHandler depending on each passed parameter type.</p>\n", "LastActivityDate": "2012-10-11T13:41:45.933"}});