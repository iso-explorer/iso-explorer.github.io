post_cb({"bq_ids": {"n4140": {"so_21521333_21521556_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 505}}, "n3337": {"so_21521333_21521556_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 496}}, "n4659": {"so_21521333_21521556_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 526}}}, "21521333": {"ViewCount": "1577", "Body": "<p>I have been believed that C header files must be included in the top level of C++ program.\nAnyway, I accidentally discovered that C++ is allowing inclusion of C headers in a sub namespace.</p>\n<pre><code>namespace AAA {\n    extern \"C\" {\n        #include \"sqlite3.h\"     // C API.\n    }\n}\n</code></pre>\n<p>And then, all the C types and functions will be placed in the namespace. More interestingly, <strong>all the linked C functions are also just working!</strong> I also discovered that this may cause some preprocessor issue, but except that, it seems to be working pretty fine.</p>\n<p>Is this a standard behavior? (I am using Clang 3.x) If it is, what is the name of this feature and where can I find this feature mentioned in the standard?</p>\n", "AcceptedAnswerId": "21521529", "Title": "Including C headers in a C++ namespace - is it a standard behavior?", "CreationDate": "2014-02-03T06:52:53.380", "Id": "21521333", "CommentCount": "6", "LastEditDate": "2014-02-03T07:41:28.563", "PostTypeId": "1", "LastEditorUserId": "246776", "LastActivityDate": "2014-02-03T10:21:45.310", "Score": "17", "OwnerUserId": "246776", "Tags": "<c++><c>", "AnswerCount": "2"}, "21521556": {"Id": "21521556", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_21521333_21521556_0\">Is this a standard behavior?</p>\n</blockquote>\n<p>Yes - the behaviour is supported by the Standard, as the C++ compiler doesn't really have a notion of code being \"C\" versus \"C++\" except when <code>extern \"C\"</code> is used to inhibit namespace mangling.</p>\n<p>The consequence of not inhibiting mangling is that you may end up with \"unresolved symbol\" errors at link time if you try to link with a C library defining the out-of-line symbols (<code>extern</code> variables, functions) mentioned in the header.</p>\n<blockquote>\n<p id=\"so_21521333_21521556_1\">If it is [a Standard feature], what is the name of this feature and where can I find this feature mentioned in the standard?</p>\n</blockquote>\n<p>This is just a consequence of the way <code>#include</code> works, which is defined in 16.2 Source file inclusion [cpp.include], crucially:</p>\n<blockquote>\n<p id=\"so_21521333_21521556_2\">[an <code>#include</code>] causes the replacement of that directive by the entire contents of the source file identified by the specified sequence between the \" delimiters.</p>\n</blockquote>\n<p>So, whatever happens with the \"C\" header is exactly as if the surrounding <code>namespace</code>/<code>extern</code> statements and braces existed at the top and bottom of the header file instead... by the time the next phase on compilation begins it's irrelevant exactly where the source code came from (except for purposes of displaying error messages that properly relate to the source file).</p>\n", "LastEditorUserId": "410767", "LastActivityDate": "2014-02-03T10:21:45.310", "Score": "4", "CreationDate": "2014-02-03T07:07:20.100", "ParentId": "21521333", "CommentCount": "0", "LastEditDate": "2014-02-03T10:21:45.310", "OwnerUserId": "410767"}, "21521529": {"Id": "21521529", "PostTypeId": "2", "Body": "<p>You may even do strange things like</p>\n<pre><code>//test.c\nint\n    #include \"main.h\"\n{\n    return 1;\n}\n\n//main.h\nmain(void)\n</code></pre>\n<p>The preprocessor macros are expanded before any syntax check is done. The above example will expand to</p>\n<pre><code>int\nmain(void)\n{\n    return 1;\n}\n</code></pre>\n<p>which is legal code. While you really should avoid such examples, there are cases, where including into another element is quite useful. In your question it depends on how the names are mangled during compilation. If all the definitions in your header file are declared with <code>extern \"C\"</code>, the names will be searched unmangled in the object file, this is, however, not the case if the object file containing the implementation does not use the same namespace as it's definition in the consuming code and does not declare it <code>extern \"C\"</code>.</p>\n", "LastEditorUserId": "2385414", "LastActivityDate": "2014-02-03T07:18:10.117", "Score": "9", "CreationDate": "2014-02-03T07:06:05.440", "ParentId": "21521333", "CommentCount": "0", "LastEditDate": "2014-02-03T07:18:10.117", "OwnerUserId": "2385414"}});