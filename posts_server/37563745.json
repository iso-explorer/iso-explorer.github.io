post_cb({"37564502": {"ParentId": "37563745", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Using the latest version of the <a href=\"https://stackoverflow.com/questions/81656/where-do-i-find-the-current-c-or-c-standard-documents/4653479#4653479\">C++ standard</a> Currently <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4582.pdf\" rel=\"nofollow noreferrer\">n4582</a>.</p>\n<p>In section 14.6 (p10) it says the name is bound at the point of declaration if the name is not dependent on a template parameter. If it depends on a template parameter this is defined in section 14.6.2.</p>\n<p>Section 14.6.2.2 goes on to say an expression is type dependent if any subexpression is type dependent.</p>\n<p>Now since the call to <code>f()</code> is dependent on its parameter. You look at the parameter type to see if it is depending on the type. The parameter is <code>False&lt;T&gt;::value ? d : d</code>. Here the first conditional is depending on the type <code>T</code>.</p>\n<p>Therefore we conclude that the call is bound at the point of instantiation not declaration. And therefore should bind to: <code>void f(Derived &amp;) { std::cout &lt;&lt; \"f(Derived&amp;)\\n\"; }</code></p>\n<p>Thus g++ has the more accurate implementation.</p>\n<blockquote>\n<h2>14.6 Name resolution [temp.res]</h2>\n<h3>Para 10:</h3>\n<p id=\"so_37563745_37564502_0\">If a name does not depend on a <strong>template-parameter (as defined in 14.6.2)</strong>, a declaration (or set of declarations) for that name shall be in scope at the point where the name appears in the template definition; the name is bound to the declaration (or declarations) found at that point and this binding is not affected by declarations that are visible at the point of instantiation.</p>\n<h2>14.6.2.2 Type-dependent expressions [temp.dep.expr]</h2>\n<p id=\"so_37563745_37564502_1\">Except as described below, an expression is type-dependent if <strong>any subexpression is type-dependent</strong>.</p>\n</blockquote>\n", "OwnerUserId": "14065", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:01:02.370", "Id": "37564502", "Score": "23", "CreationDate": "2016-06-01T09:23:17.570", "LastActivityDate": "2016-06-06T17:20:05.583"}, "37564518": {"ParentId": "37563745", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>I think gcc (and visual studio, by the way) are right on this one.</p>\n<blockquote>\n<p id=\"so_37563745_37564518_0\"><strong><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4582.pdf\">n4582</a>, \u00a714.6.2.2</strong></p>\n<p id=\"so_37563745_37564518_1\">Except as described below, an expression is type-dependent if any subexpression is type-dependent.</p>\n</blockquote>\n<p>In <code>T{} ? d : d</code>, there are 3 sub expressions:</p>\n<ul>\n<li><code>T{}</code>, obviously type dependent</li>\n<li><code>d</code> (2 times), not type dependent</li>\n</ul>\n<p>Since there is a type dependent sub expression and the ternary operator does not figure in the list of exceptions in \u00a714.6.2.2, it is considered type dependent.</p>\n", "OwnerUserId": "1261432", "LastEditorUserId": "1261432", "LastEditDate": "2016-06-01T09:32:43.410", "Id": "37564518", "Score": "7", "CreationDate": "2016-06-01T09:23:49.770", "LastActivityDate": "2016-06-01T09:32:43.410"}, "bq_ids": {"n4140": {"so_37563745_37564518_1": {"section_id": 200, "quality": 1.0, "length": 7}, "so_37563745_37564492_0": {"section_id": 235, "quality": 0.9615384615384616, "length": 50}, "so_37563745_37564502_0": {"section_id": 177, "quality": 0.9655172413793104, "length": 28}, "so_37563745_37564502_1": {"section_id": 200, "quality": 1.0, "length": 7}}, "n3337": {"so_37563745_37564518_1": {"section_id": 194, "quality": 1.0, "length": 7}, "so_37563745_37564492_0": {"section_id": 228, "quality": 0.9615384615384616, "length": 50}, "so_37563745_37564502_0": {"section_id": 171, "quality": 0.9655172413793104, "length": 28}, "so_37563745_37564502_1": {"section_id": 194, "quality": 1.0, "length": 7}}, "n4659": {"so_37563745_37564518_1": {"section_id": 206, "quality": 1.0, "length": 7}, "so_37563745_37564492_0": {"section_id": 245, "quality": 0.9615384615384616, "length": 50}, "so_37563745_37564502_0": {"section_id": 182, "quality": 0.9655172413793104, "length": 28}, "so_37563745_37564502_1": {"section_id": 206, "quality": 1.0, "length": 7}}}, "37563745": {"CommentCount": "8", "AcceptedAnswerId": "37564502", "PostTypeId": "1", "LastEditorUserId": "3980929", "CreationDate": "2016-06-01T08:48:05.240", "LastActivityDate": "2016-06-06T17:20:05.583", "LastEditDate": "2016-06-01T11:21:21.180", "ViewCount": "1023", "FavoriteCount": "4", "Title": "Conditional operator's return type and two-phase lookup", "Id": "37563745", "Score": "38", "Body": "<p>Consider the following snippet:</p>\n<pre><code>struct Base { };\nstruct Derived : Base { };\n\nvoid f(Base &amp;) { std::cout &lt;&lt; \"f(Base&amp;)\\n\"; }\n\ntemplate &lt;class T = int&gt;\nvoid g() {\n    Derived d;\n    f(T{} ? d : d); // 1\n}\n\nvoid f(Derived &amp;) { std::cout &lt;&lt; \"f(Derived&amp;)\\n\"; }\n\nint main() {\n    g();\n}\n</code></pre>\n<p>In this case, I reckon that the function call to <code>f</code> at <code>// 1</code> should be looked up in phase one, since its argument's type is unambigously <code>Derived&amp;</code>, and thus be resolved to <code>f(Base&amp;)</code> which is the only one in scope.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/3cd11c152a34b3f4\">Clang 3.8.0 agrees with me</a>, but <a href=\"http://coliru.stacked-crooked.com/a/2e730f9275d75b15\">GCC 6.1.0 doesn't</a>, and defers the lookup of <code>f</code> until phase two, where <code>f(Derived&amp;)</code> is picked up.</p>\n<p>Which compiler is right ?</p>\n", "Tags": "<c++><language-lawyer><compiler-bug><name-lookup><dependent-name>", "OwnerUserId": "3233393", "AnswerCount": "3"}, "37564492": {"ParentId": "37563745", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>According to c++ draft (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4582.pdf\" rel=\"nofollow\">n4582</a>) \u00a714.7.1.5:</p>\n<blockquote>\n<p id=\"so_37563745_37564492_0\">Unless a function template specialization has been explicitly\n  instantiated or explicitly specialized, the function template\n  specialization is implicitly instantiated when the specialization is\n  referenced in a context that requires a function definition to exist.\n  Unless a call is to a function template explicit specialization or to\n  a member function of an explicitly specialized class template, a\n  default argument for a function template or a member function of a\n  class template is implicitly instantiated when the function is called\n  in a context that requires the value of the default argument.</p>\n</blockquote>\n<p>I would say gcc is more correct about this.</p>\n<p>If you for example create an specialized version of <code>void g()</code> you get <a href=\"http://coliru.stacked-crooked.com/a/46e26f799d60e337\" rel=\"nofollow\">both compiler doing the same</a>.</p>\n", "OwnerUserId": "1810087", "LastEditorUserId": "1810087", "LastEditDate": "2016-06-06T15:15:22.343", "Id": "37564492", "Score": "1", "CreationDate": "2016-06-01T09:22:45.857", "LastActivityDate": "2016-06-06T15:15:22.343"}});