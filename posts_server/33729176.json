post_cb({"33734238": {"Id": "33734238", "PostTypeId": "2", "Body": "<p>The \"decay\" you are talking about is something that happens <em>when deducing a function template parameter from an argument</em>.  I have posted a fuller explanation <a href=\"https://stackoverflow.com/a/33734010/1505939\">here</a>.</p>\n<p>When you explicitly provide a value for a template parameter, there is no deduction step; the value you explicitly provided is exactly the value that the parameter takes.</p>\n<p>With class templates, there is never parameter deduction; they must always have their parameters explicitly provided.</p>\n<p>Illustrative examples:</p>\n<pre><code>template&lt;typename T&gt; void f(T t) {}\ntemplate&lt;typename T&gt; struct S { void f(T t) {} };\n\n...\n\nint x[27];\nf(x);               // Type deduction: decay occurs, T = int *\nf&lt;int *&gt;(x);        // No deduction. T = int *\nf&lt;int[27]&gt;(x);      // No deduction. T = int[27]\nS&lt;int[27]&gt;().f(x);  // No deduction. T = int[27]\n</code></pre>\n<p>In the latter two cases, <em>adjustment</em> still occurs. [temp.deduct]/3 explicitly restates this: when <code>T</code> is an array type, the <em>function parameter</em> <code>T t</code> means that <code>t</code> has a pointer type, in exactly the same fashion that:</p>\n<pre><code>void g(int t[27])\n</code></pre>\n<p>actually specifies that <code>t</code> has type <code>int *</code>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-16T11:31:53.030", "Score": "2", "CreationDate": "2015-11-16T11:26:03.330", "ParentId": "33729176", "CommentCount": "0", "OwnerUserId": "1505939", "LastEditDate": "2017-05-23T12:23:10.760"}, "33729446": {"Id": "33729446", "PostTypeId": "2", "Body": "<p>From the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_33729176_33729446_0\"><strong>7.1.6.2 Simple type specifiers</strong></p>\n<p id=\"so_33729176_33729446_1\">4 The type denoted by <code>decltype(e)</code> is defined as follows:</p>\n<p id=\"so_33729176_33729446_2\">\u2014 if <code>e</code> is an unparenthesized <em>id-expression</em> or an unparenthesized class member access (5.2.5), <code>decltype(e)</code> is the type of the entity named by <code>e</code>. If there is no such entity, or if <code>e</code> names a set of overloaded functions, the program is ill-formed;</p>\n<p id=\"so_33729176_33729446_3\">\u2014 otherwise, if <code>e</code> is an xvalue, <code>decltype(e)</code> is <code>T&amp;&amp;</code>, where <code>T</code> is the type of <code>e</code>;</p>\n<p id=\"so_33729176_33729446_4\">\u2014 otherwise, if <code>e</code> is an lvalue, <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code> is the type of <code>e</code>;</p>\n<p id=\"so_33729176_33729446_5\">\u2014 otherwise, <code>decltype(e)</code> is the type of <code>e</code>.</p>\n</blockquote>\n<p>Given</p>\n<pre><code>char ary[] = \"12345\";\n</code></pre>\n<p><code>decltype(ary)</code> denotes the type of <code>ary</code> (an unparenthesized <em>id-expression</em>), which is <code>char[6]</code>.</p>\n<p>A more user friendly description of <code>decltype</code> can be found at <a href=\"http://en.cppreference.com/w/cpp/language/decltype\" rel=\"nofollow\">http://en.cppreference.com</a>.</p>\n", "LastActivityDate": "2015-11-16T06:14:23.123", "CommentCount": "0", "CreationDate": "2015-11-16T06:14:23.123", "ParentId": "33729176", "Score": "2", "OwnerUserId": "434551"}, "33729176": {"ViewCount": "230", "Body": "<p>We know that <a href=\"https://stackoverflow.com/questions/1863751/array-decay-to-pointers-in-templates\">arrays decay to pointers in function templates</a> and to take an array type parameter we need to declare our function template with a reference-to-array:</p>\n<pre><code>template&lt;class T, std::size_t N&gt;\nstd::size_t number_of_elements(T (&amp;ary)[N]) {\n  return N;\n}\n</code></pre>\n<p>However, why do we not need to declare reference-to-array parameters in class templates? The code below shows this and compiles under C++11.</p>\n<pre><code>template&lt;class T&gt;\nstruct cls_number_of_elements {};\n\ntemplate&lt;class T, std::size_t R&gt;\nstruct cls_number_of_elements&lt;T[R]&gt; {\n  static const int N = R;\n};\n\nchar ary[] = \"12345\";\nauto const N = cls_number_of_elements&lt;decltype(ary)&gt;::N;\nchar ar2[N];\n</code></pre>\n", "AcceptedAnswerId": "33734238", "Title": "Why does array type not decay to pointer for class templates?", "CreationDate": "2015-11-16T05:44:32.383", "Id": "33729176", "CommentCount": "4", "LastEditDate": "2017-05-23T11:59:02.133", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-16T16:52:32.453", "Score": "3", "OwnerUserId": "1727828", "Tags": "<c++><c++11>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_33729176_33729446_3": {"length": 5, "quality": 1.0, "section_id": 5440}, "so_33729176_33729446_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 5440}, "so_33729176_33729446_4": {"length": 5, "quality": 1.0, "section_id": 5440}, "so_33729176_33729446_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 5440}, "so_33729176_33733204_0": {"length": 17, "quality": 0.85, "section_id": 11}}, "n3337": {"so_33729176_33729446_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 5235}, "so_33729176_33729446_4": {"length": 5, "quality": 1.0, "section_id": 5235}, "so_33729176_33733204_0": {"length": 17, "quality": 0.85, "section_id": 8}, "so_33729176_33729446_3": {"length": 5, "quality": 1.0, "section_id": 5235}, "so_33729176_33729446_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 5235}}, "n4659": {"so_33729176_33729446_2": {"length": 18, "quality": 0.9473684210526315, "section_id": 6867}, "so_33729176_33729446_4": {"length": 5, "quality": 1.0, "section_id": 6867}, "so_33729176_33733204_0": {"length": 16, "quality": 0.8, "section_id": 12}, "so_33729176_33729446_3": {"length": 5, "quality": 1.0, "section_id": 6867}, "so_33729176_33729446_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 6867}}}, "33733204": {"Id": "33733204", "PostTypeId": "2", "Body": "<p>Well between the C and C++ standards and <a href=\"https://stackoverflow.com/a/1462103\">this answer</a> it looks like the explanation is:</p>\n<blockquote id=\"so_33729176_33733204_0\">\n<h3>4.2 Array-to-pointer conversion</h3>\n<ol>\n<li>An lvalue or rvalue of type \u201carray of <code>N</code> <code>T</code>\u201d or \u201carray of unknown bound of <code>T</code>\u201d can be converted to an rvalue\n  of type \u201cpointer to <code>T</code>.\u201d The result is a pointer to the first element of the array.</li>\n</ol>\n</blockquote>\n<p>Looks like this conversion <strong>does</strong> happen for deduced template arguments in a function template</p>\n<pre><code>number_of_elements(ary)\n</code></pre>\n<p>but <strong>not</strong> for template arguments in class templates</p>\n<pre><code>cls_number_of_elements&lt;char[5]&gt;\n</code></pre>\n<p>and explicitly-typed function templates</p>\n<pre><code>number_of_elements&lt;char[5]&gt;(ary)\n</code></pre>\n<p>since those types are not deduced.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-16T10:32:56.043", "Score": "0", "CreationDate": "2015-11-16T10:32:56.043", "ParentId": "33729176", "CommentCount": "0", "OwnerUserId": "1727828", "LastEditDate": "2017-05-23T12:23:10.760"}, "33740543": {"Id": "33740543", "PostTypeId": "2", "Body": "<p>Looking at the code I have a very short explanation which doesn't have anything to do with the differences between class and function templates:</p>\n<p>For <code>number_of_elements</code> the \"type\" of the array is <code>T[N]</code>. Sample applies to <code>cls_number_of_elements</code>where the \"type\" is <code>T[R]</code>.\nIn both cases the <code>T</code> will become <code>char</code> while <code>N</code> resp. <code>R</code> becomes <code>6</code>.\nThe only reason why you need the <code>&amp;</code> is because you cannot pass arrays by value.\n(see anser from @bku_drytt)</p>\n", "LastActivityDate": "2015-11-16T16:52:32.453", "CommentCount": "0", "CreationDate": "2015-11-16T16:52:32.453", "ParentId": "33729176", "Score": "0", "OwnerUserId": "4279361"}});