post_cb({"16498399": {"ParentId": "16493015", "CommentCount": "0", "Body": "<p>Every name used after the member function name is also looked up inside the lexical scope of its class. This leads to the following (seemingly) inconsistent behaviour, since the normal return type is <em>not</em> inside the lexical scope of the class:</p>\n<pre><code>struct X{\n  struct Y{};\n\n  Y foo(Y);\n  Y bar(Y);\n};\n\n// normal return type is before 'foo', needs explicit scope qualification\n// parameter doesn't (after 'foo')\nX::Y X::foo(Y y){ return y; }\n\n// trailing-return-type also doesn't (after 'bar')\nauto X::bar(Y y) -&gt; Y{ return y; }\n</code></pre>\n<p>For the standardese for this, we look at <code>\u00a79.3 [class.mfct] p5</code>:</p>\n<blockquote>\n<p id=\"so_16493015_16498399_0\">If the definition of a member function is lexically outside its class definition, the member function name shall be qualified by its class name using the <code>::</code> operator. [ <em>Note:</em> <strong>A name used in a member function definition</strong> (that is, in the <em>parameter-declaration-clause</em> including the default arguments (8.3.6) or in the member function body) <strong>is looked up as described in 3.4.</strong> <em>\u2014end note</em> ] [...]</p>\n</blockquote>\n<p>And then at <code>\u00a73.4.1 [basic.lookup.unqual] p8</code> (unqualified name lookup, e.g. without <code>::</code>):</p>\n<blockquote>\n<p id=\"so_16493015_16498399_1\">A name used in the definition of a member function (9.3) of class <code>X</code> <strong>following the function\u2019s <em>declarator-id</em></strong><sup>31</sup> [...] shall be declared in one of the following ways:</p>\n<ul>\n<li>[...]</li>\n<li>shall be a member of class <code>X</code> or be a member of a base class of <code>X</code> (10.2), or</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>(The <em>declarator-ids</em> in my example are <code>foo</code> and <code>bar</code>.)</p>\n", "OwnerUserId": "500104", "PostTypeId": "2", "Id": "16498399", "Score": "0", "CreationDate": "2013-05-11T14:55:22.780", "LastActivityDate": "2013-05-11T14:55:22.780"}, "16493015": {"CommentCount": "3", "ViewCount": "88", "PostTypeId": "1", "LastEditorUserId": "1681681", "CreationDate": "2013-05-11T01:56:25.347", "LastActivityDate": "2013-05-11T14:55:22.780", "Title": "Do we need to prefix member arguments of nested type with \"::\"?", "AcceptedAnswerId": "16498399", "LastEditDate": "2013-05-11T13:28:38.960", "Id": "16493015", "Score": "2", "Body": "<p>For instance, consider the following where there is a clash of name <code>nest1</code>:</p>\n<pre><code>template &lt;typename U&gt; class nest1 {};\n\nclass cls {\npublic:\n    template &lt;typename V&gt; class nest1 {};\n\n    template &lt;typename W&gt; class nest2 {\n    public:\n        void bar(nest1&lt;W&gt; x);\n    };\n};\n\ntemplate &lt;typename W&gt;\nvoid cls::nest2&lt;W&gt;::bar(nest1&lt;W&gt; x) {}  // how does compiler know which nest&lt;1&gt;?\n</code></pre>\n<ul>\n<li>How does the compiler know whether <code>bar</code> takes <code>nest1&lt;W&gt;</code> or <code>cls::nest1&lt;W&gt;</code> if we don't prefix it with <code>cls::</code> (e.g. <code>bar(cls::nest1&lt;W&gt; x)</code>)?</li>\n<li>Is it good practice to explicitly prefix <code>cls::</code> anyhow?</li>\n</ul>\n<p><em>NB: the compiler actually chooses implicitly to declare</em> <code>bar(cls::nest1&lt;W&gt; x)</code>:</p>\n<ul>\n<li>Calling <code>cls::nest1&lt;W&gt; x; bar(x);</code> works: <a href=\"http://ideone.com/3ZuH2Z\" rel=\"nofollow\">http://ideone.com/3ZuH2Z</a></li>\n<li>Passing <code>nest1&lt;W&gt; x; bar(x);</code> fails: <a href=\"http://ideone.com/6HmA3f\" rel=\"nofollow\">http://ideone.com/6HmA3f</a></li>\n</ul>\n", "Tags": "<c++><class><templates><nested>", "OwnerUserId": "1681681", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_16493015_16498399_1": {"section_id": 7093, "quality": 0.8333333333333334, "length": 10}, "so_16493015_16498399_0": {"section_id": 5884, "quality": 0.8823529411764706, "length": 30}}, "n3337": {"so_16493015_16498399_1": {"section_id": 6838, "quality": 0.9166666666666666, "length": 11}, "so_16493015_16498399_0": {"section_id": 5655, "quality": 0.8823529411764706, "length": 30}}, "n4659": {"so_16493015_16498399_1": {"section_id": 8594, "quality": 0.8333333333333334, "length": 10}, "so_16493015_16498399_0": {"section_id": 7367, "quality": 0.8823529411764706, "length": 30}}}});