post_cb({"23872852": {"ParentId": "23872692", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_23872692_23872852_0\">The expression E1[E2] is identical (by definition) to *((E1)+(E2))</p>\n</blockquote>\n<p>...and then commutativity of index and pointer takes hold. See your friendly neighbourhood C++ standard, section 5.2.1 in this version: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf</a></p>\n", "OwnerUserId": "190499", "PostTypeId": "2", "Id": "23872852", "Score": "1", "CreationDate": "2014-05-26T14:55:12.583", "LastActivityDate": "2014-05-26T14:55:12.583"}, "23872692": {"CommentCount": "16", "AcceptedAnswerId": "23872864", "PostTypeId": "1", "ClosedDate": "2014-05-26T17:37:17.103", "LastEditorUserId": "2932052", "CreationDate": "2014-05-26T14:45:34.683", "LastActivityDate": "2014-05-26T15:25:06.430", "LastEditDate": "2014-05-26T15:25:06.430", "ViewCount": "466", "FavoriteCount": "1", "Title": "is int[pointer-to-array] in the C++ - standard?", "Id": "23872692", "Score": "7", "Body": "<p>As I have learned, one can write the following code:</p>\n<pre><code>char *a = new char[50];\nfor (int i = 0; i &lt; 50; ++i) {\n    i[a] = '5';\n}\n</code></pre>\n<p>It compiles. It works. It does <em>exactly</em> the same as</p>\n<pre><code>char *a = new char[50];\nfor (int i = 0; i &lt; 50; ++i) {\n    a[i] = '5';\n}\n</code></pre>\n<p>Is it just because:</p>\n<ul>\n<li><code>a[b]</code> is implemented as a macro <code>*(a + b)</code> by default and the fact that both code samples are valid is just an accident/compiler specific</li>\n<li>it's standardized somewhere and the outcome of such algorithms should be the same on <em>every</em> platform</li>\n</ul>\n<p>It is reasonable to assume that addition should be commutative, but if we implement <code>operator[]</code> in that way, we have made something else commutative, what might not be what we wanted.</p>\n<p>The interesting fact is that there is no <code>pointer[pointer]</code> operator, so <code>operator[]</code> is not a macro.</p>\n<p>I know it's bad. I know it's confusing the people who read the code. But I want to know if it's just an accident and it will not work in a distant land where unicorns have seven legs and horns are on their left cheek.</p>\n", "Tags": "<c++><arrays><pointers><syntax><subscript-operator>", "OwnerUserId": "2420535", "AnswerCount": "3"}, "23872870": {"ParentId": "23872692", "CommentCount": "0", "Body": "<p>Here is what C++11 standard has to say:</p>\n<blockquote>\n<p id=\"so_23872692_23872870_0\">Note: Except where it has been declared for a class (13.5.5), <strong>the subscript operator <code>[]</code> is interpreted in such\n  a way that <code>E1[E2]</code> is identical to <code>*((E1)+(E2))</code></strong>. Because of the conversion rules that apply to +, if <code>E1</code> is an\n  array and <code>E2</code> an integer, then <code>E1[E2]</code> refers to the <code>E2</code>-th member of <code>E1</code>. Therefore, despite its asymmetric\n  appearance, subscripting is a commutative operation. (emphasis is added).</p>\n</blockquote>\n<p>So your assumption that <code>a[b]</code> is implemented as <code>*(a + b)</code> is correct, except that it is implemented directly in the compiler, not as a macro.</p>\n", "OwnerUserId": "335858", "PostTypeId": "2", "Id": "23872870", "Score": "5", "CreationDate": "2014-05-26T14:56:10.347", "LastActivityDate": "2014-05-26T14:56:10.347"}, "bq_ids": {"n4140": {"so_23872692_23872852_0": {"section_id": 5986, "quality": 0.8333333333333334, "length": 5}, "so_23872692_23872870_0": {"section_id": 3233, "quality": 0.8888888888888888, "length": 32}, "so_23872692_23872864_0": {"section_id": 3233, "quality": 0.9696969696969697, "length": 32}}, "n3337": {"so_23872692_23872852_0": {"section_id": 5754, "quality": 0.8333333333333334, "length": 5}, "so_23872692_23872870_0": {"section_id": 3106, "quality": 0.8888888888888888, "length": 32}, "so_23872692_23872864_0": {"section_id": 3106, "quality": 0.9696969696969697, "length": 32}}, "n4659": {"so_23872692_23872864_0": {"section_id": 3990, "quality": 0.9696969696969697, "length": 32}, "so_23872692_23872870_0": {"section_id": 3990, "quality": 0.8888888888888888, "length": 32}, "so_23872692_23872852_0": {"section_id": 7486, "quality": 0.8333333333333334, "length": 5}}}, "23872864": {"ParentId": "23872692", "CommentCount": "0", "Body": "<p><a href=\"https://isocpp.org/files/papers/N3690.pdf\">C++ standard, \u00a7 8.3.4, note 7 (page 185) (emphasis mine).</a></p>\n<blockquote>\n<p id=\"so_23872692_23872864_0\">Except where it has been declared for a class (13.5.5), the subscript operator <code>[]</code> is interpreted in such a way that <code>E1[E2]</code> is identical to <code>*((E1)+(E2))</code>. Because of the conversion rules that apply to <code>+</code>, if <code>E1</code> is an array and <code>E2</code> an integer, then <code>E1[E2]</code> refers to the <code>E2</code>-th member of <code>E1</code>. Therefore, <em>despite its asymmetric appearance</em>, <strong>subscripting is a commutative operation</strong>.</p>\n</blockquote>\n", "OwnerUserId": "703016", "PostTypeId": "2", "Id": "23872864", "Score": "10", "CreationDate": "2014-05-26T14:55:53.390", "LastActivityDate": "2014-05-26T14:55:53.390"}});