post_cb({"2537130": {"CommentCount": "2", "ViewCount": "184", "PostTypeId": "1", "LastEditorUserId": "109747", "CreationDate": "2010-03-29T10:15:13.160", "LastActivityDate": "2010-03-29T11:04:45.737", "Title": "is back_insert_iterator<> safe to be passed by value?", "AcceptedAnswerId": "2537183", "LastEditDate": "2010-03-29T11:04:45.737", "Id": "2537130", "Score": "2", "Body": "<p>I have a code that looks something like:  </p>\n<pre><code>struct Data { int value; };\nclass A {\npublic:\n    typedef std::deque&lt;boost::shared_ptr&lt;Data&gt; &gt; TList;\n    std::back_insert_iterator&lt;TList&gt; GetInserter()\n    {\n        return std::back_inserter(m_List);\n    }\nprivate:\n    TList m_List;\n};\nclass AA {\n    boost::scoped_ptr&lt;A&gt; m_a;\npublic:\n    AA() : m_a(new A()) {}\n    std::back_insert_iterator&lt;A::TList&gt; GetDataInserter()\n    {\n        return m_a-&gt;GetInserter();\n    }        \n};\nclass B {\n    template&lt;class OutIt&gt;\n    CopyInterestingDataTo(OutIt outIt)\n    {\n        // loop and check conditions for interesting data\n        // for every `it` in a Container&lt;Data*&gt;\n        // create a copy and store it\n        for( ... it = ..; .. ; ..) if (...) {\n            *outIt = OutIt::container_type::value_type(new Data(**it));\n            outIt++; // dummy\n        }\n    }\n    void func()\n    {\n        AA aa;\n        CopyInterestingDataTo(aa.GetDataInserter());\n        // aa.m_a-&gt;m_List is empty!\n    }\n};\n</code></pre>\n<p>The problem is that <code>A::m_List</code> is always empty even after <code>CopyInterestingDataTo()</code> is called. However, if I debug and step into <code>CopyInterestingDataTo()</code>, the iterator does store the supposedly inserted data!</p>\n<p><strong>update:</strong>\nI found the culprit. I actually have something like:</p>\n<pre><code>class AA {\n    boost::scoped_ptr&lt;A&gt; m_a;\n    std::back_insert_iterator&lt;A::TList&gt; GetDataInserter()\n    {\n        //return m_a-&gt;GetInserter(); // wrong\n        return m_A-&gt;GetInserter(); // this is the one I actually want\n    }        \n    // ..... somewhere at the end of the file\n    boost::scoped_ptr&lt;A&gt; m_A;\n};\n</code></pre>\n<p>Now, which answer should I mark as answer?\nReally sorry for those not chosen, but you guys definitely got some up-votes : )</p>\n", "Tags": "<c++><stl><iterator>", "OwnerUserId": "109747", "AnswerCount": "2"}, "2537299": {"ParentId": "2537130", "CommentCount": "1", "Body": "<p>The following code, which compiles, prints \"1\", indicating one item added to the list:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;deque&gt;\n#include \"boost/shared_ptr.hpp\"\n#include \"boost/scoped_ptr.hpp\"\n\nstruct Data { \n    int value; \n    Data( int n ) : value(n) {}\n};\n\nstruct A {\n    typedef std::deque&lt;boost::shared_ptr&lt;Data&gt; &gt; TList;\n    std::back_insert_iterator&lt;TList&gt; GetInserter()\n    {\n        return std::back_inserter(m_List);\n    }\n    TList m_List;\n};\n\nstruct AA {\n    boost::scoped_ptr&lt;A&gt; m_a;\n    AA() : m_a(new A()) {}\n    std::back_insert_iterator&lt;A::TList&gt; GetDataInserter()\n    {\n        return m_a-&gt;GetInserter();\n    }        \n};\n\nstruct B {\n    template&lt;class OutIt&gt;\n    void CopyInterestingDataTo(OutIt outIt)\n    {\n        *outIt = typename OutIt::container_type::value_type(new Data(0));\n        outIt++; // dummy\n    }\n    int func()\n    {\n        AA aa;\n        CopyInterestingDataTo(aa.GetDataInserter());\n        return aa.m_a-&gt;m_List.size();\n    }\n};\n\nint main() {\n    B b;\n    int n = b.func();    \n    std::cout &lt;&lt;  n &lt;&lt; std::endl;\n}\n</code></pre>\n", "Id": "2537299", "PostTypeId": "2", "OwnerDisplayName": "anon", "Score": "1", "CreationDate": "2010-03-29T10:50:30.000", "LastActivityDate": "2010-03-29T10:50:30.000"}, "2537183": {"ParentId": "2537130", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The short answer is yes, <code>back_insert_iterator</code> is safe to pass by value. The long answer: From standard 24.4.2/3:</p>\n<blockquote>\n<p id=\"so_2537130_2537183_0\">Insert iterators satisfy the\n  requirements of output iterators.</p>\n</blockquote>\n<p>And 24.1.2/1</p>\n<blockquote>\n<p id=\"so_2537130_2537183_1\">A class or a built-in type X satisfies\n  the requirements of an output iterator\n  if X is an Assignable type (23.1) ...</p>\n</blockquote>\n<p>And finally from Table 64 in 23.1:</p>\n<blockquote>\n<p id=\"so_2537130_2537183_2\"><strong>expression</strong> <code>t = u</code>\n<strong>return-type</strong> <code>T&amp;</code>\n<strong>post-condition</strong> <code>t</code> is equivalent to <code>u</code></p>\n</blockquote>\n<p><strong>EDIT:</strong> At a glance your code looks OK to <em>me</em>, are you 100% certain that elements are actually being inserted? If you are I would single step through the code and check the address of the <code>aa.m_a-&gt;m_List</code> object and compare it to the one stored in <code>outIt</code> in <code>CopyInterestingDataTo</code>, if they're not the same something's fishy.</p>\n", "OwnerUserId": "125672", "LastEditorUserId": "125672", "LastEditDate": "2010-03-29T10:50:33.730", "Id": "2537183", "Score": "4", "CreationDate": "2010-03-29T10:25:32.087", "LastActivityDate": "2010-03-29T10:50:33.730"}, "bq_ids": {"n4140": {"so_2537130_2537183_1": {"section_id": 5571, "quality": 0.7, "length": 7}, "so_2537130_2537183_0": {"section_id": 5634, "quality": 1.0, "length": 6}}, "n3337": {"so_2537130_2537183_1": {"section_id": 5353, "quality": 0.7, "length": 7}, "so_2537130_2537183_0": {"section_id": 5417, "quality": 1.0, "length": 6}}, "n4659": {"so_2537130_2537183_1": {"section_id": 7018, "quality": 0.7, "length": 7}, "so_2537130_2537183_0": {"section_id": 7078, "quality": 1.0, "length": 6}}}});