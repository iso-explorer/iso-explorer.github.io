post_cb({"bq_ids": {"n4140": {"so_48485446_48485664_2": {"length": 12, "quality": 1.0, "section_id": 307}, "so_48485446_48485664_3": {"length": 36, "quality": 1.0, "section_id": 307}, "so_48485446_48485664_1": {"length": 9, "quality": 0.9, "section_id": 307}, "so_48485446_48485664_0": {"length": 45, "quality": 0.9, "section_id": 5451}}, "n3337": {"so_48485446_48485664_2": {"length": 12, "quality": 1.0, "section_id": 298}, "so_48485446_48485664_3": {"length": 36, "quality": 1.0, "section_id": 298}, "so_48485446_48485664_0": {"length": 35, "quality": 0.7, "section_id": 5245}, "so_48485446_48485664_1": {"length": 9, "quality": 0.9, "section_id": 298}}, "n4659": {"so_48485446_48485664_2": {"length": 12, "quality": 1.0, "section_id": 314}, "so_48485446_48485664_3": {"length": 36, "quality": 1.0, "section_id": 314}, "so_48485446_48485664_0": {"length": 49, "quality": 0.98, "section_id": 6889}, "so_48485446_48485664_1": {"length": 10, "quality": 1.0, "section_id": 314}}}, "48485664": {"Id": "48485664", "PostTypeId": "2", "Body": "<p>Yes, it's allowed according to the <a href=\"https://timsong-cpp.github.io/cppwp/n4659/over.over#1.7\" rel=\"noreferrer\">very bullet <strong>Rakete1111</strong> pointed out</a>. And there's no need to just assume it can be done, it's done according to the rules of placeholder type deduction at <a href=\"https://timsong-cpp.github.io/cppwp/n4659/dcl.type.auto.deduct#4\" rel=\"noreferrer\">[dcl.type.auto.deduct]/4</a>, emphasis mine:</p>\n<blockquote>\n<p id=\"so_48485446_48485664_0\">If the placeholder is the auto type-specifier, the deduced type T'\n  replacing T is determined using the rules for template argument\n  deduction. Obtain P from T by replacing the occurrences of auto with\n  either a new invented type template parameter U or, if the\n  initialization is copy-list-initialization, with\n  std\u200b::\u200binitializer_\u00adlist. <strong>Deduce a value for U using the rules of\n  template argument deduction from a function call, where P is a\n  function template parameter type and the corresponding argument is e.</strong>\n  If the deduction fails, the declaration is ill-formed. Otherwise, T'\n  is obtained by substituting the deduced U into P.</p>\n</blockquote>\n<p>Where <a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp.deduct.call#6\" rel=\"noreferrer\">[temp.deduct.call]/6</a> has this paragraph, pertaining to your use case:</p>\n<blockquote>\n<p id=\"so_48485446_48485664_1\">When P is a function type, function pointer type, or pointer to member\n  function type:</p>\n<ul>\n<li><p id=\"so_48485446_48485664_2\">If the argument is an overload set containing one or more function templates, the parameter is treated as a non-deduced context.</p></li>\n<li><p id=\"so_48485446_48485664_3\">If the argument is an overload set (not containing function templates), trial argument deduction is attempted using each of the\n  members of the set. <strong>If deduction succeeds for only one of the\n  overload set members, that member is used as the argument value for\n  the deduction.</strong> If deduction succeeds for more than one member of the\n  overload set the parameter is treated as a non-deduced context.</p></li>\n</ul>\n</blockquote>\n<p>So there you have it in all its glory.</p>\n", "LastActivityDate": "2018-01-28T11:08:30.190", "Score": "7", "CreationDate": "2018-01-28T11:08:30.190", "ParentId": "48485446", "CommentCount": "2", "OwnerUserId": "817643"}, "48485446": {"ViewCount": "74", "Body": "<p>A follow-up of <a href=\"https://stackoverflow.com/questions/48481057/can-auto-placeholder-be-used-to-deduce-function-result-in-non-type-template-para\">this question</a>. Assuming placeholder can be used to deduce result type of the function pointer constituting non-type template parameter. Does c++17 allows to perform overload resolution on passed to the template function name - without the knowledge of the result type, that would be needed to perform implicit casting?</p>\n<pre><code>template &lt;auto(*)(int)&gt;\nstruct Foo { };\n\nint bar(int);\nfloat bar(float);\n\nint main() {\n    static_cast&lt;void&gt;(Foo&lt;bar&gt;{});\n}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/QPEF9ek3LxAtQvq2\" rel=\"nofollow noreferrer\">[gcc]</a> as well as <a href=\"https://wandbox.org/permlink/qlvAYthDOcqB1Sr8\" rel=\"nofollow noreferrer\">[clang]</a> seem to accept the code.</p>\n", "AcceptedAnswerId": "48485664", "Title": "Can placeholder type in non-type template parameter involve overload resolution of the function passed as a template argument?", "CreationDate": "2018-01-28T10:43:05.743", "LastActivityDate": "2018-01-28T11:08:30.190", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-01-28T10:49:35.033", "LastEditorUserId": "4324224", "Id": "48485446", "Score": "4", "OwnerUserId": "4324224", "Tags": "<c++><templates><language-lawyer><c++17>", "AnswerCount": "1"}});