post_cb({"35677263": {"ViewCount": "86", "Body": "<p>The following code specializes two versions of f(). The first detects a vector and returns an iterator. The second takes all other types and returns a copy.</p>\n<p>This fails to compile on VC 2010 with an error in GetIter2 that GetIter::type doesn't exist. This is only when resolving a call to f() with a non-vector. If I remove one layer of type indirection, using GetIter instead of GetIter2 (see commented line) for the return type, then things work fine.</p>\n<p>I guess I want to know if this a compiler bug or correct behavior. If this looks weird it's because it's a reduction of a problem I'm having using boost::range_iterator where I can't just remove what GetIter2 represents.</p>\n<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nstruct GetIter {\n};\n\ntemplate&lt;typename T&gt;\nstruct GetIter&lt;vector&lt;T&gt;&gt; {\n    typedef typename vector&lt;T&gt;::iterator type;\n};\n\ntemplate&lt;typename T&gt;\nstruct GetIter2\n{\n    typedef typename GetIter&lt;T&gt;::type type;\n};\n\ntemplate&lt;typename T&gt;\ntypename enable_if&lt;is_same&lt;T, vector&lt;int&gt;&gt;::value, typename GetIter2&lt;T&gt;::type&gt;::type\n//typename enable_if&lt;is_same&lt;T, vector&lt;int&gt;&gt;::value, typename GetIter&lt;T&gt;::type&gt;::type\nf(T &amp; t) {\n    return t.begin();\n}\n\ntemplate&lt;typename T&gt;\ntypename enable_if&lt;!is_same&lt;T, vector&lt;int&gt;&gt;::value, T&gt;::type\nf(T &amp; t) {\n    return t;\n}\n\nint main(int argc, char* argv[])\n{\n    vector&lt;int&gt; v(2);\n    int i = 6;\n\n    f(v);\n    f(i);  // error C2039: 'type' : is not a member of 'GetIter&lt;T&gt;'\n\n    return 0;\n}\n</code></pre>\n<p>EDIT:\nHere is the actual problem I'm trying to solve. The second call to copy() with an iterator as the second argument causes a similar error as above on the boost::mpl::eval_if_c object.</p>\n<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\n#include &lt;boost/range.hpp&gt;\n#include &lt;boost/tti/has_type.hpp&gt;\n\nBOOST_TTI_TRAIT_HAS_TYPE(has_iterator, iterator)\n\ntemplate&lt;typename InCont, typename Out&gt;\ntypename enable_if&lt;has_iterator&lt;Out&gt;::value, typename boost::range_iterator&lt;Out&gt;::type&gt;::type\ncopy(InCont const &amp; in_cont, Out &amp; out_cont)\n{\n    return std::copy(boost::begin(in_cont), boost::end(in_cont), boost::begin(out_cont));\n}\n\ntemplate&lt;typename InCont, typename Out&gt;\ntypename enable_if&lt;!has_iterator&lt;Out&gt;::value, Out&gt;::type\ncopy(InCont const &amp; in_cont, Out &amp; out_iter)\n{\n    return std::copy(boost::begin(in_cont), boost::end(in_cont), out_iter);\n}\n\nint main(int argc, char* argv[])\n{\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n\n    copy(v1, v2);\n    copy(v1, v2.begin());  // error C2039: 'type' : is not a member of 'boost::mpl::eval_if_c&lt;C,F1,F2&gt;'\n\n    return 0;\n}\n</code></pre>\n<p>EDIT 2:\nThe original problem was fixed in a recent version of boost::range_iterator. Once I patched that things got easier. Here's what I've landed on, checking for containers with boost::has_range_iterator:</p>\n<pre><code>#include &lt;vector&gt;\nusing namespace std;\n\n#include &lt;boost/range.hpp&gt;\n\ntemplate&lt;typename InCont, typename Out&gt;\ntypename boost::range_iterator&lt;Out&gt;::type\ncopy(InCont const &amp; in_cont, Out &amp; out_cont)\n{\n    return std::copy(boost::begin(in_cont), boost::end(in_cont), boost::begin(out_cont));\n}\n\ntemplate&lt;typename InCont, typename Out&gt;\ntypename enable_if&lt;!boost::has_range_iterator&lt;Out&gt;::value, Out&gt;::type\ncopy(InCont const &amp; in_cont, Out out_iter)\n{\n    return std::copy(boost::begin(in_cont), boost::end(in_cont), out_iter);\n}\n\nint main(int argc, char* argv[])\n{\n    vector&lt;int&gt; v1;\n    vector&lt;int&gt; v2;\n\n    copy(v1, v2);\n    copy(v1, v2.begin());\n\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "35677486", "Title": "SFINAE with multi-layer type determination", "CreationDate": "2016-02-28T00:31:38.290", "Id": "35677263", "CommentCount": "2", "LastEditDate": "2016-02-28T16:43:07.917", "PostTypeId": "1", "LastEditorUserId": "4581804", "LastActivityDate": "2016-02-28T16:43:07.917", "Score": "1", "OwnerUserId": "4581804", "Tags": "<c++><language-lawyer><sfinae>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_35677263_35677739_0": {"length": 15, "quality": 0.9375, "section_id": 300}}, "n3337": {"so_35677263_35677739_0": {"length": 15, "quality": 0.9375, "section_id": 291}}, "n4659": {"so_35677263_35677739_0": {"length": 15, "quality": 0.9375, "section_id": 307}}}, "35677432": {"Id": "35677432", "PostTypeId": "2", "Body": "<p>I think the non-vector GetIter missed a type function.\n    template \n    struct GetIter {\n        typedef T type;\n    };</p>\n", "LastActivityDate": "2016-02-28T00:56:33.083", "Score": "-1", "CreationDate": "2016-02-28T00:56:33.083", "ParentId": "35677263", "CommentCount": "1", "OwnerUserId": "5968348"}, "35677739": {"Id": "35677739", "PostTypeId": "2", "Body": "<p><strong>Why it doesn't work</strong></p>\n<p>The rule is, from [temp.deduct], emphasis mine:</p>\n<blockquote>\n<p id=\"so_35677263_35677739_0\">Only invalid types and expressions in the <strong>immediate context</strong> of the function type and its template parameter types can result in a deduction failure.</p>\n</blockquote>\n<p>The immediate context is what you see in the declaration itself. The failure that happens when you try to substitute <code>T=int</code> isn't in the immediate context of <code>typename GetIter2&lt;T&gt;::type</code> - the failure happens when trying to determine what that type actually is and seeing that <code>GetIter&lt;int&gt;</code> doesn't have a <code>type</code> member. Since that isn't in the immediate context, this isn't a deduction failure - it's a hard error.</p>\n<p>Note: even if this were a deduction failure, it would still only work for <code>std::vector&lt;int, std::allocator&lt;int&gt;&gt;</code>, not any vector. </p>\n<p><strong>How to make it work</strong></p>\n<p>Actually, you don't need SFINAE at all here. Just have one overload for <code>vector</code> and another overload for everything:</p>\n<pre><code>template &lt;class T, class A&gt;\nauto f(std::vector&lt;T,A&gt;&amp; t) {\n    return t.begin();\n}\n\ntemplate &lt;class T&gt;\nT f(T&amp; t) {\n    return t;\n}\n</code></pre>\n", "LastEditorUserId": "459615", "LastActivityDate": "2016-02-28T01:46:50.513", "Score": "1", "CreationDate": "2016-02-28T01:42:49.900", "ParentId": "35677263", "CommentCount": "5", "LastEditDate": "2016-02-28T01:46:50.513", "OwnerUserId": "2069064"}, "35677486": {"Id": "35677486", "PostTypeId": "2", "Body": "<p>I'm still trying to find the relevant part of the standard to explain why this doesn't work. I think it has something to do with the substitution of <code>GetIter2&lt;T&gt;</code> not failing but subsequently accessing <code>GetIter2&lt;T&gt;::type</code> where it then determines that <code>GetIter&lt;T&gt;::type</code> doesn't exist. By making the <code>GetIter2&lt;T&gt;</code> template fail to substitute right away you don't get the error. You can do that by changing its definition slightly:</p>\n<pre><code>template&lt;typename T, typename ST = typename GetIter&lt;T&gt;::type&gt;\nstruct GetIter2\n{\n    typedef ST type;\n};\n</code></pre>\n<p>I was able to get your real example working without modifying boost types with the following code:</p>\n<pre><code>template&lt;typename InCont, typename Out, typename = typename enable_if&lt;has_iterator&lt;Out&gt;::value&gt;::type&gt;\ntypename boost::range_iterator&lt;Out&gt;::type\ncopy(InCont const &amp; in_cont, Out &amp; out_cont)\n{\n    return std::copy(boost::begin(in_cont), boost::end(in_cont), boost::begin(out_cont));\n}\n</code></pre>\n", "LastEditorUserId": "459615", "LastActivityDate": "2016-02-28T05:03:13.367", "Score": "1", "CreationDate": "2016-02-28T01:08:09.807", "ParentId": "35677263", "CommentCount": "4", "LastEditDate": "2016-02-28T05:03:13.367", "OwnerUserId": "459615"}});