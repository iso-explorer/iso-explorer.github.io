post_cb({"3951916": {"ParentId": "3951209", "CommentCount": "0", "Body": "<p>This ugliness works with Intel C++ 11.0 and perhaps illuminates the compiler's point of view:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\n// *********************\n// forward declare in the global namespace a family of functions named bar\n// taking some argument whose type is still a matter of speculation\n// at this point\ntemplate&lt;class T&gt;\nvoid bar(T x);\n// *********************\n\ntemplate&lt;typename TT&gt;\nvoid foo(std::vector&lt;TT*&gt; &amp;vec)\n{\n   TT *tt;\n   ::bar(tt);\n   vec.push_back(tt);\n}\n\nclass Blah\n{\n  public:\n};\n\nvoid bar(Blah *x)\n{\n  // I like output in my examples so I added this\n  std::cout &lt;&lt; \"Yoo hoo!\" &lt;&lt; std::endl;\n}\n\n// **********************\n// Specialize bar&lt;Blah*&gt;\ntemplate&lt;&gt;\ninline\nvoid bar&lt;Blah*&gt;(Blah *x) { ::bar(x); }\n// **********************\n\nint main(int, char *)\n{\n  std::vector&lt;Blah*&gt; vec;\n  foo(vec);\n\n  return 0;\n}\n</code></pre>\n", "OwnerUserId": "29403", "PostTypeId": "2", "Id": "3951916", "Score": "2", "CreationDate": "2010-10-17T03:38:02.447", "LastActivityDate": "2010-10-17T03:38:02.447"}, "3951382": {"ParentId": "3951209", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>A dependent name still requires a function declaration. Any function declaration with that name will do, but there must be something. How else would the compiler disambiguate an overloaded function call from, say, a misspelled functor object? In other words, finding <em>some</em> function of that name, thus verifying that overloading on that name is possible, instigates the overload resolution process in qualified (or unqualified) name lookup.</p>\n<pre><code>// hello.cpp\n\n#include &lt;vector&gt;\n\nvoid bar(); // Comeau bails without this.\n\ntemplate&lt;typename TT&gt; void foo(std::vector&lt;TT*&gt; &amp;vec)\n{\n    TT *tt;\n    ::bar(tt);\n    vec.push_back(tt);\n}\n\nclass Blah\n{\n};\n\nvoid bar(Blah *&amp;)\n{\n}\n\nint main(int argc, char *argv[])\n{\n    std::vector&lt;Blah*&gt; vec;\n    //foo(vec); - instanting it is certainly an error!\n\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2010-10-17T00:17:27.973", "Id": "3951382", "Score": "1", "CreationDate": "2010-10-17T00:07:35.150", "LastActivityDate": "2010-10-17T00:17:27.973"}, "3952874": {"ParentId": "3951209", "PostTypeId": "2", "CommentCount": "6", "Body": "<blockquote>\n<p id=\"so_3951209_3952874_0\"><em>Nobody has yet pointed out any part of the current Standard that says I can't.</em></p>\n</blockquote>\n<p>C++03 does not make the name <code>::bar</code> dependent. Dependency happens for type names by dependent types, and for non-type names by dependent expressions that are either type or value dependent. If a name is looked up in a dependent type, it becomes a type-dependent id-expression (14.6.2.2/3 last bullet), and its lookup is delayed until instantiation. The name <code>::bar</code> is no such dependent expression. If you were to call <code>bar(tt)</code>, a special rule of C++03 at 14.2.6 says</p>\n<blockquote>\n<p id=\"so_3951209_3952874_1\">In an expression of the form:</p>\n<pre><code>postfix-expression ( expression-listopt )\n</code></pre>\n<p id=\"so_3951209_3952874_2\">where the postfix-expression is an identifier, the identifier denotes a dependent name if and only if any of the expressions in the expression-list is a type-dependent expression (14.6.2.2). </p>\n</blockquote>\n<p>So you need to remove the <code>::</code> in order to make it an identifier and to make it dependent by this special rule.</p>\n<blockquote>\n<p id=\"so_3951209_3952874_3\"><em>The reason I can't remove the :: is that in my real code, the template function foo is a member function of class CC, and there exist a family of overloaded member functions CC::bar(...), meaning I need to qualify ::bar(TT*) to avoid defaulting to CC::bar(...). That's what :: exists for, I'm surprised if the Standard says I can't use :: here</em></p>\n</blockquote>\n<p>The proper way to solve it is to introduce a using declaration into the local scope of your function. </p>\n<pre><code>namespace dummies { void f(); }\ntemplate&lt;typename T&gt;\nstruct S {\n  void f();\n  void g() { \n    using dummies::f; // without it, it won't work\n    f(T()); // with ::f, it won't work\n  }\n};\n\nstruct A { };\nvoid f(A) { } // &lt;- will find this\n\nint main() {\n  S&lt;A&gt; a;\n  a.g();\n}\n</code></pre>\n<p>ADL will not do anything if ordinary lookup finds a class member function. Therefor, you introduce a using declaration, so ordinary lookup doesn't find a class member function, and ADL can advance the declarations visible when instantiating.</p>\n<blockquote>\n<p id=\"so_3951209_3952874_4\"><em>But this seems to disagree with you: Stroustrup TC++PL Sp Ed, Section C.13.8.1, Dependent Names: \"Basically, the name of a function called is dependent if it is obviously dependent by looking at its arguments or at its formal parameters\"</em></p>\n</blockquote>\n<p>Stroustrup's book is also written for people who possibly don't know C++ yet. It won't try to cover all rules with 100% accuracy, as is normal for these books. The gory details are left for ISO Standard readers.</p>\n<p>Also, the formal parameters of a function have nothing to do with whether a function call is dependent or not. In the IS, only actual arguments define dependency of a function name. This was different in <a href=\"http://wwwold.dkuug.dk/JTC1/SC22/WG21/docs/wp/txt/jun96/body.txt\" rel=\"nofollow\">an old draft from 1996</a>, which had the notion of <em>implicit</em> and <em>explicit</em> dependency. Implicitly dependency was defined as</p>\n<blockquote>\n<p id=\"so_3951209_3952874_5\">A name implicitly depends on a template-argument if it is  a  function\n  name  used  in a function call and the function call would have a dif-\n  ferent resolution or no resolution if a type, template, or  enumerator\n  mentioned in the template-argument were missing from the program.</p>\n<p id=\"so_3951209_3952874_6\">[...]</p>\n<p id=\"so_3951209_3952874_7\">[Example: some calls that depend on a template-argument type T are:</p>\n<ol>\n<li><p id=\"so_3951209_3952874_8\">The function called has a parameter that depends on T  according  to\n  the  type  deduction  rules  (<em>temp.deduct</em>).   For  example,  f(T),\n  f(Array), and f(const T*).</p></li>\n<li><p id=\"so_3951209_3952874_9\">The type of the actual argument depends on T.  For example, f(T(1)),\n  f(t), f(g(t)), and f(&amp;t) assuming that t has the type T.</p></li>\n</ol>\n</blockquote>\n<p>A practical example is also given</p>\n<blockquote>\n<p id=\"so_3951209_3952874_10\">This ill-formed template instantiation uses a function that does not\n  depend on a template-argument:</p>\n<pre><code>template&lt;class T&gt; class Z {\npublic:\n        void f() const\n        {\n                g(1); // g() not found in Z's context.\n                      // Look again at point of instantiation\n        }\n};\n\nvoid g(int);\nvoid h(const Z&lt;Horse&gt;&amp; x)\n{\n        x.f(); // error: g(int) called by g(1) does not depend\n               // on template-argument ``Horse''\n}\n</code></pre>\n<p id=\"so_3951209_3952874_11\">The call x.f() gives rise to the specialization:</p>\n<pre><code>void Z&lt;Horse&gt;::f() { g(1); }\n</code></pre>\n<p id=\"so_3951209_3952874_12\">The call g(1) would call g(int), but since that call does not depend\n  on the template-argument Horse and because g(int) was not in scope at\n  the point of the definition of the template, the call x.f() is  ill-\n  formed.</p>\n<p id=\"so_3951209_3952874_13\">On the other hand:</p>\n<pre><code>void h(const Z&lt;int&gt;&amp; y)\n{\n        y.f(); // fine: g(int) called by g(1) depends\n               // on template-argument ``int''\n}\n</code></pre>\n<p id=\"so_3951209_3952874_14\">Here, the call y.f() gives rise to the specialization:</p>\n<pre><code>void Z&lt;int&gt;::f() { g(1); }\n</code></pre>\n<p id=\"so_3951209_3952874_15\">The  call  g(1)  calls g(int), and since that call depends on the tem-\n  plate-argument int, the call y.f() is acceptable  even  though  g(int)\n  wasn't in scope at the point of the template definition.  ]</p>\n</blockquote>\n<p>These things are left to history, and even the last traces from it are disappearing slowly, albeit not actively driven (n3126 for instance gets rid of \"explicitly depends\" at [temp.names]/p4 as a side-effect of another change, because the distinction between \"explicitly depends\" and \"implicitly depends\" has never existed in the IS).</p>\n", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2016-10-08T20:22:58.233", "Id": "3952874", "Score": "5", "CreationDate": "2010-10-17T10:44:12.247", "LastActivityDate": "2016-10-08T20:22:58.233"}, "3951278": {"ParentId": "3951209", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Your code works fine on VS2005. <del>so it indeed seems like a bug in gcc. (I don't know what the specs say about this, maybe someone will come along and post it.)</del></p>\n<p>As for gcc, I also tried defining a different overload of <code>bar</code> before <code>foo</code>, so that the symbol <code>bar</code> is at least defined:</p>\n<pre><code>void bar(float *) {\n}\n\ntemplate&lt;typename TT&gt; void foo(std::vector&lt;TT*&gt; &amp;vec)\n{\n    TT *tt;\n    ::bar(tt);\n    vec.push_back(tt);\n}\n\nvoid bar(int *) {\n}\n\nint main(int argc, char *argv[])\n{\n    std::vector&lt;int*&gt; vec;\n    foo(vec);\n\n    return 0;\n}\n</code></pre>\n<p>but gcc is still totally blind to the <code>int *</code> overload:</p>\n<blockquote>\n<p id=\"so_3951209_3951278_0\">error: cannot convert int* to float* for argument 1 to void bar(float*)</p>\n</blockquote>\n<p>It seems gcc will only use those functions that are defined before the template itself.</p>\n<p>However, if you remove the explicit <code>::</code> specifier and make it just <code>bar(tt)</code>, it seems to work fine. Chris Dodd's answer seems satisfactory in explaining why this is so.</p>\n", "OwnerUserId": "381345", "LastEditorUserId": "381345", "LastEditDate": "2010-10-17T03:05:23.320", "Id": "3951278", "Score": "0", "CreationDate": "2010-10-16T23:29:42.627", "LastActivityDate": "2010-10-17T03:05:23.320"}, "3951209": {"CommentCount": "3", "AcceptedAnswerId": "3952874", "PostTypeId": "1", "LastEditorUserId": "478223", "CreationDate": "2010-10-16T23:11:04.417", "LastActivityDate": "2016-10-08T20:22:58.233", "LastEditDate": "2010-10-17T19:46:00.753", "ViewCount": "1046", "FavoriteCount": "0", "Title": "In C++ template function, why does dependent function call give \"not declared\" error?", "Id": "3951209", "Score": "5", "Body": "<p>Inside a C++ template function foo(), a call to ::bar(TT*) gives the following error under gcc 4.4.3:</p>\n<pre><code>g++ -o hello.o -c -g hello.cpp\nhello.cpp: In function 'void foo(std::vector&lt;TT*, std::allocator&lt;TT*&gt; &gt;&amp;)':\nhello.cpp:8: error: '::bar' has not been declared\n</code></pre>\n<p>Here's the offending code:</p>\n<pre><code>// hello.cpp\n\n#include &lt;vector&gt;\n\ntemplate&lt;typename TT&gt; void foo(std::vector&lt;TT*&gt; &amp;vec)\n{\n    TT *tt;\n    ::bar(tt);\n    vec.push_back(tt);\n}\n\nclass Blah\n{\n};\n\nvoid bar(Blah *&amp;)\n{\n}\n\nint main(int argc, char *argv[])\n{\n    std::vector&lt;Blah*&gt; vec;\n    foo(vec);\n\n    return 0;\n}\n</code></pre>\n<p>C++ distinguishes between symbols that are dependent on the template parameter (TT, here) and those symbols that are independent and can be evaluated immediately.</p>\n<p>Clearly, the compiler thinks my ::bar(TT*) call is independent and tries to resolve it immediately. Just as clearly, that function call <strong>is</strong> dependent on TT because the function call takes a parameter of type TT*, so the compiler should wait until the foo(vec) instantiation to resolve ::bar(TT*).</p>\n<p>Is this a gcc bug or am I missing something subtle about C++ templates?</p>\n<p>EDIT: here's a slightly more complicated example with two versions of ::bar() to clarify that declaration order is not the issue with my problem. When parsing the template, the compiler has <strong>no</strong> way of knowing if main() down below is going to instantiate the template function with TT=Blah or with TT=Argh. Therefore the compiler should not be giving an error until <strike>line 35</strike> line 28 at the earliest (if ever). But the error is given for <strike>line 8</strike> line 16.</p>\n<p>EDIT #2: improved this example.</p>\n<p>EDIT #3: added corrections to this example to make it work as desired. The bar(tt) now correctly refers to bar(Blah*). Rationale given below. (Thanks everyone).</p>\n<pre><code>// hello.cpp\n#include &lt;vector&gt;\n\nclass XX {};\nvoid bar(XX*) {}\n\nclass CC {\npublic:\n    void bar();\n    void bar(int *);\n    void bar(float *);\n\n    template&lt;typename TT&gt; static void foo(std::vector&lt;TT*&gt; &amp;vec);\n};\n\ntemplate&lt;typename TT&gt;\nvoid CC::foo(std::vector&lt;TT*&gt; &amp;vec) {\n    using ::bar;\n    TT *tt;\n    bar(tt);\n    vec.push_back(tt);\n}\n\nclass Argh {};\nvoid bar(Argh *&amp;aa) { aa = new Argh; }\n\nclass Blah {};\nvoid bar(Blah *&amp;bb) { bb = new Blah; }\n\nint main(int argc, char *argv[]) {\n    std::vector&lt;Blah*&gt; vec;\n    CC::foo(vec);\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "478223", "AnswerCount": "6"}, "3951225": {"ParentId": "3951209", "CommentCount": "9", "Body": "<p>This should work, your problem is the declaration order:</p>\n<pre><code>// hello.cpp\n\n#include &lt;vector&gt;\n\n\nclass Blah\n{\npublic:\n\n};\n\nvoid bar(Blah *&amp;)\n{ }\n\ntemplate&lt;typename TT&gt; void foo(std::vector&lt;TT*&gt; &amp;vec)\n{\n    TT *tt;\n    ::bar(tt);\n    vec.push_back(tt);\n}\n\n\nint main(int argc, char *argv[])\n{\n    std::vector&lt;Blah*&gt; vec;\n    foo(vec);\n\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "179372", "PostTypeId": "2", "Id": "3951225", "Score": "1", "CreationDate": "2010-10-16T23:16:56.943", "LastActivityDate": "2010-10-16T23:16:56.943"}, "bq_ids": {"n4140": {"so_3951209_3951339_1": {"section_id": 188, "quality": 0.7142857142857143, "length": 10}, "so_3951209_3952874_10": {"section_id": 300, "quality": 0.5555555555555556, "length": 5}, "so_3951209_3952874_2": {"section_id": 188, "quality": 0.6666666666666666, "length": 8}}, "n3337": {"so_3951209_3951339_1": {"section_id": 182, "quality": 0.5714285714285714, "length": 8}, "so_3951209_3952874_10": {"section_id": 291, "quality": 0.5555555555555556, "length": 5}, "so_3951209_3952874_2": {"section_id": 182, "quality": 0.6666666666666666, "length": 8}}, "n4659": {"so_3951209_3951339_1": {"section_id": 193, "quality": 0.6428571428571429, "length": 9}, "so_3951209_3952874_10": {"section_id": 180, "quality": 0.5555555555555556, "length": 5}, "so_3951209_3952874_2": {"section_id": 193, "quality": 0.5833333333333334, "length": 7}}}, "3951339": {"ParentId": "3951209", "CommentCount": "10", "Body": "<p>From section 14.7.2 of the C++ spec:</p>\n<blockquote>\n<p id=\"so_3951209_3951339_0\">In an expression of the form:</p>\n</blockquote>\n<pre><code>    postfix-expression ( expression-listopt )\n</code></pre>\n<blockquote>\n<p id=\"so_3951209_3951339_1\">where the postfix-expression is an unqualified-id but not a template-id , the unqualified-id denotes a dependent\n  name if and only if any of the expressions in the expression-list is a type-dependent expression (14.7.2.2).</p>\n</blockquote>\n<p>since <code>::b</code> is not an unqualified id, it is not a dependent name.  If you remove the <code>::</code>, it is an unqualified name and so is a dependent name.  For a non-dependent name, the lookup occurs at the point of the template declaration, not the instantiation, and at that point there is no global declaration of <code>bar</code> visible, so you get an error.</p>\n", "OwnerUserId": "16406", "PostTypeId": "2", "Id": "3951339", "Score": "5", "CreationDate": "2010-10-16T23:53:13.910", "LastActivityDate": "2010-10-16T23:53:13.910"}});