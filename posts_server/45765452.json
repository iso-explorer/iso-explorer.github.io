post_cb({"45765660": {"Id": "45765660", "PostTypeId": "2", "Body": "<p>You find the definition of subscripting, i.e. an expression like <code>ptr2[5]</code> in the c++ standard, e.g. like in <a href=\"https://timsong-cpp.github.io/cppwp/n3337/expr.sub#1\" rel=\"nofollow noreferrer\">this online c++ draft standard</a>:</p>\n<blockquote>\n<p id=\"so_45765452_45765660_0\">5.2.1 Subscripting [expr.sub]</p>\n<p id=\"so_45765452_45765660_1\">(1) ...  The expression E1[E2] is identical (by definition) to\n  *((E1)+(E2))</p>\n</blockquote>\n<p>So your \"discovery\" sounds correct, although your examples seem to have some bugs (e.g. <code>ptr2[5]</code> should not return an address but an int value, whereas <code>ptr2+5</code> is an address an not an int value; I suppose you meant <code>&amp;ptr2[5]</code>).</p>\n<p>Further, your code is not a prove of this discovery as it is based on undefined behaviour. It <em>may</em> yield something that supports your \"discovery\", but your discovery could still be not valid, and it could also do the opposite (really!).</p>\n<p>The reason why it is undefined behaviour is that even <a href=\"https://timsong-cpp.github.io/cppwp/n3337/expr.add#6\" rel=\"nofollow noreferrer\">pointer arithmetics</a> like <code>ptr2+5</code> is undefined behaviour if the result is out of the range of the allocated memory block <code>ptr2</code> points to (which is definitely the case in your example):</p>\n<blockquote>\n<p id=\"so_45765452_45765660_2\">5.7 Additive operators</p>\n<p id=\"so_45765452_45765660_3\">(6) ... Unless both pointers point to elements of the same array\n  object, or one past the last element of the array object, the behavior\n  is undefined.</p>\n</blockquote>\n<p>Different compilers, different optimization settings, and even slight modifications anywhere in your program may let the compiler do other things here.</p>\n", "LastEditorUserId": "2630032", "LastActivityDate": "2017-08-18T22:21:09.380", "Score": "3", "CreationDate": "2017-08-18T22:13:19.777", "ParentId": "45765452", "CommentCount": "0", "OwnerUserId": "2630032", "LastEditDate": "2017-08-18T22:21:09.380"}, "bq_ids": {"n4140": {"so_45765452_45765660_3": {"length": 15, "quality": 0.9375, "section_id": 6143}, "so_45765452_45765660_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 5986}}, "n3337": {"so_45765452_45765660_3": {"length": 15, "quality": 0.9375, "section_id": 5907}, "so_45765452_45765660_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 5754}}, "n4659": {"so_45765452_45765660_3": {"length": 9, "quality": 0.5625, "section_id": 7639}, "so_45765452_45765660_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 7486}}}, "45765580": {"Id": "45765580", "PostTypeId": "2", "Body": "<p>An array in C++ is a collection of objects.  A pointer is a variable that can store the address of something.   The two are not the same thing.</p>\n<p>Unfortunately, your sample</p>\n<blockquote id=\"so_45765452_45765580_0\">\n<pre><code>int num = 6;\nint* ptr2 = &amp;num;\ncout &lt;&lt; ptr2[5];\ncout &lt;&lt; ptr2 + 5;\n</code></pre>\n</blockquote>\n<p>exhibits undefined behaviour, both in the evaluation of <code>ptr2[5]</code> and <code>ptr2 + 5</code>.    Pointer expressions are special - arithmetic involving pointers only has defined behaviour if the pointer being acted on (<code>ptr2</code> in this case) and the result (<code>ptr2 + 5</code>) are within the same object.   Or one past the end (although dereferencing a \"one past the end\" pointer - trying to access the value it points at - also gives undefined behaviour).</p>\n<p>Semantically, <code>*(ptr + n)</code> and <code>ptr[n]</code> are equivalent (i.e. they have the same meaning) if <code>ptr</code> is a pointer and <code>n</code> is an integral value.  So if evaluating <code>ptr + n</code> gives undefined behaviour, so does evaluating <code>ptr[n]</code>.     Similarly, <code>&amp;ptr[n]</code> and <code>ptr + n</code> are equivalent.</p>\n<p>In expressions, depending on context, the name of an array is <em>converted to</em> a pointer, and that pointer is equal to the address of that array's first element.   So, given</p>\n<pre><code>  int x[5];\n  int *p;\n     // the following all have the same effect\n\n  p = x + 2;\n  p = &amp;x[0] + 2;\n  p = &amp;x[2];\n</code></pre>\n<p>That does not mean an array is a pointer though.</p>\n", "LastActivityDate": "2017-08-18T22:04:19.177", "CommentCount": "0", "CreationDate": "2017-08-18T22:04:19.177", "ParentId": "45765452", "Score": "2", "OwnerUserId": "4706785"}, "45765452": {"ViewCount": "68", "Body": "<p>I've been studying C++ for couple of months now and just recently decided to look more deeply into the logic of pointers and arrays. What I've been taught in uni is pretty basic - pointers contain the address of a variable. When an array is created, basically a pointer to its first element is created.</p>\n<p>So I started experimenting a bit. (and got to a conclusion which I need confirmation for). First of all I created </p>\n<pre><code>int arr[10];\nint* ptr = &amp;arr[5];\n</code></pre>\n<p>And as you would imagine </p>\n<pre><code>cout &lt;&lt; ptr[3];\n</code></pre>\n<p>gave me the 8th element of the array. Next I tried</p>\n<pre><code>int num = 6;\nint* ptr2 = &amp;num;\ncout &lt;&lt; ptr2[5];\ncout &lt;&lt; ptr2 + 5;\n</code></pre>\n<p>which to my great delight (not irony) returned the same addresses. Even though num wasn't an array.</p>\n<p>The conclusion to which I got: array is not something special in C++. It's just a pointer to the first element (already typed that). More important: Can I think about every pointer in the manner of object of a <code>class variable*</code>. Is the <code>operator []</code> just overloaded in the <code>class int*</code>? For example to be something along the lines of:</p>\n<pre><code>int operator[] (int index){\n    return *(arrayFirstaddress + index);\n}\n</code></pre>\n<p>What was interesting to me in these experiments is that <code>operator []</code> works for EVERY pointer. (So it's exactly like overloading an operator for all instances of the said class)</p>\n<p>Of course, I can be as wrong as possible. I couldn't find much information in the web, since I didn't know how to word my question so I decided to ask here.\nIt would be extremely helpful if you explained to me if I'm right/wrong/very wrong and why.  </p>\n", "AcceptedAnswerId": "45765660", "Title": "Internal logic of operator [] when dealing with pointers", "CreationDate": "2017-08-18T21:48:20.413", "Id": "45765452", "CommentCount": "6", "LastEditDate": "2017-08-18T21:57:45.777", "PostTypeId": "1", "LastEditorUserId": "3313438", "LastActivityDate": "2017-08-18T22:50:27.237", "Score": "2", "OwnerUserId": "6247390", "Tags": "<c++><arrays><pointers>", "AnswerCount": "2"}});