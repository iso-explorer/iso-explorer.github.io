post_cb({"14659752": {"CommentCount": "18", "ViewCount": "790", "PostTypeId": "1", "LastEditorUserId": "1698548", "CreationDate": "2013-02-02T07:38:27.213", "LastActivityDate": "2013-02-02T09:09:46.997", "Title": "Placement new and uninitialized POD members", "FavoriteCount": "3", "LastEditDate": "2013-02-02T07:43:44.623", "Id": "14659752", "Score": "13", "Body": "<p>Does the C++ standard guarantee that uninitialized POD members retain their previous value after a placement new?</p>\n<p>Or more precisely, will the following assert always be satisfied according to C++11?</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cassert&gt;\n\nstruct Foo {\n    int alpha; // NOTE: Uninitialized\n    int beta = 0;\n};\n\nint main()\n{\n    void* p = std::malloc(sizeof (Foo));\n    int i = some_random_integer();\n    static_cast&lt;Foo*&gt;(p)-&gt;alpha = i;\n    new (p) Foo;\n    assert(static_cast&lt;Foo*&gt;(p)-&gt;alpha == i);\n}\n</code></pre>\n<p>Is the answer the same for C++03?</p>\n", "Tags": "<c++><initialization><placement-new>", "OwnerUserId": "1698548", "AnswerCount": "2"}, "14659931": {"ParentId": "14659752", "PostTypeId": "2", "CommentCount": "8", "Body": "<blockquote>\n<p id=\"so_14659752_14659931_0\">Does the C++ standard guarantee that uninitialized POD members retain their previous value after a placement new?</p>\n<p id=\"so_14659752_14659931_1\">Will the following assert always be satisfied according to C++11?</p>\n</blockquote>\n<p><strong>No.</strong></p>\n<p>Uninitialized data members have an <em>indeterminate</em> value, and this is not at all the same as saying that the underlying memory is left alone.</p>\n<blockquote>\n<p id=\"so_14659752_14659931_2\"><code>[C++11: 5.3.4/15]:</code> A <em>new-expression</em> that creates an object of type <code>T</code> initializes that object as follows:</p>\n<ul>\n<li><strong>If the <em>new-initializer</em> is omitted, the object is <em>default-initialized</em></strong> (8.5); if no initialization is performed, the object has indeterminate value.</li>\n<li>Otherwise, the <em>new-initializer</em> is interpreted according to the initialization rules of 8.5 for direct-initialization.</li>\n</ul>\n<p id=\"so_14659752_14659931_3\"><code>[C++11: 8.5/6]:</code> To default-initialize an object of type <code>T</code> means:</p>\n<ul>\n<li><strong>if <code>T</code> is a</strong> (possibly <em>cv-qualified</em>) <strong>class type</strong> (Clause 9), <strong>the default constructor for <code>T</code> is called</strong> (and the initialization is ill-formed if <code>T</code> has no accessible default constructor);</li>\n<li>if <code>T</code> is an array type, each element is default-initialized;</li>\n<li>otherwise, no initialization is performed.</li>\n</ul>\n<p id=\"so_14659752_14659931_4\"><code>[C++11: 12.1/6]:</code> A default constructor that is defaulted and not defined as deleted is implicitly defined when it is <em>odr-used</em> (3.2) to create an object of its class type (1.8) or when it is explicitly defaulted after its first declaration. <strong>The implicitly-defined default constructor performs the set of initializations of the class that would be\n  performed by a user-written default constructor for that class with no <em>ctor-initializer</em> (12.6.2) and an empty <em>compound-statement</em>.</strong></p>\n<p id=\"so_14659752_14659931_5\"><code>[C++11: 12.6.2/8]:</code> In a non-delegating constructor, <strong>if a given non-static data member</strong> or base class <strong>is not designated by a <em>mem-initializer-id</em></strong> (including the case where there is no <em>mem-initializer-list</em> because the constructor has no <em>ctor-initializer</em>) and the entity is not a virtual base class of an abstract class (10.4), then</p>\n<ul>\n<li>if the entity is a non-static data member that has a <em>brace-or-equal-initializer</em>, the entity is initialized as specified in 8.5;</li>\n<li>otherwise, if the entity is a variant member (9.5), no initialization is performed;</li>\n<li><strong>otherwise, the entity is default-initialized</strong> (8.5).</li>\n</ul>\n</blockquote>\n<p><sup>(<strong>NB.</strong> the first option in <code>12.6.2/8</code> is how your member <code>beta</code> is handled)</sup></p>\n<blockquote>\n<p id=\"so_14659752_14659931_6\"><code>[C++11: 8.5/6]:</code> To default-initialize an object of type <code>T</code> means:</p>\n<ul>\n<li>if <code>T</code> is a (possibly <em>cv-qualified</em>) class type (Clause 9), the default constructor for <code>T</code> is called (and the initialization is ill-formed if <code>T</code> has no accessible default constructor);</li>\n<li>if <code>T</code> is an array type, each element is default-initialized;</li>\n<li><strong>otherwise, no initialization is performed.</strong></li>\n</ul>\n<p id=\"so_14659752_14659931_7\"><code>[C++11: 8.5/11]:</code> If no initializer is specified for an object, the object is default-initialized; <strong>if no initialization is performed, an object with automatic or dynamic storage duration has indeterminate value.</strong></p>\n</blockquote>\n<p>A compiler could choose to zero-out (or otherwise alter) the underlying memory during allocation. For example, Visual Studio in debug mode is known to write recognisable values such as <code>0xDEADBEEF</code> into memory to aid debugging; in this case, you're likely to see <code>0xCDCDCDCD</code> which they use to mean \"clean memory\" (<a href=\"https://stackoverflow.com/a/370362/560648\">reference</a>).</p>\n<p><em>Will</em> it, in this case? I don't know. I don't think that we <em>can</em> know.</p>\n<p>What we <em>do</em> know is that C++ doesn't prohibit it, and I believe that brings us to the conclusion of this answer. :)</p>\n<hr>\n<blockquote>\n<p id=\"so_14659752_14659931_8\">Is the answer the same for C++03?</p>\n</blockquote>\n<p><strong>Yes</strong>, though through slightly different logic:</p>\n<blockquote>\n<p id=\"so_14659752_14659931_9\"><code>[C++03: 5.3.4/15]:</code> A <em>new-expression</em> that creates an object of type <code>T</code> initializes that object as follows:</p>\n<ul>\n<li><strong>If the <em>new-initializer</em> is omitted</strong>:\n  \n  <ul>\n<li><strong>If <code>T</code> is a</strong> (possibly <em>cv-qualified</em>) <strong>non-POD class type</strong> (or array thereof), the object is default-initialized (8.5). If <code>T</code> is a const-qualified type, the underlying class type shall have a user-declared default constructor.</li>\n<li><strong>Otherwise, the object created has indeterminate value.</strong> If <code>T</code> is a const-qualified type, or a (possibly <em>cv-qualified</em>) POD class type (or array thereof) containing (directly or indirectly) a member of const-qualified type, the program is ill-formed;</li>\n</ul></li>\n<li>If the <em>new-initializer</em> is of the form <code>()</code>, the item is value-initialized (8.5);</li>\n<li>If the <em>new-initializer</em> is of the form <code>(expression-list)</code> and <code>T</code> is a class type, the appropriate constructor is called, using <code>expression-list</code> as the arguments (8.5);</li>\n<li>If the <em>new-initializer</em> is of the form <code>(expression-list)</code> and <code>T</code> is an arithmetic, enumeration, pointer, or pointer-to-member type and <code>expression-list</code> comprises exactly one expression, then the object is initialized to the (possibly converted) value of the expression (8.5);</li>\n<li>Otherwise the <em>new-expression</em> is ill-formed.</li>\n</ul>\n</blockquote>\n<hr>\n<p>Now, all that was my <em>strict</em> interpretation of the rules of initialisation.</p>\n<p>Speaking practically, I think you're probably correct in seeing a potential conflict with the definition of placement <code>operator new</code> syntax:</p>\n<blockquote>\n<p id=\"so_14659752_14659931_10\"><code>[C++11: 18.6.1/3]:</code> <strong>Remarks:</strong> Intentionally performs no other action.</p>\n</blockquote>\n<p>An example that follows explains that placement <code>new</code> \"can be useful for constructing an object at a known address\".</p>\n<p>However, it doesn't actually talk about the common use of constructing an object at a known address <em>without mungling the values that were already there</em>, but the phrase \"performs no other action\" does suggest that the intention is that your \"indeterminate value\" be whatever was in memory previously.</p>\n<p>Alternatively, it may simply prohibit the <em>operator</em> itself from taking any action, leaving the allocator free to. It <em>does</em> seem to me that the important point the standard trying to make is that no new memory is allocated.</p>\n<p>Regardless, accessing this data invokes undefined behaviour:</p>\n<blockquote>\n<p id=\"so_14659752_14659931_11\"><code>[C++11: 4.1/1]:</code> A glvalue (3.10) of a non-function, non-array type <code>T</code> can be converted to a prvalue. If <code>T</code> is an incomplete type, a program that necessitates this conversion is ill-formed. If the object to which the glvalue refers is not\n  an object of type <code>T</code> and is not an object of a type derived from <code>T</code>, or <strong>if the object is uninitialized, a program that necessitates this conversion has undefined behavior</strong>. If <code>T</code> is a non-class type, the type of the prvalue is the cv-unqualified version of <code>T</code>. Otherwise, the type of the prvalue is <code>T</code>.</p>\n</blockquote>\n<p>So <em>it doesn't really matter</em>: <strong>you couldn't compliantly observe the original value anyway</strong>.</p>\n</hr></hr>", "OwnerUserId": "560648", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:13:58.200", "Id": "14659931", "Score": "20", "CreationDate": "2013-02-02T08:05:48.270", "LastActivityDate": "2013-02-02T09:09:46.997"}, "bq_ids": {"n4140": {"so_14659752_14659881_1": {"section_id": 3286, "quality": 1.0, "length": 4}, "so_14659752_14659931_6": {"section_id": 3286, "quality": 0.6666666666666666, "length": 4}, "so_14659752_14659931_2": {"section_id": 6098, "quality": 0.7777777777777778, "length": 7}, "so_14659752_14659931_7": {"section_id": 3291, "quality": 0.75, "length": 12}, "so_14659752_14659931_9": {"section_id": 6098, "quality": 0.7777777777777778, "length": 7}, "so_14659752_14659931_3": {"section_id": 3286, "quality": 0.6666666666666666, "length": 4}, "so_14659752_14659931_10": {"section_id": 6859, "quality": 0.5714285714285714, "length": 4}, "so_14659752_14659931_4": {"section_id": 370, "quality": 0.8780487804878049, "length": 36}, "so_14659752_14659931_5": {"section_id": 435, "quality": 0.6071428571428571, "length": 17}, "so_14659752_14659931_11": {"section_id": 8, "quality": 0.5263157894736842, "length": 20}, "so_14659752_14659881_0": {"section_id": 435, "quality": 0.6538461538461539, "length": 17}}, "n3337": {"so_14659752_14659881_1": {"section_id": 3156, "quality": 1.0, "length": 4}, "so_14659752_14659931_5": {"section_id": 427, "quality": 0.8928571428571429, "length": 25}, "so_14659752_14659931_2": {"section_id": 5864, "quality": 0.7777777777777778, "length": 7}, "so_14659752_14659931_7": {"section_id": 3161, "quality": 0.875, "length": 14}, "so_14659752_14659931_9": {"section_id": 5864, "quality": 0.7777777777777778, "length": 7}, "so_14659752_14659931_3": {"section_id": 3156, "quality": 0.6666666666666666, "length": 4}, "so_14659752_14659931_10": {"section_id": 6605, "quality": 0.5714285714285714, "length": 4}, "so_14659752_14659931_4": {"section_id": 360, "quality": 0.8780487804878049, "length": 36}, "so_14659752_14659931_6": {"section_id": 3156, "quality": 0.6666666666666666, "length": 4}, "so_14659752_14659931_11": {"section_id": 5, "quality": 0.9210526315789473, "length": 35}, "so_14659752_14659881_0": {"section_id": 427, "quality": 0.9615384615384616, "length": 25}}, "n4659": {"so_14659752_14659931_5": {"section_id": 454, "quality": 0.6071428571428571, "length": 17}, "so_14659752_14659931_2": {"section_id": 7595, "quality": 0.7777777777777778, "length": 7}, "so_14659752_14659931_7": {"section_id": 4053, "quality": 0.75, "length": 12}, "so_14659752_14659931_10": {"section_id": 8351, "quality": 0.5714285714285714, "length": 4}, "so_14659752_14659931_9": {"section_id": 7595, "quality": 0.7777777777777778, "length": 7}, "so_14659752_14659881_0": {"section_id": 454, "quality": 0.6538461538461539, "length": 17}, "so_14659752_14659931_11": {"section_id": 8, "quality": 0.5263157894736842, "length": 20}, "so_14659752_14659931_4": {"section_id": 384, "quality": 0.8780487804878049, "length": 36}}}, "14659881": {"ParentId": "14659752", "CommentCount": "27", "Body": "<p>C++11 12.6.2/8 \"Initializing bases and members\" says:</p>\n<blockquote>\n<p id=\"so_14659752_14659881_0\">In a non-delegating constructor, if a given non-static data member or\n  base class is not designated by a mem-initializer-id (including the\n  case where there is no mem-initializer-list because the constructor\n  has no ctor-initializer) and the entity is not a virtual base class of\n  an abstract class (10.4), then</p>\n<ul>\n<li>if the entity is a non-static data member that has a brace-or-equal-initializer, the entity is initialized as specified in\n  8.5;</li>\n<li>otherwise, if the entity is a variant member (9.5), no initialization is performed;</li>\n<li><strong>otherwise, the entity is default-initialized</strong> (8.5).</li>\n</ul>\n</blockquote>\n<p>Default initialization on an <code>int</code> does nothing (8.5/6 \"Initializers\"):</p>\n<blockquote>\n<p id=\"so_14659752_14659881_1\">To default-initialize an object of type T means:</p>\n<ul>\n<li>if T is a (possibly cv-qualified) class type (Clause 9), the default constructor for T is called (and the initialization is\n  ill-formed if T has no accessible default constructor);</li>\n<li>if T is an array type, each element is default-initialized;</li>\n<li><strong>otherwise, no initialization is performed</strong>.</li>\n</ul>\n</blockquote>\n<p>So the member <code>alpha</code> should be left alone.</p>\n", "OwnerUserId": "12711", "PostTypeId": "2", "Id": "14659881", "Score": "0", "CreationDate": "2013-02-02T07:58:43.733", "LastActivityDate": "2013-02-02T07:58:43.733"}});