post_cb({"14534316": {"CommentCount": "3", "ViewCount": "1952", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-01-26T05:56:18.843", "LastActivityDate": "2013-01-26T07:04:43.017", "Title": "use of undeclared identifier with templates and inheritance followup", "AcceptedAnswerId": "14534441", "LastEditDate": "2017-05-23T10:27:09.520", "Id": "14534316", "Score": "5", "Body": "<p>I had the same problem as this previous question here:\n<a href=\"https://stackoverflow.com/questions/10735611/use-of-undeclared-identifier-in-c-with-templates-and-inheritance\">Use of undeclared identifier in C++ with templates and inheritance</a></p>\n<p>To sum it up, we try to access a template class' protected attribute from a child class. The described way to do this would be to use <code>this-&gt;attribute</code> instead of only <code>attribute</code>.\nThe thing is, I was wondering how come visual studio 2012 didn't need to add the this-&gt; in front of the variable reference for the program to compile and execute properly. I was also wondering if there was a way to have that feature in gcc or other compilers on OS X.</p>\n<p>EDIT:\nHere is the code I used to test this out in visual studio 2012.</p>\n<pre><code>//file a.h\n\ntemplate&lt;class T&gt;\nclass a\n{\npublic:\n    a(){value = 2;};\nprotected:\n    T value;\n};\n\ntemplate&lt;class T&gt;\nclass b: public a&lt;T&gt;\n{\npublic:\n    T getValue(){return value;};\n};\n\n//file main.cpp\n#include &lt;iostream&gt;\n#include \"a.h\"\nusing namespace std;\nint main()\n{\n    b&lt;int&gt; myTest;\n    cout&lt;&lt;myTest.getValue();\n    system(\"pause\");\n    return 0;\n}\n</code></pre>\n<p>This doesn't compile using g++ but does using visual studio 2012.</p>\n", "Tags": "<c++><osx><gcc><compilation><visual-studio-2012>", "OwnerUserId": "1936009", "AnswerCount": "1"}, "14534441": {"ParentId": "14534316", "CommentCount": "5", "Body": "<p>I believe the part of the standard that describes argument dependent lookup rule applicable in this case is \u00a714.6.2/3, which states the following:</p>\n<blockquote>\n<p id=\"so_14534316_14534441_0\">In the definition of a class template or a member of a class template,\n  if a base class of the class template depends on a template-parameter,\n  the base class scope is not examined during unqualified name lookup\n  either at the point of definition of the class template or member or\n  during an instantiation of the class template or member.</p>\n</blockquote>\n<p>Since your base class depends on a template parameter, the dependent base class scope should not be examined. However, some compilers had this wrong. For example, GCC was doing extra dependent base class scope lookups, which was <a href=\"http://gcc.gnu.org/gcc-4.7/porting_to.html\" rel=\"nofollow\">fixed only in version 4.7</a> (Bug# <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=24163\" rel=\"nofollow\">24163</a>, <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=29131\" rel=\"nofollow\">29131</a>). I do not have an insight as for why Visual Studio compiler allows it. But if it does then it is clearly not standard compliant in this regard. You should not depend on that bug and definitely should not look for compilers with similar bugs to depend on.</p>\n", "Id": "14534441", "PostTypeId": "2", "OwnerDisplayName": "user405725", "Score": "4", "CreationDate": "2013-01-26T06:18:18.837", "LastActivityDate": "2013-01-26T06:18:18.837"}, "bq_ids": {"n4140": {"so_14534316_14534441_0": {"section_id": 190, "quality": 0.8709677419354839, "length": 27}}, "n3337": {"so_14534316_14534441_0": {"section_id": 184, "quality": 0.8709677419354839, "length": 27}}, "n4659": {"so_14534316_14534441_0": {"section_id": 195, "quality": 0.7096774193548387, "length": 22}}}});