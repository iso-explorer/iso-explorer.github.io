post_cb({"24060303": {"ParentId": "24059738", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-06-05T12:31:32.333", "Score": "9", "LastEditorUserId": "420683", "LastEditDate": "2014-06-05T12:40:24.003", "Id": "24060303", "OwnerUserId": "420683", "Body": "<p>Let's use an even simpler example:</p>\n<pre><code>template&lt;class T&gt;\nvoid foo(T, T);\n\nfoo(42, {});\n</code></pre>\n<p>The function call has two arguments:</p>\n<ul>\n<li>a prvalue expression of type <code>int</code> (an integer literal)</li>\n<li>a <em>braced-init-list</em> <code>{}</code></li>\n</ul>\n<p>The latter, <code>{}</code>, can be part of an <em>expression-list</em> but it is not an <em>expression</em> itself. An <em>expression-list</em> is defined as an <em>initializer-list</em>. <em>braced-init-lists</em> do not have a type.</p>\n<p>Template type deduction is done for each function parameter individually [temp.deduct.type]/2. [temp.deduct.call]/1 states about type deduction for a function parameter <code>P</code>:</p>\n<blockquote>\n<p id=\"so_24059738_24060303_0\">If removing references and cv-qualifiers from <code>P</code> gives\n  <code>std::initializer_list&lt;</code><em>P'</em><code>&gt;</code> for some <em>P'</em> and the argument is an\n  initializer list, then deduction is performed instead for each element\n  of the initializer list, taking <em>P'</em> as a function template parameter\n  type and the initializer element as its argument. <strong>Otherwise, an\n  initializer list argument causes the parameter to be considered a\n  non-deduced context.</strong> [emphasis mine]</p>\n</blockquote>\n<p>So in the call <code>foo(42, {});</code> the <code>T</code> will not be deduced from the second argument <code>{}</code>. However, <code>T</code> can be deduced from the first argument.</p>\n<p>In general, we can deduce <code>T</code> from multiple function parameters. In that case, the deduced types have to match exactly [temp.deduct.type]/2. There is no problem if the type is only deduced from one function parameter but used elsewhere (in another function parameter that is in a non-deduced context, in the return type etc). Type deduction can fail e.g. when a template parameter cannot be deduced from <em>any</em> function parameter and is not set explicitly.</p>\n<p>After deduction, <code>T</code> will be substituted by <code>int</code>, producing a function signature similar to:</p>\n<pre><code>void foo&lt;int&gt;(int, int);\n</code></pre>\n<p>This function can be called with the two arguments <code>42</code> and <code>{}</code>. The latter will perform a copy-list-initialization leading to a value-initialization of the second parameter.</p>\n", "LastActivityDate": "2014-06-05T12:40:24.003"}, "24059738": {"CommentCount": "1", "AcceptedAnswerId": "24060303", "CreationDate": "2014-06-05T12:03:40.797", "LastActivityDate": "2014-06-05T12:40:24.003", "PostTypeId": "1", "ViewCount": "234", "FavoriteCount": "2", "Title": "Braced-init-lists and function template type deduction order", "Id": "24059738", "Score": "6", "Body": "<p>I have a question regarding the function template parameter type deduction procedure.</p>\n<p>Take this example:</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n#include &lt;iterator&gt;\n#include &lt;fstream&gt;\n\nint main()\n{\n    std::ifstream file(\"path/to/file\");\n    std::vector&lt;int&gt; vec(std::istream_iterator&lt;int&gt;{file},{}); // &lt;- This part\n    return 0;\n}\n</code></pre>\n<p>If I understand things correctly, the second parameter is deduced to be of type <code>std::istream_iterator</code> of which the default constructor is called.</p>\n<p>The appropriate <code>std::vector</code> constructor is declared as:</p>\n<pre><code>template &lt;class InputIterator&gt;\n         vector (InputIterator first, InputIterator last,\n                 const allocator_type&amp; alloc = allocator_type());\n</code></pre>\n<p>Since the first parameter type is deduced as <code>std::istream_iterator&lt;int&gt;</code> the second parameter is deduced as <code>std::istream_iterator&lt;int&gt;</code> too and so the uniform initialization semantics can be applied. What I have no idea about is at what order the type deduction happens. I would really appreciate some info on this.</p>\n<p>Thanks in advance!</p>\n", "Tags": "<c++><templates><c++11><type-deduction><brace-initialization>", "OwnerUserId": "3024983", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_24059738_24060303_0": {"section_id": 302, "quality": 0.9444444444444444, "length": 34}}, "n3337": {"so_24059738_24060303_0": {"section_id": 293, "quality": 0.9444444444444444, "length": 34}}, "n4659": {"so_24059738_24060303_0": {"section_id": 309, "quality": 0.9444444444444444, "length": 34}}}});