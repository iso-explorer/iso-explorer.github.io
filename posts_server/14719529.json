post_cb({"bq_ids": {"n4140": {"so_14719529_16641131_0": {"length": 14, "quality": 1.0, "section_id": 7239}}, "n3337": {"so_14719529_16641131_0": {"length": 14, "quality": 1.0, "section_id": 6983}}, "n4659": {"so_14719529_16641131_0": {"length": 14, "quality": 1.0, "section_id": 8748}}}, "16641131": {"Id": "16641131", "PostTypeId": "2", "Body": "<p>In C++11, [basic.lval]p10 says,</p>\n<blockquote>\n<p id=\"so_14719529_16641131_0\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:</p>\n<ul>\n<li>...</li>\n<li>a char or unsigned char type.</li>\n</ul>\n</blockquote>\n<p>(the exact location may be different in other versions of C++, but the meaning is the same.)</p>\n<p>That means that you can take a <code>vector&lt;unsigned char&gt; cache</code> and access its contents using the range <code>[reinterpret_cast&lt;char*&gt;(cache.data()), reinterpret_cast&lt;char*&gt;(cache.data()) + cache.size())</code>. (@Kerrek SB mentioned this.)</p>\n<p>If you store a <code>vector&lt;unsigned char&gt;</code> in <code>Processor</code> to match the return type of <code>LoadFile</code>, and <code>_dataOperation()</code> actually takes an array of <code>char</code> (meaning a <code>const char*</code> and a size), then you can cast when you're passing the argument to <code>_dataOperation()</code></p>\n<p>However, if <code>_dataOperation()</code> takes a <code>vector&lt;char&gt;</code> specifically and you store a <code>vector&lt;unsigned char&gt; cache</code>, then you <strong>cannot</strong> pass it <code>reinterpret_cast&lt;vector&lt;char&gt;&amp;&gt;(cache)</code>. (i.e. @Andr\u00e9 Puel is totally wrong. Do not listen to him.) That violates the aliasing rules, and the compiler will attempt to anger your customers at 2am. (And if this version of your compiler doesn't manage it, the next version will keep trying.)</p>\n<p>One option is, as you mentioned, to template <code>LoadFile()</code> and have it return (or fill in) a vector of the type you want. Another is to copy the result, for which the concise version is again the <code>reinterpret_cast</code> of the source vector's <code>.data()</code>. [basic.fundamental]p1 mentions that \"For character types, all bits of the object representation participate in the value representation.\", meaning that you're not going to lose data with that <code>reinterpret_cast</code>. I don't see a firm guarantee that no bit pattern of an <code>unsigned char</code> can cause a trap if <code>reinterpret_cast'ed</code> to <code>char</code>, but I don't know of any modern hardware or compilers that do it.</p>\n", "LastActivityDate": "2013-05-20T00:54:01.540", "CommentCount": "1", "CreationDate": "2013-05-20T00:54:01.540", "ParentId": "14719529", "Score": "6", "OwnerUserId": "943619"}, "14719529": {"ViewCount": "3916", "Body": "<p>I weren't able to find that question, and it's an actual problem I'm facing.</p>\n<p>I have a file loading utility that returns <code>std::vector&lt;unsigned char&gt;</code> containing whole file contents.\nHowever, the processing function requires contiguos array of <code>char</code> (and that <strong>cannot</strong> be changed - it's a library function). Since the class that's using the processing function stores a copy of the data anyway, I want to store it as <code>vector&lt;char&gt;</code>. Here's the code that might be a bit more illustrative.</p>\n<pre><code>std::vector&lt;unsigned char&gt; LoadFile (std::string const&amp; path);\n\nclass Processor {\n    std::vector&lt;char&gt; cache;\n    void _dataOperation(std::vector&lt;char&gt; const&amp; data);\n\npublic:\n    void Process() {\n        if (cache.empty())\n            // here's the problem!\n            cache = LoadFile(\"file.txt\");\n\n        _dataOperation(cache);\n    }\n};\n</code></pre>\n<p>This code doesn't compile, because (obviously) there's no appropriate conversion. We can be sure, however, that the temporary vector will ocupy the same amount of memory (IOW <code>sizeof(char) == sizeof(unsigned char)</code>)</p>\n<p>The naive solution would be to iterate over the contents of a temporary and cast every character. I know that in normal case, the <code>operator= (T&amp;&amp;)</code> would be called.</p>\n<p>In my situation it's safe to do reinterpreting conversion, because I am sure I am going to read ASCII characters only. Any other character would be caught in <code>_dataOperation</code> anyway.</p>\n<p>So, my question is : <strong>how to properly and safely convert the temporary vector in a way that involves no copying?</strong></p>\n<p>If it isn't possible, I would prefer the safe way of copying rather than unsafe noncopying. I could also change <code>LoadFile</code> to return either <code>vector&lt;char&gt;</code> or <code>vector&lt;unsigned char&gt;</code>.</p>\n", "AcceptedAnswerId": "16641131", "Title": "How to convert std::vector<unsigned char> to vector<char> without copying?", "CreationDate": "2013-02-06T00:29:11.687", "Id": "14719529", "CommentCount": "21", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-02-06T00:48:29.467", "LastEditorUserId": "752976", "LastActivityDate": "2013-05-20T00:54:01.540", "Score": "12", "OwnerUserId": "752976", "Tags": "<c++><vector><std>", "AnswerCount": "1"}});