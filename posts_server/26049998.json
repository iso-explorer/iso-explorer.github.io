post_cb({"26050164": {"ParentId": "26049998", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2014-09-26T00:22:08.863", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:13:20.543", "Id": "26050164", "OwnerUserId": "3959454", "Body": "<p>See <a href=\"https://stackoverflow.com/a/2419720/3959454\">this answer</a></p>\n<pre><code>#define CONCATENATE_DETAIL(x, y) x##y\n#define CONCATENATE(x, y) CONCATENATE_DETAIL(x, y)\n#define MAKE_UNIQUE(x) CONCATENATE(x, __LINE__)\n\nMyClass MAKE_UNIQUE(name);\nMyClass MAKE_UNIQUE(name);\n...\n</code></pre>\n<p>Or just make an array:</p>\n<pre><code>MyClass arr[N];\n</code></pre>\n<p><strong>Why these macros work</strong><br>\nC11 standard, <code>6.10.3.1 Argument substitution</code>:</br></p>\n<blockquote>\n<p id=\"so_26049998_26050164_0\">After the arguments for the invocation of a function-like macro have been identified,\n  argument substitution takes place. A parameter in the replacement list, unless preceded\n  by a <code>#</code> or <code>##</code> preprocessing token or followed by a <code>##</code> preprocessing token (see below), is\n  replaced by the corresponding argument after all macros contained therein have been\n  expanded. Before being substituted, each argument\u2019s preprocessing tokens are\n  completely macro replaced as if they formed the rest of the preprocessing file; no other\n  preprocessing tokens are available.</p>\n</blockquote>\n<p>Corresponding paragraph in C++ standard (<code>16.3.1 Argument substitution</code>) is exact copy of C standard's.</p>\n", "LastActivityDate": "2014-09-26T15:21:50.677"}, "26050194": {"ParentId": "26049998", "CommentCount": "0", "CreationDate": "2014-09-26T00:25:30.397", "OwnerUserId": "811310", "PostTypeId": "2", "Id": "26050194", "Score": "0", "Body": "<p>You need to double nest the concatenation operator</p>\n<pre><code>struct A{};\n\n#define JOIN(X, Y) JOIN_DETAIL(X, Y)\n#define JOIN_DETAIL(X, Y) JOIN_DETAIL2(X, Y)\n#define JOIN_DETAIL2(X, Y) X##Y\n\nint main() {\n    A JOIN(a, __LINE__);\n    A JOIN(a, __LINE__);\n}\n</code></pre>\n", "LastActivityDate": "2014-09-26T00:25:30.397"}, "bq_ids": {"n4140": {"so_26049998_26050164_0": {"section_id": 523, "quality": 1.0, "length": 53}}, "n3337": {"so_26049998_26050164_0": {"section_id": 514, "quality": 1.0, "length": 53}}, "n4659": {"so_26049998_26050164_0": {"section_id": 544, "quality": 1.0, "length": 53}}}, "26049998": {"CommentCount": "2", "ViewCount": "46", "PostTypeId": "1", "LastEditorUserId": "608639", "CreationDate": "2014-09-25T23:58:17.763", "LastActivityDate": "2014-09-26T15:21:50.677", "Title": "Repeated Class Instantiation without using Identifier", "AcceptedAnswerId": "26050164", "LastEditDate": "2014-09-26T00:31:16.303", "Id": "26049998", "Score": "0", "Body": "<p>I want to repeatedly instantiate a class, within module scope, without providing a unique name. Something like this.</p>\n<pre><code>MyClass name##__LINE__(); // doesn't work because __LINE__ won't stringify\nMyClass name##__LINE__(); // duplicate identifier error - two name__LINE__ variables\n</code></pre>\n<p>Is there some way to do this, either creating a unique name or using some anonymous context, such as an initializer or struct?</p>\n", "Tags": "<c++><unique><anonymous>", "OwnerUserId": "317797", "AnswerCount": "2"}});