post_cb({"18404092": {"Id": "18404092", "PostTypeId": "2", "Body": "<p>What do are achieving by this code is called <code>diamond-inheritance</code> problem. Explaining it briefly, during compilation, the compiler finds the <code>operator &amp;</code> ambiguous as it cannot make out whether to call the B class inherited version or the C class inherited version.</p>\n<p>To overcome that, declare your class definition as</p>\n<pre><code>struct B : virtual public A {};\n</code></pre>\n<p>Which makes only one copy of your function available in class D.</p>\n", "LastActivityDate": "2013-08-23T13:29:00.150", "CommentCount": "0", "CreationDate": "2013-08-23T13:29:00.150", "ParentId": "18402753", "Score": "0", "OwnerUserId": "2078685"}, "bq_ids": {"n4140": {"so_18402753_18402840_2": {"length": 20, "quality": 0.6060606060606061, "section_id": 6986}, "so_18402753_18403086_1": {"length": 90, "quality": 0.9090909090909091, "section_id": 7083}, "so_18402753_18402840_1": {"length": 82, "quality": 0.9010989010989011, "section_id": 6985}, "so_18402753_18402840_0": {"length": 50, "quality": 0.8928571428571429, "section_id": 6984}}, "n3337": {"so_18402753_18402840_2": {"length": 20, "quality": 0.6060606060606061, "section_id": 6732}, "so_18402753_18403086_1": {"length": 90, "quality": 0.9090909090909091, "section_id": 6827}, "so_18402753_18402840_1": {"length": 82, "quality": 0.9010989010989011, "section_id": 6731}, "so_18402753_18402840_0": {"length": 50, "quality": 0.8928571428571429, "section_id": 6730}}, "n4659": {"so_18402753_18402840_2": {"length": 23, "quality": 0.696969696969697, "section_id": 8484}, "so_18402753_18403086_1": {"length": 70, "quality": 0.7070707070707071, "section_id": 8584}, "so_18402753_18402840_1": {"length": 48, "quality": 0.5274725274725275, "section_id": 8483}, "so_18402753_18402840_0": {"length": 50, "quality": 0.8928571428571429, "section_id": 8482}}}, "18403086": {"Id": "18403086", "PostTypeId": "2", "Body": "<p>What I've found in Standard:</p>\n<blockquote>\n<p id=\"so_18402753_18403086_0\">3.4 Name lookup [basic.lookup]</p>\n<p id=\"so_18402753_18403086_1\">1 The name lookup rules apply uniformly to all names (including typedef-names (7.1.3), namespace-names (7.3) and class-names (9.1)) wherever the grammar allows such names in the context discussed by a particular rule. Name lookup associates the use of a name with a declaration (3.1) of that name. <strong>Name lookup shall find an unambiguous declaration for the name (see 10.2). Name lookup may associate more than one declaration with a name if it finds the name to be a function name; the declarations are said to form a set of overloaded functions (13.1). Overload resolution (13.3) takes place after name lookup has succeeded.</strong> The access rules (clause 11) are considered only once name lookup and function overload resolution (if applicable) have succeeded. Only after name lookup, function overload resolution (if applicable) and access checking have succeeded are the attributes introduced by the name\u2019s declaration used further in expression processing (clause 5).</p>\n</blockquote>\n", "LastActivityDate": "2013-08-23T12:37:37.530", "CommentCount": "0", "CreationDate": "2013-08-23T12:37:37.530", "ParentId": "18402753", "Score": "0", "OwnerUserId": "1273744"}, "18402753": {"ViewCount": "77", "Body": "<p>Here is the sample code:</p>\n<pre><code>struct A\n{\n    virtual int operator &amp; ( A &amp; ) { return 0; }\n};\n\nstruct B : public A {};\nstruct C : public A {};\n\nstruct D : public C, public B {};\n\nint main()\n{\n    D d;\n    std::cout &lt;&lt; &amp;d &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>It perfectly works in VS 2008, but GCC fails to compile it:</p>\n<pre><code>../src/TestCast.cpp: In function \u2018int main()\u2019:\n../src/TestCast.cpp:26:16: error: request for member \u2018operator&amp;\u2019 is ambiguous\n../src/TestCast.cpp:15:14: error: candidates are: virtual int A::operator&amp;(A&amp;)\n../src/TestCast.cpp:15:14: error:                 virtual int A::operator&amp;(A&amp;)\nmake: *** [src/TestCast.o] Error 1\n</code></pre>\n<p>As far as I see, it looks for operator&amp; overload by name, not by signature, so it find ambiguous overload and produces an error.</p>\n<p>The question is: is it correct by Standard? If not, which paragraph describes it? Is there any way to make GCC accept this code (I mean, lookup by signature, not by name).</p>\n<p>BTW, I know, how to fix this code. I just want to know, WHY an error appears.</p>\n", "Title": "Ambigulty while calling overloaded operator", "CreationDate": "2013-08-23T12:22:44.103", "LastActivityDate": "2013-08-23T13:29:00.150", "CommentCount": "3", "LastEditDate": "2013-08-23T12:23:42.060", "PostTypeId": "1", "LastEditorUserId": "661519", "Id": "18402753", "Score": "2", "OwnerUserId": "1273744", "Tags": "<c++><visual-c++><gcc>", "AnswerCount": "3"}, "18402840": {"Id": "18402840", "PostTypeId": "2", "Body": "<p>What you caused is a diamond-inheritance issue, and you may solve it with virtual inheritance.</p>\n<p>In A you have declared virtual <code>operator&amp;</code> which is also defined in both <code>B</code> and <code>C</code>. Now, both these methods are defined inside <code>D</code> as you're using multiple inheritance.</p>\n<p>From standard (10.1 <em>Multiple base classes</em>).</p>\n<blockquote>\n<p id=\"so_18402753_18402840_0\">A class shall not be speci\ufb01ed as a direct base class of a derived class more than once. [ Note: A class can\n  be an indirect base class more than once and can be a direct and an indirect base class. There are limited\n  things that can be done with such a class. The non-static data members and member functions of the direct\n  base class cannot be referred to in the scope of the derived class. However, the static members, enumerations\n  and types can be unambiguously referred to. \u2014 end note ] [Example:</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_18402753_18402840_1\">A base class speci\ufb01er that does not contain the keyword virtual, speci\ufb01es a non-virtual base class. A base\n  class speci\ufb01er that contains the keyword virtual, speci\ufb01es a virtual base class. For each distinct occurrence\n  of a non-virtual base class in the class lattice of the most derived class, the most derived object (1.8) shall\n  contain a corresponding distinct base class subobject of that type. For each distinct base class that is\n  speci\ufb01ed virtual, the most derived object shall contain a single base class subobject of that type. [Example:\n  for an object of class type C, each distinct occurrence of a (non-virtual) base class L in the class lattice of\n  C corresponds one-to-one with a distinct L subobject within the object of type C. Given the class C de\ufb01ned\n  above, an object of class C will have two subobjects of class L as shown below.</p>\n</blockquote>\n<pre><code>L       L\n|       |\nA       B\n  \\   /\n    C\n</code></pre>\n<blockquote>\n<p id=\"so_18402753_18402840_2\">Figure 3 \u2014 Non-virtual base\n  5 In such lattices, explicit quali\ufb01cation can be used to specify which subobject is meant. The body of function\n  C::f could refer to the member next of each L subobject:\n  void C::f() { A::next = B::next; } // well-formed\n  Without the A:: or B:: quali\ufb01ers, the de\ufb01nition of C::f above would be ill-formed because of ambiguity (10.2).</p>\n</blockquote>\n", "LastActivityDate": "2013-08-23T12:26:28.240", "CommentCount": "0", "CreationDate": "2013-08-23T12:26:28.240", "ParentId": "18402753", "Score": "4", "OwnerUserId": "133707"}});