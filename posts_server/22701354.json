post_cb({"22701397": {"ParentId": "22701354", "CommentCount": "3", "Body": "<p>It\u2019s not safe, because it\u2019s not legal (\u00a717.6.4.2.1):</p>\n<blockquote>\n<p id=\"so_22701354_22701397_0\">The behavior of a C++ program is undefined if it adds declarations or definitions to namespace <code>std</code> or to a namespace within namespace <code>std</code> unless otherwise specified. A program may add a template specialization for any standard library template to namespace <code>std</code> only if the declaration depends on a user-defined type and the specialization meets the standard library requirements for the original template and is not explicitly prohibited.</p>\n</blockquote>\n<p>So you may add specialisations for your own types. You may <em>not</em> add overloads (or indeed anything else).</p>\n<p>Your current code is the correct way of doing this.</p>\n", "OwnerUserId": "1968", "PostTypeId": "2", "Id": "22701397", "Score": "5", "CreationDate": "2014-03-27T23:34:35.910", "LastActivityDate": "2014-03-27T23:34:35.910"}, "22701420": {"ParentId": "22701354", "CommentCount": "0", "Body": "<p>Not so good an idea to put it in std namespace.</p>\n<p>Since you have your own namespace, you could import sqrt into your namespace and add specialized <code>sqrt</code> functions:</p>\n<pre><code>namespace ns {\n  using std::sqrt;\n  MyClass sqrt(const MyClass &amp;)\n}\n\nns::sqrt(...);\n</code></pre>\n", "OwnerUserId": "206328", "PostTypeId": "2", "Id": "22701420", "Score": "1", "CreationDate": "2014-03-27T23:36:21.273", "LastActivityDate": "2014-03-27T23:36:21.273"}, "22701354": {"CommentCount": "3", "ViewCount": "956", "CreationDate": "2014-03-27T23:31:26.493", "LastActivityDate": "2014-03-27T23:36:21.273", "Title": "Is it a good practice to overload math functions in namespace std in c++", "AcceptedAnswerId": "22701397", "PostTypeId": "1", "Id": "22701354", "Score": "4", "Body": "<p>I am writing a C++ class which represents an arithmetic type (a c++ wrapper around <a href=\"http://www.mpfr.org/\" rel=\"nofollow\">mpfr</a>), and I'd like to support some functions found in &lt;cmath&gt; (I'll take std::sqrt as an example).</p>\n<p>So I have the following class:</p>\n<pre><code>namespace ns\n{\n  class MyClass\n  {\n      /* ... */\n      public:\n      friend MyClass sqrt(const MyClass&amp; mc);\n  };\n}\n</code></pre>\n<p>And I can use it this way:</p>\n<pre><code>MyClass c;\n/* ... */\nMyClass d = ns::sqrt(c);\nMyClass e = sqrt(c); // Apparently I don't have to specify ns::\n</code></pre>\n<p>But I cannot use it this way:</p>\n<pre><code>MyClass f = std::sqrt(c);\n</code></pre>\n<p>Compiler (g++ (Debian 4.7.2-5)) error is: \"no matching function for call to sqrt(ns::MyClass&amp;)\".</p>\n<p>This is normal, but it's a problem to me. I need this to be valid, because MyClass is supposed to be used into existing template functions (that I'm not supposed to modify). For example:</p>\n<pre><code>template &lt;typename T&gt;\nvoid func(T a)\n{\n    /* ... */\n    T c = std::sqrt(a);\n    /* ... */\n}\nint main()\n{\n    func&lt;float&gt;(3);\n    func&lt;MyClass&gt;(MyClass(3));\n    /* ... */\n}\n</code></pre>\n<p>The following piece of code actually resolve my problem:</p>\n<pre><code>namespace std\n{\n  using ns::sqrt;\n}\n</code></pre>\n<p>But adding things into the std namespace seems very unnatural to me. I am afraid to run into unexpected troubles later, doing this.</p>\n<p>Is it safe ? If not, why ?</p>\n<p>Is there a better alternative ?</p>\n", "Tags": "<c++><std><function-overloading><cmath>", "OwnerUserId": "1545442", "AnswerCount": "4"}, "22701407": {"ParentId": "22701354", "CommentCount": "3", "Body": "<p>Adding stuff to namespace <code>std</code> is prohibited by the standard. The correct way to tackle this problem is normally seen with <code>swap</code> (that is available in the <code>std</code> namespace, but that can be specialized by user-defined types to work more efficiently): when a template function needs to use e.g. <code>sqrt</code>, it will do</p>\n<pre><code>using std::sqrt;\na=sqrt(b);\n</code></pre>\n<p>This way, for \"regular\" types it will use <code>std::sqrt</code> (\"taken in\" by the <code>using</code> statement), while for your type your overload will prevail due to <a href=\"http://en.wikipedia.org/wiki/Argument-dependent_name_lookup\" rel=\"noreferrer\">Koenig lookup</a> (which, incidentally, is the reason of the behavior you observed at <code>// Apparently I don't have to specify ns::</code>).</p>\n", "OwnerUserId": "214671", "PostTypeId": "2", "Id": "22701407", "Score": "5", "CreationDate": "2014-03-27T23:35:26.840", "LastActivityDate": "2014-03-27T23:35:26.840"}, "22701411": {"ParentId": "22701354", "CommentCount": "0", "Body": "<p>The alternative, within generic functions, is to do this:</p>\n<pre><code>template &lt;typename T&gt;\nvoid func(T a)\n{\n    using std::sqrt;\n\n    /* ... */\n    T c = sqrt(a);\n    /* ... */\n}\n</code></pre>\n<p>And defining additional things into the std-namespace is not safe in general (and not strictly legal). </p>\n", "OwnerUserId": "491645", "PostTypeId": "2", "Id": "22701411", "Score": "1", "CreationDate": "2014-03-27T23:35:36.043", "LastActivityDate": "2014-03-27T23:35:36.043"}, "bq_ids": {"n4140": {"so_22701354_22701397_0": {"section_id": 6299, "quality": 0.9705882352941176, "length": 33}}, "n3337": {"so_22701354_22701397_0": {"section_id": 6056, "quality": 0.9705882352941176, "length": 33}}, "n4659": {"so_22701354_22701397_0": {"section_id": 7808, "quality": 0.9705882352941176, "length": 33}}}});