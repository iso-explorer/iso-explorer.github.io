post_cb({"7329617": {"CommentCount": "0", "ViewCount": "234", "PostTypeId": "1", "LastEditorUserId": "751747", "CreationDate": "2011-09-07T06:16:57.230", "LastActivityDate": "2011-09-07T18:14:02.580", "Title": "A destructor Shall OR shall not be declared with a pointer ? in C++", "AcceptedAnswerId": "7330574", "LastEditDate": "2011-09-07T06:23:49.413", "Id": "7329617", "Score": "8", "Body": "<p>In C++0x -n3290 Draft : they added  in section :Destructors : 12.4/2nd point last line </p>\n<pre><code>          **A destructor shall not be declared with a ref-qualifier.**\n</code></pre>\n<p>In c++03 Draft .... they didn't mention this point in destructors ?</p>\n<p>my question is whether </p>\n<pre><code>   *~S() ;   //this declaration is allowed or not according to the Standard's\n   //**~S(); ***~S() ; etc...........\n</code></pre>\n<p>this type of declaration is allowed ? \nNo where in the Draft he described about this ...Declaration?</p>\n<p>In GCC 4.6.0,Sun/Oracle C++12.0 , ---&gt;this declaration is allowed \nint Comeau C/C++ --&gt;not allowed </p>\n", "Tags": "<c++><destructor><declaration><c++11>", "OwnerUserId": "751747", "AnswerCount": "3"}, "7329680": {"ParentId": "7329617", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>That doesn't look like it would ever be a legal function declaration of any kind, much less for a destructor. I'm not positive what that part of the standard is talking about, but I have a guess.</p>\n<p>I suspect there is a qualifier saying that your function is being called on an rvalue reference.  Something like this:</p>\n<pre><code>class A {\n public:\n   void IAmAnRValue() &amp;&amp;;\n};\n</code></pre>\n<p>I think the language in the standard is saying that this qualifier is not allowed on a destructor, much like having a trailing <code>const</code> would also be illegal.</p>\n<p>And, on further investigation, my certainty of  the correctness of my surmise goes up considerably.  Here is the justification:</p>\n<ul>\n<li><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2439.htm\" rel=\"nofollow\">Extending Move Semantics to <code>*this</code></a>.</li>\n</ul>\n<p>There it clearly states that functions may now have a 'ref-qualifier' after the 'cv-qualifer'. This means that a function declaration may now be followed by <code>const &amp;</code> or <code>const volatile &amp;&amp;</code> instead of just <code>const</code>. And the term used (ref-qualifier) is the same as the term used in the little bit of the standard you're quoting. And it makes sense for destructors to not be able to have one.</p>\n", "OwnerUserId": "167958", "LastEditorUserId": "167958", "LastEditDate": "2011-09-07T06:35:47.143", "Id": "7329680", "Score": "10", "CreationDate": "2011-09-07T06:24:20.090", "LastActivityDate": "2011-09-07T06:35:47.143"}, "7338579": {"ParentId": "7329617", "CommentCount": "1", "Body": "<p>The rule you are looking for is stated in the same paragraph, 12.4p2</p>\n<blockquote>\n<p id=\"so_7329617_7338579_0\">A destructor takes no parameters, and no return type can be specified for it (not even void).</p>\n</blockquote>\n<p>The phrase \"no return type can be specified for it\" also forbids \"*\", which is not immediately clear but can be seen by comparison with 12.3.2p1 (compare with <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#395\" rel=\"nofollow\">this issue report</a>):</p>\n<blockquote>\n<p id=\"so_7329617_7338579_1\">... Such functions are called conversion functions. No return type can be specified. </p>\n</blockquote>\n<p>That rule is what makes implementations forbid <code>* operator int() { }</code>. You can also argue with 12.4p1, although as that's phrased very general and is the first statement in the destructors section, I think the other statement above should be the primary argument</p>\n<blockquote>\n<p id=\"so_7329617_7338579_2\">A special declarator syntax using an optional function-specifier (7.1.2) followed by \u02dc followed by the destructor's class name followed by an empty parameter list is used to declare the destructor in a class definition.</p>\n</blockquote>\n<p>As can be seen/read there is no mention of declarators such as <code>*</code> in that description, which shows the intent of the authors. </p>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "7338579", "Score": "1", "CreationDate": "2011-09-07T18:14:02.580", "LastActivityDate": "2011-09-07T18:14:02.580"}, "7330574": {"ParentId": "7329617", "CommentCount": "8", "Body": "<p>You have misunderstood what <em>ref-qualifier</em> means in the new standard. In the same way that you can provide a <code>const</code> qualifier to any member function in C++03, you can also add a <em>ref-qualifier</em> to a member function in C++0x. That modifier will affect the type of the implicit <code>this</code> argument to the function:</p>\n<pre><code>struct test {\n   void f() const &amp;&amp;;  // implicit \"this\" in \"f\" is of type \"test const &amp;&amp;\"\n};\n</code></pre>\n<p>In the same way that a destructor cannot be <code>static</code>, or <code>const</code>, or <code>const volatile</code> in C++03, it cannot take a <em>ref-qualifier</em> (<code>&amp;</code> or <code>&amp;&amp;</code>) in C++0x. Of course this bit was not present in the former standard.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "7330574", "Score": "7", "CreationDate": "2011-09-07T07:57:45.567", "LastActivityDate": "2011-09-07T07:57:45.567"}, "bq_ids": {"n4140": {"so_7329617_7338579_1": {"section_id": 391, "quality": 1.0, "length": 9}, "so_7329617_7338579_0": {"section_id": 391, "quality": 0.6666666666666666, "length": 6}}, "n3337": {"so_7329617_7338579_2": {"section_id": 388, "quality": 0.95, "length": 19}, "so_7329617_7338579_1": {"section_id": 382, "quality": 1.0, "length": 9}, "so_7329617_7338579_0": {"section_id": 389, "quality": 1.0, "length": 9}}, "n4659": {"so_7329617_7338579_1": {"section_id": 408, "quality": 0.6666666666666666, "length": 6}}}});