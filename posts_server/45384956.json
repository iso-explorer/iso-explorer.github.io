post_cb({"bq_ids": {"n4140": {"so_45384956_45385086_0": {"length": 15, "quality": 1.0, "section_id": 7070}}, "n3337": {"so_45384956_45385086_0": {"length": 15, "quality": 1.0, "section_id": 6814}}, "n4659": {"so_45384956_45385086_0": {"length": 15, "quality": 1.0, "section_id": 8568}}}, "45385045": {"Id": "45385045", "PostTypeId": "2", "Body": "<p>When the compiler reads the line</p>\n<pre><code>    Money balance() { return bal; }\n</code></pre>\n<p>in the class definition, it already uses the definition of <code>Money</code> outside the class. That makes the line</p>\n<pre><code>    typedef double Money;\n</code></pre>\n<p>inside the class a problem. However, you may use redefine <code>Money</code> inside the class before it is used in the class. The following is OK.</p>\n<pre><code>typedef double Money;\n\nclass Account {\n    public:\n        typedef double Money;\n        Money balance() { return bal; }\n    private:\n        Money bal;\n};\n</code></pre>\n<p>The key point in the quote is:</p>\n<blockquote>\n<p id=\"so_45384956_45385045_0\">hence the class may not <strong>subsequently</strong> redefine that name.</p>\n</blockquote>\n", "LastEditorUserId": "434551", "LastActivityDate": "2017-07-29T03:51:30.953", "Score": "2", "CreationDate": "2017-07-29T03:49:03.250", "ParentId": "45384956", "CommentCount": "2", "OwnerUserId": "434551", "LastEditDate": "2017-07-29T03:51:30.953"}, "45384956": {"ViewCount": "83", "Body": "<p>According to the book C++ Primer section, 7.4.1 Type Names Are Special:</p>\n<blockquote>\n<p id=\"so_45384956_45384956_0\">Ordinarily, an inner scope can redefine a name from an outer scope even if that name has already been used in the inner scope. However, in a class, if a member uses a name from an outer scope and that name is a type, then the class may not subsequently redefine that name.</p>\n</blockquote>\n<p>Accordingly, for example:</p>\n<pre><code>typedef double Money;\nclass Account {\n    public:\n        Money balance() { return bal; }\n    private:\n        typedef double Money;\n        Money bal;\n};\n\nint main() {\n    typedef double Money;\n    Money asset;\n    typedef double Money;\n    return 0;\n}\n</code></pre>\n<p>When you compile the example above, it will complain:</p>\n<pre><code>a.cc:6:24: error: declaration of \u2018typedef double Account::Money\u2019 [-fpermissive]\n         typedef double Money;\n                        ^\na.cc:1:16: error: changes meaning of \u2018Money\u2019 from \u2018typedef double Money\u2019 [-fpermissive]\n typedef double Money;\n</code></pre>\n<p>So why can not we redefine type names in class, but can we in the inner scope?</p>\n<hr>\n<p>My compiler version is <code>g++ (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609</code>.<br>\nAnd there is also a note in that section:  </br></p>\n<blockquote>\n<p id=\"so_45384956_45384956_1\">Although it is an error to redefine a type name, compilers are not required to diagnose this error. Some compilers will quietly accept such code, even though the program is in error.</p>\n</blockquote>\n</hr>", "AcceptedAnswerId": "45385086", "Title": "Why can't redefine type names in class in C++?", "CreationDate": "2017-07-29T03:30:49.960", "Id": "45384956", "CommentCount": "6", "LastEditDate": "2017-07-29T04:36:46.357", "PostTypeId": "1", "LastEditorUserId": "6099429", "LastActivityDate": "2017-07-29T04:36:46.357", "Score": "1", "OwnerUserId": "6099429", "Tags": "<c++><class><scope><typename>", "AnswerCount": "2"}, "45385086": {"Id": "45385086", "PostTypeId": "2", "Body": "<p>This is not unique to types. [basic.class.scope]/2:</p>\n<blockquote>\n<p id=\"so_45384956_45385086_0\">A name <code>N</code> used in a class <code>S</code> shall refer to the same declaration in its\n  context and when re-evaluated in the completed scope of <code>S</code>. No\n  diagnostic is required for a violation of this rule.</p>\n</blockquote>\n<p>The reason is that name lookup in class scope is a little special. Consider:</p>\n<pre><code>using Foo = int;\n\nstruct X {\n    Foo a;    // ::Foo, i.e., int\n    void meow() { \n        Foo b = a; // X::Foo; error: no conversion from int to char*\n    }\n    using Foo = char*;\n};\n</code></pre>\n<p>Name lookup in member function bodies considers all class members, whether declared before or after the member function (otherwise, a member function defined in a class definition wouldn't be able to use a data member declared later in the class). The result is that you get two <code>Foo</code>s with different meanings, even though they both lexically precede the class member <code>Foo</code>'s declaration. This can easily lead to extremely confusing and brittle code, and so the standard bans it.</p>\n", "LastActivityDate": "2017-07-29T03:56:57.380", "CommentCount": "1", "CreationDate": "2017-07-29T03:56:57.380", "ParentId": "45384956", "Score": "6", "OwnerUserId": "2756719"}});