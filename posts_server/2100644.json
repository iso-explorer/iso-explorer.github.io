post_cb({"2100670": {"Id": "2100670", "PostTypeId": "2", "Body": "<p>It will deallocate with correct size, because the size to be deallocated is a property of the heap memory region you obtained (there is no size passed to <code>free()</code>-like functions!). </p>\n<p>However, no d'tor is called. If 'B' defines a destructor or contains any members with a non-trivial destructor they will not be called, causing a potential memory leak. This is not the case in your code sample, however.</p>\n", "LastActivityDate": "2010-01-20T10:36:50.727", "CommentCount": "1", "CreationDate": "2010-01-20T10:36:50.727", "ParentId": "2100644", "Score": "0", "OwnerUserId": "234053"}, "2100685": {"Id": "2100685", "PostTypeId": "2", "Body": "<p>Unless the base class destructor is virtual, it's undefined behaviour. See 5.3.5/4:</p>\n<blockquote>\n<p id=\"so_2100644_2100685_0\">If the static type of the operand [of the delete operator] is different from its dynamic type, the static type shall be a base class of the operand's dynamic type and the static type shall have a virtual destructor or the behaviour is undefined.</p>\n</blockquote>\n", "LastEditorUserId": "129963", "LastActivityDate": "2011-04-18T22:23:35.537", "Score": "23", "CreationDate": "2010-01-20T10:39:48.523", "ParentId": "2100644", "CommentCount": "2", "OwnerUserId": "11828", "LastEditDate": "2011-04-18T22:23:35.537"}, "bq_ids": {"n4140": {"so_2100644_2100685_0": {"length": 18, "quality": 0.782608695652174, "section_id": 6107}}, "n3337": {"so_2100644_2100685_0": {"length": 18, "quality": 0.782608695652174, "section_id": 5873}}, "n4659": {"so_2100644_2100685_0": {"length": 18, "quality": 0.782608695652174, "section_id": 7604}}}, "2100644": {"ViewCount": "2117", "Body": "<p>Given two classes have only primitive data type and no custom destructor/deallocator.\nDoes C++ spec guarantee it will deallocate with correct size?</p>\n<pre><code>struct A { int foo; };\nstruct B: public A { int bar[100000]; };\nA *a = (A*)new B;\ndelete a;\n</code></pre>\n<p>I want to know do I need to write an empty <code>virtual</code> dtor?</p>\n<p>I have tried g++ and vc++2008 and they won't cause a leak. But I would like to know what is correct in C++ standard.</p>\n", "AcceptedAnswerId": "2100685", "Title": "Will using delete with a base class pointer cause a memory leak?", "CreationDate": "2010-01-20T10:32:27.510", "Id": "2100644", "CommentCount": "1", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2014-08-11T06:10:57.933", "LastEditorUserId": "3622940", "LastActivityDate": "2014-08-11T06:10:57.933", "Score": "17", "OwnerUserId": "105597", "Tags": "<c++><memory-management><memory-leaks>", "AnswerCount": "5"}, "2100677": {"Id": "2100677", "PostTypeId": "2", "Body": "<p>For only primitive data I believe you're fine. You might legitimately not want to incur the cost of a v-table in this case.\nOtherwise, a virtual d'tor is definitely preferred.</p>\n", "LastActivityDate": "2010-01-20T10:38:00.787", "CommentCount": "0", "CreationDate": "2010-01-20T10:38:00.787", "ParentId": "2100644", "Score": "1", "OwnerUserId": "106095"}, "2100662": {"Id": "2100662", "PostTypeId": "2", "Body": "<p>According to the C++ standard, what you have is undefined behaviour - this may manifest itself as a leak, it may not, For your code to be correct you need a virtual destructor.</p>\n<p>Also, you do not need that (A*) cast. Whenever you find yourself using a C-style cast in C++, you can be fairly sure that either it is unecessary, or your code is wrong.</p>\n", "OwnerDisplayName": "anon", "LastActivityDate": "2010-01-20T10:35:37.393", "Score": "16", "CreationDate": "2010-01-20T10:35:37.393", "ParentId": "2100644", "CommentCount": "0"}, "2100674": {"Id": "2100674", "PostTypeId": "2", "Body": "<p>This is undefined behaviour - maybe everything's fine, maybe whetever goes wrong. Either don't do it or supply the base class with a virtual destructor.</p>\n<p>In most implementations this will not leak - there're no heap-allocated member functions in the class, so the only thing needed when <code>delete</code> is done is to deallocate memory. Deallocating memory uses only the address of the object, nothing more, the heap does all the rest.</p>\n", "LastActivityDate": "2010-01-20T10:37:32.410", "CommentCount": "0", "CreationDate": "2010-01-20T10:37:32.410", "ParentId": "2100644", "Score": "1", "OwnerUserId": "57428"}});