post_cb({"46258641": {"CommentCount": "4", "ViewCount": "60", "PostTypeId": "1", "LastEditorUserId": "3723423", "CreationDate": "2017-09-16T21:37:22.330", "LastActivityDate": "2017-09-17T11:35:53.017", "Title": "Using std::chrono library to adjust the application fps but getting weird behavior", "LastEditDate": "2017-09-17T09:06:10.110", "Id": "46258641", "Score": "2", "Body": "<p>I wrote the code bellow using std::chrono c++ library , what i am trying to do is\nto fix the application's <code>FPS</code>on 60 , but i am getting 50 <code>FPS</code>, not a performance issue for sure\nbecause i am computing nothing . but it is certainly an invalid usage or a bug .</p>\n<p>the <code>TARGET_FPS</code> macro is set to the target <code>FPS</code>that i want to get , then the console window\ndisplays the real actual FPS , these following lines shows the values i set <code>TARGET_FPS</code>to , and each is associated to the final <code>FPS</code>.</p>\n<pre><code> TARGET_FPS----&gt;FPS\n\n       60-----&gt;50\n       90-----&gt;50\n       100-----&gt;100\n     1000-----&gt;100\n     10000-----&gt;100\n   whatever -----&gt;100\n</code></pre>\n<p>Even if i define <code>TARGET_FPS</code> to 1000000000 i get 100 <code>FPS</code>, even when i define it to 458 or whatever value more than 100 i will get 100 <code>FPS</code>as output .</p>\n<pre><code>#include &lt;chrono&gt; /// to use std::chrono namespace \n#include &lt;iostream&gt; /// for console output\n#include &lt;thread&gt; /// for std::this_thread::sleep_for()\n#define TARGET_FPS 60// our target FPS    \nusing frame_len_type = std::chrono::duration&lt;float,std::ratio&lt;1,TARGET_FPS&gt;&gt;; /// this is the     duration that defines the length of a frame\nusing fsecond = std::chrono::duration&lt;float&gt;; /// this duration    represents once second and uses 'float' type as internal representation\nconst frame_len_type target_frame_len(1); /// we will define this    constant here , to represent on frame duration ( defined to avoid    construction inside a loop )\nvoid app_logic(){ /** ... All application logic goes here ... **/}\nint main() /// our main function !\n{\n    using sys_clock = std::chrono::system_clock; /// simplify the type    name to make the code readable\n     sys_clock::time_point frame_begin,frame_end; /// we will use these time points to point to frame begin and end\n     while (true)\n     {\n      frame_begin = sys_clock::now(); /// there we go !\n      app_logic(); /// lets be logical here :)\n      frame_end = sys_clock::now(); /// we are done so quick !\n      std::this_thread::sleep_for( target_frame_len-    (frame_end.time_since_epoch()-frame_begin.time_since_epoch()) ); /// we will take a rest that is equal to what we where supposed to take to finish the actual target frame length\n      std::cout&lt;&lt; fsecond(1) / ( sys_clock::now() - frame_begin) &lt;&lt;std::endl; /// this will show ass the current FPS\n     }\n    return 0; /// return to OS\n} /// end of code\n</code></pre>\n", "Tags": "<c++><windows><thread-sleep><frame-rate><chrono>", "OwnerUserId": "3856444", "AnswerCount": "2"}, "46259960": {"ParentId": "46258641", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Problem solved :) </p>\n<pre><code>    #include &lt;chrono&gt; /// to use std::chrono namespace\n    #include &lt;iostream&gt; /// for console output\n    #include &lt;thread&gt; /// for std::this_thread::sleep_for()\n    #include &lt;windows.h&gt;\n    #define TARGET_FPS 500 /// our target fps as a macro\n    const float target_fps = (float)TARGET_FPS; /// our target fps\n    float tmp_target_fps = target_fps;  /// used to adjust the target fps depending on the actual real fps to reach the real target fps\n    using frame_len_type = std::chrono::duration&lt;float,std::ratio&lt;1,TARGET_FPS&gt;&gt;; /// this is the     duration that defines the length of a frame\n    using fsecond = std::chrono::duration&lt;float&gt;; /// this duration    represents once second and uses 'float' type as internal representation\n    fsecond target_frame_len(1.0f/tmp_target_fps); /// we will define this    constant here , to represent on frame duration ( defined to avoid    construction inside a loop )\n    bool enable_fps_oscillation = true;\n    void app_logic()\n    {\n        /** ... All application logic goes here ... **/\n    }\n    class HeighResolutionClockKeeper\n    {\n    private :\n        bool using_higher_res_timer;\n    public :\n        HeighResolutionClockKeeper() : using_higher_res_timer(false) {}\n        void QueryHeighResolutionClock()\n        {\n            if (timeBeginPeriod(1) != TIMERR_NOCANDO)\n            {\n                using_higher_res_timer = true;\n            }\n        }\n        void FreeHeighResolutionClock()\n        {\n            if (using_higher_res_timer)\n            {\n                timeEndPeriod(1);\n            }\n        }\n        ~HeighResolutionClockKeeper()\n        {\n            FreeHeighResolutionClock(); /// if exception is thrown , if not this wont cause problems thanks to the flag we put\n        }\n    };\n    int main() /// our main function !\n    {\n        HeighResolutionClockKeeper MyHeighResolutionClockKeeper;\n        MyHeighResolutionClockKeeper.QueryHeighResolutionClock();\n        using sys_clock = std::chrono::system_clock; /// simplify the type    name to make the code readable\n        sys_clock::time_point frame_begin,frame_end; /// we will use these time points to point to frame begin and end\n        sys_clock::time_point start_point = sys_clock::now();\n        float accum_fps = 0.0f;\n        int frames_count = 0;\n        while (true)\n        {\n            frame_begin = sys_clock::now(); /// there we go !\n            app_logic(); /// lets be logical here :)\n            frame_end = sys_clock::now(); /// we are done so quick !\n            std::this_thread::sleep_for( target_frame_len-    (frame_end.time_since_epoch()-frame_begin.time_since_epoch()) ); /// we will take a rest that is equal to what we where supposed to take to finish the actual target frame length\n            float fps =  fsecond(1) / ( sys_clock::now() - frame_begin) ; /// this will show ass the current FPS\n\n    /// obviously we will not be able to hit the exact FPS  we want se we need to oscillate around until we\n    /// get a very close average FPS by time .\n            if (fps &lt; target_fps) /// our real fps is less than what we want\n                tmp_target_fps += 0.01; /// lets asl for more !\n            else if (fps &gt; target_fps ) /// it is more than what we want\n                tmp_target_fps -=0.01; /// lets ask for less\n            if(enable_fps_oscillation == true)\n            {\n             /// now we will adjust our target frame length for match the new target FPS\n                target_frame_len = fsecond(1.0f/tmp_target_fps);\n           /// used to calculate average FPS\n                accum_fps+=fps;\n                frames_count++;\n                /// each 1 second\n                if( (sys_clock::now()-start_point)&gt;fsecond(1.0f)) /// show average each 1 sec\n                {\n                    start_point=sys_clock::now();\n                    std::cout&lt;&lt;accum_fps/frames_count&lt;&lt;std::endl; /// it is getting more close each time to our target FPS\n                }\n            }\n            else\n            {\n                /// each frame\n                std::cout&lt;&lt;fps&lt;&lt;std::endl;\n            }\n        }\n        MyHeighResolutionClockKeeper.FreeHeighResolutionClock();\n        return 0; /// return to OS\n    } /// end of code\n</code></pre>\n<p>I had to add <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/dd757624(v=vs.85).aspx\" rel=\"nofollow noreferrer\"><code>timeBeginPeriod()</code></a> and <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/dd757626(v=vs.85).aspx\" rel=\"nofollow noreferrer\"><code>timeEndPeriod()</code></a> on windows platform , thanks to this awesome , lost-in-the-wind  website <a href=\"http://www.geisswerks.com/ryan/FAQS/timing.html\" rel=\"nofollow noreferrer\">http://www.geisswerks.com/ryan/FAQS/timing.html</a> from <a href=\"http://www.geisswerks.com/ryan/pers.html\" rel=\"nofollow noreferrer\">Ryan Geiss </a>.</p>\n<p><strong><em>Details :</em></strong> </p>\n<p>Because we can't actually hit the exact fps that we want ( very slightly above or bellow , but up to 1000 fps and down to 1 fps thanks to timeXPeriod(1) ) therefore i used some extra dump fps variable to adjust the target fps we areasking for , increasing it and decreasing it .., that will let us control the actual application fps to hits our real target fps as an average (you can enable and disable this using 'enable_fps_oscillation' flag ) this fixes an issue for fps = 60 because we can't hit it ( +/-0.5 ) , but if we set fps = 500 we hit it and we dont need to oscillate bellow and above it </p>\n", "OwnerUserId": "3856444", "LastEditorUserId": "3856444", "LastEditDate": "2017-09-17T11:35:53.017", "Id": "46259960", "Score": "1", "CreationDate": "2017-09-17T01:49:33.687", "LastActivityDate": "2017-09-17T11:35:53.017"}, "46259362": {"ParentId": "46258641", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The timing resolution of std::chrono is system dependent: </p>\n<ul>\n<li>In <a href=\"https://stackoverflow.com/a/24595079/3723423\">this answer</a> to another question, you'll find a code snippet to determine the approximate timing resolution of your platform.  </li>\n<li>On windows 7, the <a href=\"https://software.intel.com/en-us/articles/power-analysis-guide-for-windows#_Toc343774425\" rel=\"nofollow noreferrer\">default timer resolution is 15.6 ms</a> </li>\n<li>In addition, the <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ms686298(v=vs.85).aspx\" rel=\"nofollow noreferrer\">windows API sleep</a> on which the c++ standard library has to rely, does not guarantee that the thread will resume execution immediately after the waiting time:  </li>\n</ul>\n<blockquote>\n<p id=\"so_46258641_46259362_0\">After the sleep interval has passed, the thread is ready to run. If\n  you specify 0 milliseconds, the thread will relinquish the remainder\n  of its time slice but remain ready. Note that a ready thread is not\n  guaranteed to run immediately. Consequently, the thread may not run\n  until some time after the sleep interval elapses.</p>\n</blockquote>\n<ul>\n<li>The C++ standard library doesn't give better guarantees for <code>sleep_for</code>, whatever OS you are using:  </li>\n</ul>\n<blockquote>\n<p id=\"so_46258641_46259362_1\"><strong>30.3.2/7:</strong> Effect: Blocks the calling thread for the relative timeout (...)</p>\n</blockquote>\n<p>Consequence:</p>\n<ul>\n<li>With FPS set to 60, there would be a frame every 16.6 ms.  So assuming that your <code>app_logic()</code> is ultra fast, your thread will sleep at least 15.6 ms.  If the logic takes 1 ms to execute, you'd be exactly at 60 FPS.  </li>\n<li><p>However, according to the API documentation,  <em>if [wait time] is greater than one tick but less than two, the wait can be anywhere between one and two ticks</em>, so that the average sleep time will be between 15.6 and 31.2 ms, whic means, inversely, that your FPS will be between 60 and 32 FPS. This  explains why you only achieve 50 FPS.</p></li>\n<li><p>When you set FPS to 100, there should be a frame every 10ms.  This is below the timer accuracy.  There might be no sleep at all.  If no other thread is ready to run, the function will return immediately, so that you will be at your maximum throughput.  If you set a higher FPS, you'd be in exactly the same situation as the expected waiting time would always be below the timer accuracy.  The result will therefore not improve.  </p></li>\n</ul>\n", "OwnerUserId": "3723423", "LastEditorUserId": "3723423", "LastEditDate": "2017-09-16T23:53:04.537", "Id": "46259362", "Score": "2", "CreationDate": "2017-09-16T23:29:39.363", "LastActivityDate": "2017-09-16T23:53:04.537"}, "bq_ids": {"n4140": {"so_46258641_46259362_1": {"section_id": 2743, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_46258641_46259362_1": {"section_id": 2704, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_46258641_46259362_1": {"section_id": 3481, "quality": 0.7142857142857143, "length": 5}}}});