post_cb({"19307380": {"ParentId": "19306984", "CommentCount": "1", "Body": "<p>Both behaviors are correct, certainly according to the C++03 standard (8.5.3 [dcl.init.ref] paragraph 5):</p>\n<blockquote>\n<p id=\"so_19306984_19307380_0\">Otherwise, the reference shall be to a non-volatile const type (i.e., cv1 shall be const). [Example: ...]</p>\n<ul>\n<li><p id=\"so_19306984_19307380_1\">If the initializer expression is an rvalue, with T2 a class type, and \u201ccv1 T1\u201d is reference-compatible with \u201ccv2 T2,\u201d the reference is bound in one of the following ways (the choice is implementation-defined):</p>\n<p id=\"so_19306984_19307380_2\">\u2014 The reference is bound to the object represented by the rvalue (see 3.10) or to a sub-object within that object.</p>\n<p id=\"so_19306984_19307380_3\">\u2014 A temporary of type \u201ccv1 T2\u201d [sic] is created, and a constructor is called to copy the entire rvalue object into the temporary. The reference is bound to the temporary or to a sub-object within the temporary.</p></li>\n</ul>\n</blockquote>\n<p>I think the definition of C++11 still allows the copy to be made but the wording doesn't as clearly allow the copy. In any case, VC++ doesn't claim to be fully C++11 compliant.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "19307380", "Score": "2", "CreationDate": "2013-10-10T22:33:44.520", "LastActivityDate": "2013-10-10T22:33:44.520"}, "19306984": {"CommentCount": "11", "AcceptedAnswerId": "19307380", "PostTypeId": "1", "LastEditorUserId": "434551", "CreationDate": "2013-10-10T22:00:22.623", "LastActivityDate": "2017-05-26T19:11:06.390", "LastEditDate": "2017-05-26T19:11:06.390", "ViewCount": "674", "FavoriteCount": "0", "Title": "Life extension of temporary by const reference", "Id": "19306984", "Score": "4", "Body": "<p><strong>C++</strong></p>\n<p>I'm trying to see how const references prolong the lifetime of temporaries. I'm running the code from the snippet in <a href=\"https://stackoverflow.com/questions/57483/what-are-the-differences-between-pointer-variable-and-reference-variable-in-c/60148#60148\">one of the answers to <em>What are the differences between pointer variable and reference variable in C++?</em></a> and got conflicting results between VC11 and g++ 4.8. I've expanded the snippet here:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nstruct scope_test\n{\n    ~scope_test() { printf(\"scope_test done!\\n\"); }\n};\n\nint main()\n{\n    const scope_test&amp; test = scope_test();\n    printf(\"in scope\\n\");\n}\n</code></pre>\n<p>The answerer got the result:</p>\n<pre><code>in scope\nscope_test done!\n</code></pre>\n<p>I tried it in VC11 and got this:</p>\n<pre><code>scope_test done!\nin scope\nscope_test done!\n</code></pre>\n<p>I assumed the VC11 result was caused by a lack of copy elision, so I tried to see if disabling copy elision on g++ with <code>fno-elide-constructors</code> would give the same result as VC11. (I don't think copy elision can be toggled in VC11.) But, g++ gives the answerer's result regardless of the setting of the flag.</p>\n<p>The C++11 Standard, ISO/IEC 14882:2011(E), \u00a712.2/4 and /5 states:</p>\n<blockquote>\n<p id=\"so_19306984_19306984_0\">There are two contexts in which temporaries are destroyed at a\n  different point than the end of the full-expression...</p>\n<p id=\"so_19306984_19306984_1\">The second context is when a reference is bound to a temporary. The\n  temporary to which the reference is bound or the temporary that is the\n  complete object of a subobject to which the reference is bound\n  persists for the lifetime of the reference except:</p>\n<p id=\"so_19306984_19306984_2\">...</p>\n</blockquote>\n<p>Does the VC11 result have anything to do with copy elision? Is it a VC11 bug?</p>\n<p>The answerer states:</p>\n<blockquote>\n<p id=\"so_19306984_19306984_3\">temporaries assigned to const references live until the const\n  reference goes out of scope</p>\n</blockquote>\n<p>The list of exceptions to \u00a712.2/5 don't rule out a <code>non-const</code> reference. What am I missing from the Standard?</p>\n<p>Removing the const in VC11 produces the same result as the VC11 one with the const. Removing the const in g++ gives <code>error: invalid initialization of non-const reference of type \u2018scope_test&amp;\u2019 from an rvalue of type \u2018scope_test\u2019</code>. Why is there a difference?</p>\n<p><strong>EDIT</strong>:</p>\n<p>I added copy and move constructors and tried:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nstruct scope_test\n{\n    scope_test() { printf(\"regular ctor\\n\"); }\n    scope_test(const scope_test&amp; src) { printf(\"copy ctor\\n\"); }\n    scope_test(scope_test&amp;&amp; src) { printf(\"move ctor\\n\"); }\n    ~scope_test() { printf(\"scope_test done!\\n\"); }\n};\n\nint main()\n{\n    const scope_test&amp; test= scope_test();\n    printf(\"in scope\\n\");\n}\n</code></pre>\n<p>Regardless of the toggling of copy elision, g++ gives:</p>\n<pre><code>regular ctor\nin scope\nscope_test done!\n</code></pre>\n<p>VC11 gives the same thing, even if the <code>const</code> is removed. If the <code>const</code> is removed from g++, g++ still gives <code>error: invalid initialization of non-const reference of type \u2018scope_test&amp;\u2019 from an rvalue of type \u2018scope_test\u2019</code>.</p>\n", "Tags": "<c++><object-lifetime><temporary-objects><const-reference><scopeguard>", "OwnerUserId": "2090317", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_19306984_19306984_1": {"section_id": 382, "quality": 0.9047619047619048, "length": 19}, "so_19306984_19307380_2": {"section_id": 3321, "quality": 0.6363636363636364, "length": 7}, "so_19306984_19307380_0": {"section_id": 3321, "quality": 0.75, "length": 6}, "so_19306984_19306984_0": {"section_id": 381, "quality": 1.0, "length": 10}}, "n3337": {"so_19306984_19306984_1": {"section_id": 373, "quality": 0.9047619047619048, "length": 19}, "so_19306984_19307380_0": {"section_id": 3191, "quality": 0.75, "length": 6}, "so_19306984_19306984_0": {"section_id": 372, "quality": 1.0, "length": 10}}, "n4659": {"so_19306984_19307380_2": {"section_id": 4087, "quality": 0.5454545454545454, "length": 6}, "so_19306984_19307380_0": {"section_id": 4087, "quality": 0.75, "length": 6}, "so_19306984_19306984_1": {"section_id": 397, "quality": 0.8571428571428571, "length": 18}, "so_19306984_19306984_0": {"section_id": 396, "quality": 0.9, "length": 9}, "so_19306984_19307380_1": {"section_id": 4087, "quality": 0.5333333333333333, "length": 8}}}});