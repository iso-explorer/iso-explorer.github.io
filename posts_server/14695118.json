post_cb({"14699320": {"ParentId": "14695118", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>In Short, <code>2147483648</code> overflows to <code>-2147483648</code>, and <code>(-(-2147483648) &gt; 0)</code> is <code>true</code>.</p>\n<p><a href=\"http://www.wolframalpha.com/input/?i=2147483648+to+base+2\" rel=\"nofollow noreferrer\">This</a> is how <code>2147483648</code> looks like in binary.</p>\n<p>In addition, in the case of signed binary calculations, the most significant bit (\"MSB\") is the sign bit. <a href=\"https://stackoverflow.com/questions/1049722/what-is-2s-complement\">This question</a> may help explain why.</p>\n", "OwnerUserId": "1391568", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:47:01.677", "Id": "14699320", "Score": "7", "CreationDate": "2013-02-05T02:42:28.373", "LastActivityDate": "2013-02-05T18:39:39.017"}, "14695400": {"CommentCount": "8", "CreationDate": "2013-02-04T20:50:19.903", "CommunityOwnedDate": "2013-02-05T00:07:11.760", "LastEditorUserId": "1421049", "LastActivityDate": "2013-02-05T20:09:17.667", "ParentId": "14695118", "PostTypeId": "2", "LastEditDate": "2013-02-05T20:09:17.667", "Id": "14695400", "Score": "42", "Body": "<p>The compiler (VC2012) promote to the \"minimum\" integers that can hold the values. In the first case, <code>signed int</code> (and <code>long int</code>) cannot (before the sign is applied), but <code>unsigned int</code> can: <strong><code>2147483648</code> has <code>unsigned int</code></strong> ???? type. \nIn the second you force <code>int</code> from the <code>unsigned</code>. </p>\n<pre><code>const bool i= (-2147483648 &gt; 0) ;  //   --&gt; true\n</code></pre>\n<blockquote>\n<p id=\"so_14695118_14695400_0\">warning C4146: unary minus operator applied to <strong>unsigned type</strong>, result still <strong>unsigned</strong></p>\n</blockquote>\n<p>Here are  related \"curiosities\":</p>\n<pre><code>const bool b= (-2147483647      &gt; 0) ; //  false\nconst bool i= (-2147483648      &gt; 0) ; //  true : result still unsigned\nconst bool c= ( INT_MIN-1       &gt; 0) ; //  true :'-' int constant overflow\nconst bool f= ( 2147483647      &gt; 0) ; //  true\nconst bool g= ( 2147483648      &gt; 0) ; //  true\nconst bool d= ( INT_MAX+1       &gt; 0) ; //  false:'+' int constant overflow\nconst bool j= ( int(-2147483648)&gt; 0) ; //  false : \nconst bool h= ( int(2147483648) &gt; 0) ; //  false\nconst bool m= (-2147483648L     &gt; 0) ; //  true \nconst bool o= (-2147483648LL    &gt; 0) ; //  false\n</code></pre>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"noreferrer\">C++11 standard</a>:</p>\n<blockquote>\n<p id=\"so_14695118_14695400_1\">2.14.2 Integer literals [lex.icon]</p>\n</blockquote>\n<p>\u2026  </p>\n<blockquote>\n<p id=\"so_14695118_14695400_2\">An integer literal is a sequence of digits that has no period or\n  exponent part. An integer literal may have a prefix that specifies its\n  base and a suffix that specifies its type.</p>\n</blockquote>\n<p>\u2026 </p>\n<blockquote>\n<p id=\"so_14695118_14695400_3\">The type of an integer literal is the first of the corresponding list\n  in which its value can be represented.</p>\n</blockquote>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/FIHAZ.png\"> </img></p>\n<blockquote>\n<p id=\"so_14695118_14695400_4\">If an integer literal cannot be represented by any type in its list\n  and an extended integer type (3.9.1) can represent its value, it may\n  have that extended integer type. If all of the types in the list for\n  the literal are signed, the extended integer type shall be signed. If\n  all of the types in the list for the literal are unsigned, the\n  extended integer type shall be unsigned. If the list contains both\n  signed and unsigned types, the extended integer type may be signed or\n  unsigned. A program is ill-formed if one of its translation units\n  contains an integer literal that cannot be represented by any of the\n  allowed types.</p>\n</blockquote>\n<p>And these are the promotions rules for integers in the standard.</p>\n<blockquote>\n<p id=\"so_14695118_14695400_5\"><strong>4.5 Integral promotions</strong> [conv.prom] </p>\n<p id=\"so_14695118_14695400_6\">A prvalue of an integer type other than <code>bool</code>, <code>char16_t</code>, <code>char32_t</code>, or\n  <code>wchar_t</code> whose integer conversion rank (4.13) is less than the rank of\n  int can be converted to a prvalue of type <code>int</code> if <code>int</code> can represent all\n  the values of the source type; otherwise, the source prvalue can be\n  converted to a prvalue of type <strong><code>unsigned int</code>.</strong></p>\n</blockquote>\n", "OwnerUserId": "1458030"}, "14695202": {"ParentId": "14695118", "PostTypeId": "2", "CommentCount": "18", "Body": "<p><code>-2147483648</code> is not a \"number\". C++ language does not support negative literal values.</p>\n<p><code>-2147483648</code> is actually an expression: a positive literal value <code>2147483648</code> with unary <code>-</code> operator in front of it. Value <code>2147483648</code> is apparently too large for the positive side of <code>int</code> range on your platform. If type <code>long int</code> had greater range on your platform, the compiler would have to automatically assume that <code>2147483648</code> has <code>long int</code> type. (In C++11 the compiler would also have to consider <code>long long int</code> type.) This would make the compiler to evaluate <code>-2147483648</code> in the domain of larger type and the result would be negative, as one would expect. </p>\n<p>However, apparently in your case the range of <code>long int</code> is the same as range of <code>int</code>, and in general there's no integer type with greater range than <code>int</code> on your platform. This formally means that positive constant <code>2147483648</code> overflows all available signed integer types, which in turn means that the behavior of your program is undefined. (It is a bit strange that the language specification opts for undefined behavior in such cases, instead of requiring a diagnostic message, but that's the way it is.)</p>\n<p>In practice, taking into account that the behavior is undefined, <code>2147483648</code> might get interpreted as some implementation-dependent negative value which happens to turn positive after having unary <code>-</code> applied to it. Alternatively, some implementations might decide to attempt using unsigned types to represent the value (for example, in C89/90 compilers were required to use <code>unsigned long int</code>, but not in C99 or C++). Implementations are allowed to do anything, since the behavior is undefined anyway.</p>\n<p>As a side note, this is the reason why constants like <code>INT_MIN</code> are typically defined as</p>\n<pre><code>#define INT_MIN (-2147483647 - 1)\n</code></pre>\n<p>instead of the seemingly more straightforward </p>\n<pre><code>#define INT_MIN -2147483648\n</code></pre>\n<p>The latter would not work as intended.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2013-06-11T00:39:34.507", "Id": "14695202", "Score": "377", "CreationDate": "2013-02-04T20:38:46.733", "LastActivityDate": "2013-06-11T00:39:34.507"}, "14714238": {"ParentId": "14695118", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Because <code>-2147483648</code> is actually <code>2147483648</code> with negation (<code>-</code>) applied to it, the number isn't what you'd expect. It is actually the equivalent of this pseudocode: <code>operator -(2147483648)</code></p>\n<p>Now, assuming your compiler has <code>sizeof(int)</code> equal to <code>4</code> and <code>CHAR_BIT</code> is defined as <code>8</code>, that would make <code>2147483648</code> overflow the maximum signed value of an integer (<code>2147483647</code>). So what is the maximum plus one? Lets work that out with a 4 bit, 2s compliment integer.</p>\n<p>Wait! 8 overflows the integer! What do we do? Use its unsigned representation of <code>1000</code> and interpret the bits as a signed integer. This representation leaves us with <code>-8</code> being applied the 2s complement negation resulting in <code>8</code>, which, as we all know, is greater than <code>0</code>.</p>\n<p>This is why <code>&lt;limits.h&gt;</code> (and <code>&lt;climits&gt;</code>) commonly define <code>INT_MIN</code> as <code>((-2147483647) - 1)</code> - so that the maximum signed integer (<code>0x7FFFFFFF</code>) is negated (<code>0x80000001</code>), then decremented (<code>0x80000000</code>).</p>\n", "OwnerUserId": "1350209", "LastEditorUserId": "1350209", "LastEditDate": "2015-08-24T10:24:45.840", "Id": "14714238", "Score": "5", "CreationDate": "2013-02-05T18:21:40.420", "LastActivityDate": "2015-08-24T10:24:45.840"}, "14695118": {"CommentCount": "4", "AcceptedAnswerId": "14695202", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-02-04T20:33:53.057", "LastActivityDate": "2015-08-24T10:24:45.840", "LastEditDate": "2017-05-23T10:31:20.233", "ViewCount": "23219", "FavoriteCount": "69", "Title": "(-2147483648> 0) returns true in C++?", "Id": "14695118", "Score": "229", "Body": "<p>-2147483648 is the smallest integer for integer type with 32 bits, but it seems that it will overflow in the <code>if(...)</code> sentence:</p>\n<pre><code>if (-2147483648 &gt; 0)\n    std::cout &lt;&lt; \"true\";\nelse\n    std::cout &lt;&lt; \"false\";\n</code></pre>\n<p>This will print <code>true</code> in my testing. However, if we cast -2147483648 to integer, the result will be different:</p>\n<pre><code>if (int(-2147483648) &gt; 0)\n    std::cout &lt;&lt; \"true\";\nelse\n    std::cout &lt;&lt; \"false\";\n</code></pre>\n<p>This will print <code>false</code>.</p>\n<p>I'm confused. Can anyone give an explanation on this?</p>\n<hr>\n<p>Update 02-05-2012:</p>\n<p>Thanks for your comments, in my compiler, the size of int is 4 bytes. I'm using VC for some simple testing. I've changed the description in my question.</p>\n<p>That's a lot of very good replys in this post, <a href=\"https://stackoverflow.com/a/14695202/2040924\">AndreyT</a> gave a very detailed explanation on how the compiler will behaviour on such input, and how this minimum integer was implemented. <a href=\"https://stackoverflow.com/a/14695400/2040924\">qPCR4vir</a> on the other hand gave some related \"curiosities\" and how integer are represented. So impressive!</p>\n</hr>", "Tags": "<c++><overflow>", "OwnerUserId": "2040924", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_14695118_14695400_4": {"section_id": 5342, "quality": 0.9838709677419355, "length": 61}, "so_14695118_14695400_3": {"section_id": 5341, "quality": 0.9090909090909091, "length": 10}, "so_14695118_14695400_2": {"section_id": 5340, "quality": 1.0, "length": 19}, "so_14695118_14695400_6": {"section_id": 21, "quality": 0.9743589743589743, "length": 38}}, "n3337": {"so_14695118_14695400_4": {"section_id": 5139, "quality": 0.9838709677419355, "length": 61}, "so_14695118_14695400_3": {"section_id": 5138, "quality": 0.9090909090909091, "length": 10}, "so_14695118_14695400_2": {"section_id": 5137, "quality": 1.0, "length": 19}, "so_14695118_14695400_6": {"section_id": 18, "quality": 0.9743589743589743, "length": 38}}, "n4659": {"so_14695118_14695400_4": {"section_id": 6763, "quality": 0.9838709677419355, "length": 61}, "so_14695118_14695400_3": {"section_id": 6762, "quality": 0.9090909090909091, "length": 10}, "so_14695118_14695400_2": {"section_id": 6761, "quality": 0.9473684210526315, "length": 18}, "so_14695118_14695400_6": {"section_id": 21, "quality": 0.9743589743589743, "length": 38}}}});