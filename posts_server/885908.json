post_cb({"3814997": {"Id": "3814997", "PostTypeId": "2", "Body": "<p>I heard about this once.</p>\n<p>It came from an AMD assembly programmer. He stated that C programmers (the people) don't realize that their code has inefficiencies. He said today though, gcc compilers are very good, and put people like him out of business. He said for example, and told me about the <code>while 1</code> vs <code>for(;;)</code>. I use it now out of habit but gcc and especially interpreters will do the same operation (a processor jump) for both these days, since they are optimized.</p>\n", "LastEditorUserId": "1822514", "LastActivityDate": "2014-07-23T03:09:27.870", "Score": "7", "CreationDate": "2010-09-28T16:35:10.113", "ParentId": "885908", "CommentCount": "0", "OwnerUserId": "439078", "LastEditDate": "2014-07-23T03:09:27.870"}, "886172": {"Id": "886172", "PostTypeId": "2", "Body": "<p>For all the people arguing you shouldn't use indefinte while loops, and suggesting daft stuff like using open <em>goto</em>'s ( seriously, ouch ) </p>\n<pre><code>while (1) {\n     last if( condition1 );\n     code();\n     more_code(); \n     last if( condition2 ); \n     even_more_code(); \n}\n</code></pre>\n<p>Can't really be represented effectively any other way. Not without creating an exit variable and doing black magic to keep it synced. </p>\n<p>If you have a penchant for the more goto-esque syntax, use something sane that limits  scope. </p>\n<pre><code>flow: { \n\n   if ( condition ){ \n      redo flow;\n   }\n   if ( othercondition ){ \n       redo flow;\n   }\n   if ( earlyexit ){ \n       last flow;\n   }\n   something(); # doesn't execute when earlyexit is true \n}\n</code></pre>\n<p><strong>Ultimately Speed is not that important</strong> </p>\n<p>Worring about how effective speed wise different looping constructs are is a massive waste of time. Premature optimization through and through. I can't think of any situation I've ever seen where profiling code found bottlenecks in my choice of looping construct.  </p>\n<p>Generally its the <em>how</em> of the loop and the <em>what</em> of the loop. </p>\n<p>You should \"optimize\" for readability and succinctness, and write whatever is best at explaining the problem to the next poor sucker who finds your code. </p>\n<p>If you use the \"goto LABEL\" trick somebody mentioned, and I have to use your code, be prepared to sleep with one eye open, especially if you do it more than once, because that sort of stuff creates <strong>horrifically</strong> spaghetti code. </p>\n<p>Just because you <strong>can</strong> create spaghetti code doesn't mean you <strong>should</strong></p>\n", "LastEditorUserId": "15614", "LastActivityDate": "2009-05-20T04:51:30.810", "Score": "13", "CreationDate": "2009-05-20T04:46:04.703", "ParentId": "885908", "CommentCount": "0", "OwnerUserId": "15614", "LastEditDate": "2009-05-20T04:51:30.810"}, "885917": {"Id": "885917", "PostTypeId": "2", "Body": "<p>There's not much reason to prefer one over the other.  I do think that <code>while(1)</code> and particularly <code>while(true)</code> are more readable than <code>for(;;)</code>, but that's just my preference.</p>\n", "LastActivityDate": "2009-05-20T02:38:46.833", "CommentCount": "8", "CreationDate": "2009-05-20T02:38:46.833", "ParentId": "885908", "Score": "49", "OwnerUserId": "1288"}, "885921": {"Id": "885921", "PostTypeId": "2", "Body": "<p>In an optimized build of a compiled language, there should be no appreciable difference between the two. Neither should end up performing any comparisons at runtime, they will just execute the loop code until you manually exit the loop (e.g. with a <code>break</code>).</p>\n", "LastActivityDate": "2009-05-20T02:39:42.213", "CommentCount": "0", "CreationDate": "2009-05-20T02:39:42.213", "ParentId": "885908", "Score": "5", "OwnerUserId": "18529"}, "3506032": {"Id": "3506032", "PostTypeId": "2", "Body": "<p>I'm surprised no one has offered the more direct form, corresponding to the desired assembly:</p>\n<pre><code>forever:\n     do stuff;\n     goto forever;\n</code></pre>\n", "LastActivityDate": "2010-08-17T19:10:10.337", "CommentCount": "2", "CreationDate": "2010-08-17T19:10:10.337", "ParentId": "885908", "Score": "2", "OwnerUserId": "90002"}, "bq_ids": {"n4140": {"so_885908_887298_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 3904}}, "n3337": {"so_885908_887298_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 3764}}, "n4659": {"so_885908_887298_2": {"length": 14, "quality": 1.0, "section_id": 4790}}}, "2182797": {"Id": "2182797", "PostTypeId": "2", "Body": "<p>From Stroustrup, TC++PL (3rd edition), \u00a76.1.1:</p>\n<blockquote>\n<p id=\"so_885908_2182797_0\">The curious notation <code>for (;;)</code> is the standard way to specify an infinite loop; you could pronounce it \"forever\". [...] <code>while (true)</code> is an alternative.</p>\n</blockquote>\n<p>I prefer <code>for (;;)</code>.</p>\n", "LastActivityDate": "2010-02-02T08:54:27.140", "CommentCount": "0", "CreationDate": "2010-02-02T08:54:27.140", "ParentId": "885908", "Score": "8", "OwnerUserId": "264180"}, "891469": {"Id": "891469", "PostTypeId": "2", "Body": "<p>I would think that both are the same in terms of performance. But I would prefer while(1) for readability but I question why you need an infinite loop.</p>\n", "LastActivityDate": "2009-05-21T05:13:37.180", "CommentCount": "0", "CreationDate": "2009-05-21T05:13:37.180", "ParentId": "885908", "Score": "-2", "OwnerUserId": "106464"}, "885918": {"Id": "885918", "PostTypeId": "2", "Body": "<p>They are the same. There are much more important questions to ponder.</p>\n", "LastActivityDate": "2009-05-20T02:38:51.687", "CommentCount": "9", "CreationDate": "2009-05-20T02:38:51.687", "ParentId": "885908", "Score": "-8", "OwnerUserId": "5987"}, "7294866": {"Id": "7294866", "PostTypeId": "2", "Body": "<p>I am surprised that nobody properly tested <code>for (;;)</code> versus <code>while (1)</code> in perl!</p>\n<p>Because perl is interpreted language, the time to run a perl script does not only consist of the execution phase (which in this case is the same) but also of the interpretation phase before execution. Both of these phases have to be taken in account when making a speed comparison.</p>\n<p>Luckily perl has a convenient <a href=\"http://perldoc.perl.org/Benchmark.html\" rel=\"nofollow\">Benchmark module</a> which we can use to implement a benchmark such as follows:</p>\n<pre><code>#!/usr/bin/perl -w\n\nuse Benchmark qw( cmpthese );\n\nsub t_for   { eval 'die; for (;;) { }'; }\nsub t_for2  { eval 'die; for (;;)  { }'; }\nsub t_while { eval 'die; while (1) { }'; }\n\ncmpthese(-60, { for =&gt; \\&amp;t_for, for2 =&gt; \\&amp;t_for2, while =&gt; \\&amp;t_while });\n</code></pre>\n<p>Note that I am testing two different versions of the infinite for loop: one which is shorter than the while loop and another one which has an extra space to make it the same length as the while loop.</p>\n<p>On Ubuntu 11.04 x86_64 with perl 5.10.1 I get the following results:</p>\n<pre>\n          Rate   for  for2 while\nfor   100588/s    --   -0%   -2%\nfor2  100937/s    0%    --   -1%\nwhile 102147/s    2%    1%    --\n</pre>\n<p>The while loop is clearly the winner on this platform.</p>\n<p>On FreeBSD 8.2 x86_64 with perl 5.14.1:</p>\n<pre>\n         Rate   for  for2 while\nfor   53453/s    --   -0%   -2%\nfor2  53552/s    0%    --   -2%\nwhile 54564/s    2%    2%    --\n</pre>\n<p>While loop is the winner here too.</p>\n<p>On FreeBSD 8.2 i386 with perl 5.14.1:</p>\n<pre>\n         Rate while   for  for2\nwhile 24311/s    --   -1%   -1%\nfor   24481/s    1%    --   -1%\nfor2  24637/s    1%    1%    --\n</pre>\n<p>Surprisingly the for loop with an extra space is the fastest choice here!</p>\n<p><strong>My conclusion is that the while loop should be used on x86_64 platform if the programmer is optimizing for speed. Obviously a for loop should be used when optimizing for space. My results are unfortunately inconclusive regarding other platforms.</strong></p>\n", "LastActivityDate": "2011-09-03T17:58:19.523", "CommentCount": "5", "CreationDate": "2011-09-03T17:58:19.523", "ParentId": "885908", "Score": "3", "OwnerUserId": "872918"}, "885939": {"Id": "885939", "PostTypeId": "2", "Body": "<p>Using GCC, they both seem to compile to the same assembly language:</p>\n<pre><code>L2:\n        jmp     L2\n</code></pre>\n", "LastActivityDate": "2009-05-20T02:48:44.803", "CommentCount": "2", "CreationDate": "2009-05-20T02:48:44.803", "ParentId": "885908", "Score": "54", "OwnerUserId": "9936"}, "10276274": {"Id": "10276274", "PostTypeId": "2", "Body": "<p>Turbo C with this old compilers <code>for(;;)</code> results in faster code then <code>while(1)</code>.</p>\n<p>Today gcc, Visual C (I think almost all) compilers optimize well, and CPUs with 4.7 MHz are rarely used. </p>\n<p>In those days a <code>for( i=10; i; i-- )</code> was faster than <code>for( i=1; i &lt;=10; i++ )</code>, because compare <code>i</code> is 0, results in a CPU-Zero-Flag conditional Jump. And the Zero-Flag was modified with the last decrement operation <code>( i-- )</code>, no extra cmp-operation is needed.</p>\n<pre><code>    call    __printf_chk\n    decl    %ebx          %ebx=iterator i \n    jnz     .L2\n    movl    -4(%ebp), %ebx\n    leave\n</code></pre>\n<p>and here with <code>for(i=1; i&lt;=10; i++)</code> with extra cmpl:</p>\n<pre><code>    call    __printf_chk\n    incl    %ebx\n    cmpl    $11, %ebx\n    jne     .L2\n    movl    -4(%ebp), %ebx\n    leave\n</code></pre>\n", "LastEditorUserId": "1822514", "LastActivityDate": "2014-07-23T03:12:49.330", "Score": "20", "CreationDate": "2012-04-23T07:13:10.307", "ParentId": "885908", "CommentCount": "1", "OwnerUserId": "1337197", "LastEditDate": "2014-07-23T03:12:49.330"}, "886158": {"Id": "886158", "PostTypeId": "2", "Body": "<p>The Visual C++ compiler used to emit a warning for</p>\n<pre><code>while (1) \n</code></pre>\n<p>(constant expression) but not for </p>\n<pre><code>for (;;)\n</code></pre>\n<p>I've continued the practice of preferring <code>for (;;)</code> for that reason, but I don't know if the compiler still does that these days.</p>\n", "LastEditorUserId": "196561", "LastActivityDate": "2011-09-03T18:05:16.417", "Score": "27", "CreationDate": "2009-05-20T04:41:18.233", "ParentId": "885908", "CommentCount": "4", "OwnerUserId": "103912", "LastEditDate": "2011-09-03T18:05:16.417"}, "892742": {"Id": "892742", "PostTypeId": "2", "Body": "<p><code>while(1)</code> is an idiom for <code>for(;;)</code> which is recognized by most compilers.</p>\n<p>I was glad to see that perl recognizes <code>until(0)</code>, too.</p>\n", "LastEditorUserId": "1822514", "LastActivityDate": "2014-07-23T03:06:54.190", "Score": "2", "CreationDate": "2009-05-21T12:42:56.450", "ParentId": "885908", "CommentCount": "2", "OwnerUserId": "110491", "LastEditDate": "2014-07-23T03:06:54.190"}, "885908": {"ViewCount": "38850", "Body": "<p>Long version...</p>\n<p>A co-worker asserted today after seeing my use of <code>while (1)</code> in a Perl script that <code>for (;;)</code> is faster.  I argued that they should be the same hoping that the interpreter would optimize out any differences. I set up a script that would run 1,000,000,000 for loop iterations and the same number of while loops and record the time between. I could find no appreciable difference. My co-worker said that a professor had told him that the <code>while (1)</code> was doing a comparison <code>1 == 1</code> and the <code>for (;;)</code> was not.  We repeated the same test with the 100x the number of iterations with C++ and the difference was negligible. It was however a graphic example of how much faster compiled code can be vs. a scripting language.</p>\n<p>Short version...</p>\n<p>Is there any reason to prefer a <code>while (1)</code> over a <code>for (;;)</code> if you need an infinite loop to break out of?</p>\n<p><strong>Note:</strong> If it's not clear from the question.  This was purely a fun academic discussion between a couple of friends.  I am aware this is not a super important concept that all programmers should agonize over.  Thanks for all the great answers I (and I'm sure others) have learned a few things from this discussion.</p>\n<p><strong>Update:</strong> The aforementioned co-worker weighed in with a response below.</p>\n<p>Quoted here in case it gets buried.</p>\n<blockquote>\n<p id=\"so_885908_885908_0\">It came from an AMD assembly programmer. He stated that C programmers\n  (the poeple) don't realize that their code has inefficiencies. He said\n  today though, gcc compilers are very good, and put people like him out\n  of business. He said for example, and told me about the <code>while 1</code> vs\n  <code>for(;;)</code>. I use it now out of habit but gcc and especially interpreters\n  will do the same operation (a processor jump) for both these days,\n  since they are optimized.</p>\n</blockquote>\n", "AcceptedAnswerId": "885951", "Title": "while (1) Vs. for (;;) Is there a speed difference?", "CreationDate": "2009-05-20T02:34:08.763", "Id": "885908", "CommentCount": "18", "FavoriteCount": "34", "PostTypeId": "1", "LastEditDate": "2012-10-16T12:00:02.880", "LastEditorUserId": "527702", "LastActivityDate": "2016-06-13T10:06:50.420", "Score": "130", "OwnerUserId": "105170", "Tags": "<c++><perl><optimization><performance>", "AnswerCount": "19"}, "2653628": {"Id": "2653628", "PostTypeId": "2", "Body": "<p>In theory, a <em>completely</em> naive compiler could store the literal '1' in the binary (wasting space) and check to see if 1 == 0 every iteration (wasting time and more space).</p>\n<p>In reality, however, even with \"no\" optimizations, compilers will still reduce both to the same.  They may also emit warnings because it could indicate a logical error.  For instance, the argument of <code>while</code> could be defined somewhere else and you not realize it's constant.</p>\n", "LastActivityDate": "2010-04-16T14:23:31.913", "CommentCount": "0", "CreationDate": "2010-04-16T14:23:31.913", "ParentId": "885908", "Score": "2", "OwnerUserId": "194586"}, "9861242": {"Id": "9861242", "PostTypeId": "2", "Body": "<p>If compiler doesn't do any optimization, <code>for(;;)</code> would always be faster than <code>while(true)</code>. This is because while-statement evaluates the condition everytime, but for-statement is an unconditional jump. But if compiler optimizes the control flow, it may generate some opcodes. You can read disassembly code very easily.</p>\n<p>P.S. you could write a infinite loop like this:</p>\n<pre><code>#define EVER ;;\n  //...\n  for (EVER) {\n    //...\n  }\n</code></pre>\n", "LastEditorUserId": "1822514", "LastActivityDate": "2014-07-23T18:14:12.150", "Score": "8", "CreationDate": "2012-03-25T15:13:46.143", "ParentId": "885908", "CommentCount": "2", "OwnerUserId": "1277994", "LastEditDate": "2014-07-23T18:14:12.150"}, "885934": {"Id": "885934", "PostTypeId": "2", "Body": "<p><code>for(;;)</code> is one less character to type if you want to go in that direction to optimize things.</p>\n", "LastEditorUserId": "196561", "LastActivityDate": "2011-09-03T18:06:55.963", "Score": "22", "CreationDate": "2009-05-20T02:47:23.277", "ParentId": "885908", "CommentCount": "2", "OwnerUserId": "497", "LastEditDate": "2011-09-03T18:06:55.963"}, "37786949": {"Id": "37786949", "PostTypeId": "2", "Body": "<p>To summarize the <code>for (;;)</code> vs <code>while (1)</code> debate it is obvious that the former was faster in the days of older non-optimizing compilers, that is why you tend to see it in older code bases such as Lions Unix Source code commentary, however in the age of badass optimizing compilers those gains are optimized away coupling that with the fact that the latter is easier to understand than the former I believe that it would be more preferable. </p>\n", "LastActivityDate": "2016-06-13T10:06:50.420", "CommentCount": "0", "CreationDate": "2016-06-13T10:06:50.420", "ParentId": "885908", "Score": "2", "OwnerUserId": "3104473"}, "885951": {"Id": "885951", "PostTypeId": "2", "Body": "<p>In perl, they result in the same opcodes:</p>\n<pre><code>$ perl -MO=Concise -e 'for(;;) { print \"foo\\n\" }'\na  &lt;@&gt; leave[1 ref] vKP/REFC -&gt;(end)\n1     &lt;0&gt; enter -&gt;2\n2     &lt;;&gt; nextstate(main 2 -e:1) v -&gt;3\n9     &lt;2&gt; leaveloop vK/2 -&gt;a\n3        &lt;{&gt; enterloop(next-&gt;8 last-&gt;9 redo-&gt;4) v -&gt;4\n-        &lt;@&gt; lineseq vK -&gt;9\n4           &lt;;&gt; nextstate(main 1 -e:1) v -&gt;5\n7           &lt;@&gt; print vK -&gt;8\n5              &lt;0&gt; pushmark s -&gt;6\n6              &lt;$&gt; const[PV \"foo\\n\"] s -&gt;7\n8           &lt;0&gt; unstack v -&gt;4\n-e syntax OK\n\n$ perl -MO=Concise -e 'while(1) { print \"foo\\n\" }'\na  &lt;@&gt; leave[1 ref] vKP/REFC -&gt;(end)\n1     &lt;0&gt; enter -&gt;2\n2     &lt;;&gt; nextstate(main 2 -e:1) v -&gt;3\n9     &lt;2&gt; leaveloop vK/2 -&gt;a\n3        &lt;{&gt; enterloop(next-&gt;8 last-&gt;9 redo-&gt;4) v -&gt;4\n-        &lt;@&gt; lineseq vK -&gt;9\n4           &lt;;&gt; nextstate(main 1 -e:1) v -&gt;5\n7           &lt;@&gt; print vK -&gt;8\n5              &lt;0&gt; pushmark s -&gt;6\n6              &lt;$&gt; const[PV \"foo\\n\"] s -&gt;7\n8           &lt;0&gt; unstack v -&gt;4\n-e syntax OK\n</code></pre>\n<p>Likewise in GCC:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nvoid t_while() {\n    while(1)\n        printf(\"foo\\n\");\n}\n\nvoid t_for() {\n    for(;;)\n        printf(\"foo\\n\");\n}\n\n    .file   \"test.c\"\n    .section    .rodata\n.LC0:\n    .string \"foo\"\n    .text\n.globl t_while\n    .type   t_while, @function\nt_while:\n.LFB2:\n    pushq   %rbp\n.LCFI0:\n    movq    %rsp, %rbp\n.LCFI1:\n.L2:\n    movl    $.LC0, %edi\n    call    puts\n    jmp .L2\n.LFE2:\n    .size   t_while, .-t_while\n.globl t_for\n    .type   t_for, @function\nt_for:\n.LFB3:\n    pushq   %rbp\n.LCFI2:\n    movq    %rsp, %rbp\n.LCFI3:\n.L5:\n    movl    $.LC0, %edi\n    call    puts\n    jmp .L5\n.LFE3:\n    .size   t_for, .-t_for\n    .section    .eh_frame,\"a\",@progbits\n.Lframe1:\n    .long   .LECIE1-.LSCIE1\n.LSCIE1:\n    .long   0x0\n    .byte   0x1\n    .string \"zR\"\n    .uleb128 0x1\n    .sleb128 -8\n    .byte   0x10\n    .uleb128 0x1\n    .byte   0x3\n    .byte   0xc\n    .uleb128 0x7\n    .uleb128 0x8\n    .byte   0x90\n    .uleb128 0x1\n    .align 8\n.LECIE1:\n.LSFDE1:\n    .long   .LEFDE1-.LASFDE1\n.LASFDE1:\n    .long   .LASFDE1-.Lframe1\n    .long   .LFB2\n    .long   .LFE2-.LFB2\n    .uleb128 0x0\n    .byte   0x4\n    .long   .LCFI0-.LFB2\n    .byte   0xe\n    .uleb128 0x10\n    .byte   0x86\n    .uleb128 0x2\n    .byte   0x4\n    .long   .LCFI1-.LCFI0\n    .byte   0xd\n    .uleb128 0x6\n    .align 8\n.LEFDE1:\n.LSFDE3:\n    .long   .LEFDE3-.LASFDE3\n.LASFDE3:\n    .long   .LASFDE3-.Lframe1\n    .long   .LFB3\n    .long   .LFE3-.LFB3\n    .uleb128 0x0\n    .byte   0x4\n    .long   .LCFI2-.LFB3\n    .byte   0xe\n    .uleb128 0x10\n    .byte   0x86\n    .uleb128 0x2\n    .byte   0x4\n    .long   .LCFI3-.LCFI2\n    .byte   0xd\n    .uleb128 0x6\n    .align 8\n.LEFDE3:\n    .ident  \"GCC: (Ubuntu 4.3.3-5ubuntu4) 4.3.3\"\n    .section    .note.GNU-stack,\"\",@progbits\n</code></pre>\n<p>So I guess the answer is, they're the same in many compilers. Of course, for some other compilers this may not necessarily be the case, but chances are the code inside of the loop is going to be a few thousand times more expensive than the loop itself anyway, so who cares?</p>\n", "LastActivityDate": "2009-05-20T02:54:33.060", "CommentCount": "7", "CreationDate": "2009-05-20T02:54:33.060", "ParentId": "885908", "Score": "205", "OwnerUserId": "36723"}, "887298": {"Id": "887298", "PostTypeId": "2", "Body": "<p>There is no difference according to the standard.  6.5.3/1 has:</p>\n<blockquote>\n<p id=\"so_885908_887298_0\">The for statement</p>\n</blockquote>\n<pre><code>for ( for-init-statement ; conditionopt ; expressionopt ) statement\n</code></pre>\n<blockquote>\n<p id=\"so_885908_887298_1\">is equivalent to</p>\n</blockquote>\n<pre><code>{\n  for-init-statement\n  while ( condition ) {\n    statement\n    expression ;\n  }\n}\n</code></pre>\n<p>And 6.5.3/2 has:</p>\n<blockquote>\n<p id=\"so_885908_887298_2\">Either or both of the condition and the expression can be omitted. A missing condition makes the implied while clause equivalent to while(true).</p>\n</blockquote>\n<p>So according to the C++ standard the code:</p>\n<pre><code>for (;;);\n</code></pre>\n<p>is exactly the same as:</p>\n<pre><code>{\n  while (true) {\n    ;\n    ;\n  }\n}\n</code></pre>\n", "LastEditorUserId": "27074", "LastActivityDate": "2015-02-17T19:53:15.687", "Score": "31", "CreationDate": "2009-05-20T10:58:58.320", "ParentId": "885908", "CommentCount": "2", "OwnerUserId": "11698", "LastEditDate": "2015-02-17T19:53:15.687"}});