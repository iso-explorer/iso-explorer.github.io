post_cb({"3820646": {"Id": "3820646", "PostTypeId": "2", "Body": "<p>What you've got there is a horrible hack around encapsulation. If you <em>really</em> want to access private variables then you should be using the \"friend\" keyword. The reason the reinterpret_cast works is because you're interpretting the bytes of class Student as the struct _Student - which has it's variables declared as public by default. There are all manner of bad ways to access the private data, here's another one I can think of:</p>\n<pre><code>int* bs3 = reinterpret_cast&lt;int*&gt;(bs2);\n++bs3;\n*bs3 = 5;\n</code></pre>\n<p>Just don't do it would be my advice.</p>\n", "LastActivityDate": "2010-09-29T10:14:49.953", "CommentCount": "0", "CreationDate": "2010-09-29T10:14:49.953", "ParentId": "3820363", "Score": "1", "OwnerUserId": "986"}, "3820388": {"Id": "3820388", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_3820363_3820388_0\">$5.2.10/2 - \"An expression of\n  integral, enumeration, pointer, or\n  pointer-to-member type can be\n  explicitly converted to its own type;\n  <strong>such a cast yields the value of its operand.</strong>\"</p>\n</blockquote>\n<p>This means that pointers 'bs2' and 'bs3' are pointing to the same location</p>\n<blockquote>\n<p id=\"so_3820363_3820388_1\">$9.2/16 - \"Two standard-layout struct\n  (Clause 9) types are layout-compatible\n  if they have the same number of\n  non-static data members and\n  corresponding non-static data members\n  (in declaration order) have\n  layout-compatible types (3.9).\"</p>\n</blockquote>\n<p><strike>This means that your class and struct are layout compatible.</strike></p>\n<p>$9/6- </p>\n<blockquote>\n<p id=\"so_3820363_3820388_2\">A standard-layout class is a class\n  that: </p>\n<p id=\"so_3820363_3820388_3\">\u2014 has no non-static data members\n  of type non-standard-layout class (or\n  array of such types) or reference, </p>\n<p id=\"so_3820363_3820388_4\">\u2014 has no virtual functions (10.3) and no\n  virtual base classes (10.1), </p>\n<p id=\"so_3820363_3820388_5\">\u2014 has the same access control (Clause 11) for\n  all non-static data members, </p>\n<p id=\"so_3820363_3820388_6\">\u2014 has no non-standard-layout base classes, </p>\n<p id=\"so_3820363_3820388_7\">\u2014 either has no non-static data members\n  in the most-derived class and at most\n  one base class with non-static data\n  members, or has no base classes with\n  non-static data members, and </p>\n<p id=\"so_3820363_3820388_8\">\u2014 has no base classes of the same type as the\n  first non-static data member.108</p>\n</blockquote>\n<p>Since your class has a virtual destructor, your class and struct are not standard layout classes.</p>\n<p>However you have added a 'void *' data member to possibly take care of the 'vptr' (thereby possibly mimicking layout compatibility based on your particular compiler implementation)</p>\n<p>In this case reinterpret_cast is used to interpret the class pointer (bs2) as a struct pointer (bs3). By default struct members are public. Since the return value of reinterpret cast points to the same memory (refer quote above) where class members are located, you can modify the struct members (which are the same as the original class members).</p>\n<p>This is cheating. This is highly discouraged.! This is most likely going to lead to undefined behavior</p>\n", "LastEditorUserId": "418110", "LastActivityDate": "2010-09-29T10:14:12.517", "Score": "3", "CreationDate": "2010-09-29T09:40:49.410", "ParentId": "3820363", "CommentCount": "3", "OwnerUserId": "418110", "LastEditDate": "2010-09-29T10:14:12.517"}, "3820363": {"ViewCount": "430", "Body": "<p>I was just going through some codes of C++.\nWhere in I came across the concept of <code>reinterpret_cast</code> operator.</p>\n<p><strong>EDIT 1 :</strong> </p>\n<p><em><strong>I know that accessing private members of a class is not recommended.</strong></em></p>\nBut in some situations we ought to go ahead and access them.\n<strong>I have just put forth this question to get my concepts clear.</strong>\n<p>In the example that I referred,the private member of the Class is accessed by simply creating a structure with the same variables and then later on modified by implementing\n<code>reinterpret_cast</code> operator.</p>\n<p>I have understood the usage of <code>reinterpret_cast</code> operator,as in I know <strong>what</strong> it does,but I fail to understand <strong>how</strong> a structure could be used to modify the values of a <strong>private Class member</strong>.</p>\n<p>Following is the source code which I referred:</p>\n<p><strong>Class:</strong></p>\n<pre><code>class Student\n{\npublic:\n    explicit Student(float percent) // Cannot be used for conversion\n    {\n        static int nid;\n\n        id = ++nid;\n        score = percent;\n    }\n\n    int Id() const\n    {\n        return id;\n    }\n\n    float GetScore() const\n    {\n        return score;\n    }\n\n    void SetScore(float value)\n    {\n        score = value;\n    }\n\n    virtual ~Student(){}\n\nprivate:\n    int id;\n    float score;\n};\n</code></pre>\n<p><strong>Structure used to access and modify private class members:</strong></p>\n<pre><code>struct _Student\n    {\n        void* vptr;\n        int id;\n        float score;\n    };\n\n    _Student* bs3 = reinterpret_cast&lt;_Student*&gt;(bs2);\n    bs3-&gt;id = 5;\n</code></pre>\n<p>Thank you.Please correct me if I'm wrong/I couldn't put forth my question in an appropriate manner.</p>\n", "AcceptedAnswerId": "3820388", "Title": "Class Private members modified on creating a structure (C++)", "CreationDate": "2010-09-29T09:37:52.613", "Id": "3820363", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2010-09-29T09:52:18.883", "LastEditorUserId": "425094", "LastActivityDate": "2010-09-29T10:37:49.070", "Score": "3", "OwnerUserId": "425094", "Tags": "<c++><oop><class><reinterpret-cast>", "AnswerCount": "5"}, "3820455": {"Id": "3820455", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_3820363_3820455_0\">But in some situations we ought to go ahead and access them.</p>\n</blockquote>\n<p>If you have to access them in <em>any situation</em>, change its access specification.</p>\n<p>Or better, make a public method that would accept a token(or some special permissions - to validate the caller), and return the requested value.</p>\n", "LastActivityDate": "2010-09-29T09:49:49.173", "CommentCount": "0", "CreationDate": "2010-09-29T09:49:49.173", "ParentId": "3820363", "Score": "1", "OwnerUserId": "82449"}, "bq_ids": {"n4140": {"so_3820363_3820388_4": {"length": 5, "quality": 0.7142857142857143, "section_id": 369}, "so_3820363_3820388_3": {"length": 10, "quality": 1.0, "section_id": 5851}, "so_3820363_3820388_7": {"length": 17, "quality": 0.9444444444444444, "section_id": 5851}, "so_3820363_3820388_8": {"length": 7, "quality": 0.875, "section_id": 5851}, "so_3820363_3820388_5": {"length": 8, "quality": 1.0, "section_id": 5851}, "so_3820363_3820388_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 6041}, "so_3820363_3820388_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 5876}}, "n3337": {"so_3820363_3820388_3": {"length": 10, "quality": 1.0, "section_id": 5621}, "so_3820363_3820388_4": {"length": 5, "quality": 0.7142857142857143, "section_id": 359}, "so_3820363_3820388_7": {"length": 17, "quality": 0.9444444444444444, "section_id": 5621}, "so_3820363_3820388_8": {"length": 7, "quality": 0.875, "section_id": 5621}, "so_3820363_3820388_5": {"length": 8, "quality": 1.0, "section_id": 5621}, "so_3820363_3820388_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 5809}, "so_3820363_3820388_1": {"length": 22, "quality": 0.9565217391304348, "section_id": 5647}}, "n4659": {"so_3820363_3820388_3": {"length": 10, "quality": 1.0, "section_id": 7330}, "so_3820363_3820388_4": {"length": 5, "quality": 0.7142857142857143, "section_id": 383}, "so_3820363_3820388_7": {"length": 15, "quality": 0.8333333333333334, "section_id": 7330}, "so_3820363_3820388_8": {"length": 7, "quality": 0.875, "section_id": 7330}, "so_3820363_3820388_5": {"length": 8, "quality": 1.0, "section_id": 7330}, "so_3820363_3820388_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 7540}, "so_3820363_3820388_1": {"length": 18, "quality": 0.782608695652174, "section_id": 7361}}}, "3820796": {"Id": "3820796", "PostTypeId": "2", "Body": "<p>I think you should perhaps change the context of your question somewhat. \nIf you realize you need to access a private variable in your class then\nyou are facing a design problem that needs to be resolved instead of\nhacked around using an unsafe type conversion. Even if it is just\nhypothetical and for the sake of asking about reinterpret_cast here.</p>\n<p>As for a use case of reinterpret_cast that makes sense I'd say inside a hash function:</p>\n<p><code>\nunsigned short Hash( void *p )\n{</code></p>\n<pre><code>unsigned int val = reinterpret_cast&lt;unsigned int&gt;( p );\nreturn ( unsigned short )( val ^ (val &gt;&gt; 16));\n</code></pre>\n<p>}\n</p>\n<p>Some links with useful info:</p>\n<p><a href=\"https://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-and-reinterpret-cast-be-used\">When should static_cast, dynamic_cast, const_cast and reinterpret_cast be used?</a></p>\n<p><a href=\"http://advancedcppwithexamples.blogspot.com/2010/02/reinterpretcast-in-c.html\" rel=\"nofollow noreferrer\">http://advancedcppwithexamples.blogspot.com/2010/02/reinterpretcast-in-c.html</a></p>\n<p><a href=\"http://www.linuxtopia.org/online_books/programming_books/thinking_in_c++/Chapter03_054.html\" rel=\"nofollow noreferrer\">http://www.linuxtopia.org/online_books/programming_books/thinking_in_c++/Chapter03_054.html</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-09-29T10:37:49.070", "Score": "2", "CreationDate": "2010-09-29T10:37:49.070", "ParentId": "3820363", "CommentCount": "0", "OwnerUserId": "457853", "LastEditDate": "2017-05-23T10:31:02.393"}, "3820530": {"Id": "3820530", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_3820363_3820530_0\">But in some situations we ought to go ahead and access them.</p>\n</blockquote>\n<p>And what, pray, are these situations?</p>\n<p>Other than design errors, I can\u2019t see any. Accessing private members is a no-go. If you need the access, then provide it by legal means, i.e. either make the members more accessible or use <code>friend</code> modifiers to access them in a controlled way.</p>\n<p>Violating the C++ type checking system equals game over: you cheat the compiler, don\u2019t expect it to work with you. With this kind of undefined behaviour (i.e. not just platform dependent but forbidden for good reasons) you\u2019re just inviting trouble in the form of <em>very</em> hard to track bugs.</p>\n<p><strong>tl;dr</strong>: Don\u2019t. Ever.</p>\n<p><strong>Caveat</strong>: There is one exception: you have a library that you cannot access/modify the source code of, and you have no way of influencing its interface design. And <em>additionally</em> you can be sure (how?) that it won\u2019t ever change. In this case the only solution may be to hack the library with such tricks.</p>\n", "LastActivityDate": "2010-09-29T10:00:55.727", "CommentCount": "0", "CreationDate": "2010-09-29T10:00:55.727", "ParentId": "3820363", "Score": "3", "OwnerUserId": "1968"}});