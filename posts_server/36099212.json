post_cb({"bq_ids": {"n4140": {"so_36099212_36099281_2": {"length": 23, "quality": 1.0, "section_id": 5811}, "so_36099212_36099281_1": {"length": 29, "quality": 0.8285714285714286, "section_id": 5809}, "so_36099212_36099281_4": {"length": 15, "quality": 1.0, "section_id": 6173}, "so_36099212_36099281_3": {"length": 18, "quality": 0.6923076923076923, "section_id": 5768}}, "n3337": {"so_36099212_36099281_2": {"length": 23, "quality": 1.0, "section_id": 5584}, "so_36099212_36099281_3": {"length": 18, "quality": 0.6923076923076923, "section_id": 5541}, "so_36099212_36099281_4": {"length": 15, "quality": 1.0, "section_id": 5934}, "so_36099212_36099281_1": {"length": 29, "quality": 0.8285714285714286, "section_id": 5582}}, "n4659": {"so_36099212_36099281_3": {"length": 18, "quality": 0.6923076923076923, "section_id": 7225}, "so_36099212_36099281_4": {"length": 15, "quality": 1.0, "section_id": 7675}, "so_36099212_36099281_1": {"length": 29, "quality": 0.8285714285714286, "section_id": 7270}}}, "36099212": {"ViewCount": "374", "Body": "<p>I am confused about the output of the code.\nIt depends on what compiler i run the code. Why is it so?</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint f(int &amp;n)\n{   \n    n--;\n    return n;\n}\nint main()\n{\n      int n=10;\n      n=n-f(n);\n      cout&lt;&lt;n;\n      return 0;\n}\n</code></pre>\n<p>Running it on the Ubuntu terminal with g++, the output is 1 whereas running it on Turbo C++ ( the compiler we used in school) gives output as 0.</p>\n", "AcceptedAnswerId": "36099281", "Title": "How can we predict the output of the following C++ Program", "CreationDate": "2016-03-19T07:42:41.340", "LastActivityDate": "2016-03-19T18:15:57.620", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "Tags": "<c++><c++11><gcc><g++>", "Id": "36099212", "Score": "3", "OwnerUserId": "6085747", "ClosedDate": "2016-03-19T08:04:33.493", "AnswerCount": "1"}, "36099281": {"Id": "36099281", "PostTypeId": "2", "Body": "<p>In C++03, modifying a variable and also using its value in the same expression, without an intervening C++03 <em>sequence point</em>, was <strong>Undefined Behavior</strong>.</p>\n\nC++03 \u00a75/4:\n\n<blockquote>\n<p id=\"so_36099212_36099281_0\"><strong>\u201d</strong> Between the previous\n  and next sequence point a scalar object shall have its stored value modified at most once by the evaluation\n  of an expression. Furthermore, the prior value shall be accessed only to determine the value to be stored.\n  The requirements of this paragraph shall be met for each allowable ordering of the subexpressions of a full\n  expression; otherwise the behavior is undefined.</p>\n</blockquote>\n<p>Undefined Behavior, UB, provides the compiler with an opportunity to optimize, because it can assume that UB does not occur in a valid program.</p>\n<p>However, with all the myriad UB rules of C++ it's difficult to reason about source code.</p>\n<hr>\n<p>In C++11 sequence points were replaced with <em>sequenced before</em>, <em>indeterminately sequenced</em> and <em>unsequenced</em> relations:</p>\n\nC++11 \u00a71.9/3\n\n<blockquote>\n<p id=\"so_36099212_36099281_1\"><strong>\u201d</strong> Given any two evaluations <em>A</em> and <em>B</em>, if\n  <em>A</em> is sequenced before <em>B</em>, then the execution of A shall precede the execution of <em>B</em>. If <em>A</em> is not sequenced before\n  <em>B</em> and <em>B</em> is not sequenced before <em>A</em>, then <em>A</em> and <em>B</em> are <em>unsequenced</em>. [<em>Note:</em> The execution of unsequenced\n  evaluations can overlap. <em>\u2014end note</em> ] Evaluations <em>A</em> and <em>B</em> are <em>indeterminately sequenced</em> when either <em>A</em>\n  is sequenced before <em>B</em> or <em>B</em> is sequenced before <em>A</em>, but it is unspecified which.</p>\n</blockquote>\n<p>And with the new C++11 sequence relationship rules the modification in the function in the code in question is indeterminately sequenced with respect to the use of the variable, and so the code has <strong>unspecified behavior</strong> rather than Undefined Behavior, as noted by Eric M Schmidt in <a href=\"https://stackoverflow.com/questions/36099212/how-can-we-predict-the-output-of-the-following-c-program/36099281?noredirect=1#comment59843153_36099281\">a comment to (the first version of) this answer</a>. Essentially that means that there is no danger of nasal daemons or other possible UB effects, and that the behavior is a reasonable one. The two possible behaviors here are that the modification via the function call is done before the use of the value, or that it's done after the use of the value.</p>\n<p>Why it's unspecified behavior:</p>\n\nC++11 \u00a71.9/15:\n\n<blockquote>\n<p id=\"so_36099212_36099281_2\"><strong>\u201d</strong> Every evaluation in the calling function (including other function calls) that is not otherwise specifically\n  sequenced before or after the execution of the body of the called function is indeterminately sequenced with\n  respect to the execution of the called function.</p>\n</blockquote>\n<p>What \u201cunspecified behavior\u201d means:</p>\n\nC++11 \u00a71.3.25:\n\n<blockquote>\n<p id=\"so_36099212_36099281_3\"><strong>\u201d</strong> unspecified behavior<br>\n  Behavior, for a well-formed program construct and correct data, that depends on the implementation\n  [<em>Note:</em> The implementation is not required to document which behavior occurs. The range of possible\n  behaviors is usually delineated by this International Standard. <em>\u2014end note</em> ]</br></p>\n</blockquote>\n<p>Why the modification effected by the assignment is not problematic:</p>\n\nC++11 \u00a75.17/1\n\n<blockquote>\n<p id=\"so_36099212_36099281_4\"><strong>\u201d</strong>  In all cases, the assignment is sequenced after the value\n  computation of the right and left operands, and before the value computation of the assignment expression.</p>\n</blockquote>\n<p>This is also quite different from C++03.</p>\n<hr>\n<p>As the rather drastic edit of this answer shows, following Eric's comment, this kind of issue is not simple! The main advice I can give is to as much as possible just Say No\u2122 to effects governed by subtle or very complex rules, the corners of the language. Simple code has a better chance of being correct, while so called clever code does not have a good chance of being significantly faster.</p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2016-03-19T18:15:57.620", "Score": "4", "CreationDate": "2016-03-19T07:50:02.263", "ParentId": "36099212", "CommentCount": "9", "LastEditDate": "2017-05-23T12:00:49.047", "OwnerUserId": "464581"}});