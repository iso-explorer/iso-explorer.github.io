post_cb({"11420448": {"CommentCount": "8", "AcceptedAnswerId": "11445905", "PostTypeId": "1", "LastEditorUserId": "1170277", "CreationDate": "2012-07-10T19:25:42.503", "LastActivityDate": "2015-02-13T23:56:57.240", "LastEditDate": "2012-07-10T19:46:21.573", "ViewCount": "3042", "FavoriteCount": "11", "Title": "Initializer lists and RHS of operators", "Id": "11420448", "Score": "34", "Body": "<p>I do not understand why initializer lists cannot be used on the RHS of an operator. Consider:</p>\n<pre><code>class foo { };\n\nstruct bar\n{\n    template&lt;typename... T&gt;\n    bar(T const&amp;...) { }\n};\n\nfoo&amp; operator&lt;&lt;(foo&amp; f, bar const&amp;) { return f; }\n\nint main()\n{\n    foo baz;\n    baz &lt;&lt; {1, -2, \"foo\", 4, 5};\n\n    return 0;\n}\n</code></pre>\n<p>The latest Clang (gcc as well) complains:</p>\n<pre><code>clang.cc:14:9: error: initializer list cannot be used on the right hand side of operator '&lt;&lt;'\n    baz &lt;&lt; {1, -2, \"foo\", 4, 5};\n    ^  ~~~~~~~~~~~~~~~~~~~~\n\n    ^  ~~~~~~~~~~~~~~~\n</code></pre>\n<p>Why would the C++ standard forbid this? Or put differently, why does this fail as opposed to</p>\n<pre><code>baz &lt;&lt; bar{1, -2, \"foo\", 4, 5};\n</code></pre>\n<p>?</p>\n", "Tags": "<c++><c++11><operators><initializer-list>", "OwnerUserId": "1170277", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_11420448_11445905_0": {"section_id": 3323, "quality": 0.7272727272727273, "length": 24}}, "n3337": {"so_11420448_11445905_0": {"section_id": 3193, "quality": 0.7272727272727273, "length": 24}}, "n4659": {"so_11420448_11445905_0": {"section_id": 4089, "quality": 0.6666666666666666, "length": 22}}}, "11445905": {"ParentId": "11420448", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2012-07-12T06:10:06.090", "Score": "45", "LastEditorUserId": "777186", "LastEditDate": "2015-02-13T23:56:57.240", "Id": "11445905", "OwnerUserId": "777186", "Body": "<p>Indeed the final version of C++11 does not enable the use of initializer lists on the right-hand side (or left-hand side, for that matter) of a binary operator.</p>\n<p>Firstly, <strong>initializer-lists are not expressions</strong> as defined in \u00a75 of the Standard. The arguments of functions, as well as of binary operators, generally have to be expressions, and the grammar for expressions defined in \u00a75 does not include the syntax for brace-init-lists (i.e. pure initializer-lists; note that a typename <em>followed by</em> a brace-init-list, such as <code>bar {2,5,\"hello\",7}</code> is an expression, though).</p>\n<p>In order to be able to use pure initializer-lists conveniently, the standard defines various exceptions, which are summarized in the following (non-normative) note:</p>\n<blockquote>\n<p id=\"so_11420448_11445905_0\"><em>\u00a78.5.4/1</em>\n  [...] Note: List-initialization can be used<br/>\n      \u2014 as the initializer in a variable definition (8.5)<br/>\n  \u2014 as the initializer in a new expression (5.3.4)<br/>\n  \u2014 in a return statement (6.6.3)<br/>\n  \u2014 as a function argument (5.2.2)<br/>\n  \u2014 as a subscript (5.2.1)<br/>\n  \u2014 as an argument to a constructor invocation (8.5, 5.2.3)<br/>\n  \u2014 as an initializer for a non-static data member (9.2)<br/>\n  \u2014 in a mem-initializer (12.6.2)<br/>\n  \u2014 on the right-hand side of an assignment (5.17)<br/>\n  [...]</p>\n</blockquote>\n<p>The fourth item above explicitly allows pure initializer-lists as function arguments (which is why <code>operator&lt;&lt;(baz, {1, -2, \"foo\", 4, 5});</code> works), the fifth one allows it in subscript expressions (i.e. as argument of <code>operator[]</code>, e.g. <code>mymap[{2,5,\"hello\"}]</code> is legal), and the last item allows them on the right-hand side of <em>assignments</em> (but not general binary operators).</p>\n<p>There is <strong>no such exception for binary operators</strong> like <code>+</code>, <code>*</code> or <code>&lt;&lt;</code>, hence you can't put a pure initializer list (i.e. one that is not preceded with a typename) on either side of them.</p>\n<p>As to the <strong>reasons for this</strong>, a <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2007/n2215.pdf\" rel=\"noreferrer\">draft/discussion paper N2215</a> by Stroustrup and Dos Reis from 2007 provides a lot of insight into many of the issues with initializer-lists in various contexts. Specifically, there is a section on binary operators (section 6.2):</p>\n<blockquote>\n<p id=\"so_11420448_11445905_1\">Consider more general uses of initializer lists. For example:</p>\n<pre><code>v = v+{3,4};\nv = {6,7}+v;\n</code></pre>\n<p id=\"so_11420448_11445905_2\">When we consider operators as syntactic sugar for functions, we naturally consider the above equivalent to</p>\n<pre><code>v = operator+(v,{3,4});\nv = operator+({6,7},v);\n</code></pre>\n<p id=\"so_11420448_11445905_3\">It is therefore natural to extend the use of initializer lists to expressions. There are many uses where initializer lists combined with operators is a \u201cnatural\u201d notation.<br>\n  However, it is not trivial to write a LR(1) grammar that allows arbitrary use of initializer lists. A block also starts with a { so allowing an initializer list as the first (leftmost) entity of an expression would lead to chaos in the grammar.<br>\n  It is trivial to allow initializer lists as the right-hand operand of binary operators, in\n  subscripts, and similar isolated parts of the grammar. The real problem is to allow <code>;a={1,2}+b;</code> as an assignment-statement without also allowing <code>;{1,2}+b;</code>. We suspect that allowing initializer lists as right-hand, but nor [sic] as left-hand arguments to most operators is too much of a kludge, [...]</br></br></p>\n</blockquote>\n<p><strong>In other words, initializer-lists are not enabled on the right-hand side <em>because they are not enabled on the left-hand side</em>, and they are not enabled on the left-hand side because that would have posed too big a challenge for parsers.</strong></p>\n<p>I wonder if the problem could have been simplified by picking a different symbol instead of curly braces for the initializer-list syntax.</p>\n", "LastActivityDate": "2015-02-13T23:56:57.240"}});