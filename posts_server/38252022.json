post_cb({"bq_ids": {"n4140": {"so_38252022_38253266_0": {"length": 12, "quality": 0.8, "section_id": 2666}, "so_38252022_38253266_1": {"length": 5, "quality": 1.0, "section_id": 4853}, "so_38252022_38253266_2": {"length": 10, "quality": 1.0, "section_id": 4848}}, "n3337": {"so_38252022_38253266_0": {"length": 12, "quality": 0.8, "section_id": 2630}, "so_38252022_38253266_1": {"length": 5, "quality": 1.0, "section_id": 4648}, "so_38252022_38253266_2": {"length": 10, "quality": 1.0, "section_id": 4643}}, "n4659": {"so_38252022_38253266_0": {"length": 12, "quality": 0.8, "section_id": 3406}, "so_38252022_38253266_1": {"length": 5, "quality": 1.0, "section_id": 6278}, "so_38252022_38253266_2": {"length": 10, "quality": 1.0, "section_id": 6273}}}, "38252022": {"ViewCount": "1403", "Body": "<p>As known <code>clock()</code> may show less than or greater than the value of the real time - both cases are shown in the following examples 1 and 2. </p>\n<p>For high-precision measurements of the time in C++11 we can use:</p>\n<ul>\n<li><code>std::chrono::high_resolution_clock::now();</code> - guarantee high-precision</li>\n<li><code>std::chrono::steady_clock::now();</code> - guarantee that measure real time</li>\n<li><code>clock();</code> - guarantee high-precision, but measure CPU-cycles instead of time</li>\n<li><code>time(&amp;t_start);</code> - isn't high-precision, but measure real time</li>\n</ul>\n<p><strong>1-</strong> For example: <a href=\"http://ideone.com/SudWTM\">http://ideone.com/SudWTM</a></p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n#include &lt;thread&gt;\n#include &lt;iostream&gt;\n#include &lt;chrono&gt;\n\nint main(void) {\n\n    std::cout &lt;&lt; \"sleep(3) took: \\n\\n\";\n\n    clock_t c_start, c_end;\n    time_t t_start, t_end;\n    std::chrono::high_resolution_clock::time_point h_start, h_end;\n    std::chrono::steady_clock::time_point steady_start, steady_end;\n\n    time(&amp;t_start);  // less precise than clock() but always get the real actual time\n    c_start = clock(); // clock() get only CPU-time, it can be more than real or less - sleep(3); took 0.00 seconds \n    h_start = std::chrono::high_resolution_clock::now();\n    steady_start = std::chrono::steady_clock::now(); \n\n    std::this_thread::sleep_for(std::chrono::seconds(3));\n\n    steady_end = std::chrono::steady_clock::now();\n    h_end = std::chrono::high_resolution_clock::now();\n    c_end = clock();\n    time(&amp;t_end);\n\n    std::cout &lt;&lt; \"highres = \" &lt;&lt; std::chrono::duration&lt;double&gt;(h_end - h_start).count() &lt;&lt; \" s \\n\";\n    std::cout &lt;&lt; \"steady = \" &lt;&lt; std::chrono::duration&lt;double&gt;(steady_end - steady_start).count() &lt;&lt; \" s \\n\";\n\n    printf(\"clock() = %.2lf seconds \\n\", (c_end - c_start) / (double)CLOCKS_PER_SEC);\n    printf(\"time() = %.2lf seconds \\n\", difftime(t_end, t_start));\n\n    return 0;\n}\n</code></pre>\n<p>Result on g++ (Debian 4.9.2-10) 4.9.2: <strong>clock() = 0.00 seconds</strong></p>\n<pre><code>sleep(3) took: \n\nhighres = 3.00098 s \nsteady = 3.00098 s \nclock() = 0.00 seconds \ntime() = 3.00 seconds \n</code></pre>\n<p>Result on C++ MSVS 2013 v120 (Windows 7x64):</p>\n<pre><code>sleep(3) took:\n\nhighres = 3.00017 s\nsteady = 3.00017 s\nclock() = 3.00 seconds\ntime() = 3.00 seconds\n</code></pre>\n<p><strong>2-</strong> Second example OpenMP or <code>&lt;thread&gt;</code>: <a href=\"http://coliru.stacked-crooked.com/a/2922c85385d197e1\">http://coliru.stacked-crooked.com/a/2922c85385d197e1</a></p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n#include &lt;thread&gt;\n#include &lt;iostream&gt;\n#include &lt;chrono&gt;\n#include &lt;vector&gt;\n\nint main(void) {\n\n    std::cout &lt;&lt; \"for-loop took: \\n\\n\";\n\n    clock_t c_start, c_end;\n    time_t t_start, t_end;\n    std::chrono::high_resolution_clock::time_point h_start, h_end;\n    std::chrono::steady_clock::time_point steady_start, steady_end;\n\n    time(&amp;t_start);  // less precise than clock() but always get the real actual time\n    c_start = clock(); // clock() get only CPU-time, it can be more than real or less - sleep(3); took 0.00 seconds \n    h_start = std::chrono::high_resolution_clock::now();\n    steady_start = std::chrono::steady_clock::now();\n\n    #pragma omp parallel num_threads(10)\n    {\n        for (volatile int i = 0; i &lt; 200000000; ++i);\n    }\n\n    steady_end = std::chrono::steady_clock::now();\n    h_end = std::chrono::high_resolution_clock::now();\n    c_end = clock();\n    time(&amp;t_end);\n\n    std::cout &lt;&lt; \"highres = \" &lt;&lt; std::chrono::duration&lt;double&gt;(h_end - h_start).count() &lt;&lt; \" s \\n\";\n    std::cout &lt;&lt; \"steady = \" &lt;&lt; std::chrono::duration&lt;double&gt;(steady_end - steady_start).count() &lt;&lt; \" s \\n\";\n\n    printf(\"clock() = %.2lf seconds \\n\", (c_end - c_start) / (double)CLOCKS_PER_SEC);\n    printf(\"time() = %.2lf seconds \\n\", difftime(t_end, t_start));\n\n    int b = getchar();\n\n    return 0;\n}\n</code></pre>\n<p>Result on g++ (Debian 4.9.2-10) 4.9.2: <strong>clock() = 1.35 seconds</strong></p>\n<pre><code>for-loop took: \n\nhighres = 0.213906 s \nsteady = 0.213905 s \nclock() = 1.35 seconds \ntime() = 0.00 seconds \n</code></pre>\n<p>Result on C++ MSVS 2013 v120 (Windows 7x64):</p>\n<pre><code>for-loop took:\n\nhighres = 1.49109 s\nsteady = 1.49109 s\nclock() = 1.49 seconds\ntime() = 2.00 seconds\n</code></pre>\n<p>Resume:</p>\n<ol>\n<li><p>When thread sleeps then <code>clock()</code> on g++ 4.9.2 doesn't measure time unlike other functions.</p></li>\n<li><p>When we use multithreading by using OpenMP or by using <code>&lt;thread&gt;</code> (<a href=\"http://coliru.stacked-crooked.com/a/2922c85385d197e1\">link</a>), then <code>clock()</code> on g++ 4.9.2 measures CPU-cycles of all threads.</p></li>\n</ol>\n<p>Also on Windows MSVS 2013 <code>clock()</code> measures required real time in both cases, but this doesn't guarantee that <code>clock()</code> measures the same on other platforms (on linux g++ is 0 for the sleep and x-fold for the multithreading).</p>\n<p>Based on this, if <code>std::chrono::high_resolution_clock::now();</code> measures required real time in both cases on both Windows MSVS 2013 and g++ 4.9.2, does this guarantee that it will measure real high resolution time on all other platforms and does whether it guarantee standard C++11/14?</p>\n", "AcceptedAnswerId": "38253266", "Title": "Does standard C++11 guarantee that high_resolution_clock measure real time (non CPU-cycles)?", "CreationDate": "2016-07-07T17:45:32.880", "Id": "38252022", "CommentCount": "1", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2016-07-09T12:12:05.043", "LastEditorUserId": "1558037", "LastActivityDate": "2016-08-01T21:42:00.690", "Score": "13", "OwnerUserId": "1558037", "Tags": "<c++><multithreading><performance><c++11><performance-testing>", "AnswerCount": "2"}, "38253266": {"Id": "38253266", "PostTypeId": "2", "Body": "<h3>Short answer: as of the C++14 standard, <code>high_resolution_clock</code> does NOT explicitly provide the guarantee you're looking for.</h3>\n<p>For now, <code>steady_clock</code> and <code>system_clock</code> provide better and more explicit guarantees. However, most implementations <em>probably will</em> ensure that HRC advances while its thread is sleeping. It may nevertheless be preferable to do your own type-aliasing. See 'EDIT' sections below and discussion in comments.</p>\n<h3>Long answer:</h3>\n<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf\" rel=\"nofollow\">draft standard</a> does in fact implicitly acknowledge (in note 30.2.4 \"Timing Specifications\", note 5) that Clock objects are <strong>not</strong> required to advance while their associated thread is sleeping. For context, this section is explaining how the standard-library timer objects work; the behavior of a timer is based on the behavior of the clock used to set it.</p>\n<blockquote>\n<p id=\"so_38252022_38253266_0\">[ <em>Note:</em> If the clock is not synchronized with a steady clock, e.g., a\n  CPU time clock, these timeouts might not provide useful functionality.\n  \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>Note that in this case, \"timeouts might not provide useful functionality\" means that if you use a timer to <code>sleep_until</code> a particular clock time <em>using an unsynchronized (non-realtime) clock</em>, your thread <em>will not wake up</em>. So the note above is a bit of an understatement.</p>\n<p>And, indeed, there is nothing in the Clock specification (20.13.3) that actually requires synchronization with a steady clock.</p>\n<p>However, the standard appears to implicitly condone two potential aliases for <code>high_resolution_clock</code> in the definition in 20.13.7.3:</p>\n<blockquote>\n<p id=\"so_38252022_38253266_1\"><code>high_resolution_clock</code> may be a synonym for <code>system_clock</code> or\n  <code>steady_clock</code>.</p>\n</blockquote>\n<p><code>steady_clock</code> is, of course, steady. <code>system_clock</code> is <strong>not</strong>, because the system time could change (e.g. as the result of an NTP update) while the program is running.</p>\n<p>However, <code>system_clock</code> (20.13.7.1) <strong>is</strong> still a \"realtime\" clock:</p>\n<blockquote>\n<p id=\"so_38252022_38253266_2\">Objects of class <code>system_clock</code> represent wall clock time from the\n  system-wide realtime clock.</p>\n</blockquote>\n<p>So <code>system_clock</code> <strong>will not</strong> stop advancing when your thread sleeps. \nThis confirms Nicol Bolas's point that a <code>is_steady</code> may be <em>false</em> for <code>high_resolution_clock</code> even if the clock behaves as you expect (i.e. it advances regardless of the state of its associated thread).</p>\n<p>Based on this, it seems reasonable to expect most mainstream implementations to use a realtime (i.e. synchronized) clock of some sort for <code>high_resolution_clock</code>. Implementations are designed to be useful, after all, and a clock is generally less useful if it's not realtime, especially if it's used with timers as per the note on \"useful functionality\" above.</p>\n<p>Since it's not <em>guaranteed</em>, however, you should check the behavior and/or documentation of each implementation you want to use.</p>\n<p><strong>EDIT:</strong> I've started a <a href=\"https://groups.google.com/a/isocpp.org/forum/?fromgroups#!topic/std-discussion/D_S47zTnNmw\" rel=\"nofollow\">discussion on the ISO C++ Standards group</a> on the issue, suggesting that this is a bug in the standard. The first reply, from Howard Hinnant, who takes credit for putting it <em>in</em> the standard, is worth quoting:</p>\n<blockquote>\n<p id=\"so_38252022_38253266_3\">I would not be opposed to deprecating <code>high_resolution_clock</code>, with the intent to remove it after a suitable period of deprecation.  The reality is that it is always a typedef to either <code>steady_clock</code> or <code>system_clock</code>, and the programmer is better off choosing one of those two and know what he\u2019s getting, than choose <code>high_resolution_clock</code> and get some other clock by a roll of the dice.</p>\n</blockquote>\n<p>...So the moral, according to Hinnant, is <strong>don't use <code>high_resolution_clock</code>.</strong></p>\n<p><strong>EDIT 2:</strong></p>\n<p>The problem with <code>high_resolution_clock</code> according to Hinnant is not so much that you're likely to run into a problem with HRC (although that <em>is</em> possible even with a conforming compiler, as per the argument above), but that since you're typically not actually getting a lower resolution than you could with the one of the other two clocks (though you'll need to manually compare their resolutions in a type-alias or typedef to get a \"maximum resolution\" non-sleeping clock), there's no concrete benefit. So you need to weigh the risk of having threads sleep forever on conforming implementations versus the semantic benefit of the name <code>high_resolution_clock</code> and the simplicity/brevity benefit of avoiding just making your own typedef or type-alias.</p>\n<p>Here's some actual code for various approaches:</p>\n<ul>\n<li><p>Use <code>static_assert</code> to <em>check</em> whether <code>high_resolution_clock</code> is actually aliased to a real clock. This will <em>probably</em> never fire, which means that you're automatically getting the highest-resolution \"realtime\" clock without messing with your own typedefs:</p>\n<pre><code> static_assert(\n      std::is_same&lt;high_resolution_clock, steady_clock&gt;::value\n   || std::is_same&lt;high_resolution_clock, system_clock&gt;::value,\n   \"high_resolution_clock IS NOT aliased to one of the other standard clocks!\");\n</code></pre></li>\n<li><p>Use the HRC if <code>high_resolution_clock::is_steady</code> is true; otherwise prefer the higher-resolution clock between <code>system_clock</code> and <code>steady_clock</code>. <strong>NOTE</strong> that if <code>high_resolution_clock::is_steady</code> is false, this <em>probably</em> just means that the HRC is aliased to <code>system_clock</code>, in which case you'll ultimately end up with a new type-alias that is actually the same type as <code>high_resolution_clock</code>. However, creating your own type-alias makes this explicit and guarantees that even a malicious-but-conforming implementation won't have the issue outlined above.</p>\n<pre><code>using maxres_sys_or_steady =\n    std::conditional&lt;\n        system_clock::period::den &lt;= steady_clock::period::den,\n        system_clock, steady_clock\n      &gt;::type;\nusing maxres_nonsleeping_clock =\n    std::conditional&lt;\n        high_resolution_clock::is_steady,\n        high_resolution_clock, maxres_sys_or_steady\n      &gt;::type;\n</code></pre></li>\n</ul>\n", "LastEditorUserId": "1858225", "LastActivityDate": "2016-08-01T21:42:00.690", "Score": "17", "CreationDate": "2016-07-07T18:55:16.753", "ParentId": "38252022", "CommentCount": "13", "OwnerUserId": "1858225", "LastEditDate": "2016-08-01T21:42:00.690"}, "38252559": {"Id": "38252559", "PostTypeId": "2", "Body": "<p>The standard does not specify this behavior from its clocks. Not exactly.</p>\n<p>A clock has the <code>is_steady</code> static property, which can be checked. Any clock for which <code>is_steady</code> returns true <em>cannot</em> be the sort of clock that stops running just because you put a thread to sleep. However, a clock for which that value is false could be non-steady for a variety of reasons. It may not be steady because it's a wall clock that will change if the system time changes. Or because the period between ticks is an average, rather than an exact number.</p>\n<p>So <code>is_steady</code> does not really answer your question.</p>\n<p>The standard does not specify <code>high_resolution_clock::is_steady</code>, but it does require the implementation to answer that question. If it is steady, then you are guaranteed that sleeping a thread won't stop the clock. But if it's not steady... you get no guarantee at all.</p>\n", "LastActivityDate": "2016-07-07T18:14:15.447", "CommentCount": "5", "CreationDate": "2016-07-07T18:14:15.447", "ParentId": "38252022", "Score": "8", "OwnerUserId": "734069"}});