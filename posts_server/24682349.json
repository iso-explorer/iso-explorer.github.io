post_cb({"24682448": {"ParentId": "24682349", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>static</code> data members are <em>declared</em> in the <code>class</code> definition.  They need to be <em>defined</em> (once) outside of that, usually in the corresponding <code>cpp</code> file:</p>\n<pre><code>data_member Y::m;\n</code></pre>\n<p>this is where you'll see it's default ctor called.</p>\n", "OwnerUserId": "1312406", "LastEditorUserId": "1312406", "LastEditDate": "2014-07-10T17:09:06.973", "Id": "24682448", "Score": "2", "CreationDate": "2014-07-10T17:07:30.220", "LastActivityDate": "2014-07-10T17:09:06.973"}, "24693973": {"ParentId": "24682349", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Basic answer:\nWith class members it's like with functions.\nWe have declarations and definitions.\nYou \"declare\" their existence @class level and \"definition\" is made by constructor.\nWith static member its more complex. They are not \"instance related\" and constructor will not \"define\" them. You have to do it by your own outside of class:</p>\n<pre><code>Type CLASS::member;\n</code></pre>\n<p>Btw it's quitebad practice to use static members.  </p>\n<p>Use a static function instead :</p>\n<pre><code>class Foo{\npublic:\n     Type &amp;getMember(){\n         static Type member;\n         return member;\n     }\n};\n</code></pre>\n", "OwnerUserId": "3828718", "LastEditorUserId": "3706101", "LastEditDate": "2014-07-11T09:25:42.527", "Id": "24693973", "Score": "0", "CreationDate": "2014-07-11T09:05:03.763", "LastActivityDate": "2014-07-11T09:25:42.527"}, "24682460": {"ParentId": "24682349", "CommentCount": "0", "Body": "<pre><code>struct Y\n{\n    static data_member m;\n    Y(){ cout &lt;&lt; \"Y\\n\"; }\n    ~Y(){ cout &lt;&lt; \"~Y\\n\"; }\n};\n</code></pre>\n<p>This only <em>declares</em> <code>m</code>. For all the compiler knows, <code>Y::m</code> is defined in another translation unit. Since static data members are one-per-class, you have to be able to declare them without defining them, or you won't be able to put the class definition in a header file without violating the One Definition Rule when including the header in different translation units.</p>\n<pre><code>data_member Y::m;\n</code></pre>\n<p>This defines m and <a href=\"http://coliru.stacked-crooked.com/a/6ba0278f6551959f\" rel=\"nofollow\">will cause a constructor call</a>. </p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "24682460", "Score": "2", "CreationDate": "2014-07-10T17:08:16.677", "LastActivityDate": "2014-07-10T17:08:16.677"}, "24682349": {"CommentCount": "7", "ViewCount": "95", "OwnerDisplayName": "user2953119", "CreationDate": "2014-07-10T17:01:20.343", "LastActivityDate": "2014-07-11T09:25:42.527", "PostTypeId": "1", "AcceptedAnswerId": "24682473", "Title": "Initialization of static data member", "Id": "24682349", "Score": "0", "Body": "<p>Why does default initialization of static data member not occur? In the following example</p>\n<pre><code>struct data_member\n{\n    data_member(){ cout &lt;&lt; \"data_member\\n\"; }\n    ~data_member(){ cout &lt;&lt; \"~data_member\\n\"; }\n};\n\nstruct Y\n{\n    static data_member m;\n    Y(){ cout &lt;&lt; \"Y\\n\"; }\n    ~Y(){ cout &lt;&lt; \"~Y\\n\"; }\n};\n\nY y; //call constructor of Y \n</code></pre>\n<p>but if we delete <code>static</code> specifier from <code>data_member m</code> it will be default-initialized.</p>\n<pre><code>struct data_member\n{\n    data_member(){ cout &lt;&lt; \"data_member\\n\"; }\n    ~data_member(){ cout &lt;&lt; \"~data_member\\n\"; }\n};\n\nstruct Y\n{\n    data_member m;\n    Y(){ cout &lt;&lt; \"Y\\n\"; }\n    ~Y(){ cout &lt;&lt; \"~Y\\n\"; }\n};\n\nY y; //call Y() and data_member()\n</code></pre>\n", "Tags": "<c++><storage-duration>", "AnswerCount": "4"}, "24682473": {"ParentId": "24682349", "CommentCount": "0", "Body": "<p>A static member must be defined outside the class definition. It will be initialized (can be default initialized too) at that time.</p>\n<p>The following description from the draft standard about <code>static</code> member variables should explain why it is not default initialized in the class declaration.</p>\n<blockquote>\n<p id=\"so_24682349_24682473_0\"><strong>9.4.2 Static data members</strong></p>\n<p id=\"so_24682349_24682473_1\">2 The declaration of a <code>static</code> data member in its class definition is not a definition and may be of an incomplete type other than cv-qualified <code>void</code>. The definition for a <code>static</code> data member shall appear in a namespace scope enclosing the member\u2019s class definition. In the definition at namespace scope, the name of the <code>static</code> data member shall be qualified by its class name using the :: operator.</p>\n</blockquote>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "24682473", "Score": "3", "CreationDate": "2014-07-10T17:09:03.967", "LastActivityDate": "2014-07-10T17:09:03.967"}, "bq_ids": {"n4140": {"so_24682349_24682473_1": {"section_id": 5907, "quality": 0.9512195121951219, "length": 39}}, "n3337": {"so_24682349_24682473_1": {"section_id": 5679, "quality": 0.9512195121951219, "length": 39}}, "n4659": {"so_24682349_24682473_1": {"section_id": 7389, "quality": 0.9024390243902439, "length": 37}}}});