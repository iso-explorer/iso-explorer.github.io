post_cb({"bq_ids": {"n4140": {"so_30852922_30853213_0": {"section_id": 5464, "quality": 0.9333333333333333, "length": 14}, "so_30852922_30853213_2": {"section_id": 6036, "quality": 0.9444444444444444, "length": 17}, "so_30852922_30853213_1": {"section_id": 5466, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_30852922_30853213_0": {"section_id": 5251, "quality": 0.7333333333333333, "length": 11}, "so_30852922_30853213_2": {"section_id": 5804, "quality": 0.9444444444444444, "length": 17}, "so_30852922_30853213_1": {"section_id": 5252, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_30852922_30853213_0": {"section_id": 6898, "quality": 0.9333333333333333, "length": 14}, "so_30852922_30853213_2": {"section_id": 7535, "quality": 0.9444444444444444, "length": 17}, "so_30852922_30853213_1": {"section_id": 6900, "quality": 0.9090909090909091, "length": 10}}}, "30852922": {"CommentCount": "8", "ViewCount": "200", "CreationDate": "2015-06-15T18:55:46.557", "LastActivityDate": "2015-06-15T20:21:57.453", "Title": "Why is initialization of enum class temporaries with arbitrary values allowed?", "AcceptedAnswerId": "30853213", "PostTypeId": "1", "Id": "30852922", "Score": "8", "Body": "<p>I came across some code like the following in one the CppCon 2014 talks that confused the heck out of me.  The audience accepted it without comment, so I presume that it's legal:</p>\n<pre><code>enum class Foo { Bar };\n\nFoo const v1 = Foo(5);\n</code></pre>\n<p>The question is: why does this compile?  I would expect compilation to fail and complain that we can't convert an int to a Foo.  The slightly modified line below fails with the expected error:</p>\n<pre><code>Foo const v1(5);\n</code></pre>\n", "Tags": "<c++><c++11>", "OwnerUserId": "114421", "AnswerCount": "1"}, "30853213": {"ParentId": "30852922", "PostTypeId": "2", "CommentCount": "13", "CreationDate": "2015-06-15T19:13:17.610", "Score": "9", "LastEditorUserId": "743382", "LastEditDate": "2015-06-15T20:21:57.453", "Id": "30853213", "OwnerUserId": "743382", "Body": "<p>Scoped enumeration types have an implicit underlying type of <code>int</code>, assuming no other underlying type is specified. All possible values of type <code>int</code> can be represented.</p>\n<p>7.2p5:</p>\n<blockquote>\n<p id=\"so_30852922_30853213_0\">[...] For a scoped enumeration type, the underlying type is <code>int</code> if it is not explicitly specified. In both of these cases, the underlying type\n  is said to be <em>fixed</em>. [...]</p>\n</blockquote>\n<p>7.2p8:</p>\n<blockquote>\n<p id=\"so_30852922_30853213_1\">For an enumeration whose underlying type is fixed, the values of the enumeration are the values of the underlying type. [...]</p>\n</blockquote>\n<p>And any integral value that can be represented by the enumeration can be explicitly converted to that enumeration type, as @Columbo had pointed out in his now-deleted answer:</p>\n<p>5.2.9p10:</p>\n<blockquote>\n<p id=\"so_30852922_30853213_2\">A value of integral or enumeration type can be explicitly converted to an enumeration type. The value is unchanged if the original value is within the range of the enumeration values (7.2). [...]</p>\n</blockquote>\n<p>Since there is some confusion in the comments about what that means:</p>\n<blockquote id=\"so_30852922_30853213_3\">\n<pre><code>enum class Foo { Bar };\n\nFoo const v1 = Foo(5);\n</code></pre>\n</blockquote>\n<p>is well-defined. Not undefined, not unspecified, not even implementation-defined. The parts of the standard I quote explain that:</p>\n<ol>\n<li>The underlying type of <code>Foo</code> is <code>int</code>, and that the underlying type is fixed.</li>\n<li>The values of <code>Foo</code> are the values of <code>int</code>.</li>\n<li>Since <code>5</code> is in the range of the enumeration values, the value is unchanged by the conversion.</li>\n</ol>\n", "LastActivityDate": "2015-06-15T20:21:57.453"}});