post_cb({"8271766": {"Id": "8271766", "PostTypeId": "2", "Body": "<p>The C++ standard demands explicitly that every type have size at least 1. This is intimately tied to the requirement that each object have a unique address (consider <code>Foo x[10]</code> if <code>Foo</code> had size zero).</p>\n", "LastActivityDate": "2011-11-25T16:20:35.627", "CommentCount": "0", "CreationDate": "2011-11-25T16:20:35.627", "ParentId": "8271673", "Score": "0", "OwnerUserId": "596781"}, "8271673": {"ViewCount": "2781", "Body": "<p>I'm trying to declare a C++ variable that takes up zero bytes. Its in a union, and I started with the type as int[0]. I don't know if that is actually zero bytes (although sizeof(int[0]) was 0). I need a better way to declare a 0 byte type, and hopefully one that can be typedefed to something like nullType or emptyType. The variable is in a union, so in the end memory is reserved anyway. I tried void on the off chance it would work, but C++ complained. I'm using Ubuntu 10.10, with a current version of the kernel, and an up-to-date GCC.\nHere's the union:</p>\n<pre><code>union RandomArgumentTypesFirst\n{\n    uint uintVal;\n    nullType nullVal;\n}\n</code></pre>\n<p>And here is  the typedef:</p>\n<pre><code>typedef int[0] nullType;\n</code></pre>\n<p>The compiler says this about the typedef:</p>\n<pre><code>error: variable or field \u2018nullVal\u2019 declared voidmake[2]:\n</code></pre>\n<p>When I typed in <code>int[0]</code>, it worked. Any suggestions?</p>\n<p>EDIT:\nAs @fefe said in the comments, the <code>int[0]</code> may be provided as an extension by the compiler. GCC's website says that the compiler has many extensions by default.</p>\n", "AcceptedAnswerId": "8271757", "Title": "Can there be a C++ type that takes 0 bytes", "CreationDate": "2011-11-25T16:12:53.460", "Id": "8271673", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-01-27T14:52:22.357", "LastEditorUserId": "1008938", "LastActivityDate": "2016-07-20T15:37:58.120", "Score": "5", "OwnerUserId": "1008938", "Tags": "<c++><null><sizeof><void>", "AnswerCount": "6"}, "8271760": {"Id": "8271760", "PostTypeId": "2", "Body": "<p>A variable in C++ can never take zero bytes. Every object must have unique address, which is not possible if the size is zero.</p>\n<p>By the way,<code>int[0]</code> is illegal in Standard C++. If you're using GCC, compile it with <code>-pedantic</code> option, you will get this warning:</p>\n<pre><code>warning: ISO C++ forbids zero-size array 'x' [-pedantic]\n</code></pre>\n<p>Also, the syntax for <code>typedef</code> should be this:</p>\n<pre><code>  typedef int array[100]; //zero cannot be size - illegal!\n</code></pre>\n", "LastEditorUserId": "415784", "LastActivityDate": "2011-11-25T16:25:53.427", "Score": "1", "CreationDate": "2011-11-25T16:20:22.420", "ParentId": "8271673", "CommentCount": "4", "OwnerUserId": "415784", "LastEditDate": "2011-11-25T16:25:53.427"}, "8271750": {"Id": "8271750", "PostTypeId": "2", "Body": "<p>You cannot instantiate any data type in C++ that takes up zero bytes.  The Standard dictates than an empty class, such as:</p>\n<pre><code>class Empty {};\n</code></pre>\n<p>...will result in the following being true:</p>\n<pre><code>Empty emp;\nassert( sizeof(emp) != 0 );\n</code></pre>\n<p>The reason for this is so that you can take the address of the object.</p>\n<p>EDIT:  I originally said the <code>sizeof</code> would be <code>1</code>, but per @Als' comment, I have found the relevant passage in the Standard, and it is indeed simply non-zero:</p>\n<p>[Classes] \u00a79/3</p>\n<blockquote>\n<p id=\"so_8271673_8271750_0\">Complete objects and member subobjects of class type shall have nonzero size</p>\n</blockquote>\n", "LastEditorUserId": "415784", "LastActivityDate": "2011-11-25T16:30:58.493", "Score": "6", "CreationDate": "2011-11-25T16:19:25.357", "ParentId": "8271673", "CommentCount": "5", "OwnerUserId": "241536", "LastEditDate": "2011-11-25T16:30:58.493"}, "bq_ids": {"n4140": {"so_8271673_8271750_0": {"length": 9, "quality": 1.0, "section_id": 5848}}, "n3337": {"so_8271673_8271750_0": {"length": 9, "quality": 1.0, "section_id": 5618}}, "n4659": {"so_8271673_8271750_0": {"length": 9, "quality": 1.0, "section_id": 7327}}}, "8271757": {"Id": "8271757", "PostTypeId": "2", "Body": "<p>The typedef is misspelled:</p>\n<pre><code>typedef int nullType[0];\n</code></pre>\n<p>As others have pointed out, you cannot have an object of size 0; However, compilers can (and frequently do) provide the <em><code>Empty Base Class</code></em> optimization.</p>\n<ul>\n<li><a href=\"http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Empty_Base_Optimization\" rel=\"nofollow\">http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Empty_Base_Optimization</a></li>\n<li><a href=\"http://www.cantrip.org/emptyopt.html\" rel=\"nofollow\">http://www.cantrip.org/emptyopt.html</a> (\"empty member\" optimization)</li>\n</ul>\n", "LastActivityDate": "2011-11-25T16:20:13.380", "CommentCount": "1", "CreationDate": "2011-11-25T16:20:13.380", "ParentId": "8271673", "Score": "4", "OwnerUserId": "85371"}, "38484909": {"Id": "38484909", "PostTypeId": "2", "Body": "<p>It sounds like you want <a href=\"http://en.cppreference.com/w/cpp/utility/optional\" rel=\"nofollow\">std::optional</a>.<br>\nIt won't have a <code>sizeof</code> 0, but that's not important for expressing an empty value.</br></p>\n<hr>\n<p>On a related note,  there is C++ proposal (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0146r1.html\" rel=\"nofollow\">P0146R1</a>) to make <code>void</code> a regular type.<br>\nThe paper goes on to discuss why even <code>sizeof(void)</code> can't be 0.  </br></p>\n<blockquote>\n<p id=\"so_8271673_38484909_0\"><strong>Why Isn't sizeof(void) Equal to 0?</strong> </p>\n<p id=\"so_8271673_38484909_1\">One suggestion that has repeatedly come up is to have sizeof(void)\n  report 0 and to allow multiple instances to share the same address.\n  This would prevent users from having to use tricks akin to the empty\n  base optimization in order to make more optimal usage of memory.\n  Ideally, this would be the case, however such a change to the language\n  is both vast and out of scope of the proposal. <strong>Allowing a type to have</strong>\n<strong>a 0 size and to allow separate instances to share an address implies</strong>\n<strong>drastic and subtle breaking changes to existing code</strong>. For instance, if\n  you were to make an array of such a void type, a pointer, at least in\n  the traditional sense, would no longer be able to be used as an\n  iterator into that array (notably meaning that generic code which\n  relies on this would now fail for such a size 0 type). As well, any\n  code that relies on an object's type and address as unique would fail\n  for void types, even though it is otherwise perfectly acceptable.\n  Finally, if such a size were permitted for void, it should really be\n  allowed for any type, including user-defined types. Having a special\n  rule for void would make one more thing to have to think about and\n  deal with differently for void types. Instead, this proposal opts to\n  leave the size of void unspecified and thereby governed by existing\n  language rules. In practice, it is expected that void will likely be\n  size 1 in most implementations, though this is not required. If an\n  eventual change were made to the language to allow for size 0 types,\n  then void would be able to implicitly take advantage of that.</p>\n</blockquote>\n<hr>\n<p>Although this question is targeted to C++, it should be noted that an empty struct in C may result in a <code>sizeof</code> of 0.  This however, is undefined behavior.  </p>\n<blockquote>\n<p id=\"so_8271673_38484909_2\">If the struct-declaration-list contains no named members, the behavior\n  is undefined.</p>\n</blockquote>\n</hr></hr>", "LastActivityDate": "2016-07-20T15:37:58.120", "CommentCount": "0", "CreationDate": "2016-07-20T15:37:58.120", "ParentId": "8271673", "Score": "0", "OwnerUserId": "908939"}, "8271751": {"Id": "8271751", "PostTypeId": "2", "Body": "<p>The standard explicitly prohibits the existence of an instance of a type with size 0, the reason is that if an object could have size 0, then two different objects could be located at the exact same address. An empty struct, for example, will be forced to have size &gt; 0 to comply with that requirement even if when used as base of a different type, the compiler can have it have size == 0.</p>\n<p>What is it that you want to do with an <em>empty class</em>?</p>\n", "LastActivityDate": "2011-11-25T16:19:29.120", "CommentCount": "6", "CreationDate": "2011-11-25T16:19:29.120", "ParentId": "8271673", "Score": "6", "OwnerUserId": "36565"}});