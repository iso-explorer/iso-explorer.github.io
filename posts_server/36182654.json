post_cb({"36183548": {"Id": "36183548", "PostTypeId": "2", "Body": "<p>The cast implies a conversion, if necessary. But this is problematic for negative values. They are mapped to positive values on the unsigned type. Thus you have to make sure a negative value never compares equal any (positive) unsigned value:</p>\n<pre><code>int A;\nunsigned int B;\n\n...\n\nif ( (A &gt;= 0) &amp;&amp; (static_cast&lt;unsigned int&gt;(A) == B) )\n    foo();\n</code></pre>\n<p>This works because the unsigned variant of an integer type is guaranteed to hold all positive values (including <code>0</code>) of the corressponding signed type.</p>\n<p>Notice the usage of a <a href=\"https://stackoverflow.com/questions/103512/in-c-why-use-static-castintx-instead-of-intx\"><code>static_cast</code></a> instead of the \"classic\" C-style cast.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-03-23T16:36:18.037", "Score": "1", "CreationDate": "2016-03-23T16:24:12.560", "ParentId": "36182654", "CommentCount": "4", "OwnerUserId": "4774918", "LastEditDate": "2017-05-23T11:59:33.587"}, "36183442": {"Id": "36183442", "PostTypeId": "2", "Body": "<p>So you question is just about a signed/unsigned comparison.</p>\n<p>C++ standard says in clause 5 Expressions [expr] \u00a7 10:</p>\n<blockquote>\n<p id=\"so_36182654_36183442_0\">Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield\n  result types in a similar way. The purpose is to yield a common type, which is also the type of the result.\n  This pattern is called the usual arithmetic conversions, which are defined as follow:<br/>...<br/>\n  Otherwise, if the operand that has unsigned integer type has rank greater than or equal to the\n  rank of the type of the other operand, the operand with signed integer type shall be converted to\n  the type of the operand with unsigned integer type.</p>\n</blockquote>\n<p>and in 4.7 Integral conversions [conv.integral] \u00a72</p>\n<blockquote>\n<p id=\"so_36182654_36183442_1\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source\n  integer (modulo 2n where n is the number of bits used to represent the unsigned type). [ Note: In a two\u2019s\n  complement representation, this conversion is conceptual and there is no change in the bit pattern (if there\n  is no truncation). \u2014end note ]</p>\n</blockquote>\n<p>That means that on a common system using 2-complement for negative numbers and 32 bits for an int or unsigned int, <code>(unsigned int) -1</code> will end in 4294967295.</p>\n<p>It may be what you want or not, the compiler just warn you that it will consider them as equal.</p>\n<p>If it is not what you want, just first test whether the signed value is negative. If it is, say that they are not equal an skip the equality comparison.</p>\n", "LastEditorUserId": "3545273", "LastActivityDate": "2016-03-23T16:59:08.567", "Score": "0", "CreationDate": "2016-03-23T16:19:20.310", "ParentId": "36182654", "CommentCount": "0", "OwnerUserId": "3545273", "LastEditDate": "2016-03-23T16:59:08.567"}, "36183315": {"Id": "36183315", "PostTypeId": "2", "Body": "<p>With plain types, in C and C++, <code>==</code> is always done with both operands converted to the same type.  In OP's code, <code>A</code> is converted to <code>unsigned</code> first.</p>\n<blockquote>\n<p id=\"so_36182654_36183315_0\">If I cast ... does this instruct the compiler to insert code to convert A from int to unsigned int?</p>\n</blockquote>\n<p>Yes, but that code would have occurred anyway.  Without the cast, the compiler is simple warning that it is going to do something that the programmer may not have intended.</p>\n<blockquote>\n<p id=\"so_36182654_36183315_1\">Or (If I cast ) does it just tell the compiler don't worry about, ignore the type mismatch?</p>\n</blockquote>\n<p>The type mis-match is not ignored.  By supplying the cast, there is no type mis-match to warn about.</p>\n<hr>\n<blockquote>\n<p id=\"so_36182654_36183315_2\">How should I handle this comparison?</p>\n</blockquote>\n<p>Insure <code>A</code> is not negative, then convert to <code>unsigned</code> with a cast.</p>\n<pre><code>int A;\nunsigned int B;\n// if (A==B) foo();\nif (A &gt;= 0 &amp;&amp; (unsigned)A == B) foo();\n</code></pre>\n<p>Every non-negative <code>int</code> can be converted to an <code>unsigned</code> with no value change.</p>\n<blockquote>\n<p id=\"so_36182654_36183315_3\">The range of nonnegative values of a signed integer type is a subrange of the\n  corresponding unsigned integer type C11dr \u00a76.2.5 9</p>\n</blockquote>\n</hr>", "LastEditorUserId": "2410359", "LastActivityDate": "2016-03-23T16:38:50.880", "Score": "1", "CreationDate": "2016-03-23T16:14:26.033", "ParentId": "36182654", "CommentCount": "1", "OwnerUserId": "2410359", "LastEditDate": "2016-03-23T16:38:50.880"}, "bq_ids": {"n4140": {"so_36182654_36183315_3": {"length": 11, "quality": 0.7857142857142857, "section_id": 7212}, "so_36182654_36183442_1": {"length": 29, "quality": 0.90625, "section_id": 31}, "so_36182654_36183442_0": {"length": 51, "quality": 0.9444444444444444, "section_id": 5943}}, "n3337": {"so_36182654_36183315_3": {"length": 11, "quality": 0.7857142857142857, "section_id": 6956}, "so_36182654_36183442_1": {"length": 29, "quality": 0.90625, "section_id": 28}, "so_36182654_36183442_0": {"length": 51, "quality": 0.9444444444444444, "section_id": 5714}}, "n4659": {"so_36182654_36183315_3": {"length": 11, "quality": 0.7857142857142857, "section_id": 8721}, "so_36182654_36183442_1": {"length": 29, "quality": 0.90625, "section_id": 31}, "so_36182654_36183442_0": {"length": 51, "quality": 0.9444444444444444, "section_id": 7428}}}, "36183205": {"Id": "36183205", "PostTypeId": "2", "Body": "<p>When casting, at least at the conceptual level, compiler will create a temporary variable of the type specified in the cast expression.</p>\n<p>You may test that this expression:</p>\n<pre><code>(unsigned int) A = B; // This time assignment is intended\n</code></pre>\n<p>will generate an error pointing modification of a temporary (const) variable.</p>\n<p>Of course compiler is free to optimize away any temporary variables created through a cast. Nevertheless a valid method to build a temporary must exist. </p>\n", "LastActivityDate": "2016-03-23T16:09:29.470", "CommentCount": "0", "CreationDate": "2016-03-23T16:09:29.470", "ParentId": "36182654", "Score": "1", "OwnerUserId": "239189"}, "36182979": {"Id": "36182979", "PostTypeId": "2", "Body": "<p>It depends on type of cast and what you are casting. In your particular case nothing is going to happen, but in other cases the actual code will be performed. Simplest example:</p>\n<pre><code>void foo(double d) {};\n...\nint x;\nfoo(static_cast&lt;double&gt;(x));\n</code></pre>\n<p>In this example there would be code generated.</p>\n", "LastActivityDate": "2016-03-23T15:59:13.800", "CommentCount": "0", "CreationDate": "2016-03-23T15:59:13.800", "ParentId": "36182654", "Score": "-1", "OwnerUserId": "5245033"}, "36182654": {"ViewCount": "189", "Body": "<p>If I have this code:</p>\n<pre><code>int A;\nunsigned int B;\nif (A==B) foo();\n</code></pre>\n<p>the compiler will complain about mixed types in comparison.  If I cast A like this:</p>\n<pre><code>if ((unsigned int) A==B) foo();\n</code></pre>\n<p>does this instruct the compiler to insert code to convert A from int to unsigned int?  Or does it just tell the compiler don't worry about, ignore the type mismatch?</p>\n<hr>\n<h2>UPDATE: If this is unsafe (as pointed out below), how should I handle this comparison?  (Wouldn't assigning the contents of an int to an unsigned int for later comparison also be unsafe)</h2>\n<p>UPDATE: Wow are there some different answers (from people with thousands of posts).  I've accepted what seems like the best, but anyone reading this question should read ALL answers carefully.</p>\n</hr>", "AcceptedAnswerId": "36183548", "Title": "Does cast change variable in c++, or only tell compiler its ok", "CreationDate": "2016-03-23T15:43:52.477", "Id": "36182654", "CommentCount": "8", "LastEditDate": "2016-03-24T15:01:14.130", "PostTypeId": "1", "LastEditorUserId": "659503", "LastActivityDate": "2016-03-24T15:01:14.130", "Score": "2", "OwnerUserId": "659503", "Tags": "<c++><casting><compilation>", "AnswerCount": "5"}});