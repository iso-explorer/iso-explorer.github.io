post_cb({"27160109": {"Id": "27160109", "PostTypeId": "2", "Body": "<p>First, an <em>id-expression</em> naming a nonstatic member function (<code>mem_type::update</code> in this case) can't be used as an unevaluated operand (such as the operand of <code>decltype</code>).  \u00a75.1.1 [expr.prim.general]/p13 (footnote omitted):</p>\n<blockquote>\n<p id=\"so_27159187_27160109_0\">An <em>id-expression</em> that denotes a non-static data member or non-static\n  member function of a class can only be used:</p>\n<ul>\n<li>as part of a class member access (5.2.5) in which the object expression refers to the member\u2019s class or a class derived from that\n  class, or</li>\n<li>to form a pointer to member (5.3.1), or</li>\n<li>if that <em>id-expression</em> denotes a non-static data member and it appears in an unevaluated operand.</li>\n</ul>\n</blockquote>\n<p>\u00a77.1.6.2 [dcl.type.simple]/p4:</p>\n<blockquote>\n<p id=\"so_27159187_27160109_1\">The operand of the <code>decltype</code> specifier is an unevaluated operand\n  (Clause 5).</p>\n</blockquote>\n<p>And even if <code>update</code> were a regular function, <code>decltype</code> would produce a function type rather than a function pointer type, and your specialization matches a pointer-to-member-function type.</p>\n<p>You need to created a pointer-to-member-function with <code>&amp;</code> - i.e., <code>decltype(&amp;mem_type::update)</code>.</p>\n", "LastActivityDate": "2014-11-26T22:39:14.927", "CommentCount": "3", "CreationDate": "2014-11-26T22:39:14.927", "ParentId": "27159187", "Score": "4", "OwnerUserId": "2756719"}, "bq_ids": {"n4140": {"so_27159187_27160109_0": {"length": 10, "quality": 1.0, "section_id": 5959}, "so_27159187_27160109_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5440}}, "n3337": {"so_27159187_27160109_0": {"length": 10, "quality": 1.0, "section_id": 5728}, "so_27159187_27160109_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5235}}, "n4659": {"so_27159187_27160109_0": {"length": 10, "quality": 1.0, "section_id": 7440}, "so_27159187_27160109_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 6867}}}, "27159187": {"ViewCount": "350", "Body": "<p>I have written a metafunction to retrieve the type of the first parameter of a member function, which of course receives one or more parameters. The code I have written is as follow:</p>\n<pre><code>template &lt;typename...&gt; struct parameter;\n\ntemplate &lt; typename O, typename A, typename R, typename... Args&gt;\nstruct parameter &lt;R (O::*)(A, Args...)  &gt; {\n     using first_param = A;\n};\n</code></pre>\n<p>I use this meta function as follow:</p>\n<pre><code>using mem_fn = void(mem_type::*)(std::vector&lt;int&gt;);\nusing f_pm = parameter&lt;mem_fn&gt;::first_param;\n</code></pre>\n<p>and it compiles and works. But when I have a class:</p>\n<pre><code>struct mem_type{\n\n    void update(std::vector&lt;int&gt;) {\n\n    }\n};\n</code></pre>\n<p>and use my metafunction as follow:</p>\n<pre><code>using mem_fn = decltype(mem_type::update);\nusing f_pm = parameter&lt;mem_fn&gt;::first_param;\n</code></pre>\n<p>the code does not compiles and visual studio 2013 gives: error C2027: use of undefined type <code>parameter&lt;mem_fn&gt;</code>.</p>\n<p>Does anyone knows the reason for this error?</p>\n", "AcceptedAnswerId": "27160109", "Title": "Type of the first parameter of a member function in C++11", "CreationDate": "2014-11-26T21:28:23.460", "Id": "27159187", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-11-26T22:29:45.530", "LastEditorUserId": "636019", "LastActivityDate": "2014-11-26T22:39:14.927", "Score": "7", "OwnerUserId": "1271795", "Tags": "<c++><templates><c++11><template-meta-programming>", "AnswerCount": "1"}});