post_cb({"bq_ids": {"n4140": {"so_10374180_10374588_1": {"length": 24, "quality": 0.9230769230769231, "section_id": 152}, "so_10374180_10374588_5": {"length": 15, "quality": 1.0, "section_id": 160}, "so_10374180_10374588_9": {"length": 12, "quality": 0.8, "section_id": 160}, "so_10374180_10374588_4": {"length": 24, "quality": 0.96, "section_id": 160}, "so_10374180_10374588_6": {"length": 7, "quality": 0.875, "section_id": 160}, "so_10374180_10374588_8": {"length": 12, "quality": 0.8571428571428571, "section_id": 160}, "so_10374180_10374588_7": {"length": 6, "quality": 1.0, "section_id": 160}, "so_10374180_10374588_2": {"length": 8, "quality": 1.0, "section_id": 154}, "so_10374180_10374588_10": {"length": 42, "quality": 0.9767441860465116, "section_id": 161}}, "n3337": {"so_10374180_10374588_1": {"length": 26, "quality": 1.0, "section_id": 146}, "so_10374180_10374588_5": {"length": 15, "quality": 1.0, "section_id": 154}, "so_10374180_10374588_9": {"length": 12, "quality": 0.8, "section_id": 154}, "so_10374180_10374588_4": {"length": 24, "quality": 0.96, "section_id": 154}, "so_10374180_10374588_6": {"length": 7, "quality": 0.875, "section_id": 154}, "so_10374180_10374588_8": {"length": 12, "quality": 0.8571428571428571, "section_id": 154}, "so_10374180_10374588_7": {"length": 6, "quality": 1.0, "section_id": 154}, "so_10374180_10374588_2": {"length": 8, "quality": 1.0, "section_id": 148}, "so_10374180_10374588_10": {"length": 42, "quality": 0.9767441860465116, "section_id": 155}}, "n4659": {"so_10374180_10374588_1": {"length": 24, "quality": 0.9230769230769231, "section_id": 156}, "so_10374180_10374588_5": {"length": 14, "quality": 0.9333333333333333, "section_id": 164}, "so_10374180_10374588_9": {"length": 12, "quality": 0.8, "section_id": 164}, "so_10374180_10374588_4": {"length": 24, "quality": 0.96, "section_id": 164}, "so_10374180_10374588_6": {"length": 7, "quality": 0.875, "section_id": 164}, "so_10374180_10374588_8": {"length": 12, "quality": 0.8571428571428571, "section_id": 164}, "so_10374180_10374588_7": {"length": 6, "quality": 1.0, "section_id": 164}, "so_10374180_10374588_2": {"length": 6, "quality": 0.75, "section_id": 158}, "so_10374180_10374588_10": {"length": 42, "quality": 0.9767441860465116, "section_id": 165}}}, "10374180": {"ViewCount": "1256", "Body": "<p>I came up with this after answering <a href=\"https://stackoverflow.com/questions/10369464/template-function-gives-no-matching-function-for-call-error\">this question</a></p>\n<p>I had a simple function template (C++11):</p>\n<pre><code>template&lt;class elem_t, class list_t&gt;\nbool in_list(const elem_t&amp; elem, const list_t&amp; list) {\n   for (const auto&amp; i : list) {\n      if (elem == i) {\n         return true;\n      }\n   }\n   return false;\n}\n</code></pre>\n<p>But GCC emitted warnings because it doesn't seem to like deducing a template parameter as a std::initializer_list.  So, without thinking, I made a specialization:</p>\n<pre><code>template&lt;class elem_t&gt;\nbool in_list(const elem_t&amp; elem, std::initializer_list&lt;elem_t&gt; list) {\n   for (const auto&amp; i : list) {\n      if (elem == i) {\n         return true;\n      }\n   }\n   return false;\n}\n</code></pre>\n<p>This worked.  No more warnings.  But when I looked again and thought about it, I remembered that C++ does not support partial template specialization on function templates.  But that is what this appears to be.  My only guess is that this is allowed because std::initializer_list is still dependent upon the template parameter, so it is, in essence, a different template.  But I'm not sure if this is how it is supposed to be (isn't there a gotw about templates not overloading?).</p>\n<p>Is it standard behavior to accept this?  And why?</p>\n<p>And as a bonus question, why does GCC not like deducing a template parameter as a std::initializer_list? It seems quite silly to expect me to copy and paste the code and just replace the parameter with a std::initializer_list.</p>\n<p>The warning message:</p>\n<pre><code>test.cpp: In function \u2018int main()\u2019:\ntest.cpp:33:43: warning: deducing \u2018const list_t\u2019 as \u2018const std::initializer_list&lt;int&gt;\u2019 [enabled by default]\ntest.cpp:6:6: warning:   in call to \u2018bool in_list(const elem_t&amp;, const list_t&amp;) [with elem_t = int, list_t = std::initializer_list&lt;int&gt;]\u2019 [enabled by default]\ntest.cpp:33:43: warning:   (you can disable this with -fno-deduce-init-list) [enabled by default]\n</code></pre>\n<p>When called by <code>in_list(3, {1, 2, 3, 4, 5});</code></p>\n<p>EDIT:  Apparently deducing a template parameter as an initializer_list is an extension according to the working draft for my version of GCC (<a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.4.4/gcc/C_002b_002b-Dialect-Options.html\" rel=\"nofollow noreferrer\">cite</a>).  So new question: Is this still an extension as of the final c++11 standard?  If so, this would mean that it would be necessary for me to add the second function for standards-compliant code.  Thanks for all your help! </p>\n<p>EDIT2:  The compiler dialect flag appears to be removed for GCC 4.7, so it seems like the issue was resolved, but I don't know <em>how</em> it was resolved.</p>\n", "AcceptedAnswerId": "10374588", "Title": "Is this partial function template specialization?", "CreationDate": "2012-04-29T17:19:25.537", "Id": "10374180", "CommentCount": "12", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:59:46.120", "LastEditorUserId": "-1", "LastActivityDate": "2012-04-29T18:40:00.817", "Score": "3", "OwnerUserId": "251860", "Tags": "<c++><templates><c++11><template-specialization><initializer-list>", "AnswerCount": "2"}, "10374249": {"Id": "10374249", "PostTypeId": "2", "Body": "<p>That's not partial specilization. What you are doing is overloading function.</p>\n", "LastActivityDate": "2012-04-29T17:27:16.763", "CommentCount": "4", "CreationDate": "2012-04-29T17:27:16.763", "ParentId": "10374180", "Score": "3", "OwnerUserId": "814628"}, "10374588": {"Id": "10374588", "PostTypeId": "2", "Body": "<p>Using what @Ben Voigt said in the comments on the other answer, I have gathered some relevant standard quotes:</p>\n<blockquote>\n<p id=\"so_10374180_10374588_0\">\u00a714.5.6.2</p>\n<p id=\"so_10374180_10374588_1\">A function template can be overloaded with other function templates\n  and with normal (non-template) functions. A normal function is not\n  related to a function template (i.e., it is <strong>never considered to be a\n  specialization</strong>), <strong>even if it has the same name and type as a\n  potentially generated function template specialization</strong>.</p>\n</blockquote>\n<p>So that rules out function template specialisation as what you're doing, because even if two function template overloads could potentially generate the same function, it's not specialisation. So it's overloading.</p>\n<blockquote>\n<p id=\"so_10374180_10374588_2\">Such specializations are distinct functions and do not violate the one definition rule (3.2).</p>\n</blockquote>\n<p>So they're distinct functions and that's why it's not erroring.</p>\n<blockquote>\n<p id=\"so_10374180_10374588_3\">\u00a714.5.6.2.1</p>\n<p id=\"so_10374180_10374588_4\">If a function template is overloaded, the use of a function template\n  specialization* might be ambiguous because template argument deduction\n  (14.8.2) may associate the function template specialization with more\n  than one function template declaration.</p>\n</blockquote>\n<p>This is priming is for what we both already saw, which is that <code>in_list(a, b)</code> where <code>b</code> is an <code>initializer_list</code> appears to match both function templates.</p>\n<p>(*Note that \"function template specialization\" here doesn't mean specialising a function template, it means a function template that has been instantiated with a type. So with <code>template&lt;typename T&gt; f();</code>, <code>f&lt;int&gt;()</code> is a function template specialisation.)</p>\n<p>So we use what is called <em>partial ordering of overloaded function templates</em> to resolve this:</p>\n<blockquote>\n<p id=\"so_10374180_10374588_5\">Partial ordering of overloaded function template declarations is\n  used in the following contexts to select the function template to which a function\n  template specialization\n  refers:</p>\n<p id=\"so_10374180_10374588_6\">\u2014 during overload resolution for a call to a function template specialization (13.3.3);</p>\n<p id=\"so_10374180_10374588_7\">\u2014 when the address of a function template specialization is taken;</p>\n<p id=\"so_10374180_10374588_8\">\u2014 when a placement operator delete that is a function template specialization is selected to match a placement operator new (3.7.4.2, 5.3.4);</p>\n<p id=\"so_10374180_10374588_9\">\u2014 when a friend function declaration (14.5.4), an explicit instantiation (14.7.2) or an explicit specialization (14.7.3) refers to a function template specialization.</p>\n</blockquote>\n<p>Ok, so that's when partial ordering is for. This is what it does:</p>\n<blockquote>\n<p id=\"so_10374180_10374588_10\">Partial ordering selects which of two function templates is more\n  specialized than the other by transforming each template in turn (see\n  next paragraph) and performing template argument deduction using the\n  function type. The deduction process determines whether one of the\n  templates is more specialized than the other. If so, the more\n  specialized template is the one chosen by the partial ordering\n  process.</p>\n</blockquote>\n<p>And then you get into the long and laborious process of determining which template is more specialised, which you can read about if you want, but it's really complicated and I probably don't understand it all (and plus, I don't have enough time to write about it :)).</p>\n", "LastEditorUserId": "726361", "LastActivityDate": "2012-04-29T18:32:01.567", "Score": "4", "CreationDate": "2012-04-29T18:05:30.127", "ParentId": "10374180", "CommentCount": "3", "OwnerUserId": "726361", "LastEditDate": "2012-04-29T18:32:01.567"}});