post_cb({"11666887": {"ViewCount": "3285", "Body": "<p>I have done little work in multi-threaded environments. So, I need to know whether below class's getInstance function is thread-safe or not. Here is singleton class :</p>\n<pre><code>//Singleton class\nclass S {\n  // intentionally avoided pointer\n  static S singleObject;\n\n   // Private constructor   \n   s ();\n   s (S &amp;);\n   s&amp; operator= (const s&amp;);\npublic:\n  // return reference of static object\n  s&amp; getInstance ()\n  {\n    return singleObject;\n  }\n\n  /* Normally with static pointer instance, getInstnace look like as\n   s&amp; getInstace ()\n   {\n      // trying to avoid multiple copies of singleObject\n      lock_mutex ()\n\n       if (singleObject == null)\n          singleObjecct = new S();\n\n      unlock_mutex ();\n\n      return *singleObject;\n    }\n  */\n};\n\nS S::singleObject;\n</code></pre>\n<p>In getInstance function (un-commented), static object's reference is returned. Does it requires thread-safe mechanism?</p>\n<p>In second getInstance (commented), we create the object if singleObject is null. So, it requires a locking mechanism and needs to be synchronized, right?</p>\n", "AcceptedAnswerId": "11668075", "Title": "Singleton threadsafe class", "CreationDate": "2012-07-26T09:58:26.607", "Id": "11666887", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-07-26T10:17:02.963", "LastEditorUserId": "1135819", "LastActivityDate": "2012-07-26T13:25:09.527", "Score": "2", "OwnerUserId": "457228", "Tags": "<c++><thread-safety><singleton>", "AnswerCount": "4"}, "11668820": {"Id": "11668820", "PostTypeId": "2", "Body": "<p>Unless you declare getInstance as static you won't be able to call it. This mistake has propagated almost to all replies. Other than this, I can't add anything better to all the answers.</p>\n", "LastEditorUserId": "1554554", "LastActivityDate": "2012-07-26T12:04:29.137", "Score": "2", "CreationDate": "2012-07-26T11:59:27.200", "ParentId": "11666887", "CommentCount": "0", "LastEditDate": "2012-07-26T12:04:29.137", "OwnerUserId": "1554554"}, "11668075": {"Id": "11668075", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_11666887_11668075_0\">In getInstance function (un-commented), static object's reference is returned. Does it requires thread-safe mechanism?</p>\n</blockquote>\n<p>As long as you don't access it outside the lifetime of the <code>main</code> function, or modify it when other threads might have unsynchronised access, then it's safe to access from any thread.</p>\n<p>If you do access before <code>main</code> starts or after it ends (e.g. from the constructor or destructor of another static object), then there is a danger that it won't have been initialised, or will already have been destroyed, at that point. That is the motivation for \"lazy initialisation\" such as your second version.</p>\n<blockquote>\n<p id=\"so_11666887_11668075_1\">In second getInstance (commented), we create the object if singleObject is null. So, it requires a locking mechanism and needs to be synchronized, right?</p>\n</blockquote>\n<p>Yes, that requires a locking mechanism. For compilers that support the C++11 (or similar) threading model, a simpler way to get lazy initialisation like this is to use a function-static variable, which will be initialised in a thread-safe way the first time it comes into scope:</p>\n<pre><code>S&amp; getInstance ()\n{\n    static S singleObject;\n    return singleObject;\n}\n</code></pre>\n<p>This will also avoid the memory leak of your version, but introduces a danger that it might be destroyed before other static objects; therefore, it's not safe to access from a static object's destructor.</p>\n<p>In general, static objects in C++ are a minefield of such deathtraps (whether or not you try to wrap them up in some kind of singleton anti-pattern) and are best avoided.</p>\n", "LastActivityDate": "2012-07-26T11:15:42.053", "Score": "2", "CreationDate": "2012-07-26T11:15:42.053", "ParentId": "11666887", "CommentCount": "0", "OwnerUserId": "204847"}, "bq_ids": {"n4140": {"so_11666887_11667596_0": {"length": 111, "quality": 0.9568965517241379, "section_id": 3919}}, "n3337": {"so_11666887_11667596_0": {"length": 111, "quality": 0.9568965517241379, "section_id": 3779}}, "n4659": {"so_11666887_11667596_0": {"length": 61, "quality": 0.5258620689655172, "section_id": 4805}}}, "11667596": {"Id": "11667596", "PostTypeId": "2", "Body": "<p>In C++11 you can place static instance inside a static function:</p>\n<pre><code>class S\n{\n    private:\n        S();\n        S(S const&amp;);\n        S&amp; operator=(S const&amp;);\n\n    public:\n        static S&amp; getInstance ()\n        {\n            static S singleObject;\n            return singleObject;\n        }\n};\n</code></pre>\n<p>According to paragraph 6.7.4 of the Standard:</p>\n<blockquote>\n<p id=\"so_11666887_11667596_0\">The zero-initialization (8.5) of all block-scope variables with static\n  storage duration (3.7.1) or thread storage duration (3.7.2) is\n  performed before any other initialization takes place. Constant\n  initialization (3.6.2) of a block-scope entity with static storage\n  duration, if applicable, is performed before its block is first\n  entered. An implementation is permitted to perform early\n  initialization of other block-scope variables with static or thread\n  storage duration under the same conditions that an implementation is\n  permitted to statically initialize a variable with static or thread\n  storage duration in namespace scope (3.6.2). Otherwise such a variable\n  is initialized the first time control passes through its declaration;\n  such a variable is considered initialized upon the completion of its\n  initialization. If the initialization exits by throwing an exception,\n  the initialization is not complete, so it will be tried again the next\n  time control enters the declaration. <strong>If control enters the declaration\n  concurrently while the variable is being initialized, the concurrent\n  execution shall wait for completion of the initialization.</strong> If\n  control re-enters the declaration recursively while the variable is\n  being initialized, the behavior is undefined.</p>\n</blockquote>\n", "LastActivityDate": "2012-07-26T10:44:14.897", "Score": "2", "CreationDate": "2012-07-26T10:44:14.897", "ParentId": "11666887", "CommentCount": "0", "OwnerUserId": "1554020"}, "11667350": {"Id": "11667350", "PostTypeId": "2", "Body": "<p>IIRC this is better for more than this reason. It won't initialize (thread safely) until getInstance is called.</p>\n<p>-edit- I remember some reasons now. You can't get access unless that method is called. You can call this in other class constructors and wont need to worry if S has been initialized or no. As in the other class may be constructed first in which case a crash or undefined behavior occurs.</p>\n<pre><code>//Singleton class\nclass S {\n  // intentionally avoided pointer\n\n   // Private constructor   \n   s ();\n   s (S &amp;);\n   s&amp; operator= (const s&amp;);\npublic:\n  // return reference of static object\n  s&amp; getInstance ()\n  {\n    static S singleObject;\n    return singleObject;\n  }\n};\n</code></pre>\n", "LastEditorDisplayName": "user34537", "OwnerDisplayName": "user34537", "LastActivityDate": "2012-07-26T13:25:09.527", "Score": "0", "CreationDate": "2012-07-26T10:27:19.960", "ParentId": "11666887", "CommentCount": "0", "LastEditDate": "2012-07-26T13:25:09.527"}});