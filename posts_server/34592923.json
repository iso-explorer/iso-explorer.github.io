post_cb({"bq_ids": {"n4140": {"so_34592923_34592975_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 380}}, "n3337": {"so_34592923_34592975_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 371}}, "n4659": {"so_34592923_34592975_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 395}}}, "34592923": {"ViewCount": "88", "Body": "<p>We are in a hot discussion with my friends about the code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nstring getString() {\n    return string(\"Hello, world!\");\n}\n\nint main() {\n    char const * str = getString().c_str();\n    std::cout &lt;&lt; str &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>\n<p>This code produces different outputs on g++, clang and vc++:</p>\n<p><code>g++</code> and <code>clang</code> output is the same:</p>\n<blockquote>\n<p id=\"so_34592923_34592923_0\">Hello, world!</p>\n</blockquote>\n<p>However <code>vc++</code> outputs nothing (or just spaces):</p>\n<blockquote>\n<p id=\"so_34592923_34592923_1\"></p>\n</blockquote>\n<p>What behavior is correct? Is this may be a change in standard according to temporaries lifetime ?</p>\n<p>As far as I can see by reading IR of <code>clang++</code>, it works as following:</p>\n<pre><code>store `getString()`'s return value in %1\nstd::cout &lt;&lt; %1.c_str() &lt;&lt; \"\\n\";\ndestruct %1\n</code></pre>\n<p>Personally, I think <code>gcc</code> works this way too (I've tested it with rvo/move verbosity (custom ctors and dtors which prints to <code>std::cout</code>). Why does vc++ works other way?</p>\n<p>clang = Apple LLVM version 6.1.0 (clang-602.0.53) (based on LLVM 3.6.0svn)</p>\n<p>g++ = gcc version 4.9.2 (Debian 4.9.2-10)</p>\n", "AcceptedAnswerId": "34593216", "Title": "Using of temporary lifetime difference", "CreationDate": "2016-01-04T14:04:52.177", "Id": "34592923", "CommentCount": "0", "LastEditDate": "2016-01-04T14:07:07.123", "PostTypeId": "1", "LastEditorUserId": "1750757", "LastActivityDate": "2016-01-04T20:21:30.457", "Score": "2", "OwnerUserId": "1750757", "Tags": "<c++>", "AnswerCount": "3"}, "34593216": {"Id": "34593216", "PostTypeId": "2", "Body": "<p>That is undefined behavior so anything can happen (including printing the string \"correctly\").</p>\n<p>Making things \"working\" anyway happens quite often with UB, unless the program is actually running on a paying customer's computer or if it's shown on the big screen in front of a vast audience ;-)</p>\n<p>The problem is that you're taking a <code>const char *</code> pointing inside a temporary object that is destroyed before your use of the pointer.</p>\n<p>Note that this is <strong>not</strong> the same situation as with:</p>\n<pre><code>const std::string&amp; str = getString(); // Returns a temporary\nstd::cout &lt;&lt; str &lt;&lt; \"\\n\";\n</code></pre>\n<p>because in this case instead there is a very specific rule about references bound to temporaries in the C++ standard. In this case the lifetime of the temporary will be extended until the reference <code>str</code> is also destroyed. The rule only applies to references and only if <strong>directly</strong> bound to the temporary or to a sub-object of the temporary (like <code>const std::string&amp; s = getObj().s;</code>) and not to the result of calling methods of a temporary object.</p>\n", "LastEditorUserId": "320726", "LastActivityDate": "2016-01-04T14:26:36.193", "Score": "5", "CreationDate": "2016-01-04T14:20:23.250", "ParentId": "34592923", "CommentCount": "3", "LastEditDate": "2016-01-04T14:26:36.193", "OwnerUserId": "320726"}, "34592975": {"Id": "34592975", "PostTypeId": "2", "Body": "<p>Both are right, undefined behaviour is undefined.</p>\n<pre><code>char const * str = getString().c_str();\n</code></pre>\n<p><code>getString()</code> returns a temporary, which will be destroyed at the end of the full expression which contains it. So after that line is finished, <code>str</code> is an invalid pointer and trying to inspect it will plunge you into the land of undefined behaviour.</p>\n<hr>\n<p>Some standards quotes, as requested (from N4140):</p>\n<blockquote>\n<p id=\"so_34592923_34592975_0\"><code>[class.temporary]/3:</code> Temporary objects are destroyed as the last step in evaluating the full-expression that (lexically) contains the point where they were created.</p>\n</blockquote>\n<p><code>basic_string::c_str</code> is specified like so:</p>\n<blockquote>\n<p id=\"so_34592923_34592975_1\"><code>[string.accessors]/1</code>: A pointer <code>p</code> such that <code>p + i == &amp;operator[](i)</code> for each <code>i</code> in <code>[0,size()]</code>.</p>\n</blockquote>\n<p>Since strings have their contents stored contiguously (<code>[string.require]/4</code>) this essentially means \"return a pointer to the start of the buffer\".</p>\n<p>Obviously when a <code>std::string</code> is destructed it will reclaim any memory which was allocated, making that pointer invalid (if your friends don't believe that, they have other problems). </p>\n</hr>", "LastEditorUserId": "496161", "LastActivityDate": "2016-01-04T20:21:30.457", "Score": "8", "CreationDate": "2016-01-04T14:07:33.667", "ParentId": "34592923", "CommentCount": "7", "LastEditDate": "2016-01-04T20:21:30.457", "OwnerUserId": "496161"}, "34592971": {"Id": "34592971", "PostTypeId": "2", "Body": "<p>Your program has undefined behaviour! You are \"printing\" a dangling pointer.</p>\n<p>The result of <code>getString()</code>, a temporary string, lives no longer than that <code>const char*</code> declaration; accordingly neither does the result of invoking <code>c_str()</code> on that temporary.</p>\n<p>So both compilers are \"correct\"; it is you and your friends who are wrong.</p>\n<p>This is why we shall not store the result of <code>std::string::c_str()</code>, unless we really, really need to.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2016-01-04T14:11:14.430", "Score": "8", "CreationDate": "2016-01-04T14:07:14.837", "ParentId": "34592923", "CommentCount": "4", "LastEditDate": "2016-01-04T14:11:14.430", "OwnerUserId": "560648"}});