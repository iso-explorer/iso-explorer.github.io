post_cb({"bq_ids": {"n4140": {"so_34646316_34646375_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 1617}}, "n3337": {"so_34646316_34646375_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 1613}}, "n4659": {"so_34646316_34646375_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 1770}}}, "34646316": {"ViewCount": "81", "Body": "<p>The implementation of <code>std::equal</code>, based on <a href=\"http://en.cppreference.com/w/cpp/algorithm/equal\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/algorithm/equal</a>, is the following:</p>\n<pre><code>    template&lt;class InputIt1, class InputIt2&gt;\n    bool equal(InputIt1 first1, InputIt1 last1, InputIt2 first2)\n    {\n        for (; first1 != last1; ++first1, ++first2) {\n            if (!(*first1 == *first2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n</code></pre>\n<p>When I compare <code>string str1 = \"abcd\"</code> against <code>string str2 = \"abc\"</code>, <code>equal(str1.begin(), str1.end(), str2.begin())</code>returns <code>false</code> as expected. Since <code>abcd</code> is one character longer, I wonder if the above implementation compared <code>'d'</code> against the <code>*str2.end()</code>. It seems like so, but isn't it unsafe? <code>str2.end()</code> may point to anything, and it might be <code>'d'</code>.   </p>\n", "AcceptedAnswerId": "34646375", "Title": "Does `std::equal` dereference the `end()` in the case `abcd` and `abc`?", "CreationDate": "2016-01-07T02:14:30.557", "Id": "34646316", "CommentCount": "10", "LastEditDate": "2016-01-07T02:37:46.690", "PostTypeId": "1", "LastEditorUserId": "1364752", "LastActivityDate": "2016-01-07T18:14:43.693", "Score": "3", "OwnerUserId": "1433675", "Tags": "<c++><stl>", "AnswerCount": "3"}, "34646375": {"Id": "34646375", "PostTypeId": "2", "Body": "<p>Assuming you're talking about <code>std::string</code> or <code>std::wstring</code>, and assuming that you're talking about strings (like the literals in your example) that don't contain embedded nulls. Then:</p>\n<p>Since C++11 dereferencing <code>end()</code> is in practice guaranteed to yield a null-char value also for non-<code>const</code> instance. And so the comparison stops there, because either it's different from the other string's value at this point, or it's the last iterator position.</p>\n\nC++11 \u00a721.4.5/2<br>\n<i>about <code>std::basic_string::operator[]</code></i>\n<blockquote>\n<p id=\"so_34646316_34646375_0\"><strong>\u201d</strong> <em>Returns</em>: <code>*(begin() + pos)</code> if <code>pos &lt; size()</code>, otherwise a reference to an object of type <code>T</code> with value <code>charT()</code>; the referenced value shall not be modified.</p>\n</blockquote>\n<p>There's a fine point here for language lawyers, that the null-value effect is defined for <code>operator[]</code>, which is defined in terms of iterators other than <code>end</code>, so that the <code>end</code> iterator in principle could be special cased.</p>\n<p>But that would clearly be contrary to the intention of providing C string semantics to the degree possible.</p>\n</br>", "LastEditorUserId": "464581", "LastActivityDate": "2016-01-07T03:08:44.960", "Score": "4", "CreationDate": "2016-01-07T02:23:49.213", "ParentId": "34646316", "CommentCount": "3", "OwnerUserId": "464581", "LastEditDate": "2016-01-07T03:08:44.960"}, "34662286": {"Id": "34662286", "PostTypeId": "2", "Body": "<p>Yes, it does.  Thats why in C++14, the committee added a \"four iterator\" version of <code>equal</code> (and <code>mismatch</code> and <code>is_permutation</code>).</p>\n<pre><code>equal(s1.begin(), s1.end(), s2.begin(), s2.end())\n</code></pre>\n<p>will not dereference <code>s2.end()</code> (and can quickly return false if the ranges are different sizes, to boot!)</p>\n", "LastActivityDate": "2016-01-07T18:14:43.693", "CommentCount": "0", "CreationDate": "2016-01-07T18:14:43.693", "ParentId": "34646316", "Score": "1", "OwnerUserId": "992490"}, "34646363": {"Id": "34646363", "PostTypeId": "2", "Body": "<p>In this case, you are comparing a five element array against a four element array (C-style and C++-style strings both have a terminating NUL character), and the fourth elements differ.</p>\n<p>If you instead had</p>\n<pre><code>char str1[4] = { 'a', 'b', 'c', 'd' };\n</code></pre>\n<p>and</p>\n<pre><code>char str2[3] = { 'a', 'b', 'c' };\n</code></pre>\n<p>then your call would perform a read beyond the bounds (undefined behavior).</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2016-01-07T02:35:48.730", "Score": "2", "CreationDate": "2016-01-07T02:22:05.447", "ParentId": "34646316", "CommentCount": "1", "OwnerUserId": "103167", "LastEditDate": "2016-01-07T02:35:48.730"}});