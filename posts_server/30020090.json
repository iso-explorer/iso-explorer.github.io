post_cb({"bq_ids": {"n4140": {"so_30020090_30020194_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 444}}, "n3337": {"so_30020090_30020194_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 435}}, "n4659": {"so_30020090_30020194_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 467}}}, "30020486": {"Id": "30020486", "PostTypeId": "2", "Body": "<p>Your question is legit but I think the module where <code>a</code> is built will be correctly static initialized before the instance of <code>b</code> will access it and this should be especially true if you build <code>a</code> in a different shared object and the class <code>B</code> has an explicit, non-circular dependency on the class <code>A</code>, as it is in your example. This can be also easily tested on deployment compilers/platforms.</p>\n<p>If you are still unconvinced, you should be able to force the inizialization of <code>a</code> before <code>b</code>with a free function <code>a()</code> as taught <a href=\"https://isocpp.org/wiki/faq/ctors#static-init-order-on-first-use\" rel=\"nofollow\">here</a> (<em>Construct On First Use</em> idiom):</p>\n<p>Header:</p>\n<pre><code>A&amp; a();\n</code></pre>\n<p>Compilation unit:</p>\n<pre><code>A&amp; a()\n{\n  static A _a;\n  return _a;\n}\n</code></pre>\n<p>Then you refer to <code>_a</code> with <code>a()</code>.</p>\n", "LastActivityDate": "2015-05-03T23:19:20.780", "CommentCount": "0", "CreationDate": "2015-05-03T23:19:20.780", "ParentId": "30020090", "Score": "0", "OwnerUserId": "213871"}, "30020194": {"Id": "30020194", "PostTypeId": "2", "Body": "<p>Yes, this can blow up (according to the standard, anyway), because <code>b</code>'s constructor can run before <code>a</code>'s, and then ([class.cdtor]/p1)...</p>\n<blockquote>\n<p id=\"so_30020090_30020194_0\">For an object with a non-trivial constructor, referring to any\n  non-static member or base class of the object before the constructor\n  begins execution results in undefined behavior.</p>\n</blockquote>\n", "LastActivityDate": "2015-05-03T22:38:23.680", "CommentCount": "5", "CreationDate": "2015-05-03T22:38:23.680", "ParentId": "30020090", "Score": "2", "OwnerUserId": "2756719"}, "30020090": {"ViewCount": "65", "Body": "<p>Is the following example legal and safe C++, or will it have a possibility of blowing up depending on what order the linker decides to invoke the global objects' constructors?</p>\n<p>a.hpp:</p>\n<pre><code>class A {\npublic:\n  A(int val_);\n  int val;\n};\n\nextern A a;\n</code></pre>\n<p>a.cpp:</p>\n<pre><code>#include \"a.hpp\"\n\nA::A(int val_) : val(val_) {}\n\nA a(1234);\n</code></pre>\n<p>b.cpp:</p>\n<pre><code>#include &lt;cassert&gt;\n#include \"a.hpp\"\n\nclass B {\npublic:\n  B(A &amp;a);\n  int &amp;ref;\n};\n\nB::B(A &amp;a) : ref(a.val) {}\n\nB b(a);\n\nint main(int argc, char **argv) {\n  assert(b.ref == 1234);\n  assert(&amp;b.ref == &amp;a.val);\n}\n</code></pre>\n<p>I need to do something like this in some real code I'm writing (obviously my A and B classes are much more complex than this minimal example, but the data members they need to share are plain old ints and bools) and I'd much rather use references than pointers.</p>\n", "AcceptedAnswerId": "30020194", "Title": "In C++, does the \"static initialization fiasco\" affect merely taking a reference to a data member of an object defined in another module?", "CreationDate": "2015-05-03T22:21:45.163", "Id": "30020090", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-05-03T23:19:20.780", "Score": "3", "OwnerUserId": "4860270", "Tags": "<c++>", "AnswerCount": "2"}});