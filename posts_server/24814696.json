post_cb({"24814998": {"ParentId": "24814696", "CommentCount": "2", "Body": "<p>As alternative to Praetorian's answer, you can use constructor delegate:</p>\n<pre><code>class C : public B {\npublic:\n    C(std::unique_ptr&lt;A&gt; a) :\n        C(a-&gt;x, std::move(a)) // this move doesn't nullify a.\n    {}\n\nprivate:\n    C(int x, std::unique_ptr&lt;A&gt;&amp;&amp; a) :\n        B(x, std::move(a)) // this one does, but we already have copied x\n    {}\n};\n</code></pre>\n", "OwnerUserId": "2684539", "PostTypeId": "2", "Id": "24814998", "Score": "28", "CreationDate": "2014-07-17T23:12:06.363", "LastActivityDate": "2014-07-17T23:12:06.363"}, "24814759": {"ParentId": "24814696", "CommentCount": "5", "Body": "<p>Use list initialization to construct <code>B</code>. The elements are then guaranteed to be evaluated from left to right.</p>\n<pre><code>C(std::unique_ptr&lt;A&gt; a) : B{a-&gt;x, std::move(a)} {}\n//                         ^                  ^ - braces\n</code></pre>\n<p>From <em>\u00a78.5.4/4 [dcl.init.list]</em></p>\n<blockquote>\n<p id=\"so_24814696_24814759_0\">Within the <em>initializer-list</em> of a <em>braced-init-list</em>, the <em>initializer-clauses</em>, including any that result from pack expansions (14.5.3), are evaluated in the order in which they appear. That is, every value computation and side effect associated with a given <em>initializer-clause</em> is sequenced before every value computation and side effect associated with any <em>initializer-clause</em> that follows it in the comma-separated list of the <em>initializer-list</em>.</p>\n</blockquote>\n", "OwnerUserId": "241631", "PostTypeId": "2", "Id": "24814759", "Score": "45", "CreationDate": "2014-07-17T22:47:24.630", "LastActivityDate": "2014-07-17T22:47:24.630"}, "24814950": {"ParentId": "24814696", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Praetorian's suggestion of using list initialization seems to work, but it has a few problems:</p>\n<ol>\n<li>If the unique_ptr argument comes first, we're out of luck</li>\n<li>Its way too easy for clients of <code>B</code> to accidentally forget to use <code>{}</code> instead of <code>()</code>. The designers of <code>B</code>'s interface has imposed this potential bug on us.</li>\n</ol>\n<p>If we could change B, then perhaps one better solution for constructors is to always pass unique_ptr by rvalue reference instead of by value.</p>\n<pre><code>struct A { int x; };\n\nclass B {\n  B(std::unique_ptr&lt;A&gt;&amp;&amp; a, int x) : _x(x), _a(std::move(a)) {}\n};\n</code></pre>\n<p>Now we can safely use std::move().</p>\n<pre><code>B b(std::move(a), a-&gt;x);\nB b{std::move(a), a-&gt;x};\n</code></pre>\n", "OwnerUserId": "2608582", "LastEditorUserId": "2608582", "LastEditDate": "2014-07-17T23:17:51.020", "Id": "24814950", "Score": "8", "CreationDate": "2014-07-17T23:07:31.813", "LastActivityDate": "2014-07-17T23:17:51.020"}, "24814696": {"CommentCount": "4", "ViewCount": "1999", "PostTypeId": "1", "LastEditorUserId": "1291990", "CreationDate": "2014-07-17T22:41:10.320", "LastActivityDate": "2014-07-18T02:56:32.317", "Title": "Move semantics and function order evaluation", "FavoriteCount": "9", "LastEditDate": "2014-07-18T02:56:32.317", "Id": "24814696", "Score": "44", "Body": "<p>Suppose I have the following:</p>\n<pre><code>#include &lt;memory&gt;\nstruct A { int x; };\n\nclass B {\n  B(int x, std::unique_ptr&lt;A&gt; a);\n};\n\nclass C : public B {\n  C(std::unique_ptr&lt;A&gt; a) : B(a-&gt;x, std::move(a)) {}\n};\n</code></pre>\n<p>If I understand the C++ rules about \"unspecified order of function parameters\" correctly, this code is unsafe. If the second argument to <code>B</code>'s constructor is constructed first using the move constructor, then <code>a</code> now contains a <code>nullptr</code> and the expression <code>a-&gt;x</code> will trigger undefined behavior (likely segfault). If the first argument is constructed first, then everything will work as intended.</p>\n<p>If this were a normal function call, we could just create a temporary:</p>\n<pre><code>auto x = a-&gt;x\nB b{x, std::move(a)};\n</code></pre>\n<p>But in the class initialization list we don't have the freedom to create temporary variables.</p>\n<p>Suppose I cannot change <code>B</code>, is there any possible way to accomplish the above? Namely dereferencing and moving a <code>unique_ptr</code> in the same function call expression without creating a temporary?</p>\n<p>What if you could change <code>B</code>'s constructor but not add new methods such as <code>setX(int)</code>? Would that help?</p>\n<p>Thank you</p>\n", "Tags": "<c++><c++11><initialization><move-semantics><unspecified-behavior>", "OwnerUserId": "2608582", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_24814696_24814759_0": {"section_id": 3326, "quality": 0.9428571428571428, "length": 33}}, "n3337": {"so_24814696_24814759_0": {"section_id": 3196, "quality": 0.9428571428571428, "length": 33}}, "n4659": {"so_24814696_24814759_0": {"section_id": 4092, "quality": 0.9428571428571428, "length": 33}}}});