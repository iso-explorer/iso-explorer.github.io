post_cb({"bq_ids": {"n4140": {"so_34659923_34660681_0": {"length": 16, "quality": 1.0, "section_id": 6324}, "so_34659923_34660570_0": {"length": 16, "quality": 1.0, "section_id": 6324}}, "n3337": {"so_34659923_34660681_0": {"length": 16, "quality": 1.0, "section_id": 6081}, "so_34659923_34660570_0": {"length": 16, "quality": 1.0, "section_id": 6081}}, "n4659": {"so_34659923_34660681_0": {"length": 16, "quality": 1.0, "section_id": 7834}, "so_34659923_34660570_0": {"length": 16, "quality": 1.0, "section_id": 7834}}}, "34660681": {"Id": "34660681", "PostTypeId": "2", "Body": "<p>That actually induces undefined behavior with current wording. At the point of instantiation of <code>std::initializer_list&lt;TypeInfo&gt;</code>, <code>TypeInfo</code> is incomplete, hence [res.on.functions]/(2.5) applies:</p>\n<blockquote>\n<p id=\"so_34659923_34660681_0\">In particular, the effects are undefined in the following cases: <br> (2.5)\n  \u2014 if an incomplete type (3.9) is used as a template argument when\n  instantiating a template component, unless specifically allowed for\n  that component.</br></p>\n</blockquote>\n<p>\u2026 and incomplete types are not specifically allowed for <code>initializer_list</code> yet - however, that's clearly defective. LWG <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2493\" rel=\"nofollow\"><strong>issue 2493</strong></a> opts to fix this:</p>\n<blockquote>\n<p id=\"so_34659923_34660681_1\">The typical use-case of <code>std::initializer_list&lt;T&gt;</code> is for a\n  pass-by-value parameter of <code>T</code>'s constructor. However, this contravenes\n  [res.on.functions]/2.5 because initializer_list doesn't specifically\n  allow incomplete types (as do for example <code>std::unique_ptr</code>\n  ([unique.ptr]/5) and <code>std::enable_shared_from_this</code>\n  ([util.smartptr.enab]/2)).</p>\n<p id=\"so_34659923_34660681_2\">A resolution would be to copy-paste the relevant text from such a\n  paragraph.</p>\n</blockquote>\n<p>I.e. your code is fine (and will be officially fine after resolution of the aforementioned DR).</p>\n", "LastActivityDate": "2016-01-07T16:46:58.387", "CommentCount": "5", "CreationDate": "2016-01-07T16:46:58.387", "ParentId": "34659923", "Score": "3", "OwnerUserId": "3647361"}, "34659923": {"ViewCount": "120", "Body": "<p>I am trying to model some meta data for serializing/de-serializing C++ objects.  Here is something that captures the nuts &amp; bolts of what I need; it compiles with GCC 5.2 (<code>g++ sample.cpp -std=c++14</code>) and with Clang 3.6 (<code>clang++ sample.cpp -std=c++14</code>).</p>\n<p>My question is about the <code>struct TypeInfo</code> in the example.  It contains an <code>std::initializer_list</code> of itself.  Is this standards-conforming?</p>\n<pre><code>#include &lt;cstdint&gt;\n#include &lt;initializer_list&gt;\n\nenum class TypeCode : std::uint8_t { BOOLEAN, INT, OBJECT, STRING, SENTINEL };\n\nstruct TypeInfo\n{\n    TypeCode typeCode_;\n\n    char fieldName_[64];\n\n    union\n    {\n        std::uint16_t textMinLength_;\n        std::uint16_t objectVersionMajor_;\n    };\n\n    union\n    {\n        std::uint16_t textMaxLength_;\n        std::uint16_t objectVersionMinor_;\n    };\n\n    //  set only if typeCode_ = OBJECT\n    std::initializer_list &lt; TypeInfo &gt; objectTypeInfos_;\n};\n\nint main()\n{\n    TypeInfo const sti { TypeCode::STRING, \"updatedBy\", { .textMinLength_ = 0 }, { .textMaxLength_ = 16 } };\n\n    TypeInfo const iti { TypeCode::INT, \"amount\", { 0 }, { 0 } };\n\n    TypeInfo const oti { TypeCode::OBJECT, \"startTime\", { .objectVersionMajor_ = 1 }, { .objectVersionMinor_ = 0 }, {\n      TypeInfo { TypeCode::INT, \"weekdays\", { 0 }, { 0 } },\n      TypeInfo { TypeCode::INT, \"timeOfDay\", { 0 }, { 0 } },\n      TypeInfo { TypeCode::STRING, \"timezone\", { .textMinLength_ = 0 }, { .textMaxLength_ = 5 } }\n    } };\n\n    TypeInfo const noti { TypeCode::OBJECT, \"schedule\", { .objectVersionMajor_ = 1 }, { .objectVersionMinor_ = 0 }, {\n      TypeInfo { TypeCode::INT, \"id\", { 0 }, { 0 } },\n      TypeInfo { TypeCode::STRING, \"description\", { .textMinLength_ = 0 }, { .textMaxLength_ = 16 } },\n      TypeInfo { TypeCode::OBJECT, \"startTime\", { .objectVersionMajor_ = 1 }, { .objectVersionMinor_ = 0 }, {\n        TypeInfo { TypeCode::INT, \"weekdays\", { 0 }, { 0 } },\n        TypeInfo { TypeCode::INT, \"timeOfDay\", { 0 }, { 0 } },\n        TypeInfo { TypeCode::STRING, \"timezone\", { .textMinLength_ = 0 }, { .textMaxLength_ = 5 } }\n      } }\n    } };\n}\n</code></pre>\n", "AcceptedAnswerId": "34660681", "Title": "Incomplete types and initializer_list", "CreationDate": "2016-01-07T16:11:37.433", "Id": "34659923", "CommentCount": "0", "LastEditDate": "2016-01-07T17:21:07.827", "PostTypeId": "1", "LastEditorUserId": "4850040", "LastActivityDate": "2016-01-07T17:21:07.827", "Score": "8", "OwnerUserId": "4532037", "Tags": "<c++><c++14>", "AnswerCount": "2"}, "34660570": {"Id": "34660570", "PostTypeId": "2", "Body": "<p>\u00a7 [res.on.functions]/2:</p>\n<blockquote>\n<p id=\"so_34659923_34660570_0\">In particular, the effects are undefined in the following cases:<br>\n  [...]<br>\n  (2.5) - if an incomplete type (3.9) is used as a template argument when instantiating a template component, unless specifically allowed for that component.</br></br></p>\n</blockquote>\n<p>I see no such specific allowance for <code>initializer_list</code> to be instantiated over an incomplete type (in either \u00a7[dcl.init.list] or \u00a7[support.init.list], at least as of N4296).</p>\n", "LastActivityDate": "2016-01-07T16:41:24.497", "CommentCount": "2", "CreationDate": "2016-01-07T16:41:24.497", "ParentId": "34659923", "Score": "2", "OwnerUserId": "179910"}});