post_cb({"22076038": {"CommentCount": "13", "AcceptedAnswerId": "22076139", "CreationDate": "2014-02-27T17:34:57.820", "LastActivityDate": "2014-02-27T17:44:16.593", "PostTypeId": "1", "ViewCount": "109", "FavoriteCount": "1", "Title": "here are more undefined behaviour in c++, sorry for this que[s]tion, but again UB", "Id": "22076038", "Score": "2", "Body": "<p>There is very simple UB example:</p>\n<pre><code>int i = 1;\ni = i++; // classic example of UB.\n</code></pre>\n<p>I recently saw, how to use Pascal style <code>inc</code> operation. <a href=\"https://github.com/ericniebler/range-v3\" rel=\"nofollow\">Eric Niebler github</a></p>\n<pre><code>// this structure little difference than original.\nstruct inc_t \n{   \n  template&lt; typename T&gt; \n  T operator()(T&amp; t ) const { return t++; } \n};\n\nconstexpr inc_t inc{};\n\n//usage\nint i = 1;\ninc(i);\n//or\nint j = inc(i);\n</code></pre>\n<p>So, combine :</p>\n<pre><code>int i = 1;\ni = inc(i); // Is there still UB ?\n</code></pre>\n<p>Thanks.</p>\n", "Tags": "<c++><c++11><language-lawyer><undefined-behavior>", "OwnerUserId": "2542308", "AnswerCount": "1"}, "22076139": {"ParentId": "22076038", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2014-02-27T17:39:04.443", "Score": "9", "LastEditorUserId": "481267", "LastEditDate": "2014-02-27T17:44:16.593", "Id": "22076139", "OwnerUserId": "481267", "Body": "<p><strong>No</strong>.</p>\n<p><code>i = i++</code> is UB because it's not specified when <code>i</code> is incremented; it could be at any point after the <em>value computation</em> of <code>i++</code> (<em>i.e.</em>, lvalue-to-rvalue conversion of <code>i</code>) and before the end of the full-expression. Therefore this write is unsequenced with respect to the assignment statement. Two unsequenced writes to the same <code>int</code> is undefined behaviour.</p>\n<p>But in <code>i = inc(i)</code> the incrementation of <code>i</code> occurs before the function returns, because the full-expression in which <code>t++</code> occurs lies inside the function. In turn, the function has to return before the value computation of the right-hand side, and the assignment is sequenced after the value computation of both sides. Therefore the incrementation of <code>i</code> is sequenced before the assignment, and there is no UB.</p>\n<p>Relevant quotes from the C++11 standard:</p>\n<p>\u00a71.9/14</p>\n<blockquote>\n<p id=\"so_22076038_22076139_0\">Every value computation and side effect associated with a full-expression is sequenced before every value\n   computation and side effect associated with the next full-expression to be evaluated.</p>\n</blockquote>\n<p>\u00a75.17/1</p>\n<blockquote>\n<p id=\"so_22076038_22076139_1\">In all cases, the assignment is sequenced after the value\n  computation of the right and left operands, and before the value computation of the assignment expression.</p>\n</blockquote>\n", "LastActivityDate": "2014-02-27T17:44:16.593"}, "bq_ids": {"n4140": {"so_22076038_22076139_1": {"section_id": 6173, "quality": 1.0, "length": 15}, "so_22076038_22076139_0": {"section_id": 5810, "quality": 1.0, "length": 18}}, "n3337": {"so_22076038_22076139_1": {"section_id": 5934, "quality": 1.0, "length": 15}, "so_22076038_22076139_0": {"section_id": 5583, "quality": 1.0, "length": 18}}, "n4659": {"so_22076038_22076139_1": {"section_id": 7675, "quality": 1.0, "length": 15}, "so_22076038_22076139_0": {"section_id": 7271, "quality": 1.0, "length": 18}}}});