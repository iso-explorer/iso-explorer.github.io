post_cb({"29987683": {"ParentId": "29987192", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><code>std::function&lt;void(const T)&gt;</code> can be value-constructed with <code>*callback</code>. The problem is <code>Call</code> is a function template. The compiler is unable to automatically instantiate <code>void Call(const int yyy, const Callback&lt;int&gt;&amp; callback)</code> from <code>Call(111, *callback);</code>, since it does not match the call. Conversion is necessary to call the instantiation with <code>Call(111, *callback);</code>. But automatic template argument deduction does not consider such conversions. It considers exact match only. You could manually instantiate it though. So, one way to correct your code would be changing</p>\n<pre><code>Call(111, *callback);  // expected output is \"0 \\t 111\"\nCall(222, *callback);  // expected output is \"1 \\t 222\"\n</code></pre>\n<p>to</p>\n<pre><code>Call&lt;int&gt;(111, *callback);  // expected output is \"0 \\t 111\"\nCall&lt;int&gt;(222, *callback);  // expected output is \"1 \\t 222\"\n</code></pre>\n<p>As such, a temporary <code>std::function&lt;void(const T)&gt;</code> if first value-constructed with <code>*callback</code>. The function parameter <code>const Callback&lt;int&gt;&amp; callback</code> in <code>Call</code> is then bound to this temporary. Again, this is all about conversion. The function signature is not an exact match for the call.</p>\n", "OwnerUserId": "1348273", "LastEditorUserId": "1348273", "LastEditDate": "2015-05-01T13:39:10.650", "Id": "29987683", "Score": "4", "CreationDate": "2015-05-01T13:24:30.117", "LastActivityDate": "2015-05-01T13:39:10.650"}, "29988572": {"ParentId": "29987192", "CommentCount": "0", "Body": "<p>From [temp.arg.explicit]:</p>\n<blockquote>\n<p id=\"so_29987192_29988572_0\">Implicit conversions (Clause 4) will be performed on a function argument to convert it to the type of the\n  corresponding function parameter <strong>if the parameter type contains no template-parameters that participate\n  in template argument deduction.</strong> <em>[ Note:</em> Template parameters do not participate in template argument\n  deduction if they are explicitly specified. For example,</p>\n<pre><code>template&lt;class T&gt; void f(T);\n\nclass Complex {\n    Complex(double);\n};\n\nvoid g() {\n    f&lt;Complex&gt;(1); // OK, means f&lt;Complex&gt;(Complex(1))\n}\n</code></pre>\n<p id=\"so_29987192_29988572_1\"><em>\u2014end note ]</em></p>\n</blockquote>\n<p>In your case, <code>const Callback&lt;T&gt;&amp;</code> does contain a <em>template-parameter</em> that participates in template argument deduction, so no implicit conversion (i.e. <code>MyCallback&lt;int&gt;</code> to <code>std::function&lt;void(const int)&gt;</code>) is allowed.</p>\n<p>In order to use <code>std::function</code>, you'd have to have the <code>callback</code> argument not participate in any template argument deduction. That is:</p>\n<pre><code>Call&lt;int&gt;(111, *callback); // no argument deduction done here\n</code></pre>\n<p>Alternatively, you could just deduce <code>callback</code> itself, no type-erasure necessary:</p>\n<pre><code>template &lt;typename T, typename F&gt;\nvoid Call(const T yyy, F&amp;&amp; callback) {\n    callback(yyy);\n}\n</code></pre>\n<p>Lastly, if you really want the type erasure, you could manually construct your <code>Callback</code> internally to <code>Call</code>:</p>\n<pre><code>template &lt;typename T, typename F&gt;\nvoid Call(const T yyy, F&amp;&amp; f) {\n    Callback&lt;T&gt; callback(std::forward&lt;F&gt;(f));\n    callback(yyy);\n}\n</code></pre>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "29988572", "Score": "2", "CreationDate": "2015-05-01T14:17:34.997", "LastActivityDate": "2015-05-01T14:17:34.997"}, "29987192": {"CommentCount": "5", "AcceptedAnswerId": "29988229", "PostTypeId": "1", "LastEditorUserId": "2513489", "CreationDate": "2015-05-01T12:53:22.863", "LastActivityDate": "2015-05-01T15:52:24.297", "LastEditDate": "2015-05-01T13:09:56.620", "ViewCount": "853", "FavoriteCount": "2", "Title": "Pass template functor to a template std::function", "Id": "29987192", "Score": "3", "Body": "<p>Here is a code snippet:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;memory&gt;\n\ntemplate &lt;typename T&gt;\nusing Callback = std::function&lt;void(const T)&gt;;\n\ntemplate &lt;typename T&gt;\nvoid Call(const T yyy, const Callback&lt;T&gt;&amp; callback) {\n    callback(yyy);\n}\n\ntemplate &lt;typename T&gt;\nclass MyCallback {\npublic:\n    explicit MyCallback(const T counter_init) : counter_{counter_init} {}\n    void operator ()(const T xxx) {\n        std::cout &lt;&lt; counter_ &lt;&lt; '\\t' &lt;&lt; xxx &lt;&lt; std::endl;\n        ++counter_;\n    }\nprivate:\n    T counter_;\n};\n\nint main() {\n    const auto callback = std::make_unique&lt;MyCallback&lt;int&gt;&gt;(0);\n    Call(111, *callback);  // expected output is \"0 \\t 111\"\n    Call(222, *callback);  // expected output is \"1 \\t 222\"\n    return 0;\n}\n</code></pre>\n<p>Clang says it couldn't match <em>std::function</em> against <em>MyCallback</em> and g++ is thinks that <em>MyCallback</em> is derived from <em>Callback</em>.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/16a09080b6035b85\" rel=\"nofollow\">clang++ -std=c++14 main.cpp &amp;&amp; ./a.out</a></p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/c38ef371ff02161e\" rel=\"nofollow\">g++ -std=c++14 main.cpp &amp;&amp; ./a.out</a></p>\n<p>The easiest way I know that will fix this issue is to use template instead of <em>Callback</em>, so that <em>Call</em> will be defined in the following manner:</p>\n<pre><code>template &lt;typename T, typename F&gt;\nvoid Call(const T yyy, F&amp;&amp; callback) {\n    callback(yyy);\n}\n</code></pre>\n<p>But it would be unclear for the next developer which signature does <em>callback</em> has.</p>\n<p>Can some one clarify what is going on in the first example from compiler point of view and how can I fix this without applying hack I described above?</p>\n", "Tags": "<c++><templates><c++11><c++14>", "OwnerUserId": "2513489", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_29987192_29988572_0": {"section_id": 289, "quality": 0.9375, "length": 30}}, "n3337": {"so_29987192_29988572_0": {"section_id": 280, "quality": 0.9375, "length": 30}}, "n4659": {"so_29987192_29988572_0": {"section_id": 296, "quality": 0.9375, "length": 30}}}, "29988229": {"ParentId": "29987192", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Change <code>Call</code> to:</p>\n<pre><code>template &lt;class T, class F,\n  class R=typename std::result_of&lt;F&amp;(const T&amp;)&gt;::type\n&gt;\nvoid Call(const T&amp; yyy, F&amp;&amp; f) {\n  f(yyy);\n}\n</code></pre>\n<p>now we invoke <code>f</code> on <code>yyy</code>, and (assuming you have a C++11 compiler that implements SFINAE safe <code>result_of</code>) the overload only works if you can call <code>f</code> on <code>yyy</code>.</p>\n<p><code>std::function</code> is not a generic callable.  It is a way to type-erase callables down to \"being called with a given signature\", copy the callable, and destroy the callable.</p>\n<p>Type-erasure and type-deduction are opposite operations.  Doing both in one step is usually a sign of a design flaw.  <code>std::function</code> should only extremely rarely be deduced from the signature of a passed-in callable.</p>\n<p>Instead, determine how you are going to use a given function.  Then type-erase down to that use signature, or just test against that use signature and don't type-erase at all.</p>\n<p>If you have multiple possible use-signatures, test against each of them, tag dispatch to the right type-erasure path, and type erase there.</p>\n<p>The <code>result_of</code> clause is optional, but it improves error messages significantly.  It also makes the error detectible \"early\" as a failed overload, instead of as a hard error.  The <code>result_of</code> clause can be converted to a <code>static_assert</code> in the body that would generate an even clearer error message, but that would fail \"late\" after overload resolution.</p>\n<p>An alternative approach, that blocks deduction on the <code>function</code>, is:</p>\n<pre><code>template&lt;class T&gt;struct tag{using type=T;};\ntemplate&lt;class Tag&gt;using type_t=typename Tag::type;\ntemplate&lt;class T&gt;using block_deduction=type_t&lt;tag&lt;T&gt;&gt;;\n\ntemplate &lt;typename T&gt;\nusing Callback = block_deduction&lt;std::function&lt;void(const T)&gt;&gt;;\n</code></pre>\n<p>and now</p>\n<pre><code>template &lt;class T&gt;\nvoid Call(const T&amp; yyy, const Callback&lt;T&gt;&amp; callback) {\n  callback(yyy);\n}\n</code></pre>\n<p>works.  It still erases the <code>callback</code> type needlessly (with the resulting overhead).</p>\n<p>Deduction is blocked by round-tripping through a <code>struct</code> and getting the <code>::type</code>.  Under the standard, such dependent types are never deduced.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2015-05-01T15:52:24.297", "Id": "29988229", "Score": "4", "CreationDate": "2015-05-01T13:57:00.020", "LastActivityDate": "2015-05-01T15:52:24.297"}});