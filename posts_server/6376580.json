post_cb({"6376699": {"Id": "6376699", "PostTypeId": "2", "Body": "<p>Is this what you're looking for:</p>\n<p>\u00a73.10/7</p>\n<blockquote>\n<p id=\"so_6376580_6376699_0\">Whenever an lvalue appears in a context where an rvalue is expected, the lvalue is converted to an rvalue; see 4.1, 4.2, and 4.3.</p>\n</blockquote>\n<p>And I think when you write <code>int y = x</code>, it basically copies the <em>value</em> contained in the object <code>x</code> which is a lvalue, but the <em>value</em> itself is an rvalue, hence the context expects an rvalue. </p>\n<p>\u00a74.1/2 says,</p>\n<blockquote>\n<p id=\"so_6376580_6376699_1\">The value contained in the object indicated by the lvalue is the rvalue result.</p>\n</blockquote>\n<p>Maybe these two quotations clarify your doubt. Correct me if my understanding is wrong. I would like to learn <em>new</em> things.</p>\n<hr>\n<p>@Tomalak's  comment:</p>\n<blockquote>\n<p id=\"so_6376580_6376699_2\">My problem with this is that int&amp; y = x; is valid, so in this case of course x may not be an rvalue. I don't know how irrelevant the difference in my example makes that, though</p>\n</blockquote>\n<p>Well <code>int &amp;y = x</code> does NOT copy the value. It just creates an alias of the object itself. But as I previously said <code>int y = x</code>, basically <strong>copies</strong> the <em>value</em> which is an rvalue. Hence, the context expects an rvalue, as a copying is being done here.</p>\n</hr>", "LastEditorUserId": "415784", "LastActivityDate": "2011-06-16T18:35:16.743", "Score": "1", "CreationDate": "2011-06-16T18:22:50.493", "ParentId": "6376580", "CommentCount": "7", "OwnerUserId": "415784", "LastEditDate": "2011-06-16T18:35:16.743"}, "6377011": {"Id": "6377011", "PostTypeId": "2", "Body": "<p>The initializer has the follwing grammar:</p>\n<pre><code>initializer:\n        = initializer-clause\n        ( expression-list )\n\ninitializer-clause:\n    assignment-expression\n    { initializer-list ,opt }\n    { }\n</code></pre>\n<p>In your example, <code>x</code> is an <code>assignment-expression</code> which  follows this chain of grammar productions:</p>\n<pre><code>conditional-expression  ==&gt;\n    logical-or-expression ==&gt;\n        logical-and-expression  ==&gt;\n            inclusive-or-expression  ==&gt;\n                exclusive-or-expression  ==&gt;\n                    and-expression  ==&gt;\n                        equality-expression  ==&gt;\n                            relational-expression  ==&gt;\n                                shift-expression  ==&gt;\n                                    additive-expression  ==&gt;\n                                        multiplicative-expression  ==&gt;\n                                            pm-expression  ==&gt;\n                                                cast-expression  ==&gt;\n                                                    unary-expression  ==&gt;\n                                                        postfix-expression  ==&gt;\n                                                            primary-expression  ==&gt; \n                                                                id-expression  ==&gt;\n                                                                    unqualified-id  ==&gt;\n                                                                        identifier\n</code></pre>\n<p>And an identifier \"is an lvalue if the entity is a function or variable\" (5.1/4 \"Primary expressions\").</p>\n<p>So in your example, the expression to the right of the <code>=</code> is an expression that happens to be an <code>lvalue</code>.  It could be an <code>rvalue</code> of course, but it doesn't have to be.  And there is no mandated lvalue-to-rvalue conversion.</p>\n<p>I'm not sure what the value in knowing this is, though.</p>\n", "LastActivityDate": "2011-06-16T18:50:58.593", "CommentCount": "1", "CreationDate": "2011-06-16T18:50:58.593", "ParentId": "6376580", "Score": "2", "OwnerUserId": "12711"}, "bq_ids": {"n4140": {"so_6376580_6376764_9": {"length": 25, "quality": 0.9615384615384616, "section_id": 7234}, "so_6376580_6376699_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 7231}, "so_6376580_6376743_0": {"length": 5, "quality": 0.625, "section_id": 9}, "so_6376580_6376764_6": {"length": 8, "quality": 0.7272727272727273, "section_id": 7231}, "so_6376580_6376764_13": {"length": 17, "quality": 1.0, "section_id": 7238}, "so_6376580_6376699_1": {"length": 5, "quality": 0.625, "section_id": 9}, "so_6376580_6376764_1": {"length": 4, "quality": 0.8, "section_id": 3321}, "so_6376580_6376764_14": {"length": 67, "quality": 0.9710144927536232, "section_id": 7239}, "so_6376580_6376764_11": {"length": 17, "quality": 1.0, "section_id": 7236}, "so_6376580_6376743_1": {"length": 11, "quality": 1.0, "section_id": 3296}, "so_6376580_6376764_4": {"length": 14, "quality": 0.6086956521739131, "section_id": 7230}, "so_6376580_6376875_2": {"length": 11, "quality": 1.0, "section_id": 3296}, "so_6376580_6376764_12": {"length": 14, "quality": 0.875, "section_id": 7237}, "so_6376580_6376875_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 7231}, "so_6376580_6376764_3": {"length": 17, "quality": 0.6071428571428571, "section_id": 7230}, "so_6376580_6376764_7": {"length": 11, "quality": 0.7857142857142857, "section_id": 7232}, "so_6376580_6376764_10": {"length": 8, "quality": 1.0, "section_id": 7235}, "so_6376580_6376875_0": {"length": 25, "quality": 0.6410256410256411, "section_id": 6030}}, "n3337": {"so_6376580_6376764_9": {"length": 25, "quality": 0.9615384615384616, "section_id": 6978}, "so_6376580_6376699_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 6975}, "so_6376580_6376764_4": {"length": 14, "quality": 0.6086956521739131, "section_id": 6974}, "so_6376580_6376764_6": {"length": 8, "quality": 0.7272727272727273, "section_id": 6975}, "so_6376580_6376764_13": {"length": 17, "quality": 1.0, "section_id": 6982}, "so_6376580_6376699_1": {"length": 5, "quality": 0.625, "section_id": 6}, "so_6376580_6376764_1": {"length": 4, "quality": 0.8, "section_id": 2}, "so_6376580_6376764_14": {"length": 67, "quality": 0.9710144927536232, "section_id": 6983}, "so_6376580_6376764_11": {"length": 17, "quality": 1.0, "section_id": 6980}, "so_6376580_6376764_10": {"length": 8, "quality": 1.0, "section_id": 6979}, "so_6376580_6376743_0": {"length": 5, "quality": 0.625, "section_id": 6}, "so_6376580_6376875_0": {"length": 33, "quality": 0.8461538461538461, "section_id": 2}, "so_6376580_6376875_2": {"length": 11, "quality": 1.0, "section_id": 3166}, "so_6376580_6376764_12": {"length": 14, "quality": 0.875, "section_id": 6981}, "so_6376580_6376875_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 6975}, "so_6376580_6376764_3": {"length": 17, "quality": 0.6071428571428571, "section_id": 6974}, "so_6376580_6376743_1": {"length": 11, "quality": 1.0, "section_id": 3166}, "so_6376580_6376764_7": {"length": 11, "quality": 0.7857142857142857, "section_id": 6976}, "so_6376580_6376764_8": {"length": 23, "quality": 0.8518518518518519, "section_id": 6977}}, "n4659": {"so_6376580_6376699_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 8743}, "so_6376580_6376743_0": {"length": 5, "quality": 0.625, "section_id": 10}, "so_6376580_6376764_6": {"length": 8, "quality": 0.7272727272727273, "section_id": 8743}, "so_6376580_6376764_13": {"length": 9, "quality": 0.5294117647058824, "section_id": 8747}, "so_6376580_6376699_1": {"length": 5, "quality": 0.625, "section_id": 10}, "so_6376580_6376764_1": {"length": 4, "quality": 0.8, "section_id": 4040}, "so_6376580_6376764_14": {"length": 67, "quality": 0.9710144927536232, "section_id": 8748}, "so_6376580_6376764_4": {"length": 12, "quality": 0.5217391304347826, "section_id": 8741}, "so_6376580_6376875_0": {"length": 22, "quality": 0.5641025641025641, "section_id": 5}, "so_6376580_6376875_2": {"length": 11, "quality": 1.0, "section_id": 4058}, "so_6376580_6376743_1": {"length": 11, "quality": 1.0, "section_id": 4058}, "so_6376580_6376875_1": {"length": 8, "quality": 0.7272727272727273, "section_id": 8743}, "so_6376580_6376764_7": {"length": 11, "quality": 0.7857142857142857, "section_id": 8745}}}, "6376743": {"Id": "6376743", "PostTypeId": "2", "Body": "<p>I find it easier (if maybe not 100% precise) to think of lvalue-s as real objects and rvalue-s as the value stored in the object. The expression <code>x</code> is an lvalue expression that refers to the object <code>x</code> defined in the first line, but when used as the right hand side of an assignment to a type that is not a user defined type the actual <em>value</em> is read, and that is where the conversion from lvalue to rvalue is performed: reading the contents of the object.</p>\n<p>As to the specific clause in the standard that dictates that conversion... well, the closest that I can think is 4.1 [conv.lvalue]/2 (Lvalue to Rvalue conversion):</p>\n<blockquote>\n<p id=\"so_6376580_6376743_0\">The value contained in the object indicated by the lvalue is the rvalue result.</p>\n</blockquote>\n<p>The requirement that the right hand side of the assignment is an rvalue is either implicit or missing from 5.17 [expr.ass], but that is the case or else the following expression would be an error since the rhs is an rvalue and there is no rvalue-to-lvalue conversion:</p>\n<pre><code>int x = 5;\n</code></pre>\n<p>EDIT: For initialization, 8.5 [dcl.init]/14, last bullet (which refers to fundamental types) states (emphasis mine):</p>\n<blockquote id=\"so_6376580_6376743_1\">\n<ul>\n<li>Otherwise, the initial value of the object being initialized is the (possibly converted) <strong>value</strong> of the initializer expression. [...]</li>\n</ul>\n</blockquote>\n<p>That <em>value</em> there means that the lvalue expression in your example is <em>read</em> (i.e. converted to an rvalue). At any rate the previous paragraph that referred to assignment could be applied here: if initialization required an <em>lvalue</em> rather than an <em>rvalue</em>, the expression <code>int i = 0;</code> would be ill-formed.</p>\n", "LastEditorUserId": "36565", "LastActivityDate": "2011-06-17T07:28:34.600", "Score": "7", "CreationDate": "2011-06-16T18:25:28.263", "ParentId": "6376580", "CommentCount": "5", "OwnerUserId": "36565", "LastEditDate": "2011-06-17T07:28:34.600"}, "6376580": {"ViewCount": "531", "Body": "<p>Given:</p>\n<pre><code>int main() {\n   int x = 0;\n   int y = x; // &lt;---\n}\n</code></pre>\n<p>Could someone please tell me which clause of the standard (2003 preferred) mandates the conversion of the expression <code>x</code> from <em>lvalue</em> to <em>rvalue</em> in the initialisation of the object <code>y</code>?</p>\n<p>(Or, if I'm mistaken and no such conversion takes place, then I'd like to learn that too!)</p>\n", "AcceptedAnswerId": "6376743", "Title": "What standard clause mandates this lvalue-to-rvalue conversion?", "CreationDate": "2011-06-16T18:12:43.887", "Id": "6376580", "CommentCount": "9", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2011-06-17T14:03:12.137", "Score": "7", "OwnerUserId": "560648", "Tags": "<c++>", "AnswerCount": "5"}, "6376764": {"Id": "6376764", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_6376580_6376764_0\">3.10 Lvalues and rvalues</p>\n<p id=\"so_6376580_6376764_1\">1 Every expression is either an lvalue\n  or an rvalue.</p>\n<p id=\"so_6376580_6376764_2\">2 An lvalue refers to an object or\n  function. Some rvalue\n  expressions\u2014those of class or\n  cvqualified class type\u2014also refer to\n  objects.47)</p>\n<p id=\"so_6376580_6376764_3\">3 [Note: some builtin operators and\n  function calls yield lvalues.\n  [Example: if E is an expression of\n  pointer type, then *E is an lvalue\n  expression referring to the object or\n  function to which E points. As another\n  example, the function int&amp; f(); yields\n  an lvalue, so the call f() is an\n  lvalue expression. ] </p>\n<ol>\n<li>[Note: some builin operators expect lvalue operands. [Example: builtin\n  assignment operators all expect their\n  left hand operands to be lvalues. ]\n  Other builtin operators yield rvalues,\n  and some expect them. [Example: the\n  unary and binary + operators expect\n  rvalue arguments and yield rvalue\n  results. ] The discussion of each\n  builtin operator in clause 5 indicates\n  whether it expects lvalue operands and\n  whether it yieldsan lvalue. ]</li>\n</ol>\n<p id=\"so_6376580_6376764_4\">5 The result of calling a function\n  that does not return a reference is an\n  rvalue. User defined operators are\n  functions, and whether such operators\n  expect or yield lvalues is determined\n  by their parameter and return types.</p>\n<p id=\"so_6376580_6376764_5\">6 An expression which holds a\n  temporary object resulting from a cast\n  to a nonreference type is an rvalue\n  (this includes the explicit creation\n  of an object using functional notation\n  (5.2.3)).</p>\n<p id=\"so_6376580_6376764_6\"><strong>7 Whenever an lvalue appears in a context where an rvalue is expected,\n  the lvalue is converted to an rvalue;\n  see 4.1, 4.2, and 4.3.</strong></p>\n<p id=\"so_6376580_6376764_7\">8 The discussion of reference\n  initialization in 8.5.3 and of\n  temporaries in 12.2 indicates the\n  behavior of lvalues and rvalues in\n  other significant contexts.</p>\n<p id=\"so_6376580_6376764_8\">9 Class rvalues can have cvqualified\n  types; nonclass rvalues always have\n  cvunqualified types. Rvalues shall\n  always have complete types or the void\n  type; in addition to these types,\n  lvalues can also have incomplete\n  types.</p>\n<p id=\"so_6376580_6376764_9\">10 An lvalue for an object is\n  necessary in order to modify the\n  object except that an rvalue of class\n  type can also be used to modify its\n  referent under certain circumstances.\n  [Example: a member function called for\n  an object (9.3) can modify the object.\n  ]</p>\n<p id=\"so_6376580_6376764_10\">11 Functions cannot be modified, but\n  pointers to functions can be\n  modifiable.</p>\n<p id=\"so_6376580_6376764_11\">12 A pointer to an incomplete type can\n  be modifiable. At some point in the\n  program when the pointed to type is\n  complete, the object at which the\n  pointer points can also be modified.</p>\n<p id=\"so_6376580_6376764_12\">13 The referent of a constqualified\n  expression shall not be modified\n  (through that expression), except that\n  if it is of class type and has a\n  mutable component, that component can\n  be modified (7.1.5.1).</p>\n<p id=\"so_6376580_6376764_13\">14 If an expression can be used to\n  modify the object to which it refers,\n  the expression is called modifiable. A\n  program that attempts to modify an\n  object through a nonmodifiable lvalue\n  or rvalue expression is illformed.</p>\n<p id=\"so_6376580_6376764_14\">15 If a program attempts to access the\n  stored value of an object through an\n  lvalue of other than one of the\n  following types the behavior is\n  undefined48): \u2014 the dynamic type of\n  the object, \u2014 a cvqualified version of\n  the dynamic type of the object, \u2014 a\n  type that is the signed or unsigned\n  type corresponding to the dynamic type\n  of the object, \u2014 a type that is the\n  signed or unsigned type corresponding\n  to a cvqualified version of the\n  dynamic type of the object, \u2014 an\n  aggregate or union type that includes\n  one of the aforementioned types among\n  its members (including, recursively, a\n  member of a subaggregate or contained\n  union), \u2014 a type that is a (possibly\n  cvqualified) base class type of the\n  dynamic type of the object, \u2014 a char\n  or unsigned char type.</p>\n</blockquote>\n", "LastEditorUserId": "560648", "LastActivityDate": "2011-06-16T18:28:51.873", "Score": "1", "CreationDate": "2011-06-16T18:27:24.293", "ParentId": "6376580", "CommentCount": "0", "OwnerUserId": "731433", "LastEditDate": "2011-06-16T18:28:51.873"}, "6376875": {"Id": "6376875", "PostTypeId": "2", "Body": "<p>I <em>do</em> believe that this is intuitive to some degree (what others already said - the <em>value</em> is needed, so there is an obvious need to convert the object designator to the value contained therein). The best I could come up with, by 4p3:</p>\n<blockquote>\n<p id=\"so_6376580_6376875_0\">An expression e can be implicitly converted to a type T if and only if the declaration \"T t=e;\" is well-formed, for some invented temporary variable t (8.5). The effect of the implicit conversion is the same as performing the declaration and initialization and then using the temporary variable as the result of the conversion. <em>The result is an lvalue if T is a reference type (8.3.2), and an rvalue otherwise. The expression e is used as an lvalue if and only if the initialization uses it as an lvalue.</em> </p>\n</blockquote>\n<p>Note the \"if and only if\" at the end - the initializer therefor is used as an <em>rvalue</em>, because the initialization uses it as an rvalue (result of the conversion). So by 3.10p7</p>\n<blockquote>\n<p id=\"so_6376580_6376875_1\">Whenever an lvalue appears in a context where an rvalue is expected, the lvalue is converted to an rvalue; see 4.1, 4.2, and 4.3.</p>\n</blockquote>\n<hr>\n<p>EDIT: The paragraph for entering 4p3 can be found at 8.5p16, last bullet:</p>\n<blockquote>\n<p id=\"so_6376580_6376875_2\">Otherwise, the initial value of the object being initialized is the (possibly converted) value of the initializer expression. </p>\n</blockquote>\n<p>Also note the comments below.</p>\n</hr>", "LastEditorUserId": "34509", "LastActivityDate": "2011-06-17T14:03:12.137", "Score": "7", "CreationDate": "2011-06-16T18:37:51.987", "ParentId": "6376580", "CommentCount": "5", "OwnerUserId": "34509", "LastEditDate": "2011-06-17T14:03:12.137"}});