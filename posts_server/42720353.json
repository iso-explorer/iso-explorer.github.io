post_cb({"42721669": {"ParentId": "42720353", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>To clarify the difference between mencpy and memove, according to the <a href=\"http://en.cppreference.com/w/cpp/string/byte/memmove\" rel=\"nofollow noreferrer\">docs</a>\nmemmove can copy memory to a location that overlaps the source memory, for memcpy this is undefined behavior.</p>\n<p>\"<strong><em>The objects may overlap: copying takes place as if the characters were copied to a temporary character array and then the characters were copied from the array to dest.</em></strong>\"</p>\n<blockquote>\n<p id=\"so_42720353_42721669_0\">Is there a Standard C++ type-safe wrapper for the times you need memcpy? (I can't count the number of times I forgot to multiply by sizeof.)</p>\n</blockquote>\n<p>Yes, std::copy (maybe, explained below)</p>\n<blockquote>\n<p id=\"so_42720353_42721669_1\">If there's nothing in the standard, have there been any proposals for this? If not, why not?</p>\n</blockquote>\n<p>As far as i know the standard does not enforce the usage of memmove/memcpy for std::copy for trivial types. So it's up the implementation. For example in <a href=\"https://www.visualstudio.com/en-us/news/releasenotes/vs2017-relnotes\" rel=\"nofollow noreferrer\">visual studio update 2015 update 2 they did use memmove to speed things up</a>:</p>\n<p>\"<strong><em>Increased the speed of std::vector reallocation and std::copy(); they are up to 9x faster as they call memmove() for trivially copyable types (including user-defined types).</em></strong>\"</p>\n<blockquote>\n<p id=\"so_42720353_42721669_2\">Are there any specific obstacles in providing a memcpy wrapper that does the sizeof multiplication automatically?</p>\n</blockquote>\n<p>No, in fact you can implement this yourself by using <a href=\"http://en.cppreference.com/w/cpp/types/is_trivial\" rel=\"nofollow noreferrer\">std::is_trivial</a></p>\n<p>Edit:</p>\n<p>According to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3690.pdf\" rel=\"nofollow noreferrer\">this document</a> section 25.3.1 there are no restrictions to std::copy implementation only complexity:</p>\n<blockquote>\n<p id=\"so_42720353_42721669_3\">Complexity: Exactly last - first assignments.</p>\n</blockquote>\n<p>And this makes perfect sense when you consider that memcpy uses cpu speciffic instruction (that are not available on all cpus) to speed up memory copy.</p>\n", "OwnerUserId": "498424", "LastEditorUserId": "498424", "LastEditDate": "2017-03-15T10:32:15.113", "Id": "42721669", "Score": "1", "CreationDate": "2017-03-10T15:11:48.710", "LastActivityDate": "2017-03-15T10:32:15.113"}, "bq_ids": {"n4140": {"so_42720353_42721669_3": {"section_id": 1289, "quality": 0.8, "length": 4}}, "n3337": {"so_42720353_42721669_3": {"section_id": 1284, "quality": 0.8, "length": 4}}, "n4659": {"so_42720353_42721669_3": {"section_id": 1411, "quality": 0.8, "length": 4}}}, "42720353": {"CommentCount": "6", "ViewCount": "183", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2017-03-10T14:09:55.910", "LastActivityDate": "2017-03-15T12:26:15.120", "Title": "Type-Safe C++ wrapper for memcpy?", "LastEditDate": "2017-05-23T12:32:06.453", "Id": "42720353", "Score": "3", "Body": "<p>Given that <a href=\"http://en.cppreference.com/w/cpp/algorithm/copy\" rel=\"nofollow noreferrer\"><code>std::copy</code></a> (for Trivial Types obviously) can only be implemented as a wrapper around <a href=\"http://en.cppreference.com/w/cpp/string/byte/memmove\" rel=\"nofollow noreferrer\">memmove</a>(*), I'm wondering:</p>\n<ul>\n<li>Is there a Standard C++ type-safe wrapper for the times you need <code>memcpy</code>? (I can't count the number of times I forgot to multiply by <code>sizeof</code>.)</li>\n<li>If there's nothing in the standard, have there been any proposals for this? If not, why not?</li>\n<li>Are there any specific obstacles in providing a <code>memcpy</code> wrapper that does the <code>sizeof</code> multiplication automatically?</li>\n</ul>\n<hr>\n<p>(*): C++ Standard Library implementations (from back MSVC 2005(!) up to modern MSVC2015, libc++ etc.) decay <code>std::copy</code> TriviallyCopyable types to <code>memmove</code>. Bot <strong>not</strong> to <code>memcpy</code>. Because:</p>\n<ul>\n<li><p><code>std::copy(src_first, src_last, destination_first)</code> defines that:</p>\n<blockquote>\n<p id=\"so_42720353_42720353_0\">The behavior is undefined if <code>d_first</code> is within the range <code>[first, last)</code>.</p>\n</blockquote>\n<ul>\n<li>Only the <em>beginning</em> of the destination range MUST NOT be within the target range. The destination range <em>is allowed</em> to extend into the destination range. That is, <code>d_first</code> can be \"to the left\" of the source range, and the target range can extend into the source range.</li>\n</ul></li>\n<li><p>For <code>std::memcpy</code> the definition is that</p>\n<blockquote>\n<p id=\"so_42720353_42720353_1\">If the objects overlap, the behavior is undefined.</p>\n</blockquote>\n<ul>\n<li>That is, the full ranges must not overlap: This is what allows memcpy to be the fastest variant, because it can just assume that the memory of source and destination is completely disjoint.</li>\n</ul></li>\n<li><p>For <code>std::memmove</code>, the definition is:</p>\n<blockquote>\n<p id=\"so_42720353_42720353_2\">The objects may overlap: copying takes place as if the characters were copied to a temporary character array and then the characters were copied from the array to dest.</p>\n</blockquote>\n<ul>\n<li>That is, the source and destination range may arbitrarily overlap, there is no restriction.</li>\n</ul></li>\n</ul>\n<p>Given this, it is clear that you can use <code>std::memove</code> to implement <code>std::copy</code> for TrivialllyCopyable types, because memmove doesn't impose any restrictions and the dispatch to the correct implementation can be done at compile time via type traits --</p>\n<p>but it's hard to implement <code>std::copy</code> in terms of <code>memcpy</code> because (a) the check whether the pointer ranges overlap would have to be done <em>at run time</em>, and (b) even implementing the runtime check for unrelated memory ranges <a href=\"https://stackoverflow.com/q/4657976/321013\">could be quite a mess</a>.</p>\n<p>So, this leaves us with </p>\n<pre><code>void* memcpy( void* dest, const void* src, std::size_t count );\n</code></pre>\n<p>a function with a less than stellar interface, where you constantly need to multiply the input count of non-char objects with their <code>sizeof</code> and that is totally untyped.</p>\n<p>But memcpy is fastest (and by quite a margin, measure it yourself), and when you need fast copies of TriviallyCopyable types, you reach for memcpy. Which <em>superficially</em> should be easy to wrap in a type safe wrapper like:</p>\n<pre><code>template&lt;typename T&gt;\nT* trivial_copy(T* dest, T* src, std::size_t n) {\n    return static_cast&lt;T*&gt;(std::memcpy(dest, src, sizeof(T) * n));\n}\n</code></pre>\n<p>but then, it's unclear wether you should do compile time checks via <code>std::is_trival</code> or somesuch and of course there may be some discussion whether to go with the exact <code>memcpy</code> signature order, yadda yadda.</p>\n<p>So do I really have to reinvent this wheel myself? Was it discussed for the standard? Etc.</p>\n<hr>\n</hr></hr>", "Tags": "<c++><memcpy>", "OwnerUserId": "321013", "AnswerCount": "1"}});