post_cb({"bq_ids": {"n4140": {"so_48188737_48189117_2": {"length": 65, "quality": 0.8904109589041096, "section_id": 7193}, "so_48188737_48189117_1": {"length": 19, "quality": 0.5428571428571428, "section_id": 5913}}, "n3337": {"so_48188737_48189117_2": {"length": 61, "quality": 0.8356164383561644, "section_id": 6937}, "so_48188737_48189117_1": {"length": 19, "quality": 0.5428571428571428, "section_id": 5685}}, "n4659": {"so_48188737_48189117_2": {"length": 67, "quality": 0.9178082191780822, "section_id": 8702}, "so_48188737_48189117_1": {"length": 33, "quality": 0.9428571428571428, "section_id": 7404}, "so_48188737_48189117_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 8697}}}, "48189117": {"Id": "48189117", "PostTypeId": "2", "Body": "<p>Writing <code>return short_str+15;</code>, you take the address of an object whose lifetime may have not started, but this does not result in undefined behavior unless you dereference it.</p>\n<blockquote>\n<h3><a href=\"https://timsong-cpp.github.io/cppwp/n4659/basic.life#1.2\" rel=\"nofollow noreferrer\"><code>[basic.life]/1.2</code></a></h3>\n<p id=\"so_48188737_48189117_0\">if the object is a union member or subobject thereof,\n  its lifetime only begins if that union member is the initialized\n  member in the union, or as described in <code>[class.union]</code>.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<h3><a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.union#1\" rel=\"nofollow noreferrer\"><code>[class.union]/1</code></a></h3>\n<p id=\"so_48188737_48189117_1\">In a union, a non-static data member is active if its\n  name refers to an object whose lifetime has begun and has not ended\n  (<code>[basic.life]</code>). At most one of the non-static data members of an object of\n  union type can be active at any time, that is, the value of at most\n  one of the non-static data members can be stored in a union at any\n  time.</p>\n</blockquote>\n<p>but</p>\n<blockquote>\n<h3><a href=\"https://timsong-cpp.github.io/cppwp/n4659/basic.life#6\" rel=\"nofollow noreferrer\"><code>[basic.life]/6</code></a></h3>\n<p id=\"so_48188737_48189117_2\">Before the lifetime of an object has started but after the storage which the \n  object will occupy has been allocated or, after the lifetime of an\n  object has ended and before the storage which the object occupied is\n  reused or released, any pointer that represents the address of the\n  storage location where the object will be or was located may be used\n  but only in limited ways. For an object under construction or\n  destruction, see <code>[class.cdtor]</code>. Otherwise, such a pointer refers to allocated\n  storage (<code>[basic.stc.dynamic.allocation]</code>), and using the pointer as if the pointer were of\n  type void* , is well-defined. Indirection through such a pointer is\n  permitted but the resulting lvalue may only be used in limited ways,\n  as described below.<br>\n  - [list unrelated to unions]</br></p>\n</blockquote>\n", "LastEditorUserId": "5470596", "LastActivityDate": "2018-01-10T14:09:51.343", "Score": "5", "CreationDate": "2018-01-10T14:01:03.723", "ParentId": "48188737", "CommentCount": "5", "OwnerUserId": "5470596", "LastEditDate": "2018-01-10T14:09:51.343"}, "48188737": {"ViewCount": "248", "Body": "<p>Let's consider this example code:</p>\n<pre><code>struct sso\n{\n    union {\n        struct {\n            char* ptr;\n            char size_r[8];\n        } large_str;\n        char short_str[16];\n    };\n\n    const char* get_tag_ptr() const {\n        return short_str+15;\n    }\n};\n</code></pre>\n<p>In <a href=\"https://timsong-cpp.github.io/cppwp/n4659/expr.add#4\" rel=\"nofollow noreferrer\">[basic.expr]</a> it is specified that pointer arithmetic is allowed as long as the result points to another element of the array (or past the end of an object or of the last element). Nevertheless it is not specified in this setion what happens if the array is an inactive member of a union. I believe it is not an issue <code>short_str+15</code> is never UB. Is it right?</p>\n<p><sub> <a href=\"https://stackoverflow.com/questions/48189026/using-stdlaunder-to-get-a-pointer-to-an-active-object-member-from-a-pointer-to\">The following question</a> clearly showes my intent</sub></p>\n", "AcceptedAnswerId": "48189117", "Title": "Is pointer arithmetic on inactive member of a union UB?", "CreationDate": "2018-01-10T13:40:05.607", "LastActivityDate": "2018-01-10T14:09:51.343", "CommentCount": "9", "LastEditDate": "2018-01-10T14:01:24.323", "PostTypeId": "1", "LastEditorUserId": "5632316", "Id": "48188737", "Score": "8", "OwnerUserId": "5632316", "Tags": "<c++><c++11><language-lawyer><pointer-arithmetic>", "AnswerCount": "1"}});