post_cb({"bq_ids": {"n4140": {"so_1424261_1424314_1": {"length": 23, "quality": 0.92, "section_id": 641}, "so_1424261_1424314_0": {"length": 38, "quality": 0.926829268292683, "section_id": 641}}, "n3337": {"so_1424261_1424314_1": {"length": 23, "quality": 0.92, "section_id": 631}, "so_1424261_1424314_0": {"length": 38, "quality": 0.926829268292683, "section_id": 631}}, "n4659": {"so_1424261_1424314_1": {"length": 23, "quality": 0.92, "section_id": 669}, "so_1424261_1424314_0": {"length": 35, "quality": 0.8536585365853658, "section_id": 669}}}, "1424261": {"ViewCount": "1146", "Body": "<p>I'm having a minor issue dealing with pointers to overloaded member functions in C++. The following code compiles fine:</p>\n<pre><code>class Foo {\npublic:\n    float X() const;\n    void X(const float x);\n    float Y() const;\n    void Y(const float y);\n};\n\nvoid (Foo::*func)(const float) = &amp;Foo::X;\n</code></pre>\n<p>But this doesn't compile (the compiler complains that the overloads are ambiguous):</p>\n<pre><code>void (Foo::*func)(const float) = (someCondition ? &amp;Foo::X : &amp;Foo::Y);\n</code></pre>\n<p>Presumably this is something to do with the compiler sorting out the return value of the conditional operator separately from the function pointer type? I can work around it, but I'm interested to know how the spec says all this is supposed to work since it seems a little unintuitive and if there's some way to work around it without falling back to 5 lines of if-then-else.</p>\n<p>I'm using MSVC++, if that makes any difference.</p>\n<p>Thanks!</p>\n", "AcceptedAnswerId": "1424314", "Title": "Conditional operator can't resolve overloaded member function pointers", "CreationDate": "2009-09-14T22:42:32.190", "Id": "1424261", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-06-27T13:27:15.057", "LastEditorUserId": "96780", "LastActivityDate": "2013-06-27T13:27:15.057", "Score": "5", "OwnerUserId": "22517", "Tags": "<c++><function-pointers><conditional-operator>", "AnswerCount": "3"}, "1424280": {"Id": "1424280", "PostTypeId": "2", "Body": "<p>Example:</p>\n<pre><code>class Foo {\npublic:\n    void X(float x) {}\n    void Y(float y)  {}\n    float X() const;\n};\ntypedef void (Foo::*Fff)(float);\nFff func = &amp;Foo::X;\nFff func2 = true ? (Fff)&amp;Foo::X : (Fff)&amp;Foo::Y;\n\nint main(){\n    return 0;\n}\n</code></pre>\n<p>You need to cast &amp;Foo::X immediately in order to resolve the overload.  Note that if you comment out the overloaded float X(), you don't need to do so.</p>\n<p>It looks like the compiler isn't smart enough to infer the required return type of a ternary expression (this may be a bug).</p>\n", "LastEditorUserId": "12711", "LastActivityDate": "2009-09-15T00:40:29.340", "Score": "1", "CreationDate": "2009-09-14T22:51:58.633", "ParentId": "1424261", "CommentCount": "2", "LastEditDate": "2009-09-15T00:40:29.340", "OwnerUserId": "123862"}, "1424321": {"Id": "1424321", "PostTypeId": "2", "Body": "<p>Try:</p>\n<pre><code>    void (Foo::*func1)(const float) = &amp;Foo::X;\n    void (Foo::*func2)(const float) = &amp;Foo::Y;\n\n    void (Foo::*func3)(const float) = (someCondition ? func1:func2);\n</code></pre>\n<p>The problem is the result type of the operator trinary is determined by its arguments.<br>\nIn this situation it can not determine the result type because the input types has multuiple options. It is not until the type of the trinary operator has been determined that it will attempt the assignment. </br></p>\n", "LastActivityDate": "2009-09-14T23:05:05.747", "Score": "1", "CreationDate": "2009-09-14T23:05:05.747", "ParentId": "1424261", "CommentCount": "0", "OwnerUserId": "14065"}, "1424314": {"Id": "1424314", "PostTypeId": "2", "Body": "<p>From section 13.4/1 (\"Address of overloaded function,\" [over.over]):</p>\n<blockquote>\n<p id=\"so_1424261_1424314_0\">A use of an overloaded function name without arguments is resolved in certain contexts to a function, a pointer to function or pointer to member function for a specific function from the overload set. A function template name is considered to name a set of overloaded functions in such contexts. The function selected is the one whose type matches the target type required in the context. The target can be</p>\n<ul>\n<li>an object or reference being initialized (8.5, 8.5.3),</li>\n<li>the left side of an assignment (5.17),</li>\n<li>a parameter of a function (5.2.2),</li>\n<li>a parameter of a user-defined operator (13.5),</li>\n<li>the return value of a function, operator function, or conversion (6.6.3), or</li>\n<li>an explicit type conversion (5.2.3, 5.2.9, 5.4).</li>\n</ul>\n<p id=\"so_1424261_1424314_1\">The overload function name can be preceded by the <code>&amp;</code> operator. An overloaded function name shall not be used without arguments in contexts other than those listed. [<em>Note:</em> any redundant set of parentheses surrounding the overloaded function name is ignored (5.1). ]</p>\n</blockquote>\n<p>The <em>target</em> you were hoping would be selected from the above list was the first one, an object being initialized. But there's a conditional operator in the way, and conditional operators determine their types from their operands, not from any target type.</p>\n<p>Since explicit type conversions are included in the list of targets, you can type-cast each member-pointer expression in the conditional expression separately. I'd make a typedef first:</p>\n<pre><code>typedef void (Foo::* float_func)(const float);\nfloat_func func = (someCondition ? float_func(&amp;Foo::X) : float_func(&amp;Foo::Y));\n</code></pre>\n", "LastActivityDate": "2009-09-14T23:02:03.413", "Score": "7", "CreationDate": "2009-09-14T23:02:03.413", "ParentId": "1424261", "CommentCount": "1", "OwnerUserId": "33732"}});