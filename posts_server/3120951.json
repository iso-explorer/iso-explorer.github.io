post_cb({"3120951": {"CommentCount": "3", "CreationDate": "2010-06-25T19:46:17.337", "PostTypeId": "1", "AcceptedAnswerId": "3120974", "LastEditorUserId": "129413", "LastActivityDate": "2010-06-25T20:10:51.810", "LastEditDate": "2010-06-25T19:52:16.573", "ViewCount": "803", "FavoriteCount": "1", "Title": "g++ template problem", "Id": "3120951", "Score": "6", "Body": "<p>I'm porting my c++ windows code (msvc &amp; intel) to Linux (g++). The code uses lots of templates (I like metaprogramming ;-). But I can't compile this code:</p>\n<pre><code>template &lt;class TA&gt;\nstruct A\n{\n    template &lt;class TAB&gt; struct B;\n};\n\n\ntemplate &lt;class TC&gt;\nstruct C {};\n\n\ntemplate &lt;class TD&gt;\nstruct D\n{\n    template &lt;class TTD&gt; class T {};\n};\n\n\ntemplate&lt;class TA&gt;\n    template&lt;class TBA&gt;\nstruct A&lt;TA&gt;::B : C&lt;typename D&lt;TA&gt;::T&lt;TBA&gt; &gt;\n{\n    int foo;\n};\n</code></pre>\n<p>g++ tells me that in definition of A::B, C class has invalid template arguments. But on msvc and intel it works well! What's the problem here?\nPS: Sorry, I can't post the original code, because it's too template-complicated. But this example is virtually the same and gives the same error on g++.\nThank you.</p>\n<p>UPDATE: I've found the problem is in TBA argument of T. g++ doensn't like usage of second template in the definition.</p>\n", "Tags": "<c++><templates><g++><porting>", "OwnerUserId": "129413", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_3120951_3120974_0": {"section_id": 70, "quality": 0.9090909090909091, "length": 10}, "so_3120951_3120974_1": {"section_id": 72, "quality": 0.8620689655172413, "length": 25}}, "n3337": {"so_3120951_3120974_0": {"section_id": 65, "quality": 0.9090909090909091, "length": 10}, "so_3120951_3120974_1": {"section_id": 67, "quality": 0.8620689655172413, "length": 25}}, "n4659": {"so_3120951_3120974_0": {"section_id": 72, "quality": 0.9090909090909091, "length": 10}}}, "3120974": {"ParentId": "3120951", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>You need the <code>template</code> keyword </p>\n<pre><code>template&lt;class TA&gt;\n    template&lt;class TBA&gt;\nstruct A&lt;TA&gt;::B : C&lt;typename D&lt;TA&gt;::template T&lt;TBA&gt; &gt;\n{\n    int foo;\n};\n</code></pre>\n<p>GCC is correct to give a diagnostic here. This is because <code>T</code> cannot be looked up in the dependent scope <code>D&lt;TA&gt;</code>. The meaning of the <code>&lt;</code> after it depends on whether <code>T</code> is a template or not. The Standard says that <code>T</code> shall be assumed to be not a template and thus <code>T</code> cannot be followed by a template argument list.</p>\n<p><code>template</code> is like <code>typename</code> in that it tells the compiler to treat <code>T</code> as a template and that the <code>&lt;</code> is the start of an argument list in any case. The Standard says in paragraphs <code>14.2/2</code> and <code>14.2/4</code></p>\n<blockquote>\n<p id=\"so_3120951_3120974_0\">For a template-name to be explicitly qualified by the template arguments, the name must be known to refer\n  to a template.</p>\n<p id=\"so_3120951_3120974_1\">When the name of a member template specialization appears after . or -&gt; in a postfix-expression, or after nested-name-specifier in a qualified-id, and the postfix-expression or qualified-id explicitly depends on a template-parameter (14.6.2), the member template name must be prefixed by the keyword template. Otherwise the name is assumed to name a non-template. </p>\n</blockquote>\n<p>In your case, you have <code>T</code> appear after the nested-name-specifier <code>D&lt;TA&gt;</code> which depends on the template-parameter <code>TA</code>. For the typename-specifier to parse correctly, the construct <code>D&lt;TA&gt;::T&lt;TBA&gt;</code> must interpret <code>T</code> as the name of a class template, which <code>14.2</code> forbids. </p>\n<hr>\n<p>On that topic, it's always a good idea to try and compile with <a href=\"http://clang.llvm.org/index.html\" rel=\"nofollow noreferrer\">Clang</a></p>\n<pre><code>main1.cpp:21:37: error: use 'template' keyword to treat 'T' as a dependent template name\nstruct A&lt;TA&gt;::B : C&lt;typename D&lt;TA&gt;::T&lt;TBA&gt; &gt;\n                                    ^\n                                    template \n1 error generated.\n</code></pre>\n</hr>", "OwnerUserId": "34509", "LastEditorUserId": "34509", "LastEditDate": "2010-06-25T20:10:51.810", "Id": "3120974", "Score": "10", "CreationDate": "2010-06-25T19:49:42.847", "LastActivityDate": "2010-06-25T20:10:51.810"}});