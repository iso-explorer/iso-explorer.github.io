post_cb({"13593281": {"Id": "13593281", "PostTypeId": "2", "Body": "<p>Depends on your actual type <code>T</code>. It might be initialized with zeros under certain conditions. See here: <a href=\"https://stackoverflow.com/questions/6251707/default-initialization-in-c\">Default initialization in C++</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-11-27T21:20:45.800", "Score": "3", "CreationDate": "2012-11-27T21:20:45.800", "ParentId": "13593165", "CommentCount": "1", "OwnerUserId": "1756636", "LastEditDate": "2017-05-23T11:56:11.990"}, "13593696": {"Id": "13593696", "PostTypeId": "2", "Body": "<p>It will not be initialized (still calling the constructor if T is a class, of course). To force value-initialization (which is a name that to newbies can be misleading - let's call it zero-initialization which it is for primitive types like <code>int</code>), do</p>\n<pre><code>new T[N]()\n</code></pre>\n<p>That is, just put a pair of parenthesis. </p>\n", "LastActivityDate": "2012-11-27T21:45:52.517", "CommentCount": "0", "CreationDate": "2012-11-27T21:45:52.517", "ParentId": "13593165", "Score": "4", "OwnerUserId": "34509"}, "bq_ids": {"n4140": {"so_13593165_13593507_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 3286}, "so_13593165_13593507_3": {"length": 5, "quality": 1.0, "section_id": 3286}, "so_13593165_13593507_0": {"length": 9, "quality": 1.0, "section_id": 6098}, "so_13593165_13593507_1": {"length": 4, "quality": 1.0, "section_id": 3286}}, "n3337": {"so_13593165_13593507_2": {"length": 13, "quality": 1.0, "section_id": 3156}, "so_13593165_13593507_3": {"length": 5, "quality": 1.0, "section_id": 3156}, "so_13593165_13593507_0": {"length": 9, "quality": 1.0, "section_id": 5864}, "so_13593165_13593507_1": {"length": 4, "quality": 1.0, "section_id": 3156}}, "n4659": {"so_13593165_13593507_2": {"length": 9, "quality": 0.6923076923076923, "section_id": 4049}, "so_13593165_13593507_3": {"length": 5, "quality": 1.0, "section_id": 4048}, "so_13593165_13593507_0": {"length": 9, "quality": 1.0, "section_id": 7595}}}, "13593165": {"ViewCount": "243", "Body": "<p>In C++11 when I allocate a dynamic array using <code>T *array = new T[n];</code> it's <strong>already zeroed</strong> (using gcc 4.7.2, Ubuntu 12.10 64bit).</p>\n<ol>\n<li>Is this forced by the C++11 specification?</li>\n<li>How can one allocate an array without zeroing its items? This should be probably a little bit faster.</li>\n</ol>\n<p><strong>Edit:</strong> I've checked that for <code>T = int</code>.</p>\n<p><strong>gcc cxx-flags</strong>: <code>-std=gnu++11 -O3 -ffast-math -fno-rtti</code></p>\n", "AcceptedAnswerId": "13593507", "Title": "Allocated array already zeroed", "CreationDate": "2012-11-27T21:13:26.743", "Id": "13593165", "CommentCount": "4", "LastEditDate": "2012-11-27T21:19:26.220", "PostTypeId": "1", "LastEditorUserId": "684534", "LastActivityDate": "2012-11-27T21:45:52.517", "Score": "4", "OwnerUserId": "684534", "Tags": "<c++><memory-management><c++11>", "AnswerCount": "4"}, "13593507": {"Id": "13593507", "PostTypeId": "2", "Body": "<p>\u00a7 5.3.4</p>\n<blockquote>\n<p id=\"so_13593165_13593507_0\">If the new-initializer is omitted, the object is default-initialized (8.5); if no initialization is performed,\n   the object has indeterminate value.</p>\n</blockquote>\n<p>new-initializer is the <code>()</code> in <code>new T[] ()</code>, which you have omitted.</p>\n<p>\u00a7 8.5 / 6</p>\n<blockquote>\n<p id=\"so_13593165_13593507_1\">To default-initialize an object of type T means:</p>\n<p id=\"so_13593165_13593507_2\">\u2014 if T is a (possibly cv-qualified) class type (Clause 9), the default constructor for T is called (and the\n  initialization is ill-formed if T has no accessible default constructor);</p>\n<p id=\"so_13593165_13593507_3\">\u2014 if T is an array type, each element is default-initialized;</p>\n<p id=\"so_13593165_13593507_4\">\u2014 otherwise, no initialization is performed.</p>\n</blockquote>\n<p>int[] is default initialized -&gt; each element is default-initialized.</p>\n<p>\"Is this forced by the C++11 specification?\": \"no initialization is performed\", so no, zeroing is not forced if T has no zeroing constructor (i.e. T is a POD). For T=int, no zeroing has to be performed.</p>\n<p>Why is it zero anyway? If your program allocates new memory from the operating system, the OS zeroes the new memory for you. It would be very dangerous, if you could read memory of another program, which possibly stores sensible data.  However, if you write into that memory, free it and allocate some of it again, it should not be zeroed.</p>\n", "LastEditorUserId": "1176973", "LastActivityDate": "2012-11-27T21:45:07.700", "Score": "6", "CreationDate": "2012-11-27T21:36:05.010", "ParentId": "13593165", "CommentCount": "0", "OwnerUserId": "1176973", "LastEditDate": "2012-11-27T21:45:07.700"}, "13593560": {"Id": "13593560", "PostTypeId": "2", "Body": "<p>Even if you can use a C++ feature to dynamically allocate uninitialized memory (<code>std::get_temporary_buffer</code>?), the underlying implementation of <code>malloc()</code> and <code>::new</code> in your OS's libc is to use an anonymous <code>mmap()</code> for <em>large</em> allocation blocks (where <em>large</em> is a tunable). And anonymous <code>mmap()</code> are always zero initialized.</p>\n", "LastActivityDate": "2012-11-27T21:39:00.567", "CommentCount": "1", "CreationDate": "2012-11-27T21:39:00.567", "ParentId": "13593165", "Score": "2", "OwnerUserId": "22985"}});