post_cb({"31433911": {"ViewCount": "198", "Body": "<p>With g++-5 I get the following output</p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;tuple&gt;\nint main()\n{\n  bool b;\n  b = std::is_default_constructible&lt;int&gt;::value; //Compiles, returns true\n  b = std::is_default_constructible&lt;int&amp;&gt;::value; //Compiles, returns false\n  b = std::is_default_constructible&lt; std::tuple&lt;int&gt; &gt;::value; //Compiles, returns true\n  b = std::is_default_constructible&lt; std::tuple&lt;int&amp;&gt; &gt;::value; //Does not compile\n}\n</code></pre>\n<p>Is this a bug in <code>is_default_constructible</code>'s implementation ?</p>\n<p>The error message is a long stack list ending in:</p>\n<pre><code>/usr/bin/../lib/gcc/x86_64-linux-gnu/5.1.0/../../../../include/c++/5.1.0/tuple:105:9: error: reference to type 'int' requires an initializer\n  : _M_head_impl() { }\n</code></pre>\n", "AcceptedAnswerId": "31438404", "Title": "Error when checking if a tuple of references is default constructible", "CreationDate": "2015-07-15T14:56:31.020", "Id": "31433911", "CommentCount": "9", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-10-13T16:14:35.267", "LastEditorUserId": "3204551", "LastActivityDate": "2015-10-13T16:14:35.267", "Score": "7", "OwnerUserId": "3559888", "Tags": "<c++><c++11><std><c++14><stdtuple>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31433911_31438404_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 2604}}, "n3337": {"so_31433911_31438404_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 2567}}, "n4659": {"so_31433911_31438404_0": {"length": 6, "quality": 0.6666666666666666, "section_id": 4924}}}, "31438404": {"Id": "31438404", "PostTypeId": "2", "Body": "<p>This is <strong>not</strong> a bug in <code>is_default_constructible</code>. That type trait is only required to check the immediate context of default construction, it doesn't have to deeply evaluate any member initializers. This restriction is probably so that it can be implemented without dedicated compiler magic by using SFINAE. (see [meta.unary.prop], esp. p7).</p>\n<p>The <code>tuple</code> and <code>pair</code> default constructors were not required to fail in the immediate context (SFINAE-friendly) if the element type can't be default-constructed. This has been addressed by <a href=\"http://cplusplus.github.io/LWG/lwg-active.html#2367\" rel=\"nofollow noreferrer\">LWG 2367</a>, which introduces the following SFINAE requirement for the <code>tuple</code> default constructor:</p>\n<blockquote>\n<p id=\"so_31433911_31438404_0\"><em>Remarks:</em> This constructor shall not participate in overload resolution\n  unless <code>is_default_constructible&lt;Ti&gt;::value</code> is true for all <code>i</code>. [...]</p>\n</blockquote>\n<p>With this additional requirement, default construction of a tuple must fail in a SFINAE-friendly way, such that <code>is_default_constructible</code> now works for <code>tuple</code> if the elements fail to be default-constructed in the immediate context (which is the case for reference types).</p>\n<p>LWG 2367 is currently in <em>Ready</em> status; the proposed resolution has not (yet) been incorporated into the github drafts.</p>\n<hr>\n<p>[-- this part is still under consideration</p>\n<p><a href=\"https://stackoverflow.com/users/1774667/yakk\">Yakk</a> raised an important point in the comments: Why does <code>is_default_constructible</code> have to deeply instantiate the member initializers?</p>\n<p>As far as I can tell, this has to do with the <em>conditional <code>constexpr</code>'iveness</em> of <code>tuple</code>'s default constructor. <code>is_default_constructible</code> causes the instantiation of the default constructor. It only needs to instantiate the declaration in order to determine whether or not this constructor can be called without failures in the <em>immediate context</em>. However, the instantiation of the declaration requires determining the <code>constexpr</code>'iveness, and this causes the instantiation of the definition of the constructor.</p>\n<p>A member function (or constructor) of a class template which has been marked as <code>constexpr</code> is only conditionally <code>constexpr</code>: only the member functions of those class template instantiations will be <code>constexpr</code> where the body doesn't violate the <code>constexpr</code> restrictions. This requires the instantiation of the body of the constructor, for constructors in order to check if the member initializers are allowed inside a <code>constexpr</code> function. Consider:</p>\n<pre><code>struct nonconstexpr { nonconstexpr() { std::cout &lt;&lt; \"runtime\\n\"; } };\nstruct isconstexpr { constexpr isconstexpr() {} };\n\ntemplate&lt;typename T&gt;\nstruct wrapper { T t; constexpr wrapper() : t() {} };\n</code></pre>\n<p>When instantiating the default ctor of <code>wrapper</code>, the compiler has to instantiate the member initializers in order to determine whether or not this instantiation shall be <code>constexpr</code>.</p>\n<p>In the case of <code>std::tuple</code>, this causes somewhere the instantiation of a member-initializer which tries to value-initialize the reference tuple leaf (data member). This is an error, and it does not occur within the immediate context of the original instantiation of the default constructor. Therefore, it is a hard error rather than a Substitution Failure in the immediate context.</p>\n<p>--]</p>\n<p>This part isn't entirely clear to me because <a href=\"http://wg21.cmeerw.net/cwg/issue1358\" rel=\"nofollow noreferrer\">CWG 1358</a> essentially made all instantiations <code>constexpr</code>, whether or not they actually satisfy the criteria. And indeed, gcc 6.0 does not fail to compile the following example, while gcc 5.1 and clang 3.7 reject it:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt;typename T&gt;\nstruct foo\n{\n    T t;\n    constexpr foo() {} // remove `constexpr` to make it compile everywhere\n};\n\nint main()\n{\n    static_assert(std::is_default_constructible&lt;foo&lt;int&amp;&gt;&gt;{}, \"!\");\n}\n</code></pre>\n<p>CWG 1358 also tells us why the distinction between the two approaches - conditional constexpr and constexpr despite violations - is important:</p>\n<blockquote>\n<p id=\"so_31433911_31438404_1\">Questions arose in the discussion of issue 1581 as to whether this\n  approach \u2014 making the specialization of a constexpr function template\n  or member function of a class template still constexpr but unable to\n  be invoked in a constant context \u2014 is correct. The implication is that\n  class types might be categorized as literal but not be able to be\n  instantiated at compile time. This issue is therefore returned to\n  \"review\" status to allow further consideration of this question.</p>\n</blockquote>\n<hr>\n<p>For libc++, there is bug <a href=\"https://llvm.org/bugs/show_bug.cgi?id=21157\" rel=\"nofollow noreferrer\">#21157</a>, which has been resolved on 2014-10-15 and appears in the clang3.6 branch. For libstdc++, there doesn't seem to be a bug report; the issue was fixed in a <a href=\"https://github.com/gcc-mirror/gcc/commit/d3c64041b32b6962ad6b2d879231537a477631fb\" rel=\"nofollow noreferrer\">combined commit on 2015-06-30</a> which also implements <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4387.html\" rel=\"nofollow noreferrer\">N4387 - Improving Pair and Tuple (Revision 3)</a> which currently does not seem to appear in any gcc5 branches.</p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-16T17:18:00.717", "Score": "7", "CreationDate": "2015-07-15T18:34:39.120", "ParentId": "31433911", "CommentCount": "4", "OwnerUserId": "420683", "LastEditDate": "2017-05-23T10:27:08.297"}});