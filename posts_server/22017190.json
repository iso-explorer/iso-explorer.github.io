post_cb({"22017277": {"ParentId": "22017190", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2014-02-25T14:34:03.877", "Score": "1", "LastEditorUserId": "440558", "LastEditDate": "2014-02-25T14:42:44.880", "Id": "22017277", "OwnerUserId": "440558", "Body": "<p>By default, all enumerations are basically integer constants, and as all integer values you can use them in arithmetic expressions.</p>\n<p>In your case the constant <code>QuantLib::Months</code> has the value <code>2</code>, as enumerations starts from zero and are simply increased.</p>\n<hr>\n<p>However, unless you <em>have</em> to make your own data/time functionality, I suggest you use the functionality available in <a href=\"http://en.cppreference.com/w/cpp/chrono\" rel=\"nofollow\">the standard library <code>&lt;chrono&gt;</code> header</a> (or <a href=\"http://www.boost.org/doc/libs/1_55_0/doc/html/chrono.html\" rel=\"nofollow\">Boost chrono</a> if you don't have a C++11 capable compiler/library). It has all this functionality built-in.</p>\n<p>Here is an example similar to your code</p>\n<pre><code>auto now = std::chrono::system_clock::now();  // The current time at the moment\nauto then = now + std::chrono::hours(24 * 365);\n</code></pre>\n<p>The variable <code>then</code> will now be a <a href=\"http://en.cppreference.com/w/cpp/chrono/time_point\" rel=\"nofollow\"><code>time_point</code></a> <code>24 * 365</code> hours in the future from <code>now</code>.</p>\n</hr>", "LastActivityDate": "2014-02-25T14:42:44.880"}, "22017496": {"ParentId": "22017190", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2014-02-25T14:42:49.760", "Score": "4", "LastEditorUserId": "1782465", "LastEditDate": "2014-02-25T14:53:54.760", "Id": "22017496", "OwnerUserId": "1782465", "Body": "<p>One of the following is in effect here:</p>\n<ol>\n<li><p>In C++, an enumeration type can be implicitly converted to an integral type. If this is happening here, <code>date + 12 * QuantLib::Months</code> would be the same as <code>date + 12 * 2</code>.</p></li>\n<li><p>It is also possible to overload operators for enumeration types. In that case, it might be that the library defines an <code>operator* (int, QuantLib::TimeUnit)</code> which returns something compatible with the <code>+</code> you're doing.</p></li>\n</ol>\n<p>I don't know <code>QuantLib</code>, but I'd guess #2 is what's happening. <a href=\"http://quantlib.org/reference/namespace_quant_lib.html#a26a1ae8ba98b630db20bbf8e3cb84dfc\" rel=\"nofollow\">QuantLib documentation</a> corroborates this (thanks to @DaliborFrivaldsky for the link).</p>\n", "LastActivityDate": "2014-02-25T14:53:54.760"}, "22017190": {"CommentCount": "2", "ViewCount": "308", "CreationDate": "2014-02-25T14:30:37.313", "LastActivityDate": "2014-02-25T14:53:54.760", "Title": "Multiplying an Enum in C++", "AcceptedAnswerId": "22017496", "PostTypeId": "1", "Id": "22017190", "Score": "3", "Body": "<p>I have some code that is multiplying an enum by an integer:</p>\n<pre><code>QuantLib::Date date2 = date + 12 * QuantLib::Months;\n</code></pre>\n<p>Where QuantLib::Months is defined as:</p>\n<pre><code>enum TimeUnit { Days,\n                Weeks,\n                Months,\n                Years\n};\n</code></pre>\n<p>This gives me the desired result of <em>date2</em> being one year on from <em>date</em>. However, I'm not able to comprehend how this is being achieved.</p>\n<p>I had thought that this would not compile. Now I feel that I'm arriving at a \"twelve months\" object, which the is then handled by the QuantLib::Date '+' operator overload, but I've never seen this style before.</p>\n<p>I have come from a C# background, so there may be something I'm not aware of at work here. Can anyone explain what is going on? Any reference documentation would be appreciated.</p>\n", "Tags": "<c++><quantlib>", "OwnerUserId": "210566", "AnswerCount": "3"}, "22017585": {"ParentId": "22017190", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-02-25T14:45:53.313", "Score": "0", "LastEditorUserId": "2877241", "LastEditDate": "2014-02-25T14:51:12.257", "Id": "22017585", "OwnerUserId": "2877241", "Body": "<p>In your example you are using a so-called unscoped enumeration. Each enumeration has an underlying integral type (that is not necessary the type <code>int</code> There is no such a default rule for enumerations in C++).\nAccording to paragraph 4.5.3 of the C++ Standard (you asked some reference to documentation):</p>\n<blockquote>\n<p id=\"so_22017190_22017585_0\">3 A prvalue of an unscoped enumeration type whose underlying type is\n  not fixed (7.2) can be converted to a prvalue of the first of the\n  following types that can represent all the values of the enumeration\n  (i.e., the values in the range bmin to bmax as described in 7.2): int,\n  unsigned int, long int, unsigned long int, long long int, or unsigned\n  long long int. If none of the types in that list can represent all the\n  values of the enumeration, a prvalue of an unscoped enumeration type\n  can be converted to a prvalue of the extended integer type with lowest\n  integer conversion rank (4.13) greater than the rank of long long in\n  which all the values of the enumeration can be represented. If there\n  are two such extended types, the signed one is chosen.</p>\n</blockquote>\n<p>So in your example <code>QuantLib::Months</code> is converted to int because all values of the enumeration can be stored in an object of type int. Then usual arithmetic conversions are performed in the multiplicative operation.</p>\n", "LastActivityDate": "2014-02-25T14:51:12.257"}, "bq_ids": {"n4140": {"so_22017190_22017585_0": {"section_id": 23, "quality": 0.9625, "length": 77}}, "n3337": {"so_22017190_22017585_0": {"section_id": 20, "quality": 0.9625, "length": 77}}, "n4659": {"so_22017190_22017585_0": {"section_id": 23, "quality": 0.9625, "length": 77}}}});