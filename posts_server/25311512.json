post_cb({"25311919": {"PostTypeId": "2", "Body": "<p>This changed in C++11 as a result of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#374\" rel=\"nofollow\">CWG issue 374</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3064.pdf\" rel=\"nofollow\">N3064</a>. The current wording (\u00a714.7.3 [temp.expl.spec]/p2) is:</p>\n<blockquote>\n<p id=\"so_25311512_25311919_0\">An explicit specialization shall be declared in a namespace enclosing\n  the specialized template. An explicit specialization whose\n  <em>declarator-id</em> is not qualified shall be declared in the nearest\n  enclosing namespace of the template, or, if the namespace is inline\n  (7.3.1), any namespace from its enclosing namespace set.</p>\n</blockquote>\n<p>Since your <em>declarator-id</em> is in fact qualified with <code>MyLib::</code>, and the global namespace is a \"namespace enclosing the specialized template\", this looks like a GCC bug (<a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=56480\" rel=\"nofollow\">bug 56480</a>). Your code compiles fine with <a href=\"http://coliru.stacked-crooked.com/a/d27b20fe26d6fc21\" rel=\"nofollow\">clang in C++11 mode</a>.</p>\n<p>In C++98, however, the specialization must be put inside namespace in which the template is a member (see Mark B's comment below), and clang will produce a warning if <a href=\"http://coliru.stacked-crooked.com/a/1a12ca90d3c7033c\" rel=\"nofollow\">put in C++98 mode</a>.</p>\n", "LastActivityDate": "2014-08-14T21:21:28.507", "LastEditorUserId": "2756719", "Id": "25311919", "CommentCount": "3", "CreationDate": "2014-08-14T15:29:26.130", "ParentId": "25311512", "Score": "6", "OwnerUserId": "2756719", "LastEditDate": "2014-08-14T21:21:28.507"}, "bq_ids": {"n4140": {"so_25311512_25311919_0": {"length": 24, "quality": 0.96, "section_id": 264}}, "n3337": {"so_25311512_25311919_0": {"length": 24, "quality": 0.96, "section_id": 255}}}, "25311512": {"ViewCount": "2073", "Body": "<p>I'm developing a cross-platform library using C++. MSVC compiles fine but g++ is giving me problems. Suppose I have the following Enum helper class:</p>\n<pre><code>// File: Enum.h\n#ifndef ENUM_H\n#define ENUM_H\n\n#include &lt;map&gt;\n#include &lt;cstring&gt;\nnamespace MyLib {\n\n#define DECLARE_ENUM( type ) template&lt;&gt; std::map&lt;const char*, type&gt;  \\\n            MyLib::Enum&lt;type&gt;::mMap = std::map&lt;const char*, type&gt;(); \\\n            template&lt;&gt; MyLib::Enum&lt;type&gt;::Enum (void)\n\ntemplate &lt;typename Type&gt; class Enum\n{\nprivate:\n    Enum (void);\n\npublic:\n    static int Size (void) { /* ... */ return 0; }\n\nprivate:\n    static std::map&lt;const char*, Type&gt; mMap;\n};\n\n}\n#endif\n</code></pre>\n<p>Here is the intended use:</p>\n<pre><code>// SomeFile.cpp\n#include \"Enum.h\"\n\nenum MyEnum\n{\n    value1, value2, value3,\n};\n\nDECLARE_ENUM (MyEnum)\n{\n    mMap[\"value1\"] = value1;\n    mMap[\"value2\"] = value2;\n    mMap[\"value3\"] = value3;\n}\n\nvoid SomeFunc (void)\n{\n    cout &lt;&lt; Enum&lt;MyEnum&gt;::Size();\n}\n</code></pre>\n<p>g++ gives me a \"Specialization of template in different namespace\" error. Wrapping the DECLARE_ENUM block in namespace MyLib solves this problem. My question is why do I have to do this and is there another way of fixing this that doesn't require me to add a namespace MyLib around the block?</p>\n", "Title": "Specialization of template in different namespace", "CreationDate": "2014-08-14T15:10:02.867", "LastActivityDate": "2014-08-14T21:21:28.507", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-08-14T20:02:25.713", "LastEditorUserId": "419275", "Id": "25311512", "Score": "4", "OwnerUserId": "419275", "Tags": "<c++><templates><ubuntu><c++11><g++>", "AnswerCount": "1"}});