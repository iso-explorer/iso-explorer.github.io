post_cb({"16889154": {"ParentId": "16889098", "CommentCount": "0", "Body": "<p>It's called argument type deduction. From the C++ Standard (C++11 version):</p>\n<blockquote>\n<p id=\"so_16889098_16889154_0\">(\u00a714.8.2/1) When a function template specialization is referenced, all of the template arguments shall have values. The values can be explicitly specified or, in some cases, be deduced from the use or obtained from default\n  template-arguments. [ Example:</p>\n<pre><code>void f(Array&lt;dcomplex&gt;&amp; cv, Array&lt;int&gt;&amp; ci) {\n  sort(cv);   // calls sort(Array&lt;dcomplex&gt;&amp;)\n  sort(ci);   // calls sort(Array&lt;int&gt;&amp;)\n}\n</code></pre>\n<p id=\"so_16889098_16889154_1\">and</p>\n<pre><code>void g(double d) {\n  int i = convert&lt;int&gt;(d);   // calls convert&lt;int,double&gt;(double)\n  int c = convert&lt;char&gt;(d);  // calls convert&lt;char,double&gt;(double)\n}\n</code></pre>\n<p id=\"so_16889098_16889154_2\">\u2014 end example ]</p>\n</blockquote>\n<p>Type deduction is only done when arguments are present, i.e. it only works for function templates, not for class templates (not even for the constructor).</p>\n<p>Type deduction can cause very complicated ambiguities, especially when multiple template specializations and/or overloaded function definitions are given. In some cases, it won't be possible, and then you must specify some or all of the template arguments explicitly using the angle-bracket syntax.</p>\n", "OwnerUserId": "777186", "PostTypeId": "2", "Id": "16889154", "Score": "1", "CreationDate": "2013-06-03T02:07:13.697", "LastActivityDate": "2013-06-03T02:07:13.697"}, "16889129": {"ParentId": "16889098", "CommentCount": "0", "Body": "<p>Because the types are <em>deduced</em>. The compiler can look at the call, and figure out that since you're passing a value <code>aList.begin()</code>, the iterator will have the type that is the return type of <code>aList.begin()</code>. Similarly with using <code>*it</code> - the compiler knows what type <code>*it</code> is, hence can deduce the type being passed in as a function argument.</p>\n", "OwnerUserId": "1085573", "PostTypeId": "2", "Id": "16889129", "Score": "1", "CreationDate": "2013-06-03T02:03:19.263", "LastActivityDate": "2013-06-03T02:03:19.263"}, "bq_ids": {"n4140": {"so_16889098_16889154_0": {"section_id": 293, "quality": 0.875, "length": 21}}, "n3337": {"so_16889098_16889154_0": {"section_id": 284, "quality": 0.875, "length": 21}}, "n4659": {"so_16889098_16889154_0": {"section_id": 300, "quality": 0.875, "length": 21}}}, "16889098": {"CommentCount": "0", "ViewCount": "209", "CreationDate": "2013-06-03T01:56:41.083", "LastActivityDate": "2013-06-03T02:07:13.697", "Title": "C++ std::find() and template parameter", "AcceptedAnswerId": "16889154", "PostTypeId": "1", "Id": "16889098", "Score": "1", "Body": "<p>In <a href=\"http://www.cplusplus.com/reference/algorithm/find/\" rel=\"nofollow\">C++ reference</a>, the find method is defined as </p>\n<pre><code>template &lt;class InputIterator, class T&gt;\nInputIterator find (InputIterator first, InputIterator last, const T&amp; val);\n</code></pre>\n<p>However, when I use find method, I use find() method without explicitly describing the InputIterator and T.</p>\n<p>For example, I use</p>\n<pre><code>std::vector&lt;T&gt; aList\n...\nstd::list&lt;int&gt;::iterator pointer = std::find(aList.begin(), aList.end(), *it);\n</code></pre>\n<p>not this</p>\n<pre><code>std::list&lt;int&gt;::iterator pointer = std::find&lt;std::list&lt;int&gt;::iterator, int&gt;(aList.begin(), aList.end(), *it);\n</code></pre>\n<p>How does it work? Why don't I need to specify the types when I use find method?</p>\n", "Tags": "<c++><templates><find>", "OwnerUserId": "260127", "AnswerCount": "2"}});