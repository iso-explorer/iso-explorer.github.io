post_cb({"bq_ids": {"n4140": {"so_43193749_43194989_1": {"length": 12, "quality": 0.75, "section_id": 7041}, "so_43193749_43194989_0": {"length": 30, "quality": 0.9375, "section_id": 7040}}, "n3337": {"so_43193749_43194989_1": {"length": 12, "quality": 0.75, "section_id": 6786}}, "n4659": {"so_43193749_43194989_1": {"length": 15, "quality": 0.9375, "section_id": 8538}, "so_43193749_43194989_0": {"length": 30, "quality": 0.9375, "section_id": 8537}}}, "43193749": {"ViewCount": "167", "Body": "<p>I have a snippet:</p>\n<pre><code>enum class EC {a, b};\n\nstruct B {\n    constexpr B(EC ec): ec_(ec) {}\n    EC ec_;\n};\n\nstruct A_base {\n    constexpr A_base(B b): b_(b) { }\n    B b_;\n};\n\nstruct A: A_base {\n    static constexpr B bbb = EC::a;\n    constexpr A(B bbbb): A_base(bbbb) { }\n};\n\nint main()\n{\n    A a1(A::bbb);    // 1\n    A a2{A::bbb};    // 2\n\n    A a3 = A::bbb;   // 3\n    A a4 = {A::bbb}; // 4\n}\n</code></pre>\n<p>It compiles good by modern compilers with c++17 support. With c++11 and c++14 standard support linker error occurs. This question was already discussed in <a href=\"https://stackoverflow.com/questions/28839672/linker-error-undefined-reference-with-static-constexpr-const-char-and-perfe\">Linker error (undefined reference) with `static constexpr const char*` and perfect-forwarding</a> , <a href=\"https://stackoverflow.com/questions/8452952/c-linker-error-with-class-static-constexpr\">C++ Linker Error With Class static constexpr</a> and some other discussions. I understand why this error occurs.</p>\n<p>However some things I don't understand:</p>\n<ol>\n<li>With clang I always get linker errors. However when I set -O3 optimization or declare a1, a2, a3, a4 variables as constexpr it inlines A::bbb, and there is no error.</li>\n<li>Gcc without optimization  needs reference to A::bbb only for a3, and a4. With optimizations and constexpr it behaves exactly like clang.</li>\n</ol>\n<p>Is it normal that compilers differ with turned off optimizations and why does gcc treats a1,a2 initializations not equally to a3, a4?</p>\n", "AcceptedAnswerId": "43194989", "Title": "Linker error for constexpr static member variable in gcc and clang", "CreationDate": "2017-04-03T20:33:42.193", "Id": "43193749", "CommentCount": "9", "LastEditDate": "2017-05-23T12:17:32.580", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2017-04-03T22:02:28.320", "Score": "1", "OwnerUserId": "6475845", "Tags": "<c++><c++11><c++14>", "AnswerCount": "1"}, "43194989": {"Id": "43194989", "PostTypeId": "2", "Body": "<h3>Before C++17</h3>\n<p>All the initializations of <code>A</code>s invoke the <code>A::A(B )</code> constructor, which require copying a <code>B</code>, which uses the compiler-generated <code>B::B(B const&amp;)</code>. Binding a variable to reference (<code>A::bbb</code>) is an odr-use of that variable. The specific rule, from [basic.def.odr] is:</p>\n<blockquote>\n<p id=\"so_43193749_43194989_0\">A variable x whose name appears as a potentially-evaluated expression ex is odr-used by ex unless applying the\n  lvalue-to-rvalue conversion (4.1) to x yields a constant expression (5.20) that does not invoke any non-trivial\n  functions and, if x is an object, ex is an element of the set of potential results of an expression e, where\n  either the lvalue-to-rvalue conversion (4.1) is applied to e, or e is a discarded-value expression (Clause 5).</p>\n</blockquote>\n<p>The first call to the copy constructor would involve binding <code>A::bbb</code> to a reference, which is neither an lvalue-to-rvalue conversion nor a discarded-value expression, so it's odr-used. </p>\n<p>The most important rule is:</p>\n<blockquote>\n<p id=\"so_43193749_43194989_1\">Every program shall contain exactly one definition of every non-inline function or variable that is odr-used in that program outside of a discarded statement (6.4.1); no diagnostic required.</p>\n</blockquote>\n<p><code>A::bbb</code> is odr-used, but lacks a definition, so we're violating that rule - commonly referred to as an odr violation. But since the compiler is not required to issue a diagnostic in this case (\"no diagnostic required\", or NDR for short), the program is undefined behavior. These kinds of issues can be frustrating at times for a programmer, but they're arbitrarily difficult for the compiler to diagnose - so it's something that we have to live with. </p>\n<p>It is likely that on higher optimization levels, the compilers simply elide the copy, so a call to <code>B::B(B const&amp;)</code> for <code>A::bbb</code> isn't necessary... As to why different initializations are treated differently? Probably as a result of different optimization passes. Ultimately, it doesn't change the fact that this is an odr violation - regardless of whether the code compiles and links.</p>\n<hr/>\n<h3>After C++17</h3>\n<p>As a result of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0386r2.pdf\" rel=\"nofollow noreferrer\">p0386</a>, <code>static constexpr</code> data members are implicitly inline, which means that now <code>A::bbb</code> <em>does</em> have a definition and now there is no odr-violation. C++17 is cool. </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2017-04-03T22:02:28.320", "Score": "5", "CreationDate": "2017-04-03T21:57:04.790", "ParentId": "43193749", "CommentCount": "0", "LastEditDate": "2017-04-03T22:02:28.320", "OwnerUserId": "2069064"}});