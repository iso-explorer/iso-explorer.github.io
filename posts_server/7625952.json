post_cb({"7626171": {"ParentId": "7625952", "LastEditDate": "2011-10-02T12:05:05.493", "CommentCount": "5", "CreationDate": "2011-10-02T11:54:54.347", "OwnerUserId": "596781", "LastEditorUserId": "596781", "PostTypeId": "2", "Id": "7626171", "Score": "2", "Body": "<p>I believe that the rules laid out in 3.6.2 to determine when <em>static initialization</em> happens do not include the initialization for <code>d</code>, which is therefore <em>dynamic initialization</em>. On the other hand, <code>S::c</code> is indeed statically initialized (since <code>5</code> is a constant expression). Since all static initialization happens before dynamic initialization, you get the expected result.</p>\n<p>To make <code>d</code> eligible for static initialization, it has to be initialized with a constant expression. This in turn forces you to write the <code>S::c</code> inline:</p>\n<pre><code>struct S { static constexpr int c = 5; };\n\nconst int d = S::c; // statically initialized\n</code></pre>\n<p>Note that the standard permits dynamic initialization to be replaced by static initialization, which is why reordering the two lines in your original example will cause the two different sorts of initialization. As TonyK points out, you can use <code>array[d]</code> in the static case, but not in the dynamic case, so you can check which one is happening. With the <code>constexpr</code> approach, you're guaranteed to have static initialization and you don't have to rely on optional compiler behaviour.</p>\n", "LastActivityDate": "2011-10-02T12:05:05.493"}, "8683842": {"ParentId": "7625952", "CommentCount": "1", "Body": "<p>In the first example, <code>d</code> is not initialized by a constant expression, because <code>S::c</code> is not</p>\n<blockquote>\n<p id=\"so_7625952_8683842_0\">a non-volatile const object with a preceding initialization,\n  initialized with a constant expression</p>\n</blockquote>\n<p>(see C++11 [expr.const]p2, bullet on lvalue-to-rvalue conversions), because the initialization of <code>S::c</code> does not precede the initialization of <code>d</code>. Therefore static initialization will be used for <code>S::c</code> (because it is initialized by a constant expression), but dynamic initialization can be used for <code>d</code>.</p>\n<p>Since static initialization precedes dynamic initialization, <code>d</code> would be initialized to <code>50</code> by its dynamic initializer. The compiler is permitted to convert the dynamic initialization of <code>d</code> to static initialization, but if it does, it must produce the value that <code>d</code> would have had if every variable which could have used dynamic initialization had, in fact, used dynamic initialization. In this case, <code>d</code> is initialized to <code>50</code> either way. See C++11 [basic.start.init]p2 for more information on this.</p>\n<p>There is no way to add <code>constexpr</code> to the first example to guarantee that static initialization is used for <code>d</code>; in order to do that, you must reorder the initializations. However, adding <code>constexpr</code> will produce a diagnostic for the first example, which will at least allow you to ensure that dynamic initialization is <i>not</i> used (you get static initialization or a compilation error).</p>\n<p>You can update the second case to ensure that static initialization is used as follows:</p>\n<pre><code>struct S {\n    static const int c; // do not use constexpr here\n};\nconstexpr int S::c = 5;\nconstexpr int d = 10 * S::c;\n</code></pre>\n<p>It is ill-formed to use <code>constexpr</code> on a variable declaration which is not a definition, or to use it on a variable declaration which does not contain an initializer, so <code>const</code>, not <code>constexpr</code> must be used within the definition of <code>struct S</code>. There is one exception to this rule, which is when defining a <code>static constexpr</code> data member of a literal, non-integral type, with the initializer specified within the class:</p>\n<pre><code>struct T { int n; };\nstruct U {\n    static constexpr T t = { 4 };\n};\nconstexpr T U::t;\n</code></pre>\n<p>In this case, <code>constexpr</code> must be used in the definition of the class, in order to permit an initializer to be provided, and <code>constexpr</code> must be used in the definition of the static data member, in order to allow its use within constant expressions.</p>\n", "OwnerUserId": "1041090", "PostTypeId": "2", "Id": "8683842", "Score": "3", "CreationDate": "2011-12-30T20:37:32.670", "LastActivityDate": "2011-12-30T20:37:32.670"}, "7625952": {"CommentCount": "6", "ViewCount": "946", "CreationDate": "2011-10-02T11:00:38.550", "LastActivityDate": "2011-12-30T20:37:32.670", "Title": "\"surprising\" constant initialization because of definition order", "FavoriteCount": "2", "PostTypeId": "1", "Id": "7625952", "Score": "13", "Body": "<p>When reading the <a href=\"http://accu.org/content/conf2007/Maurer-C++0x_Generating_Constant_Expression.pdf\" rel=\"noreferrer\">slides about constexpr</a> the introduction is about <em>\"surprisingly dynamic initialization with consts\"</em>. The example is </p>\n<pre><code>struct S {\n    static const int c;\n};\nconst int d = 10 * S::c;\nconst int S::c = 5;\n</code></pre>\n<p>Alas, the audio track is missing, so are the notes, so I can only guess what is meant here.</p>\n<p><strong>Is it corrrect that <code>d</code> is \"surprisingly\" initialized dynamically, because <code>S::c</code> is defined <em>before</em> <code>d</code>?</strong> That the <em>declaration</em> of <code>S::c</code> is before <code>d</code> is probably not enough, the compiler needs the complete <em>definition</em>, right?</p>\n<p>That said, I suspect, that in the following example <strong><code>d</code> <em>would</em> be initialized statically?</strong></p>\n<pre><code>struct S {\n    static const int c;\n};\nconst int S::c = 5;\nconst int d = 10 * S::c;  // now _after_ defn of S::c\n</code></pre>\n<p>And to take the cake, in C++11, <strong>what would have to be <code>constexpr</code></strong> for full static initialization? <code>S::c</code>, <code>d</code> or both?</p>\n", "Tags": "<c++><initialization><const><c++11><constexpr>", "OwnerUserId": "472245", "AnswerCount": "4"}, "7626222": {"ParentId": "7625952", "CommentCount": "2", "Body": "<p>For static initialization one needs, roughly speaking, a constant-expression initializer. </p>\n<p>To be a constant-expression, roughly speaking, a variable needs to be of a <code>const</code> type and have a preceding initialization with a constant-expression.</p>\n<p>In the first example <code>d</code>'s initializer is not a constant-expression, as <code>S::c</code> isn't one (it has no preceding initialization). Hence, <code>d</code> is not statically initialized. </p>\n<p>In the second example <code>d</code>'s initializer is a constant-expression, and everything is OK.</p>\n<p>I'm simplifying matters. In full formal standardese this would be about nine times longer.</p>\n<hr>\n<p>As for <code>constexpr</code> specifier, no object <strong>has</strong> to be declared <code>constexpr</code>. It is just an additional error-check. (This is about <code>constexpr</code> <em>objects</em>, not <code>constexpr</code> <em>functions</em>).</p>\n<p>You <em>may</em> declare <code>S::c</code> <code>constexpr</code> in the second variant if you want some extra error protection (perhaps 5 will start changing its value tomorrow?) Adding <code>constexpr</code> to the first variant cannot possibly help.</p>\n</hr>", "OwnerUserId": "775806", "PostTypeId": "2", "Id": "7626222", "Score": "2", "CreationDate": "2011-10-02T12:11:25.030", "LastActivityDate": "2011-10-02T12:11:25.030"}, "7626122": {"ParentId": "7625952", "CommentCount": "5", "Body": "<p>You can find out whether a constant is statically or dynamically initialised by trying to declare an array:</p>\n<pre><code>struct S {\n    static const int c;\n};\nconst int d = 10 * S::c; // (1)\nconst int S::c = 5;      // (2)\n\nstatic char array[d];\n</code></pre>\n<p>This code fails in g++ version 4.7.0, because <code>d</code> is dynamically initialised. And if you exchange (1) and (2), it compiles, because now <code>d</code> is statically initialised. But I can't find another way to fix it, using <code>constexpr</code>.</p>\n", "OwnerUserId": "428857", "PostTypeId": "2", "Id": "7626122", "Score": "1", "CreationDate": "2011-10-02T11:42:38.237", "LastActivityDate": "2011-10-02T11:42:38.237"}, "bq_ids": {"n4140": {"so_7625952_8683842_0": {"section_id": 6185, "quality": 1.0, "length": 8}}, "n3337": {"so_7625952_8683842_0": {"section_id": 5946, "quality": 1.0, "length": 8}}, "n4659": {"so_7625952_8683842_0": {"section_id": 7687, "quality": 1.0, "length": 8}}}});