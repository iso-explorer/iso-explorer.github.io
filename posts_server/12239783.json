post_cb({"12239911": {"ParentId": "12239783", "LastEditDate": "2017-05-23T10:34:41.400", "CommentCount": "0", "CreationDate": "2012-09-02T21:33:34.693", "OwnerUserId": "13760", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "12239911", "Score": "0", "Body": "<p>You need to understand <a href=\"https://stackoverflow.com/questions/28002/regular-cast-vs-static-cast-vs-dynamic-cast\">the difference between the various types of C++ casts</a>.</p>\n<p>You're using a static cast here, which is the same as saying, \"I don't really care if it's actually of that type or not - just try your best\".</p>\n<p>In this case, you want to know if your pointer is actually of the derived type you're casting it to. You should use a dynamic_cast. This cast will succeed only if the pointer is of the correct type. That means, that if it fails, it will return a NULL pointer. </p>\n<p>The behavior you're seeing is what happens when you don't use the right cast for the job, which, while you can try to explain it, is something you really should avoid because it falls in the domain of undefined behavior. In other words, you cannot expect the same side effects across compilers or even different versions of the same compiler. In other words, avoid it.</p>\n", "LastActivityDate": "2012-09-02T21:33:34.693"}, "12239892": {"ParentId": "12239783", "CommentCount": "0", "Body": "<p>You did something very bad when you cast a pointer to an object allocated as a <code>B</code> to a pointer to a derived class <code>D</code>. Here's what the standard says, emphasis mine:</p>\n<blockquote>\n<p id=\"so_12239783_12239892_0\">5.2.9 Static Cast  </p>\n<p id=\"so_12239783_12239892_1\">If the rvalue of type \u201cpointer to cv1 B\u201d points to a B that is actually a sub-object of an object of type D, the resulting pointer points to the enclosing object of type D. <strong>Otherwise, the result of the cast is undefined</strong>.</p>\n</blockquote>\n<p>You've invoked undefined behavior by doing that <code>static_cast</code>. The compiler and runtime can do anything and still be compliant when the program invokes undefined behavior.</p>\n", "OwnerUserId": "774499", "PostTypeId": "2", "Id": "12239892", "Score": "1", "CreationDate": "2012-09-02T21:29:45.957", "LastActivityDate": "2012-09-02T21:29:45.957"}, "12239809": {"ParentId": "12239783", "LastEditDate": "2012-09-02T21:28:23.330", "CommentCount": "4", "CreationDate": "2012-09-02T21:16:29.133", "OwnerUserId": "267885", "LastEditorUserId": "267885", "PostTypeId": "2", "Id": "12239809", "Score": "4", "Body": "<p>Since <code>disp()</code> doesn't access any of the members of the class, it is in principle the same as if it were declared in the global namespace instead of in class, so there are no negative side effects to calling it, even though the instance is not of the right class.</p>\n<p>What are you doing is downcasting a pointer of a base class to a pointer of the derived class, even though it was not initialized as such. If <code>disp()</code> tried to access class members that were in <code>D</code> but not in <code>B</code>, you would probably run into segfaults. </p>\n<p>Bottom line: don't use <code>static_cast</code> for downcasting unless you're absolutely sure the pointer is actually pointing to an instance of the derived class. If you're unsure, you can use <code>dynamic_cast</code> which fails in the event of mismatch (but there is the overhead of RTTI, so avoid it if you can).</p>\n<p><code>dynamic_cast</code> will return <code>nullptr</code> if the cast is incorrect or throw a <code>std::bad_cast</code> \nexception if it casts references, so you will know for sure why it fails instead of possible memory corruption bugs.</p>\n", "LastActivityDate": "2012-09-02T21:28:23.330"}, "12239823": {"ParentId": "12239783", "CommentCount": "0", "Body": "<p>The line:</p>\n<pre><code>D *pd1 = static_cast&lt;D*&gt;(pb);\n</code></pre>\n<p>Will make the cast regardless if the source pointer is <code>B*</code> or <code>D*</code>. In your case the result will be pointer that points to an object of a wrong type. Method <code>disp</code> will work because it is not using any data member or virtual function of the class <code>D</code>. In more complex case this will lead to unstable behaviour or a crash.</p>\n<p>Your objects are polimorphic. You should use the <code>dynamic_cast</code> instead.</p>\n", "OwnerUserId": "1459996", "PostTypeId": "2", "Id": "12239823", "Score": "2", "CreationDate": "2012-09-02T21:18:39.863", "LastActivityDate": "2012-09-02T21:18:39.863"}, "12239842": {"ParentId": "12239783", "LastEditDate": "2012-09-02T21:27:00.247", "CommentCount": "0", "CreationDate": "2012-09-02T21:21:55.417", "OwnerUserId": "16287", "LastEditorUserId": "16287", "PostTypeId": "2", "Id": "12239842", "Score": "1", "Body": "<p>What's important in this context, I believe, is that the member function <code>disp()</code> isn't tucked away inside all objects of type <code>D</code>.  It's a single function that exists in one place.  And whether any object will try to call call <code>disp()</code> is decided by the code.</p>\n<p>Your <code>static_cast</code> will produce what the compiler considers a pointer to <code>D</code> <strong>regardless of what pointer you pass it</strong>.  And once you have a pointer to <code>D</code>, the compiler will let you attempt to call <code>disp()</code>.</p>\n<p><em>Put another way, <code>static_cast</code> will not protect you from casting a pointer incorrectly.</em></p>\n", "LastActivityDate": "2012-09-02T21:27:00.247"}, "bq_ids": {"n4140": {"so_12239783_12239892_1": {"section_id": 6037, "quality": 0.7894736842105263, "length": 15}}, "n3337": {"so_12239783_12239892_1": {"section_id": 5805, "quality": 0.8947368421052632, "length": 17}}, "n4659": {"so_12239783_12239892_1": {"section_id": 7536, "quality": 0.7894736842105263, "length": 15}}}, "12239783": {"CommentCount": "1", "ViewCount": "308", "CreationDate": "2012-09-02T21:11:41.917", "LastActivityDate": "2012-09-02T21:33:34.693", "Title": "Questions about static_cast", "AcceptedAnswerId": "12239809", "PostTypeId": "1", "Id": "12239783", "Score": "4", "Body": "<p>I've wrote a piece of code, but I am confused with its output:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass B{\npublic:\n    virtual void foo() {cout &lt;&lt; \"B::foo\" &lt;&lt; endl;}\n};\n\nclass D:public B{\npublic:\n    virtual void foo() {cout &lt;&lt; \"D::foo\" &lt;&lt; endl;}\n    void disp() {cout &lt;&lt; \"D::disp\" &lt;&lt; endl;}\n};\n\nvoid func(B *pb){\n    D *pd1 = static_cast&lt;D*&gt;(pb);\n    pd1-&gt;foo();\n    pd1-&gt;disp();\n}\n\nint main(int argc, char *argv[])\n{\n\n    B* pb = new B();\n    func(pb); \n\n    return 0;\n}\n</code></pre>\n<p>The output is:</p>\n<pre><code>B::foo\nD::disp\n</code></pre>\n<p>But as far as I know, <code>pb</code> points to type B. And there's no function named <code>disp()</code> in it? So, why could it get access to <code>disp()</code> function in class D?</p>\n", "Tags": "<c++><static-cast>", "OwnerUserId": "1993552", "AnswerCount": "5"}});