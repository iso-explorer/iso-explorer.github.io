post_cb({"bq_ids": {"n4140": {"so_11420802_11470880_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 5881}}, "n3337": {"so_11420802_11470880_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 5652}}, "n4659": {"so_11420802_11470880_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 7364}}}, "11420852": {"Id": "11420852", "PostTypeId": "2", "Body": "<p>In short: Put the template code in a header file.  Use compiler-specific <code>forceinline</code> or <code>noinline</code> keywords if the optimizer fails to make good decisions about inlining.</p>\n<hr>\n<p>You can and should put definitions of template members into header files.  This ensures that the compiler has access to the definition at the point of use when it finds out what the actual template parameters are, and is able to perform implicit instantiaion.</p>\n<p>The <code>inline</code> keyword has very little impact on templates, since template functions are already exempted from the single definition requirement (The One Definition Rule still requires that all definitions be the same).  It is a hint to the compiler that the function should be inlined.  And you can omit it as a hint to the compiler to not inline the function.  So use it that way.  But the optimizer will still look at other factors (function size) and make its own choice on inlining.</p>\n<p>Some compilers have special keywords, like <code>__attribute__(always_inline)</code> or <code>__declspec(noinline)</code> to override the optimizer's choice.</p>\n<p>Mostly, though, the compiler is smart enough not to inline \"complex code that makes more sense as a function call\".  You shouldn't have to worry about it, just let the optimizer do its thing.</p>\n<p>Portable inlining control isn't beneficial, because the trade-offs of inlining are very platform-specific.  The optimizers should already be aware of those platform-specific tradeoffs, and if you do feel the need to override the compiler's choice, do so on a per-platform basis.</p>\n</hr>", "LastEditorUserId": "103167", "LastActivityDate": "2012-07-14T14:50:56.983", "Score": "8", "CreationDate": "2012-07-10T19:51:52.747", "ParentId": "11420802", "CommentCount": "13", "OwnerUserId": "103167", "LastEditDate": "2012-07-14T14:50:56.983"}, "11470880": {"Id": "11470880", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_11420802_11470880_0\">1. Does it make any sense to mark the definition of a template function with inline in view of the fact that, as I've recently learnt, it is going to be automatically qualified as inline by the compiler regardless of whether it's marked with inline or not? Is the behavior compiler-specific?</p>\n</blockquote>\n<p>I think you are referring to the fact that a member function defined in its class definition is always an <em>inline</em> function. This is per the C++ Standard, and has been since the first publication:</p>\n<blockquote>\n<p id=\"so_11420802_11470880_1\"><strong>9.3 Member functions</strong></p>\n<p id=\"so_11420802_11470880_2\">...</p>\n<p id=\"so_11420802_11470880_3\">A member function may be defined (8.4) in its class definition, in which case it is an <em>inline</em> member function (7.1.2)</p>\n</blockquote>\n<p>So, in the following example, <code>template &lt;typename FloatT&gt; my_class&lt;FloatT&gt;::my_function()</code> is always an <em>inline</em> function:</p>\n<pre><code>template &lt;typename FloatT&gt;\nclass my_class\n{\npublic:\n    void my_function() // `inline` member function\n    {\n        //...\n    }\n};\n\ntemplate &lt;&gt;\nclass my_class&lt;double&gt; // specialization for doubles\n{\npublic:\n    void my_function() // `inline` member function\n    {\n        //...\n    }\n};\n</code></pre>\n<p>However, by moving the definition of <code>my_function()</code> outside of the definition of <code>template &lt;typename FloatT&gt; my_class&lt;FloatT&gt;</code>, it is not automatically an <em>inline</em> function:</p>\n<pre><code>template &lt;typename FloatT&gt;\nclass my_class\n{\npublic:\n    void my_function();\n};\n\ntemplate &lt;typename FloatT&gt;\nvoid my_class&lt;FloatT&gt;::my_function() // non-`inline` member function\n{\n    //...\n}\n\ntemplate &lt;&gt;\nvoid my_class&lt;double&gt;::my_function() // non-`inline` member function\n{\n    //...\n}\n</code></pre>\n<p>In the latter example, it does make sense (as in, it's not redundant) to use the <code>inline</code> specifier with the definitions:</p>\n<pre><code>template &lt;typename FloatT&gt;\ninline void my_class&lt;FloatT&gt;::my_function() // `inline` member function\n{\n    //...\n}\n\ntemplate &lt;&gt;\ninline void my_class&lt;double&gt;::my_function() // `inline` member function\n{\n    //...\n}\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_11420802_11470880_4\">2. And most importantly, since I would like to have the definitions of all the member functions of a template class gathered together in a single file, either it's .inl or .cpp (using explicit instantiation in case of .cpp), preferably still being able to hint the compiler (MSVC and GCC) which of the functions should be inlined and which shouldn't, sure if such thing is possible with template functions, how can I achieve this or, if there is really no way (I hope there is), what would be the most optimal compromise?</p>\n</blockquote>\n<p>As you know, the compiler may elect to inline a function, whether or not it has the <code>inline</code> specifier; the <code>inline</code> specifier is just a hint.</p>\n<p>There is no standard way to force inlining or prevent inlining; however, most C++ compilers support syntactic extensions for accomplishing just that. MSVC supports a <a href=\"http://msdn.microsoft.com/en-US/library/z8y1yy88%28v=vs.100%29.aspx\" rel=\"nofollow\"><code>__forceinline</code></a> keyword to force inlining and <code>#pragma auto_inline(off)</code> to prevent it. G++ supports <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.2.1/gcc/Inline.html\" rel=\"nofollow\"><code>always_inline</code></a> and <code>noinline</code> attributes for forcing and preventing inlining, respectively. You should refer to your compiler's documentation for details, including how to enable diagnostics when the compiler is unable to inline a function as requested.</p>\n<p>If you use those compiler extensions, then you should be able to hint to the compiler whether a function is inlined or not.</p>\n<p>In general, I recommend to have all \"simple\" member function definitions gathered together in a single file (usually the header), by which I mean, if the member function does not require very many more <code>#include</code>s above the set of <code>#include</code>s required to define the classes/templates. Sometimes, for example, a member function definition will require <code>#include &lt;algorithm&gt;</code>, but it is unlikely that the class definition requires <code>&lt;algorithm&gt;</code> to be included in order to be defined. Your compiler is able to skip over function definitions that it does not use, but the larger number of <code>#include</code>s can noticeably lengthen compile times, and it is unlikely that you will want to inline these non-\"simple\" functions anyway.</p>\n<hr>\n<blockquote>\n<p id=\"so_11420802_11470880_5\">3. If compilers are so smart these days that they can make better choices about which function should be inlined and which should be called and are capable of link-time code generation and link-time optimization, which effectively allows them looking into a .cpp-located function definition at link time to decide its fate about being inlined or called, then maybe a good solution would be simply moving all the definitions into respective .cpp files?</p>\n</blockquote>\n<p>If you place all of your function definitions into CPP files, then you will be relying on LTO for mostly all function inlining. This may not be what you want for the following reasons:</p>\n<ol>\n<li>At least with MSVC's LTCG, you give up the ability to force inlining (See <a href=\"http://msdn.microsoft.com/en-us/library/z8y1yy88.aspx\" rel=\"nofollow\">inline, __inline, __forceinline</a>.)</li>\n<li>If the CPP files are linked to a shared library, then programs linking with the shared libraries will not benefit from LTO inlining of library functions. This is because the compiler intermediate language (IL)\u2014the input to LTO\u2014has been discarded and is not available in the DLL or SO.</li>\n<li>If <a href=\"http://msdn.microsoft.com/en-us/magazine/cc301698.aspx\" rel=\"nofollow\">Under The Hood: Link-time Code Generation</a> is still correct, \"calls to functions in static libraries can't be optimized\".</li>\n<li>The linker would be performing all inlining, which might be a lot slower than having the compiler perform some inlining at compile time.</li>\n<li>The compiler's LTO implementation might have bugs that cause it to not inline certain functions.</li>\n<li>Use of LTO might impose certain limitations on projects using your library. For example, according to <a href=\"http://msdn.microsoft.com/en-us/magazine/cc301698.aspx\" rel=\"nofollow\">Under The Hood: Link-time Code Generation</a>, \"precompiled headers and LTCG are incompatible\". The <a href=\"http://msdn.microsoft.com/en-us/library/xbf3tbeh.aspx\" rel=\"nofollow\">/LTCG (Link-time Code Generation)</a> MSDN page has other notes, such as \"/LTCG is not valid for use with /INCREMENTAL\".</li>\n</ol>\n<p>If you keep the likely-to-be-inlined function definitions in the header files, then you could use <em>both</em> compiler inlining and LTO. On the other hand, moving all function definitions into CPP files will restrict compiler inlining to only within the translation units.</p>\n</hr></hr>", "LastEditorUserId": "944687", "LastActivityDate": "2012-07-14T12:56:58.857", "Score": "5", "CreationDate": "2012-07-13T12:51:04.870", "ParentId": "11420802", "CommentCount": "3", "OwnerUserId": "196844", "LastEditDate": "2012-07-14T12:56:58.857"}, "11481800": {"Id": "11481800", "PostTypeId": "2", "Body": "<p>This is not a complete answer.</p>\n<p>I read that clang and llvm are able to do very comprehensive link time optimization. This includes link time inlining! To enable this, compile with optimization level -O4 when using clang++. The object files will be llvm bytecode instead of machine code. This is what makes this possible. This feature should therefore allow you to put all of your definitions in the cpp files, knowing that they will still be inlined where necessary.</p>\n<p>Btw, the length of a function body is not the only thing that determines whether it will be inlined. A lengthy function that is only called from one location can easily be inlined at that location.</p>\n", "LastActivityDate": "2012-07-14T07:12:21.103", "CommentCount": "0", "CreationDate": "2012-07-14T07:12:21.103", "ParentId": "11420802", "Score": "1", "OwnerUserId": "1281122"}, "11462185": {"Id": "11462185", "PostTypeId": "2", "Body": "<ol>\n<li><p>I don't know where you learnt that, but templates are not \"automatically qualified as inline by the compiler regardless of whether it's marked with inline or not\".  Templates and inline functions both have what is sometimes called \"<a href=\"http://gcc.gnu.org/onlinedocs/gcc/Vague-Linkage.html\" rel=\"nofollow\">vague linkage</a>\" meaning their definitions can be present in multiple objects without error and the linker will use one of the definitions and discard the others. But the fact templates and inline functions both have vague linkage doesn't mean templates are automatically inline.  Lions and tigers are both big cats but that doesn't mean lions are tigers.</p></li>\n<li><p>Unless you know all the instantiations you are using in advance you can't always use explicit instantiation e.g. if you're writing a template library for others to use then you can't provide all the explicit instantiations, so you <em>must</em> define the template in <code>.h</code> (or <code>.inl</code>) files that the user of the code can <code>#include</code>.  If you do know all the instantiations in advance then using explicit instantiations in <code>.cpp</code> files has the advantage of improving compilation time, because the compiler only instantiates the templates once in the file containing the explicit instantiations, not in every file that uses them.  But that has nothing to do with inlining. For a function to be inlined its definition <em>must</em> be visible to the code calling it, so if you only define function templates (or member functions of class templates) in a <code>.cpp</code> file then they can't be inlined anywhere except in that file. If you define them in a <code>.cpp</code> file and <em>do</em> qualify them as <code>inline</code> then you might cause problems trying to call them from other files, which can't see the <code>inline</code> keyword (if a function is declared inline in one translation unit it must be declared inline in all translation units in which it appears, [dcl.fct.spec]/4.)<br>\nFor what it's worth, I don't generally bother using <code>.inl</code> files, I just define templates directly in <code>.h</code> files, which gives one less file to deal with.  Everything's in one place, and it just works, all files that use the templates can see the definitions and choose to inline them if desired.  You can still use explicit instantiations in that case too, to improve compilation time and reduce object file size, without sacrificing inlining opportunites.</br></p></li>\n<li><p>Why would that be better than just defining your template code in headers, where it belongs? What exactly are you trying to achieve? If it's fewer files, put the template code in headers, that will always work, the compiler can choose to inline everything without needing LTO, and you only have one file per class template  (and you can still use explicit instantiation to improve compilation times).  If you're trying to move all your code into <code>.cpp</code> files (which I think you're focusing on too much) then go ahead and do it. I think it's a bad idea, and will probably cause problems (link-time optimisation still has issues with the only compiler I've tried using it with, and certainly won't make compilation any faster) but if that's what you want, do whatever floats your boat.</p></li>\n</ol>\n<p>It seems like your questions revolve around a misunderstanding here:</p>\n<blockquote>\n<p id=\"so_11420802_11462185_0\">I would have all my class implementations in .inl files only if I knew a reliable way to prevent some functions from being inlined, </p>\n</blockquote>\n<p>If all your template definitions are in header files you don't need \"a reliable way to prevent some functions from being inlined\" ... as I said above, templates are not automatially <code>inline</code> just because they're in headers, and if they're too large to inline the compiler won't inline them. First problem solved.  Secondly:</p>\n<blockquote>\n<p id=\"so_11420802_11462185_1\">or in .cpp files if inline keyword could strongly suggest compiler to inline some of the functions, which, of course, it does not, especially if a function marked with inline is located in a .cpp file.</p>\n</blockquote>\n<p>As I said above, a function marked <code>inline</code> in a <code>.cpp</code> file is ill-formed unless it's also marked inline in the header, and never used in any other <code>.cpp</code> file. So doing this is just making life difficult and possibly causing linker errors. Why bother.</p>\n<p>Again, all signs point to just put your template definitions in headers.  You can still use explicit instantiation (as GCC does for <code>std::string</code>, as mentioned in the post you link to) so you get the best of both worlds. The only thing it doesn't achieve is hiding the implementations from users of the templates, but it doesn't sound like that's your aim anyway, if it is then provide non-template function API, which can be implemented in terms of templates in a single <code>.cpp</code> file.</p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2012-07-13T17:40:27.747", "Score": "3", "CreationDate": "2012-07-12T23:28:51.307", "ParentId": "11420802", "CommentCount": "8", "OwnerUserId": "981959", "LastEditDate": "2012-07-13T17:40:27.747"}, "11420802": {"ViewCount": "1106", "Body": "<p>I'm maintaining a large library of template classes that perform algebraic computations based on either <code>float</code> or <code>double</code> type. Many of the classes have accessor methods (getters and setters) and other functions that run small amounts of code, therefore such functions need to be qualified as inline when the compiler locates their definitions. Other member functions, in contrast, contain sophisticated code and thus would better be called rather than inlined.</p>\n<p>A substantial part of the function definitions are located in headers, actually in .inl files included by headers. But there are also many classes whose function definitions happily live in .cpp files by means of explicit instantiation for <code>float</code> and <code>double</code>, which is rather a good thing to do in case of a library (<a href=\"https://stackoverflow.com/questions/2351148/explicit-instantiation\">here</a> explained why). And finally, there is a considerable number of classes whose function definitions are broken across .inl files (accessor methods) and .cpp files (constructors, destructors, and heavy computations), which makes them all pretty difficult to maintain.</p>\n<p>I would have all my class implementations in .inl files only if I knew a reliable way to prevent some functions from being inlined, or in .cpp files if <code>inline</code> keyword could strongly suggest compiler to inline some of the functions, which, of course, it does not. I would really prefer all the function definitions in the library to reside in .cpp files, but since accessor methods are used extensively throughout the library, I have to make sure they are inlined whenever referenced, not called.</p>\n<p>So, in this connection, my questions are:</p>\n<ol>\n<li><p>Does it make any sense to mark the definition of a template function with <code>inline</code> in view of the fact that, as I've recently learnt <a href=\"https://stackoverflow.com/questions/11416747/multiple-definitions-of-a-non-template-class-vs-a-template-class\">here</a>, it is going to be automatically qualified as inline by the compiler regardless of whether it's marked with <code>inline</code> or not?</p></li>\n<li><p>And <em>most importantly</em>, since I would like to have the definitions of all the member functions of a template class gathered <em>together in a single file</em>, either it's .inl or .cpp (using explicit instantiation in case of .cpp), preferably <em>still</em> being able to hint the compiler (MSVC and GCC) which of the functions should be inlined <em>and</em> which shouldn't, sure if such thing is possible with template functions, <em>how can I achieve this or,</em> if there is really no way (I hope there is), <em>what would be the most optimal compromise?</em></p></li>\n</ol>\n<h2>----------</h2>\n<p><em>EDIT1:</em> I knew that <code>inline</code> keyword is just a suggestion to the compiler to inline a function.</p>\n<p><em>EDIT2:</em> I really do know. I like making suggestions to the compiler.</p>\n<p><em>EDIT3:</em> I still know. It's not what the question is about.</p>\n<h2>----------</h2>\n<p><em>In view of some new information, there is also third question that goes hand in hand with the second one.</em></p>\n<p><em>3.</em> If compilers are so smart these days that they can make better choices about which function should be inlined and which should be called <em>and</em> are capable of link-time code generation and link-time optimization, which effectively allows them looking into a .cpp-located function definition at link time to decide its fate about being inlined or called, then maybe a good solution would be simply moving all the definitions into respective .cpp files?</p>\n<h2>----------</h2>\n<p><strong>So what's the conclusion?</strong></p>\n<p>First of all, I'm grateful to Daniel Trebbien and Jonathan Wakely for their structured and well-founded answers. Upvoted both but had to choose just one. None of the given answers, however, presented an acceptable solution to me, so the chosen answer happened to be the one that helped me slightly more than others in making the final decision, the details of which are explained next for anyone who's interested.</p>\n<p>Well, since I've always been valuing the performance of code more than how much convenient it is to maintain and develop, it appears to me that the most acceptable compromise would be to move all the accessor methods and other lightweight member functions of each of the template classes into the .inl file included by the respective header, marking these functions with <code>inline</code> keyword in an attempt to provide the compiler with a good hint (or with a keyword for inline forcing), and move the rest of the functions into the respective .cpp file.</p>\n<p>Having all member function definitions located in .cpp files would hinder inlining of lightweight functions while unleashing some problems with link-time optimization, as has been ascertained by Daniel Trebbien for MSVC (in an older stage of development) and by Jonathan Wakely for GCC (in its current stage of development). And having all function definitions located in headers (or .inl files) doesn't outweigh the summary benefit of having the implementation of each class sorted into .inl and .cpp files combined with a bonus side effect of this decision: it would ensure that only the code of primitive accessor methods is visible to a client of the library, while more juicy stuff is hidden in the binaries (ensuring this wasn't a major reason, however, but this plus was obvious for anyone who is familiar with software libraries). And any lightweight member function that doesn't need to be exposed by the include files of the library and is used privately by its class can have its definition in the .cpp file of the class, while its declaration/definition is spiced with <code>inline</code> to encourage the inline status of the function (don't know yet whether the keyword should be in both places or just one in this particular case).</p>\n", "AcceptedAnswerId": "11470880", "Title": "Code organization across files that has to deal with template functions and inlining", "CreationDate": "2012-07-10T19:48:18.027", "Id": "11420802", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:34:29.093", "LastEditorUserId": "-1", "LastActivityDate": "2012-07-14T19:56:07.773", "Score": "4", "OwnerUserId": "944687", "Tags": "<c++><templates><compiler-construction><inline>", "AnswerCount": "4"}});