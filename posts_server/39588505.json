post_cb({"bq_ids": {"n4140": {"so_39588505_39590178_0": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_39588505_39588505_4": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_39588505_39588505_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 3325}, "so_39588505_39590178_1": {"length": 6, "quality": 1.0, "section_id": 3325}}, "n3337": {"so_39588505_39590178_0": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_39588505_39588505_4": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_39588505_39588505_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 3195}, "so_39588505_39590178_1": {"length": 6, "quality": 1.0, "section_id": 3195}}, "n4659": {"so_39588505_39590178_0": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_39588505_39588505_4": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_39588505_39588505_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 4048}, "so_39588505_39590178_1": {"length": 6, "quality": 1.0, "section_id": 4091}}}, "39590178": {"Id": "39590178", "PostTypeId": "2", "Body": "<p>As a result of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1301\" rel=\"nofollow\">Core Issue 1301</a>, which was a defect against C++11, the precedence for list-initialization changed from:</p>\n<blockquote>\n<p id=\"so_39588505_39590178_0\">List-initialization of an object or reference of type T is defined as follows:</p>\n<ul>\n<li>If the initializer list has no elements and T is a class type with a default constructor, the object is value-initialized.</li>\n<li>Otherwise, if T is an aggregate, aggregate initialization is performed (8.5.1)</li>\n</ul>\n</blockquote>\n<p>to:</p>\n<blockquote>\n<p id=\"so_39588505_39590178_1\">List-initialization of an object or reference of type T is defined as follows:</p>\n<ul>\n<li>If T is an aggregate, aggregate initialization is performed (8.5.1)  </li>\n<li>Otherwise, if the initialize list has no elements and T is a class type with a default constructor, the object is value-initialized.</li>\n</ul>\n</blockquote>\n<p>So <code>foo{}</code> in Scenario A is still aggregate-initialization.</p>\n", "LastActivityDate": "2016-09-20T09:17:38.890", "CommentCount": "3", "CreationDate": "2016-09-20T09:17:38.890", "ParentId": "39588505", "Score": "3", "OwnerUserId": "2069064"}, "39588505": {"ViewCount": "131", "Body": "<p>I try to understand the first accepted answer of @bolov to the question <a href=\"https://stackoverflow.com/questions/33988297/deleted-default-constructor-objects-can-still-be-created-sometimes\">Deleted default constructor. Objects can still be created... sometimes</a> [1]</p>\n<p>It seems like I found a error there and so it messes up the whole explanation.</p>\n<p>@bolov explains why this code SUCCEED to be compiled in c++11:</p>\n<p><strong>Scenario A</strong></p>\n<pre><code>struct foo {\n  foo() = delete;\n};\n\n// All bellow OK (no errors, no warnings)\nfoo f = foo{};\nfoo f = {};\nfoo f{}; // will use only this from now on.\n</code></pre>\n<p>And why this code FAILS to be compiled in c++11:</p>\n<p><strong>Scenario C</strong></p>\n<pre><code>struct foo {\n  foo() = delete;\n  foo(int) {};\n};\n\nfoo f{}; // error call to deleted constructor\n</code></pre>\n<p>He says that the point is that the first one foo is an aggregate and the second one foo is not an aggregate. </p>\n<p>Then he gives the excerpt from cppreference:</p>\n<blockquote>\n<p id=\"so_39588505_39588505_0\">The effects of list initialization of an object of type T are:\n          ...</p>\n<ul>\n<li>If T is an aggregate type, aggregate initialization is performed. This takes care of scenarios A B D E (and F in C++14)</li>\n<li><p id=\"so_39588505_39588505_1\">Otherwise the constructors of T are considered in two phases:</p>\n<ul>\n<li><p id=\"so_39588505_39588505_2\">All constructors that take std::initializer_list ...</p></li>\n<li><p id=\"so_39588505_39588505_3\">otherwise [...] all constructors of T participate in overload resolution [...] This takes care of C (and F in C++11)\n  ...</p></li>\n</ul></li>\n</ul>\n</blockquote>\n<p>According to the excerpt when you write <em>foo f { };</em> in <strong>scenario A</strong> you get aggregate-initialization. An it would be great. But in reality in c++11 (#3337 draft, closest to standard) you have <strong>different initialization order</strong>:</p>\n<blockquote>\n<p id=\"so_39588505_39588505_4\">List-initialization of an object or reference of type T is defined as follows:</p>\n<ul>\n<li>If the initializer list has no elements and T is a class type with a default constructor, the object is value-initialized.</li>\n<li>Otherwise, if T is an aggregate, aggregate initialization is performed (8.5.1)</li>\n</ul>\n</blockquote>\n<p>So <em>foo f { };</em> in <strong>scenario A</strong> should result in value-initialization, that is, the DELETED default constructor will be called and the code should fail to be compiled.</p>\n", "AcceptedAnswerId": "39590178", "Title": "c++11 value-initialization prior to aggregate-initialization", "CreationDate": "2016-09-20T07:49:23.297", "Id": "39588505", "CommentCount": "6", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:27:24.720", "LastEditorUserId": "-1", "LastActivityDate": "2016-09-20T09:38:00.753", "Score": "4", "OwnerUserId": "4781940", "Tags": "<c++><c++11><aggregate><language-lawyer><value-initialization>", "AnswerCount": "1"}});