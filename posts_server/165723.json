post_cb({"168103": {"CommentCount": "0", "CreationDate": "2008-10-03T17:54:54.633", "LastEditorUserId": "-1", "LastActivityDate": "2009-01-17T19:40:13.847", "ParentId": "165723", "PostTypeId": "2", "LastEditorDisplayName": "J.F. Sebastian", "LastEditDate": "2017-05-23T10:30:54.447", "Id": "168103", "Score": "4", "Body": "<p>A modification of <a href=\"https://stackoverflow.com/questions/165723/do-programmers-of-other-languages-besides-c-use-know-or-understand-raii#165991\">@Pierre's answer</a>:</p>\n<p>In Python:</p>\n<pre><code>with open(\"foo.txt\", \"w\") as f:\n    f.write(\"abc\")\n</code></pre>\n<p><code>f.close()</code> is called automatically whether an exception were raised or not.</p>\n<p>In general it can be done using <a href=\"http://www.python.org/doc/2.5.2/lib/module-contextlib.html\" rel=\"nofollow noreferrer\">contextlib.closing</a>, from the documenation:</p>\n<blockquote>\n<p id=\"so_165723_168103_0\"><code>closing(thing)</code>:  return a context\n  manager that closes thing upon\n  completion of the block. This is\n  basically equivalent to:</p>\n<pre><code>from contextlib import contextmanager\n\n@contextmanager\ndef closing(thing):\n    try:\n        yield thing\n    finally:\n        thing.close()\n</code></pre>\n<p id=\"so_165723_168103_1\">And lets you write code like this:</p>\n<pre><code>from __future__ import with_statement # required for python version &lt; 2.6\nfrom contextlib import closing\nimport urllib\n\nwith closing(urllib.urlopen('http://www.python.org')) as page:\n    for line in page:\n        print line\n</code></pre>\n<p id=\"so_165723_168103_2\">without needing to explicitly close\n  page. Even if an error occurs,\n  page.close() will be called when the\n  with block is exited.</p>\n</blockquote>\n", "OwnerUserId": "4279", "OwnerDisplayName": "J.F. Sebastian"}, "165764": {"CommentCount": "0", "CreationDate": "2008-10-03T05:16:22.423", "LastEditorUserId": "-1", "LastActivityDate": "2012-03-02T01:46:49.110", "ParentId": "165723", "PostTypeId": "2", "LastEditorDisplayName": "Martin York", "LastEditDate": "2017-05-23T11:55:13.833", "Id": "165764", "Score": "9", "Body": "<p>RAII.</p>\n<p>It starts with a constructor and destructor but it is more than that.<br>\nIt is all about safely controlling resources in the presence of exceptions.<br/></br></p>\n<p>What makes RAII superior to finally and such mechanisms is that it makes code safer to use because it moves responsibility for using an object correctly from the user of the object to the designer of the object.</p>\n<p><a href=\"https://stackoverflow.com/questions/161177/does-c-support-finally-blocks-and-whats-this-raii-i-keep-hearing-about#161247\">Read this</a></p>\n<p>Example to use <a href=\"https://stackoverflow.com/questions/165723/do-programmers-of-other-languages-besides-c-use-know-or-understand-raii#165743\">StdioFile</a> correctly using RAII.</p>\n<pre><code>void someFunc()\n{\n    StdioFile    file(\"Plop\",\"r\");\n\n    // use file\n}\n// File closed automatically even if this function exits via an exception.\n</code></pre>\n<p>To get the same functionality with finally.</p>\n<pre><code>void someFunc()\n{\n      // Assuming Java Like syntax;\n    StdioFile     file = new StdioFile(\"Plop\",\"r\");\n    try\n    {\n       // use file\n    }\n    finally\n    {\n       // close file.\n       file.close(); // \n       // Using the finaliser is not enough as we can not garantee when\n       // it will be called.\n    }\n}\n</code></pre>\n<p>Because you have to explicitly add the try{} finally{} block this makes this method of coding more error prone (<b>i.e.</b> it is the user of the object that needs to think about exceptions). By using RAII exception safety has to be coded once when the object is implemented.</p>\n<p>To the question is this C++ specific.<br>\nShort Answer: No.<br/></br></p>\n<p>Longer Answer:<br>\nIt requires Constructors/Destructors/Exceptions and objects that have a defined lifetime.</br></p>\n<p>Well technically it does not need exceptions. It just becomes much more useful when exceptions could potentially be used as it makes controlling the resource in the presence of exceptions very easy.<br>\nBut it is useful in all situations where control can leave a function early and not execute all the code (<b>e.g.</b> early return from a function. This is why multiple return points in C is a bad code smell while multiple return points in C++ is not a code smell [because we can clean up using RAII]).</br></p>\n<p>In C++ controlled lifetime is achieved by stack variables or smart pointers. But this is not the only time we can have a tightly controlled lifespan. For example Perl objects are not stack based but have a very controlled lifespan because of reference counting.</p>\n", "OwnerUserId": "14065", "OwnerDisplayName": "Martin York"}, "166461": {"ParentId": "165723", "CommentCount": "0", "Body": "<p>I use C++\u02da RAII all the time but I've also developed in VB6 for a long time and RAII has always been a widely-used concept there (although I've never heard anyone call it that).</p>\n<p>In fact, many VB6 programs rely on RAII quite heavily. One of the more curious uses that I've repeatedly seen is the following small class:</p>\n<pre><code>' WaitCursor.cls '\nPrivate m_OldCursor As MousePointerConstants\n\nPublic Sub Class_Inititialize()\n    m_OldCursor = Screen.MousePointer\n    Screen.MousePointer = vbHourGlass\nEnd Sub\n\nPublic Sub Class_Terminate()\n    Screen.MousePointer = m_OldCursor\nEnd Sub\n</code></pre>\n<p>Usage:</p>\n<pre><code>Public Sub MyButton_Click()\n    Dim WC As New WaitCursor\n\n    ' \u2026 Time-consuming operation. '\nEnd Sub\n</code></pre>\n<p>Once the time-consuming operation terminates, the original cursor gets restored automatically.</p>\n", "OwnerUserId": "1968", "Id": "166461", "PostTypeId": "2", "OwnerDisplayName": "Konrad Rudolph", "Score": "19", "CreationDate": "2008-10-03T11:44:58.343", "LastActivityDate": "2008-10-03T11:44:58.343"}, "165736": {"ParentId": "165723", "CommentCount": "0", "Body": "<p>I think a lot of other languages (ones that don't have <code>delete</code>, for example) don't give the programmer quite the same control over object lifetimes, and so there must be other means to provide for deterministic disposal of resources. In C#, for example, using <code>using</code> with <code>IDisposable</code> is common.</p>\n", "OwnerUserId": "13", "Id": "165736", "PostTypeId": "2", "OwnerDisplayName": "Chris Jester-Young", "Score": "0", "CreationDate": "2008-10-03T04:54:22.570", "LastActivityDate": "2008-10-03T04:54:22.570"}, "165749": {"CommentCount": "5", "CreationDate": "2008-10-03T05:02:31.207", "LastEditorUserId": "15124", "LastActivityDate": "2008-10-03T06:39:47.307", "ParentId": "165723", "PostTypeId": "2", "LastEditorDisplayName": "Robert Gould", "LastEditDate": "2008-10-03T06:39:47.307", "Id": "165749", "Score": "2", "Body": "<p>First of all I'm very surprised it's not more well known! I totally thought RAII was, at least, obvious to C++ programmers. \nHowever now I guess I can understand why people actually ask about it. I'm surrounded, and my self must be, C++ freaks...</p>\n<p>So my secret.. I guess that would be, that I used to read Meyers, Sutter [EDIT:] and Andrei all the time years ago until I just grokked it.</p>\n", "OwnerUserId": "15124", "OwnerDisplayName": "Robert Gould"}, "165743": {"CommentCount": "6", "CreationDate": "2008-10-03T04:58:38.707", "LastEditorUserId": "13", "LastActivityDate": "2010-08-18T18:21:35.903", "ParentId": "165723", "PostTypeId": "2", "LastEditorDisplayName": "Chris Jester-Young", "LastEditDate": "2010-08-18T18:21:35.903", "Id": "165743", "Score": "11", "Body": "<p>For people who are commenting in this thread about RAII (resource acquisition is initialisation), here's a motivational example.</p>\n<pre><code>class StdioFile {\n    FILE* file_;\n    std::string mode_;\n\n    static FILE* fcheck(FILE* stream) {\n        if (!stream)\n            throw std::runtime_error(\"Cannot open file\");\n        return stream;\n    }\n\n    FILE* fdup() const {\n        int dupfd(dup(fileno(file_)));\n        if (dupfd == -1)\n            throw std::runtime_error(\"Cannot dup file descriptor\");\n        return fdopen(dupfd, mode_.c_str());\n    }\n\npublic:\n    StdioFile(char const* name, char const* mode)\n        : file_(fcheck(fopen(name, mode))), mode_(mode)\n    {\n    }\n\n    StdioFile(StdioFile const&amp; rhs)\n        : file_(fcheck(rhs.fdup())), mode_(rhs.mode_)\n    {\n    }\n\n    ~StdioFile()\n    {\n        fclose(file_);\n    }\n\n    StdioFile&amp; operator=(StdioFile const&amp; rhs) {\n        FILE* dupstr = fcheck(rhs.fdup());\n        if (fclose(file_) == EOF) {\n            fclose(dupstr); // XXX ignore failed close\n            throw std::runtime_error(\"Cannot close stream\");\n        }\n        file_ = dupstr;\n        return *this;\n    }\n\n    int\n    read(std::vector&lt;char&gt;&amp; buffer)\n    {\n        int result(fread(&amp;buffer[0], 1, buffer.size(), file_));\n        if (ferror(file_))\n            throw std::runtime_error(strerror(errno));\n        return result;\n    }\n\n    int\n    write(std::vector&lt;char&gt; const&amp; buffer)\n    {\n        int result(fwrite(&amp;buffer[0], 1, buffer.size(), file_));\n        if (ferror(file_))\n            throw std::runtime_error(strerror(errno));\n        return result;\n    }\n};\n\nint\nmain(int argc, char** argv)\n{\n    StdioFile file(argv[1], \"r\");\n    std::vector&lt;char&gt; buffer(1024);\n    while (int hasRead = file.read(buffer)) {\n        // process hasRead bytes, then shift them off the buffer\n    }\n}\n</code></pre>\n<p>Here, when a <code>StdioFile</code> instance is created, the resource (a file stream, in this case) is acquired; when it's destroyed, the resource is released. There is no <code>try</code> or <code>finally</code> block required; if the reading causes an exception, <code>fclose</code> is called automatically, because it's in the destructor.</p>\n<p>The destructor is guaranteed to be called when the function leaves <code>main</code>, whether normally or by exception. In this case, the file stream is cleaned up. The world is safe once again. :-D</p>\n", "OwnerUserId": "13", "OwnerDisplayName": "Chris Jester-Young"}, "396344": {"ParentId": "165723", "CommentCount": "0", "Body": "<p>The problem with RAII is the acronym. It has no obvious correlation to the concept. What does this have to do with stack allocation? That is what it comes down to. C++ gives you the ability to allocate objects on the stack and guarantee that their destructors are called when the stack is unwound. In light of that, does RAII sound like a meaningful way of encapsulating that? No. I never heard of RAII until I came here a few weeks ago, and I even had to laugh hard when I read someone had posted that they would never hire a C++ programmer who'd didn't know what RAII was. Surely the concept is well known to most all competent professional C++ developers. It's just that the acronym is poorly conceived.</p>\n", "OwnerUserId": "44996", "Id": "396344", "PostTypeId": "2", "OwnerDisplayName": "ApplePieIsGood", "Score": "8", "CreationDate": "2008-12-28T16:07:58.863", "LastActivityDate": "2008-12-28T16:07:58.863"}, "194380": {"ParentId": "165723", "CommentCount": "0", "Body": "<p>I have colleagues who are hard-core, \"read the spec\" C++ types.  Many of them know RAII but I have never really heard it used outside of that scene.</p>\n", "OwnerUserId": "12704", "Id": "194380", "PostTypeId": "2", "OwnerDisplayName": "Michael Easter", "Score": "0", "CreationDate": "2008-10-11T18:00:59.800", "LastActivityDate": "2008-10-11T18:00:59.800"}, "165991": {"CommentCount": "6", "CreationDate": "2008-10-03T07:24:34.283", "LastEditorUserId": "-1", "LastActivityDate": "2008-10-03T07:24:34.283", "ParentId": "165723", "LastEditDate": "2017-05-23T12:10:49.493", "OwnerDisplayName": "Pierre", "PostTypeId": "2", "Id": "165991", "Score": "1", "Body": "<p>RAII is a way in C++ to make sure a cleanup procedure is executed after a block of code regardless of what happens in the code: the code executes till the end properly or raises an exception. An already cited example is automatically closing a file after its processing, see <a href=\"https://stackoverflow.com/questions/165723/do-programmers-of-other-languages-besides-c-use-know-or-understand-raii#165743\">answer here</a>.</p>\n<p>In other languages you use other mechanism to achieve that.</p>\n<p>In Java you have try { } finally {} constructs:</p>\n<pre><code>try {\n  BufferedReader file = new BufferedReader(new FileReader(\"infilename\"));\n  // do something with file\n}\nfinally {\n    file.close();\n}\n</code></pre>\n<p>In Ruby you have the automatic block argument:</p>\n<pre><code>File.open(\"foo.txt\") do | file |\n  # do something with file\nend\n</code></pre>\n<p>In Lisp you have <code>unwind-protect</code> and the predefined <code>with-XXX</code></p>\n<pre><code>(with-open-file (file \"foo.txt\")\n  ;; do something with file\n)\n</code></pre>\n<p>In Scheme you have <code>dynamic-wind</code> and the predefined <code>with-XXXXX</code>:</p>\n<pre><code>(with-input-from-file \"foo.txt\"\n  (lambda ()\n    ;; do something \n)\n</code></pre>\n<p>in Python you have try finally</p>\n<pre><code>try\n  file = open(\"foo.txt\")\n  # do something with file\nfinally:\n  file.close()\n</code></pre>\n<p>The C++ solution as RAII is rather clumsy in that it forces you to create one class for all kinds of cleanup you have to do. This may forces you to write a lot of small silly classes.</p>\n<p>Other examples of RAII are:</p>\n<ul>\n<li>unlocking a mutex after acquisition</li>\n<li>closing a database connection after opening</li>\n<li>freeing memory after allocation</li>\n<li>logging on entry and exit of a block of code</li>\n<li>...</li>\n</ul>\n", "OwnerUserId": "24449"}, "165723": {"CommentCount": "3", "ViewCount": "5948", "OwnerDisplayName": "Robert Gould", "CreationDate": "2008-10-03T04:48:44.563", "LastActivityDate": "2017-03-21T14:05:36.580", "PostTypeId": "1", "AcceptedAnswerId": "165743", "FavoriteCount": "7", "Title": "Do programmers of other languages, besides C++, use, know or understand RAII?", "Id": "165723", "Score": "31", "Body": "<p>I've noticed RAII has been getting lots of attention on Stackoverflow, but in my circles (mostly C++) RAII is so obvious its like asking what's a class or a destructor.</p>\n<p>So I'm really curious if that's because I'm surrounded daily, by hard-core C++ programmers, and RAII just isn't that well known in general (including C++), or if all this questioning on Stackoverflow is due to the fact that I'm now in contact with programmers that didn't grow up with C++, and in other languages people just don't use/know about RAII?</p>\n", "Tags": "<c++><language-agnostic><raii>", "OwnerUserId": "15124", "AnswerCount": "17"}, "bq_ids": {"n4140": {"so_165723_168103_1": {"section_id": 6433, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_165723_168103_1": {"section_id": 6190, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_165723_168103_1": {"section_id": 6440, "quality": 0.6666666666666666, "length": 4}}}, "165742": {"ParentId": "165723", "CommentCount": "7", "Body": "<p>RAII is popular in C++ because it's one of the few (only?) languages that can allocate complex scope-local variables, but does not have a <code>finally</code> clause. C#, Java, Python, Ruby all have <code>finally</code> or an equivalent. C hasn't <code>finally</code>, but also can't execute code when a variable drops out of scope.</p>\n", "OwnerUserId": "3560", "Id": "165742", "PostTypeId": "2", "OwnerDisplayName": "John Millikin", "Score": "0", "CreationDate": "2008-10-03T04:58:19.563", "LastActivityDate": "2008-10-03T04:58:19.563"}, "165744": {"ParentId": "165723", "CommentCount": "1", "Body": "<p>RAII is specific to C++. C++ has the requisite combination of stack-allocated objects, unmanaged object lifetimes, and exception handling.</p>\n", "OwnerUserId": "12349", "Id": "165744", "PostTypeId": "2", "OwnerDisplayName": "Justice", "Score": "-3", "CreationDate": "2008-10-03T04:58:40.920", "LastActivityDate": "2008-10-03T04:58:40.920"}, "194364": {"ParentId": "165723", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2008-10-11T17:39:50.340", "Id": "194364", "LastEditDate": "2017-03-21T14:05:36.580", "OwnerDisplayName": "Dale", "Score": "-1", "Body": "<p>CPython (the official Python written in C) supports RAII because of its use of reference counted objects with immediate scope based destruction (rather than when garbage is collected). Unfortunately, Jython (Python in Java) and PyPy do not support this very useful RAII idiom and it breaks a lot of legacy Python code. So for portable python you have to handle all the exceptions manually just like Java.</p>\n", "LastActivityDate": "2017-03-21T14:05:36.580", "LastEditorUserId": "1242646"}, "165731": {"ParentId": "165723", "CommentCount": "1", "Body": "<p>It's sort of tied to knowing when your destructor will be called though right? So it's not entirely language-agnostic, given that that's not a given in many GC'd languages.</p>\n", "Id": "165731", "PostTypeId": "2", "OwnerDisplayName": "Mike F", "Score": "0", "CreationDate": "2008-10-03T04:52:26.410", "LastActivityDate": "2008-10-03T04:52:26.410"}, "596577": {"ParentId": "165723", "CommentCount": "0", "Body": "<p>Common Lisp has RAII:</p>\n<pre><code>(with-open-file (stream \"file.ext\" :direction :input)\n    (do-something-with-stream stream))\n</code></pre>\n<p>See: <a href=\"http://www.psg.com/~dlamkins/sl/chapter09.html\" rel=\"nofollow noreferrer\">http://www.psg.com/~dlamkins/sl/chapter09.html</a></p>\n", "OwnerUserId": "27423", "Id": "596577", "PostTypeId": "2", "OwnerDisplayName": "Earwicker", "Score": "2", "CreationDate": "2009-02-27T20:36:26.890", "LastActivityDate": "2009-02-27T20:36:26.890"}, "165793": {"ParentId": "165723", "CommentCount": "4", "Body": "<p>The thing with RAII is that it requires deterministic finalization something that is guaranteed for stackbased objects in C++. Languages like C# and Java that relies on garbage collection doesn't have this guarantee so it has to be \"bolted\" on somehow. In C# this is done by implementing IDisposable and much of the same usage patterns then crops up basicly that's one of the motivators for the \"using\" statement, it ensures Disposal and is very well known and used. </p>\n<p>So basicly the idiom is there, it just doesn't have a fancy name. </p>\n", "OwnerUserId": "21182", "Id": "165793", "PostTypeId": "2", "OwnerDisplayName": "Torbj&#246;rn Gyllebring", "Score": "0", "CreationDate": "2008-10-03T05:34:01.413", "LastActivityDate": "2008-10-03T05:34:01.413"}, "396380": {"ParentId": "165723", "CommentCount": "1", "Body": "<p>There are plenty of reasons why RAII isn't better known. First, the name isn't particularly obvious. If I didn't already know what RAII was, I'd certainly never guess it from the name. (Resource acquisition is initialization? What does that have to do with the destructor or cleanup, which is what <em>really</em> characterizes RAII?)</p>\n<p>Another is that it doesn't work as well in languages without deterministic cleanup.</p>\n<p>In C++, we know exactly when the destructor is called, we know the order in which destructors are called, and we can define them to do anything we like.</p>\n<p>In most modern languages, everything is garbage-collected, which makes RAII trickier to implement. There's no reason why it wouldn't be possible to add RAII-extensions to, say, C#, but it's not as obvious as it is in C++. But as others have mentioned, Perl and other languages support RAII despite being garbage collected.</p>\n<p>That said, it is still possible to create your own RAII-styled wrapper in C# or other languages. I did it in C# a while ago.\nI had to write something to ensure that a database connection was closed immediately after use, a task which any C++ programmer would see as an obvious candidate for RAII.\nOf course we could wrap everything in <code>using</code>-statements whenever we used a db connection, but that's just messy and error-prone.</p>\n<p>My solution was to write a helper function which took a delegate as argument, and then when called, opened a database connection, and inside a using-statement, passed it to the delegate function, pseudocode:</p>\n<pre><code>T RAIIWrapper&lt;T&gt;(Func&lt;DbConnection, T&gt; f){\n  using (var db = new DbConnection()){\n    return f(db);\n  }\n}\n</code></pre>\n<p>Still not as nice or obvious as C++-RAII, but it achieved roughly the same thing. Whenever we need a DbConnection, we have to call this helper function which guarantees that it'll be closed afterwards.</p>\n", "OwnerUserId": "33213", "Id": "396380", "PostTypeId": "2", "OwnerDisplayName": "jalf", "Score": "22", "CreationDate": "2008-12-28T16:47:06.867", "LastActivityDate": "2008-12-28T16:47:06.867"}, "165760": {"CommentCount": "0", "CreationDate": "2008-10-03T05:10:38.880", "LastEditorUserId": "456", "LastActivityDate": "2008-10-03T19:29:41.883", "ParentId": "165723", "PostTypeId": "2", "LastEditorDisplayName": "wilhelmtell", "LastEditDate": "2008-10-03T19:29:41.883", "Id": "165760", "Score": "13", "Body": "<p>RAII stands for <a href=\"http://en.wikipedia.org/wiki/Resource_acquisition_is_initialization\" rel=\"noreferrer\">Resource Acquisition Is Initialization</a>.  This is not language-agnostic at all.  This mantra is here because C++ works the way it works.  In C++ an object is not constructed until its constructor completes.  A destructor will not be invoked if the object has not been successfully constructed.</p>\n<p>Translated to practical language, a constructor should make sure it covers for the case it can't complete its job thoroughly.  If, for example, an exception occurs during construction then the constructor must handle it gracefully, because the destructor will not be there to help.  This is usually done by covering for the exceptions within the constructor or by forwarding this hassle to other objects.  For example:</p>\n<pre><code>class OhMy {\npublic:\n    OhMy() { p_ = new int[42];  jump(); } \n    ~OhMy() { delete[] p_; }\n\nprivate:\n    int* p_;\n\n    void jump();\n};\n</code></pre>\n<p>If the <code>jump()</code> call in the constructor throws we're in trouble, because <code>p_</code> will leak.  We can fix this like this:</p>\n<pre><code>class Few {\npublic:\n    Few() : v_(42) { jump(); } \n    ~Few();\n\nprivate:\n    std::vector&lt;int&gt; v_;\n\n    void jump();\n};\n</code></pre>\n<p>If people are not aware of this then it's because of one of two things:</p>\n<ul>\n<li>They don't know C++ well.  In this case they should open <a href=\"http://www.research.att.com/~bs/3rd.html\" rel=\"noreferrer\">TCPPPL</a> again before they write their next class.  Specifically, section 14.4.1 in the third edition of the book talks about this technique.</li>\n<li>They don't know C++ at all.  That's fine.  This idiom is very C++y.  Either learn C++ or forget all about this and carry on with your lives.  Preferably learn C++.  ;)</li>\n</ul>\n", "OwnerUserId": "456", "OwnerDisplayName": "wilhelmtell"}});