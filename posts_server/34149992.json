post_cb({"bq_ids": {"n4140": {"so_34149992_34149992_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 175}, "so_34149992_34149992_4": {"length": 5, "quality": 0.625, "section_id": 7043}, "so_34149992_34149992_17": {"length": 5, "quality": 0.7142857142857143, "section_id": 7043}, "so_34149992_34149992_12": {"length": 5, "quality": 0.625, "section_id": 7043}, "so_34149992_34149992_13": {"length": 5, "quality": 0.625, "section_id": 5469}, "so_34149992_34149992_5": {"length": 5, "quality": 0.625, "section_id": 5469}, "so_34149992_34149992_9": {"length": 5, "quality": 0.7142857142857143, "section_id": 7043}, "so_34149992_34149992_10": {"length": 11, "quality": 0.9166666666666666, "section_id": 175}, "so_34149992_34149992_18": {"length": 5, "quality": 0.625, "section_id": 5469}}, "n3337": {"so_34149992_34149992_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 169}, "so_34149992_34149992_5": {"length": 5, "quality": 0.625, "section_id": 5255}, "so_34149992_34149992_17": {"length": 5, "quality": 0.7142857142857143, "section_id": 6788}, "so_34149992_34149992_10": {"length": 11, "quality": 0.9166666666666666, "section_id": 169}, "so_34149992_34149992_12": {"length": 5, "quality": 0.625, "section_id": 6788}, "so_34149992_34149992_18": {"length": 5, "quality": 0.625, "section_id": 5255}, "so_34149992_34149992_4": {"length": 5, "quality": 0.625, "section_id": 6788}, "so_34149992_34149992_9": {"length": 5, "quality": 0.7142857142857143, "section_id": 6788}, "so_34149992_34149992_13": {"length": 5, "quality": 0.625, "section_id": 5255}}, "n4659": {"so_34149992_34149992_2": {"length": 12, "quality": 1.0, "section_id": 180}, "so_34149992_34149992_18": {"length": 7, "quality": 0.875, "section_id": 180}, "so_34149992_34149992_4": {"length": 7, "quality": 0.875, "section_id": 180}, "so_34149992_34149992_10": {"length": 12, "quality": 1.0, "section_id": 180}, "so_34149992_34149992_11": {"length": 14, "quality": 1.0, "section_id": 180}, "so_34149992_34149992_1": {"length": 32, "quality": 0.8, "section_id": 180}, "so_34149992_34149992_17": {"length": 7, "quality": 1.0, "section_id": 180}, "so_34149992_34149992_12": {"length": 7, "quality": 0.875, "section_id": 180}, "so_34149992_34149992_5": {"length": 7, "quality": 0.875, "section_id": 180}, "so_34149992_34149992_3": {"length": 14, "quality": 1.0, "section_id": 180}, "so_34149992_34149992_9": {"length": 7, "quality": 1.0, "section_id": 180}, "so_34149992_34149992_13": {"length": 7, "quality": 0.875, "section_id": 180}}}, "34149992": {"ViewCount": "75", "Body": "<blockquote>\n<p id=\"so_34149992_34149992_0\">N4527 14.6 [temp.res]/p8</p>\n<p id=\"so_34149992_34149992_1\">If a hypothetical instantiation of a template immediately\n  following its definition would be ill-formed due to a construct that does not depend on a template parameter,\n  the program is ill-formed; no diagnostic is required. If the interpretation of such a construct in the\n  hypothetical instantiation is different from the interpretation of the corresponding construct in any actual\n  instantiation of the template, the program is ill-formed; no diagnostic is required. [ Note: This can happen\n  in situations including the following:</p>\n<blockquote>\n<p id=\"so_34149992_34149992_10\">(8.1) \u2014 a type used in a non-dependent name is incomplete at the point at which a template is defined but is\n    complete at the point at which an instantiation is performed, or</p>\n<p id=\"so_34149992_34149992_11\">(8.2) \u2014 <strong>an instantiation uses a default argument or default template argument that had not been defined at\n    the point at which the template was defined</strong>, or</p>\n<p id=\"so_34149992_34149992_12\">(8.3) \u2014 constant expression evaluation (5.20) within the template instantiation uses</p>\n<blockquote>\n<p id=\"so_34149992_34149992_18\">(8.3.1) \u2014 <strong>the value of a const object of integral or unscoped enumeration type</strong> or</p>\n<p id=\"so_34149992_34149992_19\">(8.3.2) \u2014 the value of a constexpr object or</p>\n<p id=\"so_34149992_34149992_20\">(8.3.3) \u2014 the value of a reference or</p>\n<p id=\"so_34149992_34149992_21\">(8.3.4) \u2014 the definition of a constexpr function,</p>\n</blockquote>\n<p id=\"so_34149992_34149992_17\">and that entity was not defined when the template was defined, or</p>\n</blockquote>\n</blockquote>\n<p>So, are these codes ill-formed?</p>\n<p>code 1:</p>\n<pre><code>extern double b;\n\ntemplate&lt;class T&gt;\nvoid f(T=b){}\n\nvoid g(){\n    f&lt;double&gt;();//ill-formed or not?\n}\n\ndouble b = 0;\n\nvoid h(){\n    f&lt;double&gt;();//ill-formed or not?\n}\n</code></pre>\n<p>code 2:</p>\n<pre><code>//translation 1\nextern double b;\n\ntemplate&lt;class T&gt;\nvoid f(T=b){}\n\nvoid g(){\n    f&lt;double&gt;();//ill-formed or not?\n}\n\n//translation 2\ndouble b = 0;\n</code></pre>\n<p>And <a href=\"http://wg21.cmeerw.net/cwg/issue1850\" rel=\"nofollow\">Issue1850 Differences between definition context and point of instantiation</a></p>\n<blockquote>\n<p id=\"so_34149992_34149992_22\"><strong>Various characteristics of entities referred to by a non-dependent reference in a template can change between the definition context and the point of instantiation of a specialization of that template</strong>. These include initialization (which affects whether an object can be used in a constant expression), function and template default arguments, and the completeness of types. There is implementation divergence as to whether these are checked in the definition context or at the point of instantiation. Presumably a rule is needed to make it ill-formed, no diagnostic required, if the validity of such a reference changes between the two contexts.</p>\n</blockquote>\n<p>Can you show me more examples about how are characteristics of non-dependent names different between the two contexts? Typically about 8.2 and 8.3.1</p>\n", "AcceptedAnswerId": "34170836", "Title": "Differences of the interpretation of a non-dependent construct between definition context and point of instantiation in c++", "CreationDate": "2015-12-08T07:10:09.347", "Id": "34149992", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-12-09T04:21:17.350", "LastEditorUserId": "4958516", "LastActivityDate": "2015-12-09T04:38:22.070", "Score": "1", "OwnerUserId": "4958516", "Tags": "<c++><templates><language-lawyer><name-resolution>", "AnswerCount": "1"}, "34170836": {"Id": "34170836", "PostTypeId": "2", "Body": "<p>Here's an example:</p>\n<pre><code>extern const int b;\n\ntemplate&lt;int, int&gt;\nvoid f(int);\n\ntemplate&lt;int, const int &amp;&gt;\nvoid f(long);\n\ntemplate&lt;class&gt;\nvoid g() {\n    f&lt;0, b&gt;(0);\n}\n// #1\n\nextern const int b = 0;\n\n\nint main(){\n    g&lt;int&gt;(); \n}\n\n// #2\n</code></pre>\n<p>A hypothetical instantiation at #1 will call <code>void f&lt;0, b&gt;(long)</code>, because <code>b</code> isn't a constant expression at that point, so the <code>(int)</code> overload SFINAEs away. An instantiation at #2 (which is a point of instantiation of <code>g&lt;int&gt;</code>) will call <code>void f&lt;0, 0&gt;(int)</code>, because by then <code>b</code> is a constant expression, the <code>(int)</code> overload is viable and wins overload resolution.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/2801d038cd75a446\" rel=\"nofollow\">Clang and GCC will in fact call different <code>f</code>s with this code.</a></p>\n", "LastActivityDate": "2015-12-09T04:38:22.070", "CommentCount": "0", "CreationDate": "2015-12-09T04:38:22.070", "ParentId": "34149992", "Score": "1", "OwnerUserId": "2756719"}});