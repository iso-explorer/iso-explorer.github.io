post_cb({"24490233": {"ParentId": "24489929", "CommentCount": "0", "CreationDate": "2014-06-30T12:31:38.707", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "24490233", "Score": "4", "Body": "<p>There are no operations (other than type conversions) on\n<code>unsigned char</code>.  Before any operation, integral promotion\noccurs, which converts the <code>unsigned char</code> to an <code>int</code>.  So the\noperation is shifting an <code>int</code> left, not an <code>unsigned char</code>. </p>\n", "LastActivityDate": "2014-06-30T12:31:38.707"}, "24489929": {"CommentCount": "1", "ViewCount": "244", "PostTypeId": "1", "LastEditorUserId": "651473", "CreationDate": "2014-06-30T12:13:56.503", "LastActivityDate": "2014-06-30T13:49:14.260", "Title": "Bitshift - Need explanation to understand the code", "AcceptedAnswerId": "24490603", "LastEditDate": "2014-06-30T13:49:14.260", "Id": "24489929", "Score": "3", "Body": "<p>I was wondering what this function actually performs.\nTo my understanding it should return pSrc[1].</p>\n<p>So why does it bother left-shifting pSrc[0] by 8 bits, which zeroes out those 8 bits.\nAnd when these zeroes are ORed with pSrc[1], pSrc[1] is not affected so you get pSrc[1] anyway as if the bitwise OR had never happened.</p>\n<pre><code>/*\n* Get 2 big-endian bytes.\n*/\nINLINE u2 get2BE(unsigned char const* pSrc)\n{\n    return (pSrc[0] &lt;&lt; 8) | pSrc[1];\n}\n</code></pre>\n<p>This function is from the source code of the dalvik virtual machine.\n<a href=\"https://android.googlesource.com/platform/dalvik/+/android-4.4.4_r1/vm/Bits.h\" rel=\"nofollow\">https://android.googlesource.com/platform/dalvik/+/android-4.4.4_r1/vm/Bits.h</a></p>\n<p>Update:</p>\n<p>OK, now I got it thanks to all the answers here. </p>\n<p>(1) pSrc[0] is originally an unsigned char (1 byte).</p>\n<p>(2) When it is left-shifted (pSrc[0] &lt;&lt; 8) with the literal 8 of int type, pSrc[0] is therefore int-promoted to a signed int (4 byte).</p>\n<p>(3) The result of pSrc[0] &lt;&lt; 8 is that the interested 8 bits in pSrc[0] are shifted over to the second byte of the 4 bytes of the signed int, thereby leaving zeroes in the other bytes(1st,3rd and 4th bytes).</p>\n<p>(4) And when  it is ORed ( intermediate result from step (3) | pSrc[1]), pSrc[1] is then int-promoted to a signed int (4 bytes).</p>\n<p>(5) The result of ( intermediate result from step (3) | pSrc[1]) leaves the first two least significant bytes the way we want with zeroes all in the two most significant bytes.</p>\n<p>(6) return only the first two least significant bytes to get the 2 big-endian bytes by returning the result as a u2 type.</p>\n", "Tags": "<c++><c><bit-manipulation><bit-shift>", "OwnerUserId": "651473", "AnswerCount": "3"}, "24489971": {"ParentId": "24489929", "PostTypeId": "2", "CommentCount": "10", "CreationDate": "2014-06-30T12:16:33.847", "Score": "8", "LastEditorUserId": "962089", "LastEditDate": "2014-06-30T12:52:20.420", "Id": "24489971", "OwnerUserId": "962089", "Body": "<p>For arithmetic operations like this, the <code>unsigned char</code> is converted via a process called <strong>integral promotions</strong>. </p>\n<p>C++11 - N3485 \u00a75.8 [expr.shift]/1:</p>\n<blockquote>\n<p id=\"so_24489929_24489971_0\">The operands shall be of integral or unscoped enumeration type and integral promotions are performed. The type of the result is that of the promoted left operand.</p>\n</blockquote>\n<p>And \u00a713.6 [over.built]/17:</p>\n<blockquote>\n<p id=\"so_24489929_24489971_1\">For every pair of promoted integral types L and R, there exist candidate operator functions of the form </p>\n<pre><code>LR operator%(L , R );\nLR operator&amp;(L , R );\nLR operator^(L , R );\nLR operator|(L , R );\nL operator&lt;&lt;(L , R );\nL operator&gt;&gt;(L , R );\n</code></pre>\n<p id=\"so_24489929_24489971_2\">where LR is the result of the usual arithmetic conversions between types L and R.</p>\n</blockquote>\n<p>When integral promotions are done (\u00a74.5 [conv.prom]/1):</p>\n<blockquote>\n<p id=\"so_24489929_24489971_3\">A prvalue of an integer type other than bool, char16_t, char32_t, or wchar_t whose integer conversion\n  rank (4.13) is less than the rank of int can be converted to a prvalue of type int if int can represent all\n  the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type unsigned\n  int.</p>\n</blockquote>\n<p>By integral promotions, the <code>unsigned char</code> will be promoted to <code>int</code>. The other operand is already <code>int</code>, so no changes in type are made to it. The return type then becomes <code>int</code> as well.</p>\n<p>Thus, what you have is the first <code>unsigned char</code>'s bits shifted left, but still in the now-bigger <code>int</code>, and then the second <code>unsigned char</code>'s bits at the end.</p>\n<p>You'll notice that the return type of <code>operator|</code> is the result of usual arithmetic conversions between the two operands. At this point, those are the <code>int</code> from the shift and the second <code>unsigned char</code>.</p>\n<p>This conversion is defined as follows (\u00a75 [expr]/10):</p>\n<blockquote>\n<p id=\"so_24489929_24489971_4\">Many binary operators that expect operands of arithmetic or enumeration type cause conversions and yield\n  result types in a similar way. The purpose is to yield a common type, which is also the type of the result.\n  This pattern is called the usual arithmetic conversions, which are defined as follows:<br>\n  \u2026<br>\n  Otherwise, the integral promotions (4.5) shall be performed on both operands. Then the following\n  rules shall be applied to the promoted operands:<br>\n  \u2026<br>\n  If both operands have the same type, no further conversion is needed.</br></br></br></br></p>\n</blockquote>\n<p>Since <code>L</code> and <code>R</code>, being promoted before this, are already <code>int</code>, the promotion leaves them the same and the overall return type of the expression is thus <code>int</code>, which is then converted to <code>u2</code>, whatever that happens to be.</p>\n", "LastActivityDate": "2014-06-30T12:52:20.420"}, "bq_ids": {"n4140": {"so_24489929_24489971_0": {"section_id": 6146, "quality": 0.8666666666666667, "length": 13}, "so_24489929_24490603_0": {"section_id": 6146, "quality": 0.64, "length": 16}, "so_24489929_24489971_1": {"section_id": 691, "quality": 0.9166666666666666, "length": 11}, "so_24489929_24489971_2": {"section_id": 686, "quality": 1.0, "length": 7}, "so_24489929_24489971_3": {"section_id": 21, "quality": 0.9743589743589743, "length": 38}, "so_24489929_24489971_4": {"section_id": 5943, "quality": 0.9411764705882353, "length": 48}, "so_24489929_24490603_1": {"section_id": 6147, "quality": 0.8421052631578947, "length": 32}}, "n3337": {"so_24489929_24489971_0": {"section_id": 5909, "quality": 0.8666666666666667, "length": 13}, "so_24489929_24490603_0": {"section_id": 5909, "quality": 0.64, "length": 16}, "so_24489929_24489971_1": {"section_id": 681, "quality": 0.9166666666666666, "length": 11}, "so_24489929_24489971_2": {"section_id": 676, "quality": 1.0, "length": 7}, "so_24489929_24489971_3": {"section_id": 18, "quality": 0.9743589743589743, "length": 38}, "so_24489929_24489971_4": {"section_id": 5714, "quality": 0.9411764705882353, "length": 48}, "so_24489929_24490603_1": {"section_id": 5910, "quality": 0.8421052631578947, "length": 32}}, "n4659": {"so_24489929_24489971_0": {"section_id": 7642, "quality": 0.8666666666666667, "length": 13}, "so_24489929_24490603_0": {"section_id": 7642, "quality": 0.64, "length": 16}, "so_24489929_24489971_3": {"section_id": 21, "quality": 0.9743589743589743, "length": 38}, "so_24489929_24489971_2": {"section_id": 715, "quality": 1.0, "length": 7}, "so_24489929_24489971_1": {"section_id": 720, "quality": 0.9166666666666666, "length": 11}, "so_24489929_24489971_4": {"section_id": 7428, "quality": 0.9411764705882353, "length": 48}, "so_24489929_24490603_1": {"section_id": 7643, "quality": 0.8421052631578947, "length": 32}}}, "24490603": {"ParentId": "24489929", "CommentCount": "1", "CreationDate": "2014-06-30T12:52:39.300", "OwnerUserId": "584518", "PostTypeId": "2", "Id": "24490603", "Score": "3", "Body": "<p>C11 6.5.7 Bitwise shift operators</p>\n<blockquote>\n<p id=\"so_24489929_24490603_0\"><strong>The integer promotions are performed on each of the operands. The type\n  of the result is that of the promoted left operand.</strong> If the value of\n  the right operand is negative or is greater than or equal to the\n  width of the promoted left operand, the behavior is undefined.</p>\n<p id=\"so_24489929_24490603_1\">The result of E1 &lt;&lt; E2 is E1 left-shifted E2 bit positions; vacated bits are filled with\n  zeros. If E1 has an unsigned type, the value of the result is E1 \u00d7 2E2, reduced modulo\n  one more than the maximum value representable in the result type. <strong>If E1 has a signed\n  type and nonnegative value, and E1 \u00d7 2E2 is representable in the result type, then that is\n  the resulting value; otherwise, the behavior is undefined.</strong></p>\n</blockquote>\n<p>So <code>pSrc[0]</code> is integer promoted to an <code>int</code>. The literal <code>8</code> is already an <code>int</code>, so no integer promotion takes place. The usual arithmetic converstions do not apply to shift operators: they are a special case.</p>\n<p>Since the original variable was an <code>unsigned char</code> which gets left shifted 8 bits, we also encounter the issue where \"E1\" (our promoted variable) is signed and potentially the result cannot be representable in the result type, which leads to undefined behavior if this is a 16 bit system.</p>\n<p>In plain English: if you shift something into the sign bits of a signed variable, anything can happen. In general: relying on implicit type promotions is bad programming and dangerous practice.</p>\n<p>You should fix the code to this:</p>\n<pre><code>((unsigned int)pSrc[0] &lt;&lt; 8) | (unsigned int)pSrc[1]\n</code></pre>\n", "LastActivityDate": "2014-06-30T12:52:39.300"}});