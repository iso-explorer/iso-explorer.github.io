post_cb({"39278520": {"ParentId": "39277869", "CommentCount": "7", "Body": "<p>When deciding how to initialize a reference given its initializer, first, direct binding is tried. <a href=\"http://eel.is/c++draft/dcl.init.ref#5\" rel=\"nofollow\">[dcl.init.ref]/(5.1.2)</a>:</p>\n<blockquote>\n<p id=\"so_39277869_39278520_0\">If the reference is an lvalue reference and the initializer expression [\u2026] has a class type (i.e., <code>T2</code> is a class type), where <code>T1</code> is not reference-related to <code>T2</code>, and can be\n  converted to an lvalue of type \u201c<em>cv3</em> <code>T3</code>\u201d, where \u201c<em>cv1</em> <code>T1</code>\u201d is reference-compatible with \u201c<em>cv3</em> <code>T3</code>\u201d (<strong>this conversion is selected by enumerating the applicable conversion functions (13.3.1.6) and choosing the best one through overload resolution (13.3)</strong>), then the reference is bound [\u2026] to the lvalue result\n  of the conversion [\u2026].</p>\n</blockquote>\n<p>The wording that governs the candidate selection for this process (<a href=\"http://eel.is/c++draft/over.match.ref#1\" rel=\"nofollow\">13.3.1.6</a>, as mentioned above) excludes the first conversion function:</p>\n<blockquote>\n<p id=\"so_39277869_39278520_1\">The conversion functions of <code>S</code> and its base classes are considered. <strong>Those non-explicit conversion functions\n  that are not hidden within <code>S</code> and yield type \u201clvalue reference to <em>cv2</em> <code>T2</code>\u201d</strong>(when initializing an lvalue reference or an rvalue reference to function) [\u2026], where \u201c<em>cv1</em> <code>T</code>\u201d is reference-compatible (8.6.3)\n  with \u201c<em>cv2</em> <code>T2</code>\u201d, <strong>are candidate functions</strong>. For direct-initialization, [\u2026].</p>\n</blockquote>\n<p>Clearly, this exclusion is specific to the reference initialization semantics, so the first case is ambiguous still.</p>\n", "OwnerUserId": "3647361", "PostTypeId": "2", "Id": "39278520", "Score": "3", "CreationDate": "2016-09-01T18:25:52.247", "LastActivityDate": "2016-09-01T18:25:52.247"}, "bq_ids": {"n4140": {"so_39277869_39278520_1": {"section_id": 597, "quality": 0.7878787878787878, "length": 26}, "so_39277869_39278520_0": {"section_id": 3321, "quality": 0.875, "length": 35}}, "n3337": {"so_39277869_39278520_1": {"section_id": 587, "quality": 0.6363636363636364, "length": 21}, "so_39277869_39278520_0": {"section_id": 3191, "quality": 0.875, "length": 35}}, "n4659": {"so_39277869_39278520_1": {"section_id": 620, "quality": 0.7878787878787878, "length": 26}, "so_39277869_39278520_0": {"section_id": 4087, "quality": 0.875, "length": 35}}}, "39277869": {"CommentCount": "7", "AcceptedAnswerId": "39278520", "PostTypeId": "1", "LastEditorUserId": "819272", "CreationDate": "2016-09-01T17:45:27.287", "LastActivityDate": "2016-09-01T18:37:27.343", "LastEditDate": "2016-09-01T18:37:27.343", "ViewCount": "102", "FavoriteCount": "2", "Title": "Overloading conversion function templates", "Id": "39277869", "Score": "14", "Body": "<p>Consider the following:</p>\n<pre><code>struct X {\n    template &lt;class T&gt; operator T();  // #1\n    template &lt;class T&gt; operator T&amp;(); // #2\n};\n\nint        a = X{}; // error: ambiguous\nint&amp;       b = X{}; // calls #2\nint const&amp; c = X{}; // calls #2\n</code></pre>\n<p>The situation for <code>b</code> is straightforward, <code>#2</code> is the only viable candidate. What is the rule that indicates that <code>#2</code> is preferred to <code>#1</code> for initialization of <code>int const&amp;</code>, but the two are ambiguous for initialization of <code>int</code>?</p>\n", "Tags": "<c++><language-lawyer><overload-resolution><conversion-operator>", "OwnerUserId": "2069064", "AnswerCount": "1"}});