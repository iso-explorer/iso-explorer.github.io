post_cb({"bq_ids": {"n4140": {"so_9037940_9040338_0": {"length": 44, "quality": 1.0, "section_id": 332}}, "n3337": {"so_9037940_9040338_0": {"length": 44, "quality": 1.0, "section_id": 322}}, "n4659": {"so_9037940_9040338_0": {"length": 44, "quality": 1.0, "section_id": 341}}}, "9038157": {"Id": "9038157", "PostTypeId": "2", "Body": "<p>I don't know what's wrong with Visual Studio, but what <code>gcc</code> says seems right:</p>\n<p>You instantiate <code>AddPkgrConstByType&lt;CReadType, T&gt;</code> because <code>Packager::CReadWriteType</code> resolves to <code>CReadType</code>. Therefore, <code>AddPkgrConst&lt;Packager,bool&gt;::type</code> will resolve according to the first implementation (which is not a specialisation) to <code>bool</code>. This means you have two separate function specialisations with the same parameter list, which C++ doesn't allow you.</p>\n", "LastEditorUserId": "430766", "LastActivityDate": "2012-01-27T18:35:13.880", "Score": "3", "CreationDate": "2012-01-27T18:22:56.487", "ParentId": "9037940", "CommentCount": "4", "OwnerUserId": "430766", "LastEditDate": "2012-01-27T18:35:13.880"}, "9037940": {"ViewCount": "189", "Body": "<p>The following code compiles just fine under Visual Studio but neither gcc 4.6.2 or 4.7 can handle it.  It seems to be valid but gcc can't seem to resolve the difference between const and non const parameters.  Could this be a compiler bug?</p>\n<pre><code>struct CReadType{};\nstruct CWriteType{};\n\ntemplate&lt;typename ReadWriteType, typename T&gt; \nstruct AddPkgrConstByType {}; \ntemplate&lt;typename T&gt; \nstruct AddPkgrConstByType&lt;CReadType, T&gt; {\n   typedef T type;\n};    \ntemplate&lt;typename T&gt;\nstruct AddPkgrConstByType&lt;CReadType, const T&gt; {\n    typedef T type;\n};\ntemplate&lt;typename T&gt;\nstruct AddPkgrConstByType&lt;CWriteType, T&gt; {\n    typedef T const type;\n};\n\ntemplate&lt;typename Packager, typename T&gt;\nstruct AddPkgrConst : public AddPkgrConstByType&lt;typename Packager::CReadWriteType, T&gt; {\n};\n\ntemplate&lt;typename Packager, typename T&gt;\ninline bool Package( Packager* ppkgr, T* pt ) \n{\n    return true;\n}\n\ntemplate&lt;typename Packager&gt;\ninline bool Package( Packager* ppkgr, typename AddPkgrConst&lt;Packager,bool&gt;::type* pb) \n{\n    return false;\n}\n\nstruct ReadPackager {\n    typedef CReadType CReadWriteType;\n};\nstruct WritePackager {\n    typedef CWriteType CReadWriteType;\n};\n\nint main(int argc, char* argv[])\n{\n    ReadPackager rp;\n    WritePackager wp;\n    bool b = true;\n    const bool cb = false;\n    Package( &amp;rp, &amp;b );\n}\n</code></pre>\n<p>Compiler call:</p>\n<pre><code>g++ -fPIC -O -std=c++0x -Wno-deprecated -D_REENTRANT \ng++-D__STDC_LIMIT_MACROS -c test.cpp\ntest.cpp: In function \u2018int main(int, char**)\u2019:\ntest.cpp:58:22: error: call of overloaded \u2018Package(ReadPackager*, bool*)\u2019 is ambiguous\ntest.cpp:58:22: note: candidates are:\ntest.cpp:31:6: note: bool Package(Packager*, T*) [with Packager = ReadPackager, T = bool]\ntest.cpp:38:6: note: bool Package(Packager*, typename AddPkgrConst&lt;Packager, bool&gt;::type*) [with Packager = ReadPackager, typename AddPkgrConst&lt;Packager, bool&gt;::type = bool]\n</code></pre>\n", "Title": "gcc4 template bug or more likely id10t error", "CreationDate": "2012-01-27T18:06:22.653", "LastActivityDate": "2012-07-27T21:32:03.637", "CommentCount": "4", "LastEditDate": "2012-07-27T21:32:03.637", "PostTypeId": "1", "LastEditorUserId": "1174067", "Id": "9037940", "Score": "5", "OwnerUserId": "1174067", "Tags": "<c++><templates><gcc><compiler-construction><gcc4>", "AnswerCount": "3"}, "9038597": {"Id": "9038597", "PostTypeId": "2", "Body": "<p>Since function templates can't be specialized, what you have here is two function template overloads. Both of these overloads are capable of accepting a <code>bool*</code> as their second argument so they appear to properly be detected as ambiguous by g++.</p>\n<p>However classes <em>can</em> be partially specialized so that only one version will be picked, and you can use wrapper magic to attain your desired goal. I'm only pasting the code I added.</p>\n<pre><code>template &lt;typename Packager, typename T&gt;\nstruct Wrapper\n{\n    static bool Package()\n    {\n        return true;\n    }\n};\n\ntemplate &lt;typename Packager&gt;\nstruct Wrapper&lt;Packager, typename AddPkgrConst&lt;Packager,bool&gt;::type&gt;\n{\n    static bool Package()\n    {\n        return false;\n    }\n};\n\ntemplate &lt;typename Packager, typename T&gt;\nWrapper&lt;Packager, T&gt; make_wrapper(Packager* /*p*/, T* /*t*/)\n{\n    return Wrapper&lt;Packager, T&gt;();\n}\n\nint main()\n{\n    ReadPackager rp;\n    bool b = true;\n    std::cout &lt;&lt; make_wrapper(&amp;rp, &amp;b).Package() &lt;&lt; std::endl;  // Prints out 0.\n}\n</code></pre>\n", "LastActivityDate": "2012-01-27T18:59:46.873", "CommentCount": "1", "CreationDate": "2012-01-27T18:59:46.873", "ParentId": "9037940", "Score": "1", "OwnerUserId": "251738"}, "9040338": {"Id": "9040338", "PostTypeId": "2", "Body": "<p>This looks like a compiler error to me. The issues involved here are overload resolution and partial ordering of template functions. Since both template functions can match the argument list <code>(ReadPackager*, bool)</code>, partial ordering of template functions should be used to choose the more specialized template function.</p>\n<p>Put simply, a template function is at least as specialized as another if the arguments to that function can always be used as arguments to the other.</p>\n<p>It's clear that any two pointer arguments match the first Package() function, but for instance Package(ReadPackager*, const int*) can not match the second. This seems to imply that the second Package function is more specialized and ought to resolve any ambiguity.</p>\n<p>However, since there is disagreement among the compilers, there may be some subtleties involved that are overlooked by the simplified explanation. I will therefore follow the procedure for determining function template partial ordering from the standard to discern the correct behavior.</p>\n<p>First, labeling the functions as P1 and P2 for easy reference.</p>\n<p>P1:</p>\n<pre><code>template&lt;typename Packager, typename T&gt;\nbool Package( Packager* ppkgr, T* pt );\n</code></pre>\n<p>P2:</p>\n<pre><code>template&lt;typename Packager&gt;\nbool Package( Packager* ppkgr, typename AddPkgrConst&lt;Packager,bool&gt;::type* pb);\n</code></pre>\n<p>The standard says that for each template function (T1), we must generic unique type for each of its template parameters, use those types to determine the function call parameter types, and then use those types to deduce the types in the other template (T2). If this succeeds, the first template (T1) is at least as specialized as the second (T2).\nFirst P2-&gt;P1</p>\n<ol>\n<li>Synthesize unique type <code>U</code> for template parameter <code>Packager</code> of P2.</li>\n<li>Perform type deduction against <code>P1</code>'s parameter list. <code>Packager</code> is deduced to be <code>U</code> and <code>T</code> is deduced to be <code>AddPkgrConst&lt;Packager,U&gt;::type</code>.</li>\n</ol>\n<p>This succeeds and P1 is judged to be no more specialized than P2.</p>\n<p>Now P1-&gt;P2:</p>\n<ol>\n<li>Synthesize unique types <code>U1</code> and <code>U2</code> for template parameters <code>Packager</code> and <code>T</code> of P1 to get the parameter list (U1*, U2*).</li>\n<li>Perform type deduction against <code>P2</code>'s parameter list. <code>Packager</code> is deduced to be U1.</li>\n<li>No deduction is performed for the second parameter because, being a dependent type, it is considered a non-deduced context.</li>\n<li>The second argument is therefore <code>AddPkgrConst&lt;U1,bool&gt;::type</code> which evaluates to <code>bool</code>. This does not match the second parameter <code>U2</code>.</li>\n</ol>\n<p>This procedure fails if we proceed to step 4. However, my suspicion is that the compilers that reject this code don't perform step 4 and therefore consider P2 no more specialized than P1 merely because type deduction succeeded. This seems counter intuitive since P1 clearly accepts any input that P2 does and not vice versa. This part of the standard is somewhat convoluted, so it's not clear whether this final comparison is required to be made.</p>\n<p>Let's try to address this question by applying \u00a714.8.2.5, paragraph 1, <em>Deducing template arguments from a type</em></p>\n<blockquote>\n<p id=\"so_9037940_9040338_0\">Template arguments can be deduced in several different contexts, but in each case a type that is specified in terms of template parameters (call it P) is compared with an actual type (call it A), and an attempt is made to find template argument values (a type for a type parameter, a value for a non-type parameter, or a template for a template parameter) that will make P, after substitution of the deduced values (call it the deduced A), compatible with A.</p>\n</blockquote>\n<p>In our type deduction, the deduced A is <code>AddPkgrConst&lt;U1,bool&gt;::type</code>=<code>bool</code>. This is not compatible with the original A, which is the unique type <code>U2</code>. This seems to support the position that the partial ordering resolves the ambiguity.</p>\n", "LastEditorUserId": "1174370", "LastActivityDate": "2012-01-28T02:23:39.203", "Score": "4", "CreationDate": "2012-01-27T21:30:48.833", "ParentId": "9037940", "CommentCount": "13", "OwnerUserId": "1174370", "LastEditDate": "2012-01-28T02:23:39.203"}});