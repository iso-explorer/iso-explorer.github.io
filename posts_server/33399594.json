post_cb({"33399769": {"Id": "33399769", "PostTypeId": "2", "Body": "<p>What's the 'best' way is an open question.</p>\n<p>There are a few ways.</p>\n<p>The first thing to say is that overloading <code>std::to_string</code> for a custom type is <em>not allowed</em>. We may only <em>specialise template functions and classes</em> in the <code>std</code> namespace for custom types, and <code>std::to_string</code> is not a template function.</p>\n<p>That said, a good way to treat <code>to_string</code> is much like an operator or an implementation of <code>swap</code>. i.e. allow argument-dependent-lookup to do the work.</p>\n<p>so when we want to convert something to a string we could write:</p>\n<pre><code>using std::to_string;\nauto s = to_string(x) + \" : \" + to_string(i);\n</code></pre>\n<p>assuming that x was an object of type X in namespace Y and i was an int, we could then define:</p>\n<pre><code>namespace Y {\n\n  std::string to_string(const X&amp; x);\n\n}\n</code></pre>\n<p>which would now mean that:</p>\n<p>invoking <code>to_string(x)</code> actually selects <code>Y::to_string(const Y::X&amp;)</code>, and</p>\n<p>invoking <code>to_string(i)</code> selects <code>std::to_string(int)</code> </p>\n<p>Going further, it may be that you want to_string to do much the same as operator&lt;&lt;, so then one can be written in terms of the other:</p>\n<pre><code>namespace Y {\n\n  inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const X&amp; x) { /* implement here */; return os; }\n\n  inline std::string to_string(const X&amp; x) {\n    std::ostringstream ss;\n    ss &lt;&lt; x;\n    return ss.str();\n  }\n}\n</code></pre>\n", "LastEditorUserId": "592323", "LastActivityDate": "2015-10-28T19:25:12.933", "Score": "12", "CreationDate": "2015-10-28T19:20:28.207", "ParentId": "33399594", "CommentCount": "2", "OwnerUserId": "2015579", "LastEditDate": "2015-10-28T19:25:12.933"}, "33399801": {"Id": "33399801", "PostTypeId": "2", "Body": "<p>First, some ADL helping:</p>\n<pre><code>namespace notstd {\n  namespace adl_helper {\n    using std::to_string;\n\n    template&lt;class T&gt;\n    std::string as_string( T&amp;&amp; t ) {\n      return to_string( std::forward&lt;T&gt;(t) );\n    }\n  }\n  template&lt;class T&gt;\n  std::string to_string( T&amp;&amp; t ) {\n    return adl_helper::as_string(std::forward&lt;T&gt;(t));\n  }\n}\n</code></pre>\n<p><code>notstd::to_string(blah)</code> will do an ADL-lookup of <code>to_string(blah)</code> with <code>std::to_string</code> in scope.</p>\n<p>We then modify your class:</p>\n<pre><code>class my_class{\npublic:\n  friend std::string to_string(my_class const&amp; self) const{\n    return \"I am \" + notstd::to_string(self.i);\n  }\n  int i;\n};\n</code></pre>\n<p>and now <code>notstd::to_string(my_object)</code> finds the proper <code>to_string</code>, as does <code>notstd::to_string(7)</code>.</p>\n<p>With a touch more work, we can even support <code>.tostring()</code> methods on types to be auto-detected and used.</p>\n", "LastActivityDate": "2015-10-28T19:22:06.233", "CommentCount": "3", "CreationDate": "2015-10-28T19:22:06.233", "ParentId": "33399594", "Score": "10", "OwnerUserId": "1774667"}, "33399795": {"Id": "33399795", "PostTypeId": "2", "Body": "<p>You can't add new overloads of <code>to_string</code> into <code>std</code> namespace, but you can do it in your namespace:</p>\n<pre><code>namespace my {\n   using std::to_string;\n\n   std::string to_string(const my_class&amp; o) {\n     return o.give_me_a_string_of_you();\n   }\n}\n</code></pre>\n<p>Then you can use <code>my::to_string</code> for all types.</p>\n<pre><code>int main()\n{\n    my_class my_object;\n\n    std::cout &lt;&lt; my::to_string(my_object);\n    std::cout &lt;&lt; my::to_string(5);\n}\n</code></pre>\n", "LastActivityDate": "2015-10-28T19:21:26.373", "CommentCount": "1", "CreationDate": "2015-10-28T19:21:26.373", "ParentId": "33399594", "Score": "0", "OwnerUserId": "194635"}, "bq_ids": {"n4140": {"so_33399594_33399722_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 6299}}, "n3337": {"so_33399594_33399722_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 6056}}, "n4659": {"so_33399594_33399722_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 7808}}}, "33399594": {"ViewCount": "4522", "Body": "<p>I know it seems too much Java or C#. However, is it possible/good/wise to make my own class valid as an input for the function <code>std::to_string</code> ?\nExample:</p>\n<pre><code>class my_class{\npublic:\nstd::string give_me_a_string_of_you() const{\n    return \"I am \" + std::to_string(i);\n}\nint i;\n};\n\nvoid main(){\n    my_class my_object;\n    std::cout&lt;&lt; std::to_string(my_object);\n}\n</code></pre>\n<p>If there is no such thing (and I think that), what is the best way to do it?</p>\n", "AcceptedAnswerId": "33399801", "Title": "Making a user-defined class std::to_string(able)", "CreationDate": "2015-10-28T19:10:34.690", "Id": "33399594", "CommentCount": "6", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-01-21T18:31:45.020", "LastEditorUserId": "4523099", "LastActivityDate": "2017-01-21T18:31:45.020", "Score": "13", "OwnerUserId": "4523099", "Tags": "<c++><string><c++11><tostring>", "AnswerCount": "5"}, "33399722": {"Id": "33399722", "PostTypeId": "2", "Body": "<p>You could define your own <code>to_string</code> in its own namespace (e.g., <code>foo</code>).</p>\n<pre><code>namespace foo {\n   std::string to_string(my_class const &amp;obj) {\n     return obj.string give_me_a_string_of_you();\n   }\n}\n</code></pre>\n<p>And use it as:</p>\n<pre><code>int main(){\n    my_class my_object;\n    std::cout&lt;&lt; foo::to_string(my_object);\n}\n</code></pre>\n<p>Unfortunatelly, you can't define your own version of <code>to_string</code> in namespace <code>std</code> because acorrding to the standard <em>17.6.4.2.1 Namespace std [namespace.std]</em> <strong>(Emphasis Mine)</strong>:</p>\n<blockquote>\n<p id=\"so_33399594_33399722_0\"><strong>The behavior of a C++ program is undefined if it adds declarations or\n  definitions to namespace std or to a namespace within namespace std\n  unless otherwise specified.</strong> A program may add a template\n  specialization for any standard library template to namespace std only\n  if the declaration depends on a user-defined type and the\n  specialization meets the standard library requirements for the\n  original template and is not explicitly prohibited.</p>\n</blockquote>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2015-10-28T19:29:17.347", "Score": "1", "CreationDate": "2015-10-28T19:17:30.683", "ParentId": "33399594", "CommentCount": "3", "OwnerUserId": "2352671", "LastEditDate": "2015-10-28T19:29:17.347"}, "33399672": {"Id": "33399672", "PostTypeId": "2", "Body": "<p>You probably just want to overload <code>operator&lt;&lt;()</code> something like:</p>\n<pre><code>std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, const my_class&amp; rhs ) {\n    os &lt;&lt; \"I am \" &lt;&lt; rhs.i;\n    return os;\n}\n</code></pre>\n<p>Alternatively:</p>\n<pre><code>std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, const my_class&amp; rhs ) {\n    os &lt;&lt; rhs.print_a_string();\n    return os;\n}\n</code></pre>\n<p>Then you can simply do:</p>\n<pre><code>int main() {\n    my_class my_object;\n    std::cout &lt;&lt; my_object;\n\n    return 0;\n}\n</code></pre>\n", "LastEditorUserId": "1312406", "LastActivityDate": "2015-10-28T19:19:08.133", "Score": "1", "CreationDate": "2015-10-28T19:14:59.370", "ParentId": "33399594", "CommentCount": "2", "OwnerUserId": "1312406", "LastEditDate": "2015-10-28T19:19:08.133"}});