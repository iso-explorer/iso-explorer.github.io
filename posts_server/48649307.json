post_cb({"bq_ids": {"n4140": {"so_48649307_48661207_1": {"length": 20, "quality": 0.5555555555555556, "section_id": 5938}, "so_48649307_48654098_1": {"length": 6, "quality": 1.0, "section_id": 3222}, "so_48649307_48661207_0": {"length": 5, "quality": 0.625, "section_id": 7189}}, "n3337": {"so_48649307_48661207_1": {"length": 20, "quality": 0.5555555555555556, "section_id": 5710}, "so_48649307_48661207_0": {"length": 5, "quality": 0.625, "section_id": 6933}, "so_48649307_48654098_1": {"length": 6, "quality": 1.0, "section_id": 3096}}, "n4659": {"so_48649307_48661207_1": {"length": 29, "quality": 0.8055555555555556, "section_id": 7422}, "so_48649307_48661207_0": {"length": 7, "quality": 0.875, "section_id": 8697}, "so_48649307_48654098_1": {"length": 6, "quality": 1.0, "section_id": 3979}}}, "48649307": {"ViewCount": "102", "Body": "<p>I encountered a strange problem. My compiler (for ESP32) is not showing any error or warning if I try to compile self-assing object reference. I investigate this problem and find out that some compilers will not shown any errors or warnings for this code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Foo\n{\n    public:\n        std::string s;\n        Foo(){ std::cout &lt;&lt; \"Foo()\\n\"; }\n        std::string ToString() { return s; }\n};\n\nclass Bar\n{\n    public:\n        Foo&amp; foo;\n        Bar(): foo(foo) { std::cout &lt;&lt; \"Bar()\\n\"; }\n        std::string ToString() { return foo.ToString(); }\n};\n\nint main()\n{\n    Bar bar;\n    std::cout &lt;&lt; \"START\\n\" &lt;&lt; bar.foo.ToString() &lt;&lt; \"\\nEND\\n\";\n}\n</code></pre>\n<p>Only clang shows a warning about self-assignment but even so it clearly should be an error. Is there any situation that this behavior could be legal?</p>\n", "AcceptedAnswerId": "48654098", "Title": "Why self-initialize reference in initializer list is not an error?", "CreationDate": "2018-02-06T18:07:04.967", "LastActivityDate": "2018-02-07T11:56:02.457", "CommentCount": "10", "LastEditDate": "2018-02-07T11:56:02.457", "PostTypeId": "1", "LastEditorUserId": "5376789", "Id": "48649307", "Score": "3", "OwnerUserId": "2483065", "Tags": "<c++><language-lawyer>", "AnswerCount": "3"}, "48661207": {"Id": "48661207", "PostTypeId": "2", "Body": "<p>Because self-initializing a reference is undefined behavior, so compilers are free to diagnose messages or not.</p>\n<p><a href=\"http://eel.is/c++draft/basic.life#2\" rel=\"nofollow noreferrer\">[basic.life]/2</a> says</p>\n<blockquote>\n<p id=\"so_48649307_48661207_0\">The lifetime of a reference begins when its initialization is\n  complete.</p>\n</blockquote>\n<p>So the lifetime of <code>foo</code> does not begin during the initialization. Then, according to <a href=\"http://eel.is/c++draft/expr#type-1\" rel=\"nofollow noreferrer\">[expr.type]/1</a> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_48649307_48661207_1\">If an expression initially has the type \u201creference to T\u201d ([dcl.ref], [dcl.init.ref]), the type is adjusted to T prior to any further analysis. The expression designates the object or function denoted by the reference, and the expression is an lvalue or an xvalue, depending on the expression. [\u2009Note: <strong>Before the lifetime of the reference has started or after it has ended, the behavior is undefined (see [basic.life]).</strong> \u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>Adjusting the type of <code>foo</code> in the initializer expression results in undefined behavior.</p>\n", "LastActivityDate": "2018-02-07T10:18:20.883", "Score": "0", "CreationDate": "2018-02-07T10:18:20.883", "ParentId": "48649307", "CommentCount": "0", "OwnerUserId": "5376789"}, "48662339": {"Id": "48662339", "PostTypeId": "2", "Body": "<p>Note that a compiler refusing to produce an executable for what the standard does not say is ill-formed (as opposed to undefined) would technically be non-conforming, which is why compilers can't default to <code>-Werror</code>. The compiler would also have to prove that every possible execution path of your program would invoke this undefined behavior, which is not generally possible.</p>\n<p>The standard does not say that your code is ill-formed, just undefined <em>if you ever invoke this constructor</em>.</p>\n<p>Now you might say, why doesn't the standard declare this to be ill-formed, since it is obviously incorrect? The reason is complexity. The standard is already huge. There are quite a few cases where the standard <em>could</em> identify subsets of unconditional undefined behavior that are provable at compile time and make them ill-formed, but doing so would be a very large undertaking and add many more special cases to an already large document.</p>\n<p>It is therefore the more practical choice to leave it to compilers to produce warnings in these cases and give the user an opt-in to turn these warnings into errors.</p>\n", "LastActivityDate": "2018-02-07T11:09:35.357", "Score": "0", "CreationDate": "2018-02-07T11:09:35.357", "ParentId": "48649307", "CommentCount": "0", "OwnerUserId": "8922"}, "48654098": {"Id": "48654098", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48649307_48654098_0\">Is there any situation that this behavior could be legal?</p>\n</blockquote>\n<p>No. <a href=\"http://eel.is/c++draft/dcl.ref#5.sentence-3\" rel=\"nofollow noreferrer\">[dcl.ref]/5</a> states:</p>\n<blockquote>\n<p id=\"so_48649307_48654098_1\">A reference shall be initialized to refer to a valid object or function.</p>\n</blockquote>\n<p>Your example involves initializing a reference in a way that <em>doesn't</em> refer to a valid object, so it's ill-formed. This in general isn't always possible to diagnose for obvious reasons... but here, it's pretty clear that this is an error which is why both <a href=\"https://wandbox.org/permlink/jAebSTLzgZUEOyIH\" rel=\"nofollow noreferrer\">gcc</a> and <a href=\"https://wandbox.org/permlink/jAebSTLzgZUEOyIH\" rel=\"nofollow noreferrer\">clang</a> warn about it. </p>\n<blockquote>\n<p id=\"so_48649307_48654098_2\">Only clang shows a warning about self-assignment but even so it clearly should be an error.</p>\n</blockquote>\n<p>The standard doesn't really deal with what's a warning and what's an error. It just deals in diagnostics. Why did these compilers choose to diagnose this as a warning and not an error? Shrug. </p>\n<p>Regardless, this is an easy problem to rectify. If you want an error, compile with <code>-Werror</code>. And now it <em>is</em> an error on both <a href=\"https://wandbox.org/permlink/RJjgOgh8vOZS93px\" rel=\"nofollow noreferrer\">gcc</a> and <a href=\"https://wandbox.org/permlink/Nb566FbW1LJ4jImV\" rel=\"nofollow noreferrer\">clang</a>. This is generally a good habit anyway. </p>\n", "LastActivityDate": "2018-02-07T00:24:21.340", "Score": "4", "CreationDate": "2018-02-07T00:24:21.340", "ParentId": "48649307", "CommentCount": "6", "OwnerUserId": "2069064"}});