post_cb({"6163040": {"ViewCount": "625", "Body": "<p>I was reading the difference between direct-initialization and copy-initialization (\u00a78.5/12):</p>\n<pre><code>T x(a);  //direct-initialization\nT y = a; //copy-initialization\n</code></pre>\n<p>What I understand from reading about <a href=\"https://stackoverflow.com/questions/1051379/is-there-a-difference-in-c-between-copy-initialization-and-direct-initializatio\">copy-initialization</a> is that it needs <a href=\"https://stackoverflow.com/questions/4293596/when-should-you-use-direct-initialization-and-when-copy-initialization\">accessible &amp; non-explicit copy-constructor</a>, or else the program wouldn't compile. I verified it by writing the following code:</p>\n<pre><code>struct A\n{\n   int i;\n       A(int i) : i(i) { std::cout &lt;&lt; \" A(int i)\" &lt;&lt; std::endl; }\n   private:\n       A(const A &amp;a)  {  std::cout &lt;&lt; \" A(const A &amp;)\" &lt;&lt; std::endl; }\n};\n\nint main() {\n        A a = 10; //error - copy-ctor is private!\n}\n</code></pre>\n<p>GCC gives an error (<a href=\"http://www.ideone.com/fB9K5\" rel=\"nofollow noreferrer\">ideone</a>) saying:</p>\n<blockquote>\n<p id=\"so_6163040_6163040_0\">prog.cpp:8: error: \u2018A::A(const A&amp;)\u2019 is private</p>\n</blockquote>\n<p>So far everything is fine, <a href=\"http://www.gotw.ca/gotw/036.htm\" rel=\"nofollow noreferrer\">reaffirming what Herb Sutter says</a>,</p>\n<blockquote>\n<p id=\"so_6163040_6163040_1\">Copy initialization means the object is initialized <strong>using the copy constructor</strong>, after first calling a user-defined conversion if necessary, and is equivalent to the form \"T t = u;\":</p>\n</blockquote>\n<hr>\n<p>After that I made the copy-ctor accessible by commenting the <code>private</code> keyword. Now, naturally I would expect the following to get printed:</p>\n<blockquote>\n<p id=\"so_6163040_6163040_2\">A(const A&amp;)</p>\n</blockquote>\n<p>But to my surprise, it prints this instead (<a href=\"http://www.ideone.com/oEXUT\" rel=\"nofollow noreferrer\">ideone</a>):</p>\n<blockquote>\n<p id=\"so_6163040_6163040_3\">A(int i)</p>\n</blockquote>\n<p>Why?</p>\n<p>Alright, I understand that first a temporary object of type <code>A</code> is created out of <code>10</code> which is <code>int</code> type, by using <code>A(int i)</code>, applying the conversion rule as its needed here (\u00a78.5/14), and then it was supposed to call copy-ctor to initialize <code>a</code>. But it didn't. Why? </p>\n<p>If an implementation is permitted to eliminate the need to call copy-constructor (\u00a78.5/14), then why is it not accepting the code when the copy-constructor is declared <code>private</code>? After all, its not calling it. Its like a spoiled kid who first irritatingly asks for a <em>specific</em> toy, and when you give him one, the <em>specific</em> one, he throws it away, behind your back. :|</p>\n<p>Could this behavior be dangerous? I mean, I might do some other <em>useful</em> thing in the copy-ctor, but if it doesn't call it, then does it not alter the behavior of the program?</p>\n</hr>", "AcceptedAnswerId": "6163385", "Title": "Strange behavior of copy-initialization, doesn't call the copy-constructor!", "CreationDate": "2011-05-28T16:56:51.620", "Id": "6163040", "CommentCount": "5", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:33:58.123", "LastEditorUserId": "-1", "LastActivityDate": "2011-05-28T18:22:05.813", "Score": "7", "OwnerUserId": "415784", "Tags": "<c++><initialization><copy-constructor><copy-initialization>", "AnswerCount": "6"}, "6163192": {"Id": "6163192", "PostTypeId": "2", "Body": "<p>In any compiler, syntax [and semantic] analysis process are done prior to the code optimization process.</p>\n<p>The code must be syntactically valid otherwise it won't even compile. Its only in the later phase (i.e code optimization) that the compiler decides to elide the temporary that it creates.</p>\n<p>So you need an accessible copy c-tor.</p>\n", "LastActivityDate": "2011-05-28T17:20:59.277", "CommentCount": "12", "CreationDate": "2011-05-28T17:20:59.277", "ParentId": "6163040", "Score": "4", "OwnerUserId": "165520"}, "6163127": {"Id": "6163127", "PostTypeId": "2", "Body": "<p>This is an optimization by the compiler.</p>\n<p>In evaluating: <code>A a = 10;</code> instead of:</p>\n<ol>\n<li><p>first constructing a temporary object through <code>A(int)</code>;</p></li>\n<li><p>constructing <code>a</code> through the copy constructor and passing in the temporary;</p></li>\n</ol>\n<p>the compiler will simply construct <code>a</code> using <code>A(int)</code>.</p>\n", "LastActivityDate": "2011-05-28T17:09:42.367", "CommentCount": "1", "CreationDate": "2011-05-28T17:09:42.367", "ParentId": "6163040", "Score": "0", "OwnerUserId": "671858"}, "bq_ids": {"n4140": {"so_6163040_6163385_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 479}}, "n3337": {"so_6163040_6163385_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 470}}, "n4659": {"so_6163040_6163385_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 473}}}, "6163385": {"Id": "6163385", "PostTypeId": "2", "Body": "<p>Are you asking why the compiler does the access check? 12.8/14 in C++03:</p>\n<blockquote>\n<p id=\"so_6163040_6163385_0\">A program is ill-formed if the copy\n  constructor or the copy assignment\n  operator for an object is implicitly\n  used and the special member function\n  is not accessible</p>\n</blockquote>\n<p>When the implementation \"omits the copy construction\" (permitted by 12.8/15), I don't believe this means that the copy ctor is no longer \"implicitly used\", it just isn't executed.</p>\n<p>Or are you asking why the standard says that? If copy elision were an exception to this rule about the access check, your program would be well-formed in implementations that successfully perform the elision, but ill-formed in implementations that don't.</p>\n<p>I'm pretty sure the authors would consider this a Bad Thing. Certainly it's easier to write portable code this way -- the compiler tells you if you write code that <em>attempts</em> to copy a non-copyable object, even if the copy happens to be elided in your implementation. I suspect that it could also inconvenience implementers to figure out whether the optimization will be successful <em>before</em> checking access (or to defer the access check until after the optimization is attempted), although I have no idea whether that warranted consideration.</p>\n<blockquote>\n<p id=\"so_6163040_6163385_1\">Could this behavior be dangerous? I\n  mean, I might do some other useful\n  thing in the copy-ctor, but if it\n  doesn't call it, then does it not\n  alter the behavior of the program?</p>\n</blockquote>\n<p>Of course it could be dangerous - side-effects in copy constructors occur if and only if the object is actually copied, and you should design them accordingly: the standard says copies can be elided, so don't put code in a copy constructor unless you're happy for it to be elided under the conditions defined in 12.8/15:</p>\n<pre><code>MyObject(const MyObject &amp;other) {\n    std::cout &lt;&lt; \"copy \" &lt;&lt; (void*)(&amp;other) &lt;&lt; \" to \" &lt;&lt; (void*)this &lt;&lt; \"\\n\"; // OK\n    std::cout &lt;&lt; \"object returned from function\\n\"; // dangerous: if the copy is\n      // elided then an object will be returned but you won't see the message.\n}\n</code></pre>\n", "LastEditorUserId": "13005", "LastActivityDate": "2011-05-28T18:22:05.813", "Score": "10", "CreationDate": "2011-05-28T17:51:14.430", "ParentId": "6163040", "CommentCount": "8", "OwnerUserId": "13005", "LastEditDate": "2011-05-28T18:22:05.813"}, "6163086": {"Id": "6163086", "PostTypeId": "2", "Body": "<p>RVO and NRVO, buddy. Perfectly good case of copy ellision.</p>\n", "LastActivityDate": "2011-05-28T17:04:26.063", "CommentCount": "3", "CreationDate": "2011-05-28T17:04:26.063", "ParentId": "6163040", "Score": "0", "OwnerUserId": "298661"}, "6163320": {"Id": "6163320", "PostTypeId": "2", "Body": "<p><a href=\"https://stackoverflow.com/questions/4733448/why-copy-constructor-is-called-when-passing-temp-by-const-ref/4733704#4733704\">Here</a> you can find this (with your comment ;)):</p>\n<blockquote>\n<p id=\"so_6163040_6163320_0\">[the standard] also says that the temporary copy\n  can be elided, but the semantic\n  constraints (eg. accessibility) of the\n  copy constructor still have to be\n  checked.</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-05-28T18:03:50.210", "Score": "1", "CreationDate": "2011-05-28T17:41:16.753", "ParentId": "6163040", "CommentCount": "0", "OwnerUserId": "219335", "LastEditDate": "2017-05-23T12:24:57.837"}, "6163448": {"Id": "6163448", "PostTypeId": "2", "Body": "<p>C++ explicitly allows several optimizations involving the copy constructor that actually change the semantics of the program.  (This is in contrast with most optimizations, which do not affect the semantics of the program).  In particular, there are several cases where the compiler is allowed to re-use an existing object, rather than copying one, if it knows that the existing object will become unreachable.  This (copy construction) is one such case; another similar case is the \"return value optimization\" (RVO), where if you declare the variable that holds the return value of a function, then C++ can choose to allocate that on the frame of the caller, so that it doesn't need to copy it back to the caller when the function completes.</p>\n<p>In general, in C++, you are playing with fire if you define a copy constructor that has side effects or does anything other than just copying.</p>\n", "LastActivityDate": "2011-05-28T18:02:05.083", "CommentCount": "2", "CreationDate": "2011-05-28T18:02:05.083", "ParentId": "6163040", "Score": "5", "OwnerUserId": "222329"}});