post_cb({"48188899": {"Id": "48188899", "PostTypeId": "2", "Body": "<p><code>std::enable_if&lt;..., T&gt;::type</code> is a nested name, and as such cannot be deduced:</p>\n<p>See <a href=\"https://timsong-cpp.github.io/cppwp/n3337/temp.deduct.type#5.1\" rel=\"nofollow noreferrer\">[temp.deduct.type]/5</a>:</p>\n<blockquote>\n<p id=\"so_48188515_48188899_0\">The non-deduced contexts are:</p>\n<p id=\"so_48188515_48188899_1\">\u2014\n      The <em>nested-name-specifier</em> of a type that was specified using a <em>qualified-id</em>.</p>\n<p id=\"so_48188515_48188899_2\">. . .</p>\n</blockquote>\n<p>As a workaround, move the <code>enable_if</code> to a separate template argument:</p>\n<pre><code>template &lt;typename T, size_t N, size_t M, typename std::enable_if&lt;(M == 1 || N == 1), int&gt;::type = 0&gt;\nstatic inline T Length(\n    const Matrix&lt;T, N, M&gt; &amp; input)\n</code></pre>\n", "LastEditorUserId": "485343", "LastActivityDate": "2018-01-10T15:32:37.137", "Score": "3", "CreationDate": "2018-01-10T13:49:07.280", "ParentId": "48188515", "CommentCount": "4", "OwnerUserId": "485343", "LastEditDate": "2018-01-10T15:32:37.137"}, "bq_ids": {"n4140": {"so_48188515_48188899_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 336}}, "n3337": {"so_48188515_48188899_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 326}}, "n4659": {"so_48188515_48188899_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 345}}}, "48188515": {"ViewCount": "74", "Body": "<p>I was trying to use <code>enable_if</code> to avoid duplicating code. It works fine as long as placed in the return type, but not if it's in the parameters. Before this gets closed as a dup of <a href=\"https://stackoverflow.com/questions/15427667/sfinae-working-in-return-type-but-not-as-template-parameter\">this</a>, the error I'm getting is not a redefinition, but a \"no matching function for call.\" Here's my MCVE (not so \"C\", or so \"M\" for that matter) using VS2015 and g++ 7.2.0 (mingw):</p>\n<pre><code>#include &lt;cmath&gt;\n#include &lt;array&gt;\n#include &lt;algorithm&gt;\n\n\ntemplate &lt;typename T, size_t M, size_t N&gt;\nclass Matrix\n{\npublic:\n    static const size_t ROWS = M;\n    static const size_t COLS = N;\n    typedef T SCALAR;\n\n    SCALAR operator[](const size_t index) const\n    {\n        static_assert((COLS == 1 || ROWS == 1), \"operator[] is only for vectors (single row or column).\");\n        return m_elements.at(index);\n    }\n\n    SCALAR&amp; operator[](const size_t index)\n    {\n        static_assert((COLS == 1 || ROWS == 1), \"operator[] is only for vectors (single row or column).\");\n        return m_elements.at(index);\n    }\n\n    std::array&lt;T, M * N&gt; m_elements;\n};\n\ntemplate &lt;typename T, size_t N, size_t M&gt;\nstatic inline T Length(\n    const Matrix&lt;typename std::enable_if&lt;(M == 1 || N == 1), T&gt;::type, N, M&gt; &amp; input)\n{\n    T value = 0;\n    for (size_t i = 0; i &lt; std::max(N, M); ++i)\n    {\n        value += (input[i] * input[i]);\n    }\n    return std::sqrt(value);\n}\n\ntemplate &lt;typename T, size_t M, size_t N&gt;\nstatic inline \nMatrix&lt;typename std::enable_if&lt;(M == 3 &amp;&amp; N == 1) || (M == 1 &amp;&amp; N == 3), T&gt;::type , M, N&gt;\nCrossProduct(const Matrix&lt;T, M, N&gt; &amp; a, const Matrix&lt;T, M, N&gt; &amp; b)\n{\n    Matrix&lt;T, M, N&gt; result;\n    result[0] = a[1] * b[2] - a[2] * b[1];\n    result[1] = a[2] * b[0] - a[0] * b[2];\n    result[2] = a[0] * b[1] - a[1] * b[0];\n    return result;\n}\n\n\nMatrix&lt;double, 1, 1&gt; m11;\nMatrix&lt;double, 3, 1&gt; m31;\nMatrix&lt;double, 1, 3&gt; m13;\nMatrix&lt;double, 3, 3&gt; m33;\n\n\nauto l0 = Length(m11);  // Should work, but doesn't: no matching function for call to 'Length(Matrix&lt;double, 1, 1&gt;&amp;)'\nauto l1 = Length(m31);  // Should work, but doesn't: no matching function for call to 'Length(Matrix&lt;double, 3, 1&gt;&amp;)'\nauto l2 = Length(m13);  // Should work, but doesn't: no matching function for call to 'Length(Matrix&lt;double, 1, 3&gt;&amp;)'\n//auto l3 = Length(m33);    // Shouldn't work, and doesn't: no matching function for call to 'Length(Matrix&lt;double, 3, 3&gt;&amp;)'\n\nauto v1 = CrossProduct(m13, m13); //Works, as expected\n//auto v2 = CrossProduct(m11, m11); // As expected: enable_if.cpp:71:32: error: no matching function for\n                                    // call to 'CrossProduct(Matrix&lt;double, 1, 1&gt;&amp;, Matrix&lt;double, 1, 1&gt;&amp;)'\n</code></pre>\n<p>If I change the signature of <code>Length</code> to </p>\n<pre><code>static inline typename std::enable_if&lt;(M == 1 || N == 1), T&gt;::type \\\nLength(const math::Matrix&lt;T, N, M&gt; &amp; input)\n</code></pre>\n<p>it works fine. But the error it gives me seems to indicate that it was able to determine the correct signature (e.g. <code>Length(Matrix&lt;double, 3, 1&gt;&amp;)</code>).</p>\n<p>Why is the compiler unable to find a matching function if the <code>enable_if</code> is in the parameter list, but is able to if it's in the return type?</p>\n", "AcceptedAnswerId": "48188899", "Title": "SFINAE works as return type, but not parameter type", "CreationDate": "2018-01-10T13:26:47.920", "Id": "48188515", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2018-01-10T15:32:37.137", "Score": "1", "OwnerUserId": "2899559", "Tags": "<c++><templates><sfinae><enable-if>", "AnswerCount": "1"}});