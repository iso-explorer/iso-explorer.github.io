post_cb({"25527229": {"ParentId": "25525688", "CommentCount": "0", "Body": "<p>The point is in _A's constructor. As <a href=\"http://en.cppreference.com/w/cpp/language/default_constructor\" rel=\"nofollow\">cppreference</a> states:</p>\n<p>The default constructor for class T is trivial (i.e. performs no action) if all of the following is true:</p>\n<ul>\n<li><strong>The constructor is not user-provided (that is, implicitly-defined or defaulted)</strong></li>\n<li>T has no virtual member functions</li>\n<li>T has no virtual base classes</li>\n<li>T has no non-static members with brace-or-equal initializers. (since C++11)</li>\n<li>Every direct base of T has a trivial default constructor</li>\n<li>Every non-static member of class type has a trivial default constructor</li>\n</ul>\n<p>This <a href=\"http://www.cplusplus.com/reference/type_traits/is_trivially_constructible/\" rel=\"nofollow\">is not trivially constructible</a></p>\n<pre><code>class  _A{ public: _A(){} };\n</code></pre>\n<p>while this is</p>\n<pre><code>class  _A{ public: };\n</code></pre>\n<p>and in the case of the example this definitely hasn't a trivial constructor:</p>\n<pre><code>class  _A{ public: _A(){} C&lt;_B&gt; g; };\n</code></pre>\n<p>that means the constructor <strong>does perform</strong> initialization routines for the members of the class. As the standard says 14.7.1 [temp.inst]</p>\n<blockquote>\n<p id=\"so_25525688_25527229_0\">the initialization (and any associated side-effects) of a static data member does not occur unless the static data member is itself used in a way that requires the definition of the static data member to exist</p>\n</blockquote>\n<p>and since the non-trivial constructor just provided us the <strong>use</strong> (not the <strong>need</strong>) for static variables to be initialized, the CRT begins its work and starts initializing</p>\n<pre><code>const static C&lt;T&gt; nullObj;\n</code></pre>\n<p>which in turn dereferences something unitialized and you have undefined behavior.</p>\n<p>To solve, as quantdev as stated, either you initialize <code>B&lt;_B&gt;::nullObj</code> before this process or change the design of your code.</p>\n", "OwnerUserId": "1938163", "PostTypeId": "2", "Id": "25527229", "Score": "1", "CreationDate": "2014-08-27T12:28:40.327", "LastActivityDate": "2014-08-27T12:28:40.327"}, "25526002": {"ParentId": "25525688", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Template <em>instances</em> are not defined until they are instantiated. The first time <code>C&lt;&gt;</code> is instantiated is in <code>_A</code>'s constructor. And <code>B&lt;&gt;</code> is instantiated by <code>C&lt;&gt;</code>, so <code>B&lt;_B&gt;</code> is defined when <code>C&lt;_B&gt;</code> is instantiated. Therefore <code>C&lt;_B&gt;</code> is before <code>B&lt;_B&gt;</code>.</p>\n<p>You can add explicit template instantiation <code>template class B&lt;_B&gt;;</code> before the definition of <code>_A</code>, which I believe should fix the order.</p>\n", "OwnerUserId": "2079303", "LastEditorUserId": "2079303", "LastEditDate": "2014-08-27T11:41:10.717", "Id": "25526002", "Score": "2", "CreationDate": "2014-08-27T11:28:28.477", "LastActivityDate": "2014-08-27T11:41:10.717"}, "25526090": {"ParentId": "25525688", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>C++ Standard, section 14.7.1 [temp.inst]:</p>\n<blockquote>\n<p id=\"so_25525688_25526090_0\">Unless a member of a class template or a member template has been explicitly instantiated or explicitly specialized, the specialization of the member is implicitly instantiated when the specialization is referenced in a context that requires the member definition to exist; <strong>in particular, the initialization (and any associated\n  side-effects) of a static data member does not occur unless the static data member is itself used in a way that requires the definition of the static data member to exist</strong></p>\n</blockquote>\n<hr>\n<p><code>C&lt;T&gt;</code> is instanciated before <code>B&lt;T&gt;</code>, so the order of initialization is well defined, and is :</p>\n<p><strong>1)</strong> <code>const static C&lt;T&gt; nullObj;</code></p>\n<p><strong>2)</strong> <code>const static B&lt;T&gt; nullObj;</code></p>\n<p>Since <code>C</code> constructor dereference <code>B&lt;T&gt;::nullObj._a</code>, you have undefined behavior.</p>\n<p><strong>Solution:</strong></p>\n<p>You must use the static member <code>B&lt;_B&gt;::nullObj</code> somehow for it to be initialized, e.g. if you do :</p>\n<pre><code>class _B{};\nclass _A{ public: _A() : b(B&lt;_B&gt;::nullObj) {}; B&lt;_B&gt; b; C&lt;_B&gt; g; };\n</code></pre>\n<p>Then <code>B&lt;_B&gt;::nullObj</code> is indeed initialized before <code>C</code> constructor needs it</p>\n</hr>", "OwnerUserId": "3510483", "LastEditorUserId": "3510483", "LastEditDate": "2014-08-27T12:02:38.743", "Id": "25526090", "Score": "5", "CreationDate": "2014-08-27T11:33:50.340", "LastActivityDate": "2014-08-27T12:02:38.743"}, "bq_ids": {"n4140": {"so_25525688_25526090_0": {"section_id": 234, "quality": 0.9767441860465116, "length": 42}, "so_25525688_25527229_0": {"section_id": 234, "quality": 1.0, "length": 19}}, "n3337": {"so_25525688_25526090_0": {"section_id": 227, "quality": 0.9767441860465116, "length": 42}, "so_25525688_25527229_0": {"section_id": 227, "quality": 1.0, "length": 19}}, "n4659": {"so_25525688_25526090_0": {"section_id": 244, "quality": 0.9534883720930233, "length": 41}, "so_25525688_25527229_0": {"section_id": 244, "quality": 0.9473684210526315, "length": 18}}}, "25525688": {"CommentCount": "2", "ViewCount": "828", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-08-27T11:13:07.667", "LastActivityDate": "2014-08-27T12:28:40.327", "Title": "Static initialization in one compilation unit", "AcceptedAnswerId": "25526090", "LastEditDate": "2017-05-23T12:22:53.637", "Id": "25525688", "Score": "5", "Body": "<p>Static initialization is well described subject, <a href=\"http://www.parashift.com/c++-faq/static-init-order.html\" rel=\"nofollow noreferrer\">here</a> and even at this site <a href=\"https://stackoverflow.com/questions/1005685/c-static-initialization-order\">here</a></p>\n<p>And everywhere it is written that problem will occurs if there exists different compilation units with related static variables. And if static variables exists in one compilation unit, there shouldn't be problem: they will be initialized in order of their position in file.</p>\n<p>But I have this code:</p>\n<pre><code>template &lt;typename T&gt;\nclass A{\npublic:\n    int _data;\n    T _obj;\n    A(int data) :_data(data){}\n};\n\ntemplate &lt;typename T&gt;\nclass B{\npublic:\n    const static B&lt;T&gt; nullObj;\n    B(int data) :_a(new A&lt;T&gt;(data)){}\n    A&lt;T&gt; *_a;\n};\n\ntemplate &lt;typename T&gt;\nclass C{\npublic:\n    const static C&lt;T&gt; nullObj;\n    C() :_a(nullObj._a){}\n    C(bool t) :_a(B&lt;T&gt;::nullObj._a){\n        _a-&gt;_data++; //FAILS HERE!\n    }\n    A&lt;T&gt; *_a;\n};\n\ntemplate &lt;typename T&gt;\nconst B&lt;T&gt; B&lt;T&gt;::nullObj(0);\n\ntemplate &lt;typename T&gt;\nconst C&lt;T&gt; C&lt;T&gt;::nullObj(false);\n\nclass _B{};\nclass  _A{ public: _A(){}; C&lt;_B&gt; g; };\n\nint main(){\n    return 0;\n}\n</code></pre>\n<p>And it fails at runtime before entering main() function, because it tries to initialize <code>const C&lt;T&gt; C&lt;T&gt;::nullObj(false);</code> <strong>before</strong> <code>const B&lt;T&gt; B&lt;T&gt;::nullObj(0);</code> is initialized. Despite their position in one file.</p>\n<p>Why does it tries to initialize second static variable before first static variable? Does there exist chapter in C++ Standart where described real situation with sequence of static initialization?</p>\n", "Tags": "<c++><templates><static>", "OwnerUserId": "1927794", "AnswerCount": "3"}});