post_cb({"28354014": {"Id": "28354014", "PostTypeId": "2", "Body": "<p>OK, someone already answered your first question. I'll focus on this one:</p>\n<blockquote>\n<p id=\"so_28353708_28354014_0\">if the exception destructor should be called when go out of catch scope, in this case only the base class A's d'tor will be called?</p>\n</blockquote>\n<p>The implementation will always destroy the exception object properly regardless of how it is caught. The implementation constructs the exception object, so it knows how to destroy it. This is not the same as when you call <code>delete</code> through a pointer, because in that case there is incomplete information about the complete type of the object at that point (it may have been <code>new</code>ed somewhere else) unless a virtual destructor exists.</p>\n<p>Were this not the case, <code>catch (...)</code> would never work at all.</p>\n", "LastActivityDate": "2015-02-05T21:07:11.707", "CommentCount": "7", "CreationDate": "2015-02-05T21:07:11.707", "ParentId": "28353708", "Score": "5", "OwnerUserId": "481267"}, "28353708": {"ViewCount": "607", "Body": "<p>When we go out of catch block scope, does the exception destructor get called?\n(In case we don't rethrow it)</p>\n<p>Suppose I have class A, and that its destructor is not virtual.\nB inherits A.\nSuppose some function threw object of B class as an exception,\nand it was caught by a catch block</p>\n<pre><code>catch(A&amp; a){\n...\n}\n</code></pre>\n<p>If the exception destructor should be called when go out of catch scope,\nin this case only the base class A's destructor will be called?</p>\n<p>Cornstalks:\nlive trial result in calling both class destructor.</p>\n<p>It contradicts my logic. Explain someone?</p>\n", "AcceptedAnswerId": "28354014", "Title": "exception with non virtual destructor c++", "CreationDate": "2015-02-05T20:48:11.063", "Id": "28353708", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-03-06T22:58:51.320", "LastEditorUserId": "2415524", "LastActivityDate": "2015-03-06T22:58:51.320", "Score": "12", "OwnerUserId": "324922", "Tags": "<c++><exception><virtual-destructor>", "AnswerCount": "4"}, "28356620": {"Id": "28356620", "PostTypeId": "2", "Body": "<p>Whenever the Standard says that an object is destroyed, it means that the correct most-derived destructor is invoked.</p>\n<p>Always.</p>\n<p>When you polymorphically delete an object without a virtual destructor, or you terminate (via <code>delete</code> operator or explicit destructor call) an object of incomplete type and the proper destructor is non-trivial, the Standard does not say that object is destroyed.  It does not say that the base class destructor is invoked.  It says you have undefined behavior.</p>\n", "LastActivityDate": "2015-02-06T00:30:09.957", "CommentCount": "0", "CreationDate": "2015-02-06T00:30:09.957", "ParentId": "28353708", "Score": "2", "OwnerUserId": "103167"}, "28353867": {"Id": "28353867", "PostTypeId": "2", "Body": "<p>While I'm not quoting from the standard, it seems that throwing a <code>B</code> and catching a <code>A&amp;</code> will result in both <code>A</code>'s and <code>B</code>'s destructors getting called. <a href=\"http://ideone.com/OISblJ\" rel=\"nofollow\">Live demo</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    ~A() { std::cout &lt;&lt; \"A::~A\" &lt;&lt; std::endl; }\n};\n\nstruct B : public A\n{\n    ~B() { std::cout &lt;&lt; \"B::~B\" &lt;&lt; std::endl; }\n};\n\nvoid throwit()\n{\n    throw B{};\n}\n\nint main()\n{\n    std::cout &lt;&lt; \"beginning main scope\" &lt;&lt; std::endl;\n\n    {\n        std::cout &lt;&lt; \"beginning inner scope\" &lt;&lt; std::endl;\n\n        try\n        {\n            std::cout &lt;&lt; \"calling throwit()\" &lt;&lt; std::endl;\n            throwit();\n        }\n        catch (A&amp; a)\n        {\n            std::cout &lt;&lt; \"caught exception\" &lt;&lt; std::endl;\n        }\n\n        std::cout &lt;&lt; \"ending inner scope\" &lt;&lt; std::endl;\n    }\n\n    std::cout &lt;&lt; \"ending main scope\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Output:</p>\n<blockquote>\n<p id=\"so_28353708_28353867_0\">beginning main scope<br>\n  beginning inner scope<br>\n  calling throwit()<br>\n  caught exception<br>\n  B::~B<br>\n  A::~A<br>\n  ending inner scope<br>\n  ending main scope</br></br></br></br></br></br></br></p>\n</blockquote>\n<p>As you can see, both destructors get called. The extra scope printing shows very clearly exactly when the destructors get called (at the end of the <code>catch</code> block).</p>\n", "LastActivityDate": "2015-02-05T20:57:58.930", "CommentCount": "0", "CreationDate": "2015-02-05T20:57:58.930", "ParentId": "28353708", "Score": "3", "OwnerUserId": "1287251"}, "bq_ids": {"n4140": {"so_28353708_28353749_1": {"length": 25, "quality": 0.8620689655172413, "section_id": 3337}}, "n3337": {"so_28353708_28353749_1": {"length": 25, "quality": 0.8620689655172413, "section_id": 3207}}, "n4659": {"so_28353708_28353749_1": {"length": 17, "quality": 0.5862068965517241, "section_id": 4104}}}, "28353749": {"Id": "28353749", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_28353708_28353749_0\">when we go out of catch block scope, does the exception destructor is called? (In case we don't rethrow it)</p>\n</blockquote>\n<p>Yes:</p>\n<blockquote>\n<p id=\"so_28353708_28353749_1\"><code>[C++11: 15.1/4]:</code> <em>[..]</em> The exception object is destroyed after either the last remaining active handler for the exception exits by any means other than rethrowing, or the last object of type <code>std::exception_ptr</code> (18.8.5) that refers to the exception object is destroyed, whichever is later. <em>[..]</em></p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_28353708_28353749_2\">if the exception destructor should be called when go out of catch scope, in this case only the base class A's d'tor will be called?</p>\n</blockquote>\n<p><a href=\"http://coliru.stacked-crooked.com/a/2b40109c713d6cbd\" rel=\"nofollow\">No</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    A() { std::cout &lt;&lt; \"A()\"; }\n    A(const A&amp;) { std::cout &lt;&lt; \"A(const A&amp;)\"; }\n    A(A&amp;&amp;) { std::cout &lt;&lt; \"A(A&amp;&amp;)\"; }\n    ~A() { std::cout &lt;&lt; \"~A()\"; }\n};\n\nstruct B : A\n{\n    B() { std::cout &lt;&lt; \"B()\"; }\n    B(const B&amp;) { std::cout &lt;&lt; \"B(const B&amp;)\"; }\n    B(B&amp;&amp;) { std::cout &lt;&lt; \"B(B&amp;&amp;)\"; }\n    ~B() { std::cout &lt;&lt; \"~B()\"; }\n};\n\nint main()\n{\n    try {\n        throw B();\n    }\n    catch (A&amp;) {\n    }\n}\n\n// Output: A()B()~B()~A()\n</code></pre>\n</hr>", "LastEditorUserId": "560648", "LastActivityDate": "2015-02-05T21:52:09.027", "Score": "5", "CreationDate": "2015-02-05T20:51:33.073", "ParentId": "28353708", "CommentCount": "6", "OwnerUserId": "560648", "LastEditDate": "2015-02-05T21:52:09.027"}});