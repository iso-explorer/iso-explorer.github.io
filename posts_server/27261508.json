post_cb({"27262904": {"Id": "27262904", "PostTypeId": "2", "Body": "<p>They do not have to be files, since the C and C++ preprocessor are <a href=\"https://stackoverflow.com/q/5085533/1708801\">nearly identical</a> it is reasonable to look into the C99 rationale for some clarity on this. If we look at the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf\" rel=\"nofollow noreferrer\">Rationale for International Standard\u2014Programming Languages\u2014C</a> it says in section <code>7.1.2</code> <em>Standard headers</em> says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_27261508_27262904_0\">In many implementations the names of headers are the names of files in\n  special directories. This implementation technique is not required,\n  however: <strong>the Standard makes no assumptions about the form that a file\n  name may take on any system. Headers may thus have a special status if\n  an implementation so chooses. Standard headers may even be built into\n  a translator, provided that their contents do not become \u201cknown\u201d until\n  after they are explicitly included.</strong> One purpose of permitting these\n  header \u201cfiles\u201d to be \u201cbuilt in\u201d to the translator is to allow an\n  implementation of the C language as an interpreter in a free-standing\n  environment where the only \u201cfile\u201d support may be a network interface.</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-12-03T03:01:05.997", "Score": "6", "CreationDate": "2014-12-03T03:01:05.997", "ParentId": "27261508", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T11:58:59.130"}, "27261508": {"ViewCount": "585", "Body": "<p>T.C. left an interesting comment to my answer on this question:</p>\n<p><a href=\"https://stackoverflow.com/a/27261018/1128289\">Why aren't include guards in c++ the default?</a></p>\n<p>T.C. states:</p>\n<blockquote>\n<p id=\"so_27261508_27261508_0\">There's \"header\" and there's \"source file\". \"header\"s don't need to be\n  actual files.</p>\n</blockquote>\n<p>What does this mean?</p>\n<p>Perusing the standard, I see plenty of references to both \"header files\" and \"headers\". However, regarding <code>#include</code>, I noticed that the standard seems to make reference to \"headers\" and \"source <strong>files</strong>\". (C++11, \u00a7 16.2)</p>\n<pre><code>A preprocessing directive of the form\n    # include &lt; h-char-sequence&gt; new-line\nsearches a sequence of implementation-defined places for a header identified uniquely\nby the specified sequence between the &lt; and &gt; delimiters, and causes the replacement\nof that directive by the entire contents of the header. How the places are specified\nor the header identified is implementation-defined.\n</code></pre>\n<p>and</p>\n<pre><code>A preprocessing directive of the form\n    # include \" q-char-sequence\" new-line\ncauses the replacement of that directive by the entire contents of the source *file*\nidentified by the specified sequence between the \" delimiters. The named source *file*\nis searched for in an implementation-defined manner.\n</code></pre>\n<p>I don't know if this is significant. It could be that \"headers\" in a C++ context unambiguously means \"header files\" but the word \"sources\" would be ambiguous so \"headers\" is a shorthand but \"sources\" is not. Or it could be that a C++ compiler is allowed leeway for bracket includes and only needs to act as if textual replacement takes place.</p>\n<p>So when are header (files) not files?</p>\n<p><em>The footnote mentioned by T.C. in the comments below is quite direct:</em></p>\n<blockquote>\n<p id=\"so_27261508_27261508_1\">174) A header is not necessarily a source file, nor are the sequences\n  delimited by &lt; and &gt; in header names necessarily valid source file\n  names (16.2).</p>\n</blockquote>\n", "AcceptedAnswerId": "27261606", "Title": "Is a header necessarily a file?", "CreationDate": "2014-12-03T00:21:15.370", "Id": "27261508", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:08:29.353", "LastEditorUserId": "-1", "LastActivityDate": "2016-07-04T15:34:01.903", "Score": "12", "OwnerUserId": "1128289", "Tags": "<c++><c++11><c-preprocessor><standards>", "AnswerCount": "3"}, "27261606": {"Id": "27261606", "PostTypeId": "2", "Body": "<p>For the standard header \"files\" the C++ standard doesn't really make a mandate that the compiler uses a file or that the file, if it uses one, actually looks like a C++ file. Instead, the standard header files are specified to make a certain set of declarations and definitions available to the C++ program.</p>\n<p>An alternative implementation to a file could be a readily packaged set of declarations represented in the compiler as data structure which is made available when using the corresponding <code>#include</code>-directive. I'm not aware of any compiler which does exactly that but <a href=\"http://clang.llvm.org/\">clang</a> started to implement a <a href=\"http://clang.llvm.org/docs/Modules.html\">module system</a> which makes the headers available from some already processed format.</p>\n", "LastActivityDate": "2014-12-03T00:30:20.950", "CommentCount": "4", "CreationDate": "2014-12-03T00:30:20.950", "ParentId": "27261508", "Score": "14", "OwnerUserId": "1120273"}, "bq_ids": {"n4140": {"so_27261508_27261508_1": {"length": 14, "quality": 0.875, "section_id": 6256}}, "n3337": {"so_27261508_27261508_1": {"length": 14, "quality": 0.875, "section_id": 6016}}, "n4659": {"so_27261508_27261508_1": {"length": 14, "quality": 0.875, "section_id": 7760}}}, "27261943": {"Id": "27261943", "PostTypeId": "2", "Body": "<p>It really depends on the definition of <em>files</em>.</p>\n<p>If you consider any database which maps filenames to contents to be a filesystem, then yes, headers are files.  If you only consider files to be that which is recognized by the OS kernel <code>open</code> system call, then no, headers don't have to be files.</p>\n<p>They could be stored in a relational database.  Or a compressed archive.  Or downloaded over the network.  Or stored in alternate streams or embedded resources of the compiler executable itself.</p>\n<p>In the end, though, textual replacement is done, and the text comes from some sort of indexed-by-name database.</p>\n<p>Dietmar mentioned modules and loading already processed content... but this is generally NOT allowable behavior for <code>#include</code> according to the C++ standard (modules will have to use a different syntax, or perhaps <code>#include</code> with a completely new quotation scheme other than <code>&lt;&gt;</code> or <code>\"\"</code>).  The only processing that could be done in advance is tokenization.  But contents of headers and included source files are subject to stateful preprocessing.</p>\n<p>Some compilers implement \"precompiled headers\" which have done more processing than mere tokenization, but eventually you find some behavior that violates the Standard.  For example, in <a href=\"http://msdn.microsoft.com/en-us/library/z0atkd6c.aspx\" rel=\"nofollow\">Visual C++</a>:</p>\n<blockquote>\n<p id=\"so_27261508_27261943_0\">The compiler ... skips to just beyond the <code>#include</code> directive associated with the .h file, uses the code contained in the .pch file, and then compiles all code after <em>filename</em>.</p>\n</blockquote>\n<p>Ignoring the actual source code prior to <code>#include</code> definitely does not conform to the Standard.  (That doesn't prevent it from being useful, but you need to be aware that edits may not produce the expected behavior changes)</p>\n", "LastActivityDate": "2014-12-03T01:07:03.983", "CommentCount": "0", "CreationDate": "2014-12-03T01:07:03.983", "ParentId": "27261508", "Score": "2", "OwnerUserId": "103167"}});