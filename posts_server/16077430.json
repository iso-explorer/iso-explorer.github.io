post_cb({"bq_ids": {"n4140": {"so_16077430_16077663_0": {"length": 17, "quality": 1.0, "section_id": 251}}, "n3337": {"so_16077430_16077663_0": {"length": 17, "quality": 1.0, "section_id": 242}}, "n4659": {"so_16077430_16077663_0": {"length": 17, "quality": 1.0, "section_id": 258}}}, "16077430": {"ViewCount": "513", "Body": "<p>I try to create a extern template with variadic arguments like:</p>\n<pre><code>extern template&lt;typename... XS&gt; void log( XS... xs );\n</code></pre>\n<p>But gcc 7.2 doesn't compile it, and show the error:</p>\n<pre><code>error: expected unqualified-id before \u2018&lt;\u2019 token\n</code></pre>\n<p>I check the gcc status in c++11, and extern templates should work, isn't it?</p>\n", "AcceptedAnswerId": "16077663", "Title": "Extern template with variadic arguments doesn't compile", "CreationDate": "2013-04-18T07:55:19.803", "Id": "16077430", "CommentCount": "0", "LastEditDate": "2013-04-18T08:11:09.330", "PostTypeId": "1", "LastEditorUserId": "824499", "LastActivityDate": "2013-04-18T08:11:09.330", "Score": "3", "OwnerUserId": "824499", "Tags": "<c++><templates><c++11><variadic-templates>", "AnswerCount": "1"}, "16077663": {"Id": "16077663", "PostTypeId": "2", "Body": "<p>The <code>extern</code> keyword does something different than you expect - if I understand correctly what you expect, of course. </p>\n<p>The <code>extern</code> keyword is applied to <em>explicit instantiations</em> of a template, and it prevents the compiler from generating implicitly the code for that template while processing a certain translation unit. Per Paragraph 14.7.2/2 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16077430_16077663_0\">There are two forms of explicit instantiation: an explicit instantiation definition and an explicit instantiation\n  declaration. <strong>An explicit instantiation declaration begins with the <code>extern</code> keyword</strong>.</p>\n</blockquote>\n<p>Without the <code>extern</code> keyword, the compiler would generate code for (say) <code>log(double, int)</code> in each translation unit that contains calls to <code>log(double, int)</code>, and this code - which would and should be identical for all translation units - would be eventually merged by the linker (the linker would basically discard all duplicates and keep only one).</p>\n<p>The <code>extern</code> keyword saves you from this waste of compilation time by telling the compiler: \"<em>Trust me, somebody else will instantiate this template somewhere else - you don't need to do it now</em>\". <strong>But that promise must be fulfilled</strong>. </p>\n<p>So for instance, if you have this primary template:</p>\n<pre><code>template&lt;typename... Xs&gt; void log(Xs... xs);\n</code></pre>\n<p>And you declare this explicit instantiation:</p>\n<pre><code>extern template void log(int, double);\n</code></pre>\n<p>Than you must have a corresponding explicit instantiation in some translation unit:</p>\n<pre><code>template void log(int, double)\n</code></pre>\n<p>Otherwise, the compiler will never ever produce code for <code>log&lt;int, double&gt;(int, double)</code>, and the linker will complain about undefined references.</p>\n", "LastActivityDate": "2013-04-18T08:08:21.387", "CommentCount": "4", "CreationDate": "2013-04-18T08:08:21.387", "ParentId": "16077430", "Score": "6", "OwnerUserId": "1932150"}});