post_cb({"8598574": {"ParentId": "8598498", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The rvalue reference to the literal <code>3</code>:</p>\n<pre><code>int &amp;&amp; w = 3;\n</code></pre>\n<p>is actually bound to a temporary that is the result of evaluating the expression <code>3</code>.  It's not bound to some Platonic literal 3.</p>\n<p>(all the following standards references are from the March 2011 draft, n3242)</p>\n<p>3.10/1 \"Lvalues and rvalues\"</p>\n<blockquote>\n<p id=\"so_8598498_8598574_0\">The value of a literal such as 12, 7.3e5, or true is also a prvalue</p>\n</blockquote>\n<p>Then 8.5.3 \"References\" gives the rules for how a reference is bound falls through to the last case, which says:</p>\n<blockquote>\n<p id=\"so_8598498_8598574_1\">Otherwise, a temporary of type \u201ccv1 T1\u201d is created and initialized from the initializer expression using the rules for a non-reference copy-initialization (8.5). The reference is then bound to the temporary.</p>\n</blockquote>\n<p>and gives as one example something very close to what's in your question:</p>\n<pre><code>double&amp;&amp; rrd = 2; // rrd refers to temporary with value 2.0\n</code></pre>\n", "OwnerUserId": "12711", "LastEditorUserId": "12711", "LastEditDate": "2011-12-22T01:58:51.683", "Id": "8598574", "Score": "13", "CreationDate": "2011-12-22T01:45:51.660", "LastActivityDate": "2011-12-22T01:58:51.683"}, "bq_ids": {"n4140": {"so_8598498_8598574_0": {"section_id": 7230, "quality": 0.875, "length": 7}, "so_8598498_8598574_1": {"section_id": 3321, "quality": 0.6470588235294118, "length": 11}}, "n3337": {"so_8598498_8598574_0": {"section_id": 6974, "quality": 0.875, "length": 7}, "so_8598498_8598574_1": {"section_id": 3191, "quality": 0.8823529411764706, "length": 15}}, "n4659": {"so_8598498_8598574_1": {"section_id": 4087, "quality": 0.5294117647058824, "length": 9}}}, "8598498": {"CommentCount": "4", "AcceptedAnswerId": "8598574", "PostTypeId": "1", "LastEditorUserId": "90527", "CreationDate": "2011-12-22T01:35:13.640", "LastActivityDate": "2011-12-22T02:35:09.667", "LastEditDate": "2011-12-22T02:35:09.667", "ViewCount": "226", "FavoriteCount": "3", "Title": "Are literal numbers mutable or not?", "Id": "8598498", "Score": "17", "Body": "<p>Naturally, this won't compile:</p>\n<pre><code>int &amp;z = 3; // error: invalid initialization of non-const reference ....\n</code></pre>\n<p>and this will compile:</p>\n<pre><code>const int &amp;z = 3; // OK\n</code></pre>\n<p>Now, consider:</p>\n<pre><code>const int y = 3;\nint &amp;&amp; yrr = y; // const error (as you would expect)\nint &amp;&amp; yrr = move(y); // const error (as you would expect)\n</code></pre>\n<p><strong>But</strong> these next lines do compile for me. I think it shouldn't.</p>\n<pre><code>int &amp;&amp; w = 3;\nint &amp;&amp; yrr = move(3);\nvoid bar(int &amp;&amp; x) {x = 10;}\nbar(3);\n</code></pre>\n<p>Wouldn't those last two lines allow the literal 3 to be modified? What is the difference between <code>3</code> and a const int? And finally, Is there any danger with 'modifying' literals?</p>\n<p>(g++-4.6 (GCC) 4.6.2 with <code>-std=gnu++0x -Wall -Wextra</code>)</p>\n", "Tags": "<c++><c++11><const><rvalue-reference>", "OwnerUserId": "146041", "AnswerCount": "1"}});