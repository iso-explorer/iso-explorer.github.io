post_cb({"2784304": {"ParentId": "2784262", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Only <em>local</em> <code>const</code> references prolong the lifespan.</p>\n<p>The standard specifies such behavior in \u00a78.5.3/5, [dcl.init.ref], the section on initializers of reference declarations. The reference in your example is bound to the constructor's argument <code>n</code>, and becomes invalid when the object <code>n</code> is bound to goes out of scope.</p>\n<p>The lifetime extension is not transitive through a function argument. \u00a712.2/5 [class.temporary]:</p>\n<blockquote>\n<p id=\"so_2784262_2784304_0\">The second context is when a reference is bound to a temporary. The temporary to which the reference is bound or the temporary that is the complete object to a subobject of which the temporary is bound persists for the lifetime of the reference except as specified below. A temporary bound to a reference member in a constructor\u2019s ctor-initializer (\u00a712.6.2 [class.base.init]) persists until the constructor exits. A temporary bound to a reference parameter in a function call (\u00a75.2.2 [expr.call]) persists until the completion of the full expression containing the call.</p>\n</blockquote>\n", "OwnerUserId": "153285", "LastEditorUserId": "-1", "LastEditDate": "2014-02-06T07:53:25.097", "Id": "2784304", "Score": "121", "CreationDate": "2010-05-06T20:36:24.850", "LastActivityDate": "2014-02-06T07:53:25.097"}, "2784262": {"CommentCount": "4", "AcceptedAnswerId": "2784304", "PostTypeId": "1", "LastEditorDisplayName": "Roger Pate", "CreationDate": "2010-05-06T20:31:49.540", "LastActivityDate": "2017-03-25T22:51:19.277", "LastEditDate": "2010-10-30T09:23:46.780", "ViewCount": "32436", "FavoriteCount": "44", "Title": "Does a const reference prolong the life of a temporary?", "Id": "2784262", "Score": "115", "Body": "<p>Why does this:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass Sandbox\n{\npublic:\n    Sandbox(const string&amp; n) : member(n) {}\n    const string&amp; member;\n};\n\nint main()\n{\n    Sandbox sandbox(string(\"four\"));\n    cout &lt;&lt; \"The answer is: \" &lt;&lt; sandbox.member &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>Give output of:</p>\n<blockquote>\n<p id=\"so_2784262_2784262_0\">The answer is:</p>\n</blockquote>\n<p>Instead of:</p>\n<blockquote>\n<p id=\"so_2784262_2784262_1\">The answer is: four</p>\n</blockquote>\n", "Tags": "<c++><temporary><ctor-initializer><const-reference>", "OwnerUserId": "285883", "AnswerCount": "4"}, "30141768": {"ParentId": "2784262", "CommentCount": "0", "Body": "<p>Technically speaking, this program isn't required to actually output anything to standard output (which is a buffered stream to begin with).</p>\n<ul>\n<li><p>The <code>cout &lt;&lt; \"The answer is: \"</code> bit will emit <code>\"The answer is: \"</code> into the <em>buffer</em> of stdout.</p></li>\n<li><p>Then the <code>&lt;&lt; sandbox.member</code> bit will supply the dangling reference into <code>operator &lt;&lt; (ostream &amp;, const std::string &amp;)</code>, which invokes <strong>undefined behavior</strong>.</p></li>\n</ul>\n<p>Because of this, nothing is guaranteed to happen. The program may work seemingly fine or may crash without even flushing stdout -- meaning the text \"The answer is: \" would not get to appear on your screen.</p>\n", "OwnerUserId": "1433768", "PostTypeId": "2", "Id": "30141768", "Score": "3", "CreationDate": "2015-05-09T15:28:31.883", "LastActivityDate": "2015-05-09T15:28:31.883"}, "2784306": {"ParentId": "2784262", "CommentCount": "2", "Body": "<p>Because your temporary string went out of scope once the Sandbox constructor returned, and the stack occupied by it was reclaimed for some other purposes.</p>\n<p>Generally, you should never retain references long-term. References are good for arguments or local variables, never class members.</p>\n", "OwnerUserId": "180286", "PostTypeId": "2", "Id": "2784306", "Score": "1", "CreationDate": "2010-05-06T20:36:39.060", "LastActivityDate": "2010-05-06T20:36:39.060"}, "2784478": {"ParentId": "2784262", "CommentCount": "4", "Body": "<p>Here's the simplest way to explain what happened:</p>\n<p>In main() you created a string and passed it into the constructor. This string instance only existed within the constructor. Inside the constructor, you assigned member to point directly to this instance. When when scope left the constructor, the string instance was destroyed, and member then pointed to a string object that no longer existed. Having Sandbox.member point to a reference outside its scope will not hold those external instances in scope.</p>\n<p>If you want to fix your program to display the behavior you desire, make the following changes:</p>\n<pre><code>int main()\n{\n    string temp = string(\"four\");    \n    Sandbox sandbox(temp);\n    cout &lt;&lt; sandbox.member &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>Now temp will pass out of scope at the end of main() instead of at the end of the constructor. However, this is bad practice. Your member variable should never be a reference to a variable that exists outside of the instance. In practice, you never know when that variable will go out of scope.</p>\n<p>What I recommend is to define Sandbox.member as a <code>const string member;</code> This will copy the temporary parameter's data into the member variable instead of assigning the member variable as the temporary parameter itself.</p>\n", "OwnerUserId": "334826", "PostTypeId": "2", "Id": "2784478", "Score": "17", "CreationDate": "2010-05-06T21:02:38.150", "LastActivityDate": "2010-05-06T21:02:38.150"}, "bq_ids": {"n4140": {"so_2784262_2784304_0": {"section_id": 382, "quality": 0.8, "length": 40}}, "n3337": {"so_2784262_2784304_0": {"section_id": 373, "quality": 0.8, "length": 40}}, "n4659": {"so_2784262_2784304_0": {"section_id": 397, "quality": 0.58, "length": 29}}}});