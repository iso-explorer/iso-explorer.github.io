post_cb({"bq_ids": {"n4140": {"so_24212792_24212940_3": {"length": 33, "quality": 0.8461538461538461, "section_id": 5366}, "so_24212792_24212940_0": {"length": 7, "quality": 0.5384615384615384, "section_id": 6185}, "so_24212792_24212940_2": {"length": 40, "quality": 0.8888888888888888, "section_id": 6044}}, "n3337": {"so_24212792_24212940_3": {"length": 33, "quality": 0.8461538461538461, "section_id": 5162}, "so_24212792_24212940_0": {"length": 7, "quality": 0.5384615384615384, "section_id": 36}, "so_24212792_24212940_2": {"length": 40, "quality": 0.8888888888888888, "section_id": 5812}}, "n4659": {"so_24212792_24212940_3": {"length": 33, "quality": 0.8461538461538461, "section_id": 6791}, "so_24212792_24212940_0": {"length": 7, "quality": 0.5384615384615384, "section_id": 7584}, "so_24212792_24212940_2": {"length": 40, "quality": 0.8888888888888888, "section_id": 7543}}}, "24212792": {"ViewCount": "742", "Body": "<p>In C one can have string literals in the form of</p>\n<pre><code>char *string = \"string here\";\n</code></pre>\n<p>integer literals:</p>\n<pre><code>uint8_t num = 5;\n</code></pre>\n<p>long literals:</p>\n<pre><code>long long bigNum = 90322L; \n</code></pre>\n<p>floating point literals:</p>\n<pre><code>float decimal = 6.3f;\n</code></pre>\n<p>Is the a way to have a pointer literal? That is a literal address to a memory space. I am doing some work on an embedded project and need to hard code a value for a DMA access. I am doing something similar to the following:</p>\n<pre><code>uint32_t *source = 0x08000000;\n</code></pre>\n<p>While this compiles and works correctly I get the following compiler error (I'm using a variant of <code>GCC</code>):</p>\n<pre><code>cc0144: {D} warning: a value of type \"int\" cannot be used to initialize an entity of type \"uint32_t *\"\ncc0152: {D} warning: conversion of nonzero integer to pointer\n</code></pre>\n<p>Is there a correct way to do this or do I just need to accept this as a fact of C? I know I can do:</p>\n<pre><code>uint32_t *source = (uint32_t *)0x08000000;\n</code></pre>\n<p>But that just seems very unnecessary. What is the industry way of doing this? I am also wondering if this feature exists in C++.</p>\n", "AcceptedAnswerId": "24212940", "Title": "Is it possible to have a pointer literal?", "CreationDate": "2014-06-13T19:42:37.457", "Id": "24212792", "CommentCount": "11", "LastEditDate": "2014-06-13T22:40:19.300", "PostTypeId": "1", "LastEditorUserId": "1708801", "LastActivityDate": "2014-06-17T02:05:25.673", "Score": "7", "OwnerUserId": "897794", "Tags": "<c++><c><pointers><literals>", "AnswerCount": "2"}, "24212840": {"Id": "24212840", "PostTypeId": "2", "Body": "<p>No, it's not. That is because literals are <em>valid</em> values, and the only valid pointers are addresses of objects, i.e. the result of address-of operations or of pointer arithmetic on valid pointers.</p>\n<p>You could argue that the <code>nullptr</code> keyword furnishes a kind of \"pointer literal\"; the C++ standard calls it that. It is however the <em>only</em> pointer literal, and ironically it is not of pointer type.</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2014-06-14T17:23:27.900", "Score": "3", "CreationDate": "2014-06-13T19:45:36.503", "ParentId": "24212792", "CommentCount": "12", "OwnerUserId": "596781", "LastEditDate": "2014-06-14T17:23:27.900"}, "24212940": {"Id": "24212940", "PostTypeId": "2", "Body": "<p>In both C and C++ the only pointer literal or constant is zero. We can go to the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"nofollow\">draft C99 standard</a> section <code>6.3.2.3</code> <em>Pointers</em>:</p>\n<blockquote>\n<p id=\"so_24212792_24212940_0\">An integer constant expression with the value 0, or such an expression\n  cast to type void *, is called a null pointer constant.<sup>55)</sup></p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_24212792_24212940_1\">An integer may be converted to any pointer type. Except as previously\n  specified, the result is implementation-defined, might not be\n  correctly aligned, might not point to an entity of the referenced\n  type, and might be a trap representation.<sup>56)</sup></p>\n</blockquote>\n<p>the correct way to deal with non-zero integer constant is to use a cast.</p>\n<p>The equivalent section from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> would probably be section <code>5.2.10</code> <em>Reinterpret cast</em> which says:</p>\n<blockquote>\n<p id=\"so_24212792_24212940_2\">A value of integral type or enumeration type can be explicitly\n  converted to a pointer. A pointer converted to an integer of\n  sufficient size (if any such exists on the implementation) and back to\n  the same pointer type will have its original value; mappings between\n  pointers and integers are otherwise implementation-defined. [ Note:\n  Except as described in 3.7.4.3, the result of such a conversion will\n  not be a safely-derived pointer value. \u2014end note ]</p>\n</blockquote>\n<p>You need to see section <code>3.7.4.3</code> for all the details.</p>\n<p>For the pointer literal reference you need section <code>2.14.7</code> <em>Pointer literals</em> which says:</p>\n<blockquote>\n<p id=\"so_24212792_24212940_3\">The pointer literal is the keyword nullptr. It is a prvalue of type\n  std::nullptr_t. [ Note: std::nullptr_t is a distinct type that is\n  neither a pointer type nor a pointer to member type; rather, a prvalue\n  of this type is a null pointer constant and can be converted to a null\n  pointer value or null member pointer value. See 4.10 and 4.11. \u2014end\n  note ]</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-06-17T02:05:25.673", "Score": "8", "CreationDate": "2014-06-13T19:54:00.177", "ParentId": "24212792", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2014-06-17T02:05:25.673"}});