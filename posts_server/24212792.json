post_cb({"24212940": {"ParentId": "24212792", "LastEditDate": "2014-06-17T02:05:25.673", "CommentCount": "0", "CreationDate": "2014-06-13T19:54:00.177", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "PostTypeId": "2", "Id": "24212940", "Score": "8", "Body": "<p>In both C and C++ the only pointer literal or constant is zero. We can go to the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"nofollow\">draft C99 standard</a> section <code>6.3.2.3</code> <em>Pointers</em>:</p>\n<blockquote>\n<p id=\"so_24212792_24212940_0\">An integer constant expression with the value 0, or such an expression\n  cast to type void *, is called a null pointer constant.<sup>55)</sup></p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_24212792_24212940_1\">An integer may be converted to any pointer type. Except as previously\n  specified, the result is implementation-defined, might not be\n  correctly aligned, might not point to an entity of the referenced\n  type, and might be a trap representation.<sup>56)</sup></p>\n</blockquote>\n<p>the correct way to deal with non-zero integer constant is to use a cast.</p>\n<p>The equivalent section from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> would probably be section <code>5.2.10</code> <em>Reinterpret cast</em> which says:</p>\n<blockquote>\n<p id=\"so_24212792_24212940_2\">A value of integral type or enumeration type can be explicitly\n  converted to a pointer. A pointer converted to an integer of\n  sufficient size (if any such exists on the implementation) and back to\n  the same pointer type will have its original value; mappings between\n  pointers and integers are otherwise implementation-defined. [ Note:\n  Except as described in 3.7.4.3, the result of such a conversion will\n  not be a safely-derived pointer value. \u2014end note ]</p>\n</blockquote>\n<p>You need to see section <code>3.7.4.3</code> for all the details.</p>\n<p>For the pointer literal reference you need section <code>2.14.7</code> <em>Pointer literals</em> which says:</p>\n<blockquote>\n<p id=\"so_24212792_24212940_3\">The pointer literal is the keyword nullptr. It is a prvalue of type\n  std::nullptr_t. [ Note: std::nullptr_t is a distinct type that is\n  neither a pointer type nor a pointer to member type; rather, a prvalue\n  of this type is a null pointer constant and can be converted to a null\n  pointer value or null member pointer value. See 4.10 and 4.11. \u2014end\n  note ]</p>\n</blockquote>\n", "LastActivityDate": "2014-06-17T02:05:25.673"}, "24212792": {"CommentCount": "11", "ViewCount": "742", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2014-06-13T19:42:37.457", "LastActivityDate": "2014-06-17T02:05:25.673", "Title": "Is it possible to have a pointer literal?", "AcceptedAnswerId": "24212940", "LastEditDate": "2014-06-13T22:40:19.300", "Id": "24212792", "Score": "7", "Body": "<p>In C one can have string literals in the form of</p>\n<pre><code>char *string = \"string here\";\n</code></pre>\n<p>integer literals:</p>\n<pre><code>uint8_t num = 5;\n</code></pre>\n<p>long literals:</p>\n<pre><code>long long bigNum = 90322L; \n</code></pre>\n<p>floating point literals:</p>\n<pre><code>float decimal = 6.3f;\n</code></pre>\n<p>Is the a way to have a pointer literal? That is a literal address to a memory space. I am doing some work on an embedded project and need to hard code a value for a DMA access. I am doing something similar to the following:</p>\n<pre><code>uint32_t *source = 0x08000000;\n</code></pre>\n<p>While this compiles and works correctly I get the following compiler error (I'm using a variant of <code>GCC</code>):</p>\n<pre><code>cc0144: {D} warning: a value of type \"int\" cannot be used to initialize an entity of type \"uint32_t *\"\ncc0152: {D} warning: conversion of nonzero integer to pointer\n</code></pre>\n<p>Is there a correct way to do this or do I just need to accept this as a fact of C? I know I can do:</p>\n<pre><code>uint32_t *source = (uint32_t *)0x08000000;\n</code></pre>\n<p>But that just seems very unnecessary. What is the industry way of doing this? I am also wondering if this feature exists in C++.</p>\n", "Tags": "<c++><c><pointers><literals>", "OwnerUserId": "897794", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24212792_24212940_2": {"section_id": 6044, "quality": 0.8888888888888888, "length": 40}, "so_24212792_24212940_0": {"section_id": 6185, "quality": 0.5384615384615384, "length": 7}, "so_24212792_24212940_3": {"section_id": 5366, "quality": 0.8461538461538461, "length": 33}}, "n3337": {"so_24212792_24212940_2": {"section_id": 5812, "quality": 0.8888888888888888, "length": 40}, "so_24212792_24212940_0": {"section_id": 36, "quality": 0.5384615384615384, "length": 7}, "so_24212792_24212940_3": {"section_id": 5162, "quality": 0.8461538461538461, "length": 33}}, "n4659": {"so_24212792_24212940_2": {"section_id": 7543, "quality": 0.8888888888888888, "length": 40}, "so_24212792_24212940_0": {"section_id": 7584, "quality": 0.5384615384615384, "length": 7}, "so_24212792_24212940_3": {"section_id": 6791, "quality": 0.8461538461538461, "length": 33}}}, "24212840": {"ParentId": "24212792", "LastEditDate": "2014-06-14T17:23:27.900", "CommentCount": "12", "CreationDate": "2014-06-13T19:45:36.503", "OwnerUserId": "596781", "LastEditorUserId": "596781", "PostTypeId": "2", "Id": "24212840", "Score": "3", "Body": "<p>No, it's not. That is because literals are <em>valid</em> values, and the only valid pointers are addresses of objects, i.e. the result of address-of operations or of pointer arithmetic on valid pointers.</p>\n<p>You could argue that the <code>nullptr</code> keyword furnishes a kind of \"pointer literal\"; the C++ standard calls it that. It is however the <em>only</em> pointer literal, and ironically it is not of pointer type.</p>\n", "LastActivityDate": "2014-06-14T17:23:27.900"}});