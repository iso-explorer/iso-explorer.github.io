post_cb({"33717255": {"ParentId": "33717196", "CommentCount": "0", "Body": "<p>You need a <code>using</code>, like:</p>\n<pre><code>using BaseClass::foo;\n</code></pre>\n", "OwnerUserId": "1312406", "PostTypeId": "2", "Id": "33717255", "Score": "0", "CreationDate": "2015-11-15T06:59:00.247", "LastActivityDate": "2015-11-15T06:59:00.247"}, "33717247": {"ParentId": "33717196", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>From the C++ standard 3.3.10 paragraph 1 :</p>\n<blockquote>\n<p id=\"so_33717196_33717247_0\">A name can be hidden by an explicit declaration of that same name in\n  a nested declarative region or derived class</p>\n</blockquote>\n<p><code>ChildClass::foo</code> shadows the definition of <code>BaseClass::foo</code>. All you need to bring it into scope is a <code>using</code> directive:</p>\n<pre><code>class ChildClass: public BaseClass {                                         \n  public:\n\n  using BaseClass::foo;\n  template &lt;class T&gt; T&amp; foo(int baz, T&amp; t, int szl);                         \n};\n</code></pre>\n", "OwnerUserId": "436025", "LastEditorUserId": "436025", "LastEditDate": "2015-11-15T07:20:10.457", "Id": "33717247", "Score": "1", "CreationDate": "2015-11-15T06:57:39.853", "LastActivityDate": "2015-11-15T07:20:10.457"}, "33717275": {"ParentId": "33717196", "CommentCount": "0", "Body": "<p>When the compiler tries to match a function name with a function, it does so in two steps. In the first step it finds all the functions that match the given name. If it finds more than one function, it tries the logic of overload resolution to find the best matching function.</p>\n<p>In the first step, if the compiler finds a name in the class, it stops looking for functions of the same name in base classes. In your case, since it finds a <code>foo</code> in <code>ChildClass</code>, it stops searching for functions named <code>foo</code> in <code>BaseClass</code>. However, the only matching <code>foo</code> does not match the call and the compiler reports an error.</p>\n<p>How to resolve the problem:</p>\n<ol>\n<li><p>Use the method you described in your post. Call <code>BaseClass::foo(...)</code>.</p></li>\n<li><p>Bring all the <code>foo</code> from <code>BaseClass</code> into the scope of <code>ChildClass</code>.</p>\n<pre><code>class ChildClass: public BaseClass {\n  public:\n\n  using  BaseClass::foo;\n\n  template &lt;class T&gt; T&amp; foo(int baz, T&amp; t, int szl) {\n     return t;\n  }\n\n  template &lt;class T&gt; int bar(T&amp; t) {\n    return sizeof(foo(1, t)); // Should work.\n  }\n};\n</code></pre></li>\n</ol>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "33717275", "Score": "3", "CreationDate": "2015-11-15T07:02:18.727", "LastActivityDate": "2015-11-15T07:02:18.727"}, "33717196": {"CommentCount": "1", "ViewCount": "77", "PostTypeId": "1", "LastEditorUserId": "1546600", "CreationDate": "2015-11-15T06:49:18.747", "LastActivityDate": "2015-11-15T19:06:04.350", "Title": "Why must I scope an overloaded template base class method?", "AcceptedAnswerId": "33717275", "LastEditDate": "2015-11-15T19:06:04.350", "Id": "33717196", "Score": "1", "Body": "<p>I can't seem to call a method of a base class without scoping to the base class, and it seems that this is because I have overloaded the method.  If I do not overload the method then the compiler doesn't complain.  Here's an example of what I'd like to do:</p>\n<pre><code>struct BaseClass {                                                           \n  template &lt;typename T&gt; T&amp; foo(T&amp; t) {                               \n    return t;                                                                \n  }                                                                          \n};                                                                           \n\nclass ChildClass: public BaseClass {                                         \n  public:\n  // The presence of this template causes compiler confusion                                                            \n  template &lt;class T&gt; T&amp; foo(T&amp; t, int szl) {                        \n    return t;                                                                \n  }                                                                          \n\n  template &lt;class T&gt; int bar(T&amp; t) {                 \n    // But if I scope this as BaseClass::foo(...) it's all good                        \n    return foo(t);                                                \n  }                                                                          \n};                                                                           \n\nint main() {                                                                 \n  int t = 1;                                                                 \n  ChildClass c;                                                              \n  c.bar(t);                                        \n}\n</code></pre>\n<p>If in bar(...) I call BaseClass::foo(...) the compiler does not complain, but I don't see any ambiguity here and so I'm confused as to why I'd need to do this.</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "1546600", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_33717196_33717247_0": {"section_id": 7078, "quality": 1.0, "length": 12}}, "n3337": {"so_33717196_33717247_0": {"section_id": 6822, "quality": 1.0, "length": 12}}, "n4659": {"so_33717196_33717247_0": {"section_id": 8579, "quality": 1.0, "length": 12}}}});