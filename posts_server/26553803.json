post_cb({"26553879": {"ParentId": "26553803", "CommentCount": "7", "Body": "<p>The template arguments of constructor templates <em>must</em> be deduced from their arguments, it's not possible to explicitly specify template arguments for constructors.</p>\n<p>As such, have <code>Base</code> take a dummy parameter that deduces the argument:</p>\n<pre><code>template &lt;typename T&gt;\nstruct dummy { }; // to prevent instantiation of T\n\ntemplate &lt;typename T&gt;\nstruct Base\n{\n    template &lt;typename D&gt;\n    Base(dummy&lt;D&gt;)\n    {\n        static_assert(std::is_same&lt;T, D&gt;::value, \"\");\n    }\n};\n\nstruct Derived : Base&lt;int&gt;\n{\n    Derived() : Base&lt;int&gt;(dummy&lt;int&gt;{}) { }\n};\n</code></pre>\n", "OwnerUserId": "701092", "PostTypeId": "2", "Id": "26553879", "Score": "3", "CreationDate": "2014-10-24T18:16:14.160", "LastActivityDate": "2014-10-24T18:16:14.160"}, "26557917": {"ParentId": "26553803", "CommentCount": "0", "Body": "<p>What the C++ standard says about this (section 14.8.1):</p>\n<blockquote>\n<p id=\"so_26553803_26557917_0\">[ Note:  Because the explicit template argument list follows the function template name, and because conversion member function templates and constructor member function templates are called without using a function name, there is no way to provide an explicit template argument list for these function templates. \u2014 end note ]</p>\n</blockquote>\n<p>It's a note, not a rule, because it actually is a consequence of two other rules, one in the same section:</p>\n<blockquote>\n<p id=\"so_26553803_26557917_1\">Template arguments can be speci\ufb01ed when referring to a function template specialization by qualifying the function template name  with  the  list  of  template-arguments  in  the  same  way  as  template-arguments are speci\ufb01ed in uses of a class template specialization.</p>\n</blockquote>\n<p>and from 12.1</p>\n<blockquote>\n<p id=\"so_26553803_26557917_2\">Constructors do not have names.</p>\n</blockquote>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "26557917", "Score": "3", "CreationDate": "2014-10-24T23:58:43.060", "LastActivityDate": "2014-10-24T23:58:43.060"}, "26554552": {"ParentId": "26553803", "CommentCount": "0", "Body": "<p>By the way the question is formulated it looks going towards a nonsensical paranoia.</p>\n<p>Just think for plain classes:</p>\n<pre><code>class Base \n{\npublic:\n    Base() {}\n};\n\nclass Derived: public Base\n{\npublic:\n    Derived() //&lt; default ctor\n      :Base  //&lt; this is the Base type\n           () //&lt; this selects what ctor to call\n    {}\n};\n</code></pre>\n<p>Note that you call <code>:Base()</code>, that resolve into <code>Base::Base()</code>, not <code>:Base::Base()</code></p>\n<p>Now, by templetizing <code>Base::Base()</code> you are in fact trying to admit that there can be many different default ctor (with <code>()</code>) for Base. That's a nonsense respect ot the concept itself of \"<em>default</em>\".</p>\n<p>Even if Base is not by itself a template, this is not possible:</p>\n<pre><code>class Base\n{\npublic:\n   template&lt;class T&gt;\n   Base() {} //&lt; are there infinite way to default construct Base ?!?\n};\n\nBase b; //&lt; so how is b constructed ?\n</code></pre>\n<p>Thing gets only apparently different with varadics:</p>\n<pre><code>template&lt;class T&gt;\nclass Base\n{\npublic:\n    template&lt;class... S&gt;\n    Base(S&amp;&amp;... s) { /* something to do */ }\n};\n\nclass Derived: public Base&lt;int&gt;\n{\npublic:\n   template&lt;class... S&gt;\n   Derived(S&amp;&amp;... s) //&lt; Derived varadicly initialized\n         :Base //&lt; base type ...\n         (std::forward&lt;S&gt;(s)...) //&lt; ... to initialize with what\n   {}\n};\n</code></pre>\n<p>Note that in case <code>s</code> is empty you are in fact calling <code>Base::Base()</code> from <code>Derived()::Derived()</code>, templetized with <code>&lt;&gt;</code> (no args)</p>\n", "OwnerUserId": "924727", "PostTypeId": "2", "Id": "26554552", "Score": "1", "CreationDate": "2014-10-24T18:59:56.610", "LastActivityDate": "2014-10-24T18:59:56.610"}, "bq_ids": {"n4140": {"so_26553803_26557917_1": {"section_id": 284, "quality": 0.9130434782608695, "length": 21}, "so_26553803_26557917_0": {"section_id": 114, "quality": 0.9117647058823529, "length": 31}}, "n3337": {"so_26553803_26557917_1": {"section_id": 275, "quality": 0.9130434782608695, "length": 21}, "so_26553803_26557917_0": {"section_id": 109, "quality": 0.9117647058823529, "length": 31}}, "n4659": {"so_26553803_26557917_1": {"section_id": 291, "quality": 0.9130434782608695, "length": 21}, "so_26553803_26557917_0": {"section_id": 118, "quality": 0.9117647058823529, "length": 31}}}, "26553803": {"CommentCount": "3", "ViewCount": "331", "CreationDate": "2014-10-24T18:11:47.317", "LastActivityDate": "2014-10-24T23:58:43.060", "Title": "Derive from template constuctor of template base class", "AcceptedAnswerId": "26557917", "PostTypeId": "1", "Id": "26553803", "Score": "2", "Body": "<p>Just curious, is it ever possible to inherit from a template class and in constructor of the derived class, call constructor of the base class which is also templated and has no arguments to deduce its types from?</p>\n<pre><code>template&lt;typename T&gt;\nstruct Base {\n    template&lt;typename D&gt;\n    Base() {                // no argument of type D to infer from\n        static_assert(std::is_same&lt;T,D&gt;::value, \"\");\n    }\n};\n\nstruct Derived : Base&lt;int&gt; {\n    Derived()  : Base&lt;int&gt;::Base&lt;int&gt;() {} // is there a way to write it correctly?\n};\n</code></pre>\n<p>I can replace template constructor by a template method in my particular case, but still it is an interesting question about the language flexibility.</p>\n", "Tags": "<c++><templates><inheritance><c++11>", "OwnerUserId": "2527797", "AnswerCount": "3"}});