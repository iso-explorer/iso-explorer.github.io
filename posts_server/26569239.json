post_cb({"26569369": {"Id": "26569369", "PostTypeId": "2", "Body": "<p>Deleted constructors participate in overload resolution. This is in order to ensure that the compilation really fails if a program attempts to use a deleted constructor. See <a href=\"https://stackoverflow.com/a/8631527/777186\">this answer</a> for more details.</p>\n<p>The relevant section in the C++11 standard is 8.4.3/2:</p>\n<blockquote>\n<p id=\"so_26569239_26569369_0\">A program that refers to a deleted function implicitly or explicitly, other than to declare it, is ill-formed.</p>\n<p id=\"so_26569239_26569369_1\">[ Note: This includes calling the function implicitly or explicitly and forming a pointer or pointer-to-member\n  to the function. It applies even for references in expressions that are not potentially-evaluated. If a function\n  is overloaded, it is referenced only if the function is selected by overload resolution. \u2014end note ]</p>\n</blockquote>\n<p>You can solve your problem by making the constructor call unambiguous:</p>\n<pre><code>template&lt;class T&gt;\nstruct Foo: public T,\n            public Bar&lt;T&gt;\n{\n    Foo(): Bar&lt;T&gt;(static_cast&lt;T &amp;&gt;(*this)){}\n};\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-10-26T03:05:51.557", "Score": "0", "CreationDate": "2014-10-26T02:59:22.890", "ParentId": "26569239", "CommentCount": "1", "OwnerUserId": "777186", "LastEditDate": "2017-05-23T11:57:10.170"}, "bq_ids": {"n4140": {"so_26569239_26569369_1": {"length": 21, "quality": 0.84, "section_id": 3277}, "so_26569239_26569369_0": {"length": 9, "quality": 1.0, "section_id": 3277}}, "n3337": {"so_26569239_26569369_1": {"length": 21, "quality": 0.84, "section_id": 3148}, "so_26569239_26569369_0": {"length": 9, "quality": 1.0, "section_id": 3148}}, "n4659": {"so_26569239_26569369_1": {"length": 21, "quality": 0.84, "section_id": 4035}, "so_26569239_26569369_0": {"length": 9, "quality": 1.0, "section_id": 4035}}}, "26569239": {"ViewCount": "249", "Body": "<p>The following code</p>\n<pre><code>template&lt;class T&gt;\nstruct Bar\n{\n  Bar(T&amp; myT){}\n  Bar(const Bar&amp;) = delete;\n};\n\ntemplate&lt;class T&gt;\nstruct Foo: public T,\n            public Bar&lt;T&gt;\n{\n    Foo(): Bar&lt;T&gt;(*this){}\n};\n\nclass Baz{};\n\nint main()\n{\n    Foo&lt;Baz&gt; myFoo;\n    return 0;\n}\n</code></pre>\n<p>Gives me this error:</p>\n<pre><code>error: call to constructor of 'Bar&lt;Baz&gt;' is ambiguous\n</code></pre>\n<p>How can I fix this?</p>\n<p>(Seems simple, I'm sure there's a duplicate somewhere, but I couldn't find it... all questions I found with \"ambiguous constructor\" stuff had to do with overloaded constructors, and this seems different to me.)</p>\n", "AcceptedAnswerId": "26569369", "Title": "Call to template base constructor is ambiguous", "CreationDate": "2014-10-26T02:31:54.763", "Id": "26569239", "CommentCount": "0", "LastEditDate": "2014-10-26T02:43:22.430", "PostTypeId": "1", "LastEditorUserId": "4174511", "LastActivityDate": "2014-10-26T03:05:51.557", "Score": "1", "OwnerUserId": "4174511", "Tags": "<c++><templates><constructor>", "AnswerCount": "2"}, "26569319": {"Id": "26569319", "PostTypeId": "2", "Body": "<p>You have two constructors in <code>Bar&lt;Baz&gt;</code>:</p>\n<pre><code>Bar(Baz&amp; );\nBar(const Bar&amp; );\n</code></pre>\n<p>The fact that the second is deleted doesn't matter for the purposes of overload resolution. You are trying to construct it from a <code>Foo&lt;Baz&gt;&amp;</code>... which is both a <code>Baz</code> and a <code>Bar&lt;Baz&gt;</code>, so both overloads apply - and the compiler can't prefer one over the other, so gives you the ambiguous error. Here's a simpler example with no templates that demonstrates the same issue:</p>\n<pre><code>struct A { };\nstruct B { };\n\nstruct C : A, B { };\n\nvoid foo(A&amp; ) { }\nvoid foo(B&amp; ) { }\n\nint main() {\n    C c;\n    foo(c); //  error: call of overloaded \u2018foo(C&amp;)\u2019 is ambiguous\n}\n</code></pre>\n<p>To break the ambiguity, could just explicitly tell the compiler which overload to use with casting: </p>\n<pre><code>Foo(): Bar&lt;T&gt;(static_cast&lt;T&amp;&gt;(*this)) {} // will call Bar(Baz&amp;)\n</code></pre>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2014-10-26T03:02:24.780", "Score": "0", "CreationDate": "2014-10-26T02:49:27.030", "ParentId": "26569239", "CommentCount": "3", "OwnerUserId": "2069064", "LastEditDate": "2014-10-26T03:02:24.780"}});