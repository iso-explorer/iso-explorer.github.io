post_cb({"bq_ids": {"n4140": {"so_24000710_24000744_3": {"length": 6, "quality": 1.0, "section_id": 398}, "so_24000710_24000744_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 6002}, "so_24000710_24000744_2": {"length": 11, "quality": 0.8461538461538461, "section_id": 6002}}, "n3337": {"so_24000710_24000744_3": {"length": 6, "quality": 1.0, "section_id": 389}, "so_24000710_24000744_2": {"length": 11, "quality": 0.8461538461538461, "section_id": 5770}, "so_24000710_24000744_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5770}}, "n4659": {"so_24000710_24000744_3": {"length": 6, "quality": 1.0, "section_id": 415}, "so_24000710_24000744_2": {"length": 11, "quality": 0.8461538461538461, "section_id": 7501}, "so_24000710_24000744_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 7501}}}, "24000710": {"ViewCount": "723", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntypedef int t;\nt a=42;\n\nint main()\n{\n    a.t::~t();\n    std::cout &lt;&lt; a; //42\n}\n</code></pre>\n<p>I'm expected that <code>a</code> will be destroyed. But it is not true, why? How does do that pseudo-destructor call will be destroyed the object?</p>\n", "AcceptedAnswerId": "24000744", "Title": "Pseudo-destructor call does not destroy an object", "CreationDate": "2014-06-02T18:09:39.817", "LastActivityDate": "2017-09-26T15:14:09.537", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2016-03-17T10:32:15.327", "OwnerDisplayName": "user2953119", "LastEditorUserId": "3647361", "Id": "24000710", "Score": "8", "Tags": "<c++><language-lawyer><destructor>", "AnswerCount": "1"}, "24000744": {"Id": "24000744", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_24000710_24000744_0\">But it is not true, why?</p>\n</blockquote>\n<p>\u00a75.2.4/1:</p>\n<blockquote>\n<p id=\"so_24000710_24000744_1\"><strong>The only effect</strong> is the evaluation of the postfix-expression before the dot or arrow.</p>\n</blockquote>\n<p>Where the postfix-expression is the expression of the object for which the call takes place. Thus a pseudo destructor call, as a call to a trivial destructor, does not end the lifetime of the object it is applied to. For instance,</p>\n<pre><code>int i = 0;\n(i += 5).~decltype(i)();\nstd::cout &lt;&lt; i;\n</code></pre>\n<p>You can't actually call a destructor for scalars, because they don't have one (see [class.dtor]). The statement is solely allowed for template code in which you call the destructor of an object whose type you don't know - it removes the necessity of writing a specialization for scalar types.</p>\n<hr>\n<p>It was noted in the comments that [expr.pseudo] does imply the existence of a destructor for scalars by</p>\n<blockquote>\n<p id=\"so_24000710_24000744_2\">The use of a <em>pseudo-destructor-name</em> after a dot <code>.</code> or arrow <code>-&gt;</code> operator\n  represents the destructor for the non-class type named by <em>type-name</em>.</p>\n</blockquote>\n<p>However, this is inconsistent with other parts of the standard, e.g. \u00a712, which calls a destructor a special member function and mentions that</p>\n<blockquote>\n<p id=\"so_24000710_24000744_3\">A destructor is used to destroy objects of its class type.</p>\n</blockquote>\n<p>It appears to be an imprecision created in C++98 days.</p>\n</hr>", "LastEditorUserId": "27678", "LastActivityDate": "2017-09-26T15:14:09.537", "Score": "20", "CreationDate": "2014-06-02T18:11:55.853", "ParentId": "24000710", "CommentCount": "10", "OwnerUserId": "3647361", "LastEditDate": "2017-09-26T15:14:09.537"}});