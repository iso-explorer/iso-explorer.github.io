post_cb({"39832962": {"ParentId": "39832733", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2016-10-03T13:34:36.390", "Score": "3", "LastEditorUserId": "3310281", "LastEditDate": "2016-10-03T14:41:52.287", "Id": "39832962", "OwnerUserId": "3310281", "Body": "<p>You can copy to and from an unaligned buffer. What you can't do is cast the buffer to a double * and then operate directly on the value in memory, as a double. Often that will cause an error because of alignment issues. </p>\n", "LastActivityDate": "2016-10-03T14:41:52.287"}, "39832905": {"ParentId": "39832733", "CommentCount": "0", "CreationDate": "2016-10-03T13:31:18.653", "OwnerUserId": "496161", "PostTypeId": "2", "Id": "39832905", "Score": "5", "Body": "<p>This is safe.</p>\n<blockquote>\n<p id=\"so_39832733_39832905_0\"><code>[basic.types]/2:</code> For any trivially copyable type <code>T</code>, if two pointers to <code>T</code> point to distinct <code>T</code> objects <code>obj1</code> and <code>obj2</code>, where\n  neither <code>obj1</code> nor <code>obj2</code> is a base-class subobject, if the underlying bytes (1.7) making up <code>obj1</code> are copied\n  into <code>obj2</code>, <code>obj2</code> shall subsequently hold the same value as <code>obj1</code>.</p>\n</blockquote>\n<p>Since <code>double</code> is trivially copyable, your code is well-defined.</p>\n", "LastActivityDate": "2016-10-03T13:31:18.653"}, "39832733": {"CommentCount": "2", "ViewCount": "121", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-10-03T13:23:10.387", "LastActivityDate": "2016-10-03T14:41:52.287", "Title": "Plain Old Data and `std::memcpy` alignment issues", "AcceptedAnswerId": "39832905", "LastEditDate": "2017-05-23T12:00:56.767", "Id": "39832733", "Score": "0", "Body": "<p>Trying to respond to <a href=\"https://stackoverflow.com/questions/39821244/store-arbitrary-elements-in-contiguous-memory\">another question</a>, I've proposed a solution that use <code>std::memcpy()</code> to store generic types in a buffer of <code>char</code>s.</p>\n<p>My doubt is about possible memory alignment issues storing POD (I know that with not-POD type, as <code>std::string</code>, is very very dangerous).</p>\n<p>In short: there are memory alignment issues with the following program?</p>\n<p>And if they are, it's possible to write something similar (that store POD values in a <code>char</code> buffer) that is safe? And how?</p>\n<pre><code>#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n\nint main()\n {\n   char  buffer[100];\n\n   double  d1 { 1.2 };\n\n   std::memmove( buffer + 1, &amp; d1, sizeof(double) );\n\n   double  d2;\n\n   std::memmove( &amp; d2, buffer + 1, sizeof(double) );\n\n   std::cout &lt;&lt; d2 &lt;&lt; std::endl;\n\n   return 0;\n }\n</code></pre>\n", "Tags": "<c++><memcpy><memory-alignment>", "OwnerUserId": "6022656", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_39832733_39832905_0": {"section_id": 7201, "quality": 0.9375, "length": 30}}, "n3337": {"so_39832733_39832905_0": {"section_id": 6945, "quality": 0.9375, "length": 30}}, "n4659": {"so_39832733_39832905_0": {"section_id": 8710, "quality": 0.9375, "length": 30}}}});