post_cb({"48830482": {"ViewCount": "73", "Body": "<p>To my astonishment the following code compiles and prints \"X\" on VC++ 2017:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n\n\nnamespace A {\n    using namespace std;\n}\n\nnamespace B {\n    using namespace A;\n}\n\nnamespace C {\n    using namespace B;\n    string a;\n}\n\nint main()\n{\n    C::a = \"X\";\n    std::cout &lt;&lt; C::a;\n    return 0;\n}\n</code></pre>\n<p>It looks like the <code>using namespace std</code> works from namespace A through namespace B into namespace C.</p>\n<p>Is this a bug in Visual C++ or does it concur with the language specification?</p>\n<p>I had expected that <code>using namespace std</code> ends at the end of the enclosing scope wich is at the end of the definition of namespace A.</p>\n<p>EDIT: I understand that the accepted answer to <a href=\"https://stackoverflow.com/questions/8775563/using-namespace-statement-inside-an-anonymous-namespace?noredirect=1&amp;lq=1\">this question</a> also answers my question. But that post is more about anonymous namespaces, while this one is about the transitivity of the using namespace directive. So I think it s a better example and the question makes sense.</p>\n", "AcceptedAnswerId": "48832182", "Title": "Is \"using namespace\" transitive in C++?", "CreationDate": "2018-02-16T15:58:29.213", "LastActivityDate": "2018-02-16T17:41:57.753", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2018-02-16T16:19:40.613", "LastEditorUserId": "1139219", "Id": "48830482", "Score": "3", "OwnerUserId": "1139219", "Tags": "<c++><namespaces>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_48830482_48832182_1": {"length": 11, "quality": 0.8461538461538461, "section_id": 5510}, "so_48830482_48832182_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 5512}}, "n3337": {"so_48830482_48832182_1": {"length": 11, "quality": 0.8461538461538461, "section_id": 5296}, "so_48830482_48832182_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 5298}}, "n4659": {"so_48830482_48832182_1": {"length": 11, "quality": 0.8461538461538461, "section_id": 6945}, "so_48830482_48832182_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 6947}}}, "48832182": {"Id": "48832182", "PostTypeId": "2", "Body": "<p>Yes:</p>\n<blockquote>\n<p id=\"so_48830482_48832182_0\"><code>[C++14: 7.3.4/4]:</code> For unqualified lookup (3.4.1), <strong>the <em>using-directive</em> is transitive</strong>: if a scope contains a <em>using-directive</em> that nominates a second namespace that itself contains <em>using-directives</em>, the effect is as if the using-directives from the second namespace also appeared in the first. <em>[..]</em></p>\n</blockquote>\n<p>So, the compiler is correct; <code>using namespace</code> here effectively imports the names into the enclosing namespace:</p>\n<blockquote>\n<p id=\"so_48830482_48832182_1\"><code>[C++14: 7.3.4/2]:</code> A <em>using-directive</em> specifies that the names in the nominated namespace can be used in the scope in which the <em>using-directive</em> appears after the <em>using-directive</em>. <em>[..]</em></p>\n</blockquote>\n<p>The \"scope\" here is that of the namespace; the contents of a scope doesn't vanish just because a <code>}</code> is encountered. Familiarity with block scopes sometimes makes it feel that way, though.</p>\n", "LastActivityDate": "2018-02-16T17:41:57.753", "Score": "1", "CreationDate": "2018-02-16T17:41:57.753", "ParentId": "48830482", "CommentCount": "0", "OwnerUserId": "560648"}});