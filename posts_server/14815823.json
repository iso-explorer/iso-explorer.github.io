post_cb({"14816004": {"ParentId": "14815823", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From Paragraph 5.2.7/4 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_14815823_14816004_0\">When typeid is applied to a type-id, the result refers to a std::type_info object representing the type of the type-id. <strong>If the type of the type-id is a reference to a possibly cv-qualified type, the result of the typeid expression refers to a std::type_info object representing the cv-unqualified referenced type</strong>. If the type of the type-id is a class type or a reference to a class type, the class shall be completely-defined.</p>\n</blockquote>\n<p>Thus, <code>typeid(int)</code> and <code>typeid(int&amp;)</code> will give the same result, although the two types are definitely different. Similarly, for the type system <code>int</code> and <code>int const</code> are different types, but the <code>typeid</code> operator ignores the <code>const</code> qualification. From Paragraph 5.2.7/5 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_14815823_14816004_1\">The top-level cv-qualifiers of the glvalue expression or the type-id that is the operand of typeid are always ignored.</p>\n</blockquote>\n<p>Finally, <code>int</code> and <code>int*</code> are again different types for the type system, and the <code>typeid</code> operator returns different results for them.</p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-02-11T16:13:01.883", "Id": "14816004", "Score": "4", "CreationDate": "2013-02-11T16:07:13.113", "LastActivityDate": "2013-02-11T16:13:01.883"}, "14815899": {"ParentId": "14815823", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Type qualifiers, (<code>const</code> and <code>volatile</code>), create different types.  <code>int</code> is a different type from <code>const int</code>.  </p>\n<p>So do references, pointers, and arrays. For example:</p>\n<p><code>int</code>, <code>int&amp;</code>, <code>int[10]</code> and <code>int*</code> are all different types.</p>\n<p><code>T</code> is a different type from <code>std::remove_reference&lt;T&gt;::type</code> if <code>T</code> is a reference.</p>\n<p>The <code>&lt;typeinfo&gt;</code> output of <code>typeid(int).name()</code> is platform-dependent and doesn't have to distinguish between reference/non-reference types.  However, the C++ type system <em>definitely</em> distinguishes between <code>T</code> and <code>T&amp;</code>, as you've discovered through <code>type_traits</code>.</p>\n", "OwnerUserId": "168288", "LastEditorUserId": "168288", "LastEditDate": "2013-02-11T16:07:56.340", "Id": "14815899", "Score": "2", "CreationDate": "2013-02-11T16:01:31.807", "LastActivityDate": "2013-02-11T16:07:56.340"}, "14815823": {"CommentCount": "2", "ViewCount": "133", "PostTypeId": "1", "LastEditorUserId": "1606729", "CreationDate": "2013-02-11T15:57:36.213", "LastActivityDate": "2013-02-11T16:13:01.883", "Title": "C++ type qualifiers and equality", "AcceptedAnswerId": "14816004", "LastEditDate": "2013-02-11T15:59:06.753", "Id": "14815823", "Score": "0", "Body": "<p>Are <code>int&amp;</code> and <code>int</code> the same type? if I use <code>is_same&lt;int,int&amp;&gt;::value</code> i get <code>false</code> but <code>typeid(int).name() == typeid(int&amp;).name()</code> are the same?</p>\n<p>secondly the same question for <code>int</code> and <code>const int</code>?</p>\n<p>Thirdly <code>int</code> and <code>int*</code>?</p>\n<p>I can understand if <code>int</code> and <code>int*</code> are not as one actually stores the address of another object and works differently but I would have thought <code>int&amp;</code> and <code>int</code> are as one is just an alias for another.</p>\n<p>Keen to get some good commentary on this.</p>\n", "Tags": "<c++>", "OwnerUserId": "891812", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_14815823_14816004_0": {"section_id": 6023, "quality": 0.9444444444444444, "length": 34}}, "n3337": {"so_14815823_14816004_1": {"section_id": 5792, "quality": 0.9, "length": 9}, "so_14815823_14816004_0": {"section_id": 5791, "quality": 0.9444444444444444, "length": 34}}, "n4659": {"so_14815823_14816004_0": {"section_id": 7522, "quality": 1.0, "length": 36}}}, "14816007": {"ParentId": "14815823", "CommentCount": "3", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/types/type_info/name\" rel=\"nofollow\"><code>std::type_info::name</code></a> says nothing about identity. <em>If</em> you insist on using <code>typeid</code> to test for identity, try the following:</p>\n<pre><code>assert(typeid(T) != typeid(U));\n</code></pre>\n<p>This is using the defined <a href=\"http://en.cppreference.com/w/cpp/types/type_info/operator_cmp\" rel=\"nofollow\">equality comparison operator</a> on the <code>type_info</code> objects. But prepare for disappointment: the above assertion will fail for <code>T = int</code> and <code>U = int&amp;</code> because of \u00a75.2.7/4 (see Andy\u2019s anser).</p>\n", "OwnerUserId": "1968", "PostTypeId": "2", "Id": "14816007", "Score": "0", "CreationDate": "2013-02-11T16:07:25.400", "LastActivityDate": "2013-02-11T16:07:25.400"}});