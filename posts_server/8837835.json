post_cb({"bq_ids": {"n4140": {"so_8837835_8837889_0": {"length": 25, "quality": 0.5319148936170213, "section_id": 5914}}, "n3337": {"so_8837835_8837889_0": {"length": 25, "quality": 0.5319148936170213, "section_id": 5686}}, "n4659": {"so_8837835_8837889_0": {"length": 25, "quality": 0.5319148936170213, "section_id": 7406}}}, "8837889": {"Id": "8837889", "PostTypeId": "2", "Body": "<p>A union can only be used with POD types, and as such cannot have members with virtual functions or nontrivial constructors/destructors, so this is undefined behaviour. Read (taken from <a href=\"https://stackoverflow.com/a/1873233/726361\">this answer</a>) \u00a79.5.1 of the standard:</p>\n<blockquote>\n<p id=\"so_8837835_8837889_0\">A union can have member functions (including constructors and\n  destructors), but not virtual functions. A union shall not have base\n  classes. A union shall not be used as a base class. An object of a\n  class with a non-trivial constructor, a non-trivial copy-constructor,\n  a non-trivial destructor, or a non-trivial copy assignment operator\n  cannot be a member of a union, nor can an array of such objects. If a\n  union contains a static data member, or a member of a reference type,\n  the program is ill-formed.</p>\n</blockquote>\n<p>And</p>\n<blockquote>\n<p id=\"so_8837835_8837889_1\">In certain contexts, C++ allows only POD types to be used. For\n  example, a union in C++ cannot contain a class that has virtual\n  functions, or nontrivial constructors or destructors. This restriction\n  is imposed because the compiler cannot know which constructor or\n  destructor should be called for a union.</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-01-12T15:51:05.250", "Score": "2", "CreationDate": "2012-01-12T15:45:54.267", "ParentId": "8837835", "CommentCount": "5", "OwnerUserId": "726361", "LastEditDate": "2017-05-23T10:24:23.903"}, "8837835": {"ViewCount": "400", "Body": "<p>I have the following program:</p>\n<pre><code>#include &lt;initializer_list&gt;\n#include &lt;iostream&gt;\n\nclass A;\nclass nih {\npublic:\n    virtual void apply(A &amp; a) const { std::cout &lt;&lt; \"generic\" &lt;&lt; std::endl; };\n};\n\nunion niit;\nclass A {\npublic:\n  int s; char kau;\n  A() : s(1), kau('-') { }\n  A(std::initializer_list&lt;niit&gt; k);\n};\n\nclass sn : public nih { int s; public: sn(int x) : s(x) { }\n  virtual void apply(A &amp; a) const { a.s=s; } };\nclass kaun : public nih { char kau; public: kaun(char x) : kau(x) { }\n  virtual void apply(A &amp; a) const { a.kau=kau; } };\nunion niit { sn sni; kaun kauni; nih nihi;\n  niit(const sn &amp; s) : sni(s) { }\n  niit(const kaun &amp; k) : kauni(k) { }\n};\n\nA::A(std::initializer_list&lt;niit&gt; k) { \n  const niit *n=k.begin();\n  for(int i=0;i&lt;k.size();i++) {\n    const nih* p=&amp;n[i].nihi;\n    p-&gt;apply(*this);\n  }\n}\n\nint main(int argc, char**argv) {\n  A r {kaun('a'),sn(91)};\n  std::cout &lt;&lt; r.s &lt;&lt; r.kau &lt;&lt; std::endl;\n}\n</code></pre>\n<p>I get the expected result, which is <code>91a</code>. However, if I change the line</p>\n<pre><code>p-&gt;apply(*this);\n</code></pre>\n<p>to the following:</p>\n<pre><code>((const nih*)(&amp;n[i].nihi))-&gt;apply(*this);\n</code></pre>\n<p>which should be replacement with an equivalent value, it no longer works, and instead it prints:</p>\n<pre><code>generic\ngeneric\n0\n</code></pre>\n<p>That is, it executes the generic method from <code>nih</code>. Why is that? I tried gcc 4.6 with option <code>-std=c++0x</code>, in case it matters.</p>\n", "AcceptedAnswerId": "8837889", "Title": "C++ initializer lists with unions, why different results?", "CreationDate": "2012-01-12T15:42:52.600", "Id": "8837835", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2012-01-12T15:51:05.250", "Score": "1", "OwnerUserId": "448765", "Tags": "<c++><pointers><initialization><virtual><unions>", "AnswerCount": "1"}});