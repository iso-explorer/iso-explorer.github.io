post_cb({"17646210": {"ParentId": "17642022", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You are only affecting the visibility of the injected-class-name. The access protection of the base subobject or its members should not be affected. If Clang or GCC allows it to affect a cast validity or access within the base, that's their bug.</p>\n<p>[class.member.lookup] 10.2/3 says</p>\n<blockquote>\n<p id=\"so_17642022_17646210_0\">In the declaration set, using-declarations are replaced by the members they designate, and type declarations (including injected-class-names) are replaced by the types they designate.</p>\n</blockquote>\n<p>The base class subobject does not have a name in member lookup; the injected-class-name does.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2013-07-15T06:42:36.220", "Id": "17646210", "Score": "5", "CreationDate": "2013-07-15T03:11:15.153", "LastActivityDate": "2013-07-15T06:42:36.220"}, "bq_ids": {"n4140": {"so_17642022_17646210_0": {"section_id": 6991, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_17642022_17646210_0": {"section_id": 6737, "quality": 1.0, "length": 15}}, "n4659": {"so_17642022_17646210_0": {"section_id": 8489, "quality": 0.8666666666666667, "length": 13}}}, "17642022": {"CommentCount": "4", "AcceptedAnswerId": "17646210", "PostTypeId": "1", "LastEditorUserId": "557612", "CreationDate": "2013-07-14T17:52:44.893", "LastActivityDate": "2013-07-15T06:42:36.220", "LastEditDate": "2013-07-15T03:01:58.217", "ViewCount": "139", "FavoriteCount": "1", "Title": "\"using\" with base class name to change access valid?", "Id": "17642022", "Score": "5", "Body": "<p>My friend has shown me the follow code</p>\n<pre><code>struct A {\n  virtual void f() = 0;\n  virtual void g() = 0;\n};\n\nstruct AInternal : A {\n  virtual void f() { /* ... */ }\n  virtual void g() { /* ... */ }\n};\n</code></pre>\n<p>He is using <code>AInternal</code> as an internal class that implements most (if not all of <code>A</code>). He then inherited from <code>AInternal</code>, but as he wanted that <code>AInternal</code> stays inaccessible (since it is an implementation detail), he inherits protected (implemented in terms of). What he also did was <code>using</code>ing the base class name to make <code>A</code> accessible (it was protected by default, since <code>AInternal</code> was inherited protected too)</p>\n<pre><code>struct C : protected AInternal {\n  using AInternal::A;\n};\n</code></pre>\n<p>Actually, this worked fine (but as we later found, it still kept the member functions <code>private</code> - just the base class was made <code>public</code>), but it only worked on GCC. It fails to make base <code>A</code> accessible. Any idea? We could even make it to break code that works on Clang</p>\n<pre><code>struct C : public AInternal {\nprotected:\n  using AInternal::A;\n};\n\nC *c = 0;\nA *a = c; // error on GCC!\n</code></pre>\n<p>Can someone help out please?</p>\n", "Tags": "<c++><using-declaration>", "OwnerUserId": "34509", "AnswerCount": "1"}});