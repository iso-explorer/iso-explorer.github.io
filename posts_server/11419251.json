post_cb({"bq_ids": {"n4140": {"so_11419251_11419296_0": {"length": 29, "quality": 0.6304347826086957, "section_id": 31}}, "n3337": {"so_11419251_11419296_0": {"length": 29, "quality": 0.6304347826086957, "section_id": 28}}, "n4659": {"so_11419251_11419296_0": {"length": 29, "quality": 0.6304347826086957, "section_id": 31}}}, "11419316": {"Id": "11419316", "PostTypeId": "2", "Body": "<p>Unsigned arithmetic, including conversion from signed types, is modular, with the modulus being 2<sup>n</sup> (where <code>n</code> is the number of bits).</p>\n<p>Assuming that <code>char</code> has 8 bits, then -128 is congruent to 128, modulo 256; so that is the result of the conversion.</p>\n<p>UPDATE: as noted in the comments, this assumes that -128 is a valid value for type <code>char</code>, which is not necessarily the case. <code>char</code> has a range of at least <code>[0..127]</code>, and <code>signed char</code> at least <code>[-127..127]</code>.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2012-07-10T20:38:13.943", "Score": "6", "CreationDate": "2012-07-10T18:10:30.173", "ParentId": "11419251", "CommentCount": "9", "OwnerUserId": "204847", "LastEditDate": "2012-07-10T20:38:13.943"}, "11419296": {"Id": "11419296", "PostTypeId": "2", "Body": "<p>Unsigned arithmetic, and conversion to unsigned, takes place modulo 2<sup>N</sup>.  You have an 8-bit character, so N is 8, and 2<sup>N</sup> is 256.</p>\n<p>-128 and 128 are congruent modulo 256.</p>\n<p>Here is the actual rule found in section 4.7 (<code>[conv.integral]</code>):</p>\n<blockquote id=\"so_11419251_11419296_0\">\n<ul>\n<li>If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2<sup>n</sup>\n  where n is the number of bits used to represent the unsigned type).  [ Note:  In a two\u2019s\n  complement representation, this conversion is conceptual and there is no change in the bit pattern (if there\n  is no truncation).  \u2014 end note ]</li>\n<li>If the destination type is signed, the value is unchanged if it can be represented in the destination type (and\n  bit-\ufb01eld width); otherwise, the value is implementation-de\ufb01ned.</li>\n</ul>\n</blockquote>\n", "LastEditorUserId": "103167", "LastActivityDate": "2012-07-10T18:18:23.980", "Score": "5", "CreationDate": "2012-07-10T18:08:56.237", "ParentId": "11419251", "CommentCount": "0", "OwnerUserId": "103167", "LastEditDate": "2012-07-10T18:18:23.980"}, "11419344": {"Id": "11419344", "PostTypeId": "2", "Body": "<p>The conversion works by reinterpreting the same bit pattern in a different way, not by adding +128 to bias the scope. Read up on <a href=\"http://en.wikipedia.org/wiki/Two%27s_complement\" rel=\"nofollow\">two's complement</a> to learn more.</p>\n", "LastActivityDate": "2012-07-10T18:11:39.690", "CommentCount": "2", "CreationDate": "2012-07-10T18:11:39.690", "ParentId": "11419251", "Score": "1", "OwnerUserId": "374746"}, "11419251": {"ViewCount": "409", "Body": "<p>How the conversion works ? For example:\nScope of char[-128, 127],\nscope of unsigned char[0, 255]</p>\n<pre><code>char x = -128;\nunsigned char y = static_cast&lt;unsigned char&gt;(x);\ncout&lt;&lt;y; //128\n</code></pre>\n<p>Why not 0 ?</p>\n", "Title": "converting char to unsigned char", "CreationDate": "2012-07-10T18:05:58.520", "LastActivityDate": "2012-07-10T20:38:13.943", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "Id": "11419251", "Score": "0", "OwnerUserId": "1371057", "Tags": "<c++>", "AnswerCount": "3"}});