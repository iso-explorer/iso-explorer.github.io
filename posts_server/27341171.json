post_cb({"27341219": {"ParentId": "27341171", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>First of all, your code is broken. There is no such an argument and return type as <code>ind</code>. I will assume that you meant <code>int</code>.</p>\n<p>Secondly, POD types have precedence over custom types in C++ when it comes to implicit conversion.</p>\n<blockquote>\n<p id=\"so_27341171_27341219_0\">Why std::string convert to bool instead of QString?</p>\n</blockquote>\n<p>I do not know why you think it would be <code>std::string</code>. It simply is not, not even in C++. It is the good old const char[X] where X happens to be three in your case (two letters + terminating nil).</p>\n<blockquote>\n<p id=\"so_27341171_27341219_1\">Or can I specify all string literals to be QString at compilation?</p>\n</blockquote>\n<p>No, but you ought to use this in any case when dealing with string literals in Qt regardless of this situation:</p>\n<pre><code>filters-&gt;addFilter(familyNameInd, QStringLiteral(\"\u041c*\"));\n</code></pre>\n<p>For raw string literals like this, please do <em>not</em> use the <code>QString</code> contructor. It is pointless. Therefore, you would be writing something like this:</p>\n<h3>main.cpp</h3>\n<pre><code>#include &lt;QString&gt;\n#include &lt;QDebug&gt;\n\nint addFilter(int column, const QString &amp; condition) { qDebug() &lt;&lt; \"Test 1\"; }\nint addFilter(int column, bool condition) { qDebug() &lt;&lt; \"Test 2\"; }\n\nint main()\n{\n    addFilter(0, QStringLiteral(\"foo\"));\n    return 0;\n}\n</code></pre>\n<h3>main.pro</h3>\n<pre><code>TEMPLATE = app\nTARGET = main\nQT = core\nSOURCES += main.cpp\n</code></pre>\n<h3>Build and Run</h3>\n<pre><code>qmake &amp;&amp; make &amp;&amp; ./main\n</code></pre>\n<h3>Output</h3>\n<pre><code>Test 1\n</code></pre>\n", "OwnerUserId": "2682142", "LastEditorUserId": "2682142", "LastEditDate": "2014-12-07T09:23:43.047", "Id": "27341219", "Score": "1", "CreationDate": "2014-12-07T09:09:46.403", "LastActivityDate": "2014-12-07T09:23:43.047"}, "27341209": {"ParentId": "27341171", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>\"M*\" is a const char* which is convertible to a bool due to implicit conversion rules.\nThe implicit conversion will be chosen over the QString class.</p>\n<p>You are going to have to call the function like this:</p>\n<pre><code>filters-&gt;addFilter(familyNameInd, QString(\"\u041c*\"));\n</code></pre>\n<p>To avoid an unnecessary copy of the QString, consider using the QStringLiteral macro as well:</p>\n<pre><code>filters-&gt;addFilter(familyNameInd, QStringLiteral(\"\u041c*\"));\n</code></pre>\n", "OwnerUserId": "908939", "LastEditorUserId": "908939", "LastEditDate": "2014-12-08T11:05:52.713", "Id": "27341209", "Score": "2", "CreationDate": "2014-12-07T09:06:44.313", "LastActivityDate": "2014-12-08T11:05:52.713"}, "27341212": {"ParentId": "27341171", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>According to the C++ Standard (13.3.3.2 Ranking implicit conversion sequences)</p>\n<blockquote>\n<p id=\"so_27341171_27341212_0\">2 When comparing the basic forms of implicit conversion sequences (as\n  defined in 13.3.3.1) \u2014 a standard conversion sequence (13.3.3.1.1) is\n  a better conversion sequence than a user-defined conversion sequence\n  or an ellipsis conversion sequence, and ...</p>\n</blockquote>\n<p>Relative to your example converting to bool is a standard implicit conversion. So it s better than user-defined conversion using a conversion constructor.\nSo if you want that the overloaded function with parameter of type <code>const QString &amp;</code> would be called you have to specify explicitly the conversion from the string literal to a temporary object of type <code>QString:</code>QString( \"\u041c*\" )`. </p>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2014-12-07T09:15:21.740", "Id": "27341212", "Score": "3", "CreationDate": "2014-12-07T09:07:06.867", "LastActivityDate": "2014-12-07T09:15:21.740"}, "bq_ids": {"n4140": {"so_27341171_27341212_0": {"section_id": 638, "quality": 0.9090909090909091, "length": 20}}, "n3337": {"so_27341171_27341212_0": {"section_id": 628, "quality": 0.9090909090909091, "length": 20}}, "n4659": {"so_27341171_27341212_0": {"section_id": 666, "quality": 0.9090909090909091, "length": 20}}}, "27341171": {"CommentCount": "0", "ViewCount": "122", "PostTypeId": "1", "LastEditorUserId": "2492977", "CreationDate": "2014-12-07T09:00:20.270", "LastActivityDate": "2014-12-08T11:05:52.713", "Title": "Unexpected behavior string literal", "AcceptedAnswerId": "27341212", "LastEditDate": "2014-12-07T09:01:22.280", "Id": "27341171", "Score": "2", "Body": "<p>I have two methods:</p>\n<pre><code>ind addFilter(ind column, const QString &amp; condition);\nind addFilter(ind column, bool condition);\n</code></pre>\n<p>When I use this construction gcc choose second method (with <code>bool condition</code>)</p>\n<pre><code>filters-&gt;addFilter(familyNameInd, \"\u041c*\");\n</code></pre>\n<p>Why <code>std::string</code> convert to bool instead of QString? Or can I specify all string literals to be QString at compilation?</p>\n", "Tags": "<c++><qt>", "OwnerUserId": "2909917", "AnswerCount": "3"}});