post_cb({"bq_ids": {"n4140": {"so_1943847_1943871_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 5397}}, "n3337": {"so_1943847_1943871_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 5191}, "so_1943847_1943871_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 5192}}, "n4659": {"so_1943847_1943871_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 6822}}}, "1943871": {"Id": "1943871", "PostTypeId": "2", "Body": "<p>C++ standard:</p>\n<blockquote>\n<p id=\"so_1943847_1943871_0\">7.1.1/6: \"A name declared in a namespace scope without a\n  storage-class-specifier has external\n  linkage unless it has internal linkage\n  because of a previous declaration\" [or unless it's const].</p>\n</blockquote>\n<p>In your first case, <code>name</code> is declared in a namespace scope (specifically, the global namespace). The first declaration therefore alters the linkage of the second declaration.</p>\n<p>The inverse is banned because:</p>\n<blockquote>\n<p id=\"so_1943847_1943871_1\">7.1.1/7: \"The linkages implied by successive declarations for a given\n  entity shall agree\".</p>\n</blockquote>\n<p>So, in your second example, the first declaration has external linkage (by 7.1.1/6), and the second has internal linkage (explicitly), and these do not agree.</p>\n<p>You also ask about C, and I imagine it's the same sort of thing. But I have the C++ book right here, whereas you're as capable of looking in a draft C standard online as I am ;-)</p>\n", "LastActivityDate": "2009-12-22T02:32:06.297", "CommentCount": "2", "CreationDate": "2009-12-22T02:32:06.297", "ParentId": "1943847", "Score": "12", "OwnerUserId": "13005"}, "1943847": {"ViewCount": "254", "Body": "<p>I noticed a very curious behavior that, if standard, I would be very happy to exploit (what I'd like to do with it is fairly complex to explain and irrelevant to the question).</p>\n<p>The behavior is:</p>\n<pre><code>static void name();\nvoid name() {\n    /* This function is now static, even if in the declaration\n     * there is no static keyword. Tested on GCC and VS. */\n}\n</code></pre>\n<p>What's curious is that the inverse produces a compile time error:</p>\n<pre><code>void name();\nstatic void name() {\n    /* Illegal */\n}\n</code></pre>\n<p>So, is this standard and can I expect other compilers to behave the same way? Thanks!</p>\n", "AcceptedAnswerId": "1943871", "Title": "Declaring a function static and later non-static: is it standard?", "CreationDate": "2009-12-22T02:20:14.573", "Id": "1943847", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2009-12-22T03:14:27.053", "Score": "6", "OwnerUserId": "95135", "Tags": "<c++><c><standards>", "AnswerCount": "2"}, "1943873": {"Id": "1943873", "PostTypeId": "2", "Body": "<p>Qualifiers that you put on the function prototype (or that are implied) are automatically used when the function is declared.</p>\n<p>So in your second case the lack of <code>static</code> on the prototype meant that the function was defined as NOT static, and then when it was later declared as static, that was an error.</p>\n<p>If you were to leave off the return type in the prototype, then the default would be <code>int</code> and then you would get an error again with the <code>void</code> return type.  The same thing happens with <code>__crtapi</code> and <code>__stdcall</code> and <code>__declspec()</code> (in the Microsoft C compiler).</p>\n", "LastEditorUserId": "15168", "LastActivityDate": "2009-12-22T03:14:27.053", "Score": "3", "CreationDate": "2009-12-22T02:32:57.543", "ParentId": "1943847", "CommentCount": "0", "OwnerUserId": "234815", "LastEditDate": "2009-12-22T03:14:27.053"}});