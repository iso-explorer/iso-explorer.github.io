post_cb({"bq_ids": {"n4140": {"so_9006663_9006761_2": {"length": 15, "quality": 1.0, "section_id": 6351}, "so_9006663_9006761_1": {"length": 14, "quality": 0.875, "section_id": 745}, "so_9006663_9006761_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 713}}, "n3337": {"so_9006663_9006761_2": {"length": 15, "quality": 1.0, "section_id": 6108}, "so_9006663_9006761_1": {"length": 14, "quality": 0.875, "section_id": 734}, "so_9006663_9006761_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 702}}, "n4659": {"so_9006663_9006761_2": {"length": 15, "quality": 1.0, "section_id": 7860}, "so_9006663_9006761_1": {"length": 14, "quality": 0.875, "section_id": 803}, "so_9006663_9006761_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 742}}}, "9006663": {"ViewCount": "153", "Body": "<p>Let's say that in the main thread of a C++11 program I build an <code>std::set</code>, fill it with items and extract an iterator <code>it</code> from it. After that, from another thread, I start modifying the set in such a way that elements can only be added to it but not erased.</p>\n<p>Is the validity of <code>it</code> assured also while the set is being modified, or should I consider <code>it</code> invalid while the set is being modified by insertion operations from the other thread?</p>\n", "AcceptedAnswerId": "9006761", "Title": "Iterators validity and threads", "CreationDate": "2012-01-25T16:56:50.040", "Id": "9006663", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2012-01-25T17:07:21.530", "Score": "1", "OwnerUserId": "453925", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "9006761": {"Id": "9006761", "PostTypeId": "2", "Body": "<p>From section 23.2.1 <code>[container.requirements.general]</code>:</p>\n<blockquote>\n<p id=\"so_9006663_9006761_0\">Unless otherwise specified (either explicitly or by defining a function in terms of other functions), invoking a container member function or passing a container as an argument to a library function shall not invalidate iterators to, or change the values of, objects within that container.</p>\n</blockquote>\n<p>For associative containers such as <code>std::set</code>, section 23.2.4 (<code>[associative.reqmts]</code>) says:</p>\n<blockquote>\n<p id=\"so_9006663_9006761_1\">The <code>insert</code> and <code>emplace</code> members shall not a\ufb00ect the validity of iterators and references to the container, and the <code>erase</code> members shall invalidate only iterators and references to the erased elements.</p>\n</blockquote>\n<p>So your iterators will remain valid after inserting additional items.</p>\n<p>However, thread safety is a different topic completely.</p>\n<p>Section 17.6.5.9 (<code>[res.on.data.races]</code>) provides that</p>\n<blockquote>\n<p id=\"so_9006663_9006761_2\">Operations on iterators obtained by calling a standard library container or string member function may access the underlying container, but shall not modify it.</p>\n</blockquote>\n<p>Since that results in reading the container while it's being updated, <strong>it is not necessarily safe to use a <code>std::set</code> iterator while inserting into the collection from another thread</strong>.  Your implementation may provide a stronger guarantee.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2012-01-25T17:07:21.530", "Score": "3", "CreationDate": "2012-01-25T17:02:09.787", "ParentId": "9006663", "CommentCount": "5", "OwnerUserId": "103167", "LastEditDate": "2012-01-25T17:07:21.530"}});