post_cb({"bq_ids": {"n4140": {"so_45136738_45137750_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 7239}}, "n3337": {"so_45136738_45137750_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 6983}}, "n4659": {"so_45136738_45137750_0": {"length": 19, "quality": 1.0, "section_id": 8748}}}, "45158653": {"Id": "45158653", "PostTypeId": "2", "Body": "<p><sub>\n<em>(Documenting the comments made by <a href=\"https://stackoverflow.com/users/2756719/t-c\"><strong>@T.C.</strong></a> that ultimately answer my question)<br>\n(I will remove this if T.C. ever wishes to reformulate his own answer.)</br></em></sub></p>\n<hr>\n<blockquote>\n<p id=\"so_45136738_45158653_0\">Oddly enough, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2213.pdf\" rel=\"nofollow noreferrer\">N2213</a> had wording that guarantees identical\n  representation to underlying type, but that wording was removed in\n  <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf\" rel=\"nofollow noreferrer\">N2347</a>. In fact, it even removed the C++03 wording providing for\n  identical sizeof without any obvious replacement.</p>\n</blockquote>\n<p><br/></p>\n<blockquote>\n<p id=\"so_45136738_45158653_1\">The more general question regarding enums and their underlying types\n  is probably worth a core issue, given that CWG approved this\n  formulation of <code>std::byte</code> and presumably thought that the\n  size/alignment relationship exists. As a practical matter, the clear\n  intent is for <code>std::byte</code> to take up, well, one byte; no sane\n  implementer would do it differently.</p>\n</blockquote>\n</hr>", "LastActivityDate": "2017-07-18T06:01:45.557", "Score": "3", "CreationDate": "2017-07-18T06:01:45.557", "ParentId": "45136738", "CommentCount": "0", "OwnerUserId": "817643", "CommunityOwnedDate": "2017-07-18T06:01:45.557"}, "45137750": {"Id": "45137750", "PostTypeId": "2", "Body": "<p>Essentially there is special wording all around the c++17 draft standard  that gives <code>std::byte</code> the same properties with regard to aliasing as <code>char</code> and <code>unsigned char</code>. </p>\n<p>To give you an example, in $6.10 in n4659  it states</p>\n<blockquote>\n<p id=\"so_45136738_45137750_0\">8 If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined.<br>\n  [...]<br>\n  (8.8) \u2014 a char, unsigned char, or <strong>std::byte type.</strong></br></br></p>\n</blockquote>\n<p>I didn't do an exhaustive search, but  essentially anywhere that char gets special treatment in the standard, the same is given to std::byte. As far as accessing memory is concerned, it seems irrelevant that it is defined as an enum or what it's underlying type is.</p>\n<p><strong>EDIT</strong><br>\nMaybe I understood your question wrongly: If you are asking, if the standard guarantees that <code>sizeof(std::byte) == alignof(std::byte) == 1</code> then I believe this is not the case, as there seems to be no wording about how those properties depend on the underlying type of a scoped enum and I couldn't find special wording for <code>std::byte</code> in that regard. As @T.C. mentions in the comments, this is probably a defect in the language.</br></p>\n", "LastEditorUserId": "2881849", "LastActivityDate": "2017-07-17T08:31:36.043", "Score": "8", "CreationDate": "2017-07-17T06:55:04.230", "ParentId": "45136738", "CommentCount": "5", "OwnerUserId": "2881849", "LastEditDate": "2017-07-17T08:31:36.043"}, "45136738": {"ViewCount": "878", "Body": "<p>C++17 introduces the <code>std::byte</code> type. A library type that can (supposedly) be used to access raw memory, but stands separate from the character types and represents a mere lump of bits.</p>\n<p>So far so good. But the definition has me slightly worried. As given in <a href=\"http://eel.is/c++draft/cstddef.syn#lib:byte\" rel=\"noreferrer\">[cstddef.syn]</a>:</p>\n<pre><code>enum class byte : unsigned char {};\n</code></pre>\n<p>I have seen two answers on SO which seem to imply different things about the robustness of the above. <a href=\"https://stackoverflow.com/a/44508267/817643\">This answer</a> argues (without reference) that an enumeration with an underlying type has the same size and alignment requirements as said type. Intuitively this seems correct, since specifying an underlying type allows for opaque enum declarations.</p>\n<p>However, <a href=\"https://stackoverflow.com/a/45056142/817643\">this answer</a> argues that the standard only guarantees that two enumerations with the same underlying type are layout compatible, and no more.</p>\n<p>When reading <a href=\"http://eel.is/c++draft/dcl.enum\" rel=\"noreferrer\">[dcl.enum]</a> I couldn't help but notice that indeed, the underlying type is only used to specify the range of the enumerators. There is no mention of size or alignment requirements.</p>\n<p>What am I missing?</p>\n", "AcceptedAnswerId": "45158653", "Title": "Is std::byte well defined?", "CreationDate": "2017-07-17T05:46:08.927", "Id": "45136738", "CommentCount": "16", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2017-07-18T06:01:45.557", "Score": "23", "OwnerUserId": "817643", "Tags": "<c++><c++1z>", "AnswerCount": "2"}});