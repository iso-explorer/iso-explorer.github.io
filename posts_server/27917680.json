post_cb({"27917680": {"CommentCount": "4", "AcceptedAnswerId": "27922878", "PostTypeId": "1", "LastEditorUserId": "1758528", "CreationDate": "2015-01-13T08:22:06.357", "LastActivityDate": "2017-01-31T23:39:49.510", "LastEditDate": "2015-01-13T09:59:33.380", "ViewCount": "271", "FavoriteCount": "1", "Title": "friend template argument-dependent lookup", "Id": "27917680", "Score": "3", "Body": "<p>It'n known that friend function defined in class scope can be found via argument-dependent lookup so we have to use class type in friend function type, but if we define friend function outside of class it function parameters can be left empty.\nSo how this works for template friends, if we have specialization outside of class it should be visible as ordinary friend function defined outside of class scope.</p>\n<pre><code>#include &lt;iostream&gt;    \nclass A\n{\npublic:\n        A()\n         : x(20)\n        {}\n        template &lt;typename T&gt;\n        friend void foo()\n        {\n               std::cout &lt;&lt; \"Primary Template\" &lt;&lt; std::endl;\n        }\n        friend void goo();\nprivate:\n        int x;\n};\n\nvoid goo() \n{\n    std::cout &lt;&lt; \"some goo\" &lt;&lt; std::endl;\n}\n\n\ntemplate &lt;&gt;\nvoid foo&lt;int&gt;()\n{\n        std::cout &lt;&lt; \"specialization\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n        A a;\n        foo&lt;int&gt;(); //  VS 2012 gives error C3767: 'foo': candidate function(s) \n                    // not accessible\n                    //  'foo'  [may be found via argument-dependent lookup]\n        goo();      // OK\n}\n</code></pre>\n<p>So why goo is visible and accessible but foo's specialization for int not? VisualStudio 2012 gives error \"'foo': candidate function(s) not accessible, 'foo'  [may be found via argument-dependent lookup]\". By the way GCC compiles code without errors. Is there any restrictions in standard or this is just compilers issues?</p>\n", "Tags": "<c++><templates><visual-c++><friend><argument-dependent-lookup>", "OwnerUserId": "1758528", "AnswerCount": "1"}, "27922878": {"ParentId": "27917680", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>I think Clang might be correct here. Consider two things:</p>\n<p>\u00a714.7.3/8 [temp.expl.spec], abridging the example somewhat:</p>\n<blockquote>\n<p id=\"so_27917680_27922878_0\">A template explicit specialization is in the scope of the namespace \n  in which the template was defined. <em>[Example</em>:</p>\n<pre><code>namespace N {\n    template&lt;class T&gt; class X { /* ... */ };\n    template&lt;&gt; class X&lt;int&gt; { /* ... */ }; // OK: specialization \n                                           // in same namespace\n}\ntemplate &lt;&gt; class N::X&lt;double&gt; { /* ... */ }; // OK: specialization\n                                              // in enclosing namespace\n</code></pre>\n<p id=\"so_27917680_27922878_1\"><em>\u2014end example</em> ]</p>\n</blockquote>\n<p>But, the friend function in question, <code>foo</code>, lives in, as per \u00a711.3/7 [class.friend] (emphasis mine):</p>\n<blockquote>\n<p id=\"so_27917680_27922878_2\">A friend function <strong>defined in a class is in the (lexical) scope</strong> of the\n  class in which it is defined.</p>\n</blockquote>\n<p>To provide a specialization of <code>foo</code>, it would have to be in <code>A</code>'s lexical scope - which I do not think is possible to do. Your <code>foo&lt;int&gt;</code> specialization was in the wrong scope. </p>\n<p>Note that this only applies if the function is defined in the class. The following compiles and runs for me on Clang just fine, because now <code>goo</code> is not in <code>M</code>'s scope:</p>\n<pre><code>#include &lt;iostream&gt;\nstruct M\n{\n    template &lt;typename T&gt;  \n    friend void goo();     // only declared, not defined\n};\n\ntemplate &lt;typename T&gt;\nvoid goo() { \n    std::cout &lt;&lt; \"full\" &lt;&lt; std::endl;\n}\n\ntemplate &lt;&gt;\nvoid goo&lt;int&gt;() {\n    std::cout &lt;&lt; \"explicit\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n    goo&lt;int&gt;(); // prints explicit\n}\n</code></pre>\n<p>The visibility rules are established in \u00a77.3.1.2/3 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_27917680_27922878_3\">The <code>friend</code> declaration <strong>does not</strong> by itself make the name visible to\n  unqualified lookup (3.4.1) or qualified lookup (3.4.3). [ <em>Note:</em> The name of the friend will be visible in its namespace <strong>if</strong> a matching declaration is provided at namespace scope (either before or after the class definition granting friendship). <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>Thus, in this simpler example:</p>\n<pre><code>struct M {\n    template &lt;typename T&gt; friend void foo(T ) { }\n};\n</code></pre>\n<p><code>foo</code> is defined in <code>M</code>, so it lives in its <code>M</code>'s lexical scope. There is no \"matching declaration\" of <code>foo</code> outside of <code>M</code> so it should only be visible with ADL (\u00a73.4.2/4, emphasis mine):</p>\n<blockquote>\n<p id=\"so_27917680_27922878_4\">When considering an associated namespace, the lookup is the same as the lookup performed when the\n  associated namespace is used as a qualifier (3.4.3.2) except that</p>\n<p id=\"so_27917680_27922878_5\">(4.1) - Any <em>using-directives</em> in the associated namespace are ignored.</p>\n<p id=\"so_27917680_27922878_6\">(4.2) - Any namespace-scope friend functions or friend function templates declared in associated classes <strong>are visible</strong> within their respective namespaces <strong>even if</strong> they are not visible during an ordinary lookup (11.3).</p>\n</blockquote>\n<pre><code>int main() {\n    foo(M{}); // compiles correctly on both GCC and Clang\n    foo(0);   // should fail. Clang complains about \"use of undeclared identifier 'foo'\"\n              // but GCC 4.9.2 allows it! (update: fixed in 5+)\n}\n</code></pre>\n<p>So I restate my first sentence: I think Clang may be correct here. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2017-01-31T23:39:49.510", "Id": "27922878", "Score": "3", "CreationDate": "2015-01-13T13:04:14.420", "LastActivityDate": "2017-01-31T23:39:49.510"}, "bq_ids": {"n4140": {"so_27917680_27922878_0": {"section_id": 270, "quality": 0.8888888888888888, "length": 8}, "so_27917680_27922878_3": {"section_id": 5485, "quality": 0.8055555555555556, "length": 29}, "so_27917680_27922878_6": {"section_id": 7106, "quality": 0.9090909090909091, "length": 20}, "so_27917680_27922878_2": {"section_id": 6690, "quality": 1.0, "length": 8}, "so_27917680_27922878_4": {"section_id": 7106, "quality": 0.9285714285714286, "length": 13}, "so_27917680_27922878_5": {"section_id": 7106, "quality": 0.8, "length": 4}}, "n3337": {"so_27917680_27922878_6": {"section_id": 6850, "quality": 0.9090909090909091, "length": 20}, "so_27917680_27922878_0": {"section_id": 261, "quality": 0.8888888888888888, "length": 8}, "so_27917680_27922878_2": {"section_id": 6445, "quality": 1.0, "length": 8}, "so_27917680_27922878_4": {"section_id": 6850, "quality": 0.9285714285714286, "length": 13}, "so_27917680_27922878_5": {"section_id": 6850, "quality": 0.8, "length": 4}}, "n4659": {"so_27917680_27922878_0": {"section_id": 277, "quality": 0.8888888888888888, "length": 8}, "so_27917680_27922878_3": {"section_id": 6920, "quality": 0.8055555555555556, "length": 29}, "so_27917680_27922878_6": {"section_id": 8607, "quality": 0.9090909090909091, "length": 20}, "so_27917680_27922878_2": {"section_id": 8165, "quality": 1.0, "length": 8}, "so_27917680_27922878_4": {"section_id": 8607, "quality": 0.9285714285714286, "length": 13}, "so_27917680_27922878_5": {"section_id": 8607, "quality": 0.8, "length": 4}}}});