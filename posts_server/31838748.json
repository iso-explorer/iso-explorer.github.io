post_cb({"31839069": {"ParentId": "31838748", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_31838748_31839069_0\">I think the rationale part could be applied to the copy constructor and copy assignment operator pair also, couldn't it ? </p>\n</blockquote>\n<p>Absolutely. The standard agrees with you. In [class.copy]:</p>\n<blockquote>\n<p id=\"so_31838748_31839069_1\">If the class definition does not explicitly declare <strong>a copy constructor</strong>, a non-explicit one is declared implicitly.\n  If the class definition declares a move constructor or move assignment operator, the implicitly declared copy\n  constructor is defined as deleted; otherwise, it is defined as defaulted (8.4). <strong>The latter case is deprecated if\n  the class has a user-declared copy assignment operator or a user-declared destructor.</strong></p>\n</blockquote>\n<p>And:</p>\n<blockquote>\n<p id=\"so_31838748_31839069_2\">If the class definition does not explicitly declare <strong>a copy assignment operator</strong>, one is declared implicitly. If\n  the class definition declares a move constructor or move assignment operator, the implicitly declared copy\n  assignment operator is defined as deleted; otherwise, it is defined as defaulted (8.4). <strong>The latter case is\n  deprecated if the class has a user-declared copy constructor or a user-declared destructor.</strong></p>\n</blockquote>\n<p>Of course there's probably a lot of existing code that would break if the \"latter cases\" in question were done away with immediately, which is why the Standard moved first to deprecation and will only remove them at some arbitrarily distant point in the future. </p>\n<p>Then again, even long-deprecated-and-since-removed features have a way of hanging around long past their welcome. Like <a href=\"https://stackoverflow.com/q/31816473/2069064\"><code>char * s = \"MyString\";</code></a></p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:06:53.453", "Id": "31839069", "Score": "3", "CreationDate": "2015-08-05T17:27:25.260", "LastActivityDate": "2015-08-05T17:27:25.260"}, "31838748": {"CommentCount": "3", "ViewCount": "167", "CreationDate": "2015-08-05T17:08:45.780", "LastActivityDate": "2015-08-05T17:27:25.260", "Title": "Generated copy and move operators?", "AcceptedAnswerId": "31839069", "PostTypeId": "1", "Id": "31838748", "Score": "2", "Body": "<p>Currently I read the book <b>Effective Modern C++</b> from <b>Scott Meyers</b>, and now I'm at: <i>Item 17: Understand special member function generation.</i></p>\n<p>My misunderstanding comes from the following part (rationale):</p>\n<p><i>The two copy operations are independent: declaring one doesn\u2019t prevent compilers from generating the other. So if you declare a copy constructor, but no copy assignment operator, then write code that requires copy assignment, compilers will generate the copy assignment operator for you. Similarly, if you declare a copy assignment operator, but no copy constructor, yet your code requires copy construction, compilers will generate the copy constructor for you. That was true in C++98, and it\u2019s still true in C++11.</i></p>\n<p>The two move operations are not independent. If you declare either, that prevents compilers from generating the other. The <b>rationale</b> is that if you declare, say, a move constructor for your class, you\u2019re indicating that there\u2019s something about how move construction should be implemented that\u2019s different from the default memberwise move that compilers would generate. And if there\u2019s something wrong with memberwise move construction, there\u2019d probably be something wrong with memberwise move assignment, too. So declaring a move constructor prevents a move assignment operator from being generated, and declaring a move assignment operator prevents compilers from generating a move constructor.</p>\n<p>I think the rationale part could be applied to the <i>copy constructor</i> and <i>copy assignment operator</i> pair also, couldn't it ? So if I declare a copy constructor I indicate with it that the default memberwise copy is not adequate for me. And if I say this than probably the copy assignment operator should be user defined also.</p>\n<p>I think it's a great book, but at this point this rationale is not clear for me. Please help and explain this for me. Thanks.</p>\n", "Tags": "<c++><copy-constructor><move-semantics><copy-assignment>", "OwnerUserId": "4789375", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31838748_31839069_1": {"section_id": 456, "quality": 0.9230769230769231, "length": 36}, "so_31838748_31839069_2": {"section_id": 467, "quality": 0.9487179487179487, "length": 37}}, "n3337": {"so_31838748_31839069_1": {"section_id": 447, "quality": 0.9230769230769231, "length": 36}, "so_31838748_31839069_2": {"section_id": 458, "quality": 0.9487179487179487, "length": 37}}, "n4659": {"so_31838748_31839069_1": {"section_id": 479, "quality": 0.9487179487179487, "length": 37}, "so_31838748_31839069_2": {"section_id": 490, "quality": 0.9487179487179487, "length": 37}}}});