post_cb({"bq_ids": {"n4140": {"so_31623423_31667355_0": {"length": 26, "quality": 0.6842105263157895, "section_id": 743}}, "n3337": {"so_31623423_31667355_0": {"length": 26, "quality": 0.6842105263157895, "section_id": 732}}, "n4659": {"so_31623423_31667355_0": {"length": 26, "quality": 0.6842105263157895, "section_id": 801}}}, "31667355": {"Id": "31667355", "PostTypeId": "2", "Body": "<p>This is in support of <a href=\"https://stackoverflow.com/users/153285/potatoswatter\">Potatoswatter</a>'s answer.  I answer as the author of this libc++ code.</p>\n<p>Consider:</p>\n<pre><code>int\nmain()\n{\n    std::map&lt;A, int&gt; m1;\n    m1[A{1}] = 1;\n    m1[A{2}] = 2;\n    m1[A{3}] = 3;\n    std::map&lt;A, int&gt; m2;\n    m2[A{4}] = 4;\n    m2[A{5}] = 5;\n    m2[A{6}] = 6;\n    std::cout &lt;&lt; \"start copy assignment\\n\";\n    m2 = m1;\n    std::cout &lt;&lt; \"end copy assignment\\n\";\n}\n</code></pre>\n<p>In this particular circumstance I foresaw the need to both recycle nodes of the map, and reassign the \"const\" keys to make the recycling of nodes efficient.  Therefore</p>\n<p><a href=\"http://cplusplus.github.io/LWG/lwg-defects.html#704\" rel=\"nofollow noreferrer\">http://cplusplus.github.io/LWG/lwg-defects.html#704</a></p>\n<p>inserted the following wording to allow for recycling of <code>map</code> nodes:</p>\n<blockquote>\n<p id=\"so_31623423_31667355_0\">The associative containers meet all of the requirements of\n  Allocator-aware containers (23.2.1 [container.requirements.general]),\n  except for the containers map and multimap, the requirements placed on\n  value_type in Table 93 apply instead directly to key_type and\n  mapped_type. [Note: For example key_type and mapped_type are sometimes\n  required to be CopyAssignable even though the value_type (pair) is not CopyAssignable. \u2014 end note]</p>\n</blockquote>\n<p>Thus allowing the containers non-const access to the map's key_type.  To date, only libc++ takes advantage of this.  If you instrument <code>A</code> in the above example you will get for libc++:</p>\n<pre><code>start copy assignment\noperator=(const A&amp; a)\noperator=(const A&amp; a)\noperator=(const A&amp; a)\nend copy assignment\n</code></pre>\n<p>For libstdc++ (gcc-5.2.0)</p>\n<pre><code>start copy assignment\n~A()\nA(A const&amp; a)\n~A()\nA(A const&amp; a)\n~A()\nA(A const&amp; a)\nend copy assignment\n</code></pre>\n<p>For VS-2015:</p>\n<pre><code>start copy assignment\n~A()\n~A()\n~A()\nA(A const&amp; a)\nA(A const&amp; a)\nA(A const&amp; a)\nend copy assignment\n</code></pre>\n<p>I assert that when <code>A</code> is a type such as <code>int</code>, <code>std::vector</code> or <code>std::string</code>, or a type containing one of these common std types, there is a tremendous performance advantage of assignment over destruction followed by construction.  Assignment can take advantage of existing capacity in the lhs, often resulting in a simple <code>memcpy</code> as opposed to a deallocation of memory followed by an allocation of memory.</p>\n<p>Note that above <code>~A()</code> likely implies deallocation of the entire node, not just <code>A</code> (though not necessarily).  In any event, the libc++ <code>map</code> copy assignment operator is highly optimized to recycle memory, and permission for that optimization is backed by the C++11 and beyond standards.  The union trick is one (not necessarily portable) way of achieving that optimization.</p>\n<p>A similar optimization is obtained by this same code for the move assignment operator when the allocator does not propagate on move assignment and the two allocators compare unequal:</p>\n<p>clang/libc++:</p>\n<pre><code>start move assignment\noperator=(A&amp;&amp; a)\noperator=(A&amp;&amp; a)\noperator=(A&amp;&amp; a)\nend move assignment\n</code></pre>\n<p>gcc-5.2.0</p>\n<pre><code>start move assignment\n~A()\nA(A const&amp; a)\n~A()\nA(A const&amp; a)\n~A()\nA(A const&amp; a)\n~A()\n~A()\n~A()\nend move assignment\n</code></pre>\n<p>VS-2015</p>\n<pre><code>start move assignment\n~A()\n~A()\n~A()\nA(A const&amp; a)\nA(A const&amp; a)\nA(A const&amp; a)\nend move assignment\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-28T04:25:32.053", "Score": "9", "CreationDate": "2015-07-28T04:25:32.053", "ParentId": "31623423", "CommentCount": "2", "OwnerUserId": "576911", "LastEditDate": "2017-05-23T12:33:40.370"}, "31623586": {"Id": "31623586", "PostTypeId": "2", "Body": "<p>When you use a custom allocator, it may be necessary to move the map (and its contents) into a new resource pool. In that case, this overload will provide movable access to the keys:</p>\n<pre><code>__value_type(__value_type&amp;&amp; __v)\n    : __nc(std::move(__v.__nc)) {}\n</code></pre>\n<p>It doesn't matter that keys have been moved-from, since the next thing that happens is freeing all the nodes.</p>\n<p>Note, this usage may incur undefined behavior. You can't generally write one member of a union and then read another. Clang and libc++ can do this as long as they can internally guarantee it won't cause a problem (or error diagnosis).</p>\n<p>They probably did it this way, though, because there is no good conforming alternative. At least, I can't think of one. The standard requires that <code>value_type::first_type</code> is genuinely <code>const</code> qualified, so even a <code>const_cast</code> is not allowed.</p>\n<p>The trick is conforming in the case that <code>key_type</code> and <code>mapped_type</code> are both standard layout, so that <code>std::pair&lt;key_type, mapped_type&gt;</code> and <code>std::pair&lt;key_type const, mapped_type&gt;</code> are layout-compatible, per [class.mem] \u00a79.2/16. It looks a bit odd here because the function is referring to the immediate members <code>__cc</code> and <code>__nc</code> of the union, leaving it to the constructor to access the common subsequence comprising <code>first</code> and <code>second</code>. The <a href=\"http://en.cppreference.com/w/cpp/concept/StandardLayoutType\" rel=\"noreferrer\">requirements</a> for standard-layout types are somewhat restrictive, but many common key and value types (for example, <code>std::string</code>) can potentially meet them.</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2015-07-25T09:46:03.400", "Score": "8", "CreationDate": "2015-07-25T06:13:34.903", "ParentId": "31623423", "CommentCount": "8", "OwnerUserId": "153285", "LastEditDate": "2015-07-25T09:46:03.400"}, "31623423": {"ViewCount": "273", "Body": "<pre><code>#if __cplusplus &gt;= 201103L\n\ntemplate &lt;class _Key, class _Tp&gt;\nunion __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair&lt;const key_type, mapped_type&gt;        value_type;\n    typedef pair&lt;key_type, mapped_type&gt;              __nc_value_type;\n\n    value_type __cc;\n    __nc_value_type __nc;\n\n    template &lt;class ..._Args&gt;\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(_Args&amp;&amp; ...__args)\n        : __cc(std::forward&lt;_Args&gt;(__args)...) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(const __value_type&amp; __v)\n        : __cc(__v.__cc) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(__value_type&amp; __v)\n        : __cc(__v.__cc) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(__value_type&amp;&amp; __v)\n        : __nc(std::move(__v.__nc)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type&amp; operator=(const __value_type&amp; __v)\n        {__nc = __v.__cc; return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type&amp; operator=(__value_type&amp;&amp; __v)\n        {__nc = std::move(__v.__nc); return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__value_type() {__cc.~value_type();}\n};\n\n#else\n// definition for C++03...\n</code></pre>\n<p>It looks like the purpose is to make <code>__value_type</code> assignable and movable while also being able to expose the content as <code>pair&lt;const key_type, mapped_type&gt;</code> (which is the value type of iterators and so on). But I don't see why it needs to be assignable or movable, since I can't see any reason why the implementation would ever need to copy or move nodes inside a map, or indeed to do anything other than construct and destroy them in-place, and reconfigure pointers.</p>\n", "AcceptedAnswerId": "31623586", "Title": "Why does libc++'s implementation of map use this union?", "CreationDate": "2015-07-25T05:51:00.343", "Id": "31623423", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2015-07-28T04:25:32.053", "Score": "5", "OwnerUserId": "481267", "Tags": "<c++><c++11><dictionary><stl><libc++>", "AnswerCount": "2"}});