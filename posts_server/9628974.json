post_cb({"bq_ids": {"n4140": {"so_9628974_9629009_0": {"length": 8, "quality": 1.0, "section_id": 350}}, "n3337": {"so_9628974_9629009_0": {"length": 8, "quality": 1.0, "section_id": 340}}, "n4659": {"so_9628974_9629009_0": {"length": 8, "quality": 1.0, "section_id": 360}}}, "9629009": {"Id": "9629009", "PostTypeId": "2", "Body": "<p>In C++03, the specification explicitly prohibits the default argument from being used to deduce a template argument (C++03 \u00a714.8.2/17):</p>\n<blockquote>\n<p id=\"so_9628974_9629009_0\">A template <em>type-parameter</em> cannot be deduced from the type of a function default argument. </p>\n</blockquote>\n<p>In C++11, you can provide a default template argument for the function template:</p>\n<pre><code>template &lt;typename T = float&gt;\nvoid bar(int a, T b = 0.0f) { }\n</code></pre>\n<p>The default template argument is required, though.  If the default template argument is not provided, the default function argument is still not usable for template argument deduction.  Specifically, the following applies (C++11 14.8.2.5/5):</p>\n<blockquote>\n<p id=\"so_9628974_9629009_1\">The non-deduced contexts are:</p>\n<p id=\"so_9628974_9629009_2\">...</p>\n<ul>\n<li>A template parameter used in the parameter type of a function parameter that has a default argument that is being used in the call for which argument deduction is being done.</li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2012-03-09T04:36:47.127", "CommentCount": "4", "CreationDate": "2012-03-09T04:36:47.127", "ParentId": "9628974", "Score": "15", "OwnerUserId": "151292"}, "9629112": {"Id": "9629112", "PostTypeId": "2", "Body": "<p>A good reason might be that</p>\n<pre><code>void foo(bar, xyzzy = 0);\n</code></pre>\n<p>is similar to a pair of overloads. </p>\n<pre><code>void foo(bar b) { foo(b, 0);  }\nfoo(bar, xyzzy);\n</code></pre>\n<p>Moreover, sometimes it is advantageous to refactor it into such:</p>\n<pre><code>void foo(bar b) { /* something other than foo(b, 0); */ }\nfoo(bar, xyzzy);\n</code></pre>\n<p>Even when written as one, it's still like two functions in one, neither of which is \"preferred\" in any sense. You're calling the one-argument function; the two-argument one is effectively a different function. The default argument notation just merges them into one.</p>\n<p>If overloading were to have the behavior that you are asking for, then for consistency it would have to work in the case when the template is split up into two definitions. That wouldn't make sense because then the deduction would be pulling types from an unrelated function that is not being called!  And if it was not implemented, it would mean that overloading different parameter list lengths becomes a \"second class citizen\" compared to \"default-argumenting\".</p>\n<p>It is good if the difference between overloads and defaulting is completely hidden to the client.</p>\n", "LastActivityDate": "2012-03-09T04:55:02.273", "CommentCount": "0", "CreationDate": "2012-03-09T04:55:02.273", "ParentId": "9628974", "Score": "4", "OwnerUserId": "1250772"}, "9628974": {"ViewCount": "1631", "Body": "<p>I was surprised the following code resulted in a <code>could not deduce template argument for T</code> error:</p>\n<pre><code>struct foo\n{\n  template &lt;typename T&gt;\n  void bar(int a, T b = 0.0f)\n  {\n  }\n};\n\nint main()\n{\n  foo a;\n  a.bar(5);\n\n  return 0;\n}\n</code></pre>\n<p>Calling <code>a.bar&lt;float&gt;(5)</code> fixes the issue. Why can't the compiler deduce the type from the default argument?</p>\n", "AcceptedAnswerId": "9629009", "Title": "Why can't the compiler deduce the template type from default arguments?", "CreationDate": "2012-03-09T04:32:28.880", "Id": "9628974", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-11-27T01:55:09.830", "LastEditorUserId": "1505939", "LastActivityDate": "2015-09-04T17:27:21.317", "Score": "12", "OwnerUserId": "368599", "Tags": "<c++><templates><default-arguments>", "AnswerCount": "3"}, "32403570": {"Id": "32403570", "PostTypeId": "2", "Body": "<p>There would be some technical difficulties in achieving that in general.  Remember that default arguments in templates are not instantiated until they are needed.  Consider then:</p>\n<pre><code>template&lt;typename T, typename U&gt; void f(U p = T::g());  // (A)\ntemplate&lt;typename T&gt; T f(long, int = T());  // (B)\nint r = f&lt;int&gt;(1);\n</code></pre>\n<p>This is resolved today by performing (among other things) the following steps:</p>\n<ol>\n<li>attempt to deduce template parameters for candidates (A) and (B);\n  this fails for (A), which is therefore eliminated.</li>\n<li>perform overload resolution; (B) is selected</li>\n<li>form the call, instantiating the default argument</li>\n</ol>\n<p>In order to deduce from a default argument, that default argument would have to be itself instantiated before completing the deduction process.  That could fail, leading to errors outside the SFINAE context.  I.e., a candidate that may be entirely inappropriate for a call could trigger an error.</p>\n", "LastActivityDate": "2015-09-04T17:27:21.317", "CommentCount": "1", "CreationDate": "2015-09-04T17:27:21.317", "ParentId": "9628974", "Score": "7", "OwnerUserId": "2308239"}});