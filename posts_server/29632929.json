post_cb({"29632929": {"CommentCount": "2", "ViewCount": "73", "PostTypeId": "1", "LastEditorUserId": "2175990", "CreationDate": "2015-04-14T16:44:10.040", "LastActivityDate": "2015-04-14T17:43:15.003", "Title": "C++ Universal Unicodes", "AcceptedAnswerId": "29634022", "LastEditDate": "2015-04-14T17:34:20.490", "Id": "29632929", "Score": "0", "Body": "<p>I had a quick question and couldn't find an answer anywhere else. Basically I was trying to make a universal function to return the proper unicode (instead of making literals) as shown below in the std::string getUnicode() function. The \\xe2\\x99\\xa and cardType are being treated as two separate strings in the output, which causes a \"?\" followed by the cardType number.</p>\n<p>In this case:</p>\n<pre><code>cout &lt;&lt; \"\\xe2\\x99\\xa0\"; //prints out a symbol, GOOD\ncout &lt;&lt; \"\\xe2\\x99\\xa\" &lt;&lt; 0; //prints out \"?\" followed by 0. BAD\ncout &lt;&lt; card.getUnicode(); //prints out \"?\" followed by 0. BAD\n</code></pre>\n<p>Any ideas? 4-6 month beginner to C++.</p>\n<pre><code>#ifndef CARD_H\n#define CARD_H\n\n#include &lt;map&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n\nenum CARD_TYPE {SPADE = 0, CLUB = 3, HEART = 5, DIAMOND = 6};\n\nclass Card {\n\n    private:\n        int number;\n        CARD_TYPE cardType;\n\n    public:\n        Card(CARD_TYPE, int);\n        void displayCard();\n\n        int getNumber() {\n            return number;\n        }\n\n        CARD_TYPE getCardType() {\n            return cardType;\n        }\n\n        /* Returns Unicode Value for this Card Type */\n        std::string getUnicode() {\n            std::stringstream ss;\n            ss &lt;&lt; \"\\xe2\\x99\\xa\" &lt;&lt; cardType;\n            return ss.str();\n        }\n\n};\n\n#endif\n</code></pre>\n", "Tags": "<c++><unicode>", "OwnerUserId": "2175990", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_29632929_29634022_1": {"section_id": 5362, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_29632929_29634022_1": {"section_id": 5158, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_29632929_29634022_1": {"section_id": 6786, "quality": 0.8181818181818182, "length": 9}}}, "29634022": {"ParentId": "29632929", "CommentCount": "1", "Body": "<p>This is talked about in the C++ standard, section 2.14.5, paragraph 13:</p>\n<blockquote>\n<p id=\"so_29632929_29634022_0\">[Example:</p>\n<pre><code>\"\\xA\" \"B\"\n</code></pre>\n<p id=\"so_29632929_29634022_1\">contains the two characters <code>'\\xA'</code> and <code>'B'</code> after concatenation (and not the single hexadecimal character <code>'\\xAB'</code>). \u2014 end example ]</p>\n</blockquote>\n<p>The problem is that <code>'\\xa'</code> is being treated as a single character (hex value <code>0xa</code> is 10 in decimal, which maps to the <code>\\n</code> (line feed) character in <a href=\"http://www.ascii-code.com/\" rel=\"nofollow\">ASCII</a>/UTF). The <code>cardType</code> does not get \"appended\" to the escape sequence. In fact, the escape sequence is evaluated at compile time, not runtime (which is when the card type gets evaluated).</p>\n<p>In order for this to work, you need to do something like:</p>\n<pre><code> ss &lt;&lt; \"\\xe2\\x99\" &lt;&lt; static_cast&lt;char&gt;(0xa0 + cardType);\n</code></pre>\n", "OwnerUserId": "1287251", "PostTypeId": "2", "Id": "29634022", "Score": "3", "CreationDate": "2015-04-14T17:43:15.003", "LastActivityDate": "2015-04-14T17:43:15.003"}});