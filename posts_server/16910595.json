post_cb({"16910688": {"ParentId": "16910595", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>In both function calls, what you pass to the function is an <code>int &amp;</code> (in the sense of: \"an lvalue of type <code>int</code>\"). So, presented with the declaration of <code>inc1</code>, the compiler must deduce <code>T</code> such that <code>T &amp;&amp;</code> matches the argument you provided, i.e. <code>int &amp;</code>. The only way to do this is to assume that <code>T</code> is <code>int &amp;</code>, because then <code>T &amp;&amp;</code> is <code>int &amp; &amp;&amp;</code>, which is equivalent to <code>int &amp;</code>. So <code>T</code> becomes <code>int &amp;</code> and the local <code>y</code> is declared as such.</p>\n<p>On the other hand, in <code>inc2</code>, the compiler must deduce <code>T</code> such that <code>T &amp;</code> matches the argument type you provided, which is still <code>int &amp;</code>. That's easiest done by assuming <code>T</code> is simply <code>int</code>, so that's what you get for the type of the local <code>y</code> then.</p>\n<hr>\n<p>Reply to a few comments (that have meanwhile been deleted): If you have a function with a predefined argument type, such as</p>\n<pre><code>inc3(int x) { /*...*/ }\n</code></pre>\n<p>then, when you call this e.g. as <code>inc3(a)</code>, the compiler will apply whatever implicit conversion necessary <em>to the argument</em> to make it fit. In the case of <code>inc3(a)</code> this means to transform <code>a</code> from <code>int &amp;</code> (in the sense of lvalue) to <code>int</code> (in the sense of rvalue) \u2013 which is called lvalue-to-rvalue conversion and a valid implicit conversion. It basically amounts to transforming the variable <code>a</code> into the value it represents at that time.</p>\n<p>But when you declare a <em>template</em>, such as <code>inc1</code> and <code>inc2</code> from the question, and the function argument is defined in terms of a template parameter, then the compiler will not, or not only, try to apply implicit conversions to the argument to make it fit. Instead, it will <em>choose the argument type parameter <code>T</code></em> so it matches the argument type you provided. The rules for this are complicated, but in the case of a <code>T &amp;&amp;</code> type argument declaration, they work as described above. (In the case of a pure <code>T</code> argument declaration, an lvalue argument will still undergo lvalue-to-rvalue conversion, and <code>T</code> will be deduced as <code>int</code>, not <code>int &amp;</code>.)</p>\n<p>This is why, while <code>int &amp;&amp;</code> is an rvalue reference, <code>T &amp;&amp;</code> (where <code>T</code> is a template parameter) is not necessarily an rvalue reference. Instead, it is whatever results from fitting <code>T</code> to the argument provided. The expression <code>T &amp;&amp;</code> in this case has therefore been called <em>universal reference</em> (as oppossed to lvalue or rvalue reference) \u2013 it is a reference that becomes either an lvalue or rvalue one, as necessary.</p>\n</hr>", "OwnerUserId": "777186", "LastEditorUserId": "777186", "LastEditDate": "2013-06-05T06:24:23.280", "Id": "16910688", "Score": "14", "CreationDate": "2013-06-04T05:52:16.260", "LastActivityDate": "2013-06-05T06:24:23.280"}, "16911547": {"ParentId": "16910595", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>S14.8.2.1 [temp.deduct.call] says:</p>\n<blockquote>\n<p id=\"so_16910595_16911547_0\">Template argument deduction is done by comparing each function template parameter type (call it P) with\n  the type of the corresponding argument of the call (call it A) as described below.</p>\n</blockquote>\n<p>So, we're trying to work out a P given A of type <code>int</code>.</p>\n<p>S14.8.2.3 continues:</p>\n<blockquote>\n<p id=\"so_16910595_16911547_1\">If P is a cv-qualified type, the top level cv-qualifiers of P\u2019s type are ignored for type deduction. If P is a\n  reference type, the type referred to by P is used for type deduction. If P is an rvalue reference to a cv-unqualified template parameter and the argument is an lvalue, the type \u201clvalue reference to A\u201d is used in place of A for type deduction. [ Example: <br/></p>\n</blockquote>\n<pre><code>template &lt;class T&gt; int f(T&amp;&amp;);         // &lt;--- YOUR TEMPLATE IS LIKE THIS\ntemplate &lt;class T&gt; int g(const T&amp;&amp;);\nint i;\nint n1 = f(i); // calls f&lt;int&amp;&gt;(int&amp;)  // &lt;--- YOUR CALL IS LIKE THIS\nint n2 = f(0); // calls f&lt;int&gt;(int&amp;&amp;)\nint n3 = g(i); // error: would call g&lt;int&gt;(const int&amp;&amp;), which\n               // would bind an rvalue reference to an lvalue\n</code></pre>\n<blockquote>\n<p id=\"so_16910595_16911547_2\">\u2014end example ]</p>\n</blockquote>\n<p>Your call is just like <code>f(i)</code> in the example - which instantiates a function of the form <code>f&lt;int&amp;&gt;(int&amp;)</code>... i.e. <code>T</code> is <code>int&amp;</code>, which is why <code>T y = x</code> creates a reference to <code>x</code>.</p>\n<p>See also Scott Meyers's page at <a href=\"http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers\">http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers</a></p>\n", "OwnerUserId": "410767", "LastEditorUserId": "410767", "LastEditDate": "2013-06-04T07:17:42.557", "Id": "16911547", "Score": "7", "CreationDate": "2013-06-04T06:55:19.377", "LastActivityDate": "2013-06-04T07:17:42.557"}, "bq_ids": {"n4140": {"so_16910595_16911547_1": {"section_id": 304, "quality": 0.9655172413793104, "length": 28}, "so_16910595_16911547_0": {"section_id": 302, "quality": 1.0, "length": 18}}, "n3337": {"so_16910595_16911547_1": {"section_id": 295, "quality": 0.9655172413793104, "length": 28}, "so_16910595_16911547_0": {"section_id": 293, "quality": 1.0, "length": 18}}, "n4659": {"so_16910595_16911547_1": {"section_id": 311, "quality": 0.896551724137931, "length": 26}, "so_16910595_16911547_0": {"section_id": 309, "quality": 1.0, "length": 18}}}, "16910595": {"CommentCount": "0", "AcceptedAnswerId": "16910688", "PostTypeId": "1", "LastEditorUserId": "261217", "CreationDate": "2013-06-04T05:44:59.423", "LastActivityDate": "2013-06-05T06:24:23.280", "LastEditDate": "2013-06-04T10:05:01.257", "ViewCount": "497", "FavoriteCount": "3", "Title": "Reference interpretation in c++", "Id": "16910595", "Score": "16", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nvoid inc1(T&amp;&amp; x)\n{\n    T y = x;\n    ++y;\n}\n\ntemplate&lt;typename T&gt;\nvoid inc2(T&amp; x)\n{\n    T y = x;\n    ++y;\n}\n\nint main()\n{\n    int a = 10;\n    inc1(a); // a is now 11\n\n    int b = 10;\n    inc2(b); // b remains 10\n}\n</code></pre>\n<p>After substitution we have</p>\n<pre><code>void inc1(int&amp; x)\n{\n    int&amp; y = x; // reference to x\n    ++y; // increments x\n}\n\nvoid inc2(int&amp; x)\n{\n    int y = x; // copy of x\n    ++y; // increments the copie\n}\n</code></pre>\n<p>In <code>inc1</code>, <code>x</code> is of type <code>int&amp;</code> because both <code>int&amp;</code> and <code>T&amp;&amp;</code> are references but not both are r-values.</p>\n<p>Similarly, in <code>inc2</code>, <code>x</code> is of type <code>int&amp;</code>, because again both <code>int&amp;</code> and <code>T&amp;</code> are references, but not both are r-values.</p>\n<p>My question is about <code>y</code>: why in <code>inc1</code>, <code>y</code> is of type <code>int&amp;</code>, while in <code>inc2</code>, <code>y</code> is of type <code>int</code>?</p>\n<p>I observed this on both gcc 4.8.1 and microsoft v110 and v120_ctp.</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1003615", "AnswerCount": "2"}});