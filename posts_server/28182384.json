post_cb({"bq_ids": {"n4140": {"so_28182384_28182504_1": {"length": 29, "quality": 0.90625, "section_id": 31}, "so_28182384_28182504_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 32}}, "n3337": {"so_28182384_28182504_1": {"length": 29, "quality": 0.90625, "section_id": 28}, "so_28182384_28182504_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 29}}, "n4659": {"so_28182384_28182504_1": {"length": 29, "quality": 0.90625, "section_id": 31}, "so_28182384_28182504_0": {"length": 11, "quality": 0.7857142857142857, "section_id": 32}}}, "28182384": {"ViewCount": "79", "Body": "<p>What type conversion happen if I have the following:</p>\n<pre><code>short s = 1234;\nchar c = s;\n</code></pre>\n<p>Will <code>s</code> first gets converted to an <code>int</code>, and this <code>int</code> gets converted to a <code>char</code> and assigned to <code>c</code>? Or will <code>s</code> just gets converted directly to a <code>char</code> and assigned to <code>c</code>?</p>\n", "AcceptedAnswerId": "28182504", "Title": "What type conversion happen when I assign a short to a char?", "CreationDate": "2015-01-28T00:06:04.543", "Id": "28182384", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2015-01-28T00:25:13.887", "Score": "0", "OwnerUserId": "4396948", "Tags": "<c++><types><casting>", "AnswerCount": "1"}, "28182504": {"Id": "28182504", "PostTypeId": "2", "Body": "<p><code>s</code> does not get converted to <code>int</code>.</p>\n<p>Here<sup>1</sup> we are initializing <code>c</code> with a value that is out of range for <code>char</code>. Plain <code>char</code> can either be signed or unsigned (most compilers have a switch to toggle this). If <code>char</code> is signed then the relevent standard text is in [conv.integral]/3:</p>\n<blockquote>\n<p id=\"so_28182384_28182504_0\">If the destination type is signed, the value is unchanged if it can be represented in the destination type (and bit-field width); otherwise, the value is implementation-defined.</p>\n</blockquote>\n<p>\"implementation-defined\" means that your compiler must document what happens here. A common implementation on modern systems is that excess bits will be truncated, starting at the most significant end.</p>\n<p>It's a good idea to rewrite this code to not rely on implementation-defined behaviour; so that the behaviour doesn't change when you go to compile it on a different system.</p>\n<p>If <code>char</code> is unsigned then the previous paragraph covers the case:</p>\n<blockquote>\n<p id=\"so_28182384_28182504_1\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2<sup>n</sup> where n is the number of bits used to represent the unsigned type). [Note: In a two\u2019s complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation). \u2014end note ]</p>\n</blockquote>\n<p>so the resulting char value would be 1234 - 1024 = <code>210</code> . </p>\n<hr>\n<p><sup>1</sup> This post assumes you're on a system with 8-bit bytes. There are a few specialized chips around where that is not the case, and on those systems, <code>char</code> could hold a value of <code>1234</code> just fine with no value changes required.</p>\n</hr>", "LastEditorUserId": "1505939", "LastActivityDate": "2015-01-28T00:25:13.887", "Score": "1", "CreationDate": "2015-01-28T00:17:45.910", "ParentId": "28182384", "CommentCount": "0", "OwnerUserId": "1505939", "LastEditDate": "2015-01-28T00:25:13.887"}});