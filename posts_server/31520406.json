post_cb({"31520406": {"CommentCount": "10", "ViewCount": "110", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-07-20T15:25:16.220", "LastActivityDate": "2015-07-20T17:39:18.680", "Title": "Is a rvalue reference parameter that is returned by value an xvalue?", "AcceptedAnswerId": "31520617", "LastEditDate": "2017-05-23T12:21:45.513", "Id": "31520406", "Score": "2", "Body": "<p>My understanding is that, in the following function, the expression <code>foo</code> in the statement <code>return foo;</code> is an xvalue, because the object it denotes is expiring (even though <code>foo</code> is an lvalue in previous statements):</p>\n<pre><code>Foo bar()\n{\n    Foo foo;\n    change(foo);\n    return foo;\n}\n</code></pre>\n<p>Such an expiring value is not covered by <a href=\"https://stackoverflow.com/questions/11581903/what-expressions-create-xvalues\">What expressions create xvalues?</a>.</p>\n<p>Does that change in the following case?</p>\n<pre><code>Foo bar(Foo&amp;&amp; foo)\n{\n    change(foo);\n    return foo;\n}\n</code></pre>\n<p>Is <code>foo</code> an xvalue in the return statement? And in particular, is it a candidate for move? And for RVO? Or should one use <code>return std::move(foo)</code>?</p>\n<p>I do not know what the formal rule is for classifying the expression <code>foo</code> as an xvalue in the return statement of the first case, so I cannot test it in the second.</p>\n", "Tags": "<c++><move><rvalue-reference><rvo><xvalue>", "OwnerUserId": "563765", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_31520406_31520617_1": {"section_id": 480, "quality": 0.9333333333333333, "length": 14}, "so_31520406_31520617_0": {"section_id": 7230, "quality": 0.8, "length": 20}}, "n3337": {"so_31520406_31520617_1": {"section_id": 471, "quality": 0.9333333333333333, "length": 14}, "so_31520406_31520617_0": {"section_id": 6974, "quality": 0.8, "length": 20}}, "n4659": {"so_31520406_31520617_1": {"section_id": 502, "quality": 0.9333333333333333, "length": 14}}}, "31520617": {"ParentId": "31520406", "PostTypeId": "2", "CommentCount": "25", "Body": "<p>In that function, <code>foo</code> is an <em>lvalue</em> of type \"rvalue reference to <code>Foo</code>\". When you return it, since a copy has to be constructed (due to the type of the returned value), you are constructing a whole new value, which makes <code>bar(...)</code> an <em>prvalue</em>, as per \u00a73.10.1.5:</p>\n<blockquote>\n<p id=\"so_31520406_31520617_0\">A prvalue (\u201cpure\u201d rvalue) is an rvalue that is not an xvalue. [ Example: The result of calling a function whose return type is not a reference is a prvalue. The value of a literal such as 12, 7.3e5, or true is also a prvalue. \u2014 end example ]</p>\n</blockquote>\n<p>Due to the fact that, inside the function, <code>foo</code> is an <em>lvalue</em>, the expression <code>return foo</code> is not a candidate for a move construction and <a href=\"http://coliru.stacked-crooked.com/a/5901a7fd8f12766a\" rel=\"nofollow\">the copy constructor is selected</a>.</p>\n<p>And yes, RVO applies here, assuming a move is not selected first. There's nothing special in that regard here. As per \u00a712.8.31:</p>\n<blockquote>\n<p id=\"so_31520406_31520617_1\">This elision of copy/move operations, called copy elision, is permitted in the following circumstances (which may be combined to eliminate multiple copies):</p>\n<ul>\n<li>in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (other than a function or catch-clause parameter) with the same cv- unqualified type as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function\u2019s return value</li>\n</ul>\n<p id=\"so_31520406_31520617_2\">[...]</p>\n</blockquote>\n<hr>\n<p>To clarify, <code>foo</code> per se is an lvalue, but the statement:</p>\n<pre><code>return foo;\n</code></pre>\n<p>ultimately results (from the <code>bar(...)</code> expression) in a prvalue due to the fact that given that return type, the expression is equivalent to:</p>\n<pre><code>return Foo(foo);\n</code></pre>\n<p>which means that a temporary value, copied from <code>foo</code> is returned from the function\u00a0<code>bar</code>.</p>\n<hr>\n<blockquote>\n<p id=\"so_31520406_31520617_3\">Rereading the reply, it still does not make sense to me. You say Due to the fact that, inside the function, foo is an lvalue, the expression return foo is not a candidate for a move construction and the copy constructor is selected. Why is this true in one case and not the other?</p>\n</blockquote>\n<p>When returning <code>foo</code> you have to create a new <code>Foo</code> value (because you are returning a copy) from the <em>lvalue</em> reference <code>foo</code>. This is done implicitly by the copy constructor. So <code>return foo;</code> is equivalent to <code>return Foo(foo)</code>. Given that <code>foo</code> is an lvalue, the copy constructor is selected (and not the move constructor).</p>\n<p>Now, when you have this new temporary value (constructed from <code>foo</code>), the value itself, which comes out of the expression <code>bar(...)</code>, is a prvalue. So when you do:</p>\n<pre><code>auto res = bar(...);\n</code></pre>\n<p>You have to construct a <code>Foo</code> copy out of a prvalue. Since a prvalue is also an rvalue, the constructor with the rvalue reference parameter (move constructor) is selected.</p>\n</hr></hr>", "OwnerUserId": "493122", "LastEditorUserId": "493122", "LastEditDate": "2015-07-20T16:47:49.270", "Id": "31520617", "Score": "2", "CreationDate": "2015-07-20T15:34:48.447", "LastActivityDate": "2015-07-20T16:47:49.270"}});