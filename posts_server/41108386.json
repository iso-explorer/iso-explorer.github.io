post_cb({"bq_ids": {"n4140": {"so_41108386_41108386_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 1243}}, "n3337": {"so_41108386_41108386_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 1241}}, "n4659": {"so_41108386_41108386_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 1331}}}, "41108386": {"ViewCount": "205", "Body": "<p>So I asked a question here: <a href=\"https://stackoverflow.com/q/41103743/2642059\">Lambda Works on Latest Visual Studio, but Doesn't Work Elsewhere</a> to which I got the response, that my code was implementation defined since the standard's 25.1 [algorithms.general] 10 says:</p>\n<blockquote>\n<p id=\"so_41108386_41108386_0\">Unless otherwise specified, algorithms that take function objects as arguments are permitted to copy\n  those function objects freely. Programmers for whom object identity is important should consider using a\n  wrapper class that points to a noncopied implementation object such as <code>reference_wrapper&lt;T&gt;</code></p>\n</blockquote>\n<p>I'd just like a reason why this is happening? We're told our whole lives to take objects by reference, why then is the standard taking function objects by value, and even worse in my linked question making copies of those objects? Is there some advantage that I don't understand to doing it this way?</p>\n", "AcceptedAnswerId": "41109008", "Title": "Is There a Reason Standard Algorithms Take Lambdas by Value?", "CreationDate": "2016-12-12T19:46:49.510", "Id": "41108386", "CommentCount": "15", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:09:34.567", "LastEditorUserId": "-1", "LastActivityDate": "2016-12-12T20:41:37.837", "ClosedDate": "2016-12-12T20:36:51.267", "Score": "8", "OwnerUserId": "2642059", "Tags": "<c++><algorithm><lambda><pass-by-reference><pass-by-value>", "AnswerCount": "2"}, "41109003": {"Id": "41109003", "PostTypeId": "2", "Body": "<p>I'm not sure I have an answer for you, but if I have got my object lifetimes correct I think this is portable, safe and adds zero overhead or complexity:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n#include &lt;iterator&gt;\n\n\n// @pre f must be an r-value reference - i.e. a temporary\ntemplate&lt;class F&gt;\nauto resist_copies(F &amp;&amp;f) {\n    return std::reference_wrapper&lt;F&gt;(f);\n};\n\nvoid removeIntervals(std::vector&lt;double&gt; &amp;values, const std::vector&lt;std::pair&lt;int, int&gt;&gt; &amp;intervals) {\n    values.resize(distance(\n            begin(values),\n            std::remove_if(begin(values), end(values),\n                           resist_copies([i = 0U, it = cbegin(intervals), end = cend(intervals)](const auto&amp;) mutable \n    {\n        return it != end &amp;&amp; ++i &gt; it-&gt;first &amp;&amp; (i &lt;= it-&gt;second || (++it, true));\n    }))));\n}\n\n\nint main(int argc, char **args) {\n    // Intervals of indices I have to remove from values\n    std::vector&lt;std::pair&lt;int, int&gt;&gt; intervals = {{1,  3},\n                                                  {7,  9},\n                                                  {13, 13}};\n\n    // Vector of arbitrary values.\n    std::vector&lt;double&gt; values = {4.2, 6.4, 2.3, 3.4, 9.1, 2.3, 0.6, 1.2, 0.3, 0.4, 6.4, 3.6, 1.4, 2.5, 7.5};\n    removeIntervals(values, intervals);\n    // intervals should contain 4.2,9.1,2.3,0.6,6.4,3.6,1.4,7.5\n\n    std:\n    copy(values.begin(), values.end(), std::ostream_iterator&lt;double&gt;(std::cout, \", \"));\n    std::cout &lt;&lt; '\\n';\n}\n</code></pre>\n", "LastActivityDate": "2016-12-12T20:28:52.933", "CommentCount": "0", "CreationDate": "2016-12-12T20:28:52.933", "ParentId": "41108386", "Score": "0", "OwnerUserId": "2015579"}, "41109008": {"Id": "41109008", "PostTypeId": "2", "Body": "<p><code>std</code> assumes function objects and iterators are free to copy.</p>\n<p><code>std::ref</code> provides a method to turn a function object into a pseudo-reference with a compatible <code>operator()</code> that uses reference instead of value semantics.  So nothing of large value is lost.</p>\n<p>If you have been taught all your life to take objects by reference, reconsider.  Unless there is a good reason otherwise, take objects by value.  Reasoning about values is far easier; references are pointers into any state anywhere in your program.</p>\n<p>The conventional use of references, as a pointer to a local object which is not referred to by any other active reference in the context where it is used, is not something someone reading your code nor the compiler can presume.  If you reason about references this way, they don't add a ridiculous amount of complexity to your code.</p>\n<p>But if you reason about them that way, you are going to have bugs when your assumption is violated, and they will be subtle, gross, unexpected, and horrible.</p>\n<p>A classic example is the number of <code>operator=</code> that break when <code>this</code> and the argument refer to the same object.  But any function that takes two references or pointers of the same type has the same issue.</p>\n<p>But even one reference can break your code.  Let's look at <code>sort</code>.  In pseudo-code:</p>\n<pre><code>void sort( Iterator start, Iterator end, Ordering order )\n</code></pre>\n<p>Now, let's make Ordering a reference:</p>\n<pre><code>void sort( Iterator start, Iterator end, Ordering const&amp; order )\n</code></pre>\n<p>How about this one?</p>\n<pre><code>std::function&lt; void(int, int) &gt; alice;\nstd::function&lt; void(int, int) &gt; bob;\nalice = [&amp;]( int x, int y ) { std:swap(alice, bob); return x&lt;y; };\nbob = [&amp;]( int x, int y ) { std:swap(alice, bob); return x&gt;y; };\n</code></pre>\n<p>Now, call <code>sort( begin(vector), end(vector), alice )</code>.</p>\n<p>Every time <code>&lt;</code> is called, the referred-to <code>order</code> object swaps meaning.  Now this is pretty ridiculous, but when you took <code>Ordering</code> by <code>const&amp;</code>, the optimizer had to take into account that possibility and rule it out on every invokation of your ordering code!</p>\n<p>You wouldn't do the above (and in fact this particular implementation is UB as it would violate any reasonable requisites on <code>std::sort</code>); but the compiler has to prove you didn't do something \"like that\" (change the code in <code>ordering</code>) every time it follows <code>order</code> or invokes it!  Which means constantly reloading the state of <code>order</code>, or inlining and proving you did nonesuch insanity.</p>\n<p>Doing this when taking by-value is an order of magnitude harder (and basically requires something like <code>std::ref</code>).  The optimizer has a function object, it is local, and its state is local.  Anything stored within it is local, and the compiler and optimizer know who exactly can modify it legally.</p>\n<p>Every function you write taking a <code>const&amp;</code> that ever leaves its \"local scope\" (say, called a C library function) can not assume the state of the <code>const&amp;</code> remained the same after it got back.  It must reload the data from wherever the pointer points to.</p>\n<p>Now, I did say pass by value unless there is a good reason.  And there are many good reasons; your type is very expensive to move or copy, for example, is a great reason.  You are writing data to it.  You actually want it to change as you read it each time.  Etc.</p>\n<p>But the default behavior should be pass-by-value.  Only move to references if you have a good reason, because the costs are distributed and hard to pin down.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2016-12-12T20:41:37.837", "Score": "6", "CreationDate": "2016-12-12T20:29:04.387", "ParentId": "41108386", "CommentCount": "3", "OwnerUserId": "1774667", "LastEditDate": "2016-12-12T20:41:37.837"}});