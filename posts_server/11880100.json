post_cb({"11881677": {"PostTypeId": "2", "Body": "<p>C does not provide any way for you to control whether values are kept in registers between function calls.</p>\n<p>You are trying to optimize the wrong thing. The operations required to parse strings and perform emulation will involve many, many low-level processor operations, such as loading bytes, comparing bytes and looking them up in tables, branching based on results of comparisons, pushing routine arguments onto the stack, returning from routines, looking identifiers up in symbol tables, and so on. The simple load of a value from memory is a tiny part of this process.</p>\n<p>Even assuming you have separated the parsing and the emulation, so that parsing has produced code in a virtual machine language, the operations required to execute that code still involve many operations, such as loading the bytes for an instruction from memory, decoding those bytes, branching to code to execute the decoded instruction, and so on.</p>\n<p>The best you might hope for, when writing in C or C++ or any high-level language, is to write all of the emulation code in one compilation unit (one source file plus the headers it includes), possibly even inside one routine, so that the compiler\u2019s optimizer can see all of it and optimize all of it. In that case, if you have a main loop that is reading, decoding, and executing instructions, the compiler might see that values in temporary values are retained and reused from iteration to iteration, so the compiler might decide to store those temporary values in registers.</p>\n<p>However, emulation of a virtual machine is a large task, so your code is likely to have many, many objects. It will have at least one object (likely an array element) for each register in the emulated machine, plus objects for other aspects of machine state, plus objects used to decode instructions and to dispatch to emulation code. The very simplest possible virtual machine emulator, suitable only for classroom exercises, might have few enough objects that most of them fit in processor registers. But any slightly realistic virtual machine emulator will have so many objects that few of them can be retained in processor registers. In this case, you are most likely better off leaving optimization to the optimizer and not trying to do it yourself.</p>\n", "LastActivityDate": "2013-06-27T01:58:53.353", "LastEditorUserId": "298225", "Id": "11881677", "CommentCount": "0", "CreationDate": "2012-08-09T10:46:38.297", "ParentId": "11880100", "Score": "2", "OwnerUserId": "298225", "LastEditDate": "2013-06-27T01:58:53.353"}, "11880216": {"PostTypeId": "2", "Body": "<p>Exactly as it is with <code>inline</code>, <code>register</code> is just a <em>recommendation</em> to the compiler. It may or may not follow it, as well as it may or may not store \"normal\" variables as <code>register</code> ones.</p>\n<p>The C++ standard says ( 7.1.1, paragraph 3 ):</p>\n<blockquote>\n<p id=\"so_11880100_11880216_0\">A register specifier is a hint to the implementation that the variable\n  so declared will be heavily used.  [ Note: The hint can be ignored and\n  in most implementations it will be ignored if the address of the\n  variable is taken. This use is deprecated (see D.2). \u2014 end note ]</p>\n</blockquote>\n<p>Before doing such a low-level optimization, you should really run a good analysis to determine the bottlenecks of your system, and see if you actually need it or not. </p>\n<p>Also, I could bet that if you are not a pro asm programmer, the compiler will optimize the code better than you (no offense to anyone, and I mean it in a general way). </p>\n", "LastActivityDate": "2012-08-09T09:22:59.687", "LastEditorUserId": "1490355", "Id": "11880216", "CommentCount": "5", "CreationDate": "2012-08-09T09:17:37.460", "ParentId": "11880100", "Score": "3", "OwnerUserId": "1490355", "LastEditDate": "2012-08-09T09:22:59.687"}, "bq_ids": {"n4140": {"so_11880100_11880216_0": {"length": 21, "quality": 0.8076923076923077, "section_id": 5393}}, "n3337": {"so_11880100_11880216_0": {"length": 21, "quality": 0.8076923076923077, "section_id": 5187}}}, "11880844": {"PostTypeId": "2", "Body": "<p>Registers don't work as you think they work, anyway. A name <code>R2</code> isn't really different from an address <code>2</code>. Sure, x86 assembly has fancier names such as <code>ECX</code>, but that's still register 2. </p>\n<p>And they're often not physical, either. Like virtual memory, register names are ephemeral. Modern processors may take a while to store a register value to RAM. They could wait for this to finish before recycling the register, but the faster solution is to just recycle the name and let the old (now un-named) register hold the value until the write is finished. This means the number of register addresses can be lower than the number of physical registers. (Another benefit is that newer and more expensive CPU's can have more registers and still be ISA-compatible).</p>\n<p>That said, your problem is classicly solved by <code>FMA</code> - Fused Multiply and Add. Your source code should not translate to <code>mul</code> and <code>add</code>, but to <code>mul_add(c,d,b,a)</code>. This will allow the C++ compiler to emit an FMA instruction, entirely bypassing the need for a temporarily.</p>\n", "LastActivityDate": "2012-08-09T09:55:51.653", "Id": "11880844", "CommentCount": "2", "CreationDate": "2012-08-09T09:55:51.653", "ParentId": "11880100", "Score": "2", "OwnerUserId": "15416"}, "11880395": {"PostTypeId": "2", "Body": "<p>If you turn on optimization when you compile, the compiler should use registers automatically for local variables, if there are enough registers available.\nCheck the generated machine code, to find if it does so in your case.</p>\n", "LastActivityDate": "2012-08-09T09:28:49.477", "Id": "11880395", "CommentCount": "4", "CreationDate": "2012-08-09T09:28:49.477", "ParentId": "11880100", "Score": "0", "OwnerUserId": "646887"}, "11880100": {"ViewCount": "633", "Body": "<p>The title may be a little unclear, so here is a clarification:</p>\n<p>The problem:</p>\n<pre><code>a = b + c * d;\n</code></pre>\n<p>which in my implementation is resolved to those two \"instructions\"</p>\n<pre><code>mul(c, d, temp)\nadd(b, temp, a)\n</code></pre>\n<p>I am currently using temporary objects to store the temporary values, which mandates the storing of the temporary value in RAM and fetching it again when it is needed, both of which are not really needed and lower performance.</p>\n<p>I am implementing the VM in C++, so my question is if there is some <strong>portable</strong> way to avoid the storage of temporary values into main memory but keep them on the actual CPU register?</p>\n<p>I've done some testing with using the <code>register</code> keyword, but judging from the lack of performance improvement, I'd say the compiler is ignoring it.</p>\n<p>As a last resort, I am willing to go for platform specific assembly, but I am pretty much in the dark on the subject, so if this is the only possible way, good info is welcome. I do realize this example I've given is a basic one, and it is more than likely to encounter a situation where a lot of temporary objects are needed, in which case there should be some way to determine how much registers to use and use memory storage for the rest...</p>\n<p>Perhaps there is some way to ask for register storage, and if the compiler \"runs out of\" registers, automatically push the temporaries on the stack? As far as I am familiar with assembly, you \"address\" specific registers by their name, and I am unclear on how exactly the compiler handles potential register usage conflicts...</p>\n", "Title": "Keeping temporary objects on the register to avoid extra store/load in a virtual machine?", "CreationDate": "2012-08-09T09:10:39.147", "LastActivityDate": "2015-06-11T12:15:06.943", "CommentCount": "10", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-06-11T12:15:06.943", "LastEditorUserId": "317266", "Id": "11880100", "Score": "2", "OwnerUserId": "991484", "Tags": "<c++><c><cpu-registers><temporary-objects><vm-implementation>", "AnswerCount": "4"}});