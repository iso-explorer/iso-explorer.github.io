post_cb({"bq_ids": {"n4140": {"so_23613574_23613574_25": {"length": 4, "quality": 0.5714285714285714, "section_id": 4657}, "so_23613574_23613574_21": {"length": 4, "quality": 0.5714285714285714, "section_id": 4657}, "so_23613574_23613574_10": {"length": 4, "quality": 0.5714285714285714, "section_id": 4657}, "so_23613574_23613574_5": {"length": 4, "quality": 0.5714285714285714, "section_id": 4657}, "so_23613574_23613574_40": {"length": 4, "quality": 0.5714285714285714, "section_id": 4657}, "so_23613574_23613574_55": {"length": 4, "quality": 0.5714285714285714, "section_id": 4657}}, "n3337": {"so_23613574_23613574_25": {"length": 4, "quality": 0.5714285714285714, "section_id": 4468}, "so_23613574_23613574_21": {"length": 4, "quality": 0.5714285714285714, "section_id": 4468}, "so_23613574_23613574_10": {"length": 4, "quality": 0.5714285714285714, "section_id": 4468}, "so_23613574_23613574_5": {"length": 4, "quality": 0.5714285714285714, "section_id": 4468}, "so_23613574_23613574_40": {"length": 4, "quality": 0.5714285714285714, "section_id": 4468}, "so_23613574_23613574_55": {"length": 4, "quality": 0.5714285714285714, "section_id": 4468}}}, "23614090": {"PostTypeId": "2", "Body": "<p>The move semantics introduced in C++11 exist to largely alleviate this set of 'unnecessary' copies. If you define a <code>move constructor</code> for your function-objects the STL will <code>move</code> the function-object (even/especially if it is a temporary) which will prevent the copy from occurring. This will allow you to use the STL algorithms with value-semantics without sacrificing too much in the way of performance. It will also allow you to use temporary function-objects as desired.</p>\n", "LastActivityDate": "2014-05-12T16:20:55.977", "Id": "23614090", "CommentCount": "2", "CreationDate": "2014-05-12T16:20:55.977", "ParentId": "23613574", "Score": "3", "OwnerUserId": "2774358"}, "23613574": {"ViewCount": "429", "Body": "<ul>\n<li><p>I've coded the following example in order to better illustrate my questions. </p></li>\n<li><p>In the code below, I introduce a <a href=\"http://en.wikipedia.org/wiki/Function_object\" rel=\"nofollow\">function object</a> (i.e., <code>funObj</code>). </p></li>\n<li><p>In <code>funObj</code> class's definition an integral member variable called <code>id</code> is defined to hold the ID of every <code>funObj</code> constructed and a static integral member variable <code>n</code> to count the <code>funObj</code> objects created. </p></li>\n<li><p>Thus, every time an object <code>funObj</code> is constructed <code>n</code> is increased by one and its value is assigned to the <code>id</code> field of the newly created <code>funObj</code>. </p></li>\n<li><p>Furthermore, I've defined a default constructor, a copy constructor and a destructor. All three are printing messages to the <code>stdout</code> in order to signify their invocation along with the ID of the <code>funObj</code> they are referring to. </p></li>\n<li><p>I've also defined a function <code>func</code> that takes as inputs by value objects of type <code>funObj</code>.</p></li>\n</ul>\n<h2><strong>Code:</strong></h2>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;functional&gt;\n\ntemplate&lt;typename T&gt;\nclass funObj {\n  std::size_t id;\n  static std::size_t n;\npublic:\n  funObj() : id(++n) \n  { \n    std::cout &lt;&lt; \"    Constructed via the default constructor, object foo with ID(\" &lt;&lt; id &lt;&lt; \")\" &lt;&lt; std::endl;\n  }\n  funObj(funObj const &amp;other) : id(++n) \n  {\n    std::cout &lt;&lt; \"    Constructed via the copy constructor, object foo with ID(\" &lt;&lt; id &lt;&lt; \")\" &lt;&lt; std::endl;\n  }\n  ~funObj()\n  { \n    std::cout &lt;&lt; \"    Destroyed object foo with ID(\" &lt;&lt; id &lt;&lt; \")\" &lt;&lt; std::endl;\n  }\n  void operator()(T &amp;elem)\n  { \n\n  }\n  T operator()()\n  {\n    return 1;\n  }\n};\n\ntemplate&lt;typename T&gt;\nvoid func(funObj&lt;T&gt; obj) { obj();  }\n\ntemplate&lt;typename T&gt;\nstd::size_t funObj&lt;T&gt;::n = 0;\n\nint main()\n{\n  std::vector&lt;int&gt; v{ 1, 2, 3, 4, 5, };\n  std::cout &lt;&lt; \"&gt; Calling `func`...\" &lt;&lt; std::endl;\n  func(funObj&lt;int&gt;());\n  std::cout &lt;&lt; \"&gt; Calling `for_each`...\" &lt;&lt; std::endl;\n  std::for_each(std::begin(v), std::end(v), funObj&lt;int&gt;());\n  std::cout &lt;&lt; \"&gt; Calling `generate`...\" &lt;&lt; std::endl;\n  std::generate(std::begin(v), std::end(v), funObj&lt;int&gt;());\n\n  // std::ref \n  std::cout &lt;&lt; \"&gt; Using `std::ref`...\" &lt;&lt; std::endl;\n  auto fobj1 = funObj&lt;int&gt;();\n  std::cout &lt;&lt; \"&gt; Calling `for_each` with `ref`...\" &lt;&lt; std::endl;\n  std::for_each(std::begin(v), std::end(v), std::ref(fobj1));\n  std::cout &lt;&lt; \"&gt; Calling `generate` with `ref`...\" &lt;&lt; std::endl;\n  std::for_each(std::begin(v), std::end(v), std::ref(fobj1));\n  return 0;\n}\n</code></pre>\n<h2><strong>Output:</strong></h2>\n<blockquote>\n<p id=\"so_23613574_23613574_0\">Calling <code>func</code>...</p>\n<blockquote>\n<p id=\"so_23613574_23613574_18\">Constructed via the default constructor, object foo with ID(1)</p>\n<p id=\"so_23613574_23613574_19\">Destroyed object foo with ID(1)</p>\n</blockquote>\n<p id=\"so_23613574_23613574_3\">Calling <code>for_each</code>...</p>\n<blockquote>\n<p id=\"so_23613574_23613574_20\">Constructed via the default constructor, object foo with ID(2)</p>\n<p id=\"so_23613574_23613574_21\">Constructed via the copy constructor, object foo with ID(3)</p>\n<p id=\"so_23613574_23613574_22\">Destroyed object foo with ID(2)</p>\n<p id=\"so_23613574_23613574_23\">Destroyed object foo with ID(3)</p>\n</blockquote>\n<p id=\"so_23613574_23613574_8\">Calling <code>generate</code>...</p>\n<blockquote>\n<p id=\"so_23613574_23613574_24\">Constructed via the default constructor, object foo with ID(4)</p>\n<p id=\"so_23613574_23613574_25\">Constructed via the copy constructor, object foo with ID(5)</p>\n<p id=\"so_23613574_23613574_26\">Destroyed object foo with ID(5)</p>\n<p id=\"so_23613574_23613574_27\">Destroyed object foo with ID(4)</p>\n</blockquote>\n<p id=\"so_23613574_23613574_13\">Using <code>std::ref</code>...</p>\n<blockquote>\n<p id=\"so_23613574_23613574_28\">Constructed via the default constructor, object foo with ID(6)</p>\n</blockquote>\n<p id=\"so_23613574_23613574_15\">Calling <code>for_each</code> with <code>ref</code>...</p>\n<p id=\"so_23613574_23613574_16\">Calling <code>generate</code> with <code>ref</code>...</p>\n<blockquote>\n<p id=\"so_23613574_23613574_29\">Destroyed object foo with ID(6)</p>\n</blockquote>\n</blockquote>\n<h2><strong>Discussion:</strong></h2>\n<p>As you can see from the output above, calling function <code>func</code> with a temporary object of type <code>funObj</code> results in the construction of a single <code>funObj</code> object (even though <code>func</code> passes its argument by value). However, this seems not to be the case when passing temporary objects of type <code>funObj</code> to STL algorithms <code>std::for_each</code> and <code>std::generate</code>. In the former cases the copy constructor is evoked and an extra <code>funObj</code> is constructed. In quite a few applications the creation of such \"unnecessary\" copies deteriorates the performance of the algorithm significantly. Based on this fact the following questions are being raised. </p>\n<h2><strong>Questions:</strong></h2>\n<ol>\n<li>I know that most STL algorithms pass their argument by value. However, compared to <code>func</code>, that also passes its input argument by value, the STL algorithms generate an extra copy. What's the reason for this \"unnecessary\" copy?</li>\n<li>Is there a way to eliminate such \"unnecessary\" copies?</li>\n<li>When calling <code>std::for_each(std::begin(v), std::end(v), funObj&lt;int&gt;())</code> and <code>func(funObj&lt;int&gt;())</code> in which scope does temporary object <code>funObj&lt;int&gt;</code> lives, for each case respectively?</li>\n<li>I've tried to use <code>std::ref</code> in order to force pass by reference and as you can see the \"unnecessary\" copy was eliminated. However, when I try to pass a temporary object to <code>std::ref</code> (i.e., <code>std::ref(funObj&lt;int&gt;())</code>) I get a compiler error. Why  such kind of statements are illegal?</li>\n<li>The output was generated using VC++2013. As you can see there's an anomaly when calling <code>std::for_each</code> the destructors of the objects are being called in reversed order. Why is that so?</li>\n<li>When I run the code on <a href=\"http://coliru.stacked-crooked.com/a/e2fb647376b6c2f8\" rel=\"nofollow\">Coliru</a> that runs GCC v4.8 the anomaly with destructors is fixed however <code>std::generate</code> doesn't generate an extra copy. Why is that so?</li>\n</ol>\n<h2><strong>Details/Comments:</strong></h2>\n<ul>\n<li>The output above was generated from VC++2013.</li>\n</ul>\n<h2><strong>Update:</strong></h2>\n<ul>\n<li>I've also added to <code>funObj</code> class a move constructor (see code below).</li>\n</ul>\n<hr>\n<pre><code> funObj(funObj&amp;&amp; other) : id(other.id)\n  {\n    other.id = 0;\n    std::cout &lt;&lt; \"    Constructed via the move constructor, object foo with ID(\" &lt;&lt; id &lt;&lt; \")\" &lt;&lt; std::endl;\n  }\n</code></pre>\n<hr>\n<ul>\n<li>I've also turned on full optimization in VC++2013 and compiled in release mode.</li>\n</ul>\n<h2><strong>Output (VC++2013):</strong></h2>\n<blockquote>\n<p id=\"so_23613574_23613574_30\">Calling <code>func</code>...</p>\n<blockquote>\n<p id=\"so_23613574_23613574_48\">Constructed via the default constructor, object foo with ID(1)</p>\n<p id=\"so_23613574_23613574_49\">Destroyed object foo with ID(1)</p>\n</blockquote>\n<p id=\"so_23613574_23613574_33\">Calling <code>for_each</code>...</p>\n<blockquote>\n<p id=\"so_23613574_23613574_50\">Constructed via the default constructor, object foo with ID(2)</p>\n<p id=\"so_23613574_23613574_51\">Constructed via the move constructor, object foo with ID(2)</p>\n<p id=\"so_23613574_23613574_52\">Destroyed object foo with ID(2)</p>\n<p id=\"so_23613574_23613574_53\">Destroyed object foo with ID(0)</p>\n</blockquote>\n<p id=\"so_23613574_23613574_38\">Calling <code>generate</code>...</p>\n<blockquote>\n<p id=\"so_23613574_23613574_54\">Constructed via the default constructor, object foo with ID(3)</p>\n<p id=\"so_23613574_23613574_55\">Constructed via the copy constructor, object foo with ID(4)</p>\n<p id=\"so_23613574_23613574_56\">Destroyed object foo with ID(4)</p>\n<p id=\"so_23613574_23613574_57\">Destroyed object foo with ID(3)</p>\n</blockquote>\n<p id=\"so_23613574_23613574_43\">Using <code>std::ref</code>...</p>\n<blockquote>\n<p id=\"so_23613574_23613574_58\">Constructed via the default constructor, object foo with ID(5)</p>\n</blockquote>\n<p id=\"so_23613574_23613574_45\">Calling <code>for_each</code> with <code>ref</code>...</p>\n<p id=\"so_23613574_23613574_46\">Calling <code>generate</code> with <code>ref</code>...</p>\n<blockquote>\n<p id=\"so_23613574_23613574_59\">Destroyed object foo with ID(5)</p>\n</blockquote>\n</blockquote>\n<h2><strong>Output GCC 4.8</strong></h2>\n<blockquote>\n<p id=\"so_23613574_23613574_60\">Calling <code>func</code>...</p>\n<blockquote>\n<p id=\"so_23613574_23613574_75\">Constructed via the default constructor, object foo with ID(1)</p>\n<p id=\"so_23613574_23613574_76\">Destroyed object foo with ID(1)</p>\n</blockquote>\n<p id=\"so_23613574_23613574_63\">Calling <code>for_each</code>...</p>\n<blockquote>\n<p id=\"so_23613574_23613574_77\">Constructed via the default constructor, object foo with ID(2)</p>\n<p id=\"so_23613574_23613574_78\">Constructed via the move constructor, object foo with ID(2)</p>\n<p id=\"so_23613574_23613574_79\">Destroyed object foo with ID(2)</p>\n<p id=\"so_23613574_23613574_80\">Destroyed object foo with ID(0)</p>\n</blockquote>\n<p id=\"so_23613574_23613574_68\">Calling <code>generate</code>...</p>\n<blockquote>\n<p id=\"so_23613574_23613574_81\">Constructed via the default constructor, object foo with ID(3)</p>\n<p id=\"so_23613574_23613574_82\">Destroyed object foo with ID(3)</p>\n<p id=\"so_23613574_23613574_83\">Constructed via the default constructor, object foo with ID(4)</p>\n</blockquote>\n<p id=\"so_23613574_23613574_72\">Calling <code>for_each</code> with <code>ref</code>...</p>\n<p id=\"so_23613574_23613574_73\">Calling <code>generate</code> with <code>ref</code>...</p>\n<blockquote>\n<p id=\"so_23613574_23613574_84\">Destroyed object foo with ID(4)</p>\n</blockquote>\n</blockquote>\n<p>It seems that VC++2013 <code>std::generate</code> generates an extra copy no-matter if optimization flags are on and compilation is in release mode and besides the fact that a move constructor is defined.</p>\n</hr></hr>", "AcceptedAnswerId": "23614591", "Title": "eliminate unnecessary copies when calling C++/STL algorithms", "CreationDate": "2014-05-12T15:54:42.527", "Id": "23613574", "CommentCount": "19", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2014-05-12T21:11:36.077", "LastEditorUserId": "2352671", "LastActivityDate": "2014-05-12T21:11:36.077", "Score": "5", "OwnerUserId": "2352671", "Tags": "<c++><visual-c++><c++11><stl><g++4.8>", "AnswerCount": "2"}, "23614591": {"PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_23613574_23614591_0\"><em>1 - I know that most STL algorithms pass their argument by value. However, compared to func, that also passes its input argument by value, the STL algorithms generate an extra copy. What's the reason for this \"unnecessary\" copy?</em></p>\n</blockquote>\n<p><strong>STL algorithms return the function object</strong>. This happens so that the mutation on the object will be observable. Your <code>func</code> returns void so that's a copy less. </p>\n<ul>\n<li>Well, to be precise, <code>generate</code> does not return a thing (see comment by <a href=\"https://stackoverflow.com/users/420683/dyp\">dyp)</a></li>\n</ul>\n<blockquote>\n<p id=\"so_23613574_23614591_1\"><em>2 - Is there a way to eliminate such \"unnecessary\" copies?</em></p>\n</blockquote>\n<p>Well <strong>unnecessary</strong> is a bit too strong. The whole point of functors is to be lightweight objects so that a copy wouldn't matter. As for a way, the one you provide (std::ref) will do the job, alas a copy of the <code>std::ref</code> will be generated (your object won't get copied though)</p>\n<h2>Another way would be to <strong>qualify the call of the algorithm</strong></h2>\n<p>then the function object type will be a reference : </p>\n<pre><code>auto fobj1 = funObj&lt;int&gt;();\n\nstd::for_each&lt;std::vector&lt;int&gt;::iterator, std::vector&lt;int&gt;::iterator, \nfunObj&lt;int&gt;&amp;&gt; // this is where the magic happens !!\n(std::begin(v), std::end(v), fobj1);\n</code></pre>\n<blockquote>\n<p id=\"so_23613574_23614591_2\"><em>3 - When calling std::for_each(std::begin(v), std::end(v), funObj()) and func(funObj()) in which scope does temporary object funObj lives, for each case respectively?</em></p>\n</blockquote>\n<p>The body of <a href=\"http://www.cplusplus.com/reference/algorithm/for_each/\" rel=\"nofollow noreferrer\"><code>std_for_each</code></a> is expanded as follows : </p>\n<pre><code>template&lt;class InputIterator, class Function&gt;\n  Function for_each(InputIterator first, InputIterator last, Function fn)\n{ // 1\n  while (first!=last) {\n    fn (*first);\n    ++first;\n  }\n  return fn;      // or, since C++11: return move(fn);\n// 2\n}\n</code></pre>\n<p>your function reads </p>\n<pre><code>template&lt;typename T&gt;\nvoid func(funObj&lt;T&gt; obj) \n{ // 1.\n    obj();  \n// 2.\n}\n</code></pre>\n<p>The comments <code>1</code> and <code>2</code> mark the lifespan in each case. Note though that <strong>if a return value optimization applies</strong> (named or unnamed), then the compiler may generate code that places the return value (the function object in for_each) in the stack frame of the caller, so the life span is longer. </p>\n<blockquote>\n<p id=\"so_23613574_23614591_3\"><em>4 - I've tried to use std::ref in order to force pass-by-reference and as you can see the \"unnecessary\" copy was eliminated. However, when I try to pass a temporary object to std::ref (i.e., std::ref(funObj())) I get a compiler error. Why such kind of statements are illegal?</em></p>\n</blockquote>\n<p><code>std::ref</code> does not work with r-value references (STL code follows):</p>\n<pre><code>template&lt;class _Ty&gt;\nvoid ref(const _Ty&amp;&amp;) = delete;\n</code></pre>\n<p>you need to pass an l-value</p>\n<blockquote>\n<p id=\"so_23613574_23614591_4\"><em>5 - The output was generated using VC++2013. As you can see there's an anomaly when calling std::for_each the destructors of the objects are being called in reversed order. Why is that so?</em></p>\n<p id=\"so_23613574_23614591_5\"><em>6 - When I run the code on Coliru that runs GCC v4.8 the anomaly with destructors is fixed however std::generate doesn't generate an extra copy. Why is that so?</em></p>\n</blockquote>\n<ul>\n<li><p>Check the settings for each compilation. With optimizations ON (and in Release for VS) copy elision / elimination of extra copies / ignoring non observable behaviors, are possible.       </p></li>\n<li><p>Secondly (as far as I can see) in VS 2013 the functor in <code>for_each</code> and the generator in <code>generate</code> are both passed by value (<strong>there's no signature accepting an r-value reference</strong>) so it would be clearly a matter of <strong>copy elision</strong> to save the extra copy.</p></li>\n</ul>\n<p>For what matters, the <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.6.3/libstdc++/api/a01045_source.html\" rel=\"nofollow noreferrer\">STL implementation in gcc</a> also has no signatures that accept r-value references (please notify me if one having is spotted)</p>\n<pre><code>template&lt;typename _InputIterator, typename _Function&gt;\n_Function\nfor_each(_InputIterator __first, _InputIterator __last, _Function __f)\n{\n  // concept requirements\n  __glibcxx_function_requires(_InputIteratorConcept&lt;_InputIterator&gt;)\n  __glibcxx_requires_valid_range(__first, __last);\n  for (; __first != __last; ++__first)\n__f(*__first);\n  return _GLIBCXX_MOVE(__f);\n}\n</code></pre>\n<p>so I may be going out on limb on this one and assume, that defining move semantics for your functor has no effect and only compiler optimizations apply to eliminate copies </p>\n", "LastActivityDate": "2014-05-12T19:17:23.743", "LastEditorUserId": "-1", "Id": "23614591", "CommentCount": "10", "CreationDate": "2014-05-12T16:48:45.607", "ParentId": "23613574", "Score": "4", "OwnerUserId": "2567683", "LastEditDate": "2017-05-23T12:05:37.643"}});