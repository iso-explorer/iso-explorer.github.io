post_cb({"1872597": {"ParentId": "1872571", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>MyClass* p = static_cast&lt;MyClass*&gt;(0)</code> works well.</p>\n<p><strong>New</strong>:</p>\n<p>If you use multiple inheritance then <code>static_cast</code> may shift your pointer.\nConsider the following code:</p>\n<pre><code>struct B1 {};\nstruct B2 {};\n\nstruct A : B2, B1 {\n virtual ~A() {}\n};\n</code></pre>\n<p>What is struct <code>A</code>? \n<code>A</code> contains a table of virtual functions and <code>B1</code> and <code>B2</code>.\n<code>B1</code> is shifted with respect to <code>A</code>. \nTo cast <code>B1</code> to <code>A</code> compiler need to back shift.</p>\n<p>If the pointer to <code>B1</code> is NULL then shift gives invalid result.</p>\n", "OwnerUserId": "124161", "LastEditorUserId": "124161", "LastEditDate": "2009-12-09T11:13:44.687", "Id": "1872597", "Score": "1", "CreationDate": "2009-12-09T09:21:27.697", "LastActivityDate": "2009-12-09T11:13:44.687"}, "1872571": {"CommentCount": "4", "AcceptedAnswerId": "1872860", "PostTypeId": "1", "LastEditorUserId": "14065", "CreationDate": "2009-12-09T09:16:13.870", "LastActivityDate": "2009-12-09T15:09:05.823", "LastEditDate": "2009-12-09T10:31:48.000", "ViewCount": "8952", "FavoriteCount": "1", "Title": "NULL pointer compatibility with static_cast", "Id": "1872571", "Score": "5", "Body": "<p>Q1. Why does using NULL pointers with static_cast cause crashes while dynamic_cast and reinterpret_cast give a NULL pointer in return?</p>\n<p>The problem occurred in a method similar to the one given below:</p>\n<pre><code>void A::SetEntity(B* pEntity, int iMyEntityType)\n{   \n    switch (iMyEntityType)\n    {   \n    case ENTITY1:\n        {\n            Set1(static_cast&lt;C*&gt;(pEntity));\n            return;\n        }\n    case ENTITY2:\n        {\n            Set2(static_cast&lt;D*&gt;(pEntity));\n            return;\n        }\n    case ENTITY3:\n        {\n            Set3(static_cast&lt;E*&gt;(pEntity));\n            return;\n        }   \n    }\n}\n\nInheritance:\n  class X: public B\n  class Y: public B\n  class Z: public B\n\n  class C: public X, public M\n  class D: public Y, public M\n  class E: public Z, public M\n</code></pre>\n<p>Q2. Is static_casting from B to C/D/E valid? (this worked ok till the input became NULL)</p>\n<p>I'm using gcc version 3.4.3</p>\n", "Tags": "<c++><casting>", "OwnerUserId": "86059", "AnswerCount": "5"}, "1872860": {"ParentId": "1872571", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>What compiler are you using?  A static cast from a base type to a derived type  might result in an adjustment to the pointer - especially likely if multiple inheritance is involved (which doesn't seem to be the case in your situation from your description).  However, it's still possible without MI.</p>\n<p>The standard indicates that if a null pointer value is being cast that the result will be a null pointer value (5.2.9/8 Static cast).  However, I think that on many compilers most downcasts (especially when single inheritance is involved) don't result in a pointer adjustment, so I could imagine that a compiler might have a bug such that it wouldn't make the special check for null that would be required to avoid 'converting' a zero value null pointer to some non-zero value senseless pointer.  I would assume that for such a bug to exist you must be doing something unusual to get the compiler to have to adjust the  pointer in the downcast.</p>\n<p>It might be interesting to see what kind of assembly code was generated for your example.</p>\n<p>And for detailed information about how a compiler might layout an object that might need pointer adjustment with static casts, <a href=\"http://www.informit.com/store/product.aspx?isbn=0201834545\" rel=\"nofollow noreferrer\">Stan Lippman's \"Inside the C++ Object Model\"</a> is a great resource.</p>\n<p><a href=\"http://www.usenix.org/publications/compsystems/1989/fall_stroustrup.pdf\" rel=\"nofollow noreferrer\">Stroustrup's paper on Multiple Inheritance for C++</a> (from 1989) is also a good read. It's too bad if a C++ compiler has a bug like I speculate about here - Stroustrup discusses the null pointer issue explicitly in that paper (4.5 Zero Valued Pointers).</p>\n<p>For your second question:</p>\n<blockquote>\n<p id=\"so_1872571_1872860_0\">Q2. Is static_casting from B to C/D/E valid?</p>\n</blockquote>\n<p>This is perfectly valid as long as when you perform the cast of the B pointer to a C/D/E pointer the B pointer is actually pointing to the B sub-object of a C/D/E object (respectively) and B isn't a virtual base.  This is mentioned in the same paragraph of the standard (5.2.9/8 Static cast). I've highlighted the sentences of the paragraph most relevant to your questions:</p>\n<blockquote>\n<p id=\"so_1872571_1872860_1\">An rvalue of type \u201cpointer to cv1 B\u201d, where B is a class type, can be converted to an rvalue of type \u201cpointer to cv2 D\u201d, where D is a class derived (clause 10) from B, if a valid standard conversion from \u201cpointer to D\u201d to \u201cpointer to B\u201d exists (4.10), cv2 is the same cv-qualification as, or greater cv-qualification than, cv1, and B is not a virtual base class of D.  <strong>The null pointer value (4.10) is converted to the null pointer value of the destination type.  If the rvalue of type \u201cpointer to cv1 B\u201d points to a B that is actually a sub-object of an object of type D, the resulting pointer points to the enclosing object of type D.</strong> Otherwise, the result of the cast is undefined.</p>\n</blockquote>\n<p>As a final aside, you can workaround the problem using something like:</p>\n<pre><code>Set1(pEntity ? static_cast&lt;C*&gt;(pEntity) : 0);\n</code></pre>\n<p>which is what the compiler should be doing for you.</p>\n", "OwnerUserId": "12711", "LastEditorUserId": "12711", "LastEditDate": "2009-12-09T10:57:02.460", "Id": "1872860", "Score": "4", "CreationDate": "2009-12-09T10:04:51.857", "LastActivityDate": "2009-12-09T10:57:02.460"}, "1872672": {"ParentId": "1872571", "CommentCount": "4", "Body": "<p>You can <code>static_cast</code> a null pointer - it will give you a null pointer.</p>\n<p>In your snippet the problem is most possibly that you pass inconsistent values of <code>pEntity</code> and <code>iMyEntityType</code> into the function. So that when <code>static_cast</code> is done it blindly casts to the wrong type (not the same type as the actual object) and you get an invalid pointer that is later passed down the call stack and causes undefined behaviour (crashes the program). <code>dynamic_cast</code> in the same case sees that the object is really not of the expected type and returns a null pointer.</p>\n", "OwnerUserId": "57428", "PostTypeId": "2", "Id": "1872672", "Score": "7", "CreationDate": "2009-12-09T09:35:27.577", "LastActivityDate": "2009-12-09T09:35:27.577"}, "1872686": {"ParentId": "1872571", "CommentCount": "3", "Body": "<p><code>static_cast</code> cannot itself cause a crash - its behaviour at runtime is the same as <code>reinterpret_cast</code>. There is something wrong somewhere else in your code.</p>\n", "Id": "1872686", "PostTypeId": "2", "OwnerDisplayName": "anon", "Score": "3", "CreationDate": "2009-12-09T09:37:37.207", "LastActivityDate": "2009-12-09T09:37:37.207"}, "1872676": {"ParentId": "1872571", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><code>static_cast</code> is for situations when you <strong>know</strong> the cast can be done (either you cast to a parent class, or you have other ways of assessing the type of the class). There is no runtime check on the type (hence the <code>static</code>). On the other hand, <code>dynamic_cast</code> will check, at runtime, if the object is really of the type you want to cast it to. As for <code>reinterpret_cast</code>, it doesn't do anything but using the same memory for a different purpose. Note that <code>reinterpret_cast</code> should never be used to change from one class to another.</p>\n<p>In the end, the reason <code>static_cast</code> on NULL pointer crashes, is because a <code>static_cast</code> with inheritance might requires a bit of pointer arithmetic form the compiler. This depend on how the compiler actually implement inheritance. But in case of multiple inheritance, it doesn't have a choice.</p>\n<p>One way to see this is that the daughter class \"contains\" the parent class. It virtual table contains the one of the parent, but with added features. If the features are added at the beginning, then any cast to the parent class will point to a different place ... from where the features of the daughter class cannot be seen. I hope this make sense.</p>\n<p><strong>Note on pointer arithmetic</strong></p>\n<p>First, this is always be the case for multiple inheritance, but a compiler might choose to do so for single inheritance too.</p>\n<p>Basically, if you look at the memory layout for an object content with virtual methods, you could do something like:</p>\n<pre><code>+---------------+----------------+\n| ptr to vtable | members   .... |\n+---------------+----------------+\n</code></pre>\n<p>In case of single inheritance, this is pretty much enough. In particular, you can ensure that the vtable of any derived class starts with the vtable of the mother class and the first members are those of the mother class.</p>\n<p>Now, if you have multiple inheritance, things are more complex. In particular, you probably can't merge vtables and members in a consistent way (at least not in the general case). So, say you inherit from classes A, B and C, you will probably have something like:</p>\n<pre><code>                       A                       B                      C\n+----------------------+-----------+-----------+----------+-----------+-----+\n| local vtable/members | vtable A  | members A | vtable B | members B | ... |\n+----------------------+-----------+-----------+----------+-----------+-----+\n</code></pre>\n<p>Such that if you point on A, you will see the object as an object of type <code>A</code>, plus the rest. But if you want to see the object as being of type <code>B</code>, you need to point to the address B, etc. Note, this might not be exactly what the system does, but that's the git of it.</p>\n", "OwnerUserId": "7136", "LastEditorUserId": "7136", "LastEditDate": "2009-12-09T15:09:05.823", "Id": "1872676", "Score": "1", "CreationDate": "2009-12-09T09:35:46.863", "LastActivityDate": "2009-12-09T15:09:05.823"}, "bq_ids": {"n4140": {"so_1872571_1872860_1": {"section_id": 6037, "quality": 0.7777777777777778, "length": 49}}, "n3337": {"so_1872571_1872860_1": {"section_id": 5805, "quality": 0.8095238095238095, "length": 51}}, "n4659": {"so_1872571_1872860_1": {"section_id": 7536, "quality": 0.6984126984126984, "length": 44}}}});