post_cb({"2537825": {"Id": "2537825", "PostTypeId": "2", "Body": "<p>My guess as to why this happens: complete specializations are no longer \"template classes/functions\", they are are \"real\" classes/methods, and get to have real (linker-visible) symbols. But for a completely-specialized template inside a partially-specialized one, this would not be true.\nProbably this decision was taken just to simplify the life of compiler-writers (and make life harder for coders, in the process :P ).</p>\n", "LastActivityDate": "2010-03-29T12:31:58.407", "CommentCount": "6", "CreationDate": "2010-03-29T12:31:58.407", "ParentId": "2537716", "Score": "23", "OwnerUserId": "186969"}, "2537908": {"Id": "2537908", "PostTypeId": "2", "Body": "<p>You can work around this behavior by delegating the real work to another structure though:</p>\n<pre><code>namespace detail\n{\n  template &lt;class T, class U&gt;\n  struct InnerImpl {};\n}\n\ntemplate &lt;class T&gt;\nstruct Outer\n{\n  template &lt;class U&gt;\n  struct Inner: detail::InnerImpl&lt;T,U&gt;\n  {\n  };\n};\n</code></pre>\n<p>Now you can specialize <code>InnerImpl</code> as you wish</p>\n", "LastActivityDate": "2010-03-29T12:47:30.140", "CommentCount": "4", "CreationDate": "2010-03-29T12:47:30.140", "ParentId": "2537716", "Score": "7", "OwnerUserId": "147192"}, "2537842": {"Id": "2537842", "PostTypeId": "2", "Body": "<p>Backing up Virgil's argument (he was faster than I posting the same rationale), consider this:</p>\n<pre><code>template&lt;typename T1&gt;\nclass TOuter\n  {\n  public:\n    template&lt;typename T2&gt;\n    class TInner\n      {\n      public:\n        T1 m_1;\n        T2 m_2;\n      };\n  };\n\ntemplate&lt;typename T1&gt;\ntemplate&lt;&gt;\nclass TOuter&lt;T1&gt;::TInner&lt;float&gt;\n  {\n  public:\n    T1    m_1;\n    float m_2;\n };\n</code></pre>\n<p>Is TInner fully specialized, or partially specialized because of T1?  </p>\n<p>Edit:</p>\n<p>After considering some of the other comments - it seems that you want to have a full specialization based on the template parameter in the outer class.  If you nest the inner class's implementation, that seems to work in Visual Studio 2005:</p>\n<pre><code>template&lt;typename T1&gt;\nclass TOuter\n  {\n  public:\n    template&lt;typename T2&gt;\n    class TInner\n      {\n      public:\n        std::string DoSomething() { return \"Inner - general\"; }\n        T2 m_2;\n      };\n\n    template&lt;&gt;\n    class TInner&lt;T1&gt;\n      {\n      public:\n        std::string DoSomething() { return \"Inner - special\"; }\n        T1 m_1;\n      };\n  };\n</code></pre>\n<p>TOuter::TInner will correctly be the specialization of TInner.   I could not get it to compile with the implementation outside of the template.</p>\n", "LastEditorUserId": "33987", "LastActivityDate": "2010-03-29T13:45:17.190", "Score": "4", "CreationDate": "2010-03-29T12:34:27.297", "ParentId": "2537716", "CommentCount": "5", "OwnerUserId": "33987", "LastEditDate": "2010-03-29T13:45:17.190"}, "bq_ids": {"n4140": {"so_2537716_2537776_0": {"length": 35, "quality": 1.0, "section_id": 278}}, "n3337": {"so_2537716_2537776_0": {"length": 35, "quality": 1.0, "section_id": 269}}, "n4659": {"so_2537716_2537776_0": {"length": 35, "quality": 1.0, "section_id": 285}}}, "2537776": {"Id": "2537776", "PostTypeId": "2", "Body": "<p>C++ Standard explicitly prohibits full specialization of member template classes in first case. According to 14.7.3/18:</p>\n<blockquote>\n<p id=\"so_2537716_2537776_0\">In an explicit specialization declaration for a member of a class template or a member template that appears\n  in namespace scope, the member template and some of its enclosing class templates may remain unspecialized,\n  except that the declaration <strong>shall not explicitly specialize a class member template if its enclosing class\n  templates are not explicitly specialized as well</strong>.</p>\n</blockquote>\n", "LastActivityDate": "2010-03-29T12:25:35.403", "CommentCount": "7", "CreationDate": "2010-03-29T12:25:35.403", "ParentId": "2537716", "Score": "8", "OwnerUserId": "123111"}, "2537716": {"ViewCount": "5959", "Body": "<pre><code>    template&lt;int x&gt; struct A {                                                                                                    \n        template&lt;int y&gt; struct B {};.                                                                                             \n        template&lt;int y, int unused&gt; struct C {};                                                                                  \n    };                                                                                                                            \n\n    template&lt;int x&gt; template&lt;&gt; \n    struct A&lt;x&gt;::B&lt;x&gt; {}; // error: enclosing class templates are not explicitly specialized\n\n    template&lt;int x&gt; template&lt;int unused&gt; \n    struct A&lt;x&gt;::C&lt;x, unused&gt; {}; // ok\n</code></pre>\n<p>So why is the explicit specialization of a inner, nested class (or function) not allowed, if the outer class isn't specialized too? Strange enough, I can work around this behaviour if I only <em>partially</em> specialize the inner class with simply adding a dummy template parameter. Makes things uglier and more complex, but it works.</p>\n<p>I would consider complete specializations as a subset of partial specializations - especially because you can express every complete specialization as a partial with adding a dummy parameter. So this disambiguation between partial and full specialization doesn't really make sense for me.</p>\n<p>Unfortunatly nobody at comp.std.c++ dared to answer, so I am putting it up here again with a bounty.</p>\n<p>Note: I need this feature for recursive templates of the inner class for a set of the outer class and the specialization of the inner parameter does depend on the outer template parameter.</p>\n", "AcceptedAnswerId": "2537825", "Title": "Why is partial specialziation of a nested class template allowed, while complete isn't?", "CreationDate": "2010-03-29T12:15:58.793", "Id": "2537716", "CommentCount": "2", "FavoriteCount": "9", "PostTypeId": "1", "LastEditDate": "2010-04-06T07:59:51.777", "LastEditorUserId": "154980", "LastActivityDate": "2010-04-06T07:59:51.777", "Score": "37", "OwnerUserId": "154980", "Tags": "<c++><templates><metaprogramming>", "AnswerCount": "4"}});