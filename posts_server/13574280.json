post_cb({"bq_ids": {"n4140": {"so_13574280_13575039_0": {"length": 4, "quality": 1.0, "section_id": 1639}}, "n3337": {"so_13574280_13575039_0": {"length": 4, "quality": 1.0, "section_id": 1636}}, "n4659": {"so_13574280_13575039_0": {"length": 4, "quality": 1.0, "section_id": 1798}}}, "13574280": {"ViewCount": "234", "Body": "<p>I just figured out that in Visual Studio C++ 2010, <code>basic_string::append (iter, iter)</code> is, obviously, not implemented by making use of <code>std::copy</code>.</p>\n<p>First question:</p>\n<p>Now suppose I implement my own iterator type, together with an optimized overloading of <code>std::copy</code> for my iterator type in order to provide more efficient block-wise copying. Is there any way to get <code>basic_string::append</code> to make use of this optimization, apart from overloading <code>append</code> as well?</p>\n<p>Is there any chance that <code>basic_string::append (iter, iter)</code> does not do character-wise copying?</p>\n<p>Second question (as a starting point for my own implementation):</p>\n<p>Is the following guaranteed to be valid?</p>\n<pre><code>std::string t (\"JohnB\");\nstd::string s;\ns.reserve (10);\nstd::copy (t.begin (), t.end (), s.begin ());\ns.push_back ('\\0');\n</code></pre>\n<p>or should I better use a <code>back_inserter</code>? If I use a <code>back_inserter</code> -- how can I avoid character-wise copying?</p>\n", "AcceptedAnswerId": "13575039", "Title": "Why doesn't basic_string::append (iter, iter) call std::copy?", "CreationDate": "2012-11-26T22:30:47.230", "Id": "13574280", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2012-11-26T23:36:59.823", "Score": "5", "OwnerUserId": "1419315", "Tags": "<c++><string><copy>", "AnswerCount": "2"}, "13574947": {"Id": "13574947", "PostTypeId": "2", "Body": "<p>The string class has its own traits class that defines the operations it can do on the characters it contains. </p>\n<p>To copy <code>char</code>s, <code>basic_string&lt;char&gt;</code> will use <code>std::char_traits&lt;char&gt;::copy</code> (instead of the more general <code>std::copy</code>). That probably maps to the <code>memcpy</code> function in the standard C library.</p>\n", "LastActivityDate": "2012-11-26T23:26:35.353", "Score": "5", "CreationDate": "2012-11-26T23:26:35.353", "ParentId": "13574280", "CommentCount": "4", "OwnerUserId": "597607"}, "13575039": {"Id": "13575039", "PostTypeId": "2", "Body": "<p>The definition of <code>std::basic_string&lt;cT, ...&gt;::append()</code> keeps delegating a few time before it eventually arrives at the overload (21.4.6.2 [string::append] paragraph 7):</p>\n<blockquote>\n<p id=\"so_13574280_13575039_0\"><code>basic_string&amp; append(const charT* s, size_type n);</code></p>\n</blockquote>\n<p>At this point there is clearly none of the original iterators left. In case you wonder what happens to the input iterator you may have passed to <code>append()</code>, the got removed by the overload in paragraph 17 of the same paragraph which states:</p>\n<blockquote>\n<p id=\"so_13574280_13575039_1\">Effects: Equivalent to <code>append(basic_string(first, last))</code>.</p>\n</blockquote>\n<p>at some intermediate state. If the standard library is implemented the way as it is literally stated by the standard there is clearly no call to <code>std::copy()</code>.</p>\n<p>You wouldn't really be able to see your overloaded version of <code>std::copy()</code> anyway, though. What the library may do is the moral equivalent of</p>\n<pre><code>template &lt;typename InIt&gt;\nstd::basic_string&lt;cT, ...&gt;&amp; std::basic_string&lt;cT, ...&gt;::append(InIt begin, InIt end) {\n    if (is_forward_iterator&lt;begin&gt;::value) {\n        this-&gt;reserve(this-&gt;size() + std::distance(begin, end));\n    }\n    std::copy(begin, end, back_inserter_without_capacity_check&lt;InIt&gt;(*this);\n}\n</code></pre>\n<p>Now, the other interesting bit is: Even if this is how it implemented, it doesn't really help you with respect to <code>std::copy()</code>! You cannot partially specialize <code>std::copy()</code> (well, you can't partially specialize any function template) and the type of target iterator is not defined (in the above implementation it would be a non-capacity checking variant of <code>std::back_inserter()</code> if <code>InIt</code> is a forward iterator and otherwise it would just be the same as <code>std::back_inserter()</code>.</p>\n", "LastActivityDate": "2012-11-26T23:36:59.823", "Score": "2", "CreationDate": "2012-11-26T23:36:59.823", "ParentId": "13574280", "CommentCount": "2", "OwnerUserId": "1120273"}});