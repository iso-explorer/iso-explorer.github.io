post_cb({"bq_ids": {"n4140": {"so_23564044_23564720_0": {"length": 54, "quality": 0.9152542372881356, "section_id": 6182}, "so_23564044_23564720_5": {"length": 33, "quality": 0.868421052631579, "section_id": 5366}, "so_23564044_23564720_3": {"length": 7, "quality": 0.7, "section_id": 6185}, "so_23564044_23564720_2": {"length": 35, "quality": 0.8333333333333334, "section_id": 39}, "so_23564044_23564199_0": {"length": 7, "quality": 0.875, "section_id": 6182}}, "n3337": {"so_23564044_23564199_0": {"length": 7, "quality": 0.875, "section_id": 5943}, "so_23564044_23564720_5": {"length": 33, "quality": 0.868421052631579, "section_id": 5162}, "so_23564044_23564720_2": {"length": 41, "quality": 0.9761904761904762, "section_id": 36}, "so_23564044_23564720_3": {"length": 10, "quality": 1.0, "section_id": 5946}, "so_23564044_23564720_0": {"length": 48, "quality": 0.8135593220338984, "section_id": 5943}}, "n4659": {"so_23564044_23564199_0": {"length": 7, "quality": 0.875, "section_id": 7684}, "so_23564044_23564720_5": {"length": 33, "quality": 0.868421052631579, "section_id": 6791}, "so_23564044_23564720_2": {"length": 35, "quality": 0.8333333333333334, "section_id": 39}, "so_23564044_23564720_0": {"length": 52, "quality": 0.8813559322033898, "section_id": 7684}}}, "23564199": {"Id": "23564199", "PostTypeId": "2", "Body": "<p>Quote from the C++ standard - comma operator:</p>\n<blockquote>\n<p id=\"so_23564044_23564199_0\">The type and value of the result are the type and value of the right operand</p>\n</blockquote>\n<p>so You get 'nullptr', which is converted to the result, also SUCCESS.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-06-04T09:38:38.077", "Score": "-2", "CreationDate": "2014-05-09T12:04:03.270", "ParentId": "23564044", "CommentCount": "2", "OwnerUserId": "3099147", "LastEditDate": "2014-06-04T09:38:38.077"}, "23564720": {"Id": "23564720", "PostTypeId": "2", "Body": "<p>The second case:</p>\n<pre><code>return result = Result::INSUCCESS, nullptr;\n</code></pre>\n<p>looks like a gcc bug, it appears to be ignoring the left hand side of the comma operator in the context of a return statement, if I change the <code>return</code> statement to this (<em><a href=\"http://coliru.stacked-crooked.com/a/7527b92ab2824807\" rel=\"nofollow\">see it live</a></em>):</p>\n<pre><code>return (printf(\"hello\\n\"), nullptr);\n</code></pre>\n<p>there is no output but if we do this outside of a <code>return</code> statement we get the expected result. It appears to be fixed in <code>4.8</code> but I can reproduce with <code>4.6</code> and <code>4.7</code>.</p>\n<p>If we look at the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>5.18</code> <em>Comma operator</em> it says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_23564044_23564720_0\">A pair of expressions separated by a comma is evaluated left-to-right; the left expression is a discarded value expression (Clause 5).<sup>83</sup> <strong>Every value computation and side effect associated with the left expression is sequenced before every value computation and side effect associated with the right expression</strong>. The type and value of the result are the type and value of the right operand; the result is of the same value category as its right operand, and is a bit-field if its right operand is a glvalue and a bit-field. If the value of the right operand is a temporary (12.2), the result is that temporary.</p>\n</blockquote>\n<p>Regardless, as several people have already mentioned this code is clever but hard to read and therefore will be hard to maintain, splitting this into two lines will work fine. I always like to keep in mind this <a href=\"http://en.wikiquote.org/wiki/Brian_Kernighan\" rel=\"nofollow\">quote from Brian Kernighan</a> (<em>there may be a few other versions of this</em>):</p>\n<blockquote>\n<p id=\"so_23564044_23564720_1\">Everyone knows that debugging is twice as hard as writing a program in the first place. So if you're as clever as you can be when you write it, how will you ever debug it?  </p>\n</blockquote>\n<p>For the first case, the error is valid, if we look at section <code>4.10</code> <em>Pointer conversions</em> which says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_23564044_23564720_2\">A null pointer constant is an <em>integral constant expression (5.19)\n  prvalue of integer type that evaluates to zero</em> <strong>or</strong> <em>a prvalue of type\n  std::nullptr_t</em>. A null pointer constant can be converted to a pointer\n  type; the result is the null pointer value of that type and is\n  distinguishable from every other value of object pointer or function\n  pointer type. Such a conversion is called a null pointer conversion.</p>\n</blockquote>\n<p>the expression:</p>\n<pre><code>result = Result::INSUCCESS, NULL\n</code></pre>\n<p>is not a constant expression since it contains <code>=</code>, what is a constant expression is covered in section <code>5.19</code> <em>Constant expressions</em> and says:</p>\n<blockquote>\n<p id=\"so_23564044_23564720_3\">A conditional-expression is a core constant expression unless it\n  involves one of the following as a potentially evaluated subexpression\n  (3.2) [...]</p>\n</blockquote>\n<p>and includes:</p>\n<blockquote>\n<p id=\"so_23564044_23564720_4\">an assignment or a compound assignment (5.17); or</p>\n</blockquote>\n<p>Using <em>nullptr</em> is okay since it is a prvalue of <em>std::nullptr_t</em>, we can see that from section <code>12.14.7</code> <em>Pointer literals</em> which says:</p>\n<blockquote>\n<p id=\"so_23564044_23564720_5\">The pointer literal is the keyword nullptr. <strong>It is a prvalue of type\n  std::nullptr_t</strong>. [ Note: std::nullptr_t is a distinct type that is\n  neither a pointer type nor a pointer to member type; rather, a prvalue\n  of this type is a null pointer constant and can be converted to a null\n  pointer value or null member pointer value. See 4.10 and4.11.\n  \u2014endnote]</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-06-02T11:50:48.787", "Score": "12", "CreationDate": "2014-05-09T12:30:06.727", "ParentId": "23564044", "CommentCount": "4", "OwnerUserId": "1708801", "LastEditDate": "2014-06-02T11:50:48.787"}, "23564044": {"ViewCount": "462", "Body": "<p>I have the following test code:</p>\n<pre><code>#include &lt;cstdint&gt;\n#include &lt;cassert&gt;\n\nenum class Result : std::uint32_t {SUCCESS = 0, INSUCCESS = 1};\n\nvoid* func(Result&amp; result)\n{\n    // works great\n    /*\n    result = Result::INSUCCESS;\n    return NULL;\n    */\n\n    // error: invalid conversion from \u2018long int\u2019 to \u2018void*\u2019 [-fpermissive]\n    /*\n    return result = Result::INSUCCESS, NULL;\n    */\n\n    // compiles, but &lt;result&gt; is not set???\n    return result = Result::INSUCCESS, nullptr;\n}\n\nvoid testReturnWithSideEffects()\n{\n    Result result = Result::SUCCESS;\n    func(result);\n    assert(result == Result::INSUCCESS);\n}\n</code></pre>\n<p>There are 2 questions here but I'm mostly interested in the second:</p>\n<p>Why is result not set?</p>\n<p>Edit:\nThanks to everyone for confirming this. The work-around that I have decided to use is to replace:</p>\n<pre><code>return result = Result::INSUCCESS, nullptr;\n</code></pre>\n<p>with the following:</p>\n<pre><code>return result = Result::INSUCCESS, (void*)NULL;\n</code></pre>\n<p>Additional note: of course my production scenario is with another pointer type (not void*) but I simplified for illustrative purposes.</p>\n<p>Another note: from the workaround you can tell that there's something fishy going on with that nullptr. I'm guessing that the example line which doesn't compile, should actually compile, and these 2 matters are probably related somehow.</p>\n<p>And a 3rd and final note, to those who outlined the \"trickery\" or \"unreadability\" of my code: readability is largely a subjective matter, for instance I can argue that a shorthand like this can make the code more structured which can actually help spot defects.</p>\n", "AcceptedAnswerId": "23564720", "Title": "No side effect with comma operator, return statement, and nullptr?", "CreationDate": "2014-05-09T11:57:01.317", "Id": "23564044", "CommentCount": "17", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-05-09T14:07:35.960", "LastEditorUserId": "1088790", "LastActivityDate": "2014-06-04T09:38:38.077", "ClosedDate": "2016-02-09T20:15:53.113", "Score": "7", "OwnerUserId": "1088790", "Tags": "<c++><gcc><c++11><comma><nullptr>", "AnswerCount": "3"}, "23564998": {"Id": "23564998", "PostTypeId": "2", "Body": "<p>My test indicates that your code should work. I ran this on compileonline.com:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint func5() {\n    return 5;\n}\n\nint func(int&amp; result) {\n    return result = func5(), 10;\n}\n\nenum class Result : uint32_t {SUCCESS = 0, INSUCCESS = 1};\n\nvoid* func(Result&amp; result)\n{\n    // works great\n    /*\n    result = Result::INSUCCESS;\n    return NULL;\n    */\n\n    // error: invalid conversion from \u2018long int\u2019 to \u2018void*\u2019 [-fpermissive]\n    /*\n    return result = Result::INSUCCESS, NULL;\n    */\n\n    // compiles, but &lt;result&gt; is not set???\n    return result = Result::INSUCCESS, nullptr;\n}\n\nint main()\n{\n    int b = 0;\n    int a = func(b);\n    cout &lt;&lt; a &lt;&lt; \", \" &lt;&lt; b &lt;&lt; endl;\n\n    Result result = Result::SUCCESS;\n    func(result);\n    cout &lt;&lt; uint32_t(result) &lt;&lt; endl;\n\n}\n</code></pre>\n<p>Result:</p>\n<pre><code>Compiling the source code....\n$g++ -std=c++11 main.cpp -o demo -lm -pthread -lgmpxx -lgmp -lreadline 2&gt;&amp;1\n\nExecuting the program....\n$demo \n10, 5\n1\n</code></pre>\n<p>Perhaps you have a bug in your compiler?</p>\n", "LastActivityDate": "2014-05-09T12:44:42.343", "CommentCount": "0", "CreationDate": "2014-05-09T12:44:42.343", "ParentId": "23564044", "Score": "0", "OwnerUserId": "2015579"}});