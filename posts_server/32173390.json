post_cb({"32173517": {"Id": "32173517", "PostTypeId": "2", "Body": "<p>The <code>auto</code> <em>type-specifier</em> serves two related but separate purposes</p>\n<p>[dcl.spec.auto] / 1</p>\n<blockquote>\n<p id=\"so_32173390_32173517_0\">The <code>auto</code> and <code>decltype(auto)</code> <em>type-specifier</em>s are used to\n  designate a placeholder type that will be replaced later by deduction\n  from an initializer. The <code>auto</code> <em>type-specifier</em> is also used to\n  introduce a function type having a <em>trailing-return-type</em> or to\n  signify that a lambda is a generic lambda.</p>\n</blockquote>\n<p>In the case of your static member, the type is determined by the initializer, so <code>x</code> already has type <code>int</code> at the end of its declaration.</p>\n<p>[dcl.spec.auto] / 4</p>\n<blockquote>\n<p id=\"so_32173390_32173517_1\">The type of a variable declared using <code>auto</code> or <code>decltype(auto)</code> is\n  deduced from its initializer.</p>\n</blockquote>\n<p>The rule you mention applies to functions and function templates only, and is unrelated to the use of <code>auto</code> when declaring variables.</p>\n<p>[dcl.spec.auto] / 13</p>\n<blockquote>\n<p id=\"so_32173390_32173517_2\">Redeclarations or specializations of a function or function template\n  with a declared return type that uses a placeholder type shall also\n  use that placeholder, not a deduced type.</p>\n</blockquote>\n", "LastEditorUserId": "657267", "LastActivityDate": "2015-08-24T02:05:53.757", "Score": "2", "CreationDate": "2015-08-24T01:59:02.397", "ParentId": "32173390", "CommentCount": "0", "OwnerUserId": "657267", "LastEditDate": "2015-08-24T02:05:53.757"}, "bq_ids": {"n4140": {"so_32173390_32173517_0": {"length": 18, "quality": 0.72, "section_id": 5445}, "so_32173390_32173517_2": {"length": 16, "quality": 1.0, "section_id": 5457}, "so_32173390_32173517_1": {"length": 9, "quality": 0.9, "section_id": 5448}}, "n3337": {"so_32173390_32173517_1": {"length": 6, "quality": 0.6, "section_id": 5240}}, "n4659": {"so_32173390_32173517_0": {"length": 23, "quality": 0.92, "section_id": 6872}, "so_32173390_32173517_2": {"length": 16, "quality": 1.0, "section_id": 6883}, "so_32173390_32173517_1": {"length": 9, "quality": 0.9, "section_id": 6875}}}, "32173390": {"ViewCount": "727", "Body": "<p>The following code fails to link due to an undefined reference:</p>\n<pre><code>// file.h\nstruct S {\n    static constexpr auto x = 0;\n};\n\n// file.cpp\nint main() {\n    auto const &amp; ref = S::x;\n}\n</code></pre>\n<p>Following the advice of <a href=\"https://stackoverflow.com/questions/14285198/why-doesnt-the-c11-auto-keyword-work-for-static-members\">Why doesn't the C++11 'auto' keyword work for static members?</a>, this seems to work with clang 3.5:</p>\n<pre><code>// file.h\nstruct S {\n    static constexpr auto x = 0;\n};\n\n// file.cpp\nconstexpr decltype(S::x) S::x;\n\nint main() {\n    auto const &amp; ref = S::x;\n}\n</code></pre>\n<p>Is it actually valid C++? This seems to violate the rule of \"auto everywhere or nowhere\" that functions follow (you can forward declare a function that returns auto and then define it to return auto, but you cannot mix auto with non-auto).</p>\n", "AcceptedAnswerId": "32173517", "Title": "Defining static constexpr auto class variable", "CreationDate": "2015-08-24T01:41:26.393", "Id": "32173390", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-08-24T02:05:53.757", "Score": "2", "OwnerUserId": "852254", "Tags": "<c++><c++11><language-lawyer><c++14><auto>", "AnswerCount": "1"}});