post_cb({"32173517": {"ParentId": "32173390", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The <code>auto</code> <em>type-specifier</em> serves two related but separate purposes</p>\n<p>[dcl.spec.auto] / 1</p>\n<blockquote>\n<p id=\"so_32173390_32173517_0\">The <code>auto</code> and <code>decltype(auto)</code> <em>type-specifier</em>s are used to\n  designate a placeholder type that will be replaced later by deduction\n  from an initializer. The <code>auto</code> <em>type-specifier</em> is also used to\n  introduce a function type having a <em>trailing-return-type</em> or to\n  signify that a lambda is a generic lambda.</p>\n</blockquote>\n<p>In the case of your static member, the type is determined by the initializer, so <code>x</code> already has type <code>int</code> at the end of its declaration.</p>\n<p>[dcl.spec.auto] / 4</p>\n<blockquote>\n<p id=\"so_32173390_32173517_1\">The type of a variable declared using <code>auto</code> or <code>decltype(auto)</code> is\n  deduced from its initializer.</p>\n</blockquote>\n<p>The rule you mention applies to functions and function templates only, and is unrelated to the use of <code>auto</code> when declaring variables.</p>\n<p>[dcl.spec.auto] / 13</p>\n<blockquote>\n<p id=\"so_32173390_32173517_2\">Redeclarations or specializations of a function or function template\n  with a declared return type that uses a placeholder type shall also\n  use that placeholder, not a deduced type.</p>\n</blockquote>\n", "OwnerUserId": "657267", "LastEditorUserId": "657267", "LastEditDate": "2015-08-24T02:05:53.757", "Id": "32173517", "Score": "2", "CreationDate": "2015-08-24T01:59:02.397", "LastActivityDate": "2015-08-24T02:05:53.757"}, "32173390": {"CommentCount": "2", "ViewCount": "727", "CreationDate": "2015-08-24T01:41:26.393", "LastActivityDate": "2015-08-24T02:05:53.757", "Title": "Defining static constexpr auto class variable", "AcceptedAnswerId": "32173517", "PostTypeId": "1", "Id": "32173390", "Score": "2", "Body": "<p>The following code fails to link due to an undefined reference:</p>\n<pre><code>// file.h\nstruct S {\n    static constexpr auto x = 0;\n};\n\n// file.cpp\nint main() {\n    auto const &amp; ref = S::x;\n}\n</code></pre>\n<p>Following the advice of <a href=\"https://stackoverflow.com/questions/14285198/why-doesnt-the-c11-auto-keyword-work-for-static-members\">Why doesn't the C++11 'auto' keyword work for static members?</a>, this seems to work with clang 3.5:</p>\n<pre><code>// file.h\nstruct S {\n    static constexpr auto x = 0;\n};\n\n// file.cpp\nconstexpr decltype(S::x) S::x;\n\nint main() {\n    auto const &amp; ref = S::x;\n}\n</code></pre>\n<p>Is it actually valid C++? This seems to violate the rule of \"auto everywhere or nowhere\" that functions follow (you can forward declare a function that returns auto and then define it to return auto, but you cannot mix auto with non-auto).</p>\n", "Tags": "<c++><c++11><language-lawyer><c++14><auto>", "OwnerUserId": "852254", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_32173390_32173517_1": {"section_id": 5448, "quality": 0.9, "length": 9}, "so_32173390_32173517_0": {"section_id": 5445, "quality": 0.72, "length": 18}, "so_32173390_32173517_2": {"section_id": 5457, "quality": 1.0, "length": 16}}, "n3337": {"so_32173390_32173517_1": {"section_id": 5240, "quality": 0.6, "length": 6}}, "n4659": {"so_32173390_32173517_1": {"section_id": 6875, "quality": 0.9, "length": 9}, "so_32173390_32173517_0": {"section_id": 6872, "quality": 0.92, "length": 23}, "so_32173390_32173517_2": {"section_id": 6883, "quality": 1.0, "length": 16}}}});