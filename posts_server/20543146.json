post_cb({"20543146": {"CommentCount": "0", "ViewCount": "572", "PostTypeId": "1", "LastEditorUserId": "1607442", "CreationDate": "2013-12-12T12:09:13.607", "LastActivityDate": "2013-12-12T12:27:52.773", "Title": "gcc error when declaring reference to reference type", "AcceptedAnswerId": "20543284", "LastEditDate": "2013-12-12T12:15:59.690", "Id": "20543146", "Score": "1", "Body": "<p>In the OpenCV library there is a </p>\n<pre><code>typedef const _InputArray&amp; InputArray;\n</code></pre>\n<p>In our code we have the following function definition:  </p>\n<pre><code>void wimshow(const String&amp; winName, InputArray &amp;img) {\n</code></pre>\n<p>When compiling this the following error occurs:</p>\n<p><code>error: cannot declare reference to 'cv::InputArray {aka const class cv::_InputArray&amp;}'\n void wimshow(const String&amp; winName, InputArray &amp;img) {</code> </p>\n<p>The weird thing is that this error only occurs using GCC 4.8.1 in the Cray environment.  Compiling in a normal Linux environment with GCC 4.8.1 works without errors.<br>\nAt first glance I would say that a reference to a reference type is not very meaningful anyway but I am curious about what could cause the different compiler behavior!?</br></p>\n", "Tags": "<c++><compiler-errors><gcc4.8><cray>", "OwnerUserId": "909595", "AnswerCount": "2"}, "20543284": {"ParentId": "20543146", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2013-12-12T12:15:08.613", "Score": "5", "LastEditorUserId": "560648", "LastEditDate": "2013-12-12T12:27:52.773", "Id": "20543284", "OwnerUserId": "560648", "Body": "<p><strong>This appears to be a C++03/C++11 difference.</strong></p>\n<p>In C++11, the extra <code>&amp;</code> (and the <code>const</code>, incidentally) are supposed to be ignored:</p>\n<blockquote>\n<p id=\"so_20543146_20543284_0\"><code>[C++11: 8.3.2/6]:</code> <strong>If a typedef (7.1.3)</strong>, a type template-parameter (14.3.1), or a decltype-specifier (7.1.6.2) <strong>denotes a type <code>TR</code> that is a reference to a type <code>T</code>, an attempt to create the type \u201clvalue reference to <em>cv</em> <code>TR</code>\u201d creates the type \u201clvalue reference to <code>T</code>\u201d</strong>, while an attempt to create the type \u201crvalue reference to <em>cv</em> <code>TR</code>\u201d creates the type <code>TR</code>.</p>\n<p id=\"so_20543146_20543284_1\"><em>[ Example:</em></p>\n<pre><code>int i;\ntypedef int&amp; LRI;\ntypedef int&amp;&amp; RRI;\nLRI&amp; r1 = i;           // r1 has the type int&amp;\nconst LRI&amp; r2 = i;     // r2 has the type int&amp;\nconst LRI&amp;&amp; r3 = i;    // r3 has the type int&amp;\nRRI&amp; r4 = i;           // r4 has the type int&amp;\nRRI&amp;&amp; r5 = 5;          // r5 has the type int&amp;&amp;\ndecltype(r2)&amp; r6 = i;  // r6 has the type int&amp;\ndecltype(r2)&amp;&amp; r7 = i; // r7 has the type int&amp;\n</code></pre>\n<p id=\"so_20543146_20543284_2\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p>The pertinent example here is <code>r1</code>; although <code>typedef int&amp; LRI</code> isn't precisely like your <code>typedef</code>, the example is equivalent due to the following passage having already dropped your <code>const</code>:</p>\n<blockquote>\n<p id=\"so_20543146_20543284_3\"><code>[C++11: 8.3.2/1]:</code> <em>[..]</em> Cv-qualified references are ill-formed except when the cv-qualifiers are introduced through the use of a typedef (7.1.3) or of a template type argument (14.3), in which case the cv-qualifiers are ignored. <em>[..]</em></p>\n</blockquote>\n<p>However, the <code>[C++11: 8.3.2/6]</code> wording does not exist in C++03! In fact, we can compare behaviours between the two languages with the following example program:</p>\n<pre><code>struct T1 {};\n\ntypedef T1&amp; T2;\n\nint main()\n{\n    T1 x;\n    T2&amp; t = x;\n}\n</code></pre>\n<ul>\n<li><a href=\"http://coliru.stacked-crooked.com/a/3e1bff21309be824\" rel=\"nofollow\">Output in C++03</a>: <code>error: cannot declare reference to 'T2 {aka struct T1&amp;}'</code></li>\n<li><a href=\"http://coliru.stacked-crooked.com/a/066c5f612cce93fb\" rel=\"nofollow\">Output in C++11</a>: nothing!</li>\n</ul>\n<p><sup>(ignoring warnings about unused variables)</sup></p>\n<p>So, check your compilation flags on each platform to ensure that you're using the same language on both. It may be that the default on the Cray is C++03, but the default on your platform is C++11. Use the <code>-std=c++03</code>/<code>-std=c++11</code> flag to state which to use explicitly.</p>\n", "LastActivityDate": "2013-12-12T12:27:52.773"}, "bq_ids": {"n4140": {"so_20543146_20543284_0": {"section_id": 3223, "quality": 0.7333333333333333, "length": 22}, "so_20543146_20543284_3": {"section_id": 3218, "quality": 0.6, "length": 12}}, "n3337": {"so_20543146_20543284_0": {"section_id": 3097, "quality": 0.8333333333333334, "length": 25}, "so_20543146_20543284_3": {"section_id": 3092, "quality": 0.8, "length": 16}}, "n4659": {"so_20543146_20543284_0": {"section_id": 3980, "quality": 0.7333333333333333, "length": 22}, "so_20543146_20543284_3": {"section_id": 3975, "quality": 0.6, "length": 12}}}, "20543408": {"ParentId": "20543146", "CommentCount": "1", "CreationDate": "2013-12-12T12:20:03.603", "OwnerUserId": "1312406", "PostTypeId": "2", "Id": "20543408", "Score": "1", "Body": "<p>References to references (as <code>const const</code>) are supposed to be ignored to make meta-template programming easier,  So the error you're seeing on the Cray system is a bug.</p>\n", "LastActivityDate": "2013-12-12T12:20:03.603"}});