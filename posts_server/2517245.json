post_cb({"2517321": {"ParentId": "2517245", "CommentCount": "0", "Body": "<p>Calling a virtual method or a non-virtual method are two totally different things.</p>\n<p>If you call a non-virtual method, the compiler has to generate code that does this:</p>\n<ul>\n<li>put all the arguments on the stack</li>\n<li>call the function and tell the linker that it should resolve the call</li>\n</ul>\n<p>Since we're talking about the destructor, there are no arguments to put on the stack, so it looks like we can simply do the call and tell the linker to resolve the call.  No prototype needed.</p>\n<p>However, calling a virtual method is totally different:</p>\n<ul>\n<li>put all the arguments on the stack</li>\n<li>get the vptr of the instance</li>\n<li>get the n'th entry from the vtable</li>\n<li>call the function to which this n'th entry points</li>\n</ul>\n<p>This is totally different so the compiler really has to know whether you are calling a virtual or non-virtual method.</p>\n<p>The second important thing is that the compiler needs to know on which position the virtual method is found in the vtable.  For this, it also needs to have the full definition of the class.</p>\n", "OwnerUserId": "163551", "PostTypeId": "2", "Id": "2517321", "Score": "5", "CreationDate": "2010-03-25T16:23:55.257", "LastActivityDate": "2010-03-25T16:23:55.257"}, "2517513": {"ParentId": "2517245", "CommentCount": "1", "Body": "<p>This is really just a special case of calling a method (the destructor, indirectly). delete impl_ effectively just calls the destructor and then the appropriate operator delete (global or class). You can't call any <em>other</em> function on an incomplete type, so why would delete's call to the destructor be given special treatment?</p>\n<p>The part I'm unsure about is what complication causes the standard to make it undefined instead of just forbidding it as in the method call.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "2517513", "Score": "1", "CreationDate": "2010-03-25T16:45:30.733", "LastActivityDate": "2010-03-25T16:45:30.733"}, "2517334": {"ParentId": "2517245", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Without proper declaration of <code>Body</code> the code in <code>Handle.h</code> does not know whether destructor is <code>virtual</code> or even accessible (i.e. public).</p>\n", "OwnerUserId": "106671", "LastEditorUserId": "106671", "LastEditDate": "2010-03-25T17:15:13.543", "Id": "2517334", "Score": "3", "CreationDate": "2010-03-25T16:25:32.273", "LastActivityDate": "2010-03-25T17:15:13.543"}, "2517304": {"ParentId": "2517245", "CommentCount": "0", "Body": "<p>I'm just guessing, but perhaps it has to do with the ability of per-class allocation operators.</p>\n<p>That is:</p>\n<pre><code>struct foo\n{\n    void* operator new(size_t);\n    void operator delete(void*);\n};\n\n// in another header, like your example\n\nstruct foo;\n\nstruct bar\n{\n    bar();\n    ~bar() { delete myFoo; }\n\n    foo* myFoo;\n};\n\n// in translation unit\n\n#include \"bar.h\"\n#include \"foo.h\"\n\nbar::bar() :\nmyFoo(new foo) // uses foo::operator new\n{}\n\n// but destructor uses global...!!\n</code></pre>\n<p>And now we've mismatched the allocation operators, and entered undefined behavior. The only way to guarantee that can't happen is to say \"make the type complete\". Otherwise, it's impossible to ensure.</p>\n", "OwnerUserId": "87234", "PostTypeId": "2", "Id": "2517304", "Score": "2", "CreationDate": "2010-03-25T16:22:09.037", "LastActivityDate": "2010-03-25T16:22:09.037"}, "2517455": {"ParentId": "2517245", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>To combine several answers and add my own, without a class definition the calling code doesn't know:</p>\n<ul>\n<li>whether the class has a declared destructor, or if the default destructor is to be used, and if so whether the default destructor is trivial,</li>\n<li>whether the destructor is accessible to the calling code,</li>\n<li>what base classes exist and have destructors,</li>\n<li>whether the destructor is virtual. Virtual function calls in effect use a different calling convention from non-virtual ones. The compiler can't just \"emit the code to call ~Body\", and leave the linker to work out the details later,</li>\n<li>(this just in, thanks GMan) whether <code>delete</code> is overloaded for the class.</li>\n</ul>\n<p>You can't call any member function on an incomplete type for some or all of those reasons (plus another that doesn't apply to destructors - you wouldn't know the parameters or return type). A destructor is no different. So I'm not sure what you mean when you say \"why can't it do as it always does?\".</p>\n<p>As you already know, the solution is to define the destructor of <code>Handle</code> in the TU which has the definition of <code>Body</code>, same place as you define every other member function of <code>Handle</code> which calls functions or uses data members of <code>Body</code>. Then at the point where <code>delete impl_;</code> is compiled, all the information is available to emit the code for that call.</p>\n<p>Note that the standard actually says, 5.3.5/5: </p>\n<blockquote>\n<p id=\"so_2517245_2517455_0\">if the object being deleted has\n  incomplete class type at the point of\n  deletion and the complete class has a\n  non-trivial destructor or a\n  deallocation function, the behavior is\n  undefined.</p>\n</blockquote>\n<p>I presume this is so that you can delete an incomplete POD type, same as you could <code>free</code> it in C. g++ gives you a pretty stern warning if you try it, though.</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2010-03-25T17:14:23.063", "Id": "2517455", "Score": "24", "CreationDate": "2010-03-25T16:38:42.403", "LastActivityDate": "2010-03-25T17:14:23.063"}, "2517346": {"ParentId": "2517245", "CommentCount": "0", "Body": "<p>It doesn't know whether the destructor will be public or not. </p>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "2517346", "Score": "6", "CreationDate": "2010-03-25T16:27:09.773", "LastActivityDate": "2010-03-25T16:27:09.773"}, "2517245": {"CommentCount": "0", "AcceptedAnswerId": "2517455", "PostTypeId": "1", "LastEditorUserId": "2246344", "CreationDate": "2010-03-25T16:13:49.490", "LastActivityDate": "2014-08-12T09:22:15.570", "LastEditDate": "2014-08-12T09:22:15.570", "ViewCount": "6368", "FavoriteCount": "4", "Title": "Why, really, deleting an incomplete type is undefined behaviour?", "Id": "2517245", "Score": "25", "Body": "<p>Consider this classic example used to explain what <em>not</em> to do with forward declarations:</p>\n<pre><code>//in Handle.h file\nclass Body;\n\nclass Handle\n{\n   public:\n      Handle();\n      ~Handle() {delete impl_;}\n   //....\n   private:\n      Body *impl_;\n};\n\n//---------------------------------------\n//in Handle.cpp file\n\n#include \"Handle.h\"\n\nclass Body \n{\n  //Non-trivial destructor here\n    public:\n       ~Body () {//Do a lot of things...}\n};\n\nHandle::Handle () : impl_(new Body) {}\n\n//---------------------------------------\n//in Handle_user.cpp client code:\n\n#include \"Handle.h\"\n\n//... in some function... \n{\n    Handle handleObj;\n\n    //Do smtg with handleObj...\n\n    //handleObj now reaches end-of-life, and BUM: Undefined behaviour\n} \n</code></pre>\n<p>I understand from the standard that this case is headed towards UB since Body's destructor is non trivial.\nWhat I'm trying to understand is really the root cause of this.</p>\n<p>I mean, the problem seems to be \"triggered\" by the fact that Handle's dtor is inline, and so the compiler does something like the following \"inline expansion\" (almost pseudo-code here).</p>\n<pre><code>inline Handle::~Handle()\n{\n     impl_-&gt;~Body();\n     operator delete (impl_);\n}\n</code></pre>\n<p>In all translation units (only <code>Handle_user.cpp</code> in this case) where a Handle instance gets to be destroyed, right?\nI just can't understand this: ok, when generating the above inline expansion the compiler doesn't have a full definition of the Body class, but why cannot it simply have the linker resolve for the <code>impl_-&gt;~Body()</code> thing and so have it call the Body's destructor function that's actually defined in its implementation file?</p>\n<p>In other words: I understand that at the point of Handle destruction the compiler doesn't even know if a (non-trivial) destructor exists or not for Body, but why can't it do as it always does, that is leave a \"placeholder\" for the linker to fill in, and eventually have a linker \"unresolved external\" if that function is really not available?</p>\n<p>Am I missing something big here (and in that case sorry for the stupid question)?\nIf that's not the case, I'm just curious to understand the rationale behind this.</p>\n", "Tags": "<c++><memory-management><destructor><forward-declaration><delete-operator>", "OwnerUserId": "41789", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_2517245_2517455_0": {"section_id": 6109, "quality": 1.0, "length": 16}}, "n3337": {"so_2517245_2517455_0": {"section_id": 5875, "quality": 1.0, "length": 16}}, "n4659": {"so_2517245_2517455_0": {"section_id": 7606, "quality": 1.0, "length": 16}}}});