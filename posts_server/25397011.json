post_cb({"25397133": {"ParentId": "25397011", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2014-08-20T05:15:05.150", "Score": "4", "LastEditorUserId": "241631", "LastEditDate": "2014-08-20T18:11:47.770", "Id": "25397133", "OwnerUserId": "241631", "Body": "<p>Yes, the standard guarantees that implicit instantiation of a class template only causes implicit instantiation of the declarations, and not definitions of the member functions.</p>\n<p><em>\u00a714.7.1 [temp.inst]</em></p>\n<blockquote>\n<p id=\"so_25397011_25397133_0\"><em>1</em> \u00a0 <code>...</code> <strong>The implicit instantiation of a class template specialization causes the implicit\n  instantiation of the declarations, but not of the definitions</strong>, default arguments, or exception-specifications <strong>of the class member functions</strong>, member classes, scoped member enumerations, static data members and member templates; and it causes the implicit instantiation of the definitions of unscoped member enumerations and member anonymous unions. </p>\n<p id=\"so_25397011_25397133_1\"><em>11</em> \u00a0 <strong>An implementation shall not implicitly instantiate</strong> a function template, a variable template, a member template, <strong>a non-virtual member function</strong>, a member class, or a static data member <strong>of a class template that does not require instantiation</strong>.<code>...</code></p>\n</blockquote>\n<p>Note that your code will fail to compile whether you use <code>operator+</code> or not if you <em>explicitly instantiate</em> the class</p>\n<pre><code>template class IteratorIterable&lt;std::list&lt;int&gt;&gt;;\n</code></pre>\n<p>You can prevent that by using <code>enable_if</code> to SFINAE the member function from the overload set unless <code>BackendIterator</code> is a random access iterator.</p>\n<pre><code>template&lt;typename Iter = BackendIterator&gt;\ntypename std::enable_if&lt;\n    std::is_same&lt;typename std::iterator_traits&lt;Iter&gt;::iterator_category,\n                 std::random_access_iterator_tag&gt;::value,\n    IteratorIterator&gt;::type\noperator+(size_t n) \n{\n    return IteratorIterator(it + n); \n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/8f6ed94b19edbc34\" rel=\"nofollow\">Live demo</a></p>\n", "LastActivityDate": "2014-08-20T18:11:47.770"}, "25397051": {"ParentId": "25397011", "CommentCount": "0", "CreationDate": "2014-08-20T05:06:38.163", "OwnerUserId": "4323", "PostTypeId": "2", "Id": "25397051", "Score": "1", "Body": "<p>Yes, it's fine.  <a href=\"http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error\" rel=\"nofollow\">Substitution failure is not an error (SFINAE)</a>.</p>\n", "LastActivityDate": "2014-08-20T05:06:38.163"}, "25397011": {"CommentCount": "0", "ViewCount": "83", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-08-20T05:03:11.453", "LastActivityDate": "2014-08-20T18:11:47.770", "Title": "Instantiate a class template with an invalid method", "AcceptedAnswerId": "25397133", "LastEditDate": "2017-05-23T10:33:24.390", "Id": "25397011", "Score": "1", "Body": "<p>I'm writing a class <code>IteratorIterable</code> that wraps a container class (a class with <code>begin()</code> and <code>end()</code> methods returning some iterators) to make it possible to iterate <em>over the iterators of the wrapped class</em>. The idea is based on <a href=\"https://stackoverflow.com/a/14920606/1566841\">this post</a>. My code looks like this (some methods left out for brevity):</p>\n<pre><code>template &lt;class T&gt;\nclass IteratorIterable\n{\nprivate:\n    T&amp; container;\n\npublic:\n    typedef decltype(container.begin()) BackendIterator;\n\npublic:\n    class IteratorIterator\n    {\n    public:\n        IteratorIterator() : it() {}\n        IteratorIterator(BackendIterator it) : it(it) {}\n        IteratorIterator(const IteratorIterator&amp; other) : it(other.it) {}\n\n        IteratorIterator&amp; operator=(const IteratorIterator&amp; other) { if (&amp;other == this) return *this; it = other.it; return *this; }\n\n        BackendIterator operator*() const { return it; }\n        const BackendIterator* operator-&gt;() const { return &amp;it; }\n\n        bool operator==(const IteratorIterator&amp; other) { return it == other.it; }\n        bool operator !=(const IteratorIterator&amp; other) { return it != other.it; }\n\n        IteratorIterator operator+(size_t n) { return IteratorIterator(it + n); }\n\n        IteratorIterator&amp; operator++() { ++it; return *this; }\n        IteratorIterator operator++(int) { IteratorIterator cpy(*this); ++(*this); return cpy; }\n\n    private:\n        BackendIterator it;\n    };\n\npublic:\n    IteratorIterable(T&amp; container) : container(container) {}\n\n    IteratorIterator begin() const { return IteratorIterator(container.begin()); }\n    IteratorIterator end() const { return IteratorIterator(container.end()); }\n};\n\n\ntemplate &lt;class T&gt;\nIteratorIterable&lt;T&gt; ItIt(T&amp; container)\n{\n    return IteratorIterable&lt;T&gt;(container);\n}\n</code></pre>\n<p>The problem here is, the <code>operator+()</code> method in <code>IteratorIterator</code> is only valid for a random-access <code>BackendIterator</code>, because otherwise the addition operator is not defined on the backend. I want my IteratorIterator to provide this method only if the backend supports it.</p>\n<p>Consider this example code:</p>\n<pre><code>typedef list&lt;int&gt; Cont;\n\nCont vec = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n\nIteratorIterable&lt;Cont&gt; itb(vec);\n\nIteratorIterable&lt;Cont&gt;::IteratorIterator beg = itb.begin();\nIteratorIterable&lt;Cont&gt;::IteratorIterator it = beg;\n\nit++;\n//it = beg+1;\n\nprintf(\"%d\\n\", **it);\n</code></pre>\n<p>This compiles fine when using the <code>it++</code> line, but - as expected - fails with the <code>it = beg+1</code> line, because <code>list&lt;int&gt;::iterator</code> is not random-access. I guess this is because if I don't actually <em>instantiate</em> <code>IteratorIterator::operator+()</code>, the compiler doesn't care.</p>\n<p>I know that templates are allowed to be valid only for some template arguments, but here the <em>class</em> is templated, not the <em>method</em>. Is it correct to instantiate a class template where one of the methods is invalid when that method is never used for this particular instantiation? GCC and Clang don't complain, but is it correct as per the C++ standard?</p>\n", "Tags": "<c++><templates><c++11>", "OwnerUserId": "1566841", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_25397011_25397133_0": {"section_id": 233, "quality": 0.9736842105263158, "length": 37}, "so_25397011_25397133_1": {"section_id": 243, "quality": 1.0, "length": 22}}, "n3337": {"so_25397011_25397133_0": {"section_id": 226, "quality": 0.9473684210526315, "length": 36}, "so_25397011_25397133_1": {"section_id": 235, "quality": 0.9090909090909091, "length": 20}}, "n4659": {"so_25397011_25397133_0": {"section_id": 243, "quality": 0.9473684210526315, "length": 36}, "so_25397011_25397133_1": {"section_id": 250, "quality": 0.9090909090909091, "length": 20}}}});