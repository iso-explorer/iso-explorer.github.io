post_cb({"8070241": {"ParentId": "8069717", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2011-11-09T19:11:35.903", "Score": "0", "LastEditorUserId": "459640", "LastEditDate": "2011-11-10T02:33:35.303", "Id": "8070241", "OwnerUserId": "459640", "Body": "<p>Everyone else has covered this pretty well, but just to show the variants in one place:</p>\n<pre><code>int x;                    // #1\n</code></pre>\n<p>is a declaration and definition.  The initial value of <code>x</code> is zero.</p>\n<pre><code>int x = 3;                // #2\n</code></pre>\n<p>is a declaration and definition.</p>\n<pre><code>const int cx;             // #3\n</code></pre>\n<p>is illegal in C++.</p>\n<pre><code>const int cx = 3;         // #4\n</code></pre>\n<p>is a declaration and definition, but <code>cx</code> has internal linkage if this is its first declaration in the translation unit.</p>\n<pre><code>extern int x;             // #5\n</code></pre>\n<p>is a declaration but NOT a definition.  There must be a definition of <code>x</code> somewhere else in the program.</p>\n<pre><code>extern int x = 3;         // #6\n</code></pre>\n<p>is a declaration and a definition.  The <code>extern</code> is unnecessary, but makes things clear.</p>\n<pre><code>extern const int cx;      // #7\n</code></pre>\n<p>is a declaration but NOT a definition.  There must be a definition of <code>cx</code> somewhere else in the program.</p>\n<pre><code>extern const int cx = 3;  // #8\n</code></pre>\n<p>is a declaration and a definition.  The <code>extern</code> is needed unless the previous declaration above was already seen.</p>\n", "LastActivityDate": "2011-11-10T02:33:35.303"}, "8069717": {"CommentCount": "9", "ViewCount": "441", "PostTypeId": "1", "LastEditorUserId": "230884", "CreationDate": "2011-11-09T18:27:23.590", "LastActivityDate": "2011-11-10T02:33:35.303", "Title": "Under what circumstances can an extern variable be used in definition?", "LastEditDate": "2011-11-10T01:34:40.657", "Id": "8069717", "Score": "2", "Body": "<p>I am very very sorry. I didn't know my incomplete code attachment would create such a mess. I am very glad to see so many sincere helps. </p>\n<p>This code will compile:</p>\n<pre><code>int myadd(int, int);\nstatic int main_stat = 5;\n\nint main()\n{\n    int i, j;\n    main_stat = 13;\n    j = myadd(-1,7);\n    i = main_stat;\n\n    cout &lt;&lt; j &lt;&lt; i;     //  3  and 13\n    return 0;\n\n}\n</code></pre>\n<p>myadd.cpp</p>\n<pre><code>extern int main_stat = -3;\nint myadd(int x,int y)\n{\n    int t = main_stat;\n    t = x + y;\n    y = t +main_stat;\n    return y;    // will return 3\n}\n</code></pre>\n<p>See I defined and extern linking main_stat. Why is that legal? I thought you could only link and not define. </p>\n<p>Is storage allocated in the stack frame of myadd function call? Global static are allocated on heap, I believe, right?</p>\n<hr>\n<h2>EDIT</h2>\n<p>I am sorry, but I think this time I will narrow down my questions:</p>\n<p>From C++ Primer 4ed</p>\n<blockquote>\n<p id=\"so_8069717_8069717_0\">An <strong>extern</strong> declaration may include an initializer (when combined\n  becomes definition) only if it appears outside a function.</p>\n</blockquote>\n<p>I am clear about one-definition rule. </p>\n<p>Q1. Which copy of main_stat does myadd(int,int) uses when it is called? The same copy as the main has, but with a different value (which I can test) ? Or does each function has its own static global copy?</p>\n<p>Q2. Is memory allocated on the heap for these global static variables? I know many things are up to implementation, but isn't heap used for static variables? </p>\n<p>Q3. I know the followings two are valid</p>\n<pre><code>extern int x;    // means int x is defined elsewhere\nextern int x = 3;  // declared and defined \n</code></pre>\n<p>Why do we want the second one if we can just declare a static global variable within the namespace of myadd ? How does it <strong><em>make things clear</em></strong> like aschepler said? </p>\n</hr>", "Tags": "<c++><variables><memory-management><extern>", "OwnerUserId": "230884", "AnswerCount": "6"}, "8069902": {"ParentId": "8069717", "CommentCount": "2", "CreationDate": "2011-11-09T18:43:45.810", "OwnerUserId": "187690", "PostTypeId": "2", "Id": "8069902", "Score": "2", "Body": "<p>The question apparently stems from some misconception.</p>\n<p>Some people believe that <code>extern</code> keyword always turns a definition into a non-defining declaration. This is simply not true. </p>\n<p>The keyword <code>extern</code> simply gives the declared entity <em>external linkage</em>. It can be applied to <em>declarations</em>. It can be applied to <em>definitions</em> (and remember that definitions are <em>declarations</em> as well).</p>\n<p>So, saying that one can't define an <code>extern</code> entity is absolutely incorrect. One can. There's no problem with that at all.</p>\n<p>The confusion is usually caused by the fact that when you apply <code>extern</code> to a definition like</p>\n<pre><code>int x; // no initializer\n</code></pre>\n<p>that definition suddenly turns into a non-defining declaration. This is true, but this is is no more than a one-off quirk of <code>extern</code> keyword that has to be remembered. If you take a definition like</p>\n<pre><code>int x = 42;\n</code></pre>\n<p>then applying the <code>extern</code> keyword to it will still preserve it as a definition, i.e. no quirks in this case.</p>\n", "LastActivityDate": "2011-11-09T18:43:45.810"}, "8069899": {"ParentId": "8069717", "CommentCount": "9", "CreationDate": "2011-11-09T18:43:37.460", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "8069899", "Score": "9", "Body": "<p>All variable declarations with an initializer are also definitions;\nthat's an overriding rule.  Regardless of <code>extern</code>.  There are even\ncases where you need an <code>extern</code> on a definition: you can only\ninstantiate a template using a variable which has external linkage.  And \n<code>const</code> variables have internal linkage by default, so you need\nsomething like:</p>\n<pre><code>extern int const i = 42;\n</code></pre>\n<p>if you want to use it to instantiate a <code>template&lt;int const*&gt;</code>.</p>\n", "LastActivityDate": "2011-11-09T18:43:37.460"}, "8069974": {"ParentId": "8069717", "CommentCount": "3", "CreationDate": "2011-11-09T18:48:38.393", "OwnerUserId": "1032073", "PostTypeId": "2", "Id": "8069974", "Score": "1", "Body": "<p>First, according to your comment, the file containing the main function has the definition <code>static int main_stat = 10;</code>. You should be aware that this is <code>not</code> the same variable as you defined in the file containing <code>myadd</code> because as static variable its scope is restricted to that file. Indeed, thanks to that static variable with the same name, <code>main</code> is not able to access the variable you defined in this file.</p>\n<p>But that doesn't mean that either variable was created on the stack. Both are separate global variables, it's just that the variable <code>main_stat</code> in the file containing <code>main</code> (I'll call that file main file for short, and this one myadd file) is not available in any other file, while the variable <code>main_stat</code> you defined here can be accessed from any file which contains the declaration <code>extern main_stat;</code> (note: without initializer!). The main file cannot contain this declaration, however, because it would conflict with the static variable of the same name.</p>\n<p>Note that giving an initializer makes your declaration of the variable a definition, that is, it's the same as if you had omitted the extern (note however that if a variable is declared constant, the extern may not be omitted because constants are by default static). The only global extern declarations which are not also definitions are those <em>with</em> extern, but <em>without</em> initializer.</p>\n", "LastActivityDate": "2011-11-09T18:48:38.393"}, "8069831": {"ParentId": "8069717", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-11-09T18:38:22.113", "Score": "3", "LastEditorUserId": "560648", "LastEditDate": "2011-11-09T18:46:22.300", "Id": "8069831", "OwnerUserId": "560648", "Body": "<p>The following is a declaration <em>and</em> definition:</p>\n<pre><code>int x;\n</code></pre>\n<p>Adding <code>extern</code> says \"make it a declaration only, please\".</p>\n<p>But when you are providing a value, the line <em>has</em> to be a definition, so the variable gets <code>extern</code> storage class and you just happen to be defining it right in place anyway:</p>\n<pre><code>extern int x = 3;\n</code></pre>\n<p>The linkage semantics are as they usually are for <code>extern</code>, and the storage location is just as it would be for a normal definition <code>int x = 3</code> \u2014 i.e. in that TU at namespace scope. <code>myadd</code> is not relevant at all.</p>\n<hr>\n<p>It's a hard one to \"prove\", because it's a case of \"there's no rule against it\".</p>\n<p>Here's the best quote:</p>\n<blockquote>\n<p id=\"so_8069717_8069831_0\"><code>[n3290: 3.1/2]:</code> <strong>A declaration is a definition unless it</strong> declares\n  a function without specifying the function\u2019s body (8.4), it\n  <strong>contains the <code>extern</code> specifier</strong> (7.1.1) or a linkage-specification25 (7.5) <strong>and neither an initializer nor a\n  <em>function-body</em></strong>, [..]</p>\n</blockquote>\n<p>And some other pertinent information:</p>\n<blockquote>\n<p id=\"so_8069717_8069831_1\"><code>[n3290: 3.5/2]:</code> A name is said to have <em>linkage</em> when it might denote the same object, reference, function, type, template, namespace or value as a name introduced by a declaration in another scope:</p>\n<ul>\n<li><strong>When a name has <em>external linkage</em>, the entity it denotes can be referred to by names from scopes of other translation units or from other scopes of the same translation unit.</strong></li>\n<li>When a name has <em>internal linkage</em>, the entity it denotes can be referred to by names from other scopes in the same translation unit.</li>\n<li>When a name has no <em>linkage</em>, the entity it denotes cannot be referred to by names from other scopes.</li>\n</ul>\n<p id=\"so_8069717_8069831_2\"><code>[n3290: 3.5/12]:</code>The name of a function declared in block scope and the name of a variable declared by a block scope <code>extern</code> declaration\n  have linkage. If there is a visible declaration of an entity with\n  linkage having the same name and type, ignoring entities declared\n  outside the innermost enclosing namespace scope, the block scope\n  declaration declares that same entity and receives the linkage of the\n  previous declaration. If there is more than one such matching entity,\n  the program is ill-formed. Otherwise, if no matching entity is found,\n  the block scope entity receives external linkage. [..]</p>\n</blockquote>\n</hr>", "LastActivityDate": "2011-11-09T18:46:22.300"}, "bq_ids": {"n4140": {"so_8069717_8069831_2": {"section_id": 7139, "quality": 0.9672131147540983, "length": 59}, "so_8069717_8069831_0": {"section_id": 7034, "quality": 0.7222222222222222, "length": 13}, "so_8069717_8069831_1": {"section_id": 7135, "quality": 0.8636363636363636, "length": 19}}, "n3337": {"so_8069717_8069831_2": {"section_id": 6883, "quality": 0.9672131147540983, "length": 59}, "so_8069717_8069831_0": {"section_id": 6780, "quality": 0.7222222222222222, "length": 13}, "so_8069717_8069831_1": {"section_id": 6879, "quality": 0.8636363636363636, "length": 19}}, "n4659": {"so_8069717_8069831_2": {"section_id": 8640, "quality": 0.9672131147540983, "length": 59}, "so_8069717_8069831_0": {"section_id": 8531, "quality": 0.7222222222222222, "length": 13}, "so_8069717_8069831_1": {"section_id": 8636, "quality": 0.8636363636363636, "length": 19}}}, "8069758": {"ParentId": "8069717", "PostTypeId": "2", "CommentCount": "10", "CreationDate": "2011-11-09T18:32:17.820", "Score": "2", "LastEditorUserId": "452307", "LastEditDate": "2011-11-09T18:40:42.263", "Id": "8069758", "OwnerUserId": "452307", "Body": "<pre><code>extern int main_stat=-3;  \n</code></pre>\n<p>declares and defines <code>main_stat</code>, While:  </p>\n<pre><code>extern int main_stat;      \n</code></pre>\n<p>just declares the variable <code>main_stat</code>.   </p>\n<p>You can have as many declarations as you want but you can have only one Definition.    </p>\n<p>The keyword <code>extern</code>, indicates External Linkage. Without it <code>main_stat</code> would be static and have Internal linkage and you cannot not use <code>main_stat</code> from another translation unit.</p>\n<blockquote>\n<p id=\"so_8069717_8069758_0\">Is storage allocated in the stack frame of myadd ?   </p>\n</blockquote>\n<p>No definitely not on the stackframe of <code>add</code>.<br>\nWhere the memory is allocated is implementation defined but you have the assurance that the object will be alive throughout the duration of the program.</br></p>\n", "LastActivityDate": "2011-11-09T18:40:42.263"}});