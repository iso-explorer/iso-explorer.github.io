post_cb({"23775705": {"CommentCount": "8", "CreationDate": "2014-05-21T06:37:27.453", "PostTypeId": "1", "AcceptedAnswerId": "23775840", "LastEditorUserId": "2684539", "LastActivityDate": "2014-05-21T13:44:01.713", "LastEditDate": "2014-05-21T07:02:41.513", "ViewCount": "941", "FavoriteCount": "3", "Title": "Is constexpr a \"hint\" (like inline) or \"a binding request\" to the compiler?", "Id": "23775705", "Score": "18", "Body": "<p>Is <code>constexpr</code> an indicator for the compiler or does it mandate a behaviour ? </p>\n<p>The example at hand is the following : </p>\n<pre><code>template&lt;typename T&gt; \nstd::size_t constexpr getID() { return typeid(T).hash_code(); }\n</code></pre>\n<p><code>hash_code</code> is a runtime constant, yet this snippet would <a href=\"http://ideone.com/Zm2X92\" rel=\"noreferrer\">compile</a> even though a compile time evaluation is requested with <code>constexpr</code>. Only after the return value is used where a compile time constant is expected, would we get noticed that this <a href=\"http://ideone.com/LxcuMF\" rel=\"noreferrer\">is not usable as a constexpr function</a>.</p>\n<p>So is <code>constexpr</code> a \"hint\" (much like the <code>inline</code> keyword) or \"a binding request\" to the compiler ?</p>\n", "Tags": "<c++><c++11><constexpr>", "OwnerUserId": "2567683", "AnswerCount": "4"}, "23776484": {"ParentId": "23775705", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>constexpr functions can be used to evaluate compile time constants. So it is possible to use it like:</p>\n<pre><code> constexpr int func(int a) { return a+2; }\n\n char x[func(10)];\n</code></pre>\n<p>If func is called during runtime, the compiler <em>can</em> evaluate this expression before if possible. But that is not a must but normally done if the input is also const.</p>\n<p>It is also important to have constexpr constructors. This is the only chance to get non POD classes constexpr objects.</p>\n<pre><code>    class Point\n    {   \n        private:    \n            int x;\n            int y;\n        public:\n            constexpr Point( int _x, int _y) : x(_x), y(_y) {}  \n            constexpr int GetX() const { return x; }\n    };  \n\n    constexpr Point p{1,2};\n\n    int main()\n    {   \n\n        char i[p.GetX()];\n        return 0;\n    }   \n</code></pre>\n", "OwnerUserId": "878532", "LastEditorUserId": "878532", "LastEditDate": "2014-05-21T07:28:15.787", "Id": "23776484", "Score": "2", "CreationDate": "2014-05-21T07:18:13.863", "LastActivityDate": "2014-05-21T07:28:15.787"}, "23777093": {"ParentId": "23775705", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The complete answer to your question has two aspects:</p>\n<ol>\n<li><p>A constexpr function can only be evaluated at compile-time when all\narguments can be evaluated at compile-time. It can still be used as\na normal function which is evaluated at runtime.</p></li>\n<li><p>An constexpr variable must be initialized with a value evaluated at compile-time.\nThe compiler has to raise an error if it cannot do this.</p></li>\n</ol>\n<p>You could assign the hash code to a constexpr variable and then get a compiler output:</p>\n<pre><code>#include &lt;typeinfo&gt;\n#include &lt;array&gt;\n\ntemplate&lt;typename T&gt; \nstd::size_t constexpr getID() { \n\n    return []() {constexpr size_t id = typeid(T).hash_code(); return id;}(); }\n\nint main() {\n    // both statement generate compiler errors\n    //std::array&lt;int, typeid(int).hash_code()&gt; a;\n    //constexpr size_t y = typeid(int).hash_code();\n\n    size_t x = getID&lt;int&gt;();\n}\n</code></pre>\n", "OwnerUserId": "2169853", "LastEditorUserId": "2169853", "LastEditDate": "2014-05-21T13:44:01.713", "Id": "23777093", "Score": "1", "CreationDate": "2014-05-21T07:46:41.560", "LastActivityDate": "2014-05-21T13:44:01.713"}, "23778747": {"ParentId": "23775705", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_23775705_23778747_0\">Is <code>constexpr</code> a \u201chint\u201d (like inline) or \u201ca binding request\u201d to the compiler?</p>\n</blockquote>\n<p>It is neither. Forget about <em>when</em> it is evaluated. Everything (with a few minor exceptions, notably involving <code>volatile</code>) is evaluated whenever the compiler deems it necessary to produce the behaviour of the C++ abstract machine. There isn't much else to say about <em>when</em> things are evaluated.</p>\n<p>The compiler is free to produce code that evaluates what would be constant expressions at runtime if that doesn't produce a different behaviour. It is free to produce code that evaluates things not marked <code>constexpr</code> at compile-time if it has the smarts.</p>\n<blockquote>\n<p id=\"so_23775705_23778747_1\">If not about compile-time vs runtime, what is <code>constexpr</code> about, then?</p>\n</blockquote>\n<p><code>constexpr</code> allows things to be treated as constant expressions. Anything marked <code>constexpr</code> <em>must</em> have the possibility of producing a constant expression in some way.</p>\n<p>In the case of functions, they can be able to produce constant expressions with some arguments but not others. But as long as there is some set of arguments that can result in a constant expression, a function can be marked <code>constexpr</code>. If such a set of arguments is used in a function call, that expression is a constant expression. Does that mean it is evaluated at compile-time? See above. It's evaluated when the compiler deems appropriate. The only thing it means is that you can use it in a context requiring a constant expression.</p>\n<p>For variables, either they are constant expressions or not. They have no arguments, so if <code>constexpr</code> they always have to be initialised with constant expressions.</p>\n<p><strong>TL;DR</strong>: <code>constexpr</code> is about tagging things as being usable in constant expressions, not about deciding when to evaluate them.</p>\n<hr>\n<p>With that out of the way, it appears your function template is ill-formed. There is no set of arguments that could result in a constant expression. The standard doesn't require a diagnostic for this, though.</p>\n</hr>", "OwnerUserId": "46642", "LastEditorUserId": "46642", "LastEditDate": "2014-05-21T12:31:39.480", "Id": "23778747", "Score": "14", "CreationDate": "2014-05-21T09:08:44.583", "LastActivityDate": "2014-05-21T12:31:39.480"}, "23775840": {"ParentId": "23775705", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>From the <a href=\"http://en.wikipedia.org/wiki/C++11#constexpr_.E2.80.93_Generalized_constant_expressions\" rel=\"nofollow\">C++11 Wiki page</a>:</p>\n<blockquote>\n<p id=\"so_23775705_23775840_0\">If a constexpr function or constructor is called with arguments which\n  aren't constant expressions, the call behaves as if the function were\n  not constexpr, and the resulting value is not a constant expression.\n  Likewise, if the expression in the return statement of a constexpr\n  function does not evaluate to a constant expression for a particular\n  invocation, the result is not a constant expression.</p>\n</blockquote>\n<p>The <code>constexpr</code> specifier thus expresses <em>the possibility</em> to evaluate something at compile time and is subject to <a href=\"http://en.cppreference.com/w/cpp/language/constexpr\" rel=\"nofollow\">some restrictions</a> when used.</p>\n<hr>\n<p>For your particular snippet it seems to me that the C++11 constraint:</p>\n<blockquote>\n<p id=\"so_23775705_23775840_1\">exactly one return statement that contains only literal values,\n  <em>constexpr variables and functions</em></p>\n</blockquote>\n<p>is not fulfilled, as hash_code is defined to be:</p>\n<pre><code>size_t hash_code() const;\n</code></pre>\n<p>In this case the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow\">standard draft n3242</a> says:</p>\n<blockquote>\n<p id=\"so_23775705_23775840_2\">For a constexpr function, if no function argument values exist such\n  that the function invocation substitution would produce a constant\n  expression (5.19), the program is ill-formed; no diagnostic required.</p>\n</blockquote>\n<p>I believe your example fits here.</p>\n</hr>", "OwnerUserId": "771663", "LastEditorUserId": "771663", "LastEditDate": "2014-05-21T07:31:57.553", "Id": "23775840", "Score": "7", "CreationDate": "2014-05-21T06:45:33.370", "LastActivityDate": "2014-05-21T07:31:57.553"}, "bq_ids": {"n4140": {"so_23775705_23775840_2": {"section_id": 5421, "quality": 0.631578947368421, "length": 12}}, "n3337": {"so_23775705_23775840_2": {"section_id": 5216, "quality": 0.8947368421052632, "length": 17}}, "n4659": {"so_23775705_23775840_2": {"section_id": 6843, "quality": 0.631578947368421, "length": 12}}}});