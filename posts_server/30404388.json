post_cb({"30404388": {"ViewCount": "1339", "Body": "<p>Both the <a href=\"http://en.cppreference.com/w/cpp/language/override\" rel=\"noreferrer\">override specifier</a> and <a href=\"http://en.cppreference.com/w/cpp/language/final\" rel=\"noreferrer\">final specifier</a> were added in C++11. They differ from other specifiers added to C++11 such as <a href=\"http://en.cppreference.com/w/cpp/language/constexpr\" rel=\"noreferrer\">constexpr</a> and <a href=\"http://en.cppreference.com/w/cpp/language/decltype\" rel=\"noreferrer\">decltype</a>, in that they are not <a href=\"http://en.cppreference.com/w/cpp/keyword\" rel=\"noreferrer\">keywords</a> and so are available for use as identifiers:</p>\n<pre><code>int main()\n{\n  int override = 0 ;    // Ok\n  int final = 0 ;       // Ok\n  //int constexpr = 0 ; // Error\n}\n</code></pre>\n<p>They are referred to as <em>identifiers with special meaning</em>, which is covered in the draft C++11 standard section <code>2.11</code> <em>[lex.name]</em> (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_30404388_30404388_0\">The <strong>identifiers in Table 3 have a special meaning</strong> when appearing\n  in a certain context. When referred to in the grammar, these\n  identifiers are used explicitly rather than using the identifier\n  grammar production. any ambiguity as to whether a given identifier has\n  a special meaning is resolved to interpret the token as a regular\n  identifier.</p>\n</blockquote>\n<p>and <em>Table 3 -- Identifiers with special meaning</em> lists both <em>override</em> and <em>final</em>.</p>\n<p>Why did these two specifiers end up being <em>identifiers with special meaning</em> instead of <em>keywords</em>?</p>\n", "Title": "Why are override and final identifiers with special meaning instead of reserved keywords?", "CreationDate": "2015-05-22T19:20:23.287", "LastActivityDate": "2015-05-29T13:47:47.920", "CommentCount": "8", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2015-05-28T14:10:45.540", "LastEditorUserId": "1708801", "Id": "30404388", "Score": "29", "OwnerUserId": "1708801", "Tags": "<c++><c++11><keyword>", "AnswerCount": "1"}, "30404389": {"Id": "30404389", "PostTypeId": "2", "Body": "<p>Adding new keywords is difficult because it takes away identifiers from the user. It ends up being a trade-off between choosing identifiers that potentially break old code currently using the identifier or choosing names that are highly unlikely to break old code but are <em>ugly</em> or not meaningful to the way they are being used.</p>\n<p>In this specific case <em>override</em> and <em>final</em> end up being used in the grammar in places where no user identifiers can appear. So in those places the identifiers can have a special meaning and outside of those contexts they can be treated as a regular identifier leaving the identifiers available for users. <code>C++/CLI</code> has used this technique since <code>2005</code> and they are called <em>context-sensitive keywords</em> which is covered in the <a href=\"http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-372.pdf\">C++/CLI standard</a> section <code>9.1.1</code> Identifiers.</p>\n<p>We can see in the write-up that addresses the trade-offs of the different methods of adding support for virtual control attributes in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3163.pdf\">N3163: Override Control Using Contextual Keywords</a>. It discussed three options:</p>\n<ul>\n<li><p>Using <code>[[attributes]]</code>, which was deemed undesirable for reasons including they are just keywords in disguise (<em>modified example from paper below</em>):</p>\n<blockquote id=\"so_30404388_30404389_0\">\n<pre><code>class A : public B {\n  virtual void f [[override]] () { ... }\n  virtual void h [[final]] () { ... }\n};\n</code></pre>\n</blockquote></li>\n<li><p>Use reserved keywords, which potentially breaks existing code unless <em>ugly names</em> are chosen (<em>modified example from paper below</em>):</p>\n<blockquote id=\"so_30404388_30404389_1\">\n<pre><code>class A : public B {\n  virtual void f override_func () { ... }\n  virtual void h final_func () { ... }\n};\n</code></pre>\n</blockquote></li>\n<li><p>Use context-sensitive keywords, which does not break existing code allows for <em>nice names</em> (<em>modified example from paper below</em>):</p>\n<blockquote id=\"so_30404388_30404389_2\">\n<pre><code>class A : public B {\n  virtual void f() override { ... }\n  virtual void h() final { ... }\n};\n</code></pre>\n</blockquote></li>\n</ul>\n<p>The following paragraph from the paper sums up the argument for using <em>context sensitive keywords</em> over the other two choices (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_30404388_30404389_3\">The observation was made in Rapperswil that this approach can make\n  error recovery and syntax highlighting more difficult. For example,\n  syntax highlighting is a bit harder because instead of globally\n  highlighting the keyword you need to do parsing to know whether the\n  identifier is in the location where it has special meaning and should\n  be highlighted. But this is not exceptionally difficult, particularly\n  not in comparison to other far more difficult things we already have\n  to do in C++ compared to other languages .</p>\n<p id=\"so_30404388_30404389_4\">These are <strong>minor inconveniences for a few compiler writers for a week,\n  but are seamless for users. This is the right tradeoff</strong>. Otherwise,\n  having ugly globally reserved names (Option 2) or inappropriate and\n  visibly bolted\n  - on <strong>attributes (Option 1) make things easier for a few compiler writers for a week, but are things millions of users will have to live\n  with forever</strong>.</p>\n</blockquote>\n<p>The changes were applied to the standard via <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3206.htm\">N3206: Override control: Eliminating Attributes</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3272.htm\">N3272: Follow-up on override control</a>.</p>\n", "LastEditorUserId": "597607", "LastActivityDate": "2015-05-29T13:47:47.920", "Score": "35", "CreationDate": "2015-05-22T19:20:23.287", "ParentId": "30404388", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2015-05-29T13:47:47.920"}, "bq_ids": {"n4140": {"so_30404388_30404388_0": {"length": 30, "quality": 0.9375, "section_id": 5334}, "so_30404388_30404389_2": {"length": 5, "quality": 0.625, "section_id": 7003}, "so_30404388_30404389_0": {"length": 5, "quality": 0.625, "section_id": 7003}}, "n3337": {"so_30404388_30404388_0": {"length": 30, "quality": 0.9375, "section_id": 5131}, "so_30404388_30404389_2": {"length": 5, "quality": 0.625, "section_id": 4515}, "so_30404388_30404389_0": {"length": 5, "quality": 0.625, "section_id": 4515}, "so_30404388_30404389_1": {"length": 5, "quality": 0.625, "section_id": 4515}}, "n4659": {"so_30404388_30404388_0": {"length": 30, "quality": 0.9375, "section_id": 6755}, "so_30404388_30404389_2": {"length": 5, "quality": 0.625, "section_id": 8500}, "so_30404388_30404389_0": {"length": 5, "quality": 0.625, "section_id": 8500}}}});