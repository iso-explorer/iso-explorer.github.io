post_cb({"15702473": {"ParentId": "15702146", "CommentCount": "0", "Body": "<p>Don't get distracted by the template. It has nothing to do with the error. The line in <code>main</code> that the compiler is complaining about creates an object of type <code>B&lt;int, a&gt;</code> and tries to access a protected member. That's not legal, regardless of the type. You can only use protected members from <strong>inside</strong> a member function or friend function. For example:</p>\n<pre><code>struct S {\nprotected:\n    void f();\n};\n\nint main() {\n    S s;\n    s.f(); // error: attempts to call a protected member function\n}\n</code></pre>\n", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "15702473", "Score": "2", "CreationDate": "2013-03-29T11:40:48.483", "LastActivityDate": "2013-03-29T11:40:48.483"}, "15702707": {"ParentId": "15702146", "CommentCount": "4", "Body": "<p>Let's forget for a minute about the template and look at this:</p>\n<pre><code> class A {\n   protected:\n     int value;\n     int getValue() { return value; }\n   public:\n     A(int value) { this-&gt;value = value; }\n };\n\n class B : protected A {\n   public:\n     B() : A(0) { /* Fake value */ }\n     void print(A&amp; input) {\n       cout &lt;&lt; input.getValue() &lt;&lt; endl;\n     }\n };\n</code></pre>\n<p>The <code>print()</code> method's implementation is wrong because <strong>you can't access non-public member of <code>A</code> inside <code>B</code>.</strong> And here's why: from within <code>B</code>, you can only access non-public members of <code>B</code>. Those members may be either inherited or not \u2014 it doesn't matter.</p>\n<p>On the other hand, <code>A&amp; input</code> may not be a reference to an instance of <code>B</code>. It may be a reference to another subclass (which may well have <code>getValue()</code> inaccessible).</p>\n", "OwnerUserId": "2212026", "PostTypeId": "2", "Id": "15702707", "Score": "6", "CreationDate": "2013-03-29T11:55:10.323", "LastActivityDate": "2013-03-29T11:55:10.323"}, "15702561": {"ParentId": "15702146", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>You have misunderstood the meaning of protected access.</p>\n<p>Protected members are callable by derived classes. But only on the base object contained inside the class itself.</p>\n<p>For example, if i simplify the problem, using :</p>\n<pre><code>class A {\nprotected:\n    void getValue(){}\n};\n\nclass B : protected A\n{\npublic:\n    void print(A&amp; input)\n    {\n        input.getValue(); //Invallid\n    }\n};\n</code></pre>\n<p>getValue cannot be called on a \"A\" object other than the \"A\" object inside the class itself.\nThis for example is valid.</p>\n<pre><code>    void print()\n    {\n        getValue(); //Valid, calling the base class getValue()\n    }\n</code></pre>\n<p>As pointed out by Dan Nissenbaum and shakurov. This is however also valid:</p>\n<pre><code>void print(B&amp; input)\n{\n    input.getValue();\n}\n</code></pre>\n<p>This is because we explicitly say that input is a object of B. And the compiler know that all that objects of B has protected access to getValue. In the case when we pass a A&amp;, the object might as-well be a type of C, wich could be derrived from A with private access.</p>\n", "OwnerUserId": "1339333", "LastEditorUserId": "1339333", "LastEditDate": "2013-03-29T12:15:07.140", "Id": "15702561", "Score": "9", "CreationDate": "2013-03-29T11:46:14.980", "LastActivityDate": "2013-03-29T12:15:07.140"}, "15703850": {"ParentId": "15702146", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Member functions of a derived class have access to protected base class members within any object of its type that is passed as an argument <strong>so long as the explicitly declared class of the object passed as an argument is that of the the derived class</strong> (or a further derived class).</p>\n<p>Objects explicitly passed as the <strong>base</strong> class type cannot have their protected members accessed within the derived class's member functions.</p>\n<p>In other words, if we have:</p>\n<pre><code>class A\n{\nprotected:\n    int x;\n}\n\nclass B : public A\n{\n    void foo(B b)\n    {\n        b.x; // allowed because 'b' is explicitly declared as an object of class B\n    }\n    void goo(A a)\n    {\n        a.x; // error because 'a' is explicitly declared as having *base* class type\n    }\n};\n</code></pre>\n<p>...then the line <code>a.x</code> is not allowed because the explicit type of the argument is <code>A</code>, but the rule for protected access only applies to objects explicitly defined as the <strong>same</strong> class as the class attempting to access the member.  (...Or a class derived from it; i.e., if <code>class C</code>derives from <code>B</code>, then passing an object explicitly declared as an object of class <code>C</code> will also have <code>x</code> accessible within <code>B</code> member functions.)</p>\n<p>The reason for this is given by shakurov when he writes (paraphrasing)</p>\n<blockquote>\n<p id=\"so_15702146_15703850_0\">A&amp; input might not be a reference to an instance of B. It may be a\n  reference to another subclass (which may well have getValue()\n  inaccessible)</p>\n</blockquote>\n<p>An excellent explication of this answer is also given here: <a href=\"https://stackoverflow.com/questions/11631777/accessing-a-protected-member-of-a-base-class-in-another-subclass\">accessing a protected member of a base class in another subclass</a>.</p>\n<p>As a matter of interest, I believe that this comes from the C++ standard here:</p>\n<blockquote>\n<p id=\"so_15702146_15703850_1\">11.4 Protected member access [class.protected] 1 An additional access check beyond those described earlier in Clause 11 is applied when a\n  non-static data member or non-static member function is a protected\n  member of its naming class (11.2)115 As described earlier, access to a\n  protected member is granted because the reference occurs in a friend\n  or member of some class C. If the access is to form a pointer to\n  member (5.3.1), the nested-name-specifier shall denote C or a class\n  derived from C. All other accesses involve a (possibly implicit)\n  object expression (5.2.5). In this case, the class of the object\n  expression shall be C or a class derived from C.</p>\n</blockquote>\n", "OwnerUserId": "368896", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:49:56.690", "Id": "15703850", "Score": "2", "CreationDate": "2013-03-29T13:05:47.943", "LastActivityDate": "2013-03-29T13:11:07.123"}, "15702146": {"CommentCount": "1", "AcceptedAnswerId": "15702707", "CreationDate": "2013-03-29T11:15:14.780", "LastActivityDate": "2013-03-29T13:11:07.123", "PostTypeId": "1", "ViewCount": "2126", "FavoriteCount": "1", "Title": "Policy inheritance and inaccessible protected members", "Id": "15702146", "Score": "6", "Body": "<p>It seems that a protected member from a template policy class is inaccessible, even with a class hierarchy which seems correct.</p>\n<p>For instance, with the following code snippet :</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;class T&gt;\nclass A {\n  protected:\n    T value;\n    T getValue() { return value; }\n  public:\n    A(T value) { this-&gt;value = value; }\n};\n\ntemplate &lt;class T, template &lt;class U&gt; class A&gt;\nclass B : protected A&lt;T&gt; {\n  public:\n    B() : A&lt;T&gt;(0) { /* Fake value */ }\n    void print(A&lt;T&gt;&amp; input) {\n      cout &lt;&lt; input.getValue() &lt;&lt; endl;\n    }\n};\n\nint main(int argc, char *argv[]) {\n  B&lt;int, A&gt; b;\n  A&lt;int&gt; a(42);\n  b.print(a);\n}\n</code></pre>\n<p>The compiler (clang on OS X, but gcc returns the same type of error) returns the following error :</p>\n<pre><code>Untitled.cpp:18:21: error: 'getValue' is a protected member of 'A&lt;int&gt;'\n      cout &lt;&lt; input.getValue() &lt;&lt; endl;\n                ^\nUntitled.cpp:25:5: note: in instantiation of member function 'B&lt;int, A&gt;::print' requested here\n  b.print(a);\n    ^\nUntitled.cpp:8:7: note: can only access this member on an object of type 'B&lt;int, A&gt;'\n    T getValue() { return value; }\n      ^\n1 error generated.\n</code></pre>\n<p>The strange thing is that the last note from the compiler is totally correct but already applied since the <code>b</code> object is of type <code>'B&lt;int, A&gt;'</code>. Is that a compiler bug or is there a problem in the code ?</p>\n<p>Thanks</p>\n", "Tags": "<c++><inheritance><visibility><protected><policy>", "OwnerUserId": "274592", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_15702146_15703850_1": {"section_id": 6695, "quality": 0.875, "length": 56}}, "n3337": {"so_15702146_15703850_1": {"section_id": 6450, "quality": 0.875, "length": 56}}, "n4659": {"so_15702146_15703850_1": {"section_id": 8170, "quality": 0.875, "length": 56}}}});