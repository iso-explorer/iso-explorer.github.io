post_cb({"bq_ids": {"n4140": {"so_46070793_46071137_1": {"length": 30, "quality": 0.8823529411764706, "section_id": 3324}, "so_46070793_46071137_0": {"length": 31, "quality": 0.8611111111111112, "section_id": 3280}}, "n3337": {"so_46070793_46071137_1": {"length": 30, "quality": 0.8823529411764706, "section_id": 3194}, "so_46070793_46071137_0": {"length": 31, "quality": 0.8611111111111112, "section_id": 3151}}, "n4659": {"so_46070793_46071137_1": {"length": 29, "quality": 0.8529411764705882, "section_id": 4090}, "so_46070793_46071137_0": {"length": 31, "quality": 0.8611111111111112, "section_id": 4042}}}, "46071137": {"Id": "46071137", "PostTypeId": "2", "Body": "<p>First, The C++ grammar rules makes the trailing <code>,</code> optional for <em>braced-init-list</em>. To quote <a href=\"http://eel.is/c++draft/dcl.init#1\" rel=\"noreferrer\">dcl.init/1</a></p>\n<blockquote>\n<p id=\"so_46070793_46071137_0\">A declarator can specify an initial value for the identifier being\n  declared. The identifier designates a variable being initialized. The\n  process of initialization described in the remainder of [dcl.init]\n  applies also to initializations specified by other syntactic contexts,\n  such as the initialization of function parameters ([expr.call]) or the\n  initialization of return values ([stmt.return]).</p>\n<pre><code>initializer:\n  brace-or-equal-initializer\n  ( expression-list )\nbrace-or-equal-initializer:\n  = initializer-clause\n  braced-init-list\ninitializer-clause:\n  assignment-expression\n  braced-init-list\nbraced-init-list:\n  { initializer-list ,opt }\n  { designated-initializer-list ,opt }\n  { }\n</code></pre>\n</blockquote>\n<p>Secondly, you can't pretty much override the overload resolution system. It will always use the <code>std::initializer_list</code> constructor if you use such syntax and such <code>std::initializer_list</code> constructor is available.</p>\n<p><a href=\"http://eel.is/c++draft/dcl.init#list-2\" rel=\"noreferrer\">dcl.init.list/2</a>:</p>\n<blockquote>\n<p id=\"so_46070793_46071137_1\">A constructor is an initializer-list constructor if its first\n  parameter is of type std\u200b::\u200binitializer_\u00adlist or reference to\n  possibly cv-qualified std\u200b::\u200binitializer_\u00adlist for some type E, and\n  either there are no other parameters or else all other parameters have\n  default arguments.\n  <strong><em>[\u2009Note: Initializer-list constructors are favored over other constructors in list-initialization ([over.match.list])....</em></strong></p>\n</blockquote>\n<hr>\n<p>The program below prints <code>Using InitList</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;initializer_list&gt;\n\nstruct X{\n    X(std::initializer_list&lt;double&gt;){ std::cout &lt;&lt; \"Using InitList\\n\"; }\n    X(int){ std::cout &lt;&lt; \"Using Single Arg ctor\\n\"; }\n};\n\nint main(){\n    X x{5};\n}\n</code></pre>\n<p>Despite the fact that <code>5</code> is a literal of type <code>int</code>, it should have made sense to select the single argument constructor since its a perfect match; and the <code>std::initializer_list&lt;double&gt;</code> constructor wants a list of <code>double</code>. However, the rules favour <code>std::initializer_list&lt;double&gt;</code> because its an <em>initializer-list constructor</em>.</p>\n<p>As a result, even the program below fails because of narrowing conversion:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;initializer_list&gt;\n\nstruct Y{\n    Y(std::initializer_list&lt;char&gt;){ std::cout &lt;&lt; \"Y Using InitList\\n\"; }\n    Y(int, int=4){ std::cout &lt;&lt; \"Y Using Double Arg ctor\\n\"; }\n};\n\nint main(){\n    Y y1{4777};\n    Y y2{577,};\n    Y y3{57,7777};\n}\n</code></pre>\n<hr>\n<p>In response to your comment below, \"<em>what if there is no overloading with std::initializer_list, or it is not the first constructor's parameter?</em>\" - then overload resolution doesn't choose it. Demo:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;initializer_list&gt;\n\nstruct Y{\n    Y(int, std::initializer_list&lt;double&gt;){ std::cout &lt;&lt; \"Y Using InitList\\n\"; }\n    Y(int, int=4){ std::cout &lt;&lt; \"Y Using Double Arg ctor\\n\"; }\n};\n\nint main(){\n    Y y1{4};\n    Y y2{5,};\n    Y y3{5,7};\n}\n</code></pre>\n<p>Prints:</p>\n<pre><code>Y Using Double Arg ctor\nY Using Double Arg ctor\nY Using Double Arg ctor\n</code></pre>\n<p>If there is no <em>initializer-list constructor</em> available, then the <code>{initializer-list...,}</code> initializer pretty much falls back to <em>direct initialization</em> as per <a href=\"http://eel.is/c++draft/dcl.init#16\" rel=\"noreferrer\">dcl.init/16</a>, whose semantics are covered by the proceeding paragraph of <a href=\"http://eel.is/c++draft/dcl.init#16\" rel=\"noreferrer\">dcl.init/16</a></p>\n</hr></hr>", "LastEditorUserId": "1621391", "LastActivityDate": "2017-09-06T09:40:25.953", "Score": "9", "CreationDate": "2017-09-06T09:09:43.443", "ParentId": "46070793", "CommentCount": "2", "OwnerUserId": "1621391", "LastEditDate": "2017-09-06T09:40:25.953"}, "46070793": {"ViewCount": "309", "Body": "<p>Is there any potential semantic difference when I use trailing comma during uniform initialization?</p>\n<pre><code>std::vector&lt; std::size_t &gt; v1{5, }; // allowed syntax\nstd::vector&lt; std::size_t &gt; v2{10};\n</code></pre>\n<p>Can I use trailing comma to make compiler to select <code>std::vector::vector(std::initializer_list&lt; std::size_t &gt;)</code> constructor instead of <code>std::vector::vector(std::size_t, const std::size_t &amp;)</code> or are there any other tricks with mentioned syntax?</p>\n<p>Can I use it to detect is there <code>std::initializer_list</code>-constructor overloading?</p>\n<p>Considering the following code, which constructor must be selected?</p>\n<pre><code>struct A { A(int) { ; } A(double, int = 3) { ; } };\nA a{1};\nA b{2, };\n</code></pre>\n<p>This code <a href=\"https://wandbox.org/permlink/WjPcjsCFGmDTrxFA\" rel=\"noreferrer\">is accepted by <code>gcc 8</code></a> and <code>A(int)</code> is selected in both cases.</p>\n", "AcceptedAnswerId": "46071137", "Title": "Trailing comma in uniform initialization", "CreationDate": "2017-09-06T08:54:25.070", "Id": "46070793", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-09-06T09:19:18.490", "LastEditorUserId": "1430927", "LastActivityDate": "2017-09-06T09:40:25.953", "Score": "15", "OwnerUserId": "1430927", "Tags": "<c++><c++14><language-lawyer><c++1z><uniform-initialization>", "AnswerCount": "2"}, "46071016": {"Id": "46071016", "PostTypeId": "2", "Body": "<p>No. That comma is a concession to make preprocessor macro tricks work without compile errors. It means nothing about your data type or its size.</p>\n", "LastActivityDate": "2017-09-06T09:04:30.610", "CommentCount": "0", "CreationDate": "2017-09-06T09:04:30.610", "ParentId": "46070793", "Score": "2", "OwnerUserId": "2706707"}});