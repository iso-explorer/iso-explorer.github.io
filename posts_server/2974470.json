post_cb({"2974526": {"Id": "2974526", "PostTypeId": "2", "Body": "<p>If the underlying data structure is a heap, top() will be constant time, and push (EDIT: and pop) will be logarithmic (like you are saying).  The vector is just used to store these things like this:</p>\n<p>HEAP:<br/>\n \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01<br/>\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a02\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a03<br/>\n \u00a0\u00a0\u00a0\u00a0\u00a0 8 12 \u00a0 11 9 <br/></p>\n<p>VECTOR (used to store)</p>\n<p>1 2 3 8 12 11 9</p>\n<p>You can think of it as the element at position i's children is (2i) and (2i+1)</p>\n<p>They use the vector because it stores the data sequentially (which is much more efficient and cache-friendly than discrete) </p>\n<p>Regardless of how it is stored, a heap should always be implemented (especially by the gods who made the STD lib) so that pop is constant and push is logarithmic</p>\n", "LastEditorUserId": "358464", "LastActivityDate": "2010-06-09T13:12:12.003", "Score": "2", "CreationDate": "2010-06-04T13:24:20.637", "ParentId": "2974470", "CommentCount": "4", "OwnerUserId": "358464", "LastEditDate": "2010-06-09T13:12:12.003"}, "2974470": {"ViewCount": "20609", "Body": "<p>I have an application (C++) that I think would be well served by an STL <code>priority_queue</code>.  <a href=\"http://www.sgi.com/tech/stl/priority_queue.html\" rel=\"noreferrer\">The documentation</a> says:</p>\n<blockquote>\n<p id=\"so_2974470_2974470_0\">Priority_queue is a container adaptor, meaning that it is implemented on top of some underlying container type. By default that underlying type is vector, but a different type may be selected explicitly.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_2974470_2974470_1\">Priority queues are a standard concept, and can be implemented in many different ways; this implementation uses heaps.</p>\n</blockquote>\n<p>I had previously <em>assumed</em> that <code>top()</code> is <code>O(1)</code>, and that <code>push()</code> would be a <code>O(logn)</code> (the two reasons I chose the <code>priority_queue</code> in the first place) - but the documentation neither confirms nor denies this assumption.</p>\n<p>Digging deeper, the docs for the Sequence concept say:</p>\n<blockquote>\n<p id=\"so_2974470_2974470_2\">The complexities of single-element insert and erase are sequence dependent.</p>\n</blockquote>\n<p>The <code>priority_queue</code> uses a <code>vector</code> (by default) as a heap, which:</p>\n<blockquote>\n<p id=\"so_2974470_2974470_3\">... supports random access to elements, constant time insertion and removal of elements at the end, and linear time insertion and removal of elements at the beginning or in the middle.</p>\n</blockquote>\n<p>I'm inferring that, using the default <code>priority_queue</code>, <code>top()</code> is <code>O(1)</code> and <code>push()</code> is <code>O(n)</code>.</p>\n<p><strong>Question 1:</strong> Is this correct?  (<code>top()</code> access is <code>O(1)</code> and <code>push()</code> is <code>O(n)</code>?)</p>\n<p><strong>Question 2:</strong> Would I be able to achieve <code>O(logn)</code> efficiency on <code>push()</code> if I used a <code>set</code> (or <code>multiset</code>) instead of a <code>vector</code> for the implementation of the <code>priority_queue</code>?  What would the consequences be of doing this?  What other operations would suffer as a consequence?</p>\n<p><em>N.B.: I'm worried about time efficiency here, not space.</em></p>\n", "AcceptedAnswerId": "2974501", "Title": "Efficiency of the STL priority_queue", "CreationDate": "2010-06-04T13:15:44.643", "Id": "2974470", "CommentCount": "0", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2016-12-20T08:28:21.787", "Score": "29", "OwnerUserId": "77047", "Tags": "<c++><data-structures><stl><performance><priority-queue>", "AnswerCount": "6"}, "2974562": {"Id": "2974562", "PostTypeId": "2", "Body": "<p><code>top()</code> - O(1) -- as it just returns the element @ front.</p>\n<p><code>push()</code> - </p>\n<ul>\n<li>insert into vector - 0(1) amortized</li>\n<li><p>push_into_heap - At most, log(n) comparisons. O(logn)</p>\n<p>so push() complexity is -- \nlog(n)</p></li>\n</ul>\n", "LastActivityDate": "2010-06-04T13:28:42.350", "CommentCount": "0", "CreationDate": "2010-06-04T13:28:42.350", "ParentId": "2974470", "Score": "5", "OwnerUserId": "64960"}, "2974501": {"Body": "<p>The priority queue adaptor uses the standard library heap algorithms to build and access the queue - it's the complexity of those algorithms you should be looking up in the documentation.</p>\n<p>The top() operation is obviously O(1) but presumably you want to pop() the heap after calling it which (according to <a href=\"http://www.josuttis.com/libbook/index.html\" rel=\"noreferrer\">Josuttis</a>) is O(2*log(N))  and push() is O(log(N)) - same source.</p>\n<p>And from the C++ Standard, 25.6.3.1, push_heap :</p>\n<blockquote>\n<p id=\"so_2974470_2974501_0\">Complexity: At most log(last - first) comparisons.</p>\n</blockquote>\n<p>and pop_heap:</p>\n<blockquote>\n<p id=\"so_2974470_2974501_1\">Complexity: At most 2 * log(last - first) comparisons.</p>\n</blockquote>\n", "CreationDate": "2010-06-04T13:20:49.640", "ParentId": "2974470", "CommentCount": "0", "LastEditDate": "2016-12-20T08:28:21.787", "PostTypeId": "2", "LastEditorDisplayName": "anon", "OwnerDisplayName": "anon", "LastEditorUserId": "4115625", "LastActivityDate": "2016-12-20T08:28:21.787", "Id": "2974501", "Score": "26"}, "bq_ids": {"n4140": {"so_2974470_2974501_0": {"length": 4, "quality": 0.8, "section_id": 1471}, "so_2974470_2974501_1": {"length": 4, "quality": 0.8, "section_id": 1471}, "so_2974470_2974470_3": {"length": 10, "quality": 0.5882352941176471, "section_id": 798}}, "n3337": {"so_2974470_2974501_0": {"length": 4, "quality": 0.8, "section_id": 1465}, "so_2974470_2974501_1": {"length": 4, "quality": 0.8, "section_id": 1465}, "so_2974470_2974470_3": {"length": 10, "quality": 0.5882352941176471, "section_id": 787}}, "n4659": {"so_2974470_2974470_3": {"length": 10, "quality": 0.5882352941176471, "section_id": 856}}}, "29450372": {"Id": "29450372", "PostTypeId": "2", "Body": "<p>C++ STL priority_queue underlying data structure is Heap data structure(Heap is a non linear ADT which based on complete binary tree and complete binary tree is implemented through vector(or Array) container.</p>\n<pre><code>ex  Input data : 5 9 3 10 12 4.\n\nHeap (Considering Min heap) would be :\n\n                   [3]\n             [9]             [4]\n         [10]    [12]     [5]\n\n\n   NOW , we store this min heap in to vector,             \n      [3][9][4][10][12][5].\n      Using formula ,\n      Parent : ceiling of n-1/2\n      Left Child : 2n+1\n      Right Child : 2n+2 .\n  Hence ,\n    Time Complexity for \n             Top = O(1) , get element from root node.\n             POP()= O(logn) , During deletion of root node ,there  is      chance to violation of  heap order . hence restructure of heap order takes at most O(logn) time (an element might move down to height of tree).\n            PUSH()= O(logn) , During insertion also , there might chance to violation of  heap order . hence restructure of heap order takes at most O(logn) time (an element might move up to root from leaf node).\n</code></pre>\n", "LastActivityDate": "2015-04-04T19:09:43.827", "CommentCount": "0", "CreationDate": "2015-04-04T19:09:43.827", "ParentId": "2974470", "Score": "1", "OwnerUserId": "4750021"}, "2974577": {"Id": "2974577", "PostTypeId": "2", "Body": "<p>Q1: I didn't look in the standard, but AFAIK, using <code>vector</code> (or <code>deque</code> btw), the complexity would be <code>O(1)</code> for <code>top()</code>, <code>O(log n)</code> for <code>push()</code> and <code>pop()</code>. I once compared <code>std::priority_queue</code> with my own heap with <code>O(1)</code> <code>push()</code> and <code>top()</code> and <code>O(log n)</code> <code>pop()</code> and it certainly wasn't as slow as <code>O(n)</code>.</p>\n<p>Q2: <code>set</code> is not usable as underlying container for <code>priority_queue</code> (not a Sequence), but it would be possible to use set to implement a priority queue with <code>O(log n)</code> <code>push()</code> and <code>pop()</code>. However, this wouldn't probably outperform the <code>std::priority_queue</code> over <code>std::vector</code> implementation.</p>\n", "LastEditorUserId": "51831", "LastActivityDate": "2010-06-04T13:37:56.243", "Score": "0", "CreationDate": "2010-06-04T13:31:10.030", "ParentId": "2974470", "CommentCount": "2", "OwnerUserId": "51831", "LastEditDate": "2010-06-04T13:37:56.243"}, "2974529": {"Id": "2974529", "PostTypeId": "2", "Body": "<p>No. This is not correct. top() is O(1) and push() is O(log n). Read note 2 in the documentation to see that this adapter does not allow iterating through the vector. Neil is correct about pop(), but still this allows working with the heap doing insertions and removals in O(log n) time.</p>\n", "LastActivityDate": "2010-06-04T13:24:43.547", "CommentCount": "0", "CreationDate": "2010-06-04T13:24:43.547", "ParentId": "2974470", "Score": "5", "OwnerUserId": "1702"}});