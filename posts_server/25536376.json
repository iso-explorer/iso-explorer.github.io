post_cb({"25537837": {"Id": "25537837", "PostTypeId": "2", "Body": "<p>My read of the standard is that this is not guaranteed. 23.2.5, paragraph 6, states:</p>\n<blockquote>\n<p id=\"so_25536376_25537837_0\">Thus, although the absolute order of elements in an unordered\n  container is not specified, its elements are grouped into\n  equivalent-key groups such that all elements of each group have\n  equivalent keys. Mutating operations on unordered containers shall\n  preserve the relative order of elements within each equivalent-key\n  group unless otherwise specified.</p>\n</blockquote>\n<p>Let's take off the table the fairly clear guarantee that elements that hash to the same key will have their relative order preserved no matter what. That seems to be fairly clear. Additionally, lets exclude any modifications to the container. In the remaining scope:</p>\n<p>Although this doesn't actually explicitly define that the iteration order, in absence of changes to the container, is unstable, I interpret the statement \"the absolute order of elements in an unordered container is not specified\" on its literal face value. If the iteration order is undefined, then it is undefined, and is not guaranteed to be the same every time.</p>\n<p>I think it all comes down to whether, in the quoted excerpt \"is not specified\" should be interpreted as \"it could be anything\" or \"it could be anything, at any given time\".</p>\n<p>I think an argument can be made either way. I would interpret \"is not specified\" in the most strict, literal interpretation of the latter, but I wouldn't object too hard if someone would argue in favor of the former.</p>\n", "LastActivityDate": "2014-08-27T22:16:53.630", "CommentCount": "0", "CreationDate": "2014-08-27T22:16:53.630", "ParentId": "25536376", "Score": "3", "OwnerUserId": "3943312"}, "25539172": {"Id": "25539172", "PostTypeId": "2", "Body": "<p>I think @Sharth's conclusion is correct, but (for anybody who cares about newer standards) is already obsolete (and may not have ever reflected reality--see below).</p>\n<p>More recent drafts of the standard (e.g., n3797) have changed the requirements, apparently intentionally <em>removing</em> the ordering requirement. Specifically, it says (\u00a723.2.5/12):</p>\n<blockquote>\n<p id=\"so_25536376_25539172_0\">Two unordered containers <code>a</code> and <code>b</code> compare equal if <code>a.size() == b.size()</code> and, for every equivalent-key group [<code>Ea1</code>,<code>Ea2</code>) obtained from <code>a.equal_range(Ea1)</code>, there exists an equivalent-key group [<code>Eb1</code>,<code>Eb2</code>) obtained from <code>b.equal_range(Ea1)</code>, such that <code>distance(Ea1, Ea2) == distance(Eb1, Eb2)</code> and <code>is_permutation(Ea1, Ea2, Eb1)</code> returns true.</p>\n</blockquote>\n<p>I also have relatively low confidence that implementations actually meet the requirements of the 2011 standard either. In particular, the unordered containers are normally implemented as hash tables with linked lists for collision resolution. Since those linked lists are expected to be short, they're not necessarily sorted (particularly since items stored in unordered containers aren't required to define operations to be used for sorting, such as <code>operator&lt;</code>). This being the case, it's fairly routine for the linked lists to hold the same items, but in an order that depends upon the order in which they were inserted.</p>\n<p>In such a case, it would be fairly routine for two hash tables that contained the same items that had been inserted in different orders to iterate over those items in different orders.</p>\n<p>In theory such an implementation doesn't conform with the C++11 standard--but I'd guess the change cited above was made largely because that requirement couldn't be met in practice (because, as noted above, the container had no way to enforce ordering).</p>\n<p>So, as long as you're dealing with the same container, unchanged, depending on iteration in the same order may be safe. Two containers that have the same contents may not work out so well though (and even in what claims to be a C++11 implementation, you probably can't expect it to meet tighter requirements than the newer drafts contain).</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2014-08-28T01:11:51.963", "Score": "18", "CreationDate": "2014-08-28T00:59:34.850", "ParentId": "25536376", "CommentCount": "2", "OwnerUserId": "179910", "LastEditDate": "2014-08-28T01:11:51.963"}, "25536376": {"ViewCount": "1098", "Body": "<pre><code>for (auto&amp;&amp; i : unordered_container)\n{ /* ... */ }\n\nfor (auto&amp;&amp; i : unordered_container)\n{ /* .. */ }\n</code></pre>\n<p>Does the standard require that both of these loops visit elements in the same order (assuming the container is unmodified)?</p>\n<hr>\n<p>My analysis of this question...</p>\n<p>I read the standard and as best I can tell the answer is \"no\"...</p>\n<p>Since iterators of containers are forward, there is language that requires <code>a==b</code> imply that <code>++a==++b</code> for forward iterators. That means two iterations will go through the same path IF they both start in the same place. This reduces the question to a different question of whether the standard requires <code>container.begin() == container.begin()</code>. I couldn't find any language that requires this.</p>\n</hr>", "AcceptedAnswerId": "25536957", "Title": "Does the C++11 standard require that two iterations through a constant unordered_container visit elements in the same order?", "CreationDate": "2014-08-27T20:28:31.720", "Id": "25536376", "CommentCount": "12", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-08-28T06:03:58.320", "LastEditorUserId": "1212596", "LastActivityDate": "2014-08-28T06:03:58.320", "Score": "36", "OwnerUserId": "2089740", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_25536376_25539172_0": {"length": 24, "quality": 0.8, "section_id": 764}, "so_25536376_25537837_0": {"length": 35, "quality": 0.9722222222222222, "section_id": 758}}, "n3337": {"so_25536376_25539172_0": {"length": 28, "quality": 0.9333333333333333, "section_id": 751}, "so_25536376_25537837_0": {"length": 35, "quality": 0.9722222222222222, "section_id": 746}}, "n4659": {"so_25536376_25539172_0": {"length": 24, "quality": 0.8, "section_id": 824}, "so_25536376_25537837_0": {"length": 34, "quality": 0.9444444444444444, "section_id": 818}}}, "25536957": {"Id": "25536957", "PostTypeId": "2", "Body": "<p>Containers are required to implement <code>operator==()</code>. That is we can do:</p>\n<pre><code>container c;\nc == c;\n</code></pre>\n<p>That relation is required to work the same as:</p>\n<pre><code>std::distance(a.begin(), a.end()) == std::distance(b.begin(), b.end()) &amp;&amp;\nstd::equal(a.begin(), a.end(), b.begin());\n</code></pre>\n<p>The important part here is the call to <code>std::equal()</code>. This call requires that two independent calls to <code>container.begin()</code> will produce the same sequence of values. If it didn't, then <code>c == c</code> would be false, and that doesn't make any sense because <code>==</code> is an equivalence relation.</p>\n<p>Therefore, my answer is that we <strong>can</strong> claim that the standard requires that two passes of <strong>any</strong> container must result in the same ordering. Obviously this requirement breaks if you do anything that changes the container or invalidates iterators.</p>\n<h3>Citations:</h3>\n<ul>\n<li>C++ 2011 Table 96 \u2014 Container requirements</li>\n</ul>\n", "LastEditorUserId": "47453", "LastActivityDate": "2014-08-27T21:24:36.070", "Score": "33", "CreationDate": "2014-08-27T21:07:41.280", "ParentId": "25536376", "CommentCount": "5", "OwnerUserId": "47453", "LastEditDate": "2014-08-27T21:24:36.070"}, "25536736": {"Id": "25536736", "PostTypeId": "2", "Body": "<p>Unordered containers do return forward iterators (which are defined in \u00a7 24.2.5) and those do have this property: <code>a == b implies ++a == ++b</code>. This seems to imply so long that <code>unordered_container.begin() == unordered_container.begin()</code> is true, that the traversal order will be the same.</p>\n<p>I was unable to find any language that requires <code>unordered_container.begin() == unordered_container.begin()</code> which led me to a tentative answer of \"no\", the traversal order isn't required to be the same. </p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2014-08-27T21:00:25.897", "Score": "2", "CreationDate": "2014-08-27T20:52:47.257", "ParentId": "25536376", "CommentCount": "3", "OwnerUserId": "2089740", "LastEditDate": "2014-08-27T21:00:25.897"}});