post_cb({"33891582": {"Id": "33891582", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_33891225_33891582_0\">why copy ctor is not being eventually called as evident from the output</p>\n</blockquote>\n<p>According to the standard, an implementation is allowed to omit the copy/move construction in certain criteria. In this case, a temporary <code>A</code>(constructed from <code>b</code>, and will be copied to <code>a</code>) 's construction is omitted.</p>\n<p>$12.8/31 Copying and moving class objects [class.copy]</p>\n<blockquote>\n<p id=\"so_33891225_33891582_1\">When certain criteria are met, an implementation is allowed to omit\n  the copy/move construction of a class object, even if the constructor\n  selected for the copy/move operation and/or the destructor for the\n  object have side effects.</p>\n</blockquote>\n<p>And</p>\n<blockquote>\n<p id=\"so_33891225_33891582_2\">(31.3) \u2014 when a temporary class object that has not been bound to a\n  reference (12.2) would be copied/moved to a class object with the same\n  type (ignoring cv-qualification), the copy/move operation can be\n  omitted by constructing the temporary object directly into the target\n  of the omitted copy/move</p>\n</blockquote>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2015-11-24T10:54:57.897", "Score": "0", "CreationDate": "2015-11-24T10:48:58.307", "ParentId": "33891225", "CommentCount": "0", "OwnerUserId": "3309790", "LastEditDate": "2015-11-24T10:54:57.897"}, "bq_ids": {"n4140": {"so_33891225_33891582_2": {"length": 25, "quality": 0.8620689655172413, "section_id": 480}, "so_33891225_33891582_1": {"length": 22, "quality": 1.0, "section_id": 480}}, "n3337": {"so_33891225_33891582_2": {"length": 25, "quality": 0.8620689655172413, "section_id": 471}, "so_33891225_33891582_1": {"length": 19, "quality": 0.8636363636363636, "section_id": 471}}, "n4659": {"so_33891225_33891582_2": {"length": 19, "quality": 0.6551724137931034, "section_id": 502}, "so_33891225_33891582_1": {"length": 22, "quality": 1.0, "section_id": 502}}}, "33891470": {"Id": "33891470", "PostTypeId": "2", "Body": "<pre><code>A a = b;\n</code></pre>\n<p>This form is called <a href=\"http://en.cppreference.com/w/cpp/language/copy_initialization\" rel=\"nofollow noreferrer\"><em>copy-initialization</em></a>. The applicable rule states that in this case a temporary <code>A</code> object will be constructed from the <code>B</code> instance and that temporary will then be used to <em>direct-initialize</em> <code>a</code>.</p>\n<p>However, the compiler is allowed to <a href=\"https://stackoverflow.com/questions/12953127/what-are-copy-elision-and-return-value-optimization\">elide</a> the copy as it is not necessary. Even though the elision is allowed, the class still needs to be copyable for the form to be valid.</p>\n<p>You can see the result without elision by passing <code>-fno-elide-constructors</code> to GCC or Clang.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-24T10:43:19.130", "Score": "2", "CreationDate": "2015-11-24T10:43:19.130", "ParentId": "33891225", "CommentCount": "0", "OwnerUserId": "496161", "LastEditDate": "2017-05-23T10:29:21.167"}, "33891225": {"ViewCount": "65", "Body": "<pre><code>#include&lt;iostream&gt;\n#include&lt;string&gt;\n\nusing namespace std;\n\nclass B;\n\nclass A {\n    public:\n        A(const A&amp;) {   //copy ctor\n            cout &lt;&lt; \"Copy ctor A\\n\";\n        }\n        A() {}  //default ctor\n        A(const B&amp;) {   //lets call this conversion ctor\n            cout &lt;&lt; \"B to A conversion ctor\\n\";\n        }\n};\n\nclass B {\n    public:\n\n};\n\nint main()\n{\n    B b;\n    A a = b;\n}\n</code></pre>\n<p>The above code prints \n<code>B to A conversion ctor</code>.\nBut as per what I have discovered after looking around for a while, it should print </p>\n<pre><code>B to A conversion ctor\nCopy ctor A\n</code></pre>\n<p>As first a temporary object of type <code>A</code> is created by conversion ctor and then that object is copied into <code>a</code> wherein copy ctor gets called. Also, when copy ctor is made private, statement <code>A a = b;</code> generates this error:</p>\n<pre><code>\u2018A::A(const A&amp;)\u2019 is private\n</code></pre>\n<p>which is obvious as to copy the temporary object into <code>a</code> copy ctor must be visible.\nSo my question is why copy ctor is not being eventually called as evident from the output(please correct if am leading wrong somewhere here) even though it is required to be accessible? </p>\n", "AcceptedAnswerId": "33891470", "Title": "Unusual behavior of copy ctor", "CreationDate": "2015-11-24T10:30:48.687", "Id": "33891225", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2015-11-24T10:54:57.897", "Score": "0", "OwnerUserId": "4653746", "Tags": "<c++>", "AnswerCount": "2"}});