post_cb({"42598915": {"CommentCount": "4", "AcceptedAnswerId": "42599381", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2017-03-04T17:19:33.613", "LastActivityDate": "2017-03-25T22:55:06.000", "LastEditDate": "2017-05-23T10:30:10.067", "ViewCount": "691", "FavoriteCount": "2", "Title": "Is it allowed to call destructor explicitly followed by placement new on a variable with fixed lifetime?", "Id": "42598915", "Score": "18", "Body": "<p>I know that calling destructor explicitly can lead to undefined behavior because of double destructor calling, like here:</p>\n<pre><code>#include &lt;vector&gt;\n\nint main() {\n  std::vector&lt;int&gt; foo(10);\n  foo.~vector&lt;int&gt;();\n  return 0;  // Oops, destructor will be called again on return, double-free.\n}\n</code></pre>\n<p>But, what if we call placement new to \"resurrect\" the object?</p>\n<pre><code>#include &lt;vector&gt;\n\nint main() {\n  std::vector&lt;int&gt; foo(10);\n  foo.~vector&lt;int&gt;();\n  new (&amp;foo) std::vector&lt;int&gt;(5);\n  return 0;\n}\n</code></pre>\n<p>More formally:</p>\n<ol>\n<li>What will happen in C++ (I'm interested in both C++03 and C++11, if there is a difference) if I explicitly call a destructor on some object which was not constructed with placement new in the first place (e.g. it's either local/global variable or was allocated with <code>new</code>) and then, before this object is destructed, call placement new on it to \"restore\" it?</li>\n<li>If it's ok, is it guaranteed that all non-const references to that object will also be ok, as long as I don't use them while the object is \"dead\"?</li>\n<li>If so, is it ok to use one of non-const references for placement new to resurrect the object?</li>\n<li>What about const references?</li>\n</ol>\n<p>Example usecase (though this question is more about curiosity): I want to \"re-assign\" an object which does not have <code>operator=</code>.</p>\n<p>I've seen <a href=\"https://stackoverflow.com/questions/12908398/can-placement-new-and-vectordata-be-used-to-replace-elements-in-a-vector\">this</a> question which says that \"overriding\" object which has non-static <code>const</code> members is illegal. So, let's limit scope of this question to objects which do not have any <code>const</code> members.</p>\n", "Tags": "<c++><c++11><lifetime><placement-new><explicit-destructor-call>", "OwnerUserId": "767632", "AnswerCount": "2"}, "42599285": {"ParentId": "42598915", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>This is not a good idea, because you can still end up running the destructor twice if the constructor of the new object throws an exception.  That is, the destructor will always run at the end of the scope, even if you leave the scope exceptionally.</p>\n<p>Here is a sample program that exhibits this behavior (<a href=\"https://ideone.com/30biUh\" rel=\"noreferrer\">Ideone link</a>):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\nusing namespace std;\n\nstruct Foo\n{\n    Foo(bool should_throw) {\n        if(should_throw)\n            throw std::logic_error(\"Constructor failed\");\n        cout &lt;&lt; \"Constructed at \" &lt;&lt; this &lt;&lt; endl;\n    }\n    ~Foo() {\n        cout &lt;&lt; \"Destroyed at \" &lt;&lt; this &lt;&lt; endl;\n    }\n};\n\nvoid double_free_anyway()\n{\n    Foo f(false);\n    f.~Foo();\n\n    // This constructor will throw, so the object is not considered constructed.\n    new (&amp;f) Foo(true);\n\n    // The compiler re-destroys the old value at the end of the scope.\n}\n\nint main() {\n    try {\n        double_free_anyway();\n    } catch(std::logic_error&amp; e) {\n        cout &lt;&lt; \"Error: \" &lt;&lt; e.what();\n    }\n}\n</code></pre>\n<p>This prints:</p>\n<blockquote>\n<p id=\"so_42598915_42599285_0\">Constructed at 0x7fff41ebf03f</p>\n<p id=\"so_42598915_42599285_1\">Destroyed at 0x7fff41ebf03f</p>\n<p id=\"so_42598915_42599285_2\">Destroyed at 0x7fff41ebf03f</p>\n<p id=\"so_42598915_42599285_3\">Error: Constructor failed</p>\n</blockquote>\n", "OwnerUserId": "1830736", "LastEditorUserId": "1830736", "LastEditDate": "2017-03-04T17:57:48.493", "Id": "42599285", "Score": "7", "CreationDate": "2017-03-04T17:52:47.577", "LastActivityDate": "2017-03-04T17:57:48.493"}, "bq_ids": {"n4140": {"so_42598915_42599381_0": {"section_id": 7195, "quality": 1.0, "length": 43}, "so_42598915_42599381_1": {"section_id": 7196, "quality": 0.8947368421052632, "length": 34}}, "n3337": {"so_42598915_42599381_0": {"section_id": 6939, "quality": 1.0, "length": 43}, "so_42598915_42599381_1": {"section_id": 6940, "quality": 0.8947368421052632, "length": 34}}, "n4659": {"so_42598915_42599381_0": {"section_id": 8704, "quality": 1.0, "length": 43}, "so_42598915_42599381_1": {"section_id": 8705, "quality": 0.8947368421052632, "length": 34}}}, "42599381": {"ParentId": "42598915", "CommentCount": "0", "Body": "<p>First, <code>[basic.life]/8</code> clearly states that any pointers or references to the original <code>foo</code> shall refer to the new object you construct at <code>foo</code> in your case.  In addition, the name <code>foo</code> will refer to the new object constructed there (also <code>[basic.life]/8</code>).</p>\n<p>Second, you <em>must</em> ensure that there is an object of the original type the storage used for <code>foo</code> before exiting its scope; so if anything throws, you must catch it and terminate your program (<code>[basic.life]/9</code>).</p>\n<p>Overall, this idea is often tempting, but almost always a horrible idea.</p>\n<blockquote>\n<ul>\n<li><p id=\"so_42598915_42599381_0\">(8) If, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, a new object is created at the storage location which the original object occupied, a pointer that pointed to the original object, a reference that referred to the original object, or the name of the original object will automatically refer to the new object and, once the lifetime of the new object has started, can be used to manipulate the new object, if:</p>\n<ul>\n<li>(8.1) the storage for the new object exactly overlays the storage location which the original object occupied, and</li>\n<li>(8.2) the new object is of the same type as the original object (ignoring the top-level cv-qualifiers), and</li>\n<li>(8.3) the type of the original object is not const-qualified, and, if a class type, does not contain any non-static\n  data member whose type is const-qualified or a reference type, and</li>\n<li>(8.4) the original object was a most derived object (1.8) of type\n  T and the new object is a most derived\n  object of type T (that is, they are not base class subobjects).</li>\n</ul></li>\n<li><p id=\"so_42598915_42599381_1\">(9) If a program ends the lifetime of an object of type T with static (3.7.1), thread (3.7.2), or automatic (3.7.3) storage duration and if T has a non-trivial destructor, the program must ensure that an object of the\n  original type occupies that same storage location when the implicit destructor call takes place; otherwise the behavior of the program is undefined. This is true even if the block is exited with an exception.</p></li>\n</ul>\n</blockquote>\n<p>There are reasons to manually run destructors and do placement new.  Something as simple as <code>operator=</code> <strong>is not one of them</strong>, unless you are writing your own variant/any/vector or similar type.</p>\n<p>If you really, really want to reassign an object, find a <code>std::optional</code> implementation, and create/destroy objects using that; it is careful, and you almost certainly won't be careful enough.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "42599381", "Score": "10", "CreationDate": "2017-03-04T18:01:24.260", "LastActivityDate": "2017-03-04T18:01:24.260"}});