post_cb({"38506473": {"ViewCount": "2318", "Body": "<p>I have seen many times that <code>std::string::operator[]</code> does not do any bounds checking.  Even <a href=\"https://stackoverflow.com/questions/14699060/in-c-what-is-the-difference-between-stringat-and-stringoperator\">What is the difference between string::at and string::operator[]?</a>, asked in 2013, the answers say that <code>operator[]</code> does not do any bounds checking.</p>\n<p>My issue with this is if I look at the standard (in this case <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow noreferrer\">draft N3797</a>) in [string.access] we have </p>\n<blockquote id=\"so_38506473_38506473_0\">\n<pre><code>const_reference operator[](size_type pos) const;\nreference operator[](size_type pos);\n</code></pre>\n<ol>\n<li><em>Requires:</em> <code>pos &lt;= size()</code>.</li>\n<li><em>Returns:</em> <code>*(begin() + pos)</code> if <code>pos &lt; size()</code>. Otherwise, returns a reference to an object of type <code>charT</code> with value <code>charT()</code>, where modifying the object leads to undefined behavior.</li>\n<li><em>Throws:</em> Nothing.</li>\n<li><em>Complexity:</em> constant time.</li>\n</ol>\n</blockquote>\n<p>This leads me to believe that <code>operator[]</code> has to do some sort of bounds checking to determine if it needs to return a element of the string or a default <code>charT</code>.  Is this assumption correct and <code>operator[]</code> is now required to do bounds checking?</p>\n", "AcceptedAnswerId": "38506592", "Title": "In C++11 and beyond does std::string::operator[] do bounds checking?", "CreationDate": "2016-07-21T14:05:56.403", "Id": "38506473", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:34:23.013", "LastEditorUserId": "-1", "LastActivityDate": "2016-10-03T11:06:43.843", "Score": "25", "OwnerUserId": "4342498", "Tags": "<c++><string><c++11><c++14><arrayaccess>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_38506473_38506473_0": {"length": 18, "quality": 0.5294117647058824, "section_id": 1617}}, "n3337": {"so_38506473_38506473_0": {"length": 18, "quality": 0.5294117647058824, "section_id": 1613}}, "n4659": {"so_38506473_38506473_0": {"length": 18, "quality": 0.5294117647058824, "section_id": 1770}}}, "38506592": {"Id": "38506592", "PostTypeId": "2", "Body": "<p>The wording is slightly confusing, but if you study it in detail you'll find that it's actually very precise.</p>\n<p>It says this:</p>\n<ul>\n<li>The precondition is that the argument to <code>[]</code> is either = <em>n</em> or it's &lt; <em>n</em>.</li>\n<li>Assuming that precondition is satisfied:\n\n<ul>\n<li>If it's &lt; <em>n</em> then you get the character you asked for.</li>\n<li>\"Otherwise\" (i.e. if it's <em>n</em>) then you get <code>charT()</code> (i.e. the null character).</li>\n</ul></li>\n</ul>\n<p>But no rule is defined for when you break the precondition, and <strong>the check for = <em>n</em> can be satisfied implicitly (but isn't explicitly mandated to be) by actually storing a <code>charT()</code> at position <em>n</em></strong>.</p>\n<p>So implementations don't need to perform any bounds checking\u2026 and the common ones won't.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2016-07-22T16:06:17.453", "Score": "43", "CreationDate": "2016-07-21T14:11:24.227", "ParentId": "38506473", "CommentCount": "13", "LastEditDate": "2016-07-22T16:06:17.453", "OwnerUserId": "560648"}, "38506552": {"Id": "38506552", "PostTypeId": "2", "Body": "<p>This operator of standard containers emulates the behavior of the operator [] of ordinary arrays. So it does not make any checks. However in the debug mode the corresponding library can provide this checking.</p>\n<p>If you want to check the index then use member function <code>at()</code> instead.</p>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2016-07-21T14:16:47.180", "Score": "2", "CreationDate": "2016-07-21T14:09:31.490", "ParentId": "38506473", "CommentCount": "0", "LastEditDate": "2016-07-21T14:16:47.180", "OwnerUserId": "2877241"}, "38506512": {"Id": "38506512", "PostTypeId": "2", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/string/basic_string/operator_at\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/string/basic_string/operator_at</a></p>\n<blockquote>\n<p id=\"so_38506473_38506512_0\">Returns a reference to the character at specified location pos. <strong>No\n  bounds checking is performed.</strong></p>\n</blockquote>\n<p>(Emphasis mine).</p>\n<p>If you want bounds checking, use <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/at\" rel=\"nofollow\">std::basic_string::at</a></p>\n<p>The standard imply the implementation needs to provide bounds checking because it basically describes what an unchecked array access does.</p>\n<p>If you access within bounds, it's defined. If you step outside, you trigger undefined behavior. </p>\n", "LastEditorUserId": "1084774", "LastActivityDate": "2016-07-21T14:22:50.547", "Score": "1", "CreationDate": "2016-07-21T14:07:45.593", "ParentId": "38506473", "CommentCount": "3", "LastEditDate": "2016-07-21T14:22:50.547", "OwnerUserId": "1084774"}, "38506795": {"Id": "38506795", "PostTypeId": "2", "Body": "<p>First, there is a requires clause.  If you violate the requires clause, your program behaves in an undefined manner.  That is <code>pos &lt;= size()</code>.</p>\n<p>So the language only defines what happens in that case.</p>\n<p>The next paragraph states that for <code>pos &lt; size()</code>, it returns a reference to an element in the string.  And for <code>pos == size()</code>, it returns a reference to a default constructed <code>charT</code> with value <code>charT()</code>.</p>\n<p>While this may look like bounds checking, in practice what actually happens is that the <code>std::basic_string</code> allocates a buffer one larger than asked and populates the last entry with a <code>charT()</code>.  Then <code>[]</code> simply does pointer arithemetic.</p>\n<p>I have tried to come up with a way to avoid that implementation.  While the standard does not mandate it, I could not convince myself an alternative exists.  There was something annoying with <code>.data()</code> that made it difficult to avoid the single buffer.</p>\n", "LastActivityDate": "2016-07-21T14:20:14.053", "Score": "4", "CreationDate": "2016-07-21T14:20:14.053", "ParentId": "38506473", "CommentCount": "0", "OwnerUserId": "1774667"}, "38506560": {"Id": "38506560", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_38506473_38506560_0\"><code>operator[]</code> has do some sort of bounds checking to determine...</p>\n</blockquote>\n<p>No it doesn't. With the precondition </p>\n<blockquote>\n<p id=\"so_38506473_38506560_1\">Requires: pos &lt;= size().</p>\n</blockquote>\n<p>it can just <strong>ASSUME</strong> that it can always return an element of the string. If this condition isn't met: Undefined behaviour.</p>\n<p>The <code>operator[]</code> will likely just increment the pointer from the start of the string by pos. If the string is shorter, well then it just returns a reference to the data behind the string, whatever it might be. Like a classic out of bounds in simple C arrays. </p>\n<p>To fullify the case of where <code>pos == size()</code> it could just have allocated an extra <code>charT</code> at the end of its internal string data. So just incrementing the pointer without any checks, would still deliver the stated behaviour. </p>\n", "LastEditorUserId": "3980929", "LastActivityDate": "2016-10-03T11:06:43.843", "Score": "14", "CreationDate": "2016-07-21T14:09:58.443", "ParentId": "38506473", "CommentCount": "2", "LastEditDate": "2016-10-03T11:06:43.843", "OwnerUserId": "3537677"}});