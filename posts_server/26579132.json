post_cb({"26579132": {"CommentCount": "0", "ViewCount": "220", "PostTypeId": "1", "LastEditorUserId": "596781", "CreationDate": "2014-10-26T23:23:40.093", "LastActivityDate": "2014-10-27T00:13:45.527", "Title": "What is the post condition of a move constructor?", "AcceptedAnswerId": "26579257", "LastEditDate": "2014-10-26T23:37:08.510", "Id": "26579132", "Score": "3", "Body": "<p>Consider a class:</p>\n<pre><code>class foo {\npublic:\n  foo(foo &amp;&amp;rhs) { /* some code */ }\n  ~foo() noexcept { /* code that does destruction of owning objects */ }\nprivate:\n  /* some non-trivial pointer graph like structure */\n};\n</code></pre>\n<p>Assume:</p>\n<pre><code>{\n  foo &amp;f = get_from_other_class();\n  foo g = std::move(f);\n  // some time later f goes our of scope or the owning object is destroyed.\n}\n</code></pre>\n<p>What post conditions apply to <code>f</code> after <code>std::move(f)</code> has been executed?</p>\n<h3>Note</h3>\n<p>I have the suspicion that <code>f</code> must still be cleanly destructible (not destroying owning content of <code>g</code>) but I haven't found the corresponding quote in the <em>C++11</em> standard. I'm skimming through 12.8 copying and moving class objects. </p>\n", "Tags": "<c++><c++11><language-lawyer>", "OwnerUserId": "887836", "AnswerCount": "6"}, "26579203": {"ParentId": "26579132", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>since it is <code>move</code>, thus, after <code>g = std::move(f);</code>, semantic content of <code>f</code> should be invalidated, and <code>g</code> is validated. <code>move</code> only keeps <strong>one</strong> valid copy of semantic content. <br>the semantic of \"invalidate/validate\" depends on the class, for example, if <code>f</code> is a string, it should be set to be length of 0, if <code>f</code> is a thread, it should be set to <code>std::thread()</code>. However, <strong>the detailed behavior depends on the move constructor of the class</strong>. <br>surely <code>f</code> is still destructable.</br></br></p>\n", "OwnerUserId": "1889584", "LastEditorUserId": "1889584", "LastEditDate": "2014-10-26T23:38:31.007", "Id": "26579203", "Score": "-1", "CreationDate": "2014-10-26T23:32:21.083", "LastActivityDate": "2014-10-26T23:38:31.007"}, "26579368": {"ParentId": "26579132", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_26579132_26579368_0\">What post conditions apply to f after std::move(f) has been executed?</p>\n</blockquote>\n<p>This can largely be dictated by the author of <code>foo</code>, but also constrained by the algorithms (std or not) that place requirements on <code>foo</code>.</p>\n<p>Many algorithms will require that in its moved-from state <code>foo</code> be <code>Destructible</code> and can be assigned a new value.  But this depends on the context in which <code>foo</code> will be used.</p>\n<p>If <code>foo</code> is used with a std-library component, then the requirements are dictated by Table 20 -- MoveConstructible requirements:</p>\n<blockquote>\n<p id=\"so_26579132_26579368_1\">rv\u2019s state is unspecified [ Note:rv must still meet the requirements\n  of the library compo- nent that is using it. The operations listed in\n  those requirements must work as specified whether rv has been moved\n  from or not. \u2014 end note ]</p>\n</blockquote>\n<p>For example:  Let's say you call <code>std::sort</code> with a <code>vector&lt;foo&gt;</code>.  <code>std::sort</code> will require of <code>foo</code>:  <code>Swappable</code>, <code>MoveConstructible</code>, <code>Destructible</code>, <code>MoveAssignable</code>, and <code>LessThanComparable</code>.</p>\n<p><code>std::sort</code> places these requirements on <code>foo</code> <strong>whether or not <code>foo</code> is in a moved-from state</strong>.</p>\n<p>Strictly speaking one should not need to have <code>foo</code> be <code>LessThanComparable</code> when in a moved-from state if using with <code>std::sort</code>.  It would be pointless for an implementor to compare a moved-from object since its value is unspecified.  Nevertheless, the C++11 and C++14 standards currently require <code>LessThanComparable</code>.  The result need not be sensible, but it is required to not crash if executed.  A future standard might relax this requirement, but who knows.</p>\n<p>So in summary, the author of <code>foo</code> can state what operations are allowed on a moved-from <code>foo</code>.</p>\n<p>And any algorithm can state what it requires of the types it operates on.</p>\n<p>In the intersection where <code>foo</code> meets the requirements of an algorithm, code works.  The C++ standard does not consider a moved-from state special.</p>\n", "OwnerUserId": "576911", "PostTypeId": "2", "Id": "26579368", "Score": "2", "CreationDate": "2014-10-26T23:53:39.410", "LastActivityDate": "2014-10-26T23:53:39.410"}, "26579294": {"ParentId": "26579132", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The moved from object must be ready for a destructor to run. </p>\n<p>Per Stroustrup, <em>C++ Programming Language, 4th Edition 2014</em></p>\n<blockquote>\n<p id=\"so_26579132_26579294_0\">If x is moved from, x will have \"some moved-from state\"...</p>\n<p id=\"so_26579132_26579294_1\">\"for the most interesting case, containers, that\n  moved-from state is \"empty\" \"...</p>\n</blockquote>\n<p>I tend to consider it akin to a default initialized variable.</p>\n<p>The value of builtin-types are unchanged after move.</p>\n<p>The <code>default moved-from state</code> is one where the default destructor and the default copy assignment work correctly.</p>\n<p>One of the definitions of that is if the destructor runs, any resource formerly managed by the object will no longer be managed by the object; the destructor will leave it alone, or be unaware. I suppose this is implementation / user dependent.  </p>\n<p>In short, you can do whatever correct thing you want with <code>x</code> and it shall be correct, as with a new variable.</p>\n", "OwnerUserId": "257090", "LastEditorUserId": "257090", "LastEditDate": "2014-10-27T00:13:23.320", "Id": "26579294", "Score": "1", "CreationDate": "2014-10-26T23:44:41.023", "LastActivityDate": "2014-10-27T00:13:23.320"}, "26579280": {"ParentId": "26579132", "CommentCount": "0", "Body": "<p>Table 20 (\u00a7 17.6.3.1) defines MoveConstructible requirements:</p>\n<pre>+------------+----------------------------------------------------------------+\n| Expression |                         Post-condition                         |\n+------------+----------------------------------------------------------------+\n| T u = rv;  | u is equivalent to the value of rv before the construction     |\n| T(rv)      | T(rv) is equivalent to the value of rv before the construction |\n+------------+----------------------------------------------------------------+</pre>\n<blockquote>\n<p id=\"so_26579132_26579280_0\">rv\u2019s state is unspecified [ <em>Note</em>: rv must still meet the\n  requirements of the library component that is using it. The\n  operations listed in those requirements must work as specified whether\n  rv has been moved from or not. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>The note indicates that per @Kerrek's answer that a library component may have different requirements.</p>\n", "Id": "26579280", "PostTypeId": "2", "OwnerDisplayName": "user3920237", "Score": "1", "CreationDate": "2014-10-26T23:43:00.170", "LastActivityDate": "2014-10-26T23:43:00.170"}, "26579257": {"ParentId": "26579132", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Every object must be destructible, unless you only ever allocate it dynamically. After having been \"moved from\", i.e. having its value bound to an rvalue reference (such as the first parameter of a move constructor), an object is still required to be valid and destructible, but typically it can be in an \"unspecified\" state and you are simply not supposed to look at the object any more and either let it go out of scope or reassign it.</p>\n<p>Some types make stronger guarantees, for example <code>std::unique_ptr</code> promised that when move-constructing, it leaves the moved-from object in a state equal to <code>nullptr</code>.</p>\n<p>The general idea behind rvalues and rvalue references is that an object that an rvalue should have no aliases, and specifically, when an object is bound to an rvalue reference, then there is no other alias of the object. The standard library makes those assumptions for the rvalue reference interfaces it exposes.</p>\n", "OwnerUserId": "596781", "LastEditorUserId": "1938163", "LastEditDate": "2014-10-27T00:13:45.527", "Id": "26579257", "Score": "3", "CreationDate": "2014-10-26T23:39:34.973", "LastActivityDate": "2014-10-27T00:13:45.527"}, "26579302": {"ParentId": "26579132", "CommentCount": "0", "Body": "<p>The post-condition is that your moved-from object is in an unspecified, but valid state. And it is precisely that: it is unspecified, meaning that it can be whatever you choose it to be (or the library implementor) as long as it is valid.</p>\n", "OwnerUserId": "104427", "PostTypeId": "2", "Id": "26579302", "Score": "2", "CreationDate": "2014-10-26T23:46:03.133", "LastActivityDate": "2014-10-26T23:46:03.133"}, "bq_ids": {"n4140": {"so_26579132_26579280_0": {"section_id": 6276, "quality": 0.8333333333333334, "length": 20}, "so_26579132_26579368_1": {"section_id": 6276, "quality": 0.76, "length": 19}}, "n3337": {"so_26579132_26579280_0": {"section_id": 6036, "quality": 0.8333333333333334, "length": 20}, "so_26579132_26579368_1": {"section_id": 6036, "quality": 0.76, "length": 19}}, "n4659": {"so_26579132_26579280_0": {"section_id": 7783, "quality": 0.8333333333333334, "length": 20}, "so_26579132_26579368_1": {"section_id": 7783, "quality": 0.76, "length": 19}}}});