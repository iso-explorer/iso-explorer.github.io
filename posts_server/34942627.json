post_cb({"34943090": {"Id": "34943090", "PostTypeId": "2", "Body": "<p>The accepted answer is incorrect. While it is true that: <code>template &lt;typename T&gt; A(T &amp;&amp;t) { }</code> is not a move constructor, you already knew that. The compiler will implicitly declare a move constructor in this case and normal overload resolution will work as expected:</p>\n<pre><code>A a{2}; // calls template\nA b = std::move(a); // calls move\nA c{a}; // calls template\n</code></pre>\n<p>There is nothing precluding <code>a</code> from being moved into <code>c</code>, even though the template constructor isn't a \"move\" constructor.</p>\n", "LastActivityDate": "2016-01-22T09:23:00.823", "CommentCount": "1", "CreationDate": "2016-01-22T09:23:00.823", "ParentId": "34942627", "Score": "5", "OwnerUserId": "5825406"}, "bq_ids": {"n4140": {"so_34942627_34942954_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 452}}, "n3337": {"so_34942627_34942954_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 443}}, "n4659": {"so_34942627_34942954_0": {"length": 27, "quality": 0.9310344827586207, "section_id": 475}}}, "34942627": {"ViewCount": "213", "Body": "<p>Does this template ctor hide move ctor?</p>\n<pre><code>class A {\n    public:\n        template&lt;typename T&gt;\n        A(T &amp;&amp;t);\n\n        // move would be as this:\n        /*\n            A(A &amp;&amp;a);\n        */\n};\n</code></pre>\n<p>And how in this situation should I implement move ctor then? Should it be with default syntax <code>A (A &amp;&amp;)</code> or a template specialization?</p>\n", "AcceptedAnswerId": "34942954", "Title": "Does template constructor with universal reference hide move construtor?", "CreationDate": "2016-01-22T08:59:06.003", "Id": "34942627", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-01-22T09:40:14.260", "Score": "6", "OwnerUserId": "1750757", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "34942954": {"Id": "34942954", "PostTypeId": "2", "Body": "<p>According to the standard (draft) </p>\n<p>[class.copy]</p>\n<blockquote>\n<p id=\"so_34942627_34942954_0\">3 A <strong>non-template</strong> constructor for class X is a move constructor if its first parameter is of type X&amp;&amp;, const X&amp;&amp;, volatile X&amp;&amp;, or const volatile X&amp;&amp;, and either there are no other parameters or else all other parameters have default arguments (8.3.6). [ Example: Y::Y(Y&amp;&amp;) is a move constructor.</p>\n</blockquote>\n<p>Only non-template constructors can be move constructors. Same applies to copy constructors<sup>\u2020</sup>. Therefore the implicit move constructor is generated.</p>\n<p>You implement the move constructor in the usual way. Specialization won't work because the implicit non-template move constructor is preferred by the overload resolution.</p>\n<p><sup>\u2020</sup> If the argument type does not match exactly to <code>const T&amp;</code>, however, the templated reference wins the overload resolution. This can easily happen as can be seen in Praveen's example.</p>\n", "LastEditorUserId": "2079303", "LastActivityDate": "2016-01-22T09:40:14.260", "Score": "3", "CreationDate": "2016-01-22T09:15:52.400", "ParentId": "34942627", "CommentCount": "2", "OwnerUserId": "2079303", "LastEditDate": "2016-01-22T09:40:14.260"}});