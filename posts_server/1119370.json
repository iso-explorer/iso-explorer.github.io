post_cb({"1119390": {"ParentId": "1119370", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>From <a href=\"http://en.wikipedia.org/wiki/Stdlib.h\" rel=\"noreferrer\">Wikipedia</a></p>\n<blockquote>\n<p id=\"so_1119370_1119390_0\">The <code>stdlib.h</code> and <code>stddef.h</code> header files define a datatype called <code>size_t</code><a href=\"http://en.wikipedia.org/wiki/Stdlib.h\" rel=\"noreferrer\">1</a> which is used to represent the size of an object. Library functions that take sizes expect them to be of type <code>size_t</code>, and the sizeof operator evaluates to <code>size_t</code>.</p>\n<p id=\"so_1119370_1119390_1\">The actual type of <code>size_t</code> is platform-dependent; a common mistake is to assume <code>size_t</code> is the same as unsigned int, which can lead to programming errors,<a href=\"http://open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf#page=266\" rel=\"noreferrer\">2</a> particularly as 64-bit architectures become more prevalent.</p>\n</blockquote>\n<p>From <a href=\"http://open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf#page=266\" rel=\"noreferrer\">C99 7.17.1/2</a></p>\n<blockquote>\n<p id=\"so_1119370_1119390_2\">The following types and macros are defined in the standard header <code>stddef.h</code></p>\n<p id=\"so_1119370_1119390_3\">&lt;snip&gt;</p>\n<p id=\"so_1119370_1119390_4\"><code>size_t</code></p>\n<p id=\"so_1119370_1119390_5\">which is the unsigned integer type of the result of the sizeof operator</p>\n</blockquote>\n", "OwnerUserId": "98607", "LastEditorUserId": "228539", "LastEditDate": "2015-06-22T19:38:37.990", "Id": "1119390", "Score": "97", "CreationDate": "2009-07-13T13:18:41.080", "LastActivityDate": "2015-06-22T19:38:37.990"}, "15776655": {"ParentId": "1119370", "CommentCount": "1", "Body": "<p>According to <a href=\"http://en.cppreference.com/w/cpp/types/size_t\" rel=\"noreferrer\">size_t description on en.cppreference.com</a> <code>size_t</code> is defined in the following headers :</p>\n<pre><code>std::size_t\n\n...    \n\nDefined in header &lt;cstddef&gt;         \nDefined in header &lt;cstdio&gt;      \nDefined in header &lt;cstring&gt;         \nDefined in header &lt;ctime&gt;       \nDefined in header &lt;cwchar&gt;\n</code></pre>\n", "OwnerUserId": "45654", "PostTypeId": "2", "Id": "15776655", "Score": "11", "CreationDate": "2013-04-03T00:04:19.320", "LastActivityDate": "2013-04-03T00:04:19.320"}, "1119565": {"ParentId": "1119370", "CommentCount": "0", "Body": "<p>Practically speaking <code>size_t</code> represents the number of bytes you can address. On most modern architectures for the last 10-15 years that has been 32 bits which has also been the size of a unsigned int. However we are moving to 64bit addressing while the <code>uint</code> will most likely stay at 32bits (it's size is not guaranteed in the c++ standard). To make your code that depends on the memory size portable across architectures you should use a <code>size_t</code>. For example things like array sizes should always use <code>size_t</code>'s. If you look at the standard containers the <code>::size()</code> always returns a <code>size_t</code>.</p>\n<p>Also note, visual studio has a compile option that can check for these types of errors called \"Detect 64-bit Portability Issues\".</p>\n", "OwnerUserId": "852", "PostTypeId": "2", "Id": "1119565", "Score": "4", "CreationDate": "2009-07-13T13:52:05.127", "LastActivityDate": "2009-07-13T13:52:05.127"}, "1119414": {"ParentId": "1119370", "CommentCount": "0", "Body": "<p>size_t should be defined in your standard library's headers.  In my experience, it usually is simply a typedef to unsigned int.  The point, though, is that it doesn't have to be.\nTypes like size_t allow the standard library vendor the freedom to change its underlying data types if appropriate for the platform.  If you assume size_t is always unsigned int (via casting, etc), you could run into problems in the future if your vendor changes size_t to be e.g. a 64-bit type.  It is dangerous to assume anything about this or any other library type for this reason.</p>\n", "OwnerUserId": "99376", "PostTypeId": "2", "Id": "1119414", "Score": "2", "CreationDate": "2009-07-13T13:21:58.627", "LastActivityDate": "2009-07-13T13:21:58.627"}, "1119399": {"ParentId": "1119370", "CommentCount": "0", "Body": "<p>This way you always know what the size is, because a specific type is dedicated to sizes. The very own question shows that it can be an issue: is it an <code>int</code> or an <code>unsigned int</code>? Also, what is the magnitude (<code>short</code>, <code>int</code>, <code>long</code>, etc.)?</p>\n<p>Because there is a specific type assigned, you don't have to worry about the length or the signed-ness.</p>\n<p>The actual definition can be found in the <a href=\"http://www.cplusplus.com/reference/clibrary/cstring/size_t/\" rel=\"nofollow noreferrer\">C++ Reference Library</a>, which says:</p>\n<blockquote>\n<p id=\"so_1119370_1119399_0\">Type: <code>size_t</code> (Unsigned integral type)</p>\n<p id=\"so_1119370_1119399_1\">Header: <code>&lt;cstring&gt;</code></p>\n<p id=\"so_1119370_1119399_2\"><code>size_t</code> corresponds to the integral data type returned by the language operator <code>sizeof</code> and is defined in the <code>&lt;cstring&gt;</code> header file (among others) as an unsigned integral type.</p>\n<p id=\"so_1119370_1119399_3\">In <code>&lt;cstring&gt;</code>, it is used as the type of the parameter <code>num</code> in the functions <code>memchr</code>, <code>memcmp</code>, <code>memcpy</code>, <code>memmove</code>, <code>memset</code>, <code>strncat</code>, <code>strncmp</code>, <code>strncpy</code> and <code>strxfrm</code>, which in all cases it is used to specify the maximum number of bytes or characters the function has to affect.</p>\n<p id=\"so_1119370_1119399_4\">It is also used as the return type for <code>strcspn</code>, <code>strlen</code>, <code>strspn</code> and <code>strxfrm</code> to return sizes and lengths.</p>\n</blockquote>\n", "OwnerUserId": "49713", "PostTypeId": "2", "Id": "1119399", "Score": "2", "CreationDate": "2009-07-13T13:20:01.500", "LastActivityDate": "2009-07-13T13:20:01.500"}, "1123756": {"ParentId": "1119370", "CommentCount": "1", "Body": "<p>I'm not familiar with <code>void_t</code> except as a result of a Google search (it's used in <a href=\"http://www.research.att.com/~gsf/man/man3/vmalloc.html\" rel=\"nofollow noreferrer\">a <code>vmalloc</code> library by Kiem-Phong Vo at AT&amp;T Research</a> - I'm sure it's used in other libraries as well).</p>\n<p>The various xxx_t typedefs are used to abstract a type from a particular definite implementation, since the concrete types used for certain things might differ from one platform to another.  For example:</p>\n<ul>\n<li>size_t abstracts the type used to hold the size of objects because on some systems this will be a 32-bit value, on others it might be 16-bit or 64-bit.</li>\n<li><code>Void_t</code> abstracts the type of pointer returned by the <code>vmalloc</code> library routines because it was written to work on systems that pre-date ANSI/ISO C where the <code>void</code> keyword might not exist.  At least that's what I'd guess.</li>\n<li><code>wchar_t</code> abstracts the type used for wide characters since on some systems it will be a 16 bit type, on others it will be a 32 bit type.</li>\n</ul>\n<p>So if you write your wide character handling code to use the <code>wchar_t</code> type instead of, say <code>unsigned short</code>, that code will presumably be more portable to various platforms.</p>\n", "OwnerUserId": "12711", "PostTypeId": "2", "Id": "1123756", "Score": "1", "CreationDate": "2009-07-14T06:27:28.030", "LastActivityDate": "2009-07-14T06:27:28.030"}, "18156228": {"ParentId": "1119370", "CommentCount": "0", "Body": "<p>As for \"Why not use int or unsigned int?\", simply because it's semantically more meaningful not to. There's the practical reason that it can be, say, <code>typedef</code>d as an <code>int</code> and then upgraded to a <code>long</code> later, without anyone having to change their code, of course, but more fundamentally than that a type is supposed to be meaningful. To vastly simplify, a variable of type <code>size_t</code> is suitable for, and used for, containing the sizes of things, just like <code>time_t</code> is suitable for containing time values. How these are actually implemented should quite properly be the implementation's job. Compared to just calling everything <code>int</code>, using meaningful typenames like this helps clarify the meaning and intent of your program, just like any rich set of types does.</p>\n", "OwnerUserId": "2399879", "PostTypeId": "2", "Id": "18156228", "Score": "1", "CreationDate": "2013-08-09T21:54:26.450", "LastActivityDate": "2013-08-09T21:54:26.450"}, "1119484": {"ParentId": "1119370", "PostTypeId": "2", "CommentCount": "5", "Body": "<p><code>size_t</code> is the unsigned integer type of the result of the sizeof operator (ISO C99 Section 7.17.)</p>\n<p>The <code>sizeof</code> operator yields the size (in bytes) of its operand, which may be an\nexpression or the parenthesized name of a type. The size is determined from the type of\nthe operand. The result is an integer. The value of the result is implementation-de\ufb01ned, and \nits type (an unsigned integer type) is <code>size_t</code> (ISO C99 Section 6.5.3.4.)</p>\n", "OwnerUserId": "127259", "LastEditorUserId": "417685", "LastEditDate": "2013-07-24T10:07:22.400", "Id": "1119484", "Score": "20", "CreationDate": "2009-07-13T13:36:02.743", "LastActivityDate": "2013-07-24T10:07:22.400"}, "1119370": {"CommentCount": "10", "ViewCount": "135320", "ClosedDate": "2013-08-10T09:11:59.400", "CreationDate": "2009-07-13T13:14:10.277", "LastActivityDate": "2015-06-22T19:38:37.990", "PostTypeId": "1", "AcceptedAnswerId": "1119390", "FavoriteCount": "17", "Title": "Where do I find the definition of size_t?", "Id": "1119370", "Score": "92", "Body": "<p>I see variables defined with this type but I don't know where it comes from, nor what is its purpose. Why not use int or unsigned int? (What about other \"similar\" types? Void_t, etc).</p>\n", "Tags": "<c++><c><variables>", "OwnerUserId": "121487", "AnswerCount": "9"}, "bq_ids": {"n4140": {"so_1119370_1119390_5": {"section_id": 3291, "quality": 0.6666666666666666, "length": 4}, "so_1119370_1119390_2": {"section_id": 6332, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_1119370_1119390_5": {"section_id": 3358, "quality": 0.6666666666666666, "length": 4}, "so_1119370_1119390_2": {"section_id": 6089, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_1119370_1119390_5": {"section_id": 7797, "quality": 0.8333333333333334, "length": 5}, "so_1119370_1119390_2": {"section_id": 7842, "quality": 0.5714285714285714, "length": 4}}}, "18153990": {"ParentId": "1119370", "CommentCount": "0", "Body": "<p>In minimalistic programs where a <code>size_t</code> definition was not loaded \"by chance\" in some include but I still need it in some context (for example to access <code>std::vector&lt;double&gt;</code>), then I use <em>that</em> context to extract the correct type. For example <code>typedef std::vector&lt;double&gt;::size_type size_t</code>.</p>\n<p>(Surround with <code>namespace {...}</code> if necessary to make the scope limited.)</p>\n", "OwnerUserId": "225186", "PostTypeId": "2", "Id": "18153990", "Score": "1", "CreationDate": "2013-08-09T19:12:00.660", "LastActivityDate": "2013-08-09T19:12:00.660"}});