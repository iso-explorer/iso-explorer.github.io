post_cb({"bq_ids": {"n4140": {"so_17979857_17980055_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 599}, "so_17979857_17980055_2": {"length": 20, "quality": 1.0, "section_id": 599}, "so_17979857_17980055_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 599}}, "n3337": {"so_17979857_17980055_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 589}, "so_17979857_17980055_2": {"length": 20, "quality": 1.0, "section_id": 589}, "so_17979857_17980055_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 589}}, "n4659": {"so_17979857_17980055_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 622}, "so_17979857_17980055_2": {"length": 20, "quality": 1.0, "section_id": 622}, "so_17979857_17980055_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 622}}}, "17980055": {"Id": "17980055", "PostTypeId": "2", "Body": "<p>From \u00a713.3.2/1 ([over.match.list])</p>\n<blockquote>\n<p id=\"so_17979857_17980055_0\">When objects of non-aggregate class type <code>T</code> are list-initialized\n  (8.5.4), overload resolution selects the constructor in two phases: </p>\n<p id=\"so_17979857_17980055_1\">\u2014 Initially, the candidate functions are the initializer-list\n  constructors (8.5.4) of the class <code>T</code> and the argument list consists of\n  the initializer list as a single argument. </p>\n<p id=\"so_17979857_17980055_2\">\u2014 If no viable\n  initializer-list constructor is found, overload resolution is\n  performed again, where the candidate functions are all the\n  constructors of the class <code>T</code> and the argument list consists of the\n  elements of the initializer list.</p>\n</blockquote>\n<p>In your case the initializer list constructor is deemed non-viable (because <code>std::istream_iterator&lt;std::string&gt;</code> is not convertible to <code>std::string</code>), and the second condition applies. This results in the constructor taking 2 iterators to be selected.</p>\n", "LastActivityDate": "2013-07-31T20:14:12.033", "CommentCount": "1", "CreationDate": "2013-07-31T20:14:12.033", "ParentId": "17979857", "Score": "5", "OwnerUserId": "241631"}, "17979857": {"ViewCount": "535", "Body": "<p>It's possible to construct a vector with an iterator range, like this:</p>\n<pre><code>std::vector&lt;std::string&gt; vec(std::istream_iterator&lt;std::string&gt;{std::cin},\n                             std::istream_iterator&lt;std::string&gt;{});\n</code></pre>\n<p>But I can also compile and run code using C++11 uniform initialization syntax (note the bracers), like this:</p>\n<pre><code>std::vector&lt;std::string&gt; vec{std::istream_iterator&lt;std::string&gt;{std::cin},\n                             std::istream_iterator&lt;std::string&gt;{}};\n</code></pre>\n<p>What's really going on here?</p>\n<p>I know that a constructor taking an initializer list <em>gets priority over other forms of construction</em>. Shouldn't the compiler resolve to the constructor taking an initializer list containing 2 elements of <code>std::istream_iterator</code>? This should be an error as a <code>std::istream_iterator</code> can't be converted to the vectors value type <code>std::string</code>, right?</p>\n", "AcceptedAnswerId": "17980055", "Title": "Construct container with initializer list of iterators", "CreationDate": "2013-07-31T20:03:56.973", "Id": "17979857", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-07-31T23:59:12.100", "LastEditorUserId": "873025", "LastActivityDate": "2013-07-31T23:59:12.100", "Score": "6", "OwnerUserId": "873025", "Tags": "<c++><c++11><iterator><uniform-initialization>", "AnswerCount": "1"}});