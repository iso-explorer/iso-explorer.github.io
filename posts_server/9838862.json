post_cb({"9838862": {"CommentCount": "3", "AcceptedAnswerId": "9838934", "PostTypeId": "1", "LastEditorUserId": "415784", "CreationDate": "2012-03-23T12:01:53.263", "LastActivityDate": "2013-02-22T07:03:12.770", "LastEditDate": "2013-02-22T07:02:15.703", "ViewCount": "1758", "FavoriteCount": "4", "Title": "Why Argument Dependent Lookup doesn't work with function template dynamic_pointer_cast", "Id": "9838862", "Score": "26", "Body": "<p>Consider the following C++ program:</p>\n<pre><code>#include &lt;memory&gt;\n\nstruct A {};\n\nstruct B : A {};\n\nint main()\n{\n    auto x = std::make_shared&lt;A&gt;();\n    if (auto p = dynamic_pointer_cast&lt;B&gt;(x));\n}\n</code></pre>\n<p>When compiling with MSVC 2010, I obtain the following error:</p>\n<pre><code>error C2065: 'dynamic_pointer_cast' : undeclared identifier\n</code></pre>\n<p>The error persists if <code>auto</code> is replaced by <code>std::shared_ptr&lt;A&gt;</code>. When I fully qualify the call with <code>std::dynamic_pointer_cast</code>, the program successfully compiles.</p>\n<p>Also, <a href=\"http://ideone.com/Z28dC\">gcc 4.5.1</a> doesn't like it either:</p>\n<pre><code>error: 'dynamic_pointer_cast' was not declared in this scope\n</code></pre>\n<p>I thought that <code>std::dynamic_pointer_cast</code> would have been picked by <a href=\"http://en.wikipedia.org/wiki/Argument-dependent_name_lookup\">Koenig lookup</a>, since the type of <code>x</code> lives in the <code>std</code> namespace. What am I missing here ?</p>\n", "Tags": "<c++><argument-dependent-lookup>", "OwnerUserId": "373025", "AnswerCount": "2"}, "9838934": {"ParentId": "9838862", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>I think section \u00a714.8.1/6 (C++03, and I think it holds in C++11 also) applies to this case which reads as,</p>\n<blockquote>\n<p id=\"so_9838862_9838934_0\">[Note: For simple function names, argument dependent lookup (3.4.2) applies even when the function name is not visible within the scope of the call. This is because the call still has the syntactic form of a function call (3.4.1). <strong>But when a function template with explicit template arguments is used, the call does not have the correct syntactic form unless there is a function template with that name visible at the point of the call. If no such name is visible, the call is not syntactically well-formed and argument-dependent lookup does not apply.</strong> If some such name is visible, argument dependent lookup applies and additional function templates may be found in other namespaces.</p>\n<p id=\"so_9838862_9838934_1\">[Example:</p>\n<pre><code>namespace A {\n     struct B { };\n     template&lt;int X&gt; void f(B);\n}\nnamespace C {\n     template&lt;class T&gt; void f(T t);\n}\nvoid g(A::B b) {\n     f&lt;3&gt;(b);    //ill-formed: not a function call\n     A::f&lt;3&gt;(b); //well-formed\n     C::f&lt;3&gt;(b); //ill-formed; argument dependent lookup\n                 // applies only to unqualified names\n\n    using C::f;\n     f&lt;3&gt;(b); //well-formed because C::f is visible; then\n              // A::f is found by argument dependent lookup\n}\n</code></pre>\n<p id=\"so_9838862_9838934_2\">\u2014end example] \u2014end note] </p>\n</blockquote>\n<p>Your case do not trigger ADL because you explicitly pass template argument <strong>and</strong> there is no template with the same name available at the site where you call <code>dynamic_pointer_cast</code>.</p>\n<p>One trick to enable ADL is to add a dummy template with <em>same</em> name to your code, as shown below:</p>\n<pre><code>#include &lt;memory&gt;\n\nstruct A {};\n\nstruct B : A {};\n\ntemplate&lt;int&gt; //template parameter could be anything!\nvoid dynamic_pointer_cast(); //ADD this. NO NEED TO DEFINE IT\n\nint main()\n{\n   auto x = std::make_shared&lt;A&gt;();\n   if (auto p = dynamic_pointer_cast&lt;B&gt;(x)); //now it should work through ADL\n}\n</code></pre>\n", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2013-02-22T07:03:12.770", "Id": "9838934", "Score": "24", "CreationDate": "2012-03-23T12:07:30.613", "LastActivityDate": "2013-02-22T07:03:12.770"}, "bq_ids": {"n4140": {"so_9838862_9838934_0": {"section_id": 291, "quality": 0.9305555555555556, "length": 67}}, "n3337": {"so_9838862_9838934_0": {"section_id": 282, "quality": 0.9305555555555556, "length": 67}}, "n4659": {"so_9838862_9838934_0": {"section_id": 298, "quality": 0.9305555555555556, "length": 67}}}, "9838947": {"ParentId": "9838862", "CommentCount": "4", "Body": "<p>Koenig lookup only applies to finding functions.  Here, you first have to find a template, then instantiate it, before you have a function.  In order to simply parse the code, the compiler has to know that <code>dynamic_pointer_cast</code> is a template (otherwise, '&lt;' is less than, and not the start of a template argument list); until the compiler knows that <code>dynamic_pointer_cast</code> is a function template, it doesn't even know that a function call is involved.  The expression it sees is basically <code>a &lt; b &gt; c</code>, where <code>&lt;</code> and <code>&gt;</code> are the relational operators.</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "9838947", "Score": "18", "CreationDate": "2012-03-23T12:08:24.253", "LastActivityDate": "2012-03-23T12:08:24.253"}});