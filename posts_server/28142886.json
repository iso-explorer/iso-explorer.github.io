post_cb({"bq_ids": {"n4140": {"so_28142886_28143734_4": {"length": 10, "quality": 0.8333333333333334, "section_id": 2277}, "so_28142886_28143734_1": {"length": 10, "quality": 1.0, "section_id": 2308}, "so_28142886_28143734_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 2277}, "so_28142886_28143734_0": {"length": 4, "quality": 0.8, "section_id": 2299}}, "n3337": {"so_28142886_28143734_4": {"length": 10, "quality": 0.8333333333333334, "section_id": 2265}, "so_28142886_28143734_1": {"length": 10, "quality": 1.0, "section_id": 2296}, "so_28142886_28143734_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 2265}, "so_28142886_28143734_0": {"length": 4, "quality": 0.8, "section_id": 2286}}, "n4659": {"so_28142886_28143734_4": {"length": 10, "quality": 0.8333333333333334, "section_id": 2550}, "so_28142886_28143734_1": {"length": 10, "quality": 1.0, "section_id": 2582}, "so_28142886_28143734_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 2550}, "so_28142886_28143734_0": {"length": 4, "quality": 0.8, "section_id": 2572}}}, "28142886": {"ViewCount": "86", "Body": "<p>Why does this code run successfully on g++ and clang (<a href=\"http://coliru.stacked-crooked.com/a/8c88801b6890fe14\" rel=\"nofollow\">libstdc++</a>) but give a segmentation fault with <a href=\"http://coliru.stacked-crooked.com/a/6a7d1acc1560bc0c\" rel=\"nofollow\">libc++</a>:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>#include &lt;iostream&gt;\n\nint main()\n{\n    std::cout.tie(&amp;std::cout);\n    std::cout &lt;&lt; 123;\n}\n</code></pre>\n<p>What I think should happen is that <code>std::cout.flush()</code> should be called before the output actually occurs. Why would this give a segmentation fault?</p>\n", "AcceptedAnswerId": "28143734", "Title": "Tying a stream to itself", "CreationDate": "2015-01-25T23:36:19.910", "Id": "28142886", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-01-26T04:48:09.580", "Score": "2", "OwnerUserId": "1594090", "Tags": "<c++><c++11><iostream>", "AnswerCount": "1"}, "28143734": {"Id": "28143734", "PostTypeId": "2", "Body": "<p>[ostream.unformatted]/p7:</p>\n<blockquote>\n<pre><code>basic_ostream&amp; flush();\n</code></pre>\n<p id=\"so_28142886_28143734_0\">7 Effects: Behaves as an unformatted output function [...]</p>\n</blockquote>\n<p>[ostream.unformatted]/p1:</p>\n<blockquote>\n<p id=\"so_28142886_28143734_1\">Each unformatted output function begins execution by constructing an\n  object of class <code>sentry</code>.</p>\n</blockquote>\n<p>[ostream::sentry]/p2:</p>\n<blockquote>\n<pre><code>explicit sentry(basic_ostream&lt;charT,traits&gt;&amp; os);\n</code></pre>\n<p id=\"so_28142886_28143734_2\">2 If <code>os.good()</code> is nonzero, prepares for formatted or unformatted\n  output. If <code>os.tie()</code> is not a null pointer, calls\n  <code>os.tie()-&gt;flush()</code>.<sup>324</sup></p>\n<p id=\"so_28142886_28143734_3\">3 [...]</p>\n<p id=\"so_28142886_28143734_4\"><sup>324</sup> The call <code>os.tie()-&gt;flush()</code> does not necessarily occur\n  if the function can determine that no synchronization is necessary.</p>\n</blockquote>\n<p>If you tie a stream to itself, then to flush the stream, it constructs a <code>sentry</code>, which tries to flush the stream, which constructs a <code>sentry</code>, which  tries to flush the stream, which constructs a <code>sentry</code>, which tries to flush the stream, which constructs a <code>sentry</code>......I think you see where this is going. </p>\n<p>If you get (un)lucky, the implementation might skip the <code>flush()</code> call somewhere per footnote 324; otherwise, you'll see the title of this site.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2015-01-26T04:48:09.580", "Score": "5", "CreationDate": "2015-01-26T01:44:56.223", "ParentId": "28142886", "CommentCount": "1", "OwnerUserId": "2756719", "LastEditDate": "2015-01-26T04:48:09.580"}});