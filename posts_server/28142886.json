post_cb({"28143734": {"ParentId": "28142886", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>[ostream.unformatted]/p7:</p>\n<blockquote>\n<pre><code>basic_ostream&amp; flush();\n</code></pre>\n<p id=\"so_28142886_28143734_0\">7 Effects: Behaves as an unformatted output function [...]</p>\n</blockquote>\n<p>[ostream.unformatted]/p1:</p>\n<blockquote>\n<p id=\"so_28142886_28143734_1\">Each unformatted output function begins execution by constructing an\n  object of class <code>sentry</code>.</p>\n</blockquote>\n<p>[ostream::sentry]/p2:</p>\n<blockquote>\n<pre><code>explicit sentry(basic_ostream&lt;charT,traits&gt;&amp; os);\n</code></pre>\n<p id=\"so_28142886_28143734_2\">2 If <code>os.good()</code> is nonzero, prepares for formatted or unformatted\n  output. If <code>os.tie()</code> is not a null pointer, calls\n  <code>os.tie()-&gt;flush()</code>.<sup>324</sup></p>\n<p id=\"so_28142886_28143734_3\">3 [...]</p>\n<p id=\"so_28142886_28143734_4\"><sup>324</sup> The call <code>os.tie()-&gt;flush()</code> does not necessarily occur\n  if the function can determine that no synchronization is necessary.</p>\n</blockquote>\n<p>If you tie a stream to itself, then to flush the stream, it constructs a <code>sentry</code>, which tries to flush the stream, which constructs a <code>sentry</code>, which  tries to flush the stream, which constructs a <code>sentry</code>, which tries to flush the stream, which constructs a <code>sentry</code>......I think you see where this is going. </p>\n<p>If you get (un)lucky, the implementation might skip the <code>flush()</code> call somewhere per footnote 324; otherwise, you'll see the title of this site.</p>\n", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2015-01-26T04:48:09.580", "Id": "28143734", "Score": "5", "CreationDate": "2015-01-26T01:44:56.223", "LastActivityDate": "2015-01-26T04:48:09.580"}, "28142886": {"CommentCount": "2", "ViewCount": "86", "CreationDate": "2015-01-25T23:36:19.910", "LastActivityDate": "2015-01-26T04:48:09.580", "Title": "Tying a stream to itself", "AcceptedAnswerId": "28143734", "PostTypeId": "1", "Id": "28142886", "Score": "2", "Body": "<p>Why does this code run successfully on g++ and clang (<a href=\"http://coliru.stacked-crooked.com/a/8c88801b6890fe14\" rel=\"nofollow\">libstdc++</a>) but give a segmentation fault with <a href=\"http://coliru.stacked-crooked.com/a/6a7d1acc1560bc0c\" rel=\"nofollow\">libc++</a>:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>#include &lt;iostream&gt;\n\nint main()\n{\n    std::cout.tie(&amp;std::cout);\n    std::cout &lt;&lt; 123;\n}\n</code></pre>\n<p>What I think should happen is that <code>std::cout.flush()</code> should be called before the output actually occurs. Why would this give a segmentation fault?</p>\n", "Tags": "<c++><c++11><iostream>", "OwnerUserId": "1594090", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_28142886_28143734_0": {"section_id": 2299, "quality": 0.8, "length": 4}, "so_28142886_28143734_2": {"section_id": 2277, "quality": 0.9090909090909091, "length": 10}, "so_28142886_28143734_4": {"section_id": 2277, "quality": 0.8333333333333334, "length": 10}, "so_28142886_28143734_1": {"section_id": 2308, "quality": 1.0, "length": 10}}, "n3337": {"so_28142886_28143734_0": {"section_id": 2286, "quality": 0.8, "length": 4}, "so_28142886_28143734_2": {"section_id": 2265, "quality": 0.9090909090909091, "length": 10}, "so_28142886_28143734_4": {"section_id": 2265, "quality": 0.8333333333333334, "length": 10}, "so_28142886_28143734_1": {"section_id": 2296, "quality": 1.0, "length": 10}}, "n4659": {"so_28142886_28143734_0": {"section_id": 2572, "quality": 0.8, "length": 4}, "so_28142886_28143734_2": {"section_id": 2550, "quality": 0.9090909090909091, "length": 10}, "so_28142886_28143734_4": {"section_id": 2550, "quality": 0.8333333333333334, "length": 10}, "so_28142886_28143734_1": {"section_id": 2582, "quality": 1.0, "length": 10}}}});