post_cb({"17771671": {"CommentCount": "7", "ViewCount": "344", "CreationDate": "2013-07-21T11:07:30.213", "LastActivityDate": "2013-07-21T13:27:21.807", "Title": "Ambiguous overload on function pointer and std::function", "AcceptedAnswerId": "17772810", "PostTypeId": "1", "Id": "17771671", "Score": "1", "Body": "<pre><code>#include &lt;functional&gt;\n\nvoid foo(std::function&lt;void()&gt; f) { f(); }\nvoid foo(void (*f)()) { f(); }\n\nint main ()\n{\n  foo( [](){} );\n}\n</code></pre>\n<p>VS compiles, gcc and clang complain about ambiguous overload. Who's right? The lambda is supposed to be of a class type, so there should not be any conversion between it and a function pointer. Thus VS appears to be right, against all odds. But perhaps I'm missing something.</p>\n<p>Is there a simple way to disambiguate the call, apart from casting the lambda to either type?</p>\n", "Tags": "<c++11>", "OwnerUserId": "775806", "AnswerCount": "2"}, "17771731": {"ParentId": "17771671", "CommentCount": "4", "Body": "<p>A lambda creates an anonymous and unspecified object that can be called, it's neither a function pointer nor a <code>std::function</code> object but can be used as both a function pointer and a <code>std::function</code> object, giving you the ambiguous overload error. I would say that VS is wrong.</p>\n<p>Also, since a function pointer can be used to create a <code>std::function</code> object, I would say that using an overload that takes a function pointer is not needed if you already have a function taking a <code>std::function</code> argument.</p>\n", "OwnerUserId": "440558", "PostTypeId": "2", "Id": "17771731", "Score": "4", "CreationDate": "2013-07-21T11:14:13.563", "LastActivityDate": "2013-07-21T11:14:13.563"}, "17772810": {"ParentId": "17771671", "CommentCount": "0", "Body": "<p>Non-capturing lambdas have an implicit conversion to a function pointer with the same signature. This is specified in chapter 5.1.2 paragraph 6:</p>\n<blockquote>\n<p id=\"so_17771671_17772810_0\">The closure type for a lambda-expression with no lambda-capture has a\n  public non-virtual non-explicit const conversion function to pointer\n  to function having the same parameter and return types as the closure\n  type\u2019s function call operator. The value returned by this conversion\n  function shall be the address of a function that, when invoked, has\n  the same effect as invoking the closure type\u2019s function call operator.</p>\n</blockquote>\n", "OwnerUserId": "279597", "PostTypeId": "2", "Id": "17772810", "Score": "3", "CreationDate": "2013-07-21T13:27:21.807", "LastActivityDate": "2013-07-21T13:27:21.807"}, "bq_ids": {"n4140": {"so_17771671_17772810_0": {"section_id": 5965, "quality": 0.95, "length": 38}}, "n3337": {"so_17771671_17772810_0": {"section_id": 5734, "quality": 0.95, "length": 38}}, "n4659": {"so_17771671_17772810_0": {"section_id": 7456, "quality": 0.85, "length": 34}}}});