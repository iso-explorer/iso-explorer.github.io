post_cb({"10761342": {"CommentCount": "0", "ViewCount": "53", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-05-25T21:04:09.707", "LastActivityDate": "2012-05-25T21:07:22.870", "Title": "In C++03 auto_ptr why isn't compiler generated copy-ctor called?", "AcceptedAnswerId": "10761380", "LastEditDate": "2017-05-23T11:56:29.723", "Id": "10761342", "Score": "0", "Body": "<p>I understand how <code>auto_ptr</code> works in C++03. It is based on <a href=\"https://stackoverflow.com/questions/4514124/how-could-one-implement-stdauto-ptrs-copy-constructor/4514204#4514204\">this</a> trick. The trick uses a user-defined conversion to steal the pointer from one object to another when code such as this <code>auto_int p(auto_int(new int()));</code> is written. However, I've several questions in this regard. </p>\n<ol>\n<li>Why isn't the compiler-generated copy-ctor called? </li>\n<li>Why does the user-defined conversion take precedence over a compiler-generated copy-ctor? </li>\n<li>Is there a compiler-generated copy-ctor to begin with? </li>\n<li>If not, what language rule suppresses it?</li>\n</ol>\n", "Tags": "<emulation><auto-ptr><c++03><move-constructor>", "OwnerUserId": "25014", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_10761342_10761380_5": {"section_id": 456, "quality": 1.0, "length": 10}, "so_10761342_10761380_4": {"section_id": 451, "quality": 1.0, "length": 24}}, "n3337": {"so_10761342_10761380_5": {"section_id": 447, "quality": 1.0, "length": 10}, "so_10761342_10761380_4": {"section_id": 442, "quality": 1.0, "length": 24}}, "n4659": {"so_10761342_10761380_5": {"section_id": 479, "quality": 1.0, "length": 10}, "so_10761342_10761380_4": {"section_id": 474, "quality": 1.0, "length": 24}}}, "10761380": {"ParentId": "10761342", "CommentCount": "3", "CreationDate": "2012-05-25T21:07:22.870", "OwnerUserId": "927034", "PostTypeId": "2", "Id": "10761380", "Score": "0", "Body": "<blockquote>\n<p id=\"so_10761342_10761380_0\">Why isn't the compiler-generated copy-ctor called?</p>\n</blockquote>\n<p>Because the class already supplied a copy-constructor, a mutable one which is still valid, so the compiler does not generate a default one.</p>\n<blockquote>\n<p id=\"so_10761342_10761380_1\">Why does the user-defined conversion take precedence over a compiler-generated copy-ctor?</p>\n</blockquote>\n<p>There is no compiler generated copy-constructor.</p>\n<blockquote>\n<p id=\"so_10761342_10761380_2\">Is there a compiler-generated copy-ctor to begin with?</p>\n</blockquote>\n<p>Finally! Nope, there isn't.</p>\n<blockquote>\n<p id=\"so_10761342_10761380_3\">If not, what language rule suppresses it?</p>\n</blockquote>\n<p>It's 12.8.2:</p>\n<blockquote>\n<p id=\"so_10761342_10761380_4\">A non-template constructor for class X is a copy constructor if its first parameter is of type X&amp;, const X&amp;, volatile X&amp; or const volatile X&amp;, and either there are no other parameters or else all other parameters have default arguments.</p>\n</blockquote>\n<p>And 12.8.4:</p>\n<blockquote>\n<p id=\"so_10761342_10761380_5\">If the class definition does not explicitly declare a copy constructor, one is declared implicitly.</p>\n</blockquote>\n", "LastActivityDate": "2012-05-25T21:07:22.870"}});