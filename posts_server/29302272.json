post_cb({"29302272": {"ViewCount": "321", "Body": "<pre><code>class A\n{\n     private:\n        A a;\n};\n</code></pre>\n<p>Why is the A in class an incomplete type?</p>\n<pre><code>class A\n{\n     public:\n          A&amp; operator= (A a){return *this;}\n};\n</code></pre>\n<p>Is not the parameter <code>A</code> of <code>operator=</code> an incomplete type? Why does the code above compile?</p>\n", "Title": "Why can a class be used within itself in member function definition, but is regarded as incomplete when used as a member?", "CreationDate": "2015-03-27T13:50:23.717", "LastActivityDate": "2015-03-27T18:09:28.870", "CommentCount": "5", "LastEditDate": "2015-03-27T14:06:26.250", "PostTypeId": "1", "LastEditorUserId": "2642204", "Id": "29302272", "Score": "5", "OwnerUserId": "3691082", "Tags": "<c++><types>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_29302272_29302329_0": {"length": 37, "quality": 0.9487179487179487, "section_id": 5862}, "so_29302272_29302329_1": {"length": 29, "quality": 0.90625, "section_id": 3245}}, "n3337": {"so_29302272_29302329_0": {"length": 37, "quality": 0.9487179487179487, "section_id": 5632}, "so_29302272_29302329_1": {"length": 29, "quality": 0.90625, "section_id": 3118}}, "n4659": {"so_29302272_29302329_0": {"length": 32, "quality": 0.8205128205128205, "section_id": 7345}}}, "29302752": {"Id": "29302752", "PostTypeId": "2", "Body": "<p>Second one is compiling because you are using only A's reference not an object of A. Reference doesn't need complete type. But in first case you need A's object and hence complete type will be required, which can only happen after closing }</p>\n", "LastActivityDate": "2015-03-27T14:13:10.863", "CommentCount": "3", "CreationDate": "2015-03-27T14:13:10.863", "ParentId": "29302272", "Score": "-1", "OwnerUserId": "4461931"}, "29302329": {"Id": "29302329", "PostTypeId": "2", "Body": "<p>Because there is a difference between using <code>A</code> in open space in the class definition, and using it in the parameter-list of a member function definition. Those are two different scopes.</p>\n<blockquote>\n<p id=\"so_29302272_29302329_0\"><code>[C++11: 9.2/2]:</code> A class is considered a completely-defined object type (3.9) (or complete type) at the closing <code>}</code> of the <em>class-specifier</em>. Within the class <em>member-specification</em>, the class is regarded as complete within function bodies, default arguments, exception-specifications, and <em>brace-or-equal-initializers</em> for non-static data members (including such things in nested classes). <strong>Otherwise it is regarded as incomplete within its own class <em>member-specification</em>.</strong></p>\n</blockquote>\n<p>And then the following special case:</p>\n<blockquote>\n<p id=\"so_29302272_29302329_1\"><code>[C++11: 8.3.5/9]</code>: Types shall not be defined in return or parameter types. <strong>The type of a parameter</strong> or the return type <strong>for a function definition shall not be an incomplete class type</strong> (possibly cv-qualified) <strong>unless the function definition is nested within the <em>member-specification</em> for that class</strong> (including definitions in nested classes defined within the class).</p>\n</blockquote>\n<p>\"That's just the way it is.\"</p>\n<p>Speaking practically, it's clear that it would be impossible to store an <code>A</code> within an <code>A</code> (because that would require infinite encapsulation), whereas this is obviously not the case in a member function's parameter list. So the standard committee had the opportunity to make this a little easier for us, and they took it.</p>\n<p>Furthermore, if you were to try to use a member of <code>a</code> inside the function's <em>definition</em>, then that is also allowed (per the first quote above), as if the function had been declared lexically after the end of the class definition.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2015-03-27T13:58:21.107", "Score": "4", "CreationDate": "2015-03-27T13:53:03.870", "ParentId": "29302272", "CommentCount": "2", "OwnerUserId": "560648", "LastEditDate": "2015-03-27T13:58:21.107"}, "29307431": {"Id": "29307431", "PostTypeId": "2", "Body": "<p>The way to look at this would be to understand what would happen if this was actually legal. When a class is instantiated, all its class members are constructed first. So, in your example, the construction of <code>A a</code> will take place before A is fully constructed, which is not possible. </p>\n<p>Also, this will result in an infinite recursive construction of objects of A.</p>\n", "LastActivityDate": "2015-03-27T18:09:28.870", "CommentCount": "0", "CreationDate": "2015-03-27T18:09:28.870", "ParentId": "29302272", "Score": "0", "OwnerUserId": "4599686"}, "29302442": {"Id": "29302442", "PostTypeId": "2", "Body": "<p>The first block is an impossibility in the general case, as to know what <code>sizeof(A)</code> (for the class) is it needs to know what <code>sizeof(A)</code> is (for the member).</p>\n<p>The second case is different in that even if the definition of the member function is syntactically <em>inside</em> the class, the language considers the definition to be <em>outside</em> of the class.  The compiler will translate that code as if you had typed it like:</p>\n<pre><code>class A {\npublic:\n   A&amp; operator=(A a);\n};\ninline A&amp; A::operator=(A a) { return *this; }\n</code></pre>\n<p>Declaring a function taking or returning an object of incomplete type is legal.  When the type is really used, inside the function definition outside of the class, the type is already complete, so it is perfectly fine too.</p>\n", "LastEditorUserId": "36565", "LastActivityDate": "2015-03-27T14:02:04.833", "Score": "1", "CreationDate": "2015-03-27T13:58:36.917", "ParentId": "29302272", "CommentCount": "5", "OwnerUserId": "36565", "LastEditDate": "2015-03-27T14:02:04.833"}});