post_cb({"11596898": {"CommentCount": "2", "ViewCount": "857", "PostTypeId": "1", "LastEditorUserId": "1468366", "CreationDate": "2012-07-22T00:31:31.930", "LastActivityDate": "2012-07-22T01:57:11.287", "Title": "Variadic template and inferred return type in concat", "AcceptedAnswerId": "11597196", "LastEditDate": "2012-07-22T00:40:27.803", "Id": "11596898", "Score": "1", "Body": "<h1>This works</h1>\n<p>Toying with C++11, I tried to build a function which concatenates arbitrary objects by writing them to a <code>ostringstream</code>. As a helper function for those, I have a variadic helper function which appends a single item to an existing <code>ostream</code> (More context given in the full paste below):</p>\n<pre><code>template&lt;class Head, class... Tail&gt;\nstd::ostream&amp; append(std::ostream&amp; out, const Head&amp; head, const Tail&amp;... tail)\n{\n  return append(out &lt;&lt; head, tail...);\n}\n</code></pre>\n<h1>This fails</h1>\n<p>But then I thought that there might be some objects which, when <code>&lt;&lt;</code>-applied to a stream, will not return an ostream but instead some placeholder. So it would be cool to have the stream type a template argument as well:</p>\n<pre><code>  1 #include &lt;iostream&gt;\n  2 #include &lt;sstream&gt;\n  3 \n  4 template&lt;typename Stream&gt;\n  5 Stream&amp; append(Stream&amp; out) {\n  6   return out;\n  7 }\n  8 \n  9 template&lt;class Stream, class Head, class... Tail&gt;\n 10 auto append(Stream&amp; out, const Head&amp; head, const Tail&amp;... tail)\n 11   -&gt; decltype(append(out &lt;&lt; head, tail...))  // &lt;&lt;&lt;&lt;&lt; This is the important line!\n 12 {\n 13   return append(out &lt;&lt; head, tail...);\n 14 }\n 15 \n 16 template&lt;class... Args&gt;\n 17 std::string concat(const Args&amp;... args) {\n 18   std::ostringstream s;\n 19   append(s, args...);\n 20   return s.str();\n 21 }\n 22 \n 23 int main() {\n 24   std::cout &lt;&lt; concat(\"foo \", 3, \" bar \", 7) &lt;&lt; std::endl;\n 25 }\n</code></pre>\n<p>But <code>g++-4.7.1</code> will refuse to compile this.</p>\n<p>Changing all uses of <code>Stream</code> in the signature back to <code>std::ostream</code> will not make it any better, so I assume that the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2541.htm\" rel=\"nofollow\">new function declaration syntax</a> is playing a major role here \u00ad\u2013 even though gcc <a href=\"http://gcc.gnu.org/projects/cxx0x.html\" rel=\"nofollow\">claims</a> to support it since 4.4.</p>\n<h1>Error message</h1>\n<p>The error message is rather cryptic, and doesn't tell me what's going on here. But perhaps you can make any sense of it.</p>\n<pre><code> In instantiation of \u2018std::string concat(const Args&amp; ...) [with Args = {char [5], int, char [6], int}; std::string = std::basic_string&lt;char&gt;]\u2019:\n24:44:   required from here\n19:3: error: no matching function for call to \u2018append(std::ostringstream&amp;, const char [5], const int&amp;, const char [6], const int&amp;)\u2019\n19:3: note: candidates are:\n5:9: note: template&lt;class Stream&gt; Stream&amp; append(Stream&amp;)\n5:9: note:   template argument deduction/substitution failed:\n19:3: note:   candidate expects 1 argument, 5 provided\n10:6: note: template&lt;class Stream, class Head, class ... Tail&gt; decltype (append((out &lt;&lt; head), append::tail ...)) append(Stream&amp;, const Head&amp;, const Tail&amp; ...)\n10:6: note:   template argument deduction/substitution failed:\n In substitution of \u2018template&lt;class Stream, class Head, class ... Tail&gt; decltype (append((out &lt;&lt; head), tail ...)) append(Stream&amp;, const Head&amp;, const Tail&amp; ...) [with Stream = std::basic_ostringstream&lt;char&gt;; Head = char [5]; Tail = {int, char [6], int}]\u2019:\n19:3:   required from \u2018std::string concat(const Args&amp; ...) [with Args = {char [5], int, char [6], int}; std::string = std::basic_string&lt;char&gt;]\u2019\n24:44:   required from here\n10:6: error: no matching function for call to \u2018append(std::basic_ostream&lt;char&gt;&amp;, const int&amp;, const char [6], const int&amp;)\u2019\n10:6: note: candidate is:\n5:9: note: template&lt;class Stream&gt; Stream&amp; append(Stream&amp;)\n5:9: note:   template argument deduction/substitution failed:\n10:6: note:   candidate expects 1 argument, 4 provided\n</code></pre>\n<h1>Question</h1>\n<p>So my core question is this:<br>\n<strong>Is there a good reason for this code to fail?</strong></br></p>\n<p>I'd be interested either in some quote from the standard which says my code is invalid, or some insight as to what's going wrong here in the implementation. If anyone should find a gcc bug for this, that would be an answer, too. I haven't been able to find a suitable report. A way to make this work would be great, too, although using <code>std::ostream</code> only works well enough for my current application. Input about how other compilers handle this is appreciated as well, but won't be enough for an answer I'd consider to accept.</p>\n", "Tags": "<c++><c++11><g++><type-inference><variadic-templates>", "OwnerUserId": "1468366", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_11596898_11597196_0": {"section_id": 7049, "quality": 0.7777777777777778, "length": 14}}, "n3337": {"so_11596898_11597196_0": {"section_id": 6794, "quality": 0.7777777777777778, "length": 14}}, "n4659": {"so_11596898_11597196_0": {"section_id": 8546, "quality": 0.7777777777777778, "length": 14}}}, "11597196": {"ParentId": "11596898", "LastEditDate": "2012-07-22T01:57:11.287", "CommentCount": "4", "CreationDate": "2012-07-22T01:44:58.727", "OwnerUserId": "981959", "LastEditorUserId": "981959", "PostTypeId": "2", "Id": "11597196", "Score": "7", "Body": "<blockquote>\n<p id=\"so_11596898_11597196_0\">3.3.2  [basic.scope.pdecl]<br>\n  -1- The point of declaration for a name is immediately after its complete declarator (Clause 8) and before its initializer (if any), except as noted below.</br></p>\n</blockquote>\n<p>A function declarator includes the trailing return type, so a function's own name is not in scope in its own trailing return type.</p>\n<p>So in the expression <code>decltype(append(out &lt;&lt; head, tail...))</code> the only candidate function is the non-variadic <code>append(Stream&amp;)</code> which cannot be used when the parameter pack <code>tail</code> is not empty, so deduction always fails when calling <code>append</code> with more than two arguments.</p>\n<p>Therefore GCC is correct to reject the code.</p>\n<p>This was discussed by the standard committee members last December and reported as a core issue, see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#1433\" rel=\"noreferrer\">CWG 1433</a>.</p>\n<p>The only workaround I can think of right now is to try using <code>common_type</code>, which will work for <em>some</em> cases, but probably fail for others:</p>\n<pre><code>template&lt;class Stream, class Head, class... Tail&gt;\n  auto append(Stream&amp; out, const Head&amp; head, const Tail&amp;... tail)\n  -&gt; typename std::common_type&lt;decltype(out &lt;&lt; head), decltype(out &lt;&lt; tail)...&gt;::type\n</code></pre>\n<p>This would fail if <code>out &lt;&lt; head &lt;&lt; tail</code> is valid but <code>out &lt;&lt; tail</code> is not, or if any of the <code>operator&lt;&lt;</code> calls returns something that cannot be converted to the type returned by the other <code>operator&lt;&lt;</code> calls.</p>\n", "LastActivityDate": "2012-07-22T01:57:11.287"}});