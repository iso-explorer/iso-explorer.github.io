post_cb({"33080528": {"ViewCount": "228", "Body": "<p>Say I have a class like</p>\n<pre><code>class A {\npublic: // I know, I know...\n    shared_ptr&lt;string&gt; aString;\n};\n</code></pre>\n<p>do I have to have a destructor like</p>\n<pre><code>~A() {\n    aString.reset();\n}\n</code></pre>\n<p>to ensure that ownership is properly reliquished? I did a few tests, and it would seem that I do not have to \u2014 i.e., when an instance of A goes out of scope or is deleted (or reset, if I reference it through a shared_ptr), the string is deleted as well (I played with a more sophisticated example to confirm this). However, this could be implementation specific to the compiler that I am using (clang-700.0.72).</p>\n<p>My question is: is this always the case, or is it better to explicitly reset those instances like I would delete any other dumb pointer?</p>\n", "AcceptedAnswerId": "33080560", "Title": "Do I have to manually reset shared_ptrs in my own destructors?", "CreationDate": "2015-10-12T11:57:01.617", "Id": "33080528", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2015-10-12T12:10:36.660", "Score": "0", "OwnerUserId": "554491", "Tags": "<c++><c++11><destructor><shared-ptr>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_33080528_33080560_0": {"length": 7, "quality": 0.875, "section_id": 400}, "so_33080528_33080560_7": {"length": 4, "quality": 0.8, "section_id": 4412}, "so_33080528_33080560_5": {"length": 9, "quality": 0.9, "section_id": 4412}, "so_33080528_33080560_6": {"length": 4, "quality": 0.8, "section_id": 4412}, "so_33080528_33080560_1": {"length": 19, "quality": 0.95, "section_id": 404}}, "n3337": {"so_33080528_33080560_7": {"length": 4, "quality": 0.8, "section_id": 4249}, "so_33080528_33080560_5": {"length": 9, "quality": 0.9, "section_id": 4249}, "so_33080528_33080560_1": {"length": 19, "quality": 0.95, "section_id": 395}, "so_33080528_33080560_6": {"length": 4, "quality": 0.8, "section_id": 4249}, "so_33080528_33080560_0": {"length": 7, "quality": 0.875, "section_id": 391}}, "n4659": {"so_33080528_33080560_7": {"length": 5, "quality": 1.0, "section_id": 5671}, "so_33080528_33080560_5": {"length": 10, "quality": 1.0, "section_id": 5671}, "so_33080528_33080560_1": {"length": 19, "quality": 0.95, "section_id": 422}, "so_33080528_33080560_6": {"length": 5, "quality": 1.0, "section_id": 5671}, "so_33080528_33080560_0": {"length": 7, "quality": 0.875, "section_id": 417}}}, "33080564": {"Id": "33080564", "PostTypeId": "2", "Body": "<p>No. This is well-defined and there are no compiler bugs that I'm aware of.</p>\n", "LastActivityDate": "2015-10-12T11:58:55.583", "CommentCount": "0", "CreationDate": "2015-10-12T11:58:55.583", "ParentId": "33080528", "Score": "2", "OwnerUserId": "15416"}, "33080560": {"Id": "33080560", "PostTypeId": "2", "Body": "<p>No, that's the main point of smart pointers: <strong>to manage memory automatically</strong>.</p>\n<p>The destructor of <code>shared_ptr</code> will automatically decrease the reference count, and if it reaches 0, will call the deleter.</p>\n<p>If you don't provide a destructor, a default one will be generated:</p>\n<blockquote>\n<p id=\"so_33080528_33080560_0\"><strong>\u00a7 12.4.4</strong> If a class has no user-declared destructor, a destructor is implicitly declared as defaulted</p>\n</blockquote>\n<p>The destruction of your class will guarantee the destruction of members.</p>\n<blockquote>\n<p id=\"so_33080528_33080560_1\"><strong>\u00a7 12.4.8</strong> After executing the body of the destructor and destroying any automatic objects allocated within the body, a destructor for class X calls the destructors for X's direct non-variant non-static data members(...)</p>\n</blockquote>\n<p>Which in turn for <code>shared_ptr</code> means:</p>\n<blockquote>\n<p id=\"so_33080528_33080560_2\"><strong>\u00a7 20.8.2.2.2.1</strong></p>\n<p id=\"so_33080528_33080560_3\"><code>~shared_ptr();</code></p>\n<p id=\"so_33080528_33080560_4\">Effects:</p>\n<ul>\n<li><p id=\"so_33080528_33080560_5\">If *this is empty or shares ownership with another shared_ptr instance (use_count() &gt; 1), there are no side effects.</p></li>\n<li><p id=\"so_33080528_33080560_6\">Otherwise, if *this owns an object p and a deleter d, d(p) is called.</p></li>\n<li><p id=\"so_33080528_33080560_7\">Otherwise, *this owns a pointer p, and delete p is called.</p></li>\n</ul>\n</blockquote>\n<p>This behaviour is nicely summarized as <a href=\"https://rmf.io/cxx11/rule-of-zero/\" rel=\"nofollow\">The Rule Of Zero</a>.</p>\n", "LastEditorUserId": "752976", "LastActivityDate": "2015-10-12T12:10:36.660", "Score": "4", "CreationDate": "2015-10-12T11:58:46.293", "ParentId": "33080528", "CommentCount": "8", "OwnerUserId": "752976", "LastEditDate": "2015-10-12T12:10:36.660"}, "33080572": {"Id": "33080572", "PostTypeId": "2", "Body": "<p>No, you do not need to do so.  As part of the normal destructor, each member of the class will be destroyed in turn.  The destructor for a smart pointer will take care of the necessary accounting, which in this case is an implicit <code>reset</code>.</p>\n", "LastActivityDate": "2015-10-12T11:59:18.107", "CommentCount": "0", "CreationDate": "2015-10-12T11:59:18.107", "ParentId": "33080528", "Score": "7", "OwnerUserId": "5249307"}});