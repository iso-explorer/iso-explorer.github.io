post_cb({"bq_ids": {"n4140": {"so_20659000_20659598_2": {"length": 26, "quality": 0.896551724137931, "section_id": 355}, "so_20659000_20659598_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 558}, "so_20659000_20659598_1": {"length": 38, "quality": 0.95, "section_id": 558}}, "n3337": {"so_20659000_20659598_2": {"length": 26, "quality": 0.896551724137931, "section_id": 345}, "so_20659000_20659598_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 549}, "so_20659000_20659598_1": {"length": 38, "quality": 0.95, "section_id": 549}}, "n4659": {"so_20659000_20659598_2": {"length": 26, "quality": 0.896551724137931, "section_id": 365}, "so_20659000_20659598_0": {"length": 23, "quality": 0.9583333333333334, "section_id": 581}, "so_20659000_20659598_1": {"length": 38, "quality": 0.95, "section_id": 581}}}, "20674913": {"Id": "20674913", "PostTypeId": "2", "Body": "<p>This is a bug because it prevents legitimate code like:</p>\n<pre><code>/* API declaration */\nvoid f(int);\n\n\n/* Implementation */\nvoid f(const int x) /* my business: x is my local var and I want it const */\n{\n}\n</code></pre>\n<p>I can't believe anyone would code out of their way to diagnose this as a problem.</p>\n<p>Incidentally, GCC, which doesn't complain about this, used to have a warning about this situation. Perhaps it still does:</p>\n<pre><code>void f(int func_ptr(void));\n\nvoid f(int (*func_ptr)(void))\n{\n}\n</code></pre>\n<p>This is purely a stylistic inconsistency that doesn't serve a purpose, though.</p>\n", "LastActivityDate": "2013-12-19T06:36:00.377", "CommentCount": "1", "CreationDate": "2013-12-19T06:36:00.377", "ParentId": "20659000", "Score": "2", "OwnerUserId": "1250772"}, "20659000": {"ViewCount": "635", "Body": "<p>I noticed that it's possible to have <code>const</code> qualifier on a value argument present in the function declaration and then omitted in the definition. That doesn't change the signature of the function. It actually compiles well.</p>\n<p>I also noticed that the behavior is different between regular and template classes. Also there's a difference between how it's handled in GCC and Clang.</p>\n<p>Consider the following code:</p>\n<pre><code>template &lt;typename T&gt; struct A {\n    void f(const int);\n};\n\ntemplate &lt;typename T&gt; void A&lt;T&gt;::f(int x) {\n    x = 0;\n}\n\nstruct B {\n    void f(const int);\n};\n\nvoid B::f(int x) {\n    x = 0;\n}\n\nvoid f() {\n    A&lt;float&gt; a;\n    a.f(0);\n\n    B b;\n    b.f(0);\n}\n</code></pre>\n<p>When I compile with GCC I get no errors. With Clang I get:</p>\n<pre><code>test.cpp:10:7: error: read-only variable is not assignable\n    x = 0;\n    ~ ^\ntest.cpp:26:7: note: in instantiation of member function 'A&lt;float&gt;::f' requested here\n    a.f(0);\n      ^\n</code></pre>\n<p>GCC took preference of the qualifier at the definition. Clang used the declaration and only for the template class <code>A</code>.</p>\n<p><strong>My questions are:</strong></p>\n<ol>\n<li>Is this regulated by the standard or is this implementation defined?</li>\n<li>Why is the behavior is different between regular and template classes?</li>\n<li>Why is there no error or at least a warning that the <code>const</code> qualifier is used inconsistently between the declaration and the definition?</li>\n<li>Are there any situation where this could be useful?</li>\n</ol>\n<p><strong>Update:</strong></p>\n<p>According to the comments it seems to be a Clang bug. I opened a <a href=\"http://llvm.org/bugs/show_bug.cgi?id=18275\" rel=\"nofollow\">new ticket</a>.</p>\n<p><strong>Update:</strong></p>\n<p>The bug is fixed:</p>\n<blockquote>\n<p id=\"so_20659000_20659000_0\">Fixed in r203741</p>\n</blockquote>\n", "AcceptedAnswerId": "20659598", "Title": "Inconsistent use of const qualifier between declaration and definition", "CreationDate": "2013-12-18T13:03:46.570", "Id": "20659000", "CommentCount": "8", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2014-03-20T16:55:53.463", "LastEditorUserId": "362938", "LastActivityDate": "2014-03-20T16:55:53.463", "Score": "13", "OwnerUserId": "362938", "Tags": "<c++><gcc><clang>", "AnswerCount": "2"}, "20659598": {"Id": "20659598", "PostTypeId": "2", "Body": "<p>This behavior is defined by the standard and as far as I can tell <code>gcc</code> is correct here, if we look at the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> section <code>13.1</code> <em>Overloadable declarations</em> paragraph <em>3</em> says:</p>\n<blockquote>\n<p id=\"so_20659000_20659598_0\">[...]-Parameter declarations that differ only in the presence or absence of const and/or volatile are equivalent. That is, the const and volatile type-specifiers for each parameter type are ignored when determining which function is being declared, defined, or called. </p>\n</blockquote>\n<p>and provides this example:</p>\n<pre><code>[ Example:\n    typedef const int cInt;\n\n    int f (int);\n    int f (const int); // redeclaration of f(int)\n    int f (int) { /* ... */ } // definition of f(int)\n    int f (cInt) { /* ... */ } // error: redefinition of f(int)\n\u2014end example ]\n</code></pre>\n<p>and some details clarifying that that this applies only to the outermost <em>cv qualifiers</em> (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_20659000_20659598_1\">Only the const and volatile type-specifiers at the outermost level of the parameter type specification are ignored in this fashion; <strong>const and volatile type-specifiers buried within a parameter type specification are significant and can be used to distinguish overloaded function declarations</strong>.<sup>123</sup> In particular, for any type T, \u201cpointer to T,\u201d \u201cpointer to const T,\u201d and \u201cpointer to volatile T\u201d are considered distinct parameter types, as are \u201creference to T,\u201d \u201creference to const T,\u201d and \u201creference to\n  volatile T.\u201d</p>\n</blockquote>\n<p>and as far as I can tell this applies to template functions in template classes as well from section <code>14.8</code> <em>Function template specializations</em> specifically <code>14.8.3</code> <em>Overload resolution</em> which says:</p>\n<blockquote>\n<p id=\"so_20659000_20659598_2\">[...]The complete set of candidate functions includes all the synthesized declarations and all of the non-template overloaded functions of the same name. The synthesized declarations are treated like any other functions in the remainder of overload resolution, except as explicitly noted in 13.3.3.<sup>144</sup></p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2013-12-19T14:10:40.343", "Score": "11", "CreationDate": "2013-12-18T13:32:06.747", "ParentId": "20659000", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2013-12-19T14:10:40.343"}});