post_cb({"7333730": {"CreationDate": "2011-09-07T12:15:13.557", "ViewCount": "364", "FavoriteCount": "0", "Id": "7333730", "AcceptedAnswerId": "7333914", "Score": "1", "Title": "Inheritance and destructors - theoretical question - C++", "LastEditorUserId": "514235", "CommentCount": "6", "Body": "<pre><code>class A\n{\n    public:\n         virtual void f(){ printf(\"A.f \"); }\n         ~A(){ f(); }\n};\n\nclass B : public A\n{\n    A a;\n\n    public:\n         void f(){ printf(\"B.f \"); }\n         B(){ throw -1; }\n        ~B(){ f(); }\n};\n\nint main()\n{\n    try{ B b; }\n    catch(...){ printf(\"Exc\");}\n}\n</code></pre>\n<p>So here's how I see it. Inside the try block, nothing is being printed while constructing <code>B b;</code>. The block ends. I think compiler is destructing the <code>A a;</code> member first. So <code>A.f()</code> would be printed. Does that mean the destruction of <code>class B</code> instance is finished? After that, would compiler simply call <code>~A()</code> (destructing base class)?</p>\n<p>I thought I should've got <code>A.f()</code>, then <code>B.f()</code> (destructing class B instance) and after that <code>A.f()</code> again (destructor of base class). Compiling this made me think a little.\nExc is being printed at the end of course.\nI've gone through several topic and haven't found anything.</p>\n<p><em>EDIT</em>: Output from Dev-C++ (GCC 3.4.2) is</p>\n<blockquote>\n<p id=\"so_7333730_7333730_0\">A.f A.f Exc</p>\n</blockquote>\n", "Tags": "<c++><exception><inheritance><destructor>", "LastEditDate": "2011-09-07T12:25:49.793", "LastActivityDate": "2011-09-07T12:55:40.513", "PostTypeId": "1", "AnswerCount": "5", "OwnerUserId": "932586"}, "7333816": {"LastActivityDate": "2011-09-07T12:28:45.553", "CommentCount": "8", "Body": "<p>You haven't shown us the output you get, just a wall of ranty text, so it's hard to know what you're asking.</p>\n<p>However, for the record, <a href=\"http://codepad.org/y9UnPy8E\" rel=\"nofollow\">the output of your code is</a>:</p>\n<blockquote>\n<p id=\"so_7333730_7333816_0\">A.f A.f Exc</p>\n</blockquote>\n<hr>\n<p>Why?</p>\n<ul>\n<li>Constructing <code>b</code> fails.</li>\n<li><code>b</code>'s <code>B</code> destructor is not invoked, but destructors for its <em>members</em> are<sup>1</sup>.</li>\n<li>It has a member of type <code>A</code>, whose destructor calls the function <code>f()</code>.</li>\n<li>There is also a fully-constructed <code>A</code> base of <code>b</code>; so, <code>b</code>'s <code>A</code> destructor is also invoked, calling <code>A::f()</code> as before.</li>\n<li><code>Exc</code> is of course output by the surrounding exception handler.</li>\n</ul>\n<p>Is this what you wanted to know?</p>\n<hr>\n<p><sup>1</sup>:</p>\n<blockquote>\n<p id=\"so_7333730_7333816_1\"><code>[n3290: 15.2/2]:</code> An object of any storage duration whose\n  initialization or destruction is terminated by an exception will have\n  destructors executed for all of its fully constructed subobjects\n  (excluding the variant members of a union-like class), that is, for\n  subobjects for which the principal constructor (12.6.2) has completed\n  execution and the destructor has not yet begun execution. [..]</p>\n</blockquote>\n</hr></hr>", "CreationDate": "2011-09-07T12:21:46.113", "LastEditDate": "2011-09-07T12:28:45.553", "ParentId": "7333730", "Id": "7333816", "LastEditorUserId": "560648", "PostTypeId": "2", "Score": "4", "OwnerUserId": "560648"}, "bq_ids": {"n4140": {"so_7333730_7333816_1": {"length": 31, "quality": 0.9117647058823529, "section_id": 3344}}, "n3337": {"so_7333730_7333816_1": {"length": 31, "quality": 0.9117647058823529, "section_id": 3214}}}, "7333984": {"LastActivityDate": "2011-09-07T12:36:15.600", "CommentCount": "1", "Body": "<p>You can't call virtual functions from constructor or destructor. They won't work as virtual but will be called as non-virtual functions. <br/>\nYou can read about it in FAQ <a href=\"http://www.parashift.com/c%2B%2B-faq-lite/strange-inheritance.html#faq-23.7\" rel=\"nofollow noreferrer\">here</a> and in related theme about constructors <a href=\"https://stackoverflow.com/questions/962132/calling-virtual-functions-inside-constructors\">here</a>.</p>\n", "CreationDate": "2011-09-07T12:36:15.600", "LastEditDate": "2017-05-23T11:54:43.490", "ParentId": "7333730", "Id": "7333984", "LastEditorUserId": "-1", "PostTypeId": "2", "Score": "0", "OwnerUserId": "895077"}, "7333914": {"LastActivityDate": "2011-09-07T12:55:40.513", "CommentCount": "10", "Body": "<p>You really have two <code>A</code> objects here.</p>\n<ol>\n<li><code>B</code> inherits from <code>A</code>, so a base class object of <code>A</code> is instantiated first before B is.</li>\n<li>Another <code>A</code> instance is created as you have a member field of type <code>A</code> as part of <code>B</code>.</li>\n</ol>\n<p>When you create <code>B b</code>, you create the base class <code>A</code>, and also the instance <code>A a</code>.</p>\n<p>However, you then throw the exception in <code>B</code>'s constructor, so then all fully-constructed objects at that point are destructed, that is.</p>\n<ul>\n<li><code>~A()</code> is called on the instance <code>A a</code>.</li>\n<li><code>~A()</code> is called on the base class <code>A</code>.</li>\n</ul>\n<p>That would explain why you get <code>A.f A.f Exc</code>.</p>\n<p><code>B</code>'s destructor would not be called because <code>B</code> wasn't fully constructed as its constructor did not finish successfully.</p>\n", "CreationDate": "2011-09-07T12:29:59.650", "LastEditDate": "2011-09-07T12:55:40.513", "ParentId": "7333730", "Id": "7333914", "LastEditorUserId": "297696", "PostTypeId": "2", "Score": "10", "OwnerUserId": "297696"}, "7333915": {"CommentCount": "4", "Body": "<pre><code>#include &lt;stdio.h&gt;\n\nclass A\n{\n    public:\n         virtual void f(int i){ printf(\"A.f %i\\n\", i); }\n         ~A(){ f(0); }\n};\n\nclass B : public A\n{\n    A a;\n\n    public:\n         void f(int i){ printf(\"B.f %i\\n\", i); }\n         B(){ throw -1; }\n         ~B(){ f(1); }\n};\n\nint main()\n{\n    try{ B b; }\n    catch(...){ printf(\"Exc\\n\");}\n}\n</code></pre>\n<p>Destructor of A is called twice, that's it.</p>\n<p>Output:</p>\n<pre><code>A.f 0\nA.f 0\nExc\n</code></pre>\n", "CreationDate": "2011-09-07T12:30:02.820", "ParentId": "7333730", "Id": "7333915", "LastActivityDate": "2011-09-07T12:30:02.820", "PostTypeId": "2", "Score": "0", "OwnerUserId": "405559"}, "7333937": {"LastActivityDate": "2011-09-07T12:43:31.680", "CommentCount": "0", "Body": "<p>The order should be:\nA.f, A.f, Exc</p>\n<p>When B's constructor is invoked, before entering, first A's constructor is invoked due to inheritance. Next, before entering B's constructor (i.e. before <code>{</code>), <code>a</code> is default constructed. </p>\n<p>B's construction would be complete only if it reaches matching <code>}</code>. But before that you have a throw statement. So the partially constructed B has to be destroyed, which has one object <code>a</code> and the the inherited subobject A. So both these are destroyed, hence A.f and A.f</p>\n<p>Next, you reach the throw block where 'Exc' is printed</p>\n", "CreationDate": "2011-09-07T12:32:05.817", "LastEditDate": "2011-09-07T12:43:31.680", "ParentId": "7333730", "Id": "7333937", "LastEditorUserId": "596781", "PostTypeId": "2", "Score": "4", "OwnerUserId": "240857"}});