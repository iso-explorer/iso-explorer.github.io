post_cb({"bq_ids": {"n4140": {"so_18456572_18460544_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 6092}}, "n3337": {"so_18456572_18460544_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 5859}}, "n4659": {"so_18456572_18460544_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 7588}}}, "18456572": {"ViewCount": "188", "Body": "<pre><code>struct A final\n{\n    int a;\n\n    void* operator new(size_t size)\n    {\n        //\n        // Is size always equal to sizeof(A) here?\n        //\n        return ::operator new(size); \n    }\n\n    void operator delete(void* ptr)\n    {\n        ::operator delete(ptr);\n    }\n};\n\nint main()\n{\n    for (auto i = 0; i &lt; 100; i++)\n    {\n        delete new A;\n    }\n}\n</code></pre>\n<p>My question is also embedded in the code. </p>\n<p>Does the C++ standard guarantee the sizes passed into A::operator new() are always the same?</p>\n<p><strong>Update:</strong>\nHere, just consider A is a final class only.</p>\n", "AcceptedAnswerId": "18460544", "Title": "Are the sizes passed into A::operator new() always equal to sizeof(A)?", "CreationDate": "2013-08-27T03:46:54.587", "Id": "18456572", "CommentCount": "0", "LastEditDate": "2013-08-27T03:58:02.193", "PostTypeId": "1", "LastEditorUserId": "508343", "LastActivityDate": "2013-08-27T08:26:08.907", "Score": "5", "OwnerUserId": "508343", "Tags": "<c++><memory-management><c++11><operator-overloading><standards>", "AnswerCount": "2"}, "18456680": {"Id": "18456680", "PostTypeId": "2", "Body": "<p>No.</p>\n<p>Try:</p>\n<pre><code>struct B: public A\n{\n    double a;\n}\n</code></pre>\n<p>Now the new operator will get a different size when you create a B</p>\n<pre><code>int main()\n{\n    for (auto i = 0; i &lt; 100; i++)\n    {\n        delete new A;\n        delete new B;\n    }\n}\n</code></pre>\n<p>PS add a print to see it:</p>\n<pre><code>void* operator new(size_t size)\n{\n    std::cout &lt;&lt; \"S(\" &lt;&lt; size &lt;&lt; \")\\n\";\n    //\n    // Is size always equal to sizeof(A) here?\n    //\n    return ::operator new(size); \n}\n</code></pre>\n<p>Output:</p>\n<pre><code>&gt; ./a.out\nS(4)\nS(12)\nS(4)\nS(12)\nS(4)\n</code></pre>\n", "LastActivityDate": "2013-08-27T03:58:13.137", "CommentCount": "7", "CreationDate": "2013-08-27T03:58:13.137", "ParentId": "18456572", "Score": "4", "OwnerUserId": "14065"}, "18460544": {"Id": "18460544", "PostTypeId": "2", "Body": "<p>Quote from the C++11 standard, section 5.3.4 point 10:</p>\n<blockquote>\n<p id=\"so_18456572_18460544_0\">A new-expression passes the amount of space requested to the\n  allocation function as the first argument of type std::size_t. That\n  argument shall be no less than the size of the object being created;\n  it may be greater than the size of the object being created only if\n  the object is an array.</p>\n</blockquote>\n<p>So, yes, it's guaranteed to be the same as the size of the object. Note however that different compilers or different compiler options may alter the actual size of a particular object at compile-time. </p>\n", "LastActivityDate": "2013-08-27T08:26:08.907", "CommentCount": "0", "CreationDate": "2013-08-27T08:26:08.907", "ParentId": "18456572", "Score": "4", "OwnerUserId": "1919155"}});