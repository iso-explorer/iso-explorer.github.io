post_cb({"9260900": {"ParentId": "9254605", "CommentCount": "0", "CreationDate": "2012-02-13T12:56:35.377", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "9260900", "Score": "1", "Body": "<p>Yes and no.</p>\n<p>In general, this is true (as dasblinkenlight explains), but it specifically doesn't hold for bitfields. Per C++11 9.6/3 \"there are no pointers to bitfields\" so they don't have addresses, either. And obviously, \"A pointer to a structure object, <em>suitably converted</em>, points to its initial member\" breaks down if there is no \"suitable conversion\".</p>\n", "LastActivityDate": "2012-02-13T12:56:35.377"}, "9254621": {"ParentId": "9254605", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2012-02-13T01:42:16.620", "Score": "14", "LastEditorUserId": "925649", "LastEditDate": "2017-08-13T00:02:06.320", "Id": "9254621", "OwnerUserId": "335858", "Body": "<blockquote>\n<p id=\"so_9254605_9254621_0\">Is a struct's address the same as its first member's address?</p>\n</blockquote>\n<p>Yes, this is actually mandated by the C and C++ standards. From the C standard:</p>\n<blockquote>\n<p id=\"so_9254605_9254621_1\">6.7.2.1-13. A pointer to a structure object, suitably converted, points to its initial member</p>\n</blockquote>\n<p>The size of your <code>struct</code> should be two bytes. You should not convert a pointer to it to <code>char*</code>, though: instead, you should use <a href=\"http://www.cplusplus.com/reference/clibrary/cstring/memcpy/\" rel=\"nofollow noreferrer\"><code>memcpy</code></a> to copy your <code>Bitmask</code> into the buffer that you send over the network.</p>\n<p><strong>EDIT</strong> Since you use scatter-gather I/O with <code>iovec</code>, you do not need to cast <code>Bitmask</code> to anything: <code>iov_base</code> is <code>void*</code>, so you can simply set <code>iov[0].iov_base = header;</code></p>\n<p>Note: This works only as long as your <code>struct</code> does not contain virtual functions, base classes, etc. (thanks, Timo).</p>\n<p><strong>EDIT2</strong></p>\n<p>In order to get {0x81, 0x05} in your <code>struct</code>, you should change the order of structure elements as follows:</p>\n<pre><code>struct Bitmask {\n    unsigned char opcode: 4; \n    unsigned char rsv3: 1; \n    unsigned char rsv2: 1; \n    unsigned char rsv1: 1; \n    unsigned char fin: 1; \n    unsigned char payload_length: 7; \n    unsigned char mask: 1;\n}\n</code></pre>\n", "LastActivityDate": "2017-08-13T00:02:06.320"}, "9254605": {"CommentCount": "0", "AcceptedAnswerId": "9254621", "PostTypeId": "1", "LastEditorUserId": "925649", "CreationDate": "2012-02-13T01:40:00.957", "LastActivityDate": "2017-08-13T00:02:06.320", "LastEditDate": "2017-08-13T00:00:28.937", "ViewCount": "2292", "FavoriteCount": "2", "Title": "Is a struct's address the same as its first member's address?", "Id": "9254605", "Score": "6", "Body": "<p>Consider I have Struct like the following:</p>\n<pre><code>struct Bitmask\n{\n  unsigned char payload_length: 7;\n  unsigned char mask: 1;\n  unsigned char opcode: 4;\n  unsigned char rsv3: 1;\n  unsigned char rsv2: 1;\n  unsigned char rsv1: 1;\n  unsigned char fin: 1;\n};\n\nconst char* payload = \"Hello\";\nconst size_t payload_length = strlen(payload);\n\nBitmask* header = new Bitmask();\nheader-&gt;fin =1;\nheader-&gt;rsv1 = 0;\nheader-&gt;rsv2 = 0;\nheader-&gt;rsv3 = 0;\nheader-&gt;opcode = 1;\nheader-&gt;mask = 0;\nheader-&gt;payload_length = payload_length;\n\niovec iov[2];\niov[0].iov_base = (char*)header;\niov[0].iov_len = sizeof (header);\niov[1].iov_base = (char *)payload;\niov[1].iov_len = strlen(payload);\n\nACE_DEBUG ((LM_DEBUG,\n            ACE_TEXT (\"iov[0].length = %d\\niov[1].length = %d\\n\"),\n            iov[0].iov_len,\n            iov[1].iov_len));\n\nsize_t bytes_xfered;\nclient_stream_.sendv_n (iov, 2, 0, &amp;bytes_xfered);\n\ncout &lt;&lt; \"Transfered \" &lt;&lt; bytes_xfered &lt;&lt; \" byte(s)\" &lt;&lt; std::endl;\n</code></pre>\n<p>I am initializing it with appropriate values. Finally, I want to convert the struct into char* so I can append my payload (which is char* message) and send it over a websocket connection. </p>\n", "Tags": "<c++><pointers><websocket><structure><ace>", "OwnerUserId": "1171769", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_9254605_9254621_0": {"section_id": 5879, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_9254605_9254621_1": {"section_id": 5650, "quality": 0.8, "length": 8}, "so_9254605_9254621_0": {"section_id": 5199, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_9254605_9254621_0": {"section_id": 7363, "quality": 0.7142857142857143, "length": 5}}}, "9261117": {"ParentId": "9254605", "CommentCount": "0", "CreationDate": "2012-02-13T13:11:24.667", "OwnerUserId": "1103817", "PostTypeId": "2", "Id": "9261117", "Score": "1", "Body": "<p>The address of a structure is the same as the address of its first member, provided that the appropriate cast is used. Given the below declaration of struct my_struct, if item is of type struct </p>\n<p>my_struct, then (char *)item == &amp;item.wp_cval.</p>\n<p>struct my_struct\n{</p>\n<pre><code>  char wp_cval;\n  short wp_font;\n  short wp_psize;\n</code></pre>\n<p>}ar[ARSIZE];</p>\n", "LastActivityDate": "2012-02-13T13:11:24.667"}});