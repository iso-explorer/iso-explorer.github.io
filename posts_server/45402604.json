post_cb({"bq_ids": {"n4140": {"so_45402604_45404450_0": {"length": 39, "quality": 0.9512195121951219, "section_id": 5446}, "so_45402604_45404450_1": {"length": 22, "quality": 1.0, "section_id": 5453}}, "n4659": {"so_45402604_45404450_0": {"length": 39, "quality": 0.9512195121951219, "section_id": 6873}, "so_45402604_45404450_1": {"length": 22, "quality": 1.0, "section_id": 6879}}}, "45402604": {"ViewCount": "56", "LastEditDate": "2017-07-30T20:30:40.873", "AcceptedAnswerId": "45404450", "Title": "c++ type inference recursive functions", "CreationDate": "2017-07-30T17:20:20.217", "LastActivityDate": "2017-07-30T20:55:15.130", "CommentCount": "4", "Body": "<p>Trying to understand why the type deduction is failing here with conditional operator.<br>\nSomething in the standard trying to prevent type deduction in this case? Any pointers to understand this would be great. </br></p>\n<pre><code>auto mfact(int i)\n{\n    return (0==i) ? 1 : i * mfact(i-1);\n}\n\nauto mfact2(int i)\n{\n    if (0 == i)\n        return 1;\n\n    else\n        return i * mfact2(i-1);\n}\n</code></pre>\n<blockquote id=\"so_45402604_45402604_0\">\n<pre><code>error: use of \u2018auto mfact(int)\u2019 before deduction of \u2018auto\u2019    \n    return (0==i) ? 1 : i * mfact(i-1);\n</code></pre>\n</blockquote>\n", "PostTypeId": "1", "LastEditorUserId": "3144770", "Id": "45402604", "Tags": "<c++><auto>", "Score": "2", "OwnerUserId": "1084637", "ClosedDate": "2017-07-30T20:43:47.943", "AnswerCount": "1"}, "45404450": {"Id": "45404450", "PostTypeId": "2", "LastEditDate": "2017-07-30T20:55:15.130", "CommentCount": "0", "LastEditorUserId": "817643", "LastActivityDate": "2017-07-30T20:55:15.130", "CreationDate": "2017-07-30T20:35:46.957", "ParentId": "45402604", "Score": "4", "Body": "<p>The problem in <code>mfact</code> is the ternary operator. The semantics of that operator specify that the type of the expression is the common type of the two conditional sub-expressions (I'm paraphrasing a bit).</p>\n<p>What is the common type? Why it's <code>int</code> and... A type left to be deduced.<br>\nAh, no problem! What's the type to be deduced? It's the type of the ternary operator...</br></p>\n<p>We have a chicken and egg problem. The entire function definition is ill-formed because the type of the expression cannot be determined.</p>\n<p>What about <code>mfact2</code>? It has two separate return statements. The first one being of a plain integer. Since a function can only have a single return type, return type deduction requires the two return return statements not to conflict.</p>\n<p>To quote the C++14 standard revision:</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4140/dcl.spec.auto#2\" rel=\"nofollow noreferrer\">[dcl.spec.auto/2]</a></p>\n<blockquote>\n<p id=\"so_45402604_45404450_0\">The placeholder type can appear with a function declarator in the\n  decl-specifier-seq, type-specifier-seq, conversion-function-id, or\n  trailing-return-type, in any context where such a declarator is valid.\n  If the function declarator includes a trailing-return-type\n  ([dcl.fct]), that specifies the declared return type of the function.\n  <em>If the declared return type of the function contains a placeholder\n  type, the return type of the function is deduced from return\n  statements in the body of the function, <strong>if any.</strong></em></p>\n</blockquote>\n<p>So one return statement to deduce the type is enough, and: </p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/n4140/dcl.spec.auto#9\" rel=\"nofollow noreferrer\">[dcl.spec.auto/9]</a></p>\n<blockquote>\n<p id=\"so_45402604_45404450_1\">If a function with a declared return type that contains a placeholder\n  type has multiple return statements, the return type is deduced for\n  each return statement. If the type deduced is not the same in each\n  deduction, the program is ill-formed.</p>\n</blockquote>\n<p>In this simple case, the first statement requires it to be <code>int</code>, and the second contains a recursive call. Since the same function overload can have only a single return type, the recursive call must be of type <code>int</code> as well. The two return statements agree.</p>\n", "OwnerUserId": "817643"}});