post_cb({"4180166": {"CommentCount": "13", "CreationDate": "2010-11-14T22:51:25.600", "PostTypeId": "1", "LastEditorUserId": "-1", "FavoriteCount": "7", "LastActivityDate": "2010-11-15T01:13:06.577", "AnswerCount": "6", "LastEditDate": "2017-05-23T12:34:45.947", "ViewCount": "5263", "LastEditorDisplayName": "Matthieu N.", "Title": "Why is the code in most STL implementations so convoluted?", "Id": "4180166", "Score": "50", "Body": "<p>The STL is a critical piece of the C++ world, most implementations derive from the initial efforts by Stepanov and Musser.</p>\n<p>My question is given the criticality of the code, and it being one of the primary sources for people to view examples of well written C++ for both awe and learning purposes: Why are the various implementations of the STL so disgusting to look at - convoluted and generally good examples of how not to write C++ code from an aesthetics point of view.</p>\n<p>The code examples below would not pass code-review at the places I've worked at for reasons varying from variable naming, layout, macros and uses of operators that require more than a simple glance to figure out what is actually occurring.</p>\n<pre><code>template&lt;class _BidIt&gt; inline\nbool _Next_permutation(_BidIt _First, _BidIt _Last)\n{  // permute and test for pure ascending, using operator&lt;\n_BidIt _Next = _Last;\nif (_First == _Last || _First == --_Next)\n   return (false);\n\nfor (; ; )\n   {  // find rightmost element smaller than successor\n   _BidIt _Next1 = _Next;\n   if (_DEBUG_LT(*--_Next, *_Next1))\n      {  // swap with rightmost element that's smaller, flip suffix\n      _BidIt _Mid = _Last;\n      for (; !_DEBUG_LT(*_Next, *--_Mid); )\n         ;\n      _STD iter_swap(_Next, _Mid);\n      _STD reverse(_Next1, _Last);\n      return (true);\n      }\n\n   if (_Next == _First)\n      {  // pure descending, flip all\n      _STD reverse(_First, _Last);\n      return (false);\n      }\n   }\n}\n\n\n_Ty operator()()\n   {  // return next value\n   static _Ty _Zero = 0;   // to quiet diagnostics\n   _Ty _Divisor = (_Ty)_Mx;\n\n   _Prev = _Mx ? ((_Ity)_Ax * _Prev + (_Ty)_Cx) % _Divisor\n      : ((_Ity)_Ax * _Prev + (_Ty)_Cx);\n   if (_Prev &lt; _Zero)\n      _Prev += (_Ty)_Mx;\n   return (_Prev);\n   }\n</code></pre>\n<p>Please note I'm not critiquing the interface, as it is very well designed and applicable. What I'm concerned about is the readability of the implementation details.</p>\n<p>A similar questions have been previously posed: </p>\n<p><strong><a href=\"https://stackoverflow.com/questions/2127612/is-there-a-readable-implementation-of-the-stl\">Is there a readable implementation of the STL</a></strong></p>\n<p><strong><a href=\"https://stackoverflow.com/questions/1460936/why-stl-implementation-is-so-unreadable-how-c-could-have-been-improved-here\">Why STL implementation is so unreadable? How C++ could have been improved here?</a></strong> </p>\n<p>Note: The code presented above is taken from MSVC 2010 algorithm and queue headers.</p>\n", "Tags": "<c++><stl><readability>", "OwnerDisplayName": "Matthieu N."}, "4180231": {"ParentId": "4180166", "CommentCount": "5", "CreationDate": "2010-11-14T23:05:24.740", "OwnerUserId": "240633", "PostTypeId": "2", "Id": "4180231", "Score": "3", "Body": "<p>Implementations vary.  <a href=\"http://libcxx.llvm.org/\" rel=\"nofollow\">libc++</a> for example, is much easier on the eyes.  There's still a bit of underscore noise though. As others have noted, the leading underscores are unfortunately required.  Here's the same function in libc++:</p>\n<pre><code>template &lt;class _Compare, class _BidirectionalIterator&gt;\nbool\n__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*--__i, *__ip1))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*__i, *--__j))\n                ;\n            swap(*__i, *__j);\n            _STD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _STD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n</code></pre>\n", "LastActivityDate": "2010-11-14T23:05:24.740"}, "4180210": {"ParentId": "4180166", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2010-11-14T23:01:12.273", "Score": "9", "LastEditorUserId": "13005", "LastEditDate": "2010-11-14T23:31:17.600", "Id": "4180210", "OwnerUserId": "13005", "Body": "<p>Variable names for the reason that this is standard library code, and it should use reserved names for implementation details in headers. The following should <em>not</em> break the standard libraries:</p>\n<pre><code>#define mid\n#include &lt;algorithm&gt;\n</code></pre>\n<p>So standard library headers can't use <code>mid</code> as a variable name, hence <code>_Mid</code>. The STL was different - it wasn't part of the language specification, it was defined as \"here are some headers, use them as you will\" </p>\n<p>Your code or mine, on the other hand, would be invalid if it used <code>_Mid</code> as a variable name since that's a reserved name - the implementation is allowed to do:</p>\n<pre><code>#define _Mid\n</code></pre>\n<p>if it feels like it.</p>\n<p>Layout - meh. They probably have a style guide, they probably follow it, more or less. The fact that it doesn't match my style guide (and hence would fail my code review) is nothing to them.</p>\n<p>Operators that are difficult to work out - difficult to whom? Code should be written for the people who maintain it, and GNU/Dinkumware/whoever probably don't want to let people loose on the standard libraries who can't puzzle out <code>*--_Next</code> at a glance. If you use that sort of expression, you get used to it, and if you don't you'll continue finding it hard.</p>\n<p>I will give, you, though, that <code>operator()</code> overload is gibberish. [Edit: I get it, it's a linear congruential generator, done very generically, and if the modulus is \"0\" that means just use the natural wraparound of the arithmetic type.]</p>\n", "LastActivityDate": "2010-11-14T23:31:17.600"}, "bq_ids": {"n4140": {"so_4180166_4180207_2": {"section_id": 6307, "quality": 1.0, "length": 10}, "so_4180166_4180207_1": {"section_id": 6307, "quality": 1.0, "length": 13}, "so_4180166_4180207_0": {"section_id": 6307, "quality": 1.0, "length": 8}}, "n3337": {"so_4180166_4180207_2": {"section_id": 6064, "quality": 1.0, "length": 10}, "so_4180166_4180207_1": {"section_id": 6064, "quality": 1.0, "length": 13}, "so_4180166_4180207_0": {"section_id": 6064, "quality": 1.0, "length": 8}}, "n4659": {"so_4180166_4180207_2": {"section_id": 6756, "quality": 0.9, "length": 9}, "so_4180166_4180207_1": {"section_id": 6756, "quality": 0.9230769230769231, "length": 12}, "so_4180166_4180207_0": {"section_id": 7844, "quality": 0.625, "length": 5}}}, "4180342": {"ParentId": "4180166", "CommentCount": "0", "CreationDate": "2010-11-14T23:29:28.590", "OwnerUserId": "456", "PostTypeId": "2", "Id": "4180342", "Score": "1", "Body": "<p>To add on what people have said already, the style you see is the GNU style. Ugly? Perhaps, that's in the eye of the beholder. But it's a strictly-defined style, and it does make all code look similar, as opposed to resistant to getting used to.</p>\n", "LastActivityDate": "2010-11-14T23:29:28.590"}, "4180215": {"ParentId": "4180166", "CommentCount": "2", "CreationDate": "2010-11-14T23:02:19.760", "OwnerUserId": "322806", "PostTypeId": "2", "Id": "4180215", "Score": "2", "Body": "<p>I suspect part of the reason is that the code in the STL is highly optimized. The sort of code being implemented has performance being much more important then readability. Because they are so widely used it makes sense to make them as fast as possible.</p>\n", "LastActivityDate": "2010-11-14T23:02:19.760"}, "4180299": {"ParentId": "4180166", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2010-11-14T23:20:54.607", "Score": "16", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:26:38.723", "Id": "4180299", "OwnerUserId": "464581", "Body": "<p>Neil Butterworth, now listed as \"anon\", provided a useful link in his answer to the SO question <a href=\"https://stackoverflow.com/questions/2127612/is-there-a-readable-implementation-of-the-stl\">\"Is there a readable implementation of the STL?\"</a>. Quoting his answer there:</p>\n<blockquote>\n<p id=\"so_4180166_4180299_0\">There is a book The C++ Standard\n  Template Library, co-authored by the\n  original STL designers Stepanov &amp; Lee\n  (together with P.J. Plauger and David\n  Musser), which describes a possible\n  implementation, complete with code -\n  see\n  <a href=\"http://www.amazon.co.uk/C-Standard-Template-Library/dp/0134376331\" rel=\"nofollow noreferrer\">http://www.amazon.co.uk/C-Standard-Template-Library/dp/0134376331</a>.</p>\n</blockquote>\n<p>See also the other answers in that thread.</p>\n<p>Anyway, most of the STL code (by STL I here mean the STL-like subset of the C++ standard library) is template code, and as such must be header-only, and since it's used in almost every program it pays to have that code as short as possible.</p>\n<p>Thus, the natural trade-off point between conciseness and readability is much farther over on the conciseness end of the scale than with \"normal\" code.</p>\n<p>In addition, the standard library is where the system-independent view of application code is connected to the underlying system, utilizing all kinds of compiler-specific things that you as an application developer should best stay away from.</p>\n<p>Cheers &amp; hth.,</p>\n", "LastActivityDate": "2010-11-14T23:20:54.607"}, "4180207": {"ParentId": "4180166", "CommentCount": "3", "CreationDate": "2010-11-14T23:00:12.507", "OwnerUserId": "252000", "PostTypeId": "2", "Id": "4180207", "Score": "14", "Body": "<p>About the variables names, library implementors must use \"crazy\" naming conventions, such as names starting with an underscore followed by an uppercase letter, because such names are reserved for them. They cannot use \"normal\" names, because those may have been redefined by a user macro.</p>\n<p>Section 17.6.3.3.2 \"Global names\" \u00a71 states:</p>\n<blockquote>\n<p id=\"so_4180166_4180207_0\">Certain sets of names and function signatures are always reserved to the implementation:</p>\n<ul>\n<li><p id=\"so_4180166_4180207_1\">Each name that contains a double underscore or begins with an underscore followed by an uppercase letter is reserved to the implementation for any use.</p></li>\n<li><p id=\"so_4180166_4180207_2\">Each name that begins with an underscore is reserved to the implementation for use as a name in the global namespace.</p></li>\n</ul>\n</blockquote>\n<p>(Note that these rules forbid header guards like <code>__MY_FILE_H</code> which I have seen quite often.)</p>\n", "LastActivityDate": "2010-11-14T23:00:12.507"}});