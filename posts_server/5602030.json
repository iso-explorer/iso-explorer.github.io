post_cb({"bq_ids": {"n4140": {"so_5602030_5602057_2": {"length": 4, "quality": 1.0, "section_id": 3285}, "so_5602030_5602057_1": {"length": 4, "quality": 1.0, "section_id": 3287}, "so_5602030_5602057_0": {"length": 7, "quality": 1.0, "section_id": 3290}}, "n3337": {"so_5602030_5602057_2": {"length": 4, "quality": 1.0, "section_id": 3155}, "so_5602030_5602057_1": {"length": 4, "quality": 1.0, "section_id": 3157}, "so_5602030_5602057_0": {"length": 7, "quality": 1.0, "section_id": 3160}}, "n4659": {"so_5602030_5602057_0": {"length": 7, "quality": 1.0, "section_id": 4052}}}, "5602057": {"Id": "5602057", "PostTypeId": "2", "Body": "<p>The only sensible thing you can do with a C-array in C++03 is value-initialize it (in C++11 and beyond it can be list-initialized).</p>\n<p>From the C++03 standard, \u00a78.5/7:</p>\n<blockquote>\n<p id=\"so_5602030_5602057_0\">An object whose initializer is an empty set of parentheses, i.e., (), shall be value-initialized.</p>\n</blockquote>\n<p>And from \u00a78.5/5:</p>\n<blockquote>\n<p id=\"so_5602030_5602057_1\">To <em>value-initialize</em> an object of type <code>T</code> means:</p>\n<ul>\n<li>if <code>T</code> is a class type with a user-declared constructor, then the default constructor for <code>T</code> is called (and the initialization is ill-formed if <code>T</code> has no accessible default constructor);</li>\n<li>if <code>T</code> is a non-union class type without a user-declared constructor, then every non-static data member and base-class component of <code>T</code> is value-initialized;</li>\n<li><strong>if <code>T</code> is an array type, then each element is value-initialized;</strong></li>\n<li><strong>otherwise, the object is zero-initialized</strong></li>\n</ul>\n<p id=\"so_5602030_5602057_2\">To <em>zero-initialize</em> an object of type <code>T</code> means:</p>\n<ul>\n<li><strong>if <code>T</code> is a scalar type, the object is set to the value of <code>0</code> (zero) converted to <code>T</code>;</strong></li>\n<li>if <code>T</code> is a non-union class type, each nonstatic data member and each base-class subobject is zero-initialized;</li>\n<li>if <code>T</code> is a union type, the object\u2019s first named data member) is zero-initialized;</li>\n<li>if <code>T</code> is an array type, each element is zero-initialized;</li>\n<li>if <code>T</code> is a reference type, no initialization is performed.</li>\n</ul>\n</blockquote>\n<p>So, if your constructor definition is changed to</p>\n<pre><code>A::A() : a(), ptr() { }\n</code></pre>\n<p>then you are guaranteed that post-construction, all 5 elements of <code>A::a</code> will have the value <code>'\\0'</code> and <code>A::ptr</code> will be null.</p>\n", "LastEditorUserId": "636019", "LastActivityDate": "2014-11-11T15:09:51.993", "Score": "19", "CreationDate": "2011-04-09T00:27:59.840", "ParentId": "5602030", "CommentCount": "0", "LastEditDate": "2014-11-11T15:09:51.993", "OwnerUserId": "636019"}, "5602047": {"Id": "5602047", "PostTypeId": "2", "Body": "<p>Afraid not; C++ doesn't support initialising arrays like this.</p>\n<p>You'll just have to assign to its members in <code>A</code>'s constructor body, or you can use <em>value-initialisation</em> if you don't really care what the values are:</p>\n<pre><code>struct A {\n   int x[5];\n   A() : x();\n};\n</code></pre>\n<p>C++0x does let you give all the values, though:</p>\n<pre><code>struct A {\n   int x[5];\n   A() : x{1,2,3,4,5} {}\n};\n</code></pre>\n<p>Note, though, that because arrays are not <code>class-object</code>s, you won't be able to do this:</p>\n<pre><code>struct A {\n   int x[5];\n   A(std::initializer_list&lt;int[5]&gt;&amp; i) // or whatever the T should be\n      : x{i} // or x(i)\n        {}\n}\nA a({1,2,3,4,5)};\n</code></pre>\n", "LastEditorUserId": "560648", "LastActivityDate": "2011-04-09T15:12:10.943", "Score": "3", "CreationDate": "2011-04-09T00:25:50.727", "ParentId": "5602030", "CommentCount": "11", "LastEditDate": "2011-04-09T15:12:10.943", "OwnerUserId": "560648"}, "5602030": {"ViewCount": "5508", "Body": "<pre><code>class A {\npublic:\n   A();\n\nprivate:\n   char a[5];\n   int* ptr;\n};\n\nA::A() : a(0), ptr(0) { }\n</code></pre>\n<p>Is this right?</p>\n", "AcceptedAnswerId": "5602057", "Title": "How can i use member initialization list to initialize an array?", "CreationDate": "2011-04-09T00:20:56.983", "Id": "5602030", "CommentCount": "0", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2015-07-08T12:30:17.453", "LastEditorUserId": "28169", "LastActivityDate": "2015-07-08T12:30:17.453", "Score": "7", "OwnerUserId": "435645", "Tags": "<c++><constructor>", "AnswerCount": "2"}});