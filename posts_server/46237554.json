post_cb({"bq_ids": {"n4140": {"so_46237554_46237554_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 48}, "so_46237554_46237554_0": {"length": 43, "quality": 0.9772727272727273, "section_id": 7195}, "so_46237554_46237554_2": {"length": 12, "quality": 1.0, "section_id": 7195}}, "n3337": {"so_46237554_46237554_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 3082}, "so_46237554_46237554_0": {"length": 43, "quality": 0.9772727272727273, "section_id": 6939}, "so_46237554_46237554_2": {"length": 12, "quality": 1.0, "section_id": 6939}}, "n4659": {"so_46237554_46237554_3": {"length": 5, "quality": 0.7142857142857143, "section_id": 7342}, "so_46237554_46237554_0": {"length": 43, "quality": 0.9772727272727273, "section_id": 8704}, "so_46237554_46237554_2": {"length": 12, "quality": 1.0, "section_id": 8704}}}, "46237554": {"ViewCount": "47", "Body": "<p>As said in standard:</p>\n<blockquote>\n<p id=\"so_46237554_46237554_0\">3.8.8 If, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, a new object is created at the storage location which the original object occupied, a pointer that pointed to the original object, a reference that referred to the original object, or the name of the original object will automatically refer to the new object and, once the lifetime of the new object has started, can be\n  used to manipulate the new object, if:</p>\n<p id=\"so_46237554_46237554_1\">&lt;...&gt;</p>\n<p id=\"so_46237554_46237554_2\">(8.3) &lt;...&gt; and, if a class type, does not contain any non-static data member whose type is const-qualified or a reference type, &lt;...&gt;</p>\n</blockquote>\n<p>and \"data member\" means only direct members of class, not members of their members:</p>\n<blockquote>\n<p id=\"so_46237554_46237554_3\">9.2.3 A data member is a non-function member introduced by a member-declarator.</p>\n</blockquote>\n<p>So, if we use tricky wrapper for const members:</p>\n<pre><code>template&lt;class T&gt;\nclass const_wrapper\n{\n    struct Inner { const T value; };\n    // non-const member, so const_wrapper is accessible through its name or pointer to it?\n    Inner wrapped_value;\n\n    public:\n    const_wrapper(const T&amp; v) : wrapped_value({v}) {}\n    const_wrapper(T&amp;&amp;) : wrapped_value({std::move(v)}) {}\n\n    operator const T&amp; () {\n            // accessed through launder -&gt; Ok?\n            return std::launder(&amp;wrapped_value)-&gt;value; \n    }\n\n};\n</code></pre>\n<p>(of course, it is much simplier to have non-const <code>T value</code> direct in <code>const_wrapper</code> and no <code>std::launder</code> call. But I have theoretical interest whether it is correct)</p>\n<p>... then it is possible to create class like following:</p>\n<pre><code>struct S\n{\n    const_wrapper&lt;int&gt; i;\n    void foo(int n) const { return i + n; }\n}\n</code></pre>\n<p>which storage can be reused without problems with UB and need to explicit use std::launder?</p>\n<pre><code>S s{4};\nS * ps = &amp;s;\ns.~S();\ns.S{5}\ncout &lt;&lt; ps-&gt;i &lt;&lt; ps-&gt;foo(3); // no UB, prints \"58\" ?\n</code></pre>\n<p>Or there are some other problems I didn't mention?</p>\n", "Title": "Can class with wrapped const and ref members safely reuse its storage?", "CreationDate": "2017-09-15T10:35:49.080", "LastActivityDate": "2017-09-15T10:35:49.080", "CommentCount": "0", "PostTypeId": "1", "Id": "46237554", "Score": "1", "OwnerUserId": "6092128", "Tags": "<c++><const><undefined-behavior><c++1z>", "AnswerCount": "0"}});