post_cb({"14774217": {"Id": "14774217", "PostTypeId": "2", "Body": "<p>I would not assume that any implicit type will be initialized to 0. You may find this is the case when you are running inside the debugger and using the debug heap/stack. When you are outside of the debugger or disable the debug heap via _NO_DEBUG_HEAP=1 environment variable or otherwise you will find that memory is not initialized in most cases.</p>\n<p>As a rule of thumb initialize your variables as it is safer to program this way.</p>\n<p>EDIT: As pointed out by Luchian Grigore global/namespace scope variables are an exception. They also often don't work with uninitialized variable checks due to this initialization.</p>\n", "LastActivityDate": "2013-02-08T13:59:50.330", "CommentCount": "1", "CreationDate": "2013-02-08T13:59:50.330", "ParentId": "14774152", "Score": "-1", "OwnerUserId": "876651"}, "14774284": {"Id": "14774284", "PostTypeId": "2", "Body": "<p>The full rules are in [dcl.init] (C++11). To summarize: when no initialiser is provided in a declaration, the entity is so-called <em>default-initialised.</em> For class types, this means the default constructor is called. For non-class types, this means <strong>no initialisation is performed.</strong></p>\n<p>However, [dcl.init] \u00a79 states: \"Every object of static storage duration is zero-initialized at program startup before any other initialization takes place.\"</p>\n<p>This means that static-duration variables (such as namespace-scope variables) of non-class type are zero-initialised. Other objects of non-class types (such as local variables) are <strong>not</strong> initialised.</p>\n", "LastActivityDate": "2013-02-08T14:03:58.483", "CommentCount": "2", "CreationDate": "2013-02-08T14:03:58.483", "ParentId": "14774152", "Score": "6", "OwnerUserId": "1782465"}, "14774152": {"ViewCount": "1319", "Body": "<p>I grew some doubts after discussing this with colleagues...</p>\n<p>As the title asks, when can it be assumed that built-in types will be initialized to 0 instead of an unknown value?</p>\n<p>Do the rules vary among the c++ standards?</p>\n", "AcceptedAnswerId": "14774284", "Title": "When are C++ implicit types initialized to 0?", "CreationDate": "2013-02-08T13:56:53.533", "Id": "14774152", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-02-08T17:13:11.427", "LastEditorUserId": "16287", "LastActivityDate": "2013-02-08T23:37:15.720", "Score": "5", "OwnerUserId": "16287", "Tags": "<c++><initialization><built-in-types>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_14774152_14774430_2": {"length": 9, "quality": 0.9, "section_id": 7166}, "so_14774152_14774430_4": {"length": 11, "quality": 0.7857142857142857, "section_id": 3289}, "so_14774152_14774430_1": {"length": 9, "quality": 0.6923076923076923, "section_id": 7164}, "so_14774152_14774430_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 3289}, "so_14774152_14774430_3": {"length": 12, "quality": 1.0, "section_id": 3289}}, "n3337": {"so_14774152_14774430_4": {"length": 11, "quality": 0.7857142857142857, "section_id": 3159}, "so_14774152_14774430_3": {"length": 12, "quality": 1.0, "section_id": 3159}, "so_14774152_14774430_1": {"length": 9, "quality": 0.6923076923076923, "section_id": 6908}, "so_14774152_14774430_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 3159}, "so_14774152_14774430_2": {"length": 9, "quality": 0.9, "section_id": 6910}}, "n4659": {"so_14774152_14774430_4": {"length": 11, "quality": 0.7857142857142857, "section_id": 4051}, "so_14774152_14774430_3": {"length": 12, "quality": 1.0, "section_id": 4051}, "so_14774152_14774430_1": {"length": 9, "quality": 0.6923076923076923, "section_id": 8672}, "so_14774152_14774430_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 4051}, "so_14774152_14774430_2": {"length": 9, "quality": 0.9, "section_id": 8674}}}, "14774441": {"Id": "14774441", "PostTypeId": "2", "Body": "<p>Rather than answering the exact question you post, which has been answered before: <em>only POD objects with static storage will be initialized to 0 automatically</em>, I will try to provide pieces of code to get the compiler to initialize the members for you:</p>\n<pre><code>struct POD {\n   int    a;\n   double b; //...\n};\n// namespace level:\nPOD p;\nvoid f() {\n   POD n1;                  // uninitialized\n   POD p1 = {};\n   POD p2 = POD();\n   POD* n2 = new POD;       // uninitialized\n   POD* pp1 = new POD();\n   delete n2; delete pp1;\n}\n</code></pre>\n<p>In the examples above only those marked with 'uninitialized' won't be initiazed. Note that this is with respect to what the standard mandates, your mileage will vary with different compilers. In particular VS has some issues with <code>T t = T();</code> and <code>T* p = new T()'</code> in some scenarios (IIRC when the type <code>T</code> is not a POD, but does not have a user provided default constructor the compiler will fail to initialize the POD subobjects:</p>\n<pre><code>struct T {\n   std::string s;\n   int         i;\n};\nvoid f() {\n   T t = T();    // t.i == 0 according to the standard\n}\n</code></pre>\n", "LastActivityDate": "2013-02-08T14:12:00.570", "CommentCount": "7", "CreationDate": "2013-02-08T14:12:00.570", "ParentId": "14774152", "Score": "3", "OwnerUserId": "36565"}, "14774430": {"Id": "14774430", "PostTypeId": "2", "Body": "<h2>Theory:</h2>\n<p>According to both <strong>C++98</strong> and <strong>C++03</strong> standards:</p>\n<p><strong>3.6.2 Initialization of non-local objects, \u00a71</strong>:</p>\n<blockquote>\n<p id=\"so_14774152_14774430_0\">Objects with static storage duration (3.7.1) shall be zero-initialized (8.5) before any other initialization takes place.</p>\n</blockquote>\n<p><strong>3.7.1 Static storage duration, \u00a71</strong>:</p>\n<blockquote>\n<p id=\"so_14774152_14774430_1\">All objects which neither have dynamic storage duration nor are local have <em>static storage duration.</em></p>\n</blockquote>\n<p><strong>3.7.1  Static storage duration,  \u00a73</strong>:</p>\n<blockquote>\n<p id=\"so_14774152_14774430_2\">The keyword <code>static</code> can be used to declare a local variable with static storage duration.</p>\n</blockquote>\n<p>And also <strong>8.5  Initializers,  \u00a76</strong>:</p>\n<blockquote>\n<p id=\"so_14774152_14774430_3\">Every object of static storage duration shall be zero-initialized at program startup before any other initialization takes place.</p>\n</blockquote>\n<p>This is the same in both standards. The only difference is in formulation of <strong>C++98's 8.5 \u00a76</strong>:</p>\n<blockquote>\n<p id=\"so_14774152_14774430_4\">The memory occupied by any object of static storage duration shall be zero-initialized\n  at program startup before any other initialization takes place.</p>\n</blockquote>\n<hr>\n<h2>Example:</h2>\n<p>Here's the example, where <code>x</code> and <code>y</code> and  have static storage duration, thus standard guarantees that both of them will be zero-initialized at program startup. Note that there are also POD objects <code>a</code> and <code>b</code> declared in the same manner, thus having static storage duration, which means that their members (<code>i</code> and <code>d</code>) will be zero-initialized as well:</p>\n<pre><code>struct POD {\n    int i;\n    double d;\n};\n\nint x;\nPOD a;\n\nint foo() {\n    static int y;\n    return y;\n}\n\nint main() {\n    static POD b;\n    std::cout &lt;&lt; \"x   = \" &lt;&lt; x      &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"y   = \" &lt;&lt; foo()  &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"a.i = \" &lt;&lt; a.i    &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"b.d = \" &lt;&lt; b.d    &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Output of this example is then of course:</p>\n<pre><code>x   = 0\ny   = 0\na.i = 0\nb.d = 0\n</code></pre>\n</hr>", "LastEditorUserId": "1168156", "LastActivityDate": "2013-02-08T23:37:15.720", "Score": "3", "CreationDate": "2013-02-08T14:11:19.937", "ParentId": "14774152", "CommentCount": "0", "OwnerUserId": "1168156", "LastEditDate": "2013-02-08T23:37:15.720"}});