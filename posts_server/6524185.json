post_cb({"6524855": {"ParentId": "6524185", "CommentCount": "1", "Body": "<p>The compiler is wrong in accepting the first use. Even if the copy is elided, the copy constructor must be accessible for the code to be correct.</p>\n<p>In this particular case there is an implicitly declared copy constructor in <code>A</code>:</p>\n<blockquote>\n<p id=\"so_6524185_6524855_0\">\u00a712.8/4 If the class definition does not explicitly declare a copy constructor, one is declared implicitly.</p>\n</blockquote>\n<p>That is implicitly defined:</p>\n<blockquote>\n<p id=\"so_6524185_6524855_1\">\u00a712.8/7 An implicitly-declared copy constructor is implicitly defined if it is used to initialize an object of its class type from a copy of an object of its class type or of a class type derived from its class type108). [Note: the copy constructor is implicitly defined even if the implementation elided its use (12.2). ] A program is <strong>ill-formed</strong> if the class for which a copy constructor is implicitly defined has:</p>\n<p id=\"so_6524185_6524855_2\">\u2014 a nonstatic data member of class type (or array thereof) with an inaccessible or ambiguous copy constructor, or</p>\n<p id=\"so_6524185_6524855_3\">\u2014 a <strong>base class with an inaccessible</strong> or ambiguous copy constructor.</p>\n</blockquote>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "6524855", "Score": "5", "CreationDate": "2011-06-29T17:34:08.537", "LastActivityDate": "2011-06-29T17:34:08.537"}, "6524185": {"CommentCount": "3", "AcceptedAnswerId": "6524855", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-06-29T16:40:40.690", "LastActivityDate": "2011-06-29T17:54:04.203", "LastEditDate": "2017-05-23T12:03:56.217", "ViewCount": "8431", "FavoriteCount": "2", "Title": "private copy constructor/assignment operator and copy-initialization", "Id": "6524185", "Score": "8", "Body": "<p>This is a followup of <a href=\"https://stackoverflow.com/questions/6523624/c-class-type-copy-initialization\">this question</a></p>\n<p>in the following code, why does line 1 compiles while line 2 and 3 does not (using visual C++ 2010)</p>\n<pre><code>class ABase\n{\nprotected:\n    ABase() {}\n    ~ABase() {}\nprivate:\n    ABase( const ABase&amp; );\n    const ABase&amp; operator=( const ABase&amp; );\n};\n\nclass A : ABase\n{\n};\n\nclass B\n{\npublic:\n    B() {}\n    ~B() {}\nprivate:\n    B( const B&amp; );\n    const B&amp; operator=( const B&amp; );\n};\n\nint main( void )\n{\n    A a = A(); // line 1\n    A a2( a ); // line 2\n    B b = B(); // line 3\n\n    return 0;\n}\n</code></pre>\n<p>(note BA is a copy of boost::noncopyable)</p>\n<p><strong>edit:</strong>\nMy problem is not to know why line 2 and 3 does not compile (I know that, the copy constructor is private), but why line 1 does.</p>\n", "Tags": "<c++><boost>", "OwnerUserId": "821485", "AnswerCount": "6"}, "6524454": {"ParentId": "6524185", "CommentCount": "1", "Body": "<p>Line 1 is a return value optimization (the compiler sees that there is no need to create a temporary variable for <code>A()</code> and use the copy constructor/assignment operator to assign to variable <code>a</code>). However, this does not compile on GCC (version 4.2.1) and should be avoided.</p>\n<p>Line 2 does not compile because the compiler isn't generating an assignment operator for you in this case. Line 3 is not compiling, as you expect.</p>\n<p>Reagan summary: line 1 works because it's Microsoft, the others behave as expected.</p>\n", "OwnerUserId": "167251", "PostTypeId": "2", "Id": "6524454", "Score": "1", "CreationDate": "2011-06-29T16:58:59.013", "LastActivityDate": "2011-06-29T16:58:59.013"}, "6525078": {"ParentId": "6524185", "CommentCount": "0", "Body": "<p>Why does line 1 compile?  Because your compiler is broken; it shouldn't,\naccording to the standard.  While your class <code>A</code> has an implicitly\ndeclared copy constructor, \u00a712.8/7 of the standard states that An\nimplicitly-declared copy constructor will be implicitly defined if it is\nused to initialize an object (as in <code>A a = A();</code>), and that a program is\nill formed (and thus requiring a diagnostic) if the constructor is\nimplicitly defiend and a base class has an inaccessible or ambiguous\ncopy constructor.  There's even a note saying this is the case even if\nthe implementation elides the copy constructor.  You're compiler is not\ngoing far enough: it sees the implicitly declared public copy\nconstructor, but it doesn't try to implicitly define it, even though the\nstandard clearly says it should.</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "6525078", "Score": "1", "CreationDate": "2011-06-29T17:54:04.203", "LastActivityDate": "2011-06-29T17:54:04.203"}, "6524512": {"ParentId": "6524185", "CommentCount": "1", "Body": "<p>Indeed line 1 should not compile.</p>\n<p>Apparently vc++2010 has problems enforcing language rules in this case (may be because they're related to a base class and not to the object itself).</p>\n<p>g++ diagnostic message about line 1 is very clear</p>\n<pre><code>ncopy.cpp: In copy constructor \u2018A::A(const A&amp;)\u2019:\nncopy.cpp:7: error: \u2018ABase::ABase(const ABase&amp;)\u2019 is private\nncopy.cpp:12: error: within this context\nncopy.cpp: In function \u2018int main()\u2019:\nncopy.cpp:27: note: synthesized method \u2018A::A(const A&amp;)\u2019 first required here \n</code></pre>\n", "OwnerUserId": "320726", "PostTypeId": "2", "Id": "6524512", "Score": "6", "CreationDate": "2011-06-29T17:03:38.607", "LastActivityDate": "2011-06-29T17:03:38.607"}, "6524280": {"ParentId": "6524185", "PostTypeId": "2", "CommentCount": "3", "Body": "<pre><code>ABase( const ABase&amp; );\n</code></pre>\n<p>The copy constructor is made private so a copy of the class object cannot be created using this private copy constructor resulting in error.</p>\n<pre><code>A a = A(); // line 1\n</code></pre>\n<p>Uses the <code>A::A(const A&amp;)</code> to create a new <code>A</code> object. <code>A</code> is derived from <code>ABase</code> and it calls\n<code>ABase::ABase(const ABase&amp;)</code> in its constructor, which is private to it wont compile either.    </p>\n<p>Here is the <a href=\"http://www.ideone.com/jAhjR\" rel=\"nofollow noreferrer\"><strong>output</strong></a> on Ideone. It doesn't compile even on gcc.</p>\n<p><strong><em>Why it works on Visual studio?</em></strong><br>\nThe reason is a possible <strong>Return Value optimization</strong> by the visual C++ compiler which elides the copy constructor.</br></p>\n<p>As per the C++ standard, <strong><em>12.8 copying class objects section 15</em></strong></p>\n<p><em>When certain criteria are met, an implementation is allowed to omit the copy construction of a class object, even if the copy constructor and/or destructor for the object have side effects. In such cases, the implemen-tation treats the source and target of the omitted copy operation as simply two different ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects would have been destroyed without the optimization.111)</em> </p>\n<p>See my answer <strong><a href=\"https://stackoverflow.com/questions/6523624/c-class-type-copy-initialization/6523784#6523784\">here</a></strong> which cites the Standard and the example code in this regard.</p>\n<pre><code>A a2( a ); // line 2\n</code></pre>\n<p>Does not compile for the same reason that <code>ABase::ABase(const ABase&amp;)</code> is private.</p>\n<pre><code> B b = B(); // line 3\n</code></pre>\n<p>Does not compile because <code>B( const B&amp; );</code> is private.</p>\n", "OwnerUserId": "452307", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:27:13.000", "Id": "6524280", "Score": "2", "CreationDate": "2011-06-29T16:47:32.743", "LastActivityDate": "2011-06-29T17:04:54.413"}, "bq_ids": {"n4140": {"so_6524185_6524855_0": {"section_id": 456, "quality": 0.9090909090909091, "length": 10}, "so_6524185_6524855_3": {"section_id": 41, "quality": 0.6666666666666666, "length": 4}, "so_6524185_6524855_2": {"section_id": 369, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_6524185_6524855_1": {"section_id": 453, "quality": 0.6666666666666666, "length": 26}, "so_6524185_6524855_0": {"section_id": 447, "quality": 0.9090909090909091, "length": 10}, "so_6524185_6524855_3": {"section_id": 38, "quality": 0.6666666666666666, "length": 4}, "so_6524185_6524855_2": {"section_id": 451, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_6524185_6524855_0": {"section_id": 479, "quality": 0.9090909090909091, "length": 10}, "so_6524185_6524855_3": {"section_id": 41, "quality": 0.6666666666666666, "length": 4}, "so_6524185_6524855_2": {"section_id": 382, "quality": 0.7272727272727273, "length": 8}}}, "6524356": {"ParentId": "6524185", "CommentCount": "4", "Body": "<p>I believe it is because the constructor is protected, not private. The compiler provided constructor in class A is free to call the protected constructor of class ABase, so it works.</p>\n<p>Also, line 1 is not a copy constructor. A declaration with an assignment is a special case which is converted into a constructor.</p>\n", "OwnerUserId": "13422", "PostTypeId": "2", "Id": "6524356", "Score": "0", "CreationDate": "2011-06-29T16:52:34.663", "LastActivityDate": "2011-06-29T16:52:34.663"}});