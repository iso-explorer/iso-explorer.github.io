post_cb({"32845154": {"ParentId": "32844948", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The compiler does RVO even though you specified <code>/Od</code>. It is allowed to do so by the C++ standard (\u00a712.8/31,32 as Kerrek SB points out)</p>\n<p>If you really want to see the difference, you can declare your variable as <code>volatile</code>. This will disallow the compiler from performing RVO on it. (\u00a712.8/31 item 1)</p>\n", "OwnerUserId": "1071362", "LastEditorUserId": "1071362", "LastEditDate": "2015-09-29T13:31:09.727", "Id": "32845154", "Score": "4", "CreationDate": "2015-09-29T13:22:47.117", "LastActivityDate": "2015-09-29T13:31:09.727"}, "bq_ids": {"n4140": {"so_32844948_32845247_0": {"section_id": 481, "quality": 0.9361702127659575, "length": 88}}, "n3337": {"so_32844948_32845247_0": {"section_id": 472, "quality": 0.6808510638297872, "length": 64}}, "n4659": {"so_32844948_32845247_0": {"section_id": 504, "quality": 0.8191489361702128, "length": 77}}}, "32845247": {"ParentId": "32844948", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>There's a fundamental piece of info you're missing: the standard specifically enforces that when a <code>return</code> statement (and a few other, less common contexts) specifies a function-local variable (such as <code>o</code> in your case), overload resolution to construct the return value from the argument is first performed as if the argument was an rvalue (even though it's not). Only when this fails is overload resolution done again, with the lvalue. This is covered by C++14 12.8/32; similar wording exists in C++11.</p>\n<blockquote>\n<p id=\"so_32844948_32845247_0\"><strong>12.8/32</strong> When the criteria for elision of a copy/move operation are met, but not for an <em>exception-declaration,</em> and the\n  object to be copied is designated by an lvalue, <strong>or when the expression in a <code>return</code> statement is a (possibly\n  parenthesized) <em>id-expression</em> that names an object with automatic storage duration declared in the body or\n  <em>parameter-declaration-clause</em> of the innermost enclosing function or <em>lambda-expression,</em> overload resolution\n  to select the constructor for the copy is first performed as if the object were designated by an rvalue</strong>. If\n  the first overload resolution fails or was not performed, or if the type of the first parameter of the selected\n  constructor is not an rvalue reference to the object\u2019s type (possibly cv-qualified), overload resolution is\n  performed again, considering the object as an lvalue. [ <em>Note:</em> This two-stage overload resolution must be\n  performed regardless of whether copy elision will occur. It determines the constructor to be called if elision\n  is not performed, and the selected constructor must be accessible even if the call is elided. <em>\u2014end note</em> ] ...</p>\n</blockquote>\n<p>(Emphasis mine)</p>\n<p>So in effect, there's an <em>unvaoidable, implicit <code>std::move</code></em> present in every <code>return</code> statement when returning a function-scope automatic variable.</p>\n<p>Using <code>std::move</code> in a return statement is, if anything, a <em>pessimisation.</em> It prevents NRVO, and does not get you anything, due to the \"implicitly try rvalue first\" rule.</p>\n", "OwnerUserId": "1782465", "LastEditorUserId": "1782465", "LastEditDate": "2015-09-29T14:03:04.563", "Id": "32845247", "Score": "8", "CreationDate": "2015-09-29T13:26:47.880", "LastActivityDate": "2015-09-29T14:03:04.563"}, "32844948": {"CommentCount": "6", "AcceptedAnswerId": "32845247", "CreationDate": "2015-09-29T13:12:30.477", "LastActivityDate": "2015-09-29T14:03:04.563", "PostTypeId": "1", "ViewCount": "325", "FavoriteCount": "2", "Title": "std::move and RVO optimizations", "Id": "32844948", "Score": "4", "Body": "<p>I've recently read how <code>std::move</code> can speed up code by just moving the values instead of copying them. So I made a test program to compare the speed using <code>std::vector</code>.</p>\n<p>The code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;stdint.h&gt;\n\n#ifdef WIN32\n#include &lt;Windows.h&gt;\n#else\n#include &lt;sys/time.h&gt;\n#include &lt;ctime&gt;\n#endif\n#undef max\n\n// Returns the amount of milliseconds elapsed since the UNIX epoch. Works on both\n// windows and linux.\n\nuint64_t GetTimeMs64()\n{\n#ifdef _WIN32\n    // Windows\n    FILETIME ft;\n    LARGE_INTEGER li;\n\n    // Get the amount of 100 nano seconds intervals elapsed since January 1, 1601 (UTC) and copy it\n    // to a LARGE_INTEGER structure.\n    GetSystemTimeAsFileTime(&amp;ft);\n    li.LowPart = ft.dwLowDateTime;\n    li.HighPart = ft.dwHighDateTime;\n\n    uint64_t ret = li.QuadPart;\n    ret -= 116444736000000000LL; // Convert from file time to UNIX epoch time.\n    ret /= 10000; // From 100 nano seconds (10^-7) to 1 millisecond (10^-3) intervals\n\n    return ret;\n#else\n    // Linux\n    struct timeval tv;\n\n    gettimeofday(&amp;tv, NULL);\n\n    uint64 ret = tv.tv_usec;\n    // Convert from micro seconds (10^-6) to milliseconds (10^-3)\n    ret /= 1000;\n\n    // Adds the seconds (10^0) after converting them to milliseconds (10^-3)\n    ret += (tv.tv_sec * 1000);\n\n    return ret;\n#endif\n}\n\nstatic std::vector&lt;std::string&gt; GetVec1()\n{\n    std::vector&lt;std::string&gt; o(100000, \"abcd\");\n    bool tr = true;\n    if (tr)\n        return std::move(o);\n    return std::move(std::vector&lt;std::string&gt;(100000, \"abcd\"));\n}\n\nstatic std::vector&lt;std::string&gt; GetVec2()\n{\n    std::vector&lt;std::string&gt; o(100000, \"abcd\");\n    bool tr = true;\n    if (tr)\n        return o;\n    return std::vector&lt;std::string&gt;(100000, \"abcd\");\n}\n\nint main()\n{\n    uint64_t timer;\n    std::vector&lt;std::string&gt; vec;\n\n    timer = GetTimeMs64();\n    for (int i = 0; i &lt; 1000; ++i)\n        vec = GetVec1();\n    std::cout &lt;&lt; GetTimeMs64() - timer &lt;&lt; \" timer 1(std::move)\" &lt;&lt; std::endl;\n    timer = GetTimeMs64();\n    for (int i = 0; i &lt; 1000; ++i)\n        vec = GetVec2();\n    std::cout &lt;&lt; GetTimeMs64() - timer &lt;&lt; \" timer 2(no move)\" &lt;&lt; std::endl;\n    std::cin.get();\n    return 0;\n}\n</code></pre>\n<p>I got the following results:</p>\n<p><strong>Release (x86) /O2. <code>tr = true</code></strong></p>\n<blockquote>\n<p id=\"so_32844948_32844948_0\">4376 timer 1(std::move)</p>\n<p id=\"so_32844948_32844948_1\">4191 timer 2(no move)</p>\n</blockquote>\n<p><strong>Release (x86) /O2. <code>tr = false</code></strong></p>\n<blockquote>\n<p id=\"so_32844948_32844948_2\">7311 timer 1(std::move)</p>\n<p id=\"so_32844948_32844948_3\">7301 timer 2(no move)</p>\n</blockquote>\n<p>The results between the 2 timers are really close and don't really differ that much. I already assumed this is because of <strong>Return value optimization (RVO)</strong> which means that my returns by value are already moved by the compiler without me knowing, right?</p>\n<p>So then I ran new tests without any optimizations to make sure I was right.\nThe results:</p>\n<p><strong>Release (x86) /Od. <code>tr = true</code></strong></p>\n<blockquote>\n<p id=\"so_32844948_32844948_4\">40860 timer 1(std::move)</p>\n<p id=\"so_32844948_32844948_5\">40863 timer 2(no move)</p>\n</blockquote>\n<p><strong>Release (x86) /Od. <code>tr = false</code></strong></p>\n<blockquote>\n<p id=\"so_32844948_32844948_6\">83567 timer 1(std::move)</p>\n<p id=\"so_32844948_32844948_7\">82075 timer 2(no move)</p>\n</blockquote>\n<p>Now even though the difference between /O2 and /Od is really significant, the difference between no move or <code>std::move</code> (and even between <code>tr</code> being <code>true</code> or <code>false</code>) is minimal.</p>\n<p>Does this mean that even though optimizations are disabled, the compiler is allowed to apply <code>RVO</code> or is <code>std::move</code> not as fast as I thought I'd be?</p>\n", "Tags": "<c++><c++11><optimization><visual-studio-2015><return-value-optimization>", "OwnerUserId": "1870760", "AnswerCount": "2"}});