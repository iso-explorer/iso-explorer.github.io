post_cb({"33118925": {"ParentId": "33118895", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You need to deallocate only what you allocate. You allocate five instances of <code>MyClass</code> with <code>new[]</code>. So that's what you need to deallocate.</p>\n<p>You're not deallocating any pointers. Pointers don't need to be deallocated unless you dynamically allocated them, and your code doesn't dynamically allocate any pointers.</p>\n<p>When you make the pointer <code>nullptr</code> (or <code>NULL</code>), it doesn't point to anything. So calling <code>delete</code> on it has no effect. The C++ standard chose to make calling <code>delete</code> (or <code>delete[]</code>) on a null pointer do nothing.</p>\n", "OwnerUserId": "721269", "LastEditorUserId": "721269", "LastEditDate": "2015-10-14T07:29:04.553", "Id": "33118925", "Score": "6", "CreationDate": "2015-10-14T07:14:41.980", "LastActivityDate": "2015-10-14T07:29:04.553"}, "33119000": {"ParentId": "33118895", "PostTypeId": "2", "CommentCount": "1", "Body": "<p><code>delete[] p1;</code> doesn't <em>ususally</em> change the actual value of <code>p1</code>. (Although the C++ standard states that it <em>can</em> set <code>p1</code> to <code>nullptr</code> on doing this, no compiler I've worked with actually does this).</p>\n<p>So the behaviour on a second call to <code>delete[] p1;</code> is undefined since your program no longer owns that memory.</p>\n<p>Some programmers consider it good practice to set <code>p1 = nullptr</code> explicitly after a <code>delete[]</code> since then a subsequent <code>delete</code> is benign. But doing that can hide other memory management issues your program has (why <em>would</em> your program attempt to <code>delete</code> the same block of memory more than once?), so I'd advise against it.</p>\n", "OwnerUserId": "2380830", "LastEditorUserId": "2380830", "LastEditDate": "2015-10-14T07:22:12.623", "Id": "33119000", "Score": "1", "CreationDate": "2015-10-14T07:18:51.873", "LastActivityDate": "2015-10-14T07:22:12.623"}, "33119136": {"ParentId": "33118895", "CommentCount": "0", "Body": "<p>From the standard, 5.3.5$2 Delete [expr.delete] (bold by me)</p>\n<blockquote>\n<p id=\"so_33118895_33119136_0\">In the first alternative (delete object), the value of the operand of\n  delete may be a <strong>null pointer value</strong>, a pointer to a non-array object\n  created by a previous new-expression, or a pointer to a subobject\n  (1.8) representing a base class of such an object (Clause 10). If not,\n  the behavior is undefined. In the second alternative (delete array),\n  the value of the operand of delete may be a <strong>null pointer value</strong> or a\n  pointer value that resulted from a previous array\n  new-expression.<sup>81</sup> If not, the behavior is undefined.</p>\n</blockquote>\n<p>It explains why delete a pointer twice is <a href=\"https://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow\">UB</a>, and delete a null pointer is well defined.</p>\n", "OwnerUserId": "3309790", "PostTypeId": "2", "Id": "33119136", "Score": "1", "CreationDate": "2015-10-14T07:25:55.827", "LastActivityDate": "2015-10-14T07:25:55.827"}, "bq_ids": {"n4140": {"so_33118895_33119136_0": {"section_id": 6106, "quality": 0.9347826086956522, "length": 43}}, "n3337": {"so_33118895_33119136_0": {"section_id": 5872, "quality": 0.9347826086956522, "length": 43}}, "n4659": {"so_33118895_33119136_0": {"section_id": 7603, "quality": 0.9347826086956522, "length": 43}}}, "33118895": {"CommentCount": "2", "AcceptedAnswerId": "33118925", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-10-14T07:12:41.870", "LastActivityDate": "2015-10-14T07:29:04.553", "LastEditDate": "2017-05-23T12:02:05.337", "ViewCount": "72", "FavoriteCount": "1", "Title": "deallocation of same pointer twice not giving error if I make the pointer NULL", "Id": "33118895", "Score": "4", "Body": "<p>I tried to deallocate same pointer twice and it failed, but if I follow the same steps with not making it NULL the code runs fine.</p>\n<pre><code> #include &lt;iostream&gt;\n\n    struct MyClass {\n      MyClass() {std::cout &lt;&lt; \"Allocated and Constructed\" &lt;&lt; std::endl ;} \n    };\n\n    int main () {\n      // allocates and constructs five objects:\n      MyClass * p1 = new MyClass[5];\n\n      delete[] p1;\n      delete[] p1; // The code will succeed if I comment this line of code\n      p1=NULL;\n      delete[] p1;\n      delete[] p1;\n\n      return 0;\n    }\n</code></pre>\n<p>I see a good answer to the question <a href=\"https://stackoverflow.com/questions/2746677/what-happens-when-you-deallocate-a-pointer-twice-or-more-in-c\">What happens when you deallocate a pointer twice or more in C++?</a> but what makes it run if I make it NULL, shouldn't be the same behaviour to follow for both the cases?</p>\n", "Tags": "<c++>", "OwnerUserId": "3567473", "AnswerCount": "3"}});