post_cb({"47997163": {"ViewCount": "74", "Body": "<p>With C++17 <code>std::byte</code> was added. However, all these legacy interfaces expect <code>const char*</code> for an array of bytes (for example, libpng does). If I'm representing bytes in my code as a container of <code>std::byte</code> objects (for example, <code>std::vector&lt;std::byte&gt;</code>), how do I make use of these interfaces?</p>\n", "AcceptedAnswerId": "47997677", "Title": "How to use interfaces that expect `const char*` if I'm working with `std::byte`s", "CreationDate": "2017-12-27T18:44:34.010", "Id": "47997163", "CommentCount": "4", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2017-12-27T19:34:18.477", "Score": "0", "OwnerUserId": "5736791", "Tags": "<c++><c++17>", "AnswerCount": "2"}, "47997677": {"Id": "47997677", "PostTypeId": "2", "Body": "<p>Given a contiguous buffer of <code>std::byte</code>s, a reinterpretation of a <code>std::byte*</code> to a <code>char*</code> is legal by design and doesn't violate the strict aliasing rule:</p>\n<p>(<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0298r3.pdf\" rel=\"nofollow noreferrer\">wording from the most recent revision of the <code>std::byte</code> proposal</a>)</p>\n<blockquote>\n<p id=\"so_47997163_47997677_0\">Lvalues and rvalues [basic.lval]</p>\n<ol start=\"8\">\n<li><p id=\"so_47997163_47997677_1\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:</p>\n<ul>\n<li><p id=\"so_47997163_47997677_2\">[...]</p></li>\n<li><p id=\"so_47997163_47997677_3\">(8.8) a <code>char</code>, <code>unsigned char</code>, or <code>std::byte</code> type.</p></li>\n</ul></li>\n</ol>\n</blockquote>\n<p>(note: the \"or <code>std::byte</code>\" is added by the proposal)</p>\n<p>So you can use <code>reinterpret_cast&lt;const char*&gt;(pointer_to_std_byte_buffer)</code> or <code>static_cast&lt;const char*&gt;(static_cast&lt;const void*&gt;(pointer_to_std_byte_buffer))</code> or <code>(const char*)pointer_to_std_byte_buffer</code>, depending on what your style guide says.</p>\n", "LastActivityDate": "2017-12-27T19:34:18.477", "Score": "2", "CreationDate": "2017-12-27T19:34:18.477", "ParentId": "47997163", "CommentCount": "1", "OwnerUserId": "1012936"}, "47997246": {"Id": "47997246", "PostTypeId": "2", "Body": "<p>If you insist on using std::byte you'll have to cast when passing to something that expects the elements to be char:</p>\n<pre><code>(char const *)&amp;myVec[0]\n</code></pre>\n", "LastActivityDate": "2017-12-27T18:53:10.573", "Score": "0", "CreationDate": "2017-12-27T18:53:10.573", "ParentId": "47997163", "CommentCount": "3", "OwnerUserId": "7594711"}, "bq_ids": {"n4140": {"so_47997163_47997677_1": {"length": 14, "quality": 1.0, "section_id": 7239}, "so_47997163_47997677_3": {"length": 4, "quality": 0.8, "section_id": 45}}, "n3337": {"so_47997163_47997677_1": {"length": 14, "quality": 1.0, "section_id": 6983}, "so_47997163_47997677_3": {"length": 4, "quality": 0.8, "section_id": 42}}, "n4659": {"so_47997163_47997677_1": {"length": 14, "quality": 1.0, "section_id": 8748}, "so_47997163_47997677_3": {"length": 5, "quality": 1.0, "section_id": 7588}}}});