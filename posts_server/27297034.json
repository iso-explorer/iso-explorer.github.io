post_cb({"bq_ids": {"n4140": {"so_27297034_27297034_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5433}}, "n3337": {"so_27297034_27297034_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5228}}, "n4659": {"so_27297034_27297034_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 6861}}}, "27297034": {"ViewCount": "78", "Body": "<p>According to \u00a77.1.\u200b5.1/4:</p>\n<blockquote>\n<p id=\"so_27297034_27297034_0\">Except that any class member declared mutable (7.1.1) can be modified, any attempt to modify a const object during its lifetime (3.8) results in undefined behavior.</p>\n</blockquote>\n<p>So my question becomes: when is an object a const object?</p>\n<p>In particular, is a const member in a non-const object considered a const object?</p>\n<pre><code>class Foo {\n    const Bar bar;\n\n    void replaceBar(Bar bar2) {\n        *(const_cast&lt;Bar *&gt;&amp;bar) = bar2;  // Undefined behavior?\n    }\n}\n</code></pre>\n<p>This comes up because I have an immutable class (all fields are const), but I want to have a move constructor, which technically modifies the value passed in.  I'm ok with \"cheating\" in that case, since it doesn't break logical constness.</p>\n", "Title": "When is it ok to modify a value when you remove const with const_cast?", "CreationDate": "2014-12-04T14:54:05.103", "LastActivityDate": "2014-12-04T15:59:06.480", "CommentCount": "4", "LastEditDate": "2014-12-04T15:10:40.140", "PostTypeId": "1", "LastEditorUserId": "3917", "Id": "27297034", "Score": "3", "OwnerUserId": "3917", "Tags": "<c++><const-cast>", "AnswerCount": "2"}, "27297201": {"Id": "27297201", "PostTypeId": "2", "Body": "<p>The simple rule is: it is ok to cast away constness if the original object is not const. So if you have a non-cont object and, say, you pass the const reference to it to a function, it is legal to cast away constness in the function.\nIn your example the original object is const, so casting constness away is undefined behaviour.</p>\n", "LastActivityDate": "2014-12-04T15:01:44.373", "CommentCount": "4", "CreationDate": "2014-12-04T15:01:44.373", "ParentId": "27297034", "Score": "2", "OwnerUserId": "2382136"}, "27298394": {"Id": "27298394", "PostTypeId": "2", "Body": "<p>Let us make this a full example:</p>\n<pre><code>struct Bar { int x; };\n\nstruct Foo {\n  const Bar bar;\n  Foo( int x ):bar(x) {}\n\n  void replaceBar(Bar bar2) {\n    *(const_cast&lt;Bar *&gt;&amp;bar) = bar2;  // Undefined behavior?\n  }\n};\n</code></pre>\n<p>now, let us break the world.</p>\n<pre><code>int main() {\n  Foo f(3);\n  Bar b = {2};\n  f.replaceBar(b);\n  std::cout &lt;&lt; f.bar.x &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>the above can and probably should output 3, because a <code>const</code> object <code>Bar</code> was created with <code>x=3</code>.  The compiler can, and should, assume that the <code>const</code> object will be unchanged throughout its lifetime.</p>\n<p>Let's break the world more:</p>\n<pre><code>struct Bar {\n  int* x;\n  Bar(int * p):x(p) {}\n  ~Bar(){ if (x) delete x; }\n  Bar(Bar&amp;&amp; o):x(o.x){o.x=nullptr;}\n  Bar&amp; operator=(Bar&amp;&amp; o){\n    if (x) delete x;\n    x = o.x;\n    o.x = nullptr;\n  }\n  Bar(Bar const&amp;)=delete;\n  Bar&amp; operator=(Bar const&amp;)=delete;\n};\n\nstruct Foo {\n  const Bar bar;\n  Foo( int* x ):bar(x) {}\n\n  void replaceBar(Bar bar2) {\n    *(const_cast&lt;Bar *&gt;&amp;bar) = bar2;  // Undefined behavior?\n  }\n};\n</code></pre>\n<p>now the same game can result in the compiler deleting something twice.</p>\n<pre><code>int main() {\n  int* p1 = new int(3);\n  Foo f( p1 );\n  Bar b( new int(2) );\n  f.replaceBar(std::move(b));\n}\n</code></pre>\n<p>and the compiler will delete <code>p1</code> once within <code>replaceBar</code>, and should delete it also at the end of <code>main</code>.  It can do this, because you guaranteed that <code>f.bar.x</code> would remain unchanged (<code>const</code>) until the end of its scope, then you violated that promise in <code>replaceBar</code>.</p>\n<p>Now, this is just things the compiler has reason to do: the compiler can literally do <strong>anything</strong> once you have modified an object that was declared <code>const</code>, as you have invoked undefined behavior.  Nasal demons, time travel -- anything is up for grabs.</p>\n<p>Compilers use the fact that some behavior is undefined (aka, not allowed) to optimize.</p>\n", "LastActivityDate": "2014-12-04T15:59:06.480", "CommentCount": "0", "CreationDate": "2014-12-04T15:59:06.480", "ParentId": "27297034", "Score": "0", "OwnerUserId": "1774667"}});