post_cb({"33458286": {"ParentId": "7562096", "CommentCount": "2", "Body": "<p>Another alternative is to consider the following class <code>Data</code> with the unique, static member field <code>type</code>:</p>\n<pre><code>template &lt;class T&gt;\nclass Data\n{\npublic:\n    static const std::type_index type;\n};\n// do [static data member initialization](http://stackoverflow.com/q/11300652/3041008)\n// by [generating unique type id](http://stackoverflow.com/q/26794944/3041008)\ntemplate &lt;class T&gt;\nstd::type_index const Data&lt;T&gt;::type = std::type_index(typeid(T));\n</code></pre>\n<p>produces the output (<code>MinGWx64-gcc4.8.4 -std=c++11 -O2</code>)</p>\n<pre><code>printf(\"%s %s\\n\", Data&lt;int&gt;::type.name(), Data&lt;float&gt;::type.name())\n//prints \"i f\"\n</code></pre>\n<p>It's not exactly an integer id or pretty-printable string, nor a <code>constexpr</code>, but can be <a href=\"http://en.cppreference.com/w/cpp/types/type_index\" rel=\"nofollow\">used as an index in (un)ordered associative containers</a>.<br>\nIt also appears to work if the <code>Data.h</code> header is included in multiple files (same <code>hashCode()</code> values).</br></p>\n", "OwnerUserId": "3041008", "PostTypeId": "2", "Id": "33458286", "Score": "0", "CreationDate": "2015-11-01T01:15:33.080", "LastActivityDate": "2015-11-01T01:15:33.080"}, "7569342": {"ParentId": "7562096", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I encountered this exact problem recently.\nMy solution:</p>\n<p>counter.hpp</p>\n<pre><code>class counter\n{\n    static int i;\n    static nexti()\n    {\n        return i++;\n    }\n};\n</code></pre>\n<p>Counter.cpp:</p>\n<pre><code>int counter::i = 0;\n</code></pre>\n<p>templateclass.hpp</p>\n<pre><code>#include \"counter.hpp\"\n\n    template &lt;class T&gt;\n    tclass\n    {\n        static const int id;\n    };\n\n    template &lt;class T&gt;\n    int tclass&lt;T&gt;::id = counter::nexti();\n</code></pre>\n<p>It appers to work properly in MSVC and GCC, with the one exception that you can't use it in a switch statement.</p>\n<p>For various reasons I actually went further, and defined a preprocessor macro that creates a new class from a given name parameter with a static ID (as above) that derives from a common base.</p>\n", "OwnerUserId": "967060", "LastEditorUserId": "967060", "LastEditDate": "2011-09-27T12:53:01.323", "Id": "7569342", "Score": "3", "CreationDate": "2011-09-27T12:45:03.183", "LastActivityDate": "2011-09-27T12:53:01.323"}, "40880739": {"ParentId": "7562096", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Using <a href=\"http://b.atch.se/posts/constexpr-counter/\" rel=\"nofollow noreferrer\">this</a> constant expression counter:</p>\n<pre><code>template &lt;class T&gt;\nclass A\n{\npublic:\n    static constexpr int ID() { return next(); }\n};\nclass DUMMY { };\nint main() {\n    std::cout &lt;&lt; A&lt;char&gt;::ID() &lt;&lt; std::endl;\n    std::cout &lt;&lt; A&lt;int&gt;::ID() &lt;&lt; std::endl;\n    std::cout &lt;&lt; A&lt;BETA&gt;::ID() &lt;&lt; std::endl;\n    std::cout &lt;&lt; A&lt;BETA&gt;::ID() &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>output: (GCC, C++14)</p>\n<pre><code>1\n2\n3\n3\n</code></pre>\n<p>The downside is you will need to guess an upper bound on the number of derived classes for the constant expression counter to work.</p>\n", "OwnerUserId": "7228919", "LastEditorUserId": "7228919", "LastEditDate": "2016-11-30T06:50:46.670", "Id": "40880739", "Score": "1", "CreationDate": "2016-11-30T05:08:19.633", "LastActivityDate": "2016-11-30T06:50:46.670"}, "7562096": {"CommentCount": "17", "ViewCount": "6552", "PostTypeId": "1", "LastEditorUserId": "369872", "CreationDate": "2011-09-26T22:26:18.813", "LastActivityDate": "2016-11-30T06:50:46.670", "Title": "Compile-time constant id", "FavoriteCount": "8", "LastEditDate": "2011-09-27T13:29:19.060", "Id": "7562096", "Score": "39", "Body": "<p>Given the following:</p>\n<pre><code>template&lt;typename T&gt;\nclass A\n{\npublic:\n    static const unsigned int ID = ?;\n};\n</code></pre>\n<p>I want ID to generate a unique compile time ID for every T. I've considered <code>__COUNTER__</code> and the boost PP library but have been unsuccessful so far. How can I achieve this?</p>\n<p>Edit: ID has to be usable as the case in a switch statement</p>\n<p>Edit2: All the answers based on the address of a static method or member are incorrect. Although they do create a unique ID they are not resolved in compile time and therefore can not be used as the cases of a switch statement.</p>\n", "Tags": "<c++><templates><template-meta-programming>", "OwnerUserId": "369872", "AnswerCount": "15"}, "7562810": {"ParentId": "7562096", "CommentCount": "5", "Body": "<p>This seems to work OK for me:</p>\n<pre><code>template&lt;typename T&gt;\nclass Counted\n{\n  public:\n  static int id()\n  {\n    static int v;\n    return (int)&amp;v;\n  }\n};\n\n#include &lt;iostream&gt;\n\nint main()\n{\n  std::cout&lt;&lt;\"Counted&lt;int&gt;::id()=\"&lt;&lt;Counted&lt;int&gt;::id()&lt;&lt;std::endl;\n  std::cout&lt;&lt;\"Counted&lt;char&gt;::id()=\"&lt;&lt;Counted&lt;char&gt;::id()&lt;&lt;std::endl;\n\n}\n</code></pre>\n", "OwnerUserId": "221955", "PostTypeId": "2", "Id": "7562810", "Score": "4", "CreationDate": "2011-09-27T00:10:17.977", "LastActivityDate": "2011-09-27T00:10:17.977"}, "39648489": {"ParentId": "7562096", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Here is a possible solution mostly based on templates:</p>\n<pre><code>#include&lt;cstddef&gt;\n#include&lt;functional&gt;\n#include&lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nstruct wrapper {\n    using type = T;\n    constexpr wrapper(std::size_t N): N{N} {}\n    const std::size_t N;\n};\n\ntemplate&lt;typename... T&gt;\nstruct identifier: wrapper&lt;T&gt;... {\n    template&lt;std::size_t... I&gt;\n    constexpr identifier(std::index_sequence&lt;I...&gt;): wrapper&lt;T&gt;{I}... {}\n\n    template&lt;typename U&gt;\n    constexpr std::size_t get() const { return wrapper&lt;U&gt;::N; }\n};\n\ntemplate&lt;typename... T&gt;\nconstexpr identifier&lt;T...&gt; ID = identifier&lt;T...&gt;{std::make_index_sequence&lt;sizeof...(T)&gt;{}};\n\n// ---\n\nstruct A {};\nstruct B {};\n\nconstexpr auto id = ID&lt;A, B&gt;;\n\nint main() {\n    switch(id.get&lt;B&gt;()) {\n    case id.get&lt;A&gt;():\n        std::cout &lt;&lt; \"A\" &lt;&lt; std::endl;\n        break;\n    case id.get&lt;B&gt;():\n        std::cout &lt;&lt; \"B\" &lt;&lt; std::endl;\n        break;\n    }\n}\n</code></pre>\n<p>Note that this requires C++14.</p>\n<p>All you have to do to associate sequential ids to a list of types is to provide that list to a template variable as in the example above:</p>\n<pre><code>constexpr auto id = ID&lt;A, B&gt;;\n</code></pre>\n<p>From that point on, you can get the given id for the given type by means of the <code>get</code> method:</p>\n<pre><code>id.get&lt;A&gt;()\n</code></pre>\n<p>And that's all. You can use it in a <code>switch</code> statement as requested and as shown in the example code.</p>\n<p>Note that, as long as types are appended to the list of classes to which associate a numeric id, identifiers are the same after each compilation and during each execution.<br>\nIf you want to remove a type from the list, you can still use <em>fake</em> types as placeholders, as an example:</br></p>\n<pre><code>template&lt;typename&gt; struct noLonger { };\nconstexpr auto id = ID&lt;noLonger&lt;A&gt;, B&gt;;\n</code></pre>\n<p>This will ensure that <code>A</code> has no longer an associated id and the one given to <code>B</code> won't change.<br>\nIf you won't to definitely delete <code>A</code>, you can use something like:</br></p>\n<pre><code>constexpr auto id = ID&lt;noLonger&lt;void&gt;, B&gt;;\n</code></pre>\n<p>Or whatever.</p>\n", "OwnerUserId": "4987285", "LastEditorUserId": "4987285", "LastEditDate": "2016-09-23T06:12:21.393", "Id": "39648489", "Score": "1", "CreationDate": "2016-09-22T20:39:26.900", "LastActivityDate": "2016-09-23T06:12:21.393"}, "39541549": {"ParentId": "7562096", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It is possible to generate a compile time HASH from a string using the code from <a href=\"https://stackoverflow.com/a/9842857/218774\">this answer</a>.</p>\n<p>If you can modify the template to include one extra integer and use a macro to declare the variable:</p>\n<pre><code>template&lt;typename T, int ID&gt; struct A\n{\n    static const int id = ID;\n};\n\n#define DECLARE_A(x) A&lt;x, COMPILE_TIME_CRC32_STR(#x)&gt;\n</code></pre>\n<p>Using this macro for the type declaration, the id member contains a hash of the type name. For example:</p>\n<pre><code>int main() \n{\n    DECLARE_A(int) a;\n    DECLARE_A(double) b;\n    DECLARE_A(float) c;\n    switch(a.id)\n    {\n    case DECLARE_A(int)::id:\n        cout &lt;&lt; \"int\" &lt;&lt; endl;\n        break;\n    case DECLARE_A(double)::id:\n        cout &lt;&lt; \"double\" &lt;&lt; endl;\n        break;\n    case DECLARE_A(float)::id:\n        cout &lt;&lt; \"float\" &lt;&lt; endl;\n        break;\n    };\n    return 0;\n}\n</code></pre>\n<p>As the type name is converted to a string, any modification to the type name text results on a different id. For example:</p>\n<pre><code>static_assert(DECLARE_A(size_t)::id != DECLARE_A(std::size_t)::id, \"\");\n</code></pre>\n<p>Another drawback is due to the possibility for a hash collision to occur.</p>\n", "OwnerUserId": "218774", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:17:34.590", "Id": "39541549", "Score": "3", "CreationDate": "2016-09-16T23:57:15.863", "LastActivityDate": "2016-09-16T23:57:15.863"}, "7562728": {"ParentId": "7562096", "CommentCount": "1", "Body": "<p>This can't be done. An address to a static object is the closest you can get to a unique id, however in order to take addresses of such objects (even static const integrals) they must be defined somewhere. Per the one definition rule, they should be defined within a CPP file, which cannot be done since they are templates. If you define the statics within a header file, then each compilation unit will get its own version of it implemented of course at different addresses.</p>\n", "OwnerUserId": "927034", "PostTypeId": "2", "Id": "7562728", "Score": "1", "CreationDate": "2011-09-26T23:58:44.103", "LastActivityDate": "2011-09-26T23:58:44.103"}, "39640960": {"ParentId": "7562096", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>What I usually use is this:</p>\n<pre><code>template&lt;typename&gt;\nvoid type_id(){}\n\nusing type_id_t = void(*)();\n</code></pre>\n<p>Since every instantiation of the function has it's own address, you can use that address to identify types:</p>\n<pre><code>// Work at compile time\nconstexpr type_id_t int_id = type_id&lt;int&gt;;\n\n// Work at runtime too\nstd::map&lt;type_id_t, std::any&gt; types;\n\ntypes[type_id&lt;int&gt;] = 4;\ntypes[type_id&lt;std::string&gt;] = \"values\"s\n\n// Find values\nauto it = types.find(type_id&lt;int&gt;);\n\nif (it != types.end()) {\n    // Found it!\n}\n</code></pre>\n", "OwnerUserId": "2104697", "LastEditorUserId": "2104697", "LastEditDate": "2016-09-23T21:54:21.993", "Id": "39640960", "Score": "3", "CreationDate": "2016-09-22T13:51:01.450", "LastActivityDate": "2016-09-23T21:54:21.993"}, "bq_ids": {"n4140": {"so_7562096_7562583_0": {"section_id": 7043, "quality": 0.8372093023255814, "length": 36}}, "n3337": {"so_7562096_7562583_0": {"section_id": 6788, "quality": 0.8604651162790697, "length": 37}}, "n4659": {"so_7562096_7562583_0": {"section_id": 8540, "quality": 0.8372093023255814, "length": 36}}}, "7562178": {"ParentId": "7562096", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Use the memory address of a static function.</p>\n<pre><code>template&lt;typename T&gt;\nclass A  {\npublic:\n    static void ID() {}\n}; \n</code></pre>\n<p><code>(&amp;(A&lt;int&gt;::ID))</code> will be different from <code>(&amp;(A&lt;char&gt;::ID))</code> and so on.</p>\n", "OwnerUserId": "964135", "LastEditorUserId": "964135", "LastEditDate": "2011-09-26T23:14:15.683", "Id": "7562178", "Score": "3", "CreationDate": "2011-09-26T22:37:18.667", "LastActivityDate": "2011-09-26T23:14:15.683"}, "39670543": {"ParentId": "7562096", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Ok.....so this is a hack that I found from <a href=\"https://web.archive.org/web/20160304015602/http://b.atch.se/posts/constexpr-counter/#solution\" rel=\"nofollow\">this</a> website.  It should work.  The only thing you need to do is add another template parameter to your <code>struct</code> that takes a counter \"meta-object\".  Note that <code>A</code> with <code>int</code>, <code>bool</code> and <code>char</code> all have unique IDs, but it is not guaranteed that <code>int</code>'s will be <code>1</code> and <code>bool</code> will be <code>2</code>, etc., because the order in which templates are initiated is not necessarily known.  </p>\n<p>Another note:</p>\n<p>This will not work with Microsoft Visual C++</p>\n<pre><code>#include &lt;iostream&gt;\n#include \"meta_counter.hpp\"\n\ntemplate&lt;typename T, typename counter&gt;\nstruct A\n{\n    static const size_t ID = counter::next();\n};\n\nint main () {\n    typedef atch::meta_counter&lt;void&gt; counter;\n    typedef A&lt;int,counter&gt; AInt;\n    typedef A&lt;char,counter&gt; AChar;\n    typedef A&lt;bool,counter&gt; ABool;\n    switch (ABool::ID)\n    {\n        case AInt::ID:\n            std::cout &lt;&lt; \"Int\\n\";\n            break;\n        case ABool::ID:\n            std::cout &lt;&lt; \"Bool\\n\";\n            break;\n        case AChar::ID:\n            std::cout &lt;&lt; \"Char\\n\";\n            break;\n    }\n\n    std::cout &lt;&lt; AInt::ID &lt;&lt; std::endl;\n    std::cout &lt;&lt; AChar::ID &lt;&lt; std::endl;\n    std::cout &lt;&lt; ABool::ID &lt;&lt; std::endl;\n    std::cout &lt;&lt; AInt::ID &lt;&lt; std::endl;\n    while (1) {}\n}\n</code></pre>\n<p>Here is <code>meta_counter.hpp</code>:</p>\n<pre><code>// author: Filip Ros\u00e9en &lt;filip.roseen@gmail.com&gt;\n// source: http://b.atch.se/posts/constexpr-meta-container\n\n#ifndef ATCH_META_COUNTER_HPP\n#define ATCH_META_COUNTER_HPP\n\n#include &lt;cstddef&gt;\n\nnamespace atch { namespace {\n\n  template&lt;class Tag&gt;\n  struct meta_counter {\n    using size_type = std::size_t;\n\n    template&lt;size_type N&gt;\n    struct ident {\n      friend constexpr size_type adl_lookup (ident&lt;N&gt;);\n      static constexpr size_type value = N;\n    };\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n\n    template&lt;class Ident&gt;\n    struct writer {\n      friend constexpr size_type adl_lookup (Ident) {\n        return Ident::value;\n      }\n\n      static constexpr size_type value = Ident::value;\n    };\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n\n    template&lt;size_type N, int = adl_lookup (ident&lt;N&gt; {})&gt;\n    static constexpr size_type value_reader (int, ident&lt;N&gt;) {\n      return N;\n    }\n\n    template&lt;size_type N&gt;\n    static constexpr size_type value_reader (float, ident&lt;N&gt;, size_type R = value_reader (0, ident&lt;N-1&gt; ())) {\n      return R;\n    }\n\n    static constexpr size_type value_reader (float, ident&lt;0&gt;) {\n      return 0;\n    }\n\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n\n    template&lt;size_type Max = 64&gt;\n    static constexpr size_type value (size_type R = value_reader (0, ident&lt;Max&gt; {})) {\n      return R;\n    }\n\n    template&lt;size_type N = 1, class H = meta_counter&gt;\n    static constexpr size_type next (size_type R = writer&lt;ident&lt;N + H::value ()&gt;&gt;::value) {\n      return R;\n    }\n  };\n}}\n\n#endif /* include guard */\n</code></pre>\n", "OwnerUserId": "6149078", "LastEditorUserId": "6149078", "LastEditDate": "2016-09-23T22:52:24.813", "Id": "39670543", "Score": "1", "CreationDate": "2016-09-23T22:42:11.063", "LastActivityDate": "2016-09-23T22:52:24.813"}, "39552543": {"ParentId": "7562096", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I had a similar problem a few months ago. I was looking for a technique to define identifiers that are the same over each execution.<br>\nIf this is a requirement, <a href=\"https://stackoverflow.com/questions/34008110/crtp-and-unique-persistent-identifiers\">here</a> is another question that explores more or less the same issue (of course, it comes along with its nice answer).<br>\nAnyway I didn't use the proposed solution. It follows a description of what I did that time.</br></br></p>\n<hr>\n<p>You can define a <code>constexpr</code> function like the following one:</p>\n<pre><code>static constexpr uint32_t offset = 2166136261u;\nstatic constexpr uint32_t prime = 16777619u;\n\nconstexpr uint32_t fnv(uint32_t partial, const char *str) {\n    return str[0] == 0 ? partial : fnv((partial^str[0])*prime, str+1);\n}\n\ninline uint32_t fnv(const char *str) {\n    return fnv(offset, str);\n}\n</code></pre>\n<p>Then a class like this from which to inherit:</p>\n<pre><code>template&lt;typename T&gt;\nstruct B {\n    static const uint32_t id() {\n        static uint32_t val = fnv(T::identifier);\n        return val;\n    }\n};\n</code></pre>\n<p>CRTP idiom does the rest.<br>\nAs an example, you can define a derived class as it follows:</br></p>\n<pre><code>struct C: B&lt;C&gt; {\n    static const char * identifier;\n};\n\nconst char * C::identifier = \"ID(C)\";\n</code></pre>\n<p>As long as you provide different identifiers for different classes, you will have unique numeric values that can be used to distinguish between the types.</p>\n<p>Identifiers are not required to be part of the derived classes. As an example, you can provide them by means of a trait:</p>\n<pre><code>template&lt;typename&gt; struct trait;\ntemplate&lt;&gt; struct trait { static const char * identifier; };\n\n// so on with all the identifiers\n\ntemplate&lt;typename T&gt;\nstruct B {\n    static const uint32_t id() {\n        static uint32_t val = fnv(trait&lt;T&gt;::identifier);\n        return val;\n    }\n};\n</code></pre>\n<p>Advantages:</p>\n<ul>\n<li>Easy to implement.</li>\n<li>No dependencies.</li>\n<li>Numeric values are the same during each execution.</li>\n<li>Classes can share the same numeric identifier if needed.</li>\n</ul>\n<p>Disadvantages:</p>\n<ul>\n<li>Error-prone: copy-and-paste can quickly become your worst enemy.</li>\n</ul>\n<hr>\n<p>It follows a minimal, working example of what has been described above.<br>\nI adapted the code so as to be able to use the <code>ID</code> member method in a <code>switch</code> statement:</br></p>\n<pre><code>#include&lt;type_traits&gt;\n#include&lt;cstdint&gt;\n#include&lt;cstddef&gt;\n\nstatic constexpr uint32_t offset = 2166136261u;\nstatic constexpr uint32_t prime = 16777619u;\n\ntemplate&lt;std::size_t I, std::size_t N&gt;\nconstexpr\nstd::enable_if_t&lt;(I == N), uint32_t&gt;\nfnv(uint32_t partial, const char (&amp;)[N]) {\n    return partial;\n}\n\ntemplate&lt;std::size_t I, std::size_t N&gt;\nconstexpr\nstd::enable_if_t&lt;(I &lt; N), uint32_t&gt;\nfnv(uint32_t partial, const char (&amp;str)[N]) {\n    return fnv&lt;I+1&gt;((partial^str[I])*prime, str);\n}\n\ntemplate&lt;std::size_t N&gt;\nconstexpr inline uint32_t fnv(const char (&amp;str)[N]) {\n    return fnv&lt;0&gt;(offset, str);\n}\n\ntemplate&lt;typename T&gt;\nstruct A {\n    static constexpr uint32_t ID() {\n        return fnv(T::identifier);\n    }\n};\n\nstruct C: A&lt;C&gt; {\n    static constexpr char identifier[] = \"foo\";\n};\n\nstruct D: A&lt;D&gt; {\n    static constexpr char identifier[] = \"bar\";\n};\n\nint main() {\n    constexpr auto val = C::ID();\n\n    switch(val) {\n    case C::ID():\n        break;\n    case D::ID():\n        break;\n    default:\n        break;\n    }\n}\n</code></pre>\n<p>Please, note that if you want to use <code>ID</code> in a non-constant expression, you must define somewhere the <code>identifier</code>s as it follows:</p>\n<pre><code>constexpr char C::identifier[];\nconstexpr char D::identifier[];\n</code></pre>\n<p>Once you did it, you can do something like this:</p>\n<pre><code>int main() {\n    constexpr auto val = C::ID();\n    // Now, it is well-formed\n    auto ident = C::ID();\n\n    // ...\n}\n</code></pre>\n</hr></hr>", "OwnerUserId": "4987285", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:46:25.623", "Id": "39552543", "Score": "0", "CreationDate": "2016-09-17T23:03:10.400", "LastActivityDate": "2016-09-18T14:42:59.627"}, "7562583": {"ParentId": "7562096", "PostTypeId": "2", "CommentCount": "16", "Body": "<p>This is sufficient assuming a standards conforming compiler (with respect to the one definition rule):</p>\n<pre><code>template&lt;typename T&gt;\nclass A\n{\npublic:\n    static char ID_storage;\n    static const void * const ID;\n};\n\ntemplate&lt;typename T&gt; char A&lt;T&gt;::ID_storage;\ntemplate&lt;typename T&gt; const void * const A&lt;T&gt;::ID= &amp;A&lt;T&gt;::ID_storage;\n</code></pre>\n<p>From the C++ standard 3.2.5 One definition rule [basic.def.odr] (bold emphasis mine):</p>\n<blockquote>\n<p id=\"so_7562096_7562583_0\">... If D is a template and is defined in more than one translation\n  unit, then the last four requirements from the list above shall apply\n  to names from the template\u2019s enclosing scope used in the template\n  definition (14.6.3), and also to dependent names at the point of\n  instantiation (14.6.2). <strong>If the definitions of D satisfy all these\n  requirements, then the program shall behave as if there were a single\n  definition of D.</strong> If the definitions of D do not satisfy these\n  requirements, then the behavior is undefined.</p>\n</blockquote>\n", "OwnerUserId": "6210", "LastEditorUserId": "6210", "LastEditDate": "2011-09-27T03:59:23.720", "Id": "7562583", "Score": "10", "CreationDate": "2011-09-26T23:37:58.497", "LastActivityDate": "2011-09-27T03:59:23.720"}, "39666566": {"ParentId": "7562096", "CommentCount": "0", "Body": "<p>Here is a pragmatic solution, if you are ok with writing a single additional line <code>DECLARE_ID(type)</code> for each <code>type</code> you want to use:</p>\n<pre><code> #include &lt;iostream&gt;\n\n template&lt;class&gt; struct my_id_helper;\n #define DECLARE_ID(C) template&lt;&gt; struct my_id_helper&lt;C&gt; { enum {value = __COUNTER__ }; }\n\n // actually declare ids:\n DECLARE_ID(int);\n DECLARE_ID(double);\n // this would result in a compile error: redefinition of struct my_id_helper&lt;int&gt;\u2019\n // DECLARE_ID(int);\n\n template&lt;class T&gt;\n class A\n {\n public:\n     static const unsigned int ID = my_id_helper&lt;T&gt;::value;\n };\n\n int main()\n {\n     switch(A&lt;int&gt;::ID)\n     {\n     case A&lt;int&gt;::ID:    std::cout &lt;&lt; \"it's an int!\\n\"; break;\n     case A&lt;double&gt;::ID: std::cout &lt;&lt; \"it's a double!\\n\"; break;\n     // case A&lt;float&gt;::ID: // error: incomplete type \u2018my_id_helper&lt;float&gt;\u2019\n     default: std::cout &lt;&lt; \"it's something else\\n\"; break;\n     }\n }\n</code></pre>\n", "OwnerUserId": "6870253", "PostTypeId": "2", "Id": "39666566", "Score": "0", "CreationDate": "2016-09-23T17:38:13.377", "LastActivityDate": "2016-09-23T17:38:13.377"}, "7562689": {"ParentId": "7562096", "CommentCount": "1", "Body": "<p>If non-monotonous values and an <code>intptr_t</code> are acceptable:</p>\n<pre><code>template&lt;typename T&gt;\nstruct TypeID\n{\nprivate:\n    static char id_ref;\npublic:\n    static const intptr_t ID;\n};\n\ntemplate&lt;typename T&gt;\n  char TypeID&lt;T&gt;::id_ref;\ntemplate&lt;typename T&gt;\n  const intptr_t TypeID&lt;T&gt;::ID = (intptr_t)&amp;TypeID&lt;T&gt;::id_ref;\n</code></pre>\n<p>If you must have ints, or must have monotonically incrementing values, I think using static constructors is the only way to go:</p>\n<pre><code>// put this in a namespace\nextern int counter;\n\ntemplate&lt;typename T&gt;\nclass Counter {\nprivate:\n  Counter() {\n    ID_val = counter++;\n  }\n  static Counter init;\n  static int ID_val;\npublic:\n  static const int &amp;ID;\n};\n\ntemplate&lt;typename T&gt;\n  Counter&lt;T&gt; Counter&lt;T&gt;::init;\ntemplate&lt;typename T&gt;\n  int Counter&lt;T&gt;::ID_val;\ntemplate&lt;typename T&gt;\n  const int &amp;Counter&lt;T&gt;::ID = Counter&lt;T&gt;::ID_val;\n\n// in a non-header file somewhere\nint counter;\n</code></pre>\n<p>Note that neither of these techniques is safe if you are sharing them between shared libraries and your application!</p>\n", "OwnerUserId": "36723", "PostTypeId": "2", "Id": "7562689", "Score": "0", "CreationDate": "2011-09-26T23:53:36.193", "LastActivityDate": "2011-09-26T23:53:36.193"}, "39638625": {"ParentId": "7562096", "CommentCount": "0", "Body": "<p>Here is a C++ code that uses <code>__DATE__</code> and <code>__TIME__</code> macro to get unique identifiers for types <code>&lt;T&gt;</code></p>\n<p><strong>Format:</strong></p>\n<pre><code>// __DATE__ \"??? ?? ????\"\n// __TIME__ \"??:??:??\"\n</code></pre>\n<blockquote>\n<p id=\"so_7562096_39638625_0\">This is a poor quality hash function:</p>\n</blockquote>\n<pre><code>#define HASH_A 8416451\n#define HASH_B 11368711\n#define HASH_SEED 9796691    \\\n+ __DATE__[0x0] * 389        \\\n+ __DATE__[0x1] * 82421      \\\n+ __DATE__[0x2] * 1003141    \\\n+ __DATE__[0x4] * 1463339    \\\n+ __DATE__[0x5] * 2883371    \\\n+ __DATE__[0x7] * 4708387    \\\n+ __DATE__[0x8] * 4709213    \\\n+ __DATE__[0x9] * 6500209    \\\n+ __DATE__[0xA] * 6500231    \\\n+ __TIME__[0x0] * 7071997    \\\n+ __TIME__[0x1] * 10221293   \\\n+ __TIME__[0x3] * 10716197   \\\n+ __TIME__[0x4] * 10913537   \\\n+ __TIME__[0x6] * 14346811   \\\n+ __TIME__[0x7] * 15485863\n\nunsigned HASH_STATE = HASH_SEED;\nunsigned HASH() {\n    return HASH_STATE = HASH_STATE * HASH_A % HASH_B;\n}\n</code></pre>\n<p>Using the hash function:</p>\n<pre><code>template &lt;typename T&gt;\nclass A\n{\npublic:\n    static const unsigned int ID;\n};\n\ntemplate &lt;&gt;\nconst unsigned int A&lt;float&gt;::ID = HASH();\n\ntemplate &lt;&gt;\nconst unsigned int A&lt;double&gt;::ID = HASH();\n\ntemplate &lt;&gt;\nconst unsigned int A&lt;int&gt;::ID = HASH();\n\ntemplate &lt;&gt;\nconst unsigned int A&lt;short&gt;::ID = HASH();\n\n#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; A&lt;float&gt;::ID &lt;&lt; std::endl;\n    std::cout &lt;&lt; A&lt;double&gt;::ID &lt;&lt; std::endl;\n    std::cout &lt;&lt; A&lt;int&gt;::ID &lt;&lt; std::endl;\n    std::cout &lt;&lt; A&lt;short&gt;::ID &lt;&lt; std::endl;\n}\n</code></pre>\n", "OwnerUserId": "6557569", "PostTypeId": "2", "Id": "39638625", "Score": "0", "CreationDate": "2016-09-22T12:06:55.973", "LastActivityDate": "2016-09-22T12:06:55.973"}});