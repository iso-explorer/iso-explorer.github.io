post_cb({"7140607": {"CommentCount": "3", "AcceptedAnswerId": "7140784", "PostTypeId": "1", "LastEditorUserId": "46642", "CreationDate": "2011-08-21T19:36:57.697", "LastActivityDate": "2011-08-24T03:51:17.083", "LastEditDate": "2011-08-24T03:51:17.083", "ViewCount": "270", "FavoriteCount": "1", "Title": "C++0x T operator+(const T&, T&&) pattern, still needs move?", "Id": "7140607", "Score": "7", "Body": "<p>Some time ago I was told, that the usual pattern to implement two-ary operators needs a final <code>move</code> in the return.</p>\n<pre><code>Matrix operator+(const Matrix &amp;a, Matrix &amp;&amp;b) {\n    b += a;\n    return std::move(b);\n}\n</code></pre>\n<p>But now there is the special rule that in a <code>return</code> the compiler may treat the return value as a temporary, and then this would not be necessary -- a simple <code>return b</code> would suffice.</p>\n<p>But then again, <code>b</code> has a <em>name</em> in this function, therefore, its an <em>LValue</em> -- which hinders the compiler to m consider it being a temp, and the <code>move</code> is required.</p>\n<p>Is this still the case in the most recent version of the C++0x Standard? <strong>We need the <code>move</code> to implement the above pattern?</strong></p>\n", "Tags": "<operator-overloading><rvalue-reference><c++11>", "OwnerUserId": "472245", "AnswerCount": "2"}, "7142521": {"ParentId": "7140607", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>I'm not sure why this function returns by value. Shouldn't this function return a <code>Matrix&amp;&amp;</code> like the following?</p>\n<pre><code>Matrix&amp;&amp; operator+(const Matrix &amp;a, Matrix &amp;&amp;b) {\n  b += a;\n  return std::move(b);\n}\n</code></pre>\n<p>This has the added advantage that <code>x1 + x2 + x3 + ... + xn</code> creates at most one temporary, which is important if Matrix happens to be stack allocated (as it then gains nothing from moves).</p>\n<p>I think the signatures should be like the following:</p>\n<pre><code>Matrix&amp;&amp; operator+(Matrix &amp;&amp;a,      Matrix &amp;&amp;b     );\nMatrix&amp;&amp; operator+(const Matrix &amp;a, Matrix &amp;&amp;b     );\nMatrix&amp;&amp; operator+(Matrix &amp;&amp;a,      const Matrix &amp;b);\nMatrix   operator+(const Matrix &amp;a, const Matrix &amp;b);\n</code></pre>\n", "OwnerUserId": "525980", "LastEditorUserId": "525980", "LastEditDate": "2011-08-22T03:09:02.933", "Id": "7142521", "Score": "0", "CreationDate": "2011-08-22T02:08:28.563", "LastActivityDate": "2011-08-22T03:09:02.933"}, "7140784": {"ParentId": "7140607", "CommentCount": "2", "Body": "<p>You need the explicit <code>std::move</code> in this example because <code>b</code> is not the name of a non-volatile <strong>automatic</strong> object.  Reference 12.8 [class.copy] /p31/b1:</p>\n<blockquote id=\"so_7140607_7140784_0\">\n<ul>\n<li>in a return statement in a function with a class return type, when\n  the expression is the name of a non-volatile <strong>automatic</strong> object (other\n  than a function or catch-clause parameter) with the same cv-\n  unqualified type as the function return type, the copy/move operation\n  can be omitted by constructing the automatic object directly into the\n  function\u2019s return value</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "576911", "PostTypeId": "2", "Id": "7140784", "Score": "7", "CreationDate": "2011-08-21T20:04:51.110", "LastActivityDate": "2011-08-21T20:04:51.110"}, "bq_ids": {"n4140": {"so_7140607_7140784_0": {"section_id": 480, "quality": 0.9714285714285714, "length": 34}}, "n3337": {"so_7140607_7140784_0": {"section_id": 471, "quality": 0.9714285714285714, "length": 34}}, "n4659": {"so_7140607_7140784_0": {"section_id": 502, "quality": 0.8857142857142857, "length": 31}}}});