post_cb({"bq_ids": {"n4140": {"so_27615993_27616404_1": {"length": 20, "quality": 0.5263157894736842, "section_id": 5879}, "so_27615993_27616192_1": {"length": 20, "quality": 0.5263157894736842, "section_id": 5879}}, "n3337": {"so_27615993_27616404_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 5650}, "so_27615993_27616192_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 5650}}, "n4659": {"so_27615993_27616404_1": {"length": 20, "quality": 0.5263157894736842, "section_id": 7363}, "so_27615993_27616192_1": {"length": 20, "quality": 0.5263157894736842, "section_id": 7363}}}, "27616407": {"Id": "27616407", "PostTypeId": "2", "Body": "<p>It may work, or may not, or any kind of weird things may happen, as <strong>this invokes undefined behavior</strong>. You may want to have a look at <a href=\"https://stackoverflow.com/a/5398498/2144471\">https://stackoverflow.com/a/5398498/2144471</a> also, for info related to struct padding.</p>\n<p>However, what you might do in that way is to refactor your code in order to leverage the following language feature (<a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/reinterpret_cast</a>)</p>\n<blockquote>\n<p id=\"so_27615993_27616407_0\">the resulting pointer or reference may only be accessed if one of the following is true:<br>\n  ...<br>\n  T2 is an aggregate type or a union type which holds one of the aforementioned types as an element or non-static member (including, recursively, elements of subaggregates and non-static data members of the contained unions): <strong>this makes it safe to cast from the first member of a struct and from an element of a union to the struct/union that contains it</strong>.</br></br></p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-12-23T08:09:40.373", "Score": "1", "CreationDate": "2014-12-23T08:09:40.373", "ParentId": "27615993", "CommentCount": "0", "LastEditDate": "2017-05-23T11:54:03.353", "OwnerUserId": "2144471"}, "27616192": {"Id": "27616192", "PostTypeId": "2", "Body": "<p>The C Standard does not guarantee this. In fact, it explicitly says (in <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow\">6.7.2.1</a>):</p>\n<blockquote>\n<p id=\"so_27615993_27616192_0\">There may be unnamed padding at the end of a structure or union</p>\n</blockquote>\n<p>However, in practice, you can use implementation-specific features to force zero padding for the struct.  If you do so, I recommend utilizing a static assertion technique to ensure <code>sizeof(Edge) == sizeof(double)*4</code> when the code is being compiled.</p>\n<h3>Update (re C++):</h3>\n<p>A series of comments asked if I can verify this for C++. In the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow\">draft copy of C++11</a>, page 220, it says the following (emphasis mine):</p>\n<blockquote id=\"so_27615993_27616192_1\">\n<ol start=\"21\">\n<li>A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [ Note: <strong>There might therefore be unnamed padding within a standard-layout struct object</strong>, but not at its beginning, as necessary to achieve appropriate alignment. \u2014 end note ]</li>\n</ol>\n</blockquote>\n", "LastEditorUserId": "33708", "LastActivityDate": "2014-12-23T08:04:52.743", "Score": "4", "CreationDate": "2014-12-23T07:52:44.123", "ParentId": "27615993", "CommentCount": "5", "LastEditDate": "2014-12-23T08:04:52.743", "OwnerUserId": "33708"}, "27616404": {"Id": "27616404", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_27615993_27616404_0\">Is it guaranteed by the standard?</p>\n</blockquote>\n<p>Formally, no; in practice, yes. The closest to a guarantee is C++11 9.2/20:</p>\n<blockquote>\n<p id=\"so_27615993_27616404_1\">A pointer to a standard-layout struct object, suitably converted using a <code>reinterpret_cast</code>, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [ Note: There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning, as necessary to achieve appropriate alignment. \u2014 end note ]</p>\n</blockquote>\n<p>So the cast will correctly reinterpret the first array elements as a single structure; but I don't think there's a formal guarantee that it won't expect extra padding between structures.</p>\n<blockquote>\n<p id=\"so_27615993_27616404_2\">If not, is it true in practice for Intel, AMD, and ARM?</p>\n</blockquote>\n<p>At least on mainstream architectures like the ones you list, there's no need to add padding for alignment in this case, and no other reason to do so; so in practice, this should work, but without guaranteed portability.</p>\n<blockquote>\n<p id=\"so_27615993_27616404_3\">I found there is an <code>__attribute__((__packed__))</code> for GCC, would that guarantee it for GCC at least?</p>\n</blockquote>\n<p>Yes. According to the <a href=\"https://gcc.gnu.org/onlinedocs/gcc-3.1/gcc/Type-Attributes.html\" rel=\"nofollow\">documentation</a>, this \"specifie[s] that the minimum required memory be used to represent the type\", so it will prevent any padding being added after the array member.</p>\n<blockquote>\n<p id=\"so_27615993_27616404_4\">Does MSVC have a similar option?</p>\n</blockquote>\n<p>It has a <a href=\"http://msdn.microsoft.com/en-us/library/xh3e3fd0.aspx\" rel=\"nofollow\">compiler flag</a> <code>/Zp1</code> and a <a href=\"http://msdn.microsoft.com/en-us/library/2e70t5y1.aspx\" rel=\"nofollow\">pragma</a> <code>#pragma pack(push, 1)</code> (with <code>#pragma pack(pop)</code> to restore default alignment), but they don't seem to offer the guarantee you need; they control the alignment of \"each structure member after the first is stored\", with no mention of the overall structure size.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2014-12-23T08:31:40.623", "Score": "4", "CreationDate": "2014-12-23T08:09:17.457", "ParentId": "27615993", "CommentCount": "0", "LastEditDate": "2014-12-23T08:31:40.623", "OwnerUserId": "204847"}, "27615993": {"ViewCount": "1154", "Body": "<p>If I have an array, or a pointer to an array, is it safe to reinterpret_cast it to a struct containing the array, with regards to alignment?</p>\n<pre><code>double *edges = ...; // Each edge is defined by 4 doubles in the array.\nstruct Edge { double vals[4]; };\nEdge *asStruct = reinterpret_cast&lt;Edge*&gt;(edges);\nstd::sort(asStruct, asStruct + edgesCount, EdgeLengthComparator());\n</code></pre>\n<p>In particular, will <code>sizeof(Edge) == sizeof(double)*4</code> always be true? Is it guaranteed by the standard? If not, is it true in practice for Intel, AMD, and ARM? Do you know of architectures where it won't be true? I've already tested it on x86, and it works fine there.</p>\n<p><strong>Why I need it:</strong> In case you are wondering why I would need such a thing, I'm considering it as a possible solution to <a href=\"https://stackoverflow.com/questions/1649529/sorting-by-blocks-of-elements-with-stdsort\">Sorting by blocks of elements with std::sort()</a></p>\n<p><strong>Edit:</strong> I found there is an <code>__attribute__((__packed__))</code> for GCC, would that guarantee it for GCC at least? Does MSVC have a similar option?</p>\n", "AcceptedAnswerId": "27616404", "Title": "Is it safe to reinterpret_cast an array to a struct containing the array?", "CreationDate": "2014-12-23T07:36:53.917", "Id": "27615993", "CommentCount": "14", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-12-23T08:16:07.250", "LastEditorUserId": "492336", "LastActivityDate": "2014-12-23T08:31:40.623", "Score": "9", "OwnerUserId": "492336", "Tags": "<c++><struct><alignment>", "AnswerCount": "3"}});