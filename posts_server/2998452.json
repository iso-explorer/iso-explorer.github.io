post_cb({"bq_ids": {"n4140": {"so_2998452_2998452_0": {"length": 5, "quality": 1.0, "section_id": 724}}, "n3337": {"so_2998452_2998452_0": {"length": 5, "quality": 1.0, "section_id": 713}}, "n4659": {"so_2998452_2998452_0": {"length": 5, "quality": 1.0, "section_id": 825}}}, "2998452": {"ViewCount": "2010", "Body": "<p>The following minimal example:</p>\n<pre><code>#include &lt;iostream&gt;\n\n#include &lt;boost/unordered_map.hpp&gt;\n\nint main()\n{\n        boost::unordered_map&lt;int, int&gt; m;\n        boost::unordered_map&lt;int, int&gt;::const_iterator i;\n\n        m.insert(std::make_pair(1, 2));\n\n        i = m.end();\n        --i;\n\n        std::cout &lt;&lt; i-&gt;first &lt;&lt; \" -&gt; \" &lt;&lt; i-&gt;second &lt;&lt; std::endl;\n\n        return 0;\n}\n</code></pre>\n<p>...fails to compile.</p>\n<pre><code>bidi.cxx: In function \u2018int main()\u2019:\nbidi.cxx:13: error: no match for \u2018operator--\u2019 in \u2018--i\u2019\n</code></pre>\n<p>According to <a href=\"http://www.boost.org/doc/libs/1_43_0/doc/html/unordered/comparison.html\" rel=\"noreferrer\">Boost's own documentation</a>:</p>\n<blockquote>\n<p id=\"so_2998452_2998452_0\"><code>iterator</code>, <code>const_iterator</code> are of at least the forward category.</p>\n</blockquote>\n<p>It would appear that that's all they are. Why? What technical restriction does a hash-map impose that prevents iterators from being bidirectional?</p>\n<p>(gcc version 4.1.2, Boost versions 1.40.0 and 1.43.0.)</p>\n", "AcceptedAnswerId": "2998664", "Title": "Bidirectional iterators in unordered_map?", "CreationDate": "2010-06-08T14:50:57.170", "Id": "2998452", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2010-06-08T15:15:30.790", "Score": "6", "OwnerUserId": "101999", "Tags": "<c++>", "AnswerCount": "1"}, "2998664": {"Id": "2998664", "PostTypeId": "2", "Body": "<p>There is no technical reason why an <code>unordered_map</code> can't have bidirectional iterators.  The main reason is that it would add additional cost to the implementation, and the designers thought nobody would really need bidirectional iterators in a hash map.  After all, there's no order in a hash, and so the order the iterator gives you is entirely arbitrary.  What would traversing a fixed but arbitrary order backwards give you?</p>\n<p>Normally, one would access an <code>unordered_map</code> on an element-by-element basis, or traverse the whole map.  I've never done otherwise in Perl, myself.  To do this, a forward iterator is necessary, and therefore there is one in there, and Boost guarantees it.  To have bidirectional iterators, it would likely be necessary to include an additional pointer in each entry, which increases memory use and processing time.</p>\n<p>I'm not coming up with a good, plausible, use case for bidirectional iterators here.  If you can, you can ask the Boost maintainers to consider it, although you're almost certainly too late for C++0x.</p>\n", "LastActivityDate": "2010-06-08T15:15:30.790", "Score": "10", "CreationDate": "2010-06-08T15:15:30.790", "ParentId": "2998452", "CommentCount": "1", "OwnerUserId": "14148"}});