post_cb({"3906468": {"ParentId": "3906384", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_3906384_3906468_0\">How it can be erroneous behavior at runtime if destination type is an Abstract class and if the parameter's class has derived class ?</p>\n</blockquote>\n<p>It won't even compile. \"Pass by value\" means that you would try to copy the abstract class parts of the argument to a new object. But you cannot create an object with an abstract class as its mosted derived class because it's abstract.</p>\n", "OwnerUserId": "172531", "LastEditorUserId": "172531", "LastEditDate": "2010-10-11T13:12:07.493", "Id": "3906468", "Score": "5", "CreationDate": "2010-10-11T13:06:55.073", "LastActivityDate": "2010-10-11T13:12:07.493"}, "3906514": {"ParentId": "3906384", "CommentCount": "0", "Body": "<p>It won't even compile.. </p>\n<p>From Standard docs <em>10.4.3</em>,</p>\n<blockquote>\n<p id=\"so_3906384_3906514_0\">An abstract class <strong>shall not be used</strong> as a parameter type, as a function return type, or as the type of an explicit conversion.\n  Pointers and references to an abstract class can be declared.</p>\n</blockquote>\n", "OwnerUserId": "249490", "PostTypeId": "2", "Id": "3906514", "Score": "3", "CreationDate": "2010-10-11T13:13:53.230", "LastActivityDate": "2010-10-11T13:13:53.230"}, "3906384": {"CommentCount": "4", "AcceptedAnswerId": "3906468", "PostTypeId": "1", "LastEditorUserId": "426051", "CreationDate": "2010-10-11T12:57:44.510", "LastActivityDate": "2014-07-02T21:30:54.440", "LastEditDate": "2010-10-11T13:17:16.967", "ViewCount": "1209", "FavoriteCount": "0", "Title": "Why its dangerous to use pass by value when function parameter expects an Abstract class object?", "Id": "3906384", "Score": "2", "Body": "<p>I read below statements in Addison Wesley FAQs.</p>\n<blockquote>\n<p id=\"so_3906384_3906384_0\">Beware: passing objects by value can\n  be dangerous in some situations. Often\n  it is  better to pass objects by\n  reference-to-const than to pass them\n  by value. For example,  pass-by-value\n  won't work if the destination type is\n  an abstract base class and can  result\n  in erroneous behavior at runtime if\n  the parameter's class has derived\n  classes.  However if the class of the\n  parameter is guaranteed not to have\n  derived classes, and if  the function\n  being called needs a local copy to\n  work with, pass-by-value can be\n  useful.</p>\n</blockquote>\n<p>How it can be erroneous behavior at runtime if destination type is an Abstract class and if the parameter's class has derived class ?\nDoes copy constructor solve this problem ? If so, how ? Thank you.</p>\n<p>EDIT: So, should the statement above be <strong>\"erroneous behavior at compile time\"</strong> ? Not \"runtime\" .</p>\n", "Tags": "<c++>", "OwnerUserId": "426051", "AnswerCount": "5"}, "3906424": {"ParentId": "3906384", "CommentCount": "1", "Body": "<p>I doubt passing derived class instances by value to be possible at all. After all the size of the passed value must be known at compile time. However the size of the abstract base class and the derived class can (and most likely will) differ. The resulting behavior is pretty much undefined.</p>\n", "OwnerUserId": "1626632", "PostTypeId": "2", "Id": "3906424", "Score": "0", "CreationDate": "2010-10-11T13:02:12.707", "LastActivityDate": "2010-10-11T13:02:12.707"}, "3906477": {"ParentId": "3906384", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>OK, suppose we have the following hierarchy</p>\n<pre><code>#include &lt;iostream&gt;\nclass Base\n{\npublic:\n   Base(): BaseNum(42)\n   {}\n   virtual void f()\n   {\n      std::cout &lt;&lt; BaseNum;\n   }\n   virtual ~Base() \n   {\n   }\nprotected:\n   int BaseNum;\n};\n\nclass Derived: public Base\n{\npublic:\n   Derived(): DerivedNum(14)\n   {}\n   virtual void f()\n   {\n      std::cout &lt;&lt; DerivedNum + BaseNum;\n   }\nprivate:\n   int DerivedNum;\n};\n</code></pre>\n<p>If you have a function taking Base by value and you pass Derived instead, the derived object is first converted to base(by truncating any specific fo Derived information, like DerivedNum) and then copied into the parameter. Thus, in the function you will LOSE any information that was specific to derived. This is known as slicing. Inside the function, if you called the virtual f() function, the Base::f would be called no matter Derived was passed. \nIf you passed by reference or pointer, no copying would be done. And converting from Derived&amp; to Base&amp; preserves the dynamic type information because no actual copying and therefore slicing is done. Sure, you couldn't use the Base&amp; as Derived&amp;, but if you called the f, Derived::f would be called.\nIf Base were abstract, then it would be a compiler error, because when you pass by value, the parameter must be instantiated via a copy constructor, and, as we know, an abstract class cannot be instantiated.\nHTH.</p>\n", "OwnerUserId": "469935", "LastEditorUserId": "759866", "LastEditDate": "2014-07-02T21:30:54.440", "Id": "3906477", "Score": "1", "CreationDate": "2010-10-11T13:07:51.093", "LastActivityDate": "2014-07-02T21:30:54.440"}, "3906528": {"ParentId": "3906384", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>There are two things here, and you seem to be mixing them up:</p>\n<p>1) If the destination type is an abstract class and you pass by value, there will be no runtime error: it won't compile, period.</p>\n<p>2) When there will be a runtime error is if the destination type is concrete but has derived classes. Consider this example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {\n    virtual void f() { std::cout &lt;&lt; \"A\\n\"; }\n};\nstruct B : public A {\n    virtual void f() { std::cout &lt;&lt; \"B\\n\"; }\n};\n\nvoid func(A a){\n    a.f();\n}\n\nint main() {\n    func( B() );\n}\n</code></pre>\n<p>It compiles fine, but outputs <code>A</code>. If you change the parameter to <code>A&amp;</code>, polymorphism works as expected and <code>B</code> is printed. This problem is known as slicing, and there's a <a href=\"https://stackoverflow.com/questions/274626/what-is-the-slicing-problem-in-c\">nice question</a> here on SO about it.</p>\n<p>As a general rule of thumb, if the class has any virtual functions you should a) declare the destructor as virtual and b) avoid passing it by value.</p>\n<p>I actually avoid passing any parameter by value, unless I'm sure it's a primitive type such as an <code>int</code>. If you're writing a template, you're better off accepting all parameters as <code>const T&amp;</code>.</p>\n", "OwnerUserId": "106281", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:47:39.313", "Id": "3906528", "Score": "6", "CreationDate": "2010-10-11T13:16:00.043", "LastActivityDate": "2010-10-11T14:18:59.643"}, "bq_ids": {"n4140": {"so_3906384_3906514_0": {"section_id": 7020, "quality": 1.0, "length": 16}}, "n3337": {"so_3906384_3906514_0": {"section_id": 6766, "quality": 1.0, "length": 16}}, "n4659": {"so_3906384_3906514_0": {"section_id": 8517, "quality": 1.0, "length": 16}}}});