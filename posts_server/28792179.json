post_cb({"28792179": {"CommentCount": "0", "AcceptedAnswerId": "28792389", "CreationDate": "2015-03-01T09:55:05.773", "LastActivityDate": "2015-03-01T10:16:45.650", "PostTypeId": "1", "ViewCount": "225", "FavoriteCount": "1", "Title": "Why I can not simply use types defined in base class if both classes are templates?", "Id": "28792179", "Score": "3", "Body": "<p>Why I can not simply use types defined in base class if both classes are templates? Is there some rule about searching of template members? Here is the simplest example I could deduce:</p>\n<pre><code>struct iA {\n    using type = int;\n};\ntemplate &lt;class T&gt; struct tA {\n    using type = T;\n};\n\nstruct iB1 : iA {\n    void f(type i) {}\n};\nstruct iB2 : tA&lt;int&gt; {\n    void f(type i) {}\n};\ntemplate &lt;class T&gt; struct tB1 : iA {\n    void f(type i) {}\n};\ntemplate &lt;class T&gt; struct tB2 : tA&lt;int&gt; {\n    void f(type i) {}\n};\ntemplate &lt;class T&gt; struct tB3 : tA&lt;T&gt; {\n    // void f(type i) {} // error: 'type' has not been declared\n    void f(typename tA&lt;T&gt;::type i) {}\n};\n\nint main() {}\n</code></pre>\n<p>Of course, I can just add <code>typename tA&lt;T&gt;::</code>, but is there a more elegant solution?</p>\n", "Tags": "<c++><templates><inheritance>", "OwnerUserId": "4146202", "AnswerCount": "1"}, "28792389": {"ParentId": "28792179", "CommentCount": "0", "Body": "<p>The problem is that the base class is dependent, and thus its scope is only examined when we are looking up dependent names. [temp.dep]/3:</p>\n<blockquote>\n<p id=\"so_28792179_28792389_0\">In the definition of a class or class template, if a base class\n  depends on a <em>template-parameter</em>, <strong>the base class scope is not examined\n  during unqualified name lookup</strong> either at the point of definition of\n  the class template or member or during an instantiation of the class\n  template or member.</p>\n</blockquote>\n<p>The reason for this rule is that there might be e.g. specializations of the base class template. Since we don't know the specific template arguments at definition time, we cannot inspect the base classes scope.</p>\n<p><code>type</code> isn't dependent and thus will not be looked up in the dependent base <code>tA&lt;T&gt;</code>. However, because it isn't dependent, a declaration for it must be available at definition time, [temp.res]/10:</p>\n<blockquote>\n<p id=\"so_28792179_28792389_1\"><strong>If a name does not depend on a template-parameter (as defined in\n  14.6.2), a declaration (or set of declarations) for that name shall be in scope at the point where the name appears in the template\n  definition</strong>; the name is bound to the declaration (or declarations)\n  found at that point and this binding is not affected by declarations\n  that are visible at the point of instantiation.</p>\n</blockquote>\n<hr>\n<p>If you need to use <code>type</code> frequently in the derived class, <code>using</code> declarations can help.</p>\n<pre><code>template &lt;class T&gt; struct tB3 : tA&lt;T&gt; {\n    using typename tA&lt;T&gt;::type;\n    void f(type i) {}\n};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/cd1c9c56f0e86085\" rel=\"nofollow\"><strong>Demo</strong></a>.</p>\n</hr>", "OwnerUserId": "3647361", "PostTypeId": "2", "Id": "28792389", "Score": "2", "CreationDate": "2015-03-01T10:16:45.650", "LastActivityDate": "2015-03-01T10:16:45.650"}, "bq_ids": {"n4140": {"so_28792179_28792389_1": {"section_id": 177, "quality": 0.9655172413793104, "length": 28}, "so_28792179_28792389_0": {"section_id": 190, "quality": 1.0, "length": 27}}, "n3337": {"so_28792179_28792389_1": {"section_id": 171, "quality": 0.9655172413793104, "length": 28}, "so_28792179_28792389_0": {"section_id": 184, "quality": 1.0, "length": 27}}, "n4659": {"so_28792179_28792389_1": {"section_id": 182, "quality": 0.9655172413793104, "length": 28}, "so_28792179_28792389_0": {"section_id": 195, "quality": 0.8148148148148148, "length": 22}}}});