post_cb({"bq_ids": {"n4140": {"so_17384193_17384226_3": {"length": 6, "quality": 0.6, "section_id": 0}}, "n3337": {"so_17384193_17384226_0": {"length": 8, "quality": 1.0, "section_id": 5732}, "so_17384193_17384226_3": {"length": 10, "quality": 1.0, "section_id": 5732}}, "n4659": {"so_17384193_17384226_3": {"length": 7, "quality": 0.7, "section_id": 7667}}}, "17384193": {"ViewCount": "686", "Body": "<p>In the following:</p>\n<pre><code>auto x = {0}; // auto deduction of std::initializer_list&lt;int&gt;\nauto y = []() -&gt; std::initializer_list&lt;int&gt; { return {0}; }(); //explicit\nauto z = []() { return {0}; }(); // won't compile\n</code></pre>\n<p>why it's not possible to return and auto deduce the type of std::initializer_list?</p>\n", "AcceptedAnswerId": "17384226", "Title": "return and auto deduce std::initializer_list", "CreationDate": "2013-06-29T20:02:50.327", "Id": "17384193", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-06-29T20:13:26.930", "Score": "8", "OwnerUserId": "1003615", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "17384226": {"Id": "17384226", "PostTypeId": "2", "Body": "<p>Well, because the Standard says so, and because a <em>braced-init-list</em> is not an expression. Per paragraph 5.1.2/4 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_17384193_17384226_0\">[...] If\n  a <em>lambda-expression</em> does not include a <em>trailing-return-type</em>, it is as if the <em>trailing-return-type</em> denotes the\n  following type:</p>\n<p id=\"so_17384193_17384226_1\">\u2014 if the <em>compound-statement</em> is of the form</p>\n<p id=\"so_17384193_17384226_2\"><code>{</code> <em>attribute-specifier-seq(opt)</em> <code>return</code> <em>expression</em> <code>; }</code></p>\n<p id=\"so_17384193_17384226_3\"><strong>the type of the returned expression</strong> after lvalue-to-rvalue conversion (4.1), array-to-pointer conversion\n  (4.2), and function-to-pointer conversion (4.3);</p>\n<p id=\"so_17384193_17384226_4\">\u2014 otherwise, <code>void</code>.</p>\n</blockquote>\n<p>The above makes it clear that the return type will be deduced to be anything else then <code>void</code> if and only if the <code>return</code> statement is followed by an <em>expression</em>, and a <em>braced-init-list</em> is not in itself an expression - it does not have a type, and it does not yield a value. It is just a language construct that can be used in the context of initialization.</p>\n<p>The above paragraph also provides an example:</p>\n<blockquote>\n<p id=\"so_17384193_17384226_5\">[ <em>Example</em>:</p>\n<pre><code>auto x1 = [](int i){ return i; }; // OK: return type is int\nauto x2 = []{ return { 1, 2 }; }; // error: the return type is void (a\n                                  // braced-init-list is not an expression)\n</code></pre>\n<p id=\"so_17384193_17384226_6\">\u2014<em>end example</em> ]</p>\n</blockquote>\n<p>Finally, if the question is:</p>\n<p>\"<em>Why a special rule was introduced for deducing the type of an <code>auto</code> variable initialized from a braced-init-list, while a similar rule was <strong>not</strong> introduced for deducing the return type of a lambda when <code>return</code> is followed by a braced-init-list?</em>\"</p>\n<p>Then the question is not constructive. Also notice, that type deduction for templates does not work with <em>braced-init-lists</em> either:</p>\n<pre><code>template&lt;typename T&gt;\nvoid foo(T);\n\nfoo({1, 2}); // ERROR! T is NOT deduced to be std::initializer_list&lt;int&gt;\n</code></pre>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-06-29T20:13:26.930", "Score": "7", "CreationDate": "2013-06-29T20:06:57.650", "ParentId": "17384193", "CommentCount": "4", "LastEditDate": "2013-06-29T20:13:26.930", "OwnerUserId": "1932150"}});