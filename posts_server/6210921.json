post_cb({"6210992": {"ParentId": "6210921", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>@Sharptooth's Answer makes more sense if we consider this section from the standard:</p>\n<p><strong><em>3.7.3.1 Allocation functions [basic.stc.dynamic.allocation]</em></strong></p>\n<blockquote>\n<p id=\"so_6210921_6210992_0\">[..] An allocation function shall be a class member function or a global function; a program is ill-formed if an allocation function is declared in a namespace scope other than global scope or declared static in global scope. [..]</p>\n</blockquote>\n<p>The above limitation is probably imposed for the very reason that @sharptooth's answer points out.</p>\n", "OwnerUserId": "452307", "LastEditorUserId": "4342498", "LastEditDate": "2016-10-10T15:10:40.320", "Id": "6210992", "Score": "6", "CreationDate": "2011-06-02T05:57:58.043", "LastActivityDate": "2016-10-10T15:10:40.320"}, "6210957": {"ParentId": "6210921", "CommentCount": "3", "Body": "<p>This is not allowed because it makes no sense. For example you have the following</p>\n<pre><code>int* ptr = 0;\n\nnamespace X {\n    void* operator new (size_t);\n    void operator delete(void*);\n    void f()\n    {\n       ptr = new int();\n    }\n}\n\nvoid f()\n{\n    delete ptr;\n    ptr = 0;\n}\n</code></pre>\n<p>now how should the <code>ptr</code> be <code>delete</code>d - with global namespace <code>operator delete()</code> or with the one specific to <code>namespace X</code>? There's no possible way for C++ to deduce that.</p>\n", "OwnerUserId": "57428", "PostTypeId": "2", "Id": "6210957", "Score": "7", "CreationDate": "2011-06-02T05:52:37.290", "LastActivityDate": "2011-06-02T05:52:37.290"}, "bq_ids": {"n4140": {"so_6210921_6210992_0": {"section_id": 7176, "quality": 1.0, "length": 21}}, "n3337": {"so_6210921_6210992_0": {"section_id": 6920, "quality": 1.0, "length": 21}}, "n4659": {"so_6210921_6210992_0": {"section_id": 8684, "quality": 1.0, "length": 21}}}, "6210921": {"CommentCount": "2", "AcceptedAnswerId": "6210992", "PostTypeId": "1", "LastEditorUserId": "514235", "CreationDate": "2011-06-02T05:48:10.240", "LastActivityDate": "2016-10-10T15:10:40.320", "LastEditDate": "2011-06-02T05:56:22.767", "ViewCount": "3675", "FavoriteCount": "1", "Title": "operator new inside namespace", "Id": "6210921", "Score": "7", "Body": "<pre><code>namespace X\n{\n  void* operator new (size_t);\n}\n</code></pre>\n<p>gives error message as:</p>\n<pre><code>error: \u2018void* X::operator new(size_t)\u2019 may not be declared within a namespace\n</code></pre>\n<p>Is it a <a href=\"http://gcc.gnu.org/ml/gcc-bugs/2008-02/msg00712.html\" rel=\"noreferrer\">gcc compiler bug</a> ? In older gcc version it seems to be working.\nAny idea, why it's not allowed ?</p>\n<p><strong>Use case</strong>:\nI wanted to allow only custom <code>operator new/delete</code> for the classes and wanted to disallow global <code>new/operator</code>. Instead of linker error, it was easy to catch compiler error; so I coded:</p>\n<pre><code>namespace X {\n  void* operator new (size_t);\n}\nusing namespace X;\n</code></pre>\n<p>This worked for older version of gcc but not for the new one.</p>\n", "Tags": "<c++><namespaces><new-operator><compiler-bug>", "OwnerUserId": "514235", "AnswerCount": "2"}});