post_cb({"bq_ids": {"n4140": {"so_4097762_4097876_3": {"length": 6, "quality": 0.5454545454545454, "section_id": 3321}}, "n3337": {"so_4097762_4097876_0": {"length": 8, "quality": 1.0, "section_id": 5732}, "so_4097762_4097876_3": {"length": 9, "quality": 0.8181818181818182, "section_id": 5732}}, "n4659": {"so_4097762_4097876_3": {"length": 7, "quality": 0.6363636363636364, "section_id": 7667}}}, "4097876": {"Id": "4097876", "PostTypeId": "2", "Body": "<p>\"Is it only when you have a simple one-liner?\"</p>\n<p>Yes. According to the latest public C++0x draft (\u00a75.1.2/4), </p>\n<blockquote>\n<p id=\"so_4097762_4097876_0\">If a <em>lambda-expression</em> does not include a <em>trailing-return-type</em>, it is as if the <em>trailing-return-type</em> denotes the following type:</p>\n<ul>\n<li><p id=\"so_4097762_4097876_1\">if the <em>compound-statement</em> is of the form </p>\n<p id=\"so_4097762_4097876_2\"><code>{ return</code> <em>attribute-specifier<sub>opt</sub></em> <em>expression</em> <code>; }</code></p>\n<p id=\"so_4097762_4097876_3\">the type of the returned expression after lvalue-to-rvalue conversion (4.1), array-to-pointer conver- sion (4.2), and function-to-pointer conversion (4.3);</p></li>\n<li><p id=\"so_4097762_4097876_4\"><strong>otherwise, <code>void</code>.</strong></p></li>\n</ul>\n<p id=\"so_4097762_4097876_5\">[ <em>Example:</em></p>\n<pre><code> auto x1 = [](int i){ return i; }; // OK: return type is int\n auto x2 = []{ return { 1, 2 }; }; // error: the return type is void (a\n                                   // braced-init-list is not an expression)\n</code></pre>\n<p id=\"so_4097762_4097876_6\">\u2014 <em>end example</em> ]</p>\n</blockquote>\n<p>Therefore, your first lambda expression is interpreted as returning <code>void</code>, which is not right, so you need to add a <code>-&gt; bool</code> to explicitly specify the return type.</p>\n", "LastActivityDate": "2010-11-04T14:50:34.883", "Score": "5", "CreationDate": "2010-11-04T14:50:34.883", "ParentId": "4097762", "CommentCount": "0", "OwnerUserId": "224671"}, "4097762": {"ViewCount": "966", "Body": "<p>Consider the two lambda functions in the following VC++ 10.0 code:</p>\n<pre><code>template &lt;typename T&gt;\nvoid eq(uint fieldno, T value) {\n    table* index_table = db.get_index_table(fieldno);\n    if (index_table == nullptr) return;\n    std::set&lt;uint&gt; recs;\n    index_table-&gt;scan_index&lt;T&gt;(value, [&amp;](uint recno, T n)-&gt;bool {\n        if (n != value) return false;\n        recs.insert(recno);\n        return true;\n    });\n    add_scalar_hits(fieldno, recs).is_hit =\n        [=](tools::wsdb::field_instance_t&amp; inst) {\n            return boost::get&lt;T&gt;(inst) == value;\n        };\n}\n</code></pre>\n<p>In the first lambda function, I was forced to use the <code>-&gt;bool</code> return type specification whereas in the second lambda the compiler was perfectly happy to infer the return type.</p>\n<p>My question is: when can the compiler infer the return type on a lambda? Is it only when you have a simple one-liner?</p>\n", "AcceptedAnswerId": "4097876", "Title": "C++0x lambda return value type-inferencing rules", "CreationDate": "2010-11-04T14:39:29.580", "Id": "4097762", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2010-11-04T22:42:20.807", "LastEditorUserId": "4086", "LastActivityDate": "2010-11-04T22:42:20.807", "Score": "2", "OwnerUserId": "4086", "Tags": "<lambda><c++11><type-inference>", "AnswerCount": "1"}});