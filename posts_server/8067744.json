post_cb({"8067907": {"LastActivityDate": "2011-11-09T21:11:11.807", "CreationDate": "2011-11-09T16:12:08.497", "CommentCount": "4", "Body": "<p>Since you're using c++, you can put a destructor in the struct to do that automatically for you. There are other ways, but this is the most practical:</p>\n<pre><code>struct gnt\n{\n    unsigned int* num;\n    unsigned int size;\n    bool negative;\n    ~gnt() {delete [] num; }\n};\n</code></pre>\n<p>I'd also suggest to have a constructor to make sure that num has null until it's initialized, so the destructor will work safely before that:</p>\n<pre><code>struct gnt\n{\n    unsigned int* num;\n    unsigned int size;\n    bool negative;\n    gnt() : num(NULL) {}\n    ~gnt() {delete [] num; }\n};\n</code></pre>\n<p>To have a safe behavior when instances are assigned or initialized when created, you need the copy constructor and assignment operator. They should copy the values of all the non-dynamic members, and create a duplicate of num with the same size and contents. In such case, it'd be also recommended to initialize all the members in the constructor, because size should also always have a valid content for that to work. If you don't want to complicate things too much now, just make them private, this will cause the compiler to bark if you try to do an (unsupported) object assignment or copy:</p>\n<pre><code>struct gnt\n{\n    unsigned int* num;\n    unsigned int size;\n    bool negative;\n    gnt() : num(NULL) {}\n    ~gnt() {delete [] num; }\n    private: gnt(const gnt&amp;); gnt &amp;operator = (gnt &amp;);\n};\n</code></pre>\n<p>As others suggested, one alternative is to use std::vector instead of a raw pointer. That way, you don't need to worry about deallocations:</p>\n<pre><code>struct gnt\n{\n    std::vector&lt;unsigned int&gt; num;\n    unsigned int size;\n    bool negative;\n};\n</code></pre>\n<p>About the question \"do I have to worry about the structure itself?\", that depends on how you created its instances. If it was with operator new, yes. If not, they'll be deallocated when goin out of scope as any other variable.</p>\n<p>Finally, about the recursion, IMO rarely the choice is about code efficiency. You should use recursion only if the code becomes simpler/cleaner AND there is no danger of adverse effects (like stack overflow). If that's not the case, I'd always go for the iterative version.</p>\n", "Id": "8067907", "LastEditDate": "2011-11-09T21:11:11.807", "ParentId": "8067744", "OwnerUserId": "8999", "PostTypeId": "2", "Score": "3", "LastEditorUserId": "8999"}, "8067744": {"CreationDate": "2011-11-09T15:58:13.433", "ViewCount": "309", "Id": "8067744", "AcceptedAnswerId": "8067907", "Score": "1", "Title": "How do I free pointers inside structures?", "CommentCount": "6", "Body": "<p>I'm new to structures so please bear with me. I wrote a structure called gnt containing an integer pointer, an integer, and a boolean:</p>\n<pre><code>struct gnt\n{\n    unsigned int* num;\n    unsigned int size;\n    bool negative;\n};\n</code></pre>\n<p>Because I am allocating arbitrary length int arrays to various gnt variables (ie. <code>k.num = new int*[j]</code>) (for some value <code>j</code>), I need to free them somehow. I am not sure how to do that. Do I simply use <code>delete[] k.num;</code> (where k is a gnt)? Do I have to worry about the structure itself?</p>\n<p>Also, as a side question, I wrote a recursive function to multiply out items in a list:</p>\n<pre><code>char* chain_multi(char** list, unsigned int start, unsigned int end)\n{\n    /***************************************************************\n    This function recursively multiply every items in a list then\n    return the product.\n    ***************************************************************/\n    unsigned int size = start - end + 1;\n    if(size == 1)\n        return copy_char(list[end]);\n    if(size == 2)\n        return multiplication(list[start], list[end]);\n\n    int rs = start - size / 2;\n    char* right = chain_multi(list, rs, end);\n    char* left = chain_multi(list, start, rs + 1);\n    char* product = multiplication(left, right);\n    delete[] left;\n    delete[] right;\n    return product;\n}\n</code></pre>\n<p>Will this give any advantage over doing it without recursion? I tested with various sized lists (between 10 - 10000 entries) and there doesn't seem to be any advantage time wise... The recursive code is shorter than its counterpart though.</p>\n<p>Thanks for any input.</p>\n", "Tags": "<c++><recursion><structure><destructor>", "LastActivityDate": "2011-11-09T21:11:11.807", "PostTypeId": "1", "AnswerCount": "4", "OwnerUserId": "1026257"}, "8067779": {"LastActivityDate": "2011-11-09T16:09:12.263", "CreationDate": "2011-11-09T16:01:26.740", "CommentCount": "5", "Body": "<p>Follow the Rule:<br>\nYou should pass the same address to <code>delete[]</code> that you received from <code>new[]</code>.<br>\nIf You allocated only a member on freestore, so you would need to deallocate only that.</br></br></p>\n<p>You allocated the member <code>k.num</code> using <code>new []</code>, so yes you should call <code>delete []</code> only for it.</p>\n<p>Also, You can use <code>std::vector</code> instead of doing the memory management by yourself(unless this is some crappy assignment which restricts you from doing so)</p>\n<hr>\n<p>For Standerdese Fans:<br>\n<strong>Standard C++03 \u00a7 3.7.4.2-3:</strong> </br></p>\n<blockquote>\n<p id=\"so_8067744_8067779_0\">If a deallocation function terminates by throwing an exception, the behavior is undefined. The value of the first argument supplied to a deallocation function may be a null pointer value; if so, and if the deallocation function is one supplied in the standard library, the call has no effect. Otherwise, the value supplied\n  to operator <code>delete(void*)</code> in the standard library shall be one of the values returned by a previous invocation of either operator <code>new(std::size_t)</code> or <code>operator new(std::size_t, const std::nothrow_-t&amp;)</code> in the standard library, and the value supplied to operator <code>delete[](void*)</code> in the standard library shall be one of the values returned by a previous invocation of either <code>operator new[](std::size_t)</code> or\n  <code>operator new[](std::size_t, const std::nothrow_t&amp;)</code> in the standard library.</p>\n</blockquote>\n</hr>", "Id": "8067779", "LastEditDate": "2011-11-09T16:09:12.263", "ParentId": "8067744", "OwnerUserId": "452307", "PostTypeId": "2", "Score": "3", "LastEditorUserId": "452307"}, "bq_ids": {"n4140": {"so_8067744_8067779_0": {"length": 61, "quality": 0.9838709677419355, "section_id": 7182}}, "n3337": {"so_8067744_8067779_0": {"length": 61, "quality": 0.9838709677419355, "section_id": 6926}}}, "8067809": {"CommentCount": "0", "Body": "<p>The usual advantage of recursion is simplicity and clarity (and possibly a different approach to a problem), not normally speed. In fact, rather the opposite used to be true: recursive implementations tended to be noticeably slower than iterative ones. Modern hardware has eliminated or drastically reduced that speed differential, but it would still be fairly unusual for a recursive implementation to be faster than an iterative counterpart.</p>\n", "CreationDate": "2011-11-09T16:03:10.070", "ParentId": "8067744", "Id": "8067809", "LastActivityDate": "2011-11-09T16:03:10.070", "PostTypeId": "2", "Score": "1", "OwnerUserId": "179910"}, "8067831": {"CommentCount": "4", "Body": "<p><code>free</code> is fine on any pointer disregarding the fact it is a structure member or not. If you are writing C code maybe it would be better to use <code>malloc()</code> and <code>free()</code>.</p>\n<p>For recursion or not it depends on the context. Generally speaking recursion is ok. Recursion is slightly slower because of some function calling and parameter passing overhead. The problem with recursion is that if you go very deep in recursion level (maybe 1000 nested function call) you could end up filling the stack. This would cause the program to crash.</p>\n", "CreationDate": "2011-11-09T16:04:24.640", "ParentId": "8067744", "Id": "8067831", "LastActivityDate": "2011-11-09T16:04:24.640", "PostTypeId": "2", "Score": "0", "OwnerUserId": "1029825"}});