post_cb({"30048391": {"Id": "30048391", "PostTypeId": "2", "Body": "<p>No, it isn't possible to <em>initialize</em> it, but there should be no reason why you can't just call a static setter function that assigns a value to <code>i</code> in run-time. This is the best method.</p>\n<p>Or you alternatively, you could make it so that the constructor always initializes the variable:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Test\n{\n  private:\n    static int i;\n\n  public:\n    Test()\n    {\n      i=2;\n    }\n\n    void print_i (void)\n    {\n      std::cout &lt;&lt; i &lt;&lt; std::endl;\n    }\n};\n\nint Test::i = 1;\n\n\nint main()\n{\n  Test test;\n\n  test.print_i(); // will print 2\n}\n</code></pre>\n", "LastActivityDate": "2015-05-05T08:56:42.497", "CommentCount": "6", "CreationDate": "2015-05-05T08:56:42.497", "ParentId": "30048154", "Score": "1", "OwnerUserId": "584518"}, "30048154": {"ViewCount": "102", "Body": "<p>Test.h</p>\n<pre><code>class Test\n{\n    static int i;\n};\n</code></pre>\n<p>Test.cpp</p>\n<pre><code>int Test::i = 1;\n</code></pre>\n<p>I know that normally we initialize a static member as above. And the static member is initialized before the function <code>main</code> runs.<br>\nMy question is:<br>\nIs it possible to initialize the static member <strong>after</strong> the function <code>main</code> runs? Something like this:<br/></br></br></p>\n<pre><code>int main()\n{\n// do something\n// initialize the Test::i here\n}\n</code></pre>\n", "AcceptedAnswerId": "30048391", "Title": "Is it possible to initialize a static member variable after running the main?", "CreationDate": "2015-05-05T08:46:58.870", "Id": "30048154", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-05-05T09:09:27.993", "Score": "3", "OwnerUserId": "3305546", "Tags": "<c++><static>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_30048154_30048403_0": {"length": 13, "quality": 1.0, "section_id": 7151}}, "n3337": {"so_30048154_30048403_0": {"length": 13, "quality": 1.0, "section_id": 6895}}, "n4659": {"so_30048154_30048403_0": {"length": 9, "quality": 0.6923076923076923, "section_id": 4051}}}, "30048587": {"Id": "30048587", "PostTypeId": "2", "Body": "<p>I'm going to assume that you really mean initialization, so that assignment after <code>main</code> has started is out. This will not make a difference for basic types like <code>int</code> or <code>double</code>, but may make one for complex data types.</p>\n<p>The answer is: no but yes (sort of). It is not possible to delay the initialisation of a static data member until after <code>main</code> started, but you can use a static member function with a function-local static object to simulate the effect. This object will be initialized after the function is first called. In code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {\n  A() {\n    std::cout &lt;&lt; \"A::A()\\n\";\n  }\n\n  void do_something() {\n    std::cout &lt;&lt; \"A::do_something()\\n\";\n  }\n};\n\nstruct B {\n  static A &amp;a() {\n    static A instance;\n    return instance;\n  }\n};\n\nint main() {\n  std::cout &lt;&lt; \"main start\\n\";\n\n  B::a().do_something();\n  B::a().do_something();\n\n  std::cout &lt;&lt; \"main end\\n\";\n}\n</code></pre>\n<p>This will print</p>\n<pre><code>main start\nA::A()\nA::do_something()\nA::do_something()\nmain end\n</code></pre>\n<p>You would then use <code>B::a()</code> where you'd have used <code>B::a</code> before. You will have to make sure that the function is not called before <code>main</code> is started.</p>\n", "LastActivityDate": "2015-05-05T09:05:40.473", "CommentCount": "3", "CreationDate": "2015-05-05T09:05:40.473", "ParentId": "30048154", "Score": "1", "OwnerUserId": "4301306"}, "30048403": {"Id": "30048403", "PostTypeId": "2", "Body": "<p>You're confusing the word <code>static</code> and the word <code>const.</code> </p>\n<p>You <strong>have to</strong> initialize a <code>const</code> when you declare it;</p>\n<p>You <strong>don't have to</strong> initialize a <code>static</code> when you declare it, but you can change it anywhere anytime, given you can access it. (which is not the case here, your i is private.)</p>\n<p>About thoses statements, let's look at the C++ standard (<strong>3.6.2</strong>) :</p>\n<blockquote>\n<p id=\"so_30048154_30048403_0\">Variables with static storage duration or thread storage duration\n  shall be zero-initialized before any other initialization takes place.</p>\n</blockquote>\n<p>Technically, yes, your static data is always zero-initialized even if you explicitely initialize it.</p>\n", "LastEditorUserId": "4117075", "LastActivityDate": "2015-05-05T09:06:10.630", "Score": "-1", "CreationDate": "2015-05-05T08:57:19.693", "ParentId": "30048154", "CommentCount": "10", "OwnerUserId": "4117075", "LastEditDate": "2015-05-05T09:06:10.630"}, "30048367": {"Id": "30048367", "PostTypeId": "2", "Body": "<p>The first mistake you have is that the variable 'i' is private for the class, so you cannot access it outside the class. There are two ways to fix this. The first is to make it public(not preffered) and the second to make setter and getter methods. </p>\n<p>About the question the answer is yes, you can. Use the setter method I mentioned above. \nThese are the two methods:</p>\n<pre><code>//\u2026\npublic:\n  static int get_i() {\n    return i;\n  }\n  static void set_i(int val) {\n    i = val;\n  }\n//\u2026\n</code></pre>\n<p>You can call the method like that:</p>\n<pre><code>Test::set_i(10);\n</code></pre>\n<p>Note: do not forget to include the keyword <code>public</code> before the methods so you can access them outside the class. </p>\n", "LastEditorUserId": "4200617", "LastActivityDate": "2015-05-05T09:09:27.993", "Score": "0", "CreationDate": "2015-05-05T08:55:26.220", "ParentId": "30048154", "CommentCount": "1", "OwnerUserId": "4200617", "LastEditDate": "2015-05-05T09:09:27.993"}});