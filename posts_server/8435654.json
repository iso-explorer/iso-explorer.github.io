post_cb({"8435858": {"ParentId": "8435654", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2011-12-08T18:34:29.190", "Score": "3", "LastEditorUserId": "241536", "LastEditDate": "2011-12-08T18:44:12.487", "Id": "8435858", "OwnerUserId": "241536", "Body": "<p>In:</p>\n<p><code>foobar(&amp;MyClass::method);</code></p>\n<p>... <code>&amp;</code> is not the \"reference operator\" but is the address-of operator.  It takes the address of its operand.</p>\n<p>You actually do still \"have to\" take the address of a free function in code such as (although implicit conversions are available):</p>\n<pre><code>goobar(freefunction);\n</code></pre>\n<p>There are implicit conversions available which will cause an expression such as <code>Foo</code> to decay in to a pointer, but I have had much difficulty in getting GCC to accept such code error- and warning-free, in cases where MSVC has no problems.</p>\n<p>Aside from this, there are two main differences between free functions and non-static member functions:</p>\n<ol>\n<li>Non-<code>static</code> member functions operate on an instance of a class, and there is a <code>this</code> pointer which points to the class itself.</li>\n<li>The syntax for creating and calling through a pointer-to-free-function is different than that for a pointer-to-member-function.</li>\n</ol>\n<p>In the case of the free function, the syntax is trivial(ish):</p>\n<pre><code>void foo();  // Function declaration\nvoid(*f)();  // Declaration of pointer-to-function-returning-void-and-taking-no-parameters\n</code></pre>\n<p>But in the case of a pointer to a member function, the syntax is much trickier:</p>\n<pre><code>struct Bar\n{\n  void DoIt()\n  {\n  }\n  void DoThat(int n)\n  {\n    n;\n  }\n};\n\n\nvoid(Bar::*thatfn)(int);    // declares a pointer-to-member-function taking int returning nothing\nthatfn = &amp;Bar::DoThat;      // initializes pointer to point to DoThat(int)\n(bar.*thatfn)(42);          // call the function\n</code></pre>\n", "LastActivityDate": "2011-12-08T18:44:12.487"}, "8435826": {"ParentId": "8435654", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2011-12-08T18:30:58.583", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:34:23.413", "Id": "8435826", "OwnerUserId": "415784", "Body": "<p>I think it is because of (\u00a75.3.1/3) which says,</p>\n<blockquote>\n<p id=\"so_8435654_8435826_0\"><strong>A pointer to member is only formed when an explicit &amp; is used and its operand is a qualified-id not enclosed in parentheses.</strong> </p>\n</blockquote>\n<p>and then it goes on to explain this as:</p>\n<blockquote>\n<p id=\"so_8435654_8435826_1\">[Note: that is, the expression &amp;(qualified-id), where the qualified-id is enclosed in parentheses, does not form an expression of type \u201cpointer to member.\u201d Neither does qualified-id, because there is no implicit conversion from a qualified-id for a nonstatic member function to the type \u201cpointer to member function\u201d as there is from an lvalue of function type to the type \u201cpointer to function\u201d (4.3). Nor is &amp;unqualified-id a pointer to member, even within the scope of the unqualified-id\u2019s class. ]</p>\n</blockquote>\n<hr>\n<p>I just got two interesting topics discussing this, especially @Johannes's answer is a nice read here:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/a/7138582/415784\">Error with address of parenthesized member function</a></li>\n</ul>\n<p>and this one as well:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/7134261/strange-c-rule-for-member-function-pointers\">Strange C++ rule for member function pointers?</a></li>\n</ul>\n<p>Which also means this topic should be voted close, for it seems to be a duplicate.</p>\n</hr>", "LastActivityDate": "2011-12-08T18:37:21.493"}, "bq_ids": {"n4140": {"so_8435654_8435826_1": {"section_id": 6067, "quality": 0.9318181818181818, "length": 41}, "so_8435654_8435826_0": {"section_id": 6067, "quality": 1.0, "length": 10}}, "n3337": {"so_8435654_8435826_1": {"section_id": 5835, "quality": 0.9318181818181818, "length": 41}, "so_8435654_8435826_0": {"section_id": 5835, "quality": 1.0, "length": 10}}, "n4659": {"so_8435654_8435826_1": {"section_id": 7563, "quality": 0.9318181818181818, "length": 41}, "so_8435654_8435826_0": {"section_id": 7563, "quality": 1.0, "length": 10}}}, "8435654": {"CommentCount": "2", "ViewCount": "160", "CreationDate": "2011-12-08T18:17:31.690", "LastActivityDate": "2011-12-08T18:44:12.487", "Title": "What are the subtle differences between methods and free functions?", "AcceptedAnswerId": "8435858", "PostTypeId": "1", "Id": "8435654", "Score": "2", "Body": "<p>As I understand it, methods are really just functions with an implicit extra parameter (the <code>this</code> pointer), and static methods are the pretty much the same as free functions.</p>\n<p>But there seem to be some differences between methods and functions; for example, when passing a function as an argument, why does the reference operator <code>&amp;</code> have to be used on methods, but not on free functions?</p>\n<pre><code>foobar(&amp;MyClass::method);\ngoobar(freefunction);\n</code></pre>\n<p>What other subtle technical differences are there between methods and free functions?</p>\n", "Tags": "<c++><function><methods><implementation>", "OwnerUserId": "627005", "AnswerCount": "2"}});