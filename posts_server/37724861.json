post_cb({"37724861": {"ViewCount": "116", "Body": "<p>I have a class <code>B</code> with two overloaded functions <code>int Set(B *);</code> and <code>int Set(const A&amp;);</code>. The class <code>A</code> expects a constructor argument <code>unsigned char</code>. When <code>Set</code> is called with a <code>const unsigned char</code> with value as <code>0</code>, it is resolved to <code>Set(B*)</code> whereas when the value passed is non-zero, it resolves to <code>Set(const A&amp;)</code> (as per my expectation).</p>\n<p>The overload resolution works expectedly with non-const <code>unsigned char</code> but fails with <code>const unsigned char</code> with value set as <code>0</code>. Why?</p>\n<p>Following code illustrates the discrepancy when <code>Set</code> is called with const and non-const <code>unsigned char</code></p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n\nclass A{\n  char m_byteValue;\npublic:\n  A(unsigned char c) {\n    m_byteValue = c;\n  }\n};\n\n\nclass B{\n  int m_a;\npublic:\n  B(){\n    m_a = 2;\n  }\n  int Set(B *);\n  int Set(const A&amp;);\n};\n\nint B::Set(const A&amp; v) {\n  cout &lt;&lt; \"I am in the const ref function\\n\";\n  return 0;\n}\n\nint B::Set(B* p) {\n  cout &lt;&lt; \"I am in the pointer function\\n\";\n  return 0;\n}\n\nint main(){\n  const unsigned char a = 0;\n  const unsigned char b = 1;\n  unsigned char c = 0;\n  unsigned char d = 1;\n  B var;\n  var.Set(a);\n  var.Set(b);\n  var.Set(c);\n  var.Set(d);\n  return 0;\n}\n</code></pre>\n<p>Output (as compiled by <code>gcc 4.9.2</code> c++98):\n<a href=\"http://ideone.com/H0P0ya\" rel=\"nofollow\">Demo</a> - on ideone c++ 5.1</p>\n<pre><code>I am in the pointer function // Why?\nI am in the const ref function\nI am in the const ref function\nI am in the const ref function\n</code></pre>\n", "AcceptedAnswerId": "37727181", "Title": "Incorrect overload resolution with value of const argument as 0", "CreationDate": "2016-06-09T11:35:57.033", "Id": "37724861", "CommentCount": "5", "LastEditDate": "2016-06-09T11:47:00.773", "PostTypeId": "1", "LastEditorUserId": "4342498", "LastActivityDate": "2016-06-09T13:19:46.983", "Score": "4", "OwnerUserId": "1112010", "Tags": "<c++><const><function-overloading><c++98>", "AnswerCount": "2"}, "37727181": {"Id": "37727181", "PostTypeId": "2", "Body": "<p>The difference between the standards is here:</p>\n<p>C++98 [conv.ptr]</p>\n<blockquote>\n<p id=\"so_37724861_37727181_0\">A <em>null pointer constant</em> is an integral constant expression rvalue of integer type that evaluates to zero.</p>\n</blockquote>\n<p>C++11 [conv.ptr]</p>\n<blockquote>\n<p id=\"so_37724861_37727181_1\">A <em>null pointer constant</em> is an integer literal with value zero or a prvalue of type <code>std::nullptr_t</code>.</p>\n</blockquote>\n<p><code>const unsigned char a = 0;</code> satisfies the C++98 definition of an integral constant expression. Of course <code>a</code> is not an rvalue, but it seems that an lvalue-to-rvalue conversion applies and is still a better match than the user-defined conversion from <code>unsigned char</code> to <code>A</code>.</p>\n<p><code>a</code> is not a literal, this is what makes the behaviour different in C++11.</p>\n", "LastActivityDate": "2016-06-09T13:19:46.983", "CommentCount": "2", "CreationDate": "2016-06-09T13:19:46.983", "ParentId": "37724861", "Score": "4", "OwnerUserId": "1639256"}, "bq_ids": {"n4140": {"so_37724861_37727181_1": {"length": 10, "quality": 1.0, "section_id": 39}}, "n3337": {"so_37724861_37727181_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 36}, "so_37724861_37727181_1": {"length": 8, "quality": 0.8, "section_id": 36}}, "n4659": {"so_37724861_37727181_1": {"length": 10, "quality": 1.0, "section_id": 39}}}, "37725118": {"Id": "37725118", "PostTypeId": "2", "Body": "<p>Clang reproduces the error, but fortunately also gives you the answer during compilation:</p>\n<pre><code>overloading_incorrect.cxx:41:13: warning: expression which evaluates\nto zero treated as a null pointer constant of type 'B *'\n[-Wnon-literal-null-conversion] \nvar.Set(a);\n        ^\n</code></pre>\n<p>As NathanOliver mentions correctly under your post, this behavior disappears as soon as the c++11 standard is used (adding the <code>-std=c++11</code> flag to the compiler).</p>\n", "LastEditorUserId": "1673574", "LastActivityDate": "2016-06-09T11:52:28.377", "Score": "2", "CreationDate": "2016-06-09T11:47:18.503", "ParentId": "37724861", "CommentCount": "4", "OwnerUserId": "1673574", "LastEditDate": "2016-06-09T11:52:28.377"}});