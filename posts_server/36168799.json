post_cb({"bq_ids": {"n4140": {"so_36168799_36168890_0": {"length": 19, "quality": 0.95, "section_id": 3361}}, "n4659": {"so_36168799_36168890_0": {"length": 19, "quality": 0.95, "section_id": 4127}}}, "36168799": {"ViewCount": "78", "LastEditDate": "2016-03-23T02:42:31.297", "Title": "Catching an exception by value - gcc and clang disagree", "CreationDate": "2016-03-23T02:34:29.377", "LastActivityDate": "2016-03-23T12:40:54.927", "CommentCount": "3", "Body": "<p>Consider this short snippet:</p>\n<pre><code>struct B {\n    B() = default;\n    explicit B(B const&amp; ) { }\n};\n\nstruct D : B { };\n\nint main() {\n    try {\n        throw D{};\n    }\n    catch(B ) {\n    }\n}\n</code></pre>\n<p>gcc accepts this code, clang considers it ill-formed with:</p>\n<pre><code>main.cpp:17:13: error: no matching constructor for initialization of 'B'\n    catch(B ) {\n            ^\n</code></pre>\n<p>Who's right? </p>\n", "PostTypeId": "1", "LastEditorUserId": "493106", "Id": "36168799", "Score": "6", "OwnerUserId": "2069064", "Tags": "<c++><gcc><exception-handling><clang><language-lawyer>", "AnswerCount": "1"}, "36168890": {"Id": "36168890", "PostTypeId": "2", "LastEditDate": "2016-03-23T12:40:54.927", "CommentCount": "1", "LastEditorUserId": "2069064", "LastActivityDate": "2016-03-23T12:40:54.927", "CreationDate": "2016-03-23T02:43:37.947", "ParentId": "36168799", "Score": "4", "Body": "<p>I <em>think</em> this is a gcc bug (and since nobody has downvoted this answer yet, I submitted it as <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=70375\" rel=\"nofollow\">70375</a>).</p>\n<p>Both compilers correctly agree that <code>D{}</code> should be caught, as per <a href=\"http://eel.is/c++draft/except.handle#3\" rel=\"nofollow\">[except.handle]/3</a>, which only checks that <code>B</code> is a base class of <code>D</code>.</p>\n<p>But the initialization of the handler is defined in <a href=\"http://eel.is/c++draft/except.handle#15\" rel=\"nofollow\">[except.handle]/15</a> as:</p>\n<blockquote>\n<p id=\"so_36168799_36168890_0\">The variable declared by the exception-declaration, of type <em>cv</em> <code>T</code> or <em>cv</em> <code>T&amp;</code>, is initialized from the exception object, of type <code>E</code>, as follows:<br>\n  \u2014 if <code>T</code> is a base class of <code>E</code>, the variable is copy-initialized (8.5) from the corresponding base class subobject of the exception object;</br></p>\n</blockquote>\n<p>That implies that initialization works as:</p>\n<pre><code>D __temporary_object{};\nB __handler = static_cast&lt;B&amp;&gt;(__temporary_object);\n</code></pre>\n<p>which should be disallowed since <code>B</code>'s copy constructor is marked <code>explicit</code> (and copy-initialization just doesn't cut it).</p>\n", "OwnerUserId": "2069064"}});