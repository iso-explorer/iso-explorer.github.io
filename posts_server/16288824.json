post_cb({"16288955": {"Id": "16288955", "PostTypeId": "2", "Body": "<p>If use virtual inheritance, the most-derived type has to do the initialization of this virtual base class. If you don't use virtual inheritance, the directly derived type has to do the initialization.</p>\n<p>Therefore, the private ctor does not prevent the derived type <code>NewClass</code> from initializing the direct base class <code>SealingClass</code>, and <code>AnotherClass</code> does not have to initialize <code>NewClass</code> if it's not been virtually inherited.</p>\n<hr>\n<p>Some examples:</p>\n<pre><code>template&lt;typename Child&gt;\nclass SealingClass {\npublic: // for now\n    SealingClass() {}\n};\n\nclass NewClass : public SealingClass&lt;T&gt; {\npublic:\n    NewClass() : SealingClass&lt;T&gt;() {} // allowed, SealingClass&lt;T&gt; is a\n                                      //   direct base class\n};\n\nclass AnotherClass : public NewClass {\npublic:\n    AnotherClass() : NewClass() {}        // allowed, NewClass is a\n                                          //   direct base class\n    AnotherClass() : SealingClass&lt;T&gt;() {} // not allowed, SealingClass&lt;T&gt; is\n                                          //   no direct nor a virtual base class\n};\n\n\nclass NewClass_v : public virtual SealingClass&lt;T&gt; {\npublic:\n    NewClass_v() : SealingClass&lt;T&gt;() {}   // allowed, SealingClass&lt;T&gt; is a\n                                          //   direct base class\n};\n\nclass AnotherClass_v : public NewClass_v {\npublic:\n    AnotherClass_v() : NewClass_v() {}        // allowed, NewClass_virt is a\n                                              //   direct base class\n    AnotherClass_v() : SealingClass&lt;T&gt;() {}   // allowed, SealingClass&lt;T&gt; is a \n                                              //   virtual base class\n};\n</code></pre>\n<p>Now, if the ctor of <code>SealingClass</code> is private, <code>AnotherClass_virt</code> is not allowed to call this ctor due to the <code>private</code> access specifier and not being a friend.</p>\n<p>If you leave out the explicit initialization of a base class (whether virtual or direct), it is default-initialized ([class.base.init]/8), that is, the default ctor is called implicitly (but you still must have access to the ctor, so it's the same as explicitly writting the call to the default ctor).</p>\n<hr>\n<p>Some quotes:</p>\n<p>[class.base.init]/1</p>\n<blockquote>\n<p id=\"so_16288824_16288955_0\"><strong>In the definition of a constructor for a class, initializers for direct and virtual base subobjects</strong> and non-static data members <strong>can be specified by a ctor-initializer</strong></p>\n</blockquote>\n<p>[class.base.init]/7</p>\n<blockquote>\n<p id=\"so_16288824_16288955_1\">A mem-initializer where the mem-initializer-id denotes a virtual base class is ignored during execution of a constructor of any class that is not the most derived class.</p>\n</blockquote>\n<p>[class.base.init]/10</p>\n<blockquote>\n<p id=\"so_16288824_16288955_2\">In a non-delegating constructor, initialization proceeds in the following order:</p>\n<ul>\n<li><strong>First, and only for the constructor of the most derived class, virtual base classes are initialized</strong> in the order they appear on a depth-first left-to-right traversal of the directed acyclic graph of base classes, where \u201cleft-to-right\u201d is the order of appearance of the base classes in the derived class base-specifier-list.</li>\n<li><strong>Then, direct base classes are initialized</strong> in declaration order as they appear in the base-specifier-list (regardless of the order of the mem-initializers).</li>\n</ul>\n</blockquote>\n<p>Emphasis mine.</p>\n</hr></hr>", "LastEditorUserId": "420683", "LastActivityDate": "2013-04-29T22:49:19.210", "Score": "7", "CreationDate": "2013-04-29T21:59:16.580", "ParentId": "16288824", "CommentCount": "1", "OwnerUserId": "420683", "LastEditDate": "2013-04-29T22:49:19.210"}, "bq_ids": {"n4140": {"so_16288824_16288955_2": {"length": 6, "quality": 1.0, "section_id": 438}, "so_16288824_16288955_1": {"length": 15, "quality": 1.0, "section_id": 434}, "so_16288824_16288955_0": {"length": 14, "quality": 1.0, "section_id": 428}}, "n3337": {"so_16288824_16288955_2": {"length": 6, "quality": 1.0, "section_id": 429}, "so_16288824_16288955_1": {"length": 15, "quality": 1.0, "section_id": 426}, "so_16288824_16288955_0": {"length": 14, "quality": 1.0, "section_id": 420}}, "n4659": {"so_16288824_16288955_2": {"length": 6, "quality": 1.0, "section_id": 458}, "so_16288824_16288955_1": {"length": 15, "quality": 1.0, "section_id": 452}, "so_16288824_16288955_0": {"length": 14, "quality": 1.0, "section_id": 446}}}, "16288824": {"ViewCount": "404", "Body": "<p><strong>Related: <a href=\"https://stackoverflow.com/questions/11425768/does-virtual-base-class-in-the-case-of-multilevel-inheritance-have-significanc\">Does \"virtual base class in the case of multilevel inheritance\" have significance</a></strong></p>\n<p>I have a template class that can be inherited from in order to impart some select functionality. However, it wants to prevent any classes from further inheriting from anything that inherits it.</p>\n<p>The following seems to achieve this:</p>\n<pre><code>template&lt;typename Child&gt;\nclass SealingClass\n    {\n    public:\n    /*public methods etc*/\n    private:\n    SealingClass() {}\n    friend Child;\n    };\n\n//simplify a bit:\n#define Seal( x ) public virtual SealingClass&lt; x &gt;\n</code></pre>\n<p>Now, I can inherit from the above class, as follows:</p>\n<pre><code>class NewClass: Seal(NewClass) {};\n</code></pre>\n<p>And if I then try inheriting again from <code>NewClass</code>, as in:</p>\n<pre><code>class AnotherClass: public NewClass {};\n</code></pre>\n<p>and then make an instance of said class:</p>\n<pre><code>AnotherClass a;\n</code></pre>\n<p>I get the desired error, regarding the constructor in <code>SealingClass</code> being private.</p>\n<p>So, everything works as I'd like!</p>\n<p>However, I have noticed that if I remove the <code>virtual</code> keyword from the define..</p>\n<pre><code>#define Seal( x ) public SealingClass&lt; x &gt;\n</code></pre>\n<p>..my instantiation of <code>AnotherClass</code> now works just fine.</p>\n<p>I understand that the <code>virtual</code> keyword, in this context, means that only one instance of the base class is defined in cases of multiple inheritance (eg diamond inheritance) where multiple instances of it could exist, leading to ambiguous function calls etc.</p>\n<p>But, why does it affect the functionality of the above?</p>\n<p>Thanks :)</p>\n", "AcceptedAnswerId": "16288955", "Title": "c++ why does virtual inheritance allow for the prevention of further inheritance?", "CreationDate": "2013-04-29T21:48:16.747", "Id": "16288824", "CommentCount": "4", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:07:55.510", "LastEditorUserId": "-1", "LastActivityDate": "2013-04-29T22:49:19.210", "Score": "9", "OwnerUserId": "1339698", "Tags": "<c++><inheritance><virtual>", "AnswerCount": "1"}});