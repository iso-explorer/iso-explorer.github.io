post_cb({"18544320": {"ParentId": "18544249", "LastEditDate": "2013-09-01T05:12:32.950", "CommentCount": "6", "CreationDate": "2013-08-31T03:53:57.797", "OwnerUserId": "2682142", "LastEditorUserId": "2682142", "PostTypeId": "2", "Id": "18544320", "Score": "30", "Body": "<p>Here are the relevant parts of the standard. See my explanation below the standard text:</p>\n<h3>\u00a76.9.2/2 External object definitions</h3>\n<blockquote>\n<p id=\"so_18544249_18544320_0\">A declaration of an identifier for an object that has file scope without an initializer, and without a storage-class specifier or with the storage-class specifier static, constitutes a tentative definition. If a translation unit contains one or more tentative definitions for an identifier, and the translation unit contains no external definition for that identifier, then the behavior is exactly as if the translation unit contains a file scope declaration of that identifier, with the composite type as of the end of the translation unit, with an initializer equal to 0.</p>\n</blockquote>\n<h3>ISO C99 \u00a76.9/5 External definitions</h3>\n<blockquote>\n<p id=\"so_18544249_18544320_1\">An external definition is an external declaration that is also a definition of a function (other than an inline definition) or an object. If an identifier declared with external linkage is used in an expression (other than as part of the operand of a sizeof operator whose result is an integer constant), somewhere in the entire program there shall be exactly one external definition for the identifier; otherwise, there shall be no more than one.</p>\n</blockquote>\n<p>With the C version, the 'g' global variables are 'merged' into one, so you will only have one in the end of the day which is declared twice. This is OK due to the time when extern was not needed, or perhaps did not exits. Hence, this is for historical and compatibility reason to build old code. This is a <strong>gcc extension</strong> for this legacy feature.</p>\n<p>It basically makes gcc allocate memory for a variable with the name 'a', so there can be more than one declarations, but only one definition. That is why the code below will not work even with gcc.</p>\n<p>This is also called tentative definition. There is no such a thing with C++, and that is while it compiles. C++ has no concept of tentative declaration.</p>\n<blockquote>\n<p id=\"so_18544249_18544320_2\">A tentative definition is any external data declaration that has no storage class specifier and no initializer. A tentative definition becomes a full definition if the end of the translation unit is reached and no definition has appeared with an initializer for the identifier. In this situation, the compiler reserves uninitialized space for the object defined.</p>\n</blockquote>\n<p>Note however that the following code will not compile even with gcc because this is tentative definition/declaration anymore with values assigned:</p>\n<p>in file \"a.c/a.cpp\"</p>\n<pre><code>int a = 1;\n</code></pre>\n<p>in file \"b.c/b.cpp\"</p>\n<pre><code>int a = 2;\nint main() { return 0; }\n</code></pre>\n<p>Let us go even beyond this with further examples. The following statements show normal definitions and tentative definitions. Note, static would make it a bit difference since that is file scope, and would not be external anymore.</p>\n<pre><code>int i1 = 10;         /* definition, external linkage */\nstatic int i2 = 20;  /* definition, internal linkage */\nextern int i3 = 30;  /* definition, external linkage */\nint i4;              /* tentative definition, external linkage */\nstatic int i5;       /* tentative definition, internal linkage */\n\nint i1;              /* valid tentative definition */\nint i2;              /* not legal, linkage disagreement with previous */\nint i3;              /* valid tentative definition */\nint i4;              /* valid tentative definition */\nint i5;              /* not legal, linkage disagreement with previous */\n</code></pre>\n<p>Further details can be on the following page:</p>\n<p><a href=\"http://c0x.coding-guidelines.com/6.9.2.html\">http://c0x.coding-guidelines.com/6.9.2.html</a></p>\n<p>See also this blog post for further details:</p>\n<p><a href=\"http://ninjalj.blogspot.co.uk/2011/10/tentative-definitions-in-c.html\">http://ninjalj.blogspot.co.uk/2011/10/tentative-definitions-in-c.html</a></p>\n", "LastActivityDate": "2013-09-01T05:12:32.950"}, "18544249": {"CommentCount": "4", "CreationDate": "2013-08-31T03:39:33.220", "PostTypeId": "1", "AcceptedAnswerId": "18544320", "LastEditorUserId": "2682142", "LastActivityDate": "2014-08-27T10:22:48.490", "LastEditDate": "2014-08-27T10:22:48.490", "ViewCount": "2033", "FavoriteCount": "4", "Title": "What is the difference between the global variables in C and C++?", "Id": "18544249", "Score": "27", "Body": "<p>I have tested the following code:</p>\n<p>in file <strong>a.c/a.cpp</strong></p>\n<pre><code>int a;\n</code></pre>\n<p>in file <strong>b.c/b.cpp</strong></p>\n<pre><code>int a;\nint main() { return 0; }\n</code></pre>\n<p>When I compile the source files with <strong>gcc *.c -o test</strong>, it succeeds.</p>\n<p>But when I compile the source files with <strong>g++ *.c -o test</strong>, it fails:</p>\n<pre><code>ccIJdJPe.o:b.cpp:(.bss+0x0): multiple definition of 'a'\nccOSsV4n.o:a.cpp:(.bss+0x0): first defined here\ncollect2.exe: error: ld returned 1 exit status\n</code></pre>\n<p>I'm really confused about this. Is there any difference between the global variables in C and C++?</p>\n", "Tags": "<c++><c><gcc><global-variables>", "OwnerUserId": "1162062", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_18544249_18545856_3": {"section_id": 7043, "quality": 0.5454545454545454, "length": 12}}, "n3337": {"so_18544249_18545856_3": {"section_id": 6788, "quality": 0.5454545454545454, "length": 12}}, "n4659": {"so_18544249_18545856_3": {"section_id": 8540, "quality": 0.5454545454545454, "length": 12}}}, "18545856": {"ParentId": "18544249", "LastEditDate": "2013-08-31T08:29:50.477", "CommentCount": "0", "CreationDate": "2013-08-31T07:48:41.587", "OwnerUserId": "19563", "LastEditorUserId": "19563", "PostTypeId": "2", "Id": "18545856", "Score": "5", "Body": "<p>gcc implements a legacy feature where uninitialized global variables are placed in a common block.</p>\n<p>Although in each translation unit the definitions are tentative, in ISO C, at the end of the translation unit, tentative definitions are \"upgraded\" to full definitions if they haven't already been merged into a non-tentative definition.</p>\n<p>In standard C, it is always incorrect to have the same variables with external linkage defined in more that one translation unit even if these definitions came from tentative definitions.</p>\n<p>To get the same behaviour as C++, you can use the <code>-fno-common</code> switch with gcc and this will result in the same error. (If you are using the GNU linker and don't use <code>-fno-common</code> you might also want to consider using the <code>--warn-common</code> / <code>-Wl,--warn-common</code> option to highlight the link time behaviour on encountering multiple common and non-common symbols with the same name.)</p>\n<p>From the gcc man page:</p>\n<blockquote>\n<p id=\"so_18544249_18545856_0\"><code>-fno-common</code></p>\n<p id=\"so_18544249_18545856_1\">In C code, controls the placement of uninitialized global\n  variables.  Unix C compilers have traditionally permitted multiple\n       definitions of such variables in different compilation units by\n       placing the variables in a common block.  This is the behavior\n       specified by <code>-fcommon</code>, and is the default for GCC on most\n       targets.  On the other hand, this behavior is not required by ISO\n       C, and on some targets may carry a speed or code size penalty on\n       variable references.  The <code>-fno-common</code> option specifies that the\n       compiler should place uninitialized global variables in the data\n       section of the object file, rather than generating them as common\n       blocks.  This has the effect that if the same variable is declared\n       (without <code>extern</code>) in two different compilations, you will get a\n       multiple-definition error when you link them.  In this case, you\n       must compile with <code>-fcommon</code> instead.  Compiling with\n       <code>-fno-common</code> is useful on targets for which it provides better\n       performance, or if you wish to verify that the program will work\n       on other systems which always treat uninitialized variable\n       declarations this way.</p>\n</blockquote>\n<p>gcc's behaviour is a common one and it is described in Annex J of the standard (which is not normative) which describes commonly implemented extensions to the standard:</p>\n<blockquote>\n<p id=\"so_18544249_18545856_2\"><strong>J.5.11 Multiple external definitions</strong></p>\n<p id=\"so_18544249_18545856_3\">There may be more than one external definition for the identifier of an object, with or\n  without the explicit use of the keyword <code>extern</code>; if the definitions disagree, or more than\n  one is initialized, the behavior is undefined (6.9.2).</p>\n</blockquote>\n", "LastActivityDate": "2013-08-31T08:29:50.477"}});