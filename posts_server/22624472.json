post_cb({"22624510": {"ParentId": "22624472", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2014-03-25T02:42:10.433", "Score": "4", "LastEditorUserId": "112", "LastEditDate": "2014-03-25T05:10:26.203", "Id": "22624510", "OwnerUserId": "112", "Body": "<p>Yes, that is legal, but you <em>must</em> <code>reinterpret_cast</code> exactly the same <code>uintptr_t</code> value back to <code>char*</code>.</p>\n<p>(Therefore, what it you're <em>intending</em> to do is illegal; that is, converting a <em>different</em> value back to a pointer.)</p>\n<blockquote>\n<p id=\"so_22624472_22624510_0\"><strong>5.2.10 Reinterpret cast</strong></p>\n<p id=\"so_22624472_22624510_1\">4 . A pointer can be explicitly converted to any integral type large enough to hold it. The mapping function is\n  implementation-de\ufb01ned.</p>\n<p id=\"so_22624472_22624510_2\">5 .  A value of integral type or enumeration type can be explicitly converted to a pointer. A pointer converted\n  to an integer of su\ufb03cient size (if any such exists on the implementation) and back to the same pointer type\n  will have its original value;</p>\n</blockquote>\n<p>(Note that there'd be no way, in general, for the compiler to know that you subtracted one and then added it back.)</p>\n", "LastActivityDate": "2014-03-25T05:10:26.203"}, "22643724": {"ParentId": "22624472", "CommentCount": "1", "CreationDate": "2014-03-25T18:51:12.407", "OwnerUserId": "827263", "PostTypeId": "2", "Id": "22643724", "Score": "11", "Body": "<p>No, <code>uintptr_t</code> cannot be <em>meaningfully</em> used to avoid undefined behavior when performing pointer arithmetic.</p>\n<p>For one thing, at least in C there is no guarantee that <code>uintptr_t</code> even exists. The requirement is that any value of type <code>void*</code> may be converted to <code>uintptr_t</code> and back again, yielding the original value without loss of information. In principle, there might not be any unsigned integer type wide enough to hold all pointer values. (I presume the same applies to C++, since C++ inherits most of the C standard library and defines it by reference to the C standard.)</p>\n<p>Even if <code>uintptr_t</code> does exist, there is no guarantee that a given arithmetic operation on a <code>uintptr_t</code> value does the same thing as the corresponding operation on a pointer value.</p>\n<p>For example, I've worked on systems (Cray vector systems, T90 and SV1) on which byte pointers are implemented in software. A native address is a 64-bit address that refers to a 64-bit word; there is no hardware support for byte addressing. A <code>char*</code> or <code>void*</code> pointer consists of a word pointer with a 3-bit offset stored in the otherwise unused high-order bits. Conversion between integers and pointers simply copies the bits. So incrementing a <code>char*</code> would advance it to point to the next 8-bit byte in memory; incrementing a <code>uintptr_t</code> obtained by converting a <code>char*</code> would advance it to point to the next 64-bit word.</p>\n<p>That's just one example. More generally, conversions between pointers and integers are implementation-defined, and the language standard makes no guarantee about the semantics of those conversions (other than, in some cases, converting back to a pointer).</p>\n<p>So yes, you can convert a pointer value to <code>uintptr_t</code> (if that type exists) and perform arithmetic on it without risking undefined behavior -- but the result may or may not be meaningful.</p>\n<p>It happens that, on most systems, the mapping between pointers and integers is simpler, and you probably <em>can</em> get away with that kind of game. But you're better off using pointer arithmetic directly, and just being very careful to avoid any invalid operations.</p>\n", "LastActivityDate": "2014-03-25T18:51:12.407"}, "bq_ids": {"n4140": {"so_22624472_22624510_2": {"section_id": 6044, "quality": 0.9615384615384616, "length": 25}, "so_22624472_22624510_1": {"section_id": 6043, "quality": 0.8461538461538461, "length": 11}}, "n3337": {"so_22624472_22624510_2": {"section_id": 5812, "quality": 0.9615384615384616, "length": 25}, "so_22624472_22624510_1": {"section_id": 5811, "quality": 0.8461538461538461, "length": 11}}, "n4659": {"so_22624472_22624510_2": {"section_id": 7543, "quality": 0.9615384615384616, "length": 25}, "so_22624472_22624510_1": {"section_id": 7542, "quality": 0.8461538461538461, "length": 11}}}, "22624472": {"CommentCount": "0", "AcceptedAnswerId": "22624510", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-03-25T02:36:43.623", "LastActivityDate": "2014-03-26T03:59:14.553", "LastEditDate": "2017-05-23T11:52:56.527", "ViewCount": "1046", "FavoriteCount": "1", "Title": "Can std::uintptr_t be used to avoid undefined behavior of out-of-bounds pointer arithmetic?", "Id": "22624472", "Score": "5", "Body": "<p>Now we know that doing out-of-bounds-pointer-arithmetic has undefined behavior as described in this <a href=\"https://stackoverflow.com/questions/10473573/c-why-is-out-of-bounds-pointer-arithmetic-undefined-behaviour\">SO question</a>.</p>\n<p>My question is: can we workaround such restriction by casting to std::uintptr_t for arithmetic operations and then cast back to pointer? is that guaranteed to work?</p>\n<p>For example:</p>\n<pre><code>char a[5];\nauto u = reinterpret_cast&lt;std::uintptr_t&gt;(a) - 1;\nauto p = reinterpret_cast&lt;char*&gt;(u + 1); // OK?\n</code></pre>\n<p>The real world usage is for optimizing offsetted memory access -- instead of <code>p[n + offset]</code>, I want to do <code>offset_p[n]</code>. </p>\n<p><strong>EDIT</strong> To make the question more explicit:</p>\n<p>Given a base pointer <code>p</code> of a char array, if <code>p + n</code> is a valid pointer, will <code>reinterpret_cast&lt;char*&gt;(reinterpret_cast&lt;std::uintptr_t&gt;(p) + n)</code> be guaranteed to yield the same valid pointer?</p>\n", "Tags": "<c++><pointers><pointer-arithmetic>", "OwnerUserId": "2969631", "AnswerCount": "2"}});