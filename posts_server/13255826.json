post_cb({"13255826": {"CommentCount": "3", "ViewCount": "217", "PostTypeId": "1", "LastEditorUserId": "701092", "CreationDate": "2012-11-06T17:01:52.893", "LastActivityDate": "2012-11-07T14:46:57.603", "Title": "Why don't I get compiler errors from returning from a void function template?", "AcceptedAnswerId": "13256601", "LastEditDate": "2012-11-07T14:46:57.603", "Id": "13255826", "Score": "4", "Body": "<p>Consider:</p>\n<pre><code>void f() {\n    return 5;\n}\n</code></pre>\n<p>The above will raise errors. But why not this?:</p>\n<pre><code>template &lt;typename = void&gt; void f() {\n    return 0;\n}\n</code></pre>\n<p>I'm compiling with gcc-4.5.1. Why does it make a difference using templates such that I wouldn't receive errors from doing the same illegal return statement as a non-template function?. The only setback I get is that I can't call the function (i.e <code>f()</code>) without getting:</p>\n<blockquote>\n<p id=\"so_13255826_13255826_0\"><code>error: return-statement with a value, in function returning 'void'</code></p>\n</blockquote>\n<p>But still, what could be the reason that I am able to define a return statement for a void function template?</p>\n<p>Here is the code I have:</p>\n<pre><code>template &lt;typename = void&gt; void f() {\n    return 0;\n}\n\n// pass\n\nint main() {\n\n\n\n}\n</code></pre>\n<p>The above code will pass despite a presumably illegal return statement in a function returning void. </p>\n", "Tags": "<c++><templates>", "OwnerUserId": "701092", "AnswerCount": "3"}, "13255855": {"ParentId": "13255826", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Most of the checks are only done when you instantiate the template.</p>\n<p>This is usually a good thing, as a code could work fine with one kind of template argument but fail to compile with another one. If you have template overloading, the compiler will even ignore candidates that fail to compile, see <a href=\"http://en.wikipedia.org/wiki/Substitution_failure_is_not_an_error\">SFINAE</a>.</p>\n", "OwnerUserId": "650405", "LastEditorUserId": "650405", "LastEditDate": "2012-11-06T17:12:08.290", "Id": "13255855", "Score": "10", "CreationDate": "2012-11-06T17:03:26.750", "LastActivityDate": "2012-11-06T17:12:08.290"}, "13256601": {"ParentId": "13255826", "CommentCount": "11", "Body": "<p>This is a quality of implementation issue. The particular quote from the standard would be:</p>\n<blockquote>\n<p id=\"so_13255826_13256601_0\">14.6/8 [...] If no valid specialization can be generated for a template definition, and that template is not instantiated, the template definition is ill-formed, no diagnostic required. [...]</p>\n</blockquote>\n<p>That is, your program is ill formed because that template cannot be used to generate any <em>valid</em> specialization, but the compiler is not required to diagnose this. When at a later time you instantiate the template, the compiler must generate the specialization, that specialization is not valid and the compiler complains.</p>\n<p>You don't get an error in the template definition because the compiler is following the <em>no diagnostic required</em> path, i.e. ignoring the problem until it can no longer ignore it in the instantiation.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "13256601", "Score": "6", "CreationDate": "2012-11-06T17:55:06.203", "LastActivityDate": "2012-11-06T17:55:06.203"}, "13255869": {"ParentId": "13255826", "PostTypeId": "2", "CommentCount": "6", "Body": "<p><a href=\"http://ideone.com/PHxUJ5\" rel=\"nofollow noreferrer\">You <em>do</em></a>:</p>\n<pre><code>template &lt;typename = void&gt; void f() {\n    return 0;\n}\n\nint main()\n{\n    f&lt;int&gt;();\n}\n</code></pre>\n<blockquote>\n<p id=\"so_13255826_13255869_0\">prog.cpp: In function 'void f() [with  = int]':<br/>\n  prog.cpp:7:12:   instantiated from here<br/>\n  prog.cpp:2:12: error: return-statement with a value, in function returning 'void'</p>\n</blockquote>\n<p>Though the program is still <em>ill-formed</em>, the compiler is choosing not to diagnose the semantic error (which is its prerogative) because you're never actually instantiating that function.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2012-11-06T18:41:25.107", "Id": "13255869", "Score": "7", "CreationDate": "2012-11-06T17:04:13.933", "LastActivityDate": "2012-11-06T18:41:25.107"}, "bq_ids": {"n4140": {"so_13255826_13256601_0": {"section_id": 175, "quality": 0.7857142857142857, "length": 11}}, "n3337": {"so_13255826_13256601_0": {"section_id": 169, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_13255826_13256601_0": {"section_id": 180, "quality": 0.7142857142857143, "length": 10}}}});