post_cb({"bq_ids": {"n4140": {"so_27395773_27396180_0": {"length": 51, "quality": 0.9807692307692307, "section_id": 87}}, "n3337": {"so_27395773_27396180_0": {"length": 45, "quality": 0.8653846153846154, "section_id": 82}}}, "27395773": {"CreationDate": "2014-12-10T07:50:01.607", "ViewCount": "320", "FavoriteCount": "1", "Id": "27395773", "AcceptedAnswerId": "27396180", "Score": "3", "Title": "Pointer to an object with external linkage as a non-type template parameter", "LastEditorUserId": "3953764", "CommentCount": "1", "Body": "<p>As written in the Standard for templates, one of the non-type template parameters can be a pointer to object. \nFor exapmple:</p>\n<pre><code>template &lt;int* x&gt;\nvoid f()\n{}\n</code></pre>\n<p>However when giving the argument during instantiation, only pointers to objects with <em>external</em> linkage are allowed. Why? Why doesn't the Standard allow to instantiate non-type template with a pointer to object with <em>internal</em> linkage? </p>\n<p>I found in other topics on StackOverflow some explanations but it is not clear for me:</p>\n<blockquote>\n<p id=\"so_27395773_27395773_0\">A non-type template argument provided within a template argument list is an expression whose value can be determined at compile time. Such arguments must be: constant expressions, addresses of functions or objects with external linkage, or addresses of static class members.</p>\n</blockquote>\n<p>So if I have <code>static const int x = 10;</code> in a global scope, is the address of this object determined at compile time ?</p>\n<p>Also I found in comments explanation:</p>\n<blockquote>\n<p id=\"so_27395773_27395773_1\">You don't know what the call-stack looks like at compile time. Before your function, there could've been called 10 other or 3 others or however many other, so the address on the stack, at which the string gets created can change from call to call. When you have an object with external linkage, its address is fixed during compilation/linkage.</p>\n</blockquote>\n<p>How can be changed the address of <code>static const int x = 10;</code> defined in a global scope?</p>\n<p>It would be great to understand what happens under the hood.</p>\n", "Tags": "<c++><templates><static><external><linkage>", "LastEditDate": "2014-12-10T08:33:32.437", "LastActivityDate": "2014-12-10T08:33:32.437", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "1758528"}, "27396180": {"LastActivityDate": "2014-12-10T08:25:35.753", "CommentCount": "0", "Body": "<p>In C++11 the requirements were relaxed (with further clarifications in C++14), now <code>[temp.arg.nontype]/1</code> reads:</p>\n<blockquote>\n<p id=\"so_27395773_27396180_0\">A <em>template-argument</em> for a non-type, non-template <em>template-parameter</em> shall be one of:<br>\n   (...)<br>\n  \u2014 a constant expression (5.19) that designates the address of a complete object with <strong>static storage duration and external or internal linkage</strong> or a function with external or internal linkage, including function templates and function <em>template-ids</em> but excluding non-static class members, expressed (ignoring parentheses) as <code>&amp;</code> <em>id-expression</em>, where the <em>id-expression</em> is the name of an object or function, except that the <code>&amp;</code> may be omitted if the name refers to a function or array and shall be omitted if the corresponding <em>template-parameter</em> is a reference</br></br></p>\n</blockquote>\n<p>So in C++11 this compiles, as you want:</p>\n<pre><code>template&lt;int* i&gt; void f(){};\nstatic int x; // even without const\nint main() {\n    f&lt;&amp;x&gt;();\n}\n</code></pre>\n", "CreationDate": "2014-12-10T08:18:00.093", "LastEditDate": "2014-12-10T08:25:35.753", "ParentId": "27395773", "Id": "27396180", "LastEditorUserId": "3959454", "PostTypeId": "2", "Score": "1", "OwnerUserId": "3959454"}});