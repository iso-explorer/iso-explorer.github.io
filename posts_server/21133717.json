post_cb({"bq_ids": {"n4140": {"so_21133717_21134247_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 3260}, "so_21133717_21134503_1": {"length": 22, "quality": 0.88, "section_id": 5811}, "so_21133717_21134503_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 5811}, "so_21133717_21134503_2": {"length": 19, "quality": 0.7916666666666666, "section_id": 5811}, "so_21133717_21134503_3": {"length": 8, "quality": 0.7272727272727273, "section_id": 5768}}, "n3337": {"so_21133717_21134247_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 3132}, "so_21133717_21134503_2": {"length": 19, "quality": 0.7916666666666666, "section_id": 5584}, "so_21133717_21134503_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 5584}, "so_21133717_21134503_1": {"length": 22, "quality": 0.88, "section_id": 5584}, "so_21133717_21134503_3": {"length": 8, "quality": 0.7272727272727273, "section_id": 5541}}, "n4659": {"so_21133717_21134247_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 7709}, "so_21133717_21134503_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 7272}, "so_21133717_21134503_2": {"length": 13, "quality": 0.5416666666666666, "section_id": 7272}, "so_21133717_21134503_3": {"length": 8, "quality": 0.7272727272727273, "section_id": 7225}}}, "21133805": {"Id": "21133805", "PostTypeId": "2", "Body": "<p>This is known as a <a href=\"https://stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points\">sequence-point</a> issue which means certain operations may be performed in any order chosen by the compiler.</p>\n<p>If one has side-effects on the other, it is called \"unspecified behaviour\" a bit like \"undefined behaviour\" however where the result must be one of a fixed subset of outcomes, so here it must be either 0 or 1 and can't be any other value. In reality you should usually avoid doing it.</p>\n<p>In your particular case. performing <code>operator []</code> on a map changes its size (if that element does not yet exist). Thus it has a side effect on the right hand side of what it is assigning to it.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-01-15T10:03:40.720", "Score": "14", "CreationDate": "2014-01-15T09:40:49.000", "ParentId": "21133717", "CommentCount": "14", "OwnerUserId": "442284", "LastEditDate": "2017-05-23T12:09:11.970"}, "21133717": {"ViewCount": "1971", "Body": "<p>The following test program</p>\n<pre><code>#include &lt;map&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main(int argc, char **argv)\n{\n    map&lt;int,int&gt; a;\n    a[1]=a.size();\n    for(map&lt;int,int&gt;::const_iterator it=a.begin(); it!=a.end(); ++it)\n            cout &lt;&lt; \"first \" &lt;&lt; (*it).first &lt;&lt; \" second \" &lt;&lt; (*it).second &lt;&lt; endl;\n}\n</code></pre>\n<p>leads to different output when compiled on <code>g++ 4.8.1</code> (Ubuntu 12.04 LTS):</p>\n<pre><code>g++ xxx.cpp \n./a.out \nfirst 1 second 1\n</code></pre>\n<p>and on Visual Studio 2012 (Windows 7) (Standard Win32 Console Application Project):</p>\n<pre><code>ConsoleApplication1.exe\nfirst 1 second 0\n</code></pre>\n<p>Which compiler is right? Am I doing something wrong?</p>\n", "Title": "Strange std::map behaviour", "CreationDate": "2014-01-15T09:37:34.590", "LastActivityDate": "2014-01-26T23:48:42.440", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-01-15T09:43:40.580", "LastEditorUserId": "105672", "Id": "21133717", "Score": "50", "OwnerUserId": "3197430", "Tags": "<c++><visual-studio-2012><g++>", "AnswerCount": "3"}, "21134503": {"Id": "21134503", "PostTypeId": "2", "Body": "<p>This is actually a well-formed program that has two equally valid execution paths, so both compilers are right.</p>\n<pre><code>a[1] = a.size()\n</code></pre>\n<p>In this expression, the evaluation of the two operands of <code>=</code> are unsequenced.</p>\n<blockquote>\n<p id=\"so_21133717_21134503_0\"><em>\u00a71.9/15 [intro.execution]</em> Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced.</p>\n</blockquote>\n<p>However, function calls are not interleaved, so the calls to <code>operator[]</code> and <code>size</code> are actually <em>indeterminately sequenced</em>, rather than unsequenced.</p>\n<blockquote>\n<p id=\"so_21133717_21134503_1\"><em>\u00a71.9/15 [intro.execution]</em> Every evaluation in the calling function (including other function calls) that is not otherwise speci\ufb01cally sequenced before or after the execution of the body of the called function is indeterminately sequenced with respect to the execution of the called function.</p>\n</blockquote>\n<p>This means that the function calls may happen in one of two orders:</p>\n<ol>\n<li><code>operator[]</code> then <code>size</code></li>\n<li><code>size</code> then <code>operator[]</code></li>\n</ol>\n<p>If a key doesn't exist and you call <code>operator[]</code> with that key, it will be added to the map, thereby changing the size of the map. So in the first case, the key will be added, the size will be retrieved (which is 1 now), and <code>1</code> will be assigned to that key. In the second case, the size will be retrieved (which is 0), the key will be added, and <code>0</code> will be assigned to that key.</p>\n<p>Note, this is not a situation that brings about undefined behaviour. Undefined behaviour occurs when two modifications or a modification and a read of the same scalar object are unsequenced.</p>\n<blockquote>\n<p id=\"so_21133717_21134503_2\"><em>\u00a71.9/15 [intro.execution]</em> If a side e\ufb00ect on a scalar object is unsequenced relative to either another side e\ufb00ect on the same scalar object or a value computation using the value of the same scalar object, the behavior is unde\ufb01ned.</p>\n</blockquote>\n<p>In this situation, they are not unsequenced but indeterminately sequenced.</p>\n<p>So what we do have is two equally valid orderings of the execution of the program. Either could happen and both give valid output. This is <em>unspecified behaviour</em>.</p>\n<blockquote>\n<p id=\"so_21133717_21134503_3\"><em>\u00a71.3.25 [defns.unspecified]</em><br>\n<strong>unspeci\ufb01ed behavior</strong><br>\n  behavior, for a well-formed program construct and correct data, that depends on the implementation</br></br></p>\n</blockquote>\n<hr>\n<p>So to answer your questions:</p>\n<blockquote>\n<p id=\"so_21133717_21134503_4\">Which compiler is right?</p>\n</blockquote>\n<p>Both of them are.</p>\n<blockquote>\n<p id=\"so_21133717_21134503_5\">Am I doing something wrong?</p>\n</blockquote>\n<p>Probably. It's unlikely that you would want to write code that has two execution paths like this. Unspecified behaviour can be okay, unlike undefined behaviour, because it can be resolved to a single observable output, but it's not worth having in the first place if you can avoid it. Instead, don't write code that has this kind of ambiguity. Depending on what exactly you want correct path to be, you can do either of the following:</p>\n<pre><code>auto size = a.size();\na[1] = size; // value is 0\n</code></pre>\n<p>Or:</p>\n<pre><code>a[1];\na[1] = a.size(); // value is 1\n</code></pre>\n<p>If you want the result to be <code>1</code> and you know the key doesn't yet exist, you could of course do the first code but assign <code>size + 1</code>.</p>\n</hr>", "LastEditorUserId": "150634", "LastActivityDate": "2014-01-26T23:48:42.440", "Score": "77", "CreationDate": "2014-01-15T10:10:07.940", "ParentId": "21133717", "CommentCount": "1", "OwnerUserId": "150634", "LastEditDate": "2014-01-26T23:48:42.440"}, "21134247": {"Id": "21134247", "PostTypeId": "2", "Body": "<p>In this case, where <code>a[1]</code> returns a primitive type, please refer to <a href=\"https://stackoverflow.com/a/21134503/493122\">this answer</a>. In the case in which the <code>std::map</code>'s value type is an user defined type and <code>operator=(T, std::size_t)</code> is defined for that type, the expression:</p>\n<pre><code>a[1] = a.size();\n</code></pre>\n<p>can be converted to the corresponding less-syntactic-sugar version:</p>\n<pre><code>a[1] = a.size();\na.operator[](1) = a.size();\noperator=(a.operator[](1), a.size());\n</code></pre>\n<p>And, as we all know from the \u00a78.3.6/9:</p>\n<blockquote>\n<p id=\"so_21133717_21134247_0\">The order of evaluation of function arguments is unspecified.</p>\n</blockquote>\n<p>which leads to the fact that the result of the above expression is <em>unspecified</em>. </p>\n<p>We have, of course, two cases:</p>\n<ul>\n<li>If the <code>a.operator[](1)</code> is evaluated first, the size of the map is incremented by 1 leading to the first output (<code>first 1 second 1</code>). </li>\n<li>If the <code>a.size()</code> is evaluated first, the output you'll get is the second one (<code>first 1 second 0</code>).</li>\n</ul>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-01-15T10:45:10.833", "Score": "15", "CreationDate": "2014-01-15T10:00:07.770", "ParentId": "21133717", "CommentCount": "3", "OwnerUserId": "493122", "LastEditDate": "2017-05-23T12:00:17.993"}});