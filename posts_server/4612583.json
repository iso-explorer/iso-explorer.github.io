post_cb({"4612606": {"Id": "4612606", "PostTypeId": "2", "Body": "<p>Do this,</p>\n<pre><code>virtual ~foo()\n{\n   //your code\n}\n</code></pre>\n<p>This ensures that doing <code>delete *pFoo</code> also invokes derived classes destructor (<code>~bar()</code>). The order of invocation would be <code>~bar()</code> followed by <code>~foo()</code>.</p>\n<hr>\n<p>It will also be good if you do the same for <code>~bar()</code> also, that is,</p>\n<pre><code>virtual ~bar()\n{\n   //your code\n}\n</code></pre>\n<p>Although it's not that much necessary for this scenario if you don't want to further derive from <code>bar</code> and want to use <code>bar*</code> for it's derived classes.</p>\n</hr>", "LastEditorUserId": "415784", "LastActivityDate": "2011-01-06T07:11:06.363", "Score": "0", "CreationDate": "2011-01-06T07:02:55.630", "ParentId": "4612583", "CommentCount": "4", "LastEditDate": "2011-01-06T07:11:06.363", "OwnerUserId": "415784"}, "4612680": {"Id": "4612680", "PostTypeId": "2", "Body": "<p>It is actually an undefined behavior.</p>\n<p>From Standard docs. <em>5.3.5.3 Delete</em>,</p>\n<blockquote>\n<p id=\"so_4612583_4612680_0\">In the first alternative (delete object), <strong>if the static type of the operand is different from its dynamic type,</strong> the static type\n  shall be a base class of the operand\u2019s dynamic type and <strong>the static type shall have a virtual destructor or the behavior is\n  undefined.</strong> ......</p>\n</blockquote>\n", "LastActivityDate": "2011-01-06T07:15:02.883", "Score": "3", "CreationDate": "2011-01-06T07:15:02.883", "ParentId": "4612583", "CommentCount": "4", "OwnerUserId": "249490"}, "4612583": {"ViewCount": "846", "Body": "<p>I understand that derived class is type compatible with a pointer to its base class. In the given sample code, <code>new bar</code> object construction takes place calling <code>foo::foo()</code> followed by <code>bar::bar()</code>. In the respective constructors, I am allocating resources to class members <code>foo::int *a</code> and <code>bar::int *b</code>. </p>\n<p>Now I am initializing thus constructed object to base class type. With <code>obj</code>, I can call the base class destructor but not the derived class destructor. So, how can I deallocate the derived class resources in this case? Is this not a memory leak ?  </p>\n<pre><code>#include &lt;iostream&gt;\nclass foo\n{\n    int *a;\npublic:\n    foo()\n    {\n        a = new int[5];\n        std::cout &lt;&lt; \"\\n foo constructor\" &lt;&lt; std::endl;\n    }\n    ~foo()\n    {\n        std::cout &lt;&lt; \"\\n foo destructor\" &lt;&lt; std::endl;\n        delete[] a;\n    }\n};\n\nclass bar : public foo\n{\n    int *b;\npublic:\n    bar()\n    {\n        b = new int[5];\n        std::cout &lt;&lt; \"\\n bar constructor\" &lt;&lt; std::endl;\n    }\n    ~bar()\n    {\n        std::cout &lt;&lt; \"\\n bar destructor\" &lt;&lt; std::endl;\n        delete[] b;\n    }\n};\n\nint main()\n{\n    foo *obj = new bar; // Derived class object is type compatible with base class\n\n    delete obj; // Equivalent to obj-&gt;~foo();\n    return 0;\n}\n</code></pre>\n<p>Thanks.</p>\n", "AcceptedAnswerId": "4612611", "Title": "Will Derived class type compatibility to base class cause a memory leak?", "CreationDate": "2011-01-06T06:59:26.640", "Id": "4612583", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2011-01-06T07:15:02.883", "Score": "1", "OwnerUserId": "528724", "Tags": "<c++><constructor><destructor>", "AnswerCount": "4"}, "4612595": {"Id": "4612595", "PostTypeId": "2", "Body": "<p>If you <code>delete</code> a derived class object via a pointer to one of its base classes, the base class destructor <strong>must</strong> be declared <code>virtual</code>, otherwise the behavior is undefined.  </p>\n<p>If <code>~foo()</code> is declared <code>virtual</code>, you're good to go.  <code>~bar()</code> will be called first, then <code>~foo()</code>.</p>\n", "LastActivityDate": "2011-01-06T07:01:17.330", "Score": "3", "CreationDate": "2011-01-06T07:01:17.330", "ParentId": "4612583", "CommentCount": "8", "OwnerUserId": "151292"}, "bq_ids": {"n4140": {"so_4612583_4612680_0": {"length": 23, "quality": 0.92, "section_id": 6107}}, "n3337": {"so_4612583_4612680_0": {"length": 23, "quality": 0.92, "section_id": 5873}}, "n4659": {"so_4612583_4612680_0": {"length": 23, "quality": 0.92, "section_id": 7604}}}, "4612611": {"Id": "4612611", "PostTypeId": "2", "Body": "<p>This is where the idea of the \"virtual destructor\" comes in.  Technically speaking, if you delete an object through a pointer of a base class type, you must mark that base class destructor virtual or the result is undefined.  If you do mark the destructor virtual, the meaning is different from other virtual functions.  Instead of meaning \"derived classes override this behavior,\" it means \"when deleting this object through a base class pointer, call the derived destructors before calling the base constructor.\"  This is the behavior you want.</p>\n<p>As a general rule, any class you define that you plan on subclassing should have a virtual destructor to prevent this sort of problem.</p>\n", "LastActivityDate": "2011-01-06T07:03:47.743", "Score": "4", "CreationDate": "2011-01-06T07:03:47.743", "ParentId": "4612583", "CommentCount": "0", "OwnerUserId": "501557"}});