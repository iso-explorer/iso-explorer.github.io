post_cb({"2614478": {"ParentId": "2614392", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>C++0x standard draft has in 5.2.9/13:</p>\n<blockquote>\n<p id=\"so_2614392_2614478_0\">An rvalue of type \u201cpointer to cv1\n  void\u201d can be converted to an rvalue of\n  type \u201cpointer to cv2 T,\u201d where T is an\n  object type and cv2 is the same\n  cv-qualification as, or greater\n  cv-qualification than, cv1. The null\n  pointer value is converted to the null\n  pointer value of the destination type.\n  A value of type pointer to object\n  converted to \u201cpointer to cv void\u201d and\n  back, possibly with different\n  cv-qualification, shall have its\n  original value.</p>\n</blockquote>\n<p>But also note that the cast doesn't necessarily result in a valid object:</p>\n<pre><code> std::string* p = static_cast&lt;std::string*&gt;(malloc(sizeof(*p)));\n //*p not a valid object \n</code></pre>\n", "OwnerUserId": "155693", "CommunityOwnedDate": "2010-04-10T18:38:29.647", "Id": "2614478", "Score": "3", "CreationDate": "2010-04-10T18:38:29.647", "LastActivityDate": "2010-04-10T18:38:29.647"}, "8490744": {"ParentId": "2614392", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_2614392_8490744_0\">Throughout the standard there is a bunch of references to the representation of a pointer, and <strong>the representation of a void pointer being the same as that of a char pointer</strong>,</p>\n</blockquote>\n<p>Yes, indeed.</p>\n<blockquote>\n<p id=\"so_2614392_8490744_1\">So while malloc clearly returns the address of suitable memory and so on, there does not seem to be any way to actually make use of it, portably, as far as I have seen.</p>\n</blockquote>\n<p>Of course there is:</p>\n<pre>\nvoid *vp = malloc (1);\nchar *cp;\nmemcpy (&amp;cp;, &amp;vb;, sizeof cp);\n*cp = ' ';\n</pre>\n<p>There is one tiny problem : it does not work for any other type. :(</p>\n", "OwnerUserId": "963864", "CommunityOwnedDate": "2011-12-13T14:20:29.387", "Id": "8490744", "Score": "1", "CreationDate": "2011-12-13T14:20:29.387", "LastActivityDate": "2011-12-13T14:20:29.387"}, "2614392": {"CommentCount": "5", "ViewCount": "1291", "PostTypeId": "1", "CommunityOwnedDate": "2010-04-10T18:15:57.217", "LastEditorUserId": "963864", "CreationDate": "2010-04-10T18:15:57.217", "LastActivityDate": "2011-12-13T14:20:29.387", "LastEditDate": "2011-12-13T06:00:31.720", "FavoriteCount": "3", "Title": "What wording in the C++ standard allows static_cast<non-void-type*>(malloc(N)); to work?", "Id": "2614392", "Score": "7", "Body": "<p>As far as I understand the wording in 5.2.9 Static cast, the only time the result of a <code>void*</code>-to-object-pointer conversion is allowed is when the <code>void*</code> was a result of the inverse conversion in the first place. </p>\n<p>Throughout the standard there is a bunch of references to the representation of a pointer, and the representation of a <code>void</code> pointer being the same as that of a <code>char</code> pointer, and so on, but it never seems to explicitly say that casting an arbitrary <code>void</code> pointer yields a pointer to the same location in memory, with a different type, much like type-punning is undefined where not punning back to an object's actual type.</p>\n<p>So while <code>malloc</code> clearly returns the address of suitable memory and so on, there does not seem to be any way to actually make use of it, portably, as far as I have seen.</p>\n", "Tags": "<c++><undefined-behavior><language-lawyer><reinterpret-cast>", "OwnerUserId": "4607", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_2614392_2614478_0": {"section_id": 6039, "quality": 0.8478260869565217, "length": 39}}, "n3337": {"so_2614392_2614478_0": {"section_id": 5807, "quality": 0.8478260869565217, "length": 39}}, "n4659": {"so_2614392_2614478_0": {"section_id": 7536, "quality": 0.5217391304347826, "length": 24}}}, "4726190": {"ParentId": "2614392", "PostTypeId": "2", "CommentCount": "0", "Body": "<h3>C++03, \u00a720.4.6p2</h3>\n<blockquote>\n<p id=\"so_2614392_4726190_0\">The contents are the same as the Standard C library header &lt;stdlib.h&gt;, with the following changes: [list of changes that don't apply here]</p>\n</blockquote>\n<h3>C99, \u00a77.20.3.3p2-3</h3>\n<p>(Though C++03 is based on C89, I only have C99 to quote.  However, I believe this section is semantically unchanged.  \u00a77.20.3p1 may also be useful.)</p>\n<blockquote>\n<p id=\"so_2614392_4726190_1\">The malloc function allocates space for an object whose size is specified by size and\n  whose value is indeterminate.</p>\n<p id=\"so_2614392_4726190_2\">The malloc function returns either a null pointer or a pointer to the allocated space.</p>\n</blockquote>\n<p>From these two quotes, malloc allocates an uninitialized object and returns a pointer to it, or returns a null pointer.  A pointer to an object which you have as a void pointer can be converted to a pointer to that object (first sentence of C++03 \u00a75.2.9p13, mentioned in the previous answer).</p>\n<hr>\n<p>This should be less \"handwaving\", which you complained of, but someone might argue I'm \"interpreting\" C's definition of malloc as I wish, by, for example, noticing C says \"to the allocated space\" rather than \"to the allocated object\".  To those people: first realize that \"space\" and \"object\" are synonyms in C, and second please file a defect report with the standard committees, because not even I am pedantic enough to continue. :)</p>\n<p>I'll give you the benefit of the doubt and believe you got tripped up in the cross-references, cross-interpretation, and sometimes-confused integration between the standards, rather than \"space\" vs \"object\".</p>\n</hr>", "OwnerUserId": "511601", "CommunityOwnedDate": "2011-01-18T16:04:26.163", "Id": "4726190", "Score": "2", "CreationDate": "2011-01-18T16:04:26.163", "LastActivityDate": "2011-01-18T16:04:26.163"}});