post_cb({"35698336": {"ParentId": "35696235", "CommentCount": "1", "CreationDate": "2016-02-29T11:26:06.353", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "35698336", "Score": "2", "Body": "<blockquote>\n<p id=\"so_35696235_35698336_0\">However, I've come to learn that one shouldn't pass list by value, cause it's costly.</p>\n</blockquote>\n<p>That's not entirely accurate. If you need to pass in a list that the function can modify, where the modifications shouldn't be externally visible, you <em>do</em> want to pass a list by value. This gives the caller the ability to choose whether to copy or move from an existing list, so gives you the most reasonable flexibility.</p>\n<p>If the modifications <em>should</em> be externally visible, you <em>should</em> prevent temporary list objects from being passed in, since passing in a temporary list object would prevent the caller from being able to see the changes made to the list. The flexibility to silently pass in temporary objects is the flexibility to shoot yourself in the foot. Don't make it too flexible.</p>\n<p>If you need to pass in a list that the function will not modify, then <code>const std::list&lt;T&gt; &amp;</code> is the type to use. This allows either lvalues or rvalues to be passed in. Since there won't be any update to the list, there is no need for the caller to see any update to the list, and there is no problem passing in temporary list objects. This again gives the caller the most reasonable flexibility.</p>\n<blockquote>\n<p id=\"so_35696235_35698336_1\">Is the \"you shall not pass an costly object by value\" rule valid here? We aren't passing a list after all, but an initializer_list, no?</p>\n</blockquote>\n<p>You're constructing a <code>std::list</code> from an initializer list. You're not copying that <code>std::list</code> object, but you are copying the list items from the initializer list to the <code>std::list</code>. If the copying of the list items is cheap, you don't need to worry about it. If the copying of the list items is expensive, then it should be up to the caller to construct the list in some other way, it still doesn't need to be something to worry about inside your function.</p>\n<blockquote>\n<p id=\"so_35696235_35698336_2\">If the rule still applies, what's the easy fix here?</p>\n</blockquote>\n<p>Both passing <code>std::list</code> by value or by <code>const &amp;</code> allow the caller to avoid pointless copies. Which of those you should use depends on the results you want to achieve, as explained above.</p>\n<blockquote>\n<p id=\"so_35696235_35698336_3\">Is list generated on the spot and then passed by value? If not, what is it that actually happens?</p>\n</blockquote>\n<p>Passing the list by value constructs a new <code>std::list</code> object in the location of the function parameter, using the function argument to specify how to construct it. This may or may not involve a copy or a move of an existing <code>std::list</code> object, depending on what the caller specifies as the function argument.</p>\n", "LastActivityDate": "2016-02-29T11:26:06.353"}, "35696802": {"ParentId": "35696235", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2016-02-29T10:09:39.717", "Score": "0", "LastEditorUserId": "2081434", "LastEditDate": "2016-02-29T12:46:14.867", "Id": "35696802", "OwnerUserId": "4175394", "Body": "<ol>\n<li><p>You can have <code>std::list&lt;&gt;</code> because in fact you're making temporary list and passing <code>initializer_list</code> by value is cheap. Also accessing that list later can be faster than a reference because you avoid dereferencing.</p></li>\n<li><p>You could hack it by having <code>const&amp; std::list</code> as parameter or like that </p>\n<pre><code>void foo( std::list&lt;int&gt; &amp;list ) {}\n\nint main() {\n    std::list&lt;int&gt; list{1,2,3};\n\n    foo( list );\n}\n</code></pre></li>\n<li><p>List is created on function scope and this constructor is called</p>\n<pre><code>list (initializer_list&lt;value_type&gt; il,\n      const allocator_type&amp; alloc = allocator_type())\n</code></pre></li>\n</ol>\n<p>So there's no passing list by value. But if you'll use that function and pass list as parameter it'll be passed by value.</p>\n", "LastActivityDate": "2016-02-29T12:46:14.867"}, "35697168": {"ParentId": "35696235", "CommentCount": "1", "CreationDate": "2016-02-29T10:26:15.043", "OwnerUserId": "3202093", "PostTypeId": "2", "Id": "35697168", "Score": "0", "Body": "<p>The expression <code>{10, 21, 30}</code> will construct a <code>initializer_list&lt;int&gt;</code> <br>\nThis in turn will be used to create a <code>list&lt;int&gt;</code> <br>\nThat list will be a <em>temporary</em> and a temporarys will not bind to a <br>\nnon-const reference. </br></br></br></p>\n<p>One fix would be to change the prototype for you function to <br>\n<code>fn(const std::list&lt;int&gt;&amp;)</code></br></p>\n<p>This means that you can't edit it inside the function, and you probably don't need to.<br>\nHowever, if you must edit the parameter inside the function, taking it by value would be appropriate.</br></p>\n<p>Also note, don't optimize prematurely, you should always use idiomatic\nconstructs that clearly represents what you want do do, and for functions,\nthat almost always means parameters by <code>const&amp;</code> and return by value.</p>\n<p>This is easy to use right, hard to use wrong, and almost always fast enough.</p>\n<p>Optimization should only be done after profiling, and only for the parts of the program that you have measured to need it. </p>\n", "LastActivityDate": "2016-02-29T10:26:15.043"}, "35696235": {"CommentCount": "12", "ViewCount": "553", "CreationDate": "2016-02-29T09:42:52.363", "LastActivityDate": "2016-02-29T12:46:14.867", "Title": "Is it costly to pass an initializer_list as a list by value?", "FavoriteCount": "1", "PostTypeId": "1", "Id": "35696235", "Score": "2", "Body": "<p>I want to pass a <code>std::list</code> as a parameter to <code>fn(std::list&lt;int&gt;)</code>, so I do <code>fn({10, 21, 30})</code> and everybody is happy.</p>\n<p>However, I've come to learn that one shouldn't pass list by value, cause it's costly. So, I redefine my fn as <code>fn(std::list&lt;int&gt; &amp;)</code>. Now, when I do the call <code>fn({10, 21, 30})</code>, I get an error:  <code>candidate function not viable: cannot convert initializer list argument to 'std::list&lt;int&gt; &amp;'</code>.</p>\n<p><strong>QUESTION TIME</strong></p>\n<ol>\n<li>Is the \"you shall not pass an costly object by value\" rule valid here? We aren't passing a <code>list</code> after all, but an <code>initializer_list</code>, no?</li>\n<li>If the rule still applies, what's the easy fix here?</li>\n</ol>\n<p>I guess my doubt comes from the fact that I don't know clearly what happens when one passes an <code>initializer_list</code> argument to a function that accepts a <code>list</code>. </p>\n<ol start=\"3\">\n<li>Is <code>list</code> generated on the spot and then passed by value? If not, what is it that actually happens?</li>\n</ol>\n", "Tags": "<c++><list><c++11><stl><initializer-list>", "OwnerUserId": "2081434", "AnswerCount": "6"}, "35697201": {"ParentId": "35696235", "CommentCount": "2", "CreationDate": "2016-02-29T10:27:52.190", "OwnerUserId": "1621391", "PostTypeId": "2", "Id": "35697201", "Score": "0", "Body": "<p>Quoting the C++14 standard draft, (emphasis are mine)</p>\n<blockquote>\n<p id=\"so_35696235_35697201_0\"><strong>18.9 Initializer lists [support.initlist]</strong></p>\n<p id=\"so_35696235_35697201_1\"><strong>2:</strong> An object of type initializer_list provides access to an array of\n  objects of type const E. [ Note: A pair of pointers or a pointer plus\n  a length would be obvious representations for initializer_list.\n  initializer_list is used to implement initializer lists as specified\n  in 8.5.4. <strong>Copying an initializer list does not copy the underlying\n  elements.</strong> \u2014end note ]</p>\n</blockquote>\n<p><code>std::list</code> has a constructor which is used to construct from <code>std::initializer_list</code>. As you can see, it takes it by value.</p>\n<pre><code>list(initializer_list&lt;T&gt;, const Allocator&amp; = Allocator());\n</code></pre>\n<p>If you are never going to modify your parameter, then <code>fn(const std::list&lt;int&gt;&amp;)</code> will do just fine. Otherwise, <code>fn(std::list&lt;int&gt;)</code> will suffice well for.</p>\n<p>To answer your questions:</p>\n<blockquote>\n<p id=\"so_35696235_35697201_2\">Is the \"you shall not pass an costly object by value\" rule valid here?\n  We aren't passing a list after all, but an initializer_list, no?</p>\n</blockquote>\n<p><code>std::initializer_list</code> is not a <em>costly</em> object. But <strong><code>std::list&lt;int&gt;</code></strong> surely sounds like a costly object</p>\n<blockquote>\n<p id=\"so_35696235_35697201_3\">If the rule still applies, what's the easy fix here?</p>\n</blockquote>\n<p>Again, it's not costly</p>\n<blockquote>\n<p id=\"so_35696235_35697201_4\">Is list generated on the spot and then passed by value? If not, what is it that actually happens?</p>\n</blockquote>\n<p>Yes, it is... your <code>list</code> object is created on the <em>spot</em> at run-time right before the program enters your function scope</p>\n", "LastActivityDate": "2016-02-29T10:27:52.190"}, "35698436": {"ParentId": "35696235", "CommentCount": "0", "CreationDate": "2016-02-29T11:31:57.003", "OwnerUserId": "3005057", "PostTypeId": "2", "Id": "35698436", "Score": "0", "Body": "<p>Like the other answers and comments you can use a const reference to the list.  </p>\n<pre><code>void fn(const std::list&lt;int&gt;&amp; l)\n{\n    for (auto it = l.begin(); it != l.end(); ++it)\n    {\n        *it; //do something\n    }\n}\n</code></pre>\n<p>If this <code>fn</code> function is heavily used and you are worried about the overhead of constructing and destructing the temporary list object, you can create a second function that receives the <code>initializer_list</code> directly that doesn't involve any copying whatsoever. Using a profiler to catch such a performance hot spot is not trivial in many cases.</p>\n<pre><code>void fn(const std::initializer_list&lt;int&gt;&amp; l)\n{\n    for (auto it = l.begin(); it != l.end(); ++it)\n    {\n        *it; //do something\n    }\n}\n</code></pre>\n", "LastActivityDate": "2016-02-29T11:31:57.003"}, "35697606": {"ParentId": "35696235", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2016-02-29T10:47:41.993", "Score": "0", "LastEditorUserId": "5866175", "LastEditDate": "2016-02-29T11:06:52.493", "Id": "35697606", "OwnerUserId": "5866175", "Body": "<blockquote>\n<p id=\"so_35696235_35697606_0\">However, I've come to learn that one shouldn't pass list by value, cause it's costly. So, I redefine my fn as fn(std::list &amp;). <strong>Now, when I do the call fn({10, 21, 30}), I get an error:  candidate function not viable: cannot convert initializer list argument to 'std::list &amp;'</strong>.</p>\n</blockquote>\n<p>A way to fix the problem would be:</p>\n<pre><code>fn(std::list&lt;int&gt;&amp; v) {\n   cout &lt;&lt; v.size();\n}\n\nfn(std::list&lt;int&gt;&amp;&amp; v) {\n    fn(v);\n}\n</code></pre>\n<p>Now <code>fn({1, 2, 3 });</code> works as well (it will call the second overloaded function that accepts a list by rvalue ref, and then <code>fn(v);</code> calls the first one that accepts lvalue references.</p>\n<pre><code>fn(std::list&lt;int&gt; v)\n{\n\n}\n</code></pre>\n<p>The problem with this function is that it can be called like:</p>\n<pre><code>list&lt;int&gt; biglist;\nfn(biglist);\n</code></pre>\n<p>And it will make a copy. And it will be slow. That's why you want to avoid it. </p>\n<p>I would give you the following solutions:</p>\n<ol>\n<li>Overloaded your fn function to accept both rvalues and lvalues\nproperly as shown before.</li>\n<li>Only use the second function (the one that accepts only rvalue\nreferences). The problem with this approach is that will throw a compile error even if it's called with a lvalue reference, which is something you want to allow.</li>\n</ol>\n", "LastActivityDate": "2016-02-29T11:06:52.493"}, "bq_ids": {"n4140": {"so_35696235_35697201_1": {"section_id": 6955, "quality": 0.8529411764705882, "length": 29}}, "n3337": {"so_35696235_35697201_1": {"section_id": 6702, "quality": 0.8529411764705882, "length": 29}}, "n4659": {"so_35696235_35697201_1": {"section_id": 8452, "quality": 0.8529411764705882, "length": 29}}}});