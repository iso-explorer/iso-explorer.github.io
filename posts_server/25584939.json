post_cb({"25585130": {"ParentId": "25584939", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Your code is invalid, because you are trying to override <code>Matrix::iterator Matrix::begin()</code> with <code>RegMatrix::iterator RegMatrix::begin()</code>; the return types are different. This is only allowed if the return types are \"covariant\":</p>\n<blockquote>\n<p id=\"so_25584939_25585130_0\"><strong>\u00a7 10.3.7</strong></p>\n<p id=\"so_25584939_25585130_1\">The return type of an overriding function shall be either identical to\n  the return type of the overridden function or covariant with the\n  classes of the functions. If a function D::f overrides a function\n  B::f, the return types of the functions are covariant if they satisfy\n  the following criteria:</p>\n<ul>\n<li>both are pointers to classes, both are lvalue references to classes, or both are rvalue references to classes</li>\n<li>the class in the return type of B::f is the same class as the class in the return type of D::f, or is an unambiguous and accessible direct\n  or indirect base class of the class in the return type of D::f</li>\n<li>both pointers or references have the same cv-qualification and the class type in the return type of D::f has the same cv-qualification as\n  or less cv-qualification than the class type in the return type of\n  B::f.</li>\n</ul>\n</blockquote>\n<p>Because your return types are neither pointers nor references, they cannot be covariant.</p>\n<p>You could use the Pimpl idiom to fix your design; it allows having one single iterator type that is able to iterate across different container types by injecting a concrete implementation.</p>\n<p>Here is a stripped down example to show the basic concept:</p>\n<pre><code>#include &lt;memory&gt;\n\nclass Matrix\n{\npublic:\n    class iterator\n    {\n    public:\n        // this is the interface for the implementation the iterator is using\n        struct impl\n        {\n            virtual ~impl() {}\n            virtual double dereference() const = 0;\n            // [...]\n        };\n\n        // the constructor takes a implementation\n        iterator(std::unique_ptr&lt;impl&gt; impl)\n            : m_impl{std::move(impl)}\n        {\n        }\n\n        double operator*() const\n        {\n            // all calls are referred to the concrete implementation\n            return m_impl-&gt;dereference();\n        }\n\n        // [...]\n\n    private:\n        std::unique_ptr&lt;impl&gt; m_impl;\n    };\n\n    virtual iterator begin() = 0;\n    virtual iterator end() = 0;\n};\n\nclass RegMatrix : public Matrix\n{\n    // every Matrix has its own iterator implementation\n    class iterator_impl : public Matrix::iterator::impl \n    {\n    public:\n        iterator_impl(Vector2D::iterator itr)\n            : m_itr{itr}\n        {\n        }\n\n        virtual double dereference() const override\n        {\n            return *m_itr;\n        }\n        // [...]\n\n    private:\n        Vector2D::iterator m_itr;\n    };\n\n    virtual iterator begin() override\n    {\n        // return a iterator that holds our iterator implementation\n        return iterator(std::unique_ptr&lt;iterator_impl&gt;{new iterator_impl{matrix.begin()}});\n    }\n\n    virtual iterator end() override\n    {\n        return iterator(std::unique_ptr&lt;iterator_impl&gt;{new iterator_impl{matrix.end()}});\n    }\n\nprivate:\n    Vector2D matrix;\n};\n</code></pre>\n<p>This should be able to solve your problem, but it also has drawbacks: Every iterator construction induces a heap allocation, and every iterator operation leads to a virtual method call. This could become a performance issue in critical situations, especially because iterators are intended to be lightweight objects.</p>\n", "OwnerUserId": "3989746", "LastEditorUserId": "3989746", "LastEditDate": "2014-08-31T11:25:14.953", "Id": "25585130", "Score": "0", "CreationDate": "2014-08-30T17:40:39.247", "LastActivityDate": "2014-08-31T11:25:14.953"}, "25585119": {"ParentId": "25584939", "CommentCount": "0", "Body": "<p>Covariant return types are only allowed when returning a pointer or a reference (to a base and derived class correspondingly) - not when returning by value.</p>\n<p>Think about it - the caller needs to know how much memory to reserve for storing the return value. But <code>sizeof(RegMatrix::iterator) &gt; sizeof(Matrix::iterator)</code>. How is the caller that only has <code>Matrix*</code> pointer in hand supposed to know which of them <code>begin()</code> call will return?</p>\n", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "25585119", "Score": "0", "CreationDate": "2014-08-30T17:38:59.790", "LastActivityDate": "2014-08-30T17:38:59.790"}, "25584939": {"CommentCount": "3", "ViewCount": "184", "PostTypeId": "1", "LastEditorUserId": "2630165", "CreationDate": "2014-08-30T17:15:35.697", "LastActivityDate": "2014-08-31T11:25:14.953", "Title": "'invalid covariant return type' error in nested iterators and inteface", "LastEditDate": "2014-08-31T07:39:59.820", "Id": "25584939", "Score": "0", "Body": "<p>I'm trying to make an interface called Matrix. Two classes will implement this interface.\nOne of them is called RegMatrix (Regular Matrix).\nNow, I'm trying to build iterators for the classes RegMatrix and OthMatrix, and let the user to be able to iterate over a 'Matrix' object.\nThe problem is that i'm getting an error \"invalid covariant return type for 'virtual RegMatrix::iterator RegMatrix::begin()'\" for the methods begin() and end(), probably because one of them returns a RegMatrix::iterator , and the base one returns Matrix::iterator. I don't understand what is actually wrong in this. Does anybody know how to fix this issue ?\nThanks.</p>\n<p>Edit:\ni understand from your current answers my design is invalid. So, can anybody suggest a better design/solution for my problem? iterating over a 'Matrix' that could be either an insance of 'RegMatrix' (implemented with a Map to hold data) or an instance of a 'OthMatrix' (implemented with a Vector). those two has different iterators and i want a Wrapper iterator to wrap these two so the kind of instance will be transparent to the user when iterating. thanks.</p>\n<p>Class Matrix (The interface) :</p>\n<pre><code>class Matrix\n{\npublic:\n    class iterator\n    {\n    public:\n        virtual iterator&amp; operator=(const iterator &amp;other);\n        virtual ~iterator(){}\n        double operator*() const;\n        bool operator==(const iterator &amp;other) const;\n        bool operator!=(const iterator &amp;other) const;\n        iterator &amp;operator++();\n        iterator &amp;operator++(int);\n    };\n\n    virtual iterator begin() = 0;  //*** ERROR : overriding 'virtual Matrix::iterator Matrix::begin()' ***\n    virtual iterator end() = 0;   //*** ERROR : overriding 'virtual Matrix::iterator Matrix::end()' ***\n\n};\n</code></pre>\n<p>Class Regular matrix :</p>\n<pre><code>class RegMatrix : public Matrix\n{\npublic:\n    RegMatrix() {//TODO };\n\n    class iterator : public Matrix::iterator{\n\n          friend class RegMatrix;\n\n      public:\n\n        iterator&amp; operator=(const iterator &amp;other) {\n           //TODO\n        }\n\n        ~iterator() {}\n\n        double operator*() const {\n          //TODO\n        }\n\n\n        bool operator==(const iterator &amp;other) const {\n            //TODO\n        }\n\n        bool operator!=(const iterator &amp;other) const {\n          //TODO\n        }\n\n        iterator &amp;operator++() {\n            //TODO\n        }\n\n        iterator &amp;operator++(int)\n        {\n            //TODO\n        }\n\n      iterator(Vector2D::iterator place)\n      {\n          rowIter = place;\n      }\n      private:\n            Vector2D::iterator rowIter;\n            Vector::iterator colIter;\n\n      };\n\n      iterator begin() {  //*** ERROR : invalid covariant return type for 'virtual RegMatrix::iterator RegMatrix::begin()' *** //\n        return iterator(matrix.begin());\n      }\n\n      iterator end() {  //*** ERROR : invalid covariant return type for 'virtual RegMatrix::iterator RegMatrix::end()' *** //\n            return iterator(matrix.end());\n      }\n\nprivate:\n    Vector2D matrix;\n};\n</code></pre>\n", "Tags": "<c++><iterator><nested>", "OwnerUserId": "2630165", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_25584939_25585130_1": {"section_id": 7008, "quality": 0.92, "length": 23}}, "n3337": {"so_25584939_25585130_1": {"section_id": 6754, "quality": 0.92, "length": 23}}, "n4659": {"so_25584939_25585130_1": {"section_id": 8505, "quality": 0.92, "length": 23}}}});