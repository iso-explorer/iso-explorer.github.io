post_cb({"bq_ids": {"n4140": {"so_11019615_11020907_1": {"length": 27, "quality": 0.8709677419354839, "section_id": 719}, "so_11019615_11020907_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 718}}, "n3337": {"so_11019615_11020907_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 707}, "so_11019615_11020907_1": {"length": 27, "quality": 0.8709677419354839, "section_id": 708}}, "n4659": {"so_11019615_11020907_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 749}, "so_11019615_11020907_1": {"length": 27, "quality": 0.8709677419354839, "section_id": 750}}}, "11019615": {"ViewCount": "515", "Body": "<p>I am working on a C++ port of a Java library. One of the problems is I am not able to find equivalent of Java's AtomicLongArray. Anyone knows if there is anything already equivalent in c++ 11 or how to implement similar functionality? I had a look at C++11 atomics but could not find anything.    </p>\n", "AcceptedAnswerId": "11019670", "Title": "c++ 11 equivalent of java atomiclongarray", "CreationDate": "2012-06-13T16:51:21.637", "Id": "11019615", "CommentCount": "1", "LastEditDate": "2012-06-13T17:31:14.000", "PostTypeId": "1", "LastEditorUserId": "197788", "LastActivityDate": "2012-06-13T21:31:40.037", "Score": "1", "OwnerUserId": "894688", "Tags": "<java><c++><multithreading><c++11><atomic>", "AnswerCount": "2"}, "11019670": {"Id": "11019670", "PostTypeId": "2", "Body": "<p>The docs for <a href=\"http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicLongArray.html\" rel=\"noreferrer\">AtomicLongArray</a> say:</p>\n<blockquote>\n<p id=\"so_11019615_11019670_0\">A long array in which elements may be updated atomically. See the <code>java.util.concurrent.atomic</code> package specification for description of the properties of atomic variables.</p>\n</blockquote>\n<p>That sounds to me like a simple array of <code>std::atomic&lt;long&gt;</code>:</p>\n<pre><code>std::array&lt;std::atomic&lt;long&gt;, N&gt; array;\n// or, if size is not known at compile time\nstd::vector&lt;std::atomic&lt;long&gt;&gt; vector(n);\n</code></pre>\n<p>Note that only the elements are atomic, the container itself isn't, so don't go around <code>push_back</code>ing into the vector.</p>\n", "LastActivityDate": "2012-06-13T16:54:37.183", "CommentCount": "4", "CreationDate": "2012-06-13T16:54:37.183", "ParentId": "11019615", "Score": "8", "OwnerUserId": "46642"}, "11020907": {"Id": "11020907", "PostTypeId": "2", "Body": "<p>In [container.requirements.dataraces] the standard says</p>\n<blockquote>\n<p id=\"so_11019615_11020907_0\">-2- Notwithstanding (17.6.5.9), implementations are required to avoid data races when the contents of the contained object in different elements in the same sequence, excepting <code>vector&lt;bool&gt;</code>, are modified concurrently.</p>\n<p id=\"so_11019615_11020907_1\">-3- [ <em>Note:</em> For a <code>vector&lt;int&gt; x</code> with a size greater than one, <code>x[1] = 5</code> and <code>*x.begin() = 10</code> can be executed concurrently without a data race, but <code>x[0] = 5</code> and <code>*x.begin() = 10</code> executed concurrently may result in a data race. As an exception to the general rule, for a <code>vector&lt;bool&gt; y, y[0] = true</code> may race with <code>y[1] = true</code>. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>So any container (except evil <code>vector&lt;bool&gt;</code>) allows separate elements to be updated without data races.  To also ensure updates to a single element are safe, use a container of atomic types, e.g. <code>std::vector&lt;std::atomic&lt;long&gt;&gt;</code></p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2012-06-13T21:31:40.037", "Score": "0", "CreationDate": "2012-06-13T18:15:14.247", "ParentId": "11019615", "CommentCount": "4", "OwnerUserId": "981959", "LastEditDate": "2012-06-13T21:31:40.037"}});