post_cb({"33908822": {"CommentCount": "2", "ViewCount": "177", "PostTypeId": "1", "LastEditorUserId": "1983495", "CreationDate": "2015-11-25T05:06:59.947", "LastActivityDate": "2015-11-25T07:28:36.883", "Title": "Struct definition vs struct declaration and storage generation", "FavoriteCount": "2", "LastEditDate": "2015-11-25T05:09:39.787", "Id": "33908822", "Score": "3", "Body": "<p>From <a href=\"http://www.drdobbs.com/cpp/scope-regions-in-c/240002006\" rel=\"nofollow\">Scope Regions in C++</a></p>\n<blockquote>\n<p id=\"so_33908822_33908822_0\"><strong>In C, a struct declaration never generates storage</strong>, so C doesn't\n  distinguish struct definitions from other struct declarations. C++\n  does. In C++, a struct declaration is also a definition if it has a\n  body, as in:</p>\n<pre><code>struct widget   // a definition\n    {\n    ...\n    };\n</code></pre>\n<p id=\"so_33908822_33908822_1\">It's only a declaration if it lacks a body, as in:</p>\n<p id=\"so_33908822_33908822_2\"><code>struct widget;  // just a declaration</code></p>\n</blockquote>\n<p>So in which cases does <code>struct</code> declaration generates storage in c++?</p>\n", "Tags": "<c++><c><struct><declaration>", "OwnerUserId": "5455629", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_33908822_33910325_4": {"section_id": 5907, "quality": 0.75, "length": 12}, "so_33908822_33910325_6": {"section_id": 5907, "quality": 0.8, "length": 12}, "so_33908822_33910325_5": {"section_id": 5907, "quality": 0.75, "length": 9}, "so_33908822_33910578_0": {"section_id": 7034, "quality": 0.8333333333333334, "length": 5}, "so_33908822_33910325_3": {"section_id": 5906, "quality": 0.8823529411764706, "length": 15}}, "n3337": {"so_33908822_33910325_6": {"section_id": 5679, "quality": 0.8, "length": 12}, "so_33908822_33910325_5": {"section_id": 5679, "quality": 0.75, "length": 9}, "so_33908822_33910325_4": {"section_id": 5679, "quality": 0.75, "length": 12}, "so_33908822_33910325_3": {"section_id": 5678, "quality": 0.8823529411764706, "length": 15}, "so_33908822_33910578_0": {"section_id": 6780, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_33908822_33910325_4": {"section_id": 7389, "quality": 0.6875, "length": 11}, "so_33908822_33910325_6": {"section_id": 7389, "quality": 0.8, "length": 12}, "so_33908822_33910325_5": {"section_id": 7389, "quality": 0.75, "length": 9}, "so_33908822_33910578_0": {"section_id": 8531, "quality": 0.6666666666666666, "length": 4}, "so_33908822_33910325_3": {"section_id": 7388, "quality": 0.8823529411764706, "length": 15}}}, "33910578": {"ParentId": "33908822", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Neither case, really. The problem boils down to the article you linked being at best misleading if not incorrect. The article does not actually say that \"generating storage\" is a necessary consequence of either but it misleadingly implies it. It's poorly worded, and very imprecise, I think.</p>\n<p>Unfortunately the standards aren't very easy to read either, see section 3.1: [<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf][1]\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf][1]</a></p>\n<p>In a nutshell, for structure definitions, a declaration just introduces the type name or structure tag \"widget\". The definition is a declaration that also provides the body which \"defines\" the type, like the first example.</p>\n<p>The examples from the C++ standard are easier to understand:</p>\n<blockquote>\n<p id=\"so_33908822_33910578_0\">Example: all but one of the following are definitions:</p>\n<pre><code>int a;                       // defines a\nextern const int c = 1;      // defines c\nint f(int x) { return x+a; } // defines f and defines x\nstruct S { int a; int b; };  // defines S, S::a, and S::b\nstruct X {                   // defines X\n    int x;                   // defines non-static data member x\n    static int y;            // declares static data member y\n    X(): x(0) { }            // defines a constructor of X\n};\nint X::y = 1;                // defines X::y    \nenum { up, down };           // defines up and down\nnamespace N { int d; }       // defines N and N::d\nnamespace N1 = N;            // defines N1\nX anX;                       // defines anX\n</code></pre>\n<p id=\"so_33908822_33910578_1\">whereas these are just declarations:</p>\n<pre><code>extern int a;       // declares a\nextern const int c; // declares c\nint f(int);         // declares f\nstruct S;           // declares S\ntypedef int Int;    // declares Int\nextern X anotherX;  // declares anotherX\nusing N::d;         // declares d\n</code></pre>\n</blockquote>\n<p>You can \"define\" a structure which does nothing but define it's layout. But you can also \"define\" a variable of that structure type. That is when storage might be \"generated\" (I would maybe say allocated or reserved). When a global <em>variable</em> of the structure type is defined it would result in the binary executable containing a chunk of data the size of the structure. If a local (automatic or stack) variable is defined, it would take up space on the execution stack instead at runtime.</p>\n<p>For example, if global (i.e. not in a function):</p>\n<pre><code>struct widget x; // defines variable x of type struct widget\n                 // which must be defined somewhere prior\n\nstruct widget2; // declares structure widget2\n// does nothing except tells the compiler there will be some\n// structure definition named widget2 coming later\n\nint fn(widget2 *p); // OK widget2 need only be *declared* first\n\n// NO\n// struct widget2 y; // illegal - has not be defined yet\n\nstruct widget2 // defines structure widget2 that *would* take up ~8 bytes\n{\n    int thing1;\n    int thing2;\n} y; // defines variable y of type struct widget2 that *does* take up ~8 bytes\n\nstruct widget2 z[10]; // defines global variable z that *does* take up ~80 bytes\n</code></pre>\n<p>Maybe another way to look at it is that defining a <strong>type</strong> is fundamentally different than defining a <strong>variable</strong>. A type is a concept that exists at compile time and does not take up space at runtime (RTTI ignored).</p>\n<p>The C and C++ standards are making the distinction between declare and define because, amongst other reasons, you can not have more than one different definition of something, but you can declare it many times. For <em>variables</em>, definitions roughly coincide with storage allocation, but that isn't the main reason for the distinction.</p>\n", "OwnerUserId": "5226168", "LastEditorUserId": "5226168", "LastEditDate": "2015-11-25T07:28:36.883", "Id": "33910578", "Score": "3", "CreationDate": "2015-11-25T07:17:37.513", "LastActivityDate": "2015-11-25T07:28:36.883"}, "33910325": {"ParentId": "33908822", "CommentCount": "0", "Body": "<p>The following is my paraphrase of the above, hopefully more clear.</p>\n<blockquote>\n<p id=\"so_33908822_33910325_0\">struct declarations never generate storage, in either C or C++.</p>\n<p id=\"so_33908822_33910325_1\">Since C doesn't distinguish struct definitions from other struct declarations, struct definitions never generate storage in C, either.</p>\n<p id=\"so_33908822_33910325_2\">In C++ the definition of a struct with a static data member (<em>n.b. there is no such thing as a static data member in C</em>) does not generate storage in and by itself, but formally declares its static data member, which is then required to be defined in an enclosing scope - at which point it does in fact generate storage.</p>\n</blockquote>\n<p>In other words, the C++ definition of the struct doesn't technically generate storage, but practically can't be used unless its static data member is defined elsewhere (with the implied storage - even if no objects of that type are ever instantiated).</p>\n<p>Relevant C++ references below.</p>\n<p>- 3.1.2 Declarations and de\ufb01nitions</p>\n<pre><code>struct X { // de\ufb01nes X\n    static int y; // declares static data member y\n};\n\nint X::y = 1; // de\ufb01nes X::y\n</code></pre>\n<p>- 9.4.2 Static data members</p>\n<blockquote>\n<p id=\"so_33908822_33910325_3\">9.4.2.1 [...] A static data member is not part of the subobjects of a class. There is only one copy of a static data member shared by all the objects of the class.</p>\n<p id=\"so_33908822_33910325_4\">[...] The declaration of a static data member in its class de\ufb01nition is not a de\ufb01nition and may be of an incomplete type other than cv-quali\ufb01ed void.</p>\n<p id=\"so_33908822_33910325_5\">[...] The de\ufb01nition for a static data member shall appear in a namespace scope enclosing the member\u2019s class de\ufb01nition.</p>\n<p id=\"so_33908822_33910325_6\">[...] Note: once the static data member has been de\ufb01ned, it exists even if no objects of its class have been created.</p>\n</blockquote>\n", "OwnerUserId": "5538420", "PostTypeId": "2", "Id": "33910325", "Score": "3", "CreationDate": "2015-11-25T07:01:22.640", "LastActivityDate": "2015-11-25T07:01:22.640"}});