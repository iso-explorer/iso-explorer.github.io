post_cb({"44994784": {"ParentId": "44994461", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2017-07-09T09:10:42.557", "Score": "6", "LastEditorUserId": "817643", "LastEditDate": "2017-07-09T11:29:39.607", "Id": "44994784", "OwnerUserId": "817643", "Body": "<p>What's important to remember is that</p>\n<ol>\n<li>Function declarations in different namespaces don't interfere with each other.</li>\n<li>A definition of a function is also a declaration.</li>\n<li><a href=\"http://eel.is/c++draft/namespace.def#4\" rel=\"nofollow noreferrer\">[namespace.def/4]</a></li>\n</ol>\n<blockquote>\n<p id=\"so_44994461_44994784_0\"><strong>The enclosing namespaces of a declaration are those namespaces in\n  which the declaration lexically appears</strong>, except for a redeclaration of\n  a namespace member outside its original namespace (e.g., a definition\n  as specified in [namespace.memdef]). Such a redeclaration has the same\n  enclosing namespaces as the original declaration.</p>\n</blockquote>\n<p>So let's look at the <code>otherHello</code> definition. Where does it lexically appear? In the global namespace of course. That's also the point of declaration for it. Which means the enclosing namespace is the global one, and you end up with a declaration of <code>::otherHello</code>. </p>\n<p>So no, this doesn't contradict the standard quote from the accepted answer to the other question. Member functions can be defined outside of the class, so long as they are qualified by their class name (<a href=\"http://eel.is/c++draft/class.mem#class.mfct-4\" rel=\"nofollow noreferrer\">[class.mfct/4]</a>):</p>\n<blockquote>\n<p id=\"so_44994461_44994784_1\">If the definition of a member function is lexically outside its class\n  definition, the member function name shall be qualified by its class\n  name using the \u200b::\u200b operator.</p>\n</blockquote>\n<p>So we need only ask, does <code>Greeting</code> name the same class as <code>NS::Greeting</code>? Why, yes it does. The using directive is responsible for that.</p>\n<hr>\n<p>I'll add this segment in the hope of clarifying. Consider this code snippet:</p>\n<pre><code>namespace NS1 {\n    namespace NS2 {\n        void hello();\n    }\n}\n\nusing namespace NS1;\n\nvoid NS2::hello() {\n\n}\n\nint main() {\n    NS1::NS2::hello();\n    return 0;\n}\n</code></pre>\n<p>When the compiler encounters <code>NS2::hello</code> being defined it preforms name lookup for that declarator id. According to <a href=\"http://eel.is/c++draft/basic.lookup.qual#3\" rel=\"nofollow noreferrer\">[basic.lookup.qual/3]</a>:</p>\n<blockquote>\n<p id=\"so_44994461_44994784_2\">In a declaration in which the declarator-id is a qualified-id, <strong>names\n  used before the qualified-id being declared are looked up in the\n  defining namespace scope</strong>; names following the qualified-id are looked\n  up in the scope of the member's class or namespace.</p>\n</blockquote>\n<p>So <code>NS2</code> is looked up in the defining scope (the global one), and according to the unqualified name lookup rule you quoted, it is found and resolved as <code>NS1::NS2</code>. That's how <code>NS2::hello</code> is associated with <code>NS1::NS2::hello</code> and resolved as defining it.</p>\n<p>In the global namespace of the OP, <code>otherHello</code> isn't preceded by anything. Therefore name lookup doesn't occur. It immediately defines that function in the enclosing namespace, as I previously quoted.</p>\n</hr>", "LastActivityDate": "2017-07-09T11:29:39.607"}, "bq_ids": {"n4140": {"so_44994461_44994784_2": {"section_id": 7109, "quality": 1.0, "length": 20}, "so_44994461_44994461_0": {"section_id": 5510, "quality": 0.9444444444444444, "length": 17}, "so_44994461_44994784_1": {"section_id": 5884, "quality": 1.0, "length": 17}, "so_44994461_44994784_0": {"section_id": 5478, "quality": 0.8888888888888888, "length": 24}}, "n3337": {"so_44994461_44994784_2": {"section_id": 6853, "quality": 1.0, "length": 20}, "so_44994461_44994461_0": {"section_id": 5296, "quality": 0.9444444444444444, "length": 17}, "so_44994461_44994784_1": {"section_id": 5655, "quality": 1.0, "length": 17}, "so_44994461_44994784_0": {"section_id": 5264, "quality": 0.8888888888888888, "length": 24}}, "n4659": {"so_44994461_44994784_2": {"section_id": 8610, "quality": 1.0, "length": 20}, "so_44994461_44994461_0": {"section_id": 6945, "quality": 0.9444444444444444, "length": 17}, "so_44994461_44994784_1": {"section_id": 7367, "quality": 1.0, "length": 17}, "so_44994461_44994784_0": {"section_id": 6911, "quality": 0.8888888888888888, "length": 24}}}, "44994461": {"CommentCount": "0", "AcceptedAnswerId": "44994784", "PostTypeId": "1", "LastEditorUserId": "964243", "CreationDate": "2017-07-09T08:29:57.213", "LastActivityDate": "2017-07-23T16:21:18.363", "LastEditDate": "2017-07-10T18:29:51.287", "ViewCount": "221", "FavoriteCount": "2", "Title": "Why does the using directive not \"associate\" with ordinary functions?", "Id": "44994461", "Score": "9", "Body": "<p>According to <a href=\"https://stackoverflow.com/questions/18556714\">this question</a> it is valid to define class methods after a <code>using</code> directive, instead of enclosing them within a <code>namespace</code> block.</p>\n<p>However, that seems not to be the case for ordinary functions. Consider:</p>\n<h3><code>Greeting.hh</code></h3>\n<pre><code>#pragma once\n\nnamespace NS\n{\n    class Greeting\n    {\n    public:\n        void hello();\n    };\n\n    void otherHello();\n}\n</code></pre>\n<h3><code>Greeting.cc</code></h3>\n<pre><code>#include \"Greeting.hh\"\n#include &lt;iostream&gt;\n\nusing namespace NS;\n\nvoid Greeting::hello()\n{\n    std::cout &lt;&lt; \"Greeting::hello\" &lt;&lt; std::endl;\n}\n\nvoid otherHello()\n{\n    std::cout &lt;&lt; \"otherHello\" &lt;&lt; std::endl;\n}\n</code></pre>\n<h3><code>main.cc</code></h3>\n<pre><code>#include \"Greeting.hh\"\n\nint main()\n{\n    NS::Greeting o;\n    o.hello();\n    NS::otherHello();\n}\n</code></pre>\n<p>This won't compile, yielding the following error message:</p>\n<pre><code>undefined reference to `NS::otherHello()'\n</code></pre>\n<p>Further inspection indicates that <code>otherHello</code>'s symbol is not preceded by the namespace, while <code>Greeting::hello</code>'s is:</p>\n<pre><code>g++ -std=c++14 -pedantic -Wall -c Greeting.cc\nnm -C Greeting.o | grep T\n000000000000002a T otherHello()\n0000000000000000 T NS::Greeting::hello()\n</code></pre>\n<p>Does this contradict with the Standard reference from the <a href=\"https://stackoverflow.com/a/18556784/586873\">accepted answer</a>?</p>\n<blockquote>\n<p id=\"so_44994461_44994461_0\">\"During unqualified name lookup (3.4.1), the names appear as if they\n  were declared in the nearest enclosing namespace which contains both\n  the using-directive and the nominated namespace.\"</p>\n</blockquote>\n", "Tags": "<c++><namespaces>", "OwnerUserId": "586873", "AnswerCount": "1"}});