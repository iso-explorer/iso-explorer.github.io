post_cb({"34446445": {"ParentId": "34445336", "LastEditDate": "2017-07-03T12:10:11.203", "CommentCount": "6", "CreationDate": "2015-12-24T02:17:47.463", "Score": "12", "LastEditorUserId": "3647361", "PostTypeId": "2", "Id": "34446445", "OwnerUserId": "3647361", "Body": "<p>Note: as of C++17, you can declare your <a href=\"http://en.cppreference.com/w/cpp/language/inline\" rel=\"nofollow noreferrer\">variables as inline</a>. </p>\n<hr>\n<p><strong>TL;DR</strong>: If you want to be on the (very) safe side, go with constexpr functions. It isn't inherently necessary though, and certainly won't be if you're performing trivial operations on these objects and are solely interested in their value, or simply don't use them in the dangerous scenarios listed below. </p>\n<p>The fundamental issue is that <code>const</code> variables at namespace scope such as yours (generally) have internal linkage (<a href=\"http://eel.is/c++draft/basic.link#3\" rel=\"nofollow noreferrer\">[basic.link]/(3.2)</a>). This implies that <strong>each translation unit compiling the corresponding header will observe a different entity</strong> (i.e. symbol).</p>\n<p>Now imagine we have a template or inline function in a header using those objects. The ODR is very precise about this scenario - <a href=\"http://eel.is/c++draft/basic.def.odr#6\" rel=\"nofollow noreferrer\">[basic.def.odr]/6</a>:</p>\n<p><a href=\"https://i.stack.imgur.com/XuRPp.png\" rel=\"nofollow noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/XuRPp.png\"/></a></p>\n<p><em>\"initialized with a constant expression\"</em> is certainly met, since we're talking <code>constexpr</code>. So is <em>\"the object has the same value in all definitions of <code>D</code>\"</em> if you don't monkey about.</p>\n<p><em>\"the object isn't odr-used\"</em> is probably the only questionable condition. Basically, it requires that you don't necessitate the variables runtime existence as a symbol, which in turn implies that</p>\n<ul>\n<li><p>You don't bind it to a reference (=&gt; you don't forward it!)</p></li>\n<li><p>You don't (neither explicitly nor implicitly) take its address. </p></li>\n</ul>\n<p>The only exception to the second rule are arrays, which can be taken the address of implicitly inside a subscript operation as long as the two above rules aren't violated for the yielded glvalue.</p>\n<p>More precisely, odr-use is governed by <a href=\"http://eel.is/c++draft/basic.def.odr#3\" rel=\"nofollow noreferrer\">[basic.def.odr]/3</a>:</p>\n<blockquote>\n<p id=\"so_34445336_34446445_0\">A variable <code>x</code> whose name appears as a potentially-evaluated expression <code>ex</code> is odr-used by <code>ex</code> unless applying\n  the lvalue-to-rvalue conversion (4.1) to <code>x</code> yields a constant expression (5.20) that does not invoke any non-trivial functions and, if <code>x</code> is an object, <code>ex</code> is an element of the set of potential results of an expression <code>e</code>, where either the lvalue-to-rvalue conversion (4.1) is applied to <code>e</code>, or <code>e</code> is a discarded-value expression (Clause\n  5).</p>\n</blockquote>\n<p>Applying l-t-r to any <code>constexpr</code> variable will behave as required by the first part. The second part requires that the variable be used as a <em>value</em> rather than an actual <em>object</em>; that is, it's eventually either discarded or directly evaluated, giving the above rules of thumb.</p>\n<p>If you avoid odr-use of the variable inside inline functions, templates or the like, you're fine. But if you use the return value of a corresponding constexpr function, you won't have to worry, since prvalues are already behaving more like values/literals (not objects) and constexpr functions are inline and definitely won't violate the ODR (if you don't use <code>constexpr</code> variables inside there!).</p>\n</hr>", "LastActivityDate": "2017-07-03T12:10:11.203"}, "bq_ids": {"n4140": {"so_34445336_34446445_0": {"section_id": 7040, "quality": 0.9375, "length": 30}}, "n4659": {"so_34445336_34446445_0": {"section_id": 8537, "quality": 0.9375, "length": 30}}}, "34445336": {"CommentCount": "20", "ViewCount": "4109", "PostTypeId": "1", "LastEditorUserId": "3598119", "CreationDate": "2015-12-23T23:35:25.333", "LastActivityDate": "2017-07-03T12:10:11.203", "LastEditDate": "2015-12-24T06:30:55.313", "AcceptedAnswerId": "34446445", "FavoriteCount": "6", "Title": "constexpr global constants in a header file and odr", "Id": "34445336", "Score": "15", "Body": "<p>Unfortunately, I am somewhat confused about <code>constexpr</code>, global constants declared in header files, and the odr.</p>\n<p>In short: Can we conclude from here</p>\n<p><a href=\"https://isocpp.org/files/papers/n4147.pdf\">https://isocpp.org/files/papers/n4147.pdf</a></p>\n<p>that</p>\n<pre><code>constexpr MyClass const MyClassObj () { return MyClass {}; }\nconstexpr char const * Hello () { return \"Hello\"; }\n</code></pre>\n<p>is preferable over</p>\n<pre><code>constexpr MyClass const kMyClassObj = MyClass {};\nconstexpr char const * kHello = \"Hello\";\n</code></pre>\n<p>for defining globals in a header file\nif I want to \"just use\" those <em>globally</em> declared/defined entities and do not want to think about <em>how</em> I use them?</p>\n", "Tags": "<c++><c++11><language-lawyer><constexpr><linkage>", "OwnerUserId": "1419315", "AnswerCount": "1"}});