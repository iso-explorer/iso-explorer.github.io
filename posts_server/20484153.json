post_cb({"bq_ids": {"n4140": {"so_20484153_20484272_0": {"length": 33, "quality": 0.9166666666666666, "section_id": 480}}, "n3337": {"so_20484153_20484272_0": {"length": 34, "quality": 0.9444444444444444, "section_id": 471}}, "n4659": {"so_20484153_20484272_0": {"length": 33, "quality": 0.9166666666666666, "section_id": 502}}}, "20484840": {"Id": "20484840", "PostTypeId": "2", "Body": "<p>Interestingly, your example is addressed in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1377.htm#Copy%20vs%20Move\" rel=\"nofollow\">n1377</a>:</p>\n<blockquote>\n<p id=\"so_20484153_20484840_0\">With this language feature in place, move/copy elision, although still\n  important, is no longer critical. There are some functions where NRVO\n  is allowed, but can be exceedingly difficult to implement. For\n  example:</p>\n<pre><code>A\nf(bool b)\n{\n    A a1, a2;\n    // ...\n   return b ? a1 : a2;\n}\n</code></pre>\n<p id=\"so_20484153_20484840_1\">It is somewhere between difficult and impossible to decide whether to\n  construct a1 or a2 in the caller's preferred location. Using A's move\n  constructor (instead of copy constructor) to send a1 or a2 back to the\n  caller is the best solution.</p>\n<p id=\"so_20484153_20484840_2\">We could require that the author of operator+ explicitly request the\n  move semantics. But what would be the point? The current language\n  already allows for the elision of this copy, so the coder already can\n  not rely on destruction order of the local, nor can he rely on the\n  copy constructor being called. The auto-local is about to be\n  conceptually destructed anyway, so it is very \"rvalue-like\". The move\n  is not detectable except by measuring performance, or counting copies\n  (which may be elided anyway).</p>\n<p id=\"so_20484153_20484840_3\">Note that this language addition permits movable, but non-copyable\n  objects (such as move_ptr) to be returned by value, since a move\n  constructor is found and used (or elided) instead of the inaccessible\n  copy constructor.</p>\n</blockquote>\n<p>Their example of solving this (in favor of move semantics) is:</p>\n<pre><code>// Or just call std::move\n// return x&gt;2 ? static_cast&lt;Foo&amp;&amp;&gt;(foo2) : static_cast&lt;Foo&amp;&amp;&gt;(foo3);\nreturn static_cast&lt;Foo&amp;&amp;&gt;(x&gt;2 ? foo2 : foo3);\n</code></pre>\n<blockquote>\n<p id=\"so_20484153_20484840_4\">The logic resulting from this implicit cast results in an automatic\n  hierarchy of \"move semantics\" from best to worst:</p>\n<pre><code>If you can elide the move/copy, do so (by present language rules)\nElse if there is a move constructor, use it\nElse if there is a copy constructor, use it\nElse the program is ill formed\n</code></pre>\n</blockquote>\n<p>Or as Xeo mentions, you can structure it this way:</p>\n<pre><code>Foo Baz(int x) {                \n    Foo foo2(2);                \n    Foo foo3(3);                \n    if (x &gt; 2)\n        return foo2;\n    else\n        return foo3;\n}        \n</code></pre>\n<p>You already provided an example in the OP, but the standard provides one for eliding the move/copy constructor (it equally applies):</p>\n<pre><code>class Thing {\npublic:\n    Thing() { }\n    ~Thing() { }\n    Thing(Thing&amp;&amp; thing) {\n        std::cout &lt;&lt; \"hi there\";\n    }\n};\nThing f() {\n    Thing t;\n    return t;\n}\nThing t2 = f();\n// does not print \"hi there\"\n</code></pre>\n<p>But if you supply both the move and copy constructor, the move constructor seems to be preferred.              </p>\n", "OwnerDisplayName": "user1508519", "LastActivityDate": "2013-12-10T02:20:13.327", "Score": "1", "CreationDate": "2013-12-10T02:20:13.327", "ParentId": "20484153", "CommentCount": "0"}, "20484272": {"Id": "20484272", "PostTypeId": "2", "Body": "<p>From the C++ standard:</p>\n<blockquote>\n<p id=\"so_20484153_20484272_0\">[class.copy]/31: When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, even if the copy/move constructor and/or destructor for the object have side effects. ... This elision of copy/move operations, called copy elision, is permitted in the following circumstances (which may be combined to eliminate multiple copies):</p>\n<ul>\n<li>in a return statement in a function with a class return type, when the expression is the name of a\n  non-volatile automatic object (other than a function or catch-clause parameter) with the same cv-\n  unqualified type as the function return type, the copy/move operation can be omitted by constructing\n  the automatic object directly into the function\u2019s return value</li>\n</ul>\n</blockquote>\n<p>Since <code>x &gt; 2 ? foo2 : foo3</code> is not the name of an automatic object, copy elision is not permitted.</p>\n", "LastEditorUserId": "2905299", "LastActivityDate": "2013-12-10T01:47:05.647", "Score": "3", "CreationDate": "2013-12-10T01:20:30.060", "ParentId": "20484153", "CommentCount": "0", "OwnerUserId": "2905299", "LastEditDate": "2013-12-10T01:47:05.647"}, "20484153": {"ViewCount": "226", "Body": "<p>Is there a good way to return a value from a function in C++ where we guarantee that the copy constructor is not called?  Either the return value optimization or the move constructor are fine.  For example, with the following code</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Foo {\nprivate:\n    // Disallow the copy and default constructor as well as the assignment\n    // operator\n    Foo();\n    Foo(Foo const &amp; foo);\n    Foo &amp; operator = (Foo const &amp; foo);\n\npublic:                         \n    // Store a little bit of data\n    int data;                   \n    Foo(int const &amp; data_) : data(data_) { }\n\n    // Write a move constructor \n    Foo(Foo &amp;&amp; foo) {           \n        std::cout &lt;&lt; \"Move constructor\" &lt;&lt; std::endl;\n        data=foo.data;          \n    }                           \n};                              \n\n// Write a function that creates and returns a Foo\nFoo Bar() {                     \n    Foo foo(3);                 \n    return foo;                 \n}                               \n\n// See if we can mix things up  \nFoo Baz(int x) {                \n    Foo foo2(2);                \n    Foo foo3(3);                \n    return x&gt;2 ? foo2 : foo3;   \n}                               \n\nint main() {                    \n    // This is using the return value optimization (RVO)\n    Foo foo1 = Bar();           \n    std::cout &lt;&lt; foo1.data &lt;&lt; std::endl;\n\n    // This should make the RVO fail \n    Foo foo2 = Baz(3);\n    std::cout &lt;&lt; foo2.data &lt;&lt; std::endl;\n}\n</code></pre>\n<p>We have a compiler error</p>\n<pre><code>$ make\ng++ -std=c++11 test01.cpp -o test01\ntest01.cpp: In function 'Foo Baz(int)':\ntest01.cpp:10:5: error: 'Foo::Foo(const Foo&amp;)' is private\ntest01.cpp:35:25: error: within this context\nmake: *** [all] Error 1\n</code></pre>\n<p>since the copy constructor is private.  Now, if we modify the Baz function to</p>\n<pre><code>// See if we can mix things up\nFoo Baz(int x) {\n    Foo foo2(2);\n    Foo foo3(3);\n    return std::move(x&gt;2 ? foo2 : foo3);\n}\n</code></pre>\n<p>we do in fact run correctly.  However, this seems to preclude the RVO from being used ever.  Is there a better way to structure these functions if we must guarantee that the copy constructor is not called?</p>\n", "AcceptedAnswerId": "20484840", "Title": "Returning a value from a function with move semantics or the return value optimization, but not the copy constructor", "CreationDate": "2013-12-10T01:09:58.017", "Id": "20484153", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2013-12-10T02:20:13.327", "Score": "2", "OwnerUserId": "1932452", "Tags": "<c++><c++11>", "AnswerCount": "2"}});