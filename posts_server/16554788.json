post_cb({"bq_ids": {"n4140": {"so_16554788_16554829_1": {"length": 9, "quality": 1.0, "section_id": 7224}}, "n3337": {"so_16554788_16554829_1": {"length": 9, "quality": 1.0, "section_id": 6968}}, "n4659": {"so_16554788_16554829_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 8735}}}, "16554788": {"ViewCount": "2327", "Body": "<p>If I have an array as an argument in main</p>\n<pre><code>int main(int argc, char* argv[])\n</code></pre>\n<p>why will </p>\n<pre><code>sizeof(argv)/sizeof(argv[0])\n</code></pre>\n<p>always reliably give me the length of the array?</p>\n", "AcceptedAnswerId": "16554829", "Title": "Why does sizeof(argv)/sizeof(argv[0]) give me the size of an array in C++?", "CreationDate": "2013-05-15T00:16:06.440", "Id": "16554788", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-05-15T00:36:36.187", "LastEditorUserId": "1774667", "LastActivityDate": "2013-05-15T01:25:28.683", "Score": "3", "OwnerUserId": "1670076", "Tags": "<c++><arrays><pointers><sizeof>", "AnswerCount": "1"}, "16554829": {"Id": "16554829", "PostTypeId": "2", "Body": "<p>It doesn't.</p>\n<p>I probably got a bit carried away when writing this answer; it's too much of a language-lawyer approach to a fairly simple question. I'll add this quick summary which should be enough to answer the question. The pedantic and overly verbose version of the answer is below the horizontal line.</p>\n<p>Given:</p>\n<pre><code>int main(int argc, char* argv[])\n</code></pre>\n<p><code>argv</code> isn't an array at all; it's a pointer. (C and C++ don't permit parameters of array type; something that looks like an array parameter is really a pointer parameter.) <code>argv</code> does point (at run time) to the first element of an array, but there's no information <em>in the declaration</em> about how big that array is. That's why we need the <code>argc</code> parameter to provide that information.</p>\n<p>So <code>sizeof(argv)/sizeof(argv[0])</code> <em>doesn't</em> give you the number of elements in an array; it just divides the size of a pointer by the size of a pointer, which <em>probably</em> gives you <code>1</code>. (Why only \"probably\"? That's part of the overly pedantic answer below.)</p>\n<p>Now if you define something explicitly as an array object:</p>\n<pre><code>int an_array[42];\n</code></pre>\n<p>you <em>can</em> use that idiom to compute the number of elements in the array:</p>\n<pre><code>sizeof an_array / sizeof an_array[0]\n</code></pre>\n<p>This yields <code>42</code>, the number of elements in the array. The way it works is (I think) fairly straightforward: it's the size in bytes of the whole array divided by the size in bytes of one of its elements.</p>\n<p>But it works <em>only</em> for an actual array, not for something like <code>argv</code> that <em>looks</em> like an array but is really a pointer.</p>\n<p>The relationship between arrays and pointers can be confusing. Section 6 of the <a href=\"http://www.c-faq.com/\">comp.lang.c FAQ</a> explains it very well, and most or all of it applies to both C and C++.</p>\n<p>Now the long-winded pedantic explanation with too many digressions:</p>\n<hr>\n<p><code>argv</code> is a pointer, specifically a pointer to pointer to <code>char</code>.  As a parameter declaration (and <em>only</em> in that context), <code>char *argv[]</code> is equivalent to <code>char **argv</code>.</p>\n<p><code>sizeof (argv)</code> is the number of bytes in a <code>char**</code> pointer.</p>\n<p><code>sizeof (argv[0])</code> is the number of bytes in a <code>char*</code> pointer.</p>\n<p><code>sizeof (argv) / sizeof (argv[0])</code> is very likely to be 1 (assuming that <code>char*</code> and <code>char**</code> have the same size, which they do in most implementations).</p>\n<p>Now for something that's been defined as an array object:</p>\n<pre><code>some_type an_array[COUNT];\n</code></pre>\n<p>that expression does work; this:</p>\n<pre><code>sizeof an_array / sizeof an_array[0]\n</code></pre>\n<p>does give you the number of elements in <code>an_array</code>, namely <code>COUNT</code>.  The reason for that should, I think, be fairly obvious. The number of bytes in an array is the number of bytes in one element of the array multiplied by the number of elements. So:</p>\n<pre><code>sizeof an_array == sizeof an_array[0] * COUNT\n</code></pre>\n<p>and, rearranging the terms:</p>\n<pre><code>sizeof an_array / sizeof an_array[0] == COUNT\n</code></pre>\n<p>Incidentally, <code>sizeof an_array[0]</code> can also be written as <code>sizeof *an_array</code>, due to the way the indexing operator is defined in C.</p>\n<p>(Note that the <code>sizeof</code> operator doesn't require parentheses around its argument, if that argument is an expression such as an object name. The operand to <code>sizeof</code> is either an expression or a parenthesized type name. But if you prefer to always use parentheses with <code>sizeof</code>, you can do that.)</p>\n<p>This is a common idiom for computing the number of elements in an array -- but it works only if you have the name of the array itself, not a pointer to its first element.</p>\n<p>[The following applies to C. I believe it also applies to C++ (I initially didn't notice that the question is tagged C++, not C).]</p>\n<p>In answer to a question raised in comments, no, <code>char*</code> and <code>char**</code> are not required to have the same size. The C standard's requirements on pointer representation are:</p>\n<blockquote>\n<p id=\"so_16554788_16554829_0\">A pointer to <strong>void</strong> shall have the same representation and alignment\n  requirements as a pointer to a character type. Similarly, pointers\n  to qualified or unqualified versions of compatible types shall have\n  the same representation and alignment requirements. All pointers to\n  structure types shall have the same representation and alignment\n  requirements as each other. All pointers to union types shall have the\n  same representation and alignment requirements as each other. Pointers\n  to other types need not have the same representation or alignment\n  requirements.</p>\n</blockquote>\n<p>Reference: <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\">N1570</a>, 6.2.5p28.</p>\n<p>The C++ standard has at least some some of this; section 3.9.2 [basic.compound] of the N3485 draft says:</p>\n<blockquote>\n<p id=\"so_16554788_16554829_1\">An object of type <em>cv</em> <code>void*</code> shall have the same representation and alignment\n  requirements as <em>cv</em> <code>char*</code>.</p>\n</blockquote>\n<p>I haven't found the corresponding text for the rest of what I quoted from the C standard.</p>\n<p>On a word-addressed machine, a <code>char*</code> pointer could plausibly require more information to specify both a word and a byte within that word than is needed for a <code>char**</code> pointer, which only needs to specify an aligned word.</p>\n</hr>", "LastEditorUserId": "827263", "LastActivityDate": "2013-05-15T01:25:28.683", "Score": "21", "CreationDate": "2013-05-15T00:21:05.033", "ParentId": "16554788", "CommentCount": "24", "OwnerUserId": "827263", "LastEditDate": "2013-05-15T01:25:28.683"}});