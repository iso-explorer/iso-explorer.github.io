post_cb({"43585237": {"CommentCount": "3", "AcceptedAnswerId": "43707540", "PostTypeId": "1", "LastEditorUserId": "3640643", "CreationDate": "2017-04-24T10:05:35.260", "LastActivityDate": "2017-05-01T07:48:23.220", "LastEditDate": "2017-04-24T14:40:26.400", "ViewCount": "311", "FavoriteCount": "3", "Title": "Possible GCC linker bug causes error when linking weak and local symbols together", "Id": "43585237", "Score": "7", "Body": "<p>I'm creating a library and using objcopy to change the visibility of symbols from global to local to avoid exporting a load of internal symbols. If I use the <code>--undefined</code> flag to bring in an unused symbol from the library when linking, GCC gives me the following error:</p>\n<pre><code>`_ZStorSt13_Ios_OpenmodeS_' referenced in section `.text' of ./liblibrary.a(library_stripped.o): defined in discarded section `.text._ZStorSt13_Ios_OpenmodeS_[_ZStorSt13_Ios_OpenmodeS_]' of ./liblibrary.a(library_stripped.o)\n</code></pre>\n<p>Here are the two source files and makefile that reproduce the issue.</p>\n<p>stringstream.cpp:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;sstream&gt;\nint main() {\n   std::stringstream messagebuf;\n   messagebuf &lt;&lt; \"Hello world\";\n   std::cout &lt;&lt; messagebuf.str();\n   return 0;\n}\n</code></pre>\n<p>library.cpp:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;sstream&gt;\nextern \"C\" {\nvoid keepme_lib_function() {\n    std::stringstream messagebuf;\n    messagebuf &lt;&lt; \"I'm a library function\";\n    std::cout &lt;&lt; messagebuf.str();\n}}\n</code></pre>\n<p>Makefile:</p>\n<pre><code>CC = g++\n\nall: executable\n\n#build a test program that uses stringstream\nstringstream.o : stringstream.cpp\n        $(CC) -g -O0 -o $@ -c $^\n\n#build a library that also uses stringstream\nliblibrary.a : library.cpp\n        $(CC) -g -O0 -o library.o -c $^\n        #Set all symbols to local that aren't intended to be exported (keep-global-symbol doesn't discard anything, just changes the binding value to local)\n        objcopy --keep-global-symbol 'keepme_lib_function' library.o library_stripped.o \n        #objcopy --wildcard -W '!keepme_*' library.o library_stripped.o \n        rm -f $@\n        ar crs $@ library_stripped.o\n\n#Link the program with the library, and force keepme_lib_function to be kept in, even though it isn't referenced.\nexecutable : clean liblibrary.a stringstream.o\n        $(CC) -g -o stringstream stringstream.o -L. -Wl,--undefined=keepme_lib_function,-llibrary # -lgcc_eh -lstdc++ #may need to insert these depending on your environment\n\nclean:\n        rm -f library_stripped.o\n        rm -f stringstream.o\n        rm -f library.o\n        rm -f liblibrary.a\n        rm -f stringstream\n</code></pre>\n<p>If instead of the first objcopy command, I use the second (commented out) one to only weaken the symbols, it works. But I don't want to weaken the symbols, I want them to be local and not visible to people linking to the library at all.</p>\n<p>Doing a readelf on the two object files gives the expected result for this symbol. Weak (global) in the program, and local in the library. As far as I know this should link correctly?</p>\n<p>library.a:</p>\n<pre><code>22: 0000000000000000    18 FUNC    LOCAL  DEFAULT    6 _ZStorSt13_Ios_OpenmodeS_\n</code></pre>\n<p>stringstream.o</p>\n<pre><code>22: 0000000000000000    18 FUNC    WEAK   DEFAULT    6 _ZStorSt13_Ios_OpenmodeS_\n</code></pre>\n<p>Is this a bug with GCC, that when I force a function to be brought in from the library, it has already discarded local symbols? Am I doing the right thing by changing symbols to local in my libary? </p>\n", "Tags": "<c++><c><gcc><linker><ld>", "OwnerUserId": "3640643", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_43585237_43707540_0": {"section_id": 7043, "quality": 0.8, "length": 8}, "so_43585237_43707540_1": {"section_id": 7043, "quality": 0.5454545454545454, "length": 6}}, "n3337": {"so_43585237_43707540_0": {"section_id": 6788, "quality": 0.8, "length": 8}, "so_43585237_43707540_1": {"section_id": 6788, "quality": 0.5454545454545454, "length": 6}}, "n4659": {"so_43585237_43707540_0": {"section_id": 8540, "quality": 0.8, "length": 8}, "so_43585237_43707540_1": {"section_id": 8540, "quality": 0.5454545454545454, "length": 6}}}, "43707540": {"ParentId": "43585237", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><strong>Groundwork</strong></p>\n<p>Let's fill out our knowledge of the offending symbol <code>_ZStorSt13_Ios_OpenmodeS_</code> in your\nexample.</p>\n<p><code>readelf</code> reports it identically in both <code>library.o</code> and <code>stringstream.o</code>:</p>\n<pre><code>$ readelf -s main.o | grep Bind\nNum:    Value          Size Type    Bind   Vis      Ndx Name\n\n$ readelf -s stringstream.o | grep _ZStorSt13_Ios_OpenmodeS_\n25: 0000000000000000    18 FUNC    WEAK   DEFAULT    8 _ZStorSt13_Ios_OpenmodeS_\n\n$ readelf -s library.o | grep _ZStorSt13_Ios_OpenmodeS_\n25: 0000000000000000    18 FUNC    WEAK   DEFAULT    8 _ZStorSt13_Ios_OpenmodeS_\n</code></pre>\n<p>So it's a weak function symbol in both object files. It is visible for <em>dynamic</em>\nlinkage (<code>Vis</code> = <code>DEFAULT</code>) in both files. It's defined in input linkage section #8 (<code>Ndx</code> = <code>8</code>) in both files.\nNote that: <em>it is defined in both object files</em>, not just defined in one and maybe referenced\nin the other.</p>\n<p>What sort of thing could that be? A global inline function. Its inline definition gets into\nboth object files from one of your headers. <code>g++</code> emits weak symbols for\nglobal inline functions to forestall multiple definition errors from the linker:\nweak symbols are allowed to be multiply defined in the linkage input (with any number of other\nweak definitions and at most one other strong definition).</p>\n<p>Let's look at those linkage sections:</p>\n<pre><code>$ readelf -t stringstream.o\nThere are 31 section headers, starting at offset 0x130c0:\n\nSection Headers:\n  [Nr] Name\n       Type              Address          Offset            Link\n       Size              EntSize          Info              Align\n       Flags\n  ...\n  ...\n  [ 8] .text._ZStorSt13_Ios_OpenmodeS_\n       PROGBITS               PROGBITS         0000000000000000  00000000000001b7  0\n       0000000000000012 0000000000000000  0                 1\n       [0000000000000206]: ALLOC, EXEC, GROUP\n</code></pre>\n<p>and:</p>\n<pre><code>$ readelf -t library.o \nThere are 31 section headers, starting at offset 0x130d0:\n\nSection Headers:\n  [Nr] Name\n       Type              Address          Offset            Link\n       Size              EntSize          Info              Align\n       Flags\n  ...\n  ...\n  [ 8] .text._ZStorSt13_Ios_OpenmodeS_\n       PROGBITS               PROGBITS         0000000000000000  00000000000001bc  0\n       0000000000000012 0000000000000000  0                 1\n       [0000000000000206]: ALLOC, EXEC, GROUP\n</code></pre>\n<p>They're identical, modulo position. The one notable point here is the section name itself,\n<code>.text._ZStorSt13_Ios_OpenmodeS_</code>, which is of the form: <code>.text.&lt;function_name&gt;</code>,\nand denotes: <em>A function in the</em> <code>text</code> <em>(i.e program code) region</em>.</p>\n<p>We'd expect a function to be in the program code, but compare this with, say, your\nother function <code>keepme_lib_function</code>, which</p>\n<pre><code>$ readelf -s library.o | grep keepme_lib_function\n26: 0000000000000000   246 FUNC    GLOBAL DEFAULT    3 keepme_lib_function\n</code></pre>\n<p>tells us is in section #3 of <code>library.o</code>. And section #3</p>\n<pre><code>$ readelf -t library.o\n  ...\n  ...\n  [ 3] .text\n       PROGBITS               PROGBITS         0000000000000000  0000000000000050  0\n       0000000000000154 0000000000000000  0\n</code></pre>\n<p>is simply the <code>.text</code> section. Not <code>.text.keepme_lib_function</code>.</p>\n<p>A input section of the form <code>.text.&lt;function_name&gt;</code>, like <code>.text._ZStorSt13_Ios_OpenmodeS_</code>,\nis a <em>function-section</em>. It's a code section that contains <em>only</em> the function <code>&lt;function_name&gt;</code>.\nSo in both your <code>stringstream.o</code> and <code>library.o</code>, the function <code>_ZStorSt13_Ios_OpenmodeS_</code>\ngets a function-section to itself.</p>\n<p>This agrees with <code>_ZStorSt13_Ios_OpenmodeS_</code> being an inline global function, and\ntherefore weakly defined. Suppose a weak symbol has got multiple definitions\nin the linkage. Which definition will the linker pick? If any of the definitions\nis strong, the linker can allow at most one strong definition and must pick that one.\nBut what if they're all weak? - which is what we've got here with <code>_ZStorSt13_Ios_OpenmodeS_</code>.\nIn that case, the linker can pick <em>any one of them</em>, arbitrarily.</p>\n<p>Either way, it will then have to discard all the rejected weak definitions of the symbol from\nthe linkage. That's what is enabled by putting each weak definition of an inline global function in a function-section\nof its own. Then any competing definitions that the linker rejects can be dropped from\nthe linkage by discarding the function-sections that contain them, with no collateral\ndamage. That's why <code>g++</code> emits those function-sections.</p>\n<p>Finally let's identify the function:</p>\n<pre><code>$ c++filt _ZStorSt13_Ios_OpenmodeS_\nstd::operator|(std::_Ios_Openmode, std::_Ios_Openmode)\n</code></pre>\n<p>We can sleuth for this signature under <code>/usr/include/c++</code>, and locate it (for me)\nin <code>/usr/include/c++/6.3.0/bits/ios_base.h</code>:</p>\n<pre><code>inline _GLIBCXX_CONSTEXPR _Ios_Openmode\n  operator|(_Ios_Openmode __a, _Ios_Openmode __b)\n  { return _Ios_Openmode(static_cast&lt;int&gt;(__a) | static_cast&lt;int&gt;(__b)); }\n</code></pre>\n<p>where indeed it is an inline global function, and whence its definition gets into both\nyour <code>stringstream.o</code> and <code>library.o</code> via <code>&lt;iostream&gt;</code>.</p>\n<p><strong>MVCE</strong></p>\n<p>Now let's make a simpler specimen of your linkage problem.</p>\n<p><strong>a.cpp</strong></p>\n<pre><code>inline unsigned foo()\n{\n    return 0xf0a;\n}\n\nunsigned keepme_a() {\n    return foo();\n}\n</code></pre>\n<p><strong>b.cpp</strong></p>\n<pre><code>inline unsigned foo()\n{\n    return 0xf0b;\n}\n\nunsigned keepme_b() {\n    return foo();\n}\n</code></pre>\n<p><strong>main.cpp</strong></p>\n<pre><code>extern unsigned keepme_a();\nextern unsigned keepme_b();\n\n#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; std::hex &lt;&lt; keepme_a() &lt;&lt; std::endl;\n    std::cout &lt;&lt; std::hex &lt;&lt; keepme_b() &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>And a makefile to expedite experiments:</p>\n<pre><code>CXX := g++\nCXXFLAGS := -g -O0\nLDFLAGS := -g -L. -Wl,--trace-symbol='_Z3foov',-M=prog.map,--cref\n\nifdef STRIP\nA_OBJ := a_stripped.o\nB_OBJ := b_stripped.o\nelse\nA_OBJ := a.o\nB_OBJ := b.o\nendif\n\nifdef B_A\nOBJS := main.o $(B_OBJ) $(A_OBJ)\nelse\nOBJS := main.o $(A_OBJ) $(B_OBJ)\nendif\n\n\n.PHONY: all clean\n\nall: prog\n\n%_stripped.o: %.o\n    objcopy --keep-global-symbol '_Z8keepme_$(*)v' $&lt; $@\n\nprog : $(OBJS) \n    $(CXX) $(LDFLAGS) -o $@ $^\n\nclean:\n    rm -f *.o *.map prog\n</code></pre>\n<p>With this makefile, by default we will link a program <code>prog</code> from\nuntampered-with object files <code>main.o</code>, <code>a.o</code>, <code>b.o</code>, in that order.</p>\n<p>If we define <code>STRIP</code> on the <code>make</code> commandline, we'll replace\n<code>a.o</code> and <code>b.o</code> respectively with the object files <code>a_stripped.o</code>\nand <code>b_stripped.o</code> that have been doctored with:</p>\n<pre><code>objcopy --keep-global-symbol '_Z8keepme_$(*)v' $&lt; $@\n</code></pre>\n<p>in which all symbols other than <code>_Z8keepme_{a|b}v</code>, (demangled =\n<code>keepme_{a|b}</code>) have been forced to be <code>LOCAL</code>.</p>\n<p>Furthermore, if we define <code>B_A</code> on the commandline, then the linkage\norder of <code>a[_stripped].o</code> and <code>b[_stripped].o</code> will be reversed.</p>\n<p>Notice something about the definitions of the global inline function\n<code>foo</code> in <code>a.cpp</code> and <code>b.cpp</code> respectively: they're different. The\nformer returns <code>0xf0a</code> and the latter returns <code>0xf0b</code>.</p>\n<p>This makes any program we manage to build <em>illegal</em> per the C++\nStandard: the <a href=\"http://en.cppreference.com/w/cpp/language/definition\" rel=\"nofollow noreferrer\">One Definition Rule</a>\nstipulates:</p>\n<blockquote>\n<p id=\"so_43585237_43707540_0\">For an inline function ... a definition is required\n  in every translation unit where it is odr-used.</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_43585237_43707540_1\">each definition consists of the same sequence of tokens (typically, appears in the same header file)</p>\n</blockquote>\n<p>That's what the Standard stipulates, but the compiler of course cannot\nenforce any constraint on definitions in different translation units,\nand the GNU linker, <code>ld</code>, is not subject to the C++ Standard, or any language standard.</p>\n<p>Let's do some experiments then.</p>\n<p><strong>The default build: make</strong></p>\n<pre><code>$ make\ng++ -g -O0   -c -o main.o main.cpp\ng++ -g -O0   -c -o a.o a.cpp\ng++ -g -O0   -c -o b.o b.cpp\ng++ -g -L. -Wl,--trace-symbol='_Z3foov' -o prog main.o a.o b.o\na.o: definition of _Z3foov\nb.o: reference to _Z3foov\n</code></pre>\n<p>Success. And thanks to the linker diagnostic <code>--trace-symbol='_Z3foov'</code>,\nwe're told that the program defines <code>_Z3foov</code> (demangled = <code>foo</code>)\nin <code>a.o</code> and references it in <code>b.o</code>.</p>\n<p>So we input <em>two different</em> definitions of <code>foo</code> in <code>a.o</code> and <code>b.o</code>\nand in the resulting <code>prog</code>, we have just one. The definition in <code>a.o</code> was chosen and\nthe one in <code>b.o</code> was ditched.</p>\n<p>We can check by running the program, since it can (illegally)\nshow us which definition of <code>foo</code> it calls:</p>\n<pre><code>$ ./prog\nf0a\nf0a\n</code></pre>\n<p>Yes, <code>keepme_a()</code> (from <code>a.o</code>) a <code>keepme_b()</code> (from <code>b.o</code>) are both\ncalling <code>foo</code> from <code>a.o</code>.</p>\n<p>We've also asked the linker to generate the map file <code>prog.map</code>, and\nright near the top of that map file we find:</p>\n<pre><code>Discarded input sections\n\n...\n .text._Z3foov  0x0000000000000000        0xb b.o\n...\n</code></pre>\n<p>The linker got rid of the <code>b.o</code> definition of <code>foo</code> by discarding\nthe function-section <code>.text._Z3foov</code> from <code>b.o</code>.</p>\n<p><strong>make B_A=Yes</strong></p>\n<p>This time we'll just reverse the linkage order of <code>a.o</code> and <code>b.o</code>:</p>\n<pre><code>$ make clean\nrm -f *.o *.map prog \n$ make B_A=Yes\ng++ -g -O0   -c -o main.o main.cpp\ng++ -g -O0   -c -o b.o b.cpp\ng++ -g -O0   -c -o a.o a.cpp\ng++ -g -L. -Wl,--trace-symbol='_Z3foov',-M=prog.map,--cref -o prog main.o b.o a.o\nb.o: definition of _Z3foov\na.o: reference to _Z3foov\n</code></pre>\n<p>Success again. But this time, <code>_Z3foov</code> gets its definition from <code>b.o</code>\nand is only referenced in <code>a.o</code>. Check that out:</p>\n<pre><code>$ ./prog\nf0b\nf0b\n</code></pre>\n<p>And now the map file contains:</p>\n<pre><code>Discarded input sections\n\n...\n .text._Z3foov  0x0000000000000000        0xb a.o\n...\n</code></pre>\n<p>The function-section <code>.text._Z3foov</code> was this time dropped from <code>a.o</code></p>\n<p><strong>How does that work?</strong></p>\n<p>Well we can see how the GNU linker makes its arbitrary choice between multiple\nweak definitions of a global inline function: <em>it just picks the first definition it finds in the\nlinkage sequence</em> and drops the rest. By varying the linkage order\nwe can get an arbitrary one of the definitions to be linked.</p>\n<p>But, if an inline definition must be present in each translation\nunit that calls the function, as the Standard <em>requires</em>, how is the linker\nable to drop the inline definition from any arbitrary one of the translation units and\nget an object file that calls the definition inlined in some other one?</p>\n<p>The compiler enables the linker to do it. Lets look at the assembly of\n<code>a.cpp</code>:</p>\n<pre><code>$ g++ -O0 -S a.cpp &amp;&amp; cat a.s \n    .file   \"a.cpp\"\n    .section    .text._Z3foov,\"axG\",@progbits,_Z3foov,comdat\n    .weak   _Z3foov\n    .type   _Z3foov, @function\n_Z3foov:\n.LFB0:\n    .cfi_startproc\n    pushq   %rbp\n    .cfi_def_cfa_offset 16\n    .cfi_offset 6, -16\n    movq    %rsp, %rbp\n    .cfi_def_cfa_register 6\n    movl    $3850, %eax\n    popq    %rbp\n    .cfi_def_cfa 7, 8\n    ret\n    .cfi_endproc\n.LFE0:\n    .size   _Z3foov, .-_Z3foov\n    .text\n    .globl  _Z8keepme_av\n    .type   _Z8keepme_av, @function\n_Z8keepme_av:\n.LFB1:\n    .cfi_startproc\n    pushq   %rbp\n    .cfi_def_cfa_offset 16\n    .cfi_offset 6, -16\n    movq    %rsp, %rbp\n    .cfi_def_cfa_register 6\n    call    _Z3foov\n    popq    %rbp\n    .cfi_def_cfa 7, 8\n    ret\n    .cfi_endproc\n.LFE1:\n    .size   _Z8keepme_av, .-_Z8keepme_av\n    .ident  \"GCC: (Ubuntu 6.3.0-12ubuntu2) 6.3.0 20170406\"\n    .section    .note.GNU-stack,\"\",@progbits    \n</code></pre>\n<p>There, you see that symbol <code>_Z3foov</code> ( = <code>foo</code>) is given its function-section\nand classified <code>weak</code>:</p>\n<pre><code>    .section    .text._Z3foov,\"axG\",@progbits,_Z3foov,comdat\n    .weak   _Z3foov\n</code></pre>\n<p>That symbol is assembled with the inline definition immediately\nfollowing:</p>\n<pre><code>    _Z3foov:\n    .LFB0:\n        .cfi_startproc\n        pushq   %rbp\n        .cfi_def_cfa_offset 16\n        .cfi_offset 6, -16\n        movq    %rsp, %rbp\n        .cfi_def_cfa_register 6\n        movl    $3850, %eax\n        popq    %rbp\n        .cfi_def_cfa 7, 8\n        ret\n        .cfi_endproc\n</code></pre>\n<p>Then in <code>_Z8keepme_av</code> ( = <code>keepme_a</code>), <code>foo</code> is referred to via <code>_Z3foov</code>,</p>\n<pre><code>call    _Z3foov\n</code></pre>\n<p>not via the local label <code>.LFB0</code> of the inline definition. You'll see the\npattern identically in the assembly of <code>b.cpp</code>. Thus, the\nfunction-section containing that inline definition can be discarded from\neither <code>a.o</code> or <code>b.o</code>, and <code>_Z3foov</code> resolved to the definition in the\n<em>other</em> one, and both <code>keepme_a()</code> and <code>keepme_b()</code> will call the surviving\ndefinition through <code>_Z3foov</code> - as we've seen.</p>\n<p>So much for experimental successes. Next to experimental failures:</p>\n<p><strong>make STRIP=Yes</strong></p>\n<pre><code>$ make clean\nrm -f *.o *.map prog\n$ make STRIP=Yes\ng++ -g -O0   -c -o main.o main.cpp\ng++ -g -O0   -c -o a.o a.cpp\nobjcopy --keep-global-symbol '_Z8keepme_av' a.o a_stripped.o\ng++ -g -O0   -c -o b.o b.cpp\nobjcopy --keep-global-symbol '_Z8keepme_bv' b.o b_stripped.o\ng++ -g -L. -Wl,--trace-symbol='_Z3foov',-M=prog.map,--cref -o prog main.o a_stripped.o b_stripped.o\n`_Z3foov' referenced in section `.text' of b_stripped.o: defined in discarded section `.text._Z3foov[_Z3foov]' of b_stripped.o\ncollect2: error: ld returned 1 exit status\nMakefile:28: recipe for target 'prog' failed\nmake: *** [prog] Error 1\n</code></pre>\n<p>That reproduces your issue. And we have the symmetrical failure also if we reverse the\nlinkage order:</p>\n<p><strong>make STRIP=Yes B_A=Yes</strong></p>\n<pre><code>$ make clean\nrm -f *.o *.map prog \n$ make STRIP=Yes B_A=Yes\ng++ -g -O0   -c -o main.o main.cpp\ng++ -g -O0   -c -o b.o b.cpp\nobjcopy --keep-global-symbol '_Z8keepme_bv' b.o b_stripped.o\ng++ -g -O0   -c -o a.o a.cpp\nobjcopy --keep-global-symbol '_Z8keepme_av' a.o a_stripped.o\ng++ -g -L. -Wl,--trace-symbol='_Z3foov',-M=prog.map,--cref -o prog main.o b_stripped.o a_stripped.o\n`_Z3foov' referenced in section `.text' of a_stripped.o: defined in discarded section `.text._Z3foov[_Z3foov]' of a_stripped.o\ncollect2: error: ld returned 1 exit status\nMakefile:28: recipe for target 'prog' failed\nmake: *** [prog] Error 1\n</code></pre>\n<p><strong>Why is that?</strong></p>\n<p>As you might now already see, it's because the <code>objcopy</code> intervention\ncreates an insoluble problem from the linker, as you can observe after\nthat last <code>make</code>:</p>\n<pre><code>$ readelf -s a_stripped.o | grep _Z3foov\n16: 0000000000000000    11 FUNC    LOCAL  DEFAULT    6 _Z3foov\n\n$ readelf -s b_stripped.o | grep _Z3foov\n16: 0000000000000000    11 FUNC    LOCAL  DEFAULT    6 _Z3foov\n</code></pre>\n<p>The symbol still has a definition in <code>a_stripped.o</code> and also in <code>b_stripped.o</code>,\nbut the definitions are now <code>LOCAL</code>, not available to satisfy external\nreferences from other object files. Both definitions are in input section <code>#6</code>:</p>\n<pre><code>$ readelf -t a_stripped.o\n  ...\n  ...\n  [ 6] .text._Z3foov\n       PROGBITS               PROGBITS         0000000000000000  0000000000000053  0\n       000000000000000b 0000000000000000  0                 1\n       [0000000000000206]: ALLOC, EXEC, GROUP\n\n\n$ readelf -t b_stripped.o\n  ...\n  ...\n[ 6] .text._Z3foov\n       PROGBITS               PROGBITS         0000000000000000  0000000000000053  0\n       000000000000000b 0000000000000000  0                 1\n       [0000000000000206]: ALLOC, EXEC, GROUP\n</code></pre>\n<p>which in each case remains a function-section <code>.text._Z3foov</code></p>\n<p>The linker can retain only one of the input <code>.text._Z3foov</code> function-sections\nfor output in the <code>.text</code> section of <code>prog</code> and must discard the rest, to\navert multiple definitions of <code>_Z3foov</code>. So it ticks the second-comer of those\ninput sections, whether in <code>a_stripped.o</code> or <code>b_stripped.o</code>, to be discarded.</p>\n<p>Say it's <code>b_stripped.o</code> that comes second. Our <code>objcopy</code> intervention has made <code>_Z3foov</code> <em>local</em> \nin both object files. So in <code>keepme_b()</code> the call to <code>foo()</code> can now <em>only</em> be resolved by\nthe local definition - the one that's assembled after label <code>.LFB0</code> in the assembly -\nwhich is in the <code>.text._Z3foov</code> function-section of <code>b_stripped.o</code> that is scheduled\nto be discarded. So that reference to <code>foo()</code> in <code>b_stripped.o</code> cannot be resolved in the program:</p>\n<pre><code>`_Z3foov' referenced in section `.text' of b_stripped.o: defined in discarded section `.text._Z3foov[_Z3foov]' of b_stripped.o\n</code></pre>\n<p>That's the explanation of your issue.</p>\n<p><strong>But...</strong></p>\n<p>... you might say: Isn't it an oversight on the linker's part not to check,\nbefore it decides to discard a function-section, if that section actually contains\nany a global function definition that might possibly collide with others?</p>\n<p>You could argue that, but not very persuasively. Function-sections are things that\nonly compilers create in the real world, and they are created for only two reasons:-</p>\n<ul>\n<li><p>To let the linker discard global functions that aren't called by the program, without\ncollateral damage.</p></li>\n<li><p>To let the linker discard rejected surplus definitions of global inline functions,\nwithout collateral damage.</p></li>\n</ul>\n<p>So it's reasonable for the linker to operate on the assumption that a function-section\nonly exists to contain a definition of a global function.</p>\n<p>A compiler will never trouble the linker with the scenario you've engineered,\nbecause a compiler just won't emit linkage sections that contain\nonly local symbols. In our MCVE, we've got the option of making <code>foo</code> a local\nsymbol in either <code>a.o</code> or <code>b.o</code> or both without going behind the compiler's\nback. We can either make it a <code>static</code> function or, more C++-ishly,\nwe can put it in an anonymous namespace. For a final experiment, let's do\nthat:</p>\n<p><strong>a.cpp (reprise)</strong></p>\n<pre><code>namespace {\n\ninline unsigned foo()\n{\n    return 0xf0a;\n}\n\n}\n\nunsigned keepme_a() {\n    return foo();\n}\n</code></pre>\n<p><strong>b.cpp (reprise)</strong></p>\n<pre><code>namespace {\n\ninline unsigned foo()\n{\n    return 0xf0b;\n}\n\n}\n\nunsigned keepme_b() {\n    return foo();\n}\n</code></pre>\n<p>Build and run:</p>\n<pre><code>$ make &amp;&amp; ./prog\ng++ -g -O0   -c -o a.o a.cpp\ng++ -g -O0   -c -o b.o b.cpp\ng++ -g -L. -Wl,--trace-symbol='_Z3foov',-M=prog.map,--cref -o prog main.o a.o b.o\nf0a\nf0b\n</code></pre>\n<p>Now naturally, <code>keepme_a()</code> and <code>keepme_b()</code> each call their local definition\nof <code>foo</code>, and:</p>\n<pre><code>$ nm -s a.o\n000000000000000b T _Z8keepme_av\n0000000000000000 t _ZN12_GLOBAL__N_13fooEv\n$ nm -s b.o\n000000000000000b T _Z8keepme_bv\n0000000000000000 t _ZN12_GLOBAL__N_13fooEv\n</code></pre>\n<p><code>_Z3foov</code> is gone from the global symbol tables<sup>1</sup>, and:</p>\n<pre><code>$ echo \\[$(readelf -t a.o | grep '.text._Z3foov')\\]\n[]\n$ echo \\[$(readelf -t b.o | grep '.text._Z3foov')\\]\n[]\n</code></pre>\n<p>the function-section <code>.text._Z3foov</code> is gone from both object files. The linker never knows of these local <code>foo</code>s existence.</p>\n<p>You don't have the option of getting <code>g++</code> to make <code>_ZStorSt13_Ios_OpenmodeS_</code>\n( = <code>std::operator|(_Ios_Openmode __a, _Ios_Openmode __b</code>) a local symbol\nin your implementation of the Standard C++ library short of hacking\n<code>ios_base.h</code>, which of course you wouldn't.</p>\n<p>But what you were trying to do was <em>hack the linkage</em> of this symbol\nfrom the Standard C++ library to make it local in one translation\nunit within your program and weakly global in another, and you blind-sided\nthe linker, and yourself.</p>\n<p><strong>So...</strong></p>\n<blockquote>\n<p id=\"so_43585237_43707540_2\">Am I doing the right thing by changing symbols to local in my library?</p>\n</blockquote>\n<p>No. Not unless they are symbols whose definitions <em>you</em> control,\nin your code, and then if you want them made local, make them local\nin the source code using one the language facilities for the purpose,\nand let the compiler take care of the object code.</p>\n<p>If you want to further minimise symbol bloat, see <a href=\"https://stackoverflow.com/q/6687630/1362568\">How to remove unused C/C++ symbols with GCC and ld?</a>\nSafe techniques allow the <em>compiler</em> to produce the lean object files\nthat are linked, and/or allow the <em>linker</em> to pare fat, or at least\noperate on the linked binary, post linkage.  </p>\n<p>Tampering with the object files <em>between</em> the compiler and the linker\nis tampering at your peril, and never more so than if its tampering\nwith the linkage of external library symbols.\n<hr>\n[1] <code>_ZN12_GLOBAL__N_13fooEv</code> (demangled = <code>(anonymous namespace)::foo()</code>)\nhas appeared, but it's local (<code>t</code>) not global (<code>T</code>) and is only\nin the symbol table at all because we're compiling with <code>-O0</code>.</hr></p>\n", "OwnerUserId": "1362568", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:02:16.023", "Id": "43707540", "Score": "8", "CreationDate": "2017-04-30T14:33:37.880", "LastActivityDate": "2017-05-01T07:48:23.220"}});