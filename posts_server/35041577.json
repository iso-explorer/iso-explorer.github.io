post_cb({"bq_ids": {"n4140": {"so_35041577_35041788_0": {"length": 12, "quality": 0.8, "section_id": 3913}, "so_35041577_35041790_1": {"length": 8, "quality": 0.8, "section_id": 378}, "so_35041577_35041790_0": {"length": 43, "quality": 0.9148936170212766, "section_id": 3913}}, "n3337": {"so_35041577_35041788_0": {"length": 12, "quality": 0.8, "section_id": 3773}, "so_35041577_35041790_1": {"length": 8, "quality": 0.8, "section_id": 369}, "so_35041577_35041790_0": {"length": 43, "quality": 0.9148936170212766, "section_id": 3773}}}, "35041790": {"PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_35041577_35041790_0\"><strong>[stmt.return]/2</strong> ...A return statement with an expression of non-void type can be used only in functions returning a value; the value of the expression is returned to the caller of the function. The value of the expression is implicitly converted to the return type of the function in which it appears. A return statement can involve the construction and copy or move of a temporary object (12.2)... A return statement with a <em>braced-init-list</em> initializes the object or reference to be returned from the function by copy-list-initialization (8.5.4) from the specified initializer list.</p>\n<p id=\"so_35041577_35041790_1\"><strong>[class.temporary]/1</strong> Temporaries of class type are created in various contexts: ... returning a prvalue (6.6.3) ...</p>\n</blockquote>\n<p>So yes, as far as I can tell, there's a semantic difference. <code>typedBrace</code> evaluates an expression <code>S{}</code>, which produces a prvalue of type <code>S</code>, then attempts to copy-construct its return value from that expression. <code>nakedBrace</code> instead constructs its return value straight from braced-init-list.</p>\n<p>It's the same situation as with <code>S s{};</code> (works) vs <code>S s = S{};</code> (doesn't work), just obscured somewhat by a level of indirection.</p>\n", "LastActivityDate": "2016-01-27T15:44:17.227", "Id": "35041790", "CommentCount": "0", "CreationDate": "2016-01-27T15:44:17.227", "ParentId": "35041577", "Score": "1", "OwnerUserId": "1670129"}, "35041788": {"PostTypeId": "2", "Body": "<p>This is standard behaviour.</p>\n<blockquote>\n<p id=\"so_35041577_35041788_0\"><code>N4140 [stmt.return]/2:</code> [...] A return statement with a braced-init-list initializes the object\n  or reference to be returned from the function by copy-list-initialization (8.5.4) from the specified initializer\n  list. [...]</p>\n</blockquote>\n<p>This means that the initializations carried out by <code>nakedBrace</code> and <code>typedBrace</code> are equivalent to these:</p>\n<pre><code>S nakedBrace = {}; //calls default constructor\nS typedBrace = S{}; //calls default, then copy constructor (likely elided)\n</code></pre>\n", "LastActivityDate": "2016-01-27T15:44:14.387", "Id": "35041788", "CommentCount": "0", "CreationDate": "2016-01-27T15:44:14.387", "ParentId": "35041577", "Score": "4", "OwnerUserId": "496161"}, "35041577": {"ViewCount": "83", "Body": "<p>Consider the following program:</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nstruct S\n{\n    S() = default;\n    S(const S&amp; other) = delete;\n    S(S&amp;&amp; other) = delete;\n    int i;\n};\n\nS nakedBrace()\n{\n     return {}; // no S constructed here?\n}\n\nS typedBrace()\n{\n     return S{};\n}\n\nint main()\n{\n    // produce an observable effect.\n    cout &lt;&lt; nakedBrace().i &lt;&lt; endl; // ok\n    cout &lt;&lt; typedBrace().i &lt;&lt; endl; // error: deleted move ctor\n}\n</code></pre>\n<p>Sample session:</p>\n<pre><code>$ g++ -Wall -std=c++14 -o no-copy-ctor no-copy-ctor.cpp\nno-copy-ctor.cpp: In function 'S typedBrace()':\nno-copy-ctor.cpp:19:12: error: use of deleted function 'S::S(S&amp;&amp;)'\n   return S{};\n            ^\nno-copy-ctor.cpp:8:5: note: declared here\n     S(S&amp;&amp; other) = delete;\n</code></pre>\n<p>It astonishes me that gcc accepts <code>nakedBrace()</code>. I thought that conceptually the two functions are equivalent: A temporary <code>S</code> is constructed and returned. Copy elision may or may not be performed, but the move or copy ctor (both are deleted here) must still be accessible, as mandated by the standard (12.8/32).</p>\n<p>Does that mean that <code>nakedBrace()</code> never constructs an S? Or it does, but directly in the return value with brace-initialization, so that no copy move/ctor is conceptually required? </p>\n", "AcceptedAnswerId": "35041788", "Title": "Returning temporaries of type with deleted move/copy ctor", "CreationDate": "2016-01-27T15:35:10.460", "Id": "35041577", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2016-01-27T15:44:17.227", "Score": "6", "OwnerUserId": "3150802", "Tags": "<c++><temporary><copy-elision>", "AnswerCount": "2"}});