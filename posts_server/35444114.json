post_cb({"bq_ids": {"n4140": {"so_35444114_35445106_1": {"length": 7, "quality": 0.875, "section_id": 743}, "so_35444114_35445106_5": {"length": 5, "quality": 1.0, "section_id": 6324}, "so_35444114_35445106_3": {"length": 6, "quality": 1.0, "section_id": 6276}, "so_35444114_35445106_4": {"length": 23, "quality": 0.9583333333333334, "section_id": 6323}, "so_35444114_35445106_0": {"length": 23, "quality": 0.92, "section_id": 757}}, "n3337": {"so_35444114_35445106_1": {"length": 7, "quality": 0.875, "section_id": 732}, "so_35444114_35445106_5": {"length": 5, "quality": 1.0, "section_id": 6081}, "so_35444114_35445106_3": {"length": 6, "quality": 1.0, "section_id": 6036}, "so_35444114_35445106_4": {"length": 23, "quality": 0.9583333333333334, "section_id": 6080}, "so_35444114_35445106_0": {"length": 15, "quality": 0.6, "section_id": 745}}, "n4659": {"so_35444114_35445106_1": {"length": 7, "quality": 0.875, "section_id": 801}, "so_35444114_35445106_5": {"length": 5, "quality": 1.0, "section_id": 7834}, "so_35444114_35445106_3": {"length": 6, "quality": 1.0, "section_id": 7783}, "so_35444114_35445106_4": {"length": 23, "quality": 0.9583333333333334, "section_id": 7833}, "so_35444114_35445106_0": {"length": 23, "quality": 0.92, "section_id": 817}}}, "35444114": {"ViewCount": "238", "Body": "<p>I was reading <a href=\"http://www.cplusplus.com/reference/unordered_map/unordered_map/\" rel=\"nofollow\">C++ reference page</a> about <code>std::unordered_map</code>. The \n<a href=\"http://www.cplusplus.com/reference/unordered_map/unordered_map/empty/\" rel=\"nofollow\"><code>empty</code></a> and <a href=\"http://www.cplusplus.com/reference/unordered_map/unordered_map/size/\" rel=\"nofollow\"><code>size</code></a> methods are <code>noexcept</code> qualified, but not <a href=\"http://www.cplusplus.com/reference/unordered_map/unordered_map/count/\" rel=\"nofollow\"><code>count</code></a>.</p>\n<p>I don't think it should throw in <code>count</code>.</p>\n<p>Am I missing something?</p>\n", "AcceptedAnswerId": "35445106", "Title": "Why is there no `noexcept` specifier on std::unordered_map::count?", "CreationDate": "2016-02-16T22:18:41.020", "Id": "35444114", "CommentCount": "6", "LastEditDate": "2016-08-17T21:36:20.900", "PostTypeId": "1", "LastEditorUserId": "4892076", "LastActivityDate": "2016-08-17T21:36:20.900", "Score": "2", "OwnerUserId": "5037799", "Tags": "<c++><c++11><language-lawyer><unordered-map><noexcept>", "AnswerCount": "1"}, "35445106": {"Id": "35445106", "PostTypeId": "2", "Body": "<p>Because the requirements say so:</p>\n<p><code>count</code> returns the number of elements matching a specific key, and key comparisons are evaluated off of an object of type <code>X::key_type</code> for any unordered associative container type <code>X</code> (instantiated <code>std::unordered_map</code>s are such containers)</p>\n<p><em>n3337 23.2.5/5 [unord.req]</em></p>\n<blockquote>\n<p id=\"so_35444114_35445106_0\">Two values <code>k1</code> and <code>k2</code> of type <code>Key</code> are considered equivalent if the container\u2019s key equality predicate returns <code>true</code> when passed those values. ... For any two keys <code>k1</code> and <code>k2</code> in the same container, calling<code>pred(k1, k2)</code> shall always return the same value. ...</p>\n</blockquote>\n<p>For an unordered map, <code>X::key_type</code> is defined as part of its template parameter list: </p>\n<pre><code>template&lt;\n    class Key,\n    //    ^^^ member type key_type set from this parameter\n    class T,\n    class Hash = std::hash&lt;Key&gt;,\n    class KeyEqual = std::equal_to&lt;Key&gt;,\n    //    ^^^^^^^^ member type key_equal set from this parameter\n    class Allocator = std::allocator&lt; std::pair&lt;const Key, T&gt; &gt;\n&gt; class unordered_map;\n</code></pre>\n<p>The only constraints I can find on <code>key_type</code> also applies to <code>value_type</code>:</p>\n<p><em>n3337 23.2.5/9 [unord.req]</em><sup>2</sup></p>\n<blockquote>\n<p id=\"so_35444114_35445106_1\">... the requirements placed on <code>value_type</code> in Table 96 apply instead to <code>key_type</code> and <code>mapped_type</code>.</p>\n</blockquote>\n<p>So we just need to know the requirements placed on <code>value_type</code> in table 96, which specifies the requirements for a <code>Container</code>. In the very first row, we have:</p>\n<p><em>n3337, table 96</em><sup>3</sup></p>\n<blockquote>\n<p id=\"so_35444114_35445106_2\"><code>X::value_type</code> | Returns <code>T</code> | <em>Requires:</em> <code>T</code> is <code>Destructible</code></p>\n</blockquote>\n<p>where <code>X</code> is again the type of the Container, and <code>T</code> is the type of objects it's storing. <code>Destructible</code>objects are not allowed to have throwing destructors. That's their only requirement.</p>\n<p><em>n3337, table 24</em></p>\n<blockquote>\n<p id=\"so_35444114_35445106_3\"><code>u.\u223cT()</code> All resources owned by <code>u</code> are reclaimed, no exception is propagated</p>\n</blockquote>\n<p>(<code>u</code> being an object of type <code>T</code> which fulfills the requirements of <code>Destructible</code>)</p>\n<p>Thus, <strong>there is no restriction on the throw guarantees offered by the key comparison function</strong> for the <code>unordered_map</code>, and so no guarantee on the <code>operator==</code> operation provided from <code>std::equal_to</code> to implement the required behavior. The key itself lacks any such restrictions, <strong>so: the comparison function is allowed to throw, and any function which uses the comparison function is also allowed to throw.</strong> <code>count</code> needs to count the stored values with keys that match the supplied key with the comparison function, so it may throw.</p>\n<hr>\n<p><code>clear</code> may be <code>noexcept</code> because the standard bans throwing in destructors: </p>\n<p><em>17.6.4.8/1,2</em><sup>4</sup> [res.on.functions]</p>\n<blockquote>\n<p id=\"so_35444114_35445106_4\">In certain cases (replacement functions, handler functions, operations on types used to instantiate standard library template components), the C++ standard library depends on components supplied by a C++ program. If these components do not meet their requirements, the Standard places no requirements on the implementation.  </p>\n<p id=\"so_35444114_35445106_5\">In particular, the effects are undefined in the following cases:</p>\n<p id=\"so_35444114_35445106_6\">...</p>\n<ul>\n<li>if any replacement function or handler function or <strong>destructor operation exits via an exception</strong>, unless specifically allowed in the applicable <em>Required behavior:</em> paragraph.</li>\n</ul>\n<p id=\"so_35444114_35445106_7\">...</p>\n</blockquote>\n<p>since the only client-dependent code <code>clear</code> executes may not throw exceptions, and the implementation doesn't need to, it may be and has been marked <code>noexcept</code></p>\n<hr>\n<p>Notes:</p>\n<p><sup>1. The n4140 standard draft (near c++14) does not appear to have changed this clause at all.</sup> </p>\n<p><sup>2. n4140 retains this phrasing, moved to clause 10 from clause 9.</sup></p>\n<p><sup>3. The <code>Container</code> requirements are also listed in Table 96 of n4140, and list the requirement for <code>T</code> as being <a href=\"http://en.cppreference.com/w/cpp/concept/Erasable\" rel=\"nofollow\"><code>Erasable</code></a>, which also places no restrictions on <code>operator==</code> </sup></p>\n<p><sup>4. The wording of this clause hasn't changed in n4140.</sup></p>\n</hr></hr>", "LastEditorUserId": "4892076", "LastActivityDate": "2016-02-17T00:58:34.390", "Score": "5", "CreationDate": "2016-02-16T23:32:56.997", "ParentId": "35444114", "CommentCount": "2", "OwnerUserId": "4892076", "LastEditDate": "2016-02-17T00:58:34.390"}});