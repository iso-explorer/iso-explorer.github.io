post_cb({"12031781": {"CommentCount": "15", "ViewCount": "162", "CreationDate": "2012-08-20T02:52:33.537", "LastActivityDate": "2012-08-20T03:57:43.353", "Title": "How to correctly (yet efficiently) implement something like \"vector::insert\"? (Pointer aliasing)", "AcceptedAnswerId": "12032000", "PostTypeId": "1", "Id": "12031781", "Score": "6", "Body": "<p>Consider this hypothetical implementation of <code>vector</code>:</p>\n<pre><code>template&lt;class T&gt;  // ignore the allocator\nstruct vector\n{\n    typedef T* iterator;\n    typedef const T* const_iterator;\n\n    template&lt;class It&gt;\n    void insert(iterator where, It begin, It end)\n    {\n        ...\n    }\n\n    ...\n}\n</code></pre>\n<h3>Problem</h3>\n<p>There is a subtle problem we face here:<br>\nThere is the possibility that <code>begin</code> and <code>end</code> refer to items in the same vector, <em>after</em> <code>where</code>.</br></p>\n<p>For example, if the user says:</p>\n<pre><code>vector&lt;int&gt; items;\nfor (int i = 0; i &lt; 1000; i++)\n    items.push_back(i);\nitems.insert(items.begin(), items.end() - 2, items.end() - 1);\n</code></pre>\n<p>If <code>It</code> is not a pointer type, then we're fine.<br>\nBut we don't know, so we must check that <code>[begin, end)</code> does not refer to a range already inside the vector.</br></p>\n<p>But how do we do this? According to C++, if they <em>don't</em> refer to the same array, then pointer comparisons would be undefined!<br>\nSo the compiler could falsely tell us that the items don't alias, when in fact they do, giving us unnecessary O(n) slowdown.</br></p>\n<h3>Potential solution &amp; caveat</h3>\n<p>One solution is to copy the <em>entire</em> vector <em>every</em> time, to include the new items, and then throw away the old copy.</p>\n<p>But that's very slow in scenarios such as in the example above, where we'd be copying 1000 items just to insert 1 item, even though we might clearly already have enough capacity.</p>\n<h3>Is there a generic way to (correctly) solve this problem efficiently, i.e. <em>without</em> suffering from O(n) slowdown in cases where nothing is aliasing?</h3>\n", "Tags": "<c++><aliasing>", "OwnerUserId": "541686", "AnswerCount": "3"}, "12032000": {"ParentId": "12031781", "CommentCount": "4", "Body": "<p>You can use the predicates <code>std::less</code> etc, which are guaranteed to give a total order, even when the raw pointer comparisons do not.</p>\n<p>From the standard <code>[comparisons]/8</code>:</p>\n<blockquote>\n<p id=\"so_12031781_12032000_0\">For templates greater, less, greater_equal, and less_equal, the specializations for any pointer type yield a total order, even if the built-in operators &lt;, &gt;, &lt;=, &gt;= do not.</p>\n</blockquote>\n", "OwnerUserId": "485561", "PostTypeId": "2", "Id": "12032000", "Score": "6", "CreationDate": "2012-08-20T03:31:57.113", "LastActivityDate": "2012-08-20T03:31:57.113"}, "12032130": {"ParentId": "12031781", "CommentCount": "1", "Body": "<p>Actually, this would be true <em>even if they were regular iterators</em>. There's nothing stopping anyone doing </p>\n<pre><code>std::vector&lt;int&gt; v; \n// fill v \nv.insert(v.end() - 3, v.begin(), v.end());\n</code></pre>\n<p>Determining if they alias is a problem for <em>any</em> implementation of iterators.</p>\n<p>However, the thing you're missing is that <em>you're the implementation</em>, you don't have to use portable code. As the implementation, you can do whatever you want. You could say \"Well, in <em>my</em> implementation, I follow x86 and <code>&lt;</code> and <code>&gt;</code> are fine to use for any pointers.\". And that would be fine.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "12032130", "Score": "0", "CreationDate": "2012-08-20T03:57:43.353", "LastActivityDate": "2012-08-20T03:57:43.353"}, "bq_ids": {"n4140": {"so_12031781_12032000_0": {"section_id": 4605, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_12031781_12032000_0": {"section_id": 4423, "quality": 0.9333333333333333, "length": 14}, "so_12031781_12032052_2": {"section_id": 5913, "quality": 1.0, "length": 4}, "so_12031781_12032052_1": {"section_id": 5913, "quality": 1.0, "length": 13}}, "n4659": {"so_12031781_12032000_0": {"section_id": 5962, "quality": 0.7333333333333333, "length": 11}, "so_12031781_12032052_1": {"section_id": 7709, "quality": 0.5384615384615384, "length": 7}}}, "12032052": {"ParentId": "12031781", "CommentCount": "6", "Body": "<blockquote>\n<p id=\"so_12031781_12032052_0\">But how do we do this? According to C++, if they <em>don't</em> refer to the same array, then pointer comparisons would be undefined!</p>\n</blockquote>\n<p>Wrong.  The pointer comparisons are <em>unspecified</em>, not undefined.  From C++03 \u00a75.9/2 [expr.rel]:</p>\n<blockquote>\n<p id=\"so_12031781_12032052_1\">[...] Pointers to objects or functions of the same type (after pointer conversions) can be compared, with a result defined as follows:</p>\n<p id=\"so_12031781_12032052_2\">[...]<br>\n  -Other pointer comparisons are unspecified.</br></p>\n</blockquote>\n<p>So it's safe to test if there is an overlap before doing the expensive-but-correct copy.</p>\n<p>Interestingly, C99 differs from C++ in this, in that pointer comparisons between unrelated objects is undefined behavior.  From C99 \u00a76.5.8/5:</p>\n<blockquote>\n<p id=\"so_12031781_12032052_3\">When two pointers are compared, the result depends on the relative locations in the address space of the objects pointed to. [...] In all other cases, the behavior is undefined.</p>\n</blockquote>\n", "OwnerUserId": "9530", "PostTypeId": "2", "Id": "12032052", "Score": "0", "CreationDate": "2012-08-20T03:43:33.513", "LastActivityDate": "2012-08-20T03:43:33.513"}});