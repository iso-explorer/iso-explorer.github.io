post_cb({"bq_ids": {"n4140": {"so_24959192_24959192_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 7181}, "so_24959192_24959192_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 7181}, "so_24959192_24959519_0": {"length": 65, "quality": 0.9285714285714286, "section_id": 6103}, "so_24959192_24959519_2": {"length": 84, "quality": 1.0, "section_id": 7181}}, "n3337": {"so_24959192_24959192_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 6925}, "so_24959192_24959519_0": {"length": 54, "quality": 0.7714285714285715, "section_id": 5869}, "so_24959192_24959519_2": {"length": 84, "quality": 1.0, "section_id": 6925}}, "n4659": {"so_24959192_24959192_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 8689}, "so_24959192_24959192_0": {"length": 8, "quality": 0.6153846153846154, "section_id": 8689}, "so_24959192_24959519_0": {"length": 63, "quality": 0.9, "section_id": 7600}}}, "24959320": {"Id": "24959320", "PostTypeId": "2", "Body": "<p>I believe you're getting undefined behavior. I think if the constructor fails and the array has to be deallocated it's not possible to distinguish between the right placement delete function and the sized delete function.</p>\n", "LastActivityDate": "2014-07-25T15:32:40.157", "CommentCount": "2", "CreationDate": "2014-07-25T15:32:40.157", "ParentId": "24959192", "Score": "0", "OwnerUserId": "365496"}, "24959192": {"ViewCount": "325", "Body": "<p>i'm using g++ 4.9.0 and N3797 working draft. I've written the following simple example: </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstdlib&gt;\n\nusing namespace std;\n\nstruct A\n{\n    void* operator new[](size_t t, size_t)\n    {\n        cout &lt;&lt; \"allocation\" &lt;&lt; endl;\n        return ::operator new[](t);\n    }\n\n    void operator delete[](void *p, size_t t)\n    {\n        cout &lt;&lt; \"deallocation\" &lt;&lt; endl;\n        :: operator delete[](p);\n    }\n};\n\nint main()\n{\n    A *a = new (90) A[5];\n    delete [] a;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/abb5ff8a08d97afb\" rel=\"nofollow\">demo</a></p>\n<p>The example must reflect the following footnote rule from the section 3.7.4.2/2:</p>\n<blockquote>\n<p id=\"so_24959192_24959192_0\">The global operator delete[] with exactly two parameters, the second\n  of which has type std::size_t, is a usual deallocation function.37</p>\n<p id=\"so_24959192_24959192_1\">37) This deallocation function precludes use of an allocation function\n  void operator new(std::size_t, std::size_t) as a placement allocation\n  function</p>\n</blockquote>\n<p>But it doesn't. It is a bug or footnote is just a recommendation for implementors?</p>\n", "AcceptedAnswerId": "24959519", "Title": "g++ 4.9.0 allows us to use operator delete[](void*, size_t) with placement allocation", "CreationDate": "2014-07-25T15:25:19.183", "Id": "24959192", "CommentCount": "5", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "LastActivityDate": "2014-07-25T19:58:50.220", "Score": "2", "Tags": "<c++><memory-management><g++>", "AnswerCount": "2"}, "24959519": {"Id": "24959519", "PostTypeId": "2", "Body": "<p>This is illegal and the compiler should have emitted a diagnostic. From \u00a75.3.4 [expr.new]/p22, emphasis added:</p>\n<blockquote>\n<p id=\"so_24959192_24959519_0\">A declaration of a placement deallocation function matches the\n  declaration of a placement allocation function if it has the same\n  number of parameters and, after parameter transformations (8.3.5), all\n  parameter types except the first are identical. If the lookup finds a\n  single matching deallocation function, that function will be called;\n  otherwise, no deallocation function will be called. <strong>If the lookup\n  finds the two-parameter form of a usual deallocation function\n  (3.7.4.2) and that function, considered as a placement deallocation\n  function, would have been selected as a match for the allocation\n  function, the program is ill-formed.</strong> For a non-placement allocation\n  function, the normal deallocation function lookup is used to find the\n  matching deallocation function (5.3.5) [ <em>Example</em>:</p>\n<pre><code>struct S {\n     // Placement allocation function:\n    static void* operator new(std::size_t, std::size_t);\n    // Usual (non-placement) deallocation function:\n    static void operator delete(void*, std::size_t);\n};\nS* p = new (0) S; // ill-formed: non-placement deallocation function matches\n                  // placement allocation function\n</code></pre>\n<p id=\"so_24959192_24959519_1\">\u2014<em>end example</em> ]</p>\n</blockquote>\n<p>Clang <a href=\"http://coliru.stacked-crooked.com/a/ed62b27b9283ee1a\" rel=\"nofollow\">generates</a> an error on your code.</p>\n<p>However, note that unlike global <code>operator delete</code> and <code>operator delete[]</code>, two-parameter <code>operator delete</code> and <code>operator delete[]</code> that are class members are not necessarily a usual deallocation function (\u00a73.7.4.2 [basic.stc.dynamic.deallocation]/p2):</p>\n<blockquote>\n<p id=\"so_24959192_24959519_2\">If a class <code>T</code> has a member deallocation function named <code>operator delete</code>\n  with exactly one parameter, then that function is a usual\n  deallocation function. If class <code>T</code> does not declare such an <code>operator delete</code>\n  but does declare a member deallocation function named <code>operator delete</code>\n  with exactly two parameters, the second of which has type\n  <code>std::size_t</code>, then this function is a usual deallocation function.\n  Similarly, if a class <code>T</code> has a member deallocation function named\n  <code>operator delete[]</code> with exactly one parameter, then that function is\n  a usual (non-placement) deallocation function. If class T does not\n  declare such an <code>operator delete[]</code> but does declare a member\n  deallocation function named <code>operator delete[]</code> with exactly two\n  parameters, the second of which has type <code>std::size_t</code>, then this\n  function is a usual deallocation function.</p>\n</blockquote>\n<p>Thus, unlike the global deallocation functions, if you declare a member <code>operator delete[] (void *)</code>, then <code>operator delete[] (void *, std::size_t)</code> is no longer a usual deallocation function but a placement deallocation function:</p>\n<pre><code>struct A\n{\n    void* operator new[](size_t t, size_t)\n    {\n        cout &lt;&lt; \"allocation\" &lt;&lt; endl;\n        return ::operator new[](t);\n    }\n\n    void operator delete[](void *p)\n    {\n        cout &lt;&lt; \"deallocation - usual\" &lt;&lt; endl;\n        :: operator delete[](p);\n    }\n    void operator delete[](void *p, size_t t)\n    {\n        cout &lt;&lt; \"deallocation - placement\" &lt;&lt; endl;\n        :: operator delete[](p);\n    }\n};\n</code></pre>\n<p>And clang <a href=\"http://coliru.stacked-crooked.com/a/93caeaa8f890609b\" rel=\"nofollow\">no longer</a> reports an error on this code.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-07-25T19:58:50.220", "Score": "4", "CreationDate": "2014-07-25T15:41:48.550", "ParentId": "24959192", "CommentCount": "0", "LastEditDate": "2014-07-25T19:58:50.220", "OwnerUserId": "2756719"}});