post_cb({"bq_ids": {"n4140": {"so_29707685_29708019_5": {"length": 43, "quality": 0.9555555555555556, "section_id": 6095}, "so_29707685_29708019_1": {"length": 5, "quality": 1.0, "section_id": 6095}, "so_29707685_29708019_4": {"length": 5, "quality": 1.0, "section_id": 6095}, "so_29707685_29708019_3": {"length": 5, "quality": 1.0, "section_id": 6095}, "so_29707685_29708019_2": {"length": 5, "quality": 1.0, "section_id": 6095}}, "n3337": {"so_29707685_29708019_5": {"length": 43, "quality": 0.9555555555555556, "section_id": 5861}, "so_29707685_29708019_1": {"length": 5, "quality": 1.0, "section_id": 5861}, "so_29707685_29708019_4": {"length": 5, "quality": 1.0, "section_id": 5861}, "so_29707685_29708019_3": {"length": 5, "quality": 1.0, "section_id": 5861}, "so_29707685_29708019_2": {"length": 5, "quality": 1.0, "section_id": 5861}}, "n4659": {"so_29707685_29708019_5": {"length": 42, "quality": 0.9333333333333333, "section_id": 7592}}}, "29708019": {"Id": "29708019", "PostTypeId": "2", "Body": "<p>Yes, it will zero-initialize memory because of the <code>{}</code> at the end of the line, as long as <code>malloc</code> doesn't fail from within the placement <code>new</code>.   Here's an alternative version that more completely proves the point.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cassert&gt;\n#include &lt;new&gt;\n\nchar mongo[10];\n\nint main()\n{\n    for (int i=0; i &lt; 10; ++i)\n        mongo[i] = 'a';\n    char *p = new (mongo) char[10]{};\n    for (int i= 0; i &lt; 10; ++i)\n        assert(p[i] == '\\0');\n}\n</code></pre>\n<p>This program will run and print nothing because the <code>mongo</code> array (aliased by <code>p</code>) is explicitly cleared by the initialization of <code>p</code>.  By contrast, if we omit the <code>{}</code> at the end of that line, the program will assert and terminate.</p>\n<p>Note that in your version using <code>malloc</code>, you will have to explicitly destroy the object -- that's part of the responsibility that comes with placement <code>new</code> and among the few times in modern C++ where one must explictly call a destructor.</p>\n<p>If, as in your particular case, you are allocating memory with <code>malloc()</code> you must issue a corresponding <code>free(p)</code> or your program will leak memory.</p>\n<h2>The elephant in the room</h2>\n<p>(Thanks, @TC, for pointing to the big gray thing!)  Here's an explanation and example straight from the standard (section 5.3.4): </p>\n<blockquote>\n<p id=\"so_29707685_29708019_0\">Example:</p>\n<p id=\"so_29707685_29708019_1\"><code>new T</code> results in a call of <code>operator new(sizeof(T))</code>,</p>\n<p id=\"so_29707685_29708019_2\"><code>new(2,f) T</code> results in a call of <code>operator new(sizeof(T),2,f)</code>,</p>\n<p id=\"so_29707685_29708019_3\"><code>new T[5]</code> results in a call of <code>operator new[](sizeof(T)*5+x)</code>, and</p>\n<p id=\"so_29707685_29708019_4\"><code>new(2,f) T[5]</code> results in a call of <code>operator new[](sizeof(T)*5+y,2,f)</code>.</p>\n<p id=\"so_29707685_29708019_5\">Here, x and y are non-negative unspecified values representing array allocation overhead; the result of the <em>new-expression</em> will be offset by this amount from the value returned by <code>operator new[]</code>. This overhead may be applied in all array <em>new-expressions</em>, including those referencing the library function operator <code>new[](std::size_t, void*)</code> and other placement allocation functions. The amount of overhead may vary from one invocation of new to another.</p>\n</blockquote>\n<p>In other words, if you use placement <code>new</code> for a single object, everything is fine and there is no inserted overhead, but if you allocate an <strong>array</strong> via placement <code>new</code>, there may be overhead, and it might not even be the same size from invocation to invocation.  </p>\n", "LastEditorUserId": "3191481", "LastActivityDate": "2015-04-17T21:06:23.760", "Score": "7", "CreationDate": "2015-04-17T19:38:38.800", "ParentId": "29707685", "CommentCount": "4", "OwnerUserId": "3191481", "LastEditDate": "2015-04-17T21:06:23.760"}, "29707685": {"ViewCount": "148", "Body": "\n<p>Will the following code correctly zero-initialize the memory returned from <code>malloc</code>?</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>#include &lt;cstdlib&gt;\n#include &lt;new&gt;\n\nint main()\n{\n    char* p = new (std::malloc(10)) char[10]{};\n}\n</code></pre>\n", "AcceptedAnswerId": "29708019", "Title": "Zero-initialize data using value-initialized array", "CreationDate": "2015-04-17T19:19:02.767", "Id": "29707685", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-04-17T21:06:23.760", "Score": "7", "OwnerUserId": "1594090", "Tags": "<c++><c++11>", "AnswerCount": "2"}, "29709041": {"Id": "29709041", "PostTypeId": "2", "Body": "<p>This is a very, very bad idea.</p>\n<p>Currently, placement array <code>new</code>, like all array <code>new</code> expressions, is allowed to add an unspecified amount of overhead. There is no portable way for the program to know how many bytes this overhead is.</p>\n<p>Therefore, unless the implementation's array allocation overhead for <code>char[10]</code> is zero, your code has undefined behavior.</p>\n<p><em>If</em> the pointer points to sufficient memory to accommodate all the array elements plus the unspecified overhead amount (and that's a very big if, since there's no portable way for you to be sure), then the expression will indeed zero-initialize the memory.</p>\n", "LastActivityDate": "2015-04-17T20:46:38.217", "CommentCount": "2", "CreationDate": "2015-04-17T20:46:38.217", "ParentId": "29707685", "Score": "5", "OwnerUserId": "2756719"}});