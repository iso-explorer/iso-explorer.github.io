post_cb({"bq_ids": {"n4140": {"so_19176287_19177818_4": {"length": 9, "quality": 0.8181818181818182, "section_id": 7151}}, "n3337": {"so_19176287_19177818_4": {"length": 11, "quality": 1.0, "section_id": 6895}}, "n4659": {"so_19176287_19177818_4": {"length": 6, "quality": 0.5454545454545454, "section_id": 385}}}, "19176656": {"Id": "19176656", "PostTypeId": "2", "Body": "<p><code>UINT_MAX</code> is about 4 billion on most modern machines. Because a <code>std::bitset&lt;N&gt;</code> stores <code>N</code> bits, this translates into 0.5 Gigabytes of memory (4 billion / 8) required for such a <code>std::bitset</code>. The overhead you see is probably due to internal compiler optimizations.</p>\n<p>Some small experiments on <a href=\"http://coliru.stacked-crooked.com/\" rel=\"nofollow\">http://coliru.stacked-crooked.com/</a>:</p>\n<ul>\n<li><a href=\"http://coliru.stacked-crooked.com/a/afb3e00484688910\" rel=\"nofollow\">Clang -std=c++98</a>: OK</li>\n<li><a href=\"http://coliru.stacked-crooked.com/a/14c3fb23f3f27d34\" rel=\"nofollow\">Clang -std=c++11</a>: FAIL</li>\n<li><a href=\"http://coliru.stacked-crooked.com/a/20b3b33a46f4f054\" rel=\"nofollow\">g++ -std=c++98</a>: FAIL</li>\n<li><a href=\"http://coliru.stacked-crooked.com/a/57b4f76c6dce0533\" rel=\"nofollow\">g++ -std=c++11</a>: FAIL</li>\n</ul>\n<p>So at least for Clang, the lack of <code>constexpr</code> in C++98 will allow you to compile this program without problems on reasonable resources (not sure on how much memory Coliru allows clients).</p>\n", "LastEditorUserId": "819272", "LastActivityDate": "2013-10-04T08:33:52.810", "Score": "0", "CreationDate": "2013-10-04T08:28:21.017", "ParentId": "19176287", "CommentCount": "1", "LastEditDate": "2013-10-04T08:33:52.810", "OwnerUserId": "819272"}, "19176588": {"Id": "19176588", "PostTypeId": "2", "Body": "<p>A <code>std::bitset</code> does not allocate its storage dynamically, it is contained in the object itself. This means that the compiler is most likely trying to track its state to allow constant folding and other optimizations. The fact that <code>constexpr</code> is used in some places also contributes to this. This, including some overhead to track the value of individual parts of the <code>bitset</code> will cause it to allocate tons of internal structures.</p>\n<p>I'm not sure in which cases this is triggered and it might be different on different compilers/versions or depend on certain settings.</p>\n", "LastActivityDate": "2013-10-04T08:24:43.273", "Score": "0", "CreationDate": "2013-10-04T08:24:43.273", "ParentId": "19176287", "CommentCount": "0", "OwnerUserId": "2073257"}, "19176287": {"ViewCount": "664", "Body": "<p>While compiling my program today, I noticed something very strange (which I'm sure can be explained somehow) in the memory consumption pattern of GCC (compilation step). The process called \"cc1plus\" was using approximately  10 GB of RAM for a program with less than 10 000 lines of code. After commenting and uncommenting lines of code I finally found the \"culprit\":</p>\n<pre><code>std::bitset&lt;UINT_MAX&gt;\n</code></pre>\n<p>If you want to test yourselves, please try this very short program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;bitset&gt;\n#include &lt;climits&gt;\n\nstd::bitset&lt;UINT_MAX&gt; justAVar;\n\nint main()\n{\n   std::cout &lt;&lt; UINT_MAX &lt;&lt; std::endl;\n   return 0;\n}\n</code></pre>\n<p>compile it using <em>-std=c++11</em> or <em>-std=c++0x</em>\nand please be aware that even this little example will use a lot of RAM <strong>when compiling</strong> (in my case 7 GB on both boxes for gcc and 2.6 for clang) so if you have to push the reset button, don't whine and curse the gods like you haven't been warned about it.</p>\n<p>My test machines:</p>\n<p>Setup 1: Debian 7.0 64, gcc 4.8.1</p>\n<p>Setup 2: Ubuntu 12.04 64, gcc 4.7.3, gcc 4.8.1, clang 3.0.6 (the last one using <em>-std=c++0x</em>) </p>\n<p>One hint about the implementation of the bitset constructor (guarded by if def for C++11 and C++0x, obviously), as one of my kind colleagues showed me: it is declared using <em>constexpr</em></p>\n<p>And now the question: Can someone please explain me (us) what it is going on in this case with all these compilers?</p>\n<p>Thank you</p>\n", "AcceptedAnswerId": "19177818", "Title": "GCC c++11 using a lot of RAM with STL bitset<UINT_MAX>", "CreationDate": "2013-10-04T08:06:47.640", "Id": "19176287", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-10-04T08:28:15.087", "LastEditorUserId": "2845612", "LastActivityDate": "2013-10-04T09:29:55.380", "Score": "2", "OwnerUserId": "2845612", "Tags": "<c++><linux><gcc><c++11><clang>", "AnswerCount": "3"}, "19177818": {"Id": "19177818", "PostTypeId": "2", "Body": "<p>Looking at the <code>bitset</code> implementation, which begins like this:</p>\n<pre><code>template&lt;size_t _Nw&gt;\nstruct _Base_bitset\n{\n  typedef unsigned long _WordT;\n\n\n  _WordT _M_w[_Nw];\n\n  constexpr _Base_bitset()\n  : _M_w() { }\n</code></pre>\n<p>we can create a minimal testcase like this:</p>\n<pre><code>template&lt;unsigned N&gt; \nstruct bset\n{\n    unsigned int v[N/32];\n\n    constexpr bset() : v() {}   \n};\n\n\nbset&lt;1000000000&gt; x;\n</code></pre>\n<p>The bitset must be initialized by constant initialization:</p>\n<blockquote>\n<p id=\"so_19176287_19177818_0\">3.6.2 Initialization of non-local variables [basic.start.init]</p>\n<p id=\"so_19176287_19177818_1\">...</p>\n<p id=\"so_19176287_19177818_2\">Constant initialization is performed:</p>\n<p id=\"so_19176287_19177818_3\">...</p>\n<p id=\"so_19176287_19177818_4\">\u2014 if an object with static or thread storage duration is initialized\n  by a constructor call,    if the constructor is a constexpr\n  constructor ...</p>\n</blockquote>\n<p>In practical terms and <em>in the general case</em>, it means evaluating at compile time the memory image of the constructed object and allocating it in the <code>.data</code> section.</p>\n<p>Well, it turns out that if the memory image is just a lot of zeroes, gcc is smart enough to figure that out and allocate the objects in <code>.bss</code>, but <em>it looks like</em>, it first has to create the image and examine it.</p>\n<p>Of course, a better approach would be to <em>infer</em> that if the only member of the <code>bitset</code>, is value-initialized and that member is an array and the elements of the array have no constructors and therefore their value-initialization is zero-initialization, then array is zero-initialized, then the object is zero-initialized and be done with that.</p>\n", "LastActivityDate": "2013-10-04T09:29:55.380", "Score": "2", "CreationDate": "2013-10-04T09:29:55.380", "ParentId": "19176287", "CommentCount": "0", "OwnerUserId": "390807"}});