post_cb({"45861694": {"Id": "45861694", "PostTypeId": "2", "Body": "<p>A <code>static_cast</code> is valid if there is an <a href=\"http://eel.is/c++draft/expr.static.cast#4.sentence-1\" rel=\"nofollow noreferrer\">implicit conversion sequence</a> from the expression to the desired type, and the resulting object is <a href=\"http://eel.is/c++draft/expr.static.cast#4.sentence-3\" rel=\"nofollow noreferrer\">direct-initialized</a> from the expression. So writing:</p>\n<pre><code>my_opt = static_cast&lt;std::optional&lt;int&gt;&gt;(my_foo);\n</code></pre>\n<p>Follows the same steps as doing:</p>\n<pre><code>std::optional&lt;int&gt; __tmp(my_foo); // direct-initialize the resulting\n                                  // object from the expression\nmy_opt = std::move(__tmp);        // the result of the cast is a prvalue, so move\n</code></pre>\n<p>And once we get to construction, we follow the same steps as my <a href=\"https://stackoverflow.com/a/45843921/2069064\">previous answer</a>, enumerating the constructors, which ends up selecting the constructor template, which uses <code>operator int()</code>.</p>\n", "LastActivityDate": "2017-08-24T12:29:40.177", "CommentCount": "7", "CreationDate": "2017-08-24T12:29:40.177", "ParentId": "45861479", "Score": "4", "OwnerUserId": "2069064"}, "bq_ids": {"n4140": {"so_45861479_45865802_0": {"length": 12, "quality": 0.5454545454545454, "section_id": 6030}}, "n3337": {"so_45861479_45865802_0": {"length": 13, "quality": 0.5909090909090909, "section_id": 2}}, "n4659": {"so_45861479_45865802_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 7529}}}, "45865802": {"Id": "45865802", "PostTypeId": "2", "Body": "<p>In case Barry's excellent answer still isn't clear, here's my version, hope it helps.</p>\n<p>The biggest question is why isn't the user-defined conversion to <code>optional&lt;int&gt;</code> preferred in direct initialization:</p>\n<pre><code>    std::optional&lt;int&gt; my_opt(my_foo);\n</code></pre>\n<p>After all, there is a constructor <code>optional&lt;int&gt;(optional&lt;int&gt;&amp;&amp;)</code> and a user-defined conversion of <code>my_foo</code> to <code>optional&lt;int&gt;</code>.</p>\n<p>The reason is the <a href=\"http://eel.is/c++draft/optional.ctor#20\" rel=\"nofollow noreferrer\"><code>template&lt;typename U&gt; optional(U&amp;&amp;)</code></a> constructor template, which is supposed to activate when <code>T</code> (<code>int</code>) is constructible from <code>U</code> and <code>U</code> is neither <code>std::in_place_t</code> nor <code>optional&lt;T&gt;</code>, and direct-initialize <code>T</code> from it. And so it does, stamping out <code>optional(foo&amp;)</code>.</p>\n<p>The final generated <code>optional&lt;int&gt;</code> looks something like:</p>\n<pre><code>class optional&lt;int&gt; {\n    . . .\n    int value_;\n    . . .\n    optional(optional&amp;&amp; rhs);\n    optional(foo&amp; rhs) : value_(rhs) {}\n    . . .\n</code></pre>\n<p><code>optional(optional&amp;&amp;)</code> requires a user-defined conversion whereas <code>optional(foo&amp;)</code> is an exact match for <code>my_foo</code>. So it wins, and  direct-initializes <code>int</code> from <code>my_foo</code>. Only at this point is <code>operator int()</code> selected as a better match to initialize an <code>int</code>. The result thus becomes <code>2</code>.</p>\n<p>2) In case of <code>my_opt = static_cast&lt;std::optional&lt;int&gt;&gt;(my_foo)</code>, although it <em>sounds</em> like \"<em>initialize <code>my_opt</code> as-if it was <code>std::optional&lt;int&gt;</code></em>\", it actually <strong><em>means</em></strong> \"<em>create a temporary <code>std::optional&lt;int&gt;</code> from <code>my_foo</code> and move-assign from that</em>\" as described in <a href=\"http://eel.is/c++draft/expr.static.cast#4\" rel=\"nofollow noreferrer\">[expr.static.cast]/4</a>:</p>\n<blockquote>\n<p id=\"so_45861479_45865802_0\">If <code>T</code> is a reference type, the effect is the same as performing the\n  declaration and initialization<br><code>T t(e);</code> for some invented temporary\n  variable <code>t</code> ([dcl.init]) and then using the temporary variable as the\n  result of the conversion. Otherwise, the result object is\n  direct-initialized from <code>e</code>.</br></p>\n</blockquote>\n<p>So it becomes:</p>\n<pre><code>    my_opt = std::optional&lt;int&gt;(my_foo);\n</code></pre>\n<p>And we're back to the previous situation; <code>my_opt</code> is subsequently initialized from a temporary <code>optional</code>, already holding a <code>2</code>.</p>\n<p>The issue of overloading on forwarding references is well-known. Scott Myers in his book <em>Effective Modern C++</em> in Chapter 26 talks extensively about why it is a bad idea to overload on \"universal references\". Such templates will tirelessly stamp out whatever the type you throw at them, which will overshadow everything and anything that is not an exact match. So I'm surprised the committee chose this route.</p>\n<hr>\n<p>As to the reason <strong>why it is like this</strong>, in the proposal <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3793.html#optional.object.ctor\" rel=\"nofollow noreferrer\">N3793</a> and in the standard until <a href=\"https://github.com/cplusplus/draft/commit/7988d9b5e98875b79ae942c92cb32f9990acd02a\" rel=\"nofollow noreferrer\">Nov 15, 2016</a> it was indeed</p>\n<pre><code>  optional(const T&amp; v);\n  optional(T&amp;&amp; v);\n</code></pre>\n<p>But then as part of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2451\" rel=\"nofollow noreferrer\">LWG defect 2451</a> it got changed to</p>\n<pre><code>  template &lt;class U = T&gt; optional(U&amp;&amp; v);\n</code></pre>\n<p>With the following rationale:</p>\n<blockquote>\n<p id=\"so_45861479_45865802_1\">Code such as the following is currently ill-formed (thanks to STL for\n  the compelling example):</p>\n<pre><code>optional&lt;string&gt; opt_str = \"meow\";\n</code></pre>\n<p id=\"so_45861479_45865802_2\">This is because it would require two user-defined conversions (from\n  <code>const char*</code> to <code>string</code>, and from <code>string</code> to <code>optional&lt;string&gt;</code>) where the\n  language permits only one. This is likely to be a surprise and an\n  inconvenience for users.</p>\n<p id=\"so_45861479_45865802_3\"><code>optional&lt;T&gt;</code> should be implicitly convertible from any <code>U</code> that is\n  implicitly convertible to <code>T</code>. This can be implemented as a non-explicit\n  constructor template <code>optional(U&amp;&amp;)</code>, which is enabled via SFINAE only\n  if <code>is_convertible_v&lt;U, T&gt;</code> and <code>is_constructible_v&lt;T, U&gt;</code>, plus any\n  additional conditions needed to avoid ambiguity with other\n  constructors...</p>\n</blockquote>\n<p>In the end I think it's OK that <code>T</code> is ranked higher than <code>optional&lt;T&gt;</code>, after all it's a rather unusual choice between something that <em>may</em> have a value and <em>the</em> value.</p>\n<p>Performance-wise it is also beneficial to initialize from <code>T</code> rather than from another <code>optional&lt;T&gt;</code>. An <code>optional</code> is typically implemented as:</p>\n<pre><code>template&lt;typename T&gt;\nstruct optional {\n    union\n    {\n        char dummy;\n        T value;\n    };\n    bool has_value;\n};\n</code></pre>\n<p>So initializing it from <code>optional&lt;T&gt;&amp;</code> would look something like</p>\n<pre><code>optional&lt;T&gt;::optional(const optional&lt;T&gt;&amp; rhs) {\n  has_value = rhs.has_value;\n  if (has_value) {\n    value = rhs.value;\n  }\n}\n</code></pre>\n<p>Whereas initializing from <code>T&amp;</code> would require less steps:</p>\n<pre><code>optional&lt;T&gt;::optional(const T&amp; t) {\n  value = t;\n  has_value = true;\n}\n</code></pre>\n</hr>", "LastEditorUserId": "485343", "LastActivityDate": "2017-08-25T18:33:30.170", "Score": "3", "CreationDate": "2017-08-24T15:38:50.547", "ParentId": "45861479", "CommentCount": "3", "OwnerUserId": "485343", "LastEditDate": "2017-08-25T18:33:30.170"}, "45861479": {"ViewCount": "194", "Body": "<p>This code</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;optional&gt;\n\nstruct foo\n{\n    explicit operator std::optional&lt;int&gt;() {\n        return std::optional&lt;int&gt;( 1 );\n    }\n    explicit operator int() {\n        return 2;\n    }\n};\n\nint main()\n{\n    foo my_foo;\n\n    std::optional&lt;int&gt; my_opt( my_foo );\n    std::cout &lt;&lt; \"constructor: \" &lt;&lt; my_opt.value() &lt;&lt; std::endl;\n\n    my_opt = static_cast&lt;std::optional&lt;int&gt;&gt;(my_foo);\n    std::cout &lt;&lt; \"static_cast: \" &lt;&lt; my_opt.value() &lt;&lt; std::endl;\n}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/Et7gN95oNk9xva5W\" rel=\"nofollow noreferrer\">produces the following output</a></p>\n<pre><code>constructor: 2\nstatic_cast: 2\n</code></pre>\n<p>in Clang 4.0.0 and in MSVC 2017 (15.3). (Let's ignore GCC for now, since it's behavior seems to be <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81952\" rel=\"nofollow noreferrer\">buggy</a> in that case.)</p>\n<p>Why is the output <code>2</code>? I would expect <code>1</code>. The constructors of <code>std::optional</code> seem to prefer casting to the inner type (<code>int</code>) despite the fact that a cast to the outer type (<code>std::optional&lt;int&gt;</code>) is available. Is this correct according to the C++ standard? If so, is there a reason the standard does not dictate to prefer an attempt to cast to the outer type? I would find this more reasonable and could imagine it to be implemented using <code>enable_if</code> and <code>is_convertible</code> to disable the ctor if a conversion to the outer type is possible. Otherwise every cast operator to <code>std::optional&lt;T&gt;</code> in a user class - even though it is a perfect match - would be ignored on principle if there is also one to <code>T</code>. I would find this quite obnoxious.</p>\n<p>I posted a somewhat <a href=\"https://stackoverflow.com/questions/45843428/different-results-in-clang-and-gcc-when-casting-to-stdoptionalt\">similar question</a> yesterday but probably did not state my problem accurately, since the resulting discussion was more about the GCC bug. That's why I am asking again more explicitly here.</p>\n", "AcceptedAnswerId": "45865802", "Title": "Why is a cast operator to std::optional ignored?", "CreationDate": "2017-08-24T12:19:15.623", "Id": "45861479", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-08-24T12:37:24.170", "LastEditorUserId": "1866775", "LastActivityDate": "2017-08-25T18:33:30.170", "Score": "4", "OwnerUserId": "1866775", "Tags": "<c++><casting><operator-overloading><c++1z><static-cast>", "AnswerCount": "2"}});