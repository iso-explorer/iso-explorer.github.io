post_cb({"3562096": {"CommentCount": "6", "CreationDate": "2010-08-25T00:45:50.043", "CommunityOwnedDate": "2010-08-25T13:56:50.730", "LastEditorUserId": "4143855", "LastActivityDate": "2017-05-29T03:52:18.250", "ParentId": "3561648", "PostTypeId": "2", "LastEditDate": "2017-05-29T03:52:18.250", "Id": "3562096", "Score": "66", "Body": "<p>Because I may write <code>Foo</code> and its friend <code>Bar</code> (thus there is a trust relationship). </p>\n<p>But do I trust the people who write classes that are derived from <code>Bar</code>?<br>\nNot really. So they should not inherit friendship.</br></p>\n<p>Any change in the internal representation of a class will require a modification to anything that is dependent on that representation. Thus all members of a class and also all friends of the class will require modification. </p>\n<p>Therefore if the internal representation of <code>Foo</code> is modified then <code>Bar</code> must also be modified (because friendship tightly binds <code>Bar</code> to <code>Foo</code>). If friendship was inherited then all class derived from <code>Bar</code> would also be tightly bound to <code>Foo</code> and thus require modification if <code>Foo</code>'s internal representation is changed. But I have no knowledge of derived types (nor should I. They may even be developed by different companies etc). Thus I would be unable to change <code>Foo</code> as doing so would introduce breaking changes into the code base (as I could not modify all class derived from <code>Bar</code>).</p>\n<p>Thus if friendship was inherited you are inadvertently introducing a restriction on the ability to modify a class. This is undesirable as you basically render useless the concept of a public API.</p>\n<p>Note: A child of <code>Bar</code> can access <code>Foo</code> by using <code>Bar</code>, just make the method in <code>Bar</code> protected. Then the child of <code>Bar</code> can access a <code>Foo</code> by calling through its parent class.</p>\n<p>Is this what you want?</p>\n<pre><code>class A\n{\n    int x;\n    friend class B;\n};\n\nclass B\n{\n    protected:\n       // Now children of B can access foo\n       void foo(A&amp; a, int n) { a.x = n; }\n};\n\nclass D : public B\n{\n    public:\n        foo(A&amp; a, int n)\n        {\n            B::foo(a, n + 5);\n        }\n};\n</code></pre>\n", "OwnerUserId": "14065"}, "3562144": {"CommentCount": "1", "CreationDate": "2010-08-25T00:59:02.207", "CommunityOwnedDate": "2010-08-25T13:56:50.730", "LastEditorUserId": "4143855", "LastActivityDate": "2017-05-29T03:49:59.923", "ParentId": "3561648", "PostTypeId": "2", "LastEditDate": "2017-05-29T03:49:59.923", "Id": "3562144", "Score": "6", "Body": "<p>C++ Standard, section 11.4/8</p>\n<blockquote>\n<p id=\"so_3561648_3562144_0\">Friendship is neither inherited nor transitive.</p>\n</blockquote>\n<p>If friendship would be inherited, then a class that wasn't meant to be a friend would suddenly have access to your class internals and that violates encapsulation.</p>\n", "OwnerUserId": "193481"}, "3561661": {"ParentId": "3561648", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2010-08-24T22:58:13.757", "OwnerUserId": "129570", "CommunityOwnedDate": "2010-08-25T13:56:50.730", "Id": "3561661", "Score": "0", "Body": "<p>A guess: If a class declares some other class/function as a friend, it's because that second entity needs privileged access to the first.  What use is there in granting the second entity privileged access to an arbitrary number of classes derived from the first?</p>\n", "LastActivityDate": "2010-08-24T22:58:13.757"}, "3563382": {"ParentId": "3561648", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2010-08-25T06:36:49.437", "OwnerUserId": "147192", "CommunityOwnedDate": "2010-08-25T13:56:50.730", "Id": "3563382", "Score": "2", "Body": "<p>Because it's just unnecessary.</p>\n<p>The usage of the <code>friend</code> keyword is itself suspicious. In term of coupling it's the worst relationship (way ahead of inheritance and composition).</p>\n<p>Any change to the internals of a class have a risk to impact the friends of this class... do you really want an unknown number of friends ? You would not even be able to list them if those who inherit from them could be friends also, and you would run in the risk of breaking your clients code each time, surely this is not desirable.</p>\n<p>I freely admit that for homework/pet projects dependency is often a far away consideration. On small size projects it doesn't matter. But as soon as several persons work on the same project and this grows into the dozens of thousands of lines you need to limit the impact of changes.</p>\n<p>This bring a very simple rule:</p>\n<p><em>Changing the internals of a class should only affect the class itself</em></p>\n<p>Of course, you'll probably affect its friends, but there are two cases here:</p>\n<ul>\n<li>friend free function: probably more of a member function anyway (I am think <code>std::ostream&amp; operator&lt;&lt;(...)</code> here, which is not a member purely by accident of the language rules</li>\n<li>friend class ? you don't need friend classes on real classes.</li>\n</ul>\n<p>I would recommend the use of the simple method:</p>\n<pre><code>class Example;\n\nclass ExampleKey { friend class Example; ExampleKey(); };\n\nclass Restricted\n{\npublic:\n  void forExampleOnly(int,int,ExampleKey const&amp;);\n};\n</code></pre>\n<p>This simple <code>Key</code> pattern allows you to declare a friend (in a way) without actually giving it access to your internals, thus isolating it from changes. Furthermore it allows this friend to lend its key to trustees (like children) if required.</p>\n", "LastActivityDate": "2010-08-25T06:36:49.437"}, "3562920": {"ParentId": "3561648", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2010-08-25T04:46:39.943", "OwnerUserId": "153285", "CommunityOwnedDate": "2010-08-25T13:56:50.730", "Id": "3562920", "Score": "7", "Body": "<p>A friended class may expose its friend through accessor functions, and then grant access through those.</p>\n<pre><code>class stingy {\n    int pennies;\n    friend class hot_girl;\n};\n\nclass hot_girl {\npublic:\n    stingy *bf;\n\n    int &amp;get_cash( stingy &amp;x = *bf ) { return x.pennies; }\n};\n\nclass moocher {\npublic: // moocher can access stingy's pennies despite not being a friend\n    int &amp;get_cash( hot_girl &amp;x ) { return x.get_cash(); }\n};\n</code></pre>\n<p>This allows finer control than optional transitivity. For example, <code>get_cash</code> may be <code>protected</code> or may enforce a protocol of runtime-limited access.</p>\n", "LastActivityDate": "2010-08-25T04:46:39.943"}, "3561648": {"CommentCount": "0", "ViewCount": "36671", "PostTypeId": "1", "CommunityOwnedDate": "2010-08-25T13:56:50.730", "LastEditorUserId": "-1", "CreationDate": "2010-08-24T22:55:01.277", "LastActivityDate": "2017-05-29T03:52:18.250", "LastEditDate": "2017-05-23T11:55:01.607", "AcceptedAnswerId": "3562096", "FavoriteCount": "21", "Title": "Why does C++ not allow inherited friendship?", "Id": "3561648", "Score": "69", "Body": "<p>Why is friendship not at least optionally inheritable in C++?  I understand transitivity and reflexivity being forbidden for obvious reasons (I say this only to head off simple FAQ quote answers), but the lack of something along the lines of <code>virtual friend class Foo;</code> puzzles me.  Does anyone know the historical background behind this decision?  Was friendship really just a limited hack that has since found its way into a few obscure respectable uses?</p>\n<p><strong>Edit for clarification:</strong> I'm talking about the following scenario, <em>not</em> where children of A are exposed to either B or to both B and its children.  I can also imagine optionally granting access to overrides of friend functions, etc.</p>\n<pre><code>class A {\n  int x;\n  friend class B;\n};\n\nclass B {\n  // OK as per friend declaration above.\n  void foo(A&amp; a, int n) { a.x = n; }\n};\n\nclass D : public B { /* can't get in A w/o 'friend class D' declaration. */ };\n</code></pre>\n<p><strong>Accepted answer:</strong> as <a href=\"https://stackoverflow.com/questions/3561648/why-does-c-not-allow-inherited-friendship/3562096#3562096\">Loki states</a>, the effect can be simulated more or less by making protected proxy functions in friended base classes, so there is no strict <em>need</em> for granting friendship to a class or virtual method heirarchy.  I dislike the need for boilerplate proxies (which the friended base effectively becomes), but I suppose that this was deemed preferable over a language mechanism that would more likely be misused most of the time.  I think it's probably time I bought and read Stroupstrup's <a href=\"http://public.research.att.com/~bs/dne.html\" rel=\"noreferrer\"><strong>The Design and Evolution of C++</strong></a>, which I've seen enough people here recommend, to get better insight to these types of questions ...</p>\n", "Tags": "<c++><inheritance><language-design><friend>", "OwnerUserId": "334932", "AnswerCount": "9"}, "3562336": {"ParentId": "3561648", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2010-08-25T01:59:27.743", "OwnerUserId": "418110", "CommunityOwnedDate": "2010-08-25T13:56:50.730", "Id": "3562336", "Score": "0", "Body": "<p>A derived class can inherit only something, which is 'member' of the base. A friend declaration is <strong><em>not</em></strong> a member of the befriending class.</p>\n<blockquote>\n<p id=\"so_3561648_3562336_0\">$11.4/1- \"...The name of a friend is\n  not in the scope of the class, and the\n  friend is not called with the member\n  access operators (5.2.5) unless it is\n  a member of another class.\"</p>\n<p id=\"so_3561648_3562336_1\">$11.4 - \"Also, because the base-clause\n  of the friend class is not part of its\n  member declarations, the base-clause\n  of the friend class cannot access the\n  names of the private and protected\n  members from the class granting\n  friendship.\"</p>\n</blockquote>\n<p>and further</p>\n<blockquote>\n<p id=\"so_3561648_3562336_2\">$10.3/7- \"[Note: the virtual specifier\n  implies membership, so a virtual\n  function cannot be a nonmember (7.1.2)\n  function. Nor can a virtual function\n  be a static member, since a virtual\n  function call relies on a specific\n  object for determining which function\n  to invoke. A virtual function declared\n  in one class can be declared a friend\n  in another class. ]\"</p>\n</blockquote>\n<p>Since the 'friend' is not a member of the base class in the first place, how can it be inherited by the derived class?</p>\n", "LastActivityDate": "2010-08-25T01:59:27.743"}, "41044872": {"CommentCount": "0", "CreationDate": "2016-12-08T17:00:32.840", "CommunityOwnedDate": "2016-12-08T17:00:32.840", "LastEditorUserId": "7268856", "LastActivityDate": "2016-12-08T17:06:30.940", "ParentId": "3561648", "PostTypeId": "2", "LastEditDate": "2016-12-08T17:06:30.940", "Id": "41044872", "Score": "0", "Body": "<p>Friend is good in inheritance like style interface for container\nBut for me, as the first say, C++ lack the propagatable inheritance</p>\n<pre><code>class Thing;\n\n//an interface for Thing container's\nstruct IThing {\n   friend Thing;\n   protected:\n       int IThing_getData() = 0;\n};\n\n//container for thing's\nstruct MyContainer : public IThing {\n    protected: //here is reserved access to Thing\n         int IThing_getData() override {...}\n};\n\nstruct Thing {\n    void setYourContainer(IThing* aContainerOfThings) {\n        //access to unique function in protected area \n        aContainerOfThings-&gt;IThing_getData(); //authorized access\n    }\n};\n\nstruct ChildThing : public Thing {\n    void doTest() {\n        //here the lack of granularity, you cannot access to the container.\n        //to use the container, you must implement all \n        //function in the Thing class\n        aContainerOfThings-&gt;IThing_getData(); //forbidden access\n    }\n};\n</code></pre>\n<p>For me the problem of C++ is the lack of very good granularity to\ncontrol all access from anywhere for anything :</p>\n<p>friend Thing can become friend Thing.* to grant access to all child of Thing </p>\n<p>And more, friend [named area] Thing.* to grant access for a precise\nare in the Container class via special named area for the friend.</p>\n<p>Ok stop the dream. But now, you know an interesting usage of friend.</p>\n<p>In another order, you can also found interesting to known all class are friendly with self. In other word, a class instance can call all<br>\nmembers of another instance of same name without restriction:</br></p>\n<pre><code>class Object {\n     private:\n         void test() {}\n     protected:\n         void callAnotherTest(Object* anotherObject) {\n             //private, but yes you can call test() from \n             //another object instance\n             anotherObject)-&gt;test(); \n         }\n};\n</code></pre>\n", "OwnerUserId": "7268856"}, "24304490": {"ParentId": "3561648", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2014-06-19T10:33:50.407", "OwnerUserId": "341065", "CommunityOwnedDate": "2014-06-19T10:33:50.407", "Id": "24304490", "Score": "27", "Body": "<blockquote>\n<p id=\"so_3561648_24304490_0\">Why is friendship not at least optionally inheritable in C++?</p>\n</blockquote>\n<p>I think that the answer to your first question is in this question: <em>\"Do your father's friends have access to your privates?\"</em></p>\n", "LastActivityDate": "2014-06-19T10:33:50.407"}, "bq_ids": {"n4140": {"so_3561648_3562144_0": {"section_id": 6693, "quality": 1.0, "length": 5}, "so_3561648_3562336_2": {"section_id": 7011, "quality": 0.9210526315789473, "length": 35}}, "n3337": {"so_3561648_3562144_0": {"section_id": 6448, "quality": 1.0, "length": 5}, "so_3561648_3562336_2": {"section_id": 6757, "quality": 0.9210526315789473, "length": 35}}, "n4659": {"so_3561648_3562144_0": {"section_id": 8168, "quality": 1.0, "length": 5}, "so_3561648_3562336_2": {"section_id": 8508, "quality": 0.9210526315789473, "length": 35}}}, "27149143": {"CommentCount": "0", "CreationDate": "2014-11-26T12:23:00.397", "CommunityOwnedDate": "2014-11-26T12:23:00.397", "LastEditorUserId": "1116757", "LastActivityDate": "2014-11-26T12:40:18.167", "ParentId": "3561648", "PostTypeId": "2", "LastEditDate": "2014-11-26T12:40:18.167", "Id": "27149143", "Score": "0", "Body": "<p>Friend function in a class assigns the extern property to the function. i.e. extern means that the function has been declared and defined somewhere out of the class. </p>\n<p>Hence it means friend function is not a member of a class. So the inheritance only allows you to inherit the properties of a class not external things. And also if inheritance is allowed for friend functions, then a third party class inheriting. </p>\n", "OwnerUserId": "4295898"}});