post_cb({"43895259": {"ParentId": "43894619", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>This is compiler bug <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=78939\" rel=\"noreferrer\">78939</a>. Although it's a bit more complicated than that - there were a few issues between the core language and the library that were mutually contradictory (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0490r0.html\" rel=\"noreferrer\">GB 20</a>, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2770\" rel=\"noreferrer\">LWG 2770</a>, and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2446\" rel=\"noreferrer\">LWG 2446</a>), which lead to the kind of behavior that gcc/libstdc++ exhibit here. It is certainly <em>intended</em> that the code work with or without <code>#include &lt;utility&gt;</code>, it's just a matter of the standard wording having gotten there properly.</p>\n<hr/>\n<p>Yes, classes with all public non-anonymous union members should be usable in structured bindings declarations per <a href=\"http://eel.is/c++draft/dcl.struct.bind#4\" rel=\"noreferrer\">[dcl.struct.bind]/4</a>:</p>\n<blockquote>\n<p id=\"so_43894619_43895259_0\">Otherwise, all of <code>E</code>'s non-static data members shall be public direct members of <code>E</code> or of the same unambiguous public base class of <code>E</code>, <code>E</code> shall not have an anonymous union member, and the number of elements in the identifier-list shall be equal to the number of non-static data members of <code>E</code>. Designating the non-static data members of <code>E</code> as m0, m1, m2, ... (in declaration order), each vi is the name of an lvalue that refers to the member mi of e and whose type is cv Ti, where Ti is the declared type of that member; the referenced type is cv Ti. The lvalue is a bit-field if that member is a bit-field. <em>[\u2009Example:</em></p>\n<pre><code>struct S { int x1 : 2; volatile double y1; };\nS f();\nconst auto [ x, y ] = f();\n</code></pre>\n</blockquote>\n<p>This is completely unrelated to the inclusion of <code>&lt;utility&gt;</code>, nothing in this code depends on any library functionality - the members are grabbed directly, and not via the <code>get</code>/<code>tuple_size</code> mechanism.</p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2756719", "LastEditDate": "2017-05-12T19:26:37.990", "Id": "43895259", "Score": "17", "CreationDate": "2017-05-10T14:22:04.797", "LastActivityDate": "2017-05-12T19:26:37.990"}, "43895099": {"ParentId": "43894619", "CommentCount": "0", "Body": "<p>The core idea behind structured bindings is that <code>std::tuple_size&lt;T&gt;</code> defines how many components you get from unpacking <code>T</code>, and <code>T::get&lt;N&gt;</code> should access the N'th element. Not surprising, this <code>std::tuple_size&lt;T&gt;</code> is a specialization from the base template in <code>&lt;utility&gt;</code>. </p>\n<p>Now in this case, <code>Point</code> doesn't have such support for structured bindings, but it is a special case (all public non-static members) for which C++17 states that no special unpacking support is needed. This is an exception to the rule above.</p>\n<p>The compiler is tripping over itself here, and trying to use the generic rule when it sees the unspecialized <code>std::tuple_size</code> from <code>&lt;utility&gt;</code>. </p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "43895099", "Score": "12", "CreationDate": "2017-05-10T14:15:11.243", "LastActivityDate": "2017-05-10T14:15:11.243"}, "43894619": {"CommentCount": "2", "AcceptedAnswerId": "43895259", "LastEditDate": "2017-06-25T14:54:11.690", "LastEditorUserId": "138817", "CreationDate": "2017-05-10T13:56:41.153", "LastActivityDate": "2017-06-25T14:54:11.690", "PostTypeId": "1", "ViewCount": "678", "FavoriteCount": "2", "Title": "Why does including <utility> break structured bindings in GCC?", "Id": "43894619", "OwnerUserId": "138817", "Body": "<p>Consider:</p>\n<pre><code>struct Point { int x, y; };\n\nint main()\n{\n    const auto [x, y] = Point{};\n}\n</code></pre>\n<p>This code compiles fine with gcc 7.1 in C++17 mode, however this one:</p>\n<pre><code>#include &lt;utility&gt;\n\nstruct Point { int x, y; };\n\nint main()\n{\n    const auto [x, y] = Point{};\n}\n</code></pre>\n<p>gives an error:</p>\n<pre><code>bug.cpp: In function 'int main()':\nbug.cpp:7:16: error: 'std::tuple_size&lt;const Point&gt;::value' is not an integral constant expression\n     const auto [x, y] = Point{};\n                ^~~~~~\n</code></pre>\n<p>What's going on here? A compiler bug, or is this how structured bindings are supposed to work?</p>\n", "Tags": "<c++><c++1z><structured-bindings><gcc7>", "Score": "20", "AnswerCount": "2"}, "bq_ids": {"n4659": {"so_43894619_43895259_0": {"section_id": 4041, "quality": 0.96, "length": 48}}}});