post_cb({"22331715": {"ParentId": "22330845", "LastEditDate": "2014-03-11T17:29:37.920", "CommentCount": "0", "CreationDate": "2014-03-11T17:08:33.883", "OwnerUserId": "420683", "LastEditorUserId": "420683", "PostTypeId": "2", "Id": "22331715", "Score": "2", "Body": "<p>I agree with Potatoswatter now :) The program is ill-formed:</p>\n<p>[temp.names]/4</p>\n<blockquote>\n<p id=\"so_22330845_22331715_0\">When the name of a member template specialization appears after <code>.</code> or <code>-&gt;</code> in a <em>postfix-expression</em> or [...], and the object expression of the <em>postfix-expression</em> is type-dependent\n  or [..], the member template name must be prefixed by the keyword <code>template</code>.\n  Otherwise the name is assumed to name a non-template.</p>\n</blockquote>\n<p>A non-template would mean the <code>&lt;</code> in <code>NoWay&lt;T&gt;</code> would be parsed as a less-than, which makes no sense being followed by a <em>typedef-name</em> (and the <code>~</code> would also be illegal, potentially naming but not calling a destructor).</p>\n<p>One would think that adding a <code>template</code> here:</p>\n<pre><code>ns::bar&lt;T&gt;().template ~NoWay&lt;T&gt;();\n</code></pre>\n<p>would make it well-formed. The part <code>template ~NoWay&lt;T&gt;</code> can indeed be a valid <em>pseudo-destructor-name</em>, [expr.post]/1</p>\n<blockquote>\n<p id=\"so_22330845_22331715_1\"><em>pseudo-destructor-name:</em><br/>\n  \u00a0\u00a0 <em>nested-name-specifier<sub>opt</sub> type-name</em> <code>:: ~</code> <em>type-name</em><br/>\n  \u00a0\u00a0 <em>nested-name-specifier</em> <code>template</code> <em>simple-template-id</em> <code>:: ~</code> <em>type-name</em><br/>\n  \u00a0\u00a0 <em>nested-name-specifier<sub>opt</sub></em> <code>~</code> <em>type-name</em></p>\n</blockquote>\n<p>but only if there's a <em>nested-name-specifier</em> before the <code>template</code> (note: it's not optional!).</p>\n", "LastActivityDate": "2014-03-11T17:29:37.920"}, "bq_ids": {"n4140": {"so_22330845_22331715_0": {"section_id": 72, "quality": 1.0, "length": 24}, "so_22330845_22331715_1": {"section_id": 5984, "quality": 0.7, "length": 7}}, "n3337": {"so_22330845_22331715_0": {"section_id": 67, "quality": 1.0, "length": 24}, "so_22330845_22331715_1": {"section_id": 5752, "quality": 0.7, "length": 7}}, "n4659": {"so_22330845_22331715_1": {"section_id": 7484, "quality": 0.7, "length": 7}}}, "22330845": {"CommentCount": "7", "ViewCount": "190", "CreationDate": "2014-03-11T16:33:10.313", "LastActivityDate": "2014-03-11T17:29:37.920", "Title": "Explicit call pseudo destructor in clang", "PostTypeId": "1", "Id": "22330845", "Score": "3", "Body": "<p>I'm trying to call explicit pseudo destructor: </p>\n<pre class=\"lang-cpp prettyprint-override\"><code>namespace ns {\n    template&lt;typename D&gt;\n    struct bar {};\n}\n\ntemplate &lt;typename T&gt;\nvoid example(T x)\n{\n    ns::bar&lt;T&gt;().~NoWay&lt;T&gt;();\n}\n</code></pre>\n<p>Clang++ (version 3.3) compiles this code without any errors. But <code>NoWay</code> not defined in the code. Is this right behavior?</p>\n", "Tags": "<c++><clang>", "OwnerUserId": "2599403", "AnswerCount": "1"}});