post_cb({"16073327": {"CommentCount": "2", "AcceptedAnswerId": "16073341", "ClosedDate": "2013-04-18T10:30:44.167", "CreationDate": "2013-04-18T02:02:53.770", "LastActivityDate": "2013-04-18T06:09:22.060", "PostTypeId": "1", "ViewCount": "292", "FavoriteCount": "3", "Title": "Bit shifting and assignment", "Id": "16073327", "Score": "1", "Body": "<p>This is sort of driving me crazy.</p>\n<pre><code>int a = 0xffffffff;\nint b = 32;\ncout &lt;&lt; (a &lt;&lt; b) &lt;&lt; \"\\n\";\ncout &lt;&lt; (0xffffffff &lt;&lt; 32) &lt;&lt; \"\\n\";\n</code></pre>\n<p>My output is</p>\n<pre><code>-1\n0\n</code></pre>\n<p>Why am I not getting</p>\n<pre><code>0\n0\n</code></pre>\n", "Tags": "<c++><c><bit-shift>", "OwnerUserId": "861183", "AnswerCount": "3"}, "16074348": {"ParentId": "16073327", "CommentCount": "0", "Body": "<p>C++ standard says ::\nIf the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined.\nAs GCC has no options to handle shifts by negative amounts or by amounts outside the width of the type predictably or trap on them; they are always treated as undefined.\nSo behavior is not defined.</p>\n", "OwnerUserId": "2273239", "PostTypeId": "2", "Id": "16074348", "Score": "0", "CreationDate": "2013-04-18T04:12:03.167", "LastActivityDate": "2013-04-18T04:12:03.167"}, "16073430": {"ParentId": "16073327", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>The short answer is that, since you're using an implementation with 32-bit <code>int</code>, the language standard says that a 32-bit shift is undefined behavior. Both the C standard (section 6.5.7) and the C++ standard (section 5.8) say</p>\n<blockquote>\n<p id=\"so_16073327_16073430_0\">If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined.</p>\n</blockquote>\n<p>But if you want to know <em>why</em>:</p>\n<p>Many computers have an instruction that can shift the value in a register, but the hardware only handles shift values that are actually needed. For instance, when shifting a 32 bit word, only 5 bits are needed to represent a shift value of 0 ... 31 and so the hardware may ignore higher order bits, and does on *86 machines (except for the 8086). So that compiler implementations could just use the instruction without generating extra code to check whether the shift value is too big, the authors of the C Standard (many of whom represented compiler vendors) ruled that the result of shifting by larger amounts is undefined.</p>\n<p>Your first shift is performed at run time and it encounters this situation ... only the low order 5 bits of b are considered by your machine, and they are 0, so no shift happens. Your second shift is done at compile time, and the compiler calculates the value differently and actually does the 32-bit shift.</p>\n<p>If you want to shift by an amount that may be larger than the number of bits in the thing you're shifting, you need to check the range of the value yourself. One possible way to do that is</p>\n<pre><code>#define LEFT_SHIFT(a, b) ((b) &gt;= CHAR_BIT * sizeof(a)? 0 : (a) &lt;&lt; (b))\n</code></pre>\n", "OwnerUserId": "544557", "LastEditorUserId": "544557", "LastEditDate": "2013-04-18T06:09:22.060", "Id": "16073430", "Score": "9", "CreationDate": "2013-04-18T02:16:31.580", "LastActivityDate": "2013-04-18T06:09:22.060"}, "16073341": {"ParentId": "16073327", "CommentCount": "2", "Body": "<p>Undefined behavior occurs when you shift a value by a number of bits which is not less than its size (e.g, 32 or more bits for a 32-bit integer). You've just encountered an example of that undefined behavior.</p>\n", "OwnerUserId": "149341", "PostTypeId": "2", "Id": "16073341", "Score": "8", "CreationDate": "2013-04-18T02:05:22.117", "LastActivityDate": "2013-04-18T02:05:22.117"}, "bq_ids": {"n4140": {"so_16073327_16073430_0": {"section_id": 6146, "quality": 0.6923076923076923, "length": 9}}, "n3337": {"so_16073327_16073430_0": {"section_id": 5909, "quality": 0.6923076923076923, "length": 9}}, "n4659": {"so_16073327_16073430_0": {"section_id": 7642, "quality": 0.6923076923076923, "length": 9}}}});