post_cb({"bq_ids": {"n4140": {"so_27364958_27364958_0": {"length": 42, "quality": 0.9767441860465116, "section_id": 986}}, "n3337": {"so_27364958_27364958_0": {"length": 42, "quality": 0.9767441860465116, "section_id": 971}}, "n4659": {"so_27364958_27364958_0": {"length": 42, "quality": 0.9767441860465116, "section_id": 1049}}}, "27457811": {"Id": "27457811", "PostTypeId": "2", "Body": "<p>When you used &amp;operator[], that returned a reference.  You then used emplace_back which caused reallocation, and thus invalidated all past references.  Both of these rules are well defined.  The correct thing that should happen is an exception.   I actually expect the VC++ version to throw an exception if you are running the debug version under the debugger.  </p>\n<p>push_back has the same two rules, which means it will also do the same.  I am almost certain, swapping the two lines emplace_back/push_back will result in the same behavior.</p>\n", "LastActivityDate": "2014-12-13T10:25:25.387", "CommentCount": "0", "CreationDate": "2014-12-13T10:25:25.387", "ParentId": "27364958", "Score": "0", "OwnerUserId": "1701721"}, "27364958": {"ViewCount": "429", "Body": "<p>I have heard that one of the recommendations of <em>Modern C++</em> is to use <code>emplace_back</code> instead of <code>push_back</code> for append in containers (<code>emplace_back</code> accept any version of parameters of any constructor of the type storage in the container).</p>\n<p>According to the standard draft <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\">N3797</a> <strong>23.3.6.5 (1)</strong>, say that:</p>\n<blockquote>\n<p id=\"so_27364958_27364958_0\"><strong>Remarks:</strong> Causes reallocation if the new size is greater than the old capacity. If no reallocation happens, all the iterators and references before the insertion point remain valid. If an exception is thrown other than by the copy constructor, move constructor, assignment operator, or move assignment operator of T or by any InputIterator operation there are no effects. If an exception is thrown by the move constructor of a non-CopyInsertable T, the effects are unspecified.</p>\n</blockquote>\n<p>This specify what happen when no reallocation is needed, but leave open the problem when the container need to grow.</p>\n<p>In this piece of Code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;unsigned char&gt; buff {1, 2, 3, 4};\n    buff.emplace_back(buff[0]);\n    buff.push_back(buff[1]);\n    for (const auto&amp; c : buff) {\n        std::cout &lt;&lt; std::hex &lt;&lt; static_cast&lt;long&gt;(c) &lt;&lt; \", \";\n    }\n    std::cout &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>Compiled with <strong>VC++ (Visual Studio 2013 Update 4)</strong> and <strong>GCC 4.9.1 (MinGW)</strong> in <em>Debug</em> in Windows 8.1.</p>\n<p>When compiled with VC++ the output is:</p>\n<pre><code>1, 2, 3, 4, dd, 2\n</code></pre>\n<p>When compiled with GCC the output is:</p>\n<pre><code>1, 2, 3, 4, 1, 2\n</code></pre>\n<p>Checking the implementation of <code>emplace_back</code> in VC++ the difference is that the first lines of code, check if the container need to grow (and grow if it's needed), in the case that the container need to grow, the reference to the first element (<strong>buff[0]</strong>) received in the <code>emplace_back</code> method is invalidated and when the actual setting of the value in the new created element of the container happen the value is invalid.</p>\n<p>In the case of the <code>push_back</code> work because the creation of the element to append is made in the parameter binding (before the possible grow of the container).</p>\n<p>My question is:\nThis behavior, when the container need to grow because a call to <code>emplace_back</code> and the parameter is a reference to the same container is <em>implementation defined, unspecified or there is a problem in the implementation of one of the compiler (suppose in VC++ as GCC behavior is more close to the expected)?</em></p>\n", "Title": "Difference in std::vector::emplace_back between GCC and VC++", "CreationDate": "2014-12-08T18:59:26.213", "LastActivityDate": "2014-12-13T10:25:25.387", "CommentCount": "10", "FavoriteCount": "1", "PostTypeId": "1", "ClosedDate": "2014-12-22T00:56:25.897", "Id": "27364958", "Score": "9", "OwnerUserId": "3837231", "Tags": "<c++><visual-c++><c++11><gcc><stdvector>", "AnswerCount": "1"}});