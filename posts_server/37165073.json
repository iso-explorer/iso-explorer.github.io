post_cb({"37166407": {"ParentId": "37165073", "CommentCount": "5", "Body": "<p>The problem is when initializing a <code>const</code> reference a temporary is created, and temporaries are not allowed with reference initialization in this context (converted constant expression).</p>\n<p>N4140 8.5.3 (5.2.2.1)</p>\n<blockquote>\n<p id=\"so_37165073_37166407_0\">...</p>\n<ul>\n<li>If <code>T1</code> is a non-class type, a temporary of type \"<em>cv1</em> <code>T1</code>\" is created and copy-initialized (8.5) from the initializer expression.\n  The reference is then bound to the temporary.</li>\n</ul>\n<p id=\"so_37165073_37166407_1\">In all cases except the last (i.e., creating and initializing a\n  temporary from the initializer expression), the reference is said to\n  <em>bind directly</em> to the initializer expression.</p>\n</blockquote>\n<p>Then in 5.19:</p>\n<blockquote>\n<p id=\"so_37165073_37166407_2\">A <em>conditional-expression</em> <code>e</code> is a <em>core constant expression</em> unless\n  the evaluation of <code>e</code>, following the rules of the abstract machine\n  (1.9), would evaluate one of the following expressions:</p>\n<p id=\"so_37165073_37166407_3\">(2.9)\n  -  an <em>id-expression</em> that refers to a variable or data member of reference type unless the reference has a preceding initialization and\n  either</p>\n<ul>\n<li>it is initialized with a constant expression or ...</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "6320913", "PostTypeId": "2", "Id": "37166407", "Score": "0", "CreationDate": "2016-05-11T14:57:43.480", "LastActivityDate": "2016-05-11T14:57:43.480"}, "37166057": {"ParentId": "37165073", "CommentCount": "0", "Body": "<p>A gcc specific workaround:</p>\n<pre><code>struct a\n{ int _v;\n  constexpr a():_v(0){}\n  constexpr a(int v): _v(v){} \n};\n\nstruct c: public a\n{ constexpr c():a(){}\n  constexpr c(int v):a(v){} \n};\n\nextern const c _default_c;\n\nconstexpr const c _default_c { 1 };\n\nextern const a default_a;\n\nconst a default_a __attribute__((alias(\"_default_c\")));\n\ntemplate &lt; const a &amp; The_A = default_a &gt;\nstruct b\n{ constexpr static const a &amp;the_a = The_A;\n};\n\nb&lt;&gt; a_b;\n</code></pre>\n<p>The above compiles OK .</p>\n<p>Happily, we know that the name of '_default_c' is not mangled.</p>\n", "OwnerUserId": "690051", "PostTypeId": "2", "Id": "37166057", "Score": "1", "CreationDate": "2016-05-11T14:44:17.537", "LastActivityDate": "2016-05-11T14:44:17.537"}, "37165073": {"CommentCount": "5", "ViewCount": "318", "PostTypeId": "1", "LastEditorUserId": "690051", "CreationDate": "2016-05-11T14:04:49.930", "LastActivityDate": "2016-05-11T15:13:09.423", "Title": "non-type template parameter : how to pass reference to base class object?", "FavoriteCount": "1", "LastEditDate": "2016-05-11T14:16:08.653", "Id": "37165073", "Score": "5", "Body": "<p>It does not seem to be possible to pass a reference to \nthe base class object of a derived object as a template parameter,\nas I try to do here: </p>\n<pre><code>struct a\n{ int _v;\n  constexpr a():_v(0){}\n  constexpr a(int v): _v(v){} \n};\n\nstruct c: public a\n{ constexpr c():a(){}\n  constexpr c(int v):a(v){} \n};\n\nextern const c default_a;\n\nconstexpr const c default_a { 1 };\n\nconst a&amp; c_as_a = default_a;\n//    ^-- this line (16) causes no error - c can be converted to a\n\ntemplate &lt; const a &amp; The_A = default_a &gt;\nstruct b\n{ constexpr static const a &amp;the_a = The_A;\n};\n\nb&lt;&gt; a_b;\n\n// Template instantiation causes error:\n// t.C:24:7: error: could not convert template argument 'default_a' to 'const a&amp;'\n// b&lt;&gt; a_b;\n//   ^\n</code></pre>\n<p>I would have expected the 'c' object 'default_a', since it is derived from\n'a', to be acceptable as a 'const a&amp;', as it is on the line 16.</p>\n<p>Why isn't this OK as a template parameter ?</p>\n<p>What section of specification actually mandates this behaviour ?</p>\n<p>Maybe my build of gcc-5.3.0 is somehow defective ?</p>\n<p>Anyone found a good workaround / way of passing a derived object as a base class object reference template parameter ?</p>\n<p>I cannot just substitute the reference variable 'c_as_a' for 'default_a' in\ntemplate argument list:</p>\n<pre><code>template &lt; const a &amp; The_A = c_as_a &gt;\n</code></pre>\n<p>t.C:24:7: error: 'const a&amp; c_as_a' is not a valid template argument for type 'const a&amp;' because a reference variable does not have a constant address\n     b&lt;&gt; a_b;</p>\n<p>Nor can I substitute any constexpr function call which does something like:</p>\n<pre><code> constexpr const a&amp; c_as_a( const c &amp;c ){ return *reinterpret_cast&lt;const a*&gt;(&amp;c);}\n ...\n template &lt; const a &amp; The_A = c_as_a( default_a ) &gt;\n</code></pre>\n<p>since this call is not an 'object with external linkage'. </p>\n<p>Any suggestions how to achieve passing a reference to a base class of a derived object as a template parameter would be much appreciated - it's\ngot to be possible, I just can't see how ATM.</p>\n<p>There must be a way of specifying a reference to an object's base class object as a template parameter.</p>\n", "Tags": "<c++>", "OwnerUserId": "690051", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_37165073_37166407_3": {"section_id": 6185, "quality": 1.0, "length": 11}, "so_37165073_37166407_2": {"section_id": 6185, "quality": 0.9285714285714286, "length": 13}, "so_37165073_37166407_1": {"section_id": 3321, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_37165073_37166407_3": {"section_id": 5946, "quality": 0.9090909090909091, "length": 10}, "so_37165073_37166407_1": {"section_id": 3191, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_37165073_37166407_3": {"section_id": 7687, "quality": 1.0, "length": 11}, "so_37165073_37166407_2": {"section_id": 7687, "quality": 0.7857142857142857, "length": 11}, "so_37165073_37166407_1": {"section_id": 4087, "quality": 0.7333333333333333, "length": 11}}}, "37166801": {"ParentId": "37165073", "CommentCount": "0", "Body": "<p>Fix that works in namespace:</p>\n<pre><code>namespace U {\n    struct a\n    { int _v;\n      constexpr a():_v(0){}\n      constexpr a(int v): _v(v){} \n    };\n\n    struct c: public a\n    { constexpr c():a(){}\n      constexpr c(int v):a(v){} \n    };\n    extern \"C\" {\n    extern const c _default_c;\n\n    constexpr const c _default_c { 1 };\n    }\n\n    extern const a default_a;\n\n    const a default_a __attribute__((alias(\"_default_c\")));\n\n    template &lt; const a &amp; The_A = default_a &gt;\n    struct b\n    { constexpr static const a &amp;the_a = The_A;\n    };\n\n    b&lt;&gt; a_b;\n}\n</code></pre>\n", "OwnerUserId": "690051", "PostTypeId": "2", "Id": "37166801", "Score": "0", "CreationDate": "2016-05-11T15:13:09.423", "LastActivityDate": "2016-05-11T15:13:09.423"}});