post_cb({"bq_ids": {"n4140": {"so_35088599_35088909_2": {"length": 44, "quality": 0.9361702127659575, "section_id": 6076}, "so_35088599_35088845_0": {"length": 24, "quality": 0.7272727272727273, "section_id": 5941}, "so_35088599_35088909_1": {"length": 34, "quality": 0.9714285714285714, "section_id": 6022}, "so_35088599_35088909_0": {"length": 9, "quality": 0.6, "section_id": 5941}, "so_35088599_35088909_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 5440}, "so_35088599_35088909_3": {"length": 13, "quality": 0.8666666666666667, "section_id": 6120}}, "n3337": {"so_35088599_35088845_0": {"length": 21, "quality": 0.6363636363636364, "section_id": 5712}, "so_35088599_35088909_2": {"length": 43, "quality": 0.9148936170212766, "section_id": 5844}, "so_35088599_35088909_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 5235}, "so_35088599_35088909_0": {"length": 8, "quality": 0.5333333333333333, "section_id": 5712}, "so_35088599_35088909_1": {"length": 34, "quality": 0.9714285714285714, "section_id": 5790}, "so_35088599_35088909_3": {"length": 13, "quality": 0.8666666666666667, "section_id": 5884}}, "n4659": {"so_35088599_35088845_0": {"length": 21, "quality": 0.6363636363636364, "section_id": 7425}, "so_35088599_35088909_2": {"length": 31, "quality": 0.6595744680851063, "section_id": 7572}, "so_35088599_35088909_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 6867}, "so_35088599_35088909_0": {"length": 9, "quality": 0.6, "section_id": 7425}, "so_35088599_35088909_1": {"length": 29, "quality": 0.8285714285714286, "section_id": 7521}, "so_35088599_35088909_3": {"length": 13, "quality": 0.8666666666666667, "section_id": 7617}}}, "35088845": {"Id": "35088845", "PostTypeId": "2", "Body": "<p>The standard term is an <em>unevaluated operand</em> and you can find it in [expr]</p>\n<blockquote>\n<p id=\"so_35088599_35088845_0\">In some contexts, unevaluated operands appear (5.2.8, 5.3.3, 5.3.7, 7.1.6.2). An unevaluated operand is not evaluated. An unevaluated operand is considered a full-expression. [ Note: In an unevaluated operand, a non-static class member may be named (5.1) and naming of objects or functions does not, by itself, require that a definition be provided (3.2). \u2014end note ]</p>\n</blockquote>\n<ul>\n<li>5.2.8 covers <code>typeid</code></li>\n<li>5.3.3 covers <code>sizeof</code></li>\n<li>5.3.7 covers <code>noexcept</code></li>\n<li>7.1.6.2 covers simple type specifiers such as <code>auto</code> and <code>decltype</code> and POD types like <code>int</code>, <code>char</code>, <code>double</code> etc.</li>\n</ul>\n", "LastActivityDate": "2016-01-29T16:03:42.640", "Score": "6", "CreationDate": "2016-01-29T16:03:42.640", "ParentId": "35088599", "CommentCount": "0", "OwnerUserId": "4342498"}, "35088909": {"Id": "35088909", "PostTypeId": "2", "Body": "<p>Fortunately, the standard has a handy list of those (\u00a7 5 [expr] \u00b6 8):</p>\n<blockquote>\n<p id=\"so_35088599_35088909_0\">In some contexts, <em>unevaluated operands</em> appear (5.2.8, 5.3.3, 5.3.7, 7.1.6.2). An unevaluated operand is not evaluated. An unevaluated operand is considered a full-expression.</p>\n</blockquote>\n<p>Let's look at these in detail.</p>\n<p>I will use the following declarations in my examples. The declared functions are never defined anywhere so if a call to them appears in an <em>evaluated</em> context, the program is ill-formed and we will get a link-time error. Calling them in an unevaluated context is fine, however.</p>\n<pre><code>int foo();  // never defined anywhere\n\nstruct widget\n{\n  virtual ~widget();\n  static widget&amp; get_instance();  // never defined anywhere\n};\n</code></pre>\n<h1><code>typeid</code></h1>\n<p>\u00a7 5.2.8 [expr.typeid] \u00b6 3:</p>\n<blockquote>\n<p id=\"so_35088599_35088909_1\">When <code>typeid</code> is applied to <strong>an expression other than a glvalue of a polymorphic class type</strong>, the result refers to a <code>std::type_info</code> object representing the static type of the expression. Lvalue-to-rvalue (4.1), array-to-pointer (4.2), and function-to-pointer (4.3) conversions are not applied to the expression. If the type of the expression is a class type, the class shall be completely-defined. <strong>The expression is an unevaluated operand\n  (Clause 5).</strong></p>\n</blockquote>\n<p>Note the emphasized exception for polymorphic classes (a <code>class</code> with at least one <code>virtual</code> member).</p>\n<p>Therefore, this is okay</p>\n<pre><code>typeid( foo() )\n</code></pre>\n<p>and yields a <code>std::type_info</code> object for <code>int</code> while this</p>\n<pre><code>typeid( widget::get_instance() )\n</code></pre>\n<p>is not and will probably produce a link-time error. It has to evaluate the operand because the dynamic type is determined by looking up the <code>vptr</code> at run-time.</p>\n<p>&lt;rant&gt;I find it quite confusing that the fact whether or not the static type of the operand is polymorphic changes the semantics of the operator in such dramatic, yet subtle, ways.&lt;/rant&gt;</p>\n<h1><code>sizeof</code></h1>\n<p>\u00a7 5.3.3 [expr.sizeof] \u00b6 1:</p>\n<blockquote>\n<p id=\"so_35088599_35088909_2\">The <code>sizeof</code> operator yields the number of bytes in the object representation of its operand. <strong>The operand is either an expression, which is an unevaluated operand (Clause 5)</strong>, or a parenthesized <em>type-id</em>. The <code>sizeof</code> operator shall not be applied to an expression that has function or incomplete type, to an enumeration type whose underlying type is not fixed before all its enumerators have been declared, to the parenthesized name of such types, or to a glvalue that designates a bit-field.</p>\n</blockquote>\n<p>The following</p>\n<pre><code>sizeof( foo() )\n</code></pre>\n<p>is perfectly fine and equivalent to <code>sizeof(int)</code>.</p>\n<pre><code>sizeof( widget::get_instance() )\n</code></pre>\n<p>is allowed too. Note, however, that it is equivalent to <code>sizeof(widget)</code> and therefore probably not very useful on a polymorphic <code>return</code> type.</p>\n<h1><code>noexcept</code></h1>\n<p>\u00a7 5.3.7 [expr.unary.noexcept] \u00b6 1:</p>\n<blockquote>\n<p id=\"so_35088599_35088909_3\">The <code>noexcept</code> operator determines whether the evaluation of <strong>its operand, which is an unevaluated operand (Clause 5)</strong>, can throw an exception (15.1).</p>\n</blockquote>\n<p>The expression</p>\n<pre><code>noexcept( foo() )\n</code></pre>\n<p>is valid and evaluates to <code>false</code>.</p>\n<p>Here is a more realistic example that is also valid.</p>\n<pre><code>void bar() noexcept(noexcept( widget::get_instance() ));\n</code></pre>\n<p>Note that only the inner <code>noexcept</code> is the operator while the outer is the specifier.</p>\n<h1><code>decltype</code></h1>\n<p>\u00a7 7.1.6.2 [dcl.type.simple] \u00b6 4.4:</p>\n<blockquote>\n<p id=\"so_35088599_35088909_4\"><strong>The operand of the <code>decltype</code> specifier is an unevaluated operand (Clause 5).</strong></p>\n</blockquote>\n<p>The statement</p>\n<pre><code>decltype( foo() ) n = 42;\n</code></pre>\n<p>declares a variable <code>n</code> of type <code>int</code> and initializes it with the value 42.</p>\n<pre><code>auto baz() -&gt; decltype( widget::get_instance() );\n</code></pre>\n<p>declares a function <code>baz</code> that takes no arguments and <code>return</code>s a <code>widget&amp;</code>.</p>\n<p>And that's all there are (as of C++14).</p>\n", "LastEditorUserId": "1392132", "LastActivityDate": "2016-01-29T19:28:55.447", "Score": "32", "CreationDate": "2016-01-29T16:07:06.197", "ParentId": "35088599", "CommentCount": "15", "LastEditDate": "2016-01-29T19:28:55.447", "OwnerUserId": "1392132"}, "35088599": {"ViewCount": "1393", "Body": "<p>One example that frequently comes to mind is :</p>\n<p><code>sizeof</code> expression, where it doesn't evaluates the expression but determines the size by static type. For example :</p>\n<pre><code>int func();\nsizeof(func());\n</code></pre>\n<p>This is my limit of thinking, so if there are other unevaluated contexts, then what are they?</p>\n", "AcceptedAnswerId": "35088909", "Title": "What are unevaluated contexts in C++?", "CreationDate": "2016-01-29T15:52:47.793", "Id": "35088599", "CommentCount": "11", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2016-01-29T15:56:51.010", "LastEditorUserId": "4882052", "LastActivityDate": "2016-01-29T19:28:55.447", "Score": "37", "OwnerUserId": "4882052", "Tags": "<c++><c++11>", "AnswerCount": "2"}});