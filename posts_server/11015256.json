post_cb({"11015256": {"AcceptedAnswerId": "11015488", "Body": "<p>Suppose I have the following simple struct:</p>\n<pre><code>struct Vector3\n{\n    double x;\n    double y;\n    double z;\n};\n</code></pre>\n<p>and I create a list of vertices:</p>\n<pre><code>std::vector&lt;Vector3&gt; verticesList;\n</code></pre>\n<p>In addition to this I need to use a third-party library. The library has a function with the following signature:</p>\n<pre><code>typedef double[3] Real3;\nexternal void createMesh(const Real3* vertices, const size_t verticesCount);\n</code></pre>\n<p>What is the best way to convert <code>verticesList</code> into something which could be passed into <code>createMesh()</code> as the <code>vertices</code> parameter?</p>\n<p>At the moment I use the following approach:</p>\n<pre><code>static const size_t MAX_VERTICES = 1024;\n\nif (verticesList.size() &gt; MAX_VERTICES)\n    throw std::exception(\"Number of vertices is too big\");\n\nReal3 rawVertices[MAX_VERTICES];\nfor (size_t vertexInd = 0; vertexInd &lt; verticesList.size(); ++vertexInd)\n{\n    const Vector3&amp; vertex = verticesList[vertexInd];\n\n    rawVertices[vertexInd][0] = vertex.x;\n    rawVertices[vertexInd][1] = vertex.y;\n    rawVertices[vertexInd][2] = vertex.z;\n}\n\ncreateMesh(rawVertices, verticesList.size());\n</code></pre>\n<p>But surely it is not the best way to solve the issue.</p>\n", "CreationDate": "2012-06-13T12:52:12.533", "Score": "2", "CommentCount": "4", "OwnerUserId": "428692", "Title": "How to convert a stl vector of 3-element structs into 2D C-style array", "LastActivityDate": "2012-06-13T15:31:00.247", "PostTypeId": "1", "Tags": "<c++><arrays><stl>", "AnswerCount": "1", "Id": "11015256", "ViewCount": "434"}, "11015488": {"PostTypeId": "2", "ParentId": "11015256", "Body": "<p>That is <em>one</em> proper way of doing it. There are also some other ways...</p>\n<p>The type <code>Vector3</code> is layout compatible with the type <code>Real3</code>, the implication of this is that you can force casting a pointer to one type to a pointer of the other:</p>\n<pre><code>createMesh( reinterpret_cast&lt;Real3*&gt;(&amp;verticesList[0]), vertices.size() );\n</code></pre>\n<p>Other alternative, as Rook mentions, to remove the loop is using <code>memcpy</code>, since the types are POD:</p>\n<pre><code>Real3 rawVertices[MAX_VERTICES];\nstd::memcpy( rawVertices, &amp;verticesList[0], \n             vertices.size()*sizeof verticesList[0] );\n</code></pre>\n<p>This is more concise, and probably more efficient, but it still is copying the whole container.</p>\n<hr>\n<p>I believe that the standard does guarantee this behavior (at least C++11), two standard layout and standard compatible types have the same memory layout (duh?), and \u00a79.2p19 states:</p>\n<blockquote>\n<p id=\"so_11015256_11015488_0\">A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa.</p>\n</blockquote>\n<p>This guarantee technically means something slightly different than what I claimed before:  you can <code>reinterpret_cast&lt;double*&gt;(&amp;verticesList[0])</code> points to <code>verticesList[0].x</code>. But it also implies that the conversion from <code>double*</code> to <code>Real3</code> pointer through reinterpret cast will also be fine.</p>\n</hr>", "CreationDate": "2012-06-13T13:06:56.553", "Score": "5", "LastEditDate": "2012-06-13T15:31:00.247", "CommentCount": "5", "Id": "11015488", "OwnerUserId": "36565", "LastEditorUserId": "36565", "LastActivityDate": "2012-06-13T15:31:00.247"}, "bq_ids": {"n3337": {"so_11015256_11015488_0": {"quality": 1.0, "length": 19, "section_id": 5650}}}});