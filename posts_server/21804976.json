post_cb({"21804976": {"CommentCount": "1", "ViewCount": "67", "OwnerDisplayName": "user1508519", "CreationDate": "2014-02-15T23:14:00.137", "LastActivityDate": "2014-02-16T05:34:15.417", "PostTypeId": "1", "AcceptedAnswerId": "21807738", "Title": "How many different class template permutations are there in the standard library?", "Id": "21804976", "Score": "0", "Body": "<p>Let's say I want to do something contrived like this:</p>\n<pre><code>template&lt;typename T, template &lt;typename, typename&gt; class Cont&gt;\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Cont&lt;T, std::allocator&lt;T&gt;&gt; cont)\n{\n    for (const auto&amp; el : cont)\n        std::cout &lt;&lt; el &lt;&lt; \"\\n\";\n    return os;\n}\n\ntemplate&lt;typename T, template &lt;typename, typename&gt; class Cont&gt;\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Cont&lt;T, std::deque&lt;T&gt;&gt; cont)\n{\n    while (!cont.empty())\n    {\n        std::cout &lt;&lt; cont.top() &lt;&lt; \"\\n\";\n        cont.pop();\n    }\n    return os;\n}\n</code></pre>\n<p>I realize I can just do <code>std::vector&lt;T&gt;</code> and <code>std::stack&lt;T&gt;</code> but from what I understand, <code>deque</code> and <code>vector</code> for example have similar interfaces. The first overload will accept <code>deque</code>, <code>forward_list</code> and <code>vector</code>. So my question is, is there a simple list or graph that will tell me how many overloads I need?</p>\n", "Tags": "<c++><c++11><stl>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_21804976_21807738_0": {"section_id": 772, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_21804976_21807738_0": {"section_id": 759, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_21804976_21807738_0": {"section_id": 834, "quality": 0.7857142857142857, "length": 11}}}, "21807738": {"ParentId": "21804976", "CommentCount": "1", "CreationDate": "2014-02-16T05:34:15.417", "OwnerUserId": "923854", "PostTypeId": "2", "Id": "21807738", "Score": "2", "Body": "<p>The standard sequence containers are enumerated in \u00a7 23.3.1 [sequences.general]/1:</p>\n<blockquote>\n<p id=\"so_21804976_21807738_0\">The headers <code>&lt;array&gt;</code>, <code>&lt;deque&gt;</code>, <code>&lt;forward_list&gt;</code>, <code>&lt;list&gt;</code>, and <code>&lt;vector&gt;</code> define template classes that meet the requirements for sequence containers.</p>\n</blockquote>\n<p>That said, I would prefer a generic solution using traits to detect types that are sequence-like and stack-like. I'll call anything a sequence that has members <code>begin</code> and <code>end</code> that return the same type:</p>\n<pre><code>template &lt;bool B, typename T&gt;\nusing enable_if =\n  typename std::enable_if&lt;B, T&gt;::type;\n\ntemplate &lt;typename T&gt;\nstruct is_sequence_helper {\n  template &lt;typename U=T&gt;\n  static auto test(int) -&gt;\n    enable_if&lt;\n      std::is_same&lt;\n        decltype(std::declval&lt;U&gt;().begin()),\n        decltype(std::declval&lt;U&gt;().end())\n      &gt;::value,\n      std::true_type\n    &gt;;\n\n  template &lt;typename U=T&gt;\n  static auto test(...) -&gt; std::false_type;\n};\n\ntemplate &lt;typename T&gt;\nusing is_sequence =\n  decltype(is_sequence_helper&lt;T&gt;::test(0));\n</code></pre>\n<p>and we'll say anything with members <code>top</code>, <code>pop</code>, and <code>empty() const</code> is a stack:</p>\n<pre><code>template &lt;typename T&gt;\nstruct is_stack_helper {\n  template &lt;typename U=T&gt;\n  static auto test(int) -&gt;\n    decltype((std::declval&lt;U&gt;().top(),\n              std::declval&lt;U&gt;().pop(),\n              std::declval&lt;const U&gt;().empty(),\n              std::true_type{}));\n\n  template &lt;typename U=T&gt;\n  static auto test(...) -&gt; std::false_type;\n};\ntemplate &lt;typename T&gt;\nusing is_stack =\n  decltype(is_stack_helper&lt;T&gt;::test(0));\n</code></pre>\n<p>With these traits we can constrain your stream insertion operators more generically to work on sequences or stacks:</p>\n<pre><code>template&lt;typename Sequence&gt;\nenable_if&lt;\n  is_sequence&lt;Sequence&gt;::value &amp;&amp; !is_stack&lt;Sequence&gt;::value,\n  std::ostream&amp;\n&gt; operator&lt;&lt;(std::ostream&amp; os, const Sequence&amp; cont) {\n  os &lt;&lt; \"sequence version:\\n\";\n  for (const auto&amp; el : cont)\n    os &lt;&lt; el &lt;&lt; '\\n';\n  return os;\n}\n\ntemplate&lt;typename Stack&gt;\nenable_if&lt;\n  is_stack&lt;Stack&gt;::value,\n  std::ostream&amp;\n&gt; operator&lt;&lt;(std::ostream&amp; os, Stack&amp; cont) {\n  os &lt;&lt; \"stack version:\\n\";\n  for (; !cont.empty(); cont.pop())\n    os &lt;&lt; cont.top() &lt;&lt; '\\n';\n  return os;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/a81f704b9247c1bc\" rel=\"nofollow\" title=\"Live demo\">See it all pulled together and working at Coliru</a>.</p>\n", "LastActivityDate": "2014-02-16T05:34:15.417"}});