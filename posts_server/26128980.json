post_cb({"26128980": {"CommentCount": "6", "AcceptedAnswerId": "26129015", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2014-09-30T19:53:53.310", "LastActivityDate": "2014-10-01T09:42:49.687", "LastEditDate": "2014-10-01T01:30:35.870", "ViewCount": "981", "FavoriteCount": "3", "Title": "Incrementing a Constant in C++", "Id": "26128980", "Score": "5", "Body": "<p>Can someone explain to me as why this code works? I feel like the compiler should not allow me to do what I have done (move an int pointer to point at a const int), or alternatively I would at least expect a compiler warning or a segfault. The idea of changing the value of a constant just seems so wrong.</p>\n<p>Code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct test_struct {\n    int i;\n    const int j;\n};\n\nint main() {\n    cout &lt;&lt; \"Create a struct with int i = 100 and const int j = 101.\" &lt;&lt; endl;\n    test_struct test{100, 101};\n    cout &lt;&lt; test.i &lt;&lt; endl;\n    cout &lt;&lt; test.j &lt;&lt; endl;\n    cout &lt;&lt; \"Create pointer p and point it to int i.\" &lt;&lt; endl;\n    int* p1 = &amp;test.i;\n    cout &lt;&lt; *p1 &lt;&lt; endl;\n    cout &lt;&lt; \"Increment pointer p, which should now be pointing at const int j.\" &lt;&lt; endl;\n    p1++;\n    cout &lt;&lt; *p1 &lt;&lt; endl;\n    cout &lt;&lt; \"Dereference p and increment it.\" &lt;&lt; endl;\n    (*p1)++;\n    cout &lt;&lt; *p1 &lt;&lt; endl;\n    cout &lt;&lt; test.j &lt;&lt; endl;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>Create a struct with int i = 100 and const int j = 101.\n100\n101\nCreate pointer p and point it to int i.\n100\nIncrement pointer p, which should now be pointing at const int j.\n101\nDereference p and increment it.\n102\n102\n</code></pre>\n", "Tags": "<c++><pointers><const><undefined-behavior>", "OwnerUserId": "981389", "AnswerCount": "3"}, "26129256": {"ParentId": "26128980", "PostTypeId": "2", "CommentCount": "5", "Body": "<p><em>(This answer is correct for Visual Studio 2010 - not sure about other compilers.)</em></p>\n<p>Here is the reason why this is allowed:</p>\n<p>The <code>const</code> modifier is an instruction to the compiler to prevent the user from editing that declared variable. When working with that variable the compiler will prevent you from making changes to it, and require you to add the <code>const</code> modifier to pointers associated with that particular variable. </p>\n<p>However, all like other variable values, it resides in memory, and the compiler doesn't specifically prevent access to or editing of that memory. It can be accessed and modified just like any other memory address using a pointer, if you choose to subvert the compiler's instructions, as you have done in your code.</p>\n<p>If you are looking to prevent program access to areas in memory, you can refer to the following memory protection constants for Windows:</p>\n<p><a href=\"http://msdn.microsoft.com/en-us/library/windows/desktop/aa366786(v=vs.85).aspx\" rel=\"nofollow\">http://msdn.microsoft.com/en-us/library/windows/desktop/aa366786(v=vs.85).aspx</a></p>\n", "OwnerUserId": "2076574", "LastEditorUserId": "712579", "LastEditDate": "2014-09-30T22:18:23.287", "Id": "26129256", "Score": "1", "CreationDate": "2014-09-30T20:12:31.880", "LastActivityDate": "2014-09-30T22:18:23.287"}, "26129686": {"ParentId": "26128980", "CommentCount": "0", "Body": "<p>the data items in the structure are stored on stack in memory,so when you create a pointer and make it point to the first item,the address that is stored is the position of the stack pointer.when u increment it the stack pointer increments to the next location on stack i.e the second data item.\nthus this might be the possible reason.because otherwise it should have given an error,and also we can't treat a structure like an array. Bt still its able to point to the next item,possible only if we consider the stack created in memory.</p>\n", "OwnerUserId": "4087766", "PostTypeId": "2", "Id": "26129686", "Score": "-1", "CreationDate": "2014-09-30T20:39:19.013", "LastActivityDate": "2014-09-30T20:39:19.013"}, "bq_ids": {"n4140": {"so_26128980_26129015_2": {"section_id": 6142, "quality": 1.0, "length": 32}, "so_26128980_26129015_1": {"section_id": 6141, "quality": 0.9473684210526315, "length": 18}, "so_26128980_26129015_0": {"section_id": 5433, "quality": 1.0, "length": 10}, "so_26128980_26129015_3": {"section_id": 6064, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_26128980_26129015_2": {"section_id": 5906, "quality": 1.0, "length": 32}, "so_26128980_26129015_1": {"section_id": 5905, "quality": 0.9473684210526315, "length": 18}, "so_26128980_26129015_0": {"section_id": 5228, "quality": 1.0, "length": 10}, "so_26128980_26129015_3": {"section_id": 5832, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_26128980_26129015_2": {"section_id": 7638, "quality": 0.625, "length": 20}, "so_26128980_26129015_1": {"section_id": 7603, "quality": 0.5789473684210527, "length": 11}, "so_26128980_26129015_0": {"section_id": 6861, "quality": 1.0, "length": 10}, "so_26128980_26129015_3": {"section_id": 7560, "quality": 0.8888888888888888, "length": 16}}}, "26129015": {"ParentId": "26128980", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>You program invokes <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\">undefined behavior</a> in two ways, which means the behavior of your program is unpredictable, even seemingly normal behavior is possible.</p>\n<p>First although we can treat the individual elements of a struct as arrays once you increment the pointer it is no longer valid to dereference it, it does not not even have to be pointing to the next element it could very well be pointing to padding.</p>\n<p>Second, attempting to alter a const in also undefined behavior. The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\">draft C++ standard</a> section <code>7.1.6.1</code> <em>The cv-qualifiers</em> paragraph <em>4</em> which says:</p>\n<blockquote>\n<p id=\"so_26128980_26129015_0\">[...]any attempt to modify a const object during its lifetime (3.8) results in undefined behavior.</p>\n</blockquote>\n<p>We can see for the purposes of pointer arithmetic a non-array variable is treated as an array of one element, from section <code>5.7</code> <em>Additive operators</em> which says:</p>\n<blockquote>\n<p id=\"so_26128980_26129015_1\">For the purposes of these operators, a pointer to a nonarray object\n  behaves the same as a pointer to the first element of an array of\n  length one with the type of the object as its element type.</p>\n</blockquote>\n<p>and furthermore dereferecing one past the end of an array is undefined behavior, from the same section:</p>\n<blockquote>\n<p id=\"so_26128980_26129015_2\">When an expression that has integral type is added to or subtracted\n  from a pointer, the result has the type of the pointer operand. [...]\n  If both the pointer operand and the result point to elements of the\n  same array object, or one past the last element of the array object,\n  the evaluation shall not produce an overflow; otherwise, the behavior\n  is undefined.</p>\n</blockquote>\n<p>we can further see from section <code>5.3.1</code> <em>Unary operators</em> which says:</p>\n<blockquote>\n<p id=\"so_26128980_26129015_3\">The unary * operator performs indirection: the expression to which it\n  is applied shall be a pointer to an object type, or a pointer to a\n  function type and the result is an <strong>lvalue referring to the object</strong> or\n  function</p>\n</blockquote>\n<p>when we dereference a pointer we expect and <em>object</em> which we are not guaranteed to have once we are one past the end.</p>\n<p>The <a href=\"https://gcc.gnu.org/onlinedocs/libstdc++/manual/iterators.html\">The GNU C++ Library</a> has an easier to access explanation which says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_26128980_26129015_4\">You can only dereference a pointer that points into an array. If your\n  array pointer points outside the array -- even to just one past the\n  end -- and you dereference it, <strong>Bad Things happen.</strong></p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-10-01T09:42:49.687", "Id": "26129015", "Score": "18", "CreationDate": "2014-09-30T19:56:28.333", "LastActivityDate": "2014-10-01T09:42:49.687"}});