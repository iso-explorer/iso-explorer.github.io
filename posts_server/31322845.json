post_cb({"31322897": {"ParentId": "31322845", "CommentCount": "0", "Body": "<p>No, a reference must be initialised as it is declared to support the guarantee that there are no references that point into nowhere.</p>\n", "OwnerUserId": "4999494", "PostTypeId": "2", "Id": "31322897", "Score": "0", "CreationDate": "2015-07-09T16:13:53.660", "LastActivityDate": "2015-07-09T16:13:53.660"}, "31322900": {"ParentId": "31322845", "CommentCount": "0", "Body": "<p>There is such a thing as an empty pointer, but there is not such a thing as an empty reference. A reference <strong>has to</strong> have something that it refers to. It <strong>must be</strong> initialized.</p>\n<pre><code>int&amp; r; // error\n</code></pre>\n<p>This is one of the main differences between a pointer and a reference, and is one of the reasons to potentially prefer taking a reference argument (must be valid) over a pointer argument (can be null). </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "31322900", "Score": "1", "CreationDate": "2015-07-09T16:14:04.773", "LastActivityDate": "2015-07-09T16:14:04.773"}, "31322886": {"ParentId": "31322845", "CommentCount": "0", "Body": "<p>You have no way to do this.\nReference should be constant so you may only initialize it.</p>\n", "OwnerUserId": "1750757", "PostTypeId": "2", "Id": "31322886", "Score": "0", "CreationDate": "2015-07-09T16:13:30.330", "LastActivityDate": "2015-07-09T16:13:30.330"}, "31322885": {"ParentId": "31322845", "LastEditDate": "2015-07-09T16:14:48.200", "CommentCount": "4", "CreationDate": "2015-07-09T16:13:28.700", "OwnerUserId": "2432477", "LastEditorUserId": "2432477", "PostTypeId": "2", "Id": "31322885", "Score": "4", "Body": "<p>You just can't. Consider the reference like a <code>const</code> pointer:</p>\n<p><code>int&amp; foo = x</code> is the same as <code>int * const foo = &amp;x</code>.</p>\n<p>That's why you can't re-assign a reference, or declare a new one without a value.</p>\n", "LastActivityDate": "2015-07-09T16:14:48.200"}, "31322959": {"ParentId": "31322845", "LastEditDate": "2015-07-10T02:39:09.733", "CommentCount": "0", "CreationDate": "2015-07-09T16:16:48.117", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "PostTypeId": "2", "Id": "31322959", "Score": "5", "Body": "<p>No, this can not be done, there are only a few cases where an intializer for a reference can be omitted, from the draft C++ standard section <code>8.5.3</code> <em>[dcl.init.ref]</em>:</p>\n<blockquote>\n<p id=\"so_31322845_31322959_0\">The initializer can be omitted for a reference only in a parameter\n  declaration (8.3.5), in the declaration of a function return type, in\n  the declaration of a class member within its class definition (9.2),\n  and where the extern specifier is explicitly used. [ Example:</p>\n<pre><code>int&amp; r1; // error: initializer missing\nextern int&amp; r2; // OK\n</code></pre>\n<p id=\"so_31322845_31322959_1\">\u2014end example ]</p>\n</blockquote>\n<p>As to why we find the following rationale for why references are not resettable from <a href=\"http://www.stroustrup.com/dne.html\" rel=\"nofollow\">The Design and Evolution of C++</a>:</p>\n<blockquote>\n<p id=\"so_31322845_31322959_2\">It is not possible to change what a reference refers to after\n  initialization. That is once a C++ reference is initialized it cannot\n  be made to refer to a different object later; it cannot be re-bound. I\n  had in the past been bitten by Algol68 references where <code>r1=r2</code> can\n  either assign through r1 to the object referred to or assign to a new\n  reference value to r1 (re-binding r1) depending on the type of r2. I\n  wanted to avoid such problems in C++.</p>\n</blockquote>\n", "LastActivityDate": "2015-07-10T02:39:09.733"}, "31323124": {"ParentId": "31322845", "CommentCount": "0", "Body": "<p>No you can't.\nA possible workaround is to use <code>std::boost::optional&lt;T&amp;&gt;</code> or simply <code>T*</code></p>\n<pre><code>int x;\nboost::optional&lt;int&amp;&gt; foo; // or int* foo = nullptr;\n\nfoo = x; // foo = &amp;x;\n// foo is now a 'reference' to x\n\n*foo = 56; // now, we have x == 56\n</code></pre>\n", "OwnerUserId": "2684539", "PostTypeId": "2", "Id": "31323124", "Score": "2", "CreationDate": "2015-07-09T16:23:52.293", "LastActivityDate": "2015-07-09T16:23:52.293"}, "bq_ids": {"n4140": {"so_31322845_31322959_0": {"section_id": 3319, "quality": 0.875, "length": 21}}, "n3337": {"so_31322845_31322959_0": {"section_id": 3189, "quality": 0.875, "length": 21}}, "n4659": {"so_31322845_31322959_0": {"section_id": 4085, "quality": 0.875, "length": 21}}}, "31322845": {"CommentCount": "3", "CreationDate": "2015-07-09T16:11:26.407", "PostTypeId": "1", "AcceptedAnswerId": "31322885", "LastEditorUserId": "1708801", "LastActivityDate": "2015-07-10T02:39:09.733", "LastEditDate": "2015-07-09T17:59:13.517", "ViewCount": "91", "FavoriteCount": "0", "Title": "Creating a reference variable in two statements", "Id": "31322845", "Score": "2", "Body": "<pre><code>int x;\nint&amp; foo = x;\n\n// foo is now a reference to x so this sets x to 56\nfoo = 56;\n</code></pre>\n<p>How can I split the statement <code>int&amp; foo = x;</code> into two statements?</p>\n<p>By splitting, I mean using two statements such as in the below example:</p>\n<pre><code>int y;\nint* ptr = &amp;y;\n</code></pre>\n<p>I can split the <code>int* ptr = &amp;y</code> into two statements declaring the pointer first.</p>\n<pre><code>int* ptr;\nptr = &amp;y; //then assigning the pointer to point to y\n</code></pre>\n<p>How to do a similar thing to a reference?  I'm looking also for an explanation on why or why not?</p>\n", "Tags": "<c++><reference>", "OwnerUserId": "5058495", "AnswerCount": "6"}});