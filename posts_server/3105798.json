post_cb({"3105798": {"ViewCount": "27429", "Body": "<p>In C++, the concept of returning reference from the copy assignment operator is unclear to me. Why can't the copy assignment operator return a copy of the new object? In addition, if I have class A, and the following:</p>\n<pre><code>A a1(param);\nA a2 = a1;\nA a3;\n\na3 = a2; //&lt;--- this is the problematic line\n</code></pre>\n<p>The operator= is defined as follows:</p>\n<pre><code>A A::operator =(const A&amp; a)\n{\n    if (this == &amp;a)\n    {\n        return *this;\n    }\n    param = a.param;\n    return *this;\n}\n</code></pre>\n", "AcceptedAnswerId": "3106307", "Title": "Why must the copy assignment operator return a reference/const reference?", "CreationDate": "2010-06-23T21:45:23.770", "Id": "3105798", "CommentCount": "5", "FavoriteCount": "23", "PostTypeId": "1", "LastEditDate": "2012-09-18T03:11:32.073", "LastEditorUserId": "1288", "LastActivityDate": "2015-03-27T02:44:23.977", "Score": "46", "OwnerUserId": "165702", "Tags": "<c++><operator-overloading><copy-constructor><assignment-operator>", "AnswerCount": "6"}, "3106307": {"Id": "3106307", "PostTypeId": "2", "Body": "<p>Strictly speaking, the result of a copy assignment operator doesn't need to return a reference, though to mimic the default behavior the C++ compiler uses, it should return a non-const reference to the object that is assigned to (an implicitly generated copy assignment operator will return a non-const reference - C++03: 12.8/10).  I've seen a fair bit of code that returns <code>void</code> from copy assignment overloads, and I can't recall when that caused a serious problem.  Returning <code>void</code> will prevent users from 'assignment chaining' (<code>a = b = c;</code>), and will prevent using the result of an assignment in a test expression, for example. While that kind of code is by no means unheard of, I also don't think it's particularly common - especially for non-primitive types (unless the interface for a class intends for these kinds of tests, such as for iostreams).</p>\n<p>I'm not recommending that you do this, just pointing out that it's permitted and that it doesn't seem to cause a whole lot of problems.</p>\n<p>These other SO questions are related (probably not quite dupes) that have information/opinions that might be of interest to you.</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/2649068/has-anyone-found-the-need-to-declare-the-return-parameter-of-a-copy-assignment-op\">Has anyone found the need to declare the return parameter of a copy assignment operator const?</a></li>\n<li><a href=\"https://stackoverflow.com/questions/2447696/overloading-assignment-operator-in-c\">Overloading assignment operator in C++</a></li>\n</ul>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-02-19T03:39:25.860", "Score": "52", "CreationDate": "2010-06-23T23:31:58.493", "ParentId": "3105798", "CommentCount": "2", "OwnerUserId": "12711", "LastEditDate": "2017-05-23T12:32:26.740"}, "4771782": {"Id": "4771782", "PostTypeId": "2", "Body": "<p>A bit of clarification as to why it's preferable to return by reference for <strong><em>operator=</em></strong> versus return by value --- as the chain a=b=c will work fine if a value is returned.</p>\n<p>If you return a reference, minimal work is done.  The values from one object are copied to another object.</p>\n<p>However, if you return by value for <strong><em>operator=</em></strong>, you will call a constructor AND destructor EACH time that the assignment operator is called!!  </p>\n<p>So given:</p>\n<pre><code>A&amp; operator=(constA&amp; rhs){ ... };\n</code></pre>\n<p>Then</p>\n<pre><code>a=b=c;// calls assignment operator above twice. Nice and simple.\n</code></pre>\n<p>but</p>\n<pre><code>A operator=(constA&amp; rhs){ ... };\n\na=b=c; // calls assignment operator twice, calls copy constructor twice, calls destructor type to delete the temporary values! Very wasteful and nothing gained!\n</code></pre>\n<p>In sum, there is nothing gained by returning by value, but a lot to lose.  </p>\n<p>(Note: This isn't meant to address the advantages of having the assignment operator return an l-value.  Read the other posts for why that might be preferable)</p>\n", "LastEditorUserId": "2074608", "LastActivityDate": "2014-02-22T07:18:07.880", "Score": "42", "CreationDate": "2011-01-23T01:41:42.527", "ParentId": "3105798", "CommentCount": "1", "OwnerUserId": "586068", "LastEditDate": "2014-02-22T07:18:07.880"}, "bq_ids": {"n4140": {"so_3105798_26985436_3": {"length": 33, "quality": 1.0, "section_id": 3270}, "so_3105798_26985436_1": {"length": 5, "quality": 0.625, "section_id": 763}}, "n3337": {"so_3105798_26985436_3": {"length": 33, "quality": 1.0, "section_id": 3142}, "so_3105798_26985436_1": {"length": 5, "quality": 0.625, "section_id": 750}}, "n4659": {"so_3105798_26985436_3": {"length": 33, "quality": 1.0, "section_id": 4028}, "so_3105798_26985436_1": {"length": 5, "quality": 0.625, "section_id": 823}}}, "26985363": {"Id": "26985363", "PostTypeId": "2", "Body": "<p>When you overload <code>operator=</code>, you <em>can</em> write it to return whatever type you want. If you want to badly enough, you can overload <code>X::operator=</code> to return (for example) an instance of some completely different class <code>Y</code> or <code>Z</code>. This is generally <em>highly</em> inadvisable though.</p>\n<p>In particular, you usually want to support chaining of <code>operator=</code> just like C does. For example:</p>\n<pre><code>int x, y, z;\n\nx = y = z = 0;\n</code></pre>\n<p>That being the case, you usually want to return an lvalue or rvalue of the type being assigned to. That only leaves the question of whether to return a reference to X, a const reference to X, or an X (by value).</p>\n<p>Returning a const reference to X is generally a poor idea. In particular, a const reference is allowed to bind to a temporary object. The lifetime of the temporary is extended to the lifetime of the reference to which it's bound--but not recursively to the lifetime of whatever that might be assigned to. This makes it easy to return a dangling reference--the const reference binds to a temporary object. That object's lifetime is extended to the lifetime of the reference (which ends at the end of the function). By the time the function returns, the lifetime of the reference and temporary have ended, so what's assigned is a dangling reference.</p>\n<p>Of course, returning a non-const reference doesn't provide complete protection against this, but at least makes you work a little harder at it. You can still (for example) define some local, and return a reference to it (but most compilers can and will warn about this too).</p>\n<p>Returning a value instead of a reference has both theoretical and practical problems. On the theoretical side, you have a basic disconnect between <code>=</code> normally means and what it means in this case. In particular, where assignment normally means \"take this existing source and assign its value to this existing destination\", it starts to mean something more like \"take this existing source, create a copy of it, and assign that value to this existing destination.\"</p>\n<p>From a practical viewpoint, especially before rvalue references were invented, that could have a significant impact on performance--creating an entire new object in the course of copying A to B was unexpected and often quite slow. If, for example, I had a small vector, and assigned it to a larger vector, I'd expect that to take, at most, time to copy elements of the small vector plus a (little) fixed overhead to adjust the size of the destination vector. If that instead involved <em>two</em> copies, one from source to temp, another from temp to destination, and (worse) a dynamic allocation for the temporary vector, my expectation about the complexity of the operation would be <em>entirely</em> destroyed. For a small vector, the time for the dynamic allocation could easily be many times higher than the time to copy the elements.</p>\n<p>The only other option (added in C++11) would be to return an rvalue reference. This could easily lead to unexpected results--a chained assignment like <code>a=b=c;</code> could destroy the contents of <code>b</code> and/or <code>c</code>, which would be quite unexpected.</p>\n<p>That leaves returning a normal reference (not a reference to const, nor an rvalue reference) as the only option that (reasonably) dependably produces what most people normally want.</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2015-03-27T02:44:23.977", "Score": "8", "CreationDate": "2014-11-18T02:04:07.830", "ParentId": "3105798", "CommentCount": "3", "OwnerUserId": "179910", "LastEditDate": "2015-03-27T02:44:23.977"}, "26985436": {"Id": "26985436", "PostTypeId": "2", "Body": "<p>There is no core language requirement on the result type of a user-defined <code>operator=</code>, but the standard library does have such a requirement:</p>\n<p>C++98 \u00a723.1/3:</p>\n<blockquote>\n<p id=\"so_3105798_26985436_0\"><strong>\u201d</strong> The type of objects stored in these components must meet the requirements of <code>CopyConstructible</code>\n  types (20.1.3), and the additional requirements of <code>Assignable</code> types.</p>\n</blockquote>\n<p>C++98 \u00a723.1/4:</p>\n<blockquote>\n<p id=\"so_3105798_26985436_1\"><strong>\u201d</strong> In Table 64, <code>T</code> is the type used to instantiate the container, <code>t</code> is a value of <code>T</code>, and <code>u</code> is a value of (possibly <code>const</code>) <code>T</code>.  </p>\n<p id=\"so_3105798_26985436_2\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/GlWDd.png\"/></p>\n</blockquote>\n<hr>\n<p>Returning a copy by value would still support assignment chaining like <code>a = b = c = 42;</code>, because the assignment operator is right-associative, i.e. this is parsed as <code>a = (b = (c = 42));</code>. But returning a copy would prohibit meaningless constructions like <code>(a = b) = 666;</code>. For a small class returning a copy could conceivably be most efficient, while for a larger class returning by reference will generally be most efficient (and a copy, prohibitively inefficient).</p>\n<p>Until I learned about the standard library requirement I used to let <code>operator=</code> return <code>void</code>, for efficiency and to avoid the absurdity of supporting side-effect based bad code.</p>\n<hr>\n<p>With C++11 there is additionally the requirement of <code>T&amp;</code> result type for <code>default</code>-ing the assignment operator, because</p>\n<p>C++11 \u00a78.4.2/1:</p>\n<blockquote>\n<p id=\"so_3105798_26985436_3\"><strong>\u201d</strong> A function that is explicitly defaulted shall [\u2026]  have the same declared function type (except for possibly differing <em>ref-qualifiers</em> and except that in\n  the case of a copy constructor or copy assignment operator, the parameter type may be \u201creference to non-const <code>T</code>\u201d, where <code>T</code> is the name of the member function\u2019s class) as if it had been implicitly declared</p>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "464581", "LastActivityDate": "2014-11-18T02:30:35.763", "Score": "3", "CreationDate": "2014-11-18T02:14:00.690", "ParentId": "3105798", "CommentCount": "0", "OwnerUserId": "464581", "LastEditDate": "2014-11-18T02:30:35.763"}, "3105926": {"Id": "3105926", "PostTypeId": "2", "Body": "<p><code>operator=</code> can be defined to return whatever you want. You need to be more specific as to what the problem actually is; I suspect that you have the copy constructor use <code>operator=</code> internally and that causes a stack overflow, as the copy constructor calls <code>operator=</code> which must use the copy constructor to return <code>A</code> by value ad infinitum.</p>\n", "LastActivityDate": "2010-06-23T22:07:09.193", "CommentCount": "4", "CreationDate": "2010-06-23T22:07:09.193", "ParentId": "3105798", "Score": "4", "OwnerUserId": "6210"}, "3105842": {"Id": "3105842", "PostTypeId": "2", "Body": "<p>It's partly because returning a reference to self is faster than returning by value, but in addition, it's to allow the original semantics that exist in primitive types.</p>\n", "LastActivityDate": "2010-06-23T21:52:12.277", "CommentCount": "2", "CreationDate": "2010-06-23T21:52:12.277", "ParentId": "3105798", "Score": "4", "OwnerUserId": "298661"}});