post_cb({"25348988": {"ParentId": "25347599", "CommentCount": "1", "CreationDate": "2014-08-17T11:59:14.857", "OwnerUserId": "420683", "PostTypeId": "2", "Id": "25348988", "Score": "15", "Body": "<p>This is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-active.html#2321\">LWG open issue 2321</a> [emphasis mine]</p>\n<blockquote>\n<h3>Moving containers should (usually) be required to preserve iterators</h3>\n<p id=\"so_25347599_25348988_0\">[...]</p>\n<p id=\"so_25347599_25348988_1\">[by Stephan T. Lavavej]<br/>\n  23.2.1 [container.requirements.general]/10 says that unless otherwise specified, \"no swap() function invalidates any references, pointers,\n  or iterators referring to the elements of the containers being\n  swapped. [Note: The end() iterator does not refer to any element, so\n  it may be invalidated. \u2014 end note]\". <strong>However, move constructors and\n  move assignment operators aren't given similar invalidation\n  guarantees.</strong> The guarantees need several exceptions, so I do not\n  believe that blanket language like /11 \"Unless otherwise specified\n  (either explicitly or by defining a function in terms of other\n  functions), invoking a container member function or passing a\n  container as an argument to a library function shall not invalidate\n  iterators to, or change the values of, objects within that container.\"\n  is applicable.</p>\n<p id=\"so_25347599_25348988_2\">[2014-02-13 Issaquah]</p>\n<p id=\"so_25347599_25348988_3\"><strong>General agreeement on intent, several wording nits and additional paragraphs to hit.</strong></p>\n<p id=\"so_25347599_25348988_4\">STL to provide updated wording. <strong>Move to Open.</strong></p>\n<p id=\"so_25347599_25348988_5\"><strong>Proposed resolution:</strong></p>\n<p id=\"so_25347599_25348988_6\">[...]</p>\n<p id=\"so_25347599_25348988_7\">no move constructor [...] of a container (except for <code>array</code>) invalidates any references, pointers, or iterators referring to the elements of the source container. [<em>Note:</em> The <code>end()</code> iterator does not refer to any element, so it may be invalidated. <em>\u2014 end note</em>]</p>\n</blockquote>\n<p>So, this is an open issue, with general agreement on its basic solution (pointer shall not be invalidated by moving). However, it isn't <em>officially</em> accepted (yet?) as a defect. As far as I know, all major implementations do not invalidate pointers when move-constructing, and it seems to be a generally (implicitly) provided guarantee.</p>\n", "LastActivityDate": "2014-08-17T11:59:14.857"}, "25347599": {"CommentCount": "8", "AcceptedAnswerId": "25348988", "CreationDate": "2014-08-17T08:39:22.020", "LastActivityDate": "2014-08-17T11:59:14.857", "PostTypeId": "1", "ViewCount": "1061", "FavoriteCount": "3", "Title": "Am I guaranteed that pointers to std::vector elements are valid after the vector is moved?", "Id": "25347599", "Score": "21", "Body": "<p>Considering this example:</p>\n<pre><code>std::vector&lt;int&gt; v1 = { 1, 2, 3 };\nconst int* i = &amp;v1[1];\nstd::vector&lt;int&gt; v2(std::move(v1));\nstd::cout &lt;&lt; *i &lt;&lt; std::endl;\n</code></pre>\n<p>Even though in many STL implementations this will probably work, am I guaranteed by the standard that no reallocations are performed when a <code>std::vector</code> is moved, and the internal buffer backing <code>v2</code> is the same that used to be the one of <code>v1</code>? I wasn't able to find this information neither on the Internet, nor on the standard itself.</p>\n", "Tags": "<c++><c++11><vector><stl><move>", "OwnerUserId": "671092", "AnswerCount": "2"}, "25347838": {"ParentId": "25347599", "CommentCount": "5", "CreationDate": "2014-08-17T09:12:52.210", "OwnerUserId": "280222", "PostTypeId": "2", "Id": "25347838", "Score": "3", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/utility/move\" rel=\"nofollow\">cppreference.com</a> states that:</p>\n<blockquote>\n<p id=\"so_25347599_25347838_0\">... have the option, but aren't required, to move any resources held by\n  the argument...</p>\n</blockquote>\n<p>It looks like <code>std::move</code> just is a hint to the library that an optimization by transferring ownership is possible, but it's up to the library whether to do that optimization or not.</p>\n<p>That means that you should assume that all pointers to elements are invalidated after the move.</p>\n", "LastActivityDate": "2014-08-17T09:12:52.210"}, "bq_ids": {"n4140": {"so_25347599_25348988_7": {"section_id": 712, "quality": 0.5833333333333334, "length": 14}}, "n3337": {"so_25347599_25348988_7": {"section_id": 701, "quality": 0.5833333333333334, "length": 14}}, "n4659": {"so_25347599_25348988_7": {"section_id": 741, "quality": 0.5833333333333334, "length": 14}}}});