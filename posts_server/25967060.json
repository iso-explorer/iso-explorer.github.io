post_cb({"bq_ids": {"n4140": {"so_25967060_25967060_2": {"length": 5, "quality": 1.0, "section_id": 7203}, "so_25967060_25967060_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 7204}, "so_25967060_25967060_3": {"length": 24, "quality": 0.8888888888888888, "section_id": 7203}, "so_25967060_25967495_0": {"length": 87, "quality": 0.9666666666666667, "section_id": 7204}}, "n3337": {"so_25967060_25967060_2": {"length": 5, "quality": 1.0, "section_id": 6947}, "so_25967060_25967060_3": {"length": 20, "quality": 0.7407407407407407, "section_id": 6947}, "so_25967060_25967060_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 6948}, "so_25967060_25967495_0": {"length": 87, "quality": 0.9666666666666667, "section_id": 6948}}, "n4659": {"so_25967060_25967060_2": {"length": 5, "quality": 1.0, "section_id": 8712}, "so_25967060_25967060_3": {"length": 20, "quality": 0.7407407407407407, "section_id": 8712}, "so_25967060_25967060_1": {"length": 12, "quality": 0.8, "section_id": 8713}, "so_25967060_25967495_0": {"length": 84, "quality": 0.9333333333333333, "section_id": 8713}}}, "25967060": {"ViewCount": "503", "Body": "<p>3.9/6 N3797:</p>\n<blockquote>\n<p id=\"so_25967060_25967060_0\">[...]</p>\n<p id=\"so_25967060_25967060_1\">The type of a pointer to array of unknown size, or of a type defined\n  by a typedef declaration to be an array of unknown size, cannot be\n  completed.</p>\n</blockquote>\n<p>It sounds like a pointer to an array of unknown size is an incomplete type. If so we couldn't define an object of a pointer to array of unknown size. But it is not true, because we can define an array of unknown bound. </p>\n<pre><code>#include &lt;iostream&gt;\n\nusing std::cout;\nusing std::endl;\n\nint (*a)[] = (int(*)[])0x4243afff;\n\nint main()\n{\n\n}\n</code></pre>\n<p>It compiles fine.</p>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/8c055a33b64bd424\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>We could't do it if it were incomplete type. Indeed:\n3.9/5:</p>\n<blockquote>\n<p id=\"so_25967060_25967060_2\">Objects shall not be defined to have an incomplete type</p>\n</blockquote>\n<p>The Standard previously defined an incomplete types as follows 3./5:</p>\n<blockquote>\n<p id=\"so_25967060_25967060_3\">A class that has been declared but not defined, an enumeration type in\n  certain contexts (7.2), or an array of unknown size or of incomplete\n  element type, is an incompletely-defined object type.\n  Incompletely defined object types and the void types are incomplete\n  types (3.9.1).</p>\n</blockquote>\n<p>Which means the pointer to an incomplete type is complete. Contradiction?</p>\n<p>So where I'm wrong in my reasoning?</p>\n", "AcceptedAnswerId": "25967260", "Title": "Is a pointer to an array of unknown size incomplete?", "CreationDate": "2014-09-22T05:11:37.587", "LastActivityDate": "2014-09-29T08:56:34.890", "CommentCount": "15", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-09-29T08:56:34.890", "OwnerDisplayName": "user2953119", "LastEditorUserId": "3747990", "Id": "25967060", "Score": "3", "Tags": "<c++><arrays><pointers>", "AnswerCount": "2"}, "25967495": {"Id": "25967495", "PostTypeId": "2", "Body": "<p>Like C++ statements, English sentences must be interpreted <em>in context</em>. The context of the quoted sentence makes its meaning perfectly clear. The paragraph reads (\u00a73.9 [basic.types]/p6, the sentence you quoted is bolded):</p>\n<blockquote>\n<p id=\"so_25967060_25967495_0\">A class type (such as \u201c<code>class X</code>\u201d) might be incomplete at one point in\n  a translation unit and complete later on; the type \u201c<code>class X</code>\u201d is the\n  same type at both points. The declared type of an array object might\n  be an array of incomplete class type and therefore incomplete; if the\n  class type is completed later on in the translation unit, the array\n  type becomes complete; the array type at those two points is the same\n  type. The declared type of an array object might be an array of\n  unknown size and therefore be incomplete at one point in a translation\n  unit and complete later on; the array types at those two points\n  (\u201carray of unknown bound of <code>T</code>\u201d and \u201carray of <code>N T</code>\u201d) are different\n  types. <strong>The type of a pointer to array of unknown size, or of a type\n  defined by a <code>typedef</code> declaration to be an array of unknown size,\n  cannot be completed.</strong></p>\n</blockquote>\n<p>Read in context, it's clearly saying that a \"pointer to array of unknown bound of <code>T</code>\" can't be \"completed\" into a \"pointer to array of N <code>T</code>\" in the way that an object declared as an \"array of unknown bound of <code>T</code>\"\" can be later defined as an \"array of N <code>T</code>\"</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-09-29T08:50:09.923", "Score": "0", "CreationDate": "2014-09-22T05:58:01.727", "ParentId": "25967060", "CommentCount": "3", "LastEditDate": "2014-09-29T08:50:09.923", "OwnerUserId": "2756719"}, "25967260": {"Id": "25967260", "PostTypeId": "2", "Body": "<p>I think this wording is defective. In your code:</p>\n<pre><code> int (*a)[];\n</code></pre>\n<p>the type of <code>a</code> is actually complete. The type of <code>*a</code> is incomplete. It seems to me (as dyp says in comments) that the intent of the quote was to say that there is no way that later in the program, <code>*a</code> will be an expression with complete type.</p>\n<p>Background: some incomplete types can be completed later e.g. as suggested by cdhowie and dyp:</p>\n<pre><code>extern int a[];\nint b = sizeof a;  // error\nint a[10];\nint c = sizeof a;  // OK\n</code></pre>\n<p>However <code>int (*a)[];</code> cannot be completed later; <code>sizeof *a</code> will always be an error.</p>\n", "LastEditorUserId": "1505939", "LastActivityDate": "2014-09-22T05:48:24.330", "Score": "6", "CreationDate": "2014-09-22T05:36:51.767", "ParentId": "25967060", "CommentCount": "7", "LastEditDate": "2014-09-22T05:48:24.330", "OwnerUserId": "1505939"}});