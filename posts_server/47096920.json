post_cb({"bq_ids": {"n4140": {"so_47096920_47097250_1": {"length": 17, "quality": 1.0, "section_id": 3304}, "so_47096920_47097250_2": {"length": 4, "quality": 1.0, "section_id": 3285}, "so_47096920_47097250_0": {"length": 12, "quality": 0.6666666666666666, "section_id": 3298}}, "n3337": {"so_47096920_47097250_1": {"length": 17, "quality": 1.0, "section_id": 3174}, "so_47096920_47097250_2": {"length": 4, "quality": 1.0, "section_id": 3155}, "so_47096920_47097250_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 3168}}, "n4659": {"so_47096920_47097250_1": {"length": 15, "quality": 0.8823529411764706, "section_id": 4070}, "so_47096920_47097250_0": {"length": 11, "quality": 0.6111111111111112, "section_id": 4063}}}, "47096920": {"ViewCount": "67", "Body": "<p>By the rules of value initialization. Value initialization occurs:</p>\n<blockquote>\n<p id=\"so_47096920_47096920_0\">1,5) when a nameless temporary object is created with the initializer\n  consisting of an empty pair of parentheses or braces (since C++11);</p>\n<p id=\"so_47096920_47096920_1\">2,6) when an object with dynamic storage duration is created by a\n  new-expression with the initializer consisting of an empty pair of\n  parentheses or braces (since C++11); </p>\n<p id=\"so_47096920_47096920_2\">3,7) when a non-static data\n  member or a base class is initialized using a member initializer with\n  an empty pair of parentheses or braces (since C++11); </p>\n<p id=\"so_47096920_47096920_3\">4) when a named\n  variable (automatic, static, or thread-local) is declared with the\n  initializer consisting of a pair of braces.</p>\n</blockquote>\n<p>Trivial example</p>\n<pre><code>struct A{\n    int i;\n    string s;\n    A(){};\n};\n\nA a{} \ncout &lt;&lt; a.i &lt;&lt; endl // default initialized value\n</code></pre>\n<p>without explicitly declared constructor and left with defaulted default ctor // compiler generated one we get.</p>\n<pre><code>struct A{\n    int i;\n    string s;\n\n};\nA a{};\ncout &lt;&lt; a.i &lt;&lt; endl // zero-initialized value\n</code></pre>\n<p>However using antoher struct.</p>\n<pre><code>struct A{\n    int i;\n    string s;\n\n};\n\nstruct B{\n    A a;\n    int c;\n};\n\nB a{};\ncout &lt;&lt; a.a.i &lt;&lt; endl // default initialized , even tho we did not , int struct B , declared A a{}.\n</code></pre>\n<p>The value of a.i is zero-initialized, even without using {} / () construct, which goes against rules ( if i am not mistaken ).</p>\n<p>Using same logic on struct B:</p>\n<pre><code>struct A{\n    int i;\n    string s;\n\n};\n\nstruct B{\n    A a;\n    int c;\n};\n\nB b;\ncout &lt;&lt; b.c &lt;&lt; endl; // default inicialized\n</code></pre>\n<p>We get behavior according to rules.</p>\n<p>The last example:</p>\n<pre><code>struct A\n{\n    int i;\n    A() { } \n};\n\nstruct B { A a; }; \n\nstd::cout &lt;&lt; B().a.i &lt;&lt; endl;\n</code></pre>\n<p>B().a.i is also zero-initialized while we explicitly declared constructor and its not deleted.</p>\n<p>Why are the these values getting zero-initialized? By rules stated <a href=\"http://en.cppreference.com/w/cpp/language/value_initialization\" rel=\"nofollow noreferrer\">here</a> they should be default-initialized not zero-initialized.</p>\n<p>Thanks for answers.</p>\n", "AcceptedAnswerId": "47097250", "Title": "Value initialization of nested classes", "CreationDate": "2017-11-03T13:28:11.400", "Id": "47096920", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-11-03T14:25:27.683", "Score": "0", "OwnerUserId": "4048191", "Tags": "<c++><c++11><value-initialization>", "AnswerCount": "2"}, "47097490": {"Id": "47097490", "PostTypeId": "2", "Body": "<p>According to the rules of aggregate initialization, the members are indeed value initialized.</p>\n<blockquote>\n<p id=\"so_47096920_47097490_0\"><strong>Value initialization:</strong></p>\n<p id=\"so_47096920_47097490_1\"><em>In all cases, if the empty pair of braces {} is used and T is an aggregate type, <strong>aggregate-initialization</strong> is performed instead of value-initialization.</em></p>\n</blockquote>\n<blockquote>\n<p id=\"so_47096920_47097490_2\"><em>The effects of aggregate initialization are:</em></p>\n<ol start=\"8\">\n<li><em><strong>If the number of initializer clauses is less than the number of members and bases (since C++17) or initializer list is completely empty, the remaining members and bases (since C++17) are initialized by their default initializers, if provided in the class definition, and otherwise (since C++14) by empty lists, in accordance with the usual list-initialization rules (which performs value-initialization for non-class types and non-aggregate classes with default constructors, and aggregate initialization for aggregates).</strong> If a member of a reference type is one of these remaining members, the program is ill-formed.</em></li>\n</ol>\n</blockquote>\n", "LastActivityDate": "2017-11-03T13:54:49.887", "CommentCount": "0", "CreationDate": "2017-11-03T13:54:49.887", "ParentId": "47096920", "Score": "0", "OwnerUserId": "873025"}, "47097250": {"Id": "47097250", "PostTypeId": "2", "Body": "<p>It's the difference between <code>A</code> being an aggregate or not.</p>\n<p>[dcl.init.aggr] (<strong>Emphasis</strong> mine)</p>\n<blockquote>\n<p id=\"so_47096920_47097250_0\">An aggregate is an array or a class (Clause 9) with <strong>no user-provided constructors</strong> (12.1), no brace-or-equal initializers\n  for non-static data members (9.2), no private or protected non-static data members (Clause 11),</p>\n</blockquote>\n<p>So when <code>A</code> has no declared constructors, saying <code>A a{}</code> has the effect of <a href=\"http://en.cppreference.com/w/cpp/language/aggregate_initialization\" rel=\"nofollow noreferrer\">aggregate initialization</a></p>\n<p>which will construct each member with an empty initialization list:</p>\n<blockquote>\n<p id=\"so_47096920_47097250_1\">If there are fewer initializer-clauses in the list than there are members in the aggregate, then each member\n  not explicitly initialized shall be initialized from an empty initializer list</p>\n</blockquote>\n<p>So you get <code>int{}</code> and <code>std::string{}</code> which will value-initialize the integer member to zero.</p>\n<p>When you do provide a default constructor, the aggregate property is lost and the <code>int</code> member remains uninitialized, so accessing it is considered undefined behavior.</p>\n<hr>\n<p>To be specific:</p>\n<p>This code is undefined behavior when accessing <code>a.i</code> because you provided a user-defined constructor, so the <code>int i</code> field remains uninitialized after construction:</p>\n<pre><code>struct A{\n    int i;\n    string s;\n    A(){};\n};\n\nA a{} ;\ncout &lt;&lt; a.i &lt;&lt; endl;\n</code></pre>\n<p>And this code exhibits undefined behavior when accessing <code>b.c</code> because you did not perform list initialization on <code>B b</code>:</p>\n<pre><code>struct B{\n    A a;\n    int c;\n};\n\nB b;\ncout &lt;&lt; b.c &lt;&lt; endl;\n</code></pre>\n<p>All the other code is okay, and will zero-initialize the integer fields. In the scenarios where you are using braces <code>{}</code>, you are performing <em>aggregate-initialization</em>.</p>\n<p>The last example is a little tricky because you're performing <em>value-initialization</em>. Since <code>B</code> is an aggregate, it gets <strong>zero-initialized</strong> ([dcl.init]), in which:</p>\n<blockquote>\n<p id=\"so_47096920_47097250_2\">each base-class\n  subobject is zero-initialized</p>\n</blockquote>\n<p>So again you're okay accessing the integer member of the <code>A</code> subobject.</p>\n</hr>", "LastEditorUserId": "27678", "LastActivityDate": "2017-11-03T14:25:27.683", "Score": "2", "CreationDate": "2017-11-03T13:44:15.550", "ParentId": "47096920", "CommentCount": "2", "OwnerUserId": "27678", "LastEditDate": "2017-11-03T14:25:27.683"}});