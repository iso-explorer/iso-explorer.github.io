post_cb({"8467973": {"Id": "8467973", "PostTypeId": "2", "Body": "<p>\u00a75.2.2/10 (in N3225) states:</p>\n<blockquote>\n<p id=\"so_8467914_8467973_0\">A function call is an lvalue if the result type is an lvalue reference type or an rvalue reference to function type, an xvalue if the result type is an rvalue reference to object type, and a prvalue otherwise.</p>\n</blockquote>\n", "LastActivityDate": "2011-12-11T22:18:21.870", "CommentCount": "1", "CreationDate": "2011-12-11T22:18:21.870", "ParentId": "8467914", "Score": "1", "OwnerUserId": "178761"}, "8467944": {"Id": "8467944", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_8467914_8467944_0\">So, does this mean that return values from functions are always constant by default, and thereby an rvalue? If yes: Are they always constant, or are there exceptions too?</p>\n</blockquote>\n<p>No. They are rvalues iff they don't return a reference type (<code>cv T&amp;</code> or <code>cv T&amp;&amp;</code>). They are constant iff their return type is const-qualified.</p>\n<p>That means a return value from a function <code>X foo()</code> is an rvalue (prvalue, if you want <em>new standardese</em>), and not a constant. Moreover, in an expression like <code>x = foo()</code>, we usually don't care if the temporary changes during the assignment which is pretty much the idea behind move-semantics.</p>\n", "LastEditorUserId": "51831", "LastActivityDate": "2011-12-11T22:24:23.337", "Score": "3", "CreationDate": "2011-12-11T22:13:44.430", "ParentId": "8467914", "CommentCount": "0", "OwnerUserId": "51831", "LastEditDate": "2011-12-11T22:24:23.337"}, "8467951": {"Id": "8467951", "PostTypeId": "2", "Body": "<p>You might be confusing <em>types</em>, <em>objects</em> and <em>expressions</em>. Only <em>expressions</em> have a notion of lvalue/rvalueness. The <em>expression</em> <code>foo();</code> is an rvalue of type <code>X</code>. As such, the statement <code>x = foo();</code> will invoke -- if possible -- the member function <code>X::operator=(X &amp;&amp;)</code> of <code>x</code>. Failing that, it will bind to the standard <code>X::operator=(X const &amp;)</code>, since rvalues bind to const-references.</p>\n<p>Note that it is possible in theory to have constant rvalues, for example if you had a function declared as <code>X const bar();</code>. Then <code>bar()</code> would not bind to <code>X&amp;&amp;</code>, but only to <code>X const &amp;&amp;</code> (as well as to <code>X const &amp;</code>). There is no use for this in practice, though.</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2011-12-11T22:21:26.600", "Score": "1", "CreationDate": "2011-12-11T22:14:50.197", "ParentId": "8467914", "CommentCount": "2", "OwnerUserId": "596781", "LastEditDate": "2011-12-11T22:21:26.600"}, "bq_ids": {"n4140": {"so_8467914_8467973_0": {"length": 21, "quality": 1.0, "section_id": 5997}}, "n3337": {"so_8467914_8467973_0": {"length": 21, "quality": 1.0, "section_id": 5765}}, "n4659": {"so_8467914_8467973_0": {"length": 21, "quality": 1.0, "section_id": 7498}}}, "8467958": {"Id": "8467958", "PostTypeId": "2", "Body": "<p>See <a href=\"https://stackoverflow.com/questions/6466253/if-temporaries-are-implicitly-non-modifiable-how-does-this-work\">this previous question</a>, which tells us that neither are rvalue expressions neither implicitly of a <code>const</code> type, nor are the objects they represent made inherently immutable.</p>\n<p>However, it <em>is</em> undefined (or forbidden \u2014 I forget which) in some cases to modify an object through an rvalue. This does seem to yield a sort of conditional inherent immutability to objects accessed through an rvalue, and the result of evaluating a function call is often \u2014 though not always! \u2014 an rvalue expression.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-12-11T22:35:29.073", "Score": "1", "CreationDate": "2011-12-11T22:15:45.290", "ParentId": "8467914", "CommentCount": "4", "OwnerUserId": "560648", "LastEditDate": "2017-05-23T12:03:38.453"}, "8467914": {"ViewCount": "483", "Body": "<p>I'm learning about rvalue references, and the tutorial told me this:</p>\n<blockquote>\n<pre><code>X foo();\nX x;\nx = foo();\n</code></pre>\n<p id=\"so_8467914_8467914_0\">Rather obviously, it would be ok, and much more efficient, to swap resource pointers (handles) between x and the\n  temporary, and then let the temporary's destructor destruct x's original resource. </p>\n<p id=\"so_8467914_8467914_1\">In other words, <strong>in the special case where the right hand side of the\n  assignment is an rvalue</strong>, we want the copy assignment operator to act\n  like this.</p>\n</blockquote>\n<p>So, does this mean that return values from functions are always constant by default, and thereby an rvalue? If yes: Are they always constant, or are there exceptions too?</p>\n", "AcceptedAnswerId": "8467952", "Title": "Is a function return-value constant by default (an rvalue)?", "CreationDate": "2011-12-11T22:09:53.563", "Id": "8467914", "CommentCount": "1", "LastEditDate": "2011-12-11T22:17:30.143", "PostTypeId": "1", "LastEditorUserId": "560648", "LastActivityDate": "2011-12-12T10:01:59.590", "Score": "1", "OwnerUserId": "929596", "Tags": "<c++><constants><return-value><rvalue>", "AnswerCount": "5"}, "8467952": {"Id": "8467952", "PostTypeId": "2", "Body": "<p>Rvalue-ness and constant-ness are not synonyms, but rather a bit orthogonal. With the following definitions:</p>\n<pre><code>struct X {};\nconst X x;\nconst X f();\nint X();\n</code></pre>\n<p>We can categorize the following <em>expressions</em>:</p>\n<pre><code>x;       // constant lvalue\nf();     // constant rvalue\ng();     // non-constant rvalue\n</code></pre>\n<p>As of your particular question: no, not all rvalue expressions are constant.</p>\n", "LastEditorUserId": "36565", "LastActivityDate": "2011-12-12T10:01:59.590", "Score": "3", "CreationDate": "2011-12-11T22:15:11.770", "ParentId": "8467914", "CommentCount": "8", "OwnerUserId": "36565", "LastEditDate": "2011-12-12T10:01:59.590"}});