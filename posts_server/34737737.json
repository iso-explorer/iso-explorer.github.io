post_cb({"34748943": {"ParentId": "34737737", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The standard makes no guarantees about the representation of a pointer [Note 1]. It is not necessarily the case that the values of a pointer map directly into consecutive integers, nor that pointers to types with different alignments have the same representation. So any of the following are <em>possible</em>:</p>\n<ol>\n<li><p>Segment/offset representation where the segment number occupies the low-order bits of the pointer representation.</p></li>\n<li><p>Pre-aligned representation, where the low-order 0s of the address of an object with known alignment are deleted from the representation.</p></li>\n<li><p>Flagged representation, where the low-order bit(s) of pointers to certain object types are used to identify an aspect of the type, and do not participate in address resolution. (An example of this would be a hardware-assisted garbage-collection architecture in which the low order bits of pointers to types large enough to be pointers are repurposed as GC flags.)</p></li>\n<li><p>Subword addressing representations, where the underlying hardware is word-addressed (and a word is considerably longer than 8 bits), but a hardware or software solution is available for byte addressing where a byte pointer consists of a pair of word address / subword offset. In this case, a byte pointer will be larger than a word pointer, which is allowed by the standard.</p></li>\n</ol>\n<p>I'm sure there are other possibilities.</p>\n<p>An alignment must be a power of 2, but there is no guarantee that more than one alignment exist. It is entirely possible for all types to have alignment 1. So it may well be on a given architecture that it is impossible to meaningfully define <code>Align8Type</code>.</p>\n<p>Given all the above, my interpretation:</p>\n<ol>\n<li><p><code>std::uintptr_t(&amp;align8) &amp; 3 == 0</code></p>\n<p>False. Even if <code>Align8Type</code> is definable, there is no guarantee that the conversion of <code>Align8Type*</code> to <code>std::uintptr_t</code> is to a number divisible by 8. On a 32-bit word addressed machine, for example, the underlying hardware address mod 8 could be 0, 2, 4 or 6.</p></li>\n<li><p><code>dist(nullptr, &amp;align8) &amp; 3 == 0</code></p>\n<p>False. The subtraction of <code>nullptr</code> from a pointer to an object is Undefined Behaviour. (\u00a75.7/5: \"Unless both pointers point to elements of the same array object, or one past the last element of the array object, the behavior is undefined.\")</p></li>\n<li><p><code>reinterpret_cast&lt;Align8Type*&gt;(static_cast&lt;std::uint8_t*&gt;(nullptr) + dist(nullptr, &amp;align8)) == &amp;align8</code></p>\n<p>False. First, as per 2., the invocation of <code>dist</code> is Undefined Behaviour. Second, adding that value to a null pointer is Undefined Behaviour.</p>\n<p>Round-trip conversion of <code>T1*</code> to <code>T2*</code> and back to <code>T1*</code> is guaranteed provided that the alignment requirements of <code>T2</code> are less strict than <code>T1</code> (\u00a75.2.10/7). In this case, <code>T1</code> is <code>Align8Type</code> and <code>T2</code> is <code>uint8_t</code>, and the alignment restriction presumably holds, so if it were not for the undefined behaviour of the arithmetic, this would work. That is, you could cast <code>&amp;align8</code> to <code>uint8_t*</code> and then cast it back to <code>Align8Type</code>. You could even add the integer <code>0</code> to the intermediate <code>uint8_t*</code> pointer, but no other integer.</p></li>\n</ol>\n<hr>\n<p>Do these identities work <em>in practice</em>? They probably work on C++ implementations on 8-bit byte-addressed 2's complement machines, which are pretty common (a lot more common than the theoretical beasts mentioned above, which are, statistically speaking, as common as unicorns). But technically, they render your code non-portable. I have no idea what aggressive optimizations might do to the UB mentioned in points 2 and 3, so I wouldn't suggest risking it in production code.</p>\n<hr>\n<h3>Notes:</h3>\n<ol>\n<li><p>\u00a73.9.2/3:</p>\n<blockquote>\n<p id=\"so_34737737_34748943_0\">The value representation of pointer types is implementation-defined.</p>\n</blockquote>\n<p>\u00a75.2.10/4:</p>\n<blockquote>\n<p id=\"so_34737737_34748943_1\">A pointer can be explicitly converted to any integral type large enough to hold it. The mapping function is\n  implementation-defined. [ Note: It is intended to be unsurprising to those who know the addressing structure of the underlying machine. \u2014end note ]</p>\n</blockquote>\n<p>I reproduced the note, because it is interesting: in order to understand the representation of an address as an integer, you must understand the underlying machine's addressing structure (which, by implication, might not be as simple as a contiguous sequence of integers).</p></li>\n</ol>\n</hr></hr>", "OwnerUserId": "1566221", "LastEditorUserId": "1566221", "LastEditDate": "2016-01-12T17:39:48.210", "Id": "34748943", "Score": "4", "CreationDate": "2016-01-12T16:31:57.380", "LastActivityDate": "2016-01-12T17:39:48.210"}, "34738084": {"ParentId": "34737737", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>In the C++ standard,</p>\n<blockquote>\n<p id=\"so_34737737_34738084_0\">Objects declared as characters (char) shall be large enough to store\n  any member of the implementation\u2019s basic character set.</p>\n<p id=\"so_34737737_34738084_1\">The fundamental storage unit in the C++ memory model is the byte. A\n  byte is at least large enough to contain any member of the basic\n  execution character set (2.3) and the eight-bit code units of the\n  Unicode UTF-8 encoding form and is composed of a contiguous sequence\n  of bits, the number of which is implementation defined.</p>\n<p id=\"so_34737737_34738084_2\">Every byte has a unique address.</p>\n</blockquote>\n<p>A <code>uint_8</code> is not necessarily a byte. And a byte is not necessarily 8 bits</p>\n<p><strong>Are the results of [1] &amp; [2] guaranteed to be 0?</strong></p>\n<p>Supposing Align8Type to have an address 8 byte aligned:</p>\n<p>[1] Yes: by definition of the previous supposition.</p>\n<p>[2] Yes, Even if the byte size could be bigger than uint_8,supposing Align8Type has an address 8 byte aligned, the address will be multiple of 8. (uint_8 is smaller or equal to a byte)</p>\n<p><strong>Is [3] guaranteed to be true in c++ standard?</strong> </p>\n<p>No: <code>dist</code> return the <code>uint_8</code> distance between both pointers, not the address distance.</p>\n<p>EDITED:</p>\n<p>edited to answer the redefined question.</p>\n", "OwnerUserId": "1212756", "LastEditorUserId": "1212756", "LastEditDate": "2016-01-12T09:16:40.773", "Id": "34738084", "Score": "0", "CreationDate": "2016-01-12T07:46:39.450", "LastActivityDate": "2016-01-12T09:16:40.773"}, "bq_ids": {"n4140": {"so_34737737_34738084_2": {"section_id": 5785, "quality": 1.0, "length": 4}, "so_34737737_34748943_0": {"section_id": 7223, "quality": 0.6666666666666666, "length": 4}, "so_34737737_34748943_1": {"section_id": 6043, "quality": 0.8, "length": 20}, "so_34737737_34738084_0": {"section_id": 7210, "quality": 1.0, "length": 12}, "so_34737737_34738084_1": {"section_id": 5785, "quality": 0.8709677419354839, "length": 27}}, "n3337": {"so_34737737_34738084_2": {"section_id": 5558, "quality": 1.0, "length": 4}, "so_34737737_34738084_1": {"section_id": 5558, "quality": 0.8709677419354839, "length": 27}, "so_34737737_34748943_0": {"section_id": 6967, "quality": 0.6666666666666666, "length": 4}, "so_34737737_34738084_0": {"section_id": 6954, "quality": 1.0, "length": 12}, "so_34737737_34748943_1": {"section_id": 5811, "quality": 0.8, "length": 20}}, "n4659": {"so_34737737_34738084_2": {"section_id": 7242, "quality": 1.0, "length": 4}, "so_34737737_34748943_0": {"section_id": 8732, "quality": 0.6666666666666666, "length": 4}, "so_34737737_34748943_1": {"section_id": 7542, "quality": 0.8, "length": 20}, "so_34737737_34738084_0": {"section_id": 8719, "quality": 1.0, "length": 12}, "so_34737737_34738084_1": {"section_id": 7242, "quality": 0.8709677419354839, "length": 27}}}, "34737737": {"CommentCount": "7", "ViewCount": "209", "PostTypeId": "1", "LastEditorUserId": "2969631", "CreationDate": "2016-01-12T07:25:35.050", "LastActivityDate": "2016-01-12T17:39:48.210", "Title": "Relation between numeric representation of memory address and alignment?", "AcceptedAnswerId": "34748943", "LastEditDate": "2016-01-12T08:54:09.040", "Id": "34737737", "Score": "2", "Body": "<p>Example:</p>\n<pre><code>std::ptrdiff_t dist(void* a, void* b)\n{\n    return static_cast&lt;std::uint8_t*&gt;(b) - static_cast&lt;std::uint8_t*&gt;(a);\n}\n\nAlign8Type align8; // alignof(Align8Type) == 8\nstd::uintptr_t(&amp;align8) &amp; 3; // [1]\ndist(nullptr, &amp;align8) &amp; 3; // [2]\nAlign8Type* p = reinterpret_cast&lt;Align8Type*&gt;(static_cast&lt;std::uint8_t*&gt;(nullptr) + dist(nullptr, &amp;align8));\nassert(&amp;align8 == p); // [3]\n</code></pre>\n<p><strong>Assuming <code>std::uint8_t</code> is supported</strong>, are the results of [1] &amp; [2] guaranteed to be 0 and is [3] guaranteed to be true in c++ standard?\nIf not, what about in practice?</p>\n", "Tags": "<c++><pointers><memory><memory-alignment>", "OwnerUserId": "2969631", "AnswerCount": "2"}});