post_cb({"bq_ids": {"n4140": {"so_28158861_28159027_3": {"length": 11, "quality": 1.0, "section_id": 4560}, "so_28158861_28159027_4": {"length": 15, "quality": 1.0, "section_id": 4560}, "so_28158861_28159027_2": {"length": 15, "quality": 1.0, "section_id": 4560}, "so_28158861_28159027_5": {"length": 11, "quality": 1.0, "section_id": 4560}, "so_28158861_28159027_6": {"length": 4, "quality": 1.0, "section_id": 4560}}, "n3337": {"so_28158861_28159027_3": {"length": 11, "quality": 1.0, "section_id": 4390}, "so_28158861_28159027_4": {"length": 15, "quality": 1.0, "section_id": 4390}, "so_28158861_28159027_2": {"length": 15, "quality": 1.0, "section_id": 4390}, "so_28158861_28159027_5": {"length": 11, "quality": 1.0, "section_id": 4390}, "so_28158861_28159027_6": {"length": 4, "quality": 1.0, "section_id": 4390}}, "n4659": {"so_28158861_28159027_3": {"length": 7, "quality": 0.6363636363636364, "section_id": 5932}, "so_28158861_28159027_4": {"length": 9, "quality": 0.6, "section_id": 7709}, "so_28158861_28159027_2": {"length": 9, "quality": 0.6, "section_id": 7709}, "so_28158861_28159027_5": {"length": 7, "quality": 0.6363636363636364, "section_id": 5932}, "so_28158861_28159027_6": {"length": 4, "quality": 1.0, "section_id": 5932}}}, "28159027": {"Id": "28159027", "PostTypeId": "2", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper/operator%28%29\"><code>std::reference_wrapper::operator()</code></a> performs a bit of \"magic\" in some cases beyond what a direct function call would. Its effects are specified as (quoting N4296 [refwrap.invoke]):</p>\n<blockquote>\n<pre><code>template &lt;class... ArgTypes&gt;\nresult_of_t&lt;T&amp;(ArgTypes&amp;&amp;... )&gt;\noperator()(ArgTypes&amp;&amp;... args) const;\n</code></pre>\n<p id=\"so_28158861_28159027_0\">Returns: <code>INVOKE(get(), std::forward&lt;ArgTypes&gt;(args)...)</code>. (20.9.2)</p>\n</blockquote>\n<p>where <code>get()</code> returns a reference to what the <code>reference_wrapper</code> wraps. <code>INVOKE</code> is described in 20.9.2 [func.require]:</p>\n<blockquote>\n<p id=\"so_28158861_28159027_1\">Define <code>INVOKE(f, t1, t2, ..., tN)</code> as follows:</p>\n<p id=\"so_28158861_28159027_2\">(1.1) \u2014 <code>(t1.*f)(t2, ..., tN)</code> when <code>f</code> is a pointer to a member function of a class <code>T</code> and <code>t1</code> is an object of type <code>T</code> or a reference to an object of type <code>T</code> or a reference to an object of a type derived from <code>T</code>;</p>\n<p id=\"so_28158861_28159027_3\">(1.2) \u2014 <code>((*t1).*f)(t2, ..., tN)</code> when <code>f</code> is a pointer to a member function of a class <code>T</code> and <code>t1</code> is not one of the types described in the previous item;</p>\n<p id=\"so_28158861_28159027_4\">(1.3) \u2014 <code>t1.*f</code> when <code>N == 1</code> and <code>f</code> is a pointer to member data of a class <code>T</code> and <code>t1</code> is an object of type <code>T</code> or a reference to an object of type <code>T</code> or a reference to an object of a type derived from <code>T</code>;</p>\n<p id=\"so_28158861_28159027_5\">(1.4) \u2014 <code>(*t1).*f</code> when <code>N == 1</code> and <code>f</code> is a pointer to member data of a class <code>T</code> and <code>t1</code> is not one of the types described in the previous item;</p>\n<p id=\"so_28158861_28159027_6\">(1.5) \u2014 <code>f(t1, t2, ..., tN)</code> in all other cases.</p>\n</blockquote>\n<p>The result of calling <code>ref(f)</code> instead of simply <code>f</code> is that pointer-to-member-function and pointer-to-member-data can be \"called\" with an appropriate object pointer/reference as parameter. For example,</p>\n<pre><code>struct A { void foo(); };\nstruct B : A {};\nstruct C : B {};\nfor_each_arg(&amp;A::foo, A{}, B{}, C{}, std::make_unique&lt;A&gt;());\n</code></pre>\n<p>would call <code>foo</code> on the <code>A</code>, <code>B</code> and <code>C</code> temporary objects and the object held in the <code>unique_ptr</code> (<a href=\"http://coliru.stacked-crooked.com/a/b87d4cd75e64dd98\">DEMO</a>). Why one would <em>prefer</em> to use <code>ref(f)</code> over <code>f</code> would obviously depend on the context in which one is using <code>for_each_arg</code>.</p>\n", "LastEditorUserId": "923854", "LastActivityDate": "2015-01-26T21:47:14.910", "Score": "17", "CreationDate": "2015-01-26T21:24:40.027", "ParentId": "28158861", "CommentCount": "7", "OwnerUserId": "923854", "LastEditDate": "2015-01-26T21:47:14.910"}, "28158861": {"ViewCount": "656", "Body": "<p>Why should one prefer to call std::ref instead of not calling it at all?</p>\n<pre><code>template&lt;class F, class...Ts&gt; F for_each_arg(F f, Ts&amp;&amp;...a) {\n  return (void)initializer_list&lt;int&gt;{(ref(f)((Ts&amp;&amp;)a), 0)...}, f;\n  // why not return (void)initializer_list&lt;int&gt;{(f((Ts&amp;&amp;)a), 0)...}, f;\n}\n</code></pre>\n", "AcceptedAnswerId": "28159027", "Title": "What is std::ref useful for in this function?", "CreationDate": "2015-01-26T21:12:14.360", "Id": "28158861", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-01-26T21:14:49.137", "LastEditorUserId": "923854", "LastActivityDate": "2015-01-26T21:47:14.910", "Score": "10", "OwnerUserId": "989331", "Tags": "<c++><c++11><c++14>", "AnswerCount": "1"}});