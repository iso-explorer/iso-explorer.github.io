post_cb({"10085794": {"ParentId": "10085570", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2012-04-10T09:00:00.813", "Score": "0", "LastEditorUserId": "675100", "LastEditDate": "2016-11-21T14:14:04.130", "Id": "10085794", "OwnerUserId": "862973", "Body": "<p>Try using an iterator for both. Try: </p>\n<pre><code>std::list&lt;std::string&gt;::iterator i = testList.end(); \n</code></pre>\n<p>and reverse through with --i</p>\n", "LastActivityDate": "2016-11-21T14:14:04.130"}, "10085570": {"CommentCount": "0", "AcceptedAnswerId": "10086036", "PostTypeId": "1", "LastEditorUserId": "129570", "CreationDate": "2012-04-10T08:42:49.503", "LastActivityDate": "2016-11-21T14:14:04.130", "LastEditDate": "2012-04-10T08:53:58.617", "ViewCount": "4586", "FavoriteCount": "4", "Title": "Why does a push_back on an std::list change a reverse iterator initialized with rbegin?", "Id": "10085570", "Score": "17", "Body": "<p>According to some STL documentation I found, inserting or deleting elements in an std::list does not invalidate iterators.  This means that it is allowed to loop over a list (from <code>begin()</code> to <code>end()</code>), and then add elements using push_front.</p>\n<p>E.g., in the following code, I initialize a list with elements a, b and c, then loop over it and perform a push_front of the elements.  The result should be cbaabc, which is exactly what I get:</p>\n<pre><code>std::list&lt;std::string&gt; testList;\ntestList.push_back(\"a\");\ntestList.push_back(\"b\");\ntestList.push_back(\"c\");\n\nfor (std::list&lt;std::string&gt;::iterator itList = testList.begin(); itList != testList.end(); ++itList)\n   testList.push_front(*itList);\n\nfor (std::list&lt;std::string&gt;::const_iterator itList = testList.begin(); itList != testList.end(); ++itList)\n   std::cout &lt;&lt; *itList &lt;&lt; std::endl;\n</code></pre>\n<p>When I use reverse iterators (loop from <code>rbegin()</code> to <code>rend()</code>) and use push_back, I would expect similar behavior, i.e. a result of abccba.  However, I get a different result:</p>\n<pre><code>std::list&lt;std::string&gt; testList;\ntestList.push_back(\"a\");\ntestList.push_back(\"b\");\ntestList.push_back(\"c\");\n\nfor (std::list&lt;std::string&gt;::reverse_iterator itList = testList.rbegin(); itList != testList.rend(); ++itList)\n   testList.push_back(*itList);\n\nfor (std::list&lt;std::string&gt;::const_iterator itList = testList.begin(); itList != testList.end(); ++itList)\n   std::cout &lt;&lt; *itList &lt;&lt; std::endl;\n</code></pre>\n<p>The result is not <code>abccba</code>, but <code>abcccba</code>.  That's right there is one additional c added.</p>\n<p>It looks like the first push_back also changes the value of the iterator that was initialized with rbegin().  After the push_back it does not point anymore to the 3rd element in the list (which was previously the last one), but to the 4th element (which is now the last one).</p>\n<p>I tested this with both Visual Studio 2010 and with GCC and both return the same result.</p>\n<p>Is this an error?  Or some strange behavior of reverse iterators that I'm not aware of?</p>\n", "Tags": "<c++><stl><iterator>", "OwnerUserId": "163551", "AnswerCount": "3"}, "10086296": {"ParentId": "10085570", "CommentCount": "2", "Body": "<p>I think to understand this, it's best to start by re-casting the <code>for</code> loop as a <code>while</code> loop:</p>\n<pre><code>typedef std::list&lt;std::string&gt; container;\n\ncontainer testList;\ntestList.push_back(\"a\");\ntestList.push_back(\"b\");\ntestList.push_back(\"c\");\n\ncontainer::reverse_iterator itList = testList.rbegin(); \nwhile (itList != testList.rend()) {\n    testList.push_back(*itList);\n     ++itList;\n}\n</code></pre>\n<p>Along with that, we have to understand how a <code>reverse_iterator</code> works in general. Specifically a <code>reverse_iterator</code> really points to the element <em>after</em> the one you get when you dereference it. <code>end()</code> yields an iterator to just <em>after</em> the end of the container -- but for things like arrays, there's no defined way to point to just before the beginning of a container. What C++ does instead is have the iterator start from just after the end, and progress to the beginning, but when you dereference it, you get the element just <em>before</em> where it actually points.</p>\n<p>That means your code actually works like this:</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/tvLaD.png\"/></p>\n<p>After that, you get pretty much what you expect, pushing back B and then A, so you end up with ABCCCBA.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "10086296", "Score": "7", "CreationDate": "2012-04-10T09:37:07.053", "LastActivityDate": "2012-04-10T09:37:07.053"}, "10086036": {"ParentId": "10085570", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2012-04-10T09:16:57.310", "Score": "15", "LastEditorUserId": "597607", "LastEditDate": "2012-04-10T09:33:39.967", "Id": "10086036", "OwnerUserId": "597607", "Body": "<p>The standard says that iterators and references remain valid during an insert. It doesn't say anything about reverse iterators.  :-)</p>\n<p>The <code>reverse_iterator</code> returned by <code>rbegin()</code> internally holds the value of <code>end()</code>. After a <code>push_back()</code> this value will obviously not be the same as it was before. I don't think the standard says what it should be. Obvious alternatives include the previous last element of the list, or that it stays at the end if that is a fixed value (like a sentinel node).</p>\n<hr>\n<p>Technical details: The value returned by <code>rend()</code> cannot point before <code>begin()</code>, because that is not valid. So it was decided that <code>rend()</code> should contain the value of <code>begin()</code> and all other reverse iterators be shifted one position further. The <code>operator*</code> compensates for this and accesses the correct element anyway.</p>\n<p>First paragraph of 24.5.1 Reverse iterators says:</p>\n<blockquote>\n<p id=\"so_10085570_10086036_0\">Class template <code>reverse_iterator</code> is an iterator adaptor that iterates from the end of the sequence defined\n  by its underlying iterator to the beginning of that sequence. The fundamental relation between a reverse\n  iterator and its corresponding iterator i is established by the identity:<br>\n<code>&amp;*(reverse_iterator(i)) == &amp;*(i - 1)</code>.</br></p>\n</blockquote>\n</hr>", "LastActivityDate": "2012-04-10T09:33:39.967"}, "bq_ids": {"n4140": {"so_10085570_10086036_0": {"section_id": 5600, "quality": 0.9230769230769231, "length": 24}}, "n3337": {"so_10085570_10086036_0": {"section_id": 5383, "quality": 0.9230769230769231, "length": 24}}, "n4659": {"so_10085570_10086036_0": {"section_id": 7044, "quality": 0.9230769230769231, "length": 24}}}});