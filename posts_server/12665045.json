post_cb({"bq_ids": {"n4140": {"so_12665045_12665065_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 6142}, "so_12665045_12665045_0": {"length": 50, "quality": 0.8064516129032258, "section_id": 6142}}, "n3337": {"so_12665045_12665065_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 5906}, "so_12665045_12665045_0": {"length": 50, "quality": 0.8064516129032258, "section_id": 5906}}, "n4659": {"so_12665045_12665065_0": {"length": 11, "quality": 0.5238095238095238, "section_id": 7638}}}, "12665065": {"Id": "12665065", "PostTypeId": "2", "Body": "<p>Neither 6 nor 7 are valid, because they do not perform pointer arithmetic inside an existing array (including the one-past-the-end pointer). Everything else is essentially correct.</p>\n<p>In C only: Given that <code>a[i]</code> is identical to <code>*(a + i)</code>, and <code>&amp;*p</code> is always just <code>p</code> without evaluating <code>*p</code>, 5 should always be fine, although you're right that C89 does not specify this and this was only added in C99. (This is not true at all in C++, where operators can be overloaded and there is no mention of combining <code>&amp;</code> and <code>*</code>.)</p>\n<p>From n1570 (draft to C11), in paragraph 8 of 6.5.6 Additive operators:</p>\n<blockquote>\n<p id=\"so_12665045_12665065_0\">[...] If both the pointer operand and the result [of <code>P + N</code>] point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined. [...]</p>\n</blockquote>\n<p>C++ contains very similar wording (e.g. C++11, 5.7/5).</p>\n", "LastEditorUserId": "596781", "LastActivityDate": "2012-09-30T21:17:54.033", "Score": "4", "CreationDate": "2012-09-30T20:57:39.823", "ParentId": "12665045", "CommentCount": "8", "OwnerUserId": "596781", "LastEditDate": "2012-09-30T21:17:54.033"}, "12665045": {"ViewCount": "998", "Body": "<p>I was asking myself if these line of code could produce undefined behaviour in C and in C++.\nI tried to answer to each point reading what the standard says about array subscripting (C 6.5.6 - 8). I didn't posted the entire paragraph because it is pretty long.</p>\n<blockquote>\n<p id=\"so_12665045_12665045_0\">Moreover, if the expression <code>P</code> points to the last\n  element of an array object, the expression <code>(P)+1</code> points one past the last element of the\n  array object, and if the expression <code>Q</code> points one past the last element of an array object,\n  the expression <code>(Q)-1</code> points to the last element of the array object. If both the pointer\n  operand and the result point to elements of the same array object, or one past the last\n  element of the array object, the evaluation shall not produce an overflow; otherwise, the\n  behavior is undefined. If the result points one past the last element of the array &gt;object, it\n  shall not be used as the operand of a unary <code>*</code> operator that is evaluated.</p>\n</blockquote>\n<pre><code>   1  int a[10];\n   2  int b = a[9]; // ok\n   3  int c = a[10]; // UB\n   4  int* d = (a + 10); // ok\n   5  int* e = &amp;a[10]; // ok from C99 (&amp; and [] are ignored, pointer is not deferenced), // UB in pre C99\n   6  int* f = &amp;a[11]; // ok from C99, UB in pre c99 \n      int* g = a;\n   7  int* h = g + 15; // ok\n</code></pre>\n<p>I think that the same aswers should be valid for C++</p>\n<p>Are these lines valid in C and in C++, have I misunderstood the standard?</p>\n", "AcceptedAnswerId": "12665065", "Title": "Array-pointer arithmetic - legal and undefined behaviour", "CreationDate": "2012-09-30T20:54:49.720", "LastActivityDate": "2012-09-30T21:59:50.750", "CommentCount": "6", "LastEditDate": "2012-09-30T21:59:50.750", "PostTypeId": "1", "Tags": "<c++><c><arrays><pointers><undefined-behavior>", "Id": "12665045", "AnswerCount": "1", "Score": "3", "OwnerUserId": "595897", "ClosedDate": "2012-09-30T22:43:43.693", "LastEditorUserId": "827263"}});