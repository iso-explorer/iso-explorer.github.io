post_cb({"bq_ids": {"n4140": {"so_13861161_13861611_7": {"section_id": 5851, "quality": 1.0, "length": 8}, "so_13861161_13861611_2": {"section_id": 5851, "quality": 1.0, "length": 10}, "so_13861161_13861611_3": {"section_id": 369, "quality": 0.7142857142857143, "length": 5}, "so_13861161_13861611_4": {"section_id": 5851, "quality": 1.0, "length": 8}, "so_13861161_13861244_0": {"section_id": 6077, "quality": 0.9180327868852459, "length": 56}, "so_13861161_13861611_6": {"section_id": 5851, "quality": 1.0, "length": 19}, "so_13861161_13862236_1": {"section_id": 5851, "quality": 0.9322033898305084, "length": 55}, "so_13861161_13862236_0": {"section_id": 5876, "quality": 0.875, "length": 21}}, "n3337": {"so_13861161_13861611_7": {"section_id": 5621, "quality": 1.0, "length": 8}, "so_13861161_13861611_2": {"section_id": 5621, "quality": 1.0, "length": 10}, "so_13861161_13861611_3": {"section_id": 359, "quality": 0.7142857142857143, "length": 5}, "so_13861161_13861611_4": {"section_id": 5621, "quality": 1.0, "length": 8}, "so_13861161_13861244_0": {"section_id": 5845, "quality": 0.9180327868852459, "length": 56}, "so_13861161_13861611_6": {"section_id": 5621, "quality": 1.0, "length": 19}, "so_13861161_13862236_1": {"section_id": 5621, "quality": 0.9322033898305084, "length": 55}, "so_13861161_13862236_0": {"section_id": 5647, "quality": 0.9166666666666666, "length": 22}}, "n4659": {"so_13861161_13861611_7": {"section_id": 7330, "quality": 1.0, "length": 8}, "so_13861161_13861611_2": {"section_id": 7330, "quality": 1.0, "length": 10}, "so_13861161_13861611_3": {"section_id": 383, "quality": 0.7142857142857143, "length": 5}, "so_13861161_13861611_4": {"section_id": 7330, "quality": 1.0, "length": 8}, "so_13861161_13861244_0": {"section_id": 7573, "quality": 0.9180327868852459, "length": 56}, "so_13861161_13861611_6": {"section_id": 7330, "quality": 0.7894736842105263, "length": 15}, "so_13861161_13862236_1": {"section_id": 7330, "quality": 0.6949152542372882, "length": 41}, "so_13861161_13862236_0": {"section_id": 7361, "quality": 0.75, "length": 18}}}, "13861611": {"ParentId": "13861161", "CommentCount": "1", "Body": "<p>Yes, if you <strong>only</strong> add constructors and/or non-virtual methods you will not change the size or the layout of the class, because the original class and the new class will be layout compatible (9.2 Class members [class.mem] #17), but <strong>only if they are standard-layout classes</strong>.</p>\n<p>The standard-layout classes are defines as:</p>\n<blockquote>\n<p id=\"so_13861161_13861611_0\"><strong>9 Classes [class]</strong></p>\n<p id=\"so_13861161_13861611_1\">A <em>standard-layout class</em> is a class that:</p>\n<p id=\"so_13861161_13861611_2\">\u2014 has no non-static data members of type non-standard-layout class (or\n  array of such types) or reference,</p>\n<p id=\"so_13861161_13861611_3\">\u2014 has no virtual functions (10.3) and no virtual base classes (10.1),</p>\n<p id=\"so_13861161_13861611_4\">\u2014 has the same access control (Clause 11) for all non-static data\n  members,</p>\n<p id=\"so_13861161_13861611_5\">\u2014 has no non-standard-layout base classes,</p>\n<p id=\"so_13861161_13861611_6\">\u2014 either has no non-static data members in the most derived class and\n  at most one base class with non-static data members, or has no base\n  classes with non-static data members, and</p>\n<p id=\"so_13861161_13861611_7\">\u2014 has no base classes of the same type as the first non-static data\n  member.</p>\n</blockquote>\n", "OwnerUserId": "390807", "PostTypeId": "2", "Id": "13861611", "Score": "7", "CreationDate": "2012-12-13T14:10:26.540", "LastActivityDate": "2012-12-13T14:10:26.540"}, "13861600": {"ParentId": "13861161", "CommentCount": "0", "Body": "<p>In C++03 and before, no.  There are absolutely no guarantees with regards to layout.  In C++11, there is the notion of layout compatible, but I'm not sure how far it goes; I would <em>hope</em> that adding a non-virtual function to the class would not break layout compatibility.  On the other hand, you mention embedded programming and turning off RTTI; you're probably counting on a lot of other things that are guaranteed by your compiler, and not the standard.  (The ability to turn off RTTI, for example.)  Given that, I would recommend looking for a guarantee by the compiler.  I suspect that most compilers targetting embedded systems provide detailed descriptions of the layout they generate, and you can go from there.</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "13861600", "Score": "5", "CreationDate": "2012-12-13T14:10:01.893", "LastActivityDate": "2012-12-13T14:10:01.893"}, "13862236": {"ParentId": "13861161", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You might derive this guarantee from the <em>Working Draft C++, n3242, 2011-02-28</em></p>\n<blockquote>\n<p id=\"so_13861161_13862236_0\"><strong>9.2 class members</strong><br>\n<strong>18</strong>\n  Two standard-layout struct (Clause 9) types are layout-compatible if they have the same number of non-static\n  data members and corresponding non-static data members (in declaration order) have layout-compatible\n  types (3.9).</br></p>\n</blockquote>\n<p>This talks about <em>data members</em> only, so two classes</p>\n<pre><code>struct A {\nint d1;\nfloat d2;\nvoid f();\n};\n\nstruct B {\nint e1;\nfloat e2;\nint g() const;\ndouble h();\n};\n</code></pre>\n<p>should be layout compatible.</p>\n<p>And for what's a standard layout class</p>\n<blockquote>\n<p id=\"so_13861161_13862236_1\"><strong>9 Classes</strong><br>\n<strong>7</strong>\n  A standard-layout class is a class that:<br>\n  \u2014 has no non-static data members of type non-standard-layout class (or array of such types) or reference,<br>\n  \u2014 has no virtual functions (10.3) and no virtual base classes (10.1),<br>\n  \u2014 has the same access control (Clause 11) for all non-static data members,<br>\n  \u2014 has no non-standard-layout base classes,<br>\n  \u2014 either has no non-static data members in the most derived class and at most one base class with\n  non-static data members, or has no base classes with non-static data members, and<br>\n  \u2014 has no base classes of the same type as the first non-static data member.108</br></br></br></br></br></br></br></p>\n</blockquote>\n", "OwnerUserId": "1741542", "LastEditorUserId": "1741542", "LastEditDate": "2012-12-13T16:30:16.267", "Id": "13862236", "Score": "1", "CreationDate": "2012-12-13T14:44:46.447", "LastActivityDate": "2012-12-13T16:30:16.267"}, "13861244": {"ParentId": "13861161", "PostTypeId": "2", "CommentCount": "5", "Body": "<p><strong>No, not really.</strong></p>\n<p>C++11 has this to say about <code>sizeof</code>:</p>\n<blockquote>\n<p id=\"so_13861161_13861244_0\"><code>[C++11: 5.3.5/2]:</code> [..] When applied to a reference or a reference type, the result is the size of the referenced type. <strong>When applied to a class, the result is the number of bytes in an object of that class including any padding required for placing objects of that type in an array.</strong> The size of a most derived class shall be greater than zero (1.8). The result of applying <code>sizeof</code> to a base class subobject is the size of the base class type. When applied to an array, the result is the total number of bytes in the array. This implies that the size of an array of <em>n</em> elements is <em>n</em> times the size of an element.</p>\n</blockquote>\n<p>... and that's about it. It doesn't specify what \"required for placing objects of that type in an array\" means, instead leaving that up to the target ABI.</p>\n<p>The Itanium ABI, which has recently vanished from <a href=\"http://sourcery.mentor.com/public/cxx-abi/abi.html\" rel=\"nofollow\">its previous home</a> (grr) does make the sort of guarantees that you're looking for, if I recall correctly, but that is not the same as a C++ guarantee. Not the same at all.</p>\n<p>You can use compiler-specific packing/alignment options to handle data members. But space increase due to virtual functions is beyond your control. You wouldn't expect any space to be added for non-virtual functions but this is not \"guaranteed\" either.</p>\n<p>You can <code>static_assert(sizeof T == x, \"T needs to be x bytes wide\")</code> to detect whenever you broke some assumption with a code change. This is the best you're gonna get.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2012-12-13T14:05:23.673", "Id": "13861244", "Score": "7", "CreationDate": "2012-12-13T13:50:10.100", "LastActivityDate": "2012-12-13T14:05:23.673"}, "13861161": {"CommentCount": "2", "AcceptedAnswerId": "13861611", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2012-12-13T13:45:28.547", "LastActivityDate": "2012-12-13T20:57:40.863", "LastEditDate": "2012-12-13T13:57:20.180", "ViewCount": "294", "FavoriteCount": "1", "Title": "Does the C++ standard make any guarantee for the size of class types with no virtual member functions?", "Id": "13861161", "Score": "7", "Body": "<p>I use C++ for embedded programming.</p>\n<p>Supposing I have to implement a strictly-defined (i.e. byte-by-byte) class type, can I add a constructor and some other non-virtual methods to it without objects of that type changing at the byte level? That is, can I assume that no additional data will be added to it?</p>\n<p>I assume that RTTI is turned off.</p>\n<p>I would like to be sure wheteher C++ standard defines this.</p>\n", "Tags": "<c++>", "OwnerUserId": "727238", "AnswerCount": "4"}});