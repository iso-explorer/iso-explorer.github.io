post_cb({"3892955": {"Id": "3892955", "PostTypeId": "2", "Body": "<p>assuming the types <code>sint8_t</code> and <code>uint8_t</code> are assignment compatible, this works</p>\n<pre><code>sint8_t DESER_SINT8(uint8_t x) { return x; }\n</code></pre>\n", "LastActivityDate": "2010-10-08T17:41:24.077", "CommentCount": "2", "CreationDate": "2010-10-08T17:41:24.077", "ParentId": "3892924", "Score": "0", "OwnerUserId": "25324"}, "3893697": {"Id": "3893697", "PostTypeId": "2", "Body": "<p>Assuming that you <code>sint8_t</code> is really <code>int8_t</code> from <code>&lt;stdint.h&gt;</code>, then it's guaranteed two's complement form, and it's guaranteed that there are no padding bits.</p>\n<p>Assuming further that you want the opposite (implicit) conversion to work and yield the original value.</p>\n<p>Then, given a value <code>v</code> of type <code>uint8_t</code>, all you have to do is ...</p>\n<pre><code>    int8_t( v )\n</code></pre>\n<p>That's it.</p>\n<p>The C standard does AFAIK not guarantee this conversion, only the opposite conversion. However, there is no known system or compiler where it won't work (given that you have these types available).</p>\n<p>Forget all the manual bit-fiddling. Or, to test whether you're doing it right, convert back by just assigning the value to an <code>uint8_t</code> and check whether you get the original value for all cases. In particular, the formula you used yields -((2^n-1)-x) = 1+x-2^n, while the correct conversion for value preservation is x-2^n.</p>\n<p>Cheers &amp; hth.,</p>\n<p>\u2013 Alf</p>\n", "LastActivityDate": "2010-10-08T19:26:53.360", "CommentCount": "8", "CreationDate": "2010-10-08T19:26:53.360", "ParentId": "3892924", "Score": "-1", "OwnerUserId": "464581"}, "3895544": {"Id": "3895544", "PostTypeId": "2", "Body": "<p>I don't know if this has any practical value, but here's a different approach that came to mind:</p>\n<pre><code>uint8_t input;\nint8_t output;\n*(uint8_t *)&amp;output = input;\n</code></pre>\n<p>Note that:</p>\n<ul>\n<li><code>int8_t</code> is required to be twos complement.</li>\n<li>Corresponding signed and unsigned types are required to have the same representation for the overlapping part of their ranges, so that a value that's in the range of both the signed and unsigned type can be accessed through either type of pointer.</li>\n<li>That leaves only one bit, which must be the twos complement sign bit.</li>\n</ul>\n<p>The only way I can see that this reasoning <em>might</em> fail to be valid is if <code>CHAR_BIT&gt;8</code> and the 8-bit integer types are extended integer types with trap bits that somehow flag whether the value is signed or unsigned. However, the following analogous code using <code>char</code> types explicitly could never fail:</p>\n<pre><code>unsigned char input;\nsigned char output;\n*(unsigned char *)output = input;\n</code></pre>\n<p>because <code>char</code> types cannot have padding/trap bits.</p>\n<p>A potential variant would be:</p>\n<pre><code>return ((union { uint8_t u; int8_t s; }){ input }).s;\n</code></pre>\n<p>or for <code>char</code> types:</p>\n<pre><code>return ((union { unsigned char u; signed char s; }){ input }).s;\n</code></pre>\n<p><strong>Edit:</strong> As Steve Jessop pointed out in another answer, <code>int8_t</code> and <code>uint8_t</code> are required not to have padding bits if they exist, so their existence implies <code>CHAR_BIT==8</code>. So I'm confident that this approach is valid. With that said, I would still never use <code>uint8_t</code> and always explicitly use <code>unsigned char</code>, in case the implementation implements <code>uint8_t</code> as an equal-size extended integer type, because <code>char</code> types have special privileges with respect to aliasing rules and type punning which make them more desirable.</p>\n", "LastEditorUserId": "379897", "LastActivityDate": "2010-10-09T03:12:26.480", "Score": "2", "CreationDate": "2010-10-09T03:05:56.097", "ParentId": "3892924", "CommentCount": "2", "LastEditDate": "2010-10-09T03:12:26.480", "OwnerUserId": "379897"}, "bq_ids": {"n4140": {"so_3892924_3892965_0": {"length": 9, "quality": 0.5294117647058824, "section_id": 6035}}, "n3337": {"so_3892924_3892965_0": {"length": 9, "quality": 0.5294117647058824, "section_id": 5930}}, "n4659": {"so_3892924_3892965_0": {"length": 9, "quality": 0.5294117647058824, "section_id": 7534}}}, "3892965": {"Id": "3892965", "PostTypeId": "2", "Body": "<p><code>1u &lt;&lt; 8u</code> is <code>0x100u</code>, which is larger than every <code>uint8_t</code> value, so the conditional is never satisfied.  Your \"conversion\" routine is actually just:</p>\n<pre><code>return x;\n</code></pre>\n<p>which actually makes some sense.</p>\n<p>You need to define more clearly what you want for conversion.  C99 defines conversion from unsigned to signed integer types as follows (<strong>\u00a76.3.1.3 \"Signed and unsigned integers\"</strong>)</p>\n<blockquote>\n<p id=\"so_3892924_3892965_0\">When a value with integer type is\n  converted to another integer type\n  other than <code>_Bool</code>, if the value can be\n  represented by the new type, it is\n  unchanged.</p>\n<p id=\"so_3892924_3892965_1\">\u2026</p>\n<p id=\"so_3892924_3892965_2\">Otherwise, the new type is signed and\n  the value cannot be represented in it;\n  either the result is\n  implementation-defined or an\n  implementation-defined signal is\n  raised.</p>\n</blockquote>\n<p>Thus, <code>uint8_t</code> values between <code>0</code> and <code>127</code> are preserved, and the behavior for values larger than <code>127</code> is undefined.  <em>Many</em> (but not all) implementations will simply interpret the unsigned values as a twos-complement representation of a signed integer.  Perhaps what you're really asking is how to guarantee this behavior across platforms?</p>\n<p>If so, you can use:</p>\n<pre><code>return x &lt; 128 ? x : x - 256;\n</code></pre>\n<p>The value <code>x - 256</code> is an <code>int</code>, guaranteed to have the value of <code>x</code> interpreted as a twos-complement 8 bit integer.  The implicit conversion to <code>int8_t</code> then preserves this value.</p>\n<p>This all assumes that <code>sint8_t</code> is meant to be <code>int8_t</code>, as <code>sint8_t</code> isn't a standard type.  If it isn't, then all bets are off, because the correctness of the conversion I suggested depends on the guarantee that <code>int8_t</code> have a twos-complement representation (<strong>\u00a77.18.1.1 \"Exact-width integer types\"</strong>).</p>\n<p>If <code>sint8_t</code> is instead some wacky platform-specific type, it might use some other representation like ones-complement, which has a different set of representable values, thus rendering the conversion described above implementation-defined (hence non-portable) for certain inputs.</p>\n<hr>\n<p><strong>EDIT</strong></p>\n<p>Alf has argued that this is \"silly\", and that this will never be necessary on any production system.  I disagree, but it is admittedly a corner case of a corner case.  His argument is not entirely without merit.</p>\n<p>His claim that this is \"inefficient\" and should therefore be avoided, however, is baseless.  A reasonable optimizing compiler will optimize this away on platforms where it is unnecessary.  Using GCC on x86_64 for example:</p>\n<pre><code>#include &lt;stdint.h&gt;\n\nint8_t alf(uint8_t x) {\n    return x;\n}\n\nint8_t steve(uint8_t x) {\n    return x &lt; 128 ? x : x - 256;\n}\n\nint8_t david(uint8_t x) {\n    return (x ^ 0x80) - 0x80;\n}\n</code></pre>\n<p>compiled with -Os -fomit-frame-pointer yields the following:</p>\n<pre><code>_alf:\n0000000000000000    movsbl  %dil,%eax\n0000000000000004    ret\n_steve:\n0000000000000005    movsbl  %dil,%eax\n0000000000000009    ret\n_david:\n000000000000000a    movsbl  %dil,%eax\n000000000000000e    ret\n</code></pre>\n<p>Note that all three implementations are <em>identical</em> after optimization.  Clang/LLVM gives exactly the same result.  Similarly, if we build for ARM instead of x86:</p>\n<pre><code>_alf:\n00000000        b240    sxtb    r0, r0\n00000002        4770    bx  lr\n_steve:\n00000004        b240    sxtb    r0, r0\n00000006        4770    bx  lr\n_david:\n00000008        b240    sxtb    r0, r0\n0000000a        4770    bx  lr\n</code></pre>\n<p>Protecting your implementation against corner cases when it has no cost for the \"usual\" case is never \"silly\".</p>\n<p>To the argument that this adds needless complexity, I say: which is harder -- writing a comment to explain the conversion and why it is there, or your successor's intern trying to debug the problem 10 years from now when a new compiler breaks the lucky happenstance that you've been silently depending on all this time?  Is the following really so hard to maintain?</p>\n<pre><code>// The C99 standard does not guarantee the behavior of conversion\n// from uint8_t to int8_t when the value to be converted is larger\n// than 127.  This function implements a conversion that is\n// guaranteed to wrap as though the unsigned value were simply\n// reinterpreted as a twos-complement value.  With most compilers\n// on most systems, it will be optimized away entirely.\nint8_t safeConvert(uint8_t x) {\n    return x &lt; 128 ? x : x - 256;\n}\n</code></pre>\n<p>When all is said and done, I agree that this is vaguely over the top, but I also think we should try to answer the question at face value.  A better solution, of course, would be for the C standard to pin down the behavior of conversions from unsigned to signed when the signed type is a twos-complement integer without padding (thus specifying the behavior for all of the <code>intN_t</code> types).</p>\n</hr>", "LastEditorUserId": "142434", "LastActivityDate": "2010-10-09T00:14:13.577", "Score": "12", "CreationDate": "2010-10-08T17:42:55.037", "ParentId": "3892924", "CommentCount": "18", "LastEditDate": "2010-10-09T00:14:13.577", "OwnerUserId": "142434"}, "3892924": {"ViewCount": "3121", "Body": "<p>What's the best way to convert an \"uint8_t\" to an \"sint8_t\" in portable C.</p>\n<p>That's the code I came up with ....</p>\n<pre><code>#include &lt;stdint.h&gt;\n\nsint8_t DESER_SINT8(uint8_t x)\n(\n  return\n     (sint8_t)((x &gt;= (1u &lt;&lt; 8u))\n               ? -(UINT8_MAX - x)\n               : x);\n)\n</code></pre>\n<p>Is there a better/simpler way to do it? Maybe a way without using a conditional?</p>\n<p>Edit: Thanks guys. So to sum up, what I learned already ...</p>\n<ul>\n<li><code>sint8_t</code> is really called <code>int8_t</code></li>\n<li><code>128</code> is expressed by <code>1 &lt;&lt; 7</code> and not by <code>1 &lt;&lt; 8</code></li>\n<li>2s complement is \"negating off by one\"</li>\n</ul>\n<p>:)</p>\n<p>So here is an updated version of my original code:</p>\n<pre><code>#include &lt;stdint.h&gt;\n\nint8_t DESER_INT8(uint8_t x)\n(\n  return ((x &gt;= (1 &lt;&lt; 7))\n          ? -(UINT8_MAX - x + 1)\n          : x);\n)\n</code></pre>\n", "Title": "conversion of uint8_t to sint8_t", "CreationDate": "2010-10-08T17:35:34.897", "LastActivityDate": "2010-10-09T03:12:26.480", "CommentCount": "13", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2010-10-08T20:34:52.997", "LastEditorUserId": "470474", "Id": "3892924", "Score": "4", "OwnerUserId": "470474", "Tags": "<c++><c><serialization>", "AnswerCount": "7"}, "3895084": {"Id": "3895084", "PostTypeId": "2", "Body": "<p>If you want to avoid the branch you can always do something insane like this:</p>\n<pre><code>int selector= 127 - x; // 0 or positive if x &lt;=127, negative otherwise\nint selector&gt;&gt;= 8; // arithmetic rotate to get -1 or 0\nint wrapped_value= x - 256;\n\nreturn (x&amp;~selector)|(wrapped_value&amp;selector); // if selector is 0, use x, otherwise, use the wrapped value.\n</code></pre>\n", "LastActivityDate": "2010-10-09T00:04:53.313", "CommentCount": "1", "CreationDate": "2010-10-09T00:04:53.313", "ParentId": "3892924", "Score": "0", "OwnerUserId": "6210"}, "3893174": {"Id": "3893174", "PostTypeId": "2", "Body": "<p>Uhm,... I think you were trying to return x, if x could be represented in sint8, or abs(SINT8_MAX - x) if not, right?</p>\n<p>In that case, here's one that works (yours had a tiny error I think):</p>\n<pre><code>#define HIGHBIT(X) ((X) &amp; (1 &lt;&lt; (sizeof(X) * 8 - 1)))\n\nchar utos8(unsigned char ux)\n{\n    return HIGHBIT(ux) ? -ux : ux;\n}\n</code></pre>\n<p>Note that using that code, you can <strong>convert from any unsigned to signed type</strong> wrapping the HIGHTBIT macro in a function.</p>\n<p>Hope that helps.</p>\n", "LastActivityDate": "2010-10-08T18:13:35.447", "CommentCount": "7", "CreationDate": "2010-10-08T18:13:35.447", "ParentId": "3892924", "Score": "0", "OwnerUserId": "469300"}, "3893558": {"Id": "3893558", "PostTypeId": "2", "Body": "<p>Conversion of <code>uint8_t</code> to <code>int8_t</code> essentially reverses the order of the two half-ranges. \"High\" numbers become \"low.\" This can be accomplished with XOR.</p>\n<pre><code>x ^ 0x80\n</code></pre>\n<p>However, all the numbers are still positive. That's no good. We need to introduce the proper sign and restore the proper magnitude.</p>\n<pre><code>return ( x ^ 0x80 ) - 0x80;\n</code></pre>\n<p>There you go!</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2010-10-08T21:29:35.717", "Score": "5", "CreationDate": "2010-10-08T19:08:09.453", "ParentId": "3892924", "CommentCount": "11", "LastEditDate": "2010-10-08T21:29:35.717", "OwnerUserId": "153285"}});