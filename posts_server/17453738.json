post_cb({"17453738": {"CommentCount": "0", "ViewCount": "4480", "CreationDate": "2013-07-03T16:47:30.053", "LastActivityDate": "2015-02-17T08:32:55.863", "Title": "g++ gives error : invalid initialization of reference of type \u2018char&\u2019 from expression of type \u2018unsigned char\u2019", "AcceptedAnswerId": "17453787", "PostTypeId": "1", "Id": "17453738", "Score": "4", "Body": "<p>when I try to compile the following code</p>\n<pre><code>int main()\n{\n    unsigned char uc;\n    char &amp; rc = uc;\n}\n</code></pre>\n<p>g++ gives the following error : invalid initialization of reference of type \u2018char&amp;\u2019 from expression of type \u2018unsigned char\u2019. The same happens when using signed char instead of unsigned char.\nBut the following compiles well</p>\n<pre><code>int main()\n{\n    unsigned char uc;\n    const char &amp; rc = uc;\n}\n</code></pre>\n<p>Why isn't it possible to initialize 'char &amp;' with a variable of type 'unsigned char' while it is possible to initialize 'const char &amp;' with it?</p>\n", "Tags": "<c++><reference><initialization>", "OwnerUserId": "2543838", "AnswerCount": "3"}, "17453787": {"ParentId": "17453738", "CommentCount": "4", "Body": "<p><em>Why isn't it possible to initialize 'char &amp;' with a variable of type 'unsigned char' while it is possible to initialize 'const char &amp;' with it?</em></p>\n<p>Because the latter creates a temporary to bind to the const reference when the <code>unsigned char</code> is converted to a <code>char</code>, something you can't do with non-const references. <code>char</code>, <code>signed char</code>, and <code>unsigned char</code> are three distinct types, as explained in C++11 \u00a7 3.9.1:</p>\n<blockquote>\n<p id=\"so_17453738_17453787_0\">Plain char, signed char, and unsigned char are three distinct types</p>\n</blockquote>\n", "OwnerUserId": "962089", "PostTypeId": "2", "Id": "17453787", "Score": "5", "CreationDate": "2013-07-03T16:50:56.183", "LastActivityDate": "2013-07-03T16:50:56.183"}, "17454270": {"ParentId": "17453738", "CommentCount": "0", "Body": "<p>\"The C++ compiler treats variables of type char, signed char, and unsigned char as having different types.\"</p>\n<p>The following link will clarify: <a href=\"http://msdn.microsoft.com/en-us/library/cc953fe1.aspx\" rel=\"nofollow\">http://msdn.microsoft.com/en-us/library/cc953fe1.aspx</a></p>\n<p>change the following:</p>\n<pre><code>int main()\n{\n    unsigned char uc;\n    unsigned char&amp; rc = uc;\n}\n</code></pre>\n", "OwnerUserId": "1472273", "PostTypeId": "2", "Id": "17454270", "Score": "0", "CreationDate": "2013-07-03T17:14:12.950", "LastActivityDate": "2013-07-03T17:14:12.950"}, "bq_ids": {"n4140": {"so_17453738_28557688_2": {"section_id": 3321, "quality": 0.5555555555555556, "length": 5}, "so_17453738_28557688_3": {"section_id": 603, "quality": 0.7142857142857143, "length": 5}, "so_17453738_17453787_0": {"section_id": 7210, "quality": 1.0, "length": 9}, "so_17453738_28557688_4": {"section_id": 5, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_17453738_28557688_3": {"section_id": 593, "quality": 0.7142857142857143, "length": 5}, "so_17453738_28557688_4": {"section_id": 6974, "quality": 0.5714285714285714, "length": 4}, "so_17453738_17453787_0": {"section_id": 6954, "quality": 1.0, "length": 9}, "so_17453738_28557688_2": {"section_id": 3191, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_17453738_28557688_3": {"section_id": 629, "quality": 0.7142857142857143, "length": 5}, "so_17453738_28557688_4": {"section_id": 5, "quality": 0.5714285714285714, "length": 4}, "so_17453738_17453787_0": {"section_id": 8719, "quality": 1.0, "length": 9}, "so_17453738_28557688_2": {"section_id": 4087, "quality": 0.5555555555555556, "length": 5}}}, "28557688": {"ParentId": "17453738", "CommentCount": "0", "Body": "<p>I have faced to this error today, and just would like to share what I have found.</p>\n<p>Bjarne Stroustrup in his book \"The C++ Programming Language\" Third Edition wrote:</p>\n<blockquote>\n<p id=\"so_17453738_28557688_0\">\u00a7 5.5 References</p>\n<p id=\"so_17453738_28557688_1\">Initialization of a reference is trivial when the initializer is an\n  lvalue (an object whose address you can take; see \u00a74.9.6). The\n  initializer for a \u2018\u2018plain\u2019\u2019 <strong>T&amp;</strong> must be an lvalue of type <strong>T</strong>.</p>\n<p id=\"so_17453738_28557688_2\">The initializer for a const T&amp; need not be an lvalue or even of type T\n  In such cases,</p>\n<p id=\"so_17453738_28557688_3\">[1] first, implicit type conversion to T is applied if necessary (see\n  \u00a7C.6)</p>\n<p id=\"so_17453738_28557688_4\">[2] then, the resulting value is placed in a temporary variable of\n  type T and</p>\n<p id=\"so_17453738_28557688_5\">[3] finally, this temporary variable is used as the value of the\n  initializer.</p>\n</blockquote>\n", "OwnerUserId": "2799497", "PostTypeId": "2", "Id": "28557688", "Score": "0", "CreationDate": "2015-02-17T08:32:55.863", "LastActivityDate": "2015-02-17T08:32:55.863"}});