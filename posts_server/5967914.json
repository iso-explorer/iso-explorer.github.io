post_cb({"5967962": {"ParentId": "5967914", "CommentCount": "1", "Body": "<p>Yes, that is completely undefined behaviour. That's why when downcasting you should favour <code>dynamic_cast</code> unless you're very very sure.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "5967962", "Score": "1", "CreationDate": "2011-05-11T17:03:57.440", "LastActivityDate": "2011-05-11T17:03:57.440"}, "5968007": {"ParentId": "5967914", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Given the mental model I have of C++ implementation in terms of generated machine code I'd say that if the method called is not virtual and the derived class is not introducing virtual methods when the base class has none, and multiple inheritance is not involved in this trickery and and and ... it should work as you expect if the method code is indeed only accessing members defined in base object.</p>\n<p>However this is still clearly UB in C++.</p>\n", "OwnerUserId": "320726", "LastEditorUserId": "320726", "LastEditDate": "2011-05-11T19:23:08.903", "Id": "5968007", "Score": "0", "CreationDate": "2011-05-11T17:08:59.987", "LastActivityDate": "2011-05-11T19:23:08.903"}, "5967914": {"CommentCount": "0", "ViewCount": "271", "CreationDate": "2011-05-11T16:59:32.197", "LastActivityDate": "2011-05-11T19:23:08.903", "Title": "Downcasting a base type", "AcceptedAnswerId": "5967966", "PostTypeId": "1", "Id": "5967914", "Score": "4", "Body": "<p>In C++, is it Undefined Behavior if a Base class object is instantiated <em>as a base object</em>, and subsequently downcast to a derived object?  </p>\n<p>Of course, I would assume it definitely <em>must</em> be undefined behavior, because the Derived class object might have member variables which the base class doesn't.  So these variables wouldn't actually exist if the class was instantiated as a base object, which means that accessing them through a Derived class pointer would have to cause Undefined Behavior.</p>\n<p>But, what if the Derived class simply provides extra member functions, but doesn't include any further member data?  For example:</p>\n<pre><code>class Base\n{\n    public:\n    int x;\n};\n\nclass Derived : public Base\n{\n    public:\n    void foo();    \n};\n\nint main()\n{\n    Base b;\n    Derived* d = static_cast&lt;Derived*&gt;(&amp;b);\n    d-&gt;foo(); // &lt;--- Is this undefined behavior?\n}\n</code></pre>\n<p>Does this program cause undefined behavior?  </p>\n", "Tags": "<c++><inheritance>", "OwnerUserId": "469408", "AnswerCount": "4"}, "5967966": {"ParentId": "5967914", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, it's still undefined behavior, because you're lying to the compiler about the real type of <code>d</code>.</p>\n<p>See the standard 5.2.9/8:</p>\n<blockquote>\n<p id=\"so_5967914_5967966_0\">An rvalue of type \u201cpointer to cv1 B\u201d,\n  where B is a class type, can be\n  converted to an rvalue of type\n  \u201cpointer to cv2 D\u201d, where D is a class\n  derived (clause 10) from B, if a valid\n  standard conversion from \u201cpointer to\n  D\u201d to \u201cpointer to B\u201d exists (4.10),\n  cv2 is the same cvqualification as, or\n  greater cvqualification than, cv1, and\n  B is not a virtual base class of D.\n  The null pointer value (4.10) is\n  converted to the null pointer value of\n  the destination type. If the rvalue of\n  type \u201cpointer to cv1 B\u201d points to a B\n  that is actually a subobject of an\n  object of type D, the resulting\n  pointer points to the enclosing object\n  of type D. Otherwise, the result of\n  the cast is undefined.</p>\n</blockquote>\n<p>The final two sentences say that if the <code>B</code> pointed to by the pointer is not actually part of a <code>D</code> derived class, the cast is undefined behavior.</p>\n", "OwnerUserId": "251738", "LastEditorUserId": "251738", "LastEditDate": "2011-05-11T17:12:45.257", "Id": "5967966", "Score": "7", "CreationDate": "2011-05-11T17:04:43.980", "LastActivityDate": "2011-05-11T17:12:45.257"}, "5968004": {"ParentId": "5967914", "CommentCount": "0", "Body": "<p>The C++03 standard, par. 5.2.9.8 lays it out (emphasis mine):</p>\n<blockquote>\n<p id=\"so_5967914_5968004_0\">An rvalue of type \u201cpointer to cv1 B\u201d,\n  where B is a class type, can be\n  converted to an rvalue of type\n  \u201cpointer to cv2 D\u201d, where D is a class\n  derived (clause 10) from B, if a valid\n  standard conversion from \u201cpointer to\n  D\u201d to \u201cpointer to B\u201d exists (4.10),\n  cv2 is the same cv-qualification as,\n  or greater cv-qualification than, cv1,\n  and B is not a virtual base class of\n  D. The null pointer value (4.10) is\n  converted to the null pointer value of\n  the destination type. <strong>If the rvalue of\n  type \u201cpointer to cv1 B\u201d points to a B\n  that is actually a sub-object of an\n  object of type D, the resulting\n  pointer points to the enclosing object\n  of type D. Otherwise, the result of\n  the cast is undefined.</strong></p>\n</blockquote>\n", "OwnerUserId": "50079", "PostTypeId": "2", "Id": "5968004", "Score": "4", "CreationDate": "2011-05-11T17:08:24.467", "LastActivityDate": "2011-05-11T17:08:24.467"}, "bq_ids": {"n4140": {"so_5967914_5967966_0": {"section_id": 6037, "quality": 0.7777777777777778, "length": 49}, "so_5967914_5968004_0": {"section_id": 6037, "quality": 0.7777777777777778, "length": 49}}, "n3337": {"so_5967914_5967966_0": {"section_id": 5805, "quality": 0.8095238095238095, "length": 51}, "so_5967914_5968004_0": {"section_id": 5805, "quality": 0.8095238095238095, "length": 51}}, "n4659": {"so_5967914_5967966_0": {"section_id": 7536, "quality": 0.6984126984126984, "length": 44}, "so_5967914_5968004_0": {"section_id": 7536, "quality": 0.6984126984126984, "length": 44}}}});