post_cb({"22936638": {"ParentId": "22936579", "PostTypeId": "2", "CommentCount": "9", "Body": "<blockquote>\n<p id=\"so_22936579_22936638_0\">but why does pb-&gt;f() execute C's f() function when B's f() is not virtual.</p>\n</blockquote>\n<p>Because the dynamic type of <code>pb</code> is <code>C</code> and <code>C::f</code> is indeed virtual. When you declare </p>\n<pre><code>virtual void f();\n</code></pre>\n<p>in the base class, every other <code>void f()</code> of the derived classes in the hierarchy is also virtual, as per \u00a710.3/2:</p>\n<blockquote>\n<p id=\"so_22936579_22936638_1\">If a virtual member function vf is declared in a class Base and in a class Derived, derived <strong>directly or indirectly</strong> from Base, a member function vf with the same name, parameter-type-list (8.3.5), cv-qualification, and ref- qualifier (or absence of same) as Base::vf is declared, then Derived::vf is also virtual (whether or not it is so declared) and it overrides112 Base::vf.</p>\n</blockquote>\n<p>(emphasis mine)</p>\n<p>In fact:</p>\n<pre><code>class A {\npublic:\n    virtual void f() { cout &lt;&lt; \"0\" &lt;&lt; endl; }\n}; \n\nclass B : public A{\npublic:\n    virtual void f() { cout &lt;&lt; \"1\" &lt;&lt; endl; }\n};\n\nclass C : public B{\npublic:\n    virtual void f() { cout &lt;&lt; \"2\" &lt;&lt; endl; }\n};\n</code></pre>\n<p>is equivalent to your code. It just so happens that the C++ standard allows <code>virtual</code> to be omitted in those cases.</p>\n", "OwnerUserId": "493122", "LastEditorUserId": "493122", "LastEditDate": "2014-04-08T12:17:16.293", "Id": "22936638", "Score": "10", "CreationDate": "2014-04-08T12:12:10.997", "LastActivityDate": "2014-04-08T12:17:16.293"}, "22936579": {"CommentCount": "0", "ViewCount": "83", "CreationDate": "2014-04-08T12:09:02.087", "LastActivityDate": "2014-04-08T12:17:16.293", "Title": "Polymorphism with 3 classes in C++", "AcceptedAnswerId": "22936638", "PostTypeId": "1", "Id": "22936579", "Score": "3", "Body": "<p>The following code prints 1 2, but I would expect it to print 1 1.</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass A {\npublic:\n    virtual void f() { cout &lt;&lt; \"0\" &lt;&lt; endl; }\n}; \n\nclass B : public A{\npublic:\n    void f() { cout &lt;&lt; \"1\" &lt;&lt; endl; }\n};\n\nclass C : public B{\npublic:\n    void f() { cout &lt;&lt; \"2\" &lt;&lt; endl; }\n};\n\nint main() {\n    A *pa = new B();\n    B *pb = new C();\n    pa-&gt;f();\n    pb-&gt;f();\n}\n</code></pre>\n<p>In my understanding, pa-&gt;f() executes B's f() function since A's is virtual, but why does pb-&gt;f() execute C's f() function when B's f() is not virtual.</p>\n<p>Additionally, if I remove 'virtual' from class A, it prints 0 1, which makes sense because A and B execute their own f() functions since they aren't virtual. How come pb-&gt;f() changes if it isn't affected since it's only A that changes?</p>\n", "Tags": "<c++>", "OwnerUserId": "2673009", "AnswerCount": "2"}, "22936686": {"ParentId": "22936579", "CommentCount": "0", "Body": "<p>It happens because writing virtual keyword in subclasses is not necessary, it just improves readability.</p>\n", "OwnerUserId": "1304844", "PostTypeId": "2", "Id": "22936686", "Score": "2", "CreationDate": "2014-04-08T12:14:23.227", "LastActivityDate": "2014-04-08T12:14:23.227"}, "bq_ids": {"n4140": {"so_22936579_22936638_1": {"section_id": 7003, "quality": 0.8787878787878788, "length": 29}}, "n3337": {"so_22936579_22936638_1": {"section_id": 6749, "quality": 0.8787878787878788, "length": 29}}, "n4659": {"so_22936579_22936638_1": {"section_id": 8500, "quality": 0.8787878787878788, "length": 29}}}});