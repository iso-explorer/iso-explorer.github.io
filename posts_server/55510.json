post_cb({"55510": {"ViewCount": "43620", "Body": "<p>I'm quite confident that globally declared variables get allocated (and initialized, if applicable) at program start time.</p>\n<pre><code>int globalgarbage;\nunsigned int anumber = 42;\n</code></pre>\n<p>But what about static ones defined within a function?</p>\n<pre><code>void doSomething()\n{\n  static bool globalish = true;\n  // ...\n}\n</code></pre>\n<p>When is the space for <code>globalish</code> allocated? I'm guessing when the program starts. But does it get initialized then too? Or is it initialized when <code>doSomething()</code> is first called?</p>\n", "AcceptedAnswerId": "55548", "Title": "When do function-level static variables get allocated/initialized?", "CreationDate": "2008-09-10T23:49:09.107", "Id": "55510", "CommentCount": "0", "FavoriteCount": "25", "PostTypeId": "1", "OwnerDisplayName": "Owen", "LastActivityDate": "2016-06-14T18:55:50.613", "Score": "64", "OwnerUserId": "4790", "Tags": "<c++><c><variables>", "AnswerCount": "7"}, "bq_ids": {"n4140": {"so_55510_58804_3": {"length": 79, "quality": 0.79, "section_id": 3919}, "so_55510_58804_0": {"length": 35, "quality": 0.546875, "section_id": 7151}, "so_55510_58804_5": {"length": 16, "quality": 0.7272727272727273, "section_id": 3920}}, "n3337": {"so_55510_58804_3": {"length": 79, "quality": 0.79, "section_id": 3779}, "so_55510_58804_5": {"length": 16, "quality": 0.7272727272727273, "section_id": 3780}, "so_55510_58804_0": {"length": 34, "quality": 0.53125, "section_id": 6895}}, "n4659": {"so_55510_58804_5": {"length": 16, "quality": 0.7272727272727273, "section_id": 4806}, "so_55510_55877_0": {"length": 4, "quality": 0.8, "section_id": 4087}}}, "20355603": {"Id": "20355603", "PostTypeId": "2", "Body": "<p>I try to test again code from <strong>Adam Pierce</strong> and added two more cases: static variable in class and POD type. My compiler is g++ 4.8.1, in Windows OS(MinGW-32).\nResult is static variable in class is treated same with global variable. Its constructor will be called before enter main function.</p>\n<ul>\n<li><p>Conclusion (for g++, Windows environment):</p>\n<ol>\n<li><strong>Global variable</strong> and <strong>static member in class</strong>: constructor is called before enter <strong>main</strong> function <strong><em>(1)</em></strong>.</li>\n<li><strong>Local static variable</strong>: constructor is only called when execution reaches its declaration at first time.</li>\n<li>If <strong>Local static variable is POD type</strong>, then it is also initialized before enter <strong>main</strong> function <strong><em>(1)</em></strong>.\nExample for POD type: <em>static int number = 10;</em></li>\n</ol></li>\n</ul>\n<p><strong>(1)</strong>: The correct state should be: <em>\"before any function from the same translation unit is called\".</em> However, for simple, as in example below, then it is <em>main</em> function.</p>\n<p>include &lt; iostream&gt;                </p>\n<pre><code>#include &lt; string&gt;\n\nusing namespace std;\n\nclass test\n{\npublic:\n   test(const char *name)\n            : _name(name)\n    {\n            cout &lt;&lt; _name &lt;&lt; \" created\" &lt;&lt; endl;\n    }\n\n    ~test()\n    {\n            cout &lt;&lt; _name &lt;&lt; \" destroyed\" &lt;&lt; endl;\n    }\n\n    string _name;\n    static test t; // static member\n };\ntest test::t(\"static in class\");\n\ntest t(\"global variable\");\n\nvoid f()\n{\n    static  test t(\"static variable\");\n    static int num = 10 ; // POD type, init before enter main function\n\n    test t2(\"Local variable\");\n    cout &lt;&lt; \"Function executed\" &lt;&lt; endl;\n}\n\nint main()\n{\n    test t(\"local to main\");\n    cout &lt;&lt; \"Program start\" &lt;&lt; endl;\n    f();\n    cout &lt;&lt; \"Program end\" &lt;&lt; endl;\n    return 0;\n }\n</code></pre>\n<p><strong>result:</strong></p>\n<pre><code>static in class created\nglobal variable created\nlocal to main created\nProgram start\nstatic variable created\nLocal variable created\nFunction executed\nLocal variable destroyed\nProgram end\nlocal to main destroyed\nstatic variable destroyed\nglobal variable destroyed\nstatic in class destroyed\n</code></pre>\n<p>Anybody tested in Linux env ?</p>\n", "LastEditorUserId": "2103515", "LastActivityDate": "2013-12-04T13:41:22.997", "Score": "3", "CreationDate": "2013-12-03T15:49:16.380", "ParentId": "55510", "CommentCount": "0", "OwnerUserId": "2103515", "LastEditDate": "2013-12-04T13:41:22.997"}, "55592": {"Body": "<p>The compiler will allocate static variable(s) defined in a function <code>foo</code> at program load, however the compiler will also add some additional instructions (machine code) to your function <code>foo</code> so that the first time it is invoked this additional code will initialize the static variable (e.g. invoking the constructor, if applicable).</p>\n<p>@Adam: This behind the scenes injection of code by the compiler is the reason for the result you saw.</p>\n", "CreationDate": "2008-09-11T01:00:58.823", "ParentId": "55510", "CommentCount": "0", "LastEditDate": "2008-09-11T01:09:04.843", "PostTypeId": "2", "LastEditorDisplayName": "Henk", "LastActivityDate": "2008-09-11T01:09:04.843", "LastEditorUserId": "4613", "Id": "55592", "OwnerDisplayName": "Henk", "Score": "8", "OwnerUserId": "4613"}, "55570": {"Body": "<p>The memory for all static variables is allocated at program load. But local static variables are created and initialized the first time they are used, not at program start up. There's some good reading about that, and statics in general, <a href=\"https://web.archive.org/web/20100328062506/http://www.acm.org/crossroads/xrds2-4/ovp.html\" rel=\"noreferrer\">here</a>. In general I think some of these issues depend on the implementation, especially if you want to know where in memory this stuff will be located.</p>\n", "CreationDate": "2008-09-11T00:41:46.857", "ParentId": "55510", "CommentCount": "3", "LastEditDate": "2016-06-14T18:55:50.613", "PostTypeId": "2", "LastEditorDisplayName": "Eugene", "LastActivityDate": "2016-06-14T18:55:50.613", "LastEditorUserId": "44729", "Id": "55570", "OwnerDisplayName": "Eugene", "Score": "18", "OwnerUserId": "1155"}, "58804": {"Body": "<p>Some relevant verbiage from C++ Standard:</p>\n<blockquote>\n<h2>3.6.2  Initialization of non-local objects          [basic.start.init]</h2>\n<h3>1</h3>\n<p id=\"so_55510_58804_0\">The   storage   for   objects    with    static    storage \n  duration   (<em>basic.stc.static</em>) shall be zero-initialized (<em>dcl.init</em>)\n  before any   other   initialization  takes  place. Objects  of \n  POD    types   (<em>basic.types</em>) with static storage duration\n  initialized with constant   expressions (<em>expr.const</em>) shall be \n  initialized  before  any  dynamic   initialization  takes  place. \n  Objects of namespace scope with static   storage duration defined in\n  the same translation unit and  dynamically   initialized  shall  be\n  initialized in the order in which their definition  appears  in \n  the  translation  unit. [Note:  <em>dcl.init.aggr</em>  describes  the \n  order in which aggregate members are initialized. The \n  initialization of local static objects is described in <em>stmt.dcl</em>.  ]</p>\n<p id=\"so_55510_58804_1\">[more text below adding more liberties for compiler writers]</p>\n<h2>6.7  Declaration statement                                  [stmt.dcl]</h2>\n<p id=\"so_55510_58804_2\">...</p>\n<h3>4</h3>\n<p id=\"so_55510_58804_3\">The zero-initialization (<em>dcl.init</em>) of all local objects with \n  static storage  duration  (<em>basic.stc.static</em>) is performed before\n  any other initialization  takes   place. A   local  object of \n  POD type (<em>basic.types</em>)  with static  storage  duration\n  initialized with constant-expressions is initialized before its\n  block is first entered. An implementation  is  permitted to perform\n  early initialization of other local objects with static storage\n  duration under the same conditions that an implementation is\n  permitted to statically initialize an object with static storage\n  duration in namespace scope  (<em>basic.start.init</em>). Otherwise  such\n  an object is initialized the first time control passes through its\n  declaration; such an object is considered initialized upon the\n  completion of its initialization. If the initialization exits by \n  throwing an exception, the initialization is not complete, so it will\n  be  tried again the next time control enters the declaration.  If control re-enters the declaration (recursively) while the object is being\n  initialized, the behavior is undefined.  [<em>Example:</em></p>\n<pre><code>      int foo(int i)\n      {\n          static int s = foo(2*i);  // recursive call - undefined\n          return i+1;\n      }\n</code></pre>\n<p id=\"so_55510_58804_4\">--<em>end example</em>]</p>\n<h3>5</h3>\n<p id=\"so_55510_58804_5\">The destructor for a local object with static storage duration will\n  be   executed  if  and  only  if  the  variable  was  constructed. \n  [Note:   <em>basic.start.term</em>  describes  the  order  in which local\n  objects with   static storage duration are destroyed.  ]</p>\n</blockquote>\n", "CreationDate": "2008-09-12T12:20:09.697", "ParentId": "55510", "CommentCount": "0", "LastEditDate": "2011-10-31T14:35:24.520", "PostTypeId": "2", "OwnerDisplayName": "Arkadiy", "LastEditorUserId": "496830", "LastActivityDate": "2011-10-31T14:35:24.520", "Id": "58804", "Score": "38", "OwnerUserId": "3458"}, "55548": {"Id": "55548", "PostTypeId": "2", "Body": "<p>I was curious about this so I wrote the following test program and compiled it with g++ version 4.1.2.</p>\n<pre><code>include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nclass test\n{\npublic:\n        test(const char *name)\n                : _name(name)\n        {\n                cout &lt;&lt; _name &lt;&lt; \" created\" &lt;&lt; endl;\n        }\n\n        ~test()\n        {\n                cout &lt;&lt; _name &lt;&lt; \" destroyed\" &lt;&lt; endl;\n        }\n\n        string _name;\n};\n\ntest t(\"global variable\");\n\nvoid f()\n{\n        static test t(\"static variable\");\n\n        test t2(\"Local variable\");\n\n        cout &lt;&lt; \"Function executed\" &lt;&lt; endl;\n}\n\n\nint main()\n{\n        test t(\"local to main\");\n\n        cout &lt;&lt; \"Program start\" &lt;&lt; endl;\n\n        f();\n\n        cout &lt;&lt; \"Program end\" &lt;&lt; endl;\n        return 0;\n}\n</code></pre>\n<p>The results were not what I expected. The constructor for the static object was not called until the first time the function was called. Here is the output:</p>\n<pre><code>global variable created\nlocal to main created\nProgram start\nstatic variable created\nLocal variable created\nFunction executed\nLocal variable destroyed\nProgram end\nlocal to main destroyed\nstatic variable destroyed\nglobal variable destroyed\n</code></pre>\n", "OwnerDisplayName": "Adam Pierce", "LastActivityDate": "2008-09-11T00:18:08.460", "Score": "62", "CreationDate": "2008-09-11T00:18:08.460", "ParentId": "55510", "CommentCount": "4", "OwnerUserId": "5324"}, "55515": {"Body": "<p>Static variables are allocated inside a code segment -- they are part of the executable image, and so are mapped in already initialized.</p>\n<p>Static variables within function scope are treated the same, the scoping is purely a language level construct.</p>\n<p>For this reason you are guaranteed that a static variable will be initialized to 0 (unless you specify something else) rather than an undefined value.</p>\n<p>There are some other facets to initialization you can take advantage off -- for example shared segments allow different instances of your executable running at once to access the same static variables.</p>\n<p>In C++ (globally scoped) static objects have their constructors called as part of the program start up, under the control of the C runtime library.  Under Visual C++ at least the order that objects are initialized in can be controlled by the <a href=\"http://support.microsoft.com/kb/104248\" rel=\"nofollow noreferrer\">init_seg</a> pragma.</p>\n", "CreationDate": "2008-09-10T23:54:27.237", "ParentId": "55510", "CommentCount": "5", "LastEditDate": "2008-09-11T00:44:47.803", "PostTypeId": "2", "LastEditorDisplayName": "Rob Walker", "LastActivityDate": "2008-09-11T00:44:47.803", "LastEditorUserId": "3631", "Id": "55515", "OwnerDisplayName": "Rob Walker", "Score": "3", "OwnerUserId": "3631"}, "55877": {"Body": "<blockquote>\n<p id=\"so_55510_55877_0\">Or is it initialized when doSomething() is first called?</p>\n</blockquote>\n<p>Yes, it is. This, among other things, lets you initialize globally-accessed data structures when it is appropriate, for example inside try/catch blocks. E.g. instead of</p>\n<pre><code>int foo = init(); // bad if init() throws something\n\nint main() {\n  try {\n    ...\n  }\n  catch(...){\n    ...\n  }\n}\n</code></pre>\n<p>you can write</p>\n<pre><code>int&amp; foo() {\n  static int myfoo = init();\n  return myfoo;\n}\n</code></pre>\n<p>and use it inside the try/catch block. On the first call, the variable will be initialized. Then, on the first and next calls, its value will be returned (by reference).</p>\n", "CreationDate": "2008-09-11T05:58:41.620", "ParentId": "55510", "CommentCount": "0", "LastEditDate": "2011-10-31T14:07:39.923", "PostTypeId": "2", "OwnerDisplayName": "dmityugov", "LastEditorUserId": "496830", "LastActivityDate": "2011-10-31T14:07:39.923", "Id": "55877", "Score": "3", "OwnerUserId": "3232"}});