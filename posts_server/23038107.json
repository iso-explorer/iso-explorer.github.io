post_cb({"bq_ids": {"n4140": {"so_23038107_23038120_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 6070}}, "n3337": {"so_23038107_23038120_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 5838}}, "n4659": {"so_23038107_23038120_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 7566}}}, "23038107": {"ViewCount": "36", "Body": "<p>A problem in a legacy system has been reduced to code which does \"auto\" array indexing onto itself that look like the following:</p>\n<pre><code>int x[4] = {1,2,3,4};\nstd::cout &lt;&lt; x[++*+x] &lt;&lt; \" \" &lt;&lt; x[*+x+1] &lt;&lt; \"\\n\";\n</code></pre>\n<p>The code never underwent a code review for readability and maintainability, and I am trying to understand why it outputs <strong>3</strong> and <strong>4</strong>? It's unclear to me how it indexes into the array.</p>\n", "AcceptedAnswerId": "23038120", "Title": "Array self-increments", "CreationDate": "2014-04-13T01:30:40.687", "Id": "23038107", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-04-13T02:54:17.797", "Score": "2", "OwnerUserId": "915009", "Tags": "<c++><arrays>", "AnswerCount": "2"}, "23038120": {"Id": "23038120", "PostTypeId": "2", "Body": "<p>The code does index into the array, but it also changes the array as it does. It is equivalent to,</p>\n<pre><code>std::cout &lt;&lt; x[++x[0]] &lt;&lt; \" \"; // the array becomes {2,2,3,4}    \nstd::cout &lt;&lt; x[x[0]+1] &lt;&lt; \"\\n\";\n</code></pre>\n<p>Note that <code>+x</code> is simply the pointer address of the array. The relevant part of the standard says in <code>5.3.1 [expr.unary.op]</code>:</p>\n<blockquote>\n<p id=\"so_23038107_23038120_0\">The operand of the unary + operator shall have arithmetic, unscoped enumeration, or pointer type and the\n  result is the value of the argument.</p>\n</blockquote>\n", "LastActivityDate": "2014-04-13T01:33:00.883", "CommentCount": "1", "CreationDate": "2014-04-13T01:33:00.883", "ParentId": "23038107", "Score": "3", "OwnerUserId": "3099074"}, "23038556": {"Id": "23038556", "PostTypeId": "2", "Body": "<p>Building on mockinterface's answer. (My comment is too big to fit in a comment!)</p>\n<p>The code is more clearly expressed as:</p>\n<pre><code>std::cout &lt;&lt; x[++x[0]] &lt;&lt; \" \" &lt;&lt; x[x[0]+1] &lt;&lt; \"\\n\";\n</code></pre>\n<p>However, in C++98 and C++03 <strong>this causes undefined behaviour</strong>.\nThe read of <code>x[0]</code> to the right, and the increment of <code>x[0]</code> may\noccur without an intervening sequence point. (Even though these\noperator invocations are function calls, all of the arguments may\nbe evaluated before any function is called).</p>\n<p>(C++11 changed the rules for sequencing, IDK whether this code is\nnow well-defined, or if so, which of those operations occurs first).</p>\n<p>Furthermore, just the expression <code>x[++x[0]]</code> causes undefined behaviour\nif <code>x[0] == -1</code> beforehand, as there is no sequence point between the\nincrement and the outer access of <code>x[0]</code>. </p>\n<p>I'd recommend replacing this expression with something that does not\nmix increments and reads.  For example:</p>\n<pre><code>int index = ++x[0];\nif ( index &gt;= 0 &amp;&amp; index &lt; (int)lengthof(x) - 1 )\n     std::cout &lt;&lt; x[index] &lt;&lt; \" \" &lt;&lt; x[index+1] &lt;&lt; \"\\n\";\nelse\n     std::cout &lt;&lt; \"index out of bounds on x[]\\n\";\n</code></pre>\n", "LastEditorUserId": "1505939", "LastActivityDate": "2014-04-13T02:54:17.797", "Score": "0", "CreationDate": "2014-04-13T02:46:36.090", "ParentId": "23038107", "CommentCount": "2", "OwnerUserId": "1505939", "LastEditDate": "2014-04-13T02:54:17.797"}});