post_cb({"bq_ids": {"n4140": {"so_28418145_28418297_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 1617}}, "n3337": {"so_28418145_28418297_0": {"length": 9, "quality": 0.6428571428571429, "section_id": 1613}}, "n4659": {"so_28418145_28418297_0": {"length": 10, "quality": 0.7142857142857143, "section_id": 1770}}}, "28418297": {"Id": "28418297", "PostTypeId": "2", "Body": "<p>A <code>std::string</code> has behavior that is not compatible with <code>std::vector</code>, in particular the appearance of a zero-value at the end.</p>\n<p>C++11 \u00a721.4.5/2 about <code>operator[]</code>, in [string.access]:</p>\n<blockquote>\n<p id=\"so_28418145_28418297_0\"><strong>\u201d</strong> Returns: <code>*(begin() + pos)</code> if <code>pos &lt; size()</code>, otherwise a reference to an object of type <code>T</code> with value\n  <code>charT()</code>; the referenced value shall not be modified.</p>\n</blockquote>\n<p>Another big difference is that <code>std::string</code> supports the small buffer optimization, while that optimization possibility is <a href=\"https://stackoverflow.com/a/8191356/464581\">not available for <code>std::vector</code></a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-02-09T20:17:36.507", "Score": "2", "CreationDate": "2015-02-09T20:03:56.750", "ParentId": "28418145", "CommentCount": "5", "OwnerUserId": "464581", "LastEditDate": "2017-05-23T11:52:27.893"}, "28418145": {"ViewCount": "292", "Body": "<p>It seems obvious to consider a string to be a vector of characters. Why then does string have its own special implementation, which seems quite different from that of the vector class?</p>\n<p>Just to illustrate the point, here are some snippets from both classes to show that the work needed is rather similar, e.g. both using an allocator to manage memory. Also having traits could be useful for vectors as well. </p>\n<p>The following snipped from the implementation of std::string looks like it would fit into the more general implementation of std::vector if we would allow a vector to have type-traits.</p>\n<pre><code> 139  template &lt;class _charT, class _Traits , class _Allocator &gt;                                        |\n 140  class _RWSTDExportTemplate basic_string                                                           |\n 141  {                                                                                                 |\n 142  public:  \n ....\n 333    size_type size () const   { return length(); }                                                  |\n 334    inline size_type length () const;                                                               |\n 335    size_type max_size () const                                                                     |\n 336    {                                                                                               |\n 337      return npos - sizeof(__rep_type)-2;                                                           |\n 338    }                                                                                               |\n 339    inline void resize (size_type, _charT);                                                         |\n 340    void resize (size_type n)                                                                       |\n 341    {                                                                                               |\n 342      resize(n,__eos());                                                                            |\n 343    }                                                                                               |\n 344    inline size_type capacity () const;                                                             |\n 345    inline void reserve (size_type=0);                                                              |\n 346    void clear () { erase(); }                                                                      |\n 347    bool empty () const  { return length() == 0; }   \n</code></pre>\n<p>And this is from vector:</p>\n<pre><code>75  template &lt;class _Tt, class _Allocator _RWSTD_COMPLEX_DEFAULT(allocator&lt;_Tt&gt;) &gt;                    |\n76  class vector                                                                                      |\n77  {                                                                                                 |\n78       \n86  public:                                                                                           |\n87    //                                                                                              |\n88    // Types.                                                                                       |\n89    //                                                                                              |\n90    typedef _Tt                                         value_type;                                 |\n91    typedef _Allocator                                  allocator_type;                             |\n92 \n383    //                                                                                              |\n384    // Capacity.\n385    //\n386    size_type size ()     const { return size_type(end() - begin()); }\n387    size_type max_size () const { return __value_alloc_type(__end_of_storage).max_size();   }\n388    void resize (size_type new_size);\n389    void resize (size_type new_size, _Tt value);\n390\n391    size_type capacity () const { return size_type(__end_of_storage.data() - begin()); }\n392    bool      empty ()    const { return begin() == end();                    }\n393    void reserve (size_type n)\n394    {\n395      _RWSTD_THROW(n &gt; max_size(), length_error,\n396        __RWSTD::except_msg_string(__RWSTD::__rwse_InvalidSizeParam,\n397          \"vector::reserve(size_t)\",n,max_size()).msgstr());\n398\n399      if (capacity() &lt; n)\n400      {\n401        __value_alloc_type va(__end_of_storage);\n402        iterator tmp = va.allocate(n,__start);\n403#ifndef _RWSTD_NO_EXCEPTIONS\n404        try {\n405          uninitialized_copy(begin(), end(), tmp);\n406        } catch(...) {\n407          __value_alloc_type(__end_of_storage).deallocate(tmp,n);\n408          throw;\n409        }\n410#else\n</code></pre>\n", "AcceptedAnswerId": "28418297", "Title": "Why isn't std::string a specialization of std::vector?", "CreationDate": "2015-02-09T19:54:53.950", "Id": "28418145", "CommentCount": "6", "PostTypeId": "1", "ClosedDate": "2015-02-09T20:05:21.407", "LastActivityDate": "2015-02-09T20:17:36.507", "Score": "7", "OwnerUserId": "3867787", "Tags": "<c++><string><vector><stl>", "AnswerCount": "2"}, "28418289": {"Id": "28418289", "PostTypeId": "2", "Body": "<p>Take for example this snippet:</p>\n<pre><code>string s = \"abc\";\n</code></pre>\n<p>There is no container that has a similar kind of initialisation syntax where it receives a pointer to the first element and scans the sequence for the special terminator element. Using a <code>std::vector</code> would be cumbersome at least. Since texts are common in computing, having a convenient text container type is simply a necessity and <code>std::vector</code> just doesn't fit.</p>\n<p>That said, I could imagine <code>std::string</code> inheriting <code>std::vector&lt;char&gt;</code> privately or aggregating it, but that's a whole different issue than being a specialization of it. It also can't be a specialization, because what if you want a <code>vector&lt;char&gt;</code> that does not behave like a string? You would then have the same fubar as with <code>vector&lt;bool&gt;</code> today.</p>\n", "LastActivityDate": "2015-02-09T20:03:21.123", "CommentCount": "5", "CreationDate": "2015-02-09T20:03:21.123", "ParentId": "28418145", "Score": "3", "OwnerUserId": "1968182"}});