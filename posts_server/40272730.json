post_cb({"bq_ids": {"n4140": {"so_40272730_40273121_0": {"length": 11, "quality": 1.0, "section_id": 1159}}, "n3337": {"so_40272730_40273121_0": {"length": 11, "quality": 1.0, "section_id": 1157}}, "n4659": {"so_40272730_40273121_0": {"length": 11, "quality": 1.0, "section_id": 1253}}}, "40273121": {"Id": "40273121", "PostTypeId": "2", "Body": "<p>Forget about relaxed, there's no guarantee that an atomic store <em>ever</em> become visible to an atomic load in a different thread. The best you get is the normative encouragement in <a href=\"https://timsong-cpp.github.io/cppwp/atomics#order-12\" rel=\"nofollow\">[atomics.order]/12</a> (and analogous wording in <a href=\"https://timsong-cpp.github.io/cppwp/intro.progress#18\" rel=\"nofollow\">[intro.progress]/18</a>):</p>\n<blockquote>\n<p id=\"so_40272730_40273121_0\">Implementations should make atomic stores visible to atomic loads\n  within a reasonable amount of time.</p>\n</blockquote>\n<p>...which is not a requirement.</p>\n<p>(C11 has identical wording in \u00a77.11.3/16)</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2016-10-26T22:43:08.503", "Score": "1", "CreationDate": "2016-10-26T22:27:16.260", "ParentId": "40272730", "CommentCount": "6", "LastEditDate": "2016-10-26T22:43:08.503", "OwnerUserId": "2756719"}, "40272730": {"ViewCount": "245", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;atomic&gt;\n\nextern std::atomic&lt;int&gt; i;\n\nvoid f(void)\n{\n  while (!i.load(std::memory_order_relaxed))\n      ;\n}\n</code></pre>\n<p>I'm looking for a citation from the C++11 standard that says that the compiler is not allowed to transform the loop into</p>\n<pre><code>  if (!i.load(std::memory_order_relaxed)) {\n    while (1)\n      ;\n  }\n</code></pre>\n<p>I've seen some discussion <a href=\"https://lwn.net/Articles/509596/\" rel=\"nofollow\">here</a> but nothing conclusive.</p>\n<p><strong>Edit</strong>: A previous version of this post called an extern function inside the loop.</p>\n<p><strong>Edit 2</strong>: For motivation: The book \"Effective Java\" says that the HotSpot VM performs the following transformation:</p>\n<pre><code>while (!done)\n    i++;\n</code></pre>\n<p>to</p>\n<pre><code>if (!done)\n    while (true)\n        i++;\n</code></pre>\n<p>even though it's perfectly defined behavior for another thread to change the <strong>done</strong> variable concurrently.</p>\n", "Title": "Does the C++11 memory model allow hoisting relaxed atomic loads out of loops?", "CreationDate": "2016-10-26T21:53:58.563", "LastActivityDate": "2016-10-26T22:43:08.503", "CommentCount": "11", "LastEditDate": "2016-10-26T22:26:38.100", "PostTypeId": "1", "LastEditorUserId": "5585843", "Id": "40272730", "Score": "8", "OwnerUserId": "5585843", "Tags": "<c++><c++11><atomic><atomicity>", "AnswerCount": "1"}});