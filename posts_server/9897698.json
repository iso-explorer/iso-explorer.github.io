post_cb({"9897730": {"ParentId": "9897698", "PostTypeId": "2", "CommentCount": "13", "Body": "<p>For unsigned types, <code>0-1</code> is the maximum value for that type, so it's always <code>&gt;= arraySize</code>. In other words, yes that is absolutely safe.</p>\n", "OwnerUserId": "1011995", "LastEditorUserId": "82320", "LastEditDate": "2012-03-27T21:17:28.450", "Id": "9897730", "Score": "5", "CreationDate": "2012-03-27T21:07:34.950", "LastActivityDate": "2012-03-27T21:17:28.450"}, "9897825": {"ParentId": "9897698", "CommentCount": "5", "Body": "<p>Unsigned integers never overflow in C++ and in C.</p>\n<p>For C++ language:</p>\n<blockquote>\n<p id=\"so_9897698_9897825_0\">(C++11, 3.9.1p4) \"Unsigned integers, declared unsigned, shall obey the laws of arithmetic modulo 2n where n is the number of bits in the value representation of that particular size of integer. 46)\"</p>\n</blockquote>\n<p>and footnote 46):</p>\n<blockquote>\n<p id=\"so_9897698_9897825_1\">\"46) This implies that unsigned arithmetic does not overflow because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the resulting unsigned integer type.\"</p>\n</blockquote>\n<p>and for C language:</p>\n<blockquote>\n<p id=\"so_9897698_9897825_2\">(C11, 6.2.5p9) \"A computation involving unsigned operands can never overflow,\n  because a result that cannot be represented by the resulting unsigned integer type is\n  reduced modulo the number that is one greater than the largest value that can be\n  represented by the resulting type.\"</p>\n</blockquote>\n", "OwnerUserId": "1119701", "PostTypeId": "2", "Id": "9897825", "Score": "5", "CreationDate": "2012-03-27T21:17:06.910", "LastActivityDate": "2012-03-27T21:17:06.910"}, "9897762": {"ParentId": "9897698", "CommentCount": "4", "Body": "<p>Make sure <code>oneBasedIndex</code> is greater than zero...</p>\n", "OwnerUserId": "507793", "PostTypeId": "2", "Id": "9897762", "Score": "0", "CreationDate": "2012-03-27T21:10:48.660", "LastActivityDate": "2012-03-27T21:10:48.660"}, "9897698": {"CommentCount": "1", "AcceptedAnswerId": "9897730", "PostTypeId": "1", "LastEditorUserId": "1272627", "CreationDate": "2012-03-27T21:05:10.633", "LastActivityDate": "2012-03-27T21:46:28.240", "LastEditDate": "2012-03-27T21:46:28.240", "ViewCount": "222", "FavoriteCount": "1", "Title": "Is it safe to shift 1-based numbering to 0-based numbering by subtracting 1 if unsigned integers are used?", "Id": "9897698", "Score": "4", "Body": "<p>In a system I am maintaining, users request elements from a collection from a 1-based indexing scheme.  Values are stored in 0-based arrays in C++ / C.</p>\n<p>Is the following hypothetical code portable if 0 is erroneously entered as the input to this function?  Is there a better way to validate the user's input when converting 1-based numbering schemes to 0-based?</p>\n<pre><code>const unsigned int arraySize;\nSomeType array[arraySize];    \n\nSomeType GetFromArray( unsigned int oneBasedIndex )\n{\n  unsigned int zeroBasedIndex = oneBasedIndex - 1;\n\n  //Intent is to check for a valid index.\n  if( zeroBasedIndex &lt; arraySize )\n  {\n    return array[zeroBasedIndex];\n  }\n\n  //else... handle the error\n}\n</code></pre>\n<p>My assumption is that <code>(unsigned int)( 0 - 1 )</code> is always greater than <code>arraySize</code>; is this true?</p>\n<p>The alternative, as some have suggested in their answers below, is to check <code>oneBasedIndex</code> and ensure that it is greater than 0:</p>\n<pre><code>const unsigned int arraySize;\nSomeType array[arraySize];    \n\nSomeType GetFromArray( unsigned int oneBasedIndex )\n{\n  if( oneBasedIndex &gt; 0 &amp;&amp; oneBasedIndex &lt;= arraySize )\n  {\n    return array[oneBasedIndex - 1];\n  }\n\n  //else... handle the error\n}\n</code></pre>\n", "Tags": "<c++><c>", "OwnerUserId": "1272627", "AnswerCount": "5"}, "9897919": {"ParentId": "9897698", "CommentCount": "2", "Body": "<p>No, for example 0-1 is 0xffffffff in 4-byte unsigned int, what if your array is really that big? \n32 bit is ok because 0xffffffff exceeds limit, the code breaks when compile in 64 bit if the array is that big.</p>\n<p>Just check for oneBasedIndex &gt; 0</p>\n", "OwnerUserId": "1276280", "PostTypeId": "2", "Id": "9897919", "Score": "1", "CreationDate": "2012-03-27T21:23:47.143", "LastActivityDate": "2012-03-27T21:23:47.143"}, "bq_ids": {"n4140": {"so_9897698_9897825_1": {"section_id": 7213, "quality": 0.9642857142857143, "length": 27}, "so_9897698_9897825_0": {"section_id": 7213, "quality": 0.7777777777777778, "length": 14}, "so_9897698_9897825_2": {"section_id": 7213, "quality": 0.7586206896551724, "length": 22}}, "n3337": {"so_9897698_9897825_2": {"section_id": 6957, "quality": 0.7586206896551724, "length": 22}, "so_9897698_9897825_0": {"section_id": 6957, "quality": 0.8888888888888888, "length": 16}, "so_9897698_9897825_1": {"section_id": 6957, "quality": 0.9642857142857143, "length": 27}}, "n4659": {"so_9897698_9897825_2": {"section_id": 8722, "quality": 0.7586206896551724, "length": 22}, "so_9897698_9897825_0": {"section_id": 8722, "quality": 0.7777777777777778, "length": 14}, "so_9897698_9897825_1": {"section_id": 8722, "quality": 0.9642857142857143, "length": 27}}}, "9897732": {"ParentId": "9897698", "CommentCount": "2", "Body": "<p>Chances are good that it's safe, but for many purposes, there's a much simpler way: allocate one extra spot in your array, and just ignore element 0.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "9897732", "Score": "4", "CreationDate": "2012-03-27T21:07:46.510", "LastActivityDate": "2012-03-27T21:07:46.510"}});