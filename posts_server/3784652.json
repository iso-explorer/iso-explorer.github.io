post_cb({"3784652": {"CommentCount": "1", "ViewCount": "1358", "CreationDate": "2010-09-24T06:14:58.770", "LastActivityDate": "2017-09-26T13:25:33.047", "Title": "Private template classes/structs visibility", "AcceptedAnswerId": "3784718", "PostTypeId": "1", "Id": "3784652", "Score": "3", "Body": "<p>I don't understand why in the following code, I am allowed to create the function <code>print_private_template</code> while the compiler complains about <code>print_private_class</code>:</p>\n<pre><code>#include &lt;cstdio&gt;\n\nclass A\n{\n    private:\n        template &lt;unsigned T&gt;\n        struct B\n        {\n\n        };\n\n        struct C\n        {\n\n        };\n\n    public:\n        template &lt;unsigned T&gt;\n        B&lt;T&gt; getAb()\n        { \n            return B&lt;T&gt;();\n        }\n\n        C getAc()\n        { \n            return C();\n        }\n};\n\ntemplate&lt;unsigned T&gt;\nvoid print_private_template(const A::B&lt;T&gt; &amp;ab)\n{\n    printf(\"%d\\n\", T);\n}\n\nvoid print_private_class(const A::C &amp;ac)\n{\n    printf(\"something\\n\");\n}\n\nint main(int, char**)\n{\n    A a;\n\n    print_private_template(a.getAb&lt;42&gt;());\n\n    print_private_class(a.getAc());\n\n    return 0;\n}\n</code></pre>\n<p>Is this an expected behaviour? a compiler bug/extension?</p>\n<p>Just to be clear, my goal is to make the compiler error on <em>both</em> the usage of  <code>print_private_template</code> and <code>print_private_class</code>.</p>\n", "Tags": "<c++><templates><private-members>", "OwnerUserId": "41983", "AnswerCount": "2"}, "3784718": {"ParentId": "3784652", "LastEditDate": "2010-09-24T06:37:47.327", "CommentCount": "5", "CreationDate": "2010-09-24T06:30:21.760", "OwnerUserId": "66692", "LastEditorUserId": "66692", "PostTypeId": "2", "Id": "3784718", "Score": "2", "Body": "<p><a href=\"http://www.comeaucomputing.com/tryitout/\" rel=\"nofollow\">Comeau</a> does give an error (when you comment out the <code>print_private_class</code> function and its call in strict C++03 mode.</p>\n<blockquote>\n<p id=\"so_3784652_3784718_0\">ComeauTest.c(31): error: class template \"A::B\" (declared at line 7) is inaccessible\n    void print_private_template(const A::B &amp;ab)\n                                         ^\n            detected during instantiation of \"print_private_template\" based on\n    template argument &lt;42U&gt; at line 45</p>\n</blockquote>\n<p>G++ 4.5 on Windows does not report any error with <code>-std=c++ -Wall -pedantic</code> though.</p>\n<p>Your class <code>A::C</code> and class template <code>A::B&lt;T&gt;</code> both have the same visibility as any other normal members. Hence, both <code>print_private_class</code> and <code>print_private_template</code> require a diagnostic.</p>\n<blockquote>\n<p id=\"so_3784652_3784718_1\"><strong>11.8 Nested classes</strong> [class.access.nest]</p>\n<p id=\"so_3784652_3784718_2\"><strong>1</strong> A nested class is a member and as such has the same access rights as any other member. The members of\n  an enclosing class have no special access to members of a nested class; the usual access rules (Clause 11)\n  shall be obeyed.</p>\n</blockquote>\n", "LastActivityDate": "2010-09-24T06:37:47.327"}, "46427827": {"ParentId": "3784652", "CommentCount": "0", "Body": "<p>As stated by Dirk Gently, GCC doesn't perform access control when instantiating template structs / classes nested in other (template) structs / classes.</p>\n<p>One way to work around this is to encapsulate them in a non-template struct:</p>\n<pre><code>template&lt;int I&gt; class MyTemplate\n{\n    struct PT\n    {\n        template&lt;int, typename = void&gt; struct InnerTemplate;\n        // ... specialisations here ...\n    };\npublic:\n    typedef typename PT::template InnerTemplate&lt;I&gt;::SomeType SomeType;\n};\ntypedef MyTemplate&lt;1&gt;::PT::InnerTemplate&lt;1&gt; ThisWontWork;\n</code></pre>\n<p>The last line will fail to compile with the error:</p>\n<pre><code>error: 'struct MyTemplate&lt;1&gt;::PT' is private within this context\n</code></pre>\n<p>I'll grant that this is ugly, especially having to use <code>PT::template</code> but it seems to effectively prevent clients from instantiating helper templates they aren't meant to access, so it's worth a shot.</p>\n", "OwnerUserId": "8627954", "PostTypeId": "2", "Id": "46427827", "Score": "0", "CreationDate": "2017-09-26T13:25:33.047", "LastActivityDate": "2017-09-26T13:25:33.047"}, "bq_ids": {"n4140": {"so_3784652_3784718_2": {"section_id": 6700, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_3784652_3784718_2": {"section_id": 6455, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_3784652_3784718_2": {"section_id": 8174, "quality": 0.9583333333333334, "length": 23}}}});