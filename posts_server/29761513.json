post_cb({"bq_ids": {"n4140": {"so_29761513_29761584_0": {"length": 33, "quality": 0.9428571428571428, "section_id": 1171}, "so_29761513_29761513_0": {"length": 11, "quality": 1.0, "section_id": 1170}, "so_29761513_29761513_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 1170}}, "n3337": {"so_29761513_29761584_0": {"length": 32, "quality": 0.9142857142857143, "section_id": 1169}, "so_29761513_29761513_0": {"length": 11, "quality": 1.0, "section_id": 1168}, "so_29761513_29761513_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 1168}}}, "29761584": {"LastActivityDate": "2015-04-21T02:17:39.027", "CommentCount": "3", "Body": "<p>The standard mandates this some typedefs as per [atomics.types.generic]:</p>\n<blockquote>\n<p id=\"so_29761513_29761584_0\">There shall be named types corresponding to the integral specializations of atomic, as specified in Table 146,\n  and a named type <code>atomic_bool</code> corresponding to the specified <code>atomic&lt;bool&gt;</code>. Each named type is either a\n  <code>typedef</code> to the corresponding specialization or a base class of the corresponding specialization. If it is a base\n  class, it shall support the same member functions as the corresponding specialization.</p>\n</blockquote>\n<p>In Table 146, we see that <code>atomic_int</code> is a typedef for <code>atomic&lt;int&gt;</code>. The <em>integral</em> specializations are defined in the same section as having:</p>\n<pre><code>template &lt;&gt; struct atomic&lt;integral &gt; {\n    ...\n    constexpr atomic(integral ) noexcept;\n    ...\n};\n</code></pre>\n<p>Substitute in <code>int</code> for <em>integral</em> and we have a <code>constexpr atomic_int(int )</code> constructor. Frankly, it'd be quite weird if you <em>couldn't</em> initialize an <code>atomic&lt;T&gt;</code> with a <code>T</code>...</p>\n", "CreationDate": "2015-04-21T02:00:48.447", "LastEditDate": "2015-04-21T02:17:39.027", "ParentId": "29761513", "Id": "29761584", "LastEditorUserId": "2069064", "PostTypeId": "2", "Score": "1", "OwnerUserId": "2069064"}, "29761513": {"CreationDate": "2015-04-21T01:53:54.553", "ViewCount": "203", "Id": "29761513", "AcceptedAnswerId": "29761584", "Score": "0", "Title": "Shouldn't standard specializations of std::atomic lack value constructor", "LastEditorUserId": "1348273", "CommentCount": "3", "Body": "<p>The general version of the <code>std::atomic</code> template has a value constructor declared as</p>\n<p><code>constexpr atomic( T desired );</code> (See <a href=\"http://en.cppreference.com/w/cpp/atomic/atomic/atomic\" rel=\"nofollow\">here</a>)</p>\n<p>It is also said that <code>bool</code>, integral and pointer specializations of the template have (quoted from <a href=\"http://en.cppreference.com/w/cpp/atomic/atomic\" rel=\"nofollow\">cppreference</a>)</p>\n<blockquote>\n<p id=\"so_29761513_29761513_0\">standard layout, trivial default constructors, and trivial\n  destructors. They support aggregate initialization syntax.</p>\n</blockquote>\n<p>This makes sense, for classes having only trivial default ctor and dtor (i.e., without a value ctor) qualifies as an aggregate and hence supports aggregate initialization syntax. However, the following code compiles fine on both GCC and clang:</p>\n<p><code>std::atomic_int i(9);</code></p>\n<p>This implies that a value ctor should exist. Is this a violation of the standard?</p>\n<p>Quoted from C++11 standard</p>\n<blockquote>\n<p id=\"so_29761513_29761513_1\">These specializations shall have standard layout, trivial default\n  constructors, and trivial destructors. They shall each support\n  aggregate initialization syntax.</p>\n</blockquote>\n<p>This does not make it clear whether such specializations should have a value ctor, either.</p>\n", "Tags": "<c++><c++11><aggregate><language-lawyer><atomic>", "LastEditDate": "2015-04-21T02:18:18.337", "LastActivityDate": "2015-04-21T02:18:18.337", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "1348273"}});