post_cb({"19579475": {"ParentId": "19579435", "CommentCount": "15", "Body": "<p><code>delete b;</code> effectively performs <code>b-&gt;~Base(); deallocate(b);</code>. The first part - calling the destructor - would fail to compile if the destructor is inaccessible (in the same way that calling any other inaccessible method fails).</p>\n", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "19579475", "Score": "5", "CreationDate": "2013-10-25T01:12:10.833", "LastActivityDate": "2013-10-25T01:12:10.833"}, "19579479": {"ParentId": "19579435", "LastEditDate": "2013-10-25T17:12:08.663", "CommentCount": "0", "CreationDate": "2013-10-25T01:12:36.307", "OwnerUserId": "103167", "LastEditorUserId": "103167", "PostTypeId": "2", "Id": "19579479", "Score": "8", "Body": "<p>The C++ Standard has this to say about <code>delete</code> (section 5.3.5p10):</p>\n<blockquote>\n<p id=\"so_19579435_19579479_0\">Access and ambiguity control are done for both the deallocation function and the destructor (12.4, 12.5).</p>\n</blockquote>\n<p>Therefore, only code that has access to the destructor is able to use <code>delete</code>.  Since the destructor is <code>protected</code>, that means that no one can call <code>delete</code> on a pointer of type <code>Base*</code>.  Only subclasses can use the destructor at all (and the only thing that will is the subclass's own destructor, as part of the subobject destruction process).</p>\n<p>Of course, the subclass should make its own destructor <code>public</code>, allowing you to delete objects through the subclass type (assuming that is the correct actual type).</p>\n<p>NOTE: Actually, other members of <code>Base</code> can do <code>delete (Base*)p;</code> since they have access.  But C++ assumes that someone using this construct will not be doing that -- C++ access control only provides guidance to code outside your class.</p>\n", "LastActivityDate": "2013-10-25T17:12:08.663"}, "19579435": {"CommentCount": "0", "CreationDate": "2013-10-25T01:08:09.243", "PostTypeId": "1", "AcceptedAnswerId": "19579479", "LastEditorUserId": "-1", "LastActivityDate": "2016-12-09T19:23:06.747", "LastEditDate": "2017-05-23T10:29:23.917", "ViewCount": "3663", "FavoriteCount": "1", "Title": "Protected non-virtual destructor in the base class", "Id": "19579435", "Score": "2", "Body": "<p>I am trying to understand virtual destructors. The following is a copy paste from this page <a href=\"https://stackoverflow.com/questions/461203/when-to-use-virtual-destructors\">When to use virtual destructors?</a></p>\n<blockquote>\n<p id=\"so_19579435_19579435_0\">Here, you'll notice that I didn't declare Base's destructor to be\n  virtual. Now, let's have a look at the following snippet:</p>\n<pre><code>Base *b = new Derived(); // use b \ndelete b; // Here's the problem!\n</code></pre>\n<p id=\"so_19579435_19579435_1\">[...] If you want to prevent the deletion of an instance through a base class pointer, you can make the base class destructor protected and non-virtual; by doing so, the compiler won't let you call delete on a base class pointer.</p>\n</blockquote>\n<p>I don't understand why the deletion is prevented by having a protected non-virtual base class destructor. Doesn't the compiler think that we're trying to call <code>delete</code> from a base class object? What does <code>protected</code> have to do with that?</p>\n", "Tags": "<c++><protected><virtual-destructor>", "OwnerUserId": "2564569", "AnswerCount": "3"}, "41067493": {"ParentId": "19579435", "CommentCount": "0", "Body": "<p>From my understanding (based on this <a href=\"http://www.gotw.ca/publications/mill18.htm\" rel=\"nofollow noreferrer\">page</a>), the only case we would like to use the non-virtual and protected destructor in the base class is the following:</p>\n<pre><code>struct unary_function {\n  typedef int argument_type;\n  typedef bool result_type;\n\nprotected:\n  ~unary_function() {\n      std::cout &lt;&lt; \"unary_function\" &lt;&lt; std::endl;\n  }\n};\n\nstruct IsOdd : public unary_function {\npublic:\n  bool operator()(int number) { return (number % 2 != 0); }\n};\n\nvoid f(unary_function *f) {\n  // compile error\n  // delete f;\n}\n\nint main(int argc, char **argv) {\n  // unary_function *a = new IsOdd;\n  // delete a;\n\n  IsOdd *a = new IsOdd;\n  delete a;\n\n  getchar();\n  return 0;\n} // main\n</code></pre>\n<p>therefore, you can only do this:</p>\n<pre><code>  IsOdd *a = new IsOdd;\n  delete a;\n</code></pre>\n<p>or </p>\n<pre><code>  IsOdd c;\n</code></pre>\n<p>never these:</p>\n<pre><code>  unary_function *a = new IsOdd;\n  delete a;\n</code></pre>\n<p>therefore, with nonvirtual protected destructor, the compiler would give an error when you try to use this </p>\n<pre><code>void f(unary_function *f) {\n  delete f; \n  // this function couldn't get compiled because of this delete. \n  // you would have to use the derived class as the parameter \n}\n</code></pre>\n", "OwnerUserId": "604912", "PostTypeId": "2", "Id": "41067493", "Score": "0", "CreationDate": "2016-12-09T19:23:06.747", "LastActivityDate": "2016-12-09T19:23:06.747"}, "bq_ids": {"n4140": {"so_19579435_19579479_0": {"section_id": 6116, "quality": 0.8, "length": 8}}, "n3337": {"so_19579435_19579479_0": {"section_id": 5880, "quality": 0.8, "length": 8}}, "n4659": {"so_19579435_19579479_0": {"section_id": 7613, "quality": 0.8, "length": 8}}}});