post_cb({"21055144": {"LastActivityDate": "2014-01-10T22:16:25.963", "CommentCount": "2", "Body": "<p>Not trivially as you're posing, since you cannot set the arguments directly. decltype(foo) does return the actual type of foo, so you can use that to instantiate a template traits class that then exposes the return type and arguments type (somehow), and then use that to define your function. </p>\n<pre><code>#include &lt;stdio.h&gt;\nint sf(int, float, double, bool) {}\ntemplate &lt;typename RV, typename... args&gt;\nRV func(args... as) {\n  printf(\"%d %f %f %d\\n\", as...);\n  return sf(as...);\n}\ntemplate &lt;typename RV, typename... args&gt;\nRV(*generateFunc(RV(*)(args...)))(args...) {\n  return &amp;func&lt;RV, args...&gt;;\n}\n\nint main() {\n  decltype(sf) *f = generateFunc(sf);\n  f(42, 1.0f, 12.0, true);\n}\n</code></pre>\n<p>This generates a function to match sf's signature and then forwards the call to it.</p>\n", "CreationDate": "2014-01-10T21:55:27.797", "LastEditDate": "2014-01-10T22:16:25.963", "ParentId": "21055039", "Id": "21055144", "LastEditorUserId": "272708", "PostTypeId": "2", "Score": "1", "OwnerUserId": "272708"}, "21055039": {"CreationDate": "2014-01-10T21:49:19.773", "ViewCount": "1777", "FavoriteCount": "0", "Id": "21055039", "AcceptedAnswerId": "21055215", "Score": "9", "Title": "Declare a function signature with decltype()", "LastEditorUserId": "2176945", "CommentCount": "5", "Body": "<p>Is it possible to declare a function <code>bar</code> to have the same signature as function <code>foo</code>?</p>\n<pre><code>int foo(int a)\n{\n    return 0; \n}\n\ndecltype(foo) bar\n{\n    return 1;\n} //imaginary syntax\n</code></pre>\n", "Tags": "<c++><c++11><definition><decltype>", "LastEditDate": "2014-01-27T13:46:04.127", "LastActivityDate": "2014-01-27T13:46:04.127", "PostTypeId": "1", "AnswerCount": "4", "OwnerUserId": "1073006"}, "21055394": {"CommentCount": "0", "Body": "<p>The first thing that comes into mind is that you need to name the parameters so no, you can't.</p>\n<p>The type of foo is:</p>\n<pre><code>int(int)\n</code></pre>\n<p>so any imaginary declaration syntax like:</p>\n<pre><code>decltype(foo) bar { //imaginary syntax\n  // can't access parameter\n  return 1;\n}\n</code></pre>\n<p>will have the problem that <code>bar</code> can't access parameters.</p>\n<p>So the best you can do is what @dyp suggests.</p>\n<p>One other thing you could do is to check if two functions have the same signature:</p>\n<pre><code>static_assert(std::is_same&lt;decltype(foo), decltype(bar)&gt;::value, \"Invalid bar signature\");\n</code></pre>\n", "CreationDate": "2014-01-10T22:12:41.210", "ParentId": "21055039", "Id": "21055394", "LastActivityDate": "2014-01-10T22:12:41.210", "PostTypeId": "2", "Score": "1", "OwnerUserId": "2805305"}, "21055408": {"CommentCount": "4", "Body": "<p>You can use variadic templates to define a function which has the same signature as <em>any</em> function:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint foo(char const *blah) { return 0; }\n\ntemplate&lt;typename... Args&gt;\nauto bar(Args ... args) -&gt; decltype(foo(args...))\n{\n    return 1; \n}\n\nint main() {\n    std::cout &lt;&lt; foo(\"test\") &lt;&lt; std::endl;\n    std::cout &lt;&lt; bar(\"test\") &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>This could also be modified slightly to pass \"foo\" as the first template argument, so that you could use the same \"bar\" with many different \"foo\"s:</p>\n<pre><code>template&lt;typename Func, typename... Args&gt;\nauto bar(Func f, Args ... args) -&gt; decltype(f(args...))\n{\n    return 1; \n}\n\nint baz(double d) { return 3; }\n\nint main() {\n    std::cout &lt;&lt; bar(&amp;foo, \"test\") &lt;&lt; std::endl;\n    std::cout &lt;&lt; bar(&amp;baz, 1.2) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n", "CreationDate": "2014-01-10T22:13:21.993", "ParentId": "21055039", "Id": "21055408", "LastActivityDate": "2014-01-10T22:13:21.993", "PostTypeId": "2", "Score": "2", "OwnerUserId": "36384"}, "21055215": {"CommentCount": "3", "Body": "<p>I think the same applies as for typedefs and aliases: You may use <code>decltype</code> to <em>declare</em> a function, but not to define it:</p>\n<pre><code>int foo();\n\ndecltype(foo) bar;\n\nint foo()\n{\n    return bar();\n}\n\nint bar() { return 0; }\n</code></pre>\n<p>is accepted by clang++3.5 and g++4.8.1</p>\n<hr>\n<p>[dcl.fct.def.general]/2 forbids (grammatically) the definition of a function w/o parentheses:</p>\n<blockquote>\n<p id=\"so_21055039_21055215_0\">The declarator in a function-definition shall have the form</p>\n<p id=\"so_21055039_21055215_1\">\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 <code>D1 (</code> <em>parameter-declaration-clause</em> <code>)</code> <em>cv-qualifier-seq<sub>opt</sub>\n  ref-qualifier<sub>opt</sub> exception-specification<sub>opt</sub> attribute-specifier-seq<sub>opt</sub> trailing-return-type<sub>opt</sub></em></p>\n<p id=\"so_21055039_21055215_2\">as described in 8.3.5.</p>\n</blockquote>\n</hr>", "CreationDate": "2014-01-10T22:00:09.690", "ParentId": "21055039", "Id": "21055215", "LastActivityDate": "2014-01-10T22:00:09.690", "PostTypeId": "2", "Score": "2", "OwnerUserId": "420683"}, "bq_ids": {"n4140": {"so_21055039_21055215_0": {"length": 4, "quality": 0.8, "section_id": 3263}}, "n3337": {"so_21055039_21055215_0": {"length": 4, "quality": 0.8, "section_id": 3135}}}});