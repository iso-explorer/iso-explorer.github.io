post_cb({"3902580": {"ParentId": "3902513", "PostTypeId": "2", "CommentCount": "7", "Body": "<blockquote>\n<p id=\"so_3902513_3902580_0\">Two empty base classes with a common base class must produce two instances of the base class at the same address.</p>\n</blockquote>\n<p>I don't think so. In fact a quick check with my copy of g++ indicates that I have two distinct A object addresses. I.e. your code above is not true. </p>\n<p>The fact is, we must have two A objects by the way your classes are written. If two objects share the same address they are not two different objects in any meaningful sense. Thus, it is required that distinct addresses exist for the instances of the A object.</p>\n<p>Suppose that A is defined like so:</p>\n<pre><code>class A\n{\n   static std::set&lt;A*&gt; instances;\n   A() { instances.insert(this); }\n   ~A() { instances.remove(this); }\n}\n</code></pre>\n<p>If both copies of A are allowed to share an address this code will not function as it was intended. I believe that it is situations like these where the decision is made that we ought to have distinct addresess for different copies of A. Of course, it's the wierdness of situations like this that make me avoid multiple inheritance.</p>\n", "OwnerUserId": "322806", "LastEditorDisplayName": "Roger Pate", "LastEditDate": "2010-10-11T11:24:11.033", "Id": "3902580", "Score": "2", "CreationDate": "2010-10-10T23:01:12.440", "LastActivityDate": "2010-10-11T11:24:11.033"}, "3902584": {"ParentId": "3902513", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>If you put that equality expression inside of an <code>assert()</code>, you'll find that it fails. The A sub-objects are at separate locations. That's the correct behavior without specifying <code>virtual</code>:</p>\n<pre><code>struct B : virtual A {};\nstruct C : virtual A {};\n</code></pre>\n<p>With <code>virtual</code>, D is already not a standard-layout class, by the second rule. This is the case in C++ '98, '03, and '0x.</p>\n<p>Edit to reflect comments:</p>\n<p>Edit again: Nevermind, this isn't sufficient.</p>\n<p><strike>The point of the standard-layout class definition is to specify something that can be used with other languages. Let's use C as an example. In the general case, the following C++ class</strike></p>\n<pre><code>struct X : public B{\n  B b;\n  int i;\n};\n</code></pre>\n<p>would be equivalent to this C struct:</p>\n<pre><code>struct X{\n  B base;\n  B b;\n  int i;\n};\n</code></pre>\n<p>If B were an empty class and the empty-base optimization were applied, X would be equivalent to this in C:</p>\n<pre><code>struct X{\n  B b;\n  int i;\n};\n</code></pre>\n<p>But, the C side of the interaction isn't going to know about that optimization. Instances of the C++ X and the C X would be incompatible. The restriction prevents this scenario.</p>\n", "OwnerUserId": "101225", "LastEditorUserId": "101225", "LastEditDate": "2010-10-11T03:30:35.313", "Id": "3902584", "Score": "3", "CreationDate": "2010-10-10T23:04:07.683", "LastActivityDate": "2010-10-11T03:30:35.313"}, "bq_ids": {"n4140": {"so_3902513_3902513_1": {"section_id": 5794, "quality": 0.9655172413793104, "length": 28}, "so_3902513_3902513_4": {"section_id": 6981, "quality": 0.8518518518518519, "length": 23}, "so_3902513_3902513_0": {"section_id": 5851, "quality": 0.8125, "length": 13}, "so_3902513_3902513_2": {"section_id": 5795, "quality": 0.8214285714285714, "length": 23}, "so_3902513_3902513_3": {"section_id": 5795, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_3902513_3902513_1": {"section_id": 5567, "quality": 0.9655172413793104, "length": 28}, "so_3902513_3902513_4": {"section_id": 6727, "quality": 0.8518518518518519, "length": 23}, "so_3902513_3902513_0": {"section_id": 5621, "quality": 0.8125, "length": 13}, "so_3902513_3902513_2": {"section_id": 5568, "quality": 0.8214285714285714, "length": 23}, "so_3902513_3902513_3": {"section_id": 5568, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_3902513_3902513_0": {"section_id": 7330, "quality": 0.8125, "length": 13}, "so_3902513_3902580_0": {"section_id": 7330, "quality": 0.5333333333333333, "length": 8}, "so_3902513_3902513_4": {"section_id": 8479, "quality": 0.8518518518518519, "length": 23}, "so_3902513_3902513_2": {"section_id": 7254, "quality": 0.8214285714285714, "length": 23}, "so_3902513_3902513_3": {"section_id": 7254, "quality": 0.8888888888888888, "length": 16}, "so_3902513_3902513_1": {"section_id": 7253, "quality": 0.9655172413793104, "length": 28}}}, "3902513": {"CommentCount": "0", "AcceptedAnswerId": "3904695", "PostTypeId": "1", "LastEditorUserId": "153285", "CreationDate": "2010-10-10T22:39:41.280", "LastActivityDate": "2010-10-11T22:53:57.223", "LastEditDate": "2010-10-11T22:53:57.223", "ViewCount": "591", "FavoriteCount": "2", "Title": "\"no base classes of the same type as the first non-static data member\"", "Id": "3902513", "Score": "5", "Body": "<p>I <a href=\"http://groups.google.com/group/comp.std.c++/browse_frm/thread/13281d18a2ac2aa3?hl=en\" rel=\"nofollow\">asked this a while ago</a> on comp.std.c++ and got no reply.</p>\n<p>I'm just going to quote my post there with little modification.</p>\n<hr>\n<p>Is the last requirement of standard-layout classes, 9/6, necessary or useful? </p>\n<p>A footnote explanation is provided:</p>\n<blockquote>\n<p id=\"so_3902513_3902513_0\">This ensures that two subobjects that\n  have the same class type and that\n  belong to the same most-derived object\n  are not allocated at the same address\n  (5.10).</p>\n</blockquote>\n<p>Taken alone, the footnote is incorrect. Two empty base classes with a\ncommon base class may produce two instances of the base class at the\nsame address.</p>\n<pre><code>struct A {};\nstruct B : A {};\nstruct C : A {};\nstruct D : B, C {};\n\nD d;\nstatic_cast&lt;A*&gt;(static_cast&lt;B*&gt;(&amp;d))\n   == static_cast&lt;A*&gt;(static_cast&lt;C*&gt;(&amp;d)); // allowed per 1.8/5\n</code></pre>\n<p>Taken in the context of 5.10, subobjects are only mentioned in the\ncomparison requirements of pointers to members. Base subobjects are\nirrelevant. Moreover, it doesn't make\nsense to give special status to comparison between a (scalar) pointer to a\nmember subobject and a pointer to a base subobject above that of\ncomparison between pointers to base subobjects.</p>\n<p>There wasn't such a restriction in C++03. Even if there is an ABI out there that requires every member to be\nallocated at a different address from any base of the same type, yet\nalready allows the empty base class optimization on the above code, I\nthink the ABI is buggy and the standard shouldn't capture this.</p>\n<p>The language <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2172.html#Revision-history\" rel=\"nofollow\">goes back to N2172</a>\nwhich suggests that multiple inheritance might cause trouble and need\nto be disallowed in standard-layout classes to ensure <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2172.html#ABI\" rel=\"nofollow\">ABI compatibility</a>;\nhowever, that was ultimately allowed and in that light the requirement\ndoesn't make sense. </p>\n<hr>\n<p>For reference, 1.8/5-6:</p>\n<blockquote>\n<p id=\"so_3902513_3902513_1\">5 Unless it is a bit-field (9.6), a\n  most derived object shall have a\n  non-zero size and shall occupy one or\n  more bytes of storage. Base class\n  subobjects may have zero size. An\n  object of trivially copyable or\n  standard-layout type (3.9) shall\n  occupy contiguous bytes of storage.</p>\n<p id=\"so_3902513_3902513_2\">6 Unless an object is a bit-field or a\n  base class subobject of zero size, the\n  address of that object is the address\n  of the first byte it occupies. Two\n  distinct objects that are neither\n  bit-fields nor base class subobjects\n  of zero size shall have distinct\n  addresses.</p>\n<p id=\"so_3902513_3902513_3\">(footnote) Under the \u201cas-if\u201d rule an implementation is allowed to store two objects at the same machine address or not store an object at all if the program cannot observe the difference.</p>\n</blockquote>\n<h2>Additional notes:</h2>\n<p>10.1/8 refers to the same mystery content at 5.10, but it's also just an informative note.</p>\n<blockquote>\n<p id=\"so_3902513_3902513_4\">[Note: \u2026 A base class subobject may be of zero size (Clause 9); however, two subobjects that have the same class type and that belong to the same most derived object must not be allocated at the same address (5.10). \u2014 end note ]</p>\n</blockquote>\n<p>GCC appears to guarantee that empty base subobjects of the same type are given unique addresses. <a href=\"http://ideone.com/Zy4qj\" rel=\"nofollow\">Example program and output.</a> This seems sufficient to guarantee that objects of a given type are uniquely identified by address. That would be above and beyond the guarantees of the C++ object model, \u00a71.8. Of course this is a good idea, but it doesn't seem required by the Standard. Likewise, the platform ABI can extend this guarantee to a class with the first member aliasing an empty base. The language sets minimum requirements for ABIs; an ABI can add a language feature, and other ABIs can follow suit, and the process of catch-up by the Standard is simply error-prone.</p>\n<p>My question is whether the given requirement accomplishes anything in the context of the Standard, not whether it is useful to the user in concert with other ABI guarantees. Evidence that such a unique-address guarantee was intended, and only omitted by accident, would also make the requirement more meaningful.</p>\n<hr>\n<p>To summarize the answer (or my conclusion, anyway):</p>\n<p>The requirement does not theoretically ensure anything, as it's possible anyway to ensure that all objects of a given type have different addresses. When the address of an empty base class subobject conflicts with another object (either another base or a member), the compiler may simply assign it an arbitrary location within the structure. As the standard-layout rules only describe the locations of data members (possibly inherited), the locations of empty bases are still unspecified and perhaps incompatible between similar standard-layout classes. (The locations of non-empty bases are still unspecified as far as I've noticed, and then it's not clear what is meant by \"first member\" in that case, but they must be consistent in any case.)</p>\n<p>In practice, the requirement allows implementations to continue using existing ABIs so long as they include the empty base class optimization. Existing compilers may disable the EBO when the requirement is violated, to avoid the address of the base coinciding with the address of the first member. If the Standard didn't restrict programs this way, libraries and programs would have to be recompiled with updated C++0x compilers\u2026 not worth it!</p>\n</hr></hr></hr>", "Tags": "<c++><struct><c++11>", "OwnerUserId": "153285", "AnswerCount": "3"}, "3904695": {"ParentId": "3902513", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>One of the \"special abilities\" of a standard-layout class, is that you can <code>reinterpret_cast</code> a pointer to a standard-layout class object to the type of its first data member, and thus obtain a pointer to the first data member. [Edit: 9.2/19] Further, a standard-layout class with non-static data members is permitted to have empty bases. As you no doubt know, most implementations put base class sub-objects at the start of complete sub-objects. This combination of restrictions effectively <em>mandates</em> that the empty-base-class optimization is applied to all bases of standard-layout classes.</p>\n<p>However, as other answers have explained, all base class sub-objects and member sub-objects that are part of the same complete object must be distinct, i.e., have different addresses if they are of the same type. Classes which violate your bullet point (that have a base class that is the same type as the first member) can't have the empty-base-class optimization fully applied, and thus can't be standard-layout classes if the base classes are positioned at the start of the complete object.</p>\n<p>So I'm pretty sure this is what it's getting at - it's trying to say \"if a class has base classes, and the empty-base-class optimization can't be applied, then the class is not standard-layout\".</p>\n<p>Edit: I'm being a bit slack with terminology here - it's possible to construct cases where the empty base class optimization can't be fully applied among the base classes (for example, in your <code>struct D</code>), but that doesn't matter because the base classes can still start at the beginning of the object, and conceptually \"overlay\" the data members, similar to a <code>union</code>. As you say, the base sub-objects get their addresses incremented if they (or a base) would otherwise overlay another base. While it's possible for the same thing to happen to bases of standard-layout cases (if they would overlap a data member of the same type), this would break existing ABIs, and add a special case for little gain.</p>\n<hr>\n<p>You're saying that this is \"forbidding\" a possibility - it's not really forbidding, from my point of view, it's just not granting \"standard-layout\" status to types that didn't have that originally anyway (classes with bases were not PODs in C++03). So it's not forbidding such types, it's just saying that they don't get the special standard-layout treatment, which they weren't guaranteed in the first place.</p>\n<hr>\n<p>Regarding my assertion that non-static data member subobjects and base subobjects are distinct, see if you find this convincing:</p>\n<ul>\n<li>5.9/2 (relational operators on pointers) makes it clear that no two data member subobjects (at least, with the same access specifier) have the same address as one another.</li>\n<li>5.3.1/1 (the unary operator*) says \"the expression to which it is applied shall be a pointer to an object type [snip] and the result is an lvalue referring to <em>the</em> object to which the expression points.\" (emphasis added) This implies that there is at most one object of a given type at a particular address, at a given time.</li>\n<li>1.8/2 \"A subobject can be a member subobject (9.2), a base class subobject (Clause 10), or an array element.\"... I think this implies that the categories are mutually exclusive (even if their storage overlaps). Other parts of the standard pretty strongly imply that base subobjects and member subobjects are distinct (e.g. 12.6.2).</li>\n<li>Steve M's citation of 10.1/4 \"For each distinct occurrence of a non-virtual base class in the class lattice of the most derived class, the most derived object (1.8) shall\ncontain a corresponding distinct base class subobject of that type.\" - I believe this means that different bases must be at different addresses, or else they would not be \"distinct\" objects - there would be no way to distinguish them during their common lifetime.</li>\n</ul>\n<p>I don't know how convincing this is, if you don't consider footnotes as normative or sufficiently indicating intention. For what it's worth, Stroustrup explains derived classes in \"The C++ Programming Language\" 12.2 in terms of member objects that have compiler-supported conversion from derived to base. Indeed, at the very end of this section, he explicitly says: \"Using a class as a base is equivalent to declaring an (unnamed) object of that class. Consequently, a class must be defined in order to be used as a base (section 5.7).\"</p>\n<hr>\n<p>Also: it seems that GCC 4.5 does <em>not</em> bump up the base class in this specific situation, even though it <em>does</em> bump up the bases where you have repeated base classes (as you showed):</p>\n<pre><code>#include &lt;assert.h&gt;\n#include &lt;iostream&gt;\n\nstruct E {};\nstruct D: E { E x ; };\n\nint main()\n{\n   D d;\n   std::cerr &lt;&lt; \"&amp;d: \" &lt;&lt; (void*)(&amp;d) &lt;&lt; \"\\n\";\n   std::cerr &lt;&lt; \"&amp;d.x: \" &lt;&lt; (void*)(&amp;(d.x)) &lt;&lt; \"\\n\";\n   std::cerr &lt;&lt; \"(E*)&amp;d: \" &lt;&lt; (void*)(E*)(&amp;d) &lt;&lt; \"\\n\";\n   assert(reinterpret_cast&lt;E *&gt;(&amp;d) == &amp;d.x); //standard-layout requirement\n}\n</code></pre>\n<p>Output (Linux x86-64, GCC 4.5.0): </p>\n<pre>\n&amp;d;: 0x7fffc76c9420\n&amp;d.x;: 0x7fffc76c9421\n(E*)&amp;d;: 0x7fffc76c9420\ntestLayout: testLayout.cpp:19: int main(): Assertion `reinterpret_cast(&amp;d;) == &amp;d.x;' failed.\nAborted\n</pre>\n</hr></hr></hr>", "OwnerUserId": "51305", "LastEditorUserId": "51305", "LastEditDate": "2010-10-11T11:01:32.270", "Id": "3904695", "Score": "3", "CreationDate": "2010-10-11T08:42:01.847", "LastActivityDate": "2010-10-11T11:01:32.270"}});