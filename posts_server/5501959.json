post_cb({"bq_ids": {"n4140": {"so_5501959_5502084_0": {"section_id": 5964, "quality": 0.8064516129032258, "length": 25}}, "n3337": {"so_5501959_5502084_0": {"section_id": 5733, "quality": 0.8064516129032258, "length": 25}}, "n4659": {"so_5501959_5502084_0": {"section_id": 7453, "quality": 0.6774193548387096, "length": 21}}}, "13212449": {"ParentId": "5501959", "CommentCount": "3", "Body": "<p>There is now a proposal to alleviate the need for <code>mutable</code> in lambda declarations: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3424.pdf\" rel=\"nofollow\">n3424</a></p>\n", "OwnerUserId": "182529", "PostTypeId": "2", "Id": "13212449", "Score": "3", "CreationDate": "2012-11-03T19:00:13.030", "LastActivityDate": "2012-11-03T19:00:13.030"}, "21228590": {"ParentId": "5501959", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>FWIW, Herb Sutter, a well-known member of the C++ standardization committee, provides a different answer to that question in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3424.pdf\">Lambda Correctness and Usability Issues</a>:</p>\n<blockquote>\n<p id=\"so_5501959_21228590_0\">Consider this straw man example, where the programmer captures a local variable by\n  value and tries to modify the\n  captured value (which is a member variable of the lambda object):</p>\n<pre><code>int val = 0;\nauto x = [=](item e)            // look ma, [=] means explicit copy\n            { use(e,++val); };  // error: count is const, need \u2018mutable\u2019\nauto y = [val](item e)          // darnit, I really can\u2019t get more explicit\n            { use(e,++val); };  // same error: count is const, need \u2018mutable\u2019\n</code></pre>\n<p id=\"so_5501959_21228590_1\">This feature appears to have been added out of a concern that the user\n  might not realize he got a copy, and in particular that since lambdas\n  are copyable he might be changing a different lambda\u2019s copy.</p>\n</blockquote>\n<p>His paper is about why this should be changed in C++14.  It is short, well written, worth reading if you want to know \"what's on [committee member] minds\" with regards to this particular feature.</p>\n", "OwnerUserId": "1353549", "LastEditorUserId": "1353549", "LastEditDate": "2014-05-05T09:54:26.987", "Id": "21228590", "Score": "17", "CreationDate": "2014-01-20T07:42:29.077", "LastActivityDate": "2014-05-05T09:54:26.987"}, "5502084": {"ParentId": "5501959", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>See <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2011/n3242.pdf\">this draft</a>, under 5.1.2 [expr.prim.lambda], subclause 5:</p>\n<blockquote>\n<p id=\"so_5501959_5502084_0\">The closure type for a lambda-expression has a public inline function call operator (13.5.4) whose parameters\n  and return type are described by the lambda-expression\u2019s parameter-declaration-clause and trailingreturn-\n  type respectively. <strong>This function call operator is declared const (9.3.1) if and only if the lambdaexpression\u2019s\n  parameter-declaration-clause is not followed by mutable.</strong></p>\n</blockquote>\n<p>Edit on litb's comment:\nMaybe they thought of capture-by-value so that outside changes to the variables aren't reflected inside the lambda? References work both ways, so that's my explanation. Don't know if it's any good though.  </p>\n<p>Edit on kizzx2's comment:\nThe most times when a lambda is to be used is as a functor for algorithms. The default <code>const</code>ness lets it be used in a constant environment, just like normal <code>const</code>-qualified functions can be used there, but non-<code>const</code>-qualified ones can't. Maybe they just thought to make it more intuitive for those cases, who know what goes on in their mind. :)</p>\n", "OwnerUserId": "500104", "LastEditorUserId": "500104", "LastEditDate": "2011-03-31T15:49:14.003", "Id": "5502084", "Score": "13", "CreationDate": "2011-03-31T15:10:33.320", "LastActivityDate": "2011-03-31T15:49:14.003"}, "5502247": {"ParentId": "5501959", "CommentCount": "6", "Body": "<blockquote>\n<p id=\"so_5501959_5502247_0\">I was under the impression that the whole point of capture-by-value is to allow the user to change the temporary -- otherwise I'm almost always better off using capture-by-reference, aren't I?</p>\n</blockquote>\n<p>The question is, is it \"almost\"? A frequent use-case appears to be to return or pass lambdas:</p>\n<pre><code>void registerCallback(std::function&lt;void()&gt; f) { /* ... */ }\n\nvoid doSomething() {\n  std::string name = receiveName();\n  registerCallback([name]{ /* do something with name */ });\n}\n</code></pre>\n<p>I think that <code>mutable</code> isn't a case of \"almost\". I consider \"capture-by-value\" like \"allow me to use its value after the captured entity dies\" rather than \"allow me to change a copy of it\". But perhaps this can be argued. </p>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "5502247", "Score": "28", "CreationDate": "2011-03-31T15:22:04.397", "LastActivityDate": "2011-03-31T15:22:04.397"}, "5503357": {"ParentId": "5501959", "CommentCount": "0", "Body": "<p>You need to think what is the <strong>closure type</strong> of your Lambda function. Every time you declare a Lambda expression, the compiler creates a closure type, which is nothing less than an unnamed class declaration with attributes (<em>environment</em> where the Lambda expression where declared) and the function call <code>::operator()</code> implemented. When you capture a variable using <strong>copy-by-value</strong>, the compiler will create a new <code>const</code> attribute in the closure type, so you can't change it inside the Lambda expression because it is a \"read-only\" attribute, that's the reason they call it a \"<strong>closure</strong>\", because in some way, you are closing your Lambda expression by copying the variables from upper scope into the Lambda scope. When you use the keyword <code>mutable</code>, the captured entity will became a <code>non-const</code> attribute of your closure type. This is what causes the changes done in the mutable variable captured by value, to not be propagated to upper scope, but keep inside the stateful Lambda.\nAlways try to imagine the resulting closure type of your Lambda expression, that helped me a lot, and I hope it can help you too.</p>\n", "OwnerUserId": "179372", "PostTypeId": "2", "Id": "5503357", "Score": "9", "CreationDate": "2011-03-31T16:48:46.307", "LastActivityDate": "2011-03-31T16:48:46.307"}, "5517202": {"ParentId": "5501959", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_5501959_5517202_0\">I was under the impression that the\n  whole point of capture-by-value is to\n  allow the user to change the temporary\n  -- otherwise I'm almost always better off using capture-by-reference, aren't\n  I?</p>\n</blockquote>\n<p><code>n</code> is <strong>not</strong> a temporary. n is a member of the lambda-function-object that you create with the lambda expression. The default expectation is that calling your lambda does not modify its state, therefore it is const to prevent you from accidentally modifying <code>n</code>.</p>\n", "OwnerUserId": "321013", "LastEditorUserId": "321013", "LastEditDate": "2016-07-11T10:07:45.703", "Id": "5517202", "Score": "7", "CreationDate": "2011-04-01T18:16:50.877", "LastActivityDate": "2016-07-11T10:07:45.703"}, "5503690": {"ParentId": "5501959", "CommentCount": "16", "Body": "<p>It requires <code>mutable</code> because by default, a function object should produce the same result every time it's called. This is the difference between an object orientated function and a function using a global variable, effectively.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "5503690", "Score": "167", "CreationDate": "2011-03-31T17:17:00.897", "LastActivityDate": "2011-03-31T17:17:00.897"}, "12343602": {"ParentId": "5501959", "CommentCount": "3", "Body": "<p>Your code is almost equivalent to this:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass unnamed1\n{\n    int&amp; n;\npublic:\n    unnamed1(int&amp; N) : n(N) {}\n\n    /* OK. Your this is const but you don't modify the \"n\" reference,\n    but the value pointed by it. You wouldn't be able to modify a reference\n    anyway even if your operator() was mutable. When you assign a reference\n    it will always point to the same var.\n    */\n    void operator()() const {n = 10;}\n};\n\nclass unnamed2\n{\n    int n;\npublic:\n    unnamed2(int N) : n(N) {}\n\n    /* OK. Your this pointer is not const (since your operator() is \"mutable\" instead of const).\n    So you can modify the \"n\" member. */\n    void operator()() {n = 20;}\n};\n\nclass unnamed3\n{\n    int n;\npublic:\n    unnamed3(int N) : n(N) {}\n\n    /* BAD. Your this is const so you can't modify the \"n\" member. */\n    void operator()() const {n = 10;}\n};\n\nint main()\n{\n    int n;\n    unnamed1 u1(n); u1();    // OK\n    unnamed2 u2(n); u2();    // OK\n    //unnamed3 u3(n); u3();  // Error\n    std::cout &lt;&lt; n &lt;&lt; \"\\n\";  // \"10\"\n}\n</code></pre>\n<p>So you could think of lambdas as generating a class with operator() that defaults to const unless you say that it is mutable.</p>\n<p>You can also think of all the variables captured inside [] (explicitly or implicitly) as members of that class: copies of the objects for [=] or references to the objects for [&amp;]. They are initialized when you declare your lambda as if there was a hidden constructor.</p>\n", "OwnerUserId": "1133524", "PostTypeId": "2", "Id": "12343602", "Score": "67", "CreationDate": "2012-09-09T22:43:28.747", "LastActivityDate": "2012-09-09T22:43:28.747"}, "5501959": {"CommentCount": "8", "AcceptedAnswerId": "5503690", "PostTypeId": "1", "LastEditorUserId": "34509", "CreationDate": "2011-03-31T15:02:52.243", "LastActivityDate": "2016-07-11T10:07:45.703", "LastEditDate": "2011-10-01T15:00:25.297", "ViewCount": "34020", "FavoriteCount": "46", "Title": "Why does C++0x's lambda require \"mutable\" keyword for capture-by-value, by default?", "Id": "5501959", "Score": "175", "Body": "<p>Short example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    int n;\n    [&amp;](){n = 10;}();             // OK\n    [=]() mutable {n = 20;}();    // OK\n    // [=](){n = 10;}();          // Error: a by-value capture cannot be modified in a non-mutable lambda\n    std::cout &lt;&lt; n &lt;&lt; \"\\n\";       // \"10\"\n}\n</code></pre>\n<p>The question: Why do we need the <code>mutable</code> keyword? It's quite different from traditional parameter passing to named functions. What's the rationale behind?</p>\n<p>I was under the impression that the whole point of capture-by-value is to allow the user to change the temporary -- otherwise I'm almost always better off using capture-by-reference, aren't I?</p>\n<p>Any enlightenments?</p>\n<p>(I'm using MSVC2010 by the way. AFAIK this should be standard)</p>\n", "Tags": "<c++><lambda><c++11>", "OwnerUserId": "111021", "AnswerCount": "8"}});