post_cb({"bq_ids": {"n4140": {"so_10335916_10336097_0": {"length": 7, "quality": 1.0, "section_id": 3945}}, "n3337": {"so_10335916_10336097_0": {"length": 7, "quality": 1.0, "section_id": 3804}}, "n4659": {"so_10335916_10336097_0": {"length": 7, "quality": 1.0, "section_id": 4833}}}, "10336276": {"Id": "10336276", "PostTypeId": "2", "Body": "<p>As an example as to why it is dangerous to forward an rvalue as an lvalue, see use case C of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2951.html\" rel=\"noreferrer\">N2951</a>.  This use case shows how doing so makes it easy to create dangling references.</p>\n", "LastActivityDate": "2012-04-26T15:12:11.773", "CommentCount": "0", "CreationDate": "2012-04-26T15:12:11.773", "ParentId": "10335916", "Score": "5", "OwnerUserId": "576911"}, "10336097": {"Id": "10336097", "PostTypeId": "2", "Body": "<p>It prevents strange things like <code>std::forward&lt;std::string&amp;&gt;(std::string {})</code>.</p>\n<p>The behaviour is mandated by \u00a720.2.3p2:</p>\n<blockquote>\n<p id=\"so_10335916_10336097_0\">if the second form is instantiated with an lvalue reference type, the program is ill-formed.</p>\n</blockquote>\n", "LastEditorUserId": "46642", "LastActivityDate": "2012-04-26T15:07:08.570", "Score": "5", "CreationDate": "2012-04-26T15:01:36.920", "ParentId": "10335916", "CommentCount": "0", "OwnerUserId": "46642", "LastEditDate": "2012-04-26T15:07:08.570"}, "10335916": {"ViewCount": "611", "Body": "<p>In move.h, there're two overloads of <code>forward</code></p>\n<pre><code>template&lt;typename _Tp&gt;\nconstexpr _Tp&amp;&amp;\nforward(typename std::remove_reference&lt;_Tp&gt;::type&amp; __t) noexcept\n{\n    return static_cast&lt;_Tp&amp;&amp;&gt;(__t);\n}\n\ntemplate&lt;typename _Tp&gt;\nconstexpr _Tp&amp;&amp;\nforward(typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp; __t) noexcept\n{\n    static_assert(\n        !std::is_lvalue_reference&lt;_Tp&gt;::value,\n        \"template argument substituting _Tp is an lvalue reference type\"\n    );\n    return static_cast&lt;_Tp&amp;&amp;&gt;(__t);\n}\n</code></pre>\n<p>I see the <code>static_assert</code> is to prevent accidently casting a rvalue to a lvalue. Can the rvalue version be implemented this way:</p>\n<pre><code>template&lt;typename _Tp&gt;\ntypename std::remove_reference&lt;_Tp&gt;::type&amp;&amp;         \nforward(typename std::remove_reference&lt;_Tp&gt;::type&amp;&amp; __t) noexcept\n{\n    return __t;\n}\n</code></pre>\n", "AcceptedAnswerId": "10336276", "Title": "c++11: why is static_assert in std::forward necessary?", "CreationDate": "2012-04-26T14:50:41.027", "Id": "10335916", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-04-26T17:20:43.733", "LastEditorUserId": "636019", "LastActivityDate": "2012-04-26T17:20:43.733", "Score": "4", "OwnerUserId": "264140", "Tags": "<c++><c++11><rvalue-reference>", "AnswerCount": "2"}});