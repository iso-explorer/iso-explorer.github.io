post_cb({"bq_ids": {"n4140": {"so_18849958_18850149_2": {"length": 26, "quality": 0.9629629629629629, "section_id": 480}, "so_18849958_18850149_1": {"length": 34, "quality": 0.9714285714285714, "section_id": 480}, "so_18849958_18850149_0": {"length": 64, "quality": 0.9696969696969697, "section_id": 480}}, "n3337": {"so_18849958_18850149_2": {"length": 26, "quality": 0.9629629629629629, "section_id": 471}, "so_18849958_18850149_1": {"length": 34, "quality": 0.9714285714285714, "section_id": 471}, "so_18849958_18850149_0": {"length": 61, "quality": 0.9242424242424242, "section_id": 471}}, "n4659": {"so_18849958_18850149_2": {"length": 17, "quality": 0.6296296296296297, "section_id": 502}, "so_18849958_18850149_1": {"length": 31, "quality": 0.8857142857142857, "section_id": 502}, "so_18849958_18850149_0": {"length": 64, "quality": 0.9696969696969697, "section_id": 502}}}, "18850149": {"Id": "18850149", "PostTypeId": "2", "Body": "<p>What you are seeing is called <em>copy elision</em> and is documented in 12.8.31.</p>\n<pre><code>A makeA(){\n    A a(3);\n    return a;\n}\n\nA b1(makeA()) ;\nA b2 = makeA();\n</code></pre>\n<p>Here, the <code>a</code> local variable in <code>makeA</code> is emplaced directly in the return value of <code>makeA</code>, and in turn the temporary return value of <code>makeA</code> is emplaced directly in the storage of <code>b1</code> and <code>b2</code>.  (two copy elisions in a row)</p>\n<pre><code>A b3 = A(3);\nA b4(A(3));\n</code></pre>\n<p>The temporary created with <code>A(3)</code> is constructed directly in <code>b3</code> and <code>b4</code>.  (one copy elision)</p>\n<blockquote>\n<p id=\"so_18849958_18850149_0\">When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class\n  object, even if the constructor selected for the copy/move operation and/or the destructor for the object\n  have side effects. In such cases, <strong>the implementation treats the source and target of the omitted copy/move\n  operation as simply two different ways of referring to the same object</strong>, and the destruction of that object\n  occurs at the later of the times when the two objects would have been destroyed without the optimization.122\n  This elision of copy/move operations, called <em>copy elision</em>, is permitted in the following circumstances (which\n  may be combined to eliminate multiple copies):</p>\n</blockquote>\n<p>This is the first part of the <code>b1</code> and <code>b2</code> case:</p>\n<blockquote id=\"so_18849958_18850149_1\">\n<ul>\n<li>in a return statement in a function with a class return type, when the expression is the name of a\n  non-volatile automatic object (other than a function or catch-clause parameter) with the same cv-\n  unqualified type as the function return type, the copy/move operation can be omitted by constructing\n  the automatic object directly into the function\u2019s return value</li>\n</ul>\n</blockquote>\n<p>This is the second part of the <code>b1</code> and <code>b2</code> case, as well as the whole part of the <code>b3</code> and <code>b4</code> case:</p>\n<blockquote id=\"so_18849958_18850149_2\">\n<ul>\n<li>when a temporary class object that has not been bound to a reference (12.2) would be copied/moved\n  to a class object with the same cv-unqualified type, the copy/move operation can be omitted by\n  constructing the temporary object directly into the target of the omitted copy/move</li>\n</ul>\n</blockquote>\n<p>There are also two other copy elision allowed cases to do with throwing and catching exceptions.</p>\n", "LastEditorUserId": "1131467", "LastActivityDate": "2013-09-17T13:03:20.447", "Score": "6", "CreationDate": "2013-09-17T12:40:50.680", "ParentId": "18849958", "CommentCount": "4", "OwnerUserId": "1131467", "LastEditDate": "2013-09-17T13:03:20.447"}, "18849958": {"ViewCount": "917", "Body": "<p>I have the following code snippet. Does anyone know why this move constructor is not called for all cases in the main function? Why does it compile anyway? Assignment operator is private? Here the link: <a href=\"http://ideone.com/bZPnyY\" rel=\"nofollow\">http://ideone.com/bZPnyY</a></p>\n<pre><code>#include &lt;iostream&gt;    \n#include &lt;vector&gt;\n\nclass A{\npublic:\n    A(int i){\n        std::cout &lt;&lt; \"Constructor \"&lt;&lt; i &lt;&lt;std::endl;\n        for(int l = 0; l&lt;i;l++){\n            vec.push_back(l);\n        }\n    };\n\n    A(A &amp;&amp; ref): vec(std::move(ref.vec))\n    {\n       std::cout &lt;&lt; \"Move constructor\"&lt;&lt;std::endl;\n    }\n\n    A &amp; operator=(A &amp;&amp; ref){\n       if(this != &amp;ref){\n            vec = std::move(ref.vec);\n       }\n       std::cout &lt;&lt; \"Move assignment\"&lt;&lt;std::endl;\n       return *this;\n\n    }\n\n    std::vector&lt;int&gt; vec;\n\nprivate:\n    A(const A &amp; ref);\n    A(A &amp; ref);\n    A &amp; operator=(A &amp; ref);\n};\n\n\nA makeA(){\n    A a(3);\n    return a;\n}\n\nint main(){\n    A b1(makeA()) ;\n    A b2 = makeA();\n    A b3 = A(3);\n    A b4(A(3));\n    std::cout &lt;&lt; b4.vec[2] &lt;&lt; std::endl;\n};\n</code></pre>\n<p><strong>Output:</strong><br>\nConstructor 3<br>\nConstructor 3<br>\nConstructor 3<br>\nConstructor 3<br>\n2  </br></br></br></br></br></p>\n<p>Some Additions to the responses:\nWhen I add</p>\n<pre><code> std::pair&lt;int,A&gt; a(3,A(3));\n</code></pre>\n<p>Then the move constructor gets called (so no NRVO hopefully)</p>\n", "AcceptedAnswerId": "18850149", "Title": "Why is this move constructor not working", "CreationDate": "2013-09-17T12:32:29.630", "Id": "18849958", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-09-17T12:56:55.160", "LastEditorUserId": "293195", "LastActivityDate": "2013-09-17T13:03:20.447", "Score": "2", "OwnerUserId": "293195", "Tags": "<c++><c++11><move><copy-constructor><move-semantics>", "AnswerCount": "2"}, "18850423": {"Id": "18850423", "PostTypeId": "2", "Body": "<p>Nowhere does copy assignment operator even come in to play, don't confuse the presence of <code>=</code> token with assignment (that would be <code>b1 = b2;</code>, for instance).</p>\n<pre><code>A b1(makeA()) ;  // direct initialization\nA b2 = makeA();  // copy-initialization\nA b3 = A(3);     // copy-initialization\nA b4(A(3));      // direct initialization\n</code></pre>\n<p>While copy-initiliazation to be well formed requires either copy- or move-constructor to be accessible, the compiler is free to elide it and initialize the object directly. There are subtle differences as to which constructor is eligible for each one, read more about this <a href=\"https://stackoverflow.com/questions/1051379/is-there-a-difference-in-c-between-copy-initialization-and-direct-initializati\">here</a>.</p>\n<p>If you're using GCC, try compiling with <code>-fno-elide-constructors</code> and see the difference.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-09-17T12:52:39.083", "Score": "1", "CreationDate": "2013-09-17T12:52:39.083", "ParentId": "18849958", "CommentCount": "7", "OwnerUserId": "947836", "LastEditDate": "2017-05-23T12:05:12.420"}});