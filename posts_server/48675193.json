post_cb({"bq_ids": {"n4140": {"so_48675193_48675822_0": {"length": 4, "quality": 1.0, "section_id": 6151}}, "n4659": {"so_48675193_48675822_0": {"length": 4, "quality": 1.0, "section_id": 7648}}}, "48675822": {"PostTypeId": "2", "Body": "<p>From C++17 (N4659) [expr.eq]/2 (Equality operators):</p>\n<blockquote>\n<p id=\"so_48675193_48675822_0\">Comparing pointers is defined as follows:</p>\n<ul>\n<li>If one pointer represents the address of a complete object, and another pointer represents the address one past the last element of a different complete object, the result of the comparison is unspecified.</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>This means comparison of <code>&amp;a</code> and <code>&amp;b+1</code> is <em>unspecified</em>. (It is not undefined, as claimed in other answers and comments; in fact equality comparison for pointers never undefined behaviour in C++).</p>\n<p>So your code may observe either <code>true</code> or <code>false</code> as the result of the comparison; and the optimizer could , at its whim, insert either result instead of actually doing any comparison at runtime.</p>\n<hr>\n<p><em>Historical note:</em> This change came from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1652\" rel=\"nofollow noreferrer\">CWG Defect 1652</a>, filed against C++11 and granted Defect status, meaning it applies retroactively.  The original C++11 text said that pointers should compare equal \"if they represent the same address\" , but this was changed both because it hinders optimization, and because equality comparison is allowed in <code>constexpr</code> which can't do a runtime address check obviously.</p>\n<p>I believe g++ always performed this optimization in defiance of the apparent C++11 requirement to not perform it. </p>\n</hr>", "LastActivityDate": "2018-02-08T01:08:15.133", "LastEditorUserId": "1505939", "Score": "1", "Id": "48675822", "CreationDate": "2018-02-08T00:57:34.433", "ParentId": "48675193", "CommentCount": "1", "OwnerUserId": "1505939", "LastEditDate": "2018-02-08T01:08:15.133"}, "48675468": {"PostTypeId": "2", "Body": "<p>This result has nothing to do with how the stack is laid out and everything to do with the fact that the result of comparison between unrelated pointers is unspecified.</p>\n<p>Lets look at the assembly GCC generates for just the first little bit of your <code>result</code> function:</p>\n<pre><code>.LC0:\n  .string \"false\"\n.LC1:\n  .string \", \"\n.LC2:\n  .string \"a: \"\n.LC3:\n  .string \" b: \"\nresult(int, int):\n  push rbx\n  mov edx, 5\n  sub rsp, 32\n  mov DWORD PTR [rsp+12], edi\n  mov DWORD PTR [rsp+8], esi\n  mov edi, OFFSET FLAT:std::cout\n  mov esi, OFFSET FLAT:.LC0\n  call std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp; std::__ostream_insert&lt;char, std::char_traits&lt;char&gt; &gt;(std::basic_ostream&lt;char, std::char_traits&lt;char&gt; &gt;&amp;, char const*, long)\n</code></pre>\n<p>As you can see, there is no branch at all.  A pointer to the string <code>\"false\"</code> is loaded into <code>esi</code> and used as the argument to <code>std::__ostream_insert</code> unconditionally.  Since the behavior of the pointer comparison is not specified by the language, the compiler has simply assumed that the <code>true</code> case can never happen and removed it entirely.</p>\n", "LastActivityDate": "2018-02-08T01:09:47.657", "LastEditorUserId": "4151599", "Score": "1", "Id": "48675468", "CreationDate": "2018-02-08T00:17:05.460", "ParentId": "48675193", "CommentCount": "2", "OwnerUserId": "4151599", "LastEditDate": "2018-02-08T01:09:47.657"}, "48675193": {"ViewCount": "47", "LastEditDate": "2018-02-08T00:06:53.097", "AcceptedAnswerId": "48675822", "Title": "Stack pointer comparison anomaly when optimization enabled", "CreationDate": "2018-02-07T23:43:01.043", "LastActivityDate": "2018-02-08T01:09:47.657", "CommentCount": "8", "Body": "<p>This is doing my head in! I was doing some experiments with the stack during function calls, and I came across this little anomaly. Compiler is GCC 4.9.2, and -O1, -O2, or -O3 optimization flags. The problem is not present when  optimizations are disabled (-O0). The result is the same whether compiling under C++98, C++11 or C++14.</p>\n<p>In the example below, I assume that the CDECL calling convention is used for the call to result(), so args should get pushed on the stack from right to left.</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid result(int a, int b) {\n    int* pA = &amp;a;\n    int* pB = &amp;b;\n\n    // pA should be equal to pB + sizeof(int) bytes, why does this report \"false\" \n    // when optimizations are on?\n    std::cout &lt;&lt; (pA == pB + 1 ? \"true\" : \"false\") &lt;&lt; '\\n';\n\n    // this appears to be true if we dump the pointer addresses.\n    std::cout &lt;&lt; pA &lt;&lt; \", \" &lt;&lt; pB + 1 &lt;&lt; '\\n';\n\n    // and still holds water when getting values through indirection.\n    std::cout &lt;&lt; \"a: \" &lt;&lt; *(pB + 1) &lt;&lt; \" b: \" &lt;&lt; *pB &lt;&lt; '\\n';\n}\n\nint main(int argc, char** argv)\n{\n    result(10, 20);\n    return 0;\n}\n</code></pre>\n<p>Sample output with optimizations enabled:</p>\n<pre><code>false // why?\n0x704eca3c088c, 0x704eca3c088c // clearly they're equal\na: 10 b: 20 // and point to the correct arguments on the stack\n</code></pre>\n<p>Sample output with optimizations disabled:</p>\n<pre><code>true\n0x7e5bd5f34fdc, 0x7e5bd5f34fdc\na: 10 b: 20\n</code></pre>\n<p>What about the compiler optimizations would cause a stack pointer comparison to fail, when their equality can be compared visually and found to be true, optimizations or no?</p>\n<p>Edit: I believe this question differs from the suggested duplicate (<a href=\"https://stackoverflow.com/questions/4909766/is-it-unspecified-behavior-to-compare-pointers-to-different-arrays-for-equality\">Is it unspecified behavior to compare pointers to different arrays for equality?</a>) as stacks are traditionally implemented as a contiguous array (obviously with exceptions -- case in point), and the proposed duplicate gives an example of two distinct arrays.</p>\n", "PostTypeId": "1", "LastEditorUserId": "6744877", "Id": "48675193", "Score": "-2", "OwnerUserId": "6744877", "Tags": "<c++><optimization>", "AnswerCount": "2"}});