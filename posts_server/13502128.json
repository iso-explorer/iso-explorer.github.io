post_cb({"13502206": {"ParentId": "13502128", "CommentCount": "0", "Body": "<p>The standard specifies the sorted search algorithms (<code>std::lower_bound()</code>, <code>std::upper_bound()</code>, and <code>std::binary_search()</code>) to work in linear time for forward and binary iterators. For random access the time is logarithmic.</p>\n<p>Note that the number of <code>comparisons</code> is restricted to be logarithmic, however.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "13502206", "Score": "2", "CreationDate": "2012-11-21T21:18:08.173", "LastActivityDate": "2012-11-21T21:18:08.173"}, "13502128": {"CommentCount": "3", "AcceptedAnswerId": "13502170", "PostTypeId": "1", "LastEditorUserId": "1012936", "CreationDate": "2012-11-21T21:10:15.547", "LastActivityDate": "2013-04-26T17:08:05.547", "LastEditDate": "2012-11-21T21:23:47.117", "ViewCount": "753", "FavoriteCount": "2", "Title": "Why arguments of std::binary_search are forward iterators?", "Id": "13502128", "Score": "17", "Body": "<p>While perusing <a href=\"http://en.cppreference.com/w/cpp/algorithm/binary_search\">http://en.cppreference.com/w/cpp/algorithm/binary_search</a> I've noticed it takes forward iterator as an argument. Now I'm confused, since I thought it would rather be an random access iterator, so the binary search will be actually binary.</p>\n<p>To satisfy my curiosity, I've written a little program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;forward_list&gt;\n#include &lt;list&gt;\n#include &lt;deque&gt;\n#include &lt;algorithm&gt;\n#include &lt;chrono&gt;\n#include &lt;random&gt;\n\nint main()\n{\n    std::uniform_int_distribution&lt;int&gt; uintdistr(-4000000, 4000000);\n    std::mt19937 twister(std::chrono::high_resolution_clock::to_time_t(std::chrono::high_resolution_clock::now()));\n    size_t arr[] = { 200000, 400000, 800000, 1600000, 3200000, 6400000, 12800000 };\n    for(auto size : arr)\n    {\n        std::list&lt;int&gt; my_list;\n        for(size_t i = 0; i &lt; size; i++)\n            my_list.push_front(uintdistr(twister));\n        std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; start, end;\n        my_list.sort(); //fixed\n        start = std::chrono::high_resolution_clock::now();\n\n        std::binary_search(my_list.begin(), my_list.end(), 1252525);\n\n        end = std::chrono::high_resolution_clock::now();\n        long long unsigned elapsed_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end-start).count();\n        std::cout &lt;&lt; \"Test finished in \" &lt;&lt; elapsed_time &lt;&lt; \"\\n\";\n    }\n}\n</code></pre>\n<p>Compiling it with gcc 4.7.0 and running</p>\n<pre><code>g++ -std=c++11 test.cpp\n</code></pre>\n<p>provides following results on my machine:</p>\n<pre><code>Test finished in 0\nTest finished in 15625\nTest finished in 15625\nTest finished in 46875\nTest finished in 93750\nTest finished in 171875\nTest finished in 312500\n</code></pre>\n<p>So it looks like it doesn't actually do a binary search on a forward list.\nNow my questions are: </p>\n<p>Why such a confusing name?</p>\n<p>Why does the code like this allowed?</p>\n<p>Why does the reference says it's \"Logarithmic in the distance between first and last\"?</p>\n<p>What does the standard has to say about it?</p>\n<p>EDIT: Now the code sorts the list before search - stupid mistake, now the results are:</p>\n<pre><code>Test finished in 46875\nTest finished in 109375\nTest finished in 265625\nTest finished in 546875\nTest finished in 1156250\nTest finished in 2625000\nTest finished in 6375000\n</code></pre>\n<p>And of course still not logarithmic ;)</p>\n", "Tags": "<c++>", "OwnerUserId": "1012936", "AnswerCount": "3"}, "13502170": {"ParentId": "13502128", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The docs of the original SGI STL implementation, from which the standard was derived, <a href=\"http://www.sgi.com/tech/stl/binary_search.html\" rel=\"nofollow\">states that</a></p>\n<blockquote>\n<p id=\"so_13502128_13502170_0\">The number of comparisons is logarithmic: at most log(last - first) + 2. If <code>ForwardIterator</code> is a Random Access Iterator then the number of steps through the range is also logarithmic; otherwise, the number of steps is proportional to last - first.</p>\n</blockquote>\n<p>That is, the number of <em>comparisons</em> is always logarithmic, while the number of advancements, which are affected by the lack of random-accessibility, can be linear. In practice, <a href=\"http://en.cppreference.com/w/cpp/iterator/advance\" rel=\"nofollow\"><code>stl::advance</code></a> is probably used, for which the complexity is constant if the iterator is random access, linear otherwise.</p>\n<p>A binary search with a linear number of iterator advancements, but with a logarithmic number of comparisons makes sense if a comparison is very expensive. If, for example, you have a sorted linked-list of complicated objects, which require disk- or network-access to compare, you're probably much better off with a binary search than with a linear one.</p>\n", "OwnerUserId": "1071136", "LastEditorDisplayName": "user283145", "LastEditDate": "2013-04-26T17:08:05.547", "Id": "13502170", "Score": "16", "CreationDate": "2012-11-21T21:14:34.203", "LastActivityDate": "2013-04-26T17:08:05.547"}, "bq_ids": {"n4140": {"so_13502128_13502213_1": {"section_id": 1421, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_13502128_13502213_1": {"section_id": 1415, "quality": 0.8888888888888888, "length": 8}, "so_13502128_13502213_0": {"section_id": 1427, "quality": 0.8, "length": 4}}, "n4659": {"so_13502128_13502213_1": {"section_id": 1541, "quality": 0.8888888888888888, "length": 8}}}, "13502213": {"ParentId": "13502128", "CommentCount": "0", "Body": "<p>Contrary to what <a href=\"http://en.cppreference.com/w/cpp/algorithm/lower_bound\">websites may say</a> (e.g. \"logarithmic in <code>distance(first, last)</code>\"), the standard actually only speaks about the <em>comparisons</em> (e.g. 25.4.3.1, <code>lower_bound</code>):</p>\n<blockquote>\n<p id=\"so_13502128_13502213_0\">Complexity: At most <code>log2(last \u2212 first) + O(1)</code> comparisons</p>\n</blockquote>\n<p>The incrementing of the iterator is <em>not</em> included in the complexity! Note though that the standard library requires all iterator increments to have amortized constant complexity, so there'll be a cost of order O(N) coming from incrementing the iterators (but presumably this has a very small leading factor). In parti\u00adcu\u00adlar (25.4.3):</p>\n<blockquote>\n<p id=\"so_13502128_13502213_1\">For non-random access iterators [the algorithms] execute a linear number of steps.</p>\n</blockquote>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "13502213", "Score": "6", "CreationDate": "2012-11-21T21:18:37.100", "LastActivityDate": "2012-11-21T21:18:37.100"}});