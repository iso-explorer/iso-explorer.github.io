post_cb({"14626033": {"CommentCount": "1", "CreationDate": "2013-01-31T12:40:37.047", "PostTypeId": "1", "AcceptedAnswerId": "14628304", "LastEditorUserId": "238902", "LastActivityDate": "2017-05-20T09:21:22.320", "LastEditDate": "2013-01-31T12:42:28.207", "ViewCount": "6109", "FavoriteCount": "2", "Title": "implicit instantiation of undefined template 'class'", "Id": "14626033", "Score": "5", "Body": "<p>When trying to offer functions for const and non-const template arguments in my library I came across a strange problem. The following source code is a minimal example phenomenon:</p>\n<pre><code>#include &lt;iostream&gt;\n\n\ntemplate&lt;typename some_type&gt;\nstruct some_meta_class;\n\ntemplate&lt;&gt;\nstruct some_meta_class&lt;int&gt;\n{\n    typedef void type;\n};\n\n\n\ntemplate&lt;typename some_type&gt;\nstruct return_type\n{\n    typedef typename some_meta_class&lt; some_type &gt;::type test;\n\n    typedef void type;\n};\n\n\n\ntemplate&lt;typename type&gt;\ntypename return_type&lt;type&gt;::type foo( type &amp; in )\n{\n    std::cout &lt;&lt; \"non-const\" &lt;&lt; std::endl;\n}\n\ntemplate&lt;typename type&gt;\nvoid foo( type const &amp; in )\n{\n    std::cout &lt;&lt; \"const\" &lt;&lt; std::endl;\n}\n\n\nint main()\n{\n    int i;\n\n    int const &amp; ciref = i;\n    foo(ciref);\n}\n</code></pre>\n<p>I tried to implement a non-const version and a const version for foo but unfortunately this code won't compile on CLANG 3.0 and gcc 4.6.3.</p>\n<blockquote>\n<p id=\"so_14626033_14626033_0\">main.cpp:18:22: error: implicit instantiation of undefined template\n  'some_meta_class'</p>\n</blockquote>\n<p>So for some reason the compiler wants to use the non-const version of foo for a const int-reference. This obviously leads to the error above because there is no implementation for some_meta_class. The strange thing is, that if you do one of the following changes, the code compile well and works:</p>\n<ul>\n<li>uncomment/remove the non-const version</li>\n<li>uncomemnt/remove the typedef of return_type::test</li>\n</ul>\n<p>This example is of course minimalistic and pure academic. In my library I came across this problem because the const and non-const version return different types. I managed this problem by using a helper class which is partially specialized.</p>\n<p>But why does the example above result in such strange behaviour? Why doesn't the compiler want to use the non-const version where the const version is valid and and matches better?</p>\n", "Tags": "<c++><function><templates><const><overloading>", "OwnerUserId": "2029007", "AnswerCount": "1"}, "14628304": {"ParentId": "14626033", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The reason is the way function call resolution is performed, together with template argument deduction and substitution. </p>\n<ol>\n<li><p>Firstly, <strong>name lookup</strong> is performed. This gives you two functions with a matching name <code>foo()</code>. </p></li>\n<li><p>Secondly, <strong>type deduction</strong> is performed: for <em>each</em> of the template functions with a matching name, the compiler tries to deduce the function template arguments which would yield a viable match. The error you get happens in this phase.</p></li>\n<li><p>Thirdly, <strong>overload resolution</strong> enters the game. This is only <em>after</em> type deduction has been performed and the signatures of the viable functions for resolving the call have been determined, which makes sense: the compiler can meaningfully resolve your function call only after it has found out the exact signature of all the candidates.</p></li>\n</ol>\n<p>The fact that you get an error related to the non-const overload is not because the compiler chooses it as a most viable candidate for resolving the call (that would be step 3), but because the compiler produces an error while instantiating its return type to determine its signature, during step 2.</p>\n<p>It is <strong>not entirely obvious</strong> why this results in an error though, because one might expect that <strong>SFINAE</strong> applies (Substitution Failure Is Not An Error). To clarify this, we might consider a simpler example:</p>\n<pre><code>template&lt;typename T&gt; struct X { };\n\ntemplate&lt;typename T&gt; typename X&lt;T&gt;::type f(T&amp;) { }  // 1\ntemplate&lt;typename T&gt; void f(T const&amp;) { }           // 2\n\nint main()\n{\n    int const i = 0;\n    f(i); // Selects overload 2\n}\n</code></pre>\n<p>In this example, SFINAE applies: during step 2, the compiler will deduce <code>T</code> for each of the two overloads above, and try to determine their signatures. In case of overload 1, this results in a <em>substitution  failure</em>: <code>X&lt;const int&gt;</code> does not define any <code>type</code> (no <code>typedef</code> in <code>X</code>). However, due to SFINAE, the compiler simply <strong>discards it</strong> and finds that overload 2 is a viable match. Thus, it picks it.</p>\n<p>Let's now change the example slightly in a way that mirrors <em>your</em> example:</p>\n<pre><code>template&lt;typename T&gt; struct X { };\n\ntemplate&lt;typename Y&gt;\nstruct R { typedef typename X&lt;Y&gt;::type type; };\n\n// Notice the small change from X&lt;T&gt; into R&lt;T&gt;!\ntemplate&lt;typename T&gt; typename R&lt;T&gt;::type f(T&amp;) { }  // 1\ntemplate&lt;typename T&gt; void f(T const&amp;) { }           // 2\n\nint main()\n{\n    int const i = 0;\n    f(i); // ERROR! Cannot instantiate R&lt;int const&gt;\n}\n</code></pre>\n<p>What has changed is that overload 1 no longer returns <code>X&lt;T&gt;::type</code>, but rather <code>R&lt;T&gt;::type</code>. This is in turn the <strong>same</strong> as <code>X&lt;T&gt;::type</code> because of the <code>typedef</code> declaration in <code>R</code>, so one might expect it to yield the same result. However, in this case you get a compilation error. Why?</p>\n<p>The Standard has the answer (Paragraph 14.8.3/8):</p>\n<blockquote>\n<p id=\"so_14626033_14628304_0\">If a substitution results in an invalid type or expression, type deduction fails. An invalid type or expression is one that would be ill-formed if written using the substituted arguments. [...] Only invalid types and expressions in the <strong>immediate context</strong> of the function type and its template parameter types can result in a deduction failure.</p>\n</blockquote>\n<p>Clearly, the second example (as well as yours) generates an error in a <strong>nested context</strong>, so SFINAE does not apply. I believe this answers your question.</p>\n<p>By the way, it is interesting to notice, that this <strong>has changed since C++03</strong>, which more generally stated (Paragraph 14.8.2/2):</p>\n<blockquote>\n<p id=\"so_14626033_14628304_1\">[...] If a substitution in a template parameter or in the function type of the function template results in an invalid type, type deduction fails. [...]</p>\n</blockquote>\n<p>If you are curious about the reasons <em>why</em> things have changed, <strong><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2634.html\" rel=\"nofollow noreferrer\">this paper</a></strong> might give you an idea.</p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "5256940", "LastEditDate": "2017-05-20T09:21:22.320", "Id": "14628304", "Score": "15", "CreationDate": "2013-01-31T14:37:17.767", "LastActivityDate": "2017-05-20T09:21:22.320"}, "bq_ids": {"n4140": {"so_14626033_14628304_0": {"section_id": 300, "quality": 0.9705882352941176, "length": 33}, "so_14626033_14628304_1": {"section_id": 294, "quality": 0.7692307692307693, "length": 10}}, "n3337": {"so_14626033_14628304_0": {"section_id": 291, "quality": 0.9705882352941176, "length": 33}, "so_14626033_14628304_1": {"section_id": 285, "quality": 0.7692307692307693, "length": 10}}, "n4659": {"so_14626033_14628304_0": {"section_id": 307, "quality": 0.9705882352941176, "length": 33}, "so_14626033_14628304_1": {"section_id": 301, "quality": 0.7692307692307693, "length": 10}}}});