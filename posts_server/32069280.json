post_cb({"32069494": {"ParentId": "32069280", "CommentCount": "2", "Body": "<p>This is well defined, both syntactically and semantically.</p>\n<p>[expr.sub]/1 (N3337):</p>\n<blockquote>\n<p id=\"so_32069280_32069494_0\">The expression <code>E1[E2]</code> is identical (by definition) to <code>*((E1)+(E2))</code>.</p>\n</blockquote>\n<p>So your expression is the same as <code>*(q-1) = 41;</code>, so is syntactically valid.</p>\n<p>[expr.add]/5 (N3337)</p>\n<blockquote>\n<p id=\"so_32069280_32069494_1\">When an expression that has integral type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and original array elements equals the integral expression.</p>\n</blockquote>\n<p>Since <code>q</code> points to an element of an array object of a valid size for your integral expression, it is semantically valid.</p>\n", "OwnerUserId": "496161", "PostTypeId": "2", "Id": "32069494", "Score": "42", "CreationDate": "2015-08-18T10:10:49.843", "LastActivityDate": "2015-08-18T10:10:49.843"}, "32069280": {"CommentCount": "5", "AcceptedAnswerId": "32069494", "PostTypeId": "1", "LastEditorUserId": "1014587", "CreationDate": "2015-08-18T10:01:23.157", "LastActivityDate": "2016-10-23T16:47:06.620", "LastEditDate": "2015-08-18T18:54:23.597", "ViewCount": "2193", "FavoriteCount": "3", "Title": "Is negative index for operator[] well defined?", "Id": "32069280", "Score": "40", "Body": "<p>I know it would be very bad coding-style, but the following code runs perfectly on my machine. But is the behavior well defined? Portable?</p>\n<pre><code>int main()\n{\n    int *p = new int[3];\n    int *q = &amp;p[2];\n    q[-1] = 41;\n    std::cout &lt;&lt; p[1];\n    delete[] p;\n}\n</code></pre>\n", "Tags": "<c++><operator-overloading><language-lawyer>", "OwnerUserId": "1235183", "AnswerCount": "6"}, "32069354": {"ParentId": "32069280", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It's absolutely fine so long as you don't attempt to dereference a pointer outside the bounds of the array pointed to by <code>p</code>. </p>\n<p>Also, you can set the pointer q to any element of the array, and in addition, to one element past the array.  (Don't attempt to dereference an element on past the end of the seat though.)</p>\n<p>Don't forget to <code>delete[] p;</code> at the end of your function.</p>\n", "OwnerUserId": "2380830", "LastEditorUserId": "2380830", "LastEditDate": "2016-10-23T16:47:06.620", "Id": "32069354", "Score": "3", "CreationDate": "2015-08-18T10:04:50.353", "LastActivityDate": "2016-10-23T16:47:06.620"}, "32069343": {"ParentId": "32069280", "CommentCount": "0", "Body": "<p>It is perfectly safe and portable. You are just using pointer arithmetic to address the memory allocated by the <code>new</code> operator.</p>\n<p>Your code is equivalent to:</p>\n<pre><code>int* p = new int[3];\nint* q = p + 2;\n*(q-1) = 41;\n</code></pre>\n", "OwnerUserId": "2508150", "PostTypeId": "2", "Id": "32069343", "Score": "2", "CreationDate": "2015-08-18T10:04:27.513", "LastActivityDate": "2015-08-18T10:04:27.513"}, "32069350": {"ParentId": "32069280", "CommentCount": "3", "Body": "<p>Yes, it is well defined. Built-in <code>operator[]</code> is defined in terms of pointer arithmetic. This:</p>\n<pre><code>p[N]\n</code></pre>\n<p>where <code>p</code> is a pointer and <code>N</code> is an integer, is equivalent to this:</p>\n<pre><code>*(p + N)\n</code></pre>\n<p>An interesting upshot of this is that this:</p>\n<pre><code>N[p]\n</code></pre>\n<p>is also equivalent, because addition is commutative.</p>\n", "OwnerUserId": "440119", "PostTypeId": "2", "Id": "32069350", "Score": "18", "CreationDate": "2015-08-18T10:04:44.083", "LastActivityDate": "2015-08-18T10:04:44.083"}, "32069345": {"ParentId": "32069280", "CommentCount": "0", "Body": "<p>The index operator <code>x[idx]</code> equals <code>(*(x +idx))</code> and yes <code>idx</code> might be negative. However, you have to ensure that the dereferenced pointer was pointing to a valid memory address.</p>\n<p>Notice that we can rewrite it in many ways (just like algebra).</p>\n<pre><code>x[idx] = (*(x +idx)) = (*(idx + x)) = idx[x]\n</code></pre>\n", "OwnerUserId": "2548655", "PostTypeId": "2", "Id": "32069345", "Score": "3", "CreationDate": "2015-08-18T10:04:35.477", "LastActivityDate": "2015-08-18T10:04:35.477"}, "bq_ids": {"n4140": {"so_32069280_32069494_0": {"section_id": 5986, "quality": 0.8333333333333334, "length": 5}, "so_32069280_32069562_0": {"section_id": 5986, "quality": 0.8823529411764706, "length": 30}, "so_32069280_32069494_1": {"section_id": 6142, "quality": 1.0, "length": 36}}, "n3337": {"so_32069280_32069494_0": {"section_id": 5754, "quality": 0.8333333333333334, "length": 5}, "so_32069280_32069562_0": {"section_id": 5754, "quality": 0.8529411764705882, "length": 29}, "so_32069280_32069494_1": {"section_id": 5906, "quality": 1.0, "length": 36}}, "n4659": {"so_32069280_32069494_0": {"section_id": 7486, "quality": 0.8333333333333334, "length": 5}, "so_32069280_32069562_0": {"section_id": 7486, "quality": 0.8235294117647058, "length": 28}}}, "32069562": {"ParentId": "32069280", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>According to the C++ Standard (5.2.1 Subscripting)</p>\n<blockquote>\n<p id=\"so_32069280_32069562_0\">1 A postfix expression followed by an expression in square brackets is\n  a postfix expression. One of the expressions shall have the type\n  \u201carray of T\u201d or \u201cpointer to T\u201d and the other shall have unscoped\n  enumeration or <strong>integral type</strong>. The result is of type \u201cT.\u201d The type\n  \u201cT\u201d shall be a completely-defined object type.65 The expression E1[E2]\n  is identical (by definition) to *((E1)+(E2)) ...</p>\n</blockquote>\n<p>So you may use any integral type including type <code>int</code> and correspondingly negative values provided that the result of expression <code>*((E1)+(E2))</code> is well-formed.</p>\n<p>Take into account that for user-defined types you may use a brace-init-list as the index. For example</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Point\n{\npublic:    \n    Point( int x, int y ) : x( x ), y( y ) {}\n    int x, y;\n};\n\nclass Circle\n{\npublic:    \n    Circle( unsigned int r ) : r( r ) {}\n\n    Circle &amp; operator []( Point p )\n    {\n        std::cout &lt;&lt; \"Drawing a circle at ( \" &lt;&lt; p.x &lt;&lt; \", \" &lt;&lt; p.y &lt;&lt; \" )\\n\";\n        return *this;\n    }\n\n    unsigned int r;\n};        \n\nint main()\n{\n    Circle circle( 10 );\n\n    circle[ { 0, 0 } ];\n}    \n</code></pre>\n<p>The program output is</p>\n<pre><code>Drawing a circle at ( 0, 0 )\n</code></pre>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2015-08-18T10:26:26.380", "Id": "32069562", "Score": "7", "CreationDate": "2015-08-18T10:14:23.777", "LastActivityDate": "2015-08-18T10:26:26.380"}});