post_cb({"bq_ids": {"n4140": {"so_12313405_12314089_0": {"length": 33, "quality": 0.9428571428571428, "section_id": 7192}}, "n3337": {"so_12313405_12314089_0": {"length": 33, "quality": 0.9428571428571428, "section_id": 6936}}, "n4659": {"so_12313405_12314089_0": {"length": 33, "quality": 0.9428571428571428, "section_id": 8701}}}, "12313405": {"ViewCount": "11338", "Body": "<p>I have been looking through and playing with different features of C++11, specifically in Visual Studio 2010.</p>\n<p>One of the things mentioned is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2670.htm\">minimal garbage collection</a>:</p>\n<p>According to this <a href=\"http://blogs.msdn.com/b/vcblog/archive/2011/09/12/10209291.aspx\">blog post</a>, VC10 supports this feature.</p>\n<blockquote>\n<p id=\"so_12313405_12313405_0\">My tests show that the destructor is not called on objects that are lost, so I am not sure as to whether their memory location has been freed or if they are leaking.</p>\n</blockquote>\n<p>I have no intention of depending on it, by any means, but couldn't find a straight, definitive answer on its behavior.</p>\n", "AcceptedAnswerId": "12314089", "Title": "Garbage Collection in C++11", "CreationDate": "2012-09-07T07:09:42.013", "Id": "12313405", "CommentCount": "0", "FavoriteCount": "7", "PostTypeId": "1", "LastEditDate": "2013-02-01T22:14:25.803", "LastEditorUserId": "834176", "LastActivityDate": "2013-02-01T22:14:25.803", "Score": "25", "OwnerUserId": "1224455", "Tags": "<c++><visual-studio-2010><visual-c++><c++11><garbage-collection>", "AnswerCount": "1"}, "12314089": {"Id": "12314089", "PostTypeId": "2", "Body": "<p>Minimal GC support (n2670) only means functions like <a href=\"http://msdn.microsoft.com/en-us/library/ee410598.aspx\"><code>std::declare_reachable</code></a> are included, and define what is the meaning of a \"safely-derived pointer\", so making certain operations like XOR-ing pointer values becomes undefined behavior and the GC don't need to worry about it. See also <a href=\"http://www.stroustrup.com/C++11FAQ.html#gc-abi\">Bjarne Stroustrup's C++11 FAQ on the GC ABI</a>, and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2585.pdf\">n2585: Minimal Support for Garbage\nCollection and Reachability-Based Leak Detection</a>.</p>\n<p>The proposal allows a GC to be implemented within C++11's framework. But the proposal itself does not mean the implementation needs to support GC. Some library e.g. libc++ simply implement the library functions as no-op. </p>\n<p>I'm pretty sure, at this point, the memory in your case is just leaked away. But notice that the destructor is indeed not required to run when GC happens. Assuming \"\u00a73.8 Object lifetime\" also supplies to GC-ed pointers, we have (\u00a73.8/4):</p>\n<blockquote>\n<p id=\"so_12313405_12314089_0\">... For an object of a class type with a non-trivial destructor, <strong>the program is not required to call the destructor explicitly before the storage which the object occupies is reused or released</strong>; however, if there is no explicit call to the destructor or if a delete-expression (5.3.5) is not used to release the storage, the destructor shall not be implicitly called and any program that depends on the side effects produced by the destructor has undefined behavior.</p>\n</blockquote>\n<p>So it is also possible the memory is already freed without the destructor called. In fact, earlier GC proposals such as <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2310.pdf\">n2310: Transparent Programmer-Directed Garbage Collection for C++</a> explicitly states that (n2310 \u00a77)</p>\n<blockquote>\n<p id=\"so_12313405_12314089_1\">When an object is recycled by the garbage collector, its destructor is not invoked (Of\n  course, explicit deletion always invokes destructors).</p>\n</blockquote>\n", "LastEditorUserId": "224671", "LastActivityDate": "2012-09-07T08:33:03.597", "Score": "36", "CreationDate": "2012-09-07T08:02:18.547", "ParentId": "12313405", "CommentCount": "2", "OwnerUserId": "224671", "LastEditDate": "2012-09-07T08:33:03.597"}});