post_cb({"bq_ids": {"n4140": {"so_17010884_17010977_0": {"length": 23, "quality": 0.92, "section_id": 6021}, "so_17010884_17010977_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 6022}}, "n3337": {"so_17010884_17010977_0": {"length": 23, "quality": 0.92, "section_id": 5789}, "so_17010884_17010977_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 5790}}, "n4659": {"so_17010884_17010977_0": {"length": 23, "quality": 0.92, "section_id": 7520}, "so_17010884_17010977_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 7521}}}, "17010884": {"ViewCount": "2817", "Body": "<p>I don't understand why pointers aren't polymorphic types, since we can use base class pointers, which are pointing to derived classes, to call derived class' virtual function. This suggests at runtime, the system can determine if a pointer is polymorphic, doesn't it?</p>\n<p>(This is a follow-up question from <a href=\"https://stackoverflow.com/questions/4202877/typeid-for-polymorphic-types\">typeid for polymorphic types</a>)</p>\n", "AcceptedAnswerId": "17011264", "Title": "typeid for polymorphic pointers?", "CreationDate": "2013-06-09T14:58:03.183", "Id": "17010884", "CommentCount": "10", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:25:47.460", "LastEditorUserId": "-1", "LastActivityDate": "2013-06-09T17:24:07.623", "Score": "9", "OwnerUserId": "2465355", "Tags": "<c++><polymorphism><typeid>", "AnswerCount": "2"}, "17010977": {"Id": "17010977", "PostTypeId": "2", "Body": "<p>In fact, the Standard (C++11) uses the term <em>polymorphic class type</em>, rather than <em>polymorphic type</em> when it describes the behaviour of <code>typeid</code>:</p>\n<p>Firstly, here it describes what happens when <code>typeid</code> is applied to an lvalue of class type (i.e. the case when it does what you expect):</p>\n<blockquote>\n<p id=\"so_17010884_17010977_0\">(\u00a75.2.8/2) When <code>typeid</code> is applied to a glvalue expression whose type is a polymorphic class type (10.3), the result refers to a <code>std::type_info</code> object representing the type of the most derived object (1.8) (that is, the dynamic type) to which the glvalue refers. [...]</p>\n</blockquote>\n<p>But when you apply it to a pointer (i.e. not to an lvalue of class type), the rule below applies:</p>\n<blockquote>\n<p id=\"so_17010884_17010977_1\">(\u00a75.2.8/3) When <code>typeid</code> is applied to an expression other than a glvalue of a polymorphic class type, the result refers to a <code>std::type_info</code> object representing the static type of the expression. [...]</p>\n</blockquote>\n<p>It says you get the static (not the dynamic) type, i.e. you get the declared type of the pointer, not the type of object it is actually pointing to.</p>\n<p>So, yes, pointers have polymorphic characteristics as you describe, but not when it comes to the result of <code>typeid</code>.</p>\n<p>(In fact, all of their polymorphic characteristics (including, in particular, polymorphic member function calls) only manifest themselves when some sort of explicit dereferencing, either using <code>*</code> or using <code>-&gt;</code>, is involved. So you should really say that the pointers themselves aren't polymorphic; only the objects you get when you dereference them are.)</p>\n", "LastEditorUserId": "777186", "LastActivityDate": "2013-06-09T16:07:11.103", "Score": "8", "CreationDate": "2013-06-09T15:08:18.237", "ParentId": "17010884", "CommentCount": "0", "OwnerUserId": "777186", "LastEditDate": "2013-06-09T16:07:11.103"}, "17011264": {"Id": "17011264", "PostTypeId": "2", "Body": "<p>Your question suffers from incorrect usage of terminology. C++ language makes a very clear distinction between pointers themselves and objects these pointers point to. Pointer types are not polymorphic. There's nothing polymorphic about the pointer itself. What can really be polymorphic is <em>the type the pointer points to</em>. When a pointer points to a polymorphic type, we often [informally] call it <em>polymorphic pointer</em> (just as a shorthand for \"a pointer that points to a polymorphic type\"). But when it comes to things like <code>typeid</code>, they see things very formally. For <code>typeid</code> pointer types are never polymorphic.</p>\n<p>And the compiler does not determine whether the pointer is polymorphic or not at run-time. This simple distinction is always immediately known at compile-time. Again, a pointer is referred to as <em>polymorphic</em> if it is declared as a pointer to <em>polymorphic type</em>. <em>Polymorphic type</em> is a class type that contains virtual functions (directly or indirectly). Obviously, the property of being polymorphic is a purely compile-time property of a type.</p>\n<p>The only thing that is determined at run-time in such cases case is <em>which</em> specific type the pointed object has at the given moment.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2013-06-09T17:24:07.623", "Score": "4", "CreationDate": "2013-06-09T15:39:47.353", "ParentId": "17010884", "CommentCount": "2", "OwnerUserId": "187690", "LastEditDate": "2013-06-09T17:24:07.623"}});