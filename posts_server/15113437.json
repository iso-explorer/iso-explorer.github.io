post_cb({"15113748": {"ParentId": "15113437", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>It depends on how you use these constant expressions.</p>\n<p>The ODR (one-definition rule) states that</p>\n<blockquote>\n<p id=\"so_15113437_15113748_0\">(\u00a73.2/2) [...] A variable whose name appears as a potentially-evaluated expression is odr-used unless it is an object that satisfies the requirements for appearing in a constant expression (5.19) and the lvalue-to-rvalue conversion (4.1) is immediately applied. [...]</p>\n</blockquote>\n<p>(And then, lots of special rules, exceptions and exceptions of the exceptions follow.)</p>\n<p>Any variable that <em>is</em> odr-used, must have exactly one definition. Your constant expressions have a declaration, but not a definition, so this goes well unless you odr-use one of them.</p>\n<p>For example, the following goes well:</p>\n<pre><code>int main() {\n  E e = GetE&lt;float&gt;::type;\n  return 0;\n}\n</code></pre>\n<p>But this does not:</p>\n<pre><code>void f(const E &amp;)\n{ }\n\nint main() {\n  f(GetE&lt;float&gt;::type);\n  return 0;\n}\n</code></pre>\n<p>because <code>f</code> requires a (const) reference, so the lvalue-to-rvalue conversion cannot be applied immediately, hence this constitutes an odr-use. The compiler will complain that it misses a definition.</p>\n<p>(Remark. As ShafikYaghmour found (see the comments), you may not get a complaint if the compiler uses optimization, as the references may be optimized away. To reproduce the compiler complaint, use the <code>-O0</code> flag (or similar, depending on the compiler).)</p>\n<p>To solve the problem, the required definition can be provided in the usual way, i.e. outside the struct-definition:</p>\n<pre><code>constexpr E GetE&lt;float&gt;::type;\nconstexpr E GetE&lt;char&gt;::type;\nconstexpr E GetE&lt;int&gt;::type;\n</code></pre>\n<p>But since this would have to happen in the .cpp (not the header file), you'll end up having to maintain the declarations and definitions in two different places, which is cumbersome.</p>\n<p>The solution you've just suggested in your comment, i.e. define a constexpr (and inline) function, sounds right:</p>\n<pre><code>template &lt;class T&gt; constexpr E GetE();\n\ntemplate &lt;&gt; constexpr E GetE&lt;float&gt;()\n{ return TYPE_FLOAT; }\n\ntemplate &lt;&gt; constexpr E GetE&lt;char&gt;()\n{ return TYPE_CHAR; }\n\ntemplate &lt;&gt; constexpr E GetE&lt;int&gt;()\n{ return TYPE_INT; }\n\nvoid f(const E &amp;)\n{ }\n\nint main() {\n  E e = GetE&lt;float&gt;();\n\n  f(GetE&lt;float&gt;());\n\n  return 0;\n}\n</code></pre>\n", "OwnerUserId": "777186", "LastEditorUserId": "777186", "LastEditDate": "2013-02-27T14:06:30.930", "Id": "15113748", "Score": "6", "CreationDate": "2013-02-27T13:50:11.537", "LastActivityDate": "2013-02-27T14:06:30.930"}, "15113594": {"ParentId": "15113437", "CommentCount": "1", "Body": "<p>Maybe because you forgot to put a semicolon after the enum definition, this works for me in LiveWorkSpace:</p>\n<pre><code>#include &lt;iostream&gt;\n\nenum E\n{\n   TYPE_FLOAT,\n   TYPE_CHAR,\n   TYPE_INT\n} ;\n\ntemplate&lt;class T&gt; struct GetE;\n\ntemplate&lt;&gt; struct GetE&lt;float&gt; { static constexpr E type = TYPE_FLOAT; };\ntemplate&lt;&gt; struct GetE&lt;char&gt; { static constexpr E type = TYPE_CHAR; };\ntemplate&lt;&gt; struct GetE&lt;int&gt; { static constexpr E type = TYPE_INT; };\n\nint main()\n{\n    std::cout &lt;&lt; GetE&lt;int&gt;::type &lt;&lt; std::endl ;\n}\n</code></pre>\n<p>here is a link to the code <a href=\"http://liveworkspace.org/code/nHqUe\" rel=\"nofollow\">http://liveworkspace.org/code/nHqUe</a>$6</p>\n", "OwnerUserId": "1708801", "PostTypeId": "2", "Id": "15113594", "Score": "1", "CreationDate": "2013-02-27T13:42:59.657", "LastActivityDate": "2013-02-27T13:42:59.657"}, "15113437": {"CommentCount": "0", "ViewCount": "1502", "PostTypeId": "1", "LastEditorUserId": "608639", "CreationDate": "2013-02-27T13:35:42.147", "LastActivityDate": "2016-11-12T17:04:32.670", "Title": "C++11 type to enum mapping?", "AcceptedAnswerId": "15113748", "LastEditDate": "2016-11-12T17:04:32.670", "Id": "15113437", "Score": "5", "Body": "<p>I have an enum like:</p>\n<pre><code>enum E\n{\n    TYPE_FLOAT,\n    TYPE_CHAR,\n    TYPE_INT\n}\n</code></pre>\n<p>And I want to create a compile-time mapping to get the appropriate E for a type like:</p>\n<pre><code>GetE&lt;float&gt; // returns TYPE_FLOAT\nGetE&lt;char&gt; // returns TYPE_CHAR\nGetE&lt;int&gt; // returns TYPE_INT\n</code></pre>\n<p>I thought of:</p>\n<pre><code>template&lt;class T&gt; struct GetE;\n\ntemplate&lt;&gt; struct GetE&lt;float&gt; { static constexpr E type = TYPE_FLOAT; };\ntemplate&lt;&gt; struct GetE&lt;char&gt; { static constexpr E type = TYPE_CHAR; };\ntemplate&lt;&gt; struct GetE&lt;int&gt; { static constexpr E type = TYPE_INT; };\n</code></pre>\n<p>But I'm getting errors like:</p>\n<pre><code>undefined reference to `GetE&lt;int&gt;::type'\n</code></pre>\n<p>Whats the best way to do this? And why the error?</p>\n", "Tags": "<c++><c++11><constexpr>", "OwnerUserId": "1131467", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_15113437_15113748_0": {"section_id": 7040, "quality": 0.5263157894736842, "length": 10}}, "n3337": {"so_15113437_15113748_0": {"section_id": 6785, "quality": 0.8421052631578947, "length": 16}}, "n4659": {"so_15113437_15113748_0": {"section_id": 8537, "quality": 0.5263157894736842, "length": 10}}}, "15113587": {"ParentId": "15113437", "CommentCount": "3", "Body": "<p>Static member variables need to be <em>defined</em> outside the class scope:</p>\n<pre><code>class C {\n    const static int x = 5;\n};\n\ndecltype(C::x) C::x;\n</code></pre>\n", "OwnerUserId": "752976", "PostTypeId": "2", "Id": "15113587", "Score": "1", "CreationDate": "2013-02-27T13:42:48.617", "LastActivityDate": "2013-02-27T13:42:48.617"}});