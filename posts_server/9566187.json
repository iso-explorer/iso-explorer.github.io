post_cb({"9566209": {"ParentId": "9566187", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>Keeping it safe: the standard leaves it up to the compiler to determine the order in which arguments are evaluated. So you shouldn't rely on a specific order being kept.</p>\n", "OwnerUserId": "673730", "LastEditorUserId": "673730", "LastEditDate": "2012-03-05T12:35:41.907", "Id": "9566209", "Score": "6", "CreationDate": "2012-03-05T11:56:22.517", "LastActivityDate": "2012-03-05T12:35:41.907"}, "9566187": {"CommentCount": "4", "AcceptedAnswerId": "9566538", "PostTypeId": "1", "LastEditorUserId": "280314", "CreationDate": "2012-03-05T11:54:29.547", "LastActivityDate": "2016-04-22T15:59:53.497", "LastEditDate": "2012-03-05T12:52:55.380", "ViewCount": "6726", "FavoriteCount": "8", "Title": "function parameter evaluation order", "Id": "9566187", "Score": "16", "Body": "<p>In <code>C/C++</code>, is there a fixed order for evaluation of parameter to the function? I mean, what do the standards say? Is it <code>left-to-right</code> or <code>right-to-left</code>?\nI am getting confusing information from the books.</p>\n<p>Is it necessary that <code>function call</code> should be implemented using <code>stack only</code>. What does the <code>C/C++</code> standards say about this?</p>\n", "Tags": "<c++><c>", "OwnerUserId": "92568", "AnswerCount": "4"}, "36798462": {"ParentId": "9566187", "CommentCount": "0", "Body": "<p>Just only to speak for <strong>C</strong> language, the order of evaluation inside the function parameters depend on compiler. from <strong>The C Programming Language</strong> of <strong>Brian Kernighan</strong> and <strong>Dennis Ritchie</strong>;</p>\n<blockquote>\n<p id=\"so_9566187_36798462_0\">Similarly, the order in which function arguments are evaluated is not\n  specified, so the statement</p>\n<p id=\"so_9566187_36798462_1\"><code>printf(\"%d %d\\n\", ++n, power(2, n)); /*WRONG */</code></p>\n<p id=\"so_9566187_36798462_2\">can produce different results with different compilers,\n  depending on whether n is incremented before power is called. The\n  solution, of course, is to write</p>\n<p id=\"so_9566187_36798462_3\"><code>++n;</code></p>\n<p id=\"so_9566187_36798462_4\"><code>printf(\"%d %d\\n\", n, power(2, n));</code></p>\n</blockquote>\n", "OwnerUserId": "3128926", "PostTypeId": "2", "Id": "36798462", "Score": "0", "CreationDate": "2016-04-22T15:59:53.497", "LastActivityDate": "2016-04-22T15:59:53.497"}, "9566723": {"ParentId": "9566187", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_9566187_9566723_0\">In C/C++ is there a fixed order for evaluation of parameter to the function. I mean what does standards says is it left-to-right or right-to-left . I am getting confusing information from the books.</p>\n</blockquote>\n<p>No, the order of evaluation of function parameters (and of two sub-expressions in any expression) is <em>unspecified behaviour</em> in C and C++. In plain English that means that the left-most parameter could be evaluated first, or it could be the right-most one, and <em>you cannot know which order that applies for a particular compiler</em>. </p>\n<p>Example:</p>\n<pre><code>static int x = 0;\n\nint* func (int val)\n{\n  x = val;\n  return &amp;x;\n}\n\nvoid print (int val1, int val2)\n{\n  cout &lt;&lt; val1 &lt;&lt; \" \" &lt;&lt; val2 &lt;&lt; endl;\n}\n\nprint(*func(1), *func(2));\n</code></pre>\n<p>This code is very bad. It relies of order of evaluation of print's parameters. It will print either \"1 1\" (right-to-left) or \"2 2\" (left-to-right) and <em>we cannot know which</em>. The only thing guaranteed by the standard is that both calls to func() are completed before the call to print().</p>\n<p>The solution to this is to be aware that the order is unspecified, and write programs that don't rely on the order of evaluation. For example:</p>\n<pre><code>int val1 = *func(1);\nint val2 = *func(2);\nprint(val1, val2); // Will always print \"1 2\" on any compiler.\n</code></pre>\n<hr>\n<blockquote>\n<p id=\"so_9566187_9566723_1\">Is it necessary that function call should be implemented using stack only. what does C/C++ standards says about this.</p>\n</blockquote>\n<p>This is known as \"calling convention\" and nothing that the standard specifies at all. How parameters (and return values) are passed, is entirely up to the implementation. They could be passed in CPU registers or on the stack, or in some other way. The caller could be the one responsible for pushing/popping parameters on the stack, or the function could be responsible.</p>\n<p>The order of evaluation of function parameters is only somewhat associated with the calling convention, since the evaluation occurs <em>before</em> the function is called. But on the other hand, certain compilers can choose to put the right-most parameter in a CPU register and the rest of them on the stack, as one example. </p>\n</hr>", "OwnerUserId": "584518", "PostTypeId": "2", "Id": "9566723", "Score": "2", "CreationDate": "2012-03-05T12:33:48.150", "LastActivityDate": "2012-03-05T12:33:48.150"}, "9566538": {"ParentId": "9566187", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>C and C++ are two completely different languages; don't assume the same rules always apply to both.  In the case of parameter evaluation order, however:</p>\n<p>C99:</p>\n<blockquote id=\"so_9566187_9566538_0\">\n<b>6.5.2.2 Function calls</b><br>\n...<br>\n10 The order of evaluation of the function designator, the actual arguments, and\n  subexpressions within the actual arguments is unspecified, but there is a sequence point\n   before the actual call.\n</br></br></blockquote>\n<p>[<em>Edit</em>]\nC11 (draft):</p>\n<blockquote id=\"so_9566187_9566538_1\">\n<b>6.5.2.2 Function calls</b><br>\n...<br>\n10 There is a sequence point after the evaluations of the function designator and the actual\narguments but before the actual call. Every evaluation in the calling function (including\nother function calls) that is not otherwise specifically sequenced before or after the\nexecution of the body of the called function is indeterminately sequenced with respect to\nthe execution of the called function.<sup>94)</sup><br>\n...<br>\n94) In other words, function executions do not \u2018\u2018interleave\u2019\u2019 with each other.\n</br></br></br></br></blockquote>\n<p>C++:</p>\n<blockquote id=\"so_9566187_9566538_2\">\n<b>5.2.2 Function call</b><br>\n...<br>\n8  The order of evaluation of arguments is unspecified. All side effects of argument expression evaluations take effect\n before the function is entered. The order of evaluation of the postfix expression and the argument expression list is\n  unspecified.\n</br></br></blockquote>\n<p>Neither standard mandates the use of the hardware stack for passing function parameters; that's an implementation detail. The C++ standard uses the term \"unwinding the stack\" to describe calling destructors for automatically created objects on the path from a <code>try</code> block to a <em>throw-expression</em>, but that's it.  Most popular architectures <em>do</em> pass parameters via a hardware stack, but it's not universal.  </p>\n<p>[<em>Edit</em>]</p>\n<blockquote>\n<p id=\"so_9566187_9566538_3\">I am getting confusing information from the books.</p>\n</blockquote>\n<p>This is not in the least surprising, since easily 90% of books written about C are simply <em>crap</em>.  </p>\n<p>While the language standard isn't a great resource for <em>learning</em> either C or C++, it's good to have handy for questions like this.  The official\u2122 standards documents cost real money, but there are drafts that are freely available online, and should be good enough for most purposes.</p>\n<p>The latest C99 draft (with updates since original publication) is available <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"noreferrer\">here</a>.  The latest pre-publication C11 draft (which was officially ratified last year) is available <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1539.pdf\" rel=\"noreferrer\">here</a>.  And a publicly availble draft of the C++ language is available <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"noreferrer\">here</a>, although it has an explicit disclaimer that some of the information is incomplete or incorrect.</p>\n", "OwnerUserId": "134554", "LastEditorUserId": "134554", "LastEditDate": "2012-03-05T15:28:16.193", "Id": "9566538", "Score": "29", "CreationDate": "2012-03-05T12:20:34.903", "LastActivityDate": "2012-03-05T15:28:16.193"}, "bq_ids": {"n4140": {"so_9566187_9566538_1": {"section_id": 5811, "quality": 0.6956521739130435, "length": 32}, "so_9566187_36798462_0": {"section_id": 3161, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_9566187_9566538_1": {"section_id": 5584, "quality": 0.6956521739130435, "length": 32}, "so_9566187_36798462_0": {"section_id": 3034, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_9566187_36798462_0": {"section_id": 3923, "quality": 0.5714285714285714, "length": 4}}}});