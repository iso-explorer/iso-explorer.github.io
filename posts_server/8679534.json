post_cb({"8679534": {"CommentCount": "6", "ViewCount": "797", "CreationDate": "2011-12-30T12:39:54.130", "LastActivityDate": "2011-12-30T14:45:05.367", "Title": "Guard code after switch on enum is never reached", "AcceptedAnswerId": "8679688", "PostTypeId": "1", "Id": "8679534", "Score": "12", "Body": "<p>I have just hit a confusing problem when trying to compile some code using g++ 4.4.3.</p>\n<p>The code below compiles fine, but instead of hitting the expected assert when I pass an 'invalid' enum value, the function just returns 1. What I find even stranger is that when I uncomment the lines pertaining to the E3 enum value, things start working as expected.</p>\n<p>The fact that there is no default entry in the switch block is by design. We compile with the -Wall option to get warnings of unhandled enum values.</p>\n<pre><code>enum MyEnum\n{\n    E1,\n    E2, \n    //E3\n};\n\nint doSomethingWithEnum(MyEnum myEnum)\n{\n    switch (myEnum)\n    {\n        case E1: return 1;\n        case E2: return 2;\n        //case E3: return 3;\n    }\n\n    assert(!\"Should never get here\");\n    return -1;\n}\n\nint main(int argc, char **argv)\n{\n    // Should trigger assert, but actually returns 1\n    int retVal =  doSomethingWithEnum(static_cast&lt;MyEnum&gt;(4));\n    std::cout &lt;&lt; \"RetVal=\" &lt;&lt; retVal &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "1122886", "AnswerCount": "3"}, "8679907": {"ParentId": "8679534", "CommentCount": "0", "Body": "<p>This is perfectly normal, your code relies on unspecified behavior.</p>\n<p>In C++, an enum is only supposed to hold values between its lower and higher values. Anything else can be transformed or ignored by the compiler.</p>\n<p>For example, if I have <code>enum Foo { min = 10, max = 11 };</code> then the compiler is free to represent it with a single significant bit and add 10 when I ask to print it or convert it to an integer.</p>\n<p>In general though, compilers do not take advantage of this \"compaction\" because of the performance cost, they simply select an underlying type that can accomodate all values and <code>0</code>. Most often it's an <code>int</code>, unless <code>int</code> is too small.</p>\n<p>However, it does not prevent them to <em>assume</em> that the values this <code>int</code> contain are restricted to the range you defined. In your case: <code>[0, 2)</code>.</p>\n<p>As such, the <code>switch</code> statement can simply be optimized into a comparison with <code>0</code>, since you specified that your enum could only be <code>0</code> or <code>1</code>.</p>\n<p>In the same vein, <code>if (foo == 3)</code> could be considered a tautological comparison (always false) and optimized away.</p>\n<p>In fact, as described in the gcc \"bug\" signaled by Hans Passat, this optimization typically occurs on power of 2s boundaries for gcc. So for example if you had <code>enum { zero, one, two, three };</code> and assigned <code>4</code> or higher to it, the same behavior would occur.</p>\n<p>Note that the value actually stored is not affected! This is why the print statement works as you expected, and is a source of confusion.</p>\n<p>I do not know if there is a warning to indicate that storing 4 in this enum will lead to unspecified behavior. In any case, it would only work for compile-time values...</p>\n<hr>\n<p>Hans Passat provided the <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=41425\" rel=\"noreferrer\">gcc \"bug\"</a> that is open to track this \"issue\".</p>\n<p>And Emil Styrke provided the justification (here is the updated quote for scoped enums):</p>\n<blockquote>\n<p id=\"so_8679534_8679907_0\"><strong>5.2.9/10</strong></p>\n<p id=\"so_8679534_8679907_1\">A value of integral or enumeration type can be explicitly converted to an enumeration type. The value is unchanged if the original value is within the range of the enumeration values (7.2). Otherwise, the resulting value is unspecified (and might not be in that range). A value of floating-point type can also be converted to an enumeration type. The resulting value is the same as converting the original value to the underlying type of the enumeration (4.9), and subsequently to the enumeration type.</p>\n</blockquote>\n</hr>", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "8679907", "Score": "7", "CreationDate": "2011-12-30T13:25:21.557", "LastActivityDate": "2011-12-30T13:25:21.557"}, "8679627": {"ParentId": "8679534", "CommentCount": "2", "Body": "<p>It doesn't look like a compiler error. It is more like an undefined behaviour.\nThe rule says that you can attribute an undefined value to an Enum IF this value is in the range of the enum.\nIn your case, the compiler only needs one bit to represent the enum, so it is probably doing some kind of optimization.</p>\n", "OwnerUserId": "1122858", "PostTypeId": "2", "Id": "8679627", "Score": "8", "CreationDate": "2011-12-30T12:52:23.733", "LastActivityDate": "2011-12-30T12:52:23.733"}, "8679688": {"ParentId": "8679534", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Your switch statement will be compiled into this (g++ 4.4.5):</p>\n<pre><code>    cmpl    $1, %eax\n    je      .L3\n    movl    $1, %eax\n    jmp     .L4\n.L3:\n    movl    $2, %eax\n.L4:\n    leave\n    ret\n</code></pre>\n<p>As can be seen, the assert is optimized away completely, and the compiler elects to compare against E2 and return 1 in all other cases.  With three enum values it can't do that.</p>\n<p>Section 5.2.9 of the C++98 standard (static cast) gives the reason for allowing this:</p>\n<blockquote>\n<p id=\"so_8679534_8679688_0\">A value of integral or enumeration type can be explicitly converted to an enumeration type. The value is unchanged\n  if the original value is within the range of the enumeration values (7.2). Otherwise, the resulting enumeration value is\n  unspeci\ufb01ed.</p>\n</blockquote>\n<p>In other words, the compiler is free to use whatever enum value it wants, (in this case E1) if you try to use an illegal value.  This includes doing the intuitive thing and using the supplied illegal value or using different values depending on the circumstances, which is why the behavior changes depending on the number of enum values.</p>\n", "OwnerUserId": "827828", "LastEditorUserId": "827828", "LastEditDate": "2011-12-30T14:45:05.367", "Id": "8679688", "Score": "9", "CreationDate": "2011-12-30T13:00:44.747", "LastActivityDate": "2011-12-30T14:45:05.367"}, "bq_ids": {"n4140": {"so_8679534_8679688_0": {"section_id": 6036, "quality": 0.9130434782608695, "length": 21}, "so_8679534_8679907_1": {"section_id": 6036, "quality": 0.9555555555555556, "length": 43}}, "n3337": {"so_8679534_8679688_0": {"section_id": 5804, "quality": 0.9130434782608695, "length": 21}, "so_8679534_8679907_1": {"section_id": 5804, "quality": 0.9555555555555556, "length": 43}}, "n4659": {"so_8679534_8679688_0": {"section_id": 7535, "quality": 0.8695652173913043, "length": 20}, "so_8679534_8679907_1": {"section_id": 7535, "quality": 0.8444444444444444, "length": 38}}}});