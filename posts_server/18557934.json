post_cb({"bq_ids": {"n4140": {"so_18557934_18558202_0": {"length": 15, "quality": 1.0, "section_id": 269}}, "n3337": {"so_18557934_18558202_0": {"length": 15, "quality": 1.0, "section_id": 260}}, "n4659": {"so_18557934_18558202_0": {"length": 15, "quality": 1.0, "section_id": 276}}}, "18558202": {"Id": "18558202", "PostTypeId": "2", "Body": "<p>The compiler first chooses the primary template and only then determines which specialization to use. That is, in your case the compiler always chooses the second primary template, i.e., #3.</p>\n<p>However, since you didn't specify the template argument when specializing the function template, your specialization specializes a different primary template depending on its location: with the given order, it specializes the first primary template, when you exchange the order of #2 and #3 it specializes the the second primary template. In 14.7.3 [temp.expl.spec] paragraph 7 the standard has to say the following about the situation</p>\n<blockquote>\n<p id=\"so_18557934_18558202_0\">... When writing a specialization, be careful about its location; or to make it compile will be such a trial as to kindle its self-immolation.</p>\n</blockquote>\n<p>If you wanted to control which primary template the specialization actually specializes, you would specify the template arguments in the specialization:</p>\n<pre><code>template &lt;&gt; void c&lt;int*&gt;(int* in) { ... } // specializes the first primary\ntemplate &lt;&gt; void c&lt;int&gt;(int* in)  { ... } // specializes the second primary\n</code></pre>\n", "LastEditorUserId": "1120273", "LastActivityDate": "2013-09-01T12:40:12.270", "Score": "14", "CreationDate": "2013-09-01T11:58:30.983", "ParentId": "18557934", "CommentCount": "6", "LastEditDate": "2013-09-01T12:40:12.270", "OwnerUserId": "1120273"}, "18557934": {"ViewCount": "380", "Body": "<p>I have the following code:</p>\n<pre><code>//1\ntemplate&lt;typename T&gt;\nvoid c(T in) {\n    cout &lt;&lt; \"Template c(\" &lt;&lt; in &lt;&lt; \")\" &lt;&lt; endl;\n}\n//2\ntemplate&lt;&gt;\nvoid c&lt;&gt;(int* in) { \n        cout &lt;&lt; \"Template specialization b(\" &lt;&lt; in &lt;&lt; \")\" &lt;&lt;endl;\n}\n//3\ntemplate&lt;typename T&gt;\nvoid c(T* in) {\n        cout &lt;&lt; \"Template for pointers c(\" &lt;&lt; in &lt;&lt; \")\" &lt;&lt;endl;\n}\n//..\nint i = 8;\nc(&amp;i);\n</code></pre>\n<p>Can someone explain me why in the following example compiler choose function #3, but when I change the order of functions #2 and #3, then compiler choose function #2?</p>\n", "AcceptedAnswerId": "18558202", "Title": "C++ Templates - specializing functions", "CreationDate": "2013-09-01T11:23:39.037", "Id": "18557934", "CommentCount": "7", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-09-01T12:40:12.270", "Score": "10", "OwnerUserId": "2583998", "Tags": "<c++><templates><specialization>", "AnswerCount": "1"}});