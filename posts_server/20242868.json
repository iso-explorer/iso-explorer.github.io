post_cb({"bq_ids": {"n4140": {"so_20242868_20242868_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 5954}, "so_20242868_20243257_3": {"length": 19, "quality": 0.95, "section_id": 6064}, "so_20242868_20243257_6": {"length": 28, "quality": 0.8484848484848485, "section_id": 5944}, "so_20242868_20242868_1": {"length": 19, "quality": 0.95, "section_id": 6064}, "so_20242868_20243257_5": {"length": 24, "quality": 0.9230769230769231, "section_id": 6027}}, "n3337": {"so_20242868_20242868_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 5724}, "so_20242868_20243257_3": {"length": 19, "quality": 0.95, "section_id": 5832}, "so_20242868_20243257_6": {"length": 29, "quality": 0.8787878787878788, "section_id": 5715}, "so_20242868_20242868_1": {"length": 19, "quality": 0.95, "section_id": 5832}, "so_20242868_20243257_5": {"length": 24, "quality": 0.9230769230769231, "section_id": 5795}}, "n4659": {"so_20242868_20242868_0": {"length": 19, "quality": 0.8636363636363636, "section_id": 7441}, "so_20242868_20243257_3": {"length": 18, "quality": 0.9, "section_id": 7560}, "so_20242868_20243257_6": {"length": 23, "quality": 0.696969696969697, "section_id": 7429}, "so_20242868_20242868_1": {"length": 18, "quality": 0.9, "section_id": 7560}, "so_20242868_20243257_5": {"length": 24, "quality": 0.9230769230769231, "section_id": 7526}}}, "20243257": {"Id": "20243257", "PostTypeId": "2", "Body": "<p>This <code>gcc</code> document <a href=\"http://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Volatiles.html\" rel=\"nofollow\">7.1 When is a Volatile C++ Object Accessed?</a> is relevant here, and I quote (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_20242868_20243257_0\">The C++ standard differs from the C standard in its treatment of volatile objects. <strong>It fails to specify what constitutes a volatile access</strong>, except to say that C++ should behave in a similar manner to C with respect to volatiles</p>\n<p id=\"so_20242868_20243257_1\">The C and C++ language specifications differ when an object is accessed in a void context: </p>\n</blockquote>\n<p>and provides this example:</p>\n<pre><code>volatile int *src = somevalue;\n*src;\n</code></pre>\n<p>and continues by saying:</p>\n<blockquote>\n<p id=\"so_20242868_20243257_2\">The C++ standard specifies that such expressions do not undergo lvalue to rvalue conversion, and that the type of the dereferenced object may be incomplete. The C++ standard does not specify explicitly that it is lvalue to rvalue conversion that is responsible for causing an access.</p>\n</blockquote>\n<p>which should be referring to draft standard section <code>5.3.1</code> <em>Unary operators</em> paragraph <em>1</em> which says :</p>\n<blockquote>\n<p id=\"so_20242868_20243257_3\">The unary * operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and the <strong>result is an lvalue</strong> referring to the object or function to which the expression points. [...]</p>\n</blockquote>\n<p>and with respect to references:</p>\n<blockquote>\n<p id=\"so_20242868_20243257_4\"><strong>When using a reference to volatile</strong>, G++ does not treat equivalent expressions as accesses to volatiles, but instead issues a warning that no volatile is accessed. The rationale for this is that otherwise it becomes difficult to determine where volatile access occur, and not possible to ignore the return value from functions returning volatile references. Again, <strong>if you wish to force a read, cast the reference to an rvalue</strong>.</p>\n</blockquote>\n<p>so it looks like <code>gcc</code> is choosing to treat <em>references to volatile</em> differently and in order to <em>force</em> a read you need to cast to an <em>rvalue</em>, for example:</p>\n<pre><code>static_cast&lt;volatile int&gt;( c ) ;\n</code></pre>\n<p>which generates a <em>prvalue</em> and hence a <em>lvalue to rvalue conversion</em>, from section <code>5.2.9</code> <em>Static cast</em>:</p>\n<blockquote>\n<p id=\"so_20242868_20243257_5\">The result of the expression static_cast(v) is the result of converting the expression v to type T. If T is an lvalue reference type or an rvalue reference to function type, the result is an lvalue; if T is an rvalue reference to object type, the result is an xvalue; <strong>otherwise, the result is a prvalue.</strong></p>\n</blockquote>\n<p><b>Update</b></p>\n<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">C++11 draft standard</a> adds <code>5</code> <em>Expressions</em> paragraph <em>11</em> which says:</p>\n<blockquote>\n<p id=\"so_20242868_20243257_6\">In some contexts, an expression only appears for its side effects. Such an expression is called a discarded-value expression. The expression is evaluated and its value is discarded. The array-to-pointer (4.2) and functionto-pointer (4.3) standard conversions are not applied. <strong>The lvalue-to-rvalue conversion (4.1) is applied if and only if the expression is an lvalue of volatile-qualified type and it is one of the following</strong>:</p>\n</blockquote>\n<p>and includes:</p>\n<blockquote>\n<p id=\"so_20242868_20243257_7\">\u2014 id-expression (5.1.1),</p>\n</blockquote>\n<p>This seems ambiguous to me since with respect to <code>a;</code> and <code>c;</code> section <code>5.1.1 p8</code> says it is an <code>lvalue</code> and it is not obvious to me that it covers this case but as Jonathan found <a href=\"http://open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1054\" rel=\"nofollow\">DR 1054</a> says it does indeed cover this case.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2013-11-27T18:25:50.297", "Score": "3", "CreationDate": "2013-11-27T13:02:14.270", "ParentId": "20242868", "CommentCount": "1", "OwnerUserId": "1708801", "LastEditDate": "2013-11-27T18:25:50.297"}, "20242868": {"ViewCount": "459", "Body": "<p>Consider the following statements</p>\n<pre><code>volatile int a = 7;\na;   // statement A\nvolatile int* b = &amp;a;\n*b;  // statement B\nvolatile int&amp; c = a;\nc;   // statement C\n</code></pre>\n<p>Now, I've been trying to find a point in the standard that tells me how a compiler is to behave when coming across these statements. All I could find is that A (and possibly C) gives me an lvalue, and so does B:</p>\n<h2>\"\u00a7 5.1.1.8 Primary expressions - General\" says</h2>\n<blockquote>\n<p id=\"so_20242868_20242868_0\">An identifier is an id-expression provided it has been suitably declared (Clause 7). [..]<br>\n  [..] The result is the entity denoted by the identifier. The result is an\n  lvalue if the entity is a function, variable, or data member and a\n  prvalue otherwise.<br>\n  [..]</br></br></p>\n</blockquote>\n<h2>\"\u00a7 5.3.1 Unary operators\" says</h2>\n<blockquote>\n<p id=\"so_20242868_20242868_1\">The unary * operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and the result is an lvalue referring to the object or function to which the expression points.</p>\n</blockquote>\n<h2>clang and gcc</h2>\n<p>I tried this with clang++ 3.2-11 and g++ 4.7.3, and the first produced three reads in C++11 mode and zero reads in C++03 mode (outputting three warnings) while g++ only produced the first two, explicitly warning me that the third would not be generated.</p>\n<h2>Question</h2>\n<p>It is clear which type of value comes out of the expression, from the quoted line in the standard, but:<br>\n<em>which of the statements (A,B,C) should produce a read from the volatile entity according to the C++ standard?</em></br></p>\n", "Title": "Correct behaviour of trivial statements involving expressions with volatile variables?", "CreationDate": "2013-11-27T12:44:05.420", "LastActivityDate": "2013-11-27T18:25:50.297", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2013-11-27T13:42:05.393", "LastEditorUserId": "430766", "Id": "20242868", "Score": "8", "OwnerUserId": "430766", "Tags": "<c++><standards><volatile><language-lawyer>", "AnswerCount": "2"}, "20243776": {"Id": "20243776", "PostTypeId": "2", "Body": "<p>The G++ warning about the \"implicit dereference\" comes from code in <code>gcc/cp/cvt.c</code> which intentionally does not load the value through a reference:</p>\n<pre><code>    /* Don't load the value if this is an implicit dereference, or if\n       the type needs to be handled by ctors/dtors.  */\n    else if (is_volatile &amp;&amp; is_reference)\n</code></pre>\n<p>G++ does that intentionally, because as stated in the manual (<a href=\"http://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Volatiles.html\" rel=\"nofollow\">When is a Volatile C++ Object Accessed?</a>) the standard is not clear about what constitutes an access of a volatile-qualified object. As stated there you need to force lvalue-to-rvalue conversion to force a load from a volatile.</p>\n<p>Clang gives warnings in C++03 mode that indicate a similar interpretation:</p>\n<pre><code>a.cc:4:3: warning: expression result unused; assign into a variable to force a volatile load [-Wunused-volatile-lvalue]\n  a;   // statement A\n  ^\na.cc:6:3: warning: expression result unused; assign into a variable to force a volatile load [-Wunused-volatile-lvalue]\n  *b;  // statement B\n  ^~\na.cc:8:3: warning: expression result unused; assign into a variable to force a volatile load [-Wunused-volatile-lvalue]\n  c;   // statement C\n  ^\n3 warnings generated.\n</code></pre>\n<p>The G++ behaviour and the GCC manual seem to be correct for C++03, but there is a difference in C++11 relative to C++03, introduced by <a href=\"http://open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1054\" rel=\"nofollow\">DR 1054</a> (which also explains why Clang behaves differently in C++)3 and C++11 modes). 5 [expr] p10 defines a <em>discarded-value-expression</em> and says that for volatiles the lvalue-to-rvalue conversion <em>is</em> applied to an <em>id-expression</em> such as your statements A and C.  The spec for lvalue-to-rvalue conversion (4.1 [conv.lval]) says that the result is the value of the glvalue, which constitutes an access of the volatile. According to 5p10 all three of your statements should be accesses, so G++'s handling of statement C needs to be updated to conform to C++11.  I've reported it as <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=59314\" rel=\"nofollow\">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=59314</a></p>\n", "LastEditorUserId": "981959", "LastActivityDate": "2013-11-27T15:13:24.200", "Score": "5", "CreationDate": "2013-11-27T13:26:53.030", "ParentId": "20242868", "CommentCount": "10", "OwnerUserId": "981959", "LastEditDate": "2013-11-27T15:13:24.200"}});