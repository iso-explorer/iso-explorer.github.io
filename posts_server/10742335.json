post_cb({"10742377": {"Id": "10742377", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_10742335_10742377_0\">1) Is it guaranteed that a==b?</p>\n</blockquote>\n<p>It is not. Note that you are comparing addresses and they could be pointing to different locations. Most smart compilers would fold this duplicate literal constant, so the pointers may compare equal, but again its not guaranteed by the standard.</p>\n<blockquote>\n<p id=\"so_10742335_10742377_1\">2) Why doesn't a==c? Shouldn't the compiler be able to see that they're referring to the same string?</p>\n</blockquote>\n<p>You are trying to compare pointers, they point to different memory locations. Even if you were comparing the content of such pointers, they are still unequal (see next question).</p>\n<blockquote>\n<p id=\"so_10742335_10742377_2\">3) Is an extra \\0 appended at the end of c, even though it already contains one?</p>\n</blockquote>\n<p>Yes, there is.</p>\n", "LastActivityDate": "2012-05-24T17:25:17.020", "CommentCount": "3", "CreationDate": "2012-05-24T17:25:17.020", "ParentId": "10742335", "Score": "4", "OwnerUserId": "927034"}, "10742365": {"Id": "10742365", "PostTypeId": "2", "Body": "<p>1 - absolutely not.  a might == b though if the compiler chooses to share the same static string.</p>\n<p>2 - because they are NOT referring to the same string </p>\n<p>3 - yes.</p>\n<p>The behavior is no different between C and C++ here except that C++ compilers should reject the assignment to non-const char*.</p>\n", "LastActivityDate": "2012-05-24T17:24:05.707", "CommentCount": "3", "CreationDate": "2012-05-24T17:24:05.707", "ParentId": "10742335", "Score": "6", "OwnerUserId": "301883"}, "10742335": {"ViewCount": "558", "Body": "<p>So I did the following test:</p>\n<pre><code>char* a = \"test\";\nchar* b = \"test\";\nchar* c = \"test\\0\";\n</code></pre>\n<p>And now the questions:</p>\n<p>1) Is it guaranteed that <code>a==b</code>? <strong>I know I'm comparing addresses. This is not meant to compare the strings, but whether identical string literals are stored in a single memory location</strong></p>\n<p>2) Why doesn't <code>a==c</code>? Shouldn't the compiler be able to see that they're referring to the same string?</p>\n<p>3) Is an extra <code>\\0</code> appended at the end of <code>c</code>, even though it already contains one?</p>\n<p>I didn't want to ask 3 different questions for this because they seem somehow related, sorry 'bout that.</p>\n<p>Note: The tag is correct, I'm interested in C++. (although please specify if the behavior is different for C)</p>\n", "AcceptedAnswerId": "10742372", "Title": "String literals that contain '\\0' - why aren't they the same?", "CreationDate": "2012-05-24T17:22:12.723", "Id": "10742335", "CommentCount": "7", "PostTypeId": "1", "LastActivityDate": "2012-05-24T17:36:14.897", "Score": "5", "OwnerUserId": "1358572", "Tags": "<c++><string>", "AnswerCount": "7"}, "10742518": {"Id": "10742518", "PostTypeId": "2", "Body": "<p>As has been said a few times in other answers, you are comparing pointers. However, I would add that <code>strcmp(b,c)</code> should be true, because it stops checking at the first <code>\\0</code>.</p>\n", "LastActivityDate": "2012-05-24T17:33:25.010", "CommentCount": "0", "CreationDate": "2012-05-24T17:33:25.010", "ParentId": "10742335", "Score": "0", "OwnerUserId": "299571"}, "bq_ids": {"n4140": {"so_10742335_10742372_1": {"length": 14, "quality": 0.875, "section_id": 5361}}, "n3337": {"so_10742335_10742372_1": {"length": 14, "quality": 0.875, "section_id": 5157}}, "n4659": {"so_10742335_10742372_1": {"length": 14, "quality": 0.875, "section_id": 6789}}}, "10742372": {"Id": "10742372", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_10742335_10742372_0\">Is it guaranteed that a==b?</p>\n</blockquote>\n<p>No. But it is allowed by \u00a72.14.5/12:</p>\n<blockquote>\n<p id=\"so_10742335_10742372_1\">Whether all string literals are distinct (that is, are stored in nonoverlapping objects) is implementation-defined. The effect of attempting to modify a string literal is undefined.</p>\n</blockquote>\n<p>And as you can see from that last sentence using <code>char*</code> instead of <code>char const*</code> is a recipe for trouble (and your compiler should be rejecting it; make sure you have warnings enabled and high conformance levels selected).</p>\n<blockquote>\n<p id=\"so_10742335_10742372_2\">Why doesn't a==c? Shouldn't the compiler be able to see that they're referring to the same string?</p>\n</blockquote>\n<p>No, they're not required to be referring to same array of characters. One has five elements, the other six. An implementation could store the two in overlapping storage, but that's not required.</p>\n<blockquote>\n<p id=\"so_10742335_10742372_3\">Is an extra \\0 appended at the end of c, even though it already contains one?</p>\n</blockquote>\n<p>Yes.</p>\n", "LastActivityDate": "2012-05-24T17:24:41.090", "CommentCount": "5", "CreationDate": "2012-05-24T17:24:41.090", "ParentId": "10742335", "Score": "18", "OwnerUserId": "46642"}, "10742383": {"Id": "10742383", "PostTypeId": "2", "Body": "<p>If you are doing pointer comparisons than a != b, b != c, and c != a. Unless the compiler is smart enough to notice that your first two strings are the same.</p>\n<p>If you do a strcmp(str, str) then all your strings will come back as matches.</p>\n<p>I am not sure if the compiler will add an additional null termination to c, but I would guess that it would.</p>\n", "LastActivityDate": "2012-05-24T17:25:32.973", "CommentCount": "0", "CreationDate": "2012-05-24T17:25:32.973", "ParentId": "10742335", "Score": "0", "OwnerUserId": "1160965"}, "10742375": {"Id": "10742375", "PostTypeId": "2", "Body": "<p>The problem here is you're mixing the concepts of pointer and textual equivalence. </p>\n<p>When you say <code>a == b</code> or <code>a == c</code> you are asking if the pointers involved point to the same physical address.  The test has nothing to do with the textual contents of the pointers.</p>\n<p>To get textual equivalence you should use <code>strcmp</code> </p>\n", "LastActivityDate": "2012-05-24T17:24:51.663", "CommentCount": "3", "CreationDate": "2012-05-24T17:24:51.663", "ParentId": "10742335", "Score": "2", "OwnerUserId": "23283"}, "10742433": {"Id": "10742433", "PostTypeId": "2", "Body": "<p>First note that this should be const char* as that's what string literals decay to.  </p>\n<ol>\n<li>Both create arrays initialized with 't' 'e' 's' 't' folowed by a '\\0' (length = 5).  Comparing for equality will only tell you if they both start with the same pointer, not if they have the same contents (though logically, the two ideas follow each other).</li>\n<li>A isn't equal to C because the same rules apply, a = 't' 'e' 's' 't' '\\0' and b = 't' 'e' 's' 't' '\\0' '\\0'</li>\n<li>Yes, the compiler always does it and you shouldn't expicitly do in if you're making a string like this.  If you however crated an array and manually populated it, you need to ensure you add the \\0.</li>\n</ol>\n<p>Note that for my #3, const char[] = \"Hello World\" would also automatically get the \\0 at the end, I was refferring to manually filling the array, not having the compiler work it out.</p>\n", "LastActivityDate": "2012-05-24T17:28:21.663", "CommentCount": "3", "CreationDate": "2012-05-24T17:28:21.663", "ParentId": "10742335", "Score": "3", "OwnerUserId": "857994"}});