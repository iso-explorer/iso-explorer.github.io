post_cb({"39223166": {"ParentId": "2953684", "CommentCount": "0", "Body": "<p>I would like to refine slightly accepted answer. It is not clear in the OP question, but the important part from the standard (cited by Kornel) is this (emphasis mine):</p>\n<blockquote>\n<p id=\"so_2953684_39223166_0\">But when a function template with <strong><em>explicit template arguments</em></strong> is used, the call does not have the correct syntactic form</p>\n</blockquote>\n<p>so what is prohibited is relying on ADL and using explicit template arguments. Unfortunately using non-type template arguments requires using explicit arguments (unless they have default values).</p>\n<p>Below is sample code showing this.:</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/d3e90aa5b2619804\" rel=\"nofollow\">[live]</a></p>\n<pre><code>#include &lt;string&gt;\n#include &lt;utility&gt;\n\nnamespace C {\n  struct B { };\n  template&lt;class T&gt; void f(T t){}\n}\n\nvoid g(C::B b) {\n  f(b);           // OK\n  //f&lt;C::B&gt;(b);   // ill-formed: not a function call, but only \n                  //  because explicit template argument were used\n\n  std::string s;\n  move(s);                      // OK\n  //move&lt;std::string&amp;&gt;(s);      // Error, again because \n                                //  explicit template argument were used\n  std::move&lt;std::string&amp;&gt;(s);   // Ok\n}\n\nint main()\n{\n C::B b;\n g(b);\n}\n</code></pre>\n", "OwnerUserId": "471160", "PostTypeId": "2", "Id": "39223166", "Score": "3", "CreationDate": "2016-08-30T09:05:52.177", "LastActivityDate": "2016-08-30T09:05:52.177"}, "2953882": {"ParentId": "2953684", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Edit: No, this is not right. See <a href=\"https://stackoverflow.com/questions/2953684/why-doesnt-adl-find-function-templates/2953783#2953783\">@Kornel's answer</a>.</p>\n<hr>\n<p>I'm not entirely sure but having consulted Stroustrup's \"The C++ programming language\" I think that Appendix C section 13.8.4 <em>might</em> be the cause.</p>\n<p>Since <code>frob</code> is a template one could conceivably specialise it for <code>i=0</code> at a point after you call it. This means that the implementation would be left with two possible ways of choosing which <code>frob</code> to call as it appears it can choose it at the point of instantiation <em>or</em> at the end of processing the translation unit.</p>\n<p>So, I think the problem is you could do</p>\n<pre><code>namespace ns {\n    struct foo {};\n    template&lt;int i&gt; void frob(foo const&amp;) {}\n}\n\nint main() {\n    ns::foo f;\n    frob&lt;0&gt;(f);\n    return 0;\n}\n\nnamespace ns {\n    template&lt;&gt; void frob&lt; 0 &gt;(foo const&amp;) { /* Do something different*/ }\n}\n</code></pre>\n</hr>", "OwnerUserId": "74465", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:26:11.430", "Id": "2953882", "Score": "0", "CreationDate": "2010-06-01T22:40:37.193", "LastActivityDate": "2010-06-01T22:58:22.500"}, "2953783": {"ParentId": "2953684", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>This part explains it:</p>\n<p><strong>C++ Standard 03 14.8.1.6</strong>:</p>\n<blockquote>\n<p id=\"so_2953684_2953783_0\">[Note: For simple function names, argument dependent lookup (3.4.2) applies even when the function name is not visible within the scope of the call. This is because the call still has the syntactic form of a function call (3.4.1). But when a function template with explicit template arguments is used, the call does not have the correct syntactic form unless there is a function template with that name visible at the point of the call. If no such name is visible, the call is not syntactically well-formed and argument-dependent lookup does not apply. If some such name is visible, argument dependent lookup applies and additional function templates may be found in other namespaces.</p>\n</blockquote>\n<pre><code>namespace A {\n  struct B { };\n  template&lt;int X&gt; void f(B);\n}\nnamespace C {\n  template&lt;class T&gt; void f(T t);\n}\nvoid g(A::B b) {\n  f&lt;3&gt;(b);    //ill-formed: not a function call\n  A::f&lt;3&gt;(b); //well-formed\n  C::f&lt;3&gt;(b); //ill-formed; argument dependent lookup\n              // applies only to unqualified names\n  using C::f;\n  f&lt;3&gt;(b);    //well-formed because C::f is visible; then\n              // A::f is found by argument dependent lookup\n}\n</code></pre>\n", "OwnerUserId": "233522", "LastEditorUserId": "233522", "LastEditDate": "2010-06-01T22:41:15.727", "Id": "2953783", "Score": "72", "CreationDate": "2010-06-01T22:18:24.253", "LastActivityDate": "2010-06-01T22:41:15.727"}, "bq_ids": {"n4140": {"so_2953684_2953783_0": {"section_id": 291, "quality": 0.9305555555555556, "length": 67}, "so_2953684_39223166_0": {"section_id": 291, "quality": 1.0, "length": 13}}, "n3337": {"so_2953684_2953783_0": {"section_id": 282, "quality": 0.9305555555555556, "length": 67}, "so_2953684_39223166_0": {"section_id": 282, "quality": 1.0, "length": 13}}, "n4659": {"so_2953684_2953783_0": {"section_id": 298, "quality": 0.9305555555555556, "length": 67}, "so_2953684_39223166_0": {"section_id": 298, "quality": 1.0, "length": 13}}}, "2953684": {"CommentCount": "6", "AcceptedAnswerId": "2953783", "PostTypeId": "1", "LastEditorUserId": "252000", "LastEditorDisplayName": "Roger Pate", "CreationDate": "2010-06-01T22:00:04.503", "LastActivityDate": "2016-08-30T09:05:52.177", "LastEditDate": "2010-11-22T00:38:57.297", "ViewCount": "2734", "FavoriteCount": "18", "Title": "Why doesn't ADL find function templates?", "Id": "2953684", "Score": "67", "Body": "<p>What part of the C++ specification restricts argument dependent lookup from finding function templates in the set of associated namespaces? In other words, why does the last call in <code>main</code> below fail to compile?</p>\n<pre><code>namespace ns {\n    struct foo {};\n    template&lt;int i&gt; void frob(foo const&amp;) {}\n    void non_template(foo const&amp;) {}\n}\n\nint main() {\n    ns::foo f;\n    non_template(f); // This is fine.\n    frob&lt;0&gt;(f); // This is not.\n}\n</code></pre>\n", "Tags": "<c++><syntax><argument-dependent-lookup>", "OwnerUserId": "768869", "AnswerCount": "3"}});