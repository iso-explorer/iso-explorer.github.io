post_cb({"25897459": {"Id": "25897459", "PostTypeId": "2", "Body": "<p>The one advantage to captureless lambdas over the corresponding function object is that they are convertible to function pointers.</p>\n", "LastActivityDate": "2014-09-17T18:07:53.287", "CommentCount": "0", "CreationDate": "2014-09-17T18:07:53.287", "ParentId": "25895430", "Score": "0", "OwnerUserId": "1082038"}, "25895624": {"Id": "25895624", "PostTypeId": "2", "Body": "<p>Lambdas are largely syntactic sugar, but not entirely.  One point about lambdas is that they capture arrays by direct-initialization in subscript order <strong>[expr.prim.lambda]</strong>:</p>\n<blockquote>\n<p id=\"so_25895430_25895624_0\">22 - [...] (For array members, the array elements are direct-initialized in increasing\n  subscript order.) [...]</p>\n</blockquote>\n<p>This is surprisingly difficult to achieve otherwise; it is necessary to construct an index parameter pack using something like <code>std::index_sequence</code> and the semantics are not quite the same.</p>\n<p>Another thing lambdas can do is to capture a (variadic) parameter pack; this cannot be done generically (since structure members cannot be a parameter pack expansion) except via something like <code>std::tuple</code>.</p>\n", "LastActivityDate": "2014-09-17T16:20:24.703", "CommentCount": "0", "CreationDate": "2014-09-17T16:20:24.703", "ParentId": "25895430", "Score": "5", "OwnerUserId": "567292"}, "bq_ids": {"n4140": {"so_25895430_25895624_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 5981}}, "n3337": {"so_25895430_25895624_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 5749}}, "n4659": {"so_25895430_25895624_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 7478}}}, "25895502": {"Id": "25895502", "PostTypeId": "2", "Body": "<p>See full motivation for lamdas at <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n1958.pdf\" rel=\"noreferrer\">A proposal to add lambda functions to the C++ standard\n</a>:</p>\n<blockquote>\n<p id=\"so_25895430_25895502_0\">C++ Standard Library algorithms would be much more pleasant to use if C++ had support for lambdas. Lambda functions would let people use C++ Standard Library algorithms in many cases where currently it is easier to write a for loop. Many developers do not use function objects simply because of the syntactic overhead.</p>\n</blockquote>\n", "LastActivityDate": "2014-09-17T16:12:56.103", "CommentCount": "2", "CreationDate": "2014-09-17T16:12:56.103", "ParentId": "25895430", "Score": "8", "OwnerUserId": "412080"}, "25895430": {"ViewCount": "226", "Body": "<p>The title might not be precise but I couldn't think of any brief one that would be. <em>(Feel free to suggest one or edit my question.)</em></p>\n<p>I was wondering if there is any other advantage of using lambda functions other than the fact that that one doesn't have to explicitly define (and write) the whole class definition of a functor or define a separate function to be used (possibly) just once. In other words, are lambdas introduced just for convenience or is there more to them?</p>\n<p>Edit:\nOne thing to add to my question. Lambdas allow programmer to write less, do it more conveniently and <strong>therefore they are less error-prone</strong>. Which in itself is a different thing/reason than just convenience but is associated with it.</p>\n", "Title": "Is there any other advantage of lambdas besides convenience?", "CreationDate": "2014-09-17T16:08:54.743", "Id": "25895430", "CommentCount": "6", "LastEditDate": "2014-09-17T16:42:22.837", "PostTypeId": "1", "LastEditorUserId": "241631", "LastActivityDate": "2014-09-18T02:23:12.703", "Tags": "<c++><c++11><lambda>", "Score": "3", "OwnerUserId": "1030598", "ClosedDate": "2014-09-18T01:30:55.140", "AnswerCount": "5"}, "25895546": {"Id": "25895546", "PostTypeId": "2", "Body": "<p><strong>Basically: They exist for your convenience.</strong></p>\n<p>In addition to Maxim's answer, according to the <a href=\"http://msdn.microsoft.com/en-us/library/dd293608.aspx\" rel=\"nofollow\">MSDN article about Lambda Expressions in C++</a>:</p>\n<blockquote>\n<p id=\"so_25895430_25895546_0\">When you write code, you probably use function pointers and function\n  objects to solve problems and perform calculations, especially when\n  you use STL algorithms. Function pointers and function objects have\n  advantages and disadvantages\u2014for example, function pointers have\n  minimal syntactic overhead but do not retain state within a scope, and\n  function objects can maintain state but require the syntactic overhead\n  of a class definition. </p>\n<p id=\"so_25895430_25895546_1\">A lambda combines the benefits of function\n  pointers and function objects and avoids their disadvantages. Like a\n  function objects, a lambda is flexible and can maintain state, but\n  unlike a function object, its compact syntax doesn't require a class\n  definition. By using lambdas, you can write code that's less\n  cumbersome and less prone to errors than the code for an equivalent\n  function object.</p>\n</blockquote>\n", "LastActivityDate": "2014-09-17T16:15:33.047", "CommentCount": "2", "CreationDate": "2014-09-17T16:15:33.047", "ParentId": "25895430", "Score": "2", "OwnerUserId": "1026567"}, "25902359": {"Id": "25902359", "PostTypeId": "2", "Body": "<ul>\n<li><p>Using STL algorithms becomes more convenient.    </p></li>\n<li><p>If you want to write\nreusable code in your function but might not make sense to put it in\na free function, then lambdas come to the rescue.</p></li>\n</ul>\n<p>For eg.</p>\n<pre><code>void foo()\n{\n    auto validate = [] (const std::string&amp; str) -&gt; bool { // do some validation. };\n    /// ... code.\n    if (!validate(\"some info\"))\n    {\n       // throw error;\n    }\n\n    ////  \n\n     validate(\"some other info\");\n}\n</code></pre>\n", "LastEditorUserId": "124797", "LastActivityDate": "2014-09-18T02:23:12.703", "Score": "0", "CreationDate": "2014-09-18T00:23:08.120", "ParentId": "25895430", "CommentCount": "0", "OwnerUserId": "124797", "LastEditDate": "2014-09-18T02:23:12.703"}});