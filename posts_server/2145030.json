post_cb({"2145824": {"Id": "2145824", "PostTypeId": "2", "Body": "<p>No.</p>\n<p>The C++ language specification never makes such a straightforward assertion as the one you are asking about. It doesn't say anywhere in the language standard that \"all temporary objects are rvalues\". Moreover, the question itself is a bit of misnomer, since the property of being an rvalue in the C++ language is not a property of an object, but rather a property of an expression (i.e. a property of its result). This is actually how it is defined in the language specification: for different kinds of expressions it says when the result is an lvalue and when it is an rvalue. Among other things, this actually means that a temporary object can be accessed as an rvalue as well as an lvalue, depending on the specific form of expression that is used to perform the access.</p>\n<p>For example, the result of literal <code>2 + 3</code> expression is obviously an rvalue, a temporary of type <code>int</code>. We cannot apply the unary <code>&amp;</code> to it since unary <code>&amp;</code> requires an lvalue as its operand</p>\n<pre><code>&amp;(2 + 3); // ERROR, lvalue required\n</code></pre>\n<p>However, as we all know, a constant reference can be attached to a temporary object, as in</p>\n<pre><code>const int &amp;ri = 2 + 3;\n</code></pre>\n<p>In this case the reference is attached to the temporary, extending the lifetime of the latter. Obviously, once it is done, we have access to that very same temporary as an lvalue <code>ri</code>, since references are always lvalues. For example, we can easily and legally apply the unary <code>&amp;</code> to the reference and obtain a pointer to the temporary </p>\n<pre><code>const int *pi = &amp;ri;\n</code></pre>\n<p>with that pointer remaining perfectly valid as long as the temporary persists.</p>\n<p>Another obvious example of lvalue access to a temporary object is when we access a temporary object of class type through its <code>this</code> pointer. The result of <code>*this</code> is an lvalue (as is always the case with the result of unary <code>*</code> applied to a data pointer), yet it doesn't change the fact that the actual object might easily be a temporary. For a given class type <code>T</code>, expression <code>T()</code> is an rvalue, as explicitly stated in the language standard, yet the temporary object accessed through <code>*T().get_this()</code> expression (with the obvious implementation of <code>T::get_this()</code>) is an lvalue. Unlike the previous example, this method allows you to immediately obtain a non-const-qualified lvalue, which refers to a temporary object.</p>\n<p>So, once again, the very same temporary object might easily be \"seen\" as an rvalue or as an lvalue depending on what kind of expression (what kind of <em>access path</em>) you use to \"look\" at that object.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2010-01-27T09:58:59.507", "Score": "42", "CreationDate": "2010-01-27T09:51:18.837", "ParentId": "2145030", "CommentCount": "4", "OwnerUserId": "187690", "LastEditDate": "2010-01-27T09:58:59.507"}, "2145256": {"Id": "2145256", "PostTypeId": "2", "Body": "<p>It depends on what you consider a temporary variable is. You can write something like</p>\n<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    char carray[10];\n    char *c=carray+1;\n    *(c+2+4) = 9;\n    printf(\"%d\\n\",carray[7]);\n    return 0;\n}\n</code></pre>\n<p>This runs in VisualStudios and GCC. You can run the code in <a href=\"http://codepad.org/\" rel=\"nofollow noreferrer\">codepad</a></p>\n<p>I consider (c+2+4) a rvalue although i want to assign to it. When i dereference it, it would become an lvalue. So yes all temporaries are rvalues. But you can make rvalues (thus a temporary) into an lvalue by dereferencing it</p>\n", "LastEditorDisplayName": "user34537", "OwnerDisplayName": "user34537", "LastActivityDate": "2011-12-08T09:27:52.530", "Score": "0", "CreationDate": "2010-01-27T07:50:52.337", "ParentId": "2145030", "CommentCount": "7", "LastEditDate": "2011-12-08T09:27:52.530"}, "2145514": {"Id": "2145514", "PostTypeId": "2", "Body": "<p>Prasoon Saurav already linked a very good clc++ thread. In there, James Kanze explains why the question doesn't really make sense. It boils down to:</p>\n<ul>\n<li>rvalue-ness is a (boolean) property of expressions - each expression is either an lvalue or an rvalue</li>\n<li>temporaries are <em>not</em> expressions</li>\n</ul>\n<p>For that reason, the question doesn't make sense.</p>\n<p>A good example is the following code:</p>\n<pre><code>int main() {\n  const int&amp; ri = 4;\n  std::cout &lt;&lt; ri &lt;&lt; std::endl; \n}\n</code></pre>\n<p>The temporary int with value <code>4</code> is not an expression. The expression <code>ri</code> that's printed is not a temporary. It's an lvalue, and refers to a temporary. </p>\n", "LastActivityDate": "2010-01-27T08:51:04.973", "CommentCount": "11", "CreationDate": "2010-01-27T08:51:04.973", "ParentId": "2145030", "Score": "9", "OwnerUserId": "15416"}, "8413387": {"Id": "8413387", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_2145030_8413387_0\">If no, can anyone provide me an example where temporary produced in the code is an lvalue?</p>\n</blockquote>\n<p>The following code binds a constant reference to a temporary object of type <code>const float</code> created by the compiler:</p>\n<pre><code>int i;\nconst float &amp;cfr = i;\n</code></pre>\n<p>The behaviour is \"<em>as if</em>\":</p>\n<pre><code>int i;\nconst float __tmp_cfr = i; // introduced by the compiler\nconst float &amp;cfr = __tmp_cfr;\n</code></pre>\n", "LastEditorUserId": "963864", "LastActivityDate": "2011-12-08T17:01:17.693", "Score": "-3", "CreationDate": "2011-12-07T09:55:27.673", "ParentId": "2145030", "CommentCount": "9", "OwnerUserId": "963864", "LastEditDate": "2011-12-08T17:01:17.693"}, "2145192": {"Id": "2145192", "PostTypeId": "2", "Body": "<p>well, that array operator returns a reference, any function that returns a reference could be considered to do the same thing? all references are const, while they can be lvalues, they modify what they reference, not the reference itself.  same is true for the <code>*</code>operator,</p>\n<p><code>*(a temp pointer) = val;</code></p>\n<p>I swear I used to use some compiler that would pass temp values to any function that took a reference,</p>\n<p>so you could go:</p>\n<pre><code>int Afunc()\n{\n   return 5;\n}\n\nint anotherFunc(int &amp; b)\n{\n    b = 34;\n}\n\n\nanotherFunc(Afunc());\n</code></pre>\n<p>can't find one that lets you do that now though, the reference has to be const in order to allow passing of temp values.</p>\n<pre><code>int anotherFunc(const int &amp; b);\n</code></pre>\n<p>anyway, references can be lvalues and temporary, the trick being the reference it's self is not modified, only what it references.</p>\n<p>if you count the<code>-&gt;</code> operator as an operator, then temporary pointers can be lvalues, but the same condition applies, its not the temp pointer that would be changed, but the thing that it points to.</p>\n", "LastEditorUserId": "165520", "LastActivityDate": "2010-01-27T11:48:13.903", "Score": "1", "CreationDate": "2010-01-27T07:32:35.207", "ParentId": "2145030", "CommentCount": "12", "OwnerUserId": "259846", "LastEditDate": "2010-01-27T11:48:13.903"}, "2145030": {"ViewCount": "3689", "Body": "<p>I have been coding in C++ for past few years. But there is one question that I have not been able to figure out. I want to ask, are all temporaries in C++, rvalues?</p>\n<p>If no, can anyone provide me an example where temporary produced in the code is an <strong>lvalue</strong>?</p>\n", "AcceptedAnswerId": "2145824", "Title": "Are all temporaries rvalues in C++?", "CreationDate": "2010-01-27T06:43:16.173", "Id": "2145030", "CommentCount": "5", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2011-12-07T12:59:44.797", "LastEditorUserId": "165520", "LastActivityDate": "2016-03-16T18:04:29.477", "Score": "32", "OwnerUserId": "165520", "Tags": "<c++><rvalue><temporaries>", "AnswerCount": "7"}, "bq_ids": {"n4140": {"so_2145030_2145460_0": {"length": 12, "quality": 1.0, "section_id": 480}}, "n3337": {"so_2145030_2145460_0": {"length": 12, "quality": 1.0, "section_id": 471}}, "n4659": {"so_2145030_2145460_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 502}}}, "2145460": {"Id": "2145460", "PostTypeId": "2", "Body": "<p>Short answer: yes, but I'm not going to quote the standard, because proving the point would require addressing every kind of temporary there is. By definition a temporary has a lifetime of one statement, so assigning things to one would be poor style at best.</p>\n<p>Interesting answer: Copy elision can make (often makes) a temporary object identical with an lvalue object. For example,</p>\n<pre><code>MyClass blah = MyClass( 3 ); // temporary likely to be optimized out\n</code></pre>\n<p>or</p>\n<pre><code>return MyClass( 3 ); // likely to directly initialize object in caller's frame\n</code></pre>\n<p><strong>Edit:</strong> as for the question of whether there is any temporary object in those cases, \u00a712.8/15 mentions</p>\n<blockquote>\n<p id=\"so_2145030_2145460_0\">the copy operation can be omitted by constructing the temporary object directly into the target of the omitted copy</p>\n</blockquote>\n<p>which would indicate that there is a temporary object which may be identical with an lvalue.</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2010-01-27T08:51:23.280", "Score": "0", "CreationDate": "2010-01-27T08:42:48.090", "ParentId": "2145030", "CommentCount": "1", "OwnerUserId": "153285", "LastEditDate": "2010-01-27T08:51:23.280"}, "2145145": {"Id": "2145145", "PostTypeId": "2", "Body": "<p>An array indexing operation is both a temporary and an lvalue, something like a[10] = 1 is an example of what you're looking for; the lvalue is a temporary, calculated pointer.</p>\n", "LastActivityDate": "2010-01-27T07:20:11.737", "CommentCount": "5", "CreationDate": "2010-01-27T07:20:11.737", "ParentId": "2145030", "Score": "0", "OwnerUserId": "241774"}});