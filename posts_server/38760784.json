post_cb({"38763375": {"ParentId": "38760784", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_38760784_38763375_0\">According to this (accepted) proposal, since C++17; as noexcept is part of function type, will the code above print <code>true</code>?</p>\n</blockquote>\n<p><strong>Yes.</strong></p>\n<p>The type of <code>f</code> will be deduced to <code>void(*)() noexcept</code> since the function-to-pointer conversion applied to <code>asdf</code> will preserve the <code>noexcept</code> property. A call to a <code>noexcept</code> function pointer certainly cannot throw an exception, unless one of its subexpressions does.</p>\n<p>For the exact wording, see <a href=\"http://eel.is/c++draft/expr.unary.noexcept#3\" rel=\"nofollow noreferrer\">[expr.unary.noexcept]/3</a> and <a href=\"http://eel.is/c++draft/except.spec#13\" rel=\"nofollow noreferrer\">[expect.spec]/13</a>. Note that the new wording in the latter paragraph from the C++17 draft comes from P0012R1, which is linked in the OP.</p>\n<blockquote>\n<p id=\"so_38760784_38763375_1\">The result of the <code>noexcept</code> operator is <code>true</code> if the set of potential exceptions of the expression ([except.spec]) is empty, and <code>false</code> otherwise.</p>\n<p id=\"so_38760784_38763375_2\">...</p>\n<ul>\n<li>If <code>e</code> is a function call ([expr.call]):\n  \n  <ul>\n<li>If its <em>postfix-expression</em> is a (possibly parenthesized) <em>id-expression</em> ([expr.prim.id]), class member access ([expr.ref]), or pointer-to-member operation ([expr.mptr.oper]) whose <em>cast-expression</em> is an <em>id-expression</em>, <em>S</em> is the set of types in the exception specification of the entity selected by the contained <em>id-expression</em> (after overload resolution, if applicable).\n  ...</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>So the set of potential exceptions of <code>f()</code> is the same as the set of types in the exception specification of <code>f</code>, which is empty since <code>f</code> is declared <code>noexcept</code>.</p>\n<p>Let's move on to the second question:</p>\n<blockquote>\n<p id=\"so_38760784_38763375_3\">The <code>noexcept</code> specifying seems ignored in C++14 or 11. Will this code work as intended in C++17?</p>\n</blockquote>\n<p>Your question seems to be: will <code>std::function&lt;void() noexcept&gt;</code> refuse to hold a function that can throw exceptions?</p>\n<p>I would say that it's <strong>unclear.</strong> In the present wording of the standard, <code>std::function&lt;void() noexcept&gt;</code> is not actually defined, just as <a href=\"https://stackoverflow.com/questions/25654186/trait-to-drop-const-from-a-member-function-type\"><code>std::function&lt;double(float) const&gt;</code> is not defined</a>. This was of course not an issue in C++14, since <code>noexcept</code> was not considered part of a function's type.</p>\n<p>Will <code>std::function&lt;void() noexcept&gt;</code> simply break in C++17? That's uncertain to me. Let's take a look at the current wording to guess what the behaviour \"should\" be.</p>\n<p>The standard requires the argument to the constructor of <code>std::function&lt;R(ArgTypes..)&gt;</code> to be \"Lvalue-Callable\" for argument types <code>ArgTypes...</code> and return type <code>R</code>, which <a href=\"http://eel.is/c++draft/func.wrap.func#2\" rel=\"nofollow noreferrer\">means</a>:</p>\n<blockquote>\n<p id=\"so_38760784_38763375_4\">A callable type ([func.def]) <code>F</code> is <em>Lvalue-Callable</em> for argument types <code>ArgTypes</code> and return type <code>R</code> if the expression <code>INVOKE(declval&lt;F&amp;&gt;(), declval&lt;ArgTypes&gt;()..., R)</code>, considered as an unevaluated operand (Clause [expr]), is well formed ([func.require]).</p>\n</blockquote>\n<p>Perhaps there should be an additional requirement that if the function type is <code>noexcept</code>, then <code>noexcept(INVOKE(...))</code> must be true as well. Nonetheless, this wording is not present in the current draft.</p>\n<p>In P0012R1, there is a comment that:</p>\n<blockquote>\n<p id=\"so_38760784_38763375_5\">It is an open issue how to propagate \"noexcept\" through <code>std::function</code>.</p>\n</blockquote>\n<p>My guess is that they mean that it is not clear how <code>std::function</code> could be implemented if this additional requirement were imposed. Hopefully, someone else can provide more details.</p>\n", "OwnerUserId": "481267", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:47:35.397", "Id": "38763375", "Score": "10", "CreationDate": "2016-08-04T09:21:35.820", "LastActivityDate": "2016-08-04T09:21:35.820"}, "38760784": {"CommentCount": "5", "AcceptedAnswerId": "38763375", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-08-04T07:16:30.427", "LastActivityDate": "2016-08-04T09:21:35.820", "LastEditDate": "2017-05-23T10:29:27.687", "ViewCount": "877", "FavoriteCount": "3", "Title": "How will C++17 exception specifier type system work?", "Id": "38760784", "Score": "19", "Body": "<p>Studying about \"noexcept specifier(and operator)\", I wrote a simple code. And I am surprised that this piece of code:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>void asdf() noexcept {}\nint main() \n{\n    auto f = asdf;\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; noexcept(f()) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>prints <code>false</code>, even function \"asdf\" is noexcept-specified. </p>\n<p>So while searching why this mysterious phenomenon is happening, I found C++17's \"exception specifier type system\"- <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/p0012r1.html\" rel=\"nofollow noreferrer\">P0012R1</a>.</p>\n<p>According to this (accepted) proposal, since C++17; as <code>noexcept</code> is part of function type, will the code above print <code>true</code>?</p>\n<p>And one more, in <a href=\"https://stackoverflow.com/questions/31602903/enforce-noexcept-on-stdfunction\">this</a> question's one line:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>std::function&lt;void() noexcept&gt; f\n</code></pre>\n<p>The <code>noexcept</code> specifying seems ignored in C++14 or 11.\nWill this code work as intended in C++17?</p>\n", "Tags": "<c++><c++11><c++14><c++1z><noexcept>", "OwnerUserId": "5841943", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_38760784_38763375_4": {"section_id": 4651, "quality": 0.7368421052631579, "length": 14}}, "n3337": {"so_38760784_38763375_4": {"section_id": 4462, "quality": 0.7368421052631579, "length": 14}}, "n4659": {"so_38760784_38763375_4": {"section_id": 6020, "quality": 0.7368421052631579, "length": 14}}}});