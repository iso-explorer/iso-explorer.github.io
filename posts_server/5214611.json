post_cb({"5214611": {"CommentCount": "3", "AcceptedAnswerId": "5214681", "PostTypeId": "1", "ClosedDate": "2011-03-07T01:50:19.860", "LastEditorUserId": "-1", "CreationDate": "2011-03-07T00:40:19.863", "LastActivityDate": "2011-03-07T01:12:13.700", "LastEditDate": "2017-05-23T11:45:18.377", "ViewCount": "996", "FavoriteCount": "1", "Title": "Unexpected order of evaluation (compiler bug?)", "Id": "5214611", "Score": "5", "Body": "<blockquote>\n<p id=\"so_5214611_5214611_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/4176328/undefined-behavior-and-sequence-points\">Undefined Behavior and Sequence Points</a> </br></p>\n</blockquote>\n<p>I'm not sure if this is a gcc bug or not, so I'll ask:</p>\n<pre><code>unsigned int n = 0;\nstd::cout &lt;&lt; n++ &lt;&lt; n &lt;&lt; ++n;\n</code></pre>\n<p>gcc gives the extremely strange result:\n\"122\" which AFAICT is impossible. Because &lt;&lt; is left associative, it should be the same as:</p>\n<pre><code>operator&lt;&lt;(operator&lt;&lt;(operator&lt;&lt;(std::cout, n++), n), ++n)\n</code></pre>\n<p>and because there is a sequence point before and after evaluating arguments, n is never modified twice (or even accessed) between two sequence points -- so it shouldn't be undefined behaviour, just the order of evaluation unspecified.</p>\n<p>So AFAICT valid results would be:\n111\n012\n002\n101</p>\n<p>and nothing else</p>\n", "Tags": "<c++><gcc><compiler-construction><order-of-evaluation>", "OwnerUserId": "647445", "AnswerCount": "3"}, "5214673": {"ParentId": "5214611", "CommentCount": "0", "Body": "<p>Your code its an example of why in some books remark that experienced programmers don't like <strong>that</strong>(++,--) operator overload, even other languages (ruby) has not implemented ++ or --.</p>\n", "OwnerUserId": "622465", "PostTypeId": "2", "Id": "5214673", "Score": "-3", "CreationDate": "2011-03-07T00:54:08.123", "LastActivityDate": "2011-03-07T00:54:08.123"}, "5214652": {"ParentId": "5214611", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The first rule of compiler bugs: it's probably not a compiler bug but a misunderstanding on your part. Using the postfix and prefix operators in the same statement results in undefined behavior. Try using the <code>-Wall</code> option to give you more warnings and show you the potential pitfalls in your code.</p>\n<p>Let's see what GCC 4.2.1 tells us when we ask for warnings about <code>test.cpp</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    unsigned int n = 0;\n    std::cout &lt;&lt; n++ &lt;&lt; n &lt;&lt; ++n &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>When we compile:</p>\n<pre><code>$ g++ -Wall test.cpp -o test\ntest.cpp: In function \u2018int main()\u2019:\ntest.cpp:5: warning: operation on \u2018n\u2019 may be undefined\n</code></pre>\n", "OwnerUserId": "118160", "LastEditorUserId": "118160", "LastEditDate": "2011-03-07T01:01:55.917", "Id": "5214652", "Score": "4", "CreationDate": "2011-03-07T00:48:30.100", "LastActivityDate": "2011-03-07T01:01:55.917"}, "bq_ids": {"n4140": {"so_5214611_5214681_0": {"section_id": 5809, "quality": 0.6666666666666666, "length": 10}, "so_5214611_5214681_1": {"section_id": 5811, "quality": 0.9076923076923077, "length": 59}}, "n3337": {"so_5214611_5214681_0": {"section_id": 5582, "quality": 0.6666666666666666, "length": 10}, "so_5214611_5214681_1": {"section_id": 5584, "quality": 0.9076923076923077, "length": 59}}, "n4659": {"so_5214611_5214681_0": {"section_id": 7270, "quality": 0.6666666666666666, "length": 10}, "so_5214611_5214681_1": {"section_id": 7272, "quality": 0.8153846153846154, "length": 53}}}, "5214681": {"ParentId": "5214611", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>There is a sequence point between evaluating arguments and calling a function.  There is no sequence point between evaluating different arguments.</p>\n<p>Let's look at the outermost function call:</p>\n<pre><code>operator&lt;&lt;(operator&lt;&lt;(operator&lt;&lt;(std::cout, n++), n), ++n)\n</code></pre>\n<p>The arguments are</p>\n<ul>\n<li><code>operator&lt;&lt;(operator&lt;&lt;(std::cout, n++), n)</code></li>\n</ul>\n<p>and</p>\n<ul>\n<li><code>++n</code></li>\n</ul>\n<p>It is unspecified which of these is evaluated first.  It's also allowed that the first argument is partially evaluated when the second argument is evaluated.</p>\n<p>From the standard, section <code>[intro.execution]</code> (wording from draft 3225):</p>\n<blockquote>\n<ul>\n<li><p id=\"so_5214611_5214681_0\">If <em>A</em> is not sequenced before\n  <em>B</em> and <em>B</em> is not sequenced before <em>A</em>, then <em>A</em> and <em>B</em> are <em>unsequenced</em>.  [ <em>Note:</em>  The execution of unsequenced\n  evaluations can overlap.   \u2014 <em>end note</em> ]</p></li>\n<li><p id=\"so_5214611_5214681_1\">Except where noted, evaluations of operands of individual operators and of subexpressions of individual\n  expressions are unsequenced. [ <em>Note:</em> In an expression that is evaluated more than once during the execution\n  of a program, unsequenced and indeterminately sequenced evaluations of its subexpressions need not be\n  performed consistently in di\ufb00erent evaluations.  \u2014 <em>end note</em> ] The value computations of the operands of an\n  operator are sequenced before the value computation of the result of the operator. If a side effect on a scalar\n  object is unsequenced relative to either another side effect on the same scalar object or a value computation\n  using the value of the same scalar object, the behavior is unde\ufb01ned.</p></li>\n</ul>\n</blockquote>\n<p>Because you have multiple operations with side effects on the same scalar object which are unsequenced with respect to each other, you're in that realm of undefined behavior, and even <code>999</code> would be a permissible output.</p>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2011-03-07T01:12:13.700", "Id": "5214681", "Score": "9", "CreationDate": "2011-03-07T00:55:30.540", "LastActivityDate": "2011-03-07T01:12:13.700"}});