post_cb({"20041044": {"CommentCount": "0", "ViewCount": "296", "PostTypeId": "1", "LastEditorUserId": "3003414", "CreationDate": "2013-11-18T05:55:35.240", "LastActivityDate": "2013-11-18T21:42:28.820", "Title": "Template recursion in forward order (about iteration over std::tuple) by template function overloading", "AcceptedAnswerId": "20057950", "LastEditDate": "2013-11-18T12:18:48.080", "Id": "20041044", "Score": "2", "Body": "<p>I wrote code for iteration over std::tuple using several approach (of curiosity). I successfully used std::enable_if approach, static class-function with template specialization, template function overloading, etc. \nFor function overloading I wrote the following:</p>\n<pre><code>template&lt;size_t N&gt; struct SizeT{};\n\ntemplate&lt;typename Tuple&gt;\nvoid print(Tuple, SizeT&lt;0&gt;){}\n\ntemplate&lt;typename Tuple, size_t N&gt;\nvoid print(Tuple t, SizeT&lt;N&gt;)\n{\n    print(t,SizeT&lt;N-1&gt;());\n    std::cout &lt;&lt; std::get&lt;N-1&gt;(t) &lt;&lt; ' ';\n}\n\ntemplate&lt;typename Tuple&gt;\nvoid print(Tuple t){\n    print(t, SizeT&lt;std::tuple_size&lt;Tuple&gt;::value&gt;());\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre>\n<p>It's work fine. But I tried forward order in template recursion:</p>\n<pre><code>template&lt;size_t N&gt; struct SizeT{};\n\ntemplate&lt;typename Tuple, size_t N&gt;\nvoid print(Tuple t, SizeT&lt;N&gt;) {\n    std::cout &lt;&lt; std::get&lt;N&gt;(t) &lt;&lt; ' ';\n    print(t,SizeT&lt;N+1&gt;());\n}\n\ntemplate&lt;typename Tuple&gt;\nvoid print(Tuple, SizeT&lt; std::tuple_size&lt;Tuple&gt;::value &gt;){\n    std::cout &lt;&lt; std::endl;\n}\n\ntemplate&lt;typename Tuple&gt;\nvoid print(Tuple t) {\n    print(t,SizeT&lt;0&gt;());\n}\n</code></pre>\n<p>There are compilation error about ambiguous call:</p>\n<pre><code>call of overloaded 'print(std::tuple&lt;A&lt;int&gt;&amp;, A&lt;int&gt;&amp;, A&lt;long long int&gt;&amp;, A&lt;long int&gt;&amp;&gt;&amp;, forward_first::SizeT&lt;4u&gt;)' is ambiguous\n     print(t,SizeT&lt;N+1&gt;());\ncandidates are:\nvoid forward_first::print(Tuple, forward_first::SizeT&lt;N&gt;) [with Tuple = std::tuple&lt;A&lt;int&gt;&amp;, A&lt;int&gt;&amp;, A&lt;long long int&gt;&amp;, A&lt;long int&gt;&amp;&gt;; unsigned int N = 4u]\n void print(Tuple t, SizeT&lt;N&gt;)\nvoid forward_first::print(Tuple, forward_first::SizeT&lt;std::tuple_size&lt;Tuple&gt;::value&gt;) [with Tuple = std::tuple&lt;A&lt;int&gt;&amp;, A&lt;int&gt;&amp;, A&lt;long long int&gt;&amp;, A&lt;long int&gt;&amp;&gt;]\n void print(Tuple, SizeT&lt; std::tuple_size&lt;Tuple&gt;::value &gt;)\n</code></pre>\n<p>But if replace std::tuple_size::value by actual constant (e.g. 3 literal), then it's work:</p>\n<pre><code>template&lt;size_t N&gt; struct SizeT{};\n\ntemplate&lt;typename Tuple, size_t N&gt;\nvoid print(Tuple t, SizeT&lt;N&gt;) {\n    std::cout &lt;&lt; std::get&lt;N&gt;(t) &lt;&lt; ' ';\n    print(t,SizeT&lt;N+1&gt;());\n}\n\ntemplate&lt;typename Tuple&gt;\nvoid print(Tuple, SizeT&lt;3&gt;){\n    std::cout &lt;&lt; std::endl;\n}\n\ntemplate&lt;typename Tuple&gt;\nvoid print(Tuple t) {\n    print(t,SizeT&lt;0&gt;());\n}\n</code></pre>\n<p>Why call with std::tuple_size::value ambiguous? \nWhy function     </p>\n<pre><code>template&lt;typename Tuple&gt;\nvoid print(Tuple, SizeT&lt; std::tuple_size&lt;Tuple&gt;::value &gt;)\n</code></pre>\n<p><strong>no more specialized</strong> then </p>\n<pre><code>template&lt;typename Tuple, size_t N&gt;\nvoid print(Tuple t, SizeT&lt;N&gt;)\n</code></pre>\n<p>??</p>\n", "Tags": "<c++><templates><c++11><recursion><overloading>", "OwnerUserId": "3003414", "AnswerCount": "1"}, "20057950": {"ParentId": "20041044", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The problem is that you have a nested <code>value</code> inside <code>std::tuple_size</code> that acts surprisingly. A quick rule of thumb in template argument deduction is that anything after a <code>::</code> is opaque to the compiler. The surprising thing here is that it happens not during the argument deduction phase itself (both overloads have their own arguments properly deduced), but by the deduction of one overload's parameters from the other overload's synthesized arguments during the phase of overload resolution. </p>\n<p><strong>14.8.2.4 Deducing template arguments during partial ordering [temp.deduct.partial]</strong></p>\n<blockquote>\n<p id=\"so_20041044_20057950_0\">2 Two sets of types are used to determine the partial ordering. For\n  each of the templates involved there is the original function type and\n  the transformed function type. [ Note: The creation of the transformed\n  type is described in 14.5.6.2. \u2014 end note ] The deduction process uses\n  the transformed type as the argument template and the original type of\n  the other template as the parameter template. This process is done\n  twice for each type involved in the partial ordering comparison: once\n  using the transformed template-1 as the argument template and\n  template-2 as the parameter template and again using the transformed\n  template-2 as the argument template and template-1 as the parameter\n  template.</p>\n</blockquote>\n<p>So given your two overloads</p>\n<pre><code>// #1\ntemplate&lt;typename Tuple&gt;\nvoid print(Tuple, SizeT&lt; std::tuple_size&lt;Tuple&gt;::value &gt;)\n\n// #2\ntemplate&lt;typename Tuple, size_t N&gt;\nvoid print(Tuple t, SizeT&lt;N&gt;)\n</code></pre>\n<p>It is clear that the first has no 2nd template parameter to deduce and so it is at least as specialized as the second overload. The question is whether the second can have it's <code>N</code> parameter deduced from the first overloads' synthesized 2nd argument. </p>\n<p>The reason that argument deduction does not take place it is a non-deduced context:</p>\n<p><strong>14.8.2.5 Deducing template arguments from a type [temp.deduct.type]</strong></p>\n<blockquote>\n<p id=\"so_20041044_20057950_1\">5 The non-deduced contexts are: </p>\n<p id=\"so_20041044_20057950_2\">\u2014 ... </p>\n<p id=\"so_20041044_20057950_3\">\u2014 <strong>A non-type template argument or an array bound in which a subexpression references a template parameter.</strong></p>\n<p id=\"so_20041044_20057950_4\">\u2014 ... </p>\n</blockquote>\n<p>This means that the second overload is also at least as specialized as the first one. Hence, overload resolution is not able to select one, and the program is ill-formed.</p>\n<p>Note: a similar problem (with 3 overloads and ambiguities only for certain values of <code>N</code> appears <a href=\"https://stackoverflow.com/a/19406528/819272\">in this Q&amp;A</a>).</p>\n", "OwnerUserId": "819272", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:28:46.213", "Id": "20057950", "Score": "1", "CreationDate": "2013-11-18T21:09:40.697", "LastActivityDate": "2013-11-18T21:42:28.820"}, "bq_ids": {"n4140": {"so_20041044_20057950_0": {"section_id": 321, "quality": 0.8823529411764706, "length": 60}, "so_20041044_20057950_3": {"section_id": 336, "quality": 1.0, "length": 9}}, "n3337": {"so_20041044_20057950_0": {"section_id": 311, "quality": 0.8823529411764706, "length": 60}, "so_20041044_20057950_3": {"section_id": 326, "quality": 1.0, "length": 9}}, "n4659": {"so_20041044_20057950_0": {"section_id": 329, "quality": 0.8823529411764706, "length": 60}, "so_20041044_20057950_3": {"section_id": 345, "quality": 1.0, "length": 9}}}});