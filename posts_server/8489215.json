post_cb({"8489280": {"ParentId": "8489215", "CommentCount": "0", "Body": "<p>It is confusing, but this is the only way to get access to <code>type</code> variable.\nIf you want to use <code>type</code> type you can do:</p>\n<pre><code>typedef int type;\nint main() {\n    type *type;\n    ::type *k ;\n    return 0;\n} \n</code></pre>\n<p>Most of those grammar monstrosities come from backward compatibility with C.</p>\n", "OwnerUserId": "259371", "PostTypeId": "2", "Id": "8489280", "Score": "3", "CreationDate": "2011-12-13T12:31:34.923", "LastActivityDate": "2011-12-13T12:31:34.923"}, "8489384": {"ParentId": "8489215", "CommentCount": "1", "Body": "<p>The rationale of keeping namespaces (not in the C++ sense, but in variable/type namespace) separate is fairly obvious: When you don't pollute the variable namespace with type names, less code breaks on typedef.</p>\n<p>Suppose there was pre-existing code with a variable named \"employee\". If variables and typedefs lived in the same namespace, a \"typedef struct {} employee;\" would break the existing code, requiring a change of the variable name (which was more of an issue in pre-IDE days). However, if they do <em>not</em> share a namespace, there is no problem and people have one less issue to worry about when choosing type names in large code bases.</p>\n", "OwnerUserId": "847601", "PostTypeId": "2", "Id": "8489384", "Score": "1", "CreationDate": "2011-12-13T12:38:40.483", "LastActivityDate": "2011-12-13T12:38:40.483"}, "8489530": {"ParentId": "8489215", "CommentCount": "5", "Body": "<p>The question is actually about when exactly a variable name is defined as an identifier, and the language determines that it is right after the point in code where the variable is declared:</p>\n<pre><code>typedef int type;\nint main() {\n   type t;   // type refers to ::type\n   int       // type still refers to ::type\n   type;     // variable declared, this shadows ::type\n   type + 1; // type is a variable of type int.\n}\n</code></pre>\n<p>There are similar rules in other contexts, and it is just a matter of deciding when identifiers are declared. There are other similar situations, for example in the initialization list of a class:</p>\n<pre><code>struct test {\n   int x;          // declare member\n   test( int x )   // declare parameter (shadows member)\n   : x(            // refers to member (parameter is not legal here)\n        x )        // refers to parameter\n   {};\n};\n</code></pre>\n<p>Or in the scope of the identifiers in the definition of member functions:</p>\n<pre><code>struct test {\n   typedef int type;\n   type f( type );\n};\ntest::type         // qualification required, the scope of the return type is\n                   // at namespace level\ntest::f(\n         type t )  // but the scope of arguments is the class, no qualification\n                   // required.\n{}\n</code></pre>\n<p>As of the rationale for the decision, I cannot tell you but it is consistent and simple.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "8489530", "Score": "15", "CreationDate": "2011-12-13T12:49:31.080", "LastActivityDate": "2011-12-13T12:49:31.080"}, "8489499": {"ParentId": "8489215", "CommentCount": "4", "Body": "<pre><code>type *type; // why is it allowed?\n</code></pre>\n<p>C++11 3.3.2/1 says:</p>\n<blockquote>\n<p id=\"so_8489215_8489499_0\">The point of declaration for a name is immediately after its complete declarator (Clause 8) and before its initializer (if any)</p>\n</blockquote>\n<p>So the variable name <code>type</code> is not introduced until after the use of the type name <code>type</code>; the type name is the only available meaning of <code>type</code> during the declarator.</p>\n<pre><code>type *k ;// which type?\n</code></pre>\n<p>The local variable name hides the global type name, so that is chosen here. This is described in C++11 3.3.10/1:</p>\n<blockquote>\n<p id=\"so_8489215_8489499_1\">A name can be hidden by an explicit declaration of that same name in a nested declarative region or derived class.</p>\n</blockquote>\n<p>The fully qualified type name, <code>::type</code>, is of course still available.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "8489499", "Score": "23", "CreationDate": "2011-12-13T12:47:09.387", "LastActivityDate": "2011-12-13T12:47:09.387"}, "8489305": {"ParentId": "8489215", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>I think it is allowed probably because it provides flexibility for programmers when choosing name for the variables they declare. In C#, you could declare property of same name as the type:</p>\n<pre><code>//C# code\nclass Manager\n{\n   public Name Name {get;set;}\n};\n</code></pre>\n<p>When I code in C#, I find this feature very useful. Because I've more options for names to choose from. Otherwise, if I've a type called <code>Name</code>, then I wouldn't be able to create a property of the same name, I would be <em>forced</em> to choose a different name, say <code>Name_</code>, <code>_Name</code>, <code>name</code>, <code>NAME</code> etc - all of which don't appeal to me.</p>\n<hr>\n<p>As for your code, since in the scope (after declaration of <em>object</em> <code>type</code>), <code>type</code> is already a variable, the <em>type</em> `type cannot be referred to directly. But I think this should compile fine and according to the Standard:</p>\n<pre><code>typedef int type;\nint main()\n{\n   type *type; // why is it allowed?\n   ::type *k ;// which type?\n}\n</code></pre>\n<p>Demo : <a href=\"http://ideone.com/chOov\" rel=\"nofollow\">http://ideone.com/chOov</a></p>\n</hr>", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-12-13T12:38:31.603", "Id": "8489305", "Score": "0", "CreationDate": "2011-12-13T12:33:19.997", "LastActivityDate": "2011-12-13T12:38:31.603"}, "8489215": {"CommentCount": "7", "AcceptedAnswerId": "8489530", "PostTypeId": "1", "LastEditorUserId": "165520", "CreationDate": "2011-12-13T12:25:38.587", "LastActivityDate": "2011-12-13T12:49:31.080", "LastEditDate": "2011-12-13T12:31:05.073", "ViewCount": "1196", "FavoriteCount": "7", "Title": "Understanding confusing typedef grammar", "Id": "8489215", "Score": "41", "Body": "<p>Consider the following code-snippet</p>\n<pre><code>typedef int type;\nint main()\n{\n   type *type; // why is it allowed?\n   type *k ;// which type?\n}\n</code></pre>\n<p>I get an error <code>'k' is not declared in this scope</code>. The compiler parses <code>type *k</code> as multiplication between <code>type*</code> and <code>k</code>. Isn't this grammar very confusing?</p>\n<p>Why is <code>type *type</code> allowed by the C++ Standard? Because the grammar says so? Why?</p>\n", "Tags": "<c++><c><typedef><language-lawyer>", "OwnerUserId": "165520", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_8489215_8489499_0": {"section_id": 7049, "quality": 0.8461538461538461, "length": 11}, "so_8489215_8489499_1": {"section_id": 7078, "quality": 1.0, "length": 12}}, "n3337": {"so_8489215_8489499_0": {"section_id": 6794, "quality": 0.8461538461538461, "length": 11}, "so_8489215_8489499_1": {"section_id": 6822, "quality": 1.0, "length": 12}}, "n4659": {"so_8489215_8489499_1": {"section_id": 8579, "quality": 1.0, "length": 12}, "so_8489215_8489499_0": {"section_id": 8546, "quality": 0.8461538461538461, "length": 11}}}});