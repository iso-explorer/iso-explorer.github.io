post_cb({"bq_ids": {"n4140": {"so_34410668_34411525_0": {"length": 14, "quality": 1.0, "section_id": 6304}}, "n3337": {"so_34410668_34411525_0": {"length": 14, "quality": 1.0, "section_id": 6061}}, "n4659": {"so_34410668_34411525_0": {"length": 14, "quality": 1.0, "section_id": 7814}}}, "34411525": {"Id": "34411525", "PostTypeId": "2", "Body": "<p>You are experiencing effects of undefined behavior, but I think you know this. You cannot rely on the effects of byte-wise copying non-POD resp. not trivially copyable types, and the compiler is free to change that behavior.</p>\n<p>I think it may be possible to define a safe overload for <code>memmove</code> with your class as arguments and use the copy-constructor inside it. I don't know if that is strictly legal, but you seem to be using the C-function instead of the C++ version in namespace <code>std</code>, so at least you are not changing namespace <code>std</code> which is not allowed. </p>\n<pre><code>void memmove(MyClass* a, MyClass* b, size_t)\n{\n    *a = *b;\n}\n</code></pre>\n<p>Strictly speaking, I think this is still undefined behavior because 17.6.4.3 of the C++ standard specifies that</p>\n<blockquote>\n<p id=\"so_34410668_34411525_0\">If a program declares or defines a name in a context where it is\n  reserved, other than as explicitly allowed by this Clause, its\n  behavior is undefined.</p>\n</blockquote>\n<p>In addition, all names in C library are reserved names and shall not be used by the program (17.6.4.3.2). Practically, I think this will work.</p>\n<p>You may need to compile with <code>-fno-builtin</code> to prevent gcc from replacing <code>memmove</code> globally. If it is illegal to overwrite the function, you can replace it dynamically with <code>LD_PRELOAD</code>.</p>\n<p>This is a hack solution! Your code may still not work because the compiler makes the assumption that, when you <code>memmove</code> it is a POD/TriviallyCopyable object and uses that for some optimisation, e.g. by assuming that after the <code>memmove</code>, both objects are represented by identical bytes. This is broken when you re-implement <code>memmove</code> with the copy-constructor. </p>\n", "LastEditorUserId": "2169853", "LastActivityDate": "2015-12-22T10:22:23.663", "Score": "1", "CreationDate": "2015-12-22T08:34:34.310", "ParentId": "34410668", "CommentCount": "0", "OwnerUserId": "2169853", "LastEditDate": "2015-12-22T10:22:23.663"}, "34410668": {"ViewCount": "103", "Body": "<p>I have program that uses <code>std::string</code>, but <code>memmove</code> the std::string` instances.</p>\n<p>It worked fine until gcc 5.1.</p>\n<p>However this no longer works as of gcc 5.3. I think developers finally did SSO with internal pointer.</p>\n<p>I will definitely fix that, but is there easy way to fix it with some define or pragma?</p>\n<p>Code looks similar to this:</p>\n<pre><code>// MyClass have std::string inside\nMyClass *a = malloc(MAX * sizeof(MyClass));\n// ...\n// placement new on a[0]\n// ...\nmemmove(&amp;a[1], &amp;a[0], sizeof(MyClass));\n// ...\nprocess(a[1]);\n</code></pre>\n<p>This is old code, please do not comment about <code>malloc</code> usage.</p>\n<p>I will refactor or switch to <code>std::vector</code>, but I want the code to work until I do so.</p>\n", "Title": "Using old std::string in gcc", "CreationDate": "2015-12-22T07:36:05.480", "LastActivityDate": "2015-12-22T10:22:23.663", "CommentCount": "9", "LastEditDate": "2015-12-22T08:00:29.277", "PostTypeId": "1", "LastEditorUserId": "964080", "Id": "34410668", "Score": "1", "OwnerUserId": "964080", "Tags": "<string><c++11><gcc>", "AnswerCount": "1"}});