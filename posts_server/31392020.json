post_cb({"31392020": {"CommentCount": "5", "ViewCount": "154", "PostTypeId": "1", "LastEditorUserId": "671092", "CreationDate": "2015-07-13T19:40:47.207", "LastActivityDate": "2015-07-13T22:05:28.427", "Title": "Taking the address of an overloaded function template is possible, sometimes", "FavoriteCount": "1", "LastEditDate": "2015-07-13T19:58:38.720", "Id": "31392020", "Score": "8", "Body": "<p>On <code>gcc 4.9.0</code>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nstruct A\n{\n    typedef int type;\n};\n\ntemplate&lt;typename T&gt; void foo(T*) { std::cout &lt;&lt; \"a\" &lt;&lt; std::endl; }\ntemplate&lt;typename T&gt; void foo(typename T::type*) { std::cout &lt;&lt; \"b\" &lt;&lt; std::endl; }\n\ntemplate&lt;typename T&gt;\nstruct identity\n{\n    typedef T type;\n};\n\ntemplate&lt;typename T&gt; void bar(T*) { std::cout &lt;&lt; \"a\" &lt;&lt; std::endl; }\ntemplate&lt;typename T&gt; void bar(typename identity&lt;T&gt;::type*) { std::cout &lt;&lt; \"b\" &lt;&lt; std::endl; }\n\nint main()\n{\n    //auto f = foo&lt;A&gt;; // ambiguous\n    foo&lt;A&gt;(0); // prints \"b\", as the second overload is more specific\n\n    auto b = bar&lt;A&gt;; // fine\n    bar&lt;A&gt;(0); // prints \"b\", as the second overload is more specific (?)\n    b(0); // prints \"b\"\n\n    return 0;\n}\n</code></pre>\n<p>Any clue on why the address <strong>can</strong> be taken, in the second case?</p>\n", "Tags": "<c++><templates><language-lawyer><overload-resolution>", "OwnerUserId": "671092", "AnswerCount": "1"}, "31392265": {"ParentId": "31392020", "LastEditDate": "2015-07-13T22:05:28.427", "CommentCount": "7", "CreationDate": "2015-07-13T19:55:25.050", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "PostTypeId": "2", "Id": "31392265", "Score": "3", "Body": "<p>The deduction for <code>auto</code> is the same as template deduction. From [dcl.spec.auto]:</p>\n<blockquote>\n<p id=\"so_31392020_31392265_0\">When a variable declared using a placeholder type is initialized, [...], the deduced return type or variable type is\n  determined from the type of its initializer. If the placeholder is the auto type-specifier,\n  the deduced type is determined using the rules for template argument deduction. If the placeholder is the <code>auto</code> <em>type-specifier</em>,\n  the deduced type is determined using the rules for template argument deduction.</p>\n</blockquote>\n<p>So when we have either:</p>\n<pre><code>auto f = foo&lt;A&gt;;\nauto b = bar&lt;A&gt;;\n</code></pre>\n<p>We are performing type deduction as if we called (to borrow T.C.'s choice of words):</p>\n<pre><code>template &lt;typename M&gt; void meow(M );\nmeow(foo&lt;A&gt; );\nmeow(bar&lt;A&gt; );\n</code></pre>\n<p>and using the deduced type <code>M</code> as the type of <code>f</code> and <code>b</code>, respectively. </p>\n<p>But, according to [temp.deduct.type], emphasis mine: </p>\n<blockquote>\n<p id=\"so_31392020_31392265_1\">If a template parameter is used only in non-deduced\n  contexts and is not explicitly specified, template argument deduction fails.</p>\n<p id=\"so_31392020_31392265_2\">The non-deduced contexts are:<br>\n  \u2014 [...]<br>\n  \u2014 A function parameter for which argument deduction cannot be done because the associated function\n  argument is a function, or <strong>a set of overloaded functions</strong> (13.4), and one or more of the following apply:<br>\n  \u00a0\u00a0\u00a0\u00a0\u2014 <strong>more than one function matches the function parameter type (resulting in an ambiguous deduction)</strong>,\n  or<br>\n  \u00a0\u00a0\u00a0\u00a0\u2014 no function matches the function parameter type, or<br>\n  \u00a0\u00a0\u00a0\u00a0\u2014 the set of functions supplied as an argument contains one or more function templates.<br>\n  \u2014 [...]  </br></br></br></br></br></br></p>\n</blockquote>\n<p>In both cases, the argument is a set of overloaded functions which contains one or more function templates - which makes it a non-deduced context, so template argument deduction fails. Thus, clang is correct in rejecting both initializations.</p>\n", "LastActivityDate": "2015-07-13T22:05:28.427"}, "bq_ids": {"n4140": {"so_31392020_31392265_2": {"section_id": 336, "quality": 0.9574468085106383, "length": 45}, "so_31392020_31392265_0": {"section_id": 5451, "quality": 0.868421052631579, "length": 33}, "so_31392020_31392265_1": {"section_id": 335, "quality": 1.0, "length": 10}}, "n3337": {"so_31392020_31392265_2": {"section_id": 326, "quality": 0.9574468085106383, "length": 45}, "so_31392020_31392265_0": {"section_id": 5245, "quality": 0.5263157894736842, "length": 20}, "so_31392020_31392265_1": {"section_id": 325, "quality": 1.0, "length": 10}}, "n4659": {"so_31392020_31392265_2": {"section_id": 345, "quality": 0.9574468085106383, "length": 45}, "so_31392020_31392265_1": {"section_id": 344, "quality": 1.0, "length": 10}}}});