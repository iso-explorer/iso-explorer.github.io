post_cb({"bq_ids": {"n4140": {"so_40063336_40075906_0": {"length": 10, "quality": 1.0, "section_id": 92}}, "n3337": {"so_40063336_40075906_0": {"length": 10, "quality": 1.0, "section_id": 87}}, "n4659": {"so_40063336_40075906_0": {"length": 10, "quality": 1.0, "section_id": 95}}}, "40075906": {"Id": "40075906", "PostTypeId": "2", "Body": "<p>The issue is the following: According to the standard, [temp.arg.template]/1,</p>\n<blockquote>\n<p id=\"so_40063336_40075906_0\">[a] template-argument for a template template-parameter shall be the name of a class template or an alias\n  template, expressed as id-expression.</p>\n</blockquote>\n<p>Therefore you can't instantiate the template </p>\n<pre><code>template&lt;template&lt;class...&gt; class F&gt;\nstatic void add(const std::string name) {\n    handler_provider&lt;Ts...&gt;::add&lt;F&lt;Ts...&gt;&gt;(name);\n}\n</code></pre>\n<p>with the function template <code>test_handler</code>.</p>\n<p>To fix this you have to make <code>test_handler</code> a templated functor instead, i.e. change it to</p>\n<pre><code>template&lt;class A, class B&gt;\nstruct test_handler {\n    void operator()(int v) {\n        // Something here A and B are needed\n        std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \" called with v = \" &lt;&lt; v &lt;&lt; std::endl;\n    }\n};\n</code></pre>\n<p>Unfortunately, now this is no longer of type <code>void(*)(int)</code> so you can't insert it into the <code>unordered_map</code>. Therefore you have to change the elements in the map to <code>std::function&lt;function_type&gt;</code> and adjust the <code>add</code> overload for templated functors to</p>\n<pre><code>// Overload for templates, such as 'test_handler'\ntemplate&lt;template&lt;class...&gt; class F&gt;\nstatic void add(const std::string name) {\n    fn_handlers[name] = F&lt;Ts...&gt;{};\n}\n</code></pre>\n<p>The full code now looks like this:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n\n// Handler typ\nusing function_type = void(int);\n\n// Dispatch table\nstd::unordered_map&lt;std::string, std::function&lt;function_type&gt;&gt; fn_handlers;\n\n// Handler provider (to install new handlers)\ntemplate&lt;class... Ts&gt;\nstruct handler_provider {\n    // Overload for templates, such as 'test_handler'\n    template&lt;template&lt;class...&gt; class F&gt;\n    static void add(const std::string name) {\n        fn_handlers[name] = F&lt;Ts...&gt;{};\n    }\n\n    // Overload for non-template (or already specialized) handlers (aka. function pointers)\n    template&lt;function_type F&gt;\n    static void add(const std::string name) {\n        fn_handlers[name] = F;\n    }\n};\n\ntemplate&lt;class A, class B&gt;\nstruct test_handler {\n    void operator()(int v) {\n        // Something here A and B are needed\n        std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \" called with v = \" &lt;&lt; v &lt;&lt; std::endl;\n    }\n};\n\nvoid other_handler(int v) {\n    // A handler without specialization\n    std::cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; \" called with v = \" &lt;&lt; v &lt;&lt; std::endl;\n}\n\nint main() {\n    // Install handlers\n    handler_provider&lt;int, int&gt;::add&lt;test_handler&gt;(\"testii\");\n    handler_provider&lt;double, int&gt;::add&lt;test_handler&gt;(\"testdi\");\n    handler_provider&lt;bool, bool, int&gt;::add&lt;other_handler&gt;(\"otherbbi\");\n\n    // Dispatch\n    fn_handlers[\"testii\"](5); // Sould call test_handler&lt;int, int&gt;\n    fn_handlers[\"testdi\"](5); // Should call test_handler&lt;double, int&gt;\n\n    fn_handlers[\"otherbbi\"](5); // Should call other_handler\n}\n</code></pre>\n<p>This does exactly what you want, as can be seen in this <a href=\"http://coliru.stacked-crooked.com/a/ba82ad98684a68e9\" rel=\"nofollow\">coliru</a>.</p>\n<p>If you don't want to use <code>std::function</code> because of the overhead (on my platform <code>std::function</code> uses 32 bytes instead of 8 bytes for a pointer) you can also just write your own type erasure struct for the handlers.</p>\n", "LastEditorUserId": "3601321", "LastActivityDate": "2016-10-16T23:06:33.033", "Score": "1", "CreationDate": "2016-10-16T21:57:01.843", "ParentId": "40063336", "CommentCount": "2", "OwnerUserId": "3601321", "LastEditDate": "2016-10-16T23:06:33.033"}, "40063336": {"ViewCount": "208", "Body": "<p>I am attempting to write a small script interpreter that is extensible via c++. For that purpose function handlers are inserted into a dispatch table.\nTo simplyfy my question, the handlertype is defined as follows (in the real code, this contains parameters for an argument-list and return type):</p>\n<pre><code>// Handler type\nusing function_type = void(int);\n</code></pre>\n<p>The dispatch table, for now, is a simple unordered map with a (kind of) mangled name as key to implement overloading:</p>\n<pre><code>// Dispatch table\nstd::unordered_map&lt;std::string, function_type*&gt; fn_handlers;\n</code></pre>\n<p>Methods are added to this table either direct, e.g. like a simple method that takes two arguments of type <code>int</code> (<code>operator+ii</code> is the manged name for this in my case):</p>\n<pre><code>fn_handlers[\"operator+ii\"] = my_add_handler;\n</code></pre>\n<p>However, many handlers, especially those related to basic math, do accept a variety of arguments, all combinations of <code>int</code> and <code>double</code> would be valid, yielding to 4 methods and 4 dispatch table entries. Therefore I decided to implement those methods using templates.\nTo give an example, this might be basically this (again simplyfied):</p>\n<pre><code>template&lt;class A, class B&gt;\nvoid my_add_handler(int /* simplified... */)\n{\n  // Something here A and B are needed\n}\n</code></pre>\n<p>The dispatch table then is filled like this:</p>\n<pre><code>fn_handlers[\"operator+ii\"] = my_add_handler&lt;int,int&gt;;\nfn_handlers[\"operator+di\"] = my_add_handler&lt;double,int&gt;;\nfn_handlers[\"operator+id\"] = my_add_handler&lt;int,double&gt;;\nfn_handlers[\"operator+dd\"] = my_add_handler&lt;double,double&gt;;\n</code></pre>\n<p>Still a lot to type, but this is okay for now. Anyway since there is obviously a correlation between the template parameters and the method signature (mangled name), I attempted to automate this that you could write (parameter name mangeling would be done inside handler_provider::add):</p>\n<pre><code>handler_provider&lt;int, int&gt;::add&lt;my_add_handler&gt;(\"operator+\");\nhandler_provider&lt;double, int&gt;::add&lt;fn_add_handler&gt;(\"operator+\");\nhandler_provider&lt;int, double&gt;::add&lt;fn_add_handler&gt;(\"operator+\");\nhandler_provider&lt;double, double&gt;::add&lt;fn_add_handler&gt;(\"operator+\");\n</code></pre>\n<p>Which then would take the arguments at the beginning and take them as template arguments for the second type (so that would not have to type the <code>&lt;int, int&gt;</code> part twice).</p>\n<p>Just for clarification; I am aware of the I would explicitly specialize the <code>my_add_handler</code> template like this:</p>\n<pre><code>handler_provider&lt;int, int&gt;::add&lt;my_add_handler&lt;int,int&gt;&gt;(\"test\");\n</code></pre>\n<p>But it is exactly this duplication that I want to omit (twict the <code>&lt;int,int&gt;</code>).</p>\n<p>However, I keep getting errors with the last part. The <code>handler_provider::add</code> method is defined as follows (the parameter name mangeling as mentioned above is left out because it is not the point here and works as expected):</p>\n<pre><code>template&lt;class... Ts&gt;\nstruct handler_provider\n{\n  // Overload for templates, such as 'test_handler'\n  template&lt;template&lt;class...&gt; class F&gt;\n  static void add(const std::string name)\n  {\n    handler_provider&lt;Ts...&gt;::add&lt;F&lt;Ts...&gt;&gt;(name);\n  }\n\n  // Overload for non-template (or already specialized) handlers (aka. function pointers)\n  template&lt;function_type F&gt;\n  static void add(const std::string name)\n  {\n    fn_handlers[name] = F;\n  }\n};\n</code></pre>\n<p>The first overload, as said, is supposed for the exact case I described above, the handler below installs non-template functions and those which are fully specialized.</p>\n<p>However, this gives me an error, telling be that the inner template from a call such as shown above cannot be deduced. I did not think that I told the compiler to deduce anything at all, I complete specialized the template arguments in the call (again):</p>\n<pre><code>handler_provider&lt;int, int&gt;::add&lt;my_add_handler&gt;(\"operator+\");\n</code></pre>\n<p>The arguments for the outer variadic template <code>class... Ts</code> are explicitly named <code>&lt;int, int&gt;</code> and the simple argument for the inner template-template is named as <code>my_add_handler</code>. However, the compiler seems to ignore this(?). This is the output I get (gcc 5.4.0 using <code>-std=c++14</code>):</p>\n<pre><code>$ g++ -std=c++14 sci_e1.cpp -o sci\nsci_e1.cpp: In function \u2018int main()\u2019:\nsci_e1.cpp:45:55: error: no matching function for call to \u2018handler_provider&lt;int, int&gt;::add(const char [5])\u2019\n  handler_provider&lt;int, int&gt;::add&lt;my_add_handler&gt;(\"operator+\");\n                                                             ^\nsci_e1.cpp:17:15: note: candidate: template&lt;template&lt;class ...&gt; class typedef F F&gt; static void handler_provider&lt;Ts&gt;::add(std::__cxx11::string) [with F = F; Ts = {int, int}]\n  static void add(const std::string name)\n              ^\nsci_e1.cpp:17:15: note:   template argument deduction/substitution failed:\nsci_e1.cpp:24:15: note: candidate: template&lt;void (* F)(int)&gt; static void handler_provider&lt;Ts&gt;::add(std::__cxx11::string) [with void (* F)(int) = F; Ts = {int, int}]\n  static void add(const std::string name)\n              ^\nsci_e1.cpp:24:15: note:   template argument deduction/substitution failed:\nsci_e1.cpp:45:55: error: could not convert template argument \u2018my_add_handler\u2019 to \u2018void (*)(int)\u2019\n  handler_provider&lt;int, int&gt;::add&lt;my_add_handler&gt;(\"operator+\");\n                                                             ^\n</code></pre>\n<p>I get the second error, thats completly okay and should not be a problem as this overload should be kicked out of overload resolution for template types. The first error is the one that drives me crazy.</p>\n<p>Clang (3.9.0) is a little more precise:</p>\n<pre><code>$ clang++ -std=c++14 sci_e1.cpp -o sci\nsci_e1.cpp:45:3: error: no matching function for call to 'add'\n  handler_provider&lt;int, int&gt;::add&lt;my_add_handler&gt;(\"test\");\n  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nsci_e1.cpp:17:15: note: candidate template ignored: invalid explicitly-specified argument for\n      template parameter 'F'\n  static void add(const std::string name)\n              ^\nsci_e1.cpp:24:15: note: candidate template ignored: invalid explicitly-specified argument for\n      template parameter 'F'\n  static void add(const std::string name)\n              ^\n1 error generated.\n</code></pre>\n<p>But I still do not understand where I am wrong here. What am I missing?</p>\n<p>Thanks,</p>\n<p>Sebastian</p>\n<hr>\n<p>For better testing, here is an full example:</p>\n<pre><code>#include &lt;unordered_map&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\n// Handler type\nusing function_type = void(int);\n\n// Dispatch table\nstd::unordered_map&lt;std::string, function_type*&gt; fn_handlers;\n\n// Handler provider (to install new handlers)\ntemplate&lt;class... Ts&gt;\nstruct handler_provider\n{\n  // Overload for templates, such as 'test_handler'\n  template&lt;template&lt;class...&gt; class F&gt;\n  static void add(const std::string name)\n  {\n    handler_provider&lt;Ts...&gt;::add&lt;F&lt;Ts...&gt;&gt;(name);\n  }\n\n  // Overload for non-template (or already specialized) handlers (aka. function pointers)\n  template&lt;function_type F&gt;\n  static void add(const std::string name)\n  {\n    fn_handlers[name] = F;\n  }\n};\n\n\ntemplate&lt;class A, class B&gt;\nvoid test_handler(int v)\n{\n  // Something here A and B are needed\n}\n\nvoid other_handler(int v)\n{\n  // A handler without specialization\n}\n\nint main()\n{\n  // Install handlers\n  handler_provider&lt;int, int&gt;::add&lt;test_handler&gt;(\"testii\");\n  handler_provider&lt;double, int&gt;::add&lt;test_handler&gt;(\"testdi\");\n  handler_provider&lt;bool, bool, int&gt;::add&lt;other_handler&gt;(\"otherbbi\");\n\n  // Dispatch\n  fn_handlers[\"testii\"](5); // Sould call test_handler&lt;int, int&gt;\n  fn_handlers[\"testdi\"](5); // Should call test_handler&lt;double, int&gt;\n\n  fn_handlers[\"otherbbi\"](5); // Should call other_handler\n}\n</code></pre>\n</hr>", "AcceptedAnswerId": "40075906", "Title": "template-template-parameter deducation failed for template method (although explicitly-specialized)", "CreationDate": "2016-10-15T19:28:06.220", "Id": "40063336", "CommentCount": "6", "LastEditDate": "2016-10-15T20:23:31.537", "PostTypeId": "1", "LastEditorUserId": "1820226", "LastActivityDate": "2016-10-16T23:06:33.033", "Score": "2", "OwnerUserId": "1820226", "Tags": "<c++><templates><variadic-templates><explicit-specialization>", "AnswerCount": "1"}});