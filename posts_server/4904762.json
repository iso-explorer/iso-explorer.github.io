post_cb({"4904773": {"ParentId": "4904762", "CommentCount": "23", "Body": "<p>Because <code>malloc</code> doesn't call the class's constructor, and doesn't know anything about any particular alignment requirements it might have. If you need to use <code>malloc</code> (not recommended), take a look at <a href=\"http://www.parashift.com/c++-faq-lite/dtors.html#faq-11.10\" rel=\"nofollow\">placement new</a> (assuming you don't want to overload the regular <code>new</code> for some reason).</p>\n", "OwnerUserId": "541686", "PostTypeId": "2", "Id": "4904773", "Score": "3", "CreationDate": "2011-02-05T02:36:09.447", "LastActivityDate": "2011-02-05T02:36:09.447"}, "4904915": {"ParentId": "4904762", "CommentCount": "1", "Body": "<p>Classes with <code>virtual</code> members contain a pointer to a so-called vtable - basically a table of function pointers to the implementation of these virtual members. When you use <code>operator new</code>, the constructor is called, which, even if it is an implicit constructor, will set up this pointer to the vtable properly.</p>\n<p>However, malloc does not call the constructor. The vtable pointer is left uninitialized, point to some random memory. When you then attempt to call a virtual function, you dereference a bad pointer and crash (undefined behavior).</p>\n<p>The solution is to use placement new to initialize the object before using it:</p>\n<pre><code>int main( ) {\n    Derived *d;\n    d = (Derived*) malloc( sizeof(Derived) );\n    new(d) Derived(123); // invoke constructor\n// You could also do:\n//    new(d) Derived;\n//    *d = Derived( 123 );\n\n    std::cout &lt;&lt; d-&gt;x() &lt;&lt; std::endl; // crash\n\n    // Although in your case it does not matter, it's good to clean up after yourself by\n    // calling the destructor\n    d-&gt;~Derived();\n    return 0;\n}\n</code></pre>\n<p>Some important things to note:</p>\n<ul>\n<li>Alignment is not a problem. Memory from malloc is properly aligned for any C++ type.</li>\n<li>Assigning with <code>=</code> does not help. The default implementation of <code>=</code> copies all member variables, but the vtable pointer is not a member and is not copied.</li>\n<li>Construction is not required for POD types. Non-POD types may or may not require it (it's undefined behavior if you don't). In particular, the constructor also calls member variable constructors; so if you don't construct the outer object, inner objects may be broken as well.</li>\n</ul>\n", "OwnerUserId": "36723", "PostTypeId": "2", "Id": "4904915", "Score": "2", "CreationDate": "2011-02-05T03:19:06.270", "LastActivityDate": "2011-02-05T03:19:06.270"}, "4904775": {"ParentId": "4904762", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>I don't belive that the object's constructor is called when you use malloc.</p>\n", "OwnerUserId": "264472", "LastEditorUserId": "264472", "LastEditDate": "2011-02-05T02:57:02.413", "Id": "4904775", "Score": "1", "CreationDate": "2011-02-05T02:36:40.300", "LastActivityDate": "2011-02-05T02:57:02.413"}, "4904873": {"ParentId": "4904762", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>Let's go down the line</p>\n<ol>\n<li>why is my application crashing, if I don't use new?</li>\n</ol>\n<p>Virtual table is corrupted.</p>\n<p>The virtual table is stuck right after the allocated memory.  when you <code>new</code> a class, the generated code will properly set up the vtable.  However, malloc will not properly initialize the vtable</p>\n<p>To see the virtual table, run\n    g++ -fdump-class-hierarchy </p>\n<pre><code>Vtable for Derived\nDerived::_ZTV7Derived: 3u entries\n0     (int (*)(...))0\n8     (int (*)(...))(&amp; _ZTI7Derived)\n16    Derived::x\n\nClass Derived\n   size=16 align=8\n   base size=12 base align=8\nDerived (0x10209fc40) 0\n    vptr=((&amp; Derived::_ZTV7Derived) + 16u) &lt;-- notice how this is part of the structure\n  Base (0x10209fcb0) 0 nearly-empty\n      primary-for Derived (0x10209fc40)\n</code></pre>\n<p>For a similar reason, without overloading operator=, the generated assembly code will only copy the data and not the vtable [again, the compiler only knows to copy the data, not the vtable]</p>\n<p>If you want to see a pointer-based version with a valid vtable function:</p>\n<pre><code>Derived e(123);\nd = &amp;e;\n</code></pre>\n<ol>\n<li>Would I need to use new also for non-polymorphic types?</li>\n</ol>\n<p>If you are using virtual functions, then yes, even for non-polymorphic types</p>\n<ol>\n<li>I hope that the alignment needed for my class is the class size as returned by sizeof, so that any address in the form address_returned_by_malloc + i * sizeof(my_class) is suitable to allocate my objects.</li>\n</ol>\n<p>Alignment is not an issue.</p>\n", "OwnerUserId": "590042", "LastEditorUserId": "590042", "LastEditDate": "2011-02-05T03:15:35.470", "Id": "4904873", "Score": "3", "CreationDate": "2011-02-05T03:10:23.083", "LastActivityDate": "2011-02-05T03:15:35.470"}, "4904884": {"ParentId": "4904762", "CommentCount": "0", "Body": "<p>section <code>[basic.life]</code> of the standard says</p>\n<blockquote>\n<p id=\"so_4904762_4904884_0\">The lifetime of an object is a runtime property of the object. An object is said to have non-trivial initialization if  it  is  of  a  class  or  aggregate  type  and  it  or  one  of  its  members  is  initialized  by  a  constructor  other than a trivial default constructor.  [ Note: initialization by a trivial copy/move constructor is non-trivial initialization.  \u2014 end note ] The lifetime of an object of type T begins when:</p>\n<ul>\n<li>storage with the proper alignment and size for type T is obtained, and</li>\n<li>if the object has non-trivial initialization, its initialization is complete.</li>\n</ul>\n</blockquote>\n<p>Since your class has virtual members, it requires non-trivial initialization.  You can't assign an object whose lifetime hasn't started, you have to <em>initialize</em> it with <code>new</code>.</p>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "4904884", "Score": "1", "CreationDate": "2011-02-05T03:12:49.693", "LastActivityDate": "2011-02-05T03:12:49.693"}, "4904762": {"CommentCount": "7", "ViewCount": "662", "PostTypeId": "1", "LastEditorUserId": "1593077", "CreationDate": "2011-02-05T02:33:40.437", "LastActivityDate": "2016-01-15T14:48:10.720", "Title": "In C++, why is `new` needed to dynamically create an object rather just allocation?", "AcceptedAnswerId": "4904873", "LastEditDate": "2016-01-15T14:48:10.720", "Id": "4904762", "Score": "6", "Body": "<p>I've got this trivial class hierarchy:</p>\n<pre><code>class Base {\npublic:\n    virtual int x( ) const = 0;\n};\n\nclass Derived : public Base {\n    int _x;\npublic:\n    Derived( int x ) : _x(x) { }\n    int x( ) const { return _x; }\n};\n</code></pre>\n<p>If I use <code>malloc</code> to allocate an instance of <code>Derived</code>, and then try to access the polymorphic function <code>x</code>, program crashes (I get a segmentation fault):</p>\n<pre><code>int main( ) {\n    Derived *d;\n    d = (Derived*) malloc( sizeof(Derived) );\n    *d = Derived( 123 );\n\n    std::cout &lt;&lt; d-&gt;x() &lt;&lt; std::endl; // crash\n\n    return 0;\n}\n</code></pre>\n<p>Of course my actual application is a lot more complex (it's a sort of memory pool).</p>\n<hr>\n<p>I'm pretty sure it's because of the way I allocate <code>d</code>: I didn't use <code>new</code>.</p>\n<p>I know of <a href=\"http://www.parashift.com/c++-faq-lite/dtors.html#faq-11.10\" rel=\"nofollow noreferrer\">placement <code>new</code></a> operator, which must be what I need, but I've never used it and have got some questions:</p>\n<ul>\n<li><p>why is my application crashing, if I don't use <code>new</code>?</p>\n<p>What does <code>new</code> actually do?</p>\n<p>Why can't I just use the assignment operator to assign the value of <code>Derived( 123 );</code> to the memory area pointed by <code>d</code>?</p></li>\n<li><p>Would I need to use <code>new</code> also for non-polymorphic types?</p>\n<p>How about POD ones?</p></li>\n<li><p>On the <a href=\"http://www.parashift.com/c++-faq-lite/dtors.html#faq-11.10\" rel=\"nofollow noreferrer\">C++Faq I linked above</a> it says that the memory region passed to placement <code>new</code> must be aligned for the object I'm creating.</p>\n<p>I know what alignment is, but I don't know how to check the alignment needed for my class.</p>\n<p><code>malloc</code> manual says:</p>\n<blockquote>\n<p id=\"so_4904762_4904762_0\">The  malloc() and calloc() functions return a pointer to the allocated memory that is suitably aligned for any kind of variable.</p>\n</blockquote>\n<p>And I hope that the alignment needed for my class is the class size as returned by <code>sizeof</code>, so that any address in the form <code>address_returned_by_malloc + i * sizeof(my_class)</code> is suitable to allocate my objects.</p>\n<p>Are my hopes right?</p></li>\n</ul>\n</hr>", "Tags": "<c++><memory><malloc><alignment><new-operator>", "OwnerUserId": "300805", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_4904762_4904884_0": {"section_id": 7189, "quality": 0.8461538461538461, "length": 33}}, "n3337": {"so_4904762_4904884_0": {"section_id": 6933, "quality": 0.8461538461538461, "length": 33}}, "n4659": {"so_4904762_4904884_0": {"section_id": 8697, "quality": 0.7435897435897436, "length": 29}}}});