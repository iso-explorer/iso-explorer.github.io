post_cb({"18513277": {"Id": "18513277", "PostTypeId": "2", "Body": "<p>what if you declare 'Value' as constexpr too? Actually you can probalby never be sure if something is evaluated at compilation time, however in this case there is no reason why it could not be evaluated.</p>\n", "LastActivityDate": "2013-08-29T14:09:36.267", "CommentCount": "0", "CreationDate": "2013-08-29T14:09:36.267", "ParentId": "18513107", "Score": "3", "OwnerUserId": "1749713"}, "18513825": {"Id": "18513825", "PostTypeId": "2", "Body": "<p>Create a separate source file with the expression. Evaluate <code>printf(\"#define MyExpression %d.\\n\", expression);</code>. When building your project, compile this source file for the native system and execute it. Include the resulting output as a header in your regular sources.</p>\n", "LastActivityDate": "2013-08-29T14:32:55.590", "CommentCount": "1", "CreationDate": "2013-08-29T14:32:55.590", "ParentId": "18513107", "Score": "1", "OwnerUserId": "298225"}, "18522300": {"Id": "18522300", "PostTypeId": "2", "Body": "<p>If you want to confirm that the initializer is a constant expression than you can use the <code>constexpr</code> specifier:</p>\n<pre><code>constexpr int Value = 123 * 2 + GetOffset();\n</code></pre>\n<p>It will fail to compile if it isn't a constant expression.</p>\n<p>It is theoretically unspecified whether a constexpr variable <code>Value</code> is actually calculated during translation - but in practice you can be sure it is.</p>\n", "LastEditorUserId": "1131467", "LastActivityDate": "2013-08-29T23:35:20.263", "Score": "0", "CreationDate": "2013-08-29T23:01:57.840", "ParentId": "18513107", "CommentCount": "0", "OwnerUserId": "1131467", "LastEditDate": "2013-08-29T23:35:20.263"}, "18528361": {"Id": "18528361", "PostTypeId": "2", "Body": "<p>Just assert it: <code>static_assert(Value == 123 * 2 + GetOffset(), \"constexpr\");</code>\nDoesn't get any simpler than that.</p>\n", "LastActivityDate": "2013-08-30T08:31:43.247", "CommentCount": "0", "CreationDate": "2013-08-30T08:31:43.247", "ParentId": "18513107", "Score": "0", "OwnerUserId": "15416"}, "18513301": {"Id": "18513301", "PostTypeId": "2", "Body": "<p>You can't be absolutely sure; the compiler is only required to generate code with the specified behaviour, and calculating it at compile- or run-time would not change the behaviour.</p>\n<p>However, the compiler is required to be <em>able</em> to evaluate this at compile time, since it can be used where only compile-time constants are allowed such as array sizes and template arguments; so there's no reason why a sane compiler shouldn't perform that obvious optimisation. If the compiler doesn't (at least with optimisations enabled), throw it away and find a better one.</p>\n<p>You can check the assembly produced by the compiler to see whether it calculates the value; but this in itself doesn't guarantee that future builds will do the same.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2013-08-29T14:18:02.703", "Score": "2", "CreationDate": "2013-08-29T14:10:29.140", "ParentId": "18513107", "CommentCount": "5", "OwnerUserId": "204847", "LastEditDate": "2013-08-29T14:18:02.703"}, "bq_ids": {"n4140": {"so_18513107_18513968_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 4727}}, "n3337": {"so_18513107_18513968_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 4534}}, "n4659": {"so_18513107_18513968_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 6139}}}, "18513252": {"Id": "18513252", "PostTypeId": "2", "Body": "<p>Considering that I have not used C++ in over half a decade now, the chances of the suggestion being way of the mark are quite high, but what about using inline for the function. </p>\n<p>If the function returns a certain predefined value, available at the compile time, then the compiler should be able to make use of that value. </p>\n", "LastActivityDate": "2013-08-29T14:08:33.850", "CommentCount": "1", "CreationDate": "2013-08-29T14:08:33.850", "ParentId": "18513107", "Score": "1", "OwnerUserId": "1163622"}, "18513279": {"Id": "18513279", "PostTypeId": "2", "Body": "<p>Why don't you use <code>constexpr</code> for Value too? I think it will ask the compiler to evaluate it,</p>\n<pre><code>constexpr int Value = 123 * 2 + GetOffset();   \n</code></pre>\n<p>if the function GetOffset() is simple and meet the requirements of <code>constexpr</code>.</p>\n<p>The requirements are</p>\n<ol>\n<li><p>the function must have a non-void return type. </p></li>\n<li><p>the function body cannot declare variables or define new types.</p></li>\n<li><p>the body may contain only declarations, null statements and a single return\nstatement.</p></li>\n</ol>\n<p>Since <code>Getoffset()</code> returns <code>int</code>, it meets the first one.</p>\n", "LastActivityDate": "2013-08-29T14:09:39.090", "CommentCount": "6", "CreationDate": "2013-08-29T14:09:39.090", "ParentId": "18513107", "Score": "3", "OwnerUserId": "1153165"}, "18513107": {"ViewCount": "370", "Body": "<p>I have a code like this</p>\n<pre><code>const int Value = 123 * 2 + GetOffset();\n</code></pre>\n<p><code>GetOffset</code> is a <code>constexpr</code> function returning <code>int</code>.</p>\n<p>How can I make sure this expression is indeed evaluated at compile time?</p>\n", "AcceptedAnswerId": "18513968", "Title": "How can I know if C++ compiler evaluates the expression at compile time?", "CreationDate": "2013-08-29T14:02:29.627", "Id": "18513107", "CommentCount": "0", "LastEditDate": "2013-08-29T14:54:10.377", "PostTypeId": "1", "LastEditorUserId": "1065190", "LastActivityDate": "2013-08-30T08:31:43.247", "Score": "3", "OwnerUserId": "2729562", "Tags": "<c++><optimization><c++11>", "AnswerCount": "9"}, "18513968": {"Id": "18513968", "PostTypeId": "2", "Body": "<p>One possibility is to use <code>std::ratio</code>.  From section 20.10.1 of the C++11 standard:</p>\n<blockquote>\n<p id=\"so_18513107_18513968_0\">This subclause describes the ratio library. It provides a class template ratio which exactly represents any finite rational number with a numerator and denominator representable by compile-time constants of type intmax_t.</p>\n</blockquote>\n<p>So according to the standard, this would only be valid for a compile-time constant:</p>\n<pre><code>const int value = std::ratio&lt;123 * 2 + GetOffset()&gt;::num;\n</code></pre>\n<p>So this would guarantee that the expression is evaluated at compile time.  However, it doesn't also guarantee that the expression is not evaluated at run time.</p>\n", "LastEditorUserId": "951890", "LastActivityDate": "2013-08-29T14:48:09.883", "Score": "2", "CreationDate": "2013-08-29T14:38:53.780", "ParentId": "18513107", "CommentCount": "7", "OwnerUserId": "951890", "LastEditDate": "2013-08-29T14:48:09.883"}, "18513148": {"Id": "18513148", "PostTypeId": "2", "Body": "<p>You can't ensure the compiler does this. You generally need to enable optimization, including some level of function inlining. What these options are depend on your compiler and its version.</p>\n<p>You can check the generated assembly to see if it contains a call to <code>GetOffset</code> or just uses a constant determined by the compiler.</p>\n", "LastActivityDate": "2013-08-29T14:04:19.477", "CommentCount": "7", "CreationDate": "2013-08-29T14:04:19.477", "ParentId": "18513107", "Score": "3", "OwnerUserId": "256138"}});