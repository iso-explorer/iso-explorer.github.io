post_cb({"bq_ids": {"n4140": {"so_47889416_47889779_3": {"length": 15, "quality": 0.9375, "section_id": 6689}, "so_47889416_47889779_4": {"length": 25, "quality": 0.6097560975609756, "section_id": 5485}, "so_47889416_47889779_1": {"length": 46, "quality": 0.9019607843137255, "section_id": 5485}}, "n3337": {"so_47889416_47889779_3": {"length": 15, "quality": 0.9375, "section_id": 6444}, "so_47889416_47889779_4": {"length": 24, "quality": 0.5853658536585366, "section_id": 5271}, "so_47889416_47889779_1": {"length": 32, "quality": 0.6274509803921569, "section_id": 5271}}, "n4659": {"so_47889416_47889779_3": {"length": 15, "quality": 0.9375, "section_id": 8164}, "so_47889416_47889779_4": {"length": 25, "quality": 0.6097560975609756, "section_id": 6920}, "so_47889416_47889779_1": {"length": 46, "quality": 0.9019607843137255, "section_id": 6920}}}, "47889779": {"Id": "47889779", "PostTypeId": "2", "Body": "<blockquote id=\"so_47889416_47889779_0\">\n<ul>\n<li>Why am I unable to locate <code>str(..)</code> explicitly scoping it with the enclosing namespace?</li>\n</ul>\n</blockquote>\n<p>From the standard, <a href=\"http://eel.is/c++draft/namespace.memdef#3\" rel=\"nofollow noreferrer\">\u00a710.3.1.2/3 Namespace member definitions [namespace.memdef]</a></p>\n<blockquote>\n<p id=\"so_47889416_47889779_1\">If a friend declaration in a non-local class first declares a class,\n  function, class template or function template the friend is a member\n  of the innermost enclosing namespace. The friend declaration does not\n  by itself make the name visible to unqualified lookup or qualified\n  lookup. [\u2009Note: The name of the friend will be visible in its\n  namespace if a matching declaration is provided at namespace scope\n  (either before or after the class definition granting friendship).\n  \u2014\u2009end note\u2009]</p>\n</blockquote>\n<p>That means <code>str</code> is not visible to name lookup; it can only be called via ADL.</p>\n<blockquote id=\"so_47889416_47889779_2\">\n<ul>\n<li>Why does <code>__PRETTY_FUNCTION__</code> say it's in <code>foo::</code>, and yet I am unable to locate it as such?</li>\n</ul>\n</blockquote>\n<p>From <a href=\"http://eel.is/c++draft/class.friend#6\" rel=\"nofollow noreferrer\">\u00a714.3/6 Friends [class.friend]</a>,</p>\n<blockquote>\n<p id=\"so_47889416_47889779_3\">A function can be defined in a friend declaration of a class if and only if the class is a non-local class ([class.local]), the function name is unqualified, and the function has namespace scope.</p>\n</blockquote>\n<p><code>str</code> does become member of namespace <code>foo</code>; it's just invisible.</p>\n<p>Explanations from <a href=\"http://en.cppreference.com/w/cpp/language/namespace#Namespaces\" rel=\"nofollow noreferrer\">cppreference.com</a>:</p>\n<blockquote>\n<p id=\"so_47889416_47889779_4\">Names introduced by <a href=\"http://en.cppreference.com/w/cpp/language/friend\" rel=\"nofollow noreferrer\">friend</a> declarations within a non-local class X become members of the innermost enclosing namespace of X, but they do not become visible to <a href=\"http://en.cppreference.com/w/cpp/language/lookup\" rel=\"nofollow noreferrer\">lookup</a> (neither unqualified nor qualified) unless a matching declaration is provided at namespace scope, either before or after the class definition. Such name may be found through <a href=\"http://en.cppreference.com/w/cpp/language/adl\" rel=\"nofollow noreferrer\">ADL</a> which considers both namespaces and classes.</p>\n</blockquote>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2017-12-19T15:12:59.130", "Score": "2", "CreationDate": "2017-12-19T15:03:05.617", "ParentId": "47889416", "CommentCount": "0", "OwnerUserId": "3309790", "LastEditDate": "2017-12-19T15:12:59.130"}, "47889416": {"ViewCount": "51", "Body": "<p>I had an issue today where ADL wasn't finding a static member function for a type defined inside a class.</p>\n<p>That is, in the below example, <code>str(foo::Foo::Enum)</code> isn't located via ADL without explicitly scoping it, <code>foo::Foo::str(foo::Foo::Enum)</code></p>\n<pre><code>namespace foo {\n\nstruct Foo\n{\n    enum Enum\n    {\n        FOO1,\n        FOO2\n    };\n\n    static const char* str(Enum e);\n};\n\n}\n\nfoo::Foo::Enum e = foo::Foo::FOO1;\nconst char* s = str(e);              // ADL doesn't work\n</code></pre>\n<p>I found <a href=\"https://stackoverflow.com/questions/14725214/doesnt-adl-looks-up-static-member-functions\">this</a> SO question, and as stated in the accepted answer, changing it to a <code>friend</code> function results in ADL now working.</p>\n<pre><code>namespace foo {\n\nstruct Foo\n{\n    enum Enum\n    {\n        FOO1,\n        FOO2\n    };\n\n    friend const char* str(Enum e);  // note str is now a friend\n};\n\n}\n\nfoo::Foo::Enum e = foo::Foo::FOO1;\nconst char* s = str(e);              // ADL works now\n</code></pre>\n<p>Whilst this now helps ADL, I was surprised to find that I couldn't access <code>str</code> by scoping it with a namespace <code>foo</code></p>\n<pre><code>foo::Foo::Enum e = foo::Foo::FOO1;\nconst char* s = foo::str(e);         // error: \u2018str\u2019 is not a member of \u2018foo\u2019\n</code></pre>\n<p>I ran a test, where I printed out the result of <code>__PRETTY_FUNCTION__</code>, and was even more surprised to see that the scope of str is apparently <code>foo::</code>:</p>\n<pre><code>__PRETTY_FUNCTION__: const char* foo::str(foo::Foo::Enum)\n</code></pre>\n<p><strong>Working example below:</strong></p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace foo {\n\nstruct Foo\n{\n    enum Enum\n    {\n        FOO1,\n        FOO2\n    };\n\n    friend const char* str(Enum e)\n    {\n        return __PRETTY_FUNCTION__;\n    }\n};\n\n}\n\nint main()\n{\n    foo::Foo::Enum e = foo::Foo::FOO1;\n\n    std::cout &lt;&lt; str(e) &lt;&lt; '\\n';\n    // std::cout &lt;&lt; foo::str(e) &lt;&lt; '\\n'; // error: \u2018str\u2019 is not a member of \u2018foo\u2019\n\n    return 0;\n}\n</code></pre>\n<p><strong>Output:</strong></p>\n<pre><code>$ ./a.out\nconst char* foo::str(foo::Foo::Enum)\n</code></pre>\n<p><strong>Question:</strong></p>\n<ul>\n<li>Why am I unable to locate <code>str(..)</code> explicitly scoping it with the enclosing namespace?</li>\n<li>Why does <code>__PRETTY_FUNCTION__</code> say it's in <code>foo::</code>, and yet I am unable to locate it as such?</li>\n</ul>\n", "AcceptedAnswerId": "47889779", "Title": "cannot access namespace scope friend explicitly", "CreationDate": "2017-12-19T14:45:44.570", "LastActivityDate": "2017-12-19T15:12:59.130", "CommentCount": "5", "LastEditDate": "2017-12-19T15:12:54.683", "PostTypeId": "1", "LastEditorUserId": "3309790", "Id": "47889416", "Score": "1", "OwnerUserId": "955273", "Tags": "<c++><language-lawyer><friend><argument-dependent-lookup><name-lookup>", "AnswerCount": "1"}});