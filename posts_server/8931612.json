post_cb({"8931632": {"Id": "8931632", "PostTypeId": "2", "Body": "<p>Yes, that's fine ... you only need to implement any pure virtual functions in order to instantiate a class derived from an abstract base class.</p>\n", "LastActivityDate": "2012-01-19T18:52:20.847", "CommentCount": "0", "CreationDate": "2012-01-19T18:52:20.847", "ParentId": "8931612", "Score": "3", "OwnerUserId": "649233"}, "8931834": {"Id": "8931834", "PostTypeId": "2", "Body": "<p>The ISO C++ Standard specifies that all virtual methods of a class that are not pure-virtual must be defined.   </p>\n<p>Simply put the rule is:<br>\nIf your derived class overiddes the Base class virtual method then it should provide a definition as well, If not then the Base class should provide the definition of that method. </br></p>\n<p>As per the above rule in your code example, <code>virtual void bar();</code> needs a definition in the Base class.</p>\n<p>Reference:</p>\n<p><strong>C++03 Standard: 10.3 Virtual functions   [class.virtual]</strong> </p>\n<blockquote>\n<p id=\"so_8931612_8931834_0\">A virtual function declared in a class shall be defined, or declared pure (10.4) in that class, or both; but no diagnostic is required (3.2).</p>\n</blockquote>\n<p>So either you should make the function pure virtual or provide a definition for it.  </p>\n<p>The <strong><a href=\"http://gcc.gnu.org/faq.html#vtables\" rel=\"noreferrer\">gcc faq</a></strong> doccuments it as well:  </p>\n<blockquote>\n<p id=\"so_8931612_8931834_1\">The ISO C++ Standard specifies that all virtual methods of a class that are not pure-virtual must be defined, but does not require any diagnostic for violations of this rule <code>[class.virtual]/8</code>. Based on this assumption, GCC will only emit the implicitly defined constructors, the assignment operator, the destructor and the virtual table of a class in the translation unit that defines its first such non-inline method.</p>\n<p id=\"so_8931612_8931834_2\">Therefore, if you fail to define this particular method, the linker may complain about the lack of definitions for apparently unrelated symbols. Unfortunately, in order to improve this error message, it might be necessary to change the linker, and this can't always be done.</p>\n<p id=\"so_8931612_8931834_3\">The solution is to ensure that all virtual methods that are not pure are defined. Note that a destructor must be defined even if it is declared pure-virtual <code>[class.dtor]/7</code>.</p>\n</blockquote>\n", "LastEditorUserId": "452307", "LastActivityDate": "2012-01-19T19:17:05.083", "Score": "7", "CreationDate": "2012-01-19T19:10:47.380", "ParentId": "8931612", "CommentCount": "0", "LastEditDate": "2012-01-19T19:17:05.083", "OwnerUserId": "452307"}, "bq_ids": {"n4140": {"so_8931612_8931834_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 7012}}, "n3337": {"so_8931612_8931834_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 6758}}, "n4659": {"so_8931612_8931834_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 8509}}}, "8931612": {"ViewCount": "43899", "Body": "<p>This may seem like a simple question, but I can't find the answer anywhere else.</p>\n<p>Suppose I have the following:</p>\n<pre><code>class Abstract {\npublic:\n    virtual void foo() = 0;\n    virtual void bar();\n}\n\nclass Derived : Abstract {\npublic:\n    virtual void foo();\n}\n</code></pre>\n<p>Is it ok that class Derived does not implement the bar() function?\nWhat if not ALL of my derived classes need the bar() function, but some do.\nDo all of the virtual functions of an abstract base class need to be implemented in the derived classes, or just the ones that are pure virtual?\nThanks</p>\n", "AcceptedAnswerId": "8931630", "Title": "Do ALL virtual functions need to be implemented in derived classes?", "CreationDate": "2012-01-19T18:51:12.390", "Id": "8931612", "CommentCount": "0", "FavoriteCount": "16", "PostTypeId": "1", "LastActivityDate": "2017-06-20T18:13:31.377", "Score": "67", "OwnerUserId": "387203", "Tags": "<c++><inheritance>", "AnswerCount": "5"}, "8931719": {"Id": "8931719", "PostTypeId": "2", "Body": "<p>Only the pure virtual methods have to be implemented in derived classes, but you still need a definition (and not just a declaration) of the other virtual methods. If you don't supply one, the linker might very well complain.</p>\n<p>So, just putting <code>{}</code> after your optional virtual method gives you an empty default implementation:</p>\n<pre><code>class Abstract {\npublic:\n    virtual void foo() = 0; // pure virtual must be overridden\n    virtual void bar() {}   // virtual with empty default implementation\n};\n\nclass Derived : Abstract {\npublic:\n    virtual void foo();\n};\n</code></pre>\n<p>A more involved default implementation would go into a separate source file though.</p>\n", "LastEditorUserId": "619295", "LastActivityDate": "2016-11-04T07:45:39.270", "Score": "29", "CreationDate": "2012-01-19T19:00:24.923", "ParentId": "8931612", "CommentCount": "2", "LastEditDate": "2016-11-04T07:45:39.270", "OwnerUserId": "619295"}, "8932180": {"Id": "8932180", "PostTypeId": "2", "Body": "<p>Yes, Its correct that a Derived class has to OVERRIDE the function which is Pure Virtual in the Parent Class. Parent class having a Pure Virtual Function is called Abstract Class only because it's Child class must give their own body of the Pure Virtual Function.</p>\n<p>For the Normal Virtual Functions:-\nIts not necessary to override them further, as some child class may have that function, some may not have. </p>\n<p>Main purpose of Virtual Function mechanism is Run Time Polymorphism, whether main purpose of Pure Virtual Function(Abstract Class) is to make it mandatory to have the same name Function with own's body.</p>\n", "LastActivityDate": "2012-01-19T19:36:37.463", "CommentCount": "0", "CreationDate": "2012-01-19T19:36:37.463", "ParentId": "8931612", "Score": "0", "OwnerUserId": "1159276"}, "8931630": {"Id": "8931630", "PostTypeId": "2", "Body": "<p>Derived classes do <strong>not</strong> have to implement <em>all</em> virtual functions themselves. They only need to implement the <em>pure</em> ones.<sup>1</sup> That means the <code>Derived</code> class in the question is correct. It <em>inherits</em> the <code>bar</code> implementation from its ancestor class, <code>Abstract</code>. (This assumes that <code>Abstract::bar</code> is implemented somewhere. The code in the question declares the method, but doesn't define it. You can define it inline as <a href=\"https://stackoverflow.com/a/8931719/33732\">Trenki's answer</a> shows, or you can define it separately.)</p>\n<hr>\n<p><sup>1</sup> And even then, only if the derived class is going to be <em>instantiated</em>. If a derived class is not instantiated directly, but only exists as a base class of more derived classes, then it's <em>those</em> classes that are responsible for having all their pure virtual methods implemented. The \"middle\" class in the hierarchy is allowed to leave some pure virtual methods unimplemented, just like the base class. If the \"middle\" class <em>does</em> implement a pure virtual method, then its descendants will inherit that implementation, so they don't have to re-implement it themselves.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2012-01-19T19:54:57.293", "Score": "58", "CreationDate": "2012-01-19T18:52:19.367", "ParentId": "8931612", "CommentCount": "7", "LastEditDate": "2017-05-23T12:02:51.350", "OwnerUserId": "33732"}});