post_cb({"27954295": {"ParentId": "27953629", "CommentCount": "1", "Body": "<p>This isn't worth fretting about, just let the compiler tell you that it is weird:</p>\n<pre><code>  static_assert(sizeof(request_header) == 24, \"Unexpected packet size\");\n</code></pre>\n", "OwnerUserId": "17034", "PostTypeId": "2", "Id": "27954295", "Score": "6", "CreationDate": "2015-01-14T23:20:42.107", "LastActivityDate": "2015-01-14T23:20:42.107"}, "27953756": {"ParentId": "27953629", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You are correct, that C++ may pad arbitrarily. From C++.11 \u00a79.2\u00b614 (emphasis is mine):</p>\n<blockquote>\n<p id=\"so_27953629_27953756_0\">Nonstatic data members of a (non-union) class with the same access control (Clause 11) are allocated so that later members have higher addresses within a class object. The order of allocation of non-static data members with different access control is unspecified (11). <strong>Implementation alignment requirements might cause two adjacent members not to be allocated immediately after each other</strong>; so might requirements for space for managing virtual functions (10.3) and virtual base classes (10.1).</p>\n</blockquote>\n<p>C is also permitted to add padding bytes, so this is not peculiar to C++. From C.11 \u00a76.7.2.1\u00b615 (emphasis is mine):</p>\n<blockquote>\n<p id=\"so_27953629_27953756_1\">Within a structure object, the non-bit-field members and the units in which bit-fields reside have addresses that increase in the order in which they are declared. A pointer to a structure object, suitably converted, points to its initial member (or if that member is a bit-field, then to the unit in which it resides), and vice versa. <strong>There may be unnamed padding within a structure object</strong>, but not at its beginning.</p>\n</blockquote>\n<p>If you want to avoid padding, the only maximally portable way is to pack the data structure yourself into contiguous memory (e.g., a <code>vector</code>) when sending, and unpack the serialized data into your data structure when receiving. Your compiler may provide extensions to allow you to keep all members within your <code>struct</code> contiguous (e.g., GCC's <code>packed</code> attribute, or VC++'s <code>pack</code> pragma, as described <a href=\"https://stackoverflow.com/a/1545341/315052\">here</a>).</p>\n", "OwnerUserId": "315052", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:33:03.883", "Id": "27953756", "Score": "4", "CreationDate": "2015-01-14T22:38:11.163", "LastActivityDate": "2015-01-14T22:59:11.970"}, "27953629": {"CommentCount": "6", "ViewCount": "159", "CreationDate": "2015-01-14T22:28:38.590", "LastActivityDate": "2015-01-14T23:20:42.107", "Title": "If I lay out the fields of my struct so they shouldn't need any padding, can a conforming C++ compiler add extra anyway?", "AcceptedAnswerId": "27953756", "PostTypeId": "1", "Id": "27953629", "Score": "3", "Body": "<p>I want to format a packet in an existing binary protocol format (I'm writing a memcached client) in C++.  In C, I can do this:</p>\n<pre><code>    typedef struct {\n        uint8_t magic;\n        uint8_t opcode;\n        uint16_t keylen;\n        uint8_t extlen;\n        uint8_t datatype;\n        uint16_t reserved;\n        uint32_t bodylen;\n        uint32_t opaque;\n        uint64_t cas;\n    } request_header;\n</code></pre>\n<p>In C++, in general, the compiler can add padding between the fields.  However, the above struct is carefully laid out so that everything can be aligned with no padding, assuming n bit types only need to be aligned on n bit boundaries.  So in C++, according to the standard, am I safe?  Or could a conforming C++ compiler add extra padding, thwarting my ability to use this to lay out my bits?</p>\n", "Tags": "<c++><struct>", "OwnerUserId": "3917", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_27953629_27953756_0": {"section_id": 5873, "quality": 0.9423076923076923, "length": 49}}, "n3337": {"so_27953629_27953756_1": {"section_id": 5650, "quality": 0.575, "length": 23}, "so_27953629_27953756_0": {"section_id": 5644, "quality": 0.9423076923076923, "length": 49}}, "n4659": {"so_27953629_27953756_0": {"section_id": 7356, "quality": 0.9423076923076923, "length": 49}}}, "27954102": {"ParentId": "27953629", "CommentCount": "4", "Body": "<p>There is such a thing in C++ called POD for plain-old-data. Basically if certain restrictions are met a struct in C++ is POD and it is going to be byte-to-byte compatible with the same structure defined in C code.</p>\n<p>To be POD, a structure must have no access specifiers (public, private), and no non-static member functions, including operators, constructors and destructors.</p>\n", "OwnerUserId": "4433969", "PostTypeId": "2", "Id": "27954102", "Score": "1", "CreationDate": "2015-01-14T23:04:08.147", "LastActivityDate": "2015-01-14T23:04:08.147"}});