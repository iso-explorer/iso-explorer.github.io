post_cb({"bq_ids": {"n4140": {"so_29417534_29417534_0": {"length": 20, "quality": 1.0, "section_id": 292}, "so_29417534_29417535_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 286}, "so_29417534_29417535_1": {"length": 45, "quality": 0.9574468085106383, "section_id": 336}, "so_29417534_29417535_0": {"length": 58, "quality": 1.0, "section_id": 307}}, "n3337": {"so_29417534_29417534_0": {"length": 20, "quality": 1.0, "section_id": 283}, "so_29417534_29417535_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 277}, "so_29417534_29417535_1": {"length": 45, "quality": 0.9574468085106383, "section_id": 326}, "so_29417534_29417535_0": {"length": 58, "quality": 1.0, "section_id": 298}}, "n4659": {"so_29417534_29417534_0": {"length": 20, "quality": 1.0, "section_id": 299}, "so_29417534_29417535_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 293}, "so_29417534_29417535_1": {"length": 45, "quality": 0.9574468085106383, "section_id": 345}, "so_29417534_29417535_0": {"length": 57, "quality": 0.9827586206896551, "section_id": 314}}}, "29417534": {"ViewCount": "421", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid f(int) { }\n\nvoid f(int, short) { }\n\ntemplate&lt;typename... Ts&gt; void g(void (*)(Ts...))\n{\n   std::cout &lt;&lt; sizeof...(Ts) &lt;&lt; '\\n';\n}\n\ntemplate&lt;typename T, typename... Ts&gt; void h(void (*)(T, Ts...))\n{\n   std::cout &lt;&lt; sizeof...(Ts) &lt;&lt; '\\n';\n}\n\nint main()\n{\n   g(f);         // #1\n   g&lt;int&gt;(f);    // #2\n   h(f);         // #3\n   h&lt;int&gt;(f);    // #4\n}\n</code></pre>\n<p>The intent is to try each of the lines in the body of <code>main()</code> separately. My expectations were that all four calls were ambiguous and would result in compiler errors.</p>\n<p>I tested the code on:</p>\n<ul>\n<li>Clang 3.6.0 and GCC 4.9.2, both using <code>-Wall -Wextra -pedantic -std=c++14</code> (<code>-std=c++1y</code> for GCC) - same behaviour in all these cases, except for minor differences in the wording of error messages;</li>\n<li>Visual C++ 2013 Update 4 and Visual C++ 2015 CTP6 - again, same behaviour, so I'll call them \"MSVC\" going forward.</li>\n</ul>\n<p>Clang and GCC:</p>\n<ul>\n<li><code>#1</code>: Compiler error, with a confusing message, basically <code>no overload of 'f' matching 'void (*)()'</code>. What? Where did the no-param declaration come from?</li>\n<li><code>#3</code>: Compiler error, with another confusing message: <code>couldn't infer template argument 'T'</code>. Of all the things that could fail there, deducing the argument for <code>T</code> would be the last one I would expect...</li>\n<li><code>#2</code> and <code>#4</code>: Compiles with no errors and no warnings, and chooses the first overload.</li>\n</ul>\n<p>For all four cases, if we eliminate one of the overloads (any one), the code compiles fine and chooses the remaining function. This looks like an inconsistency in Clang and GCC: after all, if deduction succeeds for both overloads separately, how can one be chosen over the other in cases <code>#2</code> and <code>#4</code>? Aren't they both perfect matches?</p>\n<p>Now, MSVC:</p>\n<ul>\n<li><p><code>#1</code>, <code>#3</code> and <code>#4</code>: Compiler error, with a nice message: <code>cannot deduce template argument as function argument is ambiguous</code>. Now that's what I'm talking about! But, wait...</p></li>\n<li><p><code>#2</code>: Compiles with no errors and no warnings, and chooses the first overload. Trying the two overloads separately, only the first one matches. The second one generates an error: <code>cannot convert argument 1 from 'void (*)(int,short)' to 'void (*)(int)'</code>. Not so good anymore.</p></li>\n</ul>\n<p>To clarify what I'm looking for with case <code>#2</code>, this is what the standard (N4296, first draft after C++14 final) says in [14.8.1p9]:</p>\n<blockquote>\n<p id=\"so_29417534_29417534_0\">Template argument deduction can extend the sequence of template\n  arguments corresponding to a template parameter pack, even when the\n  sequence contains explicitly specified template arguments.</p>\n</blockquote>\n<p>Looks like this part doesn't quite work in MSVC, making it choose the first overload for <code>#2</code>.</p>\n<p>So far, it looks like MSVC, while not quite right, is at least relatively consistent. What's going on with Clang and GCC? What's the correct behaviour according to the standard for each case?</p>\n", "Title": "Template argument deduction for variadic function pointer parameter - handling of ambiguous cases", "CreationDate": "2015-04-02T16:09:58.330", "LastActivityDate": "2015-04-02T16:09:58.330", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "Id": "29417534", "Score": "8", "OwnerUserId": "4326278", "Tags": "<c++><templates><variadic-templates><c++14><argument-deduction>", "AnswerCount": "1"}, "29417535": {"Id": "29417535", "PostTypeId": "2", "Body": "<p>As far as I can tell, Clang and GCC are right in all four cases according to the standard, even though their behaviour may seem counter-intuitive, especially in cases <code>#2</code> and <code>#4</code>.</p>\n<p>There are two main steps in the analysis of the function calls in the code sample. The first one is template argument deduction and substitution. When that completes, it yields a declaration of a specialization (of either <code>g</code> or <code>h</code>) where all template parameters have been replaced with actual types. </p>\n<p>Then, the second step attempts to match <code>f</code>'s overloads against the actual pointer-to-function parameter that was constructed in the previous step. The best match is chosen according to the rules in [13.4] - Address of overloaded function; in our cases this is pretty simple, as there are no templates among the overloads, so we have either one perfect match or none at all.</p>\n<p>The key point to understanding what happens here is that an ambiguity in the first step doesn't necessarily mean that the whole process fails.</p>\n<p>The quotes below are from N4296 but the content hasn't changed since C++11.</p>\n<p>[14.8.2.1p6] describes the process of template argument deduction when a function parameter is a pointer to function (emphasis mine): </p>\n<blockquote>\n<p id=\"so_29417534_29417535_0\">When P is a function type, pointer to function type, or pointer to\n  member function type:<br>\n  \u2014 If the argument is an overload set containing one or more function \n  templates, the parameter is treated as a non-deduced context.<br>\n  \u2014 If the argument is an overload set (not\n  containing function templates), trial argument deduction is attempted\n  using each of the members of the set. If deduction succeeds for only\n  one of the overload set members, that member is used as the argument\n  value for the deduction. If deduction succeeds for more than one\n  member of the overload set <em>the parameter is treated as a non-deduced\n  context</em>.</br></br></p>\n</blockquote>\n<p>For completeness, [14.8.2.5p5] clarifies that the same rule applies even when there's no match:</p>\n<blockquote>\n<p id=\"so_29417534_29417535_1\">The non-deduced contexts are: [...]<br>\n  \u2014 A function parameter for which argument deduction cannot be done because\n  the associated function argument is a function, or a set of overloaded\n  functions (13.4), and one or more of the following apply:<br>\n  \u2014 more than one function matches\n  the function parameter type (resulting in an ambiguous deduction), or<br>\n  \u2014 no function matches the function parameter type, or<br>\n  \u2014 the set of functions supplied as an argument contains one or more\n  function templates.</br></br></br></br></p>\n</blockquote>\n<p>So, no hard errors because of ambiguity in these cases. Instead, all template parameters are in non-deduced contexts in all our cases. This combines with [14.8.1p3]:</p>\n<blockquote>\n<p id=\"so_29417534_29417535_2\">[...] A trailing template parameter pack (14.5.3) not otherwise\n  deduced will be deduced to an empty sequence of template arguments.\n  [...]</p>\n</blockquote>\n<p>While the use of the word \"deduced\" is confusing here, I take this to mean that a template parameter pack is set to the empty sequence if no elements can be deduced for it from any source and there are no template arguments explicitly specified for it.</p>\n<p>Now, the error messages from Clang and GCC start to make sense (an error message that only makes sense <em>after</em> you understand why the error occurs is not exactly the definition of a helpful error message, but I guess it's better than nothing):</p>\n<ul>\n<li><code>#1</code>: Since <code>Ts</code> is the empty sequence, the parameter of <code>g</code>'s specialization is indeed <code>void (*)()</code> in this case. The compiler then tries to match one of the overloads to the destination type and fails.</li>\n<li><code>#3</code>: <code>T</code> only appears in a non-deduced context and is not explicitly specified (and it's not a parameter pack, so it cannot be \"empty\"), so a specialization declaration cannot be constructed for <code>h</code>, hence the message.</li>\n</ul>\n<p>For the cases that do compile:</p>\n<ul>\n<li><code>#2</code>: <code>Ts</code> cannot be deduced, but one template parameter is explicitly specified for it, so <code>Ts</code> is <code>int</code>, making <code>g</code>'s specialization's parameter <code>void (*)(int)</code>. The overloads are then matched against this destination type, and the first one is chosen.</li>\n<li><code>#4</code>: <code>T</code> is explicitly specified as <code>int</code> and <code>Ts</code> is the empty sequence, so <code>h</code>'s specialization's parameter is <code>void (*)(int)</code>, the same as above.</li>\n</ul>\n<p>When we eliminate one of the overloads, we eliminate the ambiguity during template argument deduction, so the template parameters are no longer in non-deduced contexts, allowing them to be deduced according to the remaining overload.</p>\n<p>A quick verification is that adding a third overload</p>\n<pre><code>void f() { }\n</code></pre>\n<p>allows case <code>#1</code> to compile, which is consistent with all of the above.</p>\n<p>I suppose things were specified this way to allow template arguments involved in pointer-to-function parameters to be obtained from other sources, like other function arguments or explicitly-specified template arguments, even when template argument deduction can't be done based on the pointer-to-function parameter itself. This allows a function template specialization declaration to be constructed in more cases. Since the overloads are then matched against the parameter of the synthesized specialization, this means we have a way to select an overload even if template argument deduction is ambiguous. Quite useful if this is what you're after, terribly confusing in some other cases - nothing unusual, really.</p>\n<p>The funny thing is that MSVC's error message, while apparently nice and helpful, is actually misleading for <code>#1</code>, somewhat but not quite helpful for <code>#3</code>, and incorrect for <code>#4</code>. Also, its behaviour for <code>#2</code> is a side effect of a separate problem in its implementation, as explained in the question; if it weren't for that, it would probably issue the same incorrect error message for <code>#2</code> as well.</p>\n<p>This is not to say that I like Clang's and GCC's error messages for <code>#1</code> and <code>#3</code>; I think they should at least include a note about the non-deduced context and the reason it occurs. </p>\n", "LastActivityDate": "2015-04-02T16:09:58.330", "CommentCount": "0", "CreationDate": "2015-04-02T16:09:58.330", "ParentId": "29417534", "Score": "7", "OwnerUserId": "4326278"}});