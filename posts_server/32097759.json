post_cb({"bq_ids": {"n4140": {"so_32097759_32098850_0": {"length": 29, "quality": 0.8787878787878788, "section_id": 5966}}, "n3337": {"so_32097759_32098850_0": {"length": 29, "quality": 0.8787878787878788, "section_id": 5735}}, "n4659": {"so_32097759_32098850_0": {"length": 29, "quality": 0.8787878787878788, "section_id": 7460}}}, "32097759": {"ViewCount": "950", "Body": "<p><strong>Issue:</strong> passing a generic lambda <em>(to a template function)</em> that captures <code>this</code> and calls a member function of <code>this</code> without an explicit <code>this-&gt;</code> does not compile on gcc. If the lambda is not generic, or if the lambda is not passed to any other function but called in place, it compiles withoit an explicit <code>this-&gt;</code>. Clang is cool with the code in all situations.</p>\n<p>Time for another round of <strong>clang vs gcc</strong>. Who's right?</p>\n<p><a href=\"http://melpon.org/wandbox/permlink/M2eH3FUOentPfieM\">Wandbox example</a></p>\n<hr>\n<pre><code>template&lt;typename TF&gt;\nvoid call(TF&amp;&amp; f)\n{\n    f(1);   \n}\n\nstruct Example\n{        \n    void foo(int){ }\n\n    void bar()\n    {\n        call([this](auto x){ foo(x); });\n    }\n};\n\nint main()\n{\n    Example{}.bar();\n    return 0;\n}\n</code></pre>\n<hr>\n<ul>\n<li>With <code>bar()</code> = <code>call([this](auto x){ foo(x); });</code>\n<ul>\n<li>clang++ 3.6+ <strong>compiles</strong>.</li>\n<li>g++ 5.2+ <strong>does not compile.</strong>\n<blockquote>\n<p id=\"so_32097759_32097759_0\">error: cannot call member function 'void Example::foo(int)' without object\n   call([this](auto x){ foo(x); });`</p>\n</blockquote></li>\n</ul></li>\n</ul>\n<hr>\n<ul>\n<li>With <code>bar()</code> = <code>call([this](auto x){ this-&gt;foo(x); });</code>\n<ul>\n<li>clang++ 3.6+ <strong>compiles</strong>.</li>\n<li>g++ 5.2+ <strong>compiles.</strong> </li>\n</ul></li>\n</ul>\n<hr>\n<ul>\n<li>With <code>bar()</code> = <code>call([this](int x){ foo(x); });</code>\n<ul>\n<li>clang++ 3.6+ <strong>compiles</strong>.</li>\n<li>g++ 5.2+ <strong>compiles.</strong> </li>\n</ul></li>\n</ul>\n<hr>\n<ul>\n<li>With <code>bar()</code> = <code>[this](auto x){ foo(x); }(1);</code>\n<ul>\n<li>clang++ 3.6+ <strong>compiles</strong>.</li>\n<li>g++ 5.2+ <strong>compiles.</strong> </li>\n</ul></li>\n</ul>\n<hr>\n<p>Why is the <code>this-&gt;</code> necessary only in the case of a generic lambda?</p>\n<p>Why is the <code>this-&gt;</code> not necessary if the lambda isn't passed to <code>call</code>?</p>\n<p>Who is being non standard-compliant?</p>\n</hr></hr></hr></hr></hr></hr>", "AcceptedAnswerId": "32098850", "Title": "Calling `this` member function from generic lambda - clang vs gcc", "CreationDate": "2015-08-19T14:03:04.490", "Id": "32097759", "CommentCount": "8", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-08-19T14:50:01.833", "Score": "31", "OwnerUserId": "598696", "Tags": "<c++><lambda><this><language-lawyer><c++14>", "AnswerCount": "1"}, "32098850": {"Id": "32098850", "PostTypeId": "2", "Body": "<p>This is a gcc bug. From [expr.prim.lambda]:</p>\n<blockquote>\n<p id=\"so_32097759_32098850_0\">The <em>lambda-expression</em>\u2019s <em>compound-statement</em> yields the <em>function-body</em> (8.4) of the function call operator,\n  but for purposes of name lookup (3.4), determining the type and value of <code>this</code> (9.3.2) and transforming <em>id-expressions</em>\n  referring to non-static class members into class member access expressions using <code>(*this)</code> (9.3.1), the <em>compound-statement</em> is considered in the context of the <em>lambda-expression</em>. <em>[ Example:</em></p>\n<pre><code>struct S1 {\n    int x, y;\n    int operator()(int);\n    void f() {\n        [=]()-&gt;int {\n            return operator()(this-&gt;x + y); \n                // equivalent to S1::operator()(this-&gt;x + (*this).y)\n                // this has type S1*\n        };\n    }\n};\n</code></pre>\n<p id=\"so_32097759_32098850_1\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p>Since in your example you capture <code>this</code>, the name lookup should include class members of <code>Example</code>, which should therefore find <code>Example::foo</code>. The lookup performed is identical to what would happen if <code>foo(x)</code> appeared in the context of the <em>lambda-expression</em> itself, that is if the code looked like:</p>\n<pre><code>void bar()\n{\n    foo(x); // clearly Example::foo(x);\n}\n</code></pre>\n<p>At least this bug has a very simple workaround as indicated in the question: just do <code>this-&gt;foo(x);</code>. </p>\n", "LastActivityDate": "2015-08-19T14:50:01.833", "CommentCount": "3", "CreationDate": "2015-08-19T14:50:01.833", "ParentId": "32097759", "Score": "10", "OwnerUserId": "2069064"}});