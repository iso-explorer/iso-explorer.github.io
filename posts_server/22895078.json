post_cb({"22913931": {"ParentId": "22895078", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>What you may use to check the base class :</p>\n<pre><code>// Class to check that B::f() is not virtual\n// struct A requires that this class compiles, else struct A should epic fails.\nstruct checkInterfaceIsNotVirtual_B : B\n{\n    void f() = delete;\n};\n</code></pre>\n<p>It will fail to compile if <code>B::f()</code> is virtual :</p>\n<ul>\n<li><p>g++:</p>\n<pre><code>error: deleted function 'virtual void checkInterfaceIsNotVirtual_B::f()'\n</code></pre></li>\n<li><p>clang++:</p>\n<pre><code>error: deleted function 'f' cannot override a non-deleted function\n</code></pre></li>\n</ul>\n", "OwnerUserId": "2684539", "LastEditorUserId": "2684539", "LastEditDate": "2014-04-07T13:44:44.113", "Id": "22913931", "Score": "0", "CreationDate": "2014-04-07T13:28:50.177", "LastActivityDate": "2014-04-07T13:44:44.113"}, "22896479": {"ParentId": "22895078", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>\u00a78.4.1.1 of the C++11 standard defines the function/method definition form:</p>\n<blockquote>\n<h2>8.4 Function definitions</h2>\n<h3>8.4.1 In general</h3>\n<p id=\"so_22895078_22896479_0\"><sup>1</sup> Function definitions have the form</p>\n<p id=\"so_22895078_22896479_1\">\u00a0\u00a0<em>function-definition</em>:<br>\n  \u00a0\u00a0\u00a0\u00a0attribute-specifier-seq<sub>opt</sub> decl-specifier-seq<sub>opt</sub> declarator\n  virt-specifier-seq<sub>opt</sub> function-body<br>\n  \u00a0\u00a0<em>function-body</em>:<br>\n  \u00a0\u00a0\u00a0\u00a0ctor-initializer<sub>opt</sub> compound-statement<br>\n  \u00a0\u00a0\u00a0\u00a0function-try-block<br>\n  \u00a0\u00a0\u00a0\u00a0<code>= default ;</code><br>\n  \u00a0\u00a0\u00a0\u00a0<code>= delete ;</code></br></br></br></br></br></br></p>\n</blockquote>\n<p><em>virt-specifier</em> is defined in \u00a79.2 as:</p>\n<blockquote>\n<p id=\"so_22895078_22896479_2\"><em>virt-specifier</em>:<br>\n  \u00a0\u00a0\u00a0\u00a0<code>override</code><br>\n  \u00a0\u00a0\u00a0\u00a0<code>final</code></br></br></p>\n</blockquote>\n<p>So, no, there is no keyword similar to <code>override</code> for hiding.</p>\n", "OwnerUserId": "251153", "LastEditorUserId": "251153", "LastEditDate": "2014-04-06T16:12:52.150", "Id": "22896479", "Score": "0", "CreationDate": "2014-04-06T16:06:25.363", "LastActivityDate": "2014-04-06T16:12:52.150"}, "bq_ids": {"n4140": {"so_22895078_22896479_1": {"section_id": 3262, "quality": 0.5833333333333334, "length": 7}, "so_22895078_22896479_0": {"section_id": 3262, "quality": 1.0, "length": 4}}, "n3337": {"so_22895078_22896479_1": {"section_id": 3134, "quality": 0.5833333333333334, "length": 7}, "so_22895078_22896479_0": {"section_id": 3134, "quality": 1.0, "length": 4}}, "n4659": {"so_22895078_22896479_0": {"section_id": 4020, "quality": 1.0, "length": 4}}}, "22895078": {"CommentCount": "11", "ViewCount": "505", "PostTypeId": "1", "OwnerDisplayName": "user1150105", "CreationDate": "2014-04-06T14:02:23.690", "LastActivityDate": "2014-04-07T13:44:44.113", "LastEditDate": "2014-04-06T15:54:49.637", "AcceptedAnswerId": "22913931", "LastEditorDisplayName": "user1150105", "Title": "Explicitly hide a base function in C++", "Id": "22895078", "Score": "2", "Body": "<p>C++11 introduced very useful specifier <code>override</code> for <em>explicitly override</em> a base virtual function. But what about <em>explicit hiding</em>?</p>\n<p>For example, consider the code:</p>\n<pre><code>struct A: B {\n    void f();\n}\n</code></pre>\n<ol>\n<li>If there is a virtual <code>void B::f()</code> the code cause implicit <em>overriding</em> this function.</li>\n<li>If there is a non-virtual <code>void B::f()</code> the code cause <em>hiding</em> this function.</li>\n</ol>\n<p>That is, the meaning of the code depends on existence and virtuality of <code>void B::f()</code>.</p>\n<p><strong>Question.</strong> How to explicitly hide a base function? I want to get error if I try to hide virtual function. </p>\n<p>Such as <code>override</code> is the <em>guard</em> to ensure that <em>there is</em> virtual base function with the same prototype, I need a <em>guard</em> to ensure that <em>there is no</em> virtual base function with the same prototype.</p>\n<hr>\n<p>Epic fail example:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nstruct B {\n    void f() {printf(\"Hello\\n\");}\n    void g() {f();}\n};\n\nstruct A: B {\n    void f() {g();}\n};\n\nint main() {\n    A a;\n    a.f();\n    return 0;\n}\n</code></pre>\n<p>The program print \"Hello\". But if I make <code>B::f()</code> virtual the program cause segmentation fault (infinite recursion). This may be a real problem if <code>B</code> class is third-party and I just #include it, that is changing the virtuality in the third-party code may cause fault in my code.</p>\n<p><strong>UPD.</strong> I found that C# <a href=\"http://msdn.microsoft.com/en-us/library/435f1dw2.aspx\" rel=\"nofollow\">have this feature</a> via <code>new</code> specifier. It's seems that C++ have not (yet?).</p>\n</hr>", "Tags": "<c++>", "AnswerCount": "2"}});