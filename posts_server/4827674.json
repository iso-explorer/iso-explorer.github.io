post_cb({"4827737": {"Id": "4827737", "PostTypeId": "2", "Body": "<p>IIRC the default packing is on byte alignment, use <a href=\"http://msdn.microsoft.com/en-us/library/xh3e3fd0%28v=VS.100%29.aspx\" rel=\"nofollow\">/Zpn</a> to set to another packing, then you get your padding. (or #pragma pack(n) )</p>\n<p>EDIT: come to think about I think the default packing even varies between VS versions</p>\n", "LastActivityDate": "2011-01-28T11:33:30.043", "CommentCount": "1", "CreationDate": "2011-01-28T11:33:30.043", "ParentId": "4827674", "Score": "0", "OwnerUserId": "45685"}, "4828138": {"Id": "4828138", "PostTypeId": "2", "Body": "<p>Well to answer your question literally I don't think the standard says anything about #pragma pack at all. So I would say that your code has undefined behavour according to the standard.</p>\n", "LastActivityDate": "2011-01-28T12:20:44.073", "CommentCount": "1", "CreationDate": "2011-01-28T12:20:44.073", "ParentId": "4827674", "Score": "1", "OwnerUserId": "417292"}, "4827997": {"Id": "4827997", "PostTypeId": "2", "Body": "<p>You should use <code>__declspec</code> for this purpose. Your code generated misaligned objects on my computer too (using VS2010) but when I changed to <code>__declspec(align(8))</code>, the pointers were correctly aligned.</p>\n<p>I believe that <code>pragma pack</code> only changes the <em>size</em> of the struct and doesn't make any guarantees about it's location.</p>\n", "LastEditorUserId": "298661", "LastActivityDate": "2011-01-28T12:11:34.917", "Score": "7", "CreationDate": "2011-01-28T12:04:47.677", "ParentId": "4827674", "CommentCount": "5", "OwnerUserId": "298661", "LastEditDate": "2011-01-28T12:11:34.917"}, "4827900": {"Id": "4827900", "PostTypeId": "2", "Body": "<p>The standard guarantees that the memory is correctly aligned.</p>\n<p>I doubt that Visual Studio got something so basic wrong.</p>\n<p>Currently I don't follow why you think it is not aligned?</p>\n<p>Are you trying to suggest it should be aligned to 16 byte boundaries?<br>\nThat is not required by the standard. It may only need to align to 4 byte boundaries.</br></p>\n<h3>3.11 Alignment [basic.align]</h3>\n<blockquote>\n<p id=\"so_4827674_4827900_0\">2 A fundamental alignment is represented by an alignment less than or equal to the greatest alignment supported by the implementation in all contexts, which is equal to alignof(std::max_align_t) (18.2).</p>\n</blockquote>\n<p>Thus the following code should print out the maximum required alignment of the implementation:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstddef&gt;\n#include &lt;cstdalign&gt;\n\nint main()\n{\n        std::cout &lt;&lt; alignof(std::max_align_t) &lt;&lt; \"\\n\";\n}\n</code></pre>\n", "LastEditorUserId": "14065", "LastActivityDate": "2011-01-28T12:27:08.313", "Score": "2", "CreationDate": "2011-01-28T11:53:17.203", "ParentId": "4827674", "CommentCount": "10", "OwnerUserId": "14065", "LastEditDate": "2011-01-28T12:27:08.313"}, "bq_ids": {"n4140": {"so_4827674_4827900_0": {"length": 15, "quality": 0.9375, "section_id": 7241}}, "n3337": {"so_4827674_4827900_0": {"length": 15, "quality": 0.9375, "section_id": 6985}}, "n4659": {"so_4827674_4827900_0": {"length": 14, "quality": 0.875, "section_id": 8750}}}, "4827736": {"Id": "4827736", "PostTypeId": "2", "Body": "<pre><code> printf(\"sizeof(A)= %d, pointer= %08x\", sizeof(A), pa);\n</code></pre>\n<p>As a token of caution, use <code>%p</code> when you want to print <em>memory address</em>:</p>\n<pre><code>printf(\"sizeof(A)= %d, pointer= %p\", sizeof(A), pa);\n</code></pre>\n<p><code>%x</code> expects <code>unsigned int</code> whose size may be different from the size of a pointer.</p>\n", "LastEditorUserId": "415784", "LastActivityDate": "2011-01-28T11:39:48.850", "Score": "0", "CreationDate": "2011-01-28T11:33:16.510", "ParentId": "4827674", "CommentCount": "3", "OwnerUserId": "415784", "LastEditDate": "2011-01-28T11:39:48.850"}, "4828141": {"Id": "4828141", "PostTypeId": "2", "Body": "<p><code>operator new()</code> which keyword <code>new</code> calls under the hood, has no knowledge of type's alignment. The only alignment requirement is that <code>operator new()</code> has to allocate memory suitably aligned for a built-in type with the largest alignment requirement, which is often 8 on a 32-bit platform (the alignment requirement of double).</p>\n<p>Having said that, the example you posted allocates memory aligned on 8-byte boundary as it should.</p>\n", "LastActivityDate": "2011-01-28T12:21:19.220", "CommentCount": "1", "CreationDate": "2011-01-28T12:21:19.220", "ParentId": "4827674", "Score": "0", "OwnerUserId": "412080"}, "4827674": {"ViewCount": "1781", "Body": "<p>If new[] expression is used to create an array of objects having destructors,\nthe objects in the array may not be properly alligned</p>\n<pre>\n#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n\n#pragma pack(8)\nstruct A{\n  int64_t i;\n  char dummy;\n  ~A(){}\n};\n\nint main(){\n  A* pa= new A[2];\n  printf(\"sizeof(A)= %d, pointer= %p\", sizeof(A), pa);\n}\n\n</pre>\n<p>(I build 32-bit target with VC++ 2010 express)</p>\n<p>The output (on my computer) is:</p>\n<pre>\n sizeof(A)= 16 pointer= 00344f4c\n</pre>\n<p>(sizeof(A)= 16 shows that compiler undrstand the alignment requirements for A and the struct is padded with 7 bytes <b>[ edited: __alignof(A) also returns 8 ]</b>)</p>\n<p>I understand why it happens: new[] needs to store array length and it use for this purpose first 4 bytes of allocated memory, then it allocates the array itself without proper padding.</p>\n<p>From a practical viewpoint such a behaviour is definitely poor, \nbut is it standard compliant or not?</p>\n", "AcceptedAnswerId": "4827997", "Title": "new[] expression does not respect alignment in Microsoft VC++", "CreationDate": "2011-01-28T11:25:08.150", "Id": "4827674", "CommentCount": "10", "LastEditDate": "2011-01-28T13:48:38.790", "PostTypeId": "1", "LastEditorUserId": "396672", "LastActivityDate": "2011-01-28T17:28:11.903", "Score": "5", "OwnerUserId": "396672", "Tags": "<c++><visual-c++>", "AnswerCount": "8"}, "4827969": {"Id": "4827969", "PostTypeId": "2", "Body": "<p>If <code>struct A</code> just contains <a href=\"http://en.wikipedia.org/wiki/Plain_old_data_structure\" rel=\"nofollow\">plain old data</a>, you can use <code>aligned_malloc</code> (see <a href=\"http://msdn.microsoft.com/en-us/library/8z34s9c6%28v=vs.80%29.aspx\" rel=\"nofollow\">Microsoft's documentation</a>). If it needs to be constructed, you can combine this with the <code>placement new</code> operator. Something like this (I don't have Microsoft VC++, so it might not compile):</p>\n<pre><code>void* buf = _aligned_malloc (2 * sizeof (struct A), 8) ;\nA* pa = new (buf) A[2];\n</code></pre>\n<p>Deleting this is a pain: you have to call pa[i].~A() explicitly for each array element, and then <code>_aligned_free (buf)</code>.</p>\n", "LastActivityDate": "2011-01-28T12:01:03.140", "CommentCount": "1", "CreationDate": "2011-01-28T12:01:03.140", "ParentId": "4827674", "Score": "0", "OwnerUserId": "428857"}, "4831211": {"Id": "4831211", "PostTypeId": "2", "Body": "<p>Interesting.  My first question would be: what happens without the #pragma pack?  What is the native alignement for this struct.  The operator new has no means of knowing what options you might have set with the pragma, so its presence or absense has no effect here.  And formally, there's no violation of the standard, since Intel doesn't <em>require</em> any alignment for anything (but maintaining proper alignment sure helps performance).  All in all, it doesn't seem like a desirable \"feature\", but it's a QoI issue, and not a standard conformance one.</p>\n", "LastActivityDate": "2011-01-28T17:28:11.903", "CommentCount": "1", "CreationDate": "2011-01-28T17:28:11.903", "ParentId": "4827674", "Score": "1", "OwnerUserId": "469993"}});