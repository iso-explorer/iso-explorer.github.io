post_cb({"bq_ids": {"n4140": {"so_48412892_48420671_4": {"length": 4, "quality": 0.5714285714285714, "section_id": 3291}, "so_48412892_48420671_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 3234}}, "n3337": {"so_48412892_48420671_3": {"length": 4, "quality": 0.5714285714285714, "section_id": 3107}}, "n4659": {"so_48412892_48420671_3": {"length": 7, "quality": 1.0, "section_id": 393}, "so_48412892_48420671_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 393}, "so_48412892_48420671_4": {"length": 5, "quality": 0.7142857142857143, "section_id": 393}, "so_48412892_48420671_7": {"length": 13, "quality": 0.9285714285714286, "section_id": 8741}, "so_48412892_48420671_6": {"length": 5, "quality": 1.0, "section_id": 393}, "so_48412892_48420671_2": {"length": 6, "quality": 0.75, "section_id": 393}}}, "48420322": {"Id": "48420322", "PostTypeId": "2", "Body": "<p>\"compiler optimizations can further eliminate temporaries.\"</p>\n<p>It seems you have a slight misunderstanding of the C++ semantics. The C++ Standard talks about temporaries to define the formal semantics of a program. This is a compact way to describe a large set of possible executions.</p>\n<p>An actual compiler doesn't need to behave at all like this. And often, they won't. Real compilers know about registers, real compilers don't pretend that POD's have (trivial) constructors and destructors. This happens already before optimizations. I don't know of any compiler that will generate trivial ctors in debug mode.</p>\n<p>Now some semantics described by the Standard can only be achieved by a fairly close approximation. When destructors have visible side effects (think <code>std::cout</code>), temporaries of those types cannot be entirely eliminated. But real compilers might implement the visible side effect while not allocating any storage. The notion of a temporary existing or not existing is a binary view, and in reality there are intermediate forms.</p>\n", "LastActivityDate": "2018-01-24T10:34:32.077", "Score": "4", "CreationDate": "2018-01-24T10:34:32.077", "ParentId": "48412892", "CommentCount": "0", "OwnerUserId": "15416"}, "48420671": {"Id": "48420671", "PostTypeId": "2", "Body": "<p>Due to the \"as-if\" rule it is probably unreliable to try to view the compilation process to see where temporaries are created.</p>\n<p>But reading the code (and coding) while keeping in mind the following paragraph of the standard may help in finding where temporaries are created or not, <a href=\"https://timsong-cpp.github.io/cppwp/n4659/class.temporary#2\" rel=\"nofollow noreferrer\">[class.temporary]/2</a></p>\n<blockquote>\n<p id=\"so_48412892_48420671_0\">The materialization of a temporary object is generally delayed as long as possible in order to avoid creating unnecessary temporary objects. [\u2009Note: Temporary objects are materialized:</p>\n<ul>\n<li><p id=\"so_48412892_48420671_1\">when binding a reference to a prvalue ([dcl.init.ref], [expr.type.conv], [expr.dynamic.cast], [expr.static.cast], [expr.const.cast], [expr.cast]),</p></li>\n<li><p id=\"so_48412892_48420671_2\">when performing member access on a class prvalue ([expr.ref], [expr.mptr.oper]),</p></li>\n<li><p id=\"so_48412892_48420671_3\">when performing an array-to-pointer conversion or subscripting on an array prvalue,</p></li>\n<li><p id=\"so_48412892_48420671_4\">when initializing an object of type std\u200b::\u200binitializer_\u00adlist from a braced-init-list ([dcl.init.list]),</p></li>\n<li><p id=\"so_48412892_48420671_5\">for certain unevaluated operands ([expr.typeid], [expr.sizeof]), and</p></li>\n<li><p id=\"so_48412892_48420671_6\">when a prvalue appears as a discarded-value expression.</p></li>\n</ul>\n</blockquote>\n<p>In this paragraph coming from the C++17 standard, the term <em>prvalue</em> has a new definition <a href=\"https://timsong-cpp.github.io/cppwp/n4659/basic.lval#1.2\" rel=\"nofollow noreferrer\">[basic.lval]/1</a>:</p>\n<blockquote>\n<p id=\"so_48412892_48420671_7\">A prvalue is an expression whose evaluation initializes an object or a bit-field, or computes the value of the operand of an operator, as specified by the context in which it appears.</p>\n</blockquote>\n<p>And in the last standard (pre C++20), the paragraph [basic.lval] has been moved to <em>Expressions</em> [expr], so what we knew as value categories is evolving to become expression categories.</p>\n", "LastActivityDate": "2018-01-24T10:52:44.803", "Score": "2", "CreationDate": "2018-01-24T10:52:44.803", "ParentId": "48412892", "CommentCount": "0", "OwnerUserId": "5632316"}, "48412892": {"ViewCount": "144", "Body": "<p>What is the fastest way to uncover where temporaries are created in my C++ code?</p>\n<p>The answer is not always easily deducible from the standard and compiler optimizations can further eliminate temporaries.</p>\n<p>I have experimented with <em>godbolt.org</em> and its fantastic. Unfortunately it often hides the trees behind the wood of assembler when it comes to temporaries. Additionally, aggressive compiler optimization options make the assembler totally unreadable.</p>\n<p>Any other means to accomplish this?</p>\n", "AcceptedAnswerId": "48420322", "Title": "Show where temporaries are created in C++", "CreationDate": "2018-01-24T00:09:00.673", "Id": "48412892", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2018-01-24T10:52:44.803", "Score": "4", "OwnerUserId": "2712726", "Tags": "<c++><copy-elision><temporaries>", "AnswerCount": "2"}});