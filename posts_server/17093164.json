post_cb({"17094760": {"Id": "17094760", "PostTypeId": "2", "Body": "<p>On the main thread, after <code>main()</code> terminates, the CRT acquires the exit lock and calls your static instance destructor, which waits for your background thread to exit.</p>\n<p>On the background thread, after your thread function terminates, the CRT attempts to acquire the exit lock to do some thread termination work. This blocks forever because the exit lock is held by the main thread, which is waiting for <em>this</em> thread to exit.</p>\n<p>It's a simple deadlock that's caused by the CRT implementation. The bottom line is that you can't await thread termination in a static instance destructor on Windows.</p>\n", "LastActivityDate": "2013-06-13T18:48:04.897", "Score": "22", "CreationDate": "2013-06-13T18:48:04.897", "ParentId": "17093164", "CommentCount": "0", "OwnerUserId": "2142539"}, "19758949": {"Id": "19758949", "PostTypeId": "2", "Body": "<p>This deadlock bug is the same as in </p>\n<p><a href=\"https://stackoverflow.com/questions/10915233/stdthreadjoin-hangs-if-called-after-main-exits-when-using-vs2012-rc\">std::thread::join() hangs if called after main() exits when using VS2012 RC</a></p>\n<p>and it is not fixed in Visual Studio 2013.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-11-03T22:25:32.410", "Score": "1", "CreationDate": "2013-11-03T22:25:32.410", "ParentId": "17093164", "CommentCount": "0", "LastEditDate": "2017-05-23T11:45:43.160", "OwnerUserId": "2950810"}, "17093164": {"ViewCount": "2152", "Body": "<p>i have implemented a singleton (static version) in C++. I know all the controversy about this pattern and potential thread-safety issues, but i am curious why this exact implementation won't halt. The program never quits, it remains in a deadlock state at the end.</p>\n<p>singleton.h:</p>\n<pre><code>#pragma once\n#include &lt;thread&gt;\n#include &lt;atomic&gt;\n\nclass Singleton\n{\npublic:\n    static Singleton&amp; getInstance();\n\nprivate:\n    std::thread mThread;\n    std::atomic_bool mRun;\n\n    Singleton();\n    ~Singleton();\n    void threadFoo();\n};\n</code></pre>\n<p>singleton.cpp</p>\n<pre><code>#include \"singleton.h\"\n\nSingleton&amp; Singleton::getInstance()\n{\n    static Singleton instance;\n    return instance;\n} \n\nSingleton::Singleton()\n{\n    mRun.store(true);\n    mThread = std::thread(&amp;Singleton::threadFoo, this);\n}\n\nSingleton::~Singleton()\n{\n    mRun.store(false);\n\n    if(mThread.joinable())\n        mThread.join();\n}\n\nvoid Singleton::threadFoo()\n{\n    while(mRun)\n    {\n    }\n}\n</code></pre>\n<p>main.cpp</p>\n<pre><code>#include \"singleton.h\"\n\nint main()\n{\n    Singleton::getInstance();\n    return 0;\n}\n</code></pre>\n<p>What I already know:</p>\n<ul>\n<li>the thread terminates</li>\n<li>the main thread is stuck in the join</li>\n<li>it has something to do with the static, if i make the constructor public and create an instance of Singleton in main() it will correctly terminate.</li>\n</ul>\n<p>Using Visual Studio 2012. Thanks for your advice.</p>\n", "AcceptedAnswerId": "17096248", "Title": "Why does this C++ static singleton never stop?", "CreationDate": "2013-06-13T17:16:17.260", "Id": "17093164", "CommentCount": "9", "FavoriteCount": "8", "PostTypeId": "1", "LastEditDate": "2013-06-13T18:13:14.917", "LastEditorUserId": "528313", "LastActivityDate": "2013-11-03T22:25:32.410", "Score": "17", "OwnerUserId": "1160814", "Tags": "<c++><multithreading><c++11><static><singleton>", "AnswerCount": "5"}, "17096858": {"Id": "17096858", "PostTypeId": "2", "Body": "<p>See [basic.start.term] in the Standard:</p>\n<blockquote>\n<p id=\"so_17093164_17096858_0\">If there is a use of a standard library object or function not\n  permitted within signal handlers (18.10) that does not happen before\n  (1.10) completion of destruction of objects with static storage\n  duration and execution of std::atexit registered functions (18.5), the\n  program has undefined behavior. [Note: If there is a use of an object\n  with static storage duration that does not happen before the object\u2019s\n  destruction, the program has undefined behavior. Terminating every\n  thread before a call to std::exit or the exit from main is sufficient,\n  but not necessary, to satisfy these requirements. These requirements\n  permit thread managers as static-storage-duration objects. \u2014end note ]</p>\n</blockquote>\n", "LastActivityDate": "2013-06-13T20:51:11.227", "Score": "4", "CreationDate": "2013-06-13T20:51:11.227", "ParentId": "17093164", "CommentCount": "0", "OwnerUserId": "1730086"}, "17094741": {"Id": "17094741", "PostTypeId": "2", "Body": "<p>I've traced it down to <code>void __cdecl _lock(int locknum)</code> inside <code>mlock.c</code>. When <code>main()</code> ends, the main thread goes there and enters critical section <code>EnterCriticalSection( _locktable[locknum].lock );</code>. Then Singleton destructor gets called and the other thread tries to enter the same critical section, but can't, and so it starts waiting for main thread to leave the critical section. Main thread, in turn, waits for the other thread. So I guess it's a bug.</p>\n", "LastActivityDate": "2013-06-13T18:47:09.627", "Score": "7", "CreationDate": "2013-06-13T18:47:09.627", "ParentId": "17093164", "CommentCount": "0", "OwnerUserId": "1641779"}, "bq_ids": {"n4140": {"so_17093164_17096858_0": {"length": 56, "quality": 0.8888888888888888, "section_id": 7159}}, "n3337": {"so_17093164_17096858_0": {"length": 56, "quality": 0.8888888888888888, "section_id": 6903}}, "n4659": {"so_17093164_17096858_0": {"length": 56, "quality": 0.8888888888888888, "section_id": 8666}}}, "17096248": {"Id": "17096248", "PostTypeId": "2", "Body": "<p>Ok thank you all for your hints. Apparently this pattern implementation results in a deadlock on VC++.</p>\n<p>After doing some further research i found this implementation based on C++11 mechanics which is working in VC++.</p>\n<p>singleton.h</p>\n<pre><code>#pragma once\n#include &lt;thread&gt;\n#include &lt;atomic&gt;\n#include &lt;memory&gt;\n#include &lt;mutex&gt;\n\n\nclass Singleton\n{\npublic:\n    static Singleton&amp; getInstance();\n    virtual ~Singleton();\n\nprivate:\n    static std::unique_ptr&lt;Singleton&gt; mInstance;\n    static std::once_flag mOnceFlag;\n    std::thread mThread;\n    std::atomic_bool mRun;\n\n    Singleton();\n\n    void threadFoo();\n};\n</code></pre>\n<p>singleton.cpp</p>\n<pre><code>#include \"singleton.h\"\n\nstd::unique_ptr&lt;Singleton&gt; Singleton::mInstance = nullptr;\nstd::once_flag Singleton::mOnceFlag;\n\n\nSingleton&amp; Singleton::getInstance()\n{\n    std::call_once(mOnceFlag, [] { mInstance.reset(new Singleton); });\n    return *mInstance.get();\n}\n\n\nSingleton::Singleton()\n{\n    mRun.store(true);\n    mThread = std::thread(&amp;Singleton::threadFoo, this);\n}\n\nSingleton::~Singleton()\n{ \n    mRun.store(false);\n\n    if(mThread.joinable())\n        mThread.join();\n}\n\nvoid Singleton::threadFoo()\n{\n    while(mRun.load())\n    {\n    }\n}\n</code></pre>\n<p><strong>UPDATE</strong></p>\n<p>It looks like Microsoft is aware of this issue. In the VC++ forums a user named \"dlafleur\" reported this post:\n<a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/747145\" rel=\"nofollow\">https://connect.microsoft.com/VisualStudio/feedback/details/747145</a></p>\n", "LastEditorUserId": "1160814", "LastActivityDate": "2013-06-14T08:35:39.770", "Score": "4", "CreationDate": "2013-06-13T20:18:52.810", "ParentId": "17093164", "CommentCount": "0", "LastEditDate": "2013-06-14T08:35:39.770", "OwnerUserId": "1160814"}});