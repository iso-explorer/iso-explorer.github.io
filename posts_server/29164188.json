post_cb({"29165754": {"ParentId": "29164188", "CommentCount": "5", "CreationDate": "2015-03-20T11:44:19.050", "OwnerUserId": "3959454", "PostTypeId": "2", "Id": "29165754", "Score": "8", "Body": "<p>Regarding this:</p>\n<pre><code>Foo g() { Foo a; return a; }  // gcc complains, clang is fine\n</code></pre>\n<p>GCC is right, this shouldn't compile because of <code>[class.copy]/32</code> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_29164188_29165754_0\">When the criteria for elision of a copy/move operation are met, but not for an <em>exception-declaration</em>, and the\n  object to be copied is designated by an lvalue, or when the expression in a <code>return</code> statement is a (possibly\n  parenthesized) id-expression that names an object with automatic storage duration declared in the body or\n  parameter-declaration-clause of the innermost enclosing function or lambda-expression, <strong>overload resolution\n  to select the constructor for the copy is first performed as if the object were designated by an rvalue</strong>. If\n  the first overload resolution fails or was not performed, or if the type of the first parameter of the selected\n  constructor is not an rvalue reference to the object\u2019s type (possibly cv-qualified), overload resolution is\n  performed again, considering the object as an lvalue. [ <em>Note:</em> <strong>This two-stage overload resolution must be\n  performed regardless of whether copy elision will occur. It determines the constructor to be called if elision\n  is not performed, and the selected constructor must be accessible even if the call is elided.</strong> <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>So implementation should choose move constructor for elision, and as it's deleted, the program is ill-formed.</p>\n", "LastActivityDate": "2015-03-20T11:44:19.050"}, "29164188": {"CommentCount": "5", "AcceptedAnswerId": "29164221", "PostTypeId": "1", "LastEditorUserId": "4693432", "CreationDate": "2015-03-20T10:19:51.200", "LastActivityDate": "2015-03-20T15:12:17.317", "LastEditDate": "2015-03-20T15:12:17.317", "ViewCount": "1917", "FavoriteCount": "4", "Title": "Does returning a local object require move semantics?", "Id": "29164188", "Score": "15", "Body": "<p>When returning a local object by value, C++ compilers <strong>may</strong> optimize out unnecessary copies (copy elision) by taking advantage of the move semantics.<br>\n\"<strong>may</strong> optimize\" implies that if proper conditions are not met, the behavior should fall back to the default return by value semantics, based on copy.<br>\nThus, as I understand it, it is always valid to return a copyable object by value.</br></br></p>\n<p>But compilers (clang and gcc) do not seem to agree with my interpretation, as shown by the MWE below.</p>\n<pre><code>class Foo {\npublic:\n    Foo();\n    Foo(const Foo&amp;);\n    Foo(Foo&amp;&amp;) = delete;\n}\n\nFoo f() { return Foo(); }  // error: call to explicitly deleted constructor of 'Foo'\nFoo g() { Foo a; return a; }  // gcc complains, clang is fine\nFoo x = g();  // error: call to explicitly deleted constructor of 'A'\n</code></pre>\n<p>Q1: Does return by value requires object to be movable?<br>\nQ2: If not, do gcc and clang misbehave on my MWE or am I missing something else?</br></p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "4693432", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_29164188_29165754_0": {"section_id": 481, "quality": 0.946236559139785, "length": 88}}, "n3337": {"so_29164188_29165754_0": {"section_id": 472, "quality": 0.6881720430107527, "length": 64}}, "n4659": {"so_29164188_29165754_0": {"section_id": 504, "quality": 0.8279569892473119, "length": 77}}}, "29164221": {"ParentId": "29164188", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2015-03-20T10:21:35.473", "Score": "30", "LastEditorUserId": "596781", "LastEditDate": "2015-03-20T12:07:21.327", "Id": "29164221", "OwnerUserId": "596781", "Body": "<p>You are simply meeting the intended behaviour of overload resolution: <code>Foo()</code> is an rvalue, so overload resolution finds the constructor <code>Foo(Foo&amp;&amp;)</code> as the best match. Since that overload is deleted, your program is ill-formed. Moreover, there's a special rule that says <code>Foo a; return a;</code> will also perform overload resolution as if <code>a</code> was an rvalue first. (The rule applies essentially whenever the the return statement is eligible for copy elision.)</p>\n<p>This is all working as intended. It was you who deleted the overload, so you requested expressly that such constructions be forbidden.</p>\n<p>Note that \"real\" code doesn't usually meet this obstacle, since as soon as you declare a copy constructor, your class <em>will not have</em> any move constructors at all. But you went out of your way to say, \"no, actually I <em>do</em> want a move constructor, and I want it to be an error if anyone attempts to use it\".</p>\n", "LastActivityDate": "2015-03-20T12:07:21.327"}});