post_cb({"25926441": {"ParentId": "25926407", "CommentCount": "12", "Body": "<p>Neither. Static variables inside functions reside in the data section. For the record, so do static variables outside functions, and global ones.</p>\n", "OwnerUserId": "219159", "PostTypeId": "2", "Id": "25926441", "Score": "1", "CreationDate": "2014-09-19T04:34:35.900", "LastActivityDate": "2014-09-19T04:34:35.900"}, "25926407": {"CommentCount": "0", "AcceptedAnswerId": "25926473", "CreationDate": "2014-09-19T04:30:18.500", "LastActivityDate": "2014-09-19T05:00:09.753", "PostTypeId": "1", "ViewCount": "575", "FavoriteCount": "1", "Title": "Does a reference singleton go on the stack or the heap?", "Id": "25926407", "Score": "3", "Body": "<p>I've read a lot of articles here about singletons, but none really touch my issue. I understand Singletons should only be use when needed and, in my game, I am using them for specific parts of the engine.</p>\n<p>That said, I originally had my singletons as pointers like this:</p>\n<pre><code>static MapReader* Instance()\n{\n    if (instance == 0)\n    {\n        instance = new MapReader();\n        return instance;\n    }\n    return instance;\n}\n</code></pre>\n<p>However I always felt like using too many pointers is bad for leaks and I prefer not using them if I can help it (or smart pointers if I have to). So I've changed all my singletons to references like this:</p>\n<pre><code>static MapReader&amp; Instance()\n{\n    static MapReader instance;\n    return instance;\n}\n</code></pre>\n<p>However, now I've notice my game to lag at odd times and then speed up, like the FPS are a little wonky. </p>\n<p>My question is that; does the reference singleton all pile up on the stack? or do they still get allocated on the heap? And should I change them back to pointers using smart pointers?</p>\n", "Tags": "<c++><pointers><reference><singleton>", "OwnerUserId": "2146952", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_25926407_25926473_2": {"section_id": 7166, "quality": 0.9, "length": 9}, "so_25926407_25926473_1": {"section_id": 7165, "quality": 0.9523809523809523, "length": 20}, "so_25926407_25926473_0": {"section_id": 7164, "quality": 0.8181818181818182, "length": 18}, "so_25926407_25926473_3": {"section_id": 7167, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_25926407_25926473_2": {"section_id": 6910, "quality": 0.9, "length": 9}, "so_25926407_25926473_1": {"section_id": 6909, "quality": 0.9523809523809523, "length": 20}, "so_25926407_25926473_0": {"section_id": 6908, "quality": 0.8181818181818182, "length": 18}, "so_25926407_25926473_3": {"section_id": 6911, "quality": 0.9333333333333333, "length": 14}}, "n4659": {"so_25926407_25926473_2": {"section_id": 8674, "quality": 0.9, "length": 9}, "so_25926407_25926473_1": {"section_id": 8673, "quality": 0.9523809523809523, "length": 20}, "so_25926407_25926473_0": {"section_id": 8672, "quality": 0.8181818181818182, "length": 18}, "so_25926407_25926473_3": {"section_id": 8675, "quality": 0.9333333333333333, "length": 14}}}, "25926473": {"ParentId": "25926407", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>It's almost certainly not on the heap by virtue of the fact it's not created with <code>new</code>.</p>\n<p>However, the standard is silent on <em>where</em> <code>static</code> variables are placed, mentioning only their <em>behaviour.</em> See for example, <code>C++11 3.7.1</code>:</p>\n<blockquote>\n<p id=\"so_25926407_25926473_0\">1/ All variables which do not have dynamic storage duration, do not have thread storage duration, and are not local have static storage duration. The storage for these entities shall last for the duration of the program (3.6.2, 3.6.3).</p>\n<p id=\"so_25926407_25926473_1\">2/ If a variable with static storage duration has initialization or a destructor with side effects, it shall not be eliminated even if it appears to be unused, except that a class object or its copy/move may be eliminated as specified in 12.8.</p>\n<p id=\"so_25926407_25926473_2\">3/ The keyword static can be used to declare a local variable with static storage duration.</p>\n<p id=\"so_25926407_25926473_3\">4/ The keyword static applied to a class data member in a class definition gives the data member static storage duration.</p>\n</blockquote>\n<p>That's pretty much the extent of what the standard itself imposes on them.</p>\n<p>Most implementations would likely have an area separate from both heap and stack for storing variables of static storage duration.</p>\n<p>It's also almost certainly not the use of statics and references that are slowing your code down. Having looked deeply into compilers and how they work, statics tend to be at <em>least</em> as fast as other variables since they're very quick to locate in memory.</p>\n<hr>\n<p>As an aside, your pointer variant of the singleton has two issues. The first is a potential race condition if you're working in a threaded environment. There's a possibility that more than one object may be created if distinct threads call <code>Instance()</code>.</p>\n<p>Specifically, if thread A enters the <code>if</code> statement then thread B starts running, <code>B</code> can go through, create an object then return. If <code>A</code> then continues, it will create a <em>new</em> object.</p>\n<p>If you're single-threaded, or you create the instance only from one thread, or you create the instance <em>before</em> other threads are running, you should be fine.</p>\n<p>The second issue is just eye candy. There's no need to return the object from within the <code>if</code> block, since it will be returned when you get to the bottom of the function:</p>\n<pre><code>static MapReader* Instance() {\n    if (instance == 0)\n        instance = new MapReader();\n    return instance;\n}\n</code></pre>\n</hr>", "OwnerUserId": "14860", "LastEditorUserId": "14860", "LastEditDate": "2014-09-19T05:00:09.753", "Id": "25926473", "Score": "3", "CreationDate": "2014-09-19T04:38:44.817", "LastActivityDate": "2014-09-19T05:00:09.753"}});