post_cb({"8171337": {"CommentCount": "2", "AcceptedAnswerId": "8171388", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2011-11-17T17:10:55.080", "LastActivityDate": "2011-11-17T17:19:35.327", "LastEditDate": "2011-11-17T17:19:35.327", "ViewCount": "132", "FavoriteCount": "1", "Title": "Address of a reference to first item of an array", "Id": "8171337", "Score": "5", "Body": "<p>I'm a bit confused about this:</p>\n<p>I thought that if a pointer points to some object, assigning a dereference to some reference variable was a mere aliasing.</p>\n<p>Example:</p>\n<pre><code>Object * p = &amp;o;\nObject &amp; r = *p;\n// r and o are the same object\n</code></pre>\n<p>I was aware there was some illegal cases, like:</p>\n<pre><code>Object * p = NULL;\nObject &amp; r = *p; // illegal\n</code></pre>\n<p>Now, what about the code below ?</p>\n<pre><code>const char * p = \"some string\";\nconst char &amp; r = *p;\n</code></pre>\n<p>or</p>\n<pre><code>const char &amp; r = *\"some string\";\n</code></pre>\n<p>I was said that this particular case involved temporary objects and, therefore I could'nt get the address of r and be sure it will point to a memory array containing my initial string.</p>\n<p>What does C++ standard states about that case ? Is it another illegal case like the NULL provision, or is it allowed behavior.</p>\n<p>In other words, is it legal or illegal (undefined behavior ?) to write something like ?</p>\n<pre><code>   char buffer[100];\n   strcpy(buffer, &amp;r);\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "168465", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_8171337_8171388_1": {"section_id": 7164, "quality": 0.75, "length": 18}, "so_8171337_8171388_0": {"section_id": 5356, "quality": 0.9285714285714286, "length": 26}}, "n3337": {"so_8171337_8171388_1": {"section_id": 6908, "quality": 0.75, "length": 18}, "so_8171337_8171388_0": {"section_id": 5153, "quality": 0.9285714285714286, "length": 26}}, "n4659": {"so_8171337_8171388_1": {"section_id": 8672, "quality": 0.75, "length": 18}, "so_8171337_8171388_0": {"section_id": 6781, "quality": 0.9285714285714286, "length": 26}}}, "8171388": {"ParentId": "8171337", "CommentCount": "3", "Body": "<p><strong>That's fine.</strong></p>\n<p>The string literal's data buffer will exist for the duration of your program (usually in a special segment of the process memory).</p>\n<blockquote>\n<p id=\"so_8171337_8171388_0\"><code>[C++11: 2.14.5/8]:</code> Ordinary string literals and UTF-8 string\n  literals are also referred to as narrow string literals. <strong>A narrow\n  string literal</strong> has type \u201carray of <em>n</em> const char`\u201d, where <em>n</em> is the size\n  of the string as defined below, and <strong>has static storage duration</strong> (3.7).</p>\n<p id=\"so_8171337_8171388_1\"><code>[C++11: 3.7.1/1]:</code> All variables which do not have dynamic storage\n  duration, do not have thread storage duration, and are not local have\n  <em>static storage duration</em>. <strong>The storage for these entities shall last for\n  the duration of the program</strong> (3.6.2, 3.6.3).</p>\n</blockquote>\n<p>After all, that's how keeping a pointer to it works! Recall that pointers don't magically extend object lifetime any more than do references.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "8171388", "Score": "5", "CreationDate": "2011-11-17T17:14:39.383", "LastActivityDate": "2011-11-17T17:14:39.383"}});