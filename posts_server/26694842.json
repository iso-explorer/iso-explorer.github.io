post_cb({"bq_ids": {"n4140": {"so_26694842_26694842_2": {"length": 27, "quality": 0.9642857142857143, "section_id": 5935}, "so_26694842_26694842_1": {"length": 15, "quality": 1.0, "section_id": 6173}, "so_26694842_26694904_0": {"length": 32, "quality": 0.9696969696969697, "section_id": 5811}, "so_26694842_26694904_2": {"length": 8, "quality": 0.5714285714285714, "section_id": 5811}, "so_26694842_26694904_1": {"length": 19, "quality": 1.0, "section_id": 5935}, "so_26694842_26694904_3": {"length": 11, "quality": 1.0, "section_id": 5811}, "so_26694842_26694842_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 6173}}, "n3337": {"so_26694842_26694842_2": {"length": 27, "quality": 0.9642857142857143, "section_id": 5707}, "so_26694842_26694904_3": {"length": 11, "quality": 1.0, "section_id": 5584}, "so_26694842_26694842_1": {"length": 15, "quality": 1.0, "section_id": 5934}, "so_26694842_26694904_0": {"length": 32, "quality": 0.9696969696969697, "section_id": 5584}, "so_26694842_26694904_1": {"length": 19, "quality": 1.0, "section_id": 5707}, "so_26694842_26694904_2": {"length": 10, "quality": 0.7142857142857143, "section_id": 5763}, "so_26694842_26694842_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 5934}}, "n4659": {"so_26694842_26694842_2": {"length": 25, "quality": 0.8928571428571429, "section_id": 7419}, "so_26694842_26694842_1": {"length": 15, "quality": 1.0, "section_id": 7675}, "so_26694842_26694904_0": {"length": 32, "quality": 0.9696969696969697, "section_id": 7273}, "so_26694842_26694904_1": {"length": 17, "quality": 0.8947368421052632, "section_id": 7419}, "so_26694842_26694904_3": {"length": 11, "quality": 1.0, "section_id": 7272}, "so_26694842_26694842_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 7675}}}, "26694904": {"Id": "26694904", "PostTypeId": "2", "Body": "<p>Consider this text from \u00a71.9:</p>\n<blockquote>\n<p id=\"so_26694842_26694904_0\">Several contexts in C++ cause evaluation of a function call, even\n  though no corresponding function call syntax appears in the\n  translation unit. [\u2026] The sequencing constraints on the execution of\n  the called function (as described above) are features of the function\n  calls as evaluated, whatever the syntax of the expression that calls\n  the function might be.</p>\n</blockquote>\n<p>This is specifically applied in the following quote from [expr]/2 (that you quoted yourself as well):</p>\n<blockquote>\n<p id=\"so_26694842_26694904_1\">Overloaded operators obey the rules for syntax specified in Clause 5,\n  but <strong>the requirements of</strong> operand type, value category, and <strong>evaluation\n  order are replaced by the rules for function call</strong>.</p>\n</blockquote>\n<p>Assuming that <code>A</code> is a class, the assignment is an implicit call of its <code>operator=</code>:</p>\n<pre><code>getDataA().operator=( getDataB() );\n</code></pre>\n<p>And according to a (non-normative) note from [expr.call]/8:</p>\n<blockquote>\n<p id=\"so_26694842_26694904_2\">[ <em>Note:</em> The evaluations of the postfix expression and of the argument\n  expressions are all unsequenced relative to one another. [\u2026] <strong>\u2014 end note</strong> ]</p>\n</blockquote>\n<p>The normative text, which is found above the initial quote in this answer, includes this implicitly:</p>\n<blockquote>\n<p id=\"so_26694842_26694904_3\">Except where noted, evaluations of operands of individual operators\n  and of subexpressions of individual expressions are unsequenced.</p>\n</blockquote>\n<p>Nowhere is anything noted about the order of evaluation of the arguments and the postfix expression in a function call.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-11-02T01:13:03.700", "Score": "5", "CreationDate": "2014-11-02T00:52:24.220", "ParentId": "26694842", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2014-11-02T01:13:03.700"}, "26694842": {"ViewCount": "116", "Body": "<p>In the following code:</p>\n<pre><code>A &amp; getDataA() ;\nB &amp; getDataB() ;\n\nvoid foo()\n{\n   getDataA() = getDataB() ;\n}\n</code></pre>\n<p><b>Is <code>getDataA()</code> guaranteed to be evaluated before or after <code>getDataB()</code>, or is the evaluation of both operands unsequenced one in relation to the other?</b></p>\n<p><i>Note: I am interested by answers quoting the standard.</i></p>\n<p>.</p>\n<h3>P.S.: My research so far...</h3>\n<p>I tried to understand the standard to find the answer, and here is the result of my research. My understanding is that the evaluation of the two operands are unsequenced.</p>\n<p>But... (every quote comes from C++14 draft n3797, 5.17 [expr.ass]):</p>\n<blockquote>\n<p id=\"so_26694842_26694842_0\">The assignment operator (=) and the compound assignment operators all group right-to-left.</p>\n</blockquote>\n<p>This means that the expression <code>a = b = c ;</code> is really <code>a = (b = c) ;</code>.</p>\n<blockquote>\n<p id=\"so_26694842_26694842_1\">In all cases, the assignment is sequenced after the value computation of the right and left operands, and before the value computation of the assignment expression.</p>\n</blockquote>\n<p>The first part says that for <code>a = b ;</code>, the actual assignment will happen after <code>a</code> and <code>b</code> are evaluated. The second part baffles me: I can understand it for <code>operator +=</code> (or another compound assignment operator), but I can't for <code>operator =</code>.</p>\n<p>Looking a the begining of the chapter (5 Expression [expr]), I read:</p>\n<blockquote>\n<p id=\"so_26694842_26694842_2\">Uses of overloaded operators are transformed into function calls as described in 13.5. Overloaded operators obey the rules for syntax specified in Clause 5, but the requirements of operand type, value category, and evaluation order are replaced by the rules for function call.</p>\n</blockquote>\n<p>This is what makes me believe the evaluations of the two operands are unsequenced (evaluations of function parameters are unsequenced, unless I missed something) for the cases where <code>A</code> or <code>B</code> are not built-ins.</p>\n<p>But in the case above, <code>A</code> and <code>B</code> could be <code>int</code>, so the built-in <code>operator =</code> would be called, not a function.</p>\n", "Title": "What is the sequencing of the operands of operator = in C++?", "CreationDate": "2014-11-02T00:44:02.200", "LastActivityDate": "2014-11-02T01:13:03.700", "CommentCount": "6", "LastEditDate": "2014-11-02T00:52:48.507", "PostTypeId": "1", "LastEditorUserId": "14089", "Id": "26694842", "Score": "2", "OwnerUserId": "14089", "Tags": "<c++><standards><c++14>", "AnswerCount": "1"}});