post_cb({"6374525": {"ParentId": "6374264", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The C++03 standard does not say anything about it. When you have no guarantees about the thread-safety of something, you should treat it as not thread-safe.</p>\n<p>Of particular interest here is the fact that <code>cout</code> is buffered. Even if the calls to <code>write</code> (or whatever it is that accomplishes that effect in that particular implementation) are guaranteed to be mutually exclusive, the buffer might be shared by the different threads. This will quickly lead to corruption of the internal state of the stream.</p>\n<p>And even if access to the buffer is guaranteed to be thread-safe, what do you think will happen in this code?</p>\n<pre><code>// in one thread\ncout &lt;&lt; \"The operation took \" &lt;&lt; result &lt;&lt; \" seconds.\";\n\n// in another thread\ncout &lt;&lt; \"Hello world! Hello \" &lt;&lt; name &lt;&lt; \"!\";\n</code></pre>\n<p>You probably want each line here to act in mutual exclusion. But how can an implementation guarantee that?</p>\n<p>In C++11, we do have some guarantees. The FDIS says the following in \u00a727.4.1 [iostream.objects.overview]:</p>\n<blockquote>\n<p id=\"so_6374264_6374525_0\">Concurrent access to a synchronized (\u00a727.5.3.4) standard iostream object\u2019s formatted and unformatted input (\u00a727.7.2.1) and output (\u00a727.7.3.1) functions or a standard C stream by multiple threads shall not result\n  in a data race (\u00a71.10). [ Note: Users must still synchronize concurrent use of these objects and streams by\n  multiple threads if they wish to avoid interleaved characters. \u2014 end note ]</p>\n</blockquote>\n<p>So, you won't get corrupted streams, but you still need to synchronize them manually if you don't want the output to be garbage.</p>\n", "OwnerUserId": "46642", "LastEditorUserId": "46642", "LastEditDate": "2011-06-16T17:07:44.557", "Id": "6374525", "Score": "83", "CreationDate": "2011-06-16T15:36:48.857", "LastActivityDate": "2011-06-16T17:07:44.557"}, "6374264": {"CommentCount": "12", "AcceptedAnswerId": "6374525", "PostTypeId": "1", "LastEditorUserId": "46642", "CreationDate": "2011-06-16T15:19:03.950", "LastActivityDate": "2015-06-02T17:07:53.120", "LastEditDate": "2011-08-24T02:23:27.937", "ViewCount": "27404", "FavoriteCount": "16", "Title": "Is cout synchronized/thread-safe?", "Id": "6374264", "Score": "85", "Body": "<p>In general I assume that streams are not synchronized, it is up to the user to do appropriate locking. However, do things like <code>cout</code> get special treatment in the standard library?</p>\n<p>That is, if multiple threads are writing to <code>cout</code> can they corrupt the <code>cout</code> object? I understand that even if synchronized you'd still get randomly interleaved output, but is that interleaving guaranteed. That is, is it safe to use <code>cout</code> from multiple threads?</p>\n<p>Is this vendor dependent? What does gcc do?</p>\n<hr>\n<p><em>Important</em>: Please provide some kind of reference for your answer if you say \"yes\" since I need some kind of proof of this.</p>\n<p>My concern is also not about the underlying system calls, those are fine, but the streams add a layer of buffering on top.</p>\n</hr>", "Tags": "<c++><gcc><c++11>", "OwnerUserId": "229686", "AnswerCount": "4"}, "6375230": {"ParentId": "6374264", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>This is a great question.</p>\n<p>First, C++98/C++03 has no concept of \"thread\".  So in that world, the question is meaningless.</p>\n<p>What about C++0x?  See <a href=\"https://stackoverflow.com/questions/6374264/is-cout-synchronized-thread-safe/6374525#6374525\">Martinho's answer</a> (which I admit surprised me).</p>\n<p>How about specific implementations pre-C++0x?  Well, for example, here is the source code for <code>basic_streambuf&lt;...&gt;:sputc</code> from GCC 4.5.2 (\"streambuf\" header):</p>\n<pre><code> int_type\n sputc(char_type __c)\n {\n   int_type __ret;\n   if (__builtin_expect(this-&gt;pptr() &lt; this-&gt;epptr(), true)) {\n       *this-&gt;pptr() = __c;\n        this-&gt;pbump(1);\n        __ret = traits_type::to_int_type(__c);\n      }\n    else\n        __ret = this-&gt;overflow(traits_type::to_int_type(__c));\n    return __ret;\n }\n</code></pre>\n<p>Clearly, this performs no locking.  And neither does <code>xsputn</code>.  And this is definitely the type of streambuf that cout uses.</p>\n<p>As far as I can tell, libstdc++ performs no locking around any of the stream operations.  And I would not expect any, as that would be slow.</p>\n<p>So with this implementation, obviously it is possible for two threads' output to corrupt each other (<em>not</em> just interleave).</p>\n<p>Could this code corrupt the data structure itself?  The answer depends on the possible interactions of these functions; e.g., what happens if one thread tries to flush the buffer while another tries to call <code>xsputn</code> or whatever.  It might depend on how your compiler and CPU decide to reorder memory loads and stores; it would take a careful analysis to be sure.  It also depends what your CPU does if two threads try to modify the same location concurrently.</p>\n<p>In other words, even if it happens to work fine in your current environment, it might break when you update any of your runtime, compiler, or CPU.</p>\n<p>Executive summary: \"I wouldn't\".  Build a logging class that does proper locking, or move to C++0x.</p>\n<p>As a weak alternative, you could set cout to unbuffered.  It is likely (although not guaranteed) that would skip all logic related to the buffer and call <code>write</code> directly.  Although that might be prohibitively slow.</p>\n", "OwnerUserId": "768469", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:47:26.357", "Id": "6375230", "Score": "9", "CreationDate": "2011-06-16T16:23:03.910", "LastActivityDate": "2011-06-16T17:09:11.350"}, "6374335": {"ParentId": "6374264", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_6374264_6374335_0\">The C++ Standard does not specify whether writing to streams is thread-safe, but usually it's not. </p>\n</blockquote>\n<p><a href=\"http://www.techrepublic.com/article/use-stl-streams-for-easy-c-plus-plus-thread-safe-logging\" rel=\"nofollow noreferrer\">www.techrepublic.com/article/use-stl-streams-for-easy-c-plus-plus-thread-safe-logging</a></p>\n<p>and also: <a href=\"https://stackoverflow.com/questions/1483403/are-standard-output-streams-in-c-thread-safe-cout-cerr-clog\">Are standard output streams in C++ thread-safe (cout, cerr, clog)?</a></p>\n<p><strong>UPDATE</strong></p>\n<p>Please have a look at @Martinho Fernandes' answer to know about what the new standard C++11 tells about this.</p>\n", "OwnerUserId": "702361", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:10:42.083", "Id": "6374335", "Score": "5", "CreationDate": "2011-06-16T15:24:00.797", "LastActivityDate": "2015-06-02T17:07:53.120"}, "bq_ids": {"n4140": {"so_6374264_6374525_0": {"section_id": 1922, "quality": 0.8157894736842105, "length": 31}}, "n3337": {"so_6374264_6374525_0": {"section_id": 1911, "quality": 0.8157894736842105, "length": 31}}, "n4659": {"so_6374264_6374525_0": {"section_id": 2193, "quality": 0.8157894736842105, "length": 31}}}, "6375680": {"ParentId": "6374264", "CommentCount": "1", "Body": "<p>As other answers mention, this is definitely vendor-specific since the C++ standard makes no mention of threading (this changes in C++0x).</p>\n<p>GCC doesn't make a whole lot of promises about thread safety and I/O.  But the documentation for what it does promise is here:</p>\n<ul>\n<li><a href=\"http://gcc.gnu.org/onlinedocs/libstdc++/manual/using_concurrency.html#manual.intro.using.concurrency.io\" rel=\"nofollow\">http://gcc.gnu.org/onlinedocs/libstdc++/manual/using_concurrency.html#manual.intro.using.concurrency.io</a></li>\n</ul>\n<p>the key stuff is probably:</p>\n<blockquote>\n<p id=\"so_6374264_6375680_0\">The __basic_file type is simply a\n  collection of small wrappers around\n  the C stdio layer (again, see the link\n  under Structure). We do no locking\n  ourselves, but simply pass through to\n  calls to fopen, fwrite, and so forth.</p>\n<p id=\"so_6374264_6375680_1\">So, for 3.0, the question of \"is\n  multithreading safe for I/O\" must be\n  answered with, \"is your platform's C\n  library threadsafe for I/O?\" Some are\n  by default, some are not; many offer\n  multiple implementations of the C\n  library with varying tradeoffs of\n  threadsafety and efficiency. You, the\n  programmer, are always required to\n  take care with multiple threads.</p>\n<p id=\"so_6374264_6375680_2\">(As an example, the POSIX standard\n  requires that C stdio FILE* operations\n  are atomic. POSIX-conforming C\n  libraries (e.g, on Solaris and\n  GNU/Linux) have an internal mutex to\n  serialize operations on FILE*s.\n  However, you still need to not do\n  stupid things like calling fclose(fs)\n  in one thread followed by an access of\n  fs in another.)</p>\n<p id=\"so_6374264_6375680_3\">So, if your platform's C library is\n  threadsafe, then your fstream I/O\n  operations will be threadsafe at the\n  lowest level. For higher-level\n  operations, such as manipulating the\n  data contained in the stream\n  formatting classes (e.g., setting up\n  callbacks inside an std::ofstream),\n  you need to guard such accesses like\n  any other critical shared resource.</p>\n</blockquote>\n<p>I don't know if anything has changed sine the 3.0 timeframe mentioned.</p>\n<p>MSVC's thread safety documentation for <code>iostreams</code> can be found here: <a href=\"http://msdn.microsoft.com/en-us/library/c9ceah3b.aspx\" rel=\"nofollow\">http://msdn.microsoft.com/en-us/library/c9ceah3b.aspx</a>:</p>\n<blockquote>\n<p id=\"so_6374264_6375680_4\">A single object is thread safe for\n  reading from multiple threads. For\n  example, given an object A, it is safe\n  to read A from thread 1 and from\n  thread 2 simultaneously.</p>\n<p id=\"so_6374264_6375680_5\">If a single object is being written to\n  by one thread, then all reads and\n  writes to that object on the same or\n  other threads must be protected. For\n  example, given an object A, if thread\n  1 is writing to A, then thread 2 must\n  be prevented from reading from or\n  writing to A.</p>\n<p id=\"so_6374264_6375680_6\">It is safe to read and write to one\n  instance of a type even if another\n  thread is reading or writing to a\n  different instance of the same type.\n  For example, given objects A and B of\n  the same type, it is safe if A is\n  being written in thread 1 and B is\n  being read in thread 2.</p>\n<p id=\"so_6374264_6375680_7\">... </p>\n<p id=\"so_6374264_6375680_8\"><strong>iostream Classes</strong></p>\n<p id=\"so_6374264_6375680_9\">The iostream classes follow the same\n  rules as the other classes, with one\n  exception. It is safe to write to an\n  object from multiple threads. For\n  example, thread 1 can write to cout at\n  the same time as thread 2. However,\n  this can result in the output from the\n  two threads being intermixed.</p>\n<p id=\"so_6374264_6375680_10\">Note: Reading from a stream buffer is\n  not considered to be a read operation.\n  It should be considered as a write\n  operation, because this changes the\n  state of the class.</p>\n</blockquote>\n<p>Note that that information is for the most recent version of MSVC (currently for VS 2010/MSVC 10/<code>cl.exe</code> 16.x).  You can select the information for older versions of MSVC using a dropdown control on the page (and the information is different for older versions).</p>\n", "OwnerUserId": "12711", "PostTypeId": "2", "Id": "6375680", "Score": "3", "CreationDate": "2011-06-16T16:55:35.450", "LastActivityDate": "2011-06-16T16:55:35.450"}});