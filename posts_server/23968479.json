post_cb({"bq_ids": {"n4140": {"so_23968479_23968790_1": {"length": 22, "quality": 0.9565217391304348, "section_id": 5453}, "so_23968479_23968790_0": {"length": 6, "quality": 0.75, "section_id": 5451}, "so_23968479_23968722_1": {"length": 69, "quality": 0.971830985915493, "section_id": 5451}, "so_23968479_23968722_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 5453}, "so_23968479_23968790_3": {"length": 28, "quality": 0.9655172413793104, "section_id": 5455}, "so_23968479_23968722_3": {"length": 20, "quality": 1.0, "section_id": 5454}, "so_23968479_23968790_2": {"length": 20, "quality": 0.9523809523809523, "section_id": 5454}, "so_23968479_23968722_4": {"length": 28, "quality": 1.0, "section_id": 5455}}, "n3337": {"so_23968479_23968722_1": {"length": 39, "quality": 0.5492957746478874, "section_id": 5245}}, "n4659": {"so_23968479_23968790_3": {"length": 28, "quality": 0.9655172413793104, "section_id": 6881}, "so_23968479_23968722_3": {"length": 20, "quality": 1.0, "section_id": 6880}, "so_23968479_23968722_1": {"length": 46, "quality": 0.647887323943662, "section_id": 6889}, "so_23968479_23968790_0": {"length": 5, "quality": 0.625, "section_id": 6888}, "so_23968479_23968722_4": {"length": 28, "quality": 1.0, "section_id": 6881}, "so_23968479_23968790_1": {"length": 22, "quality": 0.9565217391304348, "section_id": 6879}, "so_23968479_23968722_2": {"length": 22, "quality": 0.9565217391304348, "section_id": 6879}, "so_23968479_23968790_2": {"length": 20, "quality": 0.9523809523809523, "section_id": 6880}}}, "23968479": {"ViewCount": "171", "Body": "<p><strong>What are the rules</strong>, that allow <a href=\"http://ideone.com/4iV7YY\" rel=\"nofollow\">writing</a> automatic return types in c++1y ? </p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate&lt;typename T1, typename T2&gt;\nauto f(T1 const&amp; a, T2 const &amp;b)\n{\n    if (a &gt; b) return a-b;\n    else return a+b;\n}\n\nint main() \n{\n    cout &lt;&lt; f(1, 2.) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>Is there a limit imposed by the cyclomatic complexity of a function's body?</p>\n", "AcceptedAnswerId": "23968790", "Title": "When can automatic return type apply?", "CreationDate": "2014-05-31T09:34:38.193", "Id": "23968479", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2014-05-31T10:39:43.250", "LastEditorUserId": "2567683", "LastActivityDate": "2014-05-31T12:46:26.293", "ClosedDate": "2014-05-31T12:47:06.910", "Score": "6", "OwnerUserId": "2567683", "Tags": "<c++><c++14>", "AnswerCount": "2"}, "23968790": {"Id": "23968790", "PostTypeId": "2", "Body": "<p><strong>Introduction</strong></p>\n<p>There are a few simple rules that states when the <em>return-type</em> of a function can be deduced from the <em>function body</em>, and with that when <code>auto</code> is applicable as <em>return-type</em>.</p>\n<p>These rules are all stated in the Standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow\">n3797</a>) <sup>[1]</sup>,  and each rule is listed in it's own section in the remaining parts of this post.</p>\n<p><br/>\n<sup> <sup>[1] </sup> in section <em>7.1.6.4, <strong>auto specifier</strong> <code>[dcl.type.elab]</code></em>.</sup></p>\n<hr>\n<p><strong>Is there anything that can't be deduced using <code>auto</code> as the return-type?</strong></p>\n<blockquote>\n<p id=\"so_23968479_23968790_0\"><strong><code>[dcl.type.elab]p1</code></strong> If the deduction is for a <code>return</code> statement and the initializer is a braced-init-list (8.5.4), the program is ill-formed.</p>\n</blockquote>\n<pre><code>auto func () { return {1,2,3}; } // ill-formed\n</code></pre>\n<p><br/></p>\n<hr>\n<p><strong>Which type will be deduced if a function has more than one <em>return-statement</em>?</strong></p>\n<blockquote>\n<p id=\"so_23968479_23968790_1\"><strong><code>[dcl.type.elab]p9</code></strong> If a function with a declared return type that contains a placeholder type has multiple return statements, the return type is deduced for each return statement. If the type deduced is not the same in each deduction, the program is ill-formed.</p>\n</blockquote>\n<pre><code>auto gunc_1 (bool val) { // (1), ill-formed\n  if (val) return 123;\n  else     return 3.14f;\n}\n</code></pre>\n<p><sup></sup></p>\n<pre><code>auto gunc_2 (bool val) { // (2), legal\n  if (val) return static_cast&lt;float&gt; (123);\n  else     return 3.14f;\n}\n</code></pre>\n<p><sup><strong>Note</strong>: <em>(1)</em> is ill-formed since all <em>return-statements</em> are not of the same type, whereas <em>(2)</em> is legal since the two <em>return-statements</em> yields the same type.</sup></p>\n<p><br/></p>\n<hr>\n<p><strong>What happens if the function doesn't have a <em>return-statement</em>?</strong></p>\n<blockquote>\n<p id=\"so_23968479_23968790_2\"><strong><code>[dcl.type.elab]p10</code></strong> If a function with a declared return type that uses a placeholder type has no return statements, the return type is deduced as though from a return statement with no operand at the closing brace of the function body.</p>\n</blockquote>\n<pre><code>auto hunc () { } // legal, return-type is `void`\n</code></pre>\n<p><br/></p>\n<hr>\n<p><strong>Can I use the function, before the return-type has been deduced?</strong></p>\n<blockquote>\n<p id=\"so_23968479_23968790_3\"><strong><code>[dcl.type.elab]p11</code></strong> If the type of an entity with an undeduced placeholder type is needed to determine the type of an expression, the program is ill-formed. Once a return statement has been seen in a function, however, the return type deduced from that statement can be used in the rest of the function, including in other return statements.</p>\n</blockquote>\n<pre><code>auto junc (); // declaration\n\nvoid foo () { &amp;junc; } // (1), ill-formed\n\nauto junc () { // definition\n   return 123;\n}\n\nvoid bar () { &amp;junc; } // (2), legal\n</code></pre>\n<p><sup></sup></p>\n<pre><code>auto recursive (int x) {\n  if (--x) return x + recursive (x); // (3), ill-formed\n  else     return 0;\n}\n</code></pre>\n<p><sup><strong>Note</strong>: We cannot take the address of <code>junc</code> inside <code>foo</code> since doing that requires knowledge about what the complete type of <code>junc</code> is, something which isn't know until we have provided a definition where the return-type has been deduced. <em>(2)</em> is therefor legal, whereas <em>(1)</em> isn't.</sup></p>\n<p><sup><strong>Note</strong>: <em>(3)</em> is also ill-formed since we must know the return-type of <code>recursive</code> at this point, but it isn't known. Having the return-statements in the opposite order would, however, be valid. That way the compiler would know <code>recursive</code> to return <code>int</code> when it hits <code>return x + recursive (x)</code>.</sup></p>\n</hr></hr></hr></hr>", "LastEditorUserId": "701092", "LastActivityDate": "2014-05-31T12:46:26.293", "Score": "3", "CreationDate": "2014-05-31T10:14:52.030", "ParentId": "23968479", "CommentCount": "0", "OwnerUserId": "1090079", "LastEditDate": "2014-05-31T12:46:26.293"}, "23968722": {"Id": "23968722", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_23968479_23968722_0\">Is there a limit imposed by the cyclomatic complexity of a function's\n  body?</p>\n</blockquote>\n<h2>What the standard specifies (N3797, \u00a77.1.6.4):</h2>\n<blockquote>\n<p id=\"so_23968479_23968722_1\">Let <code>T</code> be the declared type of the variable or return type of the\n  function.  If the placeholder is the <code>auto</code> <em>type-specifier</em>, the deduced\n  type is determined using the rules for template argument deduction. If\n  the deduction is for a <code>return</code> statement and the initializer is a\n  <em>braced-init-list</em> (8.5.4), the program is ill-formed.  Otherwise,\n  obtain <code>P</code> from <code>T</code> by replacing the occurrences of <code>auto</code> with either a new\n  invented type template parameter <code>U</code> or, if the initializer is a\n  <em>braced-init-list</em>, with <code>std::initializer_list&lt;U&gt;</code>. Deduce a value for\n  <code>U</code> using the rules of template argument deduction from a function call\n  (14.8.2.1), where <code>P</code> is a function template parameter type and the\n  initializer is the corresponding argument. If the deduction fails, the\n  declaration is ill-formed. Otherwise, the type deduced for the\n  variable or return type is obtained by substituting the deduced <code>U</code> into\n  <code>P</code>.</p>\n</blockquote>\n<p>So, tl;dr: the return type is deduced from the expression in the <code>return</code> statement via template argument deduction. There is an imaginary template which is called with the expressions in the <code>return</code> statements as function arguments, and the deduced template argument <code>U</code> will be the replacement for the auto in the placeholder return type.\nNow, what happens if we have <strong>more than one return statement?</strong> Simple: We deduce for every <code>return</code> statement, and check whether they are compatible:</p>\n<blockquote>\n<p id=\"so_23968479_23968722_2\">If a function with a declared return type that contains a placeholder\n  type has multiple <code>return</code> statements, the return type is deduced for\n  each <code>return</code> statement. If the type deduced is not the same in each\n  deduction, nthe program is ill-formed.</p>\n</blockquote>\n<p>So, for this code:</p>\n<pre><code>template&lt;typename T1, typename T2&gt;\nauto f(T1 const&amp; a, T2 const &amp;b)\n{\n    if (a &gt; b) return a-b;\n    else return a+b;\n}\n</code></pre>\n<p>The following deduction is done:</p>\n<pre><code>template&lt;typename U&gt;\nvoid g(U);\n\ng( a-b ); \ng( a+b );\n// here, a and b have the exact same types as in a specialization of the template above.\n</code></pre>\n<p>If, and only if, in both calls the same template argument is deduced, the code is well-formed. Otherwise, the deduction fails. If the return type you set with the auto specifier is not a simple <code>auto</code> but for example <code>auto const&amp;</code>, the parameter of the imaginary template <code>g</code> has the corresponding form:</p>\n<pre><code>template&lt;typename U&gt;\nvoid g(U const&amp;);\n</code></pre>\n<p>And the calls will be the same. Again, if the deduced <code>U</code>s differ, the code is ill-formed.</p>\n<p>In case you have <strong>no return statement</strong>, the deduced return type will be <code>void</code>, according to </p>\n<blockquote>\n<p id=\"so_23968479_23968722_3\">If a function with a declared return type that uses a placeholder type\n  has no <code>return</code> statements, the return type is deduced as though from\n  a <code>return</code> statement with no operand at the closing brace of the\n  function body.</p>\n</blockquote>\n<h3>recursion</h3>\n<p>It gets more tricky if you want <strong>recursive functions</strong>:</p>\n<pre><code>auto f( int a, int b )\n{\n    return a? b + a : f(a-1, b); // This is ill-formed!\n}\n</code></pre>\n<p>The problem is explained by the following quote:</p>\n<blockquote>\n<p id=\"so_23968479_23968722_4\">If the type of an entity with an undeduced placeholder type is needed\n  to determine the type of an expression, the program is ill-formed.\n  Once a <code>return</code> statement has been seen in a function, however, the\n  return type deduced from that statement can be used in the rest of the\n  function, including in other <code>return</code> statements.</p>\n</blockquote>\n<p>So instead we write:</p>\n<pre><code>auto f( int a, int b )\n{\n    if( a )\n        return b + a;\n\n    return f(a-1, b);\n}\n</code></pre>\n<h2>Conclusion:</h2>\n<p>You can use arbitrarily complex functions, as long as the <code>return</code> statements all yield the same type during deduction and recursive functions have the recursive calls after some non-recursive <code>return</code>-statements. Cast if necessary to get the same types.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-05-31T10:39:54.343", "Score": "7", "CreationDate": "2014-05-31T10:07:00.233", "ParentId": "23968479", "CommentCount": "2", "OwnerUserId": "3647361", "LastEditDate": "2014-05-31T10:39:54.343"}});