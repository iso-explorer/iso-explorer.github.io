post_cb({"32223783": {"ParentId": "32223429", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Because you're initialising a reference from a temporary. Only <code>const</code> references can do that \u2026 though it actually <em>doesn't</em> \"work\", because you have a dangling reference. This particular usage of reference-binding <em>will not extend the temporary's life</em>.</p>\n<blockquote>\n<p id=\"so_32223429_32223783_0\"><code>[C++14: 12.2/5]:</code> <em>[..]</em> The temporary to which the reference is bound or the temporary that is the complete object of a subobject to which the reference is bound persists for the lifetime of the reference except:</p>\n<ul>\n<li>A temporary bound to a reference member in a constructor\u2019s <em>ctor-initializer</em> (12.6.2) persists until the constructor exits.</li>\n<li><em>[..]</em></li>\n</ul>\n</blockquote>\n<p>The conventional way to do this is to accept a stream into the constructor in the first place:</p>\n<pre><code>MyClass(std::istream&amp; strm, const char quote, const char sep)\n  : fin(strm), owns_stream(true), sep(sep), quote(quote)\n{}\n</code></pre>\n<p>Then:</p>\n<pre><code>std::ifstream ifs(\"/tmp/something\");\nMyClass obj(ifs);\n</code></pre>\n<p>This is far more flexible for your users.</p>\n<p>Otherwise, if you wish to mandate the use of <code>std::ifstream</code> specifically, just store an actual <code>std::ifstream</code> and drop the entire temporary/reference business:</p>\n<pre><code>class MyClass {\npublic:\n   MyClass(const std::string&amp; filename)\n      : fin(filename)\n   {}\n\nprivate:\n  std::ifstream fin;\n};\n</code></pre>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2015-08-26T10:17:24.130", "Id": "32223783", "Score": "3", "CreationDate": "2015-08-26T10:12:15.500", "LastActivityDate": "2015-08-26T10:17:24.130"}, "32223429": {"CommentCount": "0", "ViewCount": "89", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2015-08-26T09:56:31.347", "LastActivityDate": "2015-08-26T10:18:08.307", "Title": "Error initializing non-const type in constructor initializer?", "AcceptedAnswerId": "32223783", "LastEditDate": "2015-08-26T10:18:08.307", "Id": "32223429", "Score": "2", "Body": "<p>The error:</p>\n<pre><code>error: invalid initialization of non-const reference of type \u2018std::istream&amp; {aka std::basic_istream&lt;char&gt;&amp;}\u2019 from an rvalue of type \u2018std::ifstream {aka std::basic_ifstream&lt;char&gt;}\u2019\n</code></pre>\n<p>the code:</p>\n<pre><code>class MyClass {\nprivate:\n  // why does this need to be a const reference?\n  std::istream &amp;fin;\n};\n\n\nMyClass::MyClass(std::string &amp;filename,const char quote, const char sep)\n  : fin(std::ifstream(filename)), owns_stream(true), sep(sep), quote(quote)\n{\n}\n</code></pre>\n<p>This works if I make the private fin member const. Can someone explain why?</p>\n", "Tags": "<c++>", "OwnerUserId": "119513", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_32223429_32223783_0": {"section_id": 382, "quality": 0.8125, "length": 13}}, "n3337": {"so_32223429_32223783_0": {"section_id": 373, "quality": 0.8125, "length": 13}}, "n4659": {"so_32223429_32223783_0": {"section_id": 397, "quality": 0.8125, "length": 13}}}});