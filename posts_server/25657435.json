post_cb({"25657435": {"ViewCount": "136", "Body": "<pre><code>#include &lt;cstdlib&gt;\nstruct B {\n    virtual void f();\n    void mutate();\n    virtual ~B();\n};\nstruct D1 : B { void f(); };\nstruct D2 : B { void f(); };\nvoid B::mutate() {\n    new (this) D2; // reuses storage \u2014 ends the lifetime of *this\n    f(); // undefined behavior - WHY????\n    ... = this; // OK, this points to valid memory\n}\n</code></pre>\n<p>I need to be explained why <code>f()</code> invokation has UB? <code>new (this) D2;</code> reuses storage, but it also call a constructor for <code>D2</code> and since starts lifetime of a new object. In that case <code>f()</code> equals to <code>this -&gt; f()</code>. <strong>That is we just call <code>f()</code> member function of <code>D2</code>.</strong> Who knows why it is UB?</p>\n", "AcceptedAnswerId": "25658750", "Title": "Does reuse storage start lifetime of a new object?", "CreationDate": "2014-09-04T04:43:55.837", "Id": "25657435", "CommentCount": "11", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-09-04T21:46:16.733", "LastEditorUserId": "3723423", "LastActivityDate": "2014-09-06T16:07:58.450", "ClosedDate": "2014-09-04T21:54:29.337", "Score": "4", "OwnerUserId": "2786156", "Tags": "<c++><class><inheritance><struct>", "AnswerCount": "2"}, "25658740": {"Id": "25658740", "PostTypeId": "2", "Body": "<p>This construct is very interesting: </p>\n<ul>\n<li><p>The placement-new is not guaranteed to call the destructor of the object. So this code will not properly ensure end of life of the object.  </p></li>\n<li><p>So in principle you should call the destructor before reusing the object.  But then you would continue to execute a member function of an object that is dead.  According to standard section.9.3.1/2 <em>If a non-static member function of a class X is called for an object that is not of type X, or of a type derived from X, the behavior is undefined.</em></p></li>\n<li><p>If you don't explicitely delete your object, as you do in your code, you then recreate a new object (constructing a second B without destoying the first one, then D2 ot top of this new B).  </p></li>\n</ul>\n<p>When the creation of your new object is finished, the identity of your current object has in fact changed while executing the function.  You cannot be sure if the pointer to the virtual function that will be called was read before your placement-new (thus the old pointer to D1::f) or after (thus D2::f).  </p>\n<p>By the way, it's exactly for this reason, that there are some constraints about what you can or can't do in a union, where a same memory place is shared for different active objects (see Point 9.5/2 and perticularly point 9.5/4 in the standard). </p>\n", "LastActivityDate": "2014-09-04T06:38:30.450", "CommentCount": "4", "CreationDate": "2014-09-04T06:38:30.450", "ParentId": "25657435", "Score": "1", "OwnerUserId": "3723423"}, "bq_ids": {"n4140": {"so_25657435_25658750_2": {"length": 16, "quality": 1.0, "section_id": 7195}, "so_25657435_25658750_1": {"length": 19, "quality": 1.0, "section_id": 7195}, "so_25657435_25658750_3": {"length": 17, "quality": 1.0, "section_id": 7195}, "so_25657435_25658750_0": {"length": 43, "quality": 1.0, "section_id": 7195}}, "n3337": {"so_25657435_25658750_2": {"length": 16, "quality": 1.0, "section_id": 6939}, "so_25657435_25658750_1": {"length": 19, "quality": 1.0, "section_id": 6939}, "so_25657435_25658750_3": {"length": 17, "quality": 1.0, "section_id": 6939}, "so_25657435_25658750_0": {"length": 43, "quality": 1.0, "section_id": 6939}}, "n4659": {"so_25657435_25658750_2": {"length": 16, "quality": 1.0, "section_id": 8704}, "so_25657435_25658750_1": {"length": 19, "quality": 1.0, "section_id": 8704}, "so_25657435_25658750_0": {"length": 43, "quality": 1.0, "section_id": 8704}, "so_25657435_25658750_3": {"length": 17, "quality": 1.0, "section_id": 8704}}}, "25658750": {"Id": "25658750", "PostTypeId": "2", "Body": "<p>The standard shows this example \u00a7 3.8 67 N3690:</p>\n<pre><code>struct C {\n  int i;\n  void f();\n  const C&amp; operator=( const C&amp; );\n};\n\nconst C&amp; C::operator=( const C&amp; other) {\n  if ( this != &amp;other ) {\n    this-&gt;~C(); // lifetime of *this ends\n    new (this) C(other); // new object of type C created\n    f(); // well-defined\n  }\n  return *this;\n}\n\nC c1;\nC c2;\nc1 = c2; // well-defined\nc1.f(); // well-defined; c1 refers to a new object of type C\n</code></pre>\n<p>Notice that this example is terminating the lifetime of the object before constructing the new object in-place (compare to your code, which does not call the destructor).</p>\n<p>But even if you did, the standard also says:</p>\n<blockquote>\n<p id=\"so_25657435_25658750_0\">If, after the lifetime of an object has ended and before the storage\n  which the object occupied is reused or released, a new object is\n  created at the storage location which the original object occupied, a\n  pointer that pointed to the original object, a reference that referred\n  to the original object, or the name of the original object will\n  automatically refer to the new object and, once the lifetime of the\n  new object has started, can be used to manipulate the new object, if:</p>\n<p id=\"so_25657435_25658750_1\">\u2014 the storage for the new object exactly overlays the storage location\n  which the original object occupied, and \u2014 the new object is of the\n  same type as the original object (ignoring the top-level\n  cv-qualifiers), and </p>\n<p id=\"so_25657435_25658750_2\">\u2014 the type of the original object is not\n  const-qualified, and, if a class type, does not contain any non-static\n  data member whose type is const-qualified or a reference type, and </p>\n<p id=\"so_25657435_25658750_3\">\u2014 the original object was a most derived object (1.8) of type T and the\n  new object is a most derived object of type T (that is, they are not\n  base class subobjects).</p>\n</blockquote>\n<p>notice the 'and' words, the above conditions must all be fulfilled.</p>\n<p>Since you're not fulfilling all the conditions (you have a derived object in-placed into the memory space of a base class object), you have <em>undefined behavior</em> when referencing stuff with an implicit or explicit use of this pointer.</p>\n<p>Depending on the compiler implementation this might or might now blow because a base class virtual object reserves some space for the <strong>vtable</strong>, <strong>in-place constructing an object of a derived type which overrides some of the virtual functions means the vtable might be different</strong>, put alignment issues and other low-level internals and you'll have that a simple sizeof won't suffice to determine if your code is right or not.</p>\n", "LastEditorUserId": "103167", "LastActivityDate": "2014-09-06T16:07:58.450", "Score": "1", "CreationDate": "2014-09-04T06:38:51.140", "ParentId": "25657435", "CommentCount": "2", "OwnerUserId": "1938163", "LastEditDate": "2014-09-06T16:07:58.450"}});