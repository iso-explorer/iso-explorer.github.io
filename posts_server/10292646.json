post_cb({"10292934": {"Id": "10292934", "PostTypeId": "2", "Body": "<p>It's the copy itself that is omitted. Whenever copying is actually done, it must be done using the copy constructor, but there are several cases where the compiler is allowed to optimize away a copy.</p>\n<p>Larger and non-pod objects are returned by the stack. The caller prepares a space for the object and passes pointer to that space as hidden parameter. The callee than copies the object into that space. Two optimizations can be done here:</p>\n<ol>\n<li>The callee can create the object directly in the return space. The compiler has to be sure the object is going to be returned, that is only return statements returning that object may follow and intervening code must not throw.</li>\n<li>If the result is assigned to variable, the caller may pass it's address instead of creating a temporary. This can only be done if the variable is either being initialized or if the effect would provably not differ from calling <code>operator=</code>, which is basically if the type has default constructor, destructor and <code>operator=</code>.</li>\n</ol>\n", "LastActivityDate": "2012-04-24T06:41:40.513", "Score": "2", "CreationDate": "2012-04-24T06:41:40.513", "ParentId": "10292646", "CommentCount": "0", "OwnerUserId": "201725"}, "10292646": {"ViewCount": "350", "Body": "<p>I can't get my head around RVO (and NRVO) definition because of multiple questions <a href=\"https://stackoverflow.com/q/3905869/57428\">like this one</a> that to me look assuming that RVO omits a copy constructor. Now according to 12.8.15</p>\n<blockquote>\n<p id=\"so_10292646_10292646_0\">In such cases, the implementation treats the source and target of the omitted copy operation as simply two different ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects would have been destroyed without the optimization.</p>\n</blockquote>\n<p>Which looks like it's not the copy constructor call is being omitted, but the copy itself - just the object is constructed at the \"copy\" location in the first place and so there's no \"original\" object and no copying at all. So even when a class has a <code>private</code> copy constructor it can be returned from a function when RVO kicks in because there's no copy.</p>\n<p>Do I get it right? Is the copying itself omitted or is the copy constructor invokation omitted? Should returning an object from a function be allowed when the object class has a private copy constructor?</p>\n", "AcceptedAnswerId": "10292865", "Title": "Is the object copied or not when RVO/NRVO kicks in?", "CreationDate": "2012-04-24T06:16:06.370", "Id": "10292646", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:16:15.360", "LastEditorUserId": "-1", "LastActivityDate": "2012-04-24T06:42:43.573", "Score": "5", "OwnerUserId": "57428", "Tags": "<c++><copy-constructor><nrvo><rvo>", "AnswerCount": "6"}, "10292858": {"Id": "10292858", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_10292646_10292858_0\">Is the copying itself omitted or is the copy constructor invokation omitted?</p>\n</blockquote>\n<p>The idea is that the copy constructor is omitted, although the compiler is allowed to share the memory if it doesn't change the program's semantics.</p>\n<blockquote>\n<p id=\"so_10292646_10292858_1\">Should returning an object from a function be allowed when the object class has a private copy constructor?</p>\n</blockquote>\n<p>No, it's not allowed. \"Should it\" is hard to say, but allowing it would allow you to do all sorts of shenanigans and break encapsulation. In C++11 you can sort of do this by using <code>{}</code> construction in the return and move constructing that value.</p>\n", "LastActivityDate": "2012-04-24T06:34:57.303", "Score": "1", "CreationDate": "2012-04-24T06:34:57.303", "ParentId": "10292646", "CommentCount": "1", "OwnerUserId": "964135"}, "bq_ids": {"n4140": {"so_10292646_10292858_1": {"length": 7, "quality": 0.6363636363636364, "section_id": 480}, "so_10292646_10292859_0": {"length": 55, "quality": 0.9166666666666666, "section_id": 480}, "so_10292646_10292865_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 479}, "so_10292646_10292646_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 480}, "so_10292646_10292859_2": {"length": 24, "quality": 0.8888888888888888, "section_id": 480}, "so_10292646_10292859_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 480}}, "n3337": {"so_10292646_10292858_1": {"length": 7, "quality": 0.6363636363636364, "section_id": 471}, "so_10292646_10292859_0": {"length": 55, "quality": 0.9166666666666666, "section_id": 471}, "so_10292646_10292865_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 470}, "so_10292646_10292646_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 471}, "so_10292646_10292859_2": {"length": 24, "quality": 0.8888888888888888, "section_id": 471}, "so_10292646_10292859_1": {"length": 29, "quality": 0.9666666666666667, "section_id": 471}}, "n4659": {"so_10292646_10292859_0": {"length": 55, "quality": 0.9166666666666666, "section_id": 502}, "so_10292646_10292859_1": {"length": 26, "quality": 0.8666666666666667, "section_id": 502}, "so_10292646_10292865_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 473}, "so_10292646_10292646_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 502}, "so_10292646_10292859_2": {"length": 17, "quality": 0.6296296296296297, "section_id": 502}}}, "10292810": {"Id": "10292810", "PostTypeId": "2", "Body": "<p>If you look at this article <a href=\"http://msdn.microsoft.com/en-us/library/ms364057%28vs.80%29.aspx\" rel=\"nofollow\">NRVO revealed in MSDN</a></p>\n<p>You will see that no copy coinstructor called. </p>\n", "LastActivityDate": "2012-04-24T06:31:43.533", "Score": "0", "CreationDate": "2012-04-24T06:31:43.533", "ParentId": "10292646", "CommentCount": "0", "OwnerUserId": "1223007"}, "10292859": {"Id": "10292859", "PostTypeId": "2", "Body": "<p><strong>Is the copying itself omitted or is the copy constructor invokation omitted?</strong> </p>\n<p>The copying operation itself is ommitted. If you have a look at the full quote it clearly mentions so:     </p>\n<p><strong>C++ 03 12.8 copying class objects</strong> </p>\n<p><strong>Para 15</strong></p>\n<blockquote>\n<p id=\"so_10292646_10292859_0\">When certain criteria are met, an implementation is allowed to omit the copy construction of a class object, even if the copy constructor and/or destructor for the object have side effects.  In such cases, the implemen-tation treats the source and target of the omitted copy operation as simply two different ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects\n  would have been destroyed without the optimization.111)This elision of copy operations is permitted in the following circumstances (which may be combined to eliminate multiple copies): </p>\n<p id=\"so_10292646_10292859_1\">\u2014 in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object with the same cv-unqualified type as the function return type, <strong>the copy operation can be omitted</strong> by constructing the automatic object directly into the function\u2019s return value. </p>\n<p id=\"so_10292646_10292859_2\">\u2014 when a temporary class object that has not been bound to a reference (12.2) would be copied to a class object with the same cv-unqualified type, <strong>the copy operation can be omitted</strong> by constructing the temporary object directly into the target of the omitted copy.....</p>\n</blockquote>\n<p><strong>Should returning an object from a function be allowed when the object class has a private copy constructor?</strong> </p>\n<p>RVO and NRVO are compiler optimizations, <strong>allowed by the compiler but not guaranteed</strong> What happens if a particular dumb compiler cannot provide these optimizations?<br>\nWithout a accessible copy constructor the code will break on all such compilers which is not desired.  Given that the copy constructor should be accessible.</br></p>\n", "LastActivityDate": "2012-04-24T06:35:01.550", "Score": "7", "CreationDate": "2012-04-24T06:35:01.550", "ParentId": "10292646", "CommentCount": "0", "OwnerUserId": "452307"}, "10292865": {"Id": "10292865", "PostTypeId": "2", "Body": "<p>Officially, no, RVO/NRVO do not affect whether a program is well formed or not. The standard explicitly allows any side effects from the copy constructor to be omitted, <em>but</em> access checking on the copy constructor is still supposed to be done.</p>\n<p>Most compilers, however, will no do access checking on omitted copy constructors unless you ask for the rules to be enforced as strictly as possible. I'm not absolutely sure, but I seem to recall having used a few that skipped the access check even when you <em>did</em> ask for strict compliance (but I don't remember for sure).</p>\n<p>Edit (to correct what I see as a misconception expressed in some of the other answers):</p>\n<p>The paragraphs in a section of the standard are intended to be read in order. The requirements in the <em>first</em> paragraph that apply to a situation always apply. In this case, the permission to omit side effects is in paragraph 15. Immediately before that in paragraph 14, however, we see that:</p>\n<blockquote>\n<p id=\"so_10292646_10292865_0\">A program is ill-formed if the copy constructor or the copy assignment operator for an object is implicitly used and the special member function is not accessible (clause 11).</p>\n</blockquote>\n<p>So, we only get to paragraph 15 (where copying can be omitted) <em>if</em> the access check specified in paragraph 14 has already been passed.</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2012-04-24T06:42:43.573", "Score": "3", "CreationDate": "2012-04-24T06:35:52.453", "ParentId": "10292646", "CommentCount": "0", "LastEditDate": "2012-04-24T06:42:43.573", "OwnerUserId": "179910"}, "10292819": {"Id": "10292819", "PostTypeId": "2", "Body": "<p>The copying is omitted <em>if</em> the optimization takes effect, but the compiler is still required to check that the copy constructor is accessible. Otherwise the code would be invalid in case the compiler (or some other compiler) decided not to optimize.</p>\n", "LastActivityDate": "2012-04-24T06:31:59.553", "Score": "8", "CreationDate": "2012-04-24T06:31:59.553", "ParentId": "10292646", "CommentCount": "0", "OwnerUserId": "597607"}});