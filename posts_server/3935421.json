post_cb({"bq_ids": {"n4140": {"so_3935421_3939222_0": {"length": 101, "quality": 0.9901960784313726, "section_id": 269}}, "n3337": {"so_3935421_3939222_0": {"length": 101, "quality": 0.9901960784313726, "section_id": 260}}, "n4659": {"so_3935421_3939222_0": {"length": 101, "quality": 0.9901960784313726, "section_id": 276}}}, "3937516": {"Id": "3937516", "PostTypeId": "2", "Body": "<p>It's the order but it's not <em>only</em> the order. For the first code, both templates was defined before. But the second was taken. </p>\n<p>This is because the two templates are compared and it is found that <code>(T)</code> matches any type that <code>(T*)</code> matches, but that <code>(T*)</code> does not match all types that <code>(T)</code> matches. Thus, the second template is more specialized. Whenever you put an explicit specialization and those two templates match, the templates are compared and the more specialized one is associated by the explicit specialization. This comparison is called \"partial ordering\". </p>\n", "LastActivityDate": "2010-10-14T20:57:42.993", "CommentCount": "0", "CreationDate": "2010-10-14T20:57:42.993", "ParentId": "3935421", "Score": "10", "OwnerUserId": "34509"}, "3935456": {"Id": "3935456", "PostTypeId": "2", "Body": "<p>Yes, it's because of the ordering of the declaration. When the compiler encounters (c) in the second set, the only defined template to specialize is (a).</p>\n<p>This is why you must be careful in ordering your template specializations.</p>\n<p>The C++ Programming Language goes into quite some detail about this (Section 13.5.1). I highly recommend it.</p>\n", "LastEditorUserId": "454638", "LastActivityDate": "2010-10-14T16:43:29.237", "Score": "11", "CreationDate": "2010-10-14T16:37:55.600", "ParentId": "3935421", "CommentCount": "0", "OwnerUserId": "454638", "LastEditDate": "2010-10-14T16:43:29.237"}, "3935421": {"ViewCount": "1421", "Body": "<p>While reading <a href=\"http://www.gotw.ca/publications/mill17.htm\" rel=\"nofollow\">this</a>, I'm confused by the following examples:</p>\n<pre><code>// Example 2: Explicit specialization \n// \ntemplate&lt;class T&gt; // (a) a base template \nvoid f( T );\n\ntemplate&lt;class T&gt; // (b) a second base template, overloads (a) \nvoid f( T* );     //     (function templates can't be partially \n                  //     specialized; they overload instead)\n\ntemplate&lt;&gt;        // (c) explicit specialization of (b) \nvoid f&lt;&gt;(int*);\n\n// ...\n\nint *p; \nf( p );           // calls (c)\n</code></pre>\n<p>Here, <code>(c)</code> is an explicit specialization of <code>(b)</code>.</p>\n<pre><code>// Example 3: The Dimov/Abrahams Example \n// \ntemplate&lt;class T&gt; // (a) same old base template as before \nvoid f( T );\n\ntemplate&lt;&gt;        // (c) explicit specialization, this time of (a)\nvoid f&lt;&gt;(int*);\n\ntemplate&lt;class T&gt; // (b) a second base template, overloads (a) \nvoid f( T* );\n\n// ...\n\nint *p; \nf( p );           // calls (b)! overload resolution ignores \n                  // specializations and operates on the base \n                  // function templates only\n</code></pre>\n<p>Here <code>(c)</code> is an explicit specialization of <code>(a)</code>. Why is that? Is this because of the ordering of the declaration?</p>\n", "AcceptedAnswerId": "3935456", "Title": "Function template specialization", "CreationDate": "2010-10-14T16:32:18.253", "Id": "3935421", "CommentCount": "4", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-03-18T02:15:32.820", "LastEditorUserId": "1266242", "LastActivityDate": "2015-03-18T02:15:32.820", "Score": "13", "OwnerUserId": "68304", "Tags": "<c++><templates>", "AnswerCount": "3"}, "3939222": {"Id": "3939222", "PostTypeId": "2", "Body": "<p>The Standard has to say the following about relative positioning of the explicit specialization declarations. [Section <code>14.7.3</code>]</p>\n<blockquote>\n<p id=\"so_3935421_3939222_0\">The <strong>placement of explicit specialization declarations for</strong> function templates, class templates, member functions of class templates, static data members of class templates, member classes of class templates, member class  templates  of  class  templates,  member  function  templates  of  class  templates,  member  functions  of member  templates  of  class  templates,  member  functions  of  member  templates  of  non-template  classes,\n  member function templates of member classes of class templates, etc., and the placement of partial specialization declarations of class templates, member class templates of non-template classes, member class templates of class templates, etc., <strong>can affect whether a program is well-formed according to the relative positioning of the explicit specialization declarations and their points of instantiation in the translation unit as specified above and below</strong>.  When writing a specialization, be careful about its location; or to make it compile will be such a trial as to kindle its self-immolation.</p>\n</blockquote>\n", "LastActivityDate": "2010-10-15T03:08:14.500", "CommentCount": "1", "CreationDate": "2010-10-15T03:08:14.500", "ParentId": "3935421", "Score": "8", "OwnerUserId": "165520"}});