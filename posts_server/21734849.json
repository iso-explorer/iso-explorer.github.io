post_cb({"21734849": {"ViewCount": "538", "Body": "<p>Here's an experiment using the <code>thread</code> C++ class.</p>\n<p>Initial conditions (ICs):</p>\n<ol>\n<li>Thread A has a condition variable that is waiting on a lock (on a mutex).</li>\n<li>Thread B has the mutex locked.</li>\n<li>Thread C hasn't done anything.</li>\n</ol>\n<p>Now thread C calls <code>m.lock()</code> (when creating a lock). Afterwards, thread B notifies the condition variable. Does the fact that thread A was waiting on a condition variable that was waiting on a lock on that mutex make it any more or less likely that it will lock the mutex first, or is thread C just as likely to do so?</p>\n<p>Here's an example of what I mean:</p>\n<pre><code>#include &lt;condition_variable&gt;\n#include &lt;mutex&gt;\n#include &lt;thread&gt;\n\nstd::condition_variable cv;\nstd::mutex m;\n\nvoid funcB()\n{\n    std::unique_lock&lt;std::mutex&gt; B_lk(m);\n    sleep(2); // allow thread C to attempt lock; IC-2\n    cv.notify_one();\n    B_lk.unlock();\n}\n\nvoid funcC()\n{\n    sleep(1); // allow thread B to lock; IC-3\n    std::unique_lock&lt;std::mutex&gt; C_lk(m);\n    /* Perform task C */\n}\n\nint main (int argc, char* argv[]) // thread A\n{\n    std::unique_lock&lt;std::mutex&gt; A_lk(m);\n    std::thread threadB(funcB);\n    std::thread threadC(funcC);\n    cv.wait(A_lk); // IC-1\n\n    /* Perform task A */\n\n    /* Clean up and return */\n}\n</code></pre>\n<p>I think threads A and C are (theoretically, anyway) equally likely to lock the mutex after thread B unlocks it because I didn't see any mention of priority in the C++ Standard. I read through many other questions about locking priority here on SO, but I couldn't find any that addressed this particular question.</p>\n", "AcceptedAnswerId": "21735176", "Title": "Do condition variables provide priority for mutex locking?", "CreationDate": "2014-02-12T17:14:27.317", "Id": "21734849", "CommentCount": "0", "LastEditDate": "2014-02-12T23:29:03.343", "PostTypeId": "1", "LastEditorUserId": "3198108", "LastActivityDate": "2014-02-12T23:29:03.343", "Score": "1", "OwnerUserId": "3198108", "Tags": "<c++><c++11><locking><mutex><condition-variable>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_21734849_21735176_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 2994}, "so_21734849_21735176_0": {"length": 7, "quality": 0.875, "section_id": 2993}}, "n3337": {"so_21734849_21735176_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 2864}, "so_21734849_21735176_0": {"length": 7, "quality": 0.875, "section_id": 2863}}, "n4659": {"so_21734849_21735176_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 3753}, "so_21734849_21735176_0": {"length": 7, "quality": 0.875, "section_id": 3752}}}, "21735176": {"Id": "21735176", "PostTypeId": "2", "Body": "<p>It's deliberately unspecified by the standard to allow freedom of implementation. Specifically, C++11 \u00a730.5.1 Class <code>condition variable</code> [thread.condition.condvar] states:</p>\n<blockquote>\n<pre><code>void notify_one() noexcept;\n</code></pre>\n<p id=\"so_21734849_21735176_0\"><sup>7</sup> <em>Effects:</em> If any threads are blocked waiting for <code>*this</code>, unblocks one of those threads.</p>\n<pre><code>void notify_all() noexcept;\n</code></pre>\n<p id=\"so_21734849_21735176_1\"><sup>8</sup> <em>Effects:</em> Unblocks all threads that are blocked waiting for <code>*this</code>.</p>\n</blockquote>\n<p>There is no claim made about preference/fairness/priority to any thread(s), simply \"unblocks one\" or \"unblocks all.\"</p>\n", "LastEditorUserId": "923854", "LastActivityDate": "2014-02-12T17:35:02.173", "Score": "1", "CreationDate": "2014-02-12T17:28:27.437", "ParentId": "21734849", "CommentCount": "1", "OwnerUserId": "923854", "LastEditDate": "2014-02-12T17:35:02.173"}});