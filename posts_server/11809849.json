post_cb({"11809849": {"CommentCount": "1", "ViewCount": "322", "CreationDate": "2012-08-04T15:37:10.453", "LastActivityDate": "2012-08-05T17:28:01.977", "Title": "Is a std::string implementation conformant where 's.c_str() + s.size()' is not necessarily the same as '&s[s.size()]'?", "PostTypeId": "1", "Id": "11809849", "Score": "9", "Body": "<p><code>\u00a721.4.5 [string.access]</code></p>\n<pre><code>const_reference operator[](size_type pos) const;\nreference operator[](size_type pos);\n</code></pre>\n<blockquote>\n<p id=\"so_11809849_11809849_0\"><em>Returns:</em> <code>*(begin() + pos)</code> if <code>pos &lt; size()</code>. Otherwise, returns a reference to an object of type <code>charT</code> with value <code>charT()</code>, where modifying the object leads to undefined behavior.</p>\n</blockquote>\n<p>The second part implies, to me atleast, that this \"object of type <code>charT</code>\" may reside outside of the sequence stored in the <code>std::string</code> object. Example implementation of a conforming <code>operator[]</code>:</p>\n<pre><code>reference operator[](size_type pos){\n  static contexpr charT default = charT();\n  if(pos == size())\n    return default;\n  return buf[pos];\n}\n</code></pre>\n<p>Now, <code>c_str()</code>/<code>data()</code>, are specified in terms of <code>operator[]</code>:</p>\n<p><code>\u00a721.4.7 [string.accessors]</code></p>\n<pre><code>const charT* c_str() const noexcept;\nconst charT* data() const noexcept;\n</code></pre>\n<blockquote>\n<p id=\"so_11809849_11809849_1\"><em>Returns:</em> A pointer <code>p</code> such that <code>p + i == &amp;operator[](i)</code> for each <code>i</code> in <code>[0,size()]</code>.</p>\n</blockquote>\n<p>This would make the above <code>operator[]</code> implementation non-conformant, as <code>p + size() != &amp;operator[](size())</code>. However, with a bit of trickery, you can circumvent this problem:</p>\n<pre><code>reference operator[](size_type pos){\n  static contexpr charT default = charT();\n  if(pos == size() &amp;&amp; !evil_context) // assume 'volatile bool evil_context;'\n    return default;\n  return buf[pos];\n}\n\nstruct evil_context_guard{\n  volatile bool&amp; ctx;\n  evil_context_guard(volatile bool&amp; b)\n    : ctx(b) {}\n  ~evil_context_guard(){ b = false; }\n};\n\nconst charT* c_str() const noexcept{\n  evil_context_guard g(evil_context = true);\n  // now, during the call to 'c_str()', the requirement above holds\n  // 'p + i == &amp;operator[](i) for each i in [0,size()]'\n  const charT* p = &amp;buf[0];\n  assert(p+size() == &amp;operator[](size()));\n  return p;\n}\n</code></pre>\n<p>Now, the obvious question is...</p>\n<p><strong>Is the above code <em>really</em> conformant or did I overlook something?</strong></p>\n", "Tags": "<c++><string><c++11><language-lawyer>", "OwnerUserId": "500104", "AnswerCount": "2"}, "11818519": {"ParentId": "11809849", "CommentCount": "1", "Body": "<p>I don't see how it could be conformant. User code can never observe the promised returned value. The <code>assert</code> in the code is misleading because it is in the wrong place: the function has not returned yet. <em>Returns:</em> requirements apply to be value returned from the function, not to some value within its implementation (it should be obvious why that is a nonsensical idea).</p>\n<p>The assertion should be here:</p>\n<pre><code>auto p = s.c_str();\nassert(p + s.size() == &amp;operator[](s.size()));\n</code></pre>\n<p>I believe the wording that treats <code>s[s.size()]</code> specially is simply meant to forbid you from blowing up the null terminator.</p>\n", "OwnerUserId": "46642", "PostTypeId": "2", "Id": "11818519", "Score": "0", "CreationDate": "2012-08-05T17:28:01.977", "LastActivityDate": "2012-08-05T17:28:01.977"}, "11809923": {"ParentId": "11809849", "CommentCount": "5", "Body": "<p>Ignoring the given code, considering only the question, I think that</p>\n<ul>\n<li>unfortunately, the answer seems to be \u201cyes\u201d, and</li>\n<li>that is certainly not the <em>intent</em> of the standard.</li>\n</ul>\n<p>Hence, it appears to be a <strong>defect</strong>.</p>\n<p>Checking the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-index.html#Section%2021\" rel=\"nofollow\">list of known library defects</a> apparently this issue has not yet been reported.</p>\n<p>So, as I stated in chat, I recommend posting it to [comp.std.c++], in order to get resolved the question of whether it <em>really</em> is a defect, and if so, to get it into the defects list and fixed.</p>\n", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "11809923", "Score": "4", "CreationDate": "2012-08-04T15:47:21.633", "LastActivityDate": "2012-08-04T15:47:21.633"}, "bq_ids": {"n4140": {"so_11809849_11809849_0": {"section_id": 1617, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_11809849_11809849_0": {"section_id": 1613, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_11809849_11809849_0": {"section_id": 1770, "quality": 0.9473684210526315, "length": 18}}}});