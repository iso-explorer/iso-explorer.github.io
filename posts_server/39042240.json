post_cb({"39046515": {"ParentId": "39042240", "CommentCount": "0", "Body": "<p>Suppose access control came before overload resolution. Effectively, this would mean that <code>public/protected/private</code> controlled visibility rather than accessibility. </p>\n<p>Section 2.10 of <a href=\"http://rads.stackoverflow.com/amzn/click/0201543303\"><strong>Design and Evolution of C++ by Stroustrup</strong></a> has a passage on this where he discusses the following example</p>\n<pre><code>int a; // global a\n\nclass X {\nprivate:\n    int a; // member X::a\n};\n\nclass XX : public X {\n    void f() { a = 1; } // which a?\n};\n</code></pre>\n<p>Stroustrup mentions that a benefit of the current rules (visibility before accessibility) is that (temporarily) chaning the <code>private</code> inside <code>class X</code> into <code>public</code> (e.g. for the purposes of debugging) is that there is no quiet change in the meaning of the above program (i.e. <code>X::a</code> is attempted to be accessed in both cases, which gives an access error in the above example). If <code>public/protected/private</code> would control visibility, the meaning of the program would change (global <code>a</code> would be called with <code>private</code>, otherwise <code>X::a</code>).</p>\n<p>He then states that he does not recall whether it was by explicit design or a side effect of the preprocessor technology used to implement the C with Classess predecessor to Standard C++.</p>\n<p>How is this related to your example? Basically because the Standard made overload resolution conform to the general rule that name lookup comes before access control.</p>\n<blockquote>\n<p id=\"so_39042240_39046515_0\"><strong>10.2 Member name lookup [class.member.lookup]</strong></p>\n<p id=\"so_39042240_39046515_1\">1 Member name lookup determines the meaning of a name (id-expression)\n  in a class scope (3.3.7). Name lookup can result in an ambiguity, in\n  which case the program is ill-formed. For an id-expression, name\n  lookup begins in the class scope of this; for a qualified-id, name\n  lookup begins in the scope of the nestedname- specifier. <strong>Name lookup\n  takes place before access control</strong> (3.4, Clause 11).</p>\n<p id=\"so_39042240_39046515_2\">8 If the name of an overloaded function is unambiguously found,\n  <strong>overloading resolution (13.3) also takes place before access control</strong>.\n  Ambiguities can often be resolved by qualifying a name with its class\n  name.</p>\n</blockquote>\n", "OwnerUserId": "819272", "PostTypeId": "2", "Id": "39046515", "Score": "30", "CreationDate": "2016-08-19T19:36:48.950", "LastActivityDate": "2016-08-19T19:36:48.950"}, "39042913": {"ParentId": "39042240", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><em>The technical reason has been answered by other answers. I'll only focus on this question:</em></p>\n<blockquote>\n<p id=\"so_39042240_39042913_0\">In other words why overload resolution comes before access control? This is strange. Do you think it is consistent? My code works and then I add a method and my working code does not compile at all.</p>\n</blockquote>\n<p>That's how the language was designed. The intent is trying to call the best viable overload, as far as possible. If it fails, an error will be triggered to remind you to consider the design again.</p>\n<p>On the other hand, suppose your code compiled and worked well with the <code>const</code> member function being invoked. Someday, someone (maybe yourself) then decides to change the accessibility of the non-<code>const</code> member function from <code>private</code> to <code>public</code>. Then, the behavior would change without any compile errors! This would be a <em>surprise</em>.</p>\n", "OwnerUserId": "3309790", "LastEditorUserId": "366904", "LastEditDate": "2016-08-19T18:12:30.043", "Id": "39042913", "Score": "9", "CreationDate": "2016-08-19T15:35:45.947", "LastActivityDate": "2016-08-19T18:12:30.043"}, "39042574": {"ParentId": "39042240", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>When you call <code>a.foo();</code>, the compiler goes through overload resolution to find the best function to use. When it builds the overload set it finds</p>\n<pre><code>void foo() const\n</code></pre>\n<p>and</p>\n<pre><code>void foo()\n</code></pre>\n<p>Now, since <code>a</code> is not <code>const</code>, the non-const version is the best match, so the compiler picks <code>void foo()</code>. Then the access restrictions are put in place and you get a compiler error, since <code>void foo()</code> is private.</p>\n<p>Remember, in overload resolution it is not 'find the best usable function'. It is 'find the best function and try to use it'. If it can't because of access restrictions or being deleted, then you get a compiler error.</p>\n<blockquote>\n<p id=\"so_39042240_39042574_0\">In other words why does overload resolution comes before access control?</p>\n</blockquote>\n<p>Well, let's look at:</p>\n<pre><code>struct Base\n{\n    void foo() { std::cout &lt;&lt; \"Base\\n\"; }\n};\n\nstruct Derived : Base\n{\n    void foo() { std::cout &lt;&lt; \"Derived\\n\"; }\n};\n\nstruct Foo\n{\n    void foo(Base * b) { b-&gt;foo(); }\nprivate:\n    void foo(Derived * d) { d-&gt;foo(); }\n};\n\nint main()\n{\n    Derived d;\n    Foo f;\n    f.foo(&amp;d);\n}\n</code></pre>\n<p>Now let's say that I did not actually mean to make <code>void foo(Derived * d)</code> private. If access control came first then this program would compile and run and <code>Base</code> would be printed. This could be very hard to track down in a large code base. Since access control comes after overload resolution I get a nice compiler error telling me the function I want it to call cannot be called, and I can find the bug a lot easier.</p>\n", "OwnerUserId": "4342498", "LastEditorUserId": "63550", "LastEditDate": "2016-08-19T16:24:35.487", "Id": "39042574", "Score": "122", "CreationDate": "2016-08-19T15:18:01.793", "LastActivityDate": "2016-08-19T16:24:35.487"}, "39042240": {"CommentCount": "2", "AcceptedAnswerId": "39042574", "PostTypeId": "1", "LastEditorUserId": "4342498", "CreationDate": "2016-08-19T15:02:15.707", "LastActivityDate": "2017-03-24T11:33:13.170", "LastEditDate": "2017-03-24T11:33:13.170", "ViewCount": "6628", "FavoriteCount": "7", "Title": "Why is a public const method not called when the non-const one is private?", "Id": "39042240", "Score": "106", "Body": "<p>Consider this code:</p>\n<pre><code>struct A\n{\n    void foo() const\n    {\n        std::cout &lt;&lt; \"const\" &lt;&lt; std::endl;\n    }\n\n    private:\n\n        void foo()\n        {\n            std::cout &lt;&lt; \"non - const\" &lt;&lt; std::endl;\n        }\n};\n\nint main()\n{\n    A a;\n    a.foo();\n}\n</code></pre>\n<p>The compiler error is:</p>\n<blockquote>\n<p id=\"so_39042240_39042240_0\">error: 'void A::foo()' is private`.</p>\n</blockquote>\n<p>But when I delete the private one it just works. Why is the public const method not called when the non-const one is private?</p>\n<p>In other words, why does overload resolution come before access control? This is strange. Do you think it is consistent? My code works and then I add a method, and my working code does not compile at all.</p>\n", "Tags": "<c++><function-overloading><overload-resolution><member-functions>", "OwnerUserId": "163394", "AnswerCount": "11"}, "bq_ids": {"n4140": {"so_39042240_39046515_2": {"section_id": 6996, "quality": 0.9565217391304348, "length": 22}, "so_39042240_39046515_1": {"section_id": 6989, "quality": 0.8717948717948718, "length": 34}, "so_39042240_39042976_0": {"section_id": 564, "quality": 0.9166666666666666, "length": 11}, "so_39042240_39042473_0": {"section_id": 6667, "quality": 0.9166666666666666, "length": 11}, "so_39042240_39042976_1": {"section_id": 562, "quality": 0.8260869565217391, "length": 19}}, "n3337": {"so_39042240_39046515_2": {"section_id": 6742, "quality": 0.9565217391304348, "length": 22}, "so_39042240_39046515_1": {"section_id": 6735, "quality": 0.8717948717948718, "length": 34}, "so_39042240_39042976_0": {"section_id": 555, "quality": 0.9166666666666666, "length": 11}, "so_39042240_39042473_0": {"section_id": 6422, "quality": 0.9166666666666666, "length": 11}, "so_39042240_39042976_1": {"section_id": 553, "quality": 0.8260869565217391, "length": 19}}, "n4659": {"so_39042240_39046515_2": {"section_id": 8494, "quality": 0.9130434782608695, "length": 21}, "so_39042240_39046515_1": {"section_id": 8487, "quality": 0.8717948717948718, "length": 34}, "so_39042240_39042976_0": {"section_id": 587, "quality": 0.9166666666666666, "length": 11}, "so_39042240_39042473_0": {"section_id": 8142, "quality": 0.9166666666666666, "length": 11}, "so_39042240_39042976_1": {"section_id": 585, "quality": 0.8260869565217391, "length": 19}}}, "39042619": {"ParentId": "39042240", "CommentCount": "0", "Body": "<p>Access controls (<code>public</code>, <code>protected</code>, <code>private</code>) do not affect overload resolution. The compiler chooses <code>void foo()</code> because it's the best match. The fact that it's not accessible doesn't change that. Removing it leaves only <code>void foo() const</code>, which is then the best (i.e., only) match.</p>\n", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "39042619", "Score": "12", "CreationDate": "2016-08-19T15:20:18.457", "LastActivityDate": "2016-08-19T15:20:18.457"}, "39042299": {"ParentId": "39042240", "CommentCount": "0", "Body": "<p>Because the variable <code>a</code> in the <code>main</code> function is not declared as <code>const</code>.</p>\n<p>Constant member functions are called on constant objects.</p>\n", "OwnerUserId": "440558", "PostTypeId": "2", "Id": "39042299", "Score": "8", "CreationDate": "2016-08-19T15:05:05.843", "LastActivityDate": "2016-08-19T15:05:05.843"}, "39042625": {"ParentId": "39042240", "CommentCount": "1", "Body": "<p>It's important to keep in mind the order of things that happen, which is:</p>\n<ol>\n<li>Find all the viable functions.</li>\n<li>Pick the best viable function.</li>\n<li>If there isn't exactly one best viable, or if you can't actually call the best viable function (due to access violations or the function being <code>delete</code>d), fail. </li>\n</ol>\n<p>(3) happens after (2). Which is really important, because otherwise making functions <code>delete</code>d or <code>private</code> would become sort of meaningless and much harder to reason about. </p>\n<p>In this case:</p>\n<ol>\n<li>The viable functions are <code>A::foo()</code> and <code>A::foo() const</code>.</li>\n<li>The best viable function is <code>A::foo()</code> because the latter involves a qualification conversion on the implicit <code>this</code> argument.</li>\n<li>But <code>A::foo()</code> is <code>private</code> and you don't have access to it, hence the code is ill-formed. </li>\n</ol>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "39042625", "Score": "20", "CreationDate": "2016-08-19T15:20:28.060", "LastActivityDate": "2016-08-19T15:20:28.060"}, "39042314": {"ParentId": "39042240", "CommentCount": "4", "Body": "<p>Since the implicit <code>this</code> pointer is non-<code>const</code>, the compiler will first check for the presence of a non-<code>const</code> version of the function before a <code>const</code> version.</p>\n<p>If you explicitly mark the non-<code>const</code> one <code>private</code> then the resolution will fail, and the compiler will not continue searching.</p>\n", "OwnerUserId": "2380830", "PostTypeId": "2", "Id": "39042314", "Score": "23", "CreationDate": "2016-08-19T15:05:48.900", "LastActivityDate": "2016-08-19T15:05:48.900"}, "39042694": {"ParentId": "39042240", "CommentCount": "0", "Body": "<p>Access specifiers do not affect name-lookup and function-call resolution, ever. The function is selected before the compiler checks whether the call should trigger an access violation. </p>\n<p>This way, if you change an access specifier, you'll be alerted at compile-time if there is a violation in existing code; if privacy were taken into account for function call resolution, your program's behavior could silently change. </p>\n", "OwnerUserId": "1858225", "PostTypeId": "2", "Id": "39042694", "Score": "8", "CreationDate": "2016-08-19T15:24:00.390", "LastActivityDate": "2016-08-19T15:24:00.390"}, "39042622": {"ParentId": "39042240", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>This comes down to a fairly basic design decision in C++.</p>\n<p>When looking up the function to satisfy a call, the compiler carries out a search like this:</p>\n<ol>\n<li><p>It searches to find the first<sup>1</sup> scope at which there's <em>something</em> with that name.</p></li>\n<li><p>The compiler finds <em>all</em> the functions (or functors, etc.) with that name in that scope.</p></li>\n<li><p>Then the compiler does overload resolution to find the best candidate among those it found (whether they're accessible or not).</p></li>\n<li><p>Finally, the compiler checks whether that chosen function is accessible.</p></li>\n</ol>\n<p>Because of that ordering, yes, it's possible that the compiler will choose an overload that's not accessible, even though there's another overload that's accessible (but not chosen during overload resolution).</p>\n<p>As to whether it would be <em>possible</em> to do things differently: yes, it's undoubtedly possible. It would definitely lead to quite a different language than C++ though. It turns out that a lot of seemingly rather minor decisions can have ramifications that affect a lot more than might be initially obvious.</p>\n<hr>\n<ol>\n<li>\"First\" can be a little complex in itself, especially when/if templates get involved, since they can lead to two-phase lookup, meaning there are two entirely separate \"roots\" to start from when doing the search. The <em>basic</em> idea is pretty simple though: start from the smallest enclosing scope, and work your way outward to larger and larger enclosing scopes.</li>\n</ol>\n</hr>", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2016-08-19T16:14:32.020", "Id": "39042622", "Score": "14", "CreationDate": "2016-08-19T15:20:22.500", "LastActivityDate": "2016-08-19T16:14:32.020"}, "39042976": {"ParentId": "39042240", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Ultimately this comes down to the assertion in the standard that <strong>accessibility should not be taken into consideration when performing overload resolution</strong>. This assertion may be found in <a href=\"http://eel.is/c++draft/over.match#3\">[over.match]</a> clause 3:</p>\n<blockquote>\n<p id=\"so_39042240_39042976_0\">... When overload resolution succeeds, and the best viable function is not accessible (Clause [class.access]) in the context in which it is used, the program is ill-formed.</p>\n</blockquote>\n<p>and also the <em>Note</em> in clause 1 of the same section:</p>\n<blockquote>\n<p id=\"so_39042240_39042976_1\">[ Note: The function selected by overload resolution is not guaranteed to be appropriate for the context. Other restrictions, such as the accessibility of the function, can make its use in the calling context ill-formed.  \u2014 end note ]</p>\n</blockquote>\n<p>As for why, I can think of a couple of possible motivations:</p>\n<ol>\n<li>It prevents unexpected changes of behaviour as a result of changing the accessibility of an overload candidate (instead, a compile error will occur).</li>\n<li>It removes context-dependence from the overload resolution process (i.e. overload resolution would have the same result whether inside or outside the class).</li>\n</ol>\n", "OwnerUserId": "995218", "LastEditorUserId": "995218", "LastEditDate": "2016-08-19T15:58:32.230", "Id": "39042976", "Score": "33", "CreationDate": "2016-08-19T15:39:12.570", "LastActivityDate": "2016-08-19T15:58:32.230"}, "39042473": {"ParentId": "39042240", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>In this call:</p>\n<pre><code>a.foo();\n</code></pre>\n<p>There is always an implicit <code>this</code> pointer available in every member function. And the <code>const</code> qualification of <code>this</code> is taken from the calling reference/object. The above call <em>is treated</em> by the compiler as:</p>\n<pre><code>A::foo(a);\n</code></pre>\n<p>But you have two declarations of <code>A::foo</code> which is <em>treated like</em>:</p>\n<pre><code>A::foo(A* );\nA::foo(A const* );\n</code></pre>\n<p>By overload resolution, the first will be selected for non-const <code>this</code>, the second will be selected for a <code>const this</code>. If you remove the first, the second will bind to both <code>const</code> and <code>non-const</code> <code>this</code>.</p>\n<p>After overload resolution to select the best viable function, comes access control. Since you specified access to the chosen overload as <code>private</code>, the compiler will then complain.</p>\n<p>The standard says so:</p>\n<blockquote>\n<p id=\"so_39042240_39042473_0\"><strong><a href=\"http://eel.is/c++draft/class.access#4\" rel=\"noreferrer\">[class.access/4]</a>:</strong> ...In the case of overloaded function names, access control is applied to\n  the function selected by overload resolution....</p>\n</blockquote>\n<p>But if you do this:</p>\n<pre><code>A a;\nconst A&amp; ac = a;\nac.foo();\n</code></pre>\n<p>Then, only the <code>const</code> overload will be fit.</p>\n", "OwnerUserId": "1621391", "LastEditorUserId": "1621391", "LastEditDate": "2016-08-19T15:33:54.530", "Id": "39042473", "Score": "11", "CreationDate": "2016-08-19T15:12:17.583", "LastActivityDate": "2016-08-19T15:33:54.530"}});