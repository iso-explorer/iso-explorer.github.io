post_cb({"bq_ids": {"n4140": {"so_37726206_37726704_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 5458}}, "n3337": {"so_37726206_37726704_0": {"length": 5, "quality": 0.5555555555555556, "section_id": 382}}, "n4659": {"so_37726206_37726704_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 6884}}}, "37726704": {"Id": "37726704", "PostTypeId": "2", "Body": "<p>From <a href=\"http://eel.is/c++draft/dcl.spec.auto#14\" rel=\"noreferrer\">[dcl.spec.auto]</a>:</p>\n<blockquote>\n<p id=\"so_37726206_37726704_0\">A function declared with a return type that uses a placeholder type shall not be virtual ([class.virtual]).</p>\n</blockquote>\n<p><code>internal()</code> is a virtual function, so you can't use <code>auto</code>.</p>\n<p>The <a href=\"https://isocpp.org/files/papers/N3638.html\" rel=\"noreferrer\">original proposal</a> indicates the reasoning for this:</p>\n<blockquote>\n<p id=\"so_37726206_37726704_1\">It would be possible to allow return type deduction for virtual functions, but that would complicate both override checking and vtable layout, so it seems preferable to prohibit this.</p>\n</blockquote>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-06-09T13:01:27.327", "Score": "14", "CreationDate": "2016-06-09T12:58:59.743", "ParentId": "37726206", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2016-06-09T13:01:27.327"}, "37726206": {"ViewCount": "354", "Body": "<p>I have the following code:</p>\n<pre><code>struct A{};\n\nstruct Base {\n    virtual A&amp; internal() = 0;\n};\n\nstruct Derives : public Base {    \n    auto&amp; internal() override { // &lt;-- conflicting return type\n        return internal_;\n    }\n\nprivate:\n    A internal_;\n};\n\nint main() {\n    Derives d;\n    auto&amp; internal = d.internal();\n}\n</code></pre>\n<p>This fails to compile (tested on coliru - with gcc) with a conflicting return type - my question is why can't the compiler deduce that both <code>internal_</code> (and therefore the return type) is <code>A</code>? Is the type deduced for <code>auto</code> in a different stage of compilation for example than the one which checks the virtual overrides? Of course this compiles if you replace <code>auto</code> with the correct type - but that is besides the point.</p>\n<p>(Here is the clang error, gcc is somewhat similar)</p>\n<blockquote>\n<p id=\"so_37726206_37726206_0\">main.cpp:8:11: error: return type of virtual function 'internal' is\n  not covariant with the return type of the function it overrides ('auto\n  &amp;' is not derived from 'A &amp;')</p>\n<pre><code>auto&amp; internal() override { // &lt;-- conflicting return type\n~~~~~ ^\n</code></pre>\n<p id=\"so_37726206_37726206_1\">main.cpp:4:16: note: overridden virtual function is here</p>\n<pre><code>virtual A&amp; internal() = 0;\n        ~~ ^\n</code></pre>\n<p id=\"so_37726206_37726206_2\">1 error generated.</p>\n</blockquote>\n", "AcceptedAnswerId": "37726704", "Title": "Conflict in return type from base class with derived class using auto", "CreationDate": "2016-06-09T12:36:46.090", "Id": "37726206", "CommentCount": "8", "LastEditDate": "2016-06-09T14:09:00.270", "PostTypeId": "1", "LastEditorUserId": "2069064", "LastActivityDate": "2016-06-09T14:09:00.270", "Score": "8", "OwnerUserId": "266198", "Tags": "<c++><c++14>", "AnswerCount": "1"}});