post_cb({"5781222": {"ViewCount": "3004", "Body": "<p>Sample code snippet</p>\n<pre><code>const const const int x = 10;   \nint main()\n{}\n</code></pre>\n<p>gets compiled in C but not in C++. Why does it get compiled in C? I thought this would fail in C as well. Never mind.</p>\n<p>Which part of the C++ Standard forbids the use of duplicate <code>const</code> and which part of the C standard allows this?</p>\n", "AcceptedAnswerId": "5781283", "Title": "Duplicate const qualifier allowed in C but not in C++?", "CreationDate": "2011-04-25T17:42:40.840", "Id": "5781222", "CommentCount": "8", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2011-04-25T17:47:59.880", "LastEditorUserId": "319403", "LastActivityDate": "2011-04-25T18:14:04.227", "Score": "21", "OwnerUserId": "165520", "Tags": "<c++><c><language-agnostic><const>", "AnswerCount": "4"}, "5781361": {"Id": "5781361", "PostTypeId": "2", "Body": "<p>C++ 2003 prohibits it in 7.1.5/1 \"... redundant cv-qualifiers are prohibited except when introduced through the use of typedefs or template type arguments ...\".</p>\n", "LastActivityDate": "2011-04-25T17:56:56.973", "CommentCount": "0", "CreationDate": "2011-04-25T17:56:56.973", "ParentId": "5781222", "Score": "4", "OwnerUserId": "212870"}, "5781283": {"Id": "5781283", "PostTypeId": "2", "Body": "<p>C99 \u00a76.7.3/4:</p>\n<blockquote>\n<p id=\"so_5781222_5781283_0\">If the same qualifier appears more than once in the same <em>specifier-qualifier-list</em>, either directly or via one or more <strong>typedef</strong> s, the behavior is the same as if it appeared only once.</p>\n</blockquote>\n<p>Yes, that is valid C99, and your discovery is correct.</p>\n", "LastActivityDate": "2011-04-25T17:49:47.680", "CommentCount": "5", "CreationDate": "2011-04-25T17:49:47.680", "ParentId": "5781222", "Score": "23", "OwnerUserId": "153285"}, "5781284": {"Id": "5781284", "PostTypeId": "2", "Body": "<p>From the last C++0x draft, [dcl.type]:</p>\n<blockquote>\n<p id=\"so_5781222_5781284_0\">As a general rule, at most one type-specifier is allowed in the complete decl-specifier-seq of a declaration or in a type-specifier-seq or trailing-type-specifier-seq. The only exceptions to this rule are the following:</p>\n<p id=\"so_5781222_5781284_1\">\u2014 const can be combined with any type specifier except itself.</p>\n<p id=\"so_5781222_5781284_2\">\u2014 volatile can be combined with any type specifier except itself.</p>\n<p id=\"so_5781222_5781284_3\">\u2014 signed or unsigned can be combined with char, long, short, or int.</p>\n<p id=\"so_5781222_5781284_4\">\u2014 short or long can be combined with int.</p>\n<p id=\"so_5781222_5781284_5\">\u2014 long can be combined with double.</p>\n<p id=\"so_5781222_5781284_6\">\u2014 long can be combined with long.</p>\n</blockquote>\n", "LastActivityDate": "2011-04-25T17:49:55.777", "CommentCount": "5", "CreationDate": "2011-04-25T17:49:55.777", "ParentId": "5781222", "Score": "16", "OwnerUserId": "277176"}, "bq_ids": {"n4140": {"so_5781222_5781284_1": {"length": 7, "quality": 1.0, "section_id": 5427}, "so_5781222_5781308_2": {"length": 23, "quality": 0.6764705882352942, "section_id": 5430}, "so_5781222_5781284_6": {"length": 4, "quality": 1.0, "section_id": 5427}, "so_5781222_5781284_4": {"length": 5, "quality": 1.0, "section_id": 5427}, "so_5781222_5781284_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 5427}, "so_5781222_5781284_5": {"length": 4, "quality": 1.0, "section_id": 5427}, "so_5781222_5781284_2": {"length": 7, "quality": 1.0, "section_id": 5427}, "so_5781222_5781284_3": {"length": 8, "quality": 1.0, "section_id": 5427}}, "n3337": {"so_5781222_5781284_1": {"length": 7, "quality": 1.0, "section_id": 5222}, "so_5781222_5781308_2": {"length": 23, "quality": 0.6764705882352942, "section_id": 5225}, "so_5781222_5781284_5": {"length": 4, "quality": 1.0, "section_id": 5222}, "so_5781222_5781284_0": {"length": 14, "quality": 0.9333333333333333, "section_id": 5222}, "so_5781222_5781284_6": {"length": 4, "quality": 1.0, "section_id": 5222}, "so_5781222_5781284_4": {"length": 5, "quality": 1.0, "section_id": 5222}, "so_5781222_5781284_2": {"length": 7, "quality": 1.0, "section_id": 5222}, "so_5781222_5781284_3": {"length": 8, "quality": 1.0, "section_id": 5222}}, "n4659": {"so_5781222_5781284_1": {"length": 7, "quality": 1.0, "section_id": 6855}, "so_5781222_5781308_2": {"length": 23, "quality": 0.6764705882352942, "section_id": 6858}, "so_5781222_5781284_5": {"length": 4, "quality": 1.0, "section_id": 6855}, "so_5781222_5781284_0": {"length": 12, "quality": 0.8, "section_id": 6855}, "so_5781222_5781284_6": {"length": 4, "quality": 1.0, "section_id": 6855}, "so_5781222_5781284_4": {"length": 5, "quality": 1.0, "section_id": 6855}, "so_5781222_5781284_2": {"length": 7, "quality": 1.0, "section_id": 6855}, "so_5781222_5781284_3": {"length": 8, "quality": 1.0, "section_id": 6855}}}, "5781308": {"Id": "5781308", "PostTypeId": "2", "Body": "<p>The C++0x grammar appears to allow it:</p>\n<blockquote>\n<p id=\"so_5781222_5781308_0\"><em>cv-qualifier-seq</em>:</p>\n<ul>\n<li><em>cv-qualifier</em> <em>cv-qualifier-seq</em> opt</li>\n</ul>\n<p id=\"so_5781222_5781308_1\"><em>cv-qualifier</em>:</p>\n<pre><code>  const\n\n  volatile\n</code></pre>\n</blockquote>\n<hr>\n<p>Also, <code>[decl.type.cv]</code> appears to allow it:</p>\n<blockquote>\n<p id=\"so_5781222_5781308_2\">There are two <em>cv-qualifiers</em>, <code>const</code> and <code>volatile</code>.  If a <em>cv-qualifier</em> appears in a <em>decl-specifier-seq</em>, the <em>init-declarator-list</em> of the declaration shall not be empty. [ Note: 3.9.3 and 8.3.5 describe how cv-quali\ufb01ers a\ufb00ect\n  object and function types.  \u2014 end note ] Redundant cv-qualifications are ignored. [ Note: For example, these\n  could be introduced by typedefs. \u2014 end note ]</p>\n</blockquote>\n</hr>", "LastActivityDate": "2011-04-25T17:51:58.097", "CommentCount": "1", "CreationDate": "2011-04-25T17:51:58.097", "ParentId": "5781222", "Score": "3", "OwnerUserId": "103167"}});