post_cb({"2597398": {"ParentId": "2597116", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2010-04-08T03:26:35.040", "Score": "4", "LastEditorUserId": "221955", "LastEditDate": "2010-04-08T12:07:45.753", "Id": "2597398", "OwnerUserId": "221955", "Body": "<p>So everyone has been saying you cant do it - it leads to undefined behaviour. However\nthere are some cases where it is safe. If you are never creating instances of your class dynamically then you should be OK. (i.e. no new calls)</p>\n<p>That said, it is generally considered a bad thing to do as someone might try to create one polymorphically at some later date. ( You may be able to protect against this by having a private unimplemented operator new, but I'm not sure. )</p>\n<p>I have two examples where I don't hate deriving from classes with non-virtual destructors.\nThe first is creating syntactic sugar using temporaries ... here's a contrived example.</p>\n<pre><code>class MyList : public std::vector&lt;int&gt;\n{\n   public:\n     MyList operator&lt;&lt;(int i) const\n     {\n       MyList retval(*this);\n       retval.push_back(i);\n       return retval;\n     }\n   private: \n     // Prevent heap allocation\n     void * operator new   (size_t);\n     void * operator new[] (size_t);\n     void   operator delete   (void *);\n     void   operator delete[] (void*);\n};\n\nvoid do_somthing_with_a_vec( std::vector&lt;int&gt; v );\nvoid do_somthing_with_a_const_vec_ref( const std::vector&lt;int&gt; &amp;v );\n\nint main()\n{\n   // I think this slices correctly .. \n   // if it doesn't compile you might need to add a \n   // conversion operator to MyList\n   std::vector&lt;int&gt; v = MyList()&lt;&lt;1&lt;&lt;2&lt;&lt;3&lt;&lt;4;\n\n  // This will slice to a vector correctly.\n   do_something_with_a_vec( MyList()&lt;&lt;1&lt;&lt;2&lt;&lt;3&lt;&lt;4 );\n\n  // This will pass a const ref - which will be OK too.\n   do_something_with_a_const_vec_ref( MyList()&lt;&lt;1&lt;&lt;2&lt;&lt;3&lt;&lt;4 );\n\n  //This will not compile as MyList::operator new is private\n  MyList * ptr = new MyList();\n}\n</code></pre>\n<p>The other valid usage I can think of comes from the lack of template typedefs in C++. Here's how you might use it.</p>\n<pre><code>// Assume this is in code we cant control\ntemplate&lt;typename T1, typename T2 &gt;\nclass ComplicatedClass\n{\n  ...\n};\n\n// Now in our code we want TrivialClass = ComplicatedClass&lt;int,int&gt;\n// Normal typedef is OK\ntypedef ComplicatedClass&lt;int,int&gt; TrivialClass;\n\n// Next we want to be able to do SimpleClass&lt;T&gt; = ComplicatedClass&lt;T,T&gt; \n// But this doesn't compile\ntemplate&lt;typename T&gt;\ntypedef CompilicatedClass&lt;T,T&gt; SimpleClass;\n\n// So instead we can do this - \n// so long as it is not used polymorphically if \n// ComplicatedClass doesn't have a virtual destructor we are OK.\ntemplate&lt;typename T&gt;\nclass SimpleClass : public ComplicatedClass&lt;T,T&gt;\n{\n  // Need to add the constructors we want here :(\n  // ...\n   private: \n     // Prevent heap allocation\n     void * operator new   (size_t);\n     void * operator new[] (size_t);\n     void   operator delete   (void *);\n     void   operator delete[] (void*);\n}\n</code></pre>\n<p>Heres a more concrete example of this. You want to use std::map with a custom allocator for many different types, but you dont want the unmaintainable </p>\n<pre><code>std::map&lt;K,V, std::less&lt;K&gt;, MyAlloc&lt;K,V&gt; &gt;\n</code></pre>\n<p>littered through your code.</p>\n<pre><code>template&lt;typename K, typename V&gt;\nclass CustomAllocMap : public std::map&lt; K,V, std::less&lt;K&gt;, MyAlloc&lt;K,V&gt; &gt;\n{\n  ...\n   private: \n     // Prevent heap allocation\n     void * operator new   (size_t);\n     void * operator new[] (size_t);\n     void   operator delete   (void *);\n     void   operator delete[] (void*);\n}; \n\nMyCustomAllocMap&lt;K,V&gt; map;\n</code></pre>\n", "LastActivityDate": "2010-04-08T12:07:45.753"}, "2597123": {"ParentId": "2597116", "CommentCount": "4", "CreationDate": "2010-04-08T02:11:49.333", "OwnerUserId": "3153", "PostTypeId": "2", "Id": "2597123", "Score": "2", "Body": "<p>Problem can occur if you store the memory address of a derived type inside the base type and then call delete on the base type:</p>\n<pre><code>B* b = new C();\ndelete b;\n</code></pre>\n<p>If B had a virtual destructor then C's destructor would be called and then B's. \nBut without a virtual destructor you have undefined behavior. </p>\n<p>the following 2 deletes cause no problem:</p>\n<pre><code>B* b = new B();\ndelete b;\nC* c = new C()\ndelete c;\n</code></pre>\n", "LastActivityDate": "2010-04-08T02:11:49.333"}, "2598094": {"ParentId": "2597116", "CommentCount": "0", "CreationDate": "2010-04-08T06:56:25.587", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "2598094", "Score": "1", "Body": "<p>To add to what's been said.</p>\n<ul>\n<li>You are actually considering adding methods to a class that's already considered bloated.</li>\n<li>You want your <code>path</code> class to be considered as a <code>string</code> even though a number of operations would make little sense</li>\n</ul>\n<p>I would propose that you use <code>Composition</code> over <code>Inheritance</code>. This way you will only reimplement (forward) those operations which really make sense for your class (I don't think you really need the subscript operator, for example).</p>\n<p>Also, you might consider using a <code>std::wstring</code> instead, or perhaps a <code>ICU</code> string, to be able to handle more than ASCII characters (I am a nitpick, but then I am French and lower ASCII is insufficient for the French language).</p>\n<p>It is, really, a matter of encapsulation. If you decide to handle UTF-8 characters properly one day and change your base class... chances are your clients will hang you by the feet. On the other hand, if you have used composition, they'll never have any issue as long as you tread carefully with the interface.</p>\n<p>Finally, as has been suggested, free functions shall lead the way. Once again because they provide better encapsulation (as long as they are not friend...).</p>\n", "LastActivityDate": "2010-04-08T06:56:25.587"}, "2597735": {"ParentId": "2597116", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2010-04-08T05:18:33.263", "Score": "2", "LastEditorUserId": "3622940", "LastEditDate": "2014-08-11T09:58:30.823", "Id": "2597735", "OwnerUserId": "148146", "Body": "<p>This is not an answer to your question, but to the problem you were trying to solve (path formatting). Take a look at <a href=\"http://www.boost.org/doc/libs/release/libs/filesystem/index.html\" rel=\"nofollow noreferrer\"><code>boost::filesystem</code></a>, which has a better way to concatenate paths:</p>\n<pre><code>boost::filesystem::path p = \"/some/file/path\";\np /= \"filename.txt\";\n</code></pre>\n<p>You can then retrieve the path as a string in both platform-neutral and platform-specific formats.</p>\n<p>The best part is that it has been accepted into TR2, which means it will become part of the C++ standard in the future.</p>\n", "LastActivityDate": "2014-08-11T09:58:30.823"}, "2597128": {"ParentId": "2597116", "PostTypeId": "2", "CommentCount": "10", "CreationDate": "2010-04-08T02:13:07.807", "Score": "12", "LastEditorUserId": "87234", "LastEditDate": "2010-04-08T05:33:18.077", "Id": "2597128", "OwnerUserId": "87234", "Body": "<p>No, it's not safe to publically inherit from classes without virtual destructors, because if you delete the derived through a base you enter undefined behavior. The definition of the derived class is irrelevant (data members or not, etc.):</p>\n<blockquote>\n<p id=\"so_2597116_2597128_0\">\u00a75.3.5/3: In the first alternative (delete object), if the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand\u2019s dynamic type <strong>and the static type shall have a virtual destructor or the behavior is undefined.</strong> <sub>(Emphasis mine.)</sub></p>\n</blockquote>\n<p>Both of those examples in your code lead to undefined behavior. You can inherit non-publicly, but that obviously defeats the purpose of using that class then extending it. (Since it's not longer possible to delete it through a base pointer.)</p>\n<p>This is (one reason*) why you shouldn't inherit from standard library classes. The <a href=\"http://punchlet.wordpress.com/2009/12/29/letter-the-fifth/\" rel=\"noreferrer\">best solution</a> is to extend it with free-functions. In fact, even if you could you should <a href=\"http://www.gotw.ca/gotw/084.htm\" rel=\"noreferrer\">prefer free-functions anyway</a>.</p>\n<hr>\n<p><sub>*Another being: Do you really want to replace all your string usage with a new string class, just to get some functionality? That's a lot of unnecessary work.</sub></p>\n</hr>", "LastActivityDate": "2010-04-08T05:33:18.077"}, "2597116": {"CommentCount": "0", "ViewCount": "3946", "PostTypeId": "1", "LastEditorUserId": "3622940", "CreationDate": "2010-04-08T02:10:44.490", "LastActivityDate": "2014-08-11T09:58:30.823", "Title": "Is extending a base class with non-virtual destructor dangerous?", "AcceptedAnswerId": "2597398", "LastEditDate": "2014-08-11T09:57:30.220", "Id": "2597116", "Score": "10", "Body": "<p>In the following code:</p>\n<pre><code>class A {\n};\nclass B : public A {\n};\nclass C : public A {\n   int x;\n};\n\nint main (int argc, char** argv) {\n   A* b = new B();\n   A* c = new C();\n\n   //in both cases, only ~A() is called, not ~B() or ~C()\n   delete b; //is this ok?\n   delete c; //does this line leak memory?\n\n   return 0;\n}\n</code></pre>\n<p>When calling delete on a class with a non-virtual destructor with member functions (like class C), can the memory allocator tell what the proper size of the object is? If not, is memory leaked?</p>\n<p>Secondly, if the class has no member functions, and no explicit destructor behaviour (like class B), is everything ok?</p>\n<p>I ask this because I wanted to create a class to extend <code>std::string</code>, (which I know is not recommended, but for the sake of the discussion just bear with it), and overload the <code>+=</code>, <code>+</code> operator. -Weffc++ gives me a warning because <code>std::string</code> has a non virtual destructor, but does it matter if the sub-class has no members and does not need to do anything in its destructor?</p>\n<p>FYI the <code>+=</code> overload was to do proper file path formatting, so the path class could be used like:</p>\n<pre><code>class path : public std::string {\n    //... overload, +=, +\n    //... add last_path_component, remove_path_component, ext, etc...\n};\n\npath foo = \"/some/file/path\";\nfoo = foo + \"filename.txt\";\nstd::string s = foo; //easy assignment to std::string\nsome_function_taking_std_string (foo); //easy implicit conversion\n//and so on...\n</code></pre>\n<p>I just wanted to make sure someone doing this:</p>\n<pre><code>path* foo = new path();\nstd::string* bar = foo;\ndelete bar;\n</code></pre>\n<p>would not cause any problems with memory allocation?</p>\n", "Tags": "<c++><memory-management><polymorphism>", "OwnerUserId": "40175", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_2597116_2597128_0": {"section_id": 6107, "quality": 0.7857142857142857, "length": 22}}, "n3337": {"so_2597116_2597128_0": {"section_id": 5873, "quality": 0.7857142857142857, "length": 22}}, "n4659": {"so_2597116_2597128_0": {"section_id": 7604, "quality": 0.7857142857142857, "length": 22}}}, "2597139": {"ParentId": "2597116", "CommentCount": "1", "CreationDate": "2010-04-08T02:14:39.240", "OwnerUserId": "223265", "PostTypeId": "2", "Id": "2597139", "Score": "1", "Body": "<p>It is only safe to <em>private</em>ly inherit from base classes without a virtual destructor.  Public inheritance would make it possible for a derived class to be deleted through a base class pointer, which is undefined behavior in C++.</p>\n<p>This is one of the only reasonable uses of private inheritance in C++.</p>\n", "LastActivityDate": "2010-04-08T02:14:39.240"}});