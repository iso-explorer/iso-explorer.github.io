post_cb({"22902314": {"CommentCount": "7", "ViewCount": "142", "CreationDate": "2014-04-07T01:44:21.840", "LastActivityDate": "2014-04-07T07:34:06.080", "Title": "Singleton in java vs. Singleton in C++", "AcceptedAnswerId": "22904584", "PostTypeId": "1", "Id": "22902314", "Score": "1", "Body": "<p>In Java I can create a Singleton like this (as long as it doesn't throw as exception):</p>\n<pre><code>private static Singleton m_this = new Singleton();\n</code></pre>\n<p>This is very convenient because it's inherently thread safe.</p>\n<p>Can I do something similar in C++?</p>\n", "Tags": "<java><c++><singleton>", "OwnerUserId": "1028741", "AnswerCount": "3"}, "22906173": {"ParentId": "22902314", "CommentCount": "0", "Body": "<p>Also, on top of answer given by Pawe\u0142 Stawarz, I would add that copy constructor, move constructor (C++11), overloaded assignment operator and destructor should be private too. </p>\n<pre><code>class singleton{\n   singleton(){}; // private constructor\n   ~singleton(){}; // private destructor\n   singleton(const singleton &amp;src){}; // private copy constructor\n   singleton(const singleton&amp;&amp; src){}; // private move constructor for C++11\n   singleton&amp; operator = (const singleton&amp; src){return *this;} // private = operator\n   friend class factory;\n};\n</code></pre>\n<p>Being private, copy constructor, move constructor (C++11), overloaded assignment operator and destructor cannot be called from outside to clone an existing copy and also to destroy a copy just created.</p>\n", "OwnerUserId": "2032021", "PostTypeId": "2", "Id": "22906173", "Score": "1", "CreationDate": "2014-04-07T07:34:06.080", "LastActivityDate": "2014-04-07T07:34:06.080"}, "22904584": {"ParentId": "22902314", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>One way of making a singleton with thread-safe initialization, guaranteed by the standard as of C++11. is:</p>\n<pre><code>class SomeSingleton {\n  public:\n    static SomeSingleton&amp; instance() {\n      static SomeSingleton instance_;\n      return instance_;\n    }\n\n  private:\n  SomeSingleton() {\n    ...\n  }\n};\n</code></pre>\n<p>This is thread-safe, because <a href=\"https://stackoverflow.com/questions/8102125/is-local-static-variable-initialization-thread-safe-in-c11\">local static variable initialization is thread-safe in C++11</a>. The relevant standard document, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow noreferrer\">N3485</a>, says in section 6.7.4:</p>\n<blockquote>\n<p id=\"so_22902314_22904584_0\">such a variable is initialized the first time control passes through its declaration; such a variable is considered initialized upon the completion of its initialization. [...] If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.</p>\n</blockquote>\n<p>with footnote:</p>\n<blockquote>\n<p id=\"so_22902314_22904584_1\">The implementation must not introduce any deadlock around execution of the initializer.</p>\n</blockquote>\n<p>You can abstract into a nice template base class with CRTP:</p>\n<pre><code>//Singleton template definition\ntemplate &lt;typename TDerived&gt;\nclass Singleton {\n  static_assert(is_base_of&lt;Singleton, TDerived&gt;::value, \"Singleton: unexpected Derived template parameter\");\n  public:\n    static TDerived&amp; instance() {\n      static TDerived instance_;\n      return instance_;\n    }\n\n  protected:\n  Singleton() {\n  }\n};\n\n// SomeSingleton definition, using the Singleton template\nclass SomeSingleton : public Singleton&lt;SomeSingleton&gt; {\n  ...\n};\n</code></pre>\n", "OwnerUserId": "2715219", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:28:50.143", "Id": "22904584", "Score": "3", "CreationDate": "2014-04-07T05:56:14.213", "LastActivityDate": "2014-04-07T05:56:14.213"}, "22902369": {"ParentId": "22902314", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>If by <em>Singleton</em>, you mean a <strong>real</strong> <a href=\"http://en.wikipedia.org/wiki/Singleton_pattern\" rel=\"nofollow\">singleton</a> (which I'm not sure is the same you gave an example of, because you still could create a second <code>Singleton</code> instance and assign it to a different variable), the answer is <strong>yes</strong>. You can create a singleton object using the <strong>factory pattern</strong>.</p>\n<pre><code>class factory;\nclass singleton{\n   singleton(){}; // private constructor\n   friend class factory;\n};\n\nclass factory{\n   private:\n      static std::shared_ptr&lt;singleton&gt; object;\n\n   public:\n      static singleton&amp; getSingleton(){\n         if(object)\n            return *object;\n         object = new singleton;\n         return *object;\n      }\n};\n</code></pre>\n<p>Instead of making a dedicated <code>factory</code> class, you could make <code>getSingleton</code> a <code>static</code> member function of <code>singleton</code> itself too. Just remember to make the constructor <code>private</code>, so the user can't create multiple copies.</p>\n", "OwnerUserId": "2180870", "LastEditorUserId": "2180870", "LastEditDate": "2014-04-07T02:07:05.240", "Id": "22902369", "Score": "1", "CreationDate": "2014-04-07T01:50:58.810", "LastActivityDate": "2014-04-07T02:07:05.240"}, "bq_ids": {"n4140": {"so_22902314_22904584_1": {"section_id": 3919, "quality": 0.875, "length": 7}, "so_22902314_22904584_0": {"section_id": 3919, "quality": 1.0, "length": 30}}, "n3337": {"so_22902314_22904584_1": {"section_id": 3779, "quality": 0.875, "length": 7}, "so_22902314_22904584_0": {"section_id": 3779, "quality": 1.0, "length": 30}}, "n4659": {"so_22902314_22904584_1": {"section_id": 4805, "quality": 0.875, "length": 7}, "so_22902314_22904584_0": {"section_id": 4805, "quality": 0.9333333333333333, "length": 28}}}});