post_cb({"26949099": {"ParentId": "26947704", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The indirect initialization syntax with a <em>braced-init-list</em> your code is using is called <em>copy-list-initialization</em>.</p>\n<p>The overload resolution procedure selecting the best viable constructor for that case is described in the following section of the C++ Standard:</p>\n<blockquote>\n<h3>\u00a7 13.3.1.7 Initialization by list-initialization <code>[over.match.list]</code></h3>\n<ol>\n<li><p id=\"so_26947704_26949099_0\">When objects of non-aggregate class type <code>T</code> are list-initialized (8.5.4), overload resolution selects the constructor\n  in two phases:</p>\n<p id=\"so_26947704_26949099_1\">\u2014 Initially, the candidate functions are the initializer-list constructors (8.5.4) of the class <code>T</code> and the argument list consists of the initializer list as a single argument.</p>\n<p id=\"so_26947704_26949099_2\">\u2014 If no viable initializer-list constructor is found, overload resolution is performed again, where the candidate functions are all the constructors of the class <code>T</code> and the argument list consists of the elements of the initializer list.</p></li>\n</ol>\n<p id=\"so_26947704_26949099_3\">If the initializer list has no elements and <code>T</code> has a default constructor, the first phase is omitted. In copy-list-initialization, if an explicit constructor is chosen, the initialization is ill-formed. [ <em>Note:</em> This differs from other situations (13.3.1.3, 13.3.1.4), where only converting constructors are considered for copy-initialization. This restriction only applies if this initialization is part of the final result of overload resolution. <em>\u2014 end note</em> ].</p>\n</blockquote>\n<p>According to that, an <em>initializer-list-constructor</em> (the one callable with a single argument matching the constructor's parameter of type <code>std::initializer_list&lt;T&gt;</code>) is usually preferred to other constructors, <strong>but not if a default-constructor is available</strong>, and the <em>braced-init-list</em> used for <em>list-initialization</em> <strong>is empty</strong>.</p>\n<p>What is important here, the set of constructors of the standard library's containers has changed between C++11 and C++14 due to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2193\" rel=\"noreferrer\"><strong>LWG issue 2193</strong></a>. In case of <code>std::unordered_map</code>, for the sake of our analysis, we are interested in the following difference:</p>\n<p><em>C++11:</em></p>\n<pre><code>explicit unordered_map(size_type n = /* impl-defined */,\n                     const hasher&amp; hf = hasher(),\n                     const key_equal&amp; eql = key_equal(),\n                     const allocator_type&amp; alloc = allocator_type());\n\nunordered_map(initializer_list&lt;value_type&gt; il,\n            size_type n = /* impl-defined */,\n            const hasher&amp; hf = hasher(),\n            const key_equal&amp; eql = key_equal(),\n            const allocator_type&amp; alloc = allocator_type());\n</code></pre>\n<p><em>C++14:</em></p>\n<pre><code>unordered_map();\n\nexplicit unordered_map(size_type n,\n                     const hasher&amp; hf = hasher(),\n                     const key_equal&amp; eql = key_equal(),\n                     const allocator_type&amp; alloc = allocator_type());\n\nunordered_map(initializer_list&lt;value_type&gt; il,\n            size_type n = /* impl-defined */,\n            const hasher&amp; hf = hasher(),\n            const key_equal&amp; eql = key_equal(),\n            const allocator_type&amp; alloc = allocator_type());\n</code></pre>\n<p>In other words, there is a different <em>default constructor</em> (the one that can be called without arguments) depending on the language standard (C++11/C++14), and, what is crucial, the default constructor in C++14 is now made non-<code>explicit</code>.</p>\n<p>That change was introduced so that one can say:</p>\n<pre><code>std::unordered_map&lt;int,int&gt; m = {};\n</code></pre>\n<p>or:</p>\n<pre><code>std::unordered_map&lt;int,int&gt; foo()\n{\n    return {};\n}\n</code></pre>\n<p>which are both semantically equivalent to your code (passing <code>{}</code> as the argument of a function call to initialize <code>std::unordered_map&lt;int,int&gt;</code>). </p>\n<p>That is, in case of a C++11-conforming library, the error is <strong>expected</strong>, as the selected (default) constructor is <code>explicit</code>, therefore the code is <em>ill-formed</em>:</p>\n<pre><code>explicit unordered_map(size_type n = /* impl-defined */,\n                     const hasher&amp; hf = hasher(),\n                     const key_equal&amp; eql = key_equal(),\n                     const allocator_type&amp; alloc = allocator_type());\n</code></pre>\n<p>In case of a C++14-conforming library, the error is <strong>not expected</strong>, as the selected (default) constructor is <strong>not</strong> <code>explicit</code>, and the code is <em>well-formed</em>:</p>\n<pre><code>unordered_map();\n</code></pre>\n<p>As such, the different behavior you encounter is solely related to the version of libstdc++ and libc++ you are using with different compilers/compiler options.</p>\n<hr>\n<blockquote>\n<p id=\"so_26947704_26949099_4\"><em>Replacing <code>std::unordered_map</code> with <code>std::map</code> makes the error go away. Why?</em></p>\n</blockquote>\n<p>I suspect it's just because <code>std::map</code> in the libstdc++ version you are using was already updated for C++14.</p>\n<hr>\n<blockquote>\n<p id=\"so_26947704_26949099_5\"><em>Replacing <code>foo({})</code> with <code>foo({{}})</code> also makes the error go away. Why?</em></p>\n</blockquote>\n<p>Because now this is <em>copy-list-initialization</em> <code>{{}}</code> with a <strong>non-empty</strong> <em>braced-init-list</em> (that is, it has one element inside, initialized with an empty <em>braced-init-list</em> <code>{}</code>), so the rule from the first phase of \u00a7 13.3.1.7 [over.match.list]/p1 (quoted before) that prefers an <em>initializer-list-constructor</em> to other ones is applied. That constructor is not <code>explicit</code>, hence the call is <em>well-formed</em>.</p>\n<hr>\n<blockquote>\n<p id=\"so_26947704_26949099_6\"><em>Replacing <code>{}</code> with a non-empty initializer list works as expected in all cases. Why?</em></p>\n</blockquote>\n<p>Same as above, the overload resolution ends up with the first phase of \u00a7 13.3.1.7 [over.match.list]/p1.</p>\n</hr></hr></hr>", "OwnerUserId": "3953764", "LastEditorUserId": "3953764", "LastEditDate": "2015-08-13T22:01:46.730", "Id": "26949099", "Score": "27", "CreationDate": "2014-11-15T18:16:37.220", "LastActivityDate": "2015-08-13T22:01:46.730"}, "26949366": {"ParentId": "26947704", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>List-initialization for references is defined as follows, [dcl.init.list]/3:</p>\n<blockquote>\n<p id=\"so_26947704_26949366_0\">Otherwise, if <code>T</code> is a reference type, a prvalue temporary of the type\n  referenced by <code>T</code> is copy-list-initialized or direct-list-initialized,\n  depending on the kind of initialization for the reference, and the\n  reference is bound to that temporary.</p>\n</blockquote>\n<p>So your code fails because</p>\n<pre><code>std::unordered_map&lt;int,int&gt; m = {};\n</code></pre>\n<p>fails. List-initialization for this case is covered through this bullet from [dcl.init.list]/3:</p>\n<blockquote>\n<p id=\"so_26947704_26949366_1\">Otherwise, if the initializer list has no elements and <code>T</code> is a class\n  type with a default constructor, the object is value-initialized.</p>\n</blockquote>\n<p>So the object's default constructor will be called<sup>1</sup>.<br>\nNow to the crucial bits:\nIn C++11, <code>unordered_map</code> had this default constructor<sup>2</sup>:</br></p>\n<pre><code>explicit unordered_map(size_type n = /* some value */ ,\n                       const hasher&amp; hf = hasher(),\n                       const key_equal&amp; eql = key_equal(),\n                       const allocator_type&amp; a = allocator_type());\n</code></pre>\n<p>Clearly, calling this <code>explicit</code> constructor through copy-list-initialization is ill-formed, [over.match.list]:</p>\n<blockquote>\n<p id=\"so_26947704_26949366_2\">In copy-list-initialization, if an <code>explicit</code> constructor is chosen, the initialization is ill-formed.</p>\n</blockquote>\n<p>Since C++14 <code>unordered_map</code> declares a default constructor that is non-explicit:</p>\n<pre><code>unordered_map();\n</code></pre>\n<p>So a C++14 standard library implementation should compile this without problems. Presumably libc++ is already updated, but libstdc++ is lagging behind.</p>\n<p><hr>\n<sup>1)</sup> [dcl.init]/7:</hr></p>\n<blockquote>\n<p id=\"so_26947704_26949366_3\">To <em>value-initialize</em> an object of type <code>T</code> means:<br> \u2014 if <code>T</code> is a\n  (possibly cv-qualified) class type (Clause 9) with a user-provided\n  constructor (12.1), then the default constructor for <code>T</code> is called\n  [\u2026];</br></p>\n</blockquote>\n<p><sup>2)</sup> [class.ctor]/4:</p>\n<blockquote>\n<p id=\"so_26947704_26949366_4\">A default constructor for a class <code>X</code> is a constructor of class <code>X</code> that can be called without an argument.</p>\n</blockquote>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2014-11-15T18:51:08.250", "Id": "26949366", "Score": "3", "CreationDate": "2014-11-15T18:42:58.550", "LastActivityDate": "2014-11-15T18:51:08.250"}, "bq_ids": {"n4140": {"so_26947704_26949366_2": {"section_id": 599, "quality": 1.0, "length": 6}, "so_26947704_26949099_3": {"section_id": 599, "quality": 0.8055555555555556, "length": 29}, "so_26947704_26949099_1": {"section_id": 599, "quality": 0.9285714285714286, "length": 13}, "so_26947704_26949366_0": {"section_id": 3325, "quality": 1.0, "length": 16}, "so_26947704_26949099_0": {"section_id": 599, "quality": 0.9230769230769231, "length": 12}, "so_26947704_26949099_2": {"section_id": 599, "quality": 1.0, "length": 20}, "so_26947704_26949366_1": {"section_id": 3325, "quality": 1.0, "length": 10}, "so_26947704_26949366_4": {"section_id": 369, "quality": 0.875, "length": 7}, "so_26947704_26949366_3": {"section_id": 3287, "quality": 0.8125, "length": 13}}, "n3337": {"so_26947704_26949366_2": {"section_id": 589, "quality": 1.0, "length": 6}, "so_26947704_26949099_3": {"section_id": 589, "quality": 0.8055555555555556, "length": 29}, "so_26947704_26949099_1": {"section_id": 589, "quality": 0.9285714285714286, "length": 13}, "so_26947704_26949366_1": {"section_id": 3195, "quality": 0.9, "length": 9}, "so_26947704_26949366_0": {"section_id": 3195, "quality": 0.625, "length": 10}, "so_26947704_26949099_2": {"section_id": 589, "quality": 1.0, "length": 20}, "so_26947704_26949099_0": {"section_id": 589, "quality": 0.9230769230769231, "length": 12}, "so_26947704_26949366_4": {"section_id": 359, "quality": 0.875, "length": 7}, "so_26947704_26949366_3": {"section_id": 3157, "quality": 0.9375, "length": 15}}, "n4659": {"so_26947704_26949366_0": {"section_id": 4091, "quality": 0.6875, "length": 11}, "so_26947704_26949099_3": {"section_id": 622, "quality": 0.8055555555555556, "length": 29}, "so_26947704_26949099_1": {"section_id": 622, "quality": 0.9285714285714286, "length": 13}, "so_26947704_26949366_1": {"section_id": 4091, "quality": 1.0, "length": 10}, "so_26947704_26949366_2": {"section_id": 622, "quality": 1.0, "length": 6}, "so_26947704_26949099_2": {"section_id": 622, "quality": 1.0, "length": 20}, "so_26947704_26949099_0": {"section_id": 622, "quality": 0.9230769230769231, "length": 12}, "so_26947704_26949366_4": {"section_id": 4058, "quality": 0.75, "length": 6}, "so_26947704_26949366_3": {"section_id": 4049, "quality": 0.75, "length": 12}}}, "26947704": {"CommentCount": "0", "CreationDate": "2014-11-15T15:59:45.957", "PostTypeId": "1", "AcceptedAnswerId": "26949099", "LastEditorUserId": "453925", "LastActivityDate": "2015-08-13T22:01:46.730", "LastEditDate": "2014-11-15T16:05:29.070", "ViewCount": "7299", "FavoriteCount": "8", "Title": "Implicit conversion failure from initializer list", "Id": "26947704", "Score": "30", "Body": "<p>Consider the snippet:</p>\n<pre><code>#include &lt;unordered_map&gt;\n\nvoid foo(const std::unordered_map&lt;int,int&gt; &amp;) {}\n\nint main()\n{\n        foo({});\n}\n</code></pre>\n<p>This fails with GCC 4.9.2 with the message:</p>\n<pre><code>map2.cpp:7:19: error: converting to \u2018const std::unordered_map&lt;int, int&gt;\u2019 from initializer list would use explicit constructor \u2018std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::unordered_map(std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type, const hasher&amp;, const key_equal&amp;, const allocator_type&amp;) [with _Key = int; _Tp = int; _Hash = std::hash&lt;int&gt;; _Pred = std::equal_to&lt;int&gt;; _Alloc = std::allocator&lt;std::pair&lt;const int, int&gt; &gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::size_type = long unsigned int; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::hasher = std::hash&lt;int&gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::key_equal = std::equal_to&lt;int&gt;; std::unordered_map&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;::allocator_type = std::allocator&lt;std::pair&lt;const int, int&gt; &gt;]\u2019\n</code></pre>\n<p>Testing with other compiler/library implementations:</p>\n<ul>\n<li>GCC &lt; 4.9 accepts this without complaining,</li>\n<li>Clang 3.5 with libstdc++ fails with a similar message,</li>\n<li>Clang 3.5 with libc++ accepts this,</li>\n<li>ICC 15.something accepts this (not sure which standard library it is using).</li>\n</ul>\n<p>A couple of more baffling points:</p>\n<ul>\n<li>replacing <code>std::unordered_map</code> with <code>std::map</code> makes the error go away,</li>\n<li>replacing <code>foo({})</code> with foo <code>foo({{}})</code> also makes the error go away.</li>\n</ul>\n<p>Also, replacing <code>{}</code> with a non-empty initializer list works as expected in all cases.</p>\n<p>So my main questions are:</p>\n<ul>\n<li>who is right here? Is the code above well-formed?</li>\n<li>What does the syntax with double curly braces <code>foo({{}})</code> exactly do to make the error go away?</li>\n</ul>\n<p><strong>EDIT</strong> fixed a couple of typos.</p>\n", "Tags": "<c++><c++11><gcc><libstdc++>", "OwnerUserId": "453925", "AnswerCount": "2"}});