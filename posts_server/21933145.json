post_cb({"21933581": {"ParentId": "21933145", "CommentCount": "3", "Body": "<p>Whatever you define it to be.  At the least, the resulting\nobject should be destructable\u2014its destructor will be\ncalled, and the state of the object should be such that that\ncauses no problems.  </p>\n<p>The standard library guarantees that its objects are some\ncoherent state.  You can call any of the member functions: it is\nunspecified what you get in return, <em>but</em> the results will be\ncoherent: if you call <code>size</code> on a vector which has been moved,\nyou can also call <code>operator[]</code> with an index less than the value\nreturned by <code>size</code> (but in the only reasonable implementation,\n<code>size</code> will return 0,).  This is probably more than what is\nneeded for effective use, however; all that is really necessary\nis that calling the destructor will work. </p>\n<p>To make it clearer, using <code>std::vector</code> as an example: if we\nsuppose the usual implementation, with three pointers, begin,\nend and limit (or however they are called: limit is meant to be\none past the end of the allocated memory, so that <code>capacity()</code>\nreturns <code>limit - begin</code>).  After moving, the standard would\nrequire that all three pointers be null.  In most\nimplementations, the limit pointer will not be accessed in the\ndestructor, so the looser requirements of being deletable would\nbe met if only the begin and end pointers were set to null.</p>\n", "OwnerUserId": "649665", "PostTypeId": "2", "Id": "21933581", "Score": "3", "CreationDate": "2014-02-21T11:44:54.903", "LastActivityDate": "2014-02-21T11:44:54.903"}, "21933256": {"ParentId": "21933145", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>With regards to library types, the standard says (17.6.5.15)</p>\n<blockquote>\n<p id=\"so_21933145_21933256_0\">Unless otherwise specified, such moved-from objects shall be placed in a valid but unspecified state.</p>\n</blockquote>\n<p>This means they should, at a minimum, be destructible and assignable. As James mentions below, the object should still comply with its own interface. Your own types should follow the same idea.</p>\n<p>You should not be using placement-new for this sort of thing. Pretend the move constructor doesn't exist and write code the same way as before, using operator=. The last line in your example should be <code>x=std::move(u);</code> or <code>x=u;</code>.</p>\n", "OwnerUserId": "458742", "LastEditorUserId": "458742", "LastEditDate": "2014-02-21T13:03:32.880", "Id": "21933256", "Score": "2", "CreationDate": "2014-02-21T11:30:58.523", "LastActivityDate": "2014-02-21T13:03:32.880"}, "bq_ids": {"n4140": {"so_21933145_21933256_0": {"section_id": 6365, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_21933145_21933256_0": {"section_id": 6122, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_21933145_21933256_0": {"section_id": 7876, "quality": 0.9090909090909091, "length": 10}}}, "21933145": {"CommentCount": "0", "ViewCount": "102", "ClosedDate": "2014-02-21T12:08:20.033", "CreationDate": "2014-02-21T11:26:39.350", "LastActivityDate": "2014-02-21T13:03:32.880", "Title": "What are the operations supported after an object is moved?", "PostTypeId": "1", "Id": "21933145", "Score": "0", "Body": "<p>If an object is actually moved to another location, what are the operations supported on the original object?</p>\n<p>To elaborate it, I have a type <code>T</code> with available move constructor. With the following statements</p>\n<pre><code>T x{constructor-args};\nT y{std::move(x)};\n</code></pre>\n<p>what all can be done with the object <code>x</code> (provided that the object actually moves from <code>x</code> to <code>y</code> using available move constructor of <code>T</code>)?</p>\n<p>Specifically,</p>\n<ul>\n<li><code>x</code> can be destroyed for sure. Can I assume <code>x</code> is trivially destructible after move?</li>\n<li>can <code>x</code> be assigned or move assigned to a new object ( I guess yes, as I have seen many <code>swap</code> uses this)? </li>\n<li><p>can I construct a new object object in place of <code>x</code>? If by any chance this is allowed, then is it possible to have a <code>uninitialized_move</code> which works with (partially) overlapped source &amp; destination range, like <code>std::copy</code> and unlike <code>std::uninitialized_copy</code> ? </p>\n<pre><code>T z{some-args};\nx = z; //or x = std::move(z);\nT u{some-args};\nnew(&amp;x) T{std::move(u)}; // or new(&amp;x) T{u}; etc\n</code></pre></li>\n</ul>\n", "Tags": "<c++><c++11><move-semantics>", "OwnerUserId": "60515", "AnswerCount": "2"}});