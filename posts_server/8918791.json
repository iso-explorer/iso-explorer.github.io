post_cb({"8919369": {"Id": "8919369", "PostTypeId": "2", "Body": "<p>It's probably easier to understand if you imagine constructing <i>several</i> MyClass objects within <i>one</i> block of memory.</p>\n<p>In that case, it would go something like:</p>\n<ol>\n<li>Allocate a giant block of memory using new char[10*sizeof(MyClass)] or malloc(10*sizeof(MyClass))</li>\n<li>Use placement new to construct ten MyClass objects within that memory.</li>\n<li>Do something.</li>\n<li>Call the destructor of each of your objects</li>\n<li>Deallocate the big block of memory using delete[] or free().</li>\n</ol>\n<p>This is the sort of thing you might do if you're <i>writing</i> a compiler, or an OS, etc.</p>\n<p>In this case, I hope it's clear why you need separate \"destructor\" and \"delete\" steps, because there's no reason you <em>will</em> call delete. However, you <em>should</em> deallocate the memory however you would normally do it (free, delete, do nothing for a giant static array, exit normally if the array is part of another object, etc, etc), and if you don't it'll be leaked.</p>\n<p>Also note as Greg said, in this case, you can't use delete, because you allocated the array with new[] so you'd need to use delete[].</p>\n<p>Also note that you need to assume you haven't overridden delete for MyClass, else it will do something totally different which is almost certainly incompatible with \"new\".</p>\n<p>So I think you're unlikley to want to call \"delete\" as you describe, but could it ever work? I think this is basically the same question as \"I have two unrelated types that don't have destructors. Can I new a pointer to one type, then delete that memory through a pointer to another type?\" In other words, \"does my compiler have one big list of all allocated stuff, or can it do different things for different types\".</p>\n<p>I'm afraid I'm not sure. Reading the spec it says:</p>\n<blockquote>\n<p id=\"so_8918791_8919369_0\">5.3.5 ... If the static type of the operand [of the delete operator] is different from its dynamic type, the static type shall be a base\n  class of the operand's dynamic type and the static type shall have a\n  virtual destructor or the behaviour is undefined.</p>\n</blockquote>\n<p>I think that means \"If you use two unrelated types, it doesn't work (it's ok to delete a class object polymorphically through a virtual destructor).\"</p>\n<p>So no, don't do that. I suspect it may often work in practice, if the compiler does look solely at the address and not the type (and neither type is a multiple-inheritance class, which would mangle the address), but don't try it.</p>\n", "LastActivityDate": "2012-01-19T00:06:03.703", "Score": "3", "CreationDate": "2012-01-19T00:06:03.703", "ParentId": "8918791", "CommentCount": "0", "OwnerUserId": "138170"}, "8918791": {"ViewCount": "4831", "Body": "<p>I've been reading somewere that when you use <strong>placement new</strong> then you have to call the destructor manually.</p>\n<p>Consider the folowing code:</p>\n<pre><code>   // Allocate memory ourself\nchar* pMemory = new char[ sizeof(MyClass)];\n\n// Construct the object ourself\nMyClass* pMyClass = new( pMemory ) MyClass();\n\n// The destruction of object is our duty.\npMyClass-&gt;~MyClass();\n</code></pre>\n<p>As far as I know operator <code>delete</code> normally calls the destructor and then deallocates the memory, right? So why don't we use <code>delete</code> instead?</p>\n<pre><code>delete pMyClass;  //what's wrong with that?\n</code></pre>\n<p>in the first case we are forced to set pMyClass to <code>nullptr</code> after we call destructor like this:</p>\n<pre><code>pMyClass-&gt;~MyClass();\npMyClass = nullptr;  // is that correct?\n</code></pre>\n<p><strong>BUT the destructor did NOT deallocate memory, right?</strong>\nSo would that be a memory leak?</p>\n<p>I'm confused, can you explain that?</p>\n", "AcceptedAnswerId": "8918942", "Title": "How to properly free the memory allocated by placement new?", "CreationDate": "2012-01-18T23:01:36.707", "Id": "8918791", "CommentCount": "3", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2012-01-18T23:20:24.160", "LastEditorUserId": "827263", "LastActivityDate": "2017-06-23T21:21:04.050", "Score": "19", "OwnerUserId": "1044776", "Tags": "<c++><placement-new>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_8918791_8919369_0": {"length": 18, "quality": 0.75, "section_id": 6107}}, "n3337": {"so_8918791_8919369_0": {"length": 18, "quality": 0.75, "section_id": 5873}}, "n4659": {"so_8918791_8919369_0": {"length": 18, "quality": 0.75, "section_id": 7604}}}, "8918824": {"Id": "8918824", "PostTypeId": "2", "Body": "<p>One reason this is wrong:</p>\n<pre><code>delete pMyClass;\n</code></pre>\n<p>is that you must delete <code>pMemory</code> with <code>delete[]</code> since it is an array:</p>\n<pre><code>delete[] pMemory;\n</code></pre>\n<p>You can't do both of the above.</p>\n<p>Similarly, you might ask why you can't use <code>malloc()</code> to allocate memory, placement new to construct an object, and then <code>delete</code> to delete and free the memory. The reason is that you must match <code>malloc()</code> and <code>free()</code>, not <code>malloc()</code> and <code>delete</code>.</p>\n<p>In the real world, placement new and explicit destructor calls are almost never used. They might be used internally by the Standard Library implementation (or for other systems-level programming as noted in the comments), but normal programmers don't use them. I have never used such tricks for production code in many years of doing C++.</p>\n", "LastEditorUserId": "893", "LastActivityDate": "2012-01-18T23:16:14.360", "Score": "8", "CreationDate": "2012-01-18T23:04:03.677", "ParentId": "8918791", "CommentCount": "4", "LastEditDate": "2012-01-18T23:16:14.360", "OwnerUserId": "893"}, "8919169": {"Id": "8919169", "PostTypeId": "2", "Body": "<p>You need to distinguish between the <code>delete</code> operator and <code>operator delete</code>. In particular, if you're using placement new, you explicitly invoke the destructor and then call <code>operator delete</code> (and not the <code>delete</code> operator) to release the memory, i.e.</p>\n<pre><code>X *x = static_cast&lt;X*&gt;(::operator new(sizeof(X)));\nnew(x) X;\nx-&gt;~X();\n::operator delete(x);\n</code></pre>\n<p>Note that this uses <code>operator delete</code>, which is lower-level than the <code>delete</code> operator and doesn't worry about destructors (it's essentially a bit like <code>free</code>). Compare this to the <code>delete</code> operator, which internally does the equivalent of invoking the destructor and calling <code>operator delete</code>.</p>\n<p>It's worth noting that you don't have to use <code>::operator new</code> and <code>::operator delete</code> to allocate and deallocate your buffer - as far as placement new is concerned, it doesn't matter how the buffer comes into being / gets destroyed. The main point is to separate the concerns of memory allocation and object lifetime.</p>\n<p>Incidentally, a possible application of this would be in something like a game, where you might want to allocate a large block of memory up-front in order to carefully manage your memory usage. You'd then construct objects in the memory you've already acquired.</p>\n<p>Another possible use would be in an optimized small, fixed-size object allocator.</p>\n", "LastEditorUserId": "499449", "LastActivityDate": "2012-01-18T23:54:25.990", "Score": "4", "CreationDate": "2012-01-18T23:38:27.933", "ParentId": "8918791", "CommentCount": "1", "LastEditDate": "2012-01-18T23:54:25.990", "OwnerUserId": "499449"}, "8918942": {"Id": "8918942", "PostTypeId": "2", "Body": "<p>Using the <code>new</code> operator does two things, it calls the function <code>operator new</code> which allocates memory, and then it uses placement new, to create the object in that memory.  The <code>delete</code> operator calls the object's destructor, and then calls <code>operator delete</code>.  Yeah, the names are confusing.</p>\n<pre><code>//normal version                   calls these two functions\nMyClass* pMemory = new MyClass;    void* pMemory = operator new(sizeof(MyClass));\n                                   MyClass* pMyClass = new( pMemory ) MyClass();\n//normal version                   calls these two functions\ndelete pMemory;                    pMyClass-&gt;~MyClass();\n                                   operator delete(pMemory);\n</code></pre>\n<p>Since in your case, you used placement new manually, you also need to call the destructor manually.  Since you allocated the memory manually, you need to release it manually.  Remember, if you allocate with <code>new</code>, there must be a coressponding <code>delete</code>. Always.</p>\n<p>However, placement new is designed to work with internal buffers as well (and other scenarios), where the buffers were <em>not</em> allocated with <code>operator new</code>, which is why you shouldn't call <code>operator delete</code> on them.</p>\n<pre><code>#include &lt;type_traits&gt;\n\nstruct buffer_struct {\n    std::aligned_storage&lt;sizeof(MyClass)&gt;::type buffer;\n};\nint main() {\n    buffer_struct a;\n    MyClass* pMyClass = new (&amp;a.buffer) MyClass(); //created inside buffer_struct a\n    //stuff\n    pMyClass-&gt;~MyClass(); //can't use delete, because there's no `new`.\n    return 0;\n}\n</code></pre>\n<p>The purpose of the <code>buffer_struct</code> class is to create and destroy the storage in whatever way, while <code>main</code> takes care of the construction/destruction of <code>MyClass</code>, note how the two are (almost*) completely separate from each other.</p>\n<p><sub>*we have to be sure the storage has to be big enough</sub></p>\n", "LastEditorUserId": "845092", "LastActivityDate": "2017-06-23T21:21:04.050", "Score": "32", "CreationDate": "2012-01-18T23:15:51.630", "ParentId": "8918791", "CommentCount": "7", "LastEditDate": "2017-06-23T21:21:04.050", "OwnerUserId": "845092"}});