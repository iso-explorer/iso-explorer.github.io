post_cb({"213394": {"Body": "<p><code>const</code> helps compilers optimize mainly because it makes you write optimizable code. Unless you throw in <code>const_cast</code>.</p>\n", "CreationDate": "2008-10-17T18:51:09.803", "ParentId": "212237", "CommentCount": "1", "LastEditDate": "2012-07-03T13:26:19.077", "PostTypeId": "2", "OwnerDisplayName": "MSN", "LastEditorUserId": "142162", "LastActivityDate": "2012-07-03T13:26:19.077", "Id": "213394", "Score": "-1", "OwnerUserId": "6210"}, "389983": {"Body": "<p>Those are all true answers, but the answers and the question seem to presume one thing: that compiler optimization actually matters.</p>\n<p>There is only one kind of code where compiler optimization matters, that is in code that is</p>\n<ul>\n<li>a tight inner loop,</li>\n<li>in code that you compile, as opposed to a 3rd-party library,</li>\n<li>not containing function or method calls (even hidden ones),</li>\n<li>where the program counter spends a noticeable fraction of its time</li>\n</ul>\n<p>If the other 99% of the code is optimized to the Nth degree, it won't make a hoot of difference, because it only matters in code where the program counter actually spends time (which you can find by sampling).</p>\n", "CreationDate": "2008-12-23T20:23:00.677", "ParentId": "212237", "CommentCount": "0", "LastEditDate": "2008-12-23T20:33:52.357", "PostTypeId": "2", "LastEditorDisplayName": "Mike Dunlavey", "LastActivityDate": "2008-12-23T20:33:52.357", "LastEditorUserId": "23771", "Id": "389983", "OwnerDisplayName": "Mike Dunlavey", "Score": "2", "OwnerUserId": "23771"}, "212237": {"ViewCount": "17985", "Body": "<p>I've read all the advice on const-correctness in C++ and that it is important (in part) because it helps the compiler to optimize your code. What I've never seen is a good explanation on how the compiler uses this information to optimize the code, not even the good books go on explaining what happens behind the curtains.  </p>\n<p>For example, how does the compiler optimize a method that is declared const vs one that isn't but should be. What happens when you introduce mutable variables? Do they affect these optimizations of const methods?</p>\n", "AcceptedAnswerId": "212693", "Title": "Constants and compiler optimization in C++", "CreationDate": "2008-10-17T13:56:35.997", "Id": "212237", "CommentCount": "0", "FavoriteCount": "21", "PostTypeId": "1", "LastEditDate": "2008-10-17T14:03:15.330", "LastEditorDisplayName": "David Holm", "OwnerDisplayName": "David Holm", "LastEditorUserId": "22247", "LastActivityDate": "2012-07-03T14:33:51.300", "Score": "48", "OwnerUserId": "22247", "Tags": "<c++><optimization><compiler-construction>", "AnswerCount": "12"}, "bq_ids": {"n4140": {"so_212237_212693_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5433}}, "n3337": {"so_212237_212693_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5228}}, "n4659": {"so_212237_212693_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 6861}}}, "212269": {"Id": "212269", "PostTypeId": "2", "Body": "<p><em>handwaving begins</em></p>\n<p>Essentially, the earlier the data is fixed, the more the compiler can move around the actual assignment of the data, ensuring that the pipeline doesn't stall out</p>\n<p><em>end handwaving</em></p>\n", "OwnerDisplayName": "Vlion", "LastActivityDate": "2008-10-17T14:03:08.527", "Score": "6", "CreationDate": "2008-10-17T14:03:08.527", "ParentId": "212237", "CommentCount": "0", "OwnerUserId": "26227"}, "212517": {"Id": "212517", "PostTypeId": "2", "Body": "<p>The most obvious point where <code>const</code> is a direct optimization is in passing arguments to a function. It's often important to ensure that the function doesn't modify the data so the only real choices for the function signature are these:</p>\n<pre><code>void f(Type dont_modify); // or\nvoid f(Type const&amp; dont_modify);\n</code></pre>\n<p>Of course, the real magic here is passing a reference rather than creating an (expensive) copy of the object. But if the reference weren't marked as <code>const</code>, this would weaken the semantics of this function and have negative effects (such as making error-tracking harder). Therefore, <code>const</code> enables an optimization here.</p>\n<p>/EDIT: actually, a good compiler can analyze the control flow of the function, determine that it doesn't modify the argument and make the optimization (passing a reference rather than a copy) itself. <code>const</code> here is merely a help for the compiler. However, since C++ has some pretty complicated semantics and such control flow analysis can be very expensive for big functions, we probably shouldn't rely on compilers for this. Does anybody have any data to back me up / prove me wrong?</p>\n<p>/EDIT2: and yes, as soon as custom copy constructors come into play, it gets even trickier because compilers unfortunately aren't allowed to omit calling them in this situation.</p>\n", "OwnerDisplayName": "Konrad Rudolph", "LastActivityDate": "2008-10-17T14:58:08.057", "Score": "0", "CreationDate": "2008-10-17T14:58:08.057", "ParentId": "212237", "CommentCount": "1", "OwnerUserId": "1968"}, "212329": {"Id": "212329", "PostTypeId": "2", "Body": "<p>I would be surprised if the optimizer actually puts much stock into a const declaration.  There is a lot of code that will end up casting const-ness away, it would be a very reckless optimizer that relied on the programmer declaration to assume when the state may change.</p>\n", "OwnerDisplayName": "Rob Walker", "LastActivityDate": "2008-10-17T14:15:28.363", "Score": "1", "CreationDate": "2008-10-17T14:15:28.363", "ParentId": "212237", "CommentCount": "4", "OwnerUserId": "3631"}, "212384": {"Id": "212384", "PostTypeId": "2", "Body": "<p>I think that the const keyword was primarily introduced for compilation checking of the program semantic, not for optimization.</p>\n<p>Herb Sutter, in the <a href=\"http://www.gotw.ca/gotw/081.htm\" rel=\"noreferrer\">GotW #81 article</a>, explains very well why the compiler can't optimize anything when passing parameters by const reference, or when declaring const return value. The reason is that the compiler has no way to be sure that the object referenced won't be changed, even if declared const : one could use a const_cast, or some other code can have a non-const reference on the same object.</p>\n<p>However, quoting Herb Sutter's article : </p>\n<blockquote>\n<p id=\"so_212237_212384_0\">There is [only] one case where saying\n  \"const\" can really mean something, and\n  that is when objects are made const at\n  the point they are defined. In that\n  case, the compiler can often\n  successfully put such \"really const\"\n  objects into read-only memory[...].</p>\n</blockquote>\n<p>There is a lot more in this article, so I encourage you reading it: you'll have a better understanding of constant optimization after that.</p>\n", "OwnerDisplayName": "Luc Touraille", "LastActivityDate": "2008-10-17T14:30:37.427", "Score": "54", "CreationDate": "2008-10-17T14:30:37.427", "ParentId": "212237", "CommentCount": "0", "OwnerUserId": "20984"}, "212612": {"Body": "<p>This code,</p>\n<pre><code>class Test\n{\npublic:\n  Test (int value) : m_value (value)\n  {\n  }\n\n  void SetValue (int value) const\n  {\n    const_cast &lt;Test&amp;&gt;(*this).MySetValue (value);\n  }\n\n  int Value () const\n  {\n    return m_value;\n  }\n\nprivate:\n  void MySetValue (int value)\n  {\n    m_value = value;\n  }\n\n  int\n    m_value;\n};\n\nvoid modify (const Test &amp;test, int value) \n{\n  test.SetValue (value);\n}\n\nvoid main ()\n{\n  const Test\n    test (100);\n\n  cout &lt;&lt; test.Value () &lt;&lt; endl;\n  modify (test, 50);\n  cout &lt;&lt; test.Value () &lt;&lt; endl;\n}\n</code></pre>\n<p>outputs:</p>\n<pre><code>100\n50\n</code></pre>\n<p>which means the const declared object has been altered in a const member function. The presence of const_cast (and the mutable keyword) in the C++ language means that the const keyword can't aide the compiler in generating optimised code. And as I pointed out in my previous posts, it can even produce unexpected results.</p>\n<p>As a general rule:</p>\n<blockquote>\n<p id=\"so_212237_212612_0\">const != optimisation</p>\n</blockquote>\n<p>In fact, this is a legal C++ modifier:</p>\n<pre><code>volatile const\n</code></pre>\n", "CreationDate": "2008-10-17T15:17:55.367", "ParentId": "212237", "CommentCount": "2", "LastEditDate": "2012-07-03T14:33:51.300", "PostTypeId": "2", "OwnerDisplayName": "Skizz", "LastEditorUserId": "142162", "LastActivityDate": "2012-07-03T14:33:51.300", "Id": "212612", "Score": "0", "OwnerUserId": "1898"}, "212304": {"Id": "212304", "PostTypeId": "2", "Body": "<p>It does not optimize the function that is declared const.</p>\n<p>It can optimize functions that <em>call</em> the function that is declared const.</p>\n<pre><code>void someType::somefunc();\n\nvoid MyFunc()\n{\n    someType A(4);   // \n    Fling(A.m_val);\n    A.someFunc();\n    Flong(A.m_val);\n}\n</code></pre>\n<p>Here to call Fling, the valud A.m_val had to be loaded into a CPU register.  If someFunc() is not const, the value would have to be reloaded before calling Flong().  If someFunc is const, then we can call Flong with the value that's still in the register.</p>\n", "OwnerDisplayName": "James Curran", "LastActivityDate": "2008-10-17T14:11:02.833", "Score": "3", "CreationDate": "2008-10-17T14:11:02.833", "ParentId": "212237", "CommentCount": "8", "OwnerUserId": "12725"}, "212320": {"Id": "212320", "PostTypeId": "2", "Body": "<p>The main reason for having <strong>methods</strong> as const is for const correctness, not for possible compilation optimization of the method itself.</p>\n<p>If <strong>variables</strong> are const they can (in theory) be optimized away. But only is the scope can be seen by the compiler. After all the compiler must allow for them to be modified with a const_cast elsewhere.</p>\n", "OwnerDisplayName": "Andrew Stein", "LastActivityDate": "2008-10-17T14:13:46.713", "Score": "3", "CreationDate": "2008-10-17T14:13:46.713", "ParentId": "212237", "CommentCount": "0", "OwnerUserId": "13029"}, "212693": {"Id": "212693", "PostTypeId": "2", "Body": "<p>Let's disregard methods and look only at const objects; the compiler has much more opportunity for optimization here.  If an object is declared const, then (ISO/IEC 14882:2003 7.1.5.1(4)):</p>\n<blockquote>\n<p id=\"so_212237_212693_0\">Except that any class member declared\n  mutable (7.1.1) can be modified, any\n  attempt to modify a const object\n  during its lifetime (3.8) results in\n  undefined behavior.</p>\n</blockquote>\n<p>Lets disregard objects that may have mutable members - the compiler is free to assume that the object will not be modified, therefore it can produce significant optimizations.  These optimizations can include things like:</p>\n<ul>\n<li>incorporating the object's value directly into the machines instruction opcodes</li>\n<li>complete elimination of code that can never be reached because the const object is used in a conditional expression that is known at compile time</li>\n<li>loop unrolling if the const object is controlling the number of iterations of a loop</li>\n</ul>\n<p>Note that this stuff applies only if the actual object is const - it does not apply to objects that are accessed through const pointers or references because those access paths can lead to objects that are not const (it's even well-defined to change objects though const pointers/references as long as the actual object is non-const and you cast away the constness of the access path to the object).</p>\n<p>In practice, I don't think there are compilers out there that perform any significant optimizations for all kinds of const objects. but for objects that are primitive types (ints, chars, etc.) I think that compilers can be quite aggressive in optimizing\nthe use of those items.</p>\n", "OwnerDisplayName": "Mike B", "LastActivityDate": "2008-10-17T15:41:05.787", "Score": "35", "CreationDate": "2008-10-17T15:41:05.787", "ParentId": "212237", "CommentCount": "10", "OwnerUserId": "12711"}, "390101": {"Id": "390101", "PostTypeId": "2", "Body": "<p>const-correctness is also useful as documentation.  If a function or parameter is listed as const, I don't need to worry about the value changing out from under my code (unless somebody else on the team is being very naughty).  I'm not sure it would be actually worth it if it wasn't built into the library, though.</p>\n", "OwnerDisplayName": "David Thornley", "LastActivityDate": "2008-12-23T21:25:25.887", "Score": "1", "CreationDate": "2008-12-23T21:25:25.887", "ParentId": "212237", "CommentCount": "0", "OwnerUserId": "14148"}, "212324": {"Id": "212324", "PostTypeId": "2", "Body": "<p>Meh. Const-correctness is more of a style / error-checking thing than an optimisation. A full-on optimising compiler will follow variable usage and can detect when a variable is effectively const or not.</p>\n<p>Added to that, the compiler cannot rely on you telling it the truth - you could be casting away the const inside a library function it doesn't know about.</p>\n<p>So yes, const-correctness is a worthy thing to aim for, but it doesn't tell the compiler anything it won't figure out for itself, assuming a good optimising compiler.</p>\n", "OwnerDisplayName": "Mike F", "LastActivityDate": "2008-10-17T14:14:56.243", "Score": "5", "CreationDate": "2008-10-17T14:14:56.243", "ParentId": "212237", "CommentCount": "0"}});