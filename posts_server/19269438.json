post_cb({"19737720": {"ParentId": "19269438", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Yes, it is true that with enough contortions you can evade the \"new\" member function syntax, but I have to ask: why would you?  The syntax fosters the understanding that the member function is somehow invoked from the surrounding object.  Given the existence of virtual functions this is actually (and must be) the case.  It also automates the this pointer changes the calling of virtual functions (and support for virtual inheritance) requires.</p>\n<p>For an illustration of how you can go about doing this look at the implementation of the FastDelegate library.  It's implementation is required to know the binary structure of your compiler's member function pointers (of which there can be several varieties).  That's the \"hack\" you're looking for.  FastDelegate's delegates (ie closures) turn into two instructions at the call point: pulling the computed 'this' value into the proper place (based on calling convention) and indirectly jumping to the actual function's entry address.</p>\n<p>This ends up looking like this:</p>\n<pre><code>fastdelegate::FastDelegate0&lt;&gt; functionObject;\nSomeClass someInstance;\n\n//fill in object and function information in function object\nfunctionObject.bind(&amp;someInstance,&amp;SomeClass::someFunction);\n\n//call function via object.  Equivalent to: someInstance-&gt;someFunction();\nfunctionObject();\n</code></pre>\n<p>This is pretty similar to what boost::bind and friends are doing, but is generally faster (though, clearly, less portable).</p>\n<p>Underneath the templates and operator overloading used here there's some math (inside the bind function) which figures out how to alter &amp;someInstance into the this pointer needed by SomeClass::someInstance.  It also finds the actual address of the underlying function and records both values for later.  When the call takes place it forces the compiler to \"do the right thing\" by some trickery using <code>-&gt;*</code>.  But, if you really wanted to avoid even relying on the <code>-&gt;*</code> operator you could, at that point, do some type casts and turn the pointer into a \"__thiscall\" function pointer (well, assuming you are on Windows):</p>\n<blockquote>\n<p id=\"so_19269438_19737720_0\">The __thiscall calling convention is used on member functions and is\n  the default calling convention used by C++ member functions that do\n  not use variable arguments. Under __thiscall, the callee cleans the\n  stack, which is impossible for vararg functions. Arguments are pushed\n  on the stack from right to left, with the this pointer being passed\n  via register ECX, and not on the stack, on the x86 architecture.</p>\n</blockquote>\n<p>So, what was it exactly you didn't like about: someInstance-&gt;someFunction()?</p>\n", "OwnerUserId": "2544218", "LastEditorUserId": "2544218", "LastEditDate": "2013-11-02T00:55:53.397", "Id": "19737720", "Score": "1", "CreationDate": "2013-11-02T00:47:36.877", "LastActivityDate": "2013-11-02T00:55:53.397"}, "19269438": {"CommentCount": "11", "ViewCount": "1862", "PostTypeId": "1", "CommunityOwnedDate": "2013-11-07T02:56:25.897", "LastEditorUserId": "1348709", "CreationDate": "2013-10-09T10:26:12.573", "LastActivityDate": "2013-11-08T02:03:15.300", "LastEditDate": "2013-11-07T02:56:25.897", "AcceptedAnswerId": "19722594", "FavoriteCount": "3", "Title": "Is there a way to call member function without .* or ->* operator", "Id": "19269438", "Score": "9", "Body": "<p>Below method of calling <code>D::foo</code> function via pointer-to-member function will generate error: <strong>must use <code>.*</code> or <code>-&gt;*</code> to call pointer-to-member function in 'f (...)'</strong>\n.. of course that is not how we call pointer-to-member functions.</p>\n<p>The correct way of calling is <code>(d.*f)(5);</code> OR <code>(p-&gt;*f)(5);</code></p>\n<p>My question is, 'Is there a way to call member function of a class without the class object on left hand side? I wonder if we could pass class object (<code>this</code>) as regular argument?</p>\n<p>In my mind, at end of the day (at assembly/binary level) all member functions of a class are normal functions which should operate on n + 1 arguments where (+1 is for <code>this</code>) </p>\n<p>If we talk about <code>D::foo</code> function below, at assembly/binary level it should operate on two arguments:</p>\n<ol>\n<li>The class object itself (pointer to class D object called <code>this</code>) </li>\n<li>and the <code>int</code>.</li>\n</ol>\n<p>so, is there a way (or hack) to call <code>D::foo</code> with class object passed to it as function argument instead of using <code>. or -&gt; or .* or -&gt;*</code> operators on class object?</p>\n<p><strong>Sample Code:</strong></p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass D {\n    public:\n        void foo ( int a ) {\n            cout &lt;&lt; \"D\" &lt;&lt; endl;\n        }\n\n        int data;\n};\n\n\n//typedef void  __cdecl ( D::*  Func)(int);\ntypedef void ( D::*  Func)(int);\n\nint main ( void ) \n{\n    D d;\n\n    Func f = &amp;D::foo;\n    f(&amp;d, 5);\n\n    return 1;\n }\n</code></pre>\n<p>One method is using boost bind i.e</p>\n<pre><code>(boost:: bind (&amp;D::foo, &amp;d, 5)) ();\n</code></pre>\n<p>EDIT:\n\"Please note I am not looking for a version of this program which works, I know how to make it work\"</p>\n", "Tags": "<c++><boost><cdecl>", "OwnerUserId": "1302312", "AnswerCount": "11"}, "19763712": {"ParentId": "19269438", "CommentCount": "0", "Body": "<p>The standard is unusually clear and utterly unambiguous on this subject. The first sentence of section 5.2.2 (C++11) states:</p>\n<blockquote>\n<p id=\"so_19269438_19763712_0\">There are two kinds of function call: ordinary function call and member function call.</p>\n</blockquote>\n<p>And that's that -- they're different things, and you can't mix them up.</p>\n", "OwnerUserId": "2797826", "PostTypeId": "2", "Id": "19763712", "Score": "0", "CreationDate": "2013-11-04T08:02:43.133", "LastActivityDate": "2013-11-04T08:02:43.133"}, "19737662": {"ParentId": "19269438", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_19269438_19737662_0\">Is there a way to call member function of a class without the class object on left hand side?</p>\n<p id=\"so_19269438_19737662_1\">...</p>\n<p id=\"so_19269438_19737662_2\">so, is there a way (or hack) to call <code>D::foo</code> with class object passed to it as function argument instead of using <code>.</code> or <code>-&gt;</code> or <code>.*</code> or <code>-&gt;*</code> operators on class object?</p>\n</blockquote>\n<p>In short, no. You cannot call a non-<code>static</code> class member function without somehow specifying the object on the left side of the call. If the class (for static functions) or the object (for non-static) is not specified, the compiler has no way of knowing which function you are trying to call. It's outside the current scope because it's inside a class or object. There are ways to \"hack\" code so you can write it to look like <code>main()</code> in your example. Some of the other answers give examples of just these kinds of hacks.</p>\n<p>------------Using static functions-----------------</p>\n<p>A function within a class <em>can</em> be called outside the class without specifying a class object. The way to do it is to create a <code>typedef</code> for a function pointer with a signature that matches the class function's, then creating such a pointer and assigning it the address of the class function. That function can then be called without needing to specify the class or an object on the left side.</p>\n<p>The function <strong>must</strong> be <code>static</code>. ISO C++ does not allow taking the address of a bound member function to form a pointer to that function, i.e. you cannot create a pointer to a non-<code>static</code> member function from a class object. You may be able to find some non-ISO standard compliant compilers, but I don't have any guidance on that for you.</p>\n<p>The parameter <code>this</code> to non-<code>static</code> class member functions is an implied parameter, and is always an implied parameter. You cannot manually specify it, but you <em>can</em> emulate it by passing a pointer to an object of the class.</p>\n<p>So, for your code example:</p>\n<ul>\n<li><code>void D::foo(int)</code> should be <code>static</code> and have an added <code>D*</code> parameter: <code>class D { static void D::foo(D*, int); };</code>.</li>\n<li><code>typedef void (D::* Func)(int);</code> should be changed to accommodate the previous change and remove <code>D::</code>: <code>typedef void (*Func)(D*, int);</code></li>\n</ul>\n", "OwnerUserId": "1736312", "LastEditorUserId": "1736312", "LastEditDate": "2013-11-07T03:51:00.783", "Id": "19737662", "Score": "0", "CreationDate": "2013-11-02T00:39:16.030", "LastActivityDate": "2013-11-07T03:51:00.783"}, "19722594": {"ParentId": "19269438", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>You really want to call a member function without using <code>.</code> or <code>-&gt;</code>? Really, <strong>really</strong>? Well, okay...</p>\n<p>Evil.h:</p>\n<pre><code>#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct MyStruct\n{\n#ifdef __cplusplus\n    MyStruct();\n\n    void method(int);\n#endif\n};\n\n#ifdef __cplusplus\n}\n#endif\n</code></pre>\n<p>Evil.cc:</p>\n<pre><code>#include &lt;iostream&gt;\n\n#include \"evil.h\"\n\nMyStruct::MyStruct() { std::cout &lt;&lt; \"This is MyStruct's constructor\" &lt;&lt; std::endl; }\n\nvoid MyStruct::method(int i) { std::cout &lt;&lt; \"You passed \" &lt;&lt; i &lt;&lt; std::endl; }\n</code></pre>\n<p>Evil.c:</p>\n<pre><code>#include \"evil.h\"\n\nint main()\n{\n    struct MyStruct my_struct;\n    _ZN8MyStructC1Ev(&amp;my_struct); /* MyStruct::MyStruct() */\n\n    _ZN8MyStruct6methodEi(&amp;my_struct, 3); /* MyStruct::method(int) */\n\n    return 0;\n}\n</code></pre>\n<p>This happens to work for my combination of gcc and g++ on Linux, but needless to say it relies on the platform ABI, and violates the C89 standard in calling functions of the form <em>underscore-capital letter</em>. It almost certainly won't work with virtual functions, and I'm not inclined to try. It may also be the most evil thing I've ever written. But still...</p>\n<hr>\n<p>EDIT: To quote the OP:</p>\n<blockquote>\n<p id=\"so_19269438_19722594_0\">In my mind, at end of the day (at assembly/binary level) all member functions of a class are normal functions which should operate on n + 1 arguments where (+1 is for <code>this</code>)</p>\n</blockquote>\n<p>While it's true that every compiler since CFront has done it this way, that's just an implementation detail. The C++ standard is at pains <strong>not</strong> to specify how member functions should implemented, just how they should behave.</p>\n<p>Because it's an implementation detail, different platforms do it in different ways. This goes beyond just name mangling. For example, the calling convention used on Linux specifies that <code>this</code> is passed as the first argument; other implementations (Borland, IIRC?) pass <code>this</code> as the <em>last</em> argument.</p>\n<p>So, if you want to treat member functions as ordinary functions with an extra <code>this</code>, then you have to restrict yourself to a particular ABI. This post serves an example of how you might do that (or rather, an example of why you really shouldn't do that!)</p>\n<blockquote>\n<p id=\"so_19269438_19722594_1\">so, is there a way (or hack) to call D::foo with class object passed to it as function argument instead of using . or -&gt; or .* or -&gt;* operators on class object?</p>\n</blockquote>\n<p>A platform-specific, disgusting dirty hack...</p>\n</hr>", "OwnerUserId": "2797826", "LastEditorUserId": "2797826", "LastEditDate": "2013-11-07T05:04:05.140", "Id": "19722594", "Score": "18", "CreationDate": "2013-11-01T07:36:15.820", "LastActivityDate": "2013-11-07T05:04:05.140"}, "19819649": {"ParentId": "19269438", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_19269438_19819649_0\">Is there a way to call member function of a class without the class object on left hand side?</p>\n</blockquote>\n<p><strong>Two ways without assembly</strong>:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass D {\n    public:\n        void foo ( int a ) {\n            cout &lt;&lt; \"D\" &lt;&lt; endl;\n        }\n\n    static void foo(D&amp; d, int a)\n    {\n        d.foo(a);\n    }\n\n        int data;\n};\n\nvoid foo(D&amp; d, int a)\n{\n    d.foo(a);\n}\n\nint main ( void ) \n{\n    D d;\n\n    D::foo(d, 5);\n    foo(d, 5);\n\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "1774680", "LastEditorUserId": "984421", "LastEditDate": "2013-11-07T19:50:09.097", "Id": "19819649", "Score": "3", "CreationDate": "2013-11-06T18:15:55.253", "LastActivityDate": "2013-11-07T19:50:09.097"}, "19827813": {"ParentId": "19269438", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2013-11-07T04:05:48.450", "OwnerUserId": "153285", "CommunityOwnedDate": "2013-11-07T04:05:48.450", "Id": "19827813", "Score": "2", "Body": "<p>Yes, there is an abstraction in the C++11 standard called <em>INVOKE</em> which applies to Callable objects. Pointer-to-member-function (PTMF) objects are Callable and <code>this</code> is passed as the first (regular) argument.</p>\n<p>There is no <code>std::invoke</code> function, although it has been proposed. To get a functor from any Callable object, you can use <code>std::bind</code>, which is a derivative of Boost.bind.</p>\n<p>This works fine:</p>\n<pre><code>int main ( void ) \n{\n    D d;\n\n    auto f = std::bind( &amp;D::foo, _1, _2 );\n    f(&amp;d, 5);\n }\n</code></pre>\n<p><a href=\"http://ideone.com/VPWV5U\" rel=\"nofollow\">http://ideone.com/VPWV5U</a></p>\n", "LastActivityDate": "2013-11-07T04:05:48.450"}, "19804288": {"ParentId": "19269438", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Here is a version of your program that works.  Pointers to class methods require a bit of convoluted invocation as shown below:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass D {\n    public:\n        void foo ( int a ) {\n            cout &lt;&lt; \"D\" &lt;&lt; endl;\n        }\n\n        int data;\n};\n\n\ntypedef void ( D::*  Func)(int);\n\nint main ( void ) \n{\n    D d;\n    D *pThis = &amp;d;\n\n    Func f = &amp;D::foo;\n\n    /* invoke function pointer via a \"class\" pointer */\n    (pThis-&gt;*f)(5);\n\n    /* invoke function pointer via a \"class\" object */\n    (d.*f)(5);\n\n    return 1;\n}\n</code></pre>\n<p>The output from this program is as pasted below:</p>\n<pre><code>~/prj/stackoverflow\n# g++ funcptr.cpp \n\n~/prj/stackoverflow\n# ./a.out \nD\nD\n</code></pre>\n<p>The compiler provides the \"this\" pointer to the method invocation via a class method pointer.  The \"this\" pointer will be the invoking object.</p>\n<p>Sure there is a way.  Make foo a static class method and change the signature of foo to take a \"this\" pointer.</p>\n<p>From:</p>\n<pre><code>void foo(int a) {}\n</code></pre>\n<p>To:</p>\n<pre><code>static void foo(D *pthis, int a) {}\n</code></pre>\n<p>To call foo w/o a . or -&gt;, the following will work</p>\n<pre><code>int main(void)\n{\n    D d;\n    int a = 0;\n    D::foo(&amp;d, a); /* call foo, w/o using . or -&gt; and providing your own this pointer */\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "2958759", "LastEditorUserId": "2958759", "LastEditDate": "2013-11-06T06:16:43.850", "Id": "19804288", "Score": "0", "CreationDate": "2013-11-06T04:43:00.207", "LastActivityDate": "2013-11-06T06:16:43.850"}, "bq_ids": {"n4140": {"so_19269438_19737662_0": {"section_id": 641, "quality": 0.5454545454545454, "length": 6}, "so_19269438_19269611_0": {"section_id": 3248, "quality": 0.6666666666666666, "length": 4}, "so_19269438_19819649_0": {"section_id": 641, "quality": 0.5454545454545454, "length": 6}, "so_19269438_19763712_0": {"section_id": 576, "quality": 0.6363636363636364, "length": 7}}, "n3337": {"so_19269438_19269611_0": {"section_id": 3121, "quality": 0.6666666666666666, "length": 4}, "so_19269438_19737662_0": {"section_id": 631, "quality": 0.5454545454545454, "length": 6}, "so_19269438_19819649_0": {"section_id": 631, "quality": 0.5454545454545454, "length": 6}, "so_19269438_19763712_0": {"section_id": 5756, "quality": 1.0, "length": 11}}, "n4659": {"so_19269438_19269611_0": {"section_id": 4006, "quality": 0.6666666666666666, "length": 4}, "so_19269438_19737662_0": {"section_id": 669, "quality": 0.5454545454545454, "length": 6}, "so_19269438_19819649_0": {"section_id": 669, "quality": 0.5454545454545454, "length": 6}, "so_19269438_19763712_0": {"section_id": 599, "quality": 0.6363636363636364, "length": 7}}}, "19269611": {"ParentId": "19269438", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I'm not quite sure what you're asking. There is no \"artificial restriction\" on calling functions via pointers to members; you just have to use the correct syntax:</p>\n<pre><code>(d.*f)(5);  // for objects or references\n(p-&gt;*f)(5); // for pointers\n</code></pre>\n<p><code>bind</code> doesn't do any \"magic\"; somewhere in its implementation, it does exactly that.</p>\n<blockquote>\n<p id=\"so_19269438_19269611_0\">at end of the day it is a function which takes two argument</p>\n</blockquote>\n<p>No, it's a member function that takes one argument, and is called on an object. While conceptually similar to a function taking two arguments, there is one big difference: member functions can be virtual, involving a run-time dispatch mechanism.</p>\n", "OwnerUserId": "204847", "LastEditorUserId": "204847", "LastEditDate": "2013-10-09T10:41:36.927", "Id": "19269611", "Score": "14", "CreationDate": "2013-10-09T10:34:35.790", "LastActivityDate": "2013-10-09T10:41:36.927"}, "19818964": {"ParentId": "19269438", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The only way I see is to replace your typedef-ed function pointer by a class that behaves like a function.</p>\n<p>Are you looking for something like this? </p>\n<p>In the following code I used a macro to typedef a template which then operates like the function you described.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass D {\n    public:\n        void foo ( int a ) {\n            cout &lt;&lt; \"D\" &lt;&lt; endl;\n        }\n\n        int data;\n};\n\ntemplate&lt;class Object, class Param, class Function&gt;\nclass FunctionPointerHelper                                           \n{                                                    \nprivate:                                             \n    Function m_function;                             \npublic:                                              \n    FunctionPointerHelper(Function function) :                        \n        m_function(function)                         \n    {                                                \n    }                                                \n    void operator=(Function function)                \n    {                                                \n        m_function = function;                       \n    }                                                \n    void operator()(Object&amp; object, Param param) const      \n    {                                                \n        (object.*m_function)(param);                 \n    }                                                \n};\n\n#define TYPEDEF_NICE_FUNCTION(RESULT, CLASS, NEW_TYPENAME, PARAM) \\\ntypedef RESULT ( CLASS::* NEW_TYPENAME_INTERMEDIATE)(PARAM) ; \\\ntypedef FunctionPointerHelper&lt;CLASS, PARAM, NEW_TYPENAME_INTERMEDIATE&gt; NEW_TYPENAME;\n\nTYPEDEF_NICE_FUNCTION(void, D, Func, int)\n\nint main ( void ) \n{\n    D d;\n\n    Func f = &amp;D::foo;\n    f(d, 5);\n\n    return 1;\n }\n</code></pre>\n", "OwnerUserId": "1701372", "LastEditorUserId": "1701372", "LastEditDate": "2013-11-06T17:58:54.120", "Id": "19818964", "Score": "4", "CreationDate": "2013-11-06T17:41:22.203", "LastActivityDate": "2013-11-06T17:58:54.120"}, "19850327": {"ParentId": "19269438", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2013-11-08T02:03:15.300", "OwnerUserId": "1278288", "CommunityOwnedDate": "2013-11-08T02:03:15.300", "Id": "19850327", "Score": "0", "Body": "<p>Although I think its a kind of strange thing to want, call_member looks like what you want.\n(Needs C++11)</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T, typename Ret, typename... Args&gt;\nRet call_member(Ret (T::*mem)(Args...), T* obj, Args... args)\n{\n    return (obj-&gt;*mem)(args...);\n}\n\nstruct S {\n    void foo(int i) { std::cout &lt;&lt; \"Foo: \" &lt;&lt; i &lt;&lt; '\\n'; }\n};\n\nint main()\n{\n    S s;\n\n    call_member(&amp;S::foo, &amp;s, 5);\n    return 0;\n}                                                                \n</code></pre>\n", "LastActivityDate": "2013-11-08T02:03:15.300"}, "19269635": {"ParentId": "19269438", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_19269438_19269635_0\">but there has to be a method to avoid this artificial restriction\n  imposed by c++</p>\n</blockquote>\n<p>What do you mean by <em>'artificial restriction'</em>? It's just the syntax as the language defines it. What's wrong with it? The 'magic' of <code>bind()</code> will use the <code>-&gt;*</code> operator internally to call the function.</p>\n", "OwnerUserId": "1413395", "PostTypeId": "2", "Id": "19269635", "Score": "2", "CreationDate": "2013-10-09T10:35:17.763", "LastActivityDate": "2013-10-09T10:35:17.763"}});