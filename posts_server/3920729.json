post_cb({"3920800": {"Id": "3920800", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_3920729_3920800_0\">I understood multi-dimensional arrays as pointers to pointers, but perhaps I am wrong?</p>\n</blockquote>\n<p>Yes, you are wrong. There is a difference between an array and a pointer. An array can decay into a pointer, but a pointer doesn't carry state about the size or configuration of the array to which it points. Don't confuse this automatic decay with the idea that arrays and pointers are the same -- they are not.</p>\n<p>A <code>char **</code> is a pointer to a memory block containing character pointers, which themselves point to memory blocks of characters. A <code>char [][]</code> is a single memory block which contains characters.</p>\n<p>If you have a <code>char **</code> and access it using <code>ptr[x][y]</code>, the compiler changes that into <code>*(*(ptr + x)+y)</code>. If you have a <code>char [][]</code>, the compiler changes <code>arr[x][y]</code> into <code>*(ptr + rowLength*y + x)</code>. (<em>Note</em>: I'm not 110% positive on the order of Xs and Ys here, but that doesn't matter for the point I'm making here) Note that given the pointer, the compiler doesn't know anything about the size or dimensions of the array, and cannot determine the actual address if you treat the pointer as a multidimensional array.</p>\n<p><code>char  *dic[][40]</code> is <a href=\"http://cdecl.ridiculousfish.com/?q=char++*dic[][40]\" rel=\"noreferrer\">an array of arrays of size forty, which contain character pointers</a>. Therefore it doesn't match your assignment there at all.</p>\n<p><code>p = (char **)dic;</code> &lt;-- This is why casts are bad. The compiler was telling you that what you really wanted to do to <code>dic</code> didn't make any sense. But since you can cast a pointer to any other pointer, the cast succeeds, even though trying to read the data that way will result in undefined behavior.</p>\n", "LastEditorUserId": "82320", "LastActivityDate": "2010-10-13T04:41:29.973", "Score": "5", "CreationDate": "2010-10-13T04:35:20.273", "ParentId": "3920729", "CommentCount": "0", "OwnerUserId": "82320", "LastEditDate": "2010-10-13T04:41:29.973"}, "3925968": {"Id": "3925968", "PostTypeId": "2", "Body": "<p>The rule for <a href=\"http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf\" rel=\"noreferrer\">C</a> is as follows:</p>\n<blockquote id=\"so_3920729_3925968_0\">\n<b>6.3.2.1 Lvalues, arrays, and function designators</b><br>\n...<br>\n3  Except when it is the operand of the <b>sizeof</b> operator or the unary <b>&amp;</b> operator, or is a string literal used to initialize an array, an expression that has type \u2018\u2018array of type\u2019\u2019 is converted to an expression with type \u2018\u2018pointer to type\u2019\u2019 that points to the initial element of the array object and is not an lvalue. If the array object has register storage class, the behavior is undefined.\n</br></br></blockquote>\n<p>The language for <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf\" rel=\"noreferrer\">C++</a> is a little different:</p>\n<blockquote id=\"so_3920729_3925968_1\">\n<b>4.2 Array-to-pointer conversion [conv.array]</b><br>\n<br>\n1  An lvalue or rvalue of type \u201carray of N T\u201d or \u201carray of unknown bound of T\u201d can be converted to an rvalue of type \u201cpointer to T\u201d. The result is a pointer to the first element of the array.<br>\n...<br>\n<b>8.3.4 Arrays [dcl.array]</b><br>\n...<br>\n7 A consistent rule is followed for multidimensional arrays. If E is an n-dimensional array of rank <i>i</i> \u00d7 <i>j</i> \u00d7 ... \u00d7 <i>k</i>, then E appearing in an expression is converted to a pointer to an (<i>n</i>\u22121)-dimensional array with rank <i>j</i> \u00d7 ... \u00d7 <i>k</i>. If the <b>*</b> operator, either explicitly or implicitly as a result of subscripting, is applied to this pointer, the result is the pointed-to (<i>n</i>\u22121)-dimensional array, which itself is immediately converted into a pointer.\n</br></br></br></br></br></br></blockquote>\n<p>So the following all hold true:</p>\n<pre><code>Declaration        Expression        Type             Decays to\n-----------        ----------        ----             ---------\n     T a[N]                 a        T [N]            T *\n                           &amp;a        T (*)[N]     \n                           *a        T\n                         a[i]        T\n\n  T a[M][N]                 a        T [M][N]         T (*)[N]\n                           &amp;a        T (*)[M][N]  \n                           *a        T [N]            T *\n                         a[i]        T [N]            T *\n                        &amp;a[i]        T (*)[N]      \n                        *a[i]        T\n                      a[i][j]        T\n\nT a[M][N][O]                a        T [M][N][O]      T (*)[M][N]\n                           &amp;a        T (*)[M][N][O]\n                           *a        T [M][N]         T (*)[N]\n                         a[i]        T [M][N]         T (*)[N]\n                        &amp;a[i]        T (*)[M][N]  \n                        *a[i]        T [N]            T *\n                      a[i][j]        T [N]            T *\n                     &amp;a[i][j]        T (*)[N]\n                     *a[i][j]        T\n                   a[i][j][k]        T\n</code></pre>\n<p>The pattern should be clear for higher-dimensional arrays.  </p>\n<p>So let's analyze your dictionary:</p>\n<pre><code>/* list of words and meanings */         \n\nchar  *dic[][40] = {         \n    \"atlas\", \"A volume of maps.\",         \n    \"car\", \"A motorized vehicle.\",         \n    \"telephone\", \"A communication device.\",         \n    \"airplane\", \"A flying machine.\",         \n    \"\", \"\"  /* null terminate the list */         \n};\n</code></pre>\n<p>This isn't going to set up your dictionary the way you want; you've basically set this up as a 1-element array of 40 pointers to char.  If you want an array of pairs of strings, then the declaration should look like this:</p>\n<pre><code>char *dic[][2] = \n{\n  {\"atlas\", \"A volume of maps\"},\n  {\"car\", \"A motorized vehicle\"},\n  {\"telephone\", \"A communication device\"},\n  {\"airplane\" , \"A flying machine\"},\n  {NULL, NULL} // empty strings and NULLs are different things.  \n}; \n</code></pre>\n<p>The type of <code>dic</code> is \"5-element array of 2-element arrays of pointer to char\", or <code>char *[5][2]</code>.  Going by the rules above, the expression <code>dic</code> should decay to <code>char *(*)[2]</code> -- a pointer to a 2-element array of pointer to char.  </p>\n<p>A function to search this dictionary would then look like this:</p>\n<pre><code>char *definition(char *term, char *(*dictionary)[2]) // *NOT* char ***dictionary\n{\n  while ((*dictionary)[0] != NULL &amp;&amp; strcmp((*dictionary)[0], term) != 0)\n    dictionary++;\n  return (*dictionary)[1];\n}\n</code></pre>\n<p>and you would call it from your main function like</p>\n<pre><code>char *def = definition(term, dic);\n</code></pre>\n<p>Note that we have to use parentheses around the <code>*dictionary</code> expression in the function.  The array subscript operator <code>[]</code> has higher precedence than the dereference operator <code>*</code>, and we don't want to subscript into <code>dictionary</code> directly, we want to subscript into the array that <code>dictionary</code> <em>points to</em>.</p>\n", "LastActivityDate": "2010-10-13T16:43:19.277", "CommentCount": "1", "CreationDate": "2010-10-13T16:43:19.277", "ParentId": "3920729", "Score": "6", "OwnerUserId": "134554"}, "3920789": {"Id": "3920789", "PostTypeId": "2", "Body": "<p>One of my memorization rules for combinations of <code>*</code> and <code>[]</code> is the signature of <code>main</code>. Works! :-)</p>\n<p>Your <code>dic</code> is an array of 40-element arrays, each element of which is a pointer to <code>char</code>.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\nusing namespace std;\n\ntemplate&lt; class Type, unsigned N &gt;\nvoid tellMeAbout( Type const (&amp;)[N] )\n{\n    cout &lt;&lt; \"Well, it's an array of \" &lt;&lt; typeid( Type ).name() &lt;&lt; \".\\n\";\n}\n\nint main()\n{\n    char  *dic[][40]    = { 0 };\n    tellMeAbout( dic );\n}\n</code></pre>\n<p>Using Visual C++ I get ...</p>\n<blockquote>\n<p id=\"so_3920729_3920789_0\">Well, it's an array of char * [40].</p>\n</blockquote>\n<p>Cheers &amp; hth.,</p>\n<p>\u2013 Alf</p>\n", "LastActivityDate": "2010-10-13T04:31:24.147", "CommentCount": "8", "CreationDate": "2010-10-13T04:31:24.147", "ParentId": "3920729", "Score": "2", "OwnerUserId": "464581"}, "3920977": {"Id": "3920977", "PostTypeId": "2", "Body": "<p>You need to refer to <a href=\"http://ieng9.ucsd.edu/~cs30x/rt_lt.rule.html\" rel=\"noreferrer\">'right left rule'</a>. Alternatively you can deciper most of the C-ish declarations at <a href=\"http://ieng9.ucsd.edu/~cs30x/rt_lt.rule.html\" rel=\"noreferrer\">here</a></p>\n<p>So,</p>\n<p><code>char *p[2][3]</code> is parsed as</p>\n<p>p is an array of 2 elements where each element is an array of 3 elements, such that each element is a pointer to a character.([] binds stronger than *)</p>\n<p><code>char (*p)[2][3]</code> is parsed as</p>\n<p>\"p is a pointer to a 2 element char array where each element is a char array of 3 elements.\" (parenthesis binds the strongest)</p>\n", "LastActivityDate": "2010-10-13T05:21:30.217", "CommentCount": "0", "CreationDate": "2010-10-13T05:21:30.217", "ParentId": "3920729", "Score": "5", "OwnerUserId": "418110"}, "bq_ids": {"n4140": {"so_3920729_3925968_1": {"length": 32, "quality": 0.5614035087719298, "section_id": 3234}}, "n3337": {"so_3920729_3925968_1": {"length": 32, "quality": 0.5614035087719298, "section_id": 3107}}, "n4659": {"so_3920729_3925968_1": {"length": 32, "quality": 0.5614035087719298, "section_id": 3991}}}, "3920729": {"ViewCount": "3921", "Body": "<p>I understood multi-dimensional arrays as pointers to pointers, but perhaps I am wrong?</p>\n<p>For example, I though:</p>\n<p><code>char * var</code>  =  <code>char var[]</code></p>\n<p><code>char ** var</code>  =  <code>char* var[]</code> or <code>char var[][]</code></p>\n<p><code>char *** var</code>  =  <code>char var[][][]</code> or <code>char* var[][]</code> or  <code>char** var[]</code></p>\n<p>Is this incorrect? I was confused because I saw a char*[][] cast as a char** in a simple text book example.</p>\n<p>I pasted the example below. Can anyone clear this up for me? Thanks!</p>\n<hr>\n<pre><code>/* A simple dictionary. */\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;ctype.h&gt;\n\n/* list of words and meanings */\n\nchar  *dic[][40] = {\n    \"atlas\", \"A volume of maps.\",\n    \"car\", \"A motorized vehicle.\",\n    \"telephone\", \"A communication device.\",\n    \"airplane\", \"A flying machine.\",\n    \"\", \"\"  /* null terminate the list */\n};\n\nint main(void)\n{\n    char word[80], ch;\n    char **p;\n\ndo {\n    puts(\"\\nEnter word: \");\n    scanf(\"%s\", word);\n    p = (char **)dic;\n    /* find matching word and print its meaning */\n    do {\n        if(!strcmp(*p, word)) {\n            puts(\"Meaning:\");\n            puts(*(p+1));\n            break;\n            }\n\n        if(!strcmp(*p, word)) break;\n\n        p = p + 2;  /* advance through the list */\n        } while(*p);\n\n    if(!*p) puts(\"Word not in dictionary.\");\n    printf(\"Another? (y/n): \");\n    scanf(\" %c%*c\", &amp;ch);\n\n    } while(toupper(ch) != 'N');\n\nreturn 0;\n\n}\n</code></pre>\n</hr>", "AcceptedAnswerId": "3925968", "Title": "In C/C++, is char* arrayName[][] a pointer to a pointer to a pointer OR a pointer to a pointer?", "CreationDate": "2010-10-13T04:17:13.380", "Id": "3920729", "CommentCount": "1", "FavoriteCount": "6", "PostTypeId": "1", "LastActivityDate": "2010-10-13T16:45:39.273", "Score": "2", "OwnerUserId": "362011", "Tags": "<c++><c><arrays><pointers><multidimensional-array>", "AnswerCount": "5"}, "3920760": {"Id": "3920760", "PostTypeId": "2", "Body": "<p>Not looked in too much detail but I think the author is relying upon c laying out a 2d string array like this:</p>\n<p>key, value, key, value, key, value in contiguous memory. Then traversing this array as a 1d array of strings <code>p = (char **)dic;</code></p>\n<p>This is one of the beauties and potential problems with C - it has lots of low level power but the you have protect yourself with decent code to prevent side effects.</p>\n", "LastActivityDate": "2010-10-13T04:25:52.367", "CommentCount": "1", "CreationDate": "2010-10-13T04:25:52.367", "ParentId": "3920729", "Score": "2", "OwnerUserId": "30225"}});