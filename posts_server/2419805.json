post_cb({"2419889": {"ParentId": "2419805", "CommentCount": "0", "Body": "<p>They've been there since C++ 98. They're listed in the \u00a72.5/2 of the standard (either the 1998 or the 2003 edition). The alternate tokens include: <code>and</code>, <code>or</code>, <code>xor</code>, <code>not</code>, <code>bitand</code>, <code>bitor</code>, <code>compl</code>, <code>and_eq</code>, <code>or_eq</code>, <code>xor_eq</code>, <code>not</code>, <code>not_eq</code>.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "2419889", "Score": "12", "CreationDate": "2010-03-10T19:28:17.467", "LastActivityDate": "2010-03-10T19:28:17.467"}, "2419882": {"ParentId": "2419805", "CommentCount": "1", "Body": "<p>From the C++03 standard, section 2.5:</p>\n<p>2.5 Alternative tokens</p>\n<p>Alternative token representations are provided for some operators and punctuators. In all respects of the language, each alternative token behaves the same, respectively, as its primary token, except for its spelling. The set of alternative tokens is defined in Table 2.</p>\n<p>Table 2\u2014alternative tokens</p>\n<pre><code>alternative primary \n  &lt;%         { \n  %&gt;         } \n  &lt;:         [ \n  :&gt;         ] \n  %:         # \n  %:%:       ## \n  and        &amp;&amp; \n  bitor      | \n  or         || \n  xor        \u02c6 \n  compl      \u02dc \n  bitand     &amp; \n  and_eq     &amp;= \n  or_eq      |= \n  xor_eq     \u02c6= \n  not        ! \n  not_eq     != \n</code></pre>\n", "OwnerUserId": "189205", "PostTypeId": "2", "Id": "2419882", "Score": "25", "CreationDate": "2010-03-10T19:27:08.587", "LastActivityDate": "2010-03-10T19:27:08.587"}, "2419805": {"CommentCount": "5", "AcceptedAnswerId": "2419830", "PostTypeId": "1", "LastEditorUserId": "102", "CreationDate": "2010-03-10T19:16:02.123", "LastActivityDate": "2016-08-25T15:53:15.127", "LastEditDate": "2010-03-10T19:33:31.700", "ViewCount": "3897", "FavoriteCount": "3", "Title": "When did \"and\" become an operator in C++", "Id": "2419805", "Score": "25", "Body": "<p>I have some code that looks like:</p>\n<pre><code>static const std::string and(\" AND \");\n</code></pre>\n<p>This causes an error in g++ like so:</p>\n<pre><code>Row.cpp:140: error: expected unqualified-id before '&amp;&amp;' token\n</code></pre>\n<p>so after cursing the fool that defined \"and\" as &amp;&amp;, I added</p>\n<pre><code>#ifdef and\n#undef and\n#endif\n</code></pre>\n<p>and now I get </p>\n<pre><code>Row.cpp:9:8: error: \"and\" cannot be used as a macro name as it is an operator in C++\n</code></pre>\n<p>Which leads to my question of WHEN did \"and\" become an operator in C++?  I can't find anything that indicates it is, except of course this message from g++</p>\n", "Tags": "<c++><g++>", "OwnerUserId": "147562", "AnswerCount": "7"}, "2419867": {"ParentId": "2419805", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>According to C++ Standard 2.12 there are predefined preprocessor tokens \"which are used in\nthe syntax of the preprocessor or are converted into tokens for operators and punctuators.\" <code>and</code> is one of them. In new C++ Standard there is new 2.12/2:</p>\n<blockquote>\n<p id=\"so_2419805_2419867_0\">Furthermore, the alternative representations shown in Table 4 for certain operators and punctuators (2.6) <strong>are reserved and shall not be used</strong> otherwise:</p>\n<pre>\nand and_eq bitand bitor compl not\nnot_eq or or_eq xor xor_eq\n</pre>\n</blockquote>\n", "OwnerUserId": "123111", "LastEditorUserId": "123111", "LastEditDate": "2010-03-10T19:32:49.940", "Id": "2419867", "Score": "5", "CreationDate": "2010-03-10T19:25:12.810", "LastActivityDate": "2010-03-10T19:32:49.940"}, "2419891": {"ParentId": "2419805", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You can use <code>-fno-operator-names</code> to disable this. Alternatively, you can name your <code>std::string</code> object something else!</p>\n", "OwnerUserId": "228781", "LastEditorUserId": "1671066", "LastEditDate": "2015-05-26T10:39:08.297", "Id": "2419891", "Score": "8", "CreationDate": "2010-03-10T19:28:23.017", "LastActivityDate": "2015-05-26T10:39:08.297"}, "2419829": {"ParentId": "2419805", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I don't know when it was introduced, it may well have been there from the beginning, but I believe the reason it's there is as an alternative to <code>&amp;&amp;</code> for people with restricted character sets i.e. where they don't actually have the ampersand character.</p>\n<p>There are many others too eg. <code>and_eq</code>, <code>or</code>, <code>compl</code> and <code>not</code> to name just a selection.</p>\n", "OwnerUserId": "74465", "LastEditorUserId": "74465", "LastEditDate": "2013-08-26T21:29:07.973", "Id": "2419829", "Score": "3", "CreationDate": "2010-03-10T19:19:18.627", "LastActivityDate": "2013-08-26T21:29:07.973"}, "2420021": {"ParentId": "2419805", "CommentCount": "0", "Body": "<p>They were added because some of those characters are difficult to type on some keyboards.</p>\n", "OwnerUserId": "235825", "PostTypeId": "2", "Id": "2420021", "Score": "3", "CreationDate": "2010-03-10T19:46:30.467", "LastActivityDate": "2010-03-10T19:46:30.467"}, "bq_ids": {"n4140": {"so_2419805_2419867_0": {"section_id": 5337, "quality": 0.9, "length": 9}}, "n3337": {"so_2419805_2419867_0": {"section_id": 5134, "quality": 0.9, "length": 9}}, "n4659": {"so_2419805_2419867_0": {"section_id": 6758, "quality": 0.9, "length": 9}}}, "2419830": {"ParentId": "2419805", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>There are <a href=\"http://en.cppreference.com/w/cpp/language/operator_alternative\" rel=\"nofollow noreferrer\">several such alternatives</a> defined in C++.  You can probably use switches to turn these on/off.</p>\n", "OwnerUserId": "3153", "LastEditorUserId": "1641854", "LastEditDate": "2016-08-25T15:53:15.127", "Id": "2419830", "Score": "9", "CreationDate": "2010-03-10T19:19:20.933", "LastActivityDate": "2016-08-25T15:53:15.127"}});