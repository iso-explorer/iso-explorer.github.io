post_cb({"bq_ids": {"n4140": {"so_25248680_25249142_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5440}}, "n3337": {"so_25248680_25249142_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 5235}}, "n4659": {"so_25248680_25249142_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 6867}}}, "25248680": {"ViewCount": "236", "Body": "<p>I'm trying to pass the type of a class member as a template argument. For this I'm using the following code:</p>\n<pre><code>class C\n{\npublic:\n    int a;\n};\nclass B\n{\npublic:\n    template&lt;typename _T&gt; void Test() {}\n    // Specialize for int for Test testing purposes.\n    template&lt;&gt; void Test&lt;int&gt;() { printf(\"Success!\\n\"); }\n};\n\n//Later:\nB b;\nC c;\nb.Test&lt;decltype(c.a)&gt;();\n</code></pre>\n<p>This gives me the following error:</p>\n<blockquote>\n<p id=\"so_25248680_25248680_0\">error C2662: 'void B::Test(void)' : cannot convert 'this' pointer\n  from 'C' to 'B &amp;' Reason: cannot convert from 'C' to 'B' Conversion\n  requires a second user-defined-conversion operator or constructor</p>\n</blockquote>\n<p>However, it does work if I use the following code:</p>\n<pre><code>decltype(c.a) d;\nb.Test&lt;decltype(d)&gt;();\n</code></pre>\n<p>Why doesn't it work if I simply use the class member directly?\nI'm using Visual Studio 2012.</p>\n", "AcceptedAnswerId": "25249142", "Title": "Decltype on class member as template argument", "CreationDate": "2014-08-11T17:09:14.273", "Id": "25248680", "CommentCount": "3", "FavoriteCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-08-12T13:14:56.453", "Score": "0", "OwnerUserId": "3930429", "Tags": "<c++><templates><visual-studio-2012><member><decltype>", "AnswerCount": "2"}, "25249036": {"Id": "25249036", "PostTypeId": "2", "Body": "<p>I don't think it is legal to define a specialization inside the class, it has to be at namespace level (g++ does not compile your code, <code>error: explicit specialization in non-namespace scope 'class B'</code>). Try to define the template outside the class,</p>\n<pre><code>template&lt;&gt; void B::Test&lt;int&gt;() { printf(\"Success!\\n\"); }\n</code></pre>\n<p>This code works perfectly fine for me (on g++), if it doesn't work for you it is probably a VS issue.</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass C\n{\npublic:\n    int a;\n};\n\nclass B\n{\npublic:\n    template&lt;typename _T&gt; \n    void Test() {}\n    // Specialize for int for Test testing purposes.\n};\n\ntemplate&lt;&gt; void B::Test&lt;int&gt;() { cout &lt;&lt; \"Success!\\n\"; }\n\nint main()\n{\n    B b;\n    C c;\n    b.Test&lt;decltype(c.a)&gt;();\n}\n</code></pre>\n", "LastActivityDate": "2014-08-11T17:28:50.263", "CommentCount": "2", "CreationDate": "2014-08-11T17:28:50.263", "ParentId": "25248680", "Score": "1", "OwnerUserId": "3093378"}, "25249142": {"Id": "25249142", "PostTypeId": "2", "Body": "<p>7.1.6.2(4)</p>\n<blockquote>\n<p id=\"so_25248680_25249142_0\">For an expression <code>e</code>, the type denoted by <code>decltype(e)</code> is defined as follows:</p>\n<ul>\n<li>if <code>e</code> is an unparenthesized <em>id-expression</em> <strong>or an unparenthesized class member access</strong> (5.2.5), <code>decltype(e)</code> is the type of the entity named by <code>e</code>.</li>\n<li>If there is no such entity, or if <code>e</code> names a set of overloaded functions, the program is ill-formed;</li>\n<li>otherwise, if <code>e</code> is an xvalue, <code>decltype(e)</code> is <code>T&amp;&amp;</code>, where <code>T</code> is the type of <code>e</code>;</li>\n<li>otherwise, if <code>e</code> is an lvalue, <code>decltype(e)</code> is <code>T&amp;</code>, where <code>T</code> is the type of <code>e</code>;</li>\n<li>otherwise, <code>decltype(e)</code> is the type of <code>e</code>.</li>\n</ul>\n</blockquote>\n<p>VS2012 seems to forget (or was never told) the part which I have bolded, the case where <code>e</code> is an unparenthesized class member access. Therefore it could be falling back to the rule for when <code>e</code> is an lvalue, so for VS2012 <code>decltype(c.a)</code> denotes <code>int&amp;</code> (a reference to <code>int</code>).</p>\n<p>Your example also contains an identifier beginning with <code>_</code> and a capital letter (<code>_T</code>) which is undefined behaviour. See <a href=\"https://stackoverflow.com/q/228783/1639256\">What are the rules about using an underscore in a C++ identifier?</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-08-12T13:14:56.453", "Score": "1", "CreationDate": "2014-08-11T17:35:15.737", "ParentId": "25248680", "CommentCount": "2", "OwnerUserId": "1639256", "LastEditDate": "2017-05-23T11:49:31.090"}});