post_cb({"41850904": {"ParentId": "41847511", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, that is allowed, therefore: No, <code>std::mutex</code> is not sequentially consistent. </p>\n<p><code>std::mutex</code> is not defined in the standard to be sequentially consistent, only that </p>\n<blockquote>\n<h3>30.4.1.2 Mutex types [thread.mutex.requirements.mutex]</h3>\n<p id=\"so_41847511_41850904_0\">11 Synchronization: Prior unlock() operations on the same object shall\n  synchronize with (1.10) this operation <em>[lock()]</em>.</p>\n</blockquote>\n<p><em>Synchronize-with</em> seems to be defined in the same was as <code>std::memory_order::release/acquire</code> (see <a href=\"https://stackoverflow.com/questions/15313296/release-acquire-semantics-wrt-stdmutex\">this question</a>).<br>\nAs far as I can see, an acquire/release spinlock would satisfy the standards for std::mutex.</br></p>\n", "OwnerUserId": "6838526", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:09:02.660", "Id": "41850904", "Score": "4", "CreationDate": "2017-01-25T11:50:24.180", "LastActivityDate": "2017-01-25T16:29:15.710"}, "41847511": {"CommentCount": "0", "AcceptedAnswerId": "41850904", "PostTypeId": "1", "LastEditorUserId": "1335865", "CreationDate": "2017-01-25T09:12:37.223", "LastActivityDate": "2017-01-25T16:29:15.710", "LastEditDate": "2017-01-25T11:07:19.460", "ViewCount": "281", "FavoriteCount": "1", "Title": "Is std::mutex sequentially consistent?", "Id": "41847511", "Score": "6", "Body": "<p>Say, I have two threads <code>A</code> and <code>B</code> writing to a global Boolean variables <code>fA</code> and <code>fB</code> respectively which are initially set to <code>false</code> and are protected by <code>std::mutex</code> objects <code>mA</code> and <code>mB</code> respectively:</p>\n<pre><code>// Thread A\nmA.lock();\nassert( fA == false );\nfA = true;\nmA.unlock();\n\n// Thread B\nmB.lock()\nassert( fB == false );\nfB = true;\nmB.unlock()\n</code></pre>\n<p>Is it possible to observe the modifications on <code>fA</code> and <code>fB</code> in different orders in different threads <code>C</code> and <code>D</code>? In other words, can the following program </p>\n<pre><code>#include &lt;atomic&gt;\n#include &lt;cassert&gt;\n#include &lt;iostream&gt;\n#include &lt;mutex&gt;\n#include &lt;thread&gt;\nusing namespace std;\n\nmutex mA, mB, coutMutex;\nbool fA = false, fB = false;\n\nint main()\n{\n    thread A{ []{\n            lock_guard&lt;mutex&gt; lock{mA};\n            fA = true;\n        } };\n    thread B{ [] {\n            lock_guard&lt;mutex&gt; lock{mB};\n            fB = true;\n        } };\n    thread C{ [] { // reads fA, then fB\n            mA.lock();\n            const auto _1 = fA;\n            mA.unlock();\n            mB.lock();\n            const auto _2 = fB;\n            mB.unlock();\n            lock_guard&lt;mutex&gt; lock{coutMutex};\n            cout &lt;&lt; \"Thread C: fA = \" &lt;&lt; _1 &lt;&lt; \", fB = \" &lt;&lt; _2 &lt;&lt; endl;\n        } };\n    thread D{ [] { // reads fB, then fA (i. e. vice versa)\n            mB.lock();\n            const auto _3 = fB;\n            mB.unlock();\n            mA.lock();\n            const auto _4 = fA;\n            mA.unlock();\n            lock_guard&lt;mutex&gt; lock{coutMutex};\n            cout &lt;&lt; \"Thread D: fA = \" &lt;&lt; _4 &lt;&lt; \", fB = \" &lt;&lt; _3 &lt;&lt; endl;\n        } };\n    A.join(); B.join(); C.join(); D.join();\n}\n</code></pre>\n<p>legally print </p>\n<pre><code>Thread C: fA = 1, fB = 0\nThread D: fA = 0, fB = 1\n</code></pre>\n<p>according to the C++ standard?</p>\n<p><strong>Note:</strong> A spin-lock can be implemented using <code>std::atomic&lt;bool&gt;</code> variables using either sequential consistent memory order or acquire/release memory order. So the question is whether an <code>std::mutex</code> behaves like a sequentially consistent spin-lock or an acquire/release memory order spin-lock. </p>\n", "Tags": "<c++><multithreading><c++11><mutex><memory-order>", "OwnerUserId": "1335865", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_41847511_41850904_0": {"section_id": 2813, "quality": 0.7, "length": 7}}, "n3337": {"so_41847511_41850904_0": {"section_id": 2719, "quality": 0.6, "length": 6}}, "n4659": {"so_41847511_41850904_0": {"section_id": 3551, "quality": 0.7, "length": 7}}}});