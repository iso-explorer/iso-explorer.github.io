post_cb({"bq_ids": {"n4140": {"so_21165640_21165727_0": {"length": 20, "quality": 0.7692307692307693, "section_id": 37}}, "n3337": {"so_21165640_21165727_0": {"length": 20, "quality": 0.7692307692307693, "section_id": 34}}, "n4659": {"so_21165640_21165727_0": {"length": 19, "quality": 0.7307692307692307, "section_id": 37}}}, "21165721": {"Id": "21165721", "PostTypeId": "2", "Body": "<p><code>isnan()</code> only works on floating point.</p>\n", "LastEditorUserId": "1009479", "LastActivityDate": "2014-01-16T15:23:32.370", "Score": "2", "CreationDate": "2014-01-16T15:19:24.760", "ParentId": "21165640", "CommentCount": "0", "OwnerUserId": "1160368", "LastEditDate": "2014-01-16T15:23:32.370"}, "21165640": {"ViewCount": "152", "Body": "<p>I am writing a function that returns a pointer to an array of numbers. To be able to iterate over the numbers using a pointer I set the last element to <code>NAN</code> to mark the end of the array.<br>\nMy Loop was something like  </br></p>\n<pre><code>for(int* it=ptr;!isnan(*it);++it)  \n//print *it\n</code></pre>\n<p>but it kept going until it crashed so I wrote some test code:  </p>\n<pre><code>int* test = new int[1];  \n*test = NAN;  \ncout &lt;&lt; isnan(NAN) &lt;&lt; endl;  \ncout &lt;&lt; isnan(*test) &lt;&lt; endl;\n</code></pre>\n<p>And the result was:</p>\n<pre><code>1\n0\n</code></pre>\n<p>I have seen many examples for using <code>NAN</code> as a 'stopper' in arrays. So why doesn't that work? </p>\n", "AcceptedAnswerId": "21165727", "Title": "Is NAN returns false when accessing through pointer?", "CreationDate": "2014-01-16T15:15:59.957", "Id": "21165640", "CommentCount": "3", "LastEditDate": "2014-01-16T15:18:16.097", "PostTypeId": "1", "LastEditorUserId": "1673391", "LastActivityDate": "2014-01-16T15:25:10.847", "Score": "0", "OwnerUserId": "2847418", "Tags": "<c++><pointers><nan><math.h>", "AnswerCount": "2"}, "21165727": {"Id": "21165727", "PostTypeId": "2", "Body": "<p>You have undefined behaviour because you are attempting to convert <code>NAN</code>, which is of floating point type, to an <code>int</code> and that value cannot be represented by an <code>int</code>.</p>\n<blockquote>\n<p id=\"so_21165640_21165727_0\"><em>\u00a74.9/1 [conf.fpint]</em> A prvalue of a \ufb02oating point type can be converted to a prvalue of an integer type. The conversion truncates; that is, the fractional part is discarded. The behavior is unde\ufb01ned if the truncated value cannot be represented in the destination type.</p>\n</blockquote>\n<p>Since <code>NAN</code> is just a special value of floating point numbers, it doesn't make sense to store it in an <code>int</code>. Integer types don't have a special not-a-number value. You <em>could</em> use some specific value to denote the end of the array, but that's not a particularly pleasant solution.</p>\n<p>If you're going to dynamically allocate your array like this, you are going to have to keep track of the size of it yourself by passing it around. For other arrays (where you actually have something denoting the array object itself, rather than just a pointer to its elements), you could use <code>std::end</code> to find the end of it. However, as usual, I suggest using standard containers instead.</p>\n", "LastEditorUserId": "150634", "LastActivityDate": "2014-01-16T15:25:10.847", "Score": "5", "CreationDate": "2014-01-16T15:19:49.523", "ParentId": "21165640", "CommentCount": "1", "OwnerUserId": "150634", "LastEditDate": "2014-01-16T15:25:10.847"}});