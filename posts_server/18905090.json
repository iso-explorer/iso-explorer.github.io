post_cb({"bq_ids": {"n4140": {"so_18905090_18905247_0": {"length": 19, "quality": 1.0, "section_id": 6688}}, "n3337": {"so_18905090_18905247_0": {"length": 19, "quality": 1.0, "section_id": 6443}}, "n4659": {"so_18905090_18905247_0": {"length": 19, "quality": 1.0, "section_id": 8163}}}, "18905090": {"ViewCount": "477", "Body": "<p>I am attempting to do exercise 7.32 from C++ Primer 5th Edition. That exercise asks the following:</p>\n<blockquote>\n<p id=\"so_18905090_18905090_0\">Define your own versions of <code>Screen</code> and <code>Window_mgr</code> in which <code>clear</code> is a member of <code>Window_mgr</code> and a friend of <code>Screen</code>.</p>\n</blockquote>\n<p>Here are the definitions for <code>Screen</code>, <code>Window_mgr</code> and <code>clear</code> given in the text.</p>\n<pre><code>class Screen\n{\n  public:\n    using pos = std::string::size_type;\n    Screen(pos ht, pos wd, char c) : height(ht), width(wd), contents(ht * wd, c) { }\n  private:\n    pos height = 0, width = 0;\n    std::string contents;\n};\n\nclass Window_mgr\n{\n  public:\n    using ScreenIndex = std::vector&lt;Screen&gt;::size_type;\n    void clear(ScreenIndex);\n  private:\n    std::vector&lt;Screen&gt; screens{Screen(24, 80 ' ')};\n};\n\nvoid Window_mgr::clear(ScreenIndex i)\n{\n  Screen &amp;s = screens[i];\n  s.contents = std::string(s.height * s.width, ' ');\n}\n</code></pre>\n<p>Now those two classes, if defined Screen first than Window_mgr work as I expect. Now, the exercise asks me to make <code>clear</code> a friend of Screen and define <code>clear</code>. To make <code>clear</code> a member a friend, if I understand correctly, <code>Window_mgr</code> must be defined. To define <code>Window_mgr</code>, <code>Screen</code> must be defined. This seems impossible to me.</p>\n<p>The text gives the following hints:</p>\n<blockquote>\n<p id=\"so_18905090_18905090_1\">Making a member function a friend requires careful structuring of our programs to accommodate interdependencies among the declarations and definitions. In this example, we must order our program as follows:</p>\n<ul>\n<li><p id=\"so_18905090_18905090_2\">First, define the <code>Window_mgr</code> class, which declares, but does not define, <code>clear</code>. <code>Screen</code> must be declared before <code>clear</code> can use members of <code>Screen</code>.</p></li>\n<li><p id=\"so_18905090_18905090_3\">Next, define class <code>Screen</code>, including a friend declaration for <code>clear</code>.</p></li>\n<li><p id=\"so_18905090_18905090_4\">Finally, define <code>clear</code>, which can now refer to members in <code>Screen</code>.</p></li>\n</ul>\n</blockquote>\n<p>The order in which I attempted to solve this exercise was ultimately this:</p>\n<pre><code>class Screen;\n\nclass Window_mgr\n{\n  public:\n    using ScreenIndex = std::vector&lt;Screen&gt;::size_type;\n    void clear(ScreenIndex);\n  private:\n    std::vector&lt;Screen&gt; screens{Screen(24, 80 ' ')};\n};\n\nclass Screen\n{\n  friend Window_mgr::clear(Window_mgr::ScreenIndex);\n  public:\n    using pos = std::string::size_type;\n    Screen(pos ht, pos wd, char c) : height(ht), width(wd), contents(ht * wd, c) { }\n  private:\n    pos height = 0, width = 0;\n    std::string contents;\n};\n\nvoid Window_mgr::clear(ScreenIndex i)\n{\n  Screen &amp;s = screens[i];\n  s.contents = std::string(s.height * s.width, ' ');\n}\n</code></pre>\n<p>This obviously would not work, due to the vector in <code>Window_mgr</code> that needs <code>Screen</code> to be a complete type. This seems like an unsolvable exercise, unless the authors do not intend one to use <code>Screen</code> and <code>Window_mgr</code> classes they present earlier.</p>\n<p>Has anyone else solved this exercise from C++ Primer. If so, how? Any help how this can be done, or as my gut tells me, cannot be done?</p>\n", "AcceptedAnswerId": "18905247", "Title": "How to declare two classes such that A has members of B and B marks members of A as friends?", "CreationDate": "2013-09-19T21:19:21.550", "Id": "18905090", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-09-20T07:21:39.633", "LastEditorUserId": "499359", "LastActivityDate": "2013-09-20T07:21:39.633", "Score": "5", "OwnerUserId": "809400", "Tags": "<c++><class><friend><forward-declaration>", "AnswerCount": "1"}, "18905247": {"Id": "18905247", "PostTypeId": "2", "Body": "<p>As [class.friend]/5 says :</p>\n<blockquote>\n<p id=\"so_18905090_18905247_0\">When a friend declaration refers to an overloaded name or operator, only the function specified by the parameter types becomes a friend. A member function of a class X can be a friend of a class Y.</p>\n</blockquote>\n<p>In your specific case :</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstruct Screen;\n\nclass Window_mgr\n{\n  public:\n\n    Window_mgr();\n\n    using ScreenIndex = std::vector&lt;Screen&gt;::size_type;\n    void clear(ScreenIndex);\n  private:\n    std::vector&lt;Screen&gt; screens;\n};\n\nclass Screen\n{\n  friend void Window_mgr::clear(ScreenIndex);\n  public:\n    using pos = std::string::size_type;\n    Screen(pos ht, pos wd, char c) : height(ht), width(wd), contents(ht * wd, c) { }\n  private:\n    pos height = 0, width = 0;\n    std::string contents;\n};\n\n\nWindow_mgr::Window_mgr():\n  screens{1, Screen(24, 80, ' ') }\n{\n}\n\nvoid Window_mgr::clear(ScreenIndex i)\n{\n  Screen &amp;s = screens[i];\n  s.contents = std::string(s.height * s.width, ' ');\n}\n\nint main()\n{\n  Window_mgr w;\n  w.clear(0);\n}\n</code></pre>\n<hr>\n<p>Take a note that it is not possible to solve that exercise, because Window_mgr has a member variable of std::vector which argument is an incomplete type. It will work on most compilers (see <a href=\"https://stackoverflow.com/a/8330131/476681\">here</a> why), but the standard prohibits it.</p>\n<p>This example demonstrates how to make a member function friend of a class :</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A;\n\nstruct B\n{ \n  void bar( A&amp; a, int l);\n};\n\nstruct A\n{\n  friend void B::bar(A&amp;,int);\n  A():k(0){}\n  private:\n  void foo(int m);\n  int k;\n};\n\n\n\nvoid A::foo(int m)\n{\n  std::cout&lt;&lt;\"A::foo() changing from \"&lt;&lt;k&lt;&lt;\" to \"&lt;&lt;m&lt;&lt;std::endl;\n  k=m;\n}\n\nvoid B::bar( A&amp; a, int l)\n{\n  std::cout&lt;&lt;\"B::bar() changing to \"&lt;&lt;l&lt;&lt;std::endl;\n  a.foo(l);\n}\n\nint main()\n{\n  A a;\n  B b;\n  b.bar(a,11);\n}\n</code></pre>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-09-20T06:37:28.703", "Score": "2", "CreationDate": "2013-09-19T21:30:17.943", "ParentId": "18905090", "CommentCount": "17", "OwnerUserId": "476681", "LastEditDate": "2017-05-23T10:31:56.380"}});