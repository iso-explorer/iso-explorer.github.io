post_cb({"bq_ids": {"n4140": {"so_26824706_26824747_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 383}}, "n3337": {"so_26824706_26824747_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 374}}, "n4659": {"so_26824706_26824747_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 400}}}, "26824747": {"Id": "26824747", "PostTypeId": "2", "Body": "<p>The compiler has to look for a valid conversion from <code>char const*</code> to <code>Test</code>, so it searches for constructors from <code>Test</code> to convert the argument. This is standard behavior allowed by \u00a712.3/1 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_26824706_26824747_0\">Type conversions of class objects can be specified by <strong>constructors</strong> and by conversion functions. These conversions are called <em>user-defined conversions</em> and are used for implicit type conversions (Clause 4), for initialization (8.5), and for explicit type conversions (5.4, 5.2.9).</p>\n</blockquote>\n<p>The implicit conversion sequence creates a temporary instance of <code>Test</code> which is then copied or moved to the parameter. This copy/move can actually be elided by the compiler by an optimization known as <a href=\"http://en.wikipedia.org/wiki/Copy_elision\" rel=\"nofollow\"><em>copy-elision</em></a>.</p>\n<p>If you want to prevent implicit conversions, you can mark your constructor <code>explicit</code>:</p>\n<pre><code>explicit Test(char const* = \"\");\n</code></pre>\n", "LastEditorUserId": "701092", "LastActivityDate": "2014-11-09T03:49:37.933", "Score": "1", "CreationDate": "2014-11-09T03:42:14.743", "ParentId": "26824706", "CommentCount": "0", "OwnerUserId": "701092", "LastEditDate": "2014-11-09T03:49:37.933"}, "26824706": {"ViewCount": "52", "Body": "<p>I can't figure out a decent title - please edit it if you have a better description. Hopefully someone can help me understand what is going on. I have the following code, I just compiled on linux - it works. I just don't understand how when I call <code>Foo</code> with a <code>const char*</code>, that it gets cast by (the compiler?) into my object <code>Test</code>.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nclass Test\n{\npublic:\n  Test(const char* _data = \"\")\n  {\n    int length = strlen(_data);\n    internalData = new char[length+1];\n    strncpy(internalData, _data, length);\n    internalData[length] = '\\0';\n  }\n  char* internalData;\n};\n\nclass Bar\n{\npublic:\n  void Foo(Test _data)\n  {\n    std::cout &lt;&lt; \"Data: \" &lt;&lt; _data.internalData &lt;&lt; std::endl;\n  }\n};\n\nint main(int argc, char* argv[])\n{\n  Bar b;\n  b.Foo(\"This is my data\");\n}\n\n// Output: Data: This is my data\n</code></pre>\n<p>So, I'm curious as to why/how this works - is it the compiler? runtime? Is there documentation as to why - that someone could provide a link to?</p>\n", "AcceptedAnswerId": "26824747", "Title": "Why does the copy constructor automatically cast my data into a different type?", "CreationDate": "2014-11-09T03:35:30.637", "Id": "26824706", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-11-09T03:49:37.933", "Score": "0", "OwnerUserId": "1944429", "Tags": "<c++>", "AnswerCount": "1"}});