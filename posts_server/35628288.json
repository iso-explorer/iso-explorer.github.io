post_cb({"35628288": {"CommentCount": "0", "AcceptedAnswerId": "35628419", "PostTypeId": "1", "LastEditorUserId": "5951077", "CreationDate": "2016-02-25T13:11:22.223", "LastActivityDate": "2016-02-25T16:43:40.303", "LastEditDate": "2016-02-25T16:23:32.823", "ViewCount": "270", "FavoriteCount": "1", "Title": "seekg() does not set eofbit when reaching EOF of a stream. Is it by design?", "Id": "35628288", "Score": "0", "Body": "<p><strong>EDIT:</strong> there was a subtle error in my original test program code:\nthe <code>\" char=\" &lt;&lt; aStream.peek()</code> line (and probably the <code>\" input pos=\" &lt;&lt; aStream.tellg()</code>, as well) modified the stream state-flags, so not the real state was reported. So those calls must be completely deleted from the code, otherwise we cannot see the real effect of <code>seekg()</code> on the state-flags.\nHowever the result is still the same: the <code>eofbit</code> is not set.</p>\n<p><strong>Original post:</strong></p>\n<p>I try to detect EOF of an <code>std::istream</code> by advancing the input pointer with 1 step by calling</p>\n<pre><code>seekg( 1, std::ios_base::cur )\n</code></pre>\n<p>However <code>seekg()</code> moves 1 position beyond EOF, when it sets the <code>failbit</code> of the stream.\nThe <code>eofbit</code> is never set. See the output of this test program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n\nusing namespace std;\n\nvoid info( int aRelativePos, istream&amp; aStream )\n{\n    cout &lt;&lt; \"POS=\" &lt;&lt; aRelativePos &lt;&lt;\n            \" input pos=\" &lt;&lt; aStream.tellg() &lt;&lt;\n            \" char=\" &lt;&lt; aStream.peek() &lt;&lt;\n            \"\\tGood: \" &lt;&lt; aStream.good() &lt;&lt;\n            \" Eof: \" &lt;&lt; aStream.eof() &lt;&lt;\n            \" Bad: \" &lt;&lt; aStream.bad() &lt;&lt;\n            \" Fail: \" &lt;&lt; aStream.fail() &lt;&lt; \"\\n\";\n}\n\nint main()\n{\n    istringstream   input (\"12\");\n\n    int i=0;\n    while ( input.good() )\n    {\n        info( i, input );\n        input.seekg( 1, std::ios_base::cur ); //advance 1 step forward\n        ++i;\n    }\n    info ( i, input );\n\n    return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>POS=0 input pos=0 char=49   Good: 1 Eof: 0 Bad: 0 Fail: 0\nPOS=1 input pos=1 char=50   Good: 1 Eof: 0 Bad: 0 Fail: 0\nPOS=2 input pos=-1 char=-1  Good: 1 Eof: 0 Bad: 0 Fail: 0\nPOS=3 input pos=-1 char=-1  Good: 0 Eof: 0 Bad: 0 Fail: 1\n</code></pre>\n<p>(Compiled by gcc 5.2 with <code>-std=c++11</code>. You can run this code here: <a href=\"http://coliru.stacked-crooked.com/a/69f4d70e93359423\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/69f4d70e93359423</a> )</p>\n<p>Moreover MS document on <code>seekg</code> ( <a href=\"https://msdn.microsoft.com/en-us/library/y2d6fx99(v=vs.120).aspx\" rel=\"nofollow\">https://msdn.microsoft.com/en-us/library/y2d6fx99(v=vs.120).aspx</a> ) says that relative positioning in text files is not supported by the C++ Standard.</p>\n<p>But I could not find such info in the Standard.  Can you please give me the reference?</p>\n", "Tags": "<c++><c++11><stream>", "OwnerUserId": "5951077", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_35628288_35628419_1": {"section_id": 2248, "quality": 0.9523809523809523, "length": 40}}, "n3337": {"so_35628288_35628419_1": {"section_id": 2236, "quality": 0.9523809523809523, "length": 40}}, "n4659": {"so_35628288_35628419_1": {"section_id": 2521, "quality": 0.9285714285714286, "length": 39}}}, "35628419": {"ParentId": "35628288", "PostTypeId": "2", "CommentCount": "18", "Body": "<p>Well as long as you are okay with the standard says this is the behavior we have from [istream.unformatted]</p>\n<blockquote>\n<p id=\"so_35628288_35628419_0\"><code>basic_istream&lt;charT,traits&gt;&amp; seekg(pos_type pos);</code></p>\n<p id=\"so_35628288_35628419_1\"><em>Effects:</em> Behaves as an unformatted input function (as described in 27.7.2.3, paragraph 1), except that the function first clears <code>eofbit</code>, it does not count the number of characters extracted, and it does not affect the value returned by subsequent calls to <code>gcount()</code>. After constructing a sentry object, if <code>fail() != true</code>, executes <code>rdbuf()-&gt;pubseekpos(pos, ios_base::in)</code>. In case of failure, the function calls <code>setstate(failbit)</code> (which may throw <code>ios_base::failure</code>).</p>\n</blockquote>\n<p>So per the standard we will always clear the <code>eofbit</code> and on an failure only the fail bit is set.  Trying to read past the end of failure is a failure so that is why it gets set.  Just reaching the end of file is not a failure as the end is a valid position.</p>\n<p>You can see in this example(modified from your code) that once we reach the end of file we are still good and then trying to read from there will not only set the <code>eofbit</code> but also the <code>failbit</code> as we are at the end of file and the extraction fails</p>\n<pre><code>input.seekg(0, std::ios::end);\ninfo (input);\nchar ch;\ninput &gt;&gt; ch;\ninfo (input);\n</code></pre>\n<p>Output:</p>\n<pre><code>Good: 1 Eof: 0 Bad: 0 Fail: 0\nGood: 0 Eof: 1 Bad: 0 Fail: 1\n</code></pre>\n<p><kbd><a href=\"http://coliru.stacked-crooked.com/a/f5eebf8e4eab9aa5\" rel=\"nofollow\">Live Example</a></kbd></p>\n", "OwnerUserId": "4342498", "LastEditorUserId": "4342498", "LastEditDate": "2016-02-25T16:43:40.303", "Id": "35628419", "Score": "2", "CreationDate": "2016-02-25T13:17:00.087", "LastActivityDate": "2016-02-25T16:43:40.303"}});