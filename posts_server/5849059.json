post_cb({"5849247": {"ParentId": "5849059", "PostTypeId": "2", "CommentCount": "18", "Body": "<blockquote>\n<p id=\"so_5849059_5849247_0\">I'm asking if you can do something like:</p>\n</blockquote>\n<pre><code>Foo&lt;decltype([]()-&gt;void { })&gt; foo;\n</code></pre>\n<p>No you can't, because lambda expressions shall not appear in an unevaluated context (such as <code>decltype</code> and <code>sizeof</code>, amongst others).\nC++0x FDIS, 5.1.2 [expr.prim.lambda] p2</p>\n<blockquote>\n<p id=\"so_5849059_5849247_1\">The evaluation of a lambda-expression results in a prvalue temporary (12.2). This temporary is called the\n  closure object. <strong>A lambda-expression shall not appear in an unevaluated operand</strong> (Clause 5). [ Note: A\n  closure object behaves like a function object (20.8).\u2014end note ]\n  <em>(emphasis mine)</em></p>\n</blockquote>\n<p>You would need to first create a specific lambda and then use decltype on that:</p>\n<pre><code>auto my_comp = [](const std::string&amp; left, const std::string&amp; right) -&gt; bool {\n  // whatever\n}\n\ntypedef std::unordered_map&lt;\n  std::string,\n  std::string,\n  std::hash&lt;std::string&gt;,\n  decltype(my_comp)\n  &gt; map_type;\n</code></pre>\n<p>That is because each lambda-derived closure object could have a completely different type, they're like <em>anonymous</em> functions after all.</p>\n", "OwnerUserId": "500104", "LastEditorUserId": "500104", "LastEditDate": "2011-05-01T15:32:04.247", "Id": "5849247", "Score": "36", "CreationDate": "2011-05-01T15:17:42.153", "LastActivityDate": "2011-05-01T15:32:04.247"}, "5849059": {"CommentCount": "0", "AcceptedAnswerId": "5849247", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-05-01T14:45:05.780", "LastActivityDate": "2012-02-05T22:36:16.037", "LastEditDate": "2017-05-23T12:18:02.170", "ViewCount": "22438", "FavoriteCount": "17", "Title": "Lambda expressions as class template parameters", "Id": "5849059", "Score": "44", "Body": "<p>Can lambda expressions be used <em>as</em> class template parameters?  (Note this is a very different question than <a href=\"https://stackoverflow.com/questions/4124579/c0x-lambdas-with-template-parameters-closed\">this one</a>, which asks if a lambda expression itself can be templated.)</p>\n<p>I'm asking if you can do something like:</p>\n<pre><code>template &lt;class Functor&gt; \nstruct Foo { };\n// ...\nFoo&lt;decltype([]()-&gt;void { })&gt; foo;\n</code></pre>\n<p>This would be useful in cases where, for example, a class template has various parameters like <code>equal_to</code> or something, which are usually implemented as one-liner functors.  For example, suppose I want to instantiate a hash table which uses my own custom equality comparison function.  I'd like to be able to say something like:</p>\n<pre><code>typedef std::unordered_map&lt;\n  std::string,\n  std::string,\n  std::hash&lt;std::string&gt;,\n  decltype([](const std::string&amp; s1, const std::string&amp; s2)-&gt;bool \n    { /* Custom implementation of equal_to */ })\n  &gt; map_type;\n</code></pre>\n<p>But I tested this on GCC 4.4 and 4.6, and it doesn't work, apparently because the anonymous type created by a lambda expression doesn't have a default constructor.  (I recall a similar issue with <code>boost::bind</code>.)  Is there some reason the draft standard doesn't allow this, or am I wrong and it is allowed but GCC is just behind in their implementation?</p>\n", "Tags": "<c++><templates><lambda><c++11>", "OwnerUserId": "469408", "AnswerCount": "4"}, "5849431": {"ParentId": "5849059", "CommentCount": "7", "Body": "<p>@Xeo gave you the reason, so I'll give you the work around.</p>\n<p>Often times you do not wish to name a closure, in this case, you can use <code>std::function</code>, which is a type:</p>\n<pre><code>typedef std::unordered_map&lt;\n  std::string,\n  std::string,\n  std::hash&lt;std::string&gt;,\n  std::function&lt;bool(std::string const&amp;, std::string const&amp;)&gt;\n  &gt; map_type;\n</code></pre>\n<p>Note that it captures exactly the signature of the function, and no more.</p>\n<p>Then you may simply write the lambda when building the map.</p>\n<p>Note that with <code>unordered_map</code>, if you change the equality comparison, you'd better change the hash to match the behavior. Objects that compare equal shall have the same hash.</p>\n", "OwnerUserId": "147192", "PostTypeId": "2", "Id": "5849431", "Score": "5", "CreationDate": "2011-05-01T15:45:01.833", "LastActivityDate": "2011-05-01T15:45:01.833"}, "5849520": {"ParentId": "5849059", "CommentCount": "7", "Body": "<p>You can't do this with a closure, because the state is not contained in the type.</p>\n<p>If your lambda is stateless (no captures), then you should be ok.  In this case the lambda decays to an ordinary function pointer, which you can use as a template argument instead of some lambda type.</p>\n<p>gcc doesn't like it though.  <a href=\"http://ideone.com/bHM3n\" rel=\"nofollow\">http://ideone.com/bHM3n</a></p>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "5849520", "Score": "4", "CreationDate": "2011-05-01T16:00:44.893", "LastActivityDate": "2011-05-01T16:00:44.893"}, "5849302": {"ParentId": "5849059", "CommentCount": "1", "Body": "<p>You will have to use either a run-time abstract type, like <code>std::function</code>, or create the type as a local variable or as part of a templated class.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "5849302", "Score": "0", "CreationDate": "2011-05-01T15:25:05.777", "LastActivityDate": "2011-05-01T15:25:05.777"}, "bq_ids": {"n4140": {"so_5849059_5849247_0": {"section_id": 6433, "quality": 0.8, "length": 4}, "so_5849059_5849247_1": {"section_id": 5961, "quality": 0.6785714285714286, "length": 19}}, "n3337": {"so_5849059_5849247_0": {"section_id": 6190, "quality": 0.8, "length": 4}, "so_5849059_5849247_1": {"section_id": 5730, "quality": 0.6785714285714286, "length": 19}}, "n4659": {"so_5849059_5849247_1": {"section_id": 7448, "quality": 0.5357142857142857, "length": 15}, "so_5849059_5849247_0": {"section_id": 6440, "quality": 0.8, "length": 4}}}});