post_cb({"31203839": {"CommentCount": "6", "ViewCount": "436", "PostTypeId": "1", "LastEditorUserId": "2430597", "CreationDate": "2015-07-03T09:54:56.030", "LastActivityDate": "2015-07-04T05:08:10.043", "Title": "Mapping signed integer ranges to unsigned", "AcceptedAnswerId": "31203972", "LastEditDate": "2015-07-03T11:00:48.803", "Id": "31203839", "Score": "5", "Body": "<p>I'm facing a problem where signed integers should be converted to unsigneds, preserving their range and order.</p>\n<p>Given the following definition:</p>\n<pre><code>#include &lt;limits&gt;\n\n#define MIN(X) std::numeric_limits&lt;X&gt;::min();\n#define MAX(X) std::numeric_limits&lt;X&gt;::max();\n</code></pre>\n<p>What is the fastest and correct way to map the signed range <strong>[MIN(T), MAX(T)]</strong> to the unsigned range <strong>[0, MAX(U)]</strong>?</p>\n<p>where:</p>\n<blockquote>\n<p id=\"so_31203839_31203839_0\"><strong>T is a signed integer type</strong></p>\n<p id=\"so_31203839_31203839_1\"><strong>U is an unsigned integer type</strong></p>\n<p id=\"so_31203839_31203839_2\"><strong>sizeof(T) == sizeof(U)</strong></p>\n</blockquote>\n<p>I tried various bit twiddling and numeric methods to come up with a solution, without success.</p>\n", "Tags": "<c++><c++11><integer><int>", "OwnerUserId": "2430597", "AnswerCount": "1"}, "31203972": {"ParentId": "31203839", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-07-03T10:00:52.947", "Score": "6", "LastEditorUserId": "2659313", "LastEditDate": "2015-07-04T05:08:10.043", "Id": "31203972", "OwnerUserId": "2659313", "Body": "<pre><code>unsigned int signedToUnsigned(signed int s) {\n  unsigned int u =  1U + std::numeric_limits&lt;int&gt;::max();\n  u += s;\n  return u;\n}\n</code></pre>\n<p><a href=\"http://ideone.com/WLOnbs\" rel=\"nofollow\">Live example here</a></p>\n<p>This will add <code>signed_max + 1</code> to <code>signed int</code> to ensure <code>[MIN(int), MAX(int)]</code> is mapped to <code>[0, MAX(unsigned int)]</code></p>\n<hr>\n<p><strong>Why would this answer work and map correctly:</strong></p>\n<p>When you add a signed integral number to an unsigned, the signed number is promoted to unsigned type. From Section 4.7 [conv.integral]</p>\n<blockquote>\n<p id=\"so_31203839_31203972_0\">If the destination type is unsigned, the resulting value is the least\n  unsigned integer congruent to the source integer (modulo 2<sup>n</sup>\n  where n is the number of bits used to represent the unsigned type). [\n  Note: In a two\u2019s complement representation, this conversion is\n  conceptual and there is no change in the bit pattern (if there is no\n  truncation). \u2014end note ]</p>\n</blockquote>\n</hr>", "LastActivityDate": "2015-07-04T05:08:10.043"}, "bq_ids": {"n4140": {"so_31203839_31203972_0": {"section_id": 31, "quality": 0.90625, "length": 29}}, "n3337": {"so_31203839_31203972_0": {"section_id": 28, "quality": 0.90625, "length": 29}}, "n4659": {"so_31203839_31203972_0": {"section_id": 31, "quality": 0.90625, "length": 29}}}});