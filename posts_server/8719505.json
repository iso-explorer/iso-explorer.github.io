post_cb({"8719546": {"Id": "8719546", "PostTypeId": "2", "Body": "<p><code>std::set</code> only offers const iterators, because modifying the objects while they're in the set would break set invariant. So, you can't do what you want with <code>std::set</code>, you need to either readd the new object, or use a different container.</p>\n", "LastActivityDate": "2012-01-03T22:28:33.983", "CommentCount": "1", "CreationDate": "2012-01-03T22:28:33.983", "ParentId": "8719505", "Score": "4", "OwnerUserId": "16102"}, "bq_ids": {"n4140": {"so_8719505_8719630_0": {"length": 46, "quality": 0.9019607843137255, "section_id": 742}}, "n3337": {"so_8719505_8719630_0": {"length": 46, "quality": 0.9019607843137255, "section_id": 731}}, "n4659": {"so_8719505_8719630_0": {"length": 44, "quality": 0.8627450980392157, "section_id": 800}}}, "8719542": {"Id": "8719542", "PostTypeId": "2", "Body": "<p>The obvious error with your code is that you're using <code>-&gt;</code> instead of <code>.</code> on this line:</p>\n<pre><code>(*itP).hDisponibles-&gt;push_back(0);  // should be itP-&gt;hDisponibles.push_back(0);\n</code></pre>\n<p>But I have a feeling there are more errors related to syntax somewhere.  Please post a more complete summary of the code and the errors you're getting.</p>\n", "LastActivityDate": "2012-01-03T22:28:09.943", "CommentCount": "1", "CreationDate": "2012-01-03T22:28:09.943", "ParentId": "8719505", "Score": "1", "OwnerUserId": "22780"}, "8719505": {"ViewCount": "1366", "Body": "<p>I have a profesor class with this atribute </p>\n<pre><code>vector&lt;int&gt; hDisponibles;\n</code></pre>\n<p>If I have a vector of this class </p>\n<pre><code>set&lt;profesor&gt; profesores;\n</code></pre>\n<p>I try this</p>\n<pre><code>set&lt;profesor&gt;::iterator itP;\nitP = profesores.begin();    \nwhile ( itP != profesores.end() ){                \n    (*itP).hDisponibles-&gt;push_back(0);                                                    \n    itP++;\n}\n</code></pre>\n<p>but this errors</p>\n<pre><code>utils.cpp:138: error: passing \u2018const std::vector&lt;int, std::allocator&lt;int&gt; &gt;\u2019 as \u2018this\u2019     argument of \u2018void std::vector&lt;_Tp, _Alloc&gt;::push_back(const _Tp&amp;) [with _Tp = int, _Alloc = std::allocator&lt;int&gt;]\u2019 discards qualifiers\n</code></pre>\n", "AcceptedAnswerId": "8719630", "Title": "push_back in a vector in a object", "CreationDate": "2012-01-03T22:24:14.703", "Id": "8719505", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2012-01-03T22:49:31.547", "Score": "1", "OwnerUserId": "348081", "Tags": "<c++><vector><iterator><push-back>", "AnswerCount": "3"}, "8719630": {"Id": "8719630", "PostTypeId": "2", "Body": "<p>Your problem is that the <code>vector</code> you are trying to call <code>push_back</code> on is <code>const</code>. This is because (since C++11) the elements of a <code>std::set</code> are accessed through <code>const_iterators</code>, since changing them might change how they compare and therefore corrupt the <code>set</code>. To solve that you have two options:</p>\n<ol>\n<li>If <code>hDisponibles</code> has no effect on how <code>profesor</code> compare and it doesn't do to much damage to your overall structure you can declare it <code>mutable</code> like this: <code>mutable vector&lt;int&gt; hDisponibles;</code>. <code>mutable</code> members can be changed even if the structure they reside in is <code>const</code></li>\n<li>I that is not an option, you have to remove the <code>profesor</code> from the set (into a temporary), do your <code>push_back</code> and reinsert it (be careful about iterator invalidation). Of course this is quite costly.</li>\n</ol>\n<p>Your code as posted has an additional bug, since <code>hdisponsibles</code> is an object, but <code>push_back</code> is called as if it was a pointer. From your compilermessage it doesn't seem like that bug is in your actual code, but just in case it should be:</p>\n<pre><code>(*itP).hDisponibles.push_back(0);    \n</code></pre>\n<p><strong>Edit:</strong> Found the section in the standard draft (the value type is the same as the key for <code>set</code> and <code>multiset</code>: N3290 \u00a723.2.4/6</p>\n<blockquote>\n<p id=\"so_8719505_8719630_0\">iterator of an associative container is of the bidirectional iterator\n  category. For associative containers where  the value type is the same\n  as the key type, both iterator and const_iterator are constant\n  iterators. It is unspeci\ufb01ed whether or not iterator and const_iterator\n  are the same type. [Note: iterator and const_iterator have identical\n  semantics in this case, and iterator is convertible to const_iterator.\n  Users can avoid violating the One De\ufb01nition Rule by always using\n  const_iterator in their function parameter lists. \u2014endnote ]</p>\n</blockquote>\n", "LastEditorUserId": "201270", "LastActivityDate": "2012-01-03T22:49:31.547", "Score": "3", "CreationDate": "2012-01-03T22:37:33.227", "ParentId": "8719505", "CommentCount": "2", "OwnerUserId": "201270", "LastEditDate": "2012-01-03T22:49:31.547"}});