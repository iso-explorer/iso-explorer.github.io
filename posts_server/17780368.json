post_cb({"bq_ids": {"n4140": {"so_17780368_17780820_2": {"length": 5, "quality": 1.0, "section_id": 6732}, "so_17780368_17780820_3": {"length": 6, "quality": 0.75, "section_id": 6774}, "so_17780368_17780820_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 6774}}, "n3337": {"so_17780368_17780820_2": {"length": 5, "quality": 1.0, "section_id": 6487}, "so_17780368_17780820_3": {"length": 6, "quality": 0.75, "section_id": 6529}, "so_17780368_17780820_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 6529}}}, "17780368": {"CreationDate": "2013-07-22T05:15:16.093", "ViewCount": "404", "FavoriteCount": "1", "Id": "17780368", "Score": "1", "Title": "Serializing floats to bytes, when already assuming __STDC_IEC_559__", "LastEditorUserId": "-1", "CommentCount": "1", "Body": "<p>If I test my code with the following:</p>\n<pre><code>#ifndef __STDC_IEC_559__\n    #error Warning: __STDC_IEC_559__ not defined. The code assumes we're using the IEEE 754 floating point for binary serialization of floats and doubles.\n#endif\n</code></pre>\n<p>...such as is described <a href=\"https://stackoverflow.com/a/753018/1177073\">here</a>, am I guaranteed that this:</p>\n<pre><code>float myFloat = ...;\nunsigned char *data = reinterpret_cast&lt;unsigned char*&gt;(&amp;myFloat)\n\nunsigned char buffer[4];\nstd::memcpy(&amp;Buffer[0], data, sizeof(float));\n</code></pre>\n<p>...would safely serialize the float for writing to a file or network packet?</p>\n<p>If not, how can I safely serialize floats and doubles?</p>\n<p>Also, who's responsible for byte ordering - my code or the Operating System?</p>\n<p>To clarifiy my question: Can I cast floats to 4 bytes and doubles to 8 bytes, and safely serialize to and from files or across networks, if I:</p>\n<ol>\n<li>Assert that we're using IEC 559</li>\n<li>Convert the resulting to/from a standard byte order (such as network byte order).</li>\n</ol>\n", "Tags": "<c++><serialization><c++11><floating-point><ieee-754>", "LastEditDate": "2017-05-23T11:58:35.500", "LastActivityDate": "2013-07-23T00:55:52.540", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "1177073"}, "17780820": {"LastActivityDate": "2013-07-23T00:55:52.540", "CommentCount": "1", "Body": "<p><code>__STDC_IEC_559__</code> is a macro defined by C99/C11, I didn't find reference about whether C++ guarantees to support it.</p>\n<p>A better solution is to use <code>std::numeric_limits&lt; float &gt;::is_iec559</code> or <code>std::numeric_limits&lt; double &gt;::is_iec559</code></p>\n<p>C++11 18.2.1.1 Class template numeric_limits</p>\n<blockquote>\n<p id=\"so_17780368_17780820_0\">static const bool is_iec559 ;</p>\n<p id=\"so_17780368_17780820_1\">52 True if and only if the type adheres to IEC 559 standard.210)</p>\n<p id=\"so_17780368_17780820_2\">53 Meaningful for all floating point types.</p>\n</blockquote>\n<p>In the footnote:</p>\n<blockquote>\n<p id=\"so_17780368_17780820_3\">210) International Electrotechnical Commission standard 559 is the same as IEEE 754.</p>\n</blockquote>\n<p>About your second assumption, I don't think you can say any byte order is \"standard\", but if the byte order is the same between machines(little or big endian), then yes, I think you can serialize like that.</p>\n", "CreationDate": "2013-07-22T05:57:00.823", "LastEditDate": "2013-07-23T00:55:52.540", "ParentId": "17780368", "Id": "17780820", "LastEditorUserId": "1009479", "PostTypeId": "2", "Score": "2", "OwnerUserId": "1009479"}, "17780490": {"LastActivityDate": "2013-07-22T22:11:00.653", "CommentCount": "8", "Body": "<p>How about considering standard serialization like XDR [used in Unix RPC] or CDR etc ?</p>\n<p><a href=\"http://en.wikipedia.org/wiki/External_Data_Representation\" rel=\"nofollow\">http://en.wikipedia.org/wiki/External_Data_Representation</a></p>\n<p>for example :\n bool_t xdr_float(XDR *xdrs, float *fp); from linux.die.net/man/3/xdr</p>\n<p>or a c++ library \n<a href=\"http://xstream.sourceforge.net/\" rel=\"nofollow\">http://xstream.sourceforge.net/</a></p>\n<p>You might also be intersted in CDR [used by CORBA] , ACE [adaptive communication environment] has CDR classes [But its very heavy library]</p>\n", "CreationDate": "2013-07-22T05:27:05.093", "LastEditDate": "2013-07-22T22:11:00.653", "ParentId": "17780368", "Id": "17780490", "LastEditorUserId": "1807864", "PostTypeId": "2", "Score": "1", "OwnerUserId": "1807864"}});