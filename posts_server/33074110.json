post_cb({"33074895": {"ParentId": "33074110", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This issue has been raised before but I cannot find the relevant bug report. Here's a <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/899154/lambda-in-static-initializer-cant-access-private-members-of-class-in-vc-2013\">broken link</a> for a MSVC bug report that was supposedly filed (it's still not fixed in 2015: you can test it at <a href=\"http://webcompiler.cloudapp.net/\">rise4fun</a>). It has however been fixed somewhere between 4.7 and 4.8 for GCC. The relevant standardese used to back this up as a bug is:</p>\n<blockquote>\n<p id=\"so_33074110_33074895_0\">[C++11, 9.4.2/2] The initializer expression in the de\ufb01nition of a\n  <code>static</code> data member is in the scope of its class.</p>\n<p id=\"so_33074110_33074895_1\">[C++11, 5.1.2/2] The evaluation of a lambda-expression results in a prvalue temporary (12.2). This temporary is called the closure object. A lambda-expression shall not appear in an unevaluated operand (Clause 5).</p>\n<p id=\"so_33074110_33074895_2\">[C++11, 5.1.2/3] The type of the lambda-expression (which is also the\n  type of the closure object) is a unique, unnamed non-union class type\n  \u2014 called the closure type \u2014 whose properties are described below. This\n  class type is not an aggregate (8.5.1). The closure type is declared\n  in the smallest block scope, class scope, or namespace scope that\n  contains the corresponding lambda-expression.</p>\n</blockquote>\n<p><strong>Previously</strong></p>\n<p><a href=\"https://stackoverflow.com/questions/24273136/why-lambda-in-static-initializer-cant-access-private-members-of-class-in-vc20\">Why lambda in static initializer can't access private members of class in VC++2013?</a></p>\n<p><a href=\"https://stackoverflow.com/questions/24237729/c11-lambdas-can-access-my-private-members-why\">C++11 lambdas can access my private members. Why?</a></p>\n<p><a href=\"https://stackoverflow.com/questions/11933999/why-is-it-not-possible-to-use-private-method-in-a-lambda\">Why is it not possible to use private method in a lambda?</a></p>\n", "OwnerUserId": "5434961", "LastEditorUserId": "5434961", "LastEditDate": "2015-10-12T07:02:13.717", "Id": "33074895", "Score": "7", "CreationDate": "2015-10-12T06:52:40.893", "LastActivityDate": "2015-10-12T07:02:13.717"}, "33074110": {"CommentCount": "3", "AcceptedAnswerId": "33074895", "PostTypeId": "1", "LastEditorUserId": "3159253", "CreationDate": "2015-10-12T05:53:28.417", "LastActivityDate": "2015-10-12T07:37:17.423", "LastEditDate": "2015-10-12T07:37:17.423", "ViewCount": "536", "FavoriteCount": "2", "Title": "lambda scope for static members initializer", "Id": "33074110", "Score": "9", "Body": "<p>My question is about lambda scope for the static member initializers. Consider the following test:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\nstruct S {\n    static const std::function&lt;void(void)&gt; s_func;\n};\n\nconst std::function&lt;void(void)&gt; S::s_func = []() {\n    std::cout &lt;&lt; \"Hello from \" &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; std::endl;\n};\n\nint main(void) {\n    S::s_func();\n    return 0;\n}\n</code></pre>\n<p>gcc starting from 4.8 defines the lambda in the scope of S, so the program outputs something like this:</p>\n<pre><code>Hello from S::&lt;lambda()&gt;\n</code></pre>\n<p>(gcc-4.8.2 has a different definition for <code>__FUNCTION__</code> &amp; Co macros, but nevertheless the lambda is still defined within <code>S</code>)</p>\n<p>Meanwhile gcc-4.7 defines the lambda in the global scope, so the program outputs</p>\n<pre><code>Hello from &lt;lambda()&gt;\n</code></pre>\n<p>Probably newer gcc are more standard-compliant. However I'd like to ask if the standard actually specifies this aspect or it can be implementation-dependent.</p>\n<p><strong>Update</strong>: as @user5434961 suggested that all <code>__FUNCTION__</code>-alike macros are implementation dependent, so it's better to avoid them in a standard-compliant test. So here is the example which can be compiled if a compiler defines such lambdas within <code>S</code> scope and breaks the compilation otherwise:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\nstruct S {\n    static const std::function&lt;void(void)&gt; s_func;\nprivate:\n    static const int s_field;\n};\n\nconst std::function&lt;void(void)&gt; S::s_func = []() {\n    std::cout &lt;&lt; \"Hello from S::s_func. S::s_field = \" &lt;&lt; S::s_field &lt;&lt; std::endl;\n};\n\nconst int S::s_field = 1;\n\nint main(void) {\n    S::s_func();\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><c++11><lambda>", "OwnerUserId": "3159253", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_33074110_33074895_0": {"section_id": 5907, "quality": 0.6666666666666666, "length": 8}, "so_33074110_33074901_0": {"section_id": 5962, "quality": 0.5172413793103449, "length": 15}, "so_33074110_33074895_2": {"section_id": 5962, "quality": 0.825, "length": 33}, "so_33074110_33074895_1": {"section_id": 5961, "quality": 0.6842105263157895, "length": 13}}, "n3337": {"so_33074110_33074895_0": {"section_id": 5679, "quality": 0.6666666666666666, "length": 8}, "so_33074110_33074901_0": {"section_id": 5731, "quality": 0.5172413793103449, "length": 15}, "so_33074110_33074895_2": {"section_id": 5731, "quality": 0.825, "length": 33}, "so_33074110_33074895_1": {"section_id": 5730, "quality": 0.6842105263157895, "length": 13}}, "n4659": {"so_33074110_33074895_0": {"section_id": 7389, "quality": 0.6666666666666666, "length": 8}}}, "33074901": {"ParentId": "33074110", "CommentCount": "2", "Body": "<p>I guess it should be in the class scope. Quoted from <a href=\"http://en.cppreference.com/w/cpp/language/lambda\" rel=\"nofollow\">cppreference</a> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_33074110_33074901_0\">The lambda expression constructs an unnamed prvalue temporary object\n  of unique unnamed non-union non-aggregate type, known as closure type,\n  which is declared (for the purposes of ADL) <strong>in the smallest block\n  scope, class scope, or namespace scope that contains the lambda\n  expression</strong>.</p>\n</blockquote>\n<p>In the out-of-line definition of <code>S::s_func</code>, you enter into the scope of <code>S</code> the time <code>S::</code> is encountered. So, the lambda expression is contained in the class scope of <code>S</code>. As the closer type is a member of <code>S</code>, access to private members of <code>S</code> is granted.</p>\n", "OwnerUserId": "1348273", "PostTypeId": "2", "Id": "33074901", "Score": "4", "CreationDate": "2015-10-12T06:53:06.783", "LastActivityDate": "2015-10-12T06:53:06.783"}});