post_cb({"18456314": {"CommentCount": "0", "ViewCount": "189", "PostTypeId": "1", "LastEditorUserId": "1196603", "CreationDate": "2013-08-27T03:09:37.047", "LastActivityDate": "2014-07-06T14:03:05.090", "Title": "Is it safe to call other virtual methods in virtual destructor?", "AcceptedAnswerId": "18456362", "LastEditDate": "2014-07-06T14:03:05.090", "Id": "18456314", "Score": "1", "Body": "<pre><code>struct A\n{\n    virtual ~A() { this-&gt;f(); }\n\n    virtual void f() {};\n};\n\nstruct B : A\n{\n    int* p;\n\n    B() : p(new int) {}\n\n    ~B()\n    {\n        delete p;\n        p = 0;\n    }\n\n    void f() override { *p = 0; }\n};\n\nint main()\n{\n    delete new B; // Is it safe?\n}\n</code></pre>\n<p>Is it safe to call other virtual methods in virtual destructor?</p>\n", "Tags": "<c++><c++11><polymorphism><destructor>", "OwnerUserId": "508343", "AnswerCount": "2"}, "18456362": {"ParentId": "18456314", "LastEditDate": "2013-08-27T03:21:42.483", "CommentCount": "2", "CreationDate": "2013-08-27T03:16:24.427", "OwnerUserId": "273767", "LastEditorUserId": "273767", "PostTypeId": "2", "Id": "18456362", "Score": "2", "Body": "<p>It is safe if you know the rules, and the rules say that within a destructor, the dynamic type of the object is the class whose destructor is executing. </p>\n<p>While <code>B::~B()</code> is executing, the type of the object is <code>B</code> (and if you call <code>f()</code> then, you'll get dispatched to <code>B::f()</code></p>\n<p>While <code>A::~A()</code> is executing, the type of the object is <code>A</code>, and if you call <code>f()</code> then, you get undefined behavior per \u00a710.4[class.abstract]/6</p>\n<blockquote>\n<p id=\"so_18456314_18456362_0\">Member functions can be called from a constructor (or destructor) of an abstract class; the effect of making a virtual call to a pure virtual function directly or indirectly for the object being created (or destroyed) from such a constructor (or destructor) is <strong>undefined</strong></p>\n</blockquote>\n<p>Or, as clang++ reports it,</p>\n<pre><code>test.cc:5:20: warning: call to pure virtual member function 'f'; overrides of 'f' in subclasses are not available in the destructor of 'A'\n    virtual ~A() { this-&gt;f(); }\n                   ^\ntest.cc:7:5: note: 'f' declared here\n    virtual void f() = 0;\n    ^\n1 warning generated.\n</code></pre>\n<p>EDIT: OP edited pure virtual out.. so, then, while <code>A::~A()</code> is executing, virtual call to <code>f()</code> gets dispatched to <code>A::f()</code></p>\n", "LastActivityDate": "2013-08-27T03:21:42.483"}, "18456374": {"ParentId": "18456314", "CommentCount": "0", "Body": "<p>Note: the OP edited the code to remove the pure virtual part.</p>\n<p>With what you have posted, no it is not safe. When you call a virtual function in a constructor or destructor of a class in an inheritance hierarchy, it does not call the most derived function as usual, but calls the function defined within the current class.</p>\n<p>In this case, ~A calls A::f() which has no function body, so this is an error. If you provided a body for A::f() (you can do this with pure virtuals, just outside the class definition), then it would be \"safe\", although whether it does what you want is another matter.</p>\n", "OwnerUserId": "2068573", "PostTypeId": "2", "Id": "18456374", "Score": "1", "CreationDate": "2013-08-27T03:18:01.583", "LastActivityDate": "2013-08-27T03:18:01.583"}, "bq_ids": {"n4140": {"so_18456314_18456362_0": {"section_id": 7023, "quality": 1.0, "length": 25}}, "n3337": {"so_18456314_18456362_0": {"section_id": 6769, "quality": 1.0, "length": 25}}, "n4659": {"so_18456314_18456362_0": {"section_id": 8520, "quality": 1.0, "length": 25}}}});