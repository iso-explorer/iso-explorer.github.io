post_cb({"bq_ids": {"n4140": {"so_37463861_37464714_2": {"length": 21, "quality": 0.9545454545454546, "section_id": 6348}, "so_37463861_37464714_3": {"length": 22, "quality": 0.8461538461538461, "section_id": 6349}}, "n3337": {"so_37463861_37464714_2": {"length": 21, "quality": 0.9545454545454546, "section_id": 6105}, "so_37463861_37464714_3": {"length": 22, "quality": 0.8461538461538461, "section_id": 6106}}, "n4659": {"so_37463861_37464714_2": {"length": 21, "quality": 0.9545454545454546, "section_id": 7857}, "so_37463861_37464714_3": {"length": 22, "quality": 0.8461538461538461, "section_id": 7858}}}, "37464714": {"Id": "37464714", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_37463861_37464714_0\">but the process that fills the input buffer will always be complete before the next stage of possibly parallel processes will execute</p>\n</blockquote>\n<p>If this is guaranteed then there is not a problem having multiple reads from different threads for const objects.</p>\n<p>I don't have the official standard so the following is from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">n4296</a>:</p>\n<blockquote>\n<p id=\"so_37463861_37464714_1\"><strong>17.6.5.9 Data race avoidance</strong></p>\n<p id=\"so_37463861_37464714_2\"><sup>3</sup> A C++ standard library function shall not directly or indirectly modify objects (1.10) accessible by threads\n  other than the current thread unless the objects are accessed directly or indirectly via the function\u2019s non-const\n  arguments, including this.</p>\n<p id=\"so_37463861_37464714_3\"><sup>4</sup> [ Note: This means, for example, that implementations can\u2019t use a static object for internal purposes without\n  synchronization because it could cause a data race even in programs that do not explicitly share objects\n  between threads. \u2014end note ]</p>\n</blockquote>\n<hr>\n<p>Here is the <a href=\"https://channel9.msdn.com/posts/C-and-Beyond-2012-Herb-Sutter-You-dont-know-blank-and-blank\" rel=\"nofollow\">Herb Sutter video</a> where I first learned about the meaning of <code>const</code> in the C++11 standard. (see around 7:00 to 10:30)</p>\n</hr>", "LastEditorUserId": "4505712", "LastActivityDate": "2016-05-26T16:24:24.143", "Score": "2", "CreationDate": "2016-05-26T15:08:43.947", "ParentId": "37463861", "CommentCount": "0", "OwnerUserId": "4505712", "LastEditDate": "2016-05-26T16:24:24.143"}, "37464110": {"Id": "37464110", "PostTypeId": "2", "Body": "<p>No, you are OK. Multiple reads from the same constant source are OK and do not pose any risks in all threading models I know of (namely, Posix and Windows).</p>\n<p>However,</p>\n<blockquote>\n<p id=\"so_37463861_37464110_0\">but the process that fills the input buffer will always be complete</p>\n</blockquote>\n<p>What are the guarantees here? How do you really know this is the case? Do you have a synchronization?</p>\n", "LastActivityDate": "2016-05-26T14:43:17.983", "CommentCount": "3", "CreationDate": "2016-05-26T14:43:17.983", "ParentId": "37463861", "Score": "1", "OwnerUserId": "5245033"}, "37463861": {"ViewCount": "76", "Body": "<p>What should I be concerned about as far as thread safety and undefined behavior goes in a situation where multiple threads are reading from a single source that is constant?</p>\n<p>I am working on a signal processing model that allows for parallel execution of independent processes, these processes may share an input buffer, but the process that fills the input buffer will always be complete before the next stage of possibly parallel processes will execute.</p>\n<p>Do I need to worry about thread safety issues in this situation? and what could i do about it?</p>\n<p>I would like to note that a lock free solution would be best if possible</p>\n", "AcceptedAnswerId": "37464714", "Title": "Thread Safety: Multiple threads reading from a single const source", "CreationDate": "2016-05-26T14:32:39.840", "Id": "37463861", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2016-05-26T15:17:41.857", "LastEditorUserId": "4505712", "LastActivityDate": "2016-05-26T16:24:24.143", "Score": "1", "OwnerUserId": "1865694", "Tags": "<c++><multithreading><thread-safety>", "AnswerCount": "2"}});