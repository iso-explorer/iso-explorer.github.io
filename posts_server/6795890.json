post_cb({"6795890": {"CommentCount": "11", "AcceptedAnswerId": "7562555", "PostTypeId": "1", "LastEditorUserId": "3204551", "CreationDate": "2011-07-22T20:43:08.580", "LastActivityDate": "2016-08-28T20:17:28.473", "LastEditDate": "2015-01-23T23:40:55.460", "ViewCount": "1837", "FavoriteCount": "16", "Title": "Weird use of `?:` in `typeid` code", "Id": "6795890", "Score": "56", "Body": "<p>In one of the projects I'm working on, I'm seeing this code</p>\n<pre><code>struct Base {\n  virtual ~Base() { }\n};\n\nstruct ClassX {\n  bool isHoldingDerivedObj() const {\n    return typeid(1 ? *m_basePtr : *m_basePtr) == typeid(Derived);\n  }\n  Base *m_basePtr;\n};\n</code></pre>\n<p>I have never seen <code>typeid</code> used like that. Why does it do that weird dance with <code>?:</code>, instead of just doing <code>typeid(*m_basePtr)</code>? Could there be any reason? <code>Base</code> is a polymorphic class (with a virtual destructor). </p>\n<p>EDIT: At another place of this code, I'm seeing this and it appears to be equivalently \"superfluous\"</p>\n<pre><code>template&lt;typename T&gt; T &amp;nonnull(T &amp;t) { return t; }\n\nstruct ClassY {\n  bool isHoldingDerivedObj() const {\n    return typeid(nonnull(*m_basePtr)) == typeid(Derived);\n  }\n  Base *m_basePtr;\n};\n</code></pre>\n", "Tags": "<c++><conditional-operator><micro-optimization><typeid>", "OwnerUserId": "34509", "AnswerCount": "4"}, "7562555": {"ParentId": "6795890", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>I think <strong>it is an optimisation</strong>! A little known and rarely (you could say \"never\") used feature of <code>typeid</code> is that a null dereference of the argument of <code>typeid</code> throws an exception instead of the usual UB.</p>\n<blockquote>\n<p id=\"so_6795890_7562555_0\">What? Are you serious? Are you drunk?</p>\n</blockquote>\n<p>Indeed. Yes. No.</p>\n<pre>\nint *p = 0;\n*p; // UB\ntypeid (*p); // throws\n</pre>\n<p>Yes, this is ugly, even by the C++ standard of language ugliness.</p>\n<p>OTOH, this does not work anywhere <strong>inside</strong> the argument of <code>typeid</code>, so adding any clutter will cancel this \"feature\":</p>\n<pre>\nint *p = 0;\ntypeid(1 ? *p : *p); // UB\ntypeid(identity(*p)); // UB\n</pre>\n<p>For the record: I am not claiming in this message that automatic checking by the compiler that a pointer is not null before doing a dereference is necessarily a crazy thing. I am only saying that doing this check when the dereference is the immediate argument of <code>typeid</code>, <strong>and not elsewhere</strong>, is totally crazy. (Maybe is was a prank inserted in some draft, and never removed.)</p>\n<p>For the record: I am not claiming in the previous \"For the record\" that it makes sense for the compiler to insert automatic checks that a pointer is not null, and to to throw an exception (as in Java) when a null is dereferenced: in general, throwing an exception on a null dereference is absurd. This is a programming error so an exception will not help. An assertion failure is called for.</p>\n", "OwnerUserId": "963864", "LastEditorUserId": "1621391", "LastEditDate": "2016-08-28T20:17:28.473", "Id": "7562555", "Score": "46", "CreationDate": "2011-09-26T23:33:50.737", "LastActivityDate": "2016-08-28T20:17:28.473"}, "28120744": {"ParentId": "6795890", "CommentCount": "0", "Body": "<p>This behaviour is covered by [expr.typeid]/2 (N3936):</p>\n<blockquote>\n<p id=\"so_6795890_28120744_0\">When <code>typeid</code> is applied to a glvalue expression whose type is a polymorphic class type, the result refers to a <code>std::type_info</code> object representing the type of the most derived object (that is, the dynamic type) to which the glvalue refers. If the glvalue expression is obtained by applying the unary <code>*</code> operator to a pointer and the pointer is a null pointer value, the <code>typeid</code> expression throws an exception  of a type that would match a handler of type <code>std::bad_typeid</code> exception.</p>\n</blockquote>\n<p>The expression <code>1 ? *p : *p</code> is always an lvalue. This is because <code>*p</code> is an lvalue, and [expr.cond]/4 says that if the second and third operand to the ternary operator have the same type and value category, then the result of the operator has that type and value category also.</p>\n<p>Therefore, <code>1 ? *m_basePtr : *m_basePtr</code> is an <strong>lvalue</strong> with type <code>Base</code>. Since <code>Base</code> has a virtual destructor, it is a polymorphic class type. </p>\n<p>Therefore, this code is indeed an example of \"When <code>typeid</code> is applied to a glvalue expression whose type is a polymorphic class type\" .</p>\n<hr>\n<p>Now we can read the rest of the above quote. The glvalue expression was <strong>not</strong> \"obtained by applying the unary <code>*</code> operator to a pointer\" - it was obtained via the ternary operator. Therefore the standard does not require that an exception be thrown if <code>m_basePtr</code> is null. </p>\n<p>The behaviour in the case that <code>m_basePtr</code> is null would be covered by the more general rules about dereferencing a null pointer (which are a bit murky in C++ actually but for practical purposes we'll assume that it causes undefined behaviour here).</p>\n<hr>\n<p>Finally: <em>why would someone write this?</em> I think curiousguy's answer is the most plausible suggestion so far: with this construct, the compiler does not have to insert a null pointer test and code to generate an exception, so it is a micro-optimization.</p>\n<p>Presumably the programmer is either happy enough that this will never be called with a null pointer, or happy to rely on a particular implementation's handling of null pointer dereference.</p>\n</hr></hr>", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "28120744", "Score": "3", "CreationDate": "2015-01-24T00:04:54.040", "LastActivityDate": "2015-01-24T00:04:54.040"}, "6965502": {"ParentId": "6795890", "CommentCount": "0", "Body": "<p>I suspect some compiler was, for the simple case of</p>\n<pre><code>typeid(*m_basePtr)\n</code></pre>\n<p>returning typeid(Base) <em>always</em>, regardless of the runtime type.  But turning it to an expression/temporary/rvalue made the compiler give the RTTI.</p>\n<p>Question is which compiler, when, etc.  I think GCC had problems with typeid early on, but it is a vague memory.</p>\n", "OwnerUserId": "881713", "PostTypeId": "2", "Id": "6965502", "Score": "0", "CreationDate": "2011-08-06T07:46:08.600", "LastActivityDate": "2011-08-06T07:46:08.600"}, "6796063": {"ParentId": "6795890", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The only effect I can see is that <code>1 ? X : X</code> gives you <code>X</code> as an <em>rvalue</em> instead of plain <code>X</code> which would be an <em>lvalue</em>.  This can matter to <code>typeid()</code> for things like arrays (decaying to pointers) but I don't think it would matter if <code>Derived</code> is known to be a class.  Perhaps it was copied from someplace where the rvalue-ness <em>did</em> matter?  That would support the comment about \"cargo cult programming\"</p>\n<p>Regarding the comment below I did a test and sure enough <code>typeid(array) == typeid(1 ? array : array)</code>, so in a sense I'm wrong, but my misunderstanding could still match the misunderstanding that lead to the original code!</p>\n", "OwnerUserId": "479989", "LastEditorUserId": "479989", "LastEditDate": "2011-07-22T21:07:41.363", "Id": "6796063", "Score": "5", "CreationDate": "2011-07-22T20:59:42.673", "LastActivityDate": "2011-07-22T21:07:41.363"}, "bq_ids": {"n4140": {"so_6795890_28120744_0": {"section_id": 6021, "quality": 1.0, "length": 45}}, "n3337": {"so_6795890_28120744_0": {"section_id": 5789, "quality": 0.8666666666666667, "length": 39}}, "n4659": {"so_6795890_28120744_0": {"section_id": 7520, "quality": 1.0, "length": 45}}}});