post_cb({"35094728": {"ParentId": "35094545", "CommentCount": "0", "Body": "<p>The memory in a <code>std::vector</code> is required to be contiguous, so it's typically represented as an array.</p>\n<p>Your question about the complexity of the operations on a <code>std::vector</code> is a good one - I remember wondering this myself when I first started programming. If you append an element to a <code>std::vector</code>, then it may have to perform a resize operation and copy over all the existing elements to a new array. This will take time O(n) in the worst case. However, the <a href=\"https://en.wikipedia.org/wiki/Amortized_analysis#Dynamic_Array\" rel=\"nofollow\"><em>amortized</em> cost</a> of appending an element is O(1). By this, we mean that the total cost of <em>any</em> sequence of n appends to a <code>std::vector</code> is always O(n). The intuition behind this is that the <code>std::vector</code> usually overallocates space in its array, leaving a lot of free slots for elements to be inserted into without a reallocation. As a result, most of the appends will take time O(1) even though every now and then you'll have one that takes time O(n).</p>\n<p>That said, the cost of performing an insertion elsewhere in a <code>std::vector</code> will be O(n), because you may have to shift everything down.</p>\n<p>You also asked why this is, if it defeats the purpose of having a dynamic array. Even if the <code>std::vector</code> just acted like a managed array, it's still a win over raw arrays. The <code>std::vector</code> knows its size, can do bounds-checking (with <code>at</code>), is an actual object (unlike an array), and doesn't decay to a pointer. These extra features - coupled with the extra logic to make appends work quickly - are almost always worth it.</p>\n", "OwnerUserId": "501557", "PostTypeId": "2", "Id": "35094728", "Score": "2", "CreationDate": "2016-01-29T21:54:38.343", "LastActivityDate": "2016-01-29T21:54:38.343"}, "35094545": {"CommentCount": "1", "ViewCount": "250", "PostTypeId": "1", "LastEditorUserId": "501557", "CreationDate": "2016-01-29T21:42:28.020", "LastActivityDate": "2016-01-29T22:00:05.017", "Title": "Does the std::vector implementation use an internal array or linked list or other?", "AcceptedAnswerId": "35094731", "LastEditDate": "2016-01-29T21:54:46.933", "Id": "35094545", "Score": "3", "Body": "<p>I've been told that std::vector has a C-style array on the inside implementation, but would that not negate the entire purpose of having a dynamic container?</p>\n<p>So is inserting a value in a vector an O(n) operation? Or is it O(1) like in a linked-list?</p>\n", "Tags": "<c++><arrays><vector><stl><time-complexity>", "OwnerUserId": "5850658", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_35094545_35094731_0": {"section_id": 955, "quality": 0.84375, "length": 27}}, "n3337": {"so_35094545_35094731_0": {"section_id": 943, "quality": 0.84375, "length": 27}}, "n4659": {"so_35094545_35094731_0": {"section_id": 1016, "quality": 0.84375, "length": 27}}}, "35094731": {"ParentId": "35094545", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From the C++11 standard, in the \"sequence containers\" library section (emphasis mine):</p>\n<blockquote>\n<p id=\"so_35094545_35094731_0\">[23.3.6.1 Class template <code>vector</code> overview][vector.overview]<br>\n  A vector is a sequence container that supports (amortized) constant time insert and erase operations at the\n  end; <em>insert and erase in the middle take linear time</em>. Storage management is handled automatically, though\n  hints can be given to improve efficiency.</br></p>\n</blockquote>\n<p>This does not defeat the purpose of dynamic size -- part of the point of vector is that not only is it very fast to access a single element, but scanning over the vector has very good <em>memory locality</em> because everything is tightly packed together. In practice, having good memory locality is very important because it greatly reduces cache misses, which has a large impact on runtime. This is a major advantage of <code>vector</code> over <code>list</code> in many situations, particularly those where you need to iterate over the entire container more often than you need to add or remove elements.</p>\n", "OwnerUserId": "3598119", "LastEditorUserId": "3598119", "LastEditDate": "2016-01-29T22:00:05.017", "Id": "35094731", "Score": "5", "CreationDate": "2016-01-29T21:54:46.177", "LastActivityDate": "2016-01-29T22:00:05.017"}});