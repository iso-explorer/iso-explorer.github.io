post_cb({"34541818": {"CommentCount": "0", "ViewCount": "50", "PostTypeId": "1", "LastEditorUserId": "4370109", "CreationDate": "2015-12-31T05:56:50.763", "LastActivityDate": "2016-07-06T16:04:53.720", "Title": "Why isn't bitand properly parsed to form an rvalue reference?", "AcceptedAnswerId": "34542059", "LastEditDate": "2016-07-06T16:04:53.720", "Id": "34541818", "Score": "2", "Body": "<p>An rvalue reference could be formed using an alternative token:  </p>\n<pre><code>int and i = 0;  \n</code></pre>\n<p>It could also be formed after splicing physical source lines to form logical source lines:  </p>\n<pre><code>int &amp;\\\n&amp; i = 0;\n</code></pre>\n<p><strong>So why doesn't the following program compile?</strong> </p>\n<pre><code>int main() {\n    int &amp;\\\nbitand i = 5;\n}\n</code></pre>\n<p>Based on the standard, I don't see why it shouldn't.</p>\n<blockquote>\n<p id=\"so_34541818_34541818_0\"><strong>[lex.digraph]</strong> In all respects of the language, each alternative token\n  behaves the same, respectively, as its primary token, except for its\n  spelling.</p>\n<p id=\"so_34541818_34541818_1\"><strong>[lex.phases]</strong> Each instance of a backslash character (\\) immediately\n  followed by a new-line character is deleted,  splicing physical source\n  lines to form logical source lines. Only the last backslash on any\n  physical source line shall be eligible for being part of such a\n  splice.</p>\n</blockquote>\n<p>Is there additional information that I missed, or is this a compiler bug?  </p>\n", "Tags": "<c++><c-preprocessor><token><language-lawyer><rvalue-reference>", "OwnerUserId": "908939", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_34541818_34541818_0": {"section_id": 5326, "quality": 0.9375, "length": 15}, "so_34541818_34541818_1": {"section_id": 5313, "quality": 0.9310344827586207, "length": 27}}, "n3337": {"so_34541818_34541818_0": {"section_id": 5123, "quality": 0.9375, "length": 15}, "so_34541818_34541818_1": {"section_id": 5110, "quality": 0.9310344827586207, "length": 27}}, "n4659": {"so_34541818_34541818_0": {"section_id": 6747, "quality": 0.9375, "length": 15}, "so_34541818_34541818_1": {"section_id": 6737, "quality": 0.9310344827586207, "length": 27}}}, "34542059": {"ParentId": "34541818", "CommentCount": "0", "Body": "<p>The backslash+newline sequence is a red herring. These things are removed before the tokenization phase (that's phase two and phase three of the translation, respectively). We can thus concentrate on these fragments instead:</p>\n<pre><code>&amp;&amp;\n&amp;bitand\n</code></pre>\n<p>The first line has one token, <code>&amp;&amp;</code>. The second line has two tokens, <code>&amp;</code> and <code>bitand</code>. The last token is equivalent to <code>&amp;</code> so the second line behaves exactly as if it contained two <code>&amp;</code> tokens. This is different from one <code>&amp;&amp;</code> token. The latter is composed of two <code>&amp;</code> characters, not two <code>&amp;</code> tokens.</p>\n", "OwnerUserId": "775806", "PostTypeId": "2", "Id": "34542059", "Score": "4", "CreationDate": "2015-12-31T06:21:04.983", "LastActivityDate": "2015-12-31T06:21:04.983"}});