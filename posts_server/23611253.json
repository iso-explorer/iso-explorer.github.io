post_cb({"bq_ids": {"n4140": {"so_23611253_23617539_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 7003}}, "n3337": {"so_23611253_23617539_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 6749}}, "n4659": {"so_23611253_23617539_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 8500}}}, "23617539": {"Id": "23617539", "PostTypeId": "2", "Body": "<p>Note that the notion of <em>final overrider</em> applies to a particular object, not to a class:</p>\n<blockquote>\n<p id=\"so_23611253_23617539_0\">A virtual member function <code>C::vf</code> of a class <strong>object</strong> <code>S</code> is a\n  <em>final overrider</em> unless the most derived class (1.8) of which S is a base class <strong>subobject</strong> (if any) declares or inherits another member\n  function that overrides <code>vf</code>. In a derived class, if a virtual member\n  function of a base class <strong>subobject</strong> has more than one final\n  overrider the program is ill-formed.</p>\n</blockquote>\n<p>Bold text is mine.</p>\n<p>The example in the standard doesn't use virtual inheritance. There are two <code>A</code> subobjects within <code>D</code> - let's call them <code>A1</code> and <code>A2</code>. <code>A::f</code> is a final overrider for <code>A::f</code> in <code>A1</code> and <code>B</code>. <code>C::f</code> is a final overrider in <code>C</code> (<code>A2</code> doesn't have a final overrider). The definition of <code>D</code> is well-formed because there is no single base class subobject for which <code>A::f</code> would have more than one final overrider in <code>D</code>.</p>\n<p>In your example, with virtual inheritance, there is only one <code>A</code> object, which is a base class subobject of both <code>B</code> and <code>C</code>. <code>A::f</code> is <strong>not</strong> a final overrider in <code>B</code>, because the most derived class of which <code>B</code> is a base class subobject (namely, <code>D</code>) inherits another member function that overrides <code>A::f</code> (namely, <code>C::f</code>).</p>\n<p>So, once again, there is no single base class subobject for which <code>A::f</code> would have more than one final overrider in <code>D</code>. <code>C::f</code> is a final overrider for <code>A::f</code> in <code>C</code> and <code>D</code> objects; <code>A</code> and <code>B</code> objects don't have a final overrider.</p>\n<p>And indeed, <a href=\"http://ideone.com/hiFzhU\" rel=\"nofollow\">this code</a> calls <code>C::f</code>:</p>\n<pre><code>// Setup the same as in the OP's example:\nD d;\nB* pB = &amp;d;\npB-&gt;f();  // calls C::f, not A::f\n</code></pre>\n", "LastEditorUserId": "1670129", "LastActivityDate": "2014-05-12T19:49:41.153", "Score": "0", "CreationDate": "2014-05-12T19:44:37.970", "ParentId": "23611253", "CommentCount": "0", "OwnerUserId": "1670129", "LastEditDate": "2014-05-12T19:49:41.153"}, "23611253": {"ViewCount": "133", "Body": "<p>This code doesn't compile because of \u00a710.3/2, i.e., virtual function <code>A::f</code> has more than one final overrider in <code>D</code>.</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A { public: virtual void f(){ std::cout &lt;&lt; \"A::f\" &lt;&lt; '\\n'; } };\nclass B : public virtual A { public: void f(){ std::cout &lt;&lt; \"B::f\" &lt;&lt; '\\n'; } };\nclass C : public virtual A { public: void f(){ std::cout &lt;&lt; \"C::f\" &lt;&lt; '\\n'; } };\nclass D : public B, public C { };\n\nint main()\n{\n    D d;\n    d.f();\n}\n</code></pre>\n<p>But contrary to my expectations this code compiles. Given that \u00a710.3/2 contains this sentence, <code>For convenience we say that any virtual function overrides itself</code>, it seems to me we have here the same problem mentioned above, i.e., the virtual function <code>A::f</code> has more than one final overrider in <code>D</code>, that is, <code>A::f</code> and <code>C::f</code>. As a matter of fact the call <code>d.f()</code> invokes <code>C::f</code>. Why is that?</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A { public: virtual void f(){ std::cout &lt;&lt; \"A::f\" &lt;&lt; '\\n'; } };\nclass B : public virtual A {};\nclass C : public virtual A { public: void f(){ std::cout &lt;&lt; \"C::f\" &lt;&lt; '\\n'; } };\nclass D : public B, public C { };\n\nint main()\n{\n    D d;\n    d.f();\n}\n</code></pre>\n", "Title": "I don't understand why the second version of the snippet compiles. AFAIK it shouldn't, because of \u00a710.3/2", "CreationDate": "2014-05-12T14:07:00.603", "LastActivityDate": "2014-05-12T19:49:41.153", "CommentCount": "8", "PostTypeId": "1", "ClosedDate": "2014-05-13T04:32:04.070", "Id": "23611253", "Score": "4", "OwnerUserId": "2548699", "Tags": "<c++><c++11><override><language-lawyer><virtual-functions>", "AnswerCount": "1"}});