post_cb({"6130158": {"ParentId": "6130100", "CommentCount": "0", "Body": "<p>Volatile is unlikely to do what you expect for a non-POD type. I would recommend passing a <code>char *</code> or <code>void *</code> aliasing the container to an empty function in a different translation unit. Since the compiler is unable to analyze the usage of the pointer, this will act as a compiler memory barrier, forcing the object out to the processor cache at least, and preventing most dead-value-elimination optimizations.</p>\n", "OwnerUserId": "36723", "PostTypeId": "2", "Id": "6130158", "Score": "4", "CreationDate": "2011-05-25T20:00:07.440", "LastActivityDate": "2011-05-25T20:00:07.440"}, "6130100": {"CommentCount": "10", "AcceptedAnswerId": "6130497", "PostTypeId": "1", "LastEditorUserId": "75889", "CreationDate": "2011-05-25T19:55:16.507", "LastActivityDate": "2011-05-25T20:38:51.827", "LastEditDate": "2011-05-25T20:09:05.033", "ViewCount": "5206", "FavoriteCount": "0", "Title": "Using volatile to prevent compiler optimization in benchmarking code?", "Id": "6130100", "Score": "6", "Body": "<p>I am creating a little program measure the performance difference between containers of types <code>boost::shared_ptr</code> and <code>boost::intrusive_ptr</code>. In order to prevent the compiler from optimizing away the copy I declare the variable as volatile. The loop looks like this:</p>\n<pre><code>// TestCopy measures the time required to create n copies of the given container.\n// Returns time in milliseconds.\ntemplate&lt;class Container&gt;\ntime_t TestCopy(const Container &amp; inContainer, std::size_t n) {\n    Poco::Stopwatch stopwatch;\n    stopwatch.start();\n    for (std::size_t idx = 0; idx &lt; n; ++idx)\n    {\n        volatile Container copy = inContainer; // Volatile!\n    }\n\n    // convert microseconds to milliseconds\n    return static_cast&lt;time_t&gt;(0.5 + (double(stopwatch.elapsed()) / 1000.0));\n}\n</code></pre>\n<p>The rest of the code can be found here: <a href=\"http://code.google.com/p/stacked-crooked/source/browse/trunk/PlayGroundCpp/RefcountPerformance/main.cpp\" rel=\"noreferrer\">main.cpp</a>.</p>\n<ul>\n<li>Will using volatile here prevent the compiler from optimizing away the copy?</li>\n<li>Are there any pitfalls that may invalidate the results?</li>\n</ul>\n<h3>Update</h3>\n<p>In response to @Neil Butterworth. Even when using the copy it still seems to me that the compiler could easily avoid the copy:</p>\n<pre><code>for (std::size_t idx = 0; idx &lt; n; ++idx)\n{\n    // gcc won't remove this copy?\n    Container copy = inContainer;\n    gNumCopies += copy.size();        \n}\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "75889", "AnswerCount": "3"}, "6130497": {"ParentId": "6130100", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The C++03 standard says that reads and writes to volatile data is observable behavior (C++ 2003, 1.9 [intro.execution] / 6). I believe this guarantees that assignment to volatile data cannot be optimized away. Another kind of observable behavior is calls to I/O functions.\nThe C++11 standard is even more unambiguous in this regard: in 1.9/8 it explicitly says that </p>\n<blockquote>\n<p id=\"so_6130100_6130497_0\">The least requirements on a conforming implementation are:<br>\n  \u2014 Access to volatile objects are evaluated strictly according to the rules of the abstract machine.</br></p>\n</blockquote>\n<p>If a compiler can prove that a code does not produce an observable behavior then it can optimize the code away. In your update (where volatile is not used), copy constructor and other function calls &amp; overloaded operators might avoid any I/O calls and access to volatile data, and the compiler might well understand it. However if <code>gNumCopies</code> is a global variable that later used in an expression with observable behavior (e.g. printed),  then this code will not be removed.</p>\n", "OwnerUserId": "654891", "LastEditorUserId": "654891", "LastEditDate": "2011-05-25T20:38:51.827", "Id": "6130497", "Score": "7", "CreationDate": "2011-05-25T20:29:22.100", "LastActivityDate": "2011-05-25T20:38:51.827"}, "bq_ids": {"n4140": {"so_6130100_6130497_0": {"section_id": 5804, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_6130100_6130497_0": {"section_id": 5577, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_6130100_6130497_0": {"section_id": 7262, "quality": 0.7857142857142857, "length": 11}}}, "6130138": {"ParentId": "6130100", "CommentCount": "2", "Body": "<p>Why should  it? The best solution is to use the container in some way, like by adding its size to a global variable.</p>\n", "OwnerUserId": "2100815", "PostTypeId": "2", "Id": "6130138", "Score": "3", "CreationDate": "2011-05-25T19:59:04.060", "LastActivityDate": "2011-05-25T19:59:04.060"}});