post_cb({"28130423": {"ParentId": "28129777", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote id=\"so_28129777_28130423_0\">\n<ol>\n<li>Should this template using directive actually compile? (It does on clang but not gcc)</li>\n</ol>\n</blockquote>\n<p>I'm not sure. The standard says that function types, function names and variable names have a language linkage, but it doesn't say whether you can use an alias template to produce such function types.</p>\n<p>EDG rejects it too, but Clang might be correct to allow it.</p>\n<p>Edit: I failed to find <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/cwg_closed.html#1463\" rel=\"nofollow\">http://open-std.org/JTC1/SC22/WG21/docs/cwg_closed.html#1463</a> which points out [temp]/4 says </p>\n<blockquote>\n<p id=\"so_28129777_28130423_1\">A template, a template explicit specialization (14.7.3), and a class template partial specialization shall not have C linkage.</p>\n</blockquote>\n<p>So technically Clang is wrong to accept it, but the Evolution Working Group are going to consider whether it should be allowed.</p>\n<blockquote id=\"so_28129777_28130423_2\">\n<ol start=\"2\">\n<li>If I declare my function pointer type as: <code>extern \"C\" typedef void* (*factory_pointer)();</code> and cast the return value explicitly with a <code>reinterpret_cast&lt;&gt;</code>, will I be invoking undefined behavior?</li>\n</ol>\n</blockquote>\n<p>(Edit: I originally said yes here, because I misread the question)</p>\n<p>No, but a <code>static_cast</code> would be better than <code>reinterpret_cast</code>.</p>\n<blockquote id=\"so_28129777_28130423_3\">\n<ol start=\"3\">\n<li>Do I have any other options I might not have considered for accomplishing my stated goal that don't involve void*?</li>\n</ol>\n</blockquote>\n<p>Get rid of all the C language linkage. I don't think it's necessary or useful for your situation.</p>\n<blockquote id=\"so_28129777_28130423_4\">\n<ol start=\"4\">\n<li>Is a typedef with extern \"C\" for the function pointer strictly necessary? The standard can't seem to make up its mind. It says for example: in 7.5 of the 2014 draft standard: \"Two function types with different language linkages are distinct types even if they are otherwise identical.\" but in 8.3.5 paragraph 8: \"The return type, the parameter-type-list, the ref-qualifier, and the cv-qualifier-seq, but not the default arguments (8.3.6) or the exception specification (15.4), are part of the function type.\"</li>\n</ol>\n</blockquote>\n<p>That doesn't say anything about language linkage, so doesn't contradict the very clear statement in 7.5 which says it is part of the type.</p>\n<p>Also note:</p>\n<blockquote>\n<p id=\"so_28129777_28130423_5\">[expr.call]/1: Calling a function through an expression whose function type has a language linkage that is different from the language linkage of the function type of the called function\u2019s definition is undefined (7.5).</p>\n</blockquote>\n<p>That's undefined because it would not work if for example C language linkage implies a different calling convention to C++ language linkage.</p>\n<p>But most compilers will do the right thing because they don't actually use different calling conventions for C and C++ functions, and most don't even implement the rule that the types of functions with C language linkage are different. See e.g. <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=2316\" rel=\"nofollow\">https://gcc.gnu.org/bugzilla/show_bug.cgi?id=2316</a></p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2015-01-24T23:53:50.530", "Id": "28130423", "Score": "2", "CreationDate": "2015-01-24T21:27:36.987", "LastActivityDate": "2015-01-24T23:53:50.530"}, "bq_ids": {"n4140": {"so_28129777_28133425_0": {"section_id": 5520, "quality": 1.0, "length": 14}, "so_28129777_28130423_1": {"section_id": 51, "quality": 0.9090909090909091, "length": 10}, "so_28129777_28133425_1": {"section_id": 5520, "quality": 0.9047619047619048, "length": 19}, "so_28129777_28130423_5": {"section_id": 5988, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_28129777_28133425_0": {"section_id": 5306, "quality": 1.0, "length": 14}, "so_28129777_28130423_1": {"section_id": 46, "quality": 0.9090909090909091, "length": 10}, "so_28129777_28133425_1": {"section_id": 5306, "quality": 0.9047619047619048, "length": 19}, "so_28129777_28130423_5": {"section_id": 5756, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_28129777_28133425_0": {"section_id": 6955, "quality": 1.0, "length": 14}, "so_28129777_28130423_1": {"section_id": 52, "quality": 0.9090909090909091, "length": 10}, "so_28129777_28133425_1": {"section_id": 6955, "quality": 0.9047619047619048, "length": 19}, "so_28129777_28130423_5": {"section_id": 7488, "quality": 0.7368421052631579, "length": 14}}}, "28133425": {"ParentId": "28129777", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>You can definitely do this (credit to <a href=\"https://stackoverflow.com/a/14617173/103167\">Potatoswatter for spotting this ability in his answer here</a>):</p>\n<pre><code>extern \"C\" {\n    template &lt;typename T&gt;\n    class factory_pointer_def {\n        typedef T* (*type)();\n    };\n}\n</code></pre>\n<p>which can be combined with</p>\n<pre><code>template &lt;typename T&gt;\nusing factory_pointer_t = typename factory_pointer_def&lt;T&gt;::type;\n</code></pre>\n<p>and it may also be possible to write</p>\n<pre><code>extern \"C\" {\n    template &lt;typename T&gt;\n    using factory_pointer_t = T* (*)();\n}\n</code></pre>\n<p>and get the desired effect, although the Standard doesn't give that as an example.  However, what the Standard actually says is</p>\n<blockquote>\n<p id=\"so_28129777_28133425_0\">A C language linkage is ignored in determining the language linkage of the names of class members and the function type of class member functions.</p>\n</blockquote>\n<p>and an <em>alias-template</em> is neither of those, so the C language linkage will not be ignored.</p>\n<p>So all you need to change is to use the block form of <code>extern \"C\"</code>.</p>\n<hr>\n<p>As Jonathan points out, giving a template C language linkage is illegal.  But</p>\n<blockquote>\n<p id=\"so_28129777_28133425_1\">In  a  linkage-speci\ufb01cation,  the  speci\ufb01ed  language  linkage  applies  to  the  function types of all function declarators,  function names with external linkage,  and variable names with external linkage declared within the linkage-specification.</p>\n</blockquote>\n<p>The language linkage doesn't apply to the template class nor template-alias.  Only to the function type which is within the function pointer declaration.</p>\n<p>Therefore, any of the above code using templates inside <code>extern \"C\"</code> blocks is perfectly legal.</p>\n</hr>", "OwnerUserId": "103167", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:28:31.170", "Id": "28133425", "Score": "1", "CreationDate": "2015-01-25T05:05:43.453", "LastActivityDate": "2015-01-25T05:19:36.723"}, "28129777": {"CommentCount": "29", "ViewCount": "401", "PostTypeId": "1", "LastEditorUserId": "880984", "CreationDate": "2015-01-24T20:14:50.877", "LastActivityDate": "2015-01-25T05:19:36.723", "Title": "Using templates to get rid of dynamic linking boilerplate: extern \"C\" and templates don't mix;", "AcceptedAnswerId": "28130423", "LastEditDate": "2015-01-24T21:13:30.503", "Id": "28129777", "Score": "2", "Body": "<p>I came up with a bit of C++ code that I didn't really think too much about at first until I noticed that clang accepts it but gcc doesn't. And I think gcc is probably right about it the more I think about it. The problem is, I can't really think of a good, legal way to do what I want without a ton of boilerplate.</p>\n<p>First, here is the code I wish would compile in g++:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>extern \"C\" template &lt;typename T&gt;\nusing factory_pointer_t = T* (*)();\n</code></pre>\n<p>Since I think this might be an XY problem, a little background. I was working on a little plugin system with a fairly simple interface. Basically it only consists of a factory function that returns a pointer to an abstract base class. The abstract base class asks for methods to deal with memory management, similar to COM. Something like this:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class ITest {\npublic:\n    virtual void release() = 0;\n    virtual void test_method() = 0;\nprotected:\n    virtual ~ITest(){}\n};\n</code></pre>\n<p>Which would be implemented in the dynamic library something like this:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>class Test : public ITest {\npublic:\n    virtual void release() override {\n        delete this;\n    };\n    virtual void test_method() override {\n        std::cout &lt;&lt; \"Hello, shared World!\\n\";\n    }\n};\n\nextern \"C\" ITest * testFactory() {\n    return new Test{};\n}\n</code></pre>\n<p>The research I have done on this suggest that this should work reliably across toolchains on at least windows and linux. Even if that turns out not to be the case, the system is intended for rapid prototyping on one toolchain with the opportunity to ditch the plugins and link everything statically somewhere down the line. No problems here so far.</p>\n<p>My other research suggests that the <code>extern \"C\"</code> linkage specifier is very important for the dynamic linkage to work properly among all tools that support the same C ABI. The problem now is this:</p>\n<p>I wanted to write some template code to help make some of this easier. \nBut no combination of <code>extern \"C\"</code> together with the template syntax seems to work. My efforts to Google help have been thwarted by articles about the  deprecated <code>extern template</code>. I wanted to give it the name of an abstract interface, and have it load the dll and resolve the symbol for the factory function. But as you can see, the type of the callbacks (<code>factory_pointer_t&lt;T&gt;</code>) are parameterized by the abstract interface pointer type they are returning. So my questions:</p>\n<ol>\n<li><p>Should this template using directive actually compile? (It does on clang but not gcc)</p></li>\n<li><p>If I declare my function pointer type as: <code>extern \"C\" typedef void* (*factory_pointer)();</code> and cast the return value explicitly with a <code>reinterpret_cast&lt;&gt;</code>, will I be invoking undefined behavior? Given that in the DLL I would like to keep the function signature that I am exporting unchanged.</p></li>\n<li><p>Do I have any other options I might not have considered for accomplishing my stated goal that don't involve <code>void*</code>?</p></li>\n<li><p>Is a typedef with <code>extern \"C\"</code> for the function pointer strictly necessary? The standard can't seem to make up its mind. It says for example:  in 7.5 of the 2014 draft standard: \"Two function types with different language\nlinkages are distinct types even if they are otherwise identical.\" but in  8.3.5 paragraph 8: \"The return type, the parameter-type-list, the ref-qualifier, and the cv-qualifier-seq, but not the default\narguments (8.3.6) or the exception specification (15.4), are part of the function type.\"</p></li>\n</ol>\n<p>I would really like to keep it working automatically in other compilers (i.e. I give it a type and tell it what library to load and I am done), but I guess I am not seeing what I need to do instead. Anything that involves more than a line of boilerplate per class, I would consider bad.</p>\n<p>Since this is my first time experimenting with dynamic linking (more than letting the build system do it for me), I am eager to get some good advice.</p>\n<p><strong>In summary:</strong> I have a working solution based on the first line of code that only works in one compiler. I know it is probably wrong or at least not universally supported syntax. How do I do it the right way?</p>\n", "Tags": "<c++><templates><standards><dynamic-linking>", "OwnerUserId": "880984", "AnswerCount": "2"}});