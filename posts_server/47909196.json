post_cb({"bq_ids": {"n4140": {"so_47909196_47909452_0": {"length": 39, "quality": 0.975, "section_id": 6037}}, "n3337": {"so_47909196_47909452_0": {"length": 39, "quality": 0.975, "section_id": 5805}}, "n4659": {"so_47909196_47909452_0": {"length": 32, "quality": 0.8, "section_id": 7536}}}, "47909389": {"Id": "47909389", "PostTypeId": "2", "Body": "<p>If you use <code>protected</code> inheritance, only derived types can be aware of that inheritance. As far as <code>test</code> is concerned, there is no relation between <code>A</code> and <code>B</code>. Since a <code>static_cast</code> can't cast pointers between unrelated types, you would need to <code>reinterpret_cast</code> instead. Or you may be able to provide <code>B</code> with a static method to preform this conversion, since <code>B</code> is aware of the inheritance. For example :</p>\n<pre><code>// some C++ Wrapper class\nstruct B : protected A {\n    A* get() { return this; }\n    void print() { cout &lt;&lt; i &lt;&lt; endl; }\n    static B* cast_to_b(A* io_self) { return static_cast&lt;B*&gt;(io_self); }\n};\n\n\nextern \"C\" {\n// C callback that gives it this pointer\nvoid test(A* io_self) {\n    auto b2 = B::cast_to_b(io_self);\n    b2-&gt;print();\n}\n}\n</code></pre>\n<p>Be sure that the object referred to by <code>A* io_self</code> is actually a <code>B</code> and not just a <code>A</code> or it's undefined behavior.</p>\n<p>Are you sure <code>protected</code> is the right inheritance for you here? It seems like <code>private</code> inheritance might be clearer as there doesn't seem to be any intention of inheriting from <code>B</code>. You may also want to consider forgetting about inheritance and simply giving <code>B</code> a <code>A</code> member.</p>\n", "LastEditorUserId": "7359094", "LastActivityDate": "2017-12-20T15:28:10.217", "Score": "4", "CreationDate": "2017-12-20T15:25:29.123", "ParentId": "47909196", "CommentCount": "7", "OwnerUserId": "7359094", "LastEditDate": "2017-12-20T15:28:10.217"}, "47909196": {"ViewCount": "115", "Body": "<p>Unlike other examples of this error message i already have a pointer to <code>A</code> and want to retrieve the actual child class.</p>\n<p>This kind of arrangement is part of some C++ wrapped C code there <code>A</code> is some POD C structure (whatswhy no dynamic cast)  and <code>test</code> is some callback in C that calls C++ functionality and to retrieve the correct object the cast should be used.\nBut to prevent C++ user code messing the C-Baseclass i would like to have the inheritance <code>protected</code>.</p>\n<p>MSVC does not complain about this but g++ does!?\nWhich one is correct from the standards point of view and why?</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\n// plain C structure\nstruct A{\n    int i;\n};\n\n// some C++ Wrapper class\nstruct B: protected A{\n  A* get() { return this; }\n  void print(){cout &lt;&lt; i &lt;&lt; endl;}\n};\n\n\n\nextern \"C\" {\n  // C callback that gives it this pointer\n  void test(A* io_self){\n     auto b2 = static_cast&lt;B*&gt;(io_self);\n     b2-&gt;print();\n  }\n}    \n\nint main()\n{\n   B b;\n   test(b.get());\n   return 0;\n}\n</code></pre>\n<p>gives:</p>\n<pre><code>$g++ -std=c++11 -o main *.cpp\nmain.cpp: In function \u2018void test(A*)\u2019:\nmain.cpp:21:43: error: \u2018A\u2019 is an inaccessible base of \u2018B\u2019\n          auto b2 = static_cast&lt;B*&gt;(io_self);\n                                           ^\n</code></pre>\n", "AcceptedAnswerId": "47909452", "Title": "Downcast: why: \u2018A\u2019 is an inaccessible base of \u2018B\u2019?", "CreationDate": "2017-12-20T15:17:04.663", "Id": "47909196", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2017-12-20T15:55:07.083", "Score": "4", "OwnerUserId": "2331592", "Tags": "<c++><inheritance><language-lawyer>", "AnswerCount": "2"}, "47909452": {"Id": "47909452", "PostTypeId": "2", "Body": "<p>From c++11 N3337 draft (a bit old but it's the one I have lying around) 5.2.9/11 (static_cast):</p>\n<blockquote>\n<p id=\"so_47909196_47909452_0\">A prvalue of type \u201cpointer to cv1 B,\u201d where B is a class type, can be\n  converted to a prvalue of type \u201cpointer to cv2 D,\u201d where D is a class\n  derived (Clause 10) from B, if a valid standard conversion from\n  \u201cpointer to D\u201d to \u201cpointer to B\u201d exists (4.10), cv2 is the same\n  cv-qualification as, or greater cv-qualification than, cv1, and B is\n  neither a virtual base class of D nor a base class of a virtual base\n  class of D.</p>\n</blockquote>\n<p>In this case, since you use <code>protected</code> inheritance there is no valid standard conversion from <code>B</code> to <code>A</code> so your <code>static_cast</code> is illegal (g++ is correct to diagnose it).</p>\n<p>In this case since you're providing a c++ wrapper around a C API I think the simplest approach is to just stick with public inheritance and have a small amount of trust that your users won't abuse the C API directly <em>if they've already consciously chosen to use your C++ API</em></p>\n", "LastEditorUserId": "251738", "LastActivityDate": "2017-12-20T15:55:07.083", "Score": "3", "CreationDate": "2017-12-20T15:29:23.560", "ParentId": "47909196", "CommentCount": "0", "OwnerUserId": "251738", "LastEditDate": "2017-12-20T15:55:07.083"}});