post_cb({"28106468": {"CommentCount": "3", "ViewCount": "94", "PostTypeId": "1", "LastEditorUserId": "2805305", "CreationDate": "2015-01-23T09:14:10.810", "LastActivityDate": "2015-01-23T11:31:07.520", "Title": "How can I use extern to share globe variables between source files in C++?", "AcceptedAnswerId": "28106535", "LastEditDate": "2015-01-23T09:23:39.280", "Id": "28106468", "Score": "2", "Body": "<p>IDE:codeblocks 13.12</p>\n<p>--------------main.cpp------------------</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nextern const int x;\n\nint main()\n{\n   cout &lt;&lt; x &lt;&lt; endl;\n}\n</code></pre>\n<p>--------------sub.cpp-------------------</p>\n<pre><code>extern const int x = 10;\n</code></pre>\n<p>when I try to run the code before , the compiler show the error :</p>\n<blockquote>\n<p id=\"so_28106468_28106468_0\">E:\\NewProject\\Test\\main.cpp|8|undefined reference to `x'|</p>\n</blockquote>\n<p>so, who can tell me how to solve this problem?\n(I have tried create a head file just like:</p>\n<pre><code>extern const int x;\n</code></pre>\n<p>and let both cpp file include this head file. but it make no use)</p>\n<p>and if I want create a array at main.cpp just like:</p>\n<pre><code>int _array[x];\n</code></pre>\n<p>what should I do?</p>\n<p>I'm new here, and not good at English.\nThanks very much!!</p>\n", "Tags": "<c++>", "OwnerUserId": "4485913", "AnswerCount": "3"}, "28106531": {"ParentId": "28106468", "CommentCount": "0", "CreationDate": "2015-01-23T09:18:23.303", "OwnerUserId": "3177124", "PostTypeId": "2", "Id": "28106531", "Score": "0", "Body": "<p>In <code>sub.cpp</code>, just use</p>\n<pre><code>const int x = 10;\n</code></pre>\n", "LastActivityDate": "2015-01-23T09:18:23.303"}, "28106535": {"ParentId": "28106468", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-01-23T09:18:28.543", "Score": "4", "LastEditorUserId": "11698", "LastEditDate": "2015-01-23T11:31:07.520", "Id": "28106535", "OwnerUserId": "11698", "Body": "<p>The <code>extern</code> keyword is saying:  This is a declaration only.</p>\n<p>For a variable, you need exactly one definition, ie. a declaration without <code>extern</code> somewhere else:</p>\n<pre><code>// foo.h\nextern int i;\n\n// foo.cc\n#include \"foo.h\"\nint i;   // definition\n\n// bar.cc\n#include \"foo.h\"\nint main () {\n  ++i;   // modifies global variable\n}\n</code></pre>\n<p><strong>Special Rules for <code>const</code></strong></p>\n<p>A common use case for <code>const</code> variables is that you define constants in a header file and then use them everywhere else in your program:</p>\n<pre><code>// my_constants.h\nconst int NumHoursInDay = 24;\nconst int NumMinutesInHour = 60;\n</code></pre>\n<p>If these variables were not <code>const</code>, then including <code>my_constants.h</code> into different translation units (source files + their headers) would result in a linker error due to having multiple definitions of the variables.</p>\n<p>The standard committee decided that this was going to be a common enough use case that they actually put a special rule for variables declared <code>const</code>, C++ '03 7.1.5/2:</p>\n<blockquote>\n<p id=\"so_28106468_28106535_0\">An object declared in namespace scope with a const-qualified type has\n  internal linkage unless it is explicitly declared extern or unless it was \n  previously declared to have external linkage.</p>\n</blockquote>\n<p>This means that each translation unit will have it's own private copy of the <code>const</code> variable.  The linker won't try to merge them together and so there won't be an error.</p>\n<p>So the first point is that you can actually just remove <code>extern</code> from your exmaples and your code will compile and link correctly, all because of this special behavior of <code>const</code>.</p>\n<p>However, for whatever reason, if you decided you do want to declare your variable first and then have a single definition in the project, you may already have noticed that the following will still generate a linker error:</p>\n<pre><code>// foo.h\nextern const int i;\n\n// foo.cc\nconst int i = 0;\n</code></pre>\n<p>This is because the linker expects to find a definition for the <code>i</code> in foo.h and as the <code>i</code> in foo.cc has internal linkage (ie. it is invisible outside of that translation unit) the linker won't consider these objects to be the same.</p>\n<p>This can be addressed by looking at the end of the quote from the standard:</p>\n<blockquote>\n<p id=\"so_28106468_28106535_1\">or unless it was previously declared to have external linkage.</p>\n</blockquote>\n<p>What we need to do is to tell the compiler that <code>i</code> in foo.cc should have external linkage by first declaring it with <code>extern</code> and <em>then</em> defining it without <code>extern</code>.</p>\n<pre><code>// foo.cc\nextern const int i;\nconst int i = 0;\n</code></pre>\n<p>And the best way to do this is to include our header file so that we only have the one declaration:</p>\n<pre><code>// foo.cc\n#include \"foo.h\"   // contains the extern declaration of 'i'\nconst int i = 0;\n</code></pre>\n<p><strong>Array Dimension</strong></p>\n<p>One final point is that an array dimension needs to be a <em>constant expression</em>.  Adding to the confusion here, an <code>extern const</code> variable that is not defined in the current translation unit is not considered to be a <em>constant expression</em>:</p>\n<pre><code>extern const int ArrayDim;\nint array[ArrayDim];       // Illegal C++\n</code></pre>\n<p>The code may compile, especially if you're using g++, as there is a C language feature called Variable Length Arrays.  Behind the scenes the compiler is hiding memory allocations to support this.</p>\n<p>As you intend to use your constant across multiple translation units and you need it to be used as a <em>constant expression</em> then the best option is to define your constant in a header file:</p>\n<pre><code>// my_constants.h\nconst int x = 10;\n\n\n#include&lt;iostream&gt;\n#include \"my_constants.h\"\n\nusing namespace std;\n\nint main()\n{\n   int _array[x];\n   cout &lt;&lt; x &lt;&lt; endl;\n}\n</code></pre>\n", "LastActivityDate": "2015-01-23T11:31:07.520"}, "28106544": {"ParentId": "28106468", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-01-23T09:19:04.203", "Score": "3", "LastEditorUserId": "2893307", "LastEditDate": "2015-01-23T09:26:13.970", "Id": "28106544", "OwnerUserId": "2893307", "Body": "<p><code>extern</code> means that your variable is just <em>declared</em> here but <em>defined</em> in another translation unit. So you can have many <em>declaration</em> of your constant <code>extern const int x;</code> but you must have exactly one <em>definition</em> of this constant <code>const int x = 10;</code></p>\n", "LastActivityDate": "2015-01-23T09:26:13.970"}, "bq_ids": {"n4140": {"so_28106468_28106535_0": {"section_id": 7136, "quality": 0.6470588235294118, "length": 11}, "so_28106468_28106535_1": {"section_id": 7136, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_28106468_28106535_0": {"section_id": 6880, "quality": 0.6470588235294118, "length": 11}, "so_28106468_28106535_1": {"section_id": 6880, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_28106468_28106535_0": {"section_id": 8637, "quality": 0.6470588235294118, "length": 11}, "so_28106468_28106535_1": {"section_id": 8637, "quality": 0.8333333333333334, "length": 5}}}});