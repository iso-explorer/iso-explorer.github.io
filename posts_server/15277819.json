post_cb({"15277819": {"CommentCount": "6", "ViewCount": "616", "PostTypeId": "1", "LastEditorUserId": "718379", "CreationDate": "2013-03-07T17:28:28.937", "LastActivityDate": "2014-05-10T05:28:09.130", "Title": "Are anonymous unions acceptable for aliasing member variables in a struct?", "AcceptedAnswerId": "15278030", "LastEditDate": "2014-05-10T05:28:09.130", "Id": "15277819", "Score": "1", "Body": "<p>Let's say that I have the following C++ code:</p>\n<pre><code>struct something\n{\n  // ...\n  union { int size, length; };\n  // ...\n};\n</code></pre>\n<p>This would create two members of the <code>struct</code> which access the same value: <code>size</code> and <code>length</code>.</p>\n<p>Would treating the two members as complete aliases (i.e. setting the size, then accessing the length and vice/versa) be undefined behaviour? Is there a \"better\" way to implement this type of behaviour, or is this an acceptable implementation?</p>\n", "Tags": "<c++><struct><unions>", "OwnerUserId": "1104684", "AnswerCount": "3"}, "15277923": {"ParentId": "15277819", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2013-03-07T17:33:32.420", "Score": "5", "LastEditorUserId": "1413845", "LastEditDate": "2013-03-08T08:16:54.827", "Id": "15277923", "OwnerUserId": "1413845", "Body": "<p>It is not undefined behavior. Both of the aliases in the union will be accessing the same location in the memory. See below:</p>\n<blockquote>\n<p id=\"so_15277819_15277923_0\"><strong>\u00a79.2/18</strong> If a standard-layout union contains two or more\n  standard-layout structs that share a common initial sequence, and if\n  the standard-layout union object currently contains one of these\n  standard-layout structs, it is permitted to inspect the common initial\n  part of any of them. Two standard-layout structs share a common\n  initial sequence if corresponding members have layout-compatible types\n  and either neither member is a bit-field or both are bit-fields with\n  the same width for a sequence of one or more initial members.</p>\n</blockquote>\n<p>It is undefined if types have different initial sequence.</p>\n", "LastActivityDate": "2013-03-08T08:16:54.827"}, "15277938": {"ParentId": "15277819", "CommentCount": "1", "CreationDate": "2013-03-07T17:34:16.140", "OwnerUserId": "1955713", "PostTypeId": "2", "Id": "15277938", "Score": "0", "Body": "<p>Values will be same. If you assign 5 to size then length will also be 5.</p>\n", "LastActivityDate": "2013-03-07T17:34:16.140"}, "15278030": {"ParentId": "15277819", "PostTypeId": "2", "CommentCount": "14", "CreationDate": "2013-03-07T17:40:32.420", "Score": "4", "LastEditorUserId": "147192", "LastEditDate": "2013-03-08T07:48:02.717", "Id": "15278030", "OwnerUserId": "147192", "Body": "<p>Yes, this is allowed and well-defined. According to \u00a73.10 [basic.lval]:</p>\n<blockquote>\n<p id=\"so_15277819_15278030_0\"><strong>10/</strong> If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:</p>\n<p id=\"so_15277819_15278030_1\">\u2014 the dynamic type of the object</p>\n<p id=\"so_15277819_15278030_2\">[...]</p>\n</blockquote>\n<p>Since here we store an <code>int</code> and read through an <code>int</code>, we access the object through a glvalue of the same dynamic type than the object, thus things are fine.</p>\n<hr>\n<p>There even is a special caveat in the Standard for <em>structures</em> that share the same prefix. Or, in standardese, <em>standard-layout types</em> that share a <em>common initial sequence</em>.</p>\n<blockquote>\n<p id=\"so_15277819_15278030_3\"><strong>\u00a79.2/18</strong> If a standard-layout union contains two or more standard-layout structs that share a common initial sequence, and if the standard-layout union object currently contains one of these standard-layout structs, it is permitted to inspect the common initial part of any of them. Two standard-layout structs share a common initial sequence if corresponding members have layout-compatible types and either neither member is a bit-field or both are bit-fields with the same width for a sequence of one or more initial members.</p>\n</blockquote>\n<p>That is:</p>\n<pre><code>struct A { unsigned size; char type; };\nstruct B { unsigned length; unsigned capacity; };\n\nunion { A a; B b; } x;\n\nassert(x.a.size == x.b.length);\n</code></pre>\n<p><strong>EDIT:</strong> Given that <code>int</code> is not a <code>struct</code> (nor a <code>class</code>) I am afraid it's actually not formally defined (I certainly could not see anything in the Standard), but should be safe in practice... I've brought the matters to the isocpp forums; you might have found a hole.</p>\n<p><strong>EDIT:</strong> Following the above mentionned discussion, I have been shown \u00a73.10/10.</p>\n</hr>", "LastActivityDate": "2013-03-08T07:48:02.717"}, "bq_ids": {"n4140": {"so_15277819_15278030_3": {"section_id": 5878, "quality": 0.9803921568627451, "length": 50}, "so_15277819_15277923_0": {"section_id": 5878, "quality": 0.9803921568627451, "length": 50}, "so_15277819_15278030_0": {"section_id": 7239, "quality": 1.0, "length": 14}}, "n3337": {"so_15277819_15278030_3": {"section_id": 5649, "quality": 0.9803921568627451, "length": 50}, "so_15277819_15277923_0": {"section_id": 5649, "quality": 0.9803921568627451, "length": 50}, "so_15277819_15278030_0": {"section_id": 6983, "quality": 1.0, "length": 14}}, "n4659": {"so_15277819_15278030_0": {"section_id": 8748, "quality": 1.0, "length": 14}}}});