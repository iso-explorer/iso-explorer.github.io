post_cb({"48771164": {"Id": "48771164", "PostTypeId": "2", "Body": "<p>For your particular case, because the specialization <em>has</em> to appear after the primary template, and assuming they <em>both</em> appear, then yes. Otherwise, if one TU sees the specialization, but another doesn't and they both use <code>mystruct&lt;0&gt;</code>, you'd get undefined behavior.</p>\n<p>In the general case, with many specializations that may be quite complicated, the C++ standard has this to say at <a href=\"https://timsong-cpp.github.io/cppwp/n4659/temp.expl.spec#7\" rel=\"nofollow noreferrer\">[temp.expl.spec]/7</a>, emphasis mine:</p>\n<blockquote>\n<p id=\"so_48771102_48771164_0\">The placement of explicit specialization declarations for function\n  templates, class templates, variable templates, member functions of\n  class templates, static data members of class templates, member\n  classes of class templates, member enumerations of class templates,\n  member class templates of class templates, member function templates\n  of class templates, static data member templates of class templates,\n  member functions of member templates of class templates, member\n  functions of member templates of non-template classes, static data\n  member templates of non-template classes, member function templates of\n  member classes of class templates, etc., and the placement of partial\n  specialization declarations of class templates, variable templates,\n  member class templates of non-template classes, static data member\n  templates of non-template classes, member class templates of class\n  templates, etc., can affect whether a program is well-formed according\n  to the relative positioning of the explicit specialization\n  declarations and their points of instantiation in the translation unit\n  as specified above and below. <strong>When writing a specialization, be\n  careful about its location; or to make it compile will be such a trial\n  as to kindle its self-immolation.</strong></p>\n</blockquote>\n", "LastEditorUserId": "817643", "LastActivityDate": "2018-02-13T16:36:57.743", "Score": "5", "CreationDate": "2018-02-13T16:18:07.933", "ParentId": "48771102", "CommentCount": "6", "OwnerUserId": "817643", "LastEditDate": "2018-02-13T16:36:57.743"}, "bq_ids": {"n4140": {"so_48771102_48771164_0": {"length": 127, "quality": 0.9921875, "section_id": 269}}, "n3337": {"so_48771102_48771164_0": {"length": 105, "quality": 0.8203125, "section_id": 260}}, "n4659": {"so_48771102_48771164_0": {"length": 127, "quality": 0.9921875, "section_id": 276}}}, "48771441": {"Id": "48771441", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_48771102_48771441_0\">Does C++ normalization ensure the template specialization <code>&lt;0&gt;</code> to override the general construction <code>&lt;N&gt;</code>, whatever the templates specialization order in the code is?</p>\n</blockquote>\n<p>Just to clarify on terminology,</p>\n<pre><code>template&lt;int N&gt; struct mystruct {float k = 3.14;};\n</code></pre>\n<p>is not a specialization. It is the main/generic/base implementation.</p>\n<p>The specialization <code>mystruct&lt;0&gt;</code> will be used whenever an <code>mystruct&lt;0&gt;</code> is used as long as the specialization is visible at the point <code>mystruct&lt;0&gt;</code> is used. That's the whole point of specialization.</p>\n", "LastActivityDate": "2018-02-13T16:34:32.320", "Score": "3", "CreationDate": "2018-02-13T16:34:32.320", "ParentId": "48771102", "CommentCount": "0", "OwnerUserId": "434551"}, "48771102": {"ViewCount": "100", "Body": "<p>Let's imagine I declare a templated structure:</p>\n<pre><code>template &lt;int N&gt; struct mystruct;\n</code></pre>\n<p>Let's imagine my structure has a general behavior for all <code>N</code>, except when <code>N == 0</code></p>\n<p>I can declare for instance a special behavior for <code>N == 0</code> with:</p>\n<pre><code>template&lt;&gt; struct mystruct&lt;0&gt; {int k = 0};\n</code></pre>\n<p>I can also declare the general behaviour with:</p>\n<pre><code>template&lt;int N&gt; struct mystruct {float k = 3.14;};\n</code></pre>\n<p>If I run in the main:</p>\n<pre><code>struct mystruct&lt;-1&gt; x;\nstruct mystruct&lt;0&gt; y;\nstruct mystruct&lt;1&gt; z;\nstd::cout &lt;&lt; x.k &lt;&lt; \" \" &lt;&lt; y.k &lt;&lt; \" \" &lt;&lt; z.k &lt;&lt; std::endl;\n</code></pre>\n<p>I get what I want : <code>3.14 0 3.14</code>, whatever the order of template declarations.</p>\n<p>However I am wondering if this behavior is insured. Indeed, when I declare:</p>\n<p><code>struct mystruct&lt;0&gt; y;</code></p>\n<p>In my mind, this could as well be defined by both <code>mystruct</code> implementations.</p>\n<p>So the question is:</p>\n<p><em>Does C++ normalization ensure the template specialization <code>&lt;0&gt;</code> to override the general basic implementation <code>&lt;int N&gt;</code>, whatever the templates specialization order in the code is?</em></p>\n", "Title": "C++ template - several specializations - is behaviour defined?", "CreationDate": "2018-02-13T16:15:11.197", "LastActivityDate": "2018-02-13T16:36:57.743", "CommentCount": "3", "LastEditDate": "2018-02-13T16:36:21.023", "PostTypeId": "1", "LastEditorUserId": "8118147", "Id": "48771102", "Score": "3", "OwnerUserId": "8118147", "Tags": "<c++><templates><template-specialization>", "AnswerCount": "2"}});