post_cb({"31150948": {"Id": "31150948", "PostTypeId": "2", "Body": "<p>I don't have much experience interpreting what the C++ spec  says about template argument deduction, but I'll take a stab at this:</p>\n<p><strong>gcc is right.</strong></p>\n<p><code>[temp.deduct] p5</code> says (emphasis mine):</p>\n<blockquote>\n<p id=\"so_31150922_31150948_0\">When all template arguments have been deduced or obtained from default\n  template arguments, <strong>all uses</strong> of template parameters in the template\n  parameter list of the template and the function type are replaced with\n  the corresponding deduced or default argument values. If the\n  substitution results in an invalid type, as described above, type\n  deduction fails.</p>\n</blockquote>\n<p>The use of <code>T</code> in <code>typename enable_if&lt;!trait&lt;T&gt;::value&gt;::type...</code> is a use of a template parameter in the template parameter list of the template; since the above paragraph says that <strong>all</strong> such uses are replaced with the corresponding argument values, this substitution needs to be performed, in spite of the fact that no template arguments are bound to this parameter pack.</p>\n", "LastActivityDate": "2015-07-01T01:01:22.927", "CommentCount": "0", "CreationDate": "2015-07-01T01:01:22.927", "ParentId": "31150922", "Score": "0", "OwnerUserId": "141719"}, "bq_ids": {"n4140": {"so_31150922_31150948_0": {"length": 36, "quality": 1.0, "section_id": 297}}, "n3337": {"so_31150922_31150948_0": {"length": 36, "quality": 1.0, "section_id": 288}}, "n4659": {"so_31150922_31150948_0": {"length": 36, "quality": 1.0, "section_id": 304}}}, "31150922": {"ViewCount": "269", "Body": "<p>libstdc++'s implementation of <code>std::experimental::optional</code> <a href=\"https://gcc.gnu.org/viewcvs/gcc/trunk/libstdc%2B%2B-v3/include/experimental/optional?view=markup#l166\" rel=\"nofollow\">uses</a> a SFINAE technique that seems to work with gcc, but not with clang.</p>\n<p>I've reduced it to the following minimal example:</p>\n<pre><code>// Standard enable_if class\ntemplate &lt;bool&gt; struct enable_if {};\ntemplate &lt;&gt; struct enable_if&lt;true&gt; { typedef int type; };\n\n// An example trait\ntemplate &lt;typename&gt; struct trait { static const bool value = true; };\n\n// Overload to call if the trait is false\ntemplate&lt;typename T, typename enable_if&lt;!trait&lt;T&gt;::value&gt;::type...&gt;\nvoid foo(T);\n\n// Overload to call if the trait is true\ntemplate&lt;typename T, typename enable_if&lt;trait&lt;T&gt;::value&gt;::type...&gt;\nvoid foo(T);\n\n// Call site\nvoid bar() {\n    foo(0);\n}\n</code></pre>\n<p>This compiles with gcc, but not with clang. Clang's error is:</p>\n<pre><code>test.cpp:18:5: error: call to 'foo' is ambiguous\n    foo(0);\n    ^~~\ntest.cpp:11:6: note: candidate function [with T = int, $1 = &lt;&gt;]\nvoid foo(T);\n     ^\ntest.cpp:14:6: note: candidate function [with T = int, $1 = &lt;&gt;]\nvoid foo(T);\n     ^\n</code></pre>\n<p>Clearly, gcc is discarding the first overload as a candidate because it encounters a substitution failure while subtituting <code>T = int</code> into <code>typename enable_if&lt;!trait&lt;T&gt;::value&gt;::type</code>. </p>\n<p>Clang, on the other hand, seems to skip performing that substitution, perhaps because it realizes that there are zero template arguments bound to that parameter pack. As a result, it doesn't encounter a substitution failure, and the first overload remains viable.</p>\n<p><strong>Who is right?</strong></p>\n", "Title": "Is this SFINAE technique involving variadic templates valid?", "CreationDate": "2015-07-01T00:56:56.147", "LastActivityDate": "2015-07-01T01:01:22.927", "CommentCount": "2", "PostTypeId": "1", "ClosedDate": "2015-07-01T01:09:38.910", "Id": "31150922", "Score": "2", "OwnerUserId": "141719", "Tags": "<c++><templates><c++11><variadic-templates><sfinae>", "AnswerCount": "1"}});