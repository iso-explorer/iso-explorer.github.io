post_cb({"bq_ids": {"n4140": {"so_25809873_25814424_0": {"length": 12, "quality": 1.0, "section_id": 6325}, "so_25809873_25810115_2": {"length": 23, "quality": 0.92, "section_id": 744}, "so_25809873_25814421_0": {"length": 57, "quality": 0.8769230769230769, "section_id": 6325}, "so_25809873_25810115_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 744}}, "n3337": {"so_25809873_25814424_0": {"length": 12, "quality": 1.0, "section_id": 6082}, "so_25809873_25810115_2": {"length": 23, "quality": 0.92, "section_id": 733}, "so_25809873_25814421_0": {"length": 57, "quality": 0.8769230769230769, "section_id": 6082}, "so_25809873_25810115_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 733}}, "n4659": {"so_25809873_25814424_0": {"length": 12, "quality": 1.0, "section_id": 7835}, "so_25809873_25810115_2": {"length": 23, "quality": 0.92, "section_id": 802}, "so_25809873_25814421_0": {"length": 56, "quality": 0.8615384615384616, "section_id": 7835}, "so_25809873_25810115_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 802}}}, "25811833": {"Id": "25811833", "PostTypeId": "2", "Body": "<p>This is (very simmilar to) LWG Active issue <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4117.html#2362\" rel=\"nofollow\">2362</a> which deals with emplace. IIRC the sentiment is that it should be guaranteed that the object is only moved iff it is inserted/emplaced. With emplace it seems to be not trivial to achieve. I do not remember if the situation is easier for insert.</p>\n", "LastActivityDate": "2014-09-12T15:32:12.433", "Score": "2", "CreationDate": "2014-09-12T15:32:12.433", "ParentId": "25809873", "CommentCount": "3", "OwnerUserId": "358277"}, "25814421": {"Id": "25814421", "PostTypeId": "2", "Body": "<p>The third bullet of [res.on.arguments]/1 from N3936:</p>\n<blockquote>\n<p id=\"so_25809873_25814421_0\">If a function argument binds to an rvalue reference parameter, the implementation <strong>may assume that\n  this parameter is a unique reference to this argument</strong>. [ <em>Note:</em> If the parameter is a generic parameter of the form <code>T&amp;&amp;</code> and an lvalue of type <code>A</code> is bound, the argument binds to an lvalue reference (14.8.2.1) and thus is not covered by the previous sentence. <em>\u2014end note</em> ] [ <em>Note:</em> If a program casts an lvalue to an xvalue while passing that lvalue to a library function (e.g. by calling the function with the argument <code>move(x)</code>), the program is effectively asking that function to treat that lvalue as a temporary. The implementation is free to optimize away aliasing checks which might be needed if the argument was an lvalue. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>despite on its face being about aliasing, can be interpreted as allowing the implementation to do virtually anything to an argument that is passed to a standard library function bound to an rvalue reference. As <a href=\"https://stackoverflow.com/a/25811833/923854\">Fabio says</a>, there are situations in which tightening this specification could be useful, and the committee is looking at some of them.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-09-12T18:18:53.400", "Score": "2", "CreationDate": "2014-09-12T18:18:53.400", "ParentId": "25809873", "CommentCount": "1", "LastEditDate": "2017-05-23T10:24:12.213", "OwnerUserId": "923854"}, "25809873": {"ViewCount": "330", "Body": "<p>What happens if to a movable object if I call\n<code>std::set&lt;&gt;::insert</code> on it, and the insertion doesn't take place\nbecause there is already an object with the same key present in\nthe set.  In particular, is the following valid:</p>\n<pre><code>struct Object\n{\n    std::string key;\n    //  ...\n\n    struct OrderByKey\n    {\n        bool operator()( Object const&amp; lhs, Object const&amp; rhs) const\n        {\n            return lhs.key &lt; rhs.key;\n        }\n    };\n\n    Object( Object&amp;&amp; other )\n        : key(std::move(other.key))\n    // ...\n    {\n    }\n};\n</code></pre>\n<p>and:</p>\n<pre><code>std::set&lt;Object, Object::OrderByKey&gt; registry;\nvoid\nregister(Object&amp;&amp; o)\n{\n    auto status = registry.insert(std::move(o));\n    if (!status.second)\n        throw std::runtime_error(\"Duplicate entry for \" + o.key);\n}\n</code></pre>\n<p>After the <code>registry.insert</code>, when no insertion takes place, has\n<code>o</code> been moved or not.  (If it might have been moved, I need to\nsave a copy of the string before hand, in order to use it in the\nerror message.  (And yes, I know that I can always write: </p>\n<pre><code>throw std::runtime_error( \"Duplicate entry for \" + status-&gt;first.key );\n</code></pre>\n<p>Which is what I'll probably do.  But I would still like to know\nwhat the standard says about this.)</p>\n", "AcceptedAnswerId": "25814424", "Title": "What happens to a movable object when its insertion in an std::set fails?", "CreationDate": "2014-09-12T13:48:44.580", "Id": "25809873", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-09-12T20:03:12.560", "Score": "12", "OwnerUserId": "649665", "Tags": "<c++><c++11>", "AnswerCount": "4"}, "25810115": {"Id": "25810115", "PostTypeId": "2", "Body": "<p>Well, to answer your last question</p>\n<blockquote>\n<p id=\"so_25809873_25810115_0\">I would still like to know what the standard says about this</p>\n</blockquote>\n<p>the standard specifies what happen with <code>insert(t)</code> in <code>Table 102 - Associative container requirements</code>, p717 of N3376 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_25809873_25810115_1\">Requires: If t is a non-const rvalue expression, value_type shall be MoveInsertable into X; otherwise, value_type shall be CopyInsertable into X. </p>\n<p id=\"so_25809873_25810115_2\">Effects: Inserts t <strong>if and only if there is no element in the container with key equivalent to the key of t</strong>. The bool component of the returned pair is true if and only if the insertion takes place, and the iterator component of the pair points to the element with key equivalent to the key of t.</p>\n</blockquote>\n<p>so I'd say that nothing should happen and that your <code>Object</code> is still valid and not unspecified state.</p>\n<p><strong>EDIT</strong>: As someone pointed out in the comment, this may actually depends on the implementation as it requires explicitly that the set is not modified, but states no explicit requirement on the argument and whether it's been moved or not.</p>\n", "LastEditorUserId": "1594913", "LastActivityDate": "2014-09-12T20:03:12.560", "Score": "2", "CreationDate": "2014-09-12T14:01:33.150", "ParentId": "25809873", "CommentCount": "5", "LastEditDate": "2014-09-12T20:03:12.560", "OwnerUserId": "1594913"}, "25814424": {"Id": "25814424", "PostTypeId": "2", "Body": "<p>A <code>std::move()</code>ed object passed to a standard library function should be considered to be moved from: the library is free to consider the object to be its only reference, i.e., it may move from it even if it doesn't use it. The relevant clause is 17.6.4.9 [res.on.arguments] paragraph 2, third bullet (it seems identical in C++11 and C++14):</p>\n<blockquote>\n<p id=\"so_25809873_25814424_0\">If a function argument binds to an rvalue reference, the implementation may assume that this parameter is a unique reference to this argument. ...</p>\n</blockquote>\n", "LastActivityDate": "2014-09-12T18:19:03.007", "Score": "6", "CreationDate": "2014-09-12T18:19:03.007", "ParentId": "25809873", "CommentCount": "0", "OwnerUserId": "1120273"}});