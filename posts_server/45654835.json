post_cb({"45655158": {"ParentId": "45654835", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2017-08-12T21:39:19.847", "Score": "-1", "LastEditorUserId": "8451077", "LastEditDate": "2017-08-12T21:47:15.960", "Id": "45655158", "OwnerUserId": "8451077", "Body": "<p>The destructor is called before calling to the delete operator. See <a href=\"http://en.cppreference.com/w/cpp/language/delete\" rel=\"nofollow noreferrer\">cppreference - delete expression</a></p>\n<blockquote>\n<p id=\"so_45654835_45655158_0\">If expression is not a null pointer, the delete expression invokes the destructor (if any) for the object that's being destroyed, or for every element of the array being destroyed (proceeding from the last element to the first element of the array).\n  After that, unless the matching new-expression was combined with another new-expression (since C++14) the delete expression invokes the deallocation function, either operator delete (for the first version of the expression) or operator delete[] (for the second version of the expression). </p>\n</blockquote>\n<p>Due to this order of operations, the destructor is called and throws an exception before your overloaded version of the delete operator is called.</p>\n", "LastActivityDate": "2017-08-12T21:47:15.960"}, "45655250": {"ParentId": "45654835", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2017-08-12T21:54:51.143", "Score": "5", "LastEditorUserId": "6040181", "LastEditDate": "2017-08-13T09:46:14.977", "Id": "45655250", "OwnerUserId": "6040181", "Body": "<p>The \n<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">standard Draft N4296</a> 5.3.5, pag 121 says:</p>\n<blockquote>\n<p id=\"so_45654835_45655250_0\">[expr.delete] [ Note: The deallocation function\n  is called regardless of whether the destructor for the object or some element of the array throws an exception.\n  \u2014 end note ]</p>\n</blockquote>\n<p>So the <code>operator delete</code> has to be called regardeless the destructor throws.</p>\n<p>However, as has emerged from the comments, some compilers does not properly call the <code>operator delete</code>. This can be resolved as bug compiler.</p>\n<p>Bug tested for:</p>\n<ul>\n<li><a href=\"http://coliru.stacked-crooked.com/a/b89537fd1ed1164e\" rel=\"nofollow noreferrer\">GCC 4.8</a></li>\n<li><a href=\"http://rextester.com/OXS55762\" rel=\"nofollow noreferrer\">Visual Studio 2015</a></li>\n</ul>\n", "LastActivityDate": "2017-08-13T09:46:14.977"}, "45654835": {"CommentCount": "13", "AcceptedAnswerId": "45655250", "PostTypeId": "1", "LastEditorUserId": "1711796", "CreationDate": "2017-08-12T20:52:27.340", "LastActivityDate": "2017-08-13T09:46:14.977", "LastEditDate": "2017-08-12T21:34:41.230", "ViewCount": "405", "FavoriteCount": "1", "Title": "Why is an overloaded delete not called when an exception is thrown in a destructor?", "Id": "45654835", "Score": "8", "Body": "<p>I've written the below code which overloads the <code>new</code> and <code>delete</code> operators and throws an exception in the destructor.</p>\n<p>When the exception is thrown, why is the code in the <code>delete</code> operator not executed (and \"bye\" printed)?</p>\n<p>If it shouldn't be executed, (how) is the memory freed? Is <a href=\"http://en.cppreference.com/w/cpp/memory/new/operator_delete\" rel=\"nofollow noreferrer\">one of the other <code>delete</code> operators</a> called? Would overloading one of them instead result in the corresponding code being executed? Or is the memory simply not freed because a failed destruction implies that maybe it shouldn't be?</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nclass A\n{\npublic:\n    A() { }\n    ~A() noexcept(false) { throw exception(); }\n    void* operator new (std::size_t count)\n    {\n        cout &lt;&lt; \"hi\" &lt;&lt; endl;\n        return ::operator new(count);\n    }\n    void operator delete (void* ptr)\n    {\n        cout &lt;&lt; \"bye\" &lt;&lt; endl;\n        return ::operator delete(ptr);\n    }\n    // using these (with corresponding new's) don't seem to work either\n    // void operator delete (void* ptr, const std::nothrow_t&amp; tag);\n    // void operator delete (void* ptr, void* place);\n};\n\nint main()\n{\n    A* a = new A();\n    try\n    {\n        delete a;\n    }\n    catch(...)\n    {\n        cout &lt;&lt; \"eek\" &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>hi\neek\n</code></pre>\n<p><a href=\"http://ideone.com/6GVeXu\" rel=\"nofollow noreferrer\">Live demo</a>.</p>\n<p>I looked at:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/130117/throwing-exceptions-out-of-a-destructor\">throwing exceptions out of a destructor</a></li>\n<li><a href=\"https://stackoverflow.com/questions/19686769/how-does-c-free-the-memory-when-a-constructor-throws-an-exception-and-a-custom\">How does C++ free the memory when a constructor throws an exception and a custom new is used</a></li>\n<li>And others</li>\n</ul>\n<p>But I couldn't find an answer to what exactly happens (1) for an exception in the destructor (as opposed to the constructor) and (2) with an overloaded delete.</p>\n<p>I don't need a lecture on throwing an exception in a destructor being bad practice - I just ran into similar code and I'm curious about the behaviour.</p>\n<hr>\n<p>I would prefer an answer supported by the standard or similar references, if such references exist.</p>\n</hr>", "Tags": "<c++><c++11><exception><destructor><delete-operator>", "OwnerUserId": "1711796", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_45654835_45655866_2": {"section_id": 6110, "quality": 0.9666666666666667, "length": 29}, "so_45654835_45655866_3": {"section_id": 6111, "quality": 1.0, "length": 7}, "so_45654835_45655866_7": {"section_id": 6111, "quality": 0.8260869565217391, "length": 19}, "so_45654835_45655866_6": {"section_id": 6111, "quality": 0.8571428571428571, "length": 6}, "so_45654835_45655866_0": {"section_id": 6110, "quality": 0.92, "length": 23}, "so_45654835_45655866_5": {"section_id": 6111, "quality": 0.975, "length": 39}, "so_45654835_45655250_0": {"section_id": 6111, "quality": 0.7058823529411765, "length": 12}, "so_45654835_45655866_1": {"section_id": 6111, "quality": 0.7142857142857143, "length": 5}, "so_45654835_45655866_4": {"section_id": 6111, "quality": 0.8888888888888888, "length": 24}}, "n3337": {"so_45654835_45655866_2": {"section_id": 5876, "quality": 0.9666666666666667, "length": 29}, "so_45654835_45655866_3": {"section_id": 5876, "quality": 0.8571428571428571, "length": 6}, "so_45654835_45655866_7": {"section_id": 5877, "quality": 0.8260869565217391, "length": 19}, "so_45654835_45655866_6": {"section_id": 407, "quality": 0.5714285714285714, "length": 4}, "so_45654835_45655866_0": {"section_id": 5876, "quality": 0.92, "length": 23}, "so_45654835_45655250_0": {"section_id": 5877, "quality": 0.7058823529411765, "length": 12}, "so_45654835_45655866_1": {"section_id": 5877, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_45654835_45655866_2": {"section_id": 7607, "quality": 0.9666666666666667, "length": 29}, "so_45654835_45655866_4": {"section_id": 7608, "quality": 0.8888888888888888, "length": 24}, "so_45654835_45655866_3": {"section_id": 7608, "quality": 1.0, "length": 7}, "so_45654835_45655866_6": {"section_id": 7608, "quality": 0.8571428571428571, "length": 6}, "so_45654835_45655866_0": {"section_id": 7607, "quality": 0.92, "length": 23}, "so_45654835_45655250_0": {"section_id": 7608, "quality": 0.7058823529411765, "length": 12}, "so_45654835_45655866_1": {"section_id": 7608, "quality": 0.7142857142857143, "length": 5}, "so_45654835_45655866_5": {"section_id": 7608, "quality": 0.975, "length": 39}, "so_45654835_45655866_7": {"section_id": 7608, "quality": 0.6086956521739131, "length": 14}}}, "45655866": {"ParentId": "45654835", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2017-08-12T23:44:16.963", "Score": "2", "LastEditorUserId": "1711796", "LastEditDate": "2017-08-13T00:03:25.653", "Id": "45655866", "OwnerUserId": "4706785", "Body": "<p>In the 1998 C++ standard (ISO/IEC 14882 First edition, 1998-09-01) the workings of a delete expression are stated quite simply in \"Section 5.3.5 Delete [expr.delete]\" in paras 6 and 7.</p>\n<blockquote>\n<p id=\"so_45654835_45655866_0\">6  The <em>delete-expression</em> will invoke the destructor (if any) for the object or the elements of the array being deleted. In the case of an array, the elements will be destroyed in order of decreasing address (that is, in\n  reverse order of the completion of their constructor; see 12.6.2).</p>\n<p id=\"so_45654835_45655866_1\">7 The <em>delete-expression</em> will call a <em>deallocation function</em> (3.7.3.2).</p>\n</blockquote>\n<p>In combination, these clauses require that destructor will be invoked (or destructors for an array) and that the deallocation function will be called unconditionally.   There is no provision here for not calling the deallocation function if an exception is thrown.</p>\n<p>In the 1998 standard, language lawyers and compiler developers will probably take delight in the sophistry of arguing a different interpretation than I've stated above.   Fortunately, things are more explicit in later standards...</p>\n<p>In <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">Draft N4296 available from open-std.org</a>  the same clauses are expanded as follows: (from memory the wording in the official standard is the same, but I don't have a copy on my current machine)<br>\n(emphasis mine)</br></p>\n<blockquote>\n<p id=\"so_45654835_45655866_2\">6 If the value of the operand of the <em>delete-expression</em> is not a null pointer value, the <em>delete-expression</em> will invoke the destructor (if any) for the object or the elements of the array being deleted. In the case of an\n  array, the elements will be destroyed in order of decreasing address (that is, in reverse order of the completion of their constructor; see 12.6.2).</p>\n<p id=\"so_45654835_45655866_3\">7 If the value of the operand of the <em>delete-expression</em>  is not a null pointer value, then:</p>\n<p id=\"so_45654835_45655866_4\">(7.1) - If the allocation call for the <em>new-expression</em> for the object to be deleted was not omitted and the allocation was not extended (5.3.4), the\n  <em>delete-expression</em> shall call a <em>deallocation function</em> (3.7.4.2). The value returned from the allocation call of the <em>new-expression</em> shall be passed as the first argument to the deallocation function.</p>\n<p id=\"so_45654835_45655866_5\">(7.2) - Otherwise, if the allocation was extended or was provided by extending the allocation of another <em>new-expression</em>, and the <em>delete-expression</em> for every other pointer value produced by a <em>new-expression</em> that had storage provided by the extended <em>new-expression</em> has been evaluated, the\n  <em>delete-expression</em> shall call a deallocation function. The value returned from the allocation call of the extended <em>new-expression</em> shall be passed as the first argument to the deallocation function.</p>\n<p id=\"so_45654835_45655866_6\">(7.3) - Otherwise, the <em>delete-expression</em> will not call a\n  deallocation function (3.7.4.2).</p>\n<p id=\"so_45654835_45655866_7\">Otherwise, it is unspecified whether the deallocation function will be called. [<em>Note:</em> <strong>The deallocation function is called regardless of whether the destructor for the object or some element of the array throws an exception.</strong> \u2014 <em>end note</em>]</p>\n</blockquote>\n<p>The note at the end spells out that the deallocation function must be called even if the destructor throws an exception.</p>\n<p>I'm unsure offhand which evolution of the standard first spelled things out, but based on the above, the clauses will probably remain in Section 5.3.5 (tag [expr.delete]).</p>\n", "LastActivityDate": "2017-08-13T00:03:25.653"}});