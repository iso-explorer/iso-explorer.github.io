post_cb({"bq_ids": {"n4140": {"so_17551316_17552291_0": {"length": 40, "quality": 0.5970149253731343, "section_id": 5451}}, "n3337": {"so_17551316_17552291_0": {"length": 62, "quality": 0.9253731343283582, "section_id": 5245}}, "n4659": {"so_17551316_17552291_0": {"length": 35, "quality": 0.5223880597014925, "section_id": 6889}}}, "17551316": {"ViewCount": "612", "Body": "<p>Consider this short program compiled with GCC 4.7.2 <code>g++ -std=c++11 test.cc</code></p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;queue&gt;\n\nstruct type{\n  type(int a) : v(a) {}\n  int v;\n};\n\ntypedef std::shared_ptr&lt;type&gt; type_ptr;\n\nint main(){\n  int value = 3;\n  std::queue&lt;type_ptr&gt; queue;\n  auto ptr{std::make_shared&lt;type&gt;(value)};\n  queue.push(ptr);\n}\n</code></pre>\n<p>The compiler outputs the following errors:</p>\n<pre><code>src/test.cc: In function \u2018int main()\u2019:\nsrc/test.cc:15:17: error: no matching function for call to \u2018std::queue&lt;std::shared_ptr&lt;type&gt; &gt;::push(std::initializer_list&lt;std::shared_ptr&lt;type&gt; &gt;&amp;)\u2019\nsrc/test.cc:15:17: note: candidates are:\nIn file included from /usr/include/c++/4.7/queue:65:0,\n                 from src/test.cc:2:\n/usr/include/c++/4.7/bits/stl_queue.h:211:7: note: void std::queue&lt;_Tp, _Sequence&gt;::push(const value_type&amp;) [with _Tp = std::shared_ptr&lt;type&gt;; _Sequence = std::deque&lt;std::shared_ptr&lt;type&gt;, std::allocator&lt;std::shared_ptr&lt;type&gt; &gt; &gt;; std::queue&lt;_Tp, _Sequence&gt;::value_type = std::shared_ptr&lt;type&gt;]\n/usr/include/c++/4.7/bits/stl_queue.h:211:7: note:   no known conversion for argument 1 from \u2018std::initializer_list&lt;std::shared_ptr&lt;type&gt; &gt;\u2019 to \u2018const value_type&amp; {aka const std::shared_ptr&lt;type&gt;&amp;}\u2019\n/usr/include/c++/4.7/bits/stl_queue.h:216:7: note: void std::queue&lt;_Tp, _Sequence&gt;::push(std::queue&lt;_Tp, _Sequence&gt;::value_type&amp;&amp;) [with _Tp = std::shared_ptr&lt;type&gt;; _Sequence = std::deque&lt;std::shared_ptr&lt;type&gt;, std::allocator&lt;std::shared_ptr&lt;type&gt; &gt; &gt;; std::queue&lt;_Tp, _Sequence&gt;::value_type = std::shared_ptr&lt;type&gt;]\n/usr/include/c++/4.7/bits/stl_queue.h:216:7: note:   no known conversion for argument 1 from \u2018std::initializer_list&lt;std::shared_ptr&lt;type&gt; &gt;\u2019 to \u2018std::queue&lt;std::shared_ptr&lt;type&gt; &gt;::value_type&amp;&amp; {aka std::shared_ptr&lt;type&gt;&amp;&amp;}\u2019\n</code></pre>\n<p>Indicating that the auto type is expanded to an initializer list instead of <code>std::shared_ptr&lt;type&gt;</code>; in fact replacing <code>{...}</code> with <code>= ...</code> makes the code compile as auto expands to the correct type.</p>\n<p>I'm a bit suprised that this seemingly obvious use case fails to achieve the expected result. Especially as I recall the new bracket initialization syntax to be touted as the end-all, be-all solution to initializing problems. </p>\n<p>So my question is: Was this intended in the standard? Or is it an oversight or even a gcc bug? Or am I just thinking about it wrong?</p>\n", "AcceptedAnswerId": "17552291", "Title": "(C++11) Auto with uniform initialization expands to unexpected type", "CreationDate": "2013-07-09T14:47:51.573", "Id": "17551316", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2015-05-18T15:26:53.157", "Score": "3", "OwnerUserId": "2498188", "Tags": "<c++11><standards><auto><uniform-initialization>", "AnswerCount": "1"}, "17552291": {"Id": "17552291", "PostTypeId": "2", "Body": "<p>As Xeo says in his comment, this is standard behavior. <strong>7.1.6.4 auto specifier [dcl.spec.auto]</strong> para 6 specifies:</p>\n<blockquote>\n<p id=\"so_17551316_17552291_0\">Once the type of a <em>declarator-id</em> has been determined according to 8.3, the type of the declared variable using the <em>declarator-id</em> is determined from the type of its initializer using the rules for template argument deduction. Let <code>T</code> be the type that has been determined for a variable identifier <code>d</code>. Obtain <code>P</code> from <code>T</code> by replacing the occurrences of <code>auto</code> with either a new invented type template parameter <code>U</code> or, if the initializer is a <em>braced-init-list</em> (8.5.4), with <code>std::initializer_list&lt;U&gt;</code>. The type deduced for the variable <code>d</code> is then the deduced <code>A</code> determined using the rules of template argument deduction from a function call (14.8.2.1), where <code>P</code> is a function template parameter type and the initializer for <code>d</code> is the corresponding argument. If\n  the deduction fails, the declaration is ill-formed.</p>\n</blockquote>\n<p>It is also widely despised - there's a <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3681.html\" rel=\"nofollow\">proposal under review by the committee</a> to change the behavior for C++14. C++14's support for generalized lambda capture <a href=\"https://groups.google.com/a/isocpp.org/forum/?fromgroups=#!searchin/std-proposals/brace-intialization/std-proposals/YTti2Vy1LGM/Z02smt4udEEJ\" rel=\"nofollow\">exacerbates the problem</a>.</p>\n<p>Update: In Urbana (See CWG Motion 16 in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4251.html\" rel=\"nofollow\">N4251 WG21 2014-11 Urbana Minutes</a>) the committee applied <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3922.html\" rel=\"nofollow\">N3922 New Rules for auto deduction from braced-init-list</a> to the C++17 Working Paper. They decided to fix the special case that allows <code>auto</code> to deduce an <code>initializer_list</code> by adding <strong>another</strong> special case. <code>auto</code> works the same way for <em>copy-list-initialization</em>, but for <em>direct-list-initialization</em> from a <em>braced-init-list</em> with a single element <code>auto</code> deduces from that element directly. <em>direct-list-initialization</em> from a multiple-element <em>braced-init-list</em> is now ill-formed.</p>\n<p>That means that given</p>\n<pre><code>auto x = {42};\n</code></pre>\n<p><code>x</code> has type <code>std::initializer_list&lt;int&gt;</code>, but in</p>\n<pre><code>auto x{42};\n</code></pre>\n<p><code>x</code> is an <code>int</code>.</p>\n", "LastEditorUserId": "923854", "LastActivityDate": "2015-05-18T15:26:53.157", "Score": "7", "CreationDate": "2013-07-09T15:32:26.343", "ParentId": "17551316", "CommentCount": "3", "OwnerUserId": "923854", "LastEditDate": "2015-05-18T15:26:53.157"}});