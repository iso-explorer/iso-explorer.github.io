post_cb({"9087364": {"CommentCount": "2", "ViewCount": "313", "PostTypeId": "1", "LastEditorUserId": "363663", "CreationDate": "2012-01-31T21:41:39.873", "LastActivityDate": "2012-02-01T10:54:49.130", "Title": "Multiple polymorphism in C++", "LastEditDate": "2012-02-01T10:54:49.130", "Id": "9087364", "Score": "2", "Body": "<p>There's the compile error \" ' A ' is an ambiguous base of ' C ' \" existing on the test <code>diamond multiple inheritance</code> below,</p>\n<pre><code>struct A { void f();};\nstruct B1: A {};\nstruct B2: A {};\nstruct C: B1, B2 {};\n\nvoid g() {A *o = new C;}\n</code></pre>\n<p>It's solved by <code>virtual inheritance</code> below,</p>\n<pre><code>struct B1: virtual A {};\nstruct B2: virtual A {};\n</code></pre>\n<p>Now there's the compile error \" no unique final overridder for ' virtual void A::f() ' in ' C ' \" existing on another test <code>diamond multiple polymorphism</code> below,</p>\n<pre><code>struct A {virtual void f();};\nstruct B1: virtual A {void f();};\nstruct B2: virtual A {void f();};\nstruct C: B1, B2 {};\n\nvoid g() {\n A *o = new C;\n o-&gt;f();\n}\n</code></pre>\n<p>And it can't be solved even by <code>dynamic_cast</code> below,</p>\n<pre><code>dynamic_cast&lt;B1 *&gt;(o)-&gt;f();\n</code></pre>\n<p><strong>@NOTE</strong></p>\n<p><code>dynamic_cast&lt;T *&gt;(obj_ptr)</code> is actually used to perform <code>typesafe downcast</code>, i.e. when the run-time type Tobj of the object that the obj_ptr points to is a subtype of T, it returns obj_ptr itself; otherwise the NULL pointer. It is mistaken being thought of upcasting the subtype Tobj to the supertype T, otherwise performing upcast at run-time directly contradicts the principle of polymorphism.</p>\n<p>IMHO, <code>virtual inheritance</code> is succinct enough to solve the first-half problem at compile-time. In contrast, can you present anything to solve the second-half problem at run-time?</p>\n<p><strong>@EDIT</strong></p>\n<p>Thanks for your pointing out <code>dynamic_cast</code> doesn't do the job. Corrected.</p>\n<p>To sovle the 2nd-half problem, it seems to have no choice but implement the overrider on the final subclass of the diamond hierarchy below,</p>\n<pre><code>struct C: B1, B2 {\n void f() {B1::f();} //Hardcode to your choice of overrider\n};\n</code></pre>\n", "Tags": "<c++><polymorphism><multiple-inheritance>", "OwnerUserId": "363663", "AnswerCount": "4"}, "9087428": {"ParentId": "9087364", "CommentCount": "0", "Body": "<p>f() is ambiguous so the compiler does not know which f() to call. Use dynamic_cast as your already suggested.</p>\n", "OwnerUserId": "800454", "PostTypeId": "2", "Id": "9087428", "Score": "0", "CreationDate": "2012-01-31T21:46:19.503", "LastActivityDate": "2012-01-31T21:46:19.503"}, "9087411": {"ParentId": "9087364", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2012-01-31T21:45:16.860", "Score": "2", "LastEditorUserId": "233522", "LastEditDate": "2012-01-31T21:56:07.753", "Id": "9087411", "OwnerUserId": "233522", "Body": "<p>Your second example is ill-formed, even without the call. A compiler that accepts it is non-standard conforming. This is quite well illustrated in the C++ standard ( C++11/10.3.13 ):</p>\n<blockquote>\n<p id=\"so_9087364_9087411_0\">The following example shows a function that does not have a unique\n  final overrider: </p>\n</blockquote>\n<pre><code>struct A { \n  virtual void f(); \n}; \n\nstruct VB1 : virtual A { // note virtual derivation \n  void f(); \n}; \n\nstruct VB2 : virtual A {\n  void f(); \n}; \n\nstruct Error : VB1, VB2 { // ill-formed }; \n\nstruct Okay : VB1, VB2 { \n  void f(); \n}; \n</code></pre>\n<blockquote>\n<p id=\"so_9087364_9087411_1\">Both VB1::f and VB2::f override A::f but there\n  is no overrider of both of them in class Error. This example is\n  therefore ill-formed. Class Okay is well formed, however, because\n  Okay::f is a final overrider.</p>\n</blockquote>\n<p>As you see there is also a solution presented. In the overriden function you can decide which parent function you want to call, or even call both, by using <code>::</code>.</p>\n<pre><code>struct Okay : VB1, VB2 { \n  void f() { \n    VB1::f(); \n    VB2::f(); \n  }\n}; \n</code></pre>\n", "LastActivityDate": "2012-01-31T21:56:07.753"}, "9087472": {"ParentId": "9087364", "CommentCount": "2", "Body": "<p>Well, you still don't have a unique override for <code>f()</code>: this needs to be defined in <code>C</code> using e.g.:</p>\n<pre><code>struct C: B1, B2 { void f() { this-&gt;B1::f(); } };\n</code></pre>\n<p>You can explicitly qualify a function to enforce using this function without dynamic dispatch (this is the only way to call an abstract function when the object is complete constructed and not yet being destroyed).</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "9087472", "Score": "2", "CreationDate": "2012-01-31T21:50:42.997", "LastActivityDate": "2012-01-31T21:50:42.997"}, "9087965": {"ParentId": "9087364", "CommentCount": "1", "Body": "<p>You probably need to virtual-quantify f() in subclasses as well.</p>\n<pre><code>struct A {virtual void f();};\nstruct B1: virtual A {virtual void f();};\nstruct B2: virtual A {virtual void f();};\nstruct C: B1, B2 {};\n\nvoid g() {\n A *o = new C;\n o-&gt;f();\n}\n</code></pre>\n", "OwnerUserId": "1066452", "PostTypeId": "2", "Id": "9087965", "Score": "0", "CreationDate": "2012-01-31T22:27:17.530", "LastActivityDate": "2012-01-31T22:27:17.530"}, "bq_ids": {"n4140": {"so_9087364_9087411_0": {"section_id": 7014, "quality": 0.9, "length": 9}, "so_9087364_9087411_1": {"section_id": 7014, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_9087364_9087411_0": {"section_id": 6760, "quality": 0.9, "length": 9}, "so_9087364_9087411_1": {"section_id": 6760, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_9087364_9087411_0": {"section_id": 8511, "quality": 0.9, "length": 9}, "so_9087364_9087411_1": {"section_id": 8511, "quality": 0.9583333333333334, "length": 23}}}});