post_cb({"5552911": {"ParentId": "5552455", "CommentCount": "0", "CreationDate": "2011-04-05T13:49:23.830", "OwnerUserId": "622220", "PostTypeId": "2", "Id": "5552911", "Score": "2", "Body": "<p>If there are two or more equally good candidates for function template specialization, you will get a compiler error.</p>\n<p><a href=\"ftp://std.dkuug.dk/mirror/www.maths.warwick.ac.uk/cpp/iso/wp/html/current/over.html#over.match.best\" rel=\"nofollow\">C++ standard says:</a></p>\n<blockquote>\n<p id=\"so_5552455_5552911_0\">If there is exactly one viable function that is a better function than\n    all  other  viable  functions, then it is the one selected by overload\n    resolution; otherwise the call is ill-formed12).</p>\n</blockquote>\n", "LastActivityDate": "2011-04-05T13:49:23.830"}, "5553061": {"ParentId": "5552455", "CommentCount": "0", "CreationDate": "2011-04-05T13:58:43.257", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "5553061", "Score": "0", "Body": "<p>Using it on a map seems to work. </p>\n<p>However, if you were to use it on some container where key_type and value_type were the same type, this would end up defining \"the same\" function twice (and differently on top of that).</p>\n<p>\u00a713.1</p>\n<blockquote>\n<p id=\"so_5552455_5553061_0\">Certain function declarations cannot be overloaded:<br>\n  ...<br>\n  \u2014 Parameter declarations that differ only in the use of equivalent typedef \u201ctypes\u201d are equivalent. A\n  typedef is not a separate type, but only a synonym for another type (7.1.3).<br>\n  [ Example:<br>\n<code>typedef int Int;</code><br>\n<code>void f(int i);</code><br>\n<code>void f(Int i); // OK: redeclaration of f(int)</code><br>\n<code>void f(int i) { /* ... */ }</code><br>\n<code>void f(Int i) { /* ... */ } // error: redefinition of f(int)</code><br>\n  \u2014end example ]</br></br></br></br></br></br></br></br></br></p>\n</blockquote>\n", "LastActivityDate": "2011-04-05T13:58:43.257"}, "5552528": {"ParentId": "5552455", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2011-04-05T13:21:01.633", "Score": "2", "LastEditorUserId": "616700", "LastEditDate": "2011-04-05T13:26:20.653", "Id": "5552528", "OwnerUserId": "616700", "Body": "<p>The <code>key_type</code> template is a match, the <code>value_type</code> template isn't.</p>\n<p><code>map&lt;int,int&gt;::value_type</code> is a <code>pair&lt;const int,int&gt;</code> - so only your first template will match. If your second template used e.g. <code>mapped_type</code> you'd have a compiler error due to ambiguity.</p>\n", "LastActivityDate": "2011-04-05T13:26:20.653"}, "5552455": {"CommentCount": "1", "AcceptedAnswerId": "5554093", "PostTypeId": "1", "LastEditorUserId": "55094", "CreationDate": "2011-04-05T13:16:45.013", "LastActivityDate": "2011-04-20T07:23:27.970", "LastEditDate": "2011-04-20T07:23:27.970", "ViewCount": "1248", "FavoriteCount": "1", "Title": "Priority of template selection in C++", "Id": "5552455", "Score": "3", "Body": "<p>I just written the following piece of code</p>\n<pre><code>template&lt;typename T&gt;\ninline bool contains(T haystack,typename T::key_type needle) {\n    return haystack.find(needle) != haystack.end();\n}\n\ntemplate&lt;typename T&gt;\ninline bool contains(T haystack,typename T::value_type needle) {\n    return find(haystack.begin(),haystack.end(),needle) != haystack.end();\n}\n</code></pre>\n<p>When I'm instantiating the template with <code>vector</code> which doesn't have <code>key_type</code> typedef, <code>SFINAE</code> would make sure I wouldn't instantiate the first version. But what if I'm instantiating the template with a <code>map</code>, which have both <code>key_type</code> and <code>value_type</code> typedefs? How will the compiler choose which template function to use?</p>\n<p>With current STL map, <code>key_type</code> is a <code>pair</code>, however what happens if I define a type where <code>key_type</code> is the same as <code>value_type</code>?</p>\n<pre><code>class MyMap {typedef int key_type;typedef int value_type;};\nMyMap m;\ncontains(m,1); // both functions are valid, which will be chosen?\n</code></pre>\n<p>And surprise surprise, <code>std::set</code> has <code>key_type == value_type</code>. So I really need to resort to template meta programming in order to have a simple <code>contains</code> function. <em>Sigh</em>.</p>\n<p>Bonus point for quoting the standard.</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "55094", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_5552455_5552911_0": {"section_id": 604, "quality": 0.95, "length": 19}}, "n3337": {"so_5552455_5552911_0": {"section_id": 594, "quality": 0.95, "length": 19}}, "n4659": {"so_5552455_5552911_0": {"section_id": 630, "quality": 0.95, "length": 19}}}, "5554093": {"ParentId": "5552455", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2011-04-05T15:07:23.993", "Score": "3", "LastEditorUserId": "36565", "LastEditDate": "2011-04-05T15:32:19.977", "Id": "5554093", "OwnerUserId": "36565", "Body": "<p>If you are willing to do it, you can, with some metaprogramming help to aid you. Basically you would need to write a template metafunction that determines the condition under which you want to call one or the other functions, and use that in an <code>enable_if_c</code> clause:</p>\n<pre><code>template &lt;typename T&gt; inline\ntypename enable_if_c&lt; has_key_type&lt;T&gt;::value, bool &gt;::type\ncontains( T const &amp; c, T::key_type const &amp; k ) {...}        // associative container\n\ntemplate &lt;typename T&gt; inline\ntypename enable_if_c&lt; !has_key_type&lt;T&gt;::value, bool &gt;::type\ncontains( T const &amp; c, T::value_type const &amp; k ) {...}      // non-associative container\n</code></pre>\n<p>The <code>enable_if_c</code> template is a simple common SFINAE trick (that you can use from a C++0x compiler or boost). It takes a condition and a type, if the condition is true, it will generate an inner typedef to the argument type, if it is not present it will not define that inner type, and that can be used outside in SFINAE:</p>\n<pre><code>template &lt;bool condition, typename T&gt;\nstruct enable_if_c {};        // by default do not declare inner type\n\ntemplate &lt;typename T&gt;\nstruct enable_if_c&lt;true,T&gt; {  // if true, typedef the argument as inner type\n    typedef T type;\n};\n</code></pre>\n<p>Now the interesting part is how to determine that a type <code>T</code> has an inner type <code>key_type</code>, and while there might be other options, the first that comes to mind is:</p>\n<pre><code>template &lt;typename T&gt;\nclass has_key_type {\n    typedef char _a;\n    struct _b { _a x[2]; };\n\n    template &lt;typename U&gt;\n    static _a foo( U const &amp;, typename U::key_type* p = 0 );\n    static _b foo( ... );\n    static T&amp; generate_ref();\npublic:\n    static const bool value = sizeof(foo(generate_ref())) == sizeof(_a);\n};\n</code></pre>\n<p>The template <code>has_key_type</code> will contain an inner constant <code>value</code> that is <code>true</code> only if the type passed int contains an inner <code>T::key_type</code> type. The resolutions is not too complex: define a template function that will fail for all types but the one you want to detect, and provide a different overload with ellipsis so that it will catch if the template (has higher priority than the ellipsis) fails to substitute. Then use the size of the return types to detect which overload was chosen by the compiler. The <code>generate_ref</code> is there to avoid having to actually construct an object (i.e. do not impose that <code>T</code> can be constructed in any specific way).</p>\n<p>The overall result is that when the type <code>T</code> contains an inner type <code>key_type</code>, the result of <code>has_key_type&lt;T&gt;::value</code> will be true, and the <code>enable_if_c</code> will enable the first overload and disable the second, so SFINAE will discard the second overload not because of the type second function argument not being defined, but rather on terms of the return type.</p>\n<p>If you think of it, there is just a bunch of boiler plate code around a small change: instead of providing two ambiguous template function overloads, provide a template overload and a lesser priority function (ellipsis). Since you cannot really use that ellipsis function to implement the non-associative container version, it is used to obtain a boolean value that is then seeded into common metaprogramming structures and boilerplate.</p>\n", "LastActivityDate": "2011-04-05T15:32:19.977"}});