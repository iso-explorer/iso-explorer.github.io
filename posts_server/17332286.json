post_cb({"17332286": {"ViewCount": "130", "Body": "<p>Using gcc 4.7.3, I get the following error</p>\n<blockquote>\n<p id=\"so_17332286_17332286_0\">prog.cpp: In function \u2018int main()\u2019: prog.cpp:27:63: error:\n  \u2018Erase &gt;::Result\u2019 has not been\n  declared</p>\n</blockquote>\n<p>with <a href=\"http://ideone.com/Q8sRG3\" rel=\"nofollow\">this code</a>:</p>\n<pre><code>template &lt;typename... List&gt;\nstruct TypeList\n{\n    enum\n    {\n        Length = sizeof...(List)\n    };\n};\n\ntemplate &lt;typename ToErase, typename... List&gt;\nstruct Erase;\n\ntemplate &lt;typename ToErase&gt;\nstruct Erase&lt;ToErase, TypeList&lt;&gt;&gt;\n{\n    typedef TypeList&lt;&gt; Result;\n};\n\ntemplate &lt;typename ToErase, typename... Head, typename... Tail&gt;\nstruct Erase&lt;ToErase, TypeList&lt;Head..., ToErase, Tail...&gt;&gt;\n{\n    typedef TypeList&lt;Head..., Tail...&gt; Result;\n};\n\nint main()\n{\n    static_assert(Erase&lt;double, TypeList&lt;int, double, char&gt;&gt;::Result::Length == 2, \n    \"Did not erase double from TypeList&lt;int, double, char&gt;\");\n\n    return 0;\n}\n</code></pre>\n<p>I don't understand why the code doesn't compile given the error message I've received, given that a similar case does compile cleanly:</p>\n<pre><code>template &lt;typename ToAppend, typename... List&gt;\nstruct Append;\n\ntemplate &lt;typename ToAppend, typename... List&gt;\nstruct Append&lt;ToAppend, TypeList&lt;List...&gt;&gt;\n{\n    typedef TypeList&lt;List..., ToAppend&gt; Result;\n}\n\ntemplate &lt;typename... ToAppend, typename... List&gt;\nstruct Append&lt;TypeList&lt;ToAppend...&gt;, TypeList&lt;List...&gt;&gt;\n{\n    typedef TypeList&lt;List..., ToAppend...&gt; Result;\n}\n</code></pre>\n<p>Is there a quote from the standard about not being able to deduce elements in the middle of two parameter packs like I'm trying to do with the first block of code?</p>\n", "AcceptedAnswerId": "17335098", "Title": "Why does this variadic template specialization definition not compile?", "CreationDate": "2013-06-26T23:46:47.417", "Id": "17332286", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-06-27T05:22:28.803", "Score": "2", "OwnerUserId": "1181561", "Tags": "<c++><c++11><variadic-templates><typelist>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_17332286_17335098_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 336}}, "n3337": {"so_17332286_17335098_0": {"length": 7, "quality": 1.0, "section_id": 326}}, "n4659": {"so_17332286_17335098_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 345}}}, "17335098": {"Id": "17335098", "PostTypeId": "2", "Body": "<p>\u00a7 14.8.2.5 (Deducing template arguments from a type) paragraph 5 lists the contexts in which template arguments cannot be deduced. The relevant one is the last one in the list:</p>\n<blockquote>\n<p id=\"so_17332286_17335098_0\">\u2014 A function parameter pack that does not occur at the end of the parameter-declaration-clause.</p>\n</blockquote>\n<p>So in:</p>\n<pre><code>struct Erase&lt;ToErase, TypeList&lt;Head..., ToErase, Tail...&gt;&gt;\n</code></pre>\n<p><code>Head</code> cannot be deduced; it does not occur at the end of a parameter list.</p>\n<p>By contrast, in:</p>\n<pre><code>struct Append&lt;TypeList&lt;ToAppend...&gt;, TypeList&lt;List...&gt;&gt;\n</code></pre>\n<p>Both <code>ToAppend</code> and <code>List</code> appear at the end of their respective parameter lists, and hence they can be deduced.</p>\n", "LastActivityDate": "2013-06-27T05:22:28.803", "CommentCount": "0", "CreationDate": "2013-06-27T05:22:28.803", "ParentId": "17332286", "Score": "3", "OwnerUserId": "1566221"}});