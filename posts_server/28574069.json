post_cb({"28580509": {"ParentId": "28574069", "CommentCount": "3", "Body": "<p><em>does it imply that these languages require that a special value in the address space is dead, meaning that it's unusable except for the role of representing nullptr?</em></p>\n<p>Yes. </p>\n<p>C has requirements for null pointer that make it different to object pointers:</p>\n<blockquote>\n<p id=\"so_28574069_28580509_0\">(C11, 6.3.2.3p3) \"[...] If a null pointer constant is converted to a pointer type, the resulting pointer, called a null pointer, is guaranteed to compare unequal to a pointer to any object or function.\"</p>\n</blockquote>\n<p><em>What if the system has a really useful function or data structure at the same address that's equal to nullptr? Should this never happen because it's a compiler writer responsibility to figure out a non-conflicting null pointer value for each system the compiler compiles to?</em></p>\n<p>The New C Standard by Derek M. Jones provides the following commentary on implementations:</p>\n<blockquote>\n<p id=\"so_28574069_28580509_1\">All bits zero is a convenient execution-time representation of the null pointer constant for many implementations because it is invariably the lowest address in storage. (The INMOS Transputer[632] had a signed\n  address space, which placed zero in the middle.) Although there may be program bootstrap information at\n  this location, it is unlikely that any objects or functions will be placed here. Many operating systems leave\n  this storage location unused because experience has shown that program faults sometimes cause values to be\n  written into the location specified by the null pointer constant (the more developer-oriented environments try\n  to raise an exception when that location is accessed).</p>\n<p id=\"so_28574069_28580509_2\">Another implementation technique, when the host environment does not include address zero as part of a\n  processes address space, is to create an object (sometimes called _ _null) as part of the standard library. All\n  references to the null pointer constant refer to this object, whose address will compare unequal to any other\n  object or function.</p>\n</blockquote>\n", "OwnerUserId": "1119701", "PostTypeId": "2", "Id": "28580509", "Score": "2", "CreationDate": "2015-02-18T09:53:09.443", "LastActivityDate": "2015-02-18T09:53:09.443"}, "28574069": {"CommentCount": "18", "ViewCount": "662", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-02-18T00:52:10.520", "LastActivityDate": "2017-01-19T18:37:58.940", "Title": "Do C and C++ standards imply that a special value in the address space must exist solely to represent the value of null pointers?", "AcceptedAnswerId": "28581547", "LastEditDate": "2017-05-23T11:52:55.303", "Id": "28574069", "Score": "0", "Body": "<p>Following discussion from <a href=\"https://stackoverflow.com/q/28573215/1000282\">this question</a> about null pointers in C and C++, I'd like to have the ending question separated here.</p>\n<p>If it can be inferred from C and C++ standards (answers can target both standards) that dereferencing a pointer variable whose value is equal to the <code>nullptr</code> (or <code>(void *)0</code>) value is undefined behavior, does it imply that these languages require that a special value in the address space is <em>dead</em>, meaning that it's unusable except for the role of representing <code>nullptr</code>? What if the system has a really useful function or data structure at the same address that's equal to <code>nullptr</code>? Should this never happen because it's a compiler's writer responsibility to figure out a non-conflicting null pointer value for each system the compiler compiles to? Or should the programmer that needs to access such function or data structure be content while programming in \"undefined behavior mode\" to achieve its intents?</p>\n<p>This looks like blurring the lines of the roles of a compiler and a computer system. I would ask whether it's right to do so, but I guess there's no room for this here.</p>\n<p><a href=\"http://nosubstance.me/post/dereferencing-null-pointers/\" rel=\"nofollow noreferrer\">This blog post digs about tackling the problem situation</a></p>\n", "Tags": "<c++><c><language-lawyer><systems-programming>", "OwnerUserId": "1000282", "AnswerCount": "4"}, "28581547": {"ParentId": "28574069", "PostTypeId": "2", "CommentCount": "18", "Body": "<blockquote>\n<p id=\"so_28574069_28581547_0\">does it imply that these languages require that a special value in the address space is dead, meaning that it's unusable except for the role of representing <code>nullptr</code>?</p>\n</blockquote>\n<p>No.</p>\n<p>The compiler needs a special value to represent a null pointer, and must take care that it does not place any object or function at that address, because all pointers to objects and functions are required to compare unequal to the null pointer. The standard library must take similar precautions in its implementation of <code>malloc</code> and friends.</p>\n<p>However, if there is something at that address already, something that no strictly conforming program can access, then an implementation <em>is</em> allowed to support dereferencing the null pointer to access it. Dereferencing the null pointer is undefined in standard C, so an implementation can make it do anything it likes, including the obvious.</p>\n<p>Both the C and the C++ standards understand the concept of the <em>as-if</em> rule, which basically means that if to valid input, an implementation is indistinguishable from one that conforms to the standard, then it <em>does</em> conform to the standard. The C standard uses a trivial example:</p>\n<blockquote>\n<p id=\"so_28574069_28581547_1\"><strong>5.1.2.3 Program execution</strong></p>\n<p id=\"so_28574069_28581547_2\">10 EXAMPLE 2 In executing the fragment</p>\n<pre><code>char c1, c2;\n/* ... */\nc1 = c1 + c2;\n</code></pre>\n<p id=\"so_28574069_28581547_3\">the \"integer promotions\" require that the abstract machine promote the value of each variable to <code>int</code> size and then add the two <code>int</code>s and truncate the sum. Provided the addition of two <code>char</code>s can be done without\n  overflow, or with overflow wrapping silently to produce the correct result, the actual execution need only produce the same result, possibly omitting the promotions.</p>\n</blockquote>\n<p>Now, if <code>c1</code> and <code>c2</code>'s values come from registers, and it's possible to force values outside of <code>char</code>'s range into those registers (e.g. by inline assembly), then the fact that the implementation optimises away the integer promotions might be observable. However, since the only way to observe it is through undefined behaviour or implementation extensions, there is no way for any standard code to be affected by this, and an implementation is allowed to do it.</p>\n<p>This is the same logic that applies to getting useful results when dereferencing null pointers: there are only two ways to see, from code, that there is something meaningful at that particular address: getting a null pointer from an evaluation that is guaranteed to produce a pointer to an object, or by just trying it. The former is what I mentioned the compiler and standard library must take care of. The latter is not something that can affect a valid standard program.</p>\n<hr>\n<p>A well-known example is the interrupt vector table on DOS implementations, which resides at address zero. It is typically accessed simply by dereferencing a null pointer. The C and C++ standards don't, shouldn't and cannot cover access to the interrupt vector table. They do not define such behaviour, but they do not restrict access to it either. Implementations should be and are allowed to provide extensions to access it.</p>\n</hr>", "OwnerUserId": "743382", "LastEditorUserId": "743382", "LastEditDate": "2017-01-19T18:37:58.940", "Id": "28581547", "Score": "2", "CreationDate": "2015-02-18T10:40:35.447", "LastActivityDate": "2017-01-19T18:37:58.940"}, "28574093": {"ParentId": "28574069", "PostTypeId": "2", "CommentCount": "36", "Body": "<p>Yes, that's precisely what it means.</p>\n<blockquote>\n<p id=\"so_28574069_28574093_0\"><code>[C++11: 4.10/1]:</code> <em>[..]</em> A null pointer constant can be converted to a pointer type; the result is the <em>null pointer value</em> of that type and is distinguishable from every other value of object pointer or function pointer type. <em>[..]</em></p>\n</blockquote>\n<p>The null pointer value doesn't need to be <code>0x00000000</code>, but it does need to be unique; there's no other way to make this rule work.</p>\n<p>It's certainly not the only rule of the abstract machine that implicitly emplaces strict limitations upon practical implementations.</p>\n<blockquote>\n<p id=\"so_28574069_28574093_1\">What if the OS puts a really useful function or data structure at the same address that's equal to nullptr?</p>\n</blockquote>\n<p>The OS won't do that but <a href=\"https://blogs.oracle.com/ksplice/entry/much_ado_about_null_exploiting1\" rel=\"nofollow\">it can be exploited</a>.</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2015-02-18T10:01:55.907", "Id": "28574093", "Score": "2", "CreationDate": "2015-02-18T00:54:41.137", "LastActivityDate": "2015-02-18T10:01:55.907"}, "28574467": {"ParentId": "28574069", "PostTypeId": "2", "CommentCount": "18", "Body": "<p>That depends on what is meant by the phrase \"address space\". The C standard uses the phrase informally, but doesn't define what it means.</p>\n<p>For each pointer type, there must be a <em>value</em> (the null pointer) that compares unequal to a pointer to any object or function. That means, for example, that if a pointer type is 32 bits wide, then there can be at most 2<sup>32</sup>-1 valid non-null values of that type. There could be fewer than that if some addresses have more than one representation, or if not all representations correspond to valid addresses.</p>\n<p>So if you define the \"address space\" to cover 2<sup>N</sup> distinct addresses, where N is the width in bits of a pointer, then yes, one of those values must be reserved as the null pointer value.</p>\n<p>On the other hand, if the \"address space\" is narrower than that (for example, typical 64-bit systems can't actually access 2<sup>64</sup> distinct memory locations), then the value reserved as the null pointer can easily be outside the \"address space\".</p>\n<p>Some things to note:</p>\n<ul>\n<li>The representation of a null pointer may or may not be all-bits-zero.</li>\n<li>Not all pointer types are necessarily the same size.</li>\n<li>Not all pointer types necessarily use the same representation for a null pointer.</li>\n</ul>\n<p>On most modern implementations, all pointer types <em>are</em> the same size, and all represent a null pointer as all-bits-zero, but there are valid reasons to, for example, make function pointers wider than object pointers, or make <code>void*</code> wider than <code>int*</code>, or use a representation other than all-bits-zero for the null pointer.</p>\n<p>This answer is based on the C standard. Most of it also applies to C++. (One difference is that C++ has pointer-to-member types, which are typically wider than ordinary pointers.)</p>\n", "OwnerUserId": "827263", "LastEditorUserId": "827263", "LastEditDate": "2015-02-18T16:34:07.893", "Id": "28574467", "Score": "4", "CreationDate": "2015-02-18T01:35:07.940", "LastActivityDate": "2015-02-18T16:34:07.893"}, "bq_ids": {"n4140": {"so_28574069_28574093_0": {"section_id": 39, "quality": 0.8695652173913043, "length": 20}, "so_28574069_28580509_0": {"section_id": 39, "quality": 0.631578947368421, "length": 12}}, "n3337": {"so_28574069_28574093_0": {"section_id": 36, "quality": 0.8695652173913043, "length": 20}, "so_28574069_28580509_0": {"section_id": 36, "quality": 0.631578947368421, "length": 12}}, "n4659": {"so_28574069_28574093_0": {"section_id": 39, "quality": 0.8695652173913043, "length": 20}, "so_28574069_28580509_0": {"section_id": 39, "quality": 0.631578947368421, "length": 12}}}});