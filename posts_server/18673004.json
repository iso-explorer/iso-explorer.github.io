post_cb({"20734293": {"ParentId": "18673004", "CommentCount": "0", "CreationDate": "2013-12-22T21:36:11.013", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "20734293", "Score": "2", "Body": "<p>Lambda expressions, even with an empty closure, can <strong>not</strong> be used as a pointer to function template argument because they are temporaries which just happen to convert to some pointer to function. The lambda expression is a temporary according to 5.1.2 [expr.prim.lambda] paragraph 2:</p>\n<blockquote>\n<p id=\"so_18673004_20734293_0\">The evaluation of a lambda-expression results in a prvalue temporary. [...]</p>\n</blockquote>\n<p>The conversion to a pointer to function is desribed in paragraph 6:</p>\n<blockquote>\n<p id=\"so_18673004_20734293_1\">The closure type for a lambda-expression with no lambda-capture has a public non-virtual non-explicit const conversion function to pointer to function having the same parameter and return types as the closure type\u2019s function call operator. The value returned by this conversion function shall be the address of a function that, when invoked, has the same effect as invoking the closure type\u2019s function call operator.</p>\n</blockquote>\n<p>That is, the conversion doesn't yield a <code>constexpr</code> and, thus, there is no hope to use the resulting pointer to function as a template argument.</p>\n<p>As for the reasons the best I could find for now is a statement in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3597.html\" rel=\"nofollow\">N3597</a> which points towards <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2859.pdf\" rel=\"nofollow\">N2895</a> which seem to talk about the actual problem but I couldn't locate a detailed discussion. It seems that name-mangling for the functions created by lambda expressions is one of the problems which prohibits using them in certain contexts.</p>\n", "LastActivityDate": "2013-12-22T21:36:11.013"}, "18673004": {"CommentCount": "5", "AcceptedAnswerId": "20734293", "PostTypeId": "1", "LastEditorUserId": "1095108", "CreationDate": "2013-09-07T11:52:23.657", "LastActivityDate": "2013-12-22T21:36:11.013", "LastEditDate": "2013-09-07T12:13:12.190", "ViewCount": "930", "FavoriteCount": "1", "Title": "compile-time conversion of lambda functors into function pointers", "Id": "18673004", "Score": "5", "Body": "<p>As we know, non-capturing lambda functors can be converted to function pointers at runtime, but how about compile time? That is, is something similar to the code below possible? Please don't suggest a workaround, like passing the lambda functor as a function parameter, I'd like to know more where/how the C++11 standard forbids this.</p>\n<pre><code>template &lt;void(*fptr)()&gt;\nvoid f()\n{\n  // do something\n}\n\nint main()\n{\n  auto l([]{});\n\n  f&lt;(void(*)())(decltype(l))&gt;();\n\n  return 0;\n}\n</code></pre>\n<p>The obligatory error with <code>gcc-4.8</code>:</p>\n<pre><code>c.cpp: In function 'int main()':\nc.cpp:11:7: error: parse error in template argument list\n       f&lt;(void(*)())(decltype(l))&gt;();\n       ^\nc.cpp:11:36: error: statement cannot resolve address of overloaded function\n       f&lt;(void(*)())(decltype(l))&gt;();\n                                    ^\n</code></pre>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1095108", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_18673004_20734293_0": {"section_id": 5961, "quality": 0.8333333333333334, "length": 5}, "so_18673004_20734293_1": {"section_id": 5965, "quality": 0.95, "length": 38}}, "n3337": {"so_18673004_20734293_0": {"section_id": 5730, "quality": 0.8333333333333334, "length": 5}, "so_18673004_20734293_1": {"section_id": 5734, "quality": 0.95, "length": 38}}, "n4659": {"so_18673004_20734293_1": {"section_id": 7456, "quality": 0.85, "length": 34}}}});