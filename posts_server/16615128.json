post_cb({"bq_ids": {"n4140": {"so_16615128_16615144_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 6092}}, "n3337": {"so_16615128_16615144_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 5859}}, "n4659": {"so_16615128_16615144_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 7588}}}, "16615144": {"Id": "16615144", "PostTypeId": "2", "Body": "<p>Of course: Array-new is allowed to allocate <em>more</em> memory than just the space for the objects, and usually will do so. When you say <code>delete [] x;</code>, how would the implementation know how many destructors to call?</p>\n<p>See 5.3.4/10:</p>\n<blockquote>\n<p id=\"so_16615128_16615144_0\">A <em>new-expression</em> passes the amount of space requested to the allocation function as the first argument of type <code>std::size_t</code>. That argument shall be no less than the size of the object being created; <strong>it may be greater than the size of the object being created only if the object is an array.</strong></p>\n</blockquote>\n<p>The Itanium ABI is <a href=\"http://refspecs.linux-foundation.org/cxxabi-1.83.html#array-cookies\" rel=\"nofollow\">specific about the use of array cookies</a>:</p>\n<pre class=\"lang-none prettyprint-override\"><code>|&lt;-- offset --&gt;|\n+--------------+----------+----------+---------+---------+\n|(padding)  N  |   a[0]   |   a[1]   |   ...   |  a[N-1] |\n+--------------+----------+----------+---------+---------+\n^              ^\n|              +---- T * a = new T[N]\n|\n+----  return value of `operator new(sizeof(T) * N + offset)`\n</code></pre>\n", "LastEditorUserId": "596781", "LastActivityDate": "2013-05-17T18:05:12.917", "Score": "5", "CreationDate": "2013-05-17T17:54:31.000", "ParentId": "16615128", "CommentCount": "12", "OwnerUserId": "596781", "LastEditDate": "2013-05-17T18:05:12.917"}, "16615128": {"ViewCount": "120", "Body": "<p>Could there be any reason why:</p>\n<pre><code>new X[n];\n</code></pre>\n<p>would consume more memory as compared to:</p>\n<pre><code>X* x = reinterpret_cast&lt;X*&gt;(malloc(n * sizeof(X))\nfor(X* p = x; p != x + n; ++p)\n    new (p) X();\n</code></pre>\n<p>for multiple copies of multiple n's? </p>\n<p>I am seeing evidence of this.</p>\n", "Title": "Malloc seemingly using less memory than new[]", "CreationDate": "2013-05-17T17:53:33.367", "LastActivityDate": "2013-05-17T18:05:12.917", "CommentCount": "3", "PostTypeId": "1", "Id": "16615128", "Score": "0", "OwnerUserId": "163173", "Tags": "<c++><memory><memory-management><malloc>", "AnswerCount": "1"}});