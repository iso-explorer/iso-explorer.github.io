post_cb({"7340909": {"CommentCount": "2", "AcceptedAnswerId": "7342744", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2011-09-07T21:48:27.830", "LastActivityDate": "2011-09-08T17:13:38.413", "LastEditDate": "2011-09-07T22:26:51.820", "ViewCount": "1107", "FavoriteCount": "2", "Title": "Variadic templates and dynamic cast", "Id": "7340909", "Score": "7", "Body": "<p>I have a piece of C++ code as follows:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>template &lt;typename ...A&gt; \nstruct CastAll{\n  template &lt;typename ...B&gt;\n  void cast_all(void(*fun)(B...), A...as){\n    //...\n  }\n};\n</code></pre>\n<p>What I'd like to do is to implement cast_all in such a way that it dynamic-casts each one of its arguments to its respective type in B and then calls the given function fun with the \"casted\" arguments.</p>\n<p>For instance, in: </p>\n<pre class=\"lang-cpp prettyprint-override\"><code>struct A{};\n\nstruct B : public A{};\n\nvoid foo(B *b1, B *b2){\n  //... does something with b1 and b2\n}\n\nint main(){\n\n  A *a1 = new B();\n  A *a2 = new B();\n\n  CastAll&lt;B*, B*&gt; cast; //used to cast each A* to B*\n  cast.cast_all&lt;B*, B*&gt;(foo, a1, a2);\n}\n</code></pre>\n<p>cast_all should expand to something like: foo(dynamic_cast(a1), dynamic_cast(a2));</p>\n<p>I've looked at many articles on variadic templates. However, after a couple hours, I'm still unable to figure it out.</p>\n<p>Any ideas?</p>\n", "Tags": "<c++><templates><c++11><dynamic-cast>", "OwnerUserId": "933677", "AnswerCount": "2"}, "7342744": {"ParentId": "7340909", "CommentCount": "1", "CreationDate": "2011-09-08T03:14:22.917", "OwnerUserId": "726300", "PostTypeId": "2", "Id": "7342744", "Score": "10", "Body": "<p>Simply</p>\n<pre><code>template &lt;typename ...A&gt; \nstruct CastAll{\n    template &lt;typename ...B&gt;\n    void cast_all(void(*fun)(B...), A...as){\n        fun(dynamic_cast&lt;B&gt;(as)...);\n    }\n};\n</code></pre>\n<p>should work, and it does with my copy of GCC. Some changes in your example code are needed though: <code>A</code> should be polymorphic (which will make <code>B</code> polymorphic in turn) so that <code>dynamic_cast</code> be possible (I added a virtual, default destructor as is customary in my example code); and you probably intended to use <code>CastAll</code> as:</p>\n<pre><code>CastAll&lt;A*, A*&gt; cast;\ncast.cast_all(foo, &amp;a1, &amp;a2);\n</code></pre>\n<p>That is to say, the argument you pass to <code>cast_all</code> are pointers to <code>A</code> that are then downcast to <code>B</code> inside the body. In addition, some of the template parameters are deduced<sup>1</sup>.</p>\n<p>This works because you're allowed to use several parameter packs (here, <code>A</code> and <code>B</code>) in one pack expansion (here, the <code>dynamic_cast</code>), provided they have the same size; otherwise, it's a silent error due to SFINAE. From n3290, 14.5.3/5 Variadic templates [temp.variadic]:</p>\n<blockquote id=\"so_7340909_7342744_0\">\n<ol>\n<li>[...] The pattern of a pack expansion shall name one or more parameter packs\n  that are not expanded by a nested pack expansion; such parameter packs\n  are called unexpanded parameter packs in the pattern. All of the\n  parameter packs expanded by a pack expansion shall have the same\n  number of arguments specified. [...]</li>\n</ol>\n</blockquote>\n<p><sup>1</sup>: I cannot find a definitive reference on whether deduction is allowed here or not; GCC is even able to deduce both packs if I turn <code>CastAll</code> into a polymorphic functor. I'm somewhat dubious if this is mandated behaviour at all but at least you seem to know how to specify non-deduced argument anyway.</p>\n", "LastActivityDate": "2011-09-08T03:14:22.917"}, "7341205": {"ParentId": "7340909", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2011-09-07T22:23:17.077", "Score": "0", "LastEditorUserId": "845092", "LastEditDate": "2011-09-08T17:13:38.413", "Id": "7341205", "OwnerUserId": "845092", "Body": "<p>[EDIT] Rewritten from scratch.  Something like this should be possible, but I don't have acecss to a compiler that allows variadic template functions to <em>not</em> be a the end, since that is no longer required.  This does fail if you don't pass at least one parameter, but I didn't see that as a problem.</p>\n<pre><code>template&lt;typename...BL&gt;\nstruct Recast {\n    template &lt;typename B, typename ...BR&gt;\n    struct Inner {\n        template &lt;typename A, typename ...AR&gt;\n        static void cast_all(void(*fun)(BL...,B,BR...), BL... al, A a, AR... ar) {\n            Recast&lt;BL..., B&gt;::template Inner&lt;BR...&gt;::cast_all&lt;AR...&gt;(fun, al..., dynamic_cast&lt;B&gt;(a), ar..);\n        }\n    };\n    template &lt;typename B&gt;\n    struct Inner&lt;B&gt; {\n        template &lt;typename A&gt;\n        static void cast_all(void(*fun)(BL...,B), BL... al, A a) {\n            fun(al..., dynamic_cast&lt;B&gt;(a));\n        }\n    };\n};\n\ntemplate &lt;typename ...BR&gt;  //note I switched these\nstruct CastAll{\n    template &lt;typename ...AR&gt;  //note I switched these\n    static void cast_all(void(*fun)(BR...), AR...ar){\n      Recast&lt;&gt;::template Inner&lt;BR...&gt;::cast_all(fun, ar...);\n    }\n};\n\nstruct A{};\n\nstruct B : public A{};\n\nvoid foo(B *b1, B *b2){\n  //... does something with b1 and b2\n}\n\nint main(){\n\n  A *a1 = new B();\n  A *a2 = new B();\n\n  CastAll&lt;B*, B*&gt;::cast_all(foo, a1, a2);\n}\n</code></pre>\n<p>I acknowledge that there are still errors I can't figure out as reported by ideone.com</p>\n<blockquote>\n<p id=\"so_7340909_7341205_0\">prog.cpp: In static member function 'static void Recast::Inner::cast_all(void (*)(BL ..., B, BR ...), BL ..., A, AR ...)':<br>\n  prog.cpp:7:39: error: expected primary-expression before '...' token<br>\n  prog.cpp:7:39: error: expected ';' before '...' token</br></br></p>\n</blockquote>\n", "LastActivityDate": "2011-09-08T17:13:38.413"}, "bq_ids": {"n4140": {"so_7340909_7342744_0": {"section_id": 123, "quality": 0.9375, "length": 30}}, "n3337": {"so_7340909_7342744_0": {"section_id": 117, "quality": 0.9375, "length": 30}}, "n4659": {"so_7340909_7342744_0": {"section_id": 127, "quality": 0.90625, "length": 29}}}});