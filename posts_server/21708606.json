post_cb({"bq_ids": {"n4140": {"so_21708606_21708950_1": {"length": 21, "quality": 0.875, "section_id": 3325}, "so_21708606_21710850_1": {"length": 17, "quality": 0.68, "section_id": 3294}, "so_21708606_21708606_0": {"length": 5, "quality": 0.625, "section_id": 460}, "so_21708606_21710850_5": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_21708606_21710850_2": {"length": 23, "quality": 0.92, "section_id": 3296}, "so_21708606_21710850_3": {"length": 134, "quality": 0.8993288590604027, "section_id": 3296}, "so_21708606_21708950_0": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_21708606_21710850_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 3296}}, "n3337": {"so_21708606_21708950_1": {"length": 21, "quality": 0.875, "section_id": 3195}, "so_21708606_21710850_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 3166}, "so_21708606_21710850_5": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_21708606_21710850_2": {"length": 23, "quality": 0.92, "section_id": 3166}, "so_21708606_21710850_3": {"length": 134, "quality": 0.8993288590604027, "section_id": 3166}, "so_21708606_21708950_0": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_21708606_21710850_1": {"length": 17, "quality": 0.68, "section_id": 3164}}, "n4659": {"so_21708606_21708950_1": {"length": 21, "quality": 0.875, "section_id": 4091}, "so_21708606_21710850_4": {"length": 6, "quality": 0.8571428571428571, "section_id": 4058}, "so_21708606_21708606_0": {"length": 5, "quality": 0.625, "section_id": 483}, "so_21708606_21710850_5": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_21708606_21710850_2": {"length": 23, "quality": 0.92, "section_id": 4058}, "so_21708606_21710850_3": {"length": 113, "quality": 0.7583892617449665, "section_id": 4058}, "so_21708606_21708950_0": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_21708606_21710850_1": {"length": 17, "quality": 0.68, "section_id": 4056}}}, "21708606": {"ViewCount": "4096", "Body": "<p>I'm a little bit confused about the following code:</p>\n<pre><code>struct A {\n  std::atomic&lt;int&gt; a = 0;\n};\n</code></pre>\n<p>Which gives an error:</p>\n<blockquote>\n<p id=\"so_21708606_21708606_0\">copying member subobject of type 'std::atomic' invokes deleted constructor</p>\n</blockquote>\n<p>But almost the same code does work:</p>\n<pre><code>struct A {\n  std::atomic&lt;int&gt; a = {0};\n};\n</code></pre>\n<p>Okey, if the first variant requires the copy constructor, then it have to use <code>operator=()</code>. But wait! This operator perfectly works without the copy constructor:</p>\n<pre><code>A a;\na.a = 1;\n</code></pre>\n<p>Can anyone explain how both of the in-place initializations are expanded in terms of simple operations? Why the first one requires copy constructor?</p>\n", "AcceptedAnswerId": "21710850", "Title": "Why does an in-place member initialization use a copy constructor in C++11?", "CreationDate": "2014-02-11T17:18:07.610", "Id": "21708606", "CommentCount": "6", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2014-12-21T11:33:00.823", "LastEditorUserId": "377393", "LastActivityDate": "2014-12-21T11:33:00.823", "Score": "15", "OwnerUserId": "377393", "Tags": "<c++><c++11><initialization><atomic><copy-constructor>", "AnswerCount": "2"}, "21708950": {"Id": "21708950", "PostTypeId": "2", "Body": "<p>Let consider the first case</p>\n<pre><code>struct A {\n  std::atomic&lt;int&gt; a = 0;\n};\n</code></pre>\n<p>For this initialization to be successful, there needs to be an accessible copy constructor. But the copy constructor is defined as deleted. </p>\n<pre><code>atomic(const atomic&amp;) = delete;\n</code></pre>\n<p>So the compiler issues an error.</p>\n<p>In the second case</p>\n<pre><code>struct A {\n  std::atomic&lt;int&gt; a = {0};\n};\n</code></pre>\n<p>where an initializer list is used the copy constructor is not required. The compiler searches for a constructor that accepts one <code>int</code> argument and such constructor indeed exists, so it is called.</p>\n<pre><code>constexpr atomic(T) noexcept;\n</code></pre>\n<p>or if to substitute template parameter for type int</p>\n<pre><code>constexpr atomic(int) noexcept;\n</code></pre>\n<p>According to the C++ Standard if a class has no constructor with the first parameter of type std::initializer_list (when an initializer list is specified) then</p>\n<blockquote>\n<p id=\"so_21708606_21708950_0\">3 List-initialization of an object or reference of type T is defined\n  as follows: ...</p>\n<p id=\"so_21708606_21708950_1\">Otherwise, if T is a class type, constructors are considered. The\n  applicable constructors are enumerated and the best one is chosen\n  through overload resolution (13.3, 13.3.1.7). If a narrowing\n  conversion (see below) is required to convert any of the arguments,\n  the program is ill-formed.</p>\n</blockquote>\n<p>In the last case </p>\n<pre><code>A a;\na.a = 1;\n</code></pre>\n<p>this uses an assignment operator </p>\n<pre><code>T operator=(T) noexcept;\n</code></pre>\n<p>or if to substitute template parameter for type int</p>\n<pre><code>int operator=(int) noexcept;\n</code></pre>\n<p>So there is no problem.</p>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2014-02-11T18:00:57.787", "Score": "5", "CreationDate": "2014-02-11T17:33:36.337", "ParentId": "21708606", "CommentCount": "7", "OwnerUserId": "2877241", "LastEditDate": "2014-02-11T18:00:57.787"}, "21710850": {"Id": "21710850", "PostTypeId": "2", "Body": "<p>All references are to N3797, the C++1y current working draft. \u00a78.5 Initializers [dcl.init]/15 states:</p>\n<blockquote>\n<p id=\"so_21708606_21710850_0\">The initialization that occurs in the form</p>\n<pre><code>T x = a;\n</code></pre>\n<p id=\"so_21708606_21710850_1\">as well as in argument passing, function return, throwing an exception (15.1), handling an exception\n  (15.3), and aggregate member initialization (8.5.1) is called <em>copy-initialization</em>. [ Note: Copy-initialization may invoke a move (12.8). \u2014end note ]</p>\n</blockquote>\n<p>So the declaration:</p>\n<pre><code>std::atomic&lt;int&gt; a = 0;\n</code></pre>\n<p>is performing copy-initialization. According to 8.5/17:</p>\n<blockquote>\n<p id=\"so_21708606_21710850_2\">The semantics of initializers are as follows. The <em>destination type</em> is the type of the object or reference being initialized and the <em>source type</em> is the type of the initializer expression. If the initializer is not a single (possibly parenthesized) expression, the source type is not defined.</p>\n</blockquote>\n<p>The <em>destination type</em> here is <code>std::atomic&lt;int&gt;</code> and the <em>source type</em> is <code>int</code> (i.e., <code>decltype(0)</code>). To determine the semantics of the initialization, we have to determine which of paragraph 17's bullets applies:</p>\n<blockquote id=\"so_21708606_21710850_3\">\n<ul>\n<li>If the initializer is a (non-parenthesized) <em>braced-init-list</em>, the object or reference is list-initialized (8.5.4).</li>\n<li>If the destination type is a reference type, see 8.5.3.</li>\n<li>If the destination type is an array of characters, an array of <code>char16_t</code>, an array of <code>char32_t</code>, or an array of <code>wchar_t</code>, and the initializer is a string literal, see 8.5.2.</li>\n<li>If the initializer is <code>()</code>, the object is value-initialized.</li>\n<li>Otherwise, if the destination type is an array, the program is ill-formed.</li>\n<li>If the destination type is a (possibly cv-qualified) class type:\n  <ul>\n<li>If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified version of the source type is the same class as, or a derived class of, the class of the destination, ... [does not apply, source type is <code>int</code>]</li>\n<li>Otherwise (i.e., for the remaining copy-initialization cases), user-defined conversion sequences that can convert from the source type to the destination type or (when a conversion function\n  is used) to a derived class thereof are enumerated as described in 13.3.1.4, and the best one is chosen through overload resolution (13.3). If the conversion cannot be done or is ambiguous, the\n  initialization is ill-formed. The function selected is called with the initializer expression as its argument; if the function is a constructor, the call initializes a temporary of the cv-unqualified\n  version of the destination type. The temporary is a prvalue. The result of the call (which is the\n  temporary for the constructor case) is then used to direct-initialize, according to the rules above,\n  the object that is the destination of the copy-initialization. In certain cases, an implementation\n  is permitted to eliminate the copying inherent in this direct-initialization by constructing the\n  intermediate result directly into the object being initialized; see 12.2, 12.8.</li>\n</ul></li>\n<li>...</li>\n</ul>\n</blockquote>\n<p>There we are. The initializer expression - <code>0</code> - is converted into a <code>std::atomic&lt;int&gt;</code> via the creation of a temporary object initialized with the <code>std::atomic&lt;int&gt;(int)</code> constructor. That temporary object is used to direct-initialize the original <code>std::atomic&lt;int&gt;</code> object. The other of the \"(possibly cv-qualified) class type\" bullets that we ignored before now applies:</p>\n<ul>\n<li>If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified version of the source type is the same class as, or a derived class of, the class of the destination, constructors are considered. The applicable constructors are enumerated (13.3.1.3), and the best one is chosen through overload resolution (13.3). The constructor so selected is called to initialize the object, with the initializer expression or <em>expression-list</em> as its argument(s). If no constructor applies, or the overload resolution is ambiguous, the initialization is ill-formed.</li>\n</ul>\n<p>Recall that the new initializer is a prvalue <code>std::atomic&lt;int&gt;</code>. Overload resolution determines that there is no appropriate <code>std::atomic&lt;int&gt;</code> constructor that accepts a single argument <code>std::atomic&lt;int&gt;&amp;&amp;</code> (<code>std::atomic&lt;int&gt;</code> is not movable or copyable) and diagnoses the program as ill-formed.</p>\n<p>For the second part of the question,</p>\n<pre><code>std::atomic&lt;int&gt; a = {0};\n</code></pre>\n<p>is again copy initialization per 8.5/15. This time, however, the very first bullet of 8.5/17 applies:</p>\n<blockquote id=\"so_21708606_21710850_4\">\n<ul>\n<li>If the initializer is a (non-parenthesized) <em>braced-init-list</em>, the object or reference is list-initialized (8.5.4).</li>\n</ul>\n</blockquote>\n<p>For <em>list-initialization</em>, we must look to 8.5.4/3:</p>\n<blockquote>\n<p id=\"so_21708606_21710850_5\">List-initialization of an object or reference of type <code>T</code> is defined as follows:</p>\n<ul>\n<li>If <code>T</code> is an aggregate, aggregate initialization is performed (8.5.1).</li>\n<li>Otherwise, if the initializer list has no elements and <code>T</code> is a class type with a default constructor, the object is value-initialized.</li>\n<li>Otherwise, if <code>T</code> is a specialization of <code>std::initializer_list&lt;E&gt;</code>, a prvalue <code>initializer_list</code> object is constructed as described below and used to initialize the object according to the rules for initialization of an object from a class of the same type (8.5).</li>\n<li>Otherwise, if <code>T</code> is a class type, constructors are considered. The applicable constructors are enumerated and the best one is chosen through overload resolution (13.3, 13.3.1.7). If a narrowing conversion (see below) is required to convert any of the arguments, the program is ill-formed.</li>\n<li>...</li>\n</ul>\n</blockquote>\n<p><code>std::atomic&lt;int&gt;</code> is a class type, not an aggregate or <code>initializer_list</code> specialization, so constructors are considered. The <code>std::atomic&lt;int&gt;::atomic(int)</code> constructor will be selected as a perfect match and is used to initialize the object.</p>\n", "LastActivityDate": "2014-02-11T19:08:30.040", "CommentCount": "6", "CreationDate": "2014-02-11T19:08:30.040", "ParentId": "21708606", "Score": "15", "OwnerUserId": "923854"}});