post_cb({"13723325": {"ParentId": "13723217", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>In this answer I'll assume that you used <code>public</code> inheritance in your code (which was missing from the question).</p>\n<hr>\n<blockquote>\n<p id=\"so_13723217_13723325_0\"><code>[C++11: 11.2/1]:</code> <strong>If a class is declared to be a base class (Clause 10) for another class using the <code>public</code> access specifier</strong>, the <code>public</code> members of the base class are accessible as <code>public</code> members of the derived class and <strong><code>protected</code> members of the base class are accessible as <code>protected</code> members of the derived class</strong>. If a class is declared to be a base class for another class using the <code>protected</code> access specifier, the <code>public</code> and <code>protected</code> members of the base class are accessible as <code>protected</code> members of the derived class. If a class is declared to be a base class for another class using the <code>private</code> access specifier, the public and <code>protected</code> members of the base class are accessible as <code>private</code> members of the derived class.</p>\n</blockquote>\n<p>This covers the case where you're accessing a member of the <em>same</em> object.</p>\n<p>However, it's a little curiosity of <code>protected</code> member access that in order to access a <code>protected</code> member of <em>another</em> object, it has to be located within the definition of the <em>same</em> type or a <em>more derived</em> type; in your case, it is in a less-derived type (i.e. a base):</p>\n<blockquote>\n<p id=\"so_13723217_13723325_1\"><code>[C++11: 11.4/1]:</code> An additional access check beyond those described earlier in Clause 11 is applied when a non-static data member or non-static member function is a protected member of its naming class (11.2) As described earlier, access to a protected member is granted because the reference occurs in a friend or member of some class <code>C</code>. If the access is to form a pointer to member (5.3.1), the <em>nested-name-specifier</em> shall denote <code>C</code> or a class derived from <code>C</code>. All other accesses involve a (possibly implicit) object expression (5.2.5). <strong>In this case, the class of the object expression shall be <code>C</code> or a class derived from <code>C</code>.</strong></p>\n</blockquote>\n<p>That is, you'd have to run this code from within a <code>Class1</code> member function.</p>\n<p>Bjarne mentions this in his book <em>The C++ Programming Language (Sp. Ed.)</em> on page 404:</p>\n<blockquote>\n<p id=\"so_13723217_13723325_2\">A derived class can access a base class' protected members only for objects of its own type [...] This prevents subtle errors that would otherwise occur when one derived class corrupts data belonging to other derived classes.</p>\n</blockquote>\n</hr>", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2012-12-05T12:38:09.703", "Id": "13723325", "Score": "11", "CreationDate": "2012-12-05T12:32:14.513", "LastActivityDate": "2012-12-05T12:38:09.703"}, "13723404": {"ParentId": "13723217", "CommentCount": "0", "Body": "<p>Protected members of a base class can be accessed by the derived class only through its self (this) or through another object of the same class, but not generically through the base class. That is the access, and the purpose is that the use of the member is considered restricted to the implementation detail of the class, and as your class is dealing with the base class, it would not know the meaning of the member in this particular case.</p>\n<p>There is a workaround you can use to get access which is to provide a protected getter and setter in the base class, often static, that will fetch it or set it for you.</p>\n<pre><code>class Class1\n{\n     protected:\n       long m_memberVar; // could even be private\n\n       static long getMemberVar( Class1 const&amp; inst )\n       {\n          return inst.m_memberVar;\n       }\n\n       static long setMemberVar( Class1 &amp; inst, long val )\n       {\n          inst.m_memberVar = val;\n       }\n\n};\n</code></pre>\n<p>And now derived classes (but not general classes) can use the getter and setter methods.</p>\n", "OwnerUserId": "442284", "PostTypeId": "2", "Id": "13723404", "Score": "1", "CreationDate": "2012-12-05T12:36:37.253", "LastActivityDate": "2012-12-05T12:36:37.253"}, "13723217": {"CommentCount": "1", "AcceptedAnswerId": "13723325", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-12-05T12:24:46.017", "LastActivityDate": "2015-02-18T20:21:50.027", "LastEditDate": "2017-05-23T10:32:40.237", "ViewCount": "9717", "FavoriteCount": "2", "Title": "Why can't I access a protected member variable of a base class passed into a function as an argument?", "Id": "13723217", "Score": "5", "Body": "<p><a href=\"https://stackoverflow.com/a/967363/15369\">This</a> answer seems to suggest it should work so why does my example kick up a compiler error:</p>\n<pre><code>class Class1\n{\nprotected:\n    long m_memberVar;\n};\n\nclass SubClass1: public Class1\n{\npublic:\n    void PrintMember(Class1 memberToPrintFrom)\n    {\n        Console::Write(\"{0}\", memberToPrintFrom.m_memberVar); // &lt;-- Compiler error: error C2248: 'BaseClassMemberAccess::Class1::m_memberVar' : cannot access protected member declared in class 'BaseClassMemberAccess::Class1'\n    }\n};\n</code></pre>\n<p><em>[Edit] - changed subclass to a public inheritance on Need4Sleep's suggestion but it makes no difference.</em></p>\n", "Tags": "<c++><inheritance>", "OwnerUserId": "15369", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_13723217_13723325_0": {"section_id": 6678, "quality": 0.971830985915493, "length": 69}, "so_13723217_13723325_1": {"section_id": 6695, "quality": 0.9180327868852459, "length": 56}}, "n3337": {"so_13723217_13723325_0": {"section_id": 6433, "quality": 0.971830985915493, "length": 69}, "so_13723217_13723325_1": {"section_id": 6450, "quality": 0.9180327868852459, "length": 56}}, "n4659": {"so_13723217_13723325_0": {"section_id": 8153, "quality": 0.971830985915493, "length": 69}, "so_13723217_13723325_1": {"section_id": 8170, "quality": 0.9180327868852459, "length": 56}}}, "28590446": {"ParentId": "13723217", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You can also take advantage of the fact that a derived object can be converted to the base object type and that an object can access protected and private members of any object of it's own type. If the base object has an assignment operator that can guarantee all desired members are correctly copied, you can do something like this:</p>\n<pre><code>class Class1\n{\nprotected:\n    long m_memberVar;\n};\n\nclass SubClass1 : public Class1\n{\npublic:\n    void PrintMember(Class1 memberToPrintFrom)\n    {\n        SubClass1 tmpSC;\n        auto tmpC1 = dynamic_cast&lt;Class1*&gt;(&amp;tmpSC);\n        *tmpC1 = memberToPrintFrom;\n\n        cout &lt;&lt; tmpSC.m_memberVar &lt;&lt; endl;\n    }\n};\n</code></pre>\n<p>This isn't efficient, but will allow you to get at the base class member without having to add functions to the base class. This is using object slicing to replace the base portion of the temporary derived object with the passed base object's values.</p>\n", "OwnerUserId": "23504", "LastEditorUserId": "23504", "LastEditDate": "2015-02-18T20:21:50.027", "Id": "28590446", "Score": "1", "CreationDate": "2015-02-18T17:52:59.503", "LastActivityDate": "2015-02-18T20:21:50.027"}});