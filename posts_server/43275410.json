post_cb({"bq_ids": {"n4140": {"so_43275410_43275782_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 5790}, "so_43275410_43275782_1": {"length": 19, "quality": 0.95, "section_id": 5790}, "so_43275410_43275782_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 5790}}, "n3337": {"so_43275410_43275782_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 5563}, "so_43275410_43275782_1": {"length": 19, "quality": 0.95, "section_id": 5563}, "so_43275410_43275782_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 5563}}, "n4659": {"so_43275410_43275782_0": {"length": 8, "quality": 0.7272727272727273, "section_id": 7247}, "so_43275410_43275782_1": {"length": 19, "quality": 0.95, "section_id": 7247}, "so_43275410_43275782_2": {"length": 12, "quality": 0.9230769230769231, "section_id": 7247}}}, "43276009": {"Id": "43276009", "PostTypeId": "2", "Body": "<p>As explained by other answers the layout can change in case a virtual destructor is added. </p>\n<p>If your destructor is not virtual you can go ahead and add. But say you need a virtual destructor, you can wrap the struct in another struct and place the destructor there. </p>\n<p>Make sure the fields that you want to modify are accessible to the wrapper class. A friend relation should be good enough. </p>\n<p>Although all your inheritance will be through the wrapper. The inner struct is just to maintain the layout so you can send it over the network.</p>\n", "LastEditorUserId": "2858773", "LastActivityDate": "2017-04-07T10:49:17.380", "Score": "0", "CreationDate": "2017-04-07T10:38:30.123", "ParentId": "43275410", "CommentCount": "6", "OwnerUserId": "2858773", "LastEditDate": "2017-04-07T10:49:17.380"}, "43275782": {"Id": "43275782", "PostTypeId": "2", "Body": "<p>Actually, the only thing that influences the layout is the data contained in an object -- with one important exception, coming to that later. If you add any functions (and constructors in reality are nothing more than some kind of static function only with special syntax), you do not influence the layout of the class.</p>\n<p>If you have a virtual class (a function with at least one virtual function, including a virtual destructor), your class will contain an entry to a vtable (this is not enforced by the standard, but that's the standard way how polymorphism is implemented), but this is just a pointer to some specific memory location elsewhere. The vtable itself will be modified, if you add more virtual functions, but without any influence on the layout of your data containers (which your class instances actually are).</p>\n<p>Now the exception mentioned above: If you add a <em>virtual</em> function to a class (or make an existing one virtual, including the destructor) while the class did not have any virtual functions <em>before</em> (i. e. no own virtual functions <em>and</em> no inherited ones!), <strong>then</strong> a vtable will be newly added and <strong>then</strong> the data layout <strong>does</strong> change! (Analogously, the vtable pointer is removed if you make all functions non-virtual - including all inherited ones).</p>\n<p>Guaranteed by the standard? </p>\n<p><em>Edit:</em></p>\n<p>From C++ standard, section 4.5 The C++ object model (\u00a7 1):</p>\n<blockquote>\n<p id=\"so_43275410_43275782_0\">[...] Note: A function is not an object, regardless of whether or not it occupies storage in the way that objects do. \u2014 end note [...]</p>\n</blockquote>\n<p>Next is deduction (of mine): A function (note: not differentiated if free or member one) is not an object, thus cannot be a subobject, thus is not part of the data of an object.</p>\n<p>Further (same \u00a7):</p>\n<blockquote>\n<p id=\"so_43275410_43275782_1\">An object has a type (6.9). Some objects are polymorphic (13.3); the implementation generates information associated with each such object that makes it possible to determine that object\u2019s type during program execution.</p>\n</blockquote>\n<p>(That is the vtables! - note that it is not explicit about how they are implemented, does not even enforce them at all, if a compiler vendor finds some alternative, it is free to use it...).</p>\n<blockquote>\n<p id=\"so_43275410_43275782_2\">For other objects, the interpretation of the values found therein is determined by the type of the expressions (Clause 8) used to access them.</p>\n</blockquote>\n<p>Well, couldn't find any hints (so far), if or how functions influence the layout of a class, not flying over the standard as a whole, not (with special attendance) in chapters 8 (as referenced above) or 12 \"Classes\" (especially 12.2 \"Class members\").</p>\n<p>Seems as this is not explicitly specified (won't hold my hand into fire for not having overseen, though...). Maybe it is valid to deduce this already from functions not being objects solely...</p>\n<p>Standard layout classes, as referenced by Jan Husec, provide further guarantees on layout, such as no reordering of members (which is allowed for members of different accessibility), alignment conditions, ...</p>\n<p>From those conditions for being a SLC, I deduce that for these, at least, the guarantee applies, as all that is referenced for being layout compatible is the data members, no mention of (non-static member) functions (other than no virtual ones being allowed...).</p>\n", "LastEditorUserId": "1312382", "LastActivityDate": "2017-04-07T13:52:37.547", "Score": "1", "CreationDate": "2017-04-07T10:27:24.620", "ParentId": "43275410", "CommentCount": "5", "OwnerUserId": "1312382", "LastEditDate": "2017-04-07T13:52:37.547"}, "43275410": {"ViewCount": "74", "Body": "<p>Lets say I have a class</p>\n<pre><code>struct Foo {\n    uint32_t x;\n    uint32_t y;\n};\n</code></pre>\n<p>does the C++ standard make any mention whether <code>sizeof(Foo)</code> should be the same as <code>sizeof(Bar)</code> if <code>Bar</code> just adds a constructor ?</p>\n<pre><code>struct Bar {\n    uint32_t x;\n    uint32_t y;\n    Bar(uint32_t a = 1,uint32_t b = 2) : x(a),y(b) {}\n};\n</code></pre>\n<p>The reason why I am asking is that <code>Foo</code> is send across network as a <code>void*</code> and I cannot change its size, but if possible I would like to add a constructor.</p>\n<p>I found some related: <a href=\"https://stackoverflow.com/questions/8058213/do-class-methods-increase-the-size-of-the-class-instances\">here</a> and <a href=\"https://stackoverflow.com/questions/6552319/c-sizeof-of-a-class-with-functions\">here</a>, but there the answers focus mainly on virtuals changing the size and I was looking for something more definite than <a href=\"https://stackoverflow.com/a/8058257/4117728\">\"[...] all implementations I know of [...]\"</a>.</p>\n<p>PS: To avoid misunderstanding... I am not asking how to constsruct a <code>Foo</code> and then send it as a <code>void*</code> nor am I asking for a workaround to make sure the size does not change, but I am really just curious, whether the standard says anything about <code>sizeof</code> in that specific case.</p>\n", "AcceptedAnswerId": "43275542", "Title": "Does the standard make any guarantee that adding a constructor does not change the size?", "CreationDate": "2017-04-07T10:08:52.903", "Id": "43275410", "CommentCount": "8", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:32:19.833", "LastEditorUserId": "-1", "LastActivityDate": "2017-04-07T13:52:37.547", "Score": "3", "OwnerUserId": "4117728", "Tags": "<c++><constructor><sizeof>", "AnswerCount": "3"}, "43275542": {"Id": "43275542", "PostTypeId": "2", "Body": "<p>C++ 98 only guarantees layout for \u201cplain old data\u201d objects and those don't permit constructors.</p>\n<p>C++ 11 introduces \u201c<a href=\"http://en.cppreference.com/w/cpp/language/data_members#Standard_layout\" rel=\"nofollow noreferrer\">standard layout types</a>\u201d, which still guarantee layout, but do permit constructors and methods to be added (and permits non-virtual bases to be added with some exceptions for empty classes and duplicates).</p>\n", "LastEditorUserId": "201725", "LastActivityDate": "2017-04-07T10:28:13.823", "Score": "4", "CreationDate": "2017-04-07T10:16:05.707", "ParentId": "43275410", "CommentCount": "9", "OwnerUserId": "201725", "LastEditDate": "2017-04-07T10:28:13.823"}});