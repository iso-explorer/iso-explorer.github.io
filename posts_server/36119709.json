post_cb({"36119915": {"Id": "36119915", "PostTypeId": "2", "Body": "<p>That is undefined behavior. From <a href=\"http://eel.is/c++draft/expr.static.cast#2\">[expr.static.cast]</a>:</p>\n<blockquote>\n<p id=\"so_36119709_36119915_0\">An lvalue of type \u201ccv1 B\u201d, where B is a class type, can be cast to type \u201creference to cv2 D\u201d, where D is a class\n  derived (Clause 10) from B, if a valid standard conversion from \u201cpointer to D\u201d to \u201cpointer to B\u201d exists (4.10),\n  cv2 is the same cv-qualification as, or greater cv-qualification than, cv1, and B is neither a virtual base class\n  of D nor a base class of a virtual base class of D. The result has type \u201ccv2 D\u201d. An xvalue of type \u201ccv1 B\u201d\n  may be cast to type \u201crvalue reference to cv2 D\u201d with the same constraints as for an lvalue of type \u201ccv1 B\u201d.\n  <strong>If the object of type \u201ccv1 B\u201d is actually a subobject of an object of type D, the result refers to the enclosing\n  object of type D. Otherwise, the behavior is undefined.</strong></p>\n</blockquote>\n<p><code>a</code> isn't actually a suboject of an object of type <code>B</code> - it's really just of type <code>A</code>, so the behavior is undefined.</p>\n<p>What's to stop you from simply adding a non-member function:</p>\n<pre><code>void f(A&amp; ); \n</code></pre>\n<p>If the answer is that you need to access <code>private</code> or <code>protected</code> members of <code>A</code>, then there was intent to make those members unaccessible to you! </p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2016-03-20T21:43:30.077", "Score": "5", "CreationDate": "2016-03-20T21:38:03.623", "ParentId": "36119709", "CommentCount": "9", "LastEditDate": "2016-03-20T21:43:30.077", "OwnerUserId": "2069064"}, "bq_ids": {"n4140": {"so_36119709_36119915_0": {"length": 69, "quality": 0.971830985915493, "section_id": 6028}}, "n3337": {"so_36119709_36119915_0": {"length": 68, "quality": 0.9577464788732394, "section_id": 5796}}, "n4659": {"so_36119709_36119915_0": {"length": 58, "quality": 0.8169014084507042, "section_id": 7527}}}, "36119709": {"ViewCount": "87", "Body": "<p>I'd like to add non-virtual methods to an existing class <code>A</code> that I can't change. Therefore I create a class <code>B</code> inherited from <code>A</code> and add the methods I want. Now, if I have an object of type <code>A</code>, can I just regard it as an object of type <code>B</code>? Say, is the following code legal?:</p>\n<pre><code>class A { &lt;...&gt; };\n\nclass B: public A {\n    void f();\n  };\n\nA a();\nvoid g( const B&amp; );\nvoid h() { g( static_cast&lt;B&amp;&amp;&gt;(a()) ); }\n</code></pre>\n<p>It does compile and work, however I was wondering if it's guaranteed by the standard to work as expected. I don't see why not, yet it doesn't feel very clean..</p>\n", "Title": "In C++, is it allowed to cast to a derived class that only adds non-virtual methods?", "CreationDate": "2016-03-20T21:15:11.447", "LastActivityDate": "2016-03-20T21:43:30.077", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "Id": "36119709", "Score": "2", "OwnerUserId": "4583357", "Tags": "<c++><oop><inheritance><casting>", "AnswerCount": "1"}});