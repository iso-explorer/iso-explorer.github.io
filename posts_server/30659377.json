post_cb({"30659639": {"ParentId": "30659377", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>[class.virtual]/p7, emphasis mine:</p>\n<blockquote>\n<p id=\"so_30659377_30659639_0\">The return type of an overriding function shall be either identical to\n  the return type of the overridden function or <em>covariant</em> with the\n  classes of the functions. If a function <code>D::f</code> overrides a function\n  <code>B::f</code>, the return types of the functions are covariant if they\n  satisfy the following criteria:</p>\n<ul>\n<li>both are pointers to <strong>classes</strong>, both are lvalue references to <strong>classes</strong>, or both are rvalue references to <strong>classes</strong> [footnote omitted]</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<hr>\n<p>From pages 294-5 of <a href=\"http://www.stroustrup.com/dne.html\" rel=\"nofollow\">D&amp;E</a>:</p>\n<blockquote>\n<p id=\"so_30659377_30659639_1\">Afer some consideration of the alternatives, we decided to allow\n  overriding of a <code>B*</code> by a <code>D*</code> and of a <code>B&amp;</code> by a <code>D&amp;</code> where <code>B</code> is an\n  accessible base of <code>D</code>. In addition, <code>const</code> can be added or\n  subtracted wherever that is safe. We decided not to relax the rules to\n  allow technically feasible conversions such as a <code>D</code> to an accessible\n  base <code>B</code>, a <code>D</code> to an <code>X</code> for which <code>D</code> has a conversion, <code>int*</code> to\n  <code>void*</code>, <code>double</code> to <code>int</code>, etc. We felt that the benefits from\n  allowing such conversions through overriding would not outweigh the\n  implementation cost and the potential for confusing users.</p>\n</blockquote>\n</hr>", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "LastEditDate": "2015-06-05T11:37:18.797", "Id": "30659639", "Score": "7", "CreationDate": "2015-06-05T06:20:45.810", "LastActivityDate": "2015-06-05T11:37:18.797"}, "30661925": {"ParentId": "30659377", "CommentCount": "0", "Body": "<p>The covariance between <code>void*</code> and <code>T*</code> is not allowed because:</p>\n<p><strong>1. lack of consistency</strong>.</p>\n<p>The current way of covariance is trivial to understand and doesn't create confusion.<br>\nJust imagine of <code>void*</code> type of covariance is allowed. For 1 stage of derivation is fine, but then it will create confusion. e.g.:</br></p>\n<pre><code>struct void_ { virtual void* foo (); };\nstruct int_ : void_ { virtual int* foo (); };\nstruct double_ : int_ { virtual double* foo (); };  // int* to double* or void* to double*\n</code></pre>\n<p>In the 3rd hierarchy of <code>struct double_</code>, the user will be confused that even though <code>double*</code> to <code>int*</code> is not possible, why the code is still compiling? Only after checking the top most class <code>void_</code>, it's known that it is because of <code>double*</code> to <code>void*</code> is \"covariant\". Same goes for compiler as well :-)</p>\n<p><strong>2. Issue with the references</strong></p>\n<p>In case of classes, returning <code>B&amp;</code>/<code>D*</code>/<code>DD*</code> is possible. But same thing is not possible with <code>void&amp;</code> and hence <code>int&amp;</code> etc.</p>\n<p><strong>3. Mixing of covariances</strong></p>\n<p>If <code>void*</code> is allowed then following is also allowed unintentionally.</p>\n<pre><code>struct void_ { virtual void* foo (); };\nstruct Base : void_ { virtual Base* foo (); };\nstruct Derived : Base { virtual int* foo (); }; // Look at `int*`\n</code></pre>\n<p>Which adds up to confusion.</p>\n", "OwnerUserId": "514235", "PostTypeId": "2", "Id": "30661925", "Score": "1", "CreationDate": "2015-06-05T08:33:42.350", "LastActivityDate": "2015-06-05T08:33:42.350"}, "30659377": {"CommentCount": "0", "ViewCount": "366", "PostTypeId": "1", "LastEditorUserId": "2756719", "CreationDate": "2015-06-05T06:03:51.793", "LastActivityDate": "2015-06-05T11:37:18.797", "Title": "Why can't I have return types covariant with void*?", "AcceptedAnswerId": "30659639", "LastEditDate": "2015-06-05T08:16:40.923", "Id": "30659377", "Score": "7", "Body": "<p>Why is the following code a covariance error? Isn't <code>T *</code> covariant with <code>void *</code>...?</p>\n<pre><code>struct Base { virtual void *foo(); };\nstruct Derived : Base { int *foo(); };\n</code></pre>\n<p>GCC says:</p>\n<pre><code>invalid covariant return type for 'virtual int* Derived::foo()'\n</code></pre>\n", "Tags": "<c++><covariance><return-type>", "OwnerUserId": "541686", "AnswerCount": "3"}, "30659648": {"ParentId": "30659377", "CommentCount": "1", "Body": "<p>Covariant return type feature is when, a derived class provides a more specific/narrower return type for a overridden function. The derived class return type is said to be covariant.</p>\n<p>int* is not of type void* whereas something like this does depict covariant return type:</p>\n<pre><code>struct Base {\n  virtual void *foo();\n  virtual Base* func();\n};\nstruct Derived : Base {\n//  int *foo();\n  Derived* func(); //COVARIANT RETURN TYPE\n};\n</code></pre>\n", "OwnerUserId": "2112844", "PostTypeId": "2", "Id": "30659648", "Score": "0", "CreationDate": "2015-06-05T06:21:04.157", "LastActivityDate": "2015-06-05T06:21:04.157"}, "bq_ids": {"n4140": {"so_30659377_30659639_0": {"section_id": 7008, "quality": 0.92, "length": 23}}, "n3337": {"so_30659377_30659639_0": {"section_id": 6754, "quality": 0.92, "length": 23}}, "n4659": {"so_30659377_30659639_0": {"section_id": 8505, "quality": 0.92, "length": 23}}}});