post_cb({"bq_ids": {"n4140": {"so_26979392_26979615_0": {"length": 19, "quality": 0.8636363636363636, "section_id": 265}}, "n3337": {"so_26979392_26979615_0": {"length": 16, "quality": 0.7272727272727273, "section_id": 256}}, "n4659": {"so_26979392_26979615_0": {"length": 19, "quality": 0.8636363636363636, "section_id": 272}}}, "26979392": {"ViewCount": "144", "Body": "<p>I am using static template members in a class; the templates are instantiated in a cpp built in a software. I have a plug-in for the software that uses the  <code>name()</code> template method in the header, but does not build the source file which contains the instantiation. The build <strong>works on Linux with g++-4.9</strong> but fails on MinGW 4.8. I want to know how to make it work with the <em>almost</em> same compiler, but on Windows instead.</p>\n<p>.hpp : </p>\n<pre><code>enum class ToplevelMenuElement\n{\n    FileMenu, \n    ...\n    AboutMenu\n};\n\nenum class FileMenuElement\n{\n    New,\n    ... ,\n    Quit\n};\n\n// Others menus macros are defined\n\nclass MenuInterface\n{\n    public:\n        template&lt;typename MenuType&gt;\n        static QString name(MenuType elt);\n\n    private:\n        static const std::map&lt;ToplevelMenuElement, QString&gt; m_map;\n        static const std::map&lt;FileMenuElement, QString&gt; m_fileMap;\n};\n</code></pre>\n<p>.cpp : </p>\n<pre><code>template&lt;&gt;\nQString MenuInterface::name(ToplevelMenuElement elt)\n{\n    return m_map.at(elt);\n}\n\ntemplate&lt;&gt;\nQString MenuInterface::name(FileMenuElement elt)\n{\n    return m_fileMap.at(elt);\n}\n\nconst std::map&lt;ToplevelMenuElement, QString&gt; MenuInterface::m_map\n{\n    {ToplevelMenuElement::FileMenu, QObject::tr(\"File\")},\n    ...\n    {ToplevelMenuElement::AboutMenu, QObject::tr(\"About\")}\n};\n\nconst std::map&lt;FileMenuElement, QString&gt; MenuInterface::m_fileMap\n{\n    {FileMenuElement::New, QObject::tr(\"New\")},\n    ..., \n    {FileMenuElement::Quit, QObject::tr(\"Quit\")}\n};\n</code></pre>\n<p>Error :</p>\n<pre><code>undefined reference to `QString MenuInterface::name&lt;ToplevelMenuElement&gt;(ToplevelMenuElement)'\n</code></pre>\n<p>Is there any flag to use to make some kind of lazy instantiation ? Or should I build the .cpp containing the template instantiation in my plug-in ?</p>\n", "Title": "Template undefined reference on windows with MinGW 4.8", "CreationDate": "2014-11-17T18:29:14.350", "LastActivityDate": "2014-11-17T18:42:56.813", "CommentCount": "7", "LastEditDate": "2014-11-17T18:37:29.793", "PostTypeId": "1", "LastEditorUserId": "1495627", "Id": "26979392", "Score": "0", "OwnerUserId": "1495627", "Tags": "<c++><templates><c++11><mingw><explicit-instantiation>", "AnswerCount": "2"}, "26979448": {"Id": "26979448", "PostTypeId": "2", "Body": "<p>This has been asked many times...declaration and definitions for templates should be same file.</p>\n", "LastActivityDate": "2014-11-17T18:32:09.387", "CommentCount": "2", "CreationDate": "2014-11-17T18:32:09.387", "ParentId": "26979392", "Score": "0", "OwnerUserId": "4047092"}, "26979615": {"Id": "26979615", "PostTypeId": "2", "Body": "<p>Because you are linking a source file that contains explicit specializations, you need to declare your explicit specializations before you define them. From \u00a714.7.3/3:</p>\n<blockquote>\n<p id=\"so_26979392_26979615_0\">A declaration of a function template, class template, or variable template being explicitly specialized shall precede the declaration of the explicit specialization. [ Note: A declaration, but not a definition of the template is required. \u2014 end note ]</p>\n</blockquote>\n<p>So you need to put these after your class in your header file:</p>\n<pre><code>template&lt;&gt;\nQString MenuInterface::name(ToplevelMenuElement elt);\n\ntemplate&lt;&gt;\nQString MenuInterface::name(FileMenuElement elt);\n</code></pre>\n", "LastActivityDate": "2014-11-17T18:42:56.813", "CommentCount": "5", "CreationDate": "2014-11-17T18:42:56.813", "ParentId": "26979392", "Score": "2", "OwnerUserId": "701092"}});