post_cb({"26290247": {"ParentId": "26289918", "CommentCount": "7", "Body": "<p>The standard requires that a pointer to one-past the end of an array be a valid value for the pointer to have. (It doesn't mean that it is OK to dereference).</p>\n<p>This is required in a few places, for example in pointer comparison (5.9, relational operators):</p>\n<blockquote>\n<p id=\"so_26289918_26290247_0\">If two pointers point to elements of the same array or one beyond the\n  end of the array, the pointer to the object with the higher subscript\n  compares higher.</p>\n</blockquote>\n<p>This is actually relied on for the STL. The \"end()\" function of iterators is equivalent to 1 past the end of the array.</p>\n<p>I also see this in section 27.6.2: Stream Buffer requirements</p>\n<p>So your snippet:</p>\n<pre><code>std::sort(myarray, &amp;myarray[4]);\n</code></pre>\n<p>is basically the same as if you used a vector of int</p>\n<pre><code>  vector&lt;int&gt; yourArray;\n  std::sort(yourArray.begin(), yourArray.end());\n</code></pre>\n", "OwnerUserId": "1791696", "PostTypeId": "2", "Id": "26290247", "Score": "-2", "CreationDate": "2014-10-10T00:47:40.770", "LastActivityDate": "2014-10-10T00:47:40.770"}, "26289918": {"CommentCount": "13", "ViewCount": "148", "PostTypeId": "1", "ClosedDate": "2014-10-10T01:58:18.830", "LastEditorUserId": "3204551", "CreationDate": "2014-10-10T00:08:32.117", "LastActivityDate": "2014-10-10T01:29:58.103", "Title": "Is &a[n] valid, where n is the size of the array?", "LastEditDate": "2014-10-10T01:00:32.327", "Id": "26289918", "Score": "2", "Body": "<p>Consider the following simple code to sort an array.</p>\n<pre><code>int myarray[4] = {};\nstd::sort(myarray, myarray + 4);\n</code></pre>\n<p>I know that it is valid to create a pointer to one past the end of a C-style array.</p>\n<p>I've recently seen code like this:</p>\n<pre><code>std::sort(myarray, &amp;myarray[4]);\n</code></pre>\n<p>I'm not sure this is valid, because it dereferences an element outside the array bounds, even though the element value is not used for anything.</p>\n<p>Is this valid code?</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "2068573", "AnswerCount": "4"}, "26289943": {"ParentId": "26289918", "CommentCount": "6", "Body": "<p>It is valid for the same reason your original is valid: it can determine where that element <em>would</em> be.  In the latter case, just because it identifies a nonexistent element, since it does't try to access it, there is no problem.</p>\n<p>Or, more concisely: <code>myarray+4</code> and <code>&amp;myarray[4]</code> are synonyms.</p>\n", "OwnerUserId": "535275", "PostTypeId": "2", "Id": "26289943", "Score": "0", "CreationDate": "2014-10-10T00:11:12.873", "LastActivityDate": "2014-10-10T00:11:12.873"}, "26289958": {"ParentId": "26289918", "PostTypeId": "2", "CommentCount": "16", "Body": "<p><code>A[i]</code> is syntactically equivalent to <code>*(A + i)</code> for an array or pointer <code>A</code>.<br>\nSo <code>&amp;A[i]</code> is syntactically equivalent to <code>&amp;(*(A + i))</code>.</br></p>\n<p>When <code>*(A + i)</code> does not have undefined behavior, <code>&amp;(*(A + i))</code> will behave identically to <code>A + i</code>.</p>\n<p>The problem is that <code>myarray[4]</code> is syntactically equivalent to <code>*(myarray + 4)</code>, which dereferences a location out of the array's bounds.  That is undefined behavior according to the standard.</p>\n<p>So you should absolutely prefer <code>myarray + 4</code> over <code>&amp;myarray[4]</code> - the latter is undefined behavior.</p>\n<p>That <code>&amp;myarray[4]</code> has \"<em>correct</em>\" behavior with most - if not all - compilers does not exempt it from having <em>undefined</em> behavior according to the standard.</p>\n", "OwnerUserId": "1828879", "LastEditorUserId": "1828879", "LastEditDate": "2014-10-10T01:29:58.103", "Id": "26289958", "Score": "7", "CreationDate": "2014-10-10T00:12:57.860", "LastActivityDate": "2014-10-10T01:29:58.103"}, "26290347": {"ParentId": "26289918", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>According to \u00a76.5.3.2 in the C99 standard, its valid C:</p>\n<blockquote>\n<p id=\"so_26289918_26290347_0\">The unary &amp; operator yields the address of its operand. If the operand\n  has type \u2018\u2018type\u2019\u2019, the result has type \u2018\u2018pointer to type\u2019\u2019. If the\n  operand is the result of a unary * operator, neither that operator nor\n  the &amp; operator is evaluated and the result is <strong>as if both were omitted</strong></p>\n</blockquote>\n<p>There seems to be no equivalent counterpart in C++, probably due to operator overloading.</p>\n", "OwnerUserId": "3202093", "LastEditorUserId": "3202093", "LastEditDate": "2014-10-10T01:24:08.167", "Id": "26290347", "Score": "-2", "CreationDate": "2014-10-10T01:04:03.947", "LastActivityDate": "2014-10-10T01:24:08.167"}, "bq_ids": {"n4140": {"so_26289918_26290247_0": {"section_id": 6151, "quality": 0.6875, "length": 11}, "so_26289918_26290347_0": {"section_id": 584, "quality": 0.5185185185185185, "length": 14}}, "n3337": {"so_26289918_26290247_0": {"section_id": 5913, "quality": 1.0, "length": 16}, "so_26289918_26290347_0": {"section_id": 574, "quality": 0.5185185185185185, "length": 14}}, "n4659": {"so_26289918_26290247_0": {"section_id": 7648, "quality": 0.625, "length": 10}, "so_26289918_26290347_0": {"section_id": 607, "quality": 0.5185185185185185, "length": 14}}}});