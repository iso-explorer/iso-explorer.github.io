post_cb({"26290347": {"Id": "26290347", "PostTypeId": "2", "Body": "<p>According to \u00a76.5.3.2 in the C99 standard, its valid C:</p>\n<blockquote>\n<p id=\"so_26289918_26290347_0\">The unary &amp; operator yields the address of its operand. If the operand\n  has type \u2018\u2018type\u2019\u2019, the result has type \u2018\u2018pointer to type\u2019\u2019. If the\n  operand is the result of a unary * operator, neither that operator nor\n  the &amp; operator is evaluated and the result is <strong>as if both were omitted</strong></p>\n</blockquote>\n<p>There seems to be no equivalent counterpart in C++, probably due to operator overloading.</p>\n", "LastEditorUserId": "3202093", "LastActivityDate": "2014-10-10T01:24:08.167", "Score": "-2", "CreationDate": "2014-10-10T01:04:03.947", "ParentId": "26289918", "CommentCount": "5", "OwnerUserId": "3202093", "LastEditDate": "2014-10-10T01:24:08.167"}, "26290247": {"Id": "26290247", "PostTypeId": "2", "Body": "<p>The standard requires that a pointer to one-past the end of an array be a valid value for the pointer to have. (It doesn't mean that it is OK to dereference).</p>\n<p>This is required in a few places, for example in pointer comparison (5.9, relational operators):</p>\n<blockquote>\n<p id=\"so_26289918_26290247_0\">If two pointers point to elements of the same array or one beyond the\n  end of the array, the pointer to the object with the higher subscript\n  compares higher.</p>\n</blockquote>\n<p>This is actually relied on for the STL. The \"end()\" function of iterators is equivalent to 1 past the end of the array.</p>\n<p>I also see this in section 27.6.2: Stream Buffer requirements</p>\n<p>So your snippet:</p>\n<pre><code>std::sort(myarray, &amp;myarray[4]);\n</code></pre>\n<p>is basically the same as if you used a vector of int</p>\n<pre><code>  vector&lt;int&gt; yourArray;\n  std::sort(yourArray.begin(), yourArray.end());\n</code></pre>\n", "LastActivityDate": "2014-10-10T00:47:40.770", "CommentCount": "7", "CreationDate": "2014-10-10T00:47:40.770", "ParentId": "26289918", "Score": "-2", "OwnerUserId": "1791696"}, "26289943": {"Id": "26289943", "PostTypeId": "2", "Body": "<p>It is valid for the same reason your original is valid: it can determine where that element <em>would</em> be.  In the latter case, just because it identifies a nonexistent element, since it does't try to access it, there is no problem.</p>\n<p>Or, more concisely: <code>myarray+4</code> and <code>&amp;myarray[4]</code> are synonyms.</p>\n", "LastActivityDate": "2014-10-10T00:11:12.873", "CommentCount": "6", "CreationDate": "2014-10-10T00:11:12.873", "ParentId": "26289918", "Score": "0", "OwnerUserId": "535275"}, "bq_ids": {"n4140": {"so_26289918_26290247_0": {"length": 11, "quality": 0.6875, "section_id": 6151}, "so_26289918_26290347_0": {"length": 14, "quality": 0.5185185185185185, "section_id": 584}}, "n3337": {"so_26289918_26290247_0": {"length": 16, "quality": 1.0, "section_id": 5913}, "so_26289918_26290347_0": {"length": 14, "quality": 0.5185185185185185, "section_id": 574}}, "n4659": {"so_26289918_26290247_0": {"length": 10, "quality": 0.625, "section_id": 7648}, "so_26289918_26290347_0": {"length": 14, "quality": 0.5185185185185185, "section_id": 607}}}, "26289918": {"ViewCount": "148", "Body": "<p>Consider the following simple code to sort an array.</p>\n<pre><code>int myarray[4] = {};\nstd::sort(myarray, myarray + 4);\n</code></pre>\n<p>I know that it is valid to create a pointer to one past the end of a C-style array.</p>\n<p>I've recently seen code like this:</p>\n<pre><code>std::sort(myarray, &amp;myarray[4]);\n</code></pre>\n<p>I'm not sure this is valid, because it dereferences an element outside the array bounds, even though the element value is not used for anything.</p>\n<p>Is this valid code?</p>\n", "Title": "Is &a[n] valid, where n is the size of the array?", "CreationDate": "2014-10-10T00:08:32.117", "Id": "26289918", "CommentCount": "13", "LastEditDate": "2014-10-10T01:00:32.327", "PostTypeId": "1", "LastEditorUserId": "3204551", "LastActivityDate": "2014-10-10T01:29:58.103", "Tags": "<c++><language-lawyer>", "Score": "2", "OwnerUserId": "2068573", "ClosedDate": "2014-10-10T01:58:18.830", "AnswerCount": "4"}, "26289958": {"Id": "26289958", "PostTypeId": "2", "Body": "<p><code>A[i]</code> is syntactically equivalent to <code>*(A + i)</code> for an array or pointer <code>A</code>.<br>\nSo <code>&amp;A[i]</code> is syntactically equivalent to <code>&amp;(*(A + i))</code>.</br></p>\n<p>When <code>*(A + i)</code> does not have undefined behavior, <code>&amp;(*(A + i))</code> will behave identically to <code>A + i</code>.</p>\n<p>The problem is that <code>myarray[4]</code> is syntactically equivalent to <code>*(myarray + 4)</code>, which dereferences a location out of the array's bounds.  That is undefined behavior according to the standard.</p>\n<p>So you should absolutely prefer <code>myarray + 4</code> over <code>&amp;myarray[4]</code> - the latter is undefined behavior.</p>\n<p>That <code>&amp;myarray[4]</code> has \"<em>correct</em>\" behavior with most - if not all - compilers does not exempt it from having <em>undefined</em> behavior according to the standard.</p>\n", "LastEditorUserId": "1828879", "LastActivityDate": "2014-10-10T01:29:58.103", "Score": "7", "CreationDate": "2014-10-10T00:12:57.860", "ParentId": "26289918", "CommentCount": "16", "OwnerUserId": "1828879", "LastEditDate": "2014-10-10T01:29:58.103"}});