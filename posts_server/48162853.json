post_cb({"bq_ids": {"n4140": {"so_48162853_48162904_0": {"length": 30, "quality": 0.7692307692307693, "section_id": 638}}, "n3337": {"so_48162853_48162904_0": {"length": 30, "quality": 0.7692307692307693, "section_id": 628}}, "n4659": {"so_48162853_48162904_0": {"length": 30, "quality": 0.7692307692307693, "section_id": 666}}}, "48162853": {"ViewCount": "56", "Body": "<p>I write a simple <code>C++</code> program:  </p>\n<pre><code>#include &lt;stdint.h&gt;\n#include &lt;iostream&gt;\nusing namespace std;\n\nclass B {\npublic:\n    B(const bool&amp; value = false) {cout &lt;&lt; \"B\" &lt;&lt; endl;} \n};\n\ntemplate &lt;typename t1, typename t2&gt;\nclass A {\npublic:\n    A(const t1 &amp;value) {cout &lt;&lt; \"A1\" &lt;&lt; endl;};\n    A(const t2 &amp;value) {cout &lt;&lt; \"A2\" &lt;&lt; endl;};\n};\n\nint main() {\n    typedef A&lt;B, int8_t&gt; T;\n    T v(false);\n\n    return 0;\n}\n</code></pre>\n<p>Per my understanding, in the following code:  </p>\n<pre><code>T v(false);\n</code></pre>\n<p><code>false</code> can trigger <code>B</code>'s converting constructor(<code>B(const bool&amp; value = false) {cout &lt;&lt; \"B\" &lt;&lt; endl;}</code>) called, so the first <code>A</code>'s constructor should run. But in fact, the second <code>A</code>'s constructor is called.  </p>\n<p>So why doesn't converting constructor called?</p>\n", "AcceptedAnswerId": "48162904", "Title": "Why doesn't converting constructor called in template class?", "CreationDate": "2018-01-09T06:59:30.917", "Id": "48162853", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2018-01-09T07:35:55.047", "Score": "0", "OwnerUserId": "2106207", "Tags": "<c++>", "AnswerCount": "1"}, "48162904": {"Id": "48162904", "PostTypeId": "2", "Body": "<p>Calling the first constructor would require a <em>user-defined</em> conversion from <code>bool</code> to <code>B</code>. Calling the second one would require a <em>standard</em> conversion from <code>bool</code> to <code>int8_t</code>.  The latter is a better match, which I think is pretty natural.</p>\n<blockquote>\n<p id=\"so_48162853_48162904_0\"><strong>13.3.3.2 Ranking implicit conversion sequences</strong><br>\n<strong>2</strong> When comparing the basic forms of implicit conversion sequences (as defined in 13.3.3.1)<br>\n   \u2014 a standard conversion sequence (13.3.3.1.1) is a better conversion sequence than a user-defined conversion sequence or an ellipsis conversion sequence, and<br>\n   \u2014 a user-defined conversion sequence (13.3.3.1.2) is a better conversion sequence than an ellipsis conversion sequence (13.3.3.1.3).</br></br></br></p>\n</blockquote>\n<p>Keep in mind that <code>bool</code> is considered an <em>integral</em> type in C++, so the conversion to <code>int8_t</code> is indeed a rather unremarkable conversion from one integral type to another. A user-defined conversion to a <em>class</em> is a much more involving process. It is not surprising that language rules favor the simple conversion to <code>int8_t</code>.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2018-01-09T07:12:06.120", "Score": "3", "CreationDate": "2018-01-09T07:03:46.440", "ParentId": "48162853", "CommentCount": "0", "OwnerUserId": "187690", "LastEditDate": "2018-01-09T07:12:06.120"}});