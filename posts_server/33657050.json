post_cb({"33657050": {"CommentCount": "29", "ViewCount": "547", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-11-11T18:10:46.070", "LastActivityDate": "2015-11-15T12:17:16.667", "Title": "Are end+1 iterators for std::string allowed?", "FavoriteCount": "5", "LastEditDate": "2017-05-23T11:53:35.010", "Id": "33657050", "Score": "19", "Body": "<p>Is it valid to create an iterator to <code>end(str)+1</code> for <code>std::string</code>?<br>\nAnd if it isn't, <em>why</em> isn't it?</br></p>\n<p>This question is restricted to C++11 and later, because while pre-C++11 the data was already stored in a continuous block in any but rare POC toy-implementations,  the data didn't <em>have</em> to be stored that way.<br>\nAnd I think that might make all the difference.</br></p>\n<p>The significant difference between <code>std::string</code> and any other standard container I speculate on is that it always contains one element more than its <code>size</code>, the zero-terminator, to fulfill the requirements of <code>.c_str()</code>.</p>\n<blockquote>\n<h3>21.4.7.1 basic_string accessors <em>[string.accessors]</em></h3>\n<pre><code>const charT* c_str() const noexcept;\nconst charT* data() const noexcept;\n</code></pre>\n<p id=\"so_33657050_33657050_0\">1 Returns: A pointer <code>p</code> such that <code>p + i == &amp;operator[](i)</code> for each <code>i</code> in <code>[0,size()]</code>.<br>\n  2 Complexity: Constant time.<br>\n  3 Requires: The program shall not alter any of the values stored in the character array.</br></br></p>\n</blockquote>\n<p>Still, even though it <em>should</em> imho guarantee that said expression is valid, for consistency and interoperability with zero-terminated strings if nothing else, the only paragraph I found casts doubt on that:</p>\n<blockquote>\n<h3>21.4.1 basic_string general requirements <em>[string.require]</em></h3>\n<p id=\"so_33657050_33657050_1\">4 The char-like objects in a <code>basic_string</code> object shall be stored contiguously. That is, for any <code>basic_string</code> object <code>s</code>, the identity <code>&amp;*(s.begin() + n) == &amp;*s.begin() + n</code> shall hold for all values of <code>n</code> such that <code>0 &lt;= n &lt; s.size()</code>.</p>\n</blockquote>\n<p>(All quotes are from C++14 final draft (n3936).)</p>\n<p>Related: <a href=\"https://stackoverflow.com/questions/12740403/legal-to-overwrite-stdstrings-null-terminator\">Legal to overwrite std::string's null terminator?</a></p>\n", "Tags": "<c++><string><iterator><language-lawyer><stdstring>", "OwnerUserId": "3204551", "AnswerCount": "3"}, "33665158": {"ParentId": "33657050", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_33657050_33665158_0\">Returns: A pointer <code>p</code> such that <code>p + i == &amp;operator[](i)</code> for each <code>i</code> in <code>[0,size()]</code>.</p>\n</blockquote>\n<p><code>std::string::operator[](size_type i)</code> is specified to return \"a reference to an object of type <code>charT</code> with value <code>charT()</code> when <code>i == size()</code>, so we know that that pointer points to an object.</p>\n<p>5.7 states that \"For the purposes of [operators + and -], a pointer to a nonarray object behaves the same as a pointer to the first element of an array of length one with the type of the object as its element type.\"</p>\n<p>So we have a non-array object and the spec guarantees that a pointer one past it will be representable. So we know <code>std::addressof(*end(str)) + 1</code> has to be representable.</p>\n<p>However that's not a guarantee on <code>std::string::iterator</code>, and there is no such guarantee anywhere in the spec, which makes it undefined behavior.</p>\n<p>(Note that this is not the same as 'ill-formed'. <code>*end(str) + 1</code> is in fact well-formed.)</p>\n<p>Iterators can and do implement checking logic that produce various errors when you do things like increment the <code>end()</code> iterator. This is in fact what Visual Studios debug iterators do with <code>end(str) + 1</code>.</p>\n<pre><code>#define _ITERATOR_DEBUG_LEVEL 2\n#include &lt;string&gt;\n#include &lt;iterator&gt;\n\nint main() {\n  std::string s = \"ssssssss\";\n  auto x = std::end(s) + 1; // produces debug dialog, aborts program if skipped\n}\n</code></pre>\n<blockquote>\n<p id=\"so_33657050_33665158_1\">And if it isn't, <em>why</em> isn't it?</p>\n<p id=\"so_33657050_33665158_2\">for consistency and interoperability with zero-terminated strings if nothing else</p>\n</blockquote>\n<p>C++ specifies some specific things for compatibility with C, but such backwards compatibility is limited to supporting things that can actually be written in C. C++ doesn't necessarily try to take C's semantics and make new constructs behave in some analogous way. Should <code>std::vector</code> decay to an iterator just to be consistent with C's array decay behavior?</p>\n<p>I'd say <code>end(std) + 1</code> is left as undefined behavior because there's no value in trying to constrain <code>std::string</code> iterators this way. There's no legacy C code that does this that C++ needs to be compatible with and new code should be prevented from doing it.</p>\n<blockquote>\n<p id=\"so_33657050_33665158_3\">New code should be prevented from relying on it... why? [...] What does not allowing it buy you in theory, and how does that look in practice?</p>\n</blockquote>\n<p>Not allowing it means implementations don't have to support the added complexity, complexity which provides zero demonstrated value.</p>\n<p>In fact it seems to me that supporting <code>end(str) + 1</code> has negative value since code that tries to use it will essentially be creating the same problem as C code which can't figure out when to account for the null terminator or not. C has enough off by one buffer size errors for both languages.</p>\n", "OwnerUserId": "365496", "LastEditorUserId": "365496", "LastEditDate": "2015-11-12T18:58:57.990", "Id": "33665158", "Score": "5", "CreationDate": "2015-11-12T05:45:09.820", "LastActivityDate": "2015-11-12T18:58:57.990"}, "bq_ids": {"n4140": {"so_33657050_33675281_11": {"section_id": 5559, "quality": 0.9047619047619048, "length": 38}, "so_33657050_33675281_3": {"section_id": 1619, "quality": 1.0, "length": 7}, "so_33657050_33675281_13": {"section_id": 5569, "quality": 0.7142857142857143, "length": 5}, "so_33657050_33675281_9": {"section_id": 1560, "quality": 0.75, "length": 6}, "so_33657050_33675281_6": {"section_id": 1596, "quality": 1.0, "length": 11}, "so_33657050_33657050_1": {"section_id": 1566, "quality": 0.7777777777777778, "length": 14}, "so_33657050_33675281_1": {"section_id": 1619, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_33657050_33675281_11": {"section_id": 5341, "quality": 0.9047619047619048, "length": 38}, "so_33657050_33675281_3": {"section_id": 1615, "quality": 1.0, "length": 7}, "so_33657050_33675281_13": {"section_id": 5351, "quality": 0.7142857142857143, "length": 5}, "so_33657050_33675281_9": {"section_id": 1554, "quality": 0.75, "length": 6}, "so_33657050_33675281_6": {"section_id": 1592, "quality": 1.0, "length": 11}, "so_33657050_33657050_1": {"section_id": 1561, "quality": 0.7777777777777778, "length": 14}, "so_33657050_33675281_1": {"section_id": 1615, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_33657050_33675281_11": {"section_id": 7006, "quality": 0.9047619047619048, "length": 38}, "so_33657050_33675281_3": {"section_id": 1772, "quality": 1.0, "length": 7}, "so_33657050_33675281_6": {"section_id": 1748, "quality": 1.0, "length": 11}, "so_33657050_33675281_1": {"section_id": 1772, "quality": 0.7142857142857143, "length": 5}, "so_33657050_33675281_13": {"section_id": 7016, "quality": 0.7142857142857143, "length": 5}}}, "33674891": {"ParentId": "33657050", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>A <code>std::basic_string&lt;???&gt;</code> is a container over its elements.  Its elements do not include the trailing null that is implicitly added (it can include embedded nulls).</p>\n<p>This makes lots of sense -- \"for each character in this string\" probably shouldn't return the trailing <code>'\\0'</code>, as that is really an implementation detail for compatibility with C style APIs.</p>\n<p>The iterator rules for containers were based off of containers that don't shove an extra element at the end.  Modifying them for <code>std::basic_string&lt;???&gt;</code> without motivation is questionable; one should only break a working pattern if there is a payoff.</p>\n<p>There is every reason to think that pointers to <code>.data()</code> and <code>.data() + .size() + 1</code> are allowed (I could imagine a twisted interpretation of the standard that would make it not allowed).  So if you really need <em>read-only</em> iterators into the contents of a <code>std::string</code>, you can use pointer-to-const-elements (which are, after all, a kind of iterator).</p>\n<p>If you want editable ones, then no, there is no way to get a valid iterator to one-past-the-end.  Neither can you get a non-<code>const</code> reference to the trailing null legally.  In fact, such access is clearly a bad idea; if you change the value of that element, you break the <code>std::basic_string</code>'s invariant null-termination.</p>\n<p>For there to be an iterator to one-past-the-end, the const and non-const iterators to the container would have to have a different valid range, or a non-const iterator to the last element that can be dereferenced but not written to must exist.</p>\n<p>I shudder at making such standard wording watertight.</p>\n<p><code>std::basic_string</code> is already a mess.  Making it even stranger would lead to standard bugs and would have a non-trivial cost.  The benefit is really low; in the few cases where you want access to said trailing null in an iterator range, you can use <code>.data()</code> and use the resulting pointers as iterators.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "3204551", "LastEditDate": "2015-11-12T15:24:45.753", "Id": "33674891", "Score": "2", "CreationDate": "2015-11-12T15:19:53.677", "LastActivityDate": "2015-11-12T15:24:45.753"}, "33675281": {"ParentId": "33657050", "PostTypeId": "2", "CommentCount": "5", "Body": "<p><strong>TL;DR:</strong> <code>s.end() + 1</code> is undefined behavior.</p>\n<hr>\n<p><code>std::string</code> is a strange beast, mainly for historical reasons:</p>\n<ol>\n<li>It attempts to bring C compatibility, where it is known that an additional <code>\\0</code> character exists beyond the length reported by <code>strlen</code>.</li>\n<li>It was designed with an index-based interface.</li>\n<li>As an after thought, when merged in the Standard library with the rest of the STL code, an iterator-based interface was added.</li>\n</ol>\n<p>This led <code>std::string</code>, in C++03, to number <a href=\"http://www.gotw.ca/gotw/084.htm\" rel=\"nofollow\">103 member functions</a>, and since then a few were added.</p>\n<p>Therefore, discrepancies between the different methods should be expected.</p>\n<hr>\n<p>Already in the index-based interface discrepancies appear:</p>\n<blockquote>\n<p id=\"so_33657050_33675281_0\"><strong>\u00a721.4.5 [string.access]</strong></p>\n<p id=\"so_33657050_33675281_1\"><code>const_reference operator[](size_type pos) const;</code><br>\n<code>reference       operator[](size_type pos);</code> </br></p>\n<p id=\"so_33657050_33675281_2\"><strong>1/</strong> <em>Requires:</em> <code>pos &lt;= size()</code></p>\n<p id=\"so_33657050_33675281_3\"><code>const_reference at(size_type pos) const;</code>\n<code>reference       at(size_type pos);</code></p>\n<p id=\"so_33657050_33675281_4\"><strong>5/</strong> <em>Throws:</em> <code>out_of_range</code> if <code>pos &gt;= size()</code></p>\n</blockquote>\n<p>Yes, you read this right, <code>s[s.size()]</code> returns a reference to a NUL character while <code>s.at(s.size())</code> throws an <code>out_of_range</code> exception. If anyone tells you to replace all uses of <code>operator[]</code> by <code>at</code> because they are safer, beware the <code>string</code> trap...</p>\n<hr>\n<p>So, what about iterators?</p>\n<blockquote>\n<p id=\"so_33657050_33675281_5\"><strong>\u00a721.4.3 [string.iterators]</strong></p>\n<p id=\"so_33657050_33675281_6\"><code>iterator       end() noexcept;</code><br>\n<code>const_iterator end() const noexcept;</code><br>\n<code>const_iterator cend() const noexcept;</code> </br></br></p>\n<p id=\"so_33657050_33675281_7\"><strong>2/</strong> <em>Returns:</em> An iterator which is the <em>past-the-end</em> value.</p>\n</blockquote>\n<p>Wonderfully bland.</p>\n<p>So we have to refer to other paragraphs. A pointer is offered by</p>\n<blockquote>\n<p id=\"so_33657050_33675281_8\"><strong>\u00a721.4 [basic.string]</strong></p>\n<p id=\"so_33657050_33675281_9\"><strong>3/</strong> The iterators supported by <code>basic_string</code> are random access iterators (24.2.7).</p>\n</blockquote>\n<p>while <strong>\u00a717.6 [requirements]</strong> seems devoid of anything related. Thus, strings iterators are just plain old iterators (you can probably sense where this is going... but since we came this far let's go all the way).</p>\n<p>This leads us to:</p>\n<blockquote>\n<p id=\"so_33657050_33675281_10\"><strong>24.2.1 [iterator.requirements.general]</strong></p>\n<p id=\"so_33657050_33675281_11\"><strong>5/</strong> Just as a regular pointer to an array guarantees that there is a pointer value pointing past the last element of the array, so for any iterator type there is an iterator value that points past the last element of a corresponding sequence. These values are called <em>past-the-end</em> values. Values of an iterator <code>i</code> for which the expression <code>*i</code> is defined are called dereferenceable. The library never assumes that <em>past-the-end</em> values are dereferenceable. [...]</p>\n</blockquote>\n<p>So, <code>*s.end()</code> is ill-formed.</p>\n<blockquote>\n<p id=\"so_33657050_33675281_12\"><strong>24.2.3 [input.iterators]</strong></p>\n<p id=\"so_33657050_33675281_13\"><strong>2/</strong> Table 107 -- Input iterator requirements (in addition to Iterator)</p>\n</blockquote>\n<p>List for pre-condition to <code>++r</code> and <code>r++</code> that <code>r</code> be dereferencable.</p>\n<p>Neither the Forward iterators, Bidirectional iterators nor Random iterator lift this restriction (and all indicate they inherit the restrictions of their predecessor).</p>\n<p>Also, for completeness, in <strong>24.2.7 [random.access.iterators]</strong>, <em>Table 111 -- Random access iterator requirements (in addition to bidirectional iterator)</em> lists the following operational semantics:</p>\n<ul>\n<li><code>r += n</code> is equivalent to [inc|dec]rememting <code>r</code> <code>n</code> times</li>\n<li><code>a + n</code> and <code>n + a</code> are equivalent to copying <code>a</code> and then applying <code>+= n</code> to the copy</li>\n</ul>\n<p>and similarly for <code>-= n</code> and <code>- n</code>.</p>\n<p><strong>Thus <code>s.end() + 1</code> is undefined behavior.</strong></p>\n</hr></hr></hr>", "OwnerUserId": "147192", "LastEditorUserId": "147192", "LastEditDate": "2015-11-15T12:17:16.667", "Id": "33675281", "Score": "9", "CreationDate": "2015-11-12T15:36:42.423", "LastActivityDate": "2015-11-15T12:17:16.667"}});