post_cb({"bq_ids": {"n4140": {"so_27594731_33502576_4": {"length": 7, "quality": 1.0, "section_id": 3240}}, "n3337": {"so_27594731_33502576_4": {"length": 7, "quality": 1.0, "section_id": 3113}}, "n4659": {"so_27594731_33502576_4": {"length": 7, "quality": 1.0, "section_id": 3996}}}, "33502576": {"Id": "33502576", "PostTypeId": "2", "Body": "<p>Why does <code>libstdc++</code> use <code>... ...</code> in it's implementation of <code>is_function</code>? If we check out the cppreference section for <a href=\"http://en.cppreference.com/w/cpp/types/is_function\" rel=\"nofollow noreferrer\">std::is_function</a> it gives a sample implementation and says for the first <code>... ...</code> case:</p>\n<pre><code>// specialization for variadic functions such as std::printf\ntemplate&lt;class Ret, class... Args&gt;\nstruct is_function&lt;Ret(Args......)&gt; : std::true_type {};\n</code></pre>\n<p>so we need the second set of <code>...</code> to match a variadic function like <code>printf</code>:</p>\n<pre><code>           Comma optional as per 8.3.5 [dcl.fct] \n           |\n           v\nRet(Args... ...)\n        ^   ^\n        |   |\n        Match a function with a variable number of arguments\n            |\n            and the function is a variadic function\n</code></pre>\n<p>Note, we have functions like <code>fprintf</code> that two arguments before the variadic terms and we need to match those as well.\nIndeed if we use that implementation and attempt to match <code>printf</code> without the <code>... ...</code> specialization then it fails <a href=\"http://melpon.org/wandbox/permlink/U8NogUTEsXPzOrft\" rel=\"nofollow noreferrer\">see it live</a>.</p>\n<p>This corner of the language is covered in this post <a href=\"http://lbrandy.com/blog/2013/02/c11s-six-dots/\" rel=\"nofollow noreferrer\">C++11's six dots</a>:</p>\n<blockquote>\n<p id=\"so_27594731_33502576_0\">I was mucking around the other day and discovered this nice little oddity:</p>\n<pre><code>template &lt;typename... Args&gt;\nvoid foo(Args......);\n</code></pre>\n<p id=\"so_27594731_33502576_1\">As it turns out, ...... can be totally valid C++11. This is what happens when backward compatibility mixes with new hotness.</p>\n<p id=\"so_27594731_33502576_2\">// These are all equivalent.</p>\n<pre><code>template &lt;typename... Args&gt; void foo1(Args......);\ntemplate &lt;typename... Args&gt; void foo2(Args... ...);\ntemplate &lt;typename... Args&gt; void foo3(Args..., ...);\n</code></pre>\n<p id=\"so_27594731_33502576_3\">Hopefully the last one shows what is happening here. [...]</p>\n</blockquote>\n<p>Why is this valild? We can see that <code>, ...</code> is synonymous with <code>...</code> from the draft C++11 standard section <code>8.3.5</code> <em>[dcl.fct]</em> which has the following grammar:</p>\n<pre><code>parameter-declaration-clause:\n  parameter-declaration-listopt...opt\n  parameter-declaration-list , ...\n</code></pre>\n<p>and says:</p>\n<blockquote>\n<p id=\"so_27594731_33502576_4\">[...] Where syntactically correct and where \u201c...\u201d is not part of\n  an abstract-declarator, \u201c, ...\u201d is synonymous with \u201c...\u201d. [...]</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-11-05T14:51:27.007", "Score": "52", "CreationDate": "2015-11-03T15:12:28.877", "ParentId": "27594731", "CommentCount": "3", "OwnerUserId": "1708801", "LastEditDate": "2015-11-05T14:51:27.007"}, "27594731": {"ViewCount": "1934", "Body": "<p>While looking at <a href=\"https://stackoverflow.com/q/27594273/4224575\">this</a> question I found myself in the <a href=\"http://en.cppreference.com/w/cpp/types/is_function\" rel=\"nofollow noreferrer\">cpp reference site</a> where I noticed a strange and new to me syntax : </p>\n<pre><code>template&lt;class Ret, class... Args&gt;\nstruct is_function&lt;Ret(Args......)volatile &amp;&amp;&gt; : std::true_type {};\n</code></pre>\n<p>Yep, 6 dots ! Initially I thought this was a typo, but after checking the libstdc++ <a href=\"https://gcc.gnu.org/onlinedocs/libstdc++/latest-doxygen/a01562_source.html\" rel=\"nofollow noreferrer\">source</a> again there it was eg at line 444 :</p>\n<pre><code>template&lt;typename _Res, typename... _ArgTypes&gt;\nstruct is_function&lt;_Res(_ArgTypes......) volatile &amp;&amp;&gt; : public true_type { };\n</code></pre>\n<p>Is this a valid syntax ? Dot dot dot, are used to pack and unpack parameter packs ? What do 6 dots do ?</p>\n", "AcceptedAnswerId": "27594765", "Title": "What are the 6 dots in template parameter packs?", "CreationDate": "2014-12-21T23:06:40.063", "Id": "27594731", "CommentCount": "1", "FavoriteCount": "10", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:17:02.330", "LastEditorUserId": "-1", "LastActivityDate": "2015-11-05T14:51:27.007", "ClosedDate": "2014-12-21T23:08:29.307", "Score": "11", "OwnerUserId": "4224575", "Tags": "<c++><c++11><c++14><variadic-templates><partial-specialization>", "AnswerCount": "2"}, "27594765": {"Id": "27594765", "PostTypeId": "2", "Body": "<p>In this case, the two are for different purposes.  The first is for parameter pack expansion and the second is for variable argument lists.  That particular declaration is to handle functions which take some regular parameters plus a variable argument list.</p>\n<p>The difference is between run-time and compile-time variability.  A function which takes a variable number of arguments at run-time is special. It is a single function which can handle a variable number of arguments from the caller:</p>\n<pre><code>void f(int x,...) // equivalent to void f(int x ...)\n{\n    // Do some run-time logic here to determine what to\n    // do with parameters after x.\n}\n</code></pre>\n<p>This is distinct from the notion that we want to be able to have a template which uses a variety of functions with various parameters which are known at compile time.  For example, we could define a function template which takes a pointer to a function and allow the number and types of the arguments to vary:</p>\n<pre><code>template &lt;typename... Args&gt;\nvoid g(void (*function_ptr)(Args...)) \n{ \n    // We can do logic here to call function_ptr with the proper\n    // number of arguments.\n}\n</code></pre>\n<p>Given these functions:</p>\n<pre><code>void f1(int);\nvoid f2(int,float);\n</code></pre>\n<p>You can call g with any of them:</p>\n<pre><code>g(f1); // fine\ng(f2); // also fine\n</code></pre>\n<p>However</p>\n<pre><code>g(f); // error\n</code></pre>\n<p>The compiler wouldn't know what to use for the <code>Args</code> parameter pack in <code>g</code>.</p>\n", "LastEditorUserId": "951890", "LastActivityDate": "2015-11-04T03:55:00.880", "Score": "7", "CreationDate": "2014-12-21T23:10:51.973", "ParentId": "27594731", "CommentCount": "4", "OwnerUserId": "951890", "LastEditDate": "2015-11-04T03:55:00.880"}});