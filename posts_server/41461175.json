post_cb({"bq_ids": {"n4140": {"so_41461175_41461201_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 11}, "so_41461175_41461201_1": {"length": 7, "quality": 0.875, "section_id": 6079}}, "n3337": {"so_41461175_41461201_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 8}, "so_41461175_41461201_1": {"length": 7, "quality": 0.875, "section_id": 5847}}, "n4659": {"so_41461175_41461201_2": {"length": 17, "quality": 0.9444444444444444, "section_id": 12}, "so_41461175_41461201_1": {"length": 7, "quality": 0.875, "section_id": 7575}}}, "41461420": {"Id": "41461420", "PostTypeId": "2", "Body": "<pre><code>double array[2][1];\ndouble* arrayPtr;\narrayPtr = &amp; array[0];\n</code></pre>\n<p><code>arrayPtr</code> has the type</p>\n<pre><code>POINTER (DOUBLE)\n</code></pre>\n<p>while <code>array</code> has the type</p>\n<pre><code>POINTER(POINTER(DOUBLE))\n</code></pre>\n<p><code>&amp;array[0]</code> has the type</p>\n<pre><code>POINTER(POINTER(DOUBLE))\n</code></pre>\n<p>You try to assign</p>\n<pre><code>POINTER (DOUBLE) &lt;= POINTER(POINTER(DOUBLE))\n</code></pre>\n<p>The correct way to do it is</p>\n<pre><code>arrayPtr = array[0];\n</code></pre>\n<p>or</p>\n<pre><code>arrayPtr = *array;\n</code></pre>\n", "LastEditorUserId": "1419272", "LastActivityDate": "2017-01-04T11:57:06.480", "Score": "1", "CreationDate": "2017-01-04T10:21:06.613", "ParentId": "41461175", "CommentCount": "2", "OwnerUserId": "1419272", "LastEditDate": "2017-01-04T11:57:06.480"}, "41461175": {"ViewCount": "66", "Body": "<p>I wrote the following code to point to first row of a 2-dimensional array. However, when I do</p>\n<pre><code>arrayPtr = &amp; array[0];\n</code></pre>\n<p>I end up getting </p>\n<blockquote>\n<p id=\"so_41461175_41461175_0\">error: cannot convert <code>double (*)[1]</code> to <code>double*</code> in assignment</p>\n<pre><code> arrayPtr = &amp; array[0];\n</code></pre>\n</blockquote>\n<p>My program is:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main(int argc, char **argv) \n{       \n    double array[2][1];\n\n    array[0][1] = 1.0;\n    array[1][1] = 2.0;\n\n    double* arrayPtr;\n    arrayPtr = &amp;array[0];\n\n    return 0;\n}\n</code></pre>\n<p>Can someone help me understand as to where am I going wrong?</p>\n", "AcceptedAnswerId": "41461201", "Title": "Point to specific rows of 2-D arrays", "CreationDate": "2017-01-04T10:10:00.397", "Id": "41461175", "CommentCount": "1", "LastEditDate": "2017-01-04T10:46:17.030", "PostTypeId": "1", "LastEditorUserId": "4774918", "LastActivityDate": "2017-01-04T11:57:06.480", "Score": "2", "OwnerUserId": "5701053", "Tags": "<c++><c++11><variable-assignment><addressof>", "AnswerCount": "3"}, "41461201": {"Id": "41461201", "PostTypeId": "2", "Body": "<p>Instead of <code>arrayPtr = &amp; array[0]</code>, you can write</p>\n<pre><code> arrayPtr = array[0];\n</code></pre>\n<p>to make use of array decay property.</p>\n<p>Related, </p>\n<ul>\n<li><p>Quoting <code>C11</code>, chapter \u00a76.3.2.1, <em>Lvalues, arrays, and function designators</em></p>\n<blockquote>\n<p id=\"so_41461175_41461201_0\">Except when it is the operand of the <code>sizeof</code> operator, the <code>_Alignof</code> operator, or the\n  unary <code>&amp;</code> operator, or is a string literal used to initialize an array, an expression that has\n  type <em>\u2018\u2018array of type\u2019\u2019</em> is converted to an expression with type <em>\u2018\u2018pointer to type\u2019\u2019</em> that points\n  to the initial element of the array object and is not an lvalue. [...]</p>\n</blockquote></li>\n<li><p>Quoting <code>C++14</code>, chapter \u00a75.3.3</p>\n<blockquote>\n<p id=\"so_41461175_41461201_1\">The lvalue-to-rvalue <code>(4.1)</code>, array-to-pointer <code>(4.2)</code>, and function-to-pointer <code>(4.3)</code> standard conversions are not\n  applied to the operand of <code>sizeof</code>.</p>\n</blockquote>\n<p>and, for chapter <em>4.2</em>,</p>\n<blockquote>\n<p id=\"so_41461175_41461201_2\">An lvalue or rvalue of type <em>\u201carray of N T\u201d</em> or <em>\u201carray of unknown bound of T\u201d</em> can be converted to a prvalue\n  of type <em>\u201cpointer to T\u201d</em>. The result is a pointer to the first element of the array.</p>\n</blockquote></li>\n</ul>\n<p>So, while used as the RHS operand of the assignment operator, <code>array[0]</code> decays to the pointer to the first element of the array, i.e, produces a type <code>double*</code> which is the same as the LHS.</p>\n<p>Otherwise, the use of <code>&amp;</code> operator prevents the array decay for <code>array[0]</code> which is an array of type <code>double [1]</code>. </p>\n<p>Thus, <code>&amp;array[0]</code> returns a type which is a pointer to an array of <code>double [1]</code>, or, <code>double (*) [1]</code> which is not <em>compatible</em> with the type of the variable supplied in LHS of the assignment, a <code>double *</code>.</p>\n", "LastEditorUserId": "2173917", "LastActivityDate": "2017-01-04T10:34:17.657", "Score": "2", "CreationDate": "2017-01-04T10:11:13.220", "ParentId": "41461175", "CommentCount": "5", "OwnerUserId": "2173917", "LastEditDate": "2017-01-04T10:34:17.657"}, "41461364": {"Id": "41461364", "PostTypeId": "2", "Body": "<p>In your code:</p>\n<ul>\n<li><code>array</code> is of type <code>double (*)[1]</code>;</li>\n<li><code>array[0]</code> is of type <code>double[1]</code></li>\n<li><code>&amp;array[0]</code> (this equals to <code>array</code>) is of type <code>double (*)[1]</code> (i.e. pointer to <code>double[1]</code>)</li>\n</ul>\n<p><strong>Note 1:</strong> <code>T[]</code> can decay to <code>T*</code>. So in your example <code>double[]</code> can decay to <code>double *</code>.</p>\n<p><strong>Note 2:</strong> <code>a[b]</code> == <code>*(a + b)</code>, so in your example <code>&amp;array[0]</code> equals to <code>&amp; (*(array + 0))</code> which is simplified to <code>array</code> itself.</p>\n", "LastActivityDate": "2017-01-04T10:18:32.987", "CommentCount": "0", "CreationDate": "2017-01-04T10:18:32.987", "ParentId": "41461175", "Score": "2", "OwnerUserId": "1841194"}});