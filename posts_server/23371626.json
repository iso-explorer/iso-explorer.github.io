post_cb({"23371701": {"ParentId": "23371626", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>This is more like the C++ name \"resolution\". In your case, you have a pointer to a <code>const DM</code>, but you want a const pointer, so you must use <code>typedef dm_const_t const &amp; dm_cref_t</code> (a const reference to a const pointer)</p>\n<p>Giving more details:</p>\n<p>When you declare <code>const int * a</code>, you are saying that <code>a</code> is a constant pointer to an integer. It is the same as <code>int const * a</code>.</p>\n<p>If you want a reference to a type, you declare <code>int &amp; b</code>, meaning that <code>b</code> is a reference to an integer. Thinking the same way, <code>const int &amp; c</code> is the same as <code>int const &amp; c</code> (const always qualify the <em>variable</em>, not the type).</p>\n<p>So, if you want a const reference to a const pointer, using the second notation is clearer (and the only one possible if not using <code>typedef</code>s): <code>int const * const &amp; d</code>, meaning <code>d</code> is a constant reference to a constant pointer to an integer. Using typedefs:</p>\n<pre><code>typedef const int * int_cptr;\ntypedef const int_cptr &amp; int_cptrcref;\n</code></pre>\n<p>Proof: <a href=\"http://ideone.com/V48Kxe\" rel=\"nofollow\">http://ideone.com/V48Kxe</a></p>\n", "OwnerUserId": "3537339", "LastEditorUserId": "3537339", "LastEditDate": "2014-04-29T18:13:21.743", "Id": "23371701", "Score": "1", "CreationDate": "2014-04-29T17:44:43.623", "LastActivityDate": "2014-04-29T18:13:21.743"}, "23372137": {"ParentId": "23371626", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Look at <code>[conv.qual]</code> (4.4/4) in the C++11 standard:</p>\n<blockquote>\n<p id=\"so_23371626_23372137_0\">A conversion can add cv-qualifiers at levels other than the first in\n  multi-level pointers, subject to the following rules: ... [Note: if a\n  program could assign a pointer of type T** to a pointer of type const\n  T** (that is, if line #1 below were allowed), a program could\n  inadvertently modify a const object (as it is done on line #2).</p>\n</blockquote>\n<p>The example given is:</p>\n<pre><code>int main() {\n    const char c = \u2019c\u2019;\n    char* pc;\n    const char** pcc = &amp;pc; // #1: not allowed\n    *pcc = &amp;c;\n    *pc = \u2019C\u2019; // #2: modifies a const object\n}\n</code></pre>\n<p>This is explained for pointers to pointers, but the same applies for references to pointers for exactly the same reasons.</p>\n", "OwnerUserId": "316448", "LastEditorUserId": "316448", "LastEditDate": "2014-04-29T18:30:50.497", "Id": "23372137", "Score": "2", "CreationDate": "2014-04-29T18:08:56.763", "LastActivityDate": "2014-04-29T18:30:50.497"}, "23371826": {"ParentId": "23371626", "CommentCount": "0", "Body": "<p>You cannot.</p>\n<p>You are passing by pointer which can mean that after function execution there could be two different references to the same memory, one declared const, one declared non-const.</p>\n<p>If the non-const reference is used to change the memory then the const reference suddenly has its underlying memory would suddenly have become changed, which would be incorrect behavior.</p>\n", "OwnerUserId": "251414", "PostTypeId": "2", "Id": "23371826", "Score": "0", "CreationDate": "2014-04-29T17:52:00.540", "LastActivityDate": "2014-04-29T17:52:00.540"}, "23371815": {"ParentId": "23371626", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It's not doing it because, after expanding the typedefs, you have</p>\n<pre><code>int getSomething( DM const* &amp; dm )\n{\n  return dm-&gt;something;\n}\n...\nint main()\n{\n  DM* dm = new DM;\n  getSomething( dm );\n}\n</code></pre>\n<p>g++ is correctly NOT allowing this automatically, because you are asking for a non-const lvalue reference to a constant pointer.   You currently have a non-constant pointer.  It can't create a temporary, since the temporary can't bind to the non-const lvalue reference.</p>\n<p>Now, if you were to take the pointer by constant reference, it would work, since it would be allowed to bind to the temporary.  However, I would just pass the pointer directly, since there is no value in passing a pointer by constant reference.</p>\n<p>The reason why this isn't allow is because if it were, so would this (defeating the purpose of the <code>const</code> system)</p>\n<pre><code>const int i = 5;\nvoid foo( const int* &amp; p)\n{\n   p = &amp;i;\n}\n\nvoid bar()\n{\n   int * p; \n   foo(p); // Normally not legal\n   *p = 6; // And this is why\n}\n</code></pre>\n<p>Now, all that being said, any time I see a reference to a pointer my first question to the developer is why they needed to do that.  Occasionally, it's because you need to have an output parameter, but it's not something I would expect to be widespread.</p>\n", "OwnerUserId": "862231", "LastEditorUserId": "862231", "LastEditDate": "2014-04-29T19:01:03.983", "Id": "23371815", "Score": "4", "CreationDate": "2014-04-29T17:51:17.817", "LastActivityDate": "2014-04-29T19:01:03.983"}, "23371626": {"CommentCount": "2", "ViewCount": "253", "CreationDate": "2014-04-29T17:40:22.907", "LastActivityDate": "2014-04-29T19:01:03.983", "Title": "How to enable implicit type conversion from non-const to const in C++?", "AcceptedAnswerId": "23371701", "PostTypeId": "1", "Id": "23371626", "Score": "2", "Body": "<p>Here's the essence of the code:</p>\n<pre><code>class DM\n{\npublic:\n    int something;\n    DM() : something(0) { }\n};\n\ntypedef DM * dm_t;\ntypedef dm_t &amp; dm_ref_t;\ntypedef const DM * dm_const_t;\ntypedef dm_const_t &amp; dm_cref_t;\n\nint getSomething( dm_cref_t dm ) // CALLING getSomething DOES NOT COMPILE\n{\n    return dm-&gt;something;\n}\n\nint getSomethingAgain( dm_const_t dm )\n{\n    return dm-&gt;something;\n}\n\nint getSomethingOnceMore( dm_ref_t dm )\n{\n    return dm-&gt;something;\n}\n\nint main()\n{\n    dm_t dm = new DM;\n    getSomething( dm ); // COMPILER ERROR COMES FROM HERE\n    getSomethingAgain( dm );\n    getSomethingOnceMore( dm );\n    return 0;\n}\n</code></pre>\n<p>And here's the compiler error:</p>\n<pre><code>implicit_cast.cpp: In function \u2018int main()\u2019:\nimplicit_cast.cpp:31: error: invalid initialization of reference of type \u2018const DM*&amp;\u2019 from expression of type \u2018DM*\u2019\nimplicit_cast.cpp:13: error: in passing argument 1 of \u2018int getSomething(const DM*&amp;)\u2019\n</code></pre>\n<p>That is, I have a non-const pointer that I'd like to pass into a function that accept a const pointer by reference. All is fine and dandy if the function would accept a non-const pointer by reference or a const pointer by value, but const pointer by reference does not accept non-const pointer. </p>\n<p>For safety reasons I'd like the function to take a const pointer; for some further development reasons I'd like it to be passed by reference. It should be completely safe to automatically cast from non-const to const. Why doesn't g++ performs the cast?</p>\n<p>I'd like to proceed further with a function defined like getSomething. How can I legalize these calls without adding explicit casts every time I call it?</p>\n", "Tags": "<c++><casting>", "OwnerUserId": "2540407", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_23371626_23372137_0": {"section_id": 17, "quality": 0.96875, "length": 31}}, "n3337": {"so_23371626_23372137_0": {"section_id": 14, "quality": 0.96875, "length": 31}}, "n4659": {"so_23371626_23372137_0": {"section_id": 18, "quality": 0.65625, "length": 21}}}});