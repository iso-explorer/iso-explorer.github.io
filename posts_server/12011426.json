post_cb({"12011426": {"ViewCount": "16074", "Body": "<blockquote>\n<p id=\"so_12011426_12011426_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/4986673/c11-rvalues-and-move-semantics-confusion\">C++11 rvalues and move semantics confusion</a> </br></p>\n</blockquote>\n<p>What I think is correct is</p>\n<pre><code>std::string GetLine()\n{\nstd::string str;\nstd::getline(std::cin, str);\nreturn std::move(str);\n}\n</code></pre>\n<p>But at this link <a href=\"http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html\" rel=\"nofollow noreferrer\">http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html</a>\n( check the header part Returning an explicit rvalue-reference from a function)</p>\n<p>which is #1 google search hit for move semantics shows a similar function signature as </p>\n<pre><code>int&amp;&amp; GetInt()\n{\nint x = 0;\n// code here\nreturn std::move(x);\n}\n</code></pre>\n<p>From what I read at other places &amp;&amp; means rvalue <strong>reference</strong> so in this case its returning a reference to an object that doesn't exist.  </p>\n<p>So which is it?</p>\n<p>(Yes I know moving an int has no real benifit but the question is whether to use the return type of std::string or std::string&amp;&amp; in the first function.  And if that is how it should be done for all types.)</p>\n", "AcceptedAnswerId": "12011561", "Title": "How to use move semantics with std::string during function return?", "CreationDate": "2012-08-17T18:42:25.833", "Id": "12011426", "CommentCount": "6", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:25:43.887", "LastEditorUserId": "-1", "LastActivityDate": "2012-08-17T21:53:58.020", "ClosedDate": "2012-08-17T21:29:45.123", "Score": "14", "OwnerUserId": "459919", "Tags": "<c++><c++11><move-semantics>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_12011426_12011561_2": {"length": 20, "quality": 0.6896551724137931, "section_id": 481}, "so_12011426_12011561_0": {"length": 35, "quality": 1.0, "section_id": 480}}, "n3337": {"so_12011426_12011561_2": {"length": 29, "quality": 1.0, "section_id": 472}, "so_12011426_12011561_0": {"length": 35, "quality": 1.0, "section_id": 471}}, "n4659": {"so_12011426_12011561_2": {"length": 16, "quality": 0.5517241379310345, "section_id": 504}, "so_12011426_12011561_0": {"length": 31, "quality": 0.8857142857142857, "section_id": 502}}}, "12011561": {"Id": "12011561", "PostTypeId": "2", "Body": "<p>You are absolutely correct that the <code>int&amp;&amp; GetInt()</code> example is wrong, and is returning a reference to an object that is destroyed. However, unless I missed it, the link you posted does not actually show any code returning a reference to a <em>local</em> variable. Instead I see a reference to a <em>global</em> variable being returned, which is okay.</p>\n<p>Here is how you use move semantics when returning:</p>\n<pre><code>std::string func()\n{\n    std::string rv;\n    /* ... */\n    return rv;\n}\n</code></pre>\n<p>You generally should not use <code>std::move()</code> when returning an object. The reason for this is that moving is already implicitly allowed anytime RVO could occur, and using <code>std::move()</code> will suppress RVO. So using <code>std::move()</code> will never be better and will often be worse than just returning normally.</p>\n<hr>\n<p>Again, using <code>std::move()</code> can be worse than simply naming the variable to be returned because it suppresses the return value optimization. The return value optimization allows for an object to be returned to the caller without needing to copy that object</p>\n<blockquote>\n<p id=\"so_12011426_12011561_0\">in a <code>return</code> statement in a function with a class return type, when\n  the expression is the name of a non-volatile automatic object (other\n  than a function or catch-clause parameter) with the same\n  cv-unqualified type as the function return type, the copy/move\n  operation can be omitted by constructing the automatic object directly\n  into the function\u2019s return value</p>\n<p id=\"so_12011426_12011561_1\"><em>\u2014 [class.copy] 12.8/31</em></p>\n</blockquote>\n<p>But using <code>std::move()</code> prevents the return expression from being <em>the name</em> of the object you're returning. Instead the expression is more complicated and the language is no longer allowed to give it special handling.</p>\n<p>The reason just naming the object is not worse than using <code>std::move()</code> is because there's another rule that says an expression can already be treated as an rvalue without needing <code>std::move()</code>.</p>\n<blockquote>\n<p id=\"so_12011426_12011561_2\">When the criteria for elision of a copy operation are met or would be\n  met save for the fact that the source object is a function parameter,\n  and the object to be copied is designated by an lvalue, overload\n  resolution to select the constructor for the copy is first performed\n  as if the object were designated by an rvalue.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "365496", "LastActivityDate": "2012-08-17T21:53:58.020", "Score": "22", "CreationDate": "2012-08-17T18:51:32.943", "ParentId": "12011426", "CommentCount": "5", "LastEditDate": "2012-08-17T21:53:58.020", "OwnerUserId": "365496"}, "12011588": {"Id": "12011588", "PostTypeId": "2", "Body": "<p>No need to say <code>return std::move(str);</code> if <code>str</code> is a local variable: If the variable satisfies the criteria for return-value optimisation, then in a <code>return</code> statement the variable will bind to an rvalue reference.</p>\n<p>Also, beware that you should probably not return a reference to a local variable, neither lvalue nor rvalue reference.</p>\n<p>All told, you should have:</p>\n<pre><code>int foo() { int x; /*...*/ return x; }\n\nstd::string bar() { std::string str; /*...*/ return str; }\n</code></pre>\n", "LastActivityDate": "2012-08-17T18:53:27.683", "Score": "4", "CreationDate": "2012-08-17T18:53:27.683", "ParentId": "12011426", "CommentCount": "5", "OwnerUserId": "596781"}, "12011443": {"Id": "12011443", "PostTypeId": "2", "Body": "<p>Answering the question, sort of: return a <code>string</code>. Don't <code>move</code> anything, but rather use (rely on) RVO:</p>\n<pre><code>std::string func()\n{\n    std::string rv;\n    /* ... */\n    return rv;\n}\n</code></pre>\n<p>This is how it generally should be done. You can't return an (r-value or not) reference to a temporary.</p>\n", "LastEditorUserId": "463074", "LastActivityDate": "2012-08-17T18:49:51.867", "Score": "7", "CreationDate": "2012-08-17T18:43:43.457", "ParentId": "12011426", "CommentCount": "0", "LastEditDate": "2012-08-17T18:49:51.867", "OwnerUserId": "463074"}});