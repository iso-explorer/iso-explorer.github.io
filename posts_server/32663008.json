post_cb({"bq_ids": {"n4140": {"so_32663008_32663025_0": {"length": 27, "quality": 0.9, "section_id": 6107}}, "n3337": {"so_32663008_32663025_0": {"length": 27, "quality": 0.9, "section_id": 5873}}, "n4659": {"so_32663008_32663025_0": {"length": 27, "quality": 0.9, "section_id": 7604}}}, "32663008": {"ViewCount": "131", "Body": "<pre><code>class dummy\n{\n    union\n    {\n        templatefoo&lt;randomclassa&gt; * objecta;\n        templatefoo&lt;randomclassb&gt; * objectb;\n    };\n    ~A()\n    {\n        delete this-&gt;objecta;\n    }\n};\n</code></pre>\n<p>Assuming I have assigned objectb using new at some point, will calling delete on objecta result in undefined behavior? </p>\n", "Title": "Using delete on any member in a union of pointers", "CreationDate": "2015-09-19T00:54:50.343", "LastActivityDate": "2015-09-19T01:45:10.897", "CommentCount": "0", "PostTypeId": "1", "Id": "32663008", "Score": "2", "OwnerUserId": "3141117", "Tags": "<c++><unions>", "AnswerCount": "2"}, "32663025": {"Id": "32663025", "PostTypeId": "2", "Body": "<p>Yes, of course. Calling <code>delete</code> on <code>objecta</code> will result in the destructor for the first type being called, when the second type should be called.</p>\n<p>If you want something like this you should use a virtual base class. Nothing in the above is doing dynamic dispatch.</p>\n<hr>\n<p>Edit:</p>\n<p>Here's another way to look at it:</p>\n<p>Even in the most optimistic interpretation, you might hope this works out as well as if you had done</p>\n<pre><code>templatefoo&lt;B&gt; * objectb;\nobjectb = reinterpret_cast&lt;templatefoo&lt;B&gt;*&gt;(new templatefoo&lt;A&gt;());\ndelete objectb;\n</code></pre>\n<p>But even that is already UB, unless there is some quite unusual stuff going on in that template...</p>\n<hr>\n<p>Edit:</p>\n<p>Here's a specific point in the standard this disallows this:</p>\n<blockquote>\n<p id=\"so_32663008_32663025_0\">[C++11 standard, 5.3.5.3 [Delete]]<br>\n  In the first alternative (delete object), if the static type of the object to be deleted is different from its\n  dynamic type, the static type shall be a base class of the dynamic type of the object to be deleted and the\n  static type shall have a virtual destructor or the behavior is undefined.</br></p>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "3598119", "LastActivityDate": "2015-09-19T01:45:10.897", "Score": "2", "CreationDate": "2015-09-19T00:58:35.827", "ParentId": "32663008", "CommentCount": "3", "LastEditDate": "2015-09-19T01:45:10.897", "OwnerUserId": "3598119"}, "32663019": {"Id": "32663019", "PostTypeId": "2", "Body": "<p>Yes. Reading a <code>union</code> member other than the one that was last assigned to invokes undefined behavior.</p>\n<p>Even if that was not a problem, calling <code>delete</code> on a pointer of the \"wrong type\" invokes UB too.</p>\n<p>The easiest way around this problem would be to either template <code>dummy</code> itself if the type you want to use is known at compile time or just store two pointers, set the unused one to <code>nullptr</code> and then just <code>delete</code> both of them in the destructor.</p>\n", "LastEditorUserId": "3002139", "LastActivityDate": "2015-09-19T01:16:11.643", "Score": "3", "CreationDate": "2015-09-19T00:57:46.787", "ParentId": "32663008", "CommentCount": "3", "LastEditDate": "2015-09-19T01:16:11.643", "OwnerUserId": "3002139"}});