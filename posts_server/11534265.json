post_cb({"11551258": {"Id": "11551258", "PostTypeId": "2", "Body": "<p>GCC's warning may have been a bit confusing, but its intention is certainly right. The type of the lambda is unnamed, and it is unique <em>in the whole program</em>. On the other side if your class isn't put in an unnamed namespace (which it, given your description, I suppose is not), your class is the same type in every translation unit that you include it into. Since the same class should have the same members, and not different members in different translation units, this is a violation (and leads to undefined behavior).</p>\n<p>What's at least as bad is that <code>L</code> is <code>extern</code>, so that you will get \"multiple definitions of L\" linker errors once you include the header into multiple translation units.</p>\n", "LastActivityDate": "2012-07-18T22:22:28.277", "CommentCount": "1", "CreationDate": "2012-07-18T22:22:28.277", "ParentId": "11534265", "Score": "1", "OwnerUserId": "34509"}, "11534408": {"Id": "11534408", "PostTypeId": "2", "Body": "<p>Unless I missed something, none of these should be in an anonyous namespace, though atleast both GCC and MSVC seem to put them there.</p>\n<p><code>\u00a75.1.2 [expr.prim.lambda] p3</code></p>\n<blockquote>\n<p id=\"so_11534265_11534408_0\">[...] The closure type is declared in the smallest block scope, class scope, or namespace\n  scope that contains the corresponding <em>lambda-expression</em>. [...]</p>\n</blockquote>\n<p>Atleast Clang seems to get it right, the closure type resides where it should be.</p>\n<p>(You can test in which namespace a lambda type resides by simply containing the lambda in some kind of warning / error producing code. The compiler should spit out its type along with the warning / error.)</p>\n", "LastActivityDate": "2012-07-18T04:41:20.520", "CommentCount": "6", "CreationDate": "2012-07-18T04:41:20.520", "ParentId": "11534265", "Score": "4", "OwnerUserId": "500104"}, "11534265": {"ViewCount": "1066", "Body": "<p>A recent build of GCC 4.8 gives the following code, when in a header file:</p>\n<pre><code>auto L = [](){};\n\nstruct S\n{\n    decltype(L) m;\n};\n</code></pre>\n<p>the following warning:</p>\n<pre><code>test.hpp:3:8: warning: 'S' has a field 'S::m' whose type uses the anonymous namespace [enabled by default]\n struct S\n        ^\n</code></pre>\n<p>Why does the compiler consider the type of the lambda to use the anonymous namespace? I made the lambda global, I didn't use an anonymous namespace anywhere.</p>\n<p><strong>UPDATE</strong>: The compiles gives the same warning even if I put the lambda in an explicit namespace, like so:</p>\n<pre><code>namespace N\n{\n    auto L = [](){};\n}\n\nstruct S\n{\n    decltype(N::L) m;\n};\n</code></pre>\n<p><strong>UPDATE 2</strong>: In fact, it seems even class scope lambdas have the same problem:</p>\n<pre><code>class N\n{\n    static constexpr auto L = [](){};\n};\n\nstruct S\n{\n    decltype(N::L) m;\n};\n</code></pre>\n", "AcceptedAnswerId": "11551258", "Title": "Do non-local C++11 lambdas live in anonymous namespaces?", "CreationDate": "2012-07-18T04:23:09.263", "Id": "11534265", "CommentCount": "8", "LastEditDate": "2012-07-18T04:30:34.357", "PostTypeId": "1", "LastEditorUserId": "141719", "LastActivityDate": "2012-07-18T22:22:28.277", "Score": "6", "OwnerUserId": "141719", "Tags": "<c++><lambda><namespaces><c++11><global-variables>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_11534265_11534408_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 5962}, "so_11534265_11534379_0": {"length": 33, "quality": 0.868421052631579, "section_id": 5962}}, "n3337": {"so_11534265_11534408_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 5731}, "so_11534265_11534379_0": {"length": 33, "quality": 0.868421052631579, "section_id": 5731}}, "n4659": {"so_11534265_11534408_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 7452}}}, "11534379": {"Id": "11534379", "PostTypeId": "2", "Body": "<p>\u00a75.1.2/3: </p>\n<blockquote>\n<p id=\"so_11534265_11534379_0\">The type of the lambda-expression (which is also the type of the closure object) is a unique, unnamed nonunion\n  class type \u2014 called the closure type \u2014 whose properties are described below. This class type is not\n  an aggregate (8.5.1). The closure type is declared in the smallest block scope, class scope, or namespace\n  scope that contains the corresponding lambda-expression.</p>\n</blockquote>\n<p>So, unless you're defining the lambda expression in code inside an anonymous namespace, the lambda's type should not be contained in an anonymous namespace either.</p>\n", "LastActivityDate": "2012-07-18T04:37:49.453", "CommentCount": "1", "CreationDate": "2012-07-18T04:37:49.453", "ParentId": "11534265", "Score": "7", "OwnerUserId": "179910"}, "11534421": {"Id": "11534421", "PostTypeId": "2", "Body": "<p>I've not read the spec in this case, just thinking..., but, can you make a test?</p>\n<p>Your lambda is too trivial and may turn to become a stateless lambda. A stateless lambda like yours can turn to be a simple C function by the compiler. There may be some rule to put this functions in the anonymous namespace so that they exist across a single compilation unit only.</p>\n<p>So I suggest you to make it non-stateless, like refering to a variable, and see if it still lives in this anonymous namespace.</p>\n", "LastEditorUserId": "1000282", "LastActivityDate": "2012-07-18T04:50:44.880", "Score": "0", "CreationDate": "2012-07-18T04:43:31.987", "ParentId": "11534265", "CommentCount": "1", "OwnerUserId": "1000282", "LastEditDate": "2012-07-18T04:50:44.880"}});