post_cb({"30089244": {"ParentId": "30089131", "PostTypeId": "2", "CommentCount": "2", "Body": "<ol>\n<li><code>constexpr</code> functions are made so that they can be called both at compile-time and run-time.</li>\n<li>Code with a <code>constexpr</code> function is well-formed if you can omit <code>constexpr</code> and get a proper plain function. In other words it <em>must</em> compile as a run-time function.</li>\n<li>If the body of <code>constexpr</code> function cannot be calculated at compile-time, it's still compiled, but you cannot use it in a compile-time context such as template arguments.</li>\n<li>If <code>constexpr</code> method is called on <code>constexpr</code> object, <code>this</code> is considered constexpr.</li>\n</ol>\n<p>In case of <code>one</code> it is ill-formed, because when it's compiled to be run at run-time, <code>_data[a]</code> is considered to be a run-time expression, because <code>a</code> is not a constant expression, even though <code>this</code> and <code>this-&gt;_data</code> are.</p>\n<p>In case of <code>two</code> it compiles fine, because it works fine at runtime, and at compile-time <code>this</code> is <code>constexpr</code> as much as <code>a</code>, so that <code>this-&gt;_data[a]</code> is <code>constexpr</code> and everything works fine.</p>\n", "OwnerUserId": "1872046", "LastEditorUserId": "1872046", "LastEditDate": "2015-05-07T00:01:48.907", "Id": "30089244", "Score": "1", "CreationDate": "2015-05-06T23:13:52.760", "LastActivityDate": "2015-05-07T00:01:48.907"}, "30089692": {"ParentId": "30089131", "CommentCount": "2", "Body": "<p>If you consider this statement in [dcl.constexpr]/7:</p>\n<blockquote>\n<p id=\"so_30089131_30089692_0\">A call to a <code>constexpr</code> function produces <strong>the same result</strong> as a call to an equivalent non-<code>constexpr</code> function <strong>in all respects</strong> except that a call to a <code>constexpr</code> function can appear in a constant expression.</p>\n</blockquote>\n<p>Consider the non-<code>constexpr</code> equivalent function <code>A::one()</code>. <code>_data[a]</code> cannot be used in a constant expression (as a non-type template argument) because it would involve the evaluation of <code>this</code>, from [expr.const]:</p>\n<blockquote>\n<p id=\"so_30089131_30089692_1\">A conditional-expression e is a core constant expression unless the evaluation of e, following the rules of the\n  abstract machine (1.9), would evaluate one of the following expressions:<br>\n  (2.1) \u2014 <code>this</code> (5.1.1), except in a <code>constexpr</code> function or a <code>constexpr</code> constructor that is being evaluated as\n  part of e;</br></p>\n</blockquote>\n<p>Since the non-<code>constexpr</code> equivalent is ill-formed, it is reasonable that the <code>constexpr</code> function give the same result.</p>\n<p>Ont the other hand, <code>two()</code> is a well-formed member function regardless of <code>constexpr</code> and your use of <code>ex.two(3)</code> is valid as a constant expression - that's why it compiles. </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "30089692", "Score": "6", "CreationDate": "2015-05-07T00:00:11.613", "LastActivityDate": "2015-05-07T00:00:11.613"}, "bq_ids": {"n4140": {"so_30089131_30089692_1": {"section_id": 6185, "quality": 0.9130434782608695, "length": 21}, "so_30089131_30089692_0": {"section_id": 5423, "quality": 1.0, "length": 20}}, "n3337": {"so_30089131_30089692_0": {"section_id": 5218, "quality": 1.0, "length": 20}}, "n4659": {"so_30089131_30089692_1": {"section_id": 7687, "quality": 0.8260869565217391, "length": 19}, "so_30089131_30089692_0": {"section_id": 6845, "quality": 1.0, "length": 20}}}, "30089131": {"CommentCount": "7", "AcceptedAnswerId": "30089692", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2015-05-06T23:02:42.243", "LastActivityDate": "2015-05-07T01:23:45.123", "LastEditDate": "2015-05-07T01:23:45.123", "ViewCount": "407", "FavoriteCount": "1", "Title": "C++ constexpr auto member function. Clang issue?", "Id": "30089131", "Score": "3", "Body": "<pre><code> #include &lt;utility&gt;\n\n struct A {\n     constexpr auto one(int a) {\n         return std::integral_constant&lt;int, _data[a]&gt;{};\n     }\n     constexpr int  two(int a) const {\n         return _data[a];\n     }\n\n     int _data[10];\n };\n\n int main() {\n     constexpr auto ex = A{{1,2,3,4,5,6,7,8,9,10}};\n\n     std::integral_constant&lt;int, ex.two(3)&gt; b{};\n }\n</code></pre>\n<p>The code above will not compile in trunk Clang.  The error is in the <code>one()</code> member function, and says: </p>\n<pre><code>cc.cpp:57:44: note: implicit use of 'this' pointer is only allowed \n  within the evaluation of a call to a 'constexpr' member function.\n</code></pre>\n<p>Obviously, the function is marked <code>constexpr</code>, and if you comment out the <code>one()</code> member, everything compiles fine, so we are clearly able to create the <code>integral_constant</code> from the <code>ex</code>, but not directly from the <code>struct</code>?  It seems like, when I need the <code>auto</code> return type deduction, it fails and claims the function is not <code>constexpr</code>?</p>\n<p>Is this expected?  I feel like it should not be a problem, and I would be surprised if this was expected behavior.</p>\n", "Tags": "<c++><c++11><auto><c++14><constexpr>", "OwnerUserId": "2172459", "AnswerCount": "2"}});