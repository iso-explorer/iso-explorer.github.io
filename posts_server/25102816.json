post_cb({"bq_ids": {"n4140": {"so_25102816_25103554_11": {"length": 4, "quality": 1.0, "section_id": 6018}, "so_25102816_25103554_8": {"length": 14, "quality": 1.0, "section_id": 6015}, "so_25102816_25103008_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 6015}, "so_25102816_25103554_3": {"length": 25, "quality": 1.0, "section_id": 6018}, "so_25102816_25103554_12": {"length": 17, "quality": 0.9444444444444444, "section_id": 6019}, "so_25102816_25103008_1": {"length": 48, "quality": 0.9795918367346939, "section_id": 6015}, "so_25102816_25103554_6": {"length": 14, "quality": 1.0, "section_id": 6015}, "so_25102816_25103554_9": {"length": 11, "quality": 0.55, "section_id": 6014}, "so_25102816_25103554_2": {"length": 25, "quality": 1.0, "section_id": 6018}, "so_25102816_25103554_1": {"length": 32, "quality": 1.0, "section_id": 6018}}, "n3337": {"so_25102816_25103554_11": {"length": 4, "quality": 1.0, "section_id": 5786}, "so_25102816_25103554_8": {"length": 14, "quality": 1.0, "section_id": 5783}, "so_25102816_25103008_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 5783}, "so_25102816_25103554_3": {"length": 25, "quality": 1.0, "section_id": 5786}, "so_25102816_25103554_12": {"length": 16, "quality": 0.8888888888888888, "section_id": 5787}, "so_25102816_25103008_1": {"length": 48, "quality": 0.9795918367346939, "section_id": 5783}, "so_25102816_25103554_6": {"length": 14, "quality": 1.0, "section_id": 5783}, "so_25102816_25103554_9": {"length": 11, "quality": 0.55, "section_id": 5782}, "so_25102816_25103554_2": {"length": 25, "quality": 1.0, "section_id": 5786}, "so_25102816_25103554_1": {"length": 32, "quality": 1.0, "section_id": 5786}}, "n4659": {"so_25102816_25103554_11": {"length": 4, "quality": 1.0, "section_id": 7517}, "so_25102816_25103554_8": {"length": 14, "quality": 1.0, "section_id": 7514}, "so_25102816_25103008_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 7514}, "so_25102816_25103554_3": {"length": 25, "quality": 1.0, "section_id": 7517}, "so_25102816_25103554_12": {"length": 17, "quality": 0.9444444444444444, "section_id": 7518}, "so_25102816_25103008_1": {"length": 41, "quality": 0.8367346938775511, "section_id": 7514}, "so_25102816_25103554_6": {"length": 14, "quality": 1.0, "section_id": 7514}, "so_25102816_25103554_9": {"length": 11, "quality": 0.55, "section_id": 7513}, "so_25102816_25103554_2": {"length": 25, "quality": 1.0, "section_id": 7517}, "so_25102816_25103554_1": {"length": 32, "quality": 1.0, "section_id": 7517}}}, "25103554": {"Id": "25103554", "PostTypeId": "2", "Body": "<p>Let's start from the beginning and take a look at every case:</p>\n<pre><code>class A { virtual void f() {} };\nclass B { virtual void g() {} };\nclass D : public virtual A, private B { };\n\nvoid g() {\n  D d;\n  B* bp = (B*)&amp;d;\n\n  [continue...]\n</code></pre>\n<p>C++ casts (exception for <code>reinterpret_cast</code> which just casts raw pointer value with no adjustment or arithmetic at all) aren't allowed to \"ignore\" inheritance access levels (<a href=\"https://stackoverflow.com/a/3674955/1938163\">https://stackoverflow.com/a/3674955/1938163</a>), C-style casts can.</p>\n<p>With the above code <code>bp</code> is a pointer to a valid object, but the access level is bypassed completely. Could this be a problem?</p>\n<p>The answer is yes, take the following as an example:</p>\n<pre><code>class A { virtual void f() {} };\nclass B { virtual void g() {}\npublic:\n    ~B() {cout &lt;&lt; \"B's destructor\";} // You can destroy B objects but NOT D objects from B* pointers\n};\nclass D : public virtual A, private B {\n    ~D() {cout &lt;&lt; \"D's destructor\";}\n};\n\nvoid g() {\n    D *d = new D();\n\n    B* bp = (B*)d; // Bypass access permissions\n\n    delete bp; // This shouldn't happen! D's destructor will NOT be called! Undefined Behavior!\n</code></pre>\n<p>Compiling with <code>-Wold-style-cast -Werror</code> avoids this problem (and several others as well: <a href=\"https://stackoverflow.com/a/12765440/1938163\">https://stackoverflow.com/a/12765440/1938163</a>)</p>\n<p>Continuing with your example we have</p>\n<pre><code>A* ap = &amp;d;\n</code></pre>\n<p>and this is a perfectly legit upcast. What is not legit is the following cast:</p>\n<pre><code>D&amp; dr = dynamic_cast&lt;D&amp;&gt;(*bp);\n</code></pre>\n<p>Citing from the standard and substituting some words for readability reasons: </p>\n<blockquote>\n<p id=\"so_25102816_25103554_0\">(N3690 - \u00a75.2.7 - 8)</p>\n<p id=\"so_25102816_25103554_1\">If D is the class type to which D&amp; points or refers, the run-time check logically executes as follows:\n  \u2014 If, in the most derived object pointed (referred) to by bp, bp points (refers) to a <strong>public base class</strong>\n  subobject of a D object, and if only one object of type D is derived from the subobject pointed (referred)\n  to by bp the result points (refers) to that D object.</p>\n</blockquote>\n<p>thus the access permissions are wrong and the cast fails. It is <strong>NOT</strong> ill-formed, just fails (read later for the difference).</p>\n<p>Had you asked for a pointer you would have got a <code>NULL</code> one, but since a reference needs to be bound to an object the above throws an exception (it's the only sensible thing to do here).</p>\n<p>The cast that follows also isn't ill-formed but just plain wrong. Usually you can't cast from a base pointer to another base (<a href=\"https://stackoverflow.com/a/7426562/1938163\">https://stackoverflow.com/a/7426562/1938163</a>) but since the base\nclasses involved here are polymorphic, the following should be allowed and valid:</p>\n<pre><code>ap = dynamic_cast&lt;A*&gt;(bp);\n</code></pre>\n<blockquote>\n<p id=\"so_25102816_25103554_2\">... if bp points (refers) to a <strong>public base class</strong> subobject of the most derived object, and the\n  type of the most derived object has a base class, of type A, that is unambiguous and public, the result\n  points (refers) to the A subobject of the most derived object.</p>\n</blockquote>\n<p>but again: the permissions are getting things wrong and the cast is failing (<strong>NOT</strong> ill-formed, again just failing).</p>\n<p>The cast that follows is already an invalid cast since <code>ap</code> is <code>NULL</code></p>\n<pre><code>bp = dynamic_cast&lt;B*&gt;(ap);\n</code></pre>\n<p>but if <code>ap</code> weren't <code>NULL</code>, the cast would have failed anyway for the same passage cited above:</p>\n<blockquote>\n<p id=\"so_25102816_25103554_3\">... if ap points (refers) to a public base class subobject of the most derived object, and the\n  type of the most derived object has a base class, of type B, that is <strong>unambiguous and public</strong>, the result\n  points (refers) to the B subobject of the most derived object.</p>\n</blockquote>\n<p>The only cast that succeeds is the</p>\n<pre><code>ap = dynamic_cast&lt;A*&gt;(&amp;d);\n</code></pre>\n<p>where a <code>D</code> object pointer is casted to a public base class.</p>\n<p>The last cast is finally <strong>ill-formed</strong> </p>\n<pre><code>bp = dynamic_cast&lt;B*&gt;(&amp;d);\n</code></pre>\n<p>since according to the standard</p>\n<blockquote>\n<p id=\"so_25102816_25103554_4\">(N3690 - \u00a75.2.7 - 5)</p>\n<p id=\"so_25102816_25103554_5\">(dynamic_cast)</p>\n<p id=\"so_25102816_25103554_6\">If B* is \u201cpointer to cv1 B\u201d and &amp;d has type \u201cpointer to cv2 D\u201d such that B is a base class of D, the result is a pointer to the unique B subobject of the D object pointed to by &amp;d.</p>\n<p id=\"so_25102816_25103554_7\">...</p>\n<p id=\"so_25102816_25103554_8\">In both the pointer and reference cases, <strong>the program is ill-formed</strong> if cv2 has greater cv-qualification than cv1 or <strong>if B is an inaccessible or ambiguous base class of D</strong>.</p>\n</blockquote>\n<p>Grand-total: 3 failed casts (one with exception throwing), one succeeded and one ill-formed.</p>\n<p>Finally: failed casts are casts which could not be accomplished but they can be handled according to the standard rules:</p>\n<blockquote>\n<p id=\"so_25102816_25103554_9\">If the value of v is a null pointer value in the pointer case, the result is the null pointer value of type T.\n  If C is the class type to which T points or refers, the run-time check logically executes as follows:</p>\n<p id=\"so_25102816_25103554_10\">...(same rules as above)</p>\n<p id=\"so_25102816_25103554_11\">\u2014 Otherwise, the run-time check fails.</p>\n<p id=\"so_25102816_25103554_12\"><strong>The value of a failed cast to pointer type is the null pointer value of the required result type. A failed\n  cast to reference type throws an exception</strong></p>\n</blockquote>\n<p>Unless instructed otherwise (no diagnostics required) a compiler implementation is usually supposed to emit an error or a warning for an ill-formed program, in the casts you're interested in:</p>\n<pre><code>B* bp = (B*)&amp;d;\nA* ap = &amp;d;\nD&amp; dr = dynamic_cast&lt;D&amp;&gt;(*bp); // This is a runtime error\nap = dynamic_cast&lt;A*&gt;(bp); // this is a runtime error\nbp = dynamic_cast&lt;B*&gt;(ap); // this is a runtime error\nap = dynamic_cast&lt;A*&gt;(&amp;d); // succeeds\nbp = dynamic_cast&lt;B*&gt;(&amp;d); // This is ill-formed and the compiler should warn about it\n</code></pre>\n<p>If I got something wrong (very likely) please write it down in the comments below and I'll fix my post immediately. Thanks!</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-08-03T11:19:27.017", "Score": "1", "CreationDate": "2014-08-03T09:57:41.153", "ParentId": "25102816", "CommentCount": "3", "OwnerUserId": "1938163", "LastEditDate": "2017-05-23T12:20:50.120"}, "25103008": {"Id": "25103008", "PostTypeId": "2", "Body": "<p>Despite the name, when you use <code>dynamic_cast</code> to do an upcast (derived-&gt;base), the cast is done at compile time and behaves the same way as a <code>static_cast</code> or an implicit conversion - if the base is ambiguous or inaccessible the program is ill-formed, meaning that the compiler must produce a diagnostic. \u00a75.2.7 [expr.dynamic.cast]/p5:</p>\n<blockquote>\n<p id=\"so_25102816_25103008_0\">[For the expression <code>dynamic_cast&lt;T&gt;(v)</code>:]</p>\n<p id=\"so_25102816_25103008_1\">If <code>T</code> is \"pointer to <code>cv1 B</code>\" and <code>v</code> has type \"pointer to <code>cv2 D</code>\"\n  such that <code>B</code> is a base class of <code>D</code>, the result is a pointer to the\n  unique <code>B</code> subobject of the <code>D</code> object pointed to by v. Similarly, if\n  <code>T</code> is \"reference to <code>cv1 B</code>\" and <code>v</code> has type <code>cv2 D</code> such that <code>B</code>\n  is a base class of <code>D</code>, the result is the unique <code>B</code> subobject of the\n  <code>D</code> object referred to by <code>v</code>. <sup>67</sup> The result is an lvalue\n  if <code>T</code> is an lvalue reference, or an xvalue if <code>T</code> is an rvalue\n  reference. In both the pointer and reference cases, the program is\n  ill-formed if <code>cv2</code> has greater cv-qualification than <code>cv1</code> or if <code>B</code>\n  is an inaccessible or ambiguous base class of <code>D</code>.</p>\n<p id=\"so_25102816_25103008_2\"><sup>67</sup> The most derived object (1.8) pointed or referred to by\n  v can contain other B objects as base classes, but these are ignored.</p>\n</blockquote>\n<p>In other cases (casting down or sideways), the checks are performed at run-time. If it fails, then the cast result is a null pointer for pointer casts, and a <code>std::bad_cast</code> exception for reference casts.</p>\n", "LastActivityDate": "2014-08-03T08:41:23.000", "CommentCount": "0", "CreationDate": "2014-08-03T08:41:23.000", "ParentId": "25102816", "Score": "4", "OwnerUserId": "2756719"}, "25102816": {"ViewCount": "82", "Body": "<p>could you possibly explain what is difference between <code>ill-formed cast</code> and <code>failed cast</code>. \nFor instance:</p>\n<pre><code>class A { virtual void f(); };\nclass B { virtual void g(); };\nclass D : public virtual A, private B { };\n\nvoid g() {\n    D d;\n    B* bp = (B*)&amp;d;    // cast needed to break protection\n    A* ap = &amp;d;        // public derivation, no cast needed\n    D&amp; dr = dynamic_cast&lt;D&amp;&gt;(*bp);    // fails\n    ap = dynamic_cast&lt;A*&gt;(bp);        // fails\n    bp = dynamic_cast&lt;B*&gt;(ap);        // fails\n    ap = dynamic_cast&lt;A*&gt;(&amp;d);        // succeeds\n    bp = dynamic_cast&lt;B*&gt;(&amp;d);        // ill-formed (not a run-time check)\n}\n</code></pre>\n", "Title": "Failed and ill-formed casts", "CreationDate": "2014-08-03T08:07:49.353", "LastActivityDate": "2014-08-03T11:19:27.017", "CommentCount": "3", "PostTypeId": "1", "Id": "25102816", "Score": "0", "OwnerUserId": "2786156", "Tags": "<c++><casting>", "AnswerCount": "2"}});