post_cb({"17313717": {"ParentId": "17313579", "CommentCount": "1", "Body": "<p>One can cast to the unsigned variant first. This provides well defined behavior. If instead, the code looks like this:</p>\n<pre><code>unsigned long abs(long input)\n{\n    if (input &gt;= 0)\n    {\n        // input is positive\n        return static_cast&lt;unsigned long&gt;(input);\n    }\n    else\n    {\n        return -static_cast&lt;unsigned long&gt;(input); // read on...\n    }\n}\n</code></pre>\n<p>we invoke two well defined operations. Converting the signed integer to the unsigned one is well defined by N3485 4.7 [conv.integral]/2:</p>\n<blockquote>\n<p id=\"so_17313579_17313717_0\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2^n where n is the number of bits used to represent the unsigned type). [ Note: In a two\u2019s complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation). \u2014 end note ]</p>\n</blockquote>\n<p>This basically says that when making the specific conversion of going from signed to unsigned, one can assume unsigned-style wraparound.</p>\n<p>The negation of the unsigned integer is well defined by 5.3.1 [expr.unary.op]/8:</p>\n<blockquote>\n<p id=\"so_17313579_17313717_1\">The negative of an unsigned quantity is computed by subtracting its value from 2^n , where n is the number of bits in the promoted operand.</p>\n</blockquote>\n<p>These two requirements effectively force implementations to operate like a 2s complement machine would, even if the underlying machine is a 1s complement or signed magnitude machine.</p>\n", "OwnerUserId": "82320", "PostTypeId": "2", "Id": "17313717", "Score": "13", "CreationDate": "2013-06-26T07:11:03.320", "LastActivityDate": "2013-06-26T07:11:03.320"}, "17313579": {"CommentCount": "0", "AcceptedAnswerId": "17313717", "CreationDate": "2013-06-26T07:03:53.443", "LastActivityDate": "2013-06-26T07:15:38.197", "PostTypeId": "1", "ViewCount": "1748", "FavoriteCount": "2", "Title": "Is there a safe way to get the unsigned absolute value of a signed integer, without triggering overflow?", "Id": "17313579", "Score": "9", "Body": "<p>Consider a typical absolute value function (where for the sake of argument the integral type of maximum size is long):</p>\n<pre><code>unsigned long abs(long input);\n</code></pre>\n<p>A naive implementation of this might look something like:</p>\n<pre><code>unsigned long abs(long input)\n{\n    if (input &gt;= 0)\n    {\n        // input is positive\n        // We know this is safe, because the maximum positive signed\n        // integer is always less than the maximum positive unsigned one\n        return static_cast&lt;unsigned long&gt;(input);\n    }\n    else\n    {\n        return static_cast&lt;unsigned long&gt;(-input); // ut oh...\n    }\n}\n</code></pre>\n<p>This code triggers undefined behavior, because the negation of <code>input</code> may overflow, and triggering signed integer overflow is undefined behavior. For instance, on 2s complement machines, the absolute value of <code>std::numeric_limits&lt;long&gt;::min()</code> will be 1 greater than <code>std::numeric_limits&lt;long&gt;::max()</code>.</p>\n<p>What can a library author do to work around this problem?</p>\n", "Tags": "<c++><integer><integer-overflow>", "OwnerUserId": "82320", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_17313579_17313717_0": {"section_id": 31, "quality": 0.90625, "length": 29}, "so_17313579_17313717_1": {"section_id": 6071, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_17313579_17313717_0": {"section_id": 28, "quality": 0.90625, "length": 29}, "so_17313579_17313717_1": {"section_id": 5839, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_17313579_17313717_0": {"section_id": 31, "quality": 0.90625, "length": 29}, "so_17313579_17313717_1": {"section_id": 7567, "quality": 0.9230769230769231, "length": 12}}}});