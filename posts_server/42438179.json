post_cb({"42438378": {"ParentId": "42438179", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2017-02-24T12:13:54.770", "Score": "21", "LastEditorUserId": "3980929", "LastEditDate": "2017-02-24T13:18:40.373", "Id": "42438378", "OwnerUserId": "485343", "Body": "<p>Your code is perfectly valid.</p>\n<p>In this line</p>\n<pre><code>foo(A().ref());\n</code></pre>\n<p>The instance of a temporary <code>A</code> lives until the end of the statement (<code>;</code>).</p>\n<p>That's why it's safe to pass <code>A&amp;</code> returned from <code>ref()</code> to <code>foo</code> (as long as <code>foo</code> doesn't store it).</p>\n<p><code>ref()</code> by itself does not extend any lifetime, but it helps by returning an lvalue reference.</p>\n<p>What happens in the case of <code>foo(A());</code> ? Here the temporary is passed as an rvalue. And in C++ an rvalue does not bind to non-const lvalue references (even in C++11, an rvalue <em>reference</em> does not bind to non-const lvalue references).</p>\n<p>From this <a href=\"http://blogs.msdn.com/vcblog/archive/2009/02/03/rvalue-references-c-0x-features-in-vc10-part-2.aspx\" rel=\"noreferrer\">Visual C++ blog article about rvalue references</a>:</p>\n<blockquote>\n<p id=\"so_42438179_42438378_0\">... C++ doesn't want you to accidentally modify temporaries, but directly\n  calling a non-const member function on a modifiable rvalue is explicit, so\n  it's allowed ...</p>\n</blockquote>\n", "LastActivityDate": "2017-02-24T13:18:40.373"}, "42438390": {"ParentId": "42438179", "CommentCount": "2", "CreationDate": "2017-02-24T12:14:44.083", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "42438390", "Score": "7", "Body": "<p><code>A()</code> creates a temporary object of type <code>A</code>. The object exists until the end of the full expression in which it is created. The problem in your original code is <strong>not</strong> the lifetime of this temporary; it's that the function takes its argument as a non-const reference, and you're not allowed to pass a temporary object as a non-const reference. The simplest change is for <code>foo</code> to take it's argument by const reference, if that's appropriate to what the function does:</p>\n<pre><code>void foo(const A&amp;);\nint main() {\n    foo(A());\n}\n</code></pre>\n", "LastActivityDate": "2017-02-24T12:14:44.083"}, "42438179": {"CommentCount": "10", "ViewCount": "1635", "PostTypeId": "1", "LastEditorUserId": "3980929", "CreationDate": "2017-02-24T12:03:32.273", "LastActivityDate": "2017-02-24T16:12:14.743", "Title": "Is the lifetime of a reference extended?", "AcceptedAnswerId": "42438378", "LastEditDate": "2017-02-24T13:15:30.613", "Id": "42438179", "Score": "15", "Body": "<p>I'd like to pass a reference into a function. This code does not work, as I'd expect:</p>\n<pre><code>struct A {\n};\n\nvoid foo(A&amp; a) {\n    // do something with a\n}\n\nint main(int, char**) {\n    foo(A());\n}\n</code></pre>\n<p>I get the compile error</p>\n<blockquote>\n<p id=\"so_42438179_42438179_0\">invalid initialization of non-const reference of type <code>A&amp;</code> from an rvalue of type <code>A</code></p>\n</blockquote>\n<p>But when I just add the method <code>A&amp; ref()</code> to <code>A</code> like below and call it before passing it along, it seems I can use <code>a</code>. When debugging, the <code>A</code> object is destroyed after <code>foo()</code> is called:</p>\n<pre><code>struct A {\n    A&amp; ref() {\n        return *this;\n    }\n};\n\nvoid foo(A&amp; a) {\n    // do something with a\n}\n\nint main(int, char**) {\n    foo(A().ref());\n}\n</code></pre>\n<p>Is this valid code according to the standard? Does calling <code>ref()</code> magically extend the lifetime of the object until <code>foo()</code> returns?</p>\n", "Tags": "<c++><reference><lifetime>", "OwnerUserId": "48181", "AnswerCount": "3"}, "42443294": {"ParentId": "42438179", "CommentCount": "3", "CreationDate": "2017-02-24T16:12:14.743", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "42443294", "Score": "5", "Body": "<p>There are several questions in this question. I'll attempt to address all of them:</p>\n<hr/>\n<p>First, you cannot pass a temporary (prvalue) of type <code>A</code> to a function taking <code>A&amp;</code> because non-const lvalue references cannot bind to rvalues. That's a language restriction. If you want to be able to pass a temporary, you either need to take a parameter of type <code>A&amp;&amp;</code> or of type <code>A const&amp;</code> - the latter since temporaries <em>can</em> bind to const lvalue references. </p>\n<hr/>\n<blockquote>\n<p id=\"so_42438179_42443294_0\">Is this valid code according to the standard? Does calling <code>ref()</code> magically extend the lifetime of the object until <code>foo()</code> returns?</p>\n</blockquote>\n<p>There is no lifetime extension going on in your program at all. From [class.temp]:</p>\n<blockquote>\n<p id=\"so_42438179_42443294_1\">There are three contexts in which temporaries are destroyed at a different point than the end of the full-expression. The first context is when a default constructor is called to initialize an element of an array with\n  no corresponding initializer (8.6). The second context is when a copy constructor is called to copy an element\n  of an array while the entire array is copied (5.1.5, 12.8). [...] The third context is when a reference is bound to a temporary.</p>\n</blockquote>\n<p>None of those contexts apply. We are never binding a reference to a temporary in this code. <code>ref()</code> binds <code>*this</code> to an <code>A&amp;</code>, but <code>*this</code> is not a temporary, and then that resulting reference is simply passed into <code>foo()</code>. </p>\n<p>Consider this variant of your program:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {\n    A&amp; ref() { return *this; }\n    ~A() { std::cout &lt;&lt; \"~A()\\n\"; }\n};\n\nint main() {\n    auto&amp; foo = A().ref();\n    std::cout &lt;&lt; \"----\\n\";\n}\n</code></pre>\n<p>which prints</p>\n<pre><code>~A()\n----\n</code></pre>\n<p>illustrating that there is no lifetime extension. </p>\n<hr/>\n<p>If instead of binding the result of <code>ref()</code> to a reference we instead bound a member:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A {\n    A&amp; ref() { return *this; }\n    int x;\n\n    ~A() { std::cout &lt;&lt; \"~A()\\n\"; }\n};\n\nint main() {\n    auto&amp;&amp; foo = A().x;\n    std::cout &lt;&lt; \"----\\n\";\n}\n</code></pre>\n<p>then we actually are binding a temporary to a reference and that third context applies - the lifetime of the complete object of the subobject to which the reference is bound is persisted for the lifetime of the reference. So this code prints:</p>\n<pre><code>----\n~A()\n</code></pre>\n", "LastActivityDate": "2017-02-24T16:12:14.743"}, "bq_ids": {"n4140": {"so_42438179_42438179_0": {"section_id": 5, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_42438179_42438179_0": {"section_id": 2, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_42438179_42438179_0": {"section_id": 5, "quality": 0.7142857142857143, "length": 5}, "so_42438179_42443294_1": {"section_id": 396, "quality": 0.7555555555555555, "length": 34}}}});