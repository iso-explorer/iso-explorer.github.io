post_cb({"28065956": {"ParentId": "28065783", "CommentCount": "1", "Body": "<p>Just drop the <code>template&lt;&gt;</code> bit, and put the definition of the static data members in a .cpp file:</p>\n<pre><code>LookUp&lt;uint8_t&gt; Lbp&lt;uint8_t&gt;::_lookup{};\nLookUp&lt;uint16_t&gt; Lbp&lt;uint16_t&gt;::_lookup{};\n</code></pre>\n<p><a href=\"http://ideone.com/aKkCbg\" rel=\"nofollow\">[Live example]</a></p>\n<p>... and, since the type of <code>_lookup</code> is a class, you can leave out the <code>{}</code> as well; its default constructor will be called anyway. This might please VC++ if you're using a version which does not support uniform initialisation.</p>\n<p>Why this is the proper way: <code>template&lt;&gt;</code> is used to introduce explicit specialisations. You're <em>not</em> introducing an explicit specialisation - you're defining a data member of an <em>already defined</em> explicit specialisation.</p>\n<p>This is covered by C++11 14.7.3/5:</p>\n<blockquote>\n<p id=\"so_28065783_28065956_0\">... Members of an explicitly specialized class template are\n  defined in the same manner as members of normal classes, and not using the <code>template&lt;&gt;</code> syntax. The same\n  is true when defining a member of an explicitly specialized member class. ...</p>\n</blockquote>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "28065956", "Score": "1", "CreationDate": "2015-01-21T11:19:40.093", "LastActivityDate": "2015-01-21T11:19:40.093"}, "28065783": {"CommentCount": "0", "AcceptedAnswerId": "28065956", "PostTypeId": "1", "LastEditorUserId": "581002", "CreationDate": "2015-01-21T11:12:12.193", "LastActivityDate": "2015-01-21T11:24:51.950", "LastEditDate": "2015-01-21T11:24:51.950", "ViewCount": "319", "FavoriteCount": "1", "Title": "Hot to initialize static const member in specialized template code?", "Id": "28065783", "Score": "1", "Body": "<p>I'm currently not able to set up my class members like I want to. My templated class is only specialized for sensible integer types (unsigned and \u201csmall\u201d). Each specialization needs a rather big look-up table that only depends on the type. So I thought it should definitely be static (and const) and created only once.</p>\n<p>As C++ doesn't have static constructors I learned that you can create a class that does the heavy stuff on initialization and have that as a static member.</p>\n<p>I reduced my code to these basics:</p>\n<pre><code>// Of this, I only want one instance per type,\n// because the table can get big.\ntemplate&lt;class T&gt;\nstruct LookUp\n{\n    static int const SIZE = 1 &lt;&lt; (sizeof(T) &lt;&lt; 3);\n    std::vector&lt;T&gt; table;\n\n    LookUp()\n        : table{ SIZE }\n    {\n        for (int i = 0; i &lt; SIZE; ++i)\n        {\n            // Dummy code\n            table[i] = i;\n        }\n    }\n};\n\n// \"Normal\" template class with common code for all types.\ntemplate&lt;class T&gt;\nclass LbpHelper\n{\n    typedef /*...*/ image;\n};\n\n// No functionality for the general case.\ntemplate&lt;class T&gt;\nclass Lbp\n{\n};\n\n// But for this (among others) we have something.\ntemplate&lt;&gt;\nclass Lbp&lt;uint8_t&gt; : public LbpHelper&lt;uint8_t&gt;\n{\n    typedef uint8_t value_type;\n    typedef Lbp::image image;\n\n    static LookUp&lt;value_type&gt; _lookup; // &lt;-- This is the mean one.\n\npublic:\n\n    // Stuff...\n};\n</code></pre>\n<p>Initializing static members seems to confuse a lot of users, especially when it comes to templates and specialization. I read quite some answers here but none of them solved my problem.</p>\n<p>I tried having something like</p>\n<pre><code>// The type of the class is the same as the type of the member class.\ntemplate&lt;&gt; LookUp&lt;uint8_t&gt; Lbp&lt;uint8_t&gt;::_lookup{};\ntemplate&lt;&gt; LookUp&lt;uint16_t&gt; Lbp&lt;uint16_t&gt;::_lookup{};\n</code></pre>\n<p>in the <em>header</em> or the <em>source</em> file or <em>both</em>. I tried with or without a <code>class T</code> in the angle brackets (and using <code>T</code> to the right of course), leaving out the <code>template&lt;&gt;</code> alltogether, having the <code>{}</code>s only in the source \u2014 I don't know what else. Nothing worked.</p>\n<p>Visual C++ either tells me that <code>_lookup</code> is <strong>not a member</strong> or that it is <strong>not an entity that can be specialized</strong> or this: <strong>error C2373: '_lookup' : redefinition; different type modifiers</strong>.</p>\n<p>Can someone please tell me what to put where so that it compiles?</p>\n", "Tags": "<c++><templates><c++11><initialization><static-members>", "OwnerUserId": "581002", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_28065783_28065956_0": {"section_id": 267, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_28065783_28065956_0": {"section_id": 258, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_28065783_28065956_0": {"section_id": 274, "quality": 0.9583333333333334, "length": 23}}}});