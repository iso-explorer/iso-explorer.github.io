post_cb({"310285": {"Id": "310285", "PostTypeId": "2", "Body": "<p>In \"The C++ Programming Language, 3rd edition,\" Stroustrup says this is to make code generation easier.</p>\n<p>Although it does make sense that the position of each field in the actual binary is based on which order that field was declared in the source code, so this allows somebody to maintain some sort of layout compatibility with C or even other languages/specs.</p>\n", "LastActivityDate": "2008-11-21T21:40:10.320", "CommentCount": "0", "CreationDate": "2008-11-21T21:40:10.320", "ParentId": "309922", "Score": "0", "OwnerUserId": "10593"}, "310030": {"Id": "310030", "PostTypeId": "2", "Body": "<p>I actually take advantage of this in a slightly unpleasant way: A code idiom I often use is a private member, with public accessor functions.</p>\n<p>I have a MACRO (shudder) which automatically generates these from a single line.</p>\n<p>example:</p>\n<pre><code>PROPERTY(int, MyVal);\n</code></pre>\n<p>...generates:...</p>\n<pre><code>private:\n  int fMyVal;\npublic:\n  void setMyVal(const int f) { fMyVal = f; };\n  int getMyVal() { return fMyVal; };\n</code></pre>\n<p>This works fine as long as you remember that the PROPERTY macro switches the current visiblity, which is not pleasant....</p>\n<p>eg:</p>\n<pre><code>protected:\n  int v1;\n  PROPERTY (int, v2) // fv2 is  private with public accessors\n  int v3;  // whoops. f3 is public,\n</code></pre>\n", "OwnerDisplayName": "Roddy", "LastActivityDate": "2008-11-21T20:13:28.373", "Score": "0", "CreationDate": "2008-11-21T20:13:28.373", "ParentId": "309922", "CommentCount": "2", "OwnerUserId": "1737"}, "309941": {"Body": "<p>My guess is that it is an outgrowth of the C philosophy, which assumes that you know what you are doing and gives you the maximum flexibility.  It is like allowing a single = in an if statement.</p>\n", "CreationDate": "2008-11-21T19:46:32.827", "ParentId": "309922", "CommentCount": "1", "LastEditDate": "2008-11-21T20:12:48.563", "PostTypeId": "2", "LastEditorDisplayName": "Dima", "LastActivityDate": "2008-11-21T20:12:48.563", "LastEditorUserId": "13313", "Id": "309941", "OwnerDisplayName": "Dima", "Score": "0", "OwnerUserId": "13313"}, "bq_ids": {"n4140": {"so_309922_309931_0": {"length": 41, "quality": 0.7592592592592593, "section_id": 5873}}, "n3337": {"so_309922_309931_0": {"length": 41, "quality": 0.7592592592592593, "section_id": 5644}}, "n4659": {"so_309922_309931_0": {"length": 41, "quality": 0.7592592592592593, "section_id": 7356}}}, "309922": {"ViewCount": "350", "Body": "<p>Is it only to allow logical grouping?</p>\n", "Title": "In C++ why is grouping not forced by the language on public, private and protected members of a class/struct?", "CreationDate": "2008-11-21T19:38:43.093", "LastActivityDate": "2008-11-21T21:40:10.307", "CommentCount": "0", "PostTypeId": "1", "OwnerDisplayName": "Aydya", "Id": "309922", "Score": "2", "OwnerUserId": "37952", "Tags": "<c++><private><public><protected><access-specifier>", "AnswerCount": "6"}, "309931": {"Body": "<p>I think you are correct. Leaving it unforced allows users to group things as they see fit for better code readability.</p>\n<p>The compiler may organize things differently in memory.</p>\n<p><b>edit</b>: as per the spec:</p>\n<blockquote id=\"so_309922_309931_0\">\u00a79.2 clause 12 (1998 and 2003 standards):<br><br>Nonstatic data members of a (non-union) class declared without an intervening access-specifier are allocated so that later members have higher addresses within a class object. The order of allocation of nonstatic data members separated by an access-specifier is unspecified (11.1). Implementation alignment requirements might cause two adjacent members not to be allocated immediately after each other; so might requirements for space for managing virtual functions (10.3) and virtual base classes (10.1).</br></br></blockquote>\n<p>I found this information in <a href=\"https://stackoverflow.com/questions/281045/do-classstruct-members-always-get-created-in-memory-in-the-order-they-were-decl\">a related SO question</a></p>\n", "CreationDate": "2008-11-21T19:41:57.127", "ParentId": "309922", "CommentCount": "4", "LastEditDate": "2017-05-23T11:49:30.547", "PostTypeId": "2", "LastEditorDisplayName": "eJames", "LastActivityDate": "2008-11-21T20:00:18.743", "LastEditorUserId": "-1", "Id": "309931", "OwnerDisplayName": "eJames", "Score": "1", "OwnerUserId": "33686"}, "310047": {"Id": "310047", "PostTypeId": "2", "Body": "<p>Why would you force it?  It doesn't help the compiler out at all, it doesn't make things objectively easier for a person to read.  Part of the C/C++ philosophy is that the language doesn't make arbitrary rules that don't enable some sort of feature/functionality.</p>\n<p>It does make things MUCH easier for code generation.  Many coding styles use access specifiers more than once per class - first defining all the local types, then all constructors, then all the methods, then all the instance variables, etc...</p>\n<p>C++ gives you enough rope to shoot yourself in the foot, but it's that same flexibility that lets you build elegant, maintainable, and well abstracted applications.</p>\n", "OwnerDisplayName": "Josh", "LastActivityDate": "2008-11-21T20:16:17.010", "Score": "3", "CreationDate": "2008-11-21T20:16:17.010", "ParentId": "309922", "CommentCount": "0", "OwnerUserId": "8701"}, "309927": {"Id": "309927", "PostTypeId": "2", "Body": "<p>It gives you flexibility. For example, you might have a bunch of constructors, some public, some protected, some private - wouldn't you want them all grouped together?</p>\n", "OwnerDisplayName": "Mark Ransom", "LastActivityDate": "2008-11-21T19:41:15.817", "Score": "4", "CreationDate": "2008-11-21T19:41:15.817", "ParentId": "309922", "CommentCount": "0", "OwnerUserId": "5987"}});