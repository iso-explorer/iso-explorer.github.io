post_cb({"10278043": {"Id": "10278043", "PostTypeId": "2", "Body": "<p>Its the best practice to de-allocate memory that's been allocated. You should keep in mind that Heap memory is limited and just allocating with out de-allocating while your program is running might run the heap space out for some other/or the same program(if its some kind of a daemon that is meant to run for a very long time) that needs heap. </p>\n<p>Of course memory will be reclaimed by the operating system at the end of the program's execution.</p>\n", "LastActivityDate": "2012-04-23T09:35:57.103", "CommentCount": "0", "CreationDate": "2012-04-23T09:35:57.103", "ParentId": "10277817", "Score": "0", "OwnerUserId": "751830"}, "10277840": {"Id": "10277840", "PostTypeId": "2", "Body": "<p>Yes, you should call <code>delete</code>, at least because it's best practice. If you have important logic in your destructor, that's one extra reason that you should call <code>delete</code>.</p>\n<p>Corrected: If the program depends on logic in the destructor, not calling <code>delete</code> explicitly results in undefined behavior. </p>\n", "LastEditorUserId": "673730", "LastActivityDate": "2012-04-23T10:57:28.140", "Score": "3", "CreationDate": "2012-04-23T09:23:01.087", "ParentId": "10277817", "CommentCount": "7", "OwnerUserId": "673730", "LastEditDate": "2012-04-23T10:57:28.140"}, "10279462": {"Id": "10279462", "PostTypeId": "2", "Body": "<p>Best practices:</p>\n<ol>\n<li>Do not use <code>new</code>, use automatic allocation</li>\n<li>When dynamic allocation is necessary, use RAII to ensure automatic cleanup</li>\n</ol>\n<p>You should never have to write <code>delete</code> in applicative code.</p>\n<p>Here, why are you calling <code>new</code> for <code>TGraph</code> ?</p>\n<pre><code>TGraph A(...);\n</code></pre>\n<p>works better: less worries!</p>\n", "LastActivityDate": "2012-04-23T11:14:19.177", "CommentCount": "0", "CreationDate": "2012-04-23T11:14:19.177", "ParentId": "10277817", "Score": "0", "OwnerUserId": "147192"}, "10278250": {"Id": "10278250", "PostTypeId": "2", "Body": "<p>I see you are using ROOT (CMS guy?). I think ROOT takes care of this and cleans up, doesn't it?</p>\n", "LastActivityDate": "2012-04-23T09:50:31.130", "CommentCount": "4", "CreationDate": "2012-04-23T09:50:31.130", "ParentId": "10277817", "Score": "0", "OwnerUserId": "1225744"}, "bq_ids": {"n4140": {"so_10277817_10277856_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 7192}}, "n3337": {"so_10277817_10277856_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 6936}}, "n4659": {"so_10277817_10277856_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 8701}}}, "10277856": {"Id": "10277856", "PostTypeId": "2", "Body": "<p>Most of the modern OS always reclaim back all memory they allocated to a program(process).<br>\nThe OS doesn't really understand if your program leaked memory it merely takes back what it allocatted.</br></p>\n<p>But there are bigger issues at hand than just the memory loss:           </p>\n<p>Note that if the destructor of the object whos <code>delete</code> needs to be called performs some non-trivial operation and your program depends on the side effects produced by it then your program falls prey to <strong>Undefined Behavior</strong><sup>[Ref 1]</sup>. Once that happens all bets are off and your program may show any beahvior.                 </p>\n<p>Also, An OS usually reclaims the allocated memory but not the other resources, So you might leak those resources indirectly. This may include operations dealing with file descriptors or state of the program itself etc.     </p>\n<p>Hence, it is a good practice to always deallocate all your allocations by calling <code>delete</code> or <code>delete []</code> before exiting your program.      </p>\n<hr>\n<p><sup>[Ref 1]</sup><strong>C++03 Standard 3.8 Para 4:</strong> </p>\n<blockquote>\n<p id=\"so_10277817_10277856_0\">\"....<strong>if there is no explicit call to the destructor or if a delete-expression (5.3.5) is not used to release the storage, the destructor shall not be implicitly called and any program that depends on the side e\ufb00ects produced by the destructor has unde\ufb01ned behavior</strong>.\"</p>\n</blockquote>\n</hr>", "LastEditorUserId": "452307", "LastActivityDate": "2012-04-23T10:16:52.713", "Score": "9", "CreationDate": "2012-04-23T09:23:55.753", "ParentId": "10277817", "CommentCount": "5", "OwnerUserId": "452307", "LastEditDate": "2012-04-23T10:16:52.713"}, "10277880": {"Id": "10277880", "PostTypeId": "2", "Body": "<p>IMO it is best to always call <code>delete</code> properly:</p>\n<ul>\n<li>to make it an automatic habit, making it less likely to forget it when it is really needed</li>\n<li>to cover cases when non-memory resources (sockets, file handles, ...) need to be freed - these aren't automatically freed by the OS</li>\n<li>to cater for future refactoring when the code in question might be moved out of <code>main</code> scope</li>\n</ul>\n", "LastActivityDate": "2012-04-23T09:25:17.937", "CommentCount": "0", "CreationDate": "2012-04-23T09:25:17.937", "ParentId": "10277817", "Score": "6", "OwnerUserId": "265143"}, "10277999": {"Id": "10277999", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_10277817_10277999_0\">The reason why this seems a bit redudant to me is that when main ends,\n  the program also ends, so there is no need to worry about memory\n  leaks.</p>\n</blockquote>\n<p>You're right, but consider this: you create a class object which opens a connection to remote DB. After your program will complete, you should tell the DB \"I'm done, i'm going to disconnect\", but it won't happen in the case you won't call delete properly.</p>\n", "LastActivityDate": "2012-04-23T09:32:57.417", "CommentCount": "0", "CreationDate": "2012-04-23T09:32:57.417", "ParentId": "10277817", "Score": "0", "OwnerUserId": "324137"}, "10277817": {"ViewCount": "4837", "Body": "<p>When using dynamically allocated objects in C++ eg:</p>\n<pre><code>TGraph* A = new TGraph(...);\n</code></pre>\n<p>One should always <code>delete</code> these because otherwise the objects might still be in memory when\ncontrol is handed back to the parent scope. While I can see why this is true for subscopes and subroutines of a program, does the same count for the <code>main</code> scope?</p>\n<p>Am I obliged to <code>delete</code> objects that were dynamically built inside <code>main()</code>? The reason why this seems a bit redudant to me is that when <code>main</code> ends, the program also ends, so there is no need to worry about memory leaks.</p>\n", "AcceptedAnswerId": "10277856", "Title": "C++ is it necessary to delete dynamically allocated objects at the end of the main scope?", "CreationDate": "2012-04-23T09:21:31.917", "Id": "10277817", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2012-04-23T11:14:19.177", "Score": "4", "OwnerUserId": "600545", "Tags": "<c++><memory-management><memory-leaks>", "AnswerCount": "7"}});