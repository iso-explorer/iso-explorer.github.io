post_cb({"281154": {"CommentCount": "0", "CreationDate": "2008-11-11T15:10:45.670", "LastEditorUserId": "-1", "LastActivityDate": "2008-11-11T15:10:45.670", "ParentId": "281045", "LastEditDate": "2017-05-23T12:25:17.053", "OwnerDisplayName": "Jason Baker", "PostTypeId": "2", "Id": "281154", "Score": "0", "Body": "<p>While browsing the related topics at the right, I looked at <a href=\"https://stackoverflow.com/questions/127290/is-it-possible-to-subclass-a-c-struct-in-c-and-use-pointers-to-the-struct-in-c\">this question</a>.  I figure this may be an interesting corner case when thinking about these issues (unless it's more common than I realize).</p>\n<p>To paraphrase, if you have a struct in C that looks something like this:</p>\n<pre><code>struct foo{};\n</code></pre>\n<p>and subclass it like so in C++ (using a separate compilation unit):</p>\n<pre><code>extern \"C\" foo;\nstruct bar: public foo{};\n</code></pre>\n<p>Then the memory alignment won't necessarily be the same for the reasons <a href=\"https://stackoverflow.com/questions/281045/do-classstruct-members-always-get-created-in-memory-in-the-order-they-were-decl#281082\">aib</a> mentions (even amongst compilers from the same vendor).</p>\n", "OwnerUserId": "2147"}, "281069": {"CommentCount": "0", "CreationDate": "2008-11-11T14:47:09.370", "LastEditorUserId": "8899", "LastActivityDate": "2008-11-11T14:53:05.100", "ParentId": "281045", "PostTypeId": "2", "LastEditorDisplayName": "Nemanja Trifunovic", "LastEditDate": "2008-11-11T14:53:05.100", "Id": "281069", "Score": "3", "Body": "<p>Basically, you can count on that only for the classes with a <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2102.html\" rel=\"nofollow noreferrer\">standard layout</a>. Strictly speaking, standard layout is a C++0x thing, but it is really just standardizing existing practice/</p>\n", "OwnerUserId": "8899", "OwnerDisplayName": "Nemanja Trifunovic"}, "281045": {"CommentCount": "0", "AcceptedAnswerId": "281082", "PostTypeId": "1", "LastEditorUserId": "-1", "LastEditorDisplayName": "Jason Baker", "CreationDate": "2008-11-11T14:40:03.907", "LastActivityDate": "2016-05-13T22:54:45.860", "AnswerCount": "6", "LastEditDate": "2017-05-23T12:32:06.453", "ViewCount": "8823", "FavoriteCount": "6", "Title": "Do class/struct members always get created in memory in the order they were declared?", "Id": "281045", "Score": "35", "Body": "<p>This is a question that was sparked by <a href=\"https://stackoverflow.com/users/3631/rob-walker\">Rob Walker</a>'s answer <a href=\"https://stackoverflow.com/questions/36455/alignment-restrictions-for-mallocfree#36466\">here</a>.</p>\n<p>Suppose I declare a class/struct like so:</p>\n<pre><code>struct\n{ \n    char A;\n    int B;\n    char C;\n    int D;\n};\n</code></pre>\n<p>Is it safe to assume that these members will be declared in exactly that order in memory, or is this a compiler dependent thing?  I'm asking because I had always assumed that the compiler can do whatever it wants with them.  </p>\n<p>This leads into my next question.  If the above example causes memory alignment issues, why can the compiler not just turn that into something like this implicitly:</p>\n<pre><code>struct\n{ \n    char A;\n    char C;\n    int B;\n    int D;\n};\n</code></pre>\n<p>(I'm primarily asking about C++, but I'd be interested to hear the C answer as well)</p>\n<h3>Related topics</h3>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/118068/why-doesnt-gcc-optimize-structs\">Why doesn't GCC optimize structs?</a></li>\n</ul>\n", "Tags": "<c++><memory><memory-alignment>", "OwnerUserId": "2147", "OwnerDisplayName": "Jason Baker"}, "281065": {"CommentCount": "1", "CreationDate": "2008-11-11T14:46:16.970", "LastEditorUserId": "-1", "LastActivityDate": "2008-11-11T16:45:40.753", "ParentId": "281045", "PostTypeId": "2", "LastEditorDisplayName": "dmckee", "LastEditDate": "2017-05-23T12:17:20.153", "Id": "281065", "Score": "4", "Body": "<p>The data members are arranged in the order declared. The compiler is free to intersperse padding to arrange the memory alignment it likes (and you'll find that many compilers have a boatload a alignment specification options---useful if mixing bits compiled by different programs.). </p>\n<p>See also <a href=\"https://stackoverflow.com/questions/118068/why-doesnt-gcc-optimize-structs\">Why doesn't GCC optimize structs?</a>.</p>\n<hr>\n<p>It appears that this answer is somewhat obsolete for C++. You learn something everyday. Thanks aib, Nemanja.</p>\n</hr>", "OwnerUserId": "2509", "OwnerDisplayName": "dmckee"}, "281064": {"ParentId": "281045", "CommentCount": "0", "Body": "<p>I cannot speak for C++, but in C the order is guaranteed to be the same order in memory as declared in the struct.</p>\n", "OwnerUserId": "9417", "Id": "281064", "PostTypeId": "2", "OwnerDisplayName": "Chris Young", "Score": "2", "CreationDate": "2008-11-11T14:46:14.910", "LastActivityDate": "2008-11-11T14:46:14.910"}, "281082": {"CommentCount": "7", "CreationDate": "2008-11-11T14:50:01.970", "LastEditorUserId": "1088", "LastActivityDate": "2013-01-17T15:43:36.590", "ParentId": "281045", "PostTypeId": "2", "LastEditorDisplayName": "aib", "LastEditDate": "2013-01-17T15:43:36.590", "Id": "281082", "Score": "64", "Body": "<p>C99 \u00a76.7.2.1 clause 13 states:</p>\n<blockquote>\n<p id=\"so_281045_281082_0\">Within a structure object, the\n  non-bit-\ufb01eld members and the units in\n  which bit-\ufb01elds reside have addresses\n  that increase in the order in which\n  they are declared.</p>\n</blockquote>\n<p>and goes on to say a bit more about padding and addresses. The C89 equivalent section is \u00a76.5.2.1.</p>\n<p>C++ is a bit more complicated. In the 1998 and 2003 standards, there is \u00a79.2 clause 12 (clause 15 in C++11):</p>\n<blockquote>\n<p id=\"so_281045_281082_1\">Nonstatic data members of a\n  (non-union) class declared without an\n  intervening access-specifier are\n  allocated so that later members have\n  higher addresses within a class\n  object.  The order of allocation of\n  nonstatic data members separated by an\n  access-specifier is unspecified\n  (11.1).  Implementation alignment\n  requirements might cause two adjacent\n  members not to be allocated\n  immediately after each other; so might\n  requirements for space for managing\n  virtual functions (10.3) and virtual\n  base classes (10.1).</p>\n</blockquote>\n", "OwnerUserId": "1088", "OwnerDisplayName": "aib"}, "bq_ids": {"n4140": {"so_281045_281082_1": {"section_id": 5873, "quality": 0.8235294117647058, "length": 42}}, "n3337": {"so_281045_281082_1": {"section_id": 5644, "quality": 0.8235294117647058, "length": 42}}, "n4659": {"so_281045_281082_1": {"section_id": 7356, "quality": 0.8235294117647058, "length": 42}}}, "281091": {"CommentCount": "3", "CreationDate": "2008-11-11T14:51:30.220", "LastEditorUserId": "2147", "LastActivityDate": "2008-11-11T14:56:06.170", "ParentId": "281045", "PostTypeId": "2", "LastEditorDisplayName": "Jason Baker", "LastEditDate": "2008-11-11T14:56:06.170", "Id": "281091", "Score": "2", "Body": "<p>Aside from padding for alignment, no structure optimization is allowed by any compiler (that I am aware of) for C or C++.  I can't speak for C++ classes, as they may be another beast entirely.</p>\n<p>Consider your program is interfacing with system/library code on Windows but you want to use GCC.  You would have to verify that GCC used an identical layout-optimization algorithm so all your structures would be packed correctly before sending them to the MS-compiled code.</p>\n", "OwnerUserId": "27233", "OwnerDisplayName": "HUAGHAGUAH"}});