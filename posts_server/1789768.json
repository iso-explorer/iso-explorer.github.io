post_cb({"1790124": {"Id": "1790124", "PostTypeId": "2", "Body": "<p>It \"shouldn't\" work, but you never know your luck.</p>\n<p>Because of overloading, <code>char *First()</code> and <code>const char *First() const</code> are different functions. You could have both in the same class. So any name-mangling scheme has to map them to different names, which obviously is a problem when it comes to binding.</p>\n<p><em>But</em>, these are virtual calls, and you have three functions replaced by their equivalents in the same order. I don't know any details of MSVC's vtable scheme, in particular whether the offsets are statically determined or dynamically bound. If the former, it's possible that the exe can bind against the new vtable. The function pointers might just so happen to work, because the calling convention doesn't depend on cv-qualification (that is, a <code>const char*</code> is returned the same way a <code>char*</code> is, and const this is passed the same way non-const this is).</p>\n<p>Even if it does work, I wouldn't want to rely on it unless it's something that MS specifically addresses and guarantees.</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2009-11-24T13:50:53.120", "Score": "1", "CreationDate": "2009-11-24T13:37:40.337", "ParentId": "1789768", "CommentCount": "5", "LastEditDate": "2009-11-24T13:50:53.120", "OwnerUserId": "13005"}, "1789768": {"ViewCount": "734", "Body": "<p>I have an abstract class in my DLL.</p>\n<pre><code>class Base {\n  virtual char * First() = 0;\n  virtual char * Second() = 0;\n  virtual char * Third() = 0;\n};\n</code></pre>\n<p>This dinamic library and this interface are used for a long time.\nThere is my mistake in my code. Now I want to change this interface</p>\n<pre><code>class Base {\n  virtual const char * First()  const = 0; \n  virtual const char * Second()       = 0;\n  virtual       char * Third()  const = 0;\n};\n</code></pre>\n<p>Some EXE-program uses my DLL. Will the EXE-program work without recompilation?\nConsider changes in each line of new interface independently.</p>\n<p><strong>Note:</strong> of course, EXE-program does not change functions results.</p>\n", "AcceptedAnswerId": "1790124", "Title": "Can I change dll-interface without recompilation exe-file?", "CreationDate": "2009-11-24T12:27:01.977", "Id": "1789768", "CommentCount": "0", "LastEditDate": "2009-11-24T12:58:01.010", "PostTypeId": "1", "LastEditorUserId": "124161", "LastActivityDate": "2009-11-24T17:42:41.810", "Score": "1", "OwnerUserId": "124161", "Tags": "<c++><visual-studio-2008><dll><abstract-class>", "AnswerCount": "5"}, "1789799": {"Id": "1789799", "PostTypeId": "2", "Body": "<p>Probably won't work.  Though the easiest way to know for sure is to try it and see </p>\n", "LastActivityDate": "2009-11-24T12:34:11.747", "Score": "0", "CreationDate": "2009-11-24T12:34:11.747", "ParentId": "1789768", "CommentCount": "7", "OwnerUserId": "52888"}, "bq_ids": {"n4140": {"so_1789768_1789808_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 5433}, "so_1789768_1789808_0": {"length": 38, "quality": 0.926829268292683, "section_id": 5432}}, "n3337": {"so_1789768_1789808_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 5228}, "so_1789768_1789808_0": {"length": 38, "quality": 0.926829268292683, "section_id": 5227}}, "n4659": {"so_1789768_1789808_1": {"length": 17, "quality": 0.9444444444444444, "section_id": 6861}, "so_1789768_1789808_0": {"length": 38, "quality": 0.926829268292683, "section_id": 6860}}}, "1791720": {"Id": "1791720", "PostTypeId": "2", "Body": "<p>I don't think this will work. Changing the interface of a DLL usually requires the executable that links to it to be recompiled.</p>\n<p>In addition, you will likely need to make changes to the code in the executable, as you have changed the function signatures.</p>\n<p>Lastly, if you are going to update/append an interface, you would be best to subclass the original interface. This will prevent any existing code from breaking.</p>\n", "LastActivityDate": "2009-11-24T17:42:41.810", "Score": "0", "CreationDate": "2009-11-24T17:42:41.810", "ParentId": "1789768", "CommentCount": "0", "OwnerUserId": "142597"}, "1789788": {"Id": "1789788", "PostTypeId": "2", "Body": "<p>since you change your interface, you have to recompile (i think)</p>\n", "LastActivityDate": "2009-11-24T12:31:39.223", "Score": "0", "CreationDate": "2009-11-24T12:31:39.223", "ParentId": "1789768", "CommentCount": "0", "OwnerUserId": "136135"}, "1789808": {"Id": "1789808", "PostTypeId": "2", "Body": "<p>Your EXE could change result of function since it was <code>char*</code>. Now it is <code>const char*</code>. And changing const object will lead to undefined behavior according to C++ Standard 7.1.5.1/3-4:</p>\n<blockquote>\n<p id=\"so_1789768_1789808_0\">A pointer or reference to a cv-qualified type need not actually point or refer to a cv-qualified object, but it is treated as if it does; a const-qualified access path cannot be used to modify an object even if the object referenced is a non-const object and can be modified through some other access path.  [Note: cv-qualifiers are supported by the type system so that they cannot be subverted without casting (5.2.11).  ]</p>\n<p id=\"so_1789768_1789808_1\">Except that any class member declared mutable (7.1.1) can be modified, any attempt to modify a const\n  object during its lifetime (3.8) results in undefined behavior.</p>\n</blockquote>\n", "LastActivityDate": "2009-11-24T12:35:49.323", "Score": "3", "CreationDate": "2009-11-24T12:35:49.323", "ParentId": "1789768", "CommentCount": "1", "OwnerUserId": "123111"}});