post_cb({"bq_ids": {"n4140": {"so_22322487_22323637_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 710}}, "n3337": {"so_22322487_22323637_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 699}}, "n4659": {"so_22322487_22323637_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 739}}}, "22323637": {"Id": "22323637", "PostTypeId": "2", "Body": "<p>I believe you are misinterpreting the \"Change\": this is not referring to the invalidation rules of <code>data</code> and <code>c_str</code>, but rather those of <code>swap</code>.</p>\n<p><a href=\"https://stackoverflow.com/questions/6390756/stdstring-small-string-optimization-and-swap\">This question</a> gave me this idea, and I think I am correct when I read your quote and the linked question/answers.</p>\n<p>Since <code>basic_string</code>'s swap can invalidate iterators, one can implement a SSO. In C++03, <code>basic_string</code> was a reversible container, which means it had to comply with this requirement for <code>swap</code>ping containers:</p>\n<blockquote>\n<p id=\"so_22322487_22323637_0\">The expression a.swap(b), for containers a and b of a standard container type other than array, shall exchange the values of a and b without invoking any move, copy, or swap operations on the individual container elements.</p>\n</blockquote>\n<p>I may be immensely wrong though, IANALL (I am not a language lawyer).</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-03-11T10:57:03.187", "Score": "6", "CreationDate": "2014-03-11T10:57:03.187", "ParentId": "22322487", "CommentCount": "3", "OwnerUserId": "256138", "LastEditDate": "2017-05-23T11:45:18.377"}, "22322487": {"ViewCount": "713", "Body": "<p>In the compatibility appendix of the C++11 standard, one of the change from C++03 to C++11 is described as below:</p>\n<blockquote>\n<p id=\"so_22322487_22322487_0\"><strong>C.2.11  Clause 21: strings library</strong><br>\n<strong>21.4.1</strong><br>\n<strong>Change</strong>: Loosen basic_string invalidation rules<br>\n<strong>Rationale</strong>: Allow small-string optimization.<br>\n<strong>Effect on original feature</strong>: Valid C++ 2003 code may execute\n  differently in this International Standard.  Some const member\n  functions, such as data and c_str, no longer invalidate iterators.</br></br></br></br></p>\n</blockquote>\n<p>The iterator invalidation rule of <code>std::string</code> does have changed from C++03 to C++11 in that <code>data()</code> and <code>c_str()</code> is not allowed to invalidate iterators anymore, but I don't know how that leads to the rationale of \"<code>allow small-string optimization</code>\"?  Wasn't SSO already allowed prior to C++11?</p>\n<hr>\n<p>Two of the differences of <code>std::string</code> between C++11 and C++03 that I knew of before I came across that SSO notes in the compatibility appendix are:  </p>\n<ul>\n<li>Elements are guaranteed to be stored contiguously in C++11  </li>\n<li>COW implementation is not an option in C++11 (certain operations such as <code>operator[]</code> is not allowed to invalidate iterators)</li>\n</ul>\n<p>I took C++11's non-invalidating guarantee of <code>c_str()</code> and <code>data()</code> as the direct result of the change towards contiguous storage.  Now it seems there is some connection with SSO implementation, and I would like to know the detail of the behind-scene logic.  Thanks.</p>\n</hr>", "AcceptedAnswerId": "22323637", "Title": "C++11 and C++03 differs in support for small string optimization for std::string?", "CreationDate": "2014-03-11T10:09:21.047", "Id": "22322487", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2014-03-11T10:57:03.187", "Score": "9", "OwnerUserId": "3237645", "Tags": "<c++><string><c++11><language-lawyer>", "AnswerCount": "1"}});