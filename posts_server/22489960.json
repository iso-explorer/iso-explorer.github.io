post_cb({"bq_ids": {"n4140": {"so_22489960_22490334_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 6304}, "so_22489960_22490334_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 6306}}, "n3337": {"so_22489960_22490334_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 6061}, "so_22489960_22490334_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 6063}}, "n4659": {"so_22489960_22490334_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 7814}, "so_22489960_22490334_0": {"length": 10, "quality": 0.7692307692307693, "section_id": 7817}}}, "22489960": {"ViewCount": "130", "Body": "<p>In a C++ library where a user-defined type exists that adds a textual representation of the symbolical value of a variable, to the primitive data types int, double, ..., bool:</p>\n<pre><code>template&lt;typename T&gt;\nclass Var {\n    T value;\n\n    //a datastructure containing Expressions and string representations of operators\n    Expression expr; \n}\n</code></pre>\n<p>The operator for <code>addition (+)</code> is overwritten:</p>\n<pre><code>#define OVERLOAD_ARITHMETIC_OPERATOR(op, opName) \\\ntemplate&lt;typename X, typename Y&gt;\\\nauto operator op(const X x, const Y y) -&gt;\\\nse::Var&lt;decltype(__filter(x).getValue() op __filter(y).getValue())&gt; \\\n{\\\n    const auto __x = __filter(x);\\\n    const auto __y = __filter(y);\\\n    auto result = se::constructVar(__x.getValue() op __y.getValue());\\\n    if(__x.isSymbolic() || __y.isSymbolic()) {\\\n        result.setExpression(BINARY_EXPRESSION(opName, __x.getExpression(), __y.getExpression()));\\\n    }\\\n    return result;\\\n}\\\n\nOVERLOAD_ARITHMETIC_OPERATOR(+, ADD)\n</code></pre>\n<p>The following program:</p>\n<p>main.cpp:</p>\n<pre><code>#define double Double\n#define int Int\n#define float Float\n#define bool Bool\n\n#include \"aprogram.c\"\n\n#undef double \n#undef int\n#undef float\n#undef bool\n\nint main(){\n     std::cout &lt;&lt; afunction();\n}\n</code></pre>\n<p>aprogram.c:</p>\n<pre><code>int afunction(){\n    double t1 = ... ;\n    double t2 = ... ;\n    return t1 + t2;\n}\n</code></pre>\n<p>returns <code>t1.expr + t2.expr</code> as expected.</p>\n<p><strong>Problem</strong></p>\n<p>When overloading the operator <code>greater (&gt;)</code>:</p>\n<pre><code>#define OVERLOAD_COND_OPERATOR(op, opName) \\\ntemplate&lt;typename X, typename Y&gt;\\\nse::Var&lt;bool&gt; operator op(const X x, const Y y)\\\n{\\\n    const auto __x = __filter(x);\\\n    const auto __y = __filter(y);\\\n    auto result = se::constructVar(__x.getValue() op __y.getValue());\\\n    if(__x.isSymbolic() || __y.isSymbolic()) \\\n        result.setExpression(BINARY_EXPRESSION(opName, __x.getExpression(), __y.getExpression()));\\\n    return result;\\\n}\\\n\nOVERLOAD_COND_OPERATOR(&gt;, GREATER)\n</code></pre>\n<p>and changing the return in <em>afunction()</em> to <code>return t1 &gt; t2</code> we expect a similar result, <code>t1.expr &gt; t2.expr</code>, but instead the result gets casted to a bool and the information stored in Var.expr is lost.</p>\n<p><strong>Although I believe the operators for <code>+</code> and <code>&gt;</code> are similarly written, can you help me understand why <code>&gt;</code> behaves differently? Can you help me get to the wanted behaviour?</strong></p>\n<p>Please provide feedback to my question: help me help you helping me.</p>\n<p><strong>Information Added after posting</strong></p>\n<p>1/\n<code>__filter()</code> is a method returning the datastructure Var. In my example Var is greatly simplified, filter just returns the object with <code>T value</code> and <code>Expression expr</code> in it.</p>\n<p>2/</p>\n<pre><code>typedef se::Var&lt;double&gt; Double;\ntypedef se::Var&lt;int&gt; Int;\ntypedef se::Var&lt;char&gt; Char;\ntypedef se::Var&lt;float&gt; Float;\ntypedef se::Var&lt;bool&gt; Bool;\n</code></pre>\n", "Title": "overloading greater than operator casts user-defined type to primitive, information is lost", "CreationDate": "2014-03-18T20:10:43.403", "LastActivityDate": "2014-03-18T20:37:02.507", "CommentCount": "10", "LastEditDate": "2014-03-18T20:37:02.507", "PostTypeId": "1", "LastEditorUserId": "1501839", "Id": "22489960", "Score": "-1", "OwnerUserId": "1501839", "Tags": "<c++><casting><operator-overloading><user-defined-types>", "AnswerCount": "1"}, "22490334": {"Id": "22490334", "PostTypeId": "2", "Body": "<p>Your program is going to do any number of unexpected things, because it has undefined behavior.</p>\n<p>This is not allowed:</p>\n<pre><code>#define double Double\n#define int Int\n#define float Float\n#define bool Bool\n</code></pre>\n<p>Macro names have to be identifiers, and those are keywords, not identifiers.</p>\n<p>Section 17.6.4.3 makes this very clear:</p>\n<blockquote>\n<p id=\"so_22489960_22490334_0\">A translation unit shall not <code>#define</code> or <code>#undef</code> names lexically identical to keywords, to the identifiers listed in Table 3, or to the <em>attribute-tokens</em> described in 7.6.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_22489960_22490334_1\">If a program declares or defines a name in a context where it is reserved, other than as explicitly allowed by this Clause, its behavior is unde\ufb01ned.</p>\n</blockquote>\n", "LastEditorUserId": "103167", "LastActivityDate": "2014-03-18T20:37:00.577", "Score": "1", "CreationDate": "2014-03-18T20:28:56.393", "ParentId": "22489960", "CommentCount": "2", "OwnerUserId": "103167", "LastEditDate": "2014-03-18T20:37:00.577"}});