post_cb({"28578113": {"Id": "28578113", "PostTypeId": "2", "Body": "<p>If you don't actually create an instance of your template, the copy constructor doesn't need to be called - the template code will not even be created for <code>CannotBeCopied</code>, if you don't use it. Invoke the copy constructor and you will get the error:</p>\n<pre><code> FirstVector&lt;CannotBeCopied&gt; a;\n FirstVector&lt;CannotBeCopied&gt; b = a;\n</code></pre>\n<p>Edit: You may also use explicit instantiation of the template with all it's members by adding</p>\n<pre><code>template class FirstVector&lt;CannotBeCopied&gt;;\n</code></pre>\n<p>(\u00a714.7.2 of language specification)</p>\n", "LastEditorUserId": "2385414", "LastActivityDate": "2015-02-18T07:34:57.857", "Score": "3", "CreationDate": "2015-02-18T07:20:17.447", "ParentId": "28578061", "CommentCount": "24", "OwnerUserId": "2385414", "LastEditDate": "2015-02-18T07:34:57.857"}, "bq_ids": {"n4140": {"so_28578061_28579464_1": {"length": 22, "quality": 0.9565217391304348, "section_id": 234}, "so_28578061_28579464_2": {"length": 22, "quality": 1.0, "section_id": 243}, "so_28578061_28579464_0": {"length": 44, "quality": 0.9166666666666666, "section_id": 233}}, "n3337": {"so_28578061_28579464_1": {"length": 22, "quality": 0.9565217391304348, "section_id": 227}, "so_28578061_28579464_2": {"length": 20, "quality": 0.9090909090909091, "section_id": 235}, "so_28578061_28579464_0": {"length": 43, "quality": 0.8958333333333334, "section_id": 226}}, "n4659": {"so_28578061_28579464_1": {"length": 22, "quality": 0.9565217391304348, "section_id": 244}, "so_28578061_28579464_2": {"length": 20, "quality": 0.9090909090909091, "section_id": 250}, "so_28578061_28579464_0": {"length": 34, "quality": 0.7083333333333334, "section_id": 242}}}, "28578061": {"ViewCount": "91", "Body": "<p>GCC isn't giving me an error on an example I've made where I was hoping it would:</p>\n<pre><code>class CannotBeCopied {\npublic:\n    CannotBeCopied(const CannotBeCopied&amp;) = delete;\n    CannotBeCopied&amp; operator=(const CannotBeCopied&amp;) =delete;\n    CannotBeCopied() { }\n    ~CannotBeCopied() { }\n};\n\ntemplate&lt;class T&gt;\nclass FirstVector {\npublic:\n    FirstVector() {\n        size = 1;\n        data = new T[size];\n    }\n\n    ~FirstVector() {\n        delete[] data;\n    }\n\n    FirstVector(const FirstVector&amp; source) {\n        size = source.size;\n        data = new T[size];\n        for(int k=0;k!=size;k++) {\n            data[k] = source.data[k]; //&lt;--I EXPECT AN ERROR HERE\n        }\n    }\nprivate:\n    int size;\n    T* data;\n};\n</code></pre>\n<p>This error doesn't happen when the copy constructor isn't use (that is, it does happen when the copy constructor is used).</p>\n<p>Because of the template I cannot simply move the copy-ctor into a code file and have that fail when it compiles. </p>\n<p>How can I get this to fail?</p>\n<p>This is not SFINAE, it should not be able to instantiate the template. If the copy-ctor was itself a template method (say by putting:</p>\n<pre><code>template&lt;class U=T&gt;\n</code></pre>\n<p>on the line above, then it'd be SFINAE.</p>\n<p>I am using GCC 4.8.1, <code>-pedantic -Wall -Wextra</code> of course, and <code>-std=c++11</code> </p>\n<p>I was hoping to get this to fail with:</p>\n<pre><code>int main() { \n    FirstVector&lt;CannotBeCopied&gt; whatever;\n}\n</code></pre>\n<p>I know that GCC is just being lazy and not doing work it doesn't need to, but I do not like that if I were to explicitly instantiate this template in a code file, I'd get an error. Is there a way to get the error I want?</p>\n", "AcceptedAnswerId": "28579464", "Title": "Why isn't GCC giving me an error", "CreationDate": "2015-02-18T07:16:28.213", "Id": "28578061", "CommentCount": "4", "LastEditDate": "2015-02-18T07:26:41.683", "PostTypeId": "1", "OwnerDisplayName": "user4578468", "LastEditorUserId": "492336", "LastActivityDate": "2015-02-18T08:55:51.213", "Score": "0", "Tags": "<c++><gcc>", "AnswerCount": "3"}, "28578383": {"Id": "28578383", "PostTypeId": "2", "Body": "<p>Templates in C++ are only <strong>materialized when they are used</strong>.\nEverything else would be too expensive.</p>\n<p>As you may have heard, C++ templates are turing complete, so evaluating them can be is insanely expensive. IIRC there was an example somewhere of Fibonnaci&lt;17&gt;, which would have the compiler compute this number...</p>\n<p>In particular this means the dead code will be eliminated, and the c++ compiler will only fail once you try to use the copy constructor.</p>\n", "LastActivityDate": "2015-02-18T07:38:39.757", "CommentCount": "0", "CreationDate": "2015-02-18T07:38:39.757", "ParentId": "28578061", "Score": "3", "OwnerUserId": "1060350"}, "28579464": {"Id": "28579464", "PostTypeId": "2", "Body": "<p>It's not just a matter of GCC being lazy; it is affirmatively prohibited from doing what you want it to do by the standard. [temp.inst]/p1, 2, 11:</p>\n<blockquote>\n<p id=\"so_28578061_28579464_0\">1 Unless a class template specialization has been explicitly\n  instantiated (14.7.2) or explicitly specialized (14.7.3), the class\n  template specialization is implicitly instantiated when the\n  specialization is referenced in a context that requires a\n  completely-defined object type or when the completeness of the class\n  type affects the semantics of the program. [...] The implicit instantiation of\n  a class template specialization causes the implicit instantiation of\n  the declarations, but not of the definitions, default arguments, or\n  exception-specifications of the class member functions [...]</p>\n<p id=\"so_28578061_28579464_1\">2  Unless a member of a class template or a member template has been\n  explicitly instantiated or explicitly specialized, the specialization\n  of the member is implicitly instantiated when the specialization is\n  referenced in a context that requires the member definition to exist.\n  [...]</p>\n<p id=\"so_28578061_28579464_2\">11 An implementation shall not implicitly instantiate a function\n  template, a variable template, a member template, a non-virtual member\n  function, a member class, or a static data member of a class template\n  that does not require instantiation.</p>\n</blockquote>\n<p>This allows you to have, e.g., <code>std::vector</code>s of move-only types. Their copy constructors will not compile, but as long as you don't use them, a <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> is perfectly valid.</p>\n<p>To force it to fail, you might use a <code>static_assert</code> inside <code>FirstVector</code>:</p>\n<pre><code>static_assert(std::is_copy_constructible&lt;T&gt;::value, \"T must be copy constructible\");\n</code></pre>\n<p>Note, however, that this only checks that a declaration of the copy constructor is accessible and not deleted, not that the body of the copy constructor will compile, which means that it will falsely report that <code>std::vector&lt;std::unique_ptr&lt;T&gt;&gt;</code> is copy constructible.</p>\n", "LastActivityDate": "2015-02-18T08:55:51.213", "CommentCount": "2", "CreationDate": "2015-02-18T08:55:51.213", "ParentId": "28578061", "Score": "1", "OwnerUserId": "2756719"}});