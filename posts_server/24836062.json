post_cb({"bq_ids": {"n4140": {"so_24836062_24836148_3": {"length": 4, "quality": 0.6666666666666666, "section_id": 391}, "so_24836062_24836148_1": {"length": 21, "quality": 0.8076923076923077, "section_id": 393}, "so_24836062_24836148_4": {"length": 12, "quality": 0.6666666666666666, "section_id": 3197}}, "n3337": {"so_24836062_24836148_3": {"length": 4, "quality": 0.6666666666666666, "section_id": 382}, "so_24836062_24836148_1": {"length": 21, "quality": 0.8076923076923077, "section_id": 384}, "so_24836062_24836148_4": {"length": 12, "quality": 0.6666666666666666, "section_id": 3071}}, "n4659": {"so_24836062_24836148_3": {"length": 4, "quality": 0.6666666666666666, "section_id": 408}, "so_24836062_24836148_1": {"length": 19, "quality": 0.7307692307692307, "section_id": 410}, "so_24836062_24836148_4": {"length": 12, "quality": 0.6666666666666666, "section_id": 3959}}}, "24836148": {"Id": "24836148", "PostTypeId": "2", "Body": "<p>Yes, this is indeed required we can see this by going to the cppreference section <a href=\"http://en.cppreference.com/w/cpp/language/cast_operator\" rel=\"nofollow\">user-defined conversion</a> which says:</p>\n<blockquote>\n<p id=\"so_24836062_24836148_0\">Function and array operators [] or () are not allowed in the\n  declarator (thus conversion to types such as pointer to array requires\n  a typedef: see below). Regardless of typedef, conversion-type-id\n  cannot represent an array or a function type.</p>\n</blockquote>\n<p>We can find this in the draft C++ standard section <code>12.3.2</code> <em>Conversion functions</em> which says:</p>\n<blockquote>\n<p id=\"so_24836062_24836148_1\">The conversion-type-id shall not represent a function type nor an\n  array type. The conversion-type-id in a conversion-function-id is the\n  longest possible sequence of conversion-declarators. [ Note: This\n  prevents ambiguities between the declarator operator * and its\n  expression counterparts. [ Example:</p>\n<pre><code>&amp;ac.operator int*i; // syntax error:\n                    // parsed as: &amp;(ac.operator int *)i\n                    // not as: &amp;(ac.operator int)*i\n</code></pre>\n<p id=\"so_24836062_24836148_2\">The * is the pointer declarator and not the multiplication operator. \u2014end example ] \u2014end note ]</p>\n</blockquote>\n<p>and the grammar for <em>conversion-type-id</em> is as follows:</p>\n<blockquote id=\"so_24836062_24836148_3\">\n<pre><code>conversion-type-id:\n  type-specifier-seq conversion-declaratoropt\nconversion-declarator:\n  ptr-operator conversion-declaratoropt\n</code></pre>\n</blockquote>\n<p>which is more restricted then a <em>declarator</em> whose grammar looks like this:</p>\n<blockquote id=\"so_24836062_24836148_4\">\n<pre><code>declarator:\n  ptr-declarator\n  noptr-declarator parameters-and-qualifiers trailing-return-type\nptr-declarator:\n  noptr-declarator\n  ptr-operator ptr-declarator\nnoptr-declarator:\n  declarator-id attribute-specifier-seqopt\n  noptr-declarator parameters-and-qualifiers\n  noptr-declarator [ constant-expressionopt] attribute-specifier-seqopt\n  ( ptr-declarator )\n</code></pre>\n</blockquote>\n<p>One alternative as chris mentioned was to use an identity class:</p>\n<pre><code>template &lt;typename T&gt;\nstruct identity\n{\n    typedef T type;\n};\n</code></pre>\n<p>you would use it as follows:</p>\n<pre><code>operator typename identity&lt;int(&amp;)[10]&gt;::type() ;\n</code></pre>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-07-21T02:31:39.267", "Score": "5", "CreationDate": "2014-07-19T02:22:00.257", "ParentId": "24836062", "CommentCount": "5", "LastEditDate": "2014-07-21T02:31:39.267", "OwnerUserId": "1708801"}, "24836062": {"ViewCount": "436", "Body": "<p>Here's a conversion function returning an array reference:</p>\n<pre><code>struct S { \n    typedef int int_array_20[20];\n    operator int_array_20&amp; ();\n};\n</code></pre>\n<p>Is it possible to do the same thing without <code>typedef</code>? What I've tried:</p>\n<pre><code>struct S { \n    operator int (&amp;()) [10];\n};\n</code></pre>\n<p>but clang complains:</p>\n<pre><code>error: C++ requires a type specifier for all declarations\n    operator int (&amp;()) [10];\n                  ~ ^\nerror: conversion function cannot have any parameters\n    operator int (&amp;()) [10];\n    ^\nerror: must use a typedef to declare a conversion to 'int [10]'\nerror: conversion function cannot convert to an array type\n</code></pre>\n<p>Does:</p>\n<blockquote>\n<p id=\"so_24836062_24836062_0\">must use a typedef to declare a conversion to 'int [10]'</p>\n</blockquote>\n<p>mean <code>typedef</code> is indispensable? </p>\n<p><strong>EDIT</strong><br>\nIf <code>typedef</code> is necessary, it's impossible to create a conversion function template like the following, because couldn't define a <code>typedef</code> template, is it right?</br></p>\n<pre><code>struct S { \n    template&lt;typename T, int N&gt;\n    operator T(&amp;())[N];\n};\n</code></pre>\n", "AcceptedAnswerId": "24836148", "Title": "Is it possible to declare the conversion function returning array reference without the typedef?", "CreationDate": "2014-07-19T02:04:11.717", "Id": "24836062", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-12-14T10:23:23.637", "LastEditorUserId": "1708801", "LastActivityDate": "2015-12-14T10:23:23.637", "Score": "7", "OwnerUserId": "3309790", "Tags": "<c++><type-conversion><typedef><language-lawyer><conversion-operator>", "AnswerCount": "1"}});