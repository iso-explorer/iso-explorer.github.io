post_cb({"bq_ids": {"n4140": {"so_20700324_20701187_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 2420}}, "n3337": {"so_20700324_20701187_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 2405}}, "n4659": {"so_20700324_20701187_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 2695}}}, "20701187": {"Id": "20701187", "PostTypeId": "2", "Body": "<p>Swallowing exceptions is usually a \"worst practice\" because it defeats the purpose of throwing in the first place.</p>\n<p>But in this case, you really only want a subset of functionality in the destructor, not including flushing which is a \"bonus\" but incurs the potential to throw. There may still be side effects to trying to flush at all, such as waiting unnecessarily for a network timeout where one already occurred.</p>\n<p>As James Kanze mentioned, best practice is to manually flush before the destructor runs, which precludes the exceptional condition in the destructor.</p>\n<p>In the future C++ might support transactions better. But for now, your approach is reasonable. In any case, it is how the destructor of <code>std::filebuf</code> is specified to work:</p>\n<blockquote>\n<p id=\"so_20700324_20701187_0\"><em>Effects:</em> Destroys an object of class <code>basic_filebuf&lt;charT,traits&gt;</code>. Calls <code>close()</code>. If an exception occurs during the destruction of the object, including the call to <code>close()</code>, the exception is caught but not rethrown (see 17.6.5.12).</p>\n</blockquote>\n", "LastActivityDate": "2013-12-20T10:12:26.807", "CommentCount": "0", "CreationDate": "2013-12-20T10:12:26.807", "ParentId": "20700324", "Score": "5", "OwnerUserId": "153285"}, "20700493": {"Id": "20700493", "PostTypeId": "2", "Body": "<p>What are you closing?  In general, closing a file open for writing (<code>std::ostream</code>, <code>FILE*</code> or a system dependent file descriptor) must be done before destruction, so that you can check for errors after having done the close, and report them.  There are exceptions, however, and in particular, classes which wrap an open file should generally close it in their destructor (without checking for errors, since there's nothing you can do about them), in order to ensure proper clean up in case of an exception.  </p>\n<p>Presumably, an exception before the close means that there has been an error already, and the file being written will not be used.  I generally wrap output in a class with a <code>commit</code> function.  <code>commit</code> closes, and checks for errors.  If the destructor is called before <code>commit</code>, it closes, without checking for errors, and then removes the file being written, since it is probably not complete or usable.</p>\n", "LastActivityDate": "2013-12-20T09:38:51.193", "CommentCount": "0", "CreationDate": "2013-12-20T09:38:51.193", "ParentId": "20700324", "Score": "4", "OwnerUserId": "649665"}, "20700324": {"ViewCount": "534", "Body": "<p>I have some code which looks a bit like this:</p>\n<pre><code>void writeToStream( std::ostream &amp; outputStream )\n{\n    MyXmlWriter xmlWriter{ outputStream };\n    xmlWriter.addNode();\n    xmlWriter.addNode();\n    xmlWriter.close(); // should this be called in `MyXmlWriter` destructor?\n}\n</code></pre>\n<p>The close function writes some xml close tags so the file can be parsed properly. The constructor writes the header of the xml file. One could consider <code>xmlWriter.close();</code> clean-up code. It is common advice for C++ to put clean-up code into destructors. This way you can never forget to clean-up properly. However, in our case the clean-up code could throw. (Imagine that <code>file</code> could have exceptions enabled, writes to a file can fail.) Therefore, if the <code>close()</code> function is called in the destructor, then it should be wrapped in a try-catch block which eats all exceptions thrown:</p>\n<pre><code>MyXmlWriter::~MyXmlWriter() \n{\n    try\n    {\n        close();\n    }\n    catch (...)\n    {\n    }\n}\n</code></pre>\n<p>However, in this case the caller will not be notified about any errors. The function <code>writeToStream()</code> could fail to write the closing xml tags to the file without the caller knowing about it. What is best practice in this situation?</p>\n", "AcceptedAnswerId": "20700493", "Title": "Should I write the end of the file in the destructor?", "CreationDate": "2013-12-20T09:29:51.527", "Id": "20700324", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2013-12-20T10:29:33.703", "Score": "2", "OwnerUserId": "1335865", "Tags": "<c++><file-io><destructor><exception-safety>", "AnswerCount": "2"}});