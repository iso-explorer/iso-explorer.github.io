post_cb({"37049926": {"ParentId": "37049338", "LastEditDate": "2016-05-06T08:47:57.633", "CommentCount": "0", "CreationDate": "2016-05-05T11:53:55.283", "Score": "1", "LastEditorUserId": "3919155", "PostTypeId": "2", "Id": "37049926", "OwnerUserId": "3919155", "Body": "<p>Note that <code>cc-&gt;getA()</code> is semantically equal to <code>cc-&gt;A::getA()</code> (not <code>cc-&gt;B::getA()</code>) and returns a pointer to <code>A</code> (instead of <code>B*</code>).</p>\n<p>Now, since <code>A</code> is the subclass of <code>B</code>, but the latter also includes some extra fields, then <code>sizeof(B) &gt; sizeof(A)</code>. Since <code>cc-&gt;getA()[n]</code> is basically <code>*(cc-&gt;getA() + n)</code> the line</p>\n<pre><code>cc-&gt;getA()[1].foo();\n</code></pre>\n<p>does the same thing as:</p>\n<pre><code>A * const tmp = cc-&gt;getA();\nA &amp; tmp2 = *(tmp + 1); // sizeof(A) bytes past tmp\ntmp2.foo();\n</code></pre>\n<p>which causes undefined behaviour due to \u00a75.7.6 <a href=\"http://eel.is/c++draft/expr#expr.add-6\" rel=\"nofollow\">[expr.add]</a> of the C++ standard which states:</p>\n<blockquote>\n<p id=\"so_37049338_37049926_0\">For addition or subtraction, if the expressions P or Q have type \u201cpointer to cv T\u201d, where T and the array element type are not similar (<a href=\"http://eel.is/c++draft/conv.qual\" rel=\"nofollow\">[conv.qual]</a>), the behavior is undefined. [ <strong><em>Note:</em></strong> In particular, a pointer to a base class cannot be used for pointer arithmetic when the array contains objects of a derived class type.  \u2014 <strong><em>end note</em></strong> ]</p>\n</blockquote>\n<p>You probably wanted behaviour similar to the following:</p>\n<pre><code>A * const tmp = cc-&gt;getA();\nA &amp; tmp2 = *(static_cast&lt;B *&gt;(tmp) + 1); // sizeof(B) bytes past tmp\ntmp2.foo();\n</code></pre>\n<p>For that you need to use something like:</p>\n<pre><code>std::cout&lt;&lt;static_cast&lt;B*&gt;(cc-&gt;getA())[1].idx[0]&lt;&lt;\"\\n\"; // prints 2\nstd::cout&lt;&lt;static_cast&lt;B*&gt;(cc-&gt;getA())[1].idx[1]&lt;&lt;\"\\n\"; // prints 3\nstd::cout&lt;&lt;static_cast&lt;B*&gt;(cc-&gt;getA())[1].idx[2]&lt;&lt;\"\\n\"; // prints 4\n\nstatic_cast&lt;B*&gt;(cc-&gt;getA())[1].foo();  // prints foo B\n</code></pre>\n<p>However, it is better to implement a virtual <code>A &amp; operator[](std::size_t)</code> operator for <code>AA</code> and override it in <code>BB</code>.</p>\n", "LastActivityDate": "2016-05-06T08:47:57.633"}, "37049338": {"CommentCount": "2", "ViewCount": "194", "PostTypeId": "1", "LastEditorUserId": "3147006", "CreationDate": "2016-05-05T11:22:56.627", "LastActivityDate": "2016-05-06T08:47:57.633", "Title": "Segmentation fault when calling derived class method", "AcceptedAnswerId": "37050898", "LastEditDate": "2016-05-05T11:32:23.207", "Id": "37049338", "Score": "-3", "Body": "<p>I have a problem related to designing derived classes with array parameters. I have class B derived from A. And class BB derived from AA with array of B and A respectively...</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A\n{\npublic:\n    A(){}\n    virtual void foo(){std::cout&lt;&lt;\"foo A\\n\";}\n    int idx[3];\n};\n\nclass B: public A\n{\npublic:\n    B():A(){}\n    void foo(){std::cout&lt;&lt;\"foo B\\n\";}\n    int uidx[3];\n};\n\nclass AA\n{\npublic:\n    AA(){}\n    AA(int count){\n        m_count = count;\n        m_a = new A[count];\n    }\n    virtual A* getA(){return m_a;}\n    ~AA(){ delete[] m_a;}\nprotected:\n    A* m_a;\n    int m_count;\n};\n\nclass BB: public AA\n{\npublic:\n    BB(int count):AA()\n    {\n        m_count = count;\n        m_a = new B[count];\n    }\n    B* getA(){return dynamic_cast&lt;B*&gt;(m_a);}\n};\n\nint main()\n{\n    AA* aa = new AA(2);\n    BB* bb = new BB(2);\n    B* b = bb-&gt;getA();\n    B&amp; b0 = *b;\n    b0.idx[0] = 0;\n    b0.idx[1] = 1;\n    b0.idx[2] = 2;\n\n    B&amp; b1 = *(b+1);\n    b1.idx[0] = 2;\n    b1.idx[1] = 3;\n    b1.idx[2] = 4;\n\n    std::cout&lt;&lt;bb-&gt;getA()[1].idx[0]&lt;&lt;\"\\n\"; //prints 2\n    std::cout&lt;&lt;bb-&gt;getA()[1].idx[1]&lt;&lt;\"\\n\"; //prints 3\n    std::cout&lt;&lt;bb-&gt;getA()[1].idx[2]&lt;&lt;\"\\n\"; //prints 4\n\n    AA* cc = static_cast&lt;AA*&gt;(bb);\n    cc-&gt;getA()[0].foo();  //prints foo B\n\n    std::cout&lt;&lt;cc-&gt;getA()[1].idx[0]&lt;&lt;\"\\n\"; //prints 4198624 ??\n    std::cout&lt;&lt;cc-&gt;getA()[1].idx[1]&lt;&lt;\"\\n\"; //prints 0 ??\n    std::cout&lt;&lt;cc-&gt;getA()[1].idx[2]&lt;&lt;\"\\n\"; //prints 2 ??\n\n    cc-&gt;getA()[1].foo();  //segmentation fault\n    delete aa;\n    delete bb;\n    return 0;\n}\n</code></pre>\n<p>After static cast BB to AA I can't access A's with indices more then 0.\nHow to solve this issue?\nThank you.</p>\n", "Tags": "<c++><class><pointers><segmentation-fault><derived>", "OwnerUserId": "3147006", "AnswerCount": "2"}, "37050898": {"ParentId": "37049338", "LastEditDate": "2016-05-05T13:37:22.587", "CommentCount": "2", "CreationDate": "2016-05-05T12:42:00.800", "Score": "0", "LastEditorUserId": "5440453", "PostTypeId": "2", "Id": "37050898", "OwnerUserId": "5440453", "Body": "<p>I can see 2 issues in your code:</p>\n<ol>\n<li>Since your classes are responsible for memory management, I would suggest to make your destructors <code>virtual</code>, because if you, at any point, will try to delete derived class object via base pointer, the destructors of derived classes will not be invoked. It shouldn't be a problem in your <em>current</em> code, but may become a problem in a future.</li>\n</ol>\n<p>I.e:</p>\n<pre><code>int main ()\n    {\n    AA* aa = new BB (2);\n    delete aa;\n    }\n</code></pre>\n<p>Will not call the <code>BB::~BB()</code> in your case.</p>\n<ol start=\"2\">\n<li>The problem that you are noticing, and writing this question about.</li>\n</ol>\n<p>After you cast your variable of type from <code>BB*</code> to <code>AA*</code> (even though, the cast isn't necessary, you can straight-up assign, due to types being covariant) in line:</p>\n<pre><code>AA* cc = dynamic_cast&lt;AA*&gt;(bb);\n</code></pre>\n<p>Your variable <code>cc</code> is treated as if it is of type <code>AA*</code> (it doesn't matter that it has the runtime type of <code>BB*</code>, in general case - you don't know, and should not care about the exact runtime type). On any virtual method call, they are dispatched to the correct type via the use of the vtable.</p>\n<p>And now, why are you getting strange values printed in the console/segmentation fault? What's the result of <code>cc-&gt;getA ()</code>? Since the variable <code>cc</code> is treated as <code>AA*</code>, the return value is <code>A*</code> (as explained above, actual type is <code>B*</code>, but, due to is-a relationship of inheritance is treated as <code>A*</code>). What's the problem, you may ask: The array <code>m_a</code> is the same size in both cases, right?</p>\n<p>Well, not really, to explain that, I would need to explain how array indexing works in C++, and how it is related to sizes of the objects.</p>\n<p>I guess, that I wouldn't shock you, stating that size of object of type <code>B</code> (<code>sizeof (B)</code>), is larger than that of type <code>A</code> (<code>sizeof (A)</code>), since <code>B</code> has everything that <code>A</code> has (due to inheritance), with some stuff of its own. On my machine <code>sizeof(A)</code> = 16 bytes, and <code>sizeof(B)</code> = 28 bytes.</p>\n<p>So, when you create an array, the total amount of space that array takes up is <code>[element_count] * [size of the element]</code> bytes, which seems logical. But, when you need to take an element from an array, it needs to figure, where exactly, that element is, in the memory, in all the space that array is taking up, so it does so, by calculating it. It does so as follows: <code>[start of the array] + [index] * [size of element]</code>.</p>\n<p>And, now we arrive at the source of the problem. You are trying to do <code>cc-&gt;getA ()[1]</code>, but, since <code>cc</code>, under the hood, is <code>BB*</code>, so the size of <code>AA::m_a</code> variable is <code>2 * sizeof (B)</code> (<code>= 2 * 28 = 56</code> on my machine; first objects starts at offset <code>0</code> (<code>0 * sizeof (B)</code>; second at offset <code>28</code> (<code>1 * sizeof(B)</code>)), but since <code>cc-&gt;getA ()</code> gets treated as <code>A*, and you are trying to fetch second element from the array (index 1), it tries to fetch the object from the offset of</code>1 * sizeof (A)`, which, unfortunately, is in the middle of the space reserved to an object, and yet, any values can be printed/anything can happen - undefined behavior is invoked.</p>\n<p>How to fix it? I would fix it by implementing the virtual indexing operators, instead of <code>GetA</code> method on classes <code>AA</code>/<code>BB</code>, as follows:</p>\n<pre><code>class AA\n    {\n    public:\n        ...\n        virtual A&amp; operator[] (int idx)\n            {\n            return m_a[idx];\n            }\n        ...\n    };\n\nclass BB : public AA\n    {\n    public:\n        ...\n        virtual B&amp; operator[] (int idx)\n            {\n            return dynamic_cast&lt;B*&gt;(m_a)[idx];\n            }\n        ...\n    };\n</code></pre>\n<p>But, then you would need to be careful to call the operator on the object itself, and not to a pointer to object:</p>\n<pre><code>std::cout &lt;&lt; cc-&gt;operator[](1).idx[0] &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; cc-&gt;operator[](1).idx[1] &lt;&lt; \"\\n\";\nstd::cout &lt;&lt; cc-&gt;operator[](1).idx[2] &lt;&lt; \"\\n\";\n</code></pre>\n", "LastActivityDate": "2016-05-05T13:37:22.587"}, "bq_ids": {"n4140": {"so_37049338_37049926_0": {"section_id": 6144, "quality": 0.8125, "length": 26}}, "n4659": {"so_37049338_37049926_0": {"section_id": 7640, "quality": 0.84375, "length": 27}}}});