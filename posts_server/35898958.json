post_cb({"35899150": {"ParentId": "35898958", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>In C++98 the variable was unchanged when input failed. This was a disadvantage if you try to input to an uninitialized variable.</p>\n<p>For example:</p>\n<pre><code>int a;\ncin &gt;&gt; a;\ncout &lt;&lt; a;    // UB if input failed!\n</code></pre>\n<p>In later standards the variable will be set to the largest or smallest value possible when the input is outside of that range.</p>\n<hr>\n<p>For <code>operator&gt;&gt;(int&amp; val)</code> the standard says [istream.formatted.arithmetic]:</p>\n<blockquote>\n<p id=\"so_35898958_35899150_0\">The conversion occurs as if performed by the following code fragment (using the same notation as for\n  the preceding code fragment):</p>\n</blockquote>\n<pre><code>typedef num_get&lt;charT,istreambuf_iterator&lt;charT,traits&gt; &gt; numget;\niostate err = ios_base::goodbit;\nlong lval;\nuse_facet&lt;numget&gt;(loc).get(*this, 0, *this, err, lval);\nif (lval &lt; numeric_limits&lt;int&gt;::min()) {\n  err |= ios_base::failbit;\n  val = numeric_limits&lt;int&gt;::min();\n} else if (numeric_limits&lt;int&gt;::max() &lt; lval) {\n  err |= ios_base::failbit;\n  val = numeric_limits&lt;int&gt;::max();\n} else\n  val = static_cast&lt;int&gt;(lval);\nsetstate(err);\n</code></pre>\n</hr>", "OwnerUserId": "597607", "LastEditorUserId": "597607", "LastEditDate": "2016-03-12T10:19:14.813", "Id": "35899150", "Score": "3", "CreationDate": "2016-03-09T18:01:26.237", "LastActivityDate": "2016-03-12T10:19:14.813"}, "35899099": {"ParentId": "35898958", "PostTypeId": "2", "CommentCount": "0", "Body": "<ol>\n<li><p>Your <code>scanf</code>: The behaviour on overflowing a signed integral type in C++ is <em>undefined</em>. It's rather pointless to speculate on what is happening under the hood. \"Overflow as normal\" is particularly meaningless.</p></li>\n<li><p>Your <code>cin</code>: Pre C++03, the <code>x</code> would not have been changed if it could not accommodate the input. So the behaviour of a subsequent <code>cout</code> would have been <em>undefined</em> since you'd be reading back an uninitialised variable. From C++03 onwards, <code>x</code> is capped (or floored) at it largest (or smallest) value if its range would be exceeded. That is what is happening in your second case.</p></li>\n</ol>\n", "OwnerUserId": "2380830", "LastEditorUserId": "2380830", "LastEditDate": "2016-03-09T18:07:21.503", "Id": "35899099", "Score": "2", "CreationDate": "2016-03-09T17:59:10.030", "LastActivityDate": "2016-03-09T18:07:21.503"}, "35898958": {"CommentCount": "1", "ViewCount": "239", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-03-09T17:50:48.333", "LastActivityDate": "2016-03-12T10:19:14.813", "Title": "Unexpected behavior from cin when overflowing int", "AcceptedAnswerId": "35899150", "LastEditDate": "2017-05-23T12:07:13.697", "Id": "35898958", "Score": "1", "Body": "<p>All, I've got some code here that I can't explain the behavior of. It is posted below. I looked at <a href=\"https://stackoverflow.com/questions/3582509/why-does-integer-overflow-cause-errors-with-c-iostreams\">Why does integer overflow cause errors with C++ iostreams?</a>, but it doesn't really answer my question.</p>\n<pre><code>#include &lt;iostream&gt;\n#include&lt;stdio.h&gt;\nusing namespace std;\nint main()\n{\n    int x;\n    scanf(\"%d\", &amp;x);\n    cout &lt;&lt; \"Value of x = \" &lt;&lt; x &lt;&lt; endl;\n    cin &gt;&gt; x;\n    cout &lt;&lt; \"Failure Detected = \" &lt;&lt; cin.fail() &lt;&lt; endl;\n    cout &lt;&lt; \"Value of x = \" &lt;&lt; x &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>So, what I expect this code to do is read in an integer, print out the value of that integer, read in another integer (into the same variable), and print out that integer. If I enter input of 7 and 2, then it works as expected. However, if I enter 2^31 (overflow int by one) for both the first and second input, then the first output will say \"Value of x = -2147483648\" and the second output will say \"Value of x = 2147483647\". cin.fail() will also return true. What is cin doing to the input? I thought that if cin.fail() was true, the value of x should be left unaffected. If not left unaffected, I would expect the value of x to overflow as normal (like scanf does). What's going on with cin here? Why is it capping the value at integer max value?</p>\n<p>Thanks in advance!</p>\n", "Tags": "<c++><overflow><cin>", "OwnerUserId": "2778364", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_35898958_35899150_0": {"section_id": 2190, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_35898958_35899150_0": {"section_id": 2178, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_35898958_35899150_0": {"section_id": 2463, "quality": 0.9230769230769231, "length": 12}}}});