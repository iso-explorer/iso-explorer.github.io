post_cb({"bq_ids": {"n4140": {"so_39869216_39869217_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 7008}}, "n3337": {"so_39869216_39869217_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 6754}}, "n4659": {"so_39869216_39869217_0": {"length": 23, "quality": 0.8846153846153846, "section_id": 8505}}}, "39869216": {"ViewCount": "605", "Body": "<p>The following code compiles and runs, and no warning is emitted by either gcc or clang:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Base {\n    virtual ~Base() = default;\n    virtual std::string const&amp; get() = 0;\n};\n\nstruct Derived: Base {\n    virtual std::string&amp; get() override { return m; }\n    std::string m;\n};\n\nint main()\n{\n    Derived d;\n    d.get() = \"Hello, World\";\n\n    Base&amp; b = d;\n    std::cout &lt;&lt; b.get() &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Is <code>std::string&amp;</code> covariant with <code>std::string const&amp;</code> then?</p>\n", "AcceptedAnswerId": "39869217", "Title": "Can I lose \"constness\" in the return type of an override virtual function?", "CreationDate": "2016-10-05T08:41:44.523", "Id": "39869216", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-10-05T09:15:59.650", "Score": "19", "OwnerUserId": "147192", "Tags": "<c++>", "AnswerCount": "1"}, "39869217": {"Id": "39869217", "PostTypeId": "2", "Body": "<p><strong>Yes</strong></p>\n<p>This is specified in <strong>class.virtual</strong>, in the latest draft (n4606) we see:</p>\n<blockquote>\n<p id=\"so_39869216_39869217_0\"><strong>\u00a710.3 7/</strong> The return type of an overriding function shall be either identical to the return type of the overridden function\n  or <em>covariant</em> with the classes of the functions. If a function <code>D::f</code> overrides a function <code>B::f</code>, the return types\n  of the functions are covariant if they satisfy the following criteria:</p>\n<ul>\n<li>both are pointers to classes, both are lvalue references to classes, or both are rvalue references to classes<sup>111</sup></li>\n<li>the class in the return type of <code>B::f</code> is the same class as the class in the return type of <code>D::f</code>, or is an unambiguous and accessible direct or indirect base class of the class in the return type of <code>D::f</code></li>\n<li>both pointers or references have the same cv-qualification and the class type in the return type of <code>D::f</code> has the same cv-qualification as or less cv-qualification than the class type in the return type of <code>B::f</code>.</li>\n</ul>\n</blockquote>\n<p>Specifically, the last point addresses exactly the case here: it is acceptable for an overriding type to lose the <code>const</code> and/or <code>volatile</code> qualifiers (it cannot, however, gain them).</p>\n<hr>\n<p>Note: as mentioned by <a href=\"https://stackoverflow.com/users/471160/george\">@george</a> above, paragraph 8/ used to prevent this from working with incomplete class types, but this was <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1250\" rel=\"nofollow noreferrer\">since fixed</a>.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2016-10-05T09:15:59.650", "Score": "18", "CreationDate": "2016-10-05T08:41:44.523", "ParentId": "39869216", "CommentCount": "0", "OwnerUserId": "147192", "LastEditDate": "2017-05-23T11:48:21.040"}});