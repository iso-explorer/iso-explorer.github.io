post_cb({"7200917": {"Id": "7200917", "PostTypeId": "2", "Body": "<p>If you look at the expression <code>p[1]</code>, <code>p</code> is a <code>Base*</code> (<code>Base</code> is a completely-defined type) and <code>1</code> is an <code>int</code>, so according to ISO/IEC 14882:2003 5.2.1 [expr.sub] this expression is valid and identical to <code>*((p)+(1))</code>.</p>\n<p>From 5.7 [expr.add] / 5, when an integer is added to a pointer, the result is only well defined when the pointer points to an element of an array object and the result of the pointer arithmetic also points the an element of that array object or one past the end of the array. <code>p</code>, however, does not point to an element of an array object, it points at the base class sub-object of a <code>Derived</code> object. It is the <code>Derived</code> object that is an array member, not the <code>Base</code> sub-object.</p>\n<p>Note that under 5.7 / 4, for the purposes of the addition operator, the <code>Base</code> sub-object can be treated as an array of size one, so technically you can form the address <code>p + 1</code>, but as a \"one past the last element\" pointer, it doesn't point at a <code>Base</code> object and attempting to read from or write to it will cause <em>undefined behavior</em>.</p>\n", "LastActivityDate": "2011-08-26T06:40:37.057", "Score": "4", "CreationDate": "2011-08-26T06:40:37.057", "ParentId": "7197677", "CommentCount": "2", "OwnerUserId": "19563"}, "7197875": {"Id": "7197875", "PostTypeId": "2", "Body": "<p>The standard doesn't disallow (2), but it's dangerous nevertheless.</p>\n<p>The problem is that doing <code>p[1]</code> means adding <code>sizeof(Base)</code> to the base address <code>p</code>, and using the data at that memory location as an instance of <code>Base</code>. But chances are very high that <code>sizeof(Base)</code> is smaller than <code>sizeof(Derived)</code>, so you'll be interpreting a block of memory starting in the middle of a <code>Derived</code> object, as a <code>Base</code> object.</p>\n<p>More information in <a href=\"http://www.parashift.com/c++-faq-lite/proper-inheritance.html#faq-21.4\" rel=\"nofollow\">C++ FAQ Lite 21.4</a>.</p>\n", "LastActivityDate": "2011-08-25T22:15:26.330", "Score": "1", "CreationDate": "2011-08-25T22:15:26.330", "ParentId": "7197677", "CommentCount": "0", "OwnerUserId": "822669"}, "bq_ids": {"n4140": {"so_7197677_7197677_1": {"length": 41, "quality": 1.0, "section_id": 6107}, "so_7197677_7197878_0": {"length": 32, "quality": 0.9696969696969697, "section_id": 3233}, "so_7197677_7197677_0": {"length": 41, "quality": 0.9318181818181818, "section_id": 41}}, "n3337": {"so_7197677_7197677_1": {"length": 41, "quality": 1.0, "section_id": 5873}, "so_7197677_7197677_0": {"length": 41, "quality": 0.9318181818181818, "section_id": 38}, "so_7197677_7197878_0": {"length": 32, "quality": 0.9696969696969697, "section_id": 3106}}, "n4659": {"so_7197677_7197677_1": {"length": 41, "quality": 1.0, "section_id": 7604}, "so_7197677_7197878_0": {"length": 32, "quality": 0.9696969696969697, "section_id": 3990}, "so_7197677_7197677_0": {"length": 41, "quality": 0.9318181818181818, "section_id": 41}}}, "7197878": {"Id": "7197878", "PostTypeId": "2", "Body": "<p>(3) leads to undefined behaviour, but it is not ill-formed strictly speaking. <em>Ill-formed</em> means that a C++ program is not constructed according to the syntax rules, diagnosable semantic rules, and the One Definition Rule.</p>\n<p>Same for (2), it is well-formed, but it does not do what you have probably expected. According to \u00a78.3.4/6:</p>\n<blockquote>\n<p id=\"so_7197677_7197878_0\">Except where it has been declared for a class (13.5.5), the subscript operator [] is interpreted in such a way\n  that E1[E2] is identical to *((E1)+(E2)). Because of the conversion rules that apply to +, if E1 is an\n  array and E2 an integer, then E1[E2] refers to the E2-th member of E1. Therefore, despite its asymmetric\n  appearance, subscripting is a commutative operation.</p>\n</blockquote>\n<p>So in (2) you will get the address which is the result of <code>p+sizeof(Base)*1</code> when you probably wanted to get the address <code>p+sizeof(Derived)*1</code>.</p>\n", "LastEditorUserId": "123111", "LastActivityDate": "2011-08-25T22:21:06.187", "Score": "3", "CreationDate": "2011-08-25T22:16:04.470", "ParentId": "7197677", "CommentCount": "2", "LastEditDate": "2011-08-25T22:21:06.187", "OwnerUserId": "123111"}, "7197677": {"ViewCount": "2480", "Body": "<p>Following a <a href=\"https://stackoverflow.com/questions/7196172/interview-question-couldnt-answer-it-today\">question</a> asked here earlier today and multitudes of similary themed questions, I'm here to ask about this problem from stadard's viewpoint.</p>\n<pre><code>struct Base\n{\n  int member;\n};\n\nstruct Derived : Base\n{\n  int another_member;\n};\n\nint main()\n{\n  Base* p = new Derived[10]; // (1)\n  p[1].member = 42; // (2)\n  delete[] p; // (3)\n}\n</code></pre>\n<p>According to standard <code>(1)</code> is well-formed, because <code>Dervied*</code> (which is the result of <em>new-expression</em>) can be implicitly converted to <code>Base*</code> (C++11 draft, \u00a74.10/3):</p>\n<blockquote>\n<p id=\"so_7197677_7197677_0\">A prvalue of type \u201cpointer to <em>cv</em> D\u201d, where D is a class type, can be\n  converted to a prvalue of type \u201cpointer to <em>cv</em> B\u201d, where B is a base\n  class (Clause 10) of D. If B is an inaccessible (Clause 11) or\n  ambiguous (10.2) base class of D, a program that necessitates this\n  conversion is ill-formed. The result of the conversion is a pointer to\n  the base class subobject of the derived class object. The null pointer\n  value is converted to the null pointer value of the destination type.</p>\n</blockquote>\n<p><code>(3)</code> leads to undefined behaviour because of \u00a75.3.5/3:</p>\n<blockquote>\n<p id=\"so_7197677_7197677_1\">In the first alternative (<em>delete object</em>), if the static type of the\n  object to be deleted is different from its dynamic type, the static\n  type shall be a base class of the dynamic type of the object to be\n  deleted and the static type shall have a virtual destructor or the\n  behavior is undefined. In the second alternative (<em>delete array</em>) if the\n  dynamic type of the object to be deleted differs from its static type,\n  the behavior is undefined.</p>\n</blockquote>\n<p>Is <code>(2)</code> legal according to standard or does it lead to ill-formed program or undefined behaviour?</p>\n<p><em>edit: Better wording</em></p>\n", "AcceptedAnswerId": "7200917", "Title": "Base pointer to array of derived objects", "CreationDate": "2011-08-25T21:53:00.700", "Id": "7197677", "CommentCount": "8", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:43:59.230", "LastEditorUserId": "-1", "LastActivityDate": "2013-05-04T22:29:05.350", "Score": "11", "OwnerUserId": "700253", "Tags": "<c++><standards>", "AnswerCount": "4"}, "16379519": {"Id": "16379519", "PostTypeId": "2", "Body": "<pre><code>p[1].member = 42; \n</code></pre>\n<p>is well formed. Static type for <code>p</code> is <code>Derived</code> and dynamic type is <code>Base</code>. <code>p[1]</code> is equivalent to <code>*(p+1)</code> which seems a valid and is a pointer to first element of dynamic type <code>Base</code> in array. </p>\n<p>However, <code>*(p+1)</code> in fact refers to an array member of type <code>Derived</code>. Code <code>p[1].member = 42;</code> shows you think you are referring to an array member with type <code>Base</code>.</p>\n", "LastEditorUserId": "1141493", "LastActivityDate": "2013-05-04T22:29:05.350", "Score": "0", "CreationDate": "2013-05-04T22:22:55.667", "ParentId": "7197677", "CommentCount": "0", "LastEditDate": "2013-05-04T22:29:05.350", "OwnerUserId": "1141493"}});