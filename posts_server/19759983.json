post_cb({"19759983": {"CommentCount": "1", "ViewCount": "455", "PostTypeId": "1", "LastEditorUserId": "2167655", "CreationDate": "2013-11-04T00:31:21.753", "LastActivityDate": "2013-11-06T19:38:24.673", "Title": "What does C++11 consider to be a \"thread\"?", "FavoriteCount": "2", "LastEditDate": "2013-11-05T03:39:49.830", "Id": "19759983", "Score": "12", "Body": "<p>C++11 has some notion of threads. For example, it defines a new storage specifier <strong><code>thread_local</code></strong>, and specifies that for variables with this storage specifier, \"there is a distinct object or reference per thread\" [basic.stc.thread].</p>\n<p>What is considered to be a \"thread\" for this purpose? Is it only threads created using the standard thread library (i.e. those represented by <code>std::thread</code> objects)? What about threads created by other means (for example, by using pthreads directly on Linux)? What if I use a library that provides user-space threads - does each of those get its own copies of <code>thread_local</code> objects (I don't really see how that could be implemented)?</p>\n<p>If the answer is \"it's implementation-defined what is considered to be a thread for purposes such as <code>thread_local</code>\", could someone give an example of how one well-known implementation defines this?</p>\n", "Tags": "<c++><multithreading><c++11><language-lawyer><thread-local-storage>", "OwnerUserId": "141719", "AnswerCount": "3"}, "19781528": {"ParentId": "19759983", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>C++11 \u00a71.10/1 defines the terms:</p>\n<blockquote>\n<p id=\"so_19759983_19781528_0\">A <em>thread of execution</em> (also known as a <em>thread</em>) is a single flow of control within a program, including the initial invocation of a specific top-level function, and recursively including every function invocation subsequently executed by the thread. [ <em>Note:</em> When one thread creates another, the initial call to the top-level function of the new thread is executed by the new thread, not by the creating thread. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>The italicized terms indicate that this is definitive. You could argue that this definition is mathematically deficient, because each function invocation defines a new thread, but that's just obviously wrong. They mean <em>maximal</em> single flow of control, otherwise the non-normative note would cancel the effect of the normative \"recursively including\" text.</p>\n<p>From the standpoint of the core language, it is merely incidental that <code>std::thread</code> causes such a thing to exist.</p>\n<blockquote>\n<p id=\"so_19759983_19781528_1\">What if I use a library that provides user-space threads - does each of those get its own copies of <code>thread_local</code> objects (I don't really see how that could be implemented)?</p>\n</blockquote>\n<p>There is no way to write such a library without kernel calls. In all likelihood all threads in your process are already represented a high-level abstraction such as pthreads, just to satisfy the kernel. The C++ standard library is likely written against the native threading library to \"just work\" without additional glue.</p>\n<p>For example, <code>thread_local</code> objects are initialized at first access rather than when each new thread starts, so the compiler just has to insert a query based on <code>pthread_self</code> to access and perhaps initialize. Initialization would register a destructor with the <code>pthread_cleanup</code> facility.</p>\n<p>What is implementation-defined here is whether the pre-existing native library is compatible with C++. Supposing they provide that, and it's something customers would tend to want, all other threading libraries built atop it will be automatically compatible barring some other conflict.</p>\n", "OwnerUserId": "153285", "LastEditorUserId": "153285", "LastEditDate": "2013-11-05T04:20:35.910", "Id": "19781528", "Score": "3", "CreationDate": "2013-11-05T03:38:19.167", "LastActivityDate": "2013-11-05T04:20:35.910"}, "19760125": {"ParentId": "19759983", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>Only components from the thread support library count because of these quotes, or <code>main</code> which the standard states runs in its own thread of execution.  </p>\n<blockquote>\n<p id=\"so_19759983_19760125_0\">1 The following subclauses describe components to create and manage <strong>threads (1.10)</strong>, perform mutual exclusion, and communicate conditions and values between threads, as summarized in Table 148.  </p>\n</blockquote>\n<p>The link to 1.10 implies that the threads being spoken about are these.  </p>\n<blockquote>\n<p id=\"so_19759983_19760125_1\">1 A thread of execution (also known as a thread) is a single flow of control within a program, including the initial ...  </p>\n</blockquote>\n<p>Therefore it seems to me <em>threads</em> only refer to the stdlib threads (meaning std::thread and anything the thread support library does internally). Of course <code>thread_local</code> in many cases could end up working with the native threads (especially when you consider on a specific system you don't usually have more than one choice for implementing threads)  but as far as I can tell the standard makes no guarantee.</p>\n", "OwnerUserId": "2167655", "LastEditorUserId": "2167655", "LastEditDate": "2013-11-05T03:03:08.457", "Id": "19760125", "Score": "3", "CreationDate": "2013-11-04T00:54:23.053", "LastActivityDate": "2013-11-05T03:03:08.457"}, "bq_ids": {"n4140": {"so_19759983_19760125_1": {"section_id": 5812, "quality": 0.8181818181818182, "length": 9}, "so_19759983_19781528_0": {"section_id": 5812, "quality": 0.8809523809523809, "length": 37}, "so_19759983_19760125_0": {"section_id": 2657, "quality": 0.8, "length": 16}}, "n3337": {"so_19759983_19760125_1": {"section_id": 5585, "quality": 0.8181818181818182, "length": 9}, "so_19759983_19781528_0": {"section_id": 5585, "quality": 0.8809523809523809, "length": 37}, "so_19759983_19760125_0": {"section_id": 2620, "quality": 0.8, "length": 16}}, "n4659": {"so_19759983_19760125_1": {"section_id": 7275, "quality": 0.8181818181818182, "length": 9}, "so_19759983_19781528_0": {"section_id": 7275, "quality": 0.8809523809523809, "length": 37}, "so_19759983_19760125_0": {"section_id": 3397, "quality": 0.8, "length": 16}}}, "19760660": {"ParentId": "19759983", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The standard does not describe how threads produced by other libraries and system calls behave.  They are, as far as the standard is concerned, undefined in their behavior.  There is no other way, within C++ proper, to create multiple threads: such libraries or system calls do things that are not standardized by the C++ standard.</p>\n<p>Now, each such library and system call will behave in ways defined by its own specs.  Quite often, the C++ <code>std::thread</code> will even be built on top of such libraries or system calls.  How exactly the interaction works is not specified.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2013-11-06T19:38:24.673", "Id": "19760660", "Score": "0", "CreationDate": "2013-11-04T02:12:27.520", "LastActivityDate": "2013-11-06T19:38:24.673"}});