post_cb({"bq_ids": {"n4140": {"so_40707273_40707459_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 32}}, "n3337": {"so_40707273_40707459_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 29}}, "n4659": {"so_40707273_40707459_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 32}}}, "40707273": {"ViewCount": "35", "Body": "<p>I'm trying to convert a byte array to integer:</p>\n<pre><code>QByteArray b = QByteArray::fromHex(\"00008000\");\nquint32 result = b[3];\nresult += b[2] &lt;&lt; 8;\nresult += b[1] &lt;&lt; 16;\nresult += b[0] &lt;&lt; 24;\n</code></pre>\n<p>but I'm getting <code>4294934528</code> instead of <code>32768</code>. What is the problem here?</p>\n", "AcceptedAnswerId": "40707459", "Title": "QByteArray to Integer conversion produces incorrect results", "CreationDate": "2016-11-20T17:46:24.273", "Id": "40707273", "CommentCount": "0", "LastEditDate": "2016-11-20T18:29:31.217", "PostTypeId": "1", "LastEditorUserId": "1446689", "LastActivityDate": "2016-11-20T18:29:31.217", "Score": "0", "OwnerUserId": "1446689", "Tags": "<c++><qt5><qbytearray>", "AnswerCount": "1"}, "40707459": {"Id": "40707459", "PostTypeId": "2", "Body": "<p><a href=\"http://doc.qt.io/qt-5/qbytearray.html\" rel=\"nofollow noreferrer\"><code>QByteArray</code></a> is an array of <code>char</code>s. Apparently, <code>char</code> on your platform is signed and 8-bit wide. Thus, your problem can be distilled to:</p>\n<pre><code>char c = 0x80;\nquint32 = c &lt;&lt; 8;\n</code></pre>\n<p>The standard mandates that:</p>\n<blockquote>\n<p id=\"so_40707273_40707459_0\">N4606 \u00a7 4.8 [conv.integral] / 3</p>\n<p id=\"so_40707273_40707459_1\">If the destination type is signed, the value is unchanged if it can be\n  represented in the destination type; otherwise, the value is\n  implementation-defined.</p>\n</blockquote>\n<p>In this case (as usual on 2's complement systems), <code>0x80</code> is mapped to <code>std::numeric_limits&lt;char&gt;::min()</code> == <code>-128</code>, which is only logical because they share the same underlying bit pattern.</p>\n<p>Now, <code>-128 &lt;&lt; 8</code> is defined as -128 * 2<sup>8</sup>, which is -32768.</p>\n<p>Finally, conversion from <code>-32768</code> to 32 bit unsigned integer is well defined and yields <code>4294934528</code></p>\n", "LastEditorUserId": "2456565", "LastActivityDate": "2016-11-20T18:14:48.683", "Score": "1", "CreationDate": "2016-11-20T18:00:51.787", "ParentId": "40707273", "CommentCount": "1", "OwnerUserId": "2456565", "LastEditDate": "2016-11-20T18:14:48.683"}});