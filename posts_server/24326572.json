post_cb({"bq_ids": {"n4140": {"so_24326572_24327094_4": {"length": 61, "quality": 0.9384615384615385, "section_id": 5811}, "so_24326572_24327094_3": {"length": 33, "quality": 0.9428571428571428, "section_id": 3326}, "so_24326572_24326720_0": {"length": 33, "quality": 0.9428571428571428, "section_id": 3326}}, "n3337": {"so_24326572_24327094_4": {"length": 61, "quality": 0.9384615384615385, "section_id": 5584}, "so_24326572_24327094_3": {"length": 33, "quality": 0.9428571428571428, "section_id": 3196}, "so_24326572_24326720_0": {"length": 33, "quality": 0.9428571428571428, "section_id": 3196}}, "n4659": {"so_24326572_24327094_4": {"length": 55, "quality": 0.8461538461538461, "section_id": 7272}, "so_24326572_24327094_3": {"length": 33, "quality": 0.9428571428571428, "section_id": 4092}, "so_24326572_24326720_0": {"length": 33, "quality": 0.9428571428571428, "section_id": 4092}}}, "24326720": {"Id": "24326720", "PostTypeId": "2", "Body": "<p>The first code snippet </p>\n<pre><code>testStruct test = {a[++i], b[i]};\n</code></pre>\n<p>is valid (if to add a semicolon), because according to the C++ Standard</p>\n<blockquote>\n<p id=\"so_24326572_24326720_0\">4 Within the initializer-list of a braced-init-list, the\n  initializer-clauses, including any that result from pack expansions\n  (14.5.3), are evaluated in the order in which they appear. That is,\n  every value computation and side effect associated with a given\n  initializer-clause is sequenced before every value computation and\n  side effect associated with any initializer-clause that follows it in\n  the comma-separated list of the initializer-list.</p>\n</blockquote>\n<p>Take into account that the compiler GCC 4.8.1 has (or at least had) a bug that I described </p>\n<p><a href=\"http://cpp.forum24.ru/?1-3-0-00000063-000-0-0-1378892425\" rel=\"nofollow\">here</a>\nThough the description is written in Russian you could it translate using for example service of goofle \"translate\"</p>\n<p>However the second code snippet </p>\n<pre><code>test(a[++i], b[i]);\n</code></pre>\n<p>has undefined behaviour because the order of evaluation of function arguments is unspecified.</p>\n<p>You could write instead</p>\n<pre><code>test( { a[++i], b[i] } );\n</code></pre>\n<p>In this case the expression would be well-formed.</p>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2014-06-20T12:08:12.413", "Score": "2", "CreationDate": "2014-06-20T11:56:31.243", "ParentId": "24326572", "CommentCount": "14", "OwnerUserId": "2877241", "LastEditDate": "2014-06-20T12:08:12.413"}, "24326572": {"ViewCount": "511", "Body": "<p>I -believe- that what I'm trying to do is probably valid because it is separated in both instances by a comma (not a typical assignment), but I have no idea for sure and search isn't bringing up anything about these two specific situations.</p>\n<p>In both cases, I was using the variable as an index for two parallel arrays.</p>\n<pre><code>int a[3] = {10, 20, 30};\nint b[3] = {20, 40, 60};\n</code></pre>\n<p><strong>Situation #1: Initializing a struct for the arrays</strong></p>\n<pre><code>struct testStruct {\n     int t1;\n     int t2;\n};\nint i = 0;\ntestStruct test = {a[++i], b[i]}\n</code></pre>\n<p>Expected result of final line: <code>test = {20, 40}</code></p>\n<p><strong>Situation #2: Passing specific values from the arrays as function args</strong></p>\n<pre><code>void testFunc(int t1, int t2) {\n    // do stuff\n}\nint i = 0;\ntest(a[++i], b[i]);\n</code></pre>\n<p>Expected result of final line: <code>test(20, 40)</code></p>\n<p>Is this valid code? And if it is, is it valid in all compilers?</p>\n<p>Is the result what I expect? If so, is it because of the arrays or because of the comma?</p>\n<p>Thanks!</p>\n", "AcceptedAnswerId": "24327094", "Title": "Pre-Increment Operators when Using the Variable on the Same Line", "CreationDate": "2014-06-20T11:48:29.677", "Id": "24326572", "CommentCount": "3", "LastEditDate": "2014-06-21T00:56:22.520", "PostTypeId": "1", "LastEditorUserId": "1708801", "LastActivityDate": "2014-07-02T13:03:54.043", "Score": "4", "OwnerUserId": "3759869", "Tags": "<c++><undefined-behavior><pre-increment>", "AnswerCount": "2"}, "24327094": {"Id": "24327094", "PostTypeId": "2", "Body": "<p>I would advice against using such \"tricks\" in your code in the long term this is maintenance nightmare and is hard to reason about. There are almost always alternatives, for example this code:</p>\n<pre><code>testStruct test = {a[++i], b[i]}\n</code></pre>\n<p>could be changed to:</p>\n<pre><code>++i ;\ntestStruct test = {a[i], b[i]}\n</code></pre>\n<p>So having said that, neither case uses the comma operator in both functions calls and intialization lists the comma is a grammar elements and nothing else.</p>\n<p>Your first situation is well defined although there is some caveats depending on whether this is C++11 or pre C++11. </p>\n<p>In both cases there is a sequence point after each comma, although pre C++11 the order of evaluation is not specified. So we can see this for the pre C++11 case by going to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#430\" rel=\"nofollow\">defect report 430</a> which says:</p>\n<blockquote>\n<p id=\"so_24326572_24327094_0\">A recent GCC bug report (\n  <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=11633\" rel=\"nofollow\">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=11633</a>) asks about the\n  validity of</p>\n<pre><code>int count = 23;   int foo[] = { count++, count++, count++ };\n</code></pre>\n<p id=\"so_24326572_24327094_1\">is this undefined or unspecified or something else?</p>\n</blockquote>\n<p>and the answer is (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_24326572_24327094_2\">I believe the standard is clear that <strong>each initializer expression in\n  the above is a full-expression</strong> (1.9 [intro.execution]/12-13; see also\n  issue 392) and therefore there is a sequence point after each\n  expression (1.9 [intro.execution]/16). I agree that <strong>the standard does\n  not seem to dictate the order in which the expressions are evaluated</strong>,\n  and perhaps it should. Does anyone know of a compiler that would not\n  evaluate the expressions left to right?</p>\n</blockquote>\n<p>In C++11 it is baked in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++11 standard</a> in section <code>8.4.5</code> paragraph which says:</p>\n<blockquote>\n<p id=\"so_24326572_24327094_3\">Within the initializer-list of a braced-init-list, the\n  initializer-clauses, including any that result from pack expansions\n  (14.5.3), <strong>are evaluated in the order in which they appear. That is,\n  every value computation and side effect associated with a given\n  initializer-clause is sequenced before every value computation and\n  side effect</strong> associated with any initializer-clause that follows it in\n  the comma-separated list of the initializer-list.</p>\n</blockquote>\n<p>I am sticking with C++11 going forward since it does not change the answer for the rest of the content, although the wording on sequencing does vary the conclusion is the same.</p>\n<p>The second situation invokes <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow\">undefined behavior</a> since the order of evaluation of arguments to a function are unspecified and their evaluation is indeterminately sequenced with respect to one another. We can see this undefined behavior from section <code>1.9</code> paragraph <em>15</em> which says:</p>\n<blockquote>\n<p id=\"so_24326572_24327094_4\">Except where noted, evaluations of operands of individual operators\n  and of subexpressions of individual expressions are unsequenced. [\n  Note: In an expression that is evaluated more than once during the\n  execution of a program, unsequenced and indeterminately sequenced\n  evaluations of its subexpressions need not be performed consistently\n  in different evaluations. \u2014end note ] The value computations of the\n  operands of an operator are sequenced before the value computation of\n  the result of the operator. <strong>If a side effect on a scalar object is\n  unsequenced relative to either another side effect on the same scalar\n  object or a value computation using the value of the same scalar\n  object, the behavior is undefined</strong>.</p>\n</blockquote>\n<p>and provides the following example:</p>\n<pre><code>f(i = -1, i = -1); // the behavior is undefined\n</code></pre>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-07-02T13:03:54.043", "Score": "4", "CreationDate": "2014-06-20T12:17:47.823", "ParentId": "24326572", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2014-07-02T13:03:54.043"}});