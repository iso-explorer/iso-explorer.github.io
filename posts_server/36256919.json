post_cb({"bq_ids": {"n4140": {"so_36256919_36257114_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 5873}}, "n3337": {"so_36256919_36257114_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 5644}}, "n4659": {"so_36256919_36257114_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 7356}}}, "36257284": {"Id": "36257284", "PostTypeId": "2", "Body": "<p>I think Private and Protected, both work as a access specifier only. Only thing we can achieve that providing access permissions of data to others. And these access permissions decide on the compile time.</p>\n<p>Most use of Private and Protected to achieve Inheritance and Data Encapsulation. just see the below example:</p>\n<pre><code>class Base {\n\nprivate: \n  int MyPrivateInt;\nprotected: \n  int MyProtectedInt;\npublic:\n  int MyPublicInt;\n}\n\nclass Derived : Base\n{\npublic:\n  int foo1()  { return MyPrivateInt;} // Won't compile!\n  int foo2()  { return MyProtectedInt;} // OK  \n  int foo3()  { return MyPublicInt;} // OK\n};\n\nclass Unrelated \n{\nprivate:\n  Base B;\npublic:\n  int foo1()  { return B.MyPrivateInt;} // Won't compile!\n  int foo2()  { return B.MyProtectedInt;} // Won't compile\n  int foo3()  { return B.MyPublicInt;} // OK\n}; \n</code></pre>\n", "LastActivityDate": "2016-03-28T06:40:42.620", "Score": "0", "CreationDate": "2016-03-28T06:40:42.620", "ParentId": "36256919", "CommentCount": "0", "OwnerUserId": "2528226"}, "36256950": {"Id": "36256950", "PostTypeId": "2", "Body": "<p>I don't believe there is any runtime differences between methods/variables with different access levels. It's all enforced at compile time. </p>\n", "LastActivityDate": "2016-03-28T06:12:18.927", "Score": "0", "CreationDate": "2016-03-28T06:12:18.927", "ParentId": "36256919", "CommentCount": "0", "OwnerUserId": "1715829"}, "36257114": {"Id": "36257114", "PostTypeId": "2", "Body": "<p>For the memory layout of a class object, from a given access specifier until the next the compiler has to place the data members at increasing addresses. More generally it has to place the members with the same access level, at increasing addresses. And this is not so for members of different access levels.</p>\n<b>C++11 \u00a79.2/14:</b>\n<blockquote>\n<p id=\"so_36256919_36257114_0\"><strong>\u201d</strong> Nonstatic data members of a (non-union) class with the same access control (Clause 11) are allocated so\n  that later members have higher addresses within a class object. The order of allocation of non-static data\n  members with different access control is unspecified.</p>\n</blockquote>\n<p>That's about the only (influence on) run-time effect, something that can fit the wording \u201cinternal mechanism\u201d, that I know of.</p>\n<p>All the rest, the checking, is at compile time.</p>\n", "LastEditorUserId": "464581", "LastActivityDate": "2016-03-28T06:33:03.947", "Score": "1", "CreationDate": "2016-03-28T06:26:48.363", "ParentId": "36256919", "CommentCount": "0", "LastEditDate": "2016-03-28T06:33:03.947", "OwnerUserId": "464581"}, "36256919": {"ViewCount": "51", "Body": "<p>Internal mechanism of private and protected keywords in C++. How they restrict member variables accesses.</p>\n", "Title": "How private and protected is implemented in C++", "CreationDate": "2016-03-28T06:09:24.177", "LastActivityDate": "2016-03-28T06:40:42.620", "CommentCount": "1", "PostTypeId": "1", "ClosedDate": "2016-03-28T08:25:07.270", "Id": "36256919", "Score": "-4", "OwnerUserId": "2689922", "Tags": "<c++>", "AnswerCount": "3"}});