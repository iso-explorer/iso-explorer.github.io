post_cb({"bq_ids": {"n4140": {"so_2392515_2407544_0": {"length": 21, "quality": 1.0, "section_id": 305}, "so_2392515_2412209_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 306}, "so_2392515_2407544_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 306}}, "n3337": {"so_2392515_2407544_0": {"length": 21, "quality": 1.0, "section_id": 296}, "so_2392515_2412209_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 297}, "so_2392515_2407544_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 297}}, "n4659": {"so_2392515_2407544_0": {"length": 21, "quality": 1.0, "section_id": 312}, "so_2392515_2412209_0": {"length": 15, "quality": 0.8823529411764706, "section_id": 313}, "so_2392515_2407544_1": {"length": 16, "quality": 0.9411764705882353, "section_id": 313}}}, "2412209": {"Id": "2412209", "PostTypeId": "2", "Body": "<p>In ISO/IEC 14882 it's nearly the same (14.8.2.1):</p>\n<blockquote>\n<ul>\n<li>If P is a class, and P has the form template-id, then A can be a\n  derived class of the deduced A.\n  Likewise, if P is a pointer to a class\n  of the form template-id, A can be a\n  pointer to a derived class pointed to\n  by the deduced A.</li>\n</ul>\n<p id=\"so_2392515_2412209_0\">These altenatives are considered only if type deduction\n  would otherwise fail. If they yield\n  more than one possible deduced A, the\n  type deduction fails.</p>\n</blockquote>\n<p>So I agree with Jan. Anybody here who does not?</p>\n", "LastActivityDate": "2010-03-09T20:12:00.567", "CommentCount": "1", "CreationDate": "2010-03-09T20:12:00.567", "ParentId": "2392515", "Score": "0", "OwnerUserId": "287715"}, "2392515": {"ViewCount": "410", "Body": "<p>The following code works with Visual Studio 2008 but not with GCC/G++ 4.3.4 20090804. Which behaviour is - according to the C++ standard - correct?</p>\n<pre><code>template &lt;int N&gt;\nstruct A : A&lt;N-1&gt; {};\n\ntemplate &lt;&gt;\nstruct A&lt;0&gt; {};\n\nstruct B : A&lt;1&gt; {};\n\ntemplate &lt;int N&gt;\nvoid Func(const A&lt;N&gt; &amp;a) {}\n\nint main()\n{\n    A&lt;1&gt; a;   //is derived from A&lt;0&gt;\n    Func(a);  //vs2008: ok, g++: ok\n              //Comeau: ok\n\n    B b;      //is derived from A&lt;1&gt;\n    Func(b);  //vs2008: ok, g++: error, no matching function for call to Func(B&amp;)\n              //Comeau: error: no instance of function template \"Func\" matches the\n              //        argument list. The argument types that you used are: (B).\n\n    return 0;\n}\n</code></pre>\n<p>If I overload Func() with</p>\n<pre><code>void Func(const A&lt;0&gt; &amp;a) { std::cout &lt;&lt; '0'; }\nvoid Func(const A&lt;1&gt; &amp;a) { std::cout &lt;&lt; '1'; }\n</code></pre>\n<p>always the latter one is called (as expected). So I would also expect the templated function to be called with N=1 because A&lt;1&gt; is direct base of B. Is this assumption really wrong?</p>\n", "AcceptedAnswerId": "2407544", "Title": "GCC/VS2008: Different behaviour of function call when templated base class is derived from itself", "CreationDate": "2010-03-06T12:58:52.327", "Id": "2392515", "CommentCount": "6", "LastEditDate": "2010-03-08T11:45:05.737", "PostTypeId": "1", "LastEditorUserId": "287715", "LastActivityDate": "2010-03-09T20:12:00.567", "Score": "13", "OwnerUserId": "287715", "Tags": "<c++><visual-studio-2008><inheritance><gcc><templates>", "AnswerCount": "2"}, "2407544": {"Id": "2407544", "PostTypeId": "2", "Body": "<p>After some digging through N3035, I found this in section 14.9.2.1.4:</p>\n<blockquote>\n<p id=\"so_2392515_2407544_0\">If P is a class and P has the form simple-template-id, then the transformed A can be a derived class of the deduced A. Likewise, if P is a pointer to a class of the form simple-template-id, the transformed A can be a pointer to a derived class pointed to by the deduced A.</p>\n</blockquote>\n<p>However in 14.9.2.1.5, it says:</p>\n<blockquote>\n<p id=\"so_2392515_2407544_1\">These alternatives are considered only if type deduction would otherwise fail. If they yield more than one possible deduced A, the type deduction fails.</p>\n</blockquote>\n<p>Which is the case: both <code>A&lt;1&gt;</code> and <code>A&lt;0&gt;</code> are considered base classes for <code>B</code>.</p>\n<p>I guess this means a no for Visual Studio (at least, if the current standard says the same: exercise for the reader).</p>\n", "LastActivityDate": "2010-03-09T08:24:57.703", "CommentCount": "1", "CreationDate": "2010-03-09T08:24:57.703", "ParentId": "2392515", "Score": "4", "OwnerUserId": "280300"}});