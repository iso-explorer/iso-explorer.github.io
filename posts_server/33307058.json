post_cb({"bq_ids": {"n4140": {"so_33307058_33307090_0": {"length": 18, "quality": 1.0, "section_id": 31}}, "n3337": {"so_33307058_33307090_0": {"length": 18, "quality": 1.0, "section_id": 28}}, "n4659": {"so_33307058_33307090_0": {"length": 18, "quality": 1.0, "section_id": 31}}}, "33307090": {"Id": "33307090", "PostTypeId": "2", "Body": "<p>Yes, the value is defined and independent of the representations used. [conv.integral]/2:</p>\n<blockquote>\n<p id=\"so_33307058_33307090_0\">If the destination type is unsigned, the resulting value is the least\n  unsigned integer congruent to the source integer (modulo 2<sup><em>n</em></sup> where <em>n</em>\n  is the number of bits used to represent the unsigned type).</p>\n</blockquote>\n<p>Obviously, the size of the destination type matters, though; <code>long long</code> to <code>unsigned char</code> might yield a different value than <code>long long</code> to <code>unsigned int</code>.</p>\n", "LastActivityDate": "2015-10-23T16:19:03.767", "CommentCount": "0", "CreationDate": "2015-10-23T16:19:03.767", "ParentId": "33307058", "Score": "3", "OwnerUserId": "3647361"}, "33307058": {"ViewCount": "278", "Body": "<p>In C++, does the result of the conversion of a signed integral value, to an unsigned integral value, that can be of two different sizes (ex: <code>short int</code> to <code>unsigned long long int</code>, or <code>long long int</code> to <code>unsigned char</code>) is well defined by the standard and platform independent (regardless of how signed integer are represented for example)?</p>\n", "AcceptedAnswerId": "33307090", "Title": "Signed to unsigned conversion in C++", "CreationDate": "2015-10-23T16:16:38.113", "Id": "33307058", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-10-23T16:19:25.863", "Score": "2", "OwnerUserId": "882932", "Tags": "<c++><integer><standards><c++14><signed>", "AnswerCount": "1"}});