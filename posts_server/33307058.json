post_cb({"33307058": {"CommentCount": "2", "ViewCount": "278", "CreationDate": "2015-10-23T16:16:38.113", "LastActivityDate": "2015-10-23T16:19:25.863", "Title": "Signed to unsigned conversion in C++", "AcceptedAnswerId": "33307090", "PostTypeId": "1", "Id": "33307058", "Score": "2", "Body": "<p>In C++, does the result of the conversion of a signed integral value, to an unsigned integral value, that can be of two different sizes (ex: <code>short int</code> to <code>unsigned long long int</code>, or <code>long long int</code> to <code>unsigned char</code>) is well defined by the standard and platform independent (regardless of how signed integer are represented for example)?</p>\n", "Tags": "<c++><integer><standards><c++14><signed>", "OwnerUserId": "882932", "AnswerCount": "1"}, "33307090": {"ParentId": "33307058", "CommentCount": "0", "Body": "<p>Yes, the value is defined and independent of the representations used. [conv.integral]/2:</p>\n<blockquote>\n<p id=\"so_33307058_33307090_0\">If the destination type is unsigned, the resulting value is the least\n  unsigned integer congruent to the source integer (modulo 2<sup><em>n</em></sup> where <em>n</em>\n  is the number of bits used to represent the unsigned type).</p>\n</blockquote>\n<p>Obviously, the size of the destination type matters, though; <code>long long</code> to <code>unsigned char</code> might yield a different value than <code>long long</code> to <code>unsigned int</code>.</p>\n", "OwnerUserId": "3647361", "PostTypeId": "2", "Id": "33307090", "Score": "3", "CreationDate": "2015-10-23T16:19:03.767", "LastActivityDate": "2015-10-23T16:19:03.767"}, "bq_ids": {"n4140": {"so_33307058_33307090_0": {"section_id": 31, "quality": 1.0, "length": 18}}, "n3337": {"so_33307058_33307090_0": {"section_id": 28, "quality": 1.0, "length": 18}}, "n4659": {"so_33307058_33307090_0": {"section_id": 31, "quality": 1.0, "length": 18}}}});