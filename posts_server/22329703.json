post_cb({"22329703": {"ViewCount": "111", "Body": "<p>Specifically, say I have:</p>\n<pre><code>struct X { X(int i) { cout &lt;&lt; i; } };\nint f() { cout &lt;&lt; 'f'; return 0; }\nint g() { cout &lt;&lt; 'g'; return 1; }\n\nstruct Z {\n    Z() : a(f()), b(g()) {}\n    X a, b;\n};\n\nint main() { Z z; cout &lt;&lt; '\\n'; }\n</code></pre>\n<p>I know that the constructors of the members are guaranteed to be invoked in the order they are defined in the <code>struct</code>, so <code>0</code> will be printed before <code>1</code>.\nBut how about the evaluation of their arguments? Is it guaranteed to be:</p>\n<pre><code>f0g1\n</code></pre>\n<p>? Or, perhaps,</p>\n<pre><code>fg01\n</code></pre>\n<p>and</p>\n<pre><code>gf01\n</code></pre>\n<p>are also valid outputs?</p>\n<p>References to the standard are appreciated.</p>\n", "AcceptedAnswerId": "22330014", "Title": "Are evaluations of expressions in member initialization are sequenced with respect to each other?", "CreationDate": "2014-03-11T15:09:36.883", "Id": "22329703", "CommentCount": "2", "LastEditDate": "2014-03-11T18:15:01.540", "PostTypeId": "1", "LastEditorUserId": "1708801", "LastActivityDate": "2014-03-20T20:23:00.437", "Score": "4", "OwnerUserId": "277176", "Tags": "<c++><constructor><order><member><language-lawyer>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_22329703_22329975_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 434}, "so_22329703_22330014_1": {"length": 18, "quality": 1.0, "section_id": 5810}, "so_22329703_22330014_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 434}}, "n3337": {"so_22329703_22329975_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 426}, "so_22329703_22330014_1": {"length": 18, "quality": 1.0, "section_id": 5583}, "so_22329703_22330014_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 426}}, "n4659": {"so_22329703_22329975_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 452}, "so_22329703_22330014_1": {"length": 18, "quality": 1.0, "section_id": 7271}, "so_22329703_22330014_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 452}}}, "22330014": {"Id": "22330014", "PostTypeId": "2", "Body": "<p>In <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow noreferrer\">C++11 draft standard</a> each member initializer is a full-expression so all side effects have to take effect before the next one is evaluated.</p>\n<p>Section <code>12.6.2</code> <em>Initializing bases and members</em> paragraph <em>7</em> says:</p>\n<blockquote>\n<p id=\"so_22329703_22330014_0\">[...]The initialization performed by each mem-initializer constitutes a full-expression. Any\n  expression in a mem-initializer is evaluated as part of the full-expression that performs the initialization.[...]</p>\n</blockquote>\n<p>and section <code>1.9</code> <em>Program execution</em> paragraph <em>14</em> says:</p>\n<blockquote>\n<p id=\"so_22329703_22330014_1\">Every value computation and side effect associated with a full-expression is sequenced before every value computation and side effect associated with the next full-expression to be evaluated.</p>\n</blockquote>\n<p>The relevant grammar from section <code>12.6.2</code> is as follows:</p>\n<pre><code>ctor-initializer:\n   : mem-initializer-list\nmem-initializer-list:\n   mem-initializer ...opt\n   mem-initializer , mem-initializer-list ...opt\n[...]\n</code></pre>\n<p>Pre <em>C++11</em> the same wording on each <em>mem-initializer</em> being a full-expression is not there, at least not in the oldest draft standard available <a href=\"http://www.open-std.org/Jtc1/sc22/wg21/docs/papers/2005/n1804.pdf\" rel=\"nofollow noreferrer\">1804</a>. But as far as I can tell the same logic I used in <a href=\"https://stackoverflow.com/a/19881804/1708801\">Are multiple mutations of the same variable within initializer lists undefined behavior pre C++11</a> applies in this case as well and so we should expect the same behavior pre <em>C++11</em> as well.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-03-12T00:15:26.750", "Score": "5", "CreationDate": "2014-03-11T15:22:53.527", "ParentId": "22329703", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2017-05-23T12:05:29.267"}, "22329975": {"Id": "22329975", "PostTypeId": "2", "Body": "<p>According to the C++ Standard</p>\n<blockquote>\n<p id=\"so_22329703_22329975_0\">The initialization performed by each mem-initializer constitutes a\n  full-expression. Any expression in a mem-initializer is evaluated as\n  part of the full-expression that performs the initialization</p>\n</blockquote>\n<p>So at first there will be executed full expression a(f()) and after that the full expression b(g()) .</p>\n<p>As the result output has to be</p>\n<pre><code>f0g1\n</code></pre>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-03-20T20:23:00.437", "Score": "2", "CreationDate": "2014-03-11T15:21:23.037", "ParentId": "22329703", "CommentCount": "0", "OwnerUserId": "2877241", "LastEditDate": "2014-03-20T20:23:00.437"}});