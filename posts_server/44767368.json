post_cb({"44767368": {"ViewCount": "118", "Body": "<p>According to the answers in <a href=\"https://stackoverflow.com/questions/25183378/in-c-is-stdend-guaranteed-to-be-o1-for-all-container-types\">this</a> and <a href=\"https://stackoverflow.com/questions/9768447/can-end-be-a-costly-operation-for-stl-containers\">this</a> question, the C++ standard states in \u00a7 23.2.1 that <code>end()</code> is of constant time complexity for all stl containers.</p>\n<p>If I am understanding correctly:</p>\n<ol>\n<li><code>std::forward_list</code> only knows about it's first element, and each of the list entries only know about the next element.</li>\n<li>lists are non-contiguous in memory</li>\n<li><code>a.begin() == a.end()</code> is true for empty containers <code>a</code></li>\n<li><code>end()</code> is supposed to be an iterator pointing to 'one past the end of a container'</li>\n</ol>\n<p>So while working on some loops over <code>forward_list</code>s, I was wondering: </p>\n<p><em>How can end() be of constant time complexity (i.e. not advance to 'one past the end') in case of forward_list?</em></p>\n<p>I looked in <code>forward_list.cpp</code> and found the declaration</p>\n<pre><code>iterator       end() _NOEXCEPT\n    {return       iterator(nullptr);}\n</code></pre>\n<p>That makes sense for the constant time requirement, but not for the - admittedly vage - rule corresponding to point 4 above.</p>\n<p>So some questions remain:</p>\n<ul>\n<li>What is 'one past the end' supposed to mean for non-contiguous storage?</li>\n<li>How does <code>nullptr</code> fit the definition of 'one past the end'?</li>\n<li>How is <code>MyForwardList.begin() == MyForwardList.end()</code> true if <code>MyForwardList</code> is empty?</li>\n<li>Why isn't  <code>end()</code> always defined as <code>nullptr</code>?</li>\n</ul>\n", "AcceptedAnswerId": "44767469", "Title": "In what way does end() point to 'one past the end' in non-contiguous containers?", "CreationDate": "2017-06-26T19:33:45.200", "Id": "44767368", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2017-06-26T19:48:56.280", "Score": "3", "OwnerUserId": "7416115", "Tags": "<c++><stl>", "AnswerCount": "4"}, "44767459": {"Id": "44767459", "PostTypeId": "2", "Body": "<p>\"One past the end\" is defined in terms of iterator traversal, not memory locations. An <code>end</code> iterator is what you get when you take an iterator to the last element and increment it (or <code>begin</code> an empty container).</p>\n<p><code>std::forward_list</code>'s end iterator pointing at <code>nullptr</code> makes sense: in the implementation the last node probably has a <code>nullptr</code> next node, and following that link yields indeed the <code>end</code> iterator. <code>std::vector</code>'s <code>end</code> might physically point past the storage for the same reason.</p>\n", "LastActivityDate": "2017-06-26T19:40:23.440", "Score": "5", "CreationDate": "2017-06-26T19:40:23.440", "ParentId": "44767368", "CommentCount": "0", "OwnerUserId": "3233393"}, "44767469": {"Id": "44767469", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_44767368_44767469_0\">What is <code>one past the end</code> supposed to mean for non-contiguous storage?</p>\n</blockquote>\n<p>It means whatever you'd get if you incremented an iterator to the last element.</p>\n<blockquote>\n<p id=\"so_44767368_44767469_1\">How does <code>nullptr</code> fit the definition of 'one past the end'?</p>\n</blockquote>\n<p>If that's what you get if you increment an iterator to the last element, then it fits the definition.</p>\n<blockquote>\n<p id=\"so_44767368_44767469_2\">How is <code>MyForwardList.begin() == MyForwardList.end()</code> true if MyForwardList is empty?</p>\n</blockquote>\n<p>For an empty list, they both return the same thing. Likely an \"empty\" iterator.</p>\n<blockquote>\n<p id=\"so_44767368_44767469_3\">Why isn't <code>end()</code> always defined as <code>nullptr</code>?</p>\n</blockquote>\n<p>Because sometimes that's not the most convenient way to define it, and so long as you meet the requirements, you can implement it however you want.</p>\n<p>It's basically just a circular definition. The <code>end</code> function returns whatever you'd get if you took an iterator to the last element in the list and incremented it or, for an empty list, returns the same thing <code>begin</code> returns. So long as all these relationships hold, everything works, regardless of what internal values or logic you use to guarantee the relationships.</p>\n", "LastEditorUserId": "721269", "LastActivityDate": "2017-06-26T19:43:46.880", "Score": "6", "CreationDate": "2017-06-26T19:41:16.040", "ParentId": "44767368", "CommentCount": "0", "LastEditDate": "2017-06-26T19:43:46.880", "OwnerUserId": "721269"}, "bq_ids": {"n4140": {"so_44767368_44767469_1": {"length": 5, "quality": 0.625, "section_id": 6143}, "so_44767368_44767477_0": {"length": 5, "quality": 0.625, "section_id": 5634}, "so_44767368_44767506_1": {"length": 5, "quality": 0.625, "section_id": 6143}, "so_44767368_44767477_1": {"length": 18, "quality": 1.0, "section_id": 707}}, "n3337": {"so_44767368_44767477_0": {"length": 5, "quality": 0.625, "section_id": 5417}, "so_44767368_44767469_1": {"length": 5, "quality": 0.625, "section_id": 5907}, "so_44767368_44767506_1": {"length": 5, "quality": 0.625, "section_id": 5907}, "so_44767368_44767477_1": {"length": 18, "quality": 1.0, "section_id": 697}}, "n4659": {"so_44767368_44767477_0": {"length": 5, "quality": 0.625, "section_id": 802}, "so_44767368_44767477_1": {"length": 18, "quality": 1.0, "section_id": 736}}}, "44767506": {"Id": "44767506", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_44767368_44767506_0\">What is 'one past the end' supposed to mean for non-contiguous storage?</p>\n</blockquote>\n<p>Simply the node that the last valid node points to.</p>\n<blockquote>\n<p id=\"so_44767368_44767506_1\">How does <code>nullptr</code> fit the definition of 'one past the end'?</p>\n</blockquote>\n<p>Well, when you build a node based data structure the last valid node will point to <code>nullptr</code> for the next node, that is how you know your at the end.</p>\n<blockquote>\n<p id=\"so_44767368_44767506_2\">How is <code>MyForwardList.begin() == MyForwardList.end()</code> <code>true</code> if <code>MyForwardList</code> is empty?</p>\n</blockquote>\n<p>In an empty list the head is <code>nullptr</code> or the head points to <code>nullptr</code> so comparing <code>nullptr</code> to <code>nullptr</code> is <code>true</code>.</p>\n<blockquote>\n<p id=\"so_44767368_44767506_3\">Why isn't <code>end()</code> always defined as nullptr?</p>\n</blockquote>\n<p>Because there is no requirement that your using pointers.</p>\n", "LastActivityDate": "2017-06-26T19:43:22.307", "Score": "2", "CreationDate": "2017-06-26T19:43:22.307", "ParentId": "44767368", "CommentCount": "0", "OwnerUserId": "4342498"}, "44767477": {"Id": "44767477", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_44767368_44767477_0\"><code>end()</code> is supposed to be an iterator pointing to 'one past the end of a container'.</p>\n</blockquote>\n<p>That's subtly different than what <a href=\"https://timsong-cpp.github.io/cppwp/n3337/container.requirements\" rel=\"nofollow noreferrer\">the standard says</a> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_44767368_44767477_1\"><code>begin()</code> returns an iterator referring to the first element in the container. <code>end()</code> returns an iterator which is the <strong>past-the-end</strong> value for the container. If the container is empty, then <code>begin() == end()</code>;</p>\n</blockquote>\n<p>The standard says \"past-the-end\", not \"one past-the-end\".</p>\n<p>Implementors are free to chose whatever implementation of \"past-the-end\" works for a particular container type.</p>\n", "LastEditorUserId": "434551", "LastActivityDate": "2017-06-26T19:48:56.280", "Score": "5", "CreationDate": "2017-06-26T19:41:44.487", "ParentId": "44767368", "CommentCount": "0", "LastEditDate": "2017-06-26T19:48:56.280", "OwnerUserId": "434551"}});