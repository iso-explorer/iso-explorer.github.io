post_cb({"15612583": {"ParentId": "15612513", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>No. It just means that all local variables from the ambient scope are available for lookup inside the body of the lambda. Only <em>if</em> you refer to a name of an ambient local variable will that variable be captured, and it'll be captured by value.</p>\n<p>The \"capture anything\" shorthands <code>=</code> and <code>&amp;</code> are just syntactic sugar, essentially, telling the compiler to \"figure out what I mean\".</p>\n<hr>\n<p>A formal reference from 5.1.2/11-12:</p>\n<blockquote>\n<p id=\"so_15612513_15612583_0\">If a lambda-expression has an associated <em>capture-default</em> and its <em>compound-statement</em> odr-uses [...] a variable with automatic storage duration and the odr-used entity is not explicitly captured, then the odr-used entity is said to be <em>implicitly captured</em> [...]</p>\n<p id=\"so_15612513_15612583_1\">An entity is <em>captured</em> if it is captured explicitly or implicitly.</p>\n</blockquote>\n<p>Note that \"<em>capture-default</em>\" refers to <code>[=]</code> and <code>[&amp;]</code>. To repeat, specifying a capture-default doesn't capture anything; only odr-using a variable does.</p>\n</hr>", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2013-03-25T10:33:00.130", "Id": "15612583", "Score": "63", "CreationDate": "2013-03-25T10:22:40.767", "LastActivityDate": "2013-03-25T10:33:00.130"}, "15612513": {"CommentCount": "1", "AcceptedAnswerId": "15612583", "PostTypeId": "1", "LastEditorUserId": "469935", "CreationDate": "2013-03-25T10:19:14.497", "LastActivityDate": "2013-03-25T10:41:06.310", "LastEditDate": "2013-03-25T10:21:26.400", "ViewCount": "2117", "FavoriteCount": "5", "Title": "Does [=] imply that all local variables will be copied?", "Id": "15612513", "Score": "61", "Body": "<p>When I write a lambda with <code>[=]</code>, does it mean that all my local variables will be copied into members of the created struct or can I assume that only those will that are actually used in the lambda? For example:</p>\n<pre><code>void f()\n{\n    vector&lt;int&gt; v(10000);\n    const int n = 5;\n    const int DivByNCnt = count_if(istream_iterator&lt;int&gt;(cin), istream_iterator&lt;int&gt;(), \n          [=](int i)\n          {\n             return i % n == 0;\n          });\n}\n</code></pre>\n<p>Which of the following, if any, is true?</p>\n<ul>\n<li>both n and v will be copied</li>\n<li>n will be copied, v will not</li>\n<li>n will be copied, v may or may not be copied depending on the implmenentation/optimization settings.</li>\n</ul>\n<p>Suppose for the argument's sake that vector's copy constructor has side effects. </p>\n", "Tags": "<c++><c++11><lambda><capture>", "OwnerUserId": "469935", "AnswerCount": "2"}, "15612655": {"ParentId": "15612513", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>No! (thankfully)</p>\n<p>You can instrument your code to check whether your compiler actually does it (or not). For example <a href=\"http://liveworkspace.org/code/3HTwkb%243\">gcc 4.8.0</a> appears to be compliant.</p>\n<hr>\n<p>As to what the Standard actually mandates (working backward):</p>\n<blockquote>\n<p id=\"so_15612513_15612655_0\">\u00a75.1.2/14 An entity is <em>captured by copy</em> if it is implicitly captured and the capture-default is <code>=</code> or if it is explicitly captured with a capture that does not include an <code>&amp;</code>. For each entity captured by copy, an unnamed nonstatic data member is declared in the closure type.</p>\n<p id=\"so_15612513_15612655_1\">$5.1.2/11 If a lambda-expression has an associated capture-default and its compound-statement odr-uses (3.2) <code>this</code> or a variable with automatic storage duration and the odr-used entity is not explicitly captured, <em>then the odr-used entity is said to be implicitly captured</em>; such entities shall be declared within the reaching scope of the lambda expression.</p>\n<p id=\"so_15612513_15612655_2\">\u00a75.1.2/9 A lambda-expression whose smallest enclosing scope is a block scope (3.3.3) is a local lambda expression; any other lambda-expression shall not have a capture-list in its lambda-introducer. The <strong>reaching scope</strong> of a local lambda expression is the set of enclosing scopes up to and including the innermost enclosing function and its parameters. [ Note: This reaching scope includes any intervening lambda-expressions. \u2014end note ]</p>\n</blockquote>\n</hr>", "OwnerUserId": "147192", "LastEditorUserId": "147192", "LastEditDate": "2013-03-25T10:41:06.310", "Id": "15612655", "Score": "22", "CreationDate": "2013-03-25T10:26:15.777", "LastActivityDate": "2013-03-25T10:41:06.310"}, "bq_ids": {"n4140": {"so_15612513_15612583_0": {"section_id": 5971, "quality": 0.55, "length": 11}, "so_15612513_15612655_1": {"section_id": 5971, "quality": 0.6206896551724138, "length": 18}, "so_15612513_15612655_2": {"section_id": 5968, "quality": 0.7619047619047619, "length": 32}, "so_15612513_15612655_0": {"section_id": 5974, "quality": 0.7916666666666666, "length": 19}, "so_15612513_15612583_1": {"section_id": 5972, "quality": 0.8, "length": 4}}, "n3337": {"so_15612513_15612583_0": {"section_id": 5739, "quality": 0.95, "length": 19}, "so_15612513_15612655_1": {"section_id": 5739, "quality": 0.9310344827586207, "length": 27}, "so_15612513_15612655_2": {"section_id": 5737, "quality": 0.7857142857142857, "length": 33}, "so_15612513_15612655_0": {"section_id": 5742, "quality": 0.875, "length": 21}, "so_15612513_15612583_1": {"section_id": 5740, "quality": 0.8, "length": 4}}, "n4659": {"so_15612513_15612583_0": {"section_id": 7470, "quality": 0.55, "length": 11}, "so_15612513_15612655_1": {"section_id": 7470, "quality": 0.6206896551724138, "length": 18}, "so_15612513_15612655_0": {"section_id": 7473, "quality": 0.7916666666666666, "length": 19}, "so_15612513_15612655_2": {"section_id": 7466, "quality": 0.7619047619047619, "length": 32}, "so_15612513_15612583_1": {"section_id": 7471, "quality": 0.8, "length": 4}}}});