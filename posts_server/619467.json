post_cb({"619474": {"ParentId": "619467", "CommentCount": "2", "Body": "<p>No, there's no way.</p>\n<p>You could do this in the bad old days of <code>malloc()/free()</code> but not for <code>new</code>.</p>\n<p>You can replace the memory allocator by globally overriding the <code>new</code> operator, but you cannot inject the special variables you're talking about.</p>\n", "OwnerUserId": "4926", "Id": "619474", "PostTypeId": "2", "OwnerDisplayName": "Jason Cohen", "Score": "-2", "CreationDate": "2009-03-06T16:31:50.197", "LastActivityDate": "2009-03-06T16:31:50.197"}, "619521": {"ParentId": "619467", "CommentCount": "5", "Body": "<p>You don't say what compiler you are using, but at least with GCC, you can override new and log the caller address, then later translate that to file/line information with addr2line (or use the BFD library to do that immediately).</p>\n", "OwnerUserId": "66490", "Id": "619521", "PostTypeId": "2", "OwnerDisplayName": "TrayMan", "Score": "1", "CreationDate": "2009-03-06T16:40:59.690", "LastActivityDate": "2009-03-06T16:40:59.690"}, "723139": {"ParentId": "619467", "CommentCount": "1", "Body": "<p>What you could do is to overload the operator new and get the stack trace there (platform specific) and use the stack information to deduce from where new was called.</p>\n", "OwnerUserId": "44434", "PostTypeId": "2", "Id": "723139", "Score": "1", "CreationDate": "2009-04-06T20:43:31.310", "LastActivityDate": "2009-04-06T20:43:31.310"}, "619467": {"CommentCount": "3", "ViewCount": "14447", "PostTypeId": "1", "AnswerCount": "7", "LastEditorUserId": "1257035", "LastActivityDate": "2015-03-31T01:37:07.657", "Body": "<p>Is it possible to create macros to replace all forms of <code>operator new</code> with overloads that include additional args...say <code>__FILE__</code> and <code>__LINE__</code>?</p>\n<p>The trouble appears to be that <code>operator new</code> can either be coded with or without parentheses, therefore:</p>\n<ul>\n<li><p><em>object-like</em> macros:</p>\n<pre><code>#define new new(__FILE__, __LINE__)\n</code></pre>\n<p>will replace declarations like:</p>\n<pre><code>A* a = new A();\n</code></pre></li>\n<li><p>and <em>function-like</em> macros:</p>\n<pre><code>#define new(A) new (A, __FILE__, __LINE__)\n</code></pre>\n<p>will replace declarations like:</p>\n<pre><code>A* a = new(std::nothrow) A();\n</code></pre></li>\n</ul>\n<p>Unfortunately it's an error to attempt to declare two macros with the same <em>identifier</em>, even if they are of different <em>types</em>, so the following fails:</p>\n<pre><code>#define new new(__FILE__, __LINE__)\n#define new(A) new (A, __FILE__, __LINE__) // Error: \"new\" already defined\n</code></pre>\n<p>Since I'm using g++ I was hopeful that employing their syntax of <a href=\"https://www.redhat.com/docs/manuals/enterprise/RHEL-4-Manual/gcc/variadic-macros.html\" rel=\"nofollow noreferrer\">variadic macros</a> would yield success, but unfortunately not. The following:</p>\n<pre><code>#define new(...) new(__FILE__, __LINE__, ## __VA_ARGS__)\n</code></pre>\n<p>only matches <code>new(xyx) A()</code>, not <code>new A()</code>.</p>\n<p>I know that <a href=\"http://web.archive.org/web/20090513070647/http://www.scs.cs.nyu.edu/~dm/c++-new.html\" rel=\"nofollow noreferrer\">essays have been written</a> about why it is impossible, but I feel like I'm so close that there must be a way. Is there anything obvious that I'm missing?</p>\n", "LastEditDate": "2015-03-31T01:37:07.657", "FavoriteCount": "19", "Title": "Macro to replace C++ operator new", "Id": "619467", "Score": "24", "CreationDate": "2009-03-06T16:30:34.787", "Tags": "<c++><gcc><c-preprocessor>", "OwnerUserId": "5309", "OwnerDisplayName": "David Citron"}, "629844": {"ParentId": "619467", "CommentCount": "2", "Body": "<p>I found the following library \"<a href=\"http://sourceforge.net/projects/nvwa\" rel=\"nofollow noreferrer\">nvwa</a>\" very useful for tracking down new/delete memory leaks - have a look at the file \"debug_new\" for examples, or just use it 'as is'.</p>\n", "OwnerUserId": "64805", "Id": "629844", "PostTypeId": "2", "OwnerDisplayName": "James Fisher", "Score": "1", "CreationDate": "2009-03-10T12:02:35.363", "LastActivityDate": "2009-03-10T12:02:35.363"}, "1365402": {"ParentId": "619467", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Here is what I use:</p>\n<p>In new.cpp</p>\n<pre><code>const char* __file__ = \"unknown\";\nsize_t __line__ = 0;\n\nvoid* operator new(size_t size) {\n    void *ptr = malloc(size);\n    record_alloc(ptr,__file__,__line__);\n    __file__ = \"unknown\";\n    __line__ = 0;\n    return ptr;\n}\n\nvoid delete(void *ptr)\n{\n   unrecord_alloc(ptr);\n   free(ptr);\n}\n</code></pre>\n<p>For compactness, I'm leaving out the other definitions of new and delete. \"record_alloc\" and \"unrecord_alloc\" are functions that maintain a linked list of structure containing ptr, line, and file).</p>\n<p>in new.hpp</p>\n<pre><code>extern const char* __file__;\nextern size_t __line__;\n#define new (__file__=__FILE__,__line__=__LINE__) &amp;&amp; 0 ? NULL : new\n</code></pre>\n<p>For g++, \"new\" is expanded only once. The key is the \"&amp;&amp; 0\" which makes it false and causes the real new to be used. For example,</p>\n<pre><code>char *str = new char[100];\n</code></pre>\n<p>is expanded by the preprocessor to</p>\n<pre><code>char *str = (__file__=\"somefile.c\",__line__=some_number) &amp;&amp; 0 ? NULL : new char [100];\n</code></pre>\n<p>Thus file and line number are recorded and your custom new function is called.</p>\n<p>This works for any form of new -- as long as there is a corresponding form in new.cpp</p>\n", "Id": "1365402", "LastEditDate": "2014-09-21T08:56:11.570", "OwnerDisplayName": "Terry", "Score": "21", "CreationDate": "2009-09-02T00:57:42.403", "LastActivityDate": "2014-09-21T08:56:11.570", "LastEditorUserId": "801008"}, "619519": {"ParentId": "619467", "CommentCount": "1", "Body": "<p>You should check out this excellent blog entry by my coworker Calvin.  We had a situation recently where we wanted to enable this type of fix in order to associate memory leaks with the line that allocated them in diagnostic/debug builds.  It's an interesting trick</p>\n<p><a href=\"http://blogs.msdn.com/calvin_hsia/archive/2009/01/19/9341632.aspx\" rel=\"noreferrer\">http://blogs.msdn.com/calvin_hsia/archive/2009/01/19/9341632.aspx</a></p>\n", "OwnerUserId": "23283", "Id": "619519", "PostTypeId": "2", "OwnerDisplayName": "JaredPar", "Score": "8", "CreationDate": "2009-03-06T16:40:40.033", "LastActivityDate": "2009-03-06T16:40:40.033"}, "bq_ids": {"n4140": {"so_619467_619590_3": {"section_id": 6317, "quality": 0.7692307692307693, "length": 10}, "so_619467_619590_1": {"section_id": 7174, "quality": 0.8823529411764706, "length": 30}}, "n3337": {"so_619467_619590_3": {"section_id": 6074, "quality": 0.8461538461538461, "length": 11}, "so_619467_619590_1": {"section_id": 6918, "quality": 0.8823529411764706, "length": 30}}, "n4659": {"so_619467_619590_3": {"section_id": 7827, "quality": 0.7692307692307693, "length": 10}, "so_619467_619590_1": {"section_id": 8682, "quality": 0.8823529411764706, "length": 30}}}, "619590": {"CommentCount": "4", "CreationDate": "2009-03-06T16:56:38.280", "LastEditorUserId": "19563", "LastActivityDate": "2009-03-26T21:24:34.913", "ParentId": "619467", "PostTypeId": "2", "LastEditorDisplayName": "Charles Bailey", "LastEditDate": "2009-03-26T21:24:34.913", "Id": "619590", "Score": "4", "Body": "<blockquote>\n<p id=\"so_619467_619590_0\"><strong>3.7.4 Dynamic storage duration</strong></p>\n<p id=\"so_619467_619590_1\">2 The library provides default definitions for the global allocation and deallocation functions. Some global allocation and deallocation functions are replaceable (18.5.1). A C++ program shall provide at most one definition of a replaceable allocation or deallocation function. Any such function definition replaces the default version provided in the library (17.6.4.6) [...]</p>\n<p id=\"so_619467_619590_2\"><strong>17.6.4.6 Replacement functions</strong></p>\n<ol start=\"2\">\n<li><p id=\"so_619467_619590_3\">A C++ program may provide the definition for any of eight dynamic memory allocation \n  function signatures declared in header  (3.7.4, Clause 18):</p>\n<ul>\n<li>operator new(std::size_t)</li>\n<li>operator new(std::size_t, const std::nothrow_t&amp;)</li>\n<li>operator new[](std::size_t)</li>\n<li>operator new[](std::size_t, const std::nothrow_t&amp;)</li>\n<li>operator delete(void*)</li>\n<li>operator delete(void*, const std::nothrow_t&amp;)</li>\n<li>operator delete[](void*)</li>\n<li>operator delete[](void*, const std::nothrow_t&amp;)</li>\n</ul></li>\n</ol>\n</blockquote>\n<p>Hope this clarifies what is a legal overload and what isn't.</p>\n<p>This may be of interest to a few here:</p>\n<pre><code>#define delete cout &lt;&lt;  \"delete called at: \" &lt;&lt; __LINE__ &lt;&lt; \" of \" &lt;&lt; __FILE__  &lt;&lt; endl, delete \n\nusing namespace std;\n\nvoid *operator new(size_t size, ostream&amp; o, char *f, unsigned l) {\n    o &lt;&lt; \"new called at: \" &lt;&lt; l &lt;&lt; \" of \" &lt;&lt; f &lt;&lt; endl;\n    return ::new char[size];\n}\n\nint main() {\n    int *a = new(cout, __FILE__, __LINE__) int;\n    delete a;\n}\n</code></pre>\n<p><strong><em>Caveat Lector</em></strong>: What I do here is a Bad Thing (TM) to do -- overloading new/delete globally. </p>\n", "OwnerUserId": "66692", "OwnerDisplayName": "dirkgently"}});