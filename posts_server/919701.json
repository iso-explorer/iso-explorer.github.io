post_cb({"920145": {"LastActivityDate": "2011-11-18T13:13:44.867", "CommentCount": "0", "Body": "<p>When calling:</p>\n<pre><code>foo( A(10) );\n</code></pre>\n<p>a temporary object is being created during the lifetime of the call.  A copy constructor is being being used to populate the data.  The temporary object is removed after execution of the call.</p>\n<p>When calling:</p>\n<pre><code>{ \n  A original(10);\n  foo( original ); \n}\n</code></pre>\n<p>The original is being discarded after exiting the block.  It can safely be used as a parameter.</p>\n<p>For optimal speed, pass the object by reference, using a temporary variable that will be discarded by the compiler during its optimization.</p>\n", "PostTypeId": "2", "LastEditDate": "2011-11-18T13:13:44.867", "ParentId": "919701", "Id": "920145", "OwnerUserId": "113651", "Score": "0", "CreationDate": "2009-05-28T10:12:47.463", "LastEditorUserId": "496830"}, "919968": {"LastActivityDate": "2012-02-09T11:06:09.443", "CommentCount": "1", "Body": "<p>The 2003 standard, in \u00a712.2/1, states:</p>\n<blockquote>\n<p id=\"so_919701_919968_0\">Even when the creation of the\n  temporary object is avoided (12.8),\n  all the semantic restrictions must be\n  respected as if the temporary object\n  was created.  [Example: even if the\n  copy constructor is not called, all\n  the semantic restrictions, such as\n  accessibility (clause 11), shall be\n  satisfied. ]</p>\n</blockquote>\n<p>There are similar examples around. From what I gather, the compiler is free to generate temporaries or optimize them away.</p>\n", "PostTypeId": "2", "LastEditDate": "2012-02-09T11:06:09.443", "ParentId": "919701", "Id": "919968", "OwnerUserId": "1088", "Score": "5", "CreationDate": "2009-05-28T09:26:41.750", "LastEditorUserId": "560648"}, "920118": {"CommentCount": "1", "CreationDate": "2009-05-28T10:05:56.507", "Body": "<p><a href=\"http://www.comeaucomputing.com/iso/cwg_defects.html#391\" rel=\"nofollow noreferrer\">Core defect 391</a> explains the issue.</p>\n<p>Basically, the current C++ standard requires a copy constructor to be available when passing a temporary of class type to a const reference.</p>\n<p>This requirement will be removed in C++0x.</p>\n<p>The logic behind requiring a copy constructor comes from this case:</p>\n<pre><code>C f();\nconst C&amp; r = f(); // a copy is generated for r to refer to\n</code></pre>\n", "PostTypeId": "2", "ParentId": "919701", "Id": "920118", "LastActivityDate": "2009-05-28T10:05:56.507", "Score": "12", "OwnerUserId": "11828"}, "920180": {"CommentCount": "0", "CreationDate": "2009-05-28T10:24:41.307", "Body": "<p>In the expression:</p>\n<pre><code>A a(foo(A(10)));\n</code></pre>\n<p>The result of the sub-expression <code>A(10)</code> is an <em>rvalue</em> of type <code>A</code>. (5.2.3 [expr.type.conv])</p>\n<p>When initializing a const reference from an <em>rvalue</em> the compiler may create a temporary from the <em>rvalue</em> and bind that to the reference. Even if it chooses not to, the copy constructor must be accessible. (8.5.3 [decl.init.ref]) This would not be the case if there reference were being initialized from a <em>reference-compatible</em> <em>lvalue</em> where direct binding is mandated.</p>\n<p>As <code>foo</code> takes its parameter by reference and not value, there is no copy mandated for the argument initialization itself.</p>\n<p><code>foo</code> returns an int, so there is no copy of an <code>A</code> here.</p>\n<p><code>a</code> is direct initialized from the int returned by foo, so there is no copy of <code>A</code> here.</p>\n", "PostTypeId": "2", "ParentId": "919701", "Id": "920180", "LastActivityDate": "2009-05-28T10:24:41.307", "Score": "1", "OwnerUserId": "19563"}, "919967": {"CommentCount": "0", "Body": "<p>In general, you shouldn't get to worried about if and when the copy constructor gets called. The C++ Standard is pretty relaxed about when calls to the copy constructor will be removed, or for that matter added. If your class logically needs it, provide it (and don't forget the destructor and assignment operator) is the sensible rule.</p>\n", "CreationDate": "2009-05-28T09:26:14.343", "OwnerDisplayName": "anon", "ParentId": "919701", "Id": "919967", "LastActivityDate": "2009-05-28T09:26:14.343", "PostTypeId": "2", "Score": "0"}, "919718": {"LastActivityDate": "2009-05-29T06:18:43.087", "CommentCount": "3", "Body": "<p>The copy-constructor isn't used, but in order for the code to compile the copy-constructor need to be accessible.</p>\n<p>EDIT: Comeau C++ compiler reports the following:</p>\n<pre><code>Comeau C/C++ 4.3.10.1 (Oct  6 2008 11:28:09) for ONLINE_EVALUATION_BETA2\nCopyright 1988-2008 Comeau Computing.  All rights reserved.\nMODE:strict errors C++ noC++0x_extensions\n\n\"ComeauTest.c\", line 38: error: \"A::A(const A &amp;)\" (declared at line 17), required\n          for copy that was eliminated, is inaccessible\n    A a(foo(A(10)));    // This is line 38\n            ^\n\n1 error detected in the compilation of \"ComeauTest.c\".\n</code></pre>\n<p>Note that if C++0x extensions are enabled, it compiles fine in Comeau C++ compiler.</p>\n", "PostTypeId": "2", "LastEditDate": "2009-05-29T06:18:43.087", "ParentId": "919701", "Id": "919718", "OwnerUserId": "19100", "Score": "1", "CreationDate": "2009-05-28T07:59:46.607", "LastEditorUserId": "19100"}, "920076": {"CommentCount": "0", "CreationDate": "2009-05-28T09:54:29.013", "Body": "<p>Just another remark: the compiler does a different thing when working with a temporary.  So it's not about the copy constructor, it's about the intermediate temporary.</p>\n<pre><code>A original(10);\nfoo( original ); // does compile\nfoo( A(10) ); // doesn't compile - needs a copy constructor\n</code></pre>\n", "PostTypeId": "2", "ParentId": "919701", "Id": "920076", "LastActivityDate": "2009-05-28T09:54:29.013", "Score": "2", "OwnerUserId": "6610"}, "919926": {"CommentCount": "3", "CreationDate": "2009-05-28T09:13:22.293", "Body": "<p>As far I see you are not using the copy constructor anywhere. In the statement <code>foo(A(10))</code> you are creating a temporary object of class A and passing it as a const-reference to foo. The foo returns an integer which is used in the construction of object <code>a</code>. Hence I don't see where the copy constructor is getting involved here and how NRVO comes into picture. Also, I compiled the following code by making the copy constructor private and it compiled fine in VS2008.</p>\n<pre><code>using namespace std;\n\nclass A\n{\n public:\n  A(const int n_);\n private:\n  A(const A&amp; that_);\n  A&amp; operator=(const A&amp; that_);\n};\n\nA::A(const int n_)\n{ cout &lt;&lt; \"A::A(int), n_=\" &lt;&lt; n_ &lt;&lt; endl; }\n\nA::A(const A&amp; that_)    // This is line 21\n{ cout &lt;&lt; \"A::A(const A&amp;)\" &lt;&lt; endl; }\n\nA&amp; A::operator=(const A&amp; that_)\n{ \n    cout &lt;&lt; \"A::operator=(const A&amp;)\" &lt;&lt; endl; \n    return *this;\n}\n\nint foo(const A&amp; a_)\n{ return 20; }\n\n\nint main(int argc,char *argv[])\n{\n   A a(foo(A(10)));    // This is line 38\n  return 0;\n\n}   \n</code></pre>\n", "PostTypeId": "2", "ParentId": "919701", "Id": "919926", "LastActivityDate": "2009-05-28T09:13:22.293", "Score": "3", "OwnerUserId": "39742"}, "919701": {"FavoriteCount": "1", "ViewCount": "661", "Id": "919701", "AcceptedAnswerId": "920118", "Score": "10", "Title": "Why is the copy ctor used in this code?", "LastEditorUserId": "560648", "CommentCount": "0", "Body": "<pre><code>class A\n{\n public:\n  A(const int n_);\n  A(const A&amp; that_);\n  A&amp; operator=(const A&amp; that_);\n};\n\nA::A(const int n_)\n{ cout &lt;&lt; \"A::A(int), n_=\" &lt;&lt; n_ &lt;&lt; endl; }\n\nA::A(const A&amp; that_)    // This is line 21\n{ cout &lt;&lt; \"A::A(const A&amp;)\" &lt;&lt; endl; }\n\nA&amp; A::operator=(const A&amp; that_)\n{ cout &lt;&lt; \"A::operator=(const A&amp;)\" &lt;&lt; endl; }\n\nint foo(const A&amp; a_)\n{ return 20; }\n\nint main()\n{\n  A a(foo(A(10)));    // This is line 38\n  return 0;\n}\n</code></pre>\n<p>Executing this code gives o/p:  </p>\n<blockquote>\n<p id=\"so_919701_919701_0\">A::A(int), n_=10  <br/>\n  A::A(int), n_=20  <br/></p>\n</blockquote>\n<p>Apparently the copy constructor is never called.  </p>\n<pre><code>class A\n{\n public:\n  A(const int n_);\n  A&amp; operator=(const A&amp; that_);\n private:\n  A(const A&amp; that_);\n};\n</code></pre>\n<p>However, if we make it private, this  compile error occurs:  </p>\n<blockquote>\n<p id=\"so_919701_919701_1\">Test.cpp: In function \u2018int main()\u2019:  <br/>\n  Test.cpp:21: error: \u2018A::A(const A&amp;)\u2019 is private  <br/>\n  Test.cpp:38: error: within this context  </p>\n</blockquote>\n<p>Why does the compiler complain when it doesn't actually use the copy constructor?<br>\nI am using gcc version 4.1.2 20070925 (Red Hat 4.1.2-33)</br></p>\n", "Tags": "<c++><copy-constructor>", "CreationDate": "2009-05-28T07:54:59.923", "LastEditDate": "2012-02-09T11:05:06.540", "LastActivityDate": "2012-02-09T11:06:09.443", "PostTypeId": "1", "AnswerCount": "8", "OwnerUserId": "113595"}, "bq_ids": {"n4140": {"so_919701_919968_0": {"length": 15, "quality": 0.5357142857142857, "section_id": 378}}, "n3337": {"so_919701_919968_0": {"length": 21, "quality": 0.75, "section_id": 369}}}});