post_cb({"bq_ids": {"n4140": {"so_46054228_46054902_5": {"length": 10, "quality": 0.625, "section_id": 7104}, "so_46054228_46054902_0": {"length": 31, "quality": 0.9117647058823529, "section_id": 565}, "so_46054228_46054902_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 336}, "so_46054228_46054902_4": {"length": 4, "quality": 0.6666666666666666, "section_id": 7104}, "so_46054228_46054902_3": {"length": 9, "quality": 0.6, "section_id": 147}}, "n3337": {"so_46054228_46054902_5": {"length": 10, "quality": 0.625, "section_id": 6848}, "so_46054228_46054902_0": {"length": 31, "quality": 0.9117647058823529, "section_id": 556}, "so_46054228_46054902_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 326}, "so_46054228_46054902_4": {"length": 4, "quality": 0.6666666666666666, "section_id": 6848}, "so_46054228_46054902_3": {"length": 9, "quality": 0.6, "section_id": 141}}, "n4659": {"so_46054228_46054902_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 623}, "so_46054228_46054902_1": {"length": 6, "quality": 1.0, "section_id": 623}, "so_46054228_46054902_3": {"length": 14, "quality": 0.9333333333333333, "section_id": 623}, "so_46054228_46054902_5": {"length": 15, "quality": 0.9375, "section_id": 623}, "so_46054228_46054902_0": {"length": 31, "quality": 0.9117647058823529, "section_id": 588}, "so_46054228_46054902_4": {"length": 5, "quality": 0.8333333333333334, "section_id": 623}}}, "46054632": {"Id": "46054632", "PostTypeId": "2", "Body": "<p>They do not have lower priority. You can solve the problem using SFINEA. This is described in Effective Modern C++ from Scott Meyers.</p>\n<pre><code>template &lt;class T&gt;\nstruct foo {\n    template &lt;template &lt;class&gt; class TT, class =  std::enable_if_t&lt;!std::is_same_v&lt;foo&lt;T&gt;, std::decay_t&lt;TT&lt;T&gt;&gt;&gt;&gt;&gt;\n    foo(TT&lt;T&gt;&amp;&amp;) {}\n    foo(foo&lt;T&gt;&amp;&amp;){}\n    foo() {}\n};\n</code></pre>\n", "LastEditorUserId": "3624086", "LastActivityDate": "2017-09-05T12:13:39.400", "Score": "1", "CreationDate": "2017-09-05T12:08:37.947", "ParentId": "46054228", "CommentCount": "10", "OwnerUserId": "3624086", "LastEditDate": "2017-09-05T12:13:39.400"}, "46054228": {"ViewCount": "285", "Body": "<p>Consider a simple example:</p>\n<pre><code>template &lt;class T&gt;\nstruct foo {\n    template &lt;template &lt;class&gt; class TT&gt;\n    foo(TT&lt;T&gt;&amp;&amp;) {}\n    foo(foo&lt;T&gt;&amp;&amp;){}\n    foo() {}\n};\n\nint main() {\n    foo      f1(foo&lt;int&gt;{}); //case 1.\n    foo&lt;int&gt; f2(foo&lt;int&gt;{}); //case 2.\n}\n</code></pre>\n<p>Case 1. causes ambiguity in the template argument deduction of foo class in clang but not in gcc. I thought that template functions (here - constructor) have lower priority in overload resolution. Is it not the case here?</p>\n<p>Error message:</p>\n<pre><code>prog.cc:10:14: error: ambiguous deduction for template arguments of 'foo'\n    foo      f1(foo&lt;int&gt;{}); //case 1.\n             ^\nprog.cc:4:5: note: candidate function [with T = int, TT = foo]\n    foo(TT&lt;T&gt;&amp;&amp;) {}\n    ^\nprog.cc:5:5: note: candidate function [with T = int]\n    foo(foo&lt;T&gt;&amp;&amp;){}\n    ^\n1 error generated.\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/EpN6M1DB26MDozE8\" rel=\"noreferrer\">[clang demo]</a> <a href=\"https://wandbox.org/permlink/3cj3562mRnavT3Im\" rel=\"noreferrer\">[gcc demo]</a></p>\n", "AcceptedAnswerId": "46054902", "Title": "Can constructor template cause ambiguity in the c++17 parameter deduction of class template", "CreationDate": "2017-09-05T11:46:28.163", "Id": "46054228", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2017-09-05T12:39:59.710", "Score": "13", "OwnerUserId": "4324224", "Tags": "<c++><templates><language-lawyer><c++1z><template-deduction>", "AnswerCount": "2"}, "46054902": {"Id": "46054902", "PostTypeId": "2", "Body": "<p>This is a Clang bug. The fact the candidate set is formed from c'tors should be immaterial, since after the candidate set is formed the best overload is chosen using the same rules for ordering implicit conversion sequences and template function ordering.</p>\n<p>To quote <a href=\"https://timsong-cpp.github.io/cppwp/n4659/over.match.funcs#over.match.class.deduct\" rel=\"noreferrer\">[over.match.funcs]/1</a>: </p>\n<blockquote>\n<p id=\"so_46054228_46054902_0\"><strong>The subclauses of [over.match.funcs] describe the set of candidate\n  functions and the argument list submitted to overload resolution in\n  each of the seven contexts in which overload resolution is used.</strong> The\n  source transformations and constructions defined in these subclauses\n  are only for the purpose of describing the overload resolution\n  process. An implementation is not required to use such transformations\n  and constructions.</p>\n</blockquote>\n<p>This clearly states that the overload resolution process is the same always. The only difference is how the candidate set is formed.</p>\n<p>And as specified by <a href=\"https://timsong-cpp.github.io/cppwp/n4659/over.match.class.deduct#1\" rel=\"noreferrer\">[over.match.class.deduct]/1</a></p>\n<blockquote>\n<p id=\"so_46054228_46054902_1\">A set of functions and function templates is formed comprising:</p>\n<ul>\n<li><p id=\"so_46054228_46054902_2\">For each constructor of the primary class template designated by the template-name, if the template is defined, a function template with\n  the following properties:</p>\n<ul>\n<li><p id=\"so_46054228_46054902_3\">The template parameters are the template parameters of the class template followed by the template parameters (including default\n  template arguments) of the constructor, if any.</p></li>\n<li><p id=\"so_46054228_46054902_4\">The types of the function parameters are those of the constructor.</p></li>\n<li><p id=\"so_46054228_46054902_5\">The return type is the class template specialization designated by the template-name and template arguments corresponding to the template\n  parameters obtained from the class template.</p></li>\n</ul></li>\n</ul>\n</blockquote>\n<p>Each c'tor will introduce a pseudo function into the candidate set. Like this:</p>\n<pre><code>template &lt;class T&gt;                           foo(foo&lt;T&gt;&amp;&amp;) -&gt; foo&lt;T&gt; \ntemplate &lt;class T, template&lt;class&gt; class TT&gt; foo(TT&lt;T&gt;&amp;&amp;) -&gt; foo&lt;T&gt; \n</code></pre>\n<p>To illustrate further, if this was a free function <code>bar</code>:</p>\n<pre><code>template &lt;template &lt;class&gt; class TT, class T&gt;\nvoid bar(TT&lt;T&gt;&amp;&amp;) {}\n\ntemplate &lt;class T&gt;\nvoid bar(foo&lt;T&gt;&amp;&amp;){}\n</code></pre>\n<p>Then template function ordering would place the first overload lower than the second.</p>\n", "LastEditorUserId": "817643", "LastActivityDate": "2017-09-05T12:39:59.710", "Score": "11", "CreationDate": "2017-09-05T12:22:48.560", "ParentId": "46054228", "CommentCount": "10", "OwnerUserId": "817643", "LastEditDate": "2017-09-05T12:39:59.710"}});