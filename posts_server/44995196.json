post_cb({"44995196": {"CommentCount": "5", "CreationDate": "2017-07-09T10:01:27.223", "PostTypeId": "1", "AcceptedAnswerId": "44996066", "LastEditorUserId": "819272", "LastActivityDate": "2017-07-09T11:58:28.727", "LastEditDate": "2017-07-09T11:32:58.343", "ViewCount": "241", "FavoriteCount": "0", "Title": "Static member access in constant expressions", "Id": "44995196", "Score": "7", "Body": "<p>Accessing static class member functions or variables, can be done in two ways: through an object (<code>obj.member_fun()</code> or <code>obj.member_var</code>) or through the class (<code>Class::member_fun()</code> or <code>Class::member_var</code>). However, in <code>constexpr</code> functions, Clang gives an error on the object access and requires to use class access:</p>\n<pre><code>struct S \n{\n    constexpr static auto s_v = 42;    \n    constexpr static auto v() { return s_v; }\n};\n\n#define TEST 1\n\nconstexpr auto foo(S const&amp; s [[maybe_unused]]) \n{\n#if TEST\n    constexpr auto v = s.v();   // ERROR for clang, OK for gcc\n#else    \n    constexpr auto v = S::v();  // OK for clang and gcc\n#endif\n    return v;\n}\n\nconstexpr auto bar(S const&amp; s [[maybe_unused]])\n{\n#if TEST   \n    constexpr auto v = s.s_v;   // ERROR for clang, OK for gcc\n#else    \n    constexpr auto v = S::s_v;  // OK for clang and gcc\n#endif    \n    return v;\n}\n\nint main() {}\n</code></pre>\n<p><a href=\"https://wandbox.org/permlink/j3JdM0WEOSHsK0R3\" rel=\"nofollow noreferrer\"><strong>Live Example</strong></a> compiled with <code>-std=c++1z</code> and <code>#define TEST 1</code> for Clang 5.0 SVN, with error message:</p>\n<blockquote id=\"so_44995196_44995196_0\">\n<pre><code>Start\nprog.cc:12:24: error: constexpr variable 'v' must be initialized by a constant expression\n    constexpr auto v = s.v();   // ERROR for clang, OK for gcc\n                       ^~~~~\nprog.cc:22:24: error: constexpr variable 'v' must be initialized by a constant expression\n    constexpr auto v = s.s_v;   // ERROR for clang, OK for gcc\n                       ^~~~~\n2 errors generated.\n1\nFinish\n</code></pre>\n</blockquote>\n<p><strong>Question</strong>: is this is a Clang bug, or is gcc too liberal in accepting both syntax forms for static member access in a <code>constexpr</code> function?</p>\n", "Tags": "<c++><clang><static-members><constexpr><c++1z>", "OwnerUserId": "819272", "AnswerCount": "2"}, "44995343": {"ParentId": "44995196", "CommentCount": "2", "Body": "<pre><code>constexpr auto v = s.v();   // ERROR for clang, OK for gcc\n</code></pre>\n<p>I guess it depends on whether you compile in C++11 or C++14 mode. If you look over at <a href=\"http://en.cppreference.com/w/cpp/language/constant_expression\" rel=\"nofollow noreferrer\">cppreference</a>, you will find (emphasis added by me):</p>\n<blockquote>\n<p id=\"so_44995196_44995343_0\">A core constant expression is any expression that <strong>does not have any one of the following</strong><br>\n  (...)<br>\n  6) The <code>this</code> pointer, except if used for class member access inside a non-static member function (until C++14)<br>\n  6) The <code>this</code> pointer, <strong>except in a constexpr function</strong> or a constexpr constructor that is being <strong>evaluated as part of the expression</strong> (since C++14)</br></br></br></p>\n</blockquote>\n<p>So, in C++11, whatever happens inside <code>s.v()</code> would not be considered a constant expression, since it uses the <code>this</code> pointer, but it is <strong>not</strong> a non-static member function (it's <code>static</code>) accessing a class member.</p>\n<p>Per C++14, however, it would be, since it is evaluating a <code>constexpr</code> function as part of the expression, so the \"except if\" clause on the \"does not have any of\" set of rules catches.</p>\n<p>Now don't ask me whether that makes any sense or whether anyone is supposed to understand that... :-)</p>\n", "OwnerUserId": "572743", "PostTypeId": "2", "Id": "44995343", "Score": "0", "CreationDate": "2017-07-09T10:21:52.993", "LastActivityDate": "2017-07-09T10:21:52.993"}, "bq_ids": {"n4140": {"so_44995196_44996066_1": {"section_id": 6185, "quality": 0.8571428571428571, "length": 12}, "so_44995196_44996066_3": {"section_id": 6185, "quality": 0.8571428571428571, "length": 18}, "so_44995196_44996066_0": {"section_id": 5900, "quality": 1.0, "length": 30}}, "n3337": {"so_44995196_44996066_3": {"section_id": 5946, "quality": 0.6190476190476191, "length": 13}, "so_44995196_44996066_0": {"section_id": 5672, "quality": 1.0, "length": 30}}, "n4659": {"so_44995196_44996066_1": {"section_id": 7687, "quality": 0.8571428571428571, "length": 12}, "so_44995196_44996066_0": {"section_id": 7382, "quality": 1.0, "length": 30}, "so_44995196_44996066_3": {"section_id": 7687, "quality": 0.9047619047619048, "length": 19}}}, "44996066": {"ParentId": "44995196", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Clang seems to be in the right. When accessing a static member with the member access syntax <a href=\"http://eel.is/c++draft/class.static#1\" rel=\"noreferrer\">[class.static/1]</a>:</p>\n<blockquote>\n<p id=\"so_44995196_44996066_0\">A static member s of class X may be referred to using the qualified-id\n  expression X\u200b::\u200bs; it is not necessary to use the class member access\n  syntax to refer to a static member. <strong>A static member may be referred to\n  using the class member access syntax, in which case the object\n  expression is evaluated.</strong></p>\n</blockquote>\n<p>So <code>s.v()</code> will cause <code>s</code> to be evaluated. Now, according to <a href=\"http://eel.is/c++draft/expr.const#2.11\" rel=\"noreferrer\">[expr.const/2.11]</a>, <code>s</code> is not a constant expression:</p>\n<blockquote>\n<p id=\"so_44995196_44996066_1\">2 An expression e is a core constant expression unless the evaluation\n  of e, following the rules of the abstract machine, would evaluate one\n  of the following expressions:</p>\n<p id=\"so_44995196_44996066_2\">[...]</p>\n<p id=\"so_44995196_44996066_3\">an id-expression that refers to a variable or data member of reference\n  type unless the reference has a preceding initialization and either:<br>\n  (2.11.1) - it is initialized with a constant expression or<br>\n  (2.11.2) - its lifetime began within the evaluation of e;</br></br></p>\n</blockquote>\n<p><code>s</code> doesn't have a preceding initialization with a constant expression, not in the scope of <code>foo</code>.</p>\n<hr>\n<p>If you want to access the static members based of a function parameter, without hard-coding the type, the way forward is <code>std::remove_reference_t&lt;decltype(s)&gt;</code>. This is accepted by Clang and GCC both:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nstruct S \n{\n    constexpr static auto s_v = 42;    \n    constexpr static auto v() { return s_v; }\n};\n\nconstexpr auto foo(S const&amp; s) \n{\n    constexpr auto v = std::remove_reference_t&lt;decltype(s)&gt;::v();\n    return v;\n}\n\nconstexpr auto bar(S const&amp; s)\n{\n    constexpr auto v = std::remove_reference_t&lt;decltype(s)&gt;::s_v;\n    return v;\n}\n\nint main() {}\n</code></pre>\n</hr>", "OwnerUserId": "817643", "LastEditorUserId": "817643", "LastEditDate": "2017-07-09T11:58:28.727", "Id": "44996066", "Score": "8", "CreationDate": "2017-07-09T11:47:46.910", "LastActivityDate": "2017-07-09T11:58:28.727"}});