post_cb({"bq_ids": {"n4140": {"so_9018818_9018959_0": {"length": 38, "quality": 0.6440677966101694, "section_id": 6046}}, "n3337": {"so_9018818_9018959_0": {"length": 56, "quality": 0.9491525423728814, "section_id": 5814}}, "n4659": {"so_9018818_9018959_0": {"length": 38, "quality": 0.6440677966101694, "section_id": 7545}}}, "9020176": {"Id": "9020176", "PostTypeId": "2", "Body": "<p>I've ticked the original answer above (to give him the credit), but I thought I'd sum up what I've learned here.</p>\n<p>So, the basic problem is that it's not defined how dispatching virtual calls must be implemented. </p>\n<p>This means that the data structure(s) that are internally used for virtual call dispatching (e.g. vtables) may or <strong>may not</strong> be bit compatible among template instantiations created from the same template.</p>\n", "LastActivityDate": "2012-01-26T15:06:51.853", "CommentCount": "0", "CreationDate": "2012-01-26T15:06:51.853", "ParentId": "9018818", "Score": "0", "OwnerUserId": "614177"}, "9018963": {"Id": "9018963", "PostTypeId": "2", "Body": "<p>No, reinterpret_cast is only to be used for lowlevel code since it will not perfrom the correct address manipulation. Use static_cast or dynamic_cast instead,</p>\n<p>Why do you want two factories this does not fit in the GoF factory pattern.</p>\n<p>reinterpret_cast is not the way to do it since it is slow (runtime checks) and is not a nice OO design (you want to use the polymophisme build into the language). </p>\n<p>Instead make constructors in the factory class that produces the types you are after and then have these call the constructor of the individual types.</p>\n<p>The factory pattern allows you to be by ignorant of changes in your implementaion, which is a good thing since you minimize your dependencies, and allows for easier maintainance in the future of the code.</p>\n", "LastEditorUserId": "800454", "LastActivityDate": "2012-01-26T13:48:04.510", "Score": "0", "CreationDate": "2012-01-26T13:41:09.663", "ParentId": "9018818", "CommentCount": "13", "OwnerUserId": "800454", "LastEditDate": "2012-01-26T13:48:04.510"}, "9018959": {"Id": "9018959", "PostTypeId": "2", "Body": "<p>No, it is not. You may not use the result of a <code>reinterpret_cast</code> other than to cast stuff back, except for a few special cases:</p>\n<p>ISO14882:2011(e) 5.2.10-7:</p>\n<blockquote>\n<p id=\"so_9018818_9018959_0\">An object pointer can be explicitly converted to an object pointer of\n  a different type.70 When a prvalue v of type \u201cpointer to T1\u201d is\n  converted to the type \u201cpointer to cv T2\u201d, the result is static_cast(static_cast(v)) if both T1 and T2 are standard-layout\n  types (3.9) and the alignment requirements of T2 are no stricter than\n  those of T1, or if either type is void. Converting a prvalue of type\n  \u201cpointer to T1\u201d to the type \u201cpointer to T2\u201d (where T1 and T2 are\n  object types and where the alignment requirements of T2 are no\n  stricter than those of T1) and back to its original type yields the\n  original pointer value. The result of any other such pointer\n  conversion is unspecified.</p>\n</blockquote>\n<p>To make a possible failure scenario more clear, consider multiple inheritance, where using a <code>static_cast</code> or <code>dynamic_cast</code> would sometimes adjust the pointer value, but <code>reinterpret_cast</code> will not. Consider casting in this example from <code>A*</code> to <code>B*</code>:</p>\n<pre><code>struct A { int x; };\nstruct B { int y; };\nstruct C : A, B { };\n</code></pre>\n<p>To understand how your code fails in a different way too, consider how most compilers implement the virtual function call mechanism: With virtual pointers. Your instance of <code>ChildClassFactory</code> will have a virtual pointer, pointing to the virtual table of <code>ChildClassFactory</code>. Now when you <code>reinterpret_cast</code> this beast, it just happens to \"work\" incidentally, because the compiler expects some virtual pointer, pointing to a virtual table that will have the same/similar layout. But it will still contain the values pointing to the <code>ChildCLassFactory</code> virtual functions, thus these functions would be called. All of this is long <em>after</em> invoking undefined behaviour. It is as if you are jumping with a car into a large canyon and thinking \"hey, everything is driving fine\" just because you have not hit the ground yet.</p>\n", "LastEditorUserId": "833362", "LastActivityDate": "2012-01-26T13:49:04.790", "Score": "5", "CreationDate": "2012-01-26T13:40:37.400", "ParentId": "9018818", "CommentCount": "8", "OwnerUserId": "833362", "LastEditDate": "2012-01-26T13:49:04.790"}, "9018818": {"ViewCount": "1452", "Body": "<p>In C++, assume following class hierarchy:</p>\n<pre><code>class BaseClass { };\nclass ChildClass : public BaseClass { };\n</code></pre>\n<p>Further assume factory classes for these two classes with a common, templated base class:</p>\n<pre><code>template&lt;typename T&gt;\nclass Factory {\npublic:\n  virtual T* create() = 0;\n};\n\nclass BaseClassFactory : public Factory&lt;BaseClass&gt; {\npublic:\n  virtual BaseClass* create() {\n    return new BaseClass(&amp;m_field);\n  }\nprivate:\n  SomeClass m_field;\n};\n\nclass ChildClassFactory : public Factory&lt;ChildClass&gt; {\npublic:\n  virtual ChildClass* create() {\n    return new ChildClass(&amp;m_field);\n  }\nprivate:\n  SomeOtherClass m_field; // Different class than SomeClass\n};\n</code></pre>\n<p>Note that the size/internal structure of <code>ChildClassFactory</code> and <code>BaseClassFactory</code> is different due to their different fields.</p>\n<p>Now, if a have an instance of <code>ChildClassFactory</code> (or <code>Factory&lt;ChildClass&gt;</code>), can I safely cast it to <code>Factory&lt;BaseClass&gt;</code> (via <code>reinterpret_cast</code>)?</p>\n<pre><code>Factory&lt;ChildClass&gt;* childFactory = new ChildClassFactory();\n\n// static_cast doesn't work - need to use reinterpret_cast\nFactory&lt;BaseClass&gt;* baseFactory = reinterpret_cast&lt;Factory&lt;BaseClass&gt;*&gt;(childFactory);\n\n// Does this work correctly? (i.e. is \"cls\" of type \"ChildClass\"?)\nBaseClass* cls = baseFactory-&gt;create();\n</code></pre>\n<p>I know that you can't always cast templated classes this way, but in this special case a cast should be safe, shouldn't it? </p>\n<p>I've tested it with Visual C++ 2010 and it does work. My question now is whether this is portable to other compilers?</p>\n<p><strong>Update:</strong> Since there has been some confusion let me clarify some more what's (supposed to be) important in my example:</p>\n<ul>\n<li><code>ChildClass</code> is a child class of <code>BaseClass</code></li>\n<li>A user of <code>Factory&lt;BaseClass&gt;</code> doesn't know what child class of <code>BaseClass</code> will be created. All he knows is that <code>BaseClass</code> is created.</li>\n<li><code>Factory&lt;T&gt;</code> has no fields of its own (other than the vtable).</li>\n<li><code>Factory::create()</code> is <code>virtual</code></li>\n</ul>\n", "AcceptedAnswerId": "9018959", "Title": "c++ reinterpret_cast, virtual, and templates ok?", "CreationDate": "2012-01-26T13:30:34.390", "Id": "9018818", "CommentCount": "12", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2012-01-26T14:05:53.653", "LastEditorUserId": "614177", "LastActivityDate": "2012-01-26T15:06:51.853", "Score": "2", "OwnerUserId": "614177", "Tags": "<c++><templates><casting><virtual><reinterpret-cast>", "AnswerCount": "3"}});