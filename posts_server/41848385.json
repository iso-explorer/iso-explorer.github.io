post_cb({"41849966": {"Id": "41849966", "PostTypeId": "2", "Body": "<p>The rule is that you can convert back and forth from a pointer to object to a pointer to its base class, and from a pointer to object to a <code>void *</code>. But there are no guarantees that all those pointers keep same value (nor even same representation)!</p>\n<p>Said differently with examples where C is derived from A:</p>\n<pre><code>C* c = new C;\nA* a = static_cast&lt;A*&gt;(c);   // legal\nC* c1 = static_cast&lt;C*&gt;(a);  // ok c1 == c guaranteed\n\nvoid *vc = static_cast&lt;void *&gt;(c); // legal\nC* c2 = static_cast&lt;C*&gt;(vc); // ok, c2 == c guaranteed\n\nvoid *va = static_cast&lt;void *&gt;(a); // legal, but va == vc is not guaranteed\n\na2 = static_cast&lt;A*&gt;(vc);    // legal, but a2 == a not guaranteed \n                             //  and dereferencing a2 is Undefined Behaviour\n</code></pre>\n<p>That means that if <code>v</code> is built as <code>void *v = static_cast&lt;void *&gt;(c)</code>;  and then passed to your <code>AfromC</code> method <code>static_cast&lt;A*&gt;(v)</code> may not point to a valid object. And both methods (1) and (2) are no-op because you cast from <code>void*</code> to a pointer to obj and back which is required to get original value.</p>\n<p>For method (4), but you cast a pointer to void to a pointer to pointer, from pointer to pointer to pointer to pointer again and then back to void. As 3.9.2 Compound types [basic.compound] declares:</p>\n<blockquote>\n<p id=\"so_41848385_41849966_0\">3 ...Pointers to layout-compatible types shall have the same value representation and\n  alignment requirements...</p>\n</blockquote>\n<p>As all pointers are <em>layout compatible types</em>, the second operation should not change the value and we are back in the no-op of method (1) and (2)</p>\n<p>Method (3) should not even compile, because you take the address of a static_cast and that is not a lvalue.</p>\n<p>TL/DR: methods (1), (2) and (4) are no-op, meaning that you return the input value unchanged and method (3) is illegal because <code>&amp;</code> operator requires a lvalue.</p>\n<p>The only realiable way to convert a void* pointing to a C object to something that could be safely converted to a A* is:</p>\n<pre><code>void * AfromC(void *v) {\n    C* c = static_cast&lt;C*&gt;(v);   // v shall be static_cast&lt;void&gt;(ptr_to_C)\n    A* a = static_cast&lt;A*&gt;(c);\n    return static_cast&lt;void *&gt;(a); // or return a; with the implicit void * convertion\n}\n</code></pre>\n<p>or as a single line expression</p>\n<pre><code>void * AfromC(void *v) {\n    return static_cast&lt;A*&gt;(static_cast&lt;C*&gt;(v));\n}\n</code></pre>\n", "LastActivityDate": "2017-01-25T11:06:00.537", "CommentCount": "5", "CreationDate": "2017-01-25T11:06:00.537", "ParentId": "41848385", "Score": "1", "OwnerUserId": "3545273"}, "41848385": {"ViewCount": "96", "Body": "<p>I have some concerns about the safety of type conversions I'm designing an abstract interface, witch will be supported by plugins exporting an object orientated C ABI, i.e. pointers to objects and C-style functions of the form <code>func(void *this, ...)</code> rather than C++ style member functions these will then be packed into a struct representing the objects implementation. However some of my underlying frameworks, use multiple virtual inheritance.</p>\n<p>Simplified example</p>\n<pre><code>class A\n{\n    public:\n        virtual void doA()\n}\n\nclass B\n{\n    public:\n        virtual void doB()\n}\n\nclass C : public A, public B\n{\n    public:\n        virtual void doA()\n        virtual void doB()\n}\n\nstruct impA\n{\n    (*doA)(void *self);\n}\n\nstruct impB\n{\n    (*doB)(void *self);\n}\n\nstruct impC\n{\n    (*doA)(void *self);\n    (*doB)(void *self);\n}\n\nvoid * AfromC(void *v) {\n    C*c = reinterpret_cast&lt;C*&gt;(v); // Known to be C* type\n    return static_cast&lt;void*&gt;(static_cast&lt;A*&gt;(c)); // method 1\n    return reinterpret_cast&lt;void*&gt;(static_cast&lt;A*&gt;(c)); // method 2\n\n    //method 3 &amp; 4\n    C** c = static_cast&lt;C**&gt;(v); // Known to be C* type\n    return static_cast&lt;void*&gt;(&amp;static_cast&lt;A*&gt;(*c)); // method 3\n    return static_cast&lt;void*&gt;(static_cast&lt;A**&gt;(c)); // method 4\n}\n\n/////////// main code\n\nclass A\n{\n    public:\n        void doA() { imp.doA(self); }\n    private:\n        impA imp;\n        void *self;\n}\n\nclass B\n{\n    public:\n        void doB() { imp.doB(self); }\n    private:\n        impB imp;\n        void *self;\n}\n</code></pre>\n<p>Consider AfromC, I have 4 possible methods of getting a pointer that I can safely pass through a C ABI, I want to known the consideration for these different methods, my preference would be method 1.</p>\n<p>I'm not sure if all these methods are legal or safe.</p>\n<p>Note: Object will always be access by functions in the binary from which they are created/destroyed they return/accept other objects handled by them self or C-style data types (up to structs of POD)</p>\n<p>While I've found mention of such things on the net, they are all about people having problems as a result of converting to void i.e. <code>A* a= static_cast&lt;A*&gt;(static_cast&lt;void*&gt;(c)) // c -&gt; C*</code> which is to be expected as this doesn't correct the vtable and the solutions is to use the abstract base type (this wron't work for me as I need to pass through the C ABI), however I've also heard mention of virtual pointers being larger than normal pointers hence my reason for considering methods 3 and 4, as this would be a normal pointer to the larger pointer and thus safe even for types with larger pointers.</p>\n<p>So my main question is will method 1 work with out problem? Aslo could I safely define a template function along the lines of <code>template  &lt;typename T, typename U&gt; void * void_cast(U v) { static_cast&lt;void *&gt;(static_cast&lt;T&gt;(v)); }</code> to simplify plugin code. Finally if method 1 is correct why? and can any of the methods be used?</p>\n", "AcceptedAnswerId": "41849966", "Title": "Pass C++ object (with possible multiple virtual inheritance) through a C ABI via void pointer", "CreationDate": "2017-01-25T09:54:41.640", "Id": "41848385", "CommentCount": "0", "LastEditDate": "2017-01-26T11:33:24.920", "PostTypeId": "1", "LastEditorUserId": "530051", "LastActivityDate": "2017-01-26T11:33:24.920", "Score": "3", "OwnerUserId": "530051", "Tags": "<c++><c><pointers><inheritance><virtual-method>", "AnswerCount": "2"}, "41849832": {"Id": "41849832", "PostTypeId": "2", "Body": "<blockquote id=\"so_41848385_41849832_0\">\n<pre><code>return static_cast&lt;void*&gt;(static_cast&lt;A*&gt;(v)); // method 1\nreturn reinterpret_cast&lt;void*&gt;(static_cast&lt;A*&gt;(v)); // method 2\n</code></pre>\n</blockquote>\n<p>If <code>void* v</code> points to an instance of type <code>C</code>, then <code>static_cast&lt;A*&gt;(v)</code> is wrong.</p>\n<blockquote id=\"so_41848385_41849832_1\">\n<pre><code>//method 3 &amp; 4\nC** c = static_cast&lt;C**&gt;(v); // Known to be C* type\nreturn static_cast&lt;void*&gt;(&amp;static_cast&lt;A*&gt;(*c)); // method 3\nreturn static_cast&lt;void*&gt;(static_cast&lt;A**&gt;(c)); // method 4\n</code></pre>\n</blockquote>\n<p>If <code>void* v</code> points to an instance of type <code>C</code>, then <code>static_cast&lt;C**&gt;(v)</code> is wrong.</p>\n<hr>\n<p>Be very careful about casting <code>void*</code> into the correct type of the pointed object. I would prefer to use <code>static_cast</code> when I can, instead of <code>reinterpret_cast</code>. I also prefer to implicit casts for base subobject access and for conversion to <code>void*</code>. The reduced boilerplate is less straining to the eyes.</p>\n<pre><code>void* AfromC(void* v) {\n    C* c = static_cast&lt;C*&gt;(v); // Known to be C* type\n    A* a = c;                  // point to base sub object\n    return a;                  // implicit conversion to void*\n}\n</code></pre>\n</hr>", "LastActivityDate": "2017-01-25T10:59:50.177", "CommentCount": "0", "CreationDate": "2017-01-25T10:59:50.177", "ParentId": "41848385", "Score": "0", "OwnerUserId": "2079303"}, "bq_ids": {"n4140": {"so_41848385_41849966_0": {"length": 9, "quality": 1.0, "section_id": 7223}}, "n3337": {"so_41848385_41849966_0": {"length": 9, "quality": 1.0, "section_id": 6967}}, "n4659": {"so_41848385_41849966_0": {"length": 9, "quality": 1.0, "section_id": 8732}, "so_41848385_41849832_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 2811}, "so_41848385_41849832_1": {"length": 6, "quality": 0.6, "section_id": 2811}}}});