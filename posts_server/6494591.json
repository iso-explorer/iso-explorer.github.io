post_cb({"6494839": {"ParentId": "6494591", "CommentCount": "6", "Body": "<p>I've seen an implementation of <code>addressof</code> do this:</p>\n<pre><code>char* start = &amp;reinterpret_cast&lt;char&amp;&gt;(clyde);\nghost* pointer_to_clyde = reinterpret_cast&lt;ghost*&gt;(start);\n</code></pre>\n<p>Don't ask me how conforming this is!</p>\n", "OwnerUserId": "726300", "PostTypeId": "2", "Id": "6494839", "Score": "11", "CreationDate": "2011-06-27T14:58:16.987", "LastActivityDate": "2011-06-27T14:58:16.987"}, "6494591": {"CommentCount": "17", "AcceptedAnswerId": "6495205", "PostTypeId": "1", "LastEditorUserId": "1593077", "CreationDate": "2011-06-27T14:39:04.430", "LastActivityDate": "2015-10-11T10:57:27.857", "LastEditDate": "2015-10-11T10:57:27.857", "ViewCount": "17889", "FavoriteCount": "45", "Title": "How can I reliably get an object's address when operator& is overloaded?", "Id": "6494591", "Score": "157", "Body": "<p>Consider the following program:</p>\n<pre><code>struct ghost\n{\n    // ghosts like to pretend that they don't exist\n    ghost* operator&amp;() const volatile { return 0; }\n};\n\nint main()\n{\n    ghost clyde;\n    ghost* clydes_address = &amp;clyde; // darn; that's not clyde's address :'( \n}\n</code></pre>\n<p>How do I get <code>clyde</code>'s address?</p>\n<p>I'm looking for a solution that will work equally well for all types of objects.  A C++03 solution would be nice, but I'm interested in C++11 solutions too.  If possible, let's avoid any implementation-specific behavior.</p>\n<p>I am aware of C++11's <code>std::addressof</code> function template, but am not interested in using it here:  I'd like to understand how a Standard Library implementor might implement this function template.</p>\n", "Tags": "<c++><c++11><operator-overloading><memory-address>", "OwnerUserId": "151292", "AnswerCount": "5"}, "6494844": {"ParentId": "6494591", "CommentCount": "1", "Body": "<p>Essentially, you can reinterpret the object as a reference-to-char, take its address (won\u2019t call the overload) and cast the pointer back to a pointer of your type.</p>\n<p>The Boost.AddressOf code does exactly that, just taking additional care of <code>volatile</code> and <code>const</code> qualification.</p>\n", "OwnerUserId": "1968", "PostTypeId": "2", "Id": "6494844", "Score": "87", "CreationDate": "2011-06-27T14:58:36.570", "LastActivityDate": "2011-06-27T14:58:36.570"}, "6495205": {"ParentId": "6494591", "PostTypeId": "2", "CommentCount": "15", "Body": "<p><strong>Update:</strong> in C++11, one may use <code>std::addressof</code> instead of <code>boost::addressof</code>.</p>\n<hr>\n<p>Let us first copy the code from Boost, minus the compiler work around bits:</p>\n<pre><code>template&lt;class T&gt;\nstruct addr_impl_ref\n{\n  T &amp; v_;\n\n  inline addr_impl_ref( T &amp; v ): v_( v ) {}\n  inline operator T&amp; () const { return v_; }\n\nprivate:\n  addr_impl_ref &amp; operator=(const addr_impl_ref &amp;);\n};\n\ntemplate&lt;class T&gt;\nstruct addressof_impl\n{\n  static inline T * f( T &amp; v, long ) {\n    return reinterpret_cast&lt;T*&gt;(\n        &amp;const_cast&lt;char&amp;&gt;(reinterpret_cast&lt;const volatile char &amp;&gt;(v)));\n  }\n\n  static inline T * f( T * v, int ) { return v; }\n};\n\ntemplate&lt;class T&gt;\nT * addressof( T &amp; v ) {\n  return addressof_impl&lt;T&gt;::f( addr_impl_ref&lt;T&gt;( v ), 0 );\n}\n</code></pre>\n<blockquote>\n<p id=\"so_6494591_6495205_0\">What happens if we pass a <strong>reference to function</strong> ?</p>\n</blockquote>\n<p><em>Note: <code>addressof</code> cannot be used with a pointer to function</em></p>\n<p>In C++ if <code>void func();</code> is declared, then <code>func</code> is a reference to a function taking no argument and returning no result. This reference to a function can be trivially converted into a pointer to function -- from <code>@Konstantin</code>: According to 13.3.3.2 both <code>T &amp;</code> and <code>T *</code> are indistinguishable for functions. The 1st one is an Identity conversion and the 2nd one is Function-to-Pointer conversion both having \"Exact Match\" rank (13.3.3.1.1 table 9).</p>\n<p>The <em>reference to function</em> pass through <code>addr_impl_ref</code>, there is an ambiguity in the overload resolution for the choice of <code>f</code>, which is solved thanks to the dummy argument <code>0</code>, which is an <code>int</code> first and could be promoted to a <code>long</code> (Integral Conversion).</p>\n<p>Thus we simply returns the pointer.</p>\n<blockquote>\n<p id=\"so_6494591_6495205_1\">What happens if we pass a type with a conversion operator ?</p>\n</blockquote>\n<p>If the conversion operator yields a <code>T*</code> then we have an ambiguity: for <code>f(T&amp;,long)</code> an Integral Promotion is required for the second argument while for <code>f(T*,int)</code> the conversion operator is called on the first <em>(thanks to @litb)</em></p>\n<p>That's when <code>addr_impl_ref</code> kicks in. The C++ Standard mandates that a conversion sequence may contain at most one user-defined conversion. By wrapping the type in <code>addr_impl_ref</code> and forcing the use of a conversion sequence already, we \"disable\" any conversion operator that the type comes with.</p>\n<p>Thus the <code>f(T&amp;,long)</code> overload is selected (and the Integral Promotion performed).</p>\n<blockquote>\n<p id=\"so_6494591_6495205_2\">What happens for any other type ?</p>\n</blockquote>\n<p>Thus the <code>f(T&amp;,long)</code> overload is selected, because there the type does not match the <code>T*</code> parameter.</p>\n<p><em>Note: from the remarks in the file regarding Borland compatibility, arrays do not decay to pointers, but are passed by reference.</em></p>\n<blockquote>\n<p id=\"so_6494591_6495205_3\">What happens in this overload ?</p>\n</blockquote>\n<p>We want to avoid applying <code>operator&amp;</code> to the type, as it may have been overloaded.</p>\n<p>The Standard guarantees that <code>reinterpret_cast</code> may be used for this work (see @Matteo Italia's answer: 5.2.10/10).</p>\n<p>Boost adds some niceties with <code>const</code> and <code>volatile</code> qualifiers to avoid compiler warnings (and properly use a <code>const_cast</code> to remove them).</p>\n<ul>\n<li>Cast <code>T&amp;</code> to <code>char const volatile&amp;</code></li>\n<li>Strip the <code>const</code> and <code>volatile</code></li>\n<li>Apply the <code>&amp;</code> operator to take the address</li>\n<li>Cast back to a <code>T*</code></li>\n</ul>\n<p>The <code>const</code>/<code>volatile</code> juggling is a bit of black magic, but it does simplify the work (rather than providing 4 overloads). Note that since <code>T</code> is unqualified, if we pass a <code>ghost const&amp;</code>, then <code>T*</code> is <code>ghost const*</code>, thus the qualifiers have not really been lost.</p>\n<p><strong>EDIT:</strong> the pointer overload is used for pointer to functions, I amended the above explanation somewhat. I still do not understand why it is <em>necessary</em> though.</p>\n<p>The following <a href=\"http://ideone.com/338NX\" rel=\"noreferrer\">ideone output</a> sums this up, somewhat.</p>\n</hr>", "OwnerUserId": "147192", "LastEditorUserId": "147192", "LastEditDate": "2015-09-21T06:31:47.233", "Id": "6495205", "Score": "89", "CreationDate": "2011-06-27T15:27:30.357", "LastActivityDate": "2015-09-21T06:31:47.233"}, "6494964": {"ParentId": "6494591", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>The trick behind <a href=\"http://www.boost.org/doc/libs/1_46_1/boost/utility/addressof.hpp\" rel=\"nofollow noreferrer\"><code>boost::addressof</code></a> and the implementation provided by @Luc Danton relies on the magic of the <code>reinterpret_cast</code>; the standard explicitly states at \u00a75.2.10 \u00b610 that</p>\n<blockquote>\n<p id=\"so_6494591_6494964_0\">An lvalue expression of type <code>T1</code> can be cast to the type \u201creference to <code>T2</code>\u201d if an expression of type \u201cpointer to <code>T1</code>\u201d can be explicitly converted to the type \u201cpointer to <code>T2</code>\u201d using a <code>reinterpret_cast</code>. That is, a reference cast <code>reinterpret_cast&lt;T&amp;&gt;(x)</code> has the same effect as the conversion <code>*reinterpret_cast&lt;T*&gt;(&amp;x)</code> with the built-in <code>&amp;</code> and <code>*</code> operators. The result is an lvalue that refers to the same object as the source lvalue, but with a different type.</p>\n</blockquote>\n<p>Now, this allows us to convert an arbitrary object reference to a <code>char &amp;</code> (with a cv qualification if the reference is cv-qualified), because any pointer can be converted to a (possibly cv-qualified) <code>char *</code>. Now that we have a <code>char &amp;</code>, the operator overloading on the object is no longer relevant, and we can obtain the address with the builtin <code>&amp;</code> operator. </p>\n<p>The boost implementation adds a few steps to work with cv-qualified objects: the first <code>reinterpret_cast</code> is done to <code>const volatile char &amp;</code>, otherwise a plain <code>char &amp;</code> cast wouldn't work for <code>const</code> and/or <code>volatile</code> references (<code>reinterpret_cast</code> cannot remove <code>const</code>). Then the <code>const</code> and <code>volatile</code> is removed with <code>const_cast</code>, the address is taken with <code>&amp;</code>, and a final <code>reinterpet_cast</code> to the \"correct\" type is done.</p>\n<p>The <code>const_cast</code> is needed to remove the <code>const</code>/<code>volatile</code> that could have been added to non-const/volatile references, but it does not \"harm\" what was a <code>const</code>/<code>volatile</code> reference in first place, because the final <code>reinterpret_cast</code> will re-add the cv-qualification if it was there in first place (<code>reinterpret_cast</code> cannot remove the <code>const</code> but can add it).</p>\n<p><s>As for the rest of the code in <code>addressof.hpp</code>, it seems that most of it is for workarounds. The <code>static inline T * f( T * v, int )</code> seems to be needed only for the Borland compiler, but its presence introduces the need for <code>addr_impl_ref</code>, otherwise pointer types would be caught by this second overload.</s></p>\n<p><s>\n<strong><em>Edit</em></strong>: the various overloads have a different function, see <a href=\"https://stackoverflow.com/questions/6494591/how-can-i-reliably-get-the-address-of-an-object/6495205#6495205\">@Matthieu M. excellent answer</a>.</s> </p>\n<p>Well, I'm no longer sure of this either; I should further investigate that code, but now I'm cooking dinner :) , I'll have a look at it later. </p>\n", "OwnerUserId": "214671", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:46:18.097", "Id": "6494964", "Score": "49", "CreationDate": "2011-06-27T15:07:31.080", "LastActivityDate": "2011-06-27T16:43:38.680"}, "6494634": {"ParentId": "6494591", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Take a look at <a href=\"http://www.boost.org/doc/libs/1_46_1/libs/utility/utility.htm#addressof\" rel=\"nofollow\">boost::addressof</a> and its implementation.</p>\n", "OwnerUserId": "381333", "LastEditorUserId": "363078", "LastEditDate": "2011-06-27T20:54:36.273", "Id": "6494634", "Score": "5", "CreationDate": "2011-06-27T14:42:11.637", "LastActivityDate": "2011-06-27T20:54:36.273"}, "bq_ids": {"n4140": {"so_6494591_6494964_0": {"section_id": 6050, "quality": 0.6052631578947368, "length": 23}}, "n3337": {"so_6494591_6494964_0": {"section_id": 5818, "quality": 0.868421052631579, "length": 33}}, "n4659": {"so_6494591_6494964_0": {"section_id": 7549, "quality": 0.6052631578947368, "length": 23}}}});