post_cb({"29316636": {"ParentId": "29316538", "CommentCount": "0", "Body": "<p>It's still undefined behaviour:  </p>\n<blockquote>\n<p id=\"so_29316538_29316636_0\">If a side effect on a scalar object is unsequenced relative to either another side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined.</p>\n<p id=\"so_29316538_29316636_1\">\u00a71.9 [intro.execution]</p>\n</blockquote>\n<p>and the order of evaluation of function parameters is unsequenced relative to each other. </p>\n", "OwnerUserId": "3723423", "PostTypeId": "2", "Id": "29316636", "Score": "3", "CreationDate": "2015-03-28T11:33:10.760", "LastActivityDate": "2015-03-28T11:33:10.760"}, "46082926": {"ParentId": "29316538", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>In C++17, it's not undefined.\n<a href=\"http://en.cppreference.com/w/cpp/language/eval_order#Undefined_behavior\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/eval_order#Undefined_behavior</a></p>\n<blockquote>\n<p id=\"so_29316538_46082926_0\">f(++i, ++i);       // undefined behavior until C++17, unspecified after C++17</p>\n</blockquote>\n<p>In a function call, value computations and side effects of the initialization of every parameter are indeterminately sequenced with respect to value computations and side effects of any other parameter.</p>\n", "OwnerUserId": "6222803", "LastEditorUserId": "6222803", "LastEditDate": "2017-09-06T19:31:12.550", "Id": "46082926", "Score": "1", "CreationDate": "2017-09-06T19:25:46.843", "LastActivityDate": "2017-09-06T19:31:12.550"}, "bq_ids": {"n4140": {"so_29316538_29316641_2": {"section_id": 5811, "quality": 1.0, "length": 22}, "so_29316538_29316636_0": {"section_id": 5811, "quality": 1.0, "length": 22}, "so_29316538_29316641_0": {"section_id": 5811, "quality": 1.0, "length": 11}, "so_29316538_29316641_1": {"section_id": 5811, "quality": 0.75, "length": 9}}, "n3337": {"so_29316538_29316641_2": {"section_id": 5584, "quality": 1.0, "length": 22}, "so_29316538_29316636_0": {"section_id": 5584, "quality": 1.0, "length": 22}, "so_29316538_29316641_0": {"section_id": 5584, "quality": 1.0, "length": 11}, "so_29316538_29316641_1": {"section_id": 5584, "quality": 0.75, "length": 9}}, "n4659": {"so_29316538_29316641_2": {"section_id": 7272, "quality": 0.7272727272727273, "length": 16}, "so_29316538_29316641_0": {"section_id": 7272, "quality": 1.0, "length": 11}, "so_29316538_29316636_0": {"section_id": 7272, "quality": 0.7272727272727273, "length": 16}}}, "29316641": {"ParentId": "29316538", "CommentCount": "1", "Body": "<p>It's undefined behaviour unless <code>i</code> is a class type. From C++11 1.9/15:</p>\n<blockquote>\n<p id=\"so_29316538_29316641_0\">Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced.</p>\n</blockquote>\n<p>followed by a note to clarify that this does apply to function arguments:</p>\n<blockquote>\n<p id=\"so_29316538_29316641_1\">[ <em>Note:</em> Value computations and side effects associated with different argument expressions are unsequenced. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>Your code modifies the same object twice without sequencing, so by the same paragraph:</p>\n<blockquote>\n<p id=\"so_29316538_29316641_2\">If a side effect on a scalar object is unsequenced relative to either another side effect on the same scalar object or a value computation\n  using the value of the same scalar object, <strong>the behavior is undefined</strong>.</p>\n</blockquote>\n<p>If <code>i</code> were a class type, then <code>++</code> would call a function, and function calls are always sequenced with respect to each other. So any modifications of scalar objects would be indeterminately sequenced; there's no undefined behaviour, but the result is unspecified.</p>\n", "OwnerUserId": "204847", "PostTypeId": "2", "Id": "29316641", "Score": "8", "CreationDate": "2015-03-28T11:33:40.843", "LastActivityDate": "2015-03-28T11:33:40.843"}, "29316538": {"CommentCount": "5", "AcceptedAnswerId": "29316641", "PostTypeId": "1", "LastEditorUserId": "3723423", "CreationDate": "2015-03-28T11:23:28.140", "LastActivityDate": "2017-09-06T19:31:12.550", "LastEditDate": "2015-03-28T11:30:17.923", "ViewCount": "174", "FavoriteCount": "0", "Title": "Is f(++i, ++i) undefined?", "Id": "29316538", "Score": "2", "Body": "<p>I seem to recall that in C++11, they made some changes to the sequencing behaviour and that now i++ and ++i have different sequencing requirements.</p>\n<p>Is <code>f(++i, ++i)</code> still undefined behaviour? What is the difference between <code>f(i++, i++)</code> and <code>f(++i, ++i)</code>?</p>\n", "Tags": "<c++><language-lawyer>", "OwnerUserId": "298661", "AnswerCount": "3"}});