post_cb({"8513050": {"CommentCount": "2", "CreationDate": "2011-12-14T23:08:30.567", "PostTypeId": "1", "AcceptedAnswerId": "8513174", "LastEditorUserId": "-1", "LastActivityDate": "2012-01-16T21:22:57.187", "LastEditDate": "2017-05-23T12:01:36.113", "ViewCount": "861", "FavoriteCount": "2", "Title": "Why can template instances not be deduced in `std::reference_wrapper`s?", "Id": "8513050", "Score": "16", "Body": "<p>Suppose I have some object of type <code>T</code>, and I want to put it into a reference wrapper:</p>\n<pre><code>int a = 5, b = 7;\n\nstd::reference_wrapper&lt;int&gt; p(a), q(b);   // or \"auto p = std::ref(a)\"\n</code></pre>\n<p>Now I can readily say <code>if (p &lt; q)</code>, because the reference wrapper has a conversion to its wrapped type. All is happy, and I can process a collection of reference wrappers just like they were the original objects.</p>\n<p><sub>(As the <a href=\"https://stackoverflow.com/a/8512759/596781\">question linked below</a> shows, this can be a useful way to produce an alternate view of an existing collection, which can be rearranged at will without incurring the cost of a full copy, as well as maintaining update integrity with the original collection.)</sub></p>\n<p><br/></p>\n<p>However, with some classes this doesn't work:</p>\n<pre><code>std::string s1 = \"hello\", s2 = \"world\";\n\nstd::reference_wrapper&lt;std::string&gt; t1(s1), t2(s2);\n\nreturn t1 &lt; t2;  // ERROR\n</code></pre>\n<p>My workaround is to define a predicate <s>as in <a href=\"https://stackoverflow.com/a/8512759/596781\">this answer</a></s>*; but my question is:</p>\n<p>Why and when can operators be applied to reference wrappers and transparently use the operators of the wrapped types? Why does it fail for <code>std::string</code>? What has it got to do with the fact that <code>std::string</code> is a template instance?</p>\n<p>*) Update: In the light of the answers, it seems that using <code>std::less&lt;T&gt;()</code> is a general solution.</p>\n", "Tags": "<c++><templates><templates-deduction><reference-wrapper>", "OwnerUserId": "596781", "AnswerCount": "2"}, "8513174": {"ParentId": "8513050", "PostTypeId": "2", "CommentCount": "14", "Body": "<p><strong>Edit:</strong> Moved my guesswork to the bottom, here comes the normative text why this won't work. TL;DR version:</p>\n<blockquote>\n<p id=\"so_8513050_8513174_0\">No conversions allowed if the function parameter contains a deduced template parameter.</p>\n</blockquote>\n<hr>\n<p><code>\u00a714.8.3 [temp.over] p1</code></p>\n<blockquote>\n<p id=\"so_8513050_8513174_1\">[...] When a call to that name is written (explicitly, or implicitly using the operator\n  notation), template argument deduction (14.8.2) and checking of any explicit template arguments (14.3) are performed for each function template to find the template argument values (if any) that can be used with that function template to instantiate a function template specialization that can be invoked with the call arguments.</p>\n</blockquote>\n<p><code>\u00a714.8.2.1 [temp.deduct.call] p4</code></p>\n<blockquote>\n<p id=\"so_8513050_8513174_2\">[...] [ <em>Note:</em> as specified in 14.8.1, <strong>implicit conversions will be performed</strong> on a function argument to convert it to the type of the corresponding function parameter <strong>if the parameter contains no <em>template-parameters</em> that participate in template argument deduction</strong>. [...] <em>\u2014end note</em> ]</p>\n</blockquote>\n<p><code>\u00a714.8.1 [temp.arg.explicit] p6</code></p>\n<blockquote>\n<p id=\"so_8513050_8513174_3\">Implicit conversions (Clause 4) will be performed on a function argument to convert it to the type of the corresponding function parameter if the parameter type contains no <em>template-parameters</em> that participate in template argument deduction. [ <em>Note:</em> Template parameters do not participate in template argument deduction if they are explicitly specified. [...] <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>Since <code>std::basic_string</code> depends on deduced template parameters (<code>CharT</code>, <code>Traits</code>), no conversions are allowed.</p>\n<hr>\n<p>This is kind of a chicken and egg problem. To deduce the template argument, it needs an actual instance of <code>std::basic_string</code>. To convert to the wrapped type, a conversion target is needed. That target has to be an actual type, which a class template is not. The compiler would have to test all possible instantiations of <code>std::basic_string</code> against the conversion operator or something like that, which is impossible.</p>\n<p>Suppose the following minimal testcase:</p>\n<pre><code>#include &lt;functional&gt;\n\ntemplate&lt;class T&gt;\nstruct foo{\n    int value;\n};\n\ntemplate&lt;class T&gt;\nbool operator&lt;(foo&lt;T&gt; const&amp; lhs, foo&lt;T&gt; const&amp; rhs){\n    return lhs.value &lt; rhs.value;\n}\n\n// comment this out to get a deduction failure\nbool operator&lt;(foo&lt;int&gt; const&amp; lhs, foo&lt;int&gt; const&amp; rhs){\n    return lhs.value &lt; rhs.value;\n}\n\nint main(){\n    foo&lt;int&gt; f1 = { 1 }, f2 = { 2 };\n    auto ref1 = std::ref(f1), ref2 = std::ref(f2);\n    ref1 &lt; ref2;\n}\n</code></pre>\n<p>If we don't provide the overload for an instantiation on <code>int</code>, the deduction fails. If we provide that overload, it's something the compiler can test against with the one allowed user-defined conversion (<code>foo&lt;int&gt; const&amp;</code> being the conversion target). Since the conversion matches in this case, overload resolution succeeds and we got our function call.</p>\n</hr></hr>", "OwnerUserId": "500104", "LastEditorUserId": "500104", "LastEditDate": "2011-12-15T00:32:36.027", "Id": "8513174", "Score": "7", "CreationDate": "2011-12-14T23:24:42.693", "LastActivityDate": "2011-12-15T00:32:36.027"}, "8513198": {"ParentId": "8513050", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>std::reference_wrapper</code> does not have an <code>operator&lt;</code>, so the only way to do <code>ref_wrapper&lt;ref_wrapper</code> is via the <code>ref_wrapper</code> member:</p>\n<pre><code>operator T&amp; () const noexcept;\n</code></pre>\n<p>As you know, <code>std::string</code> is:</p>\n<pre><code>typedef basic_string&lt;char&gt; string;\n</code></pre>\n<p>The relevant declaration for <code>string&lt;string</code> is:</p>\n<pre><code>template&lt;class charT, class traits, class Allocator&gt;\nbool operator&lt; (const basic_string&lt;charT,traits,Allocator&gt;&amp; lhs, \n                const basic_string&lt;charT,traits,Allocator&gt;&amp; rhs) noexcept;\n</code></pre>\n<p>For <code>string&lt;string</code> this function declaration template is instantiated by matching <code>string</code> = <code>basic_string&lt;charT,traits,Allocator&gt;</code> which resolves to <code>charT</code> = <code>char</code>, etc.</p>\n<p>Because <code>std::reference_wrapper</code> (or any of its (zero) bases classes) cannot match <code>basic_string&lt;charT,traits,Allocator&gt;</code>, the function declaration template cannot be instantiated into a function declaration, and cannot participate in overloading.</p>\n<p>What matters here is that there is <strong>no</strong> non-template <code>operator&lt; (string, string)</code> prototype.</p>\n<h1>Minimal code showing the problem</h1>\n<pre><code>template &lt;typename T&gt;\nclass Parametrized {};\n\ntemplate &lt;typename T&gt;\nvoid f (Parametrized&lt;T&gt;);\n\nParametrized&lt;int&gt; p_i;\n\nclass Convertible {\npublic:\n    operator Parametrized&lt;int&gt; ();\n};\n\nConvertible c;\n\nint main() {\n    f (p_i); // deduce template parameter (T = int)\n    f (c);   // error: cannot instantiate template\n}\n</code></pre>\n<p><a href=\"http://codepad.org/ZToumNUZ\" rel=\"nofollow\">Gives</a>:</p>\n<pre><code>In function 'int main()':\nLine 18: error: no matching function for call to 'f(Convertible&amp;)'\n</code></pre>\n<h1>Standard citations</h1>\n<p><strong>14.8.2.1 Deducing template arguments from a function call [temp.deduct.call]</strong></p>\n<blockquote>\n<p id=\"so_8513050_8513198_0\">Template argument deduction is done by comparing each function template parameter type (call it <code>P</code>) with the type of the corresponding argument of the call (call it <code>A</code>) as described below.</p>\n</blockquote>\n<p>(...)</p>\n<blockquote>\n<p id=\"so_8513050_8513198_1\">In general, the deduction process attempts to find template argument values that will make the deduced <code>A</code> identical to <code>A</code> (after the type <code>A</code> is transformed as described above). However, there are three cases that allow a difference: </p>\n<ul>\n<li>If the original <code>P</code> is a reference type, the deduced <code>A</code> (i.e., the type referred to by the reference) can be more cv-qualified than the transformed <code>A</code>.</li>\n</ul>\n</blockquote>\n<p>Note that this is the case with <code>std::string()&lt;std::string()</code>.</p>\n<blockquote id=\"so_8513050_8513198_2\">\n<ul>\n<li>The transformed <code>A</code> can be another pointer or pointer to member type that can be converted to the deduced <code>A</code> via a qualification conversion (4.4).</li>\n</ul>\n</blockquote>\n<p>See comment below.</p>\n<blockquote id=\"so_8513050_8513198_3\">\n<ul>\n<li>If <code>P</code> is a class and <code>P</code> has the form <em>simple-template-id</em>, then the transformed <code>A</code> can be a derived class of the deduced <code>A</code>.</li>\n</ul>\n</blockquote>\n<h2>Comment</h2>\n<p>This implies that in this paragraph:</p>\n<p><strong>14.8.1 Explicit template argument specification [temp.arg.explicit]</strong>/6</p>\n<blockquote>\n<p id=\"so_8513050_8513198_4\">Implicit conversions (Clause 4) will be performed on a function argument to convert it to the type of the corresponding function parameter <strong>if</strong> the parameter type contains no template-parameters that participate in template argument deduction.</p>\n</blockquote>\n<p>the <strong>if</strong> should not be taken as a <strong>if and only if</strong>, as it would directly contradict the text quoted previously.</p>\n", "OwnerUserId": "963864", "LastEditorUserId": "963864", "LastEditDate": "2011-12-15T01:58:41.163", "Id": "8513198", "Score": "6", "CreationDate": "2011-12-14T23:27:19.917", "LastActivityDate": "2011-12-15T01:58:41.163"}, "bq_ids": {"n4140": {"so_8513050_8513198_2": {"section_id": 305, "quality": 0.9285714285714286, "length": 13}, "so_8513050_8513174_0": {"section_id": 5965, "quality": 0.75, "length": 6}, "so_8513050_8513198_0": {"section_id": 302, "quality": 1.0, "length": 18}, "so_8513050_8513198_3": {"section_id": 305, "quality": 1.0, "length": 9}, "so_8513050_8513174_3": {"section_id": 289, "quality": 0.90625, "length": 29}, "so_8513050_8513174_2": {"section_id": 305, "quality": 0.8260869565217391, "length": 19}, "so_8513050_8513198_4": {"section_id": 289, "quality": 1.0, "length": 20}, "so_8513050_8513174_1": {"section_id": 355, "quality": 0.9459459459459459, "length": 35}, "so_8513050_8513198_1": {"section_id": 305, "quality": 1.0, "length": 23}}, "n3337": {"so_8513050_8513198_2": {"section_id": 296, "quality": 0.9285714285714286, "length": 13}, "so_8513050_8513174_0": {"section_id": 280, "quality": 0.625, "length": 5}, "so_8513050_8513198_0": {"section_id": 293, "quality": 1.0, "length": 18}, "so_8513050_8513198_3": {"section_id": 296, "quality": 1.0, "length": 9}, "so_8513050_8513174_3": {"section_id": 280, "quality": 0.90625, "length": 29}, "so_8513050_8513174_2": {"section_id": 296, "quality": 0.8260869565217391, "length": 19}, "so_8513050_8513198_4": {"section_id": 280, "quality": 1.0, "length": 20}, "so_8513050_8513174_1": {"section_id": 345, "quality": 0.9459459459459459, "length": 35}, "so_8513050_8513198_1": {"section_id": 296, "quality": 1.0, "length": 23}}, "n4659": {"so_8513050_8513174_0": {"section_id": 309, "quality": 0.75, "length": 6}, "so_8513050_8513198_0": {"section_id": 309, "quality": 1.0, "length": 18}, "so_8513050_8513198_2": {"section_id": 312, "quality": 0.9285714285714286, "length": 13}, "so_8513050_8513198_3": {"section_id": 312, "quality": 1.0, "length": 9}, "so_8513050_8513174_3": {"section_id": 296, "quality": 0.90625, "length": 29}, "so_8513050_8513174_2": {"section_id": 296, "quality": 0.7391304347826086, "length": 17}, "so_8513050_8513198_4": {"section_id": 296, "quality": 1.0, "length": 20}, "so_8513050_8513174_1": {"section_id": 365, "quality": 0.9459459459459459, "length": 35}, "so_8513050_8513198_1": {"section_id": 312, "quality": 1.0, "length": 23}}}});