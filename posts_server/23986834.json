post_cb({"bq_ids": {"n4140": {"so_23986834_23986883_0": {"length": 155, "quality": 0.9451219512195121, "section_id": 500}}, "n3337": {"so_23986834_23986883_0": {"length": 155, "quality": 0.9451219512195121, "section_id": 491}}}, "23986834": {"ViewCount": "379", "Body": "<p>Consider the following code, which results in the boolean literal <code>true</code> being evaluated in a preprocessor conditional:</p>\n<pre><code>#define SOME_MACRO true\n\nint main ()\n{\n#if SOME_MACRO\n  return 1;\n#else\n  return 0;\n#endif\n}\n</code></pre>\n<p>Clang 3.4 and GCC 4.8 both accept this code, even with <code>-pedantic -std=c++11 -Wall -Wextra</code>.</p>\n<p>Visual Studio 2013 rejects it, with <a href=\"http://msdn.microsoft.com/en-us/library/h5sh3k99.aspx\" rel=\"nofollow\">fatal error C1017: invalid integer constant expression</a>.</p>\n<p>My reading of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3376.pdf\" rel=\"nofollow\">n3376</a> \u00a7\n16.1 is that the regular C++ rules for evaluating constant expressions should apply.</p>\n<p>If so, this code is valid, and it's a bug if MSVC does not accept it.</p>\n<p>But I don't find the standardeze particularly clear. Could someone confirm this?</p>\n", "AcceptedAnswerId": "23986883", "Title": "Is it valid to use boolean literals in preprocessor conditionals?", "CreationDate": "2014-06-02T03:12:22.843", "Id": "23986834", "CommentCount": "0", "LastEditDate": "2016-07-03T14:46:54.677", "PostTypeId": "1", "LastEditorUserId": "4370109", "LastActivityDate": "2016-07-03T14:46:54.677", "Score": "3", "OwnerUserId": "1815661", "Tags": "<c++><c-preprocessor><language-lawyer>", "AnswerCount": "1"}, "23986883": {"PostTypeId": "2", "Body": "<p>Yes, it is valid. See C++11 \u00a716.1/4 (emphasis mine)</p>\n<blockquote>\n<p id=\"so_23986834_23986883_0\">Prior to evaluation, macro invocations in the list of preprocessing tokens that will become the controlling\n  constant expression are replaced (except for those macro names modified by the <code>defined</code> unary operator),\n  just as in normal text. If the token <code>defined</code> is generated as a result of this replacement process or use\n  of the <code>defined</code> unary operator does not match one of the two specified forms prior to macro replacement,\n  the behavior is undefined. After all replacements due to macro expansion and the <code>defined</code> unary operator\n  have been performed, <strong>all remaining identifiers and keywords, except for <code>true</code> and <code>false</code>, are replaced\n  with the pp-number <code>0</code></strong>, and then each preprocessing token is converted into a token. The resulting tokens\n  comprise the controlling constant expression which is evaluated according to the rules of 5.19 using arithmetic\n  that has at least the ranges specified in 18.3. For the purposes of this token conversion and evaluation all\n  signed and unsigned integer types act as if they have the same representation as, respectively, <code>intmax_t</code>\n  or <code>uintmax_t</code> (18.4). This includes interpreting character literals, which may involve converting escape\n  sequences into execution character set members. Whether the numeric value for these character literals\n  matches the value obtained when an identical character literal occurs in an expression (other than within a\n  <code>#if</code> or <code>#elif</code> directive) is implementation-defined. Also, whether a single-character character literal may\n  have a negative value is implementation-defined. <strong>Each subexpression with type <code>bool</code> is subjected to integral\n  promotion before processing continues.</strong></p>\n</blockquote>\n", "LastActivityDate": "2014-06-02T03:19:37.387", "Id": "23986883", "CommentCount": "2", "CreationDate": "2014-06-02T03:19:37.387", "ParentId": "23986834", "Score": "6", "OwnerUserId": "481267"}});