post_cb({"2196327": {"ViewCount": "3373", "Body": "<p>Suppose I have the following snipplet:</p>\n<pre><code>Foo foo;\n....\nreturn bar();\n</code></pre>\n<p>Now, does the C++ standard guarantees me that bar() will be called before foo::~Foo() ? Or is this the compiler/implementation's choice?</p>\n<p>Thanks!</p>\n", "AcceptedAnswerId": "2196495", "Title": "C++ destructor & function call order", "CreationDate": "2010-02-03T23:32:45.547", "Id": "2196327", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2010-02-03T23:36:43.143", "LastEditorUserId": "16855", "LastActivityDate": "2010-02-04T00:19:33.013", "Score": "12", "OwnerUserId": "247265", "Tags": "<c++><destructor><order>", "AnswerCount": "5"}, "2196332": {"Id": "2196332", "PostTypeId": "2", "Body": "<p>Yes, bar() will be called before the destructor of foo.</p>\n<p>The standard says:\n6.6: \"On exit from a scope (however accomplished), destructors (12.4) are\ncalled for all constructed objects with automatic storage duration\n(3.7.2) (named objects or temporaries) that are declared in that scope,\nin the reverse order of their declaration.\"</p>\n<p>The scope isn't left until the return statement is completed.</p>\n", "LastEditorUserId": "227322", "LastActivityDate": "2010-02-03T23:49:01.863", "Score": "7", "CreationDate": "2010-02-03T23:33:54.453", "ParentId": "2196327", "CommentCount": "0", "LastEditDate": "2010-02-03T23:49:01.863", "OwnerUserId": "227322"}, "2196369": {"Id": "2196369", "PostTypeId": "2", "Body": "<p><em>Objects destruct when leaving the scope.</em></p>\n<p><code>return</code> leaves the scope, but it can't return until it has executed <code>bar()</code>. Ergo, <code>bar()</code> is called.</p>\n", "LastActivityDate": "2010-02-03T23:43:00.177", "CommentCount": "0", "CreationDate": "2010-02-03T23:43:00.177", "ParentId": "2196327", "Score": "3", "OwnerUserId": "87234"}, "bq_ids": {"n4140": {"so_2196327_2196495_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 5803}, "so_2196327_2196495_5": {"length": 5, "quality": 1.0, "section_id": 3913}, "so_2196327_2196495_11": {"length": 18, "quality": 0.8181818181818182, "section_id": 407}, "so_2196327_2196495_9": {"length": 9, "quality": 1.0, "section_id": 3917}, "so_2196327_2196495_7": {"length": 8, "quality": 0.5714285714285714, "section_id": 3909}, "so_2196327_2196495_3": {"length": 17, "quality": 0.7391304347826086, "section_id": 7170}}, "n3337": {"so_2196327_2196495_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 5576}, "so_2196327_2196495_3": {"length": 17, "quality": 0.7391304347826086, "section_id": 6914}, "so_2196327_2196495_11": {"length": 17, "quality": 0.7727272727272727, "section_id": 398}, "so_2196327_2196495_9": {"length": 9, "quality": 1.0, "section_id": 3777}, "so_2196327_2196495_7": {"length": 8, "quality": 0.5714285714285714, "section_id": 3769}, "so_2196327_2196495_5": {"length": 5, "quality": 1.0, "section_id": 3773}}, "n4659": {"so_2196327_2196495_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 7261}, "so_2196327_2196495_3": {"length": 14, "quality": 0.6086956521739131, "section_id": 8678}, "so_2196327_2196495_11": {"length": 18, "quality": 0.8181818181818182, "section_id": 425}, "so_2196327_2196495_9": {"length": 9, "quality": 1.0, "section_id": 4803}, "so_2196327_2196495_7": {"length": 8, "quality": 0.5714285714285714, "section_id": 4795}, "so_2196327_2196495_5": {"length": 4, "quality": 0.8, "section_id": 823}}}, "2196495": {"Id": "2196495", "PostTypeId": "2", "Body": "<p>It is guaranteed behaviour. The actual execution is unrolled as follows:</p>\n<pre><code>0: enter block (scope)\n1: Foo::Foo()\n2. evaluation of bar(); as expression in return statement\n3. save result of the expression as value returned from function\n4. finalize return statement to leave function to its caller (request exit from current scope)\n5: exit block (scope) with call to  Foo::~Foo()\n</code></pre>\n<p>Here are some references from the standard:</p>\n<ul>\n<li>What program execution guarantees, generally</li>\n</ul>\n<blockquote>\n<p id=\"so_2196327_2196495_0\">1.9 Program execution</p>\n<p id=\"so_2196327_2196495_1\">10 An instance of each object with automatic storage duration (3.7.2) is\n  associated with each entry into its\n  block.</p>\n</blockquote>\n<ul>\n<li>The <code>foo</code> is of automatic storage duration and:</li>\n</ul>\n<blockquote>\n<p id=\"so_2196327_2196495_2\">3.7.2 Automatic storage duration</p>\n<p id=\"so_2196327_2196495_3\">1 Local objects explicitly declared auto or register or not explicitly declared\n  static or extern have automatic storage duration. The storage for\n  these objects lasts until the block in which they are created exits.</p>\n</blockquote>\n<ul>\n<li>What is actual effect of return statement</li>\n</ul>\n<blockquote>\n<p id=\"so_2196327_2196495_4\">6.6.3 The return statement</p>\n<p id=\"so_2196327_2196495_5\">2 (...) the value of the expression is returned to the caller of the function</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_2196327_2196495_6\">6.6 Jump statements <em>(return belongs to jump statements)</em></p>\n<p id=\"so_2196327_2196495_7\">2 On exit from a scope (however accomplished), destructors (12.4) are called for all\n  constructed objects with automatic storage duration (3.7.2)</p>\n</blockquote>\n<ul>\n<li>What guarantees that the effect occurs</li>\n</ul>\n<blockquote>\n<p id=\"so_2196327_2196495_8\">6.7 Declaration statement</p>\n<p id=\"so_2196327_2196495_9\">2 Variables with automatic storage duration declared in the block are\n  destroyed on exit from the block</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_2196327_2196495_10\">12.4 Destructors </p>\n<p id=\"so_2196327_2196495_11\">10  Destructors are invoked implicitly (1) for a constructed\n  object with static storage duration\n  (3.7.1) at program termination\n  (3.6.3), (2) for a constructed object\n  with automatic storage duration\n  (3.7.2) when the block in which the\n  object is created exits (6.7)</p>\n</blockquote>\n<p>It is not easy to grasp single idea form details scattered around all the C++ standard. Hopefully, quick overview will help you to make such analysis yourself too.</p>\n", "LastEditorUserId": "151641", "LastActivityDate": "2010-02-04T00:19:33.013", "Score": "15", "CreationDate": "2010-02-04T00:13:56.723", "ParentId": "2196327", "CommentCount": "0", "LastEditDate": "2010-02-04T00:19:33.013", "OwnerUserId": "151641"}, "2196479": {"Id": "2196479", "PostTypeId": "2", "Body": "<p>Just think, what if it was <code>return bar(foo);</code>? That just <em>has</em> to work, and it'd be silly if the destruction order was different depending on whether you pass that as an argument or not.</p>\n", "LastActivityDate": "2010-02-04T00:11:09.970", "CommentCount": "0", "CreationDate": "2010-02-04T00:11:09.970", "ParentId": "2196327", "Score": "2", "OwnerUserId": "237349"}, "2196351": {"Id": "2196351", "PostTypeId": "2", "Body": "<p>The result of calling bar() must be evaluated before the stack frame containing Foo can be cleaned up, so yes, bar() will be called before Foo::~Foo().</p>\n", "LastActivityDate": "2010-02-03T23:38:06.783", "CommentCount": "0", "CreationDate": "2010-02-03T23:38:06.783", "ParentId": "2196327", "Score": "5", "OwnerUserId": "826"}});