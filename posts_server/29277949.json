post_cb({"29278000": {"ParentId": "29277949", "CommentCount": "1", "Body": "<p>It's completely valid; this has nothing to do with strict aliasing whatsoever.</p>\n<p>Strict aliasing rules require that pointers aliasing each other have compatible types;<br>\nclearly, <code>float*</code> is compatible with <code>float*</code>.</br></p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "29278000", "Score": "0", "CreationDate": "2015-03-26T12:06:06.243", "LastActivityDate": "2015-03-26T12:06:06.243"}, "29277949": {"CommentCount": "14", "AcceptedAnswerId": "29278260", "ClosedDate": "2017-08-27T12:16:21.120", "CreationDate": "2015-03-26T12:03:43.603", "LastActivityDate": "2017-08-27T15:52:50.983", "PostTypeId": "1", "ViewCount": "300", "Title": "Casting a Struct to an Array", "Id": "29277949", "Score": "0", "Body": "<p>This is an strict aliasing question, as in will the compiler cause any optimization order problems with this.</p>\n<p>Say that I have three public <code>float</code>s in a <code>struct XMFLOAT3</code> (not unlike <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/microsoft.directx_sdk.reference.xmfloat3%28v=vs.85%29.aspx\" rel=\"nofollow\">this one</a>.) And I want to cast to a <code>float*</code>. Will this land me in optimization trouble?</p>\n<pre><code>XMFLOAT3 foo = {1.0f, 2.0f, 3.0f};\nauto bar = &amp;foo.x;\n\nbar[2] += 5.0f;\nfoo.z += 5.0f;\ncout &lt;&lt; foo.z;\n</code></pre>\n<p>I assume this will always print \"13\". But what about this code:</p>\n<pre><code>XMFLOAT3 foo = {1.0f, 2.0f, 3.0f};\nauto bar = reinterpret_cast&lt;float*&gt;(&amp;foo);\n\nbar[2] += 5.0f;\nfoo.z += 5.0f;\ncout &lt;&lt; foo.z;\n</code></pre>\n<p>I believe this is legal because, according to <a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast#Type_aliasing\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/reinterpret_cast#Type_aliasing</a></p>\n<blockquote>\n<p id=\"so_29277949_29277949_0\">T2 is an aggregate type or a union type which holds one of the aforementioned types as an element or non-static member (including, recursively, elements of subaggregates and non-static data members of the contained unions): this makes it safe to cast from the first member of a struct and from an element of a union to the struct/union that contains it.</p>\n</blockquote>\n<p>Is my understanding of this correct?</p>\n<p><sub>Obviously this will become implementation dependent on the declaration of <code>XMFLOAT3</code>.</sub></p>\n", "Tags": "<c++><arrays><struct><alias><reinterpret-cast>", "OwnerUserId": "2642059", "AnswerCount": "3"}, "29278260": {"ParentId": "29277949", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The <code>reinterpret_cast</code> from <code>XMFLOAT3*</code> to <code>float*</code> is OK, due to:</p>\n<p>9.2 [class.mem] paragraph 20:</p>\n<blockquote>\n<p id=\"so_29277949_29278260_0\">If a standard-layout class object has any non-static data members, its address is the same as the address of its first non-static data member. Otherwise, its address is the same as the address of its first base class\n  subobject (if any). [ <em>Note:</em> There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning, as necessary to achieve appropriate alignment. \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>That means the address of the first member is the address of the struct, and there's no aliasing involved when you access <code>*bar</code> because you're accessing a <code>float</code> through an lvalue of type <code>float</code>, which is fine.</p>\n<p>But the cast is also unnecessary, it's equivalent to the first version:</p>\n<pre><code>auto bar = &amp;foo.x;\n</code></pre>\n<p>The expression <code>bar[2]</code> is only OK if there is no padding between the members of the struct, or more precisely, if the layout of the data members is the same as an array <code>float[3]</code>, in which case 3.9.2 [basic.compound] paragraph 3 says it is OK:</p>\n<blockquote>\n<p id=\"so_29277949_29278260_1\">A valid value of an object pointer type represents either the address of a byte in memory (1.7) or a null pointer (4.10). If an object of type <code>T</code> is located at an address <code>A</code>, a pointer of type <em>cv</em> <code>T*</code> whose value is the\n  address <code>A</code> is said to point to that object, regardless of how the value was obtained.</p>\n</blockquote>\n<p>In practice there is no reason that three adjacent non-static data members of the same type would not be laid out identically to an array (and I think the Itanium ABI guarantees it), but to be safe you could add:</p>\n<pre><code> static_assert(sizeof(XMFLOAT3)==sizeof(float[3]),\n     \"XMFLOAT3 layout must be compatible with float[3]\");\n</code></pre>\n<p>Or to be paranoid, or if there are just additional members after <code>z</code>:</p>\n<pre><code> static_assert(offsetof(XMFLOAT3, y)==sizeof(float)\n               &amp;&amp; offsetof(XMFLOAT3, z)==sizeof(float)*2,\n     \"XMFLOAT3 layout must be compatible with float[3]\");\n</code></pre>\n<blockquote>\n<p id=\"so_29277949_29278260_2\">Obviously this will become implementation dependent on the declaration of XMFLOAT3.</p>\n</blockquote>\n<p>Yes, it relies on it being a standard-layout class type, and on the order and type of its data members.</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2015-03-26T12:33:45.963", "Id": "29278260", "Score": "4", "CreationDate": "2015-03-26T12:18:05.670", "LastActivityDate": "2015-03-26T12:33:45.963"}, "29278638": {"ParentId": "29277949", "CommentCount": "9", "Body": "<p>Consider a reasonably smart compiler:</p>\n<pre><code>XMFLOAT3 foo = {1.0f, 2.0f, 3.0f}; \nauto bar = &amp;foo.x;\n\nbar[2] += 5.0f;\nfoo.z += 5.0f; // Since no previous expression referenced .z, I know .z==8.0\ncout &lt;&lt; foo.z; // So optimize this to a hardcoded cout &lt;&lt; 8.0f\n</code></pre>\n<p>Replacing variable accesses and operations by known results is a common optimization. Here the optimizer sees three uses of <code>.z</code> : the initial assignment, the increment and the final use. It can trivially determine the values at these three points, and substitute those.</p>\n<p>Because struct members cannot overlap (unlike unions), <code>bar</code> which is derived from <code>.x</code> cannot overlap <code>.z</code> so <code>.bar[2]</code> cannot affect <code>.z</code>.</p>\n<p>As you see, a perfectly normal optimizer can produce the \"wrong\" result.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "29278638", "Score": "-1", "CreationDate": "2015-03-26T12:37:52.023", "LastActivityDate": "2015-03-26T12:37:52.023"}, "bq_ids": {"n4140": {"so_29277949_29278260_1": {"section_id": 7223, "quality": 0.9333333333333333, "length": 28}, "so_29277949_29278260_0": {"section_id": 5879, "quality": 0.9318181818181818, "length": 41}}, "n3337": {"so_29277949_29278260_1": {"section_id": 6967, "quality": 0.9333333333333333, "length": 28}}, "n4659": {"so_29277949_29278260_0": {"section_id": 7363, "quality": 0.9318181818181818, "length": 41}}}});