post_cb({"21785696": {"ParentId": "21785577", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2014-02-14T17:24:25.273", "Score": "1", "LastEditorUserId": "204847", "LastEditDate": "2014-02-14T17:29:40.830", "Id": "21785696", "OwnerUserId": "204847", "Body": "<p>The comparator must define a <em>strict</em> ordering; that is, it must return <code>false</code> when comparing two equivalent values. Otherwise, logic that depends on this will fail. In particular, <code>find(temp)</code> looks for a key equivalent to <code>temp</code>, that satisfies </p>\n<pre><code>!compare(key,temp) &amp;&amp; !compare(temp,key)\n</code></pre>\n<p>which will not happen unless the ordering is strict.</p>\n<p><code>less</code> (the default comparator) is strict; <code>less_equal</code> is not, so can't be used.</p>\n", "LastActivityDate": "2014-02-14T17:29:40.830"}, "21785678": {"ParentId": "21785577", "CommentCount": "0", "CreationDate": "2014-02-14T17:23:24.957", "OwnerUserId": "150634", "PostTypeId": "2", "Id": "21785678", "Score": "1", "Body": "<p>The comparator for an associative container must induce a strict weak ordering on the key type. <code>std::less_equal</code> is not a strict weak ordering. In particular, it is not strict because  <code>x &lt;= x</code> for some <code>x</code> (in fact, for all <code>x</code>). Instead, you should use <code>std::less</code>.</p>\n", "LastActivityDate": "2014-02-14T17:23:24.957"}, "bq_ids": {"n4140": {"so_21785577_21785667_0": {"section_id": 739, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_21785577_21785667_0": {"section_id": 728, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_21785577_21785667_0": {"section_id": 797, "quality": 0.9090909090909091, "length": 10}}}, "21785577": {"CommentCount": "1", "ViewCount": "60", "OwnerDisplayName": "user3234933", "CreationDate": "2014-02-14T17:18:50.233", "LastActivityDate": "2014-02-14T17:29:55.970", "PostTypeId": "1", "AcceptedAnswerId": "21785696", "Title": "multimap less_equal leading to wrong find() results", "Id": "21785577", "Score": "0", "Body": "<p>So, instead of an array I decided to use a multimap, so that I could store the repeating values along with some other value(which acts as a pair).\nSo, when I declared a multi-map like</p>\n<pre><code>multimap&lt;int,int,less_equal&lt;int&gt; &gt; M;\nmultimap&lt;int,int,less_equal&lt;int&gt; &gt;::iterator it,it2;\n</code></pre>\n<p>And then inserted all the elements into it, say</p>\n<pre><code>(10,1), (2,2), (8,3), (2,2), (8,1)\n</code></pre>\n<p>and then iterated through it, I got what I desired:</p>\n<pre><code>2 2 \n2 2\n8 1 \n8 3 \n10 1\n</code></pre>\n<p>But now, the find function just doesn't work\nLike, if I want to find a number, say</p>\n<pre><code>it2=M.find(temp);\n</code></pre>\n<p>where temp is some value that exists in the multimap, say 8, it just ignores it and doesn't find it! The find function was working when I didn't include the less_equal, but since that is what I want in my program, now I am struggling with my code. Could anyone suggest a remedy to it? As well as the reason why find fails to work correctly?</p>\n", "Tags": "<c++>", "AnswerCount": "3"}, "21785667": {"ParentId": "21785577", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-02-14T17:23:00.180", "Score": "0", "LastEditorUserId": "2249683", "LastEditDate": "2014-02-14T17:29:55.970", "Id": "21785667", "OwnerUserId": "2249683", "Body": "<p>You need a less (no less equal) comparer.</p>\n<p>Two keys are equivalent if:</p>\n<blockquote>\n<p id=\"so_21785577_21785667_0\">That is, two keys k1 and k2 are considered to be equivalent if for the\n  comparison object comp, comp(k1, k2) == false &amp;&amp; comp(k2, k1) ==\n  false.</p>\n</blockquote>\n<p>(From 23.2.4 Associative containers)</p>\n", "LastActivityDate": "2014-02-14T17:29:55.970"}});