post_cb({"15398658": {"ParentId": "15398558", "CommentCount": "1", "Body": "<p>I am not sure of the exact cause but i know this:</p>\n<p>when you use multiple inheritance in a diamond pattern like this one, you will have multiple copies of the base class A in you derived object D. </p>\n<p>In your case the object D has 2 members named A::x which may cause confusion from the compiler.</p>\n<p>this is known as the <a href=\"http://en.wikipedia.org/wiki/Diamond_inheritance#The_diamond_problem\" rel=\"nofollow\">Diamon Problem</a></p>\n", "OwnerUserId": "2157349", "PostTypeId": "2", "Id": "15398658", "Score": "-1", "CreationDate": "2013-03-13T23:45:01.313", "LastActivityDate": "2013-03-13T23:45:01.313"}, "15398637": {"ParentId": "15398558", "CommentCount": "11", "Body": "<p>This is most certainly a <strong>bug</strong>. There is no reason why inheriting from class <code>B</code> as well should change the accessibility of <code>C</code>'s members. </p>\n<p>Not even GCC 4.8.0 (beta) seems to have solved this problem. Clang 3.2 and ICC 13.0.1, on the other hand, <a href=\"http://liveworkspace.org/code/188WMz%2473\">correctly refuse to compile this code</a>.</p>\n", "OwnerUserId": "1932150", "PostTypeId": "2", "Id": "15398637", "Score": "10", "CreationDate": "2013-03-13T23:43:13.217", "LastActivityDate": "2013-03-13T23:43:13.217"}, "15421410": {"ParentId": "15398558", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>The answer is clang is correct. However, the code could also fail as ambiguous according to the standard.</p>\n<p>If you look at 11.2p5 it has a relevant note (yes, I know notes are non-normative):</p>\n<blockquote>\n<p id=\"so_15398558_15421410_0\">[ Note: This class can be explicit, e.g., when a qualified-id is used,\n  or implicit, e.g., when a class member access operator (5.2.5) is used\n  (including cases where an implicit \u201cthis-&gt;\u201d is added). <strong>If both a class\n  member access operator and a qualified-id are used to name the member\n  (as in <code>p-&gt;T::m</code>), the class naming the member is the class denoted by\n  the nested-name-specifier of the qualified-id (that is, T)</strong>. \u2014end note\n  ]</p>\n</blockquote>\n<p>What this note means, is that if you add <code>this-&gt;</code> to <code>C::x = 2;</code> then <code>C</code> is the class naming the member and <a href=\"http://liveworkspace.org/code/F2wWf%240\" rel=\"nofollow\">gcc 4.7.2 correctly fails when this is the case</a>.</p>\n<p>Now the question is <strong>Who is the class naming the member for</strong> <code>C::x</code>?\nThe <code>naming class</code> is specified by the same <code>11.2p5</code>:</p>\n<blockquote>\n<p id=\"so_15398558_15421410_1\">The access to a member is affected by the class in which the member is\n  named. <strong>This naming class is the class in which the member name was\n  looked up and found.</strong></p>\n</blockquote>\n<p>Now, name lookup for class members is specified in 10.2, and after reading all of it, I have concluded that <code>x</code> is the <strong>union</strong> of subobject sets as per:</p>\n<blockquote>\n<p id=\"so_15398558_15421410_2\">Otherwise, the new S(f, C) is a lookup set with the shared set of\n  declarations and the union of the subobject sets.</p>\n</blockquote>\n<p>Which means that according to member lookup rules <code>x</code> can be either from <code>B</code> <em>or</em> <code>A</code>! This makes the code ill-formed as: <code>Name\nlookup can result in an ambiguity, in which case the program is ill-formed.</code>\nHowever, this ambiguity <strong>can</strong> be resolved as per 10.2p8:</p>\n<blockquote>\n<p id=\"so_15398558_15421410_3\">Ambiguities can often be resolved by qualifying a name with its class\n  name.</p>\n</blockquote>\n<p>And from the <a href=\"https://llvm.org/viewvc/llvm-project/cfe/trunk/lib/Sema/SemaExpr.cpp?sortby=rev&amp;r1=97677&amp;r2=97676&amp;pathrev=97677\" rel=\"nofollow\">Clang source</a>, we can see that is what they chose to do:</p>\n<pre><code>// If the member was a qualified name and the qualified referred to a\n// specific base subobject type, we'll cast to that intermediate type\n// first and then to the object in which the member is declared. That allows\n// one to resolve ambiguities in, e.g., a diamond-shaped hierarchy such as:\n//\n//   class Base { public: int x; };\n//   class Derived1 : public Base { };\n//   class Derived2 : public Base { };\n//   class VeryDerived : public Derived1, public Derived2 { void f(); };\n//   void VeryDerived::f() {\n//     x = 17; // error: ambiguous base subobjects\n//     Derived1::x = 17; // okay, pick the Base subobject of Derived1\n//   }\n</code></pre>\n<p>However, note the <code>can</code> in the wording of the above quote: <code>often can be resolved</code>. This means that <strong>they do not necessarily have to be resolved</strong>. So, I think according to the standard the code should fail as ambiguous or as a private member access failure.</p>\n<p><strong>EDIT</strong></p>\n<p>There is some contention about the interpretation of <code>can</code> and as to whether a ambiguity occurs here. I found <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#39\" rel=\"nofollow\">Defect report 39. Conflicting ambiguity rules</a> talks about this issue.</p>\n", "OwnerUserId": "906773", "LastEditorUserId": "906773", "LastEditDate": "2013-03-15T03:27:40.163", "Id": "15421410", "Score": "3", "CreationDate": "2013-03-14T22:27:38.840", "LastActivityDate": "2013-03-15T03:27:40.163"}, "15398558": {"CommentCount": "6", "AcceptedAnswerId": "15398637", "PostTypeId": "1", "LastEditorUserId": "373025", "CreationDate": "2013-03-13T23:34:44.320", "LastActivityDate": "2013-03-15T03:27:40.163", "LastEditDate": "2013-03-13T23:42:17.600", "ViewCount": "732", "FavoriteCount": "1", "Title": "Private base class and multiple inheritance", "Id": "15398558", "Score": "14", "Body": "<p>Consider :</p>\n<pre><code>struct A { int x;};\nstruct B : A {};\nstruct C : private A {};\n</code></pre>\n<p>Now, as expected, the code</p>\n<pre><code>struct D : C\n{\n    D () { C::x = 2; }\n};\n\nint main () { D d; }\n</code></pre>\n<p>does not compile:</p>\n<pre><code>test2.cc: In constructor \u2018D::D()\u2019:\ntest2.cc:1:16: error: \u2018int A::x\u2019 is inaccessible\ntest2.cc:7:12: error: within this context\n</code></pre>\n<p>Now, if I do</p>\n<pre><code>struct D : B, C\n{\n    D () { C::x = 2; }\n};\n\nint main () { D d; }\n</code></pre>\n<p>then the error disappear! Isn't <code>A::x</code> supposed to be inaccessible too? What is the explanation here?</p>\n<p>I'm using <code>gcc version 4.7.2 (GCC)</code>, linux x86_64, if this matters.</p>\n<p><strong>EDIT:</strong> It does not compile with Clang 3.2: <a href=\"http://liveworkspace.org/code/188WMz$74\" rel=\"noreferrer\">clang 3.2</a></p>\n<p>But it does with gcc 4.7.2: <a href=\"http://ideone.com/clone/VvWyUW\" rel=\"noreferrer\">gcc 4.7.2</a></p>\n", "Tags": "<c++>", "OwnerUserId": "373025", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_15398558_15421410_3": {"section_id": 6996, "quality": 1.0, "length": 9}, "so_15398558_15421410_2": {"section_id": 6994, "quality": 1.0, "length": 10}, "so_15398558_15421410_0": {"section_id": 6682, "quality": 0.8648648648648649, "length": 32}, "so_15398558_15421410_1": {"section_id": 6682, "quality": 0.875, "length": 14}}, "n3337": {"so_15398558_15421410_3": {"section_id": 6742, "quality": 1.0, "length": 9}, "so_15398558_15421410_2": {"section_id": 6740, "quality": 1.0, "length": 10}, "so_15398558_15421410_0": {"section_id": 6437, "quality": 0.8648648648648649, "length": 32}, "so_15398558_15421410_1": {"section_id": 6437, "quality": 0.875, "length": 14}}, "n4659": {"so_15398558_15421410_3": {"section_id": 8494, "quality": 1.0, "length": 9}, "so_15398558_15421410_2": {"section_id": 8492, "quality": 1.0, "length": 10}, "so_15398558_15421410_0": {"section_id": 8157, "quality": 0.8648648648648649, "length": 32}, "so_15398558_15421410_1": {"section_id": 8157, "quality": 0.875, "length": 14}}}});