post_cb({"37902495": {"ParentId": "37901693", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Your last argument is nonsense. <code>\"foo\"</code> isn't even grammatically a name, but a <em>string-literal</em>. And string literals being lvalues and some lvalues having names does not imply that string literals are or have names. String literals as used in your code do not violate the ODR.</p>\n<p>It was actually, until C++11, mandated that string literals in multiple definitions of inline functions across TUs designate the same entity, but that superfluous and mostly unimplemented rule was removed by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1823\" rel=\"noreferrer\">CWG 1823</a>.</p>\n<blockquote>\n<p id=\"so_37901693_37902495_0\">Because, the name <code>\"foo\"</code> might not correspond to the same object in the\n  two compilation units -- it's potentially a \"different\" string literal\n  in each, no?</p>\n</blockquote>\n<p>Correct, but that's irrelevant. Because the ODR does not care about specific argument values. If you did manage to somehow get a different e.g. function template specialization to be called in both TUs, that would be problematic, but fortunately string literals are invalid template arguments, so you're gonna have to be clever.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2016-06-18T23:27:42.823", "Id": "37902495", "Score": "6", "CreationDate": "2016-06-18T23:18:59.290", "LastActivityDate": "2016-06-18T23:27:42.823"}, "bq_ids": {"n4140": {"so_37901693_37901693_1": {"section_id": 7043, "quality": 0.9375, "length": 15}, "so_37901693_37901693_4": {"section_id": 5947, "quality": 0.875, "length": 7}, "so_37901693_37901693_0": {"section_id": 7043, "quality": 0.9134615384615384, "length": 95}, "so_37901693_37901693_3": {"section_id": 5333, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_37901693_37901693_1": {"section_id": 6788, "quality": 1.0, "length": 16}, "so_37901693_37901693_4": {"section_id": 5717, "quality": 0.875, "length": 7}, "so_37901693_37901693_0": {"section_id": 6788, "quality": 0.8942307692307693, "length": 93}, "so_37901693_37901693_3": {"section_id": 5130, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_37901693_37901693_1": {"section_id": 8540, "quality": 0.9375, "length": 15}, "so_37901693_37901693_4": {"section_id": 7433, "quality": 0.875, "length": 7}, "so_37901693_37901693_0": {"section_id": 8540, "quality": 0.8846153846153846, "length": 92}, "so_37901693_37901693_3": {"section_id": 6754, "quality": 0.8571428571428571, "length": 6}}}, "37901693": {"CommentCount": "9", "AcceptedAnswerId": "37902495", "PostTypeId": "1", "LastEditorUserId": "3598119", "CreationDate": "2016-06-18T21:13:51.653", "LastActivityDate": "2016-06-19T02:35:48.077", "LastEditDate": "2016-06-19T02:35:48.077", "ViewCount": "343", "FavoriteCount": "2", "Title": "Strings in headers -- does this violate the ODR?", "Id": "37901693", "Score": "9", "Body": "<p>Consider the following program with two compilation units.</p>\n<hr>\n<pre><code>// a.hpp\n\nclass A {\n  static const char * get() { return \"foo\"; }\n};\n\nvoid f();\n</code></pre>\n<hr>\n<pre><code>// a.cpp\n\n#include \"a.hpp\"\n#include &lt;iostream&gt;\n\nvoid f() {\n  std::cout &lt;&lt; A::get() &lt;&lt; std::endl;\n}\n</code></pre>\n<hr>\n<pre><code>// main.cpp\n\n#include \"a.hpp\"\n#include &lt;iostream&gt;\n\nvoid g() {\n  std::cout &lt;&lt; A::get() &lt;&lt; std::endl;\n}\n\nint main() {\n  f();\n  g();\n}\n</code></pre>\n<hr>\n<p>It is quite common to need to create global string constants for some reason or other. Doing this in the totally naive way causes linker problems. Usually, people put a declaration in the header and a definition in a single compilation unit, or use macros.</p>\n<p>I had been under the impression that this way of doing it (shown above) with a function was \"okay\", because it is an <code>inline</code> function and the linker eliminates any duplicate copies that are produced, and programs written using this pattern seem to work fine. However, now I have my doubts about whether it's actually legitimate.</p>\n<p>The function <code>A::get</code> is odr-used in two different translation units, but it is implicitly inline since it is a class member.</p>\n<p>In <code>[basic.def.odr.6]</code> it states:</p>\n<blockquote>\n<p id=\"so_37901693_37901693_0\">There can be more than one definition of a ... inline function with\n  external linkage (7.1.2)... in a program provided that each definition\n  appears in a different translation unit, and provided the definitions satisfy the following requirements. Given\n  such an entity named <code>D</code> defined in more than one translation unit, then<br>\n  - each definition of <code>D</code> shall consist of the same sequence of tokens; and<br>\n  - in each definition of <code>D</code>, corresponding names, looked up according to 3.4, shall refer to an entity defined\n  within the definition of <code>D</code>, or shall refer to the same entity, after overload resolution (13.3) and after\n  matching of partial template specialization (14.8.3), except that a name can refer to a non-volatile\n  const object with internal or no linkage if the object has the same literal type in all definitions of <code>D</code>,\n  and the object is initialized with a constant expression (5.19), and the object is not odr-used, and the\n  object has the same value in all definitions of <code>D</code>; and<br>\n  - in each definition of <code>D</code>, corresponding entities shall have the same language linkage; and<br>\n  - ... (more conditions that don't seem relevant)  </br></br></br></br></p>\n<p id=\"so_37901693_37901693_1\">If the definitions of <code>D</code> satisfy all these requirements,\n  then the program shall behave as if there were a single definition of <code>D</code>. If the definitions of <code>D</code> do not satisfy\n  these requirements, then the behavior is undefined.</p>\n</blockquote>\n<p>In my example program, the two definitions (one in each translation unit) each correspond to the same sequence of tokens. (This is why I originally thought it was okay.)</p>\n<p>However, it's not clear that the second condition is satisfied. Because, the name <code>\"foo\"</code> might not correspond to the same object in the two compilation units -- it's potentially a \"different\" string literal in each, no?</p>\n<p>I tried changing the program:</p>\n<pre><code>  static const void * get() { return static_cast&lt;const void*&gt;(\"foo\"); }\n</code></pre>\n<p>so that it prints the address of the string literal, and I get the same address, however I'm not sure if that's guaranteed to happen.</p>\n<p>Does it fall under \"... shall refer to an entity defined within the definition of <code>D</code>\"? Is <code>\"foo\"</code> considered to be defined within <code>A::get</code> here? It might seem so, but as I understand informally, string literals ultimately cause the compiler to emit some sort of global <code>const char[]</code> which lives in a special segment of the executable. Is that \"entity\" considered to be within <code>A::get</code> or is that not relevant?</p>\n<p>Is <code>\"foo\"</code> even considered a \"name\", or does the term \"name\" refer only a valid C++ \"identifier\", like could be used for a variable or function ? On the one hand it says:</p>\n<blockquote>\n<p id=\"so_37901693_37901693_2\"><code>[basic][3.4]</code><br>\n  A name is a use of an identifier (2.11), operator-function-id (13.5), literal-operator-id (13.5.8), conversion-\n  function-id (12.3.2), or template-id (14.2) that denotes an entity or label (6.6.4, 6.1).</br></p>\n</blockquote>\n<p>and an identifier is</p>\n<blockquote>\n<p id=\"so_37901693_37901693_3\"><code>[lex.name][2.11]</code><br>\n  An identifier is an arbitrarily long sequence of letters and digits.</br></p>\n</blockquote>\n<p>so it seems like a string literal is not a name.</p>\n<p>On the other hand in section 5</p>\n<blockquote>\n<p id=\"so_37901693_37901693_4\"><code>[expr.prim.general][5.1.1.1]</code><br>\n  A string literal is an lvalue; all other\n  literals are prvalues.</br></p>\n</blockquote>\n<p>Generally, I thought that <code>lvalues</code> have names.</p>\n</hr></hr></hr></hr>", "Tags": "<c++><c++11><c++14><language-lawyer><one-definition-rule>", "OwnerUserId": "3598119", "AnswerCount": "1"}});