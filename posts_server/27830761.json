post_cb({"27830856": {"ParentId": "27830761", "PostTypeId": "2", "CommentCount": "16", "Body": "<p>A workaround that I used for a long time and recently became more useful in c++11:</p>\n<p><strong><kbd><a href=\"http://coliru.stacked-crooked.com/a/b0f7f9634c57c7d5\" rel=\"nofollow\">Live On Coliru</a></kbd></strong></p>\n<pre><code>struct easy\n{\n    enum : int { a = 5 };\n    int b;\n\n    constexpr easy(int b_) : b(b_&lt;a? a : b_)\n    {}\n};\n</code></pre>\n<p>It became more useful because you can now specify the underlying type:</p>\n<pre><code>struct Container\n{\n    enum special_position : size_t { npos = size_t(-1), at_bof = 0 };\n};\n</code></pre>\n<p>Of course it's limited to (userdefined/primitive) integral types.</p>\n<hr>\n<blockquote>\n<p id=\"so_27830761_27830856_0\"><em>Externally defined constants may have the benefit that they could actually be changed by only recompiling the translation unit that defines the value.</em></p>\n</blockquote>\n</hr>", "OwnerUserId": "85371", "LastEditorUserId": "85371", "LastEditDate": "2015-01-08T00:18:05.297", "Id": "27830856", "Score": "2", "CreationDate": "2015-01-08T00:00:41.510", "LastActivityDate": "2015-01-08T00:18:05.297"}, "27883353": {"ParentId": "27830761", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>First of all, a declaration of a static data member in class is never a definition. <strong>If you odr-use that variable, a definition must be present</strong> - out of class, of course.  </p>\n<p><code>std::max</code> does indeed odr-use <code>a</code>, as its parameters are references, and variables are odr-used if a reference is bound to them ([basic.def.odr]/3). (That is indeed a problem with <code>max</code> - it shouldn't odr-use <code>a</code>, really.)<br>\nIn @sehe's answer, he is using the ternary operator directly, avoiding an odr-use as the lvalue-to-rvalue transformation is immediately applied and yields a constant expression.</br></p>\n<ol>\n<li><p>It's quite simple. When the definition of a static data member of a class template is needed, i.e. when that member is odr-used as in your case, the (namespace scope) definition is instantiated. [temp.inst]/2:</p>\n<blockquote>\n<p id=\"so_27830761_27883353_0\">Unless a member of a class template or a member template has been\n  explicitly instantiated or explicitly specialized, <strong>the specialization\n  of the member is implicitly instantiated when the specialization is\n  referenced in a context that requires the member definition to exist</strong>;\n  in particular, the initialization (and any associated  side-effects)\n  of a static data member does not occur unless the static data member\n  is itself used in a way   that requires the definition of the static\n  data member to exist.</p>\n</blockquote>\n<p>And the definition is done exactly as you did it. [temp.static]/1:</p>\n<blockquote>\n<p id=\"so_27830761_27883353_1\">A definition for a static data member or static data member template\n  may be provided in a namespace scope enclosing the definition of the\n  static member\u2019s class template. </p>\n<p id=\"so_27830761_27883353_2\">[ <em>Example:</em></p>\n<pre><code>template&lt;class T&gt; class X {\n    static T s;\n};\ntemplate&lt;class T&gt; T X&lt;T&gt;::s = 0;\n</code></pre>\n</blockquote>\n<p>The initializer can be supplied at the declaration in-class when the member is of <code>const</code> integral type, but that doesn't affect the semantics of the ODR in this respect. The definition is still required in the same way and written just as you did it.</p></li>\n</ol>\n<p>Hence it seems what you see is solely a VC++ bug.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-01-11T02:38:38.967", "Id": "27883353", "Score": "5", "CreationDate": "2015-01-11T02:23:32.530", "LastActivityDate": "2015-01-11T02:38:38.967"}, "bq_ids": {"n4140": {"so_27830761_27883353_0": {"section_id": 234, "quality": 0.9767441860465116, "length": 42}, "so_27830761_27883353_1": {"section_id": 107, "quality": 1.0, "length": 18}}, "n3337": {"so_27830761_27883353_0": {"section_id": 227, "quality": 0.9767441860465116, "length": 42}, "so_27830761_27883353_1": {"section_id": 102, "quality": 0.7777777777777778, "length": 14}}, "n4659": {"so_27830761_27883353_0": {"section_id": 244, "quality": 0.9534883720930233, "length": 41}, "so_27830761_27883353_1": {"section_id": 111, "quality": 1.0, "length": 18}}}, "27830761": {"CommentCount": "10", "AcceptedAnswerId": "27883353", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-01-07T23:51:04.127", "LastActivityDate": "2015-01-11T02:38:38.967", "LastEditDate": "2017-05-23T10:33:19.140", "ViewCount": "1126", "FavoriteCount": "1", "Title": "C++ template static integer constants: out of class definition", "Id": "27830761", "Score": "9", "Body": "<p>This question is about the relationship between templates and static integral constants in Visual Studio C++ 2013 with flag /Za. It has implications for the boost library.</p>\n<hr>\n<p>First, let us check the code without templates:</p>\n<pre><code>struct easy\n{\n    static const int a = 5;\n    const int b;\n\n    easy( int b_ ) : b( std::max( b_, a ) )\n    {}\n};\n\nconst int easy::a;\n\nint main()\n{\n    easy d_Easy( 0 );\n    return 0;\n}\n</code></pre>\n<p>According to the manual page for <a href=\"http://msdn.microsoft.com/en-us/library/34h23df8.aspx\" rel=\"nofollow noreferrer\">compiler option /Za</a>: \"Under the standard (/Za), you must make an out-of-class definition for data members\". The example in that page and the code above declares the static constant within the class and specifies its value there. The need for the out of class definition is explained in <a href=\"https://stackoverflow.com/questions/3025997/c-defining-static-const-integer-members-in-class-definition\">this link</a>.</p>\n<hr>\n<p>Now, let us see the problem with templates.</p>\n<pre><code>template&lt; class T &gt;\nstruct problem\n{\n    static const int a = 5;\n    const int b;\n\n    problem( int b_ ) : b( std::max( b_, a ) )\n    {}\n};\n\ntemplate&lt; class T &gt;\nconst int problem&lt; T &gt;::a;\n\nint main()\n{\n    problem&lt; char &gt; d_Bad( 666 );\n    return 0;\n}\n</code></pre>\n<p>When compiling with /Za, the linker throws an error \"LNK2019: unresolved external symbol\". That error does not appear with option /Ze.The major problem is that some boost libraries use BOOST_STATIC_CONSTANT and BOOST_NO_INCLASS_MEMBER_INITIALIZATION in code similar to the above snipet.</p>\n<hr>\n<p>Hacking some:</p>\n<pre><code>template&lt; class T &gt;\nstruct fixed\n{\n    static const int a;\n    const int b;\n\n    fixed( int b_ ) : b( std::max( b_, a ) )\n    {}\n};\n\ntemplate&lt; class T &gt;\nconst int fixed&lt; T &gt;::a = 5;\n\nint main()\n{\n    fixed&lt; char &gt; d_Good( 777 );\n    return 0;\n}\n</code></pre>\n<p>This code now compiles with /Za.</p>\n<p><strong>Questions:</strong></p>\n<p>1) What does the C++11 standard say about templates and static integral constants? Can/must they have an out of class definition but their value be provided in the class definition?</p>\n<p>2) Does boost have some workarounds?</p>\n<hr>\n<p><strong>UPDATE</strong></p>\n<p>It is important to keep the <code>std::max</code> in the code because (I think) it tries to get the reference to its parameters. If one uses <code>b_&lt;a</code> then the compiler simply optimizes those constants away.</p>\n</hr></hr></hr></hr>", "Tags": "<templates><c++11><boost><initialization><static-members>", "OwnerUserId": "2549876", "AnswerCount": "2"}});