post_cb({"37304238": {"ParentId": "37303968", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Have you try casting the pointer address to and from <code>uintptr_t</code>, which is an unsigned integer capable of holding a pointer value?\nThe type is defined in a standard header <code>&lt;cstdint&gt;</code> but it is only optional. If it does not exist in your version of C++, try <code>size_t</code> instead.</p>\n<p>A full example would then look like:</p>\n<pre><code>#include &lt;cstdint&gt;\n\nclass foo\n{\n    int baz;\n};\n\ntemplate&lt;uintptr_t addr&gt; class bar\n{\n    constexpr static const foo* f = (foo*)(addr);\npublic:\n    bar() {}\n    void update() {  }\n};\n\n#define FOO_ADDR ((uintptr_t)0x80103400)\n\nint main() {\n    bar&lt;FOO_ADDR&gt; myFoo;\n}\n</code></pre>\n<p>The obvious drawback is that there is no typechecking at the template parameter. You pass a value which will hopefully refer to <code>foo</code> object and not a different one.</p>\n<p>Not to mention that we are in the undefined behavior world as far as the standard goes....</p>\n<hr>\n<p>You seem to be able to compile with the line</p>\n<pre><code>constexpr static const foo* f = reinterpret_cast&lt;foo*&gt;(addr);\n</code></pre>\n<p>with at least some of the compilers as well (<a href=\"http://coliru.stacked-crooked.com/a/5af62bedecf2d75a\" rel=\"nofollow\">http://coliru.stacked-crooked.com/a/5af62bedecf2d75a</a>)</p>\n<hr>\n<p>If your compiler rejects casting in the context of <code>constexpr</code> as it is ill-formed (as per Barry's comment) you can define it as a regular <code>static const</code> variable:</p>\n<pre><code>template&lt;uintptr_t addr&gt;\nclass bar\n{\n    static const foo* f;\npublic:\n    bar() {}\n    void update() {  }\n};\n\ntemplate&lt;uintptr_t addr&gt;\nconst foo* bar&lt;addr&gt;::f = reinterpret_cast&lt;foo*&gt;(addr);\n</code></pre>\n<p>Less ideal but solves that problem hopefully.</p>\n</hr></hr>", "OwnerUserId": "635654", "LastEditorUserId": "635654", "LastEditDate": "2016-05-18T16:17:31.740", "Id": "37304238", "Score": "0", "CreationDate": "2016-05-18T15:37:51.957", "LastActivityDate": "2016-05-18T16:17:31.740"}, "37303968": {"CommentCount": "4", "ViewCount": "284", "PostTypeId": "1", "LastEditorUserId": "98328", "CreationDate": "2016-05-18T15:26:01.367", "LastActivityDate": "2016-05-18T16:17:31.740", "Title": "using an absolute pointer address as a template argument", "AcceptedAnswerId": "37304416", "LastEditDate": "2016-05-18T15:59:51.980", "Id": "37303968", "Score": "9", "Body": "<p>I have a template class which takes as its first template argument a foo * pointer. I'd like to instantiate one of these with a foo located at an absolute address, like so:</p>\n<pre><code>class foo\n{\n    int baz;\n};\n\ntemplate&lt;foo *f&gt; class bar\n{\npublic:\n    bar() {}\n    void update() { /* ... */ }\n};\n\n// ....\n\n#define FOO_ADDR ((foo *)0x80103400)\n#define FOO_NULL ((foo *)0)\n\nfoo testFoo;\n\nbar&lt;FOO_ADDR&gt; myFoo;        // fails with non-integral argument\nbar&lt;FOO_NULL&gt; huh;          // compiles, I was surprised by this\nbar&lt;&amp;testFoo&gt; test;         // compiles as expected (but not useful)\n</code></pre>\n<p>Does anyone know if it's possible without resorting to the linker and getting FOO_ADDR to be defined with external linkage?</p>\n<p>This is with the Keil ARM C/C++ Compiler version V5.06 update 1 (build 61), I've tried switching on C++11 mode but (apart from throwing a load of new errors in the system headers) it didn't change the behaviour.</p>\n<p>Update: here's the proposed solution (with the real code this time) using int casts</p>\n<pre><code>template&lt;uint32 PORT, uint32 BIT, uint32 RATE&gt; class LedToggle\n{\n    uint32 mTicks;\n    uint32 mSetReset;\n\n    public:\n\n    LedToggle()\n    {\n        mTicks = 0;\n        mSetReset = 1 &lt;&lt; BIT;\n    }\n\n    void Update()\n    {\n        uint32 mask = ((mTicks++ &amp; RATE) - 1) &gt;&gt; 31;\n        ((GPIO_TypeDef *)PORT)-&gt;BSRR = mSetReset &amp; mask;\n        mSetReset ^= ((1 &lt;&lt; BIT) | (1 &lt;&lt; (BIT + 16))) &amp; mask;\n    }\n};\n\nLedToggle&lt;(uint32)GPIOC, 13, 1023&gt; led;\n</code></pre>\n<p>It's pretty ugly, but it does work. I'd be interested to hear if anyone can improve on it?</p>\n", "Tags": "<c++><templates><pointers>", "OwnerUserId": "98328", "AnswerCount": "4"}, "37304416": {"ParentId": "37303968", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>The declaration <code>bar&lt;(foo*)0x80103400&gt; myFoo;</code> is ill-formed because non-type template arguments must be a constant expression, from [temp.arg.nontype]:</p>\n<blockquote>\n<p id=\"so_37303968_37304416_0\">A <em>template-argument</em> for a non-type <em>template-parameter</em> shall be a converted constant expression (5.20) of the type of the <em>template-parameter</em>.</p>\n</blockquote>\n<p>And the argument you are passing is not, from [expr.const]:</p>\n<blockquote>\n<p id=\"so_37303968_37304416_1\">A conditional-expression e is a core constant expression unless the evaluation of e, following the rules of the\n  abstract machine (1.9), would evaluate one of the following expressions:<br>\n  \u2014 [...]<br>\n  \u2014 a <code>reinterpret_cast</code> (5.2.10);<br>\n  \u2014 [...]</br></br></br></p>\n</blockquote>\n<p>The declaration <code>bar&lt;(foo*)0&gt; huh</code> works since it does not involve a cast, it's simply a null pointer of type <code>foo*</code> (<code>0</code> is special) and so it is a valid constant expression. </p>\n<hr/>\n<p>You could instead simply pass in the address as a template non-type parameter:</p>\n<pre><code>template &lt;uintptr_t address&gt;\nstruct bar { ... };\n\nbar&lt;0x8013400&gt; myFooWorks;\n</code></pre>\n<p>That is viable.</p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2016-05-18T16:00:34.073", "Id": "37304416", "Score": "5", "CreationDate": "2016-05-18T15:46:04.340", "LastActivityDate": "2016-05-18T16:00:34.073"}, "37304432": {"ParentId": "37303968", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>From the C++11 Standard (emphasis mine):</p>\n<blockquote>\n<p id=\"so_37303968_37304432_0\"><strong>14.3.2 Template non-type arguments</strong></p>\n<p id=\"so_37303968_37304432_1\">1 A <em>template-argument</em> for a non-type, non-template <em>template-parameter</em> shall be one of:</p>\n<p id=\"so_37303968_37304432_2\">\u2014 for a non-type <em>template-parameter</em> of integral or enumeration type, a converted constant expression (5.19) of the type of the <em>template-parameter</em>; or</p>\n<p id=\"so_37303968_37304432_3\">\u2014 the name of a non-type <em>template-parameter</em>; or</p>\n<p id=\"so_37303968_37304432_4\">\u2014 a constant expression (5.19) <strong>that designates the address of an object with static storage duration and external or internal linkage</strong> or a function with external or internal linkage, including function templates and function <em>template-ids</em> but excluding non-static class members, expressed (ignoring parentheses) as <code>&amp;</code> <em>id-expression</em>, except that the <code>&amp;</code> may be omitted if the name refers to a function or array and shall be omitted if the corresponding <em>template-parameter</em> is a reference; or</p>\n<p id=\"so_37303968_37304432_5\">\u2014 a constant expression that evaluates to a <strong>null pointer value</strong> (4.10); or</p>\n</blockquote>\n<p>When compiled with <code>g++ -Wall</code>, I get the following error:</p>\n<pre><code>error: \u20182148545536u\u2019 is not a valid template argument for \u2018foo*\u2019 because it is not the address of a variable\n    bar&lt;FOO_ADDR&gt; myFoo;        // fails with non-integral argument\n                       ^ \n</code></pre>\n<p>It seems that the compiler is able to detect that <code>0x80103400</code> is <em>not</em> the address of a variable, it's just a constant expression.</p>\n", "OwnerUserId": "434551", "LastEditorUserId": "434551", "LastEditDate": "2016-05-18T16:05:48.817", "Id": "37304432", "Score": "0", "CreationDate": "2016-05-18T15:46:50.997", "LastActivityDate": "2016-05-18T16:05:48.817"}, "bq_ids": {"n4140": {"so_37303968_37304432_5": {"section_id": 87, "quality": 0.8571428571428571, "length": 6}, "so_37303968_37304432_4": {"section_id": 87, "quality": 0.975609756097561, "length": 40}, "so_37303968_37304416_1": {"section_id": 6185, "quality": 0.875, "length": 14}, "so_37303968_37304432_1": {"section_id": 87, "quality": 1.0, "length": 5}, "so_37303968_37304416_0": {"section_id": 87, "quality": 0.8888888888888888, "length": 8}, "so_37303968_37304432_2": {"section_id": 87, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_37303968_37304432_5": {"section_id": 36, "quality": 0.8571428571428571, "length": 6}, "so_37303968_37304432_1": {"section_id": 82, "quality": 1.0, "length": 5}, "so_37303968_37304432_4": {"section_id": 82, "quality": 0.975609756097561, "length": 40}, "so_37303968_37304416_0": {"section_id": 82, "quality": 0.8888888888888888, "length": 8}, "so_37303968_37304432_2": {"section_id": 82, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_37303968_37304432_5": {"section_id": 7690, "quality": 0.7142857142857143, "length": 5}, "so_37303968_37304416_1": {"section_id": 7687, "quality": 0.75, "length": 12}, "so_37303968_37304416_0": {"section_id": 90, "quality": 0.8888888888888888, "length": 8}, "so_37303968_37304432_2": {"section_id": 90, "quality": 0.6363636363636364, "length": 7}}}, "37304430": {"ParentId": "37303968", "CommentCount": "1", "Body": "<p>First, don't use c-style casts. It doesn't make it explicit what is does.</p>\n<p>Second, you will realize that in order to cast an arbitrary number into a pointer, you need to use <code>reinterpret_cast</code>. This sort of cast is not allowed in constexpr expressions.</p>\n<p>Since template parameters are only possible with constant expressions, an arbitrary number as a pointer is not possible.</p>\n<p>The case where 0 is possible is because 0 is convertible to nullptr, which is constant expression.</p>\n", "OwnerUserId": "2104697", "PostTypeId": "2", "Id": "37304430", "Score": "-2", "CreationDate": "2016-05-18T15:46:50.880", "LastActivityDate": "2016-05-18T15:46:50.880"}});