post_cb({"2695607": {"CommentCount": "0", "AcceptedAnswerId": "2695628", "PostTypeId": "1", "LastEditorUserId": "77915", "CreationDate": "2010-04-23T01:22:27.843", "LastActivityDate": "2012-05-02T21:07:20.290", "LastEditDate": "2012-05-02T21:07:20.290", "ViewCount": "782", "FavoriteCount": "1", "Title": "Is it a good idea to index an STL map with a pair?", "Id": "2695607", "Score": "2", "Body": "<p>I'm just wondering if it is a good idea to make a data structure like</p>\n<pre><code>std::map&lt; std::pair&lt;int,int&gt;,std::string &gt;\n</code></pre>\n<p>Just wondering how the pairs would be ordered internally... :S</p>\n<p>Thanks!</p>\n", "Tags": "<c++><stl><stdmap><std-pair>", "OwnerUserId": "283271", "AnswerCount": "3"}, "2695628": {"ParentId": "2695607", "CommentCount": "1", "CreationDate": "2010-04-23T01:29:51.740", "OwnerUserId": "151292", "PostTypeId": "2", "Id": "2695628", "Score": "9", "Body": "<p>The pairs would be ordered using the pair <code>operator&lt;</code> (the default compare operation for <code>std::map</code>), which </p>\n<blockquote>\n<p id=\"so_2695607_2695628_0\">Returns: <code>x.first &lt; y.first || (!(y.first &lt; x.first) &amp;&amp; x.second &lt; y.second)</code> </p>\n</blockquote>\n<p>(C++03, 20.2.2/6)</p>\n<p>Note that it could get confusing using a pair as a map key, especially when working with map iterators (<code>it-&gt;first.first</code> to get the first element of the key pair just looks ridiculous).  But in some cases it might be easier than creating a whole new struct for the key.  </p>\n<p>As with all things, use with care, and if it's not straightforward and easy to understand, it's probably better to find a different way to do it.</p>\n", "LastActivityDate": "2010-04-23T01:29:51.740"}, "2695633": {"ParentId": "2695607", "CommentCount": "0", "CreationDate": "2010-04-23T01:31:25.377", "OwnerUserId": "178060", "PostTypeId": "2", "Id": "2695633", "Score": "1", "Body": "<p>If you're looking to have two indexes for your hash table then you should look at <a href=\"http://www.boost.org/doc/libs/1_39_0/libs/multi_index/doc/index.html\" rel=\"nofollow noreferrer\">Boost::multiindex</a> containers.</p>\n<p>As far as answering your question, why not if you can deal with the limitations others have pointed out.  I'm always for any solution that is clear, easy to use, and suits the purposes of the problem at hand.</p>\n", "LastActivityDate": "2010-04-23T01:31:25.377"}, "bq_ids": {"n4140": {"so_2695607_2695628_0": {"section_id": 3990, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_2695607_2695628_0": {"section_id": 3847, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_2695607_2695628_0": {"section_id": 4901, "quality": 0.8571428571428571, "length": 6}}}, "2695627": {"ParentId": "2695607", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2010-04-23T01:29:12.990", "Score": "1", "LastEditorUserId": "456", "LastEditDate": "2010-04-23T01:37:00.247", "Id": "2695627", "OwnerUserId": "456", "Body": "<p>You can. In my opinion though you should do something more expressive than that, because <code>std::pair</code> wasn't meant for this. For example, if you want to store strings in a map by their hash then you can do something like:</p>\n<pre><code>struct Hash {\n    int hash_low;\n    int hash_high;\n\n    bool operator&lt;(const Hash&amp; other) const;\n};\n</code></pre>\n<p>And then use <code>map&lt;Hash,string&gt;</code> rather than <code>map&lt;pair&lt;int,int&gt;,string&gt;</code>.</p>\n", "LastActivityDate": "2010-04-23T01:37:00.247"}});