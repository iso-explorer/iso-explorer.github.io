post_cb({"27943618": {"ParentId": "27943503", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Your code is incorrect. The top-level <code>T</code> cannot be used in a SFINAE context for its methods, which is what you are trying to do. Only a substitution that takes place in an immediate context may result in a deduction failure (\u00a714.8.2/8):</p>\n<blockquote>\n<p id=\"so_27943503_27943618_0\">Only invalid types and expressions in the <strong>immediate context</strong> of the function type and its template parameter types can result in a deduction failure. [ Note: The evaluation of the substituted types and expressions can result in side effects such as the instantiation of class template specializations and/or function template specializations, the generation of implicitly-defined functions, etc. Such side effects are not in the \u201cimmediate context\u201d and can result in the program being ill-formed. \u2014 end note ]</p>\n</blockquote>\n<p>GCC and Clang are correct in rejecting your code.</p>\n<p>A workaround is just to introduce a dummy template type that defaults to the top-level <code>T</code>, and SFINAE on <em>that</em> one. Like so:</p>\n<pre><code>template &lt;typename T_ = T, // now the subsequent line *is* in\n                           // an immediate context\n          typename = typename std::enable_if &lt;\n              std::is_integral&lt;T_&gt;::value&amp;&amp; !std::is_floating_point&lt;T_&gt;::value\n          &gt;::type&gt;\nFoo(T value1 = 50, T value2 = -50) \n:value1_(value1), value2_(value2) { }\n</code></pre>\n<p>Note that <code>is_integral</code> and <code>is_floating_point</code> are mutually exclusive, you should only have to check one or the other. </p>\n<p>In this example, it'd probably be a lot simpler just to farm out the default values to another struct, so that you can have just one constructor that looks like:</p>\n<pre><code>Foo(T value1 = FooDefaults&lt;T&gt;::value1, T value2 = FooDefaults&lt;T&gt;::value2)\n: value1_(value1), value2_(value2)\n{ }\n</code></pre>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-01-14T17:51:02.970", "Id": "27943618", "Score": "7", "CreationDate": "2015-01-14T13:03:43.393", "LastActivityDate": "2015-01-14T17:51:02.970"}, "27943503": {"CommentCount": "1", "AcceptedAnswerId": "27943618", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2015-01-14T12:57:03.550", "LastActivityDate": "2015-02-07T14:02:00.283", "LastEditDate": "2015-02-07T14:02:00.283", "ViewCount": "239", "FavoriteCount": "1", "Title": "specialize a template class constructor", "Id": "27943503", "Score": "3", "Body": "<p>I want to specialize a template class constructor:</p>\n<p>If type is <em>int</em> default value is <em>50</em> and <em>-50</em>. and if it's float default should be <em>0.5</em> and <em>-0.5</em> .</p>\n<p>My code is :</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;limits&gt;\n#include &lt;type_traits&gt;\n\ntemplate&lt;typename T&gt;\nclass Foo{\npublic:\n    template&lt;typename = typename std::enable_if&lt;\n        std::is_integral&lt;T&gt;::value&amp;&amp; !std::is_floating_point&lt;T&gt;::value&gt;::type&gt;\n        Foo(T value1 = 50, T value2 = -50) :value1_(value1), value2_(value2){}\n\n    template&lt;typename = typename std::enable_if&lt;\n        std::is_floating_point&lt;T&gt;::value&gt;::type&gt;\n        Foo(T value1 = 0.5, T value2 = -0.5, void* dummy = 0) : value1_(value1), value2_(value2){}\n    T value1_, value2_;\n};\n\nint main()\n{\n    Foo&lt;float&gt; test;\n    std::cout &lt;&lt; test.value1_ &lt;&lt; \" \" &lt;&lt; test.value2_ &lt;&lt; '\\n';\n\n    Foo&lt;int&gt; test2;\n    std::cout &lt;&lt; test2.value1_ &lt;&lt; \" \" &lt;&lt; test2.value2_;\n}\n</code></pre>\n<p>It <a href=\"http://rextester.com/OTWD34644\" rel=\"nofollow\">works just fine</a> in visual studio 2013 .</p>\n<p>But <a href=\"http://coliru.stacked-crooked.com/a/dbed0304223b38e1\" rel=\"nofollow\">gcc 4.9.2 rejects it</a> :</p>\n<pre><code>main.cpp: In instantiation of 'class Foo&lt;float&gt;':\nmain.cpp:29:13:   required from here\nmain.cpp:19:3: error: no type named 'type' in 'struct std::enable_if&lt;false, void&gt;'\n   Foo(T value1 = 50, T value2 = -50) :value1_(value1), value2_(value2){}\n   ^\nmain.cpp: In instantiation of 'class Foo&lt;int&gt;':\nmain.cpp:32:11:   required from here\nmain.cpp:23:3: error: no type named 'type' in 'struct std::enable_if&lt;false, void&gt;'\n   Foo(T value1 = 0.5, T value2 = -0.5, void* dummy = 0) : value1_(value1), value2_(value2){}\n   ^\n</code></pre>\n<p>Is my code wrong? if so why visual studio compile it ? or maybe it's a gcc bug ?!</p>\n", "Tags": "<c++><class><templates><c++11><sfinae>", "OwnerUserId": "2586447", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_27943503_27943618_0": {"section_id": 300, "quality": 0.9, "length": 45}}, "n3337": {"so_27943503_27943618_0": {"section_id": 291, "quality": 0.9, "length": 45}}, "n4659": {"so_27943503_27943618_0": {"section_id": 307, "quality": 0.82, "length": 41}}}});