post_cb({"bq_ids": {"n4140": {"so_5840810_5840907_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 3328}}, "n3337": {"so_5840810_5840907_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 3198}}, "n4659": {"so_5840810_5840907_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 4094}}}, "5840810": {"ViewCount": "1213", "Body": "<p>I would like to use C++0x new initializer list feature to initialize a std::vector with a compile time defined number of items for a new API I'm currently working on. Something like this:</p>\n<pre><code>template&lt;int n&gt;\nstd::initializer_list&lt;std::string&gt; duplicate(std::string s) {\n  // return s duplicated n times\n  return { s, s, s };\n}\n\nstd::vector&lt;std::string&gt; v = { \"foo\",  duplicate&lt;3&gt;(\"bar\") };\n</code></pre>\n<p>Do you have any idea how to accomplish this? Is it even possible? I'm aware of that I will need to use TMP and recursion to build up the list of duplicated strings and finally access it somehow through a constant (e.g., enum). But it seems that I cannot even nest the initializer list like this.</p>\n", "Title": "C++0x nested initializer lists", "CreationDate": "2011-04-30T09:21:30.357", "LastActivityDate": "2011-05-03T14:51:04.833", "CommentCount": "0", "LastEditDate": "2011-04-30T09:54:17.863", "PostTypeId": "1", "LastEditorUserId": "624206", "Id": "5840810", "Score": "6", "OwnerUserId": "732239", "Tags": "<c++><c++11><initializer-list><template-meta-programming>", "AnswerCount": "1"}, "5840907": {"Id": "5840907", "PostTypeId": "2", "Body": "<p>You cannot nest initializer lists in order to extend them, nor can you add/concatenate them.  They are only a bit of syntactic sugar to access a compile-time-sized array.  Even copying initializer_lists doesn't copy their items.  Most importantly, this means you cannot use the return value of duplicate!  The referenced array is destroyed when the function returns, per 8.5.4p6 in N3290:</p>\n<blockquote>\n<p id=\"so_5840810_5840907_0\">The lifetime of the array is the same as that of the initializer_list object.</p>\n</blockquote>\n<p>(A temporary is created in the return statement and then returned by value.  Even if copy elision happens, all other semantics of copying are unchanged.)</p>\n<p>Compare to, for example, the temporary initializer_list created here, which is then passed to the ctor and destroyed after the object is initialized, at the same point all other temporary objects in the same full expression (if there were any) would be destroyed:</p>\n<pre><code>vector&lt;string&gt; v {\"foo\"};\n</code></pre>\n<p>Instead of manipulating initializer lists, use vector's method to insert N copies:</p>\n<pre><code>v.insert(v.end(), 3, \"bar\");\n</code></pre>\n", "LastEditorUserId": "624206", "LastActivityDate": "2011-04-30T11:40:43.067", "Score": "8", "CreationDate": "2011-04-30T09:45:47.640", "ParentId": "5840810", "CommentCount": "0", "OwnerUserId": "624206", "LastEditDate": "2011-04-30T11:40:43.067"}});