post_cb({"bq_ids": {"n4140": {"so_45907561_45907561_0": {"length": 22, "quality": 1.0, "section_id": 5485}}, "n3337": {"so_45907561_45907561_0": {"length": 22, "quality": 1.0, "section_id": 5271}}, "n4659": {"so_45907561_45907561_0": {"length": 22, "quality": 1.0, "section_id": 6920}}}, "45907561": {"ViewCount": "36", "Body": "<p>The following code is successfully compiled by Visual C++ 2013 and 2015 however gcc and clang reports a error. I wonder if C++11 standard has something applicable to this case besides the quote below that allows some ambiguity in treatment of friend class declaration or it is just a VC bug.</p>\n<p>The line in question is friend class declaration.</p>\n<pre><code>class Friend {\npublic:\n    Friend();\n};\n\nvoid globalFun();\n\nnamespace { // Does not matter if it is not anonymous.\n    class InNamespace {\n        // \"friend Friend\" or \"friend class ::Friend\" works in gcc and clang.\n        friend class Friend; // &lt;- ???\n        friend void ::globalFun(); // Even VC does not allow unqualified name\n        class Private {};\n    };\n}\n\nFriend::Friend() {\n    InNamespace::Private a;\n    (void) a;\n}\n\nvoid globalFun() {\n    InNamespace::Private a;\n    (void) a;\n}\n\nint main() {\n    Friend f;\n    globalFun();\n    return 0;\n}\n</code></pre>\n<p>gcc and clang complains that <code>InNamespace::Private</code> is private in the scope of <code>Friend</code> constructor. It sounds reasonable since <code>Friend</code> is declared at the global namespace that is not innermost enclosing namespace for <code>InNamespace</code> and C++11 standard states</p>\n<blockquote>\n<h3>7.3.1.2 Namespace member definitions [namespace.memdef]</h3>\n<p id=\"so_45907561_45907561_0\">3 ... If the name in a friend declaration is neither qualified nor a template-id and the declaration is a <strong>function</strong> or an <strong>elaborated-type-specifier</strong>, the lookup to determine whether the entity has been previously declared shall not consider any scopes outside the <strong>innermost enclosing namespace</strong>.</p>\n</blockquote>\n<p>The same wording in C++14, and in the section 10.3.1.2 of C++17.</p>\n<p>I am confused by that in respect to function Visual Studio follows the quoted sentence but it has relaxed rules for the class. It looks like the latter is treated as elaborated type specifier instead of forward declaration of the class within the anonymous namespace. Is there another section of C++ standard that may be considered as permission of name lookup outside of innermost enclosing namespace?</p>\n", "Title": "Friend declaration in namespace: forward declaration or elaborated type specifier", "CreationDate": "2017-08-27T17:31:50.347", "LastActivityDate": "2017-08-27T17:31:50.347", "CommentCount": "0", "PostTypeId": "1", "Id": "45907561", "Score": "1", "OwnerUserId": "8507538", "Tags": "<c++><visual-c++><namespaces><friend><name-lookup>", "AnswerCount": "0"}});