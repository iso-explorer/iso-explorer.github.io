post_cb({"4267515": {"ParentId": "4267363", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_4267363_4267515_0\">Would that be a case where I actually must use (implicitly or explicitly) Base's (default) constructor on the initialisation list of Derived's copy constructor, and call the Base's copy constructor only in the body of Derived's copy constructor, when there is actually an object that can be attached by Base's copy constructor? </p>\n</blockquote>\n<p>Why on earth would you want to do that?<br>\n(Oh, and you can not call a base class' copy constructor from a derived class' constructor's <em>body</em>. Only from its initialization list.) </br></p>\n<blockquote>\n<p id=\"so_4267363_4267515_1\">Else - is (* this) a valid object?</p>\n</blockquote>\n<p>The moment the base's initialization list has completed, all of base's members (and base classes) are fully constructed. The class itself, however, is only fully constructed when its constructor has finished.<br>\nMore importantly, the derived class' constructor hasn't even started yet, so the object is not a derived class' object yet. </br></p>\n<p>So whatever that registering function does, it has to take into account that the object's <em>dynamic</em> type is <code>base</code> and that its constructor hasn't finished yet. (To be safe, all it can do is to store the object's address somewhere.) </p>\n", "OwnerUserId": "140719", "PostTypeId": "2", "Id": "4267515", "Score": "4", "CreationDate": "2010-11-24T13:53:30.747", "LastActivityDate": "2010-11-24T13:53:30.747"}, "4357616": {"ParentId": "4267363", "CommentCount": "0", "Body": "<p>Just for reference, the behavior is specified by \u00a7 12.7 2-3 of C++03:</p>\n<blockquote>\n<p id=\"so_4267363_4357616_0\">2) To explicitly or implicitly convert a pointer (an lvalue) referring to an object of class X to a pointer (reference) to a direct or indirect base class B of X, the construction of X and the construction of all of its direct or indirect bases that directly or indirectly derive from B shall have started and the destruction of these classes shall not have completed, otherwise the conversion results in undefined behavior.</p>\n</blockquote>\n<p><code>this</code> is a pointer to <code>Derived</code>. In <code>Base::Base()</code>, <code>this</code> is implicitly cast to a <code>Base*</code>, which is allowed because the construction of Derived has started and it has no other bases that derive from <code>Base</code>.</p>\n<p>\u00a7 12.7 2 continues:</p>\n<blockquote>\n<p id=\"so_4267363_4357616_1\">To form a pointer to (or access the value of) a direct nonstatic member of an object obj, the construction of obj shall have started and its destruction shall not have completed, otherwise the computation of the pointer value (or accessing the member value) results in undefined behavior.</p>\n</blockquote>\n<p>Finally, \u00a7 12.7 3 is also important:</p>\n<blockquote>\n<p id=\"so_4267363_4357616_2\">3) Member functions, including virtual functions (10.3), can be called during construction or destruction (12.6.2). When a virtual function is called directly or indirectly from a constructor (including from the <em>mem-initializer</em> for a data member) or from a destructor, and the object to which the call applies is the object under construction or destruction, the function called is the one defined in the constructor or destructor\u2019s own class or in one of its bases, but not a function overriding it in a class derived from the con- structor or destructor\u2019s class, or overriding it in one of the other base classes of the most derived object (1.8). If the virtual function call uses an explicit class member access (5.2.5) and the object-expression refers to the object under construction or destruction but its type is neither the constructor or destructor\u2019s own class or one of its bases, the result of the call is undefined.</p>\n</blockquote>\n<p>These two clauses means an instance of <code>Derived</code> is a fully-fledged <code>Base</code> once a <code>Base</code> constructor begins, though it might be in an inconsistent state. </p>\n", "OwnerUserId": "90527", "PostTypeId": "2", "Id": "4357616", "Score": "1", "CreationDate": "2010-12-05T06:04:34.977", "LastActivityDate": "2010-12-05T06:04:34.977"}, "bq_ids": {"n4140": {"so_4267363_4357616_2": {"section_id": 447, "quality": 0.5113636363636364, "length": 45}, "so_4267363_4357616_1": {"section_id": 446, "quality": 1.0, "length": 27}, "so_4267363_4357616_0": {"section_id": 446, "quality": 0.9714285714285714, "length": 34}}, "n3337": {"so_4267363_4357616_2": {"section_id": 438, "quality": 0.5113636363636364, "length": 45}, "so_4267363_4357616_1": {"section_id": 437, "quality": 1.0, "length": 27}, "so_4267363_4357616_0": {"section_id": 437, "quality": 0.9714285714285714, "length": 34}}, "n4659": {"so_4267363_4357616_2": {"section_id": 469, "quality": 0.5113636363636364, "length": 45}, "so_4267363_4357616_1": {"section_id": 468, "quality": 1.0, "length": 27}, "so_4267363_4357616_0": {"section_id": 468, "quality": 0.9714285714285714, "length": 34}}}, "4267363": {"CommentCount": "2", "AcceptedAnswerId": "4267515", "CreationDate": "2010-11-24T13:37:24.637", "LastActivityDate": "2010-12-05T06:04:34.977", "PostTypeId": "1", "ViewCount": "828", "FavoriteCount": "1", "Title": "Base class on the initialisation list of a derived class' copy constructor (C++)", "Id": "4267363", "Score": "1", "Body": "<p>Let the example be:</p>\n<pre><code>class Base {\n  Base (const Base &amp; copyFrom) { globalRegister (* this); }\n}\n\nclass Derived {\n  Derived (const Derived &amp; copyFrom) : Base (copyFrom) {}\n}\n</code></pre>\n<p>I've read suggestions to include the Base's copy constructor on the initialisation list of Derived in order to copy over the Base's properties (as in the example).</p>\n<p>However, I have the Base's copy constructor passing itself (* this) to other object (to be registered with that object). Would that be a case where I actually must use (implicitly or explicitly) Base's (default) constructor on the initialisation list of Derived's copy constructor, and call the Base's copy constructor only in the body of Derived's copy constructor, when there is actually an object that can be attached by Base's copy constructor? Else - is (* this) a valid object?</p>\n", "Tags": "<c++><oop><copy-constructor><derived><inherited>", "OwnerUserId": "99904", "AnswerCount": "2"}});