post_cb({"bq_ids": {"n4140": {"so_24167949_24168770_0": {"length": 38, "quality": 0.7755102040816326, "section_id": 5485}}, "n3337": {"so_24167949_24168770_0": {"length": 41, "quality": 0.8367346938775511, "section_id": 5271}}, "n4659": {"so_24167949_24168770_0": {"length": 38, "quality": 0.7755102040816326, "section_id": 6920}}}, "24168770": {"Id": "24168770", "PostTypeId": "2", "Body": "<p>It's because of the <code>friend</code>liness:</p>\n<blockquote>\n<p id=\"so_24167949_24168770_0\"><code>[C++11: 7.3.1.2/3]:</code> If a friend declaration in a non-local class first declares a class or function the friend class or function is a member of the innermost enclosing namespace. <strong>The name of the friend is not found by simple name lookup until a matching declaration is provided in that namespace scope</strong> <em>[...]</em>. If a friend function is called, its name may be found by the name lookup that considers function from namespaces and classes associated with the types of the function arguments (3.4.2) <em>[i.e. ADL]</em>.</p>\n</blockquote>\n<p>The fix is to simply provide that declaration:</p>\n<pre><code>namespace N {\n\n    struct C {\n        friend int f(const C&amp; c) {\n            return 1;\n        }\n        friend int g(const C&amp; c) {\n            return 2;\n        }\n    };\n\n    int f(const C&amp; c);\n    int g(const C&amp; c);\n\n    struct D {\n        void f() {\n            g(C{});\n            ::N::f(C{});\n        }\n    };\n}\n</code></pre>\n<h3>(<a href=\"http://coliru.stacked-crooked.com/a/0169457d6e70bd20\" rel=\"nofollow\">live demo</a>)</h3>\n", "LastEditorUserId": "560648", "LastActivityDate": "2014-06-11T17:19:09.140", "Score": "1", "CreationDate": "2014-06-11T17:14:02.117", "ParentId": "24167949", "CommentCount": "1", "OwnerUserId": "560648", "LastEditDate": "2014-06-11T17:19:09.140"}, "24167949": {"ViewCount": "167", "Body": "<p>As described here <a href=\"https://stackoverflow.com/questions/11694970/c11-style-sfinae-and-function-visibility-on-template-instantiation/11695164#11695164\">C++11 style SFINAE and function visibility on template instantiation</a> class member functions overshadow free functions. Using a fully qualified name usually works, however I am having a hard time with friend functions of other classes which are declared in-line. Consider the following example:</p>\n<pre><code>namespace N {\n\n    struct C {\n        friend int f(const C&amp; c) {\n            return 1;\n        }\n        friend int g(const C&amp; c) {\n            return 2;\n        }\n    };\n\n    struct D {\n        void f() {\n            g(C{});            // ADL finds this\n            ::N::f(C{});       // not found dispite full qualification\n        }\n    };\n}\n</code></pre>\n<p>I think I understand what the problem is, as described here <a href=\"https://stackoverflow.com/questions/8207633/whats-the-scope-of-inline-friend-functions\">What's the scope of inline friend functions?</a> inline friend function are usually found using ADL and not really visible in the enclosing namespace. </p>\n<p>So my question is how should I change my code to make this work (aside from renaming one of the f's)? </p>\n", "AcceptedAnswerId": "24168770", "Title": "how do I call an inline friend function with the same name as a member function?", "CreationDate": "2014-06-11T16:24:44.700", "Id": "24167949", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:44:06.740", "LastEditorUserId": "-1", "LastActivityDate": "2014-06-11T17:19:09.140", "Score": "0", "OwnerUserId": "893819", "Tags": "<c++><friend><overload-resolution><argument-dependent-lookup>", "AnswerCount": "1"}});