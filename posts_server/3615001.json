post_cb({"37061174": {"ParentId": "3615001", "CommentCount": "0", "Body": "<p>Ben Voigt's workaround only works if you don't need to inherit class members. If for some reason you need multiple base classes to share the same inherited data, and also want to inherit member functions, here's a way to do it without any additional space/time cost:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nnamespace detail {\n\n    // If you use Boost, you can use use boost::copy_cv instead\n    template&lt;class T, class U&gt;\n    struct copy_cv {\n\n        using const_copied = std::conditional_t&lt;\n            std::is_const&lt;U&gt;{}, std::add_const_t&lt;T&gt;, T&gt;;\n\n        using type = std::conditional_t&lt;\n            std::is_volatile&lt;U&gt;{},\n            std::add_volatile_t&lt;const_copied&gt;,\n            const_copied&gt;;\n    };\n\n    // a derived class uses this template to share data between bases\n    template&lt;typename Data, typename Derived&gt;\n    struct storage {\n\n        template&lt;typename BasePtr&gt;\n        static inline constexpr decltype(auto)\n        get(BasePtr&amp;&amp; ptr) {\n\n            // enforcing cv-qualifiers from the BasePtr\n            using qualified_base = \n                std::remove_reference_t&lt;std::remove_pointer_t&lt;BasePtr&gt;&gt;;\n\n            using qualified_derived =\n                typename copy_cv&lt;Derived, qualified_base&gt;::type;\n\n            using qualified_data =\n                typename copy_cv&lt;Data, qualified_base&gt;::type;\n\n            // casting the base \"this\" pointer to the base class with data\n            return static_cast&lt;qualified_data*&gt;(static_cast&lt;qualified_derived*&gt;(ptr));\n        }\n    };\n}\n\n// the base class templates here ending with \"_impl\" have no data, and are\n// EBO-ed away. They ultimately uses data from a different base class\ntemplate&lt;typename Data&gt;\nstruct print_impl {\n\n    void print() const {\n        std::cout &lt;&lt; Data::get(this)-&gt;number &lt;&lt; '\\n';\n    }\n};\n\n // add_impl_1 and add_impl_2 supply \"overloaded\" member functions for the derived class\ntemplate&lt;typename Data&gt;\nstruct add_impl_1 {\n\n    int add(int i) const {\n        return Data::get(this)-&gt;number + i;\n    }\n};\n\ntemplate&lt;typename Data&gt;\nstruct add_impl_2 {\n\n    template&lt;int i&gt;\n    int add() const {\n        return Data::get(this)-&gt;number + i;\n    }\n};\n\n// this is the base class containing data\nstruct bar_data {\n\n    int number = 42;\n};\n\nstruct bar :\n\n    // derived class inherits the data class\n    bar_data,\n\n    // using the storage template, we give the \"implementation\"\n    // base classes access to the data\n    print_impl&lt;detail::storage&lt;bar_data, bar&gt;&gt;,\n    add_impl_1&lt;detail::storage&lt;bar_data, bar&gt;&gt;,\n    add_impl_2&lt;detail::storage&lt;bar_data, bar&gt;&gt; {\n\n    // using declarations are necessary to disambiguate the \"overloads\"\n    using add_impl_1&lt;detail::storage&lt;bar_data, bar&gt;&gt;::add;\n    using add_impl_2&lt;detail::storage&lt;bar_data, bar&gt;&gt;::add;\n};\n\nstatic_assert(sizeof(bar_data) == sizeof(bar), \"\");\n\nint main() {\n\n    bar b{};\n\n    b.print();\n    std::cout &lt;&lt; b.add(1) &lt;&lt; std::endl;\n    std::cout &lt;&lt; b.add&lt;2&gt;() &lt;&lt; std::endl;\n}\n</code></pre>\n<p>As far as I can tell, this would only be useful for a few very specific metaprogramming scenarios, or perhaps some aspect-oriented programming.</p>\n", "OwnerUserId": "2397809", "PostTypeId": "2", "Id": "37061174", "Score": "0", "CreationDate": "2016-05-05T22:14:32.613", "LastActivityDate": "2016-05-05T22:14:32.613"}, "3615039": {"ParentId": "3615001", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>(This answer was written for C++03, the situation may have changed since C++11)</p>\n<p>I can't imagine any compelling reason for excluding it... more that there's no particularly good reason for including it.  Unions just aren't used enough to matter that much, and there are heavy restrictions on the type of members in the union, restrictions that prevent OO practices.  Those restrictions - and the burden of manually tracking the particular variable(s) in a union that have validity - mean pretty much the first thing you want to do with a union is encapsulate it in a class, then you can inherit from that anyway.  Letting the union be part of the inheritance chain just spreads the pain around.</p>\n<p>So, anything that might give casual C++ users the impression that unions could be mixed into their OO-centric code would cause more trouble than good.  Unions are basically a hack for memory conservation, fast-but-nasty data reinterpretation and implementing variants, and tend to be an implementation detail rather than an interface one.</p>\n<p>You've added a bit to your question with your edit... thoughts follow.</p>\n<blockquote>\n<p id=\"so_3615001_3615039_0\">If union is allowed as a base class, its data can be used by a derived class. If derived class is interested to use only one member of union, this way can be used for saving memory. I think, this is improper inheritance. Is it better to have union inside derived class in that case ?</p>\n</blockquote>\n<p>So, we're discussing:</p>\n<pre><code>union U { int i; double d; };\nstruct D : U { };\n</code></pre>\n<p>U's data members would either have to be - implicitly or explicitly - public, protected or private.  If they're public or protected, then they're not encapsulated, and we're back in the \"share the pain\" scenario mentioned above.  U has less ability to encapsulate them than a class containing a union.  If they're private, then they could just as easily be a union data member in a class.</p>\n<blockquote>\n<p id=\"so_3615001_3615039_1\">If union is allowed as derived class, it can use services of base class. For example, if Union has multiple types of data. As we know, only one type of data can be used. For each type of data, a base class is present to offer services for that particular type. In this case, multiple inheritance can be used to get services of all base classes for all types of data in Union. This also i feel as improper usage of inheritance. But is there any equivalent concept to achieve content in this point?</p>\n</blockquote>\n<p>Ok, this is where things get weird.  So, we've got:</p>\n<pre><code>union U : public A, private B { };\n</code></pre>\n<p>Firstly, let me be a bit more explicit about something.  Unions can't contain complex, encapsulated objects - they're the antithesis of encapsulation.  You're pretty much limited to POD data, and can't have non-default constructors etc..  Note I'm talking about the data members of the union, and not the union itself.  So, A and B would - if those union-content rules remain - be very limited, and the ability of U to derive not particularly useful.</p>\n<p>That leads into the question of why unions can't manage more complex objects in some safe way.  Well, how could they do it?  Obvious answer is add a hidden enum to say which one is valid, and some rules about which type should be constructed by default, invoking the destructor first when a different enum field is assigned to, etc etc etc....  Maybe they should throw if someone does something to the member that's not currently constructed?  Sounds ok?</p>\n<p>Well, firstly, the overhead of an enum might not be necessary, as client code might use one member then another in a known-appopriate order.  Checks and exceptions in the language itself are a similar overhead... they may be able to be factored down to a single check before multiple uses if left to the client code.  In both cases, you'd be paying for some management overhead that only some applications need - a very un-C++ approach.</p>\n<p>Ignoring that, unions aren't that simple anyway.  Like enums, their use is designed to be flexible and would be hard to communicate to the compiler so it could clean up, check and automate it.  You might think \"huh?  enums are complex?\", but each enum is - conceptually generalised - effectively an arbitrary set of independent bitfields of varying width.  It's non-trivial to describe which ones are meant to be mutually exclusive or dependent etc..  The compiler doesn't buy into the problem space at all.  Similarly, a union may have one or more concurrently legitimate views on the same data, while others are invalid, with subtleties to boot.  For example: a union of int64_t, double, and char[4] could always be read as an int64_t or char[4] after being set as a double, but the other way around might read an invalid double and cause undefined behaviour, unless you're re-reading values that came from a double at some earlier time, perhaps in a serialisation/deserialisation library.  The compiler doesn't want to buy into the management of that, which is what it would have to do to ensure object members of unions obeyed the promises implicit in their own encapsulation.</p>\n<p>You ask \"is it better to have union inside derived class?\"... no - doesn't generally work as most objects can't be put into a union (see above).  You hit this problem whether the union is inside the derived class, or - through the new language features you postulate - the union actually is the derived class.</p>\n<p>I do understand your frustration though.  In practice, people do sometimes want unions of arbitrary non-trivial objects, so they hack it up the hard and dirty way using reinterpret cast or similar, managing memory alignment of some space big enough for the set of objects they'll support (or - easier but slower - a pointer to them).  You'll find this sort of thing in the boost variant and any libraries.  But, you can't derive from them... the knowledge about appropriate usage, the extent of safety checks etc. just isn't deducible or expressible in C++.  The compiler's not about to do that for you.</p>\n", "OwnerUserId": "410767", "LastEditorUserId": "410767", "LastEditDate": "2014-07-05T11:12:45.060", "Id": "3615039", "Score": "11", "CreationDate": "2010-09-01T04:26:28.987", "LastActivityDate": "2014-07-05T11:12:45.060"}, "3615114": {"ParentId": "3615001", "CommentCount": "1", "Body": "<p>Here is a simple workaround:</p>\n<pre><code>struct InheritedUnion\n{\n    union {\n        type1 member1;\n        type2 member2;\n    };\n};\n\nstruct InheritsUnion : InheritedUnion\n{};\n</code></pre>\n<p>By making the union anonymous, it works just as if the base type were actually a union.</p>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "3615114", "Score": "14", "CreationDate": "2010-09-01T04:50:41.453", "LastActivityDate": "2010-09-01T04:50:41.453"}, "bq_ids": {"n4140": {"so_3615001_3615001_0": {"section_id": 5914, "quality": 1.0, "length": 7}, "so_3615001_3615001_1": {"section_id": 5914, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_3615001_3615001_0": {"section_id": 5686, "quality": 1.0, "length": 7}, "so_3615001_3615001_1": {"section_id": 5686, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_3615001_3615001_0": {"section_id": 7406, "quality": 1.0, "length": 7}, "so_3615001_3615001_1": {"section_id": 7406, "quality": 0.9166666666666666, "length": 11}}}, "3615001": {"CommentCount": "3", "CreationDate": "2010-09-01T04:13:48.213", "PostTypeId": "1", "AcceptedAnswerId": "3615039", "LastEditorUserId": "1288", "LastActivityDate": "2016-05-05T22:14:32.613", "LastEditDate": "2012-09-16T22:32:55.363", "ViewCount": "4782", "FavoriteCount": "1", "Title": "Why union can't be used in Inheritance?", "Id": "3615001", "Score": "17", "Body": "<p>I saw below thing in c++ standard (\u00a79.5/1):</p>\n<blockquote>\n<p id=\"so_3615001_3615001_0\">A union shall not have base classes. A union shall not\n  be used as a base class.</p>\n<p id=\"so_3615001_3615001_1\">A union can have member functions\n  (including constructors and\n  destructors), but not virtual (10.3)\n  functions</p>\n</blockquote>\n<p>From above, union can have constructor and destructor as well.</p>\n<p>So why is it not allowed in Inheritance ?</p>\n<p>EDIT: For answering comments:</p>\n<ol>\n<li><p>If union is allowed as a base class, its data can be used by a derived class. If derived class is interested to use only one member of union, this way can be used for saving memory. I think, this is improper inheritance. Is it better to have union inside derived class in that case ?</p></li>\n<li><p>If union is allowed as derived class, it can use services of base class. For example, if Union has multiple types of data. As we know, only one type of data can be used. For each type of data, a base class is present to offer services for that particular type. In this case, multiple inheritance can be used to get services of all base classes for all types of data in Union. This also i feel as improper usage of inheritance. But is there any equivalent concept to achieve content in this point?</p></li>\n</ol>\n<p>Just my thoughts...</p>\n", "Tags": "<c++>", "OwnerUserId": "426051", "AnswerCount": "3"}});