post_cb({"bq_ids": {"n4140": {"so_17720424_17720605_1": {"length": 29, "quality": 1.0, "section_id": 268}}, "n3337": {"so_17720424_17720605_1": {"length": 29, "quality": 1.0, "section_id": 259}}, "n4659": {"so_17720424_17720605_1": {"length": 29, "quality": 1.0, "section_id": 275}}}, "17720424": {"ViewCount": "388", "Body": "<p>The following build setup works fine on Linux using GCC (4.6.3), but not with MinGW using GCC (4.7.2).</p>\n<hr>\n<pre><code>$ cat Makefile \nall:\n        g++ -c foo.cpp\n        g++ -c bar.cpp\n        g++ bar.o foo.o -o bar\n</code></pre>\n<hr>\n<pre><code>$ cat foo.h \n#ifndef FOO_H\n#define FOO_H\n\n#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nvoid foo(T x) {\n    std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n}\n#endif\n</code></pre>\n<hr>\n<pre><code>$ cat foo.cpp\n#include \"foo.h\"\ntemplate &lt;&gt;\nvoid foo(int x) {\n    std::cout &lt;&lt; \"Hello Int!\" &lt;&lt; std::endl;\n}\n</code></pre>\n<hr>\n<pre><code>$ cat bar.cpp \n#include \"foo.h\"\n\nint main() {\n    foo &lt;int&gt; (1);\n}\n</code></pre>\n<hr>\n<p>On Linux, we have that:</p>\n<pre><code>$ make\ng++ -c foo.cpp\ng++ -c bar.cpp\ng++ bar.o foo.o -o bar\n\n$ ./bar\nHello Int!\n</code></pre>\n<p>which is what I expect.  On Windows, we have</p>\n<pre><code>$ make\ng++ -c foo.cpp\ng++ -c bar.cpp\ng++ bar.o foo.o -o bar\nfoo.o:foo.cpp:(.text+0x0): multiple definition of `void foo&lt;int&gt;(int)'\nbar.o:bar.cpp:(.text$_Z3fooIiEvT_[__Z3fooIiEvT_]+0x0): first defined here\ncollect2.exe: error: ld returned 1 exit status\nmake: *** [all] Error 1\n</code></pre>\n<p>I suspect this has something to do with weak symbols.  Meaning, on Linux we have that in foo.o</p>\n<pre><code>00000000 T _Z3fooIiEvT_\n</code></pre>\n<p>and in bar.o</p>\n<pre><code>00000000 W _Z3fooIiEvT_\n</code></pre>\n<p>Whereas on Windows we have that in foo.o</p>\n<pre><code>00000000 T __Z3fooIiEvT_\n</code></pre>\n<p>and in bar.o</p>\n<pre><code>00000000 T __Z3fooIiEvT_\n</code></pre>\n<p>Hence, there's no weak symbol to override.</p>\n<p>What's the best way to resolve this issue?  In the actual case, I have a header foo.h with a number of template definitions.  Some of them, I specialize and I put these definitions in foo.cpp, which is later compiled into a library.  Then, I give the header and the library to the users.  If possible, I always want to use the specialization in the foo library.  If the specialization does not exist, I want to use the template definition in the foo header.</p>\n<p><strong>EDIT</strong></p>\n<p>The following modification of foo.h seems to fix the problem</p>\n<pre><code>$ cat foo.h \n#ifndef FOO_H\n#define FOO_H\n\n#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt;\nvoid foo(T x) {\n    std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n}\ntemplate &lt;&gt;\nvoid foo(int x);\n#endif\n</code></pre>\n<p>Basically, the prototype for the int version of foo needs to be in the header.  This coincides with BoBTFish's note that the standard requires that, \"specialization shall be declared before the first use.\"  In any case, is this the best way setup a specialization library?</p>\n</hr></hr></hr></hr></hr>", "AcceptedAnswerId": "17720605", "Title": "Template specialization causes linking error with MinGW on Windows an not GCC on Linux", "CreationDate": "2013-07-18T10:05:07.127", "Id": "17720424", "CommentCount": "1", "LastEditDate": "2013-07-18T10:34:45.833", "PostTypeId": "1", "LastEditorUserId": "1932452", "LastActivityDate": "2013-07-18T10:34:45.833", "Score": "3", "OwnerUserId": "1932452", "Tags": "<c++><linux><windows><gcc><mingw>", "AnswerCount": "2"}, "17720605": {"Id": "17720605", "PostTypeId": "2", "Body": "<p>Don't know the intricacies of the compilers, but you violate The Standard anyway:</p>\n<blockquote>\n<p id=\"so_17720424_17720605_0\">14.7.3 Explicit specialization:</p>\n<p id=\"so_17720424_17720605_1\">6 If a template, a member template or a member of a class template is\n  explicitly specialized then that specialization <strong>shall be declared\n  before the first use of that specialization that would cause an\n  implicit instantiation to take place, in every translation unit in\n  which such a use occurs</strong>; no diagnostic is required.</p>\n</blockquote>\n<p>So your program is ill-formed.</p>\n", "LastActivityDate": "2013-07-18T10:13:11.063", "Score": "2", "CreationDate": "2013-07-18T10:13:11.063", "ParentId": "17720424", "CommentCount": "0", "OwnerUserId": "1171191"}, "17720548": {"Id": "17720548", "PostTypeId": "2", "Body": "<p>You might install (on both Windows and Linux) a very recent GCC (that is 4.8.1 today) and use the <a href=\"https://en.wikipedia.org/wiki/C++11#Extern_template\" rel=\"nofollow\">extern template</a> feature of C++11.</p>\n", "LastActivityDate": "2013-07-18T10:10:55.797", "Score": "1", "CreationDate": "2013-07-18T10:10:55.797", "ParentId": "17720424", "CommentCount": "0", "OwnerUserId": "841108"}});