post_cb({"13460913": {"CommentCount": "2", "Body": "<p>You cannot guarantee that <code>std::abs(x)</code> will always return <code>|x|</code> for all arithmetic types.  For example, most signed integer implementations have room for one more negative number than positive number, so the results of <code>abs(numeric_limits&lt;int&gt;::min())</code> will not equal <code>|x|</code>.</p>\n", "CreationDate": "2012-11-19T19:40:47.287", "ParentId": "13460750", "Id": "13460913", "LastActivityDate": "2012-11-19T19:40:47.287", "PostTypeId": "2", "Score": "4", "OwnerUserId": "1376056"}, "29167278": {"CommentCount": "0", "Body": "<p>It's not weird that g++ (with C++11 standard) returns a double when you use <code>std::abs</code> from <code>&lt;cmath&gt;</code> with an integral type:\nFrom <a href=\"http://www.cplusplus.com/reference/cmath/abs/\" rel=\"nofollow\">http://www.cplusplus.com/reference/cmath/abs/</a>:</p>\n<blockquote>\n<p id=\"so_13460750_29167278_0\">Since C++11, additional overloads are provided in this header (<code>&lt;cmath&gt;</code>) for the integral types: These overloads effectively cast x to a double before calculations (defined for T being any integral type).</p>\n</blockquote>\n<p>This is actually implemented like that in <code>/usr/include/c++/cmath</code>:\n</p>\n<pre><code>template&lt;typename _Tp&gt;\ninline _GLIBCXX_CONSTEXPR\ntypename __gnu_cxx::__enable_if&lt;__is_integer&lt;_Tp&gt;::__value,\n                                double&gt;::__type\nabs(_Tp __x)\n{ return __builtin_fabs(__x); }\n</code></pre>\n", "CreationDate": "2015-03-20T13:09:39.460", "ParentId": "13460750", "Id": "29167278", "LastActivityDate": "2015-03-20T13:09:39.460", "PostTypeId": "2", "Score": "0", "OwnerUserId": "1448926"}, "13460750": {"CreationDate": "2012-11-19T19:29:59.467", "ViewCount": "17218", "FavoriteCount": "5", "Id": "13460750", "AcceptedAnswerId": "13460915", "Score": "19", "Title": "On the std::abs function", "LastEditorUserId": "636019", "CommentCount": "7", "Body": "<p>Is the <code>std::abs()</code> function well defined for ALL arithmetic types in C++11 and will return <code>|x|</code> with no problem of approximation?</p>\n<p>A weird thing is that with g++4.7, <code>std::abs(char)</code>, <code>std::abs(short int)</code>, <code>std::abs(int)</code>, <code>std::abs(long int)</code> and <code>std::abs(long long int)</code> seem to return a double (on the contrary of : <a href=\"http://en.cppreference.com/w/cpp/numeric/math/abs\">http://en.cppreference.com/w/cpp/numeric/math/abs</a>). And if the number is casted to a double, we could have some approximation error for very large number (like <code>-9223372036854775806LL = 2^63-3</code>).</p>\n<p>So do I have the guarantee that <code>std::abs(x)</code> will always return <code>|x|</code> for all arithmetic types ?</p>\n<p>EDIT : here is an example program to make some tests </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n#include &lt;cmath&gt;\n#include &lt;typeinfo&gt;\n\ntemplate&lt;typename T&gt;\nvoid abstest(T x)\n{\n    static const unsigned int width = 16;\n    const T val = x;\n    if (sizeof(val) == 1) {\n        std::cout&lt;&lt;std::setw(width)&lt;&lt;static_cast&lt;int&gt;(val)&lt;&lt;\" \";\n        std::cout&lt;&lt;std::setw(width)&lt;&lt;static_cast&lt;int&gt;(std::abs(val))&lt;&lt;\" \";\n    } else {\n        std::cout&lt;&lt;std::setw(width)&lt;&lt;val&lt;&lt;\" \";\n        std::cout&lt;&lt;std::setw(width)&lt;&lt;static_cast&lt;T&gt;(std::abs(val))&lt;&lt;\" \";\n    }\n    std::cout&lt;&lt;std::setw(width)&lt;&lt;sizeof(val)&lt;&lt;\" \";\n    std::cout&lt;&lt;std::setw(width)&lt;&lt;sizeof(std::abs(val))&lt;&lt;\" \";\n    std::cout&lt;&lt;std::setw(width)&lt;&lt;typeid(val).name()&lt;&lt;\" \";\n    std::cout&lt;&lt;std::setw(width)&lt;&lt;typeid(std::abs(val)).name()&lt;&lt;std::endl;\n}\n\nint main()\n{\n    double ref = -100000000000;\n    abstest&lt;char&gt;(ref);\n    abstest&lt;short int&gt;(ref);\n    abstest&lt;int&gt;(ref);\n    abstest&lt;long int&gt;(ref);\n    abstest&lt;long long int&gt;(ref);\n    abstest&lt;signed char&gt;(ref);\n    abstest&lt;signed short int&gt;(ref);\n    abstest&lt;signed int&gt;(ref);\n    abstest&lt;signed long int&gt;(ref);\n    abstest&lt;signed long long int&gt;(ref);\n    abstest&lt;unsigned char&gt;(ref);\n    abstest&lt;unsigned short int&gt;(ref);\n    abstest&lt;unsigned int&gt;(ref);\n    abstest&lt;unsigned long int&gt;(ref);\n    abstest&lt;unsigned long long int&gt;(ref);\n    abstest&lt;float&gt;(ref);\n    abstest&lt;double&gt;(ref);\n    abstest&lt;long double&gt;(ref);\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><c++11><standards-compliance><absolute-value>", "LastEditDate": "2012-11-20T02:22:33.817", "LastActivityDate": "2015-03-20T13:09:39.460", "PostTypeId": "1", "AnswerCount": "4", "OwnerUserId": "882932"}, "bq_ids": {"n4140": {"so_13460750_13460915_3": {"length": 15, "quality": 0.75, "section_id": 3873}, "so_13460750_13460915_0": {"length": 16, "quality": 1.0, "section_id": 3871}}, "n3337": {"so_13460750_13460915_3": {"length": 15, "quality": 0.75, "section_id": 3733}, "so_13460750_13460915_0": {"length": 16, "quality": 1.0, "section_id": 3731}}}, "13460849": {"CommentCount": "1", "Body": "<p>Check that you're in fact using <code>std::abs</code> from <code>&lt;cstdlib&gt;</code> and not <code>std::abs</code> from <code>&lt;cmath&gt;</code>.</p>\n<p>PS. Oh, just saw the example program, well, there you go, you are using one of the floating point overloads of <code>std::abs</code>\n.</p>\n", "CreationDate": "2012-11-19T19:36:21.013", "ParentId": "13460750", "Id": "13460849", "LastActivityDate": "2012-11-19T19:36:21.013", "PostTypeId": "2", "Score": "1", "OwnerUserId": "390807"}, "13460915": {"CommentCount": "3", "Body": "<p>The correct overloads are guaranteed to be present in <code>&lt;cmath&gt;</code>/<code>&lt;cstdlib&gt;</code>:</p>\n<p>C++11, [c.math]:</p>\n<blockquote>\n<p id=\"so_13460750_13460915_0\">In addition to the <code>int</code> versions of certain math functions in <code>&lt;cstdlib&gt;</code>, C++ adds <code>long</code> and <code>long long</code> overloaded versions of these functions, with the same semantics.</p>\n<p id=\"so_13460750_13460915_1\">The added signatures are:</p>\n<pre><code>long abs(long);            // labs()\nlong long abs(long long);  // llabs()\n</code></pre>\n<p id=\"so_13460750_13460915_2\">[...]</p>\n<p id=\"so_13460750_13460915_3\">In addition to the <code>double</code> versions of the math functions in <code>&lt;cmath&gt;</code>, overloaded versions of these functions, with the same semantics.\n  C++ adds <code>float</code> and <code>long double</code> overloaded versions of these functions, with the same semantics.</p>\n<pre><code>float abs(float);\nlong double abs(long double);\n</code></pre>\n</blockquote>\n<p>So you should just make sure to include correctly <code>&lt;cstdlib&gt;</code> (<code>int</code>, <code>long</code>, <code>long long</code> overloads)/<code>&lt;cmath&gt;</code> (<code>double</code>, <code>float</code>, <code>long double</code> overloads).</p>\n", "CreationDate": "2012-11-19T19:41:04.830", "ParentId": "13460750", "Id": "13460915", "LastActivityDate": "2012-11-19T19:41:04.830", "PostTypeId": "2", "Score": "15", "OwnerUserId": "214671"}});