post_cb({"bq_ids": {"n4140": {"so_19796413_19796549_0": {"length": 35, "quality": 0.8536585365853658, "section_id": 39}}, "n3337": {"so_19796413_19796549_0": {"length": 41, "quality": 1.0, "section_id": 36}}, "n4659": {"so_19796413_19796549_0": {"length": 35, "quality": 0.8536585365853658, "section_id": 39}}}, "19796549": {"Id": "19796549", "PostTypeId": "2", "Body": "<p>It is ambiguous because <code>0</code> is a null pointer constant. A null pointer constant can be implicitly converted to any pointer type -&gt; a <em>null pointer conversion</em>. Therefore, ctor 2 is viable: <code>TemplateClassTest(const string&amp;, const char*)</code>.</p>\n<p>As an integer literal, <code>0</code> is of type <code>int</code>. Constructor 1, <code>TemplateClassTest(const string&amp;, T, EnumTypeVal = READ, const string &amp; = \"default\")</code>, therefore requires a conversion from <code>int</code> to <code>unsigned long long</code> -&gt; an <em>integral conversion</em>.</p>\n<p>Those two conversions, <em>null pointer conversion</em> and <em>integral conversion</em>, have the same rank (Conversion), hence the ambiguity.</p>\n<hr>\n<p>[conv.ptr]/1</p>\n<blockquote>\n<p id=\"so_19796413_19796549_0\">A null pointer constant is an integral constant expression prvalue of integer type that evaluates to zero or a prvalue of type <code>std::nullptr_t</code>. A null pointer constant can be converted to a pointer type; the result is the <em>null pointer value</em> of that type and is distinguishable from every other value of object pointer or function pointer type. Such a conversion is called a <em>null pointer conversion</em>.</p>\n</blockquote>\n<hr>\n<p>A possible, but ugly fix that matches your constraints is to change the second constructor to:</p>\n<pre><code>template&lt;class U,\n         class V = typename std::enable_if&lt;std::is_same&lt;U, const char*&gt;{}&gt;::type&gt;\nTemplateClassTest(const string &amp; stringVal, U charVal);\n</code></pre>\n<p>That is, a greedy constructor template, restricted by SFINAE to only accept <code>const char*</code> as the second argument. This heavily restricts the implicit conversions applied to the second argument when trying to match this ctor.</p>\n<p>The out-of-line definition becomes:</p>\n<pre><code>template &lt;class T&gt;\ntemplate&lt;class U, class V&gt;\nTemplateClassTest&lt;T&gt;::TemplateClassTest(const string &amp; stringVal, U charVal)\n{\n    cout &lt;&lt; \"In TemplateClassTest(const string &amp;, const char *)\" &lt;&lt; endl;\n}\n</code></pre>\n</hr></hr>", "LastEditorUserId": "420683", "LastActivityDate": "2013-11-05T19:14:08.077", "Score": "1", "CreationDate": "2013-11-05T18:52:39.113", "ParentId": "19796413", "CommentCount": "2", "OwnerUserId": "420683", "LastEditDate": "2013-11-05T19:14:08.077"}, "19796413": {"ViewCount": "1068", "Body": "<p>I have a simple issue with ctor overload resolution for a class template:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\nenum EnumTypeVal { READ, WRITE };\n\ntemplate &lt;class T&gt;\nclass TemplateClassTest {\npublic:\n    TemplateClassTest(const string &amp; stringVal, T typeVal, EnumTypeVal e = READ,\n                      const string &amp; defaultStringVal = \"default\");\n    TemplateClassTest(const string &amp; stringVal, const char * charVal);\n    TemplateClassTest(const string &amp; stringVal, EnumTypeVal e = READ,\n                      const string &amp; defaultStringVal = \"default\");\nprivate:\nT type;\n};\n\ntemplate &lt;class T&gt;\nTemplateClassTest&lt;T&gt;::TemplateClassTest(const string &amp; stringVal, T typeVal,\n                                        EnumTypeVal e,\n                                        const string &amp; defaultStringVal)\n{\n    type = typeVal;\n    cout &lt;&lt; \"In TemplateClassTest(const string &amp;, T, EnumTypeVal, \"\n            \"const string &amp;)\" &lt;&lt; endl;\n}\n\ntemplate &lt;class T&gt;\nTemplateClassTest&lt;T&gt;::TemplateClassTest(const string &amp; stringVal,\n                                        const char * charVal)\n{\n    cout &lt;&lt; \"In TemplateClassTest(const string &amp;, const char *)\" &lt;&lt; endl;\n}\n\ntemplate &lt;class T&gt;\nTemplateClassTest&lt;T&gt;::TemplateClassTest(const string &amp; stringVal, EnumTypeVal e,\n                                        const string &amp; defaultStringVal)\n{\n    cout &lt;&lt; \"In TemplateClassTest(const string &amp;, EnumTypeVal, const string &amp;)\"\n         &lt;&lt; endl;\n}\n\ntypedef TemplateClassTest&lt;long long unsigned int&gt; u32Type;\ntypedef TemplateClassTest&lt;bool&gt; boolType;\n\nint main()\n{\n    u32Type l(\"test\", \"0\"); //matches ctor 2\n    u32Type v(\"test\", 0); // ambiguity between ctor 1 and 2\n    boolType b(\"test\", \"true\"); //matches ctor 2\n    return 0;\n}\n</code></pre>\n<p>The second call fails to compile by throwing error:</p>\n<blockquote>\n<p id=\"so_19796413_19796413_0\">Call of overloaded 'TemplateClassTest(const char [5], int) is ambiguous.</p>\n</blockquote>\n<p>Why does <code>int</code> matches to <code>const char *</code>? This situation can be solved by changing the <code>const char *</code> to <code>const string &amp;</code> in ctor 2. But doing so, <code>boolType b(\"test\", \"true\")</code> now gets matched to ctor 1 instead of ctor 2.</p>\n<p>My requirements are:</p>\n<ul>\n<li><code>u32Type v(\"test\", 0)</code> should match ctor 1</li>\n<li><code>boolType b(\"test\", \"true\")</code> should match ctor 2.</li>\n</ul>\n<p>Limitations are:</p>\n<ul>\n<li>ctor 1 and 3 signatures can't be changed</li>\n<li>user code calls in main() can't be changed.</li>\n</ul>\n<p>Any help is highly appreciated..Thanks!</p>\n", "Title": "Template class constructor overload resolution", "CreationDate": "2013-11-05T18:45:08.373", "LastActivityDate": "2013-11-05T19:14:08.077", "CommentCount": "8", "LastEditDate": "2013-11-05T18:58:40.667", "PostTypeId": "1", "LastEditorUserId": "420683", "Id": "19796413", "Score": "1", "OwnerUserId": "1327677", "Tags": "<c++><templates><constructor><overload-resolution><constructor-overloading>", "AnswerCount": "1"}});