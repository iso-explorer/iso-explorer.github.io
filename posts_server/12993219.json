post_cb({"12993219": {"CommentCount": "9", "AcceptedAnswerId": "12993702", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-10-20T22:21:38.840", "LastActivityDate": "2014-08-19T06:05:51.163", "LastEditDate": "2017-05-23T11:45:39.890", "ViewCount": "2529", "FavoriteCount": "10", "Title": "access private member using template trick", "Id": "12993219", "Score": "16", "Body": "<p>From a blog post <a href=\"http://bloglitb.blogspot.com/2011/12/access-to-private-members-safer.html\" rel=\"nofollow noreferrer\"><em>Access to private members: Safer nastiness</em></a> by <a href=\"https://stackoverflow.com/users/34509/johannes-schaub-litb\">Johannes Schaub - litb</a>:</p>\n<pre><code>template&lt;typename Tag, typename Tag::type M&gt;\nstruct Rob { \n  friend typename Tag::type get(Tag) {\n    return M;\n  }\n};\n\n// use\nstruct A {\n  A(int a):a(a) { }\nprivate:\n  int a;\n};\n\n// tag used to access A::a\nstruct A_f { \n  typedef int A::*type;\n  friend type get(A_f);\n};\n\ntemplate struct Rob&lt;A_f, &amp;A::a&gt;;\n\nint main() {\n  A a(42);\n  std::cout &lt;&lt; \"proof: \" &lt;&lt; a.*get(A_f()) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>how <code>get</code> function can be call from <code>a</code> object since its not defined inside <code>class A</code> ?</p>\n<p><strong>EDIT:</strong></p>\n<p>I don't understand why get must have Tag as parameter instead of  <code>a.*get&lt;A_f&gt;()</code>\n=&gt; ok it's due to ADL mechanism</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "619570", "AnswerCount": "3"}, "12994900": {"ParentId": "12993219", "CommentCount": "1", "CreationDate": "2012-10-21T04:08:33.820", "OwnerUserId": "812383", "PostTypeId": "2", "Id": "12994900", "Score": "1", "Body": "<p>This is a known compiler bug in gcc and was fixed in a later release.\nSee-:</p>\n<p><a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=41437\" rel=\"nofollow\">http://gcc.gnu.org/bugzilla/show_bug.cgi?id=41437</a></p>\n", "LastActivityDate": "2012-10-21T04:08:33.820"}, "12993702": {"ParentId": "12993219", "PostTypeId": "2", "CommentCount": "10", "CreationDate": "2012-10-20T23:50:49.283", "Score": "6", "LastEditorUserId": "1322972", "LastEditDate": "2014-08-19T06:05:51.163", "Id": "12993702", "OwnerUserId": "1425813", "Body": "<p>You are not calling <code>get</code> from <code>a</code>! Actually what get return is a class pointer to a member inside <code>A</code> and type of it is <code>int A::*</code> so you need an instance of <code>A</code> to access that value.</p>\n<p>For example let me play a little with your code:</p>\n<pre><code>struct A {\n    A(int a):a(a) { }\n    int b;\nprivate:\n    int a;\n};\nvoid test() {\n    auto p = &amp;A::b;\n    std::cout &lt;&lt; a.*p &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Did I call <code>p</code> from inside <code>a</code>? <code>a</code> does not have <code>p</code>, this is exactly what happened in your code, <code>get</code> function return <code>&amp;A::a</code> and you use <code>a</code> to read its value! that's all, nothing is wrong and I think it will be compiled in all compilers.</p>\n<p>One other question here is: Why C++ allow declaring template using private member of <code>A</code>. C++ standard say:</p>\n<blockquote>\n<p id=\"so_12993219_12993702_0\"><strong>14.7.2p8</strong> The usual access checking rules do not apply to names used to  specify explicit instantiations. [Note: In particular, the template \n  arguments and names used in the function declarator (including\n  parameter  types, return types and exception specifications) may be\n  private types or objects which would normally not be accessible and\n  the template may  be a member template or member function which would\n  not normally be  accessible.]</p>\n</blockquote>\n<p>But if you try to instantiate or even <code>typedef</code> specified template then you get an error.\nLet's modify your example slightly:</p>\n<pre><code>struct A {\nprivate:\n    int a;\n    friend void f();\n};\n\n// Explicit instantiation - OK, no access checks\ntemplate struct Rob&lt;A_f, &amp;A::a&gt;;\n\n// Try to use the type in some way - get an error.\nstruct Rob&lt;A_f, &amp;A::a&gt; r;            // error\ntypedef struct Rob&lt;A_f, &amp;A::a&gt; R;    // error\nvoid g(struct Rob&lt;A_f, &amp;A::a&gt;);      // error\n\n// However, it's Ok inside a friend function.\nvoid f() {\n    Rob&lt;A_f, &amp;A::a&gt; r;               // OK\n    typedef Rob&lt;A_f, &amp;A::a&gt; R;       // OK\n}\n</code></pre>\n", "LastActivityDate": "2014-08-19T06:05:51.163"}, "bq_ids": {"n4140": {"so_12993219_12993702_0": {"section_id": 261, "quality": 0.926829268292683, "length": 38}}, "n3337": {"so_12993219_12993702_0": {"section_id": 252, "quality": 0.926829268292683, "length": 38}}, "n4659": {"so_12993219_12993702_0": {"section_id": 268, "quality": 0.926829268292683, "length": 38}}}, "12993318": {"ParentId": "12993219", "CommentCount": "4", "CreationDate": "2012-10-20T22:40:51.237", "OwnerUserId": "1610015", "PostTypeId": "2", "Id": "12993318", "Score": "0", "Body": "<p>It's legal because friend functions are always in the global scope, even if you implement them inside a class. In other words, this:</p>\n<pre><code>class A\n{\n    friend void go() {}\n};\n</code></pre>\n<p>is just a shortcut for:</p>\n<pre><code>class A\n{\n    friend void go();\n};\n\nvoid go() {}\n</code></pre>\n", "LastActivityDate": "2012-10-20T22:40:51.237"}});