post_cb({"22461779": {"CommentCount": "0", "ViewCount": "220", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-03-17T17:56:28.910", "LastActivityDate": "2014-03-31T21:41:53.247", "Title": "Is it legal for a standard algorithm comparator to accept objects of different types?", "AcceptedAnswerId": "22462260", "LastEditDate": "2017-05-23T11:57:37.737", "Id": "22461779", "Score": "7", "Body": "<p><a href=\"https://stackoverflow.com/a/22457695/700825\">An answer recently posted on Stack Overflow</a> showed code that provides, to a standard algorithm, a comparator taking operands of different types:</p>\n<blockquote>\n<h2>2. Use a comparator with templated <code>operator()</code>.</h2>\n<p id=\"so_22461779_22461779_0\">Instead of using a lambda, define a functor with a templated <code>operator()</code>.</p>\n<pre><code>struct comparator\n{\n    template&lt;typename T, typename U&gt;\n    bool operator()(T const&amp; lhs, U const&amp; rhs) const {\n        return lhs.mCommonField &lt; rhs.mCommonField;\n    }\n};\n</code></pre>\n<p id=\"so_22461779_22461779_1\">Then, it's as easy as:</p>\n<pre><code>std::sort(aStructs.begin(), aStructs.end(), comparator{});\nstd::sort(bStructs.begin(), bStructs.end(), comparator{});\n// ...\nstd::set_intersection(aStructs.begin(), aStructs.end(),\n                      bStructs.begin(), bStructs.end(),\n                      std::back_inserter(intersection),\n                      comparator{}\n                      );\n</code></pre>\n<p id=\"so_22461779_22461779_2\">Just note that as there is a template in the comparator, it must be declared outside of function scope. Live example on <a href=\"http://coliru.stacked-crooked.com/a/a673d5061e58c7b4\" rel=\"nofollow noreferrer\">Coliru Viewer</a>.</p>\n</blockquote>\n<p>Apparently this at least works in practice, as evidenced by the working live demo.</p>\n<p>But is it strictly allowed by the standard?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "700825", "AnswerCount": "1"}, "22462260": {"ParentId": "22461779", "LastEditDate": "2014-03-31T21:41:53.247", "CommentCount": "2", "CreationDate": "2014-03-17T18:20:49.693", "OwnerUserId": "3311013", "LastEditorUserId": "3311013", "PostTypeId": "2", "Id": "22462260", "Score": "11", "Body": "<p>The corresponding section in the standard is \u00a725.4. The only requirements on the type of the <code>Compare</code> parameter are in \u00a725.4/2:</p>\n<blockquote>\n<p id=\"so_22461779_22462260_0\"><code>Compare</code> is a function object type. The return value of the function call operation applied to an object of type <code>Compare</code>, when contextually converted to <code>bool</code>, yields <code>true</code> if the first argument of the call is less than the second, and <code>false</code> otherwise. <code>Compare comp</code> is used throughout for algorithms assuming an ordering relation. It is assumed that <code>comp</code> will not apply any non-constant function through the dereferenced iterator.</p>\n</blockquote>\n<p>In other words, when called, it can't change the values pointed at by the iterators and should yield a strict weak ordering on the values. Since that comparator satisfies both of these requirements, yes, it's legal!</p>\n<p>In fact, this kind of comparison functor is exactly what is proposed in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3421.htm\" rel=\"nofollow\">N3421 - Making Operator Functors <code>greater&lt;&gt;</code></a>, now part of the C++14 standard. It provides <code>void</code> specializations for the standard library functors that perfect forward comparisons to the corresponding operator, if any. For example (taken from the proposal paper):</p>\n<pre><code>namespace std\n{\n    template &lt;&gt; struct greater&lt;void&gt; {\n      template &lt;class T, class U&gt; auto operator()(T&amp;&amp; t, U&amp;&amp; u) const\n        -&gt; decltype(std::forward&lt;T&gt;(t) &gt; std::forward&lt;U&gt;(u))\n           { return std::forward&lt;T&gt;(t) &gt; std::forward&lt;U&gt;(u); }\n    };\n}\n</code></pre>\n", "LastActivityDate": "2014-03-31T21:41:53.247"}, "bq_ids": {"n4140": {"so_22461779_22462260_0": {"section_id": 1394, "quality": 0.9772727272727273, "length": 43}}, "n3337": {"so_22461779_22462260_0": {"section_id": 1388, "quality": 0.9772727272727273, "length": 43}}, "n4659": {"so_22461779_22462260_0": {"section_id": 1512, "quality": 0.9772727272727273, "length": 43}}}});