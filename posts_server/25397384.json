post_cb({"bq_ids": {"n4140": {"so_25397384_25397384_0": {"length": 19, "quality": 0.8260869565217391, "section_id": 435}}, "n3337": {"so_25397384_25397384_0": {"length": 19, "quality": 0.8260869565217391, "section_id": 427}}, "n4659": {"so_25397384_25397384_0": {"length": 19, "quality": 0.8260869565217391, "section_id": 454}}}, "25397562": {"Id": "25397562", "PostTypeId": "2", "Body": "<p>Your example doesn't demonstrate much, since the virtual base <code>A</code> has a <em>default constructor</em>. You never have to explicitly invoke default constructor for a virtual base class (or any base class for that matter). The compiler will invoke that default constructor implicitly everywhere it is needed, regardless of whether you've done it explicitly yourself.</p>\n<p>Remove the default constructor and provide a constructor with a parameter in <code>A</code></p>\n<pre><code>struct A\n{\n    A(int)\n    {\n        cout &lt;&lt; \"A()\" &lt;&lt; endl;\n    }\n};\n</code></pre>\n<p>The note in question is telling you that now you will have to explicitly invoke the constructor for base <code>A</code> from each <em>non-abstract</em> class virtually derived from <code>A</code> (directly or indirectly). In your case you have to explicitly initialize <code>A</code> from the constructor of <code>C</code></p>\n<pre><code>struct C : B\n{\n    void bar(){ }\n    C() : A(42)\n    {\n        cout &lt;&lt; \"C()\" &lt;&lt; endl;\n    }\n};\n</code></pre>\n<p>since C is not an abstract class. </p>\n<p>But you don't have to initialize <code>A</code> from the constructor of <code>B</code>, since <code>B</code> is an abstract class. I.e. this</p>\n<pre><code>struct B : virtual A\n{\n    virtual void bar() = 0;\n\n    B()\n    {\n        cout &lt;&lt; \"B()\" &lt;&lt; endl;\n    }\n};\n</code></pre>\n<p>should compile in C++11, even tough the \"classic\" (pre-C++11) language rules required an explicit initialization of <code>A</code> from the constructor of <code>B</code> as well.</p>\n<p>Note that GCC compiler used by ideone (for one example), still reports an error for the above definition of class <code>B</code> even in C++11 mode. Apparently, it has not been updated yet to follow that rule of C++11.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2014-08-20T06:06:03.757", "Score": "1", "CreationDate": "2014-08-20T05:50:42.463", "ParentId": "25397384", "CommentCount": "0", "OwnerUserId": "187690", "LastEditDate": "2014-08-20T06:06:03.757"}, "25397512": {"Id": "25397512", "PostTypeId": "2", "Body": "<p>It's talking about something like this:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing std::cout;\nusing std::endl;\n\nstruct A\n{\n    virtual void foo(){ };\n\n    // N.B.: no default ctor\n    A(int)\n    {\n        cout &lt;&lt; \"A(int)\" &lt;&lt; endl;\n    }\n};\n\nstruct B : virtual A\n{\n    virtual void bar() = 0;\n\n    B()\n    {\n        cout &lt;&lt; \"B()\" &lt;&lt; endl;\n    }\n};\n\nstruct C : B\n{\n    void bar(){ };\n    C() : A(10), B()\n    {\n        cout &lt;&lt; \"C()\" &lt;&lt; endl;\n    }\n};\n\nC c;\n\nint main()\n{\n\n}\n</code></pre>\n<p>If <code>A</code> weren't a virtual base of <code>B</code>, or <code>B</code> weren't abstract, then <code>B::B()</code> must have an appropriate <em>mem-initializer</em> for <code>A</code>; however, since <code>B</code> is abstract and <code>A</code> is a virtual base, and <code>B</code>'s constructor will never actually construct <code>A</code>, the <em>mem-initializer</em> can be omitted. Note that g++ currently does not implement this rule and still requires a <em>mem-initializer</em> for <code>B</code> (which it will never actually use). Clang does, however. <a href=\"http://coliru.stacked-crooked.com/a/9ed25370645f988b\" rel=\"nofollow\">Demo</a>.</p>\n<p>See also <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#257\" rel=\"nofollow\">CWG issue 257</a>, which introduced this rule, with the phrasing further altered later by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1658\" rel=\"nofollow\">CWG issue 1658</a>. The relevant GCC bug reports are <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=19249\" rel=\"nofollow\">bug 19249</a> and <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=53878\" rel=\"nofollow\">53878</a>.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2014-08-20T05:53:14.213", "Score": "3", "CreationDate": "2014-08-20T05:47:08.133", "ParentId": "25397384", "CommentCount": "4", "OwnerUserId": "2756719", "LastEditDate": "2014-08-20T05:53:14.213"}, "25397520": {"Id": "25397520", "PostTypeId": "2", "Body": "<p>If <code>B</code> inherits non-virtually from <code>A</code>, then <code>B</code>'s constructor must initialize the <code>A</code> base class subobject. Since <code>A</code> has a default constructor, you don't have to explicitly mention <code>A</code> in the <em>ctor-initializer</em> for <code>B</code>. However, if <code>A</code> did not have a default constructor, and <code>B</code> inherited non-virtually from <code>A</code>, you would have to explicitly initialize <code>A</code> in the <em>ctor-initializer</em> for <code>B</code>.</p>\n<p>If <code>B</code> inherits virtually from <code>A</code>, and <code>B</code> is an abstract class, then even if <code>A</code> has no default constructor, you still don't need to mention <code>A</code> in the <em>ctor-initializer</em> for <code>B</code>. This is because <code>B</code>'s constructor will never have the responsibility of initializing the <code>A</code> subobject; instead, the most derived class's constructor is the one that has to initialize the <code>A</code> subobject, since <code>A</code> is a virtual base class. </p>\n", "LastActivityDate": "2014-08-20T05:47:26.937", "CommentCount": "3", "CreationDate": "2014-08-20T05:47:26.937", "ParentId": "25397384", "Score": "2", "OwnerUserId": "481267"}, "25397384": {"ViewCount": "323", "Body": "<p>Consider the code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing std::cout;\nusing std::endl;\n\nstruct A\n{\n    virtual void foo(){ };\n\n    A()\n    {\n        cout &lt;&lt; \"A()\" &lt;&lt; endl;\n    }\n};\n\nstruct B : virtual A\n{\n    virtual void bar() = 0;\n\n    B() : A() //mem-initializer of virtual base class\n    {\n        cout &lt;&lt; \"B()\" &lt;&lt; endl;\n    }\n};\n\nstruct C : B\n{\n    void bar(){ };\n    C() : B()\n    {\n        cout &lt;&lt; \"C()\" &lt;&lt; endl;\n    }\n};\n\nC c;\n\nint main()\n{\n    //A()\n    //B()\n    //C()\n    //Is output\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/40ae35f88dea8b0d\" rel=\"nofollow\">demo</a></p>\n<p>I've written the code to understand the rule's note from <strong>12.6.2/8 N37973</strong>:</p>\n<blockquote>\n<p id=\"so_25397384_25397384_0\">[Note: An abstract class (10.4) is never a most derived class, thus\n  its constructors never initialize virtual base classes, therefore the\n  corresponding mem-initializers may be omitted. \u2014 end note]</p>\n</blockquote>\n<p>If we omit mem-initializer in the <code>B()</code> and make the base class <code>A</code> as non-virtual we'll have the same result. </p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/013d6c8202662f55\" rel=\"nofollow\"><strong>Actually</strong></a>. </p>\n<p>So what purpose of the note that I cited?</p>\n", "AcceptedAnswerId": "25397512", "Title": "Initialization of virtual base class of abstract class", "CreationDate": "2014-08-20T05:37:02.997", "Id": "25397384", "CommentCount": "0", "LastEditDate": "2014-08-20T05:41:50.083", "PostTypeId": "1", "OwnerDisplayName": "user2953119", "LastEditorUserId": "2756719", "LastActivityDate": "2014-08-20T06:06:03.757", "Score": "2", "Tags": "<c++><constructor><abstract-class>", "AnswerCount": "3"}});