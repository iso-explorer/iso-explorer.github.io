post_cb({"bq_ids": {"n4140": {"so_17783622_17783927_0": {"length": 23, "quality": 1.0, "section_id": 757}}, "n3337": {"so_17783622_17783927_0": {"length": 19, "quality": 0.8260869565217391, "section_id": 745}}, "n4659": {"so_17783622_17783927_0": {"length": 23, "quality": 1.0, "section_id": 817}}}, "17783927": {"Id": "17783927", "PostTypeId": "2", "Body": "<p>What you are doing is undefined behavior: equal elements should have equal hash values. According to the standard (emphasis mine)</p>\n<p><strong>23.2.5 Unordered associative containers [unord.req]</strong></p>\n<blockquote>\n<p id=\"so_17783622_17783927_0\">5 Two values k1 and k2 of type Key are considered equivalent if the\n  container\u2019s key equality predicate returns true when passed those\n  values. <strong>If k1 and k2 are equivalent, the container\u2019s hash function\n  shall return the same value for both</strong>. </p>\n</blockquote>\n<p>Since you define equivalence in terms of modulo 2, you also need to use the hash function on the modulo 2 of the integer being passed. It also means that you need <code>std::unordered_multimap</code> as soon as you have more than 2 elements.</p>\n", "LastActivityDate": "2013-07-22T09:23:44.430", "CommentCount": "6", "CreationDate": "2013-07-22T09:23:44.430", "ParentId": "17783622", "Score": "6", "OwnerUserId": "819272"}, "17783622": {"ViewCount": "1292", "Body": "<p>So, guys, I am playing with <code>std::unordered multimap</code> just for fun. I'd like to store (in this example) <code>unsigned short</code>s, with a custom hash and equal. </p>\n<p>What's the funny part? Having two items being equal if they're both even or odd.</p>\n<p>So, as far as I understand, I can't use <code>std::unordered_map</code>, even though actual values differ: the custom predicate says otherwise. (correct me if I'm wrong, obviously!)</p>\n<p>So to recap: I store <em>different</em> integers and therefore <em>different hashes</em>, but their values under the predicate <em>might be the same</em>.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;unordered_map&gt;\n\nclass tt\n{\npublic:\n\n    tt(const unsigned short v = 0) : i(v) { };\n\n    unsigned short i;\n};\n\nclass tt_hash\n{\npublic:\n    size_t operator()(const tt &amp;v) const\n    {\n        auto f = std::hash&lt;unsigned short&gt;();\n        return f(v.i);\n    };\n};\n\nclass tt_equal\n{\npublic:\n    bool operator()(const tt &amp;u, const tt &amp;v) const\n    {\n        return (u.i % 2) == (v.i % 2);\n    };\n};\n\ntypedef std::unordered_multimap&lt;tt, bool, tt_hash, tt_equal&gt; mymap;\n\n// Print all values that match a criteria\nvoid f(const mymap &amp;m, unsigned short c)\n{\n    auto range = m.equal_range(c);\n\n    auto target = range.first;\n\n    if (target == m.end())\n    {\n        std::cout &lt;&lt; \"not found : \" &lt;&lt; (int) c &lt;&lt; std::endl;\n    }\n    else\n    {\n        for (auto i = target; i != range.second; i++)\n            std::cout &lt;&lt; \"there is  : \" &lt;&lt; (int) i-&gt;first.i &lt;&lt; \" : \" &lt;&lt; i-&gt;second &lt;&lt; std::endl;\n    }\n\n}\n\nint main(int argc, const char * argv[])\n{    \n    mymap m;\n\n    m.emplace(std::make_pair(tt(3), false));\n    m.emplace(std::make_pair(tt(10), true));\n    m.emplace(std::make_pair(tt(4), true));\n    m.emplace(std::make_pair(tt(23), false));\n\n    std::cout &lt;&lt; \"size \" &lt;&lt; m.size() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"buck \" &lt;&lt; m.bucket_count() &lt;&lt; std::endl;\n\n    int c = 0;\n\n    for (auto i = m.begin(); i != m.end(); i++)\n        std::cout &lt;&lt; \"# \" &lt;&lt; c++ &lt;&lt; \" : \" &lt;&lt; (int) i-&gt;first.i &lt;&lt; \" : \" &lt;&lt; i-&gt;second &lt;&lt; std::endl;\n\n    f(m, 3);\n\n    return 0;\n}\n</code></pre>\n<p>So, when I execute the code above I find the correct values, 3, 10, 4, 23 (not in this order of course). </p>\n<p>Unexpectedly, when printing all the values <em>matching 3</em> calling <code>f()</code>, I get two answers, 3 and 23; but when I ask for 1000, I expected to have all the even numbers printed, but I was wrong:</p>\n<pre><code>size 4\nbuck 5\n# 0 : 4 : 1\n# 1 : 10 : 1\n# 2 : 3 : 0\n# 3 : 23 : 0\nthere is  : 10 : 1\n</code></pre>\n<p>Am I missing something here? (the answer is obviously yes) </p>\n", "Title": "Playing with unordered_multimap", "CreationDate": "2013-07-22T09:09:13.470", "LastActivityDate": "2013-07-22T09:23:44.430", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2013-07-22T09:21:40.647", "LastEditorUserId": "737971", "Id": "17783622", "Score": "3", "OwnerUserId": "737971", "Tags": "<c++><c++11><hashmap><unordered-map>", "AnswerCount": "1"}});