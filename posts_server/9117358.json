post_cb({"9117358": {"ViewCount": "133", "Body": "<p>Say, the code</p>\n<pre><code>    class Derived: public Base {....}\n\n    Base* b_ptr = new( malloc(sizeof(Derived)) ) Base(1);\n    b_ptr-&gt;f(2);\n    Derived* d_ptr = new(b_ptr) Derived(3);\n    b_ptr-&gt;g(4);\n    d_ptr-&gt;f(5);\n</code></pre>\n<p>seems to be reasonable and LSP is satisfied.</p>\n<p>I suspect that this code is standard-allowed when Base and Derived are POD, and disallowed otherwise (because vtbl ptr is overwritten). The first part of my question is: please point out precise precondition of such an overwrite.</p>\n<p>There may exist other standard-allowed ways to write over.</p>\n<p>The second part of my question is: is there any other ways? What are their precise preconditions?</p>\n<p>UPDATE: I do NOT want to write code like this; I am interested in theoretical possiblity (or impossibiliy) of such a code. So, this is \"standard nazi\" question, not a question \"how can I ...\". (Has my question to be moved to other stackoverflow site?)</p>\n<p>UPDATE2&amp;4: What about destructors? Supposed semantics of this code is \"Base instance is (destructively) updated by slice of Derived instance\". Let us assume, for the sake of simplicity, that Base class has a trivial destructor.</p>\n<p>UPDATE3: The most intersting for me is <strong>the validity of access via <code>b_ptr-&gt;g(4)</code></strong></p>\n", "AcceptedAnswerId": "9117429", "Title": "Is it allowed to write an instance of Derived over an instance of Base?", "CreationDate": "2012-02-02T17:55:15.740", "Id": "9117358", "CommentCount": "8", "LastEditDate": "2013-02-04T13:05:43.897", "PostTypeId": "1", "LastEditorUserId": "560648", "LastActivityDate": "2013-02-04T13:05:43.897", "Score": "3", "OwnerUserId": "1123502", "Tags": "<c++><memory><overwrite><language-lawyer>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_9117358_9117429_0": {"length": 43, "quality": 1.0, "section_id": 7195}, "so_9117358_9117429_1": {"length": 49, "quality": 0.9607843137254902, "section_id": 7192}}, "n3337": {"so_9117358_9117429_0": {"length": 43, "quality": 1.0, "section_id": 6939}, "so_9117358_9117429_1": {"length": 49, "quality": 0.9607843137254902, "section_id": 6936}}, "n4659": {"so_9117358_9117429_0": {"length": 43, "quality": 1.0, "section_id": 8704}, "so_9117358_9117429_1": {"length": 49, "quality": 0.9607843137254902, "section_id": 8701}}}, "9117609": {"Id": "9117609", "PostTypeId": "2", "Body": "<p>If you write this code more cleanly, it is easier to see what goes wrong:</p>\n<pre><code>void * addr = std::malloc(LARGE_NUMBER);\n\nBase * b = new (addr) Base;\nb-&gt;foo();                    // no problem\n\nDerived * d = new (addr) Derived;\nd-&gt;bar();                    // also fine  (#1)\n\nb-&gt;foo();                    // Error! b no longer points to a Base!\n\nstatic_cast&lt;Base*&gt;(d)-&gt;foo(); // OK\nb = d; b-&gt;foo();              // also OK\n</code></pre>\n<p>The problem is that at the line marked (#1), <code>b</code> and <code>d</code> point to entirely separate, unrelated things, and since you overwrote the memory of the erstwhile object <code>*b</code>, <code>b</code> is in fact no longer valid at all.</p>\n<p>You may have some misguided thoughts about <code>Base*</code> and <code>Derived*</code> being convertible pointer types, but that has nothing to do with the present situation, and for the sake of this example, the two types may as well be entirely unrelated. It is only one the very last two lines that we use the fact that the <code>Derived*</code> is convertible to a <code>Base*</code>, when we perform the actual conversion. But note that this conversion is a genuine <em>value</em> conversion, and <code>d</code> <em>is not the same pointer</em> as <code>static_cast&lt;Base*&gt;(d)</code> (at least as far as the language is concerned).</p>\n<p>Finally, let's clean up this mess:</p>\n<pre><code>d-&gt;~Derived();\nstd::free(addr);\n</code></pre>\n<p>The opportunity to destroy the original <code>*b</code> has passed, so we may have leaked that.</p>\n", "LastActivityDate": "2012-02-02T18:12:33.947", "CommentCount": "0", "CreationDate": "2012-02-02T18:12:33.947", "ParentId": "9117358", "Score": "1", "OwnerUserId": "596781"}, "9117429": {"Id": "9117429", "PostTypeId": "2", "Body": "<p>You really need to do <code>b_ptr = d_ptr</code> after placement-new of <code>Derived</code>, in case the <code>Base</code> subobject isn't first in the layout of <code>Derived</code>.  As written, <code>b_ptr-&gt;g(4)</code> evokes undefined behavior.</p>\n<p>The rule (3.8 <code>basic.life</code>):</p>\n<blockquote>\n<p id=\"so_9117358_9117429_0\"><strong>If, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, a new object is created at the storage location which the original object occupied, a pointer that pointed to the original object</strong>, a reference that referred to the original object, or the name of the original object will automatically refer to the new object and, once the lifetime of the new object has started, <strong>can\n  be used to manipulate the new object, if</strong>:</p>\n<ul>\n<li>the storage for the new object exactly overlays the storage location which the original object occupied,\n  and</li>\n<li>the new object is of the same type as the original object (ignoring the top-level cv-quali\ufb01ers), and</li>\n<li>the type of the original object is not const-quali\ufb01ed, and, if a class type, does not contain any non-static\n  data member whose type is const-quali\ufb01ed or a reference type, and</li>\n<li>the original object was a most derived object (1.8) of type <code>T</code> and the new object is a most derived object of type <code>T</code> (that is, they are <strong>not base class subobjects</strong>).</li>\n</ul>\n</blockquote>\n<p>You also should probably be destroying the old object before reusing its memory, but the standard doesn't mandate this.  However failure to do so will leak any resources owned by the old object.  The full rule is given in section 3.8 (<code>basic.life</code>) of the Standard:</p>\n<blockquote>\n<p id=\"so_9117358_9117429_1\">A program may end the lifetime of any object by reusing the storage which the object occupies or by explicitly calling the destructor for an object of a class type with a non-trivial destructor.  For an object of a class type with a non-trivial destructor, the program is not required to call the destructor explicitly before the storage which the object occupies is reused or released; however, if there is no explicit call to\n  the destructor or if a delete-expression (5.3.5) is not used to release the storage, the destructor shall not be implicitly called and <strong>any program that depends on the side effects produced by the destructor has undefined behavior</strong>.</p>\n</blockquote>\n", "LastEditorUserId": "596781", "LastActivityDate": "2012-02-02T20:10:28.370", "Score": "8", "CreationDate": "2012-02-02T17:59:45.113", "ParentId": "9117358", "CommentCount": "5", "OwnerUserId": "103167", "LastEditDate": "2012-02-02T20:10:28.370"}, "9117410": {"Id": "9117410", "PostTypeId": "2", "Body": "<p>You are initializing the same piece of memory twice. That won't end well.</p>\n<p>Suppose for example that the <code>Base</code> constructor allocates some memory and stores it in a pointer. The second time through the constructor, the first pointer will be overwritten and the memory leaked.</p>\n", "LastActivityDate": "2012-02-02T17:58:15.897", "CommentCount": "1", "CreationDate": "2012-02-02T17:58:15.897", "ParentId": "9117358", "Score": "1", "OwnerUserId": "5987"}, "9117486": {"Id": "9117486", "PostTypeId": "2", "Body": "<p>I think the overwrite is allowed.</p>\n<p>If it was me I'd probably call <code>Base::~Base</code> before reusing the storage, so that the lifetime of the original object ended cleanly. But the standard explicitly allows you to reuse the storage without calling the destructor.</p>\n<p>I don't believe your access via b_ptr is valid. The lifetime of the Base object has ended.</p>\n<p>(See 3.8/4 in either standard for the rules on lifetime.)</p>\n<p>And I'm also not entirely convinced that b_ptr must give the same address as was originally returned by the malloc() call.</p>\n", "LastActivityDate": "2012-02-02T18:03:50.580", "CommentCount": "2", "CreationDate": "2012-02-02T18:03:50.580", "ParentId": "9117358", "Score": "1", "OwnerUserId": "212870"}});