post_cb({"39241306": {"ParentId": "39240085", "CommentCount": "0", "Body": "<p>Member of <code>struct</code> is default to be public, and member of <code>class</code> is default to be private. \nSo <code>f()</code> in B is public and when it's derived to D, because you didn't explicitly declare it is public, so according to rules of derivation, it became private.</p>\n", "OwnerUserId": "6768208", "PostTypeId": "2", "Id": "39241306", "Score": "0", "CreationDate": "2016-08-31T05:19:05.743", "LastActivityDate": "2016-08-31T05:19:05.743"}, "39244879": {"ParentId": "39240085", "CommentCount": "0", "Body": "<p>This actually has less to do with virtual dispatch and more to do with what access specifiers mean.</p>\n<p><strong>The function itself is not <code>private</code>; its <em>name</em> is.</strong></p>\n<p>Consequently, the function cannot be named outside of the scope of the class, e.g. from <code>main</code>. However, you can still do so through a name that is <code>public</code> (i.e. the base's virtual function that is overridden) or from a scope in which the function's name is accessible despite the <code>private</code> qualifier (e.g. a member function of that class).</p>\n<p>That's just how it works.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "39244879", "Score": "3", "CreationDate": "2016-08-31T08:47:31.650", "LastActivityDate": "2016-08-31T08:47:31.650"}, "39240176": {"ParentId": "39240085", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This has to do that with virtual dispatch is a runtime concept. The class <code>B</code> doesn't care which class extends it, and it doesn't care if it's private or public because it can't know.</p>\n<blockquote>\n<p id=\"so_39240085_39240176_0\">I can't figure out why D::f() is private, D is public inherited from B, so the public function f in B\n  is also public in D(I know without inheritance, member access is private by default)</p>\n</blockquote>\n<p><code>D::f()</code> is private because you made it private. This rule isn't affect by inheritance nor virtual dispatch.</p>\n<blockquote>\n<p id=\"so_39240085_39240176_1\">f is a virtual function in B, so if we call b.f(), we actually call D::f(), but just as the illustration mentioned, why D::f() is able to be invoked even though it's private?</p>\n</blockquote>\n<p>Because in reality, when invoking <code>b.f()</code>, the compiler has no idea which function will actually be called. It will simply call the function <code>f()</code>, and since <code>B::f</code> is virtual, the called function will be chosen at <em>runtime</em>. The runtime program has no information about which function is private or protected. It only know functions.</p>\n<p>If the function is chosen at runtime, the compiler can't know at compile-time what function will be called, and the access specifier can't be known. In fact, the compiler won't even try to check if the function called will be private or not. The access specifier could be in some code that the compiler haven't seen yet.</p>\n<p>As you've experienced, you can't call <code>D::f</code> directly. This is exactly what private will do: prohibit direct access of the member. You can, however, access it indirectly through a pointer or a reference. The virtual dispatch you use will do that internally.</p>\n", "OwnerUserId": "2104697", "LastEditorUserId": "3980929", "LastEditDate": "2016-09-21T19:02:08.077", "Id": "39240176", "Score": "20", "CreationDate": "2016-08-31T03:15:12.763", "LastActivityDate": "2016-09-21T19:02:08.077"}, "39240312": {"ParentId": "39240085", "CommentCount": "1", "Body": "<p>The answer given illustrates what is being done, but why would you ever want to do this, where the base class calls <code>private</code> virtual functions?</p>\n<p>Well, there is a design pattern called the  <a href=\"https://en.wikipedia.org/wiki/Template_method_pattern\">template method pattern</a> that uses this technique of having a base class that calls private virtual functions in the derived class.</p>\n<pre><code>struct B \n{\n    virtual ~B() {};\n    int do_some_algorithm()\n    {\n       do_step_1();\n       do_step_2();\n       do_step_3();\n    }\n\n    private:\n          virtual void do_step_1() {}\n          virtual void do_step_2() {}\n          virtual void do_step_3() {}\n};\n\nclass D : public B \n{ \n   void do_step_1() \n   {\n      // custom implementation\n   }\n   void do_step_2() \n   {\n      // custom implementation\n   }\n\n   void do_step_3() \n   {\n      // custom implementation\n   }\n};\n\nint main()\n{\n   D dInstance;\n   B * pB = &amp;dInstance;\n   pB-&gt;do_some_algorithm();\n}\n</code></pre>\n<p>This allows us to not expose the custom steps of class <code>D</code> to the <code>public</code> interface, but at the same time allows <code>B</code> to call these functions using a <code>public</code> function.  </p>\n", "OwnerUserId": "3133316", "PostTypeId": "2", "Id": "39240312", "Score": "5", "CreationDate": "2016-08-31T03:35:00.283", "LastActivityDate": "2016-08-31T03:35:00.283"}, "39241687": {"ParentId": "39240085", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The C++ Standard has an exact example of this:</p>\n<blockquote>\n<p id=\"so_39240085_39241687_0\"><strong>11.5 Access to virtual functions [class.access.virt]</strong> </p>\n<p id=\"so_39240085_39241687_1\">1 The access rules (Clause 11) for a virtual function are determined by its\n  declaration and are not affected by the rules for a function that later\n  overrides it. [<em>Example:</em> </p>\n<pre><code>class B { \npublic:\n  virtual int f();\n};\n\nclass D : public B { \nprivate: \n  int f(); \n}; \n\nvoid f() { \n  D d; \n  B* pb = &amp;d; \n  D* pd = &amp;d; \n  pb-&gt;f();     // OK: B::f() is public, \n               // D::f() is invoked\n  pd-&gt;f();     // error: D::f() is private\n} \n</code></pre>\n<p id=\"so_39240085_39241687_2\"><em>-- end example</em>]</p>\n</blockquote>\n<p>Can't explain it any clearer.</p>\n", "OwnerUserId": "819272", "LastEditorUserId": "819272", "LastEditDate": "2016-08-31T05:56:24.783", "Id": "39241687", "Score": "6", "CreationDate": "2016-08-31T05:51:03.947", "LastActivityDate": "2016-08-31T05:56:24.783"}, "39240567": {"ParentId": "39240085", "CommentCount": "8", "Body": "<p>Access specifiers apply to <em>the function name</em> only, they aren't some restriction on how or when the function can be called by other means.   A private function could be called outside the class if it is made available by some means other than its name (for example, a function pointer).</p>\n<p>For a class declared with <code>class</code> keyword, the default access-specifier is <code>private</code>. Your code is the same as:</p>\n<pre><code>// ...\nclass D: public B\n{\nprivate:\n  int f() { return 2; }\n};\n</code></pre>\n<p>As you can see, <code>f</code> is private in <code>D</code>. It makes no difference what the access specifier was of any function in <code>B</code> with the same name.  Be clear in your mind that <code>B::f()</code> and <code>D::f()</code> are two different functions.  </p>\n<p>The effect of the <code>virtual</code> keyword is that if <code>f()</code> without a scope qualifier is called on a <code>B</code> reference that refers to a <code>D</code> object, then even though it resolves to <code>B::f()</code>, actually <code>D::f()</code> is invoked instead. </p>\n<p>This process still uses the access specifier for <code>B::f()</code>: access is checked at compile-time; but it might be run-time matter as to which function is called.</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "39240567", "Score": "11", "CreationDate": "2016-08-31T04:07:14.903", "LastActivityDate": "2016-08-31T04:07:14.903"}, "39251900": {"ParentId": "39240085", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_39240085_39251900_0\">why D::f() is able to be invoked even though it's private?</p>\n</blockquote>\n<p>To understand virtual function mechanism it is good to know, how it is usually implemented. A function at runtime is actually no more than an address in memory where the executable code of the function body locates. To call the function we need to know its address (a pointer). C++ object with virtual functions representation in memory contains so called <em>vtable</em> - an array of pointers to the virtual functions. </p>\n<p><a href=\"https://i.stack.imgur.com/z82II.png\" rel=\"nofollow noreferrer\"><img alt=\"vtable typical implementation\" src=\"https://i.stack.imgur.com/z82II.png\"/></a></p>\n<p>Key point is that in derived classes vtable repeats (and may extend) the vtable of base class, but if the virtual function is overriden its pointer <em>is replaced</em> in derived object's vtable.</p>\n<p>When a virtual function call is done through the base class pointer, the address of the virtual function is calculated as an offset in the vtable array. No other checks are done, just the function address is taken.\nIf it is a base class object, it will be the address of the base class function. If it is a derived class object, it will be the address of the derived class function, does not matter if it was declared private or not.</p>\n<p>This how it works. </p>\n", "OwnerUserId": "3291022", "PostTypeId": "2", "Id": "39251900", "Score": "1", "CreationDate": "2016-08-31T14:07:44.013", "LastActivityDate": "2016-08-31T14:07:44.013"}, "bq_ids": {"n4140": {"so_39240085_39241687_1": {"section_id": 6696, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_39240085_39241687_1": {"section_id": 6451, "quality": 0.8666666666666667, "length": 13}}, "n4659": {"so_39240085_39241687_1": {"section_id": 8171, "quality": 0.8666666666666667, "length": 13}}}, "39240085": {"CommentCount": "10", "ViewCount": "1975", "PostTypeId": "1", "LastEditorUserId": "1720972", "CreationDate": "2016-08-31T03:01:49.313", "LastActivityDate": "2016-09-21T19:02:08.077", "Title": "Access of member functions in C++ inheritance", "FavoriteCount": "0", "LastEditDate": "2016-08-31T04:01:25.030", "Id": "39240085", "Score": "22", "Body": "<p>I am just confused about the tiny program on inheritance below: </p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nstruct B {\n    virtual int f() { return 1; }\n}; // f is public in B\n\nclass D : public B { \n    int f() { return 2; }\n}; // f is private in D\n\nint main()\n{\n    D d;\n    B&amp; b = d;\n    cout&lt;&lt;b.f()&lt;&lt;endl; // OK: B::f() is public, D::f() is invoked even though it's private\n    cout&lt;&lt;d.f()&lt;&lt;endl; // error: D::f() is private\n}\n</code></pre>\n<ol>\n<li>I can't figure out why <code>D::f()</code> is private, <code>D</code> is <strong>public inherited</strong> from <code>B</code>, so the public function <code>f</code> in <code>B</code><br>\nis also public in <code>D</code> (I know without inheritance, member access is private by default)</br></li>\n<li><code>f</code> is a virtual function in <code>B</code>, so if we call <code>b.f()</code>, we actually call <code>D::f()</code>, but just as the illustration mentioned, why <code>D::f()</code> is able to be invoked even though it's private?</li>\n</ol>\n<p>Can anyone explain the simple inheritance problem in detail?</p>\n", "Tags": "<c++><inheritance><private>", "OwnerUserId": "4164526", "AnswerCount": "7"}});