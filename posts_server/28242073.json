post_cb({"28242073": {"CommentCount": "5", "ViewCount": "826", "PostTypeId": "1", "LastEditorUserId": "225186", "CreationDate": "2015-01-30T18:10:41.050", "LastActivityDate": "2015-01-30T20:19:49.117", "Title": "Viewing a raw pointer as a range in range-based for-loop", "AcceptedAnswerId": "28242402", "LastEditDate": "2015-01-30T20:19:49.117", "Id": "28242073", "Score": "3", "Body": "<p>How can I make a raw pointer behave like a range, for a for-range loop syntax.</p>\n<pre><code>double five = 5;\ndouble* dptr = &amp;five;\nfor(int&amp; d : dptr) std::cout &lt;&lt; d &lt;&lt; std::endl;// will not execute if the pointer is null\n</code></pre>\n<p><strong>Motivation:</strong></p>\n<p>It is now vox populi that an <code>boost::optional</code> (future <code>std::optional</code>) value can be viewed as a range and therefore used in a for range loop <a href=\"http://faithandbrave.hateblo.jp/entry/2015/01/29/173613\" rel=\"nofollow\">http://faithandbrave.hateblo.jp/entry/2015/01/29/173613</a>. </p>\n<p>When I rewrote my own simplified version of it:</p>\n<pre><code>namespace boost {\n    template &lt;class Optional&gt;\n    decltype(auto) begin(Optional&amp; opt) noexcept{\n        return opt?&amp;*opt:nullptr;\n    }\n\n    template &lt;class Optional&gt;\n    decltype(auto) end(Optional&amp; opt) noexcept{\n        return opt?std::next(&amp;*opt):nullptr;\n    }\n}\n</code></pre>\n<p>Used as </p>\n<pre><code>boost::optional&lt;int&gt; opt = 3;\nfor (int&amp; x : opt) std::cout &lt;&lt; x &lt;&lt; std::endl;\n</code></pre>\n<p>While looking that code I imagined that it could be generalized to raw (nullable) pointers as well.</p>\n<pre><code>double five = 5;\ndouble* dptr = &amp;five;\nfor(int&amp; d : dptr) std::cout &lt;&lt; d &lt;&lt; std::endl;\n</code></pre>\n<p>instead of the usual <code>if(dptr) std::cout &lt;&lt; *dptr &lt;&lt; std::endl;</code>. Which is fine but I wanted to achieve the other syntax above.</p>\n<p><strong>Attempts</strong></p>\n<p>First I tried to make the above <code>Optional</code> version of <code>begin</code> and <code>end</code> work for pointers but I couldn't. So I decided to be explicit in the types and remove all templates:</p>\n<pre><code>namespace std{ // excuse me, this for experimenting only, the namespace can be removed but the effect is the same.\n    double* begin(double* opt){\n        return opt?&amp;*opt:nullptr;\n    }\n    double* end(double* opt){\n        return opt?std::next(&amp;*opt):nullptr;\n    }\n}\n</code></pre>\n<p>Almost there, it works for </p>\n<pre><code>for(double* ptr = std::begin(dptr); ptr != std::end(dptr); ++ptr) \n    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;\n</code></pre>\n<p>But it doesn't work for the <em>supposedly equivalent</em> for-range loop:</p>\n<pre><code>for(double&amp; d : dptr) std::cout &lt;&lt; d &lt;&lt; std::endl;\n</code></pre>\n<p>Two compilers tell me: <code>error: invalid range expression of type 'double *'; no viable 'begin' function available</code></p>\n<p><strong>What is going on? Is there a compiler magic that forbids the ranged-loop to to work for pointers. Am I making a wrong assumption about the ranged-loop syntax?</strong></p>\n<p>Ironically, in the standard there is an overload for <code>std::begin(T(&amp;arr)[N])</code> and this is very close to it.</p>\n<hr>\n<p><strong>Note and a second though</strong></p>\n<p>Yes, the idea is silly because, even if possible this would be very confusing:</p>\n<pre><code>double* ptr = new double[10];\nfor(double&amp; d : ptr){...}\n</code></pre>\n<p>would iterate over the first element only. A more clear and also realistic workaround would be to do something like workaround proposed by @Yakk:</p>\n<pre><code>for(double&amp; d : boost::make_optional_ref(ptr)){...}\n</code></pre>\n<p>In this way it is clear that we are iterating over one element only and that that element is optional.</p>\n<p>Ok, ok, I will go back to <code>if(ptr) ... use *ptr</code>.</p>\n</hr>", "Tags": "<c++><pointers><c++11><for-loop><boost-optional>", "OwnerUserId": "225186", "AnswerCount": "2"}, "28242402": {"ParentId": "28242073", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Because the way that range-based for works is (from \u00a76.5.4):</p>\n<blockquote>\n<p id=\"so_28242073_28242402_0\"><em>begin-expr</em> and <em>end-expr</em> are determined as follows<br>\n  \u2014 if <code>_RangeT</code> is an array type, [..]<br>\n  \u2014 if <code>_RangeT</code> is a class type, [..]<br>\n  \u2014 otherwise, <em>begin-expr</em> and <em>end-expr</em> are <code>begin(__range)</code> and <code>end(__range)</code>, respectively, where <code>begin</code>\n  and <code>end</code> are looked up in the associated namespaces (3.4.2). <em>[ Note:</em> Ordinary unqualified lookup (3.4.1)\n  is not performed. <em>\u2014end note ]</em></br></br></br></p>\n</blockquote>\n<p>What are the associated namespaces in this case? (\u00a73.4.2/2, emphasis mine):</p>\n<blockquote>\n<p id=\"so_28242073_28242402_1\">The sets of namespaces and classes are determined in the following way:<br>\n  (2.1) \u2014 If <code>T</code> is a fundamental type, its associated sets of namespaces and classes are <strong>both empty</strong>.</br></p>\n</blockquote>\n<p>Thus, there is no place to put your <code>double* begin(double*)</code> such that it will be called by the range-based <code>for</code> statement. </p>\n<p>A workaround for what you want to do is just make a simple wrapper:</p>\n<pre><code>template &lt;typename T&gt; \nstruct PtrWrapper {\n    T* p;\n    T* begin() const { return p; }\n    T* end() const { return p ? p+1 : nullptr; }\n};\n\nfor (double&amp; d : PtrWrapper&lt;double&gt;{dptr}) { .. }\n</code></pre>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-01-30T18:36:49.347", "Id": "28242402", "Score": "7", "CreationDate": "2015-01-30T18:31:01.440", "LastActivityDate": "2015-01-30T18:36:49.347"}, "28242636": {"ParentId": "28242073", "CommentCount": "10", "Body": "<p>It is a useful lie to think that <code>for(:)</code> loops are implemented by \"calling <code>std::begin</code> and <code>std::end</code> in a ADL-activated context\".  But that is a lie.</p>\n<p>The standard instead basically does a parallel implementation of the <code>std::begin</code> and <code>std::end</code> in itself.  This prevents the language's low level constructs from depending on its own library, which seems like a good idea.</p>\n<p>The only lookup for <code>begin</code> by the language is the ADL-based lookup.  Your pointer's <code>std::begin</code> won't be found, unless you are a pointer to something in <code>std</code>.  The <code>std::begin( T(&amp;)[N} )</code> isn't found this way by the compiler, but instead that iteration is hard-coded by the language.</p>\n<pre><code>namespace boost {\n  template&lt;class T&gt;\n  T* begin( optional&lt;T&gt;&amp;o ) {\n    return o?std::addressof(*o):nullptr;\n  }\n  template&lt;class T&gt;\n  T* begin( optional&lt;T&amp;&gt;&amp;&amp;o ) {\n    return o?std::addressof(*o):nullptr;\n  }\n  template&lt;class T&gt;\n  T const* begin( optional&lt;T&gt; const&amp;o ) {\n    return o?std::addressof(*o):nullptr;\n  }\n  template&lt;class T&gt;\n  T* end( optional&lt;T&gt;&amp;o ) {\n    return o?std::next(begin(o)):nullptr;\n  }\n  template&lt;class T&gt;\n  T* end( optional&lt;T&amp;&gt;&amp;&amp;o ) {\n    return o?std::next(begin(o)):nullptr;\n  }\n  template&lt;class T&gt;\n  T const* end( optional&lt;T&gt; const&amp;o ) {\n    return o?std::next(begin(o)):nullptr;\n  }\n  template&lt;class T&gt;\n  boost::optional&lt;T&amp;&gt; as_optional( T* t ) {\n    if (t) return *t;\n    return {};\n  }\n}\n</code></pre>\n<p>now you can:</p>\n<pre><code>void foo(double * d) {\n  for(double&amp; x : boost::as_optional(d)) {\n    std::cout &lt;&lt; x &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>without having to repeat the type <code>double</code>.</p>\n<p>Note that an rvalue <code>optional</code> to a non-reference returns a <code>T const*</code>, while an rvalue <code>optonal</code> to a <code>T&amp;</code> returns a <code>T*</code>.  Iterating over a temporary in a writing context is probably an error.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "28242636", "Score": "3", "CreationDate": "2015-01-30T18:44:59.307", "LastActivityDate": "2015-01-30T18:44:59.307"}, "bq_ids": {"n4140": {"so_28242073_28242402_0": {"section_id": 3906, "quality": 0.7419354838709677, "length": 23}, "so_28242073_28242402_1": {"section_id": 7104, "quality": 0.9375, "length": 15}}, "n3337": {"so_28242073_28242402_0": {"section_id": 3766, "quality": 0.5806451612903226, "length": 18}, "so_28242073_28242402_1": {"section_id": 6848, "quality": 0.9375, "length": 15}}, "n4659": {"so_28242073_28242402_0": {"section_id": 4792, "quality": 0.7096774193548387, "length": 22}, "so_28242073_28242402_1": {"section_id": 8605, "quality": 0.9375, "length": 15}}}});