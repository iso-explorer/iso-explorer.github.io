post_cb({"37618407": {"ParentId": "37618213", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You're not calling the default constructor, you're using aggregate initialization on an aggregate type. Aggregate types are allowed to have a defaulted constructor, so long as it's defaulted where it's first declared:</p>\n<p>From <a href=\"http://eel.is/c++draft/dcl.init.aggr#1\" rel=\"nofollow noreferrer\">[dcl.init.aggr]/1</a>:</p>\n<blockquote>\n<p id=\"so_37618213_37618407_0\">An aggregate is an array or a class (Clause [class]) with</p>\n<ul>\n<li>no user-provided constructors ([class.ctor]) (including those inherited ([namespace.udecl]) from a base class),</li>\n<li>no private or protected non-static data members (Clause [class.access]),</li>\n<li>no virtual functions ([class.virtual]), and</li>\n<li>no virtual, private, or protected base classes ([class.mi]). </li>\n</ul>\n</blockquote>\n<p>and from <a href=\"http://eel.is/c++draft/dcl.fct.def#dcl.fct.def.default-5\" rel=\"nofollow noreferrer\">[dcl.fct.def.default]/5</a></p>\n<blockquote>\n<p id=\"so_37618213_37618407_1\">Explicitly-defaulted functions and implicitly-declared functions are collectively called defaulted functions, and the implementation shall provide implicit definitions for them ([class.ctor] [class.dtor], [class.copy]), which might mean defining them as deleted. <strong>A function is user-provided if it is user-declared and not explicitly defaulted or deleted on its first declaration.</strong> A user-provided explicitly-defaulted function (i.e., explicitly defaulted after its first declaration) is defined at the point where it is explicitly defaulted; if such a function is implicitly defined as deleted, the program is ill-formed. <em>[ Note: Declaring a function as defaulted after its first declaration can provide efficient execution and concise definition while enabling a stable binary interface to an evolving code base. \u2014 end note ]</em></p>\n</blockquote>\n<p>Thus, our requirements for an aggregate are:</p>\n<ul>\n<li>no non-public members</li>\n<li>no virtual functions</li>\n<li>no virtual or non-public base classes </li>\n<li>no user-provided constructors inherited or otherwise, which allows only constructors which are:\n\n<ul>\n<li>implicitly declared, or</li>\n<li>explicitly declared and defined as defaulted at the same time.</li>\n</ul></li>\n</ul>\n<p><code>C</code> fulfills all of these requirements.</p>\n<p>Naturally, you may be rid of this false default construction behavior by simply providing an empty default constructor, or by defining the constructor as default after declaring it:</p>\n<pre><code>class C {\n    C(){}\n};\n// --or--\nclass C {\n    C();\n};\ninline C::C() = default;\n</code></pre>\n", "OwnerUserId": "4892076", "LastEditorUserId": "492336", "LastEditDate": "2017-01-31T16:49:01.060", "Id": "37618407", "Score": "49", "CreationDate": "2016-06-03T15:36:30.260", "LastActivityDate": "2017-01-31T16:49:01.060"}, "37618395": {"ParentId": "37618213", "CommentCount": "6", "Body": "<p>The trick is in C++14  8.4.2/5 [dcl.fct.def.default]:</p>\n<blockquote>\n<p id=\"so_37618213_37618395_0\">... A function is <em>user-provided</em> if it is user-declared and not explicitly defaulted or\n  deleted on its first declaration. ...</p>\n</blockquote>\n<p>Which means that <code>C</code>'s default constructor is actually <strong>not</strong> user-provided, because it was explicitly defaulted on its first declaration. As such, <code>C</code> has no user-provided constructors and is therefore an aggregate per 8.5.1/1 [dcl.init.aggr]:</p>\n<blockquote>\n<p id=\"so_37618213_37618395_1\">An <em>aggregate</em> is an array or a class (Clause 9) with no user-provided constructors (12.1), no private or\n  protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>\n</blockquote>\n", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "37618395", "Score": "53", "CreationDate": "2016-06-03T15:35:43.890", "LastActivityDate": "2016-06-03T15:35:43.890"}, "bq_ids": {"n4140": {"so_37618213_37618407_1": {"section_id": 3274, "quality": 0.8918918918918919, "length": 66}, "so_37618213_37618395_0": {"section_id": 3274, "quality": 0.8888888888888888, "length": 8}, "so_37618213_37618407_0": {"section_id": 3310, "quality": 0.8, "length": 4}, "so_37618213_37618395_1": {"section_id": 3298, "quality": 0.8421052631578947, "length": 16}}, "n3337": {"so_37618213_37618407_1": {"section_id": 3145, "quality": 0.8918918918918919, "length": 66}, "so_37618213_37618395_0": {"section_id": 3145, "quality": 0.8888888888888888, "length": 8}, "so_37618213_37618407_0": {"section_id": 3180, "quality": 0.8, "length": 4}, "so_37618213_37618395_1": {"section_id": 3168, "quality": 0.8421052631578947, "length": 16}}, "n4659": {"so_37618213_37618407_1": {"section_id": 4032, "quality": 0.8918918918918919, "length": 66}, "so_37618213_37618395_0": {"section_id": 4032, "quality": 0.8888888888888888, "length": 8}, "so_37618213_37618407_0": {"section_id": 6103, "quality": 1.0, "length": 5}, "so_37618213_37618395_1": {"section_id": 4063, "quality": 0.631578947368421, "length": 12}}}, "37618213": {"CommentCount": "14", "AcceptedAnswerId": "37618395", "PostTypeId": "1", "LastEditorUserId": "963864", "CreationDate": "2016-06-03T15:27:21.267", "LastActivityDate": "2017-01-31T16:49:01.060", "LastEditDate": "2016-06-09T00:24:45.260", "ViewCount": "3163", "FavoriteCount": "14", "Title": "When is a private constructor not a private constructor?", "Id": "37618213", "Score": "81", "Body": "<p>Let's say I have a type and I want to make its default constructor private. I write the following:</p>\n<pre><code>class C {\n    C() = default;\n};\n\nint main() {\n    C c;           // error: C::C() is private within this context (g++)\n                   // error: calling a private constructor of class 'C' (clang++)\n                   // error C2248: 'C::C' cannot access private member declared in class 'C' (MSVC)\n    auto c2 = C(); // error: as above\n}\n</code></pre>\n<p>Great.</p>\n<p>But then, the constructor turns out to not be as private as I thought it was:</p>\n<pre><code>class C {\n    C() = default;\n};\n\nint main() {\n    C c{};         // OK on all compilers\n    auto c2 = C{}; // OK on all compilers\n}    \n</code></pre>\n<p>This strikes me as very surprising, unexpected, and explicitly undesired behavior. Why is this OK? </p>\n", "Tags": "<c++><c++11><language-lawyer><default-constructor><aggregate-initialization>", "OwnerUserId": "2069064", "AnswerCount": "2"}});