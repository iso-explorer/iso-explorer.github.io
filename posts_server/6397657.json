post_cb({"bq_ids": {"n4140": {"so_6397657_6397680_0": {"length": 16, "quality": 0.8, "section_id": 53}}, "n3337": {"so_6397657_6397680_0": {"length": 16, "quality": 0.8, "section_id": 48}}, "n4659": {"so_6397657_6397680_0": {"length": 16, "quality": 0.8, "section_id": 55}}}, "6397680": {"Id": "6397680", "PostTypeId": "2", "Body": "<p>I'm sorry you are out of luck. Unless you use a preprocessor metaprogramming library (boost.pp), there is no way to automate that. Not with template metaprogramming.</p>\n<p>What you have produced there are <em>implicit instantiations</em> of <code>Tuple&lt;float, N&gt;</code>. But implicit instantiations have two important differences to explicit instantiations</p>\n<ol>\n<li>They won't instantiate all member definitions (only those that are immediately needed are instantiated). Other definitions are only instantiated when they are used.</li>\n<li>The implicit instantiation of used member definitions cannot be used as a definition source for other translation units.</li>\n</ol>\n<p>For the latter, since I'm not aware of the reason for that, I will just quote the spec. </p>\n<blockquote>\n<p id=\"so_6397657_6397680_0\">A non-exported template must be defined in every translation unit in which it is implicitly instantiated (14.7.1), unless the corresponding specialization is explicitly instantiated (14.7.2) in some translation unit; no diagnostic is required.</p>\n</blockquote>\n<p>That may have to do with linker complications, because implicit instantiations for the same template can occur multiple times in multiple translation units, so they need special handling. Explicit instantiations and non-inline functions can't.</p>\n", "LastEditorUserId": "34509", "LastActivityDate": "2011-06-18T17:42:07.107", "Score": "4", "CreationDate": "2011-06-18T17:30:25.333", "ParentId": "6397657", "CommentCount": "4", "OwnerUserId": "34509", "LastEditDate": "2011-06-18T17:42:07.107"}, "6397694": {"Id": "6397694", "PostTypeId": "2", "Body": "<p>The correct way to avoid linkage errors with templates is to put the template definitions in every TU where you use them. Usually a header file is best suited for this purpose. Using explicit instantiation like this is at best semi-effective, and at worst just damned confusing.</p>\n", "LastActivityDate": "2011-06-18T17:32:35.443", "CommentCount": "5", "CreationDate": "2011-06-18T17:32:35.443", "ParentId": "6397657", "Score": "0", "OwnerUserId": "560648"}, "6397687": {"Id": "6397687", "PostTypeId": "2", "Body": "<p>You can use some template magic to force that instantiation:</p>\n<pre><code>namespace {\n    template &lt;unsigned N&gt;\n    struct Instantiator {\n        void instantiate_members(const Tuple&lt;float,N&gt;&amp; tuple, Instantiator&lt;N-1&gt;) {\n            // use **all** member functions here\n            // so that they get instantiated\n        }\n\n    template &lt;&gt;\n    struct Instantiator&lt;0&gt; {}\n}\n</code></pre>\n<p>And then instantiate this template:</p>\n<pre><code>template class Instantiator&lt;20&gt;;\n</code></pre>\n<p>Unfortunately this is not good in terms of maintenance, because you need to keep the instantiate_members function up to date. And you need to make sure <em>all</em> members are called, including all the various overloads.</p>\n", "LastEditorUserId": "46642", "LastActivityDate": "2011-06-18T18:12:57.120", "Score": "1", "CreationDate": "2011-06-18T17:31:37.030", "ParentId": "6397657", "CommentCount": "6", "OwnerUserId": "46642", "LastEditDate": "2011-06-18T18:12:57.120"}, "6397657": {"ViewCount": "559", "Body": "<p>If I have a class called <code>Tuple&lt;T, SIZE&gt;</code> and I want, let's say, 20 different float templates instantiated when compiling the library (so that the user does not encounter linking errors):</p>\n<pre><code>template Tuple&lt;float, 1&gt;;\ntemplate Tuple&lt;float, 2&gt;;\n...\ntemplate Tuple&lt;float, 20&gt;;\n</code></pre>\n<p>Is there any way to recursively perform the above? And maybe allow it to be flexible so that I can put it any number I would like and it instantiates the classes for me?</p>\n<p><strong>EDIT:</strong> What I have tried so far (does not seem to work):</p>\n<pre><code>template &lt;typename T, unsigned int MAX_RANGE&gt;\nclass AllTuples\n{\n  Tuple&lt;T, MAX_RANGE&gt; y;\n  AllTuples&lt;T, MAX_RANGE - 1&gt; x;\n};\n\ntemplate &lt;typename T&gt;\nclass AllTuples&lt;T, 1&gt;\n{\n  Tuple&lt;T, 1&gt; x;\n};\nAllTuples&lt;float, 10&gt;;\n</code></pre>\n", "AcceptedAnswerId": "6397680", "Title": "Instantiating multiple templates", "CreationDate": "2011-06-18T17:26:33.840", "Id": "6397657", "CommentCount": "2", "LastEditDate": "2011-06-18T17:58:53.763", "PostTypeId": "1", "LastEditorUserId": "368599", "LastActivityDate": "2011-06-18T18:12:57.120", "Score": "1", "OwnerUserId": "368599", "Tags": "<c++><templates>", "AnswerCount": "3"}});