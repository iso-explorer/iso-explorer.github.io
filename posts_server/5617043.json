post_cb({"5617204": {"ParentId": "5617043", "CommentCount": "0", "Body": "<p><code>using</code> only adjusts the name lookup process. It does not import the function into the given scope, or define a new function.</p>\n<p>So, you simply need to define a new <code>virtual</code> override.</p>\n", "OwnerUserId": "153285", "PostTypeId": "2", "Id": "5617204", "Score": "0", "CreationDate": "2011-04-11T05:42:57.920", "LastActivityDate": "2011-04-11T05:42:57.920"}, "5617327": {"ParentId": "5617043", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_5617043_5617327_0\">Which function is used for using keyword, B2::fun() or B2::fun(int) ? (there is no \n   ambiguity for<br>\n  that line )\n  <br> </br></br></p>\n</blockquote>\n<p><strong>From ISO/IEC 14882:2003(E) 7.3.3.12</strong></p>\n<blockquote>\n<p id=\"so_5617043_5617327_1\">When a using-declaration brings names from a base class into a derived class scope, member functions in the derived class override and/or hide member functions with the same name and parameter types in a base class (rather than conflicting).</p>\n</blockquote>\n<pre><code>[Example:\n    struct B { \n        virtual void f(int);\n        virtual void f(char); \n        void g(int); \n        void h(int);\n    };\n\n    struct D : B { \n        using B::f;\n        void f(int);   // OK: D::f(int) overrides B::f(int);\n\n        using B::g; \n        void g(char);  // OK\n\n        using B::h; \n        void h(int);   // OK: D::h(int) hides B::h(int)\n    };\n\n    void k(D* p) {\n        p-&gt;f(1);    //calls  D::f(int)\n        p-&gt;f(\u2019a\u2019);  //calls  B::f(char)  // Notice the call being resolved\n        p-&gt;g(1);    //calls  B::g(int)\n        p-&gt;g(\u2019a\u2019);  //calls  D::g(char)\n    }\n\n\u2014 end example] \n</code></pre>\n<blockquote>\n<p id=\"so_5617043_5617327_2\">[Note: two using-declarations may introduce functions with \n       the same name and the same parameter types. If, for a call to an unqualified \n       function name, function overload resolution selects the functions introduced \n       by such using-declarations, the function call is ill-formed. ]</p>\n</blockquote>\n<p>So, in the example you provided there is no ambiguity at all. Depending up on the parameter passed, call to a method can be decided.</p>\n", "OwnerUserId": "528724", "LastEditorUserId": "528724", "LastEditDate": "2011-04-11T06:11:17.070", "Id": "5617327", "Score": "0", "CreationDate": "2011-04-11T06:00:43.907", "LastActivityDate": "2011-04-11T06:11:17.070"}, "5617147": {"ParentId": "5617043", "CommentCount": "0", "Body": "<p>Ok. I got the answer for the 1st one just based on logical reasoning though. Suppose, standard was accepting inherited methods to resolve <code>pure virtual</code> mechanism then there will be an ambiguity for normal `virtual' functions.</p>\n<p>i.e. Suppose <code>B1::fun()</code> is normal virtual function then, there will be a choice confusion between <code>B1::fun()</code> and <code>B2::fun()</code>. So it's better to avoid considering inherited members at least for <code>virtual</code> mechanism.</p>\n", "OwnerUserId": "514235", "PostTypeId": "2", "Id": "5617147", "Score": "0", "CreationDate": "2011-04-11T05:34:56.983", "LastActivityDate": "2011-04-11T05:34:56.983"}, "5617043": {"CommentCount": "0", "ViewCount": "194", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-04-11T05:19:48.487", "LastActivityDate": "2011-04-11T06:11:17.070", "Title": "Why pure virtual mechanism doesn't consider inherited functions?", "AcceptedAnswerId": "5617327", "LastEditDate": "2017-05-23T12:26:51.687", "Id": "5617043", "Score": "2", "Body": "<p>Before asking, I had refer to this <a href=\"https://stackoverflow.com/questions/3518228/overwriting-pure-virtual-functions-by-using-a-separately-inherited-method\">older question</a>. But I have still queries.</p>\n<pre><code>struct B1 {\n  virtual void fun () = 0;\n};\nstruct B2 {\n  void fun () { cout&lt;&lt;\"B2::fun()\\n\"; }\n  void fun (int i) {}\n};\nstruct D : B1, B2 {\n  using B2::fun;  // This line doesn't help\n};\n\nint main ()\n{\n  B1 *pB1 = new D;  // Error: cannot allocate 'D' because 'B1::fun()' is abstract\n  pB1-&gt;fun();\n}\n</code></pre>\n<ol>\n<li>Any reason for C++ standard not accepting, inherited member functions to resolve <code>pure virtual</code> mechanism ?</li>\n<li>Why <code>using</code> keyword doesn't help resolving this error ? (compiler: linux-64 g++)</li>\n<li>Which function is used for <code>using</code> keyword, <code>B2::fun()</code> or <code>B2::fun(int)</code> ? (there is no ambiguity for that line)</li>\n</ol>\n", "Tags": "<c++><inheritance><pure-virtual>", "OwnerUserId": "514235", "AnswerCount": "5"}, "5617222": {"ParentId": "5617043", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I am by no means a C++ expert programmer but let me have a try:</p>\n<ol>\n<li><p>I think B1 and B2, from the compiler's perspective, are two completely different classes which happen to have a method of the same name in each.  Even when it comes to the scope of D, there is no reason for the compiler to use B2's fun() implementation to implement the fun() from B1.\n(I GUESS we might get something clear if we look into the virtual table mechanism.  There we might see why the B2::fun() doesn't help on the B1's fun().)</p></li>\n<li><p>The \"using\" directive is just making the symbol \"fun\" visible within D's scope.  The \"using\" doesn't append any fun() implementation to class D(but D needs an implementation for B1::fun()).</p></li>\n<li><p>Hmm... The \"using\" directive here doesn't actually \"use\"(or we say \"invoke\") either of the two.  \"using\" just introduces names to the D's scope(AKA making the names visible in D scope, similar to declaring them again).</p></li>\n</ol>\n", "OwnerUserId": "630364", "LastEditorUserId": "630364", "LastEditDate": "2011-04-11T05:58:54.713", "Id": "5617222", "Score": "0", "CreationDate": "2011-04-11T05:45:33.227", "LastActivityDate": "2011-04-11T05:58:54.713"}, "5617121": {"ParentId": "5617043", "PostTypeId": "2", "CommentCount": "2", "Body": "<pre><code>using B2::fun;\n</code></pre>\n<p>Just allows you to use the <code>B2::fun</code> method, but since <code>B1</code> is a abstract class you <strong>must</strong> implement the <em>pure virtual function fun</em> of that class to be able to create its objects.</p>\n", "OwnerUserId": "452307", "LastEditorUserId": "365102", "LastEditDate": "2011-04-11T05:54:45.003", "Id": "5617121", "Score": "2", "CreationDate": "2011-04-11T05:30:43.737", "LastActivityDate": "2011-04-11T05:54:45.003"}, "bq_ids": {"n4140": {"so_5617043_5617327_2": {"section_id": 5503, "quality": 0.8461538461538461, "length": 22}, "so_5617043_5617327_1": {"section_id": 5504, "quality": 0.9285714285714286, "length": 26}}, "n3337": {"so_5617043_5617327_2": {"section_id": 5289, "quality": 0.9230769230769231, "length": 24}, "so_5617043_5617327_1": {"section_id": 5290, "quality": 0.9285714285714286, "length": 26}}, "n4659": {"so_5617043_5617327_2": {"section_id": 6937, "quality": 0.8461538461538461, "length": 22}, "so_5617043_5617327_1": {"section_id": 6938, "quality": 0.8214285714285714, "length": 23}}}});