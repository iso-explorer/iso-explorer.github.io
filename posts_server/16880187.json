post_cb({"bq_ids": {"n4140": {"so_16880187_16880293_3": {"length": 13, "quality": 0.8666666666666667, "section_id": 6146}, "so_16880187_16880293_1": {"length": 16, "quality": 0.64, "section_id": 6146}}, "n3337": {"so_16880187_16880293_3": {"length": 13, "quality": 0.8666666666666667, "section_id": 5909}, "so_16880187_16880293_1": {"length": 16, "quality": 0.64, "section_id": 5909}}, "n4659": {"so_16880187_16880293_3": {"length": 13, "quality": 0.8666666666666667, "section_id": 7642}, "so_16880187_16880293_1": {"length": 16, "quality": 0.64, "section_id": 7642}}}, "16880187": {"ViewCount": "815", "Body": "<p>Please see the code below, why no integral promotion for literal \"1\"? </p>\n<pre><code>long long n = 50;\nlong long a = 1 &lt;&lt; n; // 262144\nlong long b = 1LL &lt;&lt; n; // 1125899906842624\n</code></pre>\n", "AcceptedAnswerId": "16880293", "Title": "Weird integral promotions with left shift operator", "CreationDate": "2013-06-02T05:59:21.953", "Id": "16880187", "CommentCount": "8", "PostTypeId": "1", "LastActivityDate": "2013-06-02T14:44:28.293", "Score": "1", "OwnerUserId": "979013", "Tags": "<c++><c><type-conversion>", "AnswerCount": "3"}, "16880489": {"Id": "16880489", "PostTypeId": "2", "Body": "<p>I suspect that you mixed <em>integral promotions</em> and <em>usual arithmetic conversions</em>. </p>\n<p><em>Integral promotions</em> promote smaller integral operands to <code>int</code> or <code>unsigned int</code> types. Since <code>1</code> is already an <code>int</code>, it cannot be promoted any further.</p>\n<p><em>Usual arithmetic conversions</em> bring operands of binary operators to common type (like it happens in case of binary <code>+</code>, for example), which is then used to perform the actual calculation. I suspect that you expected these conversions to occur in your example, since the right-hand operand has <code>long long</code> type. I.e. you probably expected your <code>1</code> to get converted to <code>long long</code> type as well. However, usual arithmetic conversions are simply not performed for bitwise shift operators. They are performed for additive, multiplicative, relational operators and so on, but not for bitwise operators. This is why <code>1</code> remains an <code>int</code> and the code triggers undefined behavior.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2013-06-02T06:57:26.427", "Score": "2", "CreationDate": "2013-06-02T06:52:09.003", "ParentId": "16880187", "CommentCount": "0", "OwnerUserId": "187690", "LastEditDate": "2013-06-02T06:57:26.427"}, "16880219": {"Id": "16880219", "PostTypeId": "2", "Body": "<p>Here is an equivalent code:</p>\n<pre><code>long long n = 50;\nint x = 1;\nx &lt;&lt;= n; // sizeof(x) is 4, probably. 32 bit. we are shifting it by 50.\nlong long a = x;\n\nlong long z = 1LL;\nz &lt;&lt;= n;\nlong long b = z;\n</code></pre>\n<p>Is it more clear now?</p>\n", "LastEditorUserId": "2289509", "LastActivityDate": "2013-06-02T06:13:30.720", "Score": "2", "CreationDate": "2013-06-02T06:04:06.267", "ParentId": "16880187", "CommentCount": "4", "OwnerUserId": "2289509", "LastEditDate": "2013-06-02T06:13:30.720"}, "16880293": {"Id": "16880293", "PostTypeId": "2", "Body": "<p><em>As requested by <a href=\"https://stackoverflow.com/users/2289509/elazar\">elazar</a>:</em></p>\n<p>The result shown is an acceptable result because the shift invokes <em>undefined behaviour.</em>  That's because the plain <code>1</code> is an <code>int</code>, and shifting an <code>int</code> by a value outside the range <code>0..(sizeof(int) * CHAR_BIT)-1</code> (normally, <code>0..31</code>) leads to undefined behaviour.</p>\n<p>Note that the type of a shift is affected only by the type of the (promoted) left-hand operand. This is (as <a href=\"https://stackoverflow.com/users/962089/chris\">chris</a> noted at one time) different from most other binary operators, such as addition, where the types of both operands influence the type of the result.  Of course, the type of an assignment is controlled by the type of the left operand and the value on the right is coerced to the correct type if necessary (but the value on the right of an assignment is calculated without reference to the type that it will be assigned to, as in this example).</p>\n<h3>ISO/IEC 9899:2011 (C)</h3>\n<blockquote>\n<p id=\"so_16880187_16880293_0\"><strong>\u00a76.5.7 Bitwise shift operators</strong></p>\n<p id=\"so_16880187_16880293_1\">\u00b63 The integer promotions are performed on each of the operands. The\n  type of the result is that of the promoted left operand. If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined.</p>\n</blockquote>\n<h3>ISO/IEC 14822:2011 (C++)</h3>\n<blockquote>\n<p id=\"so_16880187_16880293_2\"><strong>\u00a75.8 Shift operators</strong></p>\n<p id=\"so_16880187_16880293_3\">The operands shall be of integral or unscoped enumeration type and integral promotions are performed. The type of the result is that of the promoted left operand.</p>\n</blockquote>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-06-02T14:44:28.293", "Score": "10", "CreationDate": "2013-06-02T06:16:27.533", "ParentId": "16880187", "CommentCount": "4", "OwnerUserId": "15168", "LastEditDate": "2017-05-23T11:49:59.170"}});