post_cb({"46435142": {"ParentId": "46434964", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>I think function template name is allowed to be the same as something else to allow overloading, while class template name is explicitly disallowed to match something else according to</p>\n<blockquote>\n<p id=\"so_46434964_46435142_0\">14 Templates [temp]</p>\n<ol start=\"5\">\n<li>A class template shall not have the same name as any other template, class, function, variable, enumeration, enumerator, namespace, or type in the same scope (3.3), except as specified in (14.5.5).</li>\n</ol>\n</blockquote>\n<p>[update] the rest of this piece makes me think that the case with function template not causing the same error violates the standard requirements:</p>\n<blockquote>\n<p id=\"so_46434964_46435142_1\">Except that a function template can be overloaded either by non-template functions (8.3.5) with the same name or by other function templates with the same name (14.8.3), <strong>a template name declared in namespace scope or in class\n  scope shall be unique in that scope</strong>.</p>\n</blockquote>\n<p>and VS / clang / gcc seem to disagree on it <a href=\"https://godbolt.org/g/7owRin\" rel=\"nofollow noreferrer\">godbolt</a></p>\n", "OwnerUserId": "7860670", "LastEditorUserId": "7860670", "LastEditDate": "2017-09-26T20:44:40.510", "Id": "46435142", "Score": "3", "CreationDate": "2017-09-26T20:21:32.080", "LastActivityDate": "2017-09-26T20:44:40.510"}, "46434964": {"CommentCount": "5", "AcceptedAnswerId": "46435266", "CreationDate": "2017-09-26T20:09:07.350", "LastActivityDate": "2017-09-26T20:44:40.510", "PostTypeId": "1", "ViewCount": "382", "FavoriteCount": "5", "Title": "Overloading template class with template function", "Id": "46434964", "Score": "13", "Body": "<p>C++ allows to use class and function with the same name in one namespace:</p>\n<pre><code>struct S {};\nvoid S() {}\n</code></pre>\n<p>In this case pure name <code>S</code> means function <code>S</code>. To use struct instead you need to explicitly add <code>struct</code> before name.</p>\n<p>It's also possible to make function template and still use both of them:</p>\n<pre><code>template &lt;class T&gt;\nvoid S() {}\n\nstruct S {};\n</code></pre>\n<p>But using template struct is forbidden</p>\n<pre><code>void S() {}\n\ntemplate &lt;class T&gt;\nstruct S {};\n</code></pre>\n<p>and <a href=\"https://wandbox.org/permlink/qNocmcoPjjoAXYd6\" rel=\"noreferrer\">gives error</a> like this:</p>\n<blockquote id=\"so_46434964_46434964_0\">\n<pre><code>error: redefinition of 'S' as different kind of symbol\n</code></pre>\n</blockquote>\n<p>What is the reason for this? Why not to allow use template struct here? Is there any situation where using explicit keyword <code>struct</code> before <code>S</code> (like for non-template version) could not solve name collision if it was allowed? Maybe there is proposal exist?</p>\n", "Tags": "<c++><templates><overloading>", "OwnerUserId": "3240681", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_46434964_46435266_0": {"section_id": 52, "quality": 0.625, "length": 5}, "so_46434964_46435142_1": {"section_id": 52, "quality": 0.9230769230769231, "length": 24}}, "n3337": {"so_46434964_46435266_0": {"section_id": 47, "quality": 0.625, "length": 5}, "so_46434964_46435142_1": {"section_id": 47, "quality": 0.9230769230769231, "length": 24}}, "n4659": {"so_46434964_46435266_0": {"section_id": 53, "quality": 0.625, "length": 5}, "so_46434964_46435142_1": {"section_id": 53, "quality": 0.9230769230769231, "length": 24}}}, "46435266": {"ParentId": "46434964", "CommentCount": "7", "Body": "<blockquote>\n<p id=\"so_46434964_46435266_0\">C++ allows to use class and function with the same name in one namespace. </p>\n<pre><code>   struct S {};\n   void S() {}\n</code></pre>\n</blockquote>\n<p>Normally when you declare <code>struct S</code>, you can refer to the type in two ways: as <code>S</code> and as <code>struct S</code>. But that's only until you declare something else named <code>S</code>, for example, a function. When you do that, the name of the type is not <code>S</code> any more. It's <code>struct S</code> only. The name <code>S</code> is reserved for the function.</p>\n<p>This is done for compatibility with C. C code uses this device frequently. Unlike C++, C places struct and union tags in a different name space from normal identifiers, and <code>struct S</code> cannot be referred to as simply <code>S</code>.</p>\n<p>So C++, in order to be able to compile C code that uses this device, makes an exception for struct tags that are reused as a different kind of identifier.</p>\n<p>As <code>class</code> is nearly synonymous with <code>struct</code>, this is done for the <code>class</code> keyword too.</p>\n<p>But C has no templates and there's no need to provide backward compatibility for them, so no such exception for class templates is made. </p>\n", "OwnerUserId": "775806", "PostTypeId": "2", "Id": "46435266", "Score": "16", "CreationDate": "2017-09-26T20:29:15.133", "LastActivityDate": "2017-09-26T20:29:15.133"}});