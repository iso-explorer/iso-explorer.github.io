post_cb({"39106798": {"CommentCount": "7", "AcceptedAnswerId": "39106983", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2016-08-23T16:53:10.817", "LastActivityDate": "2016-09-01T21:08:47.470", "LastEditDate": "2016-08-23T17:02:04.077", "ViewCount": "1668", "FavoriteCount": "0", "Title": "Why can the return type of main not be deduced?", "Id": "39106798", "Score": "31", "Body": "<p>As expected, the following fails in C++11 because that language does not have return type deduction for bog standard functions:</p>\n<pre><code>auto main()\n{\n   return 0;\n}\n</code></pre>\n<p>However, C++14 does, so I cannot explain the following error (with equivalent outcomes in GCC trunk, clang 3.8 and Visual Studio 2015):</p>\n<pre><code>error: 'main' must return 'int'\n</code></pre>\n<p>Is there a passage in the standard that I'm not seeing, forbidding return type deduction for <code>main</code>? Or are both compilers non-compliant?</p>\n<p><em>(For what it's worth, I'd never actually do this. <code>int main()</code> for the win\u2026)</em></p>\n", "Tags": "<c++><c++14><return-type-deduction>", "OwnerUserId": "560648", "AnswerCount": "5"}, "39106983": {"ParentId": "39106798", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>Reading <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2016/n4594.pdf\">the C++17 draft</a> \u00a73.6.1/2:</p>\n<blockquote>\n<p id=\"so_39106798_39106983_0\">... and it shall have a declared return type of type <code>int</code>, ...</p>\n</blockquote>\n<p>So yes I would say it's forbidden to use deduction.</p>\n<hr>\n<p>Almost the exact same wording in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\">the last C++14 draft</a> (same section as the C++17 draft):</p>\n<blockquote>\n<p id=\"so_39106798_39106983_1\">It shall have a declared return type of type <code>int</code>, ...</p>\n</blockquote>\n<hr>\n<p>Just a personal reflection on the <em>possible</em> reasoning behind this, after reading comments and other answers. The reasoning return-type deduction is not allowed is (I think) because then the return type isn't known by the compiler until it sees a <code>return</code> statement. It's also not uncommon that other types (that are implicitly convertible to <code>int</code>) might be returned which would make the deduced type wrong. Declaring the return type up-front (either by the normal old-fashioned way, or by using trailing return type) will set the type when the function is declared, and can be checked by the compiler then and there to be correct.</p>\n<p>As for allowing type-aliases, they are just aliases of a type. So allowing e.g.</p>\n<pre><code>typedef int my_type;\nmy_type main() { ... }\n</code></pre>\n<p>is really no different from</p>\n<pre><code>int main() { ... }\n</code></pre>\n</hr></hr>", "OwnerUserId": "440558", "LastEditorUserId": "440558", "LastEditDate": "2016-08-24T04:30:01.243", "Id": "39106983", "Score": "22", "CreationDate": "2016-08-23T17:03:54.570", "LastActivityDate": "2016-08-24T04:30:01.243"}, "39107127": {"ParentId": "39106798", "CommentCount": "7", "Body": "<p>As discussed in various comments, I was indeed missing it in the standard, because what I thought was a copy of the C++14 FDIS was in fact no such thing (but, instead, a marginally older draft), and the word \"declared\" was snuck into the relevant passage after <a href=\"http://wg21.cmeerw.net/cwg/issue1669\" rel=\"nofollow\">CWG 1669</a>.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "39107127", "Score": "3", "CreationDate": "2016-08-23T17:11:41.033", "LastActivityDate": "2016-08-23T17:11:41.033"}, "39106982": {"ParentId": "39106798", "CommentCount": "2", "Body": "<p>From 3.6.1 [basic.start.main]</p>\n<blockquote>\n<p id=\"so_39106798_39106982_0\">1 A program shall contain a global function called main, which is the\n  designated start of the program.... <br/>2 An implementation shall not\n  predefine the main function. This function shall not be overloaded. It\n  shall have a declared return type of type int, but otherwise its type\n  is implementation-defined...</p>\n</blockquote>\n<p>If the standard were to restrict deduction, then I think the verbiage \"declared return type int\" would be it.</p>\n", "OwnerUserId": "27678", "PostTypeId": "2", "Id": "39106982", "Score": "8", "CreationDate": "2016-08-23T17:03:53.883", "LastActivityDate": "2016-08-23T17:03:53.883"}, "39115044": {"ParentId": "39106798", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Many answers have nicely mention the quotes from the standard. But there is another subtle problem with <code>auto</code> as return type.  </p>\n<p>According to C++ standard (<a href=\"https://stackoverflow.com/questions/204476/what-should-main-return-in-c-and-c\">somewhere</a>), the <strong><code>return</code> statement is not mandatory</strong> inside <code>main()</code>. This is explicitly mentioned in Bjarne Stroustrup's <a href=\"http://www.stroustrup.com/bs_faq2.html#void-main\" rel=\"nofollow noreferrer\">website</a>:</p>\n<blockquote>\n<p id=\"so_39106798_39115044_0\">In C++, <code>main()</code> need not contain an explicit <code>return</code> statement. In that case, the value returned is <code>0</code>, meaning successful execution. </p>\n</blockquote>\n<p>Which means below statement is valid:</p>\n<pre><code>auto main () {}\n</code></pre>\n<p>One can assume an implicit <code>return 0;</code> statement just before <code>}</code>. So in such case <code>auto</code> is <em>interpreted as</em> <code>int</code>. However, from technicality of C++14, the <code>auto</code> must be <em>deduced to</em> <code>void</code> because of no return statement! So, \"<code>int</code> vs <code>void</code>\", what to consider?</p>\n<p>IMO this is the caveat, which prevents <code>auto</code> as a return type in a logical sense as well.</p>\n", "OwnerUserId": "514235", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:29:27.657", "Id": "39115044", "Score": "4", "CreationDate": "2016-08-24T05:24:50.420", "LastActivityDate": "2016-08-24T05:24:50.420"}, "bq_ids": {"n4140": {"so_39106798_39106983_1": {"section_id": 7146, "quality": 1.0, "length": 6}, "so_39106798_39106983_0": {"section_id": 7146, "quality": 1.0, "length": 6}, "so_39106798_39106982_0": {"section_id": 7146, "quality": 0.64, "length": 16}, "so_39106798_39107034_2": {"section_id": 5446, "quality": 0.8181818181818182, "length": 9}, "so_39106798_39107034_0": {"section_id": 7146, "quality": 0.9090909090909091, "length": 10}, "so_39106798_39107034_1": {"section_id": 5451, "quality": 0.875, "length": 28}}, "n3337": {"so_39106798_39106983_1": {"section_id": 6890, "quality": 0.8333333333333334, "length": 5}, "so_39106798_39106983_0": {"section_id": 6890, "quality": 0.8333333333333334, "length": 5}, "so_39106798_39107034_0": {"section_id": 6890, "quality": 0.8181818181818182, "length": 9}, "so_39106798_39106982_0": {"section_id": 6890, "quality": 0.6, "length": 15}}, "n4659": {"so_39106798_39107034_2": {"section_id": 6873, "quality": 0.9090909090909091, "length": 10}, "so_39106798_39106983_1": {"section_id": 8647, "quality": 1.0, "length": 6}, "so_39106798_39107034_0": {"section_id": 8647, "quality": 0.9090909090909091, "length": 10}, "so_39106798_39106982_0": {"section_id": 8647, "quality": 0.64, "length": 16}, "so_39106798_39106983_0": {"section_id": 8647, "quality": 1.0, "length": 6}, "so_39106798_39107034_1": {"section_id": 6887, "quality": 0.625, "length": 20}}}, "39107034": {"ParentId": "39106798", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>From 3.6.1/2 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_39106798_39107034_0\">[...]it shall have a <strong>declared return type</strong> of type <code>int</code>, but otherwise its type is implementation-defined.</p>\n</blockquote>\n<p>When <code>auto</code> is used without a trailing return type, the <em>declared return type</em> of a function is still <code>auto</code>, even though the <em>deduced return type</em> can be something else. The difference between <em>declared</em> and <em>deduced</em> isn't spelled out plainly in the standard, but 7.1.6.4/7 may shed some light:</p>\n<blockquote>\n<p id=\"so_39106798_39107034_1\">When [...] a <code>return</code> statement occurs in a function declared with a return type that contains a placeholder type, the deduced return type [...] is determined from the type of its initializer. In the case of a <code>return</code> with no operand or with an operand of type <code>void</code>, the declared return type shall be <code>auto</code> and the deduced return type is <code>void</code>.</p>\n</blockquote>\n<p>My understanding is that with this:</p>\n<pre><code>auto main(){ return 0; }\n</code></pre>\n<p>the <em>declared return type</em> would still be <code>auto</code>, although the <em>deduced return type</em> would be <code>int</code>. As per 3.6.1/2 above, the <em>declared return type</em> of <code>main</code> <strong>must</strong> be <code>int</code>. Therefore, this is ill-formed.</p>\n<p>However, a trailing return type is considered a <em>declared return type</em>. From 7.1.6.4/2:</p>\n<blockquote>\n<p id=\"so_39106798_39107034_2\">If the function declarator includes a <em>trailing-return-type</em> (8.3.5), that <em>trailing-return-type</em> specifies the declared return type of the function.</p>\n</blockquote>\n<pre><code>$ cat a.cpp\nauto main() -&gt; int {}\n$ g++ -Wall -std=c++14 a.cpp\n$\n</code></pre>\n<p><sup>All quotes are identical in both C++14 and C++17.</sup></p>\n", "OwnerUserId": "4885801", "LastEditorUserId": "4885801", "LastEditDate": "2016-08-24T02:31:39.677", "Id": "39107034", "Score": "17", "CreationDate": "2016-08-23T17:07:01.387", "LastActivityDate": "2016-08-24T02:31:39.677"}});