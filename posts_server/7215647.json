post_cb({"bq_ids": {"n4140": {"so_7215647_7372003_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 3299}, "so_7215647_7372003_0": {"length": 17, "quality": 0.7083333333333334, "section_id": 3298}}, "n3337": {"so_7215647_7372003_1": {"length": 21, "quality": 0.9130434782608695, "section_id": 3169}, "so_7215647_7372003_0": {"length": 20, "quality": 0.8333333333333334, "section_id": 3168}}, "n4659": {"so_7215647_7372003_1": {"length": 16, "quality": 0.6956521739130435, "section_id": 4065}}}, "7215647": {"ViewCount": "521", "Body": "<p>In <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3257.pdf\" rel=\"nofollow\">N3257</a> I found an example using <strong>initializing members without a constructor</strong>, which is fine. I guess that is possible, because it is a POD.</p>\n<pre><code>template&lt;typename T&gt;\nstruct adaptor {\n    NonStdContainer&lt;T&gt;* ptr;                // &lt;- data member\n    T* begin() { return ptr-&gt;getFirst(); }\n    T* end() { return ptr-&gt;getLast() + 1; }\n};\nvoid f(NonStdContainer&lt;int&gt;&amp; c) {\n    for (auto i : adaptor&lt;int&gt;{&amp;c})         // &lt;- init\n        { /* ... */ }\n}\n</code></pre>\n<p>When I played around with this example I replaced the <code>*</code> with a <code>&amp;</code>, because I don't like raw pointers:</p>\n<pre><code>template&lt;typename T&gt;\nstruct adaptor {\n    NonStdContainer&lt;T&gt;&amp; ptr;                // &lt;- data member, now REF\n    T* begin() { return ptr-&gt;getFirst(); }\n    T* end() { return ptr-&gt;getLast() + 1; }\n};\nvoid f(NonStdContainer&lt;int&gt;&amp; c) {\n    for (auto i : adaptor&lt;int&gt;{c})         // &lt;- init\n        { /* ... */ }\n}\n</code></pre>\n<p>This was fine and compiled without warning with GCC-4.7.0.</p>\n<p>Then I got curious about the initialization of PODs and what might have changed with C++0x. \nThere I found Bjarnes <a href=\"http://www2.research.att.com/~bs/C++0xFAQ.html#PODs\" rel=\"nofollow\">FAQ</a>. He says there that PODs may contain <strong>pointers</strong>, but no <strong>references</strong>.</p>\n<p>Ops, now I wonder:</p>\n<ul>\n<li><strong>Do I have non-POD-object here, which the compiler can initialize without a constructor anyway</strong> and I just miss which  mechanisms are used here?</li>\n<li>or <strong>Is the GCC-4.7.0 behaving non-std</strong> by letting me initializing the ref this way?</li>\n<li>or <strong>has there been a change in the std since Bjarnes FAQ that also allows references in PODs?</strong></li>\n</ul>\n<p><strong>Update:</strong> I found <strong>aggregates</strong> in the current std (<em>8.5.1 Aggregates [dcl.init.aggr]</em>), but references are not mentioned there, so I am not sure how they relate to this</p>\n", "AcceptedAnswerId": "7372003", "Title": "C++0x Member initialization without a constructor", "CreationDate": "2011-08-27T16:00:01.683", "Id": "7215647", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-08-27T16:05:39.827", "LastEditorUserId": "472245", "LastActivityDate": "2011-09-10T13:27:57.050", "Score": "4", "OwnerUserId": "472245", "Tags": "<pod><c++11><member-initialization>", "AnswerCount": "1"}, "7372003": {"Id": "7372003", "PostTypeId": "2", "Body": "<p>Quoting the standard [dcl.init.aggr]:</p>\n<blockquote>\n<p id=\"so_7215647_7372003_0\">An aggregate is an array or a class (Clause 9) with no user-provided\n  constructors (12.1), no brace-or-equal- initializers for non-static\n  data members (9.2), no private or protected non-static data members\n  (Clause 11), no base classes (Clause 10), and no virtual functions\n  (10.3).</p>\n<p id=\"so_7215647_7372003_1\">When an aggregate is initialized by an initializer list, as speci\ufb01ed\n  in 8.5.4, the elements of the initializer list are taken as\n  initializers for the members of the aggregate, in increasing subscript\n  or member order. Each member is copy-initialized from the corresponding initializer-clause...</p>\n</blockquote>\n<p>That means you have an aggregate here, aggregates can be initialized how you do it. PODs have nothing to do with it, they are really meant for communication with eg. C.</p>\n<p>Copy-initialization of a reference with a variable is certainly legal, because that just means</p>\n<pre><code>T&amp; ref = c;\n</code></pre>\n<blockquote>\n<p id=\"so_7215647_7372003_2\">Do I have non-POD-object here, which the compiler can initialize without a constructor anyway and I just miss which mechanisms are used here?</p>\n</blockquote>\n<p>Yes, the object is non-POD.</p>\n<blockquote>\n<p id=\"so_7215647_7372003_3\">Is the GCC-4.7.0 behaving non-std by letting me initializing the ref this way?</p>\n</blockquote>\n<p>No.</p>\n", "LastActivityDate": "2011-09-10T13:27:57.050", "CommentCount": "2", "CreationDate": "2011-09-10T13:27:57.050", "ParentId": "7215647", "Score": "4", "OwnerUserId": "51831"}});