post_cb({"18150625": {"CommentCount": "4", "ViewCount": "1031", "PostTypeId": "1", "LastEditorUserId": "2006488", "CreationDate": "2013-08-09T15:44:03.373", "LastActivityDate": "2013-08-09T16:36:00.873", "Title": "How to use noexcept operator correctly", "AcceptedAnswerId": "18150932", "LastEditDate": "2013-08-09T15:49:34.827", "Id": "18150625", "Score": "4", "Body": "<p>I've implemented a smart pointer that stores an object of type T with proxy function that calls the internal object's methods:</p>\n<pre><code>template &lt;class Function, class ...Args, class ...Params&gt; \ninline bool call( Function (T::*function)(Args...) const, Params&amp;&amp; ...args ) const noexcept( noexcept( function ));\n</code></pre>\n<p>But I have found a strange problem - when an std::exception is generated in a member function, the program is terminated, even though the proxy function is called within a try block. So my question is: is it a correct way to use noexcept operator, and if not, how should I use it in this case?</p>\n", "Tags": "<c++><c++11><noexcept>", "OwnerUserId": "2037422", "AnswerCount": "1"}, "18150932": {"ParentId": "18150625", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Per C++11 \u00a75.3.7/1:</p>\n<blockquote>\n<p id=\"so_18150625_18150932_0\">The <code>noexcept</code> operator determines whether the evaluation of its operand, which is an unevaluated operand (Clause 5), can throw an exception (15.1).</p>\n</blockquote>\n<p>Evaluating the expression <code>(function)</code> cannot throw an exception, so <code>noexcept(function)</code> evaluates to <code>true</code>. Note that this is <em>not</em> the same as evaluating the expression <code>(*function)(std::forward&lt;Params&gt;(args)...)</code>, <code>noexcept((*function)(std::forward&lt;Params&gt;(args)...))</code> would certainly evaluate to <code>false</code>, since the member function pointer is not qualified <code>noexcept</code>.</p>\n<p><code>noexcept</code> is a qualification on function pointer types like <code>const</code>. Since the function pointer type <code>call</code> accepts is NOT <code>noexcept</code>-qualified, that complicated <code>noexcept(noexcept(...))</code> will always evaluate as <code>noexcept(false)</code>.</p>\n<p>EDIT: The below is incorrect, it's not possible to overload purely on the basis of <code>noexcept</code> qualification of a function pointer since \"An <em>exception-specification</em> is not considered part of a function\u2019s type.\" (\u00a715.4/13)</p>\n<p><s>If you want <code>call</code> to be <code>noexcept</code> when given a <code>noexcept</code>-qualified member function pointer, you need to provide an overload <code>call(R (T::*)() const noexcept, ...)</code>.</s></p>\n", "OwnerUserId": "923854", "LastEditorUserId": "923854", "LastEditDate": "2013-08-09T16:36:00.873", "Id": "18150932", "Score": "4", "CreationDate": "2013-08-09T15:59:40.403", "LastActivityDate": "2013-08-09T16:36:00.873"}, "bq_ids": {"n4140": {"so_18150625_18150932_0": {"section_id": 6120, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_18150625_18150932_0": {"section_id": 5884, "quality": 0.8666666666666667, "length": 13}}, "n4659": {"so_18150625_18150932_0": {"section_id": 7617, "quality": 0.8666666666666667, "length": 13}}}});