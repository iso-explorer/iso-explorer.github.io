post_cb({"bq_ids": {"n4140": {"so_24018164_24018660_5": {"length": 29, "quality": 0.8787878787878788, "section_id": 3890}, "so_24018164_24018660_1": {"length": 4, "quality": 0.8, "section_id": 5054}, "so_24018164_24018660_6": {"length": 17, "quality": 0.7083333333333334, "section_id": 3890}, "so_24018164_24018660_4": {"length": 17, "quality": 0.7083333333333334, "section_id": 3890}, "so_24018164_24018660_3": {"length": 29, "quality": 0.8787878787878788, "section_id": 3890}}, "n3337": {"so_24018164_24018660_6": {"length": 22, "quality": 0.9166666666666666, "section_id": 3750}, "so_24018164_24018660_1": {"length": 4, "quality": 0.8, "section_id": 4851}, "so_24018164_24018660_5": {"length": 25, "quality": 0.7575757575757576, "section_id": 3750}, "so_24018164_24018660_4": {"length": 22, "quality": 0.9166666666666666, "section_id": 3750}, "so_24018164_24018660_3": {"length": 25, "quality": 0.7575757575757576, "section_id": 3750}}, "n4659": {"so_24018164_24018660_6": {"length": 17, "quality": 0.7083333333333334, "section_id": 4776}, "so_24018164_24018660_1": {"length": 4, "quality": 0.8, "section_id": 6475}, "so_24018164_24018660_5": {"length": 29, "quality": 0.8787878787878788, "section_id": 4776}, "so_24018164_24018660_4": {"length": 17, "quality": 0.7083333333333334, "section_id": 4776}, "so_24018164_24018660_3": {"length": 29, "quality": 0.8787878787878788, "section_id": 4776}}}, "24018164": {"ViewCount": "150", "Body": "<p>I need to convert the if else into switch statement, please help:</p>\n<pre><code>if (XMLString::compareString(xmlch_Title, XMLString::transcode(\"abc\")) == 0 ) {\n    out_Config.abc = XMLString::transcode(xmlch_Value);\n} else if (XMLString::compareString(xmlch_Title, XMLString::transcode(\"def\")) == 0 ) {\n    out_Config.def = XMLString::transcode(xmlch_Value);\n} .......\n</code></pre>\n", "AcceptedAnswerId": "24018936", "Title": "how to use boolean expression in switch in C++", "CreationDate": "2014-06-03T14:43:55.827", "Id": "24018164", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-06-03T16:07:02.883", "Score": "0", "OwnerUserId": "1374266", "Tags": "<c++><visual-c++><switch-statement>", "AnswerCount": "3"}, "24018936": {"Id": "24018936", "PostTypeId": "2", "Body": "<p>if you want to factor out the common part, you'll probably need to use an array of struct containing the transcoded string constant and a lambda doing the <em>then</em> operation. Something along the lines of:</p>\n<pre><code>#include &lt;functional&gt;\n\nstruct check_case {\n  const XMLString code;\n  const std::function &lt;void (Config &amp;, const XMLString &amp;)&gt; handler;\n};\n\ncheck_case check_list[2] = {\n  {XMLString::transcode(\"abc\"), [](Config &amp;out_Config, const XMLString &amp;code) { out_Config.abc = code;}},\n  {XMLString::transcode(\"def\"), [](Config &amp;out_Config, const XMLString &amp;code) { out_Config.def = code;}},\n};\n\nfor (auto c : check_list) {\n   if (XMLString::compareString(xmlch_Title,c.code) == 0){ \n     c.handler(out_Config, XMLString::transcode(xmlch_Value));\n     break;\n   }\n}\n</code></pre>\n<p>It's still quite verbose though, and I'm not sure you'd find it more easily readable. Besides, you don't get to cascade your handlers as you could with a normal switch (which was perhaps the original reason for your question).</p>\n<p>Alternatively, you could embed all that in a dedicated class, where it's easier to build a context (the class instance member fields). There it would be easier to cascade methods manually. As above, the readability isn't quite up to par either.</p>\n", "LastActivityDate": "2014-06-03T15:20:48.317", "CommentCount": "2", "CreationDate": "2014-06-03T15:20:48.317", "ParentId": "24018164", "Score": "0", "OwnerUserId": "1769720"}, "24018660": {"Id": "24018660", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_24018164_24018660_0\"><strong>Note:</strong> Using a boolean expression as the condition of a <em>switch</em> would, in your case, be of little use since you then could only have two possible outcomes of the <em>switch-statement</em>:</p>\n<p id=\"so_24018164_24018660_1\">Going to <code>\"case true: \"</code>, or <code>\"case false: \"</code></p>\n</blockquote>\n<hr>\n<p><strong>Introduction</strong></p>\n<p>As stated in the Standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow\">n3797</a>), the condition used with a switch must be implicitly convertiable to either integral, or enumeration, type.</p>\n<blockquote>\n<p id=\"so_24018164_24018660_2\"><code>6.4.2</code>p2 <strong>The switch statement</strong> <code>[stmt.switch]</code></p>\n<blockquote>\n<p id=\"so_24018164_24018660_5\">The condition shall be of integral type, enumeration type, or class type. If of class type, the condition is contextually implicitly converted (Clause 4) to an integral or enumeration type**.  Integral promotions are performed. Any statement within the switch statement can be labeled with one or more case labels as follows:</p>\n<pre><code>case constant-expression:\n</code></pre>\n<p id=\"so_24018164_24018660_6\">where the constant-expression shall be a converted constant expression (5.19) of the promoted type of the switch condition. No two of the case constans in the same switch shall have the same value after conversion to the promoted type of the switch condition.</p>\n</blockquote>\n</blockquote>\n<p><br/> </p>\n<p>What this means is that the theoretical implementation below is ill-formed, since <code>std::string</code> can't implicitly be converted to an integral or enumeration type <em>(1)</em>, and neither is it usable in a <em>constant-expression</em> <em>(2)</em>.</p>\n<pre><code>std::string get_string ();\n</code></pre>\n<p><sup></sup></p>\n<pre><code>switch (get_string ()) {            //          (1)\n  case std::string (\"stack\"): ...;  // &lt;----.\n  case std::string ( \"over\"): ...;  // &lt;----|-- (2)\n  case std::string ( \"flow\"): ...;  // &lt;----'\n}\n</code></pre>\n<p><br/></p>\n<hr>\n<p><strong>Am I completely out of luck?</strong></p>\n<p>Not really, if you were to use a <a href=\"http://en.wikipedia.org/wiki/Hash_function\" rel=\"nofollow\"><em>hashing function</em></a> to generate a <em>hash</em> for the <em>strings</em> involved, you can theoretically use a <em>switch</em>; just be careful about potential collisions of said <em>hashes</em>.</p>\n<p>Also note that there must be an implementation usable in <em>constant-expressions</em> for the <em>case-labels</em>.</p>\n<p>Is it worth writing such complex code to solve this kind of problem? Probably not.</p>\n</hr></hr>", "LastEditorUserId": "1090079", "LastActivityDate": "2014-06-03T15:29:23.943", "Score": "2", "CreationDate": "2014-06-03T15:07:39.800", "ParentId": "24018164", "CommentCount": "0", "OwnerUserId": "1090079", "LastEditDate": "2014-06-03T15:29:23.943"}, "24019871": {"Id": "24019871", "PostTypeId": "2", "Body": "<p>Look at it from a different point of view. Do it in two stages...\nStage 1: Extract the text in the quotes \"abc\" or \"def\"\nStage 2: switch (based on variable from stage 1) and case will provide implementation</p>\n", "LastActivityDate": "2014-06-03T16:07:02.883", "CommentCount": "0", "CreationDate": "2014-06-03T16:07:02.883", "ParentId": "24018164", "Score": "0", "OwnerUserId": "1377381"}});