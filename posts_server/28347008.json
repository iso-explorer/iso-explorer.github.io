post_cb({"28353658": {"ParentId": "28347008", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>The rule of thumb here is that you cannot use in-class member initialization of a member variable if it's <code>static</code> (and not also <code>const int</code>), however there are some exceptions (just none that apply to your case).</p>\n<p>In the C++98 standard, you could only member initialize <code>static const int</code></p>\n<p>In C++11 standard, you can member initialize everything except <code>static</code> (with exception to the C++98 standard).</p>\n<p>You could get around this if your static member was <code>constexpr</code>:</p>\n<p>\u00a7 9.4.2 (November 2014 draft)</p>\n<blockquote>\n<p id=\"so_28347008_28353658_0\">If a non-volatile <strong>const static</strong> data member is of integral or enumeration type, its declaration in the class\n  definition can specify a <em>brace-or-equal-initializer</em> in which every <em>initializer-clause</em> that is an <em>assignment-expression</em>\n  is a constant expression (5.20). A <strong>static</strong> data member of literal type can be declared in the\n  class definition with the <strong>constexpr</strong> specifier; if so, its declaration shall specify a <em>brace-or-equal-initializer</em>\n  in which every <em>initializer-clause</em> that is an <em>assignment-expression</em> is a constant expression. [ <em>Note</em>: In both\n  these cases, the member may appear in constant expressions. \u2014 end note ] The member shall still be defined\n  in a namespace scope if it is odr-used (3.2) in the program and the namespace scope definition shall not\n  contain an <em>initializer</em>.</p>\n</blockquote>\n<p>To explain this snippet a little more clearly:\nIf you want to try to get around things with <code>constexpr</code>, your type must be \"literal\".</p>\n<p>A literal type (\u00a7 3.9.10):</p>\n<ul>\n<li>Has a \"trivial\" destructor</li>\n<li>Has only constant expression constructors</li>\n<li>Has only literal type base classes and data members</li>\n<li>Or is an <a href=\"https://stackoverflow.com/a/27511360/27678\">aggregate type</a></li>\n<li>Or is <code>void</code>, scalar (e.g., <code>int</code>), a reference, or array of literal types</li>\n</ul>\n<p>A destructor is \"trivial\" if:</p>\n<ul>\n<li>It's compiler-generated (i.e. you didn't define one)</li>\n<li>And each non-static member object has a trivial destructor</li>\n</ul>\n<p>Given all of this, you might take a look at your code and think \"Hm, well I could make all my constructors <code>constexpr</code>, and then change <code>static const CColorf blue</code> to <code>static constexpr CColorf blue</code> and I'm good.\"</p>\n<p>However, your class is \"incomplete\" at the time you declare your static. Let's think about the following <a href=\"https://stackoverflow.com/q/6349822/27678\">example</a>:</p>\n<pre><code>class A{\n    private:\n        A member;\n}\n</code></pre>\n<p>Every instance of <code>A</code> now has an instance of <code>A</code>. How many bytes does the compiler allocate for <code>A</code>? It can't tell. Infinitely many, perhaps, due to the recursion. A is <em>incomplete</em> inside it's own class. You have a similar problem of incompleteness. However, let's make it a pointer instead:</p>\n<pre><code>class A{\n    private:\n        A* member;\n}\n</code></pre>\n<p>Now it's easy because <code>A*</code> is a pointer type, which the compiler knows the size of.</p>\n<p>So now you think \"Okay, I'll just make <code>static constexpr CColorf blue</code> a pointer like <code>static constexpr CColorf* blue = new CColorf(0.0f, 0.0f, 1.0f);</code></p>\n<p>But you can't, because the <code>new</code> operator is not <code>constexpr</code>.</p>\n<p>And you can't try <code>const</code> because we already went over why.</p>\n<p>So maybe you think about overloading the <code>new</code> operator to be <code>constexpr</code>, but <a href=\"https://stackoverflow.com/a/21897696/27678\">you can't do that either</a>.</p>\n<p>So you're out of luck. </p>\n", "OwnerUserId": "27678", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:57:00.900", "Id": "28353658", "Score": "3", "CreationDate": "2015-02-05T20:44:53.967", "LastActivityDate": "2015-02-06T14:03:44.577"}, "28347008": {"CommentCount": "9", "ViewCount": "121", "PostTypeId": "1", "LastEditorUserId": "634821", "CreationDate": "2015-02-05T14:51:00.527", "LastActivityDate": "2015-02-06T22:42:00.953", "Title": "Declaring an instance of a class inside this class' declaration and initializing it in-place", "AcceptedAnswerId": "28361540", "LastEditDate": "2015-02-05T14:52:44.413", "Id": "28347008", "Score": "5", "Body": "<p>This is what I have now:</p>\n<pre><code>class CColorf\n{\npublic:\n    CColorf();\n    CColorf(float r, float g, float b, float a = 1.0f);\n\npublic:\n    float r, g, b, a;\n\n// predefined colors\n    // rgb(0.0, 0.0, 1.0)\n    static const CColorf blue;\n};\n</code></pre>\n<p>It works with <code>blue</code> defined in ccolorf.cpp like so:</p>\n<pre><code>CColorf const CColorf::blue = CColorf(0.0f, 0.0f, 1.0f);\n</code></pre>\n<p>And this is what I would like to do:</p>\n<pre><code>class CColorf\n{\n    ...\n\n// predefined colors\n    // rgb(0.0, 0.0, 1.0)\n    static const CColorf blue = CColorf(0.0f, 0.0f, 1.0f);\n};\n</code></pre>\n<p>But it produces a compilation error: </p>\n<blockquote>\n<p id=\"so_28347008_28347008_0\">a static data member with an in-class initializer must have non-volatile const integral type</p>\n</blockquote>\n<p>Is there a way to avoid the need for separate declaration and definition here?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "634821", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_28347008_28347008_0": {"section_id": 7043, "quality": 0.5454545454545454, "length": 6}, "so_28347008_28353658_0": {"section_id": 5908, "quality": 0.9206349206349206, "length": 58}}, "n3337": {"so_28347008_28353658_0": {"section_id": 5680, "quality": 0.9206349206349206, "length": 58}}, "n4659": {"so_28347008_28347008_0": {"section_id": 8540, "quality": 0.5454545454545454, "length": 6}}}, "28361540": {"ParentId": "28347008", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You can't do that.</p>\n<p>The error message implies that you're compiling as C++03, where only constant static members of integral type can be initialised in their declaration; so you can't do this for any class type.</p>\n<p>C++11 relaxes the rules, but there are still restrictions:</p>\n<ul>\n<li>the type must be <em>literal</em>. You could make this type literal by making the constructors <code>constexpr</code>; but</li>\n<li>the type must be <em>complete</em>, and a class isn't complete within its definition (except inside member definitions)</li>\n<li>the member mustn't be <em>odr-used</em>; that is, you can only use it as an <em>rvalue</em> expression, and can't take its address or create a reference to it.</li>\n</ul>\n<p>While the first point can be fixed, and the third would just restrict what you can do with the member, not whether you can define it, the second makes it impossible. You'll have to define the variable in the usual way, outside the class in a single translation unit.</p>\n<p>If you want to keep everything in the class definition, and the value available to help compile-time optimisation, you could define a function rather than a variable</p>\n<pre><code>static CColorf blue() {return CColorf(0.0f, 0.0f, 1.0f);}\n</code></pre>\n", "OwnerUserId": "204847", "LastEditorUserId": "204847", "LastEditDate": "2015-02-06T22:42:00.953", "Id": "28361540", "Score": "1", "CreationDate": "2015-02-06T08:30:22.887", "LastActivityDate": "2015-02-06T22:42:00.953"}});