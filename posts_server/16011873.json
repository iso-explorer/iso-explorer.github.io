post_cb({"bq_ids": {"n4140": {"so_16011873_16012256_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 121}, "so_16011873_16012256_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 68}, "so_16011873_16012256_4": {"length": 9, "quality": 1.0, "section_id": 121}, "so_16011873_16012256_3": {"length": 7, "quality": 1.0, "section_id": 121}, "so_16011873_16012256_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 121}}, "n3337": {"so_16011873_16012256_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 116}, "so_16011873_16012256_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 63}, "so_16011873_16012256_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 116}, "so_16011873_16012256_4": {"length": 9, "quality": 1.0, "section_id": 116}, "so_16011873_16012256_3": {"length": 7, "quality": 1.0, "section_id": 116}}, "n4659": {"so_16011873_16012256_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 125}, "so_16011873_16012256_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 70}, "so_16011873_16012256_0": {"length": 24, "quality": 0.8888888888888888, "section_id": 125}, "so_16011873_16012256_4": {"length": 9, "quality": 1.0, "section_id": 125}, "so_16011873_16012256_3": {"length": 7, "quality": 1.0, "section_id": 125}}}, "16012256": {"Id": "16012256", "PostTypeId": "2", "Body": "<p>A blunt answer is that this just isn't a context where standard allows pack expansion. The full list of allowed context is specified in 14.5.3/4:</p>\n<blockquote>\n<p id=\"so_16011873_16012256_0\">4 A pack expansion consists of a pattern and an ellipsis, the\n  instantiation of which produces zero or more instantiations of the\n  pattern in a list (described below). The form of the pattern depends\n  on the context in which the expansion occurs. Pack expansions can\n  occur in the following contexts:</p>\n<p id=\"so_16011873_16012256_1\">\u2014 In a function parameter pack (8.3.5); the pattern is the\n  parameter-declaration without the ellipsis.</p>\n<p id=\"so_16011873_16012256_2\">\u2014 In a template parameter pack that is a pack expansion (14.1):</p>\n<ul>\n<li><p id=\"so_16011873_16012256_3\">if the template parameter pack is a parameter-declaration; the\n  pattern is the parameter-declaration without the ellipsis;</p></li>\n<li><p id=\"so_16011873_16012256_4\">if the template parameter pack is a type-parameter with a\n  template-parameter-list; the pattern is the corresponding\n  type-parameter without the ellipsis.</p></li>\n</ul>\n<p id=\"so_16011873_16012256_5\">\u2014 In an initializer-list (8.5); the pattern is an initializer-clause.</p>\n<p id=\"so_16011873_16012256_6\">\u2014 In a base-speci\ufb01er-list (Clause 10); the pattern is a base-speci\ufb01er.</p>\n<p id=\"so_16011873_16012256_7\">\u2014 In a mem-initializer-list (12.6.2); the pattern is a\n  mem-initializer.</p>\n<p id=\"so_16011873_16012256_8\">\u2014 In a template-argument-list (14.3); the pattern is a\n  template-argument.</p>\n<p id=\"so_16011873_16012256_9\">\u2014 In a dynamic-exception-speci\ufb01cation (15.4); the pattern is a\n  type-id.</p>\n<p id=\"so_16011873_16012256_10\">\u2014 In an attribute-list (7.6.1); the pattern is an attribute.</p>\n<p id=\"so_16011873_16012256_11\">\u2014 In an alignment-speci\ufb01er (7.6.2); the pattern is the\n  alignment-speci\ufb01er without the ellipsis.</p>\n<p id=\"so_16011873_16012256_12\">\u2014 In a capture-list (5.1.2); the pattern is a capture.</p>\n<p id=\"so_16011873_16012256_13\">\u2014 In a sizeof... expression (5.3.3); the pattern is an identi\ufb01er.</p>\n</blockquote>\n<p>Here is one possible workaround that guarantees that arguments are evaluated in left-to-right order:</p>\n<pre><code>struct expand_aux {\n    template&lt;typename... Args&gt; expand_aux(Args&amp;&amp;...) { }\n};\n\ntemplate&lt;typename... Args&gt;\ninline void expand(Args&amp;&amp;... args)\n{\n    expand_aux  temp { some_function(std::forward&lt;Args&gt;(args))...  };\n}\n</code></pre>\n", "LastActivityDate": "2013-04-15T09:52:29.287", "CommentCount": "0", "CreationDate": "2013-04-15T09:52:29.287", "ParentId": "16011873", "Score": "1", "OwnerUserId": "947836"}, "16011873": {"ViewCount": "789", "Body": "<p>In a variadic template the ... operator expands a parameter pack into a series of comma-separated arguments (in the simplest form). My question is: how come that calling some_function() for multiple arguments comma-separated works and calling it with the ... operator doesn't?</p>\n<p>I'm talking about this code:</p>\n<pre><code>template&lt;typename... Args&gt; inline void expand(Args&amp;&amp;... args) \n{\n   some_function(22),some_function(32); // Works\n   some_function(args)...; // Doesn't work - ERROR\n}\n</code></pre>\n<p>Shouldn't these two lines produce a similar output?</p>\n", "AcceptedAnswerId": "16011941", "Title": "C++11 variadic templates and comma-separated expressions equivalence", "CreationDate": "2013-04-15T09:33:20.017", "Id": "16011873", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-04-15T09:57:17.430", "Score": "4", "OwnerUserId": "2154732", "Tags": "<c++><c++11><variadic-templates>", "AnswerCount": "3"}, "16011941": {"Id": "16011941", "PostTypeId": "2", "Body": "<p>Because in the first case you don't have comma-separated arguments but you are instead using the comma-operator, a totally different beast.</p>\n<p>You can implement the function <code>expand</code> recursively:</p>\n<pre><code>inline void expand() {}\n\ntemplate&lt;typename T, typename... Args&gt;\ninline void expand(T&amp;&amp; head, Args&amp;&amp;... tail)\n{\n    some_function(head);\n    expand(tail...);\n}\n</code></pre>\n", "LastEditorUserId": "542190", "LastActivityDate": "2013-04-15T09:43:31.313", "Score": "5", "CreationDate": "2013-04-15T09:37:28.620", "ParentId": "16011873", "CommentCount": "1", "OwnerUserId": "542190", "LastEditDate": "2013-04-15T09:43:31.313"}, "16012355": {"Id": "16012355", "PostTypeId": "2", "Body": "<p>As said in the other answer, the commas you get by expanding a parameter pack are not the comma oparator, but an argument list. Having an argument list as an expression is obviously an error. Since you don't need the return values of the function, you can try something in the lines of this:</p>\n<pre><code>template &lt;class... T&gt;\nvoid ignore(T&amp;&amp;...) {}\n\ntemplate&lt;typename... Args&gt; inline void expand(Args&amp;&amp;... args) \n{\n   ignore(some_function(args)...); \n}\n</code></pre>\n<p>if however <code>some_function</code> return <code>void</code>, the pack expansion won't work, since you cannot give void \"values\" to a function. You could either return a value or chain each call of <code>some_function</code> with a comma operator:</p>\n<pre><code>template&lt;typename... Args&gt; inline void expand(Args&amp;&amp;... args) \n{\n   ignore( (some_function(args),true)...); \n   //or:\n   bool b[] = {(some_function(args),true)...};\n}\n</code></pre>\n", "LastActivityDate": "2013-04-15T09:57:17.430", "CommentCount": "2", "CreationDate": "2013-04-15T09:57:17.430", "ParentId": "16011873", "Score": "5", "OwnerUserId": "1838266"}});