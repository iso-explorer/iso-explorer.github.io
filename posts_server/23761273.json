post_cb({"bq_ids": {"n4140": {"so_23761273_23761589_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 723}, "so_23761273_23761539_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 5561}, "so_23761273_23761589_3": {"length": 44, "quality": 0.9777777777777777, "section_id": 5561}}, "n3337": {"so_23761273_23761589_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 712}, "so_23761273_23761539_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 5343}, "so_23761273_23761589_3": {"length": 44, "quality": 0.9777777777777777, "section_id": 5343}}, "n4659": {"so_23761273_23761589_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 754}, "so_23761273_23761539_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 7008}, "so_23761273_23761589_3": {"length": 44, "quality": 0.9777777777777777, "section_id": 7008}}}, "23761539": {"Id": "23761539", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_23761273_23761539_0\"><strong>24.2.1/7</strong> Most of the library\u2019s algorithmic templates that operate on data structures have interfaces that use ranges. A range is a pair\n  of iterators that designate the beginning and end of the computation.\n  <strong>A range <code>[i,i)</code> is an empty range</strong>; in general, a range <code>[i,j)</code> refers to the elements in the data structure starting with the element\n  pointed to by <code>i</code> and up to but not including the element pointed to\n  by <code>j</code>.</p>\n</blockquote>\n<p>Emphasis mine.</p>\n<p>Further, the description of <code>erase</code> you cite is not the normative text in the standard. The standard has this to say (Table 100):</p>\n<blockquote>\n<p id=\"so_23761273_23761539_1\"><code>a.erase(q1,q2)</code></p>\n<p id=\"so_23761273_23761539_2\"><em>Effects</em>: Erases the elements in the range [q1, q2).</p>\n</blockquote>\n<p>This doesn't require that <code>q1</code> be dereferenceable. If [q1, q2) is an empty range (per 24.2.1/7), then no elements are in the range, and so none are erased.</p>\n", "LastActivityDate": "2014-05-20T13:43:19.620", "CommentCount": "1", "CreationDate": "2014-05-20T13:43:19.620", "ParentId": "23761273", "Score": "27", "OwnerUserId": "1670129"}, "23761273": {"ViewCount": "2461", "Body": "<p>All over the web I see people use the <a href=\"http://en.wikipedia.org/wiki/Erase-remove_idiom\" rel=\"nofollow noreferrer\">erase/remove idiom</a> for C++ vectors like so:</p>\n<pre><code>#include &lt;vector&gt; // the general-purpose vector container\n#include &lt;iostream&gt;\n#include &lt;algorithm&gt; // remove and remove_if\nint main()\n{\n  // initialises a vector that holds the numbers from 0-9.\n  std::vector&lt;int&gt; v = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\n  // removes all elements with the value 5\n  v.erase( std::remove( v.begin(), v.end(), 5 ), v.end() );\n\n  return 0;\n}\n</code></pre>\n<p>That is, if I want to erase all elements matching some criteria (e.g. the number 5 from a vector of <code>int</code>s), then I use <code>std::remove</code> or <code>std::remove_if</code> in conjunction with <code>vector.erase</code> like so:</p>\n<pre><code>vector.erase( std::remove( vector.begin(), vector.end(), &lt;some_value&gt;), vector.end());\n</code></pre>\n<p>This works nicely in general; <code>std::remove</code> (and <code>remove_if</code>) will copy (or use move semantics in C++11) the elements that are to be deleted over to the end of the vector, so the vector from our previous example will now look like this:</p>\n<blockquote>\n<p id=\"so_23761273_23761273_0\">{ 0, 1, 2, 3, 4, 6, 7, 8, 9, <b>5</b> };</p>\n</blockquote>\n<p>With the element <strong>5</strong> bolded because it's been moved to the end.</p>\n<p>Now, <code>std::remove</code> will return an iterator to it, which we then use in <code>erase</code> to clear the elements out. Nice.</p>\n<h2>But what about the following example?</h2>\n<pre><code>int main()\n{\n  // initialises an empty vector.\n  std::vector&lt;int&gt; v = {};\n\n  // removes all elements with the value 5\n  v.erase( std::remove( v.begin(), v.end(), 5 ), v.end() );\n\n  return 0;\n}\n</code></pre>\n<p>This seems to work as expected (not erasing anything, not segfaulting, etc.) on all platforms I run it on, but I know that just because something is working, doesn't mean it's not undefined behavior.</p>\n<p>The quick <a href=\"http://www.cplusplus.com/reference/vector/vector/erase/\" rel=\"nofollow noreferrer\">reference</a> for <code>vector.erase</code> says this (emphasis mine):</p>\n<pre><code>iterator erase (const_iterator first, const_iterator last);\n</code></pre>\n<p><code>first, last</code> are</p>\n<blockquote>\n<p id=\"so_23761273_23761273_1\">Iterators specifying a range within the vector] to be removed: <code>[first,last)</code>. i.e., the range includes all the elements between <code>first</code> and <code>last</code>, <strong>including the element pointed by first</strong> but not the one pointed by <code>last</code>.\n   Member types <code>iterator</code> and <code>const_iterator</code> are random access iterator types that point to elements.</p>\n</blockquote>\n<h2>So is <code>vector.erase(vector.end(),vector.end())</code> undefined behavior?</h2>\n<p>Here's what the quick reference says about exception safety:</p>\n<blockquote>\n<p id=\"so_23761273_23761273_2\">If the removed elements include the last element in the container, no exceptions are thrown (no-throw guarantee).\n   Otherwise, the container is guaranteed to end in a valid state (basic guarantee).\n   An invalid <code>position</code> or <code>range</code> causes undefined behavior.</p>\n</blockquote>\n<p>So, the answer, at least to me appears to be \"YES\", and <a href=\"https://stackoverflow.com/a/9590202/27678\">this StackOverflow answer</a> seems to support it.</p>\n<h2>Therefore, is the common idiom wrong?</h2>\n<p>Assuming it's undefined behavior, then any call to <code>remove</code> could return an iterator to <code>vector.end()</code> which should be checked before calling <code>vector.erase</code>, and calling remove on an empty vector does seem to return <code>vector.end</code>: (<a href=\"http://ideone.com/7sodQA\" rel=\"nofollow noreferrer\">IDEOne for code below</a>)</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n   vector&lt;int&gt; myInts;\n   auto anIter = std::remove(myInts.begin(),myInts.end(),5);\n   if (anIter == myInts.end())\n      std::cout &lt;&lt; \"iterator = myInts.end()\";\n}\n</code></pre>\n<h2>Finally, my question:</h2>\n<p>Should the actual remove/erase idiom be this?</p>\n<pre><code>auto endOfRangeIterator = std::remove(vector.begin(), vector.end(), &lt;value&gt;);\nif (endOfRangeIterator != vector.end())\n   vector.erase(endOfRangeIterator, vector.end())\n</code></pre>\n", "AcceptedAnswerId": "23761539", "Title": "std::remove with vector::erase and undefined behavior", "CreationDate": "2014-05-20T13:31:37.510", "Id": "23761273", "CommentCount": "16", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:09:20.883", "LastEditorUserId": "-1", "LastActivityDate": "2015-10-24T21:23:24.893", "Score": "24", "OwnerUserId": "27678", "Tags": "<c++><algorithm><c++11><vector><stl>", "AnswerCount": "3"}, "23761589": {"Id": "23761589", "PostTypeId": "2", "Body": "<p>I think the more important in your cite is:</p>\n<blockquote>\n<p id=\"so_23761273_23761589_0\">Iterators specifying a range within the vector] to be removed:\n  [first,last). i.e., the range includes all the elements between first\n  and last, including the element pointed by first <strong>but not the one\n  pointed by last</strong>. Member types iterator and const_iterator are random\n  access iterator types that point to elements.</p>\n</blockquote>\n<p>As we have found in comments, this citation from <a href=\"http://www.cplusplus.com/reference/vector/vector/erase/\" rel=\"nofollow\">cpluspluc.com</a> is incorrect. This will not violate the rules in case of <code>( v.end, v.end)</code> but will be incorrect in case of </p>\n<pre><code>#include &lt;vector&gt;\n\nint main()\n{\n    std::vector&lt;int&gt; v = { 1, 2, 3 };\n\n    v.erase( v.begin(), v.begin());\n}\n</code></pre>\n<p>because statement that contradicts itself with</p>\n<blockquote>\n<p id=\"so_23761273_23761589_1\">the range includes (...), <strong>including</strong> the element pointed by\n  v.begin() <strong>but not the one</strong> pointed by v.begin().</p>\n</blockquote>\n<p>cannot be a valid statement.</p>\n<p>C++ Standard n3337 in <strong>\u00a7</strong> 23.2.2 Sequence containers requirements  Table 100 specifies that</p>\n<p><code>a.erase(q1,q2)</code> returns <code>iterator</code> . And note is: </p>\n<blockquote>\n<p id=\"so_23761273_23761589_2\">Requires: For vector and deque, T shall be MoveAssignable. Effects:\n  <strong>Erases the elements in the range [q1, q2)</strong>.</p>\n</blockquote>\n<p>And this is what it says about the range <code>[i,j)</code> in <strong>\u00a7</strong> 24.2.1/7 Iterator requirements</p>\n<blockquote>\n<p id=\"so_23761273_23761589_3\">Most of the library\u2019s algorithmic templates that operate on data\n  structures have interfaces that use ranges. A range is a pair of\n  iterators that designate the beginning and end of the computation. A\n  range [i,i) is an empty range; in general, <strong>a range [i,j) refers to the</strong>\n<strong>elements in the data structure starting with the element pointed to by</strong>\n<strong>i and up to</strong> <strong>but not including the element pointed to by j</strong>. Range [i,j)\n  is valid if and only if j is reachable from i. The result of the\n  application of functions in the library to invalid ranges is\n  undefined.</p>\n</blockquote>\n<p>Thus to answer your questions</p>\n<blockquote>\n<p id=\"so_23761273_23761589_4\">But what about the following example?</p>\n</blockquote>\n<p>cplusplus.com is wrong in this case</p>\n<blockquote>\n<p id=\"so_23761273_23761589_5\">So is vector.erase(vector.end(),vector.end()) undefined behavior?</p>\n</blockquote>\n<p><strong>No, no undefined behavior is triggered.</strong></p>\n<blockquote>\n<p id=\"so_23761273_23761589_6\">Therefore, is the common idiom wrong?</p>\n</blockquote>\n<p>No, it is correct.</p>\n<blockquote>\n<p id=\"so_23761273_23761589_7\">Should the actual remove/erase idiom be this?</p>\n</blockquote>\n<p>There is no need for this, though it is also fine.</p>\n", "LastEditorUserId": "1141471", "LastActivityDate": "2014-05-20T15:05:30.303", "Score": "4", "CreationDate": "2014-05-20T13:45:51.330", "ParentId": "23761273", "CommentCount": "0", "OwnerUserId": "1141471", "LastEditDate": "2014-05-20T15:05:30.303"}, "23761536": {"Id": "23761536", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_23761273_23761536_0\">So is vector.erase(vector.end(),vector.end()) undefined behavior?</p>\n</blockquote>\n<p>No. Because of the statement right next to the one you emphesized:</p>\n<blockquote>\n<p id=\"so_23761273_23761536_1\">Iterators specifying a range within the vector] to be removed: [first,last). i.e., the range includes all the elements between first and last, including the element pointed by first <strong>but not the one pointed by last</strong>.</p>\n</blockquote>\n<p>So, <code>vector.erase(vector.end(),vector.end())</code> does not attempt to erase <code>vector.end()</code> because it is pointed to by parameter <code>last</code>.</p>\n<p>Granted, this definition is ambiguous and those statements can be interpreted as contradictory. The quoted wording is not used by the standard.</p>\n", "LastEditorUserId": "2079303", "LastActivityDate": "2014-05-20T13:53:46.663", "Score": "4", "CreationDate": "2014-05-20T13:43:17.423", "ParentId": "23761273", "CommentCount": "0", "OwnerUserId": "2079303", "LastEditDate": "2014-05-20T13:53:46.663"}});