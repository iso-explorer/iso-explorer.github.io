post_cb({"25300459": {"Id": "25300459", "PostTypeId": "2", "Body": "<p>You asked:</p>\n<blockquote>\n<p id=\"so_25299995_25300459_0\">Is it true that if some object is initialized, a constructor (possibly trivial default) will be called?</p>\n</blockquote>\n<p>The short answer: No.</p>\n<p>A longer answer: A constructor is called only for objects of class types. For objects of other types, there are no constructors, and hence constructors cannot be called.</p>\n<p>You said:</p>\n<blockquote>\n<p id=\"so_25299995_25300459_1\">I mean that every initialization process (even zero-initialization) means constructor calling.</p>\n</blockquote>\n<p>Objects of class types can be initialized by calling constructors, which can be explicit or implicit. They can also be initialized by other initialization methods. Objects of other types are initialized by directly setting the initial values of memory occupied by them.</p>\n<p>You have already the seen section 8.5 of the draft standard on initialization.</p>\n<p>Details about class constructors can be found in section <strong>12.1 Constructors</strong>.</p>\n<p>Details about class initialization can be found in section <strong>12.6 Initialization</strong>.</p>\n", "LastEditorUserId": "434551", "LastActivityDate": "2014-08-14T06:43:23.553", "Score": "0", "CreationDate": "2014-08-14T05:06:18.673", "ParentId": "25299995", "CommentCount": "2", "LastEditDate": "2014-08-14T06:43:23.553", "OwnerUserId": "434551"}, "25300561": {"Id": "25300561", "PostTypeId": "2", "Body": "<p>I think your answer would be found in 3.6.2, and 8.5 of N3797.</p>\n<p>A constructor is always called on object creation. But initialization of an object is \nmulti-step process.</p>\n<p>I understand that Zero-Initialization is separate and performed as the first step during object initialization, the Constructor (possibly trivial default) is called later </p>\n", "LastActivityDate": "2014-08-14T05:16:41.663", "Score": "0", "CreationDate": "2014-08-14T05:16:41.663", "ParentId": "25299995", "CommentCount": "0", "OwnerUserId": "994983"}, "25299995": {"ViewCount": "136", "Body": "<p>I don't understand what constructor means in C++ formally. I was reading 3.8 clause (Object lifetime, N3797) and come across with the following:</p>\n<blockquote>\n<p id=\"so_25299995_25299995_0\">An object is said to have non-trivial initialization if it is of a\n  class or aggregate type and it or one of its members is initialized by\n  a constructor other than a trivial default constructor.</p>\n</blockquote>\n<p>I would like to understand an initialization in general. I've read section 8.5, N3797. Is it true that if some object is initialized, a constructor (possibly trivial default) will be called? I mean that every initialization process (even zero-initialization) means constructor calling. It would be good if you provide corresponding references to the Standard.</p>\n", "Title": "Understanding constructor concept", "CreationDate": "2014-08-14T04:16:55.650", "LastActivityDate": "2014-08-15T19:27:04.817", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-08-14T04:48:02.767", "OwnerDisplayName": "user2953119", "LastEditorUserId": "1007504", "Id": "25299995", "Score": "3", "Tags": "<c++><constructor><language-lawyer>", "AnswerCount": "6"}, "25301490": {"Id": "25301490", "PostTypeId": "2", "Body": "<p>Basically, whenever you construct a data type in c++, it can happen in one of two ways. You can either be calling a constructor, or you can essentially be copying chunks of memory around. So constructors are not always called.</p>\n<p>In C++, there is a notion of primitives. Integers, doubles, pointers, characters, pointers (to anything) are all primitives. Primitives are data types, but they are not classes. All primitives are safe to copy bitwise. When you create or assign primitives, no constructor is called. All that happens is that some assembly code is generated that copies around some bits.</p>\n<p>With classes it's a little more complicated; the answer is that usually a constructor is called, but not always. In particular, C++11 has the concept of trivial classes. Trivial classes are classes that satisfy several conditions:</p>\n<ol>\n<li>They use the defaults for all the 'special' functions: constructor, destructor, move, copy, assignment.</li>\n<li>They don't have virtual functions.</li>\n<li>All non static members of the class are trivial classes or primitives.</li>\n</ol>\n<p>As far as C++11 is concerned, objects of any class that satisfy this requirement can be treated like chunks of data. When you create such an object, it's constructor will not be called. If you create such an object on the stack (without new), then its destructor will not be called at program termination either, as would normally be called.</p>\n<p>Don't take my word for it though. Check out the <a href=\"http://gcc.godbolt.org/#%7B%22version%22%3A3%2C%22filterAsm%22%3A%7B%22labels%22%3Atrue%2C%22directives%22%3Atrue%2C%22commentOnly%22%3Atrue%7D%2C%22compilers%22%3A%5B%7B%22sourcez%22%3A%22M4FwTgrgxiAECCAoA3o2sCWA7OAPA3GrACYD2EARgDYCmsAnoQL6GKiQywBCKRXAFNjjYADhBABKIqnTpcsALyYsYkIXRMiQ2AUQtEibQFsAhtn5SZCWCfXdYFfgFYJdkwDp5Sp%2BrA0QEGBYsAAM%2BLB6iEAAAA%3D%3D%22%2C%22compiler%22%3A%22%2Fusr%2Fbin%2Fclang%2B%2B%22%2C%22options%22%3A%22%22%7D%5D%7D\" rel=\"nofollow\">assembly generated for the code I wrote</a>. You can see that there are two classes, one is trivial and one is not. The non-trivial class has a call to its constructor in the assembly, the trivial one does not.</p>\n", "LastEditorUserId": "5801", "LastActivityDate": "2014-08-15T19:27:04.817", "Score": "0", "CreationDate": "2014-08-14T06:33:00.380", "ParentId": "25299995", "CommentCount": "6", "LastEditDate": "2014-08-15T19:27:04.817", "OwnerUserId": "1908347"}, "bq_ids": {"n4140": {"so_25299995_25300237_2": {"length": 13, "quality": 1.0, "section_id": 5880}, "so_25299995_25300292_5": {"length": 4, "quality": 1.0, "section_id": 3287}, "so_25299995_25299995_0": {"length": 18, "quality": 1.0, "section_id": 7189}, "so_25299995_25300292_3": {"length": 44, "quality": 0.7719298245614035, "section_id": 361}}, "n3337": {"so_25299995_25300292_5": {"length": 4, "quality": 1.0, "section_id": 3157}, "so_25299995_25300237_2": {"length": 13, "quality": 1.0, "section_id": 5651}, "so_25299995_25300292_2": {"length": 10, "quality": 1.0, "section_id": 355}, "so_25299995_25299995_0": {"length": 18, "quality": 1.0, "section_id": 6933}, "so_25299995_25300292_3": {"length": 44, "quality": 0.7719298245614035, "section_id": 351}, "so_25299995_25300292_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 355}}, "n4659": {"so_25299995_25300237_2": {"length": 7, "quality": 0.5384615384615384, "section_id": 48}, "so_25299995_25299995_0": {"length": 15, "quality": 0.8333333333333334, "section_id": 8697}, "so_25299995_25300292_3": {"length": 44, "quality": 0.7719298245614035, "section_id": 373}}}, "25300292": {"Id": "25300292", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_25299995_25300292_0\">I don't understand what contructor means in C++ formally.</p>\n</blockquote>\n<p>As far as I know, the standard does not explicitly contain a definition of the term \"constructor\". However, \u00a712.1/1 says</p>\n<blockquote>\n<p id=\"so_25299995_25300292_1\">Constructors do not have names. A special declarator syntax is used to declare or define the constructor.\n  The syntax uses:</p>\n<ul>\n<li>an optional <em>decl-specifier-seq</em> in which each <em>decl-specifier</em> is either a <em>function-specifier</em> or <code>constexpr</code>,</li>\n<li>the constructor's class name, and</li>\n<li>a parameter list</li>\n</ul>\n<p id=\"so_25299995_25300292_2\">in that order. In such a declaration, optional parentheses around the constructor class name are ignored.</p>\n</blockquote>\n<p>Thus, if you declare a member function according to this syntax, the function you are declaring is a constructor. In addition,</p>\n<blockquote>\n<p id=\"so_25299995_25300292_3\">The default constructor (12.1), copy constructor and copy assignment operator (12.8), move constructor\n  and move assignment operator (12.8), and destructor (12.4) are special member functions. [ <em>Note:</em> The\n  implementation will implicitly declare these member functions for some class types when the program does\n  not explicitly declare them. The implementation will implicitly define them if they are odr-used (3.2).\n   See 12.1, 12.4 and 12.8. \u2014 <em>end note</em> ] Programs shall not define implicitly-declared special member functions.</p>\n</blockquote>\n<p>(\u00a712/1)</p>\n<p>So there you go---every class has at least three constructors declared, whether implicitly or explicitly; and you can also declare other constructors using the syntax in \u00a712.1/1. The entire set of functions thus declared forms the set of constructors.</p>\n<blockquote>\n<p id=\"so_25299995_25300292_4\">Is it true that if some object is initialized, a constructor (possibly trivial default) will be called? I mean that every initialization process (even zero-initialization) means constructor calling.</p>\n</blockquote>\n<p>No, this is false. For example, <code>int</code> has no constructors. This is despite the fact that you can initialize an <code>int</code> with similar syntax compared to initialization of objects of class type.</p>\n<pre><code>struct Foo {};\nFoo f {}; // calls default constructor\nint i {}; // sets the value of i to 0\n</code></pre>\n<p>Also, zero-initialization never invokes a constructor, but zero-initialization is also never the <em>only</em> step in the initialization of an object.</p>\n<p>If by \"object\" you meant \"object of class type\", it is still not true that a constructor is always called, although three constructors are always declared, as stated above. See \u00a78.5/7 on value initialization:</p>\n<blockquote>\n<p id=\"so_25299995_25300292_5\">To value-initialize an object of type <code>T</code> means:</p>\n<ul>\n<li>if <code>T</code> is a (possibly cv-qualified) class type (Clause 9) with a user-provided constructor (12.1), then the\n  default constructor for <code>T</code> is called (and the initialization is ill-formed if <code>T</code> has no accessible default\n  constructor);</li>\n<li>if <code>T</code> is a (possibly cv-qualified) non-union class type without a user-provided constructor, then the object\n  is zero-initialized and, if <code>T</code>'s implicitly-declared default constructor is non-trivial, that constructor is\n  called.</li>\n<li>if <code>T</code> is an array type, then each element is value-initialized;</li>\n<li>otherwise, the object is zero-initialized.</li>\n</ul>\n</blockquote>\n<p>Therefore, when the default constructor for a non-union class type is trivial and you are value-initializing an object of that type, the constructor really is not called.</p>\n", "LastActivityDate": "2014-08-14T04:48:55.310", "Score": "3", "CreationDate": "2014-08-14T04:48:55.310", "ParentId": "25299995", "CommentCount": "0", "OwnerUserId": "481267"}, "25300237": {"Id": "25300237", "PostTypeId": "2", "Body": "<p>Classes are types:</p>\n<blockquote>\n<p id=\"so_25299995_25300237_0\">A class is a type.</p>\n<p id=\"so_25299995_25300237_1\">\u00a79 [class]</p>\n</blockquote>\n<p>However, not all types are classes.  The standard refers to types which are not class types (scalar types, for example) in \u00a73.9.</p>\n<p>Only class types, however, can have member functions:</p>\n<blockquote>\n<p id=\"so_25299995_25300237_2\">Functions declared in the definition of a class, excluding those declared with a <code>friend</code> specifier, are called member functions of that class.</p>\n<p id=\"so_25299995_25300237_3\">\u00a79.3 [class.mfct]</p>\n</blockquote>\n<p>Constructors are member functions.  Therefore types without constructors can exist (i.e. types that are not class types).  Therefore initialization does not necessarily involve calling a constructor, since non-class types (<code>int</code> for example) may be initialized.</p>\n<p>Note that something does not have to be of class type to be an \"object\":</p>\n<blockquote>\n<p id=\"so_25299995_25300237_4\">An object is a region of storage.</p>\n<p id=\"so_25299995_25300237_5\">\u00a71.8 [intro.object]</p>\n</blockquote>\n<p>Therefore an <code>int</code>, while not being of class type, would be an \"object\".</p>\n", "LastActivityDate": "2014-08-14T04:42:19.217", "Score": "0", "CreationDate": "2014-08-14T04:42:19.217", "ParentId": "25299995", "CommentCount": "0", "OwnerUserId": "1007504"}, "25300199": {"Id": "25300199", "PostTypeId": "2", "Body": "<p>A constructor is special function. It looks like a normal function. It doesn't have return type (though some say the return type is the object of the class) like void, int, char, double, etc. It has same name as name of Class. It runs automatically when object is created.\nIn C++, you don't need new operator to initialize an object. Just declare it and set its attribute. i.e. <code>ClassA object1, object2;</code></p>\n<p><strong>For example</strong></p>\n<pre><code>Class Player{\nint jerseyNo;\n\n//constructor\nPlayer(){\ncout&lt;&lt;\"HELLO\";\n}\n};\n</code></pre>\n<p>In main you can do the following:</p>\n<pre><code>Player nabin;\n</code></pre>\n<p>And you can declare <strong>destructor</strong> as well. Destructor is special function similar to constructor but runs when object is destroyed i.e. when object moves out of scope.</p>\n<p><strong>Example:</strong></p>\n<pre><code>Class Player{\n..\n~Player(){\ncout&lt;&lt;\"Destructor ran\";\n}\n..\n};\n</code></pre>\n<p><strong>P.S</strong> The order of execution of constructor and destructor is reverse.\n<strong>Example:</strong></p>\n<pre><code>Player p1,p2,p3;\n</code></pre>\n<p><strong>The order of their execution</strong></p>\n<pre><code>1. p1's constructor runs\n2. p2's constructor runs\n3. p3's constructor runs\n4. p3's destructor runs\n5. p2's destructor runs\n6. p1's destructor runs\n</code></pre>\n", "LastEditorUserId": "2770850", "LastActivityDate": "2014-08-14T05:54:19.810", "Score": "0", "CreationDate": "2014-08-14T04:38:08.347", "ParentId": "25299995", "CommentCount": "0", "LastEditDate": "2014-08-14T05:54:19.810", "OwnerUserId": "2770850"}});