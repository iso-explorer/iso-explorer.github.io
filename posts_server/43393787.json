post_cb({"bq_ids": {"n4140": {"so_43393787_43394295_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 3257}}, "n3337": {"so_43393787_43394295_0": {"length": 24, "quality": 0.6486486486486487, "section_id": 3129}}, "n4659": {"so_43393787_43394295_0": {"length": 35, "quality": 0.9459459459459459, "section_id": 4015}}}, "43393787": {"ViewCount": "73", "Body": "<p>Can someone give me a reference to the working draft of the C++ international standard more recent than the N4296 of 2014-11-19?</p>\n<p>Or can someone tell me whether the example given there in the 3.2.6.6 clause\n(concerning odr rule) is correct?</p>\n<p>I quote it:</p>\n<pre><code> // translation unit 1:\n    struct X {\n    X(int);\n    X(int, int);\n    };\n    X :: X(int = 0)  {  }\n\n    class D : public X {  };\n    D d2;    // X(int) called by D()\n\n   // translation unit 2:\n   struct X {\n    X(int);\n    X(int, int);\n    };\n   X :: X(int = 0, int = 0)  {  }\n   class D : public X {  };   // X(int, int) called by D();\n                              // D()'s implicit definition\n                              // violates the ODR\n</code></pre>\n<p>I have two questions concerning this example:</p>\n<p>first: </p>\n<p>standard arguments shouldn't be specified in the declaration rather than in the definition? If I give this code to the <code>clang</code> compiler (adding\na trivial <code>main</code> function in one of the two translation units) it complains\non both the constructor definitions, while it compiles silently if I put the\nstandard arguments in the declarations.</p>\n<p>second:</p>\n<p>and indeed IT COMPILES: no ODR violation is signaled at all. Hence how could I modify the code in order that the violation comes in evidence?</p>\n", "Title": "C++ international standard", "CreationDate": "2017-04-13T13:35:44.040", "LastActivityDate": "2017-04-13T14:16:30.263", "CommentCount": "5", "PostTypeId": "1", "ClosedDate": "2017-04-14T04:25:18.123", "Id": "43393787", "Score": "1", "OwnerUserId": "4278083", "Tags": "<c++><one-definition-rule>", "AnswerCount": "1"}, "43394295": {"Id": "43394295", "PostTypeId": "2", "Body": "<p>Every definition is a declaration. Default arguments can be present in any declaration.</p>\n<p>The error given by clang has nothing to do with ODR or default arguments in general. It pertains exclusively to default arguments in default, copy, and move constructors. The fact that one can transform a non-default constructor into a default one post factum, just by adding default arguments, is considered a defect in the standard. See <a href=\"https://stackoverflow.com/questions/18313509/default-argument-gcc-vs-clang\">here</a> for more information. Thus the example should not be valid, but the C++11 standard fails to explicitly make it invalid; clang fixes this. N4296 contains a correction in 8.3.6/6:</p>\n<blockquote>\n<p id=\"so_43393787_43394295_0\">Except for member functions of class templates, the default arguments in a member function definition that\n  appears outside of the class definition are added to the set of default arguments provided by the member\n  function declaration in the class definition; the program is ill-formed if a default constructor (12.1), copy\n  or move constructor, or copy or move assignment operator (12.8) is so declared.</p>\n</blockquote>\n<p>So the example is invalid already in N4296. Not sure if the passage above is a part of the official C++14 standard (some parts of N4296 are not).</p>\n<p>ODR violations are in general not diagnosed. The only way to avoid ODR violations is a strict header file discipline.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2017-04-13T14:16:30.263", "Score": "4", "CreationDate": "2017-04-13T13:58:58.653", "ParentId": "43393787", "CommentCount": "1", "OwnerUserId": "775806", "LastEditDate": "2017-05-23T12:09:51.297"}});