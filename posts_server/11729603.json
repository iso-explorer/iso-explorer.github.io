post_cb({"11729729": {"Id": "11729729", "PostTypeId": "2", "Body": "<p>No.</p>\n<p>When you construct the second object on the same storage location, the lifetime of the previous one ends (\u00a73.8/1):</p>\n<blockquote>\n<p id=\"so_11729603_11729729_0\">[...] The lifetime of an object of type <code>T</code> ends when:</p>\n<ul>\n<li>if <code>T</code> is a class type with a non-trivial destructor (\u00a712.4), the destructor call starts, or</li>\n<li>the storage which the object occupies is reused or released.</li>\n</ul>\n</blockquote>\n<p>When the second object is created, since <code>A</code> has the implicit default constructor, the <code>x</code> member is default-initialized, and thus no initialization is performed (\u00a78.5/6):</p>\n<blockquote>\n<p id=\"so_11729603_11729729_1\">To <em>default-initialize</em> an object of type <code>T</code> means:</p>\n<ul>\n<li><p id=\"so_11729603_11729729_2\">[...]</p></li>\n<li><p id=\"so_11729603_11729729_3\">otherwise, no initialization is performed.</p></li>\n</ul>\n</blockquote>\n<p>And this means the object has indeterminate value (\u00a75.3.4/15):</p>\n<blockquote>\n<p id=\"so_11729603_11729729_4\">A <em>new-expression</em> that creates an object of type <code>T</code> initializes that object as follows:</p>\n<ul>\n<li>If the <em>new-initializer</em> is omitted, the object is <em>default-initialized</em> (\u00a78.5); if no initialization is performed,\n  the object has indeterminate value.</li>\n</ul>\n</blockquote>\n<p>And in case you think that the value is not indeterminate because you previously initialized another object on that storage location: the standard discards that possibility as well by saying the properties of the previous object no longer apply once its lifetime ends (\u00a73.8/3):</p>\n<blockquote>\n<p id=\"so_11729603_11729729_5\">The properties ascribed to objects throughout this International Standard apply for a given object only during its lifetime.</p>\n</blockquote>\n", "LastEditorUserId": "46642", "LastActivityDate": "2012-07-30T21:52:02.267", "Score": "9", "CreationDate": "2012-07-30T21:16:58.180", "ParentId": "11729603", "CommentCount": "14", "OwnerUserId": "46642", "LastEditDate": "2012-07-30T21:52:02.267"}, "bq_ids": {"n4140": {"so_11729603_11729729_4": {"length": 7, "quality": 1.0, "section_id": 6098}, "so_11729603_11729729_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 7189}, "so_11729603_11729729_5": {"length": 11, "quality": 0.8461538461538461, "section_id": 7191}, "so_11729603_11729729_1": {"length": 4, "quality": 1.0, "section_id": 3286}}, "n3337": {"so_11729603_11729729_4": {"length": 7, "quality": 1.0, "section_id": 5864}, "so_11729603_11729729_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 6933}, "so_11729603_11729729_5": {"length": 11, "quality": 0.8461538461538461, "section_id": 6935}, "so_11729603_11729729_1": {"length": 4, "quality": 1.0, "section_id": 3156}}, "n4659": {"so_11729603_11729729_4": {"length": 7, "quality": 1.0, "section_id": 7595}, "so_11729603_11729729_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 8697}, "so_11729603_11729729_5": {"length": 11, "quality": 0.8461538461538461, "section_id": 8700}}}, "11729603": {"ViewCount": "185", "Body": "<p>Say I have the following:</p>\n<pre><code>struct A\n{\n   int x;\n};\n\n//...\nA* aOriginal = new A();  //value construct aOriginal\nassert( aOriginal-&gt;x == 0 );\n\nA* aSecond = new (aOriginal) A;\nassert( aSecond-&gt;x == 0 );\n</code></pre>\n<p>Is the second assert guaranteed to hold, even though <code>aSecond</code> is not value-initialized? Logically, it should, because the memory isn't overwritten, but is it specified by the standard?</p>\n", "AcceptedAnswerId": "11729729", "Title": "Is previously initialize memory guaranteed to persist after a placement new call?", "CreationDate": "2012-07-30T21:07:38.213", "Id": "11729603", "CommentCount": "7", "PostTypeId": "1", "LastActivityDate": "2012-07-30T21:52:02.267", "Score": "7", "OwnerUserId": "673730", "Tags": "<c++><c++11><placement-new>", "AnswerCount": "1"}});