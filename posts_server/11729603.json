post_cb({"11729729": {"ParentId": "11729603", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>No.</p>\n<p>When you construct the second object on the same storage location, the lifetime of the previous one ends (\u00a73.8/1):</p>\n<blockquote>\n<p id=\"so_11729603_11729729_0\">[...] The lifetime of an object of type <code>T</code> ends when:</p>\n<ul>\n<li>if <code>T</code> is a class type with a non-trivial destructor (\u00a712.4), the destructor call starts, or</li>\n<li>the storage which the object occupies is reused or released.</li>\n</ul>\n</blockquote>\n<p>When the second object is created, since <code>A</code> has the implicit default constructor, the <code>x</code> member is default-initialized, and thus no initialization is performed (\u00a78.5/6):</p>\n<blockquote>\n<p id=\"so_11729603_11729729_1\">To <em>default-initialize</em> an object of type <code>T</code> means:</p>\n<ul>\n<li><p id=\"so_11729603_11729729_2\">[...]</p></li>\n<li><p id=\"so_11729603_11729729_3\">otherwise, no initialization is performed.</p></li>\n</ul>\n</blockquote>\n<p>And this means the object has indeterminate value (\u00a75.3.4/15):</p>\n<blockquote>\n<p id=\"so_11729603_11729729_4\">A <em>new-expression</em> that creates an object of type <code>T</code> initializes that object as follows:</p>\n<ul>\n<li>If the <em>new-initializer</em> is omitted, the object is <em>default-initialized</em> (\u00a78.5); if no initialization is performed,\n  the object has indeterminate value.</li>\n</ul>\n</blockquote>\n<p>And in case you think that the value is not indeterminate because you previously initialized another object on that storage location: the standard discards that possibility as well by saying the properties of the previous object no longer apply once its lifetime ends (\u00a73.8/3):</p>\n<blockquote>\n<p id=\"so_11729603_11729729_5\">The properties ascribed to objects throughout this International Standard apply for a given object only during its lifetime.</p>\n</blockquote>\n", "OwnerUserId": "46642", "LastEditorUserId": "46642", "LastEditDate": "2012-07-30T21:52:02.267", "Id": "11729729", "Score": "9", "CreationDate": "2012-07-30T21:16:58.180", "LastActivityDate": "2012-07-30T21:52:02.267"}, "bq_ids": {"n4140": {"so_11729603_11729729_0": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}, "so_11729603_11729729_4": {"section_id": 6098, "quality": 1.0, "length": 7}, "so_11729603_11729729_1": {"section_id": 3286, "quality": 1.0, "length": 4}, "so_11729603_11729729_5": {"section_id": 7191, "quality": 0.8461538461538461, "length": 11}}, "n3337": {"so_11729603_11729729_0": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}, "so_11729603_11729729_4": {"section_id": 5864, "quality": 1.0, "length": 7}, "so_11729603_11729729_1": {"section_id": 3156, "quality": 1.0, "length": 4}, "so_11729603_11729729_5": {"section_id": 6935, "quality": 0.8461538461538461, "length": 11}}, "n4659": {"so_11729603_11729729_5": {"section_id": 8700, "quality": 0.8461538461538461, "length": 11}, "so_11729603_11729729_4": {"section_id": 7595, "quality": 1.0, "length": 7}, "so_11729603_11729729_0": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}}}, "11729603": {"CommentCount": "7", "ViewCount": "185", "CreationDate": "2012-07-30T21:07:38.213", "LastActivityDate": "2012-07-30T21:52:02.267", "Title": "Is previously initialize memory guaranteed to persist after a placement new call?", "AcceptedAnswerId": "11729729", "PostTypeId": "1", "Id": "11729603", "Score": "7", "Body": "<p>Say I have the following:</p>\n<pre><code>struct A\n{\n   int x;\n};\n\n//...\nA* aOriginal = new A();  //value construct aOriginal\nassert( aOriginal-&gt;x == 0 );\n\nA* aSecond = new (aOriginal) A;\nassert( aSecond-&gt;x == 0 );\n</code></pre>\n<p>Is the second assert guaranteed to hold, even though <code>aSecond</code> is not value-initialized? Logically, it should, because the memory isn't overwritten, but is it specified by the standard?</p>\n", "Tags": "<c++><c++11><placement-new>", "OwnerUserId": "673730", "AnswerCount": "1"}});