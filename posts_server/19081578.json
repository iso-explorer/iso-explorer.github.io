post_cb({"19081859": {"Id": "19081859", "PostTypeId": "2", "Body": "<p>If you know the object's to-be address, which is the case for your scenario, then yes you can do that kind of thing. However, it is not well-defined behaviour, so it's most probably <em>not a good idea</em> (and in every case not good design). Although it will probably \"work fine\".</p>\n<p>Using a <code>std::map</code> as suggested in a comment above is cleaner and has no \"ifs\" and \"whens\" of UB attached.</p>\n<p>Despite writing to a known memory address will probably be \"working fine\", an object doesn't exist before the constructor is run, so using any of its members is bad mojo.<br>\nAnything is possible. No compiler will likely do any such thing, but the compiler might for example memset the object's storage with zero before running the constructor, so even if you don't set your ID field, it's still overwritten. You have no way of knowing, since what you're doing is undefined.</br></p>\n", "LastActivityDate": "2013-09-29T18:44:26.903", "CommentCount": "2", "CreationDate": "2013-09-29T18:44:26.903", "ParentId": "19081578", "Score": "1", "OwnerUserId": "572743"}, "19082244": {"Id": "19082244", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_19081578_19082244_0\">Can I set a member variable before constructor call?</p>\n</blockquote>\n<p>No, but you can make a base class with ID that sets ID within its constructor (and throws exception if ID can't be allocated, for example). Derive from that class, and at the moment derived class enter constructor, ID will be already set. You could also manage id generation within another class - either within some kind of global singleton, or you could pass id manager as a first parameter to constructor.</p>\n<pre><code>typedef int Id;\nclass IdObject{\npublic:\n    Id getId() const{\n        return id;\n    }\nprotected:\n    IdManager* getIdManager() ...\n    IdObject()\n    :id(0){\n        IdManager* manager = getIdManager();\n        id = manager-&gt;generateId();\n        if (!id)\n            throw IdException;\n        manager-&gt;registerId(id, this);           \n    }\n    ~IdObject(){\n        if (id)\n            getIdManager()-&gt;unregisterId(id, this);\n    }       \nprivate:\n    Id id;\n    IdObject&amp; operator=(IdObject &amp;other){\n    }\n    IdObject(IdObject &amp;other)\n    :id(0){\n    }\n};\n\nclass DerivedObject: public IdObject{\npublic:\n    DerivedObject(){\n        //at this point, id is set.\n    }\n};\n</code></pre>\n<p>This kind of thing.</p>\n", "LastActivityDate": "2013-09-29T19:22:08.780", "CommentCount": "8", "CreationDate": "2013-09-29T19:22:08.780", "ParentId": "19081578", "Score": "2", "OwnerUserId": "271376"}, "19081578": {"ViewCount": "401", "Body": "<p>I started to implement an ID based memory pool, where every element has an id, which is basically an index in a vector. In this special case I know the index before I construct the object itself so I thought I set the ID before I call the constructor.</p>\n<h2>Some details</h2>\n<p>Allocating an object from an ID based pool is the following:</p>\n<ol>\n<li>allocate a free id from the pool</li>\n<li>get a memory address based on the id value</li>\n<li>construct the object on the memory address</li>\n<li>set the ID member of the object</li>\n</ol>\n<p>and the deallocation is based on that id</p>\n<p>here is the code (thanks jrok):</p>\n<pre><code>#include &lt;new&gt;\n#include &lt;iostream&gt;\n\nstruct X\n{\n  X()\n  {\n    // id come from \"nothing\"\n    std::cout &lt;&lt; \"X constructed with id: \" &lt;&lt; id &lt;&lt; std::endl;\n  }\n  int id;\n};\n\nint main()\n{\n    void* buf = operator new(sizeof(X));\n\n    // can I set the ID before the constructor call\n    ((X*)buf)-&gt;id = 42;\n    new (buf) X;\n    std::cout &lt;&lt; ((X*)buf)-&gt;id;\n}\n</code></pre>\n<h2>EDIT</h2>\n<p>I found a stock solution for this in boost sandbox:\n<a href=\"https://svn.boost.org/svn/boost/sandbox/tokenmap/libs/tokenmap/doc/html/index.html\" rel=\"nofollow\">sandbox Boost.Tokenmap</a></p>\n", "AcceptedAnswerId": "19082038", "Title": "Can I set a member variable before constructor call?", "CreationDate": "2013-09-29T18:17:24.917", "Id": "19081578", "CommentCount": "10", "LastEditDate": "2013-09-30T08:14:07.823", "PostTypeId": "1", "LastEditorUserId": "534381", "LastActivityDate": "2013-09-30T08:14:07.823", "Score": "2", "OwnerUserId": "534381", "Tags": "<c++><memory-management><c++11>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_19081578_19082038_0": {"length": 33, "quality": 0.8461538461538461, "section_id": 7189}, "so_19081578_19082038_5": {"length": 5, "quality": 1.0, "section_id": 7189}, "so_19081578_19082038_2": {"length": 6, "quality": 1.0, "section_id": 7189}, "so_19081578_19082244_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 7040}, "so_19081578_19082038_7": {"length": 10, "quality": 1.0, "section_id": 7193}, "so_19081578_19082038_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 7189}, "so_19081578_19082038_4": {"length": 7, "quality": 0.875, "section_id": 7189}, "so_19081578_19082038_6": {"length": 64, "quality": 0.9014084507042254, "section_id": 7193}, "so_19081578_19082038_1": {"length": 6, "quality": 1.0, "section_id": 7189}}, "n3337": {"so_19081578_19082038_1": {"length": 6, "quality": 1.0, "section_id": 6933}, "so_19081578_19082038_5": {"length": 5, "quality": 1.0, "section_id": 6933}, "so_19081578_19082038_2": {"length": 6, "quality": 1.0, "section_id": 6933}, "so_19081578_19082038_7": {"length": 10, "quality": 1.0, "section_id": 6937}, "so_19081578_19082038_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 6933}, "so_19081578_19082038_4": {"length": 7, "quality": 0.875, "section_id": 6933}, "so_19081578_19082038_0": {"length": 33, "quality": 0.8461538461538461, "section_id": 6933}, "so_19081578_19082038_6": {"length": 67, "quality": 0.9436619718309859, "section_id": 6937}}, "n4659": {"so_19081578_19082038_1": {"length": 6, "quality": 1.0, "section_id": 8697}, "so_19081578_19082038_5": {"length": 5, "quality": 1.0, "section_id": 8701}, "so_19081578_19082038_2": {"length": 5, "quality": 0.8333333333333334, "section_id": 8697}, "so_19081578_19082244_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 8537}, "so_19081578_19082038_7": {"length": 10, "quality": 1.0, "section_id": 8702}, "so_19081578_19082038_3": {"length": 5, "quality": 0.8333333333333334, "section_id": 8697}, "so_19081578_19082038_4": {"length": 7, "quality": 0.875, "section_id": 8697}, "so_19081578_19082038_0": {"length": 29, "quality": 0.7435897435897436, "section_id": 8697}, "so_19081578_19082038_6": {"length": 63, "quality": 0.8873239436619719, "section_id": 8702}}}, "19081683": {"Id": "19081683", "PostTypeId": "2", "Body": "<p>No, you cannot set anything in an object before its constructor is called.  However, you have a couple of choices:</p>\n<ol>\n<li><p>Pass the ID to the constructor itself, so it can store the ID in the object.</p></li>\n<li><p>Allocate extra memory in front of the object being constructed, store the ID in that extra memory, then have the object access that memory when needed.</p></li>\n</ol>\n", "LastActivityDate": "2013-09-29T18:27:47.740", "CommentCount": "2", "CreationDate": "2013-09-29T18:27:47.740", "ParentId": "19081578", "Score": "1", "OwnerUserId": "65863"}, "19082038": {"Id": "19082038", "PostTypeId": "2", "Body": "<p>Yes, you can do what you're doing, but it's really not a good idea. According to the standard, your code invokes <a href=\"http://en.wikipedia.org/wiki/Undefined_behavior\" rel=\"nofollow\">Undefined Behaviour</a>:</p>\n<blockquote>\n<h3>3.8 Object lifetime [basic.life]</h3>\n<p id=\"so_19081578_19082038_0\">The lifetime of an object is a runtime property of the object. <strong>An object is said to have non-trivial initialization\n  if it is of a class or aggregate type and it or one of its members is initialized by a constructor other than a trivial\n  default constructor</strong>. [ Note: initialization by a trivial copy/move constructor is non-trivial initialization. \u2014\n  end note ] <strong>The lifetime of an object of type T begins when:</strong></p>\n<p id=\"so_19081578_19082038_1\">\u2014 <strong>storage with the proper alignment and size for type T is obtained, and</strong></p>\n<p id=\"so_19081578_19082038_2\">\u2014 <strong>if the object has non-trivial initialization, its initialization is complete</strong>.</p>\n<p id=\"so_19081578_19082038_3\">The lifetime of an object of type T ends when:</p>\n<p id=\"so_19081578_19082038_4\">\u2014 if T is a class type with a non-trivial destructor (12.4), the destructor call starts, or</p>\n<p id=\"so_19081578_19082038_5\">\u2014 the storage which the object occupies is reused or released.</p>\n<p id=\"so_19081578_19082038_6\"><strong>Before the lifetime of an object has started but after the storage which the object will occupy has been\n  allocated</strong> or, after the lifetime of an object has ended and before the storage which the object occupied is\n  reused or released, <strong>any pointer that refers to the storage location where the object will be or was located\n  may be used but only in limited ways</strong>. For an object under construction or destruction, see 12.7. Otherwise,\n  such a pointer refers to allocated storage (3.7.4.2), and using the pointer as if the pointer were of type void*,\n  is well-defined. Such a pointer may be dereferenced but the resulting lvalue may only be used in limited\n  ways, as described below. <strong>The program has undefined behavior if:</strong></p>\n<p id=\"so_19081578_19082038_7\">\u2014 <strong>the pointer is used to access a non-static data member or call a non-static member function of the\n  object</strong></p>\n</blockquote>\n<p>When your code invokes Undefined Behaviour, the implementation is allowed to do anything it wants to. In most cases nothing will happen - and if you're lucky your compiler will warn you - but occasionally the result will be unexpectedly catastrophic.</p>\n<p>You describe a pool of N objects of the same type, using a contiguous array as the underlying storage. Note that in this scenario you do not need to store an integer ID for each allocated object - if you have a pointer to the allocated object, you can derive the ID from the offset of the object within the array like so:</p>\n<pre><code>struct Object\n{\n};\n\nconst int COUNT = 5; // allow enough storage for COUNT objects\n\nchar storage[sizeof(Object) * COUNT];\n\n// interpret the storage as an array of Object\nObject* pool = static_cast&lt;Object*&gt;(static_cast&lt;void*&gt;(storage));\n\nObject* p = pool + 3; // get a pointer to the third slot in the pool\nint id = p - pool; // find the ID '3' for the third slot\n</code></pre>\n", "LastEditorUserId": "1690864", "LastActivityDate": "2013-09-29T20:48:00.363", "Score": "1", "CreationDate": "2013-09-29T19:01:06.797", "ParentId": "19081578", "CommentCount": "3", "OwnerUserId": "1690864", "LastEditDate": "2013-09-29T20:48:00.363"}, "19082295": {"Id": "19082295", "PostTypeId": "2", "Body": "<p>Is there a reason you want to do this before the constructor call? </p>\n<blockquote>\n<p id=\"so_19081578_19082295_0\">Allocating an object from an ID based pool is the following:</p>\n<pre><code>1) allocate a free id from the pool\n2) get a memory address based on the id value\n3) construct the object on the memory address\n4) set the ID member of the object and the deallocation is based on that id\n</code></pre>\n</blockquote>\n<p>According to your steps, you are setting the ID after the constructor.</p>\n<blockquote>\n<p id=\"so_19081578_19082295_1\">so I thought I set the ID before I call the constructor.</p>\n</blockquote>\n<p>I hate to be blunt, but you need to have a better reason than that to wade into the undefined behaviour territory. Remember, as programmers, there is a lot we're learning all the time and unless there is absolutely no way around it, we need to stay away from minefields, undefined behavior being one of them.</p>\n<p>As other people have pointed out, yes you can do it, but that's like saying you can do <code>rm -rf /</code> as root. Doesn't mean you should :)</p>\n<blockquote>\n<p id=\"so_19081578_19082295_2\">C makes it easy to shoot yourself in the foot. C++ makes it harder, but when you do, you blow away your whole leg! \u2014 Bjarne Stroustrup </p>\n</blockquote>\n", "LastActivityDate": "2013-09-29T19:28:02.167", "CommentCount": "2", "CreationDate": "2013-09-29T19:28:02.167", "ParentId": "19081578", "Score": "1", "OwnerUserId": "13760"}});