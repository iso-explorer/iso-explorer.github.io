post_cb({"bq_ids": {"n4140": {"so_40658511_40658720_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 7132}}, "n3337": {"so_40658511_40658720_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 6876}}, "n4659": {"so_40658511_40658720_0": {"length": 25, "quality": 0.9615384615384616, "section_id": 8633}}}, "40658511": {"ViewCount": "255", "Body": "<p>Consider following program:</p>\n<pre><code>struct S {\n    using T = float;\n    operator T() { return 9.9f; }\n};\nint main() {\n    S m;\n    S::T t = m;\n    t = m.operator T(); // Is this correct ?\n}\n</code></pre>\n<p>The program compiles fine in g++ ( See live demo <a href=\"http://coliru.stacked-crooked.com/a/f94bed9444a2dd46\" rel=\"nofollow noreferrer\"><strong><em>here</em></strong></a> )</p>\n<p>But it fails in compilation in clang++, MSVC++ &amp; Intel C++ compiler</p>\n<p>clang++ gives following errors ( See live demo <a href=\"http://coliru.stacked-crooked.com/a/48b2e0746a27f9e3\" rel=\"nofollow noreferrer\"><strong><em>here</em></strong></a> )</p>\n<pre><code>main.cpp:8:20: error: unknown type name 'T'; did you mean 'S::T'?\n    t = m.operator T(); // Is this correct ?\n                   ^\n                   S::T\nmain.cpp:2:11: note: 'S::T' declared here\n    using T = float;\n</code></pre>\n<p>MSVC++ gives following errors ( See live demo <a href=\"http://rextester.com/FSZ10044\" rel=\"nofollow noreferrer\"><strong><em>here</em></strong></a> )</p>\n<pre><code>source_file.cpp(8): error C2833: 'operator T' is not a recognized operator or type\nsource_file.cpp(8): error C2059: syntax error: 'newline'\n</code></pre>\n<p>Intel C++ Compiler also rejects this code ( See live demo <a href=\"https://godbolt.org/g/8b5F4z\" rel=\"nofollow noreferrer\"><strong><em>here</em></strong></a> )</p>\n<p><strong>So, the question is which compiler is right here ? Is g++  incorrect here or other 3 compilers are incorrect here ? What C++ standard says about this ?</strong></p>\n", "AcceptedAnswerId": "40658720", "Title": "cast operator function compiles fine in g++ but not in other compilers. Why?", "CreationDate": "2016-11-17T15:14:32.600", "Id": "40658511", "CommentCount": "1", "PostTypeId": "1", "ClosedDate": "2016-11-17T15:50:40.290", "LastActivityDate": "2016-11-17T15:31:06.893", "Score": "10", "OwnerUserId": "3777958", "Tags": "<c++><visual-c++><g++><language-lawyer><clang++>", "AnswerCount": "1"}, "40658720": {"Id": "40658720", "PostTypeId": "2", "Body": "<p><a href=\"http://eel.is/c++draft/basic.lookup.classref#7\" rel=\"nofollow noreferrer\">[basic.lookup.classref]/7</a>:</p>\n<blockquote>\n<p id=\"so_40658511_40658720_0\">If the <em>id-expression</em> is a <em>conversion-function-id</em>, <strong>its <em>conversion-type-id</em> is first looked up in the class of the object expression and the name, if found, is used</strong>. Otherwise it is looked up in the context of the entire\n  <em>postfix-expression</em>. In each of these lookups, only names that denote types or templates whose specializations are types are considered. [ <em>Example</em>:</p>\n<pre><code>struct A { };\nnamespace N {\n  struct A {\n    void g() { }\n    template &lt;class T&gt; operator T();\n  };\n}\n\nint main() {\n  N::A a;\n  a.operator A();  // calls N::A::operator N::A\n}\n</code></pre>\n<p id=\"so_40658511_40658720_1\">\u2014 <em>end example</em>]</p>\n</blockquote>\n<p>This indicates that the example could be fine, although in the above example, <code>A</code> has previously been declared as a type name, visible to <code>main</code>. </p>\n<p>This was discussed in <a href=\"http://wg21.link/cwg156\" rel=\"nofollow noreferrer\">core issue 156</a>, filed all the way back in 1999:</p>\n<blockquote>\n<p id=\"so_40658511_40658720_2\">How about:</p>\n<pre><code>struct A { typedef int T; operator T(); };\nstruct B : A { operator T(); } b;\nvoid foo() {\n  b.A::operator T(); // 2) error T is not found in the context\n                     // of the postfix-expression?\n}\n</code></pre>\n<p id=\"so_40658511_40658720_3\">Is this interpretation correct? Or was the intent for this to be an\n  error only if <code>T</code> was found in both scopes and referred to different\n  entities?</p>\n<p id=\"so_40658511_40658720_4\"><strong>Erwin Unruh: The intent was that you look in both contexts. If you find it only once, that's the symbol.</strong> If you find it in both, both symbols must be \"the same\" in some respect. (If you don't find it, its an error).</p>\n</blockquote>\n<p>So I'd say that Clang is wrong: the intent, as expressed in the wording to some extent, is that we find <code>T</code>, even if only in the class.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2016-11-17T15:31:06.893", "Score": "8", "CreationDate": "2016-11-17T15:24:35.113", "ParentId": "40658511", "CommentCount": "7", "OwnerUserId": "3647361", "LastEditDate": "2016-11-17T15:31:06.893"}});