post_cb({"29683381": {"ViewCount": "534", "Body": "<p>To start with, I have a struct with one value with a default value</p>\n<pre><code>struct S {\n    int a = 1;\n};\n</code></pre>\n<p>This type can be default constructed when it is non-const / non-constexpr by both gcc and clang.  Under both, <code>std::is_pod&lt;S&gt;::value</code> is <code>false</code>.  The weird behavior is as follows:</p>\n<pre><code>S s1; // works under both\nconst S s2{}; // works under both\nconst S s3; // only works in gcc, clang wants a user-provided constructor\n</code></pre>\n<p>None of the following attempts makes a difference to clang:</p>\n<pre><code>struct S {\n    int a = 1;\n    constexpr S() = default; // defaulted ctor\n    virtual void f() { } // virtual function, not an aggregate\n  private:\n    int b = 2; // private member, really not an aggregate\n};\n</code></pre>\n<p>The only thing I can do that makes this work is to add <code>constexpr S() { }</code> explicitly.  It seems really wrong to me that <code>const S s;</code> fails while <code>const S s{};</code> especially when the type is not an aggregate.</p>\n<p>The standard makes me think that Clang is right<br/>\n<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">N4296</a>: 8.5/7</p>\n<blockquote>\n<p id=\"so_29683381_29683381_0\">If a program calls for the default initialization of an object of a\n  const-qualified type T, T shall be a class type with a user-provided\n  default constructor</p>\n</blockquote>\n<p>So why does gcc allow this, and is <code>S{};</code> not default initializing, even when the type is not a POD or an aggregate?</p>\n", "AcceptedAnswerId": "29683772", "Title": "const T{}; works, const T; fails when T is a non-POD,", "CreationDate": "2015-04-16T18:43:28.703", "Id": "29683381", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-03-20T10:44:03.853", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-20T10:44:03.853", "Score": "24", "OwnerUserId": "1013719", "Tags": "<c++><gcc><clang><language-lawyer><c++14>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_29683381_29683772_3": {"length": 4, "quality": 1.0, "section_id": 3287}, "so_29683381_29683772_2": {"length": 6, "quality": 1.0, "section_id": 3325}, "so_29683381_29683381_0": {"length": 11, "quality": 1.0, "section_id": 3286}, "so_29683381_29683772_0": {"length": 5, "quality": 1.0, "section_id": 3291}}, "n3337": {"so_29683381_29683772_3": {"length": 4, "quality": 1.0, "section_id": 3157}, "so_29683381_29683772_2": {"length": 6, "quality": 1.0, "section_id": 3195}, "so_29683381_29683381_0": {"length": 11, "quality": 1.0, "section_id": 3156}, "so_29683381_29683772_0": {"length": 5, "quality": 1.0, "section_id": 3161}}, "n4659": {"so_29683381_29683381_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 382}, "so_29683381_29683772_2": {"length": 6, "quality": 1.0, "section_id": 4091}, "so_29683381_29683772_0": {"length": 5, "quality": 1.0, "section_id": 4053}}}, "29683948": {"Id": "29683948", "PostTypeId": "2", "Body": "<p>So it looks like gcc is basing this on <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#253\" rel=\"nofollow\">DR 253</a> even though this is not resolved yet. We can see this from the the following <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=60284\" rel=\"nofollow\">gcc bug report</a> which says:</p>\n<blockquote>\n<p id=\"so_29683381_29683948_0\">This is by design, because as DR 253 shows, the normative standard is flawed.</p>\n</blockquote>\n<p>and the <a href=\"https://gcc.gnu.org/viewcvs/gcc?view=revision&amp;revision=179170\" rel=\"nofollow\">gcc change that brought this into effect</a> says:</p>\n<blockquote>\n<p id=\"so_29683381_29683948_1\">Core 234 - allow const objects with no initializer or\n      user-provided default constructor if the defaulted constructor\n      initializes all the subobjects.</p>\n</blockquote>\n<p>So technically <code>clang</code> is correct and <code>gcc</code> is not conformant but it seems like they believe <code>DR 253</code> will be resolved in their favor. This makes complete sense if the main concern is <em>indeterminate initial value</em> which as far as I can tell it is. This change is documented in <a href=\"https://gcc.gnu.org/gcc-4.6/changes.html\" rel=\"nofollow\">gcc 4.6 release notes</a>:</p>\n<blockquote>\n<p id=\"so_29683381_29683948_2\">In 4.6.0 and 4.6.1 G++ no longer allows objects of const-qualified\n  type to be default initialized unless the type has a user-declared\n  default constructor. In 4.6.2 G++ implements the proposed resolution\n  of DR 253, so default initialization is allowed if it initializes all\n  subobjects. Code that fails to compile can be fixed by providing an\n  initializer e.g.</p>\n<pre><code>struct A { A(); };\nstruct B : A { int i; };\nconst B b = B();\n</code></pre>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2015-04-23T14:40:24.130", "Score": "5", "CreationDate": "2015-04-16T19:11:58.887", "ParentId": "29683381", "CommentCount": "0", "OwnerUserId": "1708801", "LastEditDate": "2015-04-23T14:40:24.130"}, "29683772": {"Id": "29683772", "PostTypeId": "2", "Body": "<pre><code>const S s3;\n</code></pre>\n<p>Is covered by [dcl.init]/12:</p>\n<blockquote>\n<p id=\"so_29683381_29683772_0\">If no initializer is specified for an object, the object is default-initialized.</p>\n</blockquote>\n<p>Thus, as required by your quote, a user-provided default constructor must be present. Adding one like so</p>\n<pre><code>struct S {\n    int a = 1;\n    constexpr S(){}\n};\n</code></pre>\n<p>then <a href=\"http://coliru.stacked-crooked.com/a/540d422344e281f4\" rel=\"noreferrer\">makes the declaration compile fine</a>.</p>\n<blockquote>\n<p id=\"so_29683381_29683772_1\">[..] especially when the type is not an aggregate.</p>\n</blockquote>\n<p><code>S</code> <strong>is an aggregate</strong> in your case, and the reason why <code>const S s{}</code> is valid. Aggregate initialization is applied for <code>const S s{}</code>, and everything's fine.<br>\nIf <code>S</code> is not an aggregate, </br></p>\n<blockquote>\n<p id=\"so_29683381_29683772_2\">List-initialization of an object or reference of type T is defined as\n  follows:</p>\n<ul>\n<li>If <code>T</code> is an aggregate, aggregate initialization is performed (8.5.1).</li>\n<li><strong>Otherwise, if the initializer list has no elements and <code>T</code> is a class type with a default constructor, the object is value-initialized.</strong></li>\n</ul>\n</blockquote>\n<p>Now consider the definition of value initialization:</p>\n<blockquote>\n<p id=\"so_29683381_29683772_3\">To <em>value-initialize</em> an object of type <code>T</code> means:</p>\n<ul>\n<li>if <code>T</code> is a\n  (possibly cv-qualified) class type (Clause 9) with either no default\n  constructor (12.1) or a default constructor that is user-provided or deleted, then the object is default-initialized; </li>\n<li><strong>if <code>T</code> is a (possibly\n  cv-qualified) class type without a user-provided or deleted default\n  constructor, then\n       the object is zero-initialized and the semantic constraints for default-initialization are checked</strong>, and if\n      <code>T</code> has a non-trivial default constructor, the object is default-initialized;</li>\n</ul>\n</blockquote>\n<p>The default ctor is indeed nontrivial since a member has got an initializer ([class.ctor]/4.9), but that's irrelevant since the constraints are checked eitherway. Hence default-initialization it is, and the line</p>\n<pre><code>const S s{};\n</code></pre>\n<p>Is just as valid (or invalid!) as</p>\n<pre><code>const S t;\n</code></pre>\n<blockquote>\n<p id=\"so_29683381_29683772_4\">So why does gcc allow this</p>\n</blockquote>\n<p>Well:</p>\n<ol>\n<li><p>Speaking in terms of the current standard, GCC is not compliant; See above.</p></li>\n<li><p>There is an active CWG issue, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#253\" rel=\"noreferrer\"><strong>#253</strong></a>, created fifteen years ago, that covers a similar scenario. The final note on this one from a 2011 meeting says</p>\n<blockquote>\n<p id=\"so_29683381_29683772_5\">If the implicit default constructor initializes all subobjects, no initializer should be required.</p>\n</blockquote>\n<p>That is the case with the implicit default constructor for <code>S</code>, and this would make all your lines valid.</p></li>\n<li><p>GCC developers (e.g. <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=57820#c5\" rel=\"noreferrer\">here</a>) implied that since the committee basically agreed upon that above resolution, <strong>the current behavior of GCC is feasible and should not be adjusted</strong>. So one could well argue that GCC is right and the standard is broken. </p></li>\n</ol>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2015-04-16T19:20:26.923", "Score": "16", "CreationDate": "2015-04-16T19:02:58.317", "ParentId": "29683381", "CommentCount": "7", "OwnerUserId": "3647361", "LastEditDate": "2015-04-16T19:20:26.923"}});