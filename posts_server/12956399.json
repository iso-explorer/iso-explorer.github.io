post_cb({"12956515": {"ParentId": "12956399", "CommentCount": "0", "CreationDate": "2012-10-18T14:03:02.957", "OwnerUserId": "1617405", "PostTypeId": "2", "Id": "12956515", "Score": "0", "Body": "<p>This is polymorphism. You should write <code>virtual void f()</code> into your base class A and write <code>void f()</code> into inheritor class B</p>\n", "LastActivityDate": "2012-10-18T14:03:02.957"}, "12956399": {"CommentCount": "4", "ViewCount": "96", "CreationDate": "2012-10-18T13:56:36.357", "LastActivityDate": "2012-10-18T14:19:39.547", "Title": "what happened when we try to access downcasted pointer with and without virtual function", "AcceptedAnswerId": "12956638", "PostTypeId": "1", "Id": "12956399", "Score": "1", "Body": "<p>Here are 2 codes\nfirst:</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nclass A{\n  public:\n     virtual void  f()\n    {\n      cout&lt;&lt;\"A\"&lt;&lt;endl;\n    }\n};\nclass B: public A{\n  public:\n    virtual void  f()\n    {\n      cout&lt;&lt;\"B\"&lt;&lt;endl;\n    }\n};\nint main()\n{\n  A* pa=new A();\n  B* pb=new B();\n  A* upCastpa= static_cast&lt;A*&gt;(pb);\n  B* downCastpb=static_cast&lt;B*&gt;(pa);\n  upCastpa-&gt;f();\n  downCastpb-&gt;f();\n  return 1;\n}\n</code></pre>\n<p>one display</p>\n<pre><code>B\nA\n</code></pre>\n<p>Therefore I think what really matters is the objected the pointer pointing to.\nHowever, if I remove virtual form A::f(), like this;</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nclass A{\n  public:\n     void  f()\n    {\n      cout&lt;&lt;\"A\"&lt;&lt;endl;\n    }\n};\nclass B: public A{\n  public:\n    virtual void  f()\n    {\n      cout&lt;&lt;\"B\"&lt;&lt;endl;\n    }\n};\nint main()\n{\n  A* pa=new A();\n  B* pb=new B();\n  A* upCastpa= static_cast&lt;A*&gt;(pb);\n  B* downCastpb=static_cast&lt;B*&gt;(pa);\n  upCastpa-&gt;f();\n  downCastpb-&gt;f();\n  return 1;\n}\n</code></pre>\n<p>The code will displayed\n    A\n    \"stop\"\nWhat happened? If the important thing is the objected the pointer pointing to.</p>\n<p>it suppose to display\n   A\n   B\ninstead of corrupted.</p>\n<p>what happened?</p>\n<p>I really appreciate any advice or instruction. Thanks a lot.  </p>\n", "Tags": "<c++><inheritance><casting><virtual>", "OwnerUserId": "1584007", "AnswerCount": "3"}, "12956538": {"ParentId": "12956399", "CommentCount": "1", "CreationDate": "2012-10-18T14:04:18.037", "OwnerUserId": "694976", "PostTypeId": "2", "Id": "12956538", "Score": "0", "Body": "<p>By removing the first <code>virtual</code>, you effectively prevent it from going into the vtable. This means class <code>A</code>'s vtable is now empty. But, because class <code>B</code> does have a virtual function, it has an entry in its vtable.</p>\n<p>So, when you downcast an <code>A*</code> into a <code>B*</code>, and then call <code>f</code> through it, the call will be looking for a function <code>f</code> in an empty vtable. Not finding it, it's going to complain about code corruption.</p>\n<p>In practice, in the general case, your example 1 won't work either. The reason it does work in this particular case is that the vtable for <code>A</code> and <code>B</code> are exactly the same.</p>\n", "LastActivityDate": "2012-10-18T14:04:18.037"}, "bq_ids": {"n4140": {"so_12956399_12956638_0": {"section_id": 6037, "quality": 0.8805970149253731, "length": 59}}, "n3337": {"so_12956399_12956638_0": {"section_id": 5805, "quality": 0.9104477611940298, "length": 61}}, "n4659": {"so_12956399_12956638_0": {"section_id": 7536, "quality": 0.7761194029850746, "length": 52}}}, "12956638": {"ParentId": "12956399", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2012-10-18T14:08:43.510", "Score": "2", "LastEditorUserId": "452307", "LastEditDate": "2012-10-18T14:19:39.547", "Id": "12956638", "OwnerUserId": "452307", "Body": "<p>Irrespective of the presence or absence of <code>virtual</code> function:    </p>\n<pre><code>A* pa=new A(); \nB* downCastpb=static_cast&lt;B*&gt;(pa); \n</code></pre>\n<p>causes an <strong>Undefined Behavior</strong>.    </p>\n<p>When you use <code>static_cast</code> to cast an object to a type that it is not, it causes Undefined behavior. Once you have an code that produces undefined behavior it is useless to try and  find reasoning for the output observed. The compiler is free to show any behavior, a crash, a weird result or an absoultely fine working code.You are completely at the mercy of the compiler.</p>\n<p><strong>Reference:</strong> </p>\n<p><strong>C++11 Standard 5.2.9 [expr.static.cast]</strong> </p>\n<blockquote>\n<p id=\"so_12956399_12956638_0\">A prvalue of type \"pointer to <em>cv1</em> <code>B</code>\", where <code>B</code> is a class type, can be converted to a prvalue of type \"pointer to <em>cv2</em> <code>D</code>\", where <code>D</code> is a class derived from <code>B</code>, if a valid standard conversion from \"pointer to <code>D</code>\" to \"pointer to <code>B</code>\" exists, <em>cv2</em> is the same cv-qualification as, or greater cv-qualification than, <em>cv1</em>, and <code>B</code>\n  is neither a virtual base class of <code>D</code> nor a base class of a virtual base class of <code>D</code>. The null pointer value is converted to the null pointer value of the destination type. If the prvalue of type \"pointer to <em>cv1</em> <code>B</code>\" points\n  to a <code>B</code> that is actually a subobject of an object of type <code>D</code>, the resulting pointer points to the enclosing object\n  of type <code>D</code>. Otherwise, <strong>the result of the cast is undefined</strong>.</p>\n</blockquote>\n", "LastActivityDate": "2012-10-18T14:19:39.547"}});