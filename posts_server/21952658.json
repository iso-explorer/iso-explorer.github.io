post_cb({"21952658": {"CommentCount": "4", "ViewCount": "231", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-02-22T09:57:55.957", "LastActivityDate": "2014-02-22T10:49:34.947", "Title": "type-dependent nested-name-specifier in elaborated-type-specifier", "AcceptedAnswerId": "21953167", "LastEditDate": "2017-05-23T12:14:19.387", "Id": "21952658", "Score": "1", "Body": "<p>I never saw a nested-name-specifier in an elaborated-type-specifier before <a href=\"https://stackoverflow.com/q/21952375/153285\">this question</a>, and at first glance I thought it wasn't even covered by the grammar. Now I see that since C++98 up to the present, it's translated as a special case without the <em>typename-specifier</em> construct. C++11 7.1.6.3/2 (7.1.5.3/2 in C++98):</p>\n<blockquote>\n<p id=\"so_21952658_21952658_0\">3.4.4 describes how name lookup proceeds for the <em>identifier</em> in an <em>elaborated-type-specifier</em>. If the <em>identifier</em> resolves to a <em>class-name</em> or <em>enum-name</em>, the <em>elaborated-type-specifier</em> introduces it into the declaration the same way a <em>simple-type-specifier</em> introduces its <em>type-name</em>.</p>\n</blockquote>\n<p>Therefore it would seem that although you can form a qualified elaborated-type-specifier, you need to take care that it's never type-dependent. Name resolution per 3.4.4 at template definition time will never find a class-name because dependent names are presumed to be objects unless prefixed with the <code>typename</code> keyword, which isn't grammatically allowed in this context.</p>\n<p>Is this an accurate assessment of the meaning of the standard, and the design intent of the language?</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "153285", "AnswerCount": "1"}, "21953167": {"ParentId": "21952658", "CommentCount": "2", "CreationDate": "2014-02-22T10:46:32.617", "OwnerUserId": "743382", "PostTypeId": "2", "Id": "21953167", "Score": "3", "Body": "<p>Expanding from the comments:</p>\n<p>Take this program as an example:</p>\n<pre><code>template &lt;typename T&gt;\nstruct S1 { struct I { }; };\n\ntemplate &lt;typename T&gt;\nstruct S2 { typedef struct S1&lt;T&gt;::I I; }; // okay\n\ntemplate &lt;typename T&gt;\nstruct S3 { typedef struct S2&lt;T&gt;::I I; }; // okay at definition time\n                                          // usually error at instantiation time\ntemplate &lt;&gt;\nstruct S2&lt;short&gt; : S1&lt;short&gt; { };\n\nint main() {\n  S1&lt;int&gt;::I a;\n  S2&lt;int&gt;::I &amp;b = a; // okay\n  S3&lt;int&gt;::I &amp;c = b; // error\n  S1&lt;short&gt;::I d;\n  S2&lt;short&gt;::I &amp;e = d; // okay\n  S3&lt;short&gt;::I &amp;f = e; // okay\n}\n</code></pre>\n<p>At template definition time, both <code>S2</code> and <code>S3</code> are okay: 14.6p5 lists the exceptions where <code>typename</code> is not required. Essentially: where the use is unambiguous because the name can never be anything other than a type, <code>typename</code> is not required. This includes several cases where <code>typename</code> is not syntactically allowed, so where requiring <code>typename</code> would mean there is no way to write the program. Both <code>typename struct S&lt;T&gt;::I</code> and <code>struct typename S&lt;T&gt;::I</code> are hard errors, and <code>struct S&lt;T&gt;::I</code> is unambiguous.</p>\n<p>At template instantiation time, the rules of 3.4.4 are clearer: both <code>struct S1&lt;int&gt;::I</code> and <code>struct S2&lt;int&gt;::I</code> can then be found, where it becomes apparent that <code>S2&lt;int&gt;::I</code> is a typedef, so <code>struct S2&lt;int&gt;::I</code> is an error. At the same time, at that point, <code>S2&lt;short&gt;::I</code> is seen not to be a typedef, but a struct, so <code>struct S2&lt;short&gt;::I</code> is allowed.</p>\n", "LastActivityDate": "2014-02-22T10:46:32.617"}, "bq_ids": {"n4140": {"so_21952658_21952658_0": {"section_id": 5443, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_21952658_21952658_0": {"section_id": 5238, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_21952658_21952658_0": {"section_id": 6870, "quality": 0.9545454545454546, "length": 21}}}});