post_cb({"1870329": {"CommentCount": "3", "ViewCount": "682", "CreationDate": "2009-12-08T22:28:55.203", "LastActivityDate": "2009-12-08T23:31:35.417", "Title": "(c/c++) do copies of string literals share memory in TEXT section?", "AcceptedAnswerId": "1870359", "PostTypeId": "1", "Id": "1870329", "Score": "1", "Body": "<p>If I call a function like\nmyObj.setType(\"fluid\");\nmany times in a program, how many copies of the literal \"fluid\" are saved in memory? Can the compiler recognize that this literal is already defined and just reference it again?</p>\n", "Tags": "<c++><c><string-literals>", "OwnerUserId": "227540", "AnswerCount": "6"}, "1870633": {"ParentId": "1870329", "CommentCount": "0", "Body": "<p>This is a compiler implementation issue.  Many compilers that I have used have an option to share or merge duplicate string literals. Allowing duplicate string literals speeds up the compilation process but produces larger executables.</p>\n", "OwnerUserId": "225074", "PostTypeId": "2", "Id": "1870633", "Score": "1", "CreationDate": "2009-12-08T23:31:35.417", "LastActivityDate": "2009-12-08T23:31:35.417"}, "1870358": {"ParentId": "1870329", "CommentCount": "0", "Body": "<p>Yes, it can. Of course, it depends on the compiler. For VC++, it's even configurable:</p>\n<p><a href=\"http://msdn.microsoft.com/en-us/library/s0s0asdt(VS.80).aspx\" rel=\"nofollow noreferrer\">http://msdn.microsoft.com/en-us/library/s0s0asdt(VS.80).aspx</a></p>\n", "OwnerUserId": "414", "PostTypeId": "2", "Id": "1870358", "Score": "6", "CreationDate": "2009-12-08T22:32:33.470", "LastActivityDate": "2009-12-08T22:32:33.470"}, "1870357": {"ParentId": "1870329", "CommentCount": "1", "Body": "<p>Yes it can, but there's no guarantee that it will.  Define a constant if you want to be sure.</p>\n", "OwnerUserId": "121674", "PostTypeId": "2", "Id": "1870357", "Score": "4", "CreationDate": "2009-12-08T22:32:26.913", "LastActivityDate": "2009-12-08T22:32:26.913"}, "1870359": {"ParentId": "1870329", "CommentCount": "1", "Body": "<p>I believe that in C/C++ there is no specified handling for that case, but in most cases would use multiple definitions of that string.</p>\n", "OwnerUserId": "102371", "PostTypeId": "2", "Id": "1870359", "Score": "0", "CreationDate": "2009-12-08T22:32:45.857", "LastActivityDate": "2009-12-08T22:32:45.857"}, "1870355": {"ParentId": "1870329", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>This has nothing to do with C++(the language). Instead, it is an \"optimization\" that a compiler can do. So, the answer <strong>yes</strong> and <strong>no</strong>, depending on the compiler/platform you are using.</p>\n<p>@David This is from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n3000.pdf\" rel=\"nofollow noreferrer\">latest draft of the language</a>:</p>\n<blockquote>\n<p id=\"so_1870329_1870355_0\"><strong>\u00a7 2.14.6 (page 28)</strong></p>\n<p id=\"so_1870329_1870355_1\">Whether all string literals are\n  distinct (that is, are stored in\n  non overlapping objects) is\n  <strong>implementation</strong> defined. The effect of\n  attempting to modify a string literal\n  is <strong>undefined</strong>.</p>\n</blockquote>\n<p>The emphasis is mine.</p>\n<p>In other words, string literals in C++ are <em>immutable</em> because modifying a string literal is undefined behavior. So, the compiler is free, to eliminate redundant copies.</p>\n<p>BTW, I am talking about C++ only ;)</p>\n", "OwnerUserId": "127893", "LastEditorUserId": "127893", "LastEditDate": "2009-12-08T22:41:15.337", "Id": "1870355", "Score": "15", "CreationDate": "2009-12-08T22:32:14.293", "LastActivityDate": "2009-12-08T22:41:15.337"}, "bq_ids": {"n4140": {"so_1870329_1870355_1": {"section_id": 5361, "quality": 0.7222222222222222, "length": 13}}, "n3337": {"so_1870329_1870355_1": {"section_id": 5157, "quality": 0.7222222222222222, "length": 13}}, "n4659": {"so_1870329_1870355_1": {"section_id": 6789, "quality": 0.7222222222222222, "length": 13}}}, "1870463": {"ParentId": "1870329", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>2.13.4/2: \"whether all string literals are distinct (that is, are stored in nonoverlapping objects) is implementation-defined\".</p>\n<p>This permits the optimisation you're asking about.</p>\n<p>As an aside, there may be a slight ambiguity, at least locally within that section of the standard. The definition of string literal doesn't quite make clear to me whether the following code uses one string literal twice, or two string literals once each:</p>\n<pre><code>const char *a = \"\";\nconst char *b = \"\";\n</code></pre>\n<p>But the next paragraph says \"In translation phase 6 adjacent narrow string literals are concatenated\". Unless it means to say that something can be adjacent to itself, I think the intention is pretty clear that this code uses two string literals, which are concatenated in phase 6. So it's not one string literal twice:</p>\n<pre><code>const char *c = \"a\" \"a\";\n</code></pre>\n<p>Still, if you did read that \"a\" and \"a\" are the <em>same</em> string literal, then the standard requires the optimisation you're talking about. But I don't think they are the same literal, I think they're different literals that happen to consist of the same characters. This is perhaps made clear elsewhere in the standard, for instance in the general information on grammar and parsing.</p>\n<p>Whether it's made clear or not, many compiler-writers have interpreted the standard the way I think it is, so I might as well be right ;-)</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2009-12-08T23:06:29.980", "Id": "1870463", "Score": "0", "CreationDate": "2009-12-08T22:51:50.010", "LastActivityDate": "2009-12-08T23:06:29.980"}});