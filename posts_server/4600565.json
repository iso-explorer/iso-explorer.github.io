post_cb({"4600565": {"ViewCount": "414", "Body": "<p>Consider this code snippet,</p>\n<pre><code>template&lt;bool b&gt;\nstruct other\n{\n    static const bool value = !b;\n};\n\ntemplate&lt;bool b&gt;\nstruct test\n{\n    static const bool value = b || other&lt;b&gt;::value;\n};\n\nint main()\n{\n      bool value = test&lt;true&gt;::value;   \n}\n</code></pre>\n<p>Do compilers instantiate <code>other&lt;true&gt;</code> in situations such as the above, when instantiating seems completely unnecessary? Or just because I've written the syntax <code>other&lt;b&gt;::value</code>, compilers must instantiate it regardless of the fact that it contributes absolutely nothing to the calculation of the value of <code>test&lt;true&gt;::value</code>?</p>\n<p>I would like to hear, a) what is <em>required</em> by the Standard, and b) what is <em>actually</em> implemented by the various compilers? Relevant sections from the Standard would be appreciated.</p>\n", "AcceptedAnswerId": "4600746", "Title": "Short-circuiting while instantiating template?", "CreationDate": "2011-01-05T03:24:47.157", "Id": "4600565", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2011-01-31T05:09:56.330", "LastEditorUserId": "415784", "LastActivityDate": "2011-02-24T15:35:07.363", "Score": "12", "OwnerUserId": "415784", "Tags": "<c++><templates><instantiation><short-circuiting>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_4600565_4600746_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 238}}, "n3337": {"so_4600565_4600746_0": {"length": 22, "quality": 0.8148148148148148, "section_id": 230}}, "n4659": {"so_4600565_4600746_0": {"length": 21, "quality": 0.7777777777777778, "section_id": 242}}}, "4600746": {"Id": "4600746", "PostTypeId": "2", "Body": "<p>According to the C++ spec, section $14.7.1/4:</p>\n<blockquote>\n<p id=\"so_4600565_4600746_0\">\"A class template specialization is\n  implicitly instantiated if the class\n  type is used in a context that\n  requires a completely-defined object\n  type <strong>or if the completeness of the\n  class type affects the semantics of\n  the program</strong>; in particular, if an\n  expression whose type is a class\n  template specialization is involved in\n  overload resolution\"</p>\n</blockquote>\n<p>In the case you illustrated with short-circuiting, the class would have to have a complete type, because you're looking inside of it to find the value static member.  This precludes the compiler from short-circuiting the expression.</p>\n<p>As for what actually happens in practice, I'm not sure because I can't see how the compiler could get away with not doing the instantiation.  For example, suppose that the instantiation of <code>other&lt;b&gt;</code> looked like this:</p>\n<pre><code>template &lt;bool B&gt; struct other {\n    typedef int value;\n};\n</code></pre>\n<p>Here, your program would be ill-formed because <code>other&lt;b&gt;</code>::value is a type, not a value, but the compiler couldn't diagnose the error without actually doing the instantiation.</p>\n", "LastEditorUserId": "415784", "LastActivityDate": "2011-02-24T15:35:07.363", "Score": "9", "CreationDate": "2011-01-05T04:07:51.617", "ParentId": "4600565", "CommentCount": "0", "LastEditDate": "2011-02-24T15:35:07.363", "OwnerUserId": "501557"}});