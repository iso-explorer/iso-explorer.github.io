post_cb({"10676746": {"Id": "10676746", "PostTypeId": "2", "Body": "<p>It does look like a compiler bug.</p>\n<p>The standard says:</p>\n<blockquote>\n<p id=\"so_10671406_10676746_0\">After name lookup (3.4) finds that a name is a template-name or that\n  an operator-function-id or a literal-operator-id refers to a set of\n  overloaded functions any member of which is a function template if\n  this is followed by a &lt;, the &lt; is always taken as the delimiter of a\n  template-argument-list and never as the less-than operator.</p>\n</blockquote>\n<p>and in 3.4.5/1</p>\n<blockquote>\n<p id=\"so_10671406_10676746_1\">In a class member access expression (5.2.5), if the . or -&gt; token is\n  immediately followed by an identifier followed by a &lt;, the identifier\n  must be looked up to determine whether the &lt; is the beginning of a\n  template argument list (14.2) or a less-than operator. The identifier\n  is first looked up in the class of the object expression. If the\n  identifier is not found, it is then looked up in the context of the\n  entire postfix-expression and shall name a class template.</p>\n</blockquote>\n<p>The standard doesn't seem to indicate that the name lookup can ever find a non-member function template here. In any case, the meaning of <code>&lt;</code> should be decided at template definition time, not instantiation time (it's too late then).</p>\n", "LastActivityDate": "2012-05-20T20:00:55.800", "CommentCount": "0", "CreationDate": "2012-05-20T20:00:55.800", "ParentId": "10671406", "Score": "6", "OwnerUserId": "775806"}, "10806458": {"Id": "10806458", "PostTypeId": "2", "Body": "<p>In Clang, this was <a href=\"http://llvm.org/PR11856\" rel=\"nofollow\">PR11856</a>, which was fixed ~2.5 months ago. Clang trunk and Clang 3.1 do not report any errors with <a href=\"http://codepad.org/CLhyD4tr\" rel=\"nofollow\">this code</a>. The Clang bug includes an <a href=\"http://llvm.org/bugs/show_bug.cgi?id=11856#c2\" rel=\"nofollow\">explanation</a> of why this code was being rejected, and why the code is correct, reproduced here (slightly tweaked to address your case):</p>\n<blockquote>\n<p id=\"so_10671406_10806458_0\">The paragraph that matters here is <strong>[basic.lookup.classref]p1</strong>:</p>\n<p id=\"so_10671406_10806458_1\">\"In a class member access expression (5.2.5), if the <code>.</code> or <code>-&gt;</code> token is\n  immediately followed by an <em>identifier</em> followed by a <code>&lt;</code>, the identifier\n  must be looked up to determine whether the <code>&lt;</code> is the beginning of a\n  template argument list (14.2) or a less-than operator. The identifier\n  is first looked up in the class of the object expression. If the\n  identifier is not found, it is then looked up in the context of the\n  entire <em>postfix-expression</em> and shall name a class template.\"</p>\n<p id=\"so_10671406_10806458_2\">Since <code>v</code> is dependent, presumably the <em>identifier</em> is not found so we\n  consider what happens if we look in the context of the entire\n  <em>postfix-expression</em>. Since we find a function template, we should not\n  conclude that we have the start of a <em>template-id</em>.</p>\n</blockquote>\n", "LastActivityDate": "2012-05-29T20:44:23.980", "CommentCount": "1", "CreationDate": "2012-05-29T20:44:23.980", "ParentId": "10671406", "Score": "2", "OwnerUserId": "1041090"}, "bq_ids": {"n4140": {"so_10671406_10806458_1": {"length": 36, "quality": 0.9230769230769231, "section_id": 7126}, "so_10671406_10676746_1": {"length": 36, "quality": 0.9230769230769231, "section_id": 7126}, "so_10671406_10676746_0": {"length": 23, "quality": 1.0, "section_id": 71}}, "n3337": {"so_10671406_10676746_0": {"length": 23, "quality": 1.0, "section_id": 66}, "so_10671406_10806458_1": {"length": 36, "quality": 0.9230769230769231, "section_id": 6870}, "so_10671406_10676746_1": {"length": 36, "quality": 0.9230769230769231, "section_id": 6870}}, "n4659": {"so_10671406_10676746_0": {"length": 23, "quality": 1.0, "section_id": 73}, "so_10671406_10806458_1": {"length": 36, "quality": 0.9230769230769231, "section_id": 8627}, "so_10671406_10676746_1": {"length": 36, "quality": 0.9230769230769231, "section_id": 8627}}}, "10671406": {"ViewCount": "2072", "Body": "<p>I've found that when accessing a non-template attribute (<code>v.foo</code>) from a variable of a template type (<code>T&amp; v</code>), C++ can be tricked into thinking that it is a member template if there is a template function of the same name (<code>template class &lt;T&gt; void foo()</code>). How can this be explained from the C++ spec? Consider this simple program:</p>\n<pre><code>#include &lt;cassert&gt;\n\n/** Determine whether the 'foo' attribute of an object is negative. */\ntemplate &lt;class T&gt;\nbool foo_negative(T&amp; v)\n{\n    return v.foo &lt; 0;\n}\n\nstruct X\n{\n    int foo;\n};\n\nint main()\n{\n    X x;\n    x.foo = 5;\n    assert(!foo_negative(x));\n    return 0;\n}\n</code></pre>\n<p>We have a template function <code>foo_negative</code> that takes an object of any type and determines whether its foo attribute is negative. The <code>main</code> function instantiates <code>foo_negative</code> with [T = X]. This program compiles and runs without any output.</p>\n<p>Now, add this function to the top of the program:</p>\n<pre><code>template &lt;class T&gt;\nvoid foo()\n{\n}\n</code></pre>\n<p>Compiling it with G++ 4.6.3 results in this compiler error:</p>\n<pre><code>funcs.cpp: In function \u2018bool foo_negative(T&amp;)\u2019:\nfuncs.cpp:13:14: error: parse error in template argument list\nfuncs.cpp: In function \u2018bool foo_negative(T&amp;) [with T = X]\u2019:\nfuncs.cpp:25:5:   instantiated from here\nfuncs.cpp:13:14: error: \u2018foo\u2019 is not a member template function\n</code></pre>\n<p>(Where Line 13 is <code>return v.foo &lt; 0</code> and Line 25 is <code>assert(!foo_negative(x))</code>.)</p>\n<p>Clang produces similar errors.</p>\n<p>Wat? How did adding an unrelated function that is never called manage to introduce a syntax error into a valid program? When parsing <code>foo_negative</code>, the compiler doesn't know the type of <code>v</code>, and crucially, it doesn't know whether <code>v.foo</code> is a member template or a regular member. Apparently, it has to decide at parsing time (before the template is instantiated) whether to treat it as a member template or a regular member.</p>\n<p>If it thinks <code>v.foo</code> is a member template, then <code>&lt; 0</code> is seen as passing <code>0</code> as a template argument, and there is a missing <code>&gt;</code>, hence the syntax error. Then, when <code>foo_negative</code> is instantiated with [T = X], there is another error because <code>X::foo</code> is not a member template.</p>\n<p>But why does it think <code>v.foo</code> is a member template? This ambiguity is precisely what the <code>template</code> keyword is for: if I wrote <code>v.template foo</code>, then I would be explicitly telling C++ to expect a member template, but I didn't use the <code>template</code> keyword! I didn't refer to a member template, so it should assume that it's a regular member. The fact that there's a <em>function</em> of the same name as the member shouldn't have any effect. Why does it? It can't be a bug in the compiler because GCC and clang are consistent.</p>\n", "AcceptedAnswerId": "10806458", "Title": "C++ confusing attribute name for member template", "CreationDate": "2012-05-20T06:52:53.170", "Id": "10671406", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2012-05-29T20:44:23.980", "Score": "18", "OwnerUserId": "368821", "Tags": "<c++><templates>", "AnswerCount": "3"}, "10672786": {"Id": "10672786", "PostTypeId": "2", "Body": "<p><strong>This is a bug.</strong></p>\n<p>Your code is running fine on MSVC (2011).\nI think the parser of the compiler translated the '&lt;' as a start token for a template statement. But why Clang and GCC have this bug on the sametime?</p>\n<p>Please report the bug <a href=\"http://gcc.gnu.org/bugzilla/\" rel=\"nofollow noreferrer\">here</a> and <a href=\"http://llvm.org/bugs/enter_bug.cgi?product=clang\" rel=\"nofollow noreferrer\">here</a>.</p>\n<p>Maybe this is also interesting:\n<a href=\"https://stackoverflow.com/questions/4420828/another-bug-in-g-clang-c-templates-are-fun\">Another bug in g++/Clang? [C++ Templates are fun]</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2012-05-20T12:53:38.377", "Score": "4", "CreationDate": "2012-05-20T10:52:38.480", "ParentId": "10671406", "CommentCount": "6", "OwnerUserId": "1390242", "LastEditDate": "2017-05-23T12:22:43.860"}});