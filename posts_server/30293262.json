post_cb({"30293285": {"ParentId": "30293262", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You have to remove the reference first, since the type deduced by <code>decltype</code> is <code>const char (&amp;)[N]</code>, not just <code>const char [N]</code>:</p>\n<pre><code>std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_array&lt;\n    typename std::remove_reference&lt;decltype(\"sss\")&gt;::type\n&gt;::value &lt;&lt; '\\n'; // true\n</code></pre>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2015-05-17T23:56:56.383", "Id": "30293285", "Score": "5", "CreationDate": "2015-05-17T23:44:53.247", "LastActivityDate": "2015-05-17T23:56:56.383"}, "30293262": {"CommentCount": "0", "CreationDate": "2015-05-17T23:41:10.773", "PostTypeId": "1", "AcceptedAnswerId": "30293277", "LastEditorUserId": "1505939", "LastActivityDate": "2015-05-17T23:56:56.383", "LastEditDate": "2015-05-17T23:56:04.430", "ViewCount": "631", "FavoriteCount": "3", "Title": "Why does decltype on a string literal not yield an array type?", "Id": "30293262", "Score": "8", "Body": "<p>The standard defines a string literal's type, in \u00a72.13.5/8, as:</p>\n<blockquote>\n<p id=\"so_30293262_30293262_0\">Ordinary string literals and UTF-8 string literals are also referred to as narrow string literals. A narrow string literal has type \u201carray of n const char\u201d, where n is the size of the string as defined below, and has static storage duration (3.7).</p>\n</blockquote>\n<p>Therefore, for example, <code>\"sss\"</code> should have a type <code>char const[4]</code> (unless I'm reading it incorrectly).</p>\n<p>But this simple snippet:</p>\n<pre><code>std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_pointer&lt;decltype(\"sss\")&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_array&lt;decltype(\"sss\")&gt;::value;\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/783912b0fab66748\">gives</a>:</p>\n<pre><code>false\nfalse\n</code></pre>\n<p>What am I missing?</p>\n", "Tags": "<c++><arrays><string><c++11><decltype>", "OwnerUserId": "493122", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_30293262_30293277_0": {"section_id": 5947, "quality": 0.9375, "length": 15}, "so_30293262_30293262_0": {"section_id": 5356, "quality": 1.0, "length": 26}, "so_30293262_30293277_1": {"section_id": 5440, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_30293262_30293277_0": {"section_id": 5717, "quality": 0.9375, "length": 15}, "so_30293262_30293262_0": {"section_id": 5153, "quality": 1.0, "length": 26}, "so_30293262_30293277_1": {"section_id": 5235, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_30293262_30293277_0": {"section_id": 7433, "quality": 0.9375, "length": 15}, "so_30293262_30293262_0": {"section_id": 6781, "quality": 1.0, "length": 26}, "so_30293262_30293277_1": {"section_id": 6867, "quality": 0.8571428571428571, "length": 6}}}, "30293277": {"ParentId": "30293262", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>String literals are lvalues ([expr.prim.general]/p1):</p>\n<blockquote>\n<p id=\"so_30293262_30293277_0\">A literal is a primary expression. Its type depends on its form (2.13). A string literal is an lvalue; all other literals are prvalues.</p>\n</blockquote>\n<p><code>decltype(expr)</code> returns an lvalue-reference when the expression <code>expr</code> is an lvalue expression ([dcl.type.simple]/p4):</p>\n<blockquote>\n<p id=\"so_30293262_30293277_1\">For an expression e, the type denoted by decltype(e) is defined as\n  follows:</p>\n<ul>\n<li>if e is an unparenthesized id-expression or an unparenthesized class member access (5.2.5), decltype(e) is the type of the entity\n  named by e. If there is no such entity, or if e names a set of\n  overloaded func- tions, the program is ill-formed;</li>\n<li>otherwise, if e is an xvalue, decltype(e) is T&amp;&amp;, where T is the type of e;</li>\n<li>otherwise, if e is an lvalue, decltype(e) is T&amp;, where T is the type of e;</li>\n<li>otherwise, decltype(e) is the type of e.</li>\n</ul>\n</blockquote>\n<p>String literals <em>are</em> arrays of <code>N</code> <code>const char</code>, but what you are experiencing is the effect of <code>decltype</code>. What you really have is the type <code>char const(&amp;)[N]</code>, <strong>not</strong> <code>char const[N]</code>.</p>\n<p>Simply removing the reference should give you the behavior you desire:</p>\n<pre><code>std::is_array&lt;std::remove_reference_t&lt;decltype(\"sss\")&gt;&gt;::value;\n</code></pre>\n", "OwnerUserId": "701092", "LastEditorUserId": "493122", "LastEditDate": "2015-05-17T23:55:59.607", "Id": "30293277", "Score": "17", "CreationDate": "2015-05-17T23:44:03.763", "LastActivityDate": "2015-05-17T23:55:59.607"}});