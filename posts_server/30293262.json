post_cb({"bq_ids": {"n4140": {"so_30293262_30293277_0": {"length": 15, "quality": 0.9375, "section_id": 5947}, "so_30293262_30293262_0": {"length": 26, "quality": 1.0, "section_id": 5356}, "so_30293262_30293277_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 5440}}, "n3337": {"so_30293262_30293277_0": {"length": 15, "quality": 0.9375, "section_id": 5717}, "so_30293262_30293262_0": {"length": 26, "quality": 1.0, "section_id": 5153}, "so_30293262_30293277_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 5235}}, "n4659": {"so_30293262_30293277_0": {"length": 15, "quality": 0.9375, "section_id": 7433}, "so_30293262_30293262_0": {"length": 26, "quality": 1.0, "section_id": 6781}, "so_30293262_30293277_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 6867}}}, "30293285": {"Id": "30293285", "PostTypeId": "2", "Body": "<p>You have to remove the reference first, since the type deduced by <code>decltype</code> is <code>const char (&amp;)[N]</code>, not just <code>const char [N]</code>:</p>\n<pre><code>std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_array&lt;\n    typename std::remove_reference&lt;decltype(\"sss\")&gt;::type\n&gt;::value &lt;&lt; '\\n'; // true\n</code></pre>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-05-17T23:56:56.383", "Score": "5", "CreationDate": "2015-05-17T23:44:53.247", "ParentId": "30293262", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2015-05-17T23:56:56.383"}, "30293277": {"Id": "30293277", "PostTypeId": "2", "Body": "<p>String literals are lvalues ([expr.prim.general]/p1):</p>\n<blockquote>\n<p id=\"so_30293262_30293277_0\">A literal is a primary expression. Its type depends on its form (2.13). A string literal is an lvalue; all other literals are prvalues.</p>\n</blockquote>\n<p><code>decltype(expr)</code> returns an lvalue-reference when the expression <code>expr</code> is an lvalue expression ([dcl.type.simple]/p4):</p>\n<blockquote>\n<p id=\"so_30293262_30293277_1\">For an expression e, the type denoted by decltype(e) is defined as\n  follows:</p>\n<ul>\n<li>if e is an unparenthesized id-expression or an unparenthesized class member access (5.2.5), decltype(e) is the type of the entity\n  named by e. If there is no such entity, or if e names a set of\n  overloaded func- tions, the program is ill-formed;</li>\n<li>otherwise, if e is an xvalue, decltype(e) is T&amp;&amp;, where T is the type of e;</li>\n<li>otherwise, if e is an lvalue, decltype(e) is T&amp;, where T is the type of e;</li>\n<li>otherwise, decltype(e) is the type of e.</li>\n</ul>\n</blockquote>\n<p>String literals <em>are</em> arrays of <code>N</code> <code>const char</code>, but what you are experiencing is the effect of <code>decltype</code>. What you really have is the type <code>char const(&amp;)[N]</code>, <strong>not</strong> <code>char const[N]</code>.</p>\n<p>Simply removing the reference should give you the behavior you desire:</p>\n<pre><code>std::is_array&lt;std::remove_reference_t&lt;decltype(\"sss\")&gt;&gt;::value;\n</code></pre>\n", "LastEditorUserId": "493122", "LastActivityDate": "2015-05-17T23:55:59.607", "Score": "17", "CreationDate": "2015-05-17T23:44:03.763", "ParentId": "30293262", "CommentCount": "0", "OwnerUserId": "701092", "LastEditDate": "2015-05-17T23:55:59.607"}, "30293262": {"ViewCount": "631", "Body": "<p>The standard defines a string literal's type, in \u00a72.13.5/8, as:</p>\n<blockquote>\n<p id=\"so_30293262_30293262_0\">Ordinary string literals and UTF-8 string literals are also referred to as narrow string literals. A narrow string literal has type \u201carray of n const char\u201d, where n is the size of the string as defined below, and has static storage duration (3.7).</p>\n</blockquote>\n<p>Therefore, for example, <code>\"sss\"</code> should have a type <code>char const[4]</code> (unless I'm reading it incorrectly).</p>\n<p>But this simple snippet:</p>\n<pre><code>std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_pointer&lt;decltype(\"sss\")&gt;::value &lt;&lt; '\\n';\nstd::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_array&lt;decltype(\"sss\")&gt;::value;\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/783912b0fab66748\">gives</a>:</p>\n<pre><code>false\nfalse\n</code></pre>\n<p>What am I missing?</p>\n", "AcceptedAnswerId": "30293277", "Title": "Why does decltype on a string literal not yield an array type?", "CreationDate": "2015-05-17T23:41:10.773", "Id": "30293262", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-05-17T23:56:04.430", "LastEditorUserId": "1505939", "LastActivityDate": "2015-05-17T23:56:56.383", "Score": "8", "OwnerUserId": "493122", "Tags": "<c++><arrays><string><c++11><decltype>", "AnswerCount": "2"}});