post_cb({"42621378": {"CommentCount": "3", "ViewCount": "57", "PostTypeId": "1", "LastEditorUserId": "3325279", "CreationDate": "2017-03-06T09:01:12.810", "LastActivityDate": "2017-10-05T14:48:42.873", "Title": "How can I allow vector to be passed to INFO(), CAPTURE(), WARN(), etc. while avoiding illegally extending the std namespace?", "AcceptedAnswerId": "46537596", "LastEditDate": "2017-03-06T15:57:13.867", "Id": "42621378", "Score": "0", "Body": "<p>In Catch Unit Test v1.8.1, with gcc 6.2.0, I'm trying to conveniently output the contents of a vector when a test fails by passing the vector to <code>INFO(...)</code> or <code>CAPTURE(...)</code>.  To do so I'm overloading the stream insertion operator:</p>\n<pre><code>#include &lt;Catch/single_include/catch.hpp&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\n#define THIS_WORKS_BUT_EXTENDING_NAMESPACE_STD_IS_ILLEGAL\n#ifdef THIS_WORKS_BUT_EXTENDING_NAMESPACE_STD_IS_ILLEGAL\nnamespace std {\n#endif\n\nstd::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, const std::vector&lt;int&gt;&amp; v ) {\n    for ( const auto&amp; e : v ) {\n        os &lt;&lt; e &lt;&lt; \" \";\n    }\n    return os;\n}\n\n#ifdef THIS_WORKS_BUT_EXTENDING_NAMESPACE_STD_IS_ILLEGAL\n} //namespace std\n#endif\n\nint some_operation_on_vector( const std::vector&lt;int&gt;&amp; v ) {\n    return 1;\n}\n\nSCENARIO( \"some scenario\" )\n{\n    GIVEN( \"a vector\" )\n    {\n        const auto the_vector = std::vector&lt;int&gt;{ 1, 2, 3, 4, 5 };\n\n        WHEN( \"some result is calculated from the vector\" )\n        {\n            const auto actual_result = some_operation_on_vector( the_vector );\n\n            THEN( \"the result should be correct.  If not, print out the vector.\" )\n            {\n                const auto expected_result = 0;\n\n                CAPTURE( the_vector ); // &lt;--------\n                //^^^^\n                //How do I legally make this work?\n\n                REQUIRE( expected_result == actual_result );\n            }\n        }\n    }\n}\n</code></pre>\n<hr>\n<p>If I (illegally) extend the <code>std</code> namespace as above, then it works, and I see the desired output:</p>\n<pre><code>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ncatchtestexample is a Catch v1.8.1 host application.\nRun with -? for options\n\n-------------------------------------------------------------------------------\nScenario: some scenario\n     Given: a vector\n      When: some result is calculated from the vector\n      Then: the result should be correct.  If not, print out the vector.\n-------------------------------------------------------------------------------\nExampleTest.cpp:91\n...............................................................................\n\nExampleTest.cpp:95: FAILED:\n  REQUIRE( expected_result == actual_result )\nwith expansion:\n  0 == 1\nwith message:\n  the_vector := 1 2 3 4 5 \n\n===============================================================================\ntest cases: 1 | 1 failed\nassertions: 1 | 1 failed\n</code></pre>\n<p>But to try to be legal, when I try to move the <code>operator &lt;&lt;</code> overload out of the <code>std</code> namespace and into the global namespace (by commenting out <code>#define THIS_WORKS_BUT_EXTENDING_NAMESPACE_STD_IS_ILLEGAL</code>), the code doesn't compile due to passing a vector to the <code>CAPTURE()</code> macro.</p>\n<p>Per the <a href=\"https://github.com/philsquared/Catch/blob/master/docs/tostring.md\" rel=\"nofollow noreferrer\">Catch docs</a>, I tried replacing the <code>operator &lt;&lt;</code> overload with a <code>Catch::toString</code> overload:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;sstream&gt;\n\nnamespace Catch {\n    std::string toString( const std::vector&lt;int&gt;&amp; v ) {\n        std::ostringstream ss{};\n        for ( const auto&amp; e : v ) {\n            ss &lt;&lt; e &lt;&lt; \" \";\n        }\n        return ss.str();\n    }\n}\n</code></pre>\n<p>or with a <code>Catch::StringMaker</code> specialisation:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;sstream&gt;\n\nnamespace Catch {\n    template&lt;&gt; struct StringMaker&lt;std::vector&lt;int&gt;&gt; {\n        static std::string convert( const std::vector&lt;int&gt;&amp; v ) {\n            std::ostringstream ss{};\n            for ( const auto&amp; e : v ) {\n                ss &lt;&lt; e &lt;&lt; \" \";\n            }\n            return ss.str();\n        }\n    }; \n}\n</code></pre>\n<p>but in either case the test still doesn't compile, due to passing a vector to the <code>CAPTURE()</code> macro.</p>\n<p>The Catch docs say to put the <code>operator &lt;&lt;</code> overload into the same namespace as your type, but <code>std::vector</code> is not my type, and putting that overload into namespace <code>std</code> is illegal.</p>\n<p>But the only way I've been able to find to get <code>CAPTURE()</code> (or <code>INFO()</code>, or <code>WARN()</code>, etc.) to accept a <code>std::vector</code> argument is to illegally put the <code>operator &lt;&lt;</code> overload into namespace <code>std</code>.</p>\n<p>Is there a proper, legal way to do this?</p>\n</hr>", "Tags": "<c++><namespaces><catch-unit-test>", "OwnerUserId": "3325279", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_42621378_46537596_2": {"section_id": 6214, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_42621378_46537596_2": {"section_id": 5974, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_42621378_46537596_2": {"section_id": 7717, "quality": 0.5714285714285714, "length": 4}}}, "46537596": {"ParentId": "42621378", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I think I found some solutions better than <a href=\"https://stackoverflow.com/questions/42621378/how-can-i-allow-vector-to-be-passed-to-info-capture-warn-etc-while-avo/42687598#42687598\">the one I gave previously</a>:</p>\n<hr>\n<h2>Solution 1:</h2>\n<p>Update Catch to v1.8.2 or newer.  From some quick tests, it looks like v1.8.2 added support for <code>std::vector</code> in CAPTURE macros, without any extra effort on your part.  Overloading <code>operator &lt;&lt;</code> for <code>std::vector</code> isn't needed in this case.</p>\n<hr>\n<h2>Solution 2:</h2>\n<p>If you can't update to Catch v1.8.2 or newer for whatever reason, this solution is similar to the proposed solution in my original question, but with improvements based on <a href=\"https://stackoverflow.com/questions/38700941/best-way-to-specialise-operator-for-stdostream-and-stdvector-with-generic/38701053#38701053\">this answer</a> from C++ committee member Jonathan Wakely (Thank you!).</p>\n<p>He gives the following advice:</p>\n<blockquote>\n<p id=\"so_42621378_46537596_0\"><strong><em>Don't overload operators for types you don't control.</em></strong></p>\n<p id=\"so_42621378_46537596_1\">...</p>\n<p id=\"so_42621378_46537596_2\"><em>Instead create a tiny adaptor class and define the operator for that...</em></p>\n</blockquote>\n<p>So with that in mind:</p>\n<pre><code>#include &lt;Catch/single_include/catch.hpp&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt;typename T&gt; struct PrintableVector {\n    const std::vector&lt;T&gt;&amp; vec_;\n};\n\ntemplate &lt;typename T&gt;\nPrintableVector&lt;T&gt; makePrintable( const std::vector&lt;T&gt;&amp; vec ) {\n    return PrintableVector&lt;T&gt;{ vec };\n}\n\ntemplate &lt;typename T&gt;\nstd::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, const PrintableVector&lt;T&gt;&amp; printableVec ) {\n    for ( const auto&amp; e : printableVec.vec_ ) {\n        os &lt;&lt; e &lt;&lt; \" \";\n    }\n    return os;\n}\n\nint some_operation_on_vector( const std::vector&lt;int&gt;&amp; v ) {\n    return 1;\n}\n\nSCENARIO( \"some scenario\" )\n{\n    GIVEN( \"a vector\" )\n    {\n        const auto the_vector = std::vector&lt;int&gt;{ 1, 2, 3, 4, 5 };\n\n        WHEN( \"some result is calculated from the vector\" )\n        {\n            const auto actual_result = some_operation_on_vector( the_vector );\n\n            THEN( \"the result should be correct.  If not, print out the vector.\" )\n            {\n                const auto expected_result = 0;\n                CAPTURE( makePrintable( the_vector ) );\n                REQUIRE( expected_result == actual_result );\n            }\n        }\n    }\n}\n</code></pre>\n<p>This compiles and runs on Catch v1.8.1, and gives the following output:</p>\n<pre><code>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\ncatchtestexample is a Catch v1.8.1 host application.\nRun with -? for options\n\n-------------------------------------------------------------------------------\nScenario: some scenario\n     Given: a vector\n      When: some result is calculated from the vector\n      Then: the result should be correct.  If not, print out the vector.\n-------------------------------------------------------------------------------\nmain.cpp:43\n...............................................................................\n\nmain.cpp:47: FAILED:\n  REQUIRE( expected_result == actual_result )\nwith expansion:\n  0 == 1\nwith message:\n  makePrintable( the_vector ) := 1 2 3 4 5 \n\n===============================================================================\ntest cases: 1 | 1 failed\nassertions: 1 | 1 failed\n</code></pre>\n</hr></hr>", "OwnerUserId": "3325279", "LastEditorUserId": "3325279", "LastEditDate": "2017-10-05T14:48:42.873", "Id": "46537596", "Score": "0", "CreationDate": "2017-10-03T05:12:13.950", "LastActivityDate": "2017-10-05T14:48:42.873"}, "42687598": {"ParentId": "42621378", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I think I found an answer that works. (EDIT: See the <a href=\"https://stackoverflow.com/a/46537596/3325279\">other answer</a> for better solutions.)</p>\n<p>Instead of putting the <code>operator &lt;&lt;</code> overload into the <code>std</code> namespace, putting it into the <code>Catch</code> namespace compiles and gives the desired behavior:</p>\n<pre><code>namespace Catch {\n\nstd::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, const std::vector&lt;int&gt;&amp; v ) {\n    for ( const auto&amp; e : v ) {\n        os &lt;&lt; e &lt;&lt; \" \";\n    }\n    return os;\n}\n\n}\n</code></pre>\n<p>The <a href=\"https://github.com/philsquared/Catch/blob/master/docs/tostring.md\" rel=\"nofollow noreferrer\">Catch docs</a> say to put the <code>operator &lt;&lt;</code> overload into the same namespace as your type:</p>\n<blockquote>\n<h2>operator &lt;&lt; overload for std::ostream</h2>\n<p id=\"so_42621378_42687598_0\">This is the standard way of providing string conversions in C++ - and the chances are you may already provide this for your own purposes. If you're not familiar with this idiom it involves writing a free function of the form:</p>\n<pre><code>   std::ostream&amp; operator &lt;&lt; ( std::ostream&amp; os, T const&amp; value ) {\n       os &lt;&lt; convertMyTypeToString( value );\n       return os;\n   }\n</code></pre>\n<p id=\"so_42621378_42687598_1\">(where <code>T</code> is your type and <code>convertMyTypeToString</code> is where you'll write whatever code is necessary to make your type printable - it doesn't have to be in another function).</p>\n<p id=\"so_42621378_42687598_2\"><strong><em>You should put this function in the same namespace as your type.</em></strong> <em>[Emphasis mine]</em></p>\n<p id=\"so_42621378_42687598_3\">Alternatively you may prefer to write it as a member function:</p>\n<pre><code>   std::ostream&amp; T::operator &lt;&lt; ( std::ostream&amp; os ) const {\n       os &lt;&lt; convertMyTypeToString( *this );\n       return os;\n   }\n</code></pre>\n</blockquote>\n<p>But since std::vector isn't <em>my</em> type, and it lives in namespace <code>std</code>, I can't do what the docs say to do.</p>\n<p>So is it okay to put the <code>operator &lt;&lt;</code> overload into the <code>Catch</code> namespace instead?  It works, but is it okay?  Will bad things happen if I do?  The docs do say that it's okay to put overloads of <code>toString</code> into the Catch namespace, so does that make it okay for <code>operator &lt;&lt;</code> overloads as well?</p>\n", "OwnerUserId": "3325279", "LastEditorUserId": "3325279", "LastEditDate": "2017-10-03T05:59:53.693", "Id": "42687598", "Score": "0", "CreationDate": "2017-03-09T05:40:29.077", "LastActivityDate": "2017-10-03T05:59:53.693"}});