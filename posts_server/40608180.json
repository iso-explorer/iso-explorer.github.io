post_cb({"bq_ids": {"n4140": {"so_40608180_40608703_0": {"length": 12, "quality": 0.8, "section_id": 3277}, "so_40608180_40608703_1": {"length": 15, "quality": 1.0, "section_id": 6992}}, "n3337": {"so_40608180_40608703_0": {"length": 12, "quality": 0.8, "section_id": 3148}, "so_40608180_40608703_1": {"length": 15, "quality": 1.0, "section_id": 6738}}, "n4659": {"so_40608180_40608703_0": {"length": 12, "quality": 0.8, "section_id": 4035}, "so_40608180_40608703_1": {"length": 15, "quality": 1.0, "section_id": 8490}}}, "40608703": {"Id": "40608703", "PostTypeId": "2", "Body": "<p>Here's what I think is the crux of the matter:</p>\n<p><a href=\"http://eel.is/c++draft/dcl.fct.def.delete\" rel=\"nofollow noreferrer\">[dcl.fct.def.delete]</a>:</p>\n<blockquote>\n<p id=\"so_40608180_40608703_0\">A program that refers to a deleted function implicitly or explicitly, other than to declare it, is ill-formed.<br>\n  ...<br>\n  A deleted function is implicitly an inline function ([dcl.inline]).</br></br></p>\n</blockquote>\n<p><a href=\"http://eel.is/c++draft/class.member.lookup#4\" rel=\"nofollow noreferrer\">[class.member.lookup/4]</a>:</p>\n<blockquote>\n<p id=\"so_40608180_40608703_1\">If C contains a declaration of the name f, the declaration set\n  contains every declaration of f declared in C that satisfies the\n  requirements of the language construct in which the lookup occurs.</p>\n</blockquote>\n<p>Even if you <code>delete</code> the function, you still declare it. And a declared function will participate in overload resolution. It's only when it's the resolved overload, that the compiler checks if it's deleted.</p>\n<p>In your case, there is an obvious ambiguity when those function declarations are present.</p>\n", "LastEditorUserId": "817643", "LastActivityDate": "2016-11-15T11:53:03.300", "Score": "2", "CreationDate": "2016-11-15T11:27:16.140", "ParentId": "40608180", "CommentCount": "0", "OwnerUserId": "817643", "LastEditDate": "2016-11-15T11:53:03.300"}, "40608653": {"Id": "40608653", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_40608180_40608653_0\">Any use of a deleted function is ill-formed (the program will not\n  compile).</p>\n<p id=\"so_40608180_40608653_1\">If the function is overloaded, overload resolution takes place first,\n  and the program is only ill-formed if the deleted function was\n  selected.</p>\n</blockquote>\n<p>In you case programm can't select conversion becouse you have 3 variant </p>\n<ul>\n<li><p>int -&gt; Foo</p></li>\n<li><p>Foo -&gt; int</p></li>\n<li><p>Foo -&gt; int64</p></li>\n</ul>\n<p>Second question:\nyou can leave it as it is, but always use explicit conversion for int </p>\n<pre><code>bool b2 = (foo1 == Foo(5));\n</code></pre>\n", "LastActivityDate": "2016-11-15T11:24:59.923", "CommentCount": "0", "CreationDate": "2016-11-15T11:24:59.923", "ParentId": "40608180", "Score": "3", "OwnerUserId": "6752889"}, "40608180": {"ViewCount": "118", "Body": "<p>Is there a way to disable conversion operators? Marking them \"= delete\" messes up other things.</p>\n<p>Consider the following code:</p>\n<pre><code>class Foo\n{\npublic:\n\n    Foo() :mValue(0) {}\n    ~Foo() = default;\n    Foo(int64_t v) { mValue = v; }\n    Foo(const Foo&amp; src) = default;\n\n    bool operator==(const Foo&amp; rhs) { return mValue == rhs.mValue; }\n\n    /* after commenting these lines the code will compile */\n    operator int() const = delete;\n    operator int64_t() const = delete;\n\nprivate:\n    int64_t mValue;\n};\n\nint main()\n{\n    Foo foo1(5);\n    Foo foo2(10);\n    bool b1 = (foo1 == foo2);\n    bool b2 = (foo1 == 5);\n}\n</code></pre>\n<p>This won't compile because gcc complains that the == operator is ambiguous: </p>\n<pre><code>test.cc: In function \u2018int main()\u2019:\ntest.cc:25:21: error: ambiguous overload for \u2018operator==\u2019 (operand types are \u2018Foo\u2019 and \u2018int\u2019)\n     bool b2 = (foo1 == 5);\n                     ^\ntest.cc:25:21: note: candidates are:\ntest.cc:25:21: note: operator==(int, int) &lt;built-in&gt;\ntest.cc:25:21: note: operator==(int64_t {aka long int}, int) &lt;built-in&gt;\ntest.cc:10:10: note: bool Foo::operator==(const Foo&amp;)\n     bool operator==(const Foo&amp; rhs) { return mValue == rhs.mValue; }\n          ^\n</code></pre>\n<p>However, after commenting the conversion operators, the code will compile and run nicely.</p>\n<p>The first question is: why do the deleted conversion operators create an ambiguity for the == operator? I thought they should disable implicit Foo -&gt; int conversions but they seem to affect int -&gt; Foo conversions which does not sound logic to me.</p>\n<p>Second one: is there a way to mark the conversion operators deleted? Yes, by not declaring them - but I'm looking for a way that anyone in the future will see that those conversions are disabled by design.</p>\n", "AcceptedAnswerId": "40608703", "Title": "Deleting conversion operators", "CreationDate": "2016-11-15T11:02:02.867", "Id": "40608180", "CommentCount": "1", "LastEditDate": "2016-11-15T11:32:56.220", "PostTypeId": "1", "LastEditorUserId": "1025391", "LastActivityDate": "2016-11-15T11:53:03.300", "Score": "2", "OwnerUserId": "4208074", "Tags": "<c++><operators><implicit-conversion><deleted-functions>", "AnswerCount": "2"}});