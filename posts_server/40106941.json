post_cb({"40106941": {"CommentCount": "9", "AcceptedAnswerId": "40107282", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-10-18T11:24:36.590", "LastActivityDate": "2016-10-18T19:07:49.303", "LastEditDate": "2017-05-23T12:25:57.213", "ViewCount": "1655", "FavoriteCount": "1", "Title": "Is a Union Member's Destructor Called", "Id": "40106941", "Score": "13", "Body": "<p>C++11 allowed the use of standard layout types in a <code>union</code>: <a href=\"https://stackoverflow.com/q/40088319/2642059\">Member of Union has User-Defined Constructor</a></p>\n<p>My question then is: Am I guaranteed the custom destructor will be called, when the <code>union</code> goes out of scope?</p>\n<p>My understanding is that we must manually destroy and construct when switching: <a href=\"http://en.cppreference.com/w/cpp/language/union#Explanation\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/union#Explanation</a></p>\n<p>But what about an example like this:</p>\n<pre><code>{\n    union S { string str;\n              vector&lt;int&gt; vec;\n              ~S() {} } s = { \"Hello, world\"s };\n}\n</code></pre>\n<p>When <code>s</code> goes out of scope, have I leaked the memory the string allocated on the heap because I did not call <code>string</code>'s destructor?</p>\n", "Tags": "<c++><c++11><destructor><unions><standard-layout>", "OwnerUserId": "2642059", "AnswerCount": "3"}, "40108644": {"ParentId": "40106941", "CommentCount": "1", "CreationDate": "2016-10-18T12:43:48.373", "OwnerUserId": "152359", "PostTypeId": "2", "Id": "40108644", "Score": "1", "Body": "<p>You always need to manually call the constructor of the objects in your struct with non trivial types.</p>\n<p>Usually you always also need to construct them explicitly too. It seems weird that the assignment here works.</p>\n<p>In case of doubt though you can always check the assembly if destructors get called.</p>\n<p>The assembly of this code does call the <code>basic_string</code> constructor but not the destructor. So you will have leaks here.</p>\n<pre><code>using namespace std;\nint main(int argc, char** argv){\n    union S { string str;\n              vector&lt;int&gt; vec;\n              ~S() {} } s = { \"Hello, world\"s };\n}\n</code></pre>\n<p>link to see the assembly: <a href=\"https://godbolt.org/g/wKu3vf\" rel=\"nofollow\">https://godbolt.org/g/wKu3vf</a></p>\n", "LastActivityDate": "2016-10-18T12:43:48.373"}, "40107282": {"ParentId": "40106941", "PostTypeId": "2", "CommentCount": "21", "CreationDate": "2016-10-18T11:40:43.780", "Score": "10", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:17:39.080", "Id": "40107282", "OwnerUserId": "4342498", "Body": "<p>In your example that you provided <code>str</code> will not be destructed.  The standard states in [class.union]/2</p>\n<blockquote>\n<p id=\"so_40106941_40107282_0\">A union can have member functions (including constructors and destructors), but not virtual (10.3) functions. A union shall not have base classes. A union shall not be used as a base class. If a union contains a non-static data member of reference type the program is ill-formed. At most one non-static data member of a union may have a brace-or-equal-initializer . [ <strong>Note: If any non-static data member of a union has a non-trivial default constructor (12.1), copy constructor (12.8), move constructor (12.8), copy assignment operator (12.8), move assignment operator (12.8), or destructor (12.4), the corresponding member function of the union must be user-provided or it will be implicitly deleted (8.4.3) for the union. \u2014 end note</strong> ]</p>\n</blockquote>\n<p><sup>emphasis mine</sup></p>\n<p>So since both <code>str</code> and <code>vec</code> have special member functions that are not trivial you will need to provide them for the union yourself.</p>\n<p>Do note that as per <a href=\"https://stackoverflow.com/users/4326278/bogdan\">bogdan's</a> comments below the empty destructor is not enough.  In [class.union]/8 we have</p>\n<blockquote>\n<p id=\"so_40106941_40107282_1\">[...]If X is a union its variant members are the non-static data members;[...]</p>\n</blockquote>\n<p>So all members of this union are variants.  Then if we look at [class.dtor]/8 we have</p>\n<blockquote>\n<p id=\"so_40106941_40107282_2\">After executing the body of the destructor and destroying any automatic objects allocated within the body, a destructor for class X calls the destructors for X\u2019s direct non-variant non-static data members[...]</p>\n</blockquote>\n<p>So the destructor will not automatically destroy the members of the union as they are variants.</p>\n<p>You could make a <a href=\"http://en.wikipedia.org/wiki/Tagged_union\" rel=\"nofollow noreferrer\">tagged union</a> like <a href=\"https://stackoverflow.com/users/224671/kennytm\">kennytm</a> does <a href=\"https://stackoverflow.com/a/3521998/4342498\">here</a></p>\n<blockquote id=\"so_40106941_40107282_3\">\n<pre><code>struct TU {\n   int type;\n   union {\n     int i;\n     float f;\n     std::string s;\n   } u;\n\n   TU(const TU&amp; tu) : type(tu.type) {\n     switch (tu.type) {\n       case TU_STRING: new(&amp;u.s)(tu.u.s); break;\n       case TU_INT:    u.i = tu.u.i;      break;\n       case TU_FLOAT:  u.f = tu.u.f;      break;\n     }\n   }\n   ~TU() {\n     if (tu.type == TU_STRING)\n       u.s.~string();\n   }\n   ...\n};\n</code></pre>\n</blockquote>\n<p>Which ensures the correct member is destroyed or just use a <code>std::variant</code> or <code>boost::variant</code></p>\n", "LastActivityDate": "2016-10-18T19:07:49.303"}, "bq_ids": {"n4140": {"so_40106941_40107282_0": {"section_id": 5914, "quality": 0.7297297297297297, "length": 54}, "so_40106941_40107282_2": {"section_id": 404, "quality": 1.0, "length": 19}, "so_40106941_40107282_1": {"section_id": 369, "quality": 1.0, "length": 7}}, "n3337": {"so_40106941_40107282_0": {"section_id": 5686, "quality": 0.8513513513513513, "length": 63}, "so_40106941_40107282_2": {"section_id": 395, "quality": 1.0, "length": 19}, "so_40106941_40107282_1": {"section_id": 359, "quality": 1.0, "length": 7}}, "n4659": {"so_40106941_40107282_0": {"section_id": 7406, "quality": 0.7432432432432432, "length": 55}, "so_40106941_40107282_2": {"section_id": 422, "quality": 1.0, "length": 19}, "so_40106941_40107282_1": {"section_id": 382, "quality": 0.8571428571428571, "length": 6}}}, "40107227": {"ParentId": "40106941", "CommentCount": "1", "CreationDate": "2016-10-18T11:38:13.037", "OwnerUserId": "5481471", "PostTypeId": "2", "Id": "40107227", "Score": "3", "Body": "<p>Your example won't compile. Unions have, by default, a deleted destructor. Because of course, what destructor should be called? Surely you can't call both. And nowhere is any information stored about which member was actually constructed. It's up to you to provide a proper destructor.</p>\n<p>Here's the output of GCC when trying to compile your code snippet:</p>\n<pre><code>In function \u2018int main()\u2019:\nerror: use of deleted function \u2018main()::&lt;anonymous union&gt;::~&lt;constructor&gt;()\u2019\n       vector&lt;int&gt; vec; } s = { \"Hello, world\"s };\n                                                ^\n\nnote: \u2018main()::&lt;anonymous union&gt;::~&lt;constructor&gt;()\u2019 is implicitly deleted because the default definition would be ill-formed:\n      union { string str;\n            ^\n</code></pre>\n", "LastActivityDate": "2016-10-18T11:38:13.037"}});