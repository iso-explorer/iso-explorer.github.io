post_cb({"17710699": {"Id": "17710699", "PostTypeId": "2", "Body": "<p>In C:</p>\n<p><code>bool</code> is a macro that expands to <code>_Bool</code> and <code>_Bool</code> is a type that is neither <code>unsigned int</code>, <code>unsigned char</code> nor <code>int</code>.</p>\n<p>For example, <code>_Bool</code> has this property:</p>\n<pre><code>(_Bool) 0.5  == 1\n</code></pre>\n<p>and none of the other standard integer types have this property.</p>\n<p>C standard just says that <code>_Bool</code> is an unsigned integer type large enough to store values <code>0</code> and <code>1</code>. Also a <code>_Bool</code> object has at least <code>CHAR_BIT</code> as has any object of non-bit field type. </p>\n<p>Regarding the size of <code>_Bool</code>, it is usually <code>1</code> (optimized for size) but on some systems it has the same size as the size of the word (for example <code>4</code> on some <code>32</code>-bit systems).</p>\n", "LastEditorUserId": "1119701", "LastActivityDate": "2013-07-17T21:42:10.013", "Score": "2", "CreationDate": "2013-07-17T21:35:35.610", "ParentId": "17710421", "CommentCount": "6", "LastEditDate": "2013-07-17T21:42:10.013", "OwnerUserId": "1119701"}, "17710673": {"Id": "17710673", "PostTypeId": "2", "Body": "<p>C++11 spec, section 3.9.1 [basic.fundamental], paragraph 6:</p>\n<blockquote>\n<p id=\"so_17710421_17710673_0\">Values of type <code>bool</code> are either <code>true</code> or <code>false</code>. [Note: There are no\n  signed, unsigned, short, or long bool types or values. \u2014 end note ]\n  Values of type bool participate in integral promotions (4.5).</p>\n</blockquote>\n<p>Section 5.3.3 [expr.sizeof], paragraph 1:</p>\n<blockquote>\n<p id=\"so_17710421_17710673_1\">The <code>sizeof</code> operator yields the number of bytes in the object\n  representation of its operand. The operand is either an expression,\n  which is an unevaluated operand (Clause 5), or a parenthesized\n  type-id. The <code>sizeof</code> operator shall not be applied to an expression\n  that has function or incomplete type, to an enumeration type whose\n  underlying type is not \ufb01xed before all its enumerators have been\n  declared, to the parenthesized name of such types, or to an lvalue\n  that designates a bit-\ufb01eld. <code>sizeof(char)</code>, <code>sizeof(signed char)</code> and <code>sizeof(unsigned char)</code> are 1. The result of <code>sizeof</code> applied to any other fundamental type (3.9.1) is\n  implementation-de\ufb01ned. [<strong>Note: in particular, <code>sizeof(bool)</code>,\n  <code>sizeof(char16_t)</code>, <code>sizeof(char32_t)</code>, and <code>sizeof(wchar_t)</code> are\n  implementation-de\ufb01ned.</strong> (75) \u2014 end note ]</p>\n</blockquote>\n<p>Footnote (75) says:</p>\n<blockquote>\n<p id=\"so_17710421_17710673_2\">75) <code>sizeof(bool)</code> is not required to be 1</p>\n</blockquote>\n<p>The presence of the footnote suggests that <code>sizeof(bool)</code> equals 1 on enough implementations that they need to remind people it is not necessarily so.</p>\n", "LastEditorUserId": "768469", "LastActivityDate": "2013-07-17T21:39:02.640", "Score": "9", "CreationDate": "2013-07-17T21:33:49.190", "ParentId": "17710421", "CommentCount": "0", "LastEditDate": "2013-07-17T21:39:02.640", "OwnerUserId": "768469"}, "17710421": {"ViewCount": "1252", "Body": "<p>I was under the impression that <code>bool</code> types either in C or C++ were typdef'ed integers because it was \"easier\" to handle at the machine level (size of word and what not). But I just did a <code>sizeof</code> and, to my surprise, they return 1 (byte). Is this right? Well, it is, as per my own short experiment, by why does everything tell me I should be using integers?</p>\n<p>Just for the sake of interest, see the <a href=\"http://en.wikipedia.org/wiki/Boolean_data_type#C.2C_C.2B.2B.2C_Objective-C.2C_Awk.2C_Perl\" rel=\"nofollow\">Wikipedia article</a> on boolean data types for C.</p>\n", "Title": "the built-in type bool in C++ or the stdbool.h type in C defines TRUE and FALSE as not the size of the machine word?", "CreationDate": "2013-07-17T21:18:28.350", "LastActivityDate": "2013-07-17T22:45:15.713", "CommentCount": "28", "LastEditDate": "2013-07-17T22:45:15.713", "PostTypeId": "1", "LastEditorUserId": "50305", "Id": "17710421", "Score": "2", "OwnerUserId": "50305", "Tags": "<c++><c>", "AnswerCount": "4"}, "17710566": {"Id": "17710566", "PostTypeId": "2", "Body": "<p>According to the latest C standard, <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"nofollow\">C11</a>, the <code>&lt;stdbool.h&gt;</code> header defines:</p>\n<blockquote>\n<p id=\"so_17710421_17710566_0\"><b>true</b></p>\n<p id=\"so_17710421_17710566_1\">which expands to the integer constant 1,</p>\n<p id=\"so_17710421_17710566_2\"><b>false</b></p>\n<p id=\"so_17710421_17710566_3\">which expands to the integer constant 0</p>\n</blockquote>\n", "LastActivityDate": "2013-07-17T21:27:02.423", "Score": "1", "CreationDate": "2013-07-17T21:27:02.423", "ParentId": "17710421", "CommentCount": "0", "OwnerUserId": "101258"}, "bq_ids": {"n4140": {"so_17710421_17710673_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 7215}, "so_17710421_17710673_1": {"length": 57, "quality": 0.8142857142857143, "section_id": 6076}}, "n3337": {"so_17710421_17710673_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 6959}, "so_17710421_17710673_1": {"length": 58, "quality": 0.8285714285714286, "section_id": 5844}}, "n4659": {"so_17710421_17710673_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 8724}, "so_17710421_17710673_1": {"length": 45, "quality": 0.6428571428571429, "section_id": 7572}}}, "17710564": {"Id": "17710564", "PostTypeId": "2", "Body": "<p>On SOME machines, <code>int</code> may be easier to handle than a byte-sized object. But for many processors, an <code>int</code> is no easier to deal with than a byte-sized integer. Since a byte takes less space (at least if you don't stick it next to an <code>int</code> so that the compiler needs to pad it), then you benefit in doing so in some situations. </p>\n<p>I don't think the standard says anything about what size it actually MUST be. Edit: As the comment says, the C++ standard specifically says that the size is implementation defined, and is not required to be 1 (but it also doesn't say it CAN'T be 1). The standard also says that the value of a <code>bool</code> is <code>true</code> or <code>false</code>, but that if you \"use\" an uninitialized variable of type <code>bool</code>, it is undefined behaviour, and it can be something that is neither of those values. </p>\n<p>There are a few processors (older Alpha, some variants of MIPS if my memory serves right) where bytes are \"difficult\" to handle (there are only instructions to read whole words, individual bytes has to be managed by masking, etc). On these processors, it would make sense to have a <code>int</code> sized type. And it wouldn't surprise me if that is the case on those machines. Remember, C and C++ are languages that allow types to vary in size depending on what is \"good\" on that particular architecture.</p>\n", "LastEditorUserId": "19465", "LastActivityDate": "2013-07-17T21:46:33.847", "Score": "7", "CreationDate": "2013-07-17T21:27:00.767", "ParentId": "17710421", "CommentCount": "2", "LastEditDate": "2013-07-17T21:46:33.847", "OwnerUserId": "1919155"}});