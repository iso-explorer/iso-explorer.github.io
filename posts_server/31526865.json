post_cb({"31526915": {"ParentId": "31526865", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2015-07-20T21:48:16.810", "Score": "0", "LastEditorUserId": "2642204", "LastEditDate": "2015-07-20T21:58:44.210", "Id": "31526915", "OwnerUserId": "2642204", "Body": "<p>As it says <a href=\"http://en.cppreference.com/w/cpp/language/try_catch\" rel=\"nofollow\">here</a>:</p>\n<blockquote>\n<p id=\"so_31526865_31526915_0\">If the parameter of the catch-clause is a reference type, any changes made to it are reflected in the exception object, and can be observed by another handler if the exception is rethrown with throw;</p>\n</blockquote>\n<p>So this suggests that it's safe to modify the exception object, and the changes will be observable.</p>\n<p>However, one should consider just catching by an ordinary reference. Or, make the function <code>const</code> if it can work only on members that are marked as <code>mutable</code>. </p>\n<p>Any of this doesn't sound readable and can make co-developers hostile.</p>\n", "LastActivityDate": "2015-07-20T21:58:44.210"}, "31526911": {"ParentId": "31526865", "CommentCount": "0", "CreationDate": "2015-07-20T21:47:59.400", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "31526911", "Score": "3", "Body": "<p>I see no evidence of any \"trickery\" in the standard. Can't prove a negative, but I believe you're \"safe\". The <code>const</code>ness appears to be equivalent in form to this:</p>\n<pre><code>T obj;\nconst T&amp; t = obj;\nconst_cast&lt;T &amp;&gt;(t).func();\n</code></pre>\n<p>That is, the <code>const</code>ness first comes into being on the reference that exists within the <code>catch</code> block and that's that.</p>\n<p>But this all really begs the question: if you can't be sure by looking at it, why do it at all?</p>\n<p>Just catch a <code>T&amp;</code>, surely.</p>\n", "LastActivityDate": "2015-07-20T21:47:59.400"}, "31526975": {"ParentId": "31526865", "CommentCount": "6", "CreationDate": "2015-07-20T21:52:24.567", "OwnerUserId": "82320", "PostTypeId": "2", "Id": "31526975", "Score": "6", "Body": "<p>(I'm using C++11; I need to update ;))</p>\n<p>15.1/3 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_31526865_31526975_0\">A <em>throw-expression</em> initializes a temporary object, called the exception object, <strong>the type of which is determined by removing any top-level cv-quali\ufb01ers</strong> from the static type of the operand of throw</p>\n</blockquote>\n<p>This means that the exception object is never \"born const\" and as such should not trigger undefined behavior to modify.</p>\n", "LastActivityDate": "2015-07-20T21:52:24.567"}, "31526865": {"CommentCount": "14", "ViewCount": "319", "CreationDate": "2015-07-20T21:42:35.280", "LastActivityDate": "2015-07-21T01:35:15.887", "Title": "Catch exception by const reference and cast away const", "AcceptedAnswerId": "31527020", "PostTypeId": "1", "Id": "31526865", "Score": "2", "Body": "<p>Is this valid as an exception handler, where <code>T</code> is some class with a non-<code>const</code> member function <code>func</code>?</p>\n<p>In other words: is the <code>catch</code> guaranteed to bind directly to the (modifiable) exception object,  or is there latitude for the compiler to do some trickery when you catch by const reference?</p>\n<pre><code>catch(const T &amp;t)\n{\n    const_cast&lt;T &amp;&gt;(t).func();\n}\n</code></pre>\n", "Tags": "<c++><exception><language-lawyer>", "OwnerUserId": "1505939", "AnswerCount": "4"}, "31527020": {"ParentId": "31526865", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-07-20T21:55:49.367", "Score": "5", "LastEditorUserId": "2069064", "LastEditDate": "2015-07-21T01:35:15.887", "Id": "31527020", "OwnerUserId": "2069064", "Body": "<p>From [except.throw]:</p>\n<blockquote>\n<p id=\"so_31526865_31527020_0\">Evaluating a throw-expression with an operand throws an exception (15.1); the type of the exception object\n  is determined by removing any top-level cv-qualifiers from the static type of the operand and adjusting the\n  type from \u201carray of T\u201d or \u201cfunction returning T\u201d to \u201cpointer to T\u201d or \u201cpointer to function returning T\u201d,\n  respectively.</p>\n</blockquote>\n<p>and, emphasis mine:</p>\n<blockquote>\n<p id=\"so_31526865_31527020_1\">Throwing an exception copy-initializes (8.5, 12.8) a temporary object, called the exception object. The\n  temporary is an <strong>lvalue</strong> and is used to initialize the variable declared in the matching handler (15.3).</p>\n</blockquote>\n<p>So if we throw an operand of type <em>cv</em> T, we're copy-initializing a temporary object of type T. </p>\n<p>Then according to [except.handle], a handler for const T&amp; (for non-pointer-type T) is matched for an exception object of type E if:</p>\n<blockquote id=\"so_31526865_31527020_2\">\n<ul>\n<li>[...] E and T are the same type (ignoring the top-level <em>cv-qualifiers</em>),  </li>\n<li>[...] T is an unambiguous public base class of E</li>\n</ul>\n</blockquote>\n<p>This handler is initialized by:</p>\n<blockquote>\n<p id=\"so_31526865_31527020_3\">The variable declared by the exception-declaration, of type <em>cv</em> T or <em>cv</em> T&amp;, is initialized from the exception\n  object, of type E, as follows:<br>\n  \u2014 if T is a base class of E, the variable is copy-initialized (8.5) from the corresponding base class subobject\n  of the exception object;<br>\n  \u2014 otherwise, the variable is copy-initialized (8.5) from the exception object.</br></br></p>\n</blockquote>\n<p>So if we catch by const T&amp;, we're copy-initializing the reference from the exception object - which we know from the previous section will be either of type T or is derived publicly from T. From [dcl.init.ref]:</p>\n<blockquote>\n<p id=\"so_31526865_31527020_4\">A reference to type \u201c<em>cv1</em> T1\u201d is initialized by an expression of type \u201c<em>cv2</em> T2\u201d as follows:<br>\n  \u2014 If the reference is an lvalue reference and the initializer expression<br>\n  \u00a0\u00a0\u2014 is an lvalue (but is not a bit-field), and \u201c<em>cv1</em> T1\u201d is reference-compatible with \u201c<em>cv2</em> T2\u201d, or [...]</br></br></p>\n<p id=\"so_31526865_31527020_5\">then the reference is bound to the initializer expression lvalue in the first case</p>\n</blockquote>\n<p>The key is that the temporary exception object is still an <em>lvalue</em>. Thus, if our handler was matched for const T&amp;, we know that the reference is bound directly to an object of type T or D (where D derives from T) - either way, it's a type that is reference-compatible with <code>const T</code>. As such, there is no undefined behavior. If the temporary object were an rvalue or the handler could match a wider range of types, then  a temporary would be created of type <code>const T</code> - and your <code>const_cast</code> would definitely be undefined behavior. </p>\n<p>While your code exhibits no undefined behavior on a conforming compiler, there's really no reason not to just do:</p>\n<pre><code>catch(T &amp;t)\n{\n    t.func();\n}\n</code></pre>\n", "LastActivityDate": "2015-07-21T01:35:15.887"}, "bq_ids": {"n4140": {"so_31526865_31527020_3": {"section_id": 3361, "quality": 0.96, "length": 24}, "so_31526865_31527020_0": {"section_id": 3336, "quality": 0.9615384615384616, "length": 25}, "so_31526865_31527020_5": {"section_id": 3321, "quality": 1.0, "length": 8}, "so_31526865_31526975_0": {"section_id": 3336, "quality": 0.75, "length": 12}, "so_31526865_31527020_2": {"section_id": 3348, "quality": 1.0, "length": 9}, "so_31526865_31527020_1": {"section_id": 3336, "quality": 0.7222222222222222, "length": 13}, "so_31526865_31527020_4": {"section_id": 3321, "quality": 0.7894736842105263, "length": 15}}, "n3337": {"so_31526865_31526975_0": {"section_id": 3206, "quality": 0.875, "length": 14}, "so_31526865_31527020_2": {"section_id": 3218, "quality": 1.0, "length": 9}, "so_31526865_31527020_5": {"section_id": 3191, "quality": 1.0, "length": 8}, "so_31526865_31527020_4": {"section_id": 3191, "quality": 0.7894736842105263, "length": 15}, "so_31526865_31527020_0": {"section_id": 3206, "quality": 0.7307692307692307, "length": 19}}, "n4659": {"so_31526865_31527020_3": {"section_id": 4127, "quality": 0.96, "length": 24}, "so_31526865_31527020_1": {"section_id": 4103, "quality": 0.7222222222222222, "length": 13}, "so_31526865_31527020_5": {"section_id": 4087, "quality": 1.0, "length": 8}, "so_31526865_31527020_2": {"section_id": 4115, "quality": 1.0, "length": 9}, "so_31526865_31527020_4": {"section_id": 4087, "quality": 0.7894736842105263, "length": 15}, "so_31526865_31527020_0": {"section_id": 7672, "quality": 0.7692307692307693, "length": 20}}}});