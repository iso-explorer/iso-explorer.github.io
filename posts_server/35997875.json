post_cb({"35999952": {"Id": "35999952", "PostTypeId": "2", "Body": "<p>How would ADL work if namespaces can be templated? Are we supposed to create special template deduction rules for ADL then?</p>\n<p>More importantly, can you justify the added complexity to the language by demonstrating a use-case that can't be filled by, just make a template <code>struct</code> with only static members? If a template namespace is just like a gimped template struct, that doesn't seem to be very compelling.</p>\n<hr>\n<p>Also. I understand you weren't satisfied with the other questions about namespace / template hybrids, but one point in this answer seems to be relevant to your question:</p>\n<p><a href=\"https://stackoverflow.com/questions/12905951/why-cant-namespaces-be-template-parameters\">Why can't namespaces be template parameters?</a></p>\n<blockquote id=\"so_35997875_35999952_0\">\n<ol start=\"3\">\n<li>Possibly difficult: A namespace isn't a complete, self-contained entity. Different members of a namespace can be declared in different headers and even different compilation units.</li>\n</ol>\n</blockquote>\n<p>If a namespace is a template, how will this even work? Can you still \"reopen\" the namespace like you can with a regular namespace? If that's allowed, then what is the point of instantiation of the namespace?</p>\n<p>It sounds like it could potentially be extremely complicated.</p>\n<hr>\n<p>Also: Will the language still be easily parsable after your proposed feature?</p>\n<p>One of the most vexing things in C++ is the need to write <code>template</code> often when defining templates that refer to other templates, in order to resolve ambiguity in the grammar regarding whether <code>&lt;</code> is a less than operator or a template parameter list.</p>\n<blockquote>\n<p id=\"so_35997875_35999952_1\">3.4.5 [basic.lookup.classref]\n    In a class member access expression (5.2.5), if the . or -&gt; token is immediately followed by an identifier followed by a &lt;, the identifier must be looked up to determine whether the &lt; is the beginning of a template argument list (14.2) or a less-than operator. The identifier is first looked up in the class of the object expression. If the identifier is not found, it is then looked up in the context of the entire postfix-expression and shall name a class template. If the lookup in the class of the object expression finds a template, the name is also looked up in the context of the entire postfix-expression and</p>\n<p id=\"so_35997875_35999952_2\">\u2014 if the name is not found, the name found in the class of the object expression is used, otherwise</p>\n<p id=\"so_35997875_35999952_3\">\u2014 if the name is found in the context of the entire postfix-expression and does not name a class template, the name found in the class of the object expression is used, otherwise</p>\n<p id=\"so_35997875_35999952_4\">\u2014 if the name found is a class template, it shall refer to the same entity as the one found in the class of the object expression, otherwise the program is ill-formed.</p>\n</blockquote>\n<p>If namespaces can be templates, don't we have to write <code>template</code> for them also, whenever you will refer to a template after a <code>::</code> operator? For the same reason that <code>foo::bar &lt; 1 ...</code> could be a namespace template <code>bar</code> inside of template <code>foo</code> with a non-type template parameter, or it could be a comparison of <code>1</code> with <code>int foo::bar</code>.</p>\n<p>How do we disambiguate between that and the third possibility, <code>foo</code> is a namespace and <code>bar</code> is a regular class template inside of it`?</p>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2016-03-14T23:45:58.197", "Score": "1", "CreationDate": "2016-03-14T23:24:43.227", "ParentId": "35997875", "CommentCount": "3", "OwnerUserId": "3598119", "LastEditDate": "2017-05-23T10:28:32.590"}, "bq_ids": {"n4140": {"so_35997875_35999952_2": {"length": 5, "quality": 0.625, "section_id": 126}, "so_35997875_35999952_1": {"length": 36, "quality": 0.6792452830188679, "section_id": 7126}, "so_35997875_35999952_3": {"length": 8, "quality": 0.5333333333333333, "section_id": 194}}, "n3337": {"so_35997875_35999952_4": {"length": 8, "quality": 0.5714285714285714, "section_id": 188}, "so_35997875_35999952_2": {"length": 5, "quality": 0.625, "section_id": 120}, "so_35997875_35999952_1": {"length": 36, "quality": 0.6792452830188679, "section_id": 6870}, "so_35997875_35999952_3": {"length": 8, "quality": 0.5333333333333333, "section_id": 188}}, "n4659": {"so_35997875_35999952_2": {"length": 5, "quality": 0.625, "section_id": 131}, "so_35997875_35999952_1": {"length": 36, "quality": 0.6792452830188679, "section_id": 8627}}}, "35997875": {"ViewCount": "132", "Body": "<p>Namespaces are in many was like classes with no constructors, no destructors, no inheritance, final, and only static methods and members. After all, this kind of classes can essentially be used only the way namespaces are used: a named scope for declarations and definitions.</p>\n<p>... except that the above is not true, since classes can be <em>templated</em> - and namespaces cannot. There have been a couple of questions here on the site similar to \"can I template a namespace\", but what I'd like to know is - has the C++ standard committee ever considered a proposal to make namespaces templatable? If it has, was the proposal rejected? If it was, what were the reasons?</p>\n", "AcceptedAnswerId": "35999350", "Title": "Has the C++ standard committee considered templated namespace?", "CreationDate": "2016-03-14T20:53:47.960", "LastActivityDate": "2016-03-14T23:45:58.197", "CommentCount": "12", "FavoriteCount": "0", "PostTypeId": "1", "Tags": "<c++><templates><c++11><namespaces>", "Id": "35997875", "Score": "-2", "OwnerUserId": "1593077", "ClosedDate": "2016-03-22T01:00:31.293", "AnswerCount": "2"}, "35999350": {"Id": "35999350", "PostTypeId": "2", "Body": "<p>The inability to have a <code>template namespace</code> is actually just one way in which they differ from classes. Others would be things like <code>new namespace</code>, and <code>sizeof (namespace)</code> - how could a compiler implement that, given that a namespace may extend over many compilation units?</p>\n<p>Looking just at template namespaces... While it can at times be hard to keep up with all the proposals for new C++ features, I don't recall ever seeing one that attempted to add a feature such as you describe. </p>\n<p>Would it ever be considered, assuming someone were to write a proposal? As Stroustrup indicates in this interview (<a href=\"http://www.stroustrup.com/devXinterview.html\" rel=\"nofollow\">http://www.stroustrup.com/devXinterview.html</a>):</p>\n<blockquote>\n<p id=\"so_35997875_35999350_0\">For C++ to remain viable for decades to come, it is essential that\n  Standard C++ isn't extended to support every academic and commercial\n  fad. Most language facilities that people ask for can be adequately\n  addressed through libraries using only current C++ facilities.</p>\n</blockquote>\n<p>As you indicate yourself, what you are asking for is basically already there: just use a templated class with static members. This seems to disqualify it as a potential new feature, at least in the eyes of Stroustrup. </p>\n", "LastActivityDate": "2016-03-14T22:30:34.327", "CommentCount": "3", "CreationDate": "2016-03-14T22:30:34.327", "ParentId": "35997875", "Score": "1", "OwnerUserId": "4566726"}});