post_cb({"41983084": {"ParentId": "41982545", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_41982545_41983084_0\">The C++ standard says ([basic.def.odr] 3.2 paragraph 2) \"A variable\n  whose name appears as a potentially-evaluated expression is odr-used\n  unless it is an object that satisfies the requirements for appearing\n  in a constant expression (5.19) and the lvalue-to-rvalue conversion\n  (4.1) is immediately applied.\"</p>\n</blockquote>\n<p><a href=\"https://gcc.gnu.org/wiki/VerboseDiagnostics#missing_static_const_definition\" rel=\"nofollow noreferrer\">Read this for further information</a></p>\n", "OwnerUserId": "7490249", "PostTypeId": "2", "Id": "41983084", "Score": "0", "CreationDate": "2017-02-01T15:09:00.073", "LastActivityDate": "2017-02-01T15:09:00.073"}, "41983799": {"ParentId": "41982545", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>The program explicitely violates the one definition rule as you have stated in your question. But the standard does not require a diagnostic in this case. This is explicit in 3.2 One definition rule [basic.def.odr] \u00a74 (emphasis mine)</p>\n<blockquote>\n<p id=\"so_41982545_41983799_0\">Every program shall contain exactly one definition of every non-inline fonction or variable that is odr-used\n  in that program; <strong>no diagnostic required</strong>.</p>\n</blockquote>\n<p>and 1.4 Implementation compliance [intro.compliance] \u00a72.3 says:</p>\n<blockquote>\n<p id=\"so_41982545_41983799_1\">If a program contains a violation of a rule for which no diagnostic is required, this International\n  Standard places no requirement on implementations with respect to that program.</p>\n</blockquote>\n<p>That means that gcc is right to choke on that program because one rule has been violated. But it is not a bug when MSVC accepts it as a <em>compiler extension</em>(*) without even a warning because the standard <em>places no requirement</em> here.</p>\n<p>We are in the compile time undefined behaviour named <em>ill-formed program, no diagnostic required</em>. A compiler implementation is free to do what it wants:</p>\n<ul>\n<li>reject the program</li>\n<li>automatically fix the error and generate the code as if the definition was present (for current case)</li>\n<li>remove the offending line[s] if it makes sense and makes the program compilable - even if what is generated is not what the programmer expected</li>\n<li>compile it into a program that ends in a run-time error</li>\n<li>[add whatever you think of, but I have never seen a compiler able to hit my cat...]</li>\n</ul>\n<hr>\n<p>(*) more exactly, it is a compiler extension if it is <em>documented</em>. Unfortunately, I currently have no MSVC compiler full documentation, so I can not say whether it is documented and is a conformant extension, or is not and is just hmm... one possible execution of the program</p>\n<p>Here is a slight variation on OP's code demonstrating that the compiler did provide a definition:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass AE {\n    // ...\npublic:\n    static const int c6 = 7;\n    static const int c7 = 31;\n};\nconst int AE::c7;   // definition\n\nint main()\n{\n    const int* p1 = &amp;AE::c6;    // error: c6 not an lvalue\n    const int* p2 = &amp;AE::c7;    // ok\n    // ...\n    std::cout &lt;&lt; *p1 &lt;&lt; \"(\" &lt;&lt; p1 &lt;&lt; \") - \" &lt;&lt; *p2 &lt;&lt; \"(\" &lt;&lt; p2 &lt;&lt; \")\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n<p>The output is (with an old MSVC 2008, debug mode to avoid as much optimization as possible):</p>\n<pre class=\"lang-none prettyprint-override\"><code>7(00DF7800) - 31(00DF7804)\n</code></pre>\n<p>that is expected values and consecutive addresses</p>\n<p>With same code, Clang 3.4 complains (as expected) at link time with     </p>\n<pre><code>undefined reference to `AE::c6'\n</code></pre>\n</hr>", "OwnerUserId": "3545273", "LastEditorUserId": "3545273", "LastEditDate": "2017-02-01T17:01:27.990", "Id": "41983799", "Score": "5", "CreationDate": "2017-02-01T15:41:05.460", "LastActivityDate": "2017-02-01T17:01:27.990"}, "41982545": {"CommentCount": "15", "ViewCount": "215", "PostTypeId": "1", "LastEditorUserId": "4646361", "CreationDate": "2017-02-01T14:45:27.010", "LastActivityDate": "2017-02-01T17:01:27.990", "Title": "C++ static const members definition", "AcceptedAnswerId": "41983799", "LastEditDate": "2017-02-01T16:20:14.063", "Id": "41982545", "Score": "5", "Body": "<p>I understand that <strong>static const members</strong> have to have out-ouf-class definition it they are odr-used. But the thing is, my program compiles and run just fine even without members definition.</p>\n<p>Let's take a look at this example from C++ FAQ:</p>\n<pre><code>class AE\n{\npublic:\n    static const int c6 = 7;\n    static const int c7 = 31;\n};\nconst int AE::c7;   // definition\n\nvoid f()\n{\n    const int* p1 = &amp;AE::c6;    // error: c6 not an lvalue\n    const int* p2 = &amp;AE::c7;    // ok\n\n    cout &lt;&lt; *p1 &lt;&lt; endl;\n}\n\nint main()\n{\n    f();\n\n    const int* p1 = &amp;AE::c6; \n    std::cout &lt;&lt; p1 &lt;&lt; \"\\n\";\n\n    return 0;\n}\n\n\n//RESULT:\n// 7\n// 00007FF735E7ACE8\n</code></pre>\n<p>I see no error whatsoever. I use Visual Studio 2015, and this code compiles and runs just fine.</p>\n<p><strong>My question:</strong> Is this specific to msvc or there are some language changes that I'm not aware of?</p>\n<p><strong>UPDATE:</strong> This is not a duplicate,  as I said at the very beginning: I do understand how this suppose to work, I don't understand why it doesn't work as it should.</p>\n", "Tags": "<c++>", "OwnerUserId": "4646361", "AnswerCount": "3"}, "41983879": {"ParentId": "41982545", "CommentCount": "5", "Body": "<p>It <em>just so happens</em> that your compiler has applied some optimisations that mean it doesn't require you to follow the One Definition Rule in this case.</p>\n<p>However, the C++ standard still requires you to do so, so your program has undefined behaviour. The standard does not require a compiler to tell you when you violate this particular rule, so it's chosen not to. Indeed, it would have to put in extra effort to detect the problem.</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "41983879", "Score": "1", "CreationDate": "2017-02-01T15:44:45.857", "LastActivityDate": "2017-02-01T15:44:45.857"}, "bq_ids": {"n4140": {"so_41982545_41983799_1": {"section_id": 5770, "quality": 0.9090909090909091, "length": 10}, "so_41982545_41983799_0": {"section_id": 7041, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_41982545_41983084_0": {"section_id": 6785, "quality": 0.7272727272727273, "length": 16}, "so_41982545_41983799_1": {"section_id": 5543, "quality": 0.9090909090909091, "length": 10}, "so_41982545_41983799_0": {"section_id": 6786, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_41982545_41983799_1": {"section_id": 7227, "quality": 0.9090909090909091, "length": 10}, "so_41982545_41983799_0": {"section_id": 8538, "quality": 0.9166666666666666, "length": 11}}}});