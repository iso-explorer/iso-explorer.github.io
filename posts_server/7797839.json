post_cb({"7797881": {"Id": "7797881", "PostTypeId": "2", "Body": "<p>Because functions can't have arrays as arguments. They can have array references though.</p>\n", "LastActivityDate": "2011-10-17T18:23:58.083", "CommentCount": "0", "CreationDate": "2011-10-17T18:23:58.083", "ParentId": "7797839", "Score": "1", "OwnerUserId": "927034"}, "7797940": {"Id": "7797940", "PostTypeId": "2", "Body": "<p>In <code>f1()</code>, Size <code>4</code> is size of pointer which is 4 bytes. because in this function you have a pointer to the array.</p>\n<p>In <code>f1()</code>, you have that array by reference(or another name), and it is real array size.</p>\n", "LastActivityDate": "2011-10-17T18:29:37.663", "CommentCount": "0", "CreationDate": "2011-10-17T18:29:37.663", "ParentId": "7797839", "Score": "0", "OwnerUserId": "952747"}, "7798060": {"Id": "7798060", "PostTypeId": "2", "Body": "<p>It is because <em>arrays</em> cannot be passed <em>by value</em> to  a function.  So in order to make it work, the array decays into a pointer which then gets passed to the function <em>by value</em>. </p>\n<p>In other words, passing an array by value is akin to <em>initializing</em> an array with another array, but in C++ <em>an array</em> cannot be <em>initialized</em> with another array:</p>\n<pre><code>char buff[3] = {0,0,0};\nchar x[3] = buff; //error \n</code></pre>\n<p>So if an array appears on the right hand side of <code>=</code>, the left hand side has to be either <code>pointer</code> or <code>reference</code> type:</p>\n<pre><code>char *y = buff; //ok - pointer\nchar (&amp;z)[3] = buff; //ok - reference\n</code></pre>\n<p>Demo : <a href=\"http://www.ideone.com/BlfSv\" rel=\"nofollow\">http://www.ideone.com/BlfSv</a></p>\n<p>It is exactly for the same reason <code>auto</code> is inferred differently in each case below (note that <code>auto</code> comes with C++11):</p>\n<pre><code>auto a = buff; //a is a pointer - a is same as y (above)\nstd::cout &lt;&lt; sizeof(a) &lt;&lt; std::endl; //sizeof(a) == sizeof(char*)\n\nauto &amp; b = buff; //b is a reference to the array - b is same as z (above)\nstd::cout &lt;&lt; sizeof(b) &lt;&lt; std::endl; //sizeof(b) == sizeof(char[3])\n</code></pre>\n<p>Output:</p>\n<pre><code>4 //size of the pointer\n3 //size of the array of 3 chars\n</code></pre>\n<p>Demo : <a href=\"http://www.ideone.com/aXcF5\" rel=\"nofollow\">http://www.ideone.com/aXcF5</a></p>\n", "LastEditorUserId": "675100", "LastActivityDate": "2016-02-24T18:33:11.010", "Score": "5", "CreationDate": "2011-10-17T18:39:54.667", "ParentId": "7797839", "CommentCount": "0", "OwnerUserId": "415784", "LastEditDate": "2016-02-24T18:33:11.010"}, "7797921": {"Id": "7797921", "PostTypeId": "2", "Body": "<p>The reason basically boils down to type deduction when matching the different overloads. When you call <code>f</code> the compiler deduces the type to be <code>const char[3]</code> which then decays into <code>const char*</code> because <em>that's what arrays do</em>.  This is done in the same exact way that in <code>f(1)</code> the compiler deduces T to be <code>int</code> and not <code>int&amp;</code>.</p>\n<p>In the case of <code>f1</code> because the argument is taken by reference, then the compiler again deduces T to be <code>const char[3]</code>, but it takes a reference to it.</p>\n<p>Nothing really surprising, but rather consistent if it were not for the <em>decay</em> of arrays to pointers when used as function arguments...</p>\n", "LastActivityDate": "2011-10-17T18:27:13.907", "CommentCount": "0", "CreationDate": "2011-10-17T18:27:13.907", "ParentId": "7797839", "Score": "1", "OwnerUserId": "36565"}, "bq_ids": {"n4140": {"so_7797839_7797957_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 303}}, "n3337": {"so_7797839_7797957_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 294}}, "n4659": {"so_7797839_7797957_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 310}}}, "7797839": {"ViewCount": "1229", "Body": "<p>I don't understand why the array decays to a pointer in a template function. </p>\n<p>If you look at the following code: When the parameter is forced to be a reference (function f1) it does not decay. In the other function f it decays. Why is the type of T in function f not const char (buff&amp;)[3] but rather const char* (if I understand it correctly)?</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate &lt;class T&gt;\nvoid f(T buff) {\n    std::cout &lt;&lt; \"f:buff size:\" &lt;&lt; sizeof(buff) &lt;&lt; std::endl;       //prints 4\n}\n\ntemplate &lt;class T&gt;\nvoid f1(T&amp; buff) {\n    std::cout &lt;&lt; \"f:buff size:\" &lt;&lt; sizeof(buff) &lt;&lt; std::endl;       //prints 3\n}\n\nint main(int argc, char *argv[]) {\n    const char buff[3] = {0,0,0};\n    std::cout &lt;&lt; \"buff size:\" &lt;&lt; sizeof(buff) &lt;&lt; std::endl;         //prints 3\n    f(buff);\n    f1(buff);\n    return 0;\n}\n</code></pre>\n", "AcceptedAnswerId": "7797872", "Title": "why does the array decay to a pointer in a template function", "CreationDate": "2011-10-17T18:20:18.723", "Id": "7797839", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-02-24T18:33:11.010", "Score": "6", "OwnerUserId": "193049", "Tags": "<c++><arrays><templates><sizeof>", "AnswerCount": "6"}, "7797872": {"Id": "7797872", "PostTypeId": "2", "Body": "<p>Because arrays can not be passed by value as a function parameter.<br>\nWhen you pass them by value they decay into a pointer.</br></p>\n<p>In this function:</p>\n<pre><code>template &lt;class T&gt;\nvoid f(T buff) {\n</code></pre>\n<p>T can not be <code>char (&amp;buff)[3]</code> as this is a reference. The compiler would have tried <code>char (buff)[3]</code> to pass by value but that is not allowed. So to make it work arrays decay to pointers.</p>\n<p>Your second function works because here the array is passed by reference:</p>\n<pre><code>template &lt;class T&gt;\nvoid f1(T&amp; buff) {\n\n// Here T&amp; =&gt; char (&amp;buff)[3]\n</code></pre>\n", "LastEditorUserId": "36565", "LastActivityDate": "2011-10-17T18:27:52.320", "Score": "7", "CreationDate": "2011-10-17T18:23:02.467", "ParentId": "7797839", "CommentCount": "6", "OwnerUserId": "14065", "LastEditDate": "2011-10-17T18:27:52.320"}, "7797957": {"Id": "7797957", "PostTypeId": "2", "Body": "<p>To quote from spec, it says</p>\n<blockquote>\n<p id=\"so_7797839_7797957_0\">(14.8.2.1/2) If P is not a reference type: \u2014 If A is an array type,\n  the pointer type produced by the array-to-pointer standard conversion\n  (4.2) is used in place of A for type deduction; otherwise</p>\n</blockquote>\n<p>So, in your case, It is clear that,</p>\n<pre><code>template &lt;class T&gt;\nvoid f1(T&amp; buff) {\n    std::cout &lt;&lt; \"f:buff size:\" &lt;&lt; sizeof(buff) &lt;&lt; std::endl;       //prints 3\n}\n</code></pre>\n<p>doesn't decay into pointer.</p>\n", "LastActivityDate": "2011-10-17T18:31:21.933", "CommentCount": "0", "CreationDate": "2011-10-17T18:31:21.933", "ParentId": "7797839", "Score": "4", "OwnerUserId": "187543"}});