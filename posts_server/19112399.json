post_cb({"19116144": {"ParentId": "19112399", "CommentCount": "0", "CreationDate": "2013-10-01T12:26:36.640", "OwnerUserId": "981959", "PostTypeId": "2", "Id": "19116144", "Score": "1", "Body": "<p>GCC is following the standard, but this is a known defect, see <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1467\" rel=\"nofollow\">core issue 1467</a>, and is likely to get fixed soon.</p>\n", "LastActivityDate": "2013-10-01T12:26:36.640"}, "19112399": {"CommentCount": "0", "ViewCount": "576", "CreationDate": "2013-10-01T09:19:41.177", "LastActivityDate": "2013-10-01T12:26:36.640", "Title": "C++11 in gcc 4.8.1: list-initialization for copy constructor doesn't work", "FavoriteCount": "1", "PostTypeId": "1", "Id": "19112399", "Score": "8", "Body": "<p>I encourages with this problem:\nIf I have</p>\n<pre><code>class A\n{\npublic:\n};\nint main()\n{\n   A a{};\n   A b{a};\n}\n</code></pre>\n<p>gcc gives:</p>\n<blockquote>\n<p id=\"so_19112399_19112399_0\">moves.cc: In function \u2018int main()\u2019:\n  moves.cc:15:7: error: too many initializers for \u2018A\u2019\n    A b{a};</p>\n</blockquote>\n<p>But when I use A b(a) instead of A b{a} all compiles correctly. And if I declare default constructor it compiles too. Why does it work so?</p>\n", "Tags": "<c++><gcc><c++11><uniform-initialization>", "OwnerUserId": "2834162", "AnswerCount": "3"}, "19112526": {"ParentId": "19112399", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2013-10-01T09:25:08.653", "Score": "14", "LastEditorUserId": "204847", "LastEditDate": "2013-10-01T09:33:10.510", "Id": "19112526", "OwnerUserId": "204847", "Body": "<p>The class is an aggregate, so list-initialisation will perform aggregate initialisation, and won't consider the implicitly-declared constructors.</p>\n<p>Since there are no data members, only an empty list can be a valid aggregate initialiser.</p>\n<blockquote>\n<p id=\"so_19112399_19112526_0\">But when I use <code>A b(a)</code> instead of <code>A b{a}</code> all compiles correctly.</p>\n</blockquote>\n<p>Direct initialisation will use the implicit constructor rather than attempting aggregate initialisation.</p>\n<blockquote>\n<p id=\"so_19112399_19112526_1\">And if I declare default constructor it compiles too.</p>\n</blockquote>\n<p>By declaring a constructor, the class is no longer an aggregate, and can only be initialised using a constructor.</p>\n", "LastActivityDate": "2013-10-01T09:33:10.510"}, "bq_ids": {"n4140": {"so_19112399_19112572_2": {"section_id": 3299, "quality": 0.9354838709677419, "length": 29}, "so_19112399_19112572_1": {"section_id": 3298, "quality": 0.6956521739130435, "length": 16}}, "n3337": {"so_19112399_19112572_2": {"section_id": 3169, "quality": 0.9354838709677419, "length": 29}, "so_19112399_19112572_1": {"section_id": 3168, "quality": 0.8260869565217391, "length": 19}}, "n4659": {"so_19112399_19112572_2": {"section_id": 4065, "quality": 0.7741935483870968, "length": 24}, "so_19112399_19112572_1": {"section_id": 4063, "quality": 0.5217391304347826, "length": 12}}}, "19112572": {"ParentId": "19112399", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2013-10-01T09:27:03.277", "Score": "9", "LastEditorUserId": "1090079", "LastEditDate": "2013-10-01T09:44:40.817", "Id": "19112572", "OwnerUserId": "1090079", "Body": "<p>When not defining your own <em>constructors</em> <code>class A</code> will be considered an <em>aggregate</em> (ie. <em>plain-old-data</em>) storage type.</p>\n<p>When dealing with an aggregate, <em>list-initialization</em> won't consider any implicitly declared constructors, instead it will try to initialize the members of your object directly.</p>\n<p>In the case of <code>A b { a }</code> where <code>A</code> is an aggregate the compiler will try to initialize the first member in <code>A</code> with the value of <code>a</code>; this will of course fail since <code>A</code> doesn't contain any members.</p>\n<hr>\n<h3>What does the standard say?</h3>\n<blockquote>\n<p id=\"so_19112399_19112572_0\"><strong><code>[8.5.1 Aggregates]</code></strong></p>\n</blockquote>\n<p><sup></sup></p>\n<blockquote>\n<p id=\"so_19112399_19112572_1\">1) <strong>An aggregate is an array or a class (Clause 9) with no user-provided\n  constructors (12.1)</strong>, no brace-or-equal-initializer s for non-static\n  data members (9.2), no private or protected non-static data members\n  (Clause 11), no base classes (Clause 10), and no virtual functions\n  (10.3).</p>\n</blockquote>\n<p><sup></sup></p>\n<blockquote>\n<p id=\"so_19112399_19112572_2\">2) <strong>When an aggregate is initialized by an initializer list, as\n  specified in 8.5.4, the elements of the initializer are taken as\n  initializers for the members of the aggregate</strong>, in increasing subscript\n  or member order. Each member is copy-initialized from the\n  corresponding initializer-clause . If the initializer-clause is an\n  expression and a narrowing conversion (8.5.4) is required to convert\n  the expression, the program is ill-formed.</p>\n</blockquote>\n</hr>", "LastActivityDate": "2013-10-01T09:44:40.817"}});