post_cb({"34252403": {"ViewCount": "80", "Body": "<p>I have following C++11 code using templates:</p>\n<pre><code>struct Base{\n    using count_type = unsigned short;\n};\n\ntemplate&lt;class T&gt;\nstruct A : public Base{\n    using count_type = A::count_type;\n    // not works even if I comment this\n\n    count_type add(T x){\n        count_type sum = 5;\n        sum += x.value(); \n        //sum += (count_type) x.value(); // not works even if I cast this, e.g.\n\n\n        return sum;\n    }\n};\n\nstruct B{\n    using count_type = A&lt;B&gt;::count_type;\n\n    count_type value(){\n        return 5; // not works even if I do:\n        //return (count_type) 5;\n        //return 5U;\n    }\n};\n\nint main(int argc, char *argv[]){\n    B b;\n\n    A&lt;B&gt; a;\n\n    a.add(b);\n}\n</code></pre>\n<p>When I try to compile with <code>-Wconversion</code>, I get strange error message:</p>\n<pre><code>$ g++ -std=c++11  -Wconversion x.cc\nx.cc: In instantiation of \u2018A&lt;T&gt;::count_type A&lt;T&gt;::add(T) [with T = B; A&lt;T&gt;::count_type = short unsigned int]\u2019:\nx.cc:29:9:   required from here\nx.cc:11:7: warning: conversion to \u2018A&lt;B&gt;::count_type {aka short unsigned int}\u2019 from \u2018int\u2019 may alter its value [-Wconversion]\n   sum += x.value();\n       ^\n</code></pre>\n<p>Why this happens? There is no <code>int</code> anywhere?</p>\n<p>I will be grateful if someone edit my question.</p>\n<p>Note: <code>clang</code> does not give such warning.</p>\n", "AcceptedAnswerId": "34252492", "Title": "gcc weird conversion warning (conversion to \u2018A<B>::count_type {aka short unsigned int}\u2019 from \u2018int\u2019 may alter its value)", "CreationDate": "2015-12-13T14:55:39.283", "Id": "34252403", "CommentCount": "8", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2015-12-13T15:05:32.837", "LastEditorUserId": "964080", "LastActivityDate": "2015-12-13T15:06:30.660", "ClosedDate": "2015-12-13T15:07:50.380", "Score": "1", "OwnerUserId": "964080", "Tags": "<c++><c++11><gcc>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_34252403_34252511_4": {"length": 10, "quality": 0.9090909090909091, "section_id": 45}, "so_34252403_34252511_3": {"length": 12, "quality": 0.9230769230769231, "section_id": 45}, "so_34252403_34252511_1": {"length": 12, "quality": 1.0, "section_id": 5943}, "so_34252403_34252511_2": {"length": 38, "quality": 0.9743589743589743, "section_id": 21}}, "n3337": {"so_34252403_34252511_4": {"length": 10, "quality": 0.9090909090909091, "section_id": 42}, "so_34252403_34252511_3": {"length": 12, "quality": 0.9230769230769231, "section_id": 42}, "so_34252403_34252511_1": {"length": 12, "quality": 1.0, "section_id": 5714}, "so_34252403_34252511_2": {"length": 38, "quality": 0.9743589743589743, "section_id": 18}}, "n4659": {"so_34252403_34252511_4": {"length": 10, "quality": 0.9090909090909091, "section_id": 46}, "so_34252403_34252511_3": {"length": 12, "quality": 0.9230769230769231, "section_id": 46}, "so_34252403_34252511_1": {"length": 12, "quality": 1.0, "section_id": 7428}, "so_34252403_34252511_2": {"length": 38, "quality": 0.9743589743589743, "section_id": 21}}}, "34252511": {"Id": "34252511", "PostTypeId": "2", "Body": "<p>According to implicit promotions, any arithmetic expression (as <code>sum = sum + x.value()</code>) undergoes a pattern called <em>usual arithmetic conversions</em>, the relevant part from \u00a75 of the standard:</p>\n<blockquote>\n<p id=\"so_34252403_34252511_0\">...</p>\n<p id=\"so_34252403_34252511_1\">\u2014 Otherwise, <strong>the integral promotions (4.5) shall be performed on both operands</strong>. 59 Then the following rules shall be applied to the promoted operands:</p>\n</blockquote>\n<p>The integral promotions specifies:</p>\n<blockquote>\n<p id=\"so_34252403_34252511_2\">A prvalue of an integer type other than bool, char16_t, char32_t, or wchar_t <strong>whose integer conversion rank (4.13) is less than the rank of int can be converted to a prvalue of type <code>int</code></strong> if int can represent all the values of the source type; otherwise, the source prvalue can be converted to a prvalue of type unsigned int.</p>\n</blockquote>\n<p>So operands are converted to <code>int</code>, then back to <code>unsigned short</code>. This because the conversion rank specifies that</p>\n<blockquote>\n<p id=\"so_34252403_34252511_3\">The rank of a signed integer type shall be greater than the rank of any signed integer type with a smaller size.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_34252403_34252511_4\">The rank of any unsigned integer type shall equal the rank of the corresponding signed integer type.</p>\n</blockquote>\n", "LastActivityDate": "2015-12-13T15:06:30.660", "CommentCount": "0", "CreationDate": "2015-12-13T15:06:30.660", "ParentId": "34252403", "Score": "1", "OwnerUserId": "121747"}, "34252492": {"Id": "34252492", "PostTypeId": "2", "Body": "<p><code>sum += x.value();</code> means (roughly) <code>sum = sum + x.value();</code> The RHS here, <code>sum + x.value()</code>, adds two <code>unsigned short</code> values and produces an <code>int</code>. Assigning that <code>int</code> back to an <code>unsigned short</code> can alter its value.</p>\n<p>The warning is, in my opinion, not particularly useful and I suggest turning it off, but if you want to keep it enabled for some reason, write a cast there:</p>\n<pre><code>sum = (count_type) (sum + x.value());\n</code></pre>\n<p>or</p>\n<pre><code>sum = static_cast&lt;count_type&gt;(sum + x.value());\n</code></pre>\n", "LastActivityDate": "2015-12-13T15:05:23.307", "CommentCount": "6", "CreationDate": "2015-12-13T15:05:23.307", "ParentId": "34252403", "Score": "1", "OwnerUserId": "743382"}});