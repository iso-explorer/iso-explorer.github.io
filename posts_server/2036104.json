post_cb({"2036206": {"Id": "2036206", "PostTypeId": "2", "Body": "<p>You have an array of arrays.  <code>array[1]</code> follows <code>array[0]</code> in memory, because arrays are contiguous.  If <code>p == array[0]</code>, then <code>p[1]</code> follows <code>p[0]</code>, because arrays are contiguous.  So, you are right: all the memory for <code>array</code> is contiguous.</p>\n<p>In pictures, <code>array</code> looks like this.</p>\n<pre><code>+-----------------+-----------------+\n|      [0]        |      [1]        |\n+-----------------+-----------------+\n</code></pre>\n<p>Now, let's break down <code>array[0]</code> and <code>array[1]</code>, they individually look like this:</p>\n<pre><code>+--------+--------+\n|  [0]   |  [1]   |        \n+--------+--------+\n</code></pre>\n<p>So, the final picture is:</p>\n<pre><code>+--------+--------+--------+--------+\n| [0][0] | [0][1] | [1][0] | [1][1] |\n+--------+--------+--------+--------+\n</code></pre>\n<p>Now, the question is, can you access this contiguous memory the way you are.  The answer is, <em>it is not guaranteed by the standard</em>.  The arrays are contiguous, but the standard doesn't allow indexing the way you have done.  In other words:</p>\n<p><code>&amp;array[0][0]+2 == &amp;array[1][0]</code>, but <code>(&amp;a[0][0] + 2) + 1</code> is undefined whereas <code>&amp;a[1][0] + 1</code> is valid.  If this seems strange, it is, but as per the quote you posted from the standard, you are only allowed to calculate a pointer that is either inside an array or at most one past the array (without dereferencing that \"one past\" pointer).</p>\n<p>In practice, I doubt that this would fail anywhere, but the according to the standard at least, your code is invalid because of undefined behavior.</p>\n<p>See <a href=\"http://groups.google.com/group/comp.lang.c/msg/7aa195f285cac24a?dmode=source\" rel=\"nofollow noreferrer\">this post on <code>comp.lang.c</code></a> as well.</p>\n", "LastEditorUserId": "226621", "LastActivityDate": "2010-01-10T16:47:04.787", "Score": "9", "CreationDate": "2010-01-10T05:22:00.770", "ParentId": "2036104", "CommentCount": "7", "OwnerUserId": "226621", "LastEditDate": "2010-01-10T16:47:04.787"}, "2036121": {"Id": "2036121", "PostTypeId": "2", "Body": "<p>Your <code>array</code> is two arrays of <code>int[2]</code>, while your function <code>populate()</code> treats it as a single array of <code>int[4]</code>. Depending on exactly how the compiler decides to align the elements of <code>array</code>, this may not be a valid assumption.</p>\n<p>Specifically, when <code>j</code> is 2 and you try to access <code>arr[2]</code>, this is outside the bounds of <code>main</code>'s <code>array[0]</code> and is therefore invalid.</p>\n", "LastActivityDate": "2010-01-10T04:48:38.423", "CommentCount": "19", "CreationDate": "2010-01-10T04:48:38.423", "ParentId": "2036104", "Score": "15", "OwnerUserId": "893"}, "bq_ids": {"n4140": {"so_2036104_2036104_0": {"length": 21, "quality": 1.0, "section_id": 6142}}, "n3337": {"so_2036104_2036104_0": {"length": 21, "quality": 1.0, "section_id": 5906}}, "n4659": {"so_2036104_2036104_0": {"length": 11, "quality": 0.5238095238095238, "section_id": 7638}}}, "2036230": {"Id": "2036230", "PostTypeId": "2", "Body": "<p>In <code>C</code> everything is stored in linear memory segments. You are passing address of <code>a[0][0]</code> which would be same as address of <code>a[0]</code> so\n<code>a[i][j]</code> is same as <code>a[i*ColSize+j]</code> because everything is stored linearly. But if you allocate memory dynamically it would fail because that time all rows might not be stored in contiguous location. then <code>a[i][j]</code> would be <code>*(&amp;a[i]+j)</code>.</p>\n", "LastEditorUserId": "165520", "LastActivityDate": "2010-01-12T15:00:01.567", "Score": "0", "CreationDate": "2010-01-10T05:36:26.410", "ParentId": "2036104", "CommentCount": "2", "OwnerUserId": "164933", "LastEditDate": "2010-01-12T15:00:01.567"}, "2036128": {"Id": "2036128", "PostTypeId": "2", "Body": "<p>That is not going to always work. C has arrays of arrays, not 2D arrays. The sub-arrays are not always specified to be contiguous in memory(static arrays might be, check C/C++ standard)  In this particular example, I suspect it works correctly. However, if you had dynamically allocated the memory being passed in, you quite possibly would fail, because malloc(or new) might have put the subarrays quite far apart.</p>\n<p>If, however, you want to linearly walk down '2d' memory, you can construct a 2D accessor against a 1D array and it will work fine and things like memset will work against the 1D array. </p>\n", "LastActivityDate": "2010-01-10T04:51:07.523", "CommentCount": "10", "CreationDate": "2010-01-10T04:51:07.523", "ParentId": "2036104", "Score": "3", "OwnerUserId": "26227"}, "2036104": {"ViewCount": "566", "Body": "<p>Consider the following code :</p>\n<pre><code>void populate(int *arr)\n{\n   for(int j=0;j&lt;4;++j)\n       arr[j]=0;\n}\n\nint main()\n{\n   int array[2][2];\n   populate(&amp;array[0][0]);\n}\n</code></pre>\n<p>There was a discussion regarding this on a local community whether the code is valid or not(Am I supposed to mention its name?). One guy was saying that it invokes UB because it violates </p>\n<p><strong>C++ Standard</strong> ($5.7/5 [expr.add])</p>\n<blockquote>\n<p id=\"so_2036104_2036104_0\">\"If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; <strong>otherwise, the behavior is undefined</strong>.\" </p>\n</blockquote>\n<p>But I don't see anything wrong with the code,the code is perfectly OK for me. </p>\n<p>So, I just want to know is this code valid or not? Am I missing something?</p>\n", "AcceptedAnswerId": "2036121", "Title": "Validity of the code", "CreationDate": "2010-01-10T04:41:23.290", "Id": "2036104", "CommentCount": "1", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2012-10-29T16:32:12.857", "LastEditorUserId": "168868", "LastActivityDate": "2012-10-29T16:32:12.857", "Score": "14", "OwnerUserId": "165520", "Tags": "<c++><undefined-behavior>", "AnswerCount": "4"}});