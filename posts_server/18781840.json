post_cb({"18782072": {"ParentId": "18781840", "CommentCount": "4", "Body": "<p>If you put it in a structure with some padding ints, it should be safe (since the pointer actually points to \"known\" destinations).\nBut it's better to avoid it.</p>\n<pre><code>struct SafeOutOfBoundsAccess\n{ \n    int paddingBefore[6];\n    int val[10];\n    int paddingAfter[6];\n};\n\nvoid foo()\n{\n    SafeOutOfBoundsAccess a;\n    bool maybeTrue1 = a.val[-1] == a.paddingBefore[5];\n    bool maybeTrue2 = a.val[10] == a.paddingAfter[0];\n}\n</code></pre>\n", "OwnerUserId": "1254743", "PostTypeId": "2", "Id": "18782072", "Score": "3", "CreationDate": "2013-09-13T08:49:56.997", "LastActivityDate": "2013-09-13T08:49:56.997"}, "18781897": {"ParentId": "18781840", "CommentCount": "3", "Body": "<p>It is undefined behavior. By definition, undefined means \"anything could happen.\" Your code could crash, it could work perfectly, it could bring about peace and harmony amongst all humans. I wouldn't bet on the second or the last. </p>\n", "OwnerUserId": "1342470", "PostTypeId": "2", "Id": "18781897", "Score": "17", "CreationDate": "2013-09-13T08:40:31.170", "LastActivityDate": "2013-09-13T08:40:31.170"}, "18781840": {"CommentCount": "8", "AcceptedAnswerId": "18781897", "ClosedDate": "2013-09-13T11:41:44.063", "CreationDate": "2013-09-13T08:37:36.833", "LastActivityDate": "2013-09-13T13:01:59.647", "PostTypeId": "1", "ViewCount": "392", "FavoriteCount": "0", "Title": "C/C++ intentional out of range indexing", "Id": "18781840", "Score": "6", "Body": "<p>Say I have an array like so:</p>\n<pre><code>int val[10];\n</code></pre>\n<p>and I intentionally index it with everything from negative values to anything higher than 9, but WITHOUT using the resulting value in any way. This would be for performance reasons (perhaps it's more efficient to check the input index AFTER the array access has been made).</p>\n<p>My questions are:</p>\n<ol>\n<li>Is it safe to do so, or will I run into some sort of memory protection barriers, risk corrupting memory or similar for certain indices?</li>\n<li>Is it perhaps not at all efficient if I access data out of range like this? (assuming the array has no built in range check).</li>\n<li>Would it be considered bad practice? (assuming a comment is written to indicate we're aware of using out of range indices).</li>\n</ol>\n", "Tags": "<c++><c><arrays>", "OwnerUserId": "498519", "AnswerCount": "4"}, "18782654": {"ParentId": "18781840", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It is Undefined Behavior, and you might actually run afoul of the optimizers.</p>\n<p>Imagine this simple code example:</p>\n<pre><code>int select(int i) {\n    int values[10] = { .... };\n\n    int const result = values[i];\n\n    if (i &lt; 0 or i &gt; 9) throw std::out_of_range(\"out!\");\n\n    return result;\n}\n</code></pre>\n<p>And now look at it from an optimizer point of view:</p>\n<ul>\n<li><p><code>int values[10] = { ... };</code>: valid indexes are in <code>[0, 9]</code>.</p></li>\n<li><p><code>values[i]</code>: <code>i</code> is an index, thus <code>i</code> is in <code>[0, 9]</code>.</p></li>\n<li><p><code>if (i &lt; 0 or i &gt; 9) throw std::out_of_range(\"out!\");</code>: <code>i</code> is in <code>[0, 9]</code>, never taken</p></li>\n</ul>\n<p>And thus the function rewritten by the optimizer:</p>\n<pre><code>int select(int i) {\n    int values[10] = { ... };\n\n    return values[i];\n}\n</code></pre>\n<p>For more amusing stories about forward and backward propagation of assumptions based on the fact that the developer is not doing anything forbidden, see <a href=\"http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html\" rel=\"noreferrer\">What every C programmer should know about Undefined Behavior: Part 2</a>.</p>\n<p><strong>EDIT:</strong></p>\n<p>Possible work-around: if you know that you will access from <code>-M</code> to <code>+N</code> you can:</p>\n<ul>\n<li>declare the array with appropriate buffer: <code>int values[M + 10 + N]</code></li>\n<li>offset any access: <code>values[M + i]</code></li>\n</ul>\n", "OwnerUserId": "147192", "LastEditorUserId": "147192", "LastEditDate": "2013-09-13T09:24:49.067", "Id": "18782654", "Score": "9", "CreationDate": "2013-09-13T09:19:12.777", "LastActivityDate": "2013-09-13T09:24:49.067"}, "bq_ids": {"n4140": {"so_18781840_18782612_3": {"section_id": 6142, "quality": 1.0, "length": 21}, "so_18781840_18782612_0": {"section_id": 5986, "quality": 0.8333333333333334, "length": 5}, "so_18781840_18782612_2": {"section_id": 6142, "quality": 1.0, "length": 21}, "so_18781840_18782612_1": {"section_id": 5986, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_18781840_18782612_3": {"section_id": 5906, "quality": 1.0, "length": 21}, "so_18781840_18782612_0": {"section_id": 5754, "quality": 0.8333333333333334, "length": 5}, "so_18781840_18782612_2": {"section_id": 5906, "quality": 1.0, "length": 21}, "so_18781840_18782612_1": {"section_id": 5754, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_18781840_18782612_3": {"section_id": 7638, "quality": 0.5238095238095238, "length": 11}, "so_18781840_18782612_0": {"section_id": 7486, "quality": 0.8333333333333334, "length": 5}, "so_18781840_18782612_2": {"section_id": 7638, "quality": 0.5238095238095238, "length": 11}, "so_18781840_18782612_1": {"section_id": 7486, "quality": 0.8333333333333334, "length": 5}}}, "18782612": {"ParentId": "18781840", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>As <a href=\"https://stackoverflow.com/users/1342470/verbose\">verbose</a> <a href=\"https://stackoverflow.com/a/18781897/1137388\">said</a>, this yields undefined behavior. A bit more precision follows.</p>\n<p>5.2.1/1 says</p>\n<blockquote>\n<blockquote>\n<p id=\"so_18781840_18782612_1\">[...] The expression E1[E2] is identical (by definition) to *((E1)+(E2))</p>\n</blockquote>\n</blockquote>\n<p>Hence, <code>val[i]</code> is equivalent to <code>*((val)+i))</code>. Since <code>val</code> is an array, the array-to-pointer conversion (4.2/1) occurs before the addition is performed. Therefore, <code>val[i]</code> is equivalent to <code>*(ptr + i)</code> where <code>ptr</code> is an <code>int*</code> set to <code>&amp;val[0]</code>.</p>\n<p>Then, 5.7/2 explains what <code>ptr + i</code> points to. It also says (emphasis are mine):</p>\n<blockquote>\n<blockquote>\n<p id=\"so_18781840_18782612_3\">[...] If both the <strong>pointer operand</strong> and the <strong>result</strong> point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; <strong>otherwise, the behavior is undefined</strong>.</p>\n</blockquote>\n</blockquote>\n<p>In the case of <code>ptr + i</code>, ptr is the <em>pointer operand</em> and the <em>result</em> is <code>ptr + i</code>. According to the quote above, both should point to an element of the array or to one past the last element. That is, in the OP's case <code>ptr + i</code> is a well defined expression for all <code>i = 0, ..., 10</code>. Finally,  <code>*(ptr + i)</code> is well defined for <code>0 &lt;= i &lt; 10</code> but not for <code>i = 10</code>.</p>\n<p><strong>Edit</strong>:</p>\n<p>I'm puzzled to whether <code>val[10]</code> (or, equivalently, <code>*(ptr + 10)</code>) yields undefined behavior or not (I'm considering C++ not C). In some circumstances this is true (e.g. <code>int x = val[10];</code> is undefined behavior) but in others this is not so clear. For instance,</p>\n<pre><code>int* p = &amp;val[10];\n</code></pre>\n<p>As we have seen, this is equivalent to <code>int* p = &amp;*(ptr + 10);</code> which could be undefined behavior (because it <em>dereferences</em> a pointer to one past the last element of <code>val</code>) or the same as <code>int* p = ptr + 10;</code> which is well defined.</p>\n<p>I found these two references which show how fuzzy this question is:</p>\n<p><a href=\"https://stackoverflow.com/questions/3144904/may-i-take-the-address-of-the-one-past-the-end-element-of-an-array\">May I take the address of the one-past-the-end element of an array?</a></p>\n<p><a href=\"https://stackoverflow.com/questions/988158/take-the-address-of-a-one-past-the-end-array-element-via-subscript-legal-by-the\">Take the address of a one-past-the-end array element via subscript: legal by the C++ Standard or not?</a></p>\n", "OwnerUserId": "1137388", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:25:35.733", "Id": "18782612", "Score": "5", "CreationDate": "2013-09-13T09:17:15.417", "LastActivityDate": "2013-09-13T13:01:59.647"}});