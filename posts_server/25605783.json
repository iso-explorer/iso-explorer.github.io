post_cb({"bq_ids": {"n4140": {"so_25605783_25605783_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 5313}}, "n3337": {"so_25605783_25605783_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 5110}}, "n4659": {"so_25605783_25605783_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 6737}}}, "25608217": {"Id": "25608217", "PostTypeId": "2", "Body": "<p><code>new</code> and <code>delete</code> are the overloadable operators whose name is formed of a single token.</p>\n<p>The differences between the productions <em>preprocessing-op-or-punc</em> (<strong>[lex.operators]</strong>/1) and <em>operator</em> (<strong>[over.oper]</strong>/1) are the removal of the punctuators and preprocessing operators <code>{ } [ ] # ## ( ) ; : ...</code>, the digraph alternate tokens <code>&lt;: :&gt;</code> etc., the non-overloadable operators <code>. .* :: ?</code>, the lexical keyword alternate tokens <code>and and_eq</code> etc., and the addition of the multitoken operators <code>new[]</code>, <code>delete[]</code>, <code>()</code>, and <code>[]</code>. <code>new</code>, <code>delete</code>, <code>new[]</code> and <code>delete[]</code> are included in <em>operator</em> so that their <em>operator-function-id</em>s (<code>operator new</code> etc.) can follow the rules of other overloadable operators without having to duplicate language, keep it updated, and invent a new production (<em>dynamic-function-id</em>?) to occur everywhere <em>operator-function-id</em> occurs. Note that non-overloadable operators whose name has the lexical form of an identifier (<code>sizeof</code>, <code>typeid</code>, etc.) are not included in <em>operator</em>, and thus nor in <em>preprocessing-op-or-punc</em>.</p>\n<p>While this introduces an ambiguity between the <em>identifier</em> and <em>preprocessing-op-or-punc</em> productions, this does not affect phase 3 translation in any way. For phase 7, where the ambiguity is between <em>keyword</em> and <em>operator</em>, this is again not a problem, since the <em>operator</em> production and others that include the tokens <code>new</code> and <code>delete</code> e.g. <em>new-expression</em> (<strong>[expr.new]</strong>) do not reference the <em>keyword</em> or <em>operator</em> productions but instead contain the relevant tokens directly.</p>\n", "LastActivityDate": "2014-09-01T14:40:21.043", "CommentCount": "4", "CreationDate": "2014-09-01T14:40:21.043", "ParentId": "25605783", "Score": "2", "OwnerUserId": "567292"}, "25605783": {"ViewCount": "327", "Body": "<p>I am assuming that C++ token types (as per <code>2.7 Tokens [lex.token]</code>) do not form an intersecting sets (i.e. <code>int</code> is considered to belong only to the <code>keyword</code> token type and not both <code>keyword</code> and <code>identifier</code> token types). Taking that into account the following question arises.</p>\n<p>C++11 quote:</p>\n<blockquote>\n<p id=\"so_25605783_25605783_0\">2.2 Phases of translation [lex.phases]</p>\n<p id=\"so_25605783_25605783_1\">7 White-space characters separating tokens are no longer significant. Each preprocessing token is converted into a token. (2.7). The resulting tokens are syntactically and semantically analyzed and translated as a translation unit.</p>\n</blockquote>\n<p>So, the syntactic and semantic analysis of the C++ text is preformed AFTER the text is spilt into tokens.</p>\n<p>Another C++11 quote:</p>\n<blockquote>\n<p id=\"so_25605783_25605783_2\">2.7 Tokens [lex.token]</p>\n<p id=\"so_25605783_25605783_3\">token:<br/>identi\ufb01er<br/>keyword<br/>literal<br/>operator<br/>punctuator</p>\n</blockquote>\n<p>Nowhere in the standard I have found the definition for the <code>operator</code> and <code>punctuator</code> grammar non-terminals. Anyway, according to the <code>2.12 Keywords</code> and <code>2.13 Operators and punctuators</code> the token <code>new</code> can be either a <code>keyword</code> or an <code>operator</code> token. How could C++ compiler can possibly determine the type of the <code>new</code> token BEFORE performing syntactic and semantic analysis of the code? </p>\n", "AcceptedAnswerId": "25608217", "Title": "C++ token types", "CreationDate": "2014-09-01T12:23:14.403", "Id": "25605783", "CommentCount": "9", "LastEditDate": "2014-09-01T12:34:52.337", "PostTypeId": "1", "LastEditorUserId": "1782465", "LastActivityDate": "2014-09-01T14:40:21.043", "Score": "1", "OwnerUserId": "1997715", "Tags": "<c++><token><language-lawyer>", "AnswerCount": "1"}});