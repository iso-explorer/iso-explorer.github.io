post_cb({"bq_ids": {"n4140": {"so_32599788_32601159_1": {"length": 40, "quality": 0.975609756097561, "section_id": 7240}}, "n3337": {"so_32599788_32601159_1": {"length": 40, "quality": 0.975609756097561, "section_id": 6984}}, "n4659": {"so_32599788_32601159_1": {"length": 37, "quality": 0.9024390243902439, "section_id": 8749}}}, "32599788": {"ViewCount": "549", "Body": "<p>There is a Boost tutorial giving approximately the following code, slightly modified for my question:</p>\n<pre><code>#include &lt;boost/align/aligned_allocator.hpp&gt;\n#include &lt;vector&gt;\nint main()\n{\n  std::vector&lt;int, boost::alignment::\n    aligned_allocator&lt;int, 16&gt; &gt; v(100);\n}\n</code></pre>\n<p>In this example, an alignment parameter of 16 is given. Does this indicate 16 bytes of alignment, or 16*sizeof(int) bytes of alignment?</p>\n", "Title": "What does the alignment parameter for Boost aligned_allocator mean?", "CreationDate": "2015-09-16T04:27:38.433", "LastActivityDate": "2015-09-16T06:46:11.313", "CommentCount": "0", "PostTypeId": "1", "Id": "32599788", "Score": "1", "OwnerUserId": "3971332", "Tags": "<c++><boost><memory-alignment>", "AnswerCount": "2"}, "32601481": {"Id": "32601481", "PostTypeId": "2", "Body": "<p>It would represent 16 bytes of alignment.</p>\n<p>On some processors, access to a non-aligned memory address can result in an exception. On others, a non-aligned memory access might work, but may be suboptimal, possibly requiring extra reads of memory at aligned addresses. The actual alignment needed or desired varies depending on context.</p>\n<p>For example, on a 32-bit x86 processor a 32-bit (4 byte) non-aligned access can result in two aligned memory accesses. If a 4 byte read was done at address 1, the processor may need to read bytes 0..3, followed by a read of bytes 4..7, and then combine bytes 1..4 into the result, discarding the extra data read.</p>\n<p>For SIMD instructions the alignment is greater. A 64-bit MMX instruction should access memory that is 64-bit (8 byte) aligned. A 128-bit XMM instruction should access memory that is 128-bit (16 byte) aligned.</p>\n<p>On a SPARC processor an unaligned memory access would result in a processor exception. I believe ARM also generates exceptions for unaligned access. On x86 you can also get exceptions in some cases. In particular, if the stack is not properly aligned, it can cause a program crash. A detail that is usually handled by the compiler.</p>\n", "LastActivityDate": "2015-09-16T06:46:11.313", "CommentCount": "0", "CreationDate": "2015-09-16T06:46:11.313", "ParentId": "32599788", "Score": "2", "OwnerUserId": "5333629"}, "32601159": {"Id": "32601159", "PostTypeId": "2", "Body": "<p>The number 16 refers to the number of <strong>bytes</strong>. From the <a href=\"http://www.boost.org/doc/libs/1_58_0/doc/html/align/vocabulary.html\" rel=\"nofollow\"><strong>Boost.Align documentation</strong></a> (that uses the same terminology as the C++ Standard)</p>\n<blockquote>\n<p id=\"so_32599788_32601159_0\"><strong>[basic.align]</strong> </p>\n<p id=\"so_32599788_32601159_1\">Object types have alignment requirements which place\n  restrictions on the addresses at which an object of that type may be\n  allocated. An alignment is an implementation-defined integer value\n  representing <strong>the number of bytes</strong> between successive addresses at which\n  a given object can be allocated. An object type imposes an alignment\n  requirement on every object of that type; stricter alignment can be\n  requested using the alignment specifier.</p>\n</blockquote>\n", "LastActivityDate": "2015-09-16T06:24:56.747", "CommentCount": "0", "CreationDate": "2015-09-16T06:24:56.747", "ParentId": "32599788", "Score": "1", "OwnerUserId": "819272"}});