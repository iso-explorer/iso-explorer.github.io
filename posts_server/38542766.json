post_cb({"38543182": {"ParentId": "38542766", "PostTypeId": "2", "CommentCount": "1", "Body": "<p><code>a-&gt;b</code> is defined as <code>(*a).b</code> if and only if <code>a</code> is a pointer.</p>\n<p>If <code>a</code> is not a pointer, it is defined as <code>(a.operator-&gt;())-&gt;b</code>.  Now typically <code>operator-&gt;</code> returns a pointer, so it then does a <code>(*(a.operator-&gt;())).b</code> and done.</p>\n<p>But if it instead returns a non-pointer, this definition is recursive.</p>\n<p>There is no similar recursive definition for unary <code>operator*</code>.</p>\n<p>In short, the standard says so.  Why?  Because the writers thought it would be both elegant and useful.</p>\n<p>As an aside, there is an active proposal for <code>operator.</code> which will probably be in C++ as of 2021.  This would permit <code>(*a).b</code> to behave the same as <code>a-&gt;b</code>.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2016-07-23T16:45:46.703", "Id": "38543182", "Score": "2", "CreationDate": "2016-07-23T15:04:01.953", "LastActivityDate": "2016-07-23T16:45:46.703"}, "38542766": {"CommentCount": "3", "AcceptedAnswerId": "38543182", "PostTypeId": "1", "LastEditorUserId": "1558037", "CreationDate": "2016-07-23T14:17:55.800", "LastActivityDate": "2016-07-23T16:45:46.703", "LastEditDate": "2016-07-23T15:31:31.150", "ViewCount": "95", "FavoriteCount": "1", "Title": "Why the `T* operator->()` is applied repeatedly even if written once?", "Id": "38542766", "Score": "0", "Body": "<p>Why the <code>T* operator-&gt;()</code> is applied repeatedly even if written once? But another <code>T&amp; operator*()</code> is applied once, and should be written many times.</p>\n<p>As known there is Execute-Around Pointer Idiom in C++. <a href=\"https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Execute-Around_Pointer\" rel=\"nofollow\">More C++ Idioms/Execute-Around Pointer</a></p>\n<p>Provide a smart pointer object that transparently executes actions before and after each function call on an object, given that the actions performed are the same for all functions. And before and after each treatment to member variable of a class. For example we can performs:</p>\n<ul>\n<li>lock mutex</li>\n<li>log action</li>\n<li>visualize changing data</li>\n</ul>\n<p>I added some in <code>main()</code> to <a href=\"https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Execute-Around_Pointer#Solution_and_Sample_Code\" rel=\"nofollow\">this example</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nclass VisualizableVector {\n  public:\n    class proxy {\n      public:\n        proxy (std::vector&lt;int&gt; *v) : vect (v) {\n            std::cout &lt;&lt; \"Before size is: \" &lt;&lt; vect-&gt;size() &lt;&lt; std::endl;\n        }\n        std::vector&lt;int&gt; * operator -&gt; () { return vect; }\n        std::vector&lt;int&gt; &amp; operator * () { return *vect; }\n        ~proxy () { std::cout &lt;&lt; \"After size is: \" &lt;&lt; vect-&gt;size() &lt;&lt; std::endl; }\n      private:\n        std::vector &lt;int&gt; * vect;\n    };        \n    VisualizableVector (std::vector&lt;int&gt; *v) : vect(v) {}            \n    ~VisualizableVector () { delete vect; }   \n    proxy operator -&gt; () { return proxy (vect); }\n    proxy operator * () { return proxy (vect); }\n  private:\n    std::vector &lt;int&gt; * vect;\n};\n\nint main()\n{\n  VisualizableVector vecc (new std::vector&lt;int&gt;);\n\n  vecc-&gt;push_back (10);         // 1. Note use of -&gt; operator instead of . operator      \n  vecc-&gt;push_back (20);         // 2. ok      \n  (*vecc)-&gt;push_back (30);      // 3. ok      \n  // (*vecc).push_back (40);    // 4. error      \n  (**vecc).push_back (50);      // 5. ok      \n  // vecc-&gt;-&gt;push_back (60);    // 6. error     \n}\n</code></pre>\n<p>Online compiler result: <a href=\"http://ideone.com/cXGdxW\" rel=\"nofollow\">http://ideone.com/cXGdxW</a></p>\n<p>Why do we need to write twice <code>**</code>, but only once <code>-&gt;</code> ? </p>\n<p>Its operator return the same thing <code>proxy</code>:</p>\n<pre><code>    proxy operator -&gt; () { return proxy (vect); }\n    proxy operator * () { return proxy (vect); }\n</code></pre>\n<p>But why do we need to use <code>*</code> again, but we shouldn't use <code>-&gt;</code> again?:</p>\n<pre><code>  vecc-&gt;push_back (20);     // 2. ok      (vecc-&gt;) is proxy\n  (**vecc).push_back (50);  // 5. ok      (*vecc) is proxy\n</code></pre>\n<p>Why not <code>vecc-&gt;-&gt;push_back (20);</code>?</p>\n<p>Is there anything about this in the standard C++ (03/11/14)?</p>\n<p><strong>UPDATE:</strong></p>\n<p>In different cases we should use 1,2 or 3 <code>operator-&gt;</code>s : <a href=\"http://ideone.com/89kfYF\" rel=\"nofollow\">http://ideone.com/89kfYF</a></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;    \nclass VisualizableVector {\n  public:\n    class proxy {\n      public:\n        proxy (std::vector&lt;int&gt; *v) : vect (v) {\n            std::cout &lt;&lt; \"Before size is: \" &lt;&lt; vect-&gt;size() &lt;&lt; std::endl;\n        }\n        std::vector&lt;int&gt; * operator -&gt; () { return vect; }\n        std::vector&lt;int&gt; &amp; operator * () { return *vect; }\n        ~proxy () { std::cout &lt;&lt; \"After size is: \" &lt;&lt; vect-&gt;size() &lt;&lt; std::endl; }\n      private:\n        std::vector &lt;int&gt; * vect;\n    };        \n    VisualizableVector (std::vector&lt;int&gt; *v) : vect(v) {}            \n    ~VisualizableVector () { delete vect; }   \n    proxy operator -&gt; () { return proxy (vect); }\n    proxy operator * () { return proxy (vect); }\n  private:\n    std::vector &lt;int&gt; * vect;\n};\n\nint main()\n{\n  VisualizableVector vecc (new std::vector&lt;int&gt;);\n\n    vecc-&gt;push_back(30);            // ok       // one -&gt;\n  //vecc.operator-&gt;().push_back(30);// error    // one -&gt;\n\n  //vecc-&gt;-&gt;push_back(30);          // error    // two -&gt;\n  vecc.operator-&gt;()-&gt;push_back(30); // ok       // two -&gt;\n\n  auto proxy3 = vecc.operator-&gt;();      // 1st operator-&gt;()\n  auto pointer = proxy3.operator-&gt;();   // 2nd operator-&gt;()\n  pointer-&gt;push_back(30);               // 3rd operator-&gt;()      \n  return 0;\n}\n</code></pre>\n<p>Page 327: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow\">Working Draft, Standard for Programming Language C++ 2014-11-19</a></p>\n<blockquote>\n<p id=\"so_38542766_38542766_0\">13.5.6 Class member access [over.ref] 1 operator-&gt; shall be a non-static member function taking no parameters. It implements the\n  class member access syntax that uses -&gt;. postfix-expression -&gt;\n  templateopt id-expression postfix-expression -&gt; pseudo-destructor-name\n  An expression x-&gt;m is interpreted as (x.operator-&gt;())-&gt;m for a class\n  object x of type T if T::operator-&gt;() exists and if the operator is\n  selected as the best match function by the overload resolution\n  mechanism (13.3).</p>\n</blockquote>\n<p>I.e. <code>x-&gt;m</code> is <code>(x.operator-&gt;())-&gt;m</code>.</p>\n", "Tags": "<c++><c++11><design-patterns><dereference><idioms>", "OwnerUserId": "1558037", "AnswerCount": "2"}, "38543020": {"ParentId": "38542766", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Here are those two cases broken down somewhat:</p>\n<pre><code>(*vecc)-&gt;push_back(30);      // 3. ok      \nVisualizableVector::proxy proxy3 = vecc.operator*();\nstd::vector&lt;int&gt; *pointer = proxy3.operator-&gt;();\npointer-&gt;push_back(30);\n\n(**vecc).push_back(50);      // 5. ok\nVisualizableVector::proxy proxy5 = vecc.operator*();\nstd::vector&lt;int&gt; &amp;reference = proxy5.operator*();\nreference.push_back(50);\n</code></pre>\n<p>The reason you need to dereference with * twice is because proxy::operator * () returns a pointer to the underlying type.  </p>\n<p>When you have a pointer, you can call its members directly with \"-&gt;\" or you can dereference it with \"*\" then use \".\"  That remains true regardless of where the pointer came from.       </p>\n<p>Since you got the pointer from *, and you use * on that pointer, that's why you used two *'s.</p>\n", "OwnerUserId": "1766544", "LastEditorUserId": "1766544", "LastEditDate": "2016-07-23T14:54:19.833", "Id": "38543020", "Score": "1", "CreationDate": "2016-07-23T14:47:03.350", "LastActivityDate": "2016-07-23T14:54:19.833"}, "bq_ids": {"n4140": {"so_38542766_38542766_0": {"section_id": 664, "quality": 0.717948717948718, "length": 28}}, "n3337": {"so_38542766_38542766_0": {"section_id": 654, "quality": 0.717948717948718, "length": 28}}, "n4659": {"so_38542766_38542766_0": {"section_id": 692, "quality": 0.717948717948718, "length": 28}}}});