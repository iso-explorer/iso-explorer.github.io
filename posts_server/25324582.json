post_cb({"bq_ids": {"n4140": {"so_25324582_25325041_7": {"length": 11, "quality": 0.9166666666666666, "section_id": 464}, "so_25324582_25325041_5": {"length": 16, "quality": 0.9411764705882353, "section_id": 6952}, "so_25324582_25325041_0": {"length": 15, "quality": 0.9375, "section_id": 6985}, "so_25324582_25325041_2": {"length": 4, "quality": 0.8, "section_id": 6949}, "so_25324582_25325041_9": {"length": 10, "quality": 1.0, "section_id": 369}}, "n3337": {"so_25324582_25325041_7": {"length": 11, "quality": 0.9166666666666666, "section_id": 455}, "so_25324582_25325041_5": {"length": 16, "quality": 0.9411764705882353, "section_id": 6699}, "so_25324582_25325041_0": {"length": 15, "quality": 0.9375, "section_id": 6731}, "so_25324582_25325041_2": {"length": 5, "quality": 1.0, "section_id": 6697}, "so_25324582_25325041_9": {"length": 10, "quality": 1.0, "section_id": 359}}, "n4659": {"so_25324582_25325041_7": {"length": 11, "quality": 0.9166666666666666, "section_id": 487}, "so_25324582_25325041_5": {"length": 11, "quality": 0.6470588235294118, "section_id": 8449}, "so_25324582_25325041_0": {"length": 15, "quality": 0.9375, "section_id": 8483}, "so_25324582_25325041_2": {"length": 4, "quality": 0.8, "section_id": 8446}, "so_25324582_25325041_9": {"length": 10, "quality": 1.0, "section_id": 381}}}, "25325041": {"Id": "25325041", "PostTypeId": "2", "Body": "<p>The standard states:</p>\n<blockquote>\n<p id=\"so_25324582_25325041_0\">For each distinct base class that is specified virtual, the most derived object shall contain a single base class subobject of that type.</p>\n<p id=\"so_25324582_25325041_1\">\u00a710.1 [class.mi]</p>\n</blockquote>\n<p>Also, with respect to <code>std::throw_with_nested</code>:</p>\n<blockquote>\n<p id=\"so_25324582_25325041_2\"><code>[[noreturn]] template &lt;class T&gt; void throw_with_nested(T&amp;&amp; t);</code></p>\n<p id=\"so_25324582_25325041_3\">Let <code>U</code> be <code>remove_reference&lt;T&gt;::type</code>.</p>\n<p id=\"so_25324582_25325041_4\"><em>Requires:</em> <code>U</code> shall be <code>CopyConstructible</code>.</p>\n<p id=\"so_25324582_25325041_5\"><em>Throws:</em> if <code>U</code> is a non-union class type not derived from <code>nested_exception</code>, an exception of unspecified type that is publicly derived from both <code>U</code> and <code>nested_exception</code> and constructed from <code>std::forward&lt;T&gt;(t)</code>, otherwise <code>std::forward&lt;T&gt;(t)</code>.</p>\n<p id=\"so_25324582_25325041_6\">\u00a718.8.6 [except.nested]</p>\n</blockquote>\n<p>If you look in <code>bits/nested_exception.h</code>, you'll find the following, which is the base class that the library creates for <code>std::throw_with_nested</code> in libstdc++:</p>\n<pre><code>template&lt;typename _Except&gt;\nstruct _Nested_exception : public _Except, public nested_exception\n{\n  explicit _Nested_exception(_Except&amp;&amp; __ex)\n  : _Except(static_cast&lt;_Except&amp;&amp;&gt;(__ex))\n  { }\n};\n</code></pre>\n<p>This derives from your <code>Derived</code> class, and attempts to initialize itself with your copy or move constructor, both of which are implicitly defined.</p>\n<p>In the case of non-virtual inheritance, this would be fine, since base classes are recursively copied or moved by implicit copy/move constructors, as laid out in the standard:</p>\n<blockquote>\n<p id=\"so_25324582_25325041_7\">The implicitly-defined copy/move constructor for a non-union class <code>X</code> performs a memberwise copy/move of its bases and members.</p>\n<p id=\"so_25324582_25325041_8\">\u00a712.8 [class.copy]</p>\n</blockquote>\n<p>However, because of the virtual inheritance, and \u00a710.1 [class.mi] (quoted above), it is the responsibility of the base class (in this case <code>_Nested_exception</code> to initialize <code>Base</code>, <strong>not</strong> the responsibility of your <code>Derived</code> class.</p>\n<p>Therefore, an attempt is made to find a default constructor, which fails, because it is implicitly deleted, because there is another user-provided constructor, and the standard states:</p>\n<blockquote>\n<p id=\"so_25324582_25325041_9\">If there is no user-declared constructor for class X, a constructor having no parameters is implicitly declared as defaulted.</p>\n<p id=\"so_25324582_25325041_10\">\u00a712.1 [class.ctor]</p>\n</blockquote>\n<p>Accordingly this code is <strong>correctly rejected by the compiler</strong>.</p>\n", "LastEditorUserId": "1007504", "LastActivityDate": "2014-08-15T11:11:18.013", "Score": "1", "CreationDate": "2014-08-15T10:39:10.193", "ParentId": "25324582", "CommentCount": "7", "OwnerUserId": "1007504", "LastEditDate": "2014-08-15T11:11:18.013"}, "25324582": {"ViewCount": "98", "Body": "<p>Why does this not compile (tried with Clang 3.4.2 and GCC versions 4.7.4, 4.8.3 and 4.9.1):</p>\n<pre><code>#include &lt;exception&gt;\n\nstruct Base {\n  inline Base(int) {}\n  virtual void f() {}\n};\n\nstruct Derived: virtual Base {\n  inline Derived() : Base(42) {}\n};\n\nint main() {\n  std::throw_with_nested(Derived());\n  return 0;\n}\n</code></pre>\n<p>Errors from GCC 4.9.1:</p>\n<pre><code>In file included from /usr/lib/gcc/x86_64-pc-linux-gnu/4.9.1/include/g++-v4/exception:163:0,\n                from test.cpp:1:\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.1/include/g++-v4/bits/nested_exception.h: In instantiation of 'std::_Nested_exception&lt;_Except&gt;::_Nested_exception(_Except&amp;&amp;) [with _Except = Derived]':\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.1/include/g++-v4/bits/nested_exception.h:126:60:   required from 'void std::__throw_with_nested(_Ex&amp;&amp;, ...) [with _Ex = Derived]'\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.1/include/g++-v4/bits/nested_exception.h:140:58:   required from 'void std::throw_with_nested(_Ex) [with _Ex = Derived]'\ntest.cpp:13:35:   required from here\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.1/include/g++-v4/bits/nested_exception.h:81:45: error: no matching function for call to 'Base::Base()'\n      : _Except(static_cast&lt;_Except&amp;&amp;&gt;(__ex))\n                                            ^\n/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.1/include/g++-v4/bits/nested_exception.h:81:45: note: candidates are:\ntest.cpp:4:10: note: Base::Base(int)\n  inline Base(int) {}\n          ^\ntest.cpp:4:10: note:   candidate expects 1 argument, 0 provided\ntest.cpp:3:8: note: constexpr Base::Base(const Base&amp;)\nstruct Base {\n        ^\ntest.cpp:3:8: note:   candidate expects 1 argument, 0 provided\ntest.cpp:3:8: note: constexpr Base::Base(Base&amp;&amp;)\ntest.cpp:3:8: note:   candidate expects 1 argument, 0 provided\n</code></pre>\n<p>If I omit the <code>virtual</code> keyword I get no errors. Is this a GCC and Clang or libstd++ bug, or am I doing something wrong?</p>\n<p>PS: Note that <code>virtual void f() {}</code> is a workaround for <a href=\"https://stackoverflow.com/questions/25324262/stdthrow-with-nested-expects-polymorphic-type-in-c11\">this</a> <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=62154\" rel=\"nofollow\">bug</a>.</p>\n", "AcceptedAnswerId": "25325041", "Title": "std::throw_with_nested expects default constructor for virtual base class of Exception?", "CreationDate": "2014-08-15T10:01:17.037", "Id": "25324582", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2014-08-15T11:11:18.013", "Score": "0", "OwnerUserId": "3919155", "Tags": "<c++><exception><c++11><exception-handling><libstdc++>", "AnswerCount": "2"}, "25324878": {"Id": "25324878", "PostTypeId": "2", "Body": "<p>The issue is that when you have virtual inheritance, the last derived class is responsible for constructing the base.</p>\n<p>In this case, the library is trying to create more classes that derive from yours and then cannot construct them.</p>\n<p>When you remove the \"virtual\" inheritence, the final classes can derive from yours without an issue.</p>\n<p>The implementation \"code\" that is hitting the error message...</p>\n<pre><code>template&lt;typename _Except&gt;\nstruct _Nested_exception : public _Except, public nested_exception \n{\n  explicit _Nested_exception(_Except&amp;&amp; __ex)\n  : _Except(static_cast&lt;_Except&amp;&amp;&gt;(__ex))\n { }\n};\n</code></pre>\n<p>so it needs in its constructor to construct a <code>Base</code> as it is now the most derived class, and isn't able to dp so correctly.</p>\n", "LastEditorUserId": "442284", "LastActivityDate": "2014-08-15T11:00:27.510", "Score": "2", "CreationDate": "2014-08-15T10:25:19.827", "ParentId": "25324582", "CommentCount": "0", "OwnerUserId": "442284", "LastEditDate": "2014-08-15T11:00:27.510"}});