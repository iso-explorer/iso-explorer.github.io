post_cb({"8553407": {"ParentId": "8553357", "LastEditDate": "2011-12-18T20:27:57.293", "CommentCount": "5", "CreationDate": "2011-12-18T17:27:09.783", "OwnerUserId": "596781", "LastEditorUserId": "596781", "PostTypeId": "2", "Id": "8553407", "Score": "3", "Body": "<p>The program's scope unwinding, whether through normal execution or via try/throw/catch, only happens if the application exits by returning from <code>main</code>. If the application exits via an exception (or via <code>abort()</code> or <code>terminate()</code>), no unwinding happens and no destructors get called.</p>\n<p>This pertains to both automatic and static objects.</p>\n", "LastActivityDate": "2011-12-18T20:27:57.293"}, "8554056": {"ParentId": "8553357", "LastEditDate": "2011-12-18T19:21:19.427", "CommentCount": "2", "CreationDate": "2011-12-18T19:04:37.663", "OwnerUserId": "12711", "LastEditorUserId": "12711", "PostTypeId": "2", "Id": "8554056", "Score": "5", "Body": "<p>Here are the details of what's going on from the C++03 standard.</p>\n<ul>\n<li><p>From 15.3/9 Handling Exceptions</p>\n<blockquote>\n<p id=\"so_8553357_8554056_0\">If no matching handler is found in a program, the function terminate() is called;</p>\n</blockquote></li>\n<li><p>From 18.6.3 Abnormal termination:</p>\n<blockquote>\n<p id=\"so_8553357_8554056_1\">The implementation\u2019s default terminate_handler calls abort().</p>\n</blockquote></li>\n<li><p>And from 3.6.3/4 Termination:</p>\n<blockquote>\n<p id=\"so_8553357_8554056_2\">Calling the function <code>void abort();</code> declared in <code>&lt;cstdlib&gt;</code> terminates the program without executing destructors for objects of automatic or static storage duration and without calling the functions passed to atexit().</p>\n</blockquote></li>\n</ul>\n<p><strike>So that's why your <code>foos</code> object isn't being destructed (it has static storage duration). However, even if you change it so that it's a local variable (having automatic duration), that might not fix the problem (emphasis added):</strike></p>\n<p>So for <code>static duration</code> objects, destructors aren't called unless you change the terminate handler (maybe to have it call <code>exit()</code> instead of <code>abort()</code>). However, for automatic objects, there remains a possible problem (emphasis added):</p>\n<blockquote>\n<p id=\"so_8553357_8554056_3\">15.5.1/1 The <code>terminate()</code> function</p>\n<p id=\"so_8553357_8554056_4\">In the situation where no matching handler is found, it is\n  <strong>implementation-defined</strong> whether or not the stack is unwound before\n  terminate() is called.  In all other situations, the stack shall not\n  be unwound before terminate() is called.</p>\n</blockquote>\n", "LastActivityDate": "2011-12-18T19:21:19.427"}, "8553357": {"CommentCount": "0", "ViewCount": "265", "PostTypeId": "1", "LastEditorUserId": "90527", "LastActivityDate": "2011-12-20T18:53:02.400", "Body": "<p>I have the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;tr1/memory&gt;\n\nstruct FooError {};\n\nstruct Foo\n{\n    ~Foo() { std::cerr &lt;&lt; \"~Foo() executed\" &lt;&lt; std::endl; }\n    explicit Foo(unsigned int index) { if (5 == index) throw FooError(index); };\n};\n\n\nint main() {\n    typedef std::tr1::shared_ptr&lt;Foo&gt; FooPtr;\n    std::vector&lt;FooPtr&gt; foos;\n    for (unsigned int index = 0; index &lt; 20; ++index)\n    {\n        try\n        {\n            foos.push_back(FooPtr(new Foo(index)));\n        }\n        catch (const FooError&amp;)\n        {\n            std::cerr &lt;&lt; \"FooError caught\" &lt;&lt; std::endl;\n        }\n    }\n}\n</code></pre>\n<p>I see a set of <code>~Foo()</code> executed when there are <code>try{} catch{}</code> blocks. When there are no exception handlers, nothing is printed. Does it mean that destructors of stack-allocated objects are called when exception is handled? Or is nothing printed because of std::cerr buffering issues?</p>\n", "Title": "Why aren't destructors called when exception isn't caught within main?", "FavoriteCount": "1", "LastEditDate": "2011-12-20T18:53:02.400", "Id": "8553357", "Score": "2", "CreationDate": "2011-12-18T17:17:01.693", "Tags": "<c++><exception><destructor><stack-unwinding>", "OwnerUserId": "1077709", "AnswerCount": "4"}, "8553416": {"ParentId": "8553357", "CommentCount": "1", "Body": "<p>The destructors are being called (from the vector) after the loop, right before the program exits. </p>\n<p>If you don't catch the exception, terminate is called which aborts the program without calling destructors.</p>\n", "OwnerUserId": "964135", "PostTypeId": "2", "Id": "8553416", "Score": "2", "CreationDate": "2011-12-18T17:28:39.243", "LastActivityDate": "2011-12-18T17:28:39.243"}, "bq_ids": {"n4140": {"so_8553357_8554056_2": {"section_id": 6801, "quality": 0.7222222222222222, "length": 13}, "so_8553357_8554056_0": {"section_id": 3354, "quality": 0.8333333333333334, "length": 5}, "so_8553357_8554056_4": {"section_id": 3383, "quality": 0.85, "length": 17}, "so_8553357_8554056_1": {"section_id": 6924, "quality": 0.8333333333333334, "length": 5}}, "n3337": {"so_8553357_8554056_2": {"section_id": 6556, "quality": 0.7222222222222222, "length": 13}, "so_8553357_8554056_0": {"section_id": 3224, "quality": 0.8333333333333334, "length": 5}, "so_8553357_8554056_4": {"section_id": 3252, "quality": 0.85, "length": 17}, "so_8553357_8554056_1": {"section_id": 6672, "quality": 0.8333333333333334, "length": 5}}, "n4659": {"so_8553357_8554056_2": {"section_id": 8290, "quality": 0.6111111111111112, "length": 11}, "so_8553357_8554056_0": {"section_id": 4121, "quality": 0.8333333333333334, "length": 5}, "so_8553357_8554056_4": {"section_id": 4143, "quality": 0.85, "length": 17}, "so_8553357_8554056_1": {"section_id": 8421, "quality": 0.8333333333333334, "length": 5}}}, "8553370": {"ParentId": "8553357", "CommentCount": "5", "Body": "<p>If you catch the exception the deallocators will be called to clean up the memory. If you dont catch the exception the application will just quit.</p>\n<p>A vector actually stores all its data on the heap by the way; that is why it is resizable. You can think of the data on the stack as being a pointer to the memory on the heap (which is hidden from you).</p>\n", "OwnerUserId": "604653", "PostTypeId": "2", "Id": "8553370", "Score": "1", "CreationDate": "2011-12-18T17:20:56.030", "LastActivityDate": "2011-12-18T17:20:56.030"}});