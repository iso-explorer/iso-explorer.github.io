post_cb({"3788005": {"CommentCount": "13", "ViewCount": "282", "PostTypeId": "1", "LastEditorUserId": "4370109", "CreationDate": "2010-09-24T14:25:04.653", "LastActivityDate": "2015-07-09T15:26:21.417", "Title": "Deleting object from a stack", "AcceptedAnswerId": "3788075", "LastEditDate": "2015-07-09T15:26:21.417", "Id": "3788005", "Score": "0", "Body": "<p>Is it bad/illegal C++ to delete manually objects from a stack or there are situation when it is acceptable? </p>\n<p><em>Edit</em> </p>\n<pre><code>Constructor(pointer parent, pointer left, pointer right):parent_(parent),left_(left), right_(right)\n{   }\n\n   ~Constructor()\n        {\n        delete parent_;\n        delete left_;\n        delete right_;\n        }\n\n\nmain()\n{\nObject parent;\nObject left;\nObject right;\nConstructor c(&amp;parent,&amp;left,&amp;right);\n}\n</code></pre>\n<p><strong>Is there any way to check if object is on heap or on stack?</strong></p>\n", "Tags": "<c++><delete-operator>", "OwnerUserId": "207177", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_3788005_3788075_0": {"section_id": 6105, "quality": 0.9, "length": 9}}, "n3337": {"so_3788005_3788075_0": {"section_id": 5871, "quality": 0.9, "length": 9}}, "n4659": {"so_3788005_3788075_0": {"section_id": 7602, "quality": 0.9, "length": 9}}}, "3788132": {"ParentId": "3788005", "CommentCount": "5", "Body": "<p>There is one corner case, which I can think of, where it is OK to delete the local object manually.</p>\n<pre><code>struct A{\n    A(){}\n    int x;\n    ~A(){}\n};\n\nint main(){\n    char buf[sizeof(A)];\n    A *p = new(buf)A();\n    p-&gt;~A();\n}\n</code></pre>\n", "OwnerUserId": "418110", "PostTypeId": "2", "Id": "3788132", "Score": "1", "CreationDate": "2010-09-24T14:38:22.133", "LastActivityDate": "2010-09-24T14:38:22.133"}, "3788075": {"ParentId": "3788005", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>Yes, it is bad to <code>delete</code> automatic variables (ie, objects on the stack).  I suppose there is still no \"never\" in programming, but I can't think of a time/reason why you would want to do this.</p>\n<p>What scenario are you thinking of?</p>\n<p>EDIT:  Actually, not only is it bad, it is illegal:</p>\n<h2>5.3.5 Delete</h2>\n<blockquote>\n<p id=\"so_3788005_3788075_0\">1: The delete-expression operator\n  destroys a most derived object (1.8)\n  or array created by a new-expression.</p>\n</blockquote>\n", "OwnerUserId": "241536", "LastEditorUserId": "241536", "LastEditDate": "2010-09-24T14:43:31.973", "Id": "3788075", "Score": "4", "CreationDate": "2010-09-24T14:32:32.097", "LastActivityDate": "2010-09-24T14:43:31.973"}, "3788037": {"ParentId": "3788005", "CommentCount": "0", "Body": "<p>You are only allowed to <code>delete</code> those objects that have been allocated with <code>new</code>. If you try to call <code>delete</code> on a pointer pointing to an object on the stack, you will probably crash your program.</p>\n", "OwnerUserId": "56338", "PostTypeId": "2", "Id": "3788037", "Score": "12", "CreationDate": "2010-09-24T14:28:11.090", "LastActivityDate": "2010-09-24T14:28:11.090"}, "3788738": {"ParentId": "3788005", "CommentCount": "1", "Body": "<p>Use references instead of pointers.</p>\n", "OwnerUserId": "371653", "PostTypeId": "2", "Id": "3788738", "Score": "0", "CreationDate": "2010-09-24T15:44:58.223", "LastActivityDate": "2010-09-24T15:44:58.223"}, "3788047": {"ParentId": "3788005", "CommentCount": "0", "Body": "<p>Usually you will have a method which allows you to edit the stack and usually the actual stack isn't exposed to the outside world to be manipulated outside the accessors defined on the class.  So I'd say it is bad because there could be other properties and state inside the object representing the stack that become unsynced when you remove items manually.</p>\n", "OwnerUserId": "77538", "PostTypeId": "2", "Id": "3788047", "Score": "0", "CreationDate": "2010-09-24T14:29:37.063", "LastActivityDate": "2010-09-24T14:29:37.063"}, "3788165": {"ParentId": "3788005", "CommentCount": "0", "Body": "<p>If you need to know that ownership is transferred, then don't use raw pointers.  Use smart pointers, such as std::auto_ptr (Boost and C++0x have many more) which make the transfer of ownership explicit and additionally convey how to destroy the objects (for auto_ptr this means delete):</p>\n<pre><code>struct Example {\n  Example(std::auto_ptr&lt;T&gt; parent, std::auto_ptr&lt;TObject&gt; left,\n          std::auto_ptr&lt;T&gt; right)\n  : _parent (parent), _left (left), _right (right)\n  {}\n\nprivate:\n  std::auto_ptr&lt;T&gt; _parent, _left, _right;\n};\n</code></pre>\n<p>You could still store raw pointers, if you really insist, by using auto_ptr's release method and writing a copy ctor, destructor, and assignment operator for Example (the Rule of Three).</p>\n", "Id": "3788165", "PostTypeId": "2", "OwnerDisplayName": "Roger Pate", "Score": "0", "CreationDate": "2010-09-24T14:43:24.827", "LastActivityDate": "2010-09-24T14:43:24.827"}});