post_cb({"30936261": {"ParentId": "30935840", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>Above all, since c++11, <code>std::vector&lt;&gt;</code> <strong>can</strong> store not-copyable types. (<a href=\"http://ideone.com/K1gbMr\" rel=\"nofollow noreferrer\">example</a>) Let's take a look at <a href=\"http://en.cppreference.com/w/cpp/container/vector\" rel=\"nofollow noreferrer\">cppreference</a>.</p>\n<p>Until c++11, T should be copyable as you know.</p>\n<blockquote>\n<p id=\"so_30935840_30936261_0\">T must meet the requirements of CopyAssignable and CopyConstructible.</p>\n</blockquote>\n<p>However, in c++11, The requirements is completely changed.</p>\n<blockquote>\n<p id=\"so_30935840_30936261_1\">The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type is a complete type and meets the requirements of <strong>Erasable</strong>, but many member functions impose stricter requirements.</p>\n</blockquote>\n<p>.. <a href=\"http://en.cppreference.com/w/cpp/concept/Erasable\" rel=\"nofollow noreferrer\">Erasable</a> is:</p>\n<blockquote>\n<p id=\"so_30935840_30936261_2\">The type T is Erasable from the Container X if, given</p>\n<p id=\"so_30935840_30936261_3\"><strong><code>A</code></strong>    the allocator type defined as <code>X::allocator_type</code></p>\n<p id=\"so_30935840_30936261_4\"><strong><code>m</code></strong>    the lvalue of type <code>A</code> obtained from <code>X::get_allocator()</code></p>\n<p id=\"so_30935840_30936261_5\"><strong><code>p</code></strong>    the pointer of type <code>T*</code> prepared by the container</p>\n<p id=\"so_30935840_30936261_6\">the following expression is well-formed:</p>\n<pre><code>std::allocator_traits&lt;A&gt;::destroy(m, p);\n</code></pre>\n</blockquote>\n<p>And look at the \"Type requirements\" of <a href=\"http://en.cppreference.com/w/cpp/container/vector/resize\" rel=\"nofollow noreferrer\">std::vector::resize() reference</a>:</p>\n<blockquote>\n<p id=\"so_30935840_30936261_7\">T must meet the requirements of <a href=\"http://en.cppreference.com/w/cpp/concept/MoveInsertable\" rel=\"nofollow noreferrer\">MoveInsertable</a> and <a href=\"http://en.cppreference.com/w/cpp/concept/DefaultInsertable\" rel=\"nofollow noreferrer\">DefaultInsertable</a> in order to use overload (1).</p>\n</blockquote>\n<p>So T doesn't need to be copyable - it only needs to destroyable, movable and default construct-able.</p>\n<p>Moreover, since c++14, the restriction of complete type is removed.</p>\n<blockquote>\n<p id=\"so_30935840_30936261_8\">The requirements that are imposed on the elements depend on the actual operations performed on the container. Generally, it is required that element type meets the requirements of Erasable, but many member functions impose stricter requirements. <strong>This container (but not its members) can be instantiated with an incomplete element type</strong> if the allocator satisfies the allocator completeness requirements.</p>\n</blockquote>\n<p>Therefore, I think it's because of just poor standard-conforming of VS2012. It has some defect on latest C++ (e.g. <code>noexcept</code>)</p>\n<hr>\n<p>C++11 standard paper <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">N3337</a> says</p>\n<blockquote>\n<p id=\"so_30935840_30936261_9\">void resize(size_type sz);</p>\n<p id=\"so_30935840_30936261_10\">E\ufb00ects: If <code>sz &lt;= size()</code>, equivalent to <code>erase(begin() + sz, end());</code>. If <code>size() &lt; sz</code>, appends\n  <code>sz - size()</code> value-initialized elements to the sequence.</p>\n<p id=\"so_30935840_30936261_11\">Requires: T shall be CopyInsertable into *this.</p>\n</blockquote>\n<p>Therefore in strict c++11, you cannot use <code>std::vector::resize()</code> in this case. (you can use <code>std::vector</code>, though)</p>\n<p>However, <a href=\"https://stackoverflow.com/questions/30937208/stdvectorresizesize-type-requires-copyinsertable\">it is a standard defect</a> and fixed in C++14. and I guess many compilers work well with non-copyable types because copying isn't need to implementing <code>std::vector::resize()</code> indeed. Although VS2012 doesn't work, it's because another bug of VS2012 as @ComicSansMS answered, not because of <code>std::vector::resize()</code> itself.</p>\n</hr>", "OwnerUserId": "2729109", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:14:56.743", "Id": "30936261", "Score": "5", "CreationDate": "2015-06-19T10:47:50.920", "LastActivityDate": "2015-06-19T13:50:35.060"}, "30935840": {"CommentCount": "2", "ViewCount": "895", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-06-19T10:26:43.897", "LastActivityDate": "2015-06-19T15:08:34.993", "Title": "Does the C++ standard specify STL implementation details for the compiler?", "AcceptedAnswerId": "30936261", "LastEditDate": "2017-05-23T12:00:49.030", "Id": "30935840", "Score": "10", "Body": "<p>While writing an answer to <a href=\"https://stackoverflow.com/questions/30909296/can-you-put-a-pimpl-class-inside-a-vector\">this</a> question I faced an interesting situation - the question demonstrates the scenario where one would want to put a class in an STL container but fails to do so because of a missing copy constructor/move constructor/assignment operator. In this particular case the error is triggered by <code>std::vector::resize</code>. I made a quick snippet as a solution and saw another answer that had provided a move constructor instead of an assignment operator and copy constructor as I had. What was interresting that the other answer did not compile in VS 2012, while clang/gcc were happy with both approaches.</p>\n<p>First:</p>\n<pre><code>// Clang and gcc are happy with this one, VS 2012 is not\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n\nclass FooImpl {};\n\nclass Foo\n{\n    std::unique_ptr&lt;FooImpl&gt; myImpl;\npublic:\n    Foo( Foo&amp;&amp; f ) : myImpl( std::move( f.myImpl ) ) {}\n    Foo(){}\n    ~Foo(){}\n};\n\nint main() {\n    std::vector&lt;Foo&gt; testVec;\n    testVec.resize(10);\n    return 0;\n}\n</code></pre>\n<p>Second:</p>\n<pre><code>// Clang/gcc/VS2012 are all happy with this\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n\nusing namespace std;\nclass FooImpl {};\n\nclass Foo\n{\n    unique_ptr&lt;FooImpl&gt; myImpl;\npublic:\n    Foo()\n    {\n    }\n    ~Foo()\n    {\n    }\n    Foo(const Foo&amp; foo)\n    {\n        // What to do with the pointer?\n    }\n    Foo&amp; operator= (const Foo&amp; foo)\n    {\n        if (this != &amp;foo)\n        {\n            // What to do with the pointer?\n        }\n        return *this;\n    }\n};\n\nint main(int argc, char** argv)\n{\n    vector&lt;Foo&gt; testVec;\n    testVec.resize(10);\n    return 0;\n}\n</code></pre>\n<p>To understand what was happening I looked at the STL sources in VS 2012 and saw that it really was invoking the move assignment operator so that is why my sample worked (I don't have a Linux machine accessible to understand what is going on in clang/gcc) and the other did not, since it had only the move copy constructor.</p>\n<p>So this created the following question - can the compiler freely decide how to implement STL methods (in this case <code>std::vector::resize</code>), since radically different implementations could cause non-portable code? Or is this simply a VS 2012 bug?</p>\n", "Tags": "<c++><visual-c++><gcc><stl><clang>", "OwnerUserId": "1458617", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_30935840_30936261_0": {"section_id": 1537, "quality": 0.8, "length": 4}, "so_30935840_30936261_10": {"section_id": 810, "quality": 0.6363636363636364, "length": 7}}, "n3337": {"so_30935840_30936261_0": {"section_id": 1531, "quality": 0.8, "length": 4}, "so_30935840_30936261_10": {"section_id": 801, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_30935840_30936261_0": {"section_id": 1687, "quality": 0.8, "length": 4}, "so_30935840_30936261_10": {"section_id": 868, "quality": 0.5454545454545454, "length": 6}}}, "30936335": {"ParentId": "30935840", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Visual C++ 2012 is unable to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3053.html\" rel=\"nofollow noreferrer\">auto-generate the move constructor and the move assignment operator</a>. A defect that will only be fixed <a href=\"http://blogs.msdn.com/b/vcblog/archive/2015/04/29/c-11-14-17-features-in-vs-2015-rc.aspx\" rel=\"nofollow noreferrer\">in the upcoming 2015 version</a>.</p>\n<p>You can make your first example compile by adding an explicit move assignment operator to <code>Foo</code>:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;vector&gt;\n\nclass FooImpl {};\n\nclass Foo\n{\n    std::unique_ptr&lt;FooImpl&gt; myImpl;\npublic:\n    Foo( Foo&amp;&amp; f ) : myImpl( std::move( f.myImpl ) ) {}\n    // this function was missing before:\n    Foo&amp; operator=( Foo&amp;&amp; f) { myImpl = std::move(f.myImpl); return *this; }\n    Foo(){}\n    ~Foo(){}\n};\n\nint main() {\n    std::vector&lt;Foo&gt; testVec;\n    testVec.resize(10);\n    return 0;\n}\n</code></pre>\n<hr>\n<p>As explained in detail by <a href=\"https://stackoverflow.com/a/30936261/577603\">ikh's answer</a>, the standard actually does not require a move assignment operator here. The relevant concepts for <code>vector&lt;T&gt;::resize()</code> are <a href=\"http://en.cppreference.com/w/cpp/concept/MoveInsertable\" rel=\"nofollow noreferrer\">MoveInsertable</a> and <a href=\"http://en.cppreference.com/w/cpp/concept/DefaultInsertable\" rel=\"nofollow noreferrer\">DefaultInsertable</a>, which would have been met by your initial implementation with just the move constructor.</p>\n<p>The fact that VC's implementation also requires the move assignment here is a <em>different</em> defect, which was already fixed in VS2013.</p>\n<p>Thanks to <a href=\"https://stackoverflow.com/a/30936261/577603\">ikh</a> and <a href=\"https://stackoverflow.com/questions/30935840/does-the-c-standard-specify-stl-implementation-details-for-the-compiler/30936335#comment49910689_30936335\">dyp</a> for their insightful contributions in this matter.</p>\n</hr>", "OwnerUserId": "577603", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:00:49.030", "Id": "30936335", "Score": "6", "CreationDate": "2015-06-19T10:53:01.683", "LastActivityDate": "2015-06-19T12:26:02.253"}, "30941523": {"ParentId": "30935840", "CommentCount": "2", "Body": "<p>VS2012 is a C++ compiler with some C++11 features.  Calling it a C++11 compiler is a bit of a stretch.</p>\n<p>Its standard library is very C++03.  Its support for move semantics is minimal.</p>\n<p>By VS2015, the compiler remains a C++11 with some C++11 features, but its support for move semantics is much better.</p>\n<p>VS2015 still lacks full C++11 <code>constexpr</code> support and has incomplete SFINAE support (what they call \"expression SFINAE\") and some knock-on library failures.  It also has deficiencies in non-static data-member initializers, initializer lists, attributes, universal character names, some concurrency details, and its preprocessor is not compliant.  <a href=\"http://blogs.msdn.com/b/vcblog/archive/2014/11/17/10573602.aspx\" rel=\"nofollow\">This is extracted from their own blog</a>.</p>\n<p>Meanwhile, modern gcc and clang compilers have completed C++14 support and have extensive C++1z support.  VS2015 has limited C++14 feature support.  Almost all of its C++1z support is in experimental branches (which is fair).</p>\n<p>All 3 compilers have bugs on top of the features they support.</p>\n<p>What you are experiencing here is that your compiler isn't a full C++11 compiler, so your code does not work.</p>\n<p>In this case, there was a defect in the C++11 standard as well.  Defect reports are usually fixed by compilers and folded into \"C++11 compiling mode\" by compilers, as well as being incorporated into the next standard.  The defect in question was obvious enough that basically everyone who actually implemented the C++11 standard ignored the defect.</p>\n<hr>\n<p>The C++ standard mandates certain observable behavior.  Often these mandates restrict compiler writers to certain narrow implementation space (with minor variations) assuming a decent quality of implementation.</p>\n<p>At the same time, the C++ standard leaves a lot of freedom.  The type of iterators into C++ vectors could be a raw pointer under the standard, or a reference-counting smart indexer that generates extra errors when used incorrectly, or something else entirely.  Compilers can use that freedom to have their debug builds be instrumented with extra error checking (catching undefined behavior for the programmers), or use that freedom to try different tricks that could grant extra performance (a vector that stores its size and capacity in the allocated buffer could be smaller to store, and usually when you ask for size/capacity you are going to access the data shortly anyhow).</p>\n<p>The limitations are usually around data lifetime and complexity bounds.</p>\n<p>Usually some reference implementation is written, its limitations and complexity bounds are analyzed, and those are put forward as a restriction.  Sometimes parts are left \"looser\" than the reference implementation requires, which gives freedom to the compiler or library writers.</p>\n<p>As an example, there have been some complaints that the unordered map types in C++11 where over-constrained by the standard, and prevent innovation that could permit a more efficient implementation.  If fewer constraints where put on said containers, different vendors could experiment, and a faster container might have been converged on instead of the current design.</p>\n<p>The downside is that revisions to the standard library break binary compatibility really easily, so if constraints where later added that ruled out some implementations, compiler writers and users could be very annoyed.</p>\n</hr>", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "30941523", "Score": "3", "CreationDate": "2015-06-19T15:08:34.993", "LastActivityDate": "2015-06-19T15:08:34.993"}, "30936094": {"ParentId": "30935840", "CommentCount": "1", "Body": "<p>The C++ standard dictates constraints on <code>T</code> for pretty much all library container functions.</p>\n<p>For example, in draft n4296, the constraints for <code>T</code> for <code>std::vector::resize</code> defined in [vector.capacity]/13 are.</p>\n<pre><code>Requires: T shall be MoveInsertable and DefaultInsertable into *this.\n</code></pre>\n<p>I don't have access to the final standards for the various versions of C++ to hand for comparison, but I would assume that VS 2012 is non-conformant in its C++11 support in this example.</p>\n", "OwnerUserId": "496161", "PostTypeId": "2", "Id": "30936094", "Score": "1", "CreationDate": "2015-06-19T10:39:35.670", "LastActivityDate": "2015-06-19T10:39:35.670"}});