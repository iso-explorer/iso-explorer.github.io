post_cb({"bq_ids": {"n4659": {"so_19133452_19133744_1": {"section_id": 6875, "quality": 0.5714285714285714, "length": 8}}, "n3337": {"so_19133452_19133744_1": {"section_id": 5242, "quality": 0.9285714285714286, "length": 13}}}, "19133452": {"AcceptedAnswerId": "19133744", "Tags": "<c++><c++11>", "Id": "19133452", "OwnerUserId": "952747", "Body": "<p>I had a Q&amp;A before: <a href=\"https://stackoverflow.com/q/15746271/952747\">Point of declaration in C++</a>. The rule <em>point-of-declaration</em> nicely is applicable on many situations. Now, I confused on usage of <code>auto</code> in combination of this rule.</p>\n<p>Consider these two codes:</p>\n<p>i. Declaring <code>x</code> by itself <em>(we don't expect it to work)</em>:</p>\n<pre><code>{\n  auto x = x;\n}\n</code></pre>\n<p>ii. Declaring the inner <code>x</code> by the outer <code>x</code> <em>(It makes error in gcc 4.8.x)</em>:</p>\n<pre><code>{\n  int x = 101; // the outer x\n  {\n    auto x = x; // the inner x\n  }\n}\n</code></pre>\n<p>According to the rule of point-of-declaration, it should work but it doesn't. It seems there is another rule in the standard that I missed it. The question is, <strong><em>Where is the point-of-declaration when using <code>auto</code>?</em></strong></p>\n<p>\u00a0</p>\n<p>There are two possibilities:</p>\n<p>i. If the point of declaration is after <code>=</code>, at the end of statement:</p>\n<pre><code>auto object = expression;\n                        ^\n                        Is it here? If it is, why gcc complains?\n</code></pre>\n<p>So the second declaration is valid and must work, because there is no <code>x</code> but that outer one (which is declared before). Therefore <code>auto x=x</code> is valid and the inner <code>x</code> should be assigned to <code>101</code>.</p>\n<p>\u00a0</p>\n<p>ii. If the point of declaration is before <code>=</code> :</p>\n<pre><code>auto object = expression;\n           ^\n</code></pre>\n<p>Well, it doesn't make any sense because <code>auto</code> has to wait until see the following expression. For example <code>auto x;</code> is invalid.</p>\n<hr>\n<p><strong>Update</strong>: I need an answer which explains it by the rule <em>point of declaration</em>.</p>\n</hr>", "CommentCount": "22", "CreationDate": "2013-10-02T09:05:37.927", "ViewCount": "735", "FavoriteCount": "2", "LastActivityDate": "2015-02-21T21:41:01.023", "LastEditorUserId": "-1", "PostTypeId": "1", "Title": "Point of declaration for auto keyword", "AnswerCount": "4", "Score": "16", "LastEditDate": "2017-05-23T11:44:41.147"}, "19133618": {"LastActivityDate": "2013-10-02T09:15:35.320", "ParentId": "19133452", "CommentCount": "0", "Score": "1", "Body": "<p>The compiler reads a whole statement (from the beginning of a line until the next semi-colon) and then evaluates the different parts of a statement using priorities of operations, and then when the time comes when the value of <code>auto x</code> is to be assigned, the type that came up after th <code>=</code> sign gets taken.</p>\n<p>For example:</p>\n<pre><code>template &lt;typename T&gt;\nT sum(T a, T b)\n{\n    return a+b;\n}\n\nint main()\n{\n    auto x = sum&lt;double&gt;(1,5); // x here is a double, because the return value is double\n    auto y = sum&lt;int&gt;(1,7); //y is an int, because the return value is int\n}\n</code></pre>\n<p>And about your <code>auto x = x</code>, you're redefining the same variable name. That's invalid! <code>auto y = x</code> shall work.</p>\n", "Id": "19133618", "CreationDate": "2013-10-02T09:15:35.320", "OwnerUserId": "1317944", "PostTypeId": "2"}, "19133744": {"LastActivityDate": "2013-10-02T09:28:30.320", "LastEditorUserId": "1619294", "ParentId": "19133452", "CommentCount": "1", "PostTypeId": "2", "Score": "19", "Body": "<pre><code>auto x = x; // inner x\n</code></pre>\n<p>is ill-formed.</p>\n<p>To quote from the C++11 standard (emphasis mine):</p>\n<blockquote>\n<h3>7.1.6.4 auto specifier</h3>\n<p id=\"so_19133452_19133744_0\">...</p>\n<p id=\"so_19133452_19133744_1\"><sup>3</sup> Otherwise, the type of the variable is deduced from its initializer. <strong>The name of the variable being declared\n  shall not appear in the initializer expression.</strong> ...</p>\n</blockquote>\n<p>And so because <code>x</code> after <code>=</code> resolves to the <code>x</code> in <code>auto x</code> (as explained in the question you linked), that above piece of code is ill-formed.</p>\n", "Id": "19133744", "LastEditDate": "2013-10-02T09:28:30.320", "OwnerUserId": "1619294", "CreationDate": "2013-10-02T09:22:39.730"}, "19133758": {"LastActivityDate": "2013-10-02T09:40:04.007", "LastEditorUserId": "85371", "ParentId": "19133452", "CommentCount": "0", "PostTypeId": "2", "Score": "4", "Body": "<p>Just adding an example with more explicit diagnostics:</p>\n<pre><code>auto ll = [&amp;] { ll(); };\n</code></pre>\n<p>Results in (gcc):</p>\n<pre><code>error: variable \u2018auto ll\u2019 with \u2018auto\u2019 type used in its own initializer\n</code></pre>\n<p>or (clang):</p>\n<pre><code>error: variable 'll' declared with 'auto' type cannot appear in its own initializer\n    auto ll = [&amp;] { ll(); };\n                    ^\n</code></pre>\n<p>You can see that there is an explicit rule for this. I haven't looked at the specs.</p>\n", "Id": "19133758", "LastEditDate": "2013-10-02T09:40:04.007", "OwnerUserId": "85371", "CreationDate": "2013-10-02T09:23:37.093"}, "19133612": {"LastActivityDate": "2013-10-02T09:22:50.003", "LastEditorUserId": "2491746", "ParentId": "19133452", "CommentCount": "0", "PostTypeId": "2", "Score": "10", "Body": "<p>Just like in any other kind of definition, the <code>x</code> on the right-hand side of the initialiser for <code>auto x = x</code> resolves to the local <code>auto x</code>. C++ has always done this (i.e. <code>int x = x</code> compiles but will give you undefined behaviour).</p>\n<p>The reason <code>auto x = x</code> fails to compile is because while <code>x</code> is in scope it has no known type yet, and so using it as the initialiser fails because the type can't be deduced from the expression.</p>\n<p>Just like any other kind of declaration, <code>x</code> is in scope after its declarator which is <code>auto x</code>.</p>\n<pre><code>int x = 10;\nint y = 20;\n{\n    int x = x;  // This is NOT the outer x. This is undefined behaviour (reading an\n                // uninitialised variable).\n    auto y = y; // This is NOT the outer y. This is a compile error because the type of\n                // y is not known.\n}\n</code></pre>\n", "Id": "19133612", "LastEditDate": "2013-10-02T09:22:50.003", "OwnerUserId": "2491746", "CreationDate": "2013-10-02T09:15:17.320"}});