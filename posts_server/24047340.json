post_cb({"24047840": {"ParentId": "24047340", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2014-06-04T21:25:39.390", "Score": "1", "LastEditorUserId": "3647361", "LastEditDate": "2014-06-04T21:36:34.157", "Id": "24047840", "OwnerUserId": "3647361", "Body": "<p>The code runs fine with both GCC (4.9) and Clang. <strong>GCC 4.8.2 fails.</strong> VC++ 2013 fails as well.</p>\n<p>Here is a <a href=\"http://coliru.stacked-crooked.com/a/8c261691e2523633\" rel=\"nofollow\">minimalistic code example</a>.</p>\n<p>What compiler (and of course version) are you using?</p>\n", "LastActivityDate": "2014-06-04T21:36:34.157"}, "24047340": {"CommentCount": "3", "ViewCount": "320", "PostTypeId": "1", "LastEditorUserId": "395744", "CreationDate": "2014-06-04T20:51:18.767", "LastActivityDate": "2014-06-04T22:58:04.307", "Title": "C++: Overloading delete on a polymorphic singleton class", "LastEditDate": "2014-06-04T22:58:04.307", "Id": "24047340", "Score": "0", "Body": "<p>Suppose I have the following:</p>\n<pre><code>struct Base {\n  virtual ~Base() noexcept = default;\n  ...\n};\n\nstruct Singleton\n    : public Base {\n  void* operator new(size_t sz) noexcept { return instance(); }\n  void operator delete(void* ptr) noexcept {\n    // the body is supposed to be empty since new() doesn't allocate\n    ++delete_count;\n  }\n  static Singleton* instance() noexcept {\n    static Singleton kInstance;\n    return &amp;kInstance;\n  }\n  ...\n};\n</code></pre>\n<p>(I use such a singleton class to reduce overhead in a polymorphic container-like class, e.g. <code>std::vector&lt; std::unique_ptr&lt;Base&gt; &gt;</code>, esp. if multiple of them appear in the container.)</p>\n<p>I'm surprised that the following code <em>crashes</em>:</p>\n<pre><code>int delete_count = 0;\nSingleton* s = new Singleton;\nSingleton* s2 = new Singleton;\nassert(s == s2);\nassert(s == Singleton::instance());\n\ndelete s;\nassert(1 == delete_count);\nassert(s == Singleton::instance());\n\ndelete s2;  // crashes with free(): invalid pointer\nassert(2 == delete_count);\n</code></pre>\n<p>Interestingly, if I make the <code>Singleton</code> class non-polymorphic, i.e. remove the virtual destructor from <code>Base</code>, everything works fine (even if I make the <code>Base</code> class non-empty by adding class members).</p>\n<p>Does anyone have an explanation why this happens and how to fix it?</p>\n<p><strong>Edit</strong>: It seems that changing the <code>Singleton::delete</code> to:</p>\n<pre><code>void operator delete(void* ptr) noexcept {\n  ::new(ptr) Singleton;  // re-initialize using placement new\n  ++delete_count;\n}\n</code></pre>\n<p>makes it to work, at least on GCC 4.8.1</p>\n", "Tags": "<c++><memory-management><singleton><operator-overloading><dynamic-memory-allocation>", "OwnerUserId": "395744", "AnswerCount": "3"}, "24047955": {"ParentId": "24047340", "CommentCount": "1", "CreationDate": "2014-06-04T21:32:50.303", "OwnerUserId": "2293156", "PostTypeId": "2", "Id": "24047955", "Score": "0", "Body": "<p>I guess it is how g++ manage its internal states.</p>\n<p>I found that this code compile and run correctly in clang, but fails in gcc. The reason was that, at the first delete, it calls the class defined. But for the second call, it calls for the global ones.</p>\n<p>To solve this, I suggest to move allocation and deallocation to the Base class</p>\n", "LastActivityDate": "2014-06-04T21:32:50.303"}, "24048582": {"ParentId": "24047340", "CommentCount": "5", "CreationDate": "2014-06-04T22:21:10.103", "OwnerUserId": "481267", "PostTypeId": "2", "Id": "24048582", "Score": "1", "Body": "<p>You are invoking <strong>undefined behaviour</strong>. Here's why.</p>\n<p>A <em>delete-expression</em> always calls the destructor, unless the pointer to be deleted is null. Quoting from \u00a75.3.5/6 of the C++11 standard,</p>\n<blockquote>\n<p id=\"so_24047340_24048582_0\">If the value of the operand of the <em>delete-expression</em> is not a null pointer value, the <em>delete-expression</em> will\n  invoke the destructor (if any) for the object or the elements of the array being deleted.</p>\n</blockquote>\n<p>This occurs even if the <em>delete-expression</em> calls a user-defined <em>deallocation function</em> as it does here.</p>\n<p>Calling the destructor twice on the same object invokes undefined behaviour if the object has a non-trivial destructor. This is thanks to \u00a712.4/15,</p>\n<blockquote>\n<p id=\"so_24047340_24048582_1\">Once a destructor is invoked for an object, the object no longer exists; the behavior is undefined if the\n   destructor is invoked for an object whose lifetime has ended (3.8)...</p>\n</blockquote>\n<p>and \u00a73.8,</p>\n<blockquote>\n<p id=\"so_24047340_24048582_2\">... The lifetime of an object of type <code>T</code> ends when:</p>\n<p id=\"so_24047340_24048582_3\">\u2014 if <code>T</code> is a class type with a non-trivial destructor (12.4), the destructor call starts, or ...</p>\n</blockquote>\n<p>However, if the virtual destructor in the base class is removed, then <code>Singleton</code>'s destructor becomes trivial (see \u00a712.4/5). In this case the behaviour is well-defined according to the standard. (In a sense, this is because trivial destructors are no-ops, whereas nontrivial destructors actually modify vptrs and such.)</p>\n", "LastActivityDate": "2014-06-04T22:21:10.103"}, "bq_ids": {"n4140": {"so_24047340_24048582_3": {"section_id": 7189, "quality": 0.875, "length": 7}, "so_24047340_24048582_1": {"section_id": 411, "quality": 1.0, "length": 15}, "so_24047340_24048582_2": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}, "so_24047340_24048582_0": {"section_id": 6110, "quality": 1.0, "length": 15}}, "n3337": {"so_24047340_24048582_3": {"section_id": 6933, "quality": 0.875, "length": 7}, "so_24047340_24048582_1": {"section_id": 402, "quality": 1.0, "length": 15}, "so_24047340_24048582_2": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}, "so_24047340_24048582_0": {"section_id": 5876, "quality": 1.0, "length": 15}}, "n4659": {"so_24047340_24048582_3": {"section_id": 8697, "quality": 0.875, "length": 7}, "so_24047340_24048582_1": {"section_id": 429, "quality": 1.0, "length": 15}, "so_24047340_24048582_2": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}, "so_24047340_24048582_0": {"section_id": 7607, "quality": 1.0, "length": 15}}}});