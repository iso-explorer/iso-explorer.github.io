post_cb({"5838895": {"ViewCount": "232", "Body": "<p>The <code>std::vector&lt;T&gt;</code> class is a model of the STL Container concept, and as such any proper implementation of vector has to include a nested typedef <code>value_type</code> as well as <code>reference</code>.  This should be detectable using SFINAE.  However, in my own tests, I can use SFINAE to detect a nested <code>value_type</code> typedef, but for some reason I <em>can't</em> detect <code>reference</code>.</p>\n<pre><code>template &lt;class T&gt; \ntypename T::value_type* test(T)\n{\n    cout &lt;&lt; \"Has nested typedef!\" &lt;&lt; endl;\n}\n\ntemplate &lt;class T&gt; \nvoid test(...)\n{\n    cout &lt;&lt; \"Doesn't have nested typedef!\" &lt;&lt; endl;\n}\n\nint main()\n{\n    test(std::vector&lt;int&gt;());\n}\n</code></pre>\n<p>This outputs: <code>Has nested typedef!</code></p>\n<p>However, if I replace <code>value_type</code> with <code>reference</code>, like:</p>\n<pre><code>template &lt;class T&gt; \ntypename T::reference* test(T)\n{\n    cout &lt;&lt; \"Has nested typedef!\" &lt;&lt; endl;\n}\n\ntemplate &lt;class T&gt; \nvoid test(...)\n{\n    cout &lt;&lt; \"Doesn't have nested typedef!\" &lt;&lt; endl;\n}\n\nint main()\n{\n    test(std::vector&lt;int&gt;());\n}\n</code></pre>\n<p>...the program fails to compile at all, giving the error: <code>error: no matching function for call to test(std::vector&lt;int, std::allocator&lt;int&gt; &gt;)</code></p>\n<p>Why does the SFINAE technique work with <code>T::value_type</code> but not with <code>T::reference</code>?</p>\n", "AcceptedAnswerId": "5838908", "Title": "SFINAE doesn't detect T::reference", "CreationDate": "2011-04-30T01:40:58.597", "Id": "5838895", "CommentCount": "0", "LastEditDate": "2011-04-30T01:47:23.640", "PostTypeId": "1", "LastEditorUserId": "469408", "LastActivityDate": "2011-04-30T02:27:42.437", "Score": "4", "OwnerUserId": "469408", "Tags": "<c++><stl><sfinae>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_5838895_5839026_1": {"length": 7, "quality": 1.0, "section_id": 3222}}, "n3337": {"so_5838895_5839026_1": {"length": 7, "quality": 1.0, "section_id": 3096}}, "n4659": {"so_5838895_5839026_1": {"length": 7, "quality": 1.0, "section_id": 3979}}}, "5838908": {"Id": "5838908", "PostTypeId": "2", "Body": "<p>What's a pointer to a reference?</p>\n<p><strong>A</strong>: Impossible. Pointers to references cannot exist, so neither of your functions can exist. This is in contrast to your first case, where at least one of the functions can exist (and thus you get compilation, linkage and output).</p>\n<p>Interestingly, SFINAE <em>is</em> working here, as the function definition is not causing the compilation error. It's attempting to call a function that, because of impossibility+SFINAE, doesn't exist, that's causing the error. :)</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2011-04-30T02:27:42.437", "Score": "5", "CreationDate": "2011-04-30T01:44:43.670", "ParentId": "5838895", "CommentCount": "4", "OwnerUserId": "560648", "LastEditDate": "2011-04-30T02:27:42.437"}, "5839026": {"Id": "5839026", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_5838895_5839026_0\">typename T::reference* test(T)</p>\n</blockquote>\n<p>Pointers to references are illegal in C++.</p>\n<p>\u00a78.3.2/4 from the Standard says:</p>\n<blockquote>\n<p id=\"so_5838895_5839026_1\">There shall be no references to references, no arrays of references, and <strong>no pointers to references</strong>.</p>\n</blockquote>\n", "LastActivityDate": "2011-04-30T02:20:26.180", "CommentCount": "1", "CreationDate": "2011-04-30T02:20:26.180", "ParentId": "5838895", "Score": "2", "OwnerUserId": "415784"}});