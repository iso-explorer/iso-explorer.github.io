post_cb({"5715923": {"CommentCount": "0", "AcceptedAnswerId": "5715960", "CreationDate": "2011-04-19T11:53:27.207", "LastActivityDate": "2011-04-19T12:24:15.490", "PostTypeId": "1", "ViewCount": "864", "FavoriteCount": "1", "Title": "What is default destructor if a class inherits from a pure base class?", "Id": "5715923", "Score": "0", "Body": "<p>Considering next two classes :</p>\n<pre><code>struct Base\n{\n  virtual ~Base()\n  {\n  }\n\n  virtual void foo() = 0;\n};\n\nstruct Derived : public Base\n{\n  virtual void foo()\n  {\n  }\n};\n</code></pre>\n<p>Is the following causing an undefined behaviour :</p>\n<pre><code>Base *obj = new Derived;\ndelete obj;\n</code></pre>\n<p>?</p>\n<p>Additional question : how come that one a method is declared virtual, it is virtual in derived classes (even if the virtual keyword is not used in the derived class), but it is not true for destructors?</p>\n", "Tags": "<c++><inheritance><language-lawyer>", "OwnerUserId": "476681", "AnswerCount": "4"}, "5715950": {"ParentId": "5715923", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>For any class, constructors and destructors <strong>aren't</strong> inherited. This is specified in the standard. As such, your code won't cause undefined behaviour, as it will invoke the default constructor/destructor for the class.<br>\nIt is for this reason that inheritence doesn't hold true for destructors/constructors. It doesn't make sense for a constructor/destructor to be inherited from a parent object, as this object could potentially have all forms of different members.</br></p>\n", "OwnerUserId": "699674", "LastEditorUserId": "699674", "LastEditDate": "2011-04-19T12:00:48.063", "Id": "5715950", "Score": "1", "CreationDate": "2011-04-19T11:55:30.823", "LastActivityDate": "2011-04-19T12:00:48.063"}, "5715955": {"ParentId": "5715923", "CommentCount": "0", "Body": "<p>That is not undefined behaviour.  You've declared the base-class destructor as <code>virtual</code>, so at runtime, <code>delete obj</code> will first invoke the \"default\" destructor in <code>Derived</code> (as you haven't explicitly declared one), and then the destructor in <code>Base</code>.</p>\n", "OwnerUserId": "129570", "PostTypeId": "2", "Id": "5715955", "Score": "2", "CreationDate": "2011-04-19T11:55:36.940", "LastActivityDate": "2011-04-19T11:55:36.940"}, "5715960": {"ParentId": "5715923", "PostTypeId": "2", "CommentCount": "7", "Body": "<blockquote>\n<p id=\"so_5715923_5715960_0\">Is the following causing an undefined behaviour :</p>\n</blockquote>\n<p>No, that is not invoking undefined behaviour <em>precisely</em> because the destructor of <code>Base</code> is <code>virtual</code>.</p>\n<hr>\n<p>EDIT: Its just to clarify a doubt (raised in the following comment), and to emphasize what I said above.</p>\n<p>@Oli Charlesworth commented:</p>\n<blockquote>\n<p id=\"so_5715923_5715960_1\">Technically, even if it were not declared virtual, the behaviour would <strong>not</strong> be undefined, it would just be undesirable.</p>\n</blockquote>\n<p>No. The behavior would be undefined.</p>\n<p>The section \u00a75.3.5/3 from the Standard says,</p>\n<blockquote>\n<p id=\"so_5715923_5715960_2\">In the first alternative (delete\n  object), if the static type of the\n  operand is different from its dynamic\n  type, the static type shall be a base\n  class of the operand\u2019s dynamic type\n  and the static type shall have a\n  virtual destructor <strong>or the behavior\n  is undefined.</strong> In the second alternative (delete array) if the dynamic type of the\n  object to be deleted differs from its static type, the behavior is undefined.</p>\n</blockquote>\n<p>I think it helps removing the doubt.:-)</p>\n</hr>", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-04-19T12:24:15.490", "Id": "5715960", "Score": "4", "CreationDate": "2011-04-19T11:56:05.050", "LastActivityDate": "2011-04-19T12:24:15.490"}, "5715987": {"ParentId": "5715923", "CommentCount": "0", "Body": "<p>Since you have declared the base class's destructor as virtual, there is no undefined behavior here.</p>\n<p>The statments :</p>\n<pre><code>Base *obj = new Derived;\ndelete obj;\n</code></pre>\n<p>will lead to call the derived class's desctructor and then the Base class's destructor. I didn't get the second question though</p>\n", "OwnerUserId": "240857", "PostTypeId": "2", "Id": "5715987", "Score": "1", "CreationDate": "2011-04-19T11:59:09.950", "LastActivityDate": "2011-04-19T11:59:09.950"}, "bq_ids": {"n4140": {"so_5715923_5715960_2": {"section_id": 6107, "quality": 0.8974358974358975, "length": 35}}, "n3337": {"so_5715923_5715960_2": {"section_id": 5873, "quality": 0.8974358974358975, "length": 35}}, "n4659": {"so_5715923_5715960_2": {"section_id": 7604, "quality": 0.8974358974358975, "length": 35}}}});