post_cb({"18902146": {"Tags": "<c++><c++11><typetraits>", "ViewCount": "564", "AnswerCount": "2", "CreationDate": "2013-09-19T18:18:20.603", "FavoriteCount": "1", "Title": "Why does std::remove_pointer also remove const qualifier", "CommentCount": "1", "AcceptedAnswerId": "18902487", "Score": "1", "OwnerUserId": "469408", "Id": "18902146", "LastActivityDate": "2013-09-19T19:02:44.403", "Body": "<p>Consider the following code:</p>\n<pre><code>typedef const std::string const_string_type;\ncout &lt;&lt; std::is_const&lt;const_string_type&gt;::value &lt;&lt; endl;\ncout &lt;&lt; std::is_const&lt;std::remove_pointer&lt;const_string_type&gt;::type&gt;::value &lt;&lt; endl;\n</code></pre>\n<p>This outputs</p>\n<pre><code>1\n0\n</code></pre>\n<p>That means that <code>std::remove_pointer&lt;const_string_type&gt;::type</code> removed the <code>const</code> qualifier from the type.  My understanding is that <code>std::remove_pointer</code> is supposed to produce the exact same type (qualifiers and all) if the type is not a pointer.  </p>\n<p>Is this correct behavior, or is this possibly a compiler-implementation issue?</p>\n", "PostTypeId": "1"}, "18902487": {"ParentId": "18902146", "Score": "4", "CreationDate": "2013-09-19T18:37:48.183", "Id": "18902487", "OwnerUserId": "649665", "LastActivityDate": "2013-09-19T18:37:48.183", "Body": "<p>It's a compiler bug.  According to the standard (\u00a720.9.7.5,\nTable 56): \"template  struct remove_pointer; : \nIf T has type '(possibly cv-qualified) pointer to T1' then the member\ntypedef type shall name T1; otherwise, it shall name T.\"  It\nshould never remove any <code>const</code> or <code>volatile</code> qualifiers from\nthe results. </p>\n", "PostTypeId": "2", "CommentCount": "2"}, "18902264": {"ParentId": "18902146", "Score": "1", "CreationDate": "2013-09-19T18:25:02.507", "LastActivityDate": "2013-09-19T19:02:44.403", "LastEditDate": "2013-09-19T19:02:44.403", "OwnerUserId": "2167655", "LastEditorUserId": "2167655", "Body": "<p>No it does not remove the const (only removes qualifiers from the pointer not the pointed to type), from <a href=\"http://en.cppreference.com/w/cpp/types/remove_pointer\" rel=\"nofollow\">this link</a> this is a possible implementation.   </p>\n<pre><code>template&lt; class T &gt; struct remove_pointer                    {typedef T type;};\ntemplate&lt; class T &gt; struct remove_pointer&lt;T*&gt;                {typedef T type;};\ntemplate&lt; class T &gt; struct remove_pointer&lt;T* const&gt;          {typedef T type;};\ntemplate&lt; class T &gt; struct remove_pointer&lt;T* volatile&gt;       {typedef T type;};\ntemplate&lt; class T &gt; struct remove_pointer&lt;T* const volatile&gt; {typedef T type;};\n</code></pre>\n<p>The result is actually a bug in the compiler, it should not remove the const of the pointed to type in any situation.</p>\n<p><strong>EDIT</strong> here is a quote from a table in the standard confirming it. <code>20.9.7.5\nPointer modifications</code> </p>\n<blockquote>\n<p id=\"so_18902146_18902264_0\">template  struct remove_pointer;<br>\n  If T has type \u201c(possibly cv-qualified) pointer to T1\u201d then the member  typedef type shall name T1; otherwise, it shall name T.</br></p>\n</blockquote>\n", "Id": "18902264", "PostTypeId": "2", "CommentCount": "25"}, "bq_ids": {"n4659": {"so_18902146_18902264_0": {"length": 8, "section_id": 669, "quality": 0.5714285714285714}}}});