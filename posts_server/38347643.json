post_cb({"38347643": {"CommentCount": "0", "ViewCount": "64", "CreationDate": "2016-07-13T09:25:38.177", "LastActivityDate": "2016-07-13T09:49:26.260", "Title": "What should the underlying type of a char initialized enum be?", "AcceptedAnswerId": "38348173", "PostTypeId": "1", "Id": "38347643", "Score": "3", "Body": "<p>When answering this <a href=\"https://stackoverflow.com/questions/38336578/in-c-is-there-a-difference-in-memory-usage-between-enum-class-versus-enum/38336740#38336740\">question about enums</a> I read the spec regarding the underlying size and it says (regarding unscoped enums) [7.5.5]:</p>\n<blockquote>\n<p id=\"so_38347643_38347643_0\">If the underlying type is not fixed, the type of each enumerator is the type\n  of its initializing value</p>\n</blockquote>\n<p>But when I try the <a href=\"http://ideone.com/KgshjL\" rel=\"nofollow\">following code</a> I get <code>sizeof int</code> for all enums (tested on g++, VC and clang).</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nenum e1 { e1a };\nenum class ec1 { ec1a };\nenum e2 { e2a = 'a' }; // I expect this to have sizeof 1\nenum class ec2 { ec2a = 'a' };\n\nint main() {\n    cout &lt;&lt; \"plain enum:\" &lt;&lt; sizeof(e1a) &lt;&lt; endl;\n    cout &lt;&lt; \"enum class:\" &lt;&lt; sizeof(ec1::ec1a) &lt;&lt; endl;\n    cout &lt;&lt; \"char initialized plain enum:\" &lt;&lt; sizeof(e2a) &lt;&lt; endl;\n    cout &lt;&lt; \"char initialized enum class:\" &lt;&lt; sizeof(ec2::ec2a) &lt;&lt; endl;\n}\n</code></pre>\n<p><strong>Output:</strong></p>\n<blockquote>\n<p id=\"so_38347643_38347643_1\">plain enum: 4<br>\n  enum class:4<br>\n  char initialized plain enum: 4<br>\n  char initialized enum class: 4  </br></br></br></p>\n</blockquote>\n<p>What did I misunderstand?</p>\n", "Tags": "<c++><enums><language-lawyer>", "OwnerUserId": "3848", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_38347643_38347643_0": {"section_id": 5464, "quality": 0.9, "length": 9}, "so_38347643_38348173_0": {"section_id": 5464, "quality": 1.0, "length": 9}}, "n3337": {"so_38347643_38347643_0": {"section_id": 5251, "quality": 1.0, "length": 10}, "so_38347643_38348173_0": {"section_id": 5251, "quality": 1.0, "length": 9}}, "n4659": {"so_38347643_38347643_0": {"section_id": 6898, "quality": 0.9, "length": 9}, "so_38347643_38348173_0": {"section_id": 6898, "quality": 1.0, "length": 9}}}, "38348173": {"ParentId": "38347643", "CommentCount": "0", "CreationDate": "2016-07-13T09:49:26.260", "OwnerUserId": "6394138", "PostTypeId": "2", "Id": "38348173", "Score": "3", "Body": "<p>You missed this sentence:</p>\n<blockquote>\n<p id=\"so_38347643_38348173_0\">Following the closing brace of an enum-specifier, each enumerator has the type of its enumeration.</p>\n</blockquote>\n<p>Proof:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\nenum e1 { e1a };\nenum class ec1 { ec1a };\nenum e2 {\n    e2a = 'a' ,\n    e2b = sizeof(e2a)  // &lt;-- here the type of e2a is still char\n};\n// &lt;-- here the type of e2a becomes the same as the type of e2 (i.e. int)\n\nenum class ec2 { ec2a = 'a' };\n\nint main() {\n    cout &lt;&lt; \"plain enum:\" &lt;&lt; sizeof(e1a) &lt;&lt; endl;\n    cout &lt;&lt; \"enum class:\" &lt;&lt; sizeof(ec1::ec1a) &lt;&lt; endl;\n    cout &lt;&lt; \"char initialized plain enum:\" &lt;&lt; sizeof(e2a) &lt;&lt; \" but e2b=\" &lt;&lt; e2b &lt;&lt;endl;\n    cout &lt;&lt; \"char initialized enum class:\" &lt;&lt; sizeof(ec2::ec2a) &lt;&lt; endl;\n\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>plain enum:4\nenum class:4\nchar initialized plain enum:4 but e2b=1\nchar initialized enum class:4\n</code></pre>\n", "LastActivityDate": "2016-07-13T09:49:26.260"}});