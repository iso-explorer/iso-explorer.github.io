post_cb({"bq_ids": {"n4140": {"so_23256676_23257516_0": {"length": 23, "quality": 0.92, "section_id": 275}}, "n3337": {"so_23256676_23257516_0": {"length": 23, "quality": 0.92, "section_id": 266}}, "n4659": {"so_23256676_23257516_0": {"length": 21, "quality": 0.84, "section_id": 282}}}, "23256676": {"ViewCount": "1682", "Body": "<p>Yes, I know, there is a question with almost the same title, but it refers to a different situation (giving the same clang error message). In my case, I have a <code>.cpp</code> file with a big anonymous namespace (containing implementation details). In that namespace is a traits class template with a static data member, which I need to access from outside the anonymous namespace. Let me flesh this out a bit:</p>\n<pre><code>file.hpp\n\nnamespace bar {\n  template&lt;typename A&gt;\n  struct foo\n  {\n    static_assert(is_same&lt;A,float&gt;::value || is_same&lt;A,double&gt;::value, \"\");\n    static void set_static_var(A const&amp;x);\n    // ...\n  };\n}\n</code></pre>\n<p>and</p>\n<pre><code>file.cpp\n\nnamespace {\n  template&lt;typename A&gt;\n  struct foo_traits\n  {\n    // lots of static code supporting the implementation of bar::foo&lt;&gt;\n    static A datum;\n  };\n  template&lt;&gt; float  foo_traits&lt;float&gt;::datum;   // no change if this is in global namespace\n  template&lt;&gt; double foo_traits&lt;double&gt;::datum;\n  template struct foo_traits&lt;float&gt;;\n  template struct foo_traits&lt;double&gt;;\n}\n\nnamespace bar {\n  template&lt;typename A&gt;\n  void foo&lt;A&gt;::set_static_var(A const&amp;x)\n  {\n    foo_traits&lt;A&gt;::datum = x;\n  }\n  template struct foo&lt;double&gt;;     // error only appears if these lines are present.\n  template struct foo&lt;float&gt;;      // but without these lines, the whole file is void.\n}\n</code></pre>\n<p>and I get the said error on the variables <code>foo_traits&lt;&gt;::datum</code> (and later linkage failure). <strong>Note added in edit</strong> I use <code>clang++ -std=c++11 -stdlib=libc++</code> (version 3.3), which produced <em>only</em> a warning, but (as I've said) in my real application that warning is backed up by a linkage failure (exactly the said symbols are missing). No compiler warnings with gcc, though. Perhaps this is a clang bug? <strong>end note</strong></p>\n<p>What is the correct way to define those variables? Note that declaring them outside the anonymouns namespace won't compile. Note also that, AFAIK, the same construct with an ordinary non-template just works.</p>\n<p><strong>Note</strong> I'm not asking on how to circumvent this problem (that I can think of myself), but how this is correctly done.</p>\n", "AcceptedAnswerId": "23256720", "Title": "static template member variable has internal linkage but is not defined", "CreationDate": "2014-04-23T22:52:42.433", "Id": "23256676", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-04-23T23:49:49.410", "LastEditorUserId": "1023390", "LastActivityDate": "2014-04-24T00:11:23.307", "Score": "3", "OwnerUserId": "1023390", "Tags": "<c++><templates><namespaces><linkage>", "AnswerCount": "2"}, "23257516": {"Id": "23257516", "PostTypeId": "2", "Body": "<p>The problem is that a declaration of an explicit specialization of a static data member is a definition only if it includes an initializer, and a declaration otherwise. C++11 14.7.3/13:</p>\n<blockquote>\n<p id=\"so_23256676_23257516_0\">An explicit specialization of a static data member of a template is a definition if the declaration includes an initializer; otherwise, it is a declaration. [ Note: The definition of a static data member of a template that requires default initialization must use a <em>braced-init-list</em>:</p>\n<pre><code>template&lt;&gt; X Q&lt;int&gt;::x; // declaration\ntemplate&lt;&gt; X Q&lt;int&gt;::x (); // error: declares a function\ntemplate&lt;&gt; X Q&lt;int&gt;::x { }; // definition\n</code></pre>\n<p id=\"so_23256676_23257516_1\">\u2014end note ]</p>\n</blockquote>\n<p><a href=\"http://coliru.stacked-crooked.com/a/833b18b6492c397d\" rel=\"nofollow\" title=\"Live at Coliru\">Clang correctly compiles program if you provide initializers for the specializations</a>:</p>\n<pre><code>template&lt;&gt; float  foo_traits&lt;float&gt;::datum = 0;\ntemplate&lt;&gt; double foo_traits&lt;double&gt;::datum = 0;\n</code></pre>\n<p>I was erroneous in my belief that the original program was correct, apparently <a href=\"http://coliru.stacked-crooked.com/a/6a862ab893459b6f\" rel=\"nofollow\" title=\"Live at Coliru\">gcc incorrectly treats the declarations as definitions even when they lack initializers</a>.</p>\n", "LastActivityDate": "2014-04-24T00:11:23.307", "CommentCount": "2", "CreationDate": "2014-04-24T00:11:23.307", "ParentId": "23256676", "Score": "3", "OwnerUserId": "923854"}, "23256720": {"Id": "23256720", "PostTypeId": "2", "Body": "<p>I think the correct solution is simply:</p>\n<pre><code>namespace {\n  template&lt;typename A&gt;\n  struct foo_traits\n  {\n    // lots of static code supporting the implementation of bar::foo&lt;&gt;\n    static A datum;\n  };\n  template&lt;typename A&gt; A foo_traits&lt;A&gt;::datum;\n}\n</code></pre>\n<hr>\n<p>The problem with your code, AFAICT, is that</p>\n<pre><code>float foo_traits&lt;float&gt;::datum;\n</code></pre>\n<p>refers to a specialization for <code>foo_traits</code> which does not exist. (the <code>template&lt;&gt;</code> in your code is also not allowed, Clang gives an error for it as well).</p>\n<p>See <a href=\"http://coliru.stacked-crooked.com/a/0172ba6e97457c14\" rel=\"nofollow\">this <strong>live example</strong></a>.</p>\n</hr>", "LastEditorUserId": "2073257", "LastActivityDate": "2014-04-24T00:01:06.980", "Score": "4", "CreationDate": "2014-04-23T22:56:42.993", "ParentId": "23256676", "CommentCount": "5", "OwnerUserId": "2073257", "LastEditDate": "2014-04-24T00:01:06.980"}});