post_cb({"bq_ids": {"n4140": {"so_4879045_4879045_0": {"length": 6, "quality": 1.0, "section_id": 7215}, "so_4879045_4879045_2": {"length": 19, "quality": 0.9047619047619048, "section_id": 7215}}, "n3337": {"so_4879045_4879045_0": {"length": 6, "quality": 1.0, "section_id": 6959}, "so_4879045_4879045_2": {"length": 19, "quality": 0.9047619047619048, "section_id": 6959}}, "n4659": {"so_4879045_4879045_0": {"length": 6, "quality": 1.0, "section_id": 8724}, "so_4879045_4879045_2": {"length": 19, "quality": 0.9047619047619048, "section_id": 8724}}}, "4879045": {"ViewCount": "2400", "Body": "<p>The section \u00a73.9.1/6 from the C++ Standard says,</p>\n<blockquote>\n<p id=\"so_4879045_4879045_0\">Values of type bool are either <code>true</code> or <code>false</code>.</p>\n</blockquote>\n<p>Now consider this code,</p>\n<pre><code>void f(bool b)\n{\n    switch(b) //since b is bool, it's value can be either true or false!\n    {\n        case true: cout &lt;&lt; \"possible value - true\";  break;\n        case false: cout &lt;&lt; \"possible value - false\"; break;\n        default: cout &lt;&lt; \"impossible value\";\n    }\n}\nint main()\n{\n    bool b; //note : b is uninitialized\n    f(b);\n    return 0;\n}\n</code></pre>\n<p>Compile  <code>F:\\workplace&gt;g++ test.cpp -pedantic</code> </p>\n<p>Run. Output :</p>\n<blockquote>\n<p id=\"so_4879045_4879045_1\">impossible value</p>\n</blockquote>\n<p>Unexpected output? Well, not really, as the Standard reads in the footnote of \u00a73.9.1/6 that:</p>\n<blockquote>\n<p id=\"so_4879045_4879045_2\">Using a bool value in ways described\n  by this International Standard as\n  <strong>\u201cundefined,\u201d</strong> such as <strong>by examining the value of an\n  uninitialized</strong> automatic object,\n  might cause it to <strong>behave as if it is\n  neither true nor false</strong>.</p>\n</blockquote>\n<p>So no matter how many times I compile and run this program, I get the same output : <code>impossible value</code>. However, if I change it a bit - removing the function <code>f()</code> from the picture, and write the <code>switch</code> block in <code>main()</code> itself:</p>\n<pre><code>int main()\n{\n    bool b; //note : b is uninitialized\n    switch(b) //since b is bool, it's value can be either true or false!\n    {\n        case true: cout &lt;&lt; \"possible value - true\";  break;\n        case false: cout &lt;&lt; \"possible value - false\"; break;\n        default: cout &lt;&lt; \"impossible value\";\n    }\n    return 0;\n}\n</code></pre>\n<p>Then I compile and run this program, I don't get <code>impossible value</code> as output; no matter how many times I repeat this, I never get <code>impossible value</code>.</p>\n<p>I'm just curious to know why this sudden change in the behavior of uninitialized bool? </p>\n<p>Well, from the language perspective it's clear : the behavior is undefined.I understand that. I also understand the compiler is free to do anything. From the compiler perspective, however, this seems very interesting to me. What could the <em>compiler</em> (i.e GCC) possibly do in each case and why?</p>\n<p>I'm using : <code>g++ (GCC) 4.5.0 - MinGW, on Windows 7 Basic, 64-bit OS</code>.</p>\n", "AcceptedAnswerId": "4879082", "Title": "Fun with uninitialized variables and compiler (GCC)", "CreationDate": "2011-02-02T19:43:09.347", "Id": "4879045", "CommentCount": "4", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2011-02-13T19:26:31.180", "LastEditorUserId": "415784", "LastActivityDate": "2011-02-13T19:26:31.180", "Score": "16", "OwnerUserId": "415784", "Tags": "<c++><gcc><compiler-construction><undefined-behavior><initialization>", "AnswerCount": "1"}, "4879082": {"Id": "4879082", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_4879045_4879082_0\">I'm just curious to know why this sudden change in the behavior of uninitialized bool?</p>\n</blockquote>\n<p>Disassemble the code and see what the compiler\u2019s doing.</p>\n<p>My guess: since the value is now only used locally, the compiler optimizes it away completely. Since the behaviour is undefined anyway, the compiler can safely just assume any value, e.g. <code>false</code>. This is a pretty obvious optimization since the value of <code>b</code> is constant as far as the compiler is concerned, and the whole logic of the <code>switch</code> is redundant. So why put it in the executable?</p>\n<p>(The important point here is really that <code>b</code> is only ever used locally in the second code, and that in turn will trigger more optimizations even in unoptimized code. The first code has to be inlined before the compiler can do any such optimizations, or the code paths have to be traced which isn\u2019t trivial).</p>\n", "LastActivityDate": "2011-02-02T19:46:47.993", "Score": "17", "CreationDate": "2011-02-02T19:46:47.993", "ParentId": "4879045", "CommentCount": "0", "OwnerUserId": "1968"}});