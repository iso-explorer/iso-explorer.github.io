post_cb({"17460149": {"CommentCount": "0", "ViewCount": "118", "PostTypeId": "1", "LastEditorUserId": "688659", "CreationDate": "2013-07-04T00:25:09.313", "LastActivityDate": "2013-07-19T17:48:14.713", "Title": "Rules for converting between pointer types where cv-qualifiers are the only difference", "AcceptedAnswerId": "17742636", "LastEditDate": "2013-07-19T09:30:37.750", "Id": "17460149", "Score": "1", "Body": "<p>This question specifically relates to C++98, but feel free to pitch in any useful info w/regard to newer standards if you like.</p>\n<p>In case you know the answer and want to skip the rest, the short &amp; sweet of it is:</p>\n<pre><code>int **w;\nint volatile*     *x = w; // error\nint volatile*const*y = w; // OK\nint const   *const*z = w; // OK    \n</code></pre>\n<p>Why would <code>const</code> be necessary to the right of <code>volatile</code> in the declaration of <code>y</code>?  What possible evil could someone accomplish if the declaration for <code>x</code> were allowed?</p>\n<p>In section <em>4.4.4</em> of the standard it says:</p>\n<blockquote>\n<p id=\"so_17460149_17460149_0\">A conversion can add cv-qualifiers <strong>at levels other than the first</strong> in multi-level pointers, subject to the following rules:</p>\n<p id=\"so_17460149_17460149_1\">Two pointer types T1 &amp; T2 are <em>similar</em> if there exists a type T and integer <em>n</em> &gt; 0 such that:</p>\n<ul>\n<li>T1 is CV10 ptr to CV11 ptr to ... CV1N T</li>\n<li>T2 is CV20 ptr to CV21 ptr to ... CV2N T</li>\n</ul>\n<p id=\"so_17460149_17460149_2\">... where each CVij is const, volatile, const volatile, or nothing.  The n-tuple of cv-qualifiers <strong>after</strong> the first in a pointer type, e.g., CV11, CV12, ..., CV1N in the pointer type T1, is called the <em>cv-qualification signature</em> of the pointer type.  An expression of type T1 can be converted to type T2 <strong>iff</strong> the following conditions are satisfied:</p>\n<ol>\n<li>the pointer types are similar</li>\n<li>for every <em>j</em> &gt; 0, if const is in CV1j, then const is in CV2j, and similarly for volatile.</li>\n<li>if the CV1j and CV2j are different, then const is in every CV2k for <em>0 &lt; k &lt; j</em></li>\n</ol>\n</blockquote>\n<p>... after which it goes on to give an example for assigning a <code>**</code> to a <code>const**</code>.  The <strong>emphasis</strong> above is mine, italics are from the document.</p>\n<p>Putting this into code:</p>\n<pre><code> int CV13* CV12* CV11* CV10 b1;\n int CV23* CV22* CV21* CV20 b2 = b1;\n</code></pre>\n<p>I'm a little fuzzy on some of the details ... so here's some questions or potentially flawed observations:</p>\n<p>1) It says <code>at levels other than the first</code>; this isn't elaborated on any further, but <code>CV20</code> can be any valid CV qualifier.</p>\n<p>2) The 3rd rule at the bottom says if T2 adds either <code>const</code> OR <code>volatile</code> at level <code>j</code>, then levels <code>1 ... j-1</code> must be const (or suffer the wrath).  In the following, the # of stars differs from the one at the top to emphasize what the 3rd rule says:</p>\n<pre><code>int *****w;\nint **volatile*     *     *x = w; // error\nint **volatile*const*const*y = w; // OK\nint **const   *const*const*z = w; // OK\n</code></pre>\n<p>I understand why it's needed for <code>z</code>, but why with <code>y</code>?  Here's roughly what the example in 4.4.4 looks like, modified for the volatile case:</p>\n<pre><code>void f( int **x ) {\n  int volatile**y = x; // not allowed\n  // do some evil here\n}\n</code></pre>\n<p>What evil could be put there?</p>\n", "Tags": "<c++><const><volatile><const-correctness><c++98>", "OwnerUserId": "549246", "AnswerCount": "1"}, "17742636": {"ParentId": "17460149", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>(Note: \"This question specifically relates to C++98\" but the state of affairs is the same in all versions of the Standard, past and present (and future too I would bet), because it's essentially about const-correctness and preventing coders from opening a hole in the type system.)</p>\n<p>As the Standard uses the general term \"<em>cv-qualifiers</em>\", I find it easier to understand when reasoning only with \"<code>const</code>\" (no \"<code>volatile</code>\") <em>[but see further below for an example with <code>volatile</code>]</em>. The \"C++ FAQ Lite\" has a related entry : <a href=\"http://www.parashift.com/c++-faq/constptrptr-conversion.html\" rel=\"nofollow\">Why am I getting an error converting a <code>Foo**</code> \u2192 <code>Foo const**</code>?</a></p>\n<p>Essentially, allowing the conversion would let you silently modify a <em>const</em> T (through a pointer to <em>non</em>-const T):</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>int const theAnswer = 42;\nint* p = 0;  // int* p = &amp;theAnswer; is not allowed of course...\nint** pp = &amp;p;\nint const** ppc = pp;  // &lt;-- Error, but imagine this were allowed...\n*ppc = &amp;theAnswer;  // &amp;theAnswer is `int const*` and *ppc is `int const*` too,\n                    // but it's also doing *pp = &amp;theAnswer; i.e. p = &amp;theAnswer;\n*p = 999;  // I.e. theAnswer = 999; =&gt; modifying a const int!\n</code></pre>\n<p>But by adding a \"first-level\" <code>const</code>, the conversion <code>int const* const* pcpc = pp;</code> is valid because the compiler will prevent you doing <code>*pcpc = &amp;theAnswer;</code> afterwards (because <code>*pcpc</code> is <code>const</code>).</p>\n<hr>\n<p><em>Edit:</em> As for <code>volatile</code>, the problem is maybe less obvious than with <code>const</code>, but allowing the conversion would let you silently incorrectly access (read or write) a <em>volatile</em> T as if it were <em>not</em> volatile (through a pointer to <em>non</em>-volatile T):</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>extern int volatile externTimer;\nint* p = 0;  // int* p = &amp;externTimer; is not allowed...\nint** pp = &amp;p;\nint volatile** ppv = pp;  // &lt;-- Error, but imagine this were allowed...\n*ppv = &amp;externTimer;  // &amp;externTimer is `int volatile*` and *ppv too,\n                      // but it's also doing *pp = &amp;externTimer; i.e. p = &amp;externTimer;\nint a1 = externTimer;  // First read\nint a2 = externTimer;  // Second read, mandatory: the value may have changed externally\nint b1 = *p;  // First read\nint b2 = *p;  // Second read? may be optimized out! because *p is not volatile\n</code></pre>\n<p>But by adding a \"first-level\" <code>const</code>, the conversion <code>int volatile* const* pcpv = pp;</code> is valid because the compiler will prevent you doing <code>*pcpv = &amp;externTimer;</code> afterwards (because <code>*pcpv</code> is <code>const</code>).</p>\n</hr>", "OwnerUserId": "688659", "LastEditorUserId": "688659", "LastEditDate": "2013-07-19T17:48:14.713", "Id": "17742636", "Score": "2", "CreationDate": "2013-07-19T09:29:32.080", "LastActivityDate": "2013-07-19T17:48:14.713"}, "bq_ids": {"n4140": {"so_17460149_17460149_2": {"section_id": 17, "quality": 0.7941176470588235, "length": 27}, "so_17460149_17460149_0": {"section_id": 17, "quality": 1.0, "length": 13}, "so_17460149_17460149_1": {"section_id": 17, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_17460149_17460149_2": {"section_id": 14, "quality": 0.7941176470588235, "length": 27}, "so_17460149_17460149_0": {"section_id": 14, "quality": 1.0, "length": 13}, "so_17460149_17460149_1": {"section_id": 14, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_17460149_17460149_1": {"section_id": 8721, "quality": 0.5555555555555556, "length": 5}}}});