post_cb({"bq_ids": {"n4140": {"so_38731039_38731039_1": {"length": 17, "quality": 0.7727272727272727, "section_id": 382}, "so_38731039_38731039_3": {"length": 15, "quality": 0.8823529411764706, "section_id": 382}, "so_38731039_38731039_5": {"length": 34, "quality": 0.9714285714285714, "section_id": 382}}, "n3337": {"so_38731039_38731039_1": {"length": 17, "quality": 0.7727272727272727, "section_id": 373}, "so_38731039_38731039_3": {"length": 15, "quality": 0.8823529411764706, "section_id": 373}, "so_38731039_38731039_5": {"length": 34, "quality": 0.9714285714285714, "section_id": 373}}, "n4659": {"so_38731039_38731039_1": {"length": 18, "quality": 0.8181818181818182, "section_id": 397}, "so_38731039_38731039_3": {"length": 15, "quality": 0.8823529411764706, "section_id": 397}, "so_38731039_38731039_5": {"length": 34, "quality": 0.9714285714285714, "section_id": 398}}}, "38731039": {"ViewCount": "173", "Body": "<p>Why is not used Execute-Around Pointer Idiom in Boost-library as smart pointer for thread-safe access to object?</p>\n<p>As known there is Execute-Around Pointer Idiom: <a href=\"https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Execute-Around_Pointer\" rel=\"nofollow\">https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Execute-Around_Pointer</a></p>\n<p>The main idea of Execute-Around Pointer Idiom - we did not return a reference or a pointer to a class member, but we return a temporary object with type <code>proxy</code>: <a href=\"http://ideone.com/cLS8Ph\" rel=\"nofollow\">http://ideone.com/cLS8Ph</a></p>\n<ul>\n<li>a temporary object that is created before it gives access to a pointer to a class member <code>proxy (T * const _p, mutex_type&amp; _mtx) : p(_p), lock(_mtx) {}</code></li>\n<li>then <code>proxy</code> gives access to pointer to a class member <code>T* operator -&gt; () {return p;}</code></li>\n<li>and destroyed after the completion of the entire expression: after completion all functions in which member used as parameters, and after other calculations <code>~proxy () {}</code></li>\n</ul>\n<p>This is why this code is thread-safe:</p>\n<pre><code>execute_around&lt;std::vector&lt;int&gt;&gt; vecc(10, 10);\n...\nint res = std::sort(vecc-&gt;begin(), vecc-&gt;end()); // thread-safe in all threads\n</code></pre>\n<p>We can use this idiom something like as smart pointer which in addition locks mutex before we get accessing to member variable or function and unlocks mutex after. This doing always, and always locks only mutex which relates to this object.</p>\n<p><a href=\"http://ideone.com/kB3wnu\" rel=\"nofollow\">http://ideone.com/kB3wnu</a></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;mutex&gt;\n#include &lt;memory&gt;\n#include &lt;vector&gt;\n#include &lt;numeric&gt;\n#include &lt;algorithm&gt;\n\ntemplate&lt;typename T, typename mutex_type = std::recursive_mutex&gt;\nclass execute_around {\n  std::shared_ptr&lt;mutex_type&gt; mtx;\n  std::shared_ptr&lt;T&gt; p;\n\n  void lock() const { mtx-&gt;lock(); }\n  void unlock() const { mtx-&gt;unlock(); }\n  public:\n    class proxy {\n      std::unique_lock&lt;mutex_type&gt; lock;\n      T *const p;\n      public:\n        proxy (T * const _p, mutex_type&amp; _mtx) : p(_p), lock(_mtx) {} \n        T* operator -&gt; () {return p;}\n        const T* operator -&gt; () const {return p;}\n    };\n\n    template&lt;typename ...Args&gt;\n    execute_around (Args ... args) : \n        p(std::make_shared&lt;T&gt;(args...)), mtx(std::make_shared&lt;mutex_type&gt;()) {}  \n\n    proxy operator -&gt; () { return proxy(p.get(), *mtx); }\n    const proxy operator -&gt; () const { return proxy(p.get(), *mtx); }\n    template&lt;class... Args&gt; friend class std::lock_guard;\n};\n\nvoid thread_func(execute_around&lt;std::vector&lt;int&gt;&gt; vecc) \n{\n  vecc-&gt;push_back(100); // thread-safe  \n  int res = std::accumulate(vecc-&gt;begin(), vecc-&gt;end(), 0); // thread-safe\n  std::cout &lt;&lt; std::string(\"res = \" + std::to_string(res) + \"\\n\");\n\n  { //all the following code in this scope is thread safe\n    std::lock_guard&lt;decltype(vecc)&gt; lock(vecc);\n    auto it = std::find(vecc-&gt;begin(), vecc-&gt;end(), 100);\n    if(it != vecc-&gt;end()) std::cout &lt;&lt; *it &lt;&lt; std::endl;\n  }\n}\n\nint main()\n{\n  execute_around&lt;std::vector&lt;int&gt;&gt; vecc(10, 10);\n\n  auto copied_vecc_ptr = vecc; // copy-constructor\n\n  std::thread t1([&amp;]() { thread_func(copied_vecc_ptr); });\n  std::thread t2([&amp;]() { thread_func(copied_vecc_ptr); });\n  t1.join(); t2.join();\n\n  return 0;\n}\n</code></pre>\n<p>Output:</p>\n<pre><code>res = 200\n100\nres = 300\n100\n</code></pre>\n<p>We can use <code>execute_around</code> for any types, any mutexes, and any locks if it added as <code>friend</code>, with several features:</p>\n<p><strong>Advantages over the standard</strong> <code>std::recursive_mutex</code>:</p>\n<ul>\n<li>you can't get access to member of object without locking mutex, will not forget - is done automatically</li>\n<li>you can not choosing a wrong mutex which protects another object or section of code</li>\n</ul>\n<p>Other features:</p>\n<ul>\n<li>you will not forget to unlock the mutex after accessing</li>\n<li>if you know that this object can be used from multiple threads, then that no one should ever access it without locking the mutex - and <code>execute_around</code> guarantees this (but in addition you can use it together with other mutexes which protect whole code section, not only one object)</li>\n<li>you can pass members of object as parameters to the function and this will thread-safe during the entire execution of the function - as we done for <code>std::accumulate()</code></li>\n<li>we do not get the deadlock when we get accessing multiple members (variables and functions) and do multiple locks in a single expression - if we use <code>std::recursive_mutex</code></li>\n<li>it hasn't <code>operator *</code> then you can't get thread-unsafe reference to object, but can get unsafe reference to members of object</li>\n<li>it has copy-constructor, but hasn't assignment-<code>operator =</code></li>\n<li>it may has many copies which pointed to the single object &amp; mutex</li>\n</ul>\n<p><strong>Possible problems</strong></p>\n<p>In some cases we should use <code>executive_around</code> as standard <code>std::mutex</code> i.e. use <code>lock_guard</code>, but if we forgot this (<code>std::lock_guard&lt;decltype(vecc)&gt; lock(vecc);</code>), then we get a problem:</p>\n<ul>\n<li>we can get reference to member of object, and later use it thread-unsafe</li>\n<li>we can get iterators of this object, and later use it thread-unsafe, also it can be invalidated by other threads</li>\n</ul>\n<p>Is there any additional possible problems explaining why is not used Execute-Around Idiom in Boost as smart pointer for thread-safe access to object?</p>\n<p>I.e. what are other problems that <code>executive_around</code> has, but standard mutexes and locks hasn't these problems?</p>\n<hr>\n<p>How behaves <code>proxy</code> class: <a href=\"http://en.cppreference.com/w/cpp/language/lifetime\" rel=\"nofollow\">Temporary object lifetime</a></p>\n<p>2016-07-12 Working Draft, Standard for Programming Language C++: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4606.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4606.pdf</a></p>\n<blockquote>\n<p id=\"so_38731039_38731039_0\">12.2 Temporary objects</p>\n<p id=\"so_38731039_38731039_1\">\u00a7 12.2 6 The third context is when a reference is bound to a\n  temporary.115 The temporary to which the reference is bound or the\n  temporary that is the complete object of a subobject to which the\n  reference is bound persists for the lifetime of the reference except:</p>\n<p id=\"so_38731039_38731039_2\">(6.1) ...</p>\n<p id=\"so_38731039_38731039_3\">(6.2) \u2014 The lifetime of a temporary bound to the returned value in a\n  function return statement (6.6.3) is not extended; the temporary is\n  destroyed at the end of the full-expression in the return statement.</p>\n<p id=\"so_38731039_38731039_4\">(6.3) ...</p>\n<p id=\"so_38731039_38731039_5\">The destruction of a temporary whose lifetime is not extended by being\n  bound to a reference is sequenced before the destruction of every\n  temporary which is constructed earlier in the same full-expression. If\n  the lifetime of two or more temporaries to which references are bound\n  ends at the same point, these temporaries are destroyed at that point\n  in the reverse order of the completion of their construction.</p>\n</blockquote>\n</hr>", "Title": "Why is not used Execute-Around Idiom in Boost as smart pointer for thread-safe access to object?", "CreationDate": "2016-08-02T21:46:50.677", "LastActivityDate": "2016-08-03T00:32:05.583", "CommentCount": "5", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2016-08-02T23:51:15.787", "Tags": "<c++><multithreading><c++11><boost><concurrency>", "Id": "38731039", "LastEditorUserId": "1558037", "Score": "1", "OwnerUserId": "1558037", "ClosedDate": "2016-08-03T08:59:21.610", "AnswerCount": "1"}, "38731841": {"Id": "38731841", "PostTypeId": "2", "Body": "<p>In general mutex based thread safety does not compose.</p>\n<p>Ie, if operation <code>A</code> is thread safe, and operation <code>B</code> is thread safe, operation <code>A</code> and operation <code>B</code> together is not.</p>\n<p>Because of this, you cannot \"drop in and forget\".  You must be aware you are doing mutex based operations, which makes the transparency of the execute-around dangerous.</p>\n<p>As an example, suppose you have a thread safe container.</p>\n<p>You do this:</p>\n<pre><code>std::vector&lt;Element&gt; dest;\nstd::copy_if( c-&gt;begin(), c-&gt;end(), std::back_inserter(dest),\n[&amp;](auto&amp;&amp; e){\n  this-&gt;ShouldCopy(e);\n});\n</code></pre>\n<p>that looks safe, no?  We upgrade the container <code>c</code> from a normal container-smart-pointer to an execute-around smart pointer, and it now locks <code>c</code> prior to access.</p>\n<p>All is good.</p>\n<p>But it is not.  If <code>this-&gt;ShouldCopy(Element const&amp;)</code> aquires <em>any mutex</em> (say <code>bob</code>), we have just created a potential deadlock.</p>\n<p>If <code>bob</code> is elsewhere locked before the mutex within <code>c</code>, both threads can lock up and starve forever.</p>\n<p>This can happen non-deterministically, and it does not depend on the local correctness of the code in question (at least in C++).  You can only spot it through global code analysis.</p>\n<p>In this case, the transparency of the lock on the <code>mutex</code> can make the code <em>less</em> safe than if it was more obvious that we are getting a mutex.  Because at least if it is obvious and expensive, it might be more isolated and easier to track down.</p>\n<p>This is also why some people consider recursive mutexes to be an anti-pattern: if you have so little control over your use of a mutex that you cannot prevent getting it recursively, your code probably isn't managing a global order on all mutexes.</p>\n<p>In addition, guarding the contents of a <code>shared_ptr</code> separate mutex is silly.  Store both the mutex and the object in the same structure, don't ruin locality.</p>\n<hr>\n<p>That being said, I do use a variant of what you wrote.</p>\n<pre><code>template&lt;class T&gt;\nstruct mutex_guarded {\n  template&lt;class F&gt;\n  auto write( F&amp;&amp; f ) { return access( std::forward&lt;F&gt;(f), *this); }\n  template&lt;class F&gt;\n  auto read( F&amp;&amp; f ) const { return access( std::forward&lt;F&gt;(f), *this); }\n\n  template&lt;class F, class...Guarded&gt;\n  friend auto access( F&amp;&amp; f, Guarded&amp;&amp;...guardeds );\nprivate:\n  T t;\n  std::shared_timed_mutex m;\n};\n</code></pre>\n<p>where <code>access</code> takes any number of <code>mutex_guarded</code> and properly locks them in order, then passes the wrapped <code>t</code>s o the passed in <code>f</code>.</p>\n<p>This permits:</p>\n<pre><code>c.read( [&amp;](auto&amp;&amp; c){\n  std::copy_if( c.begin(), c.end(), std::back_inserter(dest),\n  [&amp;](auto&amp;&amp; e){\n    this-&gt;ShouldCopy(e);\n  });\n} );\n</code></pre>\n<p>which at least makes the mutex use vulgar.  Similarly, there is no way to access the data without going through the read or write functions, so all access has a mutex.  But here, we can at least multi-lock, and searching the code for mutex use is possible.</p>\n<p>It still suffers from deadlock risks, but in general mutex-based structures all have that problem.</p>\n</hr>", "LastEditorUserId": "1774667", "LastActivityDate": "2016-08-03T00:32:05.583", "Score": "3", "CreationDate": "2016-08-02T23:06:23.127", "ParentId": "38731039", "CommentCount": "4", "OwnerUserId": "1774667", "LastEditDate": "2016-08-03T00:32:05.583"}});