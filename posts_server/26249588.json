post_cb({"26249588": {"CommentCount": "8", "AcceptedAnswerId": "26251595", "PostTypeId": "1", "LastEditorUserId": "397706", "CreationDate": "2014-10-08T05:09:42.243", "LastActivityDate": "2014-10-08T17:38:21.857", "LastEditDate": "2014-10-08T17:38:21.857", "ViewCount": "598", "FavoriteCount": "1", "Title": "C++: Destructor being called outside object scope?", "Id": "26249588", "Score": "5", "Body": "<p><strong>Update 1:</strong> Added printing \"this\" as suggested.</p>\n<p><strong>Update 2:</strong> Split into several files to try and stop gcc from optimizing.</p>\n<p><strong>Update 3:</strong> Logged copy constructor and entering add functions.</p>\n<p><strong>Update 4:</strong> Added output from Clang and second cout in main.</p>\n<p>I expect parameter destructors to be called as the last statements in a function. Henceforth, I would expect the following output from the code below.</p>\n<pre><code>default constructor: 008DFCF8\nother constructor: 008DFCEC\ncopy constructor: 008DFBC0\nin member add\ndestroying: 008DFBC0\ncopy constructor: 008DFBB8\ncopy constructor: 008DFBB4\nin function add\ndestroying: 008DFBB4\ndestroying: 008DFBB8\n3 == 3\nend of main\ndestroying: 008DFCEC\ndestroying: 008DFCF8\n</code></pre>\n<p>When using MSVC (Visual Studio), the output is as expected. But GCC (4.8.2-19ubuntu1) outputs the following that shows that the destructors for the function parameters are being called after the first cout statement in main() but before the last one.</p>\n<pre><code>default constructor: 0x7fff2fcea510\nother constructor: 0x7fff2fcea520\ncopy constructor: 0x7fff2fcea550\nin member add\ncopy constructor: 0x7fff2fcea540\ncopy constructor: 0x7fff2fcea530\nin function add\n3 == 3\ndestroying: 0x7fff2fcea530\ndestroying: 0x7fff2fcea540\ndestroying: 0x7fff2fcea550\nend of main\ndestroying: 0x7fff2fcea520\ndestroying: 0x7fff2fcea510\n</code></pre>\n<p>For those that are curious what clang++ (3.4-1ubuntu3) outputs.</p>\n<pre><code>default constructor: 0x7fff52cf9878\nother constructor: 0x7fff52cf9870\ncopy constructor: 0x7fff52cf9860\ncopy constructor: 0x7fff52cf9858\nin function add\n3 == copy constructor: 0x7fff52cf9850\nin member add\n3\ndestroying: 0x7fff52cf9850\ndestroying: 0x7fff52cf9858\ndestroying: 0x7fff52cf9860\nend of main\ndestroying: 0x7fff52cf9870\ndestroying: 0x7fff52cf9878\n</code></pre>\n<hr>\n<p><strong>Questions:</strong></p>\n<ol>\n<li>My initial suspicion is that GCC is inlining the functions? If this is true is there a way to disable this optimization?</li>\n<li>What section in the C++ spec would allow the destructors to be called after the cout in main? Especially of interest are the rules on inlining, if relevant, and when destructors are scheduled.</li>\n</ol>\n<hr>\n<pre><code>// Test.h\n#ifndef __TEST_H__\n\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Test\n{\npublic:\n    int val;\n\n    Test(Test const &amp;a) : val(a.val)\n    {\n        cout &lt;&lt; \"copy constructor: \" &lt;&lt; this &lt;&lt; endl;\n    }\n\n    Test() : val(1)\n    {\n        cout &lt;&lt; \"default constructor: \" &lt;&lt; this &lt;&lt; endl;\n    }\n\n    Test(int val) : val(val)\n    {\n        cout &lt;&lt; \"other constructor: \" &lt;&lt; this &lt;&lt; endl;\n    }\n\n    ~Test()\n    {\n        cout &lt;&lt; \"destroying: \" &lt;&lt; this &lt;&lt; endl;\n    }\n\n    int add(Test b);\n};\n\n#endif\n</code></pre>\n<hr>\n<pre><code>// Add.cpp\n#include \"Test.h\"\n\nint Test::add(Test b)\n{\n    cout &lt;&lt; \"in member add\" &lt;&lt; endl;\n    return val + b.val;\n}\n\nint add(Test a, Test b)\n{\n    cout &lt;&lt; \"in function add\" &lt;&lt; endl;\n    return a.val + b.val;\n}\n</code></pre>\n<hr>\n<pre><code>// Main.cpp\n#include \"Test.h\"\n\nint add(Test a, Test b);\n\nint main()\n{\n    Test one, two(2);\n\n    cout &lt;&lt; add(one, two) &lt;&lt; \" == \" &lt;&lt; one.add(two) &lt;&lt; endl;\n\n    cout &lt;&lt; \"end of main\" &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<hr>\n<p>Compiled for GCC using:</p>\n<pre><code>g++ -c Add.cpp -o Add.o ; g++ -c Main.cpp -o Main.o ; g++ Add.o Main.o -o test\n</code></pre>\n</hr></hr></hr></hr></hr>", "Tags": "<c++><destructor>", "OwnerUserId": "397706", "AnswerCount": "3"}, "26251548": {"ParentId": "26249588", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Consider this line:</p>\n<pre><code>cout &lt;&lt; add(one, two) &lt;&lt; \" == \" &lt;&lt; one.add(two) &lt;&lt; endl;\n</code></pre>\n<p>Written as:</p>\n<pre><code>cout &lt;&lt; add(one, two);\ncout &lt;&lt; \" == \" &lt;&lt; one.add(two) &lt;&lt; endl;\n</code></pre>\n<p>Would that change the printout for GCC?</p>\n<p>Or that way:</p>\n<pre><code>auto i = add(one, two);\ncout &lt;&lt; i &lt;&lt; \" == \";\nauto j = one.add(two)\ncout &lt;&lt; j &lt;&lt; endl;\n</code></pre>\n<p>I think that this is about <strong>side-effects</strong> (not about inlining).\nVC seems to be scheduling side-effects (destruction of temporary objects) earlier, while GCC schedules it at end of statement - <code>;</code></p>\n<hr>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/lifetime\" rel=\"nofollow\">Added quote:</a></p>\n<blockquote>\n<h2>Temporary object lifetime</h2>\n<p id=\"so_26249588_26251548_0\">Temporary objects are created in various situations: binding a\n  reference to a prvalue, returning a prvalue from a function, cast to a\n  prvalue, throwing an exception, entering an exception handler, and in\n  some initializations. <strong>In every case, all temporaries are destroyed <em>as\n  the last step</em> in evaluating the full-expression</strong> that (lexically)\n  contains the point where they were created, and if multiple\n  temporaries were created, they are destroyed in the order opposite to\n  the order of creation. This is true even if that evaluation ends in\n  throwing an exception.</p>\n</blockquote>\n<p>In my opinion, this speaks for GCC and against VC (especially about printing \"3 == 3\" after the destruction, that is strange for me).</p>\n</hr>", "OwnerUserId": "1722660", "LastEditorUserId": "1722660", "LastEditDate": "2014-10-08T08:49:47.783", "Id": "26251548", "Score": "2", "CreationDate": "2014-10-08T07:38:00.833", "LastActivityDate": "2014-10-08T08:49:47.783"}, "26251595": {"ParentId": "26249588", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>It seems that the C++ standard might be a little ambiguous regarding exactly when function parameter destructors must be called.  C++03 and C++11 both say in 5.2.2/4 \"Function call\" (emphasis added): </p>\n<blockquote>\n<p id=\"so_26249588_26251595_0\">The lifetime of a parameter ends when the function in which it is\n  defined returns.  The initialization and destruction of each parameter\n  occurs within the context of the <strong>calling</strong> function.</p>\n</blockquote>\n<p>So the destructor for parameters doesn't occur conceptually at the function's closing brace. This is something I didn't know.</p>\n<p>The standard gives a note explaining how this means that if the destructor for a parameter throws, then only exception handlers for the calling function or 'higher' are considered (specifically, even if the called function has a 'function-try-block', it is not considered).</p>\n<p>While I think that the intent is for the MSVC behavior, I could see how someone might interpret a reading that allows the GCC behavior.</p>\n<p>Then again, maybe it's a bug in GCC?</p>\n", "OwnerUserId": "12711", "LastEditorUserId": "12711", "LastEditDate": "2014-10-08T07:49:27.387", "Id": "26251595", "Score": "2", "CreationDate": "2014-10-08T07:41:49.680", "LastActivityDate": "2014-10-08T07:49:27.387"}, "bq_ids": {"n4140": {"so_26249588_26251595_0": {"section_id": 5991, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_26249588_26251595_0": {"section_id": 5759, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_26249588_26251595_0": {"section_id": 7491, "quality": 0.8888888888888888, "length": 16}}}, "26249647": {"ParentId": "26249588", "CommentCount": "3", "Body": "<p>You create temporary objects when calling \"add(a,b)\", and when calling the member add(b).\nI think what you are seeing in the case of gcc is that the local variables in the add() functions (the parameters) are destroyed when those functions return.\nThe last two \"done\" lines are for the variables \"one\" and \"two\".</p>\n<p>VC is different - but this isn't wrong, it just shows that the two compilers are optimizing the code in different ways.</p>\n<p>Instead of just printing \"done\", try also printing the value \"this\". Print \"this\" in the constructor as well, then you can see how the constructors and destructor calls are paired.</p>\n<p>Oops - I mixed that up a bit between VC and GCC. VC prints \"done\" three times first - presumably as the add() parameters are destroyed, while GCC does them all last, probably because it inlined the add functions.</p>\n", "OwnerUserId": "1791696", "PostTypeId": "2", "Id": "26249647", "Score": "2", "CreationDate": "2014-10-08T05:16:05.980", "LastActivityDate": "2014-10-08T05:16:05.980"}});