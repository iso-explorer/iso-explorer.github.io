post_cb({"40919654": {"CommentCount": "0", "ViewCount": "378", "PostTypeId": "1", "LastEditorUserId": "3723423", "CreationDate": "2016-12-01T20:20:29.650", "LastActivityDate": "2016-12-01T23:44:07.470", "Title": "Why does this double mutex lock not cause deadlock?", "AcceptedAnswerId": "40920010", "LastEditDate": "2016-12-01T20:45:43.630", "Id": "40919654", "Score": "0", "Body": "<p>I test c++11 mutex in my centos computer.  I try to double lock this mutex to make deadlock. But after I run it, everything is fine and no deadlock occurs.</p>\n<pre><code>#include &lt;thread&gt;\n#include &lt;mutex&gt;\n#include &lt;iostream&gt;\nstd::mutex m;\nint main()\n{\n  m.lock();\n  m.lock();\n  std::cout&lt;&lt;\"i am ok\"&lt;&lt;std::endl;\n\n  return 0;  \n}\n</code></pre>\n<p>The compiler is g++ 4.8.5 in centos 3.10.0-327.36.3.el7.x86_64: </p>\n<pre><code>[zzhao010@localhost shareLibPlay]$ ./3.out\ni am ok\n</code></pre>\n", "Tags": "<c++><multithreading><c++11><mutex><deadlock>", "OwnerUserId": "6722995", "AnswerCount": "3"}, "40919676": {"ParentId": "40919654", "CommentCount": "3", "Body": "<p>Locking a <code>std::mutex</code> that is already locked by the same thread is <em>undefined behavior</em> and therefore it may work, it may fail, it may drink all your beer and throw up on the couch.  No guarantees.</p>\n", "OwnerUserId": "82294", "PostTypeId": "2", "Id": "40919676", "Score": "8", "CreationDate": "2016-12-01T20:22:46.743", "LastActivityDate": "2016-12-01T20:22:46.743"}, "40919704": {"ParentId": "40919654", "CommentCount": "0", "Body": "<p>The behavior is undefined in case you invoke <code>lock</code> twice as you did.<br>\n<em>It works as you would expect it to do</em> is a valid undefined behavior indeed.</br></p>\n<p>See <a href=\"http://en.cppreference.com/w/cpp/thread/mutex/lock\" rel=\"noreferrer\">here</a> for further details.</p>\n", "OwnerUserId": "4987285", "PostTypeId": "2", "Id": "40919704", "Score": "8", "CreationDate": "2016-12-01T20:23:54.527", "LastActivityDate": "2016-12-01T20:23:54.527"}, "40920010": {"ParentId": "40919654", "PostTypeId": "2", "CommentCount": "9", "Body": "<h3>For a deadlock, you need at least two</h3>\n<p>By <a href=\"https://en.wikipedia.org/wiki/Deadlock\" rel=\"nofollow noreferrer\">definition</a>, a deadlock involves at least 2 parties. This was laid down by many authors, among others <a href=\"https://en.wikipedia.org/wiki/Tony_Hoare\" rel=\"nofollow noreferrer\">Hoare</a> in his pioneering work <em>Communicating Sequential Processes</em>.  This is also reminded in the C++ standard definitions (emphasis is mine):  </p>\n<blockquote>\n<p id=\"so_40919654_40920010_0\"><strong>17.3.8:</strong> Deadlock: one or more threads are unable to continue execution because\n  each is blocked waiting for one or more <strong>of the others</strong> to satisfy some\n  condition</p>\n</blockquote>\n<p>A more illustrative definition is given by Anthony Williams, in <em>C++ concurrency in action</em></p>\n<blockquote>\n<p id=\"so_40919654_40920010_1\">Neither thread can proceed, because each is waiting for the other to release it's mutex.  This scenario is called deadlock and it's the biggest problem with having to lock two or more mutexes. </p>\n</blockquote>\n<p>You can therefore by definition not create a deadlock with a single thread in a single process. </p>\n<h3>Don't misunderstand the standard</h3>\n<p>The standard says on mutexes:  </p>\n<blockquote>\n<p id=\"so_40919654_40920010_2\"><strong>30.4.1.2.1/4</strong> [Note: A program may deadlock if the thread that owns a mutex object calls lock() on that object.]</p>\n</blockquote>\n<p>This is a non-normative note.  I think it embarrassingly contradicts the standard's own definition. From the terminology point of view, a process that locks itself is in a blocked state. </p>\n<p>But more important, and beyond the issue of deadlock terminology,  the word \"MAY\" allows the said behavior for C++ implementations (e.g. if it is not able on a particular OS to detect a redundant lock acquisition).  But it's not required at all : I believe that most mainstream C++ implementation will work fine, exactly as you have experienced yourself.  </p>\n<h3>Want to experience with deadlocks ?</h3>\n<p>If you want to experience with real deadlocks, or if you want simply to find out if your C++ implementation is able to detect the <code>resource_deadlock_would_occur</code> error, here a short example.  It could go fine but has high probability of creating a deadlock:   </p>\n<pre><code>std::mutex m1,m2;\nvoid foo() {\n    m1.lock();\n    std::cout&lt;&lt;\"foo locked m1\"&lt;&lt;std::endl;\n    std::this_thread::sleep_for (std::chrono::seconds(1));\n    m2.lock();\n    m1.unlock(); \n    std::cout&lt;&lt;\"foo locked m2 and releases m1\"&lt;&lt;std::endl;\n    m2.unlock(); \n    std::cout&lt;&lt;\"foo is ok\"&lt;&lt;std::endl;\n}\nvoid bar() {\n    m2.lock();\n    std::cout&lt;&lt;\"bar locked m2\"&lt;&lt;std::endl;\n    std::this_thread::sleep_for (std::chrono::seconds(1));\n    m1.lock();\n    m2.unlock(); \n    std::cout&lt;&lt;\"barlocked m1 and releases m2\"&lt;&lt;std::endl;\n    m1.unlock(); \n    std::cout&lt;&lt;\"bar is ok\"&lt;&lt;std::endl;\n}\nint main()\n{\n    std::thread t1(foo); \n    bar(); \n    t1.join(); \n    std::cout &lt;&lt; \"Everything went fine\"&lt;&lt;std::endl; \n    return 0;  \n}\n</code></pre>\n<p><a href=\"http://ideone.com/IuYh8n\" rel=\"nofollow noreferrer\">Online demo</a></p>\n<p>This kind of deadlock is avoided by locking the different mutexes always in the same order. </p>\n", "OwnerUserId": "3723423", "LastEditorUserId": "3723423", "LastEditDate": "2016-12-01T23:44:07.470", "Id": "40920010", "Score": "1", "CreationDate": "2016-12-01T20:44:11.690", "LastActivityDate": "2016-12-01T23:44:07.470"}, "bq_ids": {"n4140": {"so_40919654_40920010_2": {"section_id": 2777, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_40919654_40920010_2": {"section_id": 2738, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_40919654_40920010_2": {"section_id": 3515, "quality": 0.8181818181818182, "length": 9}, "so_40919654_40920010_0": {"section_id": 7709, "quality": 0.8888888888888888, "length": 16}}}});