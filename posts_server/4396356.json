post_cb({"4397350": {"ParentId": "4396356", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>It means that the parser first determines whether the expression before the parentheses is an <em>id</em> or a <em>postfix-expression</em>. In this case, it sees <code>f</code>, and the nearest <code>f</code> defined is <code>typedef int f</code> - therefore it concludes the expression is interpreted as <code>int(a)</code> and no Koenig lookup is performed.</p>\n<p>Let's have this code (you an try it online: <a href=\"http://ideone.com/clone/eRKvP\" rel=\"nofollow\">http://ideone.com/clone/eRKvP</a>)</p>\n<pre><code>typedef int f;\nnamespace x {\n  struct A {\n    friend void f(A &amp;);\n    //friend void f(); // # 1\n    operator int();\n    void g(A a) {\n      //void f();  // # 2\n      (void)f(a); // # 3\n    }\n  };\n}\n</code></pre>\n<p>Had you declared an (unrelated) function <code>f</code> visible from <code>g</code>, it would be interpreted as a function call and Koenig lookup would find the correct overload (see line <code>#2</code>).</p>\n<p>The friend declaration of <code>f</code> should not apply here, because </p>\n<blockquote>\n<p id=\"so_4396356_4397350_0\">11.4/1: ... The name of a friend is not in the scope of the class, </p>\n</blockquote>\n<p>However, what's disturbing me, is that uncommenting <code>#1</code> makes the compiler (gcc in this case) call <code>x::f(A&amp;)</code> too. Not sure why is that. [In Comeau Online compiler, it works as expected (eg. <code>#1</code> doesn't influence line <code>#3</code>). The latest beta version has problems compiling this code, though.]</p>\n<p>PS: As noted by litb, the rules in C++0x are a little different:</p>\n<blockquote>\n<p id=\"so_4396356_4397350_1\">3.4.2/3:</p>\n<p id=\"so_4396356_4397350_2\">Let X be the lookup set produced by\n  unquali\ufb01ed lookup (3.4.1) and let Y be\n  the lookup set produced by argument\n  dependent lookup (de\ufb01ned as follows).\n  If X contains</p>\n<ul>\n<li>a declaration of a class member, or</li>\n<li><strong>a block-scope function declaration</strong> that is not a using-declaration, or</li>\n<li>a declaration that is neither a function or a function template</li>\n</ul>\n<p id=\"so_4396356_4397350_3\">then Y is empty. Otherwise Y is the\n  set of declarations found in the\n  namespaces associated with the</p>\n</blockquote>\n<p>The bold item will make the compiler only consider <code>void f()</code> and fail for too many arguments.</p>\n<p>It seems to have been introduced by the resolution of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#218\" rel=\"nofollow\">issue 218</a>.</p>\n", "OwnerUserId": "51831", "LastEditorUserId": "51831", "LastEditDate": "2010-12-09T14:22:13.437", "Id": "4397350", "Score": "1", "CreationDate": "2010-12-09T10:45:13.013", "LastActivityDate": "2010-12-09T14:22:13.437"}, "4396356": {"CommentCount": "0", "AcceptedAnswerId": "4397350", "PostTypeId": "1", "LastEditorUserId": "1268895", "CreationDate": "2010-12-09T08:51:01.540", "LastActivityDate": "2012-05-01T02:31:53.830", "LastEditDate": "2012-05-01T02:31:53.830", "ViewCount": "472", "FavoriteCount": "0", "Title": "friend function", "Id": "4396356", "Score": "4", "Body": "<p>What does the following mean (especially the highlighted portion)? Why is the expression 'f(a)' treated as a 'cast expression'?</p>\n<blockquote>\n<p id=\"so_4396356_4396356_0\">C++03 $3.4./3- \"The lookup for an unqualified name\n  used as the postfix-expression of a\n  function call is described in 3.4.2.\n  [Note: for purposes of determining\n  (during parsing) whether an expression\n  is a postfix-expression for a function\n  call, the usual name lookup rules\n  apply. The rules in 3.4.2 have no\n  effect on the syntactic interpretation\n  of an expression. For example,</p>\n</blockquote>\n<pre><code>typedef int f;\nstruct A {\nfriend void f(A &amp;);\noperator int();\nvoid g(A a) {\nf(a);\n}\n};\n</code></pre>\n<p><strong>The expression f(a) is a cast-expression equivalent to int(a). Because the expression is not a function call</strong>, the argument-dependent name lookup (3.4.2) does not apply and the friend function f is not found. ]\"</p>\n<p>Any thoughts?</p>\n", "Tags": "<c++><lookup>", "OwnerUserId": "418110", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_4396356_4397350_3": {"section_id": 7105, "quality": 1.0, "length": 8}, "so_4396356_4397350_2": {"section_id": 7105, "quality": 0.8235294117647058, "length": 14}, "so_4396356_4396356_0": {"section_id": 7089, "quality": 0.7777777777777778, "length": 28}, "so_4396356_4397350_0": {"section_id": 6692, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_4396356_4397350_3": {"section_id": 6849, "quality": 1.0, "length": 8}, "so_4396356_4397350_2": {"section_id": 6849, "quality": 0.8235294117647058, "length": 14}, "so_4396356_4396356_0": {"section_id": 6833, "quality": 0.7777777777777778, "length": 28}, "so_4396356_4397350_0": {"section_id": 5271, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_4396356_4397350_2": {"section_id": 8606, "quality": 0.8235294117647058, "length": 14}, "so_4396356_4397350_3": {"section_id": 8606, "quality": 1.0, "length": 8}, "so_4396356_4396356_0": {"section_id": 8590, "quality": 0.7777777777777778, "length": 28}, "so_4396356_4397350_0": {"section_id": 8167, "quality": 0.6666666666666666, "length": 4}}}});