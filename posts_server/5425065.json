post_cb({"5425065": {"CommentCount": "2", "AcceptedAnswerId": "5425343", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2011-03-24T20:24:32.833", "LastActivityDate": "2011-03-24T20:50:19.833", "LastEditDate": "2017-05-23T09:58:38.247", "ViewCount": "1177", "FavoriteCount": "1", "Title": "c++ pimpl idiom : Implementation depending on a template parameter", "Id": "5425065", "Score": "0", "Body": "<p>In <a href=\"https://stackoverflow.com/questions/5419670/inner-class-depending-on-a-template-argument\">this question</a> I unsuccessfully asked how to use different pimpl implementation depending on a template argument.</p>\n<p>Maybe this example ilustrates better what I am trying to do :</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt; int N, typename T &gt;\nstruct B\n{\n    B() : c( new C&lt; N &gt; )\n    {}\n\n    template&lt; int M &gt;\n    struct C;\n    C&lt; N &gt; *c;\n};\n\ntemplate&lt; int N, typename T &gt;\ntemplate&lt; int M &gt;\nstruct B&lt; N, T &gt;::C\n{\n    int a[M];\n};\n\n// version 1 that doesn't work    \n    template&lt; int N, typename T &gt;\n    template&lt; &gt;\n    struct B&lt; N, T &gt;::C&lt; 0 &gt;\n    {\n        int a;\n    };\n// version 2 that doesn't work\n    template&lt; typename T &gt;\n    template&lt; int M &gt;\n    struct B&lt; 0, T &gt;::C\n    {\n        int a;\n    };\n\n\nint main()\n{\n    B&lt; 0, float &gt;   b0;\n    B&lt; 1, int &gt;     b1;\n\n    std::cout &lt;&lt; \"b0 = \" &lt;&lt; sizeof(b0.c-&gt;a) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"b1 = \" &lt;&lt; sizeof(b1.c-&gt;a) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>It still fails if I try to specialize the struct C (the above doesn't compile)</p>\n<p>So, is it possible to do?</p>\n<p>I know a work around like this :</p>\n<pre><code>template&lt; int M &gt;\nstruct D\n{\n  int a[M];\n};\ntemplate&lt;  &gt;\nstruct D&lt;0&gt;\n{\n  int a;\n};\n\ntemplate&lt; int N, typename T &gt;\ntemplate&lt; int M &gt;\nstruct B&lt; N, T &gt;::C\n{\n    D&lt; M &gt; helper;\n};\n</code></pre>\n<p>but if possible, I would like to avoid it</p>\n", "Tags": "<c++><templates><metaprogramming><partial-specialization><pimpl-idiom>", "OwnerUserId": "476681", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_5425065_5425343_0": {"section_id": 278, "quality": 0.9836065573770492, "length": 60}}, "n3337": {"so_5425065_5425343_0": {"section_id": 269, "quality": 0.9836065573770492, "length": 60}}, "n4659": {"so_5425065_5425343_0": {"section_id": 285, "quality": 0.9836065573770492, "length": 60}}}, "5425343": {"ParentId": "5425065", "CommentCount": "3", "CreationDate": "2011-03-24T20:50:19.833", "OwnerUserId": "311314", "PostTypeId": "2", "Id": "5425343", "Score": "3", "Body": "<p>What you're trying to do is not allowed by the language.</p>\n<p>\u00a7 14.7.3.16 (FCD 2010-03-26) states:</p>\n<blockquote>\n<p id=\"so_5425065_5425343_0\">In an explicit specialization\n  declaration for a member of a class\n  template or a member template that\n  appears in namespace scope, the member\n  template and some of its enclosing\n  class templates may remain\n  unspecialized, except that the\n  declaration shall not explicitly\n  specialize a class member template if\n  its enclosing class templates are not\n  explicitly specialized as well. In\n  such explicit specialization\n  declaration, the keyword template\n  followed by a template-parameter-list\n  shall be provided instead of the\n  template&lt;&gt; preceding the explicit\n  specialization declaration of the\n  member. The types of the\n  template-parameters in the\n  template-parameter-list shall be the\n  same as those specified in the primary\n  template definition.</p>\n</blockquote>\n<pre><code>[ Example:\ntemplate &lt;class T1&gt; class A {\n    template&lt;class T2&gt; class B {\n        template&lt;class T3&gt; void mf1(T3);\n        void mf2();\n    };\n};\ntemplate &lt;&gt; template &lt;class X&gt;\n\nclass A&lt;int&gt;::B {\n    template &lt;class T&gt; void mf1(T);\n};\ntemplate &lt;&gt; template &lt;&gt; template&lt;class T&gt;\nvoid A&lt;int&gt;::B&lt;double&gt;::mf1(T t) { }\ntemplate &lt;class Y&gt; template &lt;&gt;\nvoid A&lt;Y&gt;::B&lt;double&gt;::mf2() { } // ill-formed; B&lt;double&gt; is specialized but\n// its enclosing class template A is not\n\u2014end example ]\n</code></pre>\n", "LastActivityDate": "2011-03-24T20:50:19.833"}});