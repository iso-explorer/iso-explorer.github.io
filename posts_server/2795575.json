post_cb({"2795596": {"Id": "2795596", "PostTypeId": "2", "Body": "<p>It's not quite the right question.  For C, at least, the right question is</p>\n<blockquote>\n<p id=\"so_2795575_2795596_0\">What happens to a function value in an rvalue context?</p>\n</blockquote>\n<p>(An rvalue context is anywhere a name or other reference appears where it should be used as a value, rather than a location\u2014basically anywhere except on the left-hand side of an assignment.  The name itself comes from the <em>right</em>-hand side of an assignment.)</p>\n<p>OK, so what happens to a function value in an rvalue context?  It is immediately and implicitly converted to a pointer to the original function value.  If you dereference that pointer with <code>*</code>, you get the same function value back again, which is immediately and implicitly converted into a pointer.  And you can do this as many times as you like.</p>\n<p>Two similar experiments you can try:</p>\n<ul>\n<li><p>What happens if you dereference a function pointer in an <em>lvalue</em> context\u2014the left-hand side of an assignment.  (The answer will be about what you expect, if you keep in mind that functions are immutable.)</p></li>\n<li><p>An array value is also converted to a pointer in an lvalue context, but it is converted to a pointer to the <em>element</em> type, not to a pointer to the array.  Dereferencing it will therefore give you an element, not an array, and the madness you show doesn't occur.</p></li>\n</ul>\n<p>Hope this helps.</p>\n<p>P.S. As to <em>why</em> a function value is implicitly converted to a pointer, the answer is that for those of use who use function pointers, it's a great convenience not to have to use <code>&amp;</code>'s everywhere.  There's a dual convenience as well: a function pointer in call position is automatically converted to a function value, so you don't have to write <code>*</code> to call through a function pointer.</p>\n<p>P.P.S. Unlike C functions, C++ functions can be overloaded, and I'm not qualified to comment on how the semantics works in C++.</p>\n", "LastEditorUserId": "41661", "LastActivityDate": "2010-05-09T03:13:36.440", "Score": "44", "CreationDate": "2010-05-08T20:58:05.330", "ParentId": "2795575", "CommentCount": "1", "OwnerUserId": "41661", "LastEditDate": "2010-05-09T03:13:36.440"}, "2795575": {"ViewCount": "23716", "Body": "<p>Why and how does dereferencing a function pointer just \"do nothing\"?</p>\n<p>This is what I am talking about:</p>\n<pre><code>#include&lt;stdio.h&gt;\n\nvoid hello() { printf(\"hello\"); }\n\nint main(void) { \n    (*****hello)(); \n}\n</code></pre>\n<hr>\n<p>From a comment over <a href=\"https://stackoverflow.com/questions/2669971/how-does-this-hello-world-program-work/2669996#2669996\">here</a>:</p>\n<blockquote>\n<p id=\"so_2795575_2795575_0\">function pointers dereference just\n  fine, but the resulting function\n  designator will be immediately\n  converted back to a function pointer</p>\n</blockquote>\n<hr>\n<p>And from an answer <a href=\"https://stackoverflow.com/questions/944479/how-come-pointer-to-a-function-be-called-without-dereferencing/944539#944539\">here</a>:</p>\n<blockquote>\n<p id=\"so_2795575_2795575_1\">Dereferencing (in way you think) a\n  function's pointer means: accessing a\n  CODE memory as it would be a DATA\n  memory.</p>\n<p id=\"so_2795575_2795575_2\">Function pointer isn't suppose to be\n  dereferenced in that way. Instead, it\n  is called.</p>\n<p id=\"so_2795575_2795575_3\">I would use a name \"dereference\" side\n  by side with \"call\". It's OK.</p>\n<p id=\"so_2795575_2795575_4\">Anyway: C is designed in such a way\n  that both function name identifier as\n  well as variable holding function's\n  pointer mean the same: address to CODE\n  memory. And it allows to jump to that\n  memory by using call () syntax either\n  on an identifier or variable.</p>\n</blockquote>\n<hr>\n<p><strong>How <em>exactly</em> does dereferencing of a function pointer work?</strong></p>\n</hr></hr></hr>", "AcceptedAnswerId": "2795596", "Title": "How does dereferencing of a function pointer happen?", "CreationDate": "2010-05-08T20:50:47.107", "Id": "2795575", "CommentCount": "0", "FavoriteCount": "27", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:02:36.450", "LastEditorUserId": "-1", "LastActivityDate": "2010-05-10T07:45:51.020", "Score": "54", "OwnerUserId": "113124", "Tags": "<c++><c><pointers><function-pointers>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_2795575_2795803_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 12}}, "n3337": {"so_2795575_2795803_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 9}}, "n4659": {"so_2795575_2795803_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 13}}}, "2795803": {"Id": "2795803", "PostTypeId": "2", "Body": "<p>C++03 \u00a74.3/1:</p>\n<blockquote>\n<p id=\"so_2795575_2795803_0\">An lvalue of function type T can be converted to an rvalue of type \u201cpointer to T.\u201d The result is a pointer to the function.</p>\n</blockquote>\n<p>If you attempt an invalid operation on a function reference, such as the unary <code>*</code> operator, the first thing the language tries is a standard conversion. It's just like converting an <code>int</code> when adding it to a <code>float</code>. Using <code>*</code> on a function reference causes the language to take its pointer instead, which in your example, is square 1.</p>\n<p>Another case where this applies is when assigning a function pointer.</p>\n<pre><code>void f() {\n    void (*recurse)() = f; // \"f\" is a reference; implicitly convert to ptr.\n    recurse(); // call operator is defined for pointers\n}\n</code></pre>\n<p>Note that this <em>doesn't</em> work the other way.</p>\n<pre><code>void f() {\n    void (&amp;recurse)() = &amp;f; // \"&amp;f\" is a pointer; ERROR can't convert to ref.\n    recurse(); // OK - call operator is *separately* defined for references\n}\n</code></pre>\n<p>Function reference variables are nice because they (in theory, I've never tested) hint to the compiler that an indirect branch may be unnecessary, if initialized in an enclosing scope.</p>\n<p>In C99, dereferencing a function pointer yields a function designator. \u00a76.3.2.1/4:</p>\n<blockquote>\n<p id=\"so_2795575_2795803_1\">A function designator is an expression that has function type. Except when it is the operand of the sizeof operator or the unary &amp; operator, a function designator with type \u2018\u2018function returning type\u2019\u2019 is converted to an expression that has type \u2018\u2018pointer to function returning type\u2019\u2019.</p>\n</blockquote>\n<p>This is more like Norman's answer, but notably C99 has no concept of rvalues.</p>\n", "LastEditorUserId": "153285", "LastActivityDate": "2010-05-09T00:07:06.170", "Score": "5", "CreationDate": "2010-05-08T21:58:43.317", "ParentId": "2795575", "CommentCount": "1", "OwnerUserId": "153285", "LastEditDate": "2010-05-09T00:07:06.170"}, "2801077": {"Id": "2801077", "PostTypeId": "2", "Body": "<p>How exactly does dereferencing of a function pointer work?</p>\n<p>Two steps. The first step is at compile time, the second at runtime.</p>\n<p>In step one, the compiler sees it has a pointer and a context in which that pointer is dereferenced (such as <code>(*pFoo)()</code> ) so it generates code for that situation, code that will be used in step 2.</p>\n<p>In step 2, at runtime the code is executed. The pointer contains some bytes indicating which function should be executed next. These bytes are somehow loaded into the CPU. A common case is a CPU with an explicit <code>CALL [register]</code> instruction. On such systems, a function pointer can be simply the address of a function in memory, and the derefencing code does nothing more than loading that address into a register followed by a <code>CALL [register]</code> instruction.</p>\n", "LastActivityDate": "2010-05-10T07:45:51.020", "CommentCount": "0", "CreationDate": "2010-05-10T07:45:51.020", "ParentId": "2795575", "Score": "1", "OwnerUserId": "15416"}, "2795980": {"Id": "2795980", "PostTypeId": "2", "Body": "<p>Put yourself in the shoes of the compiler writer.  A function pointer has a well defined meaning, it is a pointer to a blob of bytes that represent machine code.</p>\n<p>What do you do when the programmer dereferences a function pointer?  Do you take the first (or 8) bytes of the machine code and reinterpret that as a pointer?  Odds are about 2 billion to one that this won't work.  Do you declare UB?  Plenty of that going around already.  Or do you just ignore the attempt?  You know the answer.</p>\n", "LastActivityDate": "2010-05-08T23:04:49.473", "CommentCount": "1", "CreationDate": "2010-05-08T23:04:49.473", "ParentId": "2795575", "Score": "2", "OwnerUserId": "17034"}});