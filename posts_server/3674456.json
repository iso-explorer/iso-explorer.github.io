post_cb({"3674505": {"ParentId": "3674456", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>Because <code>a::get_dummy()</code> returns a <strong>unnamed temporary</strong> object (int pointer). <br>\nObject returned by function <strong>sit ontop of the stack frame</strong> and it is meaningless to get its address since it might be <strong>invalid after expression ends.</strong></br></p>\n", "OwnerUserId": "217571", "LastEditorUserId": "217571", "LastEditDate": "2010-09-09T08:09:26.287", "Id": "3674505", "Score": "4", "CreationDate": "2010-09-09T07:16:08.530", "LastActivityDate": "2010-09-09T08:09:26.287"}, "3674484": {"ParentId": "3674456", "CommentCount": "5", "Body": "<p>You could instead define:</p>\n<pre><code>int **get_dummy() ... return &amp;dummy;\n</code></pre>\n<p>You can think of an r-value as an expression, essentially, whereas an l-value is an actual object. Expressions don't have addresses, and even if they did, it's hard to imagine what good the address would be. It's easy to understand how the address of an object can be useful.</p>\n<p>It's a bit hard to understand an issue like this abstractly. The very best way to develop an understanding of pointers and compiled languages is to learn assembly language.</p>\n", "OwnerUserId": "140740", "PostTypeId": "2", "Id": "3674484", "Score": "7", "CreationDate": "2010-09-09T07:11:14.250", "LastActivityDate": "2010-09-09T07:11:14.250"}, "40762790": {"ParentId": "3674456", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The compiler is right, according to ISO C++ <a href=\"http://eel.is/c++draft/expr.unary.op#3\" rel=\"nofollow noreferrer\">\u00a7 5.3.1.3</a>:</p>\n<blockquote>\n<p id=\"so_3674456_40762790_0\">The result of the unary &amp; operator is a pointer to its operand. The\n  operand shall be an lvalue or a qualified-id.</p>\n</blockquote>\n<p>In other words, you can take an address of anything that <em>has a name</em>.</p>\n<p>Values returned from functions <strong><em>by-value</em></strong> have no name and are often returned via a <em>register</em>. So there is no \"<em>address</em>\" to speak of as the value is not residing in memory!</p>\n<p>One could argue that the compiler could be smarter, detect this and store the value on the stack for the duration of the expression in which the address is used. But that is error-prone (you can \"leak\" a pointer to outside the expression), and would clearly be an <em>extension</em> of the standard (i.e. not guaranteed to be compatible). So MSVC simply prohibits it.</p>\n<p>Entertainingly, the compiler <a href=\"http://en.cppreference.com/w/cpp/language/reference_initialization\" rel=\"nofollow noreferrer\"><em>is</em> that smart</a> when it comes to a <em>reference</em> to an rvalue. But there is no such functionality for a <em>pointer</em> to an rvalue.</p>\n<p><strong>To answer your question</strong>: try to minimize taking addresses of stuff; taking an address of a variable prevents the optimizer from putting it into a register.\nBut if you have to, return a reference instead:</p>\n<pre><code>class a {\nprivate:\n    int dummy;\npublic:\n    int get_dummy() const {\n        return dummy;\n    }\n    int&amp; get_dummy() {\n        return dummy;\n    }\n};\n\nint main()\n{\n    a aa;\n\n    int* me = &amp;(aa.get_dummy());\n}\n</code></pre>\n<p>Note that having a <code>const get_dummy()</code> is not strictly needed, but will help the optimizer in rvalue contexts.</p>\n", "OwnerUserId": "485343", "LastEditorUserId": "485343", "LastEditDate": "2016-11-23T11:33:55.977", "Id": "40762790", "Score": "0", "CreationDate": "2016-11-23T11:07:58.190", "LastActivityDate": "2016-11-23T11:33:55.977"}, "3674467": {"ParentId": "3674456", "CommentCount": "3", "Body": "<p>No.</p>\n<p>What address would <code>me</code> contain otherwise? Here you gave it the address of <code>tmp</code> -- but if you replace it with <code>int** me = &amp;aa.get_dummy();</code>, where would it point?</p>\n<p>There's no meaningful answer to that question, so the standard requires that the argument of <code>&amp;</code> be an lvalue.</p>\n", "OwnerUserId": "82320", "PostTypeId": "2", "Id": "3674467", "Score": "4", "CreationDate": "2010-09-09T07:07:33.633", "LastActivityDate": "2010-09-09T07:07:33.633"}, "3674456": {"CommentCount": "2", "AcceptedAnswerId": "3674505", "CreationDate": "2010-09-09T07:05:29.270", "LastActivityDate": "2016-11-23T11:33:55.977", "PostTypeId": "1", "ViewCount": "12241", "FavoriteCount": "2", "Title": "Why this is causing C2102: '&' requires l-value", "Id": "3674456", "Score": "7", "Body": "<p>I was wondering, why the following way of code (Already commented out) will cause<br>\n<code>C2102: '&amp;' requires l-value</code></br></p>\n<p>Is there a better way to avoid using <code>tmp</code> variable?</p>\n<pre><code>class a {\nprivate:\n    int *dummy;\npublic:\n    int* get_dummy() const {\n        return dummy;\n    }\n};\n\nint main()\n{\n    a aa;\n\n    // error C2102: '&amp;' requires l-value\n    //int** me = &amp;(aa.get_dummy());\n\n    // OK!\n    int *tmp = aa.get_dummy();\n    int** me = &amp;(tmp);\n}\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "72437", "AnswerCount": "5"}, "3674489": {"ParentId": "3674456", "CommentCount": "2", "Body": "<p>The <code>&amp;</code> operator must be applied to an lvalue. When the call <code>aa.get_dummy()</code> is not assigned to a variable, its return value is only put on the stack, so it would be silly (and erroneous) to get the address of a stack item.</p>\n", "OwnerUserId": "148481", "PostTypeId": "2", "Id": "3674489", "Score": "0", "CreationDate": "2010-09-09T07:12:36.540", "LastActivityDate": "2010-09-09T07:12:36.540"}, "bq_ids": {"n4140": {"so_3674456_40762790_0": {"section_id": 6066, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_3674456_40762790_0": {"section_id": 5834, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_3674456_40762790_0": {"section_id": 7562, "quality": 0.8181818181818182, "length": 9}}}});