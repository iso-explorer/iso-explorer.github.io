post_cb({"31703356": {"ParentId": "31702956", "PostTypeId": "2", "CommentCount": "0", "Body": "<pre><code>namespace N { static int i = 1; }\nnamespace M { struct i {}; }\nusing namespace M;\nusing namespace N;    \nint main() { sizeof(i); }\n</code></pre>\n<p>This is ill-formed. \u00a77.3.4/6:</p>\n<blockquote>\n<p id=\"so_31702956_31703356_0\">If name lookup finds a declaration for a name in two different\n  namespaces, and the declarations do not declare the same entity and do\n  not declare functions, the use of the name is ill-formed.</p>\n</blockquote>\n<p>The same applies to your second example. Note that the name hiding rule that applies in e.g.</p>\n<pre><code>struct A {} A;\n</code></pre>\n<p>\u2026doesn't apply in your case, as the two <code>i</code>s are declared in distinct scopes. Also,</p>\n<blockquote>\n<p id=\"so_31702956_31703356_1\">During unqualified name lookup ([basic.lookup.unqual]), the names\n  appear as if they were declared in the nearest enclosing namespace\n  which contains both the using-directive and the nominated namespace.</p>\n</blockquote>\n<p>Is irrelevant as well since any ambiguity that name lookup produces, as in your examples with <code>i</code>, is dealt with <em>after lookup</em> - here in e.g. the aforementioned \u00a77.3.4/6.</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-07-29T14:32:42.247", "Id": "31703356", "Score": "2", "CreationDate": "2015-07-29T14:25:45.453", "LastActivityDate": "2015-07-29T14:32:42.247"}, "31702956": {"CommentCount": "0", "AcceptedAnswerId": "31703369", "CreationDate": "2015-07-29T14:09:55.307", "LastActivityDate": "2015-07-29T14:32:42.247", "PostTypeId": "1", "ViewCount": "76", "FavoriteCount": "0", "Title": "Interpretation of [basic.scope.hiding]p2 when unqualified name lookup involves using-directives", "Id": "31702956", "Score": "3", "Body": "<p>There are two types of name hiding in c++:</p>\n<p>1) Normal name hiding: [basic.scope.hiding]p1 (<a href=\"http://eel.is/c++draft/basic.scope.hiding#1\" rel=\"nofollow\">http://eel.is/c++draft/basic.scope.hiding#1</a>):</p>\n<blockquote>\n<p id=\"so_31702956_31702956_0\">A name can be hidden by an explicit declaration of that same name in a\n  nested declarative region or derived class ([class.member.lookup]).</p>\n</blockquote>\n<p>2) The special type of name hiding in [basic.scope.hiding]p2 (<a href=\"http://eel.is/c++draft/basic.scope.hiding#2\" rel=\"nofollow\">http://eel.is/c++draft/basic.scope.hiding#2</a>):</p>\n<blockquote>\n<p id=\"so_31702956_31702956_1\">A class name ([class.name]) or enumeration name ([dcl.enum]) can be\n  hidden by the name of a variable, data member, function, or enumerator\n  declared in the same scope. If a class or enumeration name and a\n  variable, data member, function, or enumerator are declared in the\n  same scope (in any order) with the same name, the class or enumeration\n  name is hidden wherever the variable, data member, function, or\n  enumerator name is visible.</p>\n</blockquote>\n<p>I'm interested to know about how name hiding interacts with using-directives when unqualified name lookup is performed.</p>\n<p>For the first type of name hiding the behaviour is quite clear. This is because [basic.scope.hiding]p1 has been reformulated in terms of the rules in the section [basic.lookup.unqual] (<a href=\"http://eel.is/c++draft/basic.lookup.unqual\" rel=\"nofollow\">http://eel.is/c++draft/basic.lookup.unqual</a>)</p>\n<p>The same has not been done for the second type of name hiding. So the following question now arises:</p>\n<p>*) How should this second type of name hiding interact with unqualified name lookup that involves using-directives?</p>\n<p>Looking elsewhere in the standard I find [namespace.udir]p2 (<a href=\"http://eel.is/c++draft/namespace.udir#2\" rel=\"nofollow\">http://eel.is/c++draft/namespace.udir#2</a>) and I think this is key to answering this question:</p>\n<blockquote>\n<p id=\"so_31702956_31702956_2\">A using-directive specifies that the names in the nominated namespace\n  can be used in the scope in which the using-directive appears after\n  the using-directive. During unqualified name lookup\n  ([basic.lookup.unqual]), the names appear <strong>as if they were declared in</strong>\n  the nearest enclosing namespace which contains both the\n  using-directive and the nominated namespace. [ Note: In this context,\n  \u201ccontains\u201d means \u201ccontains directly or indirectly\u201d. \u2014 end note ]</p>\n</blockquote>\n<p>Applying the <strong>as if</strong> part of this rule to [basic.scope.hiding]p1 gives consistency with the rules in the section [basic.lookup.unqual]. This application is also consistent with [basic.scope.hiding]p4 (<a href=\"http://eel.is/c++draft/basic.scope.hiding#4\" rel=\"nofollow\">http://eel.is/c++draft/basic.scope.hiding#4</a>) So this looks promising.</p>\n<p>Because of this I think we can answer the question *) by similarly applying the <strong>as if</strong> part of [namespace.udir]p2 to [basic.scope.hiding]p2. This application is also consistent with [basic.scope.hiding]p4. I think this is also the most natural and least complex interpretation of the c++ standard.</p>\n<p>The problem however is that Clang and GCC does not make the same interpretation as me. For example:</p>\n<pre><code>namespace N { static int i = 1; }\nnamespace M { struct i {}; }\nusing namespace M;\nusing namespace N;    \nint main() { sizeof(i); }\n</code></pre>\n<p>According to my interpretation this program should be well-formed and <code>i</code> should be looked up as the integer variable. Both Clang and GCC disagree with this by giving a name lookup ambiguity.</p>\n<p>In the case of Clang this more complex interpretation leads to the following bug:</p>\n<pre><code>namespace N { static int i = 1; }\nnamespace M { struct i {}; }\nnamespace P {\n    using N::i;\n    using M::i;\n}\nnamespace Q { using M::i; }\nusing namespace P;\nusing namespace Q;\nint main() { sizeof (i); }\n</code></pre>\n<p>Gives no errors, but change</p>\n<pre><code>using namespace P;\nusing namespace Q;\n</code></pre>\n<p>into </p>\n<pre><code>using namespace Q;\nusing namespace P;\n</code></pre>\n<p>and we get name-lookup ambiguity error. GCC is at least consistent here.</p>\n<p>Did I interpret the c++ standard correctly?</p>\n", "Tags": "<c++><language-lawyer><using-directives><name-lookup>", "OwnerUserId": "1272610", "AnswerCount": "2"}, "31703369": {"ParentId": "31702956", "CommentCount": "5", "Body": "<p>The key phrases here I believe are:</p>\n<blockquote>\n<p id=\"so_31702956_31703369_0\">A name can be hidden by an explicit declaration of that same name <strong>in a nested</strong> declarative region or derived\n  class (10.2).</p>\n<p id=\"so_31702956_31703369_1\">A class name (9.1) or enumeration name (7.2) can be hidden by the name of a variable, data member,\n  function, or enumerator <strong>declared in the same scope</strong>.</p>\n</blockquote>\n<p>In this example:</p>\n<pre><code>namespace N { static int i = 1; }\nnamespace M { struct i {}; }\nusing namespace M;\nusing namespace N;    \nint main() { sizeof(i); }\n</code></pre>\n<p>Both <code>i</code>s are declared in different, non-nested scopes, so there is no hiding. Name lookup finds them <em>as if</em> they were declared in <code>::</code>, but that's not what the rule for hiding stipulates. </p>\n<p>Otherwise, we have, from [basic.lookup]:</p>\n<blockquote>\n<p id=\"so_31702956_31703369_2\">Name lookup shall\n  find an unambiguous declaration for the name (see 10.2). Name lookup may associate more than one declaration\n  with a name if it finds the name to be a function name;</p>\n</blockquote>\n<p>There is no unambiguous declaration in <code>::</code>, so this code is ill-formed and the error is correct. The same is true for the other example, so the fact that there is some <em>using-declaration</em> ordering for which clang compiles it is a bug. </p>\n<p>While this is non-normative, there is an example in [namespace.udir] that makes this interpretation clear:</p>\n<blockquote>\n<p id=\"so_31702956_31703369_3\"><em>[ Note:</em> In particular,\n  the name of a variable, function or enumerator <strong>does not hide</strong> the name of a class or enumeration declared\n  in a different namespace. For example,</p>\n<pre><code>namespace A {\n    class X { };\n    extern \"C\" int g();\n    extern \"C++\" int h();\n}\n\nnamespace B {\n    void X(int);\n    extern \"C\" int g();\n    extern \"C++\" int h(int);\n}\n\nusing namespace A;\nusing namespace B;\nvoid f() {\n   X(1); // error: name X found in two namespaces\n   g();  // OK: name g refers to the same entity\n   h();  // OK: overload resolution selects A::h\n}\n</code></pre>\n<p id=\"so_31702956_31703369_4\"><em>\u2014end note ]</em></p>\n</blockquote>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "31703369", "Score": "3", "CreationDate": "2015-07-29T14:26:22.777", "LastActivityDate": "2015-07-29T14:26:22.777"}, "bq_ids": {"n4140": {"so_31702956_31703369_1": {"section_id": 7079, "quality": 1.0, "length": 15}, "so_31702956_31703369_0": {"section_id": 7078, "quality": 0.9230769230769231, "length": 12}, "so_31702956_31702956_1": {"section_id": 7079, "quality": 0.9534883720930233, "length": 41}, "so_31702956_31702956_0": {"section_id": 7078, "quality": 0.9230769230769231, "length": 12}, "so_31702956_31702956_2": {"section_id": 5510, "quality": 0.8947368421052632, "length": 34}, "so_31702956_31703369_3": {"section_id": 5514, "quality": 0.875, "length": 14}, "so_31702956_31703369_2": {"section_id": 7083, "quality": 0.9523809523809523, "length": 20}, "so_31702956_31703356_0": {"section_id": 5514, "quality": 1.0, "length": 17}, "so_31702956_31703356_1": {"section_id": 5510, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_31702956_31703369_1": {"section_id": 6823, "quality": 1.0, "length": 15}, "so_31702956_31702956_2": {"section_id": 5296, "quality": 0.8947368421052632, "length": 34}, "so_31702956_31702956_1": {"section_id": 6823, "quality": 0.9534883720930233, "length": 41}, "so_31702956_31702956_0": {"section_id": 6822, "quality": 0.9230769230769231, "length": 12}, "so_31702956_31703369_0": {"section_id": 6822, "quality": 0.9230769230769231, "length": 12}, "so_31702956_31703369_3": {"section_id": 5300, "quality": 0.875, "length": 14}, "so_31702956_31703369_2": {"section_id": 6827, "quality": 0.9523809523809523, "length": 20}, "so_31702956_31703356_0": {"section_id": 5300, "quality": 1.0, "length": 17}, "so_31702956_31703356_1": {"section_id": 5296, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_31702956_31703369_1": {"section_id": 8580, "quality": 1.0, "length": 15}, "so_31702956_31702956_2": {"section_id": 6945, "quality": 0.8947368421052632, "length": 34}, "so_31702956_31702956_1": {"section_id": 8580, "quality": 0.9534883720930233, "length": 41}, "so_31702956_31703369_3": {"section_id": 6949, "quality": 0.875, "length": 14}, "so_31702956_31703369_0": {"section_id": 8579, "quality": 0.9230769230769231, "length": 12}, "so_31702956_31702956_0": {"section_id": 8579, "quality": 0.9230769230769231, "length": 12}, "so_31702956_31703356_0": {"section_id": 6949, "quality": 1.0, "length": 17}, "so_31702956_31703356_1": {"section_id": 6945, "quality": 0.9444444444444444, "length": 17}}}});