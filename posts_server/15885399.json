post_cb({"15888384": {"CommentCount": "6", "Body": "<p>Consider classes <code>Foo&lt;&amp;X&gt;</code> and <code>Foo&lt;&amp;Y&gt;</code>, both with a static member <code>int Bar</code>. The linker must be able to tell whether your program has 1 or 2 <code>Bar</code> objects. Now consider that the linker is also the party most likely responsible for assigning values to <code>&amp;X</code> and <code>&amp;Y</code>. </p>\n<p>Look at the Standard again. As it's written, the compiler doesn't need to communicate the actual <strong>address</strong> to the linker. Instead, it passes the <code>id-expression</code>. Linkers are already quite capable of determining whether two <code>id-expression</code>'s are the same, even before assigning a numerical address to them.</p>\n", "CreationDate": "2013-04-08T20:30:19.737", "ParentId": "15885399", "Id": "15888384", "LastActivityDate": "2013-04-08T20:30:19.737", "PostTypeId": "2", "Score": "1", "OwnerUserId": "15416"}, "15888396": {"CommentCount": "2", "Body": "<ol>\n<li>It cannot be a variable, since variables are only set at runtime.</li>\n<li>It cannot be a <code>constexpr</code>, since the <em>value</em> of an address cannot be known at compile time; in most cases it will only be fixed after relocation prior to execution.</li>\n<li>It might theoretically be an arithmetic expression (even though it isn't allowed in the standard), but in the common case of an address of an array element, you can simply use <code>&amp;arr[i]</code> instead of <code>arr + i</code>.</li>\n</ol>\n", "CreationDate": "2013-04-08T20:30:54.987", "ParentId": "15885399", "Id": "15888396", "LastActivityDate": "2013-04-08T20:30:54.987", "PostTypeId": "2", "Score": "0", "OwnerUserId": "1468366"}, "15885399": {"CreationDate": "2013-04-08T17:36:21.630", "ViewCount": "1045", "FavoriteCount": "6", "Id": "15885399", "Score": "22", "Title": "pointer as non-type template argument", "LastEditorUserId": "-1", "CommentCount": "4", "Body": "<p>When answering <a href=\"https://stackoverflow.com/q/15867399/420683\">this SO question</a>, I found in the Standard (already C++03, still in C++11) that you can only use addresses as non-type template arguments if they're of the form <code>&amp; id-expression</code> (plus some exceptions).</p>\n<p>But I couldn't answer <em>why</em> this is the case.</p>\n<blockquote>\n<p id=\"so_15885399_15885399_0\">14.3.2 Template non-type arguments [temp.arg.nontype]</p>\n<p id=\"so_15885399_15885399_1\">A template-argument for a non-type, non-template template-parameter shall be one of:</p>\n<p id=\"so_15885399_15885399_2\">[...]</p>\n<p id=\"so_15885399_15885399_3\">\u2014 a constant expression (5.19) that designates the address of an object with static storage &gt; duration and external or internal linkage <strong>or a function with external or internal linkage</strong>, including function templates and function template-ids but excluding non-static class members, <strong>expressed (ignoring parentheses) as &amp; id-expression</strong>, except that the &amp; may be omitted if the name refers to a function or array and shall be omitted if the corresponding template-parameter is a reference; [...]</p>\n</blockquote>\n<p>(n3485, emphasis mine)</p>\n<p>Example:</p>\n<pre><code>using TFoobar = int (*)();\ntemplate &lt; TFoobar tp &gt; struct foo_struct{};\n\nint foobar() { return 42; }\nconstexpr TFoobar pFoobar = &amp;foobar;\n\nfoo_struct &lt; &amp;foobar &gt; o0; // fine\nfoo_struct &lt; pFoobar &gt; o1; // ill-formed\n</code></pre>\n<p>I guess it has something to do with the translation phases, namely the compiler doesn't know much about addresses. Yet, why isn't it allowed? Shouldn't it be possible for the compiler to use something similar to macro substitution to replace <code>pFoobar</code> with <code>&amp;foobar</code>?</p>\n", "Tags": "<c++><templates>", "LastEditDate": "2017-05-23T12:17:46.607", "LastActivityDate": "2013-04-11T11:18:32.290", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "420683"}, "bq_ids": {"n4140": {"so_15885399_15885399_3": {"length": 40, "quality": 0.975609756097561, "section_id": 87}, "so_15885399_15885399_1": {"length": 5, "quality": 1.0, "section_id": 87}}, "n3337": {"so_15885399_15885399_3": {"length": 40, "quality": 0.975609756097561, "section_id": 82}, "so_15885399_15885399_1": {"length": 5, "quality": 1.0, "section_id": 82}}}});