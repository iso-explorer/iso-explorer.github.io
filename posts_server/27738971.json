post_cb({"27738971": {"CommentCount": "0", "ViewCount": "153", "PostTypeId": "1", "LastEditorUserId": "3953764", "CreationDate": "2015-01-02T07:37:32.657", "LastActivityDate": "2015-01-02T08:04:00.813", "Title": "Why does the `static_assert` always get invoked?", "AcceptedAnswerId": "27739161", "LastEditDate": "2015-01-02T08:04:00.813", "Id": "27738971", "Score": "0", "Body": "<p>If <code>USE_STATIC_ASSERT</code> is <code>0</code>, this works as expected (getting indexed type from the list).  If 1 the <code>static_assert()</code> is always tripped.  I would have thought that the <code>static_assert()</code> would only happen if all the <code>typename</code>s were exhausted.  Why is this not so?</p>\n<pre><code>#define USE_STATIC_ASSERT 1\ntemplate &lt;unsigned int I, typename ...Ts&gt;\nstruct items;\n\ntemplate &lt;typename T, typename ...Ts&gt;\nstruct items&lt;0, T, Ts...&gt;\n{\n    typedef T type;\n};\n\ntemplate &lt;unsigned int I, typename T, typename ...Ts&gt;\nstruct items&lt;I, T, Ts...&gt; : items&lt;I-1, Ts...&gt;\n{\n};\n\n#if USE_STATIC_ASSERT\ntemplate &lt;unsigned int I&gt;\nstruct items&lt;I&gt;\n{\n    static_assert(false, \"Ran out of Ts.\");\n};\n#endif\n\n\nint main()\n{\n    cout &lt;&lt; is_same&lt;float, items&lt;1, int, float, double&gt;::type&gt;::value &lt;&lt; endl;\n}\n</code></pre>\n", "Tags": "<c++><c++11><static-assert>", "OwnerUserId": "1366368", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_27738971_27739161_0": {"section_id": 175, "quality": 1.0, "length": 27}}, "n3337": {"so_27738971_27739161_0": {"section_id": 169, "quality": 1.0, "length": 27}}, "n4659": {"so_27738971_27739161_0": {"section_id": 180, "quality": 0.6666666666666666, "length": 18}}}, "27739161": {"ParentId": "27738971", "CommentCount": "0", "Body": "<p>Even if the partial specialization of <code>items</code> that contains the <code>static_assert</code> is not instantiated, the compiler is allowed to reject this code according to \u00a714.6 [temp.res]/p8:</p>\n<blockquote>\n<p id=\"so_27738971_27739161_0\">Knowing which names are type names allows the syntax of every template to be checked. No diagnostic\n  shall be issued for a template for which a valid specialization can be generated. <strong>If no valid specialization can be generated for a template, and that template is not instantiated, the template is ill-formed, no diagnostic required.</strong></p>\n</blockquote>\n<p>To work around that, you can make the expression in <code>static_assert</code> dependent on other class template:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate &lt;unsigned int I&gt;\nstruct AlwaysFalse : std::false_type {};\n\ntemplate &lt;unsigned int I&gt;\nstruct items&lt;I&gt;\n{\n    static_assert(AlwaysFalse&lt;I&gt;{}, \"Ran out of Ts.\");\n    //            ~~~~~~~~~~~~~~~^\n};\n</code></pre>\n", "OwnerUserId": "3953764", "PostTypeId": "2", "Id": "27739161", "Score": "5", "CreationDate": "2015-01-02T08:01:40.537", "LastActivityDate": "2015-01-02T08:01:40.537"}});