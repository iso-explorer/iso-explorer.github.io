post_cb({"26238279": {"ViewCount": "150", "Body": "<p>What is the unary-&amp; doing here? </p>\n<pre><code>int * a = 1990; \nint result = &amp;5[a]; \n</code></pre>\n<p>If you were to print <code>result</code> you would get the value 2010.</p>\n<p>You have to compile it with <code>-fpermissive</code> or it will stop due to errors.</p>\n", "AcceptedAnswerId": "26238782", "Title": "Semantics of unary & on numeric literal", "CreationDate": "2014-10-07T14:22:46.200", "Id": "26238279", "CommentCount": "21", "PostTypeId": "1", "LastActivityDate": "2015-02-04T21:03:40.960", "Score": "3", "OwnerUserId": "1240825", "Tags": "<c++><c><pointers>", "AnswerCount": "4"}, "26238588": {"Id": "26238588", "PostTypeId": "2", "Body": "<p>\"...unary <code>&amp;</code> on numeric literal\"? </p>\n<p>Postfix operators in C always have higher priority than prefix ones. In case of <code>&amp;5[a]</code>, the <code>[]</code> has higher priority than the <code>&amp;</code>. Which means that in <code>&amp;5[a]</code> the unary <code>&amp;</code> is not applied to \"numeric literal\" as you seem to incorrectly believe. It is applied to the entire <code>5[a]</code> subexpression. I.e. <code>&amp;5[a]</code> is equivalent to <code>&amp;(5[a])</code>.</p>\n<p>As for what <code>5[a]</code> means - this is a beaten-to-death <a href=\"http://c-faq.com/aryptr/joke.html\" rel=\"nofollow\">FAQ</a>. Look it up.</p>\n<p>And no, you don't have \"to compile it with <code>-fpermissive</code>\" (my compiler tells me it doesn't even know what <code>-fpermissive</code> is). You have to figure out that this</p>\n<pre><code>int * a = 1990; \n</code></pre>\n<p>is not legal code in either C or C++. If anything, it requires an explicit cast</p>\n<pre><code>int * a = (int *) 1990; \n</code></pre>\n<p>not some obscure switch of some specific compiler you happened to be using at the moment. The same applies to another illegal initialization in <code>int result = &amp;5[a]</code>.</p>\n<p>Finally, even if we overlook the illegal code and the undefined behavior triggered by that <code>5[a]</code>, the behavior of this code will still be highly implementation-dependent. I.e. the answer is no, in general case you will not get <code>2010</code> in <code>result</code>.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2014-10-07T15:35:29.197", "Score": "3", "CreationDate": "2014-10-07T14:36:57.067", "ParentId": "26238279", "CommentCount": "0", "OwnerUserId": "187690", "LastEditDate": "2014-10-07T15:35:29.197"}, "26238782": {"Id": "26238782", "PostTypeId": "2", "Body": "<p>You cannot apply the unary <code>&amp;</code> operator to an integer literal, because a literal is not an <em>lvalue</em>.</p>\n<p>Due to operator precedence, your code doesn't do that. Since the indexing operator <code>[]</code> binds more tightly than unary <code>&amp;</code>, <code>&amp;5[a]</code> is equivalent to <code>&amp;(5[a])</code>.</p>\n<p>Here's a program similar to yours, except that it's valid code, not requiring <code>-fpermissive</code> to compile:</p>\n<pre><code>#include &lt;stdio.h&gt;\nint main(void) {\n    int arr[6];\n    int *ptr1 = arr;\n    int *ptr2 = &amp;5[ptr1];\n    printf(\"%p %p\\n\", ptr1, ptr2);\n}\n</code></pre>\n<p>As explained in <a href=\"https://stackoverflow.com/q/381542/827263\">this question</a> and <a href=\"https://stackoverflow.com/a/18393343/827263\">my answer</a>, the indexing operator is commutative (because it's defined in terms of addition, and addition is commutative), so <code>5[a]</code> is equivalent to <code>a[5]</code>. So the expression <code>&amp;5[ptr1]</code> computes the address of element 5 of <code>arr</code>.</p>\n<p>In your program:</p>\n<pre><code>int * a = 1990;\nint result = &amp;5[a];\n</code></pre>\n<p>the initialization of <code>a</code> is invalid because <code>a</code> is of type <code>int*</code> and <code>1990</code> is of type <code>int</code>, and there is no implicit conversion from <code>int</code> to <code>int*</code>. Likewise, the initialization of <code>result</code> is invalid because <code>&amp;5[a]</code> is of type <code>int*</code>. Apparently <code>-fpermissive</code> causes the compiler to violate the rules of the language and permit these invalid implicit conversions.</p>\n<p>At least in the version of gcc I'm using, the <code>-fpermissive</code> option is valid only for C++ and Objective-C, not for C. In C, gcc permits such implicit conversions (with a warning) anyway. I strongly recommend <em>not</em> using this option. (Your question is tagged both C and C++. Keep in mind that C and C++ are two distinct, though closely related, languages. They happen to behave similarly in this case, but it's usually best to pick one language or the other.)</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-02-04T21:03:40.960", "Score": "1", "CreationDate": "2014-10-07T14:47:28.810", "ParentId": "26238279", "CommentCount": "0", "OwnerUserId": "827263", "LastEditDate": "2017-05-23T11:57:07.543"}, "26238322": {"Id": "26238322", "PostTypeId": "2", "Body": "<p>In C, x [y] and y [x] are identical. So &amp;5[a] is the same as &amp;a[5]. </p>\n", "LastActivityDate": "2014-10-07T14:24:35.093", "CommentCount": "5", "CreationDate": "2014-10-07T14:24:35.093", "ParentId": "26238279", "Score": "10", "OwnerUserId": "3255455"}, "bq_ids": {"n4140": {"so_26238279_26238334_0": {"length": 21, "quality": 1.0, "section_id": 6142}}, "n3337": {"so_26238279_26238334_0": {"length": 21, "quality": 1.0, "section_id": 5906}}, "n4659": {"so_26238279_26238334_0": {"length": 11, "quality": 0.5238095238095238, "section_id": 7638}}}, "26238334": {"Id": "26238334", "PostTypeId": "2", "Body": "<p><code>&amp;5[a]</code> is the same as <code>&amp;a[5]</code> and the same as <code>a + 5</code>. In your case it's undefined behavior because <code>a</code> points to nowhere.</p>\n<p>C11 standard chapter <code>6.5.6 Additive operators/8</code> (the same in C++):</p>\n<blockquote>\n<p id=\"so_26238279_26238334_0\">If both the pointer\n  operand and the result point to elements of the same array object, or one past the last\n  element of the array object, the evaluation shall not produce an overflow; otherwise, the\n  behavior is undefined.</p>\n</blockquote>\n", "LastEditorUserId": "3959454", "LastActivityDate": "2014-10-07T14:36:40.767", "Score": "5", "CreationDate": "2014-10-07T14:25:12.887", "ParentId": "26238279", "CommentCount": "10", "OwnerUserId": "3959454", "LastEditDate": "2014-10-07T14:36:40.767"}});