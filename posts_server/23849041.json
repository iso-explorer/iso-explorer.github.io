post_cb({"bq_ids": {"n4140": {"so_23849041_23849282_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 4279}}, "n3337": {"so_23849041_23849282_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 4120}}, "n4659": {"so_23849041_23849282_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 5535}}}, "23849282": {"Id": "23849282", "PostTypeId": "2", "Body": "<p>What you have is plain undefined behavior. If I replace the contents of <code>main</code> with the following</p>\n<pre><code>int main()\n{\n    unique_ptr&lt;X&gt; ptr;\n    ptr-&gt;Print();\n    cout &lt;&lt; (static_cast&lt;bool&gt;(ptr) ? \"active\\n\" : \"inactive\\n\");\n}\n</code></pre>\n<p>Both gcc and clang still <a href=\"http://coliru.stacked-crooked.com/a/9bb5e05f1f800145\" rel=\"nofollow\">print</a></p>\n<pre><code>X\ninactive\n</code></pre>\n<p>You're calling a member function on a <code>nullptr</code>, and I'm guessing it just happens to work because the member function doesn't actually make use of the <code>this</code> pointer. Change your class definition to:</p>\n<pre><code>class X\n{\n    int y = 0;\npublic:\n    X(){}\n    ~X() { cout &lt;&lt; \"Destructor X\" &lt;&lt; endl; }\n    void Print() { cout &lt;&lt; \"y = \" &lt;&lt; y &lt;&lt; endl; }\n};\n</code></pre>\n<p>Now your original code should result in a segmentation fault because it'll attempt to dereference <code>nullptr</code>.</p>\n<hr>\n<p>As for your expectation that <code>unique_ptr</code> will be invalidated after you move from it, you're absolutely correct. This is guaranteed by the standard.</p>\n<p><em>\u00a720.8.1/4  [unique.ptr]</em></p>\n<blockquote>\n<p id=\"so_23849041_23849282_0\">Additionally, <code>u</code> can, upon request, transfer ownership to another unique pointer <code>u2</code>. Upon completion of such a transfer, the following postconditions hold:<br/>\n  \u2014 <code>u2.p</code> is equal to the pre-transfer <code>u.p</code>,<br/>\n  \u2014 <code>u.p</code> is equal to <code>nullptr</code>, and<br/>\n  ...</p>\n</blockquote>\n<p>Above <code>u</code> &amp; <code>u2</code> are <code>unique_ptr</code> objects, and <code>p</code> is the pointer to the managed object.</p>\n</hr>", "LastEditorUserId": "241631", "LastActivityDate": "2014-05-24T20:34:14.603", "Score": "5", "CreationDate": "2014-05-24T20:21:43.963", "ParentId": "23849041", "CommentCount": "0", "OwnerUserId": "241631", "LastEditDate": "2014-05-24T20:34:14.603"}, "23849041": {"ViewCount": "788", "Body": "<p>I was experimenting with using <strong>unique_ptr</strong> and wrote some simple code to check how it works with move semantics. </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nclass X\n{\npublic:\n    X(){}\n    ~X() { cout &lt;&lt; \"Destructor X\" &lt;&lt; endl; }\n    void Print() { cout &lt;&lt; \"X\" &lt;&lt; endl; }\n};\n\nint main()\n{\n    unique_ptr&lt;X&gt; ptr(new X());\n    ptr-&gt;Print();\n\n    vector&lt;unique_ptr&lt;X&gt;&gt; v;\n    v.push_back(move(ptr));\n    ptr-&gt;Print();\n    v.front()-&gt;Print();\n\n    return 0;\n}\n</code></pre>\n<p>The output is as follows: </p>\n<pre><code>X\nX\nX\nDestructor X\n</code></pre>\n<p>My expectation was that the original unique_ptr <strong>ptr</strong> would be invalidated after the push_back. But the Print() method is called just fine. What would be the explanation for this behavior? </p>\n", "AcceptedAnswerId": "23849245", "Title": "How do move semantics work with unique_ptr?", "CreationDate": "2014-05-24T19:54:34.870", "Id": "23849041", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-05-24T20:24:11.877", "LastEditorUserId": "241631", "LastActivityDate": "2014-05-24T20:34:14.603", "Score": "3", "OwnerUserId": "57619", "Tags": "<c++><c++11><move-semantics><unique-ptr>", "AnswerCount": "2"}, "23849245": {"Id": "23849245", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_23849041_23849245_0\">My expectation was that the original unique_ptr ptr would be invalidated after the push_back.</p>\n</blockquote>\n<p>It's set to a null pointer. You can check that by comparing it to <code>nullptr</code>.</p>\n<blockquote>\n<p id=\"so_23849041_23849245_1\">But the <code>Print()</code> method is called just fine. What would be the explanation for this behavior?</p>\n</blockquote>\n<p>You're calling a member function on a null pointer, which is undefined behaviour. That member function doesn't actually access any data in the class, so it doesn't crash, but it's still undefined behaviour.</p>\n<p>You get similar behaviour for this program, it has nothing to do with <code>unique_ptr</code>:</p>\n<pre><code>int main()\n{\n  X x;\n  X* ptr = &amp;x;\n  ptr-&gt;Print();\n  ptr = nullptr;\n  ptr-&gt;Print();\n}\n</code></pre>\n<p>It appears to work fine because <code>X::Print()</code> doesn't actually read anything from the <code>this</code> pointer. If you change the definition of <code>X::Print()</code> to access some member data in the class you'll probably get a crash due to dereferencing a null pointer.</p>\n<p>See <a href=\"https://stackoverflow.com/questions/2474018/when-does-invoking-a-member-function-on-a-null-instance-result-in-undefined-beha\">When does invoking a member function on a null instance result in undefined behavior?</a> for more information.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-05-24T20:22:44.737", "Score": "12", "CreationDate": "2014-05-24T20:16:55.590", "ParentId": "23849041", "CommentCount": "0", "OwnerUserId": "981959", "LastEditDate": "2017-05-23T11:51:39.170"}});