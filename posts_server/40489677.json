post_cb({"40489788": {"ParentId": "40489677", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2016-11-08T14:44:55.237", "Score": "4", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:13:37.900", "Id": "40489788", "OwnerUserId": "598696", "Body": "<p>You need to explicitly specify what function you want to bring into the \"overload set\" <em>(<a href=\"http://melpon.org/wandbox/permlink/UVEZ0qRkEfjOMrEK\" rel=\"nofollow noreferrer\">see wandbox example</a>)</em>:</p>\n<pre><code>void run() {\n    using namespace std;\n    using std::to_string;\n    cout &lt;&lt; string(\"Type: \") + to_string(Type::Type1) &lt;&lt; endl;\n    cout &lt;&lt; string(\"int: \" )  + to_string(42) &lt;&lt; endl;  \n}\n</code></pre>\n<p>The reason is that ADL ignores using directives. Refer to <strong>3.4.2 [basic.lookup.argdep]</strong>:</p>\n<blockquote>\n<p id=\"so_40489677_40489788_0\">When considering an associated namespace, the lookup is the same as the lookup performed when the associated namespace is used as a qualifier (3.4.3.2) except that:\n  \u2014 Any using-directives in the associated namespace are ignored.</p>\n</blockquote>\n<p>More detailed information available <a href=\"https://stackoverflow.com/questions/27544893/why-doesnt-a-using-directive-affect-adl\">in this question</a>.</p>\n", "LastActivityDate": "2016-11-08T14:52:52.367"}, "40489677": {"CommentCount": "1", "ViewCount": "72", "CreationDate": "2016-11-08T14:38:57.627", "LastActivityDate": "2016-11-08T15:45:24.007", "Title": "Compiler is trying to initialize enum class from int when it shouln't", "AcceptedAnswerId": "40490475", "PostTypeId": "1", "Id": "40489677", "Score": "3", "Body": "<p>I have an enum class of types and want a \"to_string\" function for outputting the type name so I wrote that inside my own namespace. Problem is, other functions in that namespace trying to call to_string on, e.g., an int (really just an int, not intended to be part of the enum) are finding the custom to_string and giving errors about invalid initialization of the enum.</p>\n<p>I know I could explicitly call std::to_string instead of to_string but I assume there's a better way. What am I doing wrong?</p>\n<p><a href=\"http://ideone.com/IUSQiK\" rel=\"nofollow noreferrer\">Here</a> is example code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nnamespace other {\n    enum class Type {\n        Type1,\n        Type2\n    };\n\n    std::string to_string(const Type&amp; type) {\n        switch(type) {\n            case Type::Type1:\n                return \"Type1\";\n                break;\n            case Type::Type2:\n                return \"Type2\";\n                break;\n            default:\n            {}\n        }\n\n        return \"Unknown\";\n    }\n\n    void run() {\n        using namespace std;\n        cout &lt;&lt; string(\"Type: \") + to_string(Type::Type1) &lt;&lt; endl;\n        cout &lt;&lt; string(\"int: \" )  + to_string(42) &lt;&lt; endl;  // this one generates compile-time errors\n    }\n}\n\nint main() {\n    other::run();\n\n    using namespace std;\n    cout &lt;&lt; string(\"int: \" )  + to_string(42) &lt;&lt; endl;  // This one is ok\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><enums>", "OwnerUserId": "1029418", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_40489677_40490475_0": {"section_id": 5510, "quality": 0.8947368421052632, "length": 34}, "so_40489677_40489788_0": {"section_id": 7106, "quality": 0.8947368421052632, "length": 17}, "so_40489677_40490475_1": {"section_id": 7081, "quality": 0.9545454545454546, "length": 21}}, "n3337": {"so_40489677_40490475_0": {"section_id": 5296, "quality": 0.8947368421052632, "length": 34}, "so_40489677_40489788_0": {"section_id": 6850, "quality": 0.8947368421052632, "length": 17}, "so_40489677_40490475_1": {"section_id": 6825, "quality": 0.9545454545454546, "length": 21}}, "n4659": {"so_40489677_40490475_0": {"section_id": 6945, "quality": 0.8947368421052632, "length": 34}, "so_40489677_40489788_0": {"section_id": 8607, "quality": 0.8947368421052632, "length": 17}, "so_40489677_40490475_1": {"section_id": 8582, "quality": 0.9545454545454546, "length": 21}}}, "40490475": {"ParentId": "40489677", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2016-11-08T15:17:20.307", "Score": "3", "LastEditorUserId": "951890", "LastEditDate": "2016-11-08T15:45:24.007", "Id": "40490475", "OwnerUserId": "951890", "Body": "<p>This is a tricky situation which involves some subtle rules of namespaces.  Let's consider a simpler example:</p>\n<pre><code>namespace b {\n  void f(int) { }\n}\n\nnamespace a {\n  using namespace b;\n\n  void f(char) { }\n\n  void g()\n  {\n    f(5); // calls f(char)\n  }\n}\n</code></pre>\n<p>The issue here is that even though we have <code>using namespace b</code>, the declarations inside b are treated as if they were declared in the common namespace (global) for the purposes of lookup:</p>\n<p>(C++14 7.3.4/2)</p>\n<blockquote>\n<p id=\"so_40489677_40490475_0\">A using-directive specifies that the names in the nominated namespace can be used in the scope in which the\n  using-directive appears after the using-directive. During unqualified name lookup (3.4.1), the names appear\n  as if they were declared in the nearest enclosing namespace <strong>which contains both the using-directive and the\n  nominated namespace</strong>. [ Note: In this context, \u201ccontains\u201d means \u201ccontains directly or indirectly\u201d. \u2014 end\n  note ]</p>\n</blockquote>\n<p>Because of this, for the purposes of lookup, the names in namespace b are treated as if they were in the global namespace.  That means <code>f(char)</code> inside namespace a will hide <code>f(int)</code> inside namespace b:</p>\n<p>(C++14 3.3.10/4)</p>\n<blockquote>\n<p id=\"so_40489677_40490475_1\">During the lookup of a name qualified by a namespace name, declarations that would otherwise be made\n  visible by a using-directive <strong>can be hidden by declarations with the same name</strong> in the namespace containing\n  the using-directive; see (3.4.3.2).</p>\n</blockquote>\n<p>In your example, a call to <code>to_string(42)</code> in <code>other::run()</code> will find <code>other::to_string</code>, because <code>std::to_string(int)</code> is hidden.</p>\n", "LastActivityDate": "2016-11-08T15:45:24.007"}});