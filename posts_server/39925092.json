post_cb({"bq_ids": {"n4140": {"so_39925092_39925402_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 5816}, "so_39925092_39925402_0": {"length": 10, "quality": 0.625, "section_id": 2725}}, "n3337": {"so_39925092_39925402_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 5587}, "so_39925092_39925402_0": {"length": 10, "quality": 0.625, "section_id": 2686}}, "n4659": {"so_39925092_39925402_1": {"length": 20, "quality": 0.9523809523809523, "section_id": 7277}, "so_39925092_39925402_0": {"length": 10, "quality": 0.625, "section_id": 3464}}}, "39925505": {"Id": "39925505", "PostTypeId": "2", "Body": "<p>If an execution thread is using the <code>ivector</code> class member, and another thread destroys the object with this class member, the continued use of the <code>ivector</code> class member results in undefined behavior.</p>\n<blockquote>\n<p id=\"so_39925092_39925505_0\">Even if the object is destroyed after the worker thread is finished,\n  destructor for iVector would be invoked from the main thread. Would\n  this lead to undefined behavior?</p>\n</blockquote>\n<p>No. As you've described, this situation is not undefined behavior. The C++ standard does not require an object to be destroyed by the same execution thread that created the object. It's fine for one execution thread to grow, resize the vector, then go away or stop using the vector, and then a different execution thread destroy the entire object.</p>\n", "LastActivityDate": "2016-10-07T20:42:53.657", "CommentCount": "2", "CreationDate": "2016-10-07T20:42:53.657", "ParentId": "39925092", "Score": "2", "OwnerUserId": "3943312"}, "39925092": {"ViewCount": "247", "Body": "<p>I was wondering what would happen in such a class:</p>\n<pre><code>class MyClass\n{\nprivate:\n    std::vector&lt;int&gt; iVector;\n    void Worker()\n    {\n        //Lots of stuff done with iVector\n        //adding, removing elements, etc.\n    }\n}\n</code></pre>\n<p>Let's say I create a thread (invoked by one of the class member functions) that uses iVector and modifies it. Besides this worker, none of the other member functions of the class reads or modifies this std::vector.</p>\n<p>Everything seems fine as worker thread is the only one using iVector.</p>\n<p>But what would happen when one instance of the object is destroyed? Even if the object is destroyed after the worker thread is finished, destructor for iVector would be invoked from the main thread. Would this lead to undefined behavior?</p>\n<p>Thanks!</p>\n", "AcceptedAnswerId": "39925402", "Title": "Destructor in a multithreaded environment?", "CreationDate": "2016-10-07T20:12:32.870", "Id": "39925092", "CommentCount": "8", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-10-07T21:07:18.520", "Score": "6", "OwnerUserId": "4060200", "Tags": "<c++><multithreading>", "AnswerCount": "2"}, "39925402": {"Id": "39925402", "PostTypeId": "2", "Body": "<p>Firstly I would suggest running a <code>std::join</code> (or your library equivalent) on the thread in the destructor. This will ensure the thread is properly finished and synchronized before the vector destructor runs. This is important as the vector's lifetime must exceed the thread using it.</p>\n<p>The C++11 standard and presumably later ones state in 30.3.1.5:</p>\n<blockquote>\n<p id=\"so_39925092_39925402_0\">5: Synchronization: The completion of the thread represented by *this\n  synchronizes with (1.10) the corresponding successful join() return. [\n  Note: Operations on *this are not synchronized. \u2014 end note ]</p>\n</blockquote>\n<p>Now we have to examine 1.10 for more detail, first this section states:</p>\n<blockquote>\n<p id=\"so_39925092_39925402_1\">3: The value of an object visible to a thread T at a particular point\n  is the initial value of the object, a value assigned to the object by\n  T, or a value assigned to the object by another thread, according to\n  the rules below.</p>\n</blockquote>\n<p>Honestly, this is difficult to parse, it does not specify exactly what kind of synchronization join offers and seems to imply it synchronizes only the thread itself and not data it has accessed. Therefore I would go the safe route and run <code>atomic_thread_fence(memory_order_acquire)</code> after join in the main thread, and <code>atomic_thread_fence(memory_order_release)</code> in the child thread just before it finishes which should guarantee full happens before semantics and no UB.</p>\n", "LastEditorUserId": "3323096", "LastActivityDate": "2016-10-07T21:07:18.520", "Score": "3", "CreationDate": "2016-10-07T20:35:05.397", "ParentId": "39925092", "CommentCount": "5", "OwnerUserId": "3323096", "LastEditDate": "2016-10-07T21:07:18.520"}});