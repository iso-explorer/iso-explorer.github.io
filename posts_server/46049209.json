post_cb({"46049461": {"ParentId": "46049209", "CommentCount": "1", "CreationDate": "2017-09-05T07:39:47.197", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "46049461", "Score": "2", "Body": "<p><code>void</code> is a type like any other (an incomplete type, to be precise). This means it can be used as a template argument for type template parameters normally. Taking your class template, these are all perfectly valid, and <em>distinct,</em> instantiations:</p>\n<pre><code>some_class&lt;void&gt;\nsome_class&lt;void, void&gt;\nsome_class&lt;void, void, void&gt;\nsome_class&lt;void, char, void&gt;\n</code></pre>\n<p>In the first case, the parameter pack <code>Args</code> has one element: <code>void</code>. In the second case, it has two elements: <code>void</code> and <code>void</code>. And so on.</p>\n<p>This is quite different from the case <code>some_class&lt;&gt;</code>, in which case the parameter pack has <em>zero</em> elements. You can easily demonstrate this using <code>sizeof...</code>:</p>\n<pre><code>template &lt;class... Pack&gt;\nstruct Sizer\n{\n  static constexpr size_t size = sizeof...(Pack);\n};\n\nint main()\n{\n  std::cout &lt;&lt; Sizer&lt;&gt;::size &lt;&lt; ' ' &lt;&lt; Sizer&lt;void&gt;::size &lt;&lt; ' ' &lt;&lt; Sizer&lt;void, void&gt;::size &lt;&lt; std::endl;\n}\n</code></pre>\n<p>This will output:</p>\n<blockquote>\n<p id=\"so_46049209_46049461_0\">0 1 2</p>\n</blockquote>\n<p><a href=\"http://coliru.stacked-crooked.com/a/704c7d5884d2e90a\" rel=\"nofollow noreferrer\">[Live example]</a></p>\n<p>I can't really think of a relevant part of the standard to quote. Perhaps this (C++11 [temp.variadic] 14.5.3/1):</p>\n<blockquote>\n<p id=\"so_46049209_46049461_1\">A <em>template parameter pack</em> is a template parameter that accepts zero or more template arguments. [ <em>Example:</em></p>\n<pre><code>template&lt;class ... Types&gt; struct Tuple { };\nTuple&lt;&gt; t0; // Types contains no arguments\nTuple&lt;int&gt; t1; // Types contains one argument: int\nTuple&lt;int, float&gt; t2; // Types contains two arguments: int and float\nTuple&lt;0&gt; error; // error: 0 is not a type\n</code></pre>\n<p id=\"so_46049209_46049461_2\"><em>\u2014end example</em> ]</p>\n</blockquote>\n", "LastActivityDate": "2017-09-05T07:39:47.197"}, "bq_ids": {"n4140": {"so_46049209_46049461_1": {"section_id": 118, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_46049209_46049461_1": {"section_id": 113, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_46049209_46049461_1": {"section_id": 122, "quality": 0.8181818181818182, "length": 9}}}, "46049209": {"CommentCount": "0", "AcceptedAnswerId": "46049461", "CreationDate": "2017-09-05T07:24:59.247", "LastActivityDate": "2017-09-05T07:39:47.197", "PostTypeId": "1", "ViewCount": "26", "FavoriteCount": "1", "Title": "C++11: Variadic template deduction logic", "Id": "46049209", "Score": "2", "Body": "<p>I have the following construct:</p>\n<pre><code>template &lt;class... Args&gt;\nclass some_class\n{\npublic:\n    some_class() = default;\n    some_class(Args...) = delete;\n    ~some_class() = default;\n};\n\ntemplate&lt;&gt;\nclass some_class&lt;void&gt;\n{\npublic:\n    some_class() = default;\n    ~some_class() = default;\n};\n</code></pre>\n<p>The reason for this is that I just want to allow the users to create objects using the default constructor, so for example:</p>\n<pre><code>some_class&lt;int,float&gt; b;\n</code></pre>\n<p>should work but </p>\n<pre><code>some_class&lt;int,float&gt; c(1,3.4);\n</code></pre>\n<p>should give me a compilation error.</p>\n<p>At some point in time I also needed to create templates based on <code>void</code> hence, the specialization for <code>void</code>:</p>\n<pre><code>some_class&lt;void&gt; a;\n</code></pre>\n<p>But by mistake I have typed:</p>\n<pre><code>some_class&lt;&gt; d;\n</code></pre>\n<p>And suddenly my code stopped compiling and it gave me the error:</p>\n<pre><code>some_class&lt;Args&gt;::some_class(Args ...) [with Args = {}]\u2019 cannot be \noverloaded\n some_class(Args...) = delete;\n</code></pre>\n<p>So here comes the question: I feel that I am wrong that I assume that <code>some_class&lt;&gt;</code> should be deduced to the <code>void</code> specialization... I just don't know why. Can please someone explain why <code>some_class&lt;&gt;</code> (ie: empty argument list) is different from <code>some_class&lt;void&gt;</code>? (A few lines from the standard will do :) )</p>\n<p><a href=\"https://ideone.com/o6u0D6\" rel=\"nofollow noreferrer\">https://ideone.com/o6u0D6</a></p>\n", "Tags": "<c++11><variadic-templates>", "OwnerUserId": "186193", "AnswerCount": "1"}});