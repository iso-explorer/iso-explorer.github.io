post_cb({"47194678": {"ParentId": "41678530", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2017-11-09T05:44:22.453", "Score": "0", "LastEditorUserId": "963864", "LastEditDate": "2017-11-09T05:53:52.817", "Id": "47194678", "OwnerUserId": "963864", "Body": "<p>Disregarding the text of the standard, which is absolute non sense... you have to understand the meaning of it, which is cristal clear: you can pretend that a reconstructed object is the same object as the object over which it is reconstructed, if the langage semantics would have allowed such change:</p>\n<pre><code>struct T {\n    int i;\n    T (int i) :i(i) {}\n    void set_i(int new_i) {\n        new (this) T(new_i);\n    }\n};\n</code></pre>\n<p>Here <code>set_i</code> use a very silly way to reset member <code>i</code>, but note that the exact same behavior could be done by other means (assignment).</p>\n<p>Considering </p>\n<pre><code>class Fixed_at_construction {\n    int i;\npublic:\n    Fixed_at_construction (int i) :i(i) {}\n    int get_i() {\n        return i;\n    }\n};\n</code></pre>\n<p>Now the value cannot be changed after construction, but only by virtue of access control: no public member allows such change. In this case, it's an invariant for the class user but not so much from a language semantics point of view (that's arguable...) and as a user you can still use placement new.</p>\n<p>But when a member is const qualified (and not volatile qualified) or is a reference, C++ semantics imply that it cannot be changed. The value (or the referent of the reference) is the fixed at construction, and you cannot use other language feature to destroy that property. It just means that you cannot do:</p>\n<pre><code>class Constant {\n    const int i;\npublic:\n    Constant (int i) :i(i) {}\n    void set_i(int new_i) { // destroys object\n        new (this) T(new_i);\n    }\n};\n</code></pre>\n<p>The placement new here itself it legit, but just as much as <code>delete this</code>. You cannot use the object at all later: the old object is destroyed, and the name of the old object still refers to the old object, and <em>there is no special permit to use to refer to the new one</em>. After calling <code>set_i</code>, you can only use the name of the object to refer to the storage: take its address, use it as <code>void*</code>.</p>\n<p>But in case of <code>vector</code>, <strong>object stored are not named</strong>. The class does not need to store a pointer to the objects, it only needs a pointer to the storage. <code>v[0]</code> happens to be a lvalue referring to the first object in the vector, it is not a name.</p>\n", "LastActivityDate": "2017-11-09T05:53:52.817"}, "41678886": {"ParentId": "41678530", "PostTypeId": "2", "CommentCount": "20", "CreationDate": "2017-01-16T14:41:48.260", "Score": "7", "LastEditorUserId": "734069", "LastEditDate": "2017-01-16T15:53:21.323", "Id": "41678886", "OwnerUserId": "734069", "Body": "<blockquote>\n<p id=\"so_41678530_41678886_0\">=&gt; OK, array of unsigned char can provide storage for other object, If a new object occupies storage which was previously occupied by an other object, the new objects reuses the storage of the previous.</p>\n</blockquote>\n<p>Correct, but for the wrong reasons.</p>\n<p>The notation you cite is <em>non-normative text</em>. That's why it appears in the \"[note: ...]\" markup. Non-normative text has no weight when deciding what the standard actually says. So you cannot use that text to prove that constructing an object in an <code>unsigned char[]</code> constitutes storage reuse.</p>\n<p>So if indeed it does constitute storage reuse, that is only because \"reuse\" is defined by plain English, not because the standard has a rule explicitly defining this as one of the cases of \"storage reuse\".</p>\n<blockquote>\n<p id=\"so_41678530_41678886_1\">I can construct an object at the storage location of an other object but this operation is not a \"storage reuses\" (Otherwise why would it be written ...before the storage which the object occupied is resused...)</p>\n</blockquote>\n<p>No. [basic.life]/8 is trying to explain how you can use pointers/references/variable names to an object after that object's lifetime has ended. It explains the circumstances under which those pointers/references/variable names are still valid and can access the new object created in its storage.</p>\n<p>But let's dissect the wording:</p>\n<blockquote>\n<p id=\"so_41678530_41678886_2\">If, after the lifetime of an object has ended</p>\n</blockquote>\n<p>OK, so we have this situation:</p>\n<pre><code>auto t = new T;\nt-&gt;~T(); //Lifetime has ended.\n</code></pre>\n<blockquote>\n<p id=\"so_41678530_41678886_3\">and before the storage which the object occupied is reused or released</p>\n</blockquote>\n<p>And neither of the following has happened <em>yet</em>:</p>\n<pre><code>delete t; //Release storage. UB due to double destructor call anyway.\nnew(t) T; //Reuse the storage.\n</code></pre>\n<blockquote>\n<p id=\"so_41678530_41678886_4\">a new object is created at the storage location which the original object occupied</p>\n</blockquote>\n<p>Therefore, we do this:</p>\n<pre><code>new(t) T; //Reuse the storage.\n</code></pre>\n<p>Now, that <em>sounds</em> like a contradiction, but it isn't. The \"before storage gets reused\" part is intending to prevent this:</p>\n<pre><code>auto t = new T;  //Storage created, lifetime begun.\nt-&gt;~T(); //Lifetime has ended; storage not released.\nnew(t) T; //[basic.life]/8 applies, since storage hasn't been reused yet.\nnew(t) T; //[basic.life]/8 does not apply, since storage was just reused.\n</code></pre>\n<p>[basic.life]/8 is saying that the paragraph does not apply if you created a new object between the previous object's destruction and your attempt to create a new object. That is, [basic.life]/8 doesn't apply if you <em>double reuse</em> storage.</p>\n<p>But the act of creating the new object is still <em>reusing</em> the storage. Storage reuse is not a fancy C++ term; it's just plain English. It means exactly what it sounds like: storage was used for object A, now you reuse that same storage for object B.</p>\n<hr>\n<blockquote>\n<p id=\"so_41678530_41678886_5\">EDIT: Ok please do not focus on the \"storage reuses\" term and focus on the question \"\u00a73.8.8 does not applies if the initial object is constructed on a storage provided by an unsigned char array\"?</p>\n</blockquote>\n<p>But... it <em>does apply</em>.</p>\n<p><code>vector</code> stores a pointer to the first element. That object gets allocated and constructed. Then the destructor gets called, but the storage remains. Then the storage gets reused.</p>\n<p>That is the exact case that [basic.life]/8 is talking about. The new object being created is the same type as the old one. The new object overlays the storage for the old one exactly. The objects cannot be base subobjects of anything, by the nature of <code>vector</code>. <code>vector</code> doesn't let you stick <code>const</code>-qualified objects in itself.</p>\n<p>[basic.life]/8's protections very much do apply: the new object can be accessed via pointers/references to the old one. So unless you do a lot of copy/move constructor/assignment work to put types with <code>const</code> or reference members in <code>vector</code>, it will work.</p>\n<p>And even that last case can be satisfied by implementations <code>launder</code>ing their pointers. Oh, and <code>launder</code> is <em>new</em>, from C++17. C++14 has no provisions for what to do with types where [basic.life]/8 doesn't apply.</p>\n</hr>", "LastActivityDate": "2017-01-16T15:53:21.323"}, "41678530": {"CommentCount": "4", "AcceptedAnswerId": "41678886", "PostTypeId": "1", "LastEditorUserId": "5632316", "CreationDate": "2017-01-16T14:22:09.097", "LastActivityDate": "2017-11-09T05:53:52.817", "LastEditDate": "2017-01-16T17:13:19.717", "ViewCount": "408", "FavoriteCount": "4", "Title": "Object lifetime, in which situation is reused the storage?", "Id": "41678530", "Score": "9", "Body": "<p>In the C++ ISO standard N4618 (but it almost also applies to the C++11 version) one can read:</p>\n<p>at \u00a71.8 The C++ Object Model:</p>\n<blockquote>\n<p id=\"so_41678530_41678530_0\">If a complete object is created (5.3.4) in storage associated with another object <code>e</code> of type \u201carray of N unsigned char\u201d, that array provides storage\n  for the created object... [Note:If that portion of the array previously provided storage for another object, the lifetime of that object\n  ends because its storage was reused]</p>\n</blockquote>\n<p>=&gt; OK, array of unsigned char can provide storage for other object, If a new object occupies storage which was previously occupied by an other object, the new objects reuses the storage of the previous.</p>\n<p>at \u00a73.8.8 object lifetime</p>\n<blockquote>\n<p id=\"so_41678530_41678530_1\">If, after the lifetime of an object has ended and <strong>before the storage which the object occupied is reused</strong> or released, a <strong>new object is created at the storage location</strong> which the original object occupied,...</p>\n</blockquote>\n<p>=&gt; I can construct an object at the storage location of an other object but this operation is not a \"storage reuses\" (Otherwise why would it be written <em>...before the storage which the object occupied is resused...</em>)</p>\n<p>And as an example of \u00a73.8.8</p>\n<pre><code>struct C {\n int i;\n void f();\n const C&amp; operator=( const C&amp; );\n};\n\nconst C&amp; C::operator=( const C&amp; other) {\n  if ( this != &amp;other ) {\n    this-&gt;~C();          // lifetime of *this ends\n    new (this) C(other); // new object of type C created\n    f();                 // well-defined\n  }\n  return *this;\n}\n\nC c1;\nC c2;\nc1 = c2;  // well-defined\nc1.f();  // well-defined; c1 refers to a new object of type C\n</code></pre>\n<p>So in this example <code>new(this) C(other)</code> would not be a storage reuse because c1 has automatic storage duration.</p>\n<p>On the contrary in this example:</p>\n<pre><code>alignas(C) unsigned char a[sizeof(C)];\nauto pc1 = new (&amp;a) C{};\nC c2;\n*pc1 = c2;\n</code></pre>\n<p>the expression <code>new (this) C(other)</code> evaluated during the assignment <code>*pc1=c2</code> is a storage reuse since the object pointed to by <code>pc1</code> has storage provided by an unsigned char array.</p>\n<p>Are the following assertions (and the previouses) right:</p>\n<ul>\n<li>\u00a73.8.8 does not applies if the initial object is constructed on a storage provided by an unsigned char array;</li>\n<li>the term \"storage reused\" only applies for storage provided by unsigned char array.</li>\n</ul>\n<p>EDIT: Ok please do not focus on the \"storage reuses\" term and focus on the question \"\u00a73.8.8 does not applies if the initial object is constructed on a storage provided by an unsigned char array\"?</p>\n<p>Because if it is not the case, so all std::vector implementation I know are not correct. Indeed they save the allocated storage in a pointer of type <code>value_type</code> called <code>__begin_</code> for example.\nLet's say you make a push_back on this vector. The object will be created at the begining of the allocated storage:</p>\n<pre><code> new (__begin_) value_type(data);\n</code></pre>\n<p>Then you make a clear, which will call the destroy of the allocator which will call the destructor of the object:</p>\n<pre><code> __begin_-&gt;~value_type();\n</code></pre>\n<p>Then if you make a new push_back, the vector won't allocate new storage:</p>\n<pre><code>new (__begin_) value_type(data);\n</code></pre>\n<p>Thus according de \u00a73.8.8 if <code>value_type</code> has a ref data member or const data member, then a call to front which result in <code>*__begin_</code> will not point to the new pushed object.</p>\n<p>So I think that storage reuses has in $3.8.8 a special meaning otherwise, std library implementor are wrong? I have checked libstdc++ et libc++ (GCC and Clang).</p>\n<p>This what would happen in this example:</p>\n<pre><code> #include &lt;vector&gt;\n struct A{\n   const int i;\n };\n int main() {\n   std::vector&lt;A&gt; v{};\n   A a{};\n   v.push_back(A{});\n   v.clear();\n   v.push_back(A{2});\n   return 0;\n }\n</code></pre>\n", "Tags": "<c++><c++11><language-lawyer><c++1z>", "OwnerUserId": "5632316", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_41678530_41678886_4": {"section_id": 7195, "quality": 1.0, "length": 8}, "so_41678530_41678530_1": {"section_id": 7195, "quality": 1.0, "length": 18}, "so_41678530_41678886_3": {"section_id": 7193, "quality": 1.0, "length": 6}, "so_41678530_41678886_2": {"section_id": 7193, "quality": 1.0, "length": 4}}, "n3337": {"so_41678530_41678886_4": {"section_id": 6939, "quality": 1.0, "length": 8}, "so_41678530_41678530_1": {"section_id": 6939, "quality": 1.0, "length": 18}, "so_41678530_41678886_3": {"section_id": 6937, "quality": 1.0, "length": 6}, "so_41678530_41678886_2": {"section_id": 6937, "quality": 1.0, "length": 4}}, "n4659": {"so_41678530_41678886_4": {"section_id": 8704, "quality": 1.0, "length": 8}, "so_41678530_41678530_0": {"section_id": 7249, "quality": 0.9090909090909091, "length": 30}, "so_41678530_41678886_3": {"section_id": 8702, "quality": 1.0, "length": 6}, "so_41678530_41678886_2": {"section_id": 8702, "quality": 1.0, "length": 4}, "so_41678530_41678530_1": {"section_id": 8704, "quality": 1.0, "length": 18}}}});