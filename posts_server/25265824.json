post_cb({"bq_ids": {"n4140": {"so_25265824_25265824_1": {"length": 40, "quality": 0.8888888888888888, "section_id": 6044}, "so_25265824_25265824_0": {"length": 20, "quality": 0.8, "section_id": 6043}}, "n3337": {"so_25265824_25265824_0": {"length": 20, "quality": 0.8, "section_id": 5811}, "so_25265824_25265824_1": {"length": 40, "quality": 0.8888888888888888, "section_id": 5812}}, "n4659": {"so_25265824_25265824_0": {"length": 20, "quality": 0.8, "section_id": 7542}, "so_25265824_25265824_1": {"length": 40, "quality": 0.8888888888888888, "section_id": 7543}}}, "25265824": {"ViewCount": "223", "Body": "<p>I have the following function template:</p>\n<pre><code>template &lt;class MostDerived, class HeldAs&gt;\nHeldAs* duplicate(MostDerived *original, HeldAs *held)\n{\n  // error checking omitted for brevity\n  MostDerived *copy = new MostDerived(*original);\n  std::uintptr_t distance = reinterpret_cast&lt;std::uintptr_t&gt;(held) - reinterpret_cast&lt;std::uintptr_t&gt;(original);\n  HeldAs *copyHeld = reinterpret_cast&lt;HeldAs*&gt;(reinterpret_cast&lt;std::uintptr_t&gt;(copy) + distance);\n  return copyHeld;\n}\n</code></pre>\n<p>The purpose is to duplicate an object of a particular type and return it \"held\" by the same subobject as the input. Note that in principle, <code>HeldAs</code> can be an ambiguous or inaccessible base class of <code>MostDerived</code>, so no cast can help here.</p>\n<p>This is my code, but it can be used with types outside my control (i.e. I cannot modify <code>MostDerived</code> or <code>HeldAs</code>). The function has the following preconditions:</p>\n<ul>\n<li><code>*original</code> is of dynamic type <code>MostDerived</code></li>\n<li><code>HeldAs</code> is <code>MostDerived</code> or a direct or indirect base class of <code>MostDerived</code> (ignoring cv-qualifiation)</li>\n<li><code>*held</code> refers to <code>*original</code> or one of its base class subobjects.</li>\n</ul>\n<p>Let's assume the preconditions are satisifed. Does <code>duplicate</code> have defined behaviour in such case?</p>\n<p>C++11 [expr.reinterpret.cast] says (bold emphasis mine):</p>\n<blockquote>\n<p id=\"so_25265824_25265824_0\">4 A pointer can be explicitly converted to any integral type large enough to hold it. The mapping function is\n  implementation-defined. [ <em>Note:</em> It is intended to be unsurprising to those who know the addressing structure\n  of the underlying machine. <em>\u2014end note</em> ] ...</p>\n<p id=\"so_25265824_25265824_1\">5 A value of integral type or enumeration type can be explicitly converted to a pointer. A pointer converted\n  to an integer of sufficient size (if any such exists on the implementation) and back to the same pointer type\n  will have its original value; <strong>mappings between pointers and integers are otherwise implementation-defined</strong>.\n  [ <em>Note:</em> Except as described in 3.7.4.3, the result of such a conversion will not be a safely-derived pointer\n  value. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>OK, let's say my compiler is GCC (or Clang, since that uses GCC's definitions of implementation-defined behaviour). Quoting <a href=\"https://gcc.gnu.org/onlinedocs/gcc/C_002b_002b-Implementation.html#C_002b_002b-Implementation\" rel=\"nofollow\">GCC docs chapter 5</a> on C++ implementation-defined behaviour:</p>\n<blockquote>\n<p id=\"so_25265824_25265824_2\">... Some choices are documented in the corresponding document for the C language. See <a href=\"https://gcc.gnu.org/onlinedocs/gcc/C-Implementation.html#C-Implementation\" rel=\"nofollow\">C Implementation</a>. ...</p>\n</blockquote>\n<p>On to <a href=\"https://gcc.gnu.org/onlinedocs/gcc/Arrays-and-pointers-implementation.html#Arrays-and-pointers-implementation\" rel=\"nofollow\">chapter 4.7</a> (C implementation, arrays and pointers):</p>\n<blockquote>\n<p id=\"so_25265824_25265824_3\"><em>The result of converting a pointer to an integer or vice versa (C90 6.3.4, C99 and C11 6.3.2.3).</em></p>\n<p id=\"so_25265824_25265824_4\">A cast from pointer to integer discards most-significant bits if the pointer representation is larger than the integer type, sign-extends if the pointer representation is smaller than the integer type, otherwise the bits are unchanged.</p>\n<p id=\"so_25265824_25265824_5\">A cast from integer to pointer discards most-significant bits if the pointer representation is smaller than the integer type, extends according to the signedness of the integer type if the pointer representation is larger than the integer type, otherwise the bits are unchanged.</p>\n</blockquote>\n<p>So far, so good. It would seem that since I'm using <code>std::uintptr_t</code> which is guaranteed to be large enough for any pointer, and since I'm dealing with the same types, <code>copyHeld</code> should point to the same <code>HeldAs</code> subobject of <code>*copy</code> as <code>held</code> was pointing to within <code>*original</code>.</p>\n<p>Unfortunately, there's one more paragraph in the GCC docs:</p>\n<blockquote>\n<p id=\"so_25265824_25265824_6\">When casting from pointer to integer and back again, the resulting pointer must reference the same object as the original pointer, otherwise the behavior is undefined. That is, one may not use integer arithmetic to avoid the undefined behavior of pointer arithmetic as proscribed in C99 and C11 6.5.6/8.</p>\n</blockquote>\n<p>Wham. So now it seems that even though the value of <code>copyHeld</code> is computed in accordance with the rules of the first two paragraphs, the third one still sends this into Undefined-Behaviour land.</p>\n<p>I basically have three questions:</p>\n<ol>\n<li><p>Is my reading correct and the behavior of <code>duplicate</code> undefined?</p></li>\n<li><p>Which kind of Undefined Behaviour is this? The \"formally undefined, but will do what you want anyway\" kind, or the \"expect random crashses and/or spontaneous self-immolation\" one?</p></li>\n<li><p>If it's really Undefined, is there a way to do such a thing in a well-defined (possibly compiler-dependent) way?</p></li>\n</ol>\n<p>While my question is limited to GCC (and Clang) behaviour as far as compilers are concerned, I'd welcome an answer which considers all kinds of HW platforms, from common desktops to exotic ones.</p>\n", "Title": "Pointer/integer arithmetic (un)defined behaviour", "CreationDate": "2014-08-12T13:39:58.103", "LastActivityDate": "2014-08-12T23:33:47.237", "CommentCount": "8", "PostTypeId": "1", "Id": "25265824", "Score": "5", "OwnerUserId": "1782465", "Tags": "<c++><gcc><clang><undefined-behavior><pointer-conversion>", "AnswerCount": "1"}, "25275769": {"Id": "25275769", "PostTypeId": "2", "Body": "<p>The usual pattern for this is to put a <code>clone()</code> in the base class.<br>\nThen each derived class can implements its own version of clone.</br></p>\n<pre><code>class Base\n{\n     public:\n        virtual Base*  clone() = 0;\n};\n\nclass D: public Base\n{\n        virtual Base*  clone(){  return new D(*this);}\n};\n</code></pre>\n", "LastActivityDate": "2014-08-12T23:33:47.237", "Score": "0", "CreationDate": "2014-08-12T23:33:47.237", "ParentId": "25265824", "CommentCount": "5", "OwnerUserId": "14065"}});