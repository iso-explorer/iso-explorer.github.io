post_cb({"31409151": {"ParentId": "31400109", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>If the second and third operand to the conditional operator do not have the same <em>\"type\"</em> then an attempt to covert one of the operands to the other is made. If this conversion can not be made or is ambiguous then the program is ill-formed.</p>\n<p>This has what to some may seem unexpected results, one of those interesting cases would be <a href=\"https://stackoverflow.com/q/27989031/1708801\">capturless lambda with compatible function signature after conversion to a function pointer</a>, for example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\n\nint main() {\n    std::vector&lt;int&gt; v(0, 10);\n    bool increase = true;\n    std::sort(v.begin(), v.end(), increase ? \n          [](int lhs, int rhs){return lhs &lt; rhs;} : \n          [](int lhs, int rhs){return lhs &gt; rhs;} );\n    return 0;\n} \n</code></pre>\n<p>is valid. We can see from the following <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54557\" rel=\"nofollow noreferrer\">bug report</a> this also applies in general and in particular for this question applies to classes without a common base. The following example is taken from the bug report:</p>\n<pre><code>struct A{ typedef void (*F)(); operator F(); };\nstruct B{ typedef void (*F)(); operator F(); };\n\nvoid f() {\n  false ? A() : B();\n}\n</code></pre>\n<p>is valid since like the captureless lambda case both <code>A</code> and <code>B</code> can be converted to a function pointer.</p>\n<p>For reference the draft C++ standard in section <code>5.16</code> <em>[expr.cond]</em> says:</p>\n<blockquote>\n<p id=\"so_31400109_31409151_0\">Otherwise, if the second and third operand have different types and either has (possibly cv-qualified) class\n  type, or if both are glvalues of the same value category and the same type except for cv-qualification, an\n  attempt is made to convert each of those operands to the type of the other.</p>\n</blockquote>\n<p>and then covers the rules and then says:</p>\n<blockquote>\n<p id=\"so_31400109_31409151_1\">Using this process, it is determined whether the second operand can be converted to match the third\n  operand, and whether the third operand can be converted to match the second operand. If both can be\n  converted, or one can be converted but the conversion is ambiguous, the program is ill-formed. If neither\n  can be converted, the operands are left unchanged and further checking is performed as described below.\n  If exactly one conversion is possible, that conversion is applied to the chosen operand and the converted\n  operand is used in place of the original operand for the remainder of this section</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:00:03.463", "Id": "31409151", "Score": "4", "CreationDate": "2015-07-14T14:11:53.137", "LastActivityDate": "2015-07-14T14:11:53.137"}, "31400109": {"CommentCount": "4", "AcceptedAnswerId": "31400183", "PostTypeId": "1", "LastEditorUserId": "3747990", "CreationDate": "2015-07-14T07:17:24.493", "LastActivityDate": "2016-08-21T18:39:50.030", "LastEditDate": "2015-07-14T07:31:10.490", "ViewCount": "1698", "FavoriteCount": "2", "Title": "Why can (false?A():B()).test() compile only when A and B have a subclass relationship?", "Id": "31400109", "Score": "21", "Body": "<p>Originally I like to use something like this:</p>\n<pre><code>(true?a:b).test()\n</code></pre>\n<p>instead of</p>\n<pre><code>(true?a.test():b.test())\n</code></pre>\n<p>in order to save typing time if the function has the same name, initially I thought it should be valid, but I found:</p>\n<pre><code>#include &lt;stdio.h&gt;\nclass A{\npublic:\n    char test(){\n        return 'A';\n    }\n};\n\nclass B{\npublic:\n    char test(){\n        return 'B';\n    }\n};\n\nint main(){\n    printf(\"%c\\n\",(false?A():B()).test());\n    return 0;\n}\n</code></pre>\n<p>cannot compile, but if <code>B</code> is subclass of <code>A</code>:</p>\n<pre><code>#include &lt;stdio.h&gt;\nclass A{\npublic:\n    char test(){\n        return 'A';\n    }\n};\n\nclass B : public A{\npublic:\n    char test(){\n        return 'B';\n    }\n};\n\nint main(){\n    printf(\"%c\\n\",(false?A():B()).test());\n    return 0;\n}\n</code></pre>\n<p>it can compile, why?</p>\n", "Tags": "<c++><inheritance><syntax><ternary-operator>", "OwnerUserId": "4822120", "AnswerCount": "4"}, "31443499": {"ParentId": "31400109", "CommentCount": "0", "Body": "<p>Add it to the language:</p>\n<pre><code>template&lt;class F&gt;\nstruct if_t {\n  bool b;\n  F f;\n  template&lt;class Lhs, class Rhs&gt;\n  auto operator()(Lhs&amp;&amp;lhs, Rhs&amp;&amp;rhs)&amp;&amp;\n  -&gt;std::result_of_t&lt;F(Lhs)&gt;\n  {\n    if (b) return std::forward&lt;F&gt;(f)(std::forward&lt;Lhs&gt;(lhs));\n    else return std::forward&lt;F&gt;(f)(std::forward&lt;Rhs&gt;(rhs));\n  }\n  template&lt;class Lhs&gt;\n  void operator()(Lhs&amp;&amp;lhs)&amp;&amp;\n  {\n    if (b)\n      std::forward&lt;F&gt;(f)(std::forward&lt;Lhs&gt;(lhs));\n  }\n};\n\ntemplate&lt;class F&gt;\nif_t&lt;std::decay_t&lt;F&gt;&gt; branch(bool b, F&amp;&amp; f){\n  return {b,std::forward&lt;F&gt;(f)};\n}\n</code></pre>\n<p>then we get:</p>\n<pre><code>branch(false, [&amp;](auto&amp;&amp;arg){return arg.test();})\n(\n  A{}, B{}\n);\n</code></pre>\n<p>where it only works if both <code>A</code> and <code>B</code> have a <code>.test()</code> and the return value of <code>B::test()</code> can be converted into the return value of <code>A::test()</code>.</p>\n<p>Sadly, both <code>A{}</code> and <code>B{}</code> are constructed.</p>\n<pre><code>template&lt;class T&gt;\nauto make(){return [](auto&amp;&amp;...args){return {decltype(args)(args)...};}}\n\nbranch(false, [&amp;](auto&amp;&amp;arg){return arg().test();})\n(\n  make&lt;A&gt;(), make&lt;B&gt;()\n);\n</code></pre>\n<p>which differs the construction.</p>\n<p>Not the most elegant syntax.  It can be cleaned up some, but not enough (in my opinion).  There is no way to create lazy operators in C++ with a clean syntax, you can only use the built-in ones.</p>\n<p>Anyhow, your code cannot work because <code>?:</code> is an expression that returns a type.  There is no type that can represent both an <code>A</code> and a <code>B</code>, so it cannot work.  If one was the base of the other, or there was a conversion, etc then it would work.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "31443499", "Score": "0", "CreationDate": "2015-07-16T00:31:49.377", "LastActivityDate": "2015-07-16T00:31:49.377"}, "31400183": {"ParentId": "31400109", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>The reason is that <code>(test?a:b)</code> is an expression and must have a type. That type is the common type of a and b, and unrelated types have no type in common. The common type of a base and derived class is the base class.</p>\n<p>Note that the question contains an assumption that the <em>only</em> case which compiles is where there's a common base type. In fact, it also compiles if there's a unambiguous conversion from one type to the other. </p>\n", "OwnerUserId": "15416", "LastEditorUserId": "15416", "LastEditDate": "2015-07-14T09:29:55.377", "Id": "31400183", "Score": "52", "CreationDate": "2015-07-14T07:21:54.577", "LastActivityDate": "2015-07-14T09:29:55.377"}, "31400247": {"ParentId": "31400109", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The conditional operator (<code>?:</code>) operands must have a common type. I.e. given <code>E1 ? E2 : E3</code> then <code>E2</code> and <code>E3</code> must be unambiguously convertible. This type is then the return type that is then used for the expression as a whole.</p>\n<p>From <a href=\"http://en.cppreference.com/w/cpp/language/operator_other#Conditional_operator\" rel=\"nofollow\">cppreference</a>, they list the rules and requirements, but a salient line that is relevant here is;</p>\n<blockquote>\n<p id=\"so_31400109_31400247_0\">The return type of a conditional operator is also accessible as the binary type trait <code>std::common_type</code></p>\n</blockquote>\n<p>Which basically is saying that there must be a common type, and <code>std::common_type</code> can be used to calculate that type.</p>\n<p>Based on your code snippet <code>(true ? a.test() : b.test())</code> worked since both <code>a.test()</code> and <code>b.test()</code> returned <code>char</code>. However <code>a</code> and <code>b</code> are unrelated thus cannot be used by themselves.</p>\n<hr>\n<p>The relevant material in the C++ (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4527.pdf\" rel=\"nofollow\">WD n4527</a>) standard is found is <a href=\"http://eel.is/c++draft/expr.cond\" rel=\"nofollow\">\u00a75.16 ([expr.cond])</a>. There are several rules and conversions that are applied, the gist of it is that <strong>if there is no conversion, or if the conversion is ambiguous, the program is ill-formed</strong>.</p>\n</hr>", "OwnerUserId": "3747990", "LastEditorUserId": "3747990", "LastEditDate": "2016-08-21T18:39:50.030", "Id": "31400247", "Score": "18", "CreationDate": "2015-07-14T07:25:01.900", "LastActivityDate": "2016-08-21T18:39:50.030"}, "bq_ids": {"n4140": {"so_31400109_31409151_0": {"section_id": 6169, "quality": 1.0, "length": 29}, "so_31400109_31409151_1": {"section_id": 6169, "quality": 1.0, "length": 55}}, "n3337": {"so_31400109_31409151_0": {"section_id": 5930, "quality": 1.0, "length": 29}, "so_31400109_31409151_1": {"section_id": 5930, "quality": 1.0, "length": 55}}, "n4659": {"so_31400109_31409151_0": {"section_id": 7667, "quality": 0.9655172413793104, "length": 28}, "so_31400109_31409151_1": {"section_id": 7667, "quality": 0.6909090909090909, "length": 38}}}});