post_cb({"28778769": {"ParentId": "28778671", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-02-28T06:09:50.297", "Score": "1", "LastEditorUserId": "951890", "LastEditDate": "2015-02-28T06:18:27.603", "Id": "28778769", "OwnerUserId": "951890", "Body": "<p>5.1.1.13 in the C++14 standard:</p>\n<blockquote>\n<p id=\"so_28778671_28778769_0\">An id-expression that denotes a non-static data member or non-static\n  member function of a class can only be used:</p>\n<ul>\n<li>as part of a class member access (5.2.5) in which the object expression refers to the member\u2019s class or a class derived from that\n  class, or</li>\n<li>to form a pointer to member (5.3.1), or</li>\n<li>if that id-expression denotes a non-static data member and it appears in an unevaluated operand.</li>\n</ul>\n</blockquote>\n<p>Case 1 is where you are trying to be more specific about what member you mean.  For example <code>a.A::b</code>.</p>\n<p>Case 2 is where you take the address of the member.  For example <code>&amp;A::b</code>.</p>\n<p>Case 3 is where it is unevaluated.  For example <code>sizeof(A::b)</code>.</p>\n<p>The <code>A::b</code> in your example is none of these, so it is illegal.</p>\n", "LastActivityDate": "2015-02-28T06:18:27.603"}, "bq_ids": {"n4140": {"so_28778671_28778769_0": {"section_id": 5959, "quality": 1.0, "length": 10}}, "n3337": {"so_28778671_28778769_0": {"section_id": 5728, "quality": 1.0, "length": 10}}, "n4659": {"so_28778671_28778769_0": {"section_id": 7440, "quality": 1.0, "length": 10}}}, "28778671": {"CommentCount": "3", "ViewCount": "40", "OwnerDisplayName": "user2953119", "CreationDate": "2015-02-28T05:57:46.473", "LastActivityDate": "2015-02-28T06:18:27.603", "PostTypeId": "1", "AcceptedAnswerId": "28778769", "Title": "Understanding non-static class member access", "Id": "28778671", "Score": "1", "Body": "<p>I'd like to understand all case allowing us using of the <code>::</code> operator to get  access class data members. For instance, we could use <code>::</code> to access static data members. Actually, </p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    static const int b = 3;\n};\n\nint main() { std::cout &lt;&lt; A::b &lt;&lt; std::endl; }\n</code></pre>\n<p>also, we could use the expression to get access to non-static data members within a <code>brace-or-equal initializer</code> of a non-static data member. </p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    int b = 3;\n    void foo()\n    {\n        std::cout &lt;&lt; A::b &lt;&lt; std::endl;\n    }\n};\n\nint main() { A().foo(); }\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/310f74d2a20854bb\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>I'm looking for the rule covering all cases where we could use <code>::</code> operator. What chapter of the Strandard tells us that we should't use <code>::</code> to accessing non-static data member like this</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A\n{\n    int b = 3;\n};\n\nint main() { std::cout &lt;&lt; A::b &lt;&lt; std:endl; } //error\n</code></pre>\n", "Tags": "<c++><class>", "AnswerCount": "1"}});