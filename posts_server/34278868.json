post_cb({"36756102": {"ParentId": "34278868", "CommentCount": "0", "CreationDate": "2016-04-20T22:07:51.313", "OwnerUserId": "4993180", "PostTypeId": "2", "Id": "36756102", "Score": "-1", "Body": "<p>Since, the functions above needs to be declared so that all functions that use it needs to know about it.</p>\n<p>In a class, the functions are declared in the header file. If they are not a member then, they need to be declared before they are used. This is because the compiler reads from top to bottom and only knows about a function when it sees the declaration.</p>\n<p>If you swap the concept code and the draw code it should work also.</p>\n", "LastActivityDate": "2016-04-20T22:07:51.313"}, "34278868": {"CommentCount": "8", "ViewCount": "254", "CreationDate": "2015-12-15T00:08:16.433", "LastActivityDate": "2016-05-05T01:41:23.070", "Title": "Concepts and declaration order", "FavoriteCount": "1", "PostTypeId": "1", "Id": "34278868", "Score": "11", "Body": "<p>I've been experimenting with concepts lite in GCC from SVN. I've hit upon a problem which I suspect is due to my lack of understanding, and I'd appreciate it if anyone could point me in the right direction. My code is:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\n// Uncomment this declaration to change behaviour\n//void draw(const std::string&amp;);\n\ntemplate &lt;typename T&gt;\nconcept bool Drawable() {\n    return requires (const T&amp; t) {\n        { draw(t) }\n    };\n}\n\nvoid draw(const std::string&amp; s)\n{\n    std::cout &lt;&lt; s &lt;&lt; \"\\n\";\n}\n\nint main()\n{\n    static_assert(Drawable&lt;std::string&gt;()); // Fails\n}\n</code></pre>\n<p>Here I define a simple concept, <code>Drawable</code>, which is intended to require that a given a parameter of type <code>const T&amp;</code>, the function <code>draw(t)</code> compiles.</p>\n<p>I then define a function <code>draw(const std::string&amp;)</code> which \"draws\" the string to <code>cout</code>. Finally, I check whether <code>std::string</code> matches the <code>Drawable</code> concept -- which I would have expected it does, since an appropriate <code>draw()</code> function is in scope when the <code>static_assert</code> is called.</p>\n<p>However, the static assert fails, unless I include a declaration of <code>draw(const std::string&amp;)</code> <em>before</em> the concept definition, and I have no idea why.</p>\n<p>Is this expected behaviour with concepts, or am I doing something wrong? </p>\n", "Tags": "<c++><c++1z><c++-concepts>", "OwnerUserId": "2797826", "AnswerCount": "2"}, "37040939": {"ParentId": "34278868", "CommentCount": "0", "CreationDate": "2016-05-05T01:41:23.070", "OwnerUserId": "6292850", "PostTypeId": "2", "Id": "37040939", "Score": "1", "Body": "<p>The problem has nothing to do with ADL) but solely with name lookup. The concepts draft used by GCC is n4377 but the C++ standard draft I will be using is n4140. First, before diving into standardese we can turn your problem into an MCVE of a form we know is <em>supposed</em> to work. Example:</p>\n<pre><code>template&lt;typename T&gt; concept bool C =\n  requires (T a, T b) {\n    a + b;\n  };\n</code></pre>\n<p>This is a simple requirement, [expr.prim.req.simple], that checks the validity of the expression. Rewriting our example to match the form:</p>\n<pre><code>template&lt;typename T&gt; concept bool Drawable = \n  requires (const T&amp; x) { \n    draw(x); \n  };\n</code></pre>\n<p>We can see our syntax is fine. OK, what does n4377 say?</p>\n<blockquote>\n<p id=\"so_34278868_37040939_0\">[expr.prim.req]/1 A <em>requires-expression</em> provides a concise way to\n  express requirements on template arguments. A requirement is one that\n  can be checked by name lookup (3.4) or by checking properties of types\n  and expressions.</p>\n<p id=\"so_34278868_37040939_1\">[expr.prim.req]/6 The requirement-body is comprised of a sequence of\n  requirements. These requirements may refer to local parameters,\n  template parameters, and any other declarations visible from the\n  enclosing context. ...</p>\n</blockquote>\n<p>Makes sense. We know the <em>enclosing context</em> is the global namespace, so what does n4140 say?</p>\n<blockquote>\n<p id=\"so_34278868_37040939_2\">[basic.lookup.unqual]/1 In all the cases listed in 3.4.1, the scopes\n  are searched for a declaration in the order listed in each of the\n  respective categories; name lookup ends as soon as a declaration is\n  found for the name. If no declaration is found, the program is\n  ill-formed.</p>\n<p id=\"so_34278868_37040939_3\">A name used in the definition of a function following the function\u2019s\n  <em>declarator-id</em> that is a member of namespace <code>N</code> (where, only for the purpose of exposition, <code>N</code> could represent the global scope) shall be\n  declared before its use in the block in which it is used or in one of\n  its enclosing blocks (6.3) or, shall be declared before its use in\n  namespace <code>N</code> ...</p>\n</blockquote>\n<p>As the concept appertains to the function, the paragraph above applies.</p>\n", "LastActivityDate": "2016-05-05T01:41:23.070"}, "bq_ids": {"n4140": {"so_34278868_37040939_2": {"section_id": 7087, "quality": 0.9130434782608695, "length": 21}, "so_34278868_37040939_3": {"section_id": 7092, "quality": 1.0, "length": 29}}, "n3337": {"so_34278868_37040939_2": {"section_id": 6831, "quality": 0.9130434782608695, "length": 21}, "so_34278868_37040939_3": {"section_id": 6836, "quality": 1.0, "length": 29}}, "n4659": {"so_34278868_37040939_2": {"section_id": 8588, "quality": 0.9130434782608695, "length": 21}, "so_34278868_37040939_3": {"section_id": 8593, "quality": 0.6206896551724138, "length": 18}}}});