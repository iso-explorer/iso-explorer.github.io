post_cb({"17333194": {"CommentCount": "0", "AcceptedAnswerId": "17333648", "CreationDate": "2013-06-27T01:36:59.660", "LastActivityDate": "2013-06-27T16:17:23.577", "PostTypeId": "1", "ViewCount": "280", "FavoriteCount": "1", "Title": "Return value of unordered_multimap::bucket() when key does not exist?", "Id": "17333194", "Score": "4", "Body": "<p>When the key doesn't exist, what is <a href=\"http://en.cppreference.com/w/cpp/container/unordered_multimap/bucket\" rel=\"nofollow\"><code>unordered_multimap::bucket(key)</code></a> supposed to return?</p>\n<p>The reference says it's supposed to return the bucket number for the bucket that contains the key, but says nothing for what to expect when that key does not exist in the unordered_multimap.</p>\n<p><a href=\"http://ideone.com/AQXMdi\" rel=\"nofollow\">I tried it myself</a> but I get a result that is incorrect:</p>\n<pre><code>std::unordered_multimap&lt;std::string, std::string&gt; m = {{\"jack\", \"foo\"}, {\"jill\", \"bar\"}};\nstd::cout &lt;&lt; \"jack is in bucket \" &lt;&lt; m.bucket(\"jack\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"jill is in bucket \" &lt;&lt; m.bucket(\"jill\") &lt;&lt; std::endl;\nstd::cout &lt;&lt; \"bjarne is in bucket \" &lt;&lt; m.bucket(\"bjarne\") &lt;&lt; std::endl;\n</code></pre>\n<p>Output is:</p>\n<pre><code>jack is in bucket 3\njill is in bucket 4\nbjarne is in bucket 4\n</code></pre>\n<p>Does this mean I have to use say <code>unordered_multimap::count(key) == 0</code> to catch non-existing keys?</p>\n", "Tags": "<c++><c++11><stl>", "OwnerUserId": "2038264", "AnswerCount": "2"}, "17333683": {"ParentId": "17333194", "CommentCount": "0", "Body": "<p>Reading Table 103 of the standard the return of bucket is, \"the index of the bucket\nin which elements with keys equivalent to k would be found, if any such element existed.\"  So if \"bjarne\" was in the multimap then he would be in bucket 4.</p>\n<p>It does look like you have to use</p>\n<p><code>unordered_multimap::count(key) == 0</code> or </p>\n<p><code>unordered_multimap::find(k) == unordered_multimap::end()</code> to check for non-existent keys.</p>\n", "OwnerUserId": "8405", "PostTypeId": "2", "Id": "17333683", "Score": "1", "CreationDate": "2013-06-27T02:39:00.543", "LastActivityDate": "2013-06-27T02:39:00.543"}, "17333648": {"ParentId": "17333194", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It returns the index of the bucket the key <em>belongs to,</em> regardless of whether such a key has been inserted or not.</p>\n<p>From the Standard (C++11, \u00a723.2.5, Table 103, page 752):</p>\n<blockquote>\n<p id=\"so_17333194_17333648_0\"><code>b.bucket(k)</code></p>\n<p id=\"so_17333194_17333648_1\">Returns the index of the bucket in which elements with keys equivalent to <code>k</code> would be found if any such element existed.</p>\n</blockquote>\n<p>The only pre-condition is that <code>b.bucket_count &gt; 0</code> (which is pretty much always the case). In theory, the default constructor of <code>unordered_multimap</code> is allowed to generate the initial hash with zero buckets, but I doubt that any implementation actually does that).</p>\n<hr>\n<p>To check whether a key exists (i.e. has been inserted), either use</p>\n<pre><code>b.count(key) &gt; 0\n</code></pre>\n<p>as you suggested, or</p>\n<pre><code>b.find(key) != b.end()\n</code></pre>\n<p>(I would assume the latter tends to be more efficient, as checking for existence is, generally speaking, less of an effort than counting. This would be especially true in an <code>unordered_multimap</code>.)</p>\n</hr>", "OwnerUserId": "777186", "LastEditorUserId": "701092", "LastEditDate": "2013-06-27T16:17:23.577", "Id": "17333648", "Score": "4", "CreationDate": "2013-06-27T02:36:13.700", "LastActivityDate": "2013-06-27T16:17:23.577"}, "bq_ids": {"n4140": {"so_17333194_17333648_1": {"section_id": 763, "quality": 1.0, "length": 11}}, "n3337": {"so_17333194_17333648_1": {"section_id": 750, "quality": 1.0, "length": 11}}, "n4659": {"so_17333194_17333648_1": {"section_id": 823, "quality": 1.0, "length": 11}}}});