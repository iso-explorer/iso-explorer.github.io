post_cb({"28283405": {"ParentId": "28283215", "PostTypeId": "2", "CommentCount": "17", "Body": "<p>As far as I can tell this is covered in the draft C++ standard section <code>6.8</code> <em>Ambiguity resolution</em> which says that there can be an ambiguity between expression statements and declarations and says:</p>\n<blockquote>\n<p id=\"so_28283215_28283405_0\">There is an ambiguity in the grammar involving expression-statements\n  and declarations: An expression statement with a function-style\n  explicit type conversion (5.2.3) as its leftmost subexpression can be\n  indistinguishable from a declaration where the first declarator starts\n  with a (. In those cases the statement is a declaration. [ Note: To\n  disambiguate, the whole statement might have to be examined to\n  determine if it is an expression-statement or a declaration. This\n  disambiguates many examples. [ Example: assuming T is a\n  simple-type-specifier (7.1.6),</p>\n</blockquote>\n<p>and gives the following examples:</p>\n<pre><code>T(a)-&gt;m = 7; // expression-statement\nT(a)++; // expression-statement\nT(a,5)&lt;&lt;c; // expression-statement\n\nT(*d)(int); // declaration\nT(e)[5]; // declaration\nT(f) = { 1, 2 }; // declaration\nT(*g)(double(3)); // declaration\n</code></pre>\n<p>and then says:</p>\n<blockquote>\n<p id=\"so_28283215_28283405_1\">The remaining cases are declarations. [ Example:</p>\n<pre><code>class T {\n    // ...\n   public:\n    T();\n    T(int);\n    T(int, int);\n};\nT(a); // declaration\nT(*b)(); // declaration\nT(c)=7; // declaration\nT(d),e,f=3; // declaration\nextern int h;\nT(g)(h,2); // declaration\n</code></pre>\n<p id=\"so_28283215_28283405_2\">\u2014end example ] \u2014end note ]</p>\n</blockquote>\n<p><s>It seems like this case falls into the declaration examples in particular the last example seems to make the case in the OP, so <code>gcc</code> would be correct then.</s></p>\n<p>Relevant section mentioned above <code>5.2.3</code> <em>Explicit type conversion (functional notation)</em> says:</p>\n<blockquote>\n<p id=\"so_28283215_28283405_3\">[...] If the type specified is a class type, the class type shall be complete. If the expression\n  list specifies more than a single value, the type shall be a class with a suitably declared constructor (8.5, 12.1),\n  and the expression T(x1, x2, ...) is equivalent in effect to the declaration T t(x1, x2, ...); for some\n  invented temporary variable t, with the result being the value of t as a prvalue.</p>\n</blockquote>\n<p>and <code>8.3</code> <em>Meaning of declarators</em> which says:</p>\n<blockquote>\n<p id=\"so_28283215_28283405_4\">In a declaration T D where D has the form</p>\n<pre><code>( D1 ) \n</code></pre>\n<p id=\"so_28283215_28283405_5\">the type of the contained declarator-id is the same as that of the \n  contained declarator-id in the declaration</p>\n<pre><code>T D1\n</code></pre>\n<p id=\"so_28283215_28283405_6\">Parentheses do not alter the type of the embedded declarator-id, but\n  they can alter the binding of complex declarators.</p>\n</blockquote>\n<p><b>Update</b></p>\n<p>I was originally using <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\">N337</a> but if we look at <a href=\"https://github.com/cplusplus/draft/blob/master/papers/n4296.pdf\">N4296</a> section <code>6.8</code> was updated an it now includes the following note:</p>\n<blockquote>\n<p id=\"so_28283215_28283405_7\">If the statement cannot syntactically be a declaration, there is no ambiguity, so this rule does not\n  apply.</p>\n</blockquote>\n<p>which means that <code>gcc</code> is incorrect since:</p>\n<pre><code>foo x (\"bar\")(\"baz\");\n</code></pre>\n<p>can not be a valid declaration, I originally interpreted paragraph <code>2</code> as saying if you case begins with any of the following then it is declaration, which is perhaps how the <code>gcc</code> implementor interpreted as well.</p>\n<p>I should have been more suspicious of paragraph <code>2</code> since the only normative part of paragraph <code>2</code> really said nothing with respect to paragraph <code>1</code> and seems to place a requirement on an example which is not normative. We can see that that statement form paragraph <code>2</code> is now actually a note which makes much more sense.</p>\n<p>As T.C. noted below, paragraph <code>2</code> was actually never normative, it just appeared that way and he <a href=\"https://github.com/cplusplus/draft/commit/4a58c6824c12ee4461edd9f5c891d050feca9032\">linked to the change that fixed it</a>.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-02-03T18:04:17.160", "Id": "28283405", "Score": "16", "CreationDate": "2015-02-02T17:34:09.600", "LastActivityDate": "2015-02-03T18:04:17.160"}, "28283215": {"CommentCount": "1", "ViewCount": "486", "PostTypeId": "1", "LastEditorUserId": "1505939", "CreationDate": "2015-02-02T17:22:54.393", "LastActivityDate": "2015-02-03T18:04:17.160", "Title": "g++ rejects, clang++ accepts: foo(x)(\"bar\")(\"baz\");", "AcceptedAnswerId": "28283405", "LastEditDate": "2015-02-02T23:29:38.717", "Id": "28283215", "Score": "25", "Body": "<p>Somebody had <a href=\"https://stackoverflow.com/questions/28254915/code-compiles-with-clang-but-not-with-gcc/28255085\">asked</a> the other day why something compiles with clang, but not with gcc. I intuitively understood what was happening and was able to help the person, but it got me wondering -- according to the standard, which compiler was correct? Here is a boiled down version of the code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass foo\n{\npublic:\n    foo(const std::string&amp; x):\n        name(x)\n    { }\n    foo&amp; operator()(const std::string&amp; x)\n    {\n        std::cout &lt;&lt; name &lt;&lt; \": \" &lt;&lt; x &lt;&lt; std::endl;\n        return (*this);\n    }\n    std::string name;\n};\n\nint main()\n{\n    std::string x = \"foo\";\n    foo(x)(\"bar\")(\"baz\");\n    return 0;\n}\n</code></pre>\n<p>This compiles fine with clang++, but g++ gives the following error:</p>\n<pre><code>runme.cpp: In function \u2018int main()\u2019:\nrunme.cpp:21:11: error: conflicting declaration \u2018foo x\u2019\n    foo(x)(\"bar\")(\"baz\");\n        ^\nrunme.cpp:20:17: error: \u2018x\u2019 has a previous declaration as \u2018std::string x\u2019\n    std::string x = \"foo\";\n</code></pre>\n<p>If I add a pair of parentheses in line 21, g++ is happy:</p>\n<pre><code>(foo(x))(\"bar\")(\"baz\");\n</code></pre>\n<p>In other words, g++ interprets this line as:</p>\n<pre><code>foo x (\"bar\")(\"baz\");\n</code></pre>\n<p>Methinks itsa bug in g++, but again, I wanted to ask the standard experts, which compiler got it wrong?</p>\n<p>PS: gcc-4.8.3, clang-3.5.1</p>\n", "Tags": "<c++><g++><clang++><most-vexing-parse>", "OwnerUserId": "4358570", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_28283215_28283405_5": {"section_id": 3213, "quality": 1.0, "length": 7}, "so_28283215_28283405_6": {"section_id": 3213, "quality": 1.0, "length": 12}, "so_28283215_28283405_7": {"section_id": 3922, "quality": 1.0, "length": 9}, "so_28283215_28283405_3": {"section_id": 5999, "quality": 0.9705882352941176, "length": 33}, "so_28283215_28283405_0": {"section_id": 3921, "quality": 0.5333333333333333, "length": 24}}, "n3337": {"so_28283215_28283405_3": {"section_id": 5767, "quality": 0.9705882352941176, "length": 33}, "so_28283215_28283405_6": {"section_id": 3087, "quality": 1.0, "length": 12}, "so_28283215_28283405_0": {"section_id": 3781, "quality": 0.6888888888888889, "length": 31}, "so_28283215_28283405_5": {"section_id": 3087, "quality": 1.0, "length": 7}}, "n4659": {"so_28283215_28283405_5": {"section_id": 3970, "quality": 1.0, "length": 7}, "so_28283215_28283405_6": {"section_id": 3970, "quality": 1.0, "length": 12}, "so_28283215_28283405_7": {"section_id": 4808, "quality": 1.0, "length": 9}, "so_28283215_28283405_0": {"section_id": 4807, "quality": 0.5333333333333333, "length": 24}}}, "28288088": {"ParentId": "28283215", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>If we remove the line </p>\n<pre><code>std::string x = \"foo\";\n</code></pre>\n<p>then g++ complains about:</p>\n<pre><code>foo(x)(\"bar\")(\"baz\");\n</code></pre>\n<p>with the syntax error:</p>\n<pre><code>foo.cc:20:18: error: expected ',' or ';' before '(' token\n     foo(x)(\"bar\")(\"baz\");\n</code></pre>\n<p>I do not see how <code>foo (x)(\"bar\")(\"baz\");</code> could be a valid declaration, and apparently g++ can't either.  The line <code>foo x(\"bar\")(\"baz\");</code> is rejected with the same error.</p>\n<p>The \"ambiguity resolution\" mentioned in Shafik's post only kicks in when the expression-statement is syntactically indistinguishable from a declaration. However in this case it is not a valid declaration syntax so there is no ambiguity, it must be an expression-statement.</p>\n<p>g++ fails to process the line as an expression-statement so it is a g++ bug.</p>\n<p>This is eerily similar to <a href=\"https://stackoverflow.com/questions/28034742/construction-of-temporary-in-function-call-is-interpreted-as-declaration/28035516#28035516\">this g++ bug</a> recently discussed on SO;  it seems that g++ is perhaps deciding too soon in processing that the line must be a declaration .</p>\n", "OwnerUserId": "1505939", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:33:49.253", "Id": "28288088", "Score": "5", "CreationDate": "2015-02-02T22:34:44.357", "LastActivityDate": "2015-02-02T22:49:36.573"}});