post_cb({"35126676": {"ParentId": "35109419", "CommentCount": "1", "Body": "<p>disclaimer: I am not a parallelism guru.</p>\n<blockquote>\n<p id=\"so_35109419_35126676_0\">Is it possible to mix atomic/non-atomic ops on the same memory, and if\n  so, how?</p>\n</blockquote>\n<p>you can write it in the code and compile, but it will probably yield undefined behaviour.</p>\n<p>when talking about atomics, it is important to understand what kind o problems do they solve.<br/></p>\n<p>As you might know, what we call in shortly \"memory\" is multi-layered set of entities which are capable to hold memory.<br/>\nfirst we have the RAM, then the cache lines , then the registers.<br/> </p>\n<p>on mono-core processors, we don't have any synchronization problem. on multi-core processors we have all of them. every core has it own set of registers and cache lines.</p>\n<p>this casues few problems.</p>\n<p>First one of them is memory reordering - the CPU may decide on runtime to scrumble some reading/writing instructions to make the code run faster. this may yield some strange results that are completly invisible on the high-level code that brought this set of instruction.<br/> the most classic example of this phenomanon is the \"two threads - two integer\" example:</p>\n<pre><code>int i=0;\nint j=0;\nthread a -&gt; i=1, then print j\nthread b -&gt; j=1 then print i;\n</code></pre>\n<p>logically, the result \"00\" cannot be. either a ends first, the result may be \"01\", either b ends first, the result may be \"10\". if both of them ends in the same time, the result may be \"11\". yet, if you build small program which imitates this situtation and run it in a loop, very quicly you will see the result \"00\"</p>\n<p>another problem is memory invisibility. like I mentioned before, the variable's value may be cached in one of the cache lines, or be stored in one of the registered. when the CPU updates a variables value - it may delay the writing of the new value back to the RAM. it may keep the value in the cache/regiter because it was told (by the compiler optimizations) that that value will be updated again soon, so in order to make the program faster - update the value again and only then write it back to the RAM. it may cause undefined behaviour if other CPU (and consequently a thread or a process) depends on the new value. </p>\n<p>for example, look at this psuedo code:</p>\n<pre><code>bool b = true;\nwhile (b) -&gt; print 'a'\nnew thread -&gt; sleep 4 seconds -&gt; b=false;\n</code></pre>\n<p>the character 'a' may be printed infinitly, because <code>b</code> may be cached and never be updated.</p>\n<p>there are many more problems when dealing with paralelism.</p>\n<p>atomics solves these kind of issues by (in a nutshell) telling the compiler/CPU how to read and write data to/from the RAM correctly without doing un-wanted scrumbling (read about <em>memory orders</em>). a memory order may force the cpu to write it's values back to the RAM, or read the valuse from the RAM even if they are cached. </p>\n<p>So, although you can mix non atomics actions with atomic ones, you only doing part of the job.</p>\n<p>for example let's go back to the second example:</p>\n<pre><code>atomic bool b = true;\nwhile (reload b) print 'a'\nnew thread - &gt; b = (non atomicly) false. \n</code></pre>\n<p>so although one thread re-read the value of b from the RAM again and again but the other thread may not write <code>false</code> back to the RAM.</p>\n<p>So although you can mix these kind of operations in the code, it will yield underfined behavior. </p>\n", "OwnerUserId": "3613500", "PostTypeId": "2", "Id": "35126676", "Score": "0", "CreationDate": "2016-02-01T09:14:06.933", "LastActivityDate": "2016-02-01T09:14:06.933"}, "bq_ids": {"n4140": {"so_35109419_35109419_0": {"section_id": 5834, "quality": 0.6451612903225806, "length": 20}}, "n3337": {"so_35109419_35109419_0": {"section_id": 5605, "quality": 0.7096774193548387, "length": 22}}, "n4659": {"so_35109419_35109419_0": {"section_id": 7296, "quality": 0.6451612903225806, "length": 20}}}, "35109419": {"CommentCount": "11", "ViewCount": "411", "PostTypeId": "1", "LastEditorUserId": "77070", "CreationDate": "2016-01-31T01:43:59.257", "LastActivityDate": "2016-02-02T22:02:04.257", "Title": "In C11/C++11, possible to mix atomic/non-atomic ops on the same memory?", "AcceptedAnswerId": "35164636", "LastEditDate": "2016-02-02T20:07:42.680", "Id": "35109419", "Score": "9", "Body": "<p>Is it possible to perform atomic and non-atomic ops on the same memory location?</p>\n<p>I ask not because I actually want to do this, but because I'm trying to understand the C11/C++11 memory model.  They define a \"data race\" like so:</p>\n<blockquote>\n<p id=\"so_35109419_35109419_0\">The execution of a program contains a <em>data race</em> if it contains two\n  conflicting actions in different threads, at least one of which is not\n  atomic, and neither happens before the other. Any such data race\n  results in undefined behavior.\n  -- <strong>C11</strong> \u00a75.1.2.4 p25, <strong>C++11</strong> \u00a7 1.10 p21</p>\n</blockquote>\n<p>Its the \"at least one of which is not atomic\" part that is troubling me.  If it weren't possible to mix atomic and non-atomic ops, it would just say \"on an object which is not atomic.\"</p>\n<p>I can't see any straightforward way of performing non-atomic operations on atomic variables.  <code>std::atomic&lt;T&gt;</code> in C++ doesn't define any operations with non-atomic semantics.  In C, all direct reads/writes of an atomic variable appear to be translated into atomic operations.</p>\n<p>I suppose <code>memcpy()</code> and other direct memory operations might be a way of performing a non-atomic read/write on an atomic variable?  ie. <code>memcpy(&amp;atomicvar, othermem, sizeof(atomicvar))</code>?  But is this even defined behavior?  In C++, <code>std::atomic</code> is not copyable, so would it be defined behavior to <code>memcpy()</code> it in C or C++?</p>\n<p>Initialization of an atomic variable (whether through a constructor or <code>atomic_init()</code>) is defined to not be atomic.  But this is a one-time operation: you're not allowed to initialize an atomic variable a second time.  Placement new or an explicit destructor call could would also not be atomic.  But in all of these cases, it doesn't seem like it would be defined behavior anyway to have a concurrent atomic operation that might be operating on an uninitialized value.</p>\n<p>Performing atomic operations on non-atomic variables seems totally impossible: neither C nor C++ define any atomic functions that can operate on non-atomic variables.</p>\n<p>So what is the story here?  Is it really about <code>memcpy()</code>, or initialization/destruction, or something else?</p>\n", "Tags": "<c++><c><multithreading><c++11><concurrency>", "OwnerUserId": "77070", "AnswerCount": "2"}, "35164636": {"ParentId": "35109419", "CommentCount": "4", "Body": "<p>I think you're overlooking another case, the reverse order. Consider an initialized <code>int</code> whose storage is reused to create an <code>std::atomic_int</code>. All atomic operations happen after its ctor finishes, and therefore on initialized memory. But any concurrent, non-atomic access to the now-overwritten <code>int</code> has to be barred as well.</p>\n<p>(I'm assuming here that the storage lifetime is sufficient and plays no role)</p>\n<p>I'm not entirely sure because I think that the second access to <code>int</code> would be invalid anyway as the type of the accessing expression <code>int</code> doesn't match the object's type at the time (<code>std::atomic&lt;int&gt;</code>). However, \"the object's type <strong>at the time</strong>\" assumes a single linear time progression which doesn't hold in a multi-threaded environment. C++11 in general has that solved by making such assumptions about \"<strong>the</strong> global state\" Undefined Behavior per se, and the rule from the question appears to fit in that framework.</p>\n<p>So perhaps rephrasing: if a single memory location contains an atomic object as well as a non-atomic object, and if the destruction of the earliest created (older) object is not sequenced-before the creation of the other (newer) object, then access to the older object conflicts with access to the newer object unless the former is scheduled-before the latter.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "35164636", "Score": "1", "CreationDate": "2016-02-02T22:02:04.257", "LastActivityDate": "2016-02-02T22:02:04.257"}});