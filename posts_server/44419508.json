post_cb({"bq_ids": {"n4140": {"so_44419508_44420912_2": {"length": 36, "quality": 1.0, "section_id": 307}, "so_44419508_44420912_0": {"length": 9, "quality": 0.9, "section_id": 307}, "so_44419508_44420912_3": {"length": 12, "quality": 1.0, "section_id": 286}}, "n3337": {"so_44419508_44420912_2": {"length": 36, "quality": 1.0, "section_id": 298}, "so_44419508_44420912_0": {"length": 9, "quality": 0.9, "section_id": 298}, "so_44419508_44420912_3": {"length": 12, "quality": 1.0, "section_id": 277}}, "n4659": {"so_44419508_44420912_2": {"length": 36, "quality": 1.0, "section_id": 314}, "so_44419508_44420912_0": {"length": 10, "quality": 1.0, "section_id": 314}, "so_44419508_44420912_3": {"length": 12, "quality": 1.0, "section_id": 293}}}, "44421231": {"Id": "44421231", "PostTypeId": "2", "Body": "<p>Justin is correct. Running GCC through a debugger leads to these lines of code:</p>\n<pre><code>cp_parser_lookup_name(cp_parser*, tree_node*, tag_types, bool, bool, bool, tree_node**, unsigned int) () at ../../gcc/cp/parser.c:24665\n24665   {\n(gdb) \n24667     tree object_type = parser-&gt;context-&gt;object_type;\n(gdb) \n24670     if (ambiguous_decls)\n(gdb) \n24665   {\n(gdb) \n24667     tree object_type = parser-&gt;context-&gt;object_type;\n(gdb) \n24670     if (ambiguous_decls)\n(gdb) \n24676     parser-&gt;context-&gt;object_type = NULL_TREE;\n\n...\n\n(gdb) list 24670\n24665   {\n24666     tree decl;\n24667     tree object_type = parser-&gt;context-&gt;object_type;\n24668   \n24669     /* Assume that the lookup will be unambiguous.  */\n24670     if (ambiguous_decls)\n24671       *ambiguous_decls = NULL_TREE;\n24672   \n24673     /* Now that we have looked up the name, the OBJECT_TYPE (if any) is\n24674        no longer valid.  Note that if we are parsing tentatively, and\n</code></pre>\n<p>And this is the actual code that emits the diagnostic:</p>\n<pre><code>6914                        complain);\n(gdb) \n\ntest.cpp:9:24: error: too many arguments to function \u2018void bar(Args&amp;&amp; ...) [with Args = {}]\u2019\n     bar(1, 2.0, &amp;change);\n                        ^\ntest.cpp:2:6: note: declared here\n void bar(Args&amp;&amp;...) {}\n\n...\n\n(gdb) list 6914\n6909              /* All other function calls.  */\n6910              postfix_expression\n6911            = finish_call_expr (postfix_expression, &amp;args,\n6912                        /*disallow_virtual=*/false,\n6913                        koenig_p,\n6914                        complain);\n6915    \n6916            if (close_paren_loc != UNKNOWN_LOCATION)\n6917              {\n6918            location_t combined_loc = make_location (token-&gt;location,\n</code></pre>\n<p>Skipping through a bunch of stuff (as it would make this answer unnecessarily long), the actual error occurs during overload resolution:</p>\n<pre><code>(gdb) \nadd_candidates (fns=0x7fffeffb0940, first_arg=first_arg@entry=0x0, args=args@entry=0x7fffeff9baf0, return_type=return_type@entry=0x0, explicit_targs=0x0, \n    template_only=false, conversion_path=0x0, access_path=0x0, flags=1, candidates=0x7fffffffd320, complain=3) at ../../gcc/cp/call.c:5302\n5302      for (; fns; fns = OVL_NEXT (fns))\n(gdb) \n5365    }\n(gdb) \nperform_overload_resolution (complain=3, any_viable_p=&lt;synthetic pointer&gt;, candidates=0x7fffffffd320, args=0x7fffeff9baf0, fn=&lt;optimized out&gt;)\n    at ../../gcc/cp/call.c:4036\n4036      *candidates = splice_viable (*candidates, false, any_viable_p);\n(gdb) \nbuild_new_function_call(tree_node*, vec&lt;tree_node*, va_gc, vl_embed&gt;**, bool, int) () at ../../gcc/cp/call.c:4111\n4111                          complain);\n(gdb) \n4115          if (complain &amp; tf_error)\n(gdb) \n4119          if (!any_viable_p &amp;&amp; candidates &amp;&amp; ! candidates-&gt;next\n(gdb) \n4120              &amp;&amp; (TREE_CODE (candidates-&gt;fn) == FUNCTION_DECL))\n(gdb) \n4121            return cp_build_function_call_vec (candidates-&gt;fn, args, complain);\n</code></pre>\n<p>The error occurs in <code>convert_arguments</code>:</p>\n<pre><code>(gdb) list 3611\n3606          allocated = make_tree_vector ();\n3607          params = &amp;allocated;\n3608        }\n3609    \n3610        nargs = convert_arguments (parm_types, params, fndecl, LOOKUP_NORMAL,\n3611                       complain);\n3612      if (nargs &lt; 0)\n3613        return error_mark_node;\n3614    \n3615      argarray = (*params)-&gt;address ();\n</code></pre>\n<p>Finally, the diagnostic is emitted in <code>error_num_args</code> because <code>if (TREE_CODE (TREE_TYPE (fndecl)) == METHOD_TYPE)</code> is false. </p>\n", "LastActivityDate": "2017-06-07T19:25:49.670", "CommentCount": "0", "CreationDate": "2017-06-07T19:25:49.670", "ParentId": "44419508", "Score": "3", "OwnerUserId": "8127591"}, "44419508": {"ViewCount": "692", "Body": "<p>With reference to the following code </p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;tuple&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n\nusing std::cout;\nusing std::endl;\nusing std::string;\n\ntemplate &lt;typename... Args&gt;\nvoid bar(Args&amp;&amp;...) {}\n\nint change(const string&amp;) { return 1; }\ndouble change(int) { return 1.0; }\n\nint main() {\n    // bar(1, 2.0, static_cast&lt;int(*)(const string&amp;)&gt;(&amp;change));\n    bar(1, 2.0, &amp;change);\n    return 0;\n}\n</code></pre>\n<p>I understand that the error in the above code is that the reference to the <code>change</code> function is ambiguous (which is why the commented line works), but then why does the compiler give this error message?</p>\n<pre><code>test.cpp:17:5: error: no matching function for call to 'bar'\n    bar(1, 2.0, &amp;change);\n    ^~~\ntest.cpp:11:6: note: candidate function not viable: requires 2 arguments, but 3 were\n      provided\nvoid bar(Args&amp;&amp;...) {}\n     ^\n1 error generated.\n</code></pre>\n<p>This happens both on gcc (&gt;5) as well as clang (<code>Apple LLVM version 8.0.0 (clang-800.0.42.1)</code>)</p>\n<p>I am just curious as to why <strong>both</strong> the compilers do not just say that the reference is ambiguous.  I feel like it has something to do with how template instantiations work in C++ but I am not sure of the exact reason.</p>\n", "Title": "Why does the compiler not give an ambiguous reference error?", "CreationDate": "2017-06-07T17:46:44.527", "LastActivityDate": "2017-06-07T19:25:49.670", "CommentCount": "10", "FavoriteCount": "6", "PostTypeId": "1", "LastEditDate": "2017-06-07T18:08:14.627", "LastEditorUserId": "1896169", "Id": "44419508", "Score": "24", "OwnerUserId": "5501675", "Tags": "<c++><c++11><templates><gcc><clang>", "AnswerCount": "2"}, "44420912": {"Id": "44420912", "PostTypeId": "2", "Body": "<p>I think the compiler is right, however weird it may be. Template argument deduction rules are different from substitution. The ambiguity in overloaded function resolution in a template parameter pack context does not necessarily mean failure.</p>\n<p>See <a href=\"http://eel.is/c++draft/temp.deduct.call#6\" rel=\"noreferrer\">[temp.deduct.call]/p6</a>:</p>\n<blockquote>\n<p id=\"so_44419508_44420912_0\">When P is a function type, function pointer type, or pointer to member\n  function type:</p>\n<p id=\"so_44419508_44420912_1\">...</p>\n<p id=\"so_44419508_44420912_2\">-- If the argument is an overload set (not containing function templates), trial argument deduction is attempted using each of the\n  members of the set.\n      If deduction succeeds for only one of the overload set members, that member is used as the argument value for the deduction.\n      If deduction succeeds for more than one member of the overload set the parameter is treated as a non-deduced context.</p>\n</blockquote>\n<p>So for the last argument of the parameter pack we're in a non-deduced context (not an error).</p>\n<p>And <a href=\"http://eel.is/c++draft/temp.arg.explicit#3\" rel=\"noreferrer\">[temp.arg.explicit]/p3</a>:</p>\n<blockquote>\n<p id=\"so_44419508_44420912_3\">... A trailing template parameter pack not otherwise deduced will be deduced to an empty sequence of template arguments. ...</p>\n</blockquote>\n<p>So it seems to me (although this last bit doesn't say it explicitly for partially deduced parameter packs) the ambiguous function pointer is simply thrown away at deduction phase, and subsequently the substitution fails because it is trying to substitute 3 arguments into a deduced 2-argument function. It never gets to a point when it needs to resolve ambiguity.</p>\n", "LastEditorUserId": "485343", "LastActivityDate": "2017-06-07T19:25:35.247", "Score": "7", "CreationDate": "2017-06-07T19:07:56.533", "ParentId": "44419508", "CommentCount": "0", "OwnerUserId": "485343", "LastEditDate": "2017-06-07T19:25:35.247"}});