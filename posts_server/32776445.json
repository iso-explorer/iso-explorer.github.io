post_cb({"40832844": {"ParentId": "32776445", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>A simple, a little bit dirty workaround until the relevant <em>committee</em> considers this trivial feature:</p>\n<p><em>Glob operators are syntactically similar to the constructors.</em></p>\n<p>Thus, you can't write a</p>\n<pre><code>static MyClass::operator()(...);\n</code></pre>\n<p>It was made simply impossible, because a <em>committee</em> decided so on unclear reasons. I would be so happy if I could talk with one of their members, to ask, what was in their mind as they decided so. Unfortunately, he probably wouldn't understand my question, because he never programmed c++. He only worked on its docs.</p>\n<p>Now they need some decades of</p>\n<ul>\n<li>debates</li>\n<li>consultations</li>\n<li>meetings</li>\n<li>and considerations</li>\n</ul>\n<p>to implement a trivial feature. I suspect the feature may be made available around in c++3x, and on emulated machines it may be even tried out.</p>\n<p>Until then, you can try to write:</p>\n<pre><code>MyClass::MyClass(...);\n</code></pre>\n<p>In both cases you can call <code>MyClass(...);</code>.</p>\n<p>Of course it is useful mainly if <code>MyClass</code> is a singleton. And, I would say it is a hack. Furthermore, it allocates a <code>sizeof(MyClass)</code> on the stack which may be bad in the performance / efficiency side.</p>\n<hr>\n<p>Furthermore, this will be in essence a constructor, and constructors can't return anything. But you can avoid this by storing the result in the instance, and then casting it by a cast operator to anything you wish to.</p>\n</hr>", "OwnerUserId": "1783163", "LastEditorUserId": "1783163", "LastEditDate": "2017-02-28T08:43:29.427", "Id": "40832844", "Score": "1", "CreationDate": "2016-11-27T19:13:48.457", "LastActivityDate": "2017-02-28T08:43:29.427"}, "32776445": {"CommentCount": "11", "AcceptedAnswerId": "32776545", "PostTypeId": "1", "LastEditorUserId": "27678", "CreationDate": "2015-09-25T06:53:01.230", "LastActivityDate": "2017-06-02T19:36:41.347", "LastEditDate": "2017-03-31T12:06:44.080", "ViewCount": "2966", "FavoriteCount": "2", "Title": "Why can't operator () of stateless functor be static?", "Id": "32776445", "Score": "9", "Body": "<p>Why is <code>operator ()</code> of stateless functor not allowed to be <code>static</code>? Stateless lambda objects are convertible to pointers to free functions having the same signature as their <code>operator ()</code>.</p>\n<p><a href=\"http://1drv.ms/1j4yRtz\" rel=\"nofollow noreferrer\">Stephan T. Lavavej</a> on p. 6 points out that conversion to a function pointer <em>is just an <code>operator FunctionPointer()</code></em> (cite). But I can't obtain a corresponding pointer to <code>operator ()</code> as to non-member function. For functor <code>struct F { void operator () () {} }</code> it seems to be impossible to convert <code>&amp;F::operator ()</code> to instance of type <code>using P = void (*)();</code>.</p>\n<p>Code:</p>\n<pre><code>struct L\n{\n    static\n    void operator () () const {} \n    operator auto () const\n    { \n        return &amp;L::operator ();\n    }\n};\n</code></pre>\n<p>The error is</p>\n<blockquote>\n<p id=\"so_32776445_32776445_0\">overloaded 'operator()' cannot be a static member function</p>\n</blockquote>\n<p>but <code>operator ()</code> is not overloaded.</p>\n", "Tags": "<c++><lambda><function-pointers><c++14><functor>", "OwnerUserId": "1430927", "AnswerCount": "4"}, "32776718": {"ParentId": "32776445", "CommentCount": "1", "Body": "<p>I would think that there's no technical reason to forbid this (but not being familiar with the de-facto cross-vendor C++ ABI (Itanium ABI), I can't promise anything). </p>\n<p>There's however an evolutional issue about this at <a href=\"https://cplusplus.github.io/EWG/ewg-active.html#88\" rel=\"nofollow\">https://cplusplus.github.io/EWG/ewg-active.html#88</a> . It even has the <em>[tiny]</em> mark on it, making it a somewhat \"trivial\" feature under consideration.</p>\n", "OwnerUserId": "34509", "PostTypeId": "2", "Id": "32776718", "Score": "4", "CreationDate": "2015-09-25T07:13:01.157", "LastActivityDate": "2015-09-25T07:13:01.157"}, "32776545": {"ParentId": "32776445", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Per standard 13.5/6,</p>\n<blockquote>\n<p id=\"so_32776445_32776545_0\"><strong>An operator function shall either be a non-static member function or be a non-member function</strong> and have\n  at least one parameter whose type is a class, a reference to a class, an enumeration, or a reference to an\n  enumeration.</p>\n</blockquote>\n<p>Additionally, in 13.5.4 it is stated that </p>\n<blockquote>\n<p id=\"so_32776445_32776545_1\">operator()\n  shall be a non-static member function with an arbitrary number of parameters. It can have\n  default arguments. It implements the function call syntax\n  postfix-expression\n  (\n  expression-list\n  opt\n  )\n  where the\n  postfix-expression\n  evaluates to a class object and the possibly empty\n  expression-list\n  matches\n  the parameter list of an\n  operator()\n  member function of the class. Thus, a call\n  x(arg1,...)\n  is interpreted\n  as\n  x.operator()(arg1, ...)\n  for a class object\n  x\n  of type\n  T</p>\n</blockquote>\n", "OwnerUserId": "1490355", "LastEditorUserId": "1490355", "LastEditDate": "2015-09-25T07:08:11.177", "Id": "32776545", "Score": "10", "CreationDate": "2015-09-25T07:00:17.263", "LastActivityDate": "2015-09-25T07:08:11.177"}, "40833132": {"ParentId": "32776445", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I can't see any technical reason to forbid a <code>static auto operator()( ... )</code>. But it's a special case, so it would complicate the standard to add support for it. And such complication is not necessary, because it's very easy to emulate:</p>\n<pre><code>struct L\n{\n    static void func() {}\n\n    void operator()() const { func(); }\n\n    operator auto () const\n    { \n        return &amp;L::func;\n    }\n};\n</code></pre>\n<p>See <a href=\"https://stackoverflow.com/a/32776718/464581\">Johannes' answer</a> for some possibly useful extra info.</p>\n", "OwnerUserId": "464581", "LastEditorUserId": "1329652", "LastEditDate": "2017-06-02T19:36:41.347", "Id": "40833132", "Score": "4", "CreationDate": "2016-11-27T19:42:15.403", "LastActivityDate": "2017-06-02T19:36:41.347"}, "bq_ids": {"n4140": {"so_32776445_32776445_0": {"section_id": 557, "quality": 0.8333333333333334, "length": 5}, "so_32776445_32776545_1": {"section_id": 662, "quality": 0.9024390243902439, "length": 37}, "so_32776445_32776545_0": {"section_id": 653, "quality": 0.95, "length": 19}}, "n3337": {"so_32776445_32776445_0": {"section_id": 548, "quality": 0.8333333333333334, "length": 5}, "so_32776445_32776545_1": {"section_id": 652, "quality": 0.9024390243902439, "length": 37}, "so_32776445_32776545_0": {"section_id": 643, "quality": 1.0, "length": 20}}, "n4659": {"so_32776445_32776445_0": {"section_id": 580, "quality": 0.8333333333333334, "length": 5}, "so_32776445_32776545_1": {"section_id": 690, "quality": 0.9024390243902439, "length": 37}, "so_32776445_32776545_0": {"section_id": 681, "quality": 0.95, "length": 19}}}});