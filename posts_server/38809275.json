post_cb({"bq_ids": {"n4140": {"so_38809275_38809409_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 599}}, "n3337": {"so_38809275_38809409_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 589}}, "n4659": {"so_38809275_38809409_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 622}}}, "38809409": {"Id": "38809409", "PostTypeId": "2", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/string/basic_string/basic_string\" rel=\"nofollow\"><code>std::string</code></a> has a constructor that takes an <code>initializer_list</code> argument.</p>\n<pre><code>basic_string( std::initializer_list&lt;CharT&gt; init,\n              const Allocator&amp; alloc = Allocator() );\n</code></pre>\n<p>That constructor always gets precedence when you use a <em>braced-init-list</em> to construct <code>std::string</code>. The other constructors are only considered if the elements in the <em>braced-init-list</em> are not convertible to the type of elements in the <code>initializer_list</code>. This is mentioned in <a href=\"http://eel.is/c++draft/over.match.list#1\" rel=\"nofollow\">[over.match.list]/1</a>.</p>\n<blockquote>\n<p id=\"so_38809275_38809409_0\">Initially, the candidate functions are the initializer-list constructors ([dcl.init.list]) of the class <code>T</code> and the argument list consists of the initializer list as a single argument.</p>\n</blockquote>\n<p>In your example, the first argument <code>5</code> is implicitly convertible to <code>char</code>, so the <code>initializer_list</code> constructor is viable, and it gets chosen.</p>\n<p>This is evident if you print each character in the strings as <code>int</code>s</p>\n<pre><code>void print(char const *prefix, string&amp; s)\n{\n    cout &lt;&lt; prefix &lt;&lt; s &lt;&lt; \", size \" &lt;&lt; s.size() &lt;&lt; \": \";\n    for(int c : s) cout &lt;&lt; c &lt;&lt; ' ';\n    cout &lt;&lt; '\\n';\n}\n\nstring str1 {\"aaaaa\"};\nstring str2 {5, 'a'};\nstring str3 (5, 'a');\n\nprint(\"str1: \", str1);\nprint(\"str2: \", str2);\nprint(\"str3: \", str3);\n</code></pre>\n<p>Output:</p>\n<pre><code>str1: aaaaa, size 5: 97 97 97 97 97 \nstr2: a, size 2: 5 97 \nstr3: aaaaa, size 5: 97 97 97 97 97 \n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/e270f7162f9788b0\" rel=\"nofollow\">Live demo</a></p>\n", "LastActivityDate": "2016-08-06T22:48:25.857", "Score": "2", "CreationDate": "2016-08-06T22:48:25.857", "ParentId": "38809275", "CommentCount": "2", "OwnerUserId": "241631"}, "38809354": {"Id": "38809354", "PostTypeId": "2", "Body": "<p>You are using <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/basic_string\" rel=\"nofollow noreferrer\"><code>std::string</code>'s constructor</a> with this siganture</p>\n<pre><code>std::basic_string( std::initializer_list&lt;CharT&gt; init, const Allocator&amp; alloc = Allocator() );\n</code></pre>\n<p>And the compiler treated <code>5</code> as a <code>char</code> type, which translates to an <code>ASCII</code> type that isn't printed on screen. If you change that <code>5</code> to a printable value, say <code>A</code> whose ASCII value is <code>65</code>, </p>\n<pre><code>string str2 {65, 'a'};\n</code></pre>\n<p>it will print:</p>\n<pre><code>Aa\n</code></pre>\n<p>See it <a href=\"http://coliru.stacked-crooked.com/a/5d4fd3d3c48c135d\" rel=\"nofollow noreferrer\">Live on Coliru</a> with an additional illustration</p>\n", "LastEditorUserId": "1621391", "LastActivityDate": "2016-08-06T22:42:13.570", "Score": "8", "CreationDate": "2016-08-06T22:37:05.743", "ParentId": "38809275", "CommentCount": "0", "LastEditDate": "2016-08-06T22:42:13.570", "OwnerUserId": "1621391"}, "38809275": {"ViewCount": "247", "Body": "<p>I am trying the uniform intializer with the string class of C++. Below is the code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main()\n{\n    string str1 {\"aaaaa\"};\n    string str2 {5, 'a'};\n    string str3 (5, 'a');\n\n    cout &lt;&lt; \"str1: \" &lt;&lt; str1 &lt;&lt; endl;\n    cout &lt;&lt; \"str2: \" &lt;&lt; str2 &lt;&lt; endl;\n    cout &lt;&lt; \"str3: \" &lt;&lt; str3 &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>\n<p>The output would be:</p>\n<pre><code>str1: aaaaa\nstr2: a\nstr3: aaaaa\n</code></pre>\n<p>This made me scratched my head. Why <code>str2</code> cannot achieved the desired result as <code>str3</code>?</p>\n", "AcceptedAnswerId": "38809409", "Title": "C++ - Uniform initializer with std::string", "CreationDate": "2016-08-06T22:25:00.140", "Id": "38809275", "CommentCount": "1", "LastEditDate": "2016-08-07T21:59:16.663", "PostTypeId": "1", "LastEditorUserId": "241631", "LastActivityDate": "2016-08-07T21:59:16.663", "Score": "5", "OwnerUserId": "5800979", "Tags": "<c++><string><c++11><uniform-initialization><list-initialization>", "AnswerCount": "2"}});