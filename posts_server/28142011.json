post_cb({"28142438": {"ParentId": "28142011", "LastEditDate": "2015-02-02T22:31:39.997", "CommentCount": "8", "CreationDate": "2015-01-25T22:39:53.593", "OwnerUserId": "560648", "LastEditorUserId": "246246", "PostTypeId": "2", "Id": "28142438", "Score": "1", "Body": "<p><strong>No.</strong></p>\n<p>This operation is defined by [string::assign]/4:</p>\n<blockquote>\n<pre><code>basic_string&amp; assign(const basic_string&amp; str, size_type pos,\n    size_type n = npos);\n</code></pre>\n<p id=\"so_28142011_28142438_0\"><em>Effects</em>: Determines the effective length <code>rlen</code> of the string to assign\n  as the smaller of <code>n</code> and <code>str.size() - pos</code> and calls <code>assign(str.data() + pos rlen)</code>.</p>\n</blockquote>\n<p><em>(<a href=\"https://github.com/cplusplus/draft/issues/434\" rel=\"nofollow\">dat typo</a>)</em></p>\n<p>Then:</p>\n<blockquote>\n<pre><code>basic_string&amp; assign(const charT* s, size_type n);\n</code></pre>\n<p id=\"so_28142011_28142438_1\"><em>Effects</em>: Replaces the string controlled by <code>*this</code> with a string\n  of length <code>n</code> whose elements are a copy of those pointed to by <code>s</code>.</p>\n</blockquote>\n<p>Nothing about this says anything about whether <code>str.assign(str, 0)</code> is at all safe (in particular, we have no way of knowing <em>when</em> the copy of each character will occur!).</p>\n<p>Therefore I strongly suggest you avoid doing it.</p>\n", "LastActivityDate": "2015-02-02T22:31:39.997"}, "bq_ids": {"n4140": {"so_28142011_28142438_1": {"section_id": 1665, "quality": 0.9090909090909091, "length": 10}, "so_28142011_28142011_1": {"section_id": 6290, "quality": 0.5555555555555556, "length": 5}, "so_28142011_28142438_0": {"section_id": 1661, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_28142011_28142438_1": {"section_id": 1661, "quality": 0.9090909090909091, "length": 10}, "so_28142011_28142011_1": {"section_id": 6050, "quality": 0.5555555555555556, "length": 5}, "so_28142011_28142438_0": {"section_id": 1657, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_28142011_28142438_1": {"section_id": 1828, "quality": 0.9090909090909091, "length": 10}, "so_28142011_28142011_1": {"section_id": 7797, "quality": 0.5555555555555556, "length": 5}, "so_28142011_28142438_0": {"section_id": 1819, "quality": 0.8571428571428571, "length": 12}}}, "28142011": {"CommentCount": "18", "CreationDate": "2015-01-25T21:55:55.447", "PostTypeId": "1", "AcceptedAnswerId": "28142438", "LastEditorUserId": "-1", "LastActivityDate": "2015-08-05T02:36:55.800", "LastEditDate": "2017-05-23T10:26:49.857", "ViewCount": "1637", "FavoriteCount": "2", "Title": "Can you assign a substring of a std::string to itself?", "Id": "28142011", "Score": "19", "Body": "<p>I recently found the need to replace a <code>std::string</code>'s contents with a substring of itself. The most logical function to call here I think is the following, from <a href=\"http://www.cplusplus.com/reference/string/string/assign/\" rel=\"nofollow noreferrer\">http://www.cplusplus.com/reference/string/string/assign/</a>:</p>\n<blockquote>\n<p id=\"so_28142011_28142011_0\"><em>substring (2)</em> \u00a0\u00a0\u00a0\u00a0 string&amp; assign (const string&amp; str, size_t subpos, size_t sublen);<br>\n  \u00a0\u00a0\u00a0\u00a0<br>\n  \u00a0\u00a0\u00a0\u00a0 Copies the portion of str that begins at the character position subpos and spans sublen characters (or until the end of str, if either str is too short or if sublen is string::npos).  </br></br></p>\n<p id=\"so_28142011_28142011_1\">\u00a0\u00a0\u00a0\u00a0 <em>str</em><br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Another string object, whose value is either copied or moved.  </br></p>\n<p id=\"so_28142011_28142011_2\">\u00a0\u00a0\u00a0\u00a0 <em>subpos</em><br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Position of the first character in str that is copied to the object as a substring. If this is greater than str's length, it throws out_of_range. Note: The first character in str is denoted by a value of 0 (not 1).  </br></p>\n<p id=\"so_28142011_28142011_3\">\u00a0\u00a0\u00a0\u00a0 <em>sublen</em><br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 Length of the substring to be copied (if the string is shorter, as many characters as possible are copied).\n      A value of string::npos indicates all characters until the end of str.</br></p>\n</blockquote>\n<p>However, I'm not certain if this is permissible, or if it can corrupt the string data. I know that <code>memcpy()</code>, for example, does not allow (or at least does not guarantee non-corruption in the case of) overwriting an area of memory with (a portion of) itself (see <a href=\"https://stackoverflow.com/questions/4415910/memcpy-vs-memmove\">memcpy() vs memmove()</a>). But I don't know if the above method has the same limitation.</p>\n<p>More generally, can you please comment if I should have been able to figure out the answer to this question myself? There's nothing in the documentation I linked to that makes it clear to me what the answer to this question is, except <em>perhaps</em> the qualifier \"Another\" in the description of the <code>str</code> parameter (\"<em>Another</em> string object\"), which seems to imply it cannot be the <em>this</em> object, although I don't find that to be unequivocal. Is that a weakness in the documentation?</p>\n", "Tags": "<c++><string>", "OwnerUserId": "4272464", "AnswerCount": "1"}});