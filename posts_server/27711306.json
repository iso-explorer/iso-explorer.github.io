post_cb({"bq_ids": {"n4140": {"so_27711306_27711626_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 215}}, "n3337": {"so_27711306_27711626_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 209}}, "n4659": {"so_27711306_27711626_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 223}}}, "27711626": {"Id": "27711626", "PostTypeId": "2", "Body": "<p>In the expression</p>\n<pre><code>bind(s)\n</code></pre>\n<p>the name <code>bind</code> is dependent because the argument <code>s</code> is of type <code>S</code> which is a template parameter. A dependent name is bound at the point of template instantiation. This occurs when you call</p>\n<pre><code>w.boo(f);\n</code></pre>\n<p>and thus instantiate <code>boo</code> with the type <code>S = idb::Fulalas</code>. When a dependent name is resolved, declarations are considered from two sources:</p>\n<blockquote id=\"so_27711306_27711626_0\">\n<ul>\n<li>Declarations that are visible at the point of definition of the template.</li>\n<li>Declarations from namespaces associated with the types of the function arguments both from the\n  instantiation context (14.6.4.1) and from the definition context.</li>\n</ul>\n</blockquote>\n<p>([temp.dep.res])</p>\n<p>Therefore, if a name is declared after the point of definition of the template but before the point of instantiation, then it can only be found by ADL, not by ordinary unqualified name lookup. Ordinary unqualified lookup can only find names that are visible at the point of definition of the template, not at the point of instantiation. Therefore, if <code>Fulalas</code> is not declared in the same namespace as <code>bind</code>, ADL will not find the declaration of <code>idb::bind</code> and name lookup will fail altogether.</p>\n", "LastActivityDate": "2014-12-30T19:50:39.900", "CommentCount": "0", "CreationDate": "2014-12-30T19:50:39.900", "ParentId": "27711306", "Score": "2", "OwnerUserId": "481267"}, "27711367": {"Id": "27711367", "PostTypeId": "2", "Body": "<p>It's not about the struct.</p>\n<p>It's about <code>bind</code> and Argument Dependent Lookup.</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/8111677/what-is-argument-dependent-lookup-aka-adl-or-koenig-lookup\">What is \"Argument-Dependent Lookup\" (aka ADL, or \"Koenig Lookup\")?</a></li>\n<li><a href=\"http://en.cppreference.com/w/cpp/language/adl\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/adl</a></li>\n</ul>\n<p><code>bind</code> is used unqualified and hence it's being looked for in <em>associated namespaces</em>. If the <code>struct</code> is not in the same namespace as that bind overload, then it will not be seen/considered.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-12-30T19:30:33.770", "Score": "5", "CreationDate": "2014-12-30T19:30:33.770", "ParentId": "27711306", "CommentCount": "5", "OwnerUserId": "85371", "LastEditDate": "2017-05-23T11:43:45.480"}, "27711306": {"ViewCount": "142", "Body": "<p>The title of the question does not reveal too much about my problem but I tried to explain the problem in a single phrase. Here is the problem, I have a similar code structure in an application compiled with MinGW in Windows and GCC in Linux. Visual Studio doesn't present any problem. The structure is as follows:</p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace idb\n{\n    class Wrapper\n    {\n    public:\n        template&lt;typename S&gt;\n        void boo(S&amp; s)\n        {\n            bind(s);\n        }\n    };\n}\n\nnamespace idb // &lt;- if this namespace changes, code explodes\n{\n    struct Fulalas\n    {\n        int x;\n    };\n}\n\nnamespace idb\n{\n    void bind(idb::Fulalas f)\n    {\n        std::cout &lt;&lt; f.x &lt;&lt; std::endl;\n    }\n}\n\nnamespace app\n{\n    class Foo\n    {\n    public:\n        void func()\n        {\n            idb::Fulalas f;\n            f.x = 5;\n            w.boo(f);\n        }\n\n    private:\n        idb::Wrapper w;\n    };\n}\n\nint main()\n{\n    app::Foo f;\n    f.func();\n    return 0;\n}\n</code></pre>\n<p>The question is why in GCC/MinGW changing <code>idb::Fulalas</code> to <code>aaa::Fulalas</code> (or any name desired) generates the following error:</p>\n<pre><code>..\\namespace\\main.cpp: In instantiation of 'void idb::Wrapper::boo(S&amp;) [with S = aaa::Fulalas]':\n..\\namespace\\main.cpp:41:11:   required from here\n..\\namespace\\main.cpp:11:10: error: 'bind' was not declared in this scope, and no declarations were found by argument-dependent lookup at the point of instantiation [-fpermissive]\n    bind(s);\n          ^\n..\\namespace\\main.cpp:26:7: note: 'void idb::bind(aaa::Fulalas)' declared here, later in the translation unit\n  void bind(aaa::Fulalas f)\n</code></pre>\n", "AcceptedAnswerId": "27711367", "Title": "Why does a struct have to be in the same namespace as a template class in order to compile?", "CreationDate": "2014-12-30T19:24:53.340", "Id": "27711306", "CommentCount": "4", "LastEditDate": "2014-12-30T19:50:52.457", "PostTypeId": "1", "LastEditorUserId": "661519", "LastActivityDate": "2014-12-30T19:50:52.457", "Score": "1", "OwnerUserId": "1089788", "Tags": "<c++><templates><gcc><mingw>", "AnswerCount": "2"}});