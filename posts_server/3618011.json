post_cb({"3618635": {"Id": "3618635", "PostTypeId": "2", "Body": "<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1905.pdf\" rel=\"nofollow noreferrer\">C++ Standard</a> says it like this :</p>\n<p>3.9.1, \u00a72 :</p>\n<blockquote>\n<p id=\"so_3618011_3618635_0\">There are five signed integer types :\n  \"signed char\", \"short int\", \"int\",\n  \"long int\", and \"long long int\". In\n  this list, each type provides at least\n  as much storage as those preceding it\n  in the list. Plain ints have the\n  natural size suggested by the\n  architecture of the execution\n  environment (44); the other signed\n  integer types are provided to meet\n  special needs.</p>\n<p id=\"so_3618011_3618635_1\">(44) that is, <b>large enough to contain\n  any value in the range of INT_MIN and\n  INT_MAX, as defined in the header\n  <code>&lt;climits&gt;</code></b>.</p>\n</blockquote>\n<p>The conclusion : it depends on which architecture you're working on. Any other assumption is false.</p>\n", "LastActivityDate": "2010-09-01T13:38:07.563", "CommentCount": "0", "CreationDate": "2010-09-01T13:38:07.563", "ParentId": "3618011", "Score": "1", "OwnerUserId": "3673"}, "3618034": {"Id": "3618034", "PostTypeId": "2", "Body": "<p>It depends on the architecture, that is the microprocessor/microcontroller you're compiling the code for (x86, ARM, PIC, Z80, 8051 etc.) and on the compiler, that is how the compiler implements the fundamental/built in data types.</p>\n", "LastActivityDate": "2010-09-01T12:38:55.410", "CommentCount": "1", "CreationDate": "2010-09-01T12:38:55.410", "ParentId": "3618011", "Score": "1", "OwnerUserId": "59775"}, "3618073": {"Id": "3618073", "PostTypeId": "2", "Body": "<p>The standard requires only:</p>\n<ul>\n<li>a range of a least \u00b132767 (i.e., at least 16 bits)</li>\n<li><code>int</code> is no shorter than <code>short</code> and no longer than <code>long</code>.  It may be equal in size to one of them, or neither.</li>\n</ul>\n<p>The exact size of integer types depends on the compiler.  The <em>de facto</em> standard is</p>\n<ul>\n<li><code>char</code> is 8 bits</li>\n<li><code>short</code> is 16 bits</li>\n<li><code>int</code> is 16 bits on 16-bit systems, and 32 bits on both 32- and 64-bit systems</li>\n<li><code>long</code> may be either 32 or 64 bits</li>\n</ul>\n", "LastActivityDate": "2010-09-01T12:44:38.173", "CommentCount": "1", "CreationDate": "2010-09-01T12:44:38.173", "ParentId": "3618011", "Score": "8", "OwnerUserId": "287586"}, "3618060": {"Id": "3618060", "PostTypeId": "2", "Body": "<p>You are guaranteed that a <code>short int</code> is at least 16 bits, and that a <code>long int</code> is at least 32 bits, and that plain <code>int</code> will be no smaller than a <code>short</code> nor larger than a <code>long</code>. But the actual sizes will be decided by the compiler implementor. </p>\n", "LastActivityDate": "2010-09-01T12:42:55.897", "CommentCount": "0", "CreationDate": "2010-09-01T12:42:55.897", "ParentId": "3618011", "Score": "1", "OwnerUserId": "1175"}, "3618011": {"ViewCount": "3796", "Body": "<p>I've been searching for a while but couldn't find a definite answer to this apparently simple question: what is the default length of an int?  </p>\n<p>I know that by default, an int is signed. But is it short or long?  </p>\n<p>According to the \"Fundamental data types\"table found in the following page, an int is a long int by default (4 bytes).\n<a href=\"http://www.cplusplus.com/doc/tutorial/variables/\" rel=\"nofollow noreferrer\">http://www.cplusplus.com/doc/tutorial/variables/</a></p>\n<p>Is it always true, or does this depend on the OS (32bit/64bit), the compiler or other things?  </p>\n", "AcceptedAnswerId": "3618025", "Title": "C++: What is the default length of an int?", "CreationDate": "2010-09-01T12:34:58.290", "Id": "3618011", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2010-09-01T14:12:59.033", "Score": "2", "OwnerUserId": "401523", "Tags": "<c++>", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_3618011_3618139_11": {"length": 45, "quality": 0.9574468085106383, "section_id": 7212}, "so_3618011_3618635_0": {"length": 42, "quality": 1.0, "section_id": 7211}, "so_3618011_3618635_1": {"length": 10, "quality": 1.0, "section_id": 7211}}, "n3337": {"so_3618011_3618139_11": {"length": 45, "quality": 0.9574468085106383, "section_id": 6956}, "so_3618011_3618635_0": {"length": 42, "quality": 1.0, "section_id": 6955}, "so_3618011_3618635_1": {"length": 10, "quality": 1.0, "section_id": 6955}}, "n4659": {"so_3618011_3618139_11": {"length": 45, "quality": 0.9574468085106383, "section_id": 8721}, "so_3618011_3618635_0": {"length": 41, "quality": 0.9761904761904762, "section_id": 8720}, "so_3618011_3618635_1": {"length": 8, "quality": 0.8, "section_id": 8720}}}, "3618025": {"Id": "3618025", "PostTypeId": "2", "Body": "<p>It depends on the compiler implementor. An <code>int</code> is supposed to be the best \"native\" length for the platform. Best native here typically refers to whichever size is most handy/efficient/fast for the targeted processor to work with. Often you can expect <code>int</code> to have the same size as the processor's (integer) registers.</p>\n<p>As others have pointed out, there are certain relationships about the various integer types' sizes that the compiler must adhere to, so it's the implementor is not free to choose anything. For instance, <code>int</code> can't be larger than <code>long</code>, and so on.</p>\n<p>You often talk about <a href=\"http://archive.opengroup.org/public/tech/aspen/lp64_wp.htm\" rel=\"noreferrer\">programming models</a> in relationship with issues like these, e.g. a compiler can chose to make the various types different sizes depending on the chosen model.</p>\n", "LastEditorUserId": "28169", "LastActivityDate": "2010-09-01T12:49:58.440", "Score": "12", "CreationDate": "2010-09-01T12:37:03.743", "ParentId": "3618011", "CommentCount": "5", "OwnerUserId": "28169", "LastEditDate": "2010-09-01T12:49:58.440"}, "3618139": {"Id": "3618139", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_3618011_3618139_0\">$4.4 from \"The C++ programming Language\" by Bjarne</p>\n<p id=\"so_3618011_3618139_1\">Like char, each integer type comes in three forms: \u2018\u2018plain\u2019\u2019 int , signed int, and unsigned int . In addition, integers come in three sizes: short int , \u2018\u2018plain\u2019\u2019 int , and long int. <strong>A long int can be referred to as plain long . Similarly, short is a synonym for short int , unsigned for unsigned int, and signed for signed int .</strong></p>\n<p id=\"so_3618011_3618139_2\">The unsigned integer types are ideal for uses that treat storage as a bit array. Using an unsigned instead of an int to gain one more bit to represent positive integers is almost never a good idea. Attempts to ensure that some values are positive by declaring  variables unsigned will typically be defeated by the implicit conversion rules (\u00a7C.6.1, \u00a7C.6.2.1). Unlike plain chars, plain ints are always signed. The signed int types are simply more explicit synonyms for their plain int counterparts.</p>\n</blockquote>\n<p>Section 4.6 of the same book states</p>\n<p>Sizes of C++ objects are expressed in terms of multiples of the size of a char , so by definition the size of a char is 1 . The size of an object or type can be obtained using the sizeof operator</p>\n<blockquote>\n<p id=\"so_3618011_3618139_3\">(\u00a76.2). This is what is guaranteed\n  about sizes of fundamental types:</p>\n<p id=\"so_3618011_3618139_4\">1 &lt;= sizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long)   </p>\n<p id=\"so_3618011_3618139_5\">1 &lt;= sizeof(bool) &lt;= sizeof(long)  </p>\n<p id=\"so_3618011_3618139_6\">sizeof(char) &lt;= sizeof(wchar_t) &lt;= sizeof(long)   </p>\n<p id=\"so_3618011_3618139_7\">sizeof(float) &lt;= sizeof(double) &lt;= sizeof(long double) </p>\n<p id=\"so_3618011_3618139_8\">sizeof(N) &lt;= sizeof(signed N) &lt;= sizeof(unsigned N)</p>\n<p id=\"so_3618011_3618139_9\">where N can be char , short int, int ,\n  or long int . In addition, it is\n  guaranteed that a char has at least 8\n  bits, a short at least 16 bits, and a\n  long at least 32 bits. A char can hold\n  a character of the machine\u2019s character\n  set.</p>\n<p id=\"so_3618011_3618139_10\">This clearly indicates that\n  sizeof(int) is implementation defined\n  but is guaranteed to be minimum 32bits</p>\n</blockquote>\n<p>C++03 $3.9.1/3 </p>\n<blockquote>\n<p id=\"so_3618011_3618139_11\">\"For each of the signed integer types,\n  there exists a corresponding (but\n  different) unsigned integer type:\n  \u201cunsigned char\u201d, \u201cunsigned short int\u201d,\n  \u201cunsigned int\u201d, and \u201cunsigned long\n  int,\u201d <strong>each of which occupies the\n  same amount of storage and has the\n  same alignment requirements</strong> (3.9) as\n  the corresponding signed integer\n  type40) ; that is, each signed integer\n  type has the same object\n  representation as its corresponding\n  unsigned integer type.</p>\n</blockquote>\n", "LastEditorUserId": "418110", "LastActivityDate": "2010-09-01T14:12:59.033", "Score": "1", "CreationDate": "2010-09-01T12:51:34.613", "ParentId": "3618011", "CommentCount": "1", "OwnerUserId": "418110", "LastEditDate": "2010-09-01T14:12:59.033"}});