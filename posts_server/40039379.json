post_cb({"bq_ids": {"n4140": {"so_40039379_40041585_0": {"length": 18, "quality": 1.0, "section_id": 481}, "so_40039379_40039379_0": {"length": 41, "quality": 0.9761904761904762, "section_id": 481}}, "n3337": {"so_40039379_40041585_0": {"length": 18, "quality": 1.0, "section_id": 472}}, "n4659": {"so_40039379_40041585_0": {"length": 18, "quality": 1.0, "section_id": 504}, "so_40039379_40039379_0": {"length": 30, "quality": 0.7142857142857143, "section_id": 504}}}, "40039379": {"ViewCount": "358", "Body": "<p>The following code is rejected by both <a href=\"http://melpon.org/wandbox/permlink/UuvVd79Q87eaz6PQ\" rel=\"noreferrer\">Clang</a> and <a href=\"http://melpon.org/wandbox/permlink/U1k6P5mdJpX9vkGa\" rel=\"noreferrer\">GCC</a> (trunk versions):</p>\n<pre><code>#include &lt;memory&gt;\n\nstruct Base \n{\n    Base() = default; \n    Base(Base const&amp;) = delete;\n    Base(Base&amp;&amp;) = default;\n};\n\nstruct Derived : Base\n{\n    Derived() = default; \n    Derived(Derived const&amp;) = delete;\n    Derived(Derived&amp;&amp;) = default;\n};    \n\nauto foo()\n    -&gt; Base\n{\n    Derived d;    \n    return d;   // ERROR HERE\n}\n</code></pre>\n<p>According to [class.copy]/32:</p>\n<blockquote>\n<p id=\"so_40039379_40039379_0\">When the criteria for elision of a copy/move operation are met, but not for an exception-declaration, and the object to be copied is designated by an lvalue, <strong>or when the expression in a return statement is a (possibly parenthesized) id-expression that names an object with automatic storage duration</strong> declared in the body or parameter-declaration-clause of the innermost enclosing function or lambda-expression, <strong>overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue</strong></p>\n</blockquote>\n<p>If the sentence above is meant to be parsed as <code>(copy elision criteria met &amp;&amp; lvalue) || (id-expression designating an automatic object)</code>, as <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#1579\" rel=\"noreferrer\">this CWG defect</a> seems to indicate, why isn't the last condition applying here? Is there a compiler bug both in Clang and GCC? </p>\n<p>On the other hand, if the sentence is meant to be parsed as <code>(copy elision criteria met &amp;&amp; (lvalue || id-expression designating an automatic object))</code>, isn't this a very misleading wording worth a DR?</p>\n", "AcceptedAnswerId": "40041585", "Title": "Why is move constructor not picked when returning a local object of type derived from the function's return type?", "CreationDate": "2016-10-14T09:15:03.987", "Id": "40039379", "CommentCount": "15", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-10-14T09:17:48.500", "LastEditorUserId": "809387", "LastActivityDate": "2016-10-14T11:02:23.467", "Score": "15", "OwnerUserId": "1932150", "Tags": "<c++><return><language-lawyer><move-semantics><compiler-bug>", "AnswerCount": "1"}, "40041585": {"Id": "40041585", "PostTypeId": "2", "Body": "<p>[class.copy]/32 continues:</p>\n<blockquote>\n<p id=\"so_40039379_40041585_0\">[...] if the type of the first parameter of the selected constructor\n  is not an rvalue reference to the object's type (possibly\n  cv-qualified), overload resolution is performed again, considering the\n  object as an lvalue.</p>\n</blockquote>\n<p>The first overload resolution, treating <code>d</code> as an rvalue, selects <code>Base::Base(Base&amp;&amp;)</code>. The type of the first parameter of the selected constructor is, however, not <code>Derived&amp;&amp;</code> but <code>Base&amp;&amp;</code>, so the result of that overload resolution is discarded and you perform overload resolution again, treating <code>d</code> as an lvalue. That second overload resolution selects the deleted copy constructor.</p>\n", "LastActivityDate": "2016-10-14T11:02:23.467", "Score": "9", "CreationDate": "2016-10-14T11:02:23.467", "ParentId": "40039379", "CommentCount": "9", "OwnerUserId": "2756719"}});