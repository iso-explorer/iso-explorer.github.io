post_cb({"22472039": {"ParentId": "22471909", "CommentCount": "11", "Body": "<p>C++ Standard</p>\n<h1>5.9 Relational operators</h1>\n<blockquote>\n<p id=\"so_22471909_22472039_0\">Pointers to objects or functions of the same type (after pointer conversions) can be compared,\n  with a result defined as follows:</p>\n<p id=\"so_22471909_22472039_1\">\u2014 If two pointers p and q of the same type point to the same object or function, or both point one past\n  the end of the same array, or are both null, then p&lt;=q and p&gt;=q both yield true and p&lt;q and p&gt;q both\n  yield false.</p>\n<p id=\"so_22471909_22472039_2\">\u2014 If two pointers p and q of the same type point to different objects that are not members of the same\n  object or elements of the same array or to different functions, or if only one of them is null, the results\n  of pq, p&lt;=q, and p&gt;=q are unspecified.</p>\n<p id=\"so_22471909_22472039_3\">\u2014 If two pointers point to non-static data members of the same object, or to subobjects or array elements\n  of such members, recursively, the pointer to the later declared member compares greater provided the\n  two members have the same access control (Clause 11) and provided their class is not a union.</p>\n<p id=\"so_22471909_22472039_4\">\u2014 If two pointers point to non-static data members of the same object with different access control\n  (Clause 11) the result is unspecified.</p>\n<p id=\"so_22471909_22472039_5\">\u2014 If two pointers point to non-static data members of the same union object, they compare equal (after\n  conversion to void*, if necessary). If two pointers point to elements of the same array or one beyond\n  the end of the array, the pointer to the object with the higher subscript compares higher.</p>\n<p id=\"so_22471909_22472039_6\">\u2014 Other pointer comparisons are unspecified.\n  \u00a7</p>\n</blockquote>\n", "OwnerUserId": "453803", "PostTypeId": "2", "Id": "22472039", "Score": "4", "CreationDate": "2014-03-18T06:38:45.610", "LastActivityDate": "2014-03-18T06:38:45.610"}, "22471909": {"CommentCount": "0", "AcceptedAnswerId": "22472039", "PostTypeId": "1", "LastEditorUserId": "2644390", "CreationDate": "2014-03-18T06:31:50.933", "LastActivityDate": "2014-03-18T07:36:19.713", "LastEditDate": "2014-03-18T07:36:19.713", "ViewCount": "93", "FavoriteCount": "1", "Title": "When are two pointers comparable?", "Id": "22471909", "Score": "2", "Body": "<p>There so many questions on comparing two pointers, but I found none on whether the two <em>types</em> are such that the pointers can be compared. Given</p>\n<pre><code>A* a;\nB* b;\n</code></pre>\n<p>I want to know if expression <code>a @ b</code> is valid, where <code>@</code> is one of <code>==</code>,<code>!=</code>,<code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>,<code>&gt;=</code> (I don't mind about <code>nullptr_t</code> or any other type that can be implicitly converted to a pointer). Is it when <code>A, B</code> are</p>\n<ul>\n<li>equal?</li>\n<li>equal except for cv-qualification?</li>\n<li>in the same class hierarchy?</li>\n<li>...?</li>\n</ul>\n<p>I didn't find anything in <code>std::type_traits</code>. I could always do my own SFINAE test, but I am looking for the rules to apply them directly. I guess that will be easier for the compiler, right?</p>\n<p><strong>EDIT</strong> To clarify again: I am comparing pointers, not objects pointed to. I want to know in advance when <code>a @ b</code> will give a compiler error, not what will be its value (true or false or unspecified).</p>\n", "Tags": "<c++><pointers><typetraits><comparison-operators>", "OwnerUserId": "2644390", "AnswerCount": "2"}, "22472034": {"ParentId": "22471909", "CommentCount": "1", "Body": "<p>Those comparison operators are always 'valid', in that you can always use them. But the results usually will not be meaningful or useful.</p>\n<p><code>==</code> and <code>!=</code> will essentially tell you whether or not <code>a</code> and <code>b</code> refer to the same object. If <code>a == b</code>, then changing *a will affect *b and vice-versa.</p>\n<p><code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, and <code>&lt;=</code> will tell you where the memory addresses are, relative to one another. Usually this information will be irrelevant to the functionality of your program, and in most cases it will be unpredictable. However, one example that comes to mind where you might be able to use it is if you know that <code>a</code> and <code>b</code> point to member of the same array. In which case <code>a &lt; b</code> will tell you whether or not the object <code>*a</code> comes before <code>*b</code> in the array.</p>\n", "OwnerUserId": "475491", "PostTypeId": "2", "Id": "22472034", "Score": "1", "CreationDate": "2014-03-18T06:38:22.297", "LastActivityDate": "2014-03-18T06:38:22.297"}, "bq_ids": {"n4140": {"so_22471909_22472039_1": {"section_id": 6145, "quality": 0.5833333333333334, "length": 14}, "so_22471909_22472039_4": {"section_id": 6151, "quality": 0.7857142857142857, "length": 11}, "so_22471909_22472039_3": {"section_id": 6151, "quality": 0.9375, "length": 30}}, "n3337": {"so_22471909_22472039_6": {"section_id": 5913, "quality": 1.0, "length": 4}, "so_22471909_22472039_2": {"section_id": 5913, "quality": 1.0, "length": 20}, "so_22471909_22472039_4": {"section_id": 5913, "quality": 1.0, "length": 14}, "so_22471909_22472039_0": {"section_id": 5913, "quality": 1.0, "length": 13}, "so_22471909_22472039_1": {"section_id": 5913, "quality": 1.0, "length": 24}, "so_22471909_22472039_3": {"section_id": 5913, "quality": 1.0, "length": 32}, "so_22471909_22472039_5": {"section_id": 5913, "quality": 1.0, "length": 32}}, "n4659": {"so_22471909_22472039_0": {"section_id": 7709, "quality": 0.5384615384615384, "length": 7}, "so_22471909_22472039_4": {"section_id": 7648, "quality": 0.7857142857142857, "length": 11}, "so_22471909_22472039_3": {"section_id": 7648, "quality": 0.9375, "length": 30}}}});