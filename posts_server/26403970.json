post_cb({"26404028": {"Id": "26404028", "PostTypeId": "2", "Body": "<p>In C++, the expressions inside <code>sizeof</code> is <em>not</em> evaluated, <strike>except for C99's <a href=\"http://en.wikipedia.org/wiki/Variable-length_array\" rel=\"nofollow noreferrer\">VLA</a> <sup> as mentioned in comments, since this was earlier tagged for C too </sup></strike></p>\n<p>The <code>sizeof</code> operator is calculated at compile time. </p>\n<p>Only the <em>type</em> of the expression (that is calculated at compile time) is then used by <code>sizeof</code>.</p>\n<p>From <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">C++ Standard</a> <strong>\u00a7 5.3.3 Sizeof</strong></p>\n<blockquote>\n<p id=\"so_26403970_26404028_0\">The sizeof operator yields the number of bytes in the object\n  representation of its operand. The operand is either an expression,\n  which is an <em>unevaluated</em> operand (Clause 5), or a parenthesized\n  type-id.</p>\n</blockquote>\n<p><sup>Some C++ compilers provide VLAs as an extension <a href=\"https://stackoverflow.com/questions/26403970/increment-operator-is-not-invoked-at-sizeofn-expression-in-c/26404028#comment41479677_26404028\">as commented below</a>.</sup></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-10-17T03:42:53.190", "Score": "35", "CreationDate": "2014-10-16T12:08:31.567", "ParentId": "26403970", "CommentCount": "10", "OwnerUserId": "1870232", "LastEditDate": "2017-05-23T12:29:43.390"}, "bq_ids": {"n4140": {"so_26403970_26404092_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 6076}, "so_26403970_26404028_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 6076}}, "n3337": {"so_26403970_26404092_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 5844}, "so_26403970_26404028_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 5844}}, "n4659": {"so_26403970_26404092_1": {"length": 14, "quality": 0.8235294117647058, "section_id": 7572}, "so_26403970_26404028_0": {"length": 17, "quality": 0.8947368421052632, "section_id": 7572}}}, "26403970": {"ViewCount": "1802", "Body": "<p>In C or C++, increment and decrement operator (<code>++n</code>, <code>--n</code>) are not performed when it is in a <code>sizeof()</code> operator.</p>\n<pre><code>int n = 100;\nint size_int = sizeof(++n);\nstd::cout&lt;&lt;n;\n</code></pre>\n<p>I have written this code and run the program. Of course, I think 101 will be showed for me.\nBut, <code>n</code> was not 101, it was 100.</p>\n<p>Why is that?</p>\n", "AcceptedAnswerId": "26404028", "Title": "Increment operator is not invoked at sizeof(++n) expression", "CreationDate": "2014-10-16T12:06:23.463", "Id": "26403970", "CommentCount": "17", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-01-12T19:10:20.157", "LastEditorUserId": "4082723", "LastActivityDate": "2015-01-12T19:10:20.157", "Score": "31", "OwnerUserId": "3363101", "Tags": "<c++><c><increment><sizeof>", "AnswerCount": "4"}, "26404092": {"Id": "26404092", "PostTypeId": "2", "Body": "<p>In C++ <code>sizeof</code> doesn't evaluate its operand.</p>\n<p>Quote from C++ standard, part <code>[expr] 5/7</code> in C++11 or <code>[expr] 5/8</code> in C++14:</p>\n<blockquote>\n<p id=\"so_26403970_26404092_0\">In some contexts, unevaluated operands appear (<code>5.2.8</code>, <code>5.3.3</code>, <code>5.3.7</code>, <code>7.1.6.2</code>). An unevaluated operand is not evaluated.</p>\n</blockquote>\n<p>Here <code>5.3.3</code> refers to <code>sizeof</code> (and others are <code>typeid</code>, <code>noexcept</code> and <code>decltype</code>).</p>\n<p>C++98 standard doesn't have this paragraph, but anyway in its part <code>5.3.3 Sizeof</code> it states essentially the same as newer standards:</p>\n<blockquote>\n<p id=\"so_26403970_26404092_1\">The <code>sizeof</code> operator yields the number of bytes in the object representation of its operand. The operand is either an expression, which is not evaluated, or a parenthesized <em>type-id</em>.</p>\n</blockquote>\n", "LastEditorUserId": "3959454", "LastActivityDate": "2014-10-16T12:57:41.130", "Score": "12", "CreationDate": "2014-10-16T12:11:42.743", "ParentId": "26403970", "CommentCount": "2", "OwnerUserId": "3959454", "LastEditDate": "2014-10-16T12:57:41.130"}, "26404215": {"Id": "26404215", "PostTypeId": "2", "Body": "<p>If you check out the dis-assembly of:</p>\n<pre><code>int size_int = sizeof(++n);\n</code></pre>\n<p>Then you'll see something like (depending on your compiler):</p>\n<pre><code>mov dword ptr [size_int],4\n</code></pre>\n<hr>\n<p>The <code>sizeof(...)</code> expression is evaluated during compile-time, and replaced with a constant value.</p>\n<p>In the example above, the constant value that the <code>sizeof(...)</code> expression is replaced with is 4.</p>\n</hr>", "LastActivityDate": "2014-10-16T12:17:24.680", "CommentCount": "0", "CreationDate": "2014-10-16T12:17:24.680", "ParentId": "26403970", "Score": "11", "OwnerUserId": "1382251"}, "26404083": {"Id": "26404083", "PostTypeId": "2", "Body": "<p>In C the operand of <code>sizeof</code> is not evaluated at except for variable length arrays:</p>\n<blockquote>\n<p id=\"so_26403970_26404083_0\">6.5.3.4. p2:</p>\n<p id=\"so_26403970_26404083_1\">The sizeof operator yields the size (in bytes) of its operand, which may be an\n  expression or the parenthesized name of a type. The size is determined from the type of\n  the operand. The result is an integer. <em>If the type of the operand is a variable length array\n  type, the operand is evaluated; otherwise, the operand is not evaluated and the result is an\n  integer constant</em></p>\n</blockquote>\n<p>If you put <code>n++</code> into a variable length array, for example:</p>\n<pre><code>int n = 1 ; \nsizeof( int(*)[n++] ) ;\n</code></pre>\n<p>then it is unspecified if the operand is evaluated.</p>\n<blockquote>\n<p id=\"so_26403970_26404083_2\">6.7.6.2. p5</p>\n<p id=\"so_26403970_26404083_3\">If the size is an expression that is not an integer constant expression: if it occurs in a\n  declaration at function prototype scope, it is treated as if it were replaced by *; otherwise,\n  each time it is evaluated it shall have a value greater than zero. The size of each instance\n  of a variable length array type does not change during its lifetime. <em>Where a size\n  expression is part of the operand of a sizeof operator and changing the value of the\n  size expression would not affect the result of the operator, it is unspecified whether or not\n  the size expression is evaluated</em>.</p>\n</blockquote>\n", "LastEditorUserId": "4082723", "LastActivityDate": "2014-10-16T15:05:59.890", "Score": "16", "CreationDate": "2014-10-16T12:11:18.617", "ParentId": "26403970", "CommentCount": "4", "OwnerUserId": "4082723", "LastEditDate": "2014-10-16T15:05:59.890"}});