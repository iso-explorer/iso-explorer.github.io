post_cb({"bq_ids": {"n4140": {"so_17598699_17599026_0": {"length": 27, "quality": 0.8709677419354839, "section_id": 175}}, "n3337": {"so_17598699_17599026_0": {"length": 31, "quality": 1.0, "section_id": 169}}, "n4659": {"so_17598699_17599026_0": {"length": 19, "quality": 0.6129032258064516, "section_id": 180}}}, "17598699": {"ViewCount": "513", "Body": "<pre><code>struct B\n{\n    int a;\n    void foo() {a = 5;}\n};\n\ntemplate &lt;typename T&gt;\nstruct A\n{\n    A(int i) { B::foo(); }\n    A(double d) {}\n};\n\nint main()\n{\n    A&lt;int&gt; a(5.0);\n}\n</code></pre>\n<p>gcc 4.7.2 compiles it without errors.\nclang 3.4svn complains:</p>\n<pre><code>$ clang -Wall -Wextra test.cpp \ntest.cpp:10:16: error: call to non-static member function without an object argument\n        A(int i) { B::foo(); }\n                   ~~~^~~\n</code></pre>\n<p>Of course the code is wrong, but which compiler is conformant with the standard?</p>\n<p>It's also strange that clang doesn't print any 'in instantiation' note like gcc does if you use 5 instead of 5.0:</p>\n<pre><code>$ gcc test.cpp \ntest.cpp: In instantiation of \u2018A&lt;T&gt;::A(int) [with T = int]\u2019:\ntest.cpp:15:12:   required from here\ntest.cpp:9:13: error: cannot call member function \u2018void B::foo()\u2019 without object\n</code></pre>\n", "AcceptedAnswerId": "17599026", "Title": "error in unused template method", "CreationDate": "2013-07-11T16:26:13.757", "Id": "17598699", "CommentCount": "6", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-07-11T16:54:28.883", "LastEditorUserId": "594456", "LastActivityDate": "2013-07-11T16:54:28.883", "Score": "4", "OwnerUserId": "594456", "Tags": "<c++><templates><gcc><clang><non-static>", "AnswerCount": "1"}, "17599026": {"Id": "17599026", "PostTypeId": "2", "Body": "<p>Your program is incorrect, and both compilers are right as the standard does not require a diagnostic from a conforming compiler (letting gcc ignore it). A template for which there can be no valid instantiation (specialization in standard jargon) is incorrect even if that template is never instantiated.</p>\n<p>In your case, the name <code>B::foo()</code> inside <code>A&lt;T&gt;::A(int)</code> is a non-dependent name, so it needs to be resolved during the first phase lookup, and it can only refer to the <code>B</code> class defined above. Because it is not a <code>static</code> member function, but a non-static one, the code is incorrect, regardless of the type <code>T</code> used to instantiate the <code>A&lt;T&gt;</code> template and the program is ill-formed.</p>\n<p>The relevant quote is from 14.6 [temp.res]/8:</p>\n<blockquote>\n<p id=\"so_17598699_17599026_0\">Knowing which names are type names allows the syntax of every template definition to be checked. No diagnostic shall be issued for a template definition for which a valid specialization can be generated. <strong>If no valid specialization can be generated for a template definition, and that template is not instantiated, the template definition is ill-formed, no diagnostic required.</strong></p>\n</blockquote>\n", "LastActivityDate": "2013-07-11T16:44:26.427", "CommentCount": "12", "CreationDate": "2013-07-11T16:44:26.427", "ParentId": "17598699", "Score": "5", "OwnerUserId": "36565"}});