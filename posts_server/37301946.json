post_cb({"bq_ids": {"n4140": {"so_37301946_37303140_0": {"length": 18, "quality": 0.6666666666666666, "section_id": 7116}, "so_37301946_37303140_4": {"length": 14, "quality": 1.0, "section_id": 7090}, "so_37301946_37303140_6": {"length": 17, "quality": 1.0, "section_id": 5514}, "so_37301946_37303140_2": {"length": 29, "quality": 0.8529411764705882, "section_id": 7118}, "so_37301946_37303140_5": {"length": 23, "quality": 0.8518518518518519, "section_id": 7088}, "so_37301946_37303140_3": {"length": 52, "quality": 0.9454545454545454, "section_id": 7067}, "so_37301946_37303140_1": {"length": 25, "quality": 0.7352941176470589, "section_id": 7117}}, "n3337": {"so_37301946_37303140_0": {"length": 18, "quality": 0.6666666666666666, "section_id": 6860}, "so_37301946_37303140_4": {"length": 14, "quality": 1.0, "section_id": 6834}, "so_37301946_37303140_6": {"length": 17, "quality": 1.0, "section_id": 5300}, "so_37301946_37303140_2": {"length": 29, "quality": 0.8529411764705882, "section_id": 6862}, "so_37301946_37303140_5": {"length": 23, "quality": 0.8518518518518519, "section_id": 6832}, "so_37301946_37303140_3": {"length": 52, "quality": 0.9454545454545454, "section_id": 6811}, "so_37301946_37303140_1": {"length": 25, "quality": 0.7352941176470589, "section_id": 6861}}, "n4659": {"so_37301946_37303140_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 8617}, "so_37301946_37303140_4": {"length": 14, "quality": 1.0, "section_id": 8591}, "so_37301946_37303140_6": {"length": 17, "quality": 1.0, "section_id": 6949}, "so_37301946_37303140_2": {"length": 29, "quality": 0.8529411764705882, "section_id": 8619}, "so_37301946_37303140_5": {"length": 23, "quality": 0.8518518518518519, "section_id": 8589}, "so_37301946_37303140_3": {"length": 52, "quality": 0.9454545454545454, "section_id": 8564}, "so_37301946_37303140_1": {"length": 25, "quality": 0.7352941176470589, "section_id": 8618}}}, "37301946": {"ViewCount": "157", "Body": "<p>Consider the following code:</p>\n<pre><code>namespace foo {\n  namespace bar {\n    class foo {};\n  }\n  class baz {};\n}\nusing namespace foo::bar;\n\n::foo::baz mybaz;\n</code></pre>\n<p>Is this code valid?\nOr is <code>::foo</code> ambiguous?\nOr does <code>::foo</code> refer to the <code>class foo</code>, such that there is no <code>::foo::baz</code>.</p>\n<p>When it comes to compilers, <code>gcc 6.1.1</code> seems to think the latter:</p>\n<pre><code>scope.cpp:9:8: error: \u2018baz\u2019 in \u2018class foo::bar::foo\u2019 does not name a type\n ::foo::baz mybaz;\n        ^~~\n</code></pre>\n<p>On the other hand <code>gcc 5.3.1</code>, <code>clang 3.8.0</code>, and the intel compiler 16.0.3 do not yield any warnings or errors.</p>\n<p>I suspect that under 3.4.3.2.2 of the C++14 standard, this should be valid and not ambiguous, but I am not quite sure.</p>\n<p>Edit: In addition, for <code>foo::baz mybaz</code> only clang reports an ambiguous error.</p>\n", "AcceptedAnswerId": "37303140", "Title": "Global scope resolution in the presence of using namespace", "CreationDate": "2016-05-18T14:03:02.100", "Id": "37301946", "CommentCount": "2", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2016-05-18T15:19:06.447", "LastEditorUserId": "620382", "LastActivityDate": "2016-05-19T04:23:33.863", "Score": "13", "OwnerUserId": "620382", "Tags": "<c++><language-lawyer><c++14><gcc6>", "AnswerCount": "1"}, "37303140": {"Id": "37303140", "PostTypeId": "2", "Body": "<p>[namespace.qual] is fairly straightforward:</p>\n<blockquote>\n<p id=\"so_37301946_37303140_0\">1 If the <em>nested-name-specifier</em> of a <em>qualified-id</em> nominates a namespace (including the case where the <em>nested-name-specifier</em> is <code>::</code>, i.e., nominating the global namespace), the name specified after the <em>nested-name-specifier</em> is looked up in the scope of the namespace. The names in a <em>template-argument</em> of a <em>template-id</em> are looked up in the context in which the entire <em>postfix-expression</em> occurs.</p>\n<p id=\"so_37301946_37303140_1\">2 For a namespace <code>X</code> and name <code>m</code>, the namespace-qualified lookup set S(<code>X</code>,<code>m</code>) is defined as follows: Let S<sub>0</sub>(<code>X</code>,<code>m</code>) be the set of all declarations of <code>m</code> in <code>X</code> and the inline namespace set of <code>X</code> (7.3.1). If S<sub>0</sub>(<code>X</code>,<code>m</code>) is not empty, S(<code>X</code>,<code>m</code>) is S<sub>0</sub>(<code>X</code>,<code>m</code>); otherwise, S(<code>X</code>,<code>m</code>) is the union of S(N<sub>i</sub>,<code>m</code>) for all namespaces N<sub>i</sub> nominated by <em>using-directives</em> in <code>X</code> and its inline namespace set.</p>\n<p id=\"so_37301946_37303140_2\">3 Given <code>X::m</code> (where <code>X</code> is a user-declared namespace), or given <code>::m</code> (where <code>X</code> is the global namespace), if S(<code>X</code>,<code>m</code>) is the empty set, the program is ill-formed. Otherwise, if S(<code>X</code>,<code>m</code>) has exactly one member, or if the context of the reference is a <em>using-declaration</em> (7.3.3), S(<code>X</code>,<code>m</code>) is the required set of declarations of <code>m</code>. Otherwise if the use of <code>m</code> is not one that allows a unique declaration to be chosen from S(<code>X</code>,<code>m</code>), the program is ill-formed.</p>\n</blockquote>\n<p><code>::foo</code> is a <em>qualified-id</em> with <em>nested-name-specifier</em> <code>::</code>, so the name <code>foo</code> is looked up in global scope.</p>\n<p>S<sub>0</sub>(<code>::</code>,<code>foo</code>) contains the single declaration for <code>namespace foo</code> since there are no other declarations of <code>foo</code> in the namespace, and it has no inline namespaces. Since S<sub>0</sub>(<code>::</code>,<code>foo</code>) is not empty, S(<code>::</code>,<code>foo</code>) is S<sub>0</sub>(<code>::</code>,<code>foo</code>). (Note that since S<sub>0</sub>(<code>::</code>,<code>foo</code>) is not empty, namespaces nominated by using directives are never examined.)</p>\n<p>Since S(<code>::</code>,<code>foo</code>) has exactly one element, that declaration is used for <code>::foo</code>.</p>\n<p>The name <code>::foo::baz</code> is therefore a <em>qualified-id</em> with <em>nested-name-specifier</em> <code>::foo</code> that nominates a namespace. There is again a single declaration of <code>baz</code> in namespace <code>::foo</code>, so the name <code>::foo::baz</code> refers to the <code>class baz</code> declaration.</p>\n<p>The behavior you observe in GCC 6+ is in fact a bug, filed as <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=71173\" rel=\"nofollow\">GCC PR 71173</a>.</p>\n<p>EDIT: Lookup of <code>foo::baz</code> when it appears at global scope, a la:</p>\n<pre><code>foo::baz bang;\n</code></pre>\n<p>first requires a lookup of <code>foo</code> as an unqualified name. [basic.lookup.qual]/1 says this lookup only sees \"namespaces, types, and templates whose specializations are types.\" [basic.scope.namespace]/1 tells us about namespace members and their scopes:</p>\n<blockquote>\n<p id=\"so_37301946_37303140_3\">The declarative region of a <em>namespace-definition</em> is its <em>namespace-body</em>. Entities declared in a <em>namespace-body</em> are said to be members of the namespace, and names introduced by these declarations into the declarative region of the namespace are said to be member names of the namespace. A namespace member name has namespace scope. Its potential scope includes its namespace from the name\u2019s point of declaration onwards; and for each <em>using-directive</em> that nominates the member\u2019s namespace, the member\u2019s potential scope includes that portion of the potential scope of the <em>using-directive</em> that follows the member\u2019s point of declaration.</p>\n</blockquote>\n<p>[basic.lookup.unqual]/4 tells us that the declaration of <code>namespace foo</code> is visible:</p>\n<blockquote>\n<p id=\"so_37301946_37303140_4\">A name used in global scope, outside of any function, class or user-declared namespace, shall be declared before its use in global scope.</p>\n</blockquote>\n<p>and para 2 says that <code>class foo</code> is also visible here:</p>\n<blockquote>\n<p id=\"so_37301946_37303140_5\">The declarations from the namespace nominated by a <em>using-directive</em> become visible in a namespace enclosing the <em>using-directive</em>; see 7.3.4. For the purpose of the unqualified name lookup rules described in 3.4.1, the declarations from the namespace nominated by the <em>using-directive</em> are considered members of that enclosing namespace.</p>\n</blockquote>\n<p>Since two declarations of different <code>foo</code> entities from differing namespaces are found, [namespace.udir]/6 tells us the use of <code>foo</code> is ill-formed:</p>\n<blockquote>\n<p id=\"so_37301946_37303140_6\">If name lookup finds a declaration for a name in two different namespaces, and the declarations do not declare the same entity and do not declare functions, the use of the name is ill-formed.</p>\n</blockquote>\n<p>Our name lookup for <code>foo::baz</code> dies before ever getting to <code>baz</code>.</p>\n", "LastEditorUserId": "923854", "LastActivityDate": "2016-05-19T04:23:33.863", "Score": "9", "CreationDate": "2016-05-18T14:50:27.003", "ParentId": "37301946", "CommentCount": "4", "OwnerUserId": "923854", "LastEditDate": "2016-05-19T04:23:33.863"}});