post_cb({"16888145": {"CommentCount": "10", "AcceptedAnswerId": "16888979", "PostTypeId": "1", "LastEditorUserId": "1829943", "CreationDate": "2013-06-02T23:06:34.133", "LastActivityDate": "2013-06-03T01:34:39.910", "LastEditDate": "2013-06-02T23:24:00.540", "ViewCount": "98", "FavoriteCount": "0", "Title": "default behaviour for std::streams with unsigned", "Id": "16888145", "Score": "-2", "Body": "<p>I think that when using \"&gt;&gt;\" \"&lt;&lt;\" stream operators, unsigned integer types are serialized/deserialized as binary data, while signed integer types are serialized as formatted text.</p>\n<p>My assumption is:</p>\n<pre><code>uint32_t a= 17;\nint b= 54321;\nfile_out&lt;&lt;a;   //write 0x00000011 to the file according to some endiannes\nfile_out&lt;&lt;b;   //write following ASCII characters '5''4''3''2''1' to the file.\n</code></pre>\n<p>Is my assumption explicitly stated in some standard? If yes, wich one of the following is faster?</p>\n<pre><code>file_out&lt;&lt;a;\n</code></pre>\n<p>or</p>\n<pre><code>file_out.write((char*)&amp;a,sizeof(uint32_t);\n</code></pre>\n<p>compiler and libraries MinGW.</p>\n<p>In particular is a bit strange that the same stream type offers different behaviours depending on input types.</p>\n", "Tags": "<c++><serialization><stream>", "OwnerUserId": "1829943", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_16888145_16888979_5": {"section_id": 1938, "quality": 1.0, "length": 17}, "so_16888145_16888979_1": {"section_id": 2290, "quality": 0.8, "length": 8}, "so_16888145_16888979_4": {"section_id": 6549, "quality": 0.9166666666666666, "length": 33}, "so_16888145_16888979_2": {"section_id": 6549, "quality": 0.8125, "length": 13}}, "n3337": {"so_16888145_16888979_5": {"section_id": 1927, "quality": 1.0, "length": 17}, "so_16888145_16888979_1": {"section_id": 2277, "quality": 0.8, "length": 8}, "so_16888145_16888979_4": {"section_id": 6304, "quality": 0.9166666666666666, "length": 33}, "so_16888145_16888979_2": {"section_id": 6304, "quality": 0.8125, "length": 13}}, "n4659": {"so_16888145_16888979_5": {"section_id": 2209, "quality": 1.0, "length": 17}, "so_16888145_16888979_1": {"section_id": 2563, "quality": 0.8, "length": 8}, "so_16888145_16888979_4": {"section_id": 8031, "quality": 0.9166666666666666, "length": 33}, "so_16888145_16888979_2": {"section_id": 8031, "quality": 0.8125, "length": 13}}}, "16888979": {"ParentId": "16888145", "CommentCount": "0", "Body": "<p>Either your copy of the C++ Standard Library is <strong>broken</strong> or <strong>you</strong> are doing something that you have failed to tell us about. To be brief the default expected behavior is to output integral values in decimal format regardless of the types sign. The types sign is only taken into account to ensure that an unsigned value is not formatted as a signed value when the output format is set to decimal.</p>\n<p>That said let's take a trip into Standard Land...</p>\n<p>The key piece of information that you are interested in is how formatting is applied to unsigned integers. I'm going to try and highlight the important sections of the Standard that apply to output formatting (in regard to <em>your</em> question) and how integers are handled. Start by looking at how <code>operator&lt;&lt;</code> works when dealing with integer types. That is defined in $27.7.3.6.2.</p>\n<p>From $27.7.3.6.2/1 - Arithmetic inserters <strong>[ostream.inserters.arithmetic]</strong></p>\n<blockquote>\n<p id=\"so_16888145_16888979_0\">operator&lt;&lt;(bool val);<br>\n  operator&lt;&lt;(short val);<br>\n  operator&lt;&lt;(unsigned short val);<br>\n  operator&lt;&lt;(int val);<br>\n  operator&lt;&lt;(unsigned int val);<br>\n  operator&lt;&lt;(long val);<br>\n  operator&lt;&lt;(unsigned long val);<br>\n  operator&lt;&lt;(long long val);<br>\n  operator&lt;&lt;(unsigned long long val);<br>\n  operator&lt;&lt;(float val);<br>\n  operator&lt;&lt;(double val);<br>\n  operator&lt;&lt;(long double val);<br>\n  operator&lt;&lt;(const void* val);  </br></br></br></br></br></br></br></br></br></br></br></br></p>\n<p id=\"so_16888145_16888979_1\">1 Effects: The classes num_get&lt;&gt; and num_put&lt;&gt; handle locale-dependent numeric formatting and parsing.</p>\n</blockquote>\n<p><code>num_put</code> is actually responsible for handling the formatting of integer values.</p>\n<p>From $22.4.2.2.2/5 num_put virtual functions [facet.num.put.virtuals]</p>\n<blockquote>\n<p id=\"so_16888145_16888979_2\">Stage 1: The first action of stage 1 is to <strong>determine a conversion specifier</strong>. The tables that describe this determination use the following local variables</p>\n<p id=\"so_16888145_16888979_3\">fmtflags flags = str.flags() ;<br>\n  fmtflags basefield = (flags &amp; (ios_base::basefield));<br>\n  fmtflags uppercase = (flags &amp; (ios_base::uppercase));<br>\n  fmtflags floatfield = (flags &amp; (ios_base::floatfield));<br>\n  fmtflags showpos = (flags &amp; (ios_base::showpos));<br>\n  fmtflags showbase = (flags &amp; (ios_base::showbase));  </br></br></br></br></br></p>\n<p id=\"so_16888145_16888979_4\">All tables used in describing stage 1 are ordered. That is, the first line whose condition is true applies. A line without a condition is the default behavior when none of the earlier lines apply. For conversion from an integral type other than a character type, the function determines the integral conversion specifier as indicated in Table 87.</p>\n<pre><code>          Table 87 \u2014 Integer conversions  \nState                                stdio equivalent\nbasefield == ios_base::oct           %o  \n(basefield == ios_base::hex) &amp;&amp; !uppercase %x  \n(basefield == ios_base::hex)         %X  \nfor a signed integral type           %d  \nfor an unsigned integral type        %u  \n</code></pre>\n</blockquote>\n<p>There are two key pieces of information in the above except. The <code>basefield</code> which indicates the numerical formatting and that the determination is <em>ordered</em>. The <code>basefield</code> is important because it determines whether the value is output as hex, decimal, octal, etc. Streams are required to format integral values based on the format flags. Note that in order for the value to be formatted in hex the <code>ios_base::hex</code> flag <strong>must</strong> be set.</p>\n<p>The format flags originate from <code>ios_base</code>.</p>\n<p>From $27.5.3/2 Class ios_base [ios.base]</p>\n<blockquote id=\"so_16888145_16888979_5\">\n<ol>\n<li>It maintains several kinds of data:<br>\n  \u2014 control information that influences how to interpret (format) input sequences and how to generate (format) output sequences;</br></li>\n</ol>\n</blockquote>\n<p>Another important aspect that needs to be taken into account is what the <em>default flag values</em> are when a stream is initialized. These are listed in a different table. Specifically table 128 which describes the effect calling <code>basic_ios::init()</code> has on a stream. For reference <code>std::basic_ios</code> inherits from <code>std::ios_base</code>. <code>std::basic_ios</code> is a base class of <code>std::basic_ostream</code> which is used to provide the specialized stream <code>std::ostream</code>, among others.</p>\n<p>From $27.5.5.3 Table 128 - basic_ios::init() effects</p>\n<pre><code>Elements    Flags  \n-----------------------------\nflags()     skipws | dec\n</code></pre>\n<p>This means that after <code>init()</code> has been called a call to <code>flags()</code> should always return a value the same as <code>(skipws | dec)</code>.</p>\n<p>Put this all together and it means a freshly initialized stream is required to format integer values in decimal <strong>regardless of the types sign</strong>.</p>\n<p>[The key pieces appear to be identical between C++03 and C++11]</p>\n", "OwnerUserId": "845568", "PostTypeId": "2", "Id": "16888979", "Score": "2", "CreationDate": "2013-06-03T01:34:39.910", "LastActivityDate": "2013-06-03T01:34:39.910"}});