post_cb({"37933627": {"ParentId": "37933470", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Standard, section <a href=\"http://eel.is/c++draft/basic.def.odr#6\" rel=\"nofollow\">[basic.def.odr]</a>:</p>\n<blockquote>\n<ol start=\"6\">\n<li><p id=\"so_37933470_37933627_0\">There can be more than one definition of a class type <em>[snip]</em> in a program provided that each definition appears in a different translation unit, and provided the definitions satisfy the following requirements. Given such an entity named D defined in more than one translation unit, then</p>\n<p id=\"so_37933470_37933627_1\">\u2014 each definition of D shall consist of the same sequence of tokens; and</p></li>\n</ol>\n</blockquote>\n<p>Your program violates this rule, because the two definitions of the class do not consist of the same sequence of tokens. Violating the one-definition rule makes the program ill-formed.</p>\n<blockquote id=\"so_37933470_37933627_2\">\n<ol>\n<li>Why does it work?</li>\n</ol>\n</blockquote>\n<p>Being ill-formed, the standard doesn't specify, how this situation should be handled. The tool chain is free to refuse to link the program, but it is allowed to link successfully. Your linker happens to do the latter. Another linker might do the former.</p>\n<blockquote>\n<p id=\"so_37933470_37933627_3\">Linker doesn't consider private and public declarations?</p>\n</blockquote>\n<p>As you have observed through your experiment, your linker appears to not consider access specifiers. A linker doesn't need to consider them. They are purely a compile time concept.</p>\n<blockquote>\n<p id=\"so_37933470_37933627_4\">Is this behavior useful in practice? If yes, how is it used?</p>\n</blockquote>\n<p>Relying on this is <a href=\"https://isocpp.org/wiki/faq/big-picture#defn-evil\" rel=\"nofollow\"><em>evil</em></a> and non-portable. That said, it can sometimes be seen in the wild as a dirty hack to work around API limitations when the source is not available for recompilation.</p>\n", "OwnerUserId": "2079303", "LastEditorUserId": "2079303", "LastEditDate": "2016-06-21T00:30:20.337", "Id": "37933627", "Score": "3", "CreationDate": "2016-06-21T00:01:33.160", "LastActivityDate": "2016-06-21T00:30:20.337"}, "bq_ids": {"n4140": {"so_37933470_37933627_1": {"section_id": 7043, "quality": 1.0, "length": 6}, "so_37933470_37933627_0": {"section_id": 7043, "quality": 0.96875, "length": 31}}, "n3337": {"so_37933470_37933627_1": {"section_id": 6788, "quality": 1.0, "length": 6}, "so_37933470_37933627_0": {"section_id": 6788, "quality": 0.96875, "length": 31}}, "n4659": {"so_37933470_37933627_1": {"section_id": 8540, "quality": 1.0, "length": 6}, "so_37933470_37933627_0": {"section_id": 8540, "quality": 0.96875, "length": 31}}}, "37933544": {"ParentId": "37933470", "CommentCount": "0", "Body": "<p>The linker only resolves symbols.  Each C++ file is compiled independently, with whatever declarations are brought in via #include statements, to build up symbols (in a .o file), then the linker just works on the compiler output.  C++ access modifiers such as private, protected, and public affect only the compiler, not the linker.  (Technically, the linker isn't even aware of classes, it just deals with decorated/mangled symbol names for class members.)  It's possible, though not recommended, to modify declarations of classes to change the access of members, to in effect \"un-hide\" them.</p>\n", "OwnerUserId": "3207828", "PostTypeId": "2", "Id": "37933544", "Score": "1", "CreationDate": "2016-06-20T23:50:11.270", "LastActivityDate": "2016-06-20T23:50:11.270"}, "37933745": {"ParentId": "37933470", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>First off, since you're violating the \"One Definition Rule\" (C++11 3.2/5 \"One definition rule\" says that separate class definitions in different translations units must \"consist of the same sequence of tokens\"), anything goes as far as the toolchain is concerned.  it could diagnose an error, or produce a program that appears to work (as in your test).</p>\n<p>A simple reason why your experiment produces the results that you see is that the access to a class member is 'enforced' by the compiler, and you have told the compiler that the the access to member <code>Foo::print()</code> is public.  </p>\n<p>It is conforming for the toolchain to encode the access for a member in the name mangle that is performed for other reasons (such as overloading).  However, since the standard doesn't require that the toolchain enforce it, it seems that implementers decided that they didn't need to account for access control at link time. In other words, I think that it would be feasible to encode access control into the external symbol that the linker uses, but that work wasn't done; probably because it's not necessary strictly speaking.</p>\n<p>Note that Microsoft C++ does incorporate the access to a member in the external name, so you do get a link time error:</p>\n<pre><code>testmain.obj : error LNK2019: unresolved external symbol \"public: void __thiscall Foo::print(void)const \" (?print@Foo@@QBEXXZ) referenced in function _main testmain.exe : fatal error LNK1120: 1 unresolved externals\n</code></pre>\n<p>Here are the symbols g++ produces (along with a <code>c++filt</code> decode):</p>\n<pre><code>D:\\so-test&gt;nm test.o | grep Foo\n000000000000008c t _GLOBAL__sub_I__ZNK3Foo5printEv\n0000000000000000 T _ZNK3Foo5printEv\n\nD:\\so-test&gt;nm testmain.o | grep Foo\n                 U _ZNK3Foo5printEv\n\nD:\\so-test&gt;c++filt _ZNK3Foo5printEv\nFoo::print() const\n</code></pre>\n<p>And here are the symbols MS C++ produces (along with a decode):</p>\n<pre><code>D:\\so-test&gt;dumpbin /symbols test.obj | grep Foo\n22D 00000000 SECTBA notype ()    External     | ?print@Foo@@ABEXXZ (private: void __thiscall Foo::print(void)const )\n\nD:\\so-test&gt;dumpbin /symbols testmain.obj | grep Foo\n009 00000000 UNDEF  notype ()    External     | ?print@Foo@@QBEXXZ (public: void __thiscall Foo::print(void)const )\n</code></pre>\n", "OwnerUserId": "12711", "LastEditorUserId": "12711", "LastEditDate": "2016-06-21T00:19:33.853", "Id": "37933745", "Score": "4", "CreationDate": "2016-06-21T00:14:22.437", "LastActivityDate": "2016-06-21T00:19:33.853"}, "37933470": {"CommentCount": "1", "ViewCount": "78", "PostTypeId": "1", "LastEditorUserId": "2405850", "CreationDate": "2016-06-20T23:43:23.260", "LastActivityDate": "2016-06-21T14:29:22.817", "Title": "Why doesn't linker preserve encapsulation?", "AcceptedAnswerId": "37933745", "LastEditDate": "2016-06-21T14:29:22.817", "Id": "37933470", "Score": "2", "Body": "<p>Lets assume the following header foo.h:</p>\n<pre><code>class Foo {\n  private:\n    void print() const;\n};\n</code></pre>\n<p>and following foo.cpp:</p>\n<pre><code>#include &lt;iostream&gt;\n\n#include \"foo.h\"\n\nvoid Foo::print() const {\n    std::cout &lt;&lt; \"Secret\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>another header foo1.h, that is the same as foo.h unless method print is declared public:</p>\n<pre><code>class Foo {\n  public:\n    void print() const;\n};\n</code></pre>\n<p>and this will be main.cpp, that just call print in foo1.h:</p>\n<pre><code>#include \"foo1.h\"\n\nint main() {\n    Foo f;\n    f.print();\n    return 0;\n}\n</code></pre>\n<p>What seems strange for me is that the following linking gonna work:</p>\n<pre><code>g++ foo.cpp -c -o foo.o\ng++ main.cpp -c -o main.o\ng++ main.o foo.o -o exec\n./exec\n</code></pre>\n<p>The last command will output:</p>\n<pre><code>Secret\n</code></pre>\n<p>So without knowing the concrete implementation of class Foo but, knowing its declaration and having its object file, we can create situation when its methods can be used even though they are declared private.</p>\n<p>My questions are:</p>\n<ol>\n<li><p>Why does it work? Linker doesn't consider private and public declarations?</p></li>\n<li><p>Is this behavior useful in practice? If yes, how is it used? My guess that it could be useful for testing.</p></li>\n</ol>\n", "Tags": "<c++><linker><header-files><encapsulation>", "OwnerUserId": "2405850", "AnswerCount": "3"}});