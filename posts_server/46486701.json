post_cb({"46486940": {"Id": "46486940", "PostTypeId": "2", "Body": "<p>I think that the compilter doesn't recognize Base is a class name, and recognizes it as you want to access a Base member.</p>\n<p>This also compiles:</p>\n<pre><code>class Base {};\nclass Kid : private Base {};\nBase instance;\nclass Grandkid : public Kid\n{\n    const class Base &amp;GetInstance  () const\n    { return instance; }\n};\n</code></pre>\n<p>The wrong use would be use something like this:</p>\n<pre><code>class Base {\npublic:\n    struct BaseStruct { int a; };\n};\nclass Kid : private Base {\npublic:\n    struct KidStruct { int a; };\n};\nBase instance;\nclass Grandkid : public Kid\n{\n    const class Base &amp;GetInstance  () const\n    { return instance; }\n\n    const Kid::KidStruct kidStruct;\n    const Base::BaseStruct baseStruct;\n};\n</code></pre>\n<p><code>kidStruct</code> has no error because inheritance is public, but <code>baseStruct</code> is inaccessible.</p>\n", "LastEditorUserId": "6537200", "LastActivityDate": "2017-09-29T11:10:57.177", "Score": "0", "CreationDate": "2017-09-29T10:30:47.920", "ParentId": "46486701", "CommentCount": "4", "OwnerUserId": "6537200", "LastEditDate": "2017-09-29T11:10:57.177"}, "46486701": {"ViewCount": "115", "Body": "<p>I have a simple question regarding inheriting from a class which privately inheriting of a base class, i.e. we have</p>\n<pre><code>class Base {};\nclass Heir: private Base {};\nclass HeirsHeir : public Heir {};\n</code></pre>\n<p>In understand that HeirsHeir cannot access anything of 'its' Base. In particular, it cannot have a method returning a 'Base &amp;' reference to itself. But why can't it return a reference to <em>another</em> Base object? So why does the following code not compile:</p>\n<pre><code>class Base {};\nclass Kid : private Base {};\nBase instance;\nclass Grandkid : public Kid\n{\n    const Base &amp;GetInstance  () const\n    { return instance; }\n};\n</code></pre>\n<p>At least my compiler (MinGW 5.3, i.e. gcc for Windows) gives</p>\n<pre><code>error 'class Base Base::Base' is inaccessible at {}; \nerror: within this context const Base &amp;getInstance () const\n</code></pre>\n<p>For my understanding this doesn't make sense as  I do not call the constructor of Base at this point, but return a reference (to a Base instance).</p>\n<p>Note that the error can be fixed by using</p>\n<pre><code>const ::Base &amp;GetInstance  () const\n{ return instance; }\n</code></pre>\n<p>which is surely linked to C++03 \u00a711.2/3 (see [<a href=\"https://stackoverflow.com/questions/3047511/c-private-inheritance-and-static-members-types][1]\">C++ private inheritance and static members/types</a>)</p>\n<blockquote>\n<p id=\"so_46486701_46486701_0\">Note: A member of a private base class might be inaccessible as an\n  inherited member name, but accessible directly.</p>\n</blockquote>\n<p>But I do not understand why this is necessary. Can somebody explain it?</p>\n<p>Thanks</p>\n<p>Chris</p>\n", "AcceptedAnswerId": "46487080", "Title": "Private inheritance, return reference to static member of base class", "CreationDate": "2017-09-29T10:14:54.677", "Id": "46486701", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-09-29T12:25:34.373", "LastEditorUserId": "4849573", "LastActivityDate": "2017-09-29T12:25:34.373", "Score": "4", "OwnerUserId": "8694852", "Tags": "<c++><private-inheritance>", "AnswerCount": "2"}, "46487080": {"Id": "46487080", "PostTypeId": "2", "Body": "<p>The name lookup finds the injected-class-name <code>Base</code> which is injected into <code>Base</code> (and thus inherited by <code>GrandKid</code>). This is correct, since the injected-class-name is in a closer scope than the namespace-scope name of the class. However, this injected-class-name is not accessible to <code>GrandKid</code> because it's private in <code>Kid</code>.</p>\n<p>In the compiler's error message, <code>Base::Base</code> doesn't refer to the constructor, but to the class name <code>Base</code> injected into <code>Base</code>. Note that when the context in which it is used forces the name to be interpreted as a type, you can actually use <code>Base::Base</code> legally, like in this valid, but <em>vile</em> code:</p>\n<pre><code>class Foo {};\n\nstd::vector&lt;Foo::Foo::Foo::Foo&gt; v;\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/a4646c24664d16a4\" rel=\"nofollow noreferrer\">[Live example]</a></p>\n<p>However, when the context in which <code>Base::Base</code> is used would allow referring to a function, it is taken to resolve to the constructor and not to the class name (C++11 [class.qual] 3.4.3.1/2)</p>\n", "LastEditorUserId": "1782465", "LastActivityDate": "2017-09-29T10:49:33.360", "Score": "2", "CreationDate": "2017-09-29T10:38:53.713", "ParentId": "46486701", "CommentCount": "5", "OwnerUserId": "1782465", "LastEditDate": "2017-09-29T10:49:33.360"}, "bq_ids": {"n4140": {"so_46486701_46486701_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 6680}}, "n3337": {"so_46486701_46486701_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 6435}}, "n4659": {"so_46486701_46486701_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 8155}}}});