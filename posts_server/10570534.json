post_cb({"10570550": {"ParentId": "10570534", "CommentCount": "3", "CreationDate": "2012-05-13T09:08:35.120", "OwnerUserId": "964135", "PostTypeId": "2", "Id": "10570550", "Score": "7", "Body": "<p><a href=\"http://en.cppreference.com/w/cpp/string/basic_string/operator_at\">cppreference says this:</a></p>\n<blockquote>\n<pre><code>reference       operator[]( size_type pos );\n\nconst_reference operator[]( size_type pos ) const;\n</code></pre>\n<p id=\"so_10570534_10570550_0\">If <code>pos==size()</code>,</p>\n<ul>\n<li>The const version returns a reference to the character with value CharT() (the null character). (until C++11)</li>\n<li>Both versions returns a reference to the character with value CharT() (the null character). Modifying the null character through non-const reference results in undefined behavior. (since C++11)</li>\n</ul>\n</blockquote>\n<p>So it is OK so long as you don't modify the null character.</p>\n", "LastActivityDate": "2012-05-13T09:08:35.120"}, "10570555": {"ParentId": "10570534", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-05-13T09:09:45.737", "Score": "0", "LastEditorUserId": "1016716", "LastEditDate": "2012-05-13T09:16:34.390", "Id": "10570555", "OwnerUserId": "1016716", "Body": "<p>If you want to do it like that (your collegue's code tries to copy the terminating <code>\\0</code> as well) you can</p>\n<ul>\n<li>use <code>c_str()</code>.</li>\n<li>use the loop with <code>i &lt; s.size()</code> and append the <code>\\0</code> manually afterwards.</li>\n</ul>\n<p>Edit:<br>\nWell, judging by the other answers, I'm more inclined to think now that Abyx's comment is correct: the array <code>d</code> may be overflowing (or it may not even be assigned). Check that first.<br>\nBut do make sure that you copy a <code>\\0</code> too!</br></br></p>\n", "LastActivityDate": "2012-05-13T09:16:34.390"}, "10570779": {"ParentId": "10570534", "CommentCount": "2", "CreationDate": "2012-05-13T09:46:19.117", "OwnerUserId": "12711", "PostTypeId": "2", "Id": "10570779", "Score": "10", "Body": "<p>Let's put aside the possiblity that <code>*d</code> is invalid since that has nothing to do with what the question seems directed at: whether or not <code>std::string operator[]()</code> has well defined behavior when accessing the \"element\" at index <code>std::string::size()</code>.</p>\n<p>The C++03 standard has the following description of <code>string::operator[]()</code> (21.3.4 \"<code>basic_string</code> element access\"):</p>\n<blockquote>\n<pre><code>const_reference operator[](size_type pos) const;\nreference operator[](size_type pos);\n</code></pre>\n<p id=\"so_10570534_10570779_0\">Returns: If <code>pos &lt; size()</code>, returns <code>data()[pos]</code>. Otherwise, if <code>pos\n  == size()</code>, the const version returns <code>charT()</code>.  Otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>Since <code>s</code> in the example code is <code>const</code>, the behavior is well defined and <code>s[s.size()]</code> will return a null character.  However, if <code>s</code> was not a <code>const string</code>, the behavior would be undefined.</p>\n<p>C++11 remedies this odd-ball behavior of the <code>const</code> version behaving so differently than the non-const version in this edge case.  C++11 21.4.5 \"<code>basic_string</code> element access\" says:</p>\n<blockquote>\n<pre><code>const_reference operator[](size_type pos) const;\nreference operator[](size_type pos);\n</code></pre>\n<p id=\"so_10570534_10570779_1\">Requires: <code>pos &lt;= size()</code>.</p>\n<p id=\"so_10570534_10570779_2\">Returns: <code>*(begin() + pos</code>) if <code>pos &lt; size()</code>, otherwise a reference\n  to an object of type T with value <code>charT()</code>; the referenced value\n  shall not be modified.</p>\n</blockquote>\n<p>So for a C++11 compiler, the behavior is well-defined whether or not the <code>string</code> is <code>const</code>.  </p>\n<p>Unrelated to the question, I find it a little strange that C++11 says that \"the referenced value shall not be modified\" - it's not clear to me if that clause applies only in the case where <code>pos == size()</code>.  I'm pretty sure there's a ton of existing code that does things like <code>s[i] = some_character;</code> where <code>s</code> is a non-const <code>std:string</code> and <code>i &lt; s.size()</code>.  Is that undefined behavior now? I suspect that that clause applies only to the special-case <code>charT()</code> object.</p>\n<p>Another interesting thing is that neither standard seems to require that the address of the object returned for <code>s[s.size()]</code> be in any way related to the address of the object returned for <code>s[s.size() - 1]</code>.  In other words, it seems like the returned <code>charT()</code> reference doesn't have to be contiguous to the end of the string data.  I suspect that this is to give implementers a choice to just return a reference to a single static copy of that sentinel element if desired (that would also explain C++11's \"shall not be modified\" restriction, assuming it applies only to the special case).</p>\n", "LastActivityDate": "2012-05-13T09:46:19.117"}, "bq_ids": {"n4140": {"so_10570534_10570779_2": {"section_id": 1617, "quality": 0.6428571428571429, "length": 9}}, "n3337": {"so_10570534_10570779_2": {"section_id": 1613, "quality": 0.6428571428571429, "length": 9}}, "n4659": {"so_10570534_10570779_2": {"section_id": 1770, "quality": 0.7142857142857143, "length": 10}}}, "10570534": {"CommentCount": "5", "ViewCount": "344", "CreationDate": "2012-05-13T09:05:18.353", "LastActivityDate": "2012-05-13T09:46:19.117", "Title": "string[length()] in C++, is it OK?", "AcceptedAnswerId": "10570779", "PostTypeId": "1", "Id": "10570534", "Score": "8", "Body": "<p>My colleague's code looked like this:</p>\n<pre><code>void copy(std::string const&amp; s, char *d) {\n  for(int i = 0; i &lt;= s.size(); i++, d++)\n    *d = s[i];\n}\n</code></pre>\n<p>His application crashes and I think that it is because this accesses <code>s</code> out of range, since the condition should go only up to <code>s.size() - 1</code>. </p>\n<p>But other guys next to me says there was a discussion in the past about this being legal. Can anyone please clear this up for me?</p>\n", "Tags": "<c++><string><c++11>", "OwnerUserId": "34509", "AnswerCount": "3"}});