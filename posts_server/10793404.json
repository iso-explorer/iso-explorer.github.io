post_cb({"10793474": {"ParentId": "10793404", "CommentCount": "1", "Body": "<p>All standard iterator and container types behave the same in this regard:</p>\n<p><code>\u00a723.2.1 [container.requirements.general] p6</code></p>\n<blockquote>\n<p id=\"so_10793404_10793474_0\"><code>begin()</code> returns an iterator referring to the first element in the container. <code>end()</code> returns an iterator which is the past-the-end value for the container. <strong>If the container is empty, then <code>begin() == end()</code>;</strong></p>\n</blockquote>\n<p>And table 107 in <code>\u00a724.2.3 [input.iterators]</code> demands that as a precondition for <code>++it</code>, <code>it</code> shall be dereferenceable, which is not the case for past-the-end iterators (i.e., what you get from <code>end()</code>), as such you're treading into the dreaded domain of undefined behaviour.</p>\n", "OwnerUserId": "500104", "PostTypeId": "2", "Id": "10793474", "Score": "16", "CreationDate": "2012-05-29T05:25:22.003", "LastActivityDate": "2012-05-29T05:25:22.003"}, "10793404": {"CommentCount": "1", "AcceptedAnswerId": "10793474", "PostTypeId": "1", "LastEditorUserId": "341065", "CreationDate": "2012-05-29T05:15:59.670", "LastActivityDate": "2012-05-29T05:27:23.290", "LastEditDate": "2012-05-29T05:22:08.393", "ViewCount": "9942", "FavoriteCount": "1", "Title": "Behaviour of std::list:begin() when list is empty", "Id": "10793404", "Score": "12", "Body": "<p>Does the following give defined results in terms of the C++ standard?</p>\n<pre><code>std::list&lt;int&gt; myList;\nstd::list&lt;int&gt;::iterator myIter = myList.begin();    // any issues?\nmyList.push_back( 123 );\nmyIter++;                                  // will myIter point to the 123 I pushed?\n</code></pre>\n<p>I can test this out on the compiler I'm using... but I'd like a more definitive answer.    </p>\n", "Tags": "<c++><std>", "OwnerUserId": "1099237", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_10793404_10793474_0": {"section_id": 707, "quality": 1.0, "length": 18}}, "n3337": {"so_10793404_10793474_0": {"section_id": 697, "quality": 1.0, "length": 18}}, "n4659": {"so_10793404_10793474_0": {"section_id": 736, "quality": 1.0, "length": 18}}}, "10793438": {"ParentId": "10793404", "PostTypeId": "2", "CommentCount": "4", "Body": "<pre><code>std::list&lt;int&gt; myList;\nstd::list&lt;int&gt; myIter = myList.begin();\n</code></pre>\n<p>The iterator has the same value as if you were initializing it with <code>myList.end()</code>. The iterator is initialized to on-past-the-end position. Even after you push an element into the list the iterator still points one-past-the-end. If you increment it, you are invoking undefined behaviour.</p>\n<p>UPDATE:</p>\n<p>E.g., if you compile your snippet with GCC with -D_GLIBCXX_DEBUG, the resulting executable will abort:</p>\n<pre><code>/usr/include/c++/4.6/debug/safe_iterator.h:236:error: attempt to increment \n    a past-the-end iterator.\n\nObjects involved in the operation:\niterator \"this\" @ 0x0x7fffc9548fb0 {\ntype = N11__gnu_debug14_Safe_iteratorINSt9__cxx199814_List_iteratorIiEENSt7__debug4listIiSaIiEEEEE (mutable iterator);\n  state = past-the-end;\n  references sequence with type `NSt7__debug4listIiSaIiEEE' @ 0x0x7fffc9548fb0\n}\nzsh: abort (core dumped)  ./listiter\n</code></pre>\n", "OwnerUserId": "341065", "LastEditorUserId": "341065", "LastEditDate": "2012-05-29T05:27:23.290", "Id": "10793438", "Score": "4", "CreationDate": "2012-05-29T05:20:29.923", "LastActivityDate": "2012-05-29T05:27:23.290"}});