post_cb({"bq_ids": {"n4140": {"so_19964575_19964793_2": {"length": 13, "quality": 1.0, "section_id": 243}, "so_19964575_19964793_0": {"length": 42, "quality": 0.9767441860465116, "section_id": 234}, "so_19964575_19964793_1": {"length": 26, "quality": 0.9629629629629629, "section_id": 233}}, "n3337": {"so_19964575_19964793_2": {"length": 13, "quality": 1.0, "section_id": 235}, "so_19964575_19964793_1": {"length": 26, "quality": 0.9629629629629629, "section_id": 226}, "so_19964575_19964793_0": {"length": 42, "quality": 0.9767441860465116, "section_id": 227}}, "n4659": {"so_19964575_19964793_2": {"length": 11, "quality": 0.8461538461538461, "section_id": 250}, "so_19964575_19964793_1": {"length": 26, "quality": 0.9629629629629629, "section_id": 243}, "so_19964575_19964793_0": {"length": 41, "quality": 0.9534883720930233, "section_id": 244}}}, "19964793": {"Id": "19964793", "PostTypeId": "2", "Body": "<p>The appropriate quote is [temp.inst]/2</p>\n<blockquote>\n<p id=\"so_19964575_19964793_0\">Unless a member of a class template or a member template has been explicitly instantiated or explicitly\n  specialized, the specialization of the member is implicitly instantiated when the specialization is referenced\n  in a context that requires the member definition to exist; <strong>in particular, the initialization (and any associated\n  side-effects) of a static data member does not occur unless the static data member is itself used in a way\n  that requires the definition of the static data member to exist.</strong></p>\n</blockquote>\n<p>emphasis mine.</p>\n<hr>\n<p>There's also [temp.inst]/1</p>\n<blockquote>\n<p id=\"so_19964575_19964793_1\">The implicit instantiation of a class template specialization causes the implicit\n  instantiation of the declarations, but not of the definitions or default arguments, of the class member functions, member classes, scoped member enumerations, static data members and member templates [...]</p>\n</blockquote>\n<p>and [temp.inst]/10</p>\n<blockquote>\n<p id=\"so_19964575_19964793_2\">An implementation shall not implicitly instantiate a function template, [...] or a static data member of a class template that does not require instantiation.</p>\n</blockquote>\n</hr>", "LastActivityDate": "2013-11-13T21:30:59.943", "CommentCount": "0", "CreationDate": "2013-11-13T21:30:59.943", "ParentId": "19964575", "Score": "2", "OwnerUserId": "420683"}, "19964575": {"ViewCount": "174", "Body": "<p>Consider the following code</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct Printer{\n    Printer(){\n        std::cout &lt;&lt; \"Created\\n\";\n    }\n};\n\ntemplate&lt;class Derived&gt;\nstruct InitPrinter{\n    static Printer p;\n};\n\ntemplate&lt;class Derived&gt;\nPrinter InitPrinter&lt;Derived&gt;::p;\n\n\nstruct MyClass:InitPrinter&lt;MyClass&gt;{\n     MyClass(){}\n\n};\n\n// Uncomment line below to print out created\n//auto&amp; p = MyClass::p;\n\nint main() {\n    return 0;\n}\n</code></pre>\n<p>I expected that this would print out \"Created\", however, it does not print out anything (tested with MSVC and with ideone gcc c++11). Is this a compiler implementation issue, or is this behavior supported by the standard? If the commented out line is uncommented then it prints out as expected. Is there any way to the <code>static Printer p</code> to be instantiated without requiring either changes to MyClass or extra statements like the <code>auto&amp; p = MyClass::p</code>?</p>\n<p>The reason I am interested in this is I am looking to have create a templated base class, that will run some code at startup when it is derived from.</p>\n", "AcceptedAnswerId": "19964793", "Title": "Ensuring a static member of a class is constructed", "CreationDate": "2013-11-13T21:19:34.657", "Id": "19964575", "CommentCount": "8", "PostTypeId": "1", "LastActivityDate": "2013-11-13T21:30:59.943", "Score": "3", "OwnerUserId": "1858436", "Tags": "<c++><c++11><static>", "AnswerCount": "1"}});