post_cb({"44607634": {"CommentCount": "6", "ViewCount": "63", "PostTypeId": "1", "LastEditorUserId": "3980929", "CreationDate": "2017-06-17T17:50:44.387", "LastActivityDate": "2017-08-16T17:39:42.997", "Title": "What is the meaning of the last sentence in [basic.lookup]/1?", "FavoriteCount": "0", "LastEditDate": "2017-06-17T17:51:00.120", "Id": "44607634", "Score": "1", "Body": "<p><a href=\"http://eel.is/c++draft/basic.lookup#1\" rel=\"nofollow noreferrer\">[basic.lookup]/1</a>:</p>\n<blockquote>\n<p id=\"so_44607634_44607634_0\">The name lookup rules apply uniformly to all names (including typedef-names (10.1.3), namespace-names\n  (10.3), and class-names (12.1)) wherever the grammar allows such names in the context discussed by a\n  particular rule. Name lookup associates the use of a name with a set of declarations (6.1) of that name. The\n  declarations found by name lookup shall either all declare the same entity or shall all declare functions; in the\n  latter case, the declarations are said to form a set of overloaded functions (16.1). Overload resolution (16.3)\n  takes place after name lookup has succeeded. The access rules (Clause 14) are considered only once name\n  lookup and function overload resolution (if applicable) have succeeded. Only after name lookup, function\n  overload resolution (if applicable) and access checking have succeeded <strong>are the attributes introduced by the\n  name\u2019s declaration used further in expression processing</strong> (Clause 8).</p>\n</blockquote>\n<p>What are those <strong>attributes</strong> introduced by the names\u00b4s declaration? </p>\n", "Tags": "<c++><language-lawyer><lookup>", "OwnerUserId": "3694387", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_44607634_44607634_0": {"section_id": 7083, "quality": 0.75, "length": 72}, "so_44607634_45719873_1": {"section_id": 7033, "quality": 0.8235294117647058, "length": 14}, "so_44607634_45719873_0": {"section_id": 7083, "quality": 0.9, "length": 18}}, "n3337": {"so_44607634_44607634_0": {"section_id": 6827, "quality": 0.75, "length": 72}, "so_44607634_45719873_1": {"section_id": 6779, "quality": 0.8235294117647058, "length": 14}, "so_44607634_45719873_0": {"section_id": 6827, "quality": 0.9, "length": 18}}, "n4659": {"so_44607634_44607634_0": {"section_id": 8584, "quality": 0.90625, "length": 87}, "so_44607634_45719873_0": {"section_id": 8584, "quality": 0.9, "length": 18}, "so_44607634_45719873_1": {"section_id": 8530, "quality": 0.8235294117647058, "length": 14}}}, "45719873": {"ParentId": "44607634", "CommentCount": "0", "Body": "<p>This sentence is visible in the <a href=\"http://wg21.link/N1638\" rel=\"nofollow noreferrer\">N1638 - C++ Working Draft</a> from April 2004, so it doesn't refer specifically to attributes of the form <code>[[...]]</code>, which were introduced to the standard by <a href=\"http://wg21.link/N2761\" rel=\"nofollow noreferrer\">N2761 - Towards support for attributes in C++\n(Revision 6)</a> in 2008.</p>\n<p>[basic.lookup]/1</p>\n<blockquote>\n<p id=\"so_44607634_45719873_0\">Only after name lookup, function overload resolution (if applicable) and access checking have succeeded <strong>are the attributes introduced by the name\u2019s declaration used further in expression processing (clause 5)</strong>.</p>\n</blockquote>\n<p>Also [basic.def]/1</p>\n<blockquote>\n<p id=\"so_44607634_45719873_1\">A declaration (clause 7) introduces names into a translation unit or redeclares names introduced by previous declarations. A declaration specifies the interpretation and attributes of these names.</p>\n</blockquote>\n<p>From the above, and looking at the five other occurrences of 'attribute' in that paper, it appears to me that 'attribute' just means \"information about the name\". So in this case, things like <code>extern</code>, <code>friend</code>, the body of a function definition, and anything else you can say about a name in a declaration, that wasn't part of determining the interpretation of a name.</p>\n<p>Since C++11 this would also include \"generalised attributes\" in the form <code>[[..]]</code>. There's a hint here, <a href=\"http://wg21.link/N2761\" rel=\"nofollow noreferrer\">N2761</a> didn't introduce 'attributes', it just gave us a generalised syntax for them.</p>\n<p>Function parameters, conversely, would not be 'attributes' in this sense, as the interpretation of the function name involves the parameters as part of overload resolution. The <em>return type</em> would be an attribute, since we don't look at it until we know what the name means, and which overload we've chosen.</p>\n<p>In a slightly-more-standardese sense, I <em>think</em> you can say that the 'specifiers' are attributes, while the 'declarators' specify the interpretation of a name.</p>\n<p>Pratically, I would say (without checking for a more-specific rule) that this is the rule that requires that deleted functions survive all the way through the lookup and name resolution process, and <em>then</em> fail the compilation.</p>\n<p>Otherwise, a crafty compiler author might want to save their users some grief by eliminating deleted functions earlier, on the grounds that you <em>can't</em> call a deleted function, so why bother including it in the overload set?</p>\n", "OwnerUserId": "166389", "PostTypeId": "2", "Id": "45719873", "Score": "0", "CreationDate": "2017-08-16T17:39:42.997", "LastActivityDate": "2017-08-16T17:39:42.997"}});