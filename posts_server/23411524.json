post_cb({"23411524": {"CommentCount": "6", "AcceptedAnswerId": "23413082", "PostTypeId": "1", "LastEditorUserId": "3549027", "CreationDate": "2014-05-01T16:03:00.757", "LastActivityDate": "2014-05-01T17:32:13.377", "LastEditDate": "2014-05-01T17:19:42.803", "ViewCount": "325", "FavoriteCount": "3", "Title": "Why won't \"extern template\" work with shared_ptr?", "Id": "23411524", "Score": "5", "Body": "<p>I had the (seemingly) bright idea of using <code>extern template class std::shared_ptr&lt;SomeWidelyUsedClass&gt;</code> in stdafx.h immediately after <code>#include &lt;memory&gt;</code> in order to prevent <code>std::shared_ptr&lt;SomeWidelyUsedClass&gt;</code> from being redundantly instantiated in hundreds of files, figuring I could place <code>template class std::shared_ptr&lt;SomeWidelyUsedClass&gt;</code> in a single .cpp in order to force a single instantiation and hopefully save on compile/link time. However, examination of the resulting .cod and .obj files shows that <code>shared_ptr&lt;SomeWidelyUsedClass&gt;</code> code is being created everywhere anyway. But if I use this exact same technique with my own template class, it works as expected. Is there something special about <code>shared_ptr</code> that precludes this use? Perhaps something in <code>&lt;memory&gt;</code> itself that forces the compiler to create an instantiation before it reaches my <code>extern template</code> statement (I'm very certain there's nothing higher up in stdafx.h that makes use of <code>shared_ptr</code>)?</p>\n<p>To clarify:</p>\n<pre><code>// stdafx.h; included in every cpp in the project\n#include &lt;memory&gt;\n#include \"SomeWidelyUsedClass.h\" // no shared_ptr in here\n\n// I expect this to prevent instantiation of std::shared_ptr&lt;SomeWidelyUsedClass&gt;\n// in all compilation units that include this, except the one below.\nextern template class std::shared_ptr&lt;SomeWidelyUsedClass&gt;;\n</code></pre>\n<p>Then:</p>\n<pre><code>// ExplicitTemplateInstantiations.cpp\n#include \"stdafx.h\"\n\n// I expect this to cause std::shared_ptr&lt;SomeWidelyUsedClass&gt;\n// to be instantiated in this compilation unit\ntemplate class std::shared_ptr&lt;SomeWidelyUsedClass&gt;;\n</code></pre>\n<p>And:</p>\n<pre><code>// SomeOtherFile.cpp\n#include \"stdafx.h\"\n#include \"SomeWidelyUsedClass.h\"\n\nvoid foo()\n{\n   // I expect that SomeOtherFile.obj will not include an instantiation of\n   // std::shared_ptr&lt;SomeWidelyUsedClass&gt; since it was declared extern in stdafx.h\n   std::shared_ptr&lt;SomeWidelyUsedClass&gt;(new SomeWidelyUsedClass());\n}\n</code></pre>\n", "Tags": "<c++><templates><visual-c++><visual-studio-2012><explicit-specialization>", "OwnerUserId": "3549027", "AnswerCount": "1"}, "23413082": {"ParentId": "23411524", "CommentCount": "2", "Body": "<p>The standard says in \u00a714.7.2/10:</p>\n<blockquote>\n<p id=\"so_23411524_23413082_0\">Except for inline functions and class template specializations, explicit instantiation declarations have the\n  effect of suppressing the implicit instantiation of the entity to which they refer.</p>\n</blockquote>\n<p>I just checked in VS2013 and the implementation of <code>std::shared_ptr&lt;&gt;</code> there has an inline constructor. This is probably the reason why your <code>extern template</code> is ignored.</p>\n", "OwnerUserId": "3578084", "PostTypeId": "2", "Id": "23413082", "Score": "6", "CreationDate": "2014-05-01T17:32:13.377", "LastActivityDate": "2014-05-01T17:32:13.377"}, "bq_ids": {"n4140": {"so_23411524_23413082_0": {"section_id": 259, "quality": 1.0, "length": 17}}, "n3337": {"so_23411524_23413082_0": {"section_id": 250, "quality": 1.0, "length": 17}}, "n4659": {"so_23411524_23413082_0": {"section_id": 266, "quality": 1.0, "length": 17}}}});