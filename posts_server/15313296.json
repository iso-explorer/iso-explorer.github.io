post_cb({"bq_ids": {"n4140": {"so_15313296_15313944_9": {"length": 7, "quality": 0.7777777777777778, "section_id": 2758}, "so_15313296_15313944_2": {"length": 18, "quality": 0.8181818181818182, "section_id": 5821}, "so_15313296_15313944_6": {"length": 9, "quality": 0.6, "section_id": 5823}, "so_15313296_15313296_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 2758}, "so_15313296_15313944_5": {"length": 6, "quality": 1.0, "section_id": 5823}, "so_15313296_15313944_4": {"length": 18, "quality": 1.0, "section_id": 5823}}, "n3337": {"so_15313296_15313944_9": {"length": 7, "quality": 0.7777777777777778, "section_id": 2719}, "so_15313296_15313944_2": {"length": 18, "quality": 0.8181818181818182, "section_id": 5592}, "so_15313296_15313944_6": {"length": 9, "quality": 0.6, "section_id": 5594}, "so_15313296_15313296_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 2719}, "so_15313296_15313944_5": {"length": 6, "quality": 1.0, "section_id": 5594}, "so_15313296_15313944_4": {"length": 18, "quality": 1.0, "section_id": 5594}}, "n4659": {"so_15313296_15313944_9": {"length": 7, "quality": 0.7777777777777778, "section_id": 3496}, "so_15313296_15313944_2": {"length": 18, "quality": 0.8181818181818182, "section_id": 7282}, "so_15313296_15313944_6": {"length": 9, "quality": 0.6, "section_id": 7284}, "so_15313296_15313296_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 3496}, "so_15313296_15313944_5": {"length": 6, "quality": 1.0, "section_id": 7284}, "so_15313296_15313944_4": {"length": 18, "quality": 1.0, "section_id": 7284}}}, "15313944": {"Id": "15313944", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_15313296_15313944_0\">Now can it be said that std::mutex::lock will have acquire semantics and that std::mutex::unlock essentially has release semantics?</p>\n</blockquote>\n<p><strong>Yes</strong>, this is correct. </p>\n<blockquote>\n<p id=\"so_15313296_15313944_1\">From what I understand <em>synchronize with</em> is not explicitly defined in the standard</p>\n</blockquote>\n<p>Well, in theory Paragraph 1.10/8 is probably meant to give the definition of <em>synchronizes with</em>:</p>\n<blockquote>\n<p id=\"so_15313296_15313944_2\">Certain library calls <em>synchronize with</em> other library calls performed by another thread. For example, an\n  atomic store-release <em>synchronizes with</em> a load-acquire that takes its value from the store (29.3). [Note: ...]</p>\n</blockquote>\n<p>On the other hand, this does not sound like a very formal definition. However, a better, though implicit one is indirectly given in Paragraph 1.10/10:</p>\n<blockquote>\n<p id=\"so_15313296_15313944_3\">An evaluation A is <em>dependency-ordered before</em> an evaluation B if</p>\n<p id=\"so_15313296_15313944_4\">\u2014 A performs a release operation on an atomic object M, and, in another thread, B performs a consume\n  operation on M and reads a value written by any side effect in the release sequence headed by A, or</p>\n<p id=\"so_15313296_15313944_5\">\u2014 for some evaluation X, A is dependency-ordered before X and X carries a dependency to B.</p>\n<p id=\"so_15313296_15313944_6\">[ Note: <strong>The relation \u201cis dependency-ordered before\u201d is analogous to \u201csynchronizes with\u201d, but uses release/-\n  consume in place of release/acquire.</strong> \u2014end note ]</p>\n</blockquote>\n<p>Since the \"<em>is analogous to</em>\" relationship is most often symmetric, I would say that the above definition of \"<em>is-dependency-ordered before</em>\" indirectly provides a definition of \"<em>synchronizes with</em>\" as well - although you might correctly object that notes are non-normative; still, this seems to be the intended definition.</p>\n<p>My intuition of the <em>synchronizes with</em> relationship is that it occurs between a write (atomic) operation performed by one thread that stores a certain value and the <em>first</em> (atomic) operation that reads that value. That operation might as well be in the same thread.</p>\n<p>If the two operations are on different threads, then the <em>synchronizes-with</em> relation establishes a cross-thread ordering on operations.</p>\n<blockquote>\n<p id=\"so_15313296_15313944_7\">In the Standard I can find this under section</p>\n<p id=\"so_15313296_15313944_8\"><strong>30.4.1.2 Mutex types [thread.mutex.requirements.mutex]</strong></p>\n<p id=\"so_15313296_15313944_9\">11 Synchronization: Prior <code>unlock()</code> operations on the same object shall <em>synchronize with</em> (1.10) this operation.</p>\n</blockquote>\n<p>To me, this seems compatible with the interpretation given above. An operation with release semantics (unlock, store) will synchronize with an operation of acquire semantics (lock, load).</p>\n<blockquote>\n<p id=\"so_15313296_15313944_10\">however, from my understanding of acquire/release semantics, this has more to do with memory reordering. synchronize with could also be called release/acquire semantics?</p>\n</blockquote>\n<p>Release and acquire semantics describe the nature of some operations; the <em>synchronizes-with</em> relationship is (indeed) a <em>relationship</em> which is established between operations that have acquire or release semantics, in a well-defined way. </p>\n<p>So in a sense, <em>synchronizes-with</em> is a consequence of the semantics of those operations, and we use those semantics to achieve the correct ordering of instructions and constraint the possible reordering that the CPU or the compiler will perform.</p>\n", "LastActivityDate": "2013-03-09T17:50:59.590", "CommentCount": "2", "CreationDate": "2013-03-09T17:50:59.590", "ParentId": "15313296", "Score": "6", "OwnerUserId": "1932150"}, "15313296": {"ViewCount": "1548", "Body": "<p>I am reading the C++ memory model defined in n3485 and it talks about release/acquire semantics, which from what I understand, and also from the definitions <a href=\"http://preshing.com/20120913/acquire-and-release-semantics\" rel=\"noreferrer\">given in this blog</a>:</p>\n<blockquote>\n<p id=\"so_15313296_15313296_0\"><strong>Acquire semantics</strong> is a property which can only apply to operations which <strong>read</strong> from shared memory, whether they are read-modify-write operations or plain loads. The operation is then considered a read-acquire. Acquire semantics <em>prevent memory reordering of the read-acquire with any read or write operation which follows it in program order.</em></p>\n<p id=\"so_15313296_15313296_1\"><strong>Release semantics</strong> is a property which can only apply to operations which <strong>write</strong> to shared memory, whether they are read-modify-write operations or plain stores. The operation is then considered a write-release. Release semantics <em>prevent memory reordering of the write-release with any read or write operation which precedes it in program order.</em></p>\n</blockquote>\n<p>is going to prevent reordering of reads/writes before or after the current read/write being done.  The first (acquire) will make sure that the read currently being done is not reordered with any read/write coming after it, the latter (release) will make sure that the current write is not being reordered with read/write operations that come before it.</p>\n<p>Now can it be said that <code>std::mutex::lock</code> will have <em>acquire</em> semantics and that <code>std::mutex::unlock</code> essentially has <em>release</em> semantics?</p>\n<p>In the Standard I can find this under section</p>\n<p><strong>30.4.1.2 Mutex types [thread.mutex.requirements.mutex]</strong></p>\n<blockquote>\n<p id=\"so_15313296_15313296_2\">11 Synchronization: Prior <code>unlock()</code> operations on the same object shall <em>synchronize with</em> (1.10) this operation.</p>\n</blockquote>\n<p>From what I understand <em>synchronize with</em> is not explicitly defined in the standard, however it seems to be a type of <em>happens before</em> relation looking at two statements being evaluated between two different threads, however, from my understanding of acquire/release semantics, this has more to do with memory reordering.  <em>synchronize with</em> could also be called release/acquire semantics?</p>\n<p>So do release/acquire semantics apply not only to reordering of load/store operations and also intra-thread interleaving of operations?</p>\n<p>In the standard section about the memory-model it mostly talks about ordered relations in terms of two threads interleaving.  This leaves open to interpretation as to whether this applies also to memory ordering. </p>\n<p>Can anybody clarify?  </p>\n", "AcceptedAnswerId": "15313944", "Title": "Release/Acquire semantics wrt std::mutex", "CreationDate": "2013-03-09T16:48:54.587", "Id": "15313296", "CommentCount": "5", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2013-03-09T16:50:56.987", "LastEditorUserId": "1932150", "LastActivityDate": "2013-03-09T20:27:04.017", "Score": "7", "OwnerUserId": "174614", "Tags": "<c++><multithreading><c++11><mutex><memory-model>", "AnswerCount": "1"}});