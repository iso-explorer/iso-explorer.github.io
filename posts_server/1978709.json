post_cb({"1978957": {"ParentId": "1978709", "CommentCount": "0", "Body": "<p>The language specification says nothing about \"memory leaks\". From the language point of view, when you create an object in dynamic memory, you are doing just that: you are creating an anonymous object with unlimited lifetime/storage duration. \"Unlimited\" in this case means that the object can only end its lifetime/storage duration when you explicitly deallocate it, but otherwise it continues to live forever (as long as the program runs).</p>\n<p>Now, we usually consider a dynamically allocated object become a \"memory leak\" at the point in program execution when all references (generic \"references\", like pointers) to that object are lost to the point of being unrecoverable. Note, that even to a human the notion of \"all references being lost\" is not very precisely defined. What if we have a reference to some part of the object, which can be theoretically \"recalculated\" to a reference to the entire object? Is it a memory leak or not? What if we have no references to the object whatsoever, but somehow we can calculate such a reference using some other information available to the program (like precise sequence of allocations)?</p>\n<p>The language specification doesn't concern itself with issues like that. Whatever you consider an appearance of \"memory leak\" in your program, from the language point of view it is a non-event at all. From the language point of view a \"leaked\" dynamically allocated object just continues to live happily until the program ends. This is the only remaining point of concern: what happens when program ends and some dynamic memory is still allocated?</p>\n<p>If I remember correctly, the language does not specify what happens to dynamic memory which is still allocated the moment of program termination. No attempts will be made to automatically destruct/deallocate the objects you created in dynamic memory. But there's no formal <em>undefined behavior</em> in cases like that.</p>\n", "OwnerUserId": "187690", "PostTypeId": "2", "Id": "1978957", "Score": "3", "CreationDate": "2009-12-30T07:47:07.310", "LastActivityDate": "2009-12-30T07:47:07.310"}, "1978803": {"ParentId": "1978709", "CommentCount": "2", "Body": "<p>Undefined behavior means, what will happen has not been defined or is unknown. The behavior of memory leaks is definitly known in C/C++ to eat away at available memory. The resulting problems, however, can not always be defined and vary as described by gameover.</p>\n", "OwnerUserId": "236975", "PostTypeId": "2", "Id": "1978803", "Score": "-1", "CreationDate": "2009-12-30T07:00:09.153", "LastActivityDate": "2009-12-30T07:00:09.153"}, "24137427": {"ParentId": "1978709", "PostTypeId": "2", "CommentCount": "28", "Body": "<p>(Comment below \"Heads-up: this answer has been moved here from <a href=\"https://stackoverflow.com/questions/24137006/does-a-memory-leak-cause-undefined-behaviour\">Does a memory leak cause undefined behaviour?</a>\" - you'll probably have to read that question to get proper background for this answer O_o).</p>\n<p>It seems to me that this part of the Standard explicitly permits:</p>\n<ul>\n<li><p>having a custom memory pool that you placement-<code>new</code> objects into, then release/reuse the whole thing without spending time calling their destructors, <strong><em>as long as you don't depend on side-effects of the object destructors</em></strong>.</p></li>\n<li><p>libraries that allocate a bit of memory and never release it, probably because their functions/objects could be used by destructors of static objects and registered on-exit handlers, and it's not worth buying into the whole orchestrated-order-of-destruction or transient \"phoenix\"-like rebirth each time those accesses happen.</p></li>\n</ul>\n<p>I can't understand <strong><em>why</em></strong> the Standard chooses to leave the behaviour undefined when there are dependencies on side effects - rather than simply say those side effects won't have happened and let the program have defined <em>or</em> undefined behaviour as you'd normally expect given that premise.</p>\n<p>We <strong><em>can</em></strong> still consider <strong><em>what</em></strong> the Standard says is undefined behaviour.  The crucial part is:</p>\n<blockquote>\n<p id=\"so_1978709_24137427_0\">\"depends on the side effects produced by the destructor has undefined behavior.\"</p>\n</blockquote>\n<p>The Standard \u00a71.9/12 explicitly defines <strong><em>side effects</em></strong> as follows (the italics below are the Standards, indicating the introduction of a formal definition):</p>\n<blockquote>\n<p id=\"so_1978709_24137427_1\">Accessing an object designated by a <code>volatile</code> glvalue (3.10), modifying an object, calling a library I/O function, or calling a function that does any of those operations are all <em>side effects</em>, which are changes in the state of the execution environment.</p>\n</blockquote>\n<p>In your program, there's no dependency so no undefined behaviour.</p>\n<p>One example of dependency arguably matching the scenario in  \u00a73.8 p4, where the need for or cause of undefined behaviour isn't apparent, is:</p>\n<pre><code>struct X\n{\n    ~X() { std::cout &lt;&lt; \"bye!\\n\"; }\n};\n\nint main()\n{\n     new X();\n}\n</code></pre>\n<p>An issue people are debating is whether the <code>X</code> object above would be considered <code>released</code> for the purposes of 3.8 p4, given it's probably only released to the O.S. after program termination - it's not clear from reading the Standard whether that stage of a process's \"lifetime\" is in scope for the Standard's behavioural requirements (my quick search of the Standard didn't clarify this).  I'd personally hazard that 3.8p4 applies here, partly because as long as it's ambiguous enough to be argued a compiler writer may feel entitled to allow undefined behaviour in this scenario, but even if the above code doesn't constitute release the scenario's easily amended ala...</p>\n<pre><code>int main()\n{\n     X* p = new X();\n     *(char*)p = 'x';   // token memory reuse...\n}\n</code></pre>\n<p>Anyway, however main's implemented the destructor above has a <em>side effect</em> - per \"calling a library I/O function\"; further, the program's observable behaviour arguably \"depends on\" it in the sense that buffers that would be affected by the destructor were it to have run are flushed during termination.  But is \"depends on the side effects\" <em>only</em> meant to allude to situations where the program would clearly have undefined behaviour if the destructor didn't run?  I'd err on the side of the former, particularly as the latter case wouldn't need a dedicated paragraph in the Standard to document that the behaviour is undefined.  Here's an example with obviously-undefined behaviour:</p>\n<pre><code>int* p_;\n\nstruct X\n{\n    ~X() { if (b_) p_ = 0; else delete p_; }\n    bool b_;\n};\n\nX x{true};\n\nint main()\n{\n     p_ = new int();\n     delete p_; // p_ now holds freed pointer\n     new (&amp;x){false};  // reuse x without calling destructor\n}\n</code></pre>\n<p>When <code>x</code>'s destructor is called during termination, <code>b_</code> will be <code>false</code> and <code>~X()</code> will therefore <code>delete p_</code> for an already-freed pointer, creating undefined behaviour.  If <code>x.~X();</code> had been called before reuse, <code>p_</code> would have been set to 0 and deletion would have been safe.  In that sense, the program's correct behaviour could be said to depend on the destructor, and the behaviour is clearly undefined, but have we just crafted a program that matches 3.8p4's described behaviour in its own right, rather than having the behaviour be a consequence of 3.8p4...?</p>\n<p>More sophisticated scenarios with issues - too long to provide code for - might include e.g. a weird C++ library with reference counters inside file stream objects that had to hit 0 to trigger some processing such as flushing I/O or joining of background threads etc. - where failure to do those things risked not only failing to perform output explicitly requested by the destructor, but also failing to output other buffered output from the stream, or on some OS with a transactional filesystem might result in a rollback of earlier I/O - such issues could change observable program behaviour or even leave the program hung.</p>\n<p>Note: it's not necessary to prove that there's any actual code that behaves strangely on any existing compiler/system; the Standard clearly reserves the <em>right</em> for compilers to have undefined behaviour... that's all that matters.  This is not something you can reason about and choose to ignore the Standard - it may be that C++14 or some other revision changes this stipulation, but as long as it's there then if there's even arguably some \"dependency\" on <em>side effects</em> then there's the potential for undefined behaviour (which of course is itself allowed to be defined by a particular compiler/implementation, so it doesn't automatically mean that every compiler is obliged do something bizarre).</p>\n", "OwnerUserId": "410767", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:13:42.550", "Id": "24137427", "Score": "4", "CreationDate": "2014-06-10T09:26:26.400", "LastActivityDate": "2014-07-14T02:11:54.550"}, "1978817": {"ParentId": "1978709", "CommentCount": "2", "Body": "<p>Its definately <strong>defined</strong> behaviour.</p>\n<p>Consider a case the server is running and keep allocating heap memory and no memory is released even if there's no use of it.\nHence the end result would be that eventually server will run out of memory and  definately crash will occur. </p>\n", "OwnerUserId": "303986", "PostTypeId": "2", "Id": "1978817", "Score": "2", "CreationDate": "2009-12-30T07:03:01.660", "LastActivityDate": "2009-12-30T07:03:01.660"}, "24137466": {"ParentId": "1978709", "PostTypeId": "2", "CommentCount": "21", "Body": "<p>The burden of evidence is on those who would think a memory leak could be C++ UB.</p>\n<p>Naturally no evidence has been presented.</p>\n<p>In short for anyone harboring any <em>doubt</em> this question can never be clearly resolved, except by very credibly threatening the committee with e.g. loud Justin Bieber music, so that they add a C++14 statement that clarifies that it's not UB.</p>\n<hr>\n<p>At issue is C++11 \u00a73.8/4:</p>\n<blockquote>\n<p id=\"so_1978709_24137466_0\"><strong>\u201d</strong> For an object of a class type with a non-trivial destructor, the program is not required to call the destructor explicitly before the storage which the object occupies is reused or released; however, if there is no explicit call to the destructor or if a <em>delete-expression</em> (5.3.5) is not used to release the storage, the destructor shall not be implicitly called and any program that depends on the side effects produced by the destructor has undefined behavior.</p>\n</blockquote>\n<p>This passage had the exact same wording in C++98 and C++03. What does it mean?</p>\n<ul>\n<li><p><em>the program is not required to call the destructor explicitly before the storage which the object occupies is reused or released</em><br>\n\u00a0<br>\n\u2013 means that one can grab the memory of a variable and reuse that memory, without first destroying the existing object.</br></br></p></li>\n<li><p><em>if there is no explicit call to the destructor or if a delete-expression (5.3.5) is not used to release the storage, the destructor shall not be implicitly called</em><br>\n\u00a0<br>\n\u2013 means if one does not destroy the existing object before the memory reuse, then if the object is such that its destructor is automatically called (e.g. a local automatic variable) then the program has Undefined Behavior, because that destructor would then operate on a no longer existing object.</br></br></p></li>\n<li><p><em>and any program that depends on the side effects produced by the destructor has undefined behavior</em><br>\n\u00a0<br>\n\u2013 can't mean literally what it says, because a program always depends on any side effects, by the definition of side effect. Or in other words, there is no way for the program not to depend on the side effects, because then they would not be side effects.  </br></br></p></li>\n</ul>\n<p>Most likely what was intended was not what finally made its way into C++98, so that what we have at hand is a <em>defect</em>.</p>\n<p>From the context one can guess that if a program relies on the automatic destruction of an object of statically known type <code>T</code>, where the memory has been reused to create an object or objects that is not a <code>T</code> object, then that's Undefined Behavior.</p>\n<hr>\n<p>Those who have followed the commentary may notice that the above explanation of the word \u201cshall\u201d is not the meaning that I assumed earlier. As I see it now, the \u201cshall\u201d is not a requirement on the implementation, what it's allowed to do. It's a requirement on the program, what the code is allowed to do.</p>\n<p>Thus, this is formally UB:</p>\n<pre><code>auto main() -&gt; int\n{\n    string s( 666, '#' );\n    new( &amp;s ) string( 42, '-' );    //  &lt;- Storage reuse.\n    cout &lt;&lt; s &lt;&lt; endl;\n    //  &lt;- Formal UB, because original destructor implicitly invoked.\n}\n</code></pre>\n<p>But this is OK with a literal interpretation:</p>\n<pre><code>auto main() -&gt; int\n{\n    string s( 666, '#' );\n    s.~string();\n    new( &amp;s ) string( 42, '-' );    //  &lt;- Storage reuse.\n    cout &lt;&lt; s &lt;&lt; endl;\n    //  OK, because of the explicit destruction of the original object.\n}\n</code></pre>\n<p>A main problem is that with a literal interpretation of the standard's paragraph above it would still be formally OK if the placement new created an object of a different type there, just because of the explicit destruction of the original. But it would not be very in-practice OK in that case. Maybe this is covered by some other paragraph in the standard, so that it is also formally UB.</p>\n<p>And this is also OK, using the placement <code>new</code> from <code>&lt;new&gt;</code>:</p>\n<pre><code>auto main() -&gt; int\n{\n    char* storage   = new char[sizeof( string )];\n    new( storage ) string( 666, '#' );\n    string const&amp; s = *(\n        new( storage ) string( 42, '-' )    //  &lt;- Storage reuse.\n        );\n    cout &lt;&lt; s &lt;&lt; endl;\n    //  OK, because no implicit call of original object's destructor.\n}\n</code></pre>\n<p>As I see it \u2013 now.</p>\n</hr></hr>", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2014-06-10T15:19:39.490", "Id": "24137466", "Score": "3", "CreationDate": "2014-06-10T09:28:09.590", "LastActivityDate": "2014-06-10T15:19:39.490"}, "bq_ids": {"n4140": {"so_1978709_24137466_0": {"section_id": 7192, "quality": 0.9428571428571428, "length": 33}, "so_1978709_24137427_0": {"section_id": 7192, "quality": 1.0, "length": 7}, "so_1978709_24137969_0": {"section_id": 7192, "quality": 0.9428571428571428, "length": 33}, "so_1978709_24146155_0": {"section_id": 6101, "quality": 0.9137931034482759, "length": 53}, "so_1978709_24137427_1": {"section_id": 5808, "quality": 0.9130434782608695, "length": 21}}, "n3337": {"so_1978709_24137466_0": {"section_id": 6936, "quality": 0.9428571428571428, "length": 33}, "so_1978709_24137427_0": {"section_id": 6936, "quality": 1.0, "length": 7}, "so_1978709_24137969_0": {"section_id": 6936, "quality": 0.9428571428571428, "length": 33}, "so_1978709_24146155_0": {"section_id": 5867, "quality": 0.9137931034482759, "length": 53}, "so_1978709_24137427_1": {"section_id": 5581, "quality": 0.9130434782608695, "length": 21}}, "n4659": {"so_1978709_24137466_0": {"section_id": 8701, "quality": 0.9428571428571428, "length": 33}, "so_1978709_24137427_0": {"section_id": 8701, "quality": 1.0, "length": 7}, "so_1978709_24137969_0": {"section_id": 8701, "quality": 0.9428571428571428, "length": 33}, "so_1978709_24146155_0": {"section_id": 7598, "quality": 0.9137931034482759, "length": 53}, "so_1978709_24137427_1": {"section_id": 7269, "quality": 0.8695652173913043, "length": 20}}}, "1978878": {"ParentId": "1978709", "CommentCount": "0", "Body": "<p>Straight forward answer: The standard doesn't define what happens when you leak memory, thus it is \"undefined\". It's implicitly undefined though, which is less interesting than the explicitly undefined things in the standard.</p>\n", "OwnerUserId": "238128", "PostTypeId": "2", "Id": "1978878", "Score": "0", "CreationDate": "2009-12-30T07:20:49.453", "LastActivityDate": "2009-12-30T07:20:49.453"}, "24137969": {"ParentId": "1978709", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>My interpretation of this statement:</p>\n<blockquote>\n<p id=\"so_1978709_24137969_0\">For an object of a class type with a non-trivial destructor, the\n  program is not required to call the destructor explicitly before the\n  storage which the object occupies is reused or released; however, if\n  there is no explicit call to the destructor or if a delete-expression\n  (5.3.5) is not used to release the storage, the destructor shall not\n  be implicitly called and any program that depends on the side effects\n  produced by the destructor has undefined behavior.</p>\n</blockquote>\n<p>is as follows:</p>\n<p>If you somehow manage to free the <em>storage which the object occupies</em> <strong>without</strong> calling the destructor on the object that occupied the memory, UB is the consequence, if the destructor is non-trivial and has side-effects.</p>\n<p>If <code>new</code> allocates with <code>malloc</code>, the raw storage could be released with <code>free()</code>, the destructor would not run, and UB would result. Or if a pointer is cast to an unrelated type and deleted, the memory is freed, but the wrong destructor runs, UB.</p>\n<p>This is not the same as an omitted <code>delete</code>, where the underlying memory is not freed. Omitting <code>delete</code> is not UB.</p>\n", "OwnerUserId": "3435400", "LastEditorUserId": "3435400", "LastEditDate": "2014-06-10T11:28:36.127", "Id": "24137969", "Score": "6", "CreationDate": "2014-06-10T09:53:48.313", "LastActivityDate": "2014-06-10T11:28:36.127"}, "1978757": {"ParentId": "1978709", "CommentCount": "13", "Body": "<p>Memory leaks are definitely defined in C/C++.</p>\n<p>If I do:</p>\n<pre><code>int *a = new int[10];\n</code></pre>\n<p>followed by </p>\n<pre><code>a = new int[10]; \n</code></pre>\n<p>I'm definitely leaking memory as there is no way to access the 1st allocated array and this memory is not automatically freed as GC is not supported. </p>\n<p>But the consequences of this leak are unpredictable and will vary from application to application and from machine to machine for a same given application. Say an application that crashes out due to leaking on one machine might work just fine on another machine with more RAM. Also for a given application on a given machine the crash due to leak can appear at different times during the run.</p>\n", "OwnerUserId": "127404", "PostTypeId": "2", "Id": "1978757", "Score": "6", "CreationDate": "2009-12-30T06:43:53.633", "LastActivityDate": "2009-12-30T06:43:53.633"}, "24146155": {"ParentId": "1978709", "CommentCount": "1", "Body": "<p>Adding to all the other answers, some entirely different approach. Looking at memory allocation in \u00a7 5.3.4-18 we can see:</p>\n<blockquote>\n<p id=\"so_1978709_24146155_0\">If any part of the object initialization described above<sup>76</sup> terminates\n  by throwing an exception and a suitable deallocation function can be\n  found, the deallocation function is called to free the memory in which\n  the object was being constructed, after which the exception continues\n  to propagate in the context of the new-expression. If no unambiguous\n  matching deallocation function can be found, propagating the exception\n  does not cause the object\u2019s memory to be freed. [ Note: This is\n  appropriate when the called allocation function does not allocate\n  memory; otherwise, it is likely to result in a memory leak. \u2014end note\n  ]</p>\n</blockquote>\n<p>Would it cause UB here, it would be mentioned, so it is \"just a memory leak\".</p>\n<p>In places like \u00a720.6.4-10, a possible garbage collector and leak detector is mentioned. A lot of thought has been put into the concept of safely derived pointers et.al. to be able to use C++ with a garbage collector (C.2.10 \"Minimal support for garbage-collected regions\").</p>\n<p>Thus if it would be UB to just lose the last pointer to some object, all the effort would make no sense.</p>\n<p>Regarding the \"when the destructor has side effects not running it ever UB\" I would say this is wrong, otherwise facilities such as <code>std::quick_exit()</code> would be inherently UB too.</p>\n", "OwnerUserId": "833362", "PostTypeId": "2", "Id": "24146155", "Score": "2", "CreationDate": "2014-06-10T16:24:37.527", "LastActivityDate": "2014-06-10T16:24:37.527"}, "1980868": {"ParentId": "1978709", "CommentCount": "0", "Body": "<p>If the space shuttle must take off in two minutes, and I have a choice between putting it up with code that leaks memory and code that has undefined behavior, I'm putting in the code that leaks memory.</p>\n<p>But most of us aren't usually in such a situation, and if we are, it's probably by a failure further up the line.  Perhaps I'm wrong, but I'm reading this question as, \"Which sin will get me into hell faster?\"</p>\n<p>Probably the undefined behavior, but in reality both.</p>\n", "OwnerUserId": "1674", "PostTypeId": "2", "Id": "1980868", "Score": "1", "CreationDate": "2009-12-30T15:53:29.753", "LastActivityDate": "2009-12-30T15:53:29.753"}, "1978959": {"ParentId": "1978709", "CommentCount": "0", "Body": "<p>If you leak memory, execution proceeds as if nothing happens.  This is defined behavior.  </p>\n<p>Down the track, you <em>may</em> find that a call to <code>malloc</code> fails due to there not being enough available memory.  But this is a defined behavior of <code>malloc</code>, and the consequences are also well-defined: the  <code>malloc</code> call returns <code>NULL</code>.</p>\n<p>Now this may cause a program that doesn't check the result of <code>malloc</code> to fail with a segmentation violation.  But that undefined behavior is (from the POV of the language specs) due to the program dereferencing an invalid pointer, not the earlier memory leak or the failed <code>malloc</code> call. </p>\n", "OwnerUserId": "139985", "PostTypeId": "2", "Id": "1978959", "Score": "6", "CreationDate": "2009-12-30T07:47:48.503", "LastActivityDate": "2009-12-30T07:47:48.503"}, "1978731": {"ParentId": "1978709", "CommentCount": "4", "Body": "<p>defined, since a memory leak is you forgetting to clean up after yourself.</p>\n<p>of course, a memory leak can probably cause undefined behaviour later.</p>\n", "OwnerUserId": "118131", "PostTypeId": "2", "Id": "1978731", "Score": "0", "CreationDate": "2009-12-30T06:35:11.590", "LastActivityDate": "2009-12-30T06:35:11.590"}, "1978709": {"CommentCount": "1", "AcceptedAnswerId": "1978859", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2009-12-30T06:26:27.083", "LastActivityDate": "2014-07-14T02:11:54.550", "LastEditDate": "2017-05-23T12:24:45.347", "ViewCount": "1420", "FavoriteCount": "5", "Title": "Are memory leaks \"undefined behavior\" class problem in C++?", "Id": "1978709", "Score": "12", "Body": "<p>Turns out many innocently looking things are undefined behavior in C++. For example, once a non-null pointer has been <code>delete</code>'d <a href=\"https://stackoverflow.com/questions/1866461/why-should-i-not-try-to-use-this-value-after-delete-this\">even printing out that pointer value is undefined behavior</a>.</p>\n<p>Now memory leaks are definitely bad. But what class situation are they - defined, undefined or what other class of behavior?</p>\n", "Tags": "<c++><memory-management><memory-leaks><undefined-behavior>", "OwnerUserId": "57428", "AnswerCount": "14"}, "1978859": {"ParentId": "1978709", "PostTypeId": "2", "CommentCount": "14", "Body": "<h3>Memory leaks.</h3>\n<p>There is no undefined behavior. It is perfectly legal to leak memory.</p>\n<p>Undefined behavior: is actions the standard specifically does not want to define and leaves upto the implementation so that it is flexible to perform certain types of optimizations without breaking the standard.</p>\n<p>Memory management is well defined.<br>\nIf you dynamically allocate memory and don't release it. Then the memory remains the property of the application to manage as it sees fit. The fact that you have lost all references to that portion of memory is neither here nor there.</br></p>\n<p>Of course if you continue to leak then you will eventually run out of available memory and the application will start to throw bad_alloc exceptions. But that is another issue.</p>\n", "OwnerUserId": "14065", "LastEditorUserId": "14065", "LastEditDate": "2009-12-30T07:47:56.490", "Id": "1978859", "Score": "22", "CreationDate": "2009-12-30T07:15:50.970", "LastActivityDate": "2009-12-30T07:47:56.490"}, "24143792": {"ParentId": "1978709", "PostTypeId": "2", "CommentCount": "17", "Body": "<p>This obviously cannot be undefined behaviour. Simply because UB has to happen at some point in time, and forgetting to release memory or call a destructor does not happen at any point in time. What happens is just that the program terminates without ever having released memory or called the destructor; this does not make the behaviour of the program, or of its termination, undefined in any way.</p>\n<p>This being said, in my opinion the standard is contradicting itself in this passage. On one hand it ensures that the destructor will not be called in this scenario, and on the other hand it says that if the program depends on the side effects produced by the destructor then it has undefined behaviour. Suppose the destructor calls <code>exit</code>, then no program that does anything can pretend to be independent of that, because the side effect of calling the destructor would prevent it from doing what it would otherwise do; but the text also assures that the destructor <em>will not be called</em> so that the program can go on with doing its stuff undisturbed. I think the only reasonable way to read the end of this passage is that if the proper behaviour of the program would <em>require</em> the destructor to be called, then behaviour is in fact not defined; this then is a superfluous remark, given that it has just been stipulated that the destructor will not be called.</p>\n", "OwnerUserId": "1436796", "LastEditorUserId": "1436796", "LastEditDate": "2014-07-13T07:47:10.103", "Id": "24143792", "Score": "0", "CreationDate": "2014-06-10T14:36:56.347", "LastActivityDate": "2014-07-13T07:47:10.103"}});