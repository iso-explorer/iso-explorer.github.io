post_cb({"26494206": {"ParentId": "26493902", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-10-21T18:56:36.440", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:20:29.710", "Id": "26494206", "OwnerUserId": "2556165", "Body": "<pre><code>int main(void)\n{\n    A a;        // creates `a` using default constructor of `A`\n    A b = f(a); // initializes `b` using implicitly-defined\n                // move-constructor from temporary copy of `a` (see [1])\n    /* where\n        A f(A a) // gets copy of `A` object as argument\n        {\n            return a; // return-value is copy-initialized\n        }\n    */\n    return 0;\n}\n</code></pre>\n<p><strong>[1]</strong> <a href=\"https://stackoverflow.com/a/4820339/2556165\">The implicit generation of move constructors</a></p>\n", "LastActivityDate": "2014-10-21T18:56:36.440"}, "26494575": {"ParentId": "26493902", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-10-21T19:19:49.890", "Score": "1", "LastEditorUserId": "3025453", "LastEditDate": "2014-10-21T19:24:55.463", "Id": "26494575", "OwnerUserId": "3025453", "Body": "<p>Assuming the optimizer does not simplify the process:</p>\n<ul>\n<li>The function <code>f</code> you wrote takes its argument a by value. So calling the function f invokes setting up the parameter to <code>f</code>, which means copying the local variable <code>a</code> of your <code>main</code> function into the stack space used for passing the parameter to <code>f</code> (a temporary object). This object is created using the copy constructor.</li>\n<li>As <code>f</code> returns by value, all typical C++ implementations work by passing a pointer to <em>storage space</em> for an object of type A (no created object yet) as a hidden parameter to <code>f</code>. In the most simple case, this is a temporary object created on the stack of main for the time of the expression involving the function call.</li>\n<li>Now that the parameters for <code>f</code> are set up, the function <code>f</code> is entered. As its sole statement is a return statement, the only thing <code>f</code> does is copying the parameter <code>a</code> into the storage provided by the caller. This is done using the move constructor, but you hit a corner case in the language specification here, so compiler behaviour might vary, and you might get a copy instead. More in this in the last paragraph.</li>\n<li>After having constructed the return value, <code>f</code> exits. <code>main</code> regains control and creates the local  variable <code>b</code>, taking the temporary object returned by <code>f</code> as source. As this temporary object is an rvalue, the initialization of <code>b</code> is done using move construction (on C++11).</li>\n<li>As the statement is completed now, the temporary objects (the parameter and the return value) are destroyed. I don't think the order of destruction is specified, but if it is, it will be last-constructed first, so the return value would be destroyed before the parameter.</li>\n</ul>\n<p>Typically, a \"move elision\" optimization is applied to your code, though. The hidden parameter of <code>f</code> is not given the address of a temporary object which is afterwards moved constructed into <code>b</code>, but <code>f</code> constructs directly int <code>b</code>.</p>\n<p>The (non-named) return value optimization is not of a concern for the code given, as the return statement does not consist of a constructor call.</p>\n<p>The named return-value optimization is also not applicable. This optimization would place the object you return (i.e. the parameter <code>a</code>) at the place the caller provided for the return value, so a copy/move operation can be avoided. In the function you wrote, the returned object is a parameter, so the compiler gets no chance to \"put it where the return value is going to be\" while compiling <code>f</code>, as the machine calling convention dictates where that object is to be found.</p>\n<p>The before-mentioned corner case in the language specification (whether the return value of <code>f</code> is move- or copy-constructed) is rooted in an implicit \"std::move\", allowing moving, on the return statement. This is specified in clause [class.copy] (12.8 in n3337) in paragraph 32. It specifies that if a copy is allowed to be elided (accoring to the previous paragraph), an l-value given as copy source (in this case the name of the parameter <code>a</code>) is treated as r-value (i.e. can be moved from). The criteria for allowed copy elisions are given in 12.8/31, which amongst other criteria lists:</p>\n<blockquote>\n<p id=\"so_26493902_26494575_0\">a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (other than a function or catch-clause parameter) with the same cv-unqualified type as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function\u2019s return value</p>\n</blockquote>\n<p>This is, in fact, the definition of the named return value optimization! And as already explained above, the named return value optimization can not work, as parameters and returned objects are located in different spaces, but now lets go back to [12.8/32] and look at the precise wording:</p>\n<blockquote>\n<p id=\"so_26493902_26494575_1\">When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, and the object to be copied is designated by an lvalue, overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue</p>\n</blockquote>\n<p>The part \"or would be met save for the fact that the source object is a function parameter\" is our life-saver here. It enables treatment as r-value even in the case where the named return value optimization is not possible just because of object storage locations and not because of semantic constraints.</p>\n<p>EDIT: The reason I called this a corner case was missing: The life-save clause has been added very late in the C++11 standardization process, so there are some partly conforming compilers, that do not implicitly move from parameters.</p>\n", "LastActivityDate": "2014-10-21T19:24:55.463"}, "26493902": {"CommentCount": "0", "AcceptedAnswerId": "26493998", "CreationDate": "2014-10-21T18:40:17.693", "LastActivityDate": "2014-10-22T11:50:58.847", "PostTypeId": "1", "ViewCount": "324", "FavoriteCount": "1", "Title": "Understanding function call in context of temporary objects", "Id": "26493902", "Score": "1", "Body": "<p>Look at this simple code:</p>\n<pre><code>class A\n{};\n\nA f(A a)\n{\n    return a;\n}\n\nint main(void)\n{\n    A a;\n    A b = f(a);\n    return 0;\n}\n</code></pre>\n<p>It creates a local variable <code>a</code>, calls a function <code>f()</code> and assigns its return value to another variable <code>b</code>. But I'd like to know what happens during the function call.</p>\n<p>Could someone describe to be me, step by step, what objects (temporary or otherwise) are created during the process, what constructors, destructors and assign/move operators are called and when?</p>\n", "Tags": "<c++><c++11><function-calls>", "OwnerUserId": "1030598", "AnswerCount": "4"}, "26493971": {"ParentId": "26493902", "CommentCount": "3", "CreationDate": "2014-10-21T18:43:58.333", "OwnerUserId": "3647361", "PostTypeId": "2", "Id": "26493971", "Score": "2", "Body": "<pre><code>A f(A a)\n{\n    return a;\n}\n\nA a;\nA b = f(a);\n</code></pre>\n<ol>\n<li><p>The parameter (<code>a</code>) is copy-initialized with the corresponding argument (<code>a</code>). That simply involves the copy-constructor.</p></li>\n<li><p>The return-value temporary is copy-initialized with <code>a</code>.</p></li>\n<li><p><code>b</code> is copy-initialized with the return value of the function call. The implicitly-defined move-constructor is called (as the initializer is a (p)rvalue).</p></li>\n</ol>\n<p>Note that copy elision doesn't apply here as, in <code>return</code> statements, it only works for variables that aren't function (or catch-clause) parameters.</p>\n", "LastActivityDate": "2014-10-21T18:43:58.333"}, "26493998": {"ParentId": "26493902", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2014-10-21T18:45:23.717", "Score": "10", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:27:21.780", "Id": "26493998", "OwnerUserId": "873025", "Body": "<p>When in doubt bring out the <code>Noisy</code> class:</p>\n<pre><code>struct Noisy {\n    Noisy() { std::cout &lt;&lt; \"Default construct\" &lt;&lt; std::endl; }\n    Noisy(const Noisy&amp;) { std::cout &lt;&lt; \"Copy construct\" &lt;&lt; std::endl; }\n    Noisy(Noisy&amp;&amp;) { std::cout &lt;&lt; \"Move construct\" &lt;&lt; std::endl; }\n    Noisy&amp; operator=(const Noisy&amp;) { std::cout &lt;&lt; \"Copy assignment\" &lt;&lt; std::endl; return *this; }\n    Noisy&amp; operator=(Noisy&amp;&amp;) { std::cout &lt;&lt; \"Move assignment\" &lt;&lt; std::endl; return *this; }\n    ~Noisy() { std::cout &lt;&lt; \"Destructor\" &lt;&lt; std::endl; }\n};\n\nNoisy f(Noisy a) {\n    return a;\n}\n\nint main(void) {\n    Noisy a;\n    Noisy b = f(a);\n}\n</code></pre>\n<p>Compiled with gcc-4.9.1 using options <code>g++ -fno-elide-constructors -std=c++11 t.cc</code> gives output:</p>\n<pre><code>Default construct // 1. 'a' is default constructed.\nCopy construct    // 2. Local argument 'a' in function 'f' is copied.\nMove construct    // 3. Return value is move constructed (*see note below).\nMove construct    // 4. 'b' is move constructed from return value.\nDestructor        // 5. Local argument 'a' is destroyed.\nDestructor        // 6. Return value is destroyed.\nDestructor        // 7. 'b' is destroyed.\nDestructor        // 8. 'a' is destroyed.\n</code></pre>\n<p><sub><strong>Note:</strong> Even though local argument <code>a</code> is an lvalue, the compiler knows it's about to go out of scope and considers it as an rvalue.</sub></p>\n<p>Compiling <em>without</em> option <code>-fno-elide-constructors</code> will enable compiler copy elision optimizations and yields output:</p>\n<pre><code>Default construct // 1. 'a' is default constructed.\nCopy construct    // 2. Local argument 'a' in function 'f' is copied.\nMove construct    // 3. 'b' is move constructed from argument 'a' (elision).\nDestructor        // 4. Local argument 'a' is destroyed.\nDestructor        // 5. 'b' is destroyed.\nDestructor        // 6. 'a' is destroyed.\n</code></pre>\n<p>Compiling with <code>-std=c++03</code> i.e. C++03 will result in all moves being replaced with copies.</p>\n<p>For more info about <strong>copy elision</strong> see here: <a href=\"https://stackoverflow.com/q/12953127/873025\">What are copy elision and return value optimization?</a></p>\n", "LastActivityDate": "2014-10-22T11:50:58.847"}, "bq_ids": {"n4140": {"so_26493902_26494575_0": {"section_id": 480, "quality": 1.0, "length": 35}, "so_26493902_26494575_1": {"section_id": 481, "quality": 0.6896551724137931, "length": 20}}, "n3337": {"so_26493902_26494575_0": {"section_id": 471, "quality": 1.0, "length": 35}, "so_26493902_26494575_1": {"section_id": 472, "quality": 1.0, "length": 29}}, "n4659": {"so_26493902_26494575_1": {"section_id": 504, "quality": 0.5517241379310345, "length": 16}, "so_26493902_26494575_0": {"section_id": 502, "quality": 0.8857142857142857, "length": 31}}}});