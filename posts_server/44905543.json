post_cb({"bq_ids": {"n4140": {"so_44905543_44906006_0": {"length": 23, "quality": 0.92, "section_id": 6365}}, "n3337": {"so_44905543_44906006_0": {"length": 23, "quality": 0.92, "section_id": 6122}}, "n4659": {"so_44905543_44906006_0": {"length": 23, "quality": 0.92, "section_id": 7876}}}, "44906174": {"Id": "44906174", "PostTypeId": "2", "Body": "<p>In your particular case, nothing happens, since both <code>Base</code> and <code>Foo</code> are empty classes.</p>\n<p>For the more interesting situation that both <code>Base</code> and <code>Foo</code> have some movable members (or bases), since <code>Base</code> has no user-defined move constructor, the default move constructor will be used. <strong>This will move the <code>Base</code> part of <code>foo</code> to <code>moved</code>, but leave the rest intact.</strong> For example, after</p>\n<pre><code>struct Base      { std::unique_ptr&lt;int&gt; X; };\nstruct Foo: Base { std::unique_ptr&lt;int&gt; Y; };\n\nFoo foo;\nfoo.X.reset(new int);\nfoo.Y.reset(new int);\nBase &amp;base = foo;\nBase moved = std::move(base);\n</code></pre>\n<p><code>foo.X</code> is empty (<code>nullptr</code>) with the original value moved to <code>moved</code>, but still <code>foo.Y</code> still holds the initial value.</p>\n<p>This demonstrates that when moving from a reference you potentially change the state of the referred to object, which can create all sorts of unwanted effects and is best avoided.</p>\n", "LastActivityDate": "2017-07-04T12:35:52.977", "CommentCount": "0", "CreationDate": "2017-07-04T12:35:52.977", "ParentId": "44905543", "Score": "1", "OwnerUserId": "1023390"}, "44906006": {"Id": "44906006", "PostTypeId": "2", "Body": "<p>The standard does not make any such requirement on move constructors for C++ classes that are not a part of the standard library.  The library writer is free to do what they want.  For components that are a part of the standard library, the C++17 standard does say something (emphasis mine)</p>\n<p><strong>\u00a7\u00a020.5.5.15 Moved-from state of library types [lib.types.movedfrom]</strong></p>\n<blockquote>\n<p id=\"so_44905543_44906006_0\">Objects of types defined in the C++ standard library may be moved from (15.8). Move operations may be explicitly specified or implicitly generated. <strong>Unless otherwise specified, such moved-from objects shall be placed in a valid but unspecified state.</strong></p>\n</blockquote>\n<p>For classes in the standard library that are a part of an inheritance hierarchy, you would have to consult the documentation to see what happens when you try and move construct a base object from a base class rvalue reference a derived class object.  So if you could specify which class in particular you were worried about I could try and help more.  </p>\n<hr>\n<p>Not sure how relevant this is to your question, but regarding what would really happen in such a constructor.  Remember that the virtual function mechanism is disabled in constructors for the object that is going to be constructed,  but <em>not</em> for the referenced object.  In the following example</p>\n<pre><code>class Base {\npublic:\n    virtual vector&lt;int&gt; extract_vector() { ... }\n\n    // Move constructor can use virtual functions on the other object\n    Base(Base&amp;&amp; other) {\n        this-&gt;vec = other.extract_vector();\n    }\n\nprivate:\n    std::vector&lt;int&gt; vec;\n};\n\nclass Foo : public Base {\npublic:\n    vector&lt;int&gt; extract_vector() override { ... }\n\nprivate:\n    // this does something \u00af\\\\_(\u30c4)_/\u00af \n    SpecialVectorAdaptor&lt;std::vector&lt;int&gt;&gt; vec;\n};\n</code></pre>\n<p>The virtual function <code>extract_vector</code> on <code>other</code> in the move constructor for <code>Base</code> will be called, and you can utilize virtual methods on the <code>other</code> object.  But you cannot use any such virtual methods on the class that is going to be constructed.  </p>\n<hr>\n<p><strong>So long story short</strong>, the behavior of the code you have shown will depend strictly on the implementation of the classes in question.  </p>\n</hr></hr>", "LastEditorUserId": "5501675", "LastActivityDate": "2017-07-04T12:33:46.623", "Score": "1", "CreationDate": "2017-07-04T12:28:23.660", "ParentId": "44905543", "CommentCount": "0", "OwnerUserId": "5501675", "LastEditDate": "2017-07-04T12:33:46.623"}, "44905543": {"ViewCount": "84", "Body": "<p>Assume, there is a hierarchy of two classes:</p>\n<pre><code>class Base {};\nclass Foo: public Base {};\n</code></pre>\n<p>Which are used like this:</p>\n<pre><code>Foo foo;\nBase &amp;base = foo;\nBase moved = std::move(base);\n</code></pre>\n<p>In what state is <code>foo</code> after such move? Does the Standard impose any requirements on limitations on such code?</p>\n", "AcceptedAnswerId": "44906006", "Title": "What is a state of an object after it was moved-from via a reference to its base class?", "CreationDate": "2017-07-04T12:04:56.357", "Id": "44905543", "CommentCount": "12", "LastEditDate": "2017-07-04T12:07:14.487", "PostTypeId": "1", "LastEditorUserId": "2508253", "LastActivityDate": "2017-07-04T12:35:52.977", "Score": "3", "OwnerUserId": "2508253", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}});