post_cb({"bq_ids": {"n4140": {"so_19351082_19351104_3": {"length": 43, "quality": 0.9555555555555556, "section_id": 6095}, "so_19351082_19351104_2": {"length": 4, "quality": 0.8, "section_id": 6095}, "so_19351082_19351104_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 6092}, "so_19351082_19351104_1": {"length": 5, "quality": 1.0, "section_id": 6095}}, "n3337": {"so_19351082_19351104_2": {"length": 4, "quality": 0.8, "section_id": 5861}, "so_19351082_19351104_1": {"length": 5, "quality": 1.0, "section_id": 5861}, "so_19351082_19351104_0": {"length": 26, "quality": 0.9285714285714286, "section_id": 5859}, "so_19351082_19351104_3": {"length": 43, "quality": 0.9555555555555556, "section_id": 5861}}, "n4659": {"so_19351082_19351104_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 7588}, "so_19351082_19351104_3": {"length": 42, "quality": 0.9333333333333333, "section_id": 7592}}}, "19351082": {"ViewCount": "181", "Body": "<p>I'm playing new operator overloading recently. I noticed a strange behavior when I overload new[] operator (the new operator for allocating arrays).</p>\n<p>Here is my code:\n</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Pool\n{\npublic:\n    void* alloc(size_t size) {\n        return malloc(size);\n    }\n};\n\nclass MyClass\n{\npublic:\n    MyClass() {\n        cout&lt;&lt;\"ctor called\"&lt;&lt;endl;\n    }\n    ~MyClass() {\n        cout&lt;&lt;\"dtor called\"&lt;&lt;endl;\n    }\n    void* operator new(size_t size) {\n        cout&lt;&lt;\"new called, size: \"&lt;&lt;size&lt;&lt;endl;\n        return (void*)malloc(size);\n    }\n    void* operator new[](size_t size) {\n        cout&lt;&lt;\"new[] called, size: \"&lt;&lt;size&lt;&lt;endl;\n        void* result = (void*)malloc(size);\n        cout&lt;&lt;\"in new[]: \"&lt;&lt;result&lt;&lt;endl;\n        return result;\n    }\n    void* operator new(size_t size, void* ptr) {\n        cout&lt;&lt;\"new(ptr) called, size: \"&lt;&lt;size&lt;&lt;endl;\n        return (void*)ptr;\n    }\n    void* operator new(size_t size, Pool&amp; pool) {\n        cout&lt;&lt;\"new(Pool) called, size: \"&lt;&lt;size&lt;&lt;endl;\n        return (void*)pool.alloc(size);\n    }\n    void operator delete(void* ptr) {\n        cout&lt;&lt;\"delete called, ptr: \"&lt;&lt;ptr&lt;&lt;endl;\n        free(ptr);\n    }\n    void operator delete(void* ptr, size_t size) {\n        cout&lt;&lt;\"delete called, ptr: \"&lt;&lt;ptr&lt;&lt;\", size: \"&lt;&lt;size&lt;&lt;endl;\n        free(ptr);\n    }\n    void operator delete[](void* ptr) {\n        cout&lt;&lt;\"delete[] called, ptr: \"&lt;&lt;ptr&lt;&lt;endl;\n        free(ptr);\n    }\n    void operator delete[](void* ptr, size_t size) {\n        cout&lt;&lt;\"delete[] called, ptr: \"&lt;&lt;ptr&lt;&lt;\", size: \"&lt;&lt;size&lt;&lt;endl;\n        free(ptr);\n    }\n    uint32_t data;\n};\n\nint main() {\n    Pool pool;\n    cout&lt;&lt;\"Pool\"&lt;&lt;endl;\n    new Pool;\n    cout&lt;&lt;\"MyClass\"&lt;&lt;endl;\n    MyClass *ptr1, *ptr2, *ptr3;\n    ptr1 = new MyClass;\n    ptr2 = new MyClass[10]();\n    cout&lt;&lt;(void*)ptr2&lt;&lt;endl;\n    ptr3 = new(pool) MyClass;\n    delete ptr1;\n    delete[] ptr2;\n    delete ptr3;\n\n    return 0;\n}\n</code></pre>\n<p>And the result (with gcc 64bit on OS X) is like:</p>\n<pre><code>Pool\nMyClass\nnew called, size: 4\nctor called\nnew[] called, size: 48\nin new[]: 0x7fa7f0403840\nctor called\nctor called\nctor called\nctor called\nctor called\nctor called\nctor called\nctor called\nctor called\nctor called\n0x7fa7f0403848\nnew(Pool) called, size: 4\nctor called\ndtor called\ndelete called, ptr: 0x7fa7f0403830\ndtor called\ndtor called\ndtor called\ndtor called\ndtor called\ndtor called\ndtor called\ndtor called\ndtor called\ndtor called\ndelete[] called, ptr: 0x7fa7f0403840\ndtor called\ndelete called, ptr: 0x7fa7f0403870\n</code></pre>\n<p>I noticed three things: 1st, I asked to allocate 10 objects of 4 bytes in new[], but the actual request received by the function is 48 bytes. 2nd, apparently the first 8 bytes are used for other purpose: the actual address received by <code>ptr2</code> is 8 bytes after the address returned by the new[] operator. 3rd, the address is also automatically translated (by going forward 8 bytes) in the overloaded delete[] function.</p>\n<p>I also noticed that this behavior happens only when I explicitly implement the destructor. If I only use the default destructor, the 8 bytes are just gone.</p>\n<p>Can anyone tell me what is happening behind this? What are the 8 bytes used for?</p>\n<p>Thanks.</p>\n", "AcceptedAnswerId": "19351104", "Title": "difference between return address of operator new[] and the actual address got for the array", "CreationDate": "2013-10-13T22:33:12.527", "Id": "19351082", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2013-10-13T22:40:51.393", "Score": "1", "OwnerUserId": "430665", "Tags": "<c++><operator-overloading><new-operator>", "AnswerCount": "1"}, "19351104": {"Id": "19351104", "PostTypeId": "2", "Body": "<p>The array-new expression is allowed to call the array-operator-new with more space than needed for the array. All that's required is that the <em>value</em> of the array-new expression is a pointer to the first element in the array.</p>\n<p>Practically, the extra space is needed to store information on how many elements need to be destroyed when the array is destroyed (sometimes called an \"array cookie\").</p>\n<p>It's interesting to note that the actual amount of extra memory that is requested from the array-operator-new function is completely unknowable and may change with every call. This basically makes the <a href=\"https://stackoverflow.com/q/8720425/596781\">array-placement-new expression defective and unusable</a>.</p>\n<p>Just for reference, the relevant clause is C++11 5.3.4/10:</p>\n<blockquote>\n<p id=\"so_19351082_19351104_0\">A <em>new-expression</em> passes the amount of space requested to the allocation function as the first argument of type <code>std::size_t</code>. That argument shall be no less than the size of the object being created; it may be greater than the size of the object being created only if the object is an array.</p>\n</blockquote>\n<p>The most interesting example follows just below:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_19351082_19351104_1\"><code>new T[5]</code> results in a call of <code>operator new[](sizeof(T) * 5 + x)</code>, and</p></li>\n<li><p id=\"so_19351082_19351104_2\"><code>new(2,f) T[5]</code> results in a call of <code>operator new[](sizeof(T) * 5 + y, 2, f)</code>.</p></li>\n</ul>\n<p id=\"so_19351082_19351104_3\">Here, <code>x</code> and <code>y</code> are non-negative unspecified values representing array allocation overhead; the result of the\n  new-expression will be offset by this amount from the value returned by <code>operator new[]</code>. This overhead may be applied in all array <em>new-expressions</em>, including those referencing the library function <code>operator new[](std::size_t, void*)</code> and other placement allocation functions. The amount of overhead may vary from one invocation of new to another.</p>\n</blockquote>\n<hr>\n<p>You may be pleased to learn that the <a href=\"http://mentorembedded.github.io/cxx-abi/abi.html#array-cookies\" rel=\"nofollow noreferrer\">Itanium ABI</a> has very sensible rules about array cookies; for example, none are needed for arrays of trivially-destructible objects.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-10-13T22:40:51.393", "Score": "3", "CreationDate": "2013-10-13T22:34:45.867", "ParentId": "19351082", "CommentCount": "5", "OwnerUserId": "596781", "LastEditDate": "2017-05-23T12:10:57.810"}});