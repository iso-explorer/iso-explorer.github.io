post_cb({"bq_ids": {"n4140": {"so_10448714_10449036_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 5876}, "so_10448714_10449036_1": {"length": 20, "quality": 0.5263157894736842, "section_id": 5879}}, "n3337": {"so_10448714_10449036_0": {"length": 22, "quality": 1.0, "section_id": 5647}, "so_10448714_10449036_1": {"length": 35, "quality": 0.9210526315789473, "section_id": 5650}}, "n4659": {"so_10448714_10449036_0": {"length": 18, "quality": 0.8181818181818182, "section_id": 7361}, "so_10448714_10449036_1": {"length": 20, "quality": 0.5263157894736842, "section_id": 7363}}}, "10448755": {"Id": "10448755", "PostTypeId": "2", "Body": "<p>If you want to assume it and you have a compile-time check, then go ahead.  Presumably you get some benefit out of doing this.</p>\n<p>You aren't guaranteed anything about padding, but typically padding is used to get alignment so that arrays of the type have every member of the array (and every member of the struct) aligned properly.  A native pointer is usually already the right size to be aligned, so padding isn't needed, but you aren't guaranteed that.</p>\n<p>This isn't something you can just check with gcc -- it depends on the target architecture, not only the compiler.  </p>\n", "LastActivityDate": "2012-05-04T12:25:09.727", "CommentCount": "2", "CreationDate": "2012-05-04T12:25:09.727", "ParentId": "10448714", "Score": "3", "OwnerUserId": "3937"}, "10449058": {"Id": "10449058", "PostTypeId": "2", "Body": "<p>I'd say your assumption is reasonable with most compilers and flags.</p>\n<p>For any T, the compiler is able to create arrays of T, which are required to be contiguous, so it has to be able to create that without padding. As such, any padding it put into your struct would be purely optional, not something that could be required.</p>\n<p>On the other hand, I'm reasonably certain none of the C or C++ standards guarantees what you're asking. The <em>closest</em> to guarantees about it would stem from the fact that in C++ it's a <em>standard layout</em> struct, which restricts the C++ compiler to laying out the fields about like a C compiler would, so the members must be ascending order with no padding at the beginning -- but padding between members and/or after the last member are still allowed.</p>\n<p>Bottom line: if you have a pointer to the first member, you can convert to pointer to struct (or vice versa) safely. You're on your own if you do something like creating an array of one and indexing into it as if it were an array of the other -- chances of it working are quite good, but I'm pretty sure the standard doesn't guarantee it.</p>\n", "LastActivityDate": "2012-05-04T12:44:56.517", "CommentCount": "0", "CreationDate": "2012-05-04T12:44:56.517", "ParentId": "10448714", "Score": "1", "OwnerUserId": "179910"}, "10449036": {"Id": "10449036", "PostTypeId": "2", "Body": "<p>Looking into the standard I found two interesting bits in <strong>\u00a7 9.2 [class.mem]</strong>:</p>\n<blockquote>\n<p id=\"so_10448714_10449036_0\"><strong>17/</strong> Two standard-layout struct (Clause 9) types are layout-compatible if they have the same number of non-static data members and corresponding non-static data members (in declaration order) have layout-compatible types (3.9).</p>\n</blockquote>\n<p>So, two <code>struct</code> with only a pointer in them would be layout compatible (thus if your assertion holds for this type, it holds for all types).</p>\n<blockquote>\n<p id=\"so_10448714_10449036_1\"><strong>20/</strong> A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [ Note: There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning, as necessary to achieve appropriate alignment. \u2014end note ]</p>\n</blockquote>\n<p>In the note we learn that there cannot be padding at the beginning of a structure.</p>\n<hr>\n<p>Depending on your goal, <strong>20/</strong> might be sufficient. It means that this works:</p>\n<pre><code>void check(T* t) {\n    Wrapper&lt;T&gt;* w = reinterpret_cast&lt;Wrapper&lt;T&gt;*&gt;(t);\n    assert(w-&gt;t_ == t);\n}\n</code></pre>\n</hr>", "LastActivityDate": "2012-05-04T12:43:54.333", "CommentCount": "0", "CreationDate": "2012-05-04T12:43:54.333", "ParentId": "10448714", "Score": "1", "OwnerUserId": "147192"}, "10448714": {"ViewCount": "180", "Body": "<p>Suppose I have the following class template:</p>\n<pre><code>template&lt;typename T&gt;\nstruct Wrapper {\n  T* t_;\n  static void check() {\n    static_assert(sizeof(Wrapper&lt;T&gt; == sizeof(T*), \"Illegal assumption\");\n  }\n};\n</code></pre>\n<p>I looked in the C99 standard an in the C++03 standard and cannot find a guarantee for my assumption expressed in the <code>static_assert</code>. I tried it on Visual C++ 2008 and 2010 (32bit) and gcc on linux (64bit) using several compiler options and found my assumption confirmed.<br><br>\nMy question are:</br></br></p>\n<ul>\n<li>Is my assumption reasonable for Visual C++ 2008/2010/11 (windows)?</li>\n<li>For gcc 4.* (linux)?</li>\n<li>For any combination of compiler flags?</li>\n<li>Do you know of any compiler/platform where this assumption does not hold true?</li>\n</ul>\n<p>I guess a compiler might add some padding to the struct e.g. for debugging purposes. But is there a compiler that actually does that?</p>\n<p><strong>Edit:</strong> So as you asked here is what I want to achieve:<br>\nI have the member function with the following signature:</br></p>\n<pre><code>Someclass* OtherClass::fn();\n</code></pre>\n<p>I want to change the signature like this:</p>\n<pre><code>Wrapper&lt;Someclass&gt; OtherClass::fn();\n</code></pre>\n<p>This wrapper acts like some smart-pointer, i.e. it cares for the pointer's lifetime, thus it releases it when it goes out of scope. As the function is called across a dll boundary I want to make sure that the returned value (which is now a concrete type, not just a dumb pointer) is in all circumstances (i.e. compiler settings, etc) of the same size as the pointer would be. The plan/hope is to support all combination of debug/release application/dll builds.<br>\nAs you might ask: no, I can not use boost::shared_ptr&lt;&gt;, std::shared_ptr&lt;&gt;, std::unique_ptr&lt;&gt; and the like, as we don't want to expose boost to the dll user and we don't support C++11 yet.</br></p>\n", "AcceptedAnswerId": "10448755", "Title": "Size of a struct containing 1 Pointer", "CreationDate": "2012-05-04T12:20:36.607", "Id": "10448714", "CommentCount": "7", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-05-04T14:50:26.643", "LastEditorUserId": "1303356", "LastActivityDate": "2012-05-04T14:50:26.643", "Score": "5", "OwnerUserId": "1303356", "Tags": "<c++><visual-c++><g++>", "AnswerCount": "3"}});