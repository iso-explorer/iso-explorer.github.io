post_cb({"14352408": {"ParentId": "14352373", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>This is the C++ object model. You're guaranteed that within the same access level (<code>private</code>/<code>public</code>/<code>protected</code>), the object properties are in order (C++11), and the same for members without access specifiers between them (in C++03).</p>\n<p>This doesn't mean what you're doing is a good idea. It's better to avoid the cast and just have the function do some more work.</p>\n<h2>C++11:</h2>\n<h3>9.2 Class members [class.mem]</h3>\n<blockquote>\n<p id=\"so_14352373_14352408_0\">14) <strong>Nonstatic data members of a (non-union) class with the same access control (Clause 11) are allocated so\n  that later members have higher addresses within a class object. The order of allocation of non-static data\n  members with different access control is unspecified (11)</strong>. Implementation alignment requirements might\n  cause two adjacent members not to be allocated immediately after each other; so might requirements for\n  space for managing virtual functions (10.3) and virtual base classes (10.1).</p>\n</blockquote>\n<h2>C++03</h2>\n<h3>9.2 Class members [class.mem]</h3>\n<blockquote>\n<p id=\"so_14352373_14352408_1\">12) <strong>Nonstatic data members of a (non-union) class declared without an intervening access-specifier are allocated so\n  that later members have higher addresses within a class object. The order of allocation of non-static data\n  members separated by an access-specifier is unspecified (11.1)</strong>. Implementation alignment requirements might\n  cause two adjacent members not to be allocated immediately after each other; so might requirements for\n  space for managing virtual functions (10.3) and virtual base classes (10.1).</p>\n</blockquote>\n", "OwnerUserId": "673730", "LastEditorUserId": "673730", "LastEditDate": "2013-01-16T09:55:57.910", "Id": "14352408", "Score": "7", "CreationDate": "2013-01-16T06:18:44.280", "LastActivityDate": "2013-01-16T09:55:57.910"}, "bq_ids": {"n4140": {"so_14352373_14352408_0": {"section_id": 5873, "quality": 0.9423076923076923, "length": 49}, "so_14352373_14352408_1": {"section_id": 5873, "quality": 0.8235294117647058, "length": 42}}, "n3337": {"so_14352373_14352408_0": {"section_id": 5644, "quality": 0.9423076923076923, "length": 49}, "so_14352373_14352408_1": {"section_id": 5644, "quality": 0.8235294117647058, "length": 42}}, "n4659": {"so_14352373_14352408_0": {"section_id": 7356, "quality": 0.9423076923076923, "length": 49}, "so_14352373_14352408_1": {"section_id": 7356, "quality": 0.8235294117647058, "length": 42}}}, "14352373": {"CommentCount": "0", "ViewCount": "1087", "CreationDate": "2013-01-16T06:16:02.293", "LastActivityDate": "2013-01-16T09:55:57.910", "Title": "Classes store data members in sequential memory?", "AcceptedAnswerId": "14352408", "PostTypeId": "1", "Id": "14352373", "Score": "3", "Body": "<p>The short version of this question: Does a pointer to the first data member of a class result in a pointer to all its data members?</p>\n<p>Discussion:</p>\n<p>I'm reading some sample code, and this is interesting. When a particular function (in this case the <code>glUniformMatrix4fv</code> C function from OpenGL) takes as a parameter an array, this is passed in the common C way of using a pointer to the address of the array's first element, as follows:</p>\n<p><code>glUniformMatrix4fv(glvariable, 1, 0, &amp;newmatrix[0]);</code>  // referring to newmatrix</p>\n<p>This developer has a C++ class for creating a 4X4 matrix, for a total of 16 floats. However, the data members of that class are divided into 4 separate vectors of 4 data members each:</p>\n<p>Here are the data members of the class:</p>\n<pre><code>vec4 x;\nvec4 y;\nvec4 z;\nvec4 w;\n</code></pre>\n<p>The <code>vec4</code> class in turn provides these data members:</p>\n<pre><code>T x;\nT y;\nT z;\nT w;\n</code></pre>\n<p>He then creates a function to point to just the first <code>vec4 x</code> data member:</p>\n<pre><code>    const T* Pointer() const\n{\n    return &amp;x.x;\n}\n</code></pre>\n<p>And somehow, this miraculously translates into sending all 4 <code>vec4</code> objects and their respective 4 components:</p>\n<pre><code>glUniformMatrix4fv(modelviewUniform, 1, 0, modelviewMatrix.Pointer());\n</code></pre>\n<p>I'm fairly new to C++ but this surprised me that you can point to just one data member and expect all the rest to get sent as well. Is it because the class defines them in a particular order? What if they had been defined in a different order in the class definition?</p>\n", "Tags": "<c++><opengl><pointers><opengl-es>", "OwnerUserId": "3758484", "AnswerCount": "1"}});