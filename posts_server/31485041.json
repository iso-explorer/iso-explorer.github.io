post_cb({"31485041": {"CommentCount": "2", "AcceptedAnswerId": "31485150", "CreationDate": "2015-07-17T21:32:44.500", "LastActivityDate": "2015-07-18T06:54:19.070", "PostTypeId": "1", "ViewCount": "2574", "FavoriteCount": "3", "Title": "lambda capture by value mutable doesn't work with const &?", "Id": "31485041", "Score": "13", "Body": "<p>Consider the following:</p>\n<pre><code>void test( const int &amp;value )\n{\n    auto testConstRefMutableCopy = [value] () mutable {\n        value = 2; // compile error: Cannot assign to a variable captured by copy in a non-mutable lambda\n    };\n\n    int valueCopy = value;\n    auto testCopyMutableCopy = [valueCopy] () mutable {\n        valueCopy = 2; // compiles OK\n    };\n}\n</code></pre>\n<p>Why is the first version a compile error when I've declared the lambda as mutable and captured <code>value</code> by value (which I thought made a copy of it)?</p>\n<p>Tested with clang (x86_64-apple-darwin14.3.0), which is where the error message comes from, and Visual C++ (vc120).</p>\n", "Tags": "<c++><c++11><lambda>", "OwnerUserId": "506584", "AnswerCount": "2"}, "31485150": {"ParentId": "31485041", "PostTypeId": "2", "CommentCount": "7", "Body": "<blockquote>\n<p id=\"so_31485041_31485150_0\"><code>[C++11: 5.1.2/14]:</code> <strong>An entity is <em>captured by copy</em></strong> if it is implicitly captured and the <em>capture-default</em> is <code>=</code> or <strong>if it is explicitly captured with a capture that does not include an <code>&amp;</code></strong>. For each entity captured by copy, an unnamed non-static data member is declared in the closure type. The declaration order of these members is unspecified. <strong>The type of such a data member is the type of the corresponding captured entity if the entity is not a reference to an object, or the referenced type otherwise.</strong> <em>[..]</em></p>\n</blockquote>\n<p>The type of <code>value</code> inside your lambda is <code>const int</code>, because it was captured by copy from a <code>const int&amp;</code>.</p>\n<p>Thus, even though the lambda's call operator function is not <code>const</code> (you marked the lambda <code>mutable</code>), the actual implicit member <code>value</code> is of type <code>const int</code> and cannot be mutated.</p>\n<p>Frankly, this seems absurd; I would expect this rule to say that the referenced type loses <code>const</code>ness, as it's a copy. The presence or absence of the <code>mutable</code> keyword on the lambda itself (and, thus, the presence or absence of the <code>const</code> keyword on the generated call operator function) should be the only access control here.</p>\n<p>In C++14 you can work around this by capturing as <code>[value=value]</code>, which uses the same rules as <code>auto</code> and thus drops the <code>const</code>. C++'s great, ain't it?</p>\n", "OwnerUserId": "560648", "LastEditorUserId": "560648", "LastEditDate": "2015-07-18T06:54:19.070", "Id": "31485150", "Score": "16", "CreationDate": "2015-07-17T21:42:36.873", "LastActivityDate": "2015-07-18T06:54:19.070"}, "bq_ids": {"n4140": {"so_31485041_31485150_0": {"section_id": 5974, "quality": 0.8222222222222222, "length": 37}}, "n3337": {"so_31485041_31485150_0": {"section_id": 5742, "quality": 0.8666666666666667, "length": 39}}, "n4659": {"so_31485041_31485150_0": {"section_id": 7473, "quality": 0.7555555555555555, "length": 34}}}, "31485096": {"ParentId": "31485041", "PostTypeId": "2", "CommentCount": "0", "Body": "<p><code>mutable</code> allows a lambda to modify copy of a non-const parameter captured by copy, but it does not allow it for <code>const</code> parameters.</p>\n<p>So this code works (and outputs <code>inside 2 outside 1</code>):</p>\n<pre><code>int a = 1;\n[a]() mutable {\n    a = 2; // compiles OK\n    cout &lt;&lt; \"inside \" &lt;&lt; a &lt;&lt; \"\\n\";\n}();\ncout &lt;&lt; \" outside \" &lt;&lt; a &lt;&lt; \"\\n\";\n</code></pre>\n<p>But if we omit <code>mutable</code>, or make a <code>const int</code>, the compiler gives an error.</p>\n<p>In our case, the first lambda gives an error because <code>value</code> is <code>const</code>:</p>\n<pre><code>void test( const int &amp;value )\n</code></pre>\n<p>If we make <code>copyValue</code> <code>const</code>:</p>\n<pre><code>const int valueCopy = value;\n</code></pre>\n<p>then the same error will occur with the second lambda.</p>\n", "OwnerUserId": "3246555", "LastEditorUserId": "3246555", "LastEditDate": "2015-07-17T22:11:55.347", "Id": "31485096", "Score": "4", "CreationDate": "2015-07-17T21:37:40.283", "LastActivityDate": "2015-07-17T22:11:55.347"}});