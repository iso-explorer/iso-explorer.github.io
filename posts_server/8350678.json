post_cb({"8351334": {"ParentId": "8350678", "CommentCount": "1", "Body": "<p>I can't see any reason why it would ever be called. The conversion functions are called to... convert. If you already have the right type, there is absolutely no reason to add a conversion operation before the copy.</p>\n", "OwnerUserId": "1024088", "PostTypeId": "2", "Id": "8351334", "Score": "1", "CreationDate": "2011-12-02T03:10:04.970", "LastActivityDate": "2011-12-02T03:10:04.970"}, "8350678": {"CommentCount": "0", "AcceptedAnswerId": "8351375", "CreationDate": "2011-12-02T01:27:08.867", "LastActivityDate": "2016-02-05T09:50:03.587", "PostTypeId": "1", "ViewCount": "377", "FavoriteCount": "0", "Title": "Under what circumstances would a type's conversion operator to itself be invoked?", "Id": "8350678", "Score": "11", "Body": "<p>Consider a type <code>bar</code> which has user-defined conversion operators to references of type <code>bar</code>:</p>\n<pre><code>struct bar\n{\n  operator bar &amp; ();\n  operator const bar &amp; () const;\n};\n</code></pre>\n<p>When would these conversions be applied? Moreover, what does it imply if these operators were <code>deleted</code>? Is there any interesting use of either feature?</p>\n<p>The following program does not appear to apply either conversion:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct bar\n{\n  operator bar &amp; ()\n  {\n    std::cout &lt;&lt; \"operator bar &amp;()\" &lt;&lt; std::endl;\n    return *this;\n  }\n\n  operator const bar &amp; () const\n  {\n    std::cout &lt;&lt; \"operator const bar &amp;() const\" &lt;&lt; std::endl;\n    return *this;\n  }\n};\n\nvoid foo(bar x)\n{\n}\n\nint main()\n{\n  bar x;\n\n  bar y = x;         // copy, no conversion\n\n  y = x;             // assignment, no conversion\n\n  foo(x);            // copy, no conversion\n\n  y = (bar&amp;)x;       // no output\n\n  y = (const bar&amp;)x; // no output\n\n  return 0;\n}\n</code></pre>\n", "Tags": "<c++><operator-overloading>", "OwnerUserId": "722294", "AnswerCount": "4"}, "35220969": {"ParentId": "8350678", "CommentCount": "0", "Body": "<p>Just for the record. I managed to create this kind of structure in a bigger software project, blindly trusted the compiler warning and removed the \"never used method\". Well, I guess I found a scenario where it is actually called. The compiler seems to miss the base class.</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct D;\nstruct B\n{\n    virtual operator D&amp; ()\n    {\n        throw \"foo\";\n    }\n};\n\nstruct D : public B\n{\n    virtual operator D&amp; ()\n    {\n        std::cout &lt;&lt; \"bar\" &lt;&lt; std::endl;\n        return *this;\n    }\n};\n\nint main()\n{\n    B* b = new D();\n    D&amp; d = *b;\n\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "325334", "PostTypeId": "2", "Id": "35220969", "Score": "0", "CreationDate": "2016-02-05T09:50:03.587", "LastActivityDate": "2016-02-05T09:50:03.587"}, "8351375": {"ParentId": "8350678", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>C++11 \u00a712.3.2</p>\n<blockquote>\n<p id=\"so_8350678_8351375_0\">A conversion function is never used to convert a (possibly cv-qualified) object to the (possibly cv-qualified) same object type (or a reference to it), to a (possibly cv-qualified) base class of that type (or a reference to it), or to (possibly cv-qualified) void</p>\n</blockquote>\n", "OwnerUserId": "464581", "LastEditorUserId": "50776", "LastEditDate": "2011-12-03T02:27:33.893", "Id": "8351375", "Score": "9", "CreationDate": "2011-12-02T03:15:39.917", "LastActivityDate": "2011-12-03T02:27:33.893"}, "14663727": {"ParentId": "8350678", "CommentCount": "0", "Body": "<p>The feature that you are allowed to define a conversion function from a type to itself, but that the conversion function is never used, can be a useful feature in template programming, where two type parameters may or may not refer to the same type, depending on the instantiation. Some code of mine relies on this feature.  It saves having to provide specializations for cases where two or more of the type parameters end up referring to the same type.</p>\n", "OwnerUserId": "1958486", "PostTypeId": "2", "Id": "14663727", "Score": "2", "CreationDate": "2013-02-02T16:05:24.770", "LastActivityDate": "2013-02-02T16:05:24.770"}, "bq_ids": {"n4140": {"so_8350678_8351375_0": {"section_id": 391, "quality": 1.0, "length": 22}}, "n3337": {"so_8350678_8351375_0": {"section_id": 382, "quality": 1.0, "length": 22}}, "n4659": {"so_8350678_8351375_0": {"section_id": 408, "quality": 1.0, "length": 22}}}});