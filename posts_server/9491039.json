post_cb({"9491039": {"CommentCount": "9", "ViewCount": "199", "CreationDate": "2012-02-28T22:49:07.070", "LastActivityDate": "2012-02-28T23:20:42.373", "Title": "Is this legal C++ code?", "AcceptedAnswerId": "9491245", "PostTypeId": "1", "Id": "9491039", "Score": "-2", "Body": "<p>I'm interested in answers citing a concrete passage in the standard, not just general opinions.</p>\n<pre><code>template &lt;class T&gt; struct wrapped\n{\n       wrapped(const T&amp;) {}\n};\n\ntemplate &lt;class T&gt; wrapped&lt;T&gt; wrappit(const T&amp; x)\n{\n       return wrapped&lt;T&gt;(x);\n}\n\ntemplate &lt;class T&gt; int run_function(const T&amp; x, bool wrapped)\n{\n       if (wrapped) {\n               return 0;\n       } else {\n               return run_function(wrappit(x), true) + 1;\n       }\n}\n\nint main()\n{\n       const int result = run_function(0.5, false);\n       return result;\n}\n</code></pre>\n", "Tags": "<c++><standards>", "OwnerUserId": "59557", "AnswerCount": "2"}, "9491127": {"ParentId": "9491039", "CommentCount": "4", "Body": "<p>A conforming implementation may reject this code.  See Annex B of the Standard.</p>\n<p>Your implementation is supposed to include certain limits in its documentation, these include:</p>\n<ul>\n<li>Recursively nested template instantiations</li>\n</ul>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "9491127", "Score": "5", "CreationDate": "2012-02-28T22:59:07.533", "LastActivityDate": "2012-02-28T22:59:07.533"}, "bq_ids": {"n4140": {"so_9491039_9491245_0": {"section_id": 249, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_9491039_9491245_0": {"section_id": 240, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_9491039_9491245_0": {"section_id": 256, "quality": 0.6666666666666666, "length": 4}}}, "9491245": {"ParentId": "9491039", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>From 14.7.1(15):</p>\n<blockquote>\n<p id=\"so_9491039_9491245_0\">The result of an in\ufb01nite recursion in instantiation is undefined.</p>\n</blockquote>\n<hr>\n<p>Regarding your code: You cannot do static conditionals with <code>if</code>. Instead, you'll need some sort of functional approach, and partial specialization:</p>\n<pre><code>template &lt;typename T, bool&gt; struct run_function;\ntemplate &lt;typename T&gt; struct run_function&lt;T, true&gt;\n{\n    static int go(T const &amp; x) { return 0; }\n};\ntemplate &lt;typename T&gt; struct run_function&lt;T, false&gt;\n{\n    static int go(T const &amp; x)\n    { return 1 + run_function&lt;T, true&gt;::go(wrappit(x)); }\n};\n</code></pre>\n<p>Now there's no more infinite recursion, because the two branches use <em>different</em> templates which eventually do not instantiate further templates.</p>\n</hr>", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2012-02-28T23:20:42.373", "Id": "9491245", "Score": "4", "CreationDate": "2012-02-28T23:09:09.620", "LastActivityDate": "2012-02-28T23:20:42.373"}});