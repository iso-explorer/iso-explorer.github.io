post_cb({"23959992": {"ParentId": "23959119", "CommentCount": "0", "Body": "<p>By the time you apply the address-of operator in your example, there is no distinction between the reference and the real object anymore. <strong>The reference <em>is</em> the object.</strong></p>\n<p>The rule instead applies at the moment you try to declare a pointer to a reference. Try it:</p>\n<pre><code>int x = 0;\nint &amp;*ptr = &amp;x;\n</code></pre>\n<p>Result with MSVC 2013:</p>\n<pre><code>error C2528: 'ptr' : pointer to reference is illegal\n</code></pre>\n", "OwnerUserId": "3313064", "PostTypeId": "2", "Id": "23959992", "Score": "0", "CreationDate": "2014-05-30T17:13:17.893", "LastActivityDate": "2014-05-30T17:13:17.893"}, "23959432": {"ParentId": "23959119", "CommentCount": "2", "Body": "<p>The unary operator &amp; returns the address of the designated object. Reference is not an object. It is reference to object. So this statement</p>\n<pre><code>cout &lt;&lt; &amp;xRef &lt;&lt; &amp;x &lt;&lt;endl;\n</code></pre>\n<p>outputs in the both cases the address of the designated object that is of x. Even though the compiler can allocate memory for a reference the reference itself has no address That is you can not apply operator &amp; that to get its address. It is the object (or a function) that is referenced to by a reference that has an address.</p>\n", "OwnerUserId": "2877241", "PostTypeId": "2", "Id": "23959432", "Score": "4", "CreationDate": "2014-05-30T16:37:16.890", "LastActivityDate": "2014-05-30T16:37:16.890"}, "23959224": {"ParentId": "23959119", "CommentCount": "1", "Body": "<p>You can think of references as <strong>aliases</strong> for objects. So, in your example, <code>&amp;xRef</code> declares <code>xRef</code> which is <strong>another name for</strong> <code>x</code>. Hence you're printing twice the adress of the same object.</p>\n", "OwnerUserId": "2567683", "PostTypeId": "2", "Id": "23959224", "Score": "2", "CreationDate": "2014-05-30T16:26:23.497", "LastActivityDate": "2014-05-30T16:26:23.497"}, "23959216": {"ParentId": "23959119", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>C++ Standard n3337 <strong>\u00a7</strong> 8.3.2/4</p>\n<blockquote>\n<p id=\"so_23959119_23959216_0\">It is unspecified whether or not a reference requires storage (3.7).</p>\n</blockquote>\n<p>So this is unspecified whether reference has storage. Most probably not. It is just alias. When you use it in the code it follows that special operations are taken by compiler, it might do some things similar to pointer operations. </p>\n", "OwnerUserId": "1141471", "LastEditorUserId": "1141471", "LastEditDate": "2014-06-16T07:27:06.103", "Id": "23959216", "Score": "9", "CreationDate": "2014-05-30T16:26:04.647", "LastActivityDate": "2014-06-16T07:27:06.103"}, "23967289": {"ParentId": "23959119", "CommentCount": "2", "Body": "<p>Just for completenesses sake: There is a way to produce a pointer to a reference.</p>\n<pre><code>auto foo(int &amp;x){\n    return [&amp;]{std::cout &lt;&lt; x;};\n}\n</code></pre>\n<p>What the compiler is allowed to do here is not to capture a reference to<code>x</code> but to capture the stack pointer instead. Based on the stack pointer the compiler knows the offsets to the various parameters of <code>foo</code> and may save some memory for the lambda. However, after the lambda has been returned the parameters of <code>foo</code> are gone and the lambda references objects that do not exist. Therefore it is forbidden / UB to do this.</p>\n", "OwnerUserId": "3484570", "PostTypeId": "2", "Id": "23967289", "Score": "0", "CreationDate": "2014-05-31T06:51:18.323", "LastActivityDate": "2014-05-31T06:51:18.323"}, "bq_ids": {"n4140": {"so_23959119_23959216_0": {"section_id": 3221, "quality": 1.0, "length": 5}}, "n3337": {"so_23959119_23959216_0": {"section_id": 3095, "quality": 1.0, "length": 5}}, "n4659": {"so_23959119_23959216_0": {"section_id": 3978, "quality": 1.0, "length": 5}}}, "23959119": {"CommentCount": "0", "AcceptedAnswerId": "23959432", "PostTypeId": "1", "LastEditorUserId": "3000680", "CreationDate": "2014-05-30T16:21:17.827", "LastActivityDate": "2014-06-16T07:27:06.103", "LastEditDate": "2014-05-30T17:27:43.560", "ViewCount": "173", "FavoriteCount": "1", "Title": "Address of a reference", "Id": "23959119", "Score": "1", "Body": "<p>So I am having a discussion with a friend about reference and pointers.</p>\n<p>What we got talking about is \"you can take an address of a pointer but you cant take an address of a reference\" </p>\n<p>And I disagree on that point. lets take an example:</p>\n<pre><code>int x = 0;\nint &amp;xRef = x;\ncout &lt;&lt; &amp;xRef &lt;&lt; &amp;x &lt;&lt;endl;\n</code></pre>\n<p>this example shows the same address, but never the less ain't I taking the address of <code>xRef</code> by doing <code>&amp;xRef</code>. Couldn't you argue that we have 2 variables with the same address, so even though I am taking the address of the reference, it is still the address of the reference (even though that is the address of x)?</p>\n", "Tags": "<c++><reference>", "OwnerUserId": "3000680", "AnswerCount": "5"}});