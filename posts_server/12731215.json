post_cb({"bq_ids": {"n4140": {"so_12731215_12731215_0": {"length": 47, "quality": 0.8103448275862069, "section_id": 5962}}, "n3337": {"so_12731215_12731215_0": {"length": 47, "quality": 0.8103448275862069, "section_id": 5731}}}, "12731215": {"ViewCount": "2271", "Body": "<p>Consider the following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct test\n{\n    void public_test()\n    {\n        [this]() { private_test(); }();\n    }\n\nprivate:\n    void private_test()\n    {\n        std::cout &lt;&lt; \"test\\n\";\n    }\n};\n\nint main()\n{\n    test().public_test();\n}\n</code></pre>\n<p>The lambda captures this and then calls a private method of the captured object. Now this code compiles and works (prints <code>test</code>) using VC++ 2012. Whereas this is quite intuitive and useful behaviour, I'd like to know if this is guaranteed to work by standard. Thus, does a lambda have private access to any object captured through <code>this</code>?</p>\n<p>I tried to look this up in the standard reading through <em>5.1.2 [expr.prim.lambda]</em> but could not really find a definite answer (being not that well-versed in the depths of the standard). The only paragraph that seemed useful to me is</p>\n<blockquote>\n<p id=\"so_12731215_12731215_0\">The type of the lambda-expression (which is also the type of the\n  closure object) is a unique, unnamed nonunion class type \u2014 called the\n  closure type \u2014 whose properties are described below. This class type\n  is not an aggregate (8.5.1). The closure type is declared in the\n  smallest block scope, class scope, or namespace scope that contains\n  the corresponding lambda-expression. [ Note: This determines the set\n  of namespaces and classes associated with the closure type (3.4.2).\n  The parameter types of a lambda-declarator do not affect these\n  associated namespaces and classes. \u2014end note ]</p>\n</blockquote>\n<p>But on the other a normal local class type defined in a member function doesn't have private access to the surrounding class. So a lambda having private access would somehow raise lambdas above mere syntactic sugar for a local function object to something more involved, since it would need additional \"compiler magic\" to somehow make it a friend of the surrounding class.</p>\n<p>So does a lambda have private access to any object captured through <code>this</code> and if yes, which parts of the standard allow this happen?</p>\n", "AcceptedAnswerId": "12731290", "Title": "Access rights of a lambda capturing this", "CreationDate": "2012-10-04T16:00:40.740", "Id": "12731215", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2012-10-04T16:04:35.373", "Score": "23", "OwnerUserId": "743214", "Tags": "<c++><lambda><c++11>", "AnswerCount": "1"}, "12731290": {"PostTypeId": "2", "Body": "<p>I don't think the fact that it is a lambda is relevant.  All lambda does\nis define a local class.  And according to \u00a711/2: \"A local class of a\nmember function may access the same names that the member function\nitself may access.\" </p>\n", "LastActivityDate": "2012-10-04T16:04:35.373", "Id": "12731290", "CommentCount": "4", "CreationDate": "2012-10-04T16:04:35.373", "ParentId": "12731215", "Score": "27", "OwnerUserId": "649665"}});