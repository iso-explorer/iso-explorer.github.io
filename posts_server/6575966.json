post_cb({"bq_ids": {"n4140": {"so_6575966_6576087_3": {"length": 26, "quality": 1.0, "section_id": 6300}, "so_6575966_6576087_1": {"length": 33, "quality": 0.9705882352941176, "section_id": 6299}, "so_6575966_6576087_4": {"length": 17, "quality": 1.0, "section_id": 6300}, "so_6575966_6576087_0": {"length": 16, "quality": 0.8, "section_id": 6299}}, "n3337": {"so_6575966_6576087_3": {"length": 26, "quality": 1.0, "section_id": 6057}, "so_6575966_6576087_1": {"length": 33, "quality": 0.9705882352941176, "section_id": 6056}, "so_6575966_6576087_4": {"length": 17, "quality": 1.0, "section_id": 6057}, "so_6575966_6576087_0": {"length": 16, "quality": 0.8, "section_id": 6056}}, "n4659": {"so_6575966_6576087_3": {"length": 26, "quality": 1.0, "section_id": 7809}, "so_6575966_6576087_1": {"length": 33, "quality": 0.9705882352941176, "section_id": 7808}, "so_6575966_6576087_4": {"length": 17, "quality": 1.0, "section_id": 7809}, "so_6575966_6576087_0": {"length": 16, "quality": 0.8, "section_id": 7808}}}, "6576680": {"Id": "6576680", "PostTypeId": "2", "Body": "<p>Maybe:</p>\n<pre><code>std::multiset&lt;long, std::less&lt;int&gt; &gt; moduloset;\n</code></pre>\n<p>Odd thing to do, but the point is that <code>std::less&lt;int&gt;</code>, <code>std::less&lt;long&gt;</code>, <code>std::less&lt;unsigned int&gt;</code> implement different mathematical functions which produce different results when passed (the result of converting) certain argument expressions. Various algorithms and other standard library components work by specifying a functor, so it makes sense to me that there are different functors to represent those different mathematical functions, not just different overloads of <code>operator()</code> on one functor.</p>\n<p>Furthermore, a functor with a template <code>operator()</code> can't be an Adaptable Binary Predicate, since it doesn't have argument types (an argument can have any type). So if <code>std::less</code> were defined as you suggest then it couldn't participate in the stuff in <code>&lt;functional&gt;</code>.</p>\n<p>Also on a highly speculative note -- <code>std::less</code> was probably designed before support for template member functions was at all widespread, since there are various notes in the SGI STL documentation that say, \"if your implementation doesn't support member templates then this isn't available\". For such a simple component there would, I guess, be an incentive to do something that works today. Once it exists, the standardization <em>could</em> then have removed it in favour of something else, but was it worth disrupting existing code? If it was that big a deal, then either you or the standard could introduce a <code>flexible_less</code> functor as you describe.</p>\n<p>Finally, why</p>\n<pre><code>template&lt;class T&gt;\nbool operator()(T const&amp; lhs, T const&amp; rhs){\n  return lhs &lt; rhs;\n}\n</code></pre>\n<p>rather than</p>\n<pre><code>template&lt;class T, class U&gt;\nbool operator()(T const&amp; lhs, U const&amp; rhs){\n  return lhs &lt; rhs;\n}\n</code></pre>\n<p>For user-defined types, the two might not be the same. Yes, this is an unfair question, since I don't know why there's no two-template-argument version of <code>std::less</code> ;-)</p>\n", "LastEditorUserId": "13005", "LastActivityDate": "2011-07-04T23:20:02.050", "Score": "5", "CreationDate": "2011-07-04T22:54:46.783", "ParentId": "6575966", "CommentCount": "1", "OwnerUserId": "13005", "LastEditDate": "2011-07-04T23:20:02.050"}, "6575966": {"ViewCount": "661", "Body": "<p>The STL functors are implemented like this:</p>\n<pre><code>template&lt;class T&gt;\nstruct less{\n  bool operator()(T const&amp; lhs, T const&amp; rhs){\n    return lhs &lt; rhs;\n  }\n};\n</code></pre>\n<p>This makes us mention the (possibly long) type everytime we create such a functor. Why are they not implemented like shown below? Any reasons?</p>\n<pre><code>struct less{\n  template&lt;class T&gt;\n  bool operator()(T const&amp; lhs, T const&amp; rhs){\n    return lhs &lt; rhs;\n  }\n};\n</code></pre>\n<p>That would make them usable without any mentioning of (possibly long) types.</p>\n", "AcceptedAnswerId": "6576087", "Title": "Why are the STL functors themselves templated and not their function call operator?", "CreationDate": "2011-07-04T20:52:14.907", "Id": "6575966", "CommentCount": "1", "FavoriteCount": "3", "PostTypeId": "1", "LastActivityDate": "2011-07-05T07:22:22.103", "Score": "22", "OwnerUserId": "500104", "Tags": "<c++><templates><stl><functor>", "AnswerCount": "2"}, "6576087": {"Id": "6576087", "PostTypeId": "2", "Body": "<p>It would also make it impossible to specialize them for user defined types. </p>\n<p>They are supposed to be a customization point.</p>\n<hr>\n<p>To summarize the discussions in the comments:</p>\n<p>Although it is technically possible to do like Xeo suggests, the language standard doesn't allow it. </p>\n<p>It is very hard to write a working class template if users are allowed to specialize individual functions of the template. In some cases it might however be a good idea to specialize the whole class for a user defined type.</p>\n<p>Therefore the C++98 standard writes (17.4.3.1):</p>\n<blockquote>\n<p id=\"so_6575966_6576087_0\">It is undefined for a C++ program to add declarations or definitions to namespace std or namespaces within namespace std unless otherwise specified. A program may add template specializations for any standard library template to namespace std.</p>\n</blockquote>\n<p>As it isn't \"otherwise specified\" that Xeo's code is allowed, we are to understand that it is not. Perhaps not totally obvious! Or that \"template specializations\" only apply to classes.</p>\n<p>The new C++11 standard has had this part expanded, and spells it out in more detail (17.6.4.2):</p>\n<blockquote>\n<p id=\"so_6575966_6576087_1\">The behavior of a C++ program is undefined if it adds declarations or definitions to namespace std or to a namespace within namespace std unless otherwise specified. A program may add a template specialization for any standard library template to namespace std only if the declaration depends on a user-defined type and the specialization meets the standard library requirements for the original template and is not explicitly\n  prohibited.</p>\n<p id=\"so_6575966_6576087_2\">The behavior of a C++ program is undefined if it declares </p>\n<p id=\"so_6575966_6576087_3\">\u2014 an explicit specialization of any member function of a standard library class template, or<br>\n   \u2014 an explicit specialization of any member function template of a standard library class or class template, or<br>\n  \u2014 an explicit or partial specialization of any member class template of a standard library class or class template.</br></br></p>\n<p id=\"so_6575966_6576087_4\">A program may explicitly instantiate a template defined in the standard library only if the declaration depends on the name of a user-defined type and the instantiation meets the standard library requirements for the original template.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "597607", "LastActivityDate": "2011-07-05T07:22:22.103", "Score": "23", "CreationDate": "2011-07-04T21:10:07.603", "ParentId": "6575966", "CommentCount": "22", "OwnerUserId": "597607", "LastEditDate": "2011-07-05T07:22:22.103"}});