post_cb({"bq_ids": {"n4140": {"so_38215737_38226958_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 5855}}, "n3337": {"so_38215737_38226958_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 5625}}, "n4659": {"so_38215737_38226958_0": {"length": 29, "quality": 0.9666666666666667, "section_id": 7334}}}, "38226958": {"Id": "38226958", "PostTypeId": "2", "Body": "<p>Clang and GCC are wrong, and MSVC and EDG are right to reject that partial specialization definition.</p>\n<p>A partial specialization is itself a template, and a class template definition is syntactically constructed in terms of a class definition (in grammar terms, a <em>class-specifier</em>). Within such a definition, <code>Derived::Inner&lt;int, _&gt;</code> is a <em>class-head-name</em>, with <code>Derived::</code> being a <em>nested-name-specifier</em>. </p>\n<p>[9p11] in the Standard says:</p>\n<blockquote>\n<p id=\"so_38215737_38226958_0\">If a <em>class-head-name</em> contains a <em>nested-name-specifier</em>, the\n  <em>class-specifier</em> shall refer to a class that was previously declared\n  directly in the class or namespace to which the <em>nested-name-specifier</em>\n  refers, or in an element of the inline namespace set (7.3.1) of that\n  namespace (i.e., not merely inherited or introduced by a\n  <em>using-declaration</em>), and the <em>class-specifier</em> shall appear in a\n  namespace enclosing the previous declaration. [...]</p>\n</blockquote>\n<p>So, you have to use <code>Base::Inner&lt;int, _&gt;</code>.</p>\n<hr>\n<p>As noted in the comments, the quote above applies to class template explicit specialization definitions as well (their grammar production also ends up using <em>class-head-name</em>).</p>\n<hr>\n<p>The following doesn't apply directly to your example, but I found it worth mentioning.</p>\n<p>Note that the quote above refers to class template (or explicit specialization) definitions, not declarations such as</p>\n<pre><code>template&lt;class _&gt; struct Derived::Inner&lt;int, _&gt;;\n</code></pre>\n<p>Syntactically, <code>struct Derived::Inner&lt;int, _&gt;</code> in there is an <em>elaborated-type-specifier</em>, to which the paragraph above doesn't apply. So, the Standard wording technically allows such declarations.</p>\n<p>This doesn't seem to be an oversight: the wording above was introduced by the resolution of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#284\" rel=\"nofollow\">DR284</a>, which includes the comment:</p>\n<blockquote>\n<p id=\"so_38215737_38226958_1\">The sentiment was that this should be required on class definitions,\n  but not on elaborated type specifiers in general (which are\n  references, not declarations). [...]</p>\n</blockquote>\n<p>The proposed resolution included <em>elaborated-type-specifiers</em>, but those were removed from the final wording.</p>\n<p>However, neither MSVC nor EDG accept such declarations (and frankly I'd find it confusing if they did). The comment in the DR seems to indicate that the intent was to allow only <em>elaborated-type-specifiers</em> that are not also declarations, but it looks like this wasn't reflected in the wording (a Standard bug, I think).</p>\n</hr></hr>", "LastEditorUserId": "4326278", "LastActivityDate": "2016-07-09T08:20:10.437", "Score": "2", "CreationDate": "2016-07-06T14:45:22.757", "ParentId": "38215737", "CommentCount": "2", "LastEditDate": "2016-07-09T08:20:10.437", "OwnerUserId": "4326278"}, "38215737": {"ViewCount": "253", "Body": "<p>The following source code is brought from:\n<a href=\"https://stackoverflow.com/questions/17132753/understanding-partial-specialization-of-inherited-nested-class-templates\">Understanding partial specialization of inherited nested class templates</a></p>\n<pre><code>#include &lt;type_traits&gt;\nstruct Base\n{\n    template&lt;class U, class _ = void&gt; struct Inner: std::true_type {};\n    template&lt;class _&gt; struct Inner&lt;char, _&gt;: std::false_type {};\n};\nstruct Derived : Base\n{\n};\n\ntemplate&lt;class _&gt; struct Derived::Inner&lt;int, _&gt;: std::false_type {};\n</code></pre>\n<p>I had an issue about specializing inherited class, so I googled, and find out the question above. The source code in the question above compiled w/o any problem in gcc/clang, but msvc refuses to compile it, issuing C2427 (see  <a href=\"https://msdn.microsoft.com/en-us/library/10het5hx.aspx\" rel=\"nofollow noreferrer\">https://msdn.microsoft.com/en-us/library/10het5hx.aspx</a>).</p>\n<p>Situation of the above (specialize the nested template class of a non-template class) is quite different from the situation described in <a href=\"https://msdn.microsoft.com/en-us/library/10het5hx.aspx\" rel=\"nofollow noreferrer\">https://msdn.microsoft.com/en-us/library/10het5hx.aspx</a> (define the nested non-template class of a template class), I think.</p>\n<p>Which one of msvc vs. gcc/clang is wrong? Or just the standard is so unclear to specify this behavior?</p>\n<p>I hope msvc is wrong...</p>\n", "AcceptedAnswerId": "38226958", "Title": "Specialization of inherited nested template class", "CreationDate": "2016-07-06T02:58:53.063", "Id": "38215737", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:32:52.383", "LastEditorUserId": "-1", "LastActivityDate": "2016-07-09T08:20:10.437", "Score": "6", "OwnerUserId": "4751858", "Tags": "<c++><inheritance><language-lawyer><inner-classes><template-specialization>", "AnswerCount": "1"}});