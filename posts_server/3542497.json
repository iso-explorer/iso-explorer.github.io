post_cb({"3542497": {"CommentCount": "2", "AcceptedAnswerId": "3542584", "PostTypeId": "1", "LastEditorUserId": "151292", "CreationDate": "2010-08-22T17:27:44.480", "LastActivityDate": "2012-09-29T03:18:57.600", "LastEditDate": "2012-09-29T03:17:38.990", "ViewCount": "561", "FavoriteCount": "1", "Title": "Problem by a reference variable of a template parameter", "Id": "3542497", "Score": "4", "Body": "<p>The following small example shows my problem:</p>\n<pre><code>template&lt;class T&gt; struct X\n{\n    static void xxx(T&amp; x) { }\n    static void xxx(T&amp;&amp; x) { }\n};\n\nint main(int argc, char** argv)\n{\n    int x = 9;\n    X&lt;int&gt;::xxx(x); // OK.\n    X&lt;int&amp;&gt;::xxx(x); // ERROR!\n    return 0;\n}\n</code></pre>\n<p>Error message (GCC):</p>\n<blockquote>\n<p id=\"so_3542497_3542497_0\">error: \u2018static void X::xxx(T&amp;&amp;) [with T = int&amp;]\u2019 cannot be overloaded<br>\n  error: with \u2018static void X::xxx(T&amp;) [with T = int&amp;]\u2019</br></p>\n</blockquote>\n<p>Why? <code>T = int&amp;</code> ---&gt; Is <code>T&amp;</code> replaced by <code>int&amp;&amp;</code> in <code>static void xxx(T&amp; x)</code>?</p>\n<p>If the answer to the question is yes, then:</p>\n<ul>\n<li><code>T&amp;</code> is not a lvalue-reference and it becomes a rvalue-reference!</li>\n<li>And the following code should work:</li>\n</ul>\n<p>But it didn't:</p>\n<pre><code>template&lt;class T&gt; struct X\n{\n    static void xxx(T&amp; x) { }\n};\n\nint main(int argc, char** argv)\n{\n    X&lt;int&amp;&gt;::xxx(2); // ERROR!\n    return 0;\n}\n</code></pre>\n<p>Error Message (GCC):</p>\n<blockquote>\n<p id=\"so_3542497_3542497_1\">error: no matching function for call to \u2018X::xxx(int)\u2019<br>\n  note: candidates are: static void X::xxx(T&amp;) [with T = int&amp;]</br></p>\n</blockquote>\n<p>Then <code>T&amp;</code> with <code>T = int&amp;</code> is not equal to <code>T&amp;&amp;</code> and is not a rvalue-reference. but if it is not, why the first example not working? (it's a recursive problem!)</p>\n<hr>\n<p>But the similar problem didn't occur for pointer types:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class T&gt; struct X\n{\n    static void xxx(T* x) { std::cout &lt;&lt; **x &lt;&lt; std::endl; }\n};\n\nint main(int argc, char** argv)\n{\n    int x = 10;\n    int* xx = &amp;x;\n    X&lt;int*&gt;::xxx(&amp;xx); // OK. call X&lt;int*&gt;::xxx(int**)\n    return 0;\n}\n</code></pre>\n<p>Why references are different in this behavior?</p>\n</hr>", "Tags": "<c++><templates><c++11><rvalue-reference><lvalue>", "OwnerUserId": "417024", "AnswerCount": "1"}, "3542584": {"ParentId": "3542497", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The C++11 language standard has an explanation of how this works at \u00a78.3.2[dcl.ref]/6 (reformatted for readability):</p>\n<blockquote>\n<p id=\"so_3542497_3542584_0\">If a typedef, a type <em>template-parameter</em>, or a <em>decltype-speci\ufb01er</em> denotes a type <code>TR</code> that is a reference to a type <code>T</code>, </p>\n<ul>\n<li>an attempt to create the type \"lvalue reference to <em>cv</em> <code>TR</code>\" creates the type \"lvalue reference to <code>T</code>\"</li>\n<li>an attempt to create the type \"rvalue reference to <em>cv</em> <code>TR</code>\" creates the type <code>TR</code>.</li>\n</ul>\n</blockquote>\n<p>Let's consider your example (I've renamed your <code>T</code> to be <code>TR</code> so it matches the language above):</p>\n<pre><code>template&lt;class TR&gt; struct X\n{\n    static void xxx(TR&amp; x)  { }\n    static void xxx(TR&amp;&amp; x) { }\n};\n</code></pre>\n<p>If we try instantiating <code>X</code> with <code>TR = int&amp;</code> (so, <code>T = int</code>), the instantiations of <code>xxx</code> are as follows:</p>\n<pre><code>static void xxx(TR&amp; x)  { }   --&gt;   static void xxx(int&amp; x) { }\nstatic void xxx(TR&amp;&amp; x) { }   --&gt;   static void xxx(int&amp; x) { }\n</code></pre>\n<p>In the first case, we attempt to create an \"lvalue reference to <code>TR</code>,\" which becomes an \"lvalue reference to <code>T</code>.\"  <code>T</code> is <code>int</code>, so the parameter type becomes <code>int&amp;</code>.</p>\n<p>In the second case, we attempt to create an \"rvalue reference to <code>TR</code>,\" which becomes <code>TR</code>, which is <code>int&amp;</code>.</p>\n<p>The parameter type is the same for both overloads, hence the error.</p>\n", "OwnerUserId": "151292", "LastEditorUserId": "151292", "LastEditDate": "2012-09-29T03:18:57.600", "Id": "3542584", "Score": "10", "CreationDate": "2010-08-22T17:51:15.600", "LastActivityDate": "2012-09-29T03:18:57.600"}, "bq_ids": {"n4140": {"so_3542497_3542584_0": {"section_id": 91, "quality": 0.625, "length": 5}}, "n3337": {"so_3542497_3542584_0": {"section_id": 3097, "quality": 0.875, "length": 7}}, "n4659": {"so_3542497_3542584_0": {"section_id": 823, "quality": 0.625, "length": 5}}}});