post_cb({"24829437": {"Id": "24829437", "PostTypeId": "2", "Body": "<p>A major difference between C and C++ (other than Objects and Classes!) is references. \nA reference is like a const pointer to a variable. Assigning a reference is a bit like using a pointer but with &amp; not * and you don't need to difference. The difference is that you assign an address to a pointer  but a variable  to a reference variable. \nThe line below suggests that the value of a is copied into aref. But it is not, instead aref is a reference to the variable a. Once assigned, aref is the same as a. Any changes to aref are changes to a as example  below shows </p>\n<p>int &amp; aref = a; </p>\n<pre><code> #include &lt;stdio.h&gt;\n #include \"stdafx.h\"\n\n  int main()\n   {\n      int a=9;\n      int &amp; aref = a;\n      a++;\n      cout &lt;&lt; \"The value of a is %i\\n\" &lt;&lt; aref;\n      return 0;\n    }\n</code></pre>\n<p>Also remember that</p>\n<ol>\n<li><p>A reference must always refer to something.NULLs are not allowed. </p></li>\n<li><p>A reference must be initialized when it is created. An unassigned reference can not exist. </p></li>\n<li><p>Once initialized, it cannot be changed to another variable. </p></li>\n</ol>\n<p>If it help you please inform me, thanx</p>\n", "LastActivityDate": "2014-07-18T16:06:09.790", "CommentCount": "0", "CreationDate": "2014-07-18T16:06:09.790", "ParentId": "24827592", "Score": "0", "OwnerUserId": "2382531"}, "bq_ids": {"n4140": {"so_24827592_24828578_1": {"length": 11, "quality": 0.7333333333333333, "section_id": 3218}, "so_24827592_24828578_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 5938}}, "n3337": {"so_24827592_24828578_1": {"length": 11, "quality": 0.7333333333333333, "section_id": 3092}, "so_24827592_24828578_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 5710}}, "n4659": {"so_24827592_24828578_1": {"length": 11, "quality": 0.7333333333333333, "section_id": 3975}, "so_24827592_24828578_2": {"length": 20, "quality": 0.8695652173913043, "section_id": 7422}}}, "24827592": {"ViewCount": "197", "Body": "<p>How do you define (explain) in a formal and strict way what is reference type in C++?</p>\n<p>I tried to google, and looked into Stroustrup's \"The C++ Programming Language\", but I don't see definition of this concept there. </p>\n", "AcceptedAnswerId": "24827998", "Title": "What is definition of reference type?", "CreationDate": "2014-07-18T14:36:25.397", "Id": "24827592", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-07-18T16:06:09.790", "Score": "2", "OwnerUserId": "747050", "Tags": "<c++><reference>", "AnswerCount": "3"}, "24827998": {"Id": "24827998", "PostTypeId": "2", "Body": "<p><strong>A reference is an alias, an alternate name for an object. It is not an object itself (and in that way is <em>not</em> a pointer, even if some of their uses overlap with uses of pointers).</strong></p>\n<p>References have certain limitations to their handling, related to their non-objectness. For example, you can't create an array of references. They have to be initialized (bound, seated) as soon as they are declared, since they can't possibly exist without an object to alias.</p>\n<p>You can however store them, and they obey the rules of automatic variables or member variables. One of their uses is to poke through C++'s pass-by-value function calls.</p>\n<p>Note that const references have a neat side-effect of being aliases : when bound to a temporary (i.e unnamed) object, they give said object a name, and therefore extend its lifetime to that of the reference itself.</p>\n<pre><code>{ // Block scope\n     Foo fooVal = makeFoo(); // Say makeFoo() returns a (temporary, unnamed) Foo\n     // Here the temporary Foo is dead (fooVal is a copy).\n\n     // Foo &amp;fooRef = makeFoo(); // Error, reference is non-const\n     Foo const &amp;fooCRef = makeFoo(); // All good\n\n     // ...\n\n     // The second temporary is still alive\n     fooCRef.doSomethingFunny(); // Works like a charm !\n\n} // The second temporary dies with fooRef\n</code></pre>\n<p>Beware though, it is possible (though contrived) to have an object go out of scope with references still pointing to it. You will then have <em>dangling references</em>, which are not to be used anymore (doing so would be Undefined Behaviour).</p>\n<pre><code>Foo *fooPtr = new Foo; // Here is a Foo\nFoo &amp;fooRef = *fooPtr; // Here is an alias for that Foo\n\ndelete fooPtr; // Here is the end of that Foo's life\n\nfooRef.doSomethingFunny(); // Here comes trouble...\n</code></pre>\n", "LastEditorUserId": "747050", "LastActivityDate": "2014-07-18T15:22:29.390", "Score": "1", "CreationDate": "2014-07-18T14:55:51.017", "ParentId": "24827592", "CommentCount": "0", "OwnerUserId": "3233393", "LastEditDate": "2014-07-18T15:22:29.390"}, "24828578": {"Id": "24828578", "PostTypeId": "2", "Body": "<p>Regarding</p>\n<blockquote>\n<p id=\"so_24827592_24828578_0\"><strong>\u201d</strong> How do you define (explain) in a formal and strict way what is reference type in C++?</p>\n</blockquote>\n<p>the C++11 standard gives the following formal and strict definition of a <strong>reference type</strong> in its</p>\n<p>\u00a78.3.2/1</p>\n<blockquote>\n<p id=\"so_24827592_24828578_1\"><strong>\u201d</strong> In a declaration T D where D has either of the forms<br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<code>&amp;</code> <em>attribute-specifier-seq<sub>opt</sub></em> <code>D1</code><br>\n  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0<code>&amp;&amp;</code> <em>attribute-specifier-seq<sub>opt</sub></em> <code>D1</code><br>\n  and the type of the identifier in the declaration <code>T D1</code> is \u201c<em>derived-declarator-type-list</em> <code>T</code>,\u201d then the type of the\n  identifier of <code>D</code> is \u201c<em>derived-declarator-type-list</em> reference to <code>T</code>.\u201d</br></br></br></p>\n</blockquote>\n<hr>\n<p>However, if you\u2019re more interested in what a C++ reference practically is (apart from the colloquial use of the term), then check the definition of its meaning in an expression,</p>\n<p>\u00a75.5</p>\n<blockquote>\n<p id=\"so_24827592_24828578_2\"><strong>\u201d</strong> If an expression initially has the type \u201creference to <code>T</code>\u201d (8.3.2, 8.5.3), the type is adjusted to <code>T</code> prior to\n  any further analysis. The expression designates the object or function denoted by the reference, and the\n  expression is an lvalue or an xvalue, depending on the expression</p>\n</blockquote>\n<p>Effectively this means that a reference acts as an <strong>alias</strong>.</p>\n<p>You can think of a reference as an automatically dereferenced <code>const</code> pointer, which explains most of the behavior except that a reference doesn't necessarily occupy storage (the compiler may be able to optimize it away completely).</p>\n</hr>", "LastActivityDate": "2014-07-18T15:24:12.427", "CommentCount": "0", "CreationDate": "2014-07-18T15:24:12.427", "ParentId": "24827592", "Score": "1", "OwnerUserId": "464581"}});