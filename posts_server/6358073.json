post_cb({"bq_ids": {"n4140": {"so_6358073_6358511_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 3293}, "so_6358073_6358511_2": {"length": 17, "quality": 0.68, "section_id": 3294}, "so_6358073_6358511_5": {"length": 41, "quality": 0.9111111111111111, "section_id": 3296}, "so_6358073_6358511_6": {"length": 81, "quality": 0.9204545454545454, "section_id": 3296}, "so_6358073_6358511_4": {"length": 14, "quality": 0.7777777777777778, "section_id": 3295}}, "n3337": {"so_6358073_6358511_4": {"length": 14, "quality": 0.7777777777777778, "section_id": 3165}, "so_6358073_6358511_0": {"length": 29, "quality": 0.9354838709677419, "section_id": 3163}, "so_6358073_6358511_2": {"length": 17, "quality": 0.68, "section_id": 3164}, "so_6358073_6358511_5": {"length": 41, "quality": 0.9111111111111111, "section_id": 3166}, "so_6358073_6358511_6": {"length": 81, "quality": 0.9204545454545454, "section_id": 3166}}, "n4659": {"so_6358073_6358511_4": {"length": 10, "quality": 0.5555555555555556, "section_id": 4057}, "so_6358073_6358511_2": {"length": 17, "quality": 0.68, "section_id": 4056}, "so_6358073_6358511_5": {"length": 41, "quality": 0.9111111111111111, "section_id": 4058}, "so_6358073_6358511_6": {"length": 60, "quality": 0.6818181818181818, "section_id": 4058}}}, "6358159": {"Id": "6358159", "PostTypeId": "2", "Body": "<p>This has nothing to do with overloading or argument lookup. By defining <code>Foo(Foo&amp;)</code>, you've disabled the generation of the default copy constructor <code>Foo(const Foo&amp;)</code>, which is required to initialize <code>c</code> from an rvalue. Add a ctor with the Foo(const Foo&amp;) signature and your code will run fine. I don't know why VS10 compiles this, but I will try to look up the clauses which specify why it shouldn't happen.</p>\n<p><strong>Here we go:</strong>\n\u00a712.8(1) specifies that a non template constructor for class X is a copy constructor if its first parameter is of type X&amp;, const X&amp;, volatile X&amp; or const volatile X&amp; and there are no other parameters or all other parameters have default values.</p>\n<p>\u00a712.8(5) says, that if we don't define a copy constructor for X (in any of the above mentioned forms), the compiler defines a copy constructor in the form X(const X&amp;).</p>\n<p>Thus defining Foo(Foo&amp;) defines <strong>a</strong> copy constructor, so the compiler can't implicitly define Foo(const Foo&amp;) anymore.</p>\n", "LastEditorUserId": "385433", "LastActivityDate": "2011-06-15T13:20:55.207", "Score": "4", "CreationDate": "2011-06-15T13:10:36.600", "ParentId": "6358073", "CommentCount": "5", "OwnerUserId": "385433", "LastEditDate": "2011-06-15T13:20:55.207"}, "6358511": {"Id": "6358511", "PostTypeId": "2", "Body": "<p>This should work:</p>\n<pre><code>Foo c(a &gt;&gt; b);\n</code></pre>\n<p>This initialization syntax:</p>\n<pre><code>Foo c = a &gt;&gt; b;\n</code></pre>\n<p>Is interpreted as</p>\n<pre><code>Foo c(Foo(a &gt;&gt; b));\n</code></pre>\n<p>is <em>copy-initialization</em> and requires an accessible copy-constructor which accepts <code>const Foo&amp;</code>.</p>\n<hr>\n<p>From section <code>[dcl.init]</code> of the standard (wording from C++0x):</p>\n<blockquote>\n<p id=\"so_6358073_6358511_0\">The form of initialization (using parentheses or =) is generally insigni\ufb01cant,  but does matter when the initializer or the entity being initialized has a class type; see below.  If the entity being initialized does not have class type, the expression-list in a parenthesized initializer shall be a single expression.</p>\n<p id=\"so_6358073_6358511_1\">The initialization that occurs in the form</p>\n<pre><code>   T  x  =  a;\n</code></pre>\n<p id=\"so_6358073_6358511_2\">as well as in argument passing, function return, throwing an exception (15.1), handling an exception (15.3), and aggregate member initialization (8.5.1) is called <em>copy-initialization</em>.   [ Note:  Copy-initialization may invoke a move (12.8).  \u2014 end note ]</p>\n<p id=\"so_6358073_6358511_3\">The initialization that occurs in the forms</p>\n<pre><code>   T  x(a);\n   T  x{a};\n</code></pre>\n<p id=\"so_6358073_6358511_4\">as well as in new expressions (5.3.4), static_cast expressions (5.2.9), functional notation type conversions (5.2.3), and base and member initializers (12.6.2) is called <em>direct-initialization</em>.</p>\n</blockquote>\n<p>The <code>T x{a}</code> syntax is new in C++0x, all the other rules are unchanged from C++03.</p>\n<hr>\n<p>Then the following rules apply (same section):</p>\n<blockquote>\n<ul>\n<li><p id=\"so_6358073_6358511_5\">If the initialization is direct-initialization, or if it is copy-initialization where the cv-unqualified version of the source type is the same class as, or a derived class of, the class of the destination, constructors are considered. The applicable constructors are enumerated (13.3.1.3), and the best one is chosen through overload resolution (13.3). The constructor so selected is called to initialize the object, with the initializer expression or expression-list as its argument(s). If no constructor applies, or the overload resolution is ambiguous, the initialization is ill-formed.</p></li>\n<li><p id=\"so_6358073_6358511_6\">Otherwise (i.e.,  for the remaining copy-initialization cases),  user-defined conversion sequences that can convert from the source type to the destination type or (when a conversion function is used) to a derived class thereof are enumerated as described in 13.3.1.4, and the best one is chosen through overload resolution (13.3). If the conversion cannot be done or is ambiguous, the initialization is ill-formed.  <strong>The function selected is called with the initializer expression as its argument; if the function is a constructor, the call initializes a temporary of the cv-unqualified version of the destination type. The temporary is a prvalue. The result of the call (which is the temporary for the constructor case) is then used to direct-initialize, according to the rules above, the object that is the destination of the copy-initialization.</strong>  In certain cases, an implementation is permitted to eliminate the copying inherent in this direct-initialization by constructing the intermediate result directly into the object being initialized; see 12.2, 12.8.</p></li>\n</ul>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "103167", "LastActivityDate": "2011-06-15T13:39:17.650", "Score": "2", "CreationDate": "2011-06-15T13:33:47.837", "ParentId": "6358073", "CommentCount": "1", "OwnerUserId": "103167", "LastEditDate": "2011-06-15T13:39:17.650"}, "6358073": {"ViewCount": "273", "Body": "<p>I have the following code:</p>\n<pre><code>class Foo;\nclass Bar;\n\nclass Bar {\npublic:\n    Bar() {\n    }\n\n    Bar(Foo &amp;foo) {\n    }\n};\n\nclass Foo {\npublic:\n    Foo() {\n    }\n    Foo(Foo &amp;foo) {\n    }\n    Foo(const Bar &amp;bar) {\n    }\n};\n\nBar operator &gt;&gt; (const Bar &amp;left, const Bar &amp;right) { return Bar(); }\n\nFoo a;\nFoo b;\nFoo c = a &gt;&gt; b;\n</code></pre>\n<p>In Visual Studio 10, the above code compiles fine: the compiler recognizes that <code>Bar</code> can be instantiated from <code>Foo&amp;</code>, and therefore it invokes the appropriate <code>operator &gt;&gt;</code>, which then returns a <code>Bar</code> instance, and the constructor <code>Foo(const Bar &amp;)</code> is appropriately invoked.</p>\n<p>However, GCC 4.5 does not compile the above code. It outputs the following error:</p>\n<pre><code>error: no matching function for call to 'Foo::Foo(Foo)'\nnote: candidates are: Foo::Foo(const Bar&amp;)\nnote:                 Foo::Foo(Foo&amp;)\nnote:                 Foo::Foo()\n</code></pre>\n<p>Why does the above happen and which compiler is correct, according to the language standard? </p>\n<p>EDIT:</p>\n<p>Why does C++ create a temporary <code>Foo</code> object as a result of <code>c = a &gt;&gt; b</code>, since <code>Foo(const Bar &amp;)</code> exists?</p>\n", "AcceptedAnswerId": "6358511", "Title": "Which compiler between Visual Studio 10 and GCC 4.5 is correct regarding operator overloading and argument-dependendent lookup?", "CreationDate": "2011-06-15T13:03:10.480", "Id": "6358073", "CommentCount": "0", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2011-06-15T13:26:52.140", "LastEditorUserId": "213348", "LastActivityDate": "2011-06-15T13:39:17.650", "Score": "2", "OwnerUserId": "213348", "Tags": "<c++><visual-studio-2010><gcc><operator-overloading><argument-dependent-lookup>", "AnswerCount": "2"}});