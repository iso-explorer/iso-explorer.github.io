post_cb({"bq_ids": {"n4140": {"so_37879533_37879846_3": {"length": 24, "quality": 0.96, "section_id": 6697}, "so_37879533_37879846_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6696}}, "n3337": {"so_37879533_37879846_3": {"length": 24, "quality": 0.96, "section_id": 6452}, "so_37879533_37879846_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6451}}, "n4659": {"so_37879533_37879846_3": {"length": 24, "quality": 0.96, "section_id": 8172}, "so_37879533_37879846_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 8171}}}, "37879793": {"Id": "37879793", "PostTypeId": "2", "Body": "<p>If you don't write <code>public:</code> then it's as if you've written <code>private:</code>. If you're asking why the language doesn't automatically switch to <code>public:</code> for <code>Derived::method()</code> (because it overrides <code>Base::method()</code> which is already public)\u2026 well, it could! This would be possible.</p>\n<p>However, it would also be extremely confusing and misleading when reading the code. As a programmer I much prefer that my class definition isn't fundamentally altered behind my back like that.</p>\n<p>The compiler throws out an error (as you've discovered) allowing me to make the change myself as I deem appropriate (whether that's making <code>Derived::method()</code> public, or <code>Base::method()</code> private!), which in my opinion is by far the best outcome.</p>\n<p>If instead you're asking why a difference in visibility even matters at all, then that seems fairly obvious, does it not? If the user were calling a function through the <code>Base</code> class interface, in which <code>method()</code> is public, and this ended up automatically invoking a <code>private</code> function in a derived class, that violates the contract of the derived class. And because it's only the <em>names</em> that are protected by these visibility rules, the language adds an extra check for overridden methods to extend that protection as much as possible in the case of virtual function dispatch.</p>\n", "LastActivityDate": "2016-06-17T10:54:02.913", "CommentCount": "0", "CreationDate": "2016-06-17T10:54:02.913", "ParentId": "37879533", "Score": "1", "OwnerUserId": "560648"}, "37879846": {"Id": "37879846", "PostTypeId": "2", "Body": "<p>Something very similar is given as an example in the standard where the rules for these things are specified [class.access.virt]:</p>\n<blockquote>\n<p id=\"so_37879533_37879846_0\">1 The access rules (Clause 11) for a virtual function are determined\n  by its declaration and are not affected by the rules for a function\n  that later overrides it. </p>\n<p id=\"so_37879533_37879846_1\">[ Example: </p>\n<pre><code>class B { \n    public: virtual int f();\n}; \nclass D : public B \n{ \n   private: int f(); \n}; \nvoid f() \n{ \n    D d; \n    B* pb = &amp;d; \n    D* pd = &amp;d; \n    pb-&gt;f(); // OK: B::f() is public, // D::f() is invoked\n    pd-&gt;f(); // error: D::f() is private \n}\n</code></pre>\n<p id=\"so_37879533_37879846_2\">\u2014 end example ] </p>\n<p id=\"so_37879533_37879846_3\">2 Access is\n  checked at the call point using the type of the expression used to\n  denote the object for which the member function is called (B* in the\n  example above). The access of the member function in the class in\n  which it was defined (D in the example above) is in general not known.</p>\n</blockquote>\n<p>The above answer both your questions:</p>\n<ol>\n<li>Why does it not compile - as per rule 2 above access is checked using the type of the expression (i.e. the static not dynamic type)</li>\n<li>What is the rationale - again as described above it is generally not known what the dynamic type is. To demonstrate, consider this: You can link new derived classes to an existing code defining a base class without recompiling this code: then clearly it would have no chance of determining the access controls of the derived (which didn't even exist when it was compiled).</li>\n</ol>\n", "LastActivityDate": "2016-06-17T10:57:01.990", "CommentCount": "0", "CreationDate": "2016-06-17T10:57:01.990", "ParentId": "37879533", "Score": "1", "OwnerUserId": "6255513"}, "37879533": {"ViewCount": "46", "Body": "<p>Suppose we have two classes, one derived from other and it contains only one virtual non-pure method like this:</p>\n<pre><code>class Base\n{\npublic:\n    virtual void method()\n    {\n        cout &lt;&lt; \"method() called from Base\" &lt;&lt; endl;\n    }\n};\n\n\nclass Derived : public Base\n{\npublic:\n    void method()\n    {\n        cout &lt;&lt; \"method() called from Derived\" &lt;&lt; endl;\n    }\n};\n\n\nint main()\n{\n    Base *instance1 = new Derived();\n    instance1-&gt;method();\n\n    Derived derived;\n    derived.method();\n}\n</code></pre>\n<p>Why, if we do not specify explicitly \"public\" access modifier in Derived class (so, compiler assumes that it's private) it wouldn't compile? Why instantiation way(via pointer and via regular variable) does affect to the visibility scope? Is there any rationale regarding this behavior?</p>\n<p>Many thanks!</p>\n", "Title": "Requiring \"public\" access modifier when using instance in auto scope", "CreationDate": "2016-06-17T10:41:24.163", "LastActivityDate": "2016-06-17T10:57:01.990", "CommentCount": "3", "PostTypeId": "1", "Id": "37879533", "Score": "-1", "OwnerUserId": "530589", "Tags": "<c++>", "AnswerCount": "2"}});