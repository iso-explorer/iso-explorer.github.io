post_cb({"25343085": {"CommentCount": "0", "ViewCount": "63", "CreationDate": "2014-08-16T19:14:59.753", "LastActivityDate": "2014-08-16T20:31:08.683", "Title": "Override function and its calls in base class", "AcceptedAnswerId": "25343150", "PostTypeId": "1", "Id": "25343085", "Score": "0", "Body": "<p>Let's say I've got these two classes:</p>\n<pre><code>class A {\npublic:\n    A() { foo() };\nprotected:\n    virtual void foo();\n};\n\nclass B : public A {\npublic:\n    B() : super();\nprivate:\n    typedef A super;\n    void foo();\n};\n</code></pre>\n<p>If I create an object B, is there a way to force A's constructor to use the overriden method when it is called ?</p>\n", "Tags": "<c++><class><override>", "OwnerUserId": "3250340", "AnswerCount": "4"}, "25343146": {"ParentId": "25343085", "CommentCount": "0", "Body": "<p>No. It isn't.\nAccording to Effective c++, when object is initializing, The virtual functions is not working.\n(I wrote by mobile phone so here can be typos)</p>\n<p>Best regards.</p>\n", "OwnerUserId": "3699447", "PostTypeId": "2", "Id": "25343146", "Score": "2", "CreationDate": "2014-08-16T19:21:40.823", "LastActivityDate": "2014-08-16T19:21:40.823"}, "25343150": {"ParentId": "25343085", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>C++ Standard, section \u00a7 12.7 [Construction and Destruction] :</p>\n<blockquote>\n<p id=\"so_25343085_25343150_0\">Member functions, including virtual functions (10.3), can be called\n  during construction or destruction (12.6.2).When a virtual function is\n  called directly or indirectly from a constructor or from a destructor,\n  including during the construction or destruction of the class\u2019s\n  non-static data members, and the object to which the call applies is\n  the object (call it x) under construction or destruction, the function\n  called is the final overrider <strong>in the constructor\u2019s or destructor\u2019s class and not one overriding it in a more-derived class</strong></p>\n</blockquote>\n<p>When you are in <code>A</code> constructor, your object is an <code>A</code> at this point, it doesn't matter if the call was made from <code>B</code> constructor.</p>\n<p>So <code>A::foo</code> will always be called.</p>\n", "OwnerUserId": "3510483", "LastEditorUserId": "3510483", "LastEditDate": "2014-08-16T19:31:12.910", "Id": "25343150", "Score": "1", "CreationDate": "2014-08-16T19:22:11.817", "LastActivityDate": "2014-08-16T19:31:12.910"}, "25343687": {"ParentId": "25343085", "CommentCount": "0", "Body": "<p>Calls to Virtual functions are resolved using a virtual table. Any class having at least one virtual function ( and all its derived classes ) will have a virtual table each ( in this case both A and B ) and this virtual table will contain address of all the virtual functions in the order in which they have been declared. When an object of any such class is created, the object contains a hidden pointer, vptr, that points to the virtual table. So a virtual function call is resolved by first going to the virtual table using vptr, then adding the offset of the called function to get the address of the function and then calling the function using this address. Now important thing is that the vptr is initialized in the constructor of a class and in a particular constructor it will point to the virtual table of that particular class. In this case when object of B is created, the vptr in the constructor of A ( base class constructor is called first ) will point to the virtual table of A and when the constructor of  B gets called the vptr will only then point to the virtual table of B. That means in the constructor of A, vptr is pointing to A's virtual table. So when you call foo(), the compiler will go to A's virtual table, fetch the address of foo() which in this case is A's foo() and call this function.  This is why we usually say that virtual mechanism does not work inside constructor. The reason is that the vptr is not fully initialized and is not pointing to the most derived class's vtable.\nI hope this helps.</p>\n", "OwnerUserId": "1156613", "PostTypeId": "2", "Id": "25343687", "Score": "0", "CreationDate": "2014-08-16T20:31:08.683", "LastActivityDate": "2014-08-16T20:31:08.683"}, "25343182": {"ParentId": "25343085", "CommentCount": "0", "Body": "<p>When <code>A</code> constructor is called from <code>B</code>, <code>B</code> is not yet construct, so <code>A::foo</code> is not called virtually.</p>\n<p>you may create a function to create and initialize your object:</p>\n<pre><code>struct Base\n{\n    virtual ~Base();\n    virtual void init();\n};\n\nstruct D : Base\n{\n    void init() override;\n};\n\nD make_D()\n{\n    D d;\n    d.init();\n    return d;\n}\n</code></pre>\n", "OwnerUserId": "2684539", "PostTypeId": "2", "Id": "25343182", "Score": "0", "CreationDate": "2014-08-16T19:26:08.387", "LastActivityDate": "2014-08-16T19:26:08.387"}, "bq_ids": {"n4140": {"so_25343085_25343150_0": {"section_id": 447, "quality": 0.9565217391304348, "length": 44}}, "n3337": {"so_25343085_25343150_0": {"section_id": 438, "quality": 0.9565217391304348, "length": 44}}, "n4659": {"so_25343085_25343150_0": {"section_id": 469, "quality": 0.9565217391304348, "length": 44}}}});