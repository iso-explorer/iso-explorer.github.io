post_cb({"996844": {"CommentCount": "1", "AcceptedAnswerId": "996868", "CreationDate": "2009-06-15T15:44:12.040", "LastActivityDate": "2009-06-15T17:01:46.963", "PostTypeId": "1", "ViewCount": "726", "FavoriteCount": "0", "Title": "C++ shift operator precedence weirdness", "Id": "996844", "Score": "4", "Body": "<p>Consider the following code:</p>\n<pre><code>typedef vector&lt;int&gt; intVec;\n\nintVec&amp; operator&lt;&lt;(intVec&amp; dst, const int i) {\n    dst.push_back(i);\n    return dst;\n}\nint intResult0() {\n    return 23;\n}\nint intResult1() {\n    return 42;\n}\n\n// main\nintVec v;\nv &lt;&lt; intResult0() &lt;&lt; intResult1();\n</code></pre>\n<p>The weird thing is, that the compiler generates code, which evaluates <code>intResult1</code> <strong>BEFORE</strong> <code>intResult0</code> (tested with newest VC und gcc).\nWhy would the compiler do this? By doing so, the time between evaluation and usage of the respective values is (unnecessarily) increased(?), i.e. 42 is fetched first, but pushed last to the vector. \nDoes the C++ standard dictate this?</p>\n", "Tags": "<c++><operator-overloading>", "OwnerUserId": "62459", "AnswerCount": "4"}, "996857": {"ParentId": "996844", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The order of evaluation of sub-expressions between two sequence point is undefined.</p>\n<p>The above code is syntactic sugar for:</p>\n<pre><code>v.operator&lt;&lt;(intResult0()).operator&lt;&lt;(intResult1());\n</code></pre>\n<p>The only constraint the compiler has, is that it must evaluate all parameters before a method is called and obey the precedence rules. But as long as it follows these rules  each implementation is allowed to choose the details and as such this order may change between compilers.</p>\n<p>In this example:  </p>\n<ul>\n<li>So it is perfectly legal to call intResult1() before intResult2().  </li>\n<li>But intResult0() must be called before the call to operator&lt;&lt;() (left)  </li>\n<li>and intResult1() must be called before the call to operator&lt;&lt;() (right)  </li>\n<li>and operator&lt;&lt;() (left) must be called before operator&lt;&lt;() (right)</li>\n</ul>\n<p>See here for more info:<br>\n<a href=\"https://stackoverflow.com/questions/367633/what-are-all-the-common-undefined-behaviour-that-c-programmer-should-know-about/367663#367663\">What are all the common undefined behaviours that a C++ programmer should know about?</a></br></p>\n<p>and </p>\n<p><a href=\"https://stackoverflow.com/questions/367633/what-are-all-the-common-undefined-behaviour-that-c-programmer-should-know-about/367690#367690\">What are all the common undefined behaviours that a C++ programmer should know about?</a></p>\n", "OwnerUserId": "14065", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:30:43.360", "Id": "996857", "Score": "14", "CreationDate": "2009-06-15T15:46:58.197", "LastActivityDate": "2009-06-15T15:58:02.197"}, "996868": {"ParentId": "996844", "CommentCount": "0", "Body": "<p>According to Stroustrup section 6.2.2: </p>\n<blockquote>\n<p id=\"so_996844_996868_0\">The order of evaluation of\n  subexpressions within an expression is\n  undefined.</p>\n</blockquote>\n", "OwnerUserId": "102371", "PostTypeId": "2", "Id": "996868", "Score": "12", "CreationDate": "2009-06-15T15:50:00.257", "LastActivityDate": "2009-06-15T15:50:00.223"}, "997206": {"ParentId": "996844", "CommentCount": "0", "Body": "<p>The C++ Standard, 5:4</p>\n<blockquote>\n<p id=\"so_996844_997206_0\">Except where noted, the order of\n  evaluation of operands of individual\n  operators and subexpressions of\n  individual expressions, and the order\n  in which side effects take place, is\n  unspecified</p>\n</blockquote>\n", "OwnerUserId": "13005", "PostTypeId": "2", "Id": "997206", "Score": "2", "CreationDate": "2009-06-15T17:01:47.010", "LastActivityDate": "2009-06-15T17:01:46.963"}, "bq_ids": {"n4140": {"so_996844_997206_0": {"section_id": 5811, "quality": 0.6470588235294118, "length": 11}}, "n3337": {"so_996844_997206_0": {"section_id": 5584, "quality": 0.6470588235294118, "length": 11}}, "n4659": {"so_996844_996868_0": {"section_id": 7272, "quality": 0.5714285714285714, "length": 4}, "so_996844_997206_0": {"section_id": 7272, "quality": 0.5882352941176471, "length": 10}}}, "996856": {"ParentId": "996844", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>This has nothing to do with precedence.  </p>\n<p>There is no sequence point in that last statement, so the compiler is free to evaluate the sub-expressions in whatever order it likes as long as precedence is used when combining the sub-expressions.</p>\n<p>Note that precedence does <em>not</em> define an overall order of evaluation - it just defines how the operands of an expression with several operators will be combined. </p>\n<p>For example, in the following expression:</p>\n<pre><code>a() * b() + c()\n</code></pre>\n<p>at some point, the compiler would need to evaluate <code>(a() * b())</code> before adding in the result of <code>c()</code>, but there's nothing that says what order each individual function call needs to be made.  The compiler can quite easily decide to call <code>c()</code> first, push the result on a stack, then do whatever it needs to do to evaluate the <code>(a() * b())</code> expression (in which case, it might decide to evaluate <code>b()</code> first).</p>\n<p>The only role that precedence plays is that the compiler is not permitted to evaluate the expression as:</p>\n<pre><code>a() * (b() + c())\n</code></pre>\n", "OwnerUserId": "12711", "LastEditorUserId": "56338", "LastEditDate": "2009-06-15T16:14:31.297", "Id": "996856", "Score": "10", "CreationDate": "2009-06-15T15:46:55.480", "LastActivityDate": "2009-06-15T16:14:31.297"}});