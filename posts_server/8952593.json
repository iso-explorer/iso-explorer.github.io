post_cb({"8952691": {"Id": "8952691", "PostTypeId": "2", "Body": "<p>Any variable can be declared <code>const</code> or <code>volatile</code> (or both), but they have different semantics.</p>\n<p>The <code>const</code> keyword indicates that a variable is constant. The <code>volatile</code> keyword indicates that a variable may have its content changed even when you don't assign anything to it.</p>\n<p>For example, if you have this piece of code</p>\n<pre><code>int a = ...;\nint b = ...;\nint sum1 = (a + b) * 2;\nint sum2 = (a + b) + 16;\n</code></pre>\n<p>and enable optimizations on your compiler, the compiler can optimize the previous code into this:</p>\n<pre><code>int a = ...;\nint b = ...;\nint temp = a + b;\nint sum1 = temp * 2;\nint sum2 = temp + 16;\n</code></pre>\n<p>This optimization occurs because the compiler assumes that the values of a and b will not change when calculating sum1 and sum2, therefore a + b will not change. If you declare a or b as <code>volatile</code>, this assumption is negated, which means that the compiler will produce code that calculates a + b each time and not store it in a temporary location. This is because by declaring a or b <code>volatile</code> indicates that a or b (and, consequently, a + b) may have changed between the execution of the two statements.</p>\n<p>Although <code>volatile</code> seems like a useless keyword, it has its uses in multithreading applications and when doing memory-mapped I/O (that is using the system memory for communicating with hardware). For instance, in the GameBoy Advance, one has to read a specific memory location to determine which keys are pressed at a time. If you declare a pointer to that specific memory location as volatile, it will always be guaranteed that you will read that specific data from memory each time.</p>\n", "LastEditorUserId": "676939", "LastActivityDate": "2012-01-21T11:53:35.127", "Score": "1", "CreationDate": "2012-01-21T11:40:49.137", "ParentId": "8952593", "CommentCount": "2", "OwnerUserId": "676939", "LastEditDate": "2012-01-21T11:53:35.127"}, "8952593": {"ViewCount": "366", "Body": "<p>I wonder if <code>volatile</code> can be used anywhere <code>const</code> can, and what each case would mean.</p>\n<pre><code>volatile dummy_class\nvolatile dummy_class&amp;\ndummy_class volatile*\ndummy_class *volatile\ndummy_class volatile *volatile\n</code></pre>\n<p>These are all distinct cases when <code>const</code> is involved, do the same semantics apply for <code>volatile</code>?</p>\n", "AcceptedAnswerId": "8952728", "Title": "Can volatile be used everywhere const is used?", "CreationDate": "2012-01-21T11:25:48.247", "Id": "8952593", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2012-01-21T19:42:50.240", "Score": "4", "OwnerUserId": "256138", "Tags": "<c++><const><volatile>", "AnswerCount": "4"}, "8956095": {"Id": "8956095", "PostTypeId": "2", "Body": "<p>In C++2003 I think you cannot define a <code>static int volatile</code> member of a class while you can do this with a <code>static int const</code> member: the latter becomes a constant expression and as long as you don't need an address or a reference of the object you'll be fine. For C++2011 I don't know whether this has changed because you can initialize members in the class definition and I don't know if this extends to static members.</p>\n", "LastActivityDate": "2012-01-21T19:42:50.240", "CommentCount": "0", "CreationDate": "2012-01-21T19:42:50.240", "ParentId": "8952593", "Score": "1", "OwnerUserId": "1120273"}, "bq_ids": {"n4140": {"so_8952593_8952728_2": {"length": 9, "quality": 1.0, "section_id": 5804}, "so_8952593_8952728_3": {"length": 43, "quality": 0.9347826086956522, "section_id": 5892}, "so_8952593_8952728_0": {"length": 62, "quality": 0.6391752577319587, "section_id": 7225}, "so_8952593_8952663_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 5399}}, "n3337": {"so_8952593_8952728_2": {"length": 9, "quality": 1.0, "section_id": 5577}, "so_8952593_8952728_3": {"length": 43, "quality": 0.9347826086956522, "section_id": 5663}, "so_8952593_8952728_1": {"length": 28, "quality": 0.875, "section_id": 6971}, "so_8952593_8952728_0": {"length": 89, "quality": 0.9175257731958762, "section_id": 6969}, "so_8952593_8952663_1": {"length": 14, "quality": 0.9333333333333333, "section_id": 5194}}, "n4659": {"so_8952593_8952728_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 7262}, "so_8952593_8952728_3": {"length": 43, "quality": 0.9347826086956522, "section_id": 7375}, "so_8952593_8952728_0": {"length": 54, "quality": 0.5567010309278351, "section_id": 8735}}}, "8952728": {"Id": "8952728", "PostTypeId": "2", "Body": "<p>This is section 3.9.3 <em>CV-qualifiers</em> from C++11 draft n3290:</p>\n<blockquote>\n<p id=\"so_8952593_8952728_0\">A type mentioned in 3.9.1 and 3.9.2 is a cv-unqualified type. <strong><em>Each type</em> which is a cv-unqualified complete\n  or incomplete object type or is void (3.9) has three corresponding cv-qualified versions of its type</strong>: a\n  const-qualified version, a volatile-qualified version, and a const-volatile-qualified version. The term object\n  type (1.8) includes the cv-qualifiers specified when the object is created. The presence of a const specifier\n  in a decl-specifier-seq declares an object of const-qualified object type; such object is called a const object.\n  The presence of a volatile specifier in a decl-specifier-seq declares an object of volatile-qualified object type;\n  such object is called a volatile object. The presence of both cv-qualifiers in a decl-specifier-seq declares an\n  object of const-volatile-qualified object type; such object is called a const volatile object. The cv-qualified or\n  cv-unqualified versions of a type are distinct types; however, they shall have the same representation and\n  alignment requirements (3.9).51</p>\n</blockquote>\n<p>So <code>const</code> and <code>volatile</code> can be used in the same spots, possibly in conjuction.</p>\n<p>Paragraph 3 of that section notes a slight difference in how they apply to class objects:</p>\n<blockquote>\n<p id=\"so_8952593_8952728_1\">Each non-static, <em>non-mutable</em>, non-reference data member of a const-qualified class object is const-quali-\n  fied, each non-static, non-reference data member of a volatile-qualified class object is volatile-qualified and\n  similarly for members of a const-volatile class. See 8.3.5 and 9.3.2 regarding function types that have\n  cv-qualifiers.</p>\n</blockquote>\n<p>but that's pretty logical.</p>\n<p><code>volatile</code>-qualified objects have stricter requirements for the <em>as-if</em> rule, namely:</p>\n<blockquote>\n<p id=\"so_8952593_8952728_2\">Access to volatile objects are evaluated strictly according to the rules of the abstract machine.</p>\n</blockquote>\n<p>The volatility gets attached to the object in the same way <code>const</code> does:</p>\n<pre><code>dummy_class volatile* // non-volatile pointer to volatile object\ndummy_class *volatile // volatile pointer to non-volatile object\ndummy_class volatile *volatile // volatile pointer to volatile object\n</code></pre>\n<p>For non-static member functions (\u00a79.3.1):</p>\n<blockquote>\n<p id=\"so_8952593_8952728_3\">A non-static member function may be declared const, volatile, or const volatile. <strong>These cv-qualifiers\n  affect the type of the this pointer</strong> (9.3.2). They also affect the function type (8.3.5) of the member function;\n  a member function declared const is a const member function, a member function declared volatile is\n  a volatile member function and a member function declared const volatile is a const volatile member\n  function.</p>\n</blockquote>\n<p>So volatility like const-ness applies to the type of <code>this</code> inside the function.</p>\n<p>Neither <code>const</code> nor <code>volatile</code> can be applied to static member functions.</p>\n", "LastActivityDate": "2012-01-21T11:48:07.847", "CommentCount": "0", "CreationDate": "2012-01-21T11:48:07.847", "ParentId": "8952593", "Score": "2", "OwnerUserId": "635608"}, "8952663": {"Id": "8952663", "PostTypeId": "2", "Body": "<p>Almost. Both are <em>cv-qualifiers</em> and can be used almost everywhere where the other can. The only place they appears in C++ grammar is here:</p>\n<blockquote>\n<p id=\"so_8952593_8952663_0\">cv-qualifier:<br/>\n  \u00a0\u00a0\u00a0\u00a0<code>const</code><br/>\n  \u00a0\u00a0\u00a0\u00a0<code>volatile</code></p>\n</blockquote>\n<p>And the rest of the grammar references them as <em>cv-qualifier</em>.</p>\n<p>Note that one place you didn't mention where <em>cv-qualifiers</em> can be used is:</p>\n<pre><code>struct X {\n    void f() const;\n    void g() volatile;\n    void h() const volatile;\n};\n</code></pre>\n<p>See <a href=\"http://drdobbs.com/cpp/184403766\" rel=\"nofollow\">http://drdobbs.com/cpp/184403766</a> for a use of the later.</p>\n<p><strong>However,</strong> there is a rule that you <em>cannot combine <code>const</code> and <code>mutable</code></em> like in:</p>\n<pre><code>stuct X {\n    mutable const int x; // error\n    mutable volatile int y; // valid\n};\n</code></pre>\n<p>The relevant place int the standard is [dcl.stc]:</p>\n<blockquote>\n<p id=\"so_8952593_8952663_1\">The mutable specifier can be applied only to names of class data members (9.2) and cannot be applied to names declared const or static [...]</p>\n</blockquote>\n", "LastEditorUserId": "277176", "LastActivityDate": "2012-01-21T12:13:05.793", "Score": "6", "CreationDate": "2012-01-21T11:36:41.993", "ParentId": "8952593", "CommentCount": "1", "OwnerUserId": "277176", "LastEditDate": "2012-01-21T12:13:05.793"}});