post_cb({"bq_ids": {"n4140": {"so_31316229_31316428_0": {"length": 22, "quality": 1.0, "section_id": 307}}, "n3337": {"so_31316229_31316428_0": {"length": 22, "quality": 1.0, "section_id": 298}}, "n4659": {"so_31316229_31316428_0": {"length": 21, "quality": 0.9545454545454546, "section_id": 314}}}, "31316229": {"ViewCount": "252", "Body": "<p>This question is spawned from<br>\n<a href=\"https://stackoverflow.com/questions/31309846/passing-a-member-function-pointer-to-an-overloaded-class-method-into-a-template\">Passing a member function pointer to an overloaded class method into a template function</a>.<br>\nYou need not read that to understand this question. Probably both the questions will have the same answer.</br></br></p>\n<p>I am getting <a href=\"http://ideone.com/wJvaxn\" rel=\"nofollow noreferrer\">compiler error for below simple code</a>.</p>\n<pre><code>#include&lt;set&gt;\ntemplate&lt;typename Return, typename T&gt;\nT ReceiveFuncPtr (Return (T::*Method)(const int&amp;))\n{\n  T obj;  // Found and declared an object of actual container class\n  (obj.*Method)(1);  // Some processing\n  return obj;  // Returned that container class object with RVO\n} \nint main ()\n{\n  ReceiveFuncPtr(&amp;std::set&lt;int&gt;::insert); // ERROR\n}\n</code></pre>\n<p>The error is interesting:</p>\n<pre><code> In function 'int main()':\nerror: no matching function for call to 'ReceiveFuncPtr(&lt;unresolved overloaded function type&gt;)'\n   ReceiveFuncPtr(&amp;std::set&lt;int&gt;::insert); // ERROR\n                                        ^   \nnote: candidate is: \nnote: template&lt;class Return, class T&gt; T ReceiveFuncPtr(Return (T::*)(const int&amp;))\n T ReceiveFuncPtr (Return (T::*Method)(const int&amp;))\n   ^   \nnote:   template argument deduction/substitution failed:\nnote:   mismatched types 'const int&amp;' and 'std::initializer_list&lt;int&gt;'\n   ReceiveFuncPtr(&amp;std::set&lt;int&gt;::insert); // ERROR\n                                        ^   \nnote:   mismatched types 'const int&amp;' and 'std::set&lt;int&gt;::const_iterator {aka std::_Rb_tree_const_iterator&lt;int&gt;}'\nnote:   mismatched types 'const int&amp;' and 'std::set&lt;int&gt;::const_iterator {aka std::_Rb_tree_const_iterator&lt;int&gt;}'\nnote:   mismatched types 'const int&amp;' and 'std::set&lt;int&gt;::value_type&amp;&amp; {aka int&amp;&amp;}'\nnote:   couldn't deduce template parameter 'Return'\n</code></pre>\n<p>If you look at the <em>note</em>s closely then it appears that compiler is matching all the other methods except the right one! In this case compiler should have matched <code>insert(const std::set&lt;int&gt;::value_type&amp;)</code> aka <code>const int&amp;</code>. If I change the <code>ReceiveFuncPtr()</code> to match some other overload, it will again fail by skipping that overload.</p>\n<p>To debug this situation, I created handcrafted version of <code>std::set</code>. But that <a href=\"http://ideone.com/ioNWD3\" rel=\"nofollow noreferrer\">compiles fine</a>:</p>\n<pre><code>template&lt;typename T, typename T2 = void&gt;\nstruct MySet\n{\n  std::pair&lt;T,bool&gt; insert (const T&amp; i) { return std::pair&lt;T,bool&gt;(T(),true); }\n  std::pair&lt;T,bool&gt; insert (T&amp;&amp; i) { return std::pair&lt;T,bool&gt;(T(),true); }\n  void insert (std::initializer_list&lt;T&gt; i) { return false; }\n}\nint main ()\n{\n  ReceiveFuncPtr(&amp;MySet&lt;int&gt;::insert);  // OK\n}\n</code></pre>\n<p>After surfing, I came across this post:<br>\n<a href=\"https://stackoverflow.com/questions/13521030/what-are-the-rules-for-function-pointers-and-member-function-pointers-to-standar\">What are the rules for function pointers and member function pointers to Standard functions?</a></br></p>\n<p>Though it's related , it doesn't solve problem.</p>\n<p><strong>Question</strong>: Why member function substitution fails in case of standard library method when the the same thing passes for handwritten class method?</p>\n<p><strong>Update</strong>:</p>\n<p>After looking at the correct answer, I am sure that <code>insert</code> cannot be used. The only way would be ugly typecasting which is an overkill for this problem.<br>\nOne elegant <strong>solution</strong> is to use <code>std::set&lt;int&gt;::emplace&lt;const int&amp;&gt;</code> which has only <code>template</code>d version unlike insert which has mix of <code>template</code> and non-<code>template</code> versions.<br>\nCall the function as below:</br></br></p>\n<pre><code>ReceiveFuncPtr(&amp;std::set&lt;int&gt;::emplace&lt;const int&amp;&gt;);\n</code></pre>\n<p>Above <a href=\"http://ideone.com/ps4PJb\" rel=\"nofollow noreferrer\">compiles fine</a>.</p>\n", "AcceptedAnswerId": "31316428", "Title": "Member function pointer issue with standard library methods", "CreationDate": "2015-07-09T11:33:00.373", "Id": "31316229", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T10:26:45.440", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-09T12:23:58.280", "Score": "6", "OwnerUserId": "514235", "Tags": "<c++><templates><c++11><standard-library><member-function-pointers>", "AnswerCount": "1"}, "31316428": {"Id": "31316428", "PostTypeId": "2", "Body": "<p>The problem isn't with the <code>insert</code> functions you showed in <code>MySet</code>. The problem is with one of the ones you omitted. Specifically:</p>\n<pre><code>template&lt; class InputIt &gt;\nvoid insert( InputIt first, InputIt last );\n</code></pre>\n<p>From [temp.deduct.call]:</p>\n<blockquote>\n<p id=\"so_31316229_31316428_0\">When P is a function type, pointer to function type, or pointer to member function type:<br>\n  \u2014 If the argument is an overload set containing one or more function templates, the parameter is treated\n  as a non-deduced context.</br></p>\n</blockquote>\n<p>Since <a href=\"http://en.cppreference.com/w/cpp/container/set/insert\" rel=\"nofollow\"><code>&amp;std::set&lt;int&gt;::insert</code></a> is precisely such an overload set, the parameter is a non-deduced context and cannot be resolved. Your example of <code>MySet</code> does not contain a function template overload for <code>insert</code>, which is why it works fine. If you add one, you'll see that it will also fail to compile.</p>\n", "LastEditorUserId": "2069064", "LastActivityDate": "2015-07-09T12:20:25.457", "Score": "7", "CreationDate": "2015-07-09T11:42:45.510", "ParentId": "31316229", "CommentCount": "6", "LastEditDate": "2015-07-09T12:20:25.457", "OwnerUserId": "2069064"}});