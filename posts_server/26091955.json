post_cb({"bq_ids": {"n4140": {"so_26091955_26091993_3": {"length": 22, "quality": 0.9166666666666666, "section_id": 37}, "so_26091955_26091993_1": {"length": 38, "quality": 0.9743589743589743, "section_id": 35}}, "n3337": {"so_26091955_26091993_3": {"length": 22, "quality": 0.9166666666666666, "section_id": 34}, "so_26091955_26091993_1": {"length": 38, "quality": 0.9743589743589743, "section_id": 32}}, "n4659": {"so_26091955_26091993_3": {"length": 20, "quality": 0.8333333333333334, "section_id": 37}, "so_26091955_26091993_1": {"length": 34, "quality": 0.8717948717948718, "section_id": 35}}}, "26091993": {"Id": "26091993", "PostTypeId": "2", "Body": "<p>The behaviour is according to the standard:</p>\n<blockquote>\n<p id=\"so_26091955_26091993_0\"><strong>4.8 Floating point conversions [conv.double]</strong></p>\n<p id=\"so_26091955_26091993_1\">A prvalue of floating point type can be converted to a prvalue of another floating point type. If the\n  source value can be exactly represented in the destination type, the result of the conversion is that exact\n  representation. If the source value is between two adjacent destination values, the result of the conversion\n  is an implementation-defined choice of either of those values. Otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>Moreover, values floating point type can be converted to values of integer type:</p>\n<blockquote>\n<p id=\"so_26091955_26091993_2\"><strong>4.9 Floating-integral conversions [conv.fpint]</strong></p>\n<p id=\"so_26091955_26091993_3\">A prvalue of a floating point type can be converted to a prvalue of an integer type. The conversion truncates;\n  that is, the fractional part is discarded. The behavior is undefined if the truncated value cannot be\n  represented in the destination type.</p>\n</blockquote>\n", "LastActivityDate": "2014-09-29T03:11:55.663", "Score": "1", "CreationDate": "2014-09-29T03:11:55.663", "ParentId": "26091955", "CommentCount": "4", "OwnerUserId": "3246555"}, "26091955": {"ViewCount": "265", "Body": "<p>When I compile the following code on a Mac 64-bit machine with OSX 10.8 and g++ 4.2.1 no warning is generated.</p>\n<pre><code>#include \"stdio.h\"\n\nint main()\n{\n    double d= 3.14159;\n    float res= d;\n    printf(\"%f\\n\", res);\n    return 0;\n}\n</code></pre>\n<p>Clearly, automatically demoting a double to a float is potentially very dangerous, but the compiler does not generate any warning. The only solution I could find was to use the flag <em>-Wshorten-64-to-32</em>.</p>\n<p>It seems to me such an obvious mistake that I am surprised the compiler does not catch this error by default. Is there any reason why g++ does not catch this error by default? Is there a better way to generate the warning without using the <em>-Wshorten-64-to-32</em>? </p>\n<p>In case you wonder, <em>-Wall</em> will not generate a warning either...</p>\n<p>Thank you for your help in advance.</p>\n", "AcceptedAnswerId": "26091993", "Title": "No warning when demoting double to float", "CreationDate": "2014-09-29T03:06:00.267", "LastActivityDate": "2014-09-29T03:11:55.663", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "Tags": "<c++><osx><g++><double>", "Id": "26091955", "Score": "0", "OwnerUserId": "4089654", "ClosedDate": "2014-09-29T07:28:22.830", "AnswerCount": "1"}});