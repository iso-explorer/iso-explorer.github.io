post_cb({"bq_ids": {"n4140": {"so_1197340_1197490_1": {"length": 29, "quality": 1.0, "section_id": 268}, "so_1197340_1197490_0": {"length": 56, "quality": 1.0, "section_id": 223}, "so_1197340_1197490_2": {"length": 11, "quality": 0.6470588235294118, "section_id": 7043}}, "n3337": {"so_1197340_1197490_1": {"length": 29, "quality": 1.0, "section_id": 259}, "so_1197340_1197490_0": {"length": 56, "quality": 1.0, "section_id": 216}, "so_1197340_1197490_2": {"length": 11, "quality": 0.6470588235294118, "section_id": 6788}}, "n4659": {"so_1197340_1197490_1": {"length": 29, "quality": 1.0, "section_id": 275}, "so_1197340_1197490_0": {"length": 54, "quality": 0.9642857142857143, "section_id": 231}, "so_1197340_1197490_2": {"length": 11, "quality": 0.6470588235294118, "section_id": 8540}}}, "1197490": {"Id": "1197490", "PostTypeId": "2", "Body": "<p>It's not possible. If you have a template that behaves that way, it violates the ODR and / or other rules, such as that a specialization should be declared before it would be instantiated. So you can't just put a specialization that would somehow change a typedef member to make it resolve to a different type for all following references. </p>\n<p>Remember that <code>Foo&lt;T&gt;</code> references a class if <code>Foo</code> is a class template. If the class's typedef member is defined to be one type at one point in the program, and another type at another point, then something must have been gone wrong. Here are various Standard quotes that concern this</p>\n<hr>\n<blockquote>\n<p id=\"so_1197340_1197490_0\">A specialization for a function template, a member function template, or of a member function or static data member of a class template may have multiple points of instantiations within a translation unit. A specialization for a class template has at most one point of instantiation within a translation unit. A specialization for any template may have points of instantiation in multiple translation units. If two different points of instantiation give a template specialization different meanings according to the one definition rule (3.2), the program is ill-formed, no diagnostic required.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_1197340_1197490_1\">If a template, a member template or the member of a class template is explicitly specialized then that specialization shall be declared before the first use of that specialization that would cause an implicit instantiation to take place, in every translation unit in which such a use occurs; no diagnostic is required.</p>\n</blockquote>\n<hr>\n<p>(Various \"noise\" skipped) </p>\n<blockquote>\n<p id=\"so_1197340_1197490_2\">[..Various entities that may be defined multiple in the whole program..]. Given such an entity named D defined in more than one translation unit, then </p>\n<ul>\n<li>each definition of D shall consist of the same sequence of tokens; </li>\n<li>in each definition of D, corresponding names, looked up according to 3.4, shall refer to an entity defined within the definition of D, or shall refer to the same entity, after overload resolution (13.3) and after matching of partial template specialization (14.8.3)...</li>\n<li>If D is a template, and is defined in more than one translation unit, then the last four\n  requirements from the list above shall apply to names from the template\u2019s enclosing scope used in the template definition (14.6.3), and also to dependent names at the point of instantiation (14.6.2). If the definitions of D satisfy all these requirements, then the program shall behave as if there were a single definition of D. If the definitions of D do not satisfy these requirements, then the behavior is undefined.</li>\n</ul>\n</blockquote>\n</hr></hr></hr>", "LastActivityDate": "2009-07-29T00:33:33.887", "CommentCount": "1", "CreationDate": "2009-07-29T00:33:33.887", "ParentId": "1197340", "Score": "10", "OwnerUserId": "34509"}, "1197340": {"ViewCount": "200", "Body": "<p>Is it possible to write an impure template in C++? That is, a template that will sometimes give a different resulting type or int for the same template parameters. For example, is it possible to write a template <code>Foo&lt;T&gt;</code> where <code>Foo&lt;int&gt;::type</code> is sometimes <code>char</code> and at other times <code>float</code>? Or a template <code>Foo&lt;T&gt;</code> where <code>Foo&lt;double&gt;::my_static_const_int</code> is sometimes 10 and other times 20?</p>\n", "AcceptedAnswerId": "1197490", "Title": "Is it possible to write an impure template in C++?", "CreationDate": "2009-07-28T23:43:58.290", "Id": "1197340", "CommentCount": "9", "LastEditDate": "2013-03-14T03:15:54.460", "PostTypeId": "1", "LastEditorUserId": "248129", "LastActivityDate": "2013-03-14T03:15:54.460", "Score": "6", "OwnerUserId": "50385", "Tags": "<c++><templates><functional-programming><purely-functional>", "AnswerCount": "1"}});