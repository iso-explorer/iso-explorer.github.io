post_cb({"25220229": {"CommentCount": "2", "AcceptedAnswerId": "25220259", "PostTypeId": "1", "LastEditorUserId": "2551142", "CreationDate": "2014-08-09T15:41:26.863", "LastActivityDate": "2017-04-27T18:13:50.967", "LastEditDate": "2017-04-27T18:13:50.967", "ViewCount": "1996", "FavoriteCount": "0", "Title": "In C++ Inheritance, Derived class destructor not called when pointer object to base class is pointed to derived class", "Id": "25220229", "Score": "2", "Body": "<p>I am a newbie and I know this is a very basic concept and might be a duplicate too.\nIs it not true that once a constructor is called its corresponding destructor has to be called?\n[code run on Dev C++]</p>\n<pre><code>class Base\n    {\n     public:\n            Base() { cout&lt;&lt;\"Base Constructor\\n\";}\n            int b;\n     ~Base() {cout &lt;&lt; \"Base Destructor\\n\"; }\n    };\n\nclass Derived:public Base\n{\n public:\n        Derived() { cout&lt;&lt;\"Derived Constructor\\n\";}\n        int a;\n ~Derived() { cout&lt;&lt; \"Derived Destructor\\n\"; }\n}; \nint main () {\nBase* b = new Derived;    \n//Derived *b = new Derived;\n delete b;\n    getch();\n    return 0;\n}\n</code></pre>\n<p>GIVES OUTPUT</p>\n<pre><code>Base Constructor\nDerived Constructor\nBase Destructor\n</code></pre>\n", "Tags": "<c++><inheritance>", "OwnerUserId": "2551142", "AnswerCount": "2"}, "25220360": {"ParentId": "25220229", "CommentCount": "4", "CreationDate": "2014-08-09T15:55:38.457", "OwnerUserId": "3204551", "PostTypeId": "2", "Id": "25220360", "Score": "2", "Body": "<p>There is no need to call a destructor if it is trivial.</p>\n<p>That does not help in your example though, because if a class has a sub-object with non-trivial destructor (member or base) or its own destructor is user-defined, it is not trivial.</p>\n<p>Also, you may only delete a class using a pointer to base, if that base-class has a <code>virtual</code> destructor, on pain of <a href=\"https://stackoverflow.com/q/2397984\">undefined behavior</a> (The compiler need not warn you).</p>\n<p>Pro-tip: If you need to make it virtual (for example due to above requirement), but do not want to prevent it from being trivial (some containers and algorithms have optimized implementations for trivial types), use:</p>\n<pre><code>virtual ~MyClass = default; // Since C++11\n</code></pre>\n<p>So, never delete using a pointer to <code>Base</code> if <code>Base</code> does not have a virtual destructor or it is actually really a base.</p>\n", "LastActivityDate": "2014-08-09T15:55:38.457"}, "25220259": {"ParentId": "25220229", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-08-09T15:44:54.483", "Score": "3", "LastEditorUserId": "3133316", "LastEditDate": "2014-08-09T15:52:38.220", "Id": "25220259", "OwnerUserId": "3133316", "Body": "<p>Your code has undefined behavior.  The base class's destructor must be <code>virtual</code> for the following to have defined behavior.</p>\n<pre><code>Base* b = new Derived;    \ndelete b;\n</code></pre>\n<p>From the C++ standard:</p>\n<blockquote>\n<p id=\"so_25220229_25220259_0\">5.3.5 Delete</p>\n<p id=\"so_25220229_25220259_1\">3 In the first alternative (delete object), if the static type of the\n  operand is different from its dynamic type, the static type shall be a base class of the operand\u2019s dynamic type and the static type shall have a virtual destructor or the behavior is undefined.</p>\n</blockquote>\n<p>So in your case, the static type is <code>Base</code>, and the dynamic type is <code>Derived</code>.  So the <code>Base</code>'s destructor should be:</p>\n<pre><code>virtual ~Base() {cout &lt;&lt; \"Base Destructor\\n\"; }\n</code></pre>\n", "LastActivityDate": "2014-08-09T15:52:38.220"}, "bq_ids": {"n4140": {"so_25220229_25220259_1": {"section_id": 6107, "quality": 0.88, "length": 22}}, "n3337": {"so_25220229_25220259_1": {"section_id": 5873, "quality": 0.88, "length": 22}}, "n4659": {"so_25220229_25220259_1": {"section_id": 7604, "quality": 0.88, "length": 22}}}});