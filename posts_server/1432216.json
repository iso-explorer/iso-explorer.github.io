post_cb({"1432680": {"ParentId": "1432216", "CommentCount": "0", "Body": "<p>A couple points:</p>\n<p>1) end() references an element that is past the end of the container. It doesn't change when inserts or deletes change the container because it's not pointing to an element.</p>\n<p>2) I think perhaps your idea of storing an array of 4 iterators in the Node could be changed to make the entire problem make more sense.  What you want is to add a new iterator type to the Graph object that is capable of iterating over a single node's neighbours.  The implementation of this iterator will need to access the members of the map, which possibly leads you down the path of making the Graph class extend the map collection.  With the Graph class being an extended std::map, then the language changes, and you no longer need to store an invalid iterator, but instead simply need to write the algorithm to determine who is the 'next neighbour' in the map.</p>\n", "OwnerUserId": "15852", "PostTypeId": "2", "Id": "1432680", "Score": "1", "CreationDate": "2009-09-16T12:36:01.550", "LastActivityDate": "2009-09-16T12:36:01.550"}, "1434214": {"ParentId": "1432216", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I think it is clear:</p>\n<ul>\n<li><p>end() returns an iterator to the element one passed the end.</p></li>\n<li><p>Insertion/Deletion do not affect existing iterators so the returned values is always valid (unless you try to delete the element one passed then end (but that would result in undefined behavior anyway).</p></li>\n<li><p>Thus any new iterator generated by end() (would be different but) when compared with the original using operator== would return true.</p></li>\n<li><p>Also any intermediate values generated using the assignment operator= have a post condition that they compare equal with operator== and operator== is transitive for iterators.</p></li>\n</ul>\n<p>So yes it is valid to store the iterator returned by end() (but only because of the guarantees with associative containers, therefor it would not be valid for vector etc).</p>\n<p>Remember the iterator is not necessarily a pointer. It can potentially be an object where the designer of the container has defined all the operations on the class.</p>\n", "OwnerUserId": "14065", "LastEditorUserId": "47984", "LastEditDate": "2009-09-16T19:02:02.347", "Id": "1434214", "Score": "1", "CreationDate": "2009-09-16T16:57:50.553", "LastActivityDate": "2009-09-16T19:02:02.347"}, "1432216": {"CommentCount": "10", "ViewCount": "2136", "PostTypeId": "1", "LastEditorUserId": "143642", "CreationDate": "2009-09-16T10:41:40.567", "LastActivityDate": "2011-04-01T07:11:08.553", "Title": "Is end() required to be constant in an STL map/set?", "FavoriteCount": "7", "LastEditDate": "2009-09-16T11:53:50.850", "Id": "1432216", "Score": "31", "Body": "<p>\u00a723.1.2.8 in the standard states that insertion/deletion operations on a set/map will not invalidate any iterators to those objects (except iterators pointing to a deleted element).</p>\n<p>Now, consider the following situation: you want to implement a graph with uniquely numbered nodes, where every node has a fixed number (let's say 4) of neighbors. Taking advantage of the above rule, you do it like this:</p>\n<pre><code>class Node {\n    private:\n        // iterators to neighboring nodes\n        std::map&lt;int, Node&gt;::iterator neighbors[4];\n        friend class Graph;\n};\n\nclass Graph {\n    private:\n        std::map&lt;int, Node&gt; nodes;\n};\n</code></pre>\n<p>(<strong>EDIT</strong>: Not literally like this due to the incompleteness of <code>Node</code> in line 4 (see responses/comments), but along these lines anyway)</p>\n<p>This is good, because this way you can insert and delete nodes without invalidating the consistency of the structure (assuming you keep track of deletions and remove the deleted iterator from every node's array).</p>\n<p>But let's say you also want to be able to store an \"invalid\" or \"nonexistent\" neighbor value. Not to worry, we can just use <code>nodes.end()</code>... or can we? Is there some sort of guarantee that <code>nodes.end()</code> at 8 AM will be the same as <code>nodes.end()</code> at 10 PM after a zillion insertions/deletions? That is, can I safely <code>==</code> compare an iterator received as a parameter to <code>nodes.end()</code> in some method of Graph?</p>\n<p>And if not, would this work?</p>\n<pre><code>class Graph {\n    private:\n        std::map&lt;int, Node&gt; nodes;\n        std::map&lt;int, Node&gt;::iterator _INVALID;\n    public:\n        Graph() { _INVALID = nodes.end(); }\n};\n</code></pre>\n<p>That is, can I store <code>nodes.end()</code> in a variable upon construction, and then use this variable whenever I want to set a neighbor to invalid state, or to compare it against a parameter in a method? Or is it possible that somewhere down the line a valid iterator pointing to an existing object will compare equal to <code>_INVALID</code>?</p>\n<p>And if this doesn't work either, what <em>can</em> I do to leave room for an invalid neighbor value?</p>\n", "Tags": "<c++><stl><iterator>", "OwnerUserId": "143642", "AnswerCount": "10"}, "1432796": {"ParentId": "1432216", "CommentCount": "0", "Body": "<p>Iterators in (multi)sets and (multi)maps won't be invalidated in insertions and deletions and thus <strong>comparing .end() against previous stored values of .end() will always yield true</strong>.</p>\n<p>Take as an example GNU libstdc++ implementation where .end() in maps returns the default intialized value of <code>Rb_tree_node</code></p>\n<p>From stl_tree.h:</p>\n<pre><code>  _M_initialize()\n  {\n    this-&gt;_M_header._M_color = _S_red;\n    this-&gt;_M_header._M_parent = 0;\n    this-&gt;_M_header._M_left = &amp;this-&gt;_M_header;\n    this-&gt;_M_header._M_right = &amp;this-&gt;_M_header;\n  }\n</code></pre>\n", "OwnerUserId": "72784", "PostTypeId": "2", "Id": "1432796", "Score": "1", "CreationDate": "2009-09-16T12:55:49.867", "LastActivityDate": "2009-09-16T12:55:49.867"}, "5510202": {"ParentId": "1432216", "CommentCount": "0", "Body": "<p>I had a similar question recently, but I was wondering if calling <code>end()</code> to retrieve an iterator for comparison purposes could possibly have race conditions.</p>\n<p>According to the standard, two iterators are considered equivalent if both can be dereferenced and <code>&amp;*a == &amp;*b</code> <strong>or if neither can be dereferenced.</strong> Finding the bolded statement took a while and is very relevant here.</p>\n<p>Because an <code>std::map::iterator</code> cannot be invalidated unless the element it points to has been removed, you're guaranteed that two iterators returned by <code>end</code>, regardless of what the state of the map was when they were obtained, will always compare to each other as true.</p>\n", "OwnerUserId": "214796", "PostTypeId": "2", "Id": "5510202", "Score": "0", "CreationDate": "2011-04-01T07:11:08.553", "LastActivityDate": "2011-04-01T07:11:08.553"}, "1432613": {"ParentId": "1432216", "CommentCount": "13", "Body": "<p>You write (emphasis by me): </p>\n<blockquote>\n<p id=\"so_1432216_1432613_0\">\u00a723.1.2.8 in the standard states that insertion/deletion operations on a set/map will not invalidate any iterators <em>to those objects</em> (except iterators pointing to a deleted element).</p>\n</blockquote>\n<p>Actually, the text of 23.1.2/8 is a bit different (again, emphasis by me): </p>\n<blockquote>\n<p id=\"so_1432216_1432613_1\">The insert members shall not affect the validity of iterators and references <em>to the container</em>, and the erase members shall invalidate only iterators and references to the erased elements.</p>\n</blockquote>\n<p>I read this as: If you have a map, and somehow obtain an iterator into this map (again: it doesn't say <em>to an object</em> in the map), this iterator will stay valid despite insertion and removal of elements. Assuming <code>std::map&lt;K,V&gt;::end()</code> obtains an \"iterator into the map\", it should not be invalidated by insertion/removal. </p>\n<p>This, of course, leaves the question whether \"not invalidated\" means it will always have the same value. My personal assumption is that this is not specified. However, in order for the \"not invalidated\" phrase to make sense, all results of <code>std::map&lt;K,V&gt;::end()</code> for the same map must always compare equal even in the face of insertions/removal: </p>\n<pre><code>my_map_t::iterator old_end = my_map.end();\n// wildly change my_map\nassert( old_end == my_map.end() ); \n</code></pre>\n<p>My interpretation is that, if <code>old_end</code> remains \"valid\" throughout changes to the map (as the standard promisses), then that assertion should pass. </p>\n<p><em>Disclaimer</em>: I am not a native speaker and have a <em>very</em> hard time digesting that dreaded legaleze of the Holy PDF. In fact, in general I avoid it like the plague. </p>\n<p>Oh, and my first thought also was: The question is interesting from an academic POV, but why doesn't he simply store keys instead of iterators? </p>\n", "OwnerUserId": "140719", "PostTypeId": "2", "Id": "1432613", "Score": "4", "CreationDate": "2009-09-16T12:18:31.627", "LastActivityDate": "2009-09-16T12:18:31.627"}, "bq_ids": {"n4140": {"so_1432216_1432613_1": {"section_id": 745, "quality": 0.9333333333333333, "length": 14}, "so_1432216_1434278_0": {"section_id": 745, "quality": 0.9333333333333333, "length": 14}, "so_1432216_1434278_1": {"section_id": 707, "quality": 1.0, "length": 6}}, "n3337": {"so_1432216_1432613_1": {"section_id": 734, "quality": 0.9333333333333333, "length": 14}, "so_1432216_1434278_0": {"section_id": 734, "quality": 0.9333333333333333, "length": 14}, "so_1432216_1434278_1": {"section_id": 697, "quality": 1.0, "length": 6}}, "n4659": {"so_1432216_1432613_1": {"section_id": 803, "quality": 0.9333333333333333, "length": 14}, "so_1432216_1434278_0": {"section_id": 803, "quality": 0.9333333333333333, "length": 14}, "so_1432216_1434278_1": {"section_id": 736, "quality": 1.0, "length": 6}}}, "1432651": {"ParentId": "1432216", "CommentCount": "2", "Body": "<p>23.1/7 says that end() returns an iterator that </p>\n<blockquote>\n<p id=\"so_1432216_1432651_0\">is the past-the-end value for the container.</p>\n</blockquote>\n<p>First, it confirms that what <code>end()</code> returns is the iterator.  Second, it says that the iterator doesn't point to a particular element.  Since deletion can only invalidate iterators that point somewhere (to the element being deleted), deletions can't invalidate <code>end()</code>.</p>\n", "OwnerUserId": "158676", "PostTypeId": "2", "Id": "1432651", "Score": "4", "CreationDate": "2009-09-16T12:29:25.083", "LastActivityDate": "2009-09-16T12:29:25.083"}, "1433001": {"ParentId": "1432216", "CommentCount": "1", "Body": "<p>I believe that this depends entirely on what type of iterator is being used. </p>\n<p>In a vector, end() is the one past the end pointer and it will obviously change as elements are inserted and removed.</p>\n<p>In another kind of container, the end() iterator might be a special value like NULL or a default constructed element. In this case it doesn't change because it doesn't point at anything. Instead of being a pointer-like thing, end() is just a value to compare against.</p>\n<p>I believe that set and map iterators are the second kind, but I don't know of anything that requires them to be implemented in that way.</p>\n", "OwnerUserId": "13422", "PostTypeId": "2", "Id": "1433001", "Score": "0", "CreationDate": "2009-09-16T13:33:37.047", "LastActivityDate": "2009-09-16T13:33:37.047"}, "1432353": {"ParentId": "1432216", "CommentCount": "0", "Body": "<p>Assuming that (1) map implemented with red-black tree (2) you use same instance \"after a zillion insertions/deletions\"- answer \"Yes\".</p>\n<p>Relative implmentation I can tell that all incarnation of stl I ever know use the tree algorithm. </p>\n", "OwnerUserId": "149818", "PostTypeId": "2", "Id": "1432353", "Score": "1", "CreationDate": "2009-09-16T11:15:48.863", "LastActivityDate": "2009-09-16T11:15:48.863"}, "1434278": {"ParentId": "1432216", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>C++ Standard states that iterators should stay valid. And it is. Standard clearly states that in 23.1.2/8:</p>\n<blockquote>\n<p id=\"so_1432216_1434278_0\">The insert members <strong>shall not affect</strong> the validity of <strong>iterators</strong> and references <strong>to the container</strong>, and the erase members shall invalidate only iterators and references to the erased elements.</p>\n</blockquote>\n<p>And in 21.1/7:</p>\n<blockquote>\n<p id=\"so_1432216_1434278_1\">end() returns an <strong>iterator</strong> which is the past-the-end value <strong>for the container</strong>.</p>\n</blockquote>\n<p>So iterators <code>old_end</code> and <code>new_end</code> will be valid. That means that we could get <code>--old_end</code> (call it <code>it1</code>) and <code>--new_end</code> (call it <code>it2</code>) and it will be the-end value iterators (from definition of what <code>end()</code> returns), since <em>iterator of an associative container is of the <strong>bidirectional iterator</strong> category</em> (according to 23.1.2/6) and according to definition of <code>--r</code> operation (Table 75).</p>\n<p>Now <code>it1</code> should be equal <code>it2</code> since it gives the-end value, which is only one (23.1.2/9). Then from 24.1.3 follows that: <em>The condition that <strong>a == b implies ++a == ++b</strong></em></p>. And <code>++it1</code> and <code>++it2</code> will give <code>old_end</code> and <code>new_end</code> iterators (from definition of ++r operation Table 74). Now we get that <code>old_end</code> and <code>new_end</code> should be <strong>equal</strong>.\n", "OwnerUserId": "123111", "LastEditorUserId": "123111", "LastEditDate": "2009-09-16T17:16:14.410", "Id": "1434278", "Score": "0", "CreationDate": "2009-09-16T17:09:45.360", "LastActivityDate": "2009-09-16T17:16:14.410"}, "1432355": {"ParentId": "1432216", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>Well, there's nothing preventing particular collection implementation from having <code>end()</code> depend on the instance of collection and time of day, as long as comparisons and such work. Which means, that, perhaps, <em><code>end()</code> value may change, but <code>old_end == end()</code> comparison should still yield true</em>. <strong>(edit: although after reading the comment from j_random_hacker, I doubt this paragraph itself evaluates to <em>true</em> ;-), not universally \u2014 see the discussion below )</strong></p>\n<p>I also doubt you can use <code>std::map&lt;int,Node&gt;::iterator</code> in the <code>Node</code> class due to the type being incomplete, yet (not sure, though).</p>\n<p>Also, since your nodes are uniquely numbered, you can use <code>int</code> for keying them and reserve some value for invalid.</p>\n", "OwnerUserId": "95382", "LastEditorUserId": "95382", "LastEditDate": "2009-09-16T11:41:44.057", "Id": "1432355", "Score": "3", "CreationDate": "2009-09-16T11:16:03.420", "LastActivityDate": "2009-09-16T11:41:44.057"}});