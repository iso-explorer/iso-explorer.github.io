post_cb({"11438550": {"ParentId": "11438341", "PostTypeId": "2", "CommentCount": "7", "Body": "<h2>Is there any hack I could use?</h2>\n<p>If your only goal is to not having to <em>\"explicitly\"</em> specify the type twice you could use <code>decltype</code> to provide some aid in your quest:</p>\n<pre><code>class Obj {\n  std::vector&lt;int&gt; v1 = decltype(v1) (2,3);\n};\n</code></pre>\n<p>Also remember that <code>typedef</code>/<code>using</code> is a great way of not having to type<sup>1</sup> so much:</p>\n<pre><code>struct Obj {\n   using VInt = std::vector&lt;int&gt;;\n// typedef std::vector&lt;int&gt; VInt;\n\n   VInt v = VInt (3,2);\n};\n</code></pre>\n<p><sup>1.</sup> <sub>pun not intended</sub></p>\n<hr>\n<h2>What does the standard say about it?</h2>\n<p>Sadly the standard says the following about initializing members within the body of your class:</p>\n<blockquote>\n<h3>9.2/5 Class members    [class.mem]</h3>\n<p id=\"so_11438341_11438550_0\">A member can be initialized using a <em>brace-or-equal-initializer</em>. (For\n  static data members, see 9.4.2; for non-static data members, see\n  12.6.2).</p>\n</blockquote>\n<p>We've already found a little hint about what is and what is not okay to do when initializing members, but to be 100% sure we should continue reading up on what a <em>brace-or-equal-initializer</em> really is.</p>\n<pre>\n<h3>8.5/1 Initializers [dcl.init]</h3><sub>...</sub>\n\n<em>brace-or-equal-initializer</em>:\n      = <em>initializer-clause</em>\n      <em>braced-init-list</em>\n\n<em>initializer-clause</em>:\n      <em>assignment-expression</em>\n      <em>braced-init-list</em>\n\n<em>initializer-list</em>:\n      <em>initializer-clause</em> <sub>...opt</sub>\n      <em>initializer-list</em> , <em>initializer-clause</em> <em><sub>...opt</sub></em>\n\n<em>braced-init-list</em>:\n      { <em>initializer-list</em> <em><sub>,opt</sub></em> }\n      { }\n</pre>\n<p>With the above specification of <em>braced-or-equal-initializer</em> we found that we are faced with two options when initializing members within the body of our class, using either a <code>=</code> together with an <em>initializer-clause</em>, or a <code>braced-init-list</code> on it's own.</p>\n<p>The above boils down to either of these two:</p>\n<pre><code>struct Obj {\n  Type foo = Type (1,2,3); /* example of an initializer-clause */\n  Type bar        {1,2,3}; /* example of a  braced-init-list   */\n};\n</code></pre>\n<hr>\n<h2><em>braced-init-list</em> looks awesome, let's use it!</h2>\n<p>Since <code>std::vector&lt;...&gt;</code> accepts a <code>std::initializer_list</code> in one overload of it's constructors we <strong>cannot</strong> use a <em>braced-init-list</em> to invoke the constructor taking two arguments <code>(size_type count, const T&amp; value)</code>, because that will instead be used as the contents of our <em>vector</em>.</p>\n<p>We are therefore stuck with using a <em>initializer-clause</em>.</p>\n<p><sup>See the previous <em>hack</em> for a confirming, but maybe not so obvious, solution.</sup></p>\n</hr></hr>", "OwnerUserId": "1090079", "LastEditorUserId": "1090079", "LastEditDate": "2012-07-12T02:41:09.030", "Id": "11438550", "Score": "6", "CreationDate": "2012-07-11T17:54:02.947", "LastActivityDate": "2012-07-12T02:41:09.030"}, "11438514": {"ParentId": "11438341", "PostTypeId": "2", "CommentCount": "10", "Body": "<h2>The dreamy solution..</h2>\n<p>If you just don't want to repeat <code>std::vector</code>, how about</p>\n<pre><code>class A\n{\n    auto y = std::vector&lt;int&gt;(2,3);\n};\n</code></pre>\n<hr>\n<p>This <strong>is not allowed</strong>, the Standard says (7.1.6.4) <code>[dcl.spec.auto]</code>:</p>\n<blockquote>\n<p id=\"so_11438341_11438514_0\"><strong>The <code>auto</code> type-specifier can also be used</strong> in declaring a variable in the condition of a selection statement or an iteration statement , in the <em>type-specifier-seq</em> in the <em>new-type-id</em> or <em>type-id</em> of a new-expression, in a <em>for-range-declaration</em>, and <strong>in declaring a static data member with a <em>brace-or-equal-initializer</em> that appears within the <em>member-specification</em> of a class de\ufb01nition</strong>.</p>\n</blockquote>\n<p>Probably they forgot to update this line when <em>brace-or-equal-initializer</em> syntax was added to non-static members.</p>\n</hr>", "OwnerUserId": "103167", "LastEditorUserId": "1090079", "LastEditDate": "2012-07-11T18:04:01.787", "Id": "11438514", "Score": "-2", "CreationDate": "2012-07-11T17:51:49.500", "LastActivityDate": "2012-07-11T18:04:01.787"}, "bq_ids": {"n4140": {"so_11438341_11438514_0": {"section_id": 5449, "quality": 0.6296296296296297, "length": 17}, "so_11438341_11438550_0": {"section_id": 5864, "quality": 0.5625, "length": 9}}, "n3337": {"so_11438341_11438514_0": {"section_id": 5243, "quality": 0.6666666666666666, "length": 18}, "so_11438341_11438550_0": {"section_id": 5635, "quality": 0.8125, "length": 13}}, "n4659": {"so_11438341_11438550_0": {"section_id": 7347, "quality": 0.5625, "length": 9}}}, "11438341": {"CommentCount": "4", "ViewCount": "1183", "PostTypeId": "1", "LastEditorUserId": "1090079", "CreationDate": "2012-07-11T17:40:47.603", "LastActivityDate": "2012-07-12T07:24:43.027", "Title": "Non-static Data Member Initializers / Calling constructors of std::vector", "AcceptedAnswerId": "11438550", "LastEditDate": "2012-07-12T07:24:43.027", "Id": "11438341", "Score": "4", "Body": "<p>Code:</p>\n<pre><code>class A {\n  std::vector&lt;int&gt; x = {2,3};                 // x[0] = 2 and x[1] = 3\n  std::vector&lt;int&gt; y = std::vector&lt;int&gt;(2,3); // x[0] = 3 and x[1] = 3 Too verbose!!  \n};\n</code></pre>\n<p>Is there a way that I can call the constructor of <code>std::vector&lt;int&gt;</code> only using brace initializer, or at least shorter version which gives the same effect?</p>\n<p>I don't want to repeat <code>std::vector&lt;int&gt;</code>. </p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1120977", "AnswerCount": "2"}});