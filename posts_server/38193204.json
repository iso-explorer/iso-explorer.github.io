post_cb({"38193204": {"CommentCount": "4", "ViewCount": "98", "PostTypeId": "1", "ClosedDate": "2016-07-04T23:50:26.760", "LastEditorUserId": "-1", "LastActivityDate": "2016-07-05T11:12:26.470", "Body": "<p>As known: <a href=\"https://stackoverflow.com/a/32694707/1558037\">https://stackoverflow.com/a/32694707/1558037</a></p>\n<p>Page 1104: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf</a></p>\n<p>C++11 \u00a729.5/1 says</p>\n<blockquote>\n<p id=\"so_38193204_38193204_0\">There is a generic class template atomic. The type of the template\n  argument T shall be trivially copyable (3.9).</p>\n</blockquote>\n<p>\u00a73.9 tells</p>\n<blockquote>\n<p id=\"so_38193204_38193204_1\">Scalar types, trivially copyable class types (Clause 9), arrays of\n  such types, and cv-qualified versions of these types (3.9.3) are\n  collectively called trivially copyable types.</p>\n</blockquote>\n<p>Full text:</p>\n<pre><code>1 There is a generic class template atomic&lt;T&gt;. The type of the template argument T shall be trivially copyable (3.9). [ Note: Type arguments that are not also statically initializable may be difficult to use.\n\u2014 end note ]\n2 The semantics of the operations on specializations of atomic are defined in 29.6. \n3 Specializations and instantiations of the atomic template shall have a deleted copy constructor, a deleted copy assignment operator, and a constexpr value constructor.\n4 There shall be full specializations of the atomic template for the integral types char, signed char, unsigned char, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned long long, char16_t, char32_t, wchar_t, and any other types needed by the typedefs in the header &lt;cstdint&gt;. For each integral type integral, the specialization atomic&lt;integral&gt; provides additional atomic operations appropriate to integral types. There shall be a specialization atomic&lt;bool&gt; which provides the general atomic operations as specified in 29.6.1.\n5 The atomic integral specializations and the specialization atomic&lt;bool&gt; shall have standard layout. They shall each have a trivial default constructor and a trivial destructor. They shall each support aggregate initialization syntax.\n6 There shall be pointer partial specializations of the atomic class template. These specializations shall have standard layout, trivial default constructors, and trivial destructors. They shall each support aggregate initialization syntax.\n7 There shall be named types corresponding to the integral specializations of atomic, as specified in Table 145, and a named type atomic_bool corresponding to the specified atomic&lt;bool&gt;. Each named type is a either typedef to the corresponding specialization or a base class of the corresponding specialization. If it is a base class, it shall support the same member functions as the corresponding specialization.\n8 There shall be atomic typedefs corresponding to the typedefs in the header &lt;inttypes.h&gt; as specified in Table 146.\n9 [ Note: The representation of an atomic specialization need not have the same size as its corresponding argument type. Specializations should have the same size whenever possible, as this reduces the effort required to port existing code. \u2014 end note ]\n</code></pre>\n<p>Also this code shows that <code>std::array&lt;int, 100&gt;</code> is_trivially_copyable: <a href=\"http://coliru.stacked-crooked.com/a/712a445302406f68\" rel=\"nofollow noreferrer\">http://coliru.stacked-crooked.com/a/712a445302406f68</a></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n#include &lt;array&gt;\n#include &lt;atomic&gt;\n\nint main() {\n\n    std::array&lt;int, 100&gt; myarray;   // 100 elements\n    std::cout &lt;&lt; \"myarray - trivially_copyable: \" &lt;&lt; std::boolalpha &lt;&lt;\n        std::is_trivially_copyable&lt;decltype(myarray)&gt;::value &lt;&lt; std::endl;\n\n    int c_array[100];\n    std::cout &lt;&lt; \"c_array - trivially_copyable: \" &lt;&lt; std::boolalpha &lt;&lt;\n        std::is_trivially_copyable&lt;decltype(c_array)&gt;::value &lt;&lt; std::endl;\n\n    std::atomic&lt;std::array&lt;int, 100&gt;&gt; array_atomic;\n        std::cout &lt;&lt; \"sizeof(array_atomic): \" &lt;&lt; std::boolalpha &lt;&lt;\n        sizeof(decltype(array_atomic)) &lt;&lt; std::endl;\n\n    //array_atomic.store(myarray);    // error\n\n    //std::atomic&lt;c_array[100]&gt; c_array_atomic; // error\n    //std::atomic&lt;decltype(c_array)&gt; c_array_atomic;    // error\n\n\n    return 0;\n}\n</code></pre>\n<p>With result:</p>\n<pre><code>g++ -std=c++14 -O2 -Wall -pedantic -pthread main.cpp &amp;&amp; ./a.out\nmyarray - trivially_copyable: true\nc_array - trivially_copyable: true\nsizeof(array_atomic): 400\n</code></pre>\n<p>But if I try to use <code>array_atomic.store(myarray);</code> then I get an error:</p>\n<pre><code>/tmp/ccgTvl0G.o: In function `main': main.cpp:(.text.startup+0xec):\nundefined reference to `__atomic_store' collect2: error: ld returned 1\nexit status\n</code></pre>\n<p>What also do we need for usage custom C++-type (class) as template of <code>std::atomic&lt;&gt;</code>?</p>\n<p><strong>ANSWER:</strong></p>\n<p>There should be new compilers and sometimes you need to link the library <code>-latomic</code></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n#include &lt;atomic&gt;\n\nint main() {\n    std::array&lt;int, 100&gt; myarray;                   // 100 elements\n    std::atomic&lt;std::array&lt;int, 100&gt;&gt; array_atomic;\n    array_atomic.store(myarray);                    // atomic copy 100 elements\n    return 0;\n}\n</code></pre>\n<p>It can be compiled and linked:</p>\n<ul>\n<li>ARM gcc 4.8.2 and higher <code>-std=c++11 -O3</code>: <a href=\"https://godbolt.org/g/tLRGD6\" rel=\"nofollow noreferrer\">https://godbolt.org/g/tLRGD6</a></li>\n<li>ARM64 gcc 4.8 and higher <code>-std=c++11 -O3</code>: <a href=\"https://godbolt.org/g/QFrZPZ\" rel=\"nofollow noreferrer\">https://godbolt.org/g/QFrZPZ</a></li>\n<li>PowerPC gcc 4.8 and higher <code>-std=c++11 -O3</code>: <a href=\"https://godbolt.org/g/9XP013\" rel=\"nofollow noreferrer\">https://godbolt.org/g/9XP013</a></li>\n<li>x86 clang 3.3 and higher <code>-std=c++11 -O3 -latomic</code>: <a href=\"https://godbolt.org/g/BdJsnb\" rel=\"nofollow noreferrer\">https://godbolt.org/g/BdJsnb</a></li>\n<li>x86 gcc 4.9.0 and higher <code>-std=c++11 -O3 -latomic</code>: <a href=\"https://godbolt.org/g/wifvCm\" rel=\"nofollow noreferrer\">https://godbolt.org/g/wifvCm</a></li>\n<li>x86 icc 13.0.1 and higher <code>-std=c++11 -O3</code>: <a href=\"https://godbolt.org/g/UIURSW\" rel=\"nofollow noreferrer\">https://godbolt.org/g/UIURSW</a></li>\n</ul>\n", "LastEditDate": "2017-05-23T12:16:16.623", "FavoriteCount": "1", "Title": "Can we use std::atomic<std::array<>>?", "Id": "38193204", "Score": "5", "CreationDate": "2016-07-04T23:07:06.973", "Tags": "<c++><c++11><concurrency><c++14><atomic>", "OwnerUserId": "1558037", "AnswerCount": "0"}, "bq_ids": {"n4140": {"so_38193204_38193204_1": {"section_id": 7207, "quality": 0.8421052631578947, "length": 16}, "so_38193204_38193204_0": {"section_id": 1165, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_38193204_38193204_1": {"section_id": 6951, "quality": 0.8947368421052632, "length": 17}, "so_38193204_38193204_0": {"section_id": 1163, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_38193204_38193204_1": {"section_id": 8716, "quality": 0.8947368421052632, "length": 17}, "so_38193204_38193204_0": {"section_id": 57, "quality": 0.5454545454545454, "length": 6}}}});