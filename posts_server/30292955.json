post_cb({"30468318": {"Id": "30468318", "PostTypeId": "2", "Body": "<p>Like Barry said before about:</p>\n<pre><code>ABC&lt;int,bool,char&gt;::DEF&lt;4,true,'c'&gt; foo\n</code></pre>\n<p>And make a try and worked on Coliru online compiler gcc 5.1 c++14 in this site <a href=\"http://coliru.stacked-crooked.com/\" rel=\"nofollow\">Compiler</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n template &lt;template &lt;int,bool,char&gt; class&gt;\nstruct Bar {};\ntemplate &lt;int,bool,char&gt; struct Zod {};\n\nBar&lt;Zod&gt; a;\n\nstruct GHI {\n  template &lt;int,bool,char&gt;\n  struct JKL {};\n};\n\nBar &lt;GHI::JKL&gt; b;\n\ntemplate &lt;template &lt;typename... Ts&gt; class&gt;\nstruct Base {};\ntemplate&lt;typename... Ts&gt;\nstruct Floor {};\nBase&lt;Floor&gt; c;\n\ntemplate &lt;typename... Ts&gt;\nstruct ABC {\n  template &lt;Ts... val&gt;\n  struct DEF {};\n};\nABC&lt;int,bool,char&gt;::DEF&lt;4,true,'c'&gt; foo;\n</code></pre>\n<p>I made a search and found this Template parameter list.</p>\n<p>Pack expansion may appear in a template parameter list: </p>\n<pre><code> template&lt;typename... T&gt; struct value_holder\n{\n    template&lt;T... Values&gt; // expands to a non-type template parameter \n    struct apply { };     // list, such as &lt;int, char, int(&amp;)[5]&gt;\n};\n</code></pre>\n<p>where i tested some stuff in the run code compiler at:\n<a href=\"http://en.cppreference.com/w/cpp/language/parameter_pack\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/parameter_pack</a>\nbut also i found this Ellipses and Variadic Templates in visual studio 2013:\n<a href=\"https://msdn.microsoft.com/en-us/library/dn439779.aspx\" rel=\"nofollow\">https://msdn.microsoft.com/en-us/library/dn439779.aspx</a></p>\n", "LastEditorUserId": "4597705", "LastActivityDate": "2015-05-27T17:09:47.023", "Score": "3", "CreationDate": "2015-05-26T20:30:34.517", "ParentId": "30292955", "CommentCount": "0", "OwnerUserId": "4597705", "LastEditDate": "2015-05-27T17:09:47.023"}, "bq_ids": {"n4140": {"so_30292955_30469081_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 68}, "so_30292955_30469081_1": {"length": 76, "quality": 0.9743589743589743, "section_id": 94}}, "n3337": {"so_30292955_30469081_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 63}, "so_30292955_30469081_1": {"length": 53, "quality": 0.6794871794871795, "section_id": 89}}, "n4659": {"so_30292955_30469081_0": {"length": 24, "quality": 0.9230769230769231, "section_id": 70}, "so_30292955_30469081_1": {"length": 69, "quality": 0.8846153846153846, "section_id": 97}}}, "30292955": {"ViewCount": "975", "Body": "<p>If I define a <code>struct</code> template <code>Bar</code> which accepts a template argument:</p>\n<pre><code>template &lt;template &lt;int,bool,char&gt; class&gt;\nstruct Bar {};\n</code></pre>\n<p>I can instantiate it using a <code>struct</code> template such as <code>Zod</code>:</p>\n<pre><code>template &lt;int,bool,char&gt; struct Zod {};\nBar&lt;Zod&gt; a;\n</code></pre>\n<p>I can also instantiate it using a nested <code>struct</code> template such as <code>JKL</code>:</p>\n<pre><code>struct GHI {\n  template &lt;int,bool,char&gt;\n  struct JKL {};\n};\nBar &lt;GHI::JKL&gt; b;\n</code></pre>\n<p>Why can't I instantiate <code>Bar</code> using a nested variadic <code>struct</code> template such as <code>DEF</code>?:</p>\n<pre><code>template &lt;typename ...Ts&gt;\nstruct ABC {\n  template &lt;Ts ...&gt;\n  struct DEF {};\n};\n\nBar&lt;ABC&lt;int,bool,char&gt;::DEF&gt; c;\n</code></pre>\n<p>G++ 4.9.2 complains of a type/value mismatch; while Clang 3.4.2's error reports that the template template argument has different template parameters than its corresponding template template parameter.</p>\n", "AcceptedAnswerId": "30469081", "Title": "Why is this nested variadic template an invalid argument?", "CreationDate": "2015-05-17T22:52:16.983", "Id": "30292955", "CommentCount": "22", "FavoriteCount": "11", "PostTypeId": "1", "LastEditDate": "2015-05-20T10:54:27.470", "LastEditorUserId": "2023370", "LastActivityDate": "2015-05-27T17:09:47.023", "Score": "43", "OwnerUserId": "2023370", "Tags": "<c++><templates><c++11><variadic-templates>", "AnswerCount": "2"}, "30469081": {"Id": "30469081", "PostTypeId": "2", "Body": "<p>Let's give DEF's parameter pack a name for ease of reference:</p>\n<pre><code>template &lt;typename ...Ts&gt;\nstruct ABC {\n  template &lt;Ts ... Values&gt;\n  struct DEF {};\n};\n</code></pre>\n<p>The key point here is that by [temp.param]/p15, <code>Ts... Values</code> is <em>both</em> a pack expansion of <code>Ts</code> and a declaration of a parameter pack <code>Values</code>.</p>\n<blockquote>\n<p id=\"so_30292955_30469081_0\">If a <em>template-parameter</em> is [...] a <em>parameter-declaration</em> that\n  declares a parameter pack (8.3.5), then the <em>template-parameter</em> is a\n  template parameter pack (14.5.3). A template parameter pack that is a\n  <em>parameter-declaration</em> whose type contains one or more unexpanded parameter packs is a pack expansion.</p>\n</blockquote>\n<p>Since <code>DEF</code> takes a non-type parameter pack, it doesn't match a template template parameter that doesn't take packs ([temp.arg.template]/p3):</p>\n<blockquote>\n<p id=\"so_30292955_30469081_1\">A <em>template-argument</em> matches a template <em>template-parameter</em> P when\n  each of the template parameters in the\n  <em>template-parameter-list</em> of the <em>template-argument</em>\u2019s corresponding class template or alias template A matches the corresponding template\n  parameter in the template-parameter-list of P. Two template parameters\n  match if they are of the same kind (type, non-type, template), for\n  non-type <em>template-parameter</em>s, their types are equivalent (14.5.6.1),\n  and for template <em>template-parameter</em>s, each of their corresponding\n  <em>template-parameter</em>s matches, recursively. When P\u2019s <em>template-parameter-list</em> contains a template parameter pack (14.5.3), the template parameter pack will match zero or more template\n  parameters or template parameter packs in the\n  <em>template-parameter-list</em> of A with the same type and form as the template parameter pack in P (ignoring whether those template\n  parameters are template parameter packs).</p>\n</blockquote>\n<p>To be sure, <code>Values</code> is rather weird for packs - for every specialization of <code>ABC</code>, <code>Values</code> must contain a fixed number of arguments - but under the current rules it's still a pack, so the rules for packs apply.</p>\n", "LastActivityDate": "2015-05-26T21:18:05.093", "CommentCount": "3", "CreationDate": "2015-05-26T21:18:05.093", "ParentId": "30292955", "Score": "5", "OwnerUserId": "2756719"}});