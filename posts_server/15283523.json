post_cb({"15284276": {"ParentId": "15283523", "PostTypeId": "2", "CommentCount": "2", "Body": "<h2><code>reinterpret_cast</code> of references</h2>\n<p>The standard states that an lvalue of type <code>T1</code> can be <code>reinterpret_cast</code> to a reference to <code>T2</code> if a pointer to <code>T1</code> can be <code>reinterpret_cast</code> to a pointer to <code>T2</code> (\u00a75.2.10/11):</p>\n<blockquote>\n<p id=\"so_15283523_15284276_0\">An lvalue expression of type <code>T1</code> can be cast to the type \u201creference to <code>T2</code>\u201d if an expression of type \u201cpointer to <code>T1</code>\u201d can be explicitly converted to the type \u201cpointer to <code>T2</code>\u201d using a reinterpret_cast.</p>\n</blockquote>\n<p>So we need to determine if a <code>int(*)[N]</code> can be converted to an <code>int(*)[I][J][K]</code>.</p>\n<h2><code>reinterpret_cast</code> of pointers</h2>\n<p>A pointer to <code>T1</code> can be <code>reinterpret_cast</code> to a pointer to <code>T2</code> if both <code>T1</code> and <code>T2</code> are standard-layout types and <code>T2</code> has no stricter alignment requirements than <code>T1</code> (\u00a75.2.10/7):</p>\n<blockquote>\n<p id=\"so_15283523_15284276_1\">When a prvalue v of type \u201cpointer to T1\u201d is converted to the type \u201cpointer to cv T2\u201d, the result is <code>static_cast&lt;cv T2*&gt;(static_cast&lt;cv void*&gt;(v))</code> if both <code>T1</code> and <code>T2</code> are standard-layout types (3.9) and the alignment requirements of <code>T2</code> are no stricter than those of <code>T1</code>, or if either type is void.</p>\n</blockquote>\n<ol>\n<li><p>Are <code>int[N]</code> and <code>int[I][J][K]</code> standard-layout types?</p>\n<p><code>int</code> is a scalar type and arrays of scalar types are considered to be <em>standard-layout types</em> (\u00a73.9/9). </p>\n<blockquote>\n<p id=\"so_15283523_15284276_2\">Scalar types, standard-layout class types (Clause 9), arrays of such types and cv-qualified versions of these types (3.9.3) are collectively called <em>standard-layout types</em>.</p>\n</blockquote></li>\n<li><p>Does <code>int[I][J][K]</code> have no stricter alignment requirements than <code>int[N]</code>.</p>\n<p>The result of the <code>alignof</code> operator gives the alignment requirement of a complete object type (\u00a73.11/2).</p>\n<blockquote>\n<p id=\"so_15283523_15284276_3\">The result of the <code>alignof</code> operator reflects the alignment requirement of the type in the complete-object case.</p>\n</blockquote>\n<p>Since the two arrays here are not subobjects of any other object, they are complete objects. Applying <code>alignof</code> to an array gives the alignment requirement of the element type (\u00a75.3.6/3):</p>\n<blockquote>\n<p id=\"so_15283523_15284276_4\">When <code>alignof</code> is applied to an array type, the result shall be the alignment of the element type.</p>\n</blockquote>\n<p>So both array types have the same alignment requirement.</p></li>\n</ol>\n<p>That makes the <code>reinterpret_cast</code> valid and equivalent to:</p>\n<pre><code>int (&amp;arr3d)[I][J][K] = *reinterpret_cast&lt;int (*)[I][J][K]&gt;(&amp;arr1d);\n</code></pre>\n<p>where <code>*</code> and <code>&amp;</code> are the built-in operators, which is then equivalent to:</p>\n<pre><code>int (&amp;arr3d)[I][J][K] = *static_cast&lt;int (*)[I][J][K]&gt;(static_cast&lt;void*&gt;(&amp;arr1d));\n</code></pre>\n<h2><code>static_cast</code> through <code>void*</code></h2>\n<p>The <code>static_cast</code> to <code>void*</code> is allowed by the standard conversions (\u00a74.10/2):</p>\n<blockquote>\n<p id=\"so_15283523_15284276_5\">A prvalue of type \u201cpointer to cv <code>T</code>,\u201d where <code>T</code> is an object type, can be converted to a prvalue of type \u201cpointer to cv void\u201d. The result of converting a \u201cpointer to cv <code>T</code>\u201d to a \u201cpointer to cv void\u201d points to the start of the storage location where the object of type <code>T</code> resides, as if the object is a most derived object (1.8) of type <code>T</code> (that is, not a base class subobject).</p>\n</blockquote>\n<p>The <code>static_cast</code> to <code>int(*)[I][J][K]</code> is then allowed (\u00a75.2.9/13):</p>\n<blockquote>\n<p id=\"so_15283523_15284276_6\">A prvalue of type \u201cpointer to cv1 <code>void</code>\u201d can be converted to a prvalue of type \u201cpointer to cv2 <code>T</code>,\u201d where <code>T</code> is an object type and cv2 is the same cv-qualification as, or greater cv-qualification than, cv1.</p>\n</blockquote>\n<p><strong>So the cast is fine!</strong> But are we okay to access objects through the new array reference?</p>\n<h2>Accessing array elements</h2>\n<p>Performing array subscripting on an array like <code>arr3d[E2]</code> is equivalent to <code>*((E1)+(E2))</code> (\u00a75.2.1/1). Let's consider the following array subscripting:</p>\n<pre><code>arr3d[3][2][1]\n</code></pre>\n<p>Firstly, <code>arr3d[3]</code> is equivalent to <code>*((arr3d)+(3))</code>. The lvalue <code>arr3d</code> undergoes array-to-pointer conversion to give a <code>int(*)[2][1]</code>. There is no requirement that the underlying array must be of the correct type to do this conversion. The pointers value is then accessed (which is fine by \u00a73.10) and then the value 3 is added to it. This pointer arithmetic is also fine (\u00a75.7/5):</p>\n<blockquote>\n<p id=\"so_15283523_15284276_7\">If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>This this pointer is dereferenced to give an <code>int[2][1]</code>. This undergoes the same process for the next two subscripts, resulting in the final <code>int</code> lvalue at the appropriate array index. It is an lvalue due to the result of <code>*</code> (\u00a75.3.1/1):</p>\n<blockquote>\n<p id=\"so_15283523_15284276_8\">The unary * operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and the result is an lvalue referring to the object or function to which the expression points.</p>\n</blockquote>\n<p>It is then perfectly fine to access the actual <code>int</code> object through this lvalue because the lvalue is of type <code>int</code> too (\u00a73.10/10):</p>\n<blockquote>\n<p id=\"so_15283523_15284276_9\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:</p>\n<ul>\n<li>the dynamic type of the object</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>So unless I've missed something. I'd say this program is well-defined.</p>\n", "OwnerUserId": "150634", "LastEditorUserId": "150634", "LastEditDate": "2013-03-08T00:04:58.783", "Id": "15284276", "Score": "20", "CreationDate": "2013-03-07T23:58:35.313", "LastActivityDate": "2013-03-08T00:04:58.783"}, "15283523": {"CommentCount": "6", "AcceptedAnswerId": "15284276", "PostTypeId": "1", "LastEditorUserId": "2008149", "CreationDate": "2013-03-07T23:01:37.590", "LastActivityDate": "2013-03-08T00:04:58.783", "LastEditDate": "2013-03-07T23:50:07.620", "ViewCount": "2964", "FavoriteCount": "10", "Title": "Reshaping a 1-d array to a multidimensional array", "Id": "15283523", "Score": "14", "Body": "<p>Taking into consideration the entire C++11 standard, is it possible for any conforming implementation to succeed the first assertion below but fail the latter?</p>\n<pre><code>#include &lt;cassert&gt;\n\nint main(int, char**)\n{  \n    const int I = 5, J = 4, K = 3;\n    const int N = I * J * K;\n\n    int arr1d[N] = {0};\n    int (&amp;arr3d)[I][J][K] = reinterpret_cast&lt;int (&amp;)[I][J][K]&gt;(arr1d);\n    assert(static_cast&lt;void*&gt;(arr1d) ==\n           static_cast&lt;void*&gt;(arr3d)); // is this necessary?\n\n    arr3d[3][2][1] = 1;\n    assert(arr1d[3 * (J * K) + 2 * K + 1] == 1); // UB?\n}\n</code></pre>\n<p>If not, is this technically UB or not, and does that answer change if the first assertion is removed (is <code>reinterpret_cast</code> guaranteed to preserve addresses here?)? Also, what if the reshaping is done in the opposite direction (3d to 1d) or from a 6x35 array to a 10x21 array?</p>\n<p><strong>EDIT:</strong> If the answer is that this is UB because of the <code>reinterpret_cast</code>, is there some other strictly compliant way of reshaping (e.g., via <code>static_cast</code> to/from an intermediate <code>void *</code>)?</p>\n", "Tags": "<c++><c++11><multidimensional-array><language-lawyer>", "OwnerUserId": "2008149", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_15283523_15284276_0": {"section_id": 6050, "quality": 0.9411764705882353, "length": 16}, "so_15283523_15284276_7": {"section_id": 6142, "quality": 1.0, "length": 21}, "so_15283523_15284276_1": {"section_id": 6046, "quality": 0.6818181818181818, "length": 15}, "so_15283523_15284276_2": {"section_id": 7207, "quality": 0.8823529411764706, "length": 15}, "so_15283523_15284276_8": {"section_id": 6064, "quality": 0.9, "length": 18}, "so_15283523_15284276_4": {"section_id": 6119, "quality": 1.0, "length": 9}, "so_15283523_15284276_6": {"section_id": 6039, "quality": 0.8095238095238095, "length": 17}, "so_15283523_15284276_5": {"section_id": 40, "quality": 0.5294117647058824, "length": 18}, "so_15283523_15284276_9": {"section_id": 7239, "quality": 1.0, "length": 14}, "so_15283523_15284276_3": {"section_id": 7241, "quality": 0.9, "length": 9}}, "n3337": {"so_15283523_15284276_0": {"section_id": 5818, "quality": 1.0, "length": 17}, "so_15283523_15284276_7": {"section_id": 5906, "quality": 1.0, "length": 21}, "so_15283523_15284276_1": {"section_id": 5814, "quality": 0.9090909090909091, "length": 20}, "so_15283523_15284276_2": {"section_id": 6951, "quality": 0.8823529411764706, "length": 15}, "so_15283523_15284276_3": {"section_id": 6985, "quality": 0.9, "length": 9}, "so_15283523_15284276_4": {"section_id": 5883, "quality": 1.0, "length": 9}, "so_15283523_15284276_6": {"section_id": 5807, "quality": 0.8095238095238095, "length": 17}, "so_15283523_15284276_5": {"section_id": 37, "quality": 0.9705882352941176, "length": 33}, "so_15283523_15284276_9": {"section_id": 6983, "quality": 1.0, "length": 14}, "so_15283523_15284276_8": {"section_id": 5832, "quality": 0.9, "length": 18}}, "n4659": {"so_15283523_15284276_0": {"section_id": 7549, "quality": 0.9411764705882353, "length": 16}, "so_15283523_15284276_7": {"section_id": 7638, "quality": 0.5238095238095238, "length": 11}, "so_15283523_15284276_1": {"section_id": 7545, "quality": 0.6363636363636364, "length": 14}, "so_15283523_15284276_6": {"section_id": 7538, "quality": 0.8095238095238095, "length": 17}, "so_15283523_15284276_8": {"section_id": 7560, "quality": 0.9, "length": 18}, "so_15283523_15284276_4": {"section_id": 7616, "quality": 1.0, "length": 9}, "so_15283523_15284276_9": {"section_id": 8748, "quality": 1.0, "length": 14}, "so_15283523_15284276_3": {"section_id": 8750, "quality": 0.9, "length": 9}, "so_15283523_15284276_2": {"section_id": 8716, "quality": 0.8823529411764706, "length": 15}}}, "15283671": {"ParentId": "15283523", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2013-03-07T23:11:36.683", "OwnerUserId": "2135627", "CommunityOwnedDate": "2013-03-07T23:19:57.160", "Id": "15283671", "Score": "1", "Body": "<p>I am under the impression that it will work. You allocate the same piece of contiguous memory. I know the C-standard guarantees it will be contiguous at least. I don't know what is said in the C++11 standard.</p>\n<p>However the first assert should always be true. The address of the first element of the array will always be the same. All memory address will be the same since the same piece of memory is allocated.</p>\n<p>I would therefore also say that the second assert will always hold true. At least as long as the ordering of the elements are always in row major order. This is also guaranteed by the C-standard and I would be surprised if the C++11 standard says anything differently.</p>\n", "LastActivityDate": "2013-03-07T23:11:36.683"}});