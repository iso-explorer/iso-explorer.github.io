post_cb({"17418226": {"ParentId": "17418057", "CommentCount": "0", "Body": "<p>If you declare the function in B like this</p>\n<pre><code>void fun(int ignored=0);\n</code></pre>\n<p>it will become an overload which will not take part in resolving virtual calls. Beware that calling <code>a-&gt;fun()</code> will call <code>A::fun()</code> though even if <code>a</code> actually refers to a <code>B</code>, so <strong>I would strongly advise against this approach</strong> as it makes things even more confusing than necessary.</p>\n<p>Question is: What exactly is it that you want to achieve or avoid? Knowing that, people here could suggest a better approach.</p>\n", "OwnerUserId": "1968182", "PostTypeId": "2", "Id": "17418226", "Score": "0", "CreationDate": "2013-07-02T05:49:05.940", "LastActivityDate": "2013-07-02T05:49:05.940"}, "17418359": {"ParentId": "17418057", "LastEditDate": "2013-07-02T06:29:14.250", "CommentCount": "0", "CreationDate": "2013-07-02T05:58:22.967", "OwnerUserId": "410767", "LastEditorUserId": "410767", "PostTypeId": "2", "Id": "17418359", "Score": "1", "Body": "<p>The following achieves the observable behaviour you're asking for.  In <code>A</code>, non-<code>virtual</code> <code>fun()</code> run virtual <code>fun_()</code> so the behaviour can be customised in <code>B</code>, but anyone calling <code>fun()</code> on a derived class will only see the non-polymorphic version.</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nstruct A{\n    void fun(){fun_();}\n  private:\n    virtual void fun_() { cout &lt;&lt; \"A\\n\"; }\n};\n\nstruct B:public A{\n    void fun(){cout&lt;&lt;\"B\\n\";}\n  private:\n    virtual void fun_() final { fun(); }\n};\n\nstruct C:public B{\n    void fun(){cout&lt;&lt;\"C\\n\";}\n};\n\nint main()\n{\n    C c;B b1;\n    A *a=&amp;b1;\n    a-&gt;fun(); //1\n    B *b=&amp;c;\n    b-&gt;fun(); //2\n    c.fun();    // notice that this outputs \"C\" which I think is what you want\n}\n</code></pre>\n<p>If using C++03, you can simply leave out the \"final\" keyword - it's only there to guard against further unwanted overrides of the virtual behaviour in <code>B</code>-derived classes such as <code>C</code>.</p>\n<p>(You might find it interesting to contrast this with the \"Nonvirtual Interface pattern\" - see C++ Coding Standards by Sutter and Alexandrescu, point 39)</p>\n<p><strong>Discussion</strong></p>\n<p><code>A</code> having <code>fun</code> virtual implies that overriding it in derived classes is a necessary customisation ability for derived classes, but at some point in the derivation hierarchy the choice of implementation behaviours might have narrowed down to 1 and providing a <code>final</code> implementation's not unreasonable.</p>\n<p>My real concern is that you <em>hide</em> <code>A</code>/<code>B</code>'s <code>fun()</code> with <code>C::fun</code>... that's troubling as if they do different things then your code could be very hard to reason about or debug.  <code>B</code>'s decision to finalise the virtual function implies certainty that there's no need for such further customisation.  Code working from <code>A*</code>/<code>A&amp;</code>/<code>B*</code>/<code>B&amp;</code> will do one thing, while wherever a <code>C</code> object's type is statically known, the behaviour may differ.  Templated code is one place where <code>C::fun</code> may easily be called without the template author or user being very conscious of it.  To assess whether this is a genuine hazard for you, it would help to know what the functional purpose of \"fun\" is and how implementation might differ between <code>A</code>, <code>B</code> and <code>C</code>....</p>\n", "LastActivityDate": "2013-07-02T06:29:14.250"}, "17418213": {"ParentId": "17418057", "LastEditDate": "2013-07-02T05:55:02.780", "CommentCount": "0", "CreationDate": "2013-07-02T05:48:10.060", "OwnerUserId": "777186", "LastEditorUserId": "777186", "PostTypeId": "2", "Id": "17418213", "Score": "1", "Body": "<p>A virtual function is virtual in all derived classes. There is no way to prevent this.</p>\n<blockquote>\n<p id=\"so_17418057_17418213_0\">(\u00a710.3/2 C++11) If a virtual member function vf is declared in a class Base and in a class Derived, derived directly or indirectly from Base, a member function vf with the same name, parameter-type-list (8.3.5), cv-qualification, and ref-qualifier (or absence of same) as Base::vf is declared, then Derived::vf is also virtual (whether or not it is so declared) and it overrides Base::vf. For convenience we say that any virtual function overrides itself.</p>\n</blockquote>\n<p>However, if you'd like to use the function that corresponds to the <em>static</em>, rather than the <em>dynamic</em>, type of a pointer (i.e., in your example, <code>B::fun</code> instead of <code>C::fun</code>, given that the pointer is declared as <code>B*</code>), then you can, at least in C++11, use the alias definition below to get access to the static (=compile-time) type:</p>\n<pre><code>template &lt;typename Ptr&gt;\nusing static_type = typename std::remove_pointer&lt;Ptr&gt;::type;\n</code></pre>\n<p>This is how you'd use this in <code>main()</code> (or anywhere else):</p>\n<pre><code>int main() \n{\n  C c; B b1;   \n\n  A *a = &amp;b1;\n  a-&gt;fun();\n\n  B *b = &amp;c;\n\n  /* This will output 'B': */    \n  b-&gt;static_type&lt;decltype(b)&gt;::fun();\n\n  return 0;\n}\n</code></pre>\n", "LastActivityDate": "2013-07-02T05:55:02.780"}, "17418084": {"ParentId": "17418057", "LastEditDate": "2017-05-23T11:50:12.053", "CommentCount": "7", "CreationDate": "2013-07-02T05:37:38.873", "OwnerUserId": "452307", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "17418084", "Score": "1", "Body": "<ul>\n<li>If you do not want your derived classes to override the function then there is no reason why you should mark it <code>virtual</code> in base class. The very basis of marking a function <code>virtual</code> is to have polymorphic behavior through derived class function overidding.           </li>\n</ul>\n<p><strong>Good Read:</strong><br>\n<a href=\"https://stackoverflow.com/questions/8298041/when-to-mark-a-function-in-c-as-a-virtual\">When to mark a function in C++ as a virtual?</a></br></p>\n<ul>\n<li>If you want your code to guard you against accidental overidding in derived classes.You can use the <strong><a href=\"http://en.cppreference.com/w/cpp/language/final\" rel=\"nofollow noreferrer\">final specifier</a></strong> in C++11.</li>\n</ul>\n", "LastActivityDate": "2013-07-02T05:37:38.873"}, "17418057": {"CommentCount": "3", "ViewCount": "670", "LastActivityDate": "2013-07-02T06:29:14.250", "Body": "<pre><code>struct A{\n    virtual void fun(){cout&lt;&lt;\"A\";}\n};\nstruct B:public A{\n    void fun(){cout&lt;&lt;\"B\";}\n};\nstruct C:public B{\n    void fun(){cout&lt;&lt;\"C\";}\n};\nint main() \n{\n    C c;B b1;   \n    A *a=&amp;b1;\n    a-&gt;fun(); //1\n    B *b=&amp;c;\n    b-&gt;fun(); //2\n    return 0;\n}\n</code></pre>\n<p>In the above code B::fun() is getting converted to virtual function implicitly as I have made A::fun() virtual. Can I stop this conversion? </p>\n<p>If not possible what are the alternatives to make the above code print \"BB\" ?</p>\n", "PostTypeId": "1", "AcceptedAnswerId": "17418213", "FavoriteCount": "0", "Title": "How to stop implicit conversion to virtual function", "Id": "17418057", "Score": "1", "CreationDate": "2013-07-02T05:35:06.373", "Tags": "<c++><oop><virtual-functions>", "OwnerUserId": "2020229", "AnswerCount": "5"}, "17418101": {"ParentId": "17418057", "CommentCount": "0", "Body": "<p>Yes, if you want to explicitly call a function in a specific class you can use a fully qualified name.</p>\n<pre><code>b-&gt;A::fun();\n</code></pre>\n<p>This will call the version of <code>fun()</code> belonging to <code>A</code>.</p>\n", "OwnerUserId": "845568", "PostTypeId": "2", "Id": "17418101", "Score": "1", "CreationDate": "2013-07-02T05:38:30.090", "LastActivityDate": "2013-07-02T05:38:30.090"}, "bq_ids": {"n4140": {"so_17418057_17418213_0": {"section_id": 7003, "quality": 0.8780487804878049, "length": 36}}, "n3337": {"so_17418057_17418213_0": {"section_id": 6749, "quality": 0.8780487804878049, "length": 36}}, "n4659": {"so_17418057_17418213_0": {"section_id": 8500, "quality": 0.8780487804878049, "length": 36}}}});