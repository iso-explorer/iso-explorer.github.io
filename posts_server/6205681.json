post_cb({"6205759": {"Id": "6205759", "PostTypeId": "2", "Body": "<p>I don't think the table which you posted proves anything substantial.</p>\n<p>As far as, array of static storage is concerned, its allocated before the start of the program, which by definition means, before the program enters into the <code>main()</code> function, the runtime allocates memory to the global arrays, and it lasts for duration of the program:</p>\n<p>\u00a73.7.1/1</p>\n<blockquote>\n<p id=\"so_6205681_6205759_0\">All objects which neither have dynamic\n  storage duration nor are local have\n  static storage duration. The storage\n  for these objects shall last for the\n  duration of the program (3.6.2,\n  3.6.3).</p>\n</blockquote>\n<p>And whether it is global or local, arrays have always contiguous memory.</p>\n", "LastActivityDate": "2011-06-01T18:10:35.747", "CommentCount": "0", "CreationDate": "2011-06-01T18:10:35.747", "ParentId": "6205681", "Score": "1", "OwnerUserId": "415784"}, "6207150": {"Id": "6207150", "PostTypeId": "2", "Body": "<p>There are two things in play here viz. virtual memory and physical memory.</p>\n<p>The virtual memory for for the static data, just like the instructions for your program are assigned before your program begins execution. By this I mean that the address, for your program is always defined.</p>\n<p>The operating system might be lazy, however when it comes to loading both static data and program instructions into physical memory RAM. The way that this works is like this: </p>\n<ul>\n<li>The process loader assigned process virtual memory for the static data but does not load the data into RAM. </li>\n<li>When one tries to access these addresses, a processor exception is triggered and we then enter kernel mode. </li>\n<li>The kernel now loads the data into RAM and links the RAM into the processes virtual address space. </li>\n<li>The kernel switches back into user mode to the exact point where the processor exception happenned. </li>\n<li>Since the RAM is now linked into the processes virtual address space, the program will now continue executing as if nothing had ever happenned.</li>\n</ul>\n<p>This is a total slight of hand which the operating system is allowed to do simply because it is totally undetectable to the running process. Unless of course we are short of memory.</p>\n", "LastActivityDate": "2011-06-01T20:20:27.377", "CommentCount": "0", "CreationDate": "2011-06-01T20:20:27.377", "ParentId": "6205681", "Score": "2", "OwnerUserId": "232918"}, "bq_ids": {"n4140": {"so_6205681_6205759_0": {"length": 12, "quality": 0.6, "section_id": 7164}}, "n3337": {"so_6205681_6205759_0": {"length": 12, "quality": 0.6, "section_id": 6908}}, "n4659": {"so_6205681_6205759_0": {"length": 12, "quality": 0.6, "section_id": 8672}}}, "6205681": {"ViewCount": "731", "Body": "<p>When defining a global or static array in c++ its memory is not immediately reserved at the start of the programme but only once we write to the array. What I found surprising is, if we only write to a small part of the array it still does not reserve the entire memory. Consider the following small example which writes sparsely to the global array:</p>\n<pre><code>#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n\n#define MAX_SIZE 250000000\ndouble global[MAX_SIZE];\n\nint main(int argc, char** argv) {\n   if(argc&lt;2) {\n      printf(\"usage: %s &lt;step size&gt;\\n\", argv[0]);\n      exit(EXIT_FAILURE);\n   }\n   size_t   step_size=atoi(argv[1]);\n\n   for(size_t i=0; i&lt;MAX_SIZE; i+=step_size) {\n      global[i]=(double) i;\n   }\n\n   printf(\"finished\\n\"); getchar();\n   return EXIT_SUCCESS;\n}\n</code></pre>\n<p>Now executing this for different step sizes and looking at the output of top we get for example:</p>\n<pre><code>./a.out 1000000\n./a.out 100000\n./a.out 10000\n./a.out 1000\n./a.out 100\n\n  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND\n15718 user      20   0 1918m 1868  728 S    0  0.0   0:00.00 a.out\n15748 user      20   0 1918m  10m  728 S    0  0.1   0:00.00 a.out\n15749 user      20   0 1918m  98m  728 S    1  0.8   0:00.04 a.out\n15750 user      20   0 1918m 977m  728 S    0  8.1   0:00.39 a.out\n15751 user      20   0 1918m 1.9g  728 S   23 15.9   0:00.80 a.out\n</code></pre>\n<p>The RES column indicates memory is only reserved in small blocks, which also means the array is unlikely to be contiguous in physical memory. Anyone got more insight on the lower level of things?</p>\n<p>This also has the negative side effect that I can easily run many programmes where the sum of all VIRT exceeds the physical memory as long the sum of RES is below. However, as soon as they all write to the global arrays the system runs out of physical memory and programmes get sent sigkill or something.</p>\n<p>Ideally I'd like to tell the compiler to reserve the memory of global and static variables at the start. Possible?</p>\n<p><strong>Edit</strong></p>\n<p>@Magnus: The lines are actually in the right order. :) Take the first line for example <code>./a.out 1000000</code> means I'm writing every 1 millionth entry in the array and so only 250 in total. This corresponds to a RES of only 1868k. In the last example <code>./a.out 100</code> every one hundreds entry is written and then the total memory is also physically allocated RES=VIRT=1.9g. From the numbers it appears that whenever an entry is written to the array something like a full 4k block is reserved on the physical memory.</p>\n<p>@Nawaz: The array is contiguous in virtual address space but as I understand the OS might be lazy and only reserve physical memory when it's actually needed. Since this is done in little blocks and not the whole array at once how can it be guaranteed to be contiguous in physical memory?</p>\n<p>@Nemo: Thanks for that, indeed when calling multiple instances of <code>a.out</code> which pause at the beginning and then write to the array I got <code>oom-killer</code> messages in <code>/var/log/messages</code>, and indeed your <code>sysctrl</code> command prevents me from starting too many <code>a.out</code> instances in the first place. Thanks!</p>\n<pre><code>Jun  1 17:49:16 localhost kernel: [32590.293421] a.out invoked oom-killer: gfp_mask=0x280da, order=0, oomkilladj=0\nJun  1 17:49:18 localhost kernel: [32592.110033] kded4 invoked oom-killer: gfp_mask=0x201da, order=0, oomkilladj=0\nJun  1 17:49:20 localhost kernel: [32594.718757] firefox invoked oom-killer: gfp_mask=0x201da, order=0, oomkilladj=0\n</code></pre>\n<p>The last two lines slightly worrying. :)</p>\n<p>@doron: Thanks, great explanation, sorry can't upvote/select.</p>\n", "AcceptedAnswerId": "6207150", "Title": "How and when is the memory of a global or static array allocated?", "CreationDate": "2011-06-01T18:04:09.573", "Id": "6205681", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2011-06-02T09:33:55.757", "LastEditorUserId": "-1", "LastActivityDate": "2011-06-02T09:33:55.757", "Score": "4", "OwnerUserId": "1068039", "Tags": "<c++><arrays><static><global><contiguous>", "AnswerCount": "4"}, "6205747": {"Id": "6205747", "PostTypeId": "2", "Body": "<p>You are looking at virtual memory pages being committed. The OS will typically only commit pages when they are expressly written or read by your code.  This has nothing to do with C++, which guarantees that arrays are contiguous. If you are asking how to get your OS to commit all your process's pages at start up, you need to use OS specific stuff (if such exists).</p>\n", "LastEditorUserId": "2100815", "LastActivityDate": "2011-06-01T18:34:06.727", "Score": "6", "CreationDate": "2011-06-01T18:09:32.307", "ParentId": "6205681", "CommentCount": "1", "OwnerUserId": "2100815", "LastEditDate": "2011-06-01T18:34:06.727"}, "6206379": {"Id": "6206379", "PostTypeId": "2", "Body": "<p>This sounds like a Linux system, where the \"OOM killer\" wakes up and starts killing processes once the used memory exceeds the available virtual memory.  Grep for \"oom\" in /var/log/messages to confirm.</p>\n<p>If so, this setting:</p>\n<pre><code>sysctl -w vm.overcommit_memory=2\n</code></pre>\n<p>...will prevent the kernel from allowing your processes to allocate more than the available VM.</p>\n", "LastActivityDate": "2011-06-01T19:07:57.137", "CommentCount": "0", "CreationDate": "2011-06-01T19:07:57.137", "ParentId": "6205681", "Score": "1", "OwnerUserId": "768469"}});