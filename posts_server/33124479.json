post_cb({"33124544": {"ParentId": "33124479", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\">C++11 standard</a>, basic_string 21.4.1.5,</p>\n<blockquote>\n<p id=\"so_33124479_33124544_0\">The char-like objects in a basic_string object shall be stored\n  contiguously. That is, for any basic_string object s, the identity\n  &amp;*(s.begin() + n) == &amp;*s.begin() + n shall hold for all values of n\n  such that 0 &lt;= n &lt; s.size().</p>\n</blockquote>\n", "OwnerUserId": "1501794", "LastEditorUserId": "648265", "LastEditDate": "2015-10-16T17:53:26.973", "Id": "33124544", "Score": "24", "CreationDate": "2015-10-14T11:52:31.863", "LastActivityDate": "2015-10-16T17:53:26.973"}, "33124558": {"ParentId": "33124479", "CommentCount": "0", "Body": "<p>According to the draft standard <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4527.pdf\" rel=\"nofollow\">N4527</a> <em>21.4/3 Class template basic_string [basic.string]</em> :</p>\n<blockquote>\n<p id=\"so_33124479_33124558_0\">A basic_string is a contiguous container (23.2.1).</p>\n</blockquote>\n", "OwnerUserId": "2352671", "PostTypeId": "2", "Id": "33124558", "Score": "2", "CreationDate": "2015-10-14T11:52:59.600", "LastActivityDate": "2015-10-14T11:52:59.600"}, "33124479": {"CommentCount": "11", "ViewCount": "2105", "PostTypeId": "1", "LastEditorUserId": "4342498", "CreationDate": "2015-10-14T11:48:28.837", "LastActivityDate": "2017-05-15T13:11:04.480", "Title": "Does std::string need to store its character in a contiguous piece of memory?", "AcceptedAnswerId": "33124544", "LastEditDate": "2017-05-15T13:11:04.480", "Id": "33124479", "Score": "20", "Body": "<p>I know that in C++98, neither <code>std::basic_string&lt;&gt;</code> nor <code>std::vector&lt;&gt;</code> were required to use contiguous storage. This was seen as an oversight for <code>std::vector&lt;&gt;</code> as soon as it was pointed out, and, if I remember correctly, got fixed with C++03. </p>\n<p>I <em>seem</em> to remember having read about discussions requiring <code>std::basic_string&lt;&gt;</code> to use contiguous storage back when C++11 was still called C++0x, but I haven't followed the discussion closely back then, and am still restricted to C++03 at work, so I am not sure what became of it. </p>\n<p>So is <code>std::basic_string&lt;&gt;</code> required to use contiguous storage? (If so, then which version of the standard required it first?) </p>\n<p><sup>In case you wonder: This is important if you have code passing the result of <code>&amp;str[0]</code> to a function expecting a contiguous piece of memory to write to. (I know about <code>str.data()</code>, but for obvious reasons old code doesn't use it.)</sup></p>\n", "Tags": "<c++><c++11><c++14><language-lawyer><c++1z>", "OwnerUserId": "140719", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_33124479_33124747_4": {"section_id": 1617, "quality": 0.9473684210526315, "length": 18}, "so_33124479_33124747_1": {"section_id": 1558, "quality": 0.6060606060606061, "length": 40}, "so_33124479_33124544_0": {"section_id": 1566, "quality": 0.7777777777777778, "length": 14}}, "n3337": {"so_33124479_33124747_4": {"section_id": 1613, "quality": 0.9473684210526315, "length": 18}, "so_33124479_33124747_1": {"section_id": 1552, "quality": 0.6060606060606061, "length": 40}, "so_33124479_33124544_0": {"section_id": 1561, "quality": 0.7777777777777778, "length": 14}}, "n4659": {"so_33124479_33124747_4": {"section_id": 1770, "quality": 0.9473684210526315, "length": 18}, "so_33124479_33124747_1": {"section_id": 1708, "quality": 0.6060606060606061, "length": 40}}}, "33124747": {"ParentId": "33124479", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>In c++03 there was no guarantee that that the elements of the string are stored continiously.  [basic.string] was</p>\n<blockquote id=\"so_33124479_33124747_0\">\n<ol>\n<li>For a char-like type charT, the class template basic_string describes objects that can store a\n  sequence consisting of a varying number of arbitrary char-like objects (clause 21). The first element of the\n  sequence is at position zero. Such a sequence is also called a \u201cstring\u201d if the given char-like type is clear\n  from context. In the rest of this clause, charT denotes such a given char-like type. Storage for the string\n  is allocated and freed as necessary by the member functions of class basic_string, via the\n  Allocator class passed as template parameter. Allocator::value_type shall be the same as\n  charT.</li>\n<li>The class template basic_string conforms to the requirements of a Sequence, as specified in (23.1.1).\n  Additionally, because the iterators supported by basic_string are random access iterators (24.1.5),\n  basic_string conforms to the the requirements of a Reversible Container, as specified in (23.1).\n  389\n  ISO/IEC 14882:2003(E) \uf6d9 ISO/IEC\n  21.3 Class template basic_string 21 Strings library</li>\n<li>In all cases, size() &lt;= capacity().</li>\n</ol>\n</blockquote>\n<p>And then in C++17 they changed it too</p>\n<blockquote id=\"so_33124479_33124747_1\">\n<ol>\n<li>The class template basic_string describes objects that can store a sequence consisting of a varying number\n  of arbitrary char-like objects with the first element of the sequence at position zero. Such a sequence is also\n  called a \u201cstring\u201d if the type of the char-like objects that it holds is clear from context. In the rest of this\n  Clause, the type of the char-like objects held in a basic_string object is designated by charT.</li>\n<li>The member functions of basic_string use an object of the Allocator class passed as a template parameter\n  to allocate and free storage for the contained char-like objects.233</li>\n<li><strong>A basic_string is a contiguous container (23.2.1).</strong></li>\n<li>In all cases, size() &lt;= capacity().</li>\n</ol>\n</blockquote>\n<p><sup>emphasis mine</sup></p>\n<p>So pre C++17 it was not guaranteed but now it is.</p>\n<p>With the constraints that <code>std::string::data</code> imposes this non guarantee is almost moot as calling <code>std::string::data</code> gives you a continuous array of the characters in the string.  So unless the implementation is doing this on demand and in constant time the string will be continuous.</p>\n<hr>\n<blockquote>\n<p id=\"so_33124479_33124747_2\"><sup>In case you wonder: This is important if you have code passing the result of <code>&amp;str[0]</code> to a function expecting a contiguous piece of memory to write to. (I know about <code>str.data()</code>, but for obvious reasons old code doesn't use it.)</sup></p>\n</blockquote>\n<p>The behavior of <code>operator[]</code> has changed as well.  In C++03 we had</p>\n<blockquote>\n<p id=\"so_33124479_33124747_3\"><strong>Returns:</strong> If pos &lt; size(), returns data()[pos]. Otherwise, if pos == size(), the const\n  version returns charT(). Otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>So only the <code>const</code> version was guaranteed to have defined behavior if you tried <code>&amp;s[0]</code> when <code>s</code> is empty.  In C++11 they changed it to:</p>\n<blockquote>\n<p id=\"so_33124479_33124747_4\"><em>Returns:</em> *(begin() + pos) if pos &lt; size(). Otherwise, returns a reference to an object of type\n  charT with value charT(), where modifying the object leads to undefined behavior.</p>\n</blockquote>\n<p>So now both the <code>const</code> and non <code>const</code> versions have defined behavior if you tried <code>&amp;s[0]</code> when <code>s</code> is empty.</p>\n</hr>", "OwnerUserId": "4342498", "LastEditorUserId": "4342498", "LastEditDate": "2015-12-12T18:22:31.693", "Id": "33124747", "Score": "13", "CreationDate": "2015-10-14T12:02:23.020", "LastActivityDate": "2015-12-12T18:22:31.693"}});