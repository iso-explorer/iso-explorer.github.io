post_cb({"27140916": {"Id": "27140916", "PostTypeId": "2", "Body": "<p>You cannot have free <code>begin()</code> and <code>end()</code> functions as per <a href=\"https://stackoverflow.com/a/27140852/2069064\">T.C.'s answer</a>. However, what you can do, is just make your own class and add member <code>begin</code> and <code>end</code> to it:</p>\n<pre><code>template &lt;typename I&gt;\nstruct iter_pair : std::pair&lt;I, I&gt;\n{ \n    using std::pair&lt;I, I&gt;::pair;\n\n    I begin() { return this-&gt;first; }\n    I end() { return this-&gt;second; }\n};\n</code></pre>\n<p>And just use that instead of a normal <code>pair</code>:</p>\n<pre><code>std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};\n\niter_pair&lt;decltype(v.begin())&gt; pr{v.begin(), v.end()};\n\nfor (int i : pr) {\n    std::cout &lt;&lt; i &lt;&lt; ' ';\n}\nstd::cout &lt;&lt; std::endl;\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-11-26T03:36:38.097", "Score": "1", "CreationDate": "2014-11-26T03:36:38.097", "ParentId": "27140778", "CommentCount": "0", "OwnerUserId": "2069064", "LastEditDate": "2017-05-23T12:17:45.237"}, "27140778": {"ViewCount": "2527", "Body": "<p>I have a question with respect to the following answer: </p>\n<p><a href=\"https://stackoverflow.com/a/15828866/2160256\">https://stackoverflow.com/a/15828866/2160256</a></p>\n<p>As stated there, we cannot use range based for with BGL like this:</p>\n<pre><code>   for(auto e : boost::edges(g))\n       // do something with e\n</code></pre>\n<p>However, <a href=\"http://en.cppreference.com/w/cpp/iterator/begin\" rel=\"nofollow noreferrer\">here</a> it states, that we can overload the begin() and end() functions that are required to use range based for semantics. So I tried:</p>\n<pre><code>   template&lt;class I&gt;\n   I begin(std::pair&lt;I,I&gt;&amp; p)\n   { return p.first;}\n\n   template&lt;class I&gt;\n   I end(std::pair&lt;I,I&gt;&amp; p)\n   { return p.second;}\n</code></pre>\n<p>However, the compiler still complains:</p>\n<blockquote>\n<p id=\"so_27140778_27140778_0\">error: no matching function for call to\n  \u2018<code>begin(std::pair&lt;some_really_ugly_type,some_really_ugly_type&gt;&amp;)</code>\u2019</p>\n</blockquote>\n<p>What am I doing wrong? Does the name lookup not work? Or is this not possible after all?\nI also found <a href=\"https://stackoverflow.com/questions/6167598/why-was-pair-range-access-removed-from-c11\">this answer</a>, which works, but shouldtn't it be possible with the begin/end free function overlods as well?\nRegards, Marti</p>\n<p>BTW: I find it really tiresome to write</p>\n<pre><code>   typename Graph::edge_iterator ebegin, eend;\n   std::tie(ebegin,eend) = boost::edges(_graph);\n   std::for_each(ebegin,eend,[&amp;](const edge_descriptor&amp; e){/*do something with e*/;});\n</code></pre>\n<p>UPDATE: C++17 should now allow the following :-)</p>\n<pre><code>auto [ebegin,eend] = boost::edges(_graph);\n</code></pre>\n", "AcceptedAnswerId": "27140852", "Title": "Range based for with pair<Iterator,Iterator>", "CreationDate": "2014-11-26T03:21:46.190", "Id": "27140778", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-11-08T15:07:05.843", "LastEditorUserId": "2160256", "LastActivityDate": "2017-11-08T15:07:05.843", "Score": "3", "OwnerUserId": "2160256", "Tags": "<c++><for-loop><boost><iterator>", "AnswerCount": "5"}, "27144642": {"Id": "27144642", "PostTypeId": "2", "Body": "<p>Iterator pairs are <strong>not</strong> ranges by design! The idea was specifically rejected from the language and library specification. See e.g.</p>\n<ul>\n<li>paper <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2009/n2995.pdf\" rel=\"nofollow\"><strong>n2995.pdf</strong> Pairs do not make good ranges</a></li>\n</ul>\n<p>If you \"find it tiresome\" to write the <code>tie()</code> workaround, just use</p>\n<pre><code>for (auto&amp; edge : make_iterator_range(boost::edges(_graph)))\n    /*do something with edge*/;\n</code></pre>\n<p>You could alias <code>boost::make_iterator_range</code> something shorter, but my editor\u00b9 suggests <code>make_iterator_range</code> as completion when I type <code>mir</code>. This is plenty speedy for me</p>\n<hr>\n<p>\u00b9 of course, that editor is Vim</p>\n</hr>", "LastEditorUserId": "85371", "LastActivityDate": "2014-11-26T09:14:42.140", "Score": "4", "CreationDate": "2014-11-26T08:44:19.843", "ParentId": "27140778", "CommentCount": "2", "OwnerUserId": "85371", "LastEditDate": "2014-11-26T09:14:42.140"}, "bq_ids": {"n4140": {"so_27140778_27140852_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 3906}, "so_27140778_27140852_1": {"length": 15, "quality": 0.7142857142857143, "section_id": 3906}}, "n3337": {"so_27140778_27140852_0": {"length": 19, "quality": 0.9047619047619048, "section_id": 3766}}, "n4659": {"so_27140778_27140852_0": {"length": 17, "quality": 0.8095238095238095, "section_id": 4792}, "so_27140778_27140852_1": {"length": 15, "quality": 0.7142857142857143, "section_id": 4792}}}, "41175813": {"Id": "41175813", "PostTypeId": "2", "Body": "<p>I would expand on Barry's answer and suggest (until C++17) to add</p>\n<pre><code>template &lt;typename I&gt;\niter_pair&lt;I&gt; make_range(std::pair&lt;I, I&gt; p) {\n    return iter_pair&lt;I&gt;(p);\n}\n</code></pre>\n<p>to be used as</p>\n<pre><code>for (auto e : make_range(boost::edges(g)))\n    // do something with e\n</code></pre>\n", "LastActivityDate": "2016-12-16T01:07:28.283", "CommentCount": "2", "CreationDate": "2016-12-16T01:07:28.283", "ParentId": "27140778", "Score": "0", "OwnerUserId": "2050986"}, "27140892": {"Id": "27140892", "PostTypeId": "2", "Body": "<p>Since the Boost FOREACH macro uses C++03 declarations and explicit template code, it ought to work with conventional lookup rules instead of special <code>for</code> rules.</p>\n<p>You might make sure that it expands the old way even though range-based <code>for</code> is available.</p>\n<p>Another approach would be to make your own class that is derived from the pair, but contains the <code>begin</code> and <code>end</code> members.  Then write</p>\n<pre><code>for (e: mypair(p))\n</code></pre>\n<p>Instead of</p>\n<pre><code>for (e: p)\n</code></pre>\n", "LastEditorUserId": "658087", "LastActivityDate": "2014-11-26T03:39:55.243", "Score": "0", "CreationDate": "2014-11-26T03:34:28.307", "ParentId": "27140778", "CommentCount": "0", "OwnerUserId": "658087", "LastEditDate": "2014-11-26T03:39:55.243"}, "27140852": {"Id": "27140852", "PostTypeId": "2", "Body": "<p>In a range-based <code>for</code> loop, name lookup for non-member <code>begin()</code> and <code>end()</code> uses ADL only. It doesn't perform ordinary unqualified lookup. \u00a76.5.4 [stmt.ranged]/p1.3:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_27140778_27140852_0\">if <code>_RangeT</code> is a class type, the <em>unqualified-id</em>s <code>begin</code> and <code>end</code> are looked up in the scope of class <code>_RangeT</code> as if by class member access\n  lookup (3.4.5), and if either (or both) finds at least one\n  declaration, [...]</p></li>\n<li><p id=\"so_27140778_27140852_1\">otherwise, <em>begin-expr</em> and <em>end-expr</em> are <code>begin(__range)</code> and\n  <code>end(__range)</code>, respectively, where <code>begin</code> and <code>end</code> are looked up in the\n  associated namespaces (3.4.2). [ <em>Note</em>: Ordinary unqualified lookup\n  (3.4.1) is not performed. \u2014<em>end note</em> ]</p></li>\n</ul>\n</blockquote>\n<p>Hence, your <code>begin()</code> and <code>end()</code> overloads are not found.</p>\n", "LastActivityDate": "2014-11-26T03:29:58.683", "CommentCount": "0", "CreationDate": "2014-11-26T03:29:58.683", "ParentId": "27140778", "Score": "4", "OwnerUserId": "2756719"}});