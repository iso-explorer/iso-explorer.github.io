post_cb({"22875353": {"ParentId": "22875320", "CommentCount": "0", "Body": "<p><a href=\"http://en.wikipedia.org/wiki/Dynamic_binding_%28computing%29\" rel=\"nofollow\"><code>dynamic binding</code></a>, the <em>compiler</em> doesn't decide, the runtime does because the destructor is virtual. C++ destruction calls the destructor on the current class and implicitly calls the parent class until it hits the base class.</p>\n", "OwnerUserId": "1783614", "PostTypeId": "2", "Id": "22875353", "Score": "1", "CreationDate": "2014-04-05T01:01:15.640", "LastActivityDate": "2014-04-05T01:01:15.640"}, "22897555": {"ParentId": "22875320", "CommentCount": "0", "Body": "<p>Note: My first answer was so off-base that I deleted it. It was so far off-base that someone should have down voted my response. This is another try.</p>\n<p>In the opening post, master_latch asked:</p>\n<blockquote>\n<p id=\"so_22875320_22897555_0\">How can the compiler know which derived class destructor to invoke from the base destructor?</p>\n</blockquote>\n<p>How this happens is implementation specific.</p>\n<p>Why this has to happen is \"because the standard says so.\" Here's what the standard says:</p>\n<p>C++11 12.4 paragraph 5:  </p>\n<blockquote>\n<p id=\"so_22875320_22897555_1\">After executing the body of the destructor and destroying any automatic objects allocated within the body, a destructor for class X calls the destructors for X\u2019s direct non-variant members, the destructors for X\u2019s direct base classes and, if X is the type of the most derived class, its destructor calls the destructors for X\u2019s virtual base classes. All destructors are called as if they were referenced with a qualified name, that is, ignoring any possible virtual overriding destructors in more derived classes. Bases and members are destroyed in the reverse order of the completion of their constructor. A return statement in a destructor might not directly return to the caller; before transferring control to the caller, the destructors for the members and bases are called. Destructors for elements of an array are called in reverse order of their construction.</p>\n</blockquote>\n<p>C++11 12.4 paragraph 10:  </p>\n<blockquote>\n<p id=\"so_22875320_22897555_2\">In an explicit destructor call, the destructor name appears as a ~ followed by a <em>type-name</em> or <em>decltype-specifier</em> that denotes the destructor\u2019s class type. The invocation of a destructor is subject to the usual rules for member functions, ...</p>\n</blockquote>\n<p>The example code in C++11 12.4 paragraph 10 indicates the intent of the above:</p>\n<pre><code>struct B {\n  virtual ~B() { }\n};\nstruct D : B {\n  ~D() { }\n};\n\nD D_object;\nB* B_ptr = &amp;D_object;\n\nvoid f() {\n  D_object.B::~B();   // calls B\u2019s destructor\n  B_ptr-&gt;~B();        // calls D\u2019s destructor\n  ...\n}\n</code></pre>\n<p><br/></p>\n<hr>\n<p>master_latch, your example of using <code>b-&gt;~Base();</code> is identical to the second call in the example code. Think of <code>b-&gt;~Base();</code> as if it meant <code>b-&gt;__destruct_me()</code>. It is in a sense no different than a call to any other virtual function.</p>\n<p>A compliant implementation has to do this because \"because the standard says so.\" How an implementation does it? The standard doesn't say. (That's good requirementese, by the way. Say what has to be done, but don't say how to do it.)</p>\n<p>Most implementations (every implementation I have poked into) do this by generating multiple functions for a destructor. One function implements the body of the destructor as specified by the programmer. A wrapper destructor executes this body of the destructor function, then destroys non-static data members in reverse order of construction, and then invokes parent class destructors. That classes can virtually inherit from some parent class adds another twist. This means that a third destructor function for a given class might be needed.</p>\n<p>So how does an implementation know that <code>b-&gt;~Base()</code> should call the wrapper destructor for <code>class Derived</code>? Dynamically casting a pointer to a polymorphic class to a void* pointer yields a pointer to the most derived object.</p>\n<p>C++11 5.2.7 paragraph 7:  </p>\n<blockquote>\n<p id=\"so_22875320_22897555_3\">If <code>T</code> is \u201cpointer to <em>cv</em> <code>void</code>,\u201d then the result is a pointer to the most derived object pointed to by <code>v</code>. Otherwise, a run-time check is applied to see if the object pointed or referred to by <code>v</code> can be converted to the type pointed or referred to by <code>T</code>.</p>\n</blockquote>\n<p>In other words, dynamically casting a polymorphic pointer to <code>void*</code> yields a pointer to the object as it was declared or allocated. The virtual table (not a part of the standard) dictates how to find the destructor. The implementation ensures that the pointer to the virtual table can be determined from a <code>void*</code> pointer to the most derived object. This is what lets the implementation know which destructor to call. From that point on, the pointer to that most derived object is no longer a <code>void*</code> pointer.</p>\n</hr>", "OwnerUserId": "774499", "PostTypeId": "2", "Id": "22897555", "Score": "0", "CreationDate": "2014-04-06T17:39:01.873", "LastActivityDate": "2014-04-06T17:39:01.873"}, "22875426": {"ParentId": "22875320", "CommentCount": "1", "Body": "<p>The call to virtual destructor works the same as a call to any other virtual function, as a result of virtual dispatch via virtual table. Apart from this,</p>\n<pre><code>b-&gt;~Base(); // delete b; \"has the same result\"\n</code></pre>\n<p>this is not true, because <code>delete</code> also frees the memory, which you haven't done here. <code>delete b</code> calls a destructor for <code>*b</code> and deallocates raw memory to operating system. You have only destroyed the building but haven't given ground back.</p>\n", "OwnerUserId": "1141471", "PostTypeId": "2", "Id": "22875426", "Score": "1", "CreationDate": "2014-04-05T01:12:22.467", "LastActivityDate": "2014-04-05T01:12:22.467"}, "22875320": {"CommentCount": "2", "ViewCount": "179", "CreationDate": "2014-04-05T00:57:40.057", "LastActivityDate": "2014-04-06T17:39:01.873", "Title": "How does the base destructor invoke the derived destructor?", "PostTypeId": "1", "Id": "22875320", "Score": "0", "Body": "<p>In the code below, b is a base-class pointer. However, when I invoke the destructor (either explicitly or implicitly via delete), the derived class destructor is invoked first. I don't understand how this works. There could be any number of derived classes, each with their own destructors. How can the compiler know which derived class destructor to invoke from the base destructor?</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nclass Base {\npublic:\n    virtual ~Base() { cout &lt;&lt; \"Base destructor\" &lt;&lt; endl; }\n};\n\nclass Derived : public Base {\npublic:\n    ~Derived() { cout &lt;&lt; \"Derived destructor\" &lt;&lt; endl; }\n};\n\nint main(int argc, char * argv[]) {\n\n    Base * b = new Derived();\n    b-&gt;~Base(); // delete b; has the same result\n}\n</code></pre>\n", "Tags": "<c++><oop><destructor>", "OwnerUserId": "3047531", "AnswerCount": "5"}, "22875516": {"ParentId": "22875320", "CommentCount": "0", "Body": "<p>This is done the same way as virtual functions. Its called dynamic binding. When non virtual member functions are resolved statically means at compile-time, virtual members are resolved dynamically means during run time. Compiler maintains a vtable for this.  If the object has one or more virtual functions, the compiler puts a hidden pointer in the object called a \"virtual-pointer\" or \"v-pointer.\" This v-pointer points to a global table called the \"virtual-table\" or \"v-table.\". Read more in details from <a href=\"http://www.parashift.com/c++-faq/dyn-binding.html\" rel=\"nofollow\">here</a>.</p>\n", "OwnerUserId": "395131", "PostTypeId": "2", "Id": "22875516", "Score": "1", "CreationDate": "2014-04-05T01:28:43.217", "LastActivityDate": "2014-04-05T01:28:43.217"}, "22875954": {"ParentId": "22875320", "CommentCount": "0", "Body": "<p>It doesn't. It happens the other way around. Normal virtual function despatching calls the derived destructor, and the derived destructor calls the base destructor.</p>\n", "OwnerUserId": "207421", "PostTypeId": "2", "Id": "22875954", "Score": "1", "CreationDate": "2014-04-05T02:43:34.943", "LastActivityDate": "2014-04-05T02:43:34.943"}, "bq_ids": {"n4140": {"so_22875320_22897555_1": {"section_id": 404, "quality": 1.0, "length": 79}, "so_22875320_22897555_3": {"section_id": 6017, "quality": 1.0, "length": 22}, "so_22875320_22897555_2": {"section_id": 409, "quality": 0.9523809523809523, "length": 20}}, "n3337": {"so_22875320_22897555_1": {"section_id": 395, "quality": 1.0, "length": 79}, "so_22875320_22897555_3": {"section_id": 5785, "quality": 1.0, "length": 22}, "so_22875320_22897555_2": {"section_id": 400, "quality": 0.9523809523809523, "length": 20}}, "n4659": {"so_22875320_22897555_1": {"section_id": 422, "quality": 1.0, "length": 79}, "so_22875320_22897555_3": {"section_id": 7516, "quality": 1.0, "length": 22}, "so_22875320_22897555_2": {"section_id": 427, "quality": 0.8571428571428571, "length": 18}}}});