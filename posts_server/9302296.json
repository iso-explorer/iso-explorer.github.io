post_cb({"9302360": {"ParentId": "9302296", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>You have to compare these two versions:</p>\n<pre><code>std::shared_ptr&lt;Object&gt; p1 = std::make_shared&lt;Object&gt;(\"foo\");\nstd::shared_ptr&lt;Object&gt; p2(new Object(\"foo\"));\n</code></pre>\n<p>In your code, the second variable is just a naked pointer, not a shared pointer at all.</p>\n<hr>\n<p>Now on the meat. <code>make_shared</code> <strong>is</strong> (in practice) more efficient, because it allocates the reference control block together with the actual object in one single dynamic allocation. By contrast, the constructor for <code>shared_ptr</code> that takes a naked object pointer must allocate <em>another</em> dynamic variable for the reference count. The trade-off is that <code>make_shared</code> (or its cousin <code>allocate_shared</code>) does not allow you to specify a custom deleter, since the allocation is performed by the allocator.</p>\n<p>(This does not affect the construction of the object itself. From <code>Object</code>'s perspective there is no difference between the two versions. What's more efficient is the shared pointer itself, not the managed object.)</p>\n</hr>", "OwnerUserId": "596781", "LastEditorUserId": "596781", "LastEditDate": "2012-02-15T22:31:25.120", "Id": "9302360", "Score": "30", "CreationDate": "2012-02-15T22:17:22.900", "LastActivityDate": "2012-02-15T22:31:25.120"}, "9302461": {"ParentId": "9302296", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>So one thing to keep in mind is your optimization settings. Measuring performance, particularly with regard to c++ is <strong>meaningless</strong> without optimizations enabled. I don't know if you did in fact compile with optimizations, so I thought it was worth mentioning.</p>\n<p>That said, what you are measuring with this test is <strong>not</strong> a way that <code>make_shared</code> is more efficient. Simply put, you are measuring the wrong thing :-P.</p>\n<p>Here's the deal. Normally, when you create  shared pointer, it has at least 2 data members (possibly more). One for the pointer, and one for the reference count. This reference count is allocated on the heap (so that it can be shared among <code>shared_ptr</code> with different lifetimes...that's the point after all!)</p>\n<p>So if you are creating an object with something like <code>std::shared_ptr&lt;Object&gt; p2(new Object(\"foo\"));</code> There are at least <strong>2</strong> calls to <code>new</code>. One for <code>Object</code> and one for the reference count object.</p>\n<p><code>make_shared</code> has the option (i'm not sure it has to), to do a single <code>new</code> which is big enough to hold the object pointed to and the reference count in the same contiguous block. Effectively allocating an object that looks something like this (illustrative, not literally what it is).</p>\n<pre><code>struct T {\n    int reference_count;\n    Object object;\n};\n</code></pre>\n<p>Since the reference count and the object's lifetimes are tied together (it doesn't make sense for one to live longer than the other). This whole block can be <code>delete</code>d at the same time as well.</p>\n<p>So the efficiency is in allocations, not in copying (which I suspect had to do with optimization more than anything else).</p>\n<p>To be clear, this is what boost has to say on about <code>make_shared</code></p>\n<p><a href=\"http://www.boost.org/doc/libs/1_43_0/libs/smart_ptr/make_shared.html\" rel=\"nofollow\">http://www.boost.org/doc/libs/1_43_0/libs/smart_ptr/make_shared.html</a></p>\n<blockquote>\n<p id=\"so_9302296_9302461_0\">Besides convenience and style, such a function is also exception safe\n  and considerably faster because it can use a single allocation for\n  both the object and its corresponding control block, eliminating a\n  significant portion of shared_ptr's construction overhead. This\n  eliminates one of the major efficiency complaints about shared_ptr.</p>\n</blockquote>\n", "OwnerUserId": "13430", "LastEditorUserId": "13430", "LastEditDate": "2015-02-04T22:29:39.720", "Id": "9302461", "Score": "6", "CreationDate": "2012-02-15T22:25:11.960", "LastActivityDate": "2015-02-04T22:29:39.720"}, "9303504": {"ParentId": "9302296", "PostTypeId": "2", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_9302296_9303504_0\">As infrastructure I was using llvm/clang 3.0 along with the llvm std c++ library within XCode4.</p>\n</blockquote>\n<p>Well that appears to be your problem. The C++11 standard states the following requirements for <code>make_shared&lt;T&gt;</code> (and <code>allocate_shared&lt;T&gt;</code>), in section 20.7.2.2.6:</p>\n<blockquote>\n<p id=\"so_9302296_9303504_1\">Requires: The expression ::new (pv) T(std::forward(args)...), where pv has type void* and points to storage suitable to hold an object of type T, shall be well formed. A shall be an allocator (17.6.3.5). The copy constructor and destructor of A shall not throw exceptions.</p>\n</blockquote>\n<p><code>T</code> is <em>not</em> required to be copy-constructable. Indeed, <code>T</code> isn't even required to be non-placement-new constructable. It is only required to be constructable in-place. This means that the only thing that <code>make_shared&lt;T&gt;</code> can do with <code>T</code> is <code>new</code> it in-place.</p>\n<p>So the results you get are not consistent with the standard. LLVM's libc++ is broken in this regard. File a bug report.</p>\n<p>For reference, here's what happened when I took your code into VC2010:</p>\n<pre><code>Create smart_ptr using make_shared...\nConstructor make_shared\nCreate smart_ptr using make_shared: done.\nCreate smart_ptr using new...\nConstructor new\nCreate smart_ptr using new: done.\nDestructor\nDestructor\n</code></pre>\n<p>I also ported it to Boost's original <code>shared_ptr</code> and <code>make_shared</code>, and I got the same thing as VC2010.</p>\n<p>I'd suggest filing a bug report, as libc++'s behavior is broken.</p>\n", "OwnerUserId": "734069", "LastEditorUserId": "734069", "LastEditDate": "2012-02-16T16:55:01.937", "Id": "9303504", "Score": "34", "CreationDate": "2012-02-15T23:54:04.990", "LastActivityDate": "2012-02-16T16:55:01.937"}, "9302460": {"ParentId": "9302296", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>You should not be getting any extra copies there. The output should be:</p>\n<pre><code>Create smart_ptr using make_shared...\nConstructor make_shared\nCreate smart_ptr using make_shared: done.\nCreate smart_ptr using new...\nConstructor new\nCreate smart_ptr using new: done.\nDestructor\n</code></pre>\n<p>I don't know why you're getting extra copies. (though I see you're getting one 'Destructor' too many, so the code you used to get your output must be different from the code you posted)</p>\n<p><code>make_shared</code> is more efficient because it can be implemented using only one dynamic allocation instead of two, and because it needs one pointer's worth of memory less book-keeping per shared object.</p>\n<p>Edit: I didn't check with Xcode 4.2 but with Xcode 4.3 I get the correct output I show above, not the incorrect output shown in the question.</p>\n", "OwnerUserId": "365496", "LastEditorUserId": "365496", "LastEditDate": "2012-02-17T05:47:05.270", "Id": "9302460", "Score": "3", "CreationDate": "2012-02-15T22:25:08.967", "LastActivityDate": "2012-02-17T05:47:05.270"}, "9302296": {"CommentCount": "11", "AcceptedAnswerId": "9303504", "PostTypeId": "1", "LastEditorUserId": "1863564", "CreationDate": "2012-02-15T22:12:34.457", "LastActivityDate": "2017-10-27T17:32:32.733", "LastEditDate": "2017-10-27T17:32:32.733", "ViewCount": "34738", "FavoriteCount": "14", "Title": "Is make_shared really more efficient than new?", "Id": "9302296", "Score": "44", "Body": "<p>I was experimenting with <code>shared_ptr</code> and <code>make_shared</code> from C++11 and programmed a little toy example to see what is actually happening when calling <code>make_shared</code>. As infrastructure I was using llvm/clang 3.0 along with the llvm std c++ library within XCode4.</p>\n<pre><code>class Object\n{\npublic:\n    Object(const string&amp; str)\n    {\n        cout &lt;&lt; \"Constructor \" &lt;&lt; str &lt;&lt; endl;\n    }\n\n    Object()\n    {\n        cout &lt;&lt; \"Default constructor\" &lt;&lt; endl;\n\n    }\n\n    ~Object()\n    {\n        cout &lt;&lt; \"Destructor\" &lt;&lt; endl;\n    }\n\n    Object(const Object&amp; rhs)\n    {\n        cout &lt;&lt; \"Copy constructor...\" &lt;&lt; endl;\n    }\n};\n\nvoid make_shared_example()\n{\n    cout &lt;&lt; \"Create smart_ptr using make_shared...\" &lt;&lt; endl;\n    auto ptr_res1 = make_shared&lt;Object&gt;(\"make_shared\");\n    cout &lt;&lt; \"Create smart_ptr using make_shared: done.\" &lt;&lt; endl;\n\n    cout &lt;&lt; \"Create smart_ptr using new...\" &lt;&lt; endl;\n    shared_ptr&lt;Object&gt; ptr_res2(new Object(\"new\"));\n    cout &lt;&lt; \"Create smart_ptr using new: done.\" &lt;&lt; endl;\n}\n</code></pre>\n<p>Now have a look at the output, please:</p>\n<blockquote>\n<p id=\"so_9302296_9302296_0\">Create smart_ptr using make_shared...</p>\n<p id=\"so_9302296_9302296_1\">Constructor make_shared</p>\n<p id=\"so_9302296_9302296_2\">Copy constructor...</p>\n<p id=\"so_9302296_9302296_3\">Copy constructor...</p>\n<p id=\"so_9302296_9302296_4\">Destructor</p>\n<p id=\"so_9302296_9302296_5\">Destructor</p>\n<p id=\"so_9302296_9302296_6\">Create smart_ptr using make_shared: done.</p>\n<p id=\"so_9302296_9302296_7\">Create smart_ptr using new... </p>\n<p id=\"so_9302296_9302296_8\">Constructor new</p>\n<p id=\"so_9302296_9302296_9\">Create smart_ptr using new: done.</p>\n<p id=\"so_9302296_9302296_10\">Destructor</p>\n<p id=\"so_9302296_9302296_11\">Destructor</p>\n</blockquote>\n<p>It appears that <code>make_shared</code> is calling the copy constructor two times. If I allocate memory for an <code>Object</code> using a regular <code>new</code> this does not happen, only one <code>Object</code> is constructed.</p>\n<p>What I am wondering about is the following. I heard that <code>make_shared</code> is supposed to be more efficient than using <code>new</code><sup>(<a href=\"http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared\" rel=\"nofollow noreferrer\">1</a>, <a href=\"http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/STL11-Magic-Secrets\" rel=\"nofollow noreferrer\" title=\"around minute 10\">2</a>)</sup>. One reason is because <code>make_shared</code> allocates the reference count together with the object to be managed in the same block of memory. OK, I got the point. This is of course more efficient than two separate allocation operations.</p>\n<p>On the contrary I don't understand why this has to come with the cost of two calls to the copy constructor of <code>Object</code>. Because of this I am not convinced that <code>make_shared</code> is more efficient than allocation using <code>new</code> in <em>every</em> case. Am I wrong here? Well OK, One could implement a move constructor for <code>Object</code> but still I am not sure whether this this is more efficient than just allocating <code>Object</code> through <code>new</code>. At least not in every case. It would be true if copying <code>Object</code> is less expensive than allocating memory for a reference counter. But the <code>shared_ptr</code>-internal reference counter could be implemented using a couple of primitive data types, right?</p>\n<p>Can you help and explain why <code>make_shared</code> is the way to go in terms of efficiency, despite the outlined copy overhead? </p>\n", "Tags": "<c++><shared-ptr><clang><libc++><make-shared>", "OwnerUserId": "1212354", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_9302296_9303504_1": {"section_id": 4438, "quality": 0.75, "length": 18}}, "n3337": {"so_9302296_9303504_1": {"section_id": 4275, "quality": 0.75, "length": 18}}, "n4659": {"so_9302296_9303504_1": {"section_id": 5703, "quality": 0.7916666666666666, "length": 19}}}});