post_cb({"46875695": {"Id": "46875695", "PostTypeId": "2", "Body": "<p>given that you asked about a <em>POD type</em> ( hence including unions ) it's worth mentioning that according to [class.copy]</p>\n<blockquote>\n<p id=\"so_46875027_46875695_0\">The implicitly-defined copy/move constructor for a union X copies the <strong>object representation</strong> (6.9) of X</p>\n</blockquote>\n<p>that for trivially copyable types should include padding bits as well.\nSo, it could be just a matter of replacing A with</p>\n<pre><code>union A{ struct {\n    char a;\n    int b;\n}; };\n</code></pre>\n<p>(actually, the above uses a non standard anonymous struct, but you get the point ... )</p>\n", "LastActivityDate": "2017-10-22T15:16:14.073", "CommentCount": "1", "CreationDate": "2017-10-22T15:16:14.073", "ParentId": "46875027", "Score": "7", "OwnerUserId": "8631381"}, "46875225": {"Id": "46875225", "PostTypeId": "2", "Body": "<p>It's not authoritative, but <code>cppreference</code>'s entry for <a href=\"http://en.cppreference.com/w/cpp/string/byte/memcmp\" rel=\"noreferrer\"><code>std::memcmp</code></a> suggests that the padding bytes may differ:</p>\n<blockquote>\n<p id=\"so_46875027_46875225_0\"><code>memcmp()</code> between two objects of type <code>struct{char c; int n;}</code> will compare the padding bytes whose values may differ when the values of <code>c</code> and <code>n</code> are the same</p>\n</blockquote>\n", "LastActivityDate": "2017-10-22T14:29:04.020", "CommentCount": "1", "CreationDate": "2017-10-22T14:29:04.020", "ParentId": "46875027", "Score": "9", "OwnerUserId": "2797826"}, "46875027": {"ViewCount": "1827", "Body": "<p>Suppose I have a POD type like this:</p>\n<pre><code>struct A {\n    char a;\n    int b;\n};\n</code></pre>\n<p>On my system, <code>sizeof(A) == 8</code>, even though <code>sizeof(char) == 1</code> and <code>sizeof(b) == 4</code>.  This means that the data structure has 3 unused bytes.</p>\n<p>Now suppose we do</p>\n<pre><code>A x = ...;\nA y =x;\n</code></pre>\n<p><strong>Question:</strong></p>\n<p>Is it guaranteed that all 8 bytes of <code>x</code> and <code>y</code> will be identical, even those 3 unused ones?</p>\n<p>Equivalently, if I transfer the underlying bytes of some <code>A</code> objects to another program that does not understand their meaning or structure, and treats them as an array of 8 bytes, can that other program safely compare two <code>A</code>s for equality?</p>\n<p>Note: <a href=\"http://coliru.stacked-crooked.com/a/364008a86ee4ec3d\" rel=\"noreferrer\">In an experiment with gcc 7</a>, it appears that those bytes do get copied. I would like to know if this is guaranteed.</p>\n", "AcceptedAnswerId": "46875219", "Title": "Do the padding bytes of a POD type get copied?", "CreationDate": "2017-10-22T14:10:27.220", "Id": "46875027", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-10-22T14:17:38.887", "LastEditorUserId": "695132", "LastActivityDate": "2017-10-22T15:16:14.073", "Score": "45", "OwnerUserId": "695132", "Tags": "<c++><copy-constructor>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_46875027_46875695_0": {"length": 7, "quality": 0.875, "section_id": 465}, "so_46875027_46875219_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 464}}, "n3337": {"so_46875027_46875695_0": {"length": 7, "quality": 0.875, "section_id": 456}, "so_46875027_46875219_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 455}}, "n4659": {"so_46875027_46875695_0": {"length": 7, "quality": 0.875, "section_id": 488}, "so_46875027_46875219_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 487}}}, "46875399": {"Id": "46875399", "PostTypeId": "2", "Body": "<p>Answering your second question:</p>\n<blockquote>\n<p id=\"so_46875027_46875399_0\">Equivalently, if I transfer the underlying bytes of some A objects to another program that does not understand their meaning or structure, and treats them as an array of 8 bytes, can that other program safely compare two As for equality?</p>\n</blockquote>\n<p>As an object of your type may contain padding bytes, another program generally can not compare two such objects for equality: </p>\n<p>Knowing which <i>bits</i> of the bytes that make out the object semantically is the key for defining its <i>value representation</i>. However, in this scenario, the target program only knows the <i>object representation</i>, i.e. the sequence of <i>bytes</i> representing such an object in memory, including padding bytes. A function like memcmp can only compare such objects whose value representation is identical to its object representation in a meaningful way. If you use it to compare objects value-wise even though they have padding, it may fail to give the right results as it cannot tell which bits in the object representation are irrelevant for the value representations of two objects to be equal.</p>\n<p>See <a href=\"http://en.cppreference.com/w/cpp/language/object\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/object</a></p>\n", "LastActivityDate": "2017-10-22T14:45:47.763", "CommentCount": "0", "CreationDate": "2017-10-22T14:45:47.763", "ParentId": "46875027", "Score": "4", "OwnerUserId": "7703564"}, "46875219": {"Id": "46875219", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_46875027_46875219_0\">The implicitly-defined copy/move constructor for a non-union class X performs a memberwise copy/move\n  of its bases and members.</p>\n</blockquote>\n<p>12.8/15 [class.copy] in N4141</p>\n<p>The bit pattern in the padding bytes is thus allowed to differ.</p>\n", "LastActivityDate": "2017-10-22T14:28:31.593", "CommentCount": "3", "CreationDate": "2017-10-22T14:28:31.593", "ParentId": "46875027", "Score": "40", "OwnerUserId": "3002139"}});