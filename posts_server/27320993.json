post_cb({"bq_ids": {"n4140": {"so_27320993_27321150_1": {"length": 32, "quality": 0.9411764705882353, "section_id": 149}, "so_27320993_27321150_0": {"length": 20, "quality": 1.0, "section_id": 149}}, "n3337": {"so_27320993_27321150_1": {"length": 32, "quality": 0.9411764705882353, "section_id": 143}, "so_27320993_27321150_0": {"length": 20, "quality": 1.0, "section_id": 143}}, "n4659": {"so_27320993_27321150_1": {"length": 32, "quality": 0.9411764705882353, "section_id": 153}, "so_27320993_27321150_0": {"length": 20, "quality": 1.0, "section_id": 153}}}, "27321150": {"Id": "27321150", "PostTypeId": "2", "Body": "<p>Every primary and partial specializations static data members must be defined separately.</p>\n<pre><code>template &lt;int N, int I&gt;\nconst int Table&lt;N, I&gt;::dummy = \u2026;\n</code></pre>\n<p>The only thing defined here is <code>Table&lt;N, I&gt;::dummy</code> - the primary specializations static data member. [temp.class.spec.mfunc]/1<sup>1</sup>:</p>\n<blockquote>\n<p id=\"so_27320993_27321150_0\">Class template partial specialization members that are used in a way\n  that requires a definition shall be defined; <strong>the definitions of\n  members of the primary template are never used as definitions for\n  members of a class template partial specialization.</strong></p>\n</blockquote>\n<p>This also implies that GCC is wrong here. That's a bug.<br>\nEitherway, adding</br></p>\n<pre><code>template &lt;int N&gt;\nconst int Table&lt;N, 0&gt;::dummy = 0;\n</code></pre>\n<p>Should compile fine.</p>\n<p><hr>\n<sup>1)</sup>\nIn particular, in the same section as the quote above:</hr></p>\n<blockquote>\n<p id=\"so_27320993_27321150_1\">The template parameter list of a member of a class template partial\n  specialization shall match the template parameter list of the class\n  template partial specialization.<br>\n  The template argument list of a\n  member of a class template partial specialization shall match the\n  template argument list of the class template partial specialization.</br></p>\n</blockquote>\n<p>That means that the argument lists used for defining the partial specialization and its member <strong>must be the same</strong>. Otherwise that member is never defined.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2014-12-05T17:20:26.970", "Score": "6", "CreationDate": "2014-12-05T17:09:16.047", "ParentId": "27320993", "CommentCount": "3", "OwnerUserId": "3647361", "LastEditDate": "2014-12-05T17:20:26.970"}, "27320993": {"ViewCount": "177", "Body": "<p>I wrote some code once upon a time that generated a static table/array at compile time for some template metaprogramming (the idea is that C-style strings can be built at compile time (they're just <code>char</code> arrays)). The idea and the code is based off <a href=\"https://stackoverflow.com/users/63757/david-lin\">David Lin</a>'s <a href=\"https://stackoverflow.com/a/3499919/1287251\">answer</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n\nconst int ARRAY_SIZE = 5;\n\ntemplate &lt;int N, int I=N-1&gt;\nclass Table : public Table&lt;N, I-1&gt;\n{\npublic:\n    static const int dummy;\n};\n\ntemplate &lt;int N&gt;\nclass Table&lt;N, 0&gt;\n{\npublic:\n    static const int dummy;\n    static int array[N];\n};\n\ntemplate &lt;int N, int I&gt;\nconst int Table&lt;N, I&gt;::dummy = Table&lt;N, 0&gt;::array[I] = I*I + 0*Table&lt;N, I-1&gt;::dummy;\n\ntemplate &lt;int N&gt;\nint Table&lt;N, 0&gt;::array[N];\n\ntemplate class Table&lt;ARRAY_SIZE&gt;;\n\nint main(int, char**)\n{\n    const int *compilerFilledArray = Table&lt;ARRAY_SIZE&gt;::array;\n    for (int i=0; i &lt; ARRAY_SIZE; ++i)\n        std::cout&lt;&lt;compilerFilledArray[i]&lt;&lt;std::endl;\n}\n</code></pre>\n<p>Compiling this code with GCC 4.9.2 works:</p>\n<pre><code>$ g++-4.9 -Wall -pedantic b.cpp\n$ ./a.out\n0\n1\n4\n9\n16\n</code></pre>\n<p>Clang 3.5 complains, though:</p>\n<pre><code>$ clang++ -Wall -pedantic b.cpp\nUndefined symbols for architecture x86_64:\n  \"Table&lt;5, 0&gt;::dummy\", referenced from:\n      ___cxx_global_var_init in b-b8a447.o\nld: symbol(s) not found for architecture x86_64\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n</code></pre>\n<p><code>dummy</code> and <code>array</code> are both given definitions outside of the <code>Table</code> class (where they're declared). As far as I can tell, this should satisfy the linker requirements.</p>\n<p>Is this a bug with clang?</p>\n", "AcceptedAnswerId": "27321150", "Title": "Static table generation works with GCC but not clang; is clang bugged?", "CreationDate": "2014-12-05T17:00:25.530", "Id": "27320993", "CommentCount": "0", "LastEditDate": "2017-05-23T10:29:21.167", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2016-03-18T10:56:19.380", "Score": "5", "OwnerUserId": "1287251", "Tags": "<c++><templates><language-lawyer><static-members><partial-specialization>", "AnswerCount": "1"}});