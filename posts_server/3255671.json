post_cb({"3255671": {"CommentCount": "0", "AcceptedAnswerId": "3255686", "PostTypeId": "1", "ClosedDate": "2010-07-15T14:38:23.877", "LastEditorUserId": "-1", "CreationDate": "2010-07-15T12:55:24.623", "LastActivityDate": "2010-07-15T15:16:58.213", "LastEditDate": "2017-05-23T12:26:41.650", "ViewCount": "333", "FavoriteCount": "1", "Title": "How can I make an object construct itself at a particular location in memory?", "Id": "3255671", "Score": "3", "Body": "<blockquote>\n<p id=\"so_3255671_3255671_0\"><strong>Possible Duplicate:</strong><br>\n<a href=\"https://stackoverflow.com/questions/1554774/create-new-c-object-at-specific-memory-address\">Create new C++ object at specific memory address?</a> </br></p>\n</blockquote>\n<p>I am writing what is essentially an object pool allocator, which will allocate a single class. I am allocating just enough memory to fit the objects that I need, and I am passing out pointers to spaces inside. </p>\n<p>Now my question is this: Once I have gotten a pointer within my pool, how do I construct an object there? </p>\n", "Tags": "<c++><stl><allocator>", "OwnerUserId": "265629", "AnswerCount": "4"}, "3255686": {"ParentId": "3255671", "CommentCount": "2", "Body": "<p>You use placement new.  Like so:</p>\n<pre><code>new( pointer ) MyClass();\n</code></pre>\n", "OwnerUserId": "114421", "PostTypeId": "2", "Id": "3255686", "Score": "10", "CreationDate": "2010-07-15T12:57:44.447", "LastActivityDate": "2010-07-15T12:57:44.447"}, "3255696": {"ParentId": "3255671", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Use <a href=\"http://www.parashift.com/c++-faq-lite/dtors.html#faq-11.10\" rel=\"nofollow noreferrer\">placement new</a></p>\n<pre><code>char memory[sizeof(Myclass)];    \nvoid* place = memory;          \n\nMyclass* f = new(place) Myclass();   \n</code></pre>\n<p><em>Remember</em> </p>\n<blockquote>\n<p id=\"so_3255671_3255696_0\">You are also solely responsible for destructing the placed object. This is done by <strong>explicitly</strong> calling the destructor:</p>\n</blockquote>\n<pre><code> f-&gt;~Myclass();\n</code></pre>\n<p><strong>EDIT</strong> </p>\n<p>After reading Martin York's comment and relevant section of the Standard, it is quite certain that you should not use the above method(using objects placed on the stack with placement new). Use <code>std::vector</code> instead with <code>placement new</code>as Martin has suggested.</p>\n", "OwnerUserId": "165520", "LastEditorUserId": "165520", "LastEditDate": "2010-07-15T15:16:58.213", "Id": "3255696", "Score": "0", "CreationDate": "2010-07-15T12:59:08.393", "LastActivityDate": "2010-07-15T15:16:58.213"}, "3255694": {"ParentId": "3255671", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Placement new might help.</p>\n<p><a href=\"https://stackoverflow.com/questions/222557/cs-placement-new\">What uses are there for \"placement new\"?</a></p>\n", "OwnerUserId": "9236", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:32:43.397", "Id": "3255694", "Score": "2", "CreationDate": "2010-07-15T12:58:34.380", "LastActivityDate": "2010-07-15T12:58:34.380"}, "3256565": {"ParentId": "3255671", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Use placement new.</p>\n<pre><code>std::vector&lt;char&gt; memory(sizeof(Myclass));    \nvoid*             place = &amp;memory[0];          \n\nMyclass* f = new(place) Myclass();\n</code></pre>\n<p>Don't use the method defined by the FAQ:</p>\n<pre><code>char     memory[sizeof(Myclass)];  // No alignment guarantees on this.\n</code></pre>\n<p>As noted in the FAQ it is dangerous as the standard provides no grantees about the alignment of this memory. Using a standard vector does give you guarantees about the alignment because the data section of vector is dynamically allocated and the standard does provide guarantees about the alignment of dynamically allocated memory.</p>\n<p>From: n2521 (the copy I have on my desktop) Section: 3.7.3.1</p>\n<blockquote>\n<p id=\"so_3255671_3256565_0\">The pointer returned shall be suitably aligned so that it can be converted to a pointer of any complete object type with a fundamental alignment requirement (3.11) and then used to access the object or array in the storage allocated (until the storage is explicitly deallocated by a call to a corresponding deallocation function).</p>\n</blockquote>\n<p>Which points us at 3.11</p>\n<blockquote>\n<p id=\"so_3255671_3256565_1\">3.11 Alignment    [basic.align]<br>\n  5 Alignments have an order from weaker to stronger or stricter alignments. Stricter alignments have larger alignment values. An address that satisfies an alignment requirement also satisfies any weaker valid alignment requirement.</br></p>\n</blockquote>\n<p>Don't forget to manually call the destructor:</p>\n<pre><code>f-&gt;~Myclass()\n</code></pre>\n", "OwnerUserId": "14065", "LastEditorUserId": "14065", "LastEditDate": "2010-07-15T14:47:56.800", "Id": "3256565", "Score": "4", "CreationDate": "2010-07-15T14:32:35.857", "LastActivityDate": "2010-07-15T14:47:56.800"}, "bq_ids": {"n4140": {"so_3255671_3256565_0": {"section_id": 7177, "quality": 0.9310344827586207, "length": 27}, "so_3255671_3256565_1": {"section_id": 7244, "quality": 0.7692307692307693, "length": 20}}, "n3337": {"so_3255671_3256565_0": {"section_id": 6921, "quality": 0.9310344827586207, "length": 27}, "so_3255671_3256565_1": {"section_id": 6988, "quality": 0.7692307692307693, "length": 20}}, "n4659": {"so_3255671_3256565_0": {"section_id": 8685, "quality": 0.8275862068965517, "length": 24}, "so_3255671_3256565_1": {"section_id": 8753, "quality": 0.7692307692307693, "length": 20}}}});