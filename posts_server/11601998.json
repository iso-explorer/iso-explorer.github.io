post_cb({"11602256": {"Id": "11602256", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_11601998_11602256_0\">I don't want to give up the const specifier</p>\n</blockquote>\n<p>Well, you have no choice.</p>\n<pre><code>s&amp; operator =(const s&amp; m) {\n    return *new(this) s(m); \n}\n</code></pre>\n<p>Undefined behaviour.</p>\n<p>There's a reason why pretty much nobody uses <code>const</code> member variables, and it's because of this. There's nothing you can do about it. <code>const</code> member variables simply cannot be used in types you want to be assignable. Those types are immutable, and that's it, and your implementation of <code>vector</code> requires mutability.</p>\n", "LastActivityDate": "2012-07-22T17:06:15.877", "Score": "2", "CreationDate": "2012-07-22T17:06:15.877", "ParentId": "11601998", "CommentCount": "3", "OwnerUserId": "298661"}, "15006852": {"Id": "15006852", "PostTypeId": "2", "Body": "<p>Use a const_cast in the assignment operator:</p>\n<pre><code>S&amp; operator=(const S&amp; rhs)\n{\n    if(this==&amp;rhs) return *this;\n    int *pid=const_cast&lt;int*&gt;(&amp;this-&gt;id);\n    *pid=rhs.id;\n    return *this;\n}\n</code></pre>\n", "LastActivityDate": "2013-02-21T16:05:48.770", "Score": "-1", "CreationDate": "2013-02-21T16:05:48.770", "ParentId": "11601998", "CommentCount": "1", "OwnerUserId": "534115"}, "47477929": {"Id": "47477929", "PostTypeId": "2", "Body": "<p>Ok,</p>\n<p>You should always think about a problem with simple steps.</p>\n<pre><code>std::vector&lt;typename T&gt;::push_back(args);   \n</code></pre>\n<p>needs to reserve space in the vector data then assigns(or copy, or move)  the value of the parameter to memory of the <strong>vector.data()[idx]</strong> at that position.</p>\n<p>to understand why you cannot use your structure in the member function <em>std::vector::push_back</em> , try this:</p>\n<pre><code>std::vector&lt;const int&gt; v; // the compiler will hate you here, \n                          // because this is considered ill formed.\n</code></pre>\n<p>The reason why is ill formed, is that the member functions of the class <strong>std::vector</strong> could call the assignment operator of its template argument, but in this case it's a constant type parameter \"<em>const int</em>\" which means it doesn't have an assignment operator ( it's none sense to assign to a const variable!!).\nthe same behavior is observed with a <strong>class type</strong> that has a <strong>const data member</strong>. Because the compiler will delete the default assignment operator, expel</p>\n<pre><code>struct S\n{\n    const int _id; // automatically the default assignment operator is \n                   // delete i.e.  S&amp; operator-(const S&amp;) = delete;\n};\n// ... that's why you cannot do this\nstd::vector&lt;S&gt; v; \nv.Push_back(S(1234));\n</code></pre>\n<p>But if you want to keep the intent and express it in a well formed code this is how you should do it:</p>\n<pre><code>class s\n{\n    int _id;\npublic:\n    explicit s(const int&amp; id) :\n    _id(id)\n    {};\n\n    const int&amp; get() const\n    {\n    return _id; \n    }; // no user can modify the member variable after it's initialization\n\n};\n// this is called data encapsulation, basic technique!\n// ...\nstd::vector&lt;S&gt; v ; \nv.push_back(S(1234)); // in place construction\n</code></pre>\n<p>If you want to break the rules and impose an assignable constant class type, then do what the guys suggested above. </p>\n", "LastActivityDate": "2017-11-24T17:35:37.473", "Score": "1", "CreationDate": "2017-11-24T17:35:37.473", "ParentId": "11601998", "CommentCount": "0", "OwnerUserId": "8599142"}, "11602240": {"Id": "11602240", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_11601998_11602240_0\">Q2. What should I do?</p>\n</blockquote>\n<p>Store pointers, preferably smart.</p>\n<pre><code>vector&lt;unique_ptr&lt;s&gt;&gt; v;\nv.emplace_back(new s(1));\n</code></pre>\n", "LastActivityDate": "2012-07-22T17:03:16.010", "Score": "1", "CreationDate": "2012-07-22T17:03:16.010", "ParentId": "11601998", "CommentCount": "0", "OwnerUserId": "440119"}, "bq_ids": {"n4140": {"so_11601998_47475556_2": {"length": 4, "quality": 0.8, "section_id": 6859}}, "n3337": {"so_11601998_47475556_2": {"length": 4, "quality": 0.8, "section_id": 6605}}, "n4659": {"so_11601998_47475556_2": {"length": 4, "quality": 0.8, "section_id": 8351}}}, "47475556": {"Id": "47475556", "PostTypeId": "2", "Body": "<blockquote>\n<pre><code>s&amp; operator =(const s&amp; m)\n{\n    if(this == &amp;m) return *this;\n    this-&gt;~s();\n    return *new(this) s(m);\n}\n</code></pre>\n<p id=\"so_11601998_47475556_0\">Should I avoid this, and why (if so)? Is it safe to use placement new if the object is on the stack?</p>\n</blockquote>\n<p>You should avoid it if you can, not because it is ill-formed, but because it is quite hard for a reader to understand your goal and trust in this code. As a programmer, you should aim to reduce the number of WTF/line of code you write.</p>\n<p><strong>But</strong>, it is legal. According to</p>\n<blockquote>\n<p id=\"so_11601998_47475556_1\"><a href=\"http://eel.is/c++draft/new.delete.placement#3\" rel=\"nofollow noreferrer\"><code>[new.delete.placement]/3</code></a></p>\n<pre><code>void* operator new(std::size_t size, void* ptr) noexcept;\n</code></pre>\n<p id=\"so_11601998_47475556_2\">3 Remarks: Intentionally performs no other action.</p>\n</blockquote>\n<p>Invoking the placement new does not allocate or deallocate memory, and is equivalent to manually call the copy constructor of <code>s</code>, which according to <a href=\"https://timsong-cpp.github.io/cppwp/basic.life#8\" rel=\"nofollow noreferrer\"><code>[basic.life]/8</code></a> is legal if <code>s</code> has a trivial destructor.</p>\n", "LastEditorUserId": "5470596", "LastActivityDate": "2017-11-24T15:20:17.037", "Score": "1", "CreationDate": "2017-11-24T14:44:53.197", "ParentId": "11601998", "CommentCount": "1", "LastEditDate": "2017-11-24T15:20:17.037", "OwnerUserId": "5470596"}, "11602138": {"Id": "11602138", "PostTypeId": "2", "Body": "<p>C++03 requires that elements stored in containers be <code>CopyConstructible</code> and <code>Assignable</code> (see \u00a723.1). So implementations can decide to use copy construction and assignment as they see fit. These constraints are relaxed in C++11. Explicitly, the <code>push_back</code> operation requirement is that the type be <code>CopyInsertable</code> into the vector (see \u00a723.2.3 Sequence Containers)</p>\n<p>Furthermore, C++11 containers can use move semantics in insertion operations and do on.</p>\n", "LastEditorUserId": "661519", "LastActivityDate": "2012-07-22T16:57:44.127", "Score": "5", "CreationDate": "2012-07-22T16:49:02.567", "ParentId": "11601998", "CommentCount": "2", "LastEditDate": "2012-07-22T16:57:44.127", "OwnerUserId": "661519"}, "11602289": {"Id": "11602289", "PostTypeId": "2", "Body": "<p>It's not really a solution, but a workaround:</p>\n<pre><code>#include &lt;vector&gt;\nstruct s\n{\n  const int id;\n  s(int _id):\n    id(_id)\n    {}\n};\n\nint main(){\n  std::vector&lt;s*&gt; v;  \n  v.push_back(new s(1));\n  return 0;\n}\n</code></pre>\n<p>This will store pointers of <code>s</code> instead of the object itself. At least it compiles... ;)</p>\n<p><strong>edit:</strong> you can enhance this with smart c++11 pointers. See Benjamin Lindley's answer.</p>\n", "LastActivityDate": "2012-07-22T17:10:02.243", "Score": "0", "CreationDate": "2012-07-22T17:10:02.243", "ParentId": "11601998", "CommentCount": "0", "OwnerUserId": "1175824"}, "11601998": {"ViewCount": "5408", "Body": "<p>Consider the following code:</p>\n<pre><code>struct s\n{\n    const int id;\n\n    s(int _id):\n        id(_id)\n    {}\n};\n// ...\nvector&lt;s&gt; v;  v.push_back(s(1));\n</code></pre>\n<p>I get a compiler error that 'const int id' cannot use default assignment operator.</p>\n<p><strike>Q1. Why does push_back() need an assignment operator?</strike><br>\nA1. Because the current c++ standard says so.</br></p>\n<p><strike>Q2. What should I do?</strike></p>\n<ul>\n<li>I don't want to give up the const specifier</li>\n<li>I want the data to be copied</li>\n</ul>\n<p></p>\nA2. I will use smart pointers.\n<p>Q3. I came up with a \"solution\", which seems rather insane:</p>\n<pre><code>s&amp; operator =(const s&amp; m)\n{\n    if(this == &amp;m) return *this;\n    this-&gt;~s();\n    return *new(this) s(m);\n}\n</code></pre>\n<p>Should I avoid this, and why (if so)? <strong>Is it safe to use placement new if the object is on the stack?</strong></p>\n", "AcceptedAnswerId": "11602138", "Title": "assignment of class with const member", "CreationDate": "2012-07-22T16:30:42.067", "Id": "11601998", "CommentCount": "12", "LastEditDate": "2012-07-22T17:44:40.483", "PostTypeId": "1", "LastEditorUserId": "576812", "LastActivityDate": "2017-11-24T17:35:37.473", "Score": "7", "OwnerUserId": "576812", "Tags": "<c++><vector><assignment-operator><placement-new>", "AnswerCount": "7"}});