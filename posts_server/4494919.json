post_cb({"4495050": {"Id": "4495050", "PostTypeId": "2", "Body": "<p>This is a violation of the one definition rule :</p>\n<blockquote>\n<p id=\"so_4494919_4495050_0\">There can be more than one definition\n  of a class type (clause 9),\n  enumeration type (7.2), inline\n  function with external linkage\n  (7.1.2), class template (clause 14),\n  non-static function template (14.5.5),\n  static data member of a class template\n  (14.5.1.3), member function of a class\n  template (14.5.1.1), or <strong>template\n  specialization for which some template\n  parameters are not specified</strong> (14.7,\n  14.5.4) in a program provided that each definition appears in a different\n  translation unit, and provided the\n  definitions satisfy the following\n  requirements.</p>\n</blockquote>\n<p>An explicit specialization of the <code>class2name</code> template function does not fall in any of these cases. For this reason, I believe that moving <code>class2name&lt;int&gt;()</code> definition into an implementation file should fix the issue. I also think you should have a look on <a href=\"http://www.gotw.ca/publications/mill17.htm\" rel=\"nofollow\">\"Why not specialize function templates ?\"</a>.</p>\n", "LastActivityDate": "2010-12-20T23:37:35.500", "CommentCount": "1", "CreationDate": "2010-12-20T23:37:35.500", "ParentId": "4494919", "Score": "3", "OwnerUserId": "451980"}, "bq_ids": {"n4140": {"so_4494919_4495050_0": {"length": 46, "quality": 0.8518518518518519, "section_id": 7043}}, "n3337": {"so_4494919_4495050_0": {"length": 46, "quality": 0.8518518518518519, "section_id": 6788}}, "n4659": {"so_4494919_4495050_0": {"length": 46, "quality": 0.8518518518518519, "section_id": 8540}}}, "4495069": {"Id": "4495069", "PostTypeId": "2", "Body": "<p>In short: an explicitly (i.e. fully) specialized template function <em>is no longer a template</em>. It is an ordinary function and it obeys One Definition Rule for ordinary functions. </p>\n<p>In other words you can't define explicitly specialized function templates in header file. Doing so will result in ODR violations.</p>\n<p>A template is a template only as long as it depends on at least one parameter. I.e. <em>partial</em> specializations can be <em>defined</em> in header files (since they are still <em>templates</em>). <em>Explicit</em> (i.e. full) specializations can only be <em>declared</em> in header files, but have to be <em>defined</em> in implementation files, just like ordinary functions.</p>\n", "LastActivityDate": "2010-12-20T23:42:23.637", "CommentCount": "3", "CreationDate": "2010-12-20T23:42:23.637", "ParentId": "4494919", "Score": "9", "OwnerUserId": "187690"}, "6293876": {"Id": "6293876", "PostTypeId": "2", "Body": "<p>Your files:</p>\n<pre><code>./main.cpp  \n./type_traints/TypeTraints.cpp  \n./type_traints/TypeTraints.hpp  \n./type_traints/chapter_20.hpp\n</code></pre>\n<p>in which TypeTraints.hpp is directly included in TypeTraits.cpp and indirectly included in main.cpp(through chapter_20.hpp). However, you fully specification template </p>\n<pre><code> template&lt;&gt; const char* class2name&lt;int&gt;() {\n     return \"int\";\n };\n</code></pre>\n<p>is defined in TypeTraints.hpp which be existing in two different compilation units(the above two .cpp file). These two files will be linked together after compilation and this cause the multiple definition link error. </p>\n", "LastActivityDate": "2011-06-09T13:53:28.253", "CommentCount": "1", "CreationDate": "2011-06-09T13:53:28.253", "ParentId": "4494919", "Score": "1", "OwnerUserId": "247807"}, "4494919": {"ViewCount": "2805", "Body": "<p><br>\n I have a project with configuration:  </br></p>\n<pre><code>./main.cpp  \n./type_traints/TypeTraints.cpp\n./type_traints/TypeTraints.hpp\n./type_traints/chapter_20.hpp\n</code></pre>\n<p>The ./type_traints/CMakeLists.txt file is:</p>\n<pre><code> cmake_minimum_required (VERSION 2.8)\n add_library(chapter_20 TypeTraints.cpp)\n</code></pre>\n<p>and the ./CMakeLists.txt follows:</p>\n<pre><code>cmake_minimum_required (VERSION 2.8)\nproject (mpl)\n\nadd_subdirectory(type_traints)\ninclude_directories(type_traints)\nlink_directories(type_traints)\n\nadd_executable (mpl main.cpp)\ntarget_link_libraries(mpl chapter_20)\n</code></pre>\n<p>Relevant parts of files (most includes omitted) include:<br>\n./type_traints/chapter_20.hpp</br></p>\n<pre><code>#ifndef CHAPTER_20_GUARD\n#define CHAPTER_20_GUARD\n#include &lt;TypeTraints.hpp&gt;\n\nvoid chapter_20() {\n  test_23();\n}   \n#endif //CHAPTER_20_GUARD\n</code></pre>\n<p>./type_traints/TypeTraints.hpp</p>\n<pre><code>#ifndef TYPE_TRAINTS_GUARD\n#define TYPE_TRAINTS_GUARD\nnamespace details {\n\n  template&lt;class T&gt; const char* class2name() {\n    return \"unknown\";\n  };\n\n  template&lt;&gt; const char* class2name&lt;int&gt;() {\n    return \"int\";\n  };\n}\n\ntemplate&lt;class T&gt;\nclass type_descriptor {\n  friend std::ostream&amp; operator &lt;&lt; (std::ostream&amp; stream, \n                                    const type_descriptor&lt;T&gt;&amp; desc) {\n    stream &lt;&lt; desc.getName();\n    return stream;\n  }\n\npublic:\n  std::string getName() const;  \n};\n\ntemplate&lt;class T&gt;\nstd::string type_descriptor&lt;T&gt;::getName() const {\n  return details::class2name&lt;T&gt;();\n}\n\nvoid test_23();    \n#endif // TYPE_TRAINTS_GUARD\n</code></pre>\n<p>./type_traints/TypeTraints.cpp</p>\n<pre><code>#include&lt;TypeTraints.hpp&gt;\n\nvoid test_23() {\n  cout &lt;&lt; type_descriptor&lt;int&gt;() &lt;&lt; endl;\n}\n</code></pre>\n<p>and ./main.cpp</p>\n<pre><code>#include &lt;chapter_20.hpp&gt;\n\nint main(int argc, char* argv[]) {\nchapter_20();\n  return 0;\n}\n</code></pre>\n<p>The project compiles but fails to link:</p>\n<pre><code>[ 50%] Building CXX object type_traints/CMakeFiles/chapter_20.dir/TypeTraints.cpp.o\nLinking CXX static library libchapter_20.a\n[ 50%] Built target chapter_20\n[100%] Building CXX object CMakeFiles/mpl.dir/main.cpp.o\nLinking CXX executable mpl\ntype_traints/libchapter_20.a(TypeTraints.cpp.o): In function `char const* details::cl\nass2name&lt;int&gt;()':                                                                   \n/home/marcin/Projects/mpl/type_traints/TypeTraints.hpp:312: multiple definition of `c\nhar const* details::class2name&lt;int&gt;()'                                              \nCMakeFiles/mpl.dir/main.cpp.o:/home/marcin/Projects/mpl/type_traints/TypeTraints.hpp:\n312: first defined here                                                             \ncollect2: ld returned 1 exit status\nmake[2]: *** [mpl] B\u0142\u0105d 1\nmake[1]: *** [CMakeFiles/mpl.dir/all] Error 2\nmake: *** [all] Error 2\n23:56:20@marcin-laptop ~/P\n</code></pre>\n<p>The project links fine if I remove the class2name specialization (<code>class2name&lt;int&gt;()</code>) from TypeTraints.hpp and use only the generic implementation.</p>\n<p>Does anybody have an idea Why is that? Did I miss-configure cmake files? </p>\n", "AcceptedAnswerId": "4495069", "Title": "\"multiple definition of...\" error for a full specialisation of a template function", "CreationDate": "2010-12-20T23:13:19.327", "Id": "4494919", "CommentCount": "0", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2010-12-20T23:38:00.130", "LastEditorUserId": "451980", "LastActivityDate": "2011-06-09T13:53:28.253", "Score": "2", "OwnerUserId": "434341", "Tags": "<c++><templates><definition>", "AnswerCount": "3"}});