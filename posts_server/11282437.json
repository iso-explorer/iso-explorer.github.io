post_cb({"11282663": {"Id": "11282663", "PostTypeId": "2", "Body": "<p>Ranged-for relies on ADL if the special handling for native array (<code>T foo[N]</code>) and member <code>begin</code>/<code>end</code> doesn't yield any results.</p>\n<p><code>\u00a76.5.4 [stmt.ranged] p1</code></p>\n<blockquote id=\"so_11282437_11282663_0\">\n<ul>\n<li>otherwise, <em>begin-expr</em> and <em>end-expr</em> are <code>begin(__range)</code> and <code>end(__range)</code>, respectively, <strong>where <code>begin</code> and <code>end</code> are looked up with argument-dependent lookup (3.4.2)</strong>. For the purposes of this name lookup, namespace <code>std</code> is an associated namespace.</li>\n</ul>\n</blockquote>\n<p>Your problem is, that the associated namespace of <code>std::istream_iterator</code> is (obviously) <code>namespace std</code>, not the global namespace.</p>\n<p><code>\u00a73.4.2 [basic.lookup.argdep] p2</code></p>\n<blockquote>\n<p id=\"so_11282437_11282663_1\">For each argument type <code>T</code> in the function call, there is a set of zero or more associated namespaces and a set of zero or more associated classes to be considered. The sets of namespaces and classes is determined entirely by the types of the function arguments [...].</p>\n<ul>\n<li>If <code>T</code> is a fundamental type, its associated sets of namespaces and classes are both empty.</li>\n<li><strong>If <code>T</code> is a class type</strong> (including unions), its associated classes are: the class itself; the class of which it is a member, if any; and its direct and indirect base classes. <strong>Its associated namespaces are the namespaces of which its associated classes are members.</strong> Furthermore, if T is a class template specialization, its associated namespaces and classes also include: the namespaces and classes associated with the types of the template arguments provided for template type parameters [...].</li>\n</ul>\n</blockquote>\n<p>Note the last (quoted) part of the second bullet. It basically means that using a class which is a member of the global namespace as the template argument makes the code work:</p>\n<pre><code>#include &lt;iterator&gt;\n#include &lt;iostream&gt;\n\ntemplate&lt;class T&gt;\nstd::istream_iterator&lt;T&gt; begin(std::istream_iterator&lt;T&gt; is){\n  return is;\n}\ntemplate&lt;class T&gt;\nstd::istream_iterator&lt;T&gt; end(std::istream_iterator&lt;T&gt;){\n  return std::istream_iterator&lt;T&gt;();\n}\n\nstruct foo{};\n\nstd::istream&amp; operator&gt;&gt;(std::istream&amp; is, foo){\n  return is;\n}\n\nint main(){\n  for(foo f : std::istream_iterator&lt;foo&gt;(std::cin))\n  //                                ^^^\n  // make global namespace one of the associated namespaces\n    ;\n}\n</code></pre>\n", "LastActivityDate": "2012-07-01T14:14:00.913", "CommentCount": "3", "CreationDate": "2012-07-01T14:14:00.913", "ParentId": "11282437", "Score": "7", "OwnerUserId": "500104"}, "11282437": {"ViewCount": "2364", "Body": "<p>I have code like this</p>\n<pre><code>std::ifstream file(filename, std::ios_base::in);\nif(file.good())\n{\n    file.imbue(std::locale(std::locale(), new delimeter_tokens()));\n    for(auto&amp; entry : std::istream_iterator&lt;std::string&gt;(file))\n    {\n        std::cout &lt;&lt; entry &lt;&lt; std::endl;    \n    }\n}\nfile.close();\n</code></pre>\n<p>where <code>std::istream_iterator&lt;std::string&gt;</code>'s  <code>begin()</code> and <code>end()</code>\nare defined as follows</p>\n<pre><code>template&lt;class T&gt;\nstd::istream_iterator&lt;T&gt; begin(std::istream_iterator&lt;T&gt;&amp; stream)\n{\n    return stream;\n}\n\ntemplate&lt;class T&gt;\nstd::istream_iterator&lt;T&gt; end(std::istream_iterator&lt;T&gt;&amp; stream)\n{\n    return std::istream_iterator&lt;T&gt;();\n}\n</code></pre>\n<p>which is what <strong>Mark Nelson</strong> has also written about in Dr. Dobb's <a href=\"http://www.drdobbs.com/cpp/auto-types-and-range-based-for-statement/232900460?pgno=2\" rel=\"nofollow noreferrer\">here</a>. Alas, the code fails to compile on my Visual Studio 2012 with error messages</p>\n<blockquote>\n<p id=\"so_11282437_11282437_0\">error C3312: no callable 'begin' function found for type 'std::istream_iterator&lt;_Ty&gt;'</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_11282437_11282437_1\">error C3312: no callable 'end' function found for type 'std::istream_iterator&lt;_Ty&gt;'</p>\n</blockquote>\n<p><strong>Question:</strong> Is there something I haven't noticed, bug in the compiler (unlikely, but just in case) or... Well, any ideas?</p>\n<p><br/>\nThis questions is cleaned up considerably, as advised by <a href=\"https://stackoverflow.com/users/500104/xeo\">Xeo</a>. To provide more background and references this is related to my <a href=\"https://stackoverflow.com/questions/11269678/how-to-capture-0-2-groups-in-c-regular-expressions-and-print-them\">other question</a> on Stackoverflow, I was wondering how to make line based parsing cleaner than the usual loops. A bit of coding and checking from the internet, and I had a working sketch as follows</p>\n<pre><code>std::ifstream file(filename, std::ios_base::in);\nif(file.good())\n{               \n    file.imbue(std::locale(std::locale(), new delimeter_tokens()));\n    for(auto&amp; entry : istream_range&lt;std::string&gt;(file)\n    {\n        std::cout &lt;&lt; entry &lt;&lt; std::endl;    \n    }\n}\nfile.close();\n</code></pre>\n<p>but there was slight snag I tried to remedy. I think it would look more natural to write as in the code that fails to compile and not like</p>\n<pre><code>for(auto&amp; entry : istream_range&lt;std::string&gt;(file)\n</code></pre>\n<p>Please, take a note of the different iterator. The <strong>delimeter_tokens</strong> is defined like <a href=\"https://stackoverflow.com/users/415784/nawaz\">Nawaz</a> kindly has shown <a href=\"https://stackoverflow.com/questions/5607589/right-way-to-split-an-stdstring-into-a-vectorstring\">here</a> (code not duplicated) and <strong>istream_range</strong> as in Code Synthesis blog <a href=\"http://www.codesynthesis.com/~boris/blog/2012/05/16/cxx11-range-based-for-loop/\" rel=\"nofollow noreferrer\">here</a>. I think the begin and end implementations should work, as advertised in the aforementioned Code Synthesis blog post<blockquote id=\"so_11282437_11282437_2\">The last rule (the fallback to the free-standing begin()and end() functions) allows us to non-invasively adapt an existing container to the range-based for loop interface.</blockquote></p>\n<p>Thus my question with all the (ir)relevant background.</p>\n", "AcceptedAnswerId": "11282663", "Title": "Why doesn't range-for find my overloads of begin and end for std::istream_iterator?", "CreationDate": "2012-07-01T13:39:03.980", "Id": "11282437", "CommentCount": "3", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:33:58.123", "LastEditorUserId": "-1", "LastActivityDate": "2012-07-01T20:26:53.007", "Score": "10", "OwnerUserId": "1332416", "Tags": "<c++><visual-c++><c++11><visual-studio-2012><istream-iterator>", "AnswerCount": "2"}, "11282549": {"Id": "11282549", "PostTypeId": "2", "Body": "<p>Because of argument depended lookup the compiler tries to find <code>begin()</code> and <code>end()</code> in the <code>std</code> namespace. If you put your functions there, the code compiles.</p>\n<p>Since name lookup is a complicated issue in C++ I'm not entirely sure if the compiler is behaving correctly or not.</p>\n", "LastActivityDate": "2012-07-01T13:56:12.507", "CommentCount": "3", "CreationDate": "2012-07-01T13:56:12.507", "ParentId": "11282437", "Score": "1", "OwnerUserId": "56338"}, "bq_ids": {"n4140": {"so_11282437_11282663_1": {"length": 24, "quality": 0.9230769230769231, "section_id": 7104}}, "n3337": {"so_11282437_11282663_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 3766}, "so_11282437_11282663_1": {"length": 24, "quality": 0.9230769230769231, "section_id": 6848}}, "n4659": {"so_11282437_11282663_1": {"length": 20, "quality": 0.7692307692307693, "section_id": 8605}}}});