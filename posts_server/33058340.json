post_cb({"33058550": {"ParentId": "33058340", "CommentCount": "1", "Body": "<p>CoryKramer has answered why it is an undefined behavior by standard.</p>\n<p>I'll try to expain how it works in the real situation. C++ compilers usually implement <code>&lt;&lt;</code> and <code>&gt;&gt;</code> operators for 32-bit integers as assembler instructions without checking the operand range. It means that the result depends on the processor-specific implementation of the shift instructions.</p>\n<p>For example, Intel processor specification for 32-bit SHL/SHR/SAL/SAL instructions says:</p>\n<blockquote>\n<p id=\"so_33058340_33058550_0\">The destination operand can be a register or a memory location. The\n  count operand can be an immediate value or register CL. The count is\n  masked to five bits, which limits the count range to 0 to 31.</p>\n</blockquote>\n<p>It means that <code>a &lt;&lt; b</code> becomes <code>a &lt;&lt; (b &amp; 0x1f)</code> on Intel processors. So shifting by 32 bits means no shift.</p>\n<p>But you should not rely on this information! The compiler can also optimize the code and implement the shift operator using vector instructions. In this case, the behavior is unspecified even by processor specifications.</p>\n", "OwnerUserId": "5380314", "PostTypeId": "2", "Id": "33058550", "Score": "1", "CreationDate": "2015-10-10T20:16:59.843", "LastActivityDate": "2015-10-10T20:16:59.843"}, "33058340": {"CommentCount": "4", "AcceptedAnswerId": "33058368", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-10-10T19:53:38.740", "LastActivityDate": "2015-10-10T20:16:59.843", "LastEditDate": "2017-05-23T12:29:39.193", "ViewCount": "176", "FavoriteCount": "1", "Title": "Left shift an integer by 32 bits", "Id": "33058340", "Score": "0", "Body": "<p>Under GCC, the following code always return the left operand of <code>&lt;&lt;</code> if <code>num1s == 0</code>:</p>\n<pre><code>0xFFFFFFFFu &lt;&lt; (32-num1s);\n</code></pre>\n<p>After reading <a href=\"https://stackoverflow.com/questions/7401888/why-doesnt-left-bit-shift-for-32-bit-integers-work-as-expected-when-used\">Why doesn't left bit-shift, \"&lt;&lt;\", for 32-bit integers work as expected when used more than 32 times?</a>, and the standard quoted by David Heffernan, it seems that if the left operand is <strong>unsigned</strong>, it is a defined operation. It is only when E1 (the left operand) has a signed type and non-negative value that it could result in undefined behavior.</p>\n<p>Can any one explain if the standard states explicitly that if the amount shifted is larger than the number of bits the type contains, it is <strong>undefined behavior</strong>?</p>\n", "Tags": "<c++>", "OwnerUserId": "1021388", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_33058340_33058368_1": {"section_id": 6147, "quality": 0.9210526315789473, "length": 35}, "so_33058340_33058368_0": {"section_id": 6146, "quality": 0.9, "length": 18}}, "n3337": {"so_33058340_33058368_1": {"section_id": 5910, "quality": 0.9210526315789473, "length": 35}, "so_33058340_33058368_0": {"section_id": 5909, "quality": 0.9, "length": 18}}, "n4659": {"so_33058340_33058368_1": {"section_id": 7643, "quality": 0.9210526315789473, "length": 35}, "so_33058340_33058368_0": {"section_id": 7642, "quality": 0.9, "length": 18}}}, "33058368": {"ParentId": "33058340", "PostTypeId": "2", "CommentCount": "2", "Body": "<p><strong>\u00a75.8 Shift operators</strong></p>\n<blockquote>\n<p id=\"so_33058340_33058368_0\">The type of the result is that of the promoted left operand. <strong>The behavior is undefined if the right operand is negative, or greater than or equal to the length in bits of the promoted left operand.</strong></p>\n<p id=\"so_33058340_33058368_1\">The value of <code>E1 &lt;&lt; E2</code> is <code>E1</code> left-shifted <code>E2</code> bit positions; vacated bits are zero-filled. If <code>E1</code> has an unsigned type, the value of the result is <code>E1 \u00d7 2E2</code>, reduced modulo one more than the maximum value representable in the result type. Otherwise, if <code>E1</code> has a signed type and non-negative value, and <code>E1\u00d72E2</code> is representable in the result type, then that is the resulting value; otherwise, the behavior is undefined.</p>\n</blockquote>\n", "OwnerUserId": "2296458", "LastEditorUserId": "2296458", "LastEditDate": "2015-10-10T20:02:34.123", "Id": "33058368", "Score": "4", "CreationDate": "2015-10-10T19:56:51.827", "LastActivityDate": "2015-10-10T20:02:34.123"}});