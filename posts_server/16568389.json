post_cb({"16568456": {"Id": "16568456", "PostTypeId": "2", "Body": "<p>The C++ standard says that it's undefined behavior and illegal. What this means in practice is that <em>anything</em> could happen, and the anything can vary by hardware, compiler, options, and anything else you can think of. Since anything could happen there isn't a lot of point in speculating about what might happen with a particular hardware/compiler combination.</p>\n", "LastActivityDate": "2013-05-15T14:57:10.990", "CommentCount": "0", "CreationDate": "2013-05-15T14:57:10.990", "ParentId": "16568389", "Score": "1", "OwnerUserId": "251738"}, "16568708": {"Id": "16568708", "PostTypeId": "2", "Body": "<p>Whatever happens, you get undefined behaviour since pointer arithmetic is only defined within an array (including the one-past-the-end position).</p>\n<p>A better question might be:</p>\n<pre><code>int test[10];\nint * t1 = test+1;\nint b = t1[-1];      // Is this defined behaviour?\n</code></pre>\n<p>The answer to this is yes. The definition of subscripting (C++11 5.2.1) is:</p>\n<blockquote>\n<p id=\"so_16568389_16568708_0\">The expression E1[E2] is identical (by definition) to *((E1)+(E2))</p>\n</blockquote>\n<p>so this is equivalent to <code>*((t1)+(-1))</code>. The definition of pointer addition (C++11 5.7/5) is for all integer types, signed or unsigned, so nothing will cause <code>-1</code> to be converted into an unsigned type; so the expression is equivalent to <code>*(t1-1)</code>, which is well-defined since <code>t1-1</code> is within the array bounds.</p>\n", "LastEditorUserId": "204847", "LastActivityDate": "2013-05-15T15:20:02.367", "Score": "2", "CreationDate": "2013-05-15T15:07:45.510", "ParentId": "16568389", "CommentCount": "0", "OwnerUserId": "204847", "LastEditDate": "2013-05-15T15:20:02.367"}, "16568445": {"Id": "16568445", "PostTypeId": "2", "Body": "<p>The behaviour of your program is undefined as you are attempting to access an element outside the bounds of the array.</p>\n<p>What might be happening is this: Assuming you have a 32 bit int type, you're accessing the 32 bits of memory on the stack (if any) before test[0] and are casting this to an int. Your process may not even own this memory. Not good.</p>\n", "LastEditorUserId": "2380830", "LastActivityDate": "2017-04-27T16:48:57.903", "Score": "2", "CreationDate": "2013-05-15T14:56:48.097", "ParentId": "16568389", "CommentCount": "0", "OwnerUserId": "2380830", "LastEditDate": "2017-04-27T16:48:57.903"}, "16568698": {"Id": "16568698", "PostTypeId": "2", "Body": "<p>The official answer is that the behavior is undefined.  Unofficially, you are trying to access the integer before the start of the array.  This means that you instruct the computer to calculate the address that precedes the start of the array by 4 bytes (in your case).  Whether this operation will success or not depends on multiple factors.  Some of them are whether the array is going to be allocated on the stack segment or static data segment, where specifically the location of that address is going to be.  On a general purpose machine (windows/linux) you are likely to get a garbage value as a result but it may also result in a memory violation error if the address happens to be somewhere where the process is not authorized to access.  What may happen on a specialized hardware is anybody's guess.</p>\n", "LastActivityDate": "2013-05-15T15:07:21.260", "CommentCount": "0", "CreationDate": "2013-05-15T15:07:21.260", "ParentId": "16568389", "Score": "1", "OwnerUserId": "878915"}, "bq_ids": {"n4140": {"so_16568389_16568708_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 5986}}, "n3337": {"so_16568389_16568708_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 5754}}, "n4659": {"so_16568389_16568708_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 7486}}}, "16568389": {"ViewCount": "101", "Body": "<p>let's say I have:</p>\n<pre><code>int test[10];\n</code></pre>\n<p>on a 32bit machine. What if I do:</p>\n<pre><code>int b = test[-1];\n</code></pre>\n<p>obviously that's a big no-no when it comes to access an array (out of bound) but what actually happens? Just curious</p>\n<p>Am I accessing the 32bit word \"before\" my array?</p>\n<pre><code>int b = *(test - 1);\n</code></pre>\n<p>or just addressing a very far away word (starting at \"test\" memory location)?</p>\n<pre><code>int b = *(test + 0xFFFFFFFF);\n</code></pre>\n<p>0xFFFFFFFF is the two's complement representation of decimal -1</p>\n", "AcceptedAnswerId": "16568445", "Title": "C++ array accessing", "CreationDate": "2013-05-15T14:54:48.683", "Id": "16568389", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-04-27T16:48:57.903", "Score": "0", "OwnerUserId": "958464", "Tags": "<c++><arrays><indexing><addressing>", "AnswerCount": "4"}});