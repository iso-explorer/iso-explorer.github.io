post_cb({"34889583": {"ViewCount": "486", "Body": "<p>The following code compiles using gcc 5.2, gcc 4.9, and clang 3.7 at C++11 standard:</p>\n<pre><code>template &lt;typename T, typename U, template&lt;typename...&gt; class M&gt;\nU * find_item(M&lt;T, U&gt; &amp; m, const T &amp; t) {\n  auto it = m.find(t);\n  if (it != m.end()) { return &amp;it-&gt;second; }\n  return nullptr;\n}\n\ntemplate &lt;typename T, typename U, template&lt;typename...&gt; class M&gt;\nconst U * find_item(const M&lt;T, U&gt; &amp; m, const T &amp; t) {\n  auto it = m.find(t);\n  if (it != m.end()) { return &amp;it-&gt;second; }\n  return nullptr;\n}\n\n#include &lt;map&gt;\n#include &lt;unordered_map&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nint main() {\n  std::map&lt;std::string, int&gt; foo;\n\n  foo[\"asdf\"] = 5;\n  if (find_item(foo, std::string{\"bar\"})) { std::cerr &lt;&lt; \"hmm\\n\"; }\n}\n</code></pre>\n<p>However, when I compile it with the latest version of emscripten, I get a compiler error stemming from <code>too few arguments for class template 'map'</code>:</p>\n<pre><code>main.cpp:24:7: error: no matching function for call to 'find_item'\n  if (find_item(foo, std::string{\"bar\"})) { std::cerr &lt;&lt; \"hmm\\n\"; }\n      ^~~~~~~~~\nmain.cpp:2:5: note: candidate template ignored: substitution failure [with T =\n      std::__1::basic_string&lt;char&gt;, U = int, M = map]: too few template\n      arguments for class template 'map'\nU * find_item(M&lt;T, U&gt; &amp; m, const T &amp; t) {\n    ^         ~\nmain.cpp:9:11: note: candidate template ignored: substitution failure [with T =\n      std::__1::basic_string&lt;char&gt;, U = int, M = map]: too few template\n      arguments for class template 'map'\nconst U * find_item(const M&lt;T, U&gt; &amp; m, const T &amp; t) {\n          ^               ~\n1 error generated.\nERROR:root:compiler frontend failed to generate LLVM bitcode, halting\n</code></pre>\n<p>This is a bit odd because my emscripten claims to be based on clang-3.7. Regardless, it seems to have difficulty deducing the default parameters while instantiating the <code>find_item</code> template.</p>\n<p>If the code is changed in the following way, then all compilers seem to be happy with it:</p>\n<pre><code>template &lt;typename T, typename U, template&lt;typename...&gt; class M, typename... dummy&gt;\nU * find_item(M&lt;T, U, dummy...&gt; &amp; m, const T &amp; t) {\n  auto it = m.find(t);\n  if (it != m.end()) { return &amp;it-&gt;second; }\n  return nullptr;\n}\n\ntemplate &lt;typename T, typename U, template&lt;typename...&gt; class M, typename... dummy&gt;\nconst U * find_item(const M&lt;T, U, dummy...&gt; &amp; m, const T &amp; t) {\n  auto it = m.find(t);\n  if (it != m.end()) { return &amp;it-&gt;second; }\n  return nullptr;\n}\n\n#include &lt;map&gt;\n#include &lt;unordered_map&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nint main() {\n  std::map&lt;std::string, int&gt; foo;\n\n  foo[\"asdf\"] = 5;\n  if (find_item(foo, std::string{\"bar\"})) { std::cerr &lt;&lt; \"hmm\\n\"; }\n}\n</code></pre>\n<p>The question is, should the \"dummy\" part actually be necessary according to the C++11 standard, or is emscripten defective in not figuring out the default template parameters here?</p>\n<p>My reading of section <code>[temp.deduct.type] 14.8.2.6.8</code> is that it should be able to bind <code>std::map</code> to a template template parameter of the form <code>M&lt;T, U&gt;</code> because of the wording \"at least one\" in this sentence:</p>\n<blockquote>\n<p id=\"so_34889583_34889583_0\">Similarly, &lt;T&gt; represents template argument\n  lists where at least one argument contains a T</p>\n</blockquote>\n<p>But, I'm not sure about that.</p>\n", "Title": "Default template arguments when using template template parameters", "CreationDate": "2016-01-20T00:43:54.720", "LastActivityDate": "2017-03-31T08:55:42.887", "CommentCount": "3", "LastEditDate": "2016-01-25T08:40:45.263", "PostTypeId": "1", "LastEditorUserId": "1016716", "Id": "34889583", "Score": "1", "OwnerUserId": "3598119", "Tags": "<c++><templates><c++11><language-lawyer><emscripten>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_34889583_34889583_0": {"length": 10, "quality": 1.0, "section_id": 339}}, "n3337": {"so_34889583_34889583_0": {"length": 10, "quality": 1.0, "section_id": 329}}, "n4659": {"so_34889583_34889583_0": {"length": 10, "quality": 1.0, "section_id": 348}}}, "43136486": {"Id": "43136486", "PostTypeId": "2", "Body": "<p>I hit this problem and found that I didn't need the dummy template parameter, specifying the template template as variadic was enough (this is on clang 3.6):</p>\n<pre><code>template &lt;typename T, typename U, template&lt;typename...&gt; class M&gt;\nU * find_item(M&lt;T, U&gt; &amp; m, const T &amp; t) {\n  auto it = m.find(t);\n  if (it != m.end()) { return &amp;it-&gt;second; }\n  return nullptr;\n}\n\ntemplate &lt;typename T, typename U, template&lt;typename...&gt; class M&gt;\nconst U * find_item(const M&lt;T, U&gt; &amp; m, const T &amp; t) {\n  auto it = m.find(t);\n  if (it != m.end()) { return &amp;it-&gt;second; }\n  return nullptr;\n}\n</code></pre>\n", "LastActivityDate": "2017-03-31T08:55:42.887", "CommentCount": "0", "CreationDate": "2017-03-31T08:55:42.887", "ParentId": "34889583", "Score": "1", "OwnerUserId": "649140"}});