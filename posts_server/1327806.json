post_cb({"1327830": {"PostTypeId": "2", "Body": "<p>That behavior is valid according to the C++ Standard.  Any recent compiler <em>should</em> support it.</p>\n", "LastActivityDate": "2009-08-25T11:59:52.663", "Id": "1327830", "Score": "13", "CreationDate": "2009-08-25T11:59:52.663", "ParentId": "1327806", "CommentCount": "0", "OwnerUserId": "132510"}, "1327806": {"ViewCount": "1884", "Body": "<p>In VC++ when I need to specify an array bound for a class member variable I do it this way:</p>\n<pre><code> class Class {\n\n private:\n     static const int numberOfColors = 16;\n     COLORREF colors[numberOfColors];\n };\n</code></pre>\n<p>(please don't tell me about using std::vector here)</p>\n<p>This way I have a constant that can be used as an array bound and later in the class code to specify loop-statement constraints and at the same time it is not visible anywhere else.</p>\n<p>The question is whether this usage of <code>static const int</code> member variables only allowed by VC++ or is it typically allowed by other widespread compilers?</p>\n", "AcceptedAnswerId": "1328583", "Title": "Do all C++ compilers allow using a static const int class member variable as an array bound?", "CreationDate": "2009-08-25T11:54:34.530", "Id": "1327806", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2009-08-25T16:37:32.243", "Score": "8", "OwnerUserId": "57428", "Tags": "<c++><visual-c++><static><const>", "AnswerCount": "9"}, "1327812": {"PostTypeId": "2", "Body": "<p>I've stopped bothering about the portability of that years ago.  There are perhaps still compilers which don't support it, but I haven't met any of them recently.</p>\n", "LastActivityDate": "2009-08-25T11:57:22.840", "Id": "1327812", "Score": "1", "CreationDate": "2009-08-25T11:57:22.840", "ParentId": "1327806", "CommentCount": "0", "OwnerUserId": "136208"}, "1328099": {"PostTypeId": "2", "Body": "<p>Besides other answers you can use following function do determine number of elements in statically alocated arrays:</p>\n<pre><code>template&lt;typename T, size_t length&gt;\nsize_t arrayLength(T (&amp;a)[length])\n{\n    return length;\n}\n</code></pre>\n", "LastActivityDate": "2009-08-25T12:53:49.923", "Id": "1328099", "Score": "3", "CreationDate": "2009-08-25T12:53:49.923", "ParentId": "1327806", "CommentCount": "0", "OwnerUserId": "31782"}, "1327847": {"PostTypeId": "2", "Body": "<p>I believe that Visual Studio 2005 and beyond supports it. The XCode C++ compiler as well (this is gcc actually).</p>\n<p>If you want to be safe you could always use the old enum hack that I learned from Effective C++. It goes like this:</p>\n<pre><code>class Class {\n\n private:\n     enum {\n        numberOfColors = 16\n     };\n     COLORREF colors[numberOfColors];\n };\n</code></pre>\n<p>Hope this helps.</p>\n", "LastActivityDate": "2009-08-25T12:02:30.427", "Id": "1327847", "Score": "6", "CreationDate": "2009-08-25T12:02:30.427", "ParentId": "1327806", "CommentCount": "2", "OwnerUserId": "75889"}, "1327852": {"PostTypeId": "2", "Body": "<p>I'm pretty sure that this will also work with gcc and Solaris, but I can't verify this at the moment.</p>\n<p>In the future you could extend the idea like this:</p>\n<pre><code>template&lt;int size&gt;\nclass Class {\nprivate:\n    COLORREF colors[size];\n};\n</code></pre>\n<p>and use it like this:</p>\n<pre><code>Class&lt;5&gt; c;\n</code></pre>\n<p>so that you are not limited to exactly one buffer size in your application.</p>\n", "LastActivityDate": "2009-08-25T12:04:15.837", "Id": "1327852", "Score": "2", "CreationDate": "2009-08-25T12:04:15.837", "ParentId": "1327806", "CommentCount": "2", "OwnerUserId": "4834"}, "1327845": {"PostTypeId": "2", "Body": "<p>This has been standard C++ for more than a decade now. It's even supported by VC -- what more could you want? (@Neil: What about SunCC? <code>:^&gt;</code>)</p>\n", "LastActivityDate": "2009-08-25T12:02:29.570", "Id": "1327845", "Score": "6", "CreationDate": "2009-08-25T12:02:29.570", "ParentId": "1327806", "CommentCount": "0", "OwnerUserId": "140719"}, "1328583": {"PostTypeId": "2", "Body": "<p>Yes, it's 100% legal and should be portable.  The C++ standard says this in 5.19 - Constant expressions\" (emphasis mine):</p>\n<blockquote>\n<p id=\"so_1327806_1328583_0\">In several places, C++ requires expressions that evaluate to an integral or enumeration constant: as array bounds (8.3.4, 5.3.4), as case-expressions (6.4.2), as bit-field lengths (9.6), as enumerator initializers (7.2), as static member initializers (9.4.2), and as integral or enumeration non-type template arguments (14.3).</p>\n<pre><code>constant-expression:\n    conditional-expression\n</code></pre>\n<p id=\"so_1327806_1328583_1\">An integral  constant-expression can  involve  only  literals  (2.13),  enumerators, <strong>const variables  or  static data  members  of  integral  or  enumeration  types  initialized  with constant expressions</strong> (8.5), non-type template parameters of integral or enumeration types, and sizeof expressions. </p>\n</blockquote>\n<p>That said, it appears that VC6 doesn't support it.  See <a href=\"https://stackoverflow.com/questions/1327806/do-all-c-compilers-allow-using-a-static-const-int-class-member-variable-as-an-a/1327847#1327847\">StackedCrooked's answer</a> for a good workaround. In fact, I generally prefer the <code>enum</code> method StackedCrooked mentions for this type of thing.</p>\n<p>As an FYI, the \"<code>static const</code>\" technique works in VC9, GCC 3.4.5 (MinGW), Comeau and Digital Mars.</p>\n<p>And don't forget that if you use a \"`static const'\" member, you'll <a href=\"https://stackoverflow.com/questions/1257267/is-it-legal-c-to-pass-the-address-of-a-static-const-int-with-no-definition-to-a/1257366#1257366\">need a definition for it in addition to the declaration</a> strictly speaking.  However, virtually all compilers will let you get away with skipping the definition in this case.</p>\n", "LastActivityDate": "2009-08-25T16:37:32.243", "LastEditorUserId": "-1", "Id": "1328583", "Score": "4", "CreationDate": "2009-08-25T14:17:45.840", "ParentId": "1327806", "CommentCount": "0", "LastEditDate": "2017-05-23T11:58:25.373", "OwnerUserId": "12711"}, "bq_ids": {"n4140": {"so_1327806_1328583_0": {"length": 15, "quality": 0.5357142857142857, "section_id": 6186}}}, "1327918": {"PostTypeId": "2", "Body": "<p>This is valid C++ and most (all?) reasonably modern compilers support it. If you are using boost, you can get portable support for this feature in the form of <code>BOOST_STATIC_CONSTANT</code> macro:</p>\n<pre><code>class Class {\n private:\n     BOOST_STATIC_CONSTANT(int, numberOfColors = 16);\n     COLORREF colors[numberOfColors];\n };\n</code></pre>\n<p>The macro is expanded to <code>static const int numberOfColors = 16</code> if the compiler supports this, otherwise it resorts to <code>enum { numberOfColors=16 };</code>.</p>\n", "LastActivityDate": "2009-08-25T12:19:44.860", "Id": "1327918", "Score": "13", "CreationDate": "2009-08-25T12:19:44.860", "ParentId": "1327806", "CommentCount": "0", "OwnerUserId": "70427"}, "1327859": {"PostTypeId": "2", "Body": "<p>It is possible to answer questions like this by referencing the ISO C++ speicifcation but the spec is hard for people to get and harder to read.\nI think the simplest answer hinges on two things:</p>\n<ul>\n<li>Microsoft Visual Studio 2005 and up is a relatively conformant C++ implementation. If it allows you to do something, chances are its standard.</li>\n<li>Download something like Code::Blocks to get a GCC compiler to try stuff out. If it works in MS and GCC, chances really are, its standard.</li>\n</ul>\n", "LastActivityDate": "2009-08-25T12:06:39.937", "Id": "1327859", "Score": "-1", "CreationDate": "2009-08-25T12:06:39.937", "ParentId": "1327806", "CommentCount": "1", "OwnerUserId": "27491"}});