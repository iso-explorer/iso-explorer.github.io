post_cb({"32421568": {"ParentId": "29412412", "CommentCount": "1", "CreationDate": "2015-09-06T08:28:29.687", "OwnerUserId": "2930499", "PostTypeId": "2", "Id": "32421568", "Score": "0", "Body": "<p>The following code (with the <code>final</code> specifier) compiles. But compilation fails when <code>final</code> is replaced with <code>override final</code>. Thus <code>override final</code> conveys more information (and prevents compilation) than just <code>final</code>.</p>\n<pre><code>class Base\n{\npublic:\n    virtual ~Base() {}\n};\n\nclass Derived : public Base\n{\npublic:\n    virtual void foo() final\n    {\n        std::cout &lt;&lt; \"in Derived foo\\n\";\n    }\n};\n</code></pre>\n<p>Essentially, <code>override final</code> says this method cannot be overridden in any derived class <em>and</em> this method overrides a virtual method in a base class. <code>final</code> alone doesn't specify the base class overriding part.</p>\n", "LastActivityDate": "2015-09-06T08:28:29.687"}, "29412527": {"ParentId": "29412412", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-04-02T12:04:32.057", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:18:10.910", "Id": "29412527", "OwnerUserId": "2296458", "Body": "<p>No <code>final</code> does not necessarily imply <code>override</code>. In fact, you could declare a <code>virtual</code> function that you immediately declare <code>final</code> <a href=\"http://cpp.sh/6pfbg\" rel=\"nofollow noreferrer\">see here</a>. The <code>final</code> keyword simply states that no derived <code>class</code> can create an override of this function.</p>\n<p>The <code>override</code> keyword is important in that it enforces that you are indeed actually overriding a virtual function (instead of declaring a new unrelated one). See <a href=\"https://stackoverflow.com/questions/18198314/override-keyword-in-c\">this post regarding <code>override</code></a></p>\n<p>So long story short, they each serve their own particular purpose, and it is often correct to use both.</p>\n", "LastActivityDate": "2015-04-02T12:04:32.057"}, "35622911": {"ParentId": "29412412", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-02-25T09:15:44.203", "Score": "3", "LastEditorUserId": "5340808", "LastEditDate": "2016-02-25T12:04:34.637", "Id": "35622911", "OwnerUserId": "5340808", "Body": "<p>(Skip to the end to see the conclusion if you're in a hurry.)</p>\n<p>Both <code>override</code> and <code>final</code> can appear only in declaration in a virtual function. And both key words can be used in the same function declaration, but whether it is useful to use them both depends on situations.</p>\n<p>Take the following code as an example:</p>\n<pre><code>#include &lt;iostream&gt;\nusing std::cout; using std::endl;\n\nstruct B {\n  virtual void f1() { cout &lt;&lt; \"B::f1() \"; }\n  virtual void f2() { cout &lt;&lt; \"B::f2() \"; }\n  virtual void f3() { cout &lt;&lt; \"B::f3() \"; }\n  virtual void f6() final { cout &lt;&lt; \"B::f6() \"; }\n  void f7() { cout &lt;&lt; \"B::f7() \"; }\n  void f8() { cout &lt;&lt; \"B::f8() \"; }\n  void f9() { cout &lt;&lt; \"B::f9() \"; }\n};\n\nstruct D : B {\n  void f1() override { cout &lt;&lt; \"D::f1() \"; }\n  void f2() final { cout &lt;&lt; \"D::f2() \"; }\n  void f3() override final { cout &lt;&lt; \"D::f3() \"; }  // need not have override\n  // should have override, otherwise add new virtual function\n  virtual void f4() final { cout &lt;&lt; \"D::f4() \"; }\n  //virtual void f5() override final;  // Error, no virtual function in base class\n  //void f6(); // Error, override a final virtual function\n  void f7() { cout &lt;&lt; \"D::f7() \"; }\n  virtual void f8() { cout &lt;&lt; \"D::f8() \"; }\n  //void f9() override;  // Error, override a nonvirtual function \n};\n\nint main() {\n  B b; D d;\n  B *bp = &amp;b, *bd = &amp;d; D *dp = &amp;d;\n  bp-&gt;f1(); bp-&gt;f2(); bp-&gt;f3(); bp-&gt;f6(); bp-&gt;f7(); bp-&gt;f8(); bp-&gt;f9(); cout &lt;&lt; endl;\n  bd-&gt;f1(); bd-&gt;f2(); bd-&gt;f3(); bd-&gt;f6(); bd-&gt;f7(); bd-&gt;f8(); bd-&gt;f9(); cout &lt;&lt; endl;\n  dp-&gt;f1(); dp-&gt;f2(); dp-&gt;f3(); dp-&gt;f6(); dp-&gt;f7(); dp-&gt;f8(); dp-&gt;f9(); cout &lt;&lt; endl;\n  return 0;\n}\n</code></pre>\n<p>The output is</p>\n<pre><code>B::f1() B::f2() B::f3() B::f6() B::f7() B::f8() B::f9()\nD::f1() D::f2() D::f3() B::f6() B::f7() B::f8() B::f9()\nD::f1() D::f2() D::f3() B::f6() D::f7() D::f8() B::f9()\n</code></pre>\n<ol>\n<li><p>Compare <code>f1()</code> and <code>f6()</code>. We know that <code>override</code> and <code>final</code> is indepent sematically.</p>\n<ul>\n<li><code>override</code> means the function is overriding a virtual function in its base class. See <code>f1()</code> and <code>f3()</code>.</li>\n<li><code>final</code> means the function cannot be overrided by its derived class. (But the function itself need not override a base class virtual function.) See <code>f6()</code> and <code>f4()</code>.</li>\n</ul></li>\n<li><p>Compare <code>f2()</code> and <code>f3()</code>. We know that if a member function is declared without <code>virtual</code> and with <code>final</code>, it means that it already override a virtual function in base class. In this case, the key word <code>override</code> is redundant.</p></li>\n<li><p>Compare <code>f4()</code> and <code>f5()</code>. We know that if a member function is declared with <code>virtual</code>and if it is not the <em>first</em> virtual function in inheritance hierarchy, then we should use <code>override</code> to specify the override relationship. Otherwise, we may accidentally add new virtual function in derived class.</p></li>\n<li><p>Compare <code>f1()</code> and <code>f7()</code>. We know that any member function, not just virtual ones, can be overridden in derived class. What <code>virtual</code> specifies is <em>polymorphism</em>, which means the decision as to which function to run is delayed until run time instead of compile time. (This should be avoid in practice.)</p></li>\n<li><p>Compare <code>f7()</code> and <code>f8()</code>. We know that we can even override a base class function and make it a new virtual one. (Which means any member function <code>f8()</code> of class derived from <code>D</code> will be virtual.) (This should be avoid in practice too.)</p></li>\n<li><p>Compare <code>f7()</code> and <code>f9()</code>. We know that <code>override</code> can help us find the error when we want to override a virtual function in derived class while forgot to add key word <code>virtual</code> in base class.</p></li>\n</ol>\n<p><strong>In conclusion</strong>, the best practice in my own view is:</p>\n<ul>\n<li><em>only</em> use <code>virtual</code> in declaration of the <em>first</em> virtual function in base class;</li>\n<li>always use <code>override</code> to specify override virtual function in derived class, unless <code>final</code> is also specified.</li>\n</ul>\n", "LastActivityDate": "2016-02-25T12:04:34.637"}, "29412412": {"CommentCount": "0", "AcceptedAnswerId": "29412622", "PostTypeId": "1", "LastEditorUserId": "3647361", "CreationDate": "2015-04-02T11:58:45.277", "LastActivityDate": "2017-10-05T14:53:50.857", "LastEditDate": "2017-10-05T14:53:50.857", "ViewCount": "5692", "FavoriteCount": "3", "Title": "Does final imply override?", "Id": "29412412", "Score": "29", "Body": "<p>As I understand it, the <code>override</code> keyword states that a given declaration implements a base <code>virtual</code> method, and the compilation should fail if there is no matching base method found.</p>\n<p>My understanding of the <code>final</code> keyword is that it tells the compiler that no class shall override this <code>virtual</code> function.</p>\n<p>So is <code>override final</code> redundant? <a href=\"http://ideone.com/9V7zNx\">It seems to compile fine</a>. What information does <code>override final</code> convey that <code>final</code> does not? What is the use case for such a combination?</p>\n", "Tags": "<c++><override><final><virtual-functions>", "OwnerUserId": "1613983", "AnswerCount": "5"}, "29412516": {"ParentId": "29412412", "CommentCount": "7", "CreationDate": "2015-04-02T12:04:10.547", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "29412516", "Score": "11", "Body": "<p><code>final</code> does not necessarily imply that the function is overridden. It's perfectly valid (if of somewhat dubious value) to declare a virtual function as <code>final</code> on its <em>first</em> declaration in the inheritance hierarchy.</p>\n<p>One reason I can think of to create a virtual and immediately final function is if you want to <em>prevent</em> a derived class from giving the same name &amp; parameters a different meaning.</p>\n", "LastActivityDate": "2015-04-02T12:04:10.547"}, "29412622": {"ParentId": "29412412", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2015-04-02T12:09:14.157", "Score": "28", "LastEditorUserId": "3647361", "LastEditDate": "2015-04-03T12:22:50.730", "Id": "29412622", "OwnerUserId": "3647361", "Body": "<p><code>final</code> does not require the function to override anything in the first place. Its effect is defined in [class.virtual]/4 as</p>\n<blockquote>\n<p id=\"so_29412412_29412622_0\">If a virtual function <code>f</code> in some class <code>B</code> is marked with the\n  <em>virt-specifier</em> <code>final</code> and in a class <code>D</code> derived from <code>B</code> a function <code>D::f</code>\n  overrides <code>B::f</code>, the program is ill-formed.</p>\n</blockquote>\n<p>That's it. Now <code>override final</code> would simply mean<br>\n\u201eThis function overrides a base class one (<code>override</code>) and cannot be overriden itself (<code>final</code>).\u201c<br>\n<code>final</code> on it's own would impose a weaker requirement.\n<code>override</code> and <code>final</code> have independent behavior.</br></br></p>\n<hr>\n<p>Note that <code>final</code> can only be used for virtual functions though - [class.mem]/8</p>\n<blockquote>\n<p id=\"so_29412412_29412622_1\">A <em>virt-specifier-seq</em> shall appear only in the declaration of a\n  virtual member function (10.3).</p>\n</blockquote>\n<p>Hence the declaration</p>\n<pre><code>void foo() final;\n</code></pre>\n<p>Is effectively the same as </p>\n<pre><code>virtual void foo() final override;\n</code></pre>\n<p>Since both require <code>foo</code> to override something - the second declaration by using <code>override</code>, and the first one by being valid if and only if <code>foo</code> is implicitly virtual, i.e. <strong>when <code>foo</code> is overriding a virtual function called <code>foo</code> in a base class, which makes <code>foo</code> in the derived one automatically virtual.</strong>  Thus <code>override</code> would be superfluous in declarations where <code>final</code>, but not <code>virtual</code>, occurs.<br>\nStill, the latter declaration expresses the intent a lot clearer and should definitely be preferred.</br></p>\n</hr>", "LastActivityDate": "2015-04-03T12:22:50.730"}, "bq_ids": {"n4140": {"so_29412412_29412622_1": {"section_id": 5868, "quality": 0.8571428571428571, "length": 6}, "so_29412412_29412622_0": {"section_id": 7005, "quality": 1.0, "length": 12}}, "n3337": {"so_29412412_29412622_1": {"section_id": 5639, "quality": 0.8571428571428571, "length": 6}, "so_29412412_29412622_0": {"section_id": 6751, "quality": 1.0, "length": 12}}, "n4659": {"so_29412412_29412622_1": {"section_id": 7351, "quality": 0.8571428571428571, "length": 6}, "so_29412412_29412622_0": {"section_id": 8502, "quality": 1.0, "length": 12}}}});