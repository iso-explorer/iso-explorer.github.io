post_cb({"bq_ids": {"n4140": {"so_22453001_22453001_0": {"length": 30, "quality": 0.6382978723404256, "section_id": 6088}}, "n3337": {"so_22453001_22453001_0": {"length": 43, "quality": 0.9148936170212766, "section_id": 5856}}, "n4659": {"so_22453001_22453001_0": {"length": 29, "quality": 0.6170212765957447, "section_id": 7584}}}, "22620842": {"Id": "22620842", "PostTypeId": "2", "Body": "<p>It appears that clang++ on Mac OSX does throw bad_alloc, but it also prints an error message from malloc.</p>\n<p>Program:</p>\n<pre><code>// bad_alloc example\n#include &lt;iostream&gt;     // std::cout\n#include &lt;sstream&gt;\n#include &lt;new&gt;          // std::bad_alloc\n\nint main(int argc, char *argv[])\n{\n  unsigned long long memSize = 10000;\n    if (argc &lt; 2)\n        memSize = 10000;\n    else {\n        std::istringstream is(argv[1]); // C++ atoi\n        is &gt;&gt; memSize;\n    }\n  try\n  {\n    int* myarray= new int[memSize];\n    std::cout &lt;&lt; \"alloc of \" &lt;&lt; memSize &lt;&lt; \" succeeded\" &lt;&lt; std::endl;\n  }\n  catch (std::bad_alloc&amp; ba)\n  {\n    std::cerr &lt;&lt; \"bad_alloc caught: \" &lt;&lt; ba.what() &lt;&lt; '\\n';\n  }\n  std::cerr &lt;&lt; \"Program exiting normally\" &lt;&lt; std::endl;\n  return 0;\n}\n</code></pre>\n<p>Mac terminal output:</p>\n<pre><code>david@Godel:~/Dropbox/Projects/Miscellaneous$ badalloc \nalloc of 10000 succeeded\nProgram exiting normally\ndavid@Godel:~/Dropbox/Projects/Miscellaneous$ badalloc 1234567891234567890 \nbadalloc(25154,0x7fff7622b310) malloc: *** mach_vm_map(size=4938271564938272768)\n failed (error code=3)\n*** error: can't allocate region\n*** set a breakpoint in malloc_error_break to debug\nbad_alloc caught: std::bad_alloc\nProgram exiting normally\n</code></pre>\n<p>I also tried the same program using g++ on Windows 7:\n    C:\\Users\\David\\Dropbox\\Projects\\Miscellaneous&gt;g++ -o badallocw badalloc.cpp</p>\n<pre><code>C:\\Users\\David\\Dropbox\\Projects\\Miscellaneous&gt;badallocw\nalloc of 10000 succeeded\n\nC:\\Users\\David\\Dropbox\\Projects\\Miscellaneous&gt;badallocw 1234567890\nbad_alloc caught: std::bad_alloc\n</code></pre>\n<p>Note: The program is a modified version of the example at</p>\n<p><a href=\"http://www.cplusplus.com/reference/new/bad_alloc/\" rel=\"nofollow\">http://www.cplusplus.com/reference/new/bad_alloc/</a></p>\n", "LastActivityDate": "2014-03-24T21:21:26.463", "Score": "0", "CreationDate": "2014-03-24T21:21:26.463", "ParentId": "22453001", "CommentCount": "0", "OwnerUserId": "438085"}, "22453001": {"ViewCount": "812", "Body": "<p>I am having trouble understanding how clang throws exceptions when I try to allocate an object that would exceed its limit. For instance if I compile and run the following bit of code:</p>\n<pre><code>#include &lt;limits&gt;\n#include &lt;new&gt;\n#include &lt;iostream&gt;\n\nint main(int argc, char** argv) {\n    typedef unsigned char byte;\n    byte*gb;\n    try{\n        gb=new byte[std::numeric_limits&lt;std::size_t&gt;::max()];\n    }\n    catch(const std::bad_alloc&amp;){\n        std::cout&lt;&lt;\"Normal\"&lt;&lt;std::endl;\n        return 0;}\n    delete[]gb;\n    std::cout&lt;&lt;\"Abnormal\"&lt;&lt;std::endl;\n    return 1;\n}\n</code></pre>\n<p>then when I compile using <strong>\"clang++ -O0 -std=c++11 main.cpp\"</strong> the result I get is <strong>\"Normal\"</strong> as expected, but as soon as I enable optimizations 1 through 3, the program <em>unexpectedly</em> returns <strong>\"Abnormal\"</strong>.</p>\n<p>I am saying unexpectedly, because according to the C++11 standard 5.3.4.7:</p>\n<blockquote>\n<p id=\"so_22453001_22453001_0\">When the value of the expression in a noptr-new-declarator is zero, the allocation function is called to\n  allocate an array with no elements. If the value of that expression is less than zero <strong>or such that the size\n  of the allocated object would exceed the implementation-defined limit</strong>, or if the new-initializer is a braced-\n  init-list for which the number of initializer-clauses exceeds the number of elements to initialize, no storage\n  is obtained and <strong>the new-expression terminates by throwing an exception of a type that would match a\n  handler (15.3) of type std::bad_array_new_length (18.6.2.2)</strong>.</p>\n</blockquote>\n<p>[This behavior is observed with both clang 3.5 using libstd++ on linux and clang 3.3 using libc++ on Mac. The same behavior is also observed when the -std=c++11 flag is removed.]</p>\n<p>The plot thickens when I compile the same program using <strong>gcc 4.8</strong>, using the exact same command line options. In that case, the program returns <strong>\"Normal\"</strong> for any chosen optimization level.</p>\n<p>I cannot find any undefined behavior in the code posted above that would explain why clang would feel free not to throw an exception when code optimizations are enabled. As far as the bug database is concerned, the closest I can find is <a href=\"http://llvm.org/bugs/show_bug.cgi?id=11644\" rel=\"nofollow\">http://llvm.org/bugs/show_bug.cgi?id=11644</a> but it seems to be related to the type of exception being thrown rather than a behavior difference between debug and release code.</p>\n<p>So it this a bug from Clang? Or am I missing something? Thanks,</p>\n", "AcceptedAnswerId": "22455263", "Title": "Clang fails to throw a std::bad_alloc when allocating objects that would exceed the limit", "CreationDate": "2014-03-17T11:22:26.730", "Id": "22453001", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-09-05T20:04:07.633", "Score": "2", "OwnerUserId": "3428329", "Tags": "<exception><memory-management><c++11><clang>", "AnswerCount": "2"}, "22455263": {"Id": "22455263", "PostTypeId": "2", "Body": "<p>It appears that clang eliminates the allocation as the array is unused:</p>\n<pre><code>#include &lt;limits&gt;\n#include &lt;new&gt;\n#include &lt;iostream&gt;\n\nint main(int argc, char** argv)\n{\n    typedef unsigned char byte;\n    bytes* gb;\n    const size_t max = std::numeric_limits&lt;std::size_t&gt;::max();\n    try\n    {\n        gb = new bytes[max];\n    }\n    catch(const std::bad_alloc&amp;)\n    {\n        std::cout &lt;&lt; \"Normal\" &lt;&lt; std::endl;\n        return 0;\n    }\n    try\n    {\n        gb[0] = 1;\n        gb[max - 1] = 1;\n        std::cout &lt;&lt; gb[0] &lt;&lt; gb[max - 1] &lt;&lt; \"\\n\";\n    }\n    catch ( ... )\n    {\n        std::cout &lt;&lt; \"Exception on access\\n\";\n    }\n    delete [] gb;\n    std::cout &lt;&lt; \"Abnormal\" &lt;&lt; std::endl;\n    return 1;\n}\n</code></pre>\n<p>This code prints <code>\"Normal\"</code> with -O0 and -O3, see <a href=\"http://coliru.stacked-crooked.com/a/cb1c8313f0cfe84c\" rel=\"nofollow\">this demo</a>. That means that in this code, it is actually tried to allocate the memory and it indeed fails, hence we get the exception. Note that if we don't output, clang is still smart enough to even ignore the writes.</p>\n", "LastEditorUserId": "985296", "LastActivityDate": "2015-09-05T20:04:07.633", "Score": "5", "CreationDate": "2014-03-17T13:14:05.547", "ParentId": "22453001", "CommentCount": "2", "LastEditDate": "2015-09-05T20:04:07.633", "OwnerUserId": "985296"}});