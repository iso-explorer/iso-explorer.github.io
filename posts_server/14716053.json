post_cb({"14716053": {"CommentCount": "4", "ViewCount": "1639", "PostTypeId": "1", "LastEditorUserId": "462639", "CreationDate": "2013-02-05T20:11:17.450", "LastActivityDate": "2016-08-01T10:58:26.827", "Title": "Do stl containers use implicit sharing?", "AcceptedAnswerId": "14716174", "LastEditDate": "2016-08-01T10:58:26.827", "Id": "14716053", "Score": "7", "Body": "<p>Its known that Qt widgets use <a href=\"http://doc.qt.io/qt-5/implicit-sharing.html\" rel=\"nofollow\">implicit sharing</a>. So I am interested if stl containers <code>std::vector</code>, <code>std::string</code> use implicit sharing too. </p>\n<p>If no, why? Since it is very useful.</p>\n<p>And if the answer is yes, how we can ascertain in it? I need simple C++ stl program which shows that stl containers use implicit sharing. It doesn't do deep copy when is copied. </p>\n", "Tags": "<c++><stl>", "OwnerUserId": "1356110", "AnswerCount": "3"}, "14716174": {"ParentId": "14716053", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2013-02-05T20:19:44.207", "Score": "10", "LastEditorUserId": "1329652", "LastEditDate": "2014-08-01T16:34:03.880", "Id": "14716174", "OwnerUserId": "277176", "Body": "<p>No. They cannot. When you try to modify the contents of the container, or even calling a mutable <code>begin()</code> on it, it would imply a potential copy-on-write and thus invalidate all references and iterators to the container. This would be a hard to debug situation, and it is prohibited.</p>\n<p>Although <code>std::string</code> is technically not a container, it is still prohibited to do copy-on-write since C++11:</p>\n<blockquote>\n<p id=\"so_14716053_14716174_0\">References, pointers, and iterators referring to the elements of a basic_string sequence may be invalidated by the following uses of that basic_string object:<br>\n  ...<br>\n  \u2014 Calling non-const member functions, <strong>except operator[], at, front, back, begin, rbegin, end, and rend.</strong></br></br></p>\n</blockquote>\n<p>[string.require]</p>\n<blockquote>\n<p id=\"so_14716053_14716174_1\">... Since it is very useful.</p>\n</blockquote>\n<p>Heh, what for? Passing by reference almost always solves all 'performance problems'. Atomic ref-counts are inherently non-scalable on multi-processors machines.</p>\n", "LastActivityDate": "2014-08-01T16:34:03.880"}, "14716570": {"ParentId": "14716053", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2013-02-05T20:43:39.750", "Score": "3", "LastEditorUserId": "450758", "LastEditDate": "2013-02-05T21:06:55.227", "Id": "14716570", "OwnerUserId": "450758", "Body": "<p>Aside from the objections raised by others to CoW behaviour in containers, here are a few more.  These all fall into the category of behaviour that defies convention, and will therefore cause bizarre bugs from unsuspecting developers.   </p>\n<p><strong>Exceptions</strong></p>\n<p>Allowing CoW would means that innocuous mutation operations on a container can fail with exceptions when they wouldn't otherwise.    This would be a particular hazard with <code>operator[]</code> on either a <code>std::vector</code> or <code>std::string</code></p>\n<p><strong>Threading</strong> </p>\n<p>One might reasonable expect to be able to copy construct a container with the express purpose of handing it off to another thread without worrying about concurrency thereafter.  Not so with CoW. </p>\n", "LastActivityDate": "2013-02-05T21:06:55.227"}, "bq_ids": {"n4140": {"so_14716053_14716174_0": {"section_id": 1567, "quality": 1.0, "length": 25}}, "n3337": {"so_14716053_14716174_0": {"section_id": 1562, "quality": 1.0, "length": 25}}, "n4659": {"so_14716053_14716174_0": {"section_id": 1716, "quality": 1.0, "length": 25}}}, "14716099": {"ParentId": "14716053", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2013-02-05T20:15:32.880", "Score": "2", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:25:39.370", "Id": "14716099", "OwnerUserId": "1190430", "Body": "<p>As it's noticed in <a href=\"https://stackoverflow.com/questions/4067395/gnu-stl-string-is-copy-on-write-involved-here\">similar question</a>:</p>\n<blockquote>\n<p id=\"so_14716053_14716099_0\">The C++ standard doesn't prohibit or mandate copy-on-write or any\n  other implementation details for <code>std::string</code>. So long as the semantics\n  and complexity requirements are met an implementation may choose\n  whatever implementation strategy it likes.</p>\n</blockquote>\n<p>I think, same is true for <code>std::vector</code></p>\n<p>Also, you may be interested in this topic: <a href=\"https://stackoverflow.com/questions/1466073/how-is-stdstring-implemented\">How is std::string implemented</a></p>\n", "LastActivityDate": "2013-02-05T20:15:32.880"}});