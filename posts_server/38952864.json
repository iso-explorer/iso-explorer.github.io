post_cb({"bq_ids": {"n4140": {"so_38952864_38952995_0": {"length": 7, "quality": 0.875, "section_id": 5943}, "so_38952864_38953240_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 5943}}, "n3337": {"so_38952864_38952995_0": {"length": 7, "quality": 0.875, "section_id": 5714}, "so_38952864_38953240_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 5714}}, "n4659": {"so_38952864_38952995_0": {"length": 7, "quality": 0.875, "section_id": 7428}, "so_38952864_38953240_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 7428}}}, "38952864": {"ViewCount": "68", "Body": "<p>I have read a bit about floating-point promotion. I know that it doesn't apply on binary arithmetic operations, only on e.g. overload resolution. But why?</p>\n<p>The C++ standard guarantees that double must be at least as precise as float [basic.fundamental.8] and the floating point promotion is required to keep the value unchanged [conv.fpprom]. Yet <a href=\"https://stackoverflow.com/questions/30490592/no-really-when-does-floating-point-promotion-actually-happen\">this question</a> makes it very clear that it does not happen. Stroustrup, 4th edition has the subject even errata-ed (<a href=\"http://www.stroustrup.com/4th_printing3.html\" rel=\"nofollow noreferrer\">here</a>, Chapter 10, p. 267).</p>\n<p>However, I cannot see any reason why the promotion cannot be done in <em>usual arithmetic conversions</em> [expr.10], even if all prerequisites are met. Is there any?</p>\n<p>The latest C++14 working draft can be found <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">here</a>, the final version is purchase-only.</p>\n", "AcceptedAnswerId": "38952995", "Title": "Why cannot floating-point promotion work for arithmetics as well?", "CreationDate": "2016-08-15T09:50:11.260", "Id": "38952864", "CommentCount": "2", "LastEditDate": "2017-05-23T12:22:53.670", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2016-08-15T13:19:24.227", "Score": "0", "OwnerUserId": "1043352", "Tags": "<c++><language-lawyer>", "AnswerCount": "2"}, "38952995": {"Id": "38952995", "PostTypeId": "2", "Body": "<p>Converting a <code>float</code> to a <code>double</code> costs something, and it's likely more expensive than a <code>short</code> to <code>int</code> conversion (it needs several shifts and bit combining operations). And unlike e.g. <code>short</code>, the <code>float</code> type is considered something on which the processor can operate directly (just like it can on <code>int</code>).</p>\n<p>Given the facts obove, why <em>should</em> floating-point promotion happen when it's not necessary? That is, if you're adding two <code>float</code>s, why convert them to <code>double</code>, add them, and then convert them back to <code>float</code>?<sup>(1)</sup></p>\n<p>Note that a floating-point promotion will indeed happen when you're adding mixed arguments (e.g. a <code>float + double</code>), by the very ruling in C++14 [expr] you're referring to.</p>\n<blockquote id=\"so_38952864_38952995_0\">\n<ul>\n<li>(10.3) Otherwise, if either operand is <code>double</code>, the other shall be converted to <code>double</code>.</li>\n</ul>\n</blockquote>\n<p>As per [conv.fpprom], this conversion from <code>float</code> to <code>double</code> is carried out by <em>floating point promotion.</em></p>\n<hr>\n<p><sup>(1)</sup> Of course, it is perfectly possible this will happen internally if the processor cannot operate on <code>float</code>s directly, and [expr].12 explicitly allows that. But that very paragraph says</p>\n<blockquote>\n<p id=\"so_38952864_38952995_1\">the types are not changed thereby.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "1782465", "LastActivityDate": "2016-08-15T13:19:24.227", "Score": "1", "CreationDate": "2016-08-15T09:58:46.793", "ParentId": "38952864", "CommentCount": "3", "LastEditDate": "2016-08-15T13:19:24.227", "OwnerUserId": "1782465"}, "38953240": {"Id": "38953240", "PostTypeId": "2", "Body": "<p><strong>It does!</strong></p>\n<p>I don't know what you call <em>\"work\"</em>, but the scope of definition for <em>floating-point promotion</em> and <em>usual arithmetic conversions</em> is different.</p>\n<ol>\n<li>usual arithmetic conversions :  Apply to binary operators that expect operands of arithmetic or enumeration type.</li>\n<li>floating-point promotion : Apply to prvalues of type float.</li>\n</ol>\n<p>Some expressions, like <code>a + b</code> qualify for both, while <code>1.0f</code> qualify only as a <code>prvalue</code>.</p>\n<p>The standard you linked says (about <code>usual arithmetic conversions</code>)</p>\n<blockquote>\n<p id=\"so_38952864_38953240_0\">(10.3) if either operand is double, the other shall be converted to\n  double\n  <br>...\n  <br>(10.5) \u2014 Otherwise, the <strong>integral</strong> promotions shall be performed on both operands</br></br></p>\n</blockquote>\n<p>It doesn't <strong><em>restrict</em></strong> how the other operand is converted to double, so I would assume that <code>double + float</code> follow the <code>floating-point promotion</code> rule.</p>\n", "LastActivityDate": "2016-08-15T10:16:50.493", "CommentCount": "1", "CreationDate": "2016-08-15T10:16:50.493", "ParentId": "38952864", "Score": "1", "OwnerUserId": "1122645"}});