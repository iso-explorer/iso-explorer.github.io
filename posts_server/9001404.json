post_cb({"9001643": {"ParentId": "9001404", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Not your ToBinary call is ambiguous, its the constructor call of bitset with an unsigned value. Unfortunately this is a VC++ Bug: <a href=\"http://connect.microsoft.com/VisualStudio/feedback/details/532897/problems-constructing-a-bitset-from-an-unsigned-long-in-the-vc-rc\" rel=\"nofollow\">http://connect.microsoft.com/VisualStudio/feedback/details/532897/problems-constructing-a-bitset-from-an-unsigned-long-in-the-vc-rc</a></p>\n<p>Edit - Workaround:</p>\n<pre><code>template&lt;&gt;\nstd::string ToBinary&lt;unsigned int&gt;(const unsigned int&amp; value)\n{\n    const std::bitset&lt;std::numeric_limits&lt;unsigned int&gt;::digits&gt; bs(static_cast&lt;unsigned long long&gt;(value));\n    return bs.to_string();\n}\n</code></pre>\n", "OwnerUserId": "821142", "LastEditorUserId": "821142", "LastEditDate": "2012-01-25T14:34:56.293", "Id": "9001643", "Score": "4", "CreationDate": "2012-01-25T11:05:12.200", "LastActivityDate": "2012-01-25T14:34:56.293"}, "9001693": {"ParentId": "9001404", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Are you using VC10? There is already an issue reported: <a href=\"http://connect.microsoft.com/VisualStudio/feedback/details/532897/problems-constructing-a-bitset-from-an-unsigned-long-in-the-vc-rc\" rel=\"nofollow\">Microsoft connect.</a> Also I'd guess that you might be able to fix it by casting the type to int if it is 32 bit, like this: </p>\n<pre><code>string s = ToBinary(*reinterpret_cast&lt;int*&gt;(&amp;buffer_u[1]));\n</code></pre>\n<p>This can be done inside of the method as well if needed. The result of the reinterpret should not be used for arithmetics anymore, though. ;)</p>\n<p>Works fine as workaround for me (but looks quite ugly)</p>\n<pre><code>template&lt;typename T&gt;\nstd::string ToBinary(const T&amp; value)\n{\n    switch (sizeof(T))\n    {\n    case 8:\n        return std::bitset&lt;std::numeric_limits&lt;T&gt;::digits + 1&gt;(*reinterpret_cast&lt;const long*&gt;(&amp;value)).to_string();\n    case 4:\n        return std::bitset&lt;std::numeric_limits&lt;T&gt;::digits + 1&gt;(*reinterpret_cast&lt;const int*&gt;(&amp;value)).to_string();\n    case 2:\n        return std::bitset&lt;std::numeric_limits&lt;T&gt;::digits + 1&gt;(*reinterpret_cast&lt;const short*&gt;(&amp;value)).to_string();\n    case 1:\n        return std::bitset&lt;std::numeric_limits&lt;T&gt;::digits + 1&gt;(*reinterpret_cast&lt;const char*&gt;(&amp;value)).to_string();\n    }\n    return \"n/a\";\n}\n</code></pre>\n", "OwnerUserId": "1127686", "LastEditorUserId": "1127686", "LastEditDate": "2012-01-25T14:15:55.437", "Id": "9001693", "Score": "0", "CreationDate": "2012-01-25T11:08:56.067", "LastActivityDate": "2012-01-25T14:15:55.437"}, "9001698": {"ParentId": "9001404", "CommentCount": "1", "Body": "<p>If you look at the standard (FDIS n3290), then you see that <code>std::bitset</code> has multiple constructors:</p>\n<p>First there is this one:</p>\n<p><strong>20.5.1 bitset constructors [bitset.cons]</strong> </p>\n<blockquote>\n<p id=\"so_9001404_9001698_0\"><code>constexpr bitset(unsigned long long val) noexcept;</code></p>\n<p id=\"so_9001404_9001698_1\">Effects: Constructs an object of class bitset, initializing the\n  first M bit positions to the corresponding bit values in val. M is the\n  smaller of N and the number of bits in the value representation (3.9)\n  of unsigned long long. If M &lt; N, the remaining bit positions are\n  initialized to zero.</p>\n</blockquote>\n<p>Then there is also this one, which I suspect might be might cause things to become ambigious, when you call it with <code>unsigned int</code> </p>\n<blockquote>\n<pre><code>template &lt;class charT&gt;\nexplicit bitset(\nconst charT* str,\ntypename basic_string&lt;charT&gt;::size_type n = basic_string&lt;charT&gt;::npos,\ncharT zero = charT(\u20190\u2019), charT one = charT(\u20191\u2019));\n</code></pre>\n<p id=\"so_9001404_9001698_2\">Effects: Constructs an object of class bitset as if by</p>\n<pre><code>bitset( n == basic_string&lt;charT&gt;::npos ? basic_string&lt;charT&gt;(str) :\nbasic_string&lt;charT&gt;(str, n), 0, n, zero, one)\n</code></pre>\n</blockquote>\n", "OwnerUserId": "174614", "PostTypeId": "2", "Id": "9001698", "Score": "0", "CreationDate": "2012-01-25T11:09:05.187", "LastActivityDate": "2012-01-25T11:09:05.187"}, "bq_ids": {"n4140": {"so_9001404_9001698_1": {"section_id": 4114, "quality": 0.9230769230769231, "length": 24}, "so_9001404_9001698_0": {"section_id": 4113, "quality": 1.0, "length": 6}}, "n3337": {"so_9001404_9001698_1": {"section_id": 3957, "quality": 0.9230769230769231, "length": 24}, "so_9001404_9001698_0": {"section_id": 3956, "quality": 1.0, "length": 6}}, "n4659": {"so_9001404_9001698_1": {"section_id": 5379, "quality": 0.9230769230769231, "length": 24}, "so_9001404_9001698_0": {"section_id": 5378, "quality": 1.0, "length": 6}}}, "9001404": {"CommentCount": "1", "AcceptedAnswerId": "9001643", "PostTypeId": "1", "LastEditorUserId": "587884", "CreationDate": "2012-01-25T10:47:27.940", "LastActivityDate": "2012-01-25T14:34:56.293", "LastEditDate": "2012-01-25T11:58:31.503", "ViewCount": "559", "FavoriteCount": "0", "Title": "C++ limit of unsigned int through template", "Id": "9001404", "Score": "6", "Body": "<p>I'm using a template to convert integral types into a string representation of their binary values. I used the following:</p>\n<pre><code>template&lt;typename T&gt;\nstd::string ToBinary(const T&amp; value)\n{\n    const std::bitset&lt;std::numeric_limits&lt;T&gt;::digits + 1&gt; bs(value);\n    const std::string s(bs.to_string());\n\n    return s;\n}\n</code></pre>\n<p>It works for int but doesn't compile with unsigned int :</p>\n<pre><code>unsigned int buffer_u[10];\nint buffer_i[10];\n...\nToBinary(buffer_i[1]); //compile and works\nToBinary(buffer_u[1]); //doesn't compile -- ambiguous overload\n</code></pre>\n<p>Could you explain why?</p>\n<p>EDIT:</p>\n<p>Yes, I'm using VS2010</p>\n", "Tags": "<c++><templates><stl><binary><limits>", "OwnerUserId": "587884", "AnswerCount": "3"}});