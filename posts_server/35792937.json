post_cb({"bq_ids": {"n4140": {"so_35792937_35834427_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 5908}}, "n3337": {"so_35792937_35834427_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 5680}}, "n4659": {"so_35792937_35834427_0": {"length": 19, "quality": 0.8636363636363636, "section_id": 7390}}}, "35834427": {"Id": "35834427", "PostTypeId": "2", "Body": "<p>GCC is of course wrong to complain about the name being undeclared, since the point of declaration of <code>i</code> is <a href=\"http://eel.is/c++draft/basic.scope.pdecl#1\" rel=\"nofollow\">immediately after its declarator</a>. </p>\n<p>However, GCC is arguably right in rejecting the snippet overall. <a href=\"http://eel.is/c++draft/class.static.data#3\" rel=\"nofollow\">[class.static.data]/3</a>:</p>\n<blockquote>\n<p id=\"so_35792937_35834427_0\">If a non-volatile <code>const</code> static data member is of integral or\n  enumeration type, its declaration in the class definition can specify\n  a <em>brace-or-equal-initializer</em> <strong>in which every <em>initializer-clause</em>\n  that is an <em>assignment- expression</em> is a constant expression (5.20).</strong></p>\n</blockquote>\n<p>And for <a href=\"http://eel.is/c++draft/expr.const#2\" rel=\"nofollow\">[expr.const]/(2.7)</a> not to fail, one of its four sub bullets must apply:</p>\n<blockquote>\n<p id=\"so_35792937_35834427_1\">an lvalue-to-rvalue conversion (4.1) unless it is applied to</p>\n<ul>\n<li>a non-volatile glvalue of integral or enumeration type that refers to a complete non-volatile <code>const</code> object <strong>with a preceding\n  initialization, initialized with a constant expression</strong>, or </li>\n<li>a non-volatile glvalue that refers to a subobject of a string literal (2.13.5), or</li>\n<li>a non-volatile glvalue that refers to a non-volatile object defined with <code>constexpr</code>, or that refers to a non-mutable sub-object of such an\n  object, or</li>\n<li>a non-volatile glvalue of literal type that refers to a non-volatile object whose lifetime began within the evaluation of <code>e</code>;</li>\n</ul>\n</blockquote>\n<p>(2.7.1) is the only plausible candidate, but since <code>i</code> has not previously been initialized <em>using an initializer</em>, it doesn't apply.</p>\n<p>Note that Clang is <a href=\"http://melpon.org/wandbox/permlink/vbiji6NCSRhSS9IQ\" rel=\"nofollow\">completely consistent</a>:</p>\n<pre><code>constexpr int i = i;\nvoid f() {\n    // constexpr int j = j; // error\n    static constexpr int h = h;\n}\n</code></pre>\n<p>It appears that it treats <code>i</code> as \"properly\" initialized in its initializer if it has static storage duration. I filed bug <a href=\"https://llvm.org/bugs/show_bug.cgi?id=26858\" rel=\"nofollow\">#26858</a>.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-07T00:42:27.263", "Score": "4", "CreationDate": "2016-03-07T00:35:46.497", "ParentId": "35792937", "CommentCount": "0", "LastEditDate": "2016-03-07T00:42:27.263", "OwnerUserId": "3647361"}, "35792937": {"ViewCount": "174", "Body": "<p>Consider the following piece of code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct Foo {\n  static int const i = i + 1;\n};\n\nint main() {\n  std::cout &lt;&lt; Foo::i &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Clang version 3.7 compiles this and outputs <code>1</code>.</p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/8027d91d764502e4\" rel=\"noreferrer\"><strong>Live Demo</strong></a></p>\n<p>While GCC version 5.3 emits an error:</p>\n<blockquote>\n<p id=\"so_35792937_35792937_0\"><em>error: 'i' was not declared in this scope</em></p>\n</blockquote>\n<p><a href=\"http://coliru.stacked-crooked.com/a/bbb375ffc625f01e\" rel=\"noreferrer\"><strong>Live Demo</strong></a></p>\n<h2>Q:</h2>\n<p>Which one of the two compilers conforms to the C++ standard?</p>\n", "AcceptedAnswerId": "35834427", "Title": "In class nested static const member variable initialization Clang vs GCC which compiler is right?", "CreationDate": "2016-03-04T09:55:11.723", "Id": "35792937", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2016-03-07T00:42:27.263", "Score": "9", "OwnerUserId": "2352671", "Tags": "<c++><gcc><clang><language-lawyer><static-members>", "AnswerCount": "2"}, "35793758": {"Id": "35793758", "PostTypeId": "2", "Body": "<p>A static const member initialized in-class must be initialized by a constant expression. In the initializer of <code>i</code>, <code>i</code> is not initialized by a constant expression (yet) and so is not a constant expression itself. In my view both compilers are guilty.</p>\n<ul>\n<li>clang, for accepting the program</li>\n<li>gcc, for giving a misleading error message</li>\n</ul>\n", "LastActivityDate": "2016-03-04T10:32:10.210", "Score": "2", "CreationDate": "2016-03-04T10:32:10.210", "ParentId": "35792937", "CommentCount": "2", "OwnerUserId": "775806"}});