post_cb({"25949243": {"ParentId": "25949100", "LastEditDate": "2014-09-20T13:28:29.850", "CommentCount": "0", "CreationDate": "2014-09-20T13:22:28.230", "OwnerUserId": "1938163", "LastEditorUserId": "1938163", "PostTypeId": "2", "Id": "25949243", "Score": "6", "Body": "<p>First of all the code you posted is invalid: you should declare that structure type as follows</p>\n<pre><code>struct s_t {\n  int     iMyInt;\n  char    cMyChar;\n  double  dCoordinates[128];\n};\n</code></pre>\n<p>That said: in your specific case the two approaches are the same and everything is zeroe'd out. At <code>-O3</code> and even <code>-O0</code> for clang <strong>there are no differences</strong> for a generic test code which uses any of the above members and/or array elements (at <code>-O0</code> it even calls <code>memset</code> on the entire structure in both cases).</p>\n<pre><code>s_t obj = {0};\n\nmovq    %rcx, %rdi\nmovl    %eax, %esi\ncallq   memset\n\ns_t obj = {};\n\nmovq    %rcx, %rdi\nmovl    %eax, %esi\ncallq   memset\n</code></pre>\n", "LastActivityDate": "2014-09-20T13:28:29.850"}, "25949100": {"CommentCount": "9", "ViewCount": "130", "PostTypeId": "1", "LastEditorUserId": "661519", "CreationDate": "2014-09-20T13:06:03.133", "LastActivityDate": "2014-09-20T14:47:15.507", "Title": "C++ - Efficient approach to initializing structure", "AcceptedAnswerId": "25949243", "LastEditDate": "2014-09-20T14:22:24.497", "Id": "25949100", "Score": "3", "Body": "<p>A colleague and I were debating the efficiency of certain approaches to zero'ing out a <code>struct</code>. Let's assume we have a simple <code>struct</code> like so:</p>\n<pre><code>struct {\n  int     iMyInt;\n  char    cMyChar;\n  double  dCoordinates[128];\n} s_t;\n</code></pre>\n<p>My approach would be to do this:</p>\n<pre><code>s_t myStruct = { 0 };\n</code></pre>\n<p>My colleague advised this approach instead:</p>\n<pre><code>s_t myStruct = { };\n</code></pre>\n<p>He noted that my approach initializes a single element, and then the rest of the elements, in a two-part operation, while his approach initializes the entire <code>struct</code> in a one-part operation that is faster and more efficient. </p>\n<p>Is this true, and if so, is it always the case across all compiler optimization levels (ie: does the compiler figure this out and optimize it for me anyways)?</p>\n<p>Thank you.</p>\n", "Tags": "<c++><initialization>", "OwnerUserId": "1022889", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_25949100_25949900_0": {"section_id": 3304, "quality": 1.0, "length": 17}, "so_25949100_25949900_1": {"section_id": 3325, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_25949100_25949900_0": {"section_id": 3174, "quality": 1.0, "length": 17}, "so_25949100_25949900_1": {"section_id": 3195, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_25949100_25949900_0": {"section_id": 4070, "quality": 0.8823529411764706, "length": 15}, "so_25949100_25949900_1": {"section_id": 4091, "quality": 0.8888888888888888, "length": 8}}}, "25949900": {"ParentId": "25949100", "LastEditDate": "2014-09-20T14:47:15.507", "CommentCount": "4", "CreationDate": "2014-09-20T14:39:41.273", "OwnerUserId": "464581", "LastEditorUserId": "464581", "PostTypeId": "2", "Id": "25949900", "Score": "1", "Body": "<p>C++11 \u00a78.5.1/7:</p>\n<blockquote>\n<p id=\"so_25949100_25949900_0\"><strong>\u201c</strong> If there are fewer initializer-clauses in the list than there are members in the aggregate, then each member\n  not explicitly initialized shall be initialized from an empty initializer list</p>\n</blockquote>\n<p>And last dash of C++11 \u00a78.5.4/3:</p>\n<blockquote>\n<p id=\"so_25949100_25949900_1\"><strong>\u201c</strong>  Otherwise [<em>i.e. T is not a class, not an aggregate, and not a reference</em>], if the initializer list has no elements, the object is value-initialized.</p>\n</blockquote>\n<p>Value-initialized for a simple type like <code>int</code> means zero-initialized.</p>\n<p>So the formal effect of <code>{0}</code>, for a type that has <code>0</code> value, is the same as the formal effect of <code>{}</code>.</p>\n<p>The standard can however not dictate the <strong>Quality of Implementation</strong> of a compiler. A compiler might react to what it considers bad words in a file name, and just to spite you generate time consuming dummy code before each function call. Likewise it just might, in theory, treat the two notations differently wrt. code generation, even though they mean the same.</p>\n<hr>\n<p>Re your colleague\u2019s idea that</p>\n<blockquote>\n<p id=\"so_25949100_25949900_2\"><strong>\u201c</strong> He noted that my approach initializes a single element, and then the rest of the elements, in a two-part operation, while his approach initializes the entire struct in a one-part operation that is faster and more efficient. </p>\n</blockquote>\n<p>No, that\u2019s just an incorrect vision of how a compiler might work.</p>\n<p>Compilers don\u2019t work that way.</p>\n<p>But the empty braces notation has the advantage that it also works with e.g. <code>std::string</code> and any other type <code>T</code> where <code>T()</code> is a valid expression, but <code>T(0)</code> is not.</p>\n<p>I.e. it\u2019s slightly more general.</p>\n<hr>\n<p>All this said, note that in C++ it\u2019s not necessary to do the C acrobatics</p>\n<pre><code>typedef struct Point_tag\n{\n    int x, y;\n} Point;\n</code></pre>\n<p>Instead you can simply do</p>\n<pre><code>struct Point\n{\n    int x, y;\n};\n</code></pre>\n</hr></hr>", "LastActivityDate": "2014-09-20T14:47:15.507"}});