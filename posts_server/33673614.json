post_cb({"bq_ids": {"n4140": {"so_33673614_36058677_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 224}, "so_33673614_36058677_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 224}, "so_33673614_36058677_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 224}, "so_33673614_36058677_3": {"length": 36, "quality": 1.0, "section_id": 224}}, "n3337": {"so_33673614_36058677_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 217}, "so_33673614_36058677_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 217}, "so_33673614_36058677_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 217}, "so_33673614_36058677_3": {"length": 36, "quality": 1.0, "section_id": 217}}, "n4659": {"so_33673614_36058677_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 232}, "so_33673614_36058677_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 232}, "so_33673614_36058677_1": {"length": 12, "quality": 0.8571428571428571, "section_id": 232}, "so_33673614_36058677_3": {"length": 36, "quality": 1.0, "section_id": 232}}}, "33673614": {"ViewCount": "76", "Body": "<p>Consider the code below:</p>\n<pre><code>#include &lt;utility&gt;\n\nvoid f(int, int);\nvoid g(int, int);\n\nstruct functor\n{\n    template&lt;typename... T&gt;\n    void operator()(T&amp;&amp;... params)\n    {\n        return f(std::forward&lt;T&gt;(params)...);\n    }\n};\n\nint main()\n{\n    functor()(1); // can use the default value here, why?!\n    // g(1); // error here as expected, too few arguments\n}\n\nvoid f(int a, int b = 42) {}\n\nvoid g(int a, int b = 24) {}\n</code></pre>\n<p>This is a thin wrapper around a function call. However, inside <code>functor::operator()</code>, <code>f</code> doesn't have its default value for the second parameter known (it is visible only after <code>main</code>, in the definition), so the code should not compile. g++5.2 compiles it successfully though, but clang++ spits out the expected message that one expects for compilers that perform the two-phase name lookup correctly:</p>\n<blockquote>\n<p id=\"so_33673614_33673614_0\">error: call to function 'f' that is neither visible in the\n        template definition nor found by argument-dependent lookup\n          return f(std::forward(params)...);</p>\n</blockquote>\n<p>Is this a gcc bug or I am missing something here? I.e., is the point of instantiation after the definition of <code>f</code> below <code>main()</code>? But even in this case, it shouldn't work, as at the second phase the function can only be found via ADL, which is not the case here.</p>\n", "AcceptedAnswerId": "36058677", "Title": "Default function parameter value visible in template but it shouldn't (gcc)", "CreationDate": "2015-11-12T14:20:49.000", "Id": "33673614", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-03-17T11:04:04.830", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-17T12:57:31.887", "Score": "6", "OwnerUserId": "3093378", "Tags": "<c++><g++><language-lawyer>", "AnswerCount": "1"}, "36058677": {"Id": "36058677", "PostTypeId": "2", "Body": "<p><a href=\"http://eel.is/c++draft/temp.dep.candidate\" rel=\"nofollow\">[temp.dep.candidate]</a>: </p>\n<blockquote>\n<p id=\"so_33673614_36058677_0\">For a function call where the <em>postfix-expression</em> is a dependent name, the candidate functions are found using the usual lookup rules ([basic.lookup.unqual], [basic.lookup.argdep]) except that:</p>\n<ul>\n<li><p id=\"so_33673614_36058677_1\">For the part of the lookup using unqualified name lookup ([basic.lookup.unqual]), only function declarations from the template definition context are found.</p></li>\n<li><p id=\"so_33673614_36058677_2\">For the part of the lookup using associated namespaces ([basic.lookup.argdep]), only function declarations found in either the template definition context or the template instantiation context are found.</p></li>\n</ul>\n<p id=\"so_33673614_36058677_3\"><strong>If the call</strong> would be ill-formed or <strong>would find a better match had the lookup within the associated namespaces\n  considered all the function declarations with external linkage introduced in those namespaces in all translation units, not just considering those declarations found in the template definition and template instantiation\n  contexts, then the program has undefined behavior.</strong></p>\n</blockquote>\n<p>Note that ADL is not even working here, as the involved types are fundamental (their set of associated namespaces is empty). </p>\n", "LastEditorUserId": "3093378", "LastActivityDate": "2016-03-17T12:57:31.887", "Score": "1", "CreationDate": "2016-03-17T11:03:11.220", "ParentId": "33673614", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2016-03-17T12:57:31.887"}});