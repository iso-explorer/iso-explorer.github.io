post_cb({"27679594": {"ParentId": "27678981", "CommentCount": "1", "Body": "<p>As already answered your SFINAE scheme can't work. However, you could use the following not so pretty solution to achieve what you probably want:</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;type_traits&gt;\n#include &lt;iostream&gt;\n\nclass A{};\nclass B{};\nclass C{};\nclass D{};\nclass collection1 : A, B, C {};\nclass collection2 : D {};\n\ntemplate&lt;typename X, class Enable = void&gt;\nstruct enable_if_is_base_of;\n\ntemplate&lt;typename X&gt;\nstruct enable_if_is_base_of&lt;X, typename std::enable_if&lt;std::is_base_of&lt;X, collection1&gt;::value&gt;::type&gt; {\n  static X fn(X x) {\n    (void) x;\n    std::cout &lt;&lt; \"collection1\" &lt;&lt; std::endl;\n    return X();\n  }\n};\n\ntemplate&lt;typename X&gt;\nstruct enable_if_is_base_of&lt;X, typename std::enable_if&lt;std::is_base_of&lt;X, collection2&gt;::value&gt;::type&gt; {\n  static X fn(X x) {\n    (void) x;\n    std::cout &lt;&lt; \"collection2\" &lt;&lt; std::endl;\n    return X();\n  }\n};\n\nint main() {\n  enable_if_is_base_of&lt;A&gt;::fn(A());\n  enable_if_is_base_of&lt;B&gt;::fn(B());\n  enable_if_is_base_of&lt;C&gt;::fn(C());\n  enable_if_is_base_of&lt;D&gt;::fn(D());\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/7871805b4a0aa508\" rel=\"nofollow\"><strong>LIVE DEMO</strong></a></p>\n", "OwnerUserId": "2352671", "PostTypeId": "2", "Id": "27679594", "Score": "2", "CreationDate": "2014-12-28T18:59:39.087", "LastActivityDate": "2014-12-28T18:59:39.087"}, "27679895": {"ParentId": "27678981", "CommentCount": "5", "Body": "<p>The problem is that if the type doesn't exist, the typedef isn't skipped, it is an error.</p>\n<p>Solution: no typedef</p>\n<pre><code>template&lt;typename X, typename COLLECTION&gt;\nstruct enable_if_is_base_of : std::enable_if&lt;std::is_base_of&lt;X, COLLECTION&gt;::value, X&gt;\n{};\n</code></pre>\n<p>Now the <code>type</code> member exists (via inheritance) if and only if it exists within the <code>enable_if</code> instantiation.</p>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "27679895", "Score": "2", "CreationDate": "2014-12-28T19:32:08.860", "LastActivityDate": "2014-12-28T19:32:08.860"}, "bq_ids": {"n4140": {"so_27678981_27679361_0": {"section_id": 300, "quality": 0.9, "length": 45}, "so_27678981_27679361_1": {"section_id": 233, "quality": 0.9, "length": 27}}, "n3337": {"so_27678981_27679361_0": {"section_id": 291, "quality": 0.9, "length": 45}, "so_27678981_27679361_1": {"section_id": 226, "quality": 0.9, "length": 27}}, "n4659": {"so_27678981_27679361_0": {"section_id": 307, "quality": 0.82, "length": 41}, "so_27678981_27679361_1": {"section_id": 242, "quality": 0.9, "length": 27}}}, "27679361": {"ParentId": "27678981", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Only a substitution that takes place in an <em>immediate context</em> may result in a deduction failure:</p>\n<p>\u00a714.8.2 [temp.deduct]/p8</p>\n<blockquote>\n<p id=\"so_27678981_27679361_0\">Only invalid types and expressions in the immediate context of the function type and\n  its template parameter types can result in a deduction failure. [ <em>Note</em>: The evaluation of the substituted types\n  and expressions can result in side effects <strong>such as the instantiation of class template specializations</strong> and/or\n  function template specializations, the generation of implicitly-defined functions, etc. <strong>Such side effects are\n  not in the \u201cimmediate context\u201d and can result in the program being ill-formed.</strong> \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>The signature of <code>fn</code> requires a full declaration of <code>enable_if_is_base</code>'s specialization to exist:</p>\n<p>\u00a714.7.1 [temp.inst]/p1</p>\n<blockquote>\n<p id=\"so_27678981_27679361_1\">Unless a class template specialization has been explicitly instantiated (14.7.2) or explicitly specialized (14.7.3),\n  the class template specialization is implicitly instantiated when the specialization is referenced in a context\n  that requires a completely-defined object type or when the completeness of the class type affects the semantics\n  of the program.</p>\n</blockquote>\n<p>The compiler fails to generate the specialization of:</p>\n<pre><code>template&lt;typename X, typename COLLECTION&gt;\nstruct enable_if_is_base_of\n{\n    static const int value = std::is_base_of&lt;X, COLLECTION&gt;::value;\n    typedef typename std::enable_if&lt;value, X&gt;::type type;\n};\n</code></pre>\n<p>because the substitution of <code>typename std::enable_if&lt;value, X&gt;::type</code> results in a missing type if <code>value</code> evaluates to <code>false</code>, which is not in an immediate context.</p>\n", "OwnerUserId": "3953764", "LastEditorUserId": "3953764", "LastEditDate": "2014-12-28T18:39:42.883", "Id": "27679361", "Score": "8", "CreationDate": "2014-12-28T18:31:11.043", "LastActivityDate": "2014-12-28T18:39:42.883"}, "27678981": {"CommentCount": "1", "ViewCount": "458", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-12-28T17:46:32.950", "LastActivityDate": "2014-12-28T19:32:08.860", "Title": "Does SFINAE not apply here?", "AcceptedAnswerId": "27679361", "LastEditDate": "2017-05-23T11:57:53.830", "Id": "27678981", "Score": "3", "Body": "<p>I was writing something to use SFINAE to not generate a function under certain conditions.  When I use the meta code directly it works as expected, but when I use the code indirectly through another class, it fails to work as expected.</p>\n<p>I thought that this was a VC++ thing, but looks like g++ also has this, so I'm wondering if there's some reason that SFINAE isn't being applied to this case.</p>\n<p>The code is simple.  If the class used isn't the base class of a \"collection class\", then don't generate the function.</p>\n<pre><code>#include &lt;algorithm&gt;\n#include &lt;type_traits&gt;\n\n#define USE_DIRECT 0\n#define ENABLE 1\n\nclass A{};\nclass B{};\nclass C{};\nclass D{};\nclass collection1 : A, B, C {};\nclass collection2 : D {};\n\n#if USE_DIRECT\ntemplate&lt;typename X&gt;\ntypename std::enable_if&lt;std::is_base_of&lt;X, collection1&gt;::value, X&gt;::type fn(X x)\n{\n    return X();\n}\n\n# if ENABLE\ntemplate&lt;typename X&gt;\ntypename std::enable_if&lt;std::is_base_of&lt;X, collection2&gt;::value, X&gt;::type fn(X x)\n{\n    return X();\n}\n# endif\n\n#else // USE_DIRECT\n\ntemplate&lt;typename X, typename COLLECTION&gt;\nstruct enable_if_is_base_of\n{\n    static const int value = std::is_base_of&lt;X, COLLECTION&gt;::value;\n    typedef typename std::enable_if&lt;value, X&gt;::type type;\n};\n\ntemplate&lt;typename X&gt;\ntypename enable_if_is_base_of&lt;X, collection1&gt;::type fn(X x)\n{\n    return X();\n}\n\n# if ENABLE\ntemplate&lt;typename X&gt;\ntypename enable_if_is_base_of&lt;X, collection2&gt;::type fn(X x)\n{\n    return X();\n}\n# endif\n#endif // USE_DIRECT\n\nint main()\n{\n    fn(A());\n    fn(B());\n    fn(C());\n    fn(D());\n\n   return 0;\n}\n</code></pre>\n<p>If I set USE_DIRECT to 1 and ENABLE to 0, then it fails to compile as there is no function <code>fn</code> that takes a parameter <code>D</code>.  Setting ENABLE to 1 will stop that error from occurring.</p>\n<p>However, if I set USE_DIRECT to 0 and ENABLE to 0, it will fail with different error messages but for the same case, there is no <code>fn</code> that takes parameter <code>D</code>. Setting ENABLE to 1 however will cause a failure for all 4 function calls.</p>\n<p>For your convience, here is the code in an online compiler: <a href=\"http://goo.gl/CQcXHr\" rel=\"nofollow noreferrer\">http://goo.gl/CQcXHr</a></p>\n<p>Can someone explain what is happening here and why?</p>\n<p>This looks like it may be related to <a href=\"https://stackoverflow.com/questions/19378749/alias-templates-used-in-sfinae-lead-to-a-hard-error\">Alias templates used in SFINAE lead to a hard error</a>, but no one has answered that either.</p>\n<p>For reference, here are the errors that were generated by g++:</p>\n<pre><code>main.cpp: In instantiation of 'struct enable_if_is_base_of&lt;A, collection2&gt;':                                                                   \nmain.cpp:45:53:   required by substitution of 'template&lt;class X&gt; typename enable_if_is_base_of&lt;X, collection2&gt;::type fn(X) [with X = A]'       \nmain.cpp:54:8:   required from here                                                                                                            \nmain.cpp:34:82: error: no type named 'type' in 'struct std::enable_if&lt;false, A&gt;'                                                               \n  typedef typename std::enable_if&lt;std::is_base_of&lt;X, COLLECTION&gt;::value, X&gt;::type type;                                                        \n                                                                                  ^                                                            \nmain.cpp: In instantiation of 'struct enable_if_is_base_of&lt;B, collection2&gt;':                                                                   \nmain.cpp:45:53:   required by substitution of 'template&lt;class X&gt; typename enable_if_is_base_of&lt;X, collection2&gt;::type fn(X) [with X = B]'       \nmain.cpp:55:8:   required from here                                                                                                            \nmain.cpp:34:82: error: no type named 'type' in 'struct std::enable_if&lt;false, B&gt;'                                                               \nmain.cpp: In instantiation of 'struct enable_if_is_base_of&lt;C, collection2&gt;':                                                                   \nmain.cpp:45:53:   required by substitution of 'template&lt;class X&gt; typename enable_if_is_base_of&lt;X, collection2&gt;::type fn(X) [with X = C]'       \nmain.cpp:56:8:   required from here                                                                                                            \nmain.cpp:34:82: error: no type named 'type' in 'struct std::enable_if&lt;false, C&gt;'                                                               \nmain.cpp: In instantiation of 'struct enable_if_is_base_of&lt;D, collection1&gt;':                                                                   \nmain.cpp:38:53:   required by substitution of 'template&lt;class X&gt; typename enable_if_is_base_of&lt;X, collection1&gt;::type fn(X) [with X = D]'       \nmain.cpp:57:8:   required from here                                                                                                            \nmain.cpp:34:82: error: no type named 'type' in 'struct std::enable_if&lt;false, D&gt;'                                                               \n</code></pre>\n", "Tags": "<c++><c++11><sfinae>", "OwnerUserId": "1366368", "AnswerCount": "3"}});