post_cb({"31058023": {"ParentId": "30831567", "PostTypeId": "2", "CommentCount": "10", "CreationDate": "2015-06-25T18:27:40.970", "Score": "-1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:15:00.400", "Id": "31058023", "OwnerUserId": "3306395", "Body": "<p>My previous answer thought that the problem with the code was that the std::chrono_literals objects were not valid as <code>constexp</code>s, but as pointed out by Lightspeed, this is not the case.</p>\n<p>I did a little more research and determined that the problem line with your code is your <code>struct t</code>: specifically this line:</p>\n<pre><code>static constexp auto ...\n</code></pre>\n<p>There is another answer on SO about this <a href=\"https://stackoverflow.com/questions/24018932/static-constexpr-auto-data-member-initialized-with-unnamed-enum\">here</a></p>\n<p>To explicitly point out why this is your issue (as the comment indicates this is not immediately obvious):</p>\n<p>Any expression labeled <code>constexp</code> is to be determined at compile-time. This much you know already. When you try and instantiate with the <code>decltype(T::dur_1) T:dur_1</code> expression, in your eyes you are providing the proper credentials to the chrono literal constructor (which is <code>constexp</code>). The issue is that the type is not explicitly defined as you seem to think it is from your pre-processor definition of the <code>DUR</code> replacement of 1000ms.</p>\n<p>Try the following:</p>\n<pre><code>template &lt;class T&gt;\nstruct foo {\n    static constexpr auto dur_1 = DUR;\n    typedef decltype(DUR) milliseconds;\n}\n\ntemplate &lt;class T&gt;\nconstexp milliseconds foo&lt;T&gt;::milliseconds foo&lt;T&gt;::DUR; \n</code></pre>\n<p>By removing the inability of the GCC compiler to determine the auto type at compile time through the explicit definition, you should solve your problem.</p>\n<p>This is why the original link was given. GCC is incorrectly unable to determine the auto-typing at compile time.</p>\n", "LastActivityDate": "2015-06-25T19:30:38.510"}, "31058937": {"ParentId": "30831567", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-06-25T19:16:53.107", "Score": "2", "LastEditorUserId": "1708801", "LastEditDate": "2015-10-15T14:59:08.127", "Id": "31058937", "OwnerUserId": "1708801", "Body": "<p>This looks underspecified to me, I don't see an explicit requirement but we can see why it is an issue from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3027.html#699\" rel=\"nofollow\">defect report 699:  Must constexpr member functions be defined in the class member-specification? </a> which although dealing with constexpr member functions says the following (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_30831567_31058937_0\">If the prohibition were relaxed to allow separate declaration and\n  definition of constexpr member functions, some questions would need to\n  be answered, such as whether the constexpr specifier must appear on\n  both declaration and definition (the inline specifier need not). If it\n  can be omitted in one or the other, <strong>there's a usability issue\n  regarding the fact that constexpr implies const; the const qualifier\n  would need to be specified explicitly in the declaration in which\n  constexpr was omitted.</strong></p>\n</blockquote>\n<p>Although in this case adding <code>const</code> does not solve the problem although in a simpler cases it does seem to solve the issue. We can see in a simpler case both clang and gcc require either const or constexpr:</p>\n<pre><code>struct T\n{\n   static constexpr int blah = 1 ;\n};\n\nconst int T::blah ;\n</code></pre>\n<p><b>Update</b></p>\n<p>This gcc bug report: <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58541\" rel=\"nofollow\"> Bogus \"error: redeclaration ... differs in \u2018constexpr\u2019\"</a> has the following quote from Richard Smith:</p>\n<blockquote>\n<p id=\"so_30831567_31058937_1\">There is no rule requiring successive declarations of variables to\n  agree in 'constexpr'ness (this rule only applies to functions).</p>\n</blockquote>\n<p>So this looks like a gcc bug, although it still seems like it could use some clarity in the standard.</p>\n", "LastActivityDate": "2015-10-15T14:59:08.127"}, "30831567": {"CommentCount": "4", "AcceptedAnswerId": "31058937", "CreationDate": "2015-06-14T16:05:55.417", "LastActivityDate": "2015-10-15T14:59:08.127", "PostTypeId": "1", "ViewCount": "1056", "FavoriteCount": "3", "Title": "Why does GCC think that the definition of a constexpr static data member must be marked constexpr?", "Id": "30831567", "Score": "24", "Body": "<blockquote>\n<p id=\"so_30831567_30831567_0\"><code>[C++14: 7.1.5/1]:</code> The <code>constexpr</code> specifier shall be applied only to the definition of a variable or variable template, the declaration of a function or function template, or the declaration of a static data member of a literal type (3.9). If any declaration of a function, function template, or variable template has a <code>constexpr</code> specifier, then all its declarations shall contain the <code>constexpr</code> specifier. <em>[..]</em></p>\n</blockquote>\n<p>Notice that the second sentence does not mention \"a static data member\" the way the first sentence does, so there is no requirement in this passage that all declarations (and here I'm considering a defining declaration specifically) of a <code>constexpr</code> <code>static</code> data member have the <code>constexpr</code> specifier.</p>\n<p>I can't find a rule elsewhere to mandate this, either.</p>\n<p>Why, then, does GCC reject the following program?</p>\n<pre><code>#include &lt;chrono&gt;\n\nusing namespace std::chrono_literals;\n\n#define DUR 1000ms\n\nstruct T\n{\n   static constexpr auto dur_1 = DUR;\n};\n\ndecltype(T::dur_1) T::dur_1;\n\n// main.cpp:12:23: error: 'constexpr' needed for in-class initialization of static data member 'const std::chrono::duration&lt;long int, std::ratio&lt;1l, 1000l&gt; T::dur_1' of non-integral type [-fpermissive] \n// decltype(T::dur_1) T::dur_1;\n//                       ^\n</code></pre>\n", "Tags": "<c++><gcc><c++14><constexpr>", "OwnerUserId": "560648", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_30831567_30831567_0": {"section_id": 5417, "quality": 0.9142857142857143, "length": 32}}, "n3337": {"so_30831567_30831567_0": {"section_id": 5212, "quality": 0.7714285714285715, "length": 27}}, "n4659": {"so_30831567_30831567_0": {"section_id": 6839, "quality": 0.7428571428571429, "length": 26}}}, "31004516": {"ParentId": "30831567", "CommentCount": "2", "CreationDate": "2015-06-23T13:44:56.963", "OwnerUserId": "3001468", "PostTypeId": "2", "Id": "31004516", "Score": "0", "Body": "<p>A constexpr static data member has to be initialized in class according to 7.1.5 (9). This is the definition of the member. Because of the ODR no other definition is allowed, so T::dur_1 could only be a declaration. But there is no rule allowing declaration of const static data members outside the class body, so this declaration isn't allowed. </p>\n<p>GCC support this as an extension only if constexpr is used consistently. </p>\n<p>Or I'm wrong and it's a bug ;)</p>\n<p>FWIW: clang accepts this code without a warning. </p>\n", "LastActivityDate": "2015-06-23T13:44:56.963"}});