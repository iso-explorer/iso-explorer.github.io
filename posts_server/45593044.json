post_cb({"45593044": {"CommentCount": "8", "AcceptedAnswerId": "45593720", "CreationDate": "2017-08-09T14:07:08.927", "LastActivityDate": "2017-08-09T14:58:55.187", "PostTypeId": "1", "ViewCount": "1334", "FavoriteCount": "1", "Title": "The value of a const variable is or is not usable in a constant expression, depending on the variable type", "Id": "45593044", "Score": "9", "Body": "<p>The following code is fine:</p>\n<pre><code>constexpr double square_cstxpr(double x) { return x * x; }\n\nint main() {\n    const int test = 5;\n    constexpr double result = square_cstxpr((double)test);\n}\n</code></pre>\n<p>However, if the type of <code>test</code> is changed from <code>const int</code> to <code>const double</code>, g++ gives the following error: <code>the value of 'test' is not usable in a constant expression</code>.</p>\n<p>See the code and output of g++ here: <a href=\"http://coliru.stacked-crooked.com/a/2fe9b176c2b23798\" rel=\"noreferrer\">http://coliru.stacked-crooked.com/a/2fe9b176c2b23798</a></p>\n<p>Could somebody explain that behavior?</p>\n", "Tags": "<c++><c++11><const><constexpr>", "OwnerUserId": "1832712", "AnswerCount": "2"}, "45593724": {"ParentId": "45593044", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/language/constant_expression\" rel=\"nofollow noreferrer\">constant expression</a> (Core constant expressions):</p>\n<blockquote>\n<p id=\"so_45593044_45593724_0\">10) Any other lvalue-to-rvalue implicit conversion, unless the\n  lvalue...</p>\n<p id=\"so_45593044_45593724_1\">a) <strong>has integral or enumeration type</strong> and refers to a complete non-volatile \n  const object, which is initialized with a constant expression</p>\n</blockquote>\n<p>It means, that here:</p>\n<pre><code>const int test1 = 5;\nconstexpr double result1 = square_cstxpr((double)test1);\n</code></pre>\n<p><code>test1</code> is a constant expression, <code>square_cstxpr</code> can be called with <code>test1</code> as an argument at compile time and its result can be assigned to <em>constexpr variable</em> <code>result</code>.</p>\n<p>On the other hand, here:</p>\n<pre><code>const double test2 = 5;\nconstexpr double result2 = square_cstxpr((double)test2);\n</code></pre>\n<p><code>test2</code> is not a constant expression because it is not of integral or enumeration type. Consequently, <code>square_cstxpr</code> cannot be called at compile time with <code>test2</code>as an argument.</p>\n", "OwnerUserId": "5507349", "LastEditorUserId": "5507349", "LastEditDate": "2017-08-09T14:58:55.187", "Id": "45593724", "Score": "6", "CreationDate": "2017-08-09T14:36:26.550", "LastActivityDate": "2017-08-09T14:58:55.187"}, "bq_ids": {"n4140": {"so_45593044_45593724_1": {"section_id": 6185, "quality": 0.9090909090909091, "length": 10}, "so_45593044_45593724_0": {"section_id": 603, "quality": 0.6666666666666666, "length": 4}, "so_45593044_45593720_1": {"section_id": 6185, "quality": 0.875, "length": 14}}, "n3337": {"so_45593044_45593724_1": {"section_id": 5946, "quality": 0.9090909090909091, "length": 10}, "so_45593044_45593724_0": {"section_id": 6787, "quality": 0.6666666666666666, "length": 4}, "so_45593044_45593720_1": {"section_id": 5946, "quality": 0.8125, "length": 13}}, "n4659": {"so_45593044_45593724_1": {"section_id": 7687, "quality": 1.0, "length": 11}, "so_45593044_45593724_0": {"section_id": 629, "quality": 0.6666666666666666, "length": 4}, "so_45593044_45593720_1": {"section_id": 7687, "quality": 0.9375, "length": 15}}}, "45593720": {"ParentId": "45593044", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Non-<code>constexpr</code> but <code>const</code> variables must be of integer or enumeration type for them to be usable in constant expressions. See <a href=\"http://eel.is/c++draft/expr.const#2.7\" rel=\"nofollow noreferrer\">[expr.const]/2</a>:</p>\n<blockquote>\n<p id=\"so_45593044_45593720_0\">an lvalue-to-rvalue conversion unless it is applied to </p>\n<p id=\"so_45593044_45593720_1\">(2.7.1) a non-volatile glvalue of <strong>integral or enumeration type</strong>\n  that refers to a complete non-volatile const object with a preceding\n  initialization, initialized with a constant expression, or [..]</p>\n</blockquote>\n<p>The reasons for this limitation must be mostly historical. Floating points have been handled with care when it comes to constant expressions; think non-type template parameters. This is due to their strongly platform dependent behaviour that renders compile time calculations less mathematical than they should be. </p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2017-08-09T14:44:07.200", "Id": "45593720", "Score": "4", "CreationDate": "2017-08-09T14:36:12.520", "LastActivityDate": "2017-08-09T14:44:07.200"}});