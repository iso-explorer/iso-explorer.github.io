post_cb({"6090306": {"CommentCount": "3", "AcceptedAnswerId": "6090529", "CreationDate": "2011-05-22T19:46:08.620", "LastActivityDate": "2011-05-22T21:29:05.323", "PostTypeId": "1", "ViewCount": "2144", "FavoriteCount": "3", "Title": "Unexpected compilation problem with g++ -std=c++0x", "Id": "6090306", "Score": "8", "Body": "<p>I have some compilation problems pushing back elements of type T to a vector when compiling with g++ -std=c++0x.</p>\n<p>This is a minimal example:</p>\n<pre><code>#include &lt;vector&gt;\n\nusing namespace std;\n\nclass A {\npublic:\n    A() { }\n\n    A&amp; operator=(A &amp;orig) {\n        return *this;\n    }\n};\n\nint main(int argc, char **argv) {\n    A a;\n    vector&lt;A&gt; b;\n    A c = a; // This is fine\n    b.push_back(a); // This is not, but only when compiling with -std=c++0x!\n    return 0;\n}\n</code></pre>\n<p>It compiles fine with g++ -Wall -pedantic, but it gives this error when compiling with g++ -Wall -pedantic -std=c++0x:</p>\n<pre><code> In file included from /usr/include/c++/4.4/vector:69,\n                 from min.cpp:1:\n/usr/include/c++/4.4/bits/vector.tcc: In member function \u2018void std::vector&lt;_Tp, _Alloc&gt;::_M_insert_aux(__gnu_cxx::__normal_iterator&lt;typename std::_Vector_base&lt;_Tp, _Alloc&gt;::_Tp_alloc_type::pointer, std::vector&lt;_Tp, _Alloc&gt; &gt;, _Args&amp;&amp; ...) [with _Args = const A&amp;, _Tp = A, _Alloc = std::allocator&lt;A&gt;]\u2019:\n/usr/include/c++/4.4/bits/stl_vector.h:741:   instantiated from \u2018void std::vector&lt;_Tp, _Alloc&gt;::push_back(const _Tp&amp;) [with _Tp = A, _Alloc = std::allocator&lt;A&gt;]\u2019\nmin.cpp:20:   instantiated from here\n/usr/include/c++/4.4/bits/vector.tcc:314: error: no match for \u2018operator=\u2019 in \u2018__position.__gnu_cxx::__normal_iterator&lt;_Iterator, _Container&gt;::operator* [with _Iterator = A*, _Container = std::vector&lt;A, std::allocator&lt;A&gt; &gt;]() = ((const A&amp;)((const A*)std::forward [with _Tp = const A&amp;](((const A&amp;)((const A*)__args#0)))))\u2019\nmin.cpp:11: note: candidates are: A&amp; A::operator=(A&amp;)\nIn file included from /usr/include/c++/4.4/vector:61,\n                 from min.cpp:1:\n/usr/include/c++/4.4/bits/stl_algobase.h: In static member function \u2018static _BI2 std::__copy_move_backward&lt;true, false, std::random_access_iterator_tag&gt;::__copy_move_b(_BI1, _BI1, _BI2) [with _BI1 = A*, _BI2 = A*]\u2019:\n/usr/include/c++/4.4/bits/stl_algobase.h:595:   instantiated from \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2) [with bool _IsMove = true, _BI1 = A*, _BI2 = A*]\u2019\n/usr/include/c++/4.4/bits/stl_algobase.h:605:   instantiated from \u2018_BI2 std::__copy_move_backward_a2(_BI1, _BI1, _BI2) [with bool _IsMove = true, _BI1 = A*, _BI2 = A*]\u2019\n/usr/include/c++/4.4/bits/stl_algobase.h:676:   instantiated from \u2018_BI2 std::move_backward(_BI1, _BI1, _BI2) [with _BI1 = A*, _BI2 = A*]\u2019\n/usr/include/c++/4.4/bits/vector.tcc:308:   instantiated from \u2018void std::vector&lt;_Tp, _Alloc&gt;::_M_insert_aux(__gnu_cxx::__normal_iterator&lt;typename std::_Vector_base&lt;_Tp, _Alloc&gt;::_Tp_alloc_type::pointer, std::vector&lt;_Tp, _Alloc&gt; &gt;, _Args&amp;&amp; ...) [with _Args = const A&amp;, _Tp = A, _Alloc = std::allocator&lt;A&gt;]\u2019\n/usr/include/c++/4.4/bits/stl_vector.h:741:   instantiated from \u2018void std::vector&lt;_Tp, _Alloc&gt;::push_back(const _Tp&amp;) [with _Tp = A, _Alloc = std::allocator&lt;A&gt;]\u2019\nmin.cpp:20:   instantiated from here\n/usr/include/c++/4.4/bits/stl_algobase.h:561: error: no match for \u2018operator=\u2019 in \u2018* -- __result = std::move [with _Tp = A&amp;](((A&amp;)(-- __last)))\u2019\nmin.cpp:11: note: candidates are: A&amp; A::operator=(A&amp;)\n</code></pre>\n<p>So it seems that it doesn't find the right operator= of A. Why? Why it states <code>with _Iterator = A*</code> when I'm passing A?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "69178", "AnswerCount": "3"}, "6090401": {"ParentId": "6090306", "CommentCount": "1", "Body": "<p>I'm quite sure this is a safety feature. Types with a copy-assignment operator (or a copy constructor) that may mutate the right-hand side are <em>not</em> safe to use in standard containers - an example of this is (the now deprecated) <code>std::auto_ptr</code> which will break horribly if stored in a container.</p>\n<p>The old C++03 library implementation permitted such unsafe code, but apparently they implemented a compile-time check in the C++0x version -- probably in conjunction with move-enabling the containers.</p>\n", "OwnerUserId": "279597", "PostTypeId": "2", "Id": "6090401", "Score": "3", "CreationDate": "2011-05-22T20:00:05.230", "LastActivityDate": "2011-05-22T20:00:05.230"}, "6090529": {"ParentId": "6090306", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>The <em>Assignable</em> requirement imposted by the language standard on the standard container elements requires the <code>t = u</code> expression to be valid even if <code>u</code> is a const object. The requirement was defined that way since C++98 (see 23.1/4)</p>\n<p>You violated that requirement, since your assignment operator does not accept const objects. This immediately mean that your class <code>A</code> cannot be used as a container element type.</p>\n<p>Why it worked in C++03 is rather irrelevant. It worked by accident. It is obvious from the error message that the C++0x implementation of the library uses some C++0x specific features (like <code>std::move</code>), which is what makes the above requirement to come into play. But anyway, a C++03 implementation (and even C++98 implementation) can also fail to compile for your <code>A</code>.</p>\n<p>Your example with <code>A c = a;</code> is irrelevant, since it does not use the assignment operator at all (why is it here?).</p>\n<p>In order to fix the error you should either accept the parameter by const reference or by value.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2011-05-22T21:29:05.323", "Id": "6090529", "Score": "15", "CreationDate": "2011-05-22T20:18:45.977", "LastActivityDate": "2011-05-22T21:29:05.323"}, "bq_ids": {"n4140": {"so_6090306_6090483_0": {"section_id": 466, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_6090306_6090483_0": {"section_id": 457, "quality": 0.9444444444444444, "length": 17}}, "n4659": {"so_6090306_6090483_0": {"section_id": 489, "quality": 0.9444444444444444, "length": 17}}}, "6090483": {"ParentId": "6090306", "CommentCount": "1", "Body": "<p>The standard's definition of copy-assignment operator is (section <code>[class.copy]</code>):</p>\n<blockquote>\n<p id=\"so_6090306_6090483_0\">A user-declared <em>copy</em> assignment operator <code>X::operator=</code> is a non-static non-template member function of class <code>X</code> with exactly one parameter of type <code>X</code>, <code>X&amp;</code>, <code>const X&amp;</code>, <code>volatile X&amp;</code> or <code>const volatile X&amp;</code>.</p>\n</blockquote>\n<p>But the <code>X&amp;</code> and <code>volatile X&amp;</code> variants may not be compatible with containers assuming an assignment can be made from an r-value RHS.</p>\n<p>NOTE: Passing by value, e.g. <code>X::operator=(X)</code> is a fundamental part of the copy-and-swap idiom.</p>\n", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "6090483", "Score": "1", "CreationDate": "2011-05-22T20:10:28.323", "LastActivityDate": "2011-05-22T20:10:28.323"}});