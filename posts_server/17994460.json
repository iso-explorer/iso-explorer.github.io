post_cb({"bq_ids": {"n4140": {"so_17994460_17994775_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 3906}}, "n3337": {"so_17994460_17994775_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 3766}}}, "17994460": {"ViewCount": "541", "Body": "<p><a href=\"http://isocpp.org/images/uploads/3-Tour-Abstr.pdf\" rel=\"nofollow\">In page 82 of the draft of Chapter 3 : A Tour of C++: Abstraction Mechanisms</a> the author writes:</p>\n<blockquote>\n<p id=\"so_17994460_17994460_0\">If we also want to use the range-for loop for our <strong>Vector</strong>, we must\n  de\ufb01ne suitable <strong>begin()</strong> and <strong>end()</strong> functions:</p>\n</blockquote>\n<pre><code>template&lt;typename T&gt;\nT\u2217 begin(Vector&lt;T&gt;&amp; x)\n{\n    return &amp;x[0]; // pointer to \ufb01rst element\n}\n\ntemplate&lt;typename T&gt;\nT\u2217 end(Vector&lt;T&gt;&amp; x)\n{\n    return x.begin()+x.size(); // pointer to one-past-last element\n}\n</code></pre>\n<p>Given those, we can write:</p>\n<pre><code>void f2(const Vector&lt;string&gt;&amp; vs) // Vector of some strings\n{\n    for (auto s : vs)\n        cout &lt;&lt; s &lt;&lt; \u2019\\n\u2019;\n}\n</code></pre>\n<p>Notice that the class template <strong>Vector</strong> is defined in page 81 of the draft.</p>\n", "AcceptedAnswerId": "17994640", "Title": "Shouldn't the begin() and end() functions be member functions of the template class Vector?", "CreationDate": "2013-08-01T12:45:08.110", "Id": "17994460", "CommentCount": "3", "LastEditDate": "2013-08-01T12:46:52.783", "PostTypeId": "1", "LastEditorUserId": "1155650", "LastActivityDate": "2013-08-01T13:56:11.310", "Score": "0", "OwnerUserId": "1042389", "Tags": "<c++><templates><c++11><auto>", "AnswerCount": "3"}, "17994636": {"PostTypeId": "2", "Body": "<p>If it is not an array or a container with <code>.begin()</code> and <code>.end()</code> it will look up by <a href=\"http://en.wikipedia.org/wiki/Argument-dependent_name_lookup\" rel=\"nofollow\">Argument dependent name</a>.</p>\n<p>It is said <a href=\"http://msdn.microsoft.com/en-us/library/vstudio/jj203382.aspx\" rel=\"nofollow\">here</a> :</p>\n<blockquote>\n<p id=\"so_17994460_17994636_0\">Keep in mind these facts about range-based for:</p>\n<ul>\n<li><p id=\"so_17994460_17994636_1\">Automatically recognizes arrays.</p></li>\n<li><p id=\"so_17994460_17994636_2\">Recognizes containers that have .begin() and .end().</p></li>\n<li><p id=\"so_17994460_17994636_3\"><strong>Uses argument-dependent lookup begin() and end() for anything else.</strong></p></li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2013-08-01T12:57:58.680", "LastEditorUserId": "1394283", "Id": "17994636", "CommentCount": "0", "CreationDate": "2013-08-01T12:52:12.047", "ParentId": "17994460", "Score": "4", "OwnerUserId": "1394283", "LastEditDate": "2013-08-01T12:57:58.680"}, "17994775": {"PostTypeId": "2", "Body": "<p>In such a range based for:</p>\n<pre><code>for ( for-range-declaration : expression ) statement\n</code></pre>\n<p>the standard says that the compiler looks for either members (<code>(expression).begin()</code>, <code>(expression).end()</code>) or free functions (<code>begin((expression))</code>, <code>end((expression))</code>) if expression is of class type.</p>\n<p>Therefore <strong>you can either provide member functions OR free functions</strong> (which need to be in scope for argument dependant lookup).</p>\n<blockquote id=\"so_17994460_17994775_0\">\n<h3>C++11, \u00a7 6.5.4 [stmt.ranged]</h3>\n</blockquote>\n<p>This is what a ranged-based for does according to the standard:</p>\n<pre><code>for ( for-range-declaration : expression ) statement\n\nrange-init = ( expression )\n\n{\n  auto &amp;&amp; __range = range-init;\n  for ( auto __begin = begin-expr,\n    __end = end-expr;\n    __begin != __end;\n    ++__begin ) \n  {\n    for-range-declaration = *__begin;\n    statement\n  }\n}\n</code></pre>\n<p>The <code>begin-expr</code> and <code>end-expr</code> are described as:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_17994460_17994775_1\">if <strong><code>_RangeT</code></strong> is an array type, <em>begin-expr</em> and <em>end-expr</em> are <strong>_<em>range</em></strong> and <strong></strong></p></li></ul></blockquote>_range + _<em>bound</em>, respectively, where <strong></strong>_bound is the array bound. If <strong>_RangeT</strong> is an array of unknown size or an array of incomplete type, the program is ill-formed;\n<li><p>if <strong><code>_RangeT</code></strong> is a class type, the unqualified-ids begin and end are looked up in the scope of class _RangeT as if by class member access lookup (3.4.5), and if either (or both) finds at least one declaration, beginexpr and end-expr are __range.begin() and __range.end(), respectively;</p></li>\n<li><p>otherwise, <em>begin-expr</em> and <em>end-expr</em> are <strong><code>begin(__range)</code></strong> and <strong><code>end(__range)</code></strong>, respectively, where <strong><code>begin</code></strong> and <strong><code>end</code></strong> are looked up with argument-dependent lookup (3.4.2). For the purposes of this name lookup, namespace std is an associated namespace.</p></li>\n", "LastActivityDate": "2013-08-01T13:04:56.390", "LastEditorUserId": "951423", "Id": "17994775", "CommentCount": "2", "CreationDate": "2013-08-01T12:58:56.490", "ParentId": "17994460", "Score": "2", "OwnerUserId": "951423", "LastEditDate": "2013-08-01T13:04:56.390"}, "17994640": {"PostTypeId": "2", "Body": "<p>For range-based for to work, the compiler needs to find a suitable function to get the iterators.</p>\n<ul>\n<li><p>If the type used is a class, it'll first look for member functions <code>begin</code> and <code>end</code> in the scope of that class.</p></li>\n<li><p>If the type is not a class or the are no such member functions, it looks them up by <a href=\"http://en.wikipedia.org/wiki/Argument-dependent_name_lookup\" rel=\"nofollow\">Argument Dependent Lookup.</a></p></li>\n</ul>\n<p>This is the reason range-based for works on C-arrays. Obviously, arrays can't have member functions, so standard library provides two functions defined similarly to this:</p>\n<pre><code>template&lt;typename T, size_t N&gt;\nT* begin( T(&amp;array)[N] )\n{\n    return array;\n}\n</code></pre>\n<p>and similarly for <code>end</code>.</p>\n<p>To answer your question from the title: they <em>can</em> be, but it's not a neccesity. You can define free functions in the same namespace as your class and they'll be found.</p>\n", "LastActivityDate": "2013-08-01T13:56:11.310", "LastEditorUserId": "947836", "Id": "17994640", "CommentCount": "4", "CreationDate": "2013-08-01T12:52:20.757", "ParentId": "17994460", "Score": "5", "OwnerUserId": "947836", "LastEditDate": "2013-08-01T13:56:11.310"}});