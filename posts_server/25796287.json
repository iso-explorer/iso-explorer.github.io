post_cb({"25796287": {"CommentCount": "2", "ViewCount": "350", "PostTypeId": "1", "LastEditorUserId": "2756719", "CreationDate": "2014-09-11T20:22:09.353", "LastActivityDate": "2014-09-11T21:07:49.380", "Title": "Delete std::condition_variable_any directly after notify_all crashes", "AcceptedAnswerId": "25796860", "LastEditDate": "2014-09-11T21:07:49.380", "Id": "25796287", "Score": "4", "Body": "<p>I have a portion of code, where one thread calls something like:</p>\n<pre><code>cond-&gt;notify_all();\ndelete cond;\n</code></pre>\n<p>with</p>\n<pre><code>std::condition_variable_any cond;\n</code></pre>\n<p>Afaik, this should work, since <a href=\"http://en.cppreference.com/w/cpp/thread/condition_variable_any/~condition_variable_any\" rel=\"nofollow\">I should be allowed to delete the condition variable, as soon as I notified all threads waiting on it</a>, they don't have to have resumed from the <i>wait</i> call.</p>\n<p>On Windows, this sometimes, crashes for me with an error:</p>\n<pre><code>mutex destroyed while busy\n</code></pre>\n<p>printed to stdout</p>\n<p>On linux, with <b>clang 3.5</b> this works perfectly fine, on windows I use <b>Visual Studio 2013, with v120 tookit</b>, v120 is the default one.</p>\n<p>Did I do something wrong, did I missunderstand the standard, or is M$ doing something wrong here? If it does, how can I work around that?</p>\n", "Tags": "<c++><c++11><condition-variable>", "OwnerUserId": "2191774", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_25796287_25796860_5": {"section_id": 2991, "quality": 0.8823529411764706, "length": 60}, "so_25796287_25796860_2": {"section_id": 2991, "quality": 0.8823529411764706, "length": 60}}, "n3337": {"so_25796287_25796860_5": {"section_id": 2861, "quality": 0.8823529411764706, "length": 60}, "so_25796287_25796860_2": {"section_id": 2861, "quality": 0.8823529411764706, "length": 60}}, "n4659": {"so_25796287_25796860_2": {"section_id": 3750, "quality": 0.8823529411764706, "length": 60}, "so_25796287_25796860_5": {"section_id": 3750, "quality": 0.8823529411764706, "length": 60}}}, "25796860": {"ParentId": "25796287", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Microsoft's implementation of <code>std::condition_variable_any</code> is non-conforming. According to <a href=\"http://blogs.msdn.com/b/vcblog/archive/2014/06/06/c-14-stl-features-fixes-and-breaking-changes-in-visual-studio-14-ctp1.aspx\" rel=\"nofollow\"><strong>C++14 STL Features, Fixes, And Breaking Changes In Visual Studio 14 CTP1</strong></a> this has been fixed in the not-yet-released VS14:</p>\n<blockquote>\n<p id=\"so_25796287_25796860_0\">We've implemented the extremely subtle rule specified by 30.5.2 [thread.condition.condvarany]/5:</p>\n<blockquote>\n<p id=\"so_25796287_25796860_4\"><code>~condition_variable_any()</code></p>\n<p id=\"so_25796287_25796860_5\"><em>Requires:</em> There shall be no thread blocked on <code>*this.</code> [ <em>Note:</em> That is, all threads shall have been notified; they may subsequently block on the lock specified in the wait. This relaxes the usual rules, which would have required all wait calls to happen before destruction. Only the notification to unblock the wait must happen before destruction. The user must take care to ensure that no threads wait on <code>*this</code> once the destructor has been started, especially when the waiting threads are calling the wait functions in a loop or using the overloads of <code>wait</code>, <code>wait_for</code>, or <code>wait_until</code> that take a predicate. <em>-end note</em> ]</p>\n</blockquote>\n<p id=\"so_25796287_25796860_3\">(DevDiv#484720).</p>\n</blockquote>\n", "OwnerUserId": "923854", "LastEditorUserId": "923854", "LastEditDate": "2014-09-11T21:07:26.300", "Id": "25796860", "Score": "3", "CreationDate": "2014-09-11T21:00:38.163", "LastActivityDate": "2014-09-11T21:07:26.300"}});