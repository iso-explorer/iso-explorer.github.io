post_cb({"bq_ids": {"n4140": {"so_19040518_19041178_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 460}, "so_19040518_19040518_1": {"length": 30, "quality": 0.9090909090909091, "section_id": 464}}, "n3337": {"so_19040518_19041178_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 451}, "so_19040518_19040518_1": {"length": 30, "quality": 0.9090909090909091, "section_id": 455}}, "n4659": {"so_19040518_19041178_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 382}, "so_19040518_19040518_1": {"length": 30, "quality": 0.9090909090909091, "section_id": 487}}}, "19041178": {"Id": "19041178", "PostTypeId": "2", "Body": "<p>Here be dragons.</p>\n<pre><code>logger(logger const&amp; other) : value_(other.value_)\n</code></pre>\n<p>The expression <code>other.value_</code> is an lvalue of type <code>T const</code>, e.g. <code>int&amp;</code>, <code>int&amp;&amp;</code> or <code>int const</code>.</p>\n<ol>\n<li><p>If <code>T == int&amp;&amp;</code>, you need to do a <code>move</code>, as the expression is an lvalue. The <code>move</code> is equivalent to a <code>static_cast&lt;int&amp;&amp;&gt;</code>, so you could do the <code>static_cast</code> directly as well.</p></li>\n<li><p>If <code>T == int&amp;</code>, no cast is required.</p></li>\n<li><p>If <code>T == int</code>, no cast is required.</p></li>\n</ol>\n<p>For a copy ctor defined as:</p>\n<pre><code>logger(logger const&amp; other) : value_(static_cast&lt;T&gt;(other.value_)) {/*...*/}\n</code></pre>\n<p>Applied to the third case, this is defined as the introduction of a temporary, and could result in an additional copy/move, although I think it can&amp;will be elided.</p>\n<p>A solution without relying on the copy/move elision is to introduce a <code>weird_cast</code>, that yields the desired type in any case:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt;class T, class U&gt;\ntypename std::enable_if&lt;std::is_reference&lt;T&gt;{}, T&gt;::type\nweird_cast(U&amp; p)\n{\n    return static_cast&lt;T&gt;(p);\n}\n\ntemplate&lt;class T, class U&gt;\ntypename std::enable_if&lt;not std::is_reference&lt;T&gt;{}, T const&amp;&gt;::type\nweird_cast(U const&amp; p)\n{\n    return p;\n}\n\nint main()\n{\n    int           o = 42;\n    int &amp;        lo = o;\n    int &amp;&amp;       ro = std::move(o);\n    int const   lco = o;\n\n    int&amp;&amp; r = weird_cast&lt;int&amp;&amp;&gt;(ro);\n    int&amp;  l = weird_cast&lt;int&amp; &gt;(lo);\n    int   d = weird_cast&lt;int  &gt;(lco);\n}\n</code></pre>\n<p>This is similar to <code>std::forward</code>, but also supports \"forwarding\" non-reference types.</p>\n<hr>\n<p>Where are the dragons?</p>\n<p>[class.copy]/11 specifies:</p>\n<blockquote>\n<p id=\"so_19040518_19041178_0\">A defaulted copy/move constructor for a class <code>X</code> is defined as deleted if <code>X</code> has:</p>\n<ul>\n<li>[...]</li>\n<li>for the copy constructor, a non-static data member of rvalue reference type</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>An rvalue reference is typically bound to an xvalue or prvalue, i.e. to an expression referring to an object that is \"near the end of its lifetime\". As lifetime doesn't get extended through function boundaries, it would be error prone to allow such a \"copying\".</p>\n</hr>", "LastEditorUserId": "420683", "LastActivityDate": "2013-09-27T01:56:54.790", "Score": "3", "CreationDate": "2013-09-27T01:08:43.473", "ParentId": "19040518", "CommentCount": "6", "OwnerUserId": "420683", "LastEditDate": "2013-09-27T01:56:54.790"}, "19040518": {"ViewCount": "508", "Body": "<p>I'm working on a simple wrapper template class that logs when special member functions are called. These functions cannot be defaulted since they perform additional logging related tasks.</p>\n<pre><code>template &lt;typename T&gt;\nstruct logger {\n    logger(T const&amp; value) : value_(value) { /*...log...*/ }\n    logger(T&amp;&amp; value) : value_(std::move(value)) { /*...log...*/ }\n    logger(logger const&amp; other) : value_(other.value_) { /*...log...*/ }\n    logger(logger&amp;&amp; other) : value_(std::move(other.value_)) { /*...log...*/ }\n\n    T value_;\n};\n</code></pre>\n<p>Unfortunately, when the wrapped type is an <em>rvalue-reference</em> the <em>copy-constructor</em> fails to compile with the following error message:</p>\n<blockquote>\n<p id=\"so_19040518_19040518_0\">error: cannot bind \u2018int\u2019 lvalue to \u2018int&amp;&amp;\u2019</p>\n</blockquote>\n<p>The reason is that an implicit copy constructor will behave somewhat different for an <em>rvalue-reference</em> member:</p>\n<blockquote>\n<p id=\"so_19040518_19040518_1\"><strong>[class.copy 12.8/15]</strong>\n  The implicitly-defined copy/move constructor for a non-union class <code>X</code> performs a memberwise copy/move of its bases and members. <em>[...]</em> Let <code>x</code> be either the parameter of the constructor or, for the move constructor, an xvalue referring to the parameter. Each base or non-static data member is copied/moved in the manner appropriate to its type:</p>\n<ul>\n<li>if the member is an array, each element is direct-initialized with the corresponding subobject of <code>x</code>;</li>\n<li>if a member m has rvalue reference type <code>T&amp;&amp;</code>, it is direct-initialized with <code>static_cast&lt;T&amp;&amp;&gt;(x.m)</code>;</li>\n<li>otherwise, the base or member is direct-initialized with the corresponding base or member of <code>x</code>.</li>\n</ul>\n</blockquote>\n<p>Which brings me to my question: how does one write a generic <em>copy-constructor</em> that behaves as an implicitly defined <em>copy-constructor</em>, even when working with <em>rvalue-references</em> as members.</p>\n<p>For this particular case, I could add an additional specialization for <em>rvalue-references</em>. However, I'm looking for a generic solution that doesn't restrict to single members and does not introduce code duplication.</p>\n", "AcceptedAnswerId": "19041178", "Title": "Generic copy-constructor with rvalue-reference members", "CreationDate": "2013-09-26T23:46:30.113", "Id": "19040518", "CommentCount": "11", "LastEditDate": "2013-09-27T00:34:19.313", "PostTypeId": "1", "LastEditorUserId": "927034", "LastActivityDate": "2013-09-27T01:56:54.790", "Score": "2", "OwnerUserId": "927034", "Tags": "<c++><c++11><rvalue-reference>", "AnswerCount": "2"}, "19040635": {"Id": "19040635", "PostTypeId": "2", "Body": "<p>You could write a specialization for rvalue-references:</p>\n<pre><code>template&lt;typename T&gt;\nstruct logger&lt;T&amp;&amp;&gt;{\n  ...\n};\n</code></pre>\n<p>But really I don't think you want <code>logger::_value</code> to be a rvalue reference...</p>\n<p><strong>Edit</strong></p>\n<p>Although I feel this isn't a bad solution, as it's a GENERAL workaround for ALL rvalue references, here's another option without literal specialization:</p>\n<pre><code>template&lt;typename TT&gt;\nstruct logger{\n  typedef typename rvalue_remover&lt;TT&gt;::value T;\n  //your previous code here\n};\n</code></pre>\n<p>Where <code>rvalue_remover</code> is something like this:</p>\n<pre><code>template&lt;typename T&gt;struct rvalue_remover{typedef T value;};\ntemplate&lt;typename T&gt;struct rvalue_remover&lt;T&amp;&amp;&gt;{typedef T value;};\n</code></pre>\n<p>I'm pretty sure this is already defined in c++11, but I don't have it installed here so I don't remember the name.</p>\n<p><strong>Edit2</strong></p>\n<p>Ah! found it! It's called <code>std::remove_reference&lt;T&gt;::type</code>, and declared in <code>#include &lt;type_traits&gt;</code></p>\n", "LastEditorUserId": "1268551", "LastActivityDate": "2013-09-27T00:07:44.643", "Score": "0", "CreationDate": "2013-09-26T23:58:53.563", "ParentId": "19040518", "CommentCount": "7", "OwnerUserId": "1268551", "LastEditDate": "2013-09-27T00:07:44.643"}});