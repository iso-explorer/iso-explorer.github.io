post_cb({"31454259": {"ParentId": "31453992", "CommentCount": "0", "Body": "<p><strong>Yes, it is allowed.</strong></p>\n<p>There is no rule to prevent this overload.</p>\n<blockquote>\n<p id=\"so_31453992_31454259_0\"><code>[C++14: 13.1/1]:</code> Not all function declarations can be overloaded. Those that cannot be overloaded are specified here. <em>[..]</em></p>\n<p id=\"so_31453992_31454259_1\"><code>[C++14: 13.1/2]:</code> <em>(blah blah lots of exceptions not including any for this case)</em></p>\n</blockquote>\n<p>It would be extremely limiting for the language to prohibit function overloads that <em>may</em> be ambiguous in certain scenarios with certain calls, and for no good reason I might add!</p>\n", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "31454259", "Score": "7", "CreationDate": "2015-07-16T12:31:46.583", "LastActivityDate": "2015-07-16T12:31:46.583"}, "31453992": {"CommentCount": "2", "AcceptedAnswerId": "31454259", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-07-16T12:21:26.907", "LastActivityDate": "2015-07-16T18:23:54.017", "LastEditDate": "2017-05-23T12:30:13.740", "ViewCount": "258", "FavoriteCount": "2", "Title": "Is function overloading by reference allowed when there is no ambiguity?", "Id": "31453992", "Score": "8", "Body": "<p>Consider following code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nvoid foo(int m);\nvoid foo(int &amp;k);\n\nint main()\n{\n    foo(5); // ok, because there is no ambiguity\n\n    int m = 5;\n    //foo(m); // compile-time error, because of ambiguity\n    foo(m + 0); // ok, because it's an expression of type int and not object's lvalue\n}\n\nvoid foo(int m)\n{\n    std::cout &lt;&lt; \"by value\\n\";\n}\nvoid foo(int &amp;k)\n{\n    std::cout &lt;&lt; \"by reference\\n\";\n}\n</code></pre>\n<p>I understand that it introduces ambiguity for <code>foo(m)</code>, but is this allowed, when expression is of type <code>int</code> (or another that can be converted to <code>int</code>)?</p>\n<p>I have tried to find some standard reference on this, yet with no luck.</p>\n<hr>\n<p><sup><strong>Disclaimer</strong>: Note that it's not duplicate of <a href=\"https://stackoverflow.com/questions/5465293/function-overloading-based-on-value-vs-const-reference\">Function Overloading Based on Value vs. Const Reference</a>. The <code>const</code> references are different as they can be assigned with <strong><em>rvalues</em></strong>, as opposite to \"ordinary\", non-<code>const</code> references.</sup></p>\n</hr>", "Tags": "<c++><overloading><pass-by-reference><language-lawyer>", "OwnerUserId": "586873", "AnswerCount": "2"}, "31454284": {"ParentId": "31453992", "CommentCount": "1", "Body": "<p>13.1 [over.load] is pretty clear (apart from a multi-page note) about which functions cannot be overloaded in the same scope.</p>\n<p>Your case is not listed there, and you can declare those overloads, you just can't necessarily use them easily. You could call the lvalue one like so:</p>\n<pre><code>void (*f)(int&amp;) = foo;\nf(m);\n</code></pre>\n<p>This avoids the ambiguity that happens when you call <code>foo(m)</code>.</p>\n<p>Aside: another way to write <code>foo(m + 0)</code> is simply <code>foo(+m)</code>, the unary <code>+</code> operator converts the lvalue to an rvalue, so the <code>foo(int)</code> overload is called.</p>\n", "OwnerUserId": "981959", "PostTypeId": "2", "Id": "31454284", "Score": "9", "CreationDate": "2015-07-16T12:32:35.370", "LastActivityDate": "2015-07-16T12:32:35.370"}, "bq_ids": {"n4140": {"so_31453992_31454259_0": {"section_id": 556, "quality": 0.7692307692307693, "length": 10}}, "n3337": {"so_31453992_31454259_0": {"section_id": 547, "quality": 0.7692307692307693, "length": 10}}, "n4659": {"so_31453992_31454259_0": {"section_id": 579, "quality": 0.7692307692307693, "length": 10}}}});