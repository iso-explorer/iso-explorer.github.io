post_cb({"bq_ids": {"n4659": {"so_48249817_48249817_1": {"length": 4, "section_id": 180, "quality": 1.0}}}, "48249817": {"Tags": "<c++><string><c++11>", "ViewCount": "73", "LastEditDate": "2018-01-14T13:03:57.190", "CreationDate": "2018-01-14T13:00:32.660", "LastEditorUserId": "1376095", "Title": "Error at \"placement new: explicit construct\"", "CommentCount": "6", "AnswerCount": "0", "Score": "3", "OwnerUserId": "1376095", "Id": "48249817", "LastActivityDate": "2018-01-14T13:03:57.190", "Body": "<p>I'm following Stroustroup's example on using implicit unions. </p>\n<pre><code>#include &lt;string&gt;\nusing namespace std;\n\nclass MemoryObject {\npublic:\n    enum class t { STRING, BOOLEAN };\n    t type;\n\n    MemoryObject&amp; operator=(const MemoryObject&amp; s) {\n        if (type == t::STRING &amp;&amp; s.type == t::STRING) {\n            str = s.str;\n            return *this;\n        }\n\n        if (type == t::STRING) str.~string();\n        type = s.type;\n\n        switch (s.type) {\n            case t::BOOLEAN:\n                boolean = s.boolean;\n                break;\n            case t::STRING:\n                new(&amp;str){s.str};\n                break;\n            default:\n                break;\n        }\n\n        return *this;\n    }\n\nprivate:\n    union {\n        unsigned long boolean;\n        string str;\n    };\n    t stored;\n};\n</code></pre>\n<p>On the other hand, I get the following errors over the invocation of the explicit construct:</p>\n<blockquote>\n<p id=\"so_48249817_48249817_0\">/mnt/DEC4763AC47614CD/Progetti/object_converter/MemoryObject.h:30:27:</p>\n<p id=\"so_48249817_48249817_1\">error: \u2018s\u2019 does not name a type</p>\n<pre><code>    new(&amp;str)(s.str);\n              ^ /mnt/DEC4763AC47614CD/Progetti/object_converter/MemoryObject.h:30:28:\n</code></pre>\n<p id=\"so_48249817_48249817_2\">error: expected \u2018)\u2019 before \u2018.\u2019 token</p>\n<pre><code>    new(&amp;str)(s.str);\n               ^\n</code></pre>\n</blockquote>\n<p>As a side question, I'm also wondering why I must explicitely use the <code>using namespace std;</code> in order to call the explicit destroy <code>str.~string();</code> while, on the other hand, it is possible to write neither <code>str.~std::string();</code> nor <code>str.std::~string();</code>. I'm using the following compiler: <code>g++ (Ubuntu 6.3.0-12ubuntu2) 6.3.0 20170406</code></p>\n", "PostTypeId": "1"}});