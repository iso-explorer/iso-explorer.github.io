post_cb({"25830595": {"ParentId": "25829479", "CommentCount": "2", "CreationDate": "2014-09-14T06:12:52.913", "OwnerUserId": "1566221", "PostTypeId": "2", "Id": "25830595", "Score": "0", "Body": "<p>Normally functions which return objects larger than the capacity of a register are compiled into an equivalent form where they take one extra argument which is the address into which the return value should be placed. The caller is then responsible for allocating (or providing) the location for the return value.</p>\n<p>Even before C++11 move semantics, Return Value Optimization (RVO) was allowed by the C++ standard. RVO allows the compiler to leave out a copy operation <em>even if the copy operation is non-trivial</em> in certain cases, including the one where the object returned is a non-volatile automatic variable, as in the cited example. This described in detail in paragraph 31 of \u00a712.8 ([class.copy]) of the version of the C++ standard I have handy, from which I've extracted the following quote:</p>\n<blockquote>\n<p id=\"so_25829479_25830595_0\">31. When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object, even if the constructor selected for the copy/move operation and/or the destructor for the object have side effects. In such cases, the implementation treats the source and target of the omitted copy/move operation as simply two different ways of referring to the same object\u2026 This\u2026 is permitted in the following circumstances\u2026</p>\n<p id=\"so_25829479_25830595_1\">-- in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (other than a function or catch-clause parameter) with the same cv-unqualified type as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function\u2019s return value.\u2026</p>\n</blockquote>\n<p>So, the caller allocates space on the stack for the return value, and passes the address of that space to the called function (<code>return_vector</code>). The compiler notices that the only return statement in that function returns a non-volatile automatic object (<code>tmp</code>), so rather than allocating space for <code>tmp</code> in the callee's stack segment, it just uses the space provided by the caller for the return value, so that <code>tmp</code> becomes an alias for that location, and the construction of <code>tmp</code> occurs directly in the memory into which the value will be returned. Consequently, neither a move nor a copy is done because the return value is already where it needs to be.</p>\n", "LastActivityDate": "2014-09-14T06:12:52.913"}, "25829479": {"CommentCount": "2", "ViewCount": "98", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-09-14T02:11:49.000", "LastActivityDate": "2014-09-14T06:12:52.913", "Title": "c++11 - during return r-value move, is there a stack copy?", "AcceptedAnswerId": "25830595", "LastEditDate": "2017-05-23T11:57:15.963", "Id": "25829479", "Score": "0", "Body": "<p>Looking at this <a href=\"https://stackoverflow.com/questions/4986673/c11-rvalues-and-move-semantics-confusion-return-statement\">question</a> makes me wondering how it can be implemented. Here is the code borrowed from the question:</p>\n<pre><code>std::vector&lt;int&gt; return_vector(void)\n{\n    std::vector&lt;int&gt; tmp {1,2,3,4,5};\n    return tmp;\n}\n\nstd::vector&lt;int&gt; &amp;&amp;rval_ref = return_vector();\n</code></pre>\n<p>So <code>tmp</code> is allocated from the stack of function <code>return_vector</code>, now this stack memory is re-used by <code>rval_ref</code> which sits at upper level stack. There are 2 separate stacks here, is there a memory copy going under the hood? If so, it consumes CPU cycles which seems against the semantics of \"move\".</p>\n<p>But if not, the lower level stack table must be segmented, i.e. a portion is carved out so that when the stack is released, that portion can be saved. </p>\n<p>I do not know compiler implementation, just a curiosity which is hard to find answer. Or maybe I am totally missing something.</p>\n<p>[UPDATE] Thanks for Ben's prompt reply, yes, vector actually allocated heap memory. It is a bad example, but I see comment mentioning that it is actually one memory region managed by caller stack, this makes sense to me. Looking forward to more in-depth reply.</p>\n", "Tags": "<c++><c++11><compiler-construction>", "OwnerUserId": "996371", "AnswerCount": "3"}, "25829954": {"ParentId": "25829479", "CommentCount": "1", "CreationDate": "2014-09-14T04:02:08.993", "OwnerUserId": "862351", "PostTypeId": "2", "Id": "25829954", "Score": "0", "Body": "<p><code>std::vector&lt;int&gt; &amp;&amp;rval_ref = return_vector();</code> is binding an rvalue reference to a temporary. This doesn't result in any copies or moves. The lifetime of the temporary gets extended when it is bound to either an rvalue reference or a const lvalue reference.</p>\n", "LastActivityDate": "2014-09-14T04:02:08.993"}, "bq_ids": {"n4140": {"so_25829479_25830595_1": {"section_id": 480, "quality": 1.0, "length": 35}, "so_25829479_25830595_0": {"section_id": 480, "quality": 0.9761904761904762, "length": 41}}, "n3337": {"so_25829479_25830595_1": {"section_id": 471, "quality": 1.0, "length": 35}, "so_25829479_25830595_0": {"section_id": 471, "quality": 0.9047619047619048, "length": 38}}, "n4659": {"so_25829479_25830595_1": {"section_id": 502, "quality": 0.8857142857142857, "length": 31}, "so_25829479_25830595_0": {"section_id": 502, "quality": 0.9761904761904762, "length": 41}}}, "25829516": {"ParentId": "25829479", "CommentCount": "0", "CreationDate": "2014-09-14T02:22:13.310", "OwnerUserId": "103167", "PostTypeId": "2", "Id": "25829516", "Score": "2", "Body": "<p><code>std::vector</code> contains only a small amount of bookkeeping data, and uses dynamic allocation for the real content.</p>\n<p>Moving it will result in a copy of the bookkeeping data, but the main data won't be copied, instead the pointer to the heap allocation will be transferred to the new object.</p>\n", "LastActivityDate": "2014-09-14T02:22:13.310"}});