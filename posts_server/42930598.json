post_cb({"42932134": {"Id": "42932134", "PostTypeId": "2", "Body": "<p>Thanks to SanderDeDycker for pointing out the relevant part of the standard to search in.</p>\n<p>My question is answered in the following section of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf#chapter.5.4\" rel=\"nofollow noreferrer\">N4296</a> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_42930598_42932134_0\"><strong>[expr.cast]</strong></p>\n<ol>\n<li>The result of the expression (T) cast-expression is of type T . The\n  result is an lvalue if T is an lvalue reference type or an rvalue\n  reference to function type and an xvalue if T is an rvalue reference\n  to object type; otherwise the result is a prvalue. <strong>[ Note: if T is a\n  non-class type that is cv-qualified, the cv-qualifiers are discarded\n  when determining the type of the resulting prvalue; see Clause 5. \u2014\n  end note ]</strong></li>\n</ol>\n</blockquote>\n<p>So we can conclude that expressions such as <code>(const int) 42</code> are perfectly legal C++.</p>\n", "Score": "1", "LastActivityDate": "2017-03-21T15:55:37.427", "CreationDate": "2017-03-21T15:55:37.427", "ParentId": "42930598", "CommentCount": "1", "OwnerUserId": "1816262"}, "42930598": {"ViewCount": "73", "LastEditDate": "2017-03-21T15:47:22.643", "AcceptedAnswerId": "42932134", "Title": "Is it legal to cast a non-class non-array prvalue to a cv-qualified type?", "CreationDate": "2017-03-21T14:53:44.807", "LastActivityDate": "2017-03-21T15:55:37.427", "CommentCount": "4", "Body": "<p>I was reading up on <a href=\"http://en.cppreference.com/w/cpp/language/value_category\" rel=\"nofollow noreferrer\">value categories</a>, and came across the following (much omitted for brevity):</p>\n<blockquote>\n<p id=\"so_42930598_42930598_0\">The following expressions are prvalue expressions:</p>\n<ul>\n<li>a literal (except for string literal), such as 42, true or nullptr;</li>\n</ul>\n<p id=\"so_42930598_42930598_1\">Properties:</p>\n<ul>\n<li>A non-class non-array prvalue cannot be cv-qualified.</li>\n</ul>\n</blockquote>\n<p>But ... the following program compiles and runs fine <a href=\"http://ideone.com/zCcFzG\" rel=\"nofollow noreferrer\">on ideone.com</a> and with g++ 5.4.0:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; ((const int) 42) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>I understand that compilers provide extensions, and can do all manner of things if undefined behaviour is hit. I am simply trying to work out what the standard mandates.</p>\n<p>In <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf#chapter.5\" rel=\"nofollow noreferrer\">N4296</a>, I found the following to relevant passage:</p>\n<blockquote>\n<p id=\"so_42930598_42930598_2\"><strong>[expr]</strong></p>\n<p id=\"so_42930598_42930598_3\">[ ... content omitted ... ]</p>\n<ol start=\"6\">\n<li>If a prvalue initially has the type \u201c cv T ,\u201d where T is a\n  cv-unqualified non-class, non-array type, the type of the expression\n  is adjusted to T prior to any further analysis.</li>\n</ol>\n</blockquote>\n<p>The term \"initially\" is what throws me. It's not clear if this is allowed as the result of another expression, such as the user to explicitly casting a non-class non-array prvalue to a cv-qualified type (which yields another prvalue), or whether this applies only the \"root\" expression (<code>42</code> in this case).</p>\n<p>My question is, does the standard allow such expressions (which just strips away the cv-qualifiers), or is this disallowed (and if relevant, where is this mandated)?</p>\n", "PostTypeId": "1", "LastEditorUserId": "1816262", "Id": "42930598", "Score": "3", "OwnerUserId": "1816262", "Tags": "<c++><language-lawyer><value-categories>", "AnswerCount": "2"}, "42931969": {"Id": "42931969", "PostTypeId": "2", "Body": "<p>You should be aware that cppreference is not normative. \"Cannot\" can possibly be read in two ways:</p>\n<ul>\n<li><p>It is forbidden, ala \"shall not\"</p></li>\n<li><p>It simply cannot happen, ala invariants</p></li>\n</ul>\n<p>The quote you listed in the text:</p>\n<blockquote>\n<p id=\"so_42930598_42931969_0\">If a prvalue initially has the type \u201c cv T ,\u201d where T is a\n  cv-unqualified non-class, non-array type, the type of the expression\n  is adjusted to T prior to any further analysis.</p>\n</blockquote>\n<p>suggests to me that a cv qualified prvalue drops the qualifications just as arrays can decay to pointers (to clarify, this rule doesn't happen at a point where the cast would be ill-formed). Defect <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3714.html#1261\" rel=\"nofollow noreferrer\">#1261</a> does make the language quite explicit about what happens where.</p>\n", "Score": "1", "LastActivityDate": "2017-03-21T15:49:39.303", "CreationDate": "2017-03-21T15:49:39.303", "ParentId": "42930598", "CommentCount": "0", "OwnerUserId": "7744704"}, "bq_ids": {"n4140": {"so_42930598_42931969_0": {"length": 14, "quality": 1.0, "section_id": 5939}}, "n4659": {"so_42930598_42931969_0": {"length": 14, "quality": 1.0, "section_id": 7423}}}});