post_cb({"7743482": {"Id": "7743482", "PostTypeId": "2", "Body": "<p>A <code>std::string</code> is <code>std::basic_string&lt;char&gt;</code>, so <code>s.length() * sizeof(char) = byte length</code>. Also, <code>std::string</code> knows nothing of UTF-8, so you're going to get the byte size even if that's not really what you're after. </p>\n<p>If you have UTF-8 data in a <code>std::string</code>, you'll need to use something else such as <a href=\"http://site.icu-project.org/\" rel=\"nofollow\">ICU</a> to get the \"real\" length.</p>\n", "LastEditorUserId": "132064", "LastActivityDate": "2015-01-23T17:00:22.433", "Score": "4", "CreationDate": "2011-10-12T16:39:54.917", "ParentId": "7743356", "CommentCount": "0", "LastEditDate": "2015-01-23T17:00:22.433", "OwnerUserId": "132064"}, "bq_ids": {"n4140": {"so_7743356_16796851_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 1601}, "so_7743356_16796851_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 1526}}, "n3337": {"so_7743356_16796851_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 1597}, "so_7743356_16796851_0": {"length": 22, "quality": 0.9565217391304348, "section_id": 1520}}, "n4659": {"so_7743356_16796851_2": {"length": 4, "quality": 0.6666666666666666, "section_id": 1753}, "so_7743356_16796851_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 1676}}}, "7743397": {"Id": "7743397", "PostTypeId": "2", "Body": "<p>When dealing with non-<code>char</code> instantiations of <code>std::basic_string&lt;&gt;</code>, sure, length may not equal number of bytes. This is particularly evident with <code>std::wstring</code>:</p>\n<pre><code>std::wstring ws = L\"hi\";\ncout &lt;&lt; ws.length();     // &lt;-- 2, not 4\n</code></pre>\n<p>But <code>std::string</code> is about <code>char</code> characters; there is no such thing as a multi-byte character as far as <code>std::string</code> is concerned, whether you crammed one in at a high level or not. So, <code>std::string.length()</code> is always the number of bytes represented by the string. Note that if you're cramming multibyte \"characters\" into an <code>std::string</code>, then your definition of \"character\" suddenly becomes at odds with that of the container and of the standard.</p>\n", "LastActivityDate": "2011-10-12T16:33:21.277", "Score": "20", "CreationDate": "2011-10-12T16:33:21.277", "ParentId": "7743356", "CommentCount": "6", "OwnerUserId": "560648"}, "7743467": {"Id": "7743467", "PostTypeId": "2", "Body": "<p>If we are talking specifically about <code>std::string</code>, then <code>length()</code> <strong>does</strong> return the number of bytes.</p>\n<p>This is because a <code>std::string</code> is a <code>basic_string</code> of <code>char</code>s, and the C++ Standard defines the size of one <code>char</code> to be exactly one byte.</p>\n<p>Note that the Standard doesn't say how many bits are in a byte, but that's another story entirely and you probably don't care.</p>\n<p>EDIT:  The Standard does say that an implementation shall provide a definition for <code>CHAR_BIT</code> which says how many bits are in a byte.</p>\n<p>By the way, if you go down a road where you do care how many bits are in a byte, you might consider reading <a href=\"https://stackoverflow.com/q/4329777/241536\">this</a>.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2011-10-12T17:08:51.160", "Score": "8", "CreationDate": "2011-10-12T16:39:04.700", "ParentId": "7743356", "CommentCount": "4", "LastEditDate": "2017-05-23T12:00:16.653", "OwnerUserId": "241536"}, "16796851": {"Id": "16796851", "PostTypeId": "2", "Body": "<p>cplusplus.com is not \"the documentation\" for <code>std::string</code>, it's a poor quality site full of poor quality information. The C++ standard defines it very clearly:</p>\n<ul>\n<li><p>21.1 [strings.general] \u00b61</p>\n<blockquote>\n<p id=\"so_7743356_16796851_0\">This Clause describes components for manipulating sequences of any non-array POD (3.9) type. In this Clause such types are called <em>char-like types</em>, and objects of char-like types are called <em>char-like objects</em> or simply <em>characters</em>.</p>\n</blockquote></li>\n<li><p>21.4.4 [string.capacity] \u00b61</p>\n<blockquote>\n<p id=\"so_7743356_16796851_1\"><code>size_type size() const noexcept;</code><br>\n<em>Returns:</em> A count of the number of char-like objects currently in the string.<br>\n<em>Complexity:</em> constant time.  </br></br></p>\n<p id=\"so_7743356_16796851_2\"><code>size_type length() const noexcept;</code><br>\n<em>Returns:</em> <code>size()</code></br></p>\n</blockquote></li>\n</ul>\n", "LastActivityDate": "2013-05-28T16:17:09.520", "Score": "0", "CreationDate": "2013-05-28T16:17:09.520", "ParentId": "7743356", "CommentCount": "0", "OwnerUserId": "981959"}, "7743356": {"ViewCount": "8761", "Body": "<p>I'm having some trouble figuring out the exact semantics of <code>std::string.length()</code>.\nThe <a href=\"http://www.cplusplus.com/reference/string/string/length/\" rel=\"noreferrer\">documentation</a> explicitly points out that <code>length()</code> returns the number of characters in the string and <em>not</em> the number of bytes. I was wondering in which cases this actually makes a difference.</p>\n<p>In particular, is this only relevant to non-char instantiations of <code>std::basic_string&lt;&gt;</code> or can I also get into trouble when storing UTF-8 strings with multi-byte characters? Does the standard allow for <code>length()</code> to be UTF8-aware?</p>\n", "AcceptedAnswerId": "7743397", "Title": "Length of a C++ std::string in bytes", "CreationDate": "2011-10-12T16:29:31.113", "Id": "7743356", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-10-12T16:39:00.963", "LastEditorUserId": "560648", "LastActivityDate": "2015-01-23T17:00:22.433", "Score": "10", "OwnerUserId": "577603", "Tags": "<c++><string><stdstring>", "AnswerCount": "4"}});