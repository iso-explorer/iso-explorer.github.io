post_cb({"23000236": {"Id": "23000236", "PostTypeId": "2", "Body": "<p>It is certainly not well-defined behaviour in general.</p>\n<p>Between the end of execution of function object, and the end of the call to <code>operator()</code>, the member <code>operator()</code> is executing on a deleted object. If the implementation reads or writes through <code>this</code>, which it is perfectly allowed to do, then you'll get read or write of a deleted object.</p>\n<p>More specifically, the object was only just deleted by this very thread, so it's highly unlikely that any thread actually got around to using it between deletion and the read/write or it was unmapped, so it's quite unlikely to actually cause problems in a simple program. In addition, there's little <em>apparent</em> reason for the implementation to read or write to <code>this</code> after it returns.</p>\n<p>However, Valgrind is quite correct that any such read or write would be very invalid and in some circumstances, could lead to random crashes or memory corruption. It's easy to suggest that, between deleting <code>this</code> and a hypothetical read/write, this thread was pre-empted and another thread allocated and used that memory. Alternatively, the memory allocator decided it had enough cached memory of this size and returned this segment to the OS immediately upon freeing it. This is an excellent candidate for a Heisenbug since the conditions to cause it would be relatively rare and only apparent in real complex executing systems rather than trivial test programs.</p>\n<p>You could get away with it <em>if</em> you can prove that there are no reads or writes after the function object finishes returning. This basically means guaranteeing the implementation of <code>std::function&lt;Sig&gt;::operator()</code>.</p>\n<p>Edit:</p>\n<p>Mats Peterson's answer raises an interesting question. GCC appears to have implemented the lambda by doing something like this:</p>\n<pre><code>struct lambda { std::function&lt;void()&gt;* f; };\nvoid lambda_operator(lambda* l) {\n    l-&gt;f-&gt;~std::function&lt;void()&gt;();\n    ::operator delete(l-&gt;f);\n}\n</code></pre>\n<p>As you can see, the call to <code>operator delete</code> makes a load from <code>l</code> after it's just been deleted, which is exactly the scenario I described above. I'm not actually sure what C++11's memory model rules say about this, I would have thought it was illegal but not necessarily. It might not be defined either way. If it is not illegal, you are definitely screwed.</p>\n<p>Clang, however, seems to generate this operator:</p>\n<pre><code>void lambda_operator(lambda* l) {\n    auto f = l-&gt;f;\n    f-&gt;~std::function&lt;void()&gt;();\n    ::operator delete(f);\n}\n</code></pre>\n<p>Here when <code>l</code> is deleted it doesn't matter because <code>f</code> was copied into local storage.</p>\n<p>To a certain extent, this definitively answers your question- GCC <em>absolutely does</em> load from the memory of the lambda after it's been deleted. Whether or not that's Standard-legal or not, I'm not sure. You could definitely work around this by employing a user-defined function. You'd still have the problem of the std::function implementation issuing loads or stores to <code>this</code>, though.</p>\n", "LastEditorUserId": "298661", "LastActivityDate": "2014-04-10T22:54:52.237", "Score": "2", "CreationDate": "2014-04-10T22:28:42.440", "ParentId": "22998364", "CommentCount": "7", "OwnerUserId": "298661", "LastEditDate": "2014-04-10T22:54:52.237"}, "23001854": {"Id": "23001854", "PostTypeId": "2", "Body": "<p>The problem is not related to lambdas or std::function, but rather the semantics of delete. This code exhibits the same problem:</p>\n<pre><code>class A;\n\nclass B {\n    public:\n        B(A *a_) : a(a_) {}\n        void foo();\n    private:\n        A *const a;\n};\n\nclass A {\n    public:\n        A() : b(new B(this)) {}\n        ~A() {\n            delete b;\n        }\n        void foo() { b-&gt;foo(); }\n    private:\n        B *const b;\n};\n\nvoid B::foo() {\n    delete a;\n}\n\nint main() {\n    A *ap = new A;\n    ap-&gt;foo();\n}\n</code></pre>\n<p>The issue is the semantics of delete. Is it allowed to load the operand again from memory after calling its destructor, in order to free its memory?</p>\n", "LastActivityDate": "2014-04-11T01:15:35.190", "CommentCount": "2", "CreationDate": "2014-04-11T01:15:35.190", "ParentId": "22998364", "Score": "1", "OwnerUserId": "3521733"}, "22999805": {"Id": "22999805", "PostTypeId": "2", "Body": "<p>It will probably not crash in the a general case, but WHY on earth would you ever want to do something like that in the first place. </p>\n<p>But here's my analysis:</p>\n<p>valgrind produces:</p>\n<pre><code>==7323==    at 0x4008B5: _ZZ3fooILm0EEvvENKUlvE_clEv (in /home/MatsP/src/junk/a.out)\n==7323==    by 0x400B4A: _ZNSt17_Function_handlerIFvvEZ3fooILm0EEvvEUlvE_E9_M_invokeERKSt9_Any_data (in /home/MatsP/src/junk/a.out)\n==7323==    by 0x4009DB: std::function&lt;void ()()&gt;::operator()() const (in /home/MatsP/src/junk/a.out)\n==7323==    by 0x40090A: void foo&lt;0ul&gt;() (in /home/MatsP/src/junk/a.out)\n==7323==    by 0x4007E8: main (in /home/MatsP/src/junk/a.out)\n</code></pre>\n<p>This points at the code here (which is indeed the lambda function in your original code):</p>\n<pre><code>000000000040088a &lt;_ZZ3fooILm0EEvvENKUlvE_clEv&gt;:\n  40088a:   55                      push   %rbp\n  40088b:   48 89 e5                mov    %rsp,%rbp\n  40088e:   48 83 ec 10             sub    $0x10,%rsp\n  400892:   48 89 7d f8             mov    %rdi,-0x8(%rbp)\n  400896:   48 8b 45 f8             mov    -0x8(%rbp),%rax\n  40089a:   48 8b 00                mov    (%rax),%rax\n  40089d:   48 85 c0                test   %rax,%rax   ;; Null check - don't delete if null. \n  4008a0:   74 1e                   je     4008c0 &lt;_ZZ3fooILm0EEvvENKUlvE_clEv+0x36&gt;\n  4008a2:   48 8b 45 f8             mov    -0x8(%rbp),%rax\n  4008a6:   48 8b 00                mov    (%rax),%rax\n  4008a9:   48 89 c7                mov    %rax,%rdi\n;; Call function destructor\n  4008ac:   e8 bf ff ff ff          callq  400870 &lt;_ZNSt8functionIFvvEED1Ev&gt;  \n  4008b1:   48 8b 45 f8             mov    -0x8(%rbp),%rax\n  4008b5:   48 8b 00                mov    (%rax),%rax           ;; invalid access\n  4008b8:   48 89 c7                mov    %rax,%rdi\n;; Call delete. \n  4008bb:   e8 b0 fd ff ff          callq  400670 &lt;_ZdlPv@plt&gt;   ;; delete\n  4008c0:   c9                      leaveq \n  4008c1:   c3                      retq   \n</code></pre>\n<p>Interestingly, it \"works\" using clang++ (version 3.5, built from git sha1 d73449481daee33615d907608a3a08548ce2ba65, from March 31st):</p>\n<pre><code>0000000000401050 &lt;_ZZ3fooILm0EEvvENKUlvE_clEv&gt;:\n  401050:   55                      push   %rbp\n  401051:   48 89 e5                mov    %rsp,%rbp\n  401054:   48 83 ec 10             sub    $0x10,%rsp\n  401058:   48 89 7d f8             mov    %rdi,-0x8(%rbp)\n  40105c:   48 8b 7d f8             mov    -0x8(%rbp),%rdi\n  401060:   48 8b 3f                mov    (%rdi),%rdi\n  401063:   48 81 ff 00 00 00 00    cmp    $0x0,%rdi   ;; Null check. \n  40106a:   48 89 7d f0             mov    %rdi,-0x10(%rbp)\n  40106e:   0f 84 12 00 00 00       je     401086 &lt;_ZZ3fooILm0EEvvENKUlvE_clEv+0x36&gt; \n  401074:   48 8b 7d f0             mov    -0x10(%rbp),%rdi\n  401078:   e8 d3 fa ff ff          callq  400b50 &lt;_ZNSt8functionIFvvEED2Ev&gt;   \n;; Function destructor \n  40107d:   48 8b 7d f0             mov    -0x10(%rbp),%rdi\n  401081:   e8 7a f6 ff ff          callq  400700 &lt;_ZdlPv@plt&gt;    ;; delete. \n  401086:   48 83 c4 10             add    $0x10,%rsp\n  40108a:   5d                      pop    %rbp\n  40108b:   c3                      retq   \n</code></pre>\n<p>Edit: It doesn't really make any sense - I don't see why there is a memory access to the first element inside the function class in gcc's code and not in clang's - they are supposed to do the same thing... </p>\n", "LastEditorUserId": "1919155", "LastActivityDate": "2014-04-10T22:18:48.650", "Score": "0", "CreationDate": "2014-04-10T21:55:02.830", "ParentId": "22998364", "CommentCount": "2", "OwnerUserId": "1919155", "LastEditDate": "2014-04-10T22:18:48.650"}, "23002021": {"Id": "23002021", "PostTypeId": "2", "Body": "<p>This program has well-defined behavior and demonstrates a g++ bug.</p>\n<p>The only questionable part of runtime is during the statement <code>(*f)();</code>.  The behavior of that line can be picked apart piece by piece.  The Standard section numbers below are from N3485; apologies if some don't match C++11.</p>\n<p><code>*f</code> is just the built-in unary operator on a raw pointer to class type.  No problem here.  The only other evaluation is the function-call expression <code>(*f)()</code>, which invokes <code>void std::function&lt;void()&gt;::operator() const</code>.  Then that full-expression is a discarded value.</p>\n<p>20.8.11.2.4:</p>\n<pre><code>R operator()(ArgTypes... args) const\n</code></pre>\n<blockquote>\n<p id=\"so_22998364_23002021_0\">Effects: <em><code>INVOKE</code></em><code>(obj, std::forward&lt;ArgTypes&gt;(args)..., R)</code> where <code>obj</code> is the target object of <code>*this</code>.</p>\n</blockquote>\n<p>(I've replaced \"<code>f</code>\" in the Standard with \"<code>obj</code>\" to reduce confusion with <code>main</code>'s <code>f</code>.)</p>\n<p>Here <code>obj</code> is a copy of the lambda object, <code>ArgTypes</code> is the empty parameter pack from the specialization <code>std::function&lt;void()&gt;</code>, and <code>R</code> is <code>void</code>.</p>\n<p>The <em><code>INVOKE</code></em> pseudo-macro is defined in 20.8.2.  Since the type of <code>obj</code> is not a pointer-to-member, <em><code>INVOKE</code></em><code>(obj, void)</code> is defined to be <code>obj()</code> implicitly converted to <code>void</code>.</p>\n<p>5.1.2p5:</p>\n<blockquote>\n<p id=\"so_22998364_23002021_1\">The closure type for a <em>lambda-expression</em> has a public <code>inline</code> function call operator ...</p>\n</blockquote>\n<p>... with exactly described declaration.  In this case it turns out to be <code>void operator() const</code>.  And its definition is exactly described too:</p>\n<p>5.1.2p7:</p>\n<blockquote>\n<p id=\"so_22998364_23002021_2\">The <em>lambda-expression</em>'s <em>compound-statement</em> yields the <em>function-body</em> of the function call operator, but for purposes of name lookup, determining the type and value of <code>this</code> and transforming <em>id-expressions</em> referring to non-static class members into class member access expressions using <code>(*this)</code>, the <em>compound-statement</em> is considered in the context of the <em>lambda-expression</em>.</p>\n</blockquote>\n<p>5.1.2p14:</p>\n<blockquote>\n<p id=\"so_22998364_23002021_3\">For each entity captured by copy, an unnamed non-static data member is declared in the closure type.</p>\n</blockquote>\n<p>5.1.2p17:</p>\n<blockquote>\n<p id=\"so_22998364_23002021_4\">Every <em>id-expression</em> that is an odr-use of an entity captured by copy is transformed into an access to the corresponding unnamed data member of the closure type.</p>\n</blockquote>\n<p>So the lambda function call operator must be equivalent to:</p>\n<pre><code>void __lambda_type::operator() const {\n    delete __unnamed_member_f;\n}\n</code></pre>\n<p>(where I've invented some names for the unnamed lambda type and unnamed data member.)</p>\n<p>The single statement of that call operator is of course equivalent to <code>delete (*this).__unnamed_member_f;</code>  So we have:</p>\n<ul>\n<li>The built-in unary <code>operator*</code> dereference (on the prvalue <code>this</code>)</li>\n<li>A member access expression</li>\n<li>A value computation (aka lvalue-to-rvalue conversion) for the member subobject</li>\n<li>A scalar <code>delete</code> expression\n<ul>\n<li>Invokes <code>std::function&lt;void()&gt;::~function()</code></li>\n<li>Invokes <code>void operator delete(void*)</code></li>\n</ul></li>\n</ul>\n<p>And finally, in 5.3.5p4:</p>\n<blockquote>\n<p id=\"so_22998364_23002021_5\">The <em>cast-expression</em> in a <em>delete-expression</em> shall be evaluated exactly once.</p>\n</blockquote>\n<p>(Here is where g++ is wrong, doing a second value computation on the member subobject between the destructor call and the deallocation function.)</p>\n<p>This code cannot cause any other value computations or side effects after the <code>delete</code> expression.</p>\n<p>There are some allowances for implementation-defined behavior in lambda types and lambda objects, but none that affect anything above:</p>\n<p>5.1.2p3:</p>\n<blockquote>\n<p id=\"so_22998364_23002021_6\">An implementation may define the closure type differently from what is described below provided this does not alter the observable behavior of the program other than by changing:</p>\n<ul>\n<li><p id=\"so_22998364_23002021_7\">the size and/or alignment of the closure type,</p></li>\n<li><p id=\"so_22998364_23002021_8\">whether the closure type is trivially copyable,</p></li>\n<li><p id=\"so_22998364_23002021_9\">whether the closure type is a standard-layout class, or</p></li>\n<li><p id=\"so_22998364_23002021_10\">whether the closure type is a POD class.</p></li>\n</ul>\n</blockquote>\n", "LastActivityDate": "2014-04-11T01:35:11.937", "CommentCount": "8", "CreationDate": "2014-04-11T01:35:11.937", "ParentId": "22998364", "Score": "5", "OwnerUserId": "459640"}, "bq_ids": {"n4140": {"so_22998364_23002021_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 6108}, "so_22998364_23002021_2": {"length": 29, "quality": 0.9666666666666667, "section_id": 5966}, "so_22998364_23002021_10": {"length": 5, "quality": 1.0, "section_id": 5962}, "so_22998364_23002021_9": {"length": 5, "quality": 1.0, "section_id": 5962}, "so_22998364_23002021_4": {"length": 15, "quality": 1.0, "section_id": 5977}, "so_22998364_23002021_7": {"length": 5, "quality": 1.0, "section_id": 5962}, "so_22998364_23002021_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 5964}, "so_22998364_23002021_6": {"length": 17, "quality": 1.0, "section_id": 5962}, "so_22998364_23002021_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 5974}, "so_22998364_23002021_8": {"length": 5, "quality": 1.0, "section_id": 5962}, "so_22998364_23002021_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 4680}}, "n3337": {"so_22998364_23002021_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 5874}, "so_22998364_23002021_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 5742}, "so_22998364_23002021_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 4489}, "so_22998364_23002021_9": {"length": 5, "quality": 1.0, "section_id": 5731}, "so_22998364_23002021_4": {"length": 15, "quality": 1.0, "section_id": 5745}, "so_22998364_23002021_7": {"length": 5, "quality": 1.0, "section_id": 5731}, "so_22998364_23002021_10": {"length": 5, "quality": 1.0, "section_id": 5731}, "so_22998364_23002021_6": {"length": 17, "quality": 1.0, "section_id": 5731}, "so_22998364_23002021_2": {"length": 29, "quality": 0.9666666666666667, "section_id": 5735}, "so_22998364_23002021_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 5733}, "so_22998364_23002021_8": {"length": 5, "quality": 1.0, "section_id": 5731}}, "n4659": {"so_22998364_23002021_5": {"length": 5, "quality": 0.8333333333333334, "section_id": 7605}, "so_22998364_23002021_2": {"length": 29, "quality": 0.9666666666666667, "section_id": 7460}, "so_22998364_23002021_8": {"length": 5, "quality": 1.0, "section_id": 7452}, "so_22998364_23002021_9": {"length": 5, "quality": 1.0, "section_id": 7452}, "so_22998364_23002021_4": {"length": 15, "quality": 1.0, "section_id": 7474}, "so_22998364_23002021_7": {"length": 5, "quality": 1.0, "section_id": 7452}, "so_22998364_23002021_10": {"length": 5, "quality": 1.0, "section_id": 7452}, "so_22998364_23002021_6": {"length": 17, "quality": 1.0, "section_id": 7452}, "so_22998364_23002021_3": {"length": 11, "quality": 0.9166666666666666, "section_id": 7473}, "so_22998364_23002021_1": {"length": 8, "quality": 0.8888888888888888, "section_id": 7453}, "so_22998364_23002021_0": {"length": 4, "quality": 0.5714285714285714, "section_id": 6051}}}, "23000336": {"Id": "23000336", "PostTypeId": "2", "Body": "<p>The allocation <code>auto f = new std::function&lt;void()&gt;;</code> of course is alright. The definition of the lambda <code>*f = [f]() { delete f; };</code> works as well, as it is not executed yet.</p>\n<p>Now the interesting thing is <code>(*f)();</code>. First it dereferences <code>f</code>, then calls <code>operator()</code> and finally executes <code>delete f</code>. Calling <code>delete f</code> in the class member function <code>function&lt;&gt;::operator()</code> is the same as calling <code>delete this</code>. <a href=\"http://www.parashift.com/c++-faq-lite/delete-this.html\" rel=\"nofollow\">Under certain cirqumstances</a> this is legal.</p>\n<p>So it depends on how <code>operator()</code> for <code>std::function</code> and lamdabs is implemented. Your code would be valid if it is guaranteed that no member function, member variable or the this pointer itself are used or even touched by <code>operator()</code> after executing your encapsulated lambda.</p>\n<p>I would say there is no need for <code>std::function</code> to call other member functions or use member variables in <code>operator()</code> after executing your lambda. So you will probably find implementations for which your code is legal, but in general it is probably not safe to assume so.</p>\n", "LastEditorUserId": "316448", "LastActivityDate": "2014-04-10T22:49:14.673", "Score": "0", "CreationDate": "2014-04-10T22:36:40.167", "ParentId": "22998364", "CommentCount": "0", "OwnerUserId": "316448", "LastEditDate": "2014-04-10T22:49:14.673"}, "23971572": {"Id": "23971572", "PostTypeId": "2", "Body": "<p>See <a href=\"http://cplusplus.github.io/LWG/lwg-active.html#2224\" rel=\"nofollow\">http://cplusplus.github.io/LWG/lwg-active.html#2224</a>.</p>\n<p>Accessing a library type after its destructor has started is undefined behavior. Lambdas are not library types, so they don't have such a limitation. Once a destructor of a library type has been entered, the invariants of that library type no longer hold. The language doesn't enforce such a limitation because invariants are by and large a library concept, not a language concept.</p>\n", "LastActivityDate": "2014-05-31T15:10:52.583", "CommentCount": "0", "CreationDate": "2014-05-31T15:10:52.583", "ParentId": "22998364", "Score": "0", "OwnerUserId": "1315421"}, "22998364": {"ViewCount": "1584", "Body": "<p>Is this well defined behavior?</p>\n<pre><code>#include &lt;functional&gt;\n\nvoid foo() {\n    auto f = new std::function&lt;void()&gt;;\n    *f = [f]() { delete f; };\n    (*f)();\n    f = nullptr;\n}\n\nint main() {\n    foo();\n}\n</code></pre>\n<p>Using the most recent g++, if I do this within a template it causes invalid reads while running under valgrind, otherwise it works fine. Why? Is this a bug in g++?</p>\n<pre><code>#include &lt;functional&gt;\n\ntemplate&lt;std::size_t&gt;\nvoid foo() {\n    auto f = new std::function&lt;void()&gt;;\n    *f = [f]() { delete f; };\n    (*f)();\n    f = nullptr;\n}\n\nint main() {\n    foo&lt;0&gt;();\n}\n</code></pre>\n", "AcceptedAnswerId": "23002021", "Title": "Deleting a std::function object within itself", "CreationDate": "2014-04-10T20:29:03.663", "Id": "22998364", "CommentCount": "39", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-04-10T21:36:20.743", "LastEditorDisplayName": "user2005303", "OwnerDisplayName": "user2005303", "LastActivityDate": "2014-05-31T15:10:52.583", "Score": "6", "Tags": "<c++><c++11><lambda><std-function>", "AnswerCount": "6"}});