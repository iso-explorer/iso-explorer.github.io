post_cb({"17645573": {"ParentId": "17644816", "PostTypeId": "2", "CommentCount": "1", "Body": "<h1>Built-in operators</h1>\n<h2>Why you cannot have function pointers of them:</h2>\n<h3>C++11, \u00a713.6/1, [over.built]</h3>\n<blockquote>\n<p id=\"so_17644816_17645573_0\"><strong>The candidate operator functions that represent the built-in operators</strong> defined in Clause 5 are specified in this subclause. These candidate functions <strong>participate in the operator overload resolution</strong> process as described in 13.3.1.2 <strong>and are used for no other purpose</strong>.</p>\n</blockquote>\n<p><em>Built-in operators</em> (those for the built-in types) aren't real <em>operator functions</em>. So you can't have function pointer pointing to them. You also cannot invoke them using <code>operator&lt;(A,B)</code> syntax.\nThey only participate in overload resolution but the compiler will translate them directly into the appropriate asm/machine instruction without any kind of \"function call\".</p>\n<h2>The way to get around this issue:</h2>\n<p><a href=\"https://stackoverflow.com/a/17644939/\">user1034749 has already answered</a> this question, but for completeness:</p>\n<p>The standard defines a lot of function objects in <em>\u00a720.8, [function.objects]</em>, i.e.</p>\n<ul>\n<li>Arithmetic operations </li>\n<li>Comparisons </li>\n<li>Logic operations</li>\n<li>Bitwise operations </li>\n</ul>\n<blockquote>\n<p id=\"so_17644816_17645573_1\">A function object is an object of a function object type. In the places where one would expect to pass a pointer to a function to an algorithmic template (Clause 25), the interface is specified to accept a function object. This not only makes algorithmic templates work with pointers to functions, but also enables them to work with arbitrary function objects.</p>\n</blockquote>\n<h3>C++11, \u00a720.8.5, [comparisons]</h3>\n<blockquote id=\"so_17644816_17645573_2\">\n<ul>\n<li>equal_to</li>\n<li>not_equal_to</li>\n<li>greater, less</li>\n<li>greater_equal</li>\n<li>less_equal</li>\n</ul>\n</blockquote>\n<p>Those are templated function objects which decay to the analogous operator in their <code>operator()</code> function. They can be used as function pointer arguments.</p>\n<p>user1034749 is right, I want to state: <strong>There's no other way, these are completely equivalent in usage to 'raw' function pointers.</strong> Reference given.</p>\n<h1>Standard class type operators</h1>\n<p>You can use standard library operators as function pointers (which are present as \"real functions\").</p>\n<p>But you'll have to refer to the respective instance of the template. The compiler will need appropriate hints to deduce the correct template.</p>\n<p>This works for me on MSVC 2012 using <code>operator+</code> of <code>std::basic_string</code></p>\n<pre><code>template&lt;class Test&gt;\nTest test_function (Test const &amp;a, Test const &amp;b, Test (*FPtr)(Test const &amp;, Test const &amp;))\n{\n   return FPtr(a, b);\n}\n\nint main(int argc, char* argv[])\n{\n   typedef std::char_traits&lt;char&gt; traits_t;\n   typedef std::allocator&lt;char&gt; alloc_t;\n   std::basic_string&lt;char, traits_t, alloc_t&gt; a(\"test\"), b(\"test2\");\n   std::cout &lt;&lt; test_function&lt;std::basic_string&lt;char, traits_t, alloc_t&gt;&gt;(a, b, &amp;std::operator+) &lt;&lt; std::endl;\n   return 0;\n}\n</code></pre>\n<p>If the template argument of <code>test_function</code> is left out to be deduced this will fail (at least for MSVC 2012).</p>\n", "OwnerUserId": "951423", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:13:47.523", "Id": "17645573", "Score": "15", "CreationDate": "2013-07-15T01:36:45.043", "LastActivityDate": "2013-07-16T23:41:13.207"}, "17644816": {"CommentCount": "9", "ViewCount": "1228", "PostTypeId": "1", "LastEditorUserId": "1413395", "CreationDate": "2013-07-14T23:27:27.527", "LastActivityDate": "2013-07-16T23:41:13.207", "Title": "Is it possible to get the function pointer of a built-in standard operator?", "AcceptedAnswerId": "17645573", "LastEditDate": "2013-07-16T21:38:48.543", "Id": "17644816", "Score": "8", "Body": "<p>I want to refer to function pointers of built-in operators, but I don't know how to specify the specific type overloads.</p>\n<p>I have the following template class signature:</p>\n<pre><code>template&lt;typename ParamsType, typename FnCompareType&gt;\nclass MyAction\n{\npublic:\n    MyAction(ParamsType&amp; arg0, ParamsType&amp; arg1, FnCompareType&amp; fnCpmpare) \n    : arg0_(arg0), arg1_(arg1), fnCompare_(fnCpmpare) {}\n\n    bool operator()()\n    {\n        if((*fnCompare_)(arg0_,arg1_)\n        {\n            // do this\n        }\n        else\n        {\n            // do s.th. else\n        }\n    }\n\nprivate:\n    ParamsType&amp; arg0_;\n    ParamsType&amp; arg1_;\n    FnCompareType&amp; fnCompare_;\n}\n</code></pre>\n<p>And want to use a syntax like this:</p>\n<pre><code>void doConditional(int param1, int param2)\n{\n    MyAction&lt;int,&amp;::operator&gt;=&gt; action(param1,param2);\n    if(action())\n    {\n        // Do this\n    }\n    else\n    {\n        // Do that\n    }\n}\n</code></pre>\n<p>But that doesn't compile:</p>\n<pre><code>error: \u2018::operator&gt;=\u2019 has not been declared\n</code></pre>\n<p>What can I do to refer to such intrinsic static operations?</p>\n", "Tags": "<c++><operators>", "OwnerUserId": "1413395", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_17644816_17645573_2": {"section_id": 4605, "quality": 0.6666666666666666, "length": 4}, "so_17644816_17645573_0": {"section_id": 675, "quality": 0.8695652173913043, "length": 20}, "so_17644816_17645573_1": {"section_id": 4548, "quality": 0.972972972972973, "length": 36}}, "n3337": {"so_17644816_17645573_2": {"section_id": 4423, "quality": 0.6666666666666666, "length": 4}, "so_17644816_17645573_0": {"section_id": 665, "quality": 0.8695652173913043, "length": 20}, "so_17644816_17645573_1": {"section_id": 4378, "quality": 0.972972972972973, "length": 36}}, "n4659": {"so_17644816_17645573_0": {"section_id": 703, "quality": 0.8695652173913043, "length": 20}, "so_17644816_17645573_1": {"section_id": 5922, "quality": 0.972972972972973, "length": 36}}}, "17644939": {"ParentId": "17644816", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>You can use the same solution as used in C++ standard library:</p>\n<pre><code>std::sort (numbers, numbers+5, std::greater&lt;int&gt;());\n</code></pre>\n<p>where greater is</p>\n<pre><code>template &lt;class T&gt; struct greater : binary_function &lt;T,T,bool&gt; {\n    bool operator() (const T&amp; x, const T&amp; y) const {return x&gt;y;}\n};\n</code></pre>\n<p>in your case <a href=\"http://www.cplusplus.com/reference/functional/greater_equal/\" rel=\"nofollow\">http://www.cplusplus.com/reference/functional/greater_equal/</a></p>\n<p>About reference of built operator.</p>\n<p>You can reference existing operator&lt; for any class (of course if they are not private, protected or your class/function not friend).\nBut opeator&lt; for builtin types (bool, short, int, double) it is not possible reference.\nEvent if not look at C++ standard you can see from my text above.</p>\n", "OwnerUserId": "1034749", "LastEditorUserId": "1413395", "LastEditDate": "2013-07-16T23:25:49.037", "Id": "17644939", "Score": "6", "CreationDate": "2013-07-14T23:49:02.737", "LastActivityDate": "2013-07-16T23:25:49.037"}});