post_cb({"bq_ids": {"n4140": {"so_38767993_38768590_0": {"length": 23, "quality": 0.8518518518518519, "section_id": 3242}}, "n3337": {"so_38767993_38768590_0": {"length": 23, "quality": 0.8518518518518519, "section_id": 3115}}, "n4659": {"so_38767993_38768590_0": {"length": 23, "quality": 0.8518518518518519, "section_id": 3999}}}, "38768590": {"Id": "38768590", "PostTypeId": "2", "Body": "<p>There is no such thing as a <code>const</code> function type:</p>\n<p>[dcl.fct]/6:</p>\n<blockquote>\n<p id=\"so_38767993_38768590_0\">The effect of a cv-qualifier-seq in a function declarator is not the same as adding cv-qualification on top\n  of the function type. In the latter case, the cv-qualifiers are ignored. [Note: a function type that has a\n  cv-qualifier-seq is not a cv-qualified type; there are no cv-qualified function types. \u2014end note]</p>\n</blockquote>\n<p>You will have to write your own type trait:</p>\n<pre><code>template&lt;typename T&gt;\nstruct remove_cv_seq;\n\ntemplate&lt;typename R, typename... Args&gt;\nstruct remove_cv_seq&lt;R (Args...) const&gt; {\n    using type = R (Args...);\n};\n\ntemplate&lt;typename R, typename... Args&gt;\nstruct remove_cv_seq&lt;R (Args...)&gt; {\n    using type = R (Args...);\n};\n\nstruct Foo {\n    remove_cv_seq&lt;void () const&gt;::type bar;\n};\n\nint main()\n{\n    Foo const x;\n    x.bar(); // This will fail to compile because it tries to call non-const member function.\n}\n</code></pre>\n", "LastEditorUserId": "2491746", "LastActivityDate": "2016-08-04T13:29:38.913", "Score": "2", "CreationDate": "2016-08-04T13:23:11.290", "ParentId": "38767993", "CommentCount": "4", "OwnerUserId": "2491746", "LastEditDate": "2016-08-04T13:29:38.913"}, "38767993": {"ViewCount": "96", "Body": "<p>I'm trying to extract the return and argument types of a member function without having to bother with <code>const</code> and <code>volatile</code> overloads, but it seems to me, that <code>::std::remove_cv&lt;&gt;</code> does not work with function types:</p>\n<pre><code>template &lt;typename&gt;\nstruct signature\n{\n};\n\ntemplate &lt;typename R, typename ...A&gt;\nstruct signature&lt;R(A...)&gt;\n{\n};\n\ntemplate &lt;typename C, typename F&gt;\nconstexpr auto extract_function_type(F C::* const) noexcept\n{\n  return signature&lt;::std::remove_cv_t&lt;F&gt;&gt;();\n}\n\ntemplate &lt;typename F&gt;\nconstexpr auto extract_signature(F const&amp;) noexcept -&gt;\n  decltype(&amp;F::operator(), extract_function_type(&amp;F::operator()))\n{\n  return extract_function_type(&amp;F::operator());\n}\n</code></pre>\n", "AcceptedAnswerId": "38768590", "Title": "should ::std::remove_cv<> work on function types?", "CreationDate": "2016-08-04T12:56:47.453", "Id": "38767993", "CommentCount": "0", "LastEditDate": "2016-08-04T13:03:25.687", "PostTypeId": "1", "LastEditorUserId": "1095108", "LastActivityDate": "2016-08-04T13:29:38.913", "Score": "2", "OwnerUserId": "1095108", "Tags": "<c++><c++1z>", "AnswerCount": "1"}});