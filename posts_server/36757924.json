post_cb({"36758041": {"ParentId": "36757924", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2016-04-21T01:32:17.247", "Score": "-1", "LastEditorUserId": "2224280", "LastEditDate": "2016-04-21T02:19:47.377", "Id": "36758041", "OwnerUserId": "2224280", "Body": "<p>The <strong>semantics</strong> of abc[x] is \"Add x*sizeof(type)\" to abc where abc is any memory pointer. Arrays variable behave like memory pointers and they just point to beginning of the memory location allocated to array.</p>\n<p>Hence adding x to array or pointer variable both will point to memory which is same as variable pointing to + x*sizeof(type which array contains or pointer points to, e.g. in case of int pointers or int array it's 4)</p>\n<p>Array variables are not same as pointer as said in comment by Keith as array declaration will create fix sized memory block and any arithmetic on that will use size of array not the element types in that array. </p>\n", "LastActivityDate": "2016-04-21T02:19:47.377"}, "36758186": {"ParentId": "36757924", "PostTypeId": "2", "CommentCount": "7", "CreationDate": "2016-04-21T01:49:00.863", "Score": "1", "LastEditorUserId": "6233040", "LastEditDate": "2016-04-22T06:08:30.087", "Id": "36758186", "OwnerUserId": "6233040", "Body": "<p>Pointers hold the address of memory location of variables of specific data types they are assigned to hold. As others have pointed out its counter-intutive approach take a bit of learning curve to undestand. </p>\n<p>An array uses a program's stack memory(space where we got variable/objects with automatic storage duration) to reside and work, whereas a pointer(though uses stack memory itself) can be made to point to an item in the heap memory(space where we got variable/objects with dynamic storage duration) of a program and operate on them. Though syntactically can look the same, they were created to serve different purposes in a program. So they are different.</p>\n<p>If you want to do string manipulations then I suggest you declare an int to store each character's ASCII values from the standard input output like mentioned here,</p>\n<pre><code>#include&lt;stdio.h&gt;\nint main()\n{\n    int countBlank=0,countTab=0,countNewLine=0,c;\n    while((c=getchar())!=EOF)\n    {\n        if(c==' ')\n            ++countBlank;\n        else if(c=='\\t')\n            ++countTab;\n        else if(c=='\\n')\n            ++countNewLine;\n        putchar(c);\n    }\n    printf(\"Blanks = %d\\nTabs = %d\\nNew Lines = %d\",countBlank,countTab,countNewLine);\n}\n</code></pre>\n<p>See how the integer takes ASCII values in order to get and print individual characters using getchar() and putchar(). For accessing the individual character in a string of characters you can use char pointer. But you cannot modify string data using pointer as it is done in the question.</p>\n<p>A special thanks to Keith Thompson here learnt some useful things today.</p>\n", "LastActivityDate": "2016-04-22T06:08:30.087"}, "36757924": {"CommentCount": "11", "ViewCount": "222", "PostTypeId": "1", "LastEditorUserId": "319826", "CreationDate": "2016-04-21T01:18:55.510", "LastActivityDate": "2016-04-22T06:08:30.087", "Title": "Are pointers arrays?", "AcceptedAnswerId": "36758150", "LastEditDate": "2016-04-21T07:45:09.650", "Id": "36757924", "Score": "2", "Body": "<p>Here is the code I'm having trouble to understand:</p>\n<pre><code>char* myPtr = \"example\";\nmyPtr[1] = 'x';\n</code></pre>\n<p>How am I allowed to use <code>myPtr[1]</code>? Why can I choose positions like a do on arrays? <code>myPtr</code> is not even an array.</p>\n<p>Obs. I know about lookup table, literal pooling and string literals, my concern is just how this even compile. I don't use pointers that much.</p>\n<p>Can anyone help?</p>\n", "Tags": "<c++><c><arrays><pointers>", "OwnerUserId": "6000262", "AnswerCount": "6"}, "36758316": {"ParentId": "36757924", "CommentCount": "0", "CreationDate": "2016-04-21T02:03:22.287", "OwnerUserId": "827263", "PostTypeId": "2", "Id": "36758316", "Score": "0", "Body": "<p>The most important thing to remember is this:</p>\n<p><strong>Arrays are not pointers.</strong></p>\n<p>But there are several language rules in both C and C++ that can make it seem as if they're the same thing. There are contexts in which an expression of array type or an expression of pointer type is legal. In those contexts, the expression of array type is <em>implicitly converted</em> to yield a pointer to the array's initial element.</p>\n<pre><code>char an_array[] = \"hello\";\nconst char *a_pointer = \"goodbye\";\n</code></pre>\n<p><code>an_array</code> is an array object, of type <code>char[6]</code>. The string literal <code>\"hello\"</code> is used to initialize it.</p>\n<p><code>a_pointer</code> is a pointer object, of type <code>const char*</code>. You need the <code>const</code> because the string literal used to initialize it is read-only.</p>\n<p>When an expression of array type (usually the name of an array object) appears in an expression, it is <em>usually</em> implicitly converted to a pointer to its initial (0th) element. So, for example, we can write:</p>\n<pre><code>char *ptr = an_array;\n</code></pre>\n<p><code>an_array</code> is an array expression; it's implicitly converted to a <code>char*</code> pointer. The above is exactly equivalent to:</p>\n<pre><code>char *ptr = &amp;(an_array[0]); // parentheses just for emphasis\n</code></pre>\n<p>There are 3 contexts in which an array expression is <em>not</em> converted to a pointer value:</p>\n<ol>\n<li><p>When it's the operand of the <code>sizeof</code> operator. <code>sizeof an_array</code> yields the size of the array, not the size of a pointer.</p></li>\n<li><p>When it's the operand of the unary <code>&amp;</code> operator. <code>&amp;an_array</code> yields the address of the entire array object, not the address of some (nonexistent) <code>char*</code> pointer object. It's of type \"pointer to array of 6 <code>char</code>s\", or <code>char (*)[6]</code>.</p></li>\n<li><p>When it's a string literal used as an initializer for an array object. In the example above:<br>\n<code>char an_array[] = \"hello\";</code><br>\nthe contents of the string literal <code>\"hello\"</code> are copied into <code>an_array</code>; it doesn't decay to a pointer.</br></br></p></li>\n</ol>\n<p>Finally, there's one more language rule that can make it seem as if arrays were \"really\" pointer: a parameter defined with an array type is <em>adjusted</em> so that it's really of pointer type. You can define a function like:</p>\n<pre><code>void func(char param[10]);\n</code></pre>\n<p>and it really means:</p>\n<pre><code>void func(char *param);\n</code></pre>\n<p>The <code>10</code> is silently ignored.</p>\n<p>The <code>[]</code> indexing operator requires two operands, a pointer and an integer. The pointer must point to an element of an array object. (A standalone object is treated as a 1-element array.) The expression</p>\n<pre><code>arr[i]\n</code></pre>\n<p>is by definition equivalent to</p>\n<pre><code>*(arr + i)\n</code></pre>\n<p>Adding an integer to a pointer value yields a new pointer that's advanced <code>i</code> elements forward in the array.</p>\n<p>Section 6 of the <a href=\"http://www-c.faq-com\" rel=\"nofollow\">comp.lang.c FAQ</a> has an excellent explanation of all this stuff. (It applies to C++ as well as to C; the two languages have very similar rules in this area.)</p>\n", "LastActivityDate": "2016-04-21T02:03:22.287"}, "36758232": {"ParentId": "36757924", "CommentCount": "3", "CreationDate": "2016-04-21T01:54:55.493", "OwnerUserId": "493122", "PostTypeId": "2", "Id": "36758232", "Score": "1", "Body": "<p>It compiles according to \u00a75.2.1/1 [expr.sub] of the C++ standard:</p>\n<blockquote>\n<p id=\"so_36757924_36758232_0\">A postfix expression followed by an expression in square brackets is a postfix expression. One of the expressions shall have the type \u201carray of T\u201d or \u201cpointer to T\u201d and the other shall have unscoped enumeration or integral type. The result is of type \u201cT\u201d. The type \u201cT\u201d shall be a completely-defined object type. </p>\n<p id=\"so_36757924_36758232_1\">The expression <code>E1[E2]</code> is identical (by definition) to <code>*((E1)+(E2))</code>, except that in the case of an array operand, the result is an lvalue if that operand is an lvalue and an xvalue otherwise.</p>\n</blockquote>\n<p>Since <code>\"example\"</code> has type <code>char const[8]</code> it may decay to <code>char const*</code> (it used to decay to <code>char*</code> as well, but it's mostly a relict of the past) which makes it a pointer. </p>\n<p>At which point the expression <code>myPtr[1]</code> becomes <code>*(myPtr + 1)</code> which is well defined.</p>\n", "LastActivityDate": "2016-04-21T01:54:55.493"}, "36758473": {"ParentId": "36757924", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2016-04-21T02:23:03.580", "Score": "0", "LastEditorUserId": "2785528", "LastEditDate": "2016-04-21T15:17:22.223", "Id": "36758473", "OwnerUserId": "2785528", "Body": "<p>In C++,  your code generates a warning during compile:</p>\n<pre><code>{\n  //char* myPtr = \"example\";  // ISO C++ forbids converting a string \n                              // constant to \u2018char*\u2019 [-Wpedantic]\n\n  // instead you should use the following form\n  char myPtr[] = \"example\";  // a c-style null terminated string\n\n  // the myPtr symbol is also treated as a char*, and not a const char*\n\n  myPtr[1] = 'k';  // still works,  \n\n  std::cout &lt;&lt; myPtr &lt;&lt; std::endl;  // output is 'ekample'\n}\n</code></pre>\n<p>On the other hand, std::string is much more flexible, and has many more features:</p>\n<pre><code> {\n   std::string myPtr = \"example\";\n\n   myPtr[1] = 'k';  // works the same\n\n   // then, to print the corresponding null terminated c-style string\n   std::cout &lt;&lt; myPtr.c_str() &lt;&lt; std::endl;\n\n   //  \".c_str()\" is useful to create input to system calls requiring\n   //   null terminated c-style strings\n }\n</code></pre>\n", "LastActivityDate": "2016-04-21T15:17:22.223"}, "bq_ids": {"n4140": {"so_36757924_36758232_1": {"section_id": 5986, "quality": 0.9375, "length": 15}, "so_36757924_36758232_0": {"section_id": 5986, "quality": 0.9285714285714286, "length": 26}}, "n3337": {"so_36757924_36758232_0": {"section_id": 5754, "quality": 0.8928571428571429, "length": 25}}, "n4659": {"so_36757924_36758232_1": {"section_id": 7486, "quality": 0.9375, "length": 15}, "so_36757924_36758232_0": {"section_id": 7486, "quality": 0.8571428571428571, "length": 24}}}, "36758150": {"ParentId": "36757924", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2016-04-21T01:45:18.770", "Score": "10", "LastEditorUserId": "187690", "LastEditDate": "2016-04-21T16:56:32.250", "Id": "36758150", "OwnerUserId": "187690", "Body": "<p>Apparently you made an assumption that applicability of <code>[]</code> operator to something necessarily implies that that \"something\" is an array. This is not true. The built-in <code>[]</code> operator has no direct relation to arrays. The <code>[]</code> is just a shorthand for a combination of <code>*</code> and <code>+</code> operators: by definition <code>a[b]</code> means <code>*(a + b)</code>, where one operand is required to be a pointer and another is required to be an integer. </p>\n<p>Moreover, when you apply the <code>[]</code> operator to an actual array, that array gets implicitly converted to a pointer type first, and only then the resultant pointer can act as an operand of <code>[]</code> operator. This actually means the opposite of what you supposedly assumed initially: operator <code>[]</code> <em>never</em> works with arrays. By the time we get to the <code>[]</code> the array has already decayed to a pointer.</p>\n<p>As a related side-note, this latter detail manifests itself in one obscure peculiarity of the first C language standard. In C89/90 the array-to-pointer conversion was not allowed for rvalue arrays, which also prevented the <code>[]</code> operator from working with such arrays</p>\n<pre><code>struct S { int a[10]; };\n\nstruct S foo(void) { struct S s = { 0 }; return s; }\n\nint main() \n{\n  foo().a[5]; \n  /* ERROR: cannot convert array to pointer, and therefore cannot use [] */\n\n  return 0;\n}\n</code></pre>\n<p>C99 expanded the applicability of that conversion thus making the above code valid.</p>\n", "LastActivityDate": "2016-04-21T16:56:32.250"}});