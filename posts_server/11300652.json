post_cb({"11300652": {"CommentCount": "3", "AcceptedAnswerId": "11301299", "PostTypeId": "1", "LastEditorUserId": "1290655", "CreationDate": "2012-07-02T20:24:41.083", "LastActivityDate": "2015-06-12T20:04:33.357", "LastEditDate": "2012-07-03T03:53:48.297", "ViewCount": "22507", "FavoriteCount": "9", "Title": "Static Data Member Initialization", "Id": "11300652", "Score": "13", "Body": "<p>Why must static data member initialization be outside the class?</p>\n<pre><code>class X\n{\npublic:\n      int normalValue = 5; //NSDMI\n      static int i;\n};\n\nint X::i = 0;\n</code></pre>\n<p>Why is the static data member (here \"i\") only a declaration, not a definition?</p>\n", "Tags": "<c++><c++11><g++>", "OwnerUserId": "1012759", "AnswerCount": "7"}, "11301299": {"ParentId": "11300652", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>It's important to distinguish the <em>initializer</em> which says what its initial value is, and the <em>definition</em>.  This modified code is valid, with the initializer in the class definition:</p>\n<pre><code>class X\n{\npublic:\n  int normalValue = 5;\n  static const int i = 0;       // declaration, with initializer\n};\n\nconst int X::i;                 // definition\n</code></pre>\n<p>i.e. What must be outside the class is a definition, not the initialization.</p>\n<p>That's because a variable must have an address in memory (unless it's only used in limited situations, such as in compile-time constant expressions.)</p>\n<p>A non-static member variable exists inside the object it is a member of, so its address depends on the address of the object that contains it. Every time you create a new <code>X</code> you also create a new <code>X::normalValue</code> variable.  The non-static data member's lifetime begins with the  class' constructor. NSDMI syntax doesn't have anything to do with the variable's address in memory, it just allows you to provide an initial value in one place, instead of repeating it in every constructor with an explicit constructor initializer list.</p>\n<p>On the other hand, a static member variable is not contained within an instance of the class, it exists independently of any single instance and exists from the start of the program, at a fixed address.  In order for a static member variable (or any other global object) to get a unique address the linker must see exactly one definition of the static variable, in exactly one object file, and assign it an address.</p>\n<p>Because a static variable needs exactly one definition in exactly one object file, it doesn't make sense to allow that definition to be provided in the class, since class definitions typically exist in header files and are included in multiple object files. So although you can provide an initializer in the class, you still need to define the static data member somewhere.</p>\n<p>You can also look at it like declaring an <code>extern</code> variable:</p>\n<pre><code>namespace X {\n  extern int i;\n}\n</code></pre>\n<p>This declares the variable, but there must be a definition somewhere in the program:</p>\n<pre><code>int X::i = 0;\n</code></pre>\n", "OwnerUserId": "981959", "LastEditorUserId": "981959", "LastEditDate": "2015-06-12T20:04:33.357", "Id": "11301299", "Score": "33", "CreationDate": "2012-07-02T21:16:26.503", "LastActivityDate": "2015-06-12T20:04:33.357"}, "11300875": {"ParentId": "11300652", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You need to supply a separate definition for a static data member (if its <em>odr-used</em>, as defined in C++11) simply because that definition shall reside somewhere - in one and only one translation unit. Static class data members are basically global objects (global variables) declared in class scope. The compiler wants you to choose a specific translation unit that will hold the actual \"body\" of each global object. It is you who has to decide which translation unit to place the actual object to.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2012-07-02T21:15:51.807", "Id": "11300875", "Score": "5", "CreationDate": "2012-07-02T20:43:50.883", "LastActivityDate": "2012-07-02T21:15:51.807"}, "11301021": {"ParentId": "11300652", "CommentCount": "1", "Body": "<p>Bear in mind that is is possible to initialize the static data member at the point of declaration if it is of const integral type of const enumeration type:</p>\n<p>From the C++03 standard, \u00a79.4.2</p>\n<blockquote>\n<p id=\"so_11300652_11301021_0\">If a static data member is of const integral or const enumeration type, its declaration in the class\n  definition can specify a constant-initializer which shall be an integral constant expression (5.19)</p>\n</blockquote>\n<pre><code>struct Foo {\n  static const int j = 42; // OK\n};\n</code></pre>\n", "OwnerUserId": "661519", "PostTypeId": "2", "Id": "11301021", "Score": "1", "CreationDate": "2012-07-02T20:53:30.597", "LastActivityDate": "2012-07-02T20:53:30.597"}, "23183329": {"ParentId": "11300652", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Static Data Member</p>\n<pre><code>#include&lt;iostream.h&gt;\n#include&lt;conio.h&gt;\n\nclass static_var\n{\n\nstatic int count; //static member of class\npublic :\n\nvoid incr_staticvar()\n{\ncount++;\n}\n\nvoid outputc()\n{ \ncout&lt;&lt;\"Value of Static variable Count :- \"&lt;&lt;count&lt;&lt;endl;\n}\n};\n\nint static_function : : count;\n\nvoid main()\n{\nclrscr();\nstatic_var obj1,obj2,obj3,obj4;\n\nobj1.incr_staticvar();\nobj2.incr_staticvar();\nobj3.incr_staticvar();\nobj4.incr_staticvar();\n\ncout&lt;&lt;\"\\nAfter Increment of static variable by Four Different objects is :-\\n\";\n\nobj1.outputc ( );\nobj2.outputc ( );\nobj3.outputc ( );\nobj4.outputc ( );\n\ngetch();\n}\n</code></pre>\n", "OwnerUserId": "3491994", "LastEditorUserId": "19679", "LastEditDate": "2014-07-13T21:56:21.737", "Id": "23183329", "Score": "0", "CreationDate": "2014-04-20T14:02:12.473", "LastActivityDate": "2014-07-13T21:56:21.737"}, "11300766": {"ParentId": "11300652", "CommentCount": "0", "Body": "<p>\"static\" class member is like a globally allocated variable (it is not related to the single class instance), so it must reside in some object file (and to be declared in the \".cpp\" file) as a symbol just like any global variable.</p>\n<p>Simple class member (non-static) resides in the memory block allocated for the class instance.</p>\n", "OwnerUserId": "1182653", "PostTypeId": "2", "Id": "11300766", "Score": "2", "CreationDate": "2012-07-02T20:32:58.070", "LastActivityDate": "2012-07-02T20:32:58.070"}, "11300975": {"ParentId": "11300652", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The simple reason is because classes are usually declared in <em>header</em> files, which often are included in multiple cpp files. Static data members have external linkage and must be declared in exactly one translation unit which makes them unfit for being defined inside a class.</p>\n<p>As juanchopanza points out the following is allowed:</p>\n<pre><code>struct A\n{\n    const static int i = 1;\n};\n</code></pre>\n<p>However, this is only a <em>declaration</em> not a definition. You still need to define it if you are going to use <code>i</code>'s address somewhere.\nFor example:</p>\n<pre><code>f(int);\ng(int&amp;);\n\nX&lt;A::i&gt; x; // Okay without definition for template arguments\nchar a[A::i]; // Okay without definition, just using value as constant expression\n&amp;A::i; // Need a definition because I'm taking the address\nf(A::i); // Okay without definition for pass by value\ng(A::i); // Need a definition with pass by reference\n</code></pre>\n", "OwnerUserId": "906773", "LastEditorUserId": "906773", "LastEditDate": "2012-07-02T21:08:56.803", "Id": "11300975", "Score": "2", "CreationDate": "2012-07-02T20:50:44.970", "LastActivityDate": "2012-07-02T21:08:56.803"}, "11300852": {"ParentId": "11300652", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>When the compiler generate binary code from a unit (extreme simplification: a cpp file and all its included headers) it will emit a symbol for the static variable and eventually initialization code for that variable.</p>\n<p>It is okay for a static variable symbol to be declared in multiple units, but it is not okay for it to be initialized multiple times.</p>\n<p>So you must make sure that the initialization code is only emitted for a single unit.\nThis mean that the static variable must be defined in exactly one unit.</p>\n", "OwnerUserId": "508811", "LastEditorUserId": "508811", "LastEditDate": "2012-07-02T21:04:07.763", "Id": "11300852", "Score": "1", "CreationDate": "2012-07-02T20:41:28.053", "LastActivityDate": "2012-07-02T21:04:07.763"}, "bq_ids": {"n4140": {"so_11300652_11301021_0": {"section_id": 5908, "quality": 0.7368421052631579, "length": 14}}, "n3337": {"so_11300652_11301021_0": {"section_id": 5680, "quality": 0.7368421052631579, "length": 14}}, "n4659": {"so_11300652_11301021_0": {"section_id": 7390, "quality": 0.7368421052631579, "length": 14}}}});