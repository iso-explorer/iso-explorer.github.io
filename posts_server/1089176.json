post_cb({"1089181": {"ParentId": "1089176", "PostTypeId": "2", "CommentCount": "11", "Body": "<p><strong>Yes</strong>. It's <em>usually</em> defined as something like the following (on 32-bit systems):</p>\n<pre><code>typedef unsigned int size_t;\n</code></pre>\n<p>Reference:</p>\n<p>C++ Standard Section 18.1 defines <code>size_t</code> is in <code>&lt;cstddef&gt;</code> which is described in C Standard as <code>&lt;stddef.h&gt;</code>.<br>\nC Standard Section 4.1.5 defines <code>size_t</code> as an unsigned integral type of the result of the <code>sizeof</code> operator</br></p>\n", "OwnerUserId": "33708", "LastEditorUserId": "33708", "LastEditDate": "2013-04-20T22:56:01.673", "Id": "1089181", "Score": "43", "CreationDate": "2009-07-06T20:56:41.593", "LastActivityDate": "2013-04-20T22:56:01.673"}, "1089176": {"CommentCount": "5", "AcceptedAnswerId": "1089181", "CreationDate": "2009-07-06T20:55:39.003", "LastActivityDate": "2016-12-02T10:49:42.737", "PostTypeId": "1", "ViewCount": "24621", "FavoriteCount": "8", "Title": "is size_t always unsigned?", "Id": "1089176", "Score": "52", "Body": "<p>As title: is size_t always unsigned, i.e. for <code>size_t x</code>, is <code>x</code> always <code>&gt;= 0</code> ?</p>\n", "Tags": "<c++><standards>", "OwnerUserId": "31317", "AnswerCount": "6"}, "1089179": {"ParentId": "1089176", "CommentCount": "0", "Body": "<p>Yes, size_t is guaranteed to be an unsigned type.</p>\n", "OwnerUserId": "126769", "PostTypeId": "2", "Id": "1089179", "Score": "14", "CreationDate": "2009-07-06T20:56:25.400", "LastActivityDate": "2009-07-06T20:56:25.400"}, "1089204": {"ParentId": "1089176", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>According to the 1999 ISO C standard (C99), <code>size_t</code> is an unsigned integer type of at least 16 bit (see  sections 7.17 and 7.18.3).</p>\n<p>The standard also recommends that <code>size_t</code> shouldn't have an integer conversion rank greater than <code>long</code> if possible, ie casting <code>size_t</code> to <code>unsigned long</code> is unproblematic if the recommendation is followed.</p>\n<p>The 1989 ANSI C standard (ANSI C) doesn't mention a minimal size or recommended conversion rank.</p>\n<p>The 1998 ISO C++ standard (C++98) (as well as the current draft for C++0x) refers to the C standard. Section 18.1 reads:</p>\n<blockquote>\n<p id=\"so_1089176_1089204_0\">The contents are the same as the Standard C library header <code>&lt;stddef.h&gt;</code> [...]</p>\n</blockquote>\n<p>According to section 1.2, this means the library as defined by the 1990 ISO C standard (C90), including its first amendment from 1995 (C95):</p>\n<blockquote>\n<p id=\"so_1089176_1089204_1\">The library described in clause 7 of\n  ISO/IEC 9899:1990 and clause 7 of\n  ISO/IEC 9899/Amd.1:1995 is hereinafter\n  called the <em>Standard C Library</em>.</p>\n</blockquote>\n<p>The parts regarding <code>size_t</code> should be inherited from ANSI C: Frontmatter and section numbering aside, the standards for C90 and ANSI C are identical. I'd need a copy of the normative amendment to be sure that there weren't any relevant changes to <code>stddef.h</code>, but I doubt it. The minimal size seems to be introduced with <code>stdint.h</code>, ie C99.</p>\n<p>Please also consider the following quote from section 1.2 of C++98:</p>\n<blockquote>\n<p id=\"so_1089176_1089204_2\">All standards are subject to revision,\n  and parties to agreements based on\n  this International Standard are\n  encouraged to investigate the\n  possibility of applying the most\n  recent editions of the standards\n  indicated below.</p>\n</blockquote>\n", "OwnerUserId": "48015", "LastEditorUserId": "48015", "LastEditDate": "2009-07-06T23:49:59.933", "Id": "1089204", "Score": "45", "CreationDate": "2009-07-06T21:01:50.037", "LastActivityDate": "2009-07-06T23:49:59.933"}, "40930436": {"ParentId": "1089176", "CommentCount": "0", "Body": "<p>Oh, this is just terrible:</p>\n<pre><code>vector&lt;MyObject&gt; arr;\nFill(arr);\nsize_t size = arr.size();\nfor(size_t i = 1; i &lt; size - 1; ++i)\n{\n  auto obj = arr[i];\n  auto next = arr[i+1];\n}\n</code></pre>\n<p>Now contemplate the use case where arr is empty.</p>\n", "OwnerUserId": "711202", "PostTypeId": "2", "Id": "40930436", "Score": "1", "CreationDate": "2016-12-02T10:49:42.737", "LastActivityDate": "2016-12-02T10:49:42.737"}, "1089220": {"ParentId": "1089176", "CommentCount": "2", "Body": "<p>According to the standard it is unsigned, however I recall that some older implementations used a signed type for the typedef.  </p>\n<p>From an older GCC doc:</p>\n<blockquote>\n<p id=\"so_1089176_1089220_0\">There is a potential problem with the size_t type and versions of GCC prior to release 2.4. ANSI C requires that <code>size_t</code> always be an unsigned type. For compatibility with existing systems' header files, GCC defines <code>size_t</code> in <code>stddef.h</code> to be whatever type the system's <code>sys/types.h</code> defines it to be. Most Unix systems that define <code>size_t</code> in <code>sys/types.h</code>, define it to be a signed type. Some code in the library depends on <code>size_t</code> being an unsigned type, and will not work correctly if it is signed</p>\n</blockquote>\n<p>I'm not sure how important it would be to guard against that.  My code assumes it's unsigned.</p>\n", "OwnerUserId": "12711", "PostTypeId": "2", "Id": "1089220", "Score": "5", "CreationDate": "2009-07-06T21:06:18.937", "LastActivityDate": "2009-07-06T21:06:18.937"}, "1089289": {"ParentId": "1089176", "CommentCount": "0", "Body": "<p>The size_t should follow the same definition as the C standard, and in several places in the C++ standard it implies it's unsigned natura (particularly in the allocator template argument definitions).</p>\n<p>On the C++ Standard, section 18.1 (ISO/IEC 14882 - First edition 1998-01-01):</p>\n<p>Table 15 lists as defined types: ptrdiff_t and size_t</p>\n<p>3 The contents are the same as the Standard C library header , with the following changes:\n4 The macro NULL is an implementation-defined C++ null pointer constant in this International Standard (4.10).</p>\n<p>The macro offsetof accepts a restricted set of type arguments in this International Standard. type\nshall be a POD structure or a POD union (clause 9). The result of applying the offsetof macro to a field that\nis a static data member or a function member is undefined.\nSEE ALSO: subclause 5.3.3, Sizeof, subclause 5.7, Additive operators, subclause 12.5, Free store, and ISO\nC subclause 7.1.6.</p>\n", "OwnerUserId": "4995", "PostTypeId": "2", "Id": "1089289", "Score": "2", "CreationDate": "2009-07-06T21:26:13.357", "LastActivityDate": "2009-07-06T21:26:13.357"}, "bq_ids": {"n4140": {"so_1089176_1089204_0": {"section_id": 6704, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_1089176_1089204_0": {"section_id": 6459, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_1089176_1089204_0": {"section_id": 8177, "quality": 0.7142857142857143, "length": 5}}}});