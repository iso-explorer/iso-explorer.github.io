post_cb({"5032811": {"ParentId": "5032683", "CommentCount": "0", "Body": "<p>From 9.4.2/2:</p>\n<blockquote>\n<p id=\"so_5032683_5032811_0\">The declaration of a static data\n  member in its class definition is not\n  a definition and may be of an\n  incomplete type other than cvqualified\n  void. The definition for a static data\n  member shall appear in a namespace\n  scope enclosing the member\u2019s class\n  definition. In the definition at\n  namespace scope, the name of the\n  static data member shall be qualified\n  by its class name using the ::\n  operator.</p>\n</blockquote>\n<p>And from 9.4.2/4:</p>\n<blockquote>\n<p id=\"so_5032683_5032811_1\">If a static data member is of const\n  integral or const enumeration type,\n  its declaration in the class\n  definition can specify a\n  constantinitializer which shall be an\n  integral constant expression (5.19).\n  In that case, the member can appear in\n  integral constant expressions within\n  its scope. The member shall still be\n  defined in a namespace scope if it is\n  used in the program and the namespace\n  scope definition shall not contain an\n  initializer.</p>\n</blockquote>\n<p>From these references we can infer (\"...shall still be defined...\" in 9.4.2/4) that if it's not defined then the program isn't well-formed.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "5032811", "Score": "2", "CreationDate": "2011-02-17T18:10:04.803", "LastActivityDate": "2011-02-17T18:10:04.803"}, "5032683": {"CommentCount": "4", "ViewCount": "1162", "PostTypeId": "1", "LastEditorUserId": "34509", "CreationDate": "2011-02-17T17:57:47.350", "LastActivityDate": "2011-02-17T22:35:55.470", "Title": "No definition available for static const member with initializer?", "LastEditDate": "2011-02-17T22:35:55.470", "Id": "5032683", "Score": "3", "Body": "<p>Given:</p>\n<pre><code>template&lt;class T&gt;\nstruct S {\n  static int const N = 1;\n};\n\nextern template class S&lt;int&gt;;\n\ntemplate&lt;class T&gt;\nint f( T n ) {\n  return n + S&lt;T&gt;::N; // line 10\n}\n\nint main() {\n  return f(1);        // line 14\n}\n\n//template class S&lt;int&gt;; // intentionally commented out to trigger error\n</code></pre>\n<p>I get:</p>\n<pre><code>foo.cpp: In function \u2018int f(T) [with T = int]\u2019:\nfoo.cpp:10:   instantiated from \u2018const int S&lt;int&gt;::N\u2019\nfoo.cpp:10:   instantiated from \u2018int f(T) [with T = int]\u2019\nfoo.cpp:14:   instantiated from here\nfoo.cpp:10: error: explicit instantiation of \u2018S&lt;int&gt;::N\u2019 but no definition available\n</code></pre>\n<p>But <strong>why</strong> do I get the error?</p>\n<ol>\n<li>The point of doing an explicit template instantiation declaration is so that the definitions can be <em>elsewhere</em>, yet the <em>compiler</em> (not the linker) gives an error.  (In a real application, the currently commented out explicit instantiation declaration would be in another translation unit anyway.)</li>\n<li>In this case, the value has a <em>constant initializer</em> so the compiler can in theory simply use the value directly.</li>\n<li>When I don't do the explicit template instantiation declaration, I (oddly) don't have to explicitly define <code>S&lt;T&gt;::N</code>.</li>\n</ol>\n<p>This is with g++ 4.2.1 on Mac OS X 10.6.6.</p>\n", "Tags": "<c++><templates><c++11><instantiation>", "OwnerUserId": "99089", "AnswerCount": "2"}, "5032794": {"ParentId": "5032683", "PostTypeId": "2", "CommentCount": "2", "Body": "<pre><code>extern template class S&lt;int&gt;;\n</code></pre>\n<p>I think this line causes the error, as it tells the compiler to look for <em>explicit instantiation</em>  of <code>S&lt;int&gt;</code> somewhere, but no explicit instantiation exists. Hence the error.</p>\n<p>Once you comment this line, I think the code should compile fine.</p>\n<hr>\n<p>EDIT:</p>\n<p>Well, see this : <a href=\"http://www.ideone.com/oQnOi\" rel=\"nofollow\">http://www.ideone.com/oQnOi</a></p>\n<p>As I said, it compiles fine!</p>\n<hr>\n<p>EDIT:</p>\n<p>I think $9.4.2/4 (as quoted by <strong>Mark B</strong>) doesn't apply to the static members of class <strong>templates</strong>, as $14.5.1.3 [temp.static] doesn't mandate the static members to be defined at namespace scope:</p>\n<blockquote>\n<p id=\"so_5032683_5032794_0\">A definition for a static data member\n  <strong>may be provided</strong> in a namespace scope\n  enclosing the definition of the <strong>static\n  member\u2019s class template</strong>. </p>\n</blockquote>\n<p>The the example follows as,</p>\n<pre><code>template&lt;class T&gt; class X  { static T s; }; \ntemplate&lt;class T&gt; T X&lt;T&gt;::s = 0;\n</code></pre>\n<p>Notice, it doesn't say <em>\"must be provided\"</em>, rather <em>\"may be provided\"</em>. So I think the definition of static members of class template at namespace scope is optional.</p>\n</hr></hr>", "OwnerUserId": "415784", "LastEditorUserId": "415784", "LastEditDate": "2011-02-17T18:40:09.860", "Id": "5032794", "Score": "2", "CreationDate": "2011-02-17T18:08:22.633", "LastActivityDate": "2011-02-17T18:40:09.860"}, "bq_ids": {"n4140": {"so_5032683_5032794_0": {"section_id": 107, "quality": 1.0, "length": 14}, "so_5032683_5032811_0": {"section_id": 5907, "quality": 0.9512195121951219, "length": 39}, "so_5032683_5032811_1": {"section_id": 5908, "quality": 0.7, "length": 28}}, "n3337": {"so_5032683_5032794_0": {"section_id": 102, "quality": 1.0, "length": 14}, "so_5032683_5032811_0": {"section_id": 5679, "quality": 0.9512195121951219, "length": 39}, "so_5032683_5032811_1": {"section_id": 5680, "quality": 0.7, "length": 28}}, "n4659": {"so_5032683_5032811_1": {"section_id": 7390, "quality": 0.6, "length": 24}, "so_5032683_5032811_0": {"section_id": 7389, "quality": 0.9024390243902439, "length": 37}, "so_5032683_5032794_0": {"section_id": 111, "quality": 1.0, "length": 14}}}});