post_cb({"17078032": {"ParentId": "17078002", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_17078002_17078032_0\">Ques1) Is this considered standard? My profs are contradictory.</p>\n</blockquote>\n<p>Yes, this is completely valid. Note that you need to explicitly delete the memory pointed by <code>arr</code> using operator <code>delete[]</code>. It is much better to use a <code>std::vector&lt;int&gt;</code> which will perform the memory management for you.</p>\n<p>You might be mistaken with variable length arrays(VLAs), which are not allowed in <code>C++</code>:</p>\n<pre><code>// same num as the one in your example\nint arr[num]; // ERROR\n</code></pre>\n<p>This is valid in <code>C</code> but invalid in <code>C++</code>(C++14 will include VLAs, although they will have some differences with <code>C</code> VLAs).</p>\n<blockquote>\n<p id=\"so_17078002_17078032_1\">Ques2) If it is standard, in that case, is it possible to extend the\n  size of the array (or any array) after creation?</p>\n</blockquote>\n<p>No, you can't extend it. You can allocate a bigger array, copy the elements and delete the previous one. Again, this is done automatically if you're using <code>std::vector&lt;int&gt;</code>.</p>\n<blockquote>\n<p id=\"so_17078002_17078032_2\">Ques3) Again, if this expression is standard, then is it possible to\n  use it within a function - eg. using a function to create such an\n  array? (if so, how?)</p>\n</blockquote>\n<p>Yes, of course:</p>\n<pre><code>int *allocate(size_t size) {\n    return new int[size];\n}\n</code></pre>\n<p>But again <strong>use <code>std::vector</code></strong>:</p>\n<pre><code>int num;\ncout &lt;&lt; \"How big an array? \";\ncin &gt;&gt; num;\nstd::vector&lt;int&gt; arr(num); // num elements, all of them initialized to 0\n// insert 42 at the end. reallocations(if any) are done automatically\narr.push_back(42); \n</code></pre>\n", "OwnerUserId": "525217", "LastEditorUserId": "525217", "LastEditDate": "2013-06-13T02:04:59.830", "Id": "17078032", "Score": "6", "CreationDate": "2013-06-13T01:51:11.690", "LastActivityDate": "2013-06-13T02:04:59.830"}, "17078099": {"ParentId": "17078002", "PostTypeId": "2", "CommentCount": "3", "Body": "<h2>As a complement to other answers :</h2>\n<p><strong>Vectors</strong></p>\n<p>(Agreed with vector for dynamic resize) :</p>\n<pre><code>std::vector&lt;int&gt; v;\nv.push_back(1);\nv.push_back(1);\nv.resize(v.size()+10, 5); // Greater resized\nv.resize(v.size()-1);     // Lower resized\n</code></pre>\n<ul>\n<li>If the new size is greater than the old one, additional elements will be initialized to 5 (or 0 in case of int, if the second parameter is not used) and ancient elements remain unchanged. </li>\n<li>If the new size is lower than the old one, it is truncated.</li>\n</ul>\n<p><strong>Arrays</strong></p>\n<p><em>Side note :</em> (about <em>stack</em> and <em>heap</em> allocation)</p>\n<p>The way an <code>array</code> is handled can lead to significantly different results (See this very interesting <a href=\"https://stackoverflow.com/a/79936/1715716\">discussion</a>):</p>\n<pre><code>// Create 500 bytes on the heap\nchar *pBuffer = new char[500];      // or malloc in C\n\n// Create 500 bytes on the stack\nchar buffer[500];                  \n</code></pre>\n", "OwnerUserId": "1715716", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:50:00.743", "Id": "17078099", "Score": "0", "CreationDate": "2013-06-13T02:02:59.793", "LastActivityDate": "2013-06-15T08:25:14.440"}, "17084365": {"ParentId": "17078002", "CommentCount": "0", "Body": "<p><strong>Q1:Is this considered standard?</strong> </p>\n<blockquote>\n<p id=\"so_17078002_17084365_0\">Given the de\ufb01nition int n = 42, new float[n][5]\n  is well-formed (because n is the expression of a\n  noptr-new-declarator), but new float[5][n] is ill-formed (because n is\n  not a constant expression).\n                 --<em>5.3.4.6,N3242</em></p>\n<p id=\"so_17078002_17084365_1\">If the allocated type is an array type, the allocation function\u2019s\n  name is   operator new[] and the deallocation function\u2019s name is\n  operator delete[].<br>\n                 --<em>5.3.4.8,N3242</em></br></p>\n<p id=\"so_17078002_17084365_2\"><code>new T[5]</code> results in a call of <code>operator new[](sizeof(T)*5+x)</code>\n  Here, x and y are non-negative unspeci\ufb01ed values representing array allocation overhead;<br>\n                 --<em>5.3.4.12,N3242</em></br></p>\n</blockquote>\n<p><strong>Q2:If it is standard, in that case, is it possible to extend the size of the array (or any array) after creation?</strong></p>\n<p>Partially no, or not recommended.<br>\nwhen the allocation function returns a value other than null, it must be a pointer to a block of storage\nin which space for the object has been reserved. Mostly allocation happened in heap, and there may not have more <strong>contiguous</strong> memory left which is important for array.<br>\nIf you have to do this and have a memory poll, use placement new operator you can do this partially, but what you do now is what the designer of allocator do, and have risk ruin the inner memory storage.</br></br></p>\n<p><strong>Q3: using a function to create such an array? (if so, how?)</strong></p>\n<blockquote>\n<p id=\"so_17078002_17084365_3\">Entities created by a new-expression have dynamic storage duration\n  (3.7.4). [Note: the lifetime of such an entity is not necessarily\n  restricted to the scope in which it is created. \u2014 end note ]\n                 --<em>5.3.4.1,N3242</em></p>\n</blockquote>\n<p>The rest of things are how to design such function to meet your need, even use template.</p>\n<pre><code> 1 template&lt;typename T&gt;T* foo(std::size_t size){\n 2         return new T[size] ;\n 3 }\n</code></pre>\n", "OwnerUserId": "1501948", "PostTypeId": "2", "Id": "17084365", "Score": "0", "CreationDate": "2013-06-13T10:07:23.870", "LastActivityDate": "2013-06-13T10:07:23.870"}, "17078002": {"CommentCount": "4", "AcceptedAnswerId": "17078032", "CreationDate": "2013-06-13T01:44:38.767", "LastActivityDate": "2013-06-15T08:25:14.440", "PostTypeId": "1", "ViewCount": "1523", "FavoriteCount": "0", "Title": "Creating a user-inputted sized Array using new operator", "Id": "17078002", "Score": "8", "Body": "<p>I have a few array-related questions. I've studied that array-size must be constant on declaration/compiler must know its value. But using the GNU GCC compiler (C++11 standard filter) and I am able to perfectly compile and run a program using a variable as array size, when declaring said array dynamically (using <code>new</code>)</p>\n<pre><code>int num;\ncout &lt;&lt; \"How big an array? \";\ncin &gt;&gt; num;\nint *arr = new int [num];\n</code></pre>\n<p>Ques1) Is this considered standard? My profs are contradictory.</p>\n<p>Ques2) If it <em>is</em> standard, in that case, is it possible to extend the size of the array (or any array) after creation? </p>\n<p>Ques3) Again, if this expression is standard, then is it possible to use it within a function - eg. using a function to create such an array? (if so, how?)</p>\n<p>(PS: Hi, I'm new here and also still a novice in C++)</p>\n", "Tags": "<c++><arrays><dynamic-allocation>", "OwnerUserId": "2480471", "AnswerCount": "5"}, "17078116": {"ParentId": "17078002", "CommentCount": "0", "Body": "<p>Question 1 - operator 'new' is used to make dynamic allocation, I mean, when you don't know previously what is the size of the array, so, there is no problem, you can do it! I think your profs are confusing with C sintax, where new neither exists and is not allowed to make things like: int p[n]; for instance.</p>\n<p>Question 2 - No,  it is not possible increase the size of an array created using operator new. You have to alocate another array and copy the data. You can consider use vector in order to do it easily. </p>\n<p>Question 3 - I don't see why to do it, but it is possible..</p>\n<pre><code>int* createarray(int size)\n{\n   return new int[size]; \n}\n\n\nint main()\n{\n    int *p = createarray(10);\n}\n</code></pre>\n", "OwnerUserId": "2182771", "PostTypeId": "2", "Id": "17078116", "Score": "0", "CreationDate": "2013-06-13T02:06:27.083", "LastActivityDate": "2013-06-13T02:06:27.083"}, "bq_ids": {"n4140": {"so_17078002_17084365_0": {"section_id": 6087, "quality": 0.8235294117647058, "length": 14}, "so_17078002_17084365_1": {"section_id": 6089, "quality": 0.9333333333333333, "length": 14}, "so_17078002_17084365_2": {"section_id": 6095, "quality": 0.8571428571428571, "length": 12}, "so_17078002_17084365_3": {"section_id": 6082, "quality": 0.7368421052631579, "length": 14}}, "n3337": {"so_17078002_17084365_0": {"section_id": 5855, "quality": 0.8235294117647058, "length": 14}, "so_17078002_17084365_1": {"section_id": 5857, "quality": 0.9333333333333333, "length": 14}, "so_17078002_17084365_2": {"section_id": 5861, "quality": 0.8571428571428571, "length": 12}, "so_17078002_17084365_3": {"section_id": 5850, "quality": 0.7368421052631579, "length": 14}}, "n4659": {"so_17078002_17084365_0": {"section_id": 7583, "quality": 0.8823529411764706, "length": 15}, "so_17078002_17084365_1": {"section_id": 7585, "quality": 0.9333333333333333, "length": 14}, "so_17078002_17084365_2": {"section_id": 7592, "quality": 0.5714285714285714, "length": 8}, "so_17078002_17084365_3": {"section_id": 7578, "quality": 0.7368421052631579, "length": 14}}}, "17078061": {"ParentId": "17078002", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_17078002_17078061_0\">I've studied that array-size must be constant on declaration/compiler must know its value.</p>\n</blockquote>\n<p>Well, that's true, but only for <em>static</em> or <em>automatic</em> arrays. You are allocating a <em>dynamic</em> array on the heap, which is different.</p>\n<h2>Static array</h2>\n<p>An array declared at global scope must have a constant size.</p>\n<pre><code>int arr[5];\n</code></pre>\n<h2>Automatic array</h2>\n<p>An array allocated automatically within a function must have constant size (with exception, see below).</p>\n<pre><code>void f() {\n    int arr[5];\n}\n</code></pre>\n<h2>Dynamic array</h2>\n<p>A dynamic array allocated on the heap with <code>new</code> can have any size, constant or variable.</p>\n<pre><code>new int[5];\nnew int[n * 4];\n</code></pre>\n<h2>GCC extension</h2>\n<p>The exception is that GCC allows one to use a <em>variable</em> to declare the size of an automatic array:</p>\n<pre><code>void f(int n) {\n    int arr[n];\n}\n</code></pre>\n<p>However, this usage is not standard.</p>\n", "OwnerUserId": "893", "PostTypeId": "2", "Id": "17078061", "Score": "3", "CreationDate": "2013-06-13T01:57:19.230", "LastActivityDate": "2013-06-13T01:57:19.230"}});