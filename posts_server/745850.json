post_cb({"745850": {"ViewCount": "2083", "Body": "<p>I've recently come across <a href=\"http://www.scs.stanford.edu/~dm/home/papers/c++-new.html\" rel=\"nofollow noreferrer\">this rant</a>.</p>\n<p>I don't quite understand a few of the points mentioned in the article:</p>\n<ul>\n<li>The author mentions the small annoyance of <code>delete</code> vs <code>delete[]</code>, but seems to argue that it is actually necessary (for the compiler), without ever offering a solution. Did I miss something?</li>\n<li><p>In the section 'Specialized allocators', in function <code>f()</code>, it seems the problems can be solved with replacing the allocations with: (omitting alignment)</p>\n<pre><code>// if you're going to the trouble to implement an entire Arena for memory,\n// making an arena_ptr won't be much work. basically the same as an auto_ptr,\n// except that it knows which arena to deallocate from when destructed.\narena_ptr&lt;char&gt; string(a); string.allocate(80);\n// or: arena_ptr&lt;char&gt; string; string.allocate(a, 80);\narena_ptr&lt;int&gt; intp(a); intp.allocate();\n// or: arena_ptr&lt;int&gt; intp; intp.allocate(a);\narena_ptr&lt;foo&gt; fp(a); fp.allocate();\n// or: arena_ptr&lt;foo&gt;; fp.allocate(a);\n// use templates in 'arena.allocate(...)' to determine that foo has\n// a constructor which needs to be called. do something similar\n// for destructors in '~arena_ptr()'.\n</code></pre></li>\n<li><p>In 'Dangers of overloading ::operator new[]', the author tries to do a <code>new(p) obj[10]</code>. Why not this instead (far less ambiguous):</p>\n<pre><code>obj *p = (obj *)special_malloc(sizeof(obj[10]));\nfor(int i = 0; i &lt; 10; ++i, ++p)\n    new(p) obj;\n</code></pre></li>\n<li><p>'Debugging memory allocation in C++'. Can't argue here.</p></li>\n</ul>\n<p>The entire article seems to revolve around classes with <em>significant</em> <em>constructors</em> and <em>destructors</em> located in a <em>custom memory management scheme</em>. While that could be useful, and I can't argue with it, it's pretty limited in commonality.</p>\n<p>Basically, we have placement new and per-class allocators -- what problems can't be solved with these approaches?</p>\n<p>Also, in case I'm just thick-skulled and crazy, in <strong>your</strong> ideal C++, what would replace <code>operator new</code>? Invent syntax as necessary -- what would be <strong>ideal</strong>, simply to help me understand these problems better.</p>\n", "AcceptedAnswerId": "745861", "Title": "Issues with C++ 'new' operator?", "CreationDate": "2009-04-13T23:59:39.787", "Id": "745850", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2010-11-03T12:50:22.563", "LastEditorUserId": "63550", "LastActivityDate": "2010-11-03T12:50:22.563", "Score": "2", "OwnerUserId": "66341", "Tags": "<c++><language-features><new-operator><allocation>", "AnswerCount": "2"}, "751173": {"Id": "751173", "PostTypeId": "2", "Body": "<p>The rant, IMHO, is very misleading and it seems to me that the author does understand the finer details, it's just that he appears to want to mislead.  IMHO, the key point that shows the flaw in argument is the following:</p>\n<pre><code>void* operator new(std::size_t size, void* ptr) throw();\n</code></pre>\n<p>The standard defines that the above function has the following properties:</p>\n<blockquote>\n<p id=\"so_745850_751173_0\"><strong>Returns</strong>: ptr.</p>\n<p id=\"so_745850_751173_1\"><strong>Notes</strong>: Intentionally performs no other action.</p>\n</blockquote>\n<p>To restate that - this function <strong>intentionally performs no other action</strong>.  This is very important, as it is the key to what placement new does:  It is used to call the constructor for the object, and that's all it does.  Notice explicitly that the <em>size</em> parameter is not even mentioned.</p>\n<p>For those without time, to summarise my point: everything that 'malloc' does in C can be done in C++ using \"::operator new\".  The only difference is that if you have non aggregate types, ie. types that need to have their destructors and constructors called, then you need to call those constructor and destructors.  Such types do not explicitly exist in C, and so using the argument that \"malloc does it better\" is not valid.  If you have a struct in 'C' that has a special \"initializeMe\" function which must be called with a corresponding \"destroyMe\" then all points made by the author apply equally to that struct as they do to a non-aggregate C++ struct.</p>\n<p>Taking some of his points explicitly:</p>\n<blockquote>\n<p id=\"so_745850_751173_2\">To implement multiple inheritance, the compiler must actually change the values of pointers during some casts. It can't know which value you eventually want when converting to a void * ...  Thus, no ordinary function can perform the role of malloc in C++--there is no suitable return type. </p>\n</blockquote>\n<p>This is not correct, again <em>::operator new</em> performs the role of <em>malloc</em>:</p>\n<pre><code>class A1 { };\nclass A2 { };\nclass B : public A1, public A2 { };\n\nvoid foo () {\n    void * v = ::operator new (sizeof (B));\n    B * b = new (v) B();  // Placement new calls the constructor for B.\n    delete v;\n\n    v = ::operator new (sizeof(int));\n    int * i = reinterpret_cast &lt;int*&gt; (v);\n    delete v'\n}\n</code></pre>\n<p>As I mention above, we need placement new to call the constructor for B.  In the case of 'i' we can cast from <em>void*</em> to <em>int*</em> without a problem, although again using placement new would improve type checking.</p>\n<p>Another point he makes is about alignment requirements:</p>\n<blockquote>\n<p id=\"so_745850_751173_3\">Memory returned by new char[...] will not necessarily meet the alignment requirements of a struct intlist. </p>\n</blockquote>\n<p>The standard under 3.7.3.1/2 says:</p>\n<blockquote>\n<p id=\"so_745850_751173_4\">The pointer returned shall be suitably aligned so that it can be converted to a\n  pointer of any complete object type and then used to access the object or array in the storage allocated (until\n  the storage is explicitly deallocated by a call to a corresponding deallocation function).</p>\n</blockquote>\n<p>That to me appears pretty clear.</p>\n<p>Under specialized allocators the author describes potential problems that you might have, eg. you need to use the allocator as an argument to any types which allocate memory themselves and the constructed objects will need to have their destructors called explicitly.  Again, how is this different to passing the allocator object through to an \"initalizeMe\" call for a C struct?</p>\n<p>Regarding calling the destructor, in C++ you can easily create a special kind of smart pointer, let's call it \"placement_pointer\" which we can define to call the destructor explicitly when it goes out of scope.  As a result we could have:</p>\n<pre><code>template &lt;typename T&gt;\nclass placement_pointer {\n  // ...\n  ~placement_pointer() {\n    if (*count == 0) {\n      m_b-&gt;~T();\n    }\n  }\n  // ...\n  T * m_b;\n};\n\nvoid\nf ()\n{\n  arena a;\n\n  // ...\n  foo *fp = new (a) foo;           // must be destroyed\n  // ...\n  fp-&gt;~foo ();\n\n  placement_pointer&lt;foo&gt; pfp = new (a) foo; // automatically !!destructed!!\n  // ...\n}\n</code></pre>\n<p>The last point I want to comment on is the following:</p>\n<blockquote>\n<p id=\"so_745850_751173_5\">g++ comes with a \"placement\" operator new[] defined as follows:</p>\n</blockquote>\n<pre><code>inline void *\noperator new[](size_t, void *place)\n{\n  return place;\n}\n</code></pre>\n<p>As noted above, not just implemented this way - but it is required to be so by the standard.</p>\n<blockquote>\n<p id=\"so_745850_751173_6\">Let obj be a class with a destructor. Suppose you have sizeof (obj[10]) bytes of memory somewhere and would like to construct 10 objects of type obj at that location. (C++ defines sizeof (obj[10]) to be 10 * sizeof (obj).) Can you do so with this placement operator new[]? For example, the following code would seem to do so:</p>\n</blockquote>\n<pre><code>obj *\nf ()\n{\n  void *p = special_malloc (sizeof (obj[10]));\n  return new (p) obj[10];       // Serious trouble...\n}\n</code></pre>\n<blockquote>\n<p id=\"so_745850_751173_7\">Unfortunately, this code is incorrect. In general, there is no guarantee that the size_t argument passed to operator new[] really corresponds to the size of the array being allocated.</p>\n</blockquote>\n<p>But as he highlights by supplying the definition, the size argument is not used in the allocation function.  The allocation function does <strong>nothing</strong> - and so the only affect of the above placement expression is to call the constructor for the 10 array elements as you would expect.</p>\n<p>There are other issues with this code, but not the one the author listed.</p>\n", "LastActivityDate": "2009-04-15T11:02:52.197", "Score": "3", "CreationDate": "2009-04-15T11:02:52.197", "ParentId": "745850", "CommentCount": "0", "OwnerUserId": "11698"}, "745861": {"Id": "745861", "PostTypeId": "2", "Body": "<p>Well, the <em>ideal</em> would probably be to not need delete of any kind.  Have a garbage-collected environment, let the programmer avoid the whole problem.</p>\n<p>The complaints in the rant seem to come down to</p>\n<ol>\n<li>\"I liked the way malloc does it\"</li>\n<li>\"I don't like being forced to explicitly create objects of a known type\"</li>\n</ol>\n<p>He's right about the annoying fact that you have to implement both <code>new</code> and <code>new[]</code>, but you're forced into that by Stroustrups' desire to maintain the core of C's semantics.  Since you can't tell a pointer from an array, you have to tell the compiler yourself.  You could fix that, but doing so would mean changing the semantics of the C part of the language radically; you could no longer make use of the identity</p>\n<pre><code>*(a+i) == a[i]\n</code></pre>\n<p>which would break a very large subset of all C code.</p>\n<p>So, you could have a language which</p>\n<ul>\n<li><p>implements a more complicated notion of an array, and eliminates the wonders of pointer arithmetic, implementing arrays with dope vectors or something similar.</p></li>\n<li><p>is garbage collected, so you don't need your own <code>delete</code> discipline.</p></li>\n</ul>\n<p>Which is to say, you could download Java.  You could then extend that by changing the language so it</p>\n<ul>\n<li>isn't strongly typed, so type checking the <code>void *</code> upcast is eliminated, </li>\n</ul>\n<p>...but that means that you can write code that transforms a Foo into a Bar without the compiler seeing it.  This would also enable ducktyping, if you want it.</p>\n<p>The thing is, once you've done those things, you've got Python or Ruby with a C-ish syntax.</p>\n<p>I've been writing C++ since Stroustrup sent out tapes of cfront 1.0; a lot of the history involved in C++ as it is now comes out of the desire to have an OO language that could fit into the C world.  There were plenty of other, more satisfying, languages that came out around the same time, like Eiffel.  C++ seems to have won.  I suspect that it won <em>because</em> it could fit into the C world.</p>\n", "LastEditorUserId": "35092", "LastActivityDate": "2009-04-14T00:20:42.047", "Score": "5", "CreationDate": "2009-04-14T00:05:26.933", "ParentId": "745850", "CommentCount": "8", "LastEditDate": "2009-04-14T00:20:42.047", "OwnerUserId": "35092"}, "bq_ids": {"n4140": {"so_745850_751173_4": {"length": 24, "quality": 0.96, "section_id": 7177}, "so_745850_751173_1": {"length": 4, "quality": 0.8, "section_id": 6859}}, "n3337": {"so_745850_751173_4": {"length": 24, "quality": 0.96, "section_id": 6921}, "so_745850_751173_1": {"length": 4, "quality": 0.8, "section_id": 6605}}, "n4659": {"so_745850_751173_4": {"length": 24, "quality": 0.96, "section_id": 8685}, "so_745850_751173_1": {"length": 4, "quality": 0.8, "section_id": 8351}}}});