post_cb({"15080536": {"ParentId": "15080200", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>Seems like tonight it's <a href=\"https://stackoverflow.com/questions/15079947/obviously-ambiguous-call-does-not-cause-a-compilation-error-on-gcc#comment21209484_15079947\">GCC Bug Party</a> :-)</p>\n<p>Jokes aside, this is most certainly a <strong>bug</strong>. <a href=\"https://stackoverflow.com/questions/15080015/stdthread-with-pointer-to-data-member/15080378#15080378\">My answer to the linked question</a> actually contains the proof, but since it is not emphasized, I will repeat it here.</p>\n<p>This is how the <code>INVOKE</code> facility, in terms of which the behavior of <code>std::thread</code>'s constructor (see the linked answer) is defined in the C++11 Standard</p>\n<blockquote>\n<p id=\"so_15080200_15080536_0\">Define <strong>INVOKE (f, t1, t2, ..., tN)</strong> as follows:</p>\n<p id=\"so_15080200_15080536_1\">\u2014 <strong>(t1.*f)(t2, ..., tN) when f is a pointer to a member function of a class T and t1 is an object of\n  type T or a reference to an object of type T or a reference to an object of a type derived from T;</strong></p>\n<p id=\"so_15080200_15080536_2\">\u2014 ((*t1).*f)(t2, ..., tN) when f is a pointer to a member function of a class T and t1 is not one of\n  the types described in the previous item;</p>\n<p id=\"so_15080200_15080536_3\">\u2014 t1.*f when N == 1 and f is a pointer to member data of a class T and t1 is an object of type T or a\n  reference to an object of type T or a reference to an object of a type derived from T;</p>\n<p id=\"so_15080200_15080536_4\">\u2014 (*t1).*f when N == 1 and f is a pointer to member data of a class T and t1 is not one of the types\n  described in the previous item;</p>\n<p id=\"so_15080200_15080536_5\">\u2014 f(t1, t2, ..., tN) in all other cases.</p>\n</blockquote>\n<p>The sentence in bold font effectively specifies that the line:</p>\n<blockquote>\n<p id=\"so_15080200_15080536_6\">std::thread t(&amp;S::f, s);</p>\n</blockquote>\n<p>Should compile. Therefore, this qualifies as a <strong>bug</strong>.</p>\n<p>Besides, that does line compile on GCC 4.8.0 (beta) and Clang 3.2.</p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:43:21.253", "Id": "15080536", "Score": "4", "CreationDate": "2013-02-26T02:53:59.580", "LastActivityDate": "2013-02-26T03:09:37.247"}, "15080200": {"CommentCount": "0", "ViewCount": "1193", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-02-26T02:13:19.450", "LastActivityDate": "2013-02-26T03:19:42.880", "Title": "GCC 4.7.2: std::thread with pointer to member function", "AcceptedAnswerId": "15080536", "LastEditDate": "2017-05-23T12:12:57.737", "Id": "15080200", "Score": "4", "Body": "<p>In writing test code for <a href=\"https://stackoverflow.com/questions/15080015/stdthread-with-pointer-to-data-member\">this question</a> I found that the commented line below does not compile on GCC 4.7.2:</p>\n<pre><code>#include &lt;thread&gt;\n#include &lt;iostream&gt;\n\nstruct S {\n    void f() {\n        std::cout &lt;&lt; \"Calling f()\" &lt;&lt; std::endl;\n    }\n};\n\nint main()\n{\n    S s;\n    // std::thread t(&amp;S::f, s); // does not compile?\n    std::thread t(&amp;S::f, &amp;s);\n    t.join();\n}\n</code></pre>\n<p>But cppreference seems to claim that the \"this\" argument can be passed equivalently as an object, reference to object, or pointer to object:</p>\n<blockquote>\n<p id=\"so_15080200_15080200_0\">If f is pointer to a member function of class T, then it is called. The return value is ignored. Effectively, the following code is executed:\n  (t1.*f)(t2, ..., tN) if the type of t1 is either T, reference to T or reference to type derived from T.\n  ((*t1).*f)(t2, ..., tN) otherwise.</p>\n</blockquote>\n<p>I actually think this sounds terrible, and would prefer <code>std::thread</code> only allow either pointer or reference semantics instead of accepting them interchangeably, but given that it seems like it's supposed to, is the above a GCC/libstdc++ bug (or am I misinterpreting cppreference)? </p>\n", "Tags": "<c++><gcc><c++11><std><libstdc++>", "OwnerUserId": "2008149", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_15080200_15080536_1": {"section_id": 4560, "quality": 1.0, "length": 15}, "so_15080200_15080536_2": {"section_id": 4560, "quality": 1.0, "length": 11}, "so_15080200_15080536_3": {"section_id": 4560, "quality": 1.0, "length": 15}, "so_15080200_15080536_5": {"section_id": 4560, "quality": 1.0, "length": 4}, "so_15080200_15080536_4": {"section_id": 4560, "quality": 1.0, "length": 11}}, "n3337": {"so_15080200_15080536_1": {"section_id": 4390, "quality": 1.0, "length": 15}, "so_15080200_15080536_2": {"section_id": 4390, "quality": 1.0, "length": 11}, "so_15080200_15080536_3": {"section_id": 4390, "quality": 1.0, "length": 15}, "so_15080200_15080536_5": {"section_id": 4390, "quality": 1.0, "length": 4}, "so_15080200_15080536_4": {"section_id": 4390, "quality": 1.0, "length": 11}}, "n4659": {"so_15080200_15080536_1": {"section_id": 7709, "quality": 0.6, "length": 9}, "so_15080200_15080536_2": {"section_id": 5932, "quality": 0.6363636363636364, "length": 7}, "so_15080200_15080536_3": {"section_id": 7709, "quality": 0.6, "length": 9}, "so_15080200_15080536_5": {"section_id": 5932, "quality": 1.0, "length": 4}, "so_15080200_15080536_4": {"section_id": 5932, "quality": 0.6363636363636364, "length": 7}}}});