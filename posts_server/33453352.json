post_cb({"33453792": {"ParentId": "33453352", "CommentCount": "0", "Body": "<p>You can use the nm tool on the executable.  This will show what file contains function definitions.  Also gcc provides a flag to strip out unused functions when doing the link.</p>\n<p>Compile with \u201c-fdata-sections\u201d to keep the data in separate data sections and \u201c-ffunction-sections\u201d to keep functions in separate sections, so they (data and functions) can be discarded if unused.\nLink with \u201c\u2013gc-sections\u201d to remove unused sections.</p>\n", "OwnerUserId": "1080552", "PostTypeId": "2", "Id": "33453792", "Score": "0", "CreationDate": "2015-10-31T16:21:05.333", "LastActivityDate": "2015-10-31T16:21:05.333"}, "33453352": {"CommentCount": "6", "ViewCount": "168", "CreationDate": "2015-10-31T15:35:04.750", "LastActivityDate": "2015-10-31T16:21:05.333", "Title": "Checking whether a class template has been instantiated?", "FavoriteCount": "0", "PostTypeId": "1", "Id": "33453352", "Score": "4", "Body": "<p>Is there an easy way to see whether a class has been instantiated in a translation unit? An exercise from C++ Primer asks for each labelled statement, whether an instantiation happens:</p>\n<pre><code>template &lt;typename T&gt; class Stack { };\nvoid f1(Stack&lt;char&gt;); // (a)\nclass Exercise {\n    Stack&lt;double&gt; &amp;rsd; // (b)\n    Stack&lt;int&gt; si; // (c)\n};\nint main() {\n    Stack&lt;char&gt; *sc; // (d)\n    f1(*sc); // (e)\n    int iObj = sizeof(Stack&lt; string &gt;); // (f)\n}\n</code></pre>\n<p>I'm not sure how I could actually check my answers for these. I thought maybe I could use explicit instantiations for each class type (e.g. <code>extern template class Stack&lt;char&gt;</code>) and then never have a corresponding explicit instantiation definition in the program. That way if something was instantiated, if the definition didn't later appear then the linker would kick up an error. </p>\n<p>However the compiler/linker doesn't always recognise such an error:</p>\n<pre><code>template &lt;typename T&gt; class A{ };\nextern template class A&lt;int&gt;;\nint main(){\n    A&lt;int&gt; a; \n}\n</code></pre>\n<p>This compiles fine on gcc 4.9.2. However if this was the only object file in my program is should be an error as far as I can tell from [14.7.2][11] of N3337: </p>\n<blockquote>\n<p id=\"so_33453352_33453352_0\">If an entity is the subject of both an explicit instantiation declaration and an explicit instantiation definition in the same translation unit, the definition shall follow the declaration. An entity that is the subject of\n  an explicit instantiation declaration and that is also used in a way that would otherwise cause an implicit instantiation (14.7.1) in the translation unit shall be the subject of an explicit instantiation definition somewhere in the program; otherwise the program is ill-formed, no diagnostic required.</p>\n</blockquote>\n<p>(I'm guessing the \"no diagnostic required\" is why this doesn't kick up an error?). Alternatively is it the case that instantiations happen whenever an incomplete class type isn't viable for an expression - so that I could check by removing the definition of <code>Stack</code>?</p>\n<pre><code>template &lt;typename T&gt; class Stack;\n</code></pre>\n<p>So that each incomplete type error corresponds to a place where an instantiation would have occured?</p>\n", "Tags": "<c++><templates><c++11><instantiation>", "OwnerUserId": "3348786", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_33453352_33453352_0": {"section_id": 260, "quality": 0.9743589743589743, "length": 38}}, "n3337": {"so_33453352_33453352_0": {"section_id": 251, "quality": 0.9743589743589743, "length": 38}}, "n4659": {"so_33453352_33453352_0": {"section_id": 267, "quality": 0.9743589743589743, "length": 38}}}});