post_cb({"20448518": {"Id": "20448518", "PostTypeId": "2", "Body": "<p>This is ill-formed, but no diagnostic is required. The problem is that <code>f()</code> in <code>constexpr Value(const type_t&amp; value): compile_time_bool(f())</code> may not appear in a constant expression for <em>any</em> template argument. But consider:</p>\n<pre><code>struct A{};\nstruct B{};\n\nbool foo(A);\nconstexpr bool foo(B) { return {}; }\n\ntemplate&lt;class T&gt;\nconstexpr bool bar(T p) { return foo(p); }\n</code></pre>\n<p>Here, the <code>constexpr</code>ness of <code>bar</code> depends on the template argument. Therefore:</p>\n<pre><code>constexpr A a{};\nconstexpr B b{};\n\n//constexpr auto ba {bar(a)};  // error\nconstexpr auto ba {bar(b)};    // fine\nauto ba2 {bar(a)};             // fine\n</code></pre>\n<p>A function template marked as <code>constexpr</code> can produce <code>constexpr</code> and non-<code>constexpr</code> specializations, depending on the template arguments.</p>\n<p>It is probably hard or impossible to check if a function template is not <code>constexpr</code> for any set of template arguments (in the OP's case, it could be possible to see that as <code>f()</code> unambiguously refers to <code>Value::f</code>). Therefore, no diagnostic is required.</p>\n<hr>\n<p>The relevant paragraph is [dcl.constexpr]/6:</p>\n<blockquote>\n<p id=\"so_20437734_20448518_0\">If the instantiated template specialization of a <code>constexpr</code> function template or member function of a class template would fail to satisfy the requirements for a <code>constexpr</code> function or <code>constexpr</code> constructor, that specialization is not a <code>constexpr</code> function or <code>constexpr</code> constructor. [<em>Note:</em> If the function is a member function it will still be const as described below. \u2014 <em>end note</em> ] If no specialization of the template would\n  yield a <code>constexpr</code> function or <code>constexpr</code> constructor, the program is ill-formed; no diagnostic required.</p>\n</blockquote>\n<p>N.B. the <code>const</code> thing will be lifted in C++1y, so better mark member functions (not ctors, obviously) both as both <code>constexpr</code> and <code>const</code>.</p>\n<hr>\n<p>Effectively, the program has UB. But once you instantiate the ctor in a context that requires a constant expression, your compiler should complain -- as does clang++3.4</p>\n<p>Both compilers seem to accept your program if you use the ctor in a context where a constant expression is not required. I'd say that's an extension, but it's as hard to issue a warning in this case (\"extension used, nonportable code\") as to diagnose the program is ill-formed in the first place.</p>\n</hr></hr>", "LastActivityDate": "2013-12-08T00:42:46.907", "CommentCount": "1", "CreationDate": "2013-12-08T00:42:46.907", "ParentId": "20437734", "Score": "5", "OwnerUserId": "420683"}, "bq_ids": {"n4140": {"so_20437734_20448518_0": {"length": 34, "quality": 0.7555555555555555, "section_id": 5422}}, "n3337": {"so_20437734_20448518_0": {"length": 42, "quality": 0.9333333333333333, "section_id": 5217}}, "n4659": {"so_20437734_20448518_0": {"length": 34, "quality": 0.7555555555555555, "section_id": 6844}}}, "20437734": {"ViewCount": "526", "Body": "<p>The following is valid in gcc 4.8:</p>\n<pre><code>class Value {\n    private:\n        static std::vector&lt;float&gt; compile_time_vector;\n        const bool compile_time_bool;\n\n        static bool f(void) {\n            compile_time_vector.push_back(2.3);\n\n            return true;\n        }\n\n    public:\n        template &lt;typename type_t&gt;\n        constexpr Value(const type_t&amp; value): compile_time_bool(f()) {}\n};\n</code></pre>\n<p>std::vector isn't designed to work at compile time, so exactly what kind of code is this generating?  I've used the class to make sure it isn't optimized out.</p>\n", "AcceptedAnswerId": "20448518", "Title": "Non-constexpr function's use in constexpr constructor is valid", "CreationDate": "2013-12-07T04:49:35.110", "Id": "20437734", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2013-12-08T00:42:46.907", "Score": "5", "OwnerUserId": "2228070", "Tags": "<c++><stdvector><compile-time>", "AnswerCount": "1"}});