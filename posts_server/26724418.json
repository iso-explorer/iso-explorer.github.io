post_cb({"bq_ids": {"n4140": {"so_26724418_26724770_1": {"length": 23, "quality": 0.92, "section_id": 1205}}, "n3337": {"so_26724418_26724770_1": {"length": 23, "quality": 0.92, "section_id": 1203}}, "n4659": {"so_26724418_26724770_1": {"length": 23, "quality": 0.92, "section_id": 1285}}}, "26724664": {"Id": "26724664", "PostTypeId": "2", "Body": "<p>It's implementation defined.  It could just be using a mutex lock or it could be using some intrinsics on memory blobs.  The standard simply defines it such that the latter might work as an implementation strategy.</p>\n<p>The compiler doesn't know anything here.  It'll all be in the library.  Since it's a template you can go read how your implementation does it.</p>\n", "LastActivityDate": "2014-11-03T22:44:12.127", "CommentCount": "0", "CreationDate": "2014-11-03T22:44:12.127", "ParentId": "26724418", "Score": "0", "OwnerUserId": "301883"}, "26724418": {"ViewCount": "105", "Body": "<p>I'm trying to find where the comparison semantics for the type <code>T</code> with <code>std::atomic</code> is defined.</p>\n<p>I know that beside the builtin specializations for integral types, <code>T</code> can be any <code>TriviallyCopyable</code> type.  But how do operations like <code>compare_and_exchange_X</code> know how to <em>compare</em> an instance of <code>T</code>?  </p>\n<p>I imagine they must simply do a byte by byte comparison of the user defined object (like a <code>memcmp</code>) but I don't see where in the standard this is explicitly mentioned.  </p>\n<p>So, suppose I have:</p>\n<pre><code>struct foo\n{\n  std::uint64_t x;\n  std::uint64_t y;\n};\n</code></pre>\n<p>How does the compiler know how to compare two <code>std::atomic&lt;foo&gt;</code> instances when I call <code>std::atomic&lt;foo&gt;::compare_and_exchange_weak()</code>?</p>\n", "AcceptedAnswerId": "26724770", "Title": "Comparison semantics with std::atomic types", "CreationDate": "2014-11-03T22:25:41.807", "Id": "26724418", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-11-03T22:52:35.897", "Score": "1", "OwnerUserId": "2923952", "Tags": "<c++><atomic>", "AnswerCount": "2"}, "26724770": {"Id": "26724770", "PostTypeId": "2", "Body": "<p>In draft n3936, <code>memcmp</code> semantics are explicitly described in section 29.6.5.</p>\n<blockquote>\n<p id=\"so_26724418_26724770_0\">Note:  For example, the effect of atomic_compare_exchange_strong is\n      if  (memcmp(object,  expected,  sizeof(*object))  ==  0)\n          memcpy(object,  &amp;desired,  sizeof(*object));\n      else\n          memcpy(expected,  object,  sizeof(*object));</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_26724418_26724770_1\">Note:  The <code>memcpy</code> and <code>memcmp</code> semantics of the compare-and-exchange operations may result in failed comparisons for values that compare equal with <code>operator==</code> if the underlying type has padding bits, trap bits, or alternate representations of the same value.</p>\n</blockquote>\n<p>That wording has been present at least since n3485.</p>\n<p>Note that only <code>memcmp(p1, p2, sizeof(T)) != 0</code> is meaningful to <code>compare_and_exchange_weak</code> (failure guaranteed).  <code>memcmp(p1, p2, sizeof(T)) == 0</code> allows but does not guarantee success.</p>\n", "LastActivityDate": "2014-11-03T22:52:35.897", "CommentCount": "0", "CreationDate": "2014-11-03T22:52:35.897", "ParentId": "26724418", "Score": "2", "OwnerUserId": "103167"}});