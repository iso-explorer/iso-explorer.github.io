post_cb({"9055801": {"ParentId": "9055778", "CommentCount": "2", "Body": "<p>You cannot \"solve\" this. Use a pointer if you want to be able to have that member not point to anything.</p>\n<p>References must be initialized to a real object, they cannot \"point nowhere\".</p>\n", "OwnerUserId": "635608", "PostTypeId": "2", "Id": "9055801", "Score": "9", "CreationDate": "2012-01-29T18:58:50.433", "LastActivityDate": "2012-01-29T18:58:50.433"}, "9055813": {"ParentId": "9055778", "CommentCount": "0", "Body": "<p>Use a pointer:-\n const Object* pReadOnly;</p>\n", "OwnerUserId": "832009", "PostTypeId": "2", "Id": "9055813", "Score": "1", "CreationDate": "2012-01-29T19:00:13.130", "LastActivityDate": "2012-01-29T19:00:13.130"}, "9055778": {"CommentCount": "6", "AcceptedAnswerId": "9055797", "CreationDate": "2012-01-29T18:56:08.687", "LastActivityDate": "2017-01-09T15:09:58.350", "PostTypeId": "1", "ViewCount": "26909", "FavoriteCount": "4", "Title": "Initializing a reference to member to NULL in C++", "Id": "9055778", "Score": "16", "Body": "<p>Is it possible to initialize a reference member to NULL in c++?<br>\nI'm trying to something like this:  </br></p>\n<pre><code>class BigClass\n{\nprivate:\n  Object m_inner;\npublic:\n  const Object&amp; ReadOnly;\n  BigClass() : ReadOnly(NULL)\n  {\n    Do stuff.\n  }\n};\n</code></pre>\n<p>I know I can do this if I initialize \"ReadOnly\" to a real reference of an object, but when I want to put in there \"NULL\", i get the error:  </p>\n<blockquote>\n<p id=\"so_9055778_9055778_0\">\"cannot convert from 'int' to 'const Object &amp;'</p>\n</blockquote>\n<p>How can I solve this?</p>\n", "Tags": "<c++><reference><initialization-list>", "OwnerUserId": "479770", "AnswerCount": "5"}, "9055841": {"ParentId": "9055778", "CommentCount": "1", "Body": "<p>It can be done but it is almost certainly an <strong>extremely bad idea</strong>. The way to do it is to dereference a suitably typed <code>NULL</code> pointer which already shows that it is a bad idea: you arrive at undefined behavior at this point which, however, typically tends to \"work\".</p>\n<p>In C++ references are meant to always refer to an actual object. This is different to other programming languages where \"references\" are actually the equivalent of <em>pointers</em> in C++ (typically without things like pointer arithmetic). What you probably actually want (you unfortunately didn't say what you try to achieve it but asked about a solution to a problem which is probably part of a misguided approach) is to use a pointer instead:</p>\n<pre><code>Object const* const readOnly;\nBigClass(): readOnly(0) {}\n</code></pre>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "9055841", "Score": "5", "CreationDate": "2012-01-29T19:03:33.283", "LastActivityDate": "2012-01-29T19:03:33.283"}, "13079448": {"ParentId": "9055778", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>It's useful in writing unit-tests. That is the <em>only</em> place it should be done, but there, it's quite helpful.</p>\n<pre><code> Bar&amp; bar(*static_cast&lt;Bar*&gt;(0));\n MockClass mock; // derives from RealClass\n mock.foo(bar);\n</code></pre>\n<p>Here, I am testing code which uses <code>MockClass</code>, not <code>MockClass</code> itself.</p>\n<p>It's not a panacea, but it can help. Also, <a href=\"http://www.google.com/url?sa=t&amp;rct=j&amp;q=googlemock&amp;source=web&amp;cd=1&amp;cad=rja&amp;ved=0CB8QFjAA&amp;url=http%3A%2F%2Fcode.google.com%2Fp%2Fgooglemock%2F&amp;ei=39-JUJrlOaKNigKckYCoAQ&amp;usg=AFQjCNF8vsE9svghL2ubFL0KIDYd71-YtQ\" rel=\"nofollow\">GoogleMock</a> might be your friend if you are mocking \"concrete\" classes.</p>\n<pre><code>struct Bar;\nstruct RealClass {\n  int&amp; x_;\n  double&amp; y_;\n  RealClass(int&amp; x, double&amp; y) :x_(x), y_(y) {}\n  virtual void foo(Bar&amp;);\n};\nstruct MockClass: public RealClass {\n  MockClass(): RealClass(*(int*)0, *(double*)0) {}\n  MOCK_METHOD1(foo, void(Bar&amp;));\n};\n</code></pre>\n", "OwnerUserId": "263998", "LastEditorUserId": "263998", "LastEditDate": "2015-12-11T15:04:27.250", "Id": "13079448", "Score": "0", "CreationDate": "2012-10-26T01:01:48.013", "LastActivityDate": "2015-12-11T15:04:27.250"}, "9055797": {"ParentId": "9055778", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>No, references cannot be <code>NULL</code> in C++.<sup>1</sup></p>\n<p>Possible solutions include:</p>\n<ul>\n<li>using a pointer instead of a reference.</li>\n<li>having a dummy <code>Object</code> instance that can be used to indicate \"no object\".</li>\n</ul>\n<hr>\n<p><sub>[1] From the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">C++11 standard</a>:</sub></p>\n<blockquote>\n<p id=\"so_9055778_9055797_0\"><sub><strong>[dcl.ref]</strong> [...] a null reference cannot exist in a well-defined program, because the only way to create such a reference would be to bind it to the \u201cobject\u201d obtained by dereferencing a null pointer, which causes undefined behavior.</sub></p>\n</blockquote>\n</hr>", "OwnerUserId": "129570", "LastEditorUserId": "129570", "LastEditDate": "2017-01-09T15:09:58.350", "Id": "9055797", "Score": "22", "CreationDate": "2012-01-29T18:58:34.703", "LastActivityDate": "2017-01-09T15:09:58.350"}, "bq_ids": {"n4140": {"so_9055778_9055797_0": {"section_id": 3222, "quality": 0.9047619047619048, "length": 19}}, "n3337": {"so_9055778_9055797_0": {"section_id": 3096, "quality": 0.9523809523809523, "length": 20}}, "n4659": {"so_9055778_9055797_0": {"section_id": 3979, "quality": 0.9047619047619048, "length": 19}}}});