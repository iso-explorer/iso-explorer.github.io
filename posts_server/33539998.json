post_cb({"33539998": {"CommentCount": "4", "ViewCount": "826", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2015-11-05T08:46:19.743", "LastActivityDate": "2015-11-05T12:35:42.803", "Title": "Why implicitly deleted move constructor call copy constructor?", "FavoriteCount": "1", "LastEditDate": "2017-05-23T12:23:19.400", "Id": "33539998", "Score": "3", "Body": "<p>implicitly deleted move constructor (C's move) looks like non-declared move and compiler try to use the copy constructor (C's copy). </p>\n<p>Why there is the <strong>difference</strong> between the <strong>implicitly</strong> deleted move (C's move) and <strong>explicitly</strong> deleted move (B's move)?</p>\n<p>There are some explanations, are there any more details?</p>\n<p><a href=\"https://stackoverflow.com/questions/20608662/why-is-the-move-constructor-neither-declared-nor-deleted-with-clang\">Why is the move constructor neither declared nor deleted with clang?</a></p>\n<p>@dyp comment:</p>\n<blockquote>\n<p id=\"so_33539998_33539998_0\">Because an implicitly deleted move constructor is not declared</p>\n</blockquote>\n<p>and link to DR1402:</p>\n<p><a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1402\" rel=\"nofollow noreferrer\">http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1402</a></p>\n<blockquote>\n<p id=\"so_33539998_33539998_1\">A defaulted move constructor that is defined as deleted is ignored by overload resolution (13.3 [over.match]). [Note: A deleted move constructor would otherwise interfere with initialization from an rvalue which can use the copy constructor instead. \u2014end note]</p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/language/move_constructor\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/language/move_constructor</a></p>\n<blockquote>\n<p id=\"so_33539998_33539998_2\">(since C++14)The deleted implicitly-declared move constructor is ignored by overload resolution (otherwise it would prevent copy-initialization from rvalue)</p>\n</blockquote>\n<p>sample code:</p>\n<pre><code>#include &lt;utility&gt;\n\nclass A {\npublic:\n    A() = default;\n    A(const A&amp;) = delete;\n    A(A&amp;&amp;) = delete;\n};\n\nclass B : public A {\npublic:\n    B() = default;\n    B(const B&amp;) = delete;\n    B(B&amp;&amp;) = delete; // explicitly deleted move\n};\n\nclass C: public A {\npublic:\n    C() = default;\n    C(const C&amp;) = default; // implicitly deleted copy because A's copy is deleted\n    C(C&amp;&amp;) = default; // implicitly deleted move because A's move is deleted\n};\n\nint main() {\n    A a1;\n    A a2(std::move(a1)); // error, A's move is explicitly deleted\n\n    B b1;\n    B b2(std::move(b1)); // error, B's move is explicitly deleted\n\n    C c1;\n    C c2(std::move(c1)); // error, C's **copy** is implicitly deleted\n\n    return 0;\n}\n</code></pre>\n<p>compiler message:</p>\n<pre><code>Apple LLVM version 7.0.0 (clang-700.1.76)\nclang++ -std=c++11 3.cpp\n\n3.cpp:26:7: error: call to deleted constructor of 'A'\n    A a2(std::move(a1)); // error, A's move is explicited deleted\n      ^  ~~~~~~~~~~~~~\n3.cpp:7:5: note: 'A' has been explicitly marked deleted here\n    A(A&amp;&amp;) = delete;\n    ^\n3.cpp:29:7: error: call to deleted constructor of 'B'\n    B b2(std::move(b1)); // error, B's move is explicited deleted\n      ^  ~~~~~~~~~~~~~\n3.cpp:14:5: note: 'B' has been explicitly marked deleted here\n    B(B&amp;&amp;) = delete; // explicitly deleted move\n    ^\n3.cpp:32:7: error: call to implicitly-deleted copy constructor of 'C'\n    C c2(std::move(c1)); // error, C's **copy** is implicited deleted\n      ^  ~~~~~~~~~~~~~\n3.cpp:20:5: note: explicitly defaulted function was implicitly deleted here\n    C(const C&amp;) = default; // implicitly deleted copy\n    ^\n3.cpp:17:10: note: copy constructor of 'C' is implicitly deleted because base class 'A' has a deleted copy constructor\nclass C: public A {\n         ^\n3.cpp:6:5: note: 'A' has been explicitly marked deleted here\n    A(const A&amp;) = delete;\n    ^\n3 errors generated.\n</code></pre>\n", "Tags": "<c++11><constructor><move>", "OwnerUserId": "248561", "AnswerCount": "1"}, "33542492": {"ParentId": "33539998", "CommentCount": "4", "Body": "<p>std::move does not necessarily force moving, it just casts the argument as an xvalue so that it <em>may</em> be moved, if possible. It can be ignored, and is most times unnecessary to call std::move to make the compiler move, or even better optimize copies away completely.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/utility/move\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/utility/move</a></p>\n<blockquote>\n<p id=\"so_33539998_33542492_0\">It is exactly equivalent to a static_cast to an rvalue reference type.</p>\n</blockquote>\n<pre><code>static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t)\n</code></pre>\n", "OwnerUserId": "3419420", "PostTypeId": "2", "Id": "33542492", "Score": "0", "CreationDate": "2015-11-05T10:42:25.033", "LastActivityDate": "2015-11-05T10:42:25.033"}, "bq_ids": {"n4140": {"so_33539998_33539998_1": {"section_id": 460, "quality": 0.8076923076923077, "length": 21}, "so_33539998_33539998_0": {"section_id": 458, "quality": 0.6666666666666666, "length": 4}, "so_33539998_33539998_2": {"section_id": 460, "quality": 0.5714285714285714, "length": 8}, "so_33539998_33542492_0": {"section_id": 466, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_33539998_33539998_0": {"section_id": 449, "quality": 0.8333333333333334, "length": 5}, "so_33539998_33542492_0": {"section_id": 457, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_33539998_33539998_1": {"section_id": 483, "quality": 0.8076923076923077, "length": 21}, "so_33539998_33539998_0": {"section_id": 481, "quality": 0.6666666666666666, "length": 4}, "so_33539998_33539998_2": {"section_id": 483, "quality": 0.5714285714285714, "length": 8}, "so_33539998_33542492_0": {"section_id": 489, "quality": 0.6666666666666666, "length": 4}}}});