post_cb({"37308265": {"ParentId": "37306477", "CommentCount": "1", "CreationDate": "2016-05-18T19:13:26.070", "OwnerUserId": "819272", "PostTypeId": "2", "Id": "37308265", "Score": "1", "Body": "<blockquote>\n<p id=\"so_37306477_37308265_0\"><strong>17.6.4.2.1 Namespace std [namespace.std]</strong> </p>\n<p id=\"so_37306477_37308265_1\">1 The behavior of a C++ program is undefined if it adds declarations or definitions to\n  <code>namespace std</code> or to a namespace within <code>namespace std</code> unless otherwise\n  specified. A program may add a template specialization for any\n  standard library template to <code>namespace std</code> only if the declaration\n  depends on a user-defined type and the specialization meets the\n  standard library requirements for the original template and is not\n  explicitly prohibited.</p>\n</blockquote>\n<p>Since you redefined a general template that already exists to <code>namespace std</code>, you have undefined behavior. And that includes as @T.C. mentions in the comments, that the program works fine.</p>\n", "LastActivityDate": "2016-05-18T19:13:26.070"}, "bq_ids": {"n4140": {"so_37306477_37308265_1": {"section_id": 6299, "quality": 0.9705882352941176, "length": 33}}, "n3337": {"so_37306477_37308265_1": {"section_id": 6056, "quality": 0.9705882352941176, "length": 33}}, "n4659": {"so_37306477_37308265_1": {"section_id": 7808, "quality": 0.9705882352941176, "length": 33}}}, "37306477": {"CommentCount": "2", "CreationDate": "2016-05-18T17:29:46.463", "PostTypeId": "1", "AcceptedAnswerId": "37308265", "LastEditorUserId": "2561271", "LastActivityDate": "2016-05-18T19:13:26.070", "LastEditDate": "2016-05-18T18:06:15.433", "ViewCount": "158", "FavoriteCount": "1", "Title": "Re-defining std::hash template struct", "Id": "37306477", "Score": "0", "Body": "<p>Normally, if a hash is needed for a new type, <code>std::hash</code> must be specialized. I wrote a test hashing library and would like to use it for all types not already specialized by the standard library.</p>\n<p>I tried the following with gcc/4.9.3 and clang/3.7.0. To my surprise, it works.</p>\n<pre><code>#include &lt;utility&gt;\n#include &lt;functional&gt;\n#include &lt;iostream&gt;\n\nnamespace std {\n\ntemplate&lt;typename T&gt;\nclass hash\n{\n    public:\n        size_t operator()(const T &amp; obj)\n        {\n            return 99;\n        }\n};\n}\n\nint main(void)\n{\n    int i = 10;\n    std::pair&lt;int, int&gt; pi{22,33};\n\n    std::hash&lt;int&gt; hi;\n    std::hash&lt;std::pair&lt;int, int&gt;&gt; hpi;\n\n    std::cout &lt;&lt; \"Hash of int: \" &lt;&lt; hi(i) &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"Hash of int pair: \" &lt;&lt; hpi(pi) &lt;&lt; \"\\n\";\n    return 0;\n}\n</code></pre>\n<p>The hash of the integer is the integer itself (which is the standard library version) and the hash of the pair is 99.</p>\n<p>So two questions.</p>\n<ol>\n<li><p>Why does it work? the templated version of <code>std::hash</code> should already be declared. (My only guess is it's in a deeper namespace, which gets forwarded)</p></li>\n<li><p>Is this standard behavior?</p></li>\n</ol>\n<p>Edit: Answer to question 1 - <code>template&lt;typename T&gt; struct hash</code> is declared, but doesn't seem to be defined anywhere. That is why I can define it.</p>\n", "Tags": "<c++><hash><stl>", "OwnerUserId": "2561271", "AnswerCount": "1"}});