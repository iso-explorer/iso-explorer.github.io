post_cb({"39300770": {"ParentId": "39300653", "CommentCount": "0", "Body": "<p><code>void()</code> is interpreted as type-id when used with <code>sizeof</code>.<br>\n<code>void()</code> is interpreted as an expression when used with <code>decltype</code>.  </br></p>\n<p>I don't think <code>void{}</code> is valid in any context. It is neither a valid type-id nor a valid expression.</p>\n", "OwnerUserId": "434551", "PostTypeId": "2", "Id": "39300770", "Score": "5", "CreationDate": "2016-09-02T21:13:03.293", "LastActivityDate": "2016-09-02T21:13:03.293"}, "39300653": {"CommentCount": "8", "ViewCount": "188", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-09-02T21:01:27.087", "LastActivityDate": "2017-04-23T20:21:05.363", "Title": "Differences between decltype(void()) and decltype(void{})", "AcceptedAnswerId": "39300770", "LastEditDate": "2017-05-23T11:54:33.733", "Id": "39300653", "Score": "10", "Body": "<p>This is a follow-up of the question: <a href=\"https://stackoverflow.com/questions/39279074/what-does-the-void-in-decltypevoid-mean-exactly\">What does the <code>void()</code> in <code>decltype(void())</code> mean exactly?</a>.</p>\n<hr>\n<p><code>decltype(void())</code> compiles fine and what the <code>void()</code> means in this case is explained in the above mentioned question (actually in the answer).<br>\nOn the other side, I noticed that <code>decltype(void{})</code> doesn't compile.</br></p>\n<p>What's the difference between them (in the context of a <code>decltype</code> at least)?<br>\nWhy doesn't the second expression compile?</br></p>\n<hr>\n<p>For completeness, it follows a minimal (not-)working example:</p>\n<pre><code>int main() {\n    // this doesn't compile\n    //decltype(void{}) *ptr = nullptr;\n    // this compiles fine\n    decltype(void()) *ptr = nullptr;\n    (void)ptr;\n}\n</code></pre>\n</hr></hr>", "Tags": "<c++><c++11><language-lawyer><void><decltype>", "OwnerUserId": "4987285", "AnswerCount": "2"}, "43576047": {"ParentId": "39300653", "CommentCount": "2", "Body": "<p>(Building on discussion in the question comments)</p>\n<p><strong>Note:</strong> I was referencing C++17 or close-to for the answer. C++14 works the same way, the text difference is noted near the end of the answer.</p>\n<p><code>void()</code> is a special exception. See N4618 5.2.3 <strong>[expr.type.conv]</strong>, emphasis mine:</p>\n<blockquote>\n<p id=\"so_39300653_43576047_0\">1 A <strong><em>simple-type-speci\ufb01er</em></strong> (7.1.7.2) or <em>typename-speci\ufb01er</em> (14.6) <strong>followed by a parenthesized optional <em>expression-list</em> or by a <em>braced-init-list</em></strong> (the initializer) constructs a value of the speci\ufb01ed type given the initializer. If the type is a placeholder for a deduced class type, it is replaced by the return type of the function selected by overload resolution for class template deduction (13.3.1.8) for the remainder of this section.</p>\n<p id=\"so_39300653_43576047_1\">2 If the initializer is a parenthesized single expression, the type conversion expression is equivalent (in de\ufb01nedness, and if de\ufb01ned in meaning) to the corresponding cast expression (5.4). <strong>If the type is (possibly cv-quali\ufb01ed) void and the initializer is (), the expression is a prvalue of the speci\ufb01ed type that performs no initialization.</strong> Otherwise, the expression is a prvalue of the speci\ufb01ed type whose result object is direct-initialized (8.6) with the initializer. For an expression of the form T(), T shall not be an array type.</p>\n</blockquote>\n<p>So <code>void()</code> is only valid because it's explicitly identified in <strong>[expr.type.conv]/2</strong> as <em>no initialization</em>. <code>void{}</code> doesn't meet that exception, so it attempts to be a <em>direct-initialized</em> object.</p>\n<p><strong>tl;dr</strong> here through C++14 notes: You cannot <em>direct-initialize</em> a <code>void</code> object.</p>\n<p>Rabbit-holing through N4618 8.6 <strong>[dcl.init]</strong> to see what's actually going on with <code>void{}</code></p>\n<ul>\n<li>8.6/16 =&gt; <em>direct-initialization</em></li>\n<li>8.6/17.1 =&gt; <em>list-initialized</em>, jump to 8.6.4</li>\n<li>8.6.4/3.10 =&gt; <em>value-initialized</em>\n<ul>\n<li><code>void()</code> would have shortcut the above three with 8.6/11 =&gt; <em>value-initialized</em>, and then rejoined the trail, which is why the special exception in <strong>[expr.type.conv]</strong> is needed.</li>\n</ul></li>\n<li>8.6/8.4 =&gt; <em>zero-initialized</em></li>\n</ul>\n<p>Now, 8.6/6 defines <em>zero-initialize</em> for:</p>\n<ul>\n<li><em>scalar</em></li>\n<li><em>non-union class type</em></li>\n<li><em>union type</em></li>\n<li><em>array type</em></li>\n<li><em>reference type</em></li>\n</ul>\n<p>N4618 3.9 <strong>[basic.types]/9</strong> defines <em>scalar</em>:</p>\n<blockquote>\n<p id=\"so_39300653_43576047_2\">Arithmetic types (3.9.1), enumeration types, pointer types, pointer to member types(3.9.2), <strong>std::nullptr_t</strong>, and cv-quali\ufb01ed versions of these types (3.9.3) are collectively called <em>scalar types</em>.</p>\n</blockquote>\n<p>N4618 3.9.1 <strong>[basic.fundamental]/8</strong> defines <em>arithmetic types</em>:</p>\n<blockquote>\n<p id=\"so_39300653_43576047_3\">Integral and \ufb02oating types are collectively called <em>arithmetic types</em>.</p>\n</blockquote>\n<p>So <code>void</code> is not an <em>arithmetic type</em>, so it's not a <em>scalar</em>, so it cannot be <em>zero-initialized</em>, so it cannot be <em>value-initialized</em>, so it cannot be <em>direct-initialized</em>, so the expression is not valid.</p>\n<p>Apart from the initialisation, <code>void()</code> and <code>void{}</code> would work the same way, producing a <em>prvalue</em> expression of type <code>void</code>. Even though you cannot have a <em>result object</em> for an incomplete type, and <code>void</code> is <em>always</em> incomplete:</p>\n<p>N4618 3.9.1 <strong>[basic.fundamental]/9</strong> (bold mine):</p>\n<blockquote>\n<p id=\"so_39300653_43576047_4\">A <strong>type cv void is an incomplete type</strong> that cannot be completed; such a type has an empty set of values.</p>\n</blockquote>\n<p><code>decltype</code> specifically allows incomplete types:</p>\n<p>N4618 7.1.7.2 <strong>[decl.type.simple]/5</strong> (bold mine):</p>\n<blockquote>\n<p id=\"so_39300653_43576047_5\">If the operand of a <em>decltype-speci\ufb01er</em> is a prvalue, the temporary materialization conversion is not applied (4.4) and no result object is provided for the prvalue. <strong>The type of the prvalue may be incomplete.</strong></p>\n</blockquote>\n<hr>\n<p>In C++14, N4296 5.2.3 <strong>[expr.type.conv]</strong> is differently worded. The braced form was almost an afterthought to the parenthesised version:</p>\n<blockquote>\n<p id=\"so_39300653_43576047_6\">A <em>simple-type-speci\ufb01er</em> (7.1.6.2) or <em>typename-speci\ufb01er</em> (14.6) followed by a parenthesized <em>expression-list</em> constructs a value of the speci\ufb01ed type given the expression list. If the expression list is a single expression, the type conversion expression is equivalent (in de\ufb01nedness, and if de\ufb01ned in meaning) to the corresponding cast expression (5.4). If the type speci\ufb01ed is a class type, the class type shall be complete. If the expression list speci\ufb01es more than a single value,the type shall be a class with a suitably declared constructor(8.5,12.1), and the expression <code>T(x1, x2, ...)</code> is equivalent in e\ufb00ect to the declaration <code>T t(x1, x2, ...)</code>; for some invented temporary variable t, with the result being the value of t as a prvalue.</p>\n<p id=\"so_39300653_43576047_7\">The expression T(), where T is a <code>simple-type-speci\ufb01er</code> or <code>typename-speci\ufb01er</code> for a non-array complete object type or the (possibly cv-quali\ufb01ed) <code>void</code> type, creates a prvalue of the speci\ufb01ed type, whose value is that produced by value-initializing (8.5) an object of type T; no initialization is done for the void() case. [<em>Note:</em> if <code>T</code> is a non-class type that is cv-quali\ufb01ed, the <em>cv-quali\ufb01ers</em> are discarded when determining the type of the resulting prvalue (Clause 5). <em>\u2014end note</em>]</p>\n<p id=\"so_39300653_43576047_8\">Similarly, a <em>simple-type-speci\ufb01er</em> or <em>typename-speci\ufb01er</em> followed by a <em>braced-init-list</em> creates a temporary object of the speci\ufb01ed type direct-list-initialized (8.5.4) with the speci\ufb01ed <em>braced-init-list</em>, and its value is that temporary object as a prvalue.</p>\n</blockquote>\n<p>The effect is the same for our purposes, the <a href=\"https://github.com/cplusplus/draft/commit/611f4c675e2160463cb1fbf71ab87bd67c9102eb\" rel=\"nofollow noreferrer\">change</a> relates to <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0135r1.html\" rel=\"nofollow noreferrer\">P0135R1 Wording for guaranteed copy elision through simplified value categories</a>, which removed temporary object creation from expressions. Instead, the context of the expression provides a result object to be initialised by the expression, if the context needs it.</p>\n<p>As noted above, <code>decltype</code> (unlike <code>sizeof</code> or <code>typeid</code>) doesn't provide a result-object for the expression, which is why <code>void()</code> works even though it cannot initialise a result object.</p>\n<hr>\n<p>I feel that the exception in N4618 5.2.3 <strong>[expr.type.conv]</strong> ought to be applied to <code>void{}</code> too. It means that guidelines around <code>{}</code> get more complex. See for example <a href=\"https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-list\" rel=\"nofollow noreferrer\">ES.23: Prefer the {} initializer syntax</a> in the C++ Core Guidelines, which would currently recommend <code>decltype(void{})</code> over <code>decltype(void())</code>. <code>decltype(T{})</code> is more likely to be where this one bites you...</p>\n</hr></hr>", "OwnerUserId": "166389", "PostTypeId": "2", "Id": "43576047", "Score": "2", "CreationDate": "2017-04-23T20:21:05.363", "LastActivityDate": "2017-04-23T20:21:05.363"}, "bq_ids": {"n4140": {"so_39300653_43576047_6": {"section_id": 5999, "quality": 0.8032786885245902, "length": 49}, "so_39300653_43576047_3": {"section_id": 7217, "quality": 0.7142857142857143, "length": 5}, "so_39300653_43576047_2": {"section_id": 7207, "quality": 0.7894736842105263, "length": 15}, "so_39300653_43576047_4": {"section_id": 7218, "quality": 0.6363636363636364, "length": 7}, "so_39300653_43576047_7": {"section_id": 6000, "quality": 0.7560975609756098, "length": 31}, "so_39300653_43576047_8": {"section_id": 6001, "quality": 0.7368421052631579, "length": 14}}, "n3337": {"so_39300653_43576047_6": {"section_id": 5767, "quality": 0.8032786885245902, "length": 49}, "so_39300653_43576047_3": {"section_id": 5714, "quality": 0.5714285714285714, "length": 4}, "so_39300653_43576047_2": {"section_id": 6951, "quality": 0.7368421052631579, "length": 14}, "so_39300653_43576047_4": {"section_id": 6962, "quality": 0.6363636363636364, "length": 7}, "so_39300653_43576047_7": {"section_id": 5768, "quality": 0.5365853658536586, "length": 22}, "so_39300653_43576047_8": {"section_id": 5769, "quality": 0.7368421052631579, "length": 14}}, "n4659": {"so_39300653_43576047_3": {"section_id": 8726, "quality": 0.8571428571428571, "length": 6}, "so_39300653_43576047_2": {"section_id": 8716, "quality": 0.7894736842105263, "length": 15}, "so_39300653_43576047_4": {"section_id": 8727, "quality": 0.9090909090909091, "length": 10}, "so_39300653_43576047_0": {"section_id": 7499, "quality": 0.8235294117647058, "length": 28}, "so_39300653_43576047_1": {"section_id": 7500, "quality": 0.8, "length": 32}, "so_39300653_43576047_5": {"section_id": 6868, "quality": 0.875, "length": 14}}}});