post_cb({"bq_ids": {"n4140": {"so_49206080_49206257_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 3241}}, "n3337": {"so_49206080_49206257_0": {"length": 11, "quality": 0.8461538461538461, "section_id": 3114}}, "n4659": {"so_49206080_49206257_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 3997}}}, "49206257": {"Id": "49206257", "PostTypeId": "2", "Body": "<p>When you declare a <em>function parameter</em> like this</p>\n<pre><code>short a[size]\n</code></pre>\n<p>you are declaring a pointer, not an array:</p>\n<blockquote>\n<p id=\"so_49206080_49206257_0\">[dcl.fct] After determining\n  the type of each parameter, any parameter of type \u201carray of T\u201d or of function type T is adjusted to be \u201cpointer to T\u201d.</p>\n</blockquote>\n<p><code>foo(short (&amp;a)[size])</code> requires a reference to an array of size <code>size</code>. A pointer cannot be converted to one.</p>\n", "LastActivityDate": "2018-03-10T06:53:50.423", "CommentCount": "0", "CreationDate": "2018-03-10T06:53:50.423", "ParentId": "49206080", "Score": "1", "OwnerUserId": "775806"}, "49206080": {"ViewCount": "33", "Body": "<p>I'm trying to pass an array to a function but I'm getting this weird error</p>\n<pre><code>const int size = 2;\nvoid foo(short (&amp;a)[size]){\n  cout &lt;&lt; a;\n}\nvoid testSequence(short a[size]){\n  foo(a);\n}\n</code></pre>\n<p>error: invalid initialization of reference of type \u2018short int (&amp;)[4]\u2019 from expression of type \u2018short int*\u2019</p>\n", "Title": "invalid initialization of reference of type \u2018short int (&)", "CreationDate": "2018-03-10T06:29:37.080", "LastActivityDate": "2018-03-10T06:57:49.030", "CommentCount": "5", "LastEditDate": "2018-03-10T06:54:05.017", "PostTypeId": "1", "LastEditorUserId": "8184482", "Id": "49206080", "ClosedDate": "2018-03-10T08:49:52.763", "Score": "-2", "OwnerUserId": "8184482", "Tags": "<c++>", "AnswerCount": "2"}, "49206287": {"Id": "49206287", "PostTypeId": "2", "Body": "<p>The declaration</p>\n<pre><code>void testSequence(short a[size]);\n</code></pre>\n<p>is the same as</p>\n<pre><code>void testSequence(short a[]);\n</code></pre>\n<p>which is the same as</p>\n<pre><code>void testSequence(short* a);\n</code></pre>\n<p>Hence, the call </p>\n<pre><code>foo(a); \n</code></pre>\n<p>from the function is not valid.</p>\n<p>In order to be able to use</p>\n<pre><code>foo(a);\n</code></pre>\n<p>you'll have to use:</p>\n<pre><code>void testSequence(short (&amp;a)[size]){\n  foo(a);\n}\n</code></pre>\n<hr>\n<p>The line</p>\n<pre><code>cout &lt;&lt; a;\n</code></pre>\n<p>in <code>foo</code> is not right either. There is no overload of the <code>&lt;&lt;</code> operator that allows writing a reference to an array of <code>int</code>s to <code>cout</code>. You can use:</p>\n<pre><code>for ( size_t i = 0; i &lt; size; ++i )\n{\n   std::cout &lt;&lt; a[i] &lt;&lt; std::endl;\n}\n</code></pre>\n</hr>", "LastActivityDate": "2018-03-10T06:57:49.030", "CommentCount": "0", "CreationDate": "2018-03-10T06:57:49.030", "ParentId": "49206080", "Score": "1", "OwnerUserId": "434551"}});