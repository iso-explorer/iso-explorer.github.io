post_cb({"23895545": {"CommentCount": "2", "ViewCount": "227", "CreationDate": "2014-05-27T17:31:27.713", "LastActivityDate": "2014-05-27T18:14:50.960", "Title": "Why does template parameter deduction fail when calling the constructor like this?", "AcceptedAnswerId": "23895705", "PostTypeId": "1", "Id": "23895545", "Score": "1", "Body": "<p>The following won't compile:</p>\n<pre><code>struct S {\n    template &lt;class T&gt; S(T) {}\n};\nvoid f(int) {}\nint main() {\n    S(f);\n}\n</code></pre>\n<p>g++-4.9 says</p>\n<pre><code>template.cpp: In function \u2018int main()\u2019:\ntemplate.cpp:6:8: error: no matching function for call to \u2018S::S()\u2019\n     S(f);\n        ^\ntemplate.cpp:6:8: note: candidates are:\ntemplate.cpp:2:24: note: template&lt;class T&gt; S::S(T)\n     template &lt;class T&gt; S(T) {}\n                        ^\ntemplate.cpp:2:24: note:   template argument deduction/substitution failed:\ntemplate.cpp:6:8: note:   candidate expects 1 argument, 0 provided\n     S(f);\n        ^\ntemplate.cpp:1:8: note: constexpr S::S(const S&amp;)\n struct S {\n        ^\ntemplate.cpp:1:8: note:   candidate expects 1 argument, 0 provided\ntemplate.cpp:1:8: note: constexpr S::S(S&amp;&amp;)\ntemplate.cpp:1:8: note:   candidate expects 1 argument, 0 provided\n</code></pre>\n<p>clang gives a similar error.</p>\n<p>On the other hand, the following compiles:</p>\n<pre><code>struct S {\n    template &lt;class T&gt; S(T) {}\n};\nvoid f(int) {}\nint main() {\n    S s = S(f); // this line was changed\n}\n</code></pre>\n<p>So what's going on here?</p>\n", "Tags": "<c++><templates>", "OwnerUserId": "481267", "AnswerCount": "2"}, "23895705": {"ParentId": "23895545", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-05-27T17:42:15.783", "Score": "7", "LastEditorUserId": "1090079", "LastEditDate": "2014-05-27T18:01:40.607", "Id": "23895705", "OwnerUserId": "1090079", "Body": "<p><strong>THE PROBLEM</strong></p>\n<p>The code you've written doesn't mean what you think it is, you are actually declaring a variable of type <code>S</code> having the name <code>f</code>; it is <strong>not</strong> constructing an unnamed entity of type <code>S</code>, with <code>f</code> as argument.</p>\n<p><sup> <strong>Note:</strong> When you change the line into <code>S s = S(f)</code> you are however declaring a variable named <code>s</code> of type <code>S</code>, initialized with a temporary <code>S(f)</code> (ie. the <em>copy-constructor</em> of <em>S</em>  will be used to initialize <code>s</code>).</sup></p>\n<hr>\n<p><strong>THE SOLUTION</strong></p>\n<p>Wrap the type in parenthesis, or use <em>uniform-initialization</em> (which was introduced in C++11).</p>\n<pre><code>(S) (f); // creates a temporary of type S initialized with `f`\n</code></pre>\n<p><sup></sup></p>\n<pre><code>S { f }; // c++11\n</code></pre>\n<hr>\n<p><strong>THE REASON</strong></p>\n<p>The standard (<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"nofollow\">n3797</a>) says that <code>T(x)</code> is equivalent to <code>T x</code> when declaring a variable, as can be read in the below section:</p>\n<blockquote>\n<p id=\"so_23895545_23895705_0\">8.3p6 <strong>Meaning of declarators</strong> <code>[dcl.meaning]</code></p>\n<blockquote>\n<p id=\"so_23895545_23895705_4\">In a declaration <code>T D</code> where <code>D</code> has the form</p>\n<pre><code>( D1 )\n</code></pre>\n<p id=\"so_23895545_23895705_5\">the type of the contained declarator-id is the same as of the\n    contained <em>declarator-id</em>  in the declaration</p>\n<pre><code>T D1\n</code></pre>\n<p id=\"so_23895545_23895705_6\">Parentheses do not alter the type of the embedded <em>declarator-id</em>, but\n    they can alter the binding of complex declarators.</p>\n</blockquote>\n</blockquote>\n</hr></hr>", "LastActivityDate": "2014-05-27T18:01:40.607"}, "23895992": {"ParentId": "23895545", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-05-27T17:59:29.753", "Score": "0", "LastEditorUserId": "1870232", "LastEditDate": "2014-05-27T18:14:50.960", "Id": "23895992", "OwnerUserId": "1870232", "Body": "<p>With your definition of struct <code>S</code></p>\n<pre><code>int main() {\n\n    S(f);                                            //  1 &lt;-----+\n    S s(f);           //  2 &lt;-------+                //          +---- SAME\n    S s1 ;            //            +---- SAME       //  3 &lt;-----+\n    S s2 = S(f) ;     //  4 &lt;-------+\n\n}\n</code></pre>\n<ul>\n<li>1 &amp; 3 Declares a variable <code>f</code> &amp; <code>s1</code> respectively of type <code>S</code> requires a constructor for initialization</li>\n<li>2 &amp; 4 construct a variable <code>s</code> &amp; <code>s2</code> respectively of type <code>S</code> using copy constructor (note here the <code>f</code> is not your function name)</li>\n</ul>\n", "LastActivityDate": "2014-05-27T18:14:50.960"}, "bq_ids": {"n4140": {"so_23895545_23895705_3": {"section_id": 3213, "quality": 1.0, "length": 12}, "so_23895545_23895705_6": {"section_id": 3213, "quality": 1.0, "length": 12}, "so_23895545_23895705_2": {"section_id": 3213, "quality": 1.0, "length": 7}, "so_23895545_23895705_5": {"section_id": 3213, "quality": 1.0, "length": 7}}, "n3337": {"so_23895545_23895705_3": {"section_id": 3087, "quality": 1.0, "length": 12}, "so_23895545_23895705_6": {"section_id": 3087, "quality": 1.0, "length": 12}, "so_23895545_23895705_2": {"section_id": 3087, "quality": 1.0, "length": 7}, "so_23895545_23895705_5": {"section_id": 3087, "quality": 1.0, "length": 7}}, "n4659": {"so_23895545_23895705_3": {"section_id": 3970, "quality": 1.0, "length": 12}, "so_23895545_23895705_6": {"section_id": 3970, "quality": 1.0, "length": 12}, "so_23895545_23895705_2": {"section_id": 3970, "quality": 1.0, "length": 7}, "so_23895545_23895705_5": {"section_id": 3970, "quality": 1.0, "length": 7}}}});