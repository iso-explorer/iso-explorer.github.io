post_cb({"bq_ids": {"n4140": {"so_10062156_10062510_2": {"length": 47, "quality": 0.9591836734693877, "section_id": 7070}, "so_10062156_10062510_0": {"length": 7, "quality": 0.875, "section_id": 7070}}, "n3337": {"so_10062156_10062510_2": {"length": 47, "quality": 0.9591836734693877, "section_id": 6814}, "so_10062156_10062510_0": {"length": 7, "quality": 0.875, "section_id": 6814}}, "n4659": {"so_10062156_10062510_2": {"length": 47, "quality": 0.9591836734693877, "section_id": 8570}}}, "10062510": {"Id": "10062510", "PostTypeId": "2", "Body": "<p>I think the array bound in a member definition is in class scope. Standard 3.3.7/1:</p>\n<blockquote>\n<p id=\"so_10062156_10062510_0\">The following rules describe the scope of names declared in classes.</p>\n<p id=\"so_10062156_10062510_1\">...</p>\n<p id=\"so_10062156_10062510_2\">5) The potential scope of a declaration that extends to or past the end of a class definition also extends to the regions defined by its member definitions, even if the members are defined lexically outside the class (this includes static data member definitions, nested class definitions, member function definitions (including the member function body and any portion of the declarator part of such definitions which <strong>follows the declarator-id</strong>, including a parameter-declaration-clause and any default arguments (8.3.6). ...</p>\n</blockquote>\n<p>Here the declarator-id is <code>X::arr</code>.</p>\n", "LastActivityDate": "2012-04-08T11:35:35.853", "CommentCount": "1", "CreationDate": "2012-04-08T11:35:35.853", "ParentId": "10062156", "Score": "4", "OwnerUserId": "1294391"}, "10062156": {"ViewCount": "220", "Body": "<p>I was going to file a bug against GCC, but then realized that if my interpretation of the Standard is correct, it's a core language defect, not a compiler bug.</p>\n<p>When a static data member of array type is defined outside class scope, identifiers in the array bound are looked up in class scope.</p>\n<p>\u00a79.4.2 [class.static.data] says \"The initializer expression in the definition of a static data member is in the scope of its class (3.3.7),\" but doesn't say anything about the declarator itself. It seems that this is the only name lookup context within a declarator.</p>\n<p>\u00a78.4.2 [dcl.array] doesn't mention the scope of the array bound, so by default the expression is evaluated in the enclosing scope, which is the namespace.</p>\n<pre><code>class X {\n  static int const size = some_complicated_metafunction&lt;&gt;::value;\n  static int arr[ size ];\n};\n\n// \"size\" should be qualified as \"X::size\", which is an access violation.\nint X::arr[ size ] = {};\n</code></pre>\n<p>The problem is that if the array bound is not evaluated in class scope, there is no way to access private class members, and <code>some_complicated_metafunction&lt;&gt;</code> would have to be respecified. The array bound needs the same scope as the initializer, for essentially the same reason as the initializer. (Although not quite as strong, since constant expressions can always be recomputed, unlike the address of a private object.)</p>\n<p>Am I missing something or is a DR in order?</p>\n", "AcceptedAnswerId": "10062510", "Title": "Scope of evaluation of array bound of static data member", "CreationDate": "2012-04-08T10:38:28.857", "Id": "10062156", "CommentCount": "6", "LastEditDate": "2012-04-08T19:55:47.897", "PostTypeId": "1", "LastEditorUserId": "168868", "LastActivityDate": "2012-04-08T19:55:47.897", "Score": "3", "OwnerUserId": "153285", "Tags": "<c++><arrays>", "AnswerCount": "1"}});