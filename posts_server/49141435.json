post_cb({"bq_ids": {"n4140": {"so_49141435_49141572_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 3321}, "so_49141435_49141572_1": {"length": 14, "quality": 0.875, "section_id": 378}}, "n3337": {"so_49141435_49141572_2": {"length": 11, "quality": 0.9166666666666666, "section_id": 3191}, "so_49141435_49141572_1": {"length": 14, "quality": 0.875, "section_id": 369}}, "n4659": {"so_49141435_49141572_2": {"length": 12, "quality": 1.0, "section_id": 4087}}}, "49141572": {"Id": "49141572", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_49141435_49141572_0\">If the object is temporary, why would making the reference <code>const</code> have any effect on the lifetime of the temporary object?</p>\n</blockquote>\n<p>In the present context, the issue is not the lifetime of the object but whether you can modify it.</p>\n<p>Say you make a call.</p>\n<pre><code>foo(10);\n</code></pre>\n<p>The object that holds the value <code>10</code> in the call should not be modified by the function. If the interface of <code>foo</code> is:</p>\n<pre><code>void foo(int&amp; ref);\n</code></pre>\n<p>it's fair to implement <code>foo</code> as:</p>\n<pre><code>void foo(int&amp; ref)\n{\n   ref = 20;\n}\n</code></pre>\n<p>That would be a problem given the call <code>foo(10)</code>. It won't be a problem if <code>foo</code> uses a <code>const&amp;</code>.</p>\n<pre><code>void foo(int const&amp; ref)\n{\n   ref = 20; // Not allowed.\n}\n</code></pre>\n<hr>\n<p>From <a href=\"https://timsong-cpp.github.io/cppwp/n3337/class.temporary#1\" rel=\"nofollow noreferrer\">C++11 Standard, Temporary Objects/1</a></p>\n<blockquote>\n<p id=\"so_49141435_49141572_1\">Temporaries of class type are created in various contexts: binding a reference to a prvalue (<a href=\"https://timsong-cpp.github.io/cppwp/n3337/dcl.init.ref\" rel=\"nofollow noreferrer\">[dcl.init.ref]</a>), returning a prvalue (<a href=\"https://timsong-cpp.github.io/cppwp/n3337/stmt.return\" rel=\"nofollow noreferrer\">[stmt.return]</a>), a conversion that creates a prvalue, ...</p>\n</blockquote>\n<p>and from <a href=\"https://timsong-cpp.github.io/cppwp/n3337/dcl.init.ref#5.2\" rel=\"nofollow noreferrer\">C++11 Standard, References/5.2</a>:</p>\n<blockquote>\n<p id=\"so_49141435_49141572_2\">-- Otherwise, the reference shall be an lvalue reference to a non-volatile const type (i.e., cv1 shall be const), or the reference shall be an rvalue reference.</p>\n</blockquote>\n<p>A temporary can only bind to a reference to a prvalue. The type of such a reference must be a <code>const</code> qualified lvalue reference or a rvalue references.</p>\n<p>MS Visual Studio compilers have allowed binding of non-<code>const</code> references to temporary objects but it is not sanctioned by the standard.</p>\n</hr>", "LastEditorUserId": "434551", "LastActivityDate": "2018-03-07T05:10:27.313", "Score": "4", "CreationDate": "2018-03-06T23:14:00.550", "ParentId": "49141435", "CommentCount": "4", "OwnerUserId": "434551", "LastEditDate": "2018-03-07T05:10:27.313"}, "49141435": {"ViewCount": "108", "Body": "<p><a href=\"https://stackoverflow.com/a/36955656/4784683\">Source of question:</a></p>\n<blockquote>\n<p id=\"so_49141435_49141435_0\">The only failing case is passing parameters by non-const reference,\n  since temporary variable couldn't be bound to it.</p>\n</blockquote>\n<p><code>void DrawLine(const Vector&amp; v1, const Vector&amp; v2);</code></p>\n<p>If the object is temporary, why would making the reference <code>const</code> have any effect on the lifetime of the temporary object?</p>\n<p><em>I guess I also don't fully understand the scope of existence for temporary objects created in an argument.</em></p>\n", "AcceptedAnswerId": "49141572", "Title": "why can temporary objects be bound to const reference?", "CreationDate": "2018-03-06T23:00:37.237", "Id": "49141435", "CommentCount": "8", "PostTypeId": "1", "LastActivityDate": "2018-03-07T05:10:27.313", "Score": "0", "OwnerUserId": "4784683", "Tags": "<c++><stack><pass-by-reference>", "AnswerCount": "1"}});