post_cb({"36523039": {"Id": "36523039", "PostTypeId": "2", "Body": "<p>According to the draft standard <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4582.pdf\" rel=\"noreferrer\">N4582</a> <em>\u00a720.13.2 Header  synopsis [meta.type.synop] (Emphasis Mine)</em>:</p>\n<blockquote>\n<p id=\"so_36523038_36523039_0\">The behavior of a program that adds specializations for any of the\n  templates defined in this subclause is undefined <strong>unless otherwise\n  specified</strong>.</p>\n</blockquote>\n<p>Consequently, adding specializations for <code>type_traits</code> can cause undefined behaviour unless somewhere else in the standard there's a wording for a specific type trait that supersedes the wording displayed above. Fortunately, in <em>Table 60 - Other transformations</em>:</p>\n<p><a href=\"https://i.stack.imgur.com/sFiIZ.png\" rel=\"noreferrer\"><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/sFiIZ.png\"/></a></p>\n<p>There's the wording:</p>\n<blockquote>\n<p id=\"so_36523038_36523039_1\">A program may specialize this trait if at least one template parameter\n  in the specialization is a user-defined type. [ Note: Such\n  specializations are needed when only explicit conversions are desired\n  among the template arguments. \u2014 end note ]</p>\n</blockquote>\n<p>This means that specializations of <code>std::common_type</code> type trait that have at least one user-defined type are perfectly allowed. In fact if you take a look at <em>\u00a720.15.4.3 Specializations of common_type [time.traits.specializations]</em> you'll find out that STL already defines specializations of <code>std::common_type</code> for user defined types <code>std::chrono::duration</code> and <code>std::chrono::time_point</code>.</p>\n<p>Thus, the correct way to make <code>common_type</code> \"work\" for user defined types is to provide a specialization of it for those specific types, e.g.,</p>\n<pre><code>struct A {};\nstruct B {};\n\nnamespace std {\n  template&lt;&gt;\n  struct common_type&lt;A, B&gt; {\n    using type = A;\n  };\n} \n</code></pre>\n<p>In the code example above we specify that the common type between <code>A</code> and <code>B</code> is <code>A</code>.</p>\n", "LastActivityDate": "2016-04-09T21:39:54.830", "CommentCount": "0", "CreationDate": "2016-04-09T21:39:54.830", "ParentId": "36523038", "Score": "8", "OwnerUserId": "2352671"}, "bq_ids": {"n4140": {"so_36523038_36523039_0": {"length": 9, "quality": 0.9, "section_id": 4695}}, "n3337": {"so_36523038_36523039_0": {"length": 9, "quality": 0.9, "section_id": 4504}}, "n4659": {"so_36523038_36523039_0": {"length": 9, "quality": 0.9, "section_id": 6090}}}, "36523038": {"ViewCount": "365", "Body": "<p>Since C++11 the type trait <code>std::common_type</code> was introduced. <code>std::common_type</code> determines the common type between all of its template arguments. In C++14  its helper type <code>std::common_type_t</code> was also introduce in order to make code that uses <code>std::common_type</code> type trait shorter.</p>\n<p><code>std::common_type</code> is particular useful in overloaded arithmetic operators, e.g.,</p>\n<pre><code>template&lt;typename T1, typename T2&gt;\nstd::common_type_t&lt;T1, T2&gt; operator+(T1 const &amp;t1, T2 const &amp;t2) {\n  return t1 + t2;\n}\n</code></pre>\n<p>It works fine if its templates arguments are built in types (e.g., <code>int</code>, <code>double</code>). However I doesn't seem to work if I provide as template arguments to it user defined types e.g.,</p>\n<pre><code>struct A {};\nstruct B {};\n\nstd::common_type_t&lt;A, B&gt; // doesn't work\n</code></pre>\n<p><strong>Q</strong>: How I can make <code>std::common_type</code> trait work with user defined types?</p>\n", "AcceptedAnswerId": "36523039", "Title": "std::common_type trait for user defined types", "CreationDate": "2016-04-09T21:39:54.830", "Id": "36523038", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2016-04-09T21:39:54.830", "Score": "3", "OwnerUserId": "2352671", "Tags": "<c++><templates><c++11><c++14><typetraits>", "AnswerCount": "1"}});