post_cb({"20445634": {"Id": "20445634", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_20445051_20445634_0\">Are C++11 mutexes compatible with threads not created with C++11's standard libraries?</p>\n</blockquote>\n<p>The C++ standard does not define a \"thread\" as something exclusively created by the C++ standard library.</p>\n<blockquote>\n<p id=\"so_20445051_20445634_1\">1.10 Multi-threaded executions and data races [intro.multithread]</p>\n<p id=\"so_20445051_20445634_2\">1 A thread of execution (also known as a thread) is a single flow of\n  control within a program, including the initial invocation of a\n  specific top-level function, and recursively including every function\n  invocation subsequently executed by the thread.</p>\n</blockquote>\n<p>So, I would conclude the answer to your question is \"yes\".</p>\n", "LastActivityDate": "2013-12-07T19:31:58.187", "Score": "9", "CreationDate": "2013-12-07T19:31:58.187", "ParentId": "20445051", "CommentCount": "0", "OwnerUserId": "390807"}, "20448305": {"Id": "20448305", "PostTypeId": "2", "Body": "<p>It is inconceivable that C++11's threading implementation will be incompatible with the platform's native threading implementation because any practical program using C++11 threads is going to call into platform libraries, and those libraries may themselves be threaded or make thread related calls (to mutexes for example).</p>\n<p>The C++11 library implementation for threads is not of course obliged to use the high level native threading library (say, pthreads or windows threads) but it probably will, for which purpose as has been mentioned there is a std::thread::native_handle() method to get the native handle.  However, even where it does not use the high level native implementation, it will have to use the same low level kernel primitives underneath.</p>\n<p>In all conceivable circumstances it should therefore be perfectly safe to use C++11 mutexes with thread instances created by native library calls, and vice versa, and mix any other native or C++ library synchronization calls.  There may indeed be cases where it is necessary to do so.  For example, the C++11 library does not at present provide thread pools or read-write locks (shared mutexes).  You might want to use native read-write locks with threads started using std::thread, or use one of the many thread pool implementations provided by third party libraries in your C++ program.</p>\n<p>The only caveat to observe is that trying to mix C++11 threads (which will in practice be obliged to use kernel threads in one way or another for the reasons mentioned above) with thread libraries which do not use kernel threads at all (for example, libraries based on green threads or \"user\" threads), is likely to lead you into trouble.</p>\n<p>Edit: In support of this I notice that \u00a730.3 of C++11 states, albeit non-normatively, that \"These threads [std::thread threads] are intended to map one-to-one with operating system threads\".</p>\n", "LastEditorUserId": "2615801", "LastActivityDate": "2013-12-08T11:46:15.513", "Score": "2", "CreationDate": "2013-12-08T00:06:51.770", "ParentId": "20445051", "CommentCount": "0", "LastEditDate": "2013-12-08T11:46:15.513", "OwnerUserId": "2615801"}, "20445051": {"ViewCount": "1428", "Body": "<p>I'm learning C++11 and have run into a threading issue.  My general question: are C++11 mutexes compatible with threads not created with C++11's standard libraries?</p>\n<p>I would like to safely share information between a thread created with C++11 and another thread created by a third-party library that I have no control over.</p>\n<p>For example, my application uses PortAudio, which creates its own thread for audio output.  I'm not sure if it's using pthreads, or OS-specific threading libraries, but I do know that PortAudio is NOT written in C++11.  I want to safely share data between a GUI thread (using a C++11 thread) and the PortAudio thread using a mutex.</p>\n<p>Similarly, can I use a C++11 mutex to synchronize QT QThreads and C++11 threads?</p>\n", "AcceptedAnswerId": "20445370", "Title": "Is a C++11 mutex compatible with threads NOT created with C++11?", "CreationDate": "2013-12-07T18:40:55.957", "Id": "20445051", "CommentCount": "19", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2016-12-25T08:21:14.937", "Score": "12", "OwnerUserId": "1940433", "Tags": "<c++><multithreading><qt><c++11><pthreads>", "AnswerCount": "4"}, "20448763": {"Id": "20448763", "PostTypeId": "2", "Body": "<p>The C++11 standard specifies that mutexes should work with any kind of 'execution agent', including different thread libraries. Here are some relevant quotes from the standard which I think answer the question conclusively:</p>\n<p><strong>Mutex requirements</strong></p>\n<blockquote>\n<p id=\"so_20445051_20448763_0\">A mutex object facilitates protection against data races and allows\n  safe synchronization of data between execution agents (30.2.5). An\n  execution agent owns a mutex from the time it successfully calls one\n  of the lock functions until it calls unlock.</p>\n</blockquote>\n<p><strong>Requirements for Lockable types</strong></p>\n<blockquote>\n<p id=\"so_20445051_20448763_1\">An execution agent is an entity such as a thread that may perform work\n  in parallel with other execution agents. [Note: Implementations or\n  users may introduce other kinds of agents such as processes or\n  thread-pool tasks. \u2014end note ] The calling agent is determined by\n  context, e.g. the calling thread that contains the call, and so on.</p>\n</blockquote>\n", "LastActivityDate": "2013-12-08T01:20:38.767", "Score": "3", "CreationDate": "2013-12-08T01:20:38.767", "ParentId": "20445051", "CommentCount": "5", "OwnerUserId": "475491"}, "bq_ids": {"n4140": {"so_20445051_20448763_1": {"length": 30, "quality": 0.8571428571428571, "section_id": 2670}, "so_20445051_20448763_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 2747}, "so_20445051_20445634_2": {"length": 21, "quality": 0.9130434782608695, "section_id": 5812}}, "n3337": {"so_20445051_20448763_1": {"length": 30, "quality": 0.8571428571428571, "section_id": 2633}, "so_20445051_20448763_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 2708}, "so_20445051_20445634_2": {"length": 21, "quality": 0.9130434782608695, "section_id": 5585}}, "n4659": {"so_20445051_20448763_1": {"length": 30, "quality": 0.8571428571428571, "section_id": 3410}, "so_20445051_20448763_0": {"length": 27, "quality": 0.9642857142857143, "section_id": 3485}, "so_20445051_20445634_2": {"length": 21, "quality": 0.9130434782608695, "section_id": 7275}}}, "20445370": {"Id": "20445370", "PostTypeId": "2", "Body": "<p>Obviously, the C++ standard doesn't make any guarantees about compatebility with other systems. Part of the reason the C and C++ standards added threading facilities was to standardize on one threading system.</p>\n<p>In practice it is expected that the C and C++ threads library is built to integrate with a platform threading system if there is one. For example, on platforms using pthreads the expectation is that pthreads are used where appropriate to buildtge standard library threading facilities (as far as I know there is no pthreads interface for the various atomic operations, i.e., the standard library may need to provide its own synchronization primitives).</p>\n<p>The standard library classes provide access to the underlying representation through the <code>native_handle()</code> methods. A standard library should implement what is returned from these and, e.g., if pthreads types are provided it seems safe to assume that this particular standard library will play nice with pthreads.</p>\n", "LastEditorUserId": "2945958", "LastActivityDate": "2016-12-25T08:21:14.937", "Score": "6", "CreationDate": "2013-12-07T19:08:01.123", "ParentId": "20445051", "CommentCount": "1", "LastEditDate": "2016-12-25T08:21:14.937", "OwnerUserId": "1120273"}});