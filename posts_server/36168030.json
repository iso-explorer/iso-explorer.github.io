post_cb({"36168069": {"ParentId": "36168030", "CommentCount": "5", "Body": "<p>Because <code>catch (A ...)</code> came first. This is a misfeature of C++. Ideally it would have given you a compilation error for <code>catch</code> blocks out of order, or at least for unreachable code. Put <code>catch (B ...)</code> first.</p>\n", "OwnerUserId": "207421", "PostTypeId": "2", "Id": "36168069", "Score": "0", "CreationDate": "2016-03-23T01:09:23.273", "LastActivityDate": "2016-03-23T01:09:23.273"}, "bq_ids": {"n4140": {"so_36168030_36168746_0": {"section_id": 3349, "quality": 0.92, "length": 23}, "so_36168030_36168746_1": {"section_id": 3348, "quality": 0.8181818181818182, "length": 9}}, "n3337": {"so_36168030_36168746_0": {"section_id": 3219, "quality": 0.92, "length": 23}, "so_36168030_36168746_1": {"section_id": 3218, "quality": 0.8181818181818182, "length": 9}}, "n4659": {"so_36168030_36168746_1": {"section_id": 4115, "quality": 1.0, "length": 11}, "so_36168030_36168746_0": {"section_id": 4116, "quality": 0.92, "length": 23}}}, "36168030": {"CommentCount": "0", "AcceptedAnswerId": "36168746", "CreationDate": "2016-03-23T01:05:16.253", "LastActivityDate": "2016-03-23T02:27:38.697", "PostTypeId": "1", "ViewCount": "76", "FavoriteCount": "1", "Title": "Why derived class exception could be caught by base class catch clause.", "Id": "36168030", "Score": "2", "Body": "<p>I've tried following code on Xcode</p>\n<pre><code>#include &lt;iostream&gt;\n\n\n/*Exceptions*/\nstruct A {\n    A( int value ) : m_value( value ) {}\n    int m_value;\n};\n\nstruct B : A {\n    B( int value ) : A( value ) {}\n};\n//+++++++++++++++++++++++++++++++\n\n/*Exceptions End*/\n\nint main(int argc, const char * argv[]) {\n\n    try {\n        try {\n            throw B( 5 );\n        }\n\n        catch ( A a ) {\n            a.m_value *= 2;\n        }\n        catch ( B b ) {\n            b.m_value -= 2;\n            throw b;\n        }\n\n    }\n    catch ( A a ) {\n        std::cout &lt;&lt; a.m_value;\n    }\n    return 0;\n}\n</code></pre>\n<p>The exception type thrown in here is B, but <code>catch( A a )</code> caught B. </p>\n<p>I have some thought about this, but don't know if it's correct. I think it's because the copy constructor of A accepts <code>const A&amp;</code> which can match B type objects, and copy constructor implicitly convert the datatype from B to A. To confirm this, I added copy constructor for <code>struct A</code> :</p>\n<pre><code>A( const A&amp; other ) : m_value( other.m_value ) {\n        std::cout &lt;&lt; \"hello\\n\";\n}\n</code></pre>\n<p>This do output hello while executing <code>catch( A a )</code>, but when I defined the copy constructor explicit, like this:</p>\n<pre><code>explicit A( const A&amp; other ) : m_value( other.m_value ) {\n        std::cout &lt;&lt; \"hello\\n\";\n}\n</code></pre>\n<p>The compiler yelled \"no matching constructor for initialization of 'A'\".</p>\n<p>I don't know why. Why didn't it just jump to <code>catch( B b )</code> ?</p>\n", "Tags": "<c++><exception>", "OwnerUserId": "1478835", "AnswerCount": "2"}, "36168746": {"ParentId": "36168030", "CommentCount": "1", "Body": "<p>This exact issue is covered in <a href=\"http://eel.is/c++draft/except.handle#4\" rel=\"nofollow\">[except.handle]/4</a>:</p>\n<blockquote>\n<p id=\"so_36168030_36168746_0\">The handlers for a try block are tried in order of appearance. That makes it possible to write handlers that\n  can never be executed, for example <strong>by placing a handler for a derived class after a handler for a corresponding\n  base class.</strong></p>\n</blockquote>\n<p>If you compiled with warnings enabled, that would also become clear:</p>\n<pre><code>main.cpp:28:9: warning: exception of type 'B' will be caught\n         catch ( B b ) {\n         ^\nmain.cpp:24:9: warning:    by earlier handler for 'A'\n         catch ( A a ) {\n         ^\n</code></pre>\n<p>So yes, what ends up happening is once <code>B</code> is thrown, we just go down the list of handlers one by one. Can we catch by <code>A</code>? Yes we can! A <code>B</code> is convertible to <code>A</code>.</p>\n<p>Now, when you make <code>A</code>'s copy constructor, something interesting happens. You can't implicitly convert a <code>B</code> to an <code>A</code>, but that's not what the exception logic handling does. It simply checks the types. According to <a href=\"http://eel.is/c++draft/except.handle#3\" rel=\"nofollow\">[except.handle]/3</a>:</p>\n<blockquote>\n<p id=\"so_36168030_36168746_1\">A <em>handler</em> is a match for an exception object of type <code>E</code> if<br>\n  \u2014 [...]<br>\n  \u2014 the handler is of type <em>cv</em> <code>T</code> or <em>cv</em> <code>T&amp;</code> and <code>T</code> is an unambiguous public base class of <code>E</code>, or<br>\n  \u2014 [...]  </br></br></br></p>\n</blockquote>\n<p>In our case, <code>A</code> is an unambiguous public base class of <code>B</code> and the handler is of type <code>A</code>, so the handler matches. Full stop. Now, turns out we can't actually <em>use</em> the handler, so the code is ill-formed. </p>\n", "OwnerUserId": "2069064", "PostTypeId": "2", "Id": "36168746", "Score": "2", "CreationDate": "2016-03-23T02:27:38.697", "LastActivityDate": "2016-03-23T02:27:38.697"}});