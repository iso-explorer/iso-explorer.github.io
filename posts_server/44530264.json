post_cb({"44530264": {"CommentCount": "6", "ViewCount": "437", "PostTypeId": "1", "LastEditorUserId": "8156261", "CreationDate": "2017-06-13T19:47:12.267", "LastActivityDate": "2017-07-12T09:40:59.617", "Title": "Safety of std::unordered_map::merge()", "FavoriteCount": "1", "LastEditDate": "2017-06-14T00:27:54.100", "Id": "44530264", "Score": "27", "Body": "<p>While writing some code targeting C++17, I kind of hit a stumbling block determining the exception-safety of an operation merging two compatible std::unordered_maps. Per the current <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf\" rel=\"noreferrer\">working draft</a>, \u00a726.2.7, table 91 reads, in part, regarding the conditions of <code>a.merge( a2 )</code>:</p>\n<blockquote>\n<p id=\"so_44530264_44530264_0\"><em>Requires:</em> <code>a.get_allocator() == a2.get_allocator()</code>.</p>\n<p id=\"so_44530264_44530264_1\">Attempts to extract each element in <code>a2</code> and insert it into <code>a</code> using the hash function and key equality predicate of <code>a</code>. In containers with unique keys, if there is an element in <code>a</code> with key equivalent to the key of an element from <code>a2</code>, then that element is not extracted from <code>a2</code>.</p>\n<p id=\"so_44530264_44530264_2\"><em>Postconditions:</em> Pointers and references to the transferred elements of <code>a2</code> refer to those same elements but as members of <code>a</code>. Iterators referring to the transferred elements and all iterators referring to <code>a</code> will be invalidated, but iterators to elements remaining in <code>a2</code> will remain valid.</p>\n<p id=\"so_44530264_44530264_3\"><em>Throws:</em> Nothing unless the hash function or key equality predicate throws.</p>\n</blockquote>\n<p>It's worth noting that these conditions are strongly reminiscent of those given for the requirements of ordinary associative containers (std::map), given in \u00a726.2.6, table 90, <code>a.merge( a2 )</code>:</p>\n<blockquote>\n<p id=\"so_44530264_44530264_4\"><em>Requires:</em> <code>a.get_allocator() == a2.get_allocator()</code>.</p>\n<p id=\"so_44530264_44530264_5\">Attempts to extract each element in <code>a2</code> and insert it into <code>a</code> using the comparison object of <code>a</code>. In containers with unique keys, if there is an element in <code>a</code> with key equivalent to the key of an element from <code>a2</code>, then that element is not extracted from <code>a2</code>.</p>\n<p id=\"so_44530264_44530264_6\"><em>Postconditions:</em> Pointers and references to the transferred elements of <code>a2</code> refer to those same elements but as members of <code>a</code>. Iterators referring to the transferred elements will continue to refer to their elements, but they now behave as iterators into <code>a</code>, not into <code>a2</code>.</p>\n<p id=\"so_44530264_44530264_7\"><em>Throws:</em> Nothing unless the comparison object throws.</p>\n</blockquote>\n<p>I needed to merge two std::unordered_maps with the same number of elements which I could ensure would be unique across both containers, meaning that the map containing the merged result would have double the number of elements it previously had, and the container merged-from would be empty. This should be perfectly safe thanks to C++17, right? </p>\n<p>This is a huge win in terms of performance\u2026 except, I had this nagging doubt. Hilariously, the postcondition statement says nothing about whether or not the previous max load factor in the merged map would be honored, and while that seems like a safe implicit assumption, it seemed to na\u00efvely conflict with the statement about the unordered_map's exception-safety. If you're using a hash table design wherein the buckets are contiguously allocated buffers, maintaining your load factor would seem to imply rehashing, which would seem to imply reallocation of the bucket buffer. </p>\n<p>Already, this seemed like an exercise in extreme navel-gazing and there was good cause to leave well enough alone: a more complicated hash table could conceivably be made as a completely node-based structure, similar to the red-black trees usually underpinning std::map, and in such a case, the spec seemed reasonable as a rehash wouldn't imply allocation.</p>\n<p>Perhaps to my benefit, I succumbed to doubt and dug into gcc-7.1's implementation of merge. It's incredibly complicated, but to summarize my findings, I found that the buckets are, indeed, contiguously allocated buffers, and rehashing does imply reallocation. Maybe, I thought, there was some deeper magic I was missing (I stared at the source for nearly an entire day and still felt I had a poor understanding of it) which just disabled rehashing during a merge, meaning that all of the specified conditions would be upheld, but you could get a nasty performance regression after a suitably large merge, since your map would likely be overloaded. </p>\n<p>I moved for a practical assessment mirroring my use-case (which I would have presented if it were possible, I'm sorry), instead of just questioning my interpretation of libstdc++:</p>\n<pre><code>#include &lt;memory&gt;        // for std::shared_ptr&lt;&gt;\n#include &lt;new&gt;           // for std::bad_alloc\n#include &lt;utility&gt;       // for std::move(), std::pair&lt;&gt;\n#include &lt;type_traits&gt;   // for std::true_type\n#include &lt;unordered_map&gt; // for std::unordered_map&lt;&gt;\n#include &lt;functional&gt;    // for std::hash&lt;&gt;, std::equal_to&lt;&gt;\n#include &lt;string&gt;        // for std::string\n#include &lt;iostream&gt;      // for std::cout\n#include &lt;cstddef&gt;       // for std::size_t\n\ntemplate&lt;typename T&gt;\nclass PrimedFailureAlloc\n{\npublic:\n  using value_type = T;\n  using propagate_on_container_copy_assignment = std::true_type;\n  using propagate_on_container_move_assignment = std::true_type;\n  using propagate_on_container_swap = std::true_type;\n\n  PrimedFailureAlloc() = default;\n\n  template&lt;typename U&gt;\n  PrimedFailureAlloc( const PrimedFailureAlloc&lt;U&gt;&amp; source ) noexcept\n    : m_triggered{ source.m_triggered }\n  { }\n\n  template&lt;typename U&gt;\n  PrimedFailureAlloc( PrimedFailureAlloc&lt;U&gt;&amp;&amp; source ) noexcept\n    : m_triggered{ std::move( source.m_triggered ) }\n  { }\n\n  T* allocate( std::size_t n )\n  {\n    if ( *m_triggered ) throw std::bad_alloc{};\n    return static_cast&lt;T*&gt;( ::operator new( sizeof( T ) * n ) );\n  }\n\n  void deallocate( T* ptr, std::size_t n ) noexcept\n  {\n    ::operator delete( ptr );\n  }\n\n  bool operator==( const PrimedFailureAlloc&amp; rhs ) noexcept\n  {\n    return m_triggered == rhs.m_triggered;\n  }\n\n  void trigger() noexcept { *m_triggered = true; }\n\nprivate:\n  template&lt;typename U&gt;\n  friend class PrimedFailureAlloc;\n\n  std::shared_ptr&lt;bool&gt; m_triggered{ new bool{ false } };\n};\n\ntemplate&lt;typename T&gt;\nbool operator!=( const PrimedFailureAlloc&lt;T&gt;&amp; lhs,\n                 const PrimedFailureAlloc&lt;T&gt;&amp; rhs ) noexcept\n{\n  return !(lhs == rhs);\n}\n\ntemplate&lt; typename Key\n        , typename T\n        , typename Hash = std::hash&lt;Key&gt;\n        , typename KeyEqual = std::equal_to&lt;Key&gt;\n        &gt;\nusing FailingMap = std::unordered_map&lt;\n  Key,\n  T,\n  Hash,\n  KeyEqual,\n  PrimedFailureAlloc&lt;std::pair&lt;const Key, T&gt;&gt;\n&gt;;\n\ntemplate&lt;typename Key, typename T&gt;\nvoid printMap( const FailingMap&lt;Key, T&gt;&amp; map )\n{\n  std::cout &lt;&lt; \"{\\n\";\n  for ( const auto&amp; [str, index] : map )\n    std::cout &lt;&lt; \"  { \" &lt;&lt; str &lt;&lt; \", \" &lt;&lt; index &lt;&lt; \" }\\n\";\n  std::cout &lt;&lt; \"}\\n\";\n}\n\nint main()\n{\n  PrimedFailureAlloc&lt;std::pair&lt;const std::string, int&gt;&gt; a;\n  FailingMap&lt;std::string, int&gt; m1{ a };\n  FailingMap&lt;std::string, int&gt; m2{ a };\n\n  m1.insert( { { \"Purple\", 0 }, { \"Green\", 3 }, { \"Indigo\", 16 } } );\n  m2.insert( { { \"Blue\", 12 }, { \"Red\", 2 }, { \"Violet\", 5 } } );\n\n  // m1.reserve( m1.size() + m2.size() );\n  a.trigger();\n  m1.merge( m2 );\n\n  std::cout &lt;&lt; \"map :=\\n\";\n  printMap( m1 );\n\n  return 0;\n}\n</code></pre>\n<p>Sure enough, after compiling this code under GCC-7.1, I get:</p>\n<pre><code>terminate called after throwing an instance of 'std::bad_alloc'\n  what():  std::bad_alloc\n[1]    10944 abort      ./a.out\n</code></pre>\n<p>Whereas, uncommenting line 95 (<code>m1.reserve( m1.size() + m2.size() );</code>), results in the expected output:</p>\n<pre><code>map :=\n{\n  { Red, 2 }\n  { Violet, 5 }\n  { Purple, 0 }\n  { Green, 3 }\n  { Blue, 12 }\n  { Indigo, 16 }\n}\n</code></pre>\n<p>Understanding that C++17 is still a draft standard which hasn't yet been finalized, and that gcc's implementation is experimental, I suppose my question would be:</p>\n<ol>\n<li>Have I gravely misconstrued the safety of the merge operation as set out in the standard? Are there best-practices to using <code>std::unordered_map::merge()</code> that I've missed? Was I supposed to be implicitly responsible for ensuring the allocation of buckets? Will using <code>std::unordered_map::reserve()</code> actually be portable when clang, MSVC, and Intel finally support C++17? I mean, my program aborting when an exception-free merge was impossible does, after some notion, adhere to the listed postconditions\u2026</li>\n<li>Is this actually a defect in the standard? The similarity of the wording between unordered associative containers and ordinary associative containers might have allowed unintended guarantees to slip in if the text were, say, copy-pasted.</li>\n<li>Is this just a gcc bug?</li>\n</ol>\n<p>It's worth noting that I did check gcc's bug tracker prior to this write-up and seemed to find no open bugs matching my description, and furthermore, I checked the C++ standard defect report and similarly seemed to have come up empty (admittedly, doing a text-search of that site is aggravating and I may have been less than thorough). The latter is unsurprising, since standard defects and their workarounds or consequences are usually noted in gcc's source code and I found no such notations during my examination. I tried compiling my example code in my most recent checkout of clang (over a week old), but the compiler segfaulted so I took my examination there no further, and have not consulted libc++.</p>\n", "Tags": "<c++><c++1z><exception-safety><gcc7>", "OwnerUserId": "8156261", "AnswerCount": "2"}, "45053984": {"ParentId": "44530264", "CommentCount": "0", "Body": "<p>This is just a defect in the standard, i.e., your possibility 2.</p>\n<p>LWG has just moved <a href=\"https://timsong-cpp.github.io/lwg-issues/2977\" rel=\"nofollow noreferrer\">LWG issue 2977</a> to \"Ready\" status, which will strike the erroneous <em>Throws</em> clause.</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "45053984", "Score": "1", "CreationDate": "2017-07-12T09:37:42.590", "LastActivityDate": "2017-07-12T09:37:42.590"}, "45053735": {"ParentId": "44530264", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>In order to understand whether the wording in standard is right or not you need to look into underlying functions.<br>\nMerge itself consist of two operations.</br></p>\n<ul>\n<li>setting pointers to added elements. As they are already allocated, there is no allocation involved in here</li>\n<li>in case the bounds for number of elements in bucket are reached, rehash() is called. </li>\n</ul>\n<p>Calling rehash() is point, where you expect exception to be thrown. Sol let's look into its exception safety.</p>\n<blockquote>\n<p id=\"so_44530264_45053735_0\">23.2.5.1 Exception safety guarantees [unord.req.except]<br>\n  1 For unordered associative containers, no clear() function throws an exception. erase(k) does not throw an\n  exception unless that exception is thrown by the container\u2019s Hash or Pred object (if any).<br>\n  2 For unordered associative containers, if an exception is thrown by any operation other than the container\u2019s\n  hash function from within an insert or emplace function inserting a single element, the insertion has no\n  effect.<br>\n  3 For unordered associative containers, no swap function throws an exception unless that exception is thrown\n  by the swap of the container\u2019s Hash or Pred object (if any).<br>\n  4 <strong>For unordered associative containers, if an exception is thrown from within a rehash() function other than\n  by the container\u2019s hash function or comparison function, the rehash() function has no effect.</strong></br></br></br></br></p>\n</blockquote>\n<p>As you can see for rehash() function is defined that it does nothing if exception is thrown inside other than for hash or comparison function. That is, in my view, perfectly in line with definition for merge:</p>\n<blockquote>\n<p id=\"so_44530264_45053735_1\">Throws: Nothing unless the hash function or key equality predicate throws.</p>\n</blockquote>\n<p>My understanding is that when there is no room to increase underlying data structure for bucket list, then it is kept in its original form. This might lead to slightly inefficient access to elements as there might be more elements in individual buckets than defined. Same can happen during insert.</p>\n<p>Where is the problem in your case? Possibly in implementation of rehash() function that throws where it shouldn't.</p>\n<p>DISCLAIMER: I am not an expert on the topic. It is just what I have found. So feel free to correct me if I am wrong.</p>\n", "OwnerUserId": "8113019", "LastEditorUserId": "8113019", "LastEditDate": "2017-07-12T09:40:59.617", "Id": "45053735", "Score": "-1", "CreationDate": "2017-07-12T09:27:41.220", "LastActivityDate": "2017-07-12T09:40:59.617"}, "bq_ids": {"n4140": {"so_44530264_44530264_1": {"section_id": 763, "quality": 0.625, "length": 15}, "so_44530264_44530264_5": {"section_id": 744, "quality": 0.6190476190476191, "length": 13}, "so_44530264_44530264_3": {"section_id": 763, "quality": 0.625, "length": 5}, "so_44530264_45053735_1": {"section_id": 763, "quality": 0.625, "length": 5}, "so_44530264_44530264_2": {"section_id": 874, "quality": 0.5185185185185185, "length": 14}, "so_44530264_44530264_6": {"section_id": 874, "quality": 0.8888888888888888, "length": 24}}, "n3337": {"so_44530264_44530264_1": {"section_id": 750, "quality": 0.625, "length": 15}, "so_44530264_44530264_5": {"section_id": 733, "quality": 0.5714285714285714, "length": 12}, "so_44530264_44530264_3": {"section_id": 750, "quality": 0.625, "length": 5}, "so_44530264_45053735_1": {"section_id": 750, "quality": 0.625, "length": 5}, "so_44530264_44530264_2": {"section_id": 863, "quality": 0.5185185185185185, "length": 14}, "so_44530264_44530264_6": {"section_id": 863, "quality": 0.8888888888888888, "length": 24}}, "n4659": {"so_44530264_44530264_1": {"section_id": 823, "quality": 1.0, "length": 24}, "so_44530264_44530264_5": {"section_id": 802, "quality": 1.0, "length": 21}, "so_44530264_44530264_7": {"section_id": 802, "quality": 0.8, "length": 4}, "so_44530264_44530264_3": {"section_id": 823, "quality": 0.875, "length": 7}, "so_44530264_45053735_1": {"section_id": 823, "quality": 0.875, "length": 7}, "so_44530264_44530264_2": {"section_id": 823, "quality": 0.9629629629629629, "length": 26}, "so_44530264_44530264_6": {"section_id": 802, "quality": 0.9629629629629629, "length": 26}}}});