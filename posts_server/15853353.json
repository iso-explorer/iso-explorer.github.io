post_cb({"15853437": {"ParentId": "15853353", "LastEditDate": "2013-04-06T19:12:56.487", "CommentCount": "0", "CreationDate": "2013-04-06T16:46:09.180", "OwnerUserId": "140740", "LastEditorUserId": "140740", "PostTypeId": "2", "Id": "15853437", "Score": "6", "Body": "<h3>No</h3>\n<p>That won't be portable because you are passing a parameter that will be a different size in the common LP64 paradigm.</p>\n<p>Also, you aren't dereferencing the function pointer with the correct type, and the results of <em>that</em> are undefined.</p>\n<p>Now, as you seem to have concluded, the function pointer will work as expected and the only practical problem is going to be: <em>how will write(2) interpret the <code>intptr_t</code> first parameter?</em></p>\n<p>And the actual run-time problem is that, on LP64, you are passing a 64-bit value to a 32-bit parameter. This might misalign the subsequent parameters.  On a system with register parameters it would probably work just fine.</p>\n", "LastActivityDate": "2013-04-06T19:12:56.487"}, "15853353": {"CommentCount": "10", "CreationDate": "2013-04-06T16:38:26.553", "PostTypeId": "1", "AcceptedAnswerId": "15853437", "LastEditorUserId": "578749", "LastActivityDate": "2013-04-06T19:12:56.487", "LastEditDate": "2013-04-06T16:47:44.323", "ViewCount": "452", "FavoriteCount": "0", "Title": "Is it safe to pass an intptr_t to a function that expects an int?", "Id": "15853353", "Score": "6", "Body": "<p>More specifically, if I have the following function pointer type:</p>\n<pre><code>typedef void (*callback_type) (intptr_t context, void* buffer, size_t count);\n</code></pre>\n<p>can I safely and without \"undefined behavior\" do:</p>\n<pre><code>callback_type func_ptr = (callback_type)write;\nintptr_t context = fd;\n\nfunc_ptr(context, some_buffer, buffer_size);\n</code></pre>\n<p>?</p>\n<p>Where <code>write()</code> is the system call (EDIT: has the signature <code>ssize_t write(int fd, const void *buf, size_t count);</code>, thus takes an <code>int</code> as the first argument), and <code>fd</code> is an <code>int</code> file descriptor. I assume the answer would be the same for C and C++, so I am tagging both.</p>\n", "Tags": "<c++><c><callback><function-pointers>", "OwnerUserId": "578749", "AnswerCount": "3"}, "15853406": {"ParentId": "15853353", "CommentCount": "5", "CreationDate": "2013-04-06T16:42:46.240", "Id": "15853406", "PostTypeId": "2", "OwnerDisplayName": "user529758", "Score": "1", "Body": "<p>The problem is not with passing the argument back and forth between functions, since automatic promotion from one integral type to another is done.</p>\n<p>The problem is, what if <code>intptr_t</code> is shorter than <code>int</code>, thus not every value of <code>int</code> can be represented by an <code>intptr_t</code>? In such a case, the some of the highest bits in the <code>int</code> will be truncated when converting to <code>intptr_t</code>, so you'll end up <code>write()</code>ing to an invalid file descriptor. Although that should not invoke undefined behavior, it's still erroneous.</p>\n", "LastActivityDate": "2013-04-06T16:42:46.240"}, "15853557": {"ParentId": "15853353", "CommentCount": "0", "Body": "<p>Let's have a look at C standard.</p>\n<blockquote>\n<h3>C11 (n1570), \u00a7 6.3.2.3 Pointers</h3>\n<p id=\"so_15853353_15853557_0\">A pointer to a function of one type may be converted to a pointer to a\n  function of another type and back again; the result shall compare\n  equal to the original pointer. If a converted pointer is used to call\n  a function whose type is not compatible with the referenced type, the\n  behavior is undefined.</p>\n<h3>C11 (n1570), \u00a7 6.7.6.3 Function declarators (including prototypes)</h3>\n<p id=\"so_15853353_15853557_1\">For two function types to be compatible, both shall specify compatible\n  return types. Moreover, the parameter type lists, if both are present,\n  shall agree in the number of parameters and in use of the ellipsis\n  terminator; corresponding parameters shall have compatible types.</p>\n<h3>C11 (n1570), \u00a7 6.2.7 Compatible type and composite type</h3>\n<p id=\"so_15853353_15853557_2\">Two types have compatible type if their types are the same.</p>\n</blockquote>\n<p>Conclusion: </p>\n<pre><code>void (*) (intptr_t context, void* buffer, size_t count);\n</code></pre>\n<p>cannot be converted to:</p>\n<pre><code>void (*) (int context, void* buffer, size_t count);\n</code></pre>\n", "OwnerUserId": "1126268", "PostTypeId": "2", "Id": "15853557", "Score": "2", "CreationDate": "2013-04-06T16:57:14.100", "LastActivityDate": "2013-04-06T16:57:14.100"}, "bq_ids": {"n4140": {"so_15853353_15853557_2": {"section_id": 45, "quality": 0.625, "length": 5}}, "n3337": {"so_15853353_15853557_2": {"section_id": 42, "quality": 0.625, "length": 5}}, "n4659": {"so_15853353_15853557_2": {"section_id": 46, "quality": 0.625, "length": 5}}}});