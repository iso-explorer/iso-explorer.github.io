post_cb({"bq_ids": {"n4140": {"so_48294314_48294653_3": {"length": 48, "quality": 0.96, "section_id": 520}, "so_48294314_48294653_1": {"length": 7, "quality": 1.0, "section_id": 501}}, "n3337": {"so_48294314_48294653_3": {"length": 48, "quality": 0.96, "section_id": 511}, "so_48294314_48294653_1": {"length": 7, "quality": 1.0, "section_id": 492}}, "n4659": {"so_48294314_48294653_3": {"length": 46, "quality": 0.92, "section_id": 541}, "so_48294314_48294653_1": {"length": 7, "quality": 1.0, "section_id": 522}}}, "48294802": {"Id": "48294802", "PostTypeId": "2", "Body": "<p>In the older days of C++ before safer smart pointers <code>std::shared_ptr&lt;T&gt;</code> &amp; <code>std::unique_ptr&lt;T&gt;</code> came around when using <code>new &amp; delete</code> &amp; <code>new [] &amp; delete []</code> these are some older macros that I once used in C++ for helping to manage memory.</p>\n<pre><code>#ifndef SAFE_DELETE\n    #define SAFE_DELETE(p)  { if(p) { delete (p); (p) = nullptr; } }\n#endif\n\n#ifndef SAFE_DELETE_ARRAY\n    #define SAFE_DELETE_ARRAY(p)    { if(p) { delete [] (p); (p) = nullptr; } }\n#endif \n</code></pre>\n<p>Similar to what you are trying to achieve: the design of these types of macros typically look to see if the <code>tag - identifier</code> is not yet defined. If it isn't then you define the name along with its parameter and functionality, then you end the if definition. Also as a side note when working with macros it may seem like over doing it but it is always advisable to enclose each parameter name in parenthesis. So in your case you would want something like:</p>\n<pre><code>#ifndef SWAP\n    #define SWAP(a, b)  if ( (a) != (b) ) { \\\n                            ((a) ^= (b));   \\\n                            ((b) ^= (a));   \\\n                            ((a) ^= (b));   \\\n                        } else {            \\ \n                            ((a) = (a));    \\\n                            ((b) = (b));    \\\n                        }                   \n#endif\n</code></pre>\n<p>Now the above macro is simplistic and it doesn't prevent from invalid types such as pointers, expressions, references etc., but it should work with any built in default basic types. </p>\n", "LastEditorUserId": "1757805", "LastActivityDate": "2018-01-17T06:39:56.283", "Score": "0", "CreationDate": "2018-01-17T06:24:59.610", "ParentId": "48294314", "CommentCount": "0", "OwnerUserId": "1757805", "LastEditDate": "2018-01-17T06:39:56.283"}, "48294828": {"Id": "48294828", "PostTypeId": "2", "Body": "<p>To briefly answer your question, it is as the other answers have already stated. The <code>#ifdef</code>/<code>#ifndef</code> conditional only cares about the macro identifier, so the arguments are not part of its syntax.</p>\n<p>However, your macro has a couple of weaknesses that should be addressed. First, note that using the XOR-operator for swapping, although a commonly taught trick to avoid using a temporary, fails if the two arguments are the same object. This is because the result of the first XOR would be 0, and the remaining XOR steps cannot recover the original value. Second, this version of the macro fails for pointer types, because XOR wants integral types. Third, the macro invokes the arguments multiple times, which will cause problems if the argument is an expression with side effects. Fourth, compound statements in a macro should be guarded by <code>do</code> .. <code>while (0)</code> to allow the macro to expand into a statement. This makes the macro syntactically cleaner, so that a semi-colon after it is not spurious.</p>\n<p>As explained in a separate answer, in C++, use <code>std::swap</code> instead of defining your own. Unfortunately, C does not provide a generic swapping utility function. However, it is not difficult to author a generic function:</p>\n<pre><code>static inline void swap_generic (void *a, void *b, void *t, size_t sz) {\n    if (a != b) {\n        memcpy(t, a, sz);\n        memcpy(a, b, sz);\n        memcpy(b, t, sz);\n    }\n}\n</code></pre>\n<p>Your macro could then invoke this function.</p>\n<pre><code>#ifndef SWAP\n# ifdef __cplusplus\n#  define SWAP(a, b) std::swap(a, b)\n# else\n#  define SWAP_ASSERT(X) _Static_assert(X, #X)\n#  if  __STDC_VERSION__ &lt; 201112L\n#   undef SWAP_ASSERT\n#   define SWAP_ASSERT(X) struct dummy\n#  endif\n#  define SWAP(a, b) do {                                \\\n       SWAP_ASSERT(sizeof(a) == sizeof(b));              \\\n       char t[sizeof(a) != sizeof(b) ? -1 : sizeof(a)];  \\\n       swap_generic(&amp;(a), &amp;(b), t, sizeof(a));           \\\n   } while (0)\n# endif\n#endif\n</code></pre>\n<p>Note how we use <code>std::swap</code> if C++ is detected.</p>\n<p>If you use a C compiler that supports the <code>typeof</code> extension, then the macro can be simplified greatly, since you do not need a generic swapping function.</p>\n<pre><code>#ifndef SWAP\n# ifdef __cplusplus\n#  define SWAP(a, b) std::swap(a, b)\n# else\n#  define SWAP(a, b) do {                      \\\n       typeof(a) *p = &amp;(a), *q = &amp;(b), t = *p; \\\n       *p = *q;                                \\\n       *q = t;                                 \\\n   } while (0)\n# endif\n#endif\n</code></pre>\n<p>Note that the <code>typeof</code> version promotes better type safety.</p>\n", "LastEditorUserId": "315052", "LastActivityDate": "2018-01-18T19:20:57.430", "Score": "2", "CreationDate": "2018-01-17T06:27:00.937", "ParentId": "48294314", "CommentCount": "17", "OwnerUserId": "315052", "LastEditDate": "2018-01-18T19:20:57.430"}, "48294314": {"ViewCount": "296", "Body": "<p>I have a simple code in header.h-</p>\n<pre><code>#define SWAP(a, b)  {a ^= b; b ^= a; a ^= b;} \n</code></pre>\n<p>This header.h is included in a code.c file, but my requirement is-\nI want SWAP to be checked first like-</p>\n<pre><code>#ifndef SWAP(a, b)\n#define SWAP(a, b)  {a ^= b; b ^= a; a ^= b;}\n#endif\n</code></pre>\n<p>Is this correct or I don't have to provide the argument to the first line?</p>\n", "Title": "How to use #ifndef with macro argument?", "CreationDate": "2018-01-17T05:44:28.447", "LastActivityDate": "2018-01-18T19:20:57.430", "CommentCount": "9", "PostTypeId": "1", "Id": "48294314", "Score": "2", "OwnerUserId": "5575697", "Tags": "<c++><c><c++11><macros>", "AnswerCount": "6"}, "48294486": {"Id": "48294486", "PostTypeId": "2", "Body": "<pre><code>#ifndef SWAP\n#define SWAP(a, b)  {a ^= b; b ^= a; a ^= b;}\n#endif\n</code></pre>\n<p>above change will work for c,c++11. probably it will work for all the versions of c++XX.</p>\n", "LastActivityDate": "2018-01-17T05:59:36.810", "Score": "0", "CreationDate": "2018-01-17T05:59:36.810", "ParentId": "48294314", "CommentCount": "1", "OwnerUserId": "7373699"}, "48294341": {"Id": "48294341", "PostTypeId": "2", "Body": "<p>It is incorrect.</p>\n<p>The correct usage of <code>#ifndef</code> is:</p>\n<pre><code>#ifndef SWAP\n#define SWAP(a, b)  {a ^= b; b ^= a; a ^= b;}\n#endif\n</code></pre>\n<p>From  <a href=\"http://en.cppreference.com/w/cpp/preprocessor/conditional\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/preprocessor/conditional</a>:</p>\n<blockquote>\n<p id=\"so_48294314_48294341_0\"><code>#ifndef</code> <em><code>identifier</code></em></p>\n</blockquote>\n", "LastActivityDate": "2018-01-17T05:47:38.287", "Score": "2", "CreationDate": "2018-01-17T05:47:38.287", "ParentId": "48294314", "CommentCount": "0", "OwnerUserId": "434551"}, "48294653": {"Id": "48294653", "PostTypeId": "2", "Body": "<p>Before asking the question you could have looked into the standard to get an idea of how it is used.</p>\n<p>From standard - <a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.10.1p5\" rel=\"nofollow noreferrer\"><strong>\u00a76.10.1p5</strong></a></p>\n<blockquote>\n<p id=\"so_48294314_48294653_0\">Preprocessing directives of the forms</p>\n<pre><code># ifdef identifier new-line groupopt\n# ifndef identifier new-line groupopt\n</code></pre>\n<p id=\"so_48294314_48294653_1\">check whether <em>the identifier is or is not currently defined as a\n  <strong>macro name</strong></em></p></blockquote>. Their conditions are equivalent to #if defined identifier and #if !defined identifier respectively.\n\n<p>Then again if you are not sure what is the macro name and what are the parameters etc..</p>\n<p>From standard <a href=\"http://port70.net/~nsz/c/c11/n1570.html#6.10.3p10\" rel=\"nofollow noreferrer\"><strong>\u00a76.10.3.p10</strong></a></p>\n<blockquote>\n<p id=\"so_48294314_48294653_2\">A preprocessing directive of the form</p>\n<pre><code># define identifier lparen identifier-listopt ) replacement-list new-line\n# define identifier lparen ... ) replacement-list new-line\n# define identifier lparen identifier-list , ... ) replacement-list new-line\n</code></pre>\n<p id=\"so_48294314_48294653_3\">defines a <em>function-like macro with parameters</em>, whose use is similar\n  syntactically to a function call. The parameters are specified by the\n  optional list of identifiers, whose scope extends from their\n  declaration in the identifier list until the new-line character that\n  terminates the #define preprocessing directive. <em>Each subsequent\n  instance of the function-like macro name followed by a <code>(</code> as the next\n  preprocessing token introduces the sequence of preprocessing tokens\n  that is replaced by the replacement list in the definition (an\n  invocation of the macro).</em>...</p>\n</blockquote>\n<p>The last section just will let you know enough what should be written in the <code>ifndef</code> in place of identifier. It is clear from the highlighted parts.</p>\n<p>In <code>C</code> you have to a considerable amount of work to write a generic and correct swap macro. For two same value your <code>swap</code> will not work as you expect it to. </p>\n", "LastEditorUserId": "3796113", "LastActivityDate": "2018-01-17T06:20:19.893", "Score": "3", "CreationDate": "2018-01-17T06:12:46.973", "ParentId": "48294314", "CommentCount": "0", "OwnerUserId": "3796113", "LastEditDate": "2018-01-17T06:20:19.893"}, "48294342": {"Id": "48294342", "PostTypeId": "2", "Body": "<p>You want to code</p>\n<pre><code>#ifndef SWAP\n#define SWAP(a, b)  {a ^= b; b ^= a; a ^= b;}\n#endif\n</code></pre>\n<p>The <a href=\"http://en.cppreference.com/w/cpp/preprocessor/conditional\" rel=\"noreferrer\"><code>#ifndef</code></a> is just looking into the preprocessor's symbol table (for the presence or absence of some given preprocessor symbol). It does not care about the arguments of your <code>SWAP</code> macro.</p>\n<p>Of course in genuine C++11 you should prefer the standard <a href=\"http://en.cppreference.com/w/cpp/algorithm/swap\" rel=\"noreferrer\"><code>std::swap</code></a> function. It is typesafe, more readable, and safer (think about <code>SWAP(t[i++],i)</code> as a misbehaving example).</p>\n", "LastActivityDate": "2018-01-17T05:47:49.623", "Score": "5", "CreationDate": "2018-01-17T05:47:49.623", "ParentId": "48294314", "CommentCount": "2", "OwnerUserId": "841108"}});