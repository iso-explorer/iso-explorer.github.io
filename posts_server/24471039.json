post_cb({"24471606": {"ParentId": "24471039", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2014-06-28T22:47:02.007", "Score": "2", "LastEditorUserId": "420683", "LastEditDate": "2014-06-28T22:52:33.003", "Id": "24471606", "OwnerUserId": "12711", "Body": "<p>For your example code, if you're looking for something that \"any compiler conforming to the c++ standard always produce the same output\", the answer is that there's no such guarantee.</p>\n<p>A couple easy examples: alignment issues (as mentioned in several comments) and endianness differences.</p>\n<p>C++11 5.2.10/7  \"Reinterpret cast\" says:</p>\n<blockquote>\n<p id=\"so_24471039_24471606_0\">An object pointer can be explicitly converted to an object pointer of\n  a different type. When a prvalue <code>v</code> of type \u201cpointer to <code>T1</code>\u201d is\n  converted to the type \u201cpointer to <em>cv</em> <code>T2</code>\u201d, the result is\n  <code>static_cast&lt;cv T2*&gt;(static_cast&lt;cv void*&gt;(v))</code> if both <code>T1</code> and <code>T2</code> are standard-layout\n  types (3.9) and the alignment requirements of <code>T2</code> are no stricter than\n  those of <code>T1</code>, or if either type is <code>void</code>. Converting a prvalue of type\n  \u201cpointer to <code>T1</code>\u201d to the type \u201cpointer to <code>T2</code>\u201d (where <code>T1</code> and <code>T2</code> are\n  object types and where the alignment requirements of <code>T2</code> are no\n  stricter than those of <code>T1</code>) and back to its original type yields the\n  original pointer value. The result of any other such pointer\n  conversion is unspecified.</p>\n</blockquote>\n<p>Since <code>uint32_t</code> will generally have a stricter alignment requirement than <code>char[]</code>, the standard doesn't make any promises about the behavior (since the above only talks about the situation where the alignment requirements are met). So strictly speaking the behavior is undefined.</p>\n<p>Now, lets assume that you're interested only in platforms where the alignment requirements are met (ie., <code>uint32_t</code> can be aligned on any address, same as <code>char</code>). Then your expression involving the reinterpret cast is equivalent to (note that you'd have to cast away the <code>const</code> from the <code>const char*</code> returned from <code>std::string::data()</code> as well):</p>\n<pre><code>std::uint32_t nb = *(static_cast&lt;std::uint32_t*&gt;(static_cast&lt;void*&gt;(const_cast&lt;char*&gt;(s.data()))));\n</code></pre>\n<p>The standard says this about using <code>static_cast</code> with object pointers (other than conversion between pointers in a class heirarchy) in 5.2.9/13 \"Static cast\":</p>\n<blockquote>\n<p id=\"so_24471039_24471606_1\">A prvalue of type \u201cpointer to <em>cv1</em> <code>void</code>\u201d can be converted to a prvalue\n  of type \u201cpointer to <em>cv2</em> <code>T</code>,\u201d where <code>T</code> is an object type and <em>cv2</em> is the\n  same cv-qualification as, or greater cv-qualification than, <em>cv1</em>. The\n  null pointer value is converted to the null pointer value of the\n  destination type. A value of type pointer to object converted to\n  \u201cpointer to <em>cv</em> <code>void</code>\u201d and back, possibly with different\n  cv-qualification, shall have its original value.</p>\n</blockquote>\n<p>So, as far as the standard is concerned, all that you can do with the resulting pointer is cast it back to get the original value. Anything else would be undefined behavior (that an implementation might give a better guarantee on).</p>\n<p>3.10/10 \"Lvalues and rvalues\" allows an object to be accessed through <code>char</code> or <code>unsigned char</code> types as well.</p>\n<p>However, to reiterate: the standard does not guarantee that \"any compiler conforming to the c++ standard always produce the same output\" for the example you posted.</p>\n", "LastActivityDate": "2014-06-28T22:52:33.003"}, "24471039": {"CommentCount": "16", "ViewCount": "217", "PostTypeId": "1", "LastEditorUserId": "3612977", "CreationDate": "2014-06-28T21:18:16.647", "LastActivityDate": "2014-06-28T23:46:41.273", "Title": "guarantee of reinterpret_cast output for serialization purpose", "AcceptedAnswerId": "24471606", "LastEditDate": "2014-06-28T22:04:18.830", "Id": "24471039", "Score": "0", "Body": "<pre><code>int main()\n{\n    char buffer[5] = { 0 };\n    buffer[0] = 23;\n\n    std::string s(&amp;buffer[0], 4);\n    std::uint32_t nb = *reinterpret_cast&lt;const std::uint32_t*&gt;(s.data());\n\n    return 0;\n}\n</code></pre>\n<p>For this program, is reinterpret_cast's output implementation dependent? Or will any compiler conforming to the c++ standard always produce the same output?</p>\n", "Tags": "<c++>", "OwnerUserId": "619570", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24471039_24471606_0": {"section_id": 6046, "quality": 0.6557377049180327, "length": 40}, "so_24471039_24471606_1": {"section_id": 6039, "quality": 0.8913043478260869, "length": 41}}, "n3337": {"so_24471039_24471606_0": {"section_id": 5814, "quality": 0.9508196721311475, "length": 58}, "so_24471039_24471606_1": {"section_id": 5807, "quality": 0.8913043478260869, "length": 41}}, "n4659": {"so_24471039_24471606_0": {"section_id": 7545, "quality": 0.639344262295082, "length": 39}, "so_24471039_24471606_1": {"section_id": 7536, "quality": 0.5652173913043478, "length": 26}}}, "24471303": {"ParentId": "24471039", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2014-06-28T21:56:30.130", "Score": "2", "LastEditorUserId": "464581", "LastEditDate": "2014-06-28T23:46:41.273", "Id": "24471303", "OwnerUserId": "464581", "Body": "<p>You're casting to <code>std::uint32_t</code> a buffer that is not necessarily properly aligned for such a value.</p>\n<p>That's likely to blow up and/or be hugely inefficient.</p>\n<p>The unsigned integer type means that any bitpattern for the value representation bits is OK, and on the PC platform for built-in type there are no bits other than the value representation bits; in particular no trap bits or trapping total bitpatterns.</p>\n<p>Thus, you can do a <code>memcpy</code> and you'll be fine, <em>technically</em> \u2013 provided there are enough bytes, that <code>s.length() &gt;= sizeof(std::uint32_t)</code>.</p>\n<p>However, such a conversion, if it occurred in ordinary code, would be a strong code-smell, an indication of something fundamentally wrong in the design.</p>\n<hr>\n<p><strong>Addendum</strong>, regarding \u201cOr a compiler respectfull to the c++ standard will always produce the same output\u201d.</p>\n<p>I somehow didn\u2019t see that when I answered. But the short answer is that if the conversion is performed in a way that works, such as using <code>memcpy</code>, then it depends on the <em>endianness</em>, a.k.a. <em>byte order</em>, in practice whether the most significant or least significant part of an integer is placed at lowest address.</p>\n<p>In practice you can use network-oriented functions that convert to from <em>network byte order</em>. Just assume network byte order for the serialized data. Check out <code>ntohl</code> et al (these are not part of the C++ standard library, but commonly available).</p>\n</hr>", "LastActivityDate": "2014-06-28T23:46:41.273"}});