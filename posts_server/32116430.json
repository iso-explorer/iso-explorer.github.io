post_cb({"32118790": {"ParentId": "32116430", "LastEditDate": "2015-08-22T19:34:55.107", "CommentCount": "5", "CreationDate": "2015-08-20T12:52:30.360", "Score": "3", "LastEditorUserId": "420683", "PostTypeId": "2", "Id": "32118790", "OwnerUserId": "410767", "Body": "<blockquote>\n<p id=\"so_32116430_32118790_0\">In what cases it's a good (or bad) idea construct an unnamed <code>std::string</code> object, instead of simply using a C-style string literal?</p>\n</blockquote>\n<p>A <code>std::string</code>- literal is a good idea when you specifically want a variable of type <code>std::string</code>, whether for</p>\n<ul>\n<li><p>modifying the value later (<code>auto s = \"123\"s; s += '\\n';</code>)</p></li>\n<li><p>the richer, intuitive and less error-prone interface (value semantics, iterators, <code>find</code>, <code>size</code> etc)</p>\n<ul>\n<li><em>value semantics</em> means <code>==</code>, <code>&lt;</code> copying etc. work on the values, unlike the pointer/by-reference semantics after C-string literals decay to <code>const char*</code>s</li>\n</ul></li>\n<li><p>calling <code>some_templated_function(\"123\"s)</code> would concisely ensure a <code>&lt;std::string&gt;</code> instantiation, with the argument being able to be handled using value semantics internally</p>\n<ul>\n<li>if you know other code's instantiating the template for <code>std::string</code> anyway, and it's of significant complexity relative to your resource constraints, you might want to pass a <code>std::string</code> too to avoid unnecessarily instantiation for <code>const char*</code> too, but it's rare to need to care</li>\n</ul></li>\n<li><p>values containing embedded <code>NUL</code>s</p></li>\n</ul>\n<p>A C-style string literal might be preferred where:</p>\n<ul>\n<li><p>pointer-style semantics are wanted (or at least not a problem)</p></li>\n<li><p>the value's only going to be passed to functions expecting <code>const char*</code> anyway, or <code>std::string</code> temporaries will get constructed anyway and you don't care that you're giving your compiler optimiser one extra hurdle to leap to achieve compile or load time construction if there's potential to reuse the same <code>std::string</code> instance (e.g. when passing to functions by <code>const</code>-reference) - again it's rare to need to care.</p></li>\n<li><p>(another rare and nasty hack) you're somehow leveraging your compiler's string pooling behaviour, e.g. if it guarantees that for any given translation unit the <code>const char*</code> to string literals will only (but of course always) differ if the text differs</p>\n<ul>\n<li>you can't really get the same from <code>std::string</code> <code>.data()</code>/<code>.c_str()</code>, as the same address may be associated with different text (and different <code>std::string</code> instances) during the program execution, and <code>std::string</code> buffers at distinct addresses may contain the same text</li>\n</ul></li>\n<li><p>you benefit from having the pointer remain valid after a <code>std::string</code> would leave scope and be destroyed (e.g. given <code>enum My_Enum { Zero, One };</code> - <code>const char* str(My_Enum e) { return e == Zero ? \"0\" : \"1\"; }</code> is safe, but <code>const char* str(My_Enum e) { return e == Zero ? \"0\"s.c_str() : \"1\"s.c_str(); }</code> isn't and <code>std::string str(My_Enum e) { return e == Zero ? \"0\"s : \"1\"s; }</code> smacks of premature pessimism in always using dynamic allocation (sans SSO, or for longer text))</p></li>\n<li><p>you're leveraging compile-time concatenation of adjacent C-string literals (e.g. <code>\"abc\" \"xyz\"</code> becomes one contiguous <code>const char[]</code> literal <code>\"abcxyz\"</code>) - this is particularly useful inside macro substitutions</p></li>\n<li><p>you're memory constrained and/or don't want to risk an exception or crash during dynamic memory allocation</p></li>\n</ul>\n<h2>Discussion</h2>\n<p>[basic.string.literals] 21.7 lists:</p>\n<blockquote>\n<p id=\"so_32116430_32118790_1\"><code>string operator \"\" s(const char* str, size_t len);</code></p>\n<p id=\"so_32116430_32118790_2\"><em>Returns:</em> <code>string{str,len}</code></p>\n</blockquote>\n<p>Basically, using <code>\"\"s</code> is calling a function that returns a <code>std::string</code> by value - crucially, you can bind a <code>const</code> reference, or rvalue reference, but not an lvalue reference.</p>\n<p>When used to call <code>void foo(std::string arg);</code>, <code>arg</code> will be indeed be <strong><em>move</em></strong> constructed.</p>\n<blockquote>\n<p id=\"so_32116430_32118790_3\">Also, what if foo is overloaded to accept rvalue references? In that case, I think it would make sense to call foo(\"bar\"s), but I could be wrong.</p>\n</blockquote>\n<p>Doesn't matter much which you choose.  Maintenance wise - if <code>foo(const std::string&amp;)</code> is ever changed to <code>foo(const char*)</code>, only <code>foo(\"xyz\");</code> invocations will seamlessly continue working, but there are <em>very</em> few vaguely plausible reasons it might be (so C code could call it too? - but still it'd be a bit mad not to continue to provide a <code>foo(const std::string&amp;)</code> overload for existing client code; so it could be implemented in C? - perhaps; removing dependency on the <code>&lt;string&gt;</code> header? - irrelevant with modern computing resources).</p>\n<blockquote>\n<p id=\"so_32116430_32118790_4\">std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;  // option 1</p>\n<p id=\"so_32116430_32118790_5\">std::cout &lt;&lt; \"Hello World!\"s &lt;&lt; std::endl; // option 2</p>\n</blockquote>\n<p>The former will call <code>operator&lt;&lt;(std::ostream&amp;, const char*)</code>, directly accessing the constant string literal data, with the only disadvantage being that the streaming may have to scan for the terminating NUL.  \"option 2\" would match a <code>const</code>-reference overload and implies construction of a temporary, though compilers might be able to optimise it so they're not doing that unnecessarily often, or even effectively create the string object at compile time (which might only be practical for strings short enough to use an in-object Short String Optimisation (SSO) approach).  If they're not doing such optimisations already, the potential benefit and hence pressure/desire to do so is likely to increase.</p>\n", "LastActivityDate": "2015-08-22T19:34:55.107"}, "32117125": {"ParentId": "32116430", "CommentCount": "7", "CreationDate": "2015-08-20T11:32:58.693", "OwnerUserId": "878532", "PostTypeId": "2", "Id": "32117125", "Score": "1", "Body": "<p>First I believe the answer is opinion based!</p>\n<p>For your example 1 you already mentioned all important arguments to use the new <code>s</code> literal. And yes, I expect that the result is the same so I see no need to say that I want a std::string in the definition.</p>\n<p>One argument can be, that a constructor is defined <code>explicit</code> and a automatic type conversion will not happen. On this condition a <code>s</code> literal is helpful.</p>\n<p>But is is a matter of taste I think!</p>\n<p>For your example 2 I tend to use the \"old\" c-string version because generating a std::string object has overhead. Giving a pointer to the string for cout is well defined and I see no use case where I can have some benefit.</p>\n<p>So my personal advice is actually ( every day new information is available :-) ) to use c-string if this exactly fit my needs. This means: The string is constant and will never be copied or modified and only used \"as is\". So a std::string will have simply no benefit.</p>\n<p>And using 's'-literal comes in use where I have the need to define it is a std::string.</p>\n<p>In a short: I do not use a std::string if I have no need for the additional features which std::string offers over an old c-string. For me the point is not using the s-literal but using std::string vs. c-strings in general.</p>\n<p>Only as a remark: I have to program a lot on very small embedded devices, especially also on 8bit AVRs. Using std::string results in a lot overhead. If I have to use a dynamic container because I need the features of this container, it is very good to have one which is very well implemented and tested. But if I have no need for it it is simply to expensive to use it.</p>\n<p>On a big target like a x86 box, it seems to be negligible to std::string instead of c-string. But having a small device in mind gives you a an idea what is really happening also on big machines.</p>\n<p>Only my two cents!</p>\n", "LastActivityDate": "2015-08-20T11:32:58.693"}, "32116430": {"CommentCount": "10", "ViewCount": "421", "PostTypeId": "1", "LastEditorUserId": "3606363", "CreationDate": "2015-08-20T10:58:34.273", "LastActivityDate": "2015-08-22T19:34:55.107", "LastEditDate": "2015-08-22T19:15:12.010", "AcceptedAnswerId": "32118790", "FavoriteCount": "0", "Title": "Default advice for using C-style string literals vs. constructing unnamed std::string objects?", "Id": "32116430", "Score": "11", "Body": "<p>So C++ 14 introduced a number of user-defined literals to use, one of which is the <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/operator%22%22s\" rel=\"nofollow\">\"s\" literal suffix</a>, for creating <code>std::string</code> objects. According to the documentation, its behavior is exactly the same as constructing an <code>std::string</code> object, like so:</p>\n<pre><code>auto str = \"Hello World!\"s; // RHS is equivalent to: std::string{ \"Hello World!\" }\n</code></pre>\n<p>Of course constructing an unnamed <code>std::string</code> object could be done prior to C++ 14, but because the C++ 14 way is so much simpler, I think way more people will actually consider constructing <code>std::string</code> objects on the spot than before, that's why I thought it makes sense to ask this.</p>\n<p>So my question is simple: <strong>In what cases it's a good (or bad) idea construct an unnamed <code>std::string</code> object, instead of simply using a C-style string literal?</strong></p>\n<hr>\n<h2>Example 1:</h2>\n<p>Consider the following:</p>\n<pre><code>void foo(std::string arg);\n\nfoo(\"bar\");  // option 1\nfoo(\"bar\"s); // option 2\n</code></pre>\n<p>If I'm correct, the first method will call the appropriate constructor overload of <code>std::string</code> to create an object inside <code>foo</code>'s scope, and the second method will construct an unnamed string object first, and then move-construct <code>foo</code>'s argument from that. Although I'm sure that compilers are very good at optimizing stuff like this, but still, the second version seems like it involves an extra move, as opposed to the first alternative (not like a move is expensive of course). But again, after compiling this with a reasonable compiler, the end results are most likely to be highly optimized, and free of redundand moves/copies anyway.</p>\n<p>Also, what if foo is overloaded to accept rvalue references? In that case, I think it would make sense to call <code>foo(\"bar\"s)</code>, but I could be wrong.</p>\n<hr>\n<h2>Example 2:</h2>\n<p>Consider the following:</p>\n<pre><code>std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;  // option 1\nstd::cout &lt;&lt; \"Hello World!\"s &lt;&lt; std::endl; // option 2\n</code></pre>\n<p>In this case, the <code>std::string</code> object is probably passed to <code>cout</code>'s operator via rvalue reference, and the first option passes a pointer probably, so both are very cheap operations, but the second one has the extra cost of constructing an object first. It's probably a safer way to go though (?).</p>\n<hr>\n<p><strong>In all cases of course, constructing an <code>std::string</code> object <em>could</em> result in a heap allocation, which <em>could</em> throw, so exception safety should be taken into consideration as well.</strong> This is more of an issue in the second example though, as in the first example, an <code>std::string</code> object will be constructed in both cases anyway. In practice, getting an exception from constructing a string object is very unlikely, but still could be a valid argument in certain cases.</p>\n<p>If you can think of more examples to consider, please include them in your answer. I'm interested in a general advice regarding the usage of unnamed <code>std::string</code> objects, not just these two particular cases. I only included these to point out some of my thoughts regarding this topic.</p>\n<p>Also, if I got something wrong, feel free to correct me as I'm not by any means a C++ expert. The behaviors I described are only my guesses on how things work, and I didn't base them on actual research or experimenting really.</p>\n</hr></hr></hr>", "Tags": "<c++><string><stdstring><string-literals><c-strings>", "OwnerUserId": "3606363", "AnswerCount": "3"}, "32117238": {"ParentId": "32116430", "CommentCount": "1", "CreationDate": "2015-08-20T11:38:33.763", "OwnerUserId": "186997", "PostTypeId": "2", "Id": "32117238", "Score": "1", "Body": "<blockquote>\n<p id=\"so_32116430_32117238_0\">In what cases it's a good (or bad) idea construct an unnamed std::string object, instead of simply using a C-style string literal?</p>\n</blockquote>\n<p>What is or not a good idea tends to vary with the situation.</p>\n<p>My choice is to <strong>use raw literals whenever they are enough</strong> (whenever I don't need anything else than a literal). If I need to access anything else than a pointer to the first element for the string, (the string length, it's back, iterators or anything else) then I use a std::string literal.</p>\n<blockquote>\n<p id=\"so_32116430_32117238_1\">In all cases of course, constructing an std::string object could result in a heap allocation, which could throw, so exception safety should be taken into consideration as well.</p>\n</blockquote>\n<p>Uhh ... while the code could indeed throw, this is irrelevant unless in very special circumstances (for example, embedded code running at - or close to - the memory limits of the hardware, or high-availability application/environment).</p>\n<p>In practice, I have never had an out of memory condition, from writing <code>auto a = \"abdce\"s;</code> or other similar code.</p>\n<p>In conclusion, <strong>don't bother with the exception safety of out-of-memory situations coming from instantiating a std::string literal</strong>. If you encounter an out of memory situation doing this, change the code when you find the error.</p>\n", "LastActivityDate": "2015-08-20T11:38:33.763"}, "bq_ids": {"n4140": {"so_32116430_32118790_1": {"section_id": 1881, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_32116430_32118790_1": {"section_id": 2053, "quality": 0.5714285714285714, "length": 4}}}});