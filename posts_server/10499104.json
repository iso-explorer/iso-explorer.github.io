post_cb({"10503233": {"ParentId": "10499104", "PostTypeId": "2", "CommentCount": "1", "Body": "<p><a href=\"https://stackoverflow.com/a/10499371/9530\">Daniel Fischer's answer</a> answers the question about the C language specification.  As for what actually happens on an x86 machine when you issue a shift by a variable amount, refer to the <a href=\"http://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html\" rel=\"nofollow noreferrer\">Intel Software Developer Manual</a> Volume 2B, p. 4-506:</p>\n<blockquote>\n<p id=\"so_10499104_10503233_0\">The count is masked to 5 bits (or 6 bits\n  if in 64-bit mode and REX.W is used). The count range is limited to 0 to 31 (or 63 if\n  64-bit mode and REX.W is used).</p>\n</blockquote>\n<p>So if you attempt to shift by an amount larger than 31 or 63 (for 32- and 64-bit values respectively), the hardware will only use the bottom 5 or 6 bits of the shift amount.  So this code:</p>\n<pre><code>uint32_t RightShift(uint32_t value, uint32_t count)\n{\n    return value &gt;&gt; count;\n}\n</code></pre>\n<p>Will result in <code>RightShift(2, 33) == 1</code> on x86 and x86-64.  It's still <strong>undefined behavior</strong> according to the C standard, but on x86, if the compiler compiles it down to a <code>sar</code> instruction, it will have defined behavior on that architecture.  But you should still avoid writing this sort of code that depends on architecture-specific quirks.</p>\n", "OwnerUserId": "9530", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:53:35.590", "Id": "10503233", "Score": "4", "CreationDate": "2012-05-08T17:12:56.067", "LastActivityDate": "2012-05-08T18:02:20.757"}, "10499422": {"ParentId": "10499104", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The C standard requires the shift to work correctly.  A particular buggy compiler might have the defect you describe, but that is buggy behaviour.</p>\n<p>This is a test program:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;inttypes.h&gt;\n\nint main(void)\n{\n    uint64_t x = 1;\n    for (int i = 0; i &lt; 64; i++)\n        printf(\"%2d: 0x%.16\" PRIX64 \"\\n\", i, (x &lt;&lt; i));\n    return 0;\n}\n</code></pre>\n<p>This is the output on an i686 machine running RHEL 5 with GCC 4.1.2, and also on x86/64 machine (also running RHEL 5 and GCC 4.1.2), and on a x86/64 Mac (running Mac OS X 10.7.3 with GCC 4.7.0).  Since that's the expected result, I conclude that there is no necessary problem on the 32-bit machine, and that GCC at least has not exhibited any such bug since GCC 4.1.2 (and probably never has exhibited such a bug).</p>\n<pre><code> 0: 0x0000000000000001\n 1: 0x0000000000000002\n 2: 0x0000000000000004\n 3: 0x0000000000000008\n 4: 0x0000000000000010\n 5: 0x0000000000000020\n 6: 0x0000000000000040\n 7: 0x0000000000000080\n 8: 0x0000000000000100\n 9: 0x0000000000000200\n10: 0x0000000000000400\n11: 0x0000000000000800\n12: 0x0000000000001000\n13: 0x0000000000002000\n14: 0x0000000000004000\n15: 0x0000000000008000\n16: 0x0000000000010000\n17: 0x0000000000020000\n18: 0x0000000000040000\n19: 0x0000000000080000\n20: 0x0000000000100000\n21: 0x0000000000200000\n22: 0x0000000000400000\n23: 0x0000000000800000\n24: 0x0000000001000000\n25: 0x0000000002000000\n26: 0x0000000004000000\n27: 0x0000000008000000\n28: 0x0000000010000000\n29: 0x0000000020000000\n30: 0x0000000040000000\n31: 0x0000000080000000\n32: 0x0000000100000000\n33: 0x0000000200000000\n34: 0x0000000400000000\n35: 0x0000000800000000\n36: 0x0000001000000000\n37: 0x0000002000000000\n38: 0x0000004000000000\n39: 0x0000008000000000\n40: 0x0000010000000000\n41: 0x0000020000000000\n42: 0x0000040000000000\n43: 0x0000080000000000\n44: 0x0000100000000000\n45: 0x0000200000000000\n46: 0x0000400000000000\n47: 0x0000800000000000\n48: 0x0001000000000000\n49: 0x0002000000000000\n50: 0x0004000000000000\n51: 0x0008000000000000\n52: 0x0010000000000000\n53: 0x0020000000000000\n54: 0x0040000000000000\n55: 0x0080000000000000\n56: 0x0100000000000000\n57: 0x0200000000000000\n58: 0x0400000000000000\n59: 0x0800000000000000\n60: 0x1000000000000000\n61: 0x2000000000000000\n62: 0x4000000000000000\n63: 0x8000000000000000\n</code></pre>\n", "OwnerUserId": "15168", "LastEditorUserId": "15168", "LastEditDate": "2012-05-08T13:23:27.333", "Id": "10499422", "Score": "3", "CreationDate": "2012-05-08T13:18:09.067", "LastActivityDate": "2012-05-08T13:23:27.333"}, "10499451": {"ParentId": "10499104", "CommentCount": "0", "Body": "<p>No it is ok.</p>\n<p>ISO 9899:2011 6.5.7 Bitwise shift operators</p>\n<blockquote>\n<p id=\"so_10499104_10499451_0\"><strong>If the value of the right operand</strong> is negative or <strong>is greater than or equal</strong> to the width of the promoted left operand, the <strong>behavior is undefined</strong>.</p>\n</blockquote>\n<p>That isn't the case here, so it is all fine and well-defined.</p>\n", "OwnerUserId": "584518", "PostTypeId": "2", "Id": "10499451", "Score": "1", "CreationDate": "2012-05-08T13:20:39.567", "LastActivityDate": "2012-05-08T13:20:39.567"}, "10499104": {"CommentCount": "14", "AcceptedAnswerId": "10499371", "PostTypeId": "1", "LastEditorUserId": "274261", "CreationDate": "2012-05-08T12:59:57.377", "LastActivityDate": "2012-05-08T18:02:20.757", "LastEditDate": "2012-05-08T13:18:59.033", "ViewCount": "10861", "FavoriteCount": "1", "Title": "Is Shifting more than 32 bits of a uint64_t integer on an x86 machine Undefined Behavior?", "Id": "10499104", "Score": "11", "Body": "<p>Learning the hard way, I tried to left shift a <code>long long</code> and <code>uint64_t</code> to more than 32 bits on an x86 machine resulted <code>0</code>. I vaguely remember to have read somewhere than on a 32 bit machine shift operators only work on the first 32 bits but cannot recollect the source.\nI would like to know is if Shifting more than 32 bits of a uint64_t integer on an x86 machine is an Undefined Behavior?</p>\n", "Tags": "<c++><c><x86><bit-shift><uint64>", "OwnerUserId": "977038", "AnswerCount": "5"}, "10499361": {"ParentId": "10499104", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>Shifting by a number comprised between 0 and the predecessor of the width of the type does not cause undefined behavior, but left-shifting a negative number does. Would you be doing that?</p>\n<p>On the other hand, right-shifting a negative number is implementation-defined, and most compilers, when right-shifting signed types, propagate the sign bit.</p>\n", "OwnerUserId": "139746", "LastEditorUserId": "139746", "LastEditDate": "2012-05-08T16:54:50.760", "Id": "10499361", "Score": "1", "CreationDate": "2012-05-08T13:14:51.910", "LastActivityDate": "2012-05-08T16:54:50.760"}, "10499371": {"ParentId": "10499104", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The standard says (6.5.7 in n1570):</p>\n<blockquote>\n<p id=\"so_10499104_10499371_0\">3 The integer promotions are performed on each of the operands. The type of the result is\n  that of the promoted left operand. If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is unde\ufb01ned.</p>\n<p id=\"so_10499104_10499371_1\">4 The result of E1 &lt;&lt; E2 is E1 left-shifted E2 bit positions; vacated bits are \ufb01lled with\n  zeros. If E1 has an unsigned type, the value of the result is E1 \u00d7 2<sup>E2</sup> , reduced modulo\n  one more than the maximum value representable in the result type. If E1 has a signed\n  type and nonnegative value, and E1 \u00d7 2<sup>E2</sup> is representable in the result type, then that is\n  the resulting value; otherwise, the behavior is unde\ufb01ned.</p>\n<p id=\"so_10499104_10499371_2\">5 The result of E1 &gt;&gt; E2 is E1 right-shifted E2 bit positions. If E1 has an unsigned type\n  or if E1 has a signed type and a nonnegative value, the value of the result is the integral\n  part of the quotient of E1 / 2<sup>E2</sup> . If E1 has a signed type and a negative value, the\n  resulting value is implementation-de\ufb01ned.</p>\n</blockquote>\n<p>Shifting a <code>uint64_t</code> a distance of less than 64 bits is completely defined by the standard.</p>\n<p>Since <code>long long</code> must be at least 64 bits, shifting <code>long long</code> values less than 64 bits is defined by the standard for nonnegative values, if the result doesn't overflow.</p>\n<p>Note, however, that if you write a literal that fits into 32 bits, e.g. <code>uint64_t s = 1 &lt;&lt; 32</code> as surmised by @drhirsch, you don't actually shift a 64-bit value but a 32-bit one. That is undefined behaviour. The most common results are a shift by <code>shift_distance % 32</code> or 0, depending on what the hardware does.</p>\n", "OwnerUserId": "1011995", "LastEditorUserId": "1011995", "LastEditDate": "2012-05-08T16:22:42.240", "Id": "10499371", "Score": "19", "CreationDate": "2012-05-08T13:15:31.613", "LastActivityDate": "2012-05-08T16:22:42.240"}, "bq_ids": {"n4140": {"so_10499104_10499371_1": {"section_id": 6147, "quality": 0.8157894736842105, "length": 31}, "so_10499104_10499451_0": {"section_id": 6146, "quality": 0.6923076923076923, "length": 9}, "so_10499104_10499371_2": {"section_id": 6148, "quality": 0.8333333333333334, "length": 20}, "so_10499104_10499371_0": {"section_id": 6146, "quality": 0.64, "length": 16}}, "n3337": {"so_10499104_10499371_1": {"section_id": 5910, "quality": 0.8157894736842105, "length": 31}, "so_10499104_10499371_2": {"section_id": 5911, "quality": 0.8333333333333334, "length": 20}, "so_10499104_10499451_0": {"section_id": 5909, "quality": 0.6923076923076923, "length": 9}, "so_10499104_10499371_0": {"section_id": 5909, "quality": 0.64, "length": 16}}, "n4659": {"so_10499104_10499371_1": {"section_id": 7643, "quality": 0.8157894736842105, "length": 31}, "so_10499104_10499451_0": {"section_id": 7642, "quality": 0.6923076923076923, "length": 9}, "so_10499104_10499371_2": {"section_id": 7644, "quality": 0.8333333333333334, "length": 20}, "so_10499104_10499371_0": {"section_id": 7642, "quality": 0.64, "length": 16}}}});