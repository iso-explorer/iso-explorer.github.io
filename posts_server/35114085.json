post_cb({"bq_ids": {"n4140": {"so_35114085_35114085_1": {"section_id": 639, "quality": 1.0, "length": 34}, "so_35114085_35114085_0": {"section_id": 631, "quality": 0.95, "length": 19}}, "n3337": {"so_35114085_35114085_1": {"section_id": 629, "quality": 0.8235294117647058, "length": 28}, "so_35114085_35114085_0": {"section_id": 621, "quality": 0.9, "length": 18}}, "n4659": {"so_35114085_35114085_1": {"section_id": 667, "quality": 1.0, "length": 34}, "so_35114085_35114085_0": {"section_id": 658, "quality": 0.95, "length": 19}}}, "35114085": {"CommentCount": "5", "ViewCount": "82", "CreationDate": "2016-01-31T12:56:11.073", "LastActivityDate": "2016-01-31T13:00:43.980", "Title": "Worst conversion sequence in list-initialization", "PostTypeId": "1", "Id": "35114085", "Score": "1", "Body": "<p>I don't understand how worst conversion sequences for initializer_list are ranked during overload resolution. For example:</p>\n<pre><code>#include &lt;initializer_list&gt;\n\nvoid fnc (std::initializer_list&lt;int&gt;){}\nvoid fnc (std::initializer_list&lt;long&gt;){}\n\nstruct CL1 {\n    operator short(){return 1;} };\n\nstruct CL2 {\n    operator short(){return 1;} };\n\nint main() {\n    CL1 cl1;\n    CL2 cl2;\n    fnc ({cl1, cl2});\n}\n</code></pre>\n<p>Here is a call of overloaded fnc function and overload resolution finds the best-viable function. The candidates are 2 functions which are ranked by comparing their needed conversion sequences.</p>\n<p>The Standard (n4296) 13.3.3.1.5/4 [over.ics.list] says:</p>\n<blockquote>\n<p id=\"so_35114085_35114085_0\">Otherwise, if the parameter type is std::initializer_list and all the\n  elements of the initializer list can be implicitly converted to X, the\n  implicit conversion sequence is the worst conversion necessary to\n  convert an element of the list to X</p>\n</blockquote>\n<p>For <code>std::initializer_list&lt;int&gt;</code> both conversions (CL1 -&gt; int, CL2 -&gt; int) are indistinguishable and both can be worst conversion (user-defined conversion + promotion). Simularly for <code>std::initializer_list&lt;long&gt;</code>, but with worst conversion sequence as user-defined conversion + standard conversion. And then the main question: which conversion (for cl1 or cl2) is selected as worst? Assume that in both initializer lists the worst conversion is selected as first (for cl1). Then, according to 13.3.3.2/3.3 [over.ics.rank]</p>\n<blockquote>\n<p id=\"so_35114085_35114085_1\">User-defined conversion sequence U1 is a better conversion sequence\n  than another user-defined conversion sequence U2 if they contain the\n  same user-defined conversion function or constructor or they\n  initialize the same class in an aggregate initialization and in either\n  case the second standard conversion sequence of U1 is better than the\n  second standard conversion sequence of U2.</p>\n</blockquote>\n<p>the case with int is better because its second standard conversion sequence is better (promotion against standard conversion) and both conversions contain the same operator short(). Then assume that for <code>std::initializer_list&lt;long&gt;</code> worst conversion is for second element (cl2), and here is ambuguity because conversion functions are different.</p>\n", "Tags": "<c++><c++11><type-conversion><overloading><c++14>", "OwnerUserId": "3514538", "AnswerCount": "0"}});