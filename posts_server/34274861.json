post_cb({"34274861": {"CommentCount": "1", "AcceptedAnswerId": "34274922", "ClosedDate": "2015-12-14T23:30:11.307", "CreationDate": "2015-12-14T19:16:04.973", "LastActivityDate": "2015-12-14T23:12:43.230", "PostTypeId": "1", "ViewCount": "118", "FavoriteCount": "1", "Title": "C++ reversing indexer and name of array", "Id": "34274861", "Score": "10", "Body": "<p>I came across this online and was wondering if someone might be able to explain this or at least give me a name of what it might be so that I can at least know what I'm googling for. </p>\n<pre><code>int main()\n{\n   int myarray[4] = {0, 100, 200, 300};\n   2[myarray] = -999;  //why does this work? what is this called?\n\n   for ( int i = 0; i &lt; 4; i++) \n      cout &lt;&lt; myarray[i] &lt;&lt; endl;\n}\n</code></pre>\n<p>The output is 0, 100, -999, 300</p>\n<p>I've ran it. I know it works but why? What is this called? </p>\n", "Tags": "<c++>", "OwnerUserId": "990173", "AnswerCount": "2"}, "34274996": {"ParentId": "34274861", "CommentCount": "0", "Body": "<p>I don't think this particular [ab-]use of the rules for pointer arithmetic has any particular name. It is simply falling out of the way pointer arithmetic is defined in C and C++. Neither of the two language standards makes any special attempt to prevent the reversal of the subscript and the pointer. For example, the relevant C++ rule is in 5.2.1 [expr.sub] paragraph 1:</p>\n<blockquote>\n<p id=\"so_34274861_34274996_0\">A postfix expression followed by an expression in square brackets is a postfix expression. One of the expressions shall have the type \u201carray of T\u201d or \u201cpointer to T\u201d and the other shall have unscoped enumeration or integral type. The result is of type \u201cT.\u201d The type \u201cT\u201d shall be a completely-defined object type. The expression E1[E2] is identical (by definition) to *((E1)+(E2)) [ Note: see 5.3 and 5.7 for details of * and + and 8.3.4 for details of arrays. \u2014end note ], except that in the case of an array operand, the result is an lvalue if that operand is an lvalue and an xvalue otherwise.</p>\n</blockquote>\n<p>It <em>may</em> work to look for \"C++ 5.2.1\" or \"C++ [expr.sub]\" but the use of the reversal isn't that large beyond confusing people who haven't look long enough at C or C++.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "34274996", "Score": "3", "CreationDate": "2015-12-14T19:24:28.443", "LastActivityDate": "2015-12-14T19:24:28.443"}, "34274922": {"ParentId": "34274861", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The reason this is the case is because <code>arr[n]</code> == <code>*(arr + n)</code>.</p>\n<p>However, because addition is commutative, <code>*(arr + n)</code> == <code>*(n + arr)</code>. Thus, <code>*(n + arr)</code> == <code>n[arr]</code> == <code>*(arr + n)</code> == <code>arr[n]</code>.</p>\n<p>It might be worth mentioning that <code>*(arr + n)</code> is still a little misleading. In assembly it actually means <code>*(arr + (n * s))</code> where <code>s</code> is <code>sizeof arr[0]</code>, but this is under the covers so you don't need to worry about it.</p>\n", "OwnerUserId": "2883245", "LastEditorUserId": "2883245", "LastEditDate": "2015-12-14T23:12:43.230", "Id": "34274922", "Score": "8", "CreationDate": "2015-12-14T19:19:18.473", "LastActivityDate": "2015-12-14T23:12:43.230"}, "bq_ids": {"n4140": {"so_34274861_34274996_0": {"section_id": 5986, "quality": 0.8653846153846154, "length": 45}}, "n3337": {"so_34274861_34274996_0": {"section_id": 5754, "quality": 0.6538461538461539, "length": 34}}, "n4659": {"so_34274861_34274996_0": {"section_id": 7486, "quality": 0.8269230769230769, "length": 43}}}});