post_cb({"29375948": {"ParentId": "19736281", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>A much easier example that differs b/w all of them. </p>\n<pre><code>class Base {\npublic:\n    virtual int fcn();\n};\n\nclass D1 : public Base {\npublic:  \n    // D1 inherits the definition of Base::fcn()\n    int fcn(int);  // parameter list differs from fcn in Base\n    virtual void f2(); // new virtual function that does not exist in Base\n};\n\nclass D2 : public D1 {\npublic:\n    int fcn(int); // nonvirtual function hides D1::fcn(int)\n    int fcn();  // overrides virtual fcn from Base\n    void f2();  // overrides virtual f2 from D1\n}\n</code></pre>\n", "OwnerUserId": "4417582", "LastEditorUserId": "4417582", "LastEditDate": "2015-06-27T22:15:18.260", "Id": "29375948", "Score": "1", "CreationDate": "2015-03-31T18:35:19.043", "LastActivityDate": "2015-06-27T22:15:18.260"}, "19736282": {"ParentId": "19736281", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>We'll start with the easy ones.</p>\n<p><code>p1</code> is a <code>Parent</code> pointer, so it will always call <code>Parent</code>'s member functions.</p>\n<p><code>cp</code> is a pointer to <code>Child</code>, so it will always call <code>Child</code>'s member functions.</p>\n<p>Now the more difficult one. <code>p2</code> is a <code>Parent</code> pointer, but it is pointing to an object of type <code>Child</code>, so it will call <code>Child</code>'s functions whenever the matching <code>Parent</code> function is virtual or the function only exists within <code>Child</code> and not in <code>Parent</code>. In other words, <code>Child</code> hides <code>Parent::doA()</code> with its own <code>doA()</code>, but it overrides <code>Parent::doB()</code>. Function hiding is sometimes considered a form of function overloading, because a function with the same name is given a different implementation. Because the hiding function is in a different class than the hidden function, it does have a different signature, which makes it clear which to use.</p>\n<p>The output for <code>testStuff()</code> will be</p>\n<pre><code>doA in Parent\ndoA in Parent\ndoA in Child\ndoB in Parent\ndoB in Child\ndoB in Child\n</code></pre>\n<p>In any case, <code>Parent::doA()</code> and <code>Parent::doB()</code> can be called within <code>Child</code> using name resolution, regardless of the function's \"virtual-ness\". The function</p>\n<pre><code>void Child::doX() {\n  doA();\n  doB();\n  Parent::doA();\n  Parent::doB();\n  cout &lt;&lt; \"doX in Child\" &lt;&lt; endl;\n}\n</code></pre>\n<p>demonstrates this when called by <code>cp-&gt;doX()</code> by outputting</p>\n<pre><code>doA in Child\ndoB in Child\ndoA in Parent\ndoB in Parent\ndoX in Child\n</code></pre>\n<p>Additionally, <code>cp-&gt;Parent::doA()</code> will call <code>Parent</code>'s version of <code>doA()</code>.</p>\n<p><code>p2</code> cannot refer to <code>doX()</code> because it is a <code>Parent*</code>, and <code>Parent</code> doesn't know about anything in <code>Child</code>. However, <code>p2</code> can be casted to a <code>Child*</code>, since it was initialized as one, and then it can be used to call <code>doX()</code>.</p>\n", "OwnerUserId": "1736312", "LastEditorUserId": "1317944", "LastEditDate": "2016-09-08T11:57:55.007", "Id": "19736282", "Score": "0", "CreationDate": "2013-11-01T22:15:57.507", "LastActivityDate": "2016-09-08T11:57:55.007"}, "19737267": {"ParentId": "19736281", "PostTypeId": "2", "CommentCount": "5", "Body": "<h3>What is function hiding?</h3>\n<p>... is a form of name hiding. A simple example:</p>\n<pre><code>void foo(int);\nnamespace X\n{\n    void foo();\n\n    void bar()\n    {\n        foo(42); // will not find `::foo`\n        // because `X::foo` hides it\n    }\n}\n</code></pre>\n<p>This also applies to the name lookup in a base class:</p>\n<pre><code>class Base\n{\npublic:\n    void foo(int);\n};\n\nclass Derived : public Base\n{\npublic:\n    void foo();\n    void bar()\n    {\n        foo(42); // will not find `Base::foo`\n        // because `Derived::foo` hides it\n    }\n};\n</code></pre>\n<hr>\n<h3>What is function overriding?</h3>\n<p>This is linked to the concept of virtual functions. [class.virtual]/2</p>\n<blockquote>\n<p id=\"so_19736281_19737267_0\">If a virtual member function <code>vf</code> is declared in a class <code>Base</code> and in a class <code>Derived</code>, derived directly or indirectly from <code>Base</code>, a member function <code>vf</code> with the same name, parameter-type-list, cv-qualification, and ref-qualifier (or absence of same) as <code>Base::vf</code> is declared, then <code>Derived::vf</code> is also virtual (whether or not it is so declared) and it <em>overrides</em> <code>Base::vf</code>.</p>\n</blockquote>\n<pre><code>class Base\n{\nprivate:\n    virtual void vf(int) const &amp;&amp;;\n    virtual void vf2(int);\n    virtual Base* vf3(int);\n};\n\nclass Derived : public Base\n{\npublic: // accessibility doesn't matter!\n    void vf(int) const &amp;&amp;; // overrides `Base::vf(int) const &amp;&amp;`\n    void vf2(/*int*/);     // does NOT override `Base::vf2`\n    Derived* vf3(int);     // DOES override `Base::vf3` (covariant return type)\n};\n</code></pre>\n<p>The final overrider becomes relevant when calling a virtual function: [class.virtual]/2</p>\n<blockquote>\n<p id=\"so_19736281_19737267_1\">A virtual member function <code>C::vf</code> of a class object <code>S</code> is a final overrider unless the most derived class of which <code>S</code> is a base class subobject (if any) declares or inherits another member function that overrides <code>vf</code>.</p>\n</blockquote>\n<p>I.e. if you have an object of type <code>S</code>, the final overrider is the first overrider you see when traversing the class hierarchy of <code>S</code> back to its base classes. The important point is that the <em>dynamic type</em> of the function-call expression is used in order to determine the final overrider:</p>\n<pre><code>Base* p = new Derived;\np -&gt; vf();    // dynamic type of `*p` is `Derived`\n\nBase&amp; b = *p;\nb  . vf();    // dynamic type of `b` is `Derived`\n</code></pre>\n<hr>\n<h3>What is the difference between overriding and hiding?</h3>\n<p>Essentially, the functions in the base class are always hidden by functions of the same name in a derived class; no matter if the function in the derived class overrides a base class' virtual function or not:</p>\n<pre><code>class Base\n{\nprivate:\n    virtual void vf(int);\n    virtual void vf2(int);\n};\n\nclass Derived : public Base\n{\npublic:\n    void vf();     // doesn't override, but hides `Base::vf(int)`\n    void vf2(int); // overrides and hides `Base::vf2(int)`\n};\n</code></pre>\n<p>To find a function name, the static type of an expression is used:</p>\n<pre><code>Derived d;\nd.vf(42);   // `vf` is found as `Derived::vf()`, this call is ill-formed\n            // (too many arguments)\n</code></pre>\n<hr>\n<h3>How do they relate to function overloads?</h3>\n<p>As \"function hiding\" is a form of name hiding, all overloads are affected if the name of a function is hidden:</p>\n<pre><code>class Base\n{\nprivate:\n    virtual void vf(int);\n    virtual void vf(double);\n};\n\nclass Derived : public Base\n{\npublic:\n    void vf();     // hides `Base::vf(int)` and `Base::vf(double)`\n};\n</code></pre>\n<p>For function overriding, only the function in the base class with the same arguments will be overriden; you can of course overload a virtual function:</p>\n<pre><code>class Base\n{\nprivate:\n    virtual void vf(int);\n    virtual void vf(double);\n    void vf(char);  // will be hidden by overrides in a derived class\n};\n\nclass Derived : public Base\n{\npublic:\n    void vf(int);    // overrides `Base::vf(int)`\n    void vf(double); // overrides `Base::vf(double)`\n};\n</code></pre>\n</hr></hr></hr>", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2013-11-04T20:19:16.530", "Id": "19737267", "Score": "17", "CreationDate": "2013-11-01T23:49:23.817", "LastActivityDate": "2013-11-04T20:19:16.530"}, "19737085": {"ParentId": "19736281", "CommentCount": "1", "Body": "<p>The example code you're writen in the question essentially gives the answer when you run it.</p>\n<p>Calling a non-virtual function will use the function from the same class as the pointer type, regardless of whether the object was actually created as some other derived type. Whereas calling a virtual function will use the function from the original allocated object type, regardless of what kind of pointer you're using.</p>\n<p>So your program's output in this case will be:</p>\n<pre><code>doA in Parent\ndoA in Parent\ndoA in Child\ndoB in Parent\ndoB in Child\ndoB in Child\n</code></pre>\n", "OwnerUserId": "475491", "PostTypeId": "2", "Id": "19737085", "Score": "1", "CreationDate": "2013-11-01T23:30:11.493", "LastActivityDate": "2013-11-01T23:30:11.493"}, "19736281": {"CommentCount": "6", "AcceptedAnswerId": "19737267", "PostTypeId": "1", "LastEditorUserId": "1736312", "CreationDate": "2013-11-01T22:15:57.507", "LastActivityDate": "2017-10-21T22:51:57.087", "LastEditDate": "2013-11-01T23:12:55.297", "ViewCount": "10916", "FavoriteCount": "5", "Title": "What are the differences between overriding virtual functions and hiding non-virtual functions?", "Id": "19736281", "Score": "11", "Body": "<p>Given the following code fragment, what are the differences in the function calls? What is function hiding? What is function overriding? How do they relate to function overloads? What is the difference between the two? I couldn't find a good description of these in one place, so I'm asking here so I can consolidate the information.</p>\n<pre><code>class Parent {\n  public:\n    void doA() { cout &lt;&lt; \"doA in Parent\" &lt;&lt; endl; }\n    virtual void doB() { cout &lt;&lt; \"doB in Parent\" &lt;&lt; endl; }\n};\n\nclass Child : public Parent {\n  public:\n    void doA() { cout &lt;&lt; \"doA in Child\" &lt;&lt; endl; }\n    void doB() { cout &lt;&lt; \"doB in Child\" &lt;&lt; endl; }\n};\n\nParent* p1 = new Parent();\nParent* p2 = new Child();\nChild* cp = new Child();\n\nvoid testStuff() {\n  p1-&gt;doA();\n  p2-&gt;doA();\n  cp-&gt;doA();\n\n  p1-&gt;doB();\n  p2-&gt;doB();\n  cp-&gt;doB();\n}\n</code></pre>\n", "Tags": "<c++><inheritance><virtual-functions><override><method-hiding>", "OwnerUserId": "1736312", "AnswerCount": "5"}, "31094117": {"ParentId": "19736281", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The difference between calling a <em>virtual</em> member function and calling a <em>non-virtual</em> member function is that, by definition, in the former case the target function is chosen in accordance with the <em>dynamic</em> type of the object expression used in the call, while in the latter case the <em>static</em> type is used.</p>\n<p>That's all there is to it. Your example clearly illustrates this difference by <code>p2-&gt;doA()</code> and <code>p2-&gt;doB()</code> calls. Static type of <code>*p2</code> expression is <code>Parent</code>, while dynamic type of the same expression is <code>Child</code>. This is why <code>p2-&gt;doA()</code> calls <code>Parent::doA</code> and <code>p2-&gt;doB()</code> calls <code>Child::doB</code>.</p>\n<p>In contexts in which that difference matters, name hiding does not come into the picture at all.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2017-10-21T22:51:57.087", "Id": "31094117", "Score": "3", "CreationDate": "2015-06-27T22:21:01.250", "LastActivityDate": "2017-10-21T22:51:57.087"}, "bq_ids": {"n4140": {"so_19736281_19737267_0": {"section_id": 7003, "quality": 0.967741935483871, "length": 30}, "so_19736281_19737267_1": {"section_id": 7003, "quality": 0.95, "length": 19}}, "n3337": {"so_19736281_19737267_0": {"section_id": 6749, "quality": 0.967741935483871, "length": 30}, "so_19736281_19737267_1": {"section_id": 6749, "quality": 0.95, "length": 19}}, "n4659": {"so_19736281_19737267_0": {"section_id": 8500, "quality": 0.967741935483871, "length": 30}, "so_19736281_19737267_1": {"section_id": 8500, "quality": 0.95, "length": 19}}}});