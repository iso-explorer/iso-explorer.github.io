post_cb({"15730992": {"CommentCount": "1", "AcceptedAnswerId": "15730993", "ClosedDate": "2013-03-31T15:58:38.290", "CreationDate": "2013-03-31T15:26:27.477", "LastActivityDate": "2013-03-31T15:30:14.127", "PostTypeId": "1", "ViewCount": "1227", "FavoriteCount": "2", "Title": "Why does resize() cause a copy, rather than a move, of a vector's content when capacity is exceeded?", "Id": "15730992", "Score": "8", "Body": "<p>Given class <code>X</code> below (special member functions other than the one explicitly defined are not relevant for this experiment):</p>\n<pre><code>struct X\n{\n    X() { }\n    X(int) { }\n    X(X const&amp;) { std::cout &lt;&lt; \"X(X const&amp;)\" &lt;&lt; std::endl; }\n    X(X&amp;&amp;) { std::cout &lt;&lt; \"X(X&amp;&amp;)\" &lt;&lt; std::endl; }\n};\n</code></pre>\n<p>The following program creates a vector of objects of type <code>X</code> and resizes it so that its capacity is exceeded and reallocation is forced:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main()\n{\n    std::vector&lt;X&gt; v(5);\n    v.resize(v.capacity() + 1);\n}\n</code></pre>\n<p>Since class <code>X</code> provides a move constructor, I would expect the previous content of the vector to be <em>moved</em> into the new storage after reallocation. Quite surprisingly, <a href=\"http://liveworkspace.org/code/48Ihhx$193\" rel=\"noreferrer\">that does not seem to be the case</a>, and the output I get is:</p>\n<pre><code>X(X const&amp;)\nX(X const&amp;)\nX(X const&amp;)\nX(X const&amp;)\nX(X const&amp;)\n</code></pre>\n<p><strong>Why?</strong></p>\n", "Tags": "<c++><c++11><copy-constructor><move-semantics>", "OwnerUserId": "1932150", "AnswerCount": "2"}, "15730993": {"ParentId": "15730992", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>Paragraph 23.3.6.3/14 of the C++11 Standard specifies (about the <code>resize()</code> member function of the <code>vector&lt;&gt;</code> class template):</p>\n<blockquote>\n<p id=\"so_15730992_15730993_0\"><em>Remarks</em>: If an exception is thrown other than by the move constructor of a non-<code>CopyInsertable T</code> <strong>there are no effects</strong>.</p>\n</blockquote>\n<p>In other words, this means that for <code>X</code> (which is <code>CopyInsertable</code>), <code>resize()</code> offers the <a href=\"http://en.wikipedia.org/wiki/Exception_safety\" rel=\"nofollow noreferrer\"><strong>strong guarantee</strong></a>: it either succeeds or leaves the state of the vector unchanged.</p>\n<p>In order to satisfy this guarantee, implementations usally adopt the <a href=\"https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom\"><strong>copy-and-swap idiom</strong></a>: if the copy constructor of <code>X</code> throws, we haven't altered the content of the original vector yet, so the promise is kept. </p>\n<p>However, if the previous content of the vector were <em>moved</em> into the new storage rather than being copied <strong>and the move constructor threw</strong>, then we would have irreversibly changed the original content of the vector.</p>\n<p>Therefore, implementations will use the copy constructor of <code>X</code> to safely transfer the content of the vector into a new storage <strong>unless the move constructor is known not to throw</strong>, in which case it is safe to move from the previous elements. </p>\n<p>With a small change to the definition of <code>X</code>'s move constructor (marking it as <code>noexcept</code>), in fact, <a href=\"http://liveworkspace.org/code/48Ihhx$195\" rel=\"nofollow noreferrer\">the output of the program is now the expected one</a>.:</p>\n<pre><code>struct X\n{\n    X() { }\n    X(int) { }\n    X(X const&amp;) { std::cout &lt;&lt; \"X(X const&amp;)\" &lt;&lt; std::endl; }\n    X(X&amp;&amp;) noexcept { std::cout &lt;&lt; \"X(X&amp;&amp;)\" &lt;&lt; std::endl; }\n//         ^^^^^^^^\n};\n</code></pre>\n", "OwnerUserId": "1932150", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:53:50.530", "Id": "15730993", "Score": "17", "CreationDate": "2013-03-31T15:26:27.477", "LastActivityDate": "2013-03-31T15:26:27.477"}, "bq_ids": {"n4140": {"so_15730992_15730993_0": {"section_id": 969, "quality": 0.9, "length": 9}}, "n3337": {"so_15730992_15730993_0": {"section_id": 958, "quality": 0.9, "length": 9}}, "n4659": {"so_15730992_15730993_0": {"section_id": 873, "quality": 0.9, "length": 9}}}, "15731041": {"ParentId": "15730992", "CommentCount": "0", "Body": "<p>Think about the exception guarantees: If there's an exception during the reallocation, the vector has to remain unchanged. This can only be guaranteed by copying the elements and retaining the old set until the entire copy has succeeded.</p>\n<p>Only if you know that the move constructor doesn't throw can you safely move the elements to the new location. To achieve this, declare the move constructor <code>noexcept</code>.</p>\n", "OwnerUserId": "596781", "PostTypeId": "2", "Id": "15731041", "Score": "5", "CreationDate": "2013-03-31T15:30:14.127", "LastActivityDate": "2013-03-31T15:30:14.127"}});