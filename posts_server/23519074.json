post_cb({"23520450": {"Id": "23520450", "PostTypeId": "2", "Body": "<p>What you're doing is <em>partially</em> OK, but the bit that isn't OK is probably the most important bit.</p>\n<p>In C, <code>void *</code> is a generic pointer for any <em>object</em> type (C11 6.3.2.3.1):</p>\n<blockquote>\n<p id=\"so_23519074_23520450_0\">A pointer to <code>void</code> may be converted to or from a pointer to any\n  object type.</p>\n</blockquote>\n<p>It is undefined behavior to convert a pointer to a function to a <code>void *</code>. A function is not an object.</p>\n<p>It is OK to convert a function to a function of one type to a pointer to a function of another type, and back again, without loss of information (C11 6.3.2.3.8). In your case, you are converting from, in one case, an <code>int (*)(int)</code> to a <code>void *(*)()</code>. The <code>(void *(*)())</code> cast would be OK, and the <code>(void *)</code> case would not be OK.</p>\n<p>Where you run into trouble is when you try to actually <em>call</em> that function from the converted type. Again, from C11 6.3.2.3.8:</p>\n<blockquote>\n<p id=\"so_23519074_23520450_1\">If a converted pointer is used to call a function whose type is not\n  compatible with the referenced type, the behavior is undefined.</p>\n</blockquote>\n<p>So in your case, when you convert <code>myfun2()</code>, for instance, to <code>a.function</code> with <code>a.function =(void *(*)())myfun2</code>, the conversion itself is fine. But what you cannot do is then call that function via <code>a.function('a')</code>, because the types of the two functions are not compatible, so you're into undefined behavior.</p>\n<p>Since you define <code>A.function</code> as a pointer to a function with an unspecified number of arguments, you may be OK for compatibility on the parameter front per C11 6.7.6.3.15:</p>\n<blockquote>\n<p id=\"so_23519074_23520450_2\">If one type has a parameter type list and the other type is specified\n  by a function declarator that is not part of a function definition and\n  that contains an empty identifier list, the parameter list shall not\n  have an ellipsis terminator and the type of each parameter shall be\n  compatible with the type that results from the application of the\n  default argument promotions</p>\n</blockquote>\n<p>and since there is only one parameter of type <code>int</code> in <code>myfun2()</code>, this is satisfied. What will really mess you up is the return type, since <code>void *</code> and <code>int</code> are incompatible, so you have undefined behavior. In reality, on most modern 64 bit systems, <code>void *</code> and <code>int</code> will not be the same size, so you could expect unpredictable results trying to do this on such a system even if it will let you.</p>\n<p>Because the conversion itself is OK, you can use any function pointer to store any other, so if you wanted to you could store additional information about the function type in the struct, and use it later to convert to a compatible type, for instance:</p>\n<pre><code>if ( a.return_type == RET_TYPE_INT &amp;&amp; a.arg_type == ARG_TYPE_INT ) {\n    int (*fp)(int) = (int(*)(int)) a.function;\n    int n = fp('a');\n\n    /*  Do something with n  */\n\n}\nelse if ( a.return_type = RET_TYPE_CHAR &amp;&amp; a.arg_type == ARG_TYPE_INT ) {\n    char (*fp)(int) = (char(*)(int)) a.function;\n    char ch = fp('a');\n\n    /*  Do something with ch  */\n\n}\n</code></pre>\n<p>and so on, where <code>RET_TYPE_CHAR</code> and <code>ARG_TYPE_INT</code> are constants you've defined yourself, and <code>return_type</code> and <code>arg_type</code> are additional members of <code>struct A</code> that you'd populate when setting <code>a.function</code>.</p>\n", "LastEditorUserId": "2399879", "LastActivityDate": "2014-05-07T14:38:21.573", "Score": "2", "CreationDate": "2014-05-07T14:22:39.210", "ParentId": "23519074", "CommentCount": "0", "OwnerUserId": "2399879", "LastEditDate": "2014-05-07T14:38:21.573"}, "23519210": {"Id": "23519210", "PostTypeId": "2", "Body": "<p>Um, it's worng if you're in C++.</p>\n<p>But in C, <code>void *</code> can be cast implicit.</p>\n<blockquote id=\"so_23519074_23519210_0\">\n<ol>\n<li>cast to void* explicit</li>\n<li>cast to void*(*) implicit</li>\n</ol>\n</blockquote>\n", "LastActivityDate": "2014-05-07T13:28:09.947", "CommentCount": "6", "CreationDate": "2014-05-07T13:28:09.947", "ParentId": "23519074", "Score": "-2", "OwnerUserId": "2729109"}, "23519454": {"Id": "23519454", "PostTypeId": "2", "Body": "<pre><code>a.function =(void *(*)())myfun2;\n</code></pre>\n<p>I guess you are think <code>()</code> after function name implies function doesn't take any argument. It actually means function can take any number of argument.</p>\n<p>If you want such senseless code to be illegal, you should change your structure as following</p>\n<pre><code>struct A {\n  int data;             /* this is data */\n  void *(*function)(void);  /* this is operation */\n};\n</code></pre>\n<p>If I am mis-interpreting your question, Sergey L. has already answered the other interpretation.</p>\n", "LastActivityDate": "2014-05-07T13:39:03.090", "CommentCount": "2", "CreationDate": "2014-05-07T13:39:03.090", "ParentId": "23519074", "Score": "1", "OwnerUserId": "2659313"}, "bq_ids": {"n4140": {"so_23519074_23520450_1": {"length": 7, "quality": 0.6363636363636364, "section_id": 5988}, "so_23519074_23520450_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 6039}, "so_23519074_23520312_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 6126}}, "n3337": {"so_23519074_23520450_1": {"length": 6, "quality": 0.5454545454545454, "section_id": 5756}, "so_23519074_23520450_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5807}, "so_23519074_23520312_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 5890}}, "n4659": {"so_23519074_23520450_1": {"length": 7, "quality": 0.6363636363636364, "section_id": 7537}, "so_23519074_23520450_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 7538}, "so_23519074_23520312_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 7623}}}, "23520312": {"Id": "23520312", "PostTypeId": "2", "Body": "<p>Conversions between a function pointer and any other pointer type is outside the scope of the C standard. C only specifies what will happen when you cast between void* and a pointer to object type (6.3.2.3).</p>\n<p>Conversions between two different function pointers are allowed, as long as the types are compatible. If they aren't compatible, you are invoking undefined behavior (6.3.2.3/8).</p>\n<p>I believe C and C++ work exactly the same. The fact that C allows implicit conversions between void* and pointers to <em>object</em> is completely irrelevant to the question.</p>\n<hr>\n<p>So to answer your questions:</p>\n<blockquote>\n<p id=\"so_23519074_23520312_0\">why the pointer to function can be cast in this way?</p>\n</blockquote>\n<p>It cannot, unless you rely on non-standard extensions.</p>\n<blockquote>\n<p id=\"so_23519074_23520312_1\">Why does the first one work out and mine is wrong?</p>\n</blockquote>\n<p>The first one does not work unless you rely on non-standard extensions. </p>\n<p>The second one may or may not work, depending on function calling conventions on the specific system.</p>\n</hr>", "LastEditorUserId": "584518", "LastActivityDate": "2014-05-08T13:32:12.350", "Score": "1", "CreationDate": "2014-05-07T14:17:04.973", "ParentId": "23519074", "CommentCount": "1", "OwnerUserId": "584518", "LastEditDate": "2014-05-08T13:32:12.350"}, "23519074": {"ViewCount": "127", "Body": "<pre><code>#include &lt;stdio.h&gt;\n\nstruct A {\n  int data;             // this is data\n  void *(*function)();  // this is operation\n};\n\nvoid myfun1() {\n  printf(\"this is fun()\\n\");\n}\n\nint myfun2(int a) {\n  printf(\"this is fun(%d)\\n\", a);\n  return a;\n}\n\nchar myfun3(int a) {\n  printf(\"this is fun(%c)\\n\", a);\n  return a;\n}\n\nint main(void) {\n  struct A a;\n  a.function = (void *)myfun2;\n  a.function('a');\n\n  a.function = (void *)myfun3;\n  a.function('a');\n\n  return 0;\n</code></pre>\n<p>}</p>\n<p>I wonder why</p>\n<pre><code>a.function = (void *)myfun2; \n</code></pre>\n<p>Because I first thought it can be</p>\n<pre><code>a.function =(void *(*)())myfun2;\n</code></pre>\n<p>Why does the first one work out and mine is wrong?</p>\n", "Title": "why the pointer to function can be cast in this way?", "CreationDate": "2014-05-07T13:22:58.203", "LastActivityDate": "2014-05-08T13:32:12.350", "CommentCount": "0", "LastEditDate": "2014-05-07T13:27:14.177", "PostTypeId": "1", "LastEditorUserId": "176922", "Id": "23519074", "Score": "1", "OwnerUserId": "2870135", "Tags": "<c++><c>", "AnswerCount": "4"}});