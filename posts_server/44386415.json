post_cb({"44386415": {"ViewCount": "636", "FavoriteCount": "1", "AcceptedAnswerId": "44401707", "Title": "GCC and Clang disagree about C++17 constexpr lambda captures", "CreationDate": "2017-06-06T09:35:35.683", "LastActivityDate": "2017-06-07T18:24:07.587", "CommentCount": "4", "Body": "<p>Consider this example which declares a variable as constexpr, captures it by copy in a lambda, and declares another constexpr variable which is the result of a constexpr function unwrapping a non-type template parameter from the original variable.</p>\n<pre><code>#include &lt;utility&gt;\n\ntemplate&lt;int I&gt;\nconstexpr auto unwrap(std::integral_constant&lt;int, I&gt;) {\n  return I;\n}\n\nint main() {\n  constexpr auto i = std::integral_constant&lt;int, 42&gt;{};\n  constexpr auto l = [i]() {\n    constexpr int x = unwrap(i);\n  };\n}\n</code></pre>\n<p>Clang (trunk) accepts this code. (<a href=\"https://wandbox.org/permlink/2H7zezNFXdQdyaBz\" rel=\"noreferrer\">wandbox</a>)</p>\n<p>GCC (trunk) fails with the following error message (<a href=\"https://wandbox.org/permlink/oB7VEymVTfDQuxYG\" rel=\"noreferrer\">wandbox</a>):</p>\n<pre><code>lambda_capture.cpp:11:31: error: the value of \u2018i\u2019 is not usable in a constant expression\n     constexpr int x = unwrap(i);\n                               ^\nlambda_capture.cpp:10:28: note: \u2018i\u2019 was not declared \u2018constexpr\u2019\n   constexpr auto l = [i]() {\n</code></pre>\n<p>Which compiler is correct? It seems to me that this is a GCC bug, where the constexpr-ness of lambda captures is not correctly propagated to the lambda context.</p>\n", "PostTypeId": "1", "Id": "44386415", "Score": "17", "OwnerUserId": "1412888", "Tags": "<c++><lambda><c++1z>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_44386415_44401707_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 6185}}, "n4659": {"so_44386415_44401707_0": {"length": 12, "quality": 0.8571428571428571, "section_id": 7687}}}, "44401707": {"Id": "44401707", "PostTypeId": "2", "LastEditDate": "2017-06-07T17:05:07.987", "CommentCount": "2", "LastEditorUserId": "2756719", "LastActivityDate": "2017-06-07T17:05:07.987", "CreationDate": "2017-06-07T00:32:12.533", "ParentId": "44386415", "Score": "5", "Body": "<p>Both implementations are bugged, but I'm inclined to think that GCC got the right answer here.</p>\n<hr>\n<p>Dropping the capture of <code>i</code> causes Clang to refuse to compile the code. That means it clearly has a bug somewhere.</p>\n<p><a href=\"https://timsong-cpp.github.io/cppwp/expr.const#2.12\" rel=\"nofollow noreferrer\">[expr.const]/2.12</a>:</p>\n<blockquote>\n<p id=\"so_44386415_44401707_0\">An expression <code>e</code> is a core constant expression unless the evaluation\n  of <code>e</code>, following the rules of the abstract machine, would evaluate\n  one of the following expressions:</p>\n<ul>\n<li>[...]</li>\n<li>in a <em>lambda-expression</em>, a reference to [...] a variable with automatic storage duration defined outside that <em>lambda-expression</em>,\n  where the reference would be an odr-use;</li>\n<li>[...]</li>\n</ul>\n</blockquote>\n<p>Clang's behavior is schizophrenic: if the use of <code>i</code> in the body is not an odr-use, then it doesn't need to be captured, yet it rejects the code in the OP if the explicit capture is removed; OTOH, if it is an odr-use, then by the above <code>unwrap(i)</code> isn't a constant expression, and so it should reject the initialization of <code>x</code>.</p>\n<hr>\n<p>GCC's lambda implementation is woefully bad with respect to odr-use. It does constant-folding ultra-early, resulting in all kinds of subtle mischief. On the other hand, for explicit captures it transforms all uses, whether or not it's actually an odr-use. The aggressive constant folding means that it accepts OP's code if the capture of <code>i</code> is removed.</p>\n<p>Assuming that <code>unwrap(i)</code> does odr-use <code>i</code>, then it is correct that, per [expr.const]/2.12, OP's code is ill-formed.</p>\n<hr>\n<p>Does <code>unwrap(i)</code> actually odr-use <code>i</code>? That question <a href=\"https://timsong-cpp.github.io/cppwp/basic.def.odr#3.sentence-1\" rel=\"nofollow noreferrer\">boils down</a> to whether copy-initializing the parameter object of <code>unwrap</code> counts as applying an lvalue-to-rvalue conversion to <code>i</code>. I don't see anything in the standard that explicitly says that an lvalue-to-rvalue conversion is applied here, and instead <a href=\"https://timsong-cpp.github.io/cppwp/dcl.init#17.6.2\" rel=\"nofollow noreferrer\">[dcl.init]/17.6.2</a> indicates that we call a constructor (in this case, the trivial implicitly defined copy constructor) passing <code>i</code> as the argument bound to its parameter, and reference binding is a classic example of odr-use.</p>\n<p>To be sure, applying an l-to-r conversion would result in a copy-initialization of an <code>integral_constant&lt;int, 42&gt;</code> object from <code>i</code>, but the problem here is that nothing in the standard says the converse - that all copy-initializations of an <code>integral_constant&lt;int, 42&gt;</code> object from <code>i</code> count as l-to-r conversions.</p>\n</hr></hr></hr>", "OwnerUserId": "2756719"}});