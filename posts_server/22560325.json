post_cb({"22560325": {"ViewCount": "193", "Body": "<p>I tried to implement a simple tuple according to c++11 variadic templates feature like that:</p>\n<pre><code>template &lt;class Head, class... Tail&gt;\nclass tuple;\n\ntemplate &lt;class Head&gt;\nclass tuple&lt;Head&gt;\n{\npublic:\n    tuple(Head h) : m_h( h ) {}\n\n    tuple(tuple const &amp; rhs)\n    : m_h( rhs.m_h ) {}\n\n    template&lt;class T&gt;\n    tuple(tuple&lt;T&gt; const &amp; rhs)\n    : m_h( rhs.head() )\n    {}\n\n    Head head() const\n    {\n        return m_h;\n    }\nprivate:\n    Head m_h;\n};\n\ntemplate &lt;class Head, class... Tail&gt;\nclass tuple : private tuple&lt;Tail...&gt;\n{\npublic:\n    typedef tuple&lt;Tail...&gt; inherited;\n    tuple(Head h, Tail... tail)\n    : inherited(tail...), m_h( h )\n    {}\n\n    Head head() const\n    {\n        return m_h;\n    }\n\n    inherited &amp;\n    tail()\n    {\n        return *this;\n    }\n\n    inherited const &amp;\n    tail() const\n    {\n        return *this;\n    }\n\n    template&lt;typename... Values&gt;\n    tuple(tuple&lt;Values...&gt; const &amp; rhs)\n    : inherited( rhs.tail() ),\n      m_h( rhs.head() )\n167:    {}\nprivate:\n    Head m_h;\n};\n</code></pre>\n<p>And tried to use it as follows:</p>\n<pre><code>    tuple&lt;int, double, char&gt; tpl(0, 3.3, 'a');\n175:    tuple&lt;long, float, short&gt; tpl2 = tpl;\n</code></pre>\n<p>This resulted in:</p>\n<pre><code>test.cpp(167) : error C2664: 'tuple&lt;short,&gt;::tuple(const tuple&lt;short,&gt; &amp;)' : can not convert argument 1 from 'const tuple&lt;char,&gt;' to 'short'\nNo user-defined-conversion operator available that can perform this conversion, or the operator cannot be called\ntest.cpp(167) : see reference to function template instantiation 'tuple&lt;float,short&gt;::tuple&lt;double,char&gt;(const tuple&lt;double,char&gt; &amp;)' being compiled\ntest.cpp(167) : see reference to function template instantiation 'tuple&lt;float,short&gt;::tuple&lt;double,char&gt;(const tuple&lt;double,char&gt; &amp;)' being compiled\ntest.cpp(175) : see reference to function template instantiation 'tuple&lt;long,float,short&gt;::tuple&lt;int,double,char&gt;(const tuple&lt;int,double,char&gt; &amp;)' being compiled\ntest.cpp(175) : see reference to function template instantiation 'tuple&lt;long,float,short&gt;::tuple&lt;int,double,char&gt;(const tuple&lt;int,double,char&gt; &amp;)' being compiled\n</code></pre>\n<p>with Visual Studio 2013 and in:</p>\n<pre><code>c:\\Users\\achernyaev\\Documents\\test.cpp: In function 'int main()':\nc:\\Users\\achernyaev\\Documents\\test.cpp:175:35: error: conversion from 'tuple&lt;int,double, char&gt;' to non-scalar type 'tuple&lt;long int, float, short int&gt;' requested tuple&lt;long,float,short&gt; tpl2 = tpl;\n                              ^\n</code></pre>\n<p>with MinGW's g++ 4.8.1</p>\n<p>Question: Is this code really malformed or maybe this feature isn't supported good enough yet?</p>\n<p>Best regards, Alexander.</p>\n", "AcceptedAnswerId": "22560510", "Title": "Do variadic templates work correctly with current compilers?", "CreationDate": "2014-03-21T13:36:27.967", "LastActivityDate": "2014-03-21T18:31:43.077", "CommentCount": "6", "LastEditDate": "2014-03-21T13:57:04.600", "PostTypeId": "1", "Tags": "<c++><c++11><g++><visual-studio-2013><mingw>", "Id": "22560325", "AnswerCount": "2", "Score": "1", "OwnerUserId": "1466198", "ClosedDate": "2014-03-21T19:36:13.433", "LastEditorUserId": "1466198"}, "bq_ids": {"n4140": {"so_22560325_22566565_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 341}, "so_22560325_22566565_1": {"length": 8, "quality": 1.0, "section_id": 341}, "so_22560325_22566565_2": {"length": 8, "quality": 1.0, "section_id": 341}}, "n3337": {"so_22560325_22566565_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 331}, "so_22560325_22566565_1": {"length": 8, "quality": 1.0, "section_id": 331}, "so_22560325_22566565_2": {"length": 8, "quality": 1.0, "section_id": 331}}, "n4659": {"so_22560325_22566565_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 350}, "so_22560325_22566565_1": {"length": 8, "quality": 1.0, "section_id": 350}, "so_22560325_22566565_2": {"length": 8, "quality": 1.0, "section_id": 350}}}, "22566565": {"Id": "22566565", "PostTypeId": "2", "Body": "<p>Deduction fails for your converting constructor:</p>\n<pre><code>template&lt;typename... Values&gt;\ntuple(tuple&lt;Values...&gt; const &amp; rhs)\n: inherited( rhs.tail() ),\n  m_h( rhs.head() )\n{}\n</code></pre>\n<p>but succeeds when defined as:</p>\n<pre><code>template&lt;typename H, typename... T&gt;\ntuple(tuple&lt;H, T...&gt; const &amp; rhs)\n: inherited( rhs.tail() ),\n  m_h( rhs.head() )\n{}\n</code></pre>\n<p>I believe deduction fails when trying to match the parameter pack <code>Values</code> up with the non-pack parameter <code>Head</code> of the <code>tuple</code> template, per C++11 \u00a714.8.2.5 [temp.deduct.type]/10:</p>\n<blockquote>\n<p id=\"so_22560325_22566565_0\">If the parameter-declaration corresponding to P<sub>i</sub> is a function parameter pack, then the type of its declarator-id is compared with each remaining parameter type in the parameter-type-list of A. Each comparison deduces template arguments for subsequent positions in the template parameter packs expanded by the function parameter pack. During partial ordering (14.8.2.4), if A<sub>i</sub> was originally a function parameter pack:</p>\n<ul>\n<li><p id=\"so_22560325_22566565_1\">if P does not contain a function parameter type corresponding to A<sub>i</sub> then A<sub>i</sub> is ignored;</p></li>\n<li><p id=\"so_22560325_22566565_2\">otherwise, if P<sub>i</sub> is not a function parameter pack, template argument deduction fails.</p></li>\n</ul>\n</blockquote>\n<p>In any case, you could simplify the class by making the empty tuple the base case for the recursion, and defining the whole shebang as:</p>\n<pre><code>template &lt;class...&gt; class tuple {};\n\ntemplate &lt;class Head, class... Tail&gt;\nclass tuple&lt;Head, Tail...&gt; : private tuple&lt;Tail...&gt;\n{\npublic:\n    typedef tuple&lt;Tail...&gt; inherited;\n\n    tuple(Head h, Tail... tail)\n    : inherited(tail...), m_h( h )\n    {}\n\n    Head head() const\n    {\n        return m_h;\n    }\n\n    inherited &amp;\n    tail()\n    {\n        return *this;\n    }\n\n    inherited const &amp;\n    tail() const\n    {\n        return *this;\n    }\n\n    template&lt;typename... T&gt;\n    tuple(tuple&lt;T...&gt; const &amp; rhs)\n    : inherited( rhs.tail() ),\n      m_h( rhs.head() )\n    {}\n\nprivate:\n    Head m_h;\n};\n</code></pre>\n", "LastEditorUserId": "923854", "LastActivityDate": "2014-03-21T18:31:43.077", "Score": "0", "CreationDate": "2014-03-21T18:18:24.377", "ParentId": "22560325", "CommentCount": "0", "OwnerUserId": "923854", "LastEditDate": "2014-03-21T18:31:43.077"}, "22560510": {"Id": "22560510", "PostTypeId": "2", "Body": "<p>There are several mistake in the code: Here is a corrected one:</p>\n<pre><code>template &lt;class ...&gt; class tuple; // declaration as a multivariate template.\n\ntemplate &lt;class Head&gt;\nclass tuple&lt;Head&gt;\n{\nprivate:\n    Head m_h; \npublic:\n    tuple(Head h) : m_h( h ) {}\n\n    tuple(tuple const &amp; rhs)\n    : m_h( rhs.m_h ) {}\n\n    template&lt;class T&gt;\n    tuple(tuple&lt;T&gt; const &amp; rhs)\n    : m_h( rhs.head() )\n    {}\n\n    Head head() const\n    {\n        return m_h;\n    }\n};\n\ntemplate &lt;class Head, class... Tail&gt;\nclass tuple&lt;Head, Tail...&gt; : // explicitly write the partial specialization. \n   private tuple&lt;Tail...&gt; \n{\nprivate:\n    Head m_h;\n\n    typedef tuple&lt;Tail...&gt; inherited;\n    tuple(Head h, Tail... tail)\n    : inherited(tail...), m_h( h )\n    {}\n\n    Head head() const\n    {\n        return m_h;\n    }\n\n    inherited &amp;\n    tail()\n    {\n        return *this;\n    }\n\n    inherited const &amp;\n    tail() const\n    {\n        return *this;\n    }\n\n    template&lt;typename... Values&gt;\n    tuple(tuple&lt;Values...&gt; const &amp; rhs)\n    : inherited( rhs.tail() ),\n      m_h( rhs.head() )    {}\n};\n</code></pre>\n", "LastEditorUserId": "1692107", "LastActivityDate": "2014-03-21T14:03:10.860", "Score": "2", "CreationDate": "2014-03-21T13:43:51.573", "ParentId": "22560325", "CommentCount": "4", "OwnerUserId": "1692107", "LastEditDate": "2014-03-21T14:03:10.860"}});