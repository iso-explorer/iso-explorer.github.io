post_cb({"37826750": {"ParentId": "37818028", "CommentCount": "5", "Body": "<blockquote>\n<p id=\"so_37818028_37826750_0\"><strong>[conv.fpint]/1</strong> A prvalue of a floating point type can be converted to a prvalue of an integer type. The conversion truncates; that is, the fractional part is discarded. <strong>The behavior is undefined if the truncated value cannot be\n  represented in the destination type.</strong></p>\n</blockquote>\n<p>Emphasis mine. Since the behavior is undefined, any outcome whatsoever is correct.</p>\n", "OwnerUserId": "1670129", "PostTypeId": "2", "Id": "37826750", "Score": "0", "CreationDate": "2016-06-15T05:22:09.390", "LastActivityDate": "2016-06-15T05:22:09.390"}, "bq_ids": {"n4140": {"so_37818028_37826750_0": {"section_id": 37, "quality": 0.88, "length": 22}}, "n3337": {"so_37818028_37826750_0": {"section_id": 34, "quality": 0.88, "length": 22}}, "n4659": {"so_37818028_37826750_0": {"section_id": 37, "quality": 0.8, "length": 20}}}, "37818028": {"CommentCount": "2", "ViewCount": "76", "PostTypeId": "1", "LastEditorUserId": "5801492", "CreationDate": "2016-06-14T16:57:19.623", "LastActivityDate": "2016-06-17T07:12:43.700", "Title": "casting double to signed vs unsigned integer", "AcceptedAnswerId": "37826750", "LastEditDate": "2016-06-17T07:12:43.700", "Id": "37818028", "Score": "-2", "Body": "<p>It seem that the MSVC Compiler treats signed and unsigned overflow differnetly. When casting a double value that exceeds the maximum integer value, the result is the smallest possible integer value (always the same). When casting to unsigned int, the cast produces an overflow as expected (maximum unsigned int value + 1 produces 0, maximum unsigned int + 2 produces 1, ...)\nCan someone explain the behaviour of the compiler, or is it a bug?</p>\n<p>Tested compilers MSVC 10 and 14</p>\n<pre><code>#define BOOST_TEST_MODULE Tests\n#include &lt;boost/test/unit_test.hpp&gt;\n#include &lt;climits&gt;\n#include &lt;iostream&gt;\nBOOST_AUTO_TEST_CASE(test_overflow_signed) {\n  double d_int_max_1 = INT_MAX + 1.; //2147483647 + 1\n  double d_int_max_2 = INT_MAX + 2.; //2147483647 + 2\n\n  BOOST_CHECK((int)(2147483648.) != (int)(2147483649.)); //succeeds (overflows to -2147483648 and -2147483647)\n  BOOST_CHECK((int)(d_int_max_1) != (int)(d_int_max_2)); //fails (both values overflow to -2147483648)\n  std::cout &lt;&lt; \"(int)(2147483648.) == \" &lt;&lt; (int)(2147483648.) &lt;&lt; std::endl; //-2147483648\n  std::cout &lt;&lt; \"(int)(2147483649.) == \" &lt;&lt; (int)(2147483649.) &lt;&lt; std::endl; //-2147483647\n  std::cout &lt;&lt; \"(int)(d_int_max_1) == \" &lt;&lt; (int)(d_int_max_1) &lt;&lt; std::endl; //-2147483648\n  std::cout &lt;&lt; \"(int)(d_int_max_2) == \" &lt;&lt; (int)(d_int_max_2) &lt;&lt; std::endl; //-2147483648\n}\n\nBOOST_AUTO_TEST_CASE(test_overflow_unsigned) {\n  double d_int_max_1 = UINT_MAX + 1.;//4294967295 + 1\n  double d_int_max_2 = UINT_MAX + 2.;//4294967295 + 2\n  //BOOST_CHECK((unsigned int)(4294967296.) != (unsigned int)(4294967297.)); //compiler fails (!= truncation of constant value)\n  BOOST_CHECK((unsigned int)(d_int_max_1) != (unsigned int)(d_int_max_2)); //succeeds (overflows to 0 and 1)\n  std::cout &lt;&lt; \"(unsigned int)(d_int_max_1) == \" &lt;&lt; (unsigned int)(d_int_max_1) &lt;&lt; std::endl; //0\n  std::cout &lt;&lt; \"(unsigned int)(d_int_max_2) == \" &lt;&lt; (unsigned int)(d_int_max_2) &lt;&lt; std::endl; //1\n}\n</code></pre>\n", "Tags": "<visual-studio-2010><visual-c++>", "OwnerUserId": "5801492", "AnswerCount": "1"}});