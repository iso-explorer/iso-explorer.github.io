post_cb({"20888009": {"ViewCount": "413", "Body": "<p>This is related to the <a href=\"https://stackoverflow.com/questions/4763067/difference-between-cout-x-and-cout-operator-x\">difference-between-cout-x-and-cout-operator-x</a> question, but still a little different...</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main(){\n    std::cout &lt;&lt; \"hello\" &lt;&lt; std::endl;\n\n    std::cout.operator&lt;&lt;(\"hello2\");\n    std::cout.operator&lt;&lt;(std::endl);\n\n    operator&lt;&lt;(std::cout, \"hello3\");\n//    operator&lt;&lt;(std::cout, std::endl);\n\n    return 0;\n}\n</code></pre>\n<h2>Q1: Why does <code>std::cout.operator&lt;&lt;(\"hello2\");</code> work?</h2>\n<p>From <a href=\"https://stackoverflow.com/questions/4763067/difference-between-cout-x-and-cout-operator-x\">other answers</a> on SO I would expect the compiler to complain since <code>operator&lt;&lt;</code> is meant to be a free function and not a member of <code>cout</code>. On my system, however, it prints \"0x10d54df31\". And, stranger yet, the following line correctly correctly executes <code>std::endl</code>.</p>\n<h2>Q2: Why does <code>operator&lt;&lt;(std::cout, std::endl);</code> not work?</h2>\n<p>I know that <code>std::endl</code> is a function, but it seems strange (to me) that the hello3 output works whilst the `std::endl' doesn't. Instead the compiler throws an error:</p>\n<pre><code>main.cpp:10:4: error: no matching function for call to 'operator&lt;&lt;'\n    operator&lt;&lt;(std::cout, std::endl);\n</code></pre>\n<h2>Q3: How can the first <code>std::cout &lt;&lt; \"hello1\" &lt;&lt; std::endl;</code> be written in <code>operator&lt;&lt;(...)</code> form?</h2>\n<p>If the first two questions have been answered, then this has probably already covered. It's the point of this learning exercise, so seems sensible to ask it explicitly.</p>\n", "AcceptedAnswerId": "20888151", "Title": "Difference between `cout << x` and `cout.operator<<(x)` and `operator(std::cout, x)`?", "CreationDate": "2014-01-02T17:12:23.680", "Id": "20888009", "CommentCount": "4", "LastEditDate": "2017-05-23T10:25:30.707", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2014-01-02T17:48:26.063", "Score": "0", "OwnerUserId": "760589", "Tags": "<c++><operator-overloading><cout>", "AnswerCount": "4"}, "20888148": {"Id": "20888148", "PostTypeId": "2", "Body": "<p>Some overloads of <code>operator&lt;&lt;</code> are class members, others are not.</p>\n<p>In C++03 this created some baffling call scenarios since a reference to non-<code>const</code> (argument of the not-member) can't be bound to an rvalue, but in C++11 at least one such has been fixed by introducing an rvalue reference argument overload.</p>\n<p>So, which calls compile or not depends more in general also on the C++ standards version, C++03 or C++11.</p>\n", "LastActivityDate": "2014-01-02T17:20:40.900", "CommentCount": "2", "CreationDate": "2014-01-02T17:20:40.900", "ParentId": "20888009", "Score": "1", "OwnerUserId": "464581"}, "20888555": {"Id": "20888555", "PostTypeId": "2", "Body": "<p>Your questions can be broken down to member functions an non-member functions.</p>\n<p>Having 13.5.2 Binary operators</p>\n<blockquote>\n<p id=\"so_20888009_20888555_0\">A binary operator shall be implemented\n  either by a non-static member function (9.3) with one parameter or by\n  a non-member function with two parameters. Thus, for any binary\n  operator @, x@y can be interpreted as either x.operator@(y) or\n  operator@(x,y). If both forms of the operator function have been\n  declared, the rules in 13.3.1.2 determine which, if  any,\n  interpretation is used.</p>\n</blockquote>\n<p>Omitting a quote of 13.3.1.2 the member function (operator) is preferred.</p>\n<p>The line 'std::cout &lt;&lt; \"hello\" &lt;&lt; std::endl;' involves non member functions. Each 'std::cout.operator' is an explicit member function call.</p>\n<ul>\n<li>Q1 is the member operator&lt;&lt;(const void*) </li>\n<li>Q2 there is no member taking a function </li>\n<li>Q3 It is not possible</li>\n</ul>\n", "LastEditorUserId": "2249683", "LastActivityDate": "2014-01-02T17:48:26.063", "Score": "1", "CreationDate": "2014-01-02T17:41:53.103", "ParentId": "20888009", "CommentCount": "0", "OwnerUserId": "2249683", "LastEditDate": "2014-01-02T17:48:26.063"}, "bq_ids": {"n4140": {"so_20888009_20888555_0": {"length": 30, "quality": 0.9375, "section_id": 659}}, "n3337": {"so_20888009_20888555_0": {"length": 30, "quality": 0.9375, "section_id": 649}}, "n4659": {"so_20888009_20888555_0": {"length": 30, "quality": 0.9375, "section_id": 687}}}, "20888151": {"Id": "20888151", "PostTypeId": "2", "Body": "<p>Operators can be implemented in different ways, in particular an <code>operator&lt;&lt;</code> for which the left hand side is your type can be implemented as either a free function or as a member function of that left hand side type.</p>\n<p>While you must implement <code>ostream&amp; operator&lt;&lt;(ostream&amp;, MyType const&amp;)</code> as a free function (since <code>MyType</code> is not the left hand side), the library implementation can choose<sup>*</sup> to implement <code>operator&lt;&lt;</code> for some fundamental types insde the <code>std::ostream</code> type (which is really a particular instantiation of a template, I am trying to ignore the details).</p>\n<p>Edit: After checking with the standard this is incorrect:</p>\n<p><strike>This is what you are noticing in the code, the overload that takes a <code>const char*</code> is implemented as a member of <code>ostream</code> (<code>basic_ostream&lt;char,char_traits&lt;char&gt;</code>).</strike></p>\n<p>The overloads taking manipulators are implemented as member functions (Q2), and there is an implicit conversion from <code>const char*</code> to <code>const void*</code> that will be picked if you use the syntax for explicitly calling a member operator (Q1). For Q3, the answer would be:</p>\n<pre><code>operator&lt;&lt;(std::cout, \"Hello\").operator&lt;&lt;(std::endl);\n</code></pre>\n<p><sup>*</sup> The implementation is actually not <em>free</em> to choose, since the standard mandates the signatures.</p>\n", "LastEditorUserId": "36565", "LastActivityDate": "2014-01-02T17:26:35.930", "Score": "3", "CreationDate": "2014-01-02T17:20:50.207", "ParentId": "20888009", "CommentCount": "9", "OwnerUserId": "36565", "LastEditDate": "2014-01-02T17:26:35.930"}, "20888166": {"Id": "20888166", "PostTypeId": "2", "Body": "<p>There is a bunch of member output operators defined in <code>std::ostream</code>. In retrospect that was probably an error but when IOStreams were first created I think it was actually necessary. These member operators include the overloads taking function pointers which means you'll need to use member notation for those. The operators using C-strings are non-member overloads, i.e., you need to use the non-member function call notation to get the C-string overload. When you call the member operator with a <code>char const*</code> the <code>char const*</code> will be converted to <code>void const*</code> for which there is a member output operator.</p>\n", "LastActivityDate": "2014-01-02T17:21:25.643", "CommentCount": "2", "CreationDate": "2014-01-02T17:21:25.643", "ParentId": "20888009", "Score": "1", "OwnerUserId": "1120273"}});