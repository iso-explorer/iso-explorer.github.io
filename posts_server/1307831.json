post_cb({"bq_ids": {"n4140": {"so_1307831_1307866_1": {"length": 15, "quality": 0.5555555555555556, "section_id": 5768}}, "n3337": {"so_1307831_1307866_1": {"length": 15, "quality": 0.5555555555555556, "section_id": 5541}}, "n4659": {"so_1307831_1307866_1": {"length": 15, "quality": 0.5555555555555556, "section_id": 7225}}}, "1307831": {"ViewCount": "426", "Body": "<p>I've looked at the standard and didn't see an obvious answer.</p>\n<p>suppose i've done this:</p>\n<pre><code>std::istream_iterator&lt;char&gt; is(file);\nwhile(is != std::istream_iterator&lt;char&gt;()) {\n    ++is;\n}\n</code></pre>\n<p>now <code>is</code> is at the end of the stream and is equal to <code>std::istream_iterator&lt;char&gt;()</code>. What happens if I increment it one more time? Is it still equal to <code>std::istream_iterator&lt;char&gt;()</code>? or os the result undefined?</p>\n<p>The standard explicitly states that <code>*is</code> is undefined behavior if <code>is</code> is at the end of the stream. But I haven't seen anything regarding iterating beyond the end of the stream...</p>\n<p><strong>EDIT</strong>:</p>\n<p>I ask because I stumbled across some code which does something like this:</p>\n<pre><code>// skip 2 input chars\n++is;\n++is;\nif(is != std::istream_iterator&lt;char&gt;()) {\n    // continue using is and do some work...but what if the first\n    // increment made it EOS? is this check valid?\n}\n</code></pre>\n", "AcceptedAnswerId": "1309207", "Title": "what is the result of incrementing an istream_iterator which is already at the end of the stream?", "CreationDate": "2009-08-20T17:55:45.003", "Id": "1307831", "CommentCount": "2", "LastEditDate": "2009-08-20T18:05:32.300", "PostTypeId": "1", "LastEditorUserId": "13430", "LastActivityDate": "2009-08-20T23:08:42.063", "Score": "0", "OwnerUserId": "13430", "Tags": "<c++><istream><istream-iterator>", "AnswerCount": "2"}, "1307866": {"Id": "1307866", "PostTypeId": "2", "Body": "<p>If it isn't defined, it is undefined :-)  In the standard (latest draft of C++0X) words, emphasis is mine:</p>\n<blockquote>\n<p id=\"so_1307831_1307866_0\">undefined behavior</p>\n<p id=\"so_1307831_1307866_1\">behavior, such as might arise upon use of an erroneous program construct or erroneous data,\n  for which\n  this International Standard imposes no requirements. <strong>Undefined behavior may also be expected\n  when this\n  International Standard omits the description of any explicit definition of behavior.</strong></p>\n</blockquote>\n", "LastEditorUserId": "136208", "LastActivityDate": "2009-08-20T18:07:55.760", "Score": "3", "CreationDate": "2009-08-20T18:01:41.387", "ParentId": "1307831", "CommentCount": "5", "LastEditDate": "2009-08-20T18:07:55.760", "OwnerUserId": "136208"}, "1309207": {"Id": "1309207", "PostTypeId": "2", "Body": "<p>Table 72 in C++03 about input iterator requirements says that the pre-condition of <code>++r</code> is that <code>r</code> is de-referenceable. The same pre-conditions holds for <code>r++</code>. </p>\n<p>Now, <code>24.5.1/1</code> says about <code>istream_iterator</code></p>\n<blockquote>\n<p id=\"so_1307831_1309207_0\">The result of <code>operator*</code> on an end of stream is not defined.</p>\n</blockquote>\n<p>In conclusion, the effects of <code>operator++</code> on an end-of-stream iterator are undefined. </p>\n<p>Table 72 in C++03 about input iterator requirements says that the pre-condition of <code>++r</code> is that <code>r</code> is de-referenceable. The same pre-conditions holds for <code>r++</code>. </p>\n<p>Now, <code>24.5.1/1</code> says about <code>istream_iterator</code></p>\n<blockquote>\n<p id=\"so_1307831_1309207_1\">The result of <code>operator*</code> on an end of stream is not defined.</p>\n</blockquote>\n<p>In conclusion, the effects of <code>operator++</code> on an end-of-stream iterator are undefined. </p>\n<hr>\n<p>Note that I think this conclusion makes behavior undefined only when you write or use an algorithm taking input iterators which exhibits that behavior, and then pass an istream iterator. From only <em>using</em> the istream iterator itself explicitly, without treating it as an input iterator and relying on its invariants, then i think the conclusion above isn't quite right (we may have a class that doesn't require that <code>r</code> is dereferenceable, for example).</p>\n<p>But looking at how istream iterator is described, an invocation of <code>operator++</code> after reaching the end of stream value results in undefined behavior either. <code>operator==</code> for it is defined as being equivalent to</p>\n<pre><code>x.in_stream == y.in_stream\n</code></pre>\n<p>Where <code>in_stream</code> is a pointer to the stream iterated over - and exposed into the Standard text for defining behavior and semantics \"exposition only\". Now, the only implementation i can think of that makes this work, is using an end-of-stream iterator that stores as stream pointer a null pointer. But <code>operator++</code> is defined as doing something having the effect of the following</p>\n<pre><code>*in_stream &gt;&gt;value\n</code></pre>\n<p>Now, if you enter the end-of-stream state, and we would set <code>in_stream</code> to a null pointer, then surely the effect of that would be undefined behavior. </p>\n<p>So even if you use the istream iterator alone, there doesn't seem to be any guarantee that you may increment past the end-of-stream value. </p>\n</hr>", "LastEditorUserId": "34509", "LastActivityDate": "2009-08-20T23:08:42.063", "Score": "4", "CreationDate": "2009-08-20T22:37:24.263", "ParentId": "1307831", "CommentCount": "5", "LastEditDate": "2009-08-20T23:08:42.063", "OwnerUserId": "34509"}});