post_cb({"bq_ids": {"n4140": {"so_49146508_49146691_1": {"length": 14, "quality": 0.7368421052631579, "section_id": 3163}, "so_49146508_49146691_5": {"length": 22, "quality": 0.9565217391304348, "section_id": 3163}, "so_49146508_49146691_0": {"length": 4, "quality": 0.8, "section_id": 3163}, "so_49146508_49146691_2": {"length": 16, "quality": 0.8, "section_id": 3163}, "so_49146508_49146691_4": {"length": 18, "quality": 0.9473684210526315, "section_id": 3163}, "so_49146508_49146691_3": {"length": 4, "quality": 1.0, "section_id": 3163}}, "n3337": {"so_49146508_49146691_1": {"length": 14, "quality": 0.7368421052631579, "section_id": 3036}, "so_49146508_49146691_5": {"length": 22, "quality": 0.9565217391304348, "section_id": 3036}, "so_49146508_49146691_2": {"length": 16, "quality": 0.8, "section_id": 3036}, "so_49146508_49146691_0": {"length": 4, "quality": 0.8, "section_id": 3036}, "so_49146508_49146691_4": {"length": 18, "quality": 0.9473684210526315, "section_id": 3036}, "so_49146508_49146691_3": {"length": 4, "quality": 1.0, "section_id": 3036}}, "n4659": {"so_49146508_49146691_1": {"length": 14, "quality": 0.7368421052631579, "section_id": 3925}, "so_49146508_49146691_5": {"length": 22, "quality": 0.9565217391304348, "section_id": 3925}, "so_49146508_49146691_2": {"length": 16, "quality": 0.8, "section_id": 3925}, "so_49146508_49146691_0": {"length": 4, "quality": 0.8, "section_id": 3925}, "so_49146508_49146691_4": {"length": 18, "quality": 0.9473684210526315, "section_id": 3925}, "so_49146508_49146691_3": {"length": 4, "quality": 1.0, "section_id": 3925}}}, "49146508": {"ViewCount": "32", "Body": "<p>It's said that <a href=\"http://en.cppreference.com/w/cpp/thread/thread/join\" rel=\"nofollow noreferrer\"><code>thread::join()</code></a> synchronizes-with completion of the corresponding thread of execution. I'm wondering whether the same applies to <code>async()</code> and <code>future::wait()</code>. So for example:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>std::atomic_int v(0);\nstd::async(\n  std::launch::async,\n  [&amp;v] { v.fetch_add(1, std::memory_order_relaxed); }\n).wait();\nassert(v.load(std::memory_order_relaxed) == 1);\n</code></pre>\n<p>The <code>assert()</code> will never fail.</p>\n", "AcceptedAnswerId": "49146691", "Title": "Does future::wait() synchronize-with completion of the thread of execution by async()?", "CreationDate": "2018-03-07T07:37:58.640", "Id": "49146508", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2018-03-07T07:50:12.070", "Score": "3", "OwnerUserId": "1348273", "Tags": "<c++><c++11><synchronization><atomic><memory-model>", "AnswerCount": "1"}, "49146691": {"Id": "49146691", "PostTypeId": "2", "Body": "<p>Straight from N3337 (<a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b11\" rel=\"tag\" title=\"show questions tagged 'c++11'\">c++11</a> standard draft), <a href=\"https://timsong-cpp.github.io/cppwp/n3337/futures.async#5\" rel=\"nofollow noreferrer\">[futures.async]/5</a> with my emphasis:</p>\n<blockquote>\n<p id=\"so_49146508_49146691_0\"><em>Synchronization</em>: Regardless of the provided policy argument,</p>\n<ul>\n<li><p id=\"so_49146508_49146691_1\">the invocation of async synchronizes with ([intro.multithread]) the invocation of f. [ Note: This statement applies even when the\n  corresponding future object is moved to another thread.  \u2014 end note ];\n  and</p></li>\n<li><p id=\"so_49146508_49146691_2\"><strong>the completion of the function f is sequenced before</strong> ([intro.multithread]) <strong>the shared state is made ready</strong>. [ Note: f might\n  not be called at all, so its completion might never happen.  \u2014 end\n  note ]</p></li>\n</ul>\n<p id=\"so_49146508_49146691_3\">If the implementation chooses the <code>launch::async</code> policy,</p>\n<ul>\n<li><p id=\"so_49146508_49146691_4\"><strong>a call to a waiting function on an asynchronous return object that shares the shared state created by this async call shall block until\n  the associated thread has completed, as if joined</strong>\n  ([thread.thread.member]);</p></li>\n<li><p id=\"so_49146508_49146691_5\">the associated thread completion synchronizes with ([intro.multithread]) the return from the first function that\n  successfully detects the ready status of the shared state or with the\n  return from the last function that releases the shared state,\n  whichever happens first.</p></li>\n</ul>\n</blockquote>\n<p>So referring to your question this means that yes, the assertion will never fail.</p>\n", "LastActivityDate": "2018-03-07T07:50:12.070", "CommentCount": "1", "CreationDate": "2018-03-07T07:50:12.070", "ParentId": "49146508", "Score": "3", "OwnerUserId": "817643"}});