post_cb({"42076314": {"CommentCount": "1", "AcceptedAnswerId": "42076537", "PostTypeId": "1", "LastEditorUserId": "3233393", "CreationDate": "2017-02-06T20:04:32.850", "LastActivityDate": "2017-02-06T23:04:44.303", "LastEditDate": "2017-02-06T23:04:44.303", "ViewCount": "1172", "FavoriteCount": "3", "Title": "Why this ADL case is working?", "Id": "42076314", "Score": "19", "Body": "<p>How does <code>find_type</code> know where the function <code>typemap</code> is?<br>\nThe argument it receives is not from that namespace, it's from the <code>std</code> namespace!</br></p>\n<pre><code>#include &lt;type_traits&gt;\n#include &lt;memory&gt;\n\nnamespace lib {\n    template&lt;typename T&gt;\n    struct find_type {\n        using type = decltype(typemap(std::declval&lt;T&gt;()));\n    };\n}\n\nnamespace test {\n    struct Test {};\n    auto typemap(std::unique_ptr&lt;Test&gt;) -&gt; int;    \n}\n\nstatic_assert(std::is_same&lt;int, lib::find_type&lt;std::unique_ptr&lt;test::Test&gt;&gt;::type&gt;::value, \"\");\n</code></pre>\n<p>How can this code work? What is the rule allowing this?</p>\n<p>I tested it with GCC 6.3 and clang 3.9.1.</p>\n", "Tags": "<c++><c++11><language-lawyer><argument-dependent-lookup>", "OwnerUserId": "2104697", "AnswerCount": "2"}, "42076581": {"ParentId": "42076314", "CommentCount": "0", "CreationDate": "2017-02-06T20:21:02.573", "OwnerUserId": "560648", "PostTypeId": "2", "Id": "42076581", "Score": "14", "Body": "<blockquote>\n<p id=\"so_42076314_42076581_0\">The argument it receives is not from that namespace, it's from the std namespace!</p>\n</blockquote>\n<p>Not all of it!</p>\n<pre><code>using type = decltype(typemap(std::declval&lt;T&gt;()));\n</code></pre>\n<p>This is:</p>\n<pre><code>using type = decltype(typemap(std::declval&lt;std::unique_ptr&lt;test::Test&gt;&gt;()));\n</code></pre>\n<p>There's a <code>test::</code> in there, so the namespace <code>test</code> is searched too.</p>\n", "LastActivityDate": "2017-02-06T20:21:02.573"}, "42076537": {"ParentId": "42076314", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-02-06T20:18:22.850", "Score": "19", "LastEditorUserId": "1639256", "LastEditDate": "2017-02-06T22:31:58.213", "Id": "42076537", "OwnerUserId": "5632316", "Body": "<p>In the C++ standard N4618 \u00a73.4.2 [basic.lookup.argdep] (2.2)</p>\n<blockquote>\n<p id=\"so_42076314_42076537_0\">If T is a class type (including unions), its associated classes are: the class itself; the class of which it is\n  a member, if any; and its direct and indirect base classes. Its associated namespaces are the innermost\n  enclosing namespaces of its associated classes. Furthermore, if T is a class template specialization,\n  its associated namespaces and classes also include: <strong>the namespaces and classes associated with the\n  types of the template arguments provided for template type parameters</strong> (excluding template template\n  parameters); the namespaces of which any template template arguments are members; and the classes\n  of which any member templates used as template template arguments are members.</p>\n</blockquote>\n<p>The argument of <code>typemap</code> is <code>std::unique_ptr&lt;test::Test&gt;</code>, so namespace <code>test</code> is considered for name look up.</p>\n", "LastActivityDate": "2017-02-06T22:31:58.213"}, "bq_ids": {"n4140": {"so_42076314_42076537_0": {"section_id": 7104, "quality": 1.0, "length": 61}, "so_42076314_42076581_0": {"section_id": 7092, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_42076314_42076537_0": {"section_id": 6848, "quality": 0.9672131147540983, "length": 59}, "so_42076314_42076581_0": {"section_id": 6836, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_42076314_42076537_0": {"section_id": 8605, "quality": 1.0, "length": 61}, "so_42076314_42076581_0": {"section_id": 8605, "quality": 0.5714285714285714, "length": 4}}}});