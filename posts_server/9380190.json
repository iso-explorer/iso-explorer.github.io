post_cb({"9380413": {"ParentId": "9380190", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Example 1 is working because the functor object (v1) has a member variable (n) which is incremented every time the object is called.</p>\n<p>Example 2 is different in that the functor object (v1) only updates a reference to a variable which lives outside the object.</p>\n<p>Example 1 is a better object-oriented design because each object of class g that you create will take care of its own counting, while in example 2, it is the caller's responsibility to make sure that the counter is not shared and has at least the same lifespan than the functor object.</p>\n", "OwnerUserId": "11441", "LastEditorUserId": "11441", "LastEditDate": "2012-02-25T17:26:58.637", "Id": "9380413", "Score": "0", "CreationDate": "2012-02-21T15:40:52.637", "LastActivityDate": "2012-02-25T17:26:58.637"}, "9380472": {"ParentId": "9380190", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The generate function takes one instance of the functor and calls it over and over again. So The state preservation is the same as in each normal class. I stripped (and simplified) this out of my compilers (gcc 4.5) headers:</p>\n<pre><code>template&lt;typename _ForwardIterator, typename _Generator&gt;\nvoid\ngenerate(_ForwardIterator __first, _ForwardIterator __last,\n         _Generator __gen)\n{\n  // concept requirements -- ommitted for easy reading\n  for (; __first != __last; ++__first)\n    *__first = __gen();\n}\n</code></pre>\n<p>As you can see __gen will be one instance of your functor in your examples.</p>\n<p>Note that my compiler optimized your first example so no copy construction was made. When using a named variable instead the copy construction took place.</p>\n", "OwnerUserId": "760746", "LastEditorUserId": "760746", "LastEditDate": "2012-02-21T15:53:19.053", "Id": "9380472", "Score": "0", "CreationDate": "2012-02-21T15:44:25.557", "LastActivityDate": "2012-02-21T15:53:19.053"}, "9380451": {"ParentId": "9380190", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>It's depending on behavior that's common, but not guaranteed. Specifically, it's counting on the fact that <code>generate</code> will re-invoke the function object for every value assigned, something like this:</p>\n<pre><code>template &lt;class FwdIt, class Generator&gt;\nvoid generate(FwdIt first, FwdIt last, Generator gen) {\n    while (first != last) {\n        *first = gen();\n        ++first;\n    }\n}\n</code></pre>\n<p>I believe the standard allows that, but I'm quite sure it doesn't guarantee it. At least by my reading of the standard, it would be entirely acceptable for it to do something on this general order instead:</p>\n<pre><code>template &lt;class FwdIt, class Generator&gt;\nvoid generate(FwdIt first, FwdIt last, Generator gen) {\n    decltype(*first) holder = gen();\n    while (first != last) {\n        *first = holder;\n        ++first;\n    }\n}\n</code></pre>\n<p>In this case, every item in the range would be assigned the same value. That said, this seems like a rather unusual way to implement <code>generate</code>. I'm pretty sure it's allowed, but don't see <em>much</em> reason to do it.</p>\n<p>At the same time, I should point out that there are a couple tiny hints of reasons to do it. The first would be efficiency: it could be cheaper to store the value rather than re-create it N times.</p>\n<p>The second would be based on a close (pedantic) reading of the description in the standard (\u00a725.2.6/1):</p>\n<blockquote>\n<p id=\"so_9380190_9380451_0\">Effects: Invokes the function object <code>gen</code> and assigns the return value of <code>gen</code> though all the iterators in the range <code>[first, last)</code> or <code>[first, first + n)</code>.</p>\n</blockquote>\n<p>Given the way that's worded, you could argue that it's basically saying you only invoke <code>gen</code> once, then assign that one return value to all the iterators in the range, rather than re-invoke it for every iterator in the range. For example, it talks about \"the return value\", implying that there's only one value, rather than a separate return value for each iterator in the range.</p>\n<p>Edit: Re-reading, I think the standard does provide a strong indication that the first is intended though. Reading a bit further down, we get:</p>\n<blockquote>\n<p id=\"so_9380190_9380451_1\">Complexity: Exactly last - first (or n) invocations of gen and assignments.</p>\n</blockquote>\n<p>If you were being intentionally perverse, you could still assign all the values from a single invocation, and ignore the returns from the other invocations, but this does make it pretty clear that an implementation like the first one above is what's intended (and the second does <em>not</em> conform as-is).</p>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2012-02-21T16:22:53.660", "Id": "9380451", "Score": "0", "CreationDate": "2012-02-21T15:42:53.930", "LastActivityDate": "2012-02-21T16:22:53.660"}, "9380439": {"ParentId": "9380190", "CommentCount": "3", "Body": "<p>Functors are exactly like any other objects - if their member is defined as a reference, they store it by reference, if it's defined as a value, they store a value. Your first example works because std::generate gets its functor parameter by value, not by reference and thus operates on a copy of the temporary you create in the expression with <code>g()</code>.</p>\n", "OwnerUserId": "819547", "PostTypeId": "2", "Id": "9380439", "Score": "0", "CreationDate": "2012-02-21T15:42:13.213", "LastActivityDate": "2012-02-21T15:42:13.213"}, "9380406": {"ParentId": "9380190", "CommentCount": "0", "Body": "<p>Of cause, functor objects do not have any special magic, that differ them from other objects. But I do not see what state functor should save while copting in your example.</p>\n<p>Consider first one:\nPossible <code>generate</code> realization is</p>\n<pre><code>template &lt;typename Iterator, typename Functor&gt;\nvoid generate(Iterator begin, Iterator end, Functor f)\n{\n    for (Iterator it  = begin; it != end; ++it) {\n        *it = f();\n    }\n}\n</code></pre>\n<p>In this example functor copied only once on function entrance, than code deals with local variable <code>f</code>, and it does not perform any copying.</p>\n<p>While your <code>functor</code> has memeber <code>n</code>, state is saved in it.</p>\n", "OwnerUserId": "774651", "PostTypeId": "2", "Id": "9380406", "Score": "0", "CreationDate": "2012-02-21T15:40:16.890", "LastActivityDate": "2012-02-21T15:40:16.890"}, "9380190": {"CommentCount": "0", "AcceptedAnswerId": "9380447", "PostTypeId": "1", "LastEditorUserId": "636019", "CreationDate": "2012-02-21T15:27:08.280", "LastActivityDate": "2012-04-13T10:57:40.243", "LastEditDate": "2012-02-21T16:22:22.987", "ViewCount": "1441", "FavoriteCount": "3", "Title": "How does the functor maintain/store state of a object", "Id": "9380190", "Score": "3", "Body": "<p>I am C++ noob studying functors. I have this code as below(NB - This is not my homework, i am past that!). </p>\n<p>It does print 0 1 2 3 4 5 6 7 8 9 on console<br>\nwhich I dont see how does it maintain the state of this object(value of n) if the functor is called by value and not by reference/pointer  </br></p>\n<p><strong>EDIT:</strong>\nI thought here(Example 1) since the functor is called by Value and the constructor initializes n to zero every time. So it should be zero always at beginning, then it should increment to 1 and return 1. How is it printing 0 1 2 3 4 5 6 7 8 9 </p>\n<p><strong>Example 1]</strong></p>\n<pre><code>class g\n{\npublic:\n    g():n(0){}\n    int operator()() { return n++; }\n    int n;\n};\n\n;\n\nint main()\n{\n    int a[10];\n    g v1;\n    std::generate(a, a+10, g());//This passes a functor to generate \n\n    //EDIT - this will print 0 1 2 3 4 5 6 7 8 9**\n    std::copy(a, a+10, std::ostream_iterator&lt;int&gt;(std::cout, \" \"));\n\n    getchar();\n    return 0;\n}\n</code></pre>\n<p>Because I have seen code like below using reference variables inside a functor to retain state, <a href=\"http://xenon.arcticus.com/c-morsels-std-for-each-functors-member-variables\" rel=\"nofollow\">here</a> and developed a simple code using that concept as below:</p>\n<p><strong>Example 2]</strong></p>\n<pre><code>class CountingFunctor\n{\npublic:\n    CountingFunctor() : _counter(0) {}\n    int getCounter(void) const {return(_counter);}\n    void operator () (Contained item) {if(item.getShouldBeCounted()) _counter++;}\nprivate:\n    int _counter;\n};\n#endif\n\n//this class uses references to maintain state in the functor\nclass CountingFunctor\n{\npublic:\n    CountingFunctor(int &amp;elem) : _counter(elem) {_counter=0;}\n    int getCounter(void) const {return(_counter);}\n    void operator () (Contained item) {if(item.getShouldBeCounted()) _counter++;}\nprivate:\n    int &amp;_counter;\n};\n\nint main()\n{\n    vector&lt;Contained&gt; Container(10);\n    Container[3].setShouldBeCounted(false);\n    Container[9].setShouldBeCounted(false);\n    int elem;\n    CountingFunctor CountAllWhoShouldBe(elem);\n    std::for_each(Container.begin(), Container.end(), CountAllWhoShouldBe);\n    std::cout &lt;&lt; CountAllWhoShouldBe.getCounter() &lt;&lt; \" items should be counted.\" &lt;&lt; std::endl;\n\n    getchar();\n}\n</code></pre>\n<p>Question is </p>\n<p>So Do functors maintain state of their objects by themselves, i.e. without needing any reference variables as shown in example 2</p>\n<p>Or Code in Example 1 is working because std::generate() calls the functor by reference/pointer?</p>\n<p>Further reading material appreciated.</p>\n", "Tags": "<c++><function><object>", "OwnerUserId": "2759376", "AnswerCount": "6"}, "9380447": {"ParentId": "9380190", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>When you call <code>std::generate</code>, it gets its own copy of the functor object. Once inside that function though, it's just calling it's own single instance of the object repeatedly, so state is preserved <em>inside</em> the <code>generate</code> call, but <em>not</em> between <code>generate</code> and the caller.</p>\n<p>So, change your code to</p>\n<pre><code>g v1;\nstd::generate(a, a+10, v1);\n</code></pre>\n<p>and afterwards <code>v1.n</code> will still be zero. Inside <code>generate</code> it was operating on its local copy (say v2), which did get incremented, but couldn't tell v1 about it.</p>\n<p>Now, if you want to communicate v2's state out to v1, that's when you need to use references inside your functor, so v1 and v2 share whatever state gets mutated inside the call.</p>\n<hr>\n<p>We can expand the call to show this more clearly:</p>\n<pre><code>g v1;\nstd::generate(a, a+10, v1);\n// -&gt; generate(begin=a, end=a+10, v2=g(v1))\n{\n    while (begin != end)\n        *begin = v2();\n}\n// v2 just went out of scope, and took the accumulated state with it!\n// v1 in the caller's scope remains unchanged\n</code></pre>\n<p>Now it should be obvious that if <code>v1</code>, instead of being a value object which gets deep-copied and keeps it's state internally, kept a reference to shared state and was shallow copied, then <code>v2</code> would share the same state as <code>v1</code> and that state would be accessible after the call.</p>\n<p>In fact, we can write a simple-ish wrapper to automate this, so you don't need to do it by hand for every functor:</p>\n<pre><code>template &lt;typename OriginalFunctor, typename RType&gt;\nclass StatefulFunctor\n{\n    OriginalFunctor &amp;fun;\n\npublic:\n    StatefulFunctor() = delete;\n    StatefulFunctor(OriginalFunctor &amp;orig) : fun(orig) {}\n    StatefulFunctor(StatefulFunctor const &amp;other) : fun(other.fun) {}\n    StatefulFunctor(StatefulFunctor &amp;&amp;other) : fun(other.fun) {}\n\n    template &lt;typename... Args&gt;\n    RType operator() (Args&amp;&amp;... args)\n    {\n        return fun(std::forward&lt;Args&gt;(args)...);\n    }\n};\n\ntemplate &lt;typename RT, typename OF&gt;\nStatefulFunctor&lt;OF, RT&gt; stateful(OF &amp;fun)\n{\n    return StatefulFunctor&lt;OF, RT&gt;(fun);\n}\n</code></pre>\n<p>Now changing the original code to:</p>\n<pre><code>g v1;\nstd::generate(a, a+10, stateful&lt;int&gt;(v1));\n</code></pre>\n<p>means <code>v1.i</code> will be updated in place.</p>\n<p>As Jerry Coffin points out, preservation of state even <em>inside</em> the call isn't guaranteed, so it's sensible to do something like this with stateful functors even if you don't need the state preserved for the caller.</p>\n</hr>", "OwnerUserId": "212858", "LastEditorUserId": "212858", "LastEditDate": "2012-04-13T10:57:40.243", "Id": "9380447", "Score": "0", "CreationDate": "2012-02-21T15:42:43.203", "LastActivityDate": "2012-04-13T10:57:40.243"}, "bq_ids": {"n4140": {"so_9380190_9380451_1": {"section_id": 1335, "quality": 0.8571428571428571, "length": 6}, "so_9380190_9380451_0": {"section_id": 1332, "quality": 0.5882352941176471, "length": 10}}, "n3337": {"so_9380190_9380451_1": {"section_id": 1329, "quality": 0.8571428571428571, "length": 6}, "so_9380190_9380451_0": {"section_id": 1326, "quality": 0.5882352941176471, "length": 10}}, "n4659": {"so_9380190_9380451_1": {"section_id": 1465, "quality": 0.8571428571428571, "length": 6}, "so_9380190_9380451_0": {"section_id": 1463, "quality": 0.5294117647058824, "length": 9}}}});