post_cb({"45793668": {"Id": "45793668", "PostTypeId": "2", "Body": "<p><code>vec[X].fetch_add</code> is safe as long as you're modifying each individual <strong>atomic</strong>. If you call any non-const (modifying) method of the wrapping <code>std::vector</code> this is undefined behaviour, as <code>std::vector</code> itself is not thread safe.</p>\n<p>De-facto, you can initialize the vector in some thread, pass its reference to some asynchronous task and from that point, only act on specific elements of the vector, not act on the vector itself. <code>vec[X].action(...)</code> is thread safe, <code>vec.action(...)</code> is not.</p>\n", "LastEditorUserId": "3613500", "LastActivityDate": "2017-08-21T09:32:44.743", "Score": "3", "CreationDate": "2017-08-21T09:29:29.223", "ParentId": "45793411", "CommentCount": "0", "OwnerUserId": "3613500", "LastEditDate": "2017-08-21T09:32:44.743"}, "45793481": {"Id": "45793481", "PostTypeId": "2", "Body": "<p>No it is not, in general, thread safe since the <em>container</em> itself is not atomic.</p>\n<p>That said, so long as you don't change what is in the vector (i.e. doing anything that invalidates the return of <code>data()</code>) , you'll be fine.</p>\n<p>Sadly you can't resort to <code>std::atomic&lt;std::vector&lt;...&gt;&gt;</code> as a <code>std::vector</code> is not <em>trivially copyable</em>.</p>\n", "LastActivityDate": "2017-08-21T09:20:46.030", "CommentCount": "5", "CreationDate": "2017-08-21T09:20:46.030", "ParentId": "45793411", "Score": "6", "OwnerUserId": "2380830"}, "bq_ids": {"n4140": {"so_45793411_45794804_9": {"length": 15, "quality": 0.9375, "section_id": 5817}, "so_45793411_45794804_5": {"length": 25, "quality": 0.9259259259259259, "section_id": 717}, "so_45793411_45794804_2": {"length": 20, "quality": 0.9523809523809523, "section_id": 6347}, "so_45793411_45794804_6": {"length": 18, "quality": 0.9473684210526315, "section_id": 718}, "so_45793411_45794804_11": {"length": 20, "quality": 0.8, "section_id": 5834}, "so_45793411_45794804_3": {"length": 21, "quality": 0.9545454545454546, "section_id": 6348}}, "n3337": {"so_45793411_45794804_5": {"length": 25, "quality": 0.9259259259259259, "section_id": 706}, "so_45793411_45794804_2": {"length": 20, "quality": 0.9523809523809523, "section_id": 6104}, "so_45793411_45794804_9": {"length": 15, "quality": 0.9375, "section_id": 5588}, "so_45793411_45794804_6": {"length": 17, "quality": 0.8947368421052632, "section_id": 707}, "so_45793411_45794804_11": {"length": 22, "quality": 0.88, "section_id": 5605}, "so_45793411_45794804_3": {"length": 21, "quality": 0.9545454545454546, "section_id": 6105}}, "n4659": {"so_45793411_45794804_5": {"length": 25, "quality": 0.9259259259259259, "section_id": 748}, "so_45793411_45794804_2": {"length": 20, "quality": 0.9523809523809523, "section_id": 7856}, "so_45793411_45794804_9": {"length": 14, "quality": 0.875, "section_id": 7278}, "so_45793411_45794804_6": {"length": 18, "quality": 0.9473684210526315, "section_id": 749}, "so_45793411_45794804_11": {"length": 20, "quality": 0.8, "section_id": 7296}, "so_45793411_45794804_3": {"length": 21, "quality": 0.9545454545454546, "section_id": 7857}}}, "45794804": {"Id": "45794804", "PostTypeId": "2", "Body": "<p>It depends what the other threads are doing.</p>\n<p>From the standard:</p>\n<blockquote>\n<p id=\"so_45793411_45794804_0\"><strong>17.6.5.9 Data race avoidance [res.on.data.races]</strong></p>\n<p id=\"so_45793411_45794804_1\">...</p>\n<p id=\"so_45793411_45794804_2\">2 A C++ standard library function shall not directly or indirectly access objects (1.10) accessible by threads\n  other than the current thread unless the objects are accessed directly or indirectly via the function\u2019s arguments,\n  including this.</p>\n<p id=\"so_45793411_45794804_3\">3 A C++ standard library function shall not directly or indirectly modify objects (1.10) accessible by threads\n  other than the current thread unless the objects are accessed directly or indirectly via the function\u2019s non-const\n  arguments, including this.</p>\n</blockquote>\n<p>and</p>\n<blockquote>\n<p id=\"so_45793411_45794804_4\"><strong>23.2.2 Container data races [container.requirements.dataraces]</strong></p>\n<p id=\"so_45793411_45794804_5\">1 For purposes of avoiding data races (17.6.5.9), implementations shall consider the following functions to be\n  const: begin, end, rbegin, rend, front, back, data, find, lower_bound, upper_bound, equal_range, at\n  and, except in associative or unordered associative containers, operator[].</p>\n<p id=\"so_45793411_45794804_6\">2 Notwithstanding (17.6.5.9), implementations are required to avoid data races when the contents of the contained\n  object in different elements in the same container, excepting vector&lt;bool&gt;, are modified concurrently.</p>\n</blockquote>\n<p>By combining these two parts with the rules for atomics, we can deduce that calling <code>vec[index].fetch_add(1, std::memory_order_release)</code> cannot cause a race condition with other threads performing the same or other \"const\" operations (including those mentioned in paragraph 23.2.2.1).  However, if another thread invokes a non-const operation on <code>vec</code> itself (e.g. <code>insert</code>, <code>erase</code>, <code>resize</code> etc.) then we experience undefined behaviour as specified by section 1.10:</p>\n<blockquote>\n<p id=\"so_45793411_45794804_7\"><strong>1.10 Multi-threaded executions and data races [intro.multithread]</strong></p>\n<p id=\"so_45793411_45794804_8\">...</p>\n<p id=\"so_45793411_45794804_9\">4 Two expression evaluations conflict if one of them modifies a memory location (1.7) and the other one accesses\n  or modifies the same memory location.</p>\n<p id=\"so_45793411_45794804_10\">...</p>\n<p id=\"so_45793411_45794804_11\">21 The execution of a program contains a data race if it contains two conflicting actions in different threads,\n  at least one of which is not atomic, and neither happens before the other. Any such data race results in\n  undefined behavior. </p>\n</blockquote>\n", "LastActivityDate": "2017-08-21T10:27:50.610", "CommentCount": "1", "CreationDate": "2017-08-21T10:27:50.610", "ParentId": "45793411", "Score": "2", "OwnerUserId": "5384629"}, "45793411": {"ViewCount": "208", "Body": "<p>I have a <code>std::vector&lt;std::atomic&lt;size_t&gt;&gt;</code> vec. Is it safe to run <code>vec[index].fetch_add(1, std::memory_order_release)</code> or store/load with multiple concurrent threads on it? I think it should be, because reading is thread safe and writing to one entry at the same time from multiple threads is impossible because of the atomics - is that right?</p>\n", "Title": "c++ - vector of atomics fully thread safe?", "CreationDate": "2017-08-21T09:16:23.923", "LastActivityDate": "2017-08-21T10:27:50.610", "CommentCount": "3", "LastEditDate": "2017-08-21T09:30:08.197", "PostTypeId": "1", "LastEditorUserId": "8202231", "Id": "45793411", "Score": "4", "OwnerUserId": "8202231", "Tags": "<c++><vector><concurrency><atomic>", "AnswerCount": "4"}, "45793658": {"Id": "45793658", "PostTypeId": "2", "Body": "<p>Your expression <code>vec[n].atomic_op(...)</code> is not itself atomic, but decomposes into:</p>\n<pre><code>auto iter = vec.begin();\niter += n;\niter-&gt;atomic_op(...);\n</code></pre>\n<p>So, the first two statements are vulnerable to the usual iterator invalidation rules. Concurrently changing the size of the vector, or erasing any element before the nth, or the nth element itself, can break them.</p>\n<p>Once you <em>have</em> an iterator to an element, <em>if</em> that iterator is not invalidated during the time you're using it, <em>then</em> whatever atomic operations you perform on the element itself will be safe.</p>\n", "LastActivityDate": "2017-08-21T09:29:13.073", "CommentCount": "0", "CreationDate": "2017-08-21T09:29:13.073", "ParentId": "45793411", "Score": "3", "OwnerUserId": "212858"}});