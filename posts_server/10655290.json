post_cb({"10655485": {"ParentId": "10655290", "CommentCount": "6", "Body": "<p>Maybe. It depends on C++ version.</p>\n<p>In C++03, it's an obvious UB,  there's no intervening sequence point between the assignments.</p>\n<p>In C++11, as Mankarse explains, it's not undefined anymore \u2014 the parenthesized compound assignment is sequenced before the outer one, so it's okay.</p>\n", "OwnerUserId": "784668", "PostTypeId": "2", "Id": "10655485", "Score": "13", "CreationDate": "2012-05-18T15:28:03.393", "LastActivityDate": "2012-05-18T15:28:03.393"}, "10655290": {"CommentCount": "14", "AcceptedAnswerId": "10655884", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-05-18T15:17:26.733", "LastActivityDate": "2013-06-18T15:41:25.940", "LastEditDate": "2017-05-23T12:34:04.237", "ViewCount": "1690", "FavoriteCount": "6", "Title": "In which versions of the C++ standard does \"(i+=10)+=10\" have undefined behaviour?", "Id": "10655290", "Score": "32", "Body": "<p>In C++, does the following have undefined behaviour:</p>\n<pre><code>int i = 0;\n(i+=10)+=10;\n</code></pre>\n<p>There was some debate about this in the comments to <a href=\"https://stackoverflow.com/a/10653994/367273\">my answer</a> to <a href=\"https://stackoverflow.com/questions/10653903/whats-the-result-of-in-c-and-c\">What's the result of += in C and C++?</a> The subtlety here is that the default response seems to be \"yes\", whereas it appears that the correct answer is \"it depends on the version of the C++ standard\".</p>\n<p>If it does depend on the version of the standard, please explain where it's UB and where it's not.</p>\n", "Tags": "<c++><c++11><undefined-behavior><language-lawyer><c++03>", "OwnerUserId": "367273", "AnswerCount": "3"}, "10655346": {"ParentId": "10655290", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>In C++11 the expression is well defined and will result in <code>i == 20</code>.</p>\n<p>From <code>[expr.ass]/1</code>:</p>\n<blockquote>\n<p id=\"so_10655290_10655346_0\">In all cases, the assignment is sequenced after the value computation of the right and left operands, and before the value computation of the assignment expression.</p>\n</blockquote>\n<p>This means that the assignment <code>i+=1</code> is sequenced before the value computation of the left hand side of <code>(i+=10)+=10</code>, which is in turn sequenced before the final assignment to <code>i</code>.</p>\n<hr>\n<p>In C++03 the expression has undefined behavior, because it causes <code>i</code> to be modified twice with no intervening sequence point.</p>\n</hr>", "OwnerUserId": "485561", "LastEditorUserId": "485561", "LastEditDate": "2012-05-18T15:47:18.570", "Id": "10655346", "Score": "20", "CreationDate": "2012-05-18T15:20:25.003", "LastActivityDate": "2012-05-18T15:47:18.570"}, "10655884": {"ParentId": "10655290", "PostTypeId": "2", "CommentCount": "13", "Body": "<p><strong>tl;dr</strong>: The <em>sequence</em> of the modifications and reads performed in <code>(i+=10)+=10</code> is well defined in both C++98 and C++11, however in C++98 this is not sufficient to make the behavior defined.</p>\n<p>In C++98 multiple modifications to the same object without an intervening <em>sequence-point</em> results in undefined behavior, even when the order of those modifications is well specified. This expression does not contain any sequence points and so the fact that it consists of two modifications is sufficient to render its behavior undefined.</p>\n<p>C++11 doesn't have sequence points and only requires that the modifications of an object be ordered with respect to each other and to reads of the same object to produce defined behavior.</p>\n<p>Therefore the behavior is undefined in C++98 but well defined in C++11.</p>\n<hr>\n<h3>C++98</h3>\n<p>C++98 clause [expr] 5 p4</p>\n<blockquote>\n<p id=\"so_10655290_10655884_0\">Except where noted, the order of evaluation of operands of individual operators and subexpressions of individual expression, and the order in which side effects take place, is unspecified.</p>\n</blockquote>\n<p>C++98 clause [expr.ass] 5.17 p1</p>\n<blockquote>\n<p id=\"so_10655290_10655884_1\">The result of the assignment operation is the value stored in the left operand after the assignment has taken place; the result is an lvalue</p>\n</blockquote>\n<p>So I believe the order is specified, however I don't see that that alone is enough to create a sequence point in the middle of an expression. And continuing on with the quote of [expr] 5 p4:</p>\n<blockquote>\n<p id=\"so_10655290_10655884_2\">Between the previous and next sequence point a scalar object shall have its stored value modified at most once by the evaluation of an expression.</p>\n</blockquote>\n<p>So even though the order is specified it appears to me that this is not sufficient for defined behavior in C++98.</p>\n<hr>\n<h3>C++11</h3>\n<p>C++11 does away sequence points for the much clearer idea of <em>sequence-before</em> and <em>sequenced-after</em>. The language from C++98 is replaced with</p>\n<p>C++11 [intro.execution] 1.9 p15</p>\n<blockquote>\n<p id=\"so_10655290_10655884_3\">Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced. [...]</p>\n<p id=\"so_10655290_10655884_4\">If a side effect on a scalar object is unsequenced relative to either another side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined.</p>\n</blockquote>\n<p>C++11 [expr.ass] 5.17 p1</p>\n<blockquote>\n<p id=\"so_10655290_10655884_5\">In all cases, the assignment is sequenced after the value computation of the right and left operands, and before the value computation of the assignment expression.</p>\n</blockquote>\n<p>So while being ordered was not sufficient to make the behavior defined in C++98, C++11 has changed the requirement such that being ordered (i.e., sequenced) is sufficient.</p>\n<p>(And it seems to me that the extra flexibility afforded by 'sequence before' and 'sequenced after' has lead to a much more clear, consistent, and well specified language.)</p>\n<hr>\n<p>It seems unlikely to me that any C++98 implementation would actually do anything surprising when the sequence of operations is well specified even if that is insufficient to produce technically well defined behavior. As an example, the internal representation of this expression produced by Clang in C++98 mode has well defined behavior and does the expected thing.</p>\n</hr></hr></hr>", "OwnerUserId": "365496", "LastEditorUserId": "365496", "LastEditDate": "2013-06-18T15:41:25.940", "Id": "10655884", "Score": "34", "CreationDate": "2012-05-18T15:55:48.673", "LastActivityDate": "2013-06-18T15:41:25.940"}, "bq_ids": {"n4140": {"so_10655290_10655884_0": {"section_id": 5811, "quality": 0.6470588235294118, "length": 11}, "so_10655290_10655346_0": {"section_id": 6173, "quality": 1.0, "length": 15}, "so_10655290_10655884_3": {"section_id": 5811, "quality": 1.0, "length": 11}, "so_10655290_10655884_5": {"section_id": 6173, "quality": 1.0, "length": 15}, "so_10655290_10655884_4": {"section_id": 5811, "quality": 1.0, "length": 22}}, "n3337": {"so_10655290_10655884_0": {"section_id": 5584, "quality": 0.6470588235294118, "length": 11}, "so_10655290_10655346_0": {"section_id": 5934, "quality": 1.0, "length": 15}, "so_10655290_10655884_3": {"section_id": 5584, "quality": 1.0, "length": 11}, "so_10655290_10655884_5": {"section_id": 5934, "quality": 1.0, "length": 15}, "so_10655290_10655884_4": {"section_id": 5584, "quality": 1.0, "length": 22}}, "n4659": {"so_10655290_10655884_0": {"section_id": 7272, "quality": 0.5882352941176471, "length": 10}, "so_10655290_10655346_0": {"section_id": 7675, "quality": 1.0, "length": 15}, "so_10655290_10655884_3": {"section_id": 7272, "quality": 1.0, "length": 11}, "so_10655290_10655884_5": {"section_id": 7675, "quality": 1.0, "length": 15}, "so_10655290_10655884_4": {"section_id": 7272, "quality": 0.7272727272727273, "length": 16}}}});