post_cb({"28466464": {"ParentId": "28466069", "CommentCount": "0", "Body": "<p>Quoting from <code>1.4 [intro.compliance]</code></p>\n<blockquote>\n<p id=\"so_28466069_28466464_0\">A conforming implementation may have extensions (including additional\n  library functions), provided they do not alter the behavior of any\n  well-formed program. Implementations are required to diagnose programs\n  that use such extensions that are ill-formed according to this\n  International Standard. Having done so, however, they can compile and\n  execute such programs.</p>\n</blockquote>\n<p>The applicable section for your initialization example is <code>8.5.4 [dcl.init.list]</code>. In particular,</p>\n<blockquote>\n<p id=\"so_28466069_28466464_1\">Otherwise, if the initializer list has a single element of type <strong>E</strong> and\n  either <strong>T</strong> is not a reference type or its referenced type is\n  reference-related to <strong>E</strong> , the object or reference is initialized from\n  that element; if a narrowing conversion (see below) is required to\n  convert the element to <strong>T</strong> , the program is <em>ill-formed</em>.</p>\n</blockquote>\n<p>accompanied by the example</p>\n<pre><code>int x1 {2}; // OK\nint x2 {2.0}; // error: narrowing\n</code></pre>\n<p>Since the exact nature of the diagnostic is implementation specified, both sets of behaviours observed are standard compliant.</p>\n", "OwnerUserId": "862351", "PostTypeId": "2", "Id": "28466464", "Score": "2", "CreationDate": "2015-02-11T23:17:37.560", "LastActivityDate": "2015-02-11T23:17:37.560"}, "28466236": {"ParentId": "28466069", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The standard never says anything \"should not compile\"  <strike>(except for <code>#error</code>)</strike>. Certain ill-formed programs must <em>emit a diagnostic</em> and issuing a warning satisfies that.</p>\n<p>You can cause gcc to stop compilation on all diagnostics by using the switch <code>-Werror</code>. It can be narrowed to specific warnings, e.g. <code>-Werror=narrowing</code>.</p>\n<p>If you are compiling in GNU++ or whatever the default mode is instead of C++11 then the compiler can do whatever it likes, including accepting narrowing conversions without complaint.</p>\n<p>Reference: N3936 [intro.compliance]/2</p>\n<blockquote>\n<ul>\n<li><p id=\"so_28466069_28466236_0\">If a program contains a violation of any diagnosable rule [...], a conforming implementation shall issue at least one diagnostic message.</p></li>\n<li><p id=\"so_28466069_28466236_1\">If a program contains a violation of a rule for which no diagnostic is required, this International Standard places no requirement on implementations with respect to that program.</p></li>\n</ul>\n</blockquote>\n<p>[defns.diagnostic]</p>\n<blockquote>\n<p id=\"so_28466069_28466236_2\"><strong>diagnostic message</strong></p>\n<p id=\"so_28466069_28466236_3\">message belonging to an implementation-defined subset of the implementation\u2019s output messages</p>\n</blockquote>\n<p>Note also from the first bullet point that it is not required that the number or content of messages corresponds to the number or content of the violations.</p>\n<p>The standard leaves it completely up to the compiler to decide how to organize its errors and/or warnings, with the proviso that for certain violations it can't silently ignore it.</p>\n", "OwnerUserId": "1505939", "LastEditorUserId": "1505939", "LastEditDate": "2015-02-12T02:16:22.567", "Id": "28466236", "Score": "6", "CreationDate": "2015-02-11T23:00:44.873", "LastActivityDate": "2015-02-12T02:16:22.567"}, "28466553": {"ParentId": "28466069", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The reason that the narrowing conversion inside <code>{}</code> are only an error in C++11 mode is simple: it isn't an error in C++03. Now, <code>T var{value};</code> is new C++11 syntax, but <code>T var = {value};</code> was already valid C++03 syntax, and <em>did</em> allow narrowing conversions.</p>\n<pre><code>int i = { 10.1 }; // valid C++03, invalid C++11\n</code></pre>\n<p>It makes it easier for the GCC developers to treat narrowing conversions the same in <code>T var{value};</code> and <code>T var={value};</code> initialisations. This is useful because it avoids two separate code paths for the warning in the compiler.</p>\n<p>It makes it easier for the GCC developers to accept even the <code>T var{value};</code> syntax in C++03 mode, merely warning about it. Several other C++11 syntax extensions are also enabled in C++03 mode. This is useful because several C++11 syntax extensions are used in GCC's implementation of the standard library (where warnings about it are suppressed).</p>\n<p>The reason that <code>int i{10.1};</code> <em>isn't</em> an error in GCC 4.9 in C++11 mode, but was made an error in GCC 5, is because not treating it as an error caused valid code to be rejected. The C++ standard requires treating it as an error in SFINAE contexts, and here is a valid C++11 program that runs incorrectly because of this with GCC 4.9:</p>\n<pre><code>#include &lt;stdio.h&gt;\ntemplate &lt;typename T&gt; void f(double) { puts(\"ok\"); }\ntemplate &lt;typename T, typename = decltype(T{10.1})&gt; void f(int) { puts(\"error\"); }\nint main() { f&lt;int&gt;(1); }\n</code></pre>\n<p>This is supposed to print \"ok\". The second overload is supposed to be discarded.</p>\n<p>With GCC 4.9, it prints \"error\", because the second overload isn't discarded, and <code>int</code> is a better match than <code>double</code>.</p>\n", "OwnerUserId": "743382", "LastEditorUserId": "743382", "LastEditDate": "2015-02-11T23:40:23.190", "Id": "28466553", "Score": "9", "CreationDate": "2015-02-11T23:25:02.213", "LastActivityDate": "2015-02-11T23:40:23.190"}, "bq_ids": {"n4140": {"so_28466069_28466464_0": {"section_id": 5776, "quality": 0.9705882352941176, "length": 33}, "so_28466069_28466236_0": {"section_id": 5770, "quality": 1.0, "length": 11}, "so_28466069_28466236_1": {"section_id": 5770, "quality": 0.9090909090909091, "length": 10}, "so_28466069_28466236_3": {"section_id": 5768, "quality": 0.8571428571428571, "length": 6}, "so_28466069_28466464_1": {"section_id": 3325, "quality": 1.0, "length": 25}}, "n3337": {"so_28466069_28466464_0": {"section_id": 5549, "quality": 0.9705882352941176, "length": 33}, "so_28466069_28466236_0": {"section_id": 5543, "quality": 1.0, "length": 11}, "so_28466069_28466236_1": {"section_id": 5543, "quality": 0.9090909090909091, "length": 10}, "so_28466069_28466236_3": {"section_id": 5541, "quality": 0.8571428571428571, "length": 6}, "so_28466069_28466464_1": {"section_id": 3195, "quality": 0.76, "length": 19}}, "n4659": {"so_28466069_28466464_1": {"section_id": 4091, "quality": 1.0, "length": 25}, "so_28466069_28466236_0": {"section_id": 7227, "quality": 1.0, "length": 11}, "so_28466069_28466236_1": {"section_id": 7227, "quality": 0.9090909090909091, "length": 10}, "so_28466069_28466236_3": {"section_id": 7225, "quality": 0.8571428571428571, "length": 6}, "so_28466069_28466464_0": {"section_id": 7233, "quality": 0.9705882352941176, "length": 33}}}, "28466069": {"CommentCount": "3", "ViewCount": "369", "PostTypeId": "1", "LastEditorUserId": "3093378", "CreationDate": "2015-02-11T22:48:47.110", "LastActivityDate": "2017-05-17T18:09:20.143", "Title": "g++4.9 and g++5 different behaviour when narrowing in initializing list", "AcceptedAnswerId": "28466236", "LastEditDate": "2017-05-17T18:09:20.143", "Id": "28466069", "Score": "3", "Body": "<p>Consider this code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    int i{10.1}; // narrowing, should not compile\n    std::cout &lt;&lt; i &lt;&lt; std::endl;\n}\n</code></pre>\n<p>According to the C++11 standard, it should not compile (narrowing in brace initialization is forbidden.)</p>\n<p>Now, compiling with <code>g++4.9.2 -std=c++11</code> only emits a warning</p>\n<pre><code>warning: narrowing conversion of '1.01e+1' from 'double' to 'int' inside { } [-Wnarrowing]\n</code></pre>\n<p>Removing the <code>-std=c++11</code> flag results in a warning regarding the brace init, but not any narrowing:</p>\n<pre><code>warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\n</code></pre>\n<p>On the other hand, g++5 <strong>doesn't compile it</strong>, provided you compile with <code>g++5 -std=c++11</code>. However, if <code>-std=c++11</code> is omitted, then even <code>g++5</code> happily compiles it, giving just a warning related to the brace init, not to the narrowing:</p>\n<pre><code>warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\n</code></pre>\n<p>The above behaviour seems buggy, <code>g++4.9</code> should not compile the code, and it is more than weird that <code>g++5</code> compiles it if you forget to specify <code>-std=c++11</code>. Is this a known problem?</p>\n", "Tags": "<c++><c++11><gcc4.9><gcc5>", "OwnerUserId": "3093378", "AnswerCount": "3"}});