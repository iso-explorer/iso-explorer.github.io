post_cb({"8769578": {"ParentId": "8769467", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-01-07T12:09:46.670", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:29:04.190", "Id": "8769578", "OwnerUserId": "366904", "Body": "<p>Yes, that's correct. The definition of a memory leak is a situation where you are unable to delete something that you created (and whose lifetime you are therefore responsible for managing).</p>\n<p>As the <a href=\"https://stackoverflow.com/a/8769371/366904\">answers</a> to that question indicate, <code>delete one</code> invokes undefined behavior (which in most cases will probably translate to a regular old memory leak, but things could be as bad as <a href=\"http://www.catb.org/jargon/html/N/nasal-demons.html\" rel=\"nofollow noreferrer\">nasal demons</a>) because the runtime type of the specified object does not match its static (declared) type, and the static type does not have a virtual destructor.</p>\n<p>The applicable section from the C++ standard is this one:</p>\n<blockquote>\n<p id=\"so_8769467_8769578_0\">\u00a75.3.5/3: In the first alternative (delete object), if the static type of the operand is different from its dynamic type, the static type shall be a base class of the operand\u2019s dynamic type and the static type shall have a virtual destructor or the behavior is undefined.</p>\n</blockquote>\n<p>The solution is either to declare all of the destructors <code>virtual</code>, or not to delete the objects through a pointer to <code>One</code>.</p>\n", "LastActivityDate": "2012-01-07T12:15:28.757"}, "8769467": {"CommentCount": "3", "AcceptedAnswerId": "8769578", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2012-01-07T11:52:12.303", "LastActivityDate": "2013-07-01T14:04:53.433", "LastEditDate": "2017-05-23T12:03:14.907", "ViewCount": "70", "FavoriteCount": "1", "Title": "Correct way to inherit from a virtual class with non-virtual parent continued", "Id": "8769467", "Score": "0", "Body": "<p>My question is building on this question: <a href=\"https://stackoverflow.com/questions/8769259/correct-way-to-inherit-from-a-virtual-class-with-non-virtual-parent\">Correct way to inherit from a virtual class with non-virtual parent</a>.</p>\n<p>Is my understanding right that in the case which is described in the question, the Three and Two part of new allocated object are leaking because they are not destructed?</p>\n<p>Source:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct One\n{\n    ~One() {\n        std::cout &lt;&lt; \"~One()\\n\";\n    }\n};\n\nstruct Two : One\n{\n    virtual ~Two() {\n        std::cout &lt;&lt; \"~Two()\\n\";\n    }\n\n    virtual void test() = 0;\n};\n\nstruct Three : Two\n{\n    virtual ~Three() {\n        std::cout &lt;&lt; \"~Three()\\n\";\n    }\n\n    virtual void test() {\n        std::cout &lt;&lt; \"Three::test()\\n\";\n    }\n};\n\nint main()\n{\n    Two* two = new Three;\n    two-&gt;test();\n\n    One* one = two;\n    delete one;\n}\n</code></pre>\n", "Tags": "<c++><inheritance><virtual-destructor>", "OwnerUserId": "893693", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_8769467_8769578_0": {"section_id": 6107, "quality": 0.8461538461538461, "length": 22}}, "n3337": {"so_8769467_8769578_0": {"section_id": 5873, "quality": 0.8461538461538461, "length": 22}}, "n4659": {"so_8769467_8769578_0": {"section_id": 7604, "quality": 0.8461538461538461, "length": 22}}}});