post_cb({"48791206": {"Id": "48791206", "PostTypeId": "2", "Body": "<p>I'm not sure, if this really applies here. In the <a href=\"http://en.cppreference.com/w/cpp/language/reinterpret_cast#Notes\" rel=\"nofollow noreferrer\"><code>reinterpret_cast</code> - Notes</a> section they talk about pointer-interconvertible objects.</p>\n<p>And from <a href=\"http://eel.is/c++draft/basic#compound-4\" rel=\"nofollow noreferrer\">[basic.compound]/4</a>:</p>\n<blockquote>\n<p id=\"so_48790111_48791206_0\">Two objects <em>a</em> and <em>b</em> are <em>pointer-interconvertible</em> if:</p>\n<ul>\n<li>they are the same object, or</li>\n<li>one is a union object and the other is a non-static data member of that object, or</li>\n<li>one is a standard-layout class object and the other is the first non-static data member of that object, or, if the object has no non-static data members, the first base class subobject of that object, or</li>\n<li>there exists an object <em>c</em> such that <em>a</em> and <em>c</em> are pointer-interconvertible, and <em>c</em> and <em>b</em> are pointer-interconvertible.</li>\n</ul>\n<p id=\"so_48790111_48791206_1\">If two objects are pointer-interconvertible, then they have the same address, and it is possible to obtain a pointer to one from a pointer to the other via a <code>reinterpret_\u00adcast</code>.</p>\n</blockquote>\n<p>In this case, we have <code>Hdr h;</code> (c) as a non-static data member in both unions, which should allow to (because of the second and last bullet point)</p>\n<pre><code>Big* (a) -&gt; Hdr* (c) -&gt; Little* (b)\n</code></pre>\n", "LastEditorUserId": "1741542", "LastActivityDate": "2018-02-14T17:21:28.980", "Score": "-1", "CreationDate": "2018-02-14T15:53:02.403", "ParentId": "48790111", "CommentCount": "4", "OwnerUserId": "1741542", "LastEditDate": "2018-02-14T17:21:28.980"}, "48790111": {"ViewCount": "1109", "Body": "<p>I have a standard-layout union that has a whole bunch of types in it:</p>\n<pre><code>union Big {\n    Hdr h;\n\n    A a;\n    B b;\n    C c;\n    D d;\n    E e;\n    F f;\n};\n</code></pre>\n<p>Each of the types <code>A</code> thru <code>F</code> is standard-layout and has as its first member an object of type <code>Hdr</code>. The <code>Hdr</code> identifies what the active member of the union is, so this is variant-like. Now, I'm in a situation where I know for certain (because I checked) that the active member is either a <code>B</code> or a <code>C</code>. Effectively, I've reduced the space to:</p>\n<pre><code>union Little {\n    Hdr h;\n\n    B b;\n    C c;\n};\n</code></pre>\n<p>Now, is the following well-defined or undefined behavior?</p>\n<pre><code>void given_big(Big const&amp; big) {\n    switch(big.h.type) {\n    case B::type: // fallthrough\n    case C::type:\n        given_b_or_c(reinterpret_cast&lt;Little const&amp;&gt;(big));\n        break;\n    // ... other cases here ...\n    }\n}\n\nvoid given_b_or_c(Little const&amp; little) {\n    if (little.h.type == B::type) {\n        use_a_b(little.b);\n    } else {\n        use_a_c(little.c);\n    }\n}\n</code></pre>\n<p>The goal of <code>Little</code> is to effectively serve as documentation, that I've already checked that it's a <code>B</code> or <code>C</code> so in the future nobody adds code to check that it's an <code>A</code> or something. </p>\n<p>Is the fact that I am reading the <code>B</code> subobject as a <code>B</code> enough to make this well-formed? Can the common initial sequence rule meaningfully be used here?</p>\n", "Title": "Reinterpreting a union to a different union", "CreationDate": "2018-02-14T14:55:42.410", "LastActivityDate": "2018-02-15T13:00:58.977", "CommentCount": "15", "FavoriteCount": "7", "PostTypeId": "1", "Id": "48790111", "Score": "35", "OwnerUserId": "2069064", "Tags": "<c++><c++11><language-lawyer>", "AnswerCount": "5"}, "48793659": {"Id": "48793659", "PostTypeId": "2", "Body": "<p>This is UB by omission. [expr.ref]/4.2:</p>\n<blockquote>\n<p id=\"so_48790111_48793659_0\">If E2 is a non-static data member and the type of E1 is \u201c<code>cq1 vq1 X</code>\u201d,\n  and the type of E2 is \u201c<code>cq2 vq2 T</code>\u201d, the expression [<code>E1.E2</code>] designates the\n  named member of the object designated by the first expression.</p>\n</blockquote>\n<p>During the evaluation of the <code>given_b_or_c</code> call in <code>given_big</code>, the object expression in <code>little.h</code> does not actually designate a <code>Little</code> object, and ergo there's no such member. Because the standard \"omits any explicit definition of behavior\" for this case, the behavior is undefined.</p>\n", "LastEditorUserId": "2756719", "LastActivityDate": "2018-02-14T19:34:27.630", "Score": "2", "CreationDate": "2018-02-14T18:09:47.190", "ParentId": "48790111", "CommentCount": "4", "OwnerUserId": "2756719", "LastEditDate": "2018-02-14T19:34:27.630"}, "bq_ids": {"n4140": {"so_48790111_48793277_0": {"length": 14, "quality": 1.0, "section_id": 7239}, "so_48790111_48793277_1": {"length": 51, "quality": 0.9272727272727272, "section_id": 7194}, "so_48790111_48793659_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 6007}}, "n3337": {"so_48790111_48793277_1": {"length": 51, "quality": 0.9272727272727272, "section_id": 6938}, "so_48790111_48793277_0": {"length": 14, "quality": 1.0, "section_id": 6983}, "so_48790111_48793659_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 5775}}, "n4659": {"so_48790111_48793277_1": {"length": 51, "quality": 0.9272727272727272, "section_id": 8703}, "so_48790111_48791206_1": {"length": 16, "quality": 1.0, "section_id": 8733}, "so_48790111_48793277_0": {"length": 14, "quality": 1.0, "section_id": 8748}, "so_48790111_48793659_0": {"length": 17, "quality": 0.9444444444444444, "section_id": 7506}}}, "48793277": {"Id": "48793277", "PostTypeId": "2", "Body": "<p>I think there is no need to say that the <code>reinterpret_cast</code> to <code>Little&amp;</code> is perfectly legal. What is not clear is what can be done with the resulting lvalue? Is the access in <code>little.h.type</code> legal?</p>\n<p>On one hand, the C++11 standard, <a href=\"https://timsong-cpp.github.io/cppwp/n3337/basic.lval#10.6\" rel=\"nofollow noreferrer\">[basic.lval]/10.6</a> states:</p>\n<blockquote>\n<p id=\"so_48790111_48793277_0\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined:[...]</p>\n<ul>\n<li>an aggregate or union type that includes one of the aforementioned types among its elements or non-static data members (including, recursively, an element or non-static data member of a subaggregate or contained union),[...]</li>\n</ul>\n</blockquote>\n<p>Which is exactly the case here. So according to this paragraph the access seems legal.</p>\n<p>On the other hand, <a href=\"https://timsong-cpp.github.io/cppwp/n3337/basic.life#6.2\" rel=\"nofollow noreferrer\">[basic.life]/6.2</a> states:</p>\n<blockquote>\n<p id=\"so_48790111_48793277_1\">Similarly, before the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, any glvalue that refers to the original object may be used but only in limited ways. For an object under construction or destruction, see [class.cdtor]. Otherwise, such a glvalue refers to allocated storage ([basic.stc.dynamic.deallocation]), and using the properties of the glvalue that do not depend on its value is well-defined. The program has undefined behavior if: [...]</p>\n<ul>\n<li>the glvalue is used to access a non-static data member or call a non-static member function of the object, [...]</li>\n</ul>\n</blockquote>\n<p>In this case no object of type <code>Little</code> will start its lifetime, so one could argue that this paragraph is not pertinent. This is not my interpretation. I think that this paragraph does apply because there is almost no way for the compiler to know if an object of type <code>Little</code> will later be created by a placement new. So I believe that the constraints listed in this paragraph apply intentionally or factually every time there is an access.</p>\n<p>So my interpretation is that your code is UB because <code>little.h</code> is an access to an object of type <code>Little</code> before its lifetime has started.</p>\n", "LastEditorUserId": "5632316", "LastActivityDate": "2018-02-14T17:56:30.200", "Score": "0", "CreationDate": "2018-02-14T17:45:10.097", "ParentId": "48790111", "CommentCount": "8", "OwnerUserId": "5632316", "LastEditDate": "2018-02-14T17:56:30.200"}, "48790777": {"Id": "48790777", "PostTypeId": "2", "Body": "<p>I can find no wording in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"noreferrer\">n4296</a> (draft C++14 standard) which would make this legal.  What is more, I cannot <em>even</em> find any wording that given:</p>\n<pre><code>union Big2 {\n    Hdr h;\n\n    A a;\n    B b;\n    C c;\n    D d;\n    E e;\n    F f;\n};\n</code></pre>\n<p>we can <code>reinterpret_cast</code> a reference to <code>Big</code> into a reference to <code>Big2</code> and then use the reference.  (Note that <code>Big</code> and <code>Big2</code> are <em>layout-compatible</em>.)</p>\n", "LastActivityDate": "2018-02-14T15:31:05.543", "Score": "4", "CreationDate": "2018-02-14T15:31:05.543", "ParentId": "48790111", "CommentCount": "1", "OwnerUserId": "771073"}, "48793660": {"Id": "48793660", "PostTypeId": "2", "Body": "<p>To be able to take a pointer to A, and reinterpret it as a pointer to B, they must be <em>pointer-interconvertible</em>.</p>\n<p>Pointer-interconvertible is about <em>objects</em>, not <em>types of objects</em>.</p>\n<p>In C++, there are objects at places.  If you have a <code>Big</code> at a particular spot with at least one member existing, there is also a <code>Hdr</code> at that same spot due to pointer interconvertability.</p>\n<p>However there is no <code>Little</code> object at that spot.  If there is no <code>Little</code> object there, it cannot be pointer-interconvertible with a <code>Little</code> object that isn't there.</p>\n<p>They appear to be <em>layout-compatible</em>, assuming they are flat data (plain old data, trivially copyable, etc).</p>\n<p>This means you can copy their <em>byte representation</em> and it works.  In fact, optimizers seem to understand that a memcpy to a stack local buffer, a placement new (with trivial constructor), then a memcpy back is actually a noop.</p>\n<pre><code>template&lt;class T&gt;\nT* laundry_pod( void* data ) {\n  static_assert( std::is_pod&lt;Data&gt;{}, \"POD only\" ); // could be relaxed a bit\n  char buff[sizeof(T)];\n  std::memcpy( buff, data, sizeof(T) );\n  T* r = ::new( data ) T;\n  std::memcpy( data, buff, sizeof(T) );\n  return r;\n}\n</code></pre>\n<p>the above function is a noop at runtime (in an optimized build), yet it converts T-layout-compatible data at <code>data</code> to an actual <code>T</code>.</p>\n<p>So, if I am right and <code>Big</code> and <code>Little</code> are layout-compatible when <code>Big</code> is a subtype of the types in <code>Little</code>, you can do this:</p>\n<pre><code>Little* inplace_to_little( Big* big ) {\n  return laundry_pod&lt;Little&gt;(big);\n}\nBig* inplace_to_big( Little* big ) {\n  return laundry_pod&lt;Big&gt;(big);\n}\n</code></pre>\n<p>or</p>\n<pre><code>void given_big(Big&amp; big) { // cannot be const\n  switch(big.h.type) {\n  case B::type: // fallthrough\n  case C::type:\n    auto* little = inplace_to_little(&amp;big); // replace Big object with Little inplace\n    given_b_or_c(*little); \n    inplace_to_big(little); // revive Big object.  Old references are valid, barring const data or inheritance\n    break;\n  // ... other cases here ...\n  }\n}\n</code></pre>\n<p>if <code>Big</code> has non-flat data (like references or <code>const</code> data), the above breaks horribly.</p>\n<p>Note that <code>laundry_pod</code> doesn't do any memory allocation; it uses placement new that constructs a <code>T</code> in the place where <code>data</code> points using the bytes at <code>data</code>.  And while it looks like it is doing lots of stuff (copying memory around), it optimizes to a noop.</p>\n<hr>\n<p><a class=\"post-tag\" href=\"/questions/tagged/c%2b%2b\" rel=\"tag\" title=\"show questions tagged 'c++'\">c++</a> has a concept of \"an object exists\".  The existence of an object has almost nothing to do with what bits or bytes are written in the physical or abstract machine.  There is no instruction on your binary that corresponds to \"now an object exists\".</p>\n<p>But the language has this concept.</p>\n<p>Objects that don't exist cannot be interacted with.  If you do so, the C++ standard does not define the behavior of your program.</p>\n<p>This permits the optimizer to make assumptions about what your code does and what it doesn't do and which branches cannot be reached and which can be reached.  It lets the compiler make no-aliasing assumptions; modifying data through a pointer or reference to A <em>cannot</em> change data reached through a pointer or reference to B unless somehow both A and B exist in the same spot.</p>\n<p>The compiler can prove that <code>Big</code> and <code>Little</code> objects cannot both exist in the same spot.  So no modification of any data through a pointer or reference to <code>Little</code> could modify anything existing in a variable of type <code>Big</code>.  And vice versa.</p>\n<p>Imagine if <code>given_b_or_c</code> modifies a field.  Well the compiler could inline <code>given_big</code> and <code>given_b_or_c</code> and <code>use_a_b</code>, notice that no instance of <code>Big</code> is modified (just an instance of <code>Little</code>), and prove that fields of data from <code>Big</code> it cached prior to calling your code could not be modified.</p>\n<p>This saves it a load instruction, and the optimizer is quite happy.  But now you have code that reads:</p>\n<pre><code>Big b = whatever;\nb.foo = 7;\n((Little&amp;)b).foo = 4;\nif (b.foo!=4) exit(-1);\n</code></pre>\n<p>that is optimzied to</p>\n<pre><code>Big b = whatever;\nb.foo = 7;\n((Little&amp;)b).foo = 4;\nexit(-1);\n</code></pre>\n<p>because it can prove that <code>b.foo</code> must be <code>7</code> it was set once and never modified.  The access through <code>Little</code> could not modify the <code>Big</code> due to aliasing rules.</p>\n<p>Now do this:</p>\n<pre><code>Big b = whatever;\nb.foo = 7;\n(*laundry_pod&lt;Little&gt;(&amp;b)).foo = 4;\nBig&amp; b2 = *laundry_pod&lt;Big&gt;(&amp;b);\nif (b2.foo!=4) exit(-1);\n</code></pre>\n<p>and it the assume that the big there was unchanged, because there is a memcpy and a <code>::new</code> that could legally change the state of the data.  No strict aliasing violation.</p>\n<p>It can still follow the <code>memcpy</code> and eliminate it.</p>\n<p><a href=\"https://godbolt.org/g/QZAk7S\" rel=\"nofollow noreferrer\">Live example</a> of <code>laundry_pod</code> being optimized away.  Note that if it wasn't optimized away, the code would have to have a conditional and a printf.  But because it was, it was optimized into the empty program.</p>\n</hr>", "LastEditorUserId": "5632316", "LastActivityDate": "2018-02-15T13:00:58.977", "Score": "17", "CreationDate": "2018-02-14T18:09:50.800", "ParentId": "48790111", "CommentCount": "2", "OwnerUserId": "1774667", "LastEditDate": "2018-02-15T13:00:58.977"}});