post_cb({"7501218": {"ParentId": "7501146", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2011-09-21T14:07:51.283", "Score": "1", "LastEditorUserId": "649233", "LastEditDate": "2011-09-21T15:03:19.093", "Id": "7501218", "OwnerUserId": "649233", "Body": "<p>This type of operation is actually the basis for implementing the constant reoccurring template pattern, where inside the base-class you actually <code>static_cast</code> the <code>this</code> pointer of the base-class to the derived-class template type.  Since <code>S</code> is an unambiguous base class of <code>T</code>, and you are not accessing any members from the <code>static_cast</code> that are not already members of <code>S</code>, I don't see why you would encounter any issues.</p>\n<p>Section 5.2.8 on static casting in paragraph 5 states:</p>\n<blockquote>\n<p id=\"so_7501146_7501218_0\">An lvalue of type \u201c<em>cv1</em> B\u201d, where B is a class type, can be cast to type \u201creference to <em>cv2</em> D\u201d, where D is a class derived (clause 10) from B, if a valid standard conversion from \u201cpointer to D\u201d to \u201cpointer to B\u201d exists (4.10), <em>cv2</em> is the same cv-qualification as, or greater cv-qualification than, <em>cv1</em>, and B is not a virtual base class of D. The result is an lvalue of type \u201c<em>cv2</em> D.\u201d If the lvalue of type \u201c<em>cv1</em> B\u201d is actually a sub-object of an object of type D, the lvalue refers to the enclosing object of type D. Otherwise, the result of the cast is undefined.</p>\n</blockquote>\n<p>You seem to be meeting all the requirements that avoid undefined behavior.  That is:</p>\n<ol>\n<li>Class <code>T</code> is derived from <code>S</code></li>\n<li>A pointer conversion from <code>S</code> to <code>T</code> does exist since <code>S</code> is both accessible and an unambiguous base-class of <code>T</code> (requirements from 4.10)</li>\n<li>You are using the same constant-value-qualification for both types</li>\n<li><code>S</code> is not a virtual base-class of <code>T</code></li>\n</ol>\n", "LastActivityDate": "2011-09-21T15:03:19.093"}, "bq_ids": {"n4140": {"so_7501146_7501218_0": {"section_id": 6028, "quality": 0.75, "length": 39}}, "n3337": {"so_7501146_7501218_0": {"section_id": 5796, "quality": 0.7884615384615384, "length": 41}}, "n4659": {"so_7501146_7501218_0": {"section_id": 7527, "quality": 0.6346153846153846, "length": 33}}}, "7501146": {"CommentCount": "6", "AcceptedAnswerId": "7501218", "CreationDate": "2011-09-21T14:03:01.137", "LastActivityDate": "2011-09-21T15:03:19.093", "PostTypeId": "1", "ViewCount": "78", "FavoriteCount": "1", "Title": "what standard says about static casting to temporary inheritor?", "Id": "7501146", "Score": "2", "Body": "<p>sometimes (quite rarely) I need to get protected members from existing variables\nlike this:</p>\n<pre><code>struct S {\nprotected:\n int i;\n};\n\nstruct T : S {\n using S::i;\n};\n\nint main() {\n S s;\n static_cast&lt;T&amp;&gt;(s).i = 0;\n}\n</code></pre>\n<p>I'm almost sure this  ( static_cast(s) )  is UB, but is someone know what the C++ standard (2003) says about this situation?</p>\n", "Tags": "<c++><inheritance><protected><standards><undefined-behavior>", "OwnerUserId": "616363", "AnswerCount": "1"}});