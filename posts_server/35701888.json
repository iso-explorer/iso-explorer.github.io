post_cb({"35702213": {"ParentId": "35701888", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>The problem isn't the template declaration. This is perfectly fine:</p>\n<pre><code>template &lt;typename... Tp, size_t begin = 0U&gt;\nvoid foo(tuple&lt;Tp...&gt; t);\n</code></pre>\n<p>The problem is this call:</p>\n<pre><code>foo&lt;Tp..., begin + 1&gt;(t);\n</code></pre>\n<p>While you <em>can</em> provide a defaulted template argument after a parameter pack, you have no way of actually setting it later. The compiler has no way of knowing where the pack ends and the argument after the pack begins.</p>\n<p>You should flip the ordering to put <code>begin</code> as the first argument, defaulted:</p>\n<pre><code>template &lt;size_t begin = 0U, typename... Tp&gt;\nvoid foo(tuple&lt;Tp...&gt; t);\n</code></pre>\n<p>so that your recursive call can be:</p>\n<pre><code>foo&lt;begin + 1&gt;(t);\n</code></pre>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2016-02-29T14:59:47.873", "Id": "35702213", "Score": "7", "CreationDate": "2016-02-29T14:34:32.063", "LastActivityDate": "2016-02-29T14:59:47.873"}, "35701888": {"CommentCount": "0", "ViewCount": "171", "PostTypeId": "1", "LastEditorUserId": "2069064", "CreationDate": "2016-02-29T14:19:20.693", "LastActivityDate": "2016-03-08T12:44:15.190", "Title": "Do Variadic Template Parameters Always Have to be Last?", "AcceptedAnswerId": "35702345", "LastEditDate": "2016-02-29T15:03:30.903", "Id": "35701888", "Score": "2", "Body": "<p>Do I always have to place variadic template parameters at the end of my template parameters? </p>\n<pre><code>template &lt;size_t begin = 0U, typename... Tp&gt;\nvoid foo(tuple&lt;Tp...&gt; t);\n</code></pre>\n<p>For example I get all kinds of errors with this:</p>\n<pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;tuple&gt;\nusing namespace std;\n\ntemplate &lt;typename... Tp, size_t begin = 0U&gt;\nenable_if_t&lt;begin == sizeof...(Tp), void&gt; foo(tuple&lt;Tp...&gt;&amp; t){\n    cout &lt;&lt; endl;\n}\n\ntemplate &lt;typename... Tp, size_t begin = 0U&gt;\nenable_if_t&lt;begin &lt; sizeof...(Tp), void&gt; foo(tuple&lt;Tp...&gt;&amp; t) {\n    cout &lt;&lt; get&lt;begin&gt;(t) &lt;&lt; ' ';\n    foo&lt;Tp..., begin + 1&gt;(t);\n}\n\nint main() {\n    tuple&lt;int, string, float&gt; t = make_tuple(42, \"Jonathan Mee\", 13.13);\n\n    foo(t);\n}\n</code></pre>\n<p>When <a href=\"http://ideone.com/Py0hW7\" rel=\"nofollow\">run on gcc 5.1</a> gives me:</p>\n<blockquote>\n<p id=\"so_35701888_35701888_0\">prog.cpp: In instantiation of <code>std::enable_if_t&lt;(begin &lt; sizeof... (Tp)), void&gt; foo(std::tuple&lt;_Elements ...&gt;&amp;) [with Tp = {int, std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, float}; unsigned int begin = 0u; std::enable_if_t&lt;(begin &lt; sizeof... (Tp)), void&gt; = void]</code>:<br>\n  prog.cpp:21:7:   required from here<br>\n  prog.cpp:15:23: error: no matching function for call to <code>foo(std::tuple&lt;int, std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;, float&gt;&amp;)</code><br>\n<code>foo&lt;Tp..., begin + 1&gt;(t);</code><br>\n<br>\n  prog.cpp:8:43: note: candidate: <code>template&lt;class ... Tp, unsigned int begin&gt; std::enable_if_t&lt;(begin == sizeof... (Tp)), void&gt; foo(std::tuple&lt;_Elements ...&gt;&amp;)</code><br>\n<code>enable_if_t&lt;begin == sizeof...(Tp), void&gt; foo(tuple&lt;Tp...&gt;&amp; t){</code><br>\n<br>\n  prog.cpp:8:43: note:   template argument deduction/substitution failed:<br>\n  prog.cpp:13:42: note: candidate: <code>template&lt;class ... Tp, unsigned int begin&gt; std::enable_if_t&lt;(begin &lt; sizeof... (Tp)), void&gt; foo(std::tuple&lt;_Elements ...&gt;&amp;)</code><br>\n<code>enable_if_t&lt;begin &lt; sizeof...(Tp), void&gt; foo(tuple&lt;Tp...&gt;&amp; t) {</code><br>\n<br>\n  prog.cpp:13:42: note:   template argument deduction/substitution failed:<br/></br></br></br></br></br></br></br></br></br></br></br></br></p>\n</blockquote>\n<p>When the arguments are swapped to:</p>\n<pre><code>template &lt;size_t begin = 0U, typename... Tp&gt;\nvoid foo(tuple&lt;Tp...&gt; t);\n</code></pre>\n<p>The program runs correctly: <a href=\"http://ideone.com/SozUbb\" rel=\"nofollow\">http://ideone.com/SozUbb</a></p>\n<p>If this is really a requirement that variadic template parameters be last can someone give me a source on this information?</p>\n", "Tags": "<c++><templates><parameters><order><variadic-templates>", "OwnerUserId": "2642059", "AnswerCount": "3"}, "35702345": {"ParentId": "35701888", "PostTypeId": "2", "CommentCount": "16", "Body": "<p>You are wrong -- variardic arguments doesn't have to be last -- but it doesn't help you.</p>\n<p>Your error is in the recursive call, when you try to set <code>begin</code> to be something different than <code>0</code>.  In that line, the compiler cannot figure out that your <code>begin</code> is supposed to be the <code>std::size_t</code> parameter, and bails out.</p>\n<p>This compiles fine even in gcc 5.1:</p>\n<pre><code>template &lt;class... Tp, std::size_t begin = 0U&gt;\nauto foo(std::tuple&lt;Tp...&gt;&amp; t) -&gt; std::enable_if_t&lt;begin == sizeof...(Tp), void&gt; {\n  std::cout &lt;&lt; '\\n';\n}\n\ntemplate &lt;class... Tp, std::size_t begin = 0U&gt;\nauto foo(std::tuple&lt;Tp...&gt;&amp; t) -&gt; std::enable_if_t&lt;begin &lt; sizeof...(Tp), void&gt; {\n  std::cout &lt;&lt; '\\n';\n}\n</code></pre>\n<p>(I rewrote it to figure out where it was going wrong, so it is slightly different in unimportant ways).</p>\n<p>The important way it differs it the lack of recursive call.</p>\n<p>As an aside, your printing code is a bit awkward.  Consider using something like <code>for_each_arg</code>:</p>\n<pre><code>template&lt;class F, class...Args&gt;\nvoid for_each_arg(F&amp;&amp; f, Args&amp;&amp;...args) {\n  using discard=int[];\n  (void)discard{((\n    f(std::forward&lt;Args&gt;(args))\n  ),void(),0)...,0};\n}\n</code></pre>\n<p>either mix the above with <code>std::apply</code> or write your own:</p>\n<pre><code>namespace details {\n  template&lt;class F, class Tuple, std::size_t...Is&gt;\n  decltype(auto) apply( std::index_sequence&lt;Is...&gt;, F&amp;&amp; f, Tuple&amp;&amp; args )\n  {\n    return std::forward&lt;F&gt;(f)( std::get&lt;Is&gt;(std::forward&lt;Tuple&gt;(args))... );\n  }\n}\ntemplate&lt;class F, class Tuple&gt;\ndecltype(auto) apply(F&amp;&amp; f, Tuple&amp;&amp; tuple) {\n  using dTuple = std::decay_t&lt;Tuple&gt;;\n  return details::apply(\n    std::make_index_sequence&lt;std::tuple_size&lt;dTuple&gt;::value&gt;{},\n    std::forward&lt;F&gt;(f),\n    std::forward&lt;Tuple&gt;(tuple)\n  );\n}\n\ntemplate&lt;class F, class Tuple&gt;\ndecltype(auto) for_each_tuple_element( F&amp;&amp; f, Tuple&amp;&amp; tuple ) {\n  return apply(\n    [&amp;](auto&amp;&amp;...args){\n      for_each_arg( std::forward&lt;F&gt;(f), decltype(args)(args)... );\n    },\n    std::forward&lt;Tuple&gt;(tuple)\n  );\n}\n</code></pre>\n<p>and now you don't have a recursion depth equal to the number of elements in your tuple.</p>\n<pre><code>template &lt;class Tuple&gt;\nvoid foo(Tuple&amp;&amp; tuple) {\n  for_each_tuple_element(\n    [](auto&amp;&amp; arg){ std::cout &lt;&lt; decltype(arg)(arg); },\n    std::forward&lt;Tuple&gt;(tuple)\n  );\n  std::cout &lt;&lt; '\\n';\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/d9a29289470742cc\" rel=\"nofollow\">live example</a>.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2016-03-08T12:44:15.190", "Id": "35702345", "Score": "3", "CreationDate": "2016-02-29T14:40:35.733", "LastActivityDate": "2016-03-08T12:44:15.190"}, "bq_ids": {"n4140": {"so_35701888_35701958_0": {"section_id": 64, "quality": 1.0, "length": 29}}, "n3337": {"so_35701888_35701958_0": {"section_id": 59, "quality": 0.896551724137931, "length": 26}}, "n4659": {"so_35701888_35701958_0": {"section_id": 66, "quality": 1.0, "length": 29}}}, "35701958": {"ParentId": "35701888", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>According to the standard <em>\u00a714.1/11 Template parameters [temp.param]:</em></p>\n<blockquote>\n<p id=\"so_35701888_35701958_0\"><em>If a template-parameter of a primary class template or alias template is a template parameter pack, it shall be the last template-parameter. A template parameter pack of a function template shall not be followed by another template parameter unless that template parameter can be deduced from the parameter-type-list\n  of the function template or has a default argument.</em></p>\n</blockquote>\n<p>Thus your setting is correct since variadic argument is followed by a default template argument. However, you have a syntax error, you should change to:</p>\n<pre><code>template &lt;typename... Tp, size_t begin = 0U&gt;\n                  ^^^^^^\nvoid foo(tuple&lt;Tp...&gt; t);\n</code></pre>\n<p>That is, in the template argument list <code>...</code> must preceed <code>Tp</code>.</p>\n", "OwnerUserId": "2352671", "LastEditorUserId": "2352671", "LastEditDate": "2016-02-29T14:51:18.300", "Id": "35701958", "Score": "1", "CreationDate": "2016-02-29T14:24:04.847", "LastActivityDate": "2016-02-29T14:51:18.300"}});