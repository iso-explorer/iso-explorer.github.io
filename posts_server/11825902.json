post_cb({"11826981": {"Id": "11826981", "PostTypeId": "2", "Body": "<p>You can define member functions either inside the class, or after the class declaration, or some of each. </p>\n<p>To get some consistency <em>here</em>, the rules for a class with functions defined inline is that it still has to be compiled as if the functions were defined <em>after</em> the class.</p>\n<p>Your code</p>\n<pre><code>class C {\n     static void foo()\n     {\n         C::bar();   // works just fine \n     }\n\n     static void bar()\n     {     }\n }; \n</code></pre>\n<p>compiles the same as</p>\n<pre><code>class C {\n     static void foo();\n     static void bar();\n }; \n\n void C::foo()\n {  C::bar();  }\n\n void C::bar()\n {     }\n</code></pre>\n<p>and now there is no magic in the visibility, because the functions can all see everything declared in the class.</p>\n", "LastEditorUserId": "597607", "LastActivityDate": "2012-08-06T11:12:26.367", "Score": "3", "CreationDate": "2012-08-06T10:59:41.280", "ParentId": "11825902", "CommentCount": "0", "OwnerUserId": "597607", "LastEditDate": "2012-08-06T11:12:26.367"}, "11826072": {"Id": "11826072", "PostTypeId": "2", "Body": "<p>I'm not sure but my thought is that a <code>class</code> is somewhat an <em>object</em> (badly used) where all its internal components work together (generally speaking), its member will definitely need its methods.</p>\n<p>But a namespace is different, functions are not related. It means that a function isnt intended to work with every other functions inside the namespace.</p>\n<p>So splitting declaration and definitions is the best thing you could do.</p>\n<p>If <code>foo()</code> needs <code>bar()</code> its most likely going to be in the same declaration file, and would work that way</p>\n", "LastEditorUserId": "1294388", "LastActivityDate": "2012-08-06T10:05:12.277", "Score": "0", "CreationDate": "2012-08-06T09:57:57.470", "ParentId": "11825902", "CommentCount": "0", "OwnerUserId": "1294388", "LastEditDate": "2012-08-06T10:05:12.277"}, "11825902": {"ViewCount": "143", "Body": "<pre><code>void foo()\n{\n    bar();          // error: \u2018bar\u2019 has not been declared\n}\n\nvoid bar()\n{\n}\n\nnamespace N\n{\n    void foo()\n    {\n        N::bar();   // error: \u2018bar\u2019 is not a member of \u2018N\u2019\n    }\n\n    void bar()\n    {\n    }\n}\n\nclass C\n{\n    static void foo()\n    {\n        C::bar();   // works just fine\n    }\n\n    static void bar()\n    {\n    }\n};\n</code></pre>\n<p>What is the rationale behind this inconsistency of treating calls to functions above their declaration? How come I can do it inside a class, but not inside a namespace or at global scope?</p>\n", "AcceptedAnswerId": "11826981", "Title": "calling functions above their declaration", "CreationDate": "2012-08-06T09:46:59.123", "Id": "11825902", "CommentCount": "3", "FavoriteCount": "5", "PostTypeId": "1", "LastActivityDate": "2012-08-06T11:12:26.367", "Score": "6", "OwnerUserId": "252000", "Tags": "<c++><class><namespaces><scope><forward-declaration>", "AnswerCount": "5"}, "11825982": {"Id": "11825982", "PostTypeId": "2", "Body": "<p>Well maybe because you have your class declaration in one place, and the compiler can easily obtain the information of it's members.</p>\n<p>A namespace, on the other hand, can have it's stuff in tons of different files, and you can't expect the compiler to look through them, because it doesn't know where to look in the first place.</p>\n<p>To avoid this, just use <a href=\"http://en.wikipedia.org/wiki/Function_prototype\" rel=\"nofollow\">function prototypes</a>.</p>\n", "LastEditorUserId": "1490355", "LastActivityDate": "2012-08-06T10:00:39.943", "Score": "0", "CreationDate": "2012-08-06T09:52:26.830", "ParentId": "11825902", "CommentCount": "0", "OwnerUserId": "1490355", "LastEditDate": "2012-08-06T10:00:39.943"}, "bq_ids": {"n4140": {"so_11825902_11827016_1": {"length": 36, "quality": 0.9473684210526315, "section_id": 7070}, "so_11825902_11827016_2": {"length": 15, "quality": 1.0, "section_id": 7070}}, "n3337": {"so_11825902_11827016_1": {"length": 34, "quality": 0.8947368421052632, "section_id": 6814}, "so_11825902_11827016_2": {"length": 15, "quality": 1.0, "section_id": 6814}}, "n4659": {"so_11825902_11827016_1": {"length": 29, "quality": 0.7631578947368421, "section_id": 8567}, "so_11825902_11827016_2": {"length": 15, "quality": 1.0, "section_id": 8568}}}, "11826291": {"Id": "11826291", "PostTypeId": "2", "Body": "<ol>\n<li><p>Namespaces can be reopened and new things can be added in any place.\nClasses cannot be reopened - all their contents must be put in\nsingle place.</p></li>\n<li><p>Function prototypes are legal in namespaces but not in classes.</p></li>\n</ol>\n<p>You can write  </p>\n<pre><code>namespace n\n{\n    void foo();\n\n    void bar()\n    {\n        foo();\n    }\n\n    void foo()\n    {\n    }\n}\n</code></pre>\n<p>But not  </p>\n<pre><code>class C\n{\n    void foo();\n\n    void bar()\n    {\n        foo();\n    }\n\n    void foo()\n    {\n    }\n}\n</code></pre>\n<p>So classes need such feature much more and it is much easier to implement it for them than for namespaces.</p>\n", "LastActivityDate": "2012-08-06T10:13:27.420", "CommentCount": "0", "CreationDate": "2012-08-06T10:13:27.420", "ParentId": "11825902", "Score": "1", "OwnerUserId": "113662"}, "11827016": {"Id": "11827016", "PostTypeId": "2", "Body": "<p>See the quote below from the Standard</p>\n<blockquote>\n<p id=\"so_11825902_11827016_0\"><strong>3.3.7 Class scope [basic.scope.class]</strong> </p>\n<p id=\"so_11825902_11827016_1\">1) The following rules describe the scope of names declared in classes. 1) The potential\n  scope of a name declared in a class consists not only of the\n  declarative region following the name\u2019s point of declaration, but also\n  of all function bodies, default arguments, and\n  brace-or-equalinitializers of non-static data members in that class\n  (including such things in nested classes).</p>\n<p id=\"so_11825902_11827016_2\">2) A name N used in a class S shall refer to the same declaration in its context and when re-evaluated in\n  the completed scope of S. No diagnostic is required for a violation of this rule.</p>\n</blockquote>\n<pre><code>typedef int c;\nenum { i = 1 };\n\nclass X {\n     char v[i]; // error: i refers to ::i\n                // but when reevaluated is X::i\n     int f() { return sizeof(c); } // OK: X::c\n     char c;\n     enum { i = 2 };\n};\n</code></pre>\n", "LastActivityDate": "2012-08-06T11:01:50.733", "CommentCount": "0", "CreationDate": "2012-08-06T11:01:50.733", "ParentId": "11825902", "Score": "0", "OwnerUserId": "819272"}});