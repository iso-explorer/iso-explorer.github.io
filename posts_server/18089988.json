post_cb({"18089988": {"CommentCount": "4", "AcceptedAnswerId": "18090865", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-08-06T20:37:03.697", "LastActivityDate": "2013-08-10T12:07:51.977", "LastEditDate": "2017-05-23T10:25:26.003", "ViewCount": "424", "FavoriteCount": "1", "Title": "Should initialization by conversion function be ambiguous when two candidates have the same cv-qualification?", "Id": "18089988", "Score": "14", "Body": "<p>Both clang and gcc accept the following code and choose <code>A::operator B*</code>.</p>\n<pre><code>struct B\n{\n};\n\nstruct A : B\n{\n    operator A*();\n    operator B*();\n};\n\nA a;\nvoid* x = a;\n</code></pre>\n<p>My reading of the standard - specifically sentences highlighted below in bold - suggests that this conversion should be ambiguous.</p>\n<p>Both <code>A::operator A*</code> and <code>A::operator B*</code> are candidates for overload resolution because <code>A*</code> and <code>B*</code> are both convertible to <code>void*</code> via a standard conversion. Because the implied object parameter <code>A&amp;</code> is the only argument, only the conversion sequence that converts from the implied object argument to the implied object parameter is considered - the type yielded by the conversion function is ignored. In both cases, the implied object argument is the initializer expression's type <code>A</code>, and the implied object parameter is <code>A&amp;</code>. If both conversion sequences are identical, there is no way to distinguish between the two candidates.</p>\n<blockquote>\n<p id=\"so_18089988_18089988_0\">8.5 Initializers [dcl.init]</p>\n<p id=\"so_18089988_18089988_1\">The semantics of initializers are as follows. The <em>destination type</em> is the type of the object or reference being\n  initialized and the <em>source type</em> is the type of the initializer expression. </p>\n<p id=\"so_18089988_18089988_2\">\u2014 If the destination type is a [<em>reference/array/class</em>...] [deleted details not applicable to this scenario]</p>\n<p id=\"so_18089988_18089988_3\">\u2014 Otherwise, if the source type is a (possibly cv-qualified) class type, conversion functions are considered.\n  <strong>The applicable conversion functions are enumerated (13.3.1.5), and the best one is chosen through overload\n  resolution (13.3)</strong>. The user-defined conversion so selected is called to convert the initializer\n  expression into the object being initialized. <strong>If the conversion cannot be done or is ambiguous, the\n  initialization is ill-formed.</strong></p>\n<p id=\"so_18089988_18089988_4\">13.3.1.5 Initialization by conversion function [over.match.conv]</p>\n<p id=\"so_18089988_18089988_5\">Under the conditions specified in 8.5, as part of an initialization of an object of nonclass type, a conversion\n  function can be invoked to convert an initializer expression of class type to the type of the object being\n  initialized. <strong>Overload resolution is used to select the conversion function to be invoked.</strong> Assuming that \u201ccv1\n  T\u201d is the type of the object being initialized, and \u201ccv S\u201d is the type of the initializer expression, with S a\n  class type, the candidate functions are selected as follows:</p>\n<p id=\"so_18089988_18089988_6\">\u2014 The conversion functions of S and its base classes are considered. <strong>Those non-explicit conversion\n  functions that are not hidden within S and yield type T or a type that can be converted to type T\n  via a standard conversion sequence (13.3.3.1.1) are candidate functions.</strong> For direct-initialization, those\n  explicit conversion functions that are not hidden within S and yield type T or a type that can be\n  converted to type T with a qualification conversion (4.4) are also candidate functions. Conversion\n  functions that return a cv-qualified type are considered to yield the cv-unqualified version of that type\n  for this process of selecting candidate functions. Conversion functions that return \u201creference to cv2\n  X\u201d return lvalues or xvalues, depending on the type of reference, of type \u201ccv2 X\u201d and are therefore\n  considered to yield X for this process of selecting candidate functions.</p>\n<p id=\"so_18089988_18089988_7\"><strong>The argument list has one argument, which is the initializer expression.</strong> [ Note: This argument will be\n  compared against the implicit object parameter of the conversion functions. \u2014end note ]</p>\n</blockquote>\n<p>Is this ambiguous according to the standard?</p>\n<p>EDIT: note that this is a similar question, but not the same as <a href=\"https://stackoverflow.com/questions/11555950/distinguishing-between-user-defined-conversion-sequences-by-the-initial-standard?rq=1\">Distinguishing between user-defined conversion sequences by the initial standard conversion sequence</a></p>\n<p>The difference being that in my example both conversion functions have the same qualification.</p>\n", "Tags": "<c++><initialization><standards><overloading><language-lawyer>", "OwnerUserId": "1690864", "AnswerCount": "1"}, "18090865": {"ParentId": "18089988", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2013-08-06T21:31:07.687", "Score": "9", "LastEditorUserId": "923854", "LastEditDate": "2013-08-07T19:08:13.430", "Id": "18090865", "OwnerUserId": "923854", "Body": "<p>TLDR: When everything else is equal, overload resolution breaks the tie by which conversion function has the best conversion from its return value to the target type.</p>\n<hr>\n<p>All references are to ISO/IEC 14882:2011 (C++11). The behavior of the initialization:</p>\n<pre><code>void* x = a;\n</code></pre>\n<p>is defined as follows. First, this <em>is</em> an initialization as described in 8.5 Initializers [dcl.init] and conforms to the grammar described in p1. Since the destination type <code>void*</code> is a non-class type, and the source type <code>A</code> <em>is</em> a class type, this specific initializer is of the form described in 8.5 p16, bullet 7:</p>\n<blockquote>\n<p id=\"so_18089988_18090865_0\">Otherwise, if the source type is a (possibly cv-qualified) class type, conversion functions are considered. The applicable conversion functions are enumerated (13.3.1.5), and the best one is chosen through overload resolution (13.3). The user-defined conversion so selected is called to convert the initializer expression into the object being initialized. If the conversion cannot be done or is ambiguous, the initialization is ill-formed.</p>\n</blockquote>\n<p>The \"enumeration of applicable conversion functions\" is detailed in 13.3.1.5 p1:</p>\n<blockquote>\n<p id=\"so_18089988_18090865_1\">Under the conditions specified in 8.5, as part of an initialization of an object of nonclass type, a conversion\n  function can be invoked to convert an initializer expression of class type to the type of the object being\n  initialized. Overload resolution is used to select the conversion function to be invoked. Assuming that \u201ccv1\n  T\u201d is the type of the object being initialized, and \u201ccv S\u201d is the type of the initializer expression, with S a\n  class type, the candidate functions are selected as follows:</p>\n<ul>\n<li>The conversion functions of S and its base classes are considered. Those non-explicit conversion\n  functions that are not hidden within S and yield type T or a type that can be converted to type T\n  via a standard conversion sequence (13.3.3.1.1) are candidate functions. For direct-initialization, those\n  explicit conversion functions that are not hidden within S and yield type T or a type that can be\n  converted to type T with a qualification conversion (4.4) are also candidate functions. Conversion\n  functions that return a cv-qualified type are considered to yield the cv-unqualified version of that type\n  for this process of selecting candidate functions. Conversion functions that return \u201creference to cv2\n  X\u201d return lvalues or xvalues, depending on the type of reference, of type \u201ccv2 X\u201d and are therefore\n  considered to yield X for this process of selecting candidate functions.</li>\n</ul>\n</blockquote>\n<p>Note that both <code>A::operator A*()</code> and <code>A::operator B*()</code> are candidate functions, since both <code>A*</code> and <code>B*</code> are convertible to <code>void*</code> per\n4.10p2: \"A prvalue of type \u201cpointer to cv <code>T</code>,\u201d where <code>T</code> is an object type, can be converted to a prvalue of type \u201cpointer\nto cv <code>void</code>\u201d.\" Given that both functions are candidates, overload resolution must choose between them.</p>\n<p>Overload resolution is decribed in 13.3 [over.match]. p2 states:</p>\n<blockquote>\n<p id=\"so_18089988_18090865_2\">Overload resolution selects the function to call in seven distinct contexts within the language:</p>\n<p id=\"so_18089988_18090865_3\">...</p>\n<ul>\n<li>invocation of a conversion function for initialization of an object of a nonclass type from an expression of class type (13.3.1.5)</li>\n</ul>\n<p id=\"so_18089988_18090865_4\">...</p>\n<p id=\"so_18089988_18090865_5\">Each of these contexts defines the set of candidate functions and the list of arguments in its own unique way. But, once the candidate functions and argument lists have been identified, the selection of the best function is the same in all cases:</p>\n<ul>\n<li><p id=\"so_18089988_18090865_6\">First, a subset of the candidate functions (those that have the proper number of arguments and meet certain other conditions) is selected to form a set of viable functions (13.3.2).</p></li>\n<li><p id=\"so_18089988_18090865_7\">Then the best viable function is selected based on the implicit conversion sequences (13.3.3.1) needed to match each argument to the corresponding parameter of each viable function.</p></li>\n</ul>\n</blockquote>\n<p>Which of our two functions are viable? 13.3.2 [over.match.viable] p1:</p>\n<blockquote>\n<p id=\"so_18089988_18090865_8\">From the set of candidate functions constructed for a given context (13.3.1), a set of viable functions is\n  chosen, from which the best function will be selected by comparing argument conversion sequences for the\n  best fit (13.3.3).</p>\n</blockquote>\n<p>The requirements are presented in p2:</p>\n<blockquote>\n<p id=\"so_18089988_18090865_9\">First, to be a viable function, a candidate function shall have enough parameters to agree in number with\n  the arguments in the list.</p>\n</blockquote>\n<p>and p3:</p>\n<blockquote>\n<p id=\"so_18089988_18090865_10\">Second, for <code>F</code> to be a viable function, there shall exist for each argument an implicit conversion sequence\n  (13.3.3.1) that converts that argument to the corresponding parameter of <code>F</code>.</p>\n</blockquote>\n<p>Both requirements are trivially met by our conversion functions: they have a single (implicit) argument of the same type as the initializer expression <code>a</code>.</p>\n<p>Determination of the <em>best</em> of the viable functions is described in 13.3.3 [over.match.best]. It defines some formalisms for describing <em>conversion sequences</em>, sequences of operations necessary to convert from the types of the actual function arguments to the types of the formal function parameters. In the case of our conversion functions, they both have exactly one parameter whose type is exactly that of the actual argument, so the \"conversion sequence\" corresponding to each overload is the identity sequence. They are discriminated by the language in p1:</p>\n<blockquote>\n<p id=\"so_18089988_18090865_11\">Given these definitions, a viable function <code>F1</code> is defined to be a <em>better</em> function than another viable function <code>F2</code> if for all arguments <code>i</code>, <code>ICSi(F1)</code> is not a worse conversion sequence than <code>ICSi(F2)</code>, and then</p>\n<ul>\n<li><p id=\"so_18089988_18090865_12\">for some argument <code>j</code>, <code>ICSj(F1)</code> is a better conversion sequence than <code>ICSj(F2)</code>, or, if not that,</p></li>\n<li><p id=\"so_18089988_18090865_13\">the context is an initialization by user-defined conversion (see 8.5, 13.3.1.5, and 13.3.1.6) and the\n  standard conversion sequence from the return type of <code>F1</code> to the destination type (i.e., the type of the\n  entity being initialized) is a better conversion sequence than the standard conversion sequence from\n  the return type of <code>F2</code> to the destination type.</p></li>\n</ul>\n</blockquote>\n<p>What about that final bullet? Does one of our overloads have a better standard conversion sequence from its return type to <code>void*</code>?</p>\n<p>13.3.3.2 Ranking Implicit Conversion Sequences [over.ics.rank] p4 states in the second bullet point:</p>\n<blockquote>\n<p id=\"so_18089988_18090865_14\">If class <code>B</code> is derived directly or indirectly from class <code>A</code>, conversion of <code>B*</code> to <code>A*</code> is better than conversion of <code>B*</code> to <code>void*</code>, and conversion of <code>A*</code> to <code>void*</code> is better than conversion of <code>B*</code> to <code>void*</code>.</p>\n</blockquote>\n<p>This is exactly the case of the OP, except with the names <code>A</code> and <code>B</code> reversed. Overload resolution on the two conversion operators of the OP is resolved in favor of <code>A::operator B*()</code> since the cited rule makes the conversion sequence <code>B*</code> \u2192 <code>void*</code> better than <code>A*</code> \u2192 <code>void*</code></p>\n</hr>", "LastActivityDate": "2013-08-07T19:08:13.430"}, "bq_ids": {"n4140": {"so_18089988_18089988_7": {"section_id": 594, "quality": 0.75, "length": 15}, "so_18089988_18090865_1": {"section_id": 595, "quality": 0.9761904761904762, "length": 41}, "so_18089988_18089988_5": {"section_id": 595, "quality": 0.9761904761904762, "length": 41}, "so_18089988_18090865_12": {"section_id": 603, "quality": 0.75, "length": 6}, "so_18089988_18090865_11": {"section_id": 603, "quality": 0.85, "length": 17}, "so_18089988_18090865_10": {"section_id": 602, "quality": 0.8666666666666667, "length": 13}, "so_18089988_18090865_8": {"section_id": 600, "quality": 0.8695652173913043, "length": 20}, "so_18089988_18090865_0": {"section_id": 3296, "quality": 0.9, "length": 36}, "so_18089988_18089988_3": {"section_id": 3296, "quality": 0.9, "length": 36}, "so_18089988_18090865_7": {"section_id": 563, "quality": 0.9473684210526315, "length": 18}, "so_18089988_18090865_6": {"section_id": 563, "quality": 0.9473684210526315, "length": 18}, "so_18089988_18089988_1": {"section_id": 3296, "quality": 0.8235294117647058, "length": 14}, "so_18089988_18090865_9": {"section_id": 601, "quality": 1.0, "length": 12}, "so_18089988_18089988_6": {"section_id": 595, "quality": 0.9333333333333333, "length": 70}, "so_18089988_18090865_14": {"section_id": 640, "quality": 1.0, "length": 16}, "so_18089988_18090865_13": {"section_id": 603, "quality": 0.9259259259259259, "length": 25}, "so_18089988_18090865_5": {"section_id": 563, "quality": 1.0, "length": 27}, "so_18089988_18090865_2": {"section_id": 563, "quality": 1.0, "length": 10}}, "n3337": {"so_18089988_18089988_7": {"section_id": 584, "quality": 0.75, "length": 15}, "so_18089988_18090865_1": {"section_id": 585, "quality": 0.9761904761904762, "length": 41}, "so_18089988_18089988_5": {"section_id": 585, "quality": 0.9761904761904762, "length": 41}, "so_18089988_18090865_12": {"section_id": 593, "quality": 0.75, "length": 6}, "so_18089988_18090865_11": {"section_id": 593, "quality": 0.85, "length": 17}, "so_18089988_18090865_10": {"section_id": 592, "quality": 0.8666666666666667, "length": 13}, "so_18089988_18090865_8": {"section_id": 590, "quality": 0.8695652173913043, "length": 20}, "so_18089988_18089988_6": {"section_id": 585, "quality": 0.9333333333333333, "length": 70}, "so_18089988_18089988_3": {"section_id": 3166, "quality": 0.9, "length": 36}, "so_18089988_18090865_7": {"section_id": 554, "quality": 0.9473684210526315, "length": 18}, "so_18089988_18090865_6": {"section_id": 554, "quality": 0.9473684210526315, "length": 18}, "so_18089988_18089988_1": {"section_id": 3166, "quality": 0.8235294117647058, "length": 14}, "so_18089988_18090865_9": {"section_id": 591, "quality": 1.0, "length": 12}, "so_18089988_18090865_0": {"section_id": 3166, "quality": 0.9, "length": 36}, "so_18089988_18090865_14": {"section_id": 630, "quality": 1.0, "length": 16}, "so_18089988_18090865_13": {"section_id": 593, "quality": 0.9259259259259259, "length": 25}, "so_18089988_18090865_5": {"section_id": 554, "quality": 1.0, "length": 27}, "so_18089988_18090865_2": {"section_id": 554, "quality": 1.0, "length": 10}}, "n4659": {"so_18089988_18089988_7": {"section_id": 617, "quality": 0.75, "length": 15}, "so_18089988_18090865_1": {"section_id": 618, "quality": 0.9761904761904762, "length": 41}, "so_18089988_18089988_5": {"section_id": 618, "quality": 0.9761904761904762, "length": 41}, "so_18089988_18090865_12": {"section_id": 629, "quality": 0.75, "length": 6}, "so_18089988_18090865_11": {"section_id": 629, "quality": 0.85, "length": 17}, "so_18089988_18090865_8": {"section_id": 626, "quality": 0.8695652173913043, "length": 20}, "so_18089988_18090865_0": {"section_id": 4058, "quality": 0.9, "length": 36}, "so_18089988_18089988_3": {"section_id": 4058, "quality": 0.9, "length": 36}, "so_18089988_18090865_7": {"section_id": 586, "quality": 0.9473684210526315, "length": 18}, "so_18089988_18089988_6": {"section_id": 618, "quality": 0.9333333333333333, "length": 70}, "so_18089988_18090865_6": {"section_id": 586, "quality": 0.9473684210526315, "length": 18}, "so_18089988_18089988_1": {"section_id": 4058, "quality": 0.8235294117647058, "length": 14}, "so_18089988_18090865_2": {"section_id": 586, "quality": 1.0, "length": 10}, "so_18089988_18090865_9": {"section_id": 627, "quality": 1.0, "length": 12}, "so_18089988_18090865_13": {"section_id": 629, "quality": 0.9259259259259259, "length": 25}, "so_18089988_18090865_14": {"section_id": 668, "quality": 1.0, "length": 16}, "so_18089988_18090865_5": {"section_id": 586, "quality": 1.0, "length": 27}, "so_18089988_18090865_10": {"section_id": 628, "quality": 0.8666666666666667, "length": 13}}}});