post_cb({"bq_ids": {"n4140": {"so_27737492_27737913_0": {"length": 11, "quality": 1.0, "section_id": 399}, "so_27737492_27737913_1": {"length": 46, "quality": 1.0, "section_id": 3376}}, "n3337": {"so_27737492_27737913_0": {"length": 11, "quality": 1.0, "section_id": 390}, "so_27737492_27737913_1": {"length": 41, "quality": 0.8913043478260869, "section_id": 3246}}}, "27737913": {"PostTypeId": "2", "Body": "<p><code>12.4.3</code> of the C++11 standard says</p>\n<blockquote>\n<p id=\"so_27737492_27737913_0\">A declaration of a destructor that does not have an <em>exception-specification</em> is implicitly considered to have\n  the same <em>exception-specification</em> as an implicit declaration.</p>\n</blockquote>\n<p><code>15.4.14</code> says</p>\n<blockquote>\n<p id=\"so_27737492_27737913_1\">If <strong>f</strong> is an inheriting constructor or an implicitly declared default constructor, copy\n  constructor, move constructor, destructor, copy assignment operator, or move assignment operator, its implicit\n  <em>exception-specification</em> specifies the <em>type-id</em> T if and only if T is allowed by the <em>exception-specification</em>\n  of a function directly invoked by <strong>f</strong>\u2019s implicit definition; <strong>f</strong> allows all exceptions if any function it directly\n  invokes allows all exceptions, and <strong>f</strong> has the <em>exception-specification</em> <em>noexcept(true)</em> if every function it directly\n  invokes allows no exceptions.</p>\n</blockquote>\n<p>Since the implicit destructor for <code>HCAccessor</code> would be trivial and hence <code>noexcept(true)</code> since it doesn't invoke any function, <code>~HCAcessor</code>, in the absence of an exception specification, will be declared <code>noexcept</code> as well.</p>\n", "LastActivityDate": "2015-01-02T06:06:32.683", "LastEditorUserId": "862351", "Id": "27737913", "CommentCount": "0", "CreationDate": "2015-01-02T05:50:30.287", "ParentId": "27737492", "Score": "2", "OwnerUserId": "862351", "LastEditDate": "2015-01-02T06:06:32.683"}, "27737492": {"ViewCount": "138", "Body": "<p>I'm trying to create a class with a \"mostly-invariant\" that allows clients to break the invariant if need be but only if they fix it before leaving the scope in which the nastiness happens.</p>\n<p>Here are the two classes involved. It's similar to scope guard. More details, comments, and a small test at ideone.</p>\n<p><a href=\"http://ideone.com/dMCHVU\" rel=\"nofollow\">http://ideone.com/dMCHVU</a></p>\n<pre><code>class HCAccessor;\n\nclass HasConditions\n{\n    // class \"mostly-invariant\"\n    // 7 &lt; payload_ &lt;42\n    int payload_;\n\n    bool valid() const\n    {\n        if (!(7 &lt; payload_) || !(payload_ &lt; 42))\n            return false;\n        else\n            return true;\n    }\n\npublic:\n    HasConditions(const int payload)\n        : payload_(payload)\n    {\n        if (!valid())\n        {\n            throw std::runtime_error(\"can't construct\");\n        }\n    }\n\n    friend class HCAccessor;\n};\n\nclass HCAccessor\n{\n    HasConditions&amp; hc_;\n\npublic:\n    HCAccessor(HasConditions&amp; hc)\n        : hc_(hc)\n    {}\n\n    HCAccessor(HCAccessor&amp; other)\n        : hc_(other.hc_)\n    {}\n\n    ~HCAccessor()\n    {\n        if (!hc_.valid())\n        {\n            throw std::runtime_error(\"you broke it!\");\n        }\n    }\n\n    void payload(const int newval)\n    {\n        hc_.payload_ = newval;\n    }\n\n    int payload() const\n    {\n        return hc_.payload_;\n    }\n};\n</code></pre>\n<p>When the \"mostly-invariant\" is broken and then fixed the code seems to work. When the \"mostly-invariant\" remains broken and <code>~HCAccessor()</code> throws, <code>std::terminate</code> gets called and I don't know why. None of the reasons for an exception resulting in a <code>std::terminate</code> call seem to fit.</p>\n<p><a href=\"http://en.cppreference.com/w/cpp/error/terminate\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/error/terminate</a></p>\n<p>As far as I can tell only one exception is thrown and then immediately <code>std::terminate</code> is called.</p>\n<p>Why is this happening and how can I fix it?</p>\n", "AcceptedAnswerId": "27737879", "Title": "Throwing exception from guard class destructor causes std::terminate", "CreationDate": "2015-01-02T04:50:08.317", "Id": "27737492", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-01-02T06:06:32.683", "Score": "1", "OwnerUserId": "1128289", "Tags": "<c++><exception><scope>", "AnswerCount": "2"}, "27737879": {"PostTypeId": "2", "Body": "<p>Destructors in C++11 are <code>noexcept</code> by default. If you really want to do this, you have to declare the destructor of HCAccessor with <code>noexcept(false)</code>:</p>\n<pre><code>~HCAccessor() noexcept(false) {\n</code></pre>\n<p>or an old-fashioned throw-list:</p>\n<pre><code>~HCAccessor() throw(std::runtime_error) {\n</code></pre>\n<p>(Kudos to Pradhan for the <code>noexcept(false)</code> syntax that I had not seen before. It's not something one needs often, I suppose).</p>\n<p>However, <strong>doing so is almost certainly a Bad Idea\u2122</strong>. Flying exceptions cause destructors to be called in stack unwinding, and if you have destructors that throw exceptions, you'll eventually find yourself trying to throw several exceptions at the same time. Which explodes.</p>\n<p>If an instance of <code>HCAccessor</code> does not manage any resources, it has nothing to do in cleanup, and the destructor is a nop. I don't see how that is a reason to throw an exception -- just leave it be.</p>\n", "LastActivityDate": "2015-01-02T06:04:27.310", "LastEditorUserId": "4301306", "Id": "27737879", "CommentCount": "2", "CreationDate": "2015-01-02T05:46:34.710", "ParentId": "27737492", "Score": "3", "OwnerUserId": "4301306", "LastEditDate": "2015-01-02T06:04:27.310"}});