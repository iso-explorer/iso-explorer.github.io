post_cb({"22180875": {"ParentId": "22176268", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>So your basic problem is that you don't have a hasher for <code>std::tuple</code> -- the standard library does not currently come with one by default.  I think this is an oversight.</p>\n<p>You cannot add a default hasher for <code>std::tuple</code> -- either for all <code>tuple</code>s or for your particular list -- because the standard says you aren't allowed to:</p>\n<blockquote>\n<p id=\"so_22176268_22180875_0\"><strong>17.6.4.2.1</strong> Namespace std [namespace.std]/1 The behavior of a C++ program is undefined if it adds declarations or definitions to\n  namespace std or to a namespace within namespace std unless otherwise\n  specified. A program may add a template specialization for any\n  standard library template to namespace std only if the declaration\n  depends on a user-defined type and the specialization meets the\n  standard library requirements for the original template and is not\n  explicitly prohibited.</p>\n</blockquote>\n<p>So this leaves you with either writing a custom hasher for your <code>tuple</code> type, and passing it to your <code>unordered_map</code>, or using a type that isn't merely <code>std::tuple</code> for your key, or writing a custom hasher that supports every <code>tuple</code> (including recursive <code>tuple</code>s) while also supporting <code>hash&lt;T&gt;</code> lookup for non-<code>tuple</code>s.  A 4th option would be to write your own ADL-based hash system and set it up so that types with valid <code>std::hash</code> specializations use that, with various other fallbacks.</p>\n<p>I will illustrate the 3rd option above.</p>\n<p>First, you want to be able to combine two hash values in a way that doesn't lead to many spurious collisions.</p>\n<pre><code>  inline std::size_t hash_result_combine(std::size_t lhs, std::size_t rhs)\n  {\n      return lhs ^( rhs + 0x9e3779b9 + (lhs&lt;&lt;6) + (lhs&gt;&gt;2));\n  }\n</code></pre>\n<p>this takes two <code>hash</code> outputs, and combines them.  We can then chain this any number of times.  (constants borrowed from <a href=\"https://stackoverflow.com/a/7111460/1774667\">https://stackoverflow.com/a/7111460/1774667</a> )</p>\n<p>Next, some indexing boilerplate.  Most generic work with <code>std::tuple</code> requires this stuff:</p>\n<pre><code>  template&lt;unsigned...&gt;struct indexes{};\n  template&lt;unsigned Max, unsigned... Is&gt;struct make_indexes:make_indexes&lt;Max-1,Max-1,Is...&gt; {};\n  template&lt;unsigned...Is&gt;struct make_indexes&lt;0,Is...&gt;:indexes&lt;Is...&gt;{};\n</code></pre>\n<p>Finally, a hasher class that works with nearly every type:</p>\n<pre><code>  struct my_hasher {\n    template&lt;typename... Args&gt;\n    std::size_t operator()(indexes&lt;&gt;, std::tuple&lt;Args...&gt; const&amp; tup) const {\n      return 0;\n    }\n    template&lt;unsigned I, unsigned... Is,typename... Args&gt;\n    std::size_t operator()(indexes&lt;I, Is...&gt;,std::tuple&lt;Args...&gt; const&amp; tup) const {\n      return hash_result_combine( (*this)(std::get&lt;I&gt;(tup)), (*this)(indexes&lt;Is...&gt;, tup) );\n    }\n    template&lt;typename... Args&gt;\n    std::size_t operator()(std::tuple&lt;Args...&gt; const&amp; tup) const {\n      return (*this)(make_indexes&lt;sizeof...(Args)&gt;(), tup);\n    }\n    template&lt;typename T&gt;\n    std::size_t operator()(T const&amp; t) const { return std::hash&lt;T&gt;()(t); }\n  };\n</code></pre>\n<p>you can pass <code>my_hasher</code> to an <code>unordered_set</code> in place of <code>hash&lt;T&gt;</code> for <code>tuple</code>s, <code>tuple</code>s containing tuples, or even for scalars -- it is very generous.</p>\n<pre><code>typedef std::unordered_map&lt;const key_t,IndexGuide, my_hasher&gt; GuideDouble;\n</code></pre>\n<p>and now we properly hash <code>key_t</code>.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:20:58.943", "Id": "22180875", "Score": "2", "CreationDate": "2014-03-04T19:13:35.007", "LastActivityDate": "2014-03-04T19:13:35.007"}, "22176470": {"ParentId": "22176268", "CommentCount": "1", "Body": "<p><code>unordered_set</code> is implemented using a hash table.<br>\nin order to use <code>unordered_set</code> for a type that you defined you need to specialize the <code>hash&lt;&gt;</code> template for that type,  as follows:</br></p>\n<pre><code>namespace std {\n    template &lt;&gt; struct hash&lt;key_t&gt;\n    {\n\n        size_t operator()(const key_t &amp; t) const\n        {\n            // the logic for hashing\n        }\n    };\n}\n</code></pre>\n", "OwnerUserId": "1182207", "PostTypeId": "2", "Id": "22176470", "Score": "0", "CreationDate": "2014-03-04T15:43:51.607", "LastActivityDate": "2014-03-04T15:43:51.607"}, "22176599": {"ParentId": "22176268", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>There is no default hasher for std::tuple.</p>\n<p>You may use this code snippet <a href=\"https://stackoverflow.com/a/7115547/1961500\">Generic hash for tuples in unordered_map / unordered_set</a></p>\n", "OwnerUserId": "1961500", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:20:58.943", "Id": "22176599", "Score": "0", "CreationDate": "2014-03-04T15:49:52.567", "LastActivityDate": "2014-03-04T15:49:52.567"}, "bq_ids": {"n4140": {"so_22176268_22180875_0": {"section_id": 6299, "quality": 0.868421052631579, "length": 33}}, "n3337": {"so_22176268_22180875_0": {"section_id": 6056, "quality": 0.868421052631579, "length": 33}}, "n4659": {"so_22176268_22180875_0": {"section_id": 7808, "quality": 0.868421052631579, "length": 33}}}, "22176681": {"ParentId": "22176268", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>You have to provide a hash function which tells <code>std::unordered_map</code> how to produce a hash value from your <code>key_t</code>. You can do it by specialization of <code>hash</code> template functor:</p>\n<p>provide a Key:</p>\n<pre><code>struct Key{\n    unsigned char  first;\n    unsigned char second;\n    unsigned char  third;\n\n    bool operator==(const Key &amp;other) const {\n         return (first == other.first\n            &amp;&amp; second == other.second\n            &amp;&amp; third == other.third);\n    }\n};\n</code></pre>\n<p>specialize hash template:</p>\n<pre><code>namespace std {\n\n  template &lt;&gt;\n  struct hash&lt; Key&gt;\n  {\n    std::size_t operator()(const Key&amp; k) const\n    {\n      using std::hash;\n\n      // Compute individual hash values for first,\n      // second and third and combine them using XOR\n      // and bit shifting:\n\n      return ((hash&lt;char&gt;()( k.first)\n               ^ (hash&lt;char&gt;()( k.second) &lt;&lt; 1)) &gt;&gt; 1)\n               ^ (hash&lt;int&gt;()( k.third) &lt;&lt; 1);\n    }\n  };\n\n}\n\nstd::unordered_map&lt; Key, IndexGuide&gt; myMap;\n</code></pre>\n<p>As I said in comments, you can take a look <a href=\"https://stackoverflow.com/a/17017281/1141471\">at this SO thread</a>.</p>\n", "OwnerUserId": "1141471", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:20:58.943", "Id": "22176681", "Score": "2", "CreationDate": "2014-03-04T15:53:54.303", "LastActivityDate": "2014-03-04T16:17:46.153"}, "22176268": {"CommentCount": "3", "ViewCount": "665", "PostTypeId": "1", "ClosedDate": "2014-03-15T02:36:24.140", "LastEditorUserId": "1141471", "LastActivityDate": "2014-03-04T19:13:35.007", "Body": "<p>I have to make an unordered_map consisting of the following keys and value:</p>\n<ul>\n<li><p>key: unsigned char, unsigned char, unsigned char</p></li>\n<li><p>value: structure(int,int)</p></li>\n</ul>\n<p>Here is my code to define that:</p>\n<pre><code>namespace G {\n\ntypedef std::tuple&lt; unsigned char, unsigned char , unsigned char&gt; key_t;\n\n\nstruct IndexGuide\n{\nint index;\nint SerialNo;\n\n};\n\ntypedef std::unordered_map&lt;const key_t,IndexGuide&gt; GuideDouble;\n\n}\nusing namespace G;\n</code></pre>\n<p>Is there anything wrong in this code because when I link these files on linux terminal. It gives me errors.Some part of the error as follows</p>\n<blockquote>\n<p id=\"so_22176268_22176268_0\">In function `std::__detail::_Hash_code_base const, std::pair const, G::IndexGuide&gt;,\n  std::_Select1st const, G::IndexGuide&gt; &gt;,\n  std::equal_to\n  const&gt;, std::hash const&gt;, std::__detail::_Mod_range_hashing,\n  std::__detail::_Default_ranged_hash,\n  false&gt;::_M_bucket_index(std::__detail::_Hash_node const, G::IndexGuide&gt;, false&gt;\n  const*, unsigned int) const':</p>\n</blockquote>\n", "LastEditDate": "2014-03-04T15:57:46.577", "AcceptedAnswerId": "22180875", "Title": "Unordered Map with three unsigned chars as key", "Id": "22176268", "Score": "1", "CreationDate": "2014-03-04T15:35:20.270", "Tags": "<c++><hash><hashtable><unordered-map><hash-function>", "OwnerUserId": "1170920", "AnswerCount": "4"}});