post_cb({"bq_ids": {"n4140": {"so_22817517_22817633_0": {"section_id": 5952, "quality": 0.9444444444444444, "length": 34}, "so_22817517_22817633_2": {"section_id": 5811, "quality": 0.9384615384615385, "length": 61}, "so_22817517_22817633_1": {"section_id": 6179, "quality": 1.0, "length": 4}}, "n3337": {"so_22817517_22817633_0": {"section_id": 5722, "quality": 0.9444444444444444, "length": 34}, "so_22817517_22817633_2": {"section_id": 5584, "quality": 0.9384615384615385, "length": 61}, "so_22817517_22817633_1": {"section_id": 5940, "quality": 1.0, "length": 4}}, "n4659": {"so_22817517_22817633_0": {"section_id": 7438, "quality": 0.6388888888888888, "length": 23}, "so_22817517_22817633_2": {"section_id": 7272, "quality": 0.8461538461538461, "length": 55}, "so_22817517_22817633_1": {"section_id": 7681, "quality": 1.0, "length": 4}}}, "22817633": {"ParentId": "22817517", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Adding parenthesis does not create a sequence point and in the more modern standards it does not create a sequenced before relationship with respect to side effects which is the problem with the expression that you have unless noted the rest of this will be with respect to C++11. Parenthesis are a primary expression covered in section <code>5.1</code> <em>Primary expressions</em>, which has the following grammar (<em>emphasis mine going forward</em>):</p>\n<pre><code>primary-expression:\n  literal\n  this\n  ( expression )\n  [...]\n</code></pre>\n<p>and in paragraph <em>6</em> it says:</p>\n<blockquote>\n<p id=\"so_22817517_22817633_0\">A parenthesized expression is a primary expression whose type and value are identical to those of the enclosed expression. The presence of parentheses does not affect whether the expression is an lvalue. The parenthesized expression can be used in exactly the same contexts as those where the enclosed expression can be used, and <strong>with the same meaning, except as otherwise indicated</strong>.</p>\n</blockquote>\n<p>The <code>postfix ++</code> is  problematic since we can not determine when the side effect of updating <code>a</code> will happen pre C++11 and in C this applies to both the <code>postfix ++</code> and <code>prefix ++</code> operations. With respect to how undefined behavior changed for <code>prefix ++</code> in C++11 see <a href=\"https://stackoverflow.com/questions/22616044/assignment-operator-sequencing-in-c11-expressions/22616368#22616368\">Assignment operator sequencing in C11 expressions</a>.</p>\n<p>The <code>+=</code> operation is problematic since:</p>\n<blockquote>\n<p id=\"so_22817517_22817633_1\">[...]E1 op = E2 is equivalent to E1 = E1 op E2 except that <strong>E1 is\n  evaluated only once</strong>[...]</p>\n</blockquote>\n<p>So in C++11 the following went from undefined to defined:</p>\n<pre><code>a = ++a + 1 ;\n</code></pre>\n<p>but this remains undefined:</p>\n<pre><code>a = a++ + 1 ;\n</code></pre>\n<p>and both of the above are undefined pre C++11 and in both C99 and C11.</p>\n<p>From the draft C++11 standard section <code>1.9</code> <em>Program execution</em> paragraph <em>15</em> says:</p>\n<blockquote>\n<p id=\"so_22817517_22817633_2\">Except where noted, evaluations of operands of individual operators and of subexpressions of individual expressions are unsequenced. [ Note: In an expression that is evaluated more than once during the execution of a program, unsequenced and indeterminately sequenced evaluations of its subexpressions need not be performed consistently in different evaluations. \u2014end note ] The value computations of the operands of an operator are sequenced before the value computation of the result of the operator. If a side effect on a scalar object is unsequenced relative to either another side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined.</p>\n</blockquote>\n", "OwnerUserId": "1708801", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:14:56.277", "Id": "22817633", "Score": "4", "CreationDate": "2014-04-02T16:32:03.453", "LastActivityDate": "2014-04-02T17:21:36.420"}, "22817598": {"ParentId": "22817517", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>No, applying parentheses doesn't make it a defined behaviour. It's still undefined. The C99 standard \u00a76.5 \u00b62 says  </p>\n<blockquote>\n<p id=\"so_22817517_22817598_0\">Between the previous and next sequence point an object shall have its\n  stored value modified at most once by the evaluation of an expression.\n  Furthermore, the prior value shall be read only to determine the value\n  to be stored.</p>\n</blockquote>\n<p>Putting a sub-expression in parentheses may force the order of evaluation of sub-expressions but it does not create a sequence point. Therefore, it does not guarantee when the side effects of the sub-expressions, if they produce any, will take place. Quoting the C99 standard again \u00a75.1.2.3\u00b62 </p>\n<blockquote>\n<p id=\"so_22817517_22817598_1\">Evaluation of an expression may produce side effects. At certain\n  specified points in the execution sequence called sequence points, all\n  side effects of previous evaluations shall be complete and no side\n  effects of subsequent evaluations shall have taken place.</p>\n</blockquote>\n<p>For the sake of completeness, following are sequence points laid down by the C99 standard in Annex C.</p>\n<blockquote>\n<ol>\n<li><p id=\"so_22817517_22817598_2\">The call to a function, after the arguments have been evaluated.</p></li>\n<li><p id=\"so_22817517_22817598_3\">The end of the first operand of the following operators: logical AND <strong>&amp;&amp;</strong>; logical OR <strong>||</strong>; conditional <strong>?</strong>; comma <strong>,</strong>.</p></li>\n<li><p id=\"so_22817517_22817598_4\">The end of a full declarator.</p></li>\n<li><p id=\"so_22817517_22817598_5\">The end of a full expression; the expression in an expression statement; the controlling expression of a selection statement (<strong>if</strong>\n  or <strong>switch</strong>); the controlling expression of a <strong>while</strong> or <strong>do</strong>\n  statement; each of the expressions of a <strong>for</strong> statement; the\n  expression in a <strong>return</strong> statement.</p></li>\n<li><p id=\"so_22817517_22817598_6\">Immediately before a library function returns.</p></li>\n<li><p id=\"so_22817517_22817598_7\">After the actions associated with each formatted input/output function conversion specifier.</p></li>\n<li><p id=\"so_22817517_22817598_8\">Immediately before and immediately after each call to a comparison function, and also between any call to a comparison function and any\n  movement of the objects passed as arguments to that call.</p></li>\n</ol>\n</blockquote>\n", "OwnerUserId": "1809377", "LastEditorUserId": "1809377", "LastEditDate": "2014-04-02T17:07:31.383", "Id": "22817598", "Score": "10", "CreationDate": "2014-04-02T16:30:06.067", "LastActivityDate": "2014-04-02T17:07:31.383"}, "22817517": {"CommentCount": "6", "AcceptedAnswerId": "22817598", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2014-04-02T16:26:23.727", "LastActivityDate": "2015-08-06T15:23:53.173", "LastEditDate": "2015-08-06T15:23:53.173", "ViewCount": "1167", "FavoriteCount": "3", "Title": "Do parentheses force order of evaluation and make an undefined expression defined?", "Id": "22817517", "Score": "12", "Body": "<p>I was just going though my text book when I came across this question</p>\n<ol>\n<li>What would be the value of a after the following expression ?<br>\nAssume the initial value of a = 5.Mention the steps\n<ul>\n<li>a+=(a++)+(++a)</li>\n</ul></br></li>\n</ol>\n<p>At first I thought this is undefined behaviour because a has been modified more than once.<br>\nSo then I read the question and it said <strong>Mention the steps</strong> so I probably thought this question is right.</br></p>\n<p><strong>So my question is :</strong> </p>\n<ul>\n<li>Does applying parentheses make an undefined behaviour defined ?</li>\n<li>Is a sequence point created after evaluating a parentheses expression ?</li>\n<li>If it is defined,how does the parentheses matter since ++ and () have the same precedence</li>\n</ul>\n<p><strong>Note: A well explained and clear answer will get my vote</strong></p>\n", "Tags": "<c++><c><expression><undefined-behavior><operator-precedence>", "OwnerUserId": "1764528", "AnswerCount": "2"}});