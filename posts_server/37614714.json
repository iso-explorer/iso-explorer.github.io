post_cb({"37614714": {"FavoriteCount": "3", "ViewCount": "1973", "Id": "37614714", "AcceptedAnswerId": "37614932", "Score": "41", "Title": "What is the Relationship Between the C and C++ Standards?", "LastEditorUserId": "-1", "CommentCount": "8", "Body": "<p>I was writing <a href=\"https://stackoverflow.com/questions/5539249/why-transforms-begin-s-end-s-begin-tolower-cant-be-complied-successfu/37438120#37438120\">this answer</a> and I quoted from <a href=\"http://en.cppreference.com/w/cpp/string/byte/tolower#Parameters\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/string/byte/tolower#Parameters</a></p>\n<blockquote>\n<p id=\"so_37614714_37614714_0\">Is not representable as unsigned char and does not equal EOF, the behavior is undefined</p>\n</blockquote>\n<p>When I went to inspect <a href=\"http://en.cppreference.com/mwiki/index.php?title=cpp%2Fstring%2Fbyte%2Ftolower&amp;diff=66149&amp;oldid=65953\" rel=\"nofollow noreferrer\">the edit that had added this phrase</a> I found that the author's comment:</p>\n<blockquote>\n<p id=\"so_37614714_37614714_1\">Can't use negative signed chars with any ctype.h function per C99 7.4/1</p>\n</blockquote>\n<p>The author is citing from the C99 standard in C++ documentation. Is that valid? I couldn't find anything on the definition of this function in the C++ standard, so I must assume that it is valid.</p>\n<p>But this concerns me for 2 reasons:</p>\n<ol>\n<li>How would I know what version of the C standard the C++ standard depends upon?</li>\n<li>There are lists of <a href=\"https://softwareengineering.stackexchange.com/questions/16390/what-are-the-fundamental-differences-between-c-and-c\">the discrepancies between C and C++ everywhere</a>. If I'm looking at the C standard with reference to C++ how could I possibly know whether the area I'm looking at has been overridden?</li>\n</ol>\n", "Tags": "<c++><c><dependencies><standards><language-lawyer>", "CreationDate": "2016-06-03T12:43:06.307", "LastEditDate": "2017-04-12T07:31:17.257", "LastActivityDate": "2016-06-06T10:39:20.543", "PostTypeId": "1", "AnswerCount": "3", "OwnerUserId": "2642059"}, "bq_ids": {"n4140": {"so_37614714_37614932_0": {"length": 18, "quality": 0.8181818181818182, "section_id": 5761}}, "n3337": {"so_37614714_37614932_0": {"length": 18, "quality": 0.8181818181818182, "section_id": 5534}}}, "37614939": {"CreationDate": "2016-06-03T12:53:17.097", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_37614714_37614939_0\">How would I know what version of the C standard the C++ standard depends upon?</p>\n</blockquote>\n<p>In C++ 14, it's  ISO/IEC 9899:1999 (plus three corrigendums, so C99 in essence) as stated in 1.2 [intro.refs] in N4140. In C++98, it was C90, in C++17, it probably will be C11, but the C++ standard will always make that explicit.</p>\n<blockquote>\n<p id=\"so_37614714_37614939_1\">If I'm looking at the C standard with reference to C++ how could I possibly know whether the area I'm looking at has been overridden?</p>\n</blockquote>\n<p>You look in the C++ standard, it either explicitly imports the C definitions minus <code>restrict</code> or any C behavior it wants or makes explicit modifications.</p>\n<p>Usually, reading good documentation instead of the standard itself will serve you just fine.</p>\n<hr>\n<p>To address your initial question:</p>\n<blockquote>\n<p id=\"so_37614714_37614939_2\">The author is citing from the C99 standard in C++ documentation. Is that valid?</p>\n</blockquote>\n<p>Yes, because</p>\n<blockquote>\n<p id=\"so_37614714_37614939_3\"><sup>1</sup>\n   Tables 74 [contains <code>std::tolower</code>, me], 75, 76, 77, 78, and 79 describe headers <code>&lt;cctype&gt;</code>, <code>&lt;cwctype&gt;</code>, <code>&lt;cstring&gt;</code>, <code>&lt;cwchar&gt;</code>, <code>&lt;cstdlib&gt;</code>\n  (character conversions), and <code>&lt;cuchar&gt;</code>, respectively.<br>\n<sup>2</sup>\n   The contents of these headers shall be the same as the Standard C Library headers <code>&lt;ctype.h&gt;</code>, <code>&lt;wctype.h&gt;</code>,\n  <code>&lt;string.h&gt;</code>, <code>&lt;wchar.h&gt;</code>, and <code>&lt;stdlib.h&gt;</code> and the C Unicode TR header <code>&lt;uchar.h&gt;</code>, respectively, with the\n  following modifications [none of those apply to <code>std::tolower</code>, me]:</br></p>\n</blockquote>\n<p>21.8 [c.strings] in N4140 </p>\n</hr>", "Id": "37614939", "OwnerUserId": "3002139", "LastEditDate": "2016-06-03T15:40:21.037", "ParentId": "37614714", "LastActivityDate": "2016-06-03T15:40:21.037", "PostTypeId": "2", "Score": "14", "LastEditorUserId": "3002139"}, "37615023": {"CommentCount": "2", "Body": "<p>The edit is correct and this particular text has been in the standard since C90.</p>\n<p>From C90 4.3</p>\n<blockquote>\n<p id=\"so_37614714_37615023_0\">The header  declares several functions useful for testing\n  and mapping characters. In all cases the argument is an int , the\n  value of which shall be representable as an unsigned char or shall\n  equal the value of the macro EOF .  If the argument has any other\n  value, the behavior is undefined.</p>\n</blockquote>\n<p>From C11 7.4/1</p>\n<blockquote>\n<p id=\"so_37614714_37615023_1\">The header  declares several functions useful for classifying\n  and mapping characters. In all cases the argument is an int, the\n  value of which shall be representable as an unsigned char or shall\n  equal the value of the macro EOF. If the argument has any other value,\n  the behavior is undefined.</p>\n</blockquote>\n<p>Identical text; C has always been like this. So it doesn't matter which C version your particular C++ version uses, because all C versions are equivalent. </p>\n", "CreationDate": "2016-06-03T12:57:14.933", "ParentId": "37614714", "Id": "37615023", "LastActivityDate": "2016-06-03T12:57:14.933", "PostTypeId": "2", "Score": "3", "OwnerUserId": "584518"}, "37614932": {"CommentCount": "0", "Body": "<p>For the first question:</p>\n<p>The C++ standard explicitly lists the C standard(s) on which it depends in its <em>Normative references</em> section. For C++14, [intro.refs] 1.2/1 happens to list C 99:</p>\n<blockquote id=\"so_37614714_37614932_0\">\n<ul>\n<li>ISO/IEC 9899:1999, <em>Programming languages \u2014 C</em></li>\n<li>ISO/IEC 9899:1999/Cor.1:2001(E), <em>Programming languages \u2014 C, Technical Corrigendum 1</em></li>\n<li>ISO/IEC 9899:1999/Cor.2:2004(E), <em>Programming languages \u2014 C, Technical Corrigendum 2</em></li>\n<li>ISO/IEC 9899:1999/Cor.3:2007(E), <em>Programming languages \u2014 C, Technical Corrigendum 3</em></li>\n</ul>\n</blockquote>\n<p>For the second question:</p>\n<p>The C++ standard does not implicitly incorporate <em>any</em> parts of the C standard; all references to the C standard are explicit. A good source of information on where C++ deviates from C is Annex C, \"Compatibility\" of the C++ standard, particularly C.1 [diff.iso].</p>\n<p>Additionally, references to the C standard library are scattered throughout the description of the C++ standard library (chapters 17\u201330 in C++14). Of particular interest can be:</p>\n<ul>\n<li>17.2 [library.c], which describes the basic inclusion of the C standard library</li>\n<li>Chapter 18 [language.support], which describes many of the <code>&lt;c:::&gt;</code> headers of the C++ standard library (those which offer the C standard library functionality).</li>\n</ul>\n", "CreationDate": "2016-06-03T12:52:58.860", "ParentId": "37614714", "Id": "37614932", "LastActivityDate": "2016-06-03T12:52:58.860", "PostTypeId": "2", "Score": "34", "OwnerUserId": "1782465"}});