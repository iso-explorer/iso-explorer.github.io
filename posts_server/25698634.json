post_cb({"25698634": {"CommentCount": "8", "AcceptedAnswerId": "25698913", "PostTypeId": "1", "LastEditorUserId": "2191774", "CreationDate": "2014-09-06T09:05:51.900", "LastActivityDate": "2014-09-06T10:03:48.350", "LastEditDate": "2014-09-06T10:03:48.350", "ViewCount": "1115", "FavoriteCount": "0", "Title": "std::list<std::future> destructor does not block", "Id": "25698634", "Score": "10", "Body": "<p>I have a multithreaded application, with an loop waiting for user input as main thread.\nOn the correct input, it is supposed to stop the loop and wait for all other threads, to end propperly.</p>\n<p>For this purpose I created an <i>std::list</i> in which I put the <i>std::future</i> objects created for thread creation</p>\n<pre><code>std::list&lt;std::future&lt;int&gt;&gt; threads;\nthreads.emplace_front(std::async(std::launch::async, ...));\n</code></pre>\n<p>I was under the impression, that letting the <i>list</i> run out of scope, should block, until all threads return their main function, because the <i>list</i>s destructor will destrurct all <i>std::future</i> elements and <a href=\"http://en.cppreference.com/w/cpp/thread/future/~future\">the destructor of those</a> will wait, for the thread to finish.</p>\n<p><strong>EDIT:</strong> Since it is relevant I will add it here:\nThis is on Win7 with the MSVC version in Visual Studio 2013 Professional\n<strong>/EDIT</strong></p>\n<p>When I tried this, it didn't block, I had to add</p>\n<pre><code>for (auto it = threads.begin(); it != threads.end(); ++it) {\n    it-&gt;get();\n}\n</code></pre>\n<p>to the end of the function, to block correctly.</p>\n<p>Did I missunderstand something, or do I have to create the thread in a different way, to do what I want to do here?</p>\n", "Tags": "<c++><multithreading><c++11><stdlist>", "OwnerUserId": "2191774", "AnswerCount": "2"}, "25698913": {"ParentId": "25698634", "CommentCount": "2", "CreationDate": "2014-09-06T09:40:05.573", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "25698913", "Score": "12", "Body": "<p>This is a <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/810623\">MSVC bug that has been fixed</a>, but the fix won't be available until MS releases a new version of Visual C++, probably some time in 2015. (It's also <a href=\"http://blogs.msdn.com/b/vcblog/archive/2014/06/06/c-14-stl-features-fixes-and-breaking-changes-in-visual-studio-14-ctp1.aspx\">available in the CTP for the new version</a>, but it's a pretty bad idea to use that for any production code...)</p>\n<p>As Scott Meyers explained in <a href=\"http://scottmeyers.blogspot.com/2013/03/stdfutures-from-stdasync-arent-special.html\">his blog post</a>, the destructor of a <code>std::future</code> returned by a <code>std::async</code> call using the <code>launch::async</code> policy is required to block until the spawned thread completes execution (\u00a730.6.8 [futures.async]/p5):</p>\n<blockquote>\n<p id=\"so_25698634_25698913_0\">If the implementation chooses the <code>launch::async</code> policy,</p>\n<ul>\n<li>[...]</li>\n<li>the associated thread completion <em>synchronizes with</em> (1.10) the \n  return from the first function that successfully detects the ready\n  status of the shared state or with the return from the last function\n  that releases the shared state, whichever happens first.</li>\n</ul>\n</blockquote>\n<p>In this case, the <code>future</code>'s destructor is the \"last function that releases the shared state\", so the thread completion must <em>synchronize with</em> (i.e., happen before) the return of that function.</p>\n", "LastActivityDate": "2014-09-06T09:40:05.573"}, "25698743": {"ParentId": "25698634", "CommentCount": "3", "CreationDate": "2014-09-06T09:19:52.037", "OwnerUserId": "1524341", "PostTypeId": "2", "Id": "25698743", "Score": "0", "Body": "<p>I've looked at the documentation of std::future and found this for the destructor of std::future:</p>\n<p><em>Releases any shared state. This means</em></p>\n<ul>\n<li><em>if the return object or provider holds the last reference to its shared state, the shared state is destroyed; and</em></li>\n<li><em>the return object or provider gives up its reference to its shared state; and</em></li>\n<li><em>these actions will not block for the shared state to become ready, except that it may block if all of the following are true: the shared state was created by a call to std::async, the shared state is not yet ready, and this was the last reference to the shared state.</em></li>\n</ul>\n<p>Pay attention on the last point. In my opinion you have to call the <code>get</code>'s at the end of your scope.</p>\n", "LastActivityDate": "2014-09-06T09:19:52.037"}, "bq_ids": {"n4140": {"so_25698634_25698913_0": {"section_id": 3163, "quality": 1.0, "length": 4}}, "n3337": {"so_25698634_25698913_0": {"section_id": 3036, "quality": 1.0, "length": 4}}, "n4659": {"so_25698634_25698913_0": {"section_id": 3925, "quality": 1.0, "length": 4}}}});