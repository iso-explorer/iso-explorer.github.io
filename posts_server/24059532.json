post_cb({"24059532": {"CommentCount": "1", "AcceptedAnswerId": "24059774", "PostTypeId": "1", "LastEditorUserId": "736079", "CreationDate": "2014-06-05T11:53:16.417", "LastActivityDate": "2016-12-29T16:38:52.737", "LastEditDate": "2016-12-29T16:38:52.737", "ViewCount": "508", "FavoriteCount": "1", "Title": "Type of auto reference", "Id": "24059532", "Score": "19", "Body": "<p>If I have the following two loops:</p>\n<pre><code>std::vector&lt;int&gt; v;\n\nfor(auto i : v)\n  //do something with i\n\nfor(auto&amp; j : v)\n  //do something with j\n</code></pre>\n<p>When I hover over <code>i</code>, intellisense shows it as <code>int i</code> (as expected). However, when I hover over <code>j</code> I don't get <code>int&amp;</code> as I expected to, but rather</p>\n<pre><code>std::_Simple_types&lt;std::_Wrap_alloc&lt;std::_Vec_base_types&lt;int, std::allocator&lt;int&gt; &gt;::_Alloc&gt;::value_type&gt;::value_type &amp;j\n</code></pre>\n<p>What is this complicated definition? Is it the same as <code>int&amp;</code>? If not, what is it? And if it is, why can it deduce just <code>int</code> for <code>i</code>, but not <code>int&amp;</code> for <code>j</code>?</p>\n", "Tags": "<c++><visual-studio><c++11><visual-studio-2013>", "OwnerUserId": "331785", "AnswerCount": "3"}, "24059774": {"ParentId": "24059532", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The standard states in <code>6.5.4 [stmt.ranges]</code>:</p>\n<blockquote>\n<p id=\"so_24059532_24059774_0\">For a range-based for statement of the form</p>\n<pre><code>for ( for-range-declaration : expression ) statement\n</code></pre>\n<p id=\"so_24059532_24059774_1\">let <code>range-init</code> be equivalent to the expression surrounded by\n  parentheses</p>\n<pre><code>( expression )\n</code></pre>\n<p id=\"so_24059532_24059774_2\">In each case, a range-based for statement is equivalent to</p>\n<pre><code>{\n    auto &amp;&amp; __range = range-init;\n    for ( auto __begin = begin-expr,  __end = end-expr;  __begin != __end; ++__begin ) {\n        for-range-declaration = *__begin;\n        statement\n    }\n}\n</code></pre>\n</blockquote>\n<p>So you can see that in your case the types of <code>i</code> and <code>j</code> are deduced from the type of <code>*it</code> where <code>it</code> is a <code>std::vector</code> iterator. <code>std::vector</code> iterators are implementation defined, however the result of <code>*it</code> is not.</p>\n<hr>\n<p>As indicated in the comments, a <code>std::vector</code> iterator is a forward iterator, and after <code>24.2.5/1 [forward.iterators]</code>:</p>\n<blockquote>\n<p id=\"so_24059532_24059774_3\">A class or pointer type <code>X</code> satisfies the requirements of a forward\n  iterator if</p>\n<ul>\n<li>...</li>\n<li>if X is a mutable iterator, <code>reference</code> is a reference to <code>T</code>; if <code>X</code> is a const iterator, <code>reference</code> is a reference to <code>const T</code>,</li>\n</ul>\n</blockquote>\n<p>Here <code>reference</code> is used in <code>24.4.4/2 [iterator.iterators]</code> to indicate the return type of <code>*it</code>.</p>\n<hr>\n<p>Thus for your case  the standard requires the type of <code>i</code> to be <code>int</code> and the type of <code>j</code> to be <code>int&amp;</code>. This is probably the case for MSVC++, and intellisense is just not able to correctly resolve the type.</p>\n<hr>\n<p><strong>Edit:</strong> Fixed the answer regarding the return type when dereferencing iterators.</p>\n</hr></hr></hr>", "OwnerUserId": "316448", "LastEditorUserId": "316448", "LastEditDate": "2014-06-06T08:44:26.237", "Id": "24059774", "Score": "11", "CreationDate": "2014-06-05T12:05:28.233", "LastActivityDate": "2014-06-06T08:44:26.237"}, "24059798": {"ParentId": "24059532", "CommentCount": "1", "Body": "<p>IntelliSense is giving you a peek into the implementation of <code>std::vector</code>. That is a complicated way of saying reference to <code>std::vector&lt;int&gt;::value_type</code> or, in this case, reference to <code>int</code>.</p>\n", "OwnerUserId": "445976", "PostTypeId": "2", "Id": "24059798", "Score": "8", "CreationDate": "2014-06-05T12:06:40.643", "LastActivityDate": "2014-06-05T12:06:40.643"}, "bq_ids": {"n4140": {"so_24059532_24059774_1": {"section_id": 3906, "quality": 0.8333333333333334, "length": 5}, "so_24059532_24059774_2": {"section_id": 3906, "quality": 1.0, "length": 5}, "so_24059532_24059774_3": {"section_id": 5573, "quality": 1.0, "length": 7}}, "n3337": {"so_24059532_24059774_1": {"section_id": 3766, "quality": 0.8333333333333334, "length": 5}, "so_24059532_24059774_2": {"section_id": 3766, "quality": 1.0, "length": 5}, "so_24059532_24059774_3": {"section_id": 5355, "quality": 1.0, "length": 7}}, "n4659": {"so_24059532_24059774_1": {"section_id": 4792, "quality": 0.6666666666666666, "length": 4}, "so_24059532_24059774_3": {"section_id": 7020, "quality": 1.0, "length": 7}}}, "24059747": {"ParentId": "24059532", "CommentCount": "7", "Body": "<p>Yes, it is <code>int</code>.  All that means is intellisense got confused and gave up.</p>\n<p>Intellisense is not perfect: you can even get it to red squiggly compiling code.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "24059747", "Score": "7", "CreationDate": "2014-06-05T12:04:18.780", "LastActivityDate": "2014-06-05T12:04:18.780"}});