post_cb({"3749240": {"ParentId": "3749196", "CommentCount": "0", "Body": "<pre><code>T* p;\n...\nfor (int i = 0; i&lt;cnt; i++)\n    cout &lt;&lt; p[i] &lt;&lt; \u2019\\n\u2019;\n</code></pre>\n<p>basically, you do not know if <code>cout &lt;&lt; p[i] &lt;&lt; \u2019\\n\u2019;</code> is valid expression (for example) until you know the type <code>T</code></p>\n", "OwnerUserId": "206328", "PostTypeId": "2", "Id": "3749240", "Score": "0", "CreationDate": "2010-09-20T07:00:16.670", "LastActivityDate": "2010-09-20T07:00:16.670"}, "3749242": {"ParentId": "3749196", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Looking only at the template, can you tell me what the type of <code>p[i]</code> is? No. The type of <code>p[i]</code> in <code>Set&lt;int&gt;</code> will be <code>int</code> ; the type of <code>p[i]</code> in <code>Set&lt;std::string&gt;</code> will be <code>std::string</code>. Hence, the lookup of <code>operator&lt;&lt;</code> has to be delayed until the template is instantiated and the type of <code>p[i]</code> is known.</p>\n<p>You'd have a similar issue in (assume this is another member of <code>Set&lt;T&gt;</code>)</p>\n<pre><code>// In Set&lt;T&gt;\nvoid reverse()\n{\n  for (int i = 0; i &lt;= cnt-i; ++i)\n  {\n    using std::swap;\n    swap(p[i], p[cnt-i]);\n  }\n}\n</code></pre>\n<p>The lookup of swap will also need the type of <code>p[i]</code>, even though there's a using declaration directly in front.</p>\n", "OwnerUserId": "15416", "LastEditorUserId": "147192", "LastEditDate": "2010-09-20T07:36:06.200", "Id": "3749242", "Score": "2", "CreationDate": "2010-09-20T07:00:44.490", "LastActivityDate": "2010-09-20T07:36:06.200"}, "3750738": {"ParentId": "3749196", "CommentCount": "0", "Body": "<p>Templates have concept of <code>dependent name</code> and <code>non-dependent name</code>. Dependent names, simply speaking are those that somehow depend on the template parameter. In your code 'T *p', makes 'p' a dependent name as it depends on the template parameter <code>T</code></p>\n<p>Now <code>cout &lt;&lt; p[i]</code> requires an overload of <code>operator &lt;&lt;</code> like so</p>\n<pre><code>ostream&amp; operator &lt;&lt; (ostream &amp;os, T const &amp;t);\n</code></pre>\n<p>or an overload of <code>operator &lt;&lt;</code> to which 'T' can be converted.</p>\n<p>But is such an overload available? How does the compiler know this until 'T' is known?</p>\n<p>This is exactly what the above quote from the Standard talks about.</p>\n<p>Names such as 'i' etc are non-dependent as they do not depend on the template parameter in any way. Hence lookup of such non-dependent names can be resolved immediately even though 'T' is not known</p>\n", "OwnerUserId": "418110", "PostTypeId": "2", "Id": "3750738", "Score": "0", "CreationDate": "2010-09-20T10:57:22.480", "LastActivityDate": "2010-09-20T10:57:22.480"}, "3749196": {"CommentCount": "0", "ViewCount": "104", "PostTypeId": "1", "LastEditorUserId": "147192", "CreationDate": "2010-09-20T06:51:08.820", "LastActivityDate": "2010-09-20T10:57:22.480", "LastEditDate": "2010-09-20T07:34:42.490", "AcceptedAnswerId": "3749242", "OwnerDisplayName": "BE Student", "Title": "Templates :Name resolution -->can any one tell an other example for this statement...please", "Id": "3749196", "Score": "0", "Body": "<p>This is the statement from ISO C++ Standard 14.6/8:</p>\n<blockquote>\n<p id=\"so_3749196_3749196_0\">When looking for the declaration of a name used in a template definition, the usual  lookup rules are used for nondependent names. The lookup of names dependent on the template parameters is postponed until the actual template argument is known (14.6.2).</p>\n</blockquote>\n<p>Example:</p>\n<pre><code>  #include &lt;iostream&gt;\n  using namespace std;\n  template&lt;class T&gt; class Set {\n            T* p;\n            int cnt;\n  public:\n            Set();\n            Set&lt;T&gt;(const Set&lt;T&gt;&amp;);\n            void printall()\n            {\n                        for (int i = 0; i&lt;cnt; i++)\n                                   cout &lt;&lt; p[i] &lt;&lt; \u2019\\n\u2019;\n            }\n            // ...\n  };\n</code></pre>\n<p>in the example, i is the local variable i declared in printall, cnt is the member cnt declared in Set,and cout is the standard output stream declared in iostream. However, not every declaration can be found this way; the resolution of some names must be postponed until the actual template-arguments are known. For example, even though the name operator&lt;&lt; is known within the definition of printall() and a declaration of it can be found in , the actual declaration of operator&lt;&lt; needed to print p[i] cannot be known until it is known what type T is (14.6.2). </p>\n<p>Iam unable to understand this point...and the example too?</p>\n<p>can any one tell an other example for this statement...please</p>\n", "Tags": "<c++><templates>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_3749196_3749196_0": {"section_id": 176, "quality": 0.9166666666666666, "length": 22}}, "n3337": {"so_3749196_3749196_0": {"section_id": 170, "quality": 0.9166666666666666, "length": 22}}, "n4659": {"so_3749196_3749196_0": {"section_id": 181, "quality": 0.9166666666666666, "length": 22}}}});