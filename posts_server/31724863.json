post_cb({"31724863": {"ViewCount": "1309", "Body": "<p>I am trying to iterate over a number of <code>std::list</code>s, sorting each of them. This is the naive approach:</p>\n<pre><code>#include&lt;list&gt;\nusing namespace std;\nint main(void){\n    list&lt;int&gt; a,b,c;\n    for(auto&amp; l:{a,b,c}) l.sort();\n}\n</code></pre>\n<p>producing</p>\n<pre><code>aa.cpp:5:25: error: no matching member function for call to 'sort'\n        for(auto&amp; l:{a,b,c}) l.sort();\n                             ~~^~~~\n/usr/bin/../lib64/gcc/x86_64-linux-gnu/4.9/../../../../include/c++/4.9/bits/stl_list.h:1586:7: note: \n      candidate function not viable: 'this' argument has type 'const\n      std::list&lt;int, std::allocator&lt;int&gt; &gt;', but method is not marked const\n      sort();\n      ^\n/usr/bin/../lib64/gcc/x86_64-linux-gnu/4.9/../../../../include/c++/4.9/bits/stl_list.h:1596:9: note: \n      candidate function template not viable: requires 1 argument, but 0 were\n      provided\n        sort(_StrictWeakOrdering);\n        ^\n1 error generated.\n</code></pre>\n<p>Am I correctly guessing that brace-initializer is creating copy of those lists? And is there a way to not copy them, and make them modifiable inside the loop? (other than making list of pointers to them, which is my current workaround).</p>\n", "AcceptedAnswerId": "31725109", "Title": "Range-based for with brace-initializer over non-const values?", "CreationDate": "2015-07-30T13:14:53.277", "Id": "31724863", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-07-30T13:30:57.627", "LastEditorUserId": "2069064", "LastActivityDate": "2015-07-31T13:35:50.443", "Score": "15", "OwnerUserId": "761090", "Tags": "<c++><c++11><initializer-list>", "AnswerCount": "4"}, "31725282": {"Id": "31725282", "PostTypeId": "2", "Body": "<p>Direct answer to your question:</p>\n<blockquote>\n<p id=\"so_31724863_31725282_0\">Am I correctly guessing that brace-initializer is creating copy of\n  those lists?</p>\n</blockquote>\n<p>Yes, this is the first problem. Your code would create copies of your lists, sort those copies, and finally forget the sorted copies.</p>\n<p><strong>However</strong>, that alone would just result in non-working code. The compiler error hints to a second problem: The implicit type of <code>l</code> is <code>list&lt;int&gt; const&amp;</code>, rather than <code>list&lt;int&gt;&amp;</code>. So the compiler complains that <code>sort()</code> tries to modify constant lists.</p>\n<p>You can work around this second problem with a nasty <code>const_cast</code>:</p>\n<pre><code>#include &lt;list&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nint main(void){\n    list&lt;int&gt; a,b,c;\n    a.push_back(2);\n    a.push_back(0);\n    a.push_back(1);\n    for(auto&amp; l:{a,b,c}) const_cast&lt;list&lt;int&gt;&amp;&gt;(l).sort();\n    for(auto i:a) cout &lt;&lt; i &lt;&lt; endl;\n}\n</code></pre>\n<p>However, that will then trigger the first problem: Your list of lists contains copies, and only those copies are sorted. So the final output is not what you want:</p>\n<pre><code>2\n0\n1\n</code></pre>\n<p>The easiest workaround is to create a list of pointers to your lists:</p>\n<pre><code>#include &lt;list&gt;\n#include &lt;iostream&gt;\nusing namespace std;\nint main(void){\n    list&lt;int&gt; a,b,c;\n    a.push_back(2);\n    a.push_back(0);\n    a.push_back(1);\n    for(auto l:{&amp;a,&amp;b,&amp;c}) l-&gt;sort();\n    for(auto i:a) cout &lt;&lt; i &lt;&lt; endl;\n}\n</code></pre>\n<p>This will produce the desired result:</p>\n<pre><code>0\n1\n2\n</code></pre>\n", "LastActivityDate": "2015-07-30T13:34:25.637", "CommentCount": "0", "CreationDate": "2015-07-30T13:34:25.637", "ParentId": "31724863", "Score": "2", "OwnerUserId": "19163"}, "31725138": {"Id": "31725138", "PostTypeId": "2", "Body": "<p>The <code>{...}</code> syntax is actually creating an <a href=\"http://en.cppreference.com/w/cpp/utility/initializer_list\" rel=\"nofollow\"><code>std::initializer_list</code></a>. As the linked page states :</p>\n<blockquote>\n<p id=\"so_31724863_31725138_0\">A <code>std::initializer_list</code> object is automatically constructed when:</p>\n<ul>\n<li>[...]  </li>\n<li>a <em>braced-init-list</em> is bound to <code>auto</code>, including in a ranged for loop</li>\n</ul>\n</blockquote>\n<p>And :</p>\n<blockquote>\n<p id=\"so_31724863_31725138_1\">An object of type <code>std::initializer_list&lt;T&gt;</code> is a lightweight proxy object that provides access to an array of objects of type <code>const T</code>.</p>\n</blockquote>\n<p>Thus, you can't modify the objects accessed through this <code>initialize_list</code>. Your solutions with the pointers looks like the easiest one to me.</p>\n", "LastActivityDate": "2015-07-30T13:27:28.723", "CommentCount": "2", "CreationDate": "2015-07-30T13:27:28.723", "ParentId": "31724863", "Score": "2", "OwnerUserId": "3233393"}, "31726296": {"Id": "31726296", "PostTypeId": "2", "Body": "<p>It is possible to write a function <code>ref_range</code> which allows you to do this:</p>\n<pre><code>for(auto&amp; l : ref_range(a,b,c)) {\n    l.sort();\n}\n</code></pre>\n<p>As others have said, once you write <code>{a,b,c}</code> you are stuck with an <code>initializer_list</code>, and such a list always takes copies of its arguments. The copies are <code>const</code> (hence your error), but even if you could get a non-<code>const</code> reference you would be modifying the copies of <code>a</code>, <code>b</code> and <code>c</code> instead of the originals.</p>\n<p>Anyway, here is <code>ref_range</code>. It builds a <code>vector</code> of <code>reference_wrapper</code>.</p>\n<pre><code>// http://stackoverflow.com/questions/31724863/range-based-for-with-brace-initializer-over-non-const-values\n#include&lt;list&gt;\n#include&lt;functional&gt;\n#include&lt;array&gt;\n\ntemplate&lt;typename T, std:: size_t N&gt;\nstruct hold_array_of_refs {\n    using vec_type = std:: array&lt; std:: reference_wrapper&lt;T&gt;, N &gt;;\n    vec_type m_v_of_refs;\n    hold_array_of_refs(vec_type &amp;&amp; v_of_refs) : m_v_of_refs(std::move(v_of_refs)) { }\n    ~hold_array_of_refs() { }\n    struct iterator {\n        typename vec_type :: const_iterator m_it;\n        iterator(typename vec_type :: const_iterator it) : m_it(it) {}\n        bool operator != (const iterator &amp;other) {\n            return this-&gt;m_it != other.m_it;\n        }\n        iterator&amp; operator++() { // prefix\n            ++ this-&gt;m_it;\n            return *this;\n        }\n        T&amp; operator*() {\n            return *m_it;\n        }\n    };\n\n    iterator begin() const {\n        return iterator(m_v_of_refs.begin());\n    }\n    iterator end() const {\n        return iterator(m_v_of_refs.end());\n    }\n};\n\ntemplate&lt;typename... Ts&gt;\nusing getFirstTypeOfPack = typename std::tuple_element&lt;0, std::tuple&lt;Ts...&gt;&gt;::type;\n\n\ntemplate&lt;typename ...T&gt;\nauto ref_range(T&amp;... args) -&gt; hold_array_of_refs&lt; getFirstTypeOfPack&lt;T...&gt; , sizeof...(args)&gt; {\n    return {{{ std:: ref(args)... }}}; // Why does clang prefer three levels of {} ?\n}\n\n#include&lt;iostream&gt;\nint main(void){\n    std:: list&lt;int&gt; a,b,c;\n    // print the addresses, so we can verify we're dealing\n    // with the same objects\n    std:: cout &lt;&lt; &amp;a &lt;&lt; std:: endl;\n    std:: cout &lt;&lt; &amp;b &lt;&lt; std:: endl;\n    std:: cout &lt;&lt; &amp;c &lt;&lt; std:: endl;\n    for(auto&amp; l : ref_range(a,b,c)) {\n        std:: cout &lt;&lt; &amp;l &lt;&lt; std:: endl;\n        l.sort();\n    }\n}\n</code></pre>\n", "LastEditorUserId": "146041", "LastActivityDate": "2015-07-30T15:09:41.107", "Score": "6", "CreationDate": "2015-07-30T14:19:16.253", "ParentId": "31724863", "CommentCount": "7", "OwnerUserId": "146041", "LastEditDate": "2015-07-30T15:09:41.107"}, "bq_ids": {"n4140": {"so_31724863_31725138_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 6955}, "so_31724863_31725109_2": {"length": 8, "quality": 0.8, "section_id": 3327}, "so_31724863_31725109_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 3327}, "so_31724863_31725109_0": {"length": 47, "quality": 0.9215686274509803, "section_id": 3327}}, "n3337": {"so_31724863_31725109_0": {"length": 35, "quality": 0.6862745098039216, "section_id": 3197}, "so_31724863_31725109_2": {"length": 8, "quality": 0.8, "section_id": 3197}, "so_31724863_31725109_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 3197}, "so_31724863_31725138_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 6702}}, "n4659": {"so_31724863_31725109_0": {"length": 43, "quality": 0.8431372549019608, "section_id": 4093}, "so_31724863_31725109_2": {"length": 8, "quality": 0.8, "section_id": 4093}, "so_31724863_31725109_1": {"length": 6, "quality": 0.8571428571428571, "section_id": 4093}, "so_31724863_31725138_1": {"length": 8, "quality": 0.6666666666666666, "section_id": 8452}}}, "31725109": {"Id": "31725109", "PostTypeId": "2", "Body": "<p>You are guessing correctly. <code>std::initializer_list</code> elements are always <code>const</code> (which makes <code>sort()</code>ing them impossible, as <code>sort()</code> is a non-<code>const</code> member function) and its elements are always copied (which would make <code>sort()</code>-ing them meaningless even if they weren't <code>const</code>). From [dcl.init.list], emphasis mine:</p>\n<blockquote>\n<p id=\"so_31724863_31725109_0\">An object of type <code>std::initializer_list&lt;E&gt;</code> is constructed from an initializer list as if the implementation\n  allocated a temporary array of N elements of type <strong>const E</strong>, where N is the number of elements in the\n  initializer list. Each element of that array is <strong>copy-initialized</strong> with the corresponding element of the initializer\n  list, and the <code>std::initializer_list&lt;E&gt;</code> object is constructed to refer to that array. <em>[ Note:</em> A constructor\n  or conversion function selected for the copy shall be accessible (Clause 11) in the context of the initializer\n  list. <em>\u2014end note ]</em> If a narrowing conversion is required to initialize any of the elements, the program is\n  ill-formed. <em>[ Example:</em></p>\n<pre><code>struct X {\n    X(std::initializer_list&lt;double&gt; v);\n};\nX x{ 1,2,3 };\n</code></pre>\n<p id=\"so_31724863_31725109_1\">The initialization will be implemented in a way roughly equivalent to this:</p>\n<pre><code>const double __a[3] = {double{1}, double{2}, double{3}};\nX x(std::initializer_list&lt;double&gt;(__a, __a+3));\n</code></pre>\n<p id=\"so_31724863_31725109_2\">assuming that the implementation can construct an <code>initializer_list</code> object with a pair of pointers. <em>\u2014end\n  example ]</em></p>\n</blockquote>\n<p>There is no way to make them non-const or non-copied. The pointer solution works:</p>\n<pre><code>for (auto l : {&amp;a, &amp;b, &amp;c}) l-&gt;sort();\n</code></pre>\n<p>because it's the <em>pointer</em> that's const, not the element it's pointing to. The other alternative would be to write a variadic function template:</p>\n<pre><code>template &lt;typename... Lists&gt;\nvoid sortAll(Lists&amp;&amp;... lists) {\n    using expander = int[];\n    expander{0, (void(lists.sort()), 0)...};\n}\n\nsortAll(a, b, c);\n</code></pre>\n<p>You could also, I guess, write a helper to wrap your lists into an array of <code>reference_wrapper</code> to <code>list&lt;int&gt;</code> (since you can't have an array of references), but this is probably more confusing than helpful:</p>\n<pre><code>template &lt;typename List, typename... Lists&gt;\nstd::array&lt;std::reference_wrapper&lt;List&gt;, sizeof...(Lists) + 1&gt;\nas_array(List&amp; x, Lists&amp;... xs) {\n    return {x, xs...}; \n}\n\nfor (list&lt;int&gt;&amp; l : as_array(a, b, c)) {  // can't use auto, that deduces\n    l.sort();                             // reference_wrapper&lt;list&lt;int&gt;&gt;,\n}                                         // so would need l.get().sort()\n</code></pre>\n", "LastEditorUserId": "19163", "LastActivityDate": "2015-07-31T13:35:50.443", "Score": "17", "CreationDate": "2015-07-30T13:26:18.327", "ParentId": "31724863", "CommentCount": "7", "OwnerUserId": "2069064", "LastEditDate": "2015-07-31T13:35:50.443"}});