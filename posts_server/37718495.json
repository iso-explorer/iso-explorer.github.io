post_cb({"37718495": {"CommentCount": "3", "ViewCount": "55", "PostTypeId": "1", "LastEditorUserId": "1938163", "CreationDate": "2016-06-09T06:36:10.297", "LastActivityDate": "2016-06-09T06:55:46.110", "Title": "References and constants", "LastEditDate": "2016-06-09T06:41:56.280", "Id": "37718495", "Score": "1", "Body": "<p>We can bind a reference to an object only, not to a literal or to the result of a more genreal expression.</p>\n<pre><code>int i=42;\ndouble d=1.2;\nint &amp;r=10;//error:initializer must be an object.\nint &amp;r1=d; //error: initializer must be an int object\n</code></pre>\n<p>While we can bind a reference to a constant to an object, a literal and to the result of a more general expression as shown-</p>\n<pre><code>int j=45;\ndouble d=1.2;\nconst int &amp;r2=j; // works\nconst int &amp;r2=60; //works\nconst int &amp;r3=d; //works\n</code></pre>\n<p>The reason mentioned in Primer is that the compiler creates a temporary object of type 'constant int' here.</p>\n<pre><code>const int temp=d;\nconst int &amp;r3=temp;\n</code></pre>\n<p>But if this is the case, then this logic must apply to both the above cases, and both should work if the types of reference and the object are different. But in actual, if the types are different, then the program works only when the reference is of type 'reference to a constant' otherwise it shows an error. why ?</p>\n", "Tags": "<c++><reference>", "OwnerUserId": "6097562", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_37718495_37718726_0": {"section_id": 381, "quality": 0.7058823529411765, "length": 12}, "so_37718495_37718726_1": {"section_id": 3321, "quality": 0.75, "length": 6}, "so_37718495_37718726_3": {"section_id": 3321, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_37718495_37718726_0": {"section_id": 372, "quality": 0.7058823529411765, "length": 12}, "so_37718495_37718726_1": {"section_id": 3191, "quality": 0.75, "length": 6}, "so_37718495_37718726_3": {"section_id": 3191, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_37718495_37718726_0": {"section_id": 396, "quality": 0.7647058823529411, "length": 13}, "so_37718495_37718726_1": {"section_id": 4087, "quality": 0.75, "length": 6}, "so_37718495_37718726_3": {"section_id": 4087, "quality": 0.9166666666666666, "length": 11}}}, "37718726": {"ParentId": "37718495", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Simply put: a <em>const</em> reference prolongs the lifetime of a temporary. It's a feature of the language to avoid dangling references that might arise from the temporary destroyed.</p>\n<p>More precisely the C++ standard says:</p>\n<p><em>[class.temporary]/p5</em></p>\n<blockquote>\n<p id=\"so_37718495_37718726_0\">There are three contexts in which temporaries are destroyed at a different point than the end of the fullexpression [...] The third context is when a reference is bound to a temporary.</p>\n</blockquote>\n<p>and <em>[dcl.init.ref]/p5.2</em></p>\n<blockquote>\n<p id=\"so_37718495_37718726_1\">A reference to type \u201ccv1 T1\u201d is initialized by an expression of type \u201ccv2 T2\u201d as follows:</p>\n<p id=\"so_37718495_37718726_2\">[..lvalue and conversion cases..]</p>\n<p id=\"so_37718495_37718726_3\">Otherwise, the reference shall be an lvalue reference to a non-volatile const type (i.e., cv1 shall be\n  const), or the reference shall be an rvalue reference</p>\n</blockquote>\n<p>As for what rvalue/lvalue are, I recommend reading about <a href=\"http://en.cppreference.com/w/cpp/language/value_category\" rel=\"nofollow noreferrer\">value categories</a>.</p>\n<p>Finally a word of advice if you're using MSVC: <a href=\"https://stackoverflow.com/a/23685580/1938163\">turn your warnings on</a> for this particular issue.</p>\n", "OwnerUserId": "1938163", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:52:32.763", "Id": "37718726", "Score": "2", "CreationDate": "2016-06-09T06:50:44.920", "LastActivityDate": "2016-06-09T06:55:46.110"}});