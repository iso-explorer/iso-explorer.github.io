post_cb({"42501878": {"CommentCount": "2", "ViewCount": "65", "CreationDate": "2017-02-28T06:40:27.197", "LastActivityDate": "2017-02-28T08:20:09.243", "Title": "Packed structures sizes and inheritance with different compilers", "AcceptedAnswerId": "42503334", "PostTypeId": "1", "Id": "42501878", "Score": "0", "Body": "<p>Consider a MWE:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A     {}         __attribute__((packed)) ;\nstruct B : A { int x; } __attribute__((packed)) ;\n\nstruct C : A { B y; }   __attribute__((packed)) ;\n\nint main () {\n    std::cout &lt;&lt; \"Size of A: \" &lt;&lt; sizeof(A) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Size of B: \" &lt;&lt; sizeof(B) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Size of C: \" &lt;&lt; sizeof(C) &lt;&lt; std::endl;\n};\n</code></pre>\n<p>On Linux I tried to compile it and run:</p>\n<pre><code>$ g++ --version\ng++ (Ubuntu 5.4.0-6ubuntu1~16.04.4) 5.4.0 20160609\n\n$ g++ ./test.cpp &amp;&amp; ./a.out \nSize of A: 1 \nSize of B: 4 \nSize of C: 5\n</code></pre>\n<p>As for A and B everything is clear. But what about C? What adds 1 byte to the C's size? Moreover, if you'll remove any inheritance relationships, either for B or C, C become of size 4. Using MS compilers (at least one that is shipped with VS 2013), I got 1, 4 and 4 sizes. Any explanation and details on that are appreciated.</p>\n", "Tags": "<c++><gcc><visual-studio-2013><packing>", "OwnerUserId": "5823050", "AnswerCount": "1"}, "42503334": {"ParentId": "42501878", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_42501878_42503334_0\"><a href=\"http://eel.is/c++draft/class.derived#7\" rel=\"nofollow noreferrer\">[class.derived] / 7</a> (standard draft)</p>\n<p id=\"so_42501878_42503334_1\">... A base class subobject may be of zero size (Clause [class]); however, two subobjects that have the same class type and that belong to the same most derived object must not be allocated at the same address ([expr.eq]). \u2009\u2014\u2009end note\u2009]</p>\n</blockquote>\n<p><code>C</code> has subobjects <code>B::A</code> (base of member <code>y</code>) and <code>C::A</code> (direct base) which are both of type <code>A</code>. <code>y</code> could otherwise be at the same address as the the empty base of <code>C</code>, but since it also has a base of same type, that base of <code>B</code> may not have the same address and therefore must be offset with padding. GCC follows this rule and only applies packing request to padding that was needed for correct alignment.</p>\n", "OwnerUserId": "2079303", "LastEditorUserId": "2079303", "LastEditDate": "2017-02-28T08:20:09.243", "Id": "42503334", "Score": "2", "CreationDate": "2017-02-28T08:10:13.713", "LastActivityDate": "2017-02-28T08:20:09.243"}, "bq_ids": {"n4140": {"so_42501878_42503334_1": {"section_id": 6981, "quality": 0.8518518518518519, "length": 23}}, "n3337": {"so_42501878_42503334_1": {"section_id": 6727, "quality": 0.8518518518518519, "length": 23}}, "n4659": {"so_42501878_42503334_1": {"section_id": 8479, "quality": 0.8518518518518519, "length": 23}}}});