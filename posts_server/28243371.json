post_cb({"bq_ids": {"n4140": {"so_28243371_28243509_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 639}, "so_28243371_28243509_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 603}, "so_28243371_28243509_2": {"length": 11, "quality": 1.0, "section_id": 639}}, "n3337": {"so_28243371_28243509_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 593}, "so_28243371_28243509_2": {"length": 11, "quality": 1.0, "section_id": 629}, "so_28243371_28243509_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 629}}, "n4659": {"so_28243371_28243509_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 629}, "so_28243371_28243509_2": {"length": 11, "quality": 1.0, "section_id": 667}, "so_28243371_28243509_1": {"length": 18, "quality": 0.9473684210526315, "section_id": 667}}}, "28243509": {"Id": "28243509", "PostTypeId": "2", "Body": "<p>The fundamental reason for this (standard-conforming) ambiguity appears to lie within the cost of conversion: Overload resolution tries to minimize the operations performed to convert an argument to the corresponding parameter. An array is <em>effectively</em> the pointer to its first element though, decorated with some compile-time type information. An array-to-pointer conversion doesn't cost more than e.g. saving the address of the array itself, or initializing a reference to it. From that perspective, the ambiguity seems justified, although conceptually it is unintuitive (and may be subpar). In fact, this argumentation applies to all Lvalue Transformations, as suggested by the quote below. Another example:</p>\n<pre><code>void g() {}\n\nvoid f(void(*)()) {}\nvoid f(void(&amp;)()) {}\n\nint main() {\n    f(g); // Ambiguous\n}\n</code></pre>\n<hr>\n<p>The following is obligatory standardese. Functions that are not specializations of some function template are preferred over ones that are if both are otherwise an equally good match (see [over.match.best]/(1.3), (1.6)). In our case, the conversion performed is an array-to-pointer conversion, which is an Lvalue Transformation with Exact Match rank (according to table 12 in [over.ics.user]). [over.ics.rank]/3:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_28243371_28243509_0\">Standard conversion sequence <code>S1</code> is a better conversion sequence than standard conversion sequence  <code>S2</code> if</p>\n<ul>\n<li><p id=\"so_28243371_28243509_1\"><code>S1</code> is a proper subsequence of <code>S2</code> (comparing the conversion sequences in the canonical form  defined by 13.3.3.1.1, <strong>excluding\n  any Lvalue Transformation</strong>; the identity conversion sequence is considered to be a subsequence of any non-identity conversion\n  sequence) or, if not that,</p></li>\n<li><p id=\"so_28243371_28243509_2\">the rank of <code>S1</code> is better than the rank of <code>S2</code>, or <code>S1</code> and <code>S2</code> have the same rank and are distinguishable by the rules in the paragraph below, or, if not that,</p></li>\n<li><p id=\"so_28243371_28243509_3\">[..]</p></li>\n</ul></li>\n</ul>\n</blockquote>\n<p>The first bullet point excludes our conversion (as it is an Lvalue Transformation). The second one requires a difference in ranks, which isn't present, as both conversions have Exact match rank; The \"rules in the paragraph below\", i.e. in [over.ics.rank]/4, don't cover array-to-pointer conversions either.<br>\nSo believe it or not, none of both conversion sequences is better than the other, and thus the <code>char const*</code>-overload is picked.</br></p>\n<hr>\n<p>Possible workaround: Define the second overload as a function template as well, then partial ordering kicks in and selects the first one.</p>\n<pre><code>template &lt;typename T&gt;\nauto foo(T s)\n  -&gt; std::enable_if_t&lt;std::is_convertible&lt;T, char const*&gt;{}&gt;\n{\n    std::cout &lt;&lt; \"raw, size=\" &lt;&lt; std::strlen(s) &lt;&lt; std::endl;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/ef69810b39083a6c\"><strong>Demo</strong></a>.</p>\n</hr></hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2015-08-26T17:46:01.720", "Score": "37", "CreationDate": "2015-01-30T19:49:18.523", "ParentId": "28243371", "CommentCount": "3", "OwnerUserId": "3647361", "LastEditDate": "2015-08-26T17:46:01.720"}, "28243371": {"ViewCount": "1147", "Body": "<p>Let's say I'm writing a function to print the length of a string:</p>\n<pre><code>template &lt;size_t N&gt;\nvoid foo(const char (&amp;s)[N]) {\n    std::cout &lt;&lt; \"array, size=\" &lt;&lt; N-1 &lt;&lt; std::endl;\n}\n\nfoo(\"hello\") // prints array, size=5\n</code></pre>\n<p>Now I want to extend <code>foo</code> to support <em>non</em>-arrays:</p>\n<pre><code>void foo(const char* s) {\n    std::cout &lt;&lt; \"raw, size=\" &lt;&lt; strlen(s) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>But it turns out that this breaks my original intended usage:</p>\n<pre><code>foo(\"hello\") // now prints raw, size=5\n</code></pre>\n<p>Why? Wouldn't that require an array-to-pointer conversion, whereas the template would be an exact match? Is there a way to ensure that my array function gets called?</p>\n", "AcceptedAnswerId": "28243509", "Title": "Why does pointer decay take priority over a deduced template?", "CreationDate": "2015-01-30T19:39:06.680", "Id": "28243371", "CommentCount": "2", "FavoriteCount": "10", "PostTypeId": "1", "LastEditDate": "2015-04-15T20:29:45.857", "LastEditorUserId": "2069064", "LastActivityDate": "2015-08-26T17:46:01.720", "Score": "47", "OwnerUserId": "2069064", "Tags": "<c++><arrays><overload-resolution>", "AnswerCount": "1"}});