post_cb({"20295849": {"ParentId": "20295734", "LastEditDate": "2016-02-22T20:23:40.343", "CreationDate": "2013-11-30T02:33:34.430", "LastEditorUserId": "3953764", "LastEditorDisplayName": "user405725", "CommentCount": "0", "Score": "2", "Id": "20295849", "LastActivityDate": "2016-02-22T20:23:40.343", "OwnerDisplayName": "user405725", "Body": "<blockquote>\n<p id=\"so_20295734_20295849_0\">Does that makes array dynamic?</p>\n</blockquote>\n<p>It depends how you define \"dynamic\". VLA certainly cannot grow or shrink or, in other words, change its size once it is created. It is dynamic, though, in a sense that its length is not known in compile-time.</p>\n<blockquote>\n<p id=\"so_20295734_20295849_1\">Is this memory allocated at heap?</p>\n</blockquote>\n<p>How the memory is allocated for the VLA is implementation specific. Generally speaking, the memory for the VLA is allocated from space in the stack frame of the caller. It is then automatically freed when the function where VLA is defined returns to its caller, or if VLA goes out of scope.</p>\n<p>The closest relative of VLA is <a href=\"http://man7.org/linux/man-pages/man3/alloca.3.html\" rel=\"nofollow\"><code>alloca()</code></a> function, which pretty much can be considered to have the same effect, at least in C. Assuming that compiler implements the VLA the same way <code>alloca()</code> is implemented, you can think of these two arrays as being technically the same in C: </p>\n<pre><code>int *a = alloca(sizeof(int) * N);\nint b[N];\n</code></pre>\n<p>The VLA has, however, more compact and convenient syntax. But most importantly, VLA by nature has an automatic storage duration and gives compiler more freedom to decide whether to destroy/free the array upon leaving the scope where it was declared, or upon returning from the function. </p>\n<p>This becomes very important in languages such as C++ where compiler implements <a href=\"http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization\" rel=\"nofollow\">RAII idiom</a> and must guarantee to destroy objects with automatic storage duration upon exiting their scope.</p>\n<p>Note, however, that VLA is not currently a part of C++ language and is implemented by compiler as a non-standard extension. <del>But they are <a href=\"https://en.wikipedia.org/wiki/C++14#Runtime-sized_one_dimensional_arrays\" rel=\"nofollow\">expected to become standard in C++14</a></del>.</p>\n", "PostTypeId": "2"}, "20295770": {"ParentId": "20295734", "Score": "1", "CreationDate": "2013-11-30T02:17:27.620", "Id": "20295770", "OwnerUserId": "1899162", "LastActivityDate": "2013-11-30T02:17:27.620", "Body": "<p>Short answer: it reserves space on the stack, by incrementing the stack pointer. </p>\n", "PostTypeId": "2", "CommentCount": "0"}, "20295734": {"Tags": "<c++><c><arrays>", "ViewCount": "366", "LastEditDate": "2013-11-30T02:31:57.280", "CreationDate": "2013-11-30T02:12:07.393", "LastEditorUserId": "1708801", "Title": "variable length arrays VLA (static binding or dynamic)", "CommentCount": "8", "AcceptedAnswerId": "20295849", "Score": "3", "OwnerUserId": "1311840", "Id": "20295734", "LastActivityDate": "2016-02-22T20:23:40.343", "Body": "<p>It has been a long time since I have programmed in basic compilers with basic arrays, but recently I saw an array declaration like this:</p>\n<pre><code>int y;\ncin&gt;&gt;y;\nint z[y];\n</code></pre>\n<p>old time compilers used to give error \"Storage size of array isn't constant\". Then I found out about variable size arrays in C99. I wonder how they work internally. Does that makes array dynamic? Is this memory allocated at heap? Does this binding is still done statically? If so how.</p>\n", "PostTypeId": "1", "AnswerCount": "3"}, "20295841": {"ParentId": "20295734", "Score": "3", "CreationDate": "2013-11-30T02:30:24.337", "LastActivityDate": "2013-11-30T03:15:52.277", "LastEditDate": "2013-11-30T03:15:52.277", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "Body": "<p><a href=\"http://en.wikipedia.org/wiki/Variable-length_array\" rel=\"nofollow\">Variable Length Array</a>(<em>VLA</em>)s are a <em>C99</em> feature but several compilers including <code>gcc</code> supports <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html#Variable-Length\" rel=\"nofollow\">VLA as an extension</a> outside of <em>C99</em> and both <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html\" rel=\"nofollow\">gcc</a> and <a href=\"http://clang.llvm.org/compatibility.html#vla\" rel=\"nofollow\">clang</a> support <em>variable length arrays</em> in <em>C++</em> as an extension even though this is really a <em>C99</em> feature.</p>\n<p>In both <code>gcc</code> and <code>clang</code> building using the <code>-pedantic</code> flag will produce a warning similar to the following in <em>C</em>:</p>\n<pre><code>warning: variable length arrays are a C99 feature [-Wvla-extension]\n</code></pre>\n<p>and something similar to this in <em>C++</em>:</p>\n<pre><code>warning: ISO C++ forbids variable length array \u2018z\u2019 [-Wvla]\n</code></pre>\n<p>The usual implementation will allocate <em>VLA</em> on the stack since they will treat them just like other <em>automatic variables</em> which although the standard does not refer to the stack or heap are usually allocated on the stack in most cases.</p>\n<p>We can also see from the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"nofollow\">C99 draft standard</a> that <em>VLAs</em> are just another variation of an array declaration from section <code>6.7.5.2</code> <em>Array declarators</em> paragraph <em>4</em> says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_20295734_20295841_0\">If the size is not present, the array type is an incomplete type. If the size is * instead of being an expression, the array type is a variable length array type of unspecified size, which can only be used in declarations with function prototype scope;124) such arrays are nonetheless complete types. If the size is an integer constant expression and the element type has a known constant size, the array type is not a variable length array type; <strong>otherwise, the array type is a variable length array type.</strong></p>\n</blockquote>\n<p>we see from paragraph <em>5</em> that it's size does not change during it's lifetime:</p>\n<blockquote>\n<p id=\"so_20295734_20295841_1\">[...]The size of each instance of a variable length array type does not change during its lifetime.[...]</p>\n</blockquote>\n<p>Although a major difference with <em>VLAs</em> and other variables is that <em>sizeof</em> is <em>evaluated</em> for <em>VLAs</em> while otherwise it computed at compile time, from section <code>6.5.3.4</code> <em>The sizeof operator</em> paragraph <em>2</em>:</p>\n<blockquote>\n<p id=\"so_20295734_20295841_2\">[...]If the type of the operand is a variable length array type, the operand is evaluated; otherwise, the operand is not evaluated and the result is an integer constant.</p>\n</blockquote>\n", "Id": "20295841", "PostTypeId": "2", "CommentCount": "2"}, "bq_ids": {"n4659": {"so_20295734_20295841_2": {"length": 8, "section_id": 6103, "quality": 0.5714285714285714}}}});