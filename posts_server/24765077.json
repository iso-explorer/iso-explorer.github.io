post_cb({"24765077": {"CommentCount": "6", "ViewCount": "112", "CreationDate": "2014-07-15T18:01:55.027", "LastActivityDate": "2014-07-15T19:30:26.737", "Title": "Why doesn't the Standard allow the definition of the two functions `f` below?", "AcceptedAnswerId": "24765174", "PostTypeId": "1", "Id": "24765077", "Score": "1", "Body": "<p>\u00a714.8.2/4 allows the instantiation of two different functions, <code>g&lt;int&gt;</code> and <code>g&lt;const int&gt;</code> from the template definition. Why doesn't the Standard allow the definition of the two functions <code>f</code> in the code below? I know that both functions would have the same type <code>void(int)</code>. But that also happens with the instantiated functions <code>g</code>. The note in \u00a714.8.2/4 says: <code>f&lt;int&gt;(1) and f&lt;const int&gt;(1) call distinct functions even though both of the functions called have the same function type.</code>.</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;typename T&gt;\nvoid g(T t) { std::cout &lt;&lt; t &lt;&lt; '\\n'; }\n\nvoid f(int i) { std::cout &lt;&lt; i &lt;&lt; '\\n'; }\n//void f(int const i) { std::cout &lt;&lt; i &lt;&lt; '\\n'; }   // doesn't compile\n\nint main()\n{\n    g&lt;int&gt;(1);\n    g&lt;int const&gt;(2);\n} \n</code></pre>\n", "Tags": "<c++><templates><c++11>", "OwnerUserId": "3694387", "AnswerCount": "2"}, "24766606": {"ParentId": "24765077", "CommentCount": "0", "Body": "<p>The fact that top-level <code>const</code> is not part of the function signature allows for a minor advantage.</p>\n<p>Suppose you have a function\"</p>\n<pre><code>void f(int);\n</code></pre>\n<p>in its implementation, if you know you are not going to change the input parameter, you can declare:</p>\n<pre><code>void f(int const x) {\n  std::cout &lt;&lt; x &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>and this is none of the business of the caller.  Later, it turns out it would be useful to munge the input value (say, you want to treat negative integers as 0):</p>\n<pre><code>void f(int x) {\n  if (x&lt;0) x = 0;\n  std::cout &lt;&lt; x &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>and without changing the signature or the rest of the body of the function, we are good to go.</p>\n<p>Basically, the top level <code>const</code>ness of arguments doesn't impact the usual binary calling conventions of C++, and logically the <code>const</code>ness is no business of the caller.  By eliminating that from the signature, we get some benefit.</p>\n<p>For <code>template</code> functions, however, the types impact both the signature <strong>and</strong> the body of the function, and that body is part of the <code>template</code>'s interface.  (<code>decltype</code> lets the types of function parameters impact the body, but the body is not part of the interface like a <code>template</code>)</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "24766606", "Score": "0", "CreationDate": "2014-07-15T19:30:26.737", "LastActivityDate": "2014-07-15T19:30:26.737"}, "24765174": {"ParentId": "24765077", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Top-level <code>const</code>s on the parameter types are not part of the function signature. So the two versions of <code>f()</code> you've defined are the same function as far as overload resolution is concerned making the second one a redefinition.</p>\n<p>From <em>\u00a713.1/3 [over.load]</em></p>\n<blockquote>\n<p id=\"so_24765077_24765174_0\">\u2014 Parameter declarations that differ only in the presence or absence of <code>const</code> and/or <code>volatile</code> are equivalent. That is, <strong>the <code>const</code> and <code>volatile</code> type-specifiers for each parameter type are ignored when determining which function is being declared, defined, or called</strong>. [ <em>Example:</em><br/></p>\n<pre><code> typedef const int cInt;\n int f (int);\n int f (const int); // redeclaration of f(int)\n int f (int) { /* ... */ } // definition of f(int)\n int f (cInt) { /* ... */ } // error: redefinition of f(int)\n</code></pre>\n<p id=\"so_24765077_24765174_1\">\u2014end example ]<br/>\n<strong>Only the <code>const</code> and <code>volatile</code> type-specifiers at the outermost level of the parameter type specification are ignored in this fashion</strong>; <code>const</code> and <code>volatile</code> type-specifiers buried within a parameter type specification are significant and can be used to distinguish overloaded function declarations.</p>\n</blockquote>\n", "OwnerUserId": "241631", "LastEditorUserId": "241631", "LastEditDate": "2014-07-15T18:25:47.020", "Id": "24765174", "Score": "5", "CreationDate": "2014-07-15T18:07:08.917", "LastActivityDate": "2014-07-15T18:25:47.020"}, "bq_ids": {"n4140": {"so_24765077_24765174_1": {"section_id": 558, "quality": 0.8888888888888888, "length": 24}, "so_24765077_24765174_0": {"section_id": 558, "quality": 0.92, "length": 23}}, "n3337": {"so_24765077_24765174_1": {"section_id": 549, "quality": 0.8888888888888888, "length": 24}, "so_24765077_24765174_0": {"section_id": 549, "quality": 0.92, "length": 23}}, "n4659": {"so_24765077_24765174_1": {"section_id": 581, "quality": 0.8888888888888888, "length": 24}, "so_24765077_24765174_0": {"section_id": 581, "quality": 0.92, "length": 23}}}});