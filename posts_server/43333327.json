post_cb({"43333327": {"ViewCount": "81", "Body": "<p>I thought that endianness is not supposed to affect structs of size at most 1 byte. But here's the code on my little endian machine:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;bitset&gt;\n#include &lt;cstdint&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\n\nstatic_assert(sizeof(uint8_t) == 1, \"Wrong uint8_t size\");\n\nstruct Pieces {\n    uint8_t flag : 1;\n    uint8_t value : 7;\n};\n\nstatic_assert(sizeof(Pieces) == 1, \"Something went wrong with Pieces size\");\n\nint main()\n{\n    uint8_t value = 0b10001111;\n    Pieces pieces;\n    std::memcpy(&amp;pieces, &amp;value, 1);\n\n    cout &lt;&lt; bitset&lt;8&gt;(value) &lt;&lt; endl;\n    // 10001111\n    cout &lt;&lt; bitset&lt;1&gt;(pieces.flag) &lt;&lt; bitset&lt;7&gt;(pieces.value) &lt;&lt; endl;\n    // 11000111\n    return 0;\n}\n</code></pre>\n<p>The result is incorrect. But if I change the order of <code>flag</code> and <code>value</code> members in <code>pieces</code> struct then the result is correct. But isn't it supposed to be as I've written? I'm expecting the first (counting from the left) bit in <code>value</code> to be the flag. It looks like endianess issue but isn't endianess supposed define the order of bytes, not bits?</p>\n<p>Could someone explain to me what's exactly going on here?</p>\n", "AcceptedAnswerId": "43365697", "Title": "Endianness and bitfields of size 1", "CreationDate": "2017-04-10T21:41:45.640", "Id": "43333327", "CommentCount": "15", "LastEditDate": "2017-06-06T16:30:49.127", "PostTypeId": "1", "LastEditorUserId": "718379", "LastActivityDate": "2017-06-06T16:30:49.127", "Score": "0", "OwnerUserId": "645551", "Tags": "<c++><endianness>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_43333327_43365697_0": {"length": 7, "quality": 1.0, "section_id": 5921}}, "n3337": {"so_43333327_43365697_0": {"length": 7, "quality": 1.0, "section_id": 5693}}, "n4659": {"so_43333327_43365697_0": {"length": 7, "quality": 1.0, "section_id": 7395}}}, "43365697": {"Id": "43365697", "PostTypeId": "2", "Body": "<p>So let me gather all the info from comments.</p>\n<p>It seems that the order of bit fields is not specified in the standard and thus is implementation dependent. The relevant part of the standard is (thanks to @molbdnilo):</p>\n<blockquote>\n<p id=\"so_43333327_43365697_0\">\u00a79.6: \"Bit-fields are assigned right-to-left on some machines, left-to-right on others.\"</p>\n</blockquote>\n<p>Also let me note other comments. It seems that the order of bit fields is simply reversed in memory. This seems to be consistent with the order of normal fields as well and is probably consistent with endianness (I would appreciate if someone can check it on a big-endian machine).</p>\n<p>I guess that's what \"right-to-left on some machines\" and \"left-to-right on others\" means. However this is my interpretation and as stated earlier we should not depend on it.</p>\n", "LastActivityDate": "2017-04-12T09:32:55.763", "CommentCount": "0", "CreationDate": "2017-04-12T09:32:55.763", "ParentId": "43333327", "Score": "0", "OwnerUserId": "645551"}});