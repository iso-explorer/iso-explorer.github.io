post_cb({"44287701": {"ParentId": "44287410", "Score": "5", "CreationDate": "2017-05-31T14:38:10.223", "LastActivityDate": "2017-05-31T14:45:39.903", "LastEditDate": "2017-05-31T14:45:39.903", "OwnerUserId": "7662085", "LastEditorUserId": "7662085", "Body": "<p>First off, what you are doing doesn't really make sense out of context (getting the absolute value of an unsigned type). But I digress.</p>\n<p>The code you have posted doesn't compile. At least not in the compiler I used (whichever one repl.it uses). Instead it complains of an ambiguous overload. Even if it did compile, it would cast the <code>unsigned long long</code> to a different type which cannot support its actual value (in this case <code>double</code>).</p>\n<p>Changing <code>abs</code> to <code>llabs</code> like so:</p>\n<pre><code>std::cout &lt;&lt; (unsigned long long)std::llabs(9484282305798401ull);\n</code></pre>\n<p>..both makes it compile and produces an accurate result. See the documentation of the different <code>abs</code> functions for integer types <a href=\"http://en.cppreference.com/w/cpp/numeric/math/abs\" rel=\"noreferrer\">here</a>.</p>\n", "Id": "44287701", "PostTypeId": "2", "CommentCount": "4"}, "44287879": {"ParentId": "44287410", "Score": "8", "CreationDate": "2017-05-31T14:46:19.373", "LastActivityDate": "2017-06-09T17:33:40.193", "LastEditDate": "2017-06-09T17:33:40.193", "OwnerUserId": "3980929", "LastEditorUserId": "3980929", "Body": "<p>Your program is ill-formed. From <a href=\"http://eel.is/c++draft/c.math.abs#3\" rel=\"nofollow noreferrer\">[c.math.abs]/29.9.2.3</a>:</p>\n<blockquote>\n<p id=\"so_44287410_44287879_0\">If <code>abs()</code> is called with an argument of type <code>X</code> for which <code>is_\u00adunsigned_\u00adv&lt;X&gt;</code> is <code>true</code> and if <code>X</code> cannot be converted to <code>int</code> by integral promotion, the program is ill-formed.</p>\n</blockquote>\n<p>Compilers should have to warn you about this though.</p>\n<p>It also doesn't really make sense to call <code>std::abs</code> on an unsigned type anyways.</p>\n", "Id": "44287879", "PostTypeId": "2", "CommentCount": "3"}, "bq_ids": {"n4659": {"so_44287410_44287879_0": {"length": 12, "section_id": 4693, "quality": 1.0}}}, "44287410": {"Tags": "<c++><c++11><floating-point><precision><c++1z>", "ViewCount": "419", "LastEditDate": "2017-05-31T14:53:00.740", "CreationDate": "2017-05-31T14:25:13.793", "LastEditorUserId": "2511448", "Title": "Why is std::abs(9484282305798401ull) = 9484282305798400?", "CommentCount": "4", "AcceptedAnswerId": "44287701", "Score": "7", "OwnerUserId": "2511448", "Id": "44287410", "LastActivityDate": "2017-06-09T17:33:40.193", "Body": "<p>I'm currently writing a templated helper method that can convert C numbers in general (including unsigned long long) to mpz_class numbers in the GMP library. In between, there is a call to <code>std::abs</code>.</p>\n<p>However, it turns out that for on C++17 (g++ 6.3.1),</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\n\nint main()\n{\n    std::cout &lt;&lt; (unsigned long long)std::abs(9484282305798401ull);\n}\n</code></pre>\n<p>gives an incorrect output of <code>9484282305798400</code>.</p>\n<p>As I understood from <a href=\"http://www.cplusplus.com/reference/cmath/abs/\" rel=\"noreferrer\">cmath</a>, <code>std::abs</code> first casts the argument into a double.</p>\n<p>According to the C++ docs, double has 52 mantissa bits, which means that the maximum integer value that I must be strictly less than <code>2^52 = 4503599627370496</code> before any loss of precision.</p>\n<p>Am I correct to say that since <code>9484282305798401</code> exceeds this limit, <code>std::abs</code> ends up discarding precision to give an incorrect answer?</p>\n<p>To clarify, I'm absolutely aware that it makes completely no sense to ask for the absolute value of an unsigned integer; However, I would like the templated function work for general C numbers, instead of having to specifically create a specialization for each signed and unsigned type separately.</p>\n", "PostTypeId": "1", "FavoriteCount": "1", "AnswerCount": "3"}, "44289610": {"ParentId": "44287410", "Score": "3", "CreationDate": "2017-05-31T16:04:39.227", "LastActivityDate": "2017-06-01T08:33:00.113", "LastEditDate": "2017-06-01T08:33:00.113", "OwnerUserId": "4944425", "LastEditorUserId": "4944425", "Body": "<p>You can create your own overload of <code>abs</code> if you want to manage unsigned types in a way that is different for what the standard library function does:</p>\n<pre><code>#include &lt;cmath&gt;\n#include &lt;type_traits&gt;\n\nnamespace my {\n\ntemplate &lt;class S&gt;\nauto abs (S x) -&gt; typename std::enable_if&lt;std::is_signed&lt;S&gt;::value,\n                                          decltype(std::abs(x))&gt;::type\n{\n    return std::abs(x);\n}\n\ntemplate &lt;class U&gt;\nauto abs (U x) -&gt; typename std::enable_if&lt;std::is_unsigned&lt;U&gt;::value, U&gt;::type\n{\n    return x;\n}\n\n} // namespace my\n</code></pre>\n<p>Then </p>\n<pre><code>std::cout &lt;&lt; my::abs(9484282305798401ull) &lt;&lt; '\\n'              // -&gt; 9484282305798401\n          &lt;&lt; my::abs(-3.14159) &lt;&lt; '\\n'                         // -&gt; 3.14159\n          &lt;&lt; my::abs(std::numeric_limits&lt;char&gt;::min()) &lt;&lt; '\\n' // -&gt; 128\n          &lt;&lt; my::abs(std::numeric_limits&lt;int&gt;::min()) &lt;&lt; '\\n'  // -&gt; -2147483648\n</code></pre>\n<p>Please, note that <code>std::abs</code> promotes <code>char</code>s (signed in my implementation), but due to 2's complement representation of <code>int</code>s, fails to retrieve the absolute value of INT_MIN.</p>\n", "Id": "44289610", "PostTypeId": "2", "CommentCount": "2"}});