post_cb({"25101839": {"ViewCount": "92", "Body": "<p>I have a templated class which has a cast operator defined on it. This does not seem to work as expected when I define a stand alone overload for <code>operator+</code>.</p>\n<pre><code>template &lt;class TT&gt;\nclass Mtx\n{\nprivate:\n    MtxView&lt;TT&gt; m_view;\npublic:\n    operator const MtxView&lt;TT&gt; &amp;() const { return m_view; }\n    operator MtxView&lt;TT&gt;() { return m_view; }\n    ...\n};\n\ntemplate &lt;class TT&gt; Mtx&lt;TT&gt; operator+(const MtxView&lt;TT&gt; &amp;m1, const MtxView&lt;TT&gt; &amp;m2) \n{...}\n</code></pre>\n<p>In my test code below I get a compile error for the use of '+' which is \"Invalid operands to binary expression.\" I would have expected that the cast operator would allow this to work. Why is this failing and how can I fix it (without subclassing from <code>MtxView</code>)?</p>\n<pre><code>Mtx&lt;float&gt; m1, m2, m3;\n...\nm1 = m2 + m3;\n</code></pre>\n", "AcceptedAnswerId": "25101976", "Title": "Issues with c++ cast overloading operator", "CreationDate": "2014-08-03T05:10:38.283", "Id": "25101839", "CommentCount": "3", "LastEditDate": "2014-08-03T05:39:21.223", "PostTypeId": "1", "LastEditorUserId": "986059", "LastActivityDate": "2014-08-03T05:43:41.980", "Score": "1", "OwnerUserId": "986059", "Tags": "<c++><templates><casting><operator-overloading>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_25101839_25101976_0": {"length": 20, "quality": 1.0, "section_id": 289}}, "n3337": {"so_25101839_25101976_0": {"length": 20, "quality": 1.0, "section_id": 280}}, "n4659": {"so_25101839_25101976_0": {"length": 20, "quality": 1.0, "section_id": 296}}}, "25101976": {"Id": "25101976", "PostTypeId": "2", "Body": "<p>g++ gives better error messages (OT: probably the first time anyone's ever said that)</p>\n<pre><code>e.cc:22:10: note: candidate is:\ne.cc:16:29: note: template&lt;class TT&gt; Mtx&lt;TT&gt; operator+(const MtxView&lt;TT&gt;&amp;, const MtxView&lt;TT&gt;&amp;)\n     template &lt;class TT&gt; Mtx&lt;TT&gt; operator+(const MtxView&lt;TT&gt; &amp;m1, const MtxView&lt;TT&gt; &amp;m2)\n                         ^\ne.cc:16:29: note:   template argument deduction/substitution failed:\ne.cc:22:12: note:   'Mtx&lt;float&gt;' is not derived from 'const MtxView&lt;TT&gt;'\n\nm1 = m2 + m3;\n          ^    \n</code></pre>\n<p>The template deduction fails because of 14.8.1/6:</p>\n<blockquote>\n<p id=\"so_25101839_25101976_0\">Implicit conversions (Clause 4) will be performed on a function argument to convert it to the type of the corresponding function parameter if the parameter type contains no template-parameters that participate in template argument deduction</p>\n</blockquote>\n<p>In plain language this says that implicit conversion operators are not considered when performing deduction of the parameter <code>TT</code> for a function template <code>template&lt;typename TT&gt; U operator+(</code>...</p>\n<p>So the compiler cannot deduce what type <code>TT</code> should be.</p>\n<p><a href=\"http://codepad.org/SbpNckOF\" rel=\"nofollow\">MM's solution</a> (now deleted) works because <code>operator+</code> there is not a function template; <code>TT</code> is already known by virtue of the fact that you are calling a member function of a <code>Mtx&lt;float&gt;</code>.</p>\n", "LastActivityDate": "2014-08-03T05:39:34.807", "CommentCount": "7", "CreationDate": "2014-08-03T05:39:34.807", "ParentId": "25101839", "Score": "4", "OwnerUserId": "1505939"}});