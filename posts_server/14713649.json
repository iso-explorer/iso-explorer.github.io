post_cb({"14713688": {"Id": "14713688", "PostTypeId": "2", "Body": "<p>It is generally not thread-safe if the variable gets modified in one of the threads.</p>\n", "LastActivityDate": "2013-02-05T17:48:02.593", "CommentCount": "0", "CreationDate": "2013-02-05T17:48:02.593", "ParentId": "14713649", "Score": "1", "OwnerUserId": "968261"}, "14713692": {"Id": "14713692", "PostTypeId": "2", "Body": "<p>By thread-safe I suppose you mean to ask whether they have atomic writes. In C++03 this is not true, as C++03 doesn't really know about threads. In C++11 you have <a href=\"http://en.cppreference.com/w/cpp/atomic/atomic\" rel=\"nofollow\">std::atomic</a>, which is specialized for pointers.</p>\n", "LastEditorUserId": "560648", "LastActivityDate": "2013-02-05T17:59:28.570", "Score": "1", "CreationDate": "2013-02-05T17:48:19.723", "ParentId": "14713649", "CommentCount": "3", "OwnerUserId": "105672", "LastEditDate": "2013-02-05T17:59:28.570"}, "14713755": {"Id": "14713755", "PostTypeId": "2", "Body": "<p>It is always safe to <strong>read</strong> values from multiple threads. It's only when you're also writing to the data that you need to manage concurrent accesses.</p>\n<p>The only possible issue for read-only data is ensuring that the value has, in fact, been initialized when the reading is done. If you initialize the value before you start your threads you'll be fine.</p>\n", "LastEditorUserId": "1593860", "LastActivityDate": "2013-02-05T18:02:44.103", "Score": "3", "CreationDate": "2013-02-05T17:52:13.173", "ParentId": "14713649", "CommentCount": "15", "OwnerUserId": "1593860", "LastEditDate": "2013-02-05T18:02:44.103"}, "14713838": {"Id": "14713838", "PostTypeId": "2", "Body": "<p>Yes. Actually it is safe to <em>read</em> any values (of builtin type) concurrently.</p>\n<p>Data races can only occur, if a value is modified concurrently with some other thread using it. The key statements from the Standard for this are:</p>\n<p>A <em>data race</em> is defined in \u00a71.10/21:</p>\n<blockquote>\n<p id=\"so_14713649_14713838_0\">The execution of a program contains a data race if it contains two\n  conflicting actions in different threads, at least one of which is not\n  atomic, and neither happens before the other.</p>\n</blockquote>\n<p>where <em>conflicting</em> is defined in \u00a71.10/4:</p>\n<blockquote>\n<p id=\"so_14713649_14713838_1\">Two expression evaluations conflict if one of them modifies a memory\n  location (1.7) and the other one accesses or modifies the same memory\n  location.</p>\n</blockquote>\n<p>So you must use suitable synchronization between those reads and any writes.</p>\n", "LastActivityDate": "2013-02-05T17:56:24.117", "CommentCount": "0", "CreationDate": "2013-02-05T17:56:24.117", "ParentId": "14713649", "Score": "7", "OwnerUserId": "585729"}, "bq_ids": {"n4140": {"so_14713649_14713838_1": {"length": 15, "quality": 0.9375, "section_id": 5817}, "so_14713649_14713838_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 5834}}, "n3337": {"so_14713649_14713838_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 5605}, "so_14713649_14713838_1": {"length": 15, "quality": 0.9375, "section_id": 5588}}, "n4659": {"so_14713649_14713838_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 7296}, "so_14713649_14713838_1": {"length": 14, "quality": 0.875, "section_id": 7278}}}, "14713649": {"ViewCount": "2405", "Body": "<p>I can't find the answer but it's a simple question:</p>\n<p>Is it safe for two threads to read the value of a pointer to a user-defined object in c++ at the same time with no locks or any other shenanigans?</p>\n", "AcceptedAnswerId": "14713838", "Title": "are c++ pointers to user-defined objects thread safe for reading?", "CreationDate": "2013-02-05T17:46:03.897", "Id": "14713649", "CommentCount": "0", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2013-02-05T18:02:44.103", "Score": "3", "OwnerUserId": "1760428", "Tags": "<c++><multithreading><pointers><thread-safety>", "AnswerCount": "4"}});