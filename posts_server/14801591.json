post_cb({"bq_ids": {"n4140": {"so_14801591_14804071_2": {"length": 9, "quality": 1.0, "section_id": 6700}, "so_14801591_14804071_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 5962}, "so_14801591_14804071_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 5929}}, "n3337": {"so_14801591_14804071_2": {"length": 9, "quality": 1.0, "section_id": 6455}, "so_14801591_14804071_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 5731}, "so_14801591_14804071_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 5701}}, "n4659": {"so_14801591_14804071_2": {"length": 9, "quality": 1.0, "section_id": 8174}, "so_14801591_14804071_0": {"length": 13, "quality": 0.5652173913043478, "section_id": 7452}, "so_14801591_14804071_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 7414}}}, "14801591": {"ViewCount": "913", "Body": "<p>For this game, I have a Game class, it's a singleton... Here's the header file</p>\n<pre><code>#ifndef SOKOBAN_GAME_H\n#define SOKOBAN_GAME_H\n#include &lt;memory&gt;\n#include &lt;SDL/SDL.h&gt;\nnamespace sokoban\n{\n  class Game\n  {\n  public:\n    static Game* getInstance();\n    void startGame();\n  private:\n    Game();\n    ~Game();\n    Game(const Game&amp;) = delete;\n    Game(Game&amp;&amp;) = delete;\n    Game&amp; operator=(const Game&amp;) = delete;\n    Game&amp; operator=(Game&amp;&amp;) = delete;\n\n    static std::shared_ptr&lt;Game&gt; instance_;\n    SDL_Surface* mainSurface_;\n  };\n};\n#endif\n</code></pre>\n<p>Now, most of the implementation file is unimportant except for the getInstance function:</p>\n<pre><code>Game* Game::getInstance()\n{\n  if(!Game::instance_)\n  {\n    Game::instance_ = std::shared_ptr&lt;Game&gt;(new Game,\n    [](Game* ptr)\n    {\n      delete ptr;\n    });\n  }\n\n  return Game::instance_.get();\n}\n</code></pre>\n<p>As you can see, my lazy-initialize style requires that I use a smart pointer, however because I am trying to avoid a public destructor, I have to use a lambda as a deleter, now this code compiles fine, however I can't seem to find any pattern of why a lambda, said by the standard to be a separate unique object, can call this private method, especially after looking at some questions on SO like:</p>\n<ul>\n<li><a href=\"https://stackoverflow.com/questions/11933999/why-is-it-not-possible-to-use-private-method-in-a-lambda\">Why is it not possible to use private method in a lambda?</a></li>\n</ul>\n<p>What I basically want to know is the access rules of a lambda in a member function like the example...</p>\n", "AcceptedAnswerId": "14804071", "Title": "Calling private destructor as deleter for std::shared_ptr using lambda?", "CreationDate": "2013-02-10T19:17:54.767", "Id": "14801591", "CommentCount": "0", "LastEditDate": "2017-05-23T12:22:28.823", "PostTypeId": "1", "OwnerDisplayName": "user451498", "LastEditorUserId": "-1", "LastActivityDate": "2013-02-13T21:13:15.833", "Score": "0", "Tags": "<c++><memory-management><c++11><lambda><anonymous-function>", "AnswerCount": "1"}, "14804071": {"Id": "14804071", "PostTypeId": "2", "Body": "<p>The standard says in 5.1.2/3</p>\n<blockquote>\n<p id=\"so_14801591_14804071_0\">The type of the lambda-expression [...] is a unique\u00a0[...] class type \u2014\n  called the closure type [...] The closure type is declared in the\n  smallest block scope, class scope, or namespace scope that contains\n  the corresponding lambda-expression.</p>\n</blockquote>\n<p>This means that a lambda that occurs inside a (member) function is treated like a local class, declared at block scope in the surrounding function. About local classes, the standard says in 9.8/1:</p>\n<blockquote>\n<p id=\"so_14801591_14804071_1\">[...] The local class is in the scope of the enclosing scope, and has\n  the same access to names outside the function as does the enclosing\n  function.[...]</p>\n</blockquote>\n<p>Thus the lambda has the same access as the containing member function, which means that it can access private members of the class.</p>\n<p>If a lambda occurs directly in a class scope, it would be treated as a nested class, for which a similar rule applies: 11.7/1 says:</p>\n<blockquote>\n<p id=\"so_14801591_14804071_2\">A nested class is a member and as such has the same access rights as\n  any other member.</p>\n</blockquote>\n<p>Either way, a lambda that occurs within in the scope of a class has access to private class members. So your example is fine.</p>\n<p>(The post you referred to, ultimately was about a problem accessing protected members of base classes named by a <em>qualified-id</em>.)</p>\n", "LastActivityDate": "2013-02-10T23:54:29.387", "CommentCount": "1", "CreationDate": "2013-02-10T23:54:29.387", "ParentId": "14801591", "Score": "3", "OwnerUserId": "585729"}});