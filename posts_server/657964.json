post_cb({"660279": {"ParentId": "657964", "CommentCount": "2", "Body": "<p>You will sometimes see constructions like this in fairly esoteric template library code, but only inside a <code>sizeof()</code> where it is harmless.</p>\n<p>Supposing you wanted to know the size of the return type of a function-like type <code>F</code> if it was passed a reference to a type <code>T</code> as an argument (both of those being template parameters). You could write:</p>\n<pre><code>sizeof(F(T()))\n</code></pre>\n<p>But what if T happens to have no public default constructor? So you do this instead:</p>\n<pre><code>sizeof(F(*((T *)0)))\n</code></pre>\n<p>The expression passed to <code>sizeof</code> never executes - it just gets analyzed to the point where the compiler knows the size of the result.</p>\n", "OwnerUserId": "27423", "Id": "660279", "PostTypeId": "2", "OwnerDisplayName": "Earwicker", "Score": "16", "CreationDate": "2009-03-18T22:00:17.940", "LastActivityDate": "2009-03-18T22:00:17.940"}, "660306": {"ParentId": "657964", "CommentCount": "1", "Body": "<pre><code>f( *((std::string*)NULL) );\n</code></pre>\n<p>This is essentially dereferencing NULL, which on most systems is #defined to be 0. Last I checked 0x00000000 is an <strong>invalid</strong> memory address for doing anything.</p>\n<p>Whatever happened to just checking</p>\n<pre><code>if (std::string.length() &gt; 0) ....\n</code></pre>\n", "OwnerUserId": "12776", "Id": "660306", "PostTypeId": "2", "OwnerDisplayName": "Dashogun", "Score": "1", "CreationDate": "2009-03-18T22:09:53.237", "LastActivityDate": "2009-03-18T22:09:53.237"}, "657964": {"CommentCount": "2", "AcceptedAnswerId": "657968", "OwnerDisplayName": "rve", "CreationDate": "2009-03-18T12:00:58.523", "LastActivityDate": "2009-03-19T10:00:17.057", "PostTypeId": "1", "ViewCount": "2629", "FavoriteCount": "5", "Title": "Is using NULL references OK?", "Id": "657964", "Score": "12", "Body": "<p>I came across this code:</p>\n<pre><code>void f(const std::string &amp;s);\n</code></pre>\n<p>And then a call:</p>\n<pre><code>f( *((std::string*)NULL) );\n</code></pre>\n<p>And I was wondering what others think of this construction, it is used to signal that function f() should use some default value (which it computes) instead of some user provided value.</p>\n<p>I am not sure what to think of it, it looks weird but what do you think of this construction?</p>\n", "Tags": "<c++>", "OwnerUserId": "79455", "AnswerCount": "7"}, "658068": {"ParentId": "657964", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_657964_658068_0\">Is using NULL references OK?</p>\n</blockquote>\n<p>No, unless you do not like your boss and your job ;)</p>\n<p>This is something VERY bad. One of most important point of reference that it\ncan't be NULL (unless you force it)</p>\n", "OwnerUserId": "66522", "Id": "658068", "PostTypeId": "2", "OwnerDisplayName": "Artyom", "Score": "3", "CreationDate": "2009-03-18T12:32:37.510", "LastActivityDate": "2009-03-18T12:32:37.510"}, "660246": {"ParentId": "657964", "CommentCount": "0", "Body": "<p>As others already said: A reference has to be valid. That's why it's a reference instead of a pointer.</p>\n<p>If you want to make f() have a default behavior, you might want to use this:</p>\n<pre><code>static const std::string default_for_f;\n\nvoid f(const std::string &amp;s = default_for_f)\n{\n    if (&amp;s == &amp;default_for_f)\n    {\n        // make default processing\n    }\n    else\n    ...\n}\n...\nvoid bar()\n{\n    f();              // call with default behavior\n    f(default_for_f); // call with default behavior\n    f(std::string()); // call with other behavior\n}\n</code></pre>\n<p>You can spare the default parameter for f(). (Some people hate default parameters.)</p>\n", "OwnerUserId": "47249", "PostTypeId": "2", "Id": "660246", "Score": "2", "CreationDate": "2009-03-18T21:47:41.093", "LastActivityDate": "2009-03-18T21:47:41.093"}, "657968": {"CommentCount": "0", "CreationDate": "2009-03-18T12:03:56.097", "LastEditorUserId": "67392", "LastActivityDate": "2009-03-19T10:00:17.057", "ParentId": "657964", "PostTypeId": "2", "LastEditorDisplayName": "Richard", "LastEditDate": "2009-03-19T10:00:17.057", "Id": "657968", "Score": "53", "Body": "<p>No. It is undefined behaviour and can lead to code to do anything (including reformatting you hard disk, core dumping or insulting your mother).</p>\n<p>If you need to be able to pass NULL, then use pointers. Code that takes a reference can assume it refers to a valid object.</p>\n<hr>\n<p>Addendum: The C++03 Standard (ISO/IEC 14882, 2<sup>nd</sup> edition 2003) says, in \u00a78.3.2 \"References\", paragraph 4:</p>\n<blockquote>\n<p id=\"so_657964_657968_0\">A reference shall be initialized to refer to a valid object\n  or function. [<em>Note:</em> in particular, a null reference cannot exist in a well-defined program, because the <strong>only\n  way to create such a reference would be to bind it to the \u201cobject\u201d obtained by dereferencing a null pointer,\n  which causes undefined behavior.</strong> As described in 9.6, a reference cannot be bound directly to a bit-field. ]</p>\n</blockquote>\n<p>[Bold added for emphasis]</p>\n</hr>", "OwnerUserId": "67392", "OwnerDisplayName": "Richard"}, "659239": {"ParentId": "657964", "CommentCount": "0", "Body": "<p>for the case you can make \"empty object\", which will play the role of the zero pointer</p>\n<pre><code>class Foo\n{\nstatic Foo empty;\npublic:\n  static bool isEmpty( const Foo&amp; ref )\n  {\n    return &amp;ref==&amp;empty;\n  }\n}\n</code></pre>\n", "OwnerUserId": "77342", "Id": "659239", "PostTypeId": "2", "OwnerDisplayName": "dark", "Score": "3", "CreationDate": "2009-03-18T17:12:45.683", "LastActivityDate": "2009-03-18T17:12:45.683"}, "bq_ids": {"n4140": {"so_657964_657968_0": {"section_id": 3222, "quality": 0.9411764705882353, "length": 32}}, "n3337": {"so_657964_657968_0": {"section_id": 3096, "quality": 0.9705882352941176, "length": 33}}, "n4659": {"so_657964_657968_0": {"section_id": 3979, "quality": 0.9411764705882353, "length": 32}}}, "658105": {"ParentId": "657964", "CommentCount": "1", "Body": "<p>I'm curious - does function 'f' actually check for this condition? Because if it doesn't, and it tries to use the string, then this is clearly going to crash when you try to use it. </p>\n<p>And if 'f' does check the reference for NULL, then why isn't it just using a pointer? Is there some hard and fast rule that you won't use pointers and some knucklehead obeyed the letter of the law without thinking about what it meant?</p>\n<p>I'd just like to know...</p>\n", "OwnerUserId": "5801", "Id": "658105", "PostTypeId": "2", "OwnerDisplayName": "Michael Kohne", "Score": "5", "CreationDate": "2009-03-18T12:42:28.813", "LastActivityDate": "2009-03-18T12:42:28.813"}});