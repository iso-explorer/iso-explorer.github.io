post_cb({"44065567": {"Id": "44065567", "PostTypeId": "2", "Body": "<p>There is no way to do this.  You might be able to make it work on your compiler, but the resulting program is ill formed no diagnostic required.</p>\n<p>Use <code>=delete</code>.</p>\n<pre><code>template&lt; class T &gt;\nvoid marshal(std::string name, T  *value) = delete;\n</code></pre>\n", "LastActivityDate": "2017-05-19T08:53:50.343", "CommentCount": "1", "CreationDate": "2017-05-19T08:53:50.343", "ParentId": "44059557", "Score": "4", "OwnerUserId": "1774667"}, "44064262": {"Id": "44064262", "PostTypeId": "2", "Body": "<p>What you are trying to do is doomed to be ill-formed (even your workaround can fail) according to <a href=\"http://eel.is/c++draft/temp#res-8\" rel=\"nofollow noreferrer\">[temp.res]/8</a> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_44059557_44064262_0\">Knowing which names are type names allows the syntax of every template\n  to be checked. <strong>The program is ill-formed</strong>, no diagnostic required, <strong>if</strong>:<br>\n   - <strong>no valid specialization can be generated for a template</strong> or a substatement of a constexpr if statement within a template and the\n  template is not instantiated, or (...)</br></p>\n</blockquote>\n", "LastActivityDate": "2017-05-19T07:42:54.000", "CommentCount": "2", "CreationDate": "2017-05-19T07:42:54.000", "ParentId": "44059557", "Score": "2", "OwnerUserId": "4324224"}, "44059557": {"ViewCount": "117", "Body": "<p>I\u2019m trying to use static_assert to force something to fail.  If you try to instantiate a specific templated function in a specific way I want to generate a complier error.  I could make it work, but it was really ugly.  Is there an easier way to do this?</p>\n<p>This was my first attempt.  This did not work at all.  It always generates an error, even if no one tries to use this function.</p>\n<pre><code>template&lt; class T &gt;\nvoid marshal(std::string name, T  *value)\n{\n  static_assert(false, \"You cannot marshal a pointer.\");\n}\n</code></pre>\n<p>Here\u2019s my second attempt.  It actually works.  If you don\u2019t call this, you get no error.  If you do call this, you get a very readable error message that points to this line and points to the code that tried to instantiate it.</p>\n<pre><code>template&lt; class T &gt;\nvoid marshal(std::string name, T  *value)\n{\n  static_assert(std::is_pod&lt;T&gt;::value &amp;&amp; !std::is_pod&lt;T&gt;::value, \"You cannot marshal a pointer.\");\n}\n</code></pre>\n<p>The problem is that this code is ugly at best.  It looks like a hack.  I\u2019m afraid the next time I change the optimization level, upgrade my compiler, sneeze, etc, the compiler will realize that this second case is the same as the first, and they will both stop working.</p>\n<p>Is there a better way to do what I\u2019m trying to do?</p>\n<p>Here\u2019s some context.  I want to have several different versions of marshal() which work for different input types.  I want one version that uses a template as the default case.  I want another one that specifically disallows any pointers except char *.</p>\n<pre><code>void marshal(std::string name, std::string)\n{ \n  std::cout&lt;&lt;name&lt;&lt;\" is a std::string type.\"&lt;&lt;std::endl;\n}\n\nvoid marshal(std::string name, char *string)\n{\n  marshal(name, std::string(string));\n}\n\nvoid marshal(std::string name, char const *string)\n{\n  marshal(name, std::string(string));\n}\n\ntemplate&lt; class T &gt;\nvoid marshal(std::string name, T value)\n{\n  typedef typename std::enable_if&lt;std::is_pod&lt;T&gt;::value&gt;::type OnlyAllowPOD;\n  std::cout&lt;&lt;name&lt;&lt;\" is a POD type.\"&lt;&lt;std::endl;\n}\n\ntemplate&lt; class T &gt;\nvoid marshal(std::string name, T  *value)\n{\n  static_assert(false, \"You cannot marshal a pointer.\");\n}\n\nint main (int argc, char **argv)\n{\n  marshal(\u201cshould be pod\u201d, argc);\n  marshal(\u201cshould fail to compile\u201d, argv);\n  marshal(\u201cshould fail to compile\u201d, &amp;argc);\n  marshal(\u201cshould be std::string\u201d, argv[0]);\n}\n</code></pre>\n", "AcceptedAnswerId": "44065567", "Title": "What's the right way to call static_assert(false)?", "CreationDate": "2017-05-19T00:14:01.330", "Id": "44059557", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2017-05-19T14:44:10.363", "Score": "0", "OwnerUserId": "971955", "Tags": "<c++11><sfinae><static-assert>", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_44059557_44064262_0": {"length": 18, "quality": 0.72, "section_id": 175}}, "n3337": {"so_44059557_44064262_0": {"length": 18, "quality": 0.72, "section_id": 169}}, "n4659": {"so_44059557_44064262_0": {"length": 24, "quality": 0.96, "section_id": 180}}}, "44072979": {"Id": "44072979", "PostTypeId": "2", "Body": "<p>I don't understand why you have <code>template&lt; class T &gt; void marshal(std::string name, T  *value)</code> in the first place. This should just be a static_assert in the primary template.</p>\n<p>That is, you should change the definition of your primary template to</p>\n<pre><code>template&lt; class T &gt;\nvoid marshal(std::string name, T value)\n{\n  static_assert(std::is_pod&lt;T&gt;::value);\n  static_assert(!std::is_pointer&lt;T&gt;::value);\n  std::cout&lt;&lt;name&lt;&lt;\" is a POD type.\"&lt;&lt;std::endl;\n}\n</code></pre>\n", "LastActivityDate": "2017-05-19T14:44:10.363", "CommentCount": "2", "CreationDate": "2017-05-19T14:44:10.363", "ParentId": "44059557", "Score": "1", "OwnerUserId": "4672588"}, "44065093": {"Id": "44065093", "PostTypeId": "2", "Body": "<p>Relying on a contradiction is not the best indeed, but there's a simpler way:</p>\n<pre><code>template &lt;class...&gt;\nstruct False : std::bool_constant&lt;false&gt; { };\n\ntemplate &lt;class T&gt;\nvoid bang() {\n    static_assert(False&lt;T&gt;{}, \"bang!\");\n}\n</code></pre>\n<p>Why does this not fall under the \"no valid specialization\" case?<br>\nWell, because you <em>can</em> actually make a valid specialization, with that second half of the code:</br></p>\n<pre><code>template &lt;&gt;\nstruct False&lt;int&gt; : std::bool_constant&lt;true&gt; { };\n\nint main() {\n    bang&lt;int&gt;(); // No \"bang\"!\n}\n</code></pre>\n<p>Of course, no one is actually going to specialize <code>False</code> to break your assertions in real code, but it is possible :)</p>\n", "LastActivityDate": "2017-05-19T08:30:53.870", "CommentCount": "6", "CreationDate": "2017-05-19T08:30:53.870", "ParentId": "44059557", "Score": "2", "OwnerUserId": "3233393"}});