post_cb({"35463025": {"ParentId": "35461561", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>It's because of template instantiation rules. At the point of <code>A</code>'s declaration, only <code>std::vector&lt;B&gt;</code>'s <em>interface</em> is required to be instantiated.</p>\n<p>Since <code>std::vector</code>'s interface only uses pointers and references to its value type, and the specialization in your example gets instantiated but none of its functions are used, you don't get a compiler error for it.</p>\n<p>As for why the compiler didn't generate <code>A::A()</code>\u2014which would've triggered the error by calling <code>std::vector&lt;B&gt;</code>'s constructor\u2014it's because your context only required its <em>declaration</em>. The compiler only needs to generate defaults for these special member functions if it sees they're used.</p>\n<h3>References</h3>\n<hr>\n<blockquote>\n<h3>\u00a7 14.7.1</h3>\n<p id=\"so_35461561_35463025_0\">[...] The implicit instantiation of a class template specialization causes the implicit instantiation of the declarations, but not of the definitions or default arguments, of the class member functions, member classes, scoped member enumerations, static data members and member templates[.]</p>\n<h3>\u00a7 12</h3>\n<p id=\"so_35461561_35463025_1\"><em>[1]</em> [...] The implementation will implicitly declare these [special] member functions for some class types when the program does not explicitly declare them. <em>The implementation will implicitly define them if they are odr-used.</em></p>\n</blockquote>\n</hr>", "OwnerUserId": "602372", "LastEditorUserId": "602372", "LastEditDate": "2016-02-17T17:28:42.297", "Id": "35463025", "Score": "3", "CreationDate": "2016-02-17T16:59:41.177", "LastActivityDate": "2016-02-17T17:28:42.297"}, "35462560": {"ParentId": "35461561", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>T.C commented that this is actually undefined behavior which is being addressed in a change request to the standard. The rule which is violated is apparently [res.on.functions] 2.5:</p>\n<blockquote>\n<p id=\"so_35461561_35462560_0\">In particular, the effects are undefined in the following cases: [...]</p>\n<ul>\n<li>if an incomplete type (3.9) is used as a template argument when instantiating a template component, unless specifically allowed for that component.</li>\n</ul>\n</blockquote>\n<p>The reason this works anyway (and the reason that it can be standardized) is two-fold:</p>\n<ol>\n<li><p>Your program only contains type definitions; no objects are created, no functions are called, no code is generated. If we simplify it by eliminating B's definition (it's not needed) and then try to create an instance of <code>A</code>, it fails:</p>\n<pre><code>class B;\nclass A { std::vector&lt;B&gt; b; };\nA a; // error: ctor and dtor undefined for incomplete type B.\n</code></pre>\n<p>What also fails, as expected, is a simple</p>\n<pre><code>std::vector&lt;B&gt; b;\n</code></pre>\n<p>The reason in both cases is that the compiler must produce code, as opposed to a mere type declaration which is only grammatically relevant. </p>\n<p>The use of the vector <em>type</em> is ok also in other contexts:</p>\n<pre><code>typedef std::vector&lt;B&gt; BVec;\n</code></pre></li>\n<li><p>Class <code>A</code> can be defined because, as Nikolay correctly says in his answer, the size of <code>std::vector&lt;B&gt;</code>, and hence the size of <code>A</code>'s member <code>b</code>, does not depend on the definition of <code>B</code> (because a vector holds a pointer to an array of elements, not an array proper).</p></li>\n</ol>\n", "OwnerUserId": "3150802", "LastEditorUserId": "3150802", "LastEditDate": "2016-02-17T17:32:13.967", "Id": "35462560", "Score": "5", "CreationDate": "2016-02-17T16:37:28.673", "LastActivityDate": "2016-02-17T17:32:13.967"}, "35462046": {"ParentId": "35461561", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>This compiles and runs ok because <code>std::vector</code> uses pointers and not the exact definition of <code>A</code> or <code>B</code>. You could modify your example to use single instance or array in the definition of the classes like so</p>\n<pre><code>class B;\nclass A { public: B b[2]; };\nclass B { public: A a[2]; };\n</code></pre>\n<p>This obviously fails to compile since you're trying to use definition of the classes. And the error by the compiler would be as you're expecting</p>\n<blockquote>\n<p id=\"so_35461561_35462046_0\">error: field \u2018b\u2019 has incomplete type \u2018B [2]\u2019</p>\n</blockquote>\n<p>However</p>\n<pre><code>class B;\nclass A { public: B* b; };\nclass B { public: A* a; };\n</code></pre>\n<p>would work just like <code>std::vector</code>. So you don't need fully defined class to use pointer or reference to this type.</p>\n<p>Also there is simplified example with templates</p>\n<pre><code>template&lt;typename T&gt;\nstruct C {\n    T* t;\n};\n\nclass B;\nclass A { public: C&lt;B&gt; b; };\nclass B { public: C&lt;A&gt; a; };\n</code></pre>\n<p>This would also work and of course you can instantiate it</p>\n<pre><code>int main() {\n    B b;\n    A a;\n}\n</code></pre>\n", "OwnerUserId": "4182275", "LastEditorUserId": "4182275", "LastEditDate": "2016-02-17T16:33:55.873", "Id": "35462046", "Score": "4", "CreationDate": "2016-02-17T16:14:40.820", "LastActivityDate": "2016-02-17T16:33:55.873"}, "35461561": {"CommentCount": "5", "AcceptedAnswerId": "35462560", "CreationDate": "2016-02-17T15:54:39.703", "LastActivityDate": "2016-02-17T17:32:13.967", "PostTypeId": "1", "ViewCount": "283", "FavoriteCount": "3", "Title": "Mutually-dependent C++ classes, held by std::vector", "Id": "35461561", "Score": "12", "Body": "<p>I was curious if was possible to create two classes, each of which holds a <code>std::vector</code> of the other.  My first guess was that it would not be possible, because <code>std::vector</code> requires a complete type, not just a forward declaration.</p>\n<pre><code>#include &lt;vector&gt;\n\nclass B;\nclass A { std::vector&lt;B&gt; b; };\nclass B { std::vector&lt;A&gt; a; };\n</code></pre>\n<p>I would think that the declaration of <code>std::vector&lt;B&gt;</code> would cause an immediate failure, because <code>B</code> has an incomplete type at this point.  However, this compiles successfully under both gcc and clang, without any warnings.  Why doesn't this cause an error?</p>\n", "Tags": "<c++><vector>", "OwnerUserId": "2689797", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_35461561_35463025_0": {"section_id": 233, "quality": 0.9629629629629629, "length": 26}, "so_35461561_35463025_1": {"section_id": 361, "quality": 0.875, "length": 21}, "so_35461561_35462560_0": {"section_id": 6324, "quality": 1.0, "length": 5}}, "n3337": {"so_35461561_35463025_0": {"section_id": 226, "quality": 0.9629629629629629, "length": 26}, "so_35461561_35463025_1": {"section_id": 351, "quality": 0.875, "length": 21}, "so_35461561_35462560_0": {"section_id": 6081, "quality": 1.0, "length": 5}}, "n4659": {"so_35461561_35463025_0": {"section_id": 243, "quality": 0.9629629629629629, "length": 26}, "so_35461561_35463025_1": {"section_id": 373, "quality": 0.875, "length": 21}, "so_35461561_35462560_0": {"section_id": 7834, "quality": 1.0, "length": 5}}}});