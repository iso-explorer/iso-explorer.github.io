post_cb({"14805533": {"PostTypeId": "2", "ParentId": "14805482", "Body": "<p>I don't think this will provide any significant performance increase.</p>\n<pre><code>if (memcmp(&amp;foo, \"\\0\", 1) == 0)\n{\n    // all zero\n}\n</code></pre>\n<p>I don't have the C++ spec on hand but the C99 spec 6.7.2.1/13 says (emphasis mine):</p>\n<blockquote>\n<p id=\"so_14805482_14805533_0\">Within a structure object, the non-bit-field members and the units in which bit-fields\n  reside have addresses that increase in the order in which they are declared. A pointer to a\n  structure object, suitably converted, <strong>points to its initial member (or if that member is a\n  bit-field, then to the unit in which it resides)</strong>, and vice versa. There may be unnamed\n  padding within a structure object, <strong>but not at its beginning</strong>.</p>\n</blockquote>\n", "CreationDate": "2013-02-11T03:39:10.160", "Score": "0", "LastEditDate": "2013-02-11T04:42:05.543", "CommentCount": "4", "Id": "14805533", "OwnerUserId": "10320", "LastEditorUserId": "10320", "LastActivityDate": "2013-02-11T04:42:05.543"}, "14805574": {"PostTypeId": "2", "ParentId": "14805482", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\n\nusing namespace std;\nstruct one_byte{\n  char b1:1;\n  char b2:1;\n  char b3:1;\n  char b4:1;\n  char b5:1; \n  char b6:1;\n  char b7:1;\n  char b8:1;\n    }__attribute__((packed));\n\nint main(int argc, char *argv[])\n{\n  one_byte b1;\n  int j;\n  memcpy(&amp;j, &amp;b1, sizeof(b1)); \n  if(j == 0) cout &lt;&lt; \"Its 0\";\n  else cout &lt;&lt; \"It's not 0\";\n  return 0;\n}\n</code></pre>\n<p>what about the above program? </p>\n", "CreationDate": "2013-02-11T03:43:30.053", "Score": "0", "CommentCount": "1", "Id": "14805574", "OwnerUserId": "1680957", "LastActivityDate": "2013-02-11T03:43:30.053"}, "14805482": {"LastEditDate": "2013-03-05T19:10:16.777", "Body": "<p>Suppose I have a <code>byte</code> structure, like this :</p>\n<pre><code>struct one_byte\n{\nchar b1 : 1,\n     b2 : 1,   \n     b3 : 1,   \n     b4 : 1,   \n     b5 : 1,   \n     b6 : 1,   \n     b7 : 1,   \n     b8 : 1;   \n}foo;\n</code></pre>\n<p>In some cases I'll need to check <code>(foo == 0)</code>, then I have to do eight commands :</p>\n<pre><code>if(foo.b1 == 0 &amp;&amp;\n   foo.b2 == 0 &amp;&amp;\n   foo.b3 == 0 &amp;&amp;\n...and so on\n</code></pre>\n<p>Is there any portable &amp; convenient way which can instantly check zero value only with a single command? I tried functions &amp; templates, they perform very slowly. And I tried union, my compiler doesn't support bit[array]....</p>\n", "CreationDate": "2013-02-11T03:32:25.830", "Score": "4", "AcceptedAnswerId": "14805609", "CommentCount": "7", "OwnerUserId": "2015064", "Title": "How to instantly check the zero value of a structure without checking its each element?", "LastActivityDate": "2013-03-05T19:10:16.777", "PostTypeId": "1", "Tags": "<c++><performance><structure><zero>", "AnswerCount": "6", "FavoriteCount": "0", "Id": "14805482", "ViewCount": "858", "LastEditorUserId": "918414"}, "bq_ids": {"n3337": {"so_14805482_14805533_0": {"quality": 0.575, "length": 23, "section_id": 5650}}}, "14805582": {"PostTypeId": "2", "ParentId": "14805482", "Body": "<pre><code>!*((unsigned char *) &amp;foo)\n</code></pre>\n<p>Should do the trick. Notice that I used the <code>!</code> operator to check for zero value -- if you don't like that, feel free to use <code>== 0</code> instead.</p>\n", "CreationDate": "2013-02-11T03:44:03.667", "Score": "1", "CommentCount": "0", "Id": "14805582", "OwnerUserId": "2058293", "LastActivityDate": "2013-02-11T03:44:03.667"}, "14805639": {"PostTypeId": "2", "ParentId": "14805482", "Body": "<pre><code>struct one_byte zero = { 0 };\n\n!memcmp (&amp;variable_1, &amp;zero, sizeof (struct one_byte))\n</code></pre>\n<p>Could be a solution, but I don't know if it is such a clever idea.\nMaybe just unsing the more or less standard way of bit-setting would do better:</p>\n<pre><code>#define SET_BIT(v, n) (v) |= (1&lt;&lt;n)\n#define CLR_BIT(v, n) (v) &amp;= ~(1&lt;&lt;n)\n#define GET_BIT(v, n) ((v) &amp; ~(1&lt;&lt;n) == 0)\n\nchar foo;\n\nif (foo == 0)\n   so_what ();\n</code></pre>\n", "CreationDate": "2013-02-11T03:52:25.273", "Score": "1", "CommentCount": "0", "Id": "14805639", "OwnerUserId": "2056411", "LastActivityDate": "2013-02-11T03:52:25.273"}, "14805609": {"PostTypeId": "2", "ParentId": "14805482", "Body": "<p>Use <a href=\"https://stackoverflow.com/questions/252552/why-do-we-need-c-unions\">union</a>, this is what it is intended for</p>\n<pre><code>union {\n  struct {\n    char b1:1,b2:1,b3:1,b4:1,b5:1,b6:1,b7:1,b8:1; \n  } bits;\n  unsigned char byte;\n} u;\n</code></pre>\n<p>then you can either assign directly the <em>byte</em></p>\n<pre><code>u.byte = 15;\n</code></pre>\n<p>or the bits individually</p>\n<pre><code>u.bits.b3 = 1;\n</code></pre>\n<p><em>Exemple</em></p>\n<pre><code>int main() {\n  u.byte = 0;\n  printf(\"%x\\n\", u.byte);\n  u.bits.b3 = 1;\n  u.bits.b4 = 1;\n  printf(\"%x\\n\", u.byte);\n  return 0;\n}\n</code></pre>\n<p>will output</p>\n<pre><code>0\nc  // 12 in decimal, since b3 and b4 are set to 1\n</code></pre>\n", "CreationDate": "2013-02-11T03:47:13.747", "Score": "3", "LastEditDate": "2017-05-23T11:48:50.833", "CommentCount": "0", "Id": "14805609", "OwnerUserId": "338904", "LastEditorUserId": "-1", "LastActivityDate": "2013-02-11T03:47:13.747"}, "14805589": {"PostTypeId": "2", "ParentId": "14805482", "Body": "<p>Sounds like you want to get down and dirty, so how about:</p>\n<pre><code>struct one_byte Other; // a real variable\n...   \nif(*(char*)&amp;Other == '\\0')\n</code></pre>\n", "CreationDate": "2013-02-11T03:45:06.513", "Score": "1", "CommentCount": "1", "Id": "14805589", "OwnerUserId": "212264", "LastActivityDate": "2013-02-11T03:45:06.513"}});