post_cb({"bq_ids": {"n4140": {"so_36051645_36072815_0": {"length": 23, "quality": 0.92, "section_id": 164}}, "n3337": {"so_36051645_36072815_0": {"length": 23, "quality": 0.92, "section_id": 158}}, "n4659": {"so_36051645_36072815_0": {"length": 23, "quality": 0.92, "section_id": 168}}}, "36072815": {"Id": "36072815", "PostTypeId": "2", "Body": "<ol>\n<li>Yes, that's fine. </li>\n<li><p>Current wording is quite clear on this: The parameter pack is completely ignored during partial ordering, because there are no arguments for it (<a href=\"http://eel.is/c++draft/temp.deduct.partial#3\" rel=\"nofollow\">[temp.deduct.partial]/(3.1)</a>). [temp.func.order]/5 also gives a very on point example, even with deducible template arguments - indicating that your first example is also ambiguous:</p>\n<blockquote>\n<p id=\"so_36051645_36072815_0\">[ <em>Note</em>: Since partial ordering in a call context considers only parameters for which there are explicit call arguments, some parameters are ignored (namely, function parameter packs, parameters with default arguments,\n  and ellipsis parameters). [...] [ <em>Example</em>:</p>\n<pre><code>template&lt;class T, class... U&gt; void f(T, U ...);  // #1\ntemplate&lt;class T            &gt; void f(T       );  // #2\n\nvoid h(int i) {\n  f(&amp;i); // error: ambiguous\n  // [...]\n}\n</code></pre>\n</blockquote>\n<p>However, this is not optimal. There is <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1395\" rel=\"nofollow\">core issue 1395</a> on variadic template partial ordering:</p>\n<blockquote>\n<p id=\"so_36051645_36072815_1\">CWG agreed that the example should be accepted, handling this case as a late tiebreaker, <strong>preferring an omitted parameter over a parameter pack</strong>.</p>\n</blockquote>\n<p>(<a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#1825\" rel=\"nofollow\">Issue 1825</a> gives a more refined strategy.) Both compilers implement this rule for the first case; Only GCC does for the second one (i.e. can be considered half a step ahead).</p></li>\n</ol>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-17T22:45:52.657", "Score": "7", "CreationDate": "2016-03-17T22:28:21.067", "ParentId": "36051645", "CommentCount": "3", "OwnerUserId": "3647361", "LastEditDate": "2016-03-17T22:45:52.657"}, "36053217": {"Id": "36053217", "PostTypeId": "2", "Body": "<p>The error message has already shown the reason.</p>\n<p>When generate <strong>add(12)</strong>, there are two available template functions. That's</p>\n<pre><code>template &lt;typename T&gt;\nint add(typename T::SomeType val);\n</code></pre>\n<p>and</p>\n<pre><code>template &lt;typename FirstT, typename... RestT&gt;\nint add(typename FirstT::SomeType first_value, typename RestT::SomeType... rest);\n// and RestT is empty here(RestT = &lt;&gt;)\n</code></pre>\n<p>This is not a standard usage and clang is correct.</p>\n<p>Consider this code.</p>\n<pre><code>#include &lt;tuple&gt;\n#include &lt;type_traits&gt;\n\nstruct Foo\n{\n    using SomeType = int;\n};\n\n// helper function to sum a tuple of any size\ntemplate&lt;typename Tuple, std::size_t N&gt;\nstruct TupleSum {\n    typedef typename std::tuple_element&lt;N - 1, Tuple&gt;::type ref_t;\n    typedef typename std::remove_reference&lt;ref_t&gt;::type noref_t;\n\n    static noref_t sum(const Tuple&amp; t) \n    {\n        return std::get&lt;N - 1&gt;(t) + TupleSum&lt;Tuple, N - 1&gt;::sum(t);\n    }\n};\n\ntemplate&lt;typename Tuple&gt;\nstruct TupleSum&lt;Tuple, 1&gt; {\n    typedef typename std::tuple_element&lt;0, Tuple&gt;::type ref_t;\n    typedef typename std::remove_reference&lt;ref_t&gt;::type noref_t;\n\n    static noref_t sum(const Tuple&amp; t) \n    {\n        return std::get&lt;0&gt;(t);\n    }\n};\n\ntemplate &lt;typename... RestT&gt;\nint add(typename RestT::SomeType... rest) {\n    typedef decltype(std::forward_as_tuple(rest...)) tuple_t;\n    return TupleSum&lt;tuple_t, sizeof...(RestT) &gt;::sum(std::forward_as_tuple(rest...));\n}\n\nint main(void)\n{\n    return add&lt;Foo, Foo, Foo&gt;(12, 12, 12);\n}\n</code></pre>\n", "LastEditorUserId": "5689324", "LastActivityDate": "2016-03-17T06:45:08.103", "Score": "0", "CreationDate": "2016-03-17T06:34:46.663", "ParentId": "36051645", "CommentCount": "3", "OwnerUserId": "5689324", "LastEditDate": "2016-03-17T06:45:08.103"}, "36051645": {"ViewCount": "465", "Body": "<p>The following code is a textbook example of a recursive variadic function overload. In both clang and GCC, it compiles cleanly, and <code>main</code> returns 36 (as expected):</p>\n<pre><code>template &lt;typename T&gt;\nint add(T val)\n{\n    return val;\n}\n\ntemplate &lt;typename FirstTypeT, typename... RestT&gt;\nint add(FirstTypeT first_value, RestT... rest)\n{\n    return first_value + add&lt;RestT...&gt;(rest...);\n}\n\nint main(void)\n{\n    return add(12, 12, 12);\n}\n</code></pre>\n<p>However, here is a slight modification. It uses a dependent type in the template definition instead of the template parameter directly:</p>\n<pre><code>struct Foo\n{\n    using SomeType = int;\n};\n\ntemplate &lt;typename T&gt;\nint add(typename T::SomeType val)\n{\n    return val;\n}\n\ntemplate &lt;typename FirstT, typename... RestT&gt;\nint add(typename FirstT::SomeType first_value, typename RestT::SomeType... rest)\n{\n    return first_value + add&lt;RestT...&gt;(rest...);\n}\n\nint main(void)\n{\n    return add&lt;Foo, Foo, Foo&gt;(12, 12, 12);\n}\n</code></pre>\n<p>It compiles and runs as intended using GCC 5.2, but <a href=\"http://coliru.stacked-crooked.com/a/445bf2b95492b1f0\" rel=\"noreferrer\">fails</a> using clang 3.8:</p>\n<pre><code>clang++ variadic.cpp -o var -std=c++11 -Wall\nvariadic.cpp:15:26: error: call to 'add' is ambiguous\n    return first_value + add&lt;RestT...&gt;(rest...);\n                         ^~~~~~~~~~~~~\nvariadic.cpp:15:26: note: in instantiation of function template specialization 'add&lt;Foo, Foo&gt;' requested here\n    return first_value + add&lt;RestT...&gt;(rest...);\n                         ^\nvariadic.cpp:20:12: note: in instantiation of function template specialization 'add&lt;Foo, Foo, Foo&gt;' requested here\n    return add&lt;Foo, Foo, Foo&gt;(12, 12, 12);\n           ^\nvariadic.cpp:7:5: note: candidate function [with T = Foo]\nint add(typename T::SomeType val)\n    ^\nvariadic.cpp:13:5: note: candidate function [with FirstT = Foo, RestT = &lt;&gt;]\nint add(typename FirstT::SomeType first_value, typename RestT::SomeType... rest)\n    ^\n1 error generated.\n</code></pre>\n<p>My question is twofold.</p>\n<ol>\n<li>Is it really a valid use of a parameter pack typename pattern to apply the scope resolution operator to each member of the pack as in <code>typename RestT::SomeType...</code> ?</li>\n<li>Is clang correct vis-\u00e0-vis the standard, or is this a bug? Is the second example really any more ambiguous than the first? (For the first example, it seems like you could say that the single argument overload is ambiguous with the the second instantiated with <code>RestT = &lt;&gt;</code>)</li>\n</ol>\n", "AcceptedAnswerId": "36072815", "Title": "Is a c++11 variadic function template overload with a dependent type ambiguous?", "CreationDate": "2016-03-17T04:23:48.117", "Id": "36051645", "CommentCount": "4", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2016-03-17T06:03:34.290", "LastEditorUserId": "51100", "LastActivityDate": "2016-03-17T22:45:52.657", "Score": "9", "OwnerUserId": "51100", "Tags": "<c++><c++11><gcc><clang><language-lawyer>", "AnswerCount": "2"}});