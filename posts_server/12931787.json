post_cb({"12931932": {"ParentId": "12931787", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>I think STL containers offer the following basic thread-safety guarantee:</p>\n<ul>\n<li><p><em>simultaneous reads</em> of the <em>same</em> object are OK</p></li>\n<li><p><em>simultaneous read/writes</em> of <em>different</em> objects are OK</p></li>\n</ul>\n<p>But you have to use some form of custom synchronization (e.g. critical section) if you want to do something different, like e.g. simultaneous writes on the same object.</p>\n", "OwnerUserId": "1629821", "LastEditorUserId": "1629821", "LastEditDate": "2012-10-17T10:14:19.907", "Id": "12931932", "Score": "20", "CreationDate": "2012-10-17T10:08:38.350", "LastActivityDate": "2012-10-17T10:14:19.907"}, "12931787": {"CommentCount": "5", "AcceptedAnswerId": "12938588", "CreationDate": "2012-10-17T10:01:34.270", "LastActivityDate": "2014-06-09T21:58:57.497", "PostTypeId": "1", "ViewCount": "23070", "FavoriteCount": "18", "Title": "C++11 STL containers and thread safety", "Id": "12931787", "Score": "31", "Body": "<p>I have trouble finding any up-to-date information on this.</p>\n<p>Do C++11 versions of STL containers have some level of thread safety guaranteed?</p>\n<p>I do expect that they don't, due to performance reasons. But than again, that's why we have both <code>vector::operator []</code> and <code>vector::at</code>.</p>\n", "Tags": "<c++><multithreading><stl><c++11>", "OwnerUserId": "211659", "AnswerCount": "3"}, "12931942": {"ParentId": "12931787", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>No. Check out PPL or Intel TBB for thread safe STL-like containers. </p>\n<p>Like others have noted they have usual \"multiple reader thread safety\" but that is even pre C++11. Ofc this doesnt mean single writer multiple readers. It means 0 writers. :)</p>\n", "OwnerUserId": "700825", "LastEditorUserId": "700825", "LastEditDate": "2012-10-18T01:26:51.630", "Id": "12931942", "Score": "-8", "CreationDate": "2012-10-17T10:09:13.660", "LastActivityDate": "2012-10-18T01:26:51.630"}, "bq_ids": {"n4140": {"so_12931787_12938588_0": {"section_id": 718, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_12931787_12938588_0": {"section_id": 707, "quality": 1.0, "length": 17}}, "n4659": {"so_12931787_12938588_0": {"section_id": 749, "quality": 0.9411764705882353, "length": 16}}}, "12938588": {"ParentId": "12931787", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Since the existing answers don't cover it (only a comment does), I'll just mention 23.2.2 [container.requirements.dataraces] of the current <a href=\"http://isocpp.org/std/the-standard\" rel=\"nofollow noreferrer\">C++ standard specification</a> which says:</p>\n<blockquote>\n<p id=\"so_12931787_12938588_0\">implementations are required to avoid data races when the contents of the contained object in different elements in the same sequence, excepting <code>vector&lt;bool&gt;</code>, are modified concurrently.</p>\n</blockquote>\n<p>i.e. it's safe to access distinct elements of the same container, so for example you can have a global <code>std::vector&lt;std::future&lt;int&gt;&gt;</code> of ten elements and have ten threads which each write to a different element of the vector.</p>\n<p>Apart from that, the same rules apply to containers as for the rest of the standard library (see 17.6.5.9 [res.on.data.races]), as <a href=\"https://stackoverflow.com/a/12931932/981959\">Mr.C64's answer</a> says, and additionally [container.requirements.dataraces] lists some non-const member functions of containers that can be called safely because they only return non-const references to elements, they don't actually modify anything (in general any non-const member function must be considered a modification.)</p>\n", "OwnerUserId": "981959", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:47:16.490", "Id": "12938588", "Score": "33", "CreationDate": "2012-10-17T16:08:36.570", "LastActivityDate": "2014-06-09T21:58:57.497"}});