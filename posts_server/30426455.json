post_cb({"30426455": {"ViewCount": "149", "Body": "<p>According to <a href=\"http://en.cppreference.com/w/cpp/preprocessor/replace\" rel=\"nofollow\">this page</a> \"A ## operator between any two successive identifiers in the replacement-list runs parameter replacement on the two identifiers\". That is, the preprocessor operator ## acts on identifiers. <a href=\"https://msdn.microsoft.com/en-us/library/09dwwt6y.aspx\" rel=\"nofollow\">Microsoft's page</a> says \", each occurrence of the token-pasting operator in token-string is removed, and the tokens preceding and following it are concatenated\". That is, the preprocessor operator ## acts on tokens.</p>\n<p>I have looked for a definition of an identifier and/or token and the most I have found is <a href=\"http://en.cppreference.com/w/cpp/language/identifiers\" rel=\"nofollow\">this link</a>: \"An identifier is an arbitrary long sequence of digits, underscores, lowercase and uppercase Latin letters, and Unicode characters. A valid identifier must begin with a non-digit character\".</p>\n<p>According to that definition, the following macro should not work (on two accounts):</p>\n<pre><code>#define PROB1(x) x##0000\n#define PROB2(x,y) x##y\nint PROB1(z) = PROB2( 1, 2 * 3 );\n</code></pre>\n<p>Does the standard have some rigorous definitions regarding ## and the objects it acts on? Or, is it mostly 'try and see if it works' (a.k.a. implementation defined)?</p>\n", "AcceptedAnswerId": "30447077", "Title": "Concatenation and the standard", "CreationDate": "2015-05-24T17:45:55.540", "Id": "30426455", "CommentCount": "5", "LastEditDate": "2016-07-05T14:17:28.870", "PostTypeId": "1", "LastEditorUserId": "4370109", "LastActivityDate": "2016-07-05T14:17:28.870", "Score": "1", "OwnerUserId": "2549876", "Tags": "<c++><c++11><concatenation><c-preprocessor>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_30426455_30447077_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 529}, "so_30426455_30447077_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 529}}, "n3337": {"so_30426455_30447077_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 520}, "so_30426455_30447077_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 520}}, "n4659": {"so_30426455_30447077_0": {"length": 28, "quality": 0.9655172413793104, "section_id": 550}, "so_30426455_30447077_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 550}}}, "30447077": {"Id": "30447077", "PostTypeId": "2", "Body": "<p>The standard is extremely precise, both about what can be concatenated, and about what a valid token is.</p>\n<p>The en.cppreference.com page is imprecise; what are concatenated are preprocessing tokens, not identifiers. The Microsoft page is much closer to the standard, although it omits some details and fails to distinguish \"preprocessing token\" from \"token\", which are slightly different concepts.</p>\n<p>What the standard actually says (\u00a716.3.3/3):</p>\n<blockquote>\n<p id=\"so_30426455_30447077_0\">For both object-like and function-like macro invocations, before the replacement list is reexamined for more macro names to replace, each instance of a <code>##</code> preprocessing token in the replacement list (not from an\n  argument) is deleted and the preceding preprocessing token is concatenated with the following preprocessing token.\u2026</p>\n</blockquote>\n<p>For reference, \"preprocessing token\" is defined in \u00a72.4 to be one of the following:</p>\n<ul>\n<li>header-name</li>\n<li>identifier</li>\n<li>pp-number</li>\n<li>character-literal</li>\n<li>user-defined-character-literal</li>\n<li>string-literal</li>\n<li>user-defined-string-literal</li>\n<li>preprocessing-op-or-punc</li>\n<li>each non-white-space character that cannot be one of the above</li>\n</ul>\n<p>Most of the time, the tokens to be combined are identifiers (and numbers), but it is quite possible to generate a multicharacter token by concatenating individual characters. (Given the last item in the list of possible preprocessor tokens, any single non-whitespace character is a preprocessor token, even if it is not a letter, digit or standard punctuation symbol.)</p>\n<p>The result of a concatenation must be a preprocessing token:</p>\n<blockquote>\n<p id=\"so_30426455_30447077_1\">If the result is not a valid preprocessing token, the behavior is undefined. The resulting token is available for further macro replacement.</p>\n</blockquote>\n<p>Note that the replacement of a function-like macro's argument names with the actual arguments may result in the argument name being replaced by 0 tokens or more than one token. If that argument is used on either side of a concatenation operator:</p>\n<ul>\n<li><p>In the case that the actual argument had zero tokens, nothing is concatenated. (The Microsoft page implies that the concatenation operator will concatenate whatever tokens end up preceding and following it.)</p></li>\n<li><p>In the case that the actual argument has more than one token, the one which is concatenated is the one which precedes or follows the concatenation operator.</p></li>\n</ul>\n<p>As an example of the last case, remember that <code>-42</code> is two preprocessing tokens (and two tokens, after preprocessing): <kbd>-</kbd> and <kbd>42</kbd>. Consequently, although you can concatenate the <code>pp-number</code> <kbd>42E</kbd> with the <code>pp-number</code> <kbd>3</kbd>, resulting in the <code>pp-number</code> (and valid token) <kbd>42E3</kbd>, you cannot create the token <kbd>42E-3</kbd> from <kbd>42E</kbd> and <kbd>-3</kbd>, because only the <kbd>-</kbd> would be concatenated, resulting in two <code>pp-number</code> tokens: <kbd>42E-</kbd><kbd>3</kbd>. (The first of these is a valid preprocessing token but it cannot be converted into a valid token, so a tokenization error will be reported.)</p>\n<p>In a sequence of concatenations:</p>\n<pre><code>#define concat3(a,b,c) a ## b ## c\n</code></pre>\n<p>the order of concatenations is not defined. So it is unspecified whether <code>concat3(42E,-,3)</code> is valid; if the first two tokens are concatenated first, all is well, but if the second two are concatenated first, the result is not a valid preprocessing token. On the other hand, <code>concat3(.,.,.)</code> must be an error, because <kbd>..</kbd> is not a valid token, and so neither <code>a##b</code> nor <code>b##c</code> can be processed. So it is impossible to produce the token <code>...</code> with concatenation.</p>\n", "LastActivityDate": "2015-05-25T23:02:23.897", "CommentCount": "0", "CreationDate": "2015-05-25T23:02:23.897", "ParentId": "30426455", "Score": "2", "OwnerUserId": "1566221"}});