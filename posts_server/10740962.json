post_cb({"bq_ids": {"n4140": {"so_10740962_10741060_0": {"length": 15, "quality": 0.9375, "section_id": 5409}}, "n3337": {"so_10740962_10741060_0": {"length": 15, "quality": 0.9375, "section_id": 5204}}, "n4659": {"so_10740962_10741060_0": {"length": 15, "quality": 0.9375, "section_id": 6831}}}, "10741060": {"Id": "10741060", "PostTypeId": "2", "Body": "<p>The identity typedef is allowed if the name already refers to some type.</p>\n<p>This is legal:</p>\n<pre><code>typedef int Request;\ntypedef Request Request; // Redefines \"Request\" with no effect \n</code></pre>\n<p>This is not:</p>\n<pre><code>typedef Request Request; // Illegal, first \"Request\" doesn't name a type. \n</code></pre>\n<p>The standard has a specific example relating to this. C++2003, \u00a77.1.3/2:</p>\n<blockquote>\n<p id=\"so_10740962_10741060_0\">In a given non-class scope, a typedef specifier can be used to redefine the name of any type declared in\n  that scope to refer to the type to which it already refers. [<em>Example</em>:</p>\n</blockquote>\n<pre><code>typedef struct s { /* ... */ } s;\ntypedef int I;\ntypedef int I;\ntypedef I I;\n</code></pre>\n<blockquote>\n<p id=\"so_10740962_10741060_1\">\u2014<em>end example</em>]</p>\n</blockquote>\n", "LastEditorUserId": "8747", "LastActivityDate": "2012-05-24T16:11:35.333", "Score": "9", "CreationDate": "2012-05-24T15:57:23.113", "ParentId": "10740962", "CommentCount": "2", "OwnerUserId": "8747", "LastEditDate": "2012-05-24T16:11:35.333"}, "10741285": {"Id": "10741285", "PostTypeId": "2", "Body": "<p><strong>If</strong> <code>Request</code> is only passed as a parameter it seems to be a <a href=\"http://en.wikipedia.org/wiki/Opaque_pointer\" rel=\"nofollow\">opaque pointer</a>.<br>\nThere should be a</br></p>\n<pre><code>typedef struct Request Request \n</code></pre>\n<p>somewhere in the code. (see comments on your question)<br>\nThis is used to define an API and hide implementation details. So you can later change the implementation without changing the API again.</br></p>\n<p>The client does not need to know anything about the acutal type - its just kind of a handle.<br>\nEverything you want to do with it has to be done with the api methods (creation, delete, load, init, ...)<br>\nUsually the handle <code>Request</code> will be casted to something more meaningfull in the implementation of the api. This was/is usually done in <em>old</em> C.</br></br></p>\n", "LastEditorUserId": "1343556", "LastActivityDate": "2012-05-24T16:48:21.097", "Score": "0", "CreationDate": "2012-05-24T16:12:04.063", "ParentId": "10740962", "CommentCount": "0", "OwnerUserId": "1343556", "LastEditDate": "2012-05-24T16:48:21.097"}, "10740962": {"ViewCount": "425", "Body": "<p>I've come across some C++ code that has the following:</p>\n<pre><code>typedef Request Request;\n</code></pre>\n<p>Is this just a no-op or does this typedef actual have an effect, and if so, what effect does it have?</p>\n", "AcceptedAnswerId": "10741060", "Title": "Does a typedef to self have any effect?", "CreationDate": "2012-05-24T15:52:05.427", "Id": "10740962", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2012-05-24T16:48:21.097", "Score": "6", "OwnerUserId": "115751", "Tags": "<c++><typedef><self><noop>", "AnswerCount": "2"}});