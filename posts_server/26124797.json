post_cb({"bq_ids": {"n4140": {"so_26124797_26125630_0": {"length": 67, "quality": 0.9436619718309859, "section_id": 87}}, "n3337": {"so_26124797_26125630_0": {"length": 57, "quality": 0.8028169014084507, "section_id": 82}}}, "26124797": {"LastActivityDate": "2014-09-30T16:30:01.453", "ViewCount": "187", "Id": "26124797", "AcceptedAnswerId": "26125194", "Score": "2", "Title": "Using an lvalue reference as a non-type template parameter", "LastEditorUserId": "3959454", "CommentCount": "6", "Body": "<p>I read that the following types are allowed as non-type template parameters:</p>\n<ul>\n<li>integral types</li>\n<li>enum</li>\n<li>ptr to objects/methods</li>\n<li>lvalue reference to objects/methods</li>\n<li>std::nullptr_t</li>\n</ul>\n<p>I don't understand how a non constant pointer or a lvalue reference is acceptable? Shouldn't they be constant types so that they are identified at compile time?</p>\n<p>Obviously I'm no smarter than the standard so can someone show me an example of an lvalue reference and maybe a pointer being used as non template parameter?</p>\n", "Tags": "<c++><templates>", "CreationDate": "2014-09-30T15:39:24.220", "LastEditDate": "2014-09-30T16:22:29.513", "ClosedDate": "2014-09-30T18:52:09.833", "PostTypeId": "1", "AnswerCount": "2", "OwnerUserId": "1248779"}, "26125194": {"LastActivityDate": "2014-09-30T16:30:01.453", "CommentCount": "7", "Body": "<p>Here's an example which has both a method pointer and an lvalue reference as non-type template parameters:</p>\n<pre><code>int delete_counter_1 = 0;\nint delete_counter_2 = 0;\n\ntemplate&lt;int&amp; ctr&gt;\nvoid increment_counter() { ++ctr; }\n\ntemplate&lt;void(*func)()&gt;\nclass Deleter {\n    public:\n    ~Deleter() { func(); }\n};\n\nint main() {\n    { /* Internal scope */\n      Deleter&lt;increment_counter&lt;delete_counter_1&gt;&gt; a, b;\n      Deleter&lt;increment_counter&lt;delete_counter_2&gt;&gt; c;\n    }\n    std::cout &lt;&lt; \"Counter1: \" &lt;&lt; delete_counter_1\n              &lt;&lt; \"; Counter2: \" &lt;&lt; delete_counter_2\n              &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre>\n<p>See it on <a href=\"http://coliru.stacked-crooked.com/a/8d7c409407f52d68\" rel=\"nofollow\">coliru</a>.</p>\n<p>The interesting thing about the <code>Deleter</code> class is that it has no actual data members; its destructor can be directly inlined without indirect function calls.</p>\n<p>As mentioned by Dalibor Frivaldsky in a comment, the point is that the (instantiated) functions <code>delete_counter&lt;int&amp;&gt;</code> and the counters themselves have fixed addresses known at compile-time, so <em>as pointers</em> their values are constant. In particular, this is only true for objects with static lifetime; automatic (\"stack-allocated\") objects wouldn't work, and neither would non-static class members, but static objects (as above) and static class members are just fine.</p>\n", "CreationDate": "2014-09-30T16:00:51.010", "LastEditDate": "2014-09-30T16:30:01.453", "ParentId": "26124797", "Id": "26125194", "LastEditorUserId": "1566221", "PostTypeId": "2", "Score": "4", "OwnerUserId": "1566221"}, "26125630": {"CommentCount": "0", "Body": "<p>Standard explains quite clearly in <code>14.3.2 [temp.arg.nontype]</code> what can be used as an argument if a non-type template parameter is a pointer or reference:</p>\n<blockquote id=\"so_26124797_26125630_0\">\n<ul>\n<li>a constant expression (5.19) that designates the address of a complete object with static storage duration\n  and external or internal linkage or a function with external or internal linkage, including function\n  templates and function template-ids but excluding non-static class members, expressed (ignoring parentheses)\n  as &amp; id-expression, where the id-expression is the name of an object or function, except that the\n  &amp; may be omitted if the name refers to a function or array and shall be omitted if the corresponding\n  template-parameter is a reference; or</li>\n<li>a constant expression that evaluates to a null pointer value (4.10); or</li>\n<li>a constant expression that evaluates to a null member pointer value (4.11); or</li>\n<li>a pointer to member expressed as described in 5.3.1; or</li>\n<li>a constant expression of type std::nullptr_t</li>\n</ul>\n</blockquote>\n", "CreationDate": "2014-09-30T16:25:48.160", "ParentId": "26124797", "Id": "26125630", "LastActivityDate": "2014-09-30T16:25:48.160", "PostTypeId": "2", "Score": "0", "OwnerUserId": "3959454"}});