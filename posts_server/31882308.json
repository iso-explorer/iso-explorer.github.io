post_cb({"bq_ids": {"n4140": {"so_31882308_31882751_4": {"length": 12, "quality": 1.0, "section_id": 6058}, "so_31882308_31882751_8": {"length": 5, "quality": 0.7142857142857143, "section_id": 6041}, "so_31882308_31882308_0": {"length": 21, "quality": 0.9130434782608695, "section_id": 6046}, "so_31882308_31882751_0": {"length": 14, "quality": 0.875, "section_id": 6058}}, "n3337": {"so_31882308_31882751_4": {"length": 12, "quality": 1.0, "section_id": 5826}, "so_31882308_31882751_8": {"length": 5, "quality": 0.7142857142857143, "section_id": 5809}, "so_31882308_31882751_0": {"length": 14, "quality": 0.875, "section_id": 5826}, "so_31882308_31882308_0": {"length": 17, "quality": 0.7391304347826086, "section_id": 5814}}, "n4659": {"so_31882308_31882308_0": {"length": 20, "quality": 0.8695652173913043, "section_id": 7545}, "so_31882308_31882751_8": {"length": 5, "quality": 0.7142857142857143, "section_id": 7540}}}, "31882308": {"ViewCount": "226", "Body": "<p>The following code fails to compile in both MSVC2015 and clang when the comment marks are removed but it compiles as it is.</p>\n<pre><code>int main()\n{\n    static_assert( alignof( int * ) == alignof( int * * ), \"nope\" );\n\n    const int * * a = nullptr;\n    //const int * * * b = reinterpret_cast&lt; const int * * * &gt;( a );\n    auto c = static_cast&lt; const int * * * &gt;( static_cast&lt; void * &gt;( a ) );\n    return 0;\n}\n</code></pre>\n<p>This question is different from a <a href=\"https://stackoverflow.com/questions/27995692/reinterpret-cast-casts-away-qualifiers\">previously asked one</a> because there is not overall <code>const</code> qualifier being casted away.</p>\n<p>According to the standard [expr.reinterpret.cast]/7</p>\n<blockquote>\n<p id=\"so_31882308_31882308_0\">An object pointer can be explicitly converted to an object pointer of a different type. When a prvalue <code>v</code> of object pointer type is converted to the object pointer type \u201cpointer to <code>cv T</code>\u201d, the result is <code>static_cast&lt;cv T*&gt;(static_cast&lt;cv void*&gt;(v))</code>.</p>\n</blockquote>\n<p>In this case, the target \u201cpointer to <code>cv T</code>\u201d is <code>const int * * *</code> which makes <code>T = const int * *</code> and no <code>cv</code> qualifiers. Thus, the result should be <code>static_cast&lt;T*&gt;(static_cast&lt;void*&gt;(v))</code>.</p>\n<p>There are constrains about the alignment of <code>T</code>, but those are not relevant here as demonstrated in the static assert. Since the result of <code>reinterpret_cast&lt; const int * * * &gt;( a )</code> can actually be computed using the intermediate steps, the commented code should compile if uncommented.</p>\n<p>Where is the error in my reasoning (if any)?</p>\n", "Title": "Qualifier-losing conversion C++", "CreationDate": "2015-08-07T16:13:59.717", "LastActivityDate": "2015-08-07T17:37:01.033", "CommentCount": "4", "LastEditDate": "2017-05-23T11:51:23.670", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "31882308", "Score": "2", "OwnerUserId": "2549876", "Tags": "<c++><c++11><language-lawyer><c++14>", "AnswerCount": "1"}, "31882751": {"Id": "31882751", "PostTypeId": "2", "Body": "<p>N3690 5.2.11/8:</p>\n<blockquote>\n<p id=\"so_31882308_31882751_0\">The following rules define the process known as <em>casting away constness</em>.  In these rules <code>Tn</code> and <code>Xn</code> represent types.  For two pointer types:</p>\n<p id=\"so_31882308_31882751_1\"><code>X1</code> is <code>T1</code> <em>cv</em><sub>1,1</sub> <code>*</code> ... <em>cv</em><sub>1,<em>N</em></sub> <code>*</code> where <code>T1</code> is not a pointer type</p>\n<p id=\"so_31882308_31882751_2\"><code>X2</code> is <code>T2</code> <em>cv</em><sub>2,1</sub> <code>*</code> ... <em>cv</em><sub>2,<em>M</em></sub> <code>*</code> where <code>T2</code> is not a pointer type</p>\n<p id=\"so_31882308_31882751_3\"><em>K</em> is min(<em>N</em>,<em>M</em>)</p>\n<p id=\"so_31882308_31882751_4\">casting from <code>X1</code> to <code>X2</code> casts away constness if, for a non-pointer type <code>T</code> there does not exist an implicit conversion (Clause 4) from:</p>\n<p id=\"so_31882308_31882751_5\"><code>T</code> <em>cv</em><sub>1,(<em>N</em>-<em>K</em>+1)</sub> <code>*</code> <em>cv</em><sub>1,(<em>N</em>-<em>K</em>+2)</sub> <code>*</code> ... <em>cv</em><sub>1,<em>N</em></sub> <code>*</code></p>\n<p id=\"so_31882308_31882751_6\">to</p>\n<p id=\"so_31882308_31882751_7\"><code>T</code> <em>cv</em><sub>2,(<em>M</em>-<em>K</em>+1)</sub> <code>*</code> <em>cv</em><sub>2,(<em>M</em>-<em>K</em>+2)</sub> <code>*</code> ... <em>cv</em><sub>2,<em>M</em></sub> <code>*</code></p>\n</blockquote>\n<p>In your example, <code>X1</code> is <code>const int**</code>, so <em>N</em> is 2, <code>T1</code> is <code>int</code>, <em>cv</em><sub>1,1</sub> is <code>const</code>, and <em>cv</em><sub>1,2</sub> is empty.  <code>X2</code> is <code>const int***</code>, so <em>M</em> is 3, <code>T2</code> is <code>int</code>, <em>cv</em><sub>2,1</sub> is <code>const</code>, and <em>cv</em><sub>2,2</sub> and <em>cv</em><sub>2,3</sub> are empty.  <em>K</em> is 2.  Does there exist an implicit conversion from</p>\n<p><code>T</code> <em>cv</em><sub>1,1</sub> <code>*</code> <em>cv</em><sub>1,2</sub> <code>*</code> = <code>T const**</code></p>\n<p>to</p>\n<p><code>T</code> <em>cv</em><sub>2,2</sub> <code>*</code> <em>cv</em><sub>2,3</sub> <code>*</code> = <code>T**</code>?</p>\n<p>No; therefore your cast casts away constness.</p>\n<p>And of course we have 5.2.10/2:</p>\n<blockquote>\n<p id=\"so_31882308_31882751_8\">The <code>reinterpret_cast</code> operator shall not cast away constness (5.2.11).</p>\n</blockquote>\n", "LastEditorUserId": "459640", "LastActivityDate": "2015-08-07T17:20:21.917", "Score": "2", "CreationDate": "2015-08-07T16:41:14.777", "ParentId": "31882308", "CommentCount": "2", "OwnerUserId": "459640", "LastEditDate": "2015-08-07T17:20:21.917"}});