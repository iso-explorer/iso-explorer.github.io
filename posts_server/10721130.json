post_cb({"bq_ids": {"n4140": {"so_10721130_10721407_1": {"length": 48, "quality": 0.6075949367088608, "section_id": 6186}, "so_10721130_10721407_2": {"length": 15, "quality": 0.75, "section_id": 6186}}, "n3337": {"so_10721130_10721407_1": {"length": 71, "quality": 0.8987341772151899, "section_id": 5947}, "so_10721130_10721407_2": {"length": 15, "quality": 0.75, "section_id": 5947}}, "n4659": {"so_10721130_10721407_2": {"length": 12, "quality": 0.6, "section_id": 7689}}}, "10727719": {"Id": "10727719", "PostTypeId": "2", "Body": "<p>Richard Smith (zygoloid) at the LLVM IRC channel had a short talk with me about this issue which is your answer</p>\n<pre><code>&lt;litb&gt; hello folks\n&lt;litb&gt; zygoloid, what should happen in this case?\n&lt;litb&gt; http://stackoverflow.com/questions/10721130/calling-constexpr-in-default-template-argument\n&lt;litb&gt; it seems to be clang's behavior is surprising\n&lt;litb&gt; zygoloid, i cannot apply the \"point of instantiation\" rule to constexpr \n  function templates. if i call such a function template, the called definition's \n  POI often is *after* the specialization reference, which means at the point of \n  the call, the constexpr function template specialization is \"undefined\".\n&lt;zygoloid&gt; it's a horrible mess. Clang does not do what the standard intends, but \n  as you note, the actual spec is gloriously unclear\n&lt;d0k&gt; :(\n&lt;zygoloid&gt; we should instantiate bar&lt;3&gt;::get(), because it is odr-used, but we \n  don't, because we incorrectly believe it's used in an unevaluated context\n&lt;zygoloid&gt; conversely, the point of instantiation is too late :/\n&lt;zygoloid&gt; PR11851\n</code></pre>\n<p>So it seems that sometimes, Clang instantiates called function templates or member function of class templates but their instantiation is too late for the call to see, and at other cases it doesn't even instantiate them because it thinks it will never need them (unevaluated context). </p>\n", "LastEditorUserId": "221867", "LastActivityDate": "2015-03-02T22:50:39.937", "Score": "12", "CreationDate": "2012-05-23T20:56:55.517", "ParentId": "10721130", "CommentCount": "2", "OwnerUserId": "34509", "LastEditDate": "2015-03-02T22:50:39.937"}, "10721130": {"ViewCount": "1777", "Body": "<p>In C++11 I am using a constexpr function as a default value for a template parameter - it looks like this:</p>\n<pre><code>template &lt;int value&gt;\nstruct bar\n{\n    static constexpr int get()\n    {\n        return value;\n    }\n};\n\ntemplate &lt;typename A, int value = A::get()&gt;\nstruct foo\n{\n};\n\nint main()\n{\n    typedef foo&lt;bar&lt;0&gt;&gt; type;\n\n    return 0;\n}\n</code></pre>\n<p>G++ 4.5 and 4.7 compiles this, but Clang++ 3.1 does not. The error message from clang is:</p>\n<pre><code>clang_test.cpp:10:35: error: non-type template argument is not a constant expression\ntemplate &lt;typename A, int value = A::get()&gt;\n                                  ^~~~~~~~\nclang_test.cpp:17:19: note: while checking a default template argument used here\n        typedef foo&lt;bar&lt;3&gt;&gt; type;\n                ~~~~~~~~~^~\nclang_test.cpp:10:35: note: undefined function 'get' cannot be used in a constant expression\ntemplate &lt;typename A, int value = A::get()&gt;\n                                  ^\nclang_test.cpp:4:23: note: declared here\n        static constexpr int get()\n                             ^\n1 error generated.\n</code></pre>\n<p><strong>Which one is correct?</strong></p>\n", "AcceptedAnswerId": "10727719", "Title": "Calling constexpr in default template argument", "CreationDate": "2012-05-23T13:36:39.550", "Id": "10721130", "CommentCount": "1", "LastEditDate": "2012-05-23T15:53:08.907", "PostTypeId": "1", "LastEditorUserId": "636019", "LastActivityDate": "2015-03-02T22:50:39.937", "Score": "12", "OwnerUserId": "812178", "Tags": "<c++><gcc><c++11><clang><constexpr>", "AnswerCount": "2"}, "10721407": {"Id": "10721407", "PostTypeId": "2", "Body": "<p>I think GCC <s>Clang</s> is correct</p>\n<p>quoted from n3290:</p>\n<blockquote>\n<p id=\"so_10721130_10721407_0\">14.3.2 Template non-type arguments [temp.arg.nontype]</p>\n<ol>\n<li>A template-argument for a non-type, non-template template-parameter shall be one of:\n   <ul>\n<li>for a non-type template-parameter of integral or enumeration type, a converted &gt; constant expression (5.19) of the type of the template-parameter; or\n   <li>...\n   </li></li></ul></li>\n</ol>\n</blockquote>\n<p>EDIT: 5.19 3</p>\n<blockquote>\n<p id=\"so_10721130_10721407_1\">A literal constant expression is a prvalue core constant expression of\n  literal type, but not pointer type. An integral constant expression is\n  a literal constant expression of integral or unscoped enumeration\n  type. [ Note: Such expressions may be used as array bounds (8.3.4,\n  5.3.4), as bit-field lengths (9.6), as enumerator initializers if the underlying type is not fixed (7.2), as null pointer constants (4.10),\n  and as alignments (7.6.2). \u2014end note ] A converted constant expression\n  of type T is a literal constant expression, implicitly converted to\n  type T, where the implicit conversion (if any) is permitted in a\n  literal constant expression and the implicit conversion sequence\n  contains only user-defined conversions, lvalue-to-rvalue conversions\n  (4.1), integral promotions (4.5), and integral conversions (4.7) other\n  than narrowing conversions (8.5.4).</p>\n<p id=\"so_10721130_10721407_2\">[ Note: such expressions may be used as case expressions (6.4.2), as enumerator initializers if the underlying type is fixed (7.2), and as integral or enumeration non-type template arguments (14.3). \u2014end note ]</p>\n</blockquote>\n", "LastEditorUserId": "231717", "LastActivityDate": "2012-05-24T09:15:57.927", "Score": "3", "CreationDate": "2012-05-23T13:51:49.963", "ParentId": "10721130", "CommentCount": "10", "OwnerUserId": "231717", "LastEditDate": "2012-05-24T09:15:57.927"}});