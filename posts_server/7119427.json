post_cb({"7123418": {"Id": "7123418", "PostTypeId": "2", "Body": "<p>When faced with the tokens <code>S() { }</code> at namespace scope, the compiler can't magically decide it's a ctor. Which grammar rule would produce such a sequence of tokens? Let's ignore everything but function-definitions; they can't produce the <code>( ){ }</code> part. </p>\n<p>That means that <code>S()</code> must be a <em>declarator</em> , and the <em>decl-specifier-seq<sub>opt</sub></em> has to be empty (see \u00a78.4.1). \u00a79.2/7 subsequently tells us that the <em>declarator</em> must name a constructor, destructor, or conversion function. But <code>S</code> doesn't name either. Therefore, <code>S() { }</code> is invalid.</p>\n", "LastActivityDate": "2011-08-19T14:54:13.290", "CommentCount": "2", "CreationDate": "2011-08-19T14:54:13.290", "ParentId": "7119427", "Score": "1", "OwnerUserId": "15416"}, "7119427": {"ViewCount": "1731", "Body": "<p>Here's something we all learned on Day 1 of C++, which we take for granted but doesn't clearly follow from the wording of the Standard.</p>\n<p>Given a class <code>S</code>, we can define its constructor</p>\n<pre><code>struct S { S(); };\nS::S() { \u2026 }\n</code></pre>\n<p>But the Standard seems to allow this just as well:</p>\n<pre><code>struct S { S(); };\nS() { \u2026 }\n</code></pre>\n<p>Qualifying the name of a class with itself is always allowed but always redundant. For example <code>S::S::S::S() { \u2026 }</code> is also a valid declaration. If <code>S::S</code> is, why not plain <code>S</code>?</p>\n<p>From C++11 \u00a712.1/1,</p>\n<blockquote>\n<p id=\"so_7119427_7119427_0\">Constructors do not have names. A special declarator syntax is used to declare or define the constructor. The syntax uses:</p>\n<p id=\"so_7119427_7119427_1\">\u2014 an optional decl-specifier-seq in which each decl-specifier is either a function-specifier or constexpr,</p>\n<p id=\"so_7119427_7119427_2\">\u2014 the constructor\u2019s class name, and</p>\n<p id=\"so_7119427_7119427_3\">\u2014 a parameter list</p>\n<p id=\"so_7119427_7119427_4\">in that order.</p>\n</blockquote>\n<p>This applies equally to class or namespace scope. There is a special rule about namespace scope, \u00a79.3/5,</p>\n<blockquote>\n<p id=\"so_7119427_7119427_5\">If the definition of a member function is lexically outside its class definition, the member function name shall be qualified by its class name using the :: operator.</p>\n</blockquote>\n<p>However, <em>constructors do not have names</em>, so this doesn't apply, right? Moreover, there's no reason to require the qualification, because there is no syntactic ambiguity. A function declared with no return type and a class-name for an identifier is always a syntax error under currently observed rules. Right?</p>\n<p>Not that we should start writing code with the qualification omitted, but is there a reason that no compiler accepts this, or is it just tradition?</p>\n", "AcceptedAnswerId": "7123418", "Title": "Does a namespace-scope constructor definition require a class-qualified identifier?", "CreationDate": "2011-08-19T09:14:28.933", "Id": "7119427", "CommentCount": "12", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2011-08-19T09:32:32.403", "LastEditorUserId": "153285", "LastActivityDate": "2011-08-19T14:54:13.290", "Score": "13", "OwnerUserId": "153285", "Tags": "<c++><syntax><constructor>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_7119427_7119427_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 3887}, "so_7119427_7119427_5": {"length": 17, "quality": 1.0, "section_id": 5884}, "so_7119427_7120002_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 5955}, "so_7119427_7120002_0": {"length": 17, "quality": 1.0, "section_id": 5884}}, "n3337": {"so_7119427_7119427_1": {"length": 7, "quality": 1.0, "section_id": 355}, "so_7119427_7119427_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 355}, "so_7119427_7119427_5": {"length": 17, "quality": 1.0, "section_id": 5655}, "so_7119427_7120002_1": {"length": 11, "quality": 1.0, "section_id": 5724}, "so_7119427_7120002_0": {"length": 17, "quality": 1.0, "section_id": 5655}}, "n4659": {"so_7119427_7119427_1": {"length": 5, "quality": 0.7142857142857143, "section_id": 4766}, "so_7119427_7120002_1": {"length": 9, "quality": 0.8181818181818182, "section_id": 7443}, "so_7119427_7119427_5": {"length": 17, "quality": 1.0, "section_id": 7367}, "so_7119427_7120002_0": {"length": 17, "quality": 1.0, "section_id": 7367}}}, "7120002": {"Id": "7120002", "PostTypeId": "2", "Body": "<p>Yes, it says that,</p>\n<blockquote>\n<p id=\"so_7119427_7120002_0\">If the definition of a member function is lexically outside its class definition\n    the member function name shall be qualified by its class name using the :: operator.</p>\n</blockquote>\n<p>But it <strong><em>doesn't</em></strong> says that member function w/o name shall <strong><em>not</em></strong> be qualified by its class name. Does it? ;)</p>\n<p>That seems to lead to an uncertain area depending on implementations. However, the form of A::A is defined by the Standard.</p>\n<p><em>5.1 Primary Expressions</em></p>\n<blockquote>\n<p id=\"so_7119427_7120002_1\">Where class-name :: class-name is used, and the two class-names refer to the same class, this notation names the constructor..</p>\n</blockquote>\n<p>As to whether <code>A(){..}</code> is allowed or not, I guess there is no reason to do it conventionally(Is there ANY C++ compiler allow it?? AFAIK, nope):</p>\n<ol>\n<li><p>Since constructor is a special member function, the way of <code>A::A(){..}</code> is more consistent with other member functions. Why borther allow it to behave specially? That's probably not worth the effort.</p></li>\n<li><p>No one wants to run the risk of writing non-compliant code that's not explicitly stated in the Standard.</p></li>\n</ol>\n", "LastEditorUserId": "419391", "LastActivityDate": "2011-08-19T10:30:13.193", "Score": "3", "CreationDate": "2011-08-19T10:04:20.887", "ParentId": "7119427", "CommentCount": "6", "OwnerUserId": "419391", "LastEditDate": "2011-08-19T10:30:13.193"}});