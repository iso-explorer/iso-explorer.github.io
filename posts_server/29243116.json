post_cb({"29244316": {"Id": "29244316", "PostTypeId": "2", "Body": "<p>Yes, this is correct code. Quoting N4140 for C++14:</p>\n<blockquote>\n<p id=\"so_29243116_29244316_0\">[expr.sub]/1 <em>...</em> The expression <code>E1[E2]</code> is identical (by definition) to <code>*((E1)+(E2))</code></p>\n<p id=\"so_29243116_29244316_1\">[expr.add]/5 <em>...</em> If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce an overflow; otherwise, the behavior is undefined.</p>\n</blockquote>\n<p>There is no overflow here. <code>&amp;*(*(ptr)) == &amp;ptr[0][0] == &amp;arr[1]</code>.</p>\n<p>For C11 (N1570) the rules are the same. \u00a76.5.2.1 and \u00a76.5.6</p>\n", "LastActivityDate": "2015-03-24T22:46:33.913", "CommentCount": "6", "CreationDate": "2015-03-24T22:46:33.913", "ParentId": "29243116", "Score": "3", "OwnerUserId": "4709452"}, "29244137": {"Id": "29244137", "PostTypeId": "2", "Body": "<p>For C++ (I'm using draft N4296) <code>[dcl.array]/7</code> says in particular that if the result of subscripting is an array, it's immediately converted to pointer. That is, in <code>ptr[0][0]</code> <code>ptr[0]</code> is first converted to <code>int*</code> and only then second <code>[0]</code> is applied to it. So it's perfectly valid code.</p>\n<p>For C (C11 draft N1570) <code>6.5.2.1/3</code> states the same.</p>\n", "LastActivityDate": "2015-03-24T22:32:49.767", "CommentCount": "3", "CreationDate": "2015-03-24T22:32:49.767", "ParentId": "29243116", "Score": "3", "OwnerUserId": "3959454"}, "29244032": {"Id": "29244032", "PostTypeId": "2", "Body": "<p>It depends on what you mean by \"correct\". You are doing a cast on the ptr to <code>arr[1]</code>. In C++ this will probably be a <code>reinterpret_cast</code>. C and C++ are languages which (most of the time) assume that the programmer knows what he is doing. That this code is buggy has nothing to do with the fact that it is valid C/C++ code.</p>\n<p>You are not violating any rules in the standards (as far as I can see).</p>\n", "LastActivityDate": "2015-03-24T22:24:49.530", "CommentCount": "1", "CreationDate": "2015-03-24T22:24:49.530", "ParentId": "29243116", "Score": "2", "OwnerUserId": "4647583"}, "29243717": {"Id": "29243717", "PostTypeId": "2", "Body": "<p>Trying to answer here why the code works on commonly used compilers:</p>\n<pre><code>int arr[2];\n\nint (*ptr)[2] = (int (*)[2]) &amp;arr[1];\n\nprintf(\"%p\\n\", (void*)ptr);\nprintf(\"%p\\n\", (void*)*ptr);\nprintf(\"%p\\n\", (void*)ptr[0]);\n</code></pre>\n<p>All lines print the same address on commonly used compilers. So, <code>ptr</code> is an object for which <code>*ptr</code> represents the same memory location as <code>ptr</code> on commonly used compilers and therefore <code>ptr[0]</code> is really a pointer to <code>arr[1]</code> and therefore <code>arr[0][0]</code> is <code>arr[1]</code>. So, the code assigns a value to <code>arr[1]</code>.</p>\n<p>Now, let's suppose a perverse implementation where a pointer to an array (NOTE: I'm saying pointer to an array, i.e. <code>&amp;arr</code> which has the type <code>int(*)[]</code>, not <code>arr</code> which means the same as <code>&amp;arr[0]</code> and has the type <code>int*</code>) is the pointer to the second byte within the array. Then dereferencing <code>ptr</code> is the same as subtracting 1 from <code>ptr</code> using <code>char*</code> arithmetic. For structs and unions, it is guaranteed that pointer to such types is the same as pointer to the first element of such types, but in <a href=\"https://stackoverflow.com/questions/29244504/casting-pointer-to-array-into-pointer/29248756#29248756\">casting pointer to array into pointer</a> no such guarantee was found for arrays (i.e. that pointer to an array would be the same as pointer to the first element of the array) and as a matter of fact @FUZxxl planned to file a defect report about the standard. For such a perverse implementation, <code>*ptr</code> i.e. <code>ptr[0]</code> would not be the same as <code>&amp;arr[1]</code>. On RISC processors, it would as a matter of fact cause problems due to data alignment.</p>\n<p>Some additional fun:</p>\n<pre><code>int arr[2] = {0, 0};\nint *ptr = (int*)&amp;arr;\nptr[0] = 5;\nprintf(\"%d\\n\", arr[0]);\n</code></pre>\n<p>Should that code work? It prints 5.</p>\n<p>Even more fun:</p>\n<pre><code>int arr[2] = {0, 0};\nint (*ptr)[3] = (int(*)[3])&amp;arr;\nptr[0][0] = 6;\nprintf(\"%d\\n\", arr[0]);\n</code></pre>\n<p>Should this work? It prints 6.</p>\n<p>This should obviously work:</p>\n<pre><code>int arr[2] = {0, 0};\nint (*ptr)[2] = &amp;arr;\nptr[0][0] = 7;\nprintf(\"%d\\n\", arr[0]);\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2015-03-25T08:59:17.943", "Score": "0", "CreationDate": "2015-03-24T22:00:51.927", "ParentId": "29243116", "CommentCount": "6", "OwnerUserId": "4679661", "LastEditDate": "2017-05-23T10:28:48.610"}, "bq_ids": {"n4140": {"so_29243116_29251966_0": {"length": 21, "quality": 1.0, "section_id": 6142}, "so_29243116_29244316_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 5986}, "so_29243116_29244316_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 6142}}, "n3337": {"so_29243116_29251966_0": {"length": 21, "quality": 1.0, "section_id": 5906}, "so_29243116_29244316_1": {"length": 21, "quality": 0.9545454545454546, "section_id": 5906}, "so_29243116_29244316_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 5754}}, "n4659": {"so_29243116_29251966_0": {"length": 11, "quality": 0.5238095238095238, "section_id": 7638}, "so_29243116_29244316_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 7486}}}, "29251966": {"Id": "29251966", "PostTypeId": "2", "Body": "<p>Let me give a dissenting opinion: this is (at least in C++) undefined behaviour, for much the same reason as in the other question that this question linked to.</p>\n<p>First let me clarify the example with some typedefs that will simplify the discussion.</p>\n<pre><code>typedef int two_ints[2];\ntypedef int* int_ptr;\ntypedef two_ints* two_ints_ptr;\n\ntwo_ints arr;\n\ntwo_ints_ptr ptr = (two_ints_ptr) &amp;arr[1];\n\nint_ptr temp = ptr[0]; // the two_ints value ptr[0] gets converted to int_ptr\ntemp[0] = 0;\n</code></pre>\n<p>So the question is whether, although there is no object of type <code>two_ints</code> whose address coincides with that of <code>arr[1]</code> (in the same sense that the adress of <code>arr</code> coincides with that of <code>arr[0]</code>), and therefore no object to which <code>ptr[0]</code> could possibly point to, one can nonetheless convert the value of that expression to one of type <code>int_ptr</code> (here given the name <code>temp</code>) that <em>does</em> point to an object (namely the integer object also called <code>arr[1]</code>).</p>\n<p>The point where I think behaviour is undefined is in the evaluation of <code>ptr[0]</code>, which is equivalent (per 5.2.1[expr.sub]) to <code>*(ptr+0)</code>; more precisely the evaluation of <code>ptr+0</code> has undefined behaviour.</p>\n<p>I'll cite my copy of the C++ which is not official [N3337], but probably the language has not changed; what bothers me slightly is that the section number does not at all match the one mentioned at the accepted answer of the linked question. Anyway, for me it is \u00a75.7[expr.add]</p>\n<blockquote>\n<p id=\"so_29243116_29251966_0\">If both the pointer operand and the result point to elements of the same array object, or one past the last element of the array object, the evaluation shall not produce overflow; otherwise the behavior is undefined.</p>\n</blockquote>\n<p>Since the pointer operand <code>ptr</code> has type pointer to <code>two_ints</code>, the \"array object\" mentioned in the cited text would have to be an array of <code>two_ints</code> objects. However there is only one such object here, the fictive array whose unique element is <code>arr</code> that we are supposed to conjure up in such situations (as per: \"pointer to nonarray object behaves the same as a pointer to the first element of an array of length one...\"), but clearly <code>ptr</code> <em>does not point</em> to its unique element <code>arr</code>. So even though <code>ptr</code> and <code>ptr+0</code> are no doubt equal values, neither of them point to elements of any array object at all (not even a fictive one), nor one past the end of such an array object, and the condition of the cited phrase is not met. The consequence is (not that overflow is produced, but) that behavior is undefined.</p>\n<p>So behavior is already undefined before the indirection operator <code>*</code> is applied. I would not argue for undefined behavior from the latter evaluation, even though the phrase \"the result is an lvalue referring to the object or function to which the expression points\" is hard to interpret for expressions that do not refer to any object at all. But I would be lenient in interpreting this, since I think dereferencing a pointer past an array should not itself be undefined behavior (for instance if used to initialise a reference).</p>\n<p>This would suggest that if instead of <code>ptr[0][0]</code> one wrote <code>(*ptr)[0]</code> or <code>**ptr</code>, then behaviour would not be undefined. This is curious, but it would not be the first time the C++ standard surprises me.</p>\n", "LastActivityDate": "2015-03-25T09:35:22.550", "CommentCount": "1", "CreationDate": "2015-03-25T09:35:22.550", "ParentId": "29243116", "Score": "3", "OwnerUserId": "1436796"}, "29243116": {"ViewCount": "889", "Body": "<p>Is this code correct?</p>\n<pre><code>int arr[2];\n\nint (*ptr)[2] = (int (*)[2]) &amp;arr[1];\n\nptr[0][0] = 0;\n</code></pre>\n<p>Obviously <code>ptr[0][1]</code> would be invalid by accessing out of bounds of <code>arr</code>. </p>\n<p><strong>Note:</strong> There's no doubt that <code>ptr[0][0]</code> designates the same memory location as <code>arr[1]</code>; the question is whether we are allowed to access that memory location via <code>ptr</code>. <a href=\"https://stackoverflow.com/questions/25139579/2d-array-indexing-undefined-behavior\">Here</a> are some more examples of when an expression does designate the same memory location but it is not permitted to access the memory location that way.</p>\n<p><strong>Note 2:</strong> Also consider <code>**ptr = 0;</code> . As pointed out by Marc van Leeuwen, <code>ptr[0]</code> is equivalent to <code>*(ptr + 0)</code>, however <code>ptr + 0</code> seems to fall foul of the pointer arithmetic section. But by using <code>*ptr</code> instead, that is avoided.</p>\n", "Title": "Pointer-to-array overlapping end of array", "CreationDate": "2015-03-24T21:20:54.843", "LastActivityDate": "2015-03-25T10:03:05.343", "CommentCount": "19", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2015-03-25T10:03:05.343", "LastEditorUserId": "1505939", "Id": "29243116", "Score": "21", "OwnerUserId": "1505939", "Tags": "<c++><c><arrays><language-lawyer>", "AnswerCount": "6"}, "29244277": {"Id": "29244277", "PostTypeId": "2", "Body": "<p>Not an answer but a comment that I can't seem to word well without being a wall of text:</p>\n<p>Given arrays are guaranteed to store their contents contiguously so that they can be 'iterated over' using a pointer. If I can take a pointer to the begin of an array and successively increment that pointer until I have accessed every element of the array then surely that makes a statement that the array can be accessed as a series of whatever type it is composed of.</p>\n<p>Surely the combination of:\n1) Array[x] stores its first element at address 'array'\n2) Successive increments of the a pointer to it are sufficient to access the next item\n3) Array[x-1] obeys the same rules</p>\n<p>Then it should be legal to at least look at the address 'array' as if it were type array[x-1] instead of type array[x].</p>\n<p>Furthermore given the points about being contiguous and how pointers to elements in the array have to behave, surely it must be legal to then group any contiguous subset of array[x] as array[y] where y &lt; x and it's upper bound does not exceed the extent of array[x].</p>\n<p>Not being a language-lawyer this is just me spouting some rubbish. I am very interested in the outcome of this discussion though.</p>\n<p><strong>EDIT:</strong></p>\n<p>On further consideration of the original code, it seems to me that arrays are themselves very much a special case in many regards. They decay to a pointer, and I <em>believe</em> can be aliased as per what I just said earlier in this post.</p>\n<p>So without any standardese to back up my humble opinion, an array can't really be invalid or 'undefined' as a whole if it doesn't really get treated as a whole uniformly.</p>\n<p>What does get treated uniformly are the individual elements. So I think it only makes sense to talk about whether accessing a specific element is valid or defined.</p>\n", "LastEditorUserId": "3495829", "LastActivityDate": "2015-03-25T00:34:21.100", "Score": "4", "CreationDate": "2015-03-24T22:44:11.610", "ParentId": "29243116", "CommentCount": "3", "OwnerUserId": "3495829", "LastEditDate": "2015-03-25T00:34:21.100"}});