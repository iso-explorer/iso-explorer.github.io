post_cb({"39791806": {"ViewCount": "399", "Body": "<pre><code>#include &lt;iostream&gt; \n#include &lt;cstring&gt;\n// This struct is not guaranteed to occupy contiguous storage\n// in the sense of the C++ Object model (\u00a71.8.5):\nstruct separated { \n  int i; \n  separated(int a, int b){i=a; i2=b;} \n  ~separated(){i=i2=-1;} // nontrivial destructor --&gt; not trivially   copyable\n  private: int i2;       // different access control --&gt; not standard layout\n};\nint main() {\n  static_assert(not std::is_standard_layout&lt;separated&gt;::value,\"sl\");\n  static_assert(not std::is_trivial&lt;separated&gt;::value,\"tr\");\n  separated a[2]={{1,2},{3,4}};\n  std::memset(&amp;a[0],0,sizeof(a[0]));\n  std::cout&lt;&lt;a[1].i;    \n  // No guarantee that the previous line outputs 3.\n}\n// compiled with Debian clang version 3.5.0-10, C++14-standard \n// (outputs 3) \n</code></pre>\n<ol>\n<li><p>What is the rationale behind weakening standard guarantees to the point that this program may show undefined behaviour?</p></li>\n<li><p>The standard says:\n\"An object of array type contains a contiguously allocated non-empty set of N subobjects of type T.\" [dcl.array] \u00a78.3.4.\nIf objects of type T do not occupy contiguous storage, how can an array of such objects do?</p></li>\n</ol>\n<p>edit: removed possibly distracting explanatory text</p>\n", "AcceptedAnswerId": "39866710", "Title": "Array of non-contiguous objects", "CreationDate": "2016-09-30T12:42:46.210", "Id": "39791806", "CommentCount": "12", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2016-10-13T05:20:30.427", "LastEditorUserId": "6724807", "LastActivityDate": "2016-10-14T08:16:47.417", "Score": "1", "OwnerUserId": "6724807", "Tags": "<c++><arrays><c++14><language-lawyer><memory-layout>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_39791806_39866710_2": {"length": 14, "quality": 0.7777777777777778, "section_id": 6077}, "so_39791806_39866710_0": {"length": 7, "quality": 0.875, "section_id": 6981}}, "n3337": {"so_39791806_39866710_2": {"length": 14, "quality": 0.7777777777777778, "section_id": 5845}, "so_39791806_39866710_0": {"length": 7, "quality": 0.875, "section_id": 6727}}, "n4659": {"so_39791806_39866710_2": {"length": 14, "quality": 0.7777777777777778, "section_id": 7573}, "so_39791806_39866710_0": {"length": 7, "quality": 0.875, "section_id": 8479}}}, "39866710": {"Id": "39866710", "PostTypeId": "2", "Body": "<p>1.\n    This is an instance of Occam's razor as adopted by the dragons that actually write compilers: Do not give more guarantees than needed to solve the problem, because otherwise your workload will double without compensation. Sophisticated classes adapted to fancy hardware or to historic hardware were part of the problem. (hinting by BaummitAugen and M.M)</p>\n<p>2.\n  (contiguous=sharing a common border, next or together in sequence)</p>\n<p>First, it is not that objects of type T either always or never occupy contiguous storage. There may be different memory layouts for the same type within a single binary. </p>\n<blockquote>\n<p id=\"so_39791806_39866710_0\">[class.derived] \u00a710 (8): A base class subobject might have a layout different from ...  </p>\n</blockquote>\n<p>This would be enough to lean back and be satisfied that what is happening on our computers does not contradict the standard. But let's amend the question. A better question would be: </p>\n<blockquote>\n<p id=\"so_39791806_39866710_1\">Does the standard permit arrays of objects that do not occupy contiguous storage individually, while at the same time every two successive subobjects share a common border?</p>\n</blockquote>\n<p>If so, this would influence heavily how char* arithmetic relates to T* arithmetic.</p>\n<p>Depending on whether you understand the OP standard quote meaning that only the subobjects share a common border, or that also within each subobject, the bytes share a common border, you may arrive at different conclusions.</p>\n<p>Assuming the first, you find that\n'contiguously allocated' or 'stored contiguously' may simply mean &amp;a[n]==&amp;a[0] + n (\u00a723.3.2.1), which is a statement about subobject addresses that would not imply that the array resides within a single sequence of contiguous bytes. </p>\n<p>If you assume the stronger version, you may arrive at the 'element offset==sizeof(T)' conclusion brought forward in <a href=\"https://stackoverflow.com/questions/39878237/t-versus-char-pointer-arithmetic\">T* versus char* pointer arithmetic</a>\nThat would also imply that one could force otherwise possibly non-contiguous objects into a contiguous layout by declaring them T t[1]; instead of T t;</p>\n<p>Now how to resolve this mess? There is a fundamentally ambiguous definition of the sizeof() operator in the standard that seems to be a relict of the time when, at least per architecture, type roughly equaled layout, which is not the case any more. (<a href=\"https://stackoverflow.com/questions/39946780/how-does-placement-new-know-which-layout-to-create\">How does placement new know which layout to create?</a>)</p>\n<blockquote>\n<p id=\"so_39791806_39866710_2\">When applied to a class, the result [of sizeof()] is the number of bytes in an object of that class including any padding required for placing objects of that type in an array. [expr.sizeof] \u00a75.3.3 (2)</p>\n</blockquote>\n<p>But wait, the amount of required padding depends on the layout, and a single type may have more than one layout. So we're bound to add a grain of salt and take the minimum over all possible layouts, or do something equally arbitrary. </p>\n<p>Finally, the array definition would benefit from a disambiguation in terms of char* arithmetic, in case this is the intended meaning. Otherwise, the answer to question 1 applies accordingly.</p>\n<hr>\n<p>A few remarks related to now deleted answers and comments: \nAs is discussed in <a href=\"https://stackoverflow.com/questions/39800389/can-technically-objects-occupy-non-contiguous-bytes-of-storage?noredirect=1&amp;lq=1\">Can technically objects occupy non-contiguous bytes of storage?</a>, non-contiguous objects actually exist. Furthermore, memseting a subobject naively  may invalidate unrelated subobjects of the containing object, even for perfectly contiguous, trivially copyable objects:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;cstring&gt;\nstruct A {\n  private: int a;\n  public: short i;\n};\nstruct B :  A {\n  short i;\n};\nint main()\n{\n   static_assert(std::is_trivial&lt;A&gt;::value , \"A not trivial.\");\n   static_assert(not std::is_standard_layout&lt;A&gt;::value , \"sl.\");\n   static_assert(std::is_trivial&lt;B&gt;::value , \"B not trivial.\");\n   B object;\n   object.i=1;\n   std::cout&lt;&lt; object.B::i;\n   std::memset((void*)&amp;(A&amp;)object ,0,sizeof(A));\n   std::cout&lt;&lt;object.B::i;\n}\n// outputs 10 with g++/clang++, c++11, Debian 8, amd64     \n</code></pre>\n<p>Therefore, it is conceivable that the memset in the question post might zero a[1].i, such that the program would output 0 instead of 3.</p>\n<p>There are few occasions where one would use memset-like functions with C++-objects at all. (Normally, destructors of subobjects will fail blatantly if you do that.) But sometimes one wishes to scrub the contents of an 'almost-POD'-class in its destructor, and this might be the exception.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2016-10-14T08:16:47.417", "Score": "2", "CreationDate": "2016-10-05T06:20:07.653", "ParentId": "39791806", "CommentCount": "12", "OwnerUserId": "6724807", "LastEditDate": "2017-05-23T12:16:31.537"}});