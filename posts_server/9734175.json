post_cb({"9734378": {"ParentId": "9734175", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Confusion arises because inline has two effects:</p>\n<ol>\n<li>It tells the compiler that the function code can be <em>expanded</em> where the function is called, instead of effectively <em>being called</em>.</li>\n<li>It tells the compiler that the function definition can be repeated.</li>\n</ol>\n<p>Point 1. is \"archaic\" in the sense that the compiler can in fact do what it likes in order to optimize code. It will always \"inline\" machine code if it can and find convenient to do and it will never do that if it cannot.</p>\n<p>Point 2. is the actual meaning of the term: if you <code>define</code> (specify the body) a function in the header, since a header can be included in more sources, you must tell the compiler to inform the linker about the definition duplicates, so that they can be merged.</p>\n<p>Now, by the language specification, free functions (not defined in class bodies) are by default not defined as inline, so defining in a header a thing like</p>\n<pre><code>void myfunc()\n{}\n</code></pre>\n<p>if the header is included in more sources, then linked in a same output, the linker will report a multiple definition error, hence the need to define it as</p>\n<pre><code>inline void fn()\n{}\n</code></pre>\n<p>For class members, the default is the opposite: if you just declare them, they will not be inlined. If you define them, they will be inline. </p>\n<p>So a header should look like</p>\n<pre><code>//header file\n\nclass myclass\n{\npublic:\n    void fn1()\n    {} //defined into the class, so inlined by default\n\n    void fn2();\n};\n\ninline void myclass::fn2()\n{} //defined outside the class, so explicit inline is needed\n</code></pre>\n<p>And if <code>myclass::fn2()</code> definition goes into a proper source, must lose the <code>inline</code> keyword.</p>\n", "OwnerUserId": "924727", "LastEditorUserId": "3233", "LastEditDate": "2017-03-23T11:18:00.767", "Id": "9734378", "Score": "30", "CreationDate": "2012-03-16T09:03:33.717", "LastActivityDate": "2017-03-23T11:18:00.767"}, "9734257": {"ParentId": "9734175", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The only reason to make the method function inline is if you define it in the header.</p>\n<p>If you define a method function in a header, and you do not put inline keyword, and you include the header in several header or source files, you would get multiple definition of the method.</p>\n<p>c++11 standard in 9.3/2 Member functions [class.mfct] tells :</p>\n<blockquote>\n<p id=\"so_9734175_9734257_0\">A member function may be de\ufb01ned (8.4) in its class de\ufb01nition, in which case it is an inline member function (7.1.2) ...</p>\n</blockquote>\n", "OwnerUserId": "476681", "LastEditorUserId": "476681", "LastEditDate": "2012-03-16T09:19:56.030", "Id": "9734257", "Score": "7", "CreationDate": "2012-03-16T08:52:33.257", "LastActivityDate": "2012-03-16T09:19:56.030"}, "9734303": {"ParentId": "9734175", "CommentCount": "0", "Body": "<p>When the definition is inside the class, it is treated as if it were declared <code>inline</code>, because it is assumed that class definitions live in header files that are used from more than one translation unit, so any non-inline definitions here would violate the One Definition Rule.</p>\n<p>The compiler is, as always, free to inline whatever it thinks as long as it takes care that functions that are either explicitly or implicitly inline will not lead to linker errors. How it does that is left open by the language spec -- inlining the function of course works, but it is also acceptable to demote the symbol visibility or rename the symbol to a translation unit specific name (as if the function were in an anonymous namespace), or (as most of them do) communicate to the linker that multiple copies of that function may exist and that it should discard all but one of them.</p>\n<p>So, in short, it is not treated any different from functions that are explicitly declared <code>inline</code>.</p>\n", "OwnerUserId": "613064", "PostTypeId": "2", "Id": "9734303", "Score": "2", "CreationDate": "2012-03-16T08:57:19.140", "LastActivityDate": "2012-03-16T08:57:19.140"}, "9734198": {"ParentId": "9734175", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>The compiler can ignore inlining if specified by the <code>inline</code> keyword. If the method implementation is present inside the class definition, that's a different thing, and can't be ignored. (well it can, but that makes the compiler non-conforming)</p>\n<p>The reason behind the desing - I'm assuming a mechanism was needed where you can actually force the compiler to actually inline your functions, since the <code>inline</code> keyword doesn't mandate it. But in general, inline method definition is done only in cases like getter and setter methods, or some trivial 2-liners. And templates, but that's a different issue.</p>\n<p>Inlining has to do with headers and source files in that the definition of the function must be visible to the compiler so it knows how to actually inline the call. It's more difficult to inline a function defined in an implementation file than one defined in a header.</p>\n<p>EDIT: On a side note, the paragraph the op is reffering to is <code>7.1.2.3</code>:</p>\n<blockquote>\n<p id=\"so_9734175_9734198_0\">A function defined within a class definition is a inline function [...].</p>\n</blockquote>\n<p>EDIT2:</p>\n<p>Apparently, there are some difference between an inline function and inline substitution. The first is a property of a function, that doesn't only include inline substitution, the second means that the function body is actually pasted where it is called. </p>\n<p>So the function can be inlined but not have its body pasted instead of being called.</p>\n", "OwnerUserId": "673730", "LastEditorUserId": "673730", "LastEditDate": "2012-03-16T09:52:47.947", "Id": "9734198", "Score": "3", "CreationDate": "2012-03-16T08:47:26.863", "LastActivityDate": "2012-03-16T09:52:47.947"}, "9734373": {"ParentId": "9734175", "CommentCount": "0", "Body": "<p>the two things you reffer to are different aspects and not to be confused with. </p>\n<blockquote>\n<p id=\"so_9734175_9734373_0\">1) The C++ standard says all member functions defined inside class definition are inline</p>\n<p id=\"so_9734175_9734373_1\">2) I have also heard that compiler can ignore inlining of a function</p>\n</blockquote>\n<p>1) is when you define the member functions inside the class declaration itself. ie: in the header files. for that you do not have to provide any keyword( ie: <code>inline</code>)</p>\n<p>2) You can specify a function as inline by explicitly using the <code>inline</code> keyword. this is actually a request to the compiler. the compiler may or may not make the function inline according to some rules of optimization. </p>\n", "OwnerUserId": "1155650", "PostTypeId": "2", "Id": "9734373", "Score": "0", "CreationDate": "2012-03-16T09:03:23.363", "LastActivityDate": "2012-03-16T09:03:23.363"}, "9734175": {"CommentCount": "11", "AcceptedAnswerId": "9734378", "PostTypeId": "1", "LastEditorUserId": "962111", "CreationDate": "2012-03-16T08:45:35.970", "LastActivityDate": "2017-03-23T11:18:00.767", "LastEditDate": "2012-03-16T10:04:59.990", "ViewCount": "6137", "FavoriteCount": "8", "Title": "Why are class member functions inlined?", "Id": "9734175", "Score": "17", "Body": "<p>I think my question has been asked here before, I did read them but still little confused and therefore asking to make it clear.</p>\n<p><code>The C++ standard says all member functions defined inside class definition are inline</code></p>\n<p>I have also heard that compiler can ignore inlining of a function. Will that be true in the above case or it will be always inlined if defined inside class definition? </p>\n<p>Also, what was the reason behind this design, making all functions defined inside class definition inline? And what inlining has to do with source and header files? </p>\n<p><strong>Update:</strong> So one should always define their functions outside class if not to be inlined, right?</p>\n<p><strike><strong>Update 2 by JohnB:</strong>  Two functions declared inside class definition could never call each other as they would have to each contain the whole body of the other function. What will happen in this case?</strike> (Already answered by Emilio Garavaglia)</p>\n", "Tags": "<c++><class><function><compiler-construction><inline>", "OwnerUserId": "962111", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_9734175_9734198_0": {"section_id": 5403, "quality": 1.0, "length": 7}, "so_9734175_9734257_0": {"section_id": 5881, "quality": 0.6666666666666666, "length": 8}, "so_9734175_9734373_0": {"section_id": 4706, "quality": 0.6, "length": 6}}, "n3337": {"so_9734175_9734198_0": {"section_id": 5198, "quality": 1.0, "length": 7}, "so_9734175_9734257_0": {"section_id": 5652, "quality": 0.6666666666666666, "length": 8}, "so_9734175_9734373_0": {"section_id": 4515, "quality": 0.6, "length": 6}}, "n4659": {"so_9734175_9734198_0": {"section_id": 6851, "quality": 1.0, "length": 7}, "so_9734175_9734257_0": {"section_id": 7364, "quality": 0.6666666666666666, "length": 8}}}, "9734591": {"ParentId": "9734175", "CommentCount": "0", "Body": "<p>The <code>inline</code> keyword has for a function 2 meanings:</p>\n<ol>\n<li><strong>Code replacement</strong>: Wherever <code>inline</code> function is invoked, don't generate a function call for it but simply place the contents of the function\nat the place of its call (this is something similar to macro\nreplacement, but type safe)</li>\n<li><strong>One definition rule</strong>: Don't generate multiple definition for a <code>inline</code> function, only generate a single definition common for all (exception: <code>static</code> functions)</li>\n</ol>\n<p>The 1st terminology (\"Code replacement\"), is simply a <strong>request</strong> to the compiler. which can be ignored as compiler is better to judge whether to put the text or a function call. (for example, <code>virtual</code> functions or recursive functions cannot be inlined).</p>\n<p>The 2nd terminology (\"One definition rule\") is <strong>guaranteed</strong> to happen by any conforming compiler. This will generate only 1 definition for all translation units. This facility eases coder's work sometimes, as for smaller function one may not want to put its definition in <code>.cpp</code> file (e.g. getters, setters).<br>\nMoreover, for <code>template</code> function which are header only constructs, this effect is mandatory. Thus <code>template</code> functions are <code>inline</code> by default.</br></p>\n<h2>Examples:</h2>\n<pre><code>class A {\npublic:\n  void setMember (int i) { m_i = i; }\n};\n</code></pre>\n<p>In this example mostly compiler would suffice both terminologies</p>\n<pre><code>class A {\n  inline virtual ~A () = 0;\n};\nA::~A() {}\n</code></pre>\n<p>Here compiler can only suffice the 2nd requirement.</p>\n", "OwnerUserId": "514235", "PostTypeId": "2", "Id": "9734591", "Score": "9", "CreationDate": "2012-03-16T09:20:10.097", "LastActivityDate": "2012-03-16T09:20:10.097"}});