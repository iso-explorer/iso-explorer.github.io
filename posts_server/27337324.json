post_cb({"27337346": {"ParentId": "27337324", "CommentCount": "0", "Body": "<p>The local object is destroyed during stack unwinding. The reference then becomes invalid, a <strong>dangling reference</strong>. Which means that inspection of the exception object such that the reference is used, will have Undefined Behavior.</p>\n", "OwnerUserId": "464581", "PostTypeId": "2", "Id": "27337346", "Score": "3", "CreationDate": "2014-12-06T22:31:39.183", "LastActivityDate": "2014-12-06T22:31:39.183"}, "27337344": {"ParentId": "27337324", "CommentCount": "7", "Body": "<p>The behavior is the same as when returning a reference to a variable on the stack: the object is destroyed before you get to use it. That is, by the time the exception is caught, the referenced object is destroyed and all access to the reference result in undefined behavior.</p>\n<p>The relevant clause in the standard is 15.2 [except.ctor] paragraph 1:</p>\n<blockquote>\n<p id=\"so_27337324_27337344_0\">As control passes from the point where an exception is thrown to a handler, destructors are invoked for all automatic objects constructed since the try block was entered. The automatic objects are destroyed in the reverse order of the completion of their construction.</p>\n</blockquote>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "27337344", "Score": "4", "CreationDate": "2014-12-06T22:31:30.520", "LastActivityDate": "2014-12-06T22:31:30.520"}, "bq_ids": {"n4140": {"so_27337324_27337344_0": {"section_id": 3343, "quality": 0.9629629629629629, "length": 26}}, "n3337": {"so_27337324_27337344_0": {"section_id": 3213, "quality": 0.8148148148148148, "length": 22}}, "n4659": {"so_27337324_27337344_0": {"section_id": 4109, "quality": 0.5555555555555556, "length": 15}}}, "27337324": {"CommentCount": "1", "ViewCount": "324", "PostTypeId": "1", "LastEditorUserId": "353563", "CreationDate": "2014-12-06T22:29:29.760", "LastActivityDate": "2014-12-06T23:00:08.893", "Title": "Throwing exception that has const reference to local variable", "LastEditDate": "2014-12-06T23:00:08.893", "Id": "27337324", "Score": "1", "Body": "<p>What happens to the local variables during stack unwinding, that are referenced in exception? Consider following code:</p>\n<pre><code>class bar;\nclass my_error\n{\npublic:\n    my_error(const bar&amp; bar) : _bar(bar) {}\n    const bar&amp; get_bar() const { return _bar; }\n\nprivate:\n    const bar&amp; _bar;\n}\n\n\n...\n\nbar some_local_object(...);\nif (!foo()) {\n   throw my_error(some_local_object);\n}\n\n...\n\ntry {\n    g();\n} catch (my_error&amp; e) {\n    e.get_bar()\n    ...\n}\n</code></pre>\n<p>What happens to <em>some_local_object</em>? Shouldn't it be destroyed during stack unwinding? Is it safe to use it, as provided in example?</p>\n<p><strong>Additional question</strong></p>\n<p>As already answered, this code would lead to undefined behavior. My second question to it is: </p>\n<p>If I am neither allowed to pass reference to local object nor should I try to make copy of it, because in rare case it could cause bad_alloc (which is why, I guess, gcc standard library has no meaningful error message, i.e. map.at throws exception for which what() returns \"map.at\"), then what is a good strategy to pass additional information? Note that even joining multiple strings, during construction of error message could theoretically cause bad_alloc. i.e.:</p>\n<pre><code>void do_something(const key&amp; k, ....)\n{\n    ...\n    if (!foo(k)) {\n        std::ostringstream os;\n        os &lt;&lt; \"Key \" &lt;&lt; k &lt;&lt; \" not found\"; // could throw bad_alloc\n        throw std::runtime_error(os.str()); \n    }\n    // another approcach\n    if (!foo(k)) {\n        throw key_not_found(k); // also bad, because exception could outlive k\n    }\n}\n</code></pre>\n", "Tags": "<c++><stack-unwinding>", "OwnerUserId": "353563", "AnswerCount": "2"}});