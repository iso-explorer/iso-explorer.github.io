post_cb({"34167803": {"ParentId": "34142490", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The key issue here is that <code>std::vector</code> tries to offer the <a href=\"https://en.wikipedia.org/wiki/Exception_safety\" rel=\"nofollow noreferrer\">strong exception safety guarantee</a> for as many operations as possible, but, in order to do that, it needs support from the element type. For <code>push_back</code>, <code>emplace_back</code> and friends, the main problem is what happens if a reallocation is necessary, as the existing elements need to be copied / moved to the new storage.</p>\n<p>The relevant standard wording is in [23.3.6.5p1]:</p>\n<blockquote>\n<p id=\"so_34142490_34167803_0\"><em>Remarks:</em> Causes reallocation if the new size is greater than the old capacity. If no reallocation happens, all the iterators and references\n  before the insertion point remain valid. If an exception is thrown\n  other than by the copy constructor, move constructor, assignment\n  operator, or move assignment operator of <code>T</code> or by any <code>InputIterator</code>\n  operation there are no effects. If an exception is thrown while\n  inserting a single element at the end and <code>T</code> is <code>CopyInsertable</code> or\n  <code>is_nothrow_move_constructible&lt;T&gt;::value</code> is <code>true</code>, there are no\n  effects. Otherwise, if an exception is thrown by the move constructor\n  of a non-<code>CopyInsertable</code> <code>T</code>, the effects are unspecified.</p>\n</blockquote>\n<p>(The original wording in C++11 has been clarified by the resolution of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2252\" rel=\"nofollow noreferrer\">LWG 2252</a>.)</p>\n<p>Note that <code>is_nothrow_move_constructible&lt;T&gt;::value == true</code> doesn't necessarily mean that <code>T</code> has a <code>noexcept</code> move constructor; a <code>noexcept</code> copy constructor taking <code>const T&amp;</code> will do as well.</p>\n<p>What this means in practice is that, <em>conceptually</em>, a <code>vector</code> implementation typically tries to generate code for one of the following solutions for copying / moving existing elements to the new storage, in decreasing order of preference (<code>T</code> is the element type, and we're interested in class types here):</p>\n<ul>\n<li>If <code>T</code> has a usable (present, not deleted, not ambiguous, accessible, etc.) <code>noexcept</code> move constructor, use it; exceptions cannot be thrown while constructing the elements in the new storage, so there's no need to revert to the previous state.</li>\n<li>Otherwise, if <code>T</code> has a usable copy constructor, <code>noexcept</code> or not, that takes a <code>const T&amp;</code>, use that; even if copying throws an exception, we can revert to the previous state, as the originals are still there, unmodified.</li>\n<li>Otherwise, if <code>T</code> has a usable move constructor that may throw exceptions, use that; however, the strong exception safety guarantee cannot be offered anymore.</li>\n<li>Otherwise, the code doesn't compile.</li>\n</ul>\n<p>The above can be achieved by using <a href=\"http://en.cppreference.com/w/cpp/utility/move_if_noexcept\" rel=\"nofollow noreferrer\"><code>std::move_if_noexcept</code></a> or something similar.</p>\n<hr>\n<p>Let's see what <code>Category</code> offers in terms of constructors. None is declared explicitly, so a default constructor, a copy constructor and a move constructor are implicitly declared.</p>\n<p>The copy constructor uses the respective copy constructors of the members:</p>\n<ul>\n<li><code>data</code> is a <code>std::vector</code>, and <code>vector</code>'s copy constructor cannot be <code>noexcept</code> (it generally needs to allocate new memory), so <code>Category</code>'s copy constructor cannot be <code>noexcept</code> regardless of what <code>QString</code> has.</li>\n<li>The definition of <code>std::vector&lt;std::unique_ptr&lt;int&gt;&gt;</code>'s copy constructor calls <code>std::unique_ptr&lt;int&gt;</code>'s copy constructor, which is explicitly deleted, but this only affects the definition, which is only instantiated if needed. Overload resolution only needs the declarations, so <code>Category</code> has an implicitly declared copy constructor that will cause a compile error if called.</li>\n</ul>\n<p>The move constructor:</p>\n<ul>\n<li><code>std::vector</code> has a <code>noexcept</code> move constructor (see the note below), so <code>data</code> is not a problem.</li>\n<li>Old versions of <code>QString</code> (before Qt 5.2):\n\n<ul>\n<li>A move constructor is not explicitly declared (see <a href=\"https://stackoverflow.com/questions/34142490/why-do-qstring-and-vectorunique-ptrint-appear-incompatible-here/34167803#comment56033225_34142490\">Praetorian's comment above</a>), so, because there is an explicitly declared copy constructor, a move constructor will not be implicitly declared <em>at all</em>. </li>\n<li>The definition of the implicitly declared move constructor of <code>Category</code> will use <code>QString</code>'s copy constructor that takes a <code>const QString&amp;</code>, which can bind to rvalues (the constructors for subobjects are chosen using overload resolution).</li>\n<li>In these old versions, <code>QString</code>'s copy constructor is not specified as <code>noexcept</code>, so <code>Category</code>'s move constructor can't be <code>noexcept</code> either.</li>\n</ul></li>\n<li>Since Qt 5.2, <code>QString</code> has an explicitly declared move constructor, which will be used by <code>Category</code>'s move constructor. However, before Qt 5.5, <code>QString</code>'s move constructor was not <code>noexcept</code>, so <code>Category</code>'s move constructor can't be <code>noexcept</code> either.</li>\n<li>Since Qt 5.5, <code>QString</code>'s move constructor is specified as <code>noexcept</code>, so <code>Category</code>'s move constructor is <code>noexcept</code> as well.</li>\n</ul>\n<p>Note that <code>Category</code> does have a move constructor in all cases, but it may not move <code>name</code>, and it may not be <code>noexcept</code>.</p>\n<hr>\n<p>Given all of the above, we can see that <code>categories.emplace_back()</code> won't generate code that uses <code>Category</code>'s move constructor when Qt 4 is used (OP's case), because it's not <code>noexcept</code>. (Of course, there are no existing elements to move in this case, but that's a runtime decision; <code>emplace_back</code> has to include a code path that handles the general case, and that code path has to compile.) So, the generated code calls <code>Category</code>'s copy constructor, which causes the compile error.</p>\n<p>A solution is to provide a move constructor for <code>Category</code> and mark it <code>noexcept</code> (otherwise it won't help). <code>QString</code> uses copy-on-write anyway, so it's unlikely to throw while copying.</p>\n<p>Something like this should work:</p>\n<pre><code>class Category\n{\n   std::vector&lt;std::unique_ptr&lt;int&gt;&gt; data;\n   QString name;\npublic:\n   Category() = default;\n   Category(const Category&amp;) = default;\n   Category(Category&amp;&amp; c) noexcept : data(std::move(c.data)), name(std::move(c.name)) { }\n   // assignment operators\n};\n</code></pre>\n<p>This will pick up <code>QString</code>'s move constructor if declared, and use the copy constructor otherwise (just like the implicitly declared move constructor would). Now that the constructors are user-declared, the assignment operators have to be taken into account as well.</p>\n<p>The explanations for bullets 1, 3 and 4 in the question should now be pretty clear. Bullet 2 (make <code>data</code> just a single <code>unique_ptr&lt;int&gt;</code>) is more interesting:</p>\n<ul>\n<li><code>unique_ptr</code> has a deleted copy constructor; this causes <code>Category</code>'s implicitly declared copy constructor to be defined as deleted as well.</li>\n<li><code>Category</code>'s move constructor is still declared as above (not <code>noexcept</code> in the OP's case).</li>\n<li>This means that the code generated for <code>emplace_back</code> cannot use <code>Category</code>'s copy constructor, so it has to use the move constructor, even though it can throw (see the first section above). The code compiles, but it no longer offers the strong exception safety guarantee.</li>\n</ul>\n<hr>\n<p>Note: <code>vector</code>'s move constructor has only recently been specified as <code>noexcept</code> in the Standard, after C++14, as a result of the adoption of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4258.pdf\" rel=\"nofollow noreferrer\">N4258</a> into the working draft. In practice, however, both libstdc++ and libc++ have provided a <code>noexcept</code> move constructor for <code>vector</code> since the times of C++0x; an implementation is allowed to strengthen an exception specification compared to the Standard's specification, so that's OK. </p>\n<p>libc++ actually uses <code>noexcept(is_nothrow_move_constructible&lt;allocator_type&gt;::value)</code> for C++14 and below, but allocators are required to be nothrow move and copy constructible since C++11 (table 28 in [17.6.3.5]), so that's redundant for Standard-conforming allocators.</p>\n<hr>\n<p>Note (updated): The discussion about the strong exception safety guarantee doesn't apply to the standard library implementation that comes with MSVC before version 2017: up to and including Visual Studio 2015 Update 3, it always tries to move, regardless of the noexcept specification.</p>\n<p>According to <a href=\"https://blogs.msdn.microsoft.com/vcblog/2017/02/06/stl-fixes-in-vs-2017-rtm/\" rel=\"nofollow noreferrer\">this blog post</a> by Stephan T. Lavavej, the implementation in MSVC 2017 has been overhauled and now behaves correctly as described above.</p>\n<hr>\n<p>Standard references are to working draft N4567 unless otherwise noted.</p>\n</hr></hr></hr></hr></hr>", "OwnerUserId": "4326278", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:01:43.123", "Id": "34167803", "Score": "4", "CreationDate": "2015-12-08T23:05:31.357", "LastActivityDate": "2017-02-14T09:07:16.060"}, "bq_ids": {"n4140": {"so_34142490_34167803_0": {"section_id": 986, "quality": 0.9821428571428571, "length": 55}}, "n3337": {"so_34142490_34167803_0": {"section_id": 971, "quality": 0.75, "length": 42}}, "n4659": {"so_34142490_34167803_0": {"section_id": 1049, "quality": 0.9642857142857143, "length": 54}}}, "34142490": {"CommentCount": "10", "AcceptedAnswerId": "34167803", "PostTypeId": "1", "LastEditorUserId": "241631", "CreationDate": "2015-12-07T20:23:43.213", "LastActivityDate": "2017-02-14T09:07:16.060", "LastEditDate": "2015-12-08T01:42:05.533", "ViewCount": "154", "FavoriteCount": "1", "Title": "Why do QString and vector<unique_ptr<int>> appear incompatible here?", "Id": "34142490", "Score": "5", "Body": "<p>I'm trying to compile some code, which reduces to this:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;vector&gt;\n#include &lt;QString&gt;\n\nclass Category\n{\n    std::vector&lt;std::unique_ptr&lt;int&gt;&gt; data;\n    QString name;\n};\n\nint main()\n{\n    std::vector&lt;Category&gt; categories;\n    categories.emplace_back();\n};\n</code></pre>\n<p>Compiled as is, it results in the following error from g++ and similar for clang++:</p>\n<pre><code>In file included from /opt/gcc-4.8/include/c++/4.8.2/memory:64:0,\n                 from test.cpp:1:\n/opt/gcc-4.8/include/c++/4.8.2/bits/stl_construct.h: In instantiation of \u2018void std::_Construct(_T1*, _Args&amp;&amp; ...) [with _T1 = std::unique_ptr&lt;int&gt;; _Args = {const std::unique_ptr&lt;int, std::default_delete&lt;int&gt; &gt;&amp;}]\u2019:\n/opt/gcc-4.8/include/c++/4.8.2/bits/stl_uninitialized.h:75:53:   required from \u2018static _ForwardIterator std::__uninitialized_copy&lt;_TrivialValueTypes&gt;::__uninit_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = __gnu_cxx::__normal_iterator&lt;const std::unique_ptr&lt;int&gt;*, std::vector&lt;std::unique_ptr&lt;int&gt; &gt; &gt;; _ForwardIterator = std::unique_ptr&lt;int&gt;*; bool _TrivialValueTypes = false]\u2019\n/opt/gcc-4.8/include/c++/4.8.2/bits/stl_uninitialized.h:117:41:   required from \u2018_ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = __gnu_cxx::__normal_iterator&lt;const std::unique_ptr&lt;int&gt;*, std::vector&lt;std::unique_ptr&lt;int&gt; &gt; &gt;; _ForwardIterator = std::unique_ptr&lt;int&gt;*]\u2019\n/opt/gcc-4.8/include/c++/4.8.2/bits/stl_uninitialized.h:258:63:   required from \u2018_ForwardIterator std::__uninitialized_copy_a(_InputIterator, _InputIterator, _ForwardIterator, std::allocator&lt;_Tp&gt;&amp;) [with _InputIterator = __gnu_cxx::__normal_iterator&lt;const std::unique_ptr&lt;int&gt;*, std::vector&lt;std::unique_ptr&lt;int&gt; &gt; &gt;; _ForwardIterator = std::unique_ptr&lt;int&gt;*; _Tp = std::unique_ptr&lt;int&gt;]\u2019\n/opt/gcc-4.8/include/c++/4.8.2/bits/stl_vector.h:316:32:   required from \u2018std::vector&lt;_Tp, _Alloc&gt;::vector(const std::vector&lt;_Tp, _Alloc&gt;&amp;) [with _Tp = std::unique_ptr&lt;int&gt;; _Alloc = std::allocator&lt;std::unique_ptr&lt;int&gt; &gt;]\u2019\ntest.cpp:5:7:   [ skipping 2 instantiation contexts, use -ftemplate-backtrace-limit=0 to disable ]\n/opt/gcc-4.8/include/c++/4.8.2/bits/stl_uninitialized.h:117:41:   required from \u2018_ForwardIterator std::uninitialized_copy(_InputIterator, _InputIterator, _ForwardIterator) [with _InputIterator = Category*; _ForwardIterator = Category*]\u2019\n/opt/gcc-4.8/include/c++/4.8.2/bits/stl_uninitialized.h:258:63:   required from \u2018_ForwardIterator std::__uninitialized_copy_a(_InputIterator, _InputIterator, _ForwardIterator, std::allocator&lt;_Tp&gt;&amp;) [with _InputIterator = Category*; _ForwardIterator = Category*; _Tp = Category]\u2019\n/opt/gcc-4.8/include/c++/4.8.2/bits/stl_uninitialized.h:281:69:   required from \u2018_ForwardIterator std::__uninitialized_move_if_noexcept_a(_InputIterator, _InputIterator, _ForwardIterator, _Allocator&amp;) [with _InputIterator = Category*; _ForwardIterator = Category*; _Allocator = std::allocator&lt;Category&gt;]\u2019\n/opt/gcc-4.8/include/c++/4.8.2/bits/vector.tcc:415:43:   required from \u2018void std::vector&lt;_Tp, _Alloc&gt;::_M_emplace_back_aux(_Args&amp;&amp; ...) [with _Args = {}; _Tp = Category; _Alloc = std::allocator&lt;Category&gt;]\u2019\n/opt/gcc-4.8/include/c++/4.8.2/bits/vector.tcc:101:54:   required from \u2018void std::vector&lt;_Tp, _Alloc&gt;::emplace_back(_Args&amp;&amp; ...) [with _Args = {}; _Tp = Category; _Alloc = std::allocator&lt;Category&gt;]\u2019\ntest.cpp:14:29:   required from here\n/opt/gcc-4.8/include/c++/4.8.2/bits/stl_construct.h:75:7: error: use of deleted function \u2018std::unique_ptr&lt;_Tp, _Dp&gt;::unique_ptr(const std::unique_ptr&lt;_Tp, _Dp&gt;&amp;) [with _Tp = int; _Dp = std::default_delete&lt;int&gt;]\u2019\n     { ::new(static_cast&lt;void*&gt;(__p)) _T1(std::forward&lt;_Args&gt;(__args)...); }\n       ^\nIn file included from /opt/gcc-4.8/include/c++/4.8.2/memory:81:0,\n                 from test.cpp:1:\n/opt/gcc-4.8/include/c++/4.8.2/bits/unique_ptr.h:273:7: error: declared here\n       unique_ptr(const unique_ptr&amp;) = delete;\n       ^\n</code></pre>\n<ul>\n<li>If I remove <code>name</code> member from <code>Category</code>, it compiles fine.</li>\n<li>If I make <code>data</code> just a single <code>unique_ptr&lt;int&gt;</code> instead of a vector of pointers, it compiles fine.</li>\n<li>If I create a single <code>Category</code> in <code>main()</code> instead of a creating a vector and doing <code>emplace_back()</code>, it compiles fine.</li>\n<li>If I replace <code>QString</code> with <code>std::string</code>, it compiles fine.</li>\n</ul>\n<p>What's going on? What makes this code ill-formed? Is it result of bugs in g++ &amp; clang++?</p>\n", "Tags": "<c++><qt><vector><unique-ptr><qstring>", "OwnerUserId": "673852", "AnswerCount": "1"}});