post_cb({"27518309": {"ParentId": "27518251", "CommentCount": "0", "CreationDate": "2014-12-17T04:24:20.227", "Id": "27518309", "PostTypeId": "2", "OwnerDisplayName": "user3920237", "Score": "4", "Body": "<p>No, arrays do not decay as operands of the <code>sizeof</code> operator. This is one of the few places where arrays don't decay. If an <code>int</code> is 4 bytes on your machine, then the total number of bytes of the array should be 20 (4 * 5). We don't even need an object to test this.</p>\n<pre><code>sizeof(int[5]) // 20\nsizeof(int*)   // 8 on a 64-bit machine\n</code></pre>\n", "LastActivityDate": "2014-12-17T04:24:20.227"}, "27518343": {"ParentId": "27518251", "LastEditDate": "2014-12-17T04:34:09.573", "CommentCount": "0", "CreationDate": "2014-12-17T04:28:59.673", "OwnerUserId": "179910", "LastEditorUserId": "179910", "PostTypeId": "2", "Id": "27518343", "Score": "13", "Body": "<p>The name of an array decays to a pointer to the first element of the array in <em>most</em> situations. There are a couple of exceptions to that rule though. The two most important are when the array name is used as the operand of either the <code>sizeof</code> operator or the <code>address-of</code> operator (<code>&amp;</code>). In these cases, the name of the array remains an identifier for the array as a whole.</p>\n<p>For a non-VLA array, this means that the size of the array can be determined statically (at compile time) and the result of the expression will be the size of the array (in bytes), not the size of a pointer.</p>\n<p>When you take the address of the array, you get the same value (i.e., the same address) as if you'd just used the name of the array without taking the address. The type is different though--when you explicitly take the address, what you get is a pointer of type \"pointer to array of N items of type T\". That means (for one example) that while <code>array+1</code> points to the second element of the array, <code>&amp;array+1</code> points to another array just past the end of the entire array.</p>\n<p>Assuming an array of at least two items, <code>*(array+1)</code> will refer to the second element of the array. Regardless of the array size, <code>&amp;array+1</code> will yield an address past the end of the array, so attempting to dereference that address gives undefined behavior.</p>\n<p>In your case, given that the size of the array is 20, and the size of one element of the array is 4, if <code>array</code> was, say, 0x1000, then <code>array+1</code> would be <code>0x1004</code> and <code>&amp;array+1</code> would be <code>0x1014</code> (0x14 = 20).</p>\n", "LastActivityDate": "2014-12-17T04:34:09.573"}, "27518251": {"CommentCount": "8", "AcceptedAnswerId": "27518343", "ClosedDate": "2014-12-17T12:13:57.437", "CreationDate": "2014-12-17T04:16:38.087", "LastActivityDate": "2014-12-17T10:55:28.680", "PostTypeId": "1", "ViewCount": "2715", "FavoriteCount": "3", "Title": "How does sizeof know the size of array?", "Id": "27518251", "Score": "14", "Body": "<p>I have codes as following:</p>\n<pre><code>main() {\n    int array[5] = {3,6,9,-8,1};\n    printf(\"the size of the array is %d\\n\", sizeof(array));\n    printf(\"the address of array is %p\\n\", array);\n    printf(\"the address of array is %p\\n\", &amp;array);\n    int * x = array;\n    printf(\"the address of x is %p\\n\", x);\n    printf(\"the size of x is %d\\n\", sizeof(x));\n}\n</code></pre>\n<p>The output is </p>\n<pre><code>the size of the array is 20\nthe address of array is 0x7fff02309560\nthe address of array is 0x7fff02309560\nthe address of x is 0x7fff02309560\nthe size of x is 8\n</code></pre>\n<p>I know the variable <code>array</code> will be seen as a pointer to the first element of the array, so I understand the the size of x is 8. But I don't know why the size of the array is 20. Isn't it should be 8 (in a 64-bits machine)? </p>\n<p>Besides how does the program know that it is 20? As far as I know in C it doesn't store the number of elements. How come the <code>sizeof(array)</code> and <code>sizeof(x)</code> is different? I tracked several posts pertaining to array decaying but no idea on this problem.</p>\n", "Tags": "<c++><c><arrays><pointers>", "OwnerUserId": "2288882", "AnswerCount": "7"}, "27518305": {"ParentId": "27518251", "CommentCount": "0", "Body": "<p>A pointer and an array are 2 different data types.</p>\n<p>Array can hold elements of similar data type. The memory for array is contiguous.</p>\n<p>Pointer is used to point to some valid memory location.</p>\n<p><code>sizeof(type)</code> gives you the number of bytes of the type you pass.</p>\n<p>Now if you pass array then the compiler knows that this is an array and number of elements in it and it just multiplies that many elements with the respective data-type size value.</p>\n<p>In this case:</p>\n<pre><code>5*4 = 20\n</code></pre>\n<p>Again the <code>sizeof(int)</code> or <code>sizeof(pointer)</code> is platform dependent. In this case you are seeing <code>sizeof(pointer)</code> as 8.</p>\n", "OwnerUserId": "3883560", "PostTypeId": "2", "Id": "27518305", "Score": "7", "CreationDate": "2014-12-17T04:23:51.617", "LastActivityDate": "2014-12-17T04:23:51.617"}, "27518372": {"ParentId": "27518251", "CommentCount": "0", "Body": "<p>Note that <code>sizeof</code> is <strong><em>not</em></strong> a library function. <code>sizeof</code> <strong><em>is</em></strong> </p>\n<blockquote>\n<p id=\"so_27518251_27518372_0\">a compile-time unary operator [...] that can be used to compute the\n  size of any object<br> K&amp;R</br></p>\n</blockquote>\n<p>So <code>sizeof</code> doesn't know how big the array is, the compiler knows how big the array is, and by definition</p>\n<blockquote>\n<p id=\"so_27518251_27518372_1\">when applied to an array, the result is the total number of bytes\n  in the array.<br>K&amp;R</br></p>\n</blockquote>\n", "OwnerUserId": "3386109", "PostTypeId": "2", "Id": "27518372", "Score": "9", "CreationDate": "2014-12-17T04:31:50.827", "LastActivityDate": "2014-12-17T04:31:50.827"}, "27518273": {"ParentId": "27518251", "LastEditDate": "2014-12-17T10:55:28.680", "CommentCount": "0", "CreationDate": "2014-12-17T04:19:56.733", "OwnerUserId": "4368797", "LastEditorUserId": "2968265", "PostTypeId": "2", "Id": "27518273", "Score": "14", "Body": "<p>Your array has a static length so it can be determined at compile time. Your compiler knows the <code>sizeof(int) = 4</code> and your static array length [5]. 4 * 5 = 20</p>\n<p>Edit: Your compilers int is probably <strong>32-bit</strong>, but <strong>addressing 64-bit</strong>. That is why <code>sizeof(pointer)</code> returns 8.</p>\n", "LastActivityDate": "2014-12-17T10:55:28.680"}, "27518476": {"ParentId": "27518251", "CommentCount": "0", "Body": "<p>Try this</p>\n<pre><code>int x = sizeof(array)/sizeof(int);\nprintf(\"the size of the array is %d\\n\", x);\n</code></pre>\n", "OwnerUserId": "4156176", "PostTypeId": "2", "Id": "27518476", "Score": "0", "CreationDate": "2014-12-17T04:42:52.743", "LastActivityDate": "2014-12-17T04:42:52.743"}, "27523497": {"ParentId": "27518251", "CommentCount": "0", "Body": "<h3>C11: 6.5.3.4 (p2)</h3>\n<blockquote>\n<p id=\"so_27518251_27523497_0\">The <code>sizeof</code> operator yields the size (in bytes) of its operand, which may be an\n  expression or the parenthesized name of a type. <strong>The size is determined from the type of\n  the operand</strong>. [...]</p>\n</blockquote>\n<p>In the declaration </p>\n<pre><code>int array[5]  \n</code></pre>\n<p>the type of <code>array</code> is an <em>array of 5 <code>int</code>s</em>. The compiler will determine the size of <code>array</code> from this type.  </p>\n", "OwnerUserId": "2455888", "PostTypeId": "2", "Id": "27523497", "Score": "2", "CreationDate": "2014-12-17T10:32:11.783", "LastActivityDate": "2014-12-17T10:32:11.783"}, "bq_ids": {"n4140": {"so_27518251_27518372_1": {"section_id": 6077, "quality": 0.75, "length": 6}}, "n3337": {"so_27518251_27518372_1": {"section_id": 5845, "quality": 0.75, "length": 6}}, "n4659": {"so_27518251_27518372_1": {"section_id": 7573, "quality": 0.75, "length": 6}}}});