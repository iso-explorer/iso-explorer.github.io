post_cb({"30172740": {"ParentId": "30172483", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>You are missing an initializer on <code>iseq</code>. You have to add it:</p>\n<pre><code>constexpr std::integer_sequence&lt;int, 1,2,3,4&gt; iseq{};\n                                                  ^^\n</code></pre>\n<p>From [dcl.constexpr]:</p>\n<blockquote>\n<p id=\"so_30172483_30172740_0\">A <code>constexpr</code> specifier used in an object declaration declares the object as <code>const</code>. Such an object shall have\n  literal type and <strong>shall be initialized</strong>. If it is initialized by a constructor call, that call shall be a constant expression (5.20). Otherwise, or if a <code>constexpr</code> specifier is used in a reference declaration, every fullexpression\n  that appears in its initializer shall be a constant expression. <em>[ Note:</em> Each implicit conversion\n  used in converting the initializer expressions and each constructor call used for the initialization is part of\n  such a full-expression. <em>\u2014end note ]</em><br>\n<em>[ Example:</em></br></p>\n<pre><code>struct pixel {\n    int x, y;\n};\nconstexpr pixel ur = { 1294, 1024 };  // OK\nconstexpr pixel origin;               // error: initializer missing\n</code></pre>\n<p id=\"so_30172483_30172740_1\"><em>\u2014end example ]</em></p>\n</blockquote>\n<p>Moreover, as Columbo suggests in his <a href=\"https://stackoverflow.com/questions/30172483/why-passing-constexpr-object-by-const-reference-works-but-by-value-doesnt-comp/30172740#comment48452097_30172740\">comment</a> and <a href=\"https://stackoverflow.com/a/30172733/2069064\">answer</a>, simply being initialized is insufficent. A user-provided constructor is also required, as per [dcl.init]:</p>\n<blockquote>\n<p id=\"so_30172483_30172740_2\">If a program calls for the default initialization of an object of a const-qualified type <code>T</code>, <code>T</code> shall be a class type\n  with a <strong>user-provided</strong> default constructor.</p>\n</blockquote>\n<p>It's a little odd to have the most relevant section (dcl.constexpr) have an incomplete description of the requirements for a <code>constepxr</code> object declaration. </p>\n", "OwnerUserId": "2069064", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:14:19.033", "Id": "30172740", "Score": "5", "CreationDate": "2015-05-11T16:19:24.697", "LastActivityDate": "2015-05-11T16:48:17.810"}, "30172733": {"ParentId": "30172483", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_30172483_30172733_0\">If a program calls for the default initialization of an object of a\n  const-qualified type <code>T</code>, <code>T</code> shall be a class type with a user-provided\n  default constructor.</p>\n</blockquote>\n<p>However, <code>integer_sequence</code> does not have any user-provided constructors, and <code>constexpr</code> implies <code>const</code> for variables, so you can't define a <code>constexpr</code> object of that type without an initializer.<br>\nAdding an initializer <a href=\"http://coliru.stacked-crooked.com/a/cdb1f333f4e34280\">makes it compile on Clang</a>.</br></p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2015-05-11T16:22:41.480", "Id": "30172733", "Score": "6", "CreationDate": "2015-05-11T16:19:10.143", "LastActivityDate": "2015-05-11T16:22:41.480"}, "30172483": {"CommentCount": "2", "ViewCount": "475", "PostTypeId": "1", "LastEditorUserId": "3093378", "CreationDate": "2015-05-11T16:06:08.643", "LastActivityDate": "2015-05-11T16:48:17.810", "Title": "Why passing constexpr object by const reference works, but by value doesn't compile", "AcceptedAnswerId": "30172740", "LastEditDate": "2015-05-11T16:43:40.753", "Id": "30172483", "Score": "7", "Body": "<p>I have the code below, that basically maps an <code>std::integer_sequence&lt;&gt;</code> into an <code>std::array&lt;&gt;</code> at compile time:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n#include &lt;array&gt;\n\ntemplate&lt;int...Is&gt;\nconstexpr auto make_array(const std::integer_sequence&lt;int, Is...&gt;&amp; param) // this works */\n// constexpr auto make_array(std::integer_sequence&lt;int, Is...&gt; param) // doesn't compile\n{\n    return std::array&lt;int, sizeof...(Is)&gt; {Is...};\n}\n\nint main()\n{\n    constexpr std::integer_sequence&lt;int, 1,2,3,4&gt; iseq;\n\n    // If I pass by value, error: the value of 'iseq' is not usable in a constant expression\n    constexpr auto arr = make_array(iseq);  \n\n    for(auto elem: arr)\n        std::cout &lt;&lt; elem &lt;&lt; \" \";\n}\n</code></pre>\n<p>The code works fine whenever <code>make_array</code> takes its argument by <code>const</code>-reference. Whenever I try passing it by value, like in the commented line, it spits an error:</p>\n<blockquote>\n<p id=\"so_30172483_30172483_0\">error: the value of 'iseq' is not usable in a constant expression</p>\n<pre><code>    constexpr auto arr = make_array(iseq);  \n</code></pre>\n</blockquote>\n<p>Why is this? The parameter <code>iseq</code> is certainly a constant expression, why cannot I pass it to <code>make_array</code>?</p>\n<p>For example, the code below works as expected when passing by value:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n\nstruct Foo\n{\n    int _m;\n    constexpr Foo(int m): _m(m){};\n};\n\nconstexpr Foo factory_foo(int m)\n{\n    return Foo{m};\n}\n\nconstexpr Foo copy_foo(Foo foo)\n{\n    return foo;\n}\n\nint main()\n{\n    constexpr Foo cxfoo = factory_foo(42);\n    constexpr Foo cpfoo = copy_foo(cxfoo);\n}\n</code></pre>\n<p><strong>EDIT</strong></p>\n<p>I'm using g++5.1 from macports. Using clang++ 3.5, I get an error message even for the code that compiles with g++ (with <code>const</code> reference):</p>\n<blockquote>\n<p id=\"so_30172483_30172483_1\">error: default initialization of an object of const type 'const\n        std::integer_sequence' requires a user-provided default\n        constructor</p>\n</blockquote>\n<p>so I guess there is some issue with the lack of a user-provided default constructor, but at this point I don't really understand what's going on.</p>\n", "Tags": "<c++><c++11><c++14><constexpr>", "OwnerUserId": "3093378", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_30172483_30172483_1": {"section_id": 3286, "quality": 0.5833333333333334, "length": 7}, "so_30172483_30172740_0": {"section_id": 5425, "quality": 0.8979591836734694, "length": 44}, "so_30172483_30172740_2": {"section_id": 3286, "quality": 1.0, "length": 11}, "so_30172483_30172733_0": {"section_id": 3286, "quality": 1.0, "length": 11}}, "n3337": {"so_30172483_30172483_1": {"section_id": 3156, "quality": 0.5833333333333334, "length": 7}, "so_30172483_30172740_0": {"section_id": 5220, "quality": 0.8367346938775511, "length": 41}, "so_30172483_30172740_2": {"section_id": 3156, "quality": 1.0, "length": 11}, "so_30172483_30172733_0": {"section_id": 3156, "quality": 1.0, "length": 11}}, "n4659": {"so_30172483_30172740_2": {"section_id": 382, "quality": 0.6363636363636364, "length": 7}, "so_30172483_30172733_0": {"section_id": 382, "quality": 0.6363636363636364, "length": 7}}}});