post_cb({"11369012": {"ParentId": "11240484", "PostTypeId": "2", "CommentCount": "6", "Body": "<p><strong>EDIT 1:</strong> The last drafts of C11 and C++11 are available online here: <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf\" rel=\"noreferrer\">C11 draft N1570</a> and <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"noreferrer\">C++11 draft n3242</a> if you don't have a copy of the final standards and wonderful what they look like. (Other adjustments to text appearance and some wording/grammar edits have been done.)</p>\n<p><strong>EDIT 2:</strong> Fixed all occurrences of \"behaviour\" to be \"behavior\" to match the standard.</p>\n<p>Searching the C++11 and C11 standards there are no matches for <em>indeterminate rule</em> or <em>undefined rule</em>. There are terms like <em>indeterminate value</em>, <em>indeterminately sequenced</em>, <em>indeterminate uninitialized</em>, etc.</p>\n<p>If talk of traps and exceptions seems weird in Norman Gray's answer, know that those terms do reflect the relevant definitions in <strong>Section 3</strong> in the <strong>C11 standard</strong>.</p>\n<p>C++ relies on C's definitions. Many useful definitions concerning types of <em>behaviour</em> can be found in C11's  Section 3 (in C11). For example, <em>indeterminate value</em> is defined in 3.19.2. Do take note that C11's Section 2 (Normative References) provides other sources for additional terminology interpretation and Section 4 defines when cases such as <em>undefined behavior</em> occur as a result of <em>not complying</em> with the standard.</p>\n<p>C11's section 3.4 defines <em>behavior</em>, 3.4.1 defines <em>implementation-defined behavior</em>, 3.4.2 defines <em>locale-specific behavior</em>, 3.4.3 defines <em>undefined behavior</em>, 3.4.4 defines <em>unspecified behavior</em>. For <em>value</em> (Section 3.19), there are <em>implementation-defined value</em>, <em>indeterminate value</em>, and <em>unspecified value</em>.</p>\n<p>Loosely speaking, the term <strong>indeterminate</strong> refers to an <em>unspecified/unknown state</em> that by itself doesn't result in <em>undefined behavior</em>. For example, this C++ code involves an indeterminate value: { int x = x; }. (This is actually an example in the C++11 standard.) Here x is defined to be an integer first but at that point it does not have a well-defined value --then it is initialized to whatever (indeterminate/unknown) value it has!</p>\n<p>The well-known term <strong>undefined behavior</strong> is defined in 3.4.3 in C11 and refers to any situation of a </p>\n<blockquote>\n<p id=\"so_11240484_11369012_0\">nonportable or erroneous program construct or of erroneous data, for which this International Standard imposes no requirements</p>\n</blockquote>\n<p>In other words <em>undefined behavior</em> is some error (in logic or state) and whatever happens next is unknown! So one could make an <strong>undefined [behavior] rule</strong> that states: avoid undefined behavior when writing C/C++ code! :-)</p>\n<p>An <strong>indeterminate [behavior] rule</strong> would be to state: avoid writing indeterminate code <em>unless</em> it is needed <em>and</em> it does not affect program correctness or portability. So unlike undefined behavior, indeterminate behavior <em>does not necessarily</em> imply that code/data is erroneous, however, <em>its subsequent use may or may not be erroneous</em> --so care is required to ensure program correctness is maintained.</p>\n<p>Other terms like <em>indeterminately sequenced</em> are in the body text (e.g., C11 5.1.2.3 para 3; C++11, section 1.9 para. 13; i.e., in [intro.executation]). (As you might guess, it refers an unspecified order of operational steps.)</p>\n<p>IMO if one is interested in all of these nuances, acquiring both the C++11 and C11 standards is a must. This will permit one to explore to the desired level-of-detail needed with definitions, etc. If you don't have such the links provided herein will help you explore such with the last published draft C11 and C++11 standards.</p>\n", "OwnerUserId": "1507666", "LastEditorUserId": "1507666", "LastEditDate": "2012-07-08T19:38:11.140", "Id": "11369012", "Score": "7", "CreationDate": "2012-07-06T20:09:17.520", "LastActivityDate": "2012-07-08T19:38:11.140"}, "11241238": {"ParentId": "11240484", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The following remarks are based on the C standard, <a href=\"http://www.iso-9899.info/wiki/The_Standard\" rel=\"nofollow\">ISO-9899</a>, rather than the C++ one, but the meanings are fundamentally the same (see sections 3.4 and 4 of the C standard; see also the C++ standard, <a href=\"http://www.open-std.org/Jtc1/sc22/wg21/\" rel=\"nofollow\">ISO-14882</a>, section 1.3; the latter document doesn't define 'unspecified value' as such, but does use that phrase later with the obvious meaning).  The official standards documents are not free (indeed, they are expensive), but the links above are to the committee pages, and include free 'drafts' of the standard, which you can take to be essentially equivalent to the finalised standard text.</p>\n<p>The terms describe a ladder of vagueness.</p>\n<p>So, heading downwards....</p>\n<p>Most of the time, the standard defines what should happen in a particular case: if you write <code>c=a+b</code> and <code>a</code> and <code>b</code> are <code>int</code>, then <code>c</code> is their sum (modulo some details).  This, of course, is the point of a standard.</p>\n<p><em>Implementation-defined behaviour</em> is where the standard lists two or more things which are allowed to happen in a particular case; it doesn't prescribe which one is preferred, but <em>does</em> demand that the implementation (the actual compiler which parses the C) makes a choice between the alternatives, does that same thing consistently, and that the implementation <em>must document the choice it makes</em>.  For example, whether a single file can be opened by multiple processes is implementation-defined.</p>\n<p><em>Unspecified behaviour</em> is where the standard lists a couple of alternatives, each of which is therefore conformant with the standard, but goes no further.  An implementation must choose one of the alternatives to pick in a particular case, but doesn't have to do the same thing each time, and doesn't have to commit itself in documentation to which choice it will make.  For example, the padding bits in a <code>struct</code> are unspecified.</p>\n<p><em>Undefined behaviour</em> is the most extreme case.  Here, all bets are off.  If the compiler, or the program it generates, runs into <em>undefined behaviour</em>, it can do anything: it can scramble memory, corrupt the stack, <a href=\"https://en.wikipedia.org/wiki/Halt_and_Catch_Fire\" rel=\"nofollow\">HCF</a> or, in the standard extreme case, cause demons to fly out of your nose.  But mostly it'll just crash.  And all of these behaviours are conformant with the standard.  For example, if a variable is declared both <code>static int i;</code> and <code>int i;</code> in the same scope, or if you write <code>#include &lt;'my file'.h&gt;</code>, the effect is undefined.</p>\n<p>There are analogous definitions for 'value'.  </p>\n<p>An <em>unspecified value</em> is a valid value, but the standard doesn't say what it is.  Thus the standard might say that a given function returns an unspecified value.  You can store that value and look at it if you want to, without causing an error, but it doesn't mean anything, and the function might return a different value next time, depending on the phase of the moon.</p>\n<p>An <em>implementation-defined value</em> is like implementation-defined behaviour.  Like <em>unspecified</em>, it's a valid value, but the implementation's documentation has to commit itself on what will be returned, and do the same thing each time.</p>\n<p>An <em>indeterminate value</em> even more unspecified than <em>unspecified</em>.  It's either an unspecified value or a <em>trap representation</em>. A trap representation is standards-speak for some magic value which, if you try to assign it to anything, results in undefined behaviour.  This wouldn't have to be an actual value; probably the best way to think about it is \"if C had exceptions, a trap representation would be an exception\".  For example, if you declare <code>int i;</code> in a block, without an initialisation, the initial value of the variable <code>i</code> is <em>indeterminate</em>, meaning that if you try to assign this to something else before initialising it, the behaviour is undefined, and the compiler is entitled to try the said demons-out-of-nose trick.  Of course, in most cases, the compiler will do something less dramatic/fun, like initialise it to 0 or some other random valid value, but no matter what it does, you're not entitled to object.</p>\n<p>The point of all this imprecision is to give maximal freedom to compiler writers.  That's nice for compiler writers (and is one of the reasons it's reasonably easy to get a C compiler running on such a huge range of platforms), but it does make things rather more interesting than fun for the poor users.</p>\n<p><strong>Edit 1</strong>: to clarify indeterminate values.</p>\n<p><strong>Edit 2</strong>: to include a link to the C++ standard, and note that the committee drafts are essentially equivalent to the final standard, but free.</p>\n", "OwnerUserId": "375147", "LastEditorUserId": "375147", "LastEditDate": "2014-06-18T09:32:32.130", "Id": "11241238", "Score": "36", "CreationDate": "2012-06-28T09:00:18.133", "LastActivityDate": "2014-06-18T09:32:32.130"}, "11240631": {"ParentId": "11240484", "CommentCount": "11", "Body": "<p>I think the standard mentions undefined <em>behaviour</em> and indeterminate <em>value</em>. So one is about the behaviour and another about values. </p>\n<p>These two are somewhat orthogonal, for example, the behaviour can still be well defined in the presence of indeterminate values. </p>\n", "OwnerUserId": "412080", "PostTypeId": "2", "Id": "11240631", "Score": "8", "CreationDate": "2012-06-28T08:18:24.753", "LastActivityDate": "2012-06-28T08:18:24.753"}, "11240484": {"CommentCount": "7", "AcceptedAnswerId": "11369012", "PostTypeId": "1", "LastEditorUserId": "584518", "CreationDate": "2012-06-28T08:07:17.267", "LastActivityDate": "2015-02-05T13:40:29.587", "LastEditDate": "2015-02-05T13:40:29.587", "ViewCount": "2486", "FavoriteCount": "4", "Title": "What is indeterminate behavior in C++ ? How is it different from undefined behavior?", "Id": "11240484", "Score": "22", "Body": "<p>What is the difference between an <strong>indeterminate</strong> behaviour and an <strong>undefined</strong> behaviour in C++? Is this classification valid for C codes also?</p>\n", "Tags": "<c++><c>", "OwnerUserId": "668279", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_11240484_11369012_0": {"section_id": 5768, "quality": 0.5555555555555556, "length": 5}}, "n3337": {"so_11240484_11369012_0": {"section_id": 5541, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_11240484_11369012_0": {"section_id": 7225, "quality": 0.5555555555555556, "length": 5}}}});