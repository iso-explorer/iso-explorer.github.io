post_cb({"bq_ids": {"n4140": {"so_7820981_7820981_0": {"length": 13, "quality": 1.0, "section_id": 6342}, "so_7820981_7820981_1": {"length": 21, "quality": 1.0, "section_id": 6342}}, "n3337": {"so_7820981_7820981_0": {"length": 13, "quality": 1.0, "section_id": 6099}, "so_7820981_7820981_1": {"length": 21, "quality": 1.0, "section_id": 6099}}, "n4659": {"so_7820981_7820981_0": {"length": 9, "quality": 0.6923076923076923, "section_id": 7851}, "so_7820981_7820981_1": {"length": 16, "quality": 0.7619047619047619, "section_id": 7847}}}, "7820981": {"ViewCount": "500", "Body": "<p><code>std::forward_list</code> provides <code>insert_after</code> and <code>erase_after</code> members which may not need to actually access the <code>std::forward_list</code> object. Therefore they can be implemented as <code>static</code> member functions and be called without a list object \u2014 useful for an object that wants to delete itself from a list, which is a very common use. <strong>EDIT</strong>: This optimization only applies to <code>forward_list</code> specializations on <code>std::allocator</code> or user-defined stateless allocators.</p>\n<p>Can a standard-conforming implementation do this?</p>\n<p>\u00a717.6.5.5/3 says</p>\n<blockquote>\n<p id=\"so_7820981_7820981_0\">A call to a member function signature described in the C++ standard library behaves as if the implementation\n  declares no additional member function signatures.</p>\n</blockquote>\n<p>with a footnote</p>\n<blockquote>\n<p id=\"so_7820981_7820981_1\">A valid C++ program always calls the expected library member function, or one with equivalent behavior. An implementation may also define additional member functions that would otherwise not be called by a valid C++ program.</p>\n</blockquote>\n<p>It's not clear to me whether adding <code>static</code> would create a \"different\" member function, but removing an (implicit) argument shouldn't break anything that adding defaulted arguments wouldn't, and that is legal. (You cannot legally take a PTMF to any standard member function.)</p>\n<p>It strikes me that the library should be allowed to do this, but I'm not sure if some rule would be broken. And how normative are the listed member function prototypes?</p>\n", "AcceptedAnswerId": "7824998", "Title": "Can std::forward_list members be implemented as static?", "CreationDate": "2011-10-19T12:01:49.820", "Id": "7820981", "CommentCount": "6", "LastEditDate": "2011-10-19T13:12:38.530", "PostTypeId": "1", "LastEditorUserId": "153285", "LastActivityDate": "2011-10-23T15:01:14.227", "Score": "9", "OwnerUserId": "153285", "Tags": "<c++><c++11><c++-standard-library>", "AnswerCount": "1"}, "7824998": {"Id": "7824998", "PostTypeId": "2", "Body": "<p>The standard says you can get away with it if no one can tell the difference.  And you are correct that one can not legally create a PTMF into <code>forward_list</code>, so you're safe that way.</p>\n<p>The danger of custom allocators has already been pointed out.  But even for <code>std::allocator&lt;T&gt;</code> there is a danger that someone could specialize <code>std::allocator&lt;MyType&gt;</code> and then detect that the <code>allocator::construct/destroy</code> wasn't being called.</p>\n<p>Okay, but can one specialize say <code>std::forward_list&lt;int&gt;</code> (no custom allocator, no user defined value_type) and make <code>insert_after</code> static?</p>\n<p>No.  This change would be detectable with the new SFINAE capabilities.  Here is a demo:</p>\n<pre><code>#include &lt;memory&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt;class T, class A = std::allocator&lt;T&gt;&gt;\nclass forward_list\n{\npublic:\n    typedef T value_type;\n    struct const_iterator {};\n    struct iterator {};\n\n    iterator insert_after(const_iterator p, const T&amp; x);\n};\n\ntemplate &lt;class C&gt;\nauto test(C&amp; c, typename C::const_iterator p, const typename C::value_type&amp; x)\n    -&gt; decltype(C::insert_after(p, x))\n{\n    std::cout &lt;&lt; \"static\\n\";\n    return typename C::iterator();\n}\n\ntemplate &lt;class C&gt;\nauto test(C&amp; c, typename C::const_iterator p, const typename C::value_type&amp; x)\n    -&gt; decltype(c.insert_after(p, x))\n{\n    std::cout &lt;&lt; \"not static\\n\";\n    return typename C::iterator();\n}\n\nint main()\n{\n    ::forward_list&lt;int&gt; c;\n    test(c, ::forward_list&lt;int&gt;::const_iterator(), 0);\n}\n</code></pre>\n<p>This program runs and prints out:</p>\n<pre><code>not static\n</code></pre>\n<p>But if I make <code>insert_after</code> static:</p>\n<pre><code>static iterator insert_after(const_iterator p, const T&amp; x);\n</code></pre>\n<p>Then I get a compile time error:</p>\n<pre><code>test.cpp:34:5: error: call to 'test' is ambiguous\n    test(c, ::forward_list&lt;int&gt;::const_iterator(), 0);\n    ^~~~\ntest.cpp:16:6: note: candidate function [with C = forward_list&lt;int, std::__1::allocator&lt;int&gt; &gt;]\nauto test(C&amp; c, typename C::const_iterator p, const typename C::value_type&amp; x)\n     ^\ntest.cpp:24:6: note: candidate function [with C = forward_list&lt;int, std::__1::allocator&lt;int&gt; &gt;]\nauto test(C&amp; c, typename C::const_iterator p, const typename C::value_type&amp; x)\n     ^\n1 error generated.\n</code></pre>\n<p><strong>Difference detected.</strong></p>\n<p>Thus it is non-conforming to make <code>forward_list::insert_after</code> static.</p>\n<p><strong>Update</strong></p>\n<p>If you want to make the \"static\" overload callable, you simply need to make it slightly more desirable than the \"not static\" overload.  One way of doing that is changing the \"not static\" overload to:</p>\n<pre><code>template &lt;class C, class ...Args&gt;\nauto test(C&amp; c, typename C::const_iterator p, const typename C::value_type&amp; x, Args...)\n    -&gt; decltype(c.insert_after(p, x))\n{\n    std::cout &lt;&lt; \"not static\\n\";\n    return typename C::iterator();\n}\n</code></pre>\n<p>Now the test will print out either \"static\" or \"not static\" depending on whether the <code>insert_after</code> member function is static or not.</p>\n", "LastEditorUserId": "576911", "LastActivityDate": "2011-10-23T15:01:14.227", "Score": "9", "CreationDate": "2011-10-19T16:51:56.330", "ParentId": "7820981", "CommentCount": "4", "LastEditDate": "2011-10-23T15:01:14.227", "OwnerUserId": "576911"}});