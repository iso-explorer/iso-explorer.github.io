post_cb({"8481997": {"CommentCount": "0", "AcceptedAnswerId": "8482018", "PostTypeId": "1", "LastEditorUserId": "722294", "CreationDate": "2011-12-12T22:44:55.773", "LastActivityDate": "2011-12-13T07:03:16.643", "LastEditDate": "2011-12-13T07:03:16.643", "ViewCount": "732", "FavoriteCount": "1", "Title": "How to detect whether a type is a lambda expression at compile time?", "Id": "8481997", "Score": "5", "Body": "<p>Suppose I have a type <code>my_struct</code> enclosing a member variable, <code>f</code>, which is a function. It's possible for <code>f</code> to be a c++11 lambda function.</p>\n<p>Since it is illegal to assign to lambda objects, I'd like to implement <code>my_struct</code>'s assignment operator in such a way that when <code>f</code> is a lambda, it is not assigned.</p>\n<p>Is it possible to build a type trait <code>is_lambda</code> which can inspect a type for lambda-ness?</p>\n<p>In code:</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt;typename Function&gt; struct is_lambda\n{\n  // what goes here?\n};\n\ntemplate&lt;typename Function&gt; struct my_struct\n{\n  Function f;\n\n  my_struct &amp;do_assign(const my_struct &amp;other, std::true_type)\n  {\n    // don't assign to f\n    return *this;\n  }\n\n  my_struct &amp;do_assign(const my_struct &amp;other, std::false_type)\n  {\n    // do assign to f\n    f = other.f;\n    return *this;\n  }\n\n  my_struct &amp;operator=(const my_struct &amp;other)\n  {\n    return do_assign(other, typename is_lambda&lt;Function&gt;::type());\n  }\n};\n</code></pre>\n", "Tags": "<c++><lambda><template-meta-programming>", "OwnerUserId": "722294", "AnswerCount": "2"}, "8482086": {"ParentId": "8481997", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Presumably you don't want to assign non-assignable non-lambda functions either, so you could use <code>std::is_assignable</code>.</p>\n", "OwnerUserId": "743382", "LastEditorUserId": "500104", "LastEditDate": "2011-12-12T23:05:56.340", "Id": "8482086", "Score": "4", "CreationDate": "2011-12-12T22:51:35.920", "LastActivityDate": "2011-12-12T23:05:56.340"}, "bq_ids": {"n4140": {"so_8481997_8482018_0": {"section_id": 5962, "quality": 0.9166666666666666, "length": 11}}, "n3337": {"so_8481997_8482018_0": {"section_id": 5731, "quality": 0.9166666666666666, "length": 11}}, "n4659": {"so_8481997_8482018_0": {"section_id": 7451, "quality": 0.9166666666666666, "length": 11}}}, "8482018": {"ParentId": "8481997", "CommentCount": "0", "Body": "<p>Impossible without compiler support, as the type of a lambda is just a normal, non-union class type.</p>\n<p><code>\u00a75.1.2 [expr.prim.lambda] p3</code></p>\n<blockquote>\n<p id=\"so_8481997_8482018_0\">The type of the <em>lambda-expression</em> (which is also the type of the closure object) is a unique, unnamed nonunion class type [...]</p>\n</blockquote>\n", "OwnerUserId": "500104", "PostTypeId": "2", "Id": "8482018", "Score": "7", "CreationDate": "2011-12-12T22:46:22.170", "LastActivityDate": "2011-12-12T22:46:22.170"}});