post_cb({"35287487": {"ParentId": "35287049", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>You're mistaken. <code>std::set::find</code> does a lookup in a binary search tree (in a typical implementation). That might seem like binary search algorithm, but the algorithms in 25.4.3 are not typically used for the lookup. A tree supports only non-random-access iterators and binary search with linear iterators is much slower than a lookup using the knowledge that the data is in a BST.</p>\n<p>The comparator of <a href=\"http://en.cppreference.com/w/cpp/container/set/set\" rel=\"nofollow\"><code>std::set</code></a> must comply to the <a href=\"http://en.cppreference.com/w/cpp/concept/Compare\" rel=\"nofollow\">Compare</a> concept, which does require <a href=\"https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings\" rel=\"nofollow\">strict weak ordering</a>.</p>\n<blockquote>\n<p id=\"so_35287049_35287487_0\">Is this valid in C++ if I never insert elements that have a wildcard value, and only ever look them up in the set?</p>\n</blockquote>\n<p>Technically no, since you're breaking the requirements. At the very least you will have indeterminate results, when looking up <code>{x, 0}</code> from a set that contains <code>{x, a}</code> and <code>{x, b}</code>. Either could be found. If that doesn't matter, then I doubt a typical implementation would pose trouble. What you're doing is not guaranteed to work by the standard though, which is enough for most people to shy away from it.</p>\n", "OwnerUserId": "2079303", "LastEditorUserId": "2079303", "LastEditDate": "2016-02-09T09:08:20.560", "Id": "35287487", "Score": "1", "CreationDate": "2016-02-09T08:48:11.380", "LastActivityDate": "2016-02-09T09:08:20.560"}, "bq_ids": {"n4140": {"so_35287049_35287049_1": {"section_id": 1395, "quality": 0.8666666666666667, "length": 13}}, "n3337": {"so_35287049_35287049_1": {"section_id": 1389, "quality": 0.8666666666666667, "length": 13}}, "n4659": {"so_35287049_35287049_1": {"section_id": 1513, "quality": 0.7333333333333333, "length": 11}}}, "35287049": {"CommentCount": "0", "ViewCount": "101", "CreationDate": "2016-02-09T08:21:42.567", "LastActivityDate": "2016-02-09T09:08:20.560", "Title": "Strict Weak Ordering and std::set / std::map", "PostTypeId": "1", "Id": "35287049", "Score": "0", "Body": "<pre><code>#include &lt;iostream&gt;\n#include &lt;set&gt;\n#include &lt;tuple&gt;\n\nstruct Key {\n  int field1;\n  int field2;\n\n  Key(int field1, int field2) : field1(field1), field2(field2) {}\n\n  bool operator&lt;(const Key&amp; other) const {\n    // Is this acceptable?! Seems to work\n    if (field2 == 0 || other.field2 == 0) {\n      return field1 &lt; other.field1;\n    } else {\n      return std::tie(field1, field2) &lt; std::tie(other.field1, other.field2);\n    }\n  }\n};\n\nint main() {\n    std::set&lt;Key&gt; values{Key(4,3), Key(5,9), Key(5,7), Key(5,8), Key(6,1)};\n    std::cout &lt;&lt; values.find(Key(5,0))-&gt;field2 &lt;&lt; std::endl; // Prints '7'\n    auto range = values.equal_range(Key(5,0));\n    for (auto i = range.first; i != range.second; i++) {\n        std::cout &lt;&lt; i-&gt;field2; // Prints '789'\n    }\n    return 0;\n}\n</code></pre>\n<p>Field2 is not always available in my data, so sometimes I use a wildcard value of 0, which can match any value for which field1 matches. Is this valid in C++ if I never insert elements that have a wildcard value, and only ever look them up in the set? I'm okay with the find function returning any of the values in this case which happens rarely in my code, though hopefully it would be the same value when called repeatedly.</p>\n<p>According to the <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/papers/2015/n4567.pdf\" rel=\"nofollow\">specification</a>, it seems like strict weak ordering is not required for binary_search, which should be the only algorithm used on the data structure when performing a lookup, right? Or is there some undefined behavior I should worry about here?</p>\n<blockquote>\n<p id=\"so_35287049_35287049_0\">25.4 Sorting and related operations</p>\n<p id=\"so_35287049_35287049_1\">... For algorithms other than those described in 25.4.3 to work\n  correctly, comp has to induce a strict weak ordering on the values...</p>\n<p id=\"so_35287049_35287049_2\">25.4.3 Binary search</p>\n</blockquote>\n", "Tags": "<c++><strict-weak-ordering>", "OwnerUserId": "1762181", "AnswerCount": "1"}});