post_cb({"23053731": {"Id": "23053731", "PostTypeId": "2", "Body": "<p>One potentially dangerous backward-incompatible change is in constructors of sequence containers such as <code>std::vector</code>, specifically in the overload specifying initial size. Where in C++03, they copied a default-constructed element, in C++11 they default-construct each one.</p>\n<p>Consider this example (using <code>boost::shared_ptr</code> so that it's valid C++03):</p>\n<pre><code>#include &lt;deque&gt;\n#include &lt;iostream&gt;\n\n#include \"boost/shared_ptr.hpp\"\n\n\nstruct Widget\n{\n  boost::shared_ptr&lt;int&gt; p;\n\n  Widget() : p(new int(42)) {}\n};\n\n\nint main()\n{\n  std::deque&lt;Widget&gt; d(10);\n  for (size_t i = 0; i &lt; d.size(); ++i)\n    std::cout &lt;&lt; \"d[\" &lt;&lt; i &lt;&lt; \"] : \" &lt;&lt; d[i].p.use_count() &lt;&lt; '\\n';\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/426fb7a77f020e4b\">C++03 Live example</a></p>\n<p><a href=\"http://coliru.stacked-crooked.com/a/201f0609fec61325\">C++11 Live example</a></p>\n<p>The reason is that C++03 specified one overload for both \"specify size and prototype element\" and \"specify size only,\" like this (allocator arguments omitted for brevity):</p>\n<pre><code>container(size_type size, const value_type &amp;prototype = value_type());\n</code></pre>\n<p>This will always copy <code>prototype</code> into the container <code>size</code> times. When called with just one argument, it will therefore create <code>size</code> copies of a default-constructed element.</p>\n<p>In C++11, this constructor signature was removed and replaced with these two overloads:</p>\n<pre><code>container(size_type size);\n\ncontainer(size_type size, const value_type &amp;prototype);\n</code></pre>\n<p>The second one works as before, creating <code>size</code> copies of the <code>prototype</code> element. However, the first one (which now handles calls with only the size argument specified) default-constructs each element individually.</p>\n<p>My guess for the reason of this change is that the C++03 overload wouldn't be usable with a move-only element type. But it's a breaking change none the less, and one seldom documented at that.</p>\n", "LastEditorUserId": "1782465", "LastActivityDate": "2014-04-14T06:58:14.430", "Score": "35", "CreationDate": "2014-04-14T06:52:46.087", "ParentId": "23047198", "CommentCount": "1", "LastEditDate": "2014-04-14T06:58:14.430", "OwnerUserId": "1782465"}, "23047198": {"ViewCount": "14854", "Body": "<p>Is it possible for C++ code to conform to both the <a href=\"http://en.wikipedia.org/wiki/C++03\">C++03</a> standard and the <a href=\"http://en.wikipedia.org/wiki/C++11\">C++11</a> standard, but do different things depending on under which standard it is being compiled?</p>\n", "AcceptedAnswerId": "23048287", "Title": "Can C++ code be valid in both C++03 and C++11 but do different things?", "CreationDate": "2014-04-13T19:12:39.627", "Id": "23047198", "CommentCount": "20", "FavoriteCount": "95", "PostTypeId": "1", "LastEditDate": "2014-04-17T20:02:22.587", "LastEditorUserId": "1782465", "LastActivityDate": "2014-07-01T19:28:51.813", "Score": "289", "OwnerUserId": "757777", "Tags": "<c++><c++11><language-lawyer><c++03>", "AnswerCount": "7"}, "23048287": {"Body": "<p>The answer is a definite yes. On the plus side there is:</p>\n<ul>\n<li>Code that previously implicitly copied objects will now implicitly move them when possible.</li>\n</ul>\n<p>On the negative side, several examples are listed in the appendix C of the standard. Even though there are many more negative ones than positive, each one of them is much less likely to occur.</p>\n<p><strong>String literals</strong></p>\n<pre><code>#define u8 \"abc\"\nconst char* s = u8\"def\"; // Previously \"abcdef\", now \"def\"\n</code></pre>\n<p>and</p>\n<pre><code>#define _x \"there\"\n\"hello \"_x // Previously \"hello there\", now a user defined string literal\n</code></pre>\n<p><strong>Type conversions of 0</strong></p>\n<p>In C++11, only literals are integer null pointer constants:</p>\n<pre><code>void f(void *); // #1\nvoid f(...); // #2\ntemplate&lt;int N&gt; void g() {\n    f(0*N); // Calls #2; used to call #1\n}\n</code></pre>\n<p><strong>Rounded results after integer division and modulo</strong></p>\n<p>In C++03 the compiler was allowed to either round towards 0 or towards negative infinity. In C++11 it is mandatory to round towards 0</p>\n<pre><code>int i = (-1) / 2; // Might have been -1 in C++03, is now ensured to be 0\n</code></pre>\n<p><strong>Whitespaces between nested template closing braces &gt;&gt; vs &gt; &gt;</strong></p>\n<p>Inside an specialization or instantiation the <code>&gt;&gt;</code> might instead be interpreted as an right-shift in C++03. This is more likely to break existing code though: (from <a href=\"http://gustedt.wordpress.com/2013/12/15/a-disimprovement-observed-from-the-outside-right-angle-brackets/\" rel=\"noreferrer\">http://gustedt.wordpress.com/2013/12/15/a-disimprovement-observed-from-the-outside-right-angle-brackets/</a>)</p>\n<pre><code>template&lt; unsigned len &gt; unsigned int fun(unsigned int x);\ntypedef unsigned int (*fun_t)(unsigned int);\ntemplate&lt; fun_t f &gt; unsigned int fon(unsigned int x);\n\nvoid total(void) {\n    // fon&lt;fun&lt;9&gt; &gt;(1) &gt;&gt; 2 in both standards\n    unsigned int A = fon&lt; fun&lt; 9 &gt; &gt;(1) &gt;&gt;(2);\n    // fon&lt;fun&lt;4&gt; &gt;(2) in C++03\n    // Compile time error in C++11\n    unsigned int B = fon&lt; fun&lt; 9 &gt;&gt;(1) &gt; &gt;(2);\n}\n</code></pre>\n<p><strong>Operator <code>new</code> may now throw other exceptions than <code>std::bad_alloc</code></strong></p>\n<pre><code>struct foo { void *operator new(size_t x){ throw std::exception(); } }\ntry {\n    foo *f = new foo();\ncatch (std::bad_alloc &amp;) {\n    // c++03 code\n} catch (std::exception &amp;) {\n    // c++11 code\n}\n</code></pre>\n<p><strong>User-declared destructors have an implicit exception specification</strong>\nexample from <a href=\"https://stackoverflow.com/questions/6399615/what-breaking-changes-are-introduced-in-c11\">What breaking changes are introduced in C++11?</a></p>\n<pre><code>struct A {\n    ~A() { throw \"foo\"; } // Calls std::terminate in C++11\n};\n//...\ntry { \n    A a; \n} catch(...) { \n    // C++03 will catch the exception\n} \n</code></pre>\n<p><strong><code>size()</code> of containers is now required to run in O(1)</strong></p>\n<pre><code>std::list&lt;double&gt; list;\n// ...\nsize_t s = list.size(); // Might be an O(n) operation in C++03\n</code></pre>\n<p><strong><code>std::ios_base::failure</code> does not derive from <code>std::exception</code> anymore</strong></p>\n<p>Code that expects it to derive directly from <code>std::exception</code> might behave differently.</p>\n", "CreationDate": "2014-04-13T20:49:14.850", "ParentId": "23047198", "CommentCount": "6", "LastEditDate": "2017-05-23T12:31:56.080", "Id": "23048287", "PostTypeId": "2", "LastActivityDate": "2014-04-18T18:28:06.793", "LastEditorUserId": "-1", "CommunityOwnedDate": "2014-04-13T20:58:52.263", "Score": "271", "OwnerUserId": "1365260"}, "23055151": {"Id": "23055151", "PostTypeId": "2", "Body": "<p>The result of a failed read from an <code>std::istream</code> has changed.  <a href=\"http://en.cppreference.com/w/cpp/io/basic%5fistream/operator%5fgtgt\">CppReference</a> summarizes it nicely:</p>\n<blockquote>\n<p id=\"so_23047198_23055151_0\">If extraction fails (e.g. if a letter was entered where a digit is expected), <code>value</code> is left unmodified and <code>failbit</code> is set. <strong>(until C++11)</strong></p>\n<p id=\"so_23047198_23055151_1\">If extraction fails, zero is written to <code>value</code> and <code>failbit</code> is set. If extraction results in the value too large or too small to fit in <code>value</code>, <code>std::numeric_limits&lt;T&gt;::max()</code> or <code>std::numeric_limits&lt;T&gt;::min()</code> is written and <code>failbit</code> flag is set. <strong>(since C++11)</strong></p>\n</blockquote>\n<p>This is primarily an issue if you are used to the new semantics and then have to write using C++03.  The following is not particularly good practice but well-defined in C++11:</p>\n<pre><code>int x, y;\nstd::cin &gt;&gt; x &gt;&gt; y;\nstd::cout &lt;&lt; x + y;\n</code></pre>\n<p>However, in C++03, the above code uses an uninitialized variable and thus has undefined behaviour.</p>\n", "LastActivityDate": "2014-04-14T08:15:00.087", "Score": "18", "CreationDate": "2014-04-14T08:15:00.087", "ParentId": "23047198", "CommentCount": "1", "OwnerUserId": "559931"}, "23103018": {"Id": "23103018", "PostTypeId": "2", "Body": "<p>Here's another example:</p>\n<pre><code>#include &lt;iostream&gt;\n\ntemplate&lt;class T&gt;\nstruct has {\n  typedef char yes;\n  typedef yes (&amp;no)[2];    \n  template&lt;int&gt; struct foo;    \n  template&lt;class U&gt; static yes test(foo&lt;U::bar&gt;*);      \n  template&lt;class U&gt; static no  test(...);    \n  static bool const value = sizeof(test&lt;T&gt;(0)) == sizeof(yes);\n};\n\nenum foo { bar };\n\nint main()\n{\n    std::cout &lt;&lt; (has&lt;foo&gt;::value ? \"yes\" : \"no\") &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Prints:</p>\n<pre><code>Using c++03: no\nUsing c++11: yes\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/760c5a986815c70c\">See the result on Coliru</a></p>\n", "LastActivityDate": "2014-04-16T07:41:59.783", "Score": "6", "CreationDate": "2014-04-16T07:41:59.783", "ParentId": "23047198", "CommentCount": "0", "OwnerUserId": "75889"}, "bq_ids": {"n4140": {"so_23047198_23063914_2": {"length": 21, "quality": 0.875, "section_id": 3325}, "so_23047198_23063914_1": {"length": 6, "quality": 1.0, "section_id": 3325}}, "n3337": {"so_23047198_23063914_2": {"length": 21, "quality": 0.875, "section_id": 3195}, "so_23047198_23063914_1": {"length": 6, "quality": 1.0, "section_id": 3195}}, "n4659": {"so_23047198_23063914_2": {"length": 21, "quality": 0.875, "section_id": 4091}, "so_23047198_23063914_1": {"length": 6, "quality": 1.0, "section_id": 4091}}}, "23063914": {"Id": "23063914", "PostTypeId": "2", "Body": "<p>Yes, there are number of changes that will cause the same code to result in different behavior between C++03 and C++11. The sequencing rules differences make for some interesting changes including some previously undefined behavior becoming well defined.</p>\n<p><b>1. multiple mutations of the same variable within an initializer list</b></p>\n<p>One very interesting corner case would multiple mutations of the same variable within an initializer list, for example:</p>\n<pre><code>int main()\n{\n    int count = 0 ;\n    int arrInt[2] = { count++, count++ } ;\n\n    return 0 ;\n}\n</code></pre>\n<p>In both C++03 and C++11 this is well defined but the <a href=\"https://stackoverflow.com/questions/19881803/are-multiple-mutations-of-the-same-variable-within-initializer-lists-undefined-b\">order of evaluation in C++03 is unspecified</a> but in <a href=\"https://stackoverflow.com/questions/14442894/are-multiple-mutations-within-initializer-lists-undefined-behavior\">C++11 they are evaluated in the order in which they appear</a>. So if we compile using <code>clang</code> in C++03 mode it provide the following warning (<em><a href=\"http://coliru.stacked-crooked.com/a/906eb652c8852d7a\" rel=\"nofollow noreferrer\">see it live</a></em>):</p>\n<pre><code>warning: multiple unsequenced modifications to 'count' [-Wunsequenced]\n\n    int arrInt[2] = { count++, count++ } ;\n\n                           ^        ~~\n</code></pre>\n<p>but does not provide a warning in C++11 (<em><a href=\"http://coliru.stacked-crooked.com/a/f64b518da84ecc4e\" rel=\"nofollow noreferrer\">see it live</a></em>).</p>\n<p><b>2. New sequencing rules make i = ++ i + 1; well defined in C++11 </b></p>\n<p>The new sequencing rules adopted after C++03 means that:</p>\n<pre><code>int i = 0 ;\ni = ++ i + 1;\n</code></pre>\n<p>is no longer undefined behavior in C++11, this is covered in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#637\" rel=\"nofollow noreferrer\">defect report 637. Sequencing rules and example disagree </a></p>\n<p><b>3. New sequencing rules also make ++++i ; well defined in C++11 </b></p>\n<p>The new sequencing rules adopted after C++03 means that:</p>\n<pre><code>int i = 0 ;\n++++i ;\n</code></pre>\n<p>is no longer undefined behavior in C++11.</p>\n<p><b>4. Slightly More Sensible Signed Left-Shifts</b></p>\n<p>Later drafts of C++11 include <code>N3485</code> which I link below <a href=\"http://blog.regehr.org/archives/738\" rel=\"nofollow noreferrer\">fixed the undefined behavior of shifting a 1 bit into or past the sign bit</a>. This is also covered in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3367.html#1457\" rel=\"nofollow noreferrer\">defect report 1457</a>. Howard Hinnant commented on the significance of this change in the thread on <a href=\"https://stackoverflow.com/questions/19593938/is-left-shifting-a-negative-integer-undefined-behavior-in-c11#comment29091986_19593938\">Is left-shifting (&lt;&lt;) a negative integer undefined behavior in C++11?</a>. </p>\n<p><b>5. constexpr functions can be treated as compile time constant expressions in C++11</b></p>\n<p>C++11 introduced <a href=\"http://en.cppreference.com/w/cpp/language/constexpr\" rel=\"nofollow noreferrer\">constexpr</a> functions which:</p>\n<blockquote>\n<p id=\"so_23047198_23063914_0\">The constexpr specifier declares that it is possible to evaluate the value of the function or variable at compile time. Such variables and functions can then be used where only compile time constant expressions are allowed. </p>\n</blockquote>\n<p>while C++03 does not have the <em>constexpr</em> feature we don't have to explicitly use the <em>constexpr</em> keyword since the standard library provides many functions in C++11 as <em>constexpr</em>. For example <a href=\"http://en.cppreference.com/w/cpp/types/numeric_limits/min\" rel=\"nofollow noreferrer\">std::numeric_limits::min</a>. Which can lead to different behavior, for example:</p>\n<pre><code>#include &lt;limits&gt;\n\nint main()\n{\n    int x[std::numeric_limits&lt;unsigned int&gt;::min()+2] ;\n}\n</code></pre>\n<p>Using <code>clang</code> in C++03 this will cause <code>x</code> to be a variable length array, which is <a href=\"http://clang.llvm.org/compatibility.html#vla\" rel=\"nofollow noreferrer\">an extension</a> and will generate the following warning:</p>\n<pre><code>warning: variable length arrays are a C99 feature [-Wvla-extension]\n    int x[std::numeric_limits&lt;unsigned int&gt;::min()+2] ;\n         ^\n</code></pre>\n<p>while in C++11 <code>std::numeric_limits&lt;unsigned int&gt;::min()+2</code> is a compile time constant expression and does not require the VLA extension.</p>\n<p><b>6. In C++11 noexcept exception specifications are implicitly generated for your destructors </b></p>\n<p>Since in C++11 user defined destructor has implicit <code>noexcept(true)</code> specification as explained in <a href=\"http://akrzemi1.wordpress.com/2013/08/20/noexcept-destructors/\" rel=\"nofollow noreferrer\">noexcept destructors</a> it means that the following program:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n\nstruct S\n{\n  ~S() { throw std::runtime_error(\"\"); } // bad, but acceptable\n};\n\nint main()\n{\n  try { S s; }\n  catch (...) {\n    std::cerr &lt;&lt; \"exception occurred\";\n  } \n std::cout &lt;&lt; \"success\";\n}\n</code></pre>\n<p>In C++11 will call <code>std::terminate</code> but will run successfully in C++03.</p>\n<p><b>7. In C++03, template arguments could not have internal linkage</b></p>\n<p>This is covered nicely in <a href=\"https://stackoverflow.com/a/14596065/1708801\">Why std::sort doesn't accept Compare classes declared within a function</a>. So the following code should not work in C++03:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nclass Comparators\n{\npublic:\n    bool operator()(int first, int second)\n    {\n        return first &lt; second;\n    }\n};\n\nint main()\n{\n    class ComparatorsInner : public Comparators{};\n\n    std::vector&lt;int&gt; compares ;\n    compares.push_back(20) ;\n    compares.push_back(10) ;\n    compares.push_back(30) ;\n\n    ComparatorsInner comparatorInner;\n    std::sort(compares.begin(), compares.end(), comparatorInner);\n\n    std::vector&lt;int&gt;::iterator it;\n    for(it = compares.begin(); it != compares.end(); ++it)\n    {\n        std::cout &lt;&lt; (*it) &lt;&lt; std::endl;\n    }\n}\n</code></pre>\n<p>but currently <code>clang</code> allows this code in C++03 mode with a warning unless you use <code>-pedantic-errors</code> flag, which is kind of icky, <a href=\"http://coliru.stacked-crooked.com/a/316202b3a33a8ec6\" rel=\"nofollow noreferrer\">see it live</a>.</p>\n<p><b>8. &gt;&gt; is not longer ill-formed when closing multiple templates</b></p>\n<p>Using <code>&gt;&gt;</code> to close multiple templates is no longer ill-formed but can lead to code with different results in C++03 and C+11. The example below is taken from <a href=\"http://dev.krzaq.cc/right-angle-brackets-and-backwards-compatibility/\" rel=\"nofollow noreferrer\">Right angle brackets and backwards compatibility</a>:</p>\n<pre><code>#include &lt;iostream&gt;\ntemplate&lt;int I&gt; struct X {\n  static int const c = 2;\n};\ntemplate&lt;&gt; struct X&lt;0&gt; {\n  typedef int c;\n};\ntemplate&lt;typename T&gt; struct Y {\n  static int const c = 3;\n};\nstatic int const c = 4;\nint main() {\n  std::cout &lt;&lt; (Y&lt;X&lt;1&gt; &gt;::c &gt;::c&gt;::c) &lt;&lt; '\\n';\n  std::cout &lt;&lt; (Y&lt;X&lt; 1&gt;&gt;::c &gt;::c&gt;::c) &lt;&lt; '\\n';\n}\n</code></pre>\n<p>and the result in C++03 is:</p>\n<pre><code>0\n3\n</code></pre>\n<p>and in C++11:</p>\n<pre><code>0\n0\n</code></pre>\n<p><b>9. C++11 changes some of std::vector constructors</b></p>\n<p>Slightly modified code from <a href=\"https://stackoverflow.com/a/6474857/1708801\">this answer</a> shows that using the following constructor from <a href=\"http://en.cppreference.com/w/cpp/container/vector/vector\" rel=\"nofollow noreferrer\">std::vector</a>:</p>\n<pre><code>std::vector&lt;T&gt; test(1);\n</code></pre>\n<p>produces different results in C++03 and C++11:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstruct T\n{\n    bool flag;\n    T() : flag(false) {}\n    T(const T&amp;) : flag(true) {}\n};\n\n\nint main()\n{\n    std::vector&lt;T&gt; test(1);\n    bool is_cpp11 = !test[0].flag;\n\n    std::cout &lt;&lt; is_cpp11 &lt;&lt; std::endl ;\n}\n</code></pre>\n<p><b>10. Narrowing conversions in aggregate initializers</b></p>\n<p>In C++11 a narrowing conversion in aggregate initializers is ill-formed and it looks like <code>gcc</code> allows this in both C++11 and C++03 although it provide a warning by default in C++11:</p>\n<pre><code>int x[] = { 2.0 };\n</code></pre>\n<p>This is covered in the draft C++11 standard section <code>8.5.4</code> <em>List-initialization</em> paragraph <em>3</em>:</p>\n<blockquote>\n<p id=\"so_23047198_23063914_1\">List-initialization of an object or reference of type T is defined as follows:</p>\n</blockquote>\n<p>and contains the following bullet (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_23047198_23063914_2\">Otherwise, if T is a class type, constructors are considered. The applicable constructors are enumerated and the best one is chosen through overload resolution (13.3, 13.3.1.7). <strong>If a narrowing conversion (see below) is required to convert any of the arguments, the program is ill-formed</strong></p>\n</blockquote>\n<p>This and many more instance are covered in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow noreferrer\">draft C++ standard</a> section <code>annex C.2</code> <em>C++ and ISO C++ 2003</em>. It also includes:</p>\n<ul>\n<li><p>New kinds of string literals [...] Specifically, macros named R, u8, u8R, u, uR, U, UR, or LR will not be expanded when adjacent to a string literal but will be interpreted as part of the string literal. For example</p>\n<pre><code>#define u8 \"abc\"\nconst char *s = u8\"def\"; // Previously \"abcdef\", now \"def\"\n</code></pre></li>\n<li><p>User-defined literal string support [...]Previously, #1 would have consisted of two separate preprocessing tokens and the macro _x would have been expanded. In this International Standard, #1 consists of a single preprocessing tokens, so the macro\nis not expanded.</p>\n<pre><code>#define _x \"there\"\n\"hello\"_x // #1\n</code></pre></li>\n<li><p>Specify rounding for results of integer / and % [...] 2003 code that uses integer division rounds the result toward 0 or toward negative infinity, whereas this \nInternational Standard always rounds the result toward 0.</p></li>\n<li><p>Complexity of size() member functions now constant [...] Some container implementations that conform to C++ 2003 may not conform to the specified size() requirements in this International Standard. Adjusting containers such as std::list to the stricter requirements may require incompatible changes.</p></li>\n<li><p>Change base class of std::ios_base::failure [...] std::ios_base::failure is no longer derived directly from std::exception, but is now derived from std::system_error, which in turn is derived from std::runtime_error. Valid C++ 2003 code that assumes that std::ios_base::failure is derived directly from std::exception may execute differently in this International Standard.</p></li>\n</ul>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-04-16T03:16:23.920", "Score": "37", "CreationDate": "2014-04-14T15:20:58.467", "ParentId": "23047198", "CommentCount": "4", "LastEditDate": "2017-05-23T11:46:16.047", "OwnerUserId": "1708801"}, "23063891": {"Id": "23063891", "PostTypeId": "2", "Body": "<p>This thread <a href=\"https://stackoverflow.com/a/6473994/809044\">What differences, if any, between C++03 and C++0x can be detected at run-time</a> has examples (copied from that thread) to determine language differences, for example by exploiting C++11 reference collapsing:</p>\n<pre><code>template &lt;class T&gt; bool f(T&amp;) {return true; } \ntemplate &lt;class T&gt; bool f(...){return false;} \n\nbool isCpp11() \n{\n    int v = 1;\n    return f&lt;int&amp;&gt;(v); \n}\n</code></pre>\n<p>and c++11 allowing local types as template parameters:</p>\n<pre><code>template &lt;class T&gt; bool cpp11(T)  {return true;} //T cannot be a local type in C++03\n                   bool cpp11(...){return false;}\n\nbool isCpp0x() \n{\n   struct local {} var; //variable with local type\n   return cpp11(var);\n}\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-04-22T13:58:54.577", "Score": "14", "CreationDate": "2014-04-14T15:19:54.090", "ParentId": "23047198", "CommentCount": "0", "LastEditDate": "2017-05-23T12:16:54.317", "OwnerUserId": "809044"}, "23048056": {"Id": "23048056", "PostTypeId": "2", "Body": "<p>I point you to <a href=\"http://gustedt.wordpress.com/2013/12/15/a-disimprovement-observed-from-the-outside-right-angle-brackets/\">this article</a> and <a href=\"http://gustedt.wordpress.com/2013/12/18/right-angle-brackets-shifting-semantics/\">the follow-up</a>, which has a nice example of how <code>&gt;&gt;</code> can change meaning from C++03 to C++11 while still compiling in both.</p>\n<pre><code>bool const one = true;\nint const two = 2;\nint const three = 3;\n\ntemplate&lt;int&gt; struct fun {\n    typedef int two;\n};\n\ntemplate&lt;class T&gt; struct fon {\n    static int const three = ::three;\n    static bool const one = ::one;\n};\n\nint main(void) {\n    fon&lt; fun&lt; 1 &gt;&gt;::three &gt;::two &gt;::one; // valid for both  \n}\n</code></pre>\n<p>The key part is the line in <code>main</code>, which is an expression. </p>\n<h2>In C++03:</h2>\n<pre><code>1 &gt;&gt; ::three = 0\n=&gt; fon&lt; fun&lt; 0 &gt;::two &gt;::one;\n\nfun&lt; 0 &gt;::two = int\n=&gt; fon&lt; int &gt;::one\n\nfon&lt; int &gt;::one = true\n=&gt; true\n</code></pre>\n<h2>In C++11</h2>\n<pre><code>fun&lt; 1 &gt; is a type argument to fon\nfon&lt; fun&lt;1&gt; &gt;::three = 3\n=&gt; 3 &gt; ::two &gt; ::one\n\n::two is 2 and ::one is 1\n=&gt; 3 &gt; 2 &gt; 1\n=&gt; (3 &gt; 2) &gt; 1\n=&gt; true &gt; 1\n=&gt; 1 &gt; 1\n=&gt; false\n</code></pre>\n<p>Congratulations, two different results for the same expression. Granted, the C++03 one did come up with a warning form Clang when I tested it.</p>\n", "LastActivityDate": "2014-04-13T20:27:59.537", "Score": "54", "CreationDate": "2014-04-13T20:27:59.537", "ParentId": "23047198", "CommentCount": "8", "OwnerUserId": "962089"}});