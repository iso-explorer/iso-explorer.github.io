post_cb({"23698203": {"CommentCount": "2", "CreationDate": "2014-05-16T14:44:51.707", "PostTypeId": "1", "AcceptedAnswerId": "23698352", "LastEditorUserId": "865874", "ClosedDate": "2014-05-16T15:06:43.850", "LastActivityDate": "2014-05-16T15:18:19.533", "LastEditDate": "2014-05-16T14:46:36.220", "ViewCount": "781", "OwnerDisplayName": "user3640765", "Title": "C++ default constructor syntax", "Id": "23698203", "Score": "3", "Body": "<p>I have a question about the default constructor in C++. For example in a class A, what is the difference between using this default constructor <code>A(){};</code> or <code>A() = default;</code> ?  And what is the general difference between them?</p>\n<p>Thank you in advance!</p>\n", "Tags": "<c++><default-constructor>", "AnswerCount": "3"}, "23698451": {"ParentId": "23698203", "PostTypeId": "2", "CommentCount": "9", "CreationDate": "2014-05-16T14:56:57.370", "Score": "1", "LastEditorUserId": "567292", "LastEditDate": "2014-05-16T15:08:49.590", "Id": "23698451", "OwnerUserId": "567292", "Body": "<p>The behavior of the default constructors is the same for <code>A() {}</code> and <code>A() = default;</code> per 12.1p6:</p>\n<blockquote>\n<p id=\"so_23698203_23698451_0\">The implicitly-defined default constructor performs the set of initializations of the class that would be performed by a user-written default constructor for that class with no ctor-initializer (12.6.2) and an empty compound-statement.</p>\n</blockquote>\n<p>The differences are:</p>\n<ul>\n<li>whether the constructor is <code>constexpr</code> (an explicitly-defaulted constructor is <code>constexpr</code> if that would be valid),</li>\n<li>whether the class is an aggregate (8.5.1p1), and</li>\n<li>whether value-initialization results in the default constructor being called, if the explicitly-defaulted default constructor is trivial (8.5p7).</li>\n</ul>\n<p>For the last point:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A { int i; A() = default; };\nstruct B { int j; B() {} };\n\nint main() {\n    int i = 42, j = 42;\n    new (&amp;i) A();\n    new (&amp;j) B();\n    std::cout &lt;&lt; i &lt;&lt; std::endl;  // 0\n    std::cout &lt;&lt; j &lt;&lt; std::endl;  // 42\n}\n</code></pre>\n<p>So you <em>might</em> want to write a user-provided non-defaulted default constructor, if for example your class has trivial members that would be expensive to zero-initialize (e.g. a large array), but it's a very niche case.</p>\n", "LastActivityDate": "2014-05-16T15:08:49.590"}, "23698352": {"ParentId": "23698203", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-05-16T14:52:11.577", "Score": "5", "LastEditorUserId": "153285", "LastEditDate": "2014-05-16T15:18:19.533", "Id": "23698352", "OwnerUserId": "153285", "Body": "<p>A constructor defined as defaulted on the first declaration is considered not user-provided. This is essentially like being implicit in C++03. Such a constructor declaration is allowed in an aggregate class.</p>\n<pre><code>struct ag {\n    ag() = default;\n\n    int a;\n    double b;\n};\n\nstruct nag {\n    nag() {}\n\n    int a;\n    double b;\n};\n\nag a = { 5, 12. }; // OK\nnag na = { 5, 12. }; // error: not an aggregate and no appropriate constructor\n</code></pre>\n<hr>\n<p>This rule only applies when <code>= default</code> appears inside the class. Given this class definition:</p>\n<pre><code>struct nag {\n    nag();\n\n    int a;\n    double b;\n}; \n</code></pre>\n<p>then these constructor definitions would indeed be completely equivalent:</p>\n<pre><code>nag::nag() {} // 1\nnag::nag() = default; // 2\n</code></pre>\n<hr>\n<p>An <code>explicit</code> default constructor usually disables empty copy-list-initialization syntax (<code>= {}</code>), and <code>{}</code> as an argument or <code>return</code> value. An explicitly-defaulted and <code>explicit</code> default constructor in an aggregate is confusingly exempt from this rule because aggregate initialization has higher precedence than constructor initialization. This provides a way to detect whether a class is an aggregate, but you probably <em>should not</em> do so.</p>\n<pre><code>struct sadistic {\n    explicit sadistic() = default;\n\n    // members\n};\n\nsadistic se = {}; // OK only if sadistic has no virtual functions, etc.\n</code></pre>\n</hr></hr>", "LastActivityDate": "2014-05-16T15:18:19.533"}, "bq_ids": {"n4140": {"so_23698203_23698451_0": {"section_id": 370, "quality": 0.8888888888888888, "length": 16}}, "n3337": {"so_23698203_23698451_0": {"section_id": 360, "quality": 0.8888888888888888, "length": 16}}, "n4659": {"so_23698203_23698451_0": {"section_id": 384, "quality": 0.8888888888888888, "length": 16}}}, "23698277": {"ParentId": "23698203", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-05-16T14:48:34.410", "Score": "-1", "LastEditorUserId": "865874", "LastEditDate": "2014-05-16T14:57:06.267", "Id": "23698277", "OwnerUserId": "865874", "Body": "<p>There is not a lot of differences:</p>\n<p>The old syntax (note that the <code>;</code> is not needed):</p>\n<pre><code>A() {}\n</code></pre>\n<p>is available since the first days of C++. It will default construct every base class and member variable.</p>\n<p>The new C++11 syntax:</p>\n<pre><code>A() = default;\n</code></pre>\n<p>does exactly the same, but it is explicit about being default, so you (or the compiler) don't have to check if the braces are really empty.</p>\n<p>Note that if a class have no declared constructors, the compiler will add one for you.</p>\n<p><em>CORRECTION</em>: There is a difference if the default constructor is deleted, that is, the class implicit default constructor is not valid. In this case the <code>{}</code> is a syntax error, while the <code>=default</code> is like a deleted definition:</p>\n<pre><code>struct S\n{\n    int &amp;r;  //non default constructible\n\n    S() {} //error: uninitialized reference S::r;\n    S() = default; //ok: deleted constructor\n    S() = delete;  //also ok (but not both!)\n};\n</code></pre>\n", "LastActivityDate": "2014-05-16T14:57:06.267"}});