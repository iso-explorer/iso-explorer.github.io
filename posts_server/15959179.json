post_cb({"15959179": {"CommentCount": "0", "AcceptedAnswerId": "15959298", "PostTypeId": "1", "LastEditorUserId": "526560", "CreationDate": "2013-04-11T21:27:36.173", "LastActivityDate": "2013-04-11T22:23:26.217", "LastEditDate": "2013-04-11T21:57:42.917", "ViewCount": "119", "FavoriteCount": "1", "Title": "Pointer to member function weirdness", "Id": "15959179", "Score": "1", "Body": "<p>I'm trying to do some binding with my C++ code, and use pointer to member functions.</p>\n<p>I have the following code :</p>\n<pre><code>class A\n{\nexplicit A(float);\n}\nclass B\n{\nvoid setA(A);\nvoid setA(float);\n}\n</code></pre>\n<p>Then I declare the pointer to member functions :</p>\n<pre><code>(void (B::*)(A))&amp;B::setA\n(void (B::*)(float))&amp;B::setA\n</code></pre>\n<p>The compiler (MSVC11) finds the second line is ambiguous.</p>\n<p>If I comment setA(A) in class B, both lines are considered ok by the compiler (!)</p>\n<p>Is it a compiler bug? </p>\n<p>Is there a way to circumvent that, without modifying class B's signature?</p>\n<p>EDIT :</p>\n<p>Actually, the code I posted was oversimplified from my real classes and did compile..</p>\n<p>Here's a modified version that really reproduces the bug :</p>\n<pre><code>class A\n{\npublic:\n    explicit A(float f=1.0f, float g=1.0f) {}\n};\nclass B\n{\npublic:\n    void setA(A){}\n    void setA(float f, float g=1.0f){}\n};\n</code></pre>\n<p>with</p>\n<pre><code>(void (B::*)(A))&amp;B::setA\n(void (B::*)(float))&amp;B::setA\n(void (B::*)(float,float))&amp;B::setA\n</code></pre>\n<p>The 2nd line brings a compile error :\nerror C2440: 'type casting'\u00a0: impossible to convert 'overloaded-function' to 'void (__thiscall B::* )(float)'</p>\n", "Tags": "<c++><visual-studio>", "OwnerUserId": "526560", "AnswerCount": "1"}, "15959298": {"ParentId": "15959179", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>I would say this is a bug. Per Paragraph 13.4/1 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15959179_15959298_0\">A use of an overloaded function name without arguments is resolved in certain contexts to a function, a\n  pointer to function or a <strong>pointer to member function</strong> for a specific function from the overload set. [...] . <strong>The function selected\n  is the one whose type is <em>identical</em> to the function type of the target type required in the context</strong>. [...] The target can be</p>\n<p id=\"so_15959179_15959298_1\">\u2014 an object or reference being initialized (8.5, 8.5.3),</p>\n<p id=\"so_15959179_15959298_2\">\u2014 the left side of an assignment (5.17),</p>\n<p id=\"so_15959179_15959298_3\">\u2014 a parameter of a function (5.2.2),</p>\n<p id=\"so_15959179_15959298_4\">\u2014 a parameter of a user-defined operator (13.5),</p>\n<p id=\"so_15959179_15959298_5\">\u2014 the return value of a function, operator function, or conversion (6.6.3),</p>\n<p id=\"so_15959179_15959298_6\">\u2014 <strong>an explicit type conversion</strong> (5.2.3, 5.2.9, 5.4), or</p>\n<p id=\"so_15959179_15959298_7\">\u2014 a non-type template-parameter (14.3.2).</p>\n</blockquote>\n<p>Since it is pretty clear which member function from the overload set has a signature identical to the one you are explicitly casting it to, your code is legal.</p>\n<p>Besides, your code compiles fine with Clang 3.2, GCC 4.7.2, GCC 4.8, ICC 13.0.1 and (!) VC10. See, for instance, <a href=\"http://liveworkspace.org/code/3kW04t%24167\" rel=\"nofollow\">this live example</a>.</p>\n<p><strong>EDIT:</strong></p>\n<p>The new code you posted is indeed illegal. </p>\n<p>The second cast cannot be resolved, because none of the member functions <code>setA()</code> takes only <em>one</em> float parameter. Therefore, the compiler doesn't know which function you mean by the expression <code>&amp;B::setA</code>. Normally, it would try to disambiguate based on the contextual explicit conversion, but that doesn't help, because it specifies a signature which is incompatible with the signature of both overloads of <code>setA()</code>.</p>\n<p>If you are wondering why this is the case and why the second overload is not picked, then the reason is that a parameter with a default argument is still a formal parameter of your function (even if it could be omitted in some calls), and its type still counts as part of the function's signature.</p>\n<p>Default arguments, on the other hand, are not part of a function's signature:</p>\n<blockquote>\n<p id=\"so_15959179_15959298_8\"><strong>1.3.20 [defns.signature.member]</strong></p>\n<p id=\"so_15959179_15959298_9\"><strong>signature</strong></p>\n<p id=\"so_15959179_15959298_10\"><code>&lt;class member function&gt;</code> name, parameter type list (8.3.5), class of which the function is a member, <em>cv</em>-qualifiers (if any), and <em>ref-qualifier</em> (if any)</p>\n</blockquote>\n<p>Now if you remove the overload <code>setA(A)</code>, the compiler <em>does</em> know what member function the expression <code>&amp;B::setA</code> refers to, because there is only one. No need to use the explicit cast in order to resolve the expression.</p>\n<p>Then, since function pointers can be cast to function pointers of other types, the compiler performs an additional conversion to the specified target type.</p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-04-11T22:23:26.217", "Id": "15959298", "Score": "1", "CreationDate": "2013-04-11T21:36:06.140", "LastActivityDate": "2013-04-11T22:23:26.217"}, "bq_ids": {"n4140": {"so_15959179_15959298_10": {"section_id": 5768, "quality": 0.8461538461538461, "length": 11}, "so_15959179_15959298_1": {"section_id": 593, "quality": 0.8, "length": 4}, "so_15959179_15959298_5": {"section_id": 641, "quality": 0.8571428571428571, "length": 6}, "so_15959179_15959298_0": {"section_id": 641, "quality": 0.9411764705882353, "length": 32}}, "n3337": {"so_15959179_15959298_10": {"section_id": 5541, "quality": 0.8461538461538461, "length": 11}, "so_15959179_15959298_1": {"section_id": 631, "quality": 0.8, "length": 4}, "so_15959179_15959298_5": {"section_id": 631, "quality": 0.8571428571428571, "length": 6}, "so_15959179_15959298_0": {"section_id": 631, "quality": 0.9411764705882353, "length": 32}}, "n4659": {"so_15959179_15959298_10": {"section_id": 7225, "quality": 0.8461538461538461, "length": 11}, "so_15959179_15959298_1": {"section_id": 616, "quality": 0.8, "length": 4}, "so_15959179_15959298_5": {"section_id": 669, "quality": 0.8571428571428571, "length": 6}, "so_15959179_15959298_0": {"section_id": 669, "quality": 0.8235294117647058, "length": 28}}}});