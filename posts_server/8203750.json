post_cb({"8203828": {"ParentId": "8203750", "LastEditDate": "2017-05-23T12:06:17.890", "CommentCount": "0", "CreationDate": "2011-11-20T18:54:14.717", "OwnerUserId": "85140", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "8203828", "Score": "2", "Body": "<p>According to <a href=\"https://stackoverflow.com/questions/991062/passing-unnamed-classes-through-functions\">my own question</a> the limitation is removed and local classes can be used as template arguments.<br>\nI see no reference to the new standard though.</br></p>\n", "LastActivityDate": "2011-11-20T18:54:14.717"}, "8203860": {"ParentId": "8203750", "LastEditDate": "2011-11-20T19:14:41.600", "CommentCount": "2", "CreationDate": "2011-11-20T18:59:00.410", "OwnerUserId": "964135", "LastEditorUserId": "964135", "PostTypeId": "2", "Id": "8203860", "Score": "10", "Body": "<p>From older standard:</p>\n<blockquote>\n<p id=\"so_8203750_8203860_0\">(14.3) A local type, a type with no linkage, an unnamed type or a type compounded from any of these types shall not be used as a template-argument for a template type-parameter.</p>\n</blockquote>\n<p>It seems to be removed in the C++11 standard.</p>\n<p>More restrictions:</p>\n<blockquote>\n<p id=\"so_8203750_8203860_1\">(9.8) Declarations in a local class can\n  use only type names, static variables, extern variables and functions, and enumerators from the enclosing\n  scope. </p>\n<p id=\"so_8203750_8203860_2\">(9.8) A local class shall not have member templates.</p>\n<p id=\"so_8203750_8203860_3\">(14.5.4) A friend template shall not be declared in a local class.</p>\n<p id=\"so_8203750_8203860_4\">(9.4.2 ) A local class shall not have static data members.</p>\n<p id=\"so_8203750_8203860_5\">(9.3) Member functions of a local class (9.8) have no linkage. </p>\n</blockquote>\n", "LastActivityDate": "2011-11-20T19:14:41.600"}, "8203750": {"CommentCount": "4", "CreationDate": "2011-11-20T18:43:19.753", "PostTypeId": "1", "AcceptedAnswerId": "8203922", "LastEditorUserId": "415784", "LastActivityDate": "2011-11-20T19:14:41.600", "LastEditDate": "2011-11-20T18:49:11.417", "ViewCount": "1499", "FavoriteCount": "3", "Title": "Local classes : C++03 vs. C++11", "Id": "8203750", "Score": "21", "Body": "<p>Is there any change in the usage of local class in C++11?</p>\n<p>It seems in C++03 local classes cannot be used as template argument (I recall that).</p>\n<p>Consider this code,</p>\n<pre><code>template&lt;typename T&gt; void f(const T&amp;) {}\n\n//Note : S is a local class defined inside main()\nint main() { struct S{};  f(S()); } //I want template argument to be deduced.\n</code></pre>\n<p>But it gives compilation error (C++03 mode), saying (<a href=\"http://ideone.com/6nB1U\">ideone</a>):</p>\n<blockquote>\n<p id=\"so_8203750_8203750_0\">prog.cpp:4: error: no matching function for call to \u2018f(main()::S)\u2019</p>\n</blockquote>\n<p>However, it compiles fine when compiling it in C++11 mode (<a href=\"http://ideone.com/oNkWE\">ideone</a>), which makes sense to me, otherwise lambda wouldn't work. So I guess that there is at least this change in the usage of local classes. Am I right? What are other changes concerning local classes?</p>\n<p>Please quote the relevant text from the Standards (C++03 and C++11 both) so readers can compare themselves, and for future reference.</p>\n", "Tags": "<c++><templates><c++11><local-class>", "OwnerUserId": "415784", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_8203750_8203860_0": {"section_id": 7141, "quality": 0.6153846153846154, "length": 8}, "so_8203750_8203922_3": {"section_id": 85, "quality": 0.5454545454545454, "length": 6}, "so_8203750_8203922_0": {"section_id": 7141, "quality": 0.6153846153846154, "length": 8}, "so_8203750_8203860_2": {"section_id": 111, "quality": 1.0, "length": 5}, "so_8203750_8203860_3": {"section_id": 132, "quality": 0.8333333333333334, "length": 5}, "so_8203750_8203922_1": {"section_id": 85, "quality": 0.6666666666666666, "length": 6}, "so_8203750_8203860_5": {"section_id": 5882, "quality": 1.0, "length": 6}, "so_8203750_8203860_4": {"section_id": 5910, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_8203750_8203860_0": {"section_id": 6885, "quality": 0.6153846153846154, "length": 8}, "so_8203750_8203922_3": {"section_id": 80, "quality": 0.5454545454545454, "length": 6}, "so_8203750_8203922_0": {"section_id": 6885, "quality": 0.6153846153846154, "length": 8}, "so_8203750_8203860_2": {"section_id": 106, "quality": 1.0, "length": 5}, "so_8203750_8203860_3": {"section_id": 126, "quality": 0.8333333333333334, "length": 5}, "so_8203750_8203922_1": {"section_id": 80, "quality": 0.6666666666666666, "length": 6}, "so_8203750_8203860_5": {"section_id": 5653, "quality": 1.0, "length": 6}, "so_8203750_8203860_4": {"section_id": 5682, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_8203750_8203860_0": {"section_id": 8642, "quality": 0.6153846153846154, "length": 8}, "so_8203750_8203922_1": {"section_id": 88, "quality": 0.6666666666666666, "length": 6}, "so_8203750_8203922_0": {"section_id": 8642, "quality": 0.6153846153846154, "length": 8}, "so_8203750_8203860_2": {"section_id": 115, "quality": 1.0, "length": 5}, "so_8203750_8203860_3": {"section_id": 136, "quality": 0.8333333333333334, "length": 5}, "so_8203750_8203922_3": {"section_id": 88, "quality": 0.5454545454545454, "length": 6}, "so_8203750_8203860_5": {"section_id": 7365, "quality": 1.0, "length": 6}, "so_8203750_8203860_4": {"section_id": 7392, "quality": 0.8571428571428571, "length": 6}}}, "8203922": {"ParentId": "8203750", "CommentCount": "0", "Body": "<p>The differences are visible by comparing \u00a714.3.1/2 in both standards.</p>\n<ul>\n<li><p>C++03</p>\n<blockquote>\n<p id=\"so_8203750_8203922_0\">A local type, a type with no linkage, an unnamed type or a type compounded from any of these types shall\n  not be used as a template-argument for a template type-parameter. [Example:</p>\n</blockquote>\n<pre><code>template &lt;class T&gt; class X { /* ... */ };\nvoid f()\n{\n struct S { /* ... */ };\n X&lt;S&gt; x3;        // error: local type used as template-argument\n X&lt;S*&gt; x4;        // error: pointer to local type used as template-argument\n}\n</code></pre>\n<blockquote>\n<p id=\"so_8203750_8203922_1\">\u2014end example] [Note: a template type argument may be an incomplete type (3.9). ]</p>\n</blockquote></li>\n<li><p>C++0x (n3290)</p>\n<blockquote>\n<p id=\"so_8203750_8203922_2\">[ Example:</p>\n</blockquote>\n<pre><code>template &lt;class T&gt; class X { };\ntemplate &lt;class T&gt; void f(T t) { }\nstruct { } unnamed_obj;\n\nvoid f() {\n struct A { };\n enum { e1 };\n typedef struct { } B;\n B b;\n X&lt;A&gt; x1;        // OK\n X&lt;A*&gt; x2;       // OK\n X&lt;B&gt; x3;        // OK\n f(e1);          // OK\n f(unnamed_obj); // OK\n f(b);           // OK\n}\n</code></pre>\n<blockquote>\n<p id=\"so_8203750_8203922_3\">\u2014 end example ] [ Note: A template type argument may be an incomplete type (3.9). \u2014 end note ]</p>\n</blockquote></li>\n</ul>\n<p>C++03 explicitly disallows local classes in template type arguments. C++11 doesn't, and even includes an example of a valid use of such.</p>\n", "OwnerUserId": "635608", "PostTypeId": "2", "Id": "8203922", "Score": "12", "CreationDate": "2011-11-20T19:07:30.653", "LastActivityDate": "2011-11-20T19:07:30.653"}});