post_cb({"bq_ids": {"n4140": {"so_24896622_24896622_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 2708}}, "n3337": {"so_24896622_24896622_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 2670}}, "n4659": {"so_24896622_24896622_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 3448}}}, "24896622": {"ViewCount": "76", "Body": "<p>I'm trying to get the code from <a href=\"https://stackoverflow.com/questions/14200678/c11-async-continuations-or-attempt-at-then-semantics\">this post</a> to work with Visual Studio 2013. My current version is below and works fine with gcc and clang (<a href=\"http://coliru.stacked-crooked.com/a/5ae7529a21d5fd90\" rel=\"nofollow noreferrer\">coliru demo</a>).</p>\n<p>The standard says about std::async in 30.6.8.2:</p>\n<blockquote>\n<p id=\"so_24896622_24896622_0\">Requires: F and each Ti in Args shall satisfy the MoveConstructible requirements.</p>\n</blockquote>\n<p>But the standard library from MSVC seems to try to copy the functor object, which will obviously not work because of the std::future member.</p>\n<p>My current workaround is the commented out copy constructor that does evil stuff, but maybe a reference object would be a better workaround.</p>\n<p>Is my code incorrect or does VS have a bug there? Is there a better workaround if this is a bug?</p>\n<pre><code>#ifndef CONTINUATION_H\n#define CONTINUATION_H\n\n#include &lt;future&gt;\n\n\nnamespace detail {\n\n    template&lt;typename F, typename W, typename R&gt;\n    struct helper\n    {\n        F f;\n        W w;\n\n        helper(F f, W w)\n            : f(std::move(f))\n            , w(std::move(w))\n        {\n        }\n\n        /*helper(const helper&amp; other)\n            : f(std::move(const_cast&lt;helper&amp;&gt;(other).f))\n            , w(other.w)\n        {\n        }*/\n\n        helper(helper&amp;&amp; other)\n            : f(std::move(other.f))\n            , w(std::move(other.w))\n        {\n        }\n\n        helper&amp; operator=(helper other)\n        {\n            f = std::move(other.f);\n            w = std::move(other.w);\n            return *this;\n        }\n\n        R operator()()\n        {\n            f.wait();\n            return w(std::move(f));\n        }\n    };\n\n}\n\nnamespace util\n{\n    template&lt;typename F, typename W&gt;\n    auto then(F f, W w) -&gt; std::future&lt;decltype(w(std::move(f)))&gt;\n    {\n        return std::async(std::launch::async, detail::helper&lt;F, W, decltype(w(std::move(f)))&gt;(std::move(f), std::move(w)));\n    }\n}\n\n#endif\n\n\n\nint main()\n{\n    std::promise&lt;int&gt; prom;\n    auto fut = prom.get_future();\n\n    std::thread th([&amp;](){\n        prom.set_value(42);\n    });\n\n    util::then(std::move(fut), [](std::future&lt;int&gt; f){\n        printf(\"future got: %i\\n\", f.get());\n    });\n\n    th.join();\n}\n</code></pre>\n", "Title": "Compile Errors on MSVC with continuation implementation", "CreationDate": "2014-07-22T19:53:09.170", "LastActivityDate": "2014-07-22T19:53:09.170", "CommentCount": "2", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:05:34.797", "LastEditorUserId": "-1", "Id": "24896622", "Score": "1", "OwnerUserId": "2040925", "Tags": "<c++><c++11><asynchronous><future><continuations>", "AnswerCount": "0"}});