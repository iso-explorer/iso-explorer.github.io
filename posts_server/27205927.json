post_cb({"27205927": {"CommentCount": "4", "ViewCount": "98", "PostTypeId": "1", "ClosedDate": "2014-11-29T19:40:32.627", "LastEditorUserId": "16673", "CreationDate": "2014-11-29T19:06:51.117", "LastActivityDate": "2014-11-29T19:36:31.913", "Title": "On calling destructor for an object, it is called two times?", "LastEditDate": "2014-11-29T19:15:15.163", "Id": "27205927", "Score": "3", "Body": "<p>On calling desctructor explicitly, it is executed two times. What's the reason for that?   </p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A\n{\n    public:\n        int x;\n\n        A() { cout &lt;&lt; \"A's constructor called \" &lt;&lt; endl;  }\n\n        ~A(){\n            cout&lt;&lt;\"A's desctructor called \"&lt;&lt;endl;\n        }\n};\n\nint main()\n{\n    A a;\n    A b;\n    a.~A();\n}\n</code></pre>\n<p>Output:</p>\n<blockquote>\n<p id=\"so_27205927_27205927_0\">A's constructor called<br>\n  A's desctructor called<br>\n  A's desctructor called </br></br></p>\n</blockquote>\n", "Tags": "<c++><destructor>", "OwnerUserId": "3747190", "AnswerCount": "4"}, "27205967": {"ParentId": "27205927", "CommentCount": "1", "Body": "<p>Well, you called it for 'a', and then 'the language' called it again for 'a' when the object went out of scope. And then, of course, 'the language' called it for b. By 'the language', I mean, of course, the very basic rule that automatic-scope objects are constructed as their scope initialize, and destructed when their scope ends.</p>\n<p>Using explicit calls to destructors is rarely a good idea.</p>\n", "OwnerUserId": "131433", "PostTypeId": "2", "Id": "27205967", "Score": "6", "CreationDate": "2014-11-29T19:10:07.340", "LastActivityDate": "2014-11-29T19:10:07.340"}, "27206227": {"ParentId": "27205927", "CommentCount": "0", "Body": "<p>When a variable goes out of scope, its destructor is implicitly called.</p>\n<p>If the there is no object of the appropriate type there, the behavior is undefined.  Typically the compiler generates code that would call the destructor and does so blindly, as that makes the 'defined behavior' path efficient and simple, and the 'undefined behavior' path is considered your fault.</p>\n<p>So what you are seeing is a symptom of undefined behavior.  Your call of the destructor <strong>does not</strong> mean the compiler will not try to destroy the object.</p>\n<p>In fact, if your object was slightly more complex, it could easily lead to a crash.</p>\n<p>Don't call the destructor of an object directly unless you used placement new (a variant of <code>new</code> that constructs an object and does not allocate any memory) or the equivalent on it, and don't use placement new unless you really know what you are doing.</p>\n<p>There is another valid use, where you destruct and reconstruct in the same place, but that is dangerous, usually a bad idea, and hard to get right.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "27206227", "Score": "1", "CreationDate": "2014-11-29T19:36:31.913", "LastActivityDate": "2014-11-29T19:36:31.913"}, "27205965": {"ParentId": "27205927", "CommentCount": "2", "Body": "<p>You shouldn't call the destructor by hand, it will get called automatically when the object goes out of scope.</p>\n<p>The only place to manually call destructors is when you're writing your own allocator, but that is quite an advanced topic, so the rule of thumb would be to never call the destructor by hand.</p>\n", "OwnerUserId": "72583", "PostTypeId": "2", "Id": "27205965", "Score": "5", "CreationDate": "2014-11-29T19:10:00.783", "LastActivityDate": "2014-11-29T19:10:00.783"}, "bq_ids": {"n4140": {"so_27205927_27206109_0": {"section_id": 7196, "quality": 0.9642857142857143, "length": 27}, "so_27205927_27205927_0": {"section_id": 3296, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_27205927_27206109_0": {"section_id": 6940, "quality": 0.9642857142857143, "length": 27}, "so_27205927_27205927_0": {"section_id": 3166, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_27205927_27206109_0": {"section_id": 8705, "quality": 0.9642857142857143, "length": 27}, "so_27205927_27205927_0": {"section_id": 4058, "quality": 0.6666666666666666, "length": 4}}}, "27206109": {"ParentId": "27205927", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>[basic.life]/8:</p>\n<blockquote>\n<p id=\"so_27205927_27206109_0\">If a program ends the lifetime of an object of type <code>T</code> with [\u2026]\n  automatic (3.7.3) storage duration and if <code>T</code> has a non-trivial\n  destructor, <strong>the program must ensure that an object of the original\n  type occupies that same storage location when the implicit destructor\n  call takes place;</strong> <strong>otherwise the behavior of the program is undefined.</strong></p>\n</blockquote>\n<p>Hence we cannot explain the behavior of your program in general, but we could say \"For your implementation a particular execution behaved as if the destructor was called two times.\"</p>\n", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "LastEditDate": "2014-11-29T19:29:27.720", "Id": "27206109", "Score": "3", "CreationDate": "2014-11-29T19:24:10.983", "LastActivityDate": "2014-11-29T19:29:27.720"}});