post_cb({"bq_ids": {"n4140": {"so_27047795_27048079_1": {"length": 40, "quality": 0.5797101449275363, "section_id": 5451}, "so_27047795_27048079_2": {"length": 28, "quality": 0.9333333333333333, "section_id": 304}, "so_27047795_27048079_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 5450}}, "n3337": {"so_27047795_27048079_2": {"length": 28, "quality": 0.9333333333333333, "section_id": 295}, "so_27047795_27048079_1": {"length": 62, "quality": 0.8985507246376812, "section_id": 5245}, "so_27047795_27048079_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 5244}}, "n4659": {"so_27047795_27048079_2": {"length": 26, "quality": 0.8666666666666667, "section_id": 311}, "so_27047795_27048079_1": {"length": 35, "quality": 0.5072463768115942, "section_id": 6889}, "so_27047795_27048079_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 6877}}}, "27049886": {"Id": "27049886", "PostTypeId": "2", "Body": "<p>The cause of your error is attempting to bind a temporary object to an lvalue reference to non-const.</p>\n<p>Consider this example:</p>\n<pre><code>      int  i = 42;\nconst int ci = 42;\n\nauto&amp; a =  i; // type of  i is       int, value category of  i is lvalue -- OK\nauto&amp; b = ci; // type of ci is const int, value category of ci is lvalue -- OK\nauto&amp; c = 42; // type of 42 is       int, value category of 42 is rvalue -- error\n</code></pre>\n<p><code>auto</code> will deduce the type of the initializing expression according to template arugment deduction rules, so <code>a</code> is an <code>int&amp;</code> and b is a <code>const int&amp;</code>.</p>\n<p>But if the initializing expression is a non-const rvalue, like a literal <code>42</code>, or <code>ints.find(0)</code>, <code>auto</code> will deduce a non-const type, so <code>c</code> is an <code>int&amp;</code> (lvalue reference to non-const) which will not bind to an rvalue.</p>\n<pre><code>auto&amp;&amp; d =  i; // d is       int&amp;  -- OK\nauto&amp;&amp; e = ci; // e is const int&amp;  -- OK\nauto&amp;&amp; f = 42; // f is       int&amp;&amp; -- OK\n</code></pre>\n<p><code>auto&amp;&amp;</code> is a forwarding reference which will deduce both the cv-qualification (constness) and value category of its initializing expression.</p>\n", "LastActivityDate": "2014-11-20T21:28:06.693", "CommentCount": "0", "CreationDate": "2014-11-20T21:28:06.693", "ParentId": "27047795", "Score": "0", "OwnerUserId": "1639256"}, "27048079": {"Id": "27048079", "PostTypeId": "2", "Body": "<p>Yes, this behaviour is entirely standard-mandated:</p>\n<blockquote>\n<p id=\"so_27047795_27048079_0\"><code>[C++11: 7.1.6.4/5]:</code> A program that uses <code>auto</code> in a context not explicitly allowed in this section is ill-formed.</p>\n<p id=\"so_27047795_27048079_1\"><code>[C++11: 7.1.6.4/6]:</code> Once the type of a <em>declarator-id</em> has been determined according to 8.3, the type of the declared variable using the <em>declarator-id</em> is determined from the type of its initializer using the rules for template argument deduction. Let <code>T</code> be the type that has been determined for a variable identifier d. Obtain <code>P</code> from <code>T</code> by replacing the occurrences of auto with either a new invented type template parameter <code>U</code> or, if the initializer is a <em>braced-init-list</em> (8.5.4), with <code>std::initializer_list&lt;U&gt;</code>. <strong>The type deduced for the variable <code>d</code> is then the deduced <code>A</code> determined using the rules of template argument deduction from a function call (14.8.2.1), where <code>P</code> is a function template parameter type and the initializer for <code>d</code> is the corresponding argument. If the deduction fails, the declaration is ill-formed.</strong></p>\n<p id=\"so_27047795_27048079_2\"><code>[C++11: 14.8.2.1/3]:</code> <strong>If <code>P</code> is a cv-qualified type, the top level cv-qualifiers of <code>P</code>\u2019s type are ignored for type deduction. If <code>P</code> is a reference type, the type referred to by <code>P</code> is used for type deduction.</strong> If <code>P</code> is an rvalue reference to a cv-unqualified template parameter and the argument is an lvalue, the type \u201clvalue reference to <code>A</code>\u201d is used in place of <code>A</code> for type deduction.</p>\n</blockquote>\n<p>You've added the <code>&amp;</code> (which would have been necessary even if <code>std::map&lt;int, int&gt;::find const</code> were to return a reference, which it doesn't by the way); now add the <code>const</code> (required per the above)!</p>\n", "LastActivityDate": "2014-11-20T19:40:41.707", "CommentCount": "1", "CreationDate": "2014-11-20T19:40:41.707", "ParentId": "27047795", "Score": "1", "OwnerUserId": "560648"}, "27047795": {"ViewCount": "85", "Body": "<p><strong>EDIT</strong> I missed an important detail, the map is <code>const</code>. The example has been updated.</p>\n<p>Consider</p>\n<pre><code>const std::map&lt;int, int&gt; ints;\nauto&amp; it = ints.find(0);\n</code></pre>\n<p>Reviewing both the C++ (working draft) specification, as well as Stroustrup's \"The C++ Programming Language, FOURTH EDITION\", I cannot determine if <code>const</code> is required (I do believe decorating the type explicitly with <code>const</code> is better stylistically, but such is not my question). Visual Studio 2013 compiles it fine, deducing <code>const</code>.</p>\n<p>I understand that a naked <code>auto</code> (i.e. no decorations such as <code>const</code> nor <code>&amp;</code>) will deduce a non-const, non-reference type.</p>\n<p>In every example in Stroupstrup's book, he uses <code>const auto&amp;</code> and never <code>auto&amp;</code> for such scenarios. <strong>edit</strong> But he doesn't speak to the option/need of using <code>const</code>, they are just examples of <code>auto</code>.</p>\n<p>gcc 4.9.1 fails to compile it, as does xcode for mac:\n<code>error: invalid initialization of non-const reference of type ...</code></p>\n<p>Are these compiler choices? Does the specification speak either way about this?</p>\n<p>Thanks.</p>\n", "AcceptedAnswerId": "27048079", "Title": "According to the spec, is const required with auto for const references?", "CreationDate": "2014-11-20T19:22:53.003", "Id": "27047795", "CommentCount": "3", "LastEditDate": "2014-11-20T19:34:47.243", "PostTypeId": "1", "LastEditorUserId": "788195", "LastActivityDate": "2014-11-20T21:28:06.693", "Score": "-1", "OwnerUserId": "788195", "Tags": "<c++><c++11>", "AnswerCount": "2"}});