post_cb({"bq_ids": {"n4140": {"so_38935256_38966560_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 3325}, "so_38935256_38966560_1": {"length": 13, "quality": 0.8125, "section_id": 3296}, "so_38935256_38966560_2": {"length": 12, "quality": 0.5714285714285714, "section_id": 599}}, "n3337": {"so_38935256_38966560_0": {"length": 9, "quality": 0.5294117647058824, "section_id": 3166}, "so_38935256_38966560_1": {"length": 13, "quality": 0.8125, "section_id": 3166}, "so_38935256_38966560_2": {"length": 12, "quality": 0.5714285714285714, "section_id": 589}}, "n4659": {"so_38935256_38966560_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 4091}, "so_38935256_38966560_1": {"length": 13, "quality": 0.8125, "section_id": 4058}, "so_38935256_38966560_2": {"length": 20, "quality": 0.9523809523809523, "section_id": 622}}}, "38966560": {"Id": "38966560", "PostTypeId": "2", "Body": "<p>DR1467's title concerns aggregates, but <a href=\"http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1467\" rel=\"nofollow\">the wording it added to [dcl.init.list]/3</a> as the first bullet is not limited to aggregates:</p>\n<blockquote>\n<p id=\"so_38935256_38966560_0\">If <code>T</code> is a class type and the initializer list has a single element\n  of type <code>cv U</code>, where <code>U</code> is <code>T</code> or a class derived from <code>T</code>, the\n  object is initialized from that element (by copy-initialization for\n  copy-list-initialization, or by direct-initialization for\n  direct-list-initialization).</p>\n</blockquote>\n<p>However, <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0384r0.html#2137\" rel=\"nofollow\">DR2137</a> walked back from this wording (replacing \"a class type\" with \"an aggregate class\"), and so <a href=\"http://eel.is/c++draft/dcl.init.list#3\" rel=\"nofollow\">this bullet</a> no longer applies to non-aggregates like <code>InitSomething</code>.</p>\n<p>Instead, [dcl.init.list]/3.6 applies, like it did pre-DR1467:</p>\n<blockquote>\n<p id=\"so_38935256_38966560_1\">Otherwise, if T is a class type, constructors are considered.\n  The applicable constructors are enumerated and the best one\n  is chosen through overload resolution ([over.match],\n  [over.match.list]).</p>\n</blockquote>\n<p>And <a href=\"http://eel.is/c++draft/over.match.list\" rel=\"nofollow\">[over.match.list]</a> makes clear that initializer-list constructors are preferred if at all viable:</p>\n<blockquote>\n<p id=\"so_38935256_38966560_2\">When objects of non-aggregate class type <code>T</code> are list-initialized such\n  that [dcl.init.list] specifies that overload resolution is performed\n  according to the rules in this section, overload resolution selects\n  the constructor in two phases:</p>\n<ul>\n<li>Initially, the candidate functions are the initializer-list constructors ([dcl.init.list]) of the class <code>T</code> and the argument list\n  consists of the initializer list as a single argument.</li>\n<li>If no viable initializer-list constructor is found, overload resolution  is performed again, where the candidate functions are all\n  the constructors of the class <code>T</code> and the argument list consists of\n  the elements of the initializer list.</li>\n</ul>\n</blockquote>\n<p>All this talk about ranking implicit conversion sequences is irrelevant because the non-initializer-list constructors <em>are not even candidates</em>.</p>\n<p>Clang is implementing the wording after DR1467 and before DR2137.</p>\n", "LastActivityDate": "2016-08-16T04:14:07.053", "Score": "2", "CreationDate": "2016-08-16T04:14:07.053", "ParentId": "38935256", "CommentCount": "1", "OwnerUserId": "2756719"}, "38935256": {"ViewCount": "97", "Body": "<p>If you look at the following code, I think that both the lines in <code>main()</code> should call the <code>initializer_list</code> constructor for <code>InitSomething</code>. gcc outputs <code>22</code> as I expected, but clang just outputs a single <code>2</code>. Is clang wrong? </p>\n<p>I am compiling with <code>-std=c++14</code>. </p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct InitSomething {\n    explicit InitSomething(int) { std::cout &lt;&lt; '1'; }\n    InitSomething(std::initializer_list&lt;int&gt; ) { std::cout &lt;&lt; '2'; }\n    operator int() { return 1; }\n};\n\nint main() {\n    InitSomething init_something{1};\n    InitSomething init_something_else{init_something};\n}\n</code></pre>\n<hr>\n<p>The output of <code>clang++ --version</code> (I am on a mac) is</p>\n<pre><code>Apple LLVM version 7.3.0 (clang-703.0.31)\nTarget: x86_64-apple-darwin15.5.0\nThread model: posix\nInstalledDir: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin\n</code></pre>\n<p>and the output of <code>g++ --version</code> on the other platform I mentioned is </p>\n<pre><code>g++ (GCC) 4.8.5 20150623 (Red Hat 4.8.5-4)\nCopyright (C) 2015 Free Software Foundation, Inc.\nThis is free software; see the source for copying conditions.  There is NO\nwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n</code></pre>\n</hr>", "Title": "Clang skips processing of an initializer list construction", "CreationDate": "2016-08-13T17:25:57.453", "LastActivityDate": "2016-08-16T04:14:07.053", "CommentCount": "5", "LastEditDate": "2016-08-13T19:15:17.643", "PostTypeId": "1", "LastEditorUserId": "2069064", "Id": "38935256", "Score": "1", "OwnerUserId": "5501675", "Tags": "<c++><gcc><clang><c++14><language-lawyer>", "AnswerCount": "1"}});