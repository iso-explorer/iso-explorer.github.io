post_cb({"35726062": {"ParentId": "35373384", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I believe that Clang and MSVC are incorrect, and GCC is correct to reject this code. This is an example of the principle that names in different scopes do not overload with each other. I submitted this to Clang as <a href=\"https://llvm.org/bugs/show_bug.cgi?id=26850\" rel=\"nofollow\">llvm bug 26850</a>, we'll see if they agree.</p>\n<p>There is nothing special about <code>operator[]</code> vs <code>f()</code>. From [over.sub]:</p>\n<blockquote>\n<p id=\"so_35373384_35726062_0\"><code>operator[]</code> shall be a non-static member function with exactly one parameter. [...] Thus, a subscripting expression <code>x[y]</code> is interpreted as <code>x.operator[](y)</code> for a class object <code>x</code> of type <code>T</code>\n  if <code>T::operator[](T1)</code> exists and if the operator is selected as the best match function by the overload\n  resolution mechanism</p>\n</blockquote>\n<p>So the rules governing the lookup of <code>d[Y()]</code> are the same as the rules governing <code>d.f(X())</code>. All the compilers were correct to reject the latter, and should have also rejected the former. Moreover, <em>both</em> Clang and MSVC reject</p>\n<pre><code>d.operator[](Y());\n</code></pre>\n<p>where both they accept:</p>\n<pre><code>d[Y()];\n</code></pre>\n<p>despite the two having identical meaning. There is no non-member <code>operator[]</code>, and this is not a function call so there is no argument-dependent lookup either.</p>\n<p>What follows is an explanation of why the call should be viewed as ambiguous, despite one of the two inherited member functions seeming like it's a better match. </p>\n<p><hr/>\nThe rules for member name lookup are defined in [class.member.lookup]. This is already a little difficult to parse, plus it refers to <code>C</code> as the object we're looking up in (which in OP is named <code>D</code>, whereas <code>C</code> is a subobject). We have this notion of <em>lookup set</em>:</p>\n<blockquote>\n<p id=\"so_35373384_35726062_1\">The <em>lookup set</em> for <code>f</code> in <code>C</code>, called <code>S(f,C)</code>, consists of two component sets: the <em>declaration set</em>, a set of\n  members named <code>f</code>; and the <em>subobject set</em>, a set of subobjects where declarations of these members (possibly\n  including using-declarations) were found. In the declaration set, <em>using-declarations</em> are replaced by the set\n  of designated members that are not hidden or overridden by members of the derived class (7.3.3), and type\n  declarations (including injected-class-names) are replaced by the types they designate.</p>\n</blockquote>\n<p>The <em>declaration set</em> for <code>operator[]</code> in <code>D&lt;float&gt;</code> is empty: there is neither an explicit declaration nor a <em>using-declaration</em>. </p>\n<blockquote>\n<p id=\"so_35373384_35726062_2\">Otherwise (i.e., <code>C</code> does not contain a declaration of f or the resulting declaration set is empty), <code>S(f,C)</code> is\n  initially empty. If <code>C</code> has base classes, calculate the lookup set for <code>f</code> in each direct base class subobject B<sub>i</sub>,\n  and merge each such lookup set S(f,B<sub>i</sub>) in turn into <code>S(f,C)</code>.</p>\n</blockquote>\n<p>So we look into <code>B&lt;float&gt;</code> and <code>C&lt;float&gt;</code>. </p>\n<blockquote>\n<p id=\"so_35373384_35726062_3\">The following steps define the result of merging lookup set S(f,B<sub>i</sub>) \n  into the intermediate S(f,C):\n  \u2014 If each of the subobject members of S(f,B<sub>i</sub>) is a base class subobject of at least one of the subobject\n  members of S(f,C), or if S(f,B<sub>i</sub>) is empty, S(f,C) is unchanged and the merge is complete. Conversely,\n  if each of the subobject members of S(f,C) is a base class subobject of at least one of the\n  subobject members of S(f,B<sub>i</sub>), or if S(f,C) is empty, the new S(f,C) is a copy of S(f,B<sub>i</sub>).<br>\n  \u2014 Otherwise, if the declaration sets of S(f,B<sub>i</sub>) and S(f,C) differ, the <strong>merge is ambiguous</strong>: the new\n  S(f,C) is a lookup set with an invalid declaration set and the union of the subobject sets. In subsequent\n  merges, an invalid declaration set is considered different from any other.<br>\n  \u2014 Otherwise, the new S(f,C) is a lookup set with the shared set of declarations and the union of the\n  subobject sets.\n  The result of name lookup for <code>f</code> in <code>C</code> is the declaration set of <code>S(f,C)</code>. If it is an invalid set, the program is\n  ill-formed. <em>[ Example:</em></br></br></p>\n<pre><code>struct A { int x; }; // S(x,A) = { { A::x }, { A } }\nstruct B { float x; }; // S(x,B) = { { B::x }, { B } }\nstruct C: public A, public B { }; // S(x,C) = { invalid, { A in C, B in C } }\nstruct D: public virtual C { }; // S(x,D) = S(x,C)\nstruct E: public virtual C { char x; }; // S(x,E) = { { E::x }, { E } }\nstruct F: public D, public E { }; // S(x,F) = S(x,E)\nint main() {\n    F f;\n    f.x = 0; // OK, lookup finds E::x\n}\n</code></pre>\n<p id=\"so_35373384_35726062_4\"><code>S(x, F)</code> is unambiguous because the <code>A</code> and <code>B</code> base subobjects of <code>D</code> are also base subobjects of <code>E</code>, so <code>S(x,D)</code>\n  is discarded in the first merge step. <em>\u2014end example ]</em></p>\n</blockquote>\n<p>So here's what happens. First, we try to merge the empty declaration set of <code>operator[]</code> in <code>D&lt;float&gt;</code> with that of <code>B&lt;float&gt;</code>. This gives us the set <code>{operator[](X)}</code>. </p>\n<p>Next, we merge that with the declaration set of <code>operator[]</code> in <code>C&lt;float&gt;</code>. This latter declaration set is <code>{operator[](Y)}</code>. These merge sets <strong>differ</strong>, so the merge is <strong>ambiguous</strong>. Note that overload resolution is <strong>not considered here</strong>. We are simply looking up the name. </p>\n<p>The fix, by the way, is to add <em>using-declarations</em> to <code>D&lt;T&gt;</code> such that there is no merge step done:</p>\n<pre><code>template&lt;typename T&gt; struct D : B&lt;T&gt;, C&lt;T&gt; {\n    using B&lt;T&gt;::operator[];\n    using C&lt;T&gt;::operator[];\n};\n</code></pre>\n", "OwnerUserId": "2069064", "LastEditorUserId": "2069064", "LastEditDate": "2016-03-06T22:37:06.667", "Id": "35726062", "Score": "3", "CreationDate": "2016-03-01T14:52:35.830", "LastActivityDate": "2016-03-06T22:37:06.667"}, "bq_ids": {"n4140": {"so_35373384_35726062_2": {"section_id": 6993, "quality": 0.9666666666666667, "length": 29}, "so_35373384_35375162_3": {"section_id": 663, "quality": 0.8947368421052632, "length": 17}, "so_35373384_35375162_9": {"section_id": 559, "quality": 0.9642857142857143, "length": 27}, "so_35373384_35375162_5": {"section_id": 554, "quality": 0.9487179487179487, "length": 37}, "so_35373384_35375162_13": {"section_id": 7104, "quality": 0.9318181818181818, "length": 41}, "so_35373384_35375162_15": {"section_id": 7104, "quality": 0.9571428571428572, "length": 67}, "so_35373384_35726062_3": {"section_id": 6994, "quality": 0.8125, "length": 78}, "so_35373384_35375162_6": {"section_id": 555, "quality": 0.90625, "length": 29}, "so_35373384_35726062_4": {"section_id": 6995, "quality": 0.8571428571428571, "length": 12}, "so_35373384_35726062_0": {"section_id": 663, "quality": 0.96, "length": 24}, "so_35373384_35375162_1": {"section_id": 663, "quality": 1.0, "length": 10}, "so_35373384_35375162_12": {"section_id": 7103, "quality": 0.8928571428571429, "length": 25}, "so_35373384_35375162_10": {"section_id": 7089, "quality": 0.7777777777777778, "length": 7}, "so_35373384_35726062_1": {"section_id": 6991, "quality": 0.8936170212765957, "length": 42}}, "n3337": {"so_35373384_35726062_2": {"section_id": 6739, "quality": 0.9666666666666667, "length": 29}, "so_35373384_35375162_3": {"section_id": 653, "quality": 0.8947368421052632, "length": 17}, "so_35373384_35375162_9": {"section_id": 550, "quality": 0.9642857142857143, "length": 27}, "so_35373384_35375162_5": {"section_id": 545, "quality": 0.9487179487179487, "length": 37}, "so_35373384_35375162_13": {"section_id": 6848, "quality": 0.9318181818181818, "length": 41}, "so_35373384_35375162_15": {"section_id": 6848, "quality": 0.9285714285714286, "length": 65}, "so_35373384_35726062_3": {"section_id": 6740, "quality": 0.8125, "length": 78}, "so_35373384_35375162_6": {"section_id": 546, "quality": 0.90625, "length": 29}, "so_35373384_35726062_4": {"section_id": 6741, "quality": 0.8571428571428571, "length": 12}, "so_35373384_35726062_0": {"section_id": 653, "quality": 0.96, "length": 24}, "so_35373384_35375162_1": {"section_id": 653, "quality": 1.0, "length": 10}, "so_35373384_35375162_12": {"section_id": 6847, "quality": 0.8214285714285714, "length": 23}, "so_35373384_35375162_10": {"section_id": 6833, "quality": 0.7777777777777778, "length": 7}, "so_35373384_35726062_1": {"section_id": 6737, "quality": 0.7446808510638298, "length": 35}}, "n4659": {"so_35373384_35726062_2": {"section_id": 8491, "quality": 0.9666666666666667, "length": 29}, "so_35373384_35375162_3": {"section_id": 691, "quality": 0.8947368421052632, "length": 17}, "so_35373384_35726062_4": {"section_id": 8493, "quality": 0.8571428571428571, "length": 12}, "so_35373384_35375162_5": {"section_id": 577, "quality": 0.9230769230769231, "length": 36}, "so_35373384_35375162_13": {"section_id": 8605, "quality": 0.8409090909090909, "length": 37}, "so_35373384_35375162_15": {"section_id": 8605, "quality": 0.9571428571428572, "length": 67}, "so_35373384_35726062_3": {"section_id": 8492, "quality": 0.8125, "length": 78}, "so_35373384_35375162_6": {"section_id": 578, "quality": 0.90625, "length": 29}, "so_35373384_35375162_9": {"section_id": 582, "quality": 0.9642857142857143, "length": 27}, "so_35373384_35375162_12": {"section_id": 8604, "quality": 0.8928571428571429, "length": 25}, "so_35373384_35375162_1": {"section_id": 691, "quality": 1.0, "length": 10}, "so_35373384_35726062_0": {"section_id": 691, "quality": 0.96, "length": 24}, "so_35373384_35375162_10": {"section_id": 8590, "quality": 0.7777777777777778, "length": 7}, "so_35373384_35726062_1": {"section_id": 8489, "quality": 0.8936170212765957, "length": 42}}}, "35375162": {"ParentId": "35373384", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>It's not 100% clear in which compiler the issue lie. The standard goes over a lot of rules for name lookup (which is what this is an issue with), but more specifically section 13.5.5 covers the <code>operator[]</code> overload:</p>\n<blockquote>\n<p id=\"so_35373384_35375162_0\"><b>13.5.5 Subscripting [over.sub]</b></p>\n<p id=\"so_35373384_35375162_1\">1 - <code>operator[]</code> shall be a non-static member function with exactly one parameter. It implements the subscripting syntax</p>\n<p id=\"so_35373384_35375162_2\"><i><code>postfix-expression [ expr-or-braced-init-list ]</code></i></p>\n<p id=\"so_35373384_35375162_3\">Thus, a subscripting expression <code>x[y]</code> is interpreted as <code>x.operator[](y)</code> for a class object <code>x</code> of type <code>T</code> if <code>T::operator[](T1)</code> exists and if the operator is selected as the best match function by the overload resolution mechanism (13.3.3).</p>\n</blockquote>\n<p>Looking at the standard on Overloading (chapter 13):</p>\n<blockquote>\n<p id=\"so_35373384_35375162_4\"><b>13 Overloading [over]</b></p>\n<p id=\"so_35373384_35375162_5\">1 - When two or more different declarations are specified for a single name in the same scope, that name is said to be overloaded. By extension, two declarations in the same scope that declare the same name but with different types are called overloaded declarations. Only function and function template declarations can be overloaded; variable and type declarations cannot be overloaded.</p>\n<p id=\"so_35373384_35375162_6\">2 - When an overloaded function name is used in a call, which overloaded function declaration is being referenced is determined by comparing the types of the arguments at the point of use with the types of the parameters in the overloaded declarations that are visible at the point of use. This function selection process is called overload resolution and is defined in 13.3.</p>\n<p id=\"so_35373384_35375162_7\">...</p>\n<p id=\"so_35373384_35375162_8\"><b>13.2 Declaration matching [over.dcl]</b></p>\n<p id=\"so_35373384_35375162_9\">1 - Two function declarations of the same name refer to the same function if they are in the same scope and have equivalent parameter declarations (13.1). A function member of a derived class is not in the same scope as a function member of the same name in a base class.</p>\n</blockquote>\n<p>So according to this and section 10.2 on derived classes, since you've declared <code>struct D : B, C</code>, both <code>B</code> and <code>C</code> have member functions for <code>operator[]</code> but different types, thus the <code>operator[]</code> function is overloaded within the scope of <code>D</code> (since there's no <code>using</code> nor is <code>operator[]</code> overridden or hidden directly in <code>D</code>). </p>\n<p>Based on this, <b><i>MSVC and Clang are incorrect in their implementations</i></b> since <code>d[Y()]</code> <i>should</i> be evaluated to <code>d.operator[](Y())</code>, which would produce an ambiguous name resolution; so the question is <b>why do they accept the syntax of <code>d[Y()]</code> at all</b>?</p>\n<p>The only other areas I could see with regards to the subscript (<code>[]</code>) syntax make reference to section <b>5.2.1</b> (which states what a subscript expression is) and <b>13.5.5</b> (stated above), which means that those compilers are using other rules to further compile the <code>d[Y()]</code> expression.</p>\n<p>If we look at name lookup, we see that <b>3.4.1 Unqualified name lookup</b> paragraph 3 states that</p>\n<blockquote>\n<p id=\"so_35373384_35375162_10\">The lookup for an unqualified name used as the postfix-expression of a function call is described in 3.4.2.</p>\n</blockquote>\n<p>Where 3.4.2 states:</p>\n<blockquote>\n<p id=\"so_35373384_35375162_11\"><b>3.4.2 Argument-dependent name lookup [basic.lookup.argdep]</b></p>\n<p id=\"so_35373384_35375162_12\">1 - When the postfix-expression in a function call (5.2.2) is an unqualified-id, other namespaces not considered during the usual unqualified lookup (3.4.1) <b>may</b> be searched, and in those namespaces, namespace-scope friend function or function template declarations (11.3) not otherwise visible <b>may</b> be found.</p>\n<p id=\"so_35373384_35375162_13\">2 - For each argument type T in the function call, there is a set of zero or more associated namespaces and a set of zero or more associated classes to be considered. The sets of namespaces and classes is determined entirely by the types of the function arguments (and the namespace of any template template argument). Typedef names and using-declarations used to specify the types do not contribute to this set. The sets of namespaces and classes are determined in the following way:</p>\n<p id=\"so_35373384_35375162_14\">...</p>\n<p id=\"so_35373384_35375162_15\">(2.2) - If <code>T</code> is a class type (including unions), its associated classes are: the class itself; the class of which it is a member, if any; and its direct and indirect base classes. Its associated namespaces are the innermost enclosing namespaces of its associated classes. Furthermore, if <code>T</code> is a class template specialization, its associated namespaces and classes also include: the namespaces and classes associated with the types of the template arguments provided for template type parameters (excluding template template parameters); the namespaces of which any template template arguments are members; and the classes of which any member templates used as template template arguments are members. [ Note: Non-type template arguments do not contribute to the set of associated namespaces.\u2014end note ]</p>\n</blockquote>\n<p>Note the emphasis on <i>may</i>.</p>\n<p>With the above points and a couple of others from 3.4 (name lookup), one could believe that Clang and MSVC are using these rules to find <code>d[]</code> first (and thus finding it as <code>C::operator[]</code>) vs. using 13.5.5 to turn <code>d[]</code> into <code>d.operator[]</code> and continuing compilation.</p>\n<p>It should be noted that bringing the operators of the base classes into scope of the <code>D</code> class or using explicit scope does, however, 'fix' this issue across all three compilers (as is expected based on the using declaration clauses in the references), example:</p>\n<pre><code>struct X{};\nstruct Y{};\n\ntemplate&lt;typename T&gt;\nstruct B\n{\n    void f(X) { }\n    void operator[](X) {}\n};\n\ntemplate&lt;typename T&gt;\nstruct C\n{\n    void f(Y) { }\n    void operator[](Y) {}\n};\n\ntemplate&lt;typename T&gt;\nstruct D : B&lt;T&gt;, C&lt;T&gt;\n{\n    using B&lt;T&gt;::operator[];\n    using C&lt;T&gt;::operator[];\n};\n\nint main()\n{\n    D&lt;float&gt; d;\n\n    d.B&lt;float&gt;::operator[](X()); // OK\n    //d.B&lt;float&gt;::operator[](Y()); // Error\n\n    //d.C&lt;float&gt;::operator[](X()); // Error\n    d.C&lt;float&gt;::operator[](Y()); // OK\n\n    d[Y()]; // calls C&lt;T&gt;::operator[](Y)\n    return 0;\n}\n</code></pre>\n<p>Since the standard is ultimately left to the interpretation of the implementer, I'm not sure which compiler would be technically correct in this instance since MSVC and Clang <i>might</i> be using other rules to compile this though, given the subscripting paragraphs from the standard, I'm inclined to say they are not strictly adhering to the standard as much as GCC is in this instance.</p>\n<p>I hope this can add some insight into the problem.</p>\n", "OwnerUserId": "1152524", "LastEditorUserId": "1152524", "LastEditDate": "2016-03-03T06:27:47.527", "Id": "35375162", "Score": "6", "CreationDate": "2016-02-13T01:51:50.397", "LastActivityDate": "2016-03-03T06:27:47.527"}, "35373384": {"CommentCount": "6", "AcceptedAnswerId": "35726062", "PostTypeId": "1", "LastEditorUserId": "1152524", "CreationDate": "2016-02-12T22:34:44.060", "LastActivityDate": "2016-03-06T22:37:06.667", "LastEditDate": "2016-02-12T22:45:34.070", "ViewCount": "381", "FavoriteCount": "9", "Title": "operator[] lookup into template base classes", "Id": "35373384", "Score": "26", "Body": "<p>The following code is causing a little headache for us: <em>clang</em> and <em>MSVC</em> accepts the following code, while <em>GCC</em> rejects it. We believe <em>GCC</em> is right this time, but I wanted to make it sure before filing the bugreports. So, are there any special rules for <code>operator[]</code> lookup that I'm unaware of?</p>\n<pre><code>struct X{};\nstruct Y{};\n\ntemplate&lt;typename T&gt;\nstruct B\n{\n    void f(X) { }\n    void operator[](X){}\n};\n\ntemplate&lt;typename T&gt;\nstruct C\n{\n    void f(Y) { }\n    void operator[](Y){}\n};\n\ntemplate&lt;typename T&gt; struct D : B&lt;T&gt;, C&lt;T&gt; {};\n\nint main()\n{\n    D&lt;float&gt; d;\n    //d.f(X()); //This is erroneous in all compilers\n    d[Y()];//this is accepted by clang and MSVC\n}\n</code></pre>\n<p>So is the above code is correct in resolving the <code>operator[]</code> call in the <code>main</code> function?</p>\n", "Tags": "<c++><visual-c++><gcc><clang>", "OwnerUserId": "4524629", "AnswerCount": "2"}});