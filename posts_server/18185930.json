post_cb({"18186453": {"ParentId": "18185930", "CommentCount": "0", "Body": "<p>There are at least two questions involved here.</p>\n<p>Yes, B's destructor will be called. That's how polymorphism works, that's how virtual destructors work, it's by design and it's a good thing.</p>\n<p>The fact that a member function that is protected (or even private) in B but virtual and available (e.g. public) in A can be invoked via A* may seem a little odd at first, but it's by design too. What's the alternative? The only other option I can see would be to forbid inheritance that increases the restriction of a virtual member function; what good purpose would that serve?</p>\n<p>If you don't want a method to be accessible, don't derive it from an accessible virtual parent method.</p>\n", "OwnerUserId": "128940", "PostTypeId": "2", "Id": "18186453", "Score": "1", "CreationDate": "2013-08-12T12:01:25.457", "LastActivityDate": "2013-08-12T12:01:25.457"}, "18185930": {"CommentCount": "2", "ViewCount": "72", "PostTypeId": "1", "LastEditorUserId": "153285", "CreationDate": "2013-08-12T11:34:30.807", "LastActivityDate": "2013-08-12T12:01:25.457", "Title": "Friendliness and inheritance", "AcceptedAnswerId": "18186370", "LastEditDate": "2013-08-12T11:54:25.080", "Id": "18185930", "Score": "0", "Body": "<p>Suppose i have this code:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A\n{\nprotected:\n    virtual ~A() { cout &lt;&lt; \"A destructor reached.\" &lt;&lt; endl;}\n\n    friend class Z; \n};\n\nclass B : public A\n{\nprotected:\n    virtual ~B() { cout &lt;&lt; \"B destructor reached.\" &lt;&lt; endl; }\n};\n\nclass Z\n{\npublic:\n    void Test();\n\n    friend class A;\n};\n\nvoid Z::Test()\n{\n    A* derived = (A*) new B();\n\n    delete derived;\n}\n\nint main()\n{\n    Z test;\n    test.Test();\n}\n</code></pre>\n<p>What is going to happen, will the B destructor be called? Is it legal? And if it's not, is there any way to call the derived constructor without making every class derived from A friend of Z?</p>\n", "Tags": "<c++><inheritance>", "OwnerUserId": "1639642", "AnswerCount": "2"}, "18186370": {"ParentId": "18185930", "CommentCount": "1", "Body": "<p>The Standard, \u00a711.5/1 \"access to virtual functions,\" says</p>\n<blockquote>\n<p id=\"so_18185930_18186370_0\">The access rules (Clause 11) for a virtual function are determined by its declaration and are not affected by the rules for a function that later overrides it.</p>\n</blockquote>\n<p>So you can call <code>B::~B</code> as long as you have access to <code>A::~A</code>. But you must call it through <code>A</code> because <code>Z</code> does not have access to <code>B</code>.</p>\n<p>By the way, the friend declaration in <code>Z</code> is useless since nothing is private or protected in it.</p>\n", "OwnerUserId": "153285", "PostTypeId": "2", "Id": "18186370", "Score": "1", "CreationDate": "2013-08-12T11:56:58.927", "LastActivityDate": "2013-08-12T11:56:58.927"}, "bq_ids": {"n4140": {"so_18185930_18186370_0": {"section_id": 6696, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_18185930_18186370_0": {"section_id": 6451, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_18185930_18186370_0": {"section_id": 8171, "quality": 0.9285714285714286, "length": 13}}}});