post_cb({"34230189": {"ParentId": "12358843", "CommentCount": "1", "CreationDate": "2015-12-11T18:27:39.737", "OwnerUserId": "805830", "PostTypeId": "2", "Id": "34230189", "Score": "-1", "Body": "<p>I know that this hasn't been commented on since 2012, but I thought it would be useful to add that I <em>do</em> know an architecture that has <em>very</em> incompatible pointers for data and functions since a call on that architecture checks privilege and carries extra information. No amount of casting will help. It's <a href=\"https://millcomputing.com/\" rel=\"nofollow\">The Mill</a>.</p>\n", "LastActivityDate": "2015-12-11T18:27:39.737"}, "12358879": {"ParentId": "12358843", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-09-10T20:24:34.103", "Score": "5", "LastEditorUserId": "301883", "LastEditDate": "2012-09-10T20:35:22.910", "Id": "12358879", "OwnerUserId": "301883", "Body": "<p>They can be different types with different space requirements.  Assigning to one can irreversibly slice the value of the pointer so that assigning back results in something different.</p>\n<p>I believe they can be different types because the standard doesn't want to limit possible implementations that save space when it's not needed or when the size could cause the CPU to have to do extra crap to use it, etc...</p>\n", "LastActivityDate": "2012-09-10T20:35:22.910"}, "40826136": {"ParentId": "12358843", "CommentCount": "0", "CreationDate": "2016-11-27T05:46:22.403", "OwnerUserId": "1808989", "PostTypeId": "2", "Id": "40826136", "Score": "0", "Body": "<p>A modern example of where function pointers can differ in size from data pointers: <strong>C++ class member function pointers</strong></p>\n<p>Directly quoted from <a href=\"https://blogs.msdn.microsoft.com/oldnewthing/20040209-00/?p=40713/\" rel=\"nofollow noreferrer\">https://blogs.msdn.microsoft.com/oldnewthing/20040209-00/?p=40713/</a></p>\n<blockquote>\n<pre><code>class Base1 { int b1; void Base1Method(); };\nclass Base2 { int b2; void Base2Method(); };\nclass Derived : public Base1, Base2 { int d; void DerivedMethod(); };\n</code></pre>\n<p id=\"so_12358843_40826136_0\">There are now two possible <code>this</code> pointers.</p>\n<p id=\"so_12358843_40826136_1\">A pointer to a member function of <code>Base1</code> can be used as a pointer to a\n  member function of <code>Derived</code>, since they both use the same <code>this</code>\n  pointer. But a pointer to a member function of <code>Base2</code> cannot be used\n  as-is as a pointer to a member function of <code>Derived</code>, since the <code>this</code>\n  pointer needs to be adjusted.</p>\n<p id=\"so_12358843_40826136_2\">There are many ways of solving this. Here's how the Visual Studio\n  compiler decides to handle it:</p>\n<p id=\"so_12358843_40826136_3\">A pointer to a member function of a multiply-inherited class is really\n  a structure.</p>\n<pre><code>[Address of function]\n[Adjustor]\n</code></pre>\n<p id=\"so_12358843_40826136_4\">The size of a pointer-to-member-function of a class that uses multiple inheritance is the size of a pointer plus the size of a <code>size_t</code>.</p>\n</blockquote>\n<p>tl;dr: When using multiple inheritance, a pointer to a member function may (depending on compiler, version, architecture, etc) actually be stored as</p>\n<pre><code>struct { \n    void * func;\n    size_t offset;\n}\n</code></pre>\n<p>which is obviously larger than a <code>void *</code>.</p>\n", "LastActivityDate": "2016-11-27T05:46:22.403"}, "4926068": {"ParentId": "12358843", "CommentCount": "0", "CreationDate": "2011-02-07T20:16:56.463", "OwnerUserId": "379897", "PostTypeId": "2", "Id": "4926068", "Score": "4", "Body": "<p>Another solution:</p>\n<p>Assuming POSIX guarantees function and data pointers to have the same size and representation (I can't find the text for this, but the example OP cited suggests they at least <em>intended</em> to make this requirement), the following should work:</p>\n<pre><code>double (*cosine)(double);\nvoid *tmp;\nhandle = dlopen(\"libm.so\", RTLD_LAZY);\ntmp = dlsym(handle, \"cos\");\nmemcpy(&amp;cosine, &amp;tmp, sizeof cosine);\n</code></pre>\n<p>This avoids violating the aliasing rules by going through the <code>char []</code> representation, which is allowed to alias all types.</p>\n<p>Yet another approach:</p>\n<pre><code>union {\n    double (*fptr)(double);\n    void *dptr;\n} u;\nu.dptr = dlsym(handle, \"cos\");\ncosine = u.fptr;\n</code></pre>\n<p>But I would recommend the <code>memcpy</code> approach if you want absolutely 100% correct C.</p>\n", "LastActivityDate": "2011-02-07T20:16:56.463"}, "12358843": {"CommentCount": "5", "AcceptedAnswerId": "12358902", "PostTypeId": "1", "LastEditorUserId": "1128737", "CreationDate": "2012-09-10T20:21:39.567", "LastActivityDate": "2016-11-27T05:46:22.403", "LastEditDate": "2012-09-11T13:37:13.740", "ViewCount": "11110", "FavoriteCount": "23", "Title": "Why are function pointers and data pointers incompatible in C/C++?", "Id": "12358843", "Score": "124", "Body": "<p>I have read that converting a function pointer to a data pointer and vice versa works on most platforms but is not guaranteed to work. Why is this the case? Shouldn't both be simply addresses into main memory and therefore be compatible?</p>\n", "Tags": "<c++><c><pointers><function-pointers>", "OwnerUserId": "1408611", "AnswerCount": "14"}, "12359083": {"ParentId": "12358843", "CommentCount": "4", "CreationDate": "2012-09-10T20:38:34.977", "OwnerUserId": "412080", "PostTypeId": "2", "Id": "12359083", "Score": "12", "Body": "<p>In addition to what is already said here, it is interesting to look at POSIX <a href=\"http://pubs.opengroup.org/onlinepubs/009695399/functions/dlsym.html\" rel=\"noreferrer\"><code>dlsym()</code></a>:</p>\n<blockquote>\n<p id=\"so_12358843_12359083_0\">The ISO C standard does not require that pointers to functions can be cast back and forth to pointers to data. Indeed, the ISO C standard does not require that an object of type void * can hold a pointer to a function. Implementations supporting the XSI extension, however, do require that an object of type void * can hold a pointer to a function. The result of converting a pointer to a function into a pointer to another data type (except void *) is still undefined, however. Note that compilers conforming to the ISO C standard are required to generate a warning if a conversion from a void * pointer to a function pointer is attempted as in:</p>\n<pre><code> fptr = (int (*)(int))dlsym(handle, \"my_function\");\n</code></pre>\n<p id=\"so_12358843_12359083_1\">Due to the problem noted here, a future version may either add a new function to return function pointers, or the current interface may be deprecated in favor of two new functions: one that returns data pointers and the other that returns function pointers.</p>\n</blockquote>\n", "LastActivityDate": "2012-09-10T20:38:34.977"}, "12378076": {"ParentId": "12358843", "CommentCount": "0", "CreationDate": "2012-09-11T21:18:54.790", "OwnerUserId": "1491895", "PostTypeId": "2", "Id": "12378076", "Score": "2", "Body": "<p>On most architectures, pointers to all normal data types have the same representation, so casting between data pointer types is a no-op.</p>\n<p>However, it's conceivable that function pointers might require a different representation, perhaps they're larger than other pointers. If void* could hold function pointers, this would mean that void*'s representation would have to be the larger size. And all casts of data pointers to/from void* would have to perform this extra copy.</p>\n<p>As someone mentioned, if you need this you can achieve it using a union. But most uses of void* are just for data, so it would be onerous to increase all their memory use just in case a function pointer needs to be stored.</p>\n", "LastActivityDate": "2012-09-11T21:18:54.790"}, "bq_ids": {"n4140": {"so_12358843_40826136_3": {"section_id": 641, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_12358843_40826136_3": {"section_id": 631, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_12358843_40826136_3": {"section_id": 669, "quality": 0.5714285714285714, "length": 4}}}, "4925402": {"ParentId": "12358843", "CommentCount": "3", "CreationDate": "2011-02-07T19:11:30.240", "OwnerUserId": "379897", "PostTypeId": "2", "Id": "4925402", "Score": "2", "Body": "<p>The only truly portable solution is not to use <code>dlsym</code> for functions, and instead use <code>dlsym</code> to obtain a pointer to data that contains function pointers. For example, in your library:</p>\n<pre><code>struct module foo_module = {\n    .create = create_func,\n    .destroy = destroy_func,\n    .write = write_func,\n    /* ... */\n};\n</code></pre>\n<p>and then in your application:</p>\n<pre><code>struct module *foo = dlsym(handle, \"foo_module\");\nfoo-&gt;create(/*...*/);\n/* ... */\n</code></pre>\n<p>Incidentally, this is good design practice anyway, and makes it easy to support both dynamic loading via <code>dlopen</code> and static linking all modules on systems that don't support dynamic linking, or where the user/system integrator does not want to use dynamic linking.</p>\n", "LastActivityDate": "2011-02-07T19:11:30.240"}, "12358887": {"ParentId": "12358843", "PostTypeId": "2", "CommentCount": "12", "CreationDate": "2012-09-10T20:24:57.550", "Score": "36", "LastEditorUserId": "597607", "LastEditDate": "2012-09-11T06:35:40.223", "Id": "12358887", "OwnerUserId": "597607", "Body": "<p>Some computers have (had) separate address spaces for code and data. On such hardware it just doesn't work.</p>\n<p>The language is designed not only for current desktop applications, but to allow it to be implemented on a large set of hardware.</p>\n<hr>\n<p>It seems like the C language committee never intended <code>void*</code> to be a pointer to function, they just wanted a generic pointer to objects.</p>\n<p>The C99 Rationale says:</p>\n<blockquote>\n<p id=\"so_12358843_12358887_0\"><strong>6.3.2.3 Pointers</strong><br>\n  C has now been implemented on a wide range of architectures. While some of these\n  architectures feature uniform pointers which are the size of some integer type, maximally\n  portable code cannot assume any necessary correspondence between different pointer types and the integer types. On some implementations, pointers can even be wider than any integer type.</br></p>\n<p id=\"so_12358843_12358887_1\">The use of <code>void*</code> (\u201cpointer to <code>void</code>\u201d) as a generic object pointer type is an invention of the C89 Committee. Adoption of this type was stimulated by the desire to specify function prototype arguments that either quietly convert arbitrary pointers (as in <code>fread</code>) or complain if the argument type does not exactly match (as in <code>strcmp</code>). Nothing is said about pointers to functions, which may be incommensurate with object pointers and/or integers.</p>\n</blockquote>\n<p>Note <em>Nothing is said about pointers to functions</em> in the last paragraph. They might be different from other pointers, and the committee is aware of that.</p>\n</hr>", "LastActivityDate": "2012-09-11T06:35:40.223"}, "12359449": {"ParentId": "12358843", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2012-09-10T21:04:35.143", "Score": "30", "LastEditorUserId": "134633", "LastEditDate": "2012-09-11T00:54:23.513", "Id": "12359449", "OwnerUserId": "25406", "Body": "<p>For those who remember MS-DOS, Windows 3.1 and older the answer is quite easy. All of these used to support several different memory models, with varying combinations of characteristics for code and data pointers.</p>\n<p>So for instance for the Compact model (small code, large data):</p>\n<pre><code>sizeof(void *) &gt; sizeof(void(*)())\n</code></pre>\n<p>and conversely in the Medium model (large code, small data):</p>\n<pre><code>sizeof(void *) &lt; sizeof(void(*)())\n</code></pre>\n<p>In this case you didn't have separate storage for code and date but still couldn't convert between the two pointers (short of using non-standard __near and __far modifiers).</p>\n<p>Additionally there's no guarantee that even if the pointers are the same size, that they point to the same thing - in the DOS Small memory model, both code and data used near pointers, but they pointed to different segments.  So converting a function pointer to a data pointer wouldn't give you a pointer that had any relationship to the function at all, and hence there was no use for such a conversion.</p>\n", "LastActivityDate": "2012-09-11T00:54:23.513"}, "4924728": {"ParentId": "12358843", "CommentCount": "6", "CreationDate": "2011-02-07T18:00:56.330", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "4924728", "Score": "22", "Body": "<p>Pointers to void are supposed to be able to accommodate a pointer to any kind of data -- but not necessarily a pointer to a function. Some systems have different requirements for pointers to functions than pointers to data (e.g, there are DSPs with different addressing for data vs. code, medium model on MS-DOS used 32-bit pointers for code but only 16-bit pointers for data).</p>\n", "LastActivityDate": "2011-02-07T18:00:56.330"}, "12358902": {"ParentId": "12358843", "CommentCount": "9", "CreationDate": "2012-09-10T20:26:03.853", "OwnerUserId": "1568792", "PostTypeId": "2", "Id": "12358902", "Score": "164", "Body": "<p>An architecture doesn't have to store code and data in the same memory. With a Harvard architecture, code and data are stored in completely different memory. Most architectures are Von Neumann architectures with code and data in the same memory but C doesn't limit itself to only certain types of architectures if at all possible.</p>\n", "LastActivityDate": "2012-09-10T20:26:03.853"}, "4924730": {"ParentId": "12358843", "CommentCount": "0", "CreationDate": "2011-02-07T18:00:58.853", "OwnerUserId": "10897", "PostTypeId": "2", "Id": "4924730", "Score": "5", "Body": "<p>undefined doesn't necessarily mean not allowed, it can mean that the compiler implementor has more freedom to do it how they want.</p>\n<p>For instance it may not be possible on some architectures - undefined allows them to still have a conforming 'C' library even if you can't do this.</p>\n", "LastActivityDate": "2011-02-07T18:00:58.853"}, "4924721": {"ParentId": "12358843", "CommentCount": "4", "CreationDate": "2011-02-07T18:00:21.993", "OwnerUserId": "385478", "PostTypeId": "2", "Id": "4924721", "Score": "7", "Body": "<p>Depending on the target architecture, code and data may be stored in fundamentally incompatible, physically distinct areas of memory. </p>\n", "LastActivityDate": "2011-02-07T18:00:21.993"}, "12360610": {"ParentId": "12358843", "CommentCount": "5", "CreationDate": "2012-09-10T23:01:30.220", "OwnerUserId": "774499", "PostTypeId": "2", "Id": "12360610", "Score": "7", "Body": "<p>C++11 has a solution to the long-standing mismatch between C/C++ and POSIX with regard to <code>dlsym()</code>. One can use <code>reinterpret_cast</code> to convert a function pointer to/from a data pointer so long as the implementation supports this feature.</p>\n<p>From the standard, 5.2.10 para. 8, \"converting a function pointer to an object pointer type or vice versa is conditionally-supported.\" 1.3.5 defines \"conditionally-supported\" as a \"program construct that an implementation is not required to support\".</p>\n", "LastActivityDate": "2012-09-10T23:01:30.220"}});