post_cb({"23462067": {"CreationDate": "2014-05-04T22:00:19.483", "ViewCount": "498", "FavoriteCount": "1", "Id": "23462067", "AcceptedAnswerId": "23640320", "Score": "2", "Title": "Check if a type has a member function (inhrited member functions also) with Boost TTI", "LastEditorUserId": "-1", "CommentCount": "4", "Body": "<p><a href=\"http://www.boost.org/doc/libs/1_55_0/libs/tti/doc/html/index.html\" rel=\"nofollow noreferrer\">Boost TTI</a> has very convenient macros for checking if a type has a member function. <a href=\"http://www.boost.org/doc/libs/1_55_0/libs/tti/doc/html/the_type_traits_introspection_library/tti_detail_has_member_function.html\" rel=\"nofollow noreferrer\">See here</a>.</p>\n<p>But <a href=\"http://www.boost.org/doc/libs/1_55_0/libs/tti/doc/html/the_type_traits_introspection_library/tti_detail_has_member_function.html\" rel=\"nofollow noreferrer\">BOOST_TTI_HAS_MEMBER_FUNCTION</a> returns false for inherited member functions. Is there a convenient Boost solution for this?</p>\n<p>I am aware of an existing thread for a custom <a href=\"https://stackoverflow.com/questions/1966362/sfinae-to-check-for-inherited-member-functions\">SFINAE solution</a>. But I would prefer a Boost solution, since that way I am more sure it works on more compilers and I want avoid maintaining code for each such specific behavior. Also I am already using something similar libraries from Boost. </p>\n", "Tags": "<c++><boost><typetraits>", "LastEditDate": "2017-05-23T11:58:11.243", "LastActivityDate": "2014-05-13T19:50:13.613", "PostTypeId": "1", "AnswerCount": "1", "OwnerUserId": "1686769"}, "23640320": {"CommentCount": "0", "Body": "<p>As Edward Diener, the creator of the library, informs us in <a href=\"https://groups.google.com/forum/#!topic/boost-list/awd4kqJezfQ\" rel=\"nofollow\">this thread</a> : </p>\n<blockquote>\n<p id=\"so_23462067_23640320_0\">TTI cannot identify inherited member functions even if they are public. </p>\n</blockquote>\n<p>So since you still want to use TTI, let's make a work around. I'll be using an example similar to the related manual pages in BOOST, only inheritance will be added to the 'problem' : </p>\n<pre><code>struct AClass { };\n\nstruct Top {\n    int function1();\n    AClass function2(double, short *);\n};\n\nstruct Top2 : Top {\n    long function2(Top &amp;, int, bool, short, float);\n    Top * function3(long, int, AClass &amp;);\n};\n\nint main()\n{\n    cout &lt;&lt; has_member_function_function1&lt;Top, int&gt;::value &lt;&lt; endl;; // 1. true\n    cout &lt;&lt; has_member_function_function1&lt;Top2, int&gt;::value &lt;&lt; endl; // 2. false\n    return 0;\n}\n</code></pre>\n<p>Case (2) is an error since a function named <code>function1</code> returning an <code>int</code> is defined in the base class of <code>Top2</code>, class <code>Top</code></p>\n<h2>1. Mechanism to check across a hierarchy of classes</h2>\n<p>First step will be to build a mechanism that would apply <strong>TTI checks</strong> to an arbitrary number of classes : </p>\n<pre><code>template &lt;\n    template &lt;class, class, class, class&gt; class check,\n    typename Ret, typename... Bases\n&gt;\nstruct has_m_f;\n\n\ntemplate &lt; \n    template &lt;class, class, class, class&gt; class check, \n    typename Ret, typename Base\n&gt;\nstruct has_m_f &lt;check, Ret, Base&gt;\n{\n    static const bool value = check&lt;Base, Ret, \n        boost::mpl::vector&lt;&gt;, boost::function_types::null_tag&gt;::value;\n};\n\n\ntemplate &lt; \n    template &lt;class, class, class, class&gt; class check, \n    typename Ret, typename Base, typename... Bases\n&gt;\nstruct has_m_f &lt;check, Ret, Base, Bases...&gt;\n{\n    static const bool value = check&lt;Base, Ret, \n        boost::mpl::vector&lt;&gt;, boost::function_types::null_tag&gt;::value \n        || has_m_f&lt;check, Ret, Bases...&gt;::value;\n};\n</code></pre>\n<p><code>has_m_f</code> is a struct that forwards an arbitrary length of classes to <code>has_member_function_...</code> structs, which will be doing the check. No algorithm is added, just a mechanism to elevate the predicate using existential quantification : </p>\n<blockquote>\n<p id=\"so_23462067_23640320_1\">if any of the classes ascending the hierarchy has such a member function then return true</p>\n</blockquote>\n<p>With this tool, in your case, you could write</p>\n<pre><code>has_m_f &lt; has_member_function_function1, int, Top2, Top &gt;::value;\n</code></pre>\n<p>The template arguments are : </p>\n<ol>\n<li>The struct that checks for the member function (eg <code>has_member_function_function2</code>)</li>\n<li>The return type of the function</li>\n<li>Arbitrary number of classes in the hierarchy</li>\n</ol>\n<h2>2. Auto producing the base classes</h2>\n<p>The above workaround suffers from the fact that you have to manually supply the base classes. <strong>When practicing generic programming, being specific is a drawback</strong>.</p>\n<p>A way to have this kind of introspection is through <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.7.2/libstdc++/api/a00907.html\" rel=\"nofollow\"><strong>std::tr2::bases</strong></a>. If you have an implementation that supports it (it's going to be standard in a \"while\") you can at last have your introspection using TTI : </p>\n<pre><code>has_m_f &lt; has_member_function_function1, int, Top2,\n            std::tr2::bases&lt;Top2&gt;::type &gt;::value;\n</code></pre>\n<p>HTH</p>\n", "CreationDate": "2014-05-13T19:50:13.613", "ParentId": "23462067", "Id": "23640320", "LastActivityDate": "2014-05-13T19:50:13.613", "PostTypeId": "2", "Score": "3", "OwnerUserId": "2567683"}, "bq_ids": {"n4140": {"so_23462067_23640320_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 4706}}, "n3337": {"so_23462067_23640320_1": {"length": 5, "quality": 0.5555555555555556, "section_id": 6925}}}});