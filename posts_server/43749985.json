post_cb({"bq_ids": {"n4140": {"so_43749985_43751510_0": {"length": 11, "quality": 1.0, "section_id": 1159}, "so_43749985_43751330_0": {"length": 19, "quality": 0.95, "section_id": 5839}}, "n3337": {"so_43749985_43751510_0": {"length": 11, "quality": 1.0, "section_id": 1157}, "so_43749985_43751330_0": {"length": 19, "quality": 0.95, "section_id": 5609}}, "n4659": {"so_43749985_43751510_0": {"length": 11, "quality": 1.0, "section_id": 1253}, "so_43749985_43751330_0": {"length": 19, "quality": 0.95, "section_id": 7317}}}, "43751510": {"Id": "43751510", "PostTypeId": "2", "Body": "<p>This is what the standard says in 29.3.12:</p>\n<blockquote>\n<p id=\"so_43749985_43751510_0\">Implementations should make atomic stores visible to atomic loads within a reasonable amount of time.</p>\n</blockquote>\n<p>There is no guarantee a <code>store</code> will become visible in another thread, there is no guaranteed timing and there is no formal relationship with memory order.  </p>\n<p>Of course, on each regular architecture a <code>store</code> <em>will</em> become visible, but on rare platforms that do not support cache coherency, it may never become visible to a <code>load</code>.<br>\nIn that case, you would have to reach for an atomic <em>read-modify-write</em> operation to get the latest value in the modification order.</br></p>\n", "LastEditorUserId": "6651824", "LastActivityDate": "2017-05-03T05:36:33.040", "Score": "1", "CreationDate": "2017-05-03T05:09:12.093", "ParentId": "43749985", "CommentCount": "2", "OwnerUserId": "6651824", "LastEditDate": "2017-05-03T05:36:33.040"}, "43751330": {"Id": "43751330", "PostTypeId": "2", "Body": "<p>This is all the standard has to say on the matter, I believe:</p>\n<blockquote>\n<p id=\"so_43749985_43751330_0\"><strong>[intro.multithread]/28</strong> An implementation should ensure that the last value (in modification order) assigned by an atomic or synchronization operation will become visible to all other threads in a finite period of time.</p>\n</blockquote>\n", "LastActivityDate": "2017-05-03T04:51:53.890", "CommentCount": "0", "CreationDate": "2017-05-03T04:51:53.890", "ParentId": "43749985", "Score": "2", "OwnerUserId": "1670129"}, "43749985": {"ViewCount": "72", "Body": "<p>Suppose I have a thread <strong>A</strong> that writes to an <code>atomic_int x = 0;</code>, using <code>x.store(1, std::memory_order_relaxed);</code>. Without any other synchronization methods, how long would it take before other threads can see this, using <code>x.load(std::memory_order_relaxed);</code>? Is it possible that the value written to <code>x</code> stays entirely thread-local given the current definition of the C/C++ memory model that the standard gives?</p>\n<p>The practical case that I have at hand is where a thread <strong>B</strong> reads an <code>atomic_bool</code> frequently to check if it has to quit; Another thread, at some point, writes <em>true</em> to this bool and then calls join() on thread B. Clearly I do not mind to call join() before thread B can even see that the atomic_bool was set, nor do I mind when thread B already saw the change and exited execution before I call join(). But I am wondering: using <code>memory_order_relaxed</code> on both sides, is it possible to call join() and block \"forever\" because the change is never propagated to thread B?</p>\n<h2>Edit</h2>\n<p>I contacted Mark Batty (the brain behind mathematically verifying and subsequently fixing the C++ memory model requirements). Originally about something else (which turned out to be a known bug in cppmem and his thesis; so fortunately I didn't make a complete fool of myself, and took the opportunity to ask him about this too; his answer was:</p>\n<blockquote>\n<p id=\"so_43749985_43749985_0\">Q: Can it theoretically be that such a store [memory_order_relaxed without (any following) release operation] never reaches the other thread?<br>\n  Mark: <strong>Theoretically, yes, but I don't think that has been observed.</strong><br>\n  Q: In other words, do relaxed stores make no sense\n  whatsoever unless you combine them with some release operation (and\n  acquire on the other thread), assuming you want another thread to\n  see it?<br>\n  Mark: <strong>Nearly all of the use cases for them do use release and acquire, yes.</strong></br></br></br></p>\n</blockquote>\n", "AcceptedAnswerId": "43751510", "Title": "Is it possible that a store with memory_order_relaxed never reaches other threads?", "CreationDate": "2017-05-03T02:15:40.410", "Id": "43749985", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-08T09:51:46.687", "LastEditorUserId": "2378300", "LastActivityDate": "2017-05-08T09:51:46.687", "Score": "4", "OwnerUserId": "1487069", "Tags": "<c++><c++11><memory-order><relaxed-atomics>", "AnswerCount": "2"}});