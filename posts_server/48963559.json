post_cb({"48964012": {"Id": "48964012", "PostTypeId": "2", "Body": "<p>Because read-modify-write operations have special guarantees.</p>\n<p>According to the standard <a href=\"http://www.eel.is/c++draft/atomics.order#11\" rel=\"nofollow noreferrer\">[atomics.order] paragraph 11</a>:</p>\n<blockquote>\n<p id=\"so_48963559_48964012_0\">Atomic read-modify-write operations shall always read the last value (in the modification order) written before the write associated with the read-modify-write operation.</p>\n</blockquote>\n", "LastActivityDate": "2018-02-24T14:40:45.793", "Score": "3", "CreationDate": "2018-02-24T14:40:45.793", "ParentId": "48963559", "CommentCount": "1", "OwnerUserId": "5376789"}, "48963559": {"ViewCount": "240", "Body": "<p>I took the example about std::memory_order_seq_cst from:\n<a href=\"http://en.cppreference.com/w/cpp/atomic/memory_order\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/atomic/memory_order</a></p>\n<pre><code>#include &lt;thread&gt;\n#include &lt;atomic&gt;\n#include &lt;cassert&gt;\n\nstd::atomic&lt;bool&gt; x = {false};\nstd::atomic&lt;bool&gt; y = {false};\nstd::atomic&lt;int&gt; z = {0};\n\nvoid write_x()\n{\n    x.store(true, std::memory_order_seq_cst);\n}\n\nvoid write_y()\n{\n    y.store(true, std::memory_order_seq_cst);\n}\n\nvoid read_x_then_y()\n{\n    while (!x.load(std::memory_order_seq_cst))\n        ;\n    if (y.load(std::memory_order_seq_cst)) {\n        ++z;\n    }\n}\n\nvoid read_y_then_x()\n{\n    while (!y.load(std::memory_order_seq_cst))\n        ;\n    if (x.load(std::memory_order_seq_cst)) {\n        ++z;\n    }\n}\n\nint main()\n{\n    std::thread a(write_x);\n    std::thread b(write_y);\n    std::thread c(read_x_then_y);\n    std::thread d(read_y_then_x);\n    a.join(); b.join(); c.join(); d.join();\n    assert(z.load() != 0);  // will never happen\n}\n</code></pre>\n<p>This example is also mentioned in the question of <a href=\"https://stackoverflow.com/questions/14861822/acquire-release-versus-sequentially-consistent-memory-order\">Acquire/Release versus Sequentially Consistent memory order</a>.</p>\n<p>My question is how it is possible that thread c and thread d see different things? If it is possible, why this simple example below always yields to z=3? For instance, thread b could say \"okay I see 0 even though thread a is already done so z becomes 0+1 again\" </p>\n<pre><code>#include &lt;atomic&gt;\n#include &lt;iostream&gt;\n\nstd::atomic&lt;int&gt; z = {0};\n\nvoid increment()\n{\n    z.fetch_add(1, std::memory_order_relaxed);\n}\nint main()\n{\n    std::thread a(increment);\n    std::thread b(increment);\n    std::thread c(increment);\n    a.join(); b.join(); c.join();\n    std::cout &lt;&lt; z.load() &lt;&lt; '\\n';\n}\n</code></pre>\n", "AcceptedAnswerId": "48984938", "Title": "How std::memory_order_seq_cst works", "CreationDate": "2018-02-24T13:48:52.030", "LastActivityDate": "2018-02-27T08:11:45.427", "CommentCount": "6", "LastEditDate": "2018-02-26T12:21:01.147", "PostTypeId": "1", "LastEditorUserId": "4083309", "Id": "48963559", "Score": "5", "OwnerUserId": "5787076", "Tags": "<c++><c++11><memory-barriers>", "AnswerCount": "2"}, "48984938": {"Id": "48984938", "PostTypeId": "2", "Body": "<p>So by seeing different things in your comment you mean that <em>Thread C see x==1,y==0 and Thread D see x==0 and y==1</em>. Is that possible with sequential consistency?</p>\n<p>Let's suppose this total order (the modification is the transition between this symbolized memory states):</p>\n<pre><code>{x==0,y==0} : S0\n{x==1,y==0} : S1\n{x==1,y==1} : S2\n</code></pre>\n<p>When we say \"see\" we mean that a thread potentialy performs a load. Two loads can not be performed simultaneously in one thread. So how is it possible that thread C see x==1 <strong>then</strong> see y==0 and Thread D see x==0 <strong>then</strong> see y==1? Thread C performs the two loads while the memory is in the state S1, and Thread D see <code>x</code> at state S0, then see <code>y</code> at state S2.</p>\n<p>In your example code, what happens is that Thread C load x then load y, and Thread D load y repeatedly until it is true then load x. So after y==1, it is guarenteed that <code>x==1</code> in this total order.</p>\n<p>As said by Minee in its comment, nothing could be expected if in place of sequential consistency memory order were used acquire/release memory order: acquire/release semantic does not imply any total ordering,moreover there are no <em>happens before</em> relation between the store to <code>x</code> and the store to <code>y</code>. So the assertion <code>z.load()!=0</code> could fire.</p>\n", "LastEditorUserId": "5632316", "LastActivityDate": "2018-02-27T08:11:45.427", "Score": "1", "CreationDate": "2018-02-26T09:14:50.880", "ParentId": "48963559", "CommentCount": "1", "OwnerUserId": "5632316", "LastEditDate": "2018-02-27T08:11:45.427"}, "bq_ids": {"n4140": {"so_48963559_48964012_0": {"length": 15, "quality": 1.0, "section_id": 1158}}, "n3337": {"so_48963559_48964012_0": {"length": 15, "quality": 1.0, "section_id": 1156}}, "n4659": {"so_48963559_48964012_0": {"length": 15, "quality": 1.0, "section_id": 1252}}}});