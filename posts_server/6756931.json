post_cb({"6756951": {"ParentId": "6756931", "CommentCount": "2", "Body": "<p>The \"something different\" example puts the processing of the initializer list within the scope of the try block.</p>\n", "OwnerUserId": "2574", "PostTypeId": "2", "Id": "6756951", "Score": "2", "CreationDate": "2011-07-20T04:18:11.703", "LastActivityDate": "2011-07-20T04:18:11.703"}, "6757017": {"ParentId": "6756931", "CommentCount": "4", "Body": "<p>Might as well cite the spec...  Or at least a <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow\">draft</a>.</p>\n<p>Section 15 (4):</p>\n<blockquote>\n<p id=\"so_6756931_6757017_0\">A <em>function-try-block</em> associates a <em>handler-seq</em> with the <em>ctor-initializer</em>, if present, and the <em>compound-statement</em>.  An exception thrown during the execution of the <em>compound statement</em> or, for constructors and destructors, during the initialization or destruction, respectively, of the class\u2019s subobjects, transfers control to a handler in a <em>function-try-block</em> in the same way as an exception thrown during the execution of a <em>try-block</em> transfers control to other handlers.</p>\n</blockquote>\n<p>(Here the <em>handler-seq</em> is the stuff after the <code>catch</code> and the <code>compound-statement</code> is the function body.)</p>\n<p>So the \"function try block\" on a constructor or destructor catches exceptions thrown by the ctor-initializers and by the construction or destruction of subobjects.</p>\n<p>On a function other than a constructor or destructor, it is the same as simply wrapping the function body.  (Well, as far as I can discern from reading the spec.)</p>\n<p>Interesting feature, and new to me.  Thanks for bringing it up.</p>\n", "OwnerUserId": "768469", "PostTypeId": "2", "Id": "6757017", "Score": "3", "CreationDate": "2011-07-20T04:28:46.970", "LastActivityDate": "2011-07-20T04:28:46.970"}, "6757172": {"ParentId": "6756931", "PostTypeId": "2", "CommentCount": "8", "Body": "<p><em>Function-try-block</em> is useful mostly in constructors, because there is no other way of catching exceptions in initialization list. In destructors one must be careful to return in catch block, because exception will be automatically re-thrown. (And in good design destructors must not throw.) In normal functions this feature is not useful.\nEdit: an old but still good article: <a href=\"http://drdobbs.com/184401316\" rel=\"nofollow\">http://drdobbs.com/184401316</a></p>\n", "OwnerUserId": "491591", "LastEditorUserId": "491591", "LastEditDate": "2011-07-20T05:28:19.290", "Id": "6757172", "Score": "9", "CreationDate": "2011-07-20T04:54:29.563", "LastActivityDate": "2011-07-20T05:28:19.290"}, "6756931": {"CommentCount": "6", "AcceptedAnswerId": "6756957", "PostTypeId": "1", "LastEditorUserId": "452307", "CreationDate": "2011-07-20T04:14:33.243", "LastActivityDate": "2011-10-24T12:39:17.670", "LastEditDate": "2011-08-18T17:02:58.847", "ViewCount": "5049", "FavoriteCount": "21", "Title": "Difference between try-catch syntax for function", "Id": "6756931", "Score": "41", "Body": "<p>I came across this syntax recently for <code>try-catch</code> for function.</p>\n<pre><code>struct A\n{\n  int a;\n\n  A (int i) : a(i)  // normal syntax\n  {\n    try {}\n    catch(...) {}\n  }\n\n  A ()   // something different\n  try : a(0) {}\n  catch(...) {}\n\n  void foo ()  // normal function\n  try {}\n  catch(...) {}\n};\n</code></pre>\n<p>Both <a href=\"http://www.ideone.com/uueGT\">syntax are valid</a>. Is there any technical difference between these syntax apart from coding style ? Is one of the syntax superior to other by any aspect ?</p>\n", "Tags": "<c++><syntax><try-catch><function-try-block>", "OwnerUserId": "514235", "AnswerCount": "4"}, "6756957": {"ParentId": "6756931", "PostTypeId": "2", "CommentCount": "16", "Body": "<p><strong>The First Syntax:</strong><br>\nThe scope of the try block starts after the Member Initialization list has been completed, So any exception thrown during Member Initialization <strong>will not be</strong> caught by this try-catch block.</br></p>\n<p><strong>The second syntax:</strong><br>\nIt ensures that if an exception gets thrown during Member Initialization list then you are able to catch the exception.</br></p>\n<p><strong>The Third Syntax:</strong><br>\nIt ensures that any exception thrown from betwen the starting brace of the try block inside the function body gets caught appropriately, It would mean any exception caused during the argument passing(if any can occur) will not be caught in this try-catch block.</br></p>\n<p>So yes they are disinctly different in what functionality they provide.</p>\n<hr>\n<p><strong>EDIT:</strong><br>\nSome guidelines to be considered while using the second syntax(function-try-block) in constructors &amp; destructors:  </br></p>\n<p>As per the C++ Standard,   </p>\n<blockquote>\n<p id=\"so_6756931_6756957_0\">If the catch block does not throw (either rethrow the original exception, or throw something new), and control reaches the end of the catch block of a constructor or destructor, then the original exception is automatically rethrown.</p>\n</blockquote>\n<p>In Simple words:<br>\n<em>A constructor or destructor function-try-block's handler code <strong>MUST</strong> finish by emitting some exception.</em> </br></p>\n<p><strong>Guideline 1:</strong><br>\n<em>Constructor function-try-block handlers have only one purpose -- to translate an exception. (And maybe to do logging or some other side effects.) They are not useful for any other purpose.</em></br></p>\n<p>Throwing a exception from destructors is an bad idea, Take a look <strong><a href=\"http://www.parashift.com/c++-faq-lite/exceptions.html#faq-17.9\" rel=\"noreferrer\">here</a></strong> to know why.<br>\n<strong>Guideline 2:</strong><br>\n<em>Destructor function-try-blocks have no practical use at all. There should never be anything for them to detect, and even if there were something to detect because of evil code, the handler is not very useful for doing anything about it because it can not suppress the exception.</em> </br></br></p>\n<p><strong>Guideline 3:</strong><br>\nAlways clean up unmanaged resource acquisition in local try-block handlers within the constructor or destructor body, never in constructor or destructor function-try-block handlers.</br></p>\n<hr>\n<p>For Standardese Fans: </p>\n<p><strong>C++ standard, clause 15.3, paragraph 15:</strong></p>\n<blockquote>\n<p id=\"so_6756931_6756957_1\">If a return statement appears in a handler of the function-try-block of a constructor, the program is ill-formed. </p>\n</blockquote>\n<p><strong>C++ standard, clause 15.3, paragraph 16:</strong></p>\n<blockquote>\n<p id=\"so_6756931_6756957_2\">The exception being handled is rethrown if control reaches the end of a handler of the function-try-block of a constructor or destructor. Otherwise, a function returns when control reaches the end of a handler for the function-try-block (6.6.3). Flowing off the end of a function-try-block is equivalent to a return with no value; this results in undefined behavior in a value-returning function (6.6.3). </p>\n</blockquote>\n<hr>\n<p><strong>References:</strong><br>\nHave a look at this <strong>must read</strong> resource <strong><a href=\"http://www.gotw.ca/gotw/066.htm\" rel=\"noreferrer\">here</a></strong> for more details &amp; explanation.</br></p>\n</hr></hr></hr>", "OwnerUserId": "452307", "LastEditorUserId": "452307", "LastEditDate": "2011-10-24T12:39:17.670", "Id": "6756957", "Score": "41", "CreationDate": "2011-07-20T04:19:04.683", "LastActivityDate": "2011-10-24T12:39:17.670"}, "bq_ids": {"n4140": {"so_6756931_6756957_1": {"section_id": 3359, "quality": 1.0, "length": 7}, "so_6756931_6756957_2": {"section_id": 3360, "quality": 0.8571428571428571, "length": 30}, "so_6756931_6757017_0": {"section_id": 3333, "quality": 0.9428571428571428, "length": 33}}, "n3337": {"so_6756931_6756957_1": {"section_id": 3229, "quality": 1.0, "length": 7}, "so_6756931_6756957_2": {"section_id": 3230, "quality": 0.8571428571428571, "length": 30}, "so_6756931_6757017_0": {"section_id": 3203, "quality": 0.9428571428571428, "length": 33}}, "n4659": {"so_6756931_6756957_1": {"section_id": 4125, "quality": 1.0, "length": 7}, "so_6756931_6757017_0": {"section_id": 4099, "quality": 0.9428571428571428, "length": 33}}}});