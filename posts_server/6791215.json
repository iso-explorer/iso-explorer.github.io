post_cb({"6791263": {"ParentId": "6791215", "CommentCount": "2", "Body": "<p>It's not allowed to forgo a variable definition. It should be an error.</p>\n", "OwnerUserId": "831725", "PostTypeId": "2", "Id": "6791263", "Score": "0", "CreationDate": "2011-07-22T14:08:28.733", "LastActivityDate": "2011-07-22T14:08:28.733"}, "bq_ids": {"n4140": {"so_6791215_6791435_1": {"section_id": 3909, "quality": 1.0, "length": 24}, "so_6791215_6791537_1": {"section_id": 3909, "quality": 0.5217391304347826, "length": 12}, "so_6791215_6791435_0": {"section_id": 3918, "quality": 0.975609756097561, "length": 40}, "so_6791215_6791537_2": {"section_id": 3917, "quality": 0.95, "length": 19}, "so_6791215_6791537_0": {"section_id": 3918, "quality": 0.8333333333333334, "length": 15}}, "n3337": {"so_6791215_6791435_1": {"section_id": 3769, "quality": 1.0, "length": 24}, "so_6791215_6791537_1": {"section_id": 3769, "quality": 0.5217391304347826, "length": 12}, "so_6791215_6791435_0": {"section_id": 3778, "quality": 0.975609756097561, "length": 40}, "so_6791215_6791537_2": {"section_id": 3777, "quality": 0.95, "length": 19}, "so_6791215_6791537_0": {"section_id": 3778, "quality": 0.8333333333333334, "length": 15}}, "n4659": {"so_6791215_6791435_1": {"section_id": 4795, "quality": 1.0, "length": 24}, "so_6791215_6791537_1": {"section_id": 4795, "quality": 0.5217391304347826, "length": 12}, "so_6791215_6791435_0": {"section_id": 4804, "quality": 1.0, "length": 41}, "so_6791215_6791537_2": {"section_id": 4803, "quality": 0.95, "length": 19}, "so_6791215_6791537_0": {"section_id": 4804, "quality": 0.8888888888888888, "length": 16}}}, "6791215": {"CommentCount": "5", "ViewCount": "1306", "PostTypeId": "1", "LastEditorUserId": "147192", "CreationDate": "2011-07-22T14:04:56.847", "LastActivityDate": "2011-07-22T18:52:35.397", "Title": "Goto prior to a variable definition - what happens with its value?", "FavoriteCount": "3", "LastEditDate": "2011-07-22T14:07:01.390", "Id": "6791215", "Score": "17", "Body": "<p>Here is some question I wondered about. Given the following code, can we be certain about its output?</p>\n<pre><code>void f() {\n  int i = 0; \n  z: if(i == 1) goto x; else goto u; \n  int a; \n  x: if(a == 10) goto y; \n  u: a = 10; i = 1; goto z; \n  y: std::cout &lt;&lt; \"finished: \" &lt;&lt; a; \n}\n</code></pre>\n<p>Is this guaranteed to output <code>finished: 10</code> according to the C++ Standard? Or can the compiler occupy the register that <code>a</code> is stored into, when <code>goto</code> to a place prior to <code>a</code>?</p>\n", "Tags": "<c++><goto><local-variables><register-allocation>", "OwnerUserId": "34509", "AnswerCount": "4"}, "6791537": {"ParentId": "6791215", "CommentCount": "1", "Body": "<p>6.7/3 says that </p>\n<blockquote>\n<p id=\"so_6791215_6791537_0\">A program that jumps from a point where a local variable with\n  automatic storage duration is not in scope to a point where it is in\n  scope is illformed unless the variable has POD type (3.9) and is\n  declared without an initializer (8.5).</p>\n</blockquote>\n<p>So that should be ok.</p>\n<p>Then in 6.6/2:</p>\n<blockquote>\n<p id=\"so_6791215_6791537_1\">On exit from a scope (however accomplished), destructors (12.4) are\n  called for all constructed objects with automatic storage duration\n  (3.7.2) (named objects or temporaries) that are declared in that\n  scope, in the reverse order of their declaration.</p>\n</blockquote>\n<p>Now this implies to me that <code>a</code> is toast when you jump back to <code>z</code> and you cant' make any guarantees about how the no-initializer declaration of <code>a</code> will behave the second time it executes.</p>\n<p>See 6.7/2:</p>\n<blockquote>\n<p id=\"so_6791215_6791537_2\">Variables with automatic storage duration (3.7.2) are initialized each\n  time their declarationstatement is executed. Variables with automatic\n  storage duration declared in the block are destroyed on exit from the\n  block (6.6).</p>\n</blockquote>\n<p>So it looks to me like there isn't a guarantee that you'll get 10 although it seems hard to imagine a compiler where that wouldn't be the case.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "6791537", "Score": "5", "CreationDate": "2011-07-22T14:31:01.537", "LastActivityDate": "2011-07-22T14:31:01.537"}, "6791435": {"ParentId": "6791215", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2011-07-22T14:22:22.380", "Score": "6", "LastEditorUserId": "60281", "LastEditDate": "2011-07-22T14:42:21.277", "Id": "6791435", "OwnerUserId": "60281", "Body": "<p><strong>Note:</strong> Read the comments to this one first. Johannes more or less shot down my whole argument with one well-placed standard quote. ;-)</p>\n<hr>\n<p>I do not have the C++ standard available, so I have to extrapolate from the C standard.</p>\n<p>Surprisingly enough (for me), chapter 6.2.1 <em>Scopes of identifiers</em> says nothing about the scope of an identifier starting at the point of its declaration (as I would have guessed). <code>int a</code>, in your example, has <em>block scope</em>, which \"terminates at the end of the associated block\", and that is all that is said about it. chapter 6.8.6.1 <em>The goto statement</em> says that \"a goto statement shall not jump from outside the scope of an identifier having a variably modified type to inside the scope of that identifier\" - but since your <code>goto</code>s jump around only <em>within</em> the block (and, thus, the scope of <code>int a</code>, that <em>seems</em> to be OK as far as ISO/IEC 9899:1999 is concerned.</p>\n<p>I'm <em>quite</em> surprised about this...</p>\n<p><strong>Edit #1:</strong> A quick google later I got my hands on the C++0x final draft. The relevant statement, I think, is this here (6.7 <em>Declaration statement</em>, highlighting mine):</p>\n<blockquote>\n<p id=\"so_6791215_6791435_0\">It is possible to transfer into a block, but not in a way that\n  bypasses declarations <strong>with initialization</strong>.\n  A program that jumps from a point where a variable with automatic\n  storage duration is not in scope to a point where it is in scope is\n  ill-formed <strong>unless the variable has scalar type</strong>, class type with\n  a trivial default constructor and a trivial destructor, a cv-qualified\n  version of one of these types, or an array of one of the\n  preceding types <strong>and is declared without an initializer</strong>.</p>\n</blockquote>\n<p>I think your code is OK by the standard's standards. But butt-ugly, mind you. ;-)</p>\n<p><strong>Edit #2:</strong> Reading your comment about the possible destruction of <code>int a</code> due to the jump backwards, I found this (6.6 <em>Jump statements</em>, highlighting mine):</p>\n<blockquote>\n<p id=\"so_6791215_6791435_1\">Transfer out of a loop, out of a block, or back past an <strong>initialized variable</strong>\n  with automatic storage duration involves the destruction of <strong>objects</strong> with\n  automatic storage duration that are in scope at the point transferred from but\n  not at the point transferred to.</p>\n</blockquote>\n<p>One, <code>int a</code> is not \"initialized\", and it is not an object if I understand the standard terminology correctly.</p>\n</hr>", "LastActivityDate": "2011-07-22T14:42:21.277"}, "6794707": {"ParentId": "6791215", "CommentCount": "2", "Body": "<p>Is it guaranteed to output <code>finished: 10</code> according to the C++ Standard?</p>\n<p>I think yes ,it must! </p>\n<p>Why ? Because <code>a</code> lives from its declaration till the end of its scope (end of the function) and by definition it can only be initialized once and from there on retain its value until destruction which is at the end of the function.</p>\n", "OwnerUserId": "517580", "PostTypeId": "2", "Id": "6794707", "Score": "0", "CreationDate": "2011-07-22T18:52:35.397", "LastActivityDate": "2011-07-22T18:52:35.397"}});