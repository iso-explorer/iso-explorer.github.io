post_cb({"29983869": {"ViewCount": "1328", "Body": "<p>The following user defined literal omits an error:</p>\n<pre><code>constexpr double operator \"\" _kg(double q)\n{\n   return q*1000;\n}\n</code></pre>\n<p>but if <code>long</code> is added the error will disappear and code will work as follows:</p>\n<pre><code>constexpr double operator \"\" _kg(long double q)\n{\n   return q*1000;\n}\n</code></pre>\n<p>the error is:</p>\n<pre><code>\u2018constexpr double operator\"\"_kg(double)\u2019 has invalid argument list\n</code></pre>\n<p>The problem is only caused by the argument and return type can be <code>double</code> without <code>long</code>.</p>\n<p>Why is <code>long</code> needed?</p>\n", "AcceptedAnswerId": "29984044", "Title": "Why do I have to use long double for user defined literals?", "CreationDate": "2015-05-01T08:36:55.137", "Id": "29983869", "CommentCount": "3", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-05-01T09:36:43.027", "LastEditorUserId": "3002139", "LastActivityDate": "2015-05-01T16:06:23.267", "Score": "17", "OwnerUserId": "807495", "Tags": "<c++><c++11><user-defined-literals>", "AnswerCount": "4"}, "29990561": {"Id": "29990561", "PostTypeId": "2", "Body": "<p>Although the failure of ANSI C to define a form of variable-argument declaration that can cleanly handle an extended-precision <code>long double</code> type whose format differs from from <code>double</code> has led to the type's being effectively deprecated on many platforms (unfortunate, IMHO, since it was a good type for use not only on systems with x87 coprocessors <em>but also on systems with no FPU</em>), the only sane way for a system with proper extended-precision types to handle a statement like:</p>\n<pre><code>long double a = 0.1;\n</code></pre>\n<p>is to have the 0.1 numeric literal start life as a <code>long double</code> equal to 14,757,395,258,967,641,293/147,573,952,589,676,412,928; it would be absurd to have that statement set <code>a</code> to 7,205,759,403,792,794/72,057,594,037,927,936 (roughly 0.10000000000000000555, the value of <code>(double)0.1</code>).</p>\n<p>There might arguably be a few cases where having a numeric literal start life as a <code>long double</code> prior to getting down-converted might cause it to yield a different value from what it would if it started life as a <code>double</code> or <code>float</code> (e.g. the closest <code>float</code> to <code>9007199791611905.0</code> is 9007200328482816, which is 536870911 above the requested value, but <code>(float)(double)9007199791611905.0</code> yields 9007199254740992, which is 536870913 below it.  Of course, if one wants the float value 9007200328482816.0f, one should probably use a decimal representation that is closer to what one really wants.</p>\n", "LastActivityDate": "2015-05-01T16:06:23.267", "CommentCount": "0", "CreationDate": "2015-05-01T16:06:23.267", "ParentId": "29983869", "Score": "0", "OwnerUserId": "363751"}, "bq_ids": {"n4140": {"so_29983869_29984044_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 669}, "so_29983869_29984358_3": {"length": 6, "quality": 0.6, "section_id": 673}, "so_29983869_29984358_1": {"length": 4, "quality": 0.6666666666666666, "section_id": 6317}, "so_29983869_29984358_8": {"length": 27, "quality": 0.6923076923076923, "section_id": 673}, "so_29983869_29984358_4": {"length": 6, "quality": 0.6, "section_id": 673}}, "n3337": {"so_29983869_29984358_3": {"length": 6, "quality": 0.6, "section_id": 663}, "so_29983869_29984358_8": {"length": 27, "quality": 0.6923076923076923, "section_id": 663}, "so_29983869_29984358_4": {"length": 6, "quality": 0.6, "section_id": 663}, "so_29983869_29984044_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 659}}, "n4659": {"so_29983869_29984358_3": {"length": 6, "quality": 0.6, "section_id": 701}, "so_29983869_29984358_8": {"length": 27, "quality": 0.6923076923076923, "section_id": 701}, "so_29983869_29984358_4": {"length": 6, "quality": 0.6, "section_id": 701}, "so_29983869_29984044_0": {"length": 8, "quality": 0.8888888888888888, "section_id": 697}}}, "29984010": {"Id": "29984010", "PostTypeId": "2", "Body": "<p>Stroustrup has a great section on string literals where he states (from the spec):</p>\n<ul>\n<li>floating-point literal: accepted by a literal operator taking a single <strong>long double</strong> or const char* argument.</li>\n</ul>\n<p><a href=\"http://www.stroustrup.com/C++11FAQ.html#UD-literals\" rel=\"nofollow\">http://www.stroustrup.com/C++11FAQ.html#UD-literals</a></p>\n", "LastActivityDate": "2015-05-01T08:50:13.603", "CommentCount": "0", "CreationDate": "2015-05-01T08:50:13.603", "ParentId": "29983869", "Score": "0", "OwnerUserId": "4201768"}, "29984044": {"Id": "29984044", "PostTypeId": "2", "Body": "<p>C++11 draft n3290 has this to say about the parameters that user-defined literals can take (\u00a713.5.8):</p>\n<blockquote>\n<p id=\"so_29983869_29984044_0\">The declaration of a literal operator shall have a <em>parameter-declaration-clause</em> equivalent to one of the following:</p>\n<pre><code>const char*\nunsigned long long int\nlong double\nchar\nwchar_t\nchar16_t\nchar32_t\nconst char*, std::size_t\nconst wchar_t*, std::size_t\nconst char16_t*, std::size_t\nconst char32_t*, std::size_t\n</code></pre>\n</blockquote>\n<p>As you can see, <code>double</code> is not in that list, only <code>long double</code> is. So you have to use that for user-defined literals that expect a floating point number as an argument.</p>\n", "LastActivityDate": "2015-05-01T08:53:12.457", "CommentCount": "3", "CreationDate": "2015-05-01T08:53:12.457", "ParentId": "29983869", "Score": "20", "OwnerUserId": "635608"}, "29984358": {"Id": "29984358", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_29983869_29984358_0\">Only the following parameter lists are allowed on literal operators :</p>\n<ul>\n<li>( const char * )    (1) </li>\n<li>( unsigned long long int )  (2) </li>\n<li>( long double ) (3) </li>\n<li>( char )    (4) </li>\n<li>( wchar_t ) (5) </li>\n<li>( char16_t )    (6) </li>\n<li>( char32_t )    (7) </li>\n<li>( const char * , std::size_t )  (8) </li>\n<li>( const wchar_t * , std::size_t )   (9) </li>\n<li><p id=\"so_29983869_29984358_1\">( const char16_t * , std::size_t )  (10)     ( const char32_t * , std::size_t ) (11)</p>\n<ol>\n<li><p id=\"so_29983869_29984358_2\">Literal operators with this parameter list are the raw literal operators, used as fallbacks for integer and floating-point\n  user-defined literals (see above)</p></li>\n<li><p id=\"so_29983869_29984358_3\">Literal operators with these parameter lists are the first-choice literal operator for user-defined integer literals</p></li>\n<li><p id=\"so_29983869_29984358_4\">Literal operators with these parameter lists are the first-choice literal operator for user-defined floating-point literals</p></li>\n</ol></li>\n</ul>\n<p id=\"so_29983869_29984358_5\">4-7. Literal operators with these parameter lists are called by</p>\n<p id=\"so_29983869_29984358_6\">user-defined character literals</p>\n<p id=\"so_29983869_29984358_7\">8-11. Literal operators with these parameter lists are called by\n  user-defined string literals</p>\n<p id=\"so_29983869_29984358_8\">Default arguments are not allowed C language linkage is not allowed\n  Other than the restrictions above, literal operators and literal\n  operator templates are normal functions (and function templates), they\n  can be declared inline or constexpr, they may have internal or\n  external linkage, they can be called explicitly, their addresses can\n  be taken, etc.</p>\n</blockquote>\n<p>From cpp reference:\n<a href=\"http://en.cppreference.com/w/cpp/language/user_literal\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/user_literal</a></p>\n", "LastActivityDate": "2015-05-01T09:20:16.020", "CommentCount": "0", "CreationDate": "2015-05-01T09:20:16.020", "ParentId": "29983869", "Score": "3", "OwnerUserId": "4853626"}});