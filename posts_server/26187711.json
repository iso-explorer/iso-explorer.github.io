post_cb({"26187743": {"Id": "26187743", "PostTypeId": "2", "Body": "<p>The chapter <code>5.1.2/3 ([expr.prim.lambda])</code> of C++ standard says: </p>\n<blockquote>\n<p id=\"so_26187711_26187743_0\">The type of the lambda-expression (which is also the type of the closure object) is a unique, unnamed nonunion class type</p>\n</blockquote>\n<p>So the two lambdas in this line</p>\n<pre><code>WhichOp2(2, [](int i){return i * 2; }, [](int i){return i * 3; });\n</code></pre>\n<p>have different types, even though they look the same. If you want <code>WhichOp2</code> to work like this you have to declare it with different operation types:</p>\n<pre><code>template &lt;class A, class OP1, class OP2&gt;\nauto WhichOp2(A argument, OP1 firstOp, OP2 secondOp)-&gt;decltype(firstOp(argument) + secondOp(argument)) {\n    return firstOp(argument) + secondOp(argument);\n}\n</code></pre>\n", "LastEditorUserId": "3959454", "LastActivityDate": "2014-10-04T19:28:47.407", "Score": "4", "CreationDate": "2014-10-03T22:40:49.137", "ParentId": "26187711", "CommentCount": "2", "OwnerUserId": "3959454", "LastEditDate": "2014-10-04T19:28:47.407"}, "bq_ids": {"n4140": {"so_26187711_26187743_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 5962}}, "n3337": {"so_26187711_26187743_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 5731}}, "n4659": {"so_26187711_26187743_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 7451}}}, "26187711": {"ViewCount": "206", "Body": "<p>I have a template that works if I pass it one lambda, but in a related template that takes two lambdas mapped to the same templated type, it cannot deduce that type, and MSVC++ Express 2013 complains the template parameter is ambiguous. To be clear up front, there is no overloading (or specialization) going on here -- my two examples below are the only entities with those identifiers. Here are the templates, which simply apply the callable objects on an argument and return a result:</p>\n<pre><code>    template &lt;class A, class OP&gt;\n    auto WhichOp1(A argument, OP firstOp)-&gt;decltype(firstOp(argument)) {\n        return firstOp(argument);\n    }\n\n    template &lt;class A, class OP&gt;\n    auto WhichOp2(A argument, OP firstOp, OP secondOp)-&gt;decltype(firstOp(argument)) {\n        return firstOp(argument) + secondOp(argument);\n    }\n</code></pre>\n<p>I can use WhichOp1 successfully like so:</p>\n<pre><code>    int e = WhichOp1(2, [](int i){return i * 2; });\n</code></pre>\n<p>But a similar call to WhichOp2 won't compile:</p>\n<pre><code>    int d = WhichOp2(2, [](int i){return i * 2; }, [](int i){return i * 3; });\n</code></pre>\n<p>I get the following errors:</p>\n<p><em>error C2782: 'unknown-type chaj::ops::WhichOp2(A,OP,OP)' : template parameter 'OP' is ambiguous</em></p>\n<p><em>IntelliSense: no instance of function template \"chaj::ops::WhichOp2\" matches the argument list\n            argument types are: (int, lambda []int (int i)-&gt;int, lambda []int (int i)-&gt;int)</em></p>\n<p>What I gather is that it simply can't take the first lambda with the second one and determine between the two what exactly OP's type should be. If I explicitly instantiate, it works fine to resolve the ambiguity:</p>\n<pre><code>    int b = WhichOp2&lt;int, int(*)(int)&gt;(2, [](int i){return i * 2; }, [](int i){return i * 3; });\n</code></pre>\n<p>So my question is simply an attempt to have a better understanding of what is going on -- why can the compiler not resolve ambiguity when passing two similar lambdas to a template under a common template parameter? The intellisense error seems to map the type of the lambdas to the same type. I won't be surprised if this is compiler specific, but if anyone sees that this works on their compiler, I'd be interested to know.</p>\n", "AcceptedAnswerId": "26187743", "Title": "Two lambdas passed to template function makes type deduction of parameter ambiguous -- why?", "CreationDate": "2014-10-03T22:36:52.240", "Id": "26187711", "CommentCount": "0", "LastEditDate": "2014-10-04T09:34:46.877", "PostTypeId": "1", "LastEditorUserId": "2801814", "LastActivityDate": "2014-10-04T19:28:47.407", "Score": "4", "OwnerUserId": "2801814", "Tags": "<c++><templates><lambda><ambiguity>", "AnswerCount": "2"}, "26187750": {"Id": "26187750", "PostTypeId": "2", "Body": "<p>Each lambda defines a unique type. Even if they take the same parameter(s) and return the same type, two separate lambdas are still two separate types.</p>\n<p>Since they're separate types, to the compiler it's roughly as if you had attempted to do something like:</p>\n<pre><code>template &lt;class T&gt;\nT foo(T a, T b) { return a + b; }\n</code></pre>\n<p>...and then tried to do something like: <code>auto x = foo(1, 2.0);</code> Since you've passed an <code>int</code> and a <code>double</code>, the compiler can't decide whether <code>T</code> is <code>int</code> or <code>double</code>.</p>\n<p>The fix is the same in both cases: specify a separate template parameter for each if you might be using lambdas.</p>\n<p>Note that this is not unique to lambdas either. The same can happen if you use explicitly defined function objects. For example:</p>\n<pre><code>struct foo { \n    bool operator()();\n};\n\nstruct bar {\n    bool operator()();\n};\n\ntemplate &lt;class T&gt;\nvoid baz(T a, T b) { /* ... */ }\n\nbaz(foo(), bar());\n</code></pre>\n<p>Here, since you've defined <code>foo</code> and <code>bar</code> yourself, it's pretty obvious that they're two separate types, even though they both define an <code>operator()</code> of the same type. Lambda expressions do exactly the same, aside from minor (and irrelevant) details about the names of the classes defined by the lambda expression.</p>\n", "LastEditorUserId": "179910", "LastActivityDate": "2014-10-03T22:47:13.793", "Score": "6", "CreationDate": "2014-10-03T22:41:43.617", "ParentId": "26187711", "CommentCount": "0", "OwnerUserId": "179910", "LastEditDate": "2014-10-03T22:47:13.793"}});