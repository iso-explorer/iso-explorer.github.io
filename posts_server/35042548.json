post_cb({"35043929": {"ParentId": "35042548", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The code is <strong>not</strong> fine.</p>\n<ul>\n<li>std::move is nothing but a cast (g++: something like\n<code>static_cast&lt;typename std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(value)</code>)</li>\n<li>Value computation and side effects of each argument expression are\nsequenced before execution of the called function.</li>\n<li><strong>However</strong>, the initialization of function parameters takes place in the\ncontext of the calling function. (Thanks to <a href=\"https://stackoverflow.com/users/2756719/t-c\">T.C</a>)</li>\n</ul>\n<p>Quotes from the draft N4296:</p>\n<p>1.9/15 Program execution</p>\n<blockquote>\n<p id=\"so_35042548_35043929_0\">[...] When calling a function (whether or not the function is inline), every\n  value computation and side effect associated with any argument\n  expression, or with the postfix expression designating the called\n  function, is sequenced before execution of every expression or\n  statement in the body of the called function. [...]</p>\n</blockquote>\n<p>5.2.2/4 Function call</p>\n<blockquote>\n<p id=\"so_35042548_35043929_1\">When a function is called, each parameter (8.3.5) shall be initialized\n  (8.5, 12.8, 12.1) with its corresponding argument. [ Note: Such\n  initializations are indeterminately sequenced with respect to each\n  other (1.9) end note ] [...] The initialization and destruction of each\n  parameter occurs within the context of the calling function. [...]</p>\n</blockquote>\n<p>A sample (g++ 4.8.4):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\nstruct X\n{\n    int x = 1;\n    X() {}\n    X(const X&amp;) = delete;\n    X(X&amp;&amp;) {}\n    X&amp; operator = (const X&amp;) = delete;\n    X&amp; operator = (X&amp;&amp;) = delete;\n};\n\n\nvoid f(std::shared_ptr&lt;X&gt; a, X* ap, X* bp, std::shared_ptr&lt;X&gt; b){\n    std::cout &lt;&lt; a-&gt;x &lt;&lt; \", \" &lt;&lt; ap &lt;&lt; \", \" &lt;&lt; bp &lt;&lt; \", \" &lt;&lt; b-&gt;x &lt;&lt; '\\n';\n}\n\nint main()\n{\n    auto a = std::make_unique&lt;X&gt;();\n    auto b = std::make_unique&lt;X&gt;();\n    f(std::move(a), a.get(), b.get(), std::move(b));\n}\n</code></pre>\n<p>The output may be <code>1, 0xb0f010, 0, 2</code>, showing a (zero) pointer moved away.</p>\n", "OwnerUserId": "2249683", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:27:58.107", "Id": "35043929", "Score": "4", "CreationDate": "2016-01-27T17:19:03.350", "LastActivityDate": "2016-01-29T11:48:42.080"}, "35045792": {"ParentId": "35042548", "CommentCount": "6", "Body": "<p>Stop doing more than one thing on a single line, unless the operations are non-mutating.</p>\n<p>Code isn't faster if it is all on one line, and it is often less correct.</p>\n<p><code>std::move</code> is a mutating operation (or more accurately, it flags an operation to follow as \"mutate ok\").  It should be on its own line, or at the least it should be on a line with no other interaction with its parameter.</p>\n<p>This is like <code>foo( i++, i )</code>.  You modified something and also used it.</p>\n<p>If you want a universal brainless habit, simply bind all arguments in <code>std::forward_as_tuple</code>, and call <code>std::apply</code> to call the function.</p>\n<pre><code>unique_ptr&lt;C&gt; transform1(unique_ptr&lt;C&gt; p) {\n  return std::experimental::apply( transform2, std::forward_as_tuple( std::move(p), p-&gt;x ) );\n}\n</code></pre>\n<p>which avoids the problem because the mutation of <code>p</code> is done on a line different than the reading of the <code>p.get()</code> address in <code>p-&gt;x</code>.</p>\n<p>Or, roll your own:</p>\n<pre><code>template&lt;class F, class...Args&gt;\nauto call( F&amp;&amp; f, Args&amp;&amp;...args )\n-&gt;std::result_of_t&lt;F(Args...)&gt;\n{\n  return std::forward&lt;F&gt;(f)(std::forward_as_tuple(std::forward&lt;Args&gt;)...);\n}\nunique_ptr&lt;C&gt; transform1(unique_ptr&lt;C&gt; p) {\n  return call( transform2, std::move(p), p-&gt;x );\n}\n</code></pre>\n<p>The goal here is to order the evaluation-of-parameter expressions separately from the evaluation-of-parameter-initialization.  It still doesn't fix some move-based issues (like SSO <code>std::basic_string</code> move-guts and reference-to-char issues).</p>\n<p>Next to that, hope that a compiler will add warnings for unordered mutate-and-read in the general case.</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "35045792", "Score": "2", "CreationDate": "2016-01-27T19:00:37.793", "LastActivityDate": "2016-01-27T19:00:37.793"}, "35045817": {"ParentId": "35042548", "CommentCount": "3", "Body": "<p>Generally speaking, no, there isn't a fool-proof method of doing this without taking care of the small details. Where it gets really sneaky is in member-initialization-lists.</p>\n<p>Just an as example that goes one step beyond yours, what happens if <code>p-&gt;x</code> is itself an object whose lifetime depends on <code>*p</code>, and then <code>transform2()</code>, which is effectively <em>unaware</em> of the temporal relationship between its arguments, passes <code>val</code> onwards to some sink function, without taking care to keep <code>*p</code> alive. And, given its own scope, how would it know it should?</p>\n<p>Move semantics are just one of a set of features that can be easily abused, and needs to be handled with care. Then again, that's part of the essential charm of C++: it requires attention to details. In return for that added responsibility, it gives you more control\u2014or is it the other way around?</p>\n", "OwnerUserId": "602372", "PostTypeId": "2", "Id": "35045817", "Score": "1", "CreationDate": "2016-01-27T19:02:14.063", "LastActivityDate": "2016-01-27T19:02:14.063"}, "35042548": {"CommentCount": "18", "ViewCount": "867", "PostTypeId": "1", "LastEditorUserId": "125997", "CreationDate": "2016-01-27T16:17:21.073", "LastActivityDate": "2016-01-29T11:48:42.080", "Title": "How to properly forward unique_ptr?", "FavoriteCount": "1", "LastEditDate": "2016-01-27T18:36:06.360", "Id": "35042548", "Score": "9", "Body": "<p>What is generally the proper way to forward an std::unique_ptr?</p>\n<p>The following code uses <code>std::move</code>, which I thought was the considered practice, but it crashes with clang.</p>\n<pre><code>class C {\n   int x;\n}\n\nunique_ptr&lt;C&gt; transform1(unique_ptr&lt;C&gt; p) {\n    return transform2(move(p), p-&gt;x); // &lt;--- Oops! could access p after move construction takes place, compiler-dependant\n}\n\nunique_ptr&lt;C&gt; transform2(unique_ptr&lt;C&gt; p, int val) {\n    p-&gt;x *= val;\n    return p;\n}\n</code></pre>\n<p>Is there a more robust convention than simply making sure you get everything you need from <code>p</code> before transferring ownership to the next function via <code>std::move</code>? It seems to me using <code>move</code> on an object and accessing it to provide a parameter to the same function call could be a common mistake to make.</p>\n", "Tags": "<c++><c++11><move><unique-ptr>", "OwnerUserId": "125997", "AnswerCount": "6"}, "35042638": {"ParentId": "35042548", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>Since you do not really need to access <code>p</code> after it was moved, one way would be to get <code>p-&gt;x</code> before the move and then use it. </p>\n<p>Example:</p>\n<pre><code>unique_ptr&lt;C&gt; transform1(unique_ptr&lt;C&gt; p) {\n    int x = p-&gt;x;\n    return transform2(move(p), x);\n}\n</code></pre>\n", "OwnerUserId": "5245033", "LastEditorUserId": "2874384", "LastEditDate": "2016-01-27T17:37:08.647", "Id": "35042638", "Score": "5", "CreationDate": "2016-01-27T16:21:31.013", "LastActivityDate": "2016-01-27T17:37:08.647"}, "35042884": {"ParentId": "35042548", "CommentCount": "5", "Body": "<p>ammm... not much of an answer but a suggestion - why pass the ownership of the <code>unique_ptr</code> in the first place? it seems that <code>transformXXX</code> play with the integer value, why does memory management has to play a part here? </p>\n<p>pass the <code>unique_ptr</code> by reference : </p>\n<pre><code>unique_ptr&lt;C&gt;&amp; transform1(unique_ptr&lt;C&gt;&amp; p) {\n    return transform2(p, p-&gt;x); // \n}\n\nunique_ptr&lt;C&gt;&amp; transform2(unique_ptr&lt;C&gt; p&amp;, int val) {\n    p-&gt;x *= val;\n    return p;\n}\n</code></pre>\n<p>pass ownership <strong>outside</strong> these functions. create specific functions which this is their job. seperate algebric logic from memory management.</p>\n", "OwnerUserId": "3613500", "PostTypeId": "2", "Id": "35042884", "Score": "1", "CreationDate": "2016-01-27T16:31:41.907", "LastActivityDate": "2016-01-27T16:31:41.907"}, "bq_ids": {"n4140": {"so_35042548_35043929_1": {"section_id": 5991, "quality": 0.78125, "length": 25}, "so_35042548_35043929_0": {"section_id": 5811, "quality": 1.0, "length": 28}}, "n3337": {"so_35042548_35043929_1": {"section_id": 5759, "quality": 0.78125, "length": 25}, "so_35042548_35043929_0": {"section_id": 5584, "quality": 1.0, "length": 28}}, "n4659": {"so_35042548_35043929_1": {"section_id": 7491, "quality": 0.59375, "length": 19}, "so_35042548_35043929_0": {"section_id": 7273, "quality": 1.0, "length": 28}}}, "35048190": {"ParentId": "35042548", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>As noted in <a href=\"https://stackoverflow.com/a/35043929/166389\">Dieter L\u00fccking's answer</a>, the value computations are sequenced before function body, so the <code>std::move</code> and <code>operator -&gt;</code> are sequenced before the body of the function --- 1.9/15.</p>\n<p>However, this does <em>not</em> specify that the parameter initialization is done after all of those computations, they can appear anywhere with regard to each other, and to non-dependent value computations, as long as they are done before the function body --- 5.2.2/4.</p>\n<p>This means the behaviour is undefined here, as one expression modifies p (moving into a temporary argument) and the other uses the value of p, see <a href=\"https://stackoverflow.com/a/26911480/166389\">https://stackoverflow.com/a/26911480/166389</a>. Although as mentioned there, <a href=\"http://wg21.link/p0145\" rel=\"nofollow noreferrer\">P0145</a> proposes to fix the evaluation order to left-to-right (in this case). Which would mean your code is broken, but <code>transform2(p-&gt;x, move(p))</code> would do what you want. (Corrected, thanks to <a href=\"https://stackoverflow.com/users/2756719/t-c\">T.C.</a>)</p>\n<p>As far as idioms go to avoid this, consider <a href=\"https://stackoverflow.com/a/35042884/166389\">David Haim's approach</a> taking the <code>unique_ptr&lt;C&gt;</code> by reference, although that's pretty opaque to the caller. You're signalling something like \"May modify this pointer\". <code>unique_ptr</code>'s moved-from state is reasonably clear, so this isn't likely to bite you as badly as if you move from a passed-in object reference or something.</p>\n<p>In the end, you need a sequence point between using <code>p</code> and modifying <code>p</code>.</p>\n", "OwnerUserId": "166389", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:15:15.653", "Id": "35048190", "Score": "2", "CreationDate": "2016-01-27T21:17:31.730", "LastActivityDate": "2016-01-28T09:46:40.083"}});