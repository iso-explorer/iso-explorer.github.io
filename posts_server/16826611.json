post_cb({"16826646": {"ParentId": "16826611", "CommentCount": "0", "Body": "<p><code>char</code> is a distinct type from the signed and unsigned versions, and may be signed or unsigned. If you want a specifically signed or unsigned byte/char, you should indeed specify that in your variable declaration.</p>\n", "OwnerUserId": "251738", "PostTypeId": "2", "Id": "16826646", "Score": "2", "CreationDate": "2013-05-30T01:42:34.633", "LastActivityDate": "2013-05-30T01:42:34.633"}, "16826698": {"ParentId": "16826611", "CommentCount": "1", "Body": "<p>The standard doesn't specify if plain 'char' is signed or unsigned.  It's left up to the compiler.  In GCC it's signed by default, but can be specified with <code>-funsigned-char/-fsigned-char</code> and likewise in MSVC the default is signed but can be forced to unsigned with <code>/J</code>.</p>\n", "OwnerUserId": "1349111", "PostTypeId": "2", "Id": "16826698", "Score": "0", "CreationDate": "2013-05-30T01:49:55.197", "LastActivityDate": "2013-05-30T01:49:55.197"}, "16826658": {"ParentId": "16826611", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, <code>char</code> can be signed or unsigned [basic.fundamental], it's up to the compiler (\"C++ implementation\") to choose(*). If it's signed, there's no guarantee it can hold the value <code>255</code>, and in the case it cannot hold the value <code>255</code>, the conversion results in an implementation-defined value [conv.integral].</p>\n<p>As <code>unsigned char</code> is guaranteed to have at least 8 bits (as well as <code>char</code> and <code>signed char</code>), the line <code>unsigned char t = 255;</code> is fine.</p>\n<p><sub>(*) That does <strong>not</strong> mean <code>typedef signed char char;</code>, as <code>char</code>, <code>signed char</code> and <code>unsigned char</code> are required to be three distinct types [basic.fundamental]/1.</sub></p>\n", "OwnerUserId": "420683", "LastEditorUserId": "420683", "LastEditDate": "2013-08-12T18:46:08.500", "Id": "16826658", "Score": "2", "CreationDate": "2013-05-30T01:43:56.547", "LastActivityDate": "2013-08-12T18:46:08.500"}, "16826611": {"CommentCount": "3", "ViewCount": "136", "PostTypeId": "1", "LastEditorUserId": "445131", "CreationDate": "2013-05-30T01:38:37.977", "LastActivityDate": "2013-08-12T18:46:08.500", "Title": "C++ information about placing a small integer in a char", "LastEditDate": "2013-08-12T18:37:44.443", "Id": "16826611", "Score": "1", "Body": "<p>I see a lot of code in C++ where they use <code>char</code> to represent numbers smaller\nthan 256. </p>\n<p>Should these be <code>unsigned char</code> instead of <code>char</code>?</p>\n<p>What happens if I do this?</p>\n<pre><code>char t = 255;\n</code></pre>\n<p>I remember I read at some place that saying char is special about the signs.  </p>\n", "Tags": "<c++><char>", "OwnerUserId": "1804543", "AnswerCount": "4"}, "16826659": {"ParentId": "16826611", "CommentCount": "0", "Body": "<p>Strictly speaking, it depends on how many bits there are in a <code>char</code> for the target in question.  You're right that for a normal 2's complement machine with a signed 8-bit <code>char</code> type, that they should probably be using <code>unsigned char</code>.</p>\n<p>The conversion from signed to unsigned, should one take place, is well-defined according to the C++ spec (<strong>4.7 Integral conversions</strong>):</p>\n<blockquote>\n<p id=\"so_16826611_16826659_0\">2 If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2<sup><em>n</em></sup> where <em>n</em> is the number of bits used to represent the unsigned type). [<em>Note:</em> In a two\u2019s complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation). <em>\u2014endnote</em>]</p>\n</blockquote>\n<p>The conversion from unsigned to signed, however, is implementation-defined:</p>\n<blockquote>\n<p id=\"so_16826611_16826659_1\">3 If the destination type is signed, the value is unchanged if it can be represented in the destination type (and bit-field width); otherwise, the value is implementation-defined.</p>\n</blockquote>\n<p>But in practice, most systems work they way you'd expect and things go fine.  That is, signed overflow works like unsigned overflow, the bit patterns don't change regardless of signed-&gt;unsigned or unsigned-&gt;signed conversions, etc.</p>\n", "OwnerUserId": "116908", "PostTypeId": "2", "Id": "16826659", "Score": "0", "CreationDate": "2013-05-30T01:44:05.253", "LastActivityDate": "2013-05-30T01:44:05.253"}, "bq_ids": {"n4140": {"so_16826611_16826659_0": {"section_id": 31, "quality": 0.9354838709677419, "length": 29}, "so_16826611_16826659_1": {"section_id": 32, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_16826611_16826659_0": {"section_id": 28, "quality": 0.9354838709677419, "length": 29}, "so_16826611_16826659_1": {"section_id": 29, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_16826611_16826659_0": {"section_id": 31, "quality": 0.9354838709677419, "length": 29}, "so_16826611_16826659_1": {"section_id": 32, "quality": 0.7857142857142857, "length": 11}}}});