post_cb({"35490466": {"ParentId": "35490327", "CommentCount": "0", "Body": "<p>I think you're mixing up two different concepts. If you have two pointers <code>p</code> and <code>q</code> of any type, then <code>p == q</code> <em>always</em> compares the addresses stored in the pointers rather than the objects being pointed at. As a result, the statement</p>\n<pre><code>if (p == q) \n</code></pre>\n<p>tests whether <code>p</code> and <code>q</code> are literally pointing at the same object. As to why you're getting back the same objects - many compilers, as an optimization, will pool together all string literals of the same value into a single string literal and set all pointers to share it. This optimization saves space in the binary. It's also why it's undefined behavior to write to a string literal - if you could write to a string literal, then you might accidentally pollute other strings initialized to that literal.</p>\n<p>Independently, the streams library is specifically programmed so that if you try to print out a <code>const char *</code>, it will treat that <code>const char*</code> as a pointer to the start of a null-terminated string, and then print out all of the characters in that string.</p>\n<p>If you wanted to instead print out the addresses, you can cast the pointers to <code>void*</code> first:</p>\n<pre><code>cout &lt;&lt; static_cast&lt;const void*&gt;(p) &lt;&lt; endl;\ncout &lt;&lt; static_cast&lt;const void*&gt;(q) &lt;&lt; endl;\n</code></pre>\n<p>The reason this works is that the streams library is designed so that if you try to print out a pointer that isn't a character pointer, it displays the address. The typecast basically tells the compiler \"please forget that this is actually a <code>char*</code> and instead treat it like a generic pointer.\"</p>\n<p>Similarly, if you want to compare the strings themselves, use <code>strcmp</code>:</p>\n<pre><code>if (strcmp(p, q) == 0) {\n   // Equal!\n}\n</code></pre>\n<p>That said, in C++, you should probably consider using <code>std::string</code> instead of <code>const char*</code>, since it's safer and easier to use.</p>\n", "OwnerUserId": "501557", "PostTypeId": "2", "Id": "35490466", "Score": "4", "CreationDate": "2016-02-18T19:16:03.167", "LastActivityDate": "2016-02-18T19:16:03.167"}, "35490427": {"ParentId": "35490327", "PostTypeId": "2", "CommentCount": "3", "Body": "<blockquote>\n<p id=\"so_35490327_35490427_0\">In Visual studio 2015 the syntax <code>if (p == q)</code> doesn't comparing addresses, it compares the values...</p>\n</blockquote>\n<p>It does compare addresses. String (or other) literals with the exact same content will be optimized to be instantiated only once (at the same address).</p>\n<p>To check the actual address use a statement like</p>\n<pre><code>cout &lt;&lt; (void*)p &lt;&lt; ' ' &lt;&lt; (void*)q &lt;&lt; endl;\n</code></pre>\n", "OwnerUserId": "1413395", "LastEditorUserId": "1413395", "LastEditDate": "2016-02-18T19:16:59.420", "Id": "35490427", "Score": "4", "CreationDate": "2016-02-18T19:14:25.397", "LastActivityDate": "2016-02-18T19:16:59.420"}, "35490327": {"CommentCount": "4", "ViewCount": "124", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-02-18T19:09:03.493", "LastActivityDate": "2016-02-18T19:41:05.770", "LastEditDate": "2017-05-23T11:53:08.923", "AcceptedAnswerId": "35490466", "OwnerDisplayName": "user5895251", "Title": "Const char* pointers", "Id": "35490327", "Score": "0", "Body": "<p>I have a miss-understanding with pointers.  </p>\n<pre><code>const char* p = \"Some text\";\nconst char* q = \"Some text\";\nif (p == q)\n    cout &lt;&lt; \"\\nSAME ADDRESS!\";\ncout &lt;&lt; \"\\np = \" &lt;&lt; p; \ncout &lt;&lt; \"\\nq = \" &lt;&lt; q; //same outputs \"Some text\"\n</code></pre>\n<p>In Visual Studio 2015 the syntax <code>if (p == q)</code> doesn't compare addresses, it compares the values... I thought it was supposed to be something like <code>if (*p == *q)</code>.</p>\n<p><em>So how do I compare addresses?</em> I thought using <code>if (&amp;p == &amp;q)</code>, but <a href=\"https://stackoverflow.com/questions/1955775/what-is-the-result-of-pointer\" title=\"it's been said\">it's been said</a> that it would be addresses of pointers, not the address of what they point to. </p>\n", "Tags": "<c++><pointers>", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_35490327_35490471_0": {"section_id": 5361, "quality": 0.875, "length": 14}}, "n3337": {"so_35490327_35490471_0": {"section_id": 5157, "quality": 0.875, "length": 14}}, "n4659": {"so_35490327_35490471_0": {"section_id": 6789, "quality": 0.875, "length": 14}}}, "35490471": {"ParentId": "35490327", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Usually it depends on compiler options (implementation-defined) whether the compiler will store identical string literals as one string literal or separatly.</p>\n<p>So for this code snippet</p>\n<pre><code>const char* p = \"Some text\";\nconst char* q = \"Some text\";\nif (p == q)\n</code></pre>\n<p>the condition in the if statement can either evaluate to true or to false.</p>\n<p>From the C++ Standard (2.14.5 String literals)</p>\n<blockquote>\n<p id=\"so_35490327_35490471_0\">12 Whether all string literals are distinct (that is, are stored in\n  nonoverlapping objects) is implementationdefined. The effect of\n  attempting to modify a string literal is undefined.</p>\n</blockquote>\n<p>Thus in this statement</p>\n<pre><code>if (p == q)\n</code></pre>\n<p>there are indeed compared pointers but the result of the comparison is implementation-defined and in general can be controlled by the programmer by means of setting compiler options.</p>\n", "OwnerUserId": "2877241", "LastEditorUserId": "2877241", "LastEditDate": "2016-02-18T19:24:13.903", "Id": "35490471", "Score": "3", "CreationDate": "2016-02-18T19:16:22.657", "LastActivityDate": "2016-02-18T19:24:13.903"}});