post_cb({"34706615": {"ParentId": "34706564", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>From the C++14 standard (1.7/3):</p>\n<blockquote>\n<p id=\"so_34706564_34706615_0\">Two or more threads of execution (1.10) can update and access separate memory locations without interfering with each other.</p>\n</blockquote>\n<p>Where it previously defines (emphasis mine)</p>\n<blockquote>\n<p id=\"so_34706564_34706615_1\">A memory location is either an object of <strong>scalar</strong> type or a maximal sequence of adjacent bit-fields all having\n  non-zero width.</p>\n</blockquote>\n<p>So the <code>char</code>s of the array are memory locations, but the array itself is not; therefore, separate threads writing to different <code>char</code>s do not interfere with each other.</p>\n", "OwnerUserId": "951890", "LastEditorUserId": "951890", "LastEditDate": "2016-01-10T14:55:06.110", "Id": "34706615", "Score": "6", "CreationDate": "2016-01-10T14:36:52.427", "LastActivityDate": "2016-01-10T14:55:06.110"}, "bq_ids": {"n4140": {"so_34706564_34706615_1": {"section_id": 5787, "quality": 0.9285714285714286, "length": 13}, "so_34706564_34706615_0": {"section_id": 5787, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_34706564_34706615_1": {"section_id": 5560, "quality": 0.9285714285714286, "length": 13}, "so_34706564_34706615_0": {"section_id": 5560, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_34706564_34706615_1": {"section_id": 7244, "quality": 0.9285714285714286, "length": 13}, "so_34706564_34706615_0": {"section_id": 7244, "quality": 0.8571428571428571, "length": 12}}}, "34706564": {"CommentCount": "6", "ViewCount": "106", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-01-10T14:30:57.717", "LastActivityDate": "2016-01-10T14:55:06.110", "Title": "Writing to different offsets in array always well defined", "AcceptedAnswerId": "34706615", "LastEditDate": "2017-05-23T10:27:58.903", "Id": "34706564", "Score": "8", "Body": "<p>In <a href=\"https://stackoverflow.com/a/34700940/144746\">this</a> question it was brought up that writing to two different offsets in a char array concurrently would imply a data race, since some processors such as Alpha don't have byte-wise addressing so it'd be hard to implement this.</p>\n<p>I certainly see that this would very much slow down writing bytes on alpha processors (basically involving a LL/SC), but as I understand the C++ standard every field in an array is its own memory location (although from reading \u00a71.7, I could also see the whole array as one memory location - that's probably what this question boils down to).</p>\n<p>So basically is the following pseudo code</p>\n<pre><code>char arr[10]; // global field\nThread 1:\narr[1] = 0;\nThread 2:\narr[0] = 1;\n</code></pre>\n<p>well defined according to the C++14 standard or not?</p>\n", "Tags": "<c++><multithreading><language-lawyer><c++14>", "OwnerUserId": "144746", "AnswerCount": "1"}});