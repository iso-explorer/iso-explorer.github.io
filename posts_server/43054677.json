post_cb({"43055483": {"ParentId": "43054677", "CommentCount": "0", "Body": "<p>Yes <code>std::call_once</code> is a blocking call.  From [thread.once.callonce] we have</p>\n<blockquote>\n<p id=\"so_43054677_43055483_0\"><em>Effects:</em> An execution of call_once that does not call its <code>func</code> is a passive execution. An execution of call_once that calls its <code>func</code> is an active execution. An active execution shall call <code>INVOKE (DECAY_COPY ( std::forward&lt;Callable&gt;(func)), DECAY_COPY (std::forward&lt;Args&gt;(args))...)</code>. If such a call to func throws an exception the execution is exceptional, otherwise it is returning. An exceptional execution shall propagate the exception to the caller of call_once. Among all executions of <code>call_once</code> for any given <code>once_flag</code>: at most one shall be a returning execution; if there is a returning\n  execution, it shall be the last active execution; and there are passive executions only if there is a returning execution. <strong>[ Note: passive executions allow other threads to reliably observe the results produced by the earlier returning execution. \u2014end note ]</strong></p>\n<p id=\"so_43054677_43055483_1\"><em>Synchronization:</em> For any given <code>once_flag</code>: all active executions occur in a total order; completion of an active execution synchronizes with (1.10) the start of the next one in this total order; <strong>and the returning execution synchronizes with the return from all passive executions.</strong></p>\n</blockquote>\n<p><sup>emphasis mine</sup></p>\n<p>This means that all calls to <code>call_once</code> will wait until the function passed to <code>call_once</code> completes.  In your case that means <code>do_once()</code> must be called before any thread calls <code>print()</code></p>\n", "OwnerUserId": "4342498", "PostTypeId": "2", "Id": "43055483", "Score": "3", "CreationDate": "2017-03-27T20:03:57.357", "LastActivityDate": "2017-03-27T20:03:57.357"}, "43054677": {"CommentCount": "6", "ViewCount": "114", "CreationDate": "2017-03-27T19:17:18.783", "LastActivityDate": "2017-03-27T20:03:57.357", "Title": "Is std::call_once a blocking call?", "AcceptedAnswerId": "43055483", "PostTypeId": "1", "Id": "43054677", "Score": "1", "Body": "<p>I'm using <code>std::call_once</code> in my code to initialize some shared variables only once. The calling code is inside a callback that is triggered by multiple threads.\nWhat I'm interested to know, since I couldn't find it in the documentation is whether <code>std::call_once</code> is blocking essentially as if there was a <code>std::lock_guard</code> instead? \nIn practice it looks like this is the case. </p>\n<p>For example, the following will print <code>\"Done\"</code> before any <code>print()</code> will be called:</p>\n<pre><code>#include &lt;future&gt;\n#include &lt;iostream&gt;\n#include &lt;thread&gt;\n#include &lt;mutex&gt;\n\nstd::once_flag flag;\n\nvoid print()\n{\n    for(int i=0;i&lt;10;i++)\n    {\n          std::cout &lt;&lt; \"Hi, my name is \" &lt;&lt; std::this_thread::get_id() \n            &lt;&lt; \", what?\" &lt;&lt; std::endl;\n    }\n}\n\nvoid do_once()\n{\n    std::cout &lt;&lt; \"sleeping for a while...\" &lt;&lt; std::endl;\n    std::this_thread::sleep_for(std::chrono::milliseconds(500));\n    std::cout &lt;&lt; \"Done\" &lt;&lt; std::endl;\n}\n\nvoid work()\n{\n    std::call_once(flag, [](){ do_once(); });\n    print();\n}\n\n\nint main()\n{\n    auto handle1 = std::async(std::launch::async, work);\n    auto handle2 = std::async(std::launch::async, work);\n    auto handle3 = std::async(std::launch::async, work);\n    auto handle4 = std::async(std::launch::async, work);\n\n    std::this_thread::sleep_for(std::chrono::milliseconds(1000));\n}\n</code></pre>\n<p>I'm assuming this is indeed the case (since I don't see how it could be implemented otherwise), but is this behavior guaranteed or could there be a compiler that decides that <code>std::call_once</code> will indeed be called once but allow other threads to continue and just ignore this call?   </p>\n", "Tags": "<c++><multithreading><c++11><c++-standard-library>", "OwnerUserId": "2523211", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_43054677_43055483_0": {"section_id": 2973, "quality": 0.8421052631578947, "length": 64}, "so_43054677_43055483_1": {"section_id": 2974, "quality": 0.8888888888888888, "length": 24}}, "n3337": {"so_43054677_43055483_0": {"section_id": 2842, "quality": 0.8421052631578947, "length": 64}, "so_43054677_43055483_1": {"section_id": 2843, "quality": 0.8888888888888888, "length": 24}}, "n4659": {"so_43054677_43055483_0": {"section_id": 3732, "quality": 0.8421052631578947, "length": 64}, "so_43054677_43055483_1": {"section_id": 3733, "quality": 0.8888888888888888, "length": 24}}}});