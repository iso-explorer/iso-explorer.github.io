post_cb({"bq_ids": {"n4140": {"so_23304025_23304090_6": {"length": 31, "quality": 0.96875, "section_id": 369}, "so_23304025_23304090_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 3299}, "so_23304025_23304090_2": {"length": 17, "quality": 0.8947368421052632, "section_id": 3298}, "so_23304025_23304090_7": {"length": 5, "quality": 0.8333333333333334, "section_id": 369}, "so_23304025_23304090_4": {"length": 13, "quality": 0.8666666666666667, "section_id": 460}, "so_23304025_23304090_0": {"length": 6, "quality": 1.0, "section_id": 3325}}, "n3337": {"so_23304025_23304090_6": {"length": 31, "quality": 0.96875, "section_id": 359}, "so_23304025_23304090_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 3169}, "so_23304025_23304090_2": {"length": 17, "quality": 0.8947368421052632, "section_id": 3168}, "so_23304025_23304090_7": {"length": 5, "quality": 0.8333333333333334, "section_id": 359}, "so_23304025_23304090_4": {"length": 13, "quality": 0.8666666666666667, "section_id": 451}, "so_23304025_23304090_0": {"length": 6, "quality": 1.0, "section_id": 3195}}, "n4659": {"so_23304025_23304090_6": {"length": 24, "quality": 0.75, "section_id": 381}, "so_23304025_23304090_3": {"length": 13, "quality": 0.7222222222222222, "section_id": 4065}, "so_23304025_23304090_2": {"length": 12, "quality": 0.631578947368421, "section_id": 4063}, "so_23304025_23304090_7": {"length": 5, "quality": 0.8333333333333334, "section_id": 382}, "so_23304025_23304090_4": {"length": 13, "quality": 0.8666666666666667, "section_id": 483}, "so_23304025_23304090_0": {"length": 6, "quality": 1.0, "section_id": 4091}}}, "23304068": {"Id": "23304068", "PostTypeId": "2", "Body": "<p>It's not. The error states that:</p>\n<pre><code>no matching function for call to \u2018test::test(&lt;brace-enclosed initializer list&gt;)\n</code></pre>\n<p>which is what you are trying to do. </p>\n<p>Because G++ is nice, it lists the possible <em>candidates</em>, which include:</p>\n<pre><code>test::test(const test&amp;) &lt;deleted&gt;\n</code></pre>\n<p>It then notes that not only is this deleted, <code>test arg{1};</code> will not work because you cannot convert <code>1</code> to a <code>test</code> object.</p>\n", "LastActivityDate": "2014-04-25T22:24:03.433", "CommentCount": "2", "CreationDate": "2014-04-25T22:24:03.433", "ParentId": "23304025", "Score": "1", "OwnerUserId": "1783614"}, "23304770": {"Id": "23304770", "PostTypeId": "2", "Body": "<p>It's a gcc bug, see <a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=52707\" rel=\"nofollow\">Bug 52707 - C++11 Deleted special member function prevent type being an aggregate </a>. gcc erroneously thinks the class is not an aggregate any more, if it has a deleted special member function (like a deleted copy constructor).</p>\n<p>This seems to have been fixed in g++4.9.0</p>\n", "LastEditorUserId": "420683", "LastActivityDate": "2014-04-25T23:46:12.890", "Score": "3", "CreationDate": "2014-04-25T23:38:06.347", "ParentId": "23304025", "CommentCount": "1", "OwnerUserId": "420683", "LastEditDate": "2014-04-25T23:46:12.890"}, "23304090": {"Id": "23304090", "PostTypeId": "2", "Body": "<p>You seem to have two questions here.  The title asks about <em>default-initialization</em>, and your code uses <em>list-initialization</em>.</p>\n<hr>\n<p>You were relying on list initialization, not default initialization, and specifically you are trying to get aggregate initialization.  The rules for that are found in 8.5.4p3:</p>\n<blockquote>\n<p id=\"so_23304025_23304090_0\">List-initialization of an object or reference of type <code>T</code> is defined as follows:</p>\n<ul>\n<li>If <code>T</code> is an aggregate, aggregate initialization is performed (8.5.1).</li>\n</ul>\n<p id=\"so_23304025_23304090_1\">...</p>\n<ul>\n<li>Otherwise, if <code>T</code> is a class type, constructors are considered.  The applicable constructors are enumerated and the best one is chosen through overload resolution (13.3, 13.3.1.7).  If a narrowing conversion (see below) is required to convert any of the arguments, the program is ill-formed.</li>\n</ul>\n</blockquote>\n<p>and in 8.5.1:</p>\n<blockquote>\n<p id=\"so_23304025_23304090_2\">An  aggregate  is  an  array  or  a  class  (Clause  9)  with  no  user-provided  constructors  (12.1),  no  private  or protected non-static data members (Clause 11), no base classes (Clause 10), and no virtual functions (10.3).</p>\n<p id=\"so_23304025_23304090_3\">When an aggregate is initialized by an initializer list, as specified in 8.5.4, <strong>the elements of the initializer list are taken as initializers for the members of the aggregate, in increasing subscript or member order.</strong></p>\n</blockquote>\n<p>That's exactly what you want, but having a \"user-provided constructor\" disables that.  This is not the same as a \"user-declared constructor\", but some compiler writers may have confused the two (see <a href=\"https://stackoverflow.com/a/23304770/103167\">@dyp's answer</a>).</p>\n<p>As far as I know, there's no way to explicitly enable aggregate initialization for a type that isn't an aggregate.  However you <em>can</em> work around this.  Make your type an aggregate, and disable copy-construction another way:</p>\n<pre><code>struct test\n{\n  const int index;\n  struct nocopy { nocopy() = default; nocopy(const nocopy&amp;) = delete; } copy_disabled;\n};\n</code></pre>\n<p>This works because 12.8p11 says:</p>\n<blockquote>\n<p id=\"so_23304025_23304090_4\">An implicitly-declared copy/move constructor is an inline public member of its class.  A defaulted copy/move constructor for a class X is defined as deleted (8.4.3) if X has:</p>\n<p id=\"so_23304025_23304090_5\">...</p>\n<ul>\n<li>a  non-static  data  member  of  class  type <code>M</code> (or  array  thereof)  that  cannot  be  copied/moved  because overload resolution (13.3),  as applied to <code>M</code>'s corresponding constructor,  results in an ambiguity or a function that is deleted or inaccessible from the defaulted constructor,</li>\n</ul>\n</blockquote>\n<p>Note however that you can't just inherit from <code>boost::noncopyable</code>, because aggregates cannot have base classes.</p>\n<hr>\n<p>The case dealing with default initialization is a bit easier.  Recall the condition for having a compiler-declared default constructor:</p>\n<ul>\n<li>There are no user-declared constructors.</li>\n</ul>\n<p>Since you've declared a constructor (and defined it as deleted), you've also gotten rid of the defaulted default constructor.</p>\n<p>This rule comes from 12.1p4 in the Standard:</p>\n<blockquote>\n<p id=\"so_23304025_23304090_6\">A default constructor for a class <code>X</code> is a constructor of class <code>X</code> that can be called without an argument.  <strong>If there is no user-declared constructor for class <code>X</code>, a constructor having no parameters is implicitly declared as defaulted</strong> (8.4).  An implicitly-declared default constructor is an <code>inline public</code> member of its class.  A defaulted default constructor for class <code>X</code> is de\ufb01ned as deleted if ...</p>\n</blockquote>\n<p>Since default initialization relies on the compiler-declared default constructor, it works if and only if there is no user-declared constructor.</p>\n<p>You can fix this by making the default constructor explicitly declared as defaulted, like so:</p>\n<pre><code>struct test\n{\n  const int index;\n  test(void) = default; // &lt;-- ADD THIS\nprivate:\n  test(const test&amp;) = delete;\n};\n</code></pre>\n<p>But this doesn't work in your situation, the defaulted default constructor is deleted because the rule continues with</p>\n<blockquote>\n<p id=\"so_23304025_23304090_7\">A defaulted default constructor for class X is de\ufb01ned as deleted if ...</p>\n<ul>\n<li>any non-variant non-static data member of <code>const</code>-qualified type (or array thereof) with no <em>brace-or-equal-initializer</em> does not have a user-provided default constructor,</li>\n</ul>\n</blockquote>\n</hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2014-04-26T16:51:09.577", "Score": "6", "CreationDate": "2014-04-25T22:25:44.630", "ParentId": "23304025", "CommentCount": "10", "OwnerUserId": "103167", "LastEditDate": "2017-05-23T11:49:25.250"}, "23304025": {"ViewCount": "353", "Body": "<p>Can someone explain to me why the below does not compile?  I'm not sure why the compiler thinks I'm invoking the copy constructor.</p>\n<pre><code>struct test {\n  const int index;\n private:\n  test(const test&amp;) = delete; // comment out this line and voila.\n};\n\nint main(int argc, char** argv) {\n  test arg{1};\n  return arg.index;\n}\n</code></pre>\n<p>GCC fails with this message (reproducible in <a href=\"http://www.compileonline.com/compile_cpp11_online.php\" rel=\"nofollow\">http://www.compileonline.com/compile_cpp11_online.php</a>)</p>\n<pre><code>main.cpp: In function \u2018int main(int, char**)\u2019:\nmain.cpp:8:13: error: no matching function for call to \u2018test::test(&lt;brace-enclosed initializer list&gt;)\u2019\n   test arg{1};\n             ^\nmain.cpp:8:13: note: candidate is:\nmain.cpp:4:3: note: test::test(const test&amp;) &lt;deleted&gt;\n   test(const test&amp;) = delete;\n   ^\nmain.cpp:4:3: note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018const test&amp;\u2019\n</code></pre>\n", "AcceptedAnswerId": "23304090", "Title": "Why would the default Initialization fail when copy constructor is deleted?", "CreationDate": "2014-04-25T22:20:03.910", "Id": "23304025", "CommentCount": "1", "PostTypeId": "1", "LastActivityDate": "2014-04-26T16:51:09.577", "Score": "1", "OwnerUserId": "3574684", "Tags": "<c++><c++11>", "AnswerCount": "3"}});