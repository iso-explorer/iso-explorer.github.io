post_cb({"24167823": {"Id": "24167823", "PostTypeId": "2", "Body": "<p>A destructor is code that is executed when an object is destroyed... period. </p>\n<p>What goes in the destructor depends on the semantics associated to the object.</p>\n<p><em>Typical stuff</em> that go in the destructor (but might go elsewhere, e.g. think of a pooled object) are</p>\n<ol>\n<li>Deallocate all the memory the objects currently own (note that it might have allocated memory but transferred its ownership).</li>\n<li>Release all the resources the object has acquired.</li>\n<li>....</li>\n</ol>\n<p>The exception is that you must declare a <em>virtual</em> destructor, even if empty when in a hierachy of classes, you would need to be able destroy objects of child classes from a pointer to the parent class.</p>\n<p>The compiler will provide a default destructor for you if you don't define one.\nIn addition, attributes contained within the class will get their destructor called automatically after the (implicit/explicit) class destructor is run.</p>\n", "LastEditorUserId": "308705", "LastActivityDate": "2014-06-11T16:24:27.453", "Score": "1", "CreationDate": "2014-06-11T16:17:35.910", "ParentId": "24167652", "CommentCount": "0", "OwnerUserId": "308705", "LastEditDate": "2014-06-11T16:24:27.453"}, "24167737": {"Id": "24167737", "PostTypeId": "2", "Body": "<p>When memory is accounted for at compile-time (i.e. no memory is allocated at run-time), then a destructor CAN be created, but this is not necessary. In such instances, a destructor for the class is implied by the class' definition; a destructor will be supplied for you behind the scenes, and memory will be freed when instances of the class go out of scope.</p>\n<p>EDIT: a simple, handy tutorial can be found here - <a href=\"http://www.learncpp.com/cpp-tutorial/86-destructors/\" rel=\"nofollow\">http://www.learncpp.com/cpp-tutorial/86-destructors/</a></p>\n", "LastActivityDate": "2014-06-11T16:12:44.000", "CommentCount": "0", "CreationDate": "2014-06-11T16:12:44.000", "ParentId": "24167652", "Score": "1", "OwnerUserId": "1732865"}, "bq_ids": {"n4140": {"so_24167652_24167902_6": {"length": 6, "quality": 1.0, "section_id": 369}, "so_24167652_24167902_14": {"length": 6, "quality": 0.6, "section_id": 401}, "so_24167652_24167902_12": {"length": 6, "quality": 1.0, "section_id": 369}, "so_24167652_24167902_7": {"length": 11, "quality": 0.8461538461538461, "section_id": 369}, "so_24167652_24167902_3": {"length": 12, "quality": 0.8, "section_id": 400}, "so_24167652_24167902_8": {"length": 6, "quality": 0.6, "section_id": 401}, "so_24167652_24167902_13": {"length": 11, "quality": 0.8461538461538461, "section_id": 369}, "so_24167652_24167902_15": {"length": 12, "quality": 0.9230769230769231, "section_id": 401}, "so_24167652_24167902_9": {"length": 12, "quality": 0.9230769230769231, "section_id": 401}, "so_24167652_24167902_1": {"length": 12, "quality": 0.8, "section_id": 400}}, "n3337": {"so_24167652_24167902_6": {"length": 6, "quality": 1.0, "section_id": 359}, "so_24167652_24167902_12": {"length": 6, "quality": 1.0, "section_id": 359}, "so_24167652_24167902_14": {"length": 9, "quality": 0.9, "section_id": 392}, "so_24167652_24167902_1": {"length": 12, "quality": 0.8, "section_id": 391}, "so_24167652_24167902_7": {"length": 12, "quality": 0.9230769230769231, "section_id": 392}, "so_24167652_24167902_3": {"length": 12, "quality": 0.8, "section_id": 391}, "so_24167652_24167902_8": {"length": 9, "quality": 0.9, "section_id": 392}, "so_24167652_24167902_15": {"length": 12, "quality": 0.9230769230769231, "section_id": 392}, "so_24167652_24167902_9": {"length": 12, "quality": 0.9230769230769231, "section_id": 392}, "so_24167652_24167902_13": {"length": 12, "quality": 0.9230769230769231, "section_id": 392}}, "n4659": {"so_24167652_24167902_6": {"length": 6, "quality": 1.0, "section_id": 418}, "so_24167652_24167902_12": {"length": 6, "quality": 1.0, "section_id": 418}, "so_24167652_24167902_14": {"length": 6, "quality": 0.6, "section_id": 418}, "so_24167652_24167902_1": {"length": 12, "quality": 0.8, "section_id": 417}, "so_24167652_24167902_7": {"length": 11, "quality": 0.8461538461538461, "section_id": 382}, "so_24167652_24167902_3": {"length": 12, "quality": 0.8, "section_id": 417}, "so_24167652_24167902_8": {"length": 6, "quality": 0.6, "section_id": 418}, "so_24167652_24167902_15": {"length": 12, "quality": 0.9230769230769231, "section_id": 418}, "so_24167652_24167902_9": {"length": 12, "quality": 0.9230769230769231, "section_id": 418}, "so_24167652_24167902_13": {"length": 11, "quality": 0.8461538461538461, "section_id": 382}}}, "24167691": {"Id": "24167691", "PostTypeId": "2", "Body": "<p>Destructor's main purpose is to release used memory from heap or to delete links to other objects, etc. You do not allocate memory from heap here, you do not make any relations between objects, so no destructor is needed.</p>\n", "LastActivityDate": "2014-06-11T16:10:07.583", "CommentCount": "0", "CreationDate": "2014-06-11T16:10:07.583", "ParentId": "24167652", "Score": "1", "OwnerUserId": "2946480"}, "24167803": {"Id": "24167803", "PostTypeId": "2", "Body": "<ul>\n<li><p>Although if you don't define one, the language will define a destructor for you. </p></li>\n<li><p>Generally, is a good idea to define your destructor as <code>virtual</code>, in order to assure that things will be OK if someone inherits from your class.</p></li>\n<li><p>However, it is mandatory to define your destructor if you allocate dynamically memory in your constructors, and make sure that any allocated memory will be deleted in it, in order to avoid memory leaks.</p></li>\n<li><p>Another suggestion is that if your compiler supports C++11 features, it would be for the best to avoid raw pointers for your memory allocations and use smart pointers (i.e., RAII). Thus, you will not have to delete any previously allocated memory in your destructors. </p></li>\n</ul>\n", "LastEditorUserId": "2352671", "LastActivityDate": "2014-06-11T16:22:12.227", "Score": "1", "CreationDate": "2014-06-11T16:16:38.393", "ParentId": "24167652", "CommentCount": "0", "OwnerUserId": "2352671", "LastEditDate": "2014-06-11T16:22:12.227"}, "24169065": {"Id": "24169065", "PostTypeId": "2", "Body": "<p>You might also want to look at the \"Rule Of Three\" \nThe rule of three (also known as the Law of The Big Three or The Big Three) is a rule of thumb in C++ that claims that if a class defines one of the following it should probably explicitly define all three:</p>\n<p>destructor,\ncopy constructor,\ncopy assignment operator,\nWikipedia Link: <a href=\"http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29\" rel=\"nofollow\">http://en.wikipedia.org/wiki/Rule_of_three_(C%2B%2B_programming)</a></p>\n", "LastActivityDate": "2014-06-11T17:29:22.537", "CommentCount": "0", "CreationDate": "2014-06-11T17:29:22.537", "ParentId": "24167652", "Score": "1", "OwnerUserId": "3224160"}, "24167652": {"ViewCount": "5207", "Body": "<pre><code>class Point    \n{\npublic:\n    float x,y;\n    Point() {}\n    Point(float,float);\n    Point operator + (Point);\n    Point operator * (double);\n    void rotate_p(float);\n    void render_p(Point*);\n    void sub(float);\n    float get_dist();//get_distance\n};\n</code></pre>\n<p>As you can see this class has no pointers as <em>non-static</em> <em>data-members</em>, so I think I can just use the default destructor; is this accurate?</p>\n<hr>\n<h3>Question</h3>\n<ul>\n<li>When do I need to declare my own destructor?</li>\n</ul>\n</hr>", "AcceptedAnswerId": "24167902", "Title": "When do I need to declare my own destructor?", "CreationDate": "2014-06-11T16:07:35.763", "Id": "24167652", "CommentCount": "5", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2014-06-11T16:53:42.727", "LastEditorUserId": "1090079", "LastActivityDate": "2014-06-11T17:29:22.537", "Score": "14", "OwnerUserId": "2626111", "Tags": "<c++><class><destructor>", "AnswerCount": "6"}, "24167902": {"Id": "24167902", "PostTypeId": "2", "Body": "<h3>Introduction</h3>\n<p>Since data-members with <em>automatic-storage duration</em> have their lifetime bound to that of the instance having them, there's no need for you to call their destructor explicitly; they will always be destroyed whenever the instance of the class is.</p>\n<hr>\n<h3>When do I normally need to declare my own destructor?</h3>\n<p>Normally you will have to explicitly declare your own destructor if:</p>\n<ul>\n<li><p>You are declaring a class which is supposed to serve as a base for inheritance involving polymorphism, if you do you'll need a <em>virtual destructor</em> to make sure that the destructor of a <em>Derived</em> class is called upon destroying it through a pointer/reference to <em>Base</em>.</p></li>\n<li><p>You need to release resourced aquired by the class during its leftime</p>\n<ul>\n<li><p><strong>Example 1</strong>: The class has a handle to a file, this needs to be closed when the object destructs; the destructor is the perfect location.</p></li>\n<li><p><strong>Exempel 2</strong>: The class owns an object with <em>dynamic-storage duration</em>, since the lifetime of the object can potentially live on long after the class instance has been destroyed you'll need to explicitly destroy it in the destructor.</p></li>\n</ul></li>\n</ul>\n<hr>\n<h3>The implicitly generated destructor</h3>\n<p>Unless you explicitly declare your own destructor, an implicitly generated destructor will be created for you by the compiler.</p>\n<blockquote>\n<p id=\"so_24167652_24167902_0\"><code>14.4p4</code> <strong>Destructors</strong> <code>[class.dtor]</code></p>\n<blockquote>\n<p id=\"so_24167652_24167902_3\">If a class has no user-declared destructor, a destructor is\n    implicitly declares as defaulted (8.4). An implicitly declared\n    destructor is an inline public member of its class.</p>\n</blockquote>\n<p id=\"so_24167652_24167902_2\"><sup>src: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf</a></sup></p>\n</blockquote>\n<p><br/></p>\n<p>There are however some rare/advanced cases where the compiler will refuse to generate a destructor for you, under these cases you <strong>must</strong> explicitly declare your own, or make sure that the destructor for your class instance is never called; because in order to destroy an object, a destructor is neccessary.</p>\n<blockquote>\n<p id=\"so_24167652_24167902_4\"><code>14.4p5</code> <strong>Destructors</strong> <code>[class.dtor]</code></p>\n<blockquote>\n<p id=\"so_24167652_24167902_11\">A default destructor for a class X is defined as delete if:</p>\n<ul>\n<li><p id=\"so_24167652_24167902_12\"><em>X</em> is a union-like class that has a variant member with a non-trivial\n    destructor,</p></li>\n<li><p id=\"so_24167652_24167902_13\">any of the non-static data members has class type <em>M</em> (or array\n    thereof) and <em>M</em> has a deleted destructor or a destructor that is\n    inaccessible from the default destructor,</p></li>\n<li><p id=\"so_24167652_24167902_14\">any direct or virtual base class has a deleted destructor or a\n    destructor that is inaccessible from the default destructor,</p></li>\n<li><p id=\"so_24167652_24167902_15\">or, for a virtual destructor, lookup of the non-array deallocation\n    function results in an ambiguity or in a function that is deleted\n    or inaccessible from the default destructor.</p></li>\n</ul>\n</blockquote>\n<p id=\"so_24167652_24167902_10\"><sup>src: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf</a></sup></p>\n</blockquote>\n<hr>\n<p>More can be read under the following link:</p>\n<ul>\n<li><a href=\"http://en.cppreference.com/w/cpp/language/destructor\"><strong>cppreference.com</strong> - Destructors</a></li>\n</ul>\n</hr></hr></hr>", "LastEditorUserId": "1090079", "LastActivityDate": "2014-06-11T16:41:01.637", "Score": "11", "CreationDate": "2014-06-11T16:21:34.220", "ParentId": "24167652", "CommentCount": "0", "OwnerUserId": "1090079", "LastEditDate": "2014-06-11T16:41:01.637"}});