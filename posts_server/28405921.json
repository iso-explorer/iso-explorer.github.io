post_cb({"28405921": {"CommentCount": "2", "ViewCount": "984", "CreationDate": "2015-02-09T08:56:01.100", "LastActivityDate": "2015-02-10T09:54:53.880", "Title": "Overload resolution, templates and inheritance", "AcceptedAnswerId": "28406090", "PostTypeId": "1", "Id": "28405921", "Score": "19", "Body": "<pre><code>#include &lt;iostream&gt;\n\nstruct A {};\nstruct B : public A {};\n\ntemplate&lt;typename T&gt;\nvoid foo(const T &amp;x) { std::cout &lt;&lt; \"Called template\" &lt;&lt; std::endl; }\n\nvoid foo(const A &amp;a) { std::cout &lt;&lt; \"Called A\" &lt;&lt; std::endl; }\n\nint main()\n{\n    foo(A());\n    foo(B());\n    return 0;\n}\n</code></pre>\n<p>This prints:</p>\n<pre><code>Called A\nCalled template\n</code></pre>\n<p>I was under the impression that a suitable non-template function would always be chosen over a template function. Can someone explain to me the resolution steps that lead to this somewhat surprising result?</p>\n", "Tags": "<c++><templates><overload-resolution>", "OwnerUserId": "436418", "AnswerCount": "3"}, "28406617": {"ParentId": "28405921", "PostTypeId": "2", "CommentCount": "1", "Body": "<blockquote>\n<p id=\"so_28405921_28406617_0\">Can someone explain to me the resolution steps that lead to this somewhat surprising result?</p>\n</blockquote>\n<p>you may look at <strong>Overload Resolution</strong> at cppreference.com:\n<a href=\"http://en.cppreference.com/w/cpp/language/overload_resolution\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/overload_resolution</a> </p>\n<p>in particular see the section <em>Ranking of implicit conversion sequences</em></p>\n<p><em>Extension of the Answer:</em></p>\n<p>I tried to provide more clarification with an excerpt of the information from the aforementioned link:</p>\n<blockquote>\n<p id=\"so_28405921_28406617_1\">A function template by itself is not a type, or a function, or any other entity. No code is generated from a source file that contains only template definitions. In order for any code to appear, a template must be instantiated: the template arguments must be determined so that the compiler can generate an actual function (or class, from a class template).</p>\n</blockquote>\n<p>For that, the compiler goes through:</p>\n<ul>\n<li>function template name lookup</li>\n<li>template argument deduction</li>\n</ul>\n<p>Down to here, the compiler has a couple of <em>candidate</em> function definitions which can handle the specific function call. These candidates are <em>instannces</em> of the template function as well as relevant non-template function definitions in the program.</p>\n<p>But the answer to your question lies in fact here:</p>\n<blockquote>\n<p id=\"so_28405921_28406617_2\">Template argument deduction takes place after the function template name lookup (which may involve argument-dependent lookup) and <strong>before</strong> overload resolution.</p>\n</blockquote>\n<p>The fact that function overload resolution is performed after template function instantiation is the reason for the ouput of your code.</p>\n<p>Now your specific case goes through overload resolution as the following:</p>\n<blockquote>\n<p id=\"so_28405921_28406617_3\"><strong>Overload Resolution:</strong></p>\n<p id=\"so_28405921_28406617_4\">If the [previous] steps produce more than one candidate function, then overload resolution is performed to select the function that will actually be called. In general, the candidate function whose parameters match the arguments most closely is the one that is called. \n  .\n  .\n  .</p>\n<p id=\"so_28405921_28406617_5\">...<br>\n  F1 is determined to be a better function than F2 if implicit conversions for all arguments of F1 are not worse than the implicit conversions for all arguments of F2, and<br>\n     1) there is at least one argument of F1 whose implicit conversion is better than the corresponding implicit conversion for that argument of F2<br>\n  ...\n  .<br>\n  .<br>\n  .<br>\n<em>Ranking of implicit conversion sequences:</em></br></br></br></br></br></br></p>\n<p id=\"so_28405921_28406617_6\">Each type of standard conversion sequence is assigned one of three ranks:<br>\n  1) Exact match: no conversion required, lvalue-to-rvalue conversion, qualification conversion, user-defined conversion of class type to the same class<br>\n  2) Promotion: integral promotion, floating-point promotion<br>\n  3) Conversion: integral conversion, floating-point conversion, floating-integral conversion, pointer conversion, pointer-to-member conversion, boolean conversion, <strong>user-defined conversion of a derived class to its base</strong></br></br></br></p>\n<p id=\"so_28405921_28406617_7\">The rank of the standard conversion sequence is the worst of the ranks of the standard conversions it holds (there may be up to three conversions)</p>\n<p id=\"so_28405921_28406617_8\">Binding of a reference parameter directly to the argument expression is either Identity or a derived-to-base Conversion:</p>\n</blockquote>\n<pre class=\"lang-c++ prettyprint-override\"><code>struct Base {};\nstruct Derived : Base {} d;\nint f(Base&amp;);    // overload #1\nint f(Derived&amp;); // overload #2\nint i = f(d); // d -&gt; Derived&amp; has rank Exact Match\n              // d -&gt; Base&amp; has rank Conversion\n              // calls f(Derived&amp;)\n</code></pre>\n", "OwnerUserId": "1738000", "LastEditorUserId": "1738000", "LastEditDate": "2015-02-10T09:54:53.880", "Id": "28406617", "Score": "2", "CreationDate": "2015-02-09T09:37:42.230", "LastActivityDate": "2015-02-10T09:54:53.880"}, "28406267": {"ParentId": "28405921", "CommentCount": "0", "Body": "<p>n3376 13.3.3.1/6</p>\n<blockquote>\n<p id=\"so_28405921_28406267_0\">When the parameter has a class type and the argument expression has a\n  derived class type, the implicit conversion sequence is a\n  derived-to-base Conversion from the derived class to the base class.</p>\n</blockquote>\n<p>n3376 13.3.3.1/8</p>\n<blockquote>\n<p id=\"so_28405921_28406267_1\">If no conversions are required to match an argument to a parameter\n  type, the implicit conversion sequence is the standard conversion\n  sequence consisting of the identity conversion (13.3.3.1.1).</p>\n</blockquote>\n<p>Identity conversion has exact match rank due table in 13.3.3.1.1/table 12, but derived-to-base is worse, than identity.</p>\n<p>So, compiler just have candidates in first case</p>\n<pre><code>// template after resolving\nvoid foo(const A&amp;)\n\n// non-template\nvoid foo(const A&amp;)\n</code></pre>\n<p>Both has identity rank, but since first is function-template, second will be chosen.\nAnd in second case</p>\n<pre><code>// template after resolving\nvoid foo(const B&amp;)\n\n// non-template\nvoid foo(const A&amp;)\n</code></pre>\n<p>Only first has identity rank and will be chosen.</p>\n", "OwnerUserId": "1498580", "PostTypeId": "2", "Id": "28406267", "Score": "5", "CreationDate": "2015-02-09T09:18:49.067", "LastActivityDate": "2015-02-09T09:18:49.067"}, "bq_ids": {"n4140": {"so_28405921_28406267_1": {"section_id": 613, "quality": 0.9333333333333333, "length": 14}, "so_28405921_28406267_0": {"section_id": 611, "quality": 1.0, "length": 18}, "so_28405921_28406617_8": {"section_id": 625, "quality": 0.8, "length": 8}}, "n3337": {"so_28405921_28406267_1": {"section_id": 603, "quality": 0.9333333333333333, "length": 14}, "so_28405921_28406267_0": {"section_id": 601, "quality": 1.0, "length": 18}, "so_28405921_28406617_8": {"section_id": 615, "quality": 0.8, "length": 8}}, "n4659": {"so_28405921_28406267_1": {"section_id": 639, "quality": 0.9333333333333333, "length": 14}, "so_28405921_28406267_0": {"section_id": 637, "quality": 1.0, "length": 18}, "so_28405921_28406617_8": {"section_id": 651, "quality": 0.8, "length": 8}}}, "28406090": {"ParentId": "28405921", "PostTypeId": "2", "CommentCount": "4", "Body": "<blockquote>\n<p id=\"so_28405921_28406090_0\">I was under the impression that a suitable non-template function would always be chosen over a template function.</p>\n</blockquote>\n<p>This only holds if the template and the non-template are <em>equally good</em> candidates. That's why the non-template is chosen for <code>foo(A())</code>.</p>\n<p>However, in the case of <code>foo(B())</code>, using the non-template requires a derived-to-base conversion. So the function template is strictly better, and hence it's chosen.</p>\n<p>The <code>foo</code> template instantiates into <code>void foo(const B&amp;)</code>. Consider what it would look like without templates:</p>\n<pre><code>void foo(const B &amp;x) { std::cout &lt;&lt; \"Called template\" &lt;&lt; std::endl; }\n\nvoid foo(const A &amp;a) { std::cout &lt;&lt; \"Called A\" &lt;&lt; std::endl; }\n</code></pre>\n<p>I believe you'll agree calling <code>foo(B())</code> should unambiguously pick the first one. That's exactly why the template is chosen.</p>\n", "OwnerUserId": "1782465", "LastEditorUserId": "1782465", "LastEditDate": "2015-02-09T09:16:06.680", "Id": "28406090", "Score": "15", "CreationDate": "2015-02-09T09:06:39.157", "LastActivityDate": "2015-02-09T09:16:06.680"}});