post_cb({"bq_ids": {"n4140": {"so_42276302_42276668_2": {"length": 30, "quality": 0.9375, "section_id": 6169}, "so_42276302_42276668_1": {"length": 4, "quality": 0.8, "section_id": 3296}, "so_42276302_42276668_3": {"length": 16, "quality": 0.8421052631578947, "section_id": 6171}, "so_42276302_42276668_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 6169}}, "n3337": {"so_42276302_42276668_2": {"length": 30, "quality": 0.9375, "section_id": 5930}, "so_42276302_42276668_1": {"length": 4, "quality": 0.8, "section_id": 3166}, "so_42276302_42276668_3": {"length": 16, "quality": 0.8421052631578947, "section_id": 5932}, "so_42276302_42276668_0": {"length": 33, "quality": 0.9705882352941176, "section_id": 5930}}, "n4659": {"so_42276302_42276668_1": {"length": 4, "quality": 0.8, "section_id": 4058}, "so_42276302_42276668_3": {"length": 16, "quality": 0.8421052631578947, "section_id": 7669}, "so_42276302_42276668_0": {"length": 25, "quality": 0.7352941176470589, "section_id": 7667}}}, "42276668": {"Id": "42276668", "PostTypeId": "2", "Body": "<p>From standard, 5.16.</p>\n<blockquote>\n<p id=\"so_42276302_42276668_0\">if the second and third operand have different types, and either has\n  (possibly cv-qualified) class type, an attempt is made to convert each\n  of those operands to the type of the other. The process for determining whether an operand expression E1 of type T1 can be converted to\n  match an operand expression E2 of type T2 is defined as follows:</p>\n<p id=\"so_42276302_42276668_1\">If E2 is an rvalue, or if the conversion above cannot be done:</p>\n<p id=\"so_42276302_42276668_2\">Otherwise (i.e., if E1 or E2 has a nonclass type, or if they both have\n  class types but the underlying classes are not either the same or one\n  a base class of the other): E1 can be converted to match E2 if E1 can\n  be implicitly converted to the type that expression E2 would have if\n  E2 were converted to an rvalue (or the type it has, if E2 is an\n  rvalue).</p>\n<p id=\"so_42276302_42276668_3\">If the second and third operand do not have the same type, and either\n  has (possibly cv-qualified) class type, overload resolution is used to\n  determine the conversions (if any) to be applied to the operands\n  (13.3.1.2, 13.6).</p>\n</blockquote>\n<p>So, here, 0 is rvalue and it has type <code>int</code>. Compiler will try to convert first argument to <code>int</code> and it will do that, cause that can be done, due to your conversion operator.</p>\n", "LastEditorUserId": "4850040", "LastActivityDate": "2017-02-16T16:41:50.033", "Score": "6", "CreationDate": "2017-02-16T14:26:09.897", "ParentId": "42276302", "CommentCount": "0", "LastEditDate": "2017-02-16T16:41:50.033", "OwnerUserId": "1498580"}, "42276302": {"ViewCount": "98", "Body": "<p>I cannot understand this ternary operator's conversion logic (here is an example):</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;typeinfo&gt;\n#include &lt;unistd.h&gt;\n#include &lt;cxxabi.h&gt;\n#include &lt;climits&gt;\n\ntemplate&lt;typename T&gt;\nstruct singletime\n{\nprivate:\n    T               value;\npublic: \n    T&amp; operator()() {return this-&gt;value;}\n\n    operator const  T&amp; () const {return value;}\n    unsigned char   flag_needed_for_all_types;\n};\n\nstatic void getvalue1 (uint64_t value, const char *call)\n{\n    std::cout &lt;&lt; call &lt;&lt; \": \\t\" &lt;&lt; value &lt;&lt; std::endl &lt;&lt; std::endl;\n}\n\n#define getvalue(x, str) \\\nstd::cout &lt;&lt; typeid(x).name() &lt;&lt; std::endl; \\\ngetvalue1(x, str);\n\nint main (int argc, char *argv[])\n{\n    bool flag = true;\n    singletime&lt;uint64_t&gt; singletime_64;\n    singletime_64() = INT_MAX+1lu;\n\n    uint64_t value_64 = singletime_64;\n\n    getvalue (flag ? singletime_64 : 0, \"Ternary with singletime, &gt; INT_MAX\");\n    getvalue (singletime_64, \"singletime w/o ternary, &gt; INT_MAX\");\n\n    getvalue (flag ? value_64 : 0, \"Ternary with uint64_t, &gt; INT_MAX\");\n    getvalue (value_64, \"uint64_t w/o ternary, &gt; INT_MAX\");\n\n\n    singletime_64() = INT_MAX;\n\n    uint64_t value_64_l = singletime_64;\n\n    getvalue (flag ? singletime_64 : 0, \"Ternary with singletime, &lt;= INT_MAX\");\n    getvalue (singletime_64, \"singletime w/o ternary, &lt;= INT_MAX\");\n\n    getvalue (flag ? value_64_l : 0, \"Ternary with uint64_t, &lt;= INT_MAX\");\n    getvalue (value_64_l, \"uint64_t w/o ternary, &lt;= INT_MAX\");\n\n    return 0;\n}\n</code></pre>\n<p>I have a template class <code>singletime&lt;T&gt;</code>, which is a wrapper of any type, used for cases, not related to this question and has a conversion operator to <code>T</code>. The issue is when <code>singletime&lt;uint64_t&gt;</code> is used in a ternary operator expression.</p>\n<p>This is the problematic line:</p>\n<pre><code>getvalue (flag ? singletime_64 : 0, \"Ternary with singletime, &gt; INT_MAX\");\n</code></pre>\n<p>The 64-bit value is converted to int and if the value is above <code>INT_MAX</code>, it becomes incorrect.</p>\n<p>The example prints some usage types of the ternary operator - with the resulting type of the expression and resulting value.<br>\nHere is the output of the example:</br></p>\n<pre><code>int\nTernary with singletime, &gt; INT_MAX:     18446744071562067968\n\nsingletime&lt;unsigned long&gt;\nsingletime w/o ternary, &gt; INT_MAX:  2147483648\n\nunsigned long\nTernary with uint64_t, &gt; INT_MAX:   2147483648\n\nunsigned long\nuint64_t w/o ternary, &gt; INT_MAX:    2147483648\n\nint\nTernary with singletime, &lt;= INT_MAX:    2147483647\n\nsingletime&lt;unsigned long&gt;\nsingletime w/o ternary, &lt;= INT_MAX:     2147483647\n\nunsigned long\nTernary with uint64_t, &lt;= INT_MAX:  2147483647\n\nunsigned long\nuint64_t w/o ternary, &lt;= INT_MAX:   2147483647\n</code></pre>\n<p>The only problem is when the ternary operator is used with <code>singletime&lt;uint64_t&gt;</code> - it gets the value 18446744071562067968</p>\n<p>As I understand, it tries to convert different types to one type.</p>\n<p>As there is conversion operator from <code>singletime&lt;uint64_t&gt;</code> to <code>uint64_t</code>, it maybe uses it, but after that I don't understand why it converts both values to int, instead of <code>uint64_t</code>? In examples where <code>uint64_t</code> is used instead of <code>singletime&lt;uint64_t&gt;</code>, the int is converted to <code>uint64_t</code> and no values are lost</p>\n<p>In the case of <code>singletime&lt;uint64_t&gt;</code> and int, there is also no compiler warning about cast to smaller type and potential data loss.</p>\n<p>Tried with gcc 4.8.2 and gcc 5.2.0</p>\n", "Title": "c++ ternary operator conversion understanding", "CreationDate": "2017-02-16T14:10:14.347", "LastActivityDate": "2017-02-16T16:41:50.033", "CommentCount": "0", "LastEditDate": "2017-02-16T16:04:39.673", "PostTypeId": "1", "LastEditorUserId": "6178493", "Id": "42276302", "Score": "3", "OwnerUserId": "935512", "Tags": "<c++><implicit-conversion>", "AnswerCount": "1"}});