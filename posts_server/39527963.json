post_cb({"39527963": {"CommentCount": "2", "ViewCount": "80", "CreationDate": "2016-09-16T09:25:28.100", "LastActivityDate": "2016-09-19T06:11:10.163", "Title": "Why throw at derived class catches by base?", "AcceptedAnswerId": "39566416", "PostTypeId": "1", "Id": "39527963", "Score": "1", "Body": "<p>For the code below, result is \"EA Exception Finished\", which means although we threw at derived class it caught by base class. Is it always? And if so, how can I make the derived class catches, thus \"EB Exception Finished\" appears?</p>\n<p>Also I can't exactly get what does it mean by <code>throw EB()</code> and <code>catch(EA&amp;)</code>. And does <code>catch(EA&amp;)</code> means the catch block gets a reference for EA <em>object</em>?</p>\n<p>Sorry for my ignorance. If you recommend me a book or something to refer about exception structure, that'd be great help.</p>\n<pre><code>class EA {};\nclass EB: public EA {};\n\nvoid F()\n{\n  throw EB();  // throw at EB().\n}\n\nint main()\n{\n  try\n  {\n    F();\n  }\n  catch(EA&amp;) // caught here??\n  {\n    std::cout&lt;&lt;\"EA Exception\";\n  }\n  catch(EB&amp;) // why not me? every time?\n  {\n    std::cout&lt;&lt;\"EB Exception\";\n  }\n\n  std::cout&lt;&lt;\" Finished\"&lt;&lt;std::endl;\n\n  return 0;\n}\n</code></pre>\n", "Tags": "<c++><exception-handling><try-catch><throw><catch-block>", "OwnerUserId": "6213399", "AnswerCount": "5"}, "39528055": {"ParentId": "39527963", "CommentCount": "3", "Body": "<p>Change the order of the <code>catch</code> blocks to fix that behavior:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass EA {};\nclass EB: public EA {};\n\nvoid F()\n{\n  throw EB();  // throw at EB().\n}\n\nint main()\n{\n  try\n  {\n    F();\n  }\n  catch(EB&amp;) // why not me? every time?\n  {\n    std::cout&lt;&lt;\"EB Exception\";\n  }\n  catch(EA&amp;) // caught here??\n  {\n    std::cout&lt;&lt;\"EA Exception\";\n  }\n\n  std::cout&lt;&lt;\" Finished\"&lt;&lt;std::endl;\n\n  return 0;\n}\n</code></pre>\n<p>The compiler even warns you about this:</p>\n<pre><code>main.cpp:21:3: warning: exception of type 'EB' will be caught\n   catch(EB&amp;) // why not me? every time?\n   ^~~~~\nmain.cpp:17:3: warning:    by earlier handler for 'EA'\n   catch(EA&amp;) // caught here??\n   ^~~~~\n</code></pre>\n", "OwnerUserId": "1413395", "PostTypeId": "2", "Id": "39528055", "Score": "3", "CreationDate": "2016-09-16T09:29:26.160", "LastActivityDate": "2016-09-16T09:29:26.160"}, "39537680": {"ParentId": "39527963", "CommentCount": "1", "Body": "<p>As mentioned by the standard in <a href=\"http://eel.is/c++draft/except.handle#4\" rel=\"nofollow\">[except.handle]</a> (working draft):</p>\n<blockquote>\n<p id=\"so_39527963_39537680_0\">The handlers for a try block are tried in order of appearance. That makes it possible to write handlers that can never be executed, for example by placing a handler for a derived class after a handler for a corresponding base class.</p>\n</blockquote>\n<p>That's exactly what you did. Interesting indeed.<br>\nInvert the handlers to solve the issue.</br></p>\n", "OwnerUserId": "4987285", "PostTypeId": "2", "Id": "39537680", "Score": "2", "CreationDate": "2016-09-16T18:09:01.900", "LastActivityDate": "2016-09-16T18:09:01.900"}, "39566416": {"ParentId": "39527963", "CommentCount": "1", "Body": "<p>Reason: </p>\n<blockquote>\n<p id=\"so_39527963_39566416_0\">Upcasting</p>\n</blockquote>\n<p>of derived class to base. and hence always getting stuck on the first catch.</p>\n", "OwnerUserId": "1080000", "PostTypeId": "2", "Id": "39566416", "Score": "1", "CreationDate": "2016-09-19T06:11:10.163", "LastActivityDate": "2016-09-19T06:11:10.163"}, "39528052": {"ParentId": "39527963", "CommentCount": "3", "Body": "<p>catch statements are inspected in order.  <code>EA&amp;</code> matches, so it is used.  <code>EB&amp;</code> can never be matched.  You need to put the more specific catch first.</p>\n<pre><code>  catch(EB&amp;) // Will catch\n  {\n    std::cout&lt;&lt;\"EB Exception\";\n  }\n  catch(EA&amp;) // and this would catch EA objects that aren't EB.\n  {\n    std::cout&lt;&lt;\"EA Exception\";\n  }\n</code></pre>\n", "OwnerUserId": "771073", "PostTypeId": "2", "Id": "39528052", "Score": "1", "CreationDate": "2016-09-16T09:29:09.297", "LastActivityDate": "2016-09-16T09:29:09.297"}, "39528040": {"ParentId": "39527963", "CommentCount": "3", "Body": "<p>Because the catch blocks check in the order you declare them.</p>\n<p>you first catch by <code>EA&amp;</code>. \nEB is  derived from EA, so this is a valid catch and the second catch gets ignored.</p>\n<p>You want to have the most \"specialized\" exception-catch first. So if you switch the catch blocks it should work the other way.</p>\n", "OwnerUserId": "152359", "PostTypeId": "2", "Id": "39528040", "Score": "1", "CreationDate": "2016-09-16T09:28:40.647", "LastActivityDate": "2016-09-16T09:28:40.647"}, "bq_ids": {"n4140": {"so_39527963_39537680_0": {"section_id": 3349, "quality": 0.92, "length": 23}}, "n3337": {"so_39527963_39537680_0": {"section_id": 3219, "quality": 0.92, "length": 23}}, "n4659": {"so_39527963_39537680_0": {"section_id": 4116, "quality": 0.92, "length": 23}}}});