post_cb({"12902461": {"Id": "12902461", "PostTypeId": "2", "Body": "<p>I'll say, you can clean up your <code>vector3</code> declaration by just using a <code>union</code></p>\n<pre><code>union vector3 {\n  struct { float x, y, z; } ;\n  float v[3] ;\n} ;\n</code></pre>\n<p>Sure, <a href=\"http://msdn.microsoft.com/en-us/library/z2cx9y4f.aspx\">anonymous structures <em>was</em> an MSVC extension</a>.  But ISO C11 permits it now, and <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Unnamed-Fields.html\">gcc allows it</a>, and so does Apple's llvm compiler.</p>\n<p>Why in C11 and not C++11?  I'm not sure, but practically speaking most (gcc++, MSVC++ and Apple's C++ compiler) C++ compilers support them.</p>\n", "LastEditorUserId": "111307", "LastActivityDate": "2012-10-15T19:24:12.167", "Score": "14", "CreationDate": "2012-10-15T19:14:43.157", "ParentId": "2253878", "CommentCount": "4", "OwnerUserId": "111307", "LastEditDate": "2012-10-15T19:24:12.167"}, "2253992": {"Id": "2253992", "PostTypeId": "2", "Body": "<p>Unions can be anonymous; see the Standard, 9.5 paragraph 2.</p>\n<p>What purpose do you see an anonymous struct or class as fulfilling?  Before speculating why something isn't in the Standard, I'd like to have some idea why it should be, and I don't see a use for an anonymous struct.</p>\n", "LastActivityDate": "2010-02-12T18:06:41.220", "CommentCount": "0", "CreationDate": "2010-02-12T18:06:41.220", "ParentId": "2253878", "Score": "1", "OwnerUserId": "14148"}, "2255088": {"Id": "2255088", "PostTypeId": "2", "Body": "<p>Your code</p>\n<pre><code>union {\n  struct {\n    float x;\n    float y;\n    float z;\n  };\n  float v[3];\n};\n</code></pre>\n<p>is like </p>\n<pre><code>union Foo {\n   int;\n   float v[3];\n};\n</code></pre>\n<p>which is surely invalid (in C99 and before).</p>\n<p>The reason is <strong>probably</strong> to simplify parsing (in C), because in that case you only need to check that the struct/union body has only \"declarator statements\" like</p>\n<pre><code>Type field;\n</code></pre>\n<p>That said, <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Unnamed-Fields.html#Unnamed-Fields\" rel=\"nofollow noreferrer\">gcc and \"other compilers\"</a> supports unnamed fields as an extension. </p>\n<p><strong>Edit:</strong> Anonymous structs are now officially supported in C11 (\u00a76.7.2.1/13).</p>\n", "LastEditorUserId": "224671", "LastActivityDate": "2012-10-08T16:39:11.763", "Score": "1", "CreationDate": "2010-02-12T21:03:31.927", "ParentId": "2253878", "CommentCount": "8", "OwnerUserId": "224671", "LastEditDate": "2012-10-08T16:39:11.763"}, "bq_ids": {"n4140": {"so_2253878_2253971_1": {"length": 7, "quality": 0.875, "section_id": 5917}}, "n3337": {"so_2253878_2253971_1": {"length": 8, "quality": 1.0, "section_id": 5689}}, "n4659": {"so_2253878_2253971_1": {"length": 6, "quality": 0.75, "section_id": 7410}}}, "2253971": {"Id": "2253971", "PostTypeId": "2", "Body": "<p>Not sure what you mean.  Section 9.5 of the C++ spec, clause 2:</p>\n<blockquote>\n<p id=\"so_2253878_2253971_0\">A union of the form</p>\n<pre><code>union { member-specification } ;\n</code></pre>\n<p id=\"so_2253878_2253971_1\">is called an anonymous union; it defines an unnamed object of unnamed type.</p>\n</blockquote>\n<p>You can do things like this too:</p>\n<pre><code>void foo()\n{\n  typedef\n  struct { // unnamed, is that what you mean by anonymous?\n    int a;\n    char b;\n  } MyStructType; // this is more of a \"C\" style, but valid C++ nonetheless\n\n  struct { // an anonymous struct, not even typedef'd\n    double x;\n    double y;\n  } point = { 1.0, 3.4 };\n}\n</code></pre>\n<p>Not always very useful... although sometimes useful in nasty macro definitions.</p>\n", "LastActivityDate": "2010-02-12T18:03:35.733", "CommentCount": "1", "CreationDate": "2010-02-12T18:03:35.733", "ParentId": "2253878", "Score": "7", "OwnerUserId": "95559"}, "2253878": {"ViewCount": "37295", "Body": "<p>Some C++ compilers permit anonymous unions and structs as an extension to standard C++.  It's a bit of syntactic sugar that's occasionally very helpful.</p>\n<p>What's the rationale that prevents this from being part of the standard? Is there a technical roadblock? A philosophical one? Or just not enough of a need to justify it?</p>\n<p>Here's a sample of what I'm talking about:</p>\n<pre><code>struct vector3 {\n  union {\n    struct {\n      float x;\n      float y;\n      float z;\n    };\n    float v[3];\n  };\n};\n</code></pre>\n<p>My compiler will accept this, but it warns that <a href=\"http://msdn.microsoft.com/en-us/library/c89bw853(v=vs.100).aspx\" rel=\"noreferrer\">\"nameless struct/union\" is a non-standard extension to C++</a>.</p>\n", "AcceptedAnswerId": "12785369", "Title": "Why does C++ disallow anonymous structs and unions?", "CreationDate": "2010-02-12T17:48:47.310", "Id": "2253878", "CommentCount": "6", "FavoriteCount": "18", "PostTypeId": "1", "LastEditDate": "2013-01-10T18:00:43.967", "LastEditorUserId": "1386054", "LastActivityDate": "2013-01-11T19:10:24.677", "Score": "63", "OwnerUserId": "1386054", "Tags": "<c++><struct><unions>", "AnswerCount": "6"}, "2256340": {"Id": "2256340", "PostTypeId": "2", "Body": "<p>Based on the edit, the comments, and this MSDN article: <a href=\"http://msdn.microsoft.com/en-us/library/z2cx9y4f.aspx\" rel=\"nofollow noreferrer\">Anonymous Structures</a>, I'll hazard a guess - it fits poorly with the concept of encapsulation. I wouldn't expect a member of a class to mess with my class namespace beyond merely adding one member. Furthermore, changes to the anonymous structure can affect my class without permission.</p>\n", "LastActivityDate": "2010-02-13T03:12:37.813", "CommentCount": "1", "CreationDate": "2010-02-13T03:12:37.813", "ParentId": "2253878", "Score": "1", "OwnerUserId": "269177"}, "12785369": {"Id": "12785369", "PostTypeId": "2", "Body": "<p>As others have pointed out anonymous unions are permitted in standard C++, but anonymous structs are not.</p>\n<p>The reason for this is that C supports anonymous unions but not anonymous structs*, so C++ supports the former for compatibility but not the latter because it's not needed for compatibility. </p>\n<p>Furthermore, there's not much use to anonymous structs in C++. The use you demonstrate, to have a struct containing three floats which can be referred to either by <code>.v[i]</code>, or <code>.x</code>, <code>.y</code>, and <code>.z</code>, I believe results in undefined behavior in C++. C++ does not allow you to write to one member of a union, say <code>.v[1]</code>, and then read from another member, say <code>.y</code>. Although code that does this is not uncommon it is not actually well defined.</p>\n<p>C++'s facilities for user-defined types provide alternative solutions. For example:</p>\n<pre><code>struct vector3 {\n  float v[3];\n  float &amp;operator[] (int i) { return v[i]; }\n  float &amp;x() { return v[0]; }\n  float &amp;y() { return v[1]; }\n  float &amp;z() { return v[2]; }\n};\n</code></pre>\n<p><sub>* C11 apparently adds anonymous structs, so a future revision to C++ may add them.</sub></p>\n", "LastEditorUserId": "365496", "LastActivityDate": "2013-01-11T19:10:24.677", "Score": "29", "CreationDate": "2012-10-08T16:07:19.290", "ParentId": "2253878", "CommentCount": "6", "OwnerUserId": "365496", "LastEditDate": "2013-01-11T19:10:24.677"}});