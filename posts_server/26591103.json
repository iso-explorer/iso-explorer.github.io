post_cb({"26591234": {"Id": "26591234", "PostTypeId": "2", "Body": "<p>From the standard [n3690: 14.6.1/1]:</p>\n<blockquote>\n<p id=\"so_26591103_26591234_0\">Like normal (non-template) classes, class templates have an\n  injected-class-name (Clause 9). The injected class-name can be used as\n  a template-name or a type-name. When it is used with a\n  template-argument-list, as a template-argument for a template\n  template-parameter, or as the final identifier in the elaborated-type\n  specifier of a friend class template declaration, it refers to the\n  class template itself. Otherwise, it is equivalent to the\n  template-name followed by the template-parameters of the class\n  template enclosed in &lt;&gt;.</p>\n</blockquote>\n", "LastEditorUserId": "4108963", "LastActivityDate": "2014-10-27T19:27:23.913", "Score": "3", "CreationDate": "2014-10-27T15:37:52.250", "ParentId": "26591103", "CommentCount": "2", "OwnerUserId": "4108963", "LastEditDate": "2014-10-27T19:27:23.913"}, "bq_ids": {"n4140": {"so_26591103_26591234_0": {"length": 35, "quality": 0.875, "section_id": 179}}, "n3337": {"so_26591103_26591234_0": {"length": 35, "quality": 0.875, "section_id": 173}}, "n4659": {"so_26591103_26591234_0": {"length": 35, "quality": 0.875, "section_id": 184}}}, "26591134": {"Id": "26591134", "PostTypeId": "2", "Body": "<p>This is known as injected class name. In a template <code>X&lt;T&gt;</code>, the name <code>X</code> is equivalent to <code>X&lt;T&gt;</code>. Here's an interesting example:</p>\n<pre><code>template&lt;template&lt;class T&gt; class X&gt;\nclass Y\n{\n};\n\ntemplate&lt;class T&gt;\nclass X;\n{\n    Y&lt;X&gt; mem; //won't compile, because X is not a template, but is equivalent to X&lt;T&gt;, which is a type.\n};\n</code></pre>\n<p>See also: <a href=\"https://stackoverflow.com/questions/7025054/ambiguous-injected-class-name-is-not-an-error\">Ambiguous injected class name is not an error</a></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-10-27T15:33:22.437", "Score": "2", "CreationDate": "2014-10-27T15:33:22.437", "ParentId": "26591103", "CommentCount": "8", "OwnerUserId": "469935", "LastEditDate": "2017-05-23T12:05:52.317"}, "26591103": {"ViewCount": "102", "Body": "<p>In the following snippet, I omitted the template param placeholder in the return type of Assignment operator (operator=). In both the cases where I have specified the template parameter or not, the code just runs fine, just wondering why?</p>\n<p>Thanks</p>\n<pre><code>#include &lt;iostream&gt;\nusing std::cout; using std::endl;\n\nclass Ref\n{\n    int _ref_counter;\n\npublic:\n    Ref() : _ref_counter(0)     {}\n    void upRef() { _ref_counter++; }\n\n    int downRef() { return --_ref_counter; }\n};\n\ntemplate &lt;typename T1&gt; class SmartPointer\n{\n    T1* _ptr;\n    Ref *_ref;\n\npublic:\n    SmartPointer() : _ptr(0)\n    {\n        _ref = new Ref();\n        _ref-&gt;upRef();\n    }\n\n    SmartPointer(T1* ptr): _ptr(ptr)\n    {\n        _ref = new Ref();\n        _ref-&gt;upRef();\n    }\n\n    SmartPointer(const SmartPointer &amp;sp): _ptr(sp._ptr), _ref(sp._ref)\n    {\n    {\n        _ref-&gt;upRef();\n    }\n\n//      SmartPointer&lt;T1&gt;&amp; operator= (const SmartPointer &amp;sp)\n    SmartPointer&amp; operator= (const SmartPointer &amp;sp)\n    {\n        //Always check self assignment\n        if(this != &amp;sp)\n        {\n            //Lose the existing smartpointer info\n            if(0 == _ref-&gt;downRef())\n            {\n                delete _ptr;\n                delete _ref;\n            }\n\n            _ptr = sp._ptr;\n            _ref = sp._ref;\n            _ref-&gt;upRef();\n        }\n        return *this;\n    }\n\n    ~SmartPointer()\n    {\n        if(0 == _ref-&gt;downRef())\n        {\n            delete _ptr;\n            delete _ref;\n        }\n    }\n\n    T1&amp; operator* () { return *_ptr; }\n\n    T1* operator-&gt; () { return _ptr; }\n};\n\nclass Lock\n{\npublic:\n    void somefuntion()\n    {\n        cout &lt;&lt; \"somefunction called ! \" &lt;&lt; endl;\n    }\n\n    ~Lock()\n    {\n        cout &lt;&lt; \"Destructor Lock called !\" &lt;&lt; endl;\n    }\n};\n\nint main()\n{\n    SmartPointer&lt;Lock&gt; pMemLock(new Lock());\n\n    pMemLock-&gt;somefuntion();\n    {\n        SmartPointer&lt;Lock&gt; pMemLock1(pMemLock);\n    }\n\n    SmartPointer&lt;Lock&gt; pMemLock2;\n    pMemLock2 = pMemLock;\n    pMemLock2-&gt;somefuntion();\n}\n</code></pre>\n", "AcceptedAnswerId": "26591234", "Title": "Template placeholder not defined in return type of member, still works fine?", "CreationDate": "2014-10-27T15:31:42.247", "Id": "26591103", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2014-10-27T19:27:23.913", "Score": "1", "OwnerUserId": "2286803", "Tags": "<c++><c++11>", "AnswerCount": "2"}});