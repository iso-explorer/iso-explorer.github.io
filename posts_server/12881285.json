post_cb({"12883413": {"ParentId": "12881285", "CommentCount": "5", "CreationDate": "2012-10-14T15:03:12.650", "OwnerUserId": "229686", "PostTypeId": "2", "Id": "12883413", "Score": "1", "Body": "<p>I don't believe there is an effective variation between C and C++ in this regards. Though the wording on sequencing varies the end result is the same: both result in undefined behaviour (though C seems to indicate the evaluation will suceed but with an undefined result).</p>\n<p>In C99 (sorry, don't have C11 handy) paragraph 5.1.2.3.5 specifies:</p>\n<blockquote>\n<p id=\"so_12881285_12883413_0\">\u2014 At sequence points, volatile objects are stable in the sense that previous accesses are\n  complete and subsequent accesses have not yet occurred.</p>\n</blockquote>\n<p>Combined with your quote from 5.1.2.3.2 would indicate the value of <code>pa</code> would not be in a stable state for at least one of the accesses to <code>pa</code>. This makes logical sense since the compiler would be allowed to evaluate them in any order, just once, or at the same time (if possible). It doesn't actually define what <em>stable</em> means however.</p>\n<p>In C++11 there is explicit reference to unsequenced oeprations at 1.9.13. Then point 15 indicates such unsequenced operations on the same operand is undefined. Since <em>undefined behaviour</em> can mean anything happens it is perhaps strong than C's <em>unstable</em> behaviour. However, in both cases there is no guaranteed result of your expression.</p>\n", "LastActivityDate": "2012-10-14T15:03:12.650"}, "bq_ids": {"n4140": {"so_12881285_12881285_0": {"section_id": 5808, "quality": 0.8, "length": 12}, "so_12881285_12881285_1": {"section_id": 5808, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_12881285_12881285_0": {"section_id": 5581, "quality": 0.8, "length": 12}, "so_12881285_12881285_1": {"section_id": 5581, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_12881285_12881285_0": {"section_id": 7269, "quality": 0.7333333333333333, "length": 11}, "so_12881285_12881285_1": {"section_id": 7269, "quality": 0.8947368421052632, "length": 17}}}, "12881285": {"CommentCount": "10", "ViewCount": "374", "PostTypeId": "1", "LastEditorUserId": "34509", "CreationDate": "2012-10-14T10:17:29.643", "LastActivityDate": "2012-10-14T15:03:12.650", "Title": "Why is \"volatileQualifiedExpr + volatileQualifiedExpr\" not necessarily UB in C but in C++?", "FavoriteCount": "2", "LastEditDate": "2012-10-14T10:27:53.180", "Id": "12881285", "Score": "11", "Body": "<p>When I today read the C Standard, it says about side effects</p>\n<blockquote>\n<p id=\"so_12881285_12881285_0\">Accessing a volatile object, modifying an object, modifying a file, or calling a function\n  that does any of those operations are all side effects</p>\n</blockquote>\n<p>and the C++ Standard says</p>\n<blockquote>\n<p id=\"so_12881285_12881285_1\">Accessing an object designated by a volatile glvalue (3.10), modifying an object, calling a library I/O function, or calling a function that does any of those operations are all side effects</p>\n</blockquote>\n<p>Hence because both forbid unsequenced side effects to occur on the same scalar object, C allows the following, but C++ makes it undefined behavior</p>\n<pre><code>int a = 0;\nvolatile int *pa = &amp;a;\n\nint b = *pa + *pa;\n</code></pre>\n<p>Am I reading the specifications correctly? And what is the reason for the discrepancy, if so?</p>\n", "Tags": "<c++><c><volatile><side-effects>", "OwnerUserId": "34509", "AnswerCount": "1"}});