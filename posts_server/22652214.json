post_cb({"22652214": {"CommentCount": "0", "ViewCount": "157", "PostTypeId": "1", "ClosedDate": "2014-06-03T18:35:08.143", "LastEditorUserId": "1090079", "CreationDate": "2014-03-26T05:28:03.737", "LastActivityDate": "2014-05-12T09:52:27.427", "Title": "How exactly does C++ casting between numeric types work?", "AcceptedAnswerId": "22652447", "LastEditDate": "2014-03-26T05:56:25.333", "Id": "22652214", "Score": "1", "Body": "<p>In my code, I do something like the following:</p>\n<pre><code>double a = 3.0;\nuint64_t b = static_cast&lt;uint64_t&gt;(a);\ndouble c = static_cast&lt;double&gt;(b);\n</code></pre>\n<p>Interestingly, this works as I would expect (a == c), as long as a is positive, but if a is negative, c ends up as an arbitrarily large positive number. (It must be wrapping somewhere or something.)</p>\n<p>My questions are:</p>\n<ol>\n<li>Why does this happen?</li>\n<li>Why doesn't this code break strict aliasing rules?</li>\n</ol>\n<p><sup><strong>Note:</strong> double and uint64_t are the same size on my system.</sup></p>\n", "Tags": "<c++><casting><double><uint64>", "OwnerUserId": "1516662", "AnswerCount": "2"}, "22652369": {"ParentId": "22652214", "CommentCount": "0", "Body": "<p><code>uint64_t</code> means a 64-bit <strong>unsigned</strong> integer, so when you cast to a uint64_t, if the number is negative it overflows since an unsigned integer cannot store negative numbers.</p>\n<p>Try it with an int64_t and it will work as expected.</p>\n", "OwnerUserId": "2593738", "PostTypeId": "2", "Id": "22652369", "Score": "0", "CreationDate": "2014-03-26T05:38:46.097", "LastActivityDate": "2014-03-26T05:38:46.097"}, "22652447": {"ParentId": "22652214", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Strict aliasing only comes into play with pointers. As in casting a <code>double *</code> to <code>uint64_t *</code> and accessing the memory through that pointer, so you don't have to worry about it here. Read the excellent answers at <a href=\"https://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule\">What is the strict aliasing rule?</a> for more information on it.</p>\n<p>Also as for conversion, it will try to convert the value held by your <code>double</code> into something representable by a <code>uint64_t</code>. But <code>uint64_t</code> is unsigned and can't represent negative values so you get <strong>undefined behavior</strong> when trying to convert a negative value (also positive valus that are too high and can't be represented). In practice you'll probably get some high positive numbers but you shouldn't rely on it.</p>\n<hr>\n<blockquote>\n<p id=\"so_22652214_22652447_0\">C++ Standard (N3797) <code>4.9 [conv.fpint]/1</code> says:</p>\n<blockquote>\n<p id=\"so_22652214_22652447_2\">A prvalue of a floating point type can be converted to a prvalue of an\n    integer type. The conversion truncates; that is, the fractional part\n    is discarded. The behavior is undefined if the truncated value cannot\n    be represented in the destination type. [ Note: If the destination\n    type is bool, see 4.12. \u2014 end note ]</p>\n</blockquote>\n</blockquote>\n<p>It being well defined which Chris Dodd is refering to in his comment only holds for integral conversions, not for floating point conversions which <code>double</code> to <code>uint64_t</code> counts to.</p>\n</hr>", "OwnerUserId": "1942027", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:11:11.033", "Id": "22652447", "Score": "3", "CreationDate": "2014-03-26T05:43:27.390", "LastActivityDate": "2014-05-12T09:52:27.427"}, "bq_ids": {"n4140": {"so_22652214_22652447_2": {"section_id": 37, "quality": 0.8125, "length": 26}, "so_22652214_22652447_1": {"section_id": 37, "quality": 0.8125, "length": 26}}, "n3337": {"so_22652214_22652447_2": {"section_id": 34, "quality": 0.8125, "length": 26}, "so_22652214_22652447_1": {"section_id": 34, "quality": 0.8125, "length": 26}}, "n4659": {"so_22652214_22652447_2": {"section_id": 37, "quality": 0.75, "length": 24}, "so_22652214_22652447_1": {"section_id": 37, "quality": 0.75, "length": 24}}}});