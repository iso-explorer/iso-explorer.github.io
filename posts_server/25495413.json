post_cb({"bq_ids": {"n4140": {"so_25495413_25496464_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 2778}}, "n3337": {"so_25495413_25496464_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 2739}}, "n4659": {"so_25495413_25496464_0": {"length": 13, "quality": 0.9285714285714286, "section_id": 3516}}}, "25495440": {"Id": "25495440", "PostTypeId": "2", "Body": "<p>Yes, of course there's undefined behaviour. The lock's destructor will try to call <code>mutex-&gt;unlock()</code>, which will dereference an invalid pointer.</p>\n", "LastActivityDate": "2014-08-25T22:43:13.190", "CommentCount": "0", "CreationDate": "2014-08-25T22:43:13.190", "ParentId": "25495413", "Score": "4", "OwnerUserId": "596781"}, "25496464": {"Id": "25496464", "PostTypeId": "2", "Body": "<p>You are in UB territory even before the lock's destructor runs. \u00a730.4.1.2.1 [thread.mutex.class]/p5:</p>\n<blockquote>\n<p id=\"so_25495413_25496464_0\">The behavior of a program is undefined if it destroys a <code>mutex</code> object\n  owned by any thread or a thread terminates while owning a <code>mutex</code>\n  object.</p>\n</blockquote>\n", "LastActivityDate": "2014-08-26T00:56:24.893", "CommentCount": "0", "CreationDate": "2014-08-26T00:56:24.893", "ParentId": "25495413", "Score": "4", "OwnerUserId": "2756719"}, "25495413": {"ViewCount": "98", "Body": "<pre><code>void Fn() {\n  std::mutex* mutex = new std::mutex;\n  std::unique_lock&lt;std::mutex&gt; lock(*mutex);\n  delete mutex;\n}\n</code></pre>\n<p>Is there undefined behavior in the snippet above?</p>\n", "AcceptedAnswerId": "25496464", "Title": "What if a mutex managed by a unique_lock is destroyed?", "CreationDate": "2014-08-25T22:40:24.327", "Id": "25495413", "CommentCount": "0", "LastEditDate": "2014-08-25T22:43:18.193", "PostTypeId": "1", "LastEditorUserId": "596781", "LastActivityDate": "2014-08-26T00:56:24.893", "Score": "0", "OwnerUserId": "851835", "Tags": "<c++><c++11><mutex>", "AnswerCount": "2"}});