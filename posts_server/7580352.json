post_cb({"7580560": {"ParentId": "7580352", "CommentCount": "0", "Body": "<p>This is due to rounding errors, to see the value of that you are using insert a printf before the if:</p>\n<pre><code>printf(\"a=%f\\n\", a);\n</code></pre>\n", "OwnerUserId": "941268", "PostTypeId": "2", "Id": "7580560", "Score": "0", "CreationDate": "2011-09-28T08:46:26.330", "LastActivityDate": "2011-09-28T08:46:26.330"}, "7580410": {"ParentId": "7580352", "CommentCount": "2", "Body": "<p>This error is due to floating point accuracy and because you are comparing a <code>float</code> type with a <code>double</code> value. Try to compare it versus floating point literals: <code>if(a&lt;0.8f)</code></p>\n<p>I suggest you read the according <a href=\"http://en.wikipedia.org/wiki/Floating_point\" rel=\"nofollow\">wikipedia article</a>, it explains in detail why your error happens.</p>\n", "OwnerUserId": "746961", "PostTypeId": "2", "Id": "7580410", "Score": "10", "CreationDate": "2011-09-28T08:32:20.470", "LastActivityDate": "2011-09-28T08:32:20.470"}, "7580489": {"ParentId": "7580352", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The literals <code>0.9</code> and <code>0.8</code> have type <code>double</code>. Since both values cannot be represented exactly, they will in fact be <code>0.9000000000000000222...</code> and <code>0.8000000000000000444...</code>.</p>\n<p>When stored in the <code>float</code> (single precision) variable <code>a</code> they will be converted to single and become even more inaccurate: <code>0.89999997...</code> and <code>0.8000000119...</code>. </p>\n<p>For the comparison with the literal <code>double</code> value they are converted back to <code>double</code> retaining the more inaccurate value. </p>\n<p>As you can see from the numbers above, the comparison yields different results for <code>0.9</code> and <code>0.8</code>.</p>\n<p>All this is assuming your platform has IEEE754 floats which is most probably the case.</p>\n<p>You can see single/double representations of numbers at <a href=\"http://www.binaryconvert.com/\" rel=\"nofollow\">www.binaryconvert.com</a>.</p>\n", "OwnerUserId": "908515", "LastEditorUserId": "908515", "LastEditDate": "2011-09-28T08:55:19.157", "Id": "7580489", "Score": "5", "CreationDate": "2011-09-28T08:39:13.660", "LastActivityDate": "2011-09-28T08:55:19.157"}, "7580352": {"CommentCount": "2", "AcceptedAnswerId": "7580469", "PostTypeId": "1", "LastEditorUserId": "44390", "CreationDate": "2011-09-28T08:28:07.827", "LastActivityDate": "2012-05-10T13:05:14.967", "LastEditDate": "2012-05-10T13:05:14.967", "ViewCount": "817", "FavoriteCount": "1", "Title": "Float comparison gives different results", "Id": "7580352", "Score": "3", "Body": "<p>Look at the following two codes, and tell me the reason why answers vary a lot.</p>\n<pre><code>#include&lt;stdio.h&gt;\nint main() {\n    float a = 0.9;\n    if(a&lt;0.9)\n        printf(\"hi\"); // This will be the answer\n    else\n        printf(\"bye\");\n    return 0;\n}\n</code></pre>\n<p>And if we change 0.9 to 0.8, then else's statement is printed:</p>\n<pre><code>#include&lt;stdio.h&gt;\nint main() {\n    float a = 0.8;\n    if(a&lt;0.8)\n        printf(\"hi\");\n    else\n        printf(\"bye\");//this will be the answer\n    return 0;\n}\n</code></pre>\n<p>So why this output changes when we just change a single digit?</p>\n", "Tags": "<c++><c><floating-point>", "OwnerUserId": "2231861", "AnswerCount": "7"}, "7580540": {"ParentId": "7580352", "CommentCount": "0", "Body": "<p>Try this:</p>\n<p>Instead of \"if(a&lt;0.9)\" compare using \"if(a&lt;0.9f)\"</p>\n", "OwnerUserId": "552407", "PostTypeId": "2", "Id": "7580540", "Score": "-1", "CreationDate": "2011-09-28T08:45:01.487", "LastActivityDate": "2011-09-28T08:45:01.487"}, "7580469": {"ParentId": "7580352", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>You have to know how floating points works.</p>\n<p>Floating points are represented by using powers of two, each digit is used to represent <code>2^-x</code> where X is the n-th digit.</p>\n<p>For example, <code>0.011</code> (binary) would be <code>2^-2 + 2^-3</code>, which is <code>0.25 + 0.125 = 0.375</code></p>\n<p>Now try to represent <code>0.9</code>. You are in trouble, since no power of two to represent it. The value this is represented in 32-bits and probably 64-bits machines will give a result slightly smaller than 0.9, <s>whereas for 0.8 the result is precise and representable by powers of two</s>.</p>\n<p>You can try this out by opening a <code>python</code> prompt. Try and type a few numbers, eventually one will end with <code>...99999999</code>.</p>\n", "OwnerUserId": "353548", "LastEditorUserId": "353548", "LastEditDate": "2011-09-28T09:22:11.230", "Id": "7580469", "Score": "1", "CreationDate": "2011-09-28T08:37:03.167", "LastActivityDate": "2011-09-28T09:22:11.230"}, "7580488": {"ParentId": "7580352", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>First of all, as others mentioned, use values like <code>0.8f</code> when working with <code>float</code>s.</p>\n<p>Also, floating point <code>==</code> comparison is something you would want to avoid because of the precision of this operation in the FPU. What always worked best for me, was to define a margin, let's say <code>1e-6f</code> (or the precision you need based on your application) and instead of this:</p>\n<pre><code>if (LHS == RHS)\n</code></pre>\n<p>you write:</p>\n<pre><code>if (LHS-RHS &lt; MARGIN &amp;&amp; RHS-LHS &lt; MARGIN)\n</code></pre>\n<p>You could write a function (if you are a c++ fan) or macro (if you are a c fan (here comes the -1s)) that does this for you.</p>\n", "OwnerUserId": "912144", "LastEditorUserId": "912144", "LastEditDate": "2011-09-28T08:48:07.330", "Id": "7580488", "Score": "0", "CreationDate": "2011-09-28T08:39:07.257", "LastActivityDate": "2011-09-28T08:48:07.330"}, "bq_ids": {"n4140": {"so_7580352_7580541_1": {"section_id": 7217, "quality": 0.6153846153846154, "length": 8}}, "n3337": {"so_7580352_7580541_1": {"section_id": 6961, "quality": 0.6153846153846154, "length": 8}}, "n4659": {"so_7580352_7580541_1": {"section_id": 8726, "quality": 0.6153846153846154, "length": 8}}}, "7580541": {"ParentId": "7580352", "CommentCount": "0", "Body": "<p>According to the C Standard:</p>\n<blockquote>\n<p id=\"so_7580352_7580541_0\">6.3.1.5 Real \ufb02oating types</p>\n<p id=\"so_7580352_7580541_1\">1) When a float is promoted to double or long double, or a double is\n  promoted to long double, its value is unchanged.</p>\n<p id=\"so_7580352_7580541_2\">2) When a double is demoted to float, a long double is demoted to double\n  or float, or a value being represented in greater precision and range\n  than required by its semantic type (see 6.3.1.8) is explicitly\n  converted to its semantic type, if the value being converted can be\n  represented exactly in the new type, it is unchanged. If the value\n  being converted is in the range of values that can be represented but\n  cannot be represented exactly, the result is either the nearest higher\n  or nearest lower representable value, chosen in an\n  implementation-de\ufb01ned manner. If the value being converted is outside\n  the range of values that can be represented, the behavior is unde\ufb01ned.</p>\n</blockquote>\n<p>The standard can be found <strong><a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf\" rel=\"nofollow\">here</a></strong>.</p>\n", "OwnerUserId": "433945", "PostTypeId": "2", "Id": "7580541", "Score": "1", "CreationDate": "2011-09-28T08:45:05.477", "LastActivityDate": "2011-09-28T08:45:05.477"}});