post_cb({"bq_ids": {"n4140": {"so_24121708_24122429_3": {"length": 26, "quality": 1.0, "section_id": 5451}, "so_24121708_24122429_10": {"length": 5, "quality": 1.0, "section_id": 5440}, "so_24121708_24122429_8": {"length": 6, "quality": 0.8571428571428571, "section_id": 5440}, "so_24121708_24122429_9": {"length": 18, "quality": 0.9473684210526315, "section_id": 5440}, "so_24121708_24122429_2": {"length": 34, "quality": 0.9444444444444444, "section_id": 5952}}, "n3337": {"so_24121708_24122429_10": {"length": 5, "quality": 1.0, "section_id": 5235}, "so_24121708_24122429_8": {"length": 5, "quality": 0.7142857142857143, "section_id": 5235}, "so_24121708_24122429_2": {"length": 34, "quality": 0.9444444444444444, "section_id": 5722}, "so_24121708_24122429_9": {"length": 18, "quality": 0.9473684210526315, "section_id": 5235}}, "n4659": {"so_24121708_24122429_3": {"length": 18, "quality": 0.6923076923076923, "section_id": 6887}, "so_24121708_24122429_10": {"length": 5, "quality": 1.0, "section_id": 6867}, "so_24121708_24122429_8": {"length": 6, "quality": 0.8571428571428571, "section_id": 6867}, "so_24121708_24122429_2": {"length": 23, "quality": 0.6388888888888888, "section_id": 7438}, "so_24121708_24122429_9": {"length": 18, "quality": 0.9473684210526315, "section_id": 6867}}}, "24121872": {"Id": "24121872", "PostTypeId": "2", "Body": "<p>The two versions <strong>differ in context</strong> when automatic return type deduction with <a href=\"https://stackoverflow.com/q/24109737/2567683\"><code>decltype(auto)</code></a> is used in C++14</p>\n<p>Particularly the second is an antipatern in case B ( example taken from the <a href=\"https://isocpp.org/wiki/faq/cpp14-language#decltype-auto\" rel=\"nofollow noreferrer\">C++FAQ</a>)</p>\n<pre><code>decltype(auto) look_up_a_string_1() { auto str = lookup1(); return str; }  //A\ndecltype(auto) look_up_a_string_2() { auto str = lookup1(); return(str); } //B\n</code></pre>\n<p>as it returns <code>string&amp;</code> (as opposed to a <code>string</code> in A), which is a reference to the <strong>local</strong> variable str.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2014-06-09T14:27:55.690", "Score": "10", "CreationDate": "2014-06-09T13:58:49.690", "ParentId": "24121708", "CommentCount": "4", "LastEditDate": "2017-05-23T10:29:58.003", "OwnerUserId": "2567683"}, "24122429": {"Id": "24122429", "PostTypeId": "2", "Body": "<p>Pre <em>C++1y</em> the parenthesized version of the <em>return</em> is identical, if we look at the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">C++11 draft standard</a> section <code>6.6</code> <em>Jump statements</em>, the grammar for <em>return</em> is:</p>\n<blockquote>\n<p id=\"so_24121708_24122429_0\">return expression<sub>opt</sub> ;</p>\n<p id=\"so_24121708_24122429_1\">return braced-init-list ;</p>\n</blockquote>\n<p>an <em>expression</em> can be any <em>expression</em> and we can see from section <code>5.1</code> <em>Primary expressions</em> says (<em>emphasis mine going forward</em>):</p>\n<blockquote>\n<p id=\"so_24121708_24122429_2\">A parenthesized expression is a primary expression whose type and\n  value are identical to those of the enclosed expression. The presence\n  of parentheses does not affect whether the expression is an lvalue.\n  <strong>The parenthesized expression can be used in exactly the same contexts\n  as those where the enclosed expression can be used, and with the same\n  meaning, except as otherwise indicated</strong>.</p>\n</blockquote>\n<p>In <em>C++1y</em> we can use <a href=\"https://isocpp.org/wiki/faq/cpp14-language#decltype-auto\" rel=\"nofollow\">delctype(auto)</a> to deduce return types and this changes the situation as we can see from the <a href=\"https://github.com/cplusplus/draft/blob/b7b8ed08ba4c111ad03e13e8524a1b746cb74ec6/papers/N3936.pdf\" rel=\"nofollow\">draft C++1y standard</a> section <code>7.1.6.4</code> <em>auto specifier</em> says:</p>\n<blockquote>\n<p id=\"so_24121708_24122429_3\">When a variable declared using a placeholder type is initialized, or a\n  return statement occurs in a function declared with a return type that\n  contains a placeholder type, <strong>the deduced return type or variable type\n  is determined from the type of its initializer</strong>.[...]</p>\n</blockquote>\n<p>and contains the following examples:</p>\n<blockquote>\n<p id=\"so_24121708_24122429_4\">auto x3a = i; // decltype(x3a) is int</p>\n<p id=\"so_24121708_24122429_5\"><strong>decltype(auto) x3d = i; // decltype(x3d) is int</strong></p>\n<p id=\"so_24121708_24122429_6\">auto x4a = (i); // decltype(x4a) is int</p>\n<p id=\"so_24121708_24122429_7\"><strong>decltype(auto) x4d = (i); // decltype(x4d) is int&amp;</strong></p>\n</blockquote>\n<p>and we can see there is a difference when using <em>delctype(auto)</em> and parenthesized expressions. The rule that is being applied is from section <code>7.1.6.2</code> <em>Simple type specifiers</em> paragraph <em>4</em> which says:</p>\n<blockquote>\n<p id=\"so_24121708_24122429_8\">For an expression e, the type denoted by decltype(e) is defined as follows:</p>\n</blockquote>\n<p>and includes the following bullets:</p>\n<blockquote>\n<p id=\"so_24121708_24122429_9\">\u2014 if e is an unparenthesized id-expression or an unparenthesized class\n  member access (5.2.5), decltype(e) is the type of the entity named by\n  e. If there is no such entity, or if e names a set of overloaded\n  functions, the program is ill-formed;</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_24121708_24122429_10\">\u2014 otherwise, if e is an lvalue, decltype(e) is T&amp;, where T is the type\n  of e;</p>\n</blockquote>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2014-06-12T21:21:07.373", "Score": "7", "CreationDate": "2014-06-09T14:28:18.050", "ParentId": "24121708", "CommentCount": "1", "LastEditDate": "2014-06-12T21:21:07.373", "OwnerUserId": "1708801"}, "24121708": {"ViewCount": "883", "Body": "<p>In <em>C++</em> you are allowed to write a <em>return statement</em> that looks like :</p>\n<pre><code>return ( ... );\n</code></pre>\n<p>which is different from the more popular :</p>\n<pre><code>return ... ;\n</code></pre>\n<p>In particular the first version returns the address/reference of something that is local to the stack of the function which contains that <code>return</code> statement.</p>\n<p>Now why something would like to return a reference to something that, at that point, has no lifetime ?</p>\n<p>What are the use case for this idiom ? Considering the new buzzword and features from C++11 and C++14 there is a different usage for this ?</p>\n", "AcceptedAnswerId": "24122429", "Title": "C++11/14 and return( ... ) vs return", "CreationDate": "2014-06-09T13:50:15.523", "Id": "24121708", "CommentCount": "13", "LastEditDate": "2014-06-10T13:22:31.957", "PostTypeId": "1", "LastEditorUserId": "1708801", "LastActivityDate": "2016-10-24T11:41:12.453", "Score": "3", "OwnerUserId": "2485710", "Tags": "<c++><c++11><c++14><decltype><type-deduction>", "AnswerCount": "3"}, "24121766": {"Id": "24121766", "PostTypeId": "2", "Body": "<p>The form is <code>return expression;</code> <br>\nExpression can be anything, including a parenthesised expression.<br>\nThese are not different <strong>forms</strong> of returns, however, together <br>\nwith <code>decltype(auto)</code> different types will be deduced.</br></br></br></p>\n", "LastEditorUserId": "3202093", "LastActivityDate": "2016-10-24T11:41:12.453", "Score": "12", "CreationDate": "2014-06-09T13:53:33.443", "ParentId": "24121708", "CommentCount": "8", "LastEditDate": "2016-10-24T11:41:12.453", "OwnerUserId": "3202093"}});