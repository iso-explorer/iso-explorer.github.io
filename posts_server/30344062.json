post_cb({"30352758": {"ParentId": "30344062", "CommentCount": "0", "Body": "<p>That rule applies only to class templates, not functions, because the templates can be deduced for functions. If you try that on a class template, you'll see the error:</p>\n<pre><code>template &lt;class... X, class Y&gt;\nclass C {  // This won't compile.\n};\n</code></pre>\n<p>For more information, please refer to Page 7 in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2242.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2242.pdf</a>:</p>\n<blockquote>\n<p id=\"so_30344062_30352758_0\">If a template-parameter of a class template is a template parameter\n  pack, it must be the last template-parameter. Note: This is not a\n  requirementThese are not requirements for function templates because\n  template arguments might be deduced (14.8.2)</p>\n</blockquote>\n", "OwnerUserId": "1733239", "PostTypeId": "2", "Id": "30352758", "Score": "0", "CreationDate": "2015-05-20T14:33:21.060", "LastActivityDate": "2015-05-20T14:33:21.060"}, "30363491": {"ParentId": "30344062", "CommentCount": "0", "Body": "\n<p>The first call <code>f(12)</code> is ill-formed. A parameter-pack that does not appear at the end of a parameter-declaration is a non-deduced context per [temp.deduct.type]/p5.7:</p>\n<blockquote>\n<p id=\"so_30344062_30363491_0\">The non-deduced contexts are:</p>\n<p id=\"so_30344062_30363491_1\">\u2014 [..]</p>\n<p id=\"so_30344062_30363491_2\">\u2014 <strong>A function parameter pack that does not occur at the end of the <em>parameter-declaration-list</em></strong></p>\n</blockquote>\n<p>Further in [temp.deduct.call]/p1:</p>\n<blockquote>\n<p id=\"so_30344062_30363491_3\">For a function parameter pack that occurs at the end of the <em>parameter-declaration-list</em>, the type <code>A</code> of each remaining argument of the call is compared with the type <code>P</code> of the <em>declarator-id</em> of the function parameter pack. Each comparison deduces template arguments for subsequent positions in the template parameter packs expanded by the function parameter pack. <strong>When a function parameter pack appears in a non-deduced context (14.8.2.5), the type of that parameter pack is never deduced.</strong></p>\n<p id=\"so_30344062_30363491_4\">[ Example:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>template&lt;class ... Types&gt; void f(Types&amp; ...);\ntemplate&lt;class T1, class ... Types&gt; void g(T1, Types ...);\ntemplate&lt;class T1, class ... Types&gt; void g1(Types ..., T1);\n\nvoid h(int x, float&amp; y) {\n    const int z = x;\n    f(x, y, z); // Types is deduced to int, float, const int\n    g(x, y, z); // T1 is deduced to int; Types is deduced to float, int\n    g1(x, y, z); // error: Types is not deduced\n    g1&lt;int, int, int&gt;(x, y, z); // OK, no deduction occurs\n}\n</code></pre>\n<p id=\"so_30344062_30363491_5\">\u2014 end example ]</p>\n</blockquote>\n<p>Thus the parameter pack <code>X...</code> cannot be deduced by the function's arguments and template argument deduction fails. GCC accepts the first call instead of rejecting the template for not deducing <code>12</code> so it appears to be a bug.</p>\n<p>The second call, <code>f&lt;int, int, int&gt;(1, 2, 3, 4)</code>, however, is well-formed according to [temp.deduct]/p6. The explicitly-specified template arguments are immediately substituted for the template parameters of the function template. This means <code>X = {int, int, int}</code>. Template argument deduction then proceeds with <code>Y</code> being deduced from the rightmost argument as <code>int</code>:</p>\n<blockquote>\n<p id=\"so_30344062_30363491_6\">At certain points in the template argument deduction process it is necessary to take a function type that makes use of template parameters and replace those template parameters with the corresponding template\n  arguments. <strong>This is done at the beginning of template argument deduction when any explicitly specified template\n  arguments are substituted into the function type, and again at the end of template argument deduction\n  when any template arguments that were deduced or obtained from default arguments are substituted.</strong></p>\n</blockquote>\n<p>Note that also ([temp.deduct]/p2):</p>\n<blockquote>\n<p id=\"so_30344062_30363491_7\">There must not be more arguments than there are parameters <strong>unless at least one parameter is a template parameter pack</strong>, and there shall be an argument for each non-pack parameter.</p>\n</blockquote>\n<p>Clang does not accept the last function call, but GCC does. I believe this to be a Clang bug.</p>\n<hr>\n<p>Note that there is an open <a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/cwg_active.html#1609\" rel=\"nofollow\">CWG issue 1609</a> pertaining to the use of default-arguments following the occurrence of a parameter-pack. There's also <a href=\"https://llvm.org/bugs/show_bug.cgi?id=21774\" rel=\"nofollow\">LLVM Bug 21774</a> which disputes Clang's behavior in that context.</p>\n</hr>", "OwnerUserId": "701092", "PostTypeId": "2", "Id": "30363491", "Score": "0", "CreationDate": "2015-05-21T02:21:17.727", "LastActivityDate": "2015-05-21T02:21:17.727"}, "bq_ids": {"n4140": {"so_30344062_30363491_3": {"section_id": 302, "quality": 0.9555555555555556, "length": 43}, "so_30344062_30363491_7": {"section_id": 294, "quality": 1.0, "length": 18}, "so_30344062_30363491_2": {"section_id": 336, "quality": 1.0, "length": 7}, "so_30344062_30363491_6": {"section_id": 298, "quality": 0.98, "length": 49}, "so_30344062_30352758_0": {"section_id": 64, "quality": 0.5238095238095238, "length": 11}}, "n3337": {"so_30344062_30363491_3": {"section_id": 293, "quality": 0.8222222222222222, "length": 37}, "so_30344062_30352758_0": {"section_id": 59, "quality": 0.5238095238095238, "length": 11}, "so_30344062_30363491_7": {"section_id": 285, "quality": 1.0, "length": 18}, "so_30344062_30363491_2": {"section_id": 293, "quality": 1.0, "length": 7}, "so_30344062_30363491_6": {"section_id": 289, "quality": 0.98, "length": 49}}, "n4659": {"so_30344062_30363491_3": {"section_id": 309, "quality": 0.8888888888888888, "length": 40}, "so_30344062_30352758_0": {"section_id": 66, "quality": 0.5238095238095238, "length": 11}, "so_30344062_30363491_7": {"section_id": 301, "quality": 1.0, "length": 18}, "so_30344062_30363491_6": {"section_id": 305, "quality": 0.98, "length": 49}, "so_30344062_30363491_2": {"section_id": 345, "quality": 1.0, "length": 7}}}, "30344062": {"CommentCount": "1", "ViewCount": "160", "PostTypeId": "1", "LastEditorUserId": "3953764", "CreationDate": "2015-05-20T08:20:01.653", "LastActivityDate": "2015-05-21T02:21:17.727", "Title": "Not deduced context in variadic function template", "FavoriteCount": "1", "LastEditDate": "2015-05-20T08:21:42.073", "Id": "30344062", "Score": "5", "Body": "<p>The following code should be, as I know, \"not deduced context\" (or not?)</p>\n<pre><code>template &lt;class... X, class Y&gt;\nvoid f(X... args, Y y)\n{\n\n}\n\nint main()\n{\n    f(12);\n    f&lt;int, int, int&gt;(1, 2, 3, 4);\n}\n</code></pre>\n<p>but g++ 4.9 compiles it for both instantiations of <code>f</code> in <code>main</code>...\nCan anybody explain?</p>\n", "Tags": "<c++><c++11><variadic-templates><template-deduction>", "OwnerUserId": "4278083", "AnswerCount": "2"}});