post_cb({"10376279": {"ParentId": "10370713", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The relevant passage of the standard is [dcl.fct.def.default]/1:</p>\n<blockquote>\n<p id=\"so_10370713_10376279_0\">A function that is explicitly defaulted shall\n  [...]\n  have the same declared function type (except for possibly differing ref-qualifiers and except that in the case of a copy constructor or copy assignment operator, the parameter type may be \"reference to non-const <code>T</code>\", where <code>T</code> is the name of the member function's class) as if it had been implicitly declared</p>\n</blockquote>\n<p>This rule applies even if the defaulted function is never used. Now, [class.copy]/9 says:</p>\n<blockquote>\n<p id=\"so_10370713_10376279_1\">The implicitly-declared copy constructor will have the form</p>\n<p id=\"so_10370713_10376279_2\"><code>X::X(const X&amp;)</code></p>\n<p id=\"so_10370713_10376279_3\">if [...] for all the non-static data members of <code>X</code> that are of a class type <code>M</code> [...], each such class type has a copy constructor whose first parameter is of type <code>const M&amp;</code> or <code>const volatile M&amp;</code>.</p>\n<p id=\"so_10370713_10376279_4\">Otherwise the implicitly-declared copy constructor will have the form</p>\n<p id=\"so_10370713_10376279_5\"><code>X::X(X&amp;)</code></p>\n</blockquote>\n<p>Therefore, an example like this is ill-formed (and should produce the diagnostics you are seeing):</p>\n<pre><code>struct A {\n  A();\n  A(A&amp;); // Note, non-const type A in copy constructor\n};\ntemplate&lt;typename T&gt;\nstruct B {\n  T t;\n  B();\n  B(const B&amp;) = default;\n};\nB&lt;A&gt; b; // error, B&lt;A&gt;::B(const B&amp;) is defaulted but has the wrong type\n</code></pre>\n<p>However, in your example, this rule doesn't apply. Due to a clang bug (which is already fixed), deleted copy constructors were incorrectly considered to have non-const parameter types, leading to this error.</p>\n", "OwnerUserId": "1041090", "LastEditorUserId": "1041090", "LastEditDate": "2012-04-29T21:55:18.767", "Id": "10376279", "Score": "2", "CreationDate": "2012-04-29T21:45:54.317", "LastActivityDate": "2012-04-29T21:55:18.767"}, "10370981": {"ParentId": "10370713", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Have a look at section 14.7.1 of the current C++11 standard. To quote from the n3242 version of the draft:</p>\n<blockquote>\n<p id=\"so_10370713_10370981_0\">The implicit instantiation of a class template specialization causes\n  the implicit instantiation of the declarations, but not of the\n  definitions or default arguments, of the class member functions,\n  member classes, static data members and member templates; and it\n  causes the implicit instantiation of the definitions of member\n  anonymous unions. Unless a member of a class template or a member\n  template has been explicitly instantiated or explicitly specialized,\n  the specialization of the member is implicitly instantiated when the\n  specialization is referenced in a context that requires the member\n  definition to exist; in particular, the initialization (and any\n  associated side-effects) of a static data member does not occur unless\n  the static data member is itself used in a way that requires the\n  definition of the static data member to exist.</p>\n</blockquote>\n<p>So, this means, when you use a class as a type as above only the declarations are instantiated with it. So the actual (defaulted) implementation of the copy constructor should not be instantiated, as it is not needed in the above code. So GCC is handling this correctly, whereas Clang does not.</p>\n<p>Also your edit suggests, that Clang is generating the implementation for the default copy constructor too early, since your directly implemented copy constructor is faulty as well (you cannot call the copy constructor for <code>S</code> as you are doing in your own implementation). Since the defaulted implementation and your implementation should be the same in all respects (including the time of instantiation), I would consider this a clang bug.</p>\n", "OwnerUserId": "663957", "LastEditorUserId": "597607", "LastEditDate": "2012-04-29T14:21:06.033", "Id": "10370981", "Score": "5", "CreationDate": "2012-04-29T09:08:44.213", "LastActivityDate": "2012-04-29T14:21:06.033"}, "10370713": {"CommentCount": "1", "AcceptedAnswerId": "10376279", "CreationDate": "2012-04-29T08:16:57.210", "LastActivityDate": "2012-04-29T21:55:18.767", "PostTypeId": "1", "ViewCount": "2727", "FavoriteCount": "1", "Title": "When are special member functions of a template class instantiated?", "Id": "10370713", "Score": "8", "Body": "<p>When are the special member functions (specifically, copy/move constructors and copy/move assignment operators) of a template class instantiated? As soon as the class itself is instantiated, or only when they are needed?</p>\n<p>This comes up in the following situation:</p>\n<pre><code>template &lt;class T, class U&gt;\nstruct pair\n{\n    T first;                 \n    U second;                \n\n    pair() : first(), second() {}\n\n    pair(const pair&amp;) = default;\n};\n\nstruct S\n{\n    S() {}\n    S(const S&amp;) = delete;\n    S(S&amp;&amp;) = default;\n};\n\nint main()\n{\n    pair&lt;int, S&gt; p;\n}\n</code></pre>\n<p>Clang refuses to compile this code, with the following errors:</p>\n<pre><code>test.cpp:9:5: error: the parameter for this explicitly-defaulted copy constructor is const, but a member or base requires it to be\n      non-const\n    pair(const pair&amp;) = default;\n    ^\ntest.cpp:21:18: note: in instantiation of template class 'pair&lt;int, S&gt;' requested here\n    pair&lt;int, S&gt; p;\n                 ^\n</code></pre>\n<p>suggesting that it tries to instantiate the copy constructor as soon as the class is instantiated.</p>\n<p>GCC, however, compiles the code just fine, suggesting that it would only try to instantiate the copy constructor if it was actually needed.</p>\n<p>Which compiler's behaviour is correct?</p>\n<p>(A similar discrepancy is exhibited for assignment operators.)</p>\n<p><strong>UPDATE</strong>: This has something to do with the fact that the copy constructor of <code>pair</code> in this example is <code>default</code>ed, because if I change its definition to </p>\n<pre><code>pair(const pair&amp; p) : first(p.first), second(p.second) {}\n</code></pre>\n<p>then the code passes clang as well.</p>\n", "Tags": "<c++><templates><c++11><clang><copy-constructor>", "OwnerUserId": "141719", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_10370713_10376279_0": {"section_id": 3270, "quality": 1.0, "length": 33}, "so_10370713_10376279_1": {"section_id": 457, "quality": 0.8571428571428571, "length": 6}, "so_10370713_10376279_3": {"section_id": 467, "quality": 0.8947368421052632, "length": 17}, "so_10370713_10370981_0": {"section_id": 234, "quality": 0.5675675675675675, "length": 42}, "so_10370713_10376279_4": {"section_id": 457, "quality": 1.0, "length": 7}}, "n3337": {"so_10370713_10376279_0": {"section_id": 3142, "quality": 1.0, "length": 33}, "so_10370713_10376279_1": {"section_id": 448, "quality": 0.8571428571428571, "length": 6}, "so_10370713_10370981_0": {"section_id": 227, "quality": 0.5675675675675675, "length": 42}, "so_10370713_10376279_3": {"section_id": 448, "quality": 1.0, "length": 19}, "so_10370713_10376279_4": {"section_id": 448, "quality": 1.0, "length": 7}}, "n4659": {"so_10370713_10376279_4": {"section_id": 480, "quality": 1.0, "length": 7}, "so_10370713_10376279_1": {"section_id": 480, "quality": 0.8571428571428571, "length": 6}, "so_10370713_10370981_0": {"section_id": 244, "quality": 0.5540540540540541, "length": 41}, "so_10370713_10376279_3": {"section_id": 490, "quality": 0.8947368421052632, "length": 17}, "so_10370713_10376279_0": {"section_id": 4028, "quality": 1.0, "length": 33}}}});