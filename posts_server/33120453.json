post_cb({"33124790": {"Id": "33124790", "PostTypeId": "2", "Body": "<p>Not directly.</p>\n<p>If p and q are expressions so that p does not have overloaded operators, short circuit evaluation is in effect: expression q is going to be evaluated only if p is false.</p>\n<p>If p is of non-primitive type, there is no short circuit evaluation and overloaded function could be anything - even not related to the conventional usage.</p>\n<p>Compiler will do its optimizations in its own way. Perhaps it might result de Morgan identities, but not on the level of if condition replacement.</p>\n", "LastActivityDate": "2015-10-14T12:04:23.383", "CommentCount": "0", "CreationDate": "2015-10-14T12:04:23.383", "ParentId": "33120453", "Score": "3", "OwnerUserId": "5349798"}, "33120453": {"ViewCount": "3352", "Body": "<p>Every programmer should know that:  </p>\n<p><a href=\"https://i.stack.imgur.com/DAZCK.gif\" rel=\"noreferrer\"><img alt=\"De Morgan 1\" src=\"https://i.stack.imgur.com/DAZCK.gif\"/></a><br>\n<a href=\"https://i.stack.imgur.com/okkHe.gif\" rel=\"noreferrer\"><img alt=\"De Morgan 2\" src=\"https://i.stack.imgur.com/okkHe.gif\"/></a><br>\n(<a href=\"https://en.wikipedia.org/wiki/De_Morgan%27s_laws\" rel=\"noreferrer\">De Morgan's Laws)</a></br></br></p>\n<p>Under some circumstances, in order to optimize the program, it may happen that compiler modifies <code>(!p &amp;&amp; !q)</code> to <code>(!(p || q))</code>.</p>\n<p>The two expressions are equivalent, and it makes no difference evaluating the first or the second.<br>\nBut in C++ it is possible to overload operators, and the overloaded operator may not always respect this property. So transforming the code this way will actually modify the code.  </br></p>\n<p>Should the compiler use De Morgan's Laws when <code>!</code>, <code>||</code> and <code>&amp;&amp;</code> are overloaded?</p>\n", "AcceptedAnswerId": "33120598", "Title": "De Morgan's Law optimization with overloaded operators", "CreationDate": "2015-10-14T08:36:39.880", "Id": "33120453", "CommentCount": "12", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2015-10-14T20:40:21.003", "LastEditorUserId": "1835769", "LastActivityDate": "2015-10-22T10:48:54.107", "Score": "66", "OwnerUserId": "4261955", "Tags": "<c++><operator-overloading><language-lawyer><compiler-optimization>", "AnswerCount": "8"}, "bq_ids": {"n4140": {"so_33120453_33120598_3": {"length": 19, "quality": 1.0, "section_id": 675}}, "n3337": {"so_33120453_33120598_3": {"length": 19, "quality": 1.0, "section_id": 665}}, "n4659": {"so_33120453_33120598_3": {"length": 19, "quality": 1.0, "section_id": 703}}}, "33121152": {"Id": "33121152", "PostTypeId": "2", "Body": "<p><strong>Overloaded operators <em>per se</em> are just syntactic sugar for function calls</strong>; the compiler itself is not allowed to make any assumption about the properties that may or may not hold for such calls. Optimizations that exploit properties of some specific operator (say, De Morgan's for boolean operators, commutativity for sums, distributivity for sum/product, transformation of integral division in an appropriate multiplication, ...) can be employed only when the \"real operators\" are used.</p>\n<p>Notice instead that some parts of the <em>standard library</em> may associate some specific semantic meaning to overloaded operators - for example, <code>std::sort</code> by default expects an <code>operator&lt;</code> that complies to a strict weak ordering between the elements - but this is of course listed in the prerequisites of each algorithm/container.</p>\n<p>(incidentally, overloading <code>&amp;&amp;</code> and <code>||</code> should probably be avoided anyway since they lose their short-circuiting properties when overloaded, so their behavior becomes surprising and thus potentially dangerous)</p>\n", "LastActivityDate": "2015-10-14T09:10:20.170", "CommentCount": "0", "CreationDate": "2015-10-14T09:10:20.170", "ParentId": "33120453", "Score": "5", "OwnerUserId": "214671"}, "33254845": {"Id": "33254845", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_33120453_33254845_0\">But in C++ it is possible to overload operators,  and the overloaded operator may not always respect this property.</p>\n</blockquote>\n<p>Overloaded operator is no longer an operator, it is a function call.</p>\n<pre><code>class Boolean\n{\n  bool value;\n\n  ..\n\n  Boolean operator||(const Boolean&amp; b)\n  {\n      Boolean c;\n      c.value = this-&gt;value || b.value;\n      return c;\n  }\n\n  Boolean logical_or(const Boolean&amp; b)\n  {\n      Boolean c;\n      c.value = this-&gt;value || b.value;\n      return c;\n  }\n}\n</code></pre>\n<p>So this line of code</p>\n<pre><code>Boolean a (true);\nBoolean b (false);\n\nBoolean c = a || b;\n</code></pre>\n<p>is equivalent to this</p>\n<pre><code>Boolean c = a.logical_or(b);\n</code></pre>\n", "LastActivityDate": "2015-10-21T08:50:43.027", "CommentCount": "0", "CreationDate": "2015-10-21T08:50:43.027", "ParentId": "33120453", "Score": "1", "OwnerUserId": "2128327"}, "33120598": {"Id": "33120598", "PostTypeId": "2", "Body": "<p>Note that:</p>\n<blockquote>\n<p id=\"so_33120453_33120598_0\"><strong>Builtin operators &amp;&amp; and || perform short-circuit evaluation</strong> (do not evaluate the second operand if the result is known after evaluating the first), but <strong>overloaded operators behave like regular function calls</strong> and <strong>always evaluate both operands</strong>.</p>\n<p id=\"so_33120453_33120598_1\">...\n  Because the short-circuiting properties of operator&amp;&amp; and operator|| do not apply to overloads, and because types with boolean semantics are uncommon, only two standard library classes overload these operators ...</p>\n<p id=\"so_33120453_33120598_2\">Source: <a href=\"http://en.cppreference.com/w/cpp/language/operator_logical\">http://en.cppreference.com/w/cpp/language/operator_logical</a>\n  (emphasis mine)</p>\n</blockquote>\n<p>And that:</p>\n<blockquote>\n<p id=\"so_33120453_33120598_3\">If there is a user-written candidate with the same name\n  and parameter types as a built-in candidate operator function, the <strong>built-in operator function is hidden</strong> and\n  is not included in the set of candidate functions.</p>\n<p id=\"so_33120453_33120598_4\">Source: n4431 13.6 Built-in operators [over.built] (emphasis mine)</p>\n</blockquote>\n<p>To summarize: overloaded operators behave like regular, user-written functions.</p>\n<p>NO, the compiler will not replace a call of a user-written function with a call of another user-written function.\nDoing otherwise would potentially violate the <a href=\"http://en.cppreference.com/w/cpp/language/as_if\">\"as if\"</a> rule.</p>\n", "LastEditorUserId": "2020827", "LastActivityDate": "2015-10-14T09:45:08.583", "Score": "76", "CreationDate": "2015-10-14T08:44:08.560", "ParentId": "33120453", "CommentCount": "0", "OwnerUserId": "2020827", "LastEditDate": "2015-10-14T09:45:08.583"}, "33120538": {"Id": "33120538", "PostTypeId": "2", "Body": "<p>I think that you have answered your own question: no, a compiler can not do this. Not only the operators can be overloaded, some can not be even defined. For example, you can have <code>operator &amp;&amp;</code> and <code>operator !</code> defined, and <code>operator ||</code> not defined at all.</p>\n<p>Note that there are many other laws that the compiler can not follow. For example, it can not change <code>p||q</code> to <code>q||p</code>, as well as <code>x+y</code> to <code>y+x</code>.</p>\n<p>(All of the above applies to overloaded operators, as this is what the question asks for.)</p>\n", "LastEditorUserId": "916491", "LastActivityDate": "2015-10-22T10:48:54.107", "Score": "17", "CreationDate": "2015-10-14T08:41:06.013", "ParentId": "33120453", "CommentCount": "3", "OwnerUserId": "3216312", "LastEditDate": "2015-10-22T10:48:54.107"}, "33120550": {"Id": "33120550", "PostTypeId": "2", "Body": "<p>No, in that case the transformation would be invalid. The permission to transform <code>!p &amp;&amp; !q</code> into <code>!(p || q)</code> is implicit, by the as-if rule. The as-if rule allows any transformation that, roughly speaking, cannot be observed by a correct program. When overloaded operators are used and would detect the transformation, that automatically means the transformation is no longer allowed.</p>\n", "LastActivityDate": "2015-10-14T08:41:54.797", "CommentCount": "3", "CreationDate": "2015-10-14T08:41:54.797", "ParentId": "33120453", "Score": "9", "OwnerUserId": "743382"}, "33121383": {"Id": "33121383", "PostTypeId": "2", "Body": "<p>You are asking whether the compiler can arbitrarily rewrite your program to do something you did not write it to do.</p>\n<p>The answer is: <em>of course not!</em></p>\n<ul>\n<li>Where De Morgan's laws apply, they may be applied.</li>\n<li>Where they don't, they may not.</li>\n</ul>\n<p>It's really that simple.</p>\n", "LastActivityDate": "2015-10-14T09:20:27.163", "CommentCount": "16", "CreationDate": "2015-10-14T09:20:27.163", "ParentId": "33120453", "Score": "4", "OwnerUserId": "560648"}, "33129658": {"Id": "33129658", "PostTypeId": "2", "Body": "<p>DeMorgan's laws apply to the <strong>semantics</strong> of those operators. Overloading applies to the <strong>syntax</strong> of those operators. There is no guarantee that an overloaded operator implements the semantics that are needed for DeMorgan's laws to apply.</p>\n", "LastActivityDate": "2015-10-14T15:35:05.517", "CommentCount": "3", "CreationDate": "2015-10-14T15:35:05.517", "ParentId": "33120453", "Score": "3", "OwnerUserId": "1593860"}});