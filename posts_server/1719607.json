post_cb({"1719647": {"ParentId": "1719607", "PostTypeId": "2", "CommentCount": "5", "CreationDate": "2009-11-12T03:12:18.067", "Score": "16", "LastEditorUserId": "202699", "LastEditDate": "2009-11-12T03:29:29.313", "Id": "1719647", "OwnerUserId": "202699", "Body": "<pre><code>BYTE* data = new BYTE[size];\n</code></pre>\n<p>In this code, whatever size is given, the returned memory region is <strong>consecutive</strong>. If the heap manager can't allocate consecutive memory of <code>size</code>, it's fail. an exception (or NULL in <code>malloc</code>) will be returned.</p>\n<p><strong>Programmers will always see the illusion of consecutive (and yes, infinite :-) memory in a process's address space.</strong> This is what virtual memory provides to programmers.</p>\n<p>Note that programmers (other than a few embedded systems) always see virtual memory. However, virtually consecutive memory could be mapped (in granularity of 'page' size, which is typically 4KB) in physical memory in arbitrary fashion. That mapping, you can't see, and mostly you don't need to understand it (except for very specific page-level optimizations).</p>\n<p>What about this?</p>\n<pre><code>BYTE* data1 = new BYTE[size1];\nBYTE* data2 = new BYTE[size2];\n</code></pre>\n<p>Sure, you can't say the relative address of <code>data1</code> and <code>data2</code>. It's generally non-deterministic. It depends on heap manager (such as <code>malloc</code>, often <code>new</code> is just wrapped <code>malloc</code>) policies and current heap status when a request was made.</p>\n", "LastActivityDate": "2009-11-12T03:29:29.313"}, "1720221": {"ParentId": "1719607", "CommentCount": "0", "CreationDate": "2009-11-12T06:04:59.187", "OwnerUserId": "205475", "PostTypeId": "2", "Id": "1720221", "Score": "0", "Body": "<p>Physical memory is never contiguous its logical memory which is contiguous.</p>\n", "LastActivityDate": "2009-11-12T06:04:59.187"}, "1719675": {"ParentId": "1719607", "CommentCount": "0", "CreationDate": "2009-11-12T03:20:34.243", "OwnerUserId": "77047", "PostTypeId": "2", "Id": "1719675", "Score": "3", "Body": "<p>Case 1:\n Using \"new\" to allocate an array, as in</p>\n<pre><code>int* foo = new int[10];\n</code></pre>\n<p>In this case, each element of foo <strong>will</strong> be in contiguous virtual memory.</p>\n<p>Case 2:\n Using consecutive \"new\" operations non-atomically, as in</p>\n<pre><code>int* foo = new int;\nint* bar = new int;\n</code></pre>\n<p>In this case, there is never a guarantee that the memory allocated between calls to \"new\" will be adjacent in virtual memory.</p>\n", "LastActivityDate": "2009-11-12T03:20:34.243"}, "1719607": {"CommentCount": "4", "ViewCount": "2580", "CreationDate": "2009-11-12T03:00:36.873", "LastActivityDate": "2009-11-12T06:04:59.187", "Title": "Is the memory allocated by new operated consecutive?", "AcceptedAnswerId": "1719647", "PostTypeId": "1", "Id": "1719607", "Score": "1", "Body": "<p>as the title says, I want to know in c++, whether the memory allocated by one new operation is consecutive...</p>\n", "Tags": "<c++>", "OwnerUserId": "81992", "AnswerCount": "7"}, "1719658": {"ParentId": "1719607", "CommentCount": "0", "CreationDate": "2009-11-12T03:14:34.647", "OwnerUserId": "106671", "PostTypeId": "2", "Id": "1719658", "Score": "2", "Body": "<p>The virtual addresses of the allocated bytes will be contiguous. They will also be physically contiguous within resident pages backing the address space of your process. The mapping of physical pages to regions of the process virtual space is very OS and platform specific, but in general you cannot assume physically contiguous range larger then or not aligned on a page.</p>\n", "LastActivityDate": "2009-11-12T03:14:34.647"}, "1719609": {"ParentId": "1719607", "PostTypeId": "2", "CommentCount": "10", "CreationDate": "2009-11-12T03:01:34.330", "Score": "6", "LastEditorUserId": "151292", "LastEditDate": "2009-11-12T03:33:45.357", "Id": "1719609", "OwnerUserId": "151292", "Body": "<p>The memory allocated in <em>your process's address space</em> will be contiguous.  </p>\n<p>How those bytes are mapped into physical memory is implementation-specific; if you allocate a very large block of memory, it is likely to be mapped to different parts of physical memory.</p>\n<p><strong>Edit:</strong>  Since someone disagrees that the bytes are guaranteed to be contiguous, the standard says (3.7.3.1):</p>\n<blockquote>\n<p id=\"so_1719607_1719609_0\">The allocation function attempts to allocate the requested amount of storage.  If it is successful, it shall return the address of the start of a block of storage whose length in bytes shall be at least as large as the requested size.</p>\n</blockquote>\n", "LastActivityDate": "2009-11-12T03:33:45.357"}, "1719719": {"ParentId": "1719607", "CommentCount": "0", "CreationDate": "2009-11-12T03:35:06.320", "OwnerUserId": "69178", "PostTypeId": "2", "Id": "1719719", "Score": "0", "Body": "<p>Yes.</p>\n<p>Don't bother about the \"virtual memory\" issue: apart that there could be cases when you haven't at all a system that supports virtual memory, from <strong>your</strong> PoV you get a consecutive memory chunk. That's all.</p>\n", "LastActivityDate": "2009-11-12T03:35:06.320"}, "bq_ids": {"n4140": {"so_1719607_1719609_0": {"section_id": 7177, "quality": 0.9523809523809523, "length": 20}}, "n3337": {"so_1719607_1719609_0": {"section_id": 6921, "quality": 0.9523809523809523, "length": 20}}, "n4659": {"so_1719607_1719609_0": {"section_id": 8685, "quality": 0.9523809523809523, "length": 20}}}, "1719966": {"ParentId": "1719607", "CommentCount": "0", "CreationDate": "2009-11-12T04:54:49.033", "OwnerUserId": "157168", "PostTypeId": "2", "Id": "1719966", "Score": "0", "Body": "<p>If by your question you mean \"Will successive (in time) new() operations return adjacent chunks of memory, with no gaps in between?\", this old programmer will suggest, very politely, that you should not rely on it.</p>\n<p>The only reason that question would come up was if you intended to walk a pointer \"out\" of one data object and \"into\" the next one.  This is a really bad idea, since you have no guarantee that the next object in the address space is of anything remotely resembling the same type as the previous one.</p>\n", "LastActivityDate": "2009-11-12T04:54:49.033"}});