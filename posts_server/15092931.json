post_cb({"15093007": {"ParentId": "15092931", "PostTypeId": "2", "CommentCount": "5", "Body": "<p><strong>Edit</strong> my original answer was quite wrong, so I have edited it heavily.</p>\n<p>If you want to guarantee that <code>A::a</code> is zero-initialized in the absence of value initialization calls such as</p>\n<pre><code>A a1; //\n</code></pre>\n<p>or</p>\n<pre><code>B() { .... }\n</code></pre>\n<p>then you can give <code>A</code> a constructor and do the initialization there:</p>\n<pre><code>class A {\npublic:\n  A() : a() {} // value initialization of a, means zero initialization here.\n    int a;\n};\n</code></pre>\n<p>Otherwise, explicitly calling <code>A()</code> in <code>B</code> and <code>C</code>'s constructors performs the value initialization.</p>\n<pre><code>// value initialization of A sub-object leads to zero initialization of A::a\n B() : A() {} \n</code></pre>\n<p>This also works for initialization of an <code>A</code> instance:</p>\n<pre><code>A a1 = A();\n</code></pre>\n", "OwnerUserId": "661519", "LastEditorUserId": "661519", "LastEditDate": "2013-02-26T15:52:26.010", "Id": "15093007", "Score": "3", "CreationDate": "2013-02-26T15:31:45.380", "LastActivityDate": "2013-02-26T15:52:26.010"}, "15093382": {"ParentId": "15092931", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>With your original code</p>\n<pre><code>class A {\npublic:\n    int a;\n};\n\nclass B : public A {\npublic:\n    B() { std::cout &lt;&lt; \"B[\" &lt;&lt; a &lt;&lt; \"]\" &lt;&lt; std::endl; }\n};\n</code></pre>\n<p>the members of <code>A</code> are not initialized, because you have not specified any initialization. And generally, in C++ you don't pay for what you don't need. So, you don't get initialization by default for POD members (however, you do get it for members that have constructors, because there the initialization is specified).</p>\n<p>In your subsequent \"explicit constructor call\" code</p>\n<pre><code>class B : public A {\npublic:\n    B() : A() { std::cout &lt;&lt; \"B[\" &lt;&lt; a &lt;&lt; \"]\" &lt;&lt; std::endl; }\n};\n</code></pre>\n<p>you have specified <strong>value initialization</strong> of the <code>A</code> base class sub-object. Effectively this reduces to zero-initialization.</p>\n<p>It's the same difference as</p>\n<pre><code>A* p = new A;\n</code></pre>\n<p>versus</p>\n<pre><code>A* p = new A();\n</code></pre>\n<p>The latter value-initializes the object.</p>\n<hr>\n<p>Standardese\u2026</p>\n<blockquote>\n<p id=\"so_15092931_15093382_0\"><strong>C++11 \u00a78.5/10</strong>:<br>\n  \u201cAn object whose initializer is an empty set of parentheses, i.e., <code>()</code>, shall be value-initialized.\u201d</br></p>\n</blockquote>\n<blockquote>\n<p id=\"so_15092931_15093382_1\"><strong>C++11 \u00a78.5./7</strong>:<br>\n  \u201cTo <i>value-initialize</i> an object of type <code>T</code> means:<br>\n  \u2014 if <code>T</code> is a (possibly cv-qualified) class type (Clause 9) with a user-provided constructor (12.1), then the default constructor for <code>T</code> is called (and the initialization is ill-formed if <code>T</code> has no accessible default constructor);<br>\n  \u2014 if <code>T</code> is a (possibly cv-qualified) non-union class type without a user-provided constructor, then the object is zero-initialized and, if T\u2019s implicitly-declared default constructor is non-trivial, that constructor is called.<br>\n  \u2014 if <code>T</code> is an array type, then each element is value-initialized;<br>\n  \u2014 otherwise, the object is zero-initialized.<br>\n  An object that is value-initialized is deemed to be constructed and thus subject to provisions of this International Standard applying to \u201cconstructed\u201d objects, objects \u201cfor which the constructor has completed,\u201d etc., even if no constructor is invoked for the object\u2019s initialization.\u201d</br></br></br></br></br></br></p>\n</blockquote>\n<p>It is perhaps worth noting that value initialization was not part of the original C++98. It was introduced in C++03, by Andrew Koenig (of \"Koenig look-up\" fame) in order to deal with some severe problems of unexpected effects of pure default-initialization. Which is what the <code>()</code> initializer bought you in C++98.</p>\n</hr>", "OwnerUserId": "464581", "LastEditorUserId": "464581", "LastEditDate": "2013-02-26T15:58:54.587", "Id": "15093382", "Score": "6", "CreationDate": "2013-02-26T15:48:02.777", "LastActivityDate": "2013-02-26T15:58:54.587"}, "bq_ids": {"n4140": {"so_15092931_15093382_1": {"section_id": 3287, "quality": 0.7536231884057971, "length": 52}, "so_15092931_15093382_0": {"section_id": 3290, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_15092931_15093382_1": {"section_id": 3157, "quality": 0.9420289855072463, "length": 65}, "so_15092931_15093382_0": {"section_id": 3160, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_15092931_15093382_0": {"section_id": 4052, "quality": 0.7777777777777778, "length": 7}}}, "15092931": {"CommentCount": "1", "ViewCount": "122", "CreationDate": "2013-02-26T15:28:32.880", "LastActivityDate": "2013-02-26T15:58:54.587", "Title": "Constructor call in inherited classes", "AcceptedAnswerId": "15093382", "PostTypeId": "1", "Id": "15092931", "Score": "2", "Body": "<p>Consider the following code:</p>\n<pre><code>class A {\npublic:\n    int a;\n};\n\nclass B : public A {\npublic:\n    B() { std::cout &lt;&lt; \"B[\" &lt;&lt; a &lt;&lt; \"]\" &lt;&lt; std::endl; }\n};\n\nclass C : public B {\npublic:\n    C() { std::cout &lt;&lt; \"C[\" &lt;&lt; a &lt;&lt; \"]\" &lt;&lt; std::endl; }\n};\n\nint main(int argc, char *argv[]) {\n\n    B();\n    std::cout &lt;&lt; std::endl;\n    C();\n\n}\n</code></pre>\n<p>And its output -- program compiled with g++ (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3:</p>\n<pre><code>B[0]\n\nB[-2097962768]\nC[-2097962768]\n</code></pre>\n<p>The only way I found to get the second call -- <code>C()</code> -- to have its values initialized was adding an explicit call to the constructors, like:</p>\n<pre><code>class B : public A {\npublic:\n    B() : A() { std::cout &lt;&lt; \"B[\" &lt;&lt; a &lt;&lt; \"]\" &lt;&lt; std::endl; }\n};\n\nclass C : public B {\npublic:\n    C() : B() { std::cout &lt;&lt; \"C[\" &lt;&lt; a &lt;&lt; \"]\" &lt;&lt; std::endl; }\n};\n</code></pre>\n<p>Although I understand that calling the default constructor of each former class will initialize the values, I'm not able to see what is being called when nothing is specified.</p>\n<p>Isn't the default constructor what is called by default -- hence its handle?</p>\n", "Tags": "<c++><constructor><initialization><default><default-constructor>", "OwnerUserId": "1655939", "AnswerCount": "2"}});