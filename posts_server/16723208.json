post_cb({"bq_ids": {"n4140": {"so_16723208_16723951_0": {"length": 37, "quality": 0.9736842105263158, "section_id": 3321}, "so_16723208_16723951_2": {"length": 10, "quality": 0.5263157894736842, "section_id": 3321}, "so_16723208_16723951_3": {"length": 11, "quality": 0.5789473684210527, "section_id": 3321}}, "n3337": {"so_16723208_16723951_0": {"length": 38, "quality": 1.0, "section_id": 3191}, "so_16723208_16723951_2": {"length": 10, "quality": 0.5263157894736842, "section_id": 3191}, "so_16723208_16723951_3": {"length": 14, "quality": 0.7368421052631579, "section_id": 3191}}, "n4659": {"so_16723208_16723951_0": {"length": 32, "quality": 0.8421052631578947, "section_id": 4087}, "so_16723208_16723951_2": {"length": 12, "quality": 0.631578947368421, "section_id": 4087}}}, "16723951": {"Id": "16723951", "PostTypeId": "2", "Body": "<p>The relevant quote from the standard is in 8.5.3p5 (C++11):</p>\n<blockquote>\n<p id=\"so_16723208_16723951_0\">has a class type (i.e., T2 is a class type), where T1 is not\n  reference-related to T2, and can be implicitly converted to an xvalue,\n  class prvalue, or function lvalue of type \u201ccv3 T3\u201d, where \u201ccv1 T1\u201d is\n  reference-compatible with \u201ccv3 T3\u201d, then the reference is bound to the\n  value of the initializer expression in the first case and to the\n  <strong>result of the conversion in the second case (or, in either case, to an\n  appropriate base class subobject</strong>).</p>\n<p id=\"so_16723208_16723951_1\">Example:</p>\n</blockquote>\n<pre><code>struct A { };\nstruct B : A { } b;\nextern B f();\nconst A&amp; rca2 = f(); // bound to the A subobject of the B rvalue.\nA&amp;&amp; rra = f(); // same as above\nstruct X {\noperator B();\noperator int&amp;();\n} x;\nconst A&amp; r = x; // bound to the A subobject of the result of the conversion\n</code></pre>\n<p>In your case, <code>T1</code> is <code>Base</code>, <code>T2</code> is <code>NewDerived</code>, and <code>T3</code> is <code>Derived</code>. From the above quote, the copy constructor <strong>should not</strong> be called and the lvalue reference should bind to the <code>Base</code> subobject.</p>\n<p>However, note that in C++03, this was not the case. In C++03, the following quotes were pertinent:</p>\n<blockquote>\n<p id=\"so_16723208_16723951_2\">If the initializer expression is an rvalue, with T2 a class type, and\n  \u201ccv1 T1\u201d is reference-compatible with \u201ccv2 T2,\u201d the reference is bound\n  to the object represented by the rvalue (see 3.10 [basic.lval]) or to\n  a sub-object within that object.</p>\n</blockquote>\n<p>...</p>\n<blockquote>\n<p id=\"so_16723208_16723951_3\">Otherwise, <strong>a temporary of type \u201ccv1 T1\u201d is created</strong> and initialized\n  from the initializer expression using the rules for a non-reference\n  copy initialization (8.5 [dcl.init]). The reference is then bound to\n  the temporary.</p>\n</blockquote>\n<p>The first quoted paragraph does not apply, because <code>Base</code> is not reference compatible with <code>NewDerived</code>, so only the last paragraph applies, which means a temporary <code>Base</code> object must be created. Therefore, MSVC2008 and gcc are conforming to C++03 rules.</p>\n", "LastEditorUserId": "906773", "LastActivityDate": "2013-05-23T21:17:35.950", "Score": "6", "CreationDate": "2013-05-23T21:11:13.967", "ParentId": "16723208", "CommentCount": "7", "OwnerUserId": "906773", "LastEditDate": "2013-05-23T21:17:35.950"}, "16723208": {"ViewCount": "147", "Body": "<p>I'm getting unexpected behavior from the following code:</p>\n<pre><code>struct Base\n{\n    Base() {}\n    virtual ~Base() {}\n\n    virtual void foo() const = 0;\n\nprotected:\n    Base(const Base &amp;) {}\n};\n\nstruct Derived : public Base\n{\n    Derived() {}\n    Derived(const Derived &amp;other) : Base(other) {}\n\n    virtual void foo() const {}\n};\n\nstruct NewDerived\n{\n    operator const Derived() { return Derived(); }\n};\n\nvoid func(const Base &amp;b)\n{\n    b.foo();\n}\n\nint main()\n{\n    func(NewDerived());\n    return 0;\n}\n</code></pre>\n<p>With MSVC2008, I get this compilation error in main():</p>\n<pre><code>error C2248: 'Base::Base' : cannot access protected member declared in class 'Base'\n</code></pre>\n<p>Why is it trying to access the copy constructor of Base?</p>\n<p>If I make Base's copy constructor public, the code compiles and slices the return value at runtime and the call to foo() inside func() triggers a pure virtual function called error.</p>\n<p>Can someone please shed a bit of light?</p>\n", "Title": "Conversion operator is slicing my object", "CreationDate": "2013-05-23T20:22:11.887", "LastActivityDate": "2014-11-27T13:48:48.457", "CommentCount": "0", "LastEditDate": "2014-11-27T13:48:48.457", "PostTypeId": "1", "LastEditorUserId": "1816580", "Id": "16723208", "Score": "2", "OwnerUserId": "814222", "Tags": "<c++><object-slicing><conversion-operator>", "AnswerCount": "1"}});