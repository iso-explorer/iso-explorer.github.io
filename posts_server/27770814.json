post_cb({"bq_ids": {"n4140": {"so_27770814_27770873_4": {"length": 21, "quality": 0.9545454545454546, "section_id": 3304}, "so_27770814_27770873_5": {"length": 12, "quality": 1.0, "section_id": 3304}, "so_27770814_27770873_2": {"length": 12, "quality": 1.0, "section_id": 3316}, "so_27770814_27770873_3": {"length": 9, "quality": 1.0, "section_id": 3303}, "so_27770814_27770873_0": {"length": 38, "quality": 0.95, "section_id": 3314}, "so_27770814_27770873_1": {"length": 7, "quality": 1.0, "section_id": 3315}}, "n3337": {"so_27770814_27770873_3": {"length": 9, "quality": 1.0, "section_id": 3173}, "so_27770814_27770873_5": {"length": 9, "quality": 0.75, "section_id": 3174}, "so_27770814_27770873_2": {"length": 12, "quality": 1.0, "section_id": 3186}, "so_27770814_27770873_4": {"length": 17, "quality": 0.7727272727272727, "section_id": 3174}, "so_27770814_27770873_0": {"length": 34, "quality": 0.85, "section_id": 3184}, "so_27770814_27770873_1": {"length": 7, "quality": 1.0, "section_id": 3185}}, "n4659": {"so_27770814_27770873_3": {"length": 8, "quality": 0.8888888888888888, "section_id": 4069}, "so_27770814_27770873_5": {"length": 12, "quality": 1.0, "section_id": 4070}, "so_27770814_27770873_2": {"length": 12, "quality": 1.0, "section_id": 4082}, "so_27770814_27770873_4": {"length": 16, "quality": 0.7272727272727273, "section_id": 4070}, "so_27770814_27770873_0": {"length": 38, "quality": 0.95, "section_id": 4080}, "so_27770814_27770873_1": {"length": 7, "quality": 1.0, "section_id": 4081}}}, "27770814": {"ViewCount": "165", "Body": "<p>Let's say I have:</p>\n<pre><code>char name[16] = \"123456789abc\";\n</code></pre>\n<p>so <code>name[11] == 'c'</code>, <code>name[12] == '\\0'</code>.</p>\n<p>Will <code>name[13]</code> be gibberish/compiler-dependant, or will it reliably be a specific value (such as '\\0'?)</p>\n", "AcceptedAnswerId": "27770873", "Title": "Assigning a const-string to a constant sized char array, what happens in un-used array indices?", "CreationDate": "2015-01-04T21:59:05.853", "Id": "27770814", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2015-01-04T22:20:48.297", "Score": "3", "OwnerUserId": "2043902", "Tags": "<c++><c++11>", "AnswerCount": "1"}, "27770873": {"Id": "27770873", "PostTypeId": "2", "Body": "<p>When a character array is initialized from a string literal, unused elements are initialized to zero.</p>\n<p>Section 8.5.2 has the rule:</p>\n<blockquote>\n<p id=\"so_27770814_27770873_0\">An array of narrow character type (3.9.1), <code>char16_t</code> array, <code>char32_t</code> array, or <code>wchar_t</code> array can be initialized  by  a  narrow  string  literal,  <code>char16_t</code>  string  literal,  <code>char32_t</code>  string  literal,  or  wide  string  literal, respectively, or by an appropriately-typed string literal enclosed in braces (2.14.5).  Successive characters of the value of the string literal initialize the elements of the array.</p>\n<p id=\"so_27770814_27770873_1\">There shall not be more initializers than there are array elements.</p>\n<p id=\"so_27770814_27770873_2\"><strong>If there are fewer initializers than there are array elements, each element not explicitly initialized shall be zero-initialized (8.5).</strong></p>\n</blockquote>\n<p>Therefore, they will be zero.  Guaranteed.</p>\n<p>And accessing them is not undefined behavior.</p>\n<hr>\n<p>If you initialized from a list of characters instead <code>char name[16] = { '1', '2', '3', '4', '5', 0 };</code>, you'd be in the realm of aggregate initialization, which gives the same result through a different route.</p>\n<p>When aggregate initialization is used and there are fewer initializers than elements of the aggregate, the remainder are value initialized (unless there is a <em>brace-or-equal-initializer</em> in the definition of the aggregate type).</p>\n<p>The rule is found in section 8.5.1</p>\n<blockquote>\n<p id=\"so_27770814_27770873_3\">An initializer-list is ill-formed if the number of initializer-clauses exceeds the number of members or elements to initialize.</p>\n<p id=\"so_27770814_27770873_4\"><strong>If there are fewer initializer-clauses in the list than there are members in the aggregate, then each member not explicitly initialized shall be initialized from its brace-or-equal-initializer or, if there is no brace-or-equal-initializer, from an empty initializer list (8.5.4).</strong></p>\n</blockquote>\n<p>And there is an example given:</p>\n<blockquote>\n<pre><code>struct  S  {  int  a;  const  char*  b;  int  c;  int  d  =  b[a];  };\nS  ss  =  {  1,  \"asdf\"  };\n</code></pre>\n<p id=\"so_27770814_27770873_5\">initializes <code>ss.a</code> with <code>1</code>, <code>ss.b</code> with <code>\"asdf\"</code>, <code>ss.c</code> with the value of an expression of the form <code>int{}</code> (<strong>that\n  is, <code>0</code></strong>), and <code>ss.d</code> with the value of <code>ss.b[ss.a]</code> (that is, <code>'s'</code>)</p>\n</blockquote>\n<hr>\n<p>C++03 didn't explicitly state that extra elements would be zero-initialized in the character array rule.  On the other hand the aggregate rule was substantially similar and did guarantee value initialization, always (<em>brace-or-equal-initializer</em> was introduced in C++11).</p>\n<p>C99 section 6.7.8 provides zero initialization in both cases, to wit:</p>\n<blockquote>\n<p id=\"so_27770814_27770873_6\">If there are fewer initializers in a brace-enclosed list than there are elements or members\n  of an aggregate, or fewer characters in a string literal used to initialize an array of known\n  size  than  there  are  elements  in  the  array,  the  remainder  of  the  aggregate  shall  be\n  initialized implicitly the same as objects that have static storage duration.</p>\n</blockquote>\n<p>Of course, objects with static storage duration are pre-initialized to zero.</p>\n</hr></hr>", "LastEditorUserId": "103167", "LastActivityDate": "2015-01-04T22:20:48.297", "Score": "8", "CreationDate": "2015-01-04T22:05:43.520", "ParentId": "27770814", "CommentCount": "8", "LastEditDate": "2015-01-04T22:20:48.297", "OwnerUserId": "103167"}});