post_cb({"4153663": {"ParentId": "4153527", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>To expand on @MSalters' answer (which is correct), if you were to add <code>passByValue(a);</code> to your <code>main()</code> function, the compiler <s>would</s> should complain about it.</p>\n<p>Explicit copy constructors are for preventing exactly this, i.e. to prevent implicit copying of resources in function calls and so on (essentially it forces the user to pass-by-reference rather than pass-by-value).</p>\n", "OwnerUserId": "129570", "LastEditorUserId": "129570", "LastEditDate": "2010-11-11T11:10:04.937", "Id": "4153663", "Score": "2", "CreationDate": "2010-11-11T10:55:09.000", "LastActivityDate": "2010-11-11T11:10:04.937"}, "4153619": {"ParentId": "4153527", "CommentCount": "5", "Body": "<p>The definition of <code>passByValue</code> is OK, because there's no statement that copies an A object. In the definition of <code>retByValue</code> there's of course a return statement that copies an A object.</p>\n", "OwnerUserId": "15416", "PostTypeId": "2", "Id": "4153619", "Score": "4", "CreationDate": "2010-11-11T10:50:57.313", "LastActivityDate": "2010-11-11T10:50:57.313"}, "4154213": {"ParentId": "4153527", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I believe the relevant sections of C++03 are <a href=\"http://www.lcdf.org/c++/clause12.html#s12.1\" rel=\"noreferrer\">\u00a712.3.1</a> 2:</p>\n<blockquote>\n<p id=\"so_4153527_4154213_0\">An explicit constructor constructs objects just like non-explicit constructors, but does so only where the direct-initialization syntax (<a href=\"http://www.lcdf.org/c++/clause8.html#s8.5\" rel=\"noreferrer\">8.5</a>) or where casts (<a href=\"http://www.lcdf.org/c++/clause5.html#s5.2.9\" rel=\"noreferrer\">5.2.9</a>, <a href=\"http://www.lcdf.org/c++/clause5.html#s5.4\" rel=\"noreferrer\">5.4</a>) are explicitly used. A default constructor may be an explicit constructor; such a constructor will be used to perform default-initialization or value-initialization (<a href=\"http://www.lcdf.org/c++/clause8.html#s8.5\" rel=\"noreferrer\">8.5</a>). </p>\n</blockquote>\n<p>and <a href=\"http://www.lcdf.org/c++/clause8.html#s8.5\" rel=\"noreferrer\">\u00a7 8.5</a> 12:</p>\n<blockquote>\n<p id=\"so_4153527_4154213_1\">The initialization that occurs in argument passing, function return, throwing an exception (<a href=\"http://www.lcdf.org/c++/clause15.html#s15.1\" rel=\"noreferrer\">15.1</a>), handling an exception (<a href=\"http://www.lcdf.org/c++/clause15.html#s15.3\" rel=\"noreferrer\">15.3</a>), and brace-enclosed initializer lists (<a href=\"http://www.lcdf.org/c++/clause8.html#s8.5.1\" rel=\"noreferrer\">8.5.1</a>) is called copy-initialization and is equivalent to the form</p>\n<pre><code>    T x = a;\n</code></pre>\n<p id=\"so_4153527_4154213_2\">The initialization that occurs in new expressions (<a href=\"http://www.lcdf.org/c++/clause5.html#s5.3.4\" rel=\"noreferrer\">5.3.4</a>), static_cast expressions (<a href=\"http://www.lcdf.org/c++/clause5.html#s5.2.9\" rel=\"noreferrer\">5.2.9</a>), functional notation type conversions (<a href=\"http://www.lcdf.org/c++/clause5.html#s5.2.3\" rel=\"noreferrer\">5.2.3</a>), and base and member initializers (<a href=\"http://www.lcdf.org/c++/clause12.html#s12.6.2\" rel=\"noreferrer\">12.6.2</a>) is called direct-initialization and is equivalent to the form</p>\n<pre><code>    T x(a);\n</code></pre>\n</blockquote>\n<p>Calling <code>passByValue(a)</code> involves copy-initialization, not direct-initialization, and thus should be an error, according to C++03 \u00a7 12.3.1 2.</p>\n", "OwnerUserId": "90527", "LastEditorUserId": "90527", "LastEditDate": "2010-11-11T12:13:26.667", "Id": "4154213", "Score": "39", "CreationDate": "2010-11-11T12:06:42.750", "LastActivityDate": "2010-11-11T12:13:26.667"}, "4153527": {"CommentCount": "2", "AcceptedAnswerId": "4154213", "PostTypeId": "1", "LastEditorUserId": "1242646", "CreationDate": "2010-11-11T10:40:19.793", "LastActivityDate": "2017-03-20T09:59:42.103", "LastEditDate": "2017-03-20T09:59:42.103", "ViewCount": "9947", "FavoriteCount": "10", "Title": "Explicit copy constructor behavior and practical uses", "Id": "4153527", "Score": "35", "Body": "<p>A recent question got me wondering about explicit copy constructors. Here is a sample code that I tried compiling under Visual Studio 2005 :</p>\n<pre><code>struct A\n{\n    A() {}\n    explicit A(const A &amp;) {}\n};\n\n// #1 &gt; Compilation error (expected behavior)\nA retByValue()\n{\n    return A();\n}\n\n// #2 &gt; Compiles just fine, but why ?\nvoid passByValue(A a)\n{\n}\n\nint main()\n{\n    A a;\n    A b(a); // #3 &gt; explicit copy construction : OK (expected behavior)\n    A c = a; // #4 &gt; implicit copy construction : KO (expected behavior)\n\n    // Added after multiple comments : not an error according to VS 2005.\n    passByValue(a);\n    return 0;\n}\n</code></pre>\n<p>Now for the questions :</p>\n<ul>\n<li>Is #2 allowed by the standard ? If it is, what is the relevant section describing this situation ?</li>\n<li>Do you known of any practical use for an explicit copy constructor ? </li>\n</ul>\n<p><strong>[EDIT]</strong> I just found a funny link on <a href=\"http://msdn.microsoft.com/en-us/library/h1y7x448.aspx\" rel=\"noreferrer\">MSDN</a> with the exact same situation, and a mysterious comment from the main function : \"c is copied\" (as if it was obvious). As pointed by Oli Charlesworth : gcc does not compile this code and I believe he's right not to.</p>\n", "Tags": "<c++>", "OwnerUserId": "451980", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_4153527_4154213_2": {"section_id": 3295, "quality": 0.6818181818181818, "length": 15}, "so_4153527_4154213_1": {"section_id": 3294, "quality": 0.5238095238095238, "length": 11}, "so_4153527_4154213_0": {"section_id": 389, "quality": 0.9642857142857143, "length": 27}}, "n3337": {"so_4153527_4154213_2": {"section_id": 3165, "quality": 0.6818181818181818, "length": 15}, "so_4153527_4154213_1": {"section_id": 3164, "quality": 0.5238095238095238, "length": 11}, "so_4153527_4154213_0": {"section_id": 380, "quality": 0.9642857142857143, "length": 27}}, "n4659": {"so_4153527_4154213_1": {"section_id": 4056, "quality": 0.5238095238095238, "length": 11}, "so_4153527_4154213_0": {"section_id": 406, "quality": 0.9642857142857143, "length": 27}}}, "33915396": {"ParentId": "4153527", "CommentCount": "0", "Body": "<p>A practical use, prior to C++11, of making a copy constructor explicit is in the case where it is actually part of making a class non-copyable.</p>\n<p>The danger is that, although you declare the copy constructor private and don't implement it, if you do accidentally copy one either in a friend or in the class itself, the compiler won't pick it up and you'll only get a hard-to-find link error.</p>\n<p>Making it explicit as well cuts down the chance of this as the compiler may well pick up your unintentional copy and point to the actual line where you're doing it.</p>\n<p>In C++11 (and 14) there is no need to do this when using the <code>=delete</code> syntax as you would get a compiler error even if copying within the class itself or within a friend.</p>\n", "OwnerUserId": "442284", "PostTypeId": "2", "Id": "33915396", "Score": "3", "CreationDate": "2015-11-25T11:30:36.733", "LastActivityDate": "2015-11-25T11:30:36.733"}});