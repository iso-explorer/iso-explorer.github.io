post_cb({"18218263": {"ParentId": "18218146", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>Remove the parentheses around the string literal. The parentheses make the macro expand into an expression that will decay into a pointer type, which makes it not compile in your C compiler. A pointer type cannot be used to initialize an array. Without the parentheses, the string literal is used to initialize the array.</p>\n<pre><code>#define PROD_FAMILY_NAME \"product name goes here\"\n</code></pre>\n<p>The C standard states that a parenthesized expression takes on the same type as the unparenthesized expression, C.99 \u00a76.5.1 \u00b65:</p>\n<blockquote>\n<p id=\"so_18218146_18218263_0\">A parenthesized expression is a primary expression. <strong>Its type and value are identical to those of the unparenthesized expression.</strong> It is an lvalue, a function designator, or a void expression if the unparenthesized expression is, respectively, an lvalue, a function designator, or a void expression.</p>\n</blockquote>\n<p>However, while a string literal is an expression, the converse is not true. Specifically, a string literal in of itself is not a type, but a defined entity. The initialization of arrays makes a specific allowance for a string literal, C.99 \u00a76.7.8 \u00b614:</p>\n<blockquote>\n<p id=\"so_18218146_18218263_1\"><strong>An array of character type may be initialized by a character string literal</strong>, optionally\n  enclosed in braces.</p>\n</blockquote>\n<p>The other allowed initializers for an array are described in C.99 \u00a76.7.8 \u00b616:</p>\n<blockquote>\n<p id=\"so_18218146_18218263_2\">Otherwise, the initializer for an object that has aggregate or union type shall be a brace enclosed list of initializers for the elements or named members.</p>\n</blockquote>\n<p>A parenthesized expression is not a string literal, nor a brace enclosed list of initializers.</p>\n", "OwnerUserId": "315052", "LastEditorUserId": "315052", "LastEditDate": "2013-08-13T21:10:33.967", "Id": "18218263", "Score": "11", "CreationDate": "2013-08-13T20:06:46.290", "LastActivityDate": "2013-08-13T21:10:33.967"}, "18218286": {"ParentId": "18218146", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As <code>PROD_FAMILY_NAME</code> is a (constant) string, the compiler expects <code>ID</code> to be declared as something like <code>uint8_t *ID;</code> as strings are generally represented as pointers to characters in memory in C. See my example here: <a href=\"http://ideone.com/m5ZZl0\" rel=\"nofollow\">http://ideone.com/m5ZZl0</a></p>\n<p>To do this with a character array as you have, you need to do a <code>strcpy</code> or <code>memcpy</code> from the product family name to your <code>ID</code> byte array as C doesn't support direct array assignment as far as I know. If the product name will be a variable but isn't going to change and won't go out of scope, I'd recommend using a <code>uint8_t*</code>-typed <code>ID</code>, but if you need a copy of the name and don't want to dynamically allocate memory you may want to stick with an array (but note that older versions of the C standard don't support non-static-length arrays, either [though there are ways of getting around that with a variable-length array at the end of the struct, but you often have to keep track of the struct size manually in such cases as <code>sizeof()</code> will return 0 for such arrays; things like <code>strlen()</code> should still work fine, though.)</p>\n<hr>\n<p>Seems I forgot that, while array assignment isn't allowed, something like <code>char array[] = \"literal string\";</code> still is. (<a href=\"http://ideone.com/vilDOa\" rel=\"nofollow\">http://ideone.com/vilDOa</a> vs. <a href=\"http://ideone.com/gEC2k2\" rel=\"nofollow\">http://ideone.com/gEC2k2</a>) So my above was a bit pointless, but I do think that dynamically sizing structs isn't all that good of an idea if you want to have an array of such structs, in which case the <code>char*</code> method can be a better idea (even if it's just a pointer to an array elsewhere).</p>\n</hr>", "OwnerUserId": "138772", "LastEditorUserId": "138772", "LastEditDate": "2013-08-13T20:25:17.963", "Id": "18218286", "Score": "0", "CreationDate": "2013-08-13T20:07:55.720", "LastActivityDate": "2013-08-13T20:25:17.963"}, "bq_ids": {"n4140": {"so_18218146_18218263_1": {"section_id": 3314, "quality": 0.7272727272727273, "length": 8}}, "n3337": {"so_18218146_18218263_1": {"section_id": 3184, "quality": 0.6363636363636364, "length": 7}}, "n4659": {"so_18218146_18218263_1": {"section_id": 4080, "quality": 0.7272727272727273, "length": 8}}}, "18218146": {"CommentCount": "6", "AcceptedAnswerId": "18218263", "PostTypeId": "1", "LastEditorUserId": "645128", "CreationDate": "2013-08-13T20:00:22.013", "LastActivityDate": "2014-07-27T01:42:23.143", "LastEditDate": "2013-08-13T20:17:00.623", "ViewCount": "426", "FavoriteCount": "1", "Title": "Is there a way to modify this C++ struct assignment block to work in straight C", "Id": "18218146", "Score": "6", "Body": "<p>The following code resides in a device that will issue a deviceId (LXdeviceInfo) when enumerated through an IrDA sockets connection.  This is only important to explain why I would like to keep the data types as similar as possible, but be able to compile using ansi C</p>\n<p>With #includes of windows.h and af_irda.h, the following code compiles with no errors in a C++ compiler, but breaks in a C compiler just below the struct assignment (see ERROR here).  Ideally I would like to initialize the struct member <em>'ID'</em> to be an array of characters while keeping it typed just as it is in the original code so I can test the value of LXdeviceInfo just as it would appear when querying it from a call to the device from a PC socket connection.</p>\n<p><em><strong>Is there some way to modify this assignment block to work in straight C?</strong></em></p>\n<pre><code>#include &lt;windows.h&gt;\n#include &lt;af_irda.h&gt;\n\n#define IR_HINT_COMPUTER  0x04\n#define IR_HINT_EXT       0x80\n#define IR_HINT_OBEX      0x20\n#define IR_HINT_IRCOMM    0x04\n#define IR_CHAR_ASCII       0\n#define PROD_FAMILY_NAME (\"product name goes here\")\n\n#define uint8_t unsigned char\n\nconst struct {\n    uint8_t hint1;\n    uint8_t hint2;\n    uint8_t charset;\n    uint8_t ID[sizeof(PROD_FAMILY_NAME)];\n} devInfoStorage = \n{\n    IR_HINT_COMPUTER | IR_HINT_EXT,   // hint1\n    IR_HINT_OBEX | IR_HINT_IRCOMM,    // hint2\n    IR_CHAR_ASCII,                    // charset\n    PROD_FAMILY_NAME                  // Prod ID string\n}; // ERROR here: Innvalid initialization type: found 'pointer to char' expected 'unsigned char'\n\nconst uint8_t *LXdeviceInfo = (uint8_t *) &amp;devInfoStorage;\n\n/* The size of the device info */\nconst uint8_t LXdeviceInfoLen = sizeof(devInfoStorage);\n\n\n\nvoid main(void)\n{\n\n    #define DEVICE_LIST_LEN    10\n\n    unsigned char DevListBuff[sizeof (DEVICELIST) -\n                              sizeof (IRDA_DEVICE_INFO) +\n                              (sizeof (IRDA_DEVICE_INFO) * DEVICE_LIST_LEN)];\n\n    int DevListLen = sizeof (DevListBuff);\n    PDEVICELIST pDevList;\n\n    pDevList = (PDEVICELIST) &amp; DevListBuff;\n         //code continues.\n\n}\n</code></pre>\n", "Tags": "<c++><c>", "OwnerUserId": "645128", "AnswerCount": "2"}});