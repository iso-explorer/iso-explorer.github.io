post_cb({"34560867": {"Id": "34560867", "PostTypeId": "2", "Body": "<p><em>code unit in UTF-8 is always exactly eight bits</em>.  <code>unsigned char</code> is specified to have at least 8 bits, so all code units in UTF-8 fit in type <code>unsigned char</code>.</p>\n<p>The rationale for the <code>u8\"This is a UTF-8 encoded string constant\"</code> is not the fact that it is stored in 8-bit bytes, but that it is encoded as UTF-8, whereas the source file might have a different encoding.  The <code>u8string</code> typedef is consistent with that but a tad confusing if bytes have more than 8 bits.</p>\n<p>Using <code>unsigned char</code> is a good way to remove the uncertainty regarding the signedness of type <code>char</code>.</p>\n", "LastActivityDate": "2016-01-01T22:54:56.583", "CommentCount": "0", "CreationDate": "2016-01-01T22:54:56.583", "ParentId": "34560711", "Score": "0", "OwnerUserId": "4593267"}, "34560759": {"Id": "34560759", "PostTypeId": "2", "Body": "<p><code>uint8_t</code> only exists on systems that have memory that's accessible as <strong>exactly</strong> 8 bits. UTF-8 doesn't have any such requirement. It uses values that fit into 8 bits, but does not impose any requirements on how those values are actually stored. Each 8-bit value could be stored as 16 bits or 32 bits or whatever makes sense for the system that it's running on; the only requirement is that the value must be correct.</p>\n", "LastActivityDate": "2016-01-01T22:41:05.817", "CommentCount": "9", "CreationDate": "2016-01-01T22:41:05.817", "ParentId": "34560711", "Score": "3", "OwnerUserId": "1593860"}, "34560871": {"Id": "34560871", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_34560711_34560871_0\">So why does he claim <code>const char*</code> is used instead of <code>const uint8_t*</code> (or the suggested, hypothetical <code>const char8_t*</code>)?</p>\n</blockquote>\n<p>Because that's what the standard says. a <code>u8</code> literal string will resolve to an array of type <code>const char[N]</code>. That's how UTF-8 literals in C++ are defined to work.</p>\n<p>If <code>char</code> on a system has more than 8 bits... so be it. Each <code>char</code> in the string will still hold a value between 0 and 255, which is the range of valid UTF-8 code units. Even though <code>char</code> could hold large values on such system.</p>\n<p>If <code>char</code> cannot hold 8 bits... then the implementation is invalid. By recent wording of the standard, <code>char</code> is required to hold enough bits to store every valid UTF-8 code unit. And technically, 255 is not a valid UTF-8 code unit.</p>\n<p>And the fact of the matter is this: there's already a <em>huge</em> amount of code that accepts UTF-8 via <code>char*</code>. They aren't going to rewrite POSIX, filesystem APIs, and whatever else to adopt a different type.</p>\n<p>That being said, manipulating a sequence of UTF-8 code units via <code>const char*</code> is... dubious. This is because they could be signed. However, the recent standard wording requires that a conversion between <code>unsigned char</code> and <code>char</code> work within the range of valid UTF-8 code units. That is, you can cast a <code>const char*</code> to a <code>const unsigned char*</code>, do your bit manipulation on that, and then cast it back, and you're guaranteed to work.</p>\n<blockquote>\n<p id=\"so_34560711_34560871_1\">And what's the point of that super-complex \"recent wording of the standard\"?</p>\n</blockquote>\n<p>The point of that is to allow UTF-8 strings to actually <em>work</em>. Because the standards committee, in their \"infinite wisdom\", decided not to include a special <code>char8_t</code> UTF-8 code unit type, they had to add wording to make <code>char</code> serve in that role. And that requires that the conversion to/from <code>unsigned char</code> and <code>char</code> to not be able to mangle a UTF-8 code unit.</p>\n<p>There was even a <a href=\"https://groups.google.com/a/isocpp.org/d/topic/std-discussion/6eYafw4jUZI/discussion\" rel=\"nofollow\">discussion topic on the C++ standard discussion forums</a>, where the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3914.html\" rel=\"nofollow\">wording was discussed (search for 1759)</a>. The C++14 wording says:</p>\n<blockquote>\n<p id=\"so_34560711_34560871_2\">For each value <code>i</code> of type <code>unsigned char</code> in the range 0 to 255 inclusive, there exists a value <code>j</code> of type <code>char</code> such that the result of an integral conversion (4.7) from <code>i</code> to <code>char</code> is <code>j</code>, and the result of an integral conversion from <code>j</code> to <code>unsigned char</code> is <code>i</code>.</p>\n</blockquote>\n<p>This means in particular that <code>char</code> could only be signed by default if the signed representation satisfies the above. A one's complement signed <code>char</code> would not be sufficient, since negative zero has a special representation (0x80), which when converted to unsigned becomes regular 0.</p>\n<p>Should they have just defined a specific <code>char8_t</code> that is required to be unsigned and has at least 8 bits? Probably. But it's done and it ain't changing.</p>\n", "LastEditorUserId": "734069", "LastActivityDate": "2016-01-02T01:55:21.243", "Score": "1", "CreationDate": "2016-01-01T22:56:16.750", "ParentId": "34560711", "CommentCount": "6", "OwnerUserId": "734069", "LastEditDate": "2016-01-02T01:55:21.243"}, "bq_ids": {"n4140": {"so_34560711_34560743_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 5356}, "so_34560711_34560871_2": {"length": 23, "quality": 0.9583333333333334, "section_id": 7210}}, "n3337": {"so_34560711_34560743_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 5153}}, "n4659": {"so_34560711_34560743_0": {"length": 26, "quality": 0.9629629629629629, "section_id": 6781}, "so_34560711_34560871_2": {"length": 23, "quality": 0.9583333333333334, "section_id": 8719}}}, "34560743": {"Id": "34560743", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_34560711_34560743_0\"><strong>[lex.string]/8</strong> Ordinary string literals and UTF-8 string literals are also referred to as narrow string literals. A narrow string literal has type \u201carray of <code>n</code> const char\u201d, where <code>n</code> is the size of the string as defined below, and has static storage duration (3.7).</p>\n</blockquote>\n<p>So, whatever else is true, a UTF-8 string literal is a sequence of <code>char</code>s.</p>\n<p>As to <code>uint8_t</code>:</p>\n<blockquote>\n<p id=\"so_34560711_34560743_1\"><strong>7.20.1.1</strong></p>\n<p id=\"so_34560711_34560743_2\">2 The typedef name <code>uintN_t</code> designates an unsigned integer type with width <code>N</code> and no padding bits. Thus, <code>uint24_t</code> denotes such an unsigned integer type with a width of exactly 24 bits.</p>\n<p id=\"so_34560711_34560743_3\">3 These types are optional. However, if an implementation provides integer types with widths of 8, 16, 32, or 64 bits, no padding bits, and (for the signed types) that have a two\u2019s complement representation, it shall define the corresponding typedef names.</p>\n</blockquote>\n<p>On a hypothetical system with a <code>char</code> larger than 8 bits, <code>uint8_t</code> would not be defined.</p>\n", "LastEditorUserId": "1670129", "LastActivityDate": "2016-01-01T22:42:06.273", "Score": "1", "CreationDate": "2016-01-01T22:38:21.373", "ParentId": "34560711", "CommentCount": "5", "OwnerUserId": "1670129", "LastEditDate": "2016-01-01T22:42:06.273"}, "34560711": {"ViewCount": "124", "Body": "<p>I just browsed around looking for some implementation of UTF-8 code points (and no, not to plagiarize) and stumbled across <a href=\"https://groups.google.com/a/isocpp.org/forum/#!topic/std-discussion/jGr2bZXWntc\" rel=\"nofollow\">this</a>:</p>\n<blockquote id=\"so_34560711_34560711_0\">\n<pre><code>typedef unsigned char char8_t;\ntypedef std::basic_string&lt;unsigned char&gt; u8string;\n</code></pre>\n</blockquote>\n<p>Is this code ignoring the fact that <code>CHAR_BIT</code> is only required to be at least <code>8</code>, but may be greater? Or does this not matter in this context and the code is fine? If so, then why is this?</p>\n<p>Also, someone (presumably SO member @NicolBolas?) wrote this:</p>\n<blockquote>\n<pre><code>const char *str = u8\"This is a UTF-8 string.\";\n</code></pre>\n<p id=\"so_34560711_34560711_1\">This is pretty much how UTF-8 will be used in C++ for string literals.</p>\n</blockquote>\n<p>I thought that a code unit in UTF-8 is always exactly eight bits!<br>\nFrom the Unicode Standard 8.0.0, Chapter 2.5:</br></p>\n<blockquote>\n<p id=\"so_34560711_34560711_2\">In the Unicode character encoding model, precisely defined encoding\n  forms specify how each integer (code point) for a Unicode character is\n  to be expressed as a sequence of one or more code units. The Unicode\n  Standard provides three distinct encoding forms for Unicode\n  characters, using <strong>8-bit</strong>, 16- bit, and 32-bit units. These are\n  named <strong>UTF-8</strong>, UTF-16, and UTF-32, respectively.</p>\n</blockquote>\n<p><sub>(Newlines removed, hyphen on line-break removed, emphasis added.)</sub></p>\n<p>So why does he claim <code>const char*</code> is used instead of <code>const uint8_t*</code> (or the suggested, hypothetical <code>const char8_t*</code>)?</p>\n", "AcceptedAnswerId": "34560871", "Title": "Is this UTF-8 implementation implementation-defined or well-defined?", "CreationDate": "2016-01-01T22:34:17.140", "Id": "34560711", "CommentCount": "5", "LastEditDate": "2016-01-01T22:45:12.540", "PostTypeId": "1", "LastEditorUserId": "3494013", "LastActivityDate": "2016-01-02T01:55:21.243", "Score": "1", "OwnerUserId": "3494013", "Tags": "<c++><string><unicode><utf-8>", "AnswerCount": "4"}});