post_cb({"6257807": {"ViewCount": "290", "Body": "<p>I was getting some odd behaviour out of a switch block today, specifically I was reading a byte from a file and comparing it against certain hex values (text file encoding issue, no big deal).  The code looked something like:</p>\n<pre><code>char BOM[3] = {0};\nb_error = ReadFile (iNCfile, BOM, 3, &amp;lpNumberOfBytesRead, NULL); \n\nswitch ( BOM[0] ) {\ncase 0xef: {\n    // Byte Order Marker Potentially Indicates UTF-8\n    if ( ( BOM[1] == 0xBB ) &amp;&amp; ( BOM[2] == 0xBF ) ) {\n        iNCfileEncoding = UTF8;\n    }\n    break;\n           }\n}\n</code></pre>\n<p>Which didn't work, although the debug looked ok.  I realized that the switch was promoting the values to integers, and once that clicked in place I was able to match using 0xffffffef in the case statement.  Of course the correct solution was to make BOM[] unsigned and now everything promotes and compares as expected.</p>\n<p>Can someone briefly explain what was going on in the char -&gt; int promotion that produced 0xffffffef instead of 0x000000ef?</p>\n", "AcceptedAnswerId": "6259317", "Title": "What's happening in the background of a unsigned char to integer type cast?", "CreationDate": "2011-06-06T20:43:01.280", "Id": "6257807", "CommentCount": "2", "LastEditDate": "2011-08-23T02:12:56.487", "PostTypeId": "1", "LastEditorUserId": "759749", "LastActivityDate": "2011-08-23T02:12:56.487", "Score": "2", "OwnerUserId": "759749", "Tags": "<c++><binary><casting><implicit-conversion>", "AnswerCount": "5"}, "6259317": {"Id": "6259317", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_6257807_6259317_0\">\"Can someone briefly explain what was\n  going on in the char -&gt; int promotion\n  that produced 0xffffffef instead of\n  0x000000ef?\"</p>\n</blockquote>\n<p>Contrary to the four answers so far, <em><strong>it didn't.</strong></em></p>\n<p>Rather, you had a negative <code>char</code> value, which as a <code>switch</code> condition was promoted to the same negative <code>int</code> value as required by</p>\n<blockquote>\n<p id=\"so_6257807_6259317_1\"><strong>C++98 \u00a76.4.2/2</strong><br>\n  Integral promotions are performed.</br></p>\n</blockquote>\n<p>Then with your 32-bit C++ compiler <code>0xffffffef</code> was interpreted as an <code>unsigned int</code> literal, because it\u2019s too large for a 32-bit <code>int</code>, by</p>\n<blockquote>\n<p id=\"so_6257807_6259317_2\"><strong>C++98 2.13.1/2</strong><br>\n  If it is octal or hexadecimal and has no suffix, it has the first of these types in\n  which it can be represented: <code>int</code>, <code>unsigned int</code>, <code>long int</code>, <code>unsigned long int</code>.</br></p>\n</blockquote>\n<p>Now, for the <code>case</code> label,</p>\n<blockquote>\n<p id=\"so_6257807_6259317_3\"><strong>C++98 \u00a76.4.2/2</strong><br>\n  The integral constant-expression (5.19) is implicitly converted to the promoted\n  type of the switch condition.</br></p>\n</blockquote>\n<p>In your case, with signed destination type, the result of the conversion is formally implementation-defined, by</p>\n<blockquote>\n<p id=\"so_6257807_6259317_4\"><strong>C++98 \u00a74.7/3</strong><br>\n  If the destination type is signed, the value is unchanged if it can be represented\n  in the destination type (and bit-field width); otherwise, the value is\n  implementation-defined.</br></p>\n</blockquote>\n<p>But in practice nearly all compilers use two's complement representation with no trapping, and so the implementation defined conversion is in your case that the bitpattern <code>0xffffffef</code> is interpreted as two's complement specification of a negative value. You can calculate which value by 0xffffffef - 2<sup>32</sup>, because we\u2019re talking 32-bit representation here. Or, since this is just an 8-bit value that\u2019s been <em>sign extended</em> to 32 bits, you can alternatively calculate it as 0xef - 2<sup>8</sup>, where 0xef is the character code point.</p>\n<p>Cheers &amp; hth.,</p>\n", "LastEditorUserId": "464581", "LastActivityDate": "2011-06-07T01:21:56.903", "Score": "1", "CreationDate": "2011-06-06T23:51:57.213", "ParentId": "6257807", "CommentCount": "0", "OwnerUserId": "464581", "LastEditDate": "2011-06-07T01:21:56.903"}, "6257843": {"Id": "6257843", "PostTypeId": "2", "Body": "<p><a href=\"http://en.wikipedia.org/wiki/Sign_extension\" rel=\"nofollow\">Sign extension</a></p>\n", "LastActivityDate": "2011-06-06T20:46:18.807", "CommentCount": "0", "CreationDate": "2011-06-06T20:46:18.807", "ParentId": "6257807", "Score": "1", "OwnerUserId": "636019"}, "6257828": {"Id": "6257828", "PostTypeId": "2", "Body": "<p>The sign of your (signed) char got extended to form a signed int. That is because of the way signed values are stored in binary.</p>\n<p>Example</p>\n<p>1 in binary char = 00000001</p>\n<p>1 in binary int = 00000000 00000000 00000000 00000001</p>\n<p>-1 in binary char = 11111111</p>\n<p>-1 in binary int is NOT 00000000 00000000 00000000 11111111 but 11111111 11111111 11111111 11111111</p>\n<p>if you convert back to decimal you should know up front whether you are dealing with signed or unsigned values because 11111111 might be -1 in signed and 255 in unsigned.</p>\n", "LastActivityDate": "2011-06-06T20:44:51.827", "CommentCount": "0", "CreationDate": "2011-06-06T20:44:51.827", "ParentId": "6257807", "Score": "3", "OwnerUserId": "251824"}, "bq_ids": {"n4140": {"so_6257807_6259317_2": {"length": 11, "quality": 0.6470588235294118, "section_id": 22}, "so_6257807_6259317_3": {"length": 7, "quality": 0.5833333333333334, "section_id": 3890}, "so_6257807_6259317_4": {"length": 13, "quality": 0.8125, "section_id": 32}}, "n3337": {"so_6257807_6259317_2": {"length": 11, "quality": 0.6470588235294118, "section_id": 19}, "so_6257807_6259317_4": {"length": 13, "quality": 0.8125, "section_id": 29}}, "n4659": {"so_6257807_6259317_2": {"length": 11, "quality": 0.6470588235294118, "section_id": 22}, "so_6257807_6259317_3": {"length": 7, "quality": 0.5833333333333334, "section_id": 4776}, "so_6257807_6259317_4": {"length": 11, "quality": 0.6875, "section_id": 32}}}, "6257844": {"Id": "6257844", "PostTypeId": "2", "Body": "<p><code>char</code> must be signed on your platform, and what you are seeing is <a href=\"http://en.wikipedia.org/wiki/Sign_extension\" rel=\"nofollow\">sign extension</a>.</p>\n", "LastActivityDate": "2011-06-06T20:46:30.570", "CommentCount": "1", "CreationDate": "2011-06-06T20:46:30.570", "ParentId": "6257807", "Score": "3", "OwnerUserId": "45914"}, "6257893": {"Id": "6257893", "PostTypeId": "2", "Body": "<p>What hasn't been stated yet (as I type, anyway) is that it is unspecified whether or not char is singed. In your case - as was stated - char is signed, so any ASCII value above 127 is going to be interpreted as a negative.</p>\n", "LastActivityDate": "2011-06-06T20:51:27.127", "CommentCount": "0", "CreationDate": "2011-06-06T20:51:27.127", "ParentId": "6257807", "Score": "2", "OwnerUserId": "785937"}});