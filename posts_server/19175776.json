post_cb({"bq_ids": {"n4140": {"so_19175776_19179387_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 3402}}, "n3337": {"so_19175776_19179387_0": {"length": 18, "quality": 0.9473684210526315, "section_id": 3271}}, "n4659": {"so_19175776_19179387_0": {"length": 15, "quality": 0.7894736842105263, "section_id": 4159}}}, "19176770": {"Id": "19176770", "PostTypeId": "2", "Body": "<p>If you really want to separate input for real and imaginary parts of a complex, you could try IO manipulators approach.</p>\n<pre><code>#include &lt;complex&gt;\n#include &lt;iosfwd&gt;\n\nclass proxy_complex {\n    explicit proxy_complex(std::istream&amp; strm, bool f)\n        : strm_(&amp;strm), flag(f) { }\n    proxy_complex(const proxy_complex&amp;) = default;\n\n    std::istream* strm_;\n    bool flag;           // flag to check whether we're writing real or imag\n\npublic:\n    template&lt;typename T&gt;\n    std::istream&amp; operator&gt;&gt;(std::complex&lt;T&gt;&amp; c)\n    {\n        T n;\n        if (*strm_ &gt;&gt; n)\n            flag ? c.real(n) : c.imag(n);\n        return *strm_;\n    }\n\n    friend proxy_complex operator&gt;&gt;(std::istream&amp; is, proxy_complex(*func)(std::istream&amp;))\n    {\n        return func(is);\n    }\n    friend proxy_complex real(std::istream&amp;);\n    friend proxy_complex imag(std::istream&amp;);\n};\n\ninline proxy_complex real(std::istream&amp; is)\n{\n    return proxy_complex(is, true);\n}\n\ninline proxy_complex imag(std::istream&amp; is)\n{\n    return proxy_complex(is, false);\n}\n</code></pre>\n<p>You can put the above code in a header file of its own (if you do that, it might be a good idea to wrap it in a namespace).</p>\n<p>Usage:</p>\n<pre><code>#include &lt;iostream&gt;\n#include \"my_header.h\"\n\nint main()\n{\n    std::complex&lt;double&gt; c;\n    std::cin &gt;&gt; real &gt;&gt; c &gt;&gt; imag &gt;&gt; c;\n    if (std::cin) std::cout &lt;&lt; c;\n}\n</code></pre>\n<p>Hope I guessed your definition of \"clean\" correctly :)</p>\n", "LastActivityDate": "2013-10-04T08:35:10.947", "CommentCount": "1", "CreationDate": "2013-10-04T08:35:10.947", "ParentId": "19175776", "Score": "5", "OwnerUserId": "947836"}, "19177470": {"Id": "19177470", "PostTypeId": "2", "Body": "<p>Sorry to be negative, but your question starts from a wrong premise. Concerning <code>std::complex</code> the 2011 standard is backward compatible. Code of the form </p>\n<pre><code>complex&lt;double&gt; C; cin &gt;&gt; C.real();\n</code></pre>\n<p>was <strong>never valid C++</strong>. The 2003 standard only gives the member function</p>\n<pre><code>T std::complext&lt;T&gt;::real() const;\n</code></pre>\n<p>but not</p>\n<pre><code>const T&amp; std::complext&lt;T&gt;::real() const;  // non-standard\nT&amp; std::complext&lt;T&gt;::real();              // non-standard\n</code></pre>\n<p>even though some implementations (such as that shipped with gcc 4.3) may have implemented these two instead.</p>\n<p>Now, <strong>to answer your question</strong>. Clearly, the cleanest way is to follow the intention of the standard. The 2011 standard adds the following setters</p>\n<pre><code>void std::complex&lt;T&gt;::real(T);\nvoid std::complex&lt;T&gt;::imag(T);\n</code></pre>\n<p>so you can now simply use those to set the real or imaginary parts separately.</p>\n<p>However, those cannot be used in a function taking <code>T&amp;</code>, such as <code>operator&gt;&gt;</code>. For that you must do some nasty tricks, which I cannot really recommend:</p>\n<pre><code>template&lt;typename T&gt;\nT&amp; get_real(std::complex&lt;T&gt;&amp;z)   // dirty cast to gain non-const access to member.\n{\n  struct Z { T x,y; };           // assumes that std::complex&lt;&gt; has same layout\n  static_assert(sizeof(Z)==sizeof(std::complex&lt;T&gt;),\"!!\");\n  static_assert(alignof(Z)==alignof(std::complex&lt;T&gt;),\"!!\");\n  return static_cast&lt;Z&amp;&gt;(z).x;\n}\n\nstd::complex&lt;double&gt; z;\ncin &gt;&gt; get_real(z);\n</code></pre>\n<p>However, this is <strong>beyond the standard and not guaranteed to work</strong> because the standard makes no specification about the layout of <code>std::complex&lt;&gt;</code>: it could store its data members in the reverse order or in any other way.</p>\n", "LastEditorUserId": "1023390", "LastActivityDate": "2013-10-04T09:54:40.533", "Score": "4", "CreationDate": "2013-10-04T09:14:31.263", "ParentId": "19175776", "CommentCount": "6", "OwnerUserId": "1023390", "LastEditDate": "2013-10-04T09:54:40.533"}, "19176099": {"Id": "19176099", "PostTypeId": "2", "Body": "<p>Not that I know of. </p>\n<p>You could construct a helper if that's important to you:</p>\n<pre><code>class ModifyReal\n{\n   double d;\n   complex&lt;double&gt; &amp; c;\npublic:\n   ModifyReal(complex&lt;double&gt; &amp; c_) : c(c_), d(numeric_limits&lt;double&gt;::quiet_NaN()) \n   {}\n   operator double &amp;() { return d; }\n   ~ModifyReal() { c.real(d); }\n};\n\n\ncin &gt;&gt; ModifyReal(C);\n</code></pre>\n<p>I would not exactly <em>recommend</em> to use this, however, unless you have a very compelling reason to. (\"I do not like it\" is not convincing enough.) </p>\n<p>I do think having many different classes like this in your code can hamper readability, but if you use it in a few dedicated instances you should be fine. Error handling can become subtley difficult (e.g. since cin doesn't throw on invalid input, C gets assigned nan,  rather than being unmodified.)</p>\n<hr>\n<p>What does \"clean\" mean? No, don't tell me - think about it.</p>\n</hr>", "LastEditorUserId": "31317", "LastActivityDate": "2013-10-07T13:55:29.013", "Score": "1", "CreationDate": "2013-10-04T07:54:17.080", "ParentId": "19175776", "CommentCount": "2", "OwnerUserId": "31317", "LastEditDate": "2013-10-07T13:55:29.013"}, "19178454": {"Id": "19178454", "PostTypeId": "2", "Body": "<p>Inspired by Steve Jessop, it's just <code>C += (C + C.conj())/2 + 1;</code>. </p>\n<p>Remember that in complex math, you cannot really treat the real and imaginary parts as fully independent components. That's just about as sane than treating their phase and magnitude as fully independent components. Addition of complex numbers is done independently on real and imaginary parts, but multiplication is done independently on the phase and magnitude parts. </p>\n<p>Your example is not complex multiplication, so it makes sense that <code>std::complex</code> doesn't support that kind of multiplication.</p>\n", "LastActivityDate": "2013-10-04T10:00:31.377", "CommentCount": "1", "CreationDate": "2013-10-04T10:00:31.377", "ParentId": "19175776", "Score": "-2", "OwnerUserId": "15416"}, "19176414": {"Id": "19176414", "PostTypeId": "2", "Body": "<p>If you want to manipulate real parts you can just use double or floats directly.\nIf you want to manipulate imaginary parts you can have a unique complex number <code>std::complex&lt;double&gt; I(0,1)</code> and multiply it by the value you want.</p>\n<p>For instance, instead of writing: <code>C.real(2*C.real() + 1);</code> you can write: <code>C += C.real() + 1;</code></p>\n<p>Then you can mix doubles with complexs in your mathematical expressions and the compiler will use the correct conversions. See an example:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;complex&gt;\n\nint main(int argc, char* argv[])\n{\n    // Let the user enter a Real number\n    double c;\n    std::cin &gt;&gt; c;\n\n    // Explicitly convert to a complex\n    std::complex&lt;double&gt; C = 2*c + 1;\n    std::cout &lt;&lt; C &lt;&lt; std::endl;\n\n    // Creates a pure imaginary complex number I\n    std::complex&lt;double&gt; I(0,1);\n\n    // Mix together complex and real numbers in the\n    // same expression\n    C = C + c*I;\n    std::cout &lt;&lt; C &lt;&lt; std::endl;\n\n\n    // Setup a specific value and compare how to achieve\n    // C.real = 2*C.real + 1\n    C = 1. + 2.*I;\n    C.real(2*C.real()+1);\n    std::complex&lt;double&gt; D = 1. + 2.*I;\n    D += D.real() + 1;\n    std::cout &lt;&lt; \"C=\" &lt;&lt; C &lt;&lt; \"\\tD=\" &lt;&lt; D &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>The output:</p>\n<pre><code>$ ./main.exe\n1\n(3,0)\n(3,1)\nC=(3,2) D=(3,2)\n\n$ ./main.exe\n2\n(5,0)\n(5,2)\nC=(3,2) D=(3,2)\n</code></pre>\n<p>If you are afraid of the lost of efficiency of this method compared to affecting directly through a reference you can look at the generated assembly code. On my computer with <code>g++</code> and <code>-O3</code> everything is inlined.</p>\n", "LastEditorUserId": "657700", "LastActivityDate": "2013-10-04T08:20:33.910", "Score": "2", "CreationDate": "2013-10-04T08:14:43.303", "ParentId": "19175776", "CommentCount": "0", "OwnerUserId": "657700", "LastEditDate": "2013-10-04T08:20:33.910"}, "19179387": {"Id": "19179387", "PostTypeId": "2", "Body": "<p>C++11 now allows </p>\n<pre><code>double&amp; re(std::complex&lt;double&gt;&amp; c)\n{\n    return reinterpret_cast&lt;double (&amp;)[2]&gt;(c)[0];\n}\n\ndouble&amp; im(std::complex&lt;double&gt;&amp; c)\n{\n    return reinterpret_cast&lt;double (&amp;)[2]&gt;(c)[1];\n}\n\nconst double&amp; re(const std::complex&lt;double&gt;&amp; c)\n{\n    return reinterpret_cast&lt;const double (&amp;)[2]&gt;(c)[0];\n}\n\nconst double&amp; im(const std::complex&lt;double&gt;&amp; c)\n{\n    return reinterpret_cast&lt;const double (&amp;)[2]&gt;(c)[1];\n}\n</code></pre>\n<p>Usage:</p>\n<pre><code>std::complex&lt;double&gt; a;\nstd::cin &gt;&gt; re(a);\n</code></pre>\n<p>Relevant quote \u00a726.4: </p>\n<blockquote>\n<p id=\"so_19175776_19179387_0\">Moreover, if a is an expression of type <code>cv std::complex&lt;T&gt;*</code> and the expression <code>a[i]</code> is well-defined for an integer expression <code>i</code> , then:\n   \u2014 <code>reinterpret_cast&lt;cv T*&gt;(a)[2*i]</code> shall designate the real part of <code>a[i]</code>, and \n  \u2014 <code>reinterpret_cast&lt;cv T*&gt;(a)[2*i+1]</code> shall designate the imaginary part of <code>a[i]</code> .</p>\n</blockquote>\n", "LastEditorUserId": "1012936", "LastActivityDate": "2014-09-22T22:24:12.907", "Score": "3", "CreationDate": "2013-10-04T10:49:13.923", "ParentId": "19175776", "CommentCount": "0", "OwnerUserId": "1012936", "LastEditDate": "2014-09-22T22:24:12.907"}, "19175776": {"ViewCount": "2778", "Body": "<p>I'm looking for a function that returns a reference to real or imag values of  a complex number in C++11. In C++03 I could say:</p>\n<p><code>complex&lt;double&gt; C; cin &gt;&gt; C.real();</code></p>\n<p>But in C++11 that gives me a compile error since the C.real() returns a value not a reference. </p>\n<p>I found out that I can write this:</p>\n<p><code>double t;   cin &gt;&gt; t;   C.real(t);</code></p>\n<p>but it isn't straightforward and for example if I want to multiply the real part of c by 2 and ad it by 1 I should say:</p>\n<p><code>C.real(2*C.real() + 1);</code></p>\n<p>That is not clean.</p>\n<p>Is there any other [clean] way to do that?</p>\n", "AcceptedAnswerId": "19177470", "Title": "a function returning reference to real or imag values of a complex number in C++11", "CreationDate": "2013-10-04T07:35:43.927", "Id": "19175776", "CommentCount": "12", "PostTypeId": "1", "LastActivityDate": "2014-09-22T22:24:12.907", "Score": "3", "OwnerUserId": "1128609", "Tags": "<c++><gcc><c++11><complex-numbers>", "AnswerCount": "6"}});