post_cb({"4242013": {"ParentId": "4241946", "CommentCount": "0", "Body": "<p>'overridding' and 'inheritance' are terms that make sense only with objects. Class variables do not participate in object inheritance.</p>\n", "OwnerUserId": "331225", "PostTypeId": "2", "Id": "4242013", "Score": "0", "CreationDate": "2010-11-22T03:27:17.043", "LastActivityDate": "2010-11-22T03:27:17.043"}, "12697762": {"ParentId": "4241946", "CommentCount": "0", "Body": "<p><br/>\nI think the reason is really because the following is true: <br/> <br/>\n<code>&amp;base::componentName == &amp;derived::componentName</code><br/><br/>\nthey refer to the same object, and initializing an object twice in a <br/>\n\"who laughs last, laughs the best\" manner cannot be a good thing.</p>\n<p>Cheers.</p>\n<p>Vintz</p>\n", "OwnerUserId": "1715398", "PostTypeId": "2", "Id": "12697762", "Score": "2", "CreationDate": "2012-10-02T20:27:51.597", "LastActivityDate": "2012-10-02T20:27:51.597"}, "4242028": {"ParentId": "4241946", "CommentCount": "3", "Body": "<p>A static member variable means there is a single variable that's shared across <em>all</em> instances of that class. Trying to have one value for the base class and a different value for the derived class doesn't work because they're both sharing the same variable, which (obviously enough) can't simultaneously be set to two different values.</p>\n", "OwnerUserId": "179910", "PostTypeId": "2", "Id": "4242028", "Score": "2", "CreationDate": "2010-11-22T03:31:04.850", "LastActivityDate": "2010-11-22T03:31:04.850"}, "4242093": {"ParentId": "4241946", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_4241946_4242093_0\">$9.4.2/2 - \"In the definition at\n  namespace scope, the name of the\n  static data member shall be qualified\n  by <strong>its</strong> class name using the ::\n  operator.\"</p>\n</blockquote>\n<p>And...</p>\n<blockquote>\n<p id=\"so_4241946_4242093_1\">It seems that static initializations\n  cannot be overriden on the derived\n  classes?</p>\n</blockquote>\n<p>Please remember that overriding is only for virtual functions.</p>\n<blockquote>\n<p id=\"so_4241946_4242093_2\">$10.3/2 - 'If a virtual member\n  function vf is declared in a class\n  Base and in a class Derived, derived\n  directly or indirectly from Base, a\n  member function vf with the same name\n  and same parameter list as Base::vf is\n  declared, then Derived::vf is also\n  virtual (whether or not it is so\n  declared) and it overrides97)\n  Base::vf.</p>\n</blockquote>\n<p>You may try to retrun the component name like so while gaining advantage of working with polymorphic code.</p>\n<pre><code>struct base{\n   virtual char const* myname(){\n      return \"base\";\n   }\n   virtual ~base(){}\n};\n\nstruct derived : base{\n   virtual char const* myname(){\n      return \"derived\";\n   }\n};\n\nint main(){}\n</code></pre>\n", "OwnerUserId": "418110", "PostTypeId": "2", "Id": "4242093", "Score": "0", "CreationDate": "2010-11-22T03:45:11.473", "LastActivityDate": "2010-11-22T03:45:11.473"}, "23798902": {"ParentId": "4241946", "CommentCount": "0", "Body": "<p>if you try to initialize the static variable in the derived class before declaring in your derived class you will get redefinition error because derived class is-like base class and static variables are only defined once for class so second initialization causes redefinition error.</p>\n<p>One of the correct way to do what you are intending is below;</p>\n<pre><code>struct a {\n    virtual const string&amp; getClassType() const {\n        return ClassName;\n    }\n    static string ClassName;\n};\nstring a::ClassName = \"StructA\";\n\nstruct c : public a {\n    const string&amp; getClassType() const {\n        return ClassName;\n    }\n    static string ClassName;\n};\nstring c::ClassName = \"StructC\";\n\na* a1 = new c();\ncout &lt;&lt; a1-&gt;getClassType() &lt;&lt; endl;\n</code></pre>\n<p><strong>NOTE</strong> \nIn the above code, getClassType is virtual function and returns class type in string format.\nThis function uses static variable and must be overridden in the derived class too. If you forget to override it, compiler will call base class version of the function and it will use the base class static variable instead of derived class static variable. So, it will returns\nthe object type of base class.</p>\n", "OwnerUserId": "1516116", "PostTypeId": "2", "Id": "23798902", "Score": "0", "CreationDate": "2014-05-22T06:02:02.230", "LastActivityDate": "2014-05-22T06:02:02.230"}, "4241960": {"ParentId": "4241946", "CommentCount": "4", "Body": "<p>You need to declare it in your subclass too.</p>\n<pre><code>struct derived : public base {\n    static const char* componentName;\n};\n</code></pre>\n", "OwnerUserId": "345717", "PostTypeId": "2", "Id": "4241960", "Score": "6", "CreationDate": "2010-11-22T03:13:26.690", "LastActivityDate": "2010-11-22T03:13:26.690"}, "bq_ids": {"n4140": {"so_4241946_4242093_2": {"section_id": 7003, "quality": 0.8666666666666667, "length": 26}, "so_4241946_4242093_0": {"section_id": 5907, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_4241946_4242093_2": {"section_id": 6749, "quality": 0.8666666666666667, "length": 26}, "so_4241946_4242093_0": {"section_id": 5679, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_4241946_4242093_2": {"section_id": 8500, "quality": 0.8666666666666667, "length": 26}, "so_4241946_4242093_0": {"section_id": 7389, "quality": 0.9285714285714286, "length": 13}}}, "4241946": {"CommentCount": "0", "ViewCount": "3983", "CreationDate": "2010-11-22T03:09:56.170", "LastActivityDate": "2014-05-22T06:02:02.230", "Title": "cannot override static initialization in derived class", "AcceptedAnswerId": "4241960", "PostTypeId": "1", "Id": "4241946", "Score": "3", "Body": "<p>i'm trying to provide different static initializations for classes in a hierarchy, but when i tried with this code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nstruct base {\nstatic const char* componentName;\n};\nconst char* base::componentName = \"base\";\n\nstruct derived : public base {};\n\nconst char* derived::componentName = \"derived\";\n\nint main() {\n\ncout &lt;&lt; base::componentName &lt;&lt; endl;\ncout &lt;&lt; derived::componentName &lt;&lt; endl;\n}\n</code></pre>\n<p>I ended up with this build error:</p>\n<pre><code>test.cpp:15: error: ISO C++ does not permit \u2018base::componentName\u2019 to be defined as \u2018derived::componentName\u2019\ntest.cpp:15: error: redefinition of \u2018const char* base::componentName\u2019\ntest.cpp:11: error: \u2018const char* base::componentName\u2019 previously defined here\n</code></pre>\n<p>It seems that static initializations cannot be overriden on the derived classes? If this does not work i might always define the componentName to be a static function that returns a const char*, the only problem with that i was sort of hoping to do initializations for partial specializations, and there does not seem to be any way that i know of to redefine just a single function in a partial specialization, without copying all the other code that will remain mostly the same</p>\n", "Tags": "<c++><inheritance><static-initialization>", "OwnerUserId": "170521", "AnswerCount": "6"}});