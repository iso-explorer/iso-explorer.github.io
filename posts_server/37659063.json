post_cb({"37659207": {"ParentId": "37659063", "CommentCount": "2", "Body": "<p>Destructors of local objects are called after 'the last line of your code'. Here is a relevant quote from Standard (3.7.3 / 3):</p>\n<blockquote>\n<p id=\"so_37659063_37659207_0\">If a variable with automatic storage duration has initialization or a\n  destructor with side effects, it <strong>shall not be destroyed before the end\n  of its block</strong>, nor shall it be eliminated as an optimization even if it\n  appears to be unused, except that a class object or its copy/move may\n  be eliminated as specified in 12.8</p>\n</blockquote>\n", "OwnerUserId": "5245033", "PostTypeId": "2", "Id": "37659207", "Score": "-1", "CreationDate": "2016-06-06T13:48:46.300", "LastActivityDate": "2016-06-06T13:48:46.300"}, "37659312": {"ParentId": "37659063", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The copy-initialization of the returned value will be processed before.</p>\n<p>From the standard, <code>$6.6.3/3 The return statement [stmt.return]</code> (emphasis mine)</p>\n<blockquote>\n<p id=\"so_37659063_37659312_0\">The copy-initialization of the returned entity is sequenced before the\n  destruction of temporaries at the end of the full-expression\n  established by the operand of the return statement, which, in turn, is\n  <strong>sequenced before the destruction of local variables (6.6) of the block\n  enclosing the return statement</strong>.</p>\n</blockquote>\n", "OwnerUserId": "3309790", "LastEditorUserId": "3309790", "LastEditDate": "2016-06-06T14:08:03.250", "Id": "37659312", "Score": "10", "CreationDate": "2016-06-06T13:53:20.227", "LastActivityDate": "2016-06-06T14:08:03.250"}, "bq_ids": {"n4140": {"so_37659063_37659207_0": {"section_id": 7172, "quality": 0.9642857142857143, "length": 27}}, "n3337": {"so_37659063_37659207_0": {"section_id": 6916, "quality": 0.9642857142857143, "length": 27}}, "n4659": {"so_37659063_37659207_0": {"section_id": 8680, "quality": 0.8928571428571429, "length": 25}, "so_37659063_37659312_0": {"section_id": 4800, "quality": 0.875, "length": 21}}}, "37659063": {"CommentCount": "3", "ViewCount": "145", "PostTypeId": "1", "LastEditorUserId": "443878", "CreationDate": "2016-06-06T13:42:06.207", "LastActivityDate": "2016-06-06T14:08:08.953", "Title": "When is the copy constructor for the return value happens", "AcceptedAnswerId": "37659312", "LastEditDate": "2016-06-06T14:08:08.953", "Id": "37659063", "Score": "8", "Body": "<p>I have the following member function:</p>\n<pre><code>Person ClassB::DoSomethingAndReturnPerson()\n{\n RAIIMutex myLock(&amp;m_mutex);\n return m_person;\n}\n</code></pre>\n<p><code>RAIIMutex</code> is an helper class that recieves a mutex and locks it in the constructor and releases in the destructor.</p>\n<p><code>m_person</code> is of type <code>Person</code> (something very small in size). Other functions in other threads might change this member. </p>\n<p>I want to return <code>m_person</code> by value (return a copy) and of course I want to avoid the situation where the <code>m_person</code> being changed in another thread while it's being copied in the return so I've added the lock.</p>\n<p>But what happens first ? Does the compiler first creates a copy of <code>m_person</code> or first calls the destructor of <code>myLock</code> ? </p>\n<p>Theoretically it easly solvable by doing something like this : </p>\n<pre><code>Person ClassB::DoSomethingAndReturnPerson()\n{\n RAIIMutex myLock(&amp;m_mutex);\n Person tmp = m_person;\n return tmp;\n}\n</code></pre>\n<p>But I'm interested in knowing the answer to my question.</p>\n<p>Thanks</p>\n", "Tags": "<c++><return><language-lawyer>", "OwnerUserId": "443878", "AnswerCount": "2"}});