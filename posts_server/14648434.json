post_cb({"14649258": {"ParentId": "14648434", "LastEditDate": "2017-05-23T12:10:47.957", "CommentCount": "0", "CreationDate": "2013-02-01T15:12:18.917", "OwnerUserId": "1838266", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "14649258", "Score": "1", "Body": "<p>That's complicated. I guess, GCC and CLANG are using SFINAE to disambiguate the two function templates, that at first glance are ambiguos. Lets look at an example: The call <code>c.b(2445)</code> I'm gonna mess up a bit the types and actual arguments, but I hope it's understandable what I mean.</p>\n<ol>\n<li><p>Instantiating the first function template, meaning </p>\n<p><code>auto b&lt;int&gt;(int args)-&gt;decltype(_b_caller__(_first__, std::forward &lt;int&gt; (args)))</code>, which in turn instantiates <code>_b_caller&lt;A,int&gt;</code>, which calls <code>_first__-&gt;b(int)</code>. Since A has no method b, both instantiations fail. This leads to</p></li>\n<li><p>Instantiating the second function template, meaning</p>\n<p><code>auto b&lt;int&gt;(int args)-&gt;decltype(_b_caller__(_second__, std::forward &lt;int&gt; (args)))</code> and <code>_b_caller&lt;B,int&gt;</code> which works, since B has a method b(double).</p></li>\n</ol>\n<p>It seems that somewehere in that process Visual Studio bails out. My guess is, that SFINAE does not work correctly with trailing return types, but it might as well be the two level deep instantiation that makes it difficult to apply SFINAE correctly in that case.</p>\n<p><strong>Edit:</strong> this might be related:\n<a href=\"https://stackoverflow.com/questions/1606738/why-does-sfinae-not-apply-to-this\">Why does SFINAE not apply to this?</a></p>\n", "LastActivityDate": "2013-02-01T15:12:18.917"}, "14648434": {"CommentCount": "12", "AcceptedAnswerId": "14649812", "PostTypeId": "1", "LastEditorUserId": "1056328", "CreationDate": "2013-02-01T14:25:16.900", "LastActivityDate": "2013-02-04T20:47:44.227", "LastEditDate": "2013-02-01T14:37:20.637", "ViewCount": "559", "FavoriteCount": "0", "Title": "VS2012 SP1 (+november pack) unknown-type errors (alike C::a(T &&...) )", "Id": "14648434", "Score": "1", "Body": "<p>So <a href=\"http://rise4fun.com/Vcpp/hBV\" rel=\"nofollow\">ms compiler online could not compile this</a> (as wall as my home VS2012 with SP1 (+november pack)) while <a href=\"http://liveworkspace.org/code/KKkbu%241\" rel=\"nofollow\">clang and modern gcc could</a>. Can aany one please tall me what C++11 feature is missing in VS and is there ways around?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;utility&gt;\n#include &lt;type_traits&gt;\n\nstruct A {\n    int x;\n\n    void a() {\n        std::cout &lt;&lt; \"an a! \" &lt;&lt; x &lt;&lt; \"\\n\";\n    }\n};\n\nstruct B {\n    double x;\n\n    double b(double k) {\n        std::cout &lt;&lt; \"b! \" &lt;&lt; x &lt;&lt; \", \" &lt;&lt; k &lt;&lt; \"\\n\";\n        return x - k;\n    }\n\n    void b() {\n        std::cout &lt;&lt; \"b! \" &lt;&lt; x &lt;&lt; \", ?\\n\";\n    }\n};\n\nstruct C {\n    A *_first__;\n    B *_second__;\n     C(A * _first__, B * _second__):_first__(_first__), _second__(_second__) {\n    } template &lt; typename K, typename ... T &gt; static auto _a_caller__(K * k, T &amp;&amp; ... args)-&gt;decltype(k-&gt;a(std::forward &lt; T &gt; (args) ...)) {\n    return k-&gt;a(std::forward &lt; T &gt; (args)...);\n    }\n    template &lt; typename...T &gt; auto a(T &amp;&amp;...args)-&gt;decltype(_a_caller__(_first__, std::forward &lt; T &gt; (args)...)) {\n        return _a_caller__(_first__, std::forward &lt; T &gt; (args)...);\n    }\n    template &lt; typename...T &gt; auto a(T &amp;&amp;...args)-&gt;decltype(_a_caller__(_second__, std::forward &lt; T &gt; (args)...)) {\n        return _a_caller__(_second__, std::forward &lt; T &gt; (args)...);\n    }\n    template &lt; typename K, typename...T &gt; static auto _b_caller__(K * k, T &amp;&amp; ... args)-&gt;decltype(k-&gt;b(std::forward &lt; T &gt; (args) ...)) {\n        return k-&gt;b(std::forward &lt; T &gt; (args)...);\n    }\n    template &lt; typename...T &gt; auto b(T &amp;&amp;...args)-&gt;decltype(_b_caller__(_first__, std::forward &lt; T &gt; (args)...)) {\n        return _b_caller__(_first__, std::forward &lt; T &gt; (args)...);\n    }\n    template &lt; typename...T &gt; auto b(T &amp;&amp;...args)-&gt;decltype(_b_caller__(_second__, std::forward &lt; T &gt; (args)...)) {\n        return _b_caller__(_second__, std::forward &lt; T &gt; (args)...);\n    }\n};\n\nint main() {\n    A a {12};\n    B b {24};\n\n    C c (&amp;a, &amp;b);\n\n    c.a();\n    c.b();\n    std::cout &lt;&lt; c.b(2445) &lt;&lt; std::endl;\n}\n</code></pre>\n<p>Errors:</p>\n<pre><code>testvc.cpp\n--\\testvc.cpp(38) : error C2535: 'unknown-type C::a(T &amp;&amp;...)' : member function already defined or declared\n        --\\testvc.cpp(33) : see declaration of 'C::a'\n--\\testvc.cpp(47) : error C2535: 'unknown-type C::b(T &amp;&amp;...)' : member function already defined or declared\n        --\\testvc.cpp(42) : see declaration of 'C::b'\n--\\testvc.cpp(56) : error C2893: Failed to specialize function template 'unknown-type C::a(T &amp;&amp;...)'\n        With the following template arguments:\n        ''\n--\\testvc.cpp(57) : error C2893: Failed to specialize function template 'unknown-type C::b(T &amp;&amp;...)'\n        With the following template arguments:\n        ''\n--\\testvc.cpp(58) : error C2893: Failed to specialize function template 'unknown-type C::b(T &amp;&amp;...)'\n        With the following template arguments:\n        'int'\n</code></pre>\n", "Tags": "<c++><visual-studio><c++11><visual-studio-2012>", "OwnerUserId": "1056328", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_14648434_14649812_2": {"section_id": 300, "quality": 0.9375, "length": 30}, "so_14648434_14649812_1": {"section_id": 300, "quality": 0.9705882352941176, "length": 33}, "so_14648434_14649812_0": {"section_id": 299, "quality": 0.9473684210526315, "length": 36}, "so_14648434_14649812_3": {"section_id": 175, "quality": 0.9333333333333333, "length": 14}}, "n3337": {"so_14648434_14649812_2": {"section_id": 291, "quality": 0.9375, "length": 30}, "so_14648434_14649812_1": {"section_id": 291, "quality": 0.9705882352941176, "length": 33}, "so_14648434_14649812_0": {"section_id": 290, "quality": 0.9473684210526315, "length": 36}, "so_14648434_14649812_3": {"section_id": 169, "quality": 1.0, "length": 15}}, "n4659": {"so_14648434_14649812_2": {"section_id": 307, "quality": 0.84375, "length": 27}, "so_14648434_14649812_1": {"section_id": 307, "quality": 0.9705882352941176, "length": 33}, "so_14648434_14649812_0": {"section_id": 306, "quality": 0.9473684210526315, "length": 36}, "so_14648434_14649812_3": {"section_id": 180, "quality": 0.8666666666666667, "length": 13}}}, "14649812": {"ParentId": "14648434", "LastEditDate": "2017-05-23T10:24:48.817", "CommentCount": "6", "CreationDate": "2013-02-01T15:39:54.430", "OwnerUserId": "1932150", "LastEditorUserId": "-1", "PostTypeId": "2", "Id": "14649812", "Score": "3", "Body": "<p>[This answer has been updated. See the <strong>EDIT</strong> at the end of the text]</p>\n<p>I brought this down to an <a href=\"http://sscce.org\" rel=\"nofollow noreferrer\">SSCCE</a>:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A { A g(int) { return A(); } };\nstruct B { B g() { return B(); } };\n\nstruct C\n{\n    template&lt;typename... Ts&gt;\n    auto f(Ts... ts) -&gt; decltype(A().g(ts...)) \n    { std::cout &lt;&lt; \"f -&gt; A\" &lt;&lt; std::endl; return A(); }\n\n    template&lt;typename... Ts&gt;\n    auto f(Ts... ts) -&gt; decltype(B().g(ts...)) \n    { std::cout &lt;&lt; \"f -&gt; B\" &lt;&lt; std::endl; return B(); }\n};\n\nint main()\n{\n    C c;\n    c.f(1);\n}\n</code></pre>\n<p>GCC 4.7.2 and Clang 3.2 compile this, while VC11 does not. Indeed it seems VC11 does not apply SFINAE when substitution fails inside the <code>decltype</code> expression, and this is most likely a <strong>bug</strong>.</p>\n<p>In fact, the C++11 Standard specifies (14.8.2/7):</p>\n<blockquote>\n<p id=\"so_14648434_14649812_0\">The substitution occurs in all types and expressions that are used in the function type and in template parameter declarations. The expressions include not only constant expressions such as those that appear in array bounds or as nontype template arguments <strong>but also general expressions (i.e., non-constant expressions) inside <code>sizeof</code>, <code>decltype</code></strong>, and other contexts that allow non-constant expressions. [...]</p>\n</blockquote>\n<p>Also relevant to SFINAE is 14.8.2/8, which adds:</p>\n<blockquote>\n<p id=\"so_14648434_14649812_1\">If a substitution results in an invalid type or expression, type deduction fails. An invalid type or expression is one that would be ill-formed if written using the substituted arguments. [...] Only invalid types and expressions <strong>in the immediate context</strong> of the function type and its template parameter types can result in a deduction failure. </p>\n</blockquote>\n<p>So is this a case of substitution failure \"in an immediate context\"? The same paragraph clarifies what is meant by \"immediate context\":</p>\n<blockquote>\n<p id=\"so_14648434_14649812_2\"><em>Note:</em> The evaluation of the substituted types and expressions can result in side effects such as the <strong>instantiation of class template specializations and/or function template specializations</strong>, the generation of implicitly-defined functions, etc. Such side effects are <strong>not</strong> in the \u201cimmediate context\u201d and can result in the program being ill-formed.</p>\n</blockquote>\n<p>In the case of my simplified example, the substitution failure definitely occurs in an immediate context, as it involves no template instantiation or specialization whatsovever. Thus, VC11 definitely contains a <strong>bug</strong>.</p>\n<p>However, it is less obvious whether in <em>your</em> example the substitution happens in an \"immediate context\", because inside the <code>decltype</code> expression a function template (<code>_b_caller__</code>) instantiation is <em>attempted</em>.</p>\n<p>The key observation here is that the instantiation is attempted but <em>never performed</em>, because <strong>type deduction</strong> fails (again, due to substitution failure for the expression in the <code>decltype</code> clause of the template function whose instantiation is attempted). Thus, the error does not occur in the nested context of a template instantiation.</p>\n<p>Hence, this qualifies as a <strong>VC11 bug</strong>.</p>\n<p>P.S.: See <a href=\"https://stackoverflow.com/questions/1606738/why-does-sfinae-not-apply-to-this\">this Q&amp;A on SO</a> for a situation where SFINAE does not apply because substitution failure occurs in a nested context.</p>\n<p><strong>EDIT:</strong></p>\n<p>It turns out my answer was <strong>incorrect</strong>, but I decided to keep its original text because I believe the reasoning is non-trivial and might be helpful to some. However, I overlooked one important aspect.</p>\n<p>As <a href=\"https://stackoverflow.com/users/34509/johannes-schaub-litb\">Johannes Schaub</a> correctly pointed out in a comment below, the second definition of <code>f()</code> above is ill-formed and no diagnostic is required. This is dictated by Paragraph 14.6/8 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_14648434_14649812_3\">[...] If every valid specialization of a variadic template requires an empty template parameter pack, the template definition is ill-formed, <strong>no diagnostic required</strong>. [...]</p>\n</blockquote>\n<p>Thus, although the program is ill-formed, compilers are not required (even though they are allowed) to issue an error. This means that failure to compile this program is <strong>NOT a bug</strong> of VC11, but rather a good feature, in that the compiler detects an error it is not required to detect (although it must be said that the error message is quite misleading).</p>\n", "LastActivityDate": "2013-02-02T17:00:48.303"}});