post_cb({"4881349": {"Id": "4881349", "PostTypeId": "2", "Body": "<p>To quote the C++ spec, \u00a714.17.3.18:</p>\n<blockquote>\n<p id=\"so_4881281_4881349_0\">In an explicit specialization declaration for a member of a class template or a member template that appears in namespace scope, the member template and some of its enclosing class templates may remain unspecialzed, <strong>except that the declaration shall not explicitly specialize a class member template if its enclosing class templates are not explicitly specialized as well</strong>. [...]</p>\n</blockquote>\n<p>(my emphasis)</p>\n<p>This suggests that you can't specialize a template class nested inside another template class unless the outer template class is specialized as well.  So it looks like VS2010 has this behavior wrong and g++ has it right.</p>\n", "LastActivityDate": "2011-02-02T23:54:53.673", "CommentCount": "3", "CreationDate": "2011-02-02T23:54:53.673", "ParentId": "4881281", "Score": "2", "OwnerUserId": "501557"}, "bq_ids": {"n4140": {"so_4881281_4881349_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 278}}, "n3337": {"so_4881281_4881349_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 269}}, "n4659": {"so_4881281_4881349_0": {"length": 34, "quality": 0.9714285714285714, "section_id": 285}}}, "4881368": {"Id": "4881368", "PostTypeId": "2", "Body": "<p>It just doesn't work that way.:-(</p>\n<p>You cannot specialize a function inside the class declaration, even though msvc accepts this with its default settings.</p>\n<p>You also cannot specialize a member function without also specializing the enclosing class. Most compilers avred on this (as does the language standard).</p>\n", "LastActivityDate": "2011-02-02T23:57:04.043", "CommentCount": "0", "CreationDate": "2011-02-02T23:57:04.043", "ParentId": "4881281", "Score": "1", "OwnerUserId": "597607"}, "4881281": {"ViewCount": "283", "Body": "<pre><code>template &lt;typename T&gt;\nstruct A\n   {\n   template &lt;typename U&gt;\n   struct B;\n\n   template &lt;&gt;\n   struct B&lt;int&gt; {static const int tag = 1;};  // Works fine in VS2010\n   };\n</code></pre>\n<p>How can I specialize B the same way, but outside of A.  I tried this with no success : </p>\n<pre><code>template &lt;typename T&gt; template &lt;&gt;\nstruct A&lt;T&gt;::B&lt;int&gt; {static const int tag = 1;};\n</code></pre>\n<p>I get: </p>\n<p><code>error C3212: 'A&lt;T&gt;::B&lt;int&gt;' : an explicit specialization of a template member must be a member of an explicit specialization</code></p>\n<p>It does not make sense since I can do exactly that by defining it inside the class</p>\n<p>VS2010 problem?  Wrong syntax?</p>\n<p>Thanks  </p>\n<p><hr/></p>\n<p>PS: This one (which should be wrong anyway, crashes VS2010):</p>\n<pre><code>template &lt;&gt; template &lt;typename T&gt;\nstruct A&lt;T&gt;::B&lt;int&gt; {static const int tag = 1;};\n</code></pre>\n", "AcceptedAnswerId": "4881349", "Title": "Specialization of member class nested in a non-specialized class", "CreationDate": "2011-02-02T23:44:31.173", "Id": "4881281", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2011-02-02T23:57:04.043", "Score": "0", "OwnerUserId": "574538", "Tags": "<c++><visual-studio-2010><templates><specialization>", "AnswerCount": "2"}});