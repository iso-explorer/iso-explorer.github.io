post_cb({"bq_ids": {"n4140": {"so_41487900_41488409_0": {"length": 18, "quality": 0.6666666666666666, "section_id": 7164}}, "n3337": {"so_41487900_41488409_0": {"length": 18, "quality": 0.6666666666666666, "section_id": 6908}}, "n4659": {"so_41487900_41488409_0": {"length": 18, "quality": 0.6666666666666666, "section_id": 8672}}}, "41488409": {"Id": "41488409", "PostTypeId": "2", "Body": "<p>With respect to initialization the standard lumps together everything with \"static storage duration\", which are the variables (including member variables) declared using the <code>static</code> keyword (variables with internal linkage) as well as \"true globals\" (variables with external linkage). The standard does not distinguish between plain old data types one one hand and structs or classes on the other.</p>\n<p>Note after comments (all quotes from the 2012 standard): </p>\n<blockquote>\n<p id=\"so_41487900_41488409_0\">3.7.1 Static storage duration [basic.stc.static]<br>\n     1\u00a0\u00a0\u00a0All variables which do not have dynamic storage duration, do not have thread storage duration, and are not local have <em>static storage duration.</em> The <strong>storage</strong> for these entities shall last for the duration of the program (3.6.2, 3.6.3).</br></p>\n</blockquote>\n<p>(Emphasis by me.) There is no distinction between PODs and non-PODs. Note that the paragraph defines the lifetime of the <em>storage</em>, not of the (typed, initialized) object. When the <em>program</em> (<strong>not</strong> <code>main()</code>!) starts, all static storage is readily allocated. And yes, the destructors of objects with static storage duration are part of the program. This makes it, as far as I can see, safe to access <code>errno</code> in a destructor.</p>\n<p>As you say, there is no guarantee about the order of initialization of objects with static storage duration <em>across different translation units;</em> <em>within</em> one TU the initialization is performed in the definition order, and destruction is then done in the opposite order. </p>\n<p>That is all there is to it (apart from workarounds, like putting your globals in an artificial class or returning <code>static</code>  local variables from functions).</p>\n<p>The answer to your example question then depends on the storage duration of the object for which the destructor is called. If the object has static storage duration and is in a different translation unit, you are out of luck. If it is automatically or dynamically allocated, or if it is defined in the same translation unit after the global variable you are fine.</p>\n", "LastEditorUserId": "3150802", "LastActivityDate": "2017-01-05T19:35:03.353", "Score": "2", "CreationDate": "2017-01-05T15:13:03.657", "ParentId": "41487900", "CommentCount": "5", "OwnerUserId": "3150802", "LastEditDate": "2017-01-05T19:35:03.353"}, "41487900": {"ViewCount": "67", "Body": "<p>Question coming from another question I recently asked <a href=\"https://stackoverflow.com/questions/41486703/referencing-a-possibly-destroyed-static-object\">Referencing a possibly destroyed static object</a>. Can a destructor for an instance of a class use a global primitive variable/constant?  Is it guaranteed to hold its value till program termination (i.e. after the statics have been destroyed)?  </p>\n<p>I know that static object destruction across compilation units is not defined but I was wondering whether the same holds for primitive values.</p>\n<p>For example </p>\n<h1>Something.cpp</h1>\n<pre><code>extern bool global_boolean_value;\n\nSomething::~Something() {\n    assert(global_boolean_value);\n}\n</code></pre>\n", "Title": "Lifetime of primitive globals relative to class statics", "CreationDate": "2017-01-05T14:47:30.240", "LastActivityDate": "2017-01-05T19:35:03.353", "CommentCount": "8", "LastEditDate": "2017-05-23T11:53:47.180", "PostTypeId": "1", "LastEditorUserId": "-1", "Id": "41487900", "Score": "1", "OwnerUserId": "5501675", "Tags": "<c++>", "AnswerCount": "1"}});