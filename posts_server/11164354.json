post_cb({"11164508": {"ParentId": "11164354", "CommentCount": "1", "Body": "<p>Yes it is the correct behavior.</p>\n<p>\u00a720.7.1.2.2[unique.ptr.single.dtor]/2:</p>\n<blockquote>\n<h3><code>unique_ptr</code> destructor</h3>\n<p id=\"so_11164354_11164508_0\"><em>Effects</em>: If <code>get() == nullptr</code> there are no effects. Otherwise <code>get_deleter()(get())</code>.</p>\n</blockquote>\n<p>\u00a720.7.2.2.2[util.smartptr.shared.dest]/1:</p>\n<blockquote>\n<h3><code>shared_ptr</code> destructor</h3>\n<p id=\"so_11164354_11164508_1\"><em>Effects</em>:</p>\n<ul>\n<li>If <code>*this</code> is <em>empty</em> or shares ownership with another <code>shared_ptr</code> instance (<code>use_count() &gt; 1</code>), there are no side effects.</li>\n<li>Otherwise, if <code>*this</code> <em>owns</em> an object <code>p</code> and a deleter <code>d</code>, <code>d(p)</code> is called.</li>\n<li>Otherwise, <code>*this</code> <em>owns</em> a pointer <code>p</code>, and delete <code>p</code> is called.</li>\n</ul>\n</blockquote>\n<p>So there should be no effect since the shared_ptr is empty? Wrong, because providing the a pointer makes the shared_ptr <em>not</em> empty, even if the pointer is null.</p>\n<p>\u00a720.7.2.2.1[util.smartptr.shared.const]/8\u201310</p>\n<blockquote>\n<p id=\"so_11164354_11164508_2\"><code>shared_ptr</code> constructors</p>\n<pre><code>template&lt;class Y, class D&gt; shared_ptr(Y* p, D d);\ntemplate&lt;class Y, class D, class A&gt; shared_ptr(Y* p, D d, A a);\ntemplate &lt;class D&gt; shared_ptr(nullptr_t p, D d);\ntemplate &lt;class D, class A&gt; shared_ptr(nullptr_t p, D d, A a);\n</code></pre>\n<p id=\"so_11164354_11164508_3\"><em>Requires:</em> <code>p</code> shall be convertible to <code>T*</code>. \u2026</p>\n<p id=\"so_11164354_11164508_4\"><em>Effects:</em> Constructs a <code>shared_ptr</code> object that <em>owns</em> the object <code>p</code> and the deleter <code>d</code>.</p>\n<p id=\"so_11164354_11164508_5\"><em>Postconditions:</em> <code>use_count() == 1 &amp;&amp; get() == p</code>.</p>\n</blockquote>\n<p>This means the shared_ptr <em>owns</em> the nullptr. Thus the deleter will be called when the shared_ptr is destroyed.</p>\n", "OwnerUserId": "224671", "PostTypeId": "2", "Id": "11164508", "Score": "9", "CreationDate": "2012-06-22T21:41:14.697", "LastActivityDate": "2012-06-22T21:41:14.697"}, "11164463": {"ParentId": "11164354", "PostTypeId": "2", "CommentCount": "10", "Body": "<p>The observed behavior is in accordance with the standard.</p>\n<p>For <code>unique_ptr</code>, 20.7.1.2.2/2 (destructor effects) says</p>\n<blockquote>\n<p id=\"so_11164354_11164463_0\">Effects: If <code>get() == nullptr</code> there are no effects. Otherwise\n  <code>get_deleter()(get())</code>.</p>\n</blockquote>\n<p>For <code>shared_ptr</code>, 20.7.2.2.2/1 says that the deleter should be called even if it wraps the null pointer:</p>\n<blockquote>\n<p id=\"so_11164354_11164463_1\">Effects:</p>\n<ul>\n<li>If *this is empty or shares ownership with another\n  <code>shared_ptr</code> instance (<code>use_count() &gt; 1</code>), there are no side effects.</li>\n<li><strong>Otherwise, if *this owns an object <code>p</code> and a deleter <code>d</code>, <code>d(p)</code> is called.</strong></li>\n<li>Otherwise, *this owns a pointer <code>p</code>, and <code>delete p</code> is called.</li>\n</ul>\n</blockquote>\n<p>The important detail here is the expression \"owns an object <code>p</code>\". 20.7.2.2/1 says that \"a <code>shared_ptr</code> object is <em>empty</em> if it does not <em>own</em> a pointer\". 20.7.2.2.1/9 (the relevant constructor) says that it \"constructs a <code>shared_ptr</code> object that owns the object <code>p</code> and the deleter <code>d</code>\".</p>\n<p>So as far as I can tell, that invocation technically makes the <code>shared_ptr</code> <em>own</em> the null pointer, which results in the deleter being called. Contrast this with the parameterless constructor which is said to leave the <code>shared_ptr</code> \"<em>empty</em>\".</p>\n", "OwnerUserId": "50079", "LastEditorUserId": "50079", "LastEditDate": "2012-06-22T22:07:25.790", "Id": "11164463", "Score": "25", "CreationDate": "2012-06-22T21:37:28.033", "LastActivityDate": "2012-06-22T22:07:25.790"}, "bq_ids": {"n4140": {"so_11164354_11164463_0": {"section_id": 4319, "quality": 0.8571428571428571, "length": 6}, "so_11164354_11164508_4": {"section_id": 4386, "quality": 0.7142857142857143, "length": 5}, "so_11164354_11164508_0": {"section_id": 4319, "quality": 0.8571428571428571, "length": 6}}, "n3337": {"so_11164354_11164463_0": {"section_id": 4160, "quality": 0.8571428571428571, "length": 6}, "so_11164354_11164508_4": {"section_id": 4223, "quality": 0.7142857142857143, "length": 5}, "so_11164354_11164508_0": {"section_id": 4160, "quality": 0.8571428571428571, "length": 6}}, "n4659": {"so_11164354_11164463_0": {"section_id": 5576, "quality": 0.8571428571428571, "length": 6}, "so_11164354_11164508_4": {"section_id": 5651, "quality": 0.8571428571428571, "length": 6}, "so_11164354_11164508_0": {"section_id": 5576, "quality": 0.8571428571428571, "length": 6}}}, "11164354": {"CommentCount": "0", "AcceptedAnswerId": "11164463", "PostTypeId": "1", "LastEditorUserId": "46642", "CreationDate": "2012-06-22T21:26:48.610", "LastActivityDate": "2012-06-22T22:07:25.790", "LastEditDate": "2012-06-22T21:27:38.227", "ViewCount": "1721", "FavoriteCount": "2", "Title": "Does the standard behavior for deleters differ between shared_ptr and unique_ptr in the case of null pointers?", "Id": "11164354", "Score": "27", "Body": "<p>OK, so first some things that might be relevant:</p>\n<p>I'm using the Clang 3.1 compiler, in C++11 mode, with the standard library set to libc++.</p>\n<p>I'm trying to familiarize myself with C++11, and in so doing I ran across behavior that seems odd. It may be a quirk of Clang or libc++ but I can't speak C++ standardese and I have no access to other compilers with C++11 support so I can't really check it, and I've searched the internet and Stack Overflow to the best of my ability without finding anything related...so here we go:</p>\n<p>When using shared_ptr / unique_ptr to implement RAII for a simple resource, it seems that their behavior differs with respect to null pointers upon deletion. I realize that normally it's not necessary to delete a null pointer, but I had expected the behavior to at least match between the two STL smart pointers.</p>\n<p>For the specific case, consider the following code:</p>\n<pre><code>{\n    auto Deleter = [](void *){cout &lt;&lt; \"It's later!\" &lt;&lt; endl;};\n    shared_ptr&lt;void&gt; spDoSomethingLater(nullptr, Deleter);\n    unique_ptr&lt;void, void (*)(void *)&gt; upDoSomethingLater(nullptr, Deleter);\n    cout &lt;&lt; \"It's now!\" &lt;&lt; endl;\n}\n</code></pre>\n<p>I would have expected one of the following outputs from this:</p>\n<p>a) If both deleters are called even though the pointer is null:</p>\n<pre><code>\"It's now!\"\n\"It's later!\"\n\"It's later!\"\n</code></pre>\n<p>b) If neither deleter is called because the pointer is null:</p>\n<pre><code>\"It's now!\"\n</code></pre>\n<p>But I observe neither of these cases. Instead, I observe:</p>\n<pre><code>\"It's now!\"\n\"It's later!\"\n</code></pre>\n<p>Which means one but not the other of the deleters is being called. Upon further investigation, I found that the deleter for shared_ptr is called regardless of whether it holds a null value, but unique_ptr's deleter is only called if it does not hold a null value.</p>\n<p>My questions: \nIs this actually the correct behavior as specified by the standard? If so, why does the specified behavior differ between the two STL types in this manner? If not, is this a bug I should report to libc++?</p>\n", "Tags": "<c++><c++11><shared-ptr><unique-ptr><nullptr>", "OwnerUserId": "660162", "AnswerCount": "2"}});