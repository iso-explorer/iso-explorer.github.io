post_cb({"47172507": {"ViewCount": "66", "Body": "<p>In C++ primer(5th) 19.2.1 about dynamic_cast. It says, for <code>dynamic_cast&lt;type*&gt;(e)</code> to be successful, </p>\n<blockquote>\n<p id=\"so_47172507_47172507_0\">the type of e must be either a class type that is publicly derived from\n  the target type, <strong>a public base class of the target type</strong>, or the same as the target\n  type</p>\n</blockquote>\n<p>However, for the following code:</p>\n<pre><code>class B{\n  public:\n    virtual ~B(){}\n};\n\nclass D : public B{};\n\nB *pb = new B;\nD *pd = dynamic_cast&lt;D*&gt;(pb);\nif(pd == 0) cout &lt;&lt; \"err\" &lt;&lt; endl;\n</code></pre>\n<p>The output is \"err\". But the type of pb is a public base class of type D.</p>\n<p>Is this a mistake in C++ primer(5th)? Or do I just misunderstand these words?</p>\n", "AcceptedAnswerId": "47172661", "Title": "dynamic_cast<D *>(pb) return null", "CreationDate": "2017-11-08T05:55:34.637", "Id": "47172507", "CommentCount": "4", "PostTypeId": "1", "LastActivityDate": "2017-11-08T06:13:14.347", "Score": "2", "OwnerUserId": "4526762", "Tags": "<c++><dynamic-cast>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_47172507_47172507_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 7008}}, "n3337": {"so_47172507_47172507_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 6754}}, "n4659": {"so_47172507_47172507_0": {"length": 10, "quality": 0.5882352941176471, "section_id": 4087}}}, "47172661": {"Id": "47172661", "PostTypeId": "2", "Body": "<p>The type of <code>pb</code> is indeed a public base class of <code>D</code>, but the object that <code>pb</code> points to is <em>not</em> the base subobject of any object of type <code>D</code>. The dynamic cast detects this and returns null.</p>\n<p>If indeed you did attempt to cast the pointer to a base subobject of a <code>D</code> object, you would get the (non-null) pointer to the <code>D</code> object:</p>\n<pre><code>D obj;\nB *pb = &amp;obj;   // points at subobject\n\nassert(&amp;obj == dynamic_cast&lt;D*&gt;(pb));\n</code></pre>\n<p>The requirement that you've cited is merely a static requirement that allows you to use the dynamic cast at all -- but it does not describe the <em>result</em> of using the cast. That's described later on.</p>\n", "LastActivityDate": "2017-11-08T06:06:55.830", "CommentCount": "3", "CreationDate": "2017-11-08T06:06:55.830", "ParentId": "47172507", "Score": "4", "OwnerUserId": "596781"}, "47172581": {"Id": "47172581", "PostTypeId": "2", "Body": "<p><code>dynamic_cast</code> can be used as a tool to detect if an object is derived from another one or not, in the code you've written, the answer is NO, so you got a null. By</p>\n<pre><code>B *pb = new B;\nD *pd = dynamic_cast&lt;D*&gt;(pb);\n</code></pre>\n<p>You're down-casting a base to a derived, and it is reverse of what the documet is saying. Of course you can have below if <code>pb</code> points to an extact <code>D*</code>:</p>\n<pre><code>B *pb = new D; // &lt;--- It is a `D`\nD *pd = dynamic_cast&lt;D*&gt;(pb);\n</code></pre>\n", "LastEditorUserId": "952747", "LastActivityDate": "2017-11-08T06:13:14.347", "Score": "2", "CreationDate": "2017-11-08T06:00:43.610", "ParentId": "47172507", "CommentCount": "0", "OwnerUserId": "952747", "LastEditDate": "2017-11-08T06:13:14.347"}});