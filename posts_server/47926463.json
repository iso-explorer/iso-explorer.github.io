post_cb({"47926463": {"Tags": "<c++><c++11><c++17><undefined-behavior><reinterpret-cast>", "ViewCount": "110", "LastEditDate": "2017-12-21T16:26:06.537", "CreationDate": "2017-12-21T13:55:01.270", "LastEditorUserId": "6370128", "Title": "Why do c++ standard not guarantee pointer-interconvertibility between an array of objects and its first element?", "CommentCount": "3", "AnswerCount": "0", "Score": "5", "OwnerUserId": "6370128", "ClosedDate": "2017-12-21T15:41:31.897", "Id": "47926463", "LastActivityDate": "2017-12-21T16:26:06.537", "Body": "<p>According to this</p>\n<p><a href=\"http://eel.is/c++draft/basic.compound#4\" rel=\"nofollow noreferrer\">http://eel.is/c++draft/basic.compound#4</a></p>\n<blockquote>\n<p id=\"so_47926463_47926463_0\">Two objects a and b are pointer-interconvertible if:</p>\n<ul>\n<li>they are the same object, or</li>\n<li>one is a union object and the other is a non-static data member of that object ([class.union]), or</li>\n<li>one is a standard-layout class object and the other is the first non-static data member of that object, or, if the object has no non-static data members, the first base class subobject of that object ([class.mem]), or</li>\n<li>there exists an object c such that a and c are pointer-interconvertible, and c and b are pointer-interconvertible.</li>\n</ul>\n<p id=\"so_47926463_47926463_1\">If two objects are pointer-interconvertible, then they have the same address, and it is possible to obtain a pointer to one from a pointer to the other via a reinterpret_\u00adcast.\n  [\u2009<strong>Note: An array object and its first element are not pointer-interconvertible, even though they have the same address.</strong>\n  \u2014\u2009end note ]</p>\n</blockquote>\n<p>Why do c++ standard not guarantee pointer-interconvertibility between an array of objects and its first element whereas do guarantee class and its 1st member ?</p>\n<p>How come this is undefined behavior?</p>\n<pre><code>char carr[8];\nchar&amp; ch0 = carr[0];\nauto&amp; carr2 = reinterpret_cat&lt;char (&amp;) [8]&gt;(ch0); // Is this considered undefined behavior?\n\n// Because ch0 (char&amp;) and carr2 (char(&amp;)[8]) are not \"pointer-interconvertible\".\n// So they can not use reinterpret_cast \"definedly\".\n// Array and its first element are not \"pointer-interconvertible\"\n// eventhough they share the same address.\n</code></pre>\n<p>While this is an example on the standard itself.</p>\n<p><a href=\"http://www.eel.is/c++draft/basic.types#2\" rel=\"nofollow noreferrer\">http://www.eel.is/c++draft/basic.types#2</a></p>\n<pre><code>#define N sizeof(T)\nchar buf[N];\nT obj;                          // obj initialized to its original value\nstd::memcpy(buf, &amp;obj, N);      // between these two calls to std\u200b::\u200bmemcpy, \n                                // obj might be modified\nstd::memcpy(&amp;obj, buf, N);      // at this point, each subobject of obj\n                                // of scalar type holds its original value\n</code></pre>\n<p>Think if T = char[N]? Well, wouldn't &amp;obj become char(&amp;)[N]? Why is std::memcpy so superior that it can use char(&amp;)[N] while we can't.</p>\n<p>This is so amusing.</p>\n<p>I'm eager to know why the standard intentionally make <code>char *</code> and <code>std::memcpy</code> <strong>only</strong> tools to iterate storage by bytes.</p>\n", "PostTypeId": "1"}, "bq_ids": {"n4659": {"so_47926463_47926463_1": {"length": 28, "section_id": 8733, "quality": 0.9032258064516129}}}});