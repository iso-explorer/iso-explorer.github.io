post_cb({"20726714": {"ParentId": "20580138", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Wrap <code>std::string</code> in your own type. By making it a template you can customise any existing container and add your own range logic to it. It's not even that different from your first attempt.</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n\ntemplate &lt;typename S&gt;\nstruct custom_container {\n    S &amp;s_;\n\n    custom_container (S &amp;s) : s_(s) {}\n\n    auto begin() -&gt; decltype(s_.begin()) {\n        std::cout &lt;&lt; \"BEGIN\";\n        return s_.begin();\n    }\n\n    auto end() -&gt; decltype(s_.end()) {\n        std::cout &lt;&lt; \"END\";\n        return s_.end();\n    }\n};\n\ntemplate &lt;typename S&gt;\ncustom_container make_container (S &amp;s) {\n     return custom_container &lt;S&gt; (s);\n}\n\n\nint main () {\n    std::string t = \"asdf\";\n    auto s = make_container(t);\n\n    for (char c : s) {\n        std::cout &lt;&lt; c;\n    }\n}\n</code></pre>\n<p>Outputs</p>\n<blockquote>\n<p id=\"so_20580138_20726714_0\">BEGINENDasdf</p>\n</blockquote>\n", "OwnerUserId": "184741", "LastEditorUserId": "184741", "LastEditDate": "2013-12-23T23:04:41.770", "Id": "20726714", "Score": "6", "CreationDate": "2013-12-22T06:01:31.780", "LastActivityDate": "2013-12-23T23:04:41.770"}, "20726854": {"ParentId": "20580138", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-12-22T06:25:47.773", "Id": "20726854", "LastEditDate": "2017-05-23T11:43:37.040", "OwnerDisplayName": "user1508519", "Score": "6", "Body": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow noreferrer\">N3337</a> 6.5.4/1:</p>\n<blockquote>\n<p id=\"so_20580138_20726854_0\">(...) <i>begin-expr</i> and <i>end-expr</i> are determined as follows:</p>\n<p id=\"so_20580138_20726854_1\">\u2014 if <code>_RangeT</code> is an array type, <i>begin-expr</i> and <i>end-expr</i> are\n  <code>__range</code> and <code>__range + __bound</code>, respectively, (...);</p>\n<p id=\"so_20580138_20726854_2\">\u2014 if <code>_RangeT</code> is a class type, the <i>unquali\ufb01ed-id</i>s <code>begin</code> and <code>end</code> are\n  looked up in the scope of class <code>_RangeT</code> as if by class member access\n  lookup (3.4.5), and if either (or both) \ufb01nds at least one declaration,\n  <i>begin-expr</i> and <i>end-expr</i> are <code>__range.begin()</code> and <code>__range.end()</code>,\n  respectively;</p>\n<p id=\"so_20580138_20726854_3\">\u2014 otherwise, <i>begin-expr</i> and <i>end-expr</i> are <code>begin(__range)</code> and\n  <code>end(__range)</code>, respectively, where <code>begin</code> and <code>end</code> are looked up with\n  argument-dependent lookup (3.4.2). For the purposes of this name\n  lookup, namespace <code>std</code> is an associated namespace.</p>\n</blockquote>\n<p>So in other words, it will call <code>std::string</code>'s <code>begin</code> and <code>end</code> member functions (second list bullet). The correct solution is to provide a wrapper class as <a href=\"https://stackoverflow.com/a/20726714/1508519\">anthony</a>'s answer suggests.</p>\n<p>Note: If you use <code>-std=c++1y</code> you can omit the trailing decltype.</p>\n<p>You can also write a typedef to make it less typing:</p>\n<pre><code>typedef custom_string&lt;std::string&gt; cs;\n\nfor (char c : cs(t)) {\n    std::cout &lt;&lt; c;\n}\n</code></pre>\n", "LastActivityDate": "2013-12-23T12:05:02.737", "LastEditorUserId": "-1"}, "20780978": {"ParentId": "20580138", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The cleanest way to do, at least at the point of use, this is to mark up your type for the purpose of special iteration.</p>\n<p>First, some machinery:</p>\n<pre><code>template&lt;class Mark, class T&gt;\nstruct marked_type {\n  T raw;\n  marked_type(T&amp;&amp; in):raw(std::forward&lt;T&gt;(in)) {}\n};\ntemplate&lt;typename Mark, typename T&gt;\nmarked_type&lt;Mark, T&gt; mark_type( T&amp;&amp; t ) {\n  return {std::forward&lt;T&gt;(t)};\n}\n</code></pre>\n<p>next, we invent a mark that says \"iterate strangely\", and overload begin/end:</p>\n<pre><code>struct strange_iteration {};\ntemplate&lt;typename T&gt;\nauto begin( marked_type&lt;strange_iteration, T&gt; const&amp; container )\n  -&gt; decltype( std::begin(std::forward&lt;T&gt;(container.raw)) )\n{\n  std::cout &lt;&lt; \"BEGIN\";\n  using std::begin;\n  return begin(std::forward&lt;T&gt;(container.raw));\n}\ntemplate&lt;typename T&gt;\nauto end( marked_type&lt;strange_iteration, T&gt; const&amp; container )\n  -&gt; decltype( std::end(std::forward&lt;T&gt;(container.raw)) )\n{\n  std::cout &lt;&lt; \"END\";\n  using std::end;\n  return end(std::forward&lt;T&gt;(container.raw));\n}        \n</code></pre>\n<p>and then at point of use:</p>\n<pre><code>std::string s = \"hello world\";\nfor( char c : mark_type&lt;strange_iteration&gt;(s) ) {\n  std::cout &lt;&lt; c;\n}\nstd::cout &lt;&lt; \"\\n\";\n</code></pre>\n<p>with the one note that I wrote <code>mark_type</code> to be overly generic.</p>\n<p>Now, <code>mark_type&lt;Foo&gt;</code> will create references to lvalues, and create a moved-to copy of an rvalue, if passed to it.  In an iteration, its return value's lifetime will be extended by reference lifetime extension.</p>\n<p>You can use this technique to do things like</p>\n<pre><code>for( char c : mark_type&lt;reverse_iteration&gt;(s) )\n</code></pre>\n<p>where now we instead iterate backwards, regardless of the container we have passed in.  The \"creation of a copy\" for rvalue is needed for constructs like this:</p>\n<pre><code>for( char c: mark_type&lt;reverse_iteration&gt;(mark_type&lt;strange_iteration&gt;(s))\n</code></pre>\n<p>where we daisy-chain the marks.  Lifetime extension only applies to the outermost return value, and our \"create a copy and move\" on rvalue is basically manual lifetime extension.</p>\n<p>Finally, the <code>std::begin</code> use in the above code is better done in an ADL-admitting context in the return values.  Create a helper namespace like this:</p>\n<pre><code>namespace adl_helper {\n  using std::begin; using std::end;\n  template&lt;typename T&gt;\n  auto adl_begin(T&amp;&amp; t)-&gt;decltype( begin(std::forward&lt;T&gt;(t)) ); // no implementation\n  template&lt;typename T&gt;\n  auto adl_end(T&amp;&amp; t)-&gt;decltype( end(std::forward&lt;T&gt;(t)) ); // no implementation\n  // add adl_cbegin, adl_rbegin etc in C++14\n}\n</code></pre>\n<p>then replace <code>std::begin</code> in the <code>decltype</code>s in my above code with <code>adl_helper::adl_begin</code>, which emulates how <code>for( a:b )</code> loops find <code>begin</code> and <code>end</code> a touch better (not perfectly, but better).</p>\n<p>C++1y may come with some machinery to remove the need for the above hack.</p>\n<p>Sample code running: <a href=\"http://ideone.com/RYvzD0\" rel=\"nofollow\">http://ideone.com/RYvzD0</a></p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2013-12-26T07:41:28.750", "Id": "20780978", "Score": "1", "CreationDate": "2013-12-26T07:33:02.257", "LastActivityDate": "2013-12-26T07:41:28.750"}, "bq_ids": {"n4140": {"so_20580138_20726854_2": {"section_id": 3906, "quality": 0.8461538461538461, "length": 22}, "so_20580138_20726854_1": {"section_id": 3906, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_20580138_20726854_1": {"section_id": 3766, "quality": 0.7777777777777778, "length": 7}, "so_20580138_20726854_2": {"section_id": 3766, "quality": 0.8461538461538461, "length": 22}, "so_20580138_20726854_3": {"section_id": 3766, "quality": 0.8571428571428571, "length": 18}}, "n4659": {"so_20580138_20726854_0": {"section_id": 4792, "quality": 1.0, "length": 4}, "so_20580138_20726854_2": {"section_id": 4792, "quality": 0.6923076923076923, "length": 18}, "so_20580138_20726854_1": {"section_id": 4792, "quality": 0.6666666666666666, "length": 6}}}, "20580138": {"CommentCount": "3", "AcceptedAnswerId": "20726714", "PostTypeId": "1", "LastEditorUserId": "2925619", "CreationDate": "2013-12-14T05:48:21.567", "LastActivityDate": "2013-12-26T07:41:28.750", "LastEditDate": "2013-12-14T05:53:42.590", "ViewCount": "214", "FavoriteCount": "1", "Title": "Prefer some function over ADL", "Id": "20580138", "Score": "7", "Body": "<p>I want to use range-based <code>for</code> to iterate over the unicode code points in a UTF8 encoded <code>std::string</code>. I have defined my own <code>begin</code> and <code>end</code> in the global namespace but the <code>begin</code> and <code>end</code> in the <code>std</code> namespace are being preferred (i.e. those found by ADL). Is there any way to prefer my own functions?</p>\n<p>Example:</p>\n<pre><code>const char* begin(const std::string&amp; s) {\n    std::cout &lt;&lt; \"BEGIN\";\n    return s.data();\n}\n\nconst char* end(const std::string&amp; s) {\n    std::cout &lt;&lt; \"END\";\n    return s.data() + s.length();\n}\n\nint main() {\n    std::string s = \"asdf\";\n\n    for (char c : s)\n        std::cout &lt;&lt; c;\n}\n</code></pre>\n<p>I want it to print <code>BEGINENDasdf</code> (or <code>ENDBEGINasdf</code>) but it prints <code>asdf</code>.</p>\n<p>Is there no other way than to do a manual <code>for</code> using a qualified name?</p>\n", "Tags": "<c++><argument-dependent-lookup>", "OwnerUserId": "2925619", "AnswerCount": "3"}});