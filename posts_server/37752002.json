post_cb({"37752002": {"CommentCount": "12", "AcceptedAnswerId": "37752390", "CreationDate": "2016-06-10T15:31:25.583", "LastActivityDate": "2016-06-10T23:07:27.220", "PostTypeId": "1", "ViewCount": "365", "FavoriteCount": "3", "Title": "How to safely cast integral types to scoped enums", "Id": "37752002", "Score": "5", "Body": "<p><code>C++11</code> scoped enums are great, you should use them whenever possible.\nHowever, sometimes you need to convert an integer to a scoped enum value (say if you are getting it from user input).</p>\n<p>Is there a safe way to do this and detect when the value is not valid (i.e., outside the permitted values of the enum)?</p>\n<p>I believe just using static_cast leads to undefined behavior if the integer is not valid. Is there a generic way of doing that does not require writing a conversion function for each scoped enum type by hand (and that needs to be updated every time you add a new value to the enum)?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "1027857", "AnswerCount": "3"}, "37757636": {"ParentId": "37752002", "CommentCount": "2", "Body": "<p>[dcl.enum]/8:</p>\n<blockquote>\n<p id=\"so_37752002_37757636_0\">For an enumeration whose underlying type is fixed, the values of the\n  enumeration are the values of the underlying type.</p>\n</blockquote>\n<p>This includes all scoped enumerations, because the underlying type of a scoped enum defaults to <code>int</code>:</p>\n<blockquote>\n<p id=\"so_37752002_37757636_1\">The underlying type can be explicitly specified using an <em>enum-base</em>.\n  For a scoped enumeration type, the underlying type is <code>int</code> if it is not\n  explicitly specified. In both of these cases, the underlying type is\n  said to be <em>fixed</em>.</p>\n</blockquote>\n<p>Thus, by verifying that the input value is within the range of the underlying type of the enum (which you can check with <code>std::numeric_limits</code> and <code>std::underlying_type</code>), you can be sure that the <code>static_cast</code> will always have well-defined behavior.</p>\n<p>However, that's not enough if the rest of your program isn't prepared to handle every value within the range of the enum's underlying type. In that case, you'll have to do validation yourself, possibly with something along the lines of @Altainia's answer.</p>\n", "OwnerUserId": "2756719", "PostTypeId": "2", "Id": "37757636", "Score": "3", "CreationDate": "2016-06-10T21:53:33.440", "LastActivityDate": "2016-06-10T21:53:33.440"}, "37752390": {"ParentId": "37752002", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>A common way to do that is to include in your enum an ending marker</p>\n<pre><code>enum class Colors : char\n{\n  Red,\n  Green,\n  Blue,\n  Last_Element\n}\n</code></pre>\n<p>Using this approach, when converting, you can check if the value you're using is less than the value of Last_Element.</p>\n<p>Consider the following function:</p>\n<pre><code>template&lt;typename T&gt;\ntypename std::enable_if&lt;std::is_enum&lt;T&gt;::value, bool&gt;::type\n  IsValidEnumIntegral&lt;T&gt;(int integral)\n{\n  return (int)(T::Last_Element) &gt; integral;\n}\n</code></pre>\n<p>and you could use it like so:</p>\n<pre><code>if(IsValidEnumIntegral&lt;Colors&gt;(2))\n  //do whatever\n</code></pre>\n<p>This would work for any enum you made with an element called Last_Element. You could go further to create a similar function to then auto-convert for you.</p>\n<p>Note: This is not tested. I am not in a position to do so at the moment but I think this could work.</p>\n<p><strong>EDIT</strong>: This will only work if the enum in question uses a set of integers with no gaps for its elements. The function provided will also assume the enum does not contain negative integers, though a First_Element can easily be added to it.</p>\n", "OwnerUserId": "5344725", "LastEditorUserId": "5344725", "LastEditDate": "2016-06-10T17:38:40.047", "Id": "37752390", "Score": "3", "CreationDate": "2016-06-10T15:50:47.420", "LastActivityDate": "2016-06-10T17:38:40.047"}, "bq_ids": {"n4140": {"so_37752002_37757636_0": {"section_id": 5466, "quality": 0.9090909090909091, "length": 10}, "so_37752002_37757636_1": {"section_id": 5464, "quality": 0.9130434782608695, "length": 21}}, "n3337": {"so_37752002_37757636_0": {"section_id": 5252, "quality": 0.9090909090909091, "length": 10}, "so_37752002_37757636_1": {"section_id": 5251, "quality": 0.6956521739130435, "length": 16}}, "n4659": {"so_37752002_37757636_0": {"section_id": 6900, "quality": 0.9090909090909091, "length": 10}, "so_37752002_37757636_1": {"section_id": 6898, "quality": 0.9130434782608695, "length": 21}}}, "37758280": {"ParentId": "37752002", "CommentCount": "0", "Body": "<p>Another way that I've seen this kind of thing done in some codebases is, basically, use a type trait to decorate your scoped enums with extra info.</p>\n<p>The idea is that you would have some trait like</p>\n<pre><code>namespace mpl {\n    template &lt;typename T&gt;\n    struct GetEnumData;\n}\n</code></pre>\n<p>Then, when you declare a \"smart\" enum, you will also specialize this trait to link to a structure that contains metadata about the scoped enum, like what the legal values are. Or, a list of strings corresponding to the names of the enum values, so you can do the enum-to-string conversion and back.</p>\n<pre><code>enum class my_enum { a, b, c };\nnamespace mpl {\n  template&lt;&gt;\n  struct GetEnumData&lt;my_enum&gt; {\n    static constexpr std::size_t my_number = 3;\n    static const char * const my_strings [] () {\n      return {\"a\", \"b\", \"c\"};\n    }\n    static const int my_values [] () {\n      return {0, 1, 2};\n    }\n  }\n} // end namespace mpl\n</code></pre>\n<p>N.B. Generating the above type trait is a bit tedious, so invariably, you end up using some macro for your \"smart enum\" declarations. If you really don't like macros then this approach is not for you. At least until C++ adds some more introspection features in future versions (fingers crossed).</p>\n<p>Once you have this type trait though, you can do useful things like \"enum_cast\" which will parse a string to an enum for instance.</p>\n<pre><code>template &lt;typename T&gt;\nT enum_cast(const std::string &amp; input) {\n  using data = GetEnumData&lt;T&gt;;\n\n  for (std::size_t idx = 0; idx &lt; data::my_number; ++idx) {\n    if (data::my_strings()[idx] == input) {\n      return static_cast&lt;T&gt;(data::my_values()[idx]);\n    }\n  }\n  throw bad_enum_value(input);\n}\n</code></pre>\n<p>And you could do something similar for <code>int</code>'s or other integral types.</p>\n", "OwnerUserId": "3598119", "PostTypeId": "2", "Id": "37758280", "Score": "1", "CreationDate": "2016-06-10T23:07:27.220", "LastActivityDate": "2016-06-10T23:07:27.220"}});