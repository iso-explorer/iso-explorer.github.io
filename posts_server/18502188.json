post_cb({"18502590": {"Id": "18502590", "PostTypeId": "2", "Body": "<p>The behavior you observe is correct:  <code>decltype(makeCI())</code> is <code>int</code>, not <code>int const</code>.</p>\n<p>The <code>makeCI()</code> function call expression is a prvalue expression.  Per C++11 \u00a73.10[basic.lval]/4:</p>\n<blockquote>\n<p id=\"so_18502188_18502590_0\">Class prvalues can have cv-qualified types; non-class prvalues always have cv-unqualified types.</p>\n</blockquote>\n<p>The term \"cv-qualification\" refers to const- and volatile-qualification.  <code>int</code> is not a class type, so the type of the rvalue expression <code>makeCI()</code> is <code>int</code> and it is not const-qualified.</p>\n<p>(In recent drafts of the C++ language standard, e.g. N3690, this text has been removed and replaced by new text at \u00a75[expr]/6, which states, \"If a prvalue initially has the type \"cv T,\" where T is a cv-unqualified non-class, non-array type, the type of the expression is adjusted to T prior to any further analysis.\"  See <a href=\"http://wg21.cmeerw.net/cwg/issue1261\" rel=\"noreferrer\">CWG defect 1261</a> for details.)</p>\n", "LastEditorUserId": "151292", "LastActivityDate": "2013-08-29T05:14:07.753", "Score": "16", "CreationDate": "2013-08-29T04:57:47.607", "ParentId": "18502188", "CommentCount": "4", "OwnerUserId": "151292", "LastEditDate": "2013-08-29T05:14:07.753"}, "bq_ids": {"n4140": {"so_18502188_18502590_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 7233}}, "n3337": {"so_18502188_18502590_0": {"length": 12, "quality": 1.0, "section_id": 6977}}, "n4659": {"so_18502188_18502590_0": {"length": 11, "quality": 0.9166666666666666, "section_id": 8746}}}, "18502188": {"ViewCount": "1199", "Body": "<p>As a general rule, <code>decltype</code> preserves constness:</p>\n<pre><code>const int ci = 0;\ndecltype(ci)  x;         // x is const int\nx = 5;                   // error--x is const\n\nclass Gadget{}:\n\nconst Gadget makeCG();         // factory\n\ndecltype(makeCG()) y1, y2;     // y1 and y2 are const Gadgets\ny1 = y2;                       // error--y1 is const\n</code></pre>\n<p>But for <code>const</code> return types that return fundamental types, <code>decltype</code> seems to throw <code>const</code> away:</p>\n<pre><code>const int makeCI();            // factory\n\ndecltype(makeCI()) z;          // z is NOT const\nz = 5;                         // okay\n</code></pre>\n<p>Why does <code>decltype</code> discard constness in this case?  I mean the question in two ways:</p>\n<ol>\n<li>What part of the standard specifies this behavior?</li>\n<li>What is the motivation for specifying the behavior this way?</li>\n</ol>\n<p>Thanks.</p>\n", "AcceptedAnswerId": "18502590", "Title": "Why does decltype remove const from return types for built-in types?", "CreationDate": "2013-08-29T04:18:03.057", "Id": "18502188", "CommentCount": "4", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-08-29T05:14:07.753", "Score": "8", "OwnerUserId": "1426649", "Tags": "<c++><c++11><decltype>", "AnswerCount": "1"}});