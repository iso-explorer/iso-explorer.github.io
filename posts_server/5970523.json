post_cb({"5970551": {"ParentId": "5970523", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It doesn't matter whether they can leak or not. The C++ standard says that deleting a derived class via  a base pointer is undefined behavior if the base does not have a virtual destructor.  Specifically from 5.3.5/3:</p>\n<blockquote>\n<p id=\"so_5970523_5970551_0\">In the first alternative (delete object), if the static type of the\n  operand is different from its dynamic type, the  static   type   shall   be \n  a   base   class   of   the   operand\u2019s   dynamic   type   and   the\n  static   type   shall   have   a  virtual destructor or the behavior is undefined.</p>\n</blockquote>\n<p>So once you have done such a deletion, your program is in an undefined state, and all questions about leaks are moot.</p>\n", "OwnerUserId": "2100815", "LastEditorUserId": "2100815", "LastEditDate": "2011-05-11T21:25:46.087", "Id": "5970551", "Score": "4", "CreationDate": "2011-05-11T20:58:14.753", "LastActivityDate": "2011-05-11T21:25:46.087"}, "5970523": {"CommentCount": "3", "AcceptedAnswerId": "5970543", "PostTypeId": "1", "LastEditorUserId": "239916", "CreationDate": "2011-05-11T20:55:47.510", "LastActivityDate": "2011-05-11T21:25:46.087", "LastEditDate": "2011-05-11T21:01:52.083", "ViewCount": "661", "FavoriteCount": "1", "Title": "Non-virtual trivial destructor + Inheritance", "Id": "5970523", "Score": "2", "Body": "<p>Given that a class and all its subclasses need no more than the default destructor to release their resources if stored in a variable of the exact type (or pointer to the exact type), can a subclass leak memory if referenced by a base class pointer and then deleted by that pointer?</p>\n<h2>Example:</h2>\n<pre><code>#include &lt;memory&gt;\n\nclass A {\n};\n\nclass B : public A {\npublic:\n    B () : pInt(new int) {}\n    auto_ptr&lt;int&gt; pInt; // this is what might leak... possibly more will though\n};\n\nvoid will_this_leak () {\n    A *pA = new B();\n    delete pA;\n}\n</code></pre>\n", "Tags": "<c++><inheritance><destructor>", "OwnerUserId": "239916", "AnswerCount": "4"}, "5970739": {"ParentId": "5970523", "CommentCount": "0", "Body": "<p>The code as of now exhibits <em>undefined-behavior</em>. </p>\n<blockquote>\n<p id=\"so_5970523_5970739_0\">If the static type of the operand is\n  different from the dynamic type, then\n  the static type becomes the base class\n  and it's destructor must be <strong>virtual</strong>. Else the behavior is undefined.</p>\n</blockquote>\n<pre><code>#include &lt;memory&gt;\n\nclass A {\n\n    public :\n    virtual ~A() {} // This makes the derived sub-object destruction first\n\n};\n\nclass B : public A {\npublic:\n    B () : pInt(new int) {}\n    auto_ptr&lt;int&gt; pInt; \n\n    /* There is no need to write any custom destructor\n       in this case. auto_ptr will effectively handle deallocating\n       the acquired resources from free store.\n    */\n};\n\nvoid will_this_leak () {\n    A *pA = new B();\n    delete pA;\n}\n</code></pre>\n<p>With the above changes made, there shouldn't be any undefined behavior or memory leaks.</p>\n", "OwnerUserId": "528724", "PostTypeId": "2", "Id": "5970739", "Score": "1", "CreationDate": "2011-05-11T21:18:36.953", "LastActivityDate": "2011-05-11T21:18:36.953"}, "5970543": {"ParentId": "5970523", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>\"Leak memory\"? Why are you talking about leaking memory specifically?</p>\n<p>The code you posted produces <em>undefined behavior</em>. Anything can happen in this case: memory leaked, hard drive formatted, program crashed, etc.</p>\n<p>P.S. I know that there's a popular urban legend out there that performing polymorphic destruction without a virtual destructor \"might leak memory\". I don't know who invented that nonsense and why they decided to use \"leaking memory\" as the primary scenario for what might happen. In reality the behavior in this case has absolutely nothing to do with \"leaking memory\". The behavior is simply undefined.</p>\n<p>From the practical point of view, in your particular case it is rather obvious that there's no real chance for the destructor of your <code>auto_ptr</code> to get called, so the memory owned by that <code>auto_ptr</code> will certainly be leaked. But again, this is the least of this code's problems.</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2011-05-11T21:15:33.527", "Id": "5970543", "Score": "9", "CreationDate": "2011-05-11T20:57:49.897", "LastActivityDate": "2011-05-11T21:15:33.527"}, "5970541": {"ParentId": "5970523", "CommentCount": "0", "Body": "<p>Yes, this will leak.  When you delete the A*, it calls ~A().  Since ~A() is not virtual, it won't know that ~B() needs calling too.</p>\n<p>Assuming, of course, that B inherits from A.  I'm guessing that's a typo in your question -- the code as it stands won't compile :)</p>\n", "OwnerUserId": "209199", "PostTypeId": "2", "Id": "5970541", "Score": "1", "CreationDate": "2011-05-11T20:57:45.433", "LastActivityDate": "2011-05-11T20:57:45.433"}, "bq_ids": {"n4140": {"so_5970523_5970551_0": {"section_id": 6107, "quality": 0.88, "length": 22}, "so_5970523_5970739_0": {"section_id": 6107, "quality": 0.631578947368421, "length": 12}}, "n3337": {"so_5970523_5970551_0": {"section_id": 5873, "quality": 0.88, "length": 22}, "so_5970523_5970739_0": {"section_id": 5873, "quality": 0.631578947368421, "length": 12}}, "n4659": {"so_5970523_5970551_0": {"section_id": 7604, "quality": 0.88, "length": 22}, "so_5970523_5970739_0": {"section_id": 7604, "quality": 0.631578947368421, "length": 12}}}});