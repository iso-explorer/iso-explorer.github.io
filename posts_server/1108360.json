post_cb({"1108525": {"ParentId": "1108360", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I remember something similar on operator delete a while ago in comp.lang.c++.moderated. I cannot find it now, but the answer stated something like this ..</p>\n<blockquote>\n<p id=\"so_1108360_1108525_0\">Unfortunately, the language\n  specification is not sufficiently\n  clear on whether the control should go\n  into the overloaded 'operator delete'\n  when the delete-expression is invoked\n  on the null-pointer of corresponding\n  type, even though the standard does\n  say that delete-expression on\n  null-pointer is a no-op.</p>\n</blockquote>\n<p>And <em>James Kanze</em> specifically said:</p>\n<blockquote>\n<p id=\"so_1108360_1108525_1\">It's still the responisiblity of\n  operator delete (or delete[]) to\n  check; the standard doesn't guarantee\n  that it won't be given a null pointer;\n  the standard requires that it be a\n  no-op if given a null pointer. Or that\n  the implementation is allowed to call\n  it. According to the latest draft,\n  \"The value of the first argument\n  supplied to a deallocation function\n  may be a null pointer value; if so,\n  and if the deallocation function is\n  one supplied in the standard library,\n  the call has no effect.\" I'm not quite\n  sure what the implications of that \"is\n  one supplied in the standard library\"\n  are meant to be---taken literally,\n  since his function is not one provided\n  by the standard library, the sentence\n  wouldn't seem to apply. But somehow,\n  that doesn't make sense</p>\n</blockquote>\n<p>I remember this becoz i had a similar prob sometime back and had preserved the answer in a .txt file.</p>\n<p><strong>UPDATE-1:</strong></p>\n<p>Oh i found it <a href=\"http://bytes.com/groups/cpp/853692-null-pointer-overloaded-operator-delete\" rel=\"noreferrer\">here</a>.\nAlso read this link <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_defects.html#348\" rel=\"noreferrer\">defect report</a>.\nSo, the answer is <strong><em>Unspecified</em></strong>. Chapter <strong><em>5.3.5/7</em></strong>. </p>\n", "OwnerUserId": "79298", "LastEditorUserId": "79298", "LastEditDate": "2009-07-10T09:45:14.660", "Id": "1108525", "Score": "21", "CreationDate": "2009-07-10T09:04:40.480", "LastActivityDate": "2009-07-10T09:45:14.660"}, "1108667": {"ParentId": "1108360", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Would like a leave a comment, instead of answer, didn't have enough privileges being a new member.</p>\n<p>An exception is being raised during the creation of object.\nThe destructor is not getting called, as the object itself is not created.</p>\n<p>That you can also observe, as the messages from the constructor &amp; destructor are not getting displayed.</p>\n<p>But, the delete is being called when the destructor is not defined.\nIf thought in the directon that when destrcutor is not defined, C++ Compiler considers it as any other operator, the compiler by default provides a destructor when not defined.</p>\n", "OwnerUserId": "135553", "LastEditorUserId": "135553", "LastEditDate": "2009-07-10T10:03:14.043", "Id": "1108667", "Score": "3", "CreationDate": "2009-07-10T09:44:53.130", "LastActivityDate": "2009-07-10T10:03:14.043"}, "bq_ids": {"n4140": {"so_1108360_1108511_0": {"section_id": 652, "quality": 0.6666666666666666, "length": 4}, "so_1108360_1108360_1": {"section_id": 652, "quality": 0.6666666666666666, "length": 4}}, "n3337": {"so_1108360_1108511_0": {"section_id": 642, "quality": 0.6666666666666666, "length": 4}, "so_1108360_1108360_1": {"section_id": 642, "quality": 0.6666666666666666, "length": 4}}, "n4659": {"so_1108360_1108511_0": {"section_id": 680, "quality": 0.6666666666666666, "length": 4}, "so_1108360_1108360_1": {"section_id": 680, "quality": 0.6666666666666666, "length": 4}}}, "1108540": {"ParentId": "1108360", "CommentCount": "2", "Body": "<p>The object destructor is called before the delete operator. So my guess would be that it tries to call the destructor, realizes that the pointer is NULL therefore</p>\n<ol>\n<li>doesn't call destructor which needs an instance</li>\n<li>stops the deleteing operation there (kind of speed optimization IMHO).</li>\n</ol>\n<p>As Neil said, if w contains a Widget, it should work.</p>\n", "OwnerUserId": "119212", "PostTypeId": "2", "Id": "1108540", "Score": "-1", "CreationDate": "2009-07-10T09:07:54.127", "LastActivityDate": "2009-07-10T09:07:54.127"}, "1108511": {"ParentId": "1108360", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>You were trying to delete a NULL pointer. So, the destructor was not getting called.</p>\n<pre><code>class Widget\n{   \npublic:        \n    Widget()\n    {            \n        cout&lt;&lt;\"Widget()\"&lt;&lt;endl;        \n    }       \n\n    ~Widget() \n    {          \n        cout&lt;&lt;\"~Widget()\"&lt;&lt;endl;    \n    }    \n\n    void* operator new(size_t sz) throw(bad_alloc) \n    {      \n        cout&lt;&lt;\"operator new\"&lt;&lt;endl;  \n        return malloc(sizeof(Widget));\n        //throw bad_alloc();    \n    }  \n\n    void operator delete(void *v)\n    {               \n        cout&lt;&lt;\"operator delete\"&lt;&lt;endl;   \n    }\n};\n\nint main()\n{\n\n    Widget* w = NULL; \n    try \n    {   \n        w = new Widget();\n        //throw bad_alloc();\n    }   \n    catch(bad_alloc) \n    {        \n        cout&lt;&lt;\"Out of Memory\"&lt;&lt;endl;  \n    }   \n    delete w; \n}\n</code></pre>\n<p>Output:</p>\n<blockquote>\n<p id=\"so_1108360_1108511_0\">operator new<br>\n  Widget()<br>\n  ~Widget()<br>\n  operator delete</br></br></br></p>\n</blockquote>\n", "OwnerUserId": "124797", "LastEditorUserId": "3622940", "LastEditDate": "2014-08-10T14:26:22.733", "Id": "1108511", "Score": "-2", "CreationDate": "2009-07-10T09:01:09.317", "LastActivityDate": "2014-08-10T14:26:22.733"}, "1108535": {"ParentId": "1108360", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>The reason is that if you have a destructor, the call to the delete operator is done from within the scalar deleting destructor, which in VC contains the call to both your destructor and the delete operator. The compiler provides code that checks whether you're trying to delete a NULL pointer. Deleting such pointer is legal, of course, but the destructor of such object must not be invoked, as it might contain usage of member variables. For that the call to the scalar deleting destructor is avoided, and as a result the call to the delete operator is avoided as well.</p>\n<p>When there is no destructor, the compiler just calls the delete operator directly, without generating the scalar deleting destructor. Therefore, in such cases the delete operator is invoked after all.</p>\n", "OwnerUserId": "26039", "LastEditorUserId": "26039", "LastEditDate": "2009-07-10T09:58:16.473", "Id": "1108535", "Score": "4", "CreationDate": "2009-07-10T09:06:42.363", "LastActivityDate": "2009-07-10T09:58:16.473"}, "1108641": {"ParentId": "1108360", "CommentCount": "1", "Body": "<p>First of all, this can really be simplified down to <code>delete (Widget*)0</code> - everything else in your <code>main()</code> is unnecessary to repro this.</p>\n<p>It's a code generation artefact that happens because 1) user-defined <code>operator delete</code> must be able to handle NULL values, and 2) compiler tries to generate the most optimal code possible.</p>\n<p>First let's consider the case when no user-defined destructor is involved. If that's the case, there's no code to run on the instance, except for <code>operator delete</code>. There's no point in checking for null before transferring control to <code>operator delete</code>, because the latter should do a check anyway; and so the compiler just generates unconditional call of <code>operator delete</code> (and you see the latter print a message).</p>\n<p>Now the second case - destructor was defined. This means that your <code>delete</code> statement actually expands into two calls - destructor, and <code>operator delete</code>. But destructor cannot be safely called on a null pointer, because it could try to access class fields (the compiler could figure out that your particular destructor doesn't really do it and so is safe to call with null <code>this</code>, but looks like they don't bother in practice). So it inserts a null check in there before the destructor call. And once the check is already there, it might as well use it skip the call to <code>operator delete</code>, too - after all it's required to be a no-op anyway, and it will spare an extra meaningless check for null inside <code>operator delete</code> itself in case the pointer actually is null.</p>\n<p>So far as I can see, nothing in this is in any way guaranteed by ISO C++ spec. It's just that both compilers do the same optimization here.</p>\n", "OwnerUserId": "111335", "PostTypeId": "2", "Id": "1108641", "Score": "9", "CreationDate": "2009-07-10T09:37:08.247", "LastActivityDate": "2009-07-10T09:37:08.247"}, "1108463": {"ParentId": "1108360", "CommentCount": "0", "Body": "<p>I don't have a good answer, but I have simplified the issue slightly. The following code removes the operator new and exception handling:</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass Widget {\n\n  public:\n    Widget() {\n        cout&lt;&lt;\"Widget()\"&lt;&lt;endl;\n    }\n    ~Widget() {\n        cout&lt;&lt;\"~Widget()\"&lt;&lt;endl;\n    }\n\n  void operator delete(void *v) {\n       cout &lt;&lt; \"operator delete\" &lt;&lt; endl;\n  }\n};\n\nint main() {\n    Widget* w = 0;\n    cout &lt;&lt; \"calling delete\" &lt;&lt; endl;\n    delete w;\n}\n</code></pre>\n<p>This still exhibits the same behaviour and des so on both VC++ and g++.</p>\n<p>Of course, deleting a NULL pointer is a no-op, so the compiler does not have to call operator delete. If one actually allocates an object:</p>\n<pre><code>    Widget* w = new Widget;\n</code></pre>\n<p>then things work as expected.</p>\n", "Id": "1108463", "PostTypeId": "2", "OwnerDisplayName": "anon", "Score": "3", "CreationDate": "2009-07-10T08:50:13.973", "LastActivityDate": "2009-07-10T08:50:13.973"}, "1108360": {"CommentCount": "1", "AcceptedAnswerId": "1108525", "PostTypeId": "1", "LastEditorUserId": "3622940", "CreationDate": "2009-07-10T08:21:29.430", "LastActivityDate": "2014-08-10T14:26:22.733", "LastEditDate": "2014-08-10T14:25:02.830", "ViewCount": "2684", "FavoriteCount": "7", "Title": "delete a NULL pointer does not call overloaded delete when destructor is written", "Id": "1108360", "Score": "16", "Body": "<pre><code>class Widget\n{\n    public:\n        Widget() {\n            cout&lt;&lt;\"~Widget()\"&lt;&lt;endl;\n        }\n        ~Widget() {\n            cout&lt;&lt;\"~Widget()\"&lt;&lt;endl;\n        }\n\n    void* operator new(size_t sz) throw(bad_alloc) {\n        cout&lt;&lt;\"operator new\"&lt;&lt;endl;\n        throw bad_alloc();\n    }\n\n    void operator delete(void *v) {\n        cout&lt;&lt;\"operator delete\"&lt;&lt;endl;\n    }\n\n};\n\nint main() \n{\n    Widget* w = 0;\n    try {\n        w = new Widget();\n    }\n    catch(bad_alloc) {\n        cout&lt;&lt;\"Out of Memory\"&lt;&lt;endl;\n    }\n\n    delete w;\n    getch();\n    return 1;\n}\n</code></pre>\n<p>In this code, <code>delete w</code> does not call the overloaded <code>delete</code> operator when the destructor is there. If the destructor is omitted, the overloaded <code>delete</code> is called. Why is this so?</p>\n<p><strong>Output when ~Widget() is written</strong> </p>\n<blockquote>\n<p id=\"so_1108360_1108360_0\">operator new<br>\n  Out of Memory  </br></p>\n</blockquote>\n<p><strong>Output when ~Widget() is not written</strong> </p>\n<blockquote>\n<p id=\"so_1108360_1108360_1\">operator new<br>\n  Out of Memory<br>\n  operator delete  </br></br></p>\n</blockquote>\n", "Tags": "<c++><memory-management><destructor>", "OwnerUserId": "115057", "AnswerCount": "7"}});