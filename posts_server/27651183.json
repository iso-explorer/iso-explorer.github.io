post_cb({"27651369": {"ParentId": "27651183", "CommentCount": "0", "Body": "\n<p>The question is not about whether it will look for <code>boost::whatever</code>, but where it will find <code>boost</code> <em>itself</em>.</p>\n<p>If you have a nested namespace definition with the name <code>boost</code>, it will <em>hide</em> the global <code>boost</code> namespace at its point of declaration. The global <code>boost</code> namespace will be visible up until the point where <code>myNamespace::boost</code> is declared (\u00a73.3.2/2).</p>\n<blockquote>\n<p id=\"so_27651183_27651369_0\">[ Note: a name from an outer scope remains visible up to the point of declaration of the name that hides it. [ Example:</p>\n<pre class=\"lang-c++ prettyprint-override\"><code>const int i = 2;\n{ int i[i]; }\n</code></pre>\n<p id=\"so_27651183_27651369_1\">declares a block-scope array of two integers. \u2014 end example ] \u2014 end note ]</p>\n</blockquote>\n<p>So if you're calling <code>boost::whatever()</code> before the nested name <code>myNamespace::boost</code> is created, it will look for the global <code>boost</code> namespace. You can qualify the name with <code>::boost</code> if you always want it to find <code>boost</code> in the global namespace.</p>\n", "OwnerUserId": "701092", "PostTypeId": "2", "Id": "27651369", "Score": "2", "CreationDate": "2014-12-25T22:55:55.217", "LastActivityDate": "2014-12-25T22:55:55.217"}, "27651183": {"CommentCount": "1", "ViewCount": "89", "CreationDate": "2014-12-25T22:21:31.843", "LastActivityDate": "2014-12-26T00:49:21.820", "Title": "Namespace qualified names INSIDE a user namespace", "PostTypeId": "1", "Id": "27651183", "Score": "1", "Body": "<p>In C++, if I have</p>\n<pre><code>namespace myNamespace {\n    boost::whatever();\n}\n</code></pre>\n<p>will the compiler look for whatever() in the boost namespace or in myNamespace::boost?  </p>\n", "Tags": "<c++>", "OwnerUserId": "4394486", "AnswerCount": "3"}, "27651865": {"ParentId": "27651183", "LastEditDate": "2014-12-26T00:49:21.820", "CommentCount": "0", "CreationDate": "2014-12-26T00:42:34.217", "OwnerUserId": "1967498", "LastEditorUserId": "1967498", "PostTypeId": "2", "Id": "27651865", "Score": "2", "Body": "<p>First of all I think you mean this:</p>\n<pre><code>namespace myNamespace {\n     using boost::whatever; // NOT boost::whatever();\n}\n</code></pre>\n<p>Remember that C++ namespaces are mainly to avoid naming clashes not a design mechanism, which means when you are using a method of other namespaces in another one, you just call the original one and there is no copy in new namespace scope. So, when you call <code>myNamespace::whatever()</code>, compiler would choose <code>boost::whatever()</code> not <code>myNamespace::boost::whatever()</code> because there is no <code>boost</code> namespace declared inside <code>myNamespace</code>.</p>\n<p>For more details on namespaces you could see:\n<a href=\"http://en.cppreference.com/w/cpp/language/namespace\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/namespace</a></p>\n", "LastActivityDate": "2014-12-26T00:49:21.820"}, "bq_ids": {"n4140": {"so_27651183_27651369_0": {"section_id": 7050, "quality": 0.8181818181818182, "length": 9}, "so_27651183_27651369_1": {"section_id": 7050, "quality": 0.5555555555555556, "length": 5}}, "n3337": {"so_27651183_27651369_0": {"section_id": 6795, "quality": 0.8181818181818182, "length": 9}, "so_27651183_27651369_1": {"section_id": 6795, "quality": 0.5555555555555556, "length": 5}}, "n4659": {"so_27651183_27651369_0": {"section_id": 8547, "quality": 0.8181818181818182, "length": 9}, "so_27651183_27651369_1": {"section_id": 8547, "quality": 0.5555555555555556, "length": 5}}}, "27651234": {"ParentId": "27651183", "CommentCount": "0", "Body": "<p>Assuming you want to call a function using some qualification, you may end up using a local namespace rather than a global namespace:</p>\n<pre><code>#include &lt;iostream&gt;\nnamespace A { void f() { std::cout &lt;&lt; \"::A::f()\\n\"; } }\nnamespace B {\n    namespace A { void f() { std::cout &lt;&lt; \"::B::A::f()\\n\"; } }\n    void g() { A::f(); }\n    void h() { ::A::f(); }\n}\n\nint main() {\n    B::g();\n    B::h();\n}\n</code></pre>\n<p>If you want to make sure you are picking up a specific namespace you'll need to use absolute qualification as in <code>::A::f()</code>.</p>\n", "OwnerUserId": "1120273", "PostTypeId": "2", "Id": "27651234", "Score": "1", "CreationDate": "2014-12-25T22:30:18.547", "LastActivityDate": "2014-12-25T22:30:18.547"}});