post_cb({"4503219": {"ParentId": "4502728", "CommentCount": "0", "Body": "<p>The creation/destruction of objects in C++ is divided into two tasks: <strong><em>memory allocation/deallocation</em></strong> and <strong><em>object initialization/deinitialization</em></strong>. Memory allocation/deallocation is done very differently depending on an object's storage class (automatic, static, dynamic), object initialization/deinitialization is done using the object's type's constructor/destructor. </p>\n<p>You can customize object initialization/deinitialization by providing your own <strong><em>constructors</em></strong>/<em><strong>destructor</strong></em></p>. You can customize the allocation of <em>dynamically</em> allocated objects by overloading <strong><em><code>operator new</code></em></strong> and <strong><em><code>operator delete</code></em></strong> for this type. You can provide different versions of these operators for single objects and arrays (plus any number of additional overloads). \n<p>When you want to fine-tune the construction/destruction of objects of a specific type you first need to <strong><em>decide</em></strong> whether you want to fiddle with allocation/deallocation (of dynamically allocated objects) or with initialization/deinitialization. Your code mixes the two, violating one of C++' most fundamental design principle, all established praxis, every known C++ coding standard on this planet, and your fellow-workers' assumptions. </p>\n", "OwnerUserId": "140719", "PostTypeId": "2", "Id": "4503219", "Score": "1", "CreationDate": "2010-12-21T19:39:36.790", "LastActivityDate": "2010-12-21T19:39:36.790"}, "4503082": {"ParentId": "4502728", "PostTypeId": "2", "CommentCount": "14", "Body": "<h1>This does not work.</h1>\n<p>Your professor code will fail to initialize correctly in 3/4 of cases.</p>\n<ul>\n<li>It does not initialize objects correctly (new only affects pointers).</li>\n<li>The default constructor generated for tests has two modes.\n\n<ul>\n<li>Zero Initialization (which happens after new, but POD are set to zero)</li>\n<li>Default Initialization (POD are uninitialized)</li>\n</ul></li>\n</ul>\n<h3>Running Code  (comments added by hand)</h3>\n<pre><code>$ ./a.exe\nUsing Test::new\nUsing Test::new\nA Count(  0)               // zero initialized:  pointer leaked.\nA Pointer(0)\nB Count(  10)              // Works as expected because of default init.\nB Pointer(0xd20388)\nC Count(  1628884611)      // Uninitialized as new not used.\nC Pointer(0x611f0108)\nD Count(  0)               // Zero initialized because it is global (static storage duration)\nD Pointer(0)\n</code></pre>\n<h3>The Code</h3>\n<pre><code>#include &lt;new&gt;\n#include &lt;iostream&gt;\n#include &lt;stdlib.h&gt;\n\nclass test\n{\n    // code\n        int *a;\n        int n;\n    public:\n        void* operator new(size_t);\n\n        // Added dredded getter so we can print the values. (Quick Hack).\n        int* getA() const { return a;}\n        int  getN() const { return n;}\n};\n\nvoid* test::operator new(size_t size)\n{\n    std::cout &lt;&lt; \"Using Test::new\\n\";\n    test *p;\n    p=(test*)malloc(size);\n    p-&gt;n = 10;             // Fixed size for simple test.\n    p-&gt;a = new int[p-&gt;n];\n    return p;\n}\n\n// Objects that have static storage duration are zero initialized.\n// So here 'a' and 'n' will be set to 0\ntest d;\n\nint main()\n{\n    // Here a is zero initialized. Resulting in a and n being reset to 0\n    // Thus you have memory leaks as the reset happens after new has completed.\n    test* a = new test();\n    // Here b is default initialized.\n    // So the POD values are undefined (so the results are what you prof expects).\n    // But the standard does not gurantee this (though it will usually work because\n    // of the it should work as a side effect of the 'zero cost principle`)\n    test* b = new test;\n\n    // Here is a normal object.\n    // New is not called so its members are random.\n    test  c;\n\n    // Print out values\n    std::cout &lt;&lt; \"A Count(  \" &lt;&lt; a-&gt;getN() &lt;&lt; \")\\n\";\n    std::cout &lt;&lt; \"A Pointer(\" &lt;&lt; a-&gt;getA() &lt;&lt; \")\\n\";\n    std::cout &lt;&lt; \"B Count(  \" &lt;&lt; b-&gt;getN() &lt;&lt; \")\\n\";\n    std::cout &lt;&lt; \"B Pointer(\" &lt;&lt; b-&gt;getA() &lt;&lt; \")\\n\";\n    std::cout &lt;&lt; \"C Count(  \" &lt;&lt; c.getN() &lt;&lt; \")\\n\";\n    std::cout &lt;&lt; \"C Pointer(\" &lt;&lt; c.getA() &lt;&lt; \")\\n\";\n    std::cout &lt;&lt; \"D Count(  \" &lt;&lt; d.getN() &lt;&lt; \")\\n\";\n    std::cout &lt;&lt; \"D Pointer(\" &lt;&lt; d.getA() &lt;&lt; \")\\n\";\n}\n</code></pre>\n<h3>A valid example of what the professor failed to do:</h3>\n<pre><code>class test\n{\n    // code\n        int n;\n        int a[1];  // Notice the zero sized array.\n                   // The new will allocate enough memory for n locations.\n    public:\n        void* operator new(size_t);\n\n        // Added dredded getter so we can print the values. (Quick Hack).\n        int* getA() const { return a;}\n        int  getN() const { return n;}\n};\n\nvoid* test::operator new(size_t size)\n{\n    std::cout &lt;&lt; \"Using Test::new\\n\";\n\n    int  tmp;\n    std::cout &lt;&lt; How big?\\n\";\n    std::cin  &gt;&gt; tmp;\n\n    // This is a half arsed trick from the C days.\n    // It should probably still work.\n    // Note: This may be what the professor should have wrote (if he was using C)\n    //       This is totally horrible and whould not be used.\n    //       std::vector is a much:much:much better solution.\n    //       If anybody tries to convince you that an array is faster than a vector\n    //       The please read the linked question below where that myth is nailed into\n    //       its over sized coffin.\n    test *p =(test*)malloc(size + sizeof(int) * tmp);\n    p-&gt;n = tmp;\n    // p-&gt;a  = You can now overflow a upto n places.\n    return p;\n}\n</code></pre>\n<p><a href=\"https://stackoverflow.com/questions/3664272/stdvector-is-so-much-slower-than-plain-arrays\">Is std::vector so much slower than plain arrays?</a></p>\n", "OwnerUserId": "14065", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:55:28.180", "Id": "4503082", "Score": "0", "CreationDate": "2010-12-21T19:24:03.700", "LastActivityDate": "2010-12-21T20:28:45.587"}, "4503088": {"ParentId": "4502728", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Did some Standard checking.  Since <code>test</code> has private non-static members, it is not POD.  So <code>new test</code> default-initializes the object, and <code>new test()</code> value-initializes it.  As others have pointed out, value-initialization sets members to zero, which could come as a surprise here.</p>\n<p>Default-initialization uses the implicitly defined default constructor, which omits initializers for members <code>a</code> and <code>n</code>.</p>\n<blockquote>\n<p id=\"so_4502728_4503088_0\">12.6.2p4: After the call to a constructor for class <code>X</code> has completed, if a member of <code>X</code> is neither specified in the constructor's <em>mem-initializers</em>, nor default-initialized, nor value-initialized, nor given a value during execution of the body of the constructor, the member has indeterminate value.</p>\n</blockquote>\n<p>Not \"the value its memory had before the constructor, which is usually indeterminate.\"  The Standard directly says the members have indeterminate value if the constructor doesn't do anything about them.</p>\n<p>So given <code>test* p = new test;</code>, <code>p-&gt;a</code> and <code>p-&gt;n</code> have indeterminate value and any rvalue use of them results in Undefined Behavior.</p>\n", "OwnerUserId": "459640", "LastEditorUserId": "459640", "LastEditDate": "2010-12-21T19:29:25.403", "Id": "4503088", "Score": "2", "CreationDate": "2010-12-21T19:24:19.137", "LastActivityDate": "2010-12-21T19:29:25.403"}, "4502802": {"ParentId": "4502728", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>As you show this is wrong. You can also see how easy it is to get this wrong. </p>\n<p>There usually isn't any reason for it unless you are trying to manage your own memory allocations and in a C++ environment you would be better off learning the <a href=\"http://www.sgi.com/tech/stl/\" rel=\"nofollow\">STL</a> and write custom allocators.</p>\n", "OwnerUserId": "147373", "LastEditorUserId": "147373", "LastEditDate": "2011-01-04T13:24:55.113", "Id": "4502802", "Score": "-2", "CreationDate": "2010-12-21T18:48:55.787", "LastActivityDate": "2011-01-04T13:24:55.113"}, "4503460": {"ParentId": "4502728", "CommentCount": "0", "Body": "<p>Your professor is completely misunderstanding the purpose of <code>operator new</code> whose only task is to allocate as much memory as was asked and to return a <code>void*</code> to it.</p>\n<p>After that the constructor is called to initialize the object at that memory location. This is not up to the programmer to avoid.</p>\n<p>As the class doesn't have a user-defined constructor, the fields are supposed to be uninitialized, and in such a case the compiler has probably freedom to initialize them to some magic value in order to help finding use of uninitialized values (e.g for debug builds). That would defeat the extra work done by the overloaded operator.</p>\n<p>Another case where the extra work will be wasted is when using value-initialization: <code>new test();</code></p>\n", "OwnerUserId": "155693", "PostTypeId": "2", "Id": "4503460", "Score": "1", "CreationDate": "2010-12-21T20:12:52.187", "LastActivityDate": "2010-12-21T20:12:52.187"}, "4502728": {"CommentCount": "19", "ViewCount": "390", "PostTypeId": "1", "LastEditorUserId": "527114", "CreationDate": "2010-12-21T18:40:36.783", "LastActivityDate": "2011-01-04T13:24:55.113", "Title": "Accessing an object in operator new", "AcceptedAnswerId": "4502807", "LastEditDate": "2010-12-21T18:47:16.747", "Id": "4502728", "Score": "0", "Body": "<p>My professor in C++ has shown us this as an example in overloading the operator new (which i believe is wrong):</p>\n<pre><code>class test {\n    // code\n    int *a;\n    int n;\npublic:\n    void* operator new(size_t);\n};\n\nvoid* test::operator new(size_t size) {\n    test *p;\n    p=(test*)malloc(size);\n    cout &lt;&lt; \"Input the size of array = ?\";\n    cin &gt;&gt; p-&gt;n;\n    p-&gt;a = new int[p-&gt;n];\n    return p;\n}\n</code></pre>\n<p>Is this right?</p>\n", "Tags": "<c++><new-operator>", "OwnerUserId": "527114", "AnswerCount": "7"}, "4502807": {"ParentId": "4502728", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>It's definitely \"not right\", in the sense that it's giving me the creeps.</p>\n<p>Since <code>test</code> has no user-declared constructors, I think it could work provided that the instance of <code>test</code> isn't value-initialized (which would clear the pointer). And provided that you write the corresponding <code>operator delete</code>.</p>\n<p>It's clearly a silly example, though - user interaction inside an overloaded <code>operator new</code>? And what if an instance of <code>test</code> is created on the stack? Or copied? Or created with <code>test *tp = new test();</code> in C++03? Or placement new? Hardly user-friendly.</p>\n<p>It's <em>constructors</em> which must be used to establish class invariants (such as \"I have an array to use\"), because that's the only way to cover all those cases. So allocating an array like that is the kind of thing that should be done in a constructor, not in <code>operator new</code>. Or better yet, use a <code>vector</code> instead.</p>\n<p>As far as the standard is concerned - I think that since the class is non-POD the implementation is allowed to scribble all over the data in between calling <code>operator new</code> and returning it to the user, so this is not guaranteed to work even when used carefully. I'm not entirely sure, though. Conceivably your professor has run it (perhaps many years ago when he first wrote the course), and if so it worked on his machine. There's no obvious reason why an implementation would want to do anything to the memory in the specific case of this class.</p>\n<blockquote>\n<p id=\"so_4502728_4502807_0\">I believe that is \"wrong\" because he\n  access the object before the\n  constructor.</p>\n</blockquote>\n<p>I think you're correct on this point too - casting the pointer returned from <code>malloc</code> to <code>test*</code> and accessing members is UB, since the class <code>test</code> is non-POD (because it has private non-static data members) and the memory does not contain a constructed instance of the class. Again, though, there's no reason I can immediately think of why an implementation would want to do anything that stops it working, so I'm not surprised if in practice it stores the intended value in the intended location on my machine.</p>\n", "OwnerUserId": "13005", "LastEditorUserId": "13005", "LastEditDate": "2010-12-21T19:59:24.950", "Id": "4502807", "Score": "2", "CreationDate": "2010-12-21T18:49:29.420", "LastActivityDate": "2010-12-21T19:59:24.950"}, "bq_ids": {"n4140": {"so_4502728_4503088_0": {"section_id": 435, "quality": 0.68, "length": 17}, "so_4502728_4502807_0": {"section_id": 444, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_4502728_4503088_0": {"section_id": 427, "quality": 0.68, "length": 17}, "so_4502728_4502807_0": {"section_id": 435, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_4502728_4503088_0": {"section_id": 454, "quality": 0.68, "length": 17}, "so_4502728_4502807_0": {"section_id": 467, "quality": 0.5714285714285714, "length": 4}}}, "4503664": {"ParentId": "4502728", "CommentCount": "0", "Body": "<p>This is very bad code because it takes initialization code that should be part of a constructor and puts it in <code>operator new</code> which should only allocate new memory.</p>\n<p>The expression <code>new test</code> may leak memory (that allocated by <code>p-&gt;a = new int[p-&gt;n];</code>) and the expression <code>new test()</code> definitely will leak memory. There is nothing in the standard that prevents the implementation zeroing, or setting to an alternate value, the memory returned by a custom <code>operator new</code> before that memory is initialized with an object even if the subsequent initialization wouldn't ordinarily touch the memory again. If the <code>test</code> object is <em>value-initialized</em> the leak is guaranteed.</p>\n<p>There is also no easy way to correctly deallocate a test allocated with <code>new test</code>. There is no matching <code>operator delete</code> so the expression <code>delete t;</code> will do the wrong thing global <code>operator delete</code> to be called on memory allocated with <code>malloc</code>.</p>\n", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "4503664", "Score": "1", "CreationDate": "2010-12-21T20:36:48.803", "LastActivityDate": "2010-12-21T20:36:48.803"}});