post_cb({"18129650": {"ParentId": "18128899", "CommentCount": "4", "CreationDate": "2013-08-08T15:10:34.370", "OwnerUserId": "1593860", "PostTypeId": "2", "Id": "18129650", "Score": "4", "Body": "<p>C has no notion of namespaces. When you write <code>#include &lt;math.h&gt;</code> all the names declared in the header go into the global namespace, and you need to write <code>isnan</code>.</p>\n<p>C++ has namespaces. Still, when you write <code>#include &lt;math.h&gt;</code> all the names declared in the header go into the global namespace, and you need to write <code>isnan</code>, just like in C.</p>\n<p>In addition, when you write <code>#include &lt;cmath&gt;</code> all the names declared in the header go into the namespace <code>std</code>, and you need to write <code>std::isnan</code>.</p>\n<p>Further, C++ implementations are <strong>allowed</strong> to also go the other way, with <code>#include &lt;math.h&gt;</code> putting the names into <code>std</code> <strong>as well as</strong> in the global namespace, and with <code>#include &lt;cmath&gt;</code> putting the names into the global namespace <strong>as well as</strong> in <code>std</code>. Don't rely on this; code that does so is not portable. This is a concession to implementors to make things easier; what it really means is that if you use <code>#include &lt;cmath&gt;</code> you cannot assume that there will be no <code>isnan</code> in the global namespace and that if you use <code>#include &lt;math.h&gt;</code> you cannot assume that there will be no <code>isnan</code> in <code>std</code>.</p>\n", "LastActivityDate": "2013-08-08T15:10:34.370"}, "18129007": {"ParentId": "18128899", "PostTypeId": "2", "CommentCount": "6", "CreationDate": "2013-08-08T14:43:41.997", "Score": "12", "LastEditorUserId": "743214", "LastEditDate": "2013-08-08T15:19:52.560", "Id": "18129007", "OwnerUserId": "743214", "Body": "<p>It depends on which header you include. If you include the C header <code>&lt;math.h&gt;</code> (which is part of C++, albeit marked as deprecated), then you can use the unqualified C functions, like <code>isnan</code>. If you on the other hand include the C++ header <code>&lt;cmath&gt;</code>, you are only <em>guaranteed</em> that it brings all the functions from <code>&lt;math.h&gt;</code> into the <code>std</code> namespace and thus you have to properly qualify them, like <code>std::isnan</code> (or use some kind of <code>using</code> directive). Unfortunately an implementation is <em>allowed</em> but <em>not required</em> to bring those functions into the global namespace, too, when including <code>&lt;cmath&gt;</code> (and thus it is one of the many <em>\"works on my machine\"</em>-incidences of C++ and the reason why many people write code like you just tried to compile unsuccessfully).</p>\n<p>So to sum up: Either include <code>&lt;math.h&gt;</code> and use <code>isnan</code> or include <code>&lt;cmath&gt;</code> and use <code>std::isnan</code>, everything else is non-portable. Of course all this applies to any other C header and its respective C++ version, too.</p>\n<p><strong>EDIT:</strong> It should be noted though, that this particular function <code>isnan</code> is only supported since C++11 and wasn't available in C++98 at all (which may be part of your confusion). But this doesn't change anything in this situation because in C++98 neither <code>&lt;cmath&gt;</code> nor <code>&lt;math.h&gt;</code> (which was the actual C89/C90 header back then and not the C99 header that C++11 includes) had this function, since they're always in-sync. So what this library from your question maybe tried was to use C++98 while taking the <code>isnan</code> function from a different C99 implementation (which isn't a particularly good idea, as it might conflict with the C89/C90 parts of the C++ implementation, never even tried this though).</p>\n", "LastActivityDate": "2013-08-08T15:19:52.560"}, "18128988": {"ParentId": "18128899", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2013-08-08T14:42:42.953", "Score": "2", "LastEditorUserId": "1009479", "LastEditDate": "2013-08-08T14:48:24.617", "Id": "18128988", "OwnerUserId": "1009479", "Body": "<p>That's because <code>isnan</code> is from C. Using different type of <code>include</code> will lead to different results. Take <code>isnan</code> from C header <code>&lt;math.h&gt;</code> as an example:</p>\n<p>If you use <code>#include &lt;cmath&gt;</code>, it will be put in the <code>std</code> namespace.</p>\n<p>If you use <code>#include &lt;math.h&gt;</code>, it will be put in the global namespace.</p>\n<p>C++11 D.5 C standard library headers</p>\n<blockquote>\n<p id=\"so_18128899_18128988_0\">Every C header, each of which has a name of the form name.h, behaves as if each name placed in the standard library namespace by the corresponding cname header is placed within the global namespace scope. It is unspecified whether these names are first declared or defined within namespace scope (3.3.6) of the namespace std and are then injected into the global namespace scope by explicit using-declarations (7.3.3).</p>\n<p id=\"so_18128899_18128988_1\">[ Example: The header  assuredly provides its declarations and definitions within the namespace std. It may also provide these names within the global namespace. The header  assuredly provides the same declarations and definitions within the global namespace, much as in the C Standard. It may also provide these names within the namespace std. \u2014end example ]</p>\n</blockquote>\n", "LastActivityDate": "2013-08-08T14:48:24.617"}, "bq_ids": {"n4140": {"so_18128899_18128988_0": {"section_id": 4907, "quality": 0.926829268292683, "length": 38}, "so_18128899_18128988_1": {"section_id": 4908, "quality": 0.8461538461538461, "length": 33}}, "n3337": {"so_18128899_18128988_0": {"section_id": 4702, "quality": 0.926829268292683, "length": 38}, "so_18128899_18128988_1": {"section_id": 4703, "quality": 0.8461538461538461, "length": 33}}, "n4659": {"so_18128899_18128988_0": {"section_id": 6316, "quality": 0.926829268292683, "length": 38}, "so_18128899_18128988_1": {"section_id": 6317, "quality": 0.8461538461538461, "length": 33}}}, "18128899": {"CommentCount": "3", "AcceptedAnswerId": "18129007", "PostTypeId": "1", "LastEditorUserId": "2436175", "CreationDate": "2013-08-08T14:38:35.843", "LastActivityDate": "2013-08-08T15:26:36.987", "LastEditDate": "2013-08-08T15:26:36.987", "ViewCount": "9897", "FavoriteCount": "1", "Title": "Is isnan in the std:: namespace? More in general, when is std:: necessary, optional or to be avoided?", "Id": "18128899", "Score": "6", "Body": "<p>With Mingw 4.7.2, I have a library that doesn't compile because of a call to <code>isnan</code>.\nThe compiler says \"everything will be fine\" if I use <code>std::isnan</code>, and indeed I manage to compile my file.</p>\n<p>But if I check <a href=\"http://www.cplusplus.com/reference/cmath/isnan/\" rel=\"nofollow\">here</a> (<em>Edit:</em> but maybe I should have checked also <a href=\"http://en.cppreference.com/w/cpp/numeric/math/isnan\" rel=\"nofollow\">here</a> :-) ), the <code>std::</code> doesn't seem to be necessary. If I add it, will the file be portable?</p>\n<p>More in general, for each case is there a general way to understand when putting <code>std::</code> is necessary (for portability), optional or to be avoided?</p>\n<p><strong>Edit</strong></p>\n<p>Indeed among the origins of the problem is that there are multiple header inclusions, and some of the included headers include <code>&lt;cmath&gt;</code>, while this cpp file tries to include <code>&lt;math.h&gt;</code> (when <code>&lt;cmath&gt;</code> has already been included).</p>\n", "Tags": "<c++><mingw><portability><c++98>", "OwnerUserId": "2436175", "AnswerCount": "3"}});