post_cb({"bq_ids": {"n4140": {"so_27735754_27735989_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 710}}, "n3337": {"so_27735754_27735989_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 699}}, "n4659": {"so_27735754_27735989_0": {"length": 18, "quality": 0.8571428571428571, "section_id": 739}}}, "27735754": {"ViewCount": "696", "Body": "<p>Assume there is a class A that contains a vector of ints. Now assume that a vector of A's is created. If a reallocation of an A object occurs (so the vector object is moved) due to a push_back for example, will pointers to the ints themselves remain valid? Is this guaranteed?</p>\n<p>To clarify:</p>\n<pre><code>class A {\npublic:\n    A() {};\n    std::vector&lt;int&gt; a = {1,2,3,4,5,6,7,8,9};\n};\n\nint main()\n{\n    std::vector&lt;A&gt; aVec(2);\n\n    int *x1 = &amp;(aVec[1].a[2]);\n    A *x2 = &amp;aVec[1];\n    std::cout &lt;&lt; x1 &lt;&lt; \" - \" &lt;&lt; x2 &lt;&lt; \" - \" &lt;&lt; aVec.capacity() &lt;&lt; \"\\n\";\n\n    aVec.resize(30);\n\n    int *y1 = &amp;(aVec[1].a[2]);\n    A *y2 = &amp;aVec[1];\n    std::cout &lt;&lt; y1 &lt;&lt; \" - \" &lt;&lt; y2 &lt;&lt; \" - \" &lt;&lt; aVec.capacity() &lt;&lt; \"\\n\";\n}\n</code></pre>\n<p>Running this code gives this:</p>\n<pre><code>0x1810088 - 0x1810028 - 2\n0x1810088 - 0x18100c8 - 30\n</code></pre>\n<p>so it shows that the pointers remain valid. But I want to make sure that this is guaranteed and not just a chance thing. I'm leaning towards saying that this is guaranteed since the vector's internal data is dynamically allocated, but, again, just wanted to check.</p>\n<p>I have looked here [ <a href=\"https://stackoverflow.com/q/6438086/4076418\">Iterator invalidation rules</a> ] but it doesn't consider this specific case (i.e. reallocation of the vector object itself).</p>\n<p>UPDATE:</p>\n<p>I tried this to check what I wrote in the comments for Jarod42's answer:</p>\n<pre><code>std::vector&lt;std::vector&lt;int&gt;&gt; aVec(2, {1,2,3});\n\nint *x1 = &amp;(aVec[1][2]);\nstd::vector&lt;int&gt; *x2 = &amp;aVec[1];\nstd::cout &lt;&lt; x1 &lt;&lt; \" - \" &lt;&lt; x2 &lt;&lt; \" - \" &lt;&lt; aVec.capacity() &lt;&lt; \"\\n\";\n\naVec.resize(30);\n\nint *y1 = &amp;(aVec[1][2]);\nstd::vector&lt;int&gt; *y2 = &amp;aVec[1];\nstd::cout &lt;&lt; y1 &lt;&lt; \" - \" &lt;&lt; y2 &lt;&lt; \" - \" &lt;&lt; aVec.capacity() &lt;&lt; \"\\n\";\n</code></pre>\n<p>and got this:</p>\n<pre><code>0x16f0098 - 0x16f0048 - 2\n0x16f0098 - 0x16f00c8 - 30\n</code></pre>\n<p>which is strange to me. I expected x2==y2.</p>\n", "AcceptedAnswerId": "27736068", "Title": "Validity of pointers to internal data structure when reallocating a std::vector object", "CreationDate": "2015-01-01T23:40:45.923", "Id": "27735754", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:58:25.357", "LastEditorUserId": "-1", "LastActivityDate": "2015-01-02T02:50:35.797", "Score": "13", "OwnerUserId": "4076418", "Tags": "<c++><vector><stl>", "AnswerCount": "3"}, "27735843": {"Id": "27735843", "PostTypeId": "2", "Body": "<p>It would depend of your move constructor of <code>A</code>.\nbut as it (*), it will use move constructor of <code>vector&lt;int&gt;</code> for <code>a</code>, and according to <a href=\"http://www.cplusplus.com/reference/vector/vector/vector/\" rel=\"nofollow\">http://www.cplusplus.com/reference/vector/vector/vector/</a></p>\n<blockquote>\n<p id=\"so_27735754_27735843_0\">[..] no elements are constructed (their ownership is directly transferred).</p>\n</blockquote>\n<p>So pointers to the ints themselves remain valid.</p>\n<p><strong>Edit</strong>: (*) <code>A</code> should be <code>noexcept</code> for that, and <code>std::vector</code> is not guaranteed to be <code>noexcept</code>.</p>\n", "LastEditorUserId": "2684539", "LastActivityDate": "2015-01-02T00:45:34.897", "Score": "4", "CreationDate": "2015-01-01T23:54:14.790", "ParentId": "27735754", "CommentCount": "2", "OwnerUserId": "2684539", "LastEditDate": "2015-01-02T00:45:34.897"}, "27735989": {"Id": "27735989", "PostTypeId": "2", "Body": "<p>Your <code>A</code> elements will be moved where possible, and <code>A</code> has an implicit move constructor and implicit move assignment operator, so the member vector will also be moved.</p>\n<p>Now, moving a vector is not necessarily equivalent to <code>a.swap(b)</code>, so you cannot rely on the implicit move functions if you want a <em>guarantee</em>; you could write your own.</p>\n<p>But whether you guarantee it yourself or obtain a guarantee by looking up the code of your particular standard library implementation, you can be assured that pointers and iterators to the individual elements shall remain valid:</p>\n<blockquote>\n<p id=\"so_27735754_27735989_0\"><code>[C++11: 23.2.1/8]:</code> The expression <code>a.swap(b)</code>, for containers <code>a</code> and <code>b</code> of a standard container type other than <code>array</code>, shall exchange the values of <code>a</code> and <code>b</code> without invoking any move, copy, or swap operations on the individual container elements. <em>[..]</em></p>\n</blockquote>\n", "LastActivityDate": "2015-01-02T00:18:53.553", "CommentCount": "0", "CreationDate": "2015-01-02T00:18:53.553", "ParentId": "27735754", "Score": "3", "OwnerUserId": "560648"}, "27736068": {"Id": "27736068", "PostTypeId": "2", "Body": "<p>Unfortunately this is not guaranteed.  That being said, it is the case that all 3 current implementations (libc++, libstdc++ and VS-2015) appear to guarantee it.  The question is whether or not the move constructor for <code>A</code> is noexcept:</p>\n<pre><code>static_assert(std::is_nothrow_move_constructible&lt;A&gt;::value, \"\");\n</code></pre>\n<p>The move constructor for <code>A</code> is compiler supplied, and thus dependent upon the move constructor of <code>std::vector&lt;int&gt;</code>.  If the move constructor of <code>std::vector&lt;int&gt;</code> is noexcept, then the move constructor for <code>A</code> is noexcept, else it is not.</p>\n<p>The current draft N4296 does not mark the move constructor for <code>vector</code> as noexcept.  However it allows implementations to do so.</p>\n<p>This line:</p>\n<pre><code>aVec.resize(30);\n</code></pre>\n<p>Will use <code>A</code>'s move constructor if that move constructor is noexcept, else it will use <code>A</code>'s copy constructor.  If it uses <code>A</code>'s copy constructor, the location of the ints will change.  If it uses <code>A</code>'s move constructor, the location of the ints will remain stable.</p>\n<p>libc++ and libstdc++ mark <code>vector</code>'s move constructor as noexcept.  And thus give <code>A</code> a noexcept move constructor.</p>\n<p>VS-2015 says that <code>A</code> does not have a noexcept move constructor:</p>\n<pre><code>static_assert(std::is_nothrow_move_constructible&lt;A&gt;::value, \"\");\n</code></pre>\n<p>does not compile.</p>\n<p>Nevertheless, VS-2015 does not reallocate the ints to a new address, and thus it looks like it is not conforming to the C++11 spec.</p>\n<p>If one changes the libc++ headers such that the <code>vector</code> move constructor is not marked noexcept, then the ints do indeed reallocate.</p>\n<p>Recent discussions on the committee indicate that everyone is in favor of marking the move constructor of <code>vector</code> noexcept (and maybe <code>basic_string</code> too, but not other containers).  So it is possible that a future standard will guarantee the stability you seek.  In the meantime, if:</p>\n<pre><code>static_assert(std::is_nothrow_move_constructible&lt;A&gt;::value, \"\");\n</code></pre>\n<p>compiles, then you have your guarantee, else you don't.</p>\n<p><strong>Update</strong></p>\n<p>The reason that <code>x2 != y2</code> in the update is that these are the addresses of <code>vector&lt;int&gt;</code> in the <code>vector&lt;vector&lt;int&gt;&gt;</code>.  These inner elements had to find a new (bigger) buffer to live in, just the same as if the inner element was <code>int</code>.  But unlike <code>int</code>, the inner element <code>vector&lt;int&gt;</code> could move there with a move constructor (<code>int</code> had to copy).  But whether moving or copying, the address of the inner element had to change (from the small old buffer to the big new buffer).  This behavior is consistent with the original part of the question (where the inner element is also shown to change addresses).</p>\n<p>And yes, <a href=\"http://cplusplus.github.io/LWG/lwg-active.html#2321\" rel=\"nofollow\">LWG 2321</a> is involved, though not a contentious point.  In my answer I've already assumed <a href=\"http://cplusplus.github.io/LWG/lwg-active.html#2321\" rel=\"nofollow\">LWG 2321</a> has passed.  There's really no other way for things to happen aside from overly eager debugging iterators to gratuitously (and incorrectly) invalidate themselves.  Non-debugging iterators would never invalidate, and neither will pointers or references.</p>\n<p>Wish I had the ability to easily create an animation with arrows to buffers.  That would be really clear.  I just don't know how to easily do that in the time I have available.</p>\n", "LastEditorUserId": "576911", "LastActivityDate": "2015-01-02T02:50:35.797", "Score": "10", "CreationDate": "2015-01-02T00:30:54.803", "ParentId": "27735754", "CommentCount": "6", "OwnerUserId": "576911", "LastEditDate": "2015-01-02T02:50:35.797"}});