post_cb({"44445351": {"ParentId": "44429408", "PostTypeId": "2", "CommentCount": "8", "CreationDate": "2017-06-08T20:52:25.587", "Score": "6", "LastEditorUserId": "2756719", "LastEditDate": "2017-06-08T22:37:23.257", "Id": "44445351", "OwnerUserId": "2756719", "Body": "<p>Barry got #1 right. Your #2 hit a corner case: captureless nongeneric lambdas have an implicit conversion to function pointer, which got used in the mismatch case. That is, given </p>\n<pre><code>struct foo : foo_int, foo_str {\n    using foo_int::operator();\n    //using foo_str::operator();\n    foo(): foo_int(print_int), foo_str(print_str) {}\n} f;\n\nusing fptr_str = void(*)(const char*);\n</code></pre>\n<p><code>f(\"hello\")</code> is equivalent to <code>f.operator fptr_str()(\"hello\")</code>, converting the <code>foo</code> to an pointer-to-function and calling that. If you compile at <code>-O0</code> you can actually see the call to the conversion function in the assembly before it gets optimized away. Put an <em>init-capture</em> in <code>print_str</code>, and you'll see an error since the implicit conversion goes away.</p>\n<p>For more, see <a href=\"https://timsong-cpp.github.io/cppwp/over.call.object\" rel=\"noreferrer\">[over.call.object]</a>.</p>\n", "LastActivityDate": "2017-06-08T22:37:23.257"}, "44429408": {"CommentCount": "0", "AcceptedAnswerId": "44445351", "PostTypeId": "1", "LastEditorUserId": "2805305", "CreationDate": "2017-06-08T07:34:27.310", "LastActivityDate": "2017-06-08T22:37:23.257", "LastEditDate": "2017-06-08T08:57:39.927", "ViewCount": "551", "FavoriteCount": "3", "Title": "Overload resolution for multiply inherited operator()", "Id": "44429408", "Score": "22", "Body": "<p>First, consider this C++ code:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nstruct foo_int {\n    void print(int x) {\n        printf(\"int %d\\n\", x);\n    }    \n};\n\nstruct foo_str {\n    void print(const char* x) {\n        printf(\"str %s\\n\", x);\n    }    \n};\n\nstruct foo : foo_int, foo_str {\n    //using foo_int::print;\n    //using foo_str::print;\n};\n\nint main() {\n    foo f;\n    f.print(123);\n    f.print(\"abc\");\n}\n</code></pre>\n<p>As expected according to the Standard, this fails to compile, because <code>print</code> is considered separately in each base class for the purpose of overload resolution, and thus the calls are ambiguous. This is the case on Clang (4.0), gcc (6.3) and MSVC (17.0) - see godbolt results <a href=\"https://godbolt.org/g/XoFi4m\" rel=\"noreferrer\">here</a>.</p>\n<p>Now consider the following snippet, the sole difference of which is that we use <code>operator()</code> instead of <code>print</code>:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nstruct foo_int {\n    void operator() (int x) {\n        printf(\"int %d\\n\", x);\n    }    \n};\n\nstruct foo_str {\n    void operator() (const char* x) {\n        printf(\"str %s\\n\", x);\n    }    \n};\n\nstruct foo : foo_int, foo_str {\n    //using foo_int::operator();\n    //using foo_str::operator();\n};\n\nint main() {\n    foo f;\n    f(123);\n    f(\"abc\");\n}\n</code></pre>\n<p>I would expect the results to be identical to the previous case, but <a href=\"https://godbolt.org/g/4bksih\" rel=\"noreferrer\">it is not the case</a> - while gcc still complains, Clang and MSVC can compile this fine!</p>\n<p>Question #1: who is correct in this case? I expect it to be gcc, but the fact that two other unrelated compilers give a consistently different result here makes me wonder whether I'm missing something in the Standard, and things are different for operators when they're not invoked using function syntax.</p>\n<p>Also note that if you only uncomment one of the <code>using</code> declarations, but not the other, then all three compilers will fail to compile, because they will only consider the function brought in by <code>using</code> during overload resolution, and thus one of the calls will fail due to type mismatch. Remember this; we'll get back to it later.</p>\n<p>Now consider the following code:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nauto print_int = [](int x) {\n    printf(\"int %d\\n\", x);\n};\ntypedef decltype(print_int) foo_int;\n\nauto print_str = [](const char* x) {\n    printf(\"str %s\\n\", x);\n};\ntypedef decltype(print_str) foo_str;\n\nstruct foo : foo_int, foo_str {\n    //using foo_int::operator();\n    //using foo_str::operator();\n    foo(): foo_int(print_int), foo_str(print_str) {}\n};\n\nint main() {\n    foo f;\n    f(123);\n    f(\"foo\");\n}\n</code></pre>\n<p>Again, same as before, except now we don't define <code>operator()</code> explicitly, but instead get it from a lambda type. Again, you'd expect the results to be consistent with the previous snippet; and this is true for the case where <a href=\"https://godbolt.org/g/nvI6Of\" rel=\"noreferrer\">both <code>using</code> declarations are commented out</a>, or if <a href=\"https://godbolt.org/g/YDJOdt\" rel=\"noreferrer\">both are uncommented</a>. But if you only comment out one but not the other, things are <a href=\"https://godbolt.org/g/WjzT35\" rel=\"noreferrer\">suddenly different again</a>: now only MSVC complains as I would expect it to, while Clang and gcc both think it's fine - and use both inherited members for overload resolution, despite only one being brought in by <code>using</code>!</p>\n<p>Question #2: who is correct in this case? Again, I'd expect it to be MSVC, but then why do both Clang and gcc disagree? And, more importantly, why this is different from the previous snippet? I would expect the lambda type to behave exactly the same as a manually defined type with overloaded <code>operator()</code>...</p>\n", "Tags": "<c++><lambda><language-lawyer><multiple-inheritance><overload-resolution>", "OwnerUserId": "111335", "AnswerCount": "3"}, "44436678": {"ParentId": "44429408", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2017-06-08T13:09:14.030", "Score": "3", "LastEditorUserId": "2069064", "LastEditDate": "2017-06-08T13:14:29.663", "Id": "44436678", "OwnerUserId": "2069064", "Body": "<p>The rule for name lookup in base classes of a class <code>C</code> only happens if <code>C</code> itself doesn't directly contain the name is <a href=\"http://eel.is/c++draft/class.member.lookup#6\" rel=\"nofollow noreferrer\">[class.member.lookup]/6</a>:</p>\n<blockquote>\n<p id=\"so_44429408_44436678_0\">The following steps define the result of merging lookup set <code>S(f,Bi)</code>\n   into the intermediate <code>S(f,C)</code>:  </p>\n<ul>\n<li><p id=\"so_44429408_44436678_1\">If each of the subobject members of S(f,Bi) is a base class subobject of at least one of the subobject members of S(f,C), or if S(f,Bi) is empty, S(f,C) is unchanged and the merge is complete. Conversely, if each of the subobject members of S(f,C) is a base class subobject of at least one of the subobject members of S(f,Bi), or if S(f,C) is empty, the new S(f,C) is a copy of S(f,Bi).</p></li>\n<li><p id=\"so_44429408_44436678_2\"><strong>Otherwise, if the declaration sets of S(f,Bi) and S(f,C) differ, the merge is ambiguous</strong>: the new S(f,C) is a lookup set with an invalid declaration set and the union of the subobject sets. In subsequent merges, an invalid declaration set is considered different from any other.</p></li>\n<li><p id=\"so_44429408_44436678_3\">Otherwise, the new S(f,C) is a lookup set with the shared set of declarations and the union of the subobject sets.</p></li>\n</ul>\n</blockquote>\n<p>If we have two base classes, that each declare the same name, that the derived class does not bring in with a using-declaration, lookup of that name in the derived class would run afoul of that second bullet point and the lookup should fail. All of your examples are basically the same in this regard. </p>\n<blockquote>\n<p id=\"so_44429408_44436678_4\">Question #1: who is correct in this case? </p>\n</blockquote>\n<p>gcc is correct. The only difference between <code>print</code> and <code>operator()</code> is the name that we're looking up. </p>\n<blockquote>\n<p id=\"so_44429408_44436678_5\">Question #2: who is correct in this case? </p>\n</blockquote>\n<p>This is the same question as #1 - except we have lambdas (which give you unnamed class types with overload <code>operator()</code>) instead of explicit class types. The code should be ill-formed for the same reason. At least for gcc, this is <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=58820\" rel=\"nofollow noreferrer\">bug 58820</a>.</p>\n", "LastActivityDate": "2017-06-08T13:14:29.663"}, "bq_ids": {"n4140": {"so_44429408_44436678_3": {"section_id": 6994, "quality": 1.0, "length": 11}, "so_44429408_44436678_2": {"section_id": 6994, "quality": 0.96, "length": 24}, "so_44429408_44437919_0": {"section_id": 662, "quality": 1.0, "length": 15}, "so_44429408_44436678_0": {"section_id": 6994, "quality": 0.8333333333333334, "length": 10}, "so_44429408_44436678_1": {"section_id": 6994, "quality": 0.8918918918918919, "length": 33}, "so_44429408_44437919_2": {"section_id": 662, "quality": 0.9411764705882353, "length": 32}}, "n3337": {"so_44429408_44436678_3": {"section_id": 6740, "quality": 1.0, "length": 11}, "so_44429408_44436678_2": {"section_id": 6740, "quality": 0.96, "length": 24}, "so_44429408_44437919_0": {"section_id": 652, "quality": 1.0, "length": 15}, "so_44429408_44436678_0": {"section_id": 6740, "quality": 0.8333333333333334, "length": 10}, "so_44429408_44436678_1": {"section_id": 6740, "quality": 0.8918918918918919, "length": 33}, "so_44429408_44437919_2": {"section_id": 652, "quality": 0.9411764705882353, "length": 32}}, "n4659": {"so_44429408_44436678_3": {"section_id": 8492, "quality": 1.0, "length": 11}, "so_44429408_44436678_2": {"section_id": 8492, "quality": 0.96, "length": 24}, "so_44429408_44437919_0": {"section_id": 690, "quality": 1.0, "length": 15}, "so_44429408_44436678_0": {"section_id": 8492, "quality": 0.8333333333333334, "length": 10}, "so_44429408_44436678_1": {"section_id": 8492, "quality": 0.8918918918918919, "length": 33}, "so_44429408_44437919_2": {"section_id": 690, "quality": 0.9411764705882353, "length": 32}}}, "44437919": {"ParentId": "44429408", "CommentCount": "7", "CreationDate": "2017-06-08T14:03:09.403", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "44437919", "Score": "0", "Body": "<p>Your analysis of the first code is incorrect. There is no overload resolution.</p>\n<p>The <em>name lookup</em> process occurs wholly before overload resolution.  Name lookup determines which scope an <em>id-expression</em> is resolved to. </p>\n<p>If a unique scope is found via the name look-up rules, <em>then</em> overload resolution begins: all instances of that name within that scope form the overload set.</p>\n<p>But in your code, name lookup fails. The name is not declared in <code>foo</code>, so base classes are searched. If the name is found in more than one immediate base class then the program is ill-formed and the error message describes it as an ambiguous name.</p>\n<hr>\n<p>The name lookup rules do not have special cases for overloaded operators. You should find that the code:</p>\n<pre><code>f.operator()(123);\n</code></pre>\n<p>fails for the same reason as <code>f.print</code> failed.  However, there is another issue in your second code.  <code>f(123)</code> is NOT defined as always meaning <code>f.operator()(123);</code>.  In fact the definition in C++14 is in [over.call]:</p>\n<blockquote>\n<p id=\"so_44429408_44437919_0\"><code>operator()</code> shall be a non-static member function with an arbitrary number of parameters. It can have default arguments. It implements the function call syntax</p>\n<p id=\"so_44429408_44437919_1\">postfix-expression ( expression-list opt )</p>\n<p id=\"so_44429408_44437919_2\">where the postfix-expression evaluates to a class object and the possibly empty expression-list matches the parameter list of an <code>operator()</code> member function of the class. Thus, a call <code>x(arg1,...)</code> is interpreted as <code>x.operator()(arg1, ...)</code> for a class object x of type T if <code>T::operator()(T1, T2, T3)</code> exists and if the operator is selected as the best match function by the overload resolution mechanism (13.3.3).</p>\n</blockquote>\n<p>This actually seems an imprecise specification to me so I can understand different compilers coming out with different results.  What is T1,T2,T3? Does it mean the types of the arguments? (I suspect not). What are T1,T2,T3 when multiple <code>operator()</code> function exist, only taking one argument?</p>\n<p>And what is meant by \"if <code>T::operator()</code> exists\" anyway?  It could perhaps mean any of the following:</p>\n<ol>\n<li><code>operator()</code> is declared in <code>T</code>.</li>\n<li>Unqualified lookup of <code>operator()</code> in the scope of <code>T</code> succeeds and performing overload resolution on that lookup set with the given arguments succeeds.</li>\n<li>Qualified lookup of <code>T::operator()</code> in the calling context succeeds and performing overload resolution on that lookup set with the given arguments succeeds.</li>\n<li>Something else?</li>\n</ol>\n<p>To proceed from here (for me anyway) I would like to understand why the standard didn't simply say that <code>f(123)</code> means <code>f.operator()(123);</code>, the former being ill-formed if and only if the latter is ill-formed.  The motivation behind the actual wording might reveal the intent and therefore which compiler's behaviour matches the intent.</p>\n</hr>", "LastActivityDate": "2017-06-08T14:03:09.403"}});