post_cb({"25066165": {"Id": "25066165", "PostTypeId": "2", "Body": "<p>Because <code>Bar::stuff</code> hides <code>Foo::stuff</code> (only the name matters when overload resolution is performed, parameters are ignored). </p>\n<p><strong>You can :</strong></p>\n<ul>\n<li>Bring it into sope with a <code>using</code> declaration</li>\n<li>Or alternatively,  explicitly qualify the call e.g. <code>b.Foo::stuff(3);</code>.</li>\n</ul>\n<p><strong>Note</strong> :</p>\n<ul>\n<li><code>main()</code> must return an <code>int</code>.</li>\n</ul>\n<hr>\n<pre><code>#include &lt;iostream&gt;\n\nclass Foo\n{\npublic:\n    int a;\n    void stuff(int a){ std::cout &lt;&lt; a &lt;&lt; std::endl; }\n};\n\nclass Bar : public Foo\n{\npublic:\n    using Foo::stuff;\nprotected:\n    void stuff() { std::cout &lt;&lt; \"hello world\"; }\n};\n\nint main()\n{\n    Bar b;\n    b.stuff(3);\n}\n</code></pre>\n<p>Or :</p>\n<pre><code>int main()\n{\n    Bar b;\n    b.Foo::stuff(3);\n}\n</code></pre>\n</hr>", "LastEditorUserId": "3510483", "LastActivityDate": "2014-07-31T18:22:07.687", "Score": "6", "CreationDate": "2014-07-31T18:16:51.383", "ParentId": "25066001", "CommentCount": "3", "OwnerUserId": "3510483", "LastEditDate": "2014-07-31T18:22:07.687"}, "25066001": {"ViewCount": "129", "Body": "<p>I have two simple classes, and wish to access the public method <code>stuff</code> by passing an <code>int</code> value. why can't I do that with an instance of Bar? Shouldn't it inherit the public method stuff. The type hinting gives the <code>int a</code> parameter, but it doesn't compile.</p>\n<pre><code>class Foo\n{\npublic:\n    int a;\n    void stuff(int a){ std::cout &lt;&lt; a &lt;&lt; std::endl; }\n};\n\nclass Bar : public Foo\n{\nprotected:\n    void stuff() { std::cout &lt;&lt; \"hello world\"; }\n};\n\n\n\nvoid main()\n{\n    Bar b\n    b.stuff(3);\n}\n</code></pre>\n", "AcceptedAnswerId": "25066165", "Title": "why can't I access this method via inheritance?", "CreationDate": "2014-07-31T18:06:57.477", "Id": "25066001", "CommentCount": "7", "PostTypeId": "1", "ClosedDate": "2014-08-01T13:21:22.403", "LastActivityDate": "2014-07-31T19:13:41.610", "Score": "3", "OwnerUserId": "3791372", "Tags": "<c++><oop><inheritance>", "AnswerCount": "4"}, "25066044": {"Id": "25066044", "PostTypeId": "2", "Body": "<p>In C++, name hiding can take place when one function in base class has the same name as one function in derived class.</p>\n<p><strong>Phases of the function call process</strong></p>\n<ol>\n<li>Name lookup</li>\n<li>Overload resolution</li>\n<li>Access control</li>\n</ol>\n<p>Name lookup stops looking for other names as soon as it finds a name in derived class <code>Bar</code>. Therefore, <code>Bar::stuff()</code> hides any function with name <code>stuff</code> in <code>Foo</code>.</p>\n<p>After the name lookup process,</p>\n<ul>\n<li>overload resolution fails since there is no <code>stuff(int)</code> in <code>Bar</code>.</li>\n<li>even though <code>stuff()</code> without <code>int</code> parameter is called, access control fails since <code>stuff()</code> is protected.</li>\n</ul>\n", "LastEditorUserId": "2328763", "LastActivityDate": "2014-07-31T19:13:41.610", "Score": "4", "CreationDate": "2014-07-31T18:09:35.927", "ParentId": "25066001", "CommentCount": "0", "OwnerUserId": "2328763", "LastEditDate": "2014-07-31T19:13:41.610"}, "bq_ids": {"n4140": {"so_25066001_25066055_1": {"length": 36, "quality": 0.9473684210526315, "section_id": 6989}}, "n3337": {"so_25066001_25066055_1": {"length": 36, "quality": 0.9473684210526315, "section_id": 6735}}, "n4659": {"so_25066001_25066055_1": {"length": 36, "quality": 0.9473684210526315, "section_id": 8487}}}, "25066146": {"Id": "25066146", "PostTypeId": "2", "Body": "<pre><code>b.Foo::stuff(3);\n</code></pre>\n<p>Or, you can do a trick to access any protected:)</p>\n<pre><code>void main()\n{\n    Bar b;\n    class BarAccess : public Bar { friend void main(); }\n    BarAccess * ba = reinterpret_cast&lt;BarAccess *&gt;(&amp;b);\n    ba-&gt;stuff(3);\n    ba-&gt;stuff();\n}\n</code></pre>\n", "LastActivityDate": "2014-07-31T18:16:00.863", "CommentCount": "2", "CreationDate": "2014-07-31T18:16:00.863", "ParentId": "25066001", "Score": "0", "OwnerUserId": "2342276"}, "25066055": {"Id": "25066055", "PostTypeId": "2", "Body": "<p>When looking up the name <code>stuff</code>, the one in <code>Bar</code> found first. Once that is found, the access privileges are checked. Since <code>Bar::stuff</code> is protected, you are not able to use it from <code>main</code>.</p>\n<p>From the draft standard:</p>\n<blockquote>\n<p id=\"so_25066001_25066055_0\"><strong>10.2 Member name lookup [class.member.lookup]</strong></p>\n<p id=\"so_25066001_25066055_1\">1 Member name lookup determines the meaning of a name (<em>id-expression</em>) in a class scope (3.3.7). Name lookup can result in an <em>ambiguity</em>, in which case the program is ill-formed. For an <em>id-expression</em>, name lookup begins in the class scope of <code>this</code>; for a <em>qualified-id</em>, name lookup begins in the scope of the <em>nestedname-specifier</em>. Name lookup takes place before access control (3.4, Clause 11).</p>\n</blockquote>\n", "LastEditorUserId": "434551", "LastActivityDate": "2014-07-31T18:16:08.807", "Score": "4", "CreationDate": "2014-07-31T18:10:04.383", "ParentId": "25066001", "CommentCount": "3", "OwnerUserId": "434551", "LastEditDate": "2014-07-31T18:16:08.807"}});