post_cb({"26999748": {"Id": "26999748", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_26998571_26999748_0\">My main question is whether it is safe to flags = defaultFlags; in the\n  object constructor, in order to eliminate the 20 lines for assigning\n  each field individually?</p>\n</blockquote>\n<p>Yes. The implicitly defined copy constructor for <code>Flags</code> will assign each Bitfield appropriately. [class.copy]/15:</p>\n<blockquote>\n<p id=\"so_26998571_26999748_1\">Each base or non-static data member is copied/moved in the manner\n  appropriate to its type:</p>\n<ul>\n<li>if the member is an array, [..]</li>\n<li>if a member <code>m</code> has rvalue reference type T&amp;&amp; [..]</li>\n<li><strong>otherwise, the base or member is direct-initialized with the corresponding <br>base or member of <code>x</code>.</br></strong></li>\n</ul>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_26998571_26999748_2\">can I serialize that as a 32bit unsigned integer and desterilize it as\n  such without any data corruption?</p>\n</blockquote>\n<p>If you write and read the file on the same machine with the same compiled program, yes. The layout might be different on other compilers or architectures though, the standard doesn't impose any fixed requirements in that respect. [class.bit]/1:</p>\n<blockquote>\n<p id=\"so_26998571_26999748_3\">Allocation of bit-fields within a class object is\n  implementation-defined. Alignment of bit-fields is\n  implementation-defined. Bit-fields are packed into some addressable\n  allocation unit. [ <em>Note:</em> Bit-fields straddle allocation units on\n  some machines and not on others. Bit-fields are assigned right-to-left\n  on some machines, left-to-right on others. <em>\u2014 end note</em> ]</p>\n</blockquote>\n<p>If you write it into a <code>char</code> array of size <code>sizeof Field</code>, write that into a file and extract it from there again, copying it back into a <code>Field</code> object should thus give you the same values. [basic.types]/2 (emphasis mine):</p>\n<blockquote>\n<p id=\"so_26998571_26999748_4\">For any object (other than a base-class subobject) of trivially\n  copyable type <code>T</code>, whether or not the object holds a valid value of type\n  <code>T</code>, the underlying bytes (1.7) making up the object can be copied\n  into an array of <code>char</code> or <code>unsigned char</code>. If <strong>the content</strong> of the\n  array of <code>char</code> or <code>unsigned char</code> is copied back into the object, the\n  object shall subsequently hold its original value.</p>\n</blockquote>\n<p>However, as pointed out in the comments, full portability (and reasonable efficiency) can be achieved using bitmasks. </p>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2014-11-18T17:44:24.343", "Score": "3", "CreationDate": "2014-11-18T16:58:11.093", "ParentId": "26998571", "CommentCount": "0", "LastEditDate": "2014-11-18T17:44:24.343", "OwnerUserId": "3647361"}, "bq_ids": {"n4140": {"so_26998571_26999748_1": {"length": 10, "quality": 1.0, "section_id": 464}, "so_26998571_26999748_3": {"length": 28, "quality": 0.8484848484848485, "section_id": 5921}, "so_26998571_26999748_4": {"length": 40, "quality": 0.975609756097561, "section_id": 7200}}, "n3337": {"so_26998571_26999748_1": {"length": 10, "quality": 1.0, "section_id": 455}, "so_26998571_26999748_3": {"length": 28, "quality": 0.8484848484848485, "section_id": 5693}, "so_26998571_26999748_4": {"length": 40, "quality": 0.975609756097561, "section_id": 6944}}, "n4659": {"so_26998571_26999748_1": {"length": 10, "quality": 1.0, "section_id": 487}, "so_26998571_26999748_3": {"length": 28, "quality": 0.8484848484848485, "section_id": 7395}, "so_26998571_26999748_4": {"length": 37, "quality": 0.9024390243902439, "section_id": 8709}}}, "26998571": {"ViewCount": "351", "Body": "<p>I have a bunch of properties crammed in a bitfield to save on space:</p>\n<pre><code>struct Flags {\n    uint access : 2;\n    uint status : 2;\n    uint isEnabled : 1;\n    uint isDeletable: 1;\n    ...\n};\n</code></pre>\n<p>Then I have a static <code>Flags defaultFlags</code> which is initialized on program startup. My main question is whether it is safe to <code>flags = defaultFlags;</code> in the object constructor, in order to eliminate the 20 lines for assigning each field individually?</p>\n<p>Also, I was wondering what about serialization? According to the compiler, <code>Flags</code> is 4 bytes, can I serialize that as a 32bit unsigned integer and desterilize it as such without any data corruption?</p>\n", "AcceptedAnswerId": "26999748", "Title": "Bitfield assignment - is it safe?", "CreationDate": "2014-11-18T16:00:41.020", "Id": "26998571", "CommentCount": "9", "PostTypeId": "1", "OwnerDisplayName": "user3735658", "LastActivityDate": "2014-11-18T17:44:24.343", "Score": "3", "Tags": "<c++><serialization><variable-assignment><bit-fields><mass-assignment>", "AnswerCount": "1"}});