post_cb({"41996580": {"Id": "41996580", "PostTypeId": "2", "Body": "<p>Shortly that's because a reference or a pointer to a const type is not a const type.<br>\nNote that <code>decltype(*bar)</code> isn't <code>const foo</code>, it's <code>const foo &amp;</code> and they are really different beasts.</br></p>\n<hr>\n<p>Consider the example given <a href=\"http://en.cppreference.com/w/cpp/types/is_const\" rel=\"noreferrer\">here</a>:</p>\n<pre><code>std::cout &lt;&lt; std::is_const&lt;const int *&gt;::value &lt;&lt; '\\n'; // false\nstd::cout &lt;&lt; std::is_const&lt;int * const&gt;::value &lt;&lt; '\\n'; // true\n</code></pre>\n<p>We see that <code>std::is_const&lt;const int *&gt;::value</code> is false and <code>std::is_const&lt;int * const&gt;::value</code> is true.<br>\nThat's because in <code>const int *</code> the type is pointer to something const, that is not a const type as intended by <code>is_const</code> (and the standard actually). In <code>int * const</code> the const qualifier applies to the pointer type and not to the pointed one, thus the type is a const one, no matter to what it points.<br>\nSomething similar applies for <code>const foo &amp;</code>, that is a reference to something const.</br></br></p>\n<p>You can solve using this instead:</p>\n<pre><code>static_assert(std::is_const&lt;std::remove_reference_t&lt;decltype(*bar)&gt;&gt;::value, \"expected const but this is non-const!\");\n</code></pre>\n<p>Or even this, for you don't need to do <code>*bar</code> actually:</p>\n<pre><code>static_assert(std::is_const&lt;std::remove_pointer_t&lt;decltype(bar)&gt;&gt;::value, \"expected const but this is non-const!\");\n</code></pre>\n<p>In this case, by <em>removing the pointer/reference</em> with <code>remove_pointer_t</code>/<code>remove_reference_t</code> your type becomes <code>const foo</code>, that is actually a const type.</p>\n<hr>\n<p>As a side note, the example above uses the <em>C++14-ish</em> <code>std::remove_reference_t</code> and <code>std::remove_pointer_t</code> type traits.<br>\nYou can easily turn those lines of code to C++11 as it follows:</br></p>\n<pre><code>static_assert(std::is_const&lt;typename std::remove_pointer&lt;decltype(bar)&gt;:: type&gt;::value, \"expected const but this is non-const!\");\n</code></pre>\n<hr>\n<p>It's worth mentioning a few comments to the answer to give more details:</p>\n<ul>\n<li><p>Thanks to @DanielFischer for the question:</p>\n<blockquote>\n<p id=\"so_41996441_41996580_0\">Is there a short explanation why <code>decltype(*bar)</code> is <code>const foo&amp;</code> rather than <code>const foo</code>?</p>\n</blockquote>\n<p>I'm not a language-lawyer, but I guess it can be deduced from <a href=\"http://eel.is/c++draft/expr.unary#op-1\" rel=\"noreferrer\">[expr.unary.op]/1</a> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_41996441_41996580_1\"><strong>The unary * operator performs indirection</strong>: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type <strong>and the result is an lvalue</strong> referring to the object or function to which the expression points.</p>\n</blockquote>\n<p>And <a href=\"http://eel.is/c++draft/dcl.type.simple#4.4\" rel=\"noreferrer\">[dcl.type.simple]/4.4</a> (emphasis mine):</p>\n<blockquote>\n<p id=\"so_41996441_41996580_2\">otherwise, <strong>if e is an lvalue, decltype(e) is T&amp;</strong>, where T is the type of e;</p>\n</blockquote>\n<p>Both referring to the working draft.</p></li>\n<li><p>Thanks to @LightnessRacesInOrbit for the comment. Note that <code>decltype(*bar)</code> being <code>const foo &amp;</code> is a funny C++ quirk of <code>decltype</code>, since <code>*bar</code> is not <code>const foo &amp;</code>.</p></li>\n</ul>\n</hr></hr></hr>", "LastEditorUserId": "4987285", "LastActivityDate": "2017-02-02T17:31:26.293", "Score": "35", "CreationDate": "2017-02-02T07:38:01.200", "ParentId": "41996441", "CommentCount": "13", "OwnerUserId": "4987285", "LastEditDate": "2017-02-02T17:31:26.293"}, "bq_ids": {"n4140": {"so_41996441_41996580_2": {"length": 5, "quality": 1.0, "section_id": 5440}, "so_41996441_41996580_1": {"length": 19, "quality": 0.95, "section_id": 6064}}, "n3337": {"so_41996441_41996580_2": {"length": 5, "quality": 1.0, "section_id": 5235}, "so_41996441_41996580_1": {"length": 19, "quality": 0.95, "section_id": 5832}}, "n4659": {"so_41996441_41996580_2": {"length": 5, "quality": 1.0, "section_id": 6867}, "so_41996441_41996580_1": {"length": 18, "quality": 0.9, "section_id": 7560}}}, "41996441": {"ViewCount": "1477", "Body": "<pre><code>#include &lt;type_traits&gt;\n\nstruct foo;\nint main()\n{\n    const foo *bar;\n\n    static_assert(std::is_const&lt;decltype(*bar)&gt;::value,\n                  \"expected const but this is non-const!\");\n}\n</code></pre>\n<p>This results in a failing <code>static_assert</code> which is unexpected. This is somewhat similar to <a href=\"https://stackoverflow.com/q/24029723/234175\">this question</a> on const references but not quite the same.</p>\n<p>In my case, dereferencing <code>bar</code> should give an instance of <code>const foo</code> as its type but yet <code>std::is_const</code> is saying otherwise.</p>\n", "AcceptedAnswerId": "41996580", "Title": "Why is std::is_const::value 'false' even though T's value_type is const?", "CreationDate": "2017-02-02T07:29:17.040", "Id": "41996441", "CommentCount": "3", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:17:18.480", "LastEditorUserId": "-1", "LastActivityDate": "2017-02-02T17:31:26.293", "Score": "24", "OwnerUserId": "234175", "Tags": "<c++><c++11><const>", "AnswerCount": "1"}});