post_cb({"14754220": {"Id": "14754220", "PostTypeId": "2", "Body": "<p>You seem to be confusing <em>copy-constructors</em> with <em>copy-assignment</em> operators. The implicitly generated <em>copy-constructor</em> will <em>copy-construct</em> each of the members:</p>\n<pre><code>A::A( A const&amp; source )\n  : a( source.a )\n  , b( source.b )\n{}\n</code></pre>\n<p>The implicitly generated <em>copy-assignment</em> operator will <em>copy-assign</em> each of the members:</p>\n<pre><code>A&amp; A::operator =( A const&amp; source )\n{\n    a = source.a;\n    b = source.b;\n    return *this;\n}\n</code></pre>\n<p>The <em>copy-assignment</em> operator as you defined it in your question takes an <code>A</code> by <em>copy</em>, so the <em>copy-constructor</em> will be called to create the argument passed to <code>operator=</code>. Note that the copy may be elided under certain circumstances.</p>\n", "LastActivityDate": "2013-02-07T15:01:45.437", "CommentCount": "0", "CreationDate": "2013-02-07T15:01:45.437", "ParentId": "14754145", "Score": "3", "OwnerUserId": "927034"}, "14754324": {"Id": "14754324", "PostTypeId": "2", "Body": "<p>Your class provides <code>operator=</code>. Per the rule of three (as @AlokSave says), you should then provide the copy constructor and destructor as well.</p>\n<p>The question is, if you're happy with the default-supplied copy constructor, why aren't you happy with the default-supplied copy assignment operator? And if you are, just don't declare <code>operator=</code> and let the compiler generate the entire \"rule of three\" for you.</p>\n", "LastActivityDate": "2013-02-07T15:07:04.333", "CommentCount": "0", "CreationDate": "2013-02-07T15:07:04.333", "ParentId": "14754145", "Score": "1", "OwnerUserId": "1782465"}, "14754209": {"Id": "14754209", "PostTypeId": "2", "Body": "<p>The rule is that if you need to provide either:    </p>\n<ul>\n<li>copy constructor or</li>\n<li>destructor or</li>\n<li>copy assignment operator </li>\n</ul>\n<p>then you probably need to provide all three of them. This rule is known as <strong><a href=\"https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three\">Rule of Three</a></strong>.</p>\n<hr>\n<blockquote>\n<p id=\"so_14754145_14754209_0\"><strong>I<em>s it safe not to declare a copy constructor?</em></strong> </p>\n</blockquote>\n<p>It is safe.    </p>\n<blockquote>\n<p id=\"so_14754145_14754209_1\"><strong><em>Do you have to for your example case?</em></strong> </p>\n</blockquote>\n<p>Not really. To be specific the rule of three governs that. Check the linked question for more details on that.</p>\n<hr>\n<blockquote>\n<p id=\"so_14754145_14754209_2\"><strong><em>How does the default copy constructor looks like?</em></strong> </p>\n</blockquote>\n<p>I gather this is asking, What does the default copy constructor do.<br>\nThis is answered in:<br>\n<strong>C++03 Standard 12.8 Copying class objects:</strong><br>\n<strong>Para 8:</strong> </br></br></br></p>\n<blockquote>\n<p id=\"so_14754145_14754209_3\">The implicitly-defined copy constructor for class X performs a memberwise copy of its subobjects. The order of copying is the same as the order of initialization of bases and members in a user-defined constructor (see 12.6.2). Each subobject is copied in the manner appropriate to its type:</p>\n<p id=\"so_14754145_14754209_4\">\u2014 if the subobject is of class type, the copy constructor for the class is used;<br>\n  \u2014 if the subobject is an array, each element is copied, in the manner appropriate to the element type;<br>\n  \u2014 if the subobject is of scalar type, the built-in assignment operator is used.<br>\n  Virtual base class subobjects shall be copied only once by the implicitly-defined copy constructor (see 12.6.2).</br></br></br></p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_14754145_14754209_5\"><strong><em>Even If I not declare a copy constructor, the default one will be called when I call <code>operator=()</code></em></strong> </p>\n</blockquote>\n<p>A copy constructor is invoked only when a copy of the class object needs to be created. This involves copies of objects created while passing to or returning from functions.<br>\nYour copy assignment operator passes the object <code>A</code> <em>by value</em>, this pass by value is achieved by passing a copy of the object through copy constructor and hence the call to copy constructor.<br>\nTo avoid the copy you need to pass <em>by reference</em>:    </br></br></p>\n<pre><code>A&amp; A::operator=(const A&amp; other)\n</code></pre>\n<p><strong>Good Read:</strong><br>\n<a href=\"https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value\">What's the difference between passing by reference vs. passing by value?</a></br></p>\n</hr></hr></hr>", "LastEditorUserId": "-1", "LastActivityDate": "2013-02-07T15:21:01.047", "Score": "6", "CreationDate": "2013-02-07T15:01:07.590", "ParentId": "14754145", "CommentCount": "4", "OwnerUserId": "452307", "LastEditDate": "2017-05-23T11:56:23.037"}, "bq_ids": {"n4140": {"so_14754145_14754209_3": {"length": 20, "quality": 0.6896551724137931, "section_id": 464}, "so_14754145_14754209_4": {"length": 21, "quality": 0.65625, "section_id": 477}}, "n3337": {"so_14754145_14754209_3": {"length": 20, "quality": 0.6896551724137931, "section_id": 455}, "so_14754145_14754209_4": {"length": 21, "quality": 0.65625, "section_id": 468}}, "n4659": {"so_14754145_14754209_3": {"length": 20, "quality": 0.6896551724137931, "section_id": 487}, "so_14754145_14754209_4": {"length": 20, "quality": 0.625, "section_id": 500}}}, "14754232": {"Id": "14754232", "PostTypeId": "2", "Body": "<pre><code>A::A(const A&amp; other) != A&amp; A::operator=(const A other)\n</code></pre>\n", "LastEditorUserId": "50049", "LastActivityDate": "2013-02-07T16:01:23.403", "Score": "1", "CreationDate": "2013-02-07T15:02:16.137", "ParentId": "14754145", "CommentCount": "0", "OwnerUserId": "2050386", "LastEditDate": "2013-02-07T16:01:23.403"}, "14754145": {"ViewCount": "117", "Body": "<p>If I declare a class like, (no dynamic memory allocation, no pointer):</p>\n<pre><code>class A{\n  int a,b;\npublic:\n  A();\n  A(int,int);\n  A&amp; operator=(const A);\n};\n</code></pre>\n<p>Is it safe not to declare a copy constructor? How does the default copy constructor looks like?</p>\n<pre><code>A&amp; A::operator=(const A other)\n{\n   a=other.a;\n   b=other.b;\n   return *this;\n}\n</code></pre>\n<p>Even If I do not declare a copy constructor, the default one will be called when I call <strong>operator=()</strong></p>\n<hr>\n<p>EDIT:</p>\n<p>the default destructor is:</p>\n<pre><code>A::~A(){}\n</code></pre>\n<p>so it's not needed here</p>\n</hr>", "AcceptedAnswerId": "14754209", "Title": "C++: autogenerated(default) copy costructor", "CreationDate": "2013-02-07T14:58:28.817", "Id": "14754145", "CommentCount": "4", "LastEditDate": "2013-02-07T15:37:44.337", "PostTypeId": "1", "LastEditorUserId": "1187554", "LastActivityDate": "2013-02-07T16:01:23.403", "Score": "2", "OwnerUserId": "1187554", "Tags": "<c++><operator-overloading><copy-constructor>", "AnswerCount": "4"}});