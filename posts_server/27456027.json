post_cb({"27456027": {"CommentCount": "7", "ViewCount": "185", "OwnerDisplayName": "user2953119", "CreationDate": "2014-12-13T05:58:15.367", "LastActivityDate": "2014-12-13T06:43:16.233", "Title": "Why was the following type incomplete?", "PostTypeId": "1", "Id": "27456027", "Score": "0", "Body": "<p>Consider the following simple program:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct A; //1\n\nnamespace B\n{\n    struct A //2\n    {\n        int a;\n        A() : a(10){ }\n        friend void foo(A* a);\n    };\n}\n\nvoid foo(A* a)\n{\n    std::cout &lt;&lt; a -&gt; a &lt;&lt; std::endl;\n}\n\nA* a = new A; //error: allocation of incomplete type\n\nint main()\n{\n    foo(a);\n}\n</code></pre>\n<p><strong><a href=\"http://coliru.stacked-crooked.com/a/f6fbd267a6a0ec85\" rel=\"nofollow\">DEMO</a></strong></p>\n<p>In the code above we tried to allocate memory to incomplete type. But why is it incomplete? The Standard said <code>N3797::3.9/6 [basic.types]</code>:</p>\n<blockquote>\n<p id=\"so_27456027_27456027_0\">A class type (such as \u201cclass X\u201d) might be incomplete at one point in a\n  translation unit and complete later on; the type \u201cclass X\u201d is the same\n  type at both points.</p>\n</blockquote>\n<p>So, the type <code>A</code> is incomplete at <code>//1</code> and has completed at <code>//2</code>, therefore as the Standard said it was the same at both points, which means class type is completed at <code>//1</code>. That is why the compile-error isn't clear to me. Couldn't you clarify?</p>\n", "Tags": "<c++><class>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_27456027_27456027_0": {"section_id": 7204, "quality": 1.0, "length": 18}}, "n3337": {"so_27456027_27456027_0": {"section_id": 6948, "quality": 1.0, "length": 18}}, "n4659": {"so_27456027_27456027_0": {"section_id": 8713, "quality": 1.0, "length": 18}}}, "27456292": {"ParentId": "27456027", "CommentCount": "0", "Body": "<p>I guess //1 case is used for forward declaration.<br>\nBut you can not do this because <code>A and B::A</code> are in totally different place.\nso the option could be.</br></p>\n<p>If you want to use forward declaration you will have to put <code>A</code> in the same <code>namespace</code>.<br>\nMay be this would put some light what i want to say.</br></p>\n<pre><code>#include &lt;iostream&gt;\n\nnamespace B{\nstruct A;\n}\n\nnamespace B\n{\n    struct A\n    {\n    private:\n        int a;\n    public:\n        A() : a(10){ }\n        friend void foo(A * a);\n    };\n\n    void foo(A* a)\n    {\n        std::cout &lt;&lt; a -&gt; a &lt;&lt; std::endl;\n    }\n}\n\nB::A* a = new B::A;\n\nint main()\n{\n    foo(a);\n}\n</code></pre>\n<p>Here's the \n<a href=\"http://coliru.stacked-crooked.com/a/3ff9a7184752de25\" rel=\"nofollow\">DEMO</a></p>\n", "OwnerUserId": "2219912", "PostTypeId": "2", "Id": "27456292", "Score": "2", "CreationDate": "2014-12-13T06:43:16.233", "LastActivityDate": "2014-12-13T06:43:16.233"}});