post_cb({"31483328": {"ParentId": "31483064", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2015-07-17T19:27:47.750", "Score": "3", "LastEditorUserId": "567292", "LastEditDate": "2015-07-17T19:33:59.713", "Id": "31483328", "OwnerUserId": "567292", "Body": "<p>For C++, this is is described in Object lifetime <strong>[object.life]</strong>; in particular:</p>\n<blockquote>\n<p id=\"so_31483064_31483328_0\">The lifetime of an object of type <code>T</code> begins when:</p>\n<ul>\n<li>storage with the proper alignment and size for type <code>T</code> is obtained, and</li>\n<li>if the object has non-trivial initialization, its initialization is complete.</li>\n</ul>\n</blockquote>\n<p>Lifetime continues until the storage is reused or the object is destructed:</p>\n<blockquote>\n<p id=\"so_31483064_31483328_1\">A program may end the lifetime of any object by reusing the storage which the object occupies or by explicitly\n  calling the destructor for an object of a class type with a non-trivial destructor.</p>\n</blockquote>\n<p>This has the rather odd implication that unused allocated storage (returned from <code>operator new</code>) contains an object of every trivial type that fits in that block of storage, at least until the block of storage is used.  But then, the standard cares more about getting the treatment of non-trivial types right than this minor wart.</p>\n", "LastActivityDate": "2015-07-17T19:33:59.713"}, "31483130": {"ParentId": "31483064", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-07-17T19:14:51.810", "Score": "0", "LastEditorUserId": "2296458", "LastEditDate": "2015-07-17T19:27:09.793", "Id": "31483130", "OwnerUserId": "2296458", "Body": "<p>I'm not sure such an analog exists, or is needed in C++. To allocate memory you can do one of three things</p>\n<pre><code>Foo f;\n</code></pre>\n<p>This will allocate <code>sizeof(Foo)</code> amount of memory on the stack. The size is known at compile-time, which is how the compiler knows how much space to allocate. The same is true of arrays, etc.</p>\n<p>The other option is</p>\n<pre><code>Foo* f = new Foo;  // or the smart pointer alternatives\n</code></pre>\n<p>This will allocate from the heap, but again <code>sizeof(Foo)</code> must be known, but this allows allocation at run-time.</p>\n<p>The third option, as @BasileStarynkevitch mentions, is <a href=\"https://stackoverflow.com/questions/222557/what-uses-are-there-for-placement-new\">placement new</a></p>\n<p>You can see that <strong>all of these allocation mechanisms in C++ require knowledge of the type that you are allocating space for</strong>. </p>\n<p>While it is possible to use <code>malloc</code>, etc in C++, it is frowned upon as it goes against the grain for typical C++ semantics. You can see a discussion of a <a href=\"https://stackoverflow.com/questions/14111900/using-new-on-void-pointer\">similar question</a>. The other mechanisms of allocating \"raw\" memory are hacky. For example</p>\n<pre><code>void* p = operator new(size);\n</code></pre>\n<p>This will allocate <code>size</code> number of bytes.</p>\n", "LastActivityDate": "2015-07-17T19:27:09.793"}, "31484505": {"ParentId": "31483064", "CommentCount": "6", "CreationDate": "2015-07-17T20:50:22.507", "OwnerUserId": "2445184", "PostTypeId": "2", "Id": "31484505", "Score": "1", "Body": "<p>I think, the approach of C++ in this regard can be summarized as: \"<code>malloc()</code> is evil. Use <code>new</code> instead. There is no such thing as an object without a declared type.\" Of course, C++ implementations need to define the global <code>operator new()</code>, which is basically the C++ version of <code>malloc()</code> (and which can be provided by the user). The very existence of this operator proves that there is something like objects without a declared type in C++, but the standard won't admit it.</p>\n<p>If I were you, I'd take the pragmatic approach. Both the global <code>operator new()</code> and <code>malloc()</code> are available in C++, so any implementation must be able to use their return values sensibly. Especially <code>malloc()</code> will behave identical in C and C++. So, just handle these untyped objects the same way as you would handle them in C, and you should be fine.</p>\n", "LastActivityDate": "2015-07-17T20:50:22.507"}, "31484575": {"ParentId": "31483064", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2015-07-17T20:56:01.627", "Score": "2", "LastEditorUserId": "3747990", "LastEditDate": "2015-07-19T19:30:36.030", "Id": "31484575", "OwnerUserId": "3747990", "Body": "<p>I think \"an allocated object with no declared type\" is effectively allocated storage that is not yet initialised and no object has yet been created in that memory space. From the global allocation function <code>::operator new(std::size_t)</code> and family (\u00a73.7.4/2);</p>\n<p>\u00a73.7.4.1/2</p>\n<blockquote>\n<p id=\"so_31483064_31484575_0\">The allocation function attempts to allocate the requested amount of storage. If it is successful, it shall return the address of the start of a block of storage whose length in bytes shall be at least as large as the requested size. There are no constraints on the contents of the allocated storage on return from the allocation function.</p>\n</blockquote>\n<p>The creation of an object, whether it is automatic or dynamic, is governed by two stages, the allocation itself and then the construction of the object in that space.</p>\n<p>\u00a73.8/1</p>\n<blockquote>\n<p id=\"so_31483064_31484575_1\">The lifetime of an object is a runtime property of the object. An object is said to have non-vacuous initialization if it is of a class or aggregate type and it or one of its members is initialized by a constructor other than a trivial default constructor. [<em>Note: initialization by a trivial copy/move constructor is non- vacuous initialization. \u2014 end note</em>]  The lifetime of an object of type <code>T</code> begins when:</p>\n<ul>\n<li>storage with the proper alignment and size for type <code>T</code> is obtained, and</li>\n<li>if the object has non-trivial initialization, its initialization is complete.</li>\n</ul>\n</blockquote>\n<p>Correspondingly;</p>\n<blockquote>\n<p id=\"so_31483064_31484575_2\">The lifetime of an object of type T ends when:</p>\n<ul>\n<li>if <code>T</code> is a class type with a non-trivial destructor (12.4), the destructor call starts, or</li>\n<li>the storage which the object occupies is reused or released.</li>\n</ul>\n</blockquote>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4527.pdf\" rel=\"nofollow\">C++ WD n4527</a>.</p>\n", "LastActivityDate": "2015-07-19T19:30:36.030"}, "bq_ids": {"n4140": {"so_31483064_31484575_1": {"section_id": 7189, "quality": 0.775, "length": 31}, "so_31483064_31483328_0": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}, "so_31483064_31483328_1": {"section_id": 7192, "quality": 1.0, "length": 16}, "so_31483064_31484575_2": {"section_id": 7189, "quality": 0.8333333333333334, "length": 5}, "so_31483064_31484575_0": {"section_id": 7177, "quality": 0.9655172413793104, "length": 28}}, "n3337": {"so_31483064_31483328_0": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}, "so_31483064_31484575_0": {"section_id": 6921, "quality": 0.9655172413793104, "length": 28}, "so_31483064_31483328_1": {"section_id": 6936, "quality": 1.0, "length": 16}, "so_31483064_31484575_2": {"section_id": 6933, "quality": 0.8333333333333334, "length": 5}, "so_31483064_31484575_1": {"section_id": 6933, "quality": 0.775, "length": 31}}, "n4659": {"so_31483064_31483328_1": {"section_id": 8701, "quality": 1.0, "length": 16}, "so_31483064_31484575_0": {"section_id": 8685, "quality": 0.9655172413793104, "length": 28}, "so_31483064_31483328_0": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}, "so_31483064_31484575_2": {"section_id": 8697, "quality": 0.8333333333333334, "length": 5}, "so_31483064_31484575_1": {"section_id": 8697, "quality": 0.725, "length": 29}}}, "31483064": {"CommentCount": "3", "ViewCount": "529", "CreationDate": "2015-07-17T19:10:22.313", "LastActivityDate": "2015-07-19T19:30:36.030", "Title": "What is the C++ equivalent of an 'allocated object having no declared type' in C?", "AcceptedAnswerId": "31484505", "PostTypeId": "1", "Id": "31483064", "Score": "15", "Body": "<p>I'm writing a memory manager for my VM in C++. Well, more exactly the VM instructions will be compiled into C++ with an embedded memory manager. I'm much more comfortable in handling C, but now I do need native support of exception handling, pretty much the only reason I'm using C++.</p>\n<p>Both C and C++ have the strict aliasing rule that two objects of incompatible types shall not overlap, with a small exception in C for unions. But to define the behaviour of memory allocation functions such as <code>malloc</code>, <code>calloc</code>, <code>alloca</code> etc., the C standard has the following paragraph.</p>\n<blockquote>\n<p id=\"so_31483064_31483064_0\"><strong>6.5-6</strong> The effective type of an object for an access to its stored value is the declared type of the object, if any. Allocated objects\n  have no declared type. If a value is stored into an object having no\n  declared type through an lvalue having a type that is not a character\n  type, then the type of the lvalue becomes the effective type of the\n  object for that access and for subsequent accesses that do not modify\n  the stored value. If a value is copied into an object having no declared type using <code>memcpy</code> or <code>memmove</code>, or is copied as an array of character type, then the effective type of the modified object for that access and for subsequent accesses that do not modify the value is the effective type of the object from which the value is copied, if it has one. For all other accesses to an object having no declared type, the effective type of the object is simply the type of the lvalue used for the access.</p>\n</blockquote>\n<p>This effectively makes using raw allocated memory for any type a well defined behaviour in C. I tried to find a similar paragraph in the C++ standard document but could not find one. I think C++ has a different approach in this regard. What is the C++ equivalent of an 'allocated object having no declared type' in C, and how does the C++ standard define it?</p>\n", "Tags": "<c++><c><memory>", "OwnerUserId": "3998522", "AnswerCount": "4"}});