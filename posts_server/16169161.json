post_cb({"bq_ids": {"n4140": {"so_16169161_16169257_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 6181}, "so_16169161_16169240_8": {"length": 4, "quality": 1.0, "section_id": 3312}}, "n3337": {"so_16169161_16169257_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 5942}, "so_16169161_16169240_8": {"length": 4, "quality": 1.0, "section_id": 3182}}, "n4659": {"so_16169161_16169257_0": {"length": 5, "quality": 0.7142857142857143, "section_id": 7683}, "so_16169161_16169240_8": {"length": 4, "quality": 1.0, "section_id": 382}}}, "16170079": {"Id": "16170079", "PostTypeId": "2", "Body": "<p>No real reason.</p>\n<p>C++ is the result of a committee effort so sometimes strange but deliberate decisions may slip through because of complex political/sociological dynamics.</p>\n<p>C++ syntax is hard. Very hard. Almost unbelievably hard. There are rules even go like \"if you can parse this arbitrarily long sequence of tokens as both this or that, then it's this\".</p>\n<p>It took many years for compilers even to simply agree on what is C++ and what is not.</p>\n<p>In this case my wild guess is that they didn't like the idea that cases that looked very similar:</p>\n<pre><code>MyClass x = {...};\nMyClass y; y = {...};\n</code></pre>\n<p>would be handled differently so there is a special provision for assignment to allow the syntax.</p>\n<p>From a technical point of view I don't see what are the problems of allowing it for other operators too, and on the other hand if there are problems (e.g. for overloading, template instantiation etc.) I don't see how assignment can hope to escape them.</p>\n<h1>EDIT</h1>\n<p>g++ allows using not only strict <code>operator=</code> but also <code>operator+=</code>, <code>operator-=</code> and similar \"augmented assignment\". May be the logical problems happens only if you allow non-member overloads (that are forbidden for assignment and augmented assignment operators).</p>\n", "LastEditorUserId": "320726", "LastActivityDate": "2013-04-23T16:14:04.067", "Score": "0", "CreationDate": "2013-04-23T13:03:09.917", "ParentId": "16169161", "CommentCount": "0", "OwnerUserId": "320726", "LastEditDate": "2013-04-23T16:14:04.067"}, "16169257": {"Id": "16169257", "PostTypeId": "2", "Body": "<p>It's just simply not supported.</p>\n<p>Initializer lists are explicitly defined to be valid in <em>initializations</em> (<code>[C++11: 8.5.4]</code>), and <em>assignments</em>:</p>\n<blockquote>\n<p id=\"so_16169161_16169257_0\"><code>[C++11: 5.17/9]:</code> A <em>braced-init-list</em> may appear on the right-hand side of</p>\n<ul>\n<li>an assignment to a scalar, in which case the initializer list shall have at most a single element. The meaning of <code>x={v}</code>, where <code>T</code> is the scalar type of the expression <code>x</code>, is that of <code>x=T(v)</code> except that no narrowing conversion (8.5.4) is allowed. The meaning of <code>x={}</code> is <code>x=T()</code>.</li>\n<li>an assignment defined by a user-defined assignment operator, in which case the initializer list is passed as the argument to the operator function.</li>\n</ul>\n</blockquote>\n<p>There is no standard wording to allow other, arbitrary cases.</p>\n<p>If it were allowed, in this example, the type of <code>{1,2}</code> would be fairly ambiguous. It would be a complicated language feature to implement.</p>\n", "LastActivityDate": "2013-04-23T12:22:23.710", "CommentCount": "4", "CreationDate": "2013-04-23T12:22:23.710", "ParentId": "16169161", "Score": "7", "OwnerUserId": "560648"}, "16169269": {"Id": "16169269", "PostTypeId": "2", "Body": "<p>An explicit cast is required.</p>\n<pre><code>if (a == (Foo){1, 2})\n{\n}\n</code></pre>\n", "LastActivityDate": "2013-04-23T12:22:49.127", "CommentCount": "1", "CreationDate": "2013-04-23T12:22:49.127", "ParentId": "16169161", "Score": "4", "OwnerUserId": "2040040"}, "16169240": {"Id": "16169240", "PostTypeId": "2", "Body": "<p>List-initialization cannot be used as an argument to an operator <em>in the general case</em>. Per Paragraph 8.5.4/1 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_16169161_16169240_0\">[...] List-initialization can be used</p>\n<p id=\"so_16169161_16169240_1\">\u2014 as the initializer in a variable definition (8.5)</p>\n<p id=\"so_16169161_16169240_2\">\u2014 as the initializer in a new expression (5.3.4)</p>\n<p id=\"so_16169161_16169240_3\">\u2014 in a return statement (6.6.3)</p>\n<p id=\"so_16169161_16169240_4\">\u2014 as a for-range-initializer (6.5)</p>\n<p id=\"so_16169161_16169240_5\">\u2014 <strong>as a function argument</strong> (5.2.2)</p>\n<p id=\"so_16169161_16169240_6\">\u2014 as a subscript (5.2.1)</p>\n<p id=\"so_16169161_16169240_7\">\u2014 as an argument to a constructor invocation (8.5, 5.2.3)</p>\n<p id=\"so_16169161_16169240_8\">\u2014 as an initializer for a non-static data member (9.2)</p>\n<p id=\"so_16169161_16169240_9\">\u2014 in a mem-initializer (12.6.2)</p>\n<p id=\"so_16169161_16169240_10\">\u2014 <strong>on the right-hand side of an assignment</strong> (5.17)</p>\n</blockquote>\n<p>The last item explains why list-initialization is allowed on the right side of <code>operator =</code>, even though it is not allowed in general for an arbitrary operator.</p>\n<p>Because of the fifth item above, however, it can be used as an argument to a regular function call, this way:</p>\n<pre><code>if (a.operator == ({1, 2}))\n</code></pre>\n", "LastEditorUserId": "1932150", "LastActivityDate": "2013-04-23T18:28:42.267", "Score": "41", "CreationDate": "2013-04-23T12:21:35.560", "ParentId": "16169161", "CommentCount": "15", "OwnerUserId": "1932150", "LastEditDate": "2013-04-23T18:28:42.267"}, "16169283": {"Id": "16169283", "PostTypeId": "2", "Body": "<p>When you are using the expression containing the user defined type a and == operator\nOverloaded operator function gets called which as per definition you have given requires an argument of a reference of an object of class Foo</p>\n<p>so your expression should be like a==b</p>\n<p>where b is an object of class Foo </p>\n<p>Here with this expression you will be able to compare data members of b and a and hence know if they are equal or not </p>\n", "LastActivityDate": "2013-04-23T12:23:25.037", "CommentCount": "0", "CreationDate": "2013-04-23T12:23:25.037", "ParentId": "16169161", "Score": "0", "OwnerUserId": "2216718"}, "16169161": {"ViewCount": "912", "Body": "<p>See this example:</p>\n<pre><code>struct Foo\n{\n    int a;\n    int b;\n\n    bool operator == (const Foo &amp; x)\n    {\n        return a == x.a &amp;&amp; b == x.b;\n    }\n};\n\nint main ()\n{\n    Foo a;\n\n    a = {1, 2};\n\n    if (a == {1, 2}) // error: expected primary-expression before \u2018{\u2019 token\n    {\n    }\n}\n</code></pre>\n<p>The line <code>a={1,2}</code> is fine. The braces are convert to a <code>Foo</code> to match the argument type of the implicit <code>operator=</code> method. It still works if <code>operator=</code> is user-defined.</p>\n<p>The line <code>if (a=={1,2}})</code> errors as indicated.</p>\n<p>Why does the expression <code>{1,2}</code> not convert to a <code>Foo</code> to match the user-defined <code>operator==</code> method?</p>\n", "AcceptedAnswerId": "16169240", "Title": "Why can I use operator= but not operator== with C++11 brace-initializers?", "CreationDate": "2013-04-23T12:17:47.990", "Id": "16169161", "CommentCount": "5", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2013-04-23T12:57:59.020", "LastEditorUserId": "458742", "LastActivityDate": "2013-04-23T18:28:42.267", "Score": "32", "OwnerUserId": "458742", "Tags": "<c++><c++11>", "AnswerCount": "5"}});