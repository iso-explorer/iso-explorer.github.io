post_cb({"30585119": {"ParentId": "30584706", "CommentCount": "0", "Body": "<p>This code causes undefined behaviour due to violating the strict aliasing rule.</p>\n<p>It may also cause UB due to alignment violation but I'll assume for this post that it doesn't.</p>\n<p>The object <code>d</code> has type <code>double</code>. But you try to access its memory through the glvalue <code>*b</code> which has type <code>int</code>. This is not one of the permitted aliasing types that are listed in [basic.lval]/10:</p>\n<blockquote>\n<p id=\"so_30584706_30585119_0\">If a program attempts to access the stored value of an object through a glvalue of other than one of the following types the behavior is undefined: </p>\n<ul>\n<li>the dynamic type of the object,</li>\n<li>a cv-qualified version of the dynamic type of the object,</li>\n<li>a type similar (as defined in 4.4) to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to the dynamic type of the object,</li>\n<li>a type that is the signed or unsigned type corresponding to a cv-qualified version of the dynamic type\n  of the object,</li>\n<li>an aggregate or union type that includes one of the aforementioned types among its elements or non-\n  static data members (including, recursively, an element or non-static data member of a subaggregate\n  or contained union),</li>\n<li>a type that is a (possibly cv-qualified) base class type of the dynamic type of the object,</li>\n<li>a char or unsigned char type.</li>\n</ul>\n</blockquote>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "30585119", "Score": "0", "CreationDate": "2015-06-01T23:43:38.847", "LastActivityDate": "2015-06-01T23:43:38.847"}, "30584904": {"ParentId": "30584706", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Let's make a minor change to the code:</p>\n<pre><code>#include &lt;iostream&gt;\n\nint main() {\n    double a = 5.0;\n    double *d = &amp;a;\n    char *b = (char *)&amp;a;\n    int a1 = 10;\n\n    for (int i = 0; i &lt; sizeof(double); i++)\n        std::cout &lt;&lt; std::hex &lt;&lt; (int)b[i] &lt;&lt; \"\\t\";\n}\n</code></pre>\n<p>This shows us the individual bytes of the <code>double</code> as they're stored in memory. The result I get is:</p>\n<pre><code>0       0       0       0       0       0       14      40\n</code></pre>\n<p>Now, if you look at the first four bytes of this, they're all zeros. Assuming your <code>int</code> is two or four bytes, when you try to view that memory as an <code>int</code>, the result is going to be zero, because all the non-zero bytes of the double are stored later in memory than the part you're looking at when using it as an <code>int</code>.</p>\n<p>Of course, if you printed it out as a <code>long long int</code> instead, you'd get a non-zero result (a <code>long long int</code> is required to be at least 64 bits). Likewise, if you were doing this on a big-endian system, the <code>14</code> and <code>40</code> bytes of the <code>double</code> would probably be stored at the first bytes in memory rather than the last, so the result would again be non-zero.</p>\n<p>The bottom line is that in this case, your cast is roughly equivalent to a <code>reinterpret_cast</code>. Rather than taking the <code>double</code> <em>value</em> and converting it to an <code>int</code> value, it's looking at the bytes of memory occupied by the <code>double</code>, and interpreting them as if they were an <code>int</code>.</p>\n<p>Note that the result above isn't really required and you can't count on its happening in portable code. It <em>is</em> quite common and widely expected though (e.g., on most little-endian machines with IEEE floating point and 32-bit <code>int</code>s).</p>\n", "OwnerUserId": "179910", "LastEditorUserId": "179910", "LastEditDate": "2015-06-01T23:27:42.997", "Id": "30584904", "Score": "6", "CreationDate": "2015-06-01T23:21:20.253", "LastActivityDate": "2015-06-01T23:27:42.997"}, "30584727": {"ParentId": "30584706", "PostTypeId": "2", "CommentCount": "11", "Body": "<p>Because the double is represented in a totally different format from the <code>int</code> (even if you assume they have the same sizes). A <code>double</code> uses a <a href=\"http://en.wikipedia.org/wiki/Floating_point\" rel=\"nofollow noreferrer\">floating point format</a>, whereas the <code>int</code> does not. Addressing a <code>double</code> with an <code>int</code> pointer is undefined behaviour. </p>\n<p>Related: <a href=\"https://stackoverflow.com/q/6725809/3093378\">trap representation</a>.</p>\n<p><strong>EDIT</strong> \nIf you are a beginner, it may seem quite strange that something like <code>int i = 3.14;</code> works, i.e. a <code>double</code> is converted to an <code>int</code>, however a pointer to <code>double</code> CANNOT be used to represent/convert-to an <code>int</code>. That's because in the first case the compiler takes care of the conversion, and automatically truncates <code>3.14</code> to <code>3</code> then represents the latter as an <code>int</code>, i.e. as <code>3</code>. Whereas the <code>double</code> representation of <code>3</code> looks completely different in the memory.</p>\n", "OwnerUserId": "3093378", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:45:57.150", "Id": "30584727", "Score": "6", "CreationDate": "2015-06-01T23:02:27.920", "LastActivityDate": "2015-06-01T23:28:48.550"}, "30584706": {"CommentCount": "2", "ViewCount": "2381", "PostTypeId": "1", "LastEditorUserId": "1410669", "CreationDate": "2015-06-01T23:00:10.907", "LastActivityDate": "2015-06-01T23:43:38.847", "Title": "Converting a double pointer to an int pointer", "AcceptedAnswerId": "30584727", "LastEditDate": "2015-06-01T23:03:37.777", "Id": "30584706", "Score": "-1", "Body": "<p>when i print <code>b</code> and <code>d</code> they both hold the same address ( address of <code>a</code> ).\nSo why does <code>*b</code> print <code>0</code> and <code>*d</code> print 5 ?</p>\n<pre><code> void main() \n {\n    double a = 5.0;\n    double *d = &amp;a;\n    int *b = (int*)d;\n    int a1 = 10;\n    cout &lt;&lt; \"Val of D : \" &lt;&lt; d &lt;&lt; \" Address of d :\" &lt;&lt; &amp;d\n         &lt;&lt; \" Value of *d :\" &lt;&lt; *d &lt;&lt; endl;\n    cout &lt;&lt; \"Val of B : \" &lt;&lt; b &lt;&lt; \" Address of B :\" &lt;&lt; &amp;b\n         &lt;&lt; \" Value of *b :\" &lt;&lt; *b &lt;&lt; endl;\n}\n</code></pre>\n", "Tags": "<c++><pointers><type-punning>", "OwnerUserId": "4536452", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_30584706_30585119_0": {"section_id": 7239, "quality": 1.0, "length": 14}}, "n3337": {"so_30584706_30585119_0": {"section_id": 6983, "quality": 1.0, "length": 14}}, "n4659": {"so_30584706_30585119_0": {"section_id": 8748, "quality": 1.0, "length": 14}}}});