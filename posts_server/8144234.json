post_cb({"8144268": {"ParentId": "8144234", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>I have no idea how the <code>SEHException</code> is related, but is your input in the format of:</p>\n<pre><code>std::istream&amp; in;\nstd::string line;\nwhile (std::getline(in, line)) {\n    //stuff\n}\n</code></pre>\n<p>That's the safest method for reading in line by line I've ever come across.</p>\n<p><code>I think it should at least throw an exception that unwinds the stack to find a handler or terminate</code><br>\n\u00a7 15.3 (From Feb 2011 C++ draft) </br></p>\n<blockquote>\n<p id=\"so_8144234_8144268_0\">If no matching handler is found, the function std::terminate() is called; whether or not the stack is unwound before this call to std::terminate() is implementation-defined (15.5.1).</p>\n</blockquote>\n<p>This means the debugger was <em>right about</em> to crash your entire program (probably without unwinding), but decided to be nice and break and show you what was happening first.  You'll have to step through the stack to see exactly why Windows decided to throw an <code>SEHException</code>.  According to some random web crawling, an SEH can be fired by the standard library when you access unallocated memory, dereference NULL pointers, run out of memory, or other situations.  You'll also want to try to look at the members of the SEHException object, to see what the status and message are.</p>\n", "OwnerUserId": "845092", "LastEditorUserId": "845092", "LastEditDate": "2011-11-16T01:07:01.073", "Id": "8144268", "Score": "3", "CreationDate": "2011-11-15T22:49:31.887", "LastActivityDate": "2011-11-16T01:07:01.073"}, "8144234": {"CommentCount": "1", "ViewCount": "569", "PostTypeId": "1", "LastEditorUserId": "866333", "CreationDate": "2011-11-15T22:46:36.770", "LastActivityDate": "2011-11-16T01:07:01.073", "Title": "Visual C++, std and getline(ifstream, string), EOF throws and breaks inside the std stack, is this normal?", "AcceptedAnswerId": "8144268", "LastEditDate": "2011-11-16T00:26:46.830", "Id": "8144234", "Score": "0", "Body": "<p>I remember all the hassle it used to be processing strings and ensuring that a newline was or wasn't appended before EOF.</p>\n<p>Now as my error references interop I am wondering if this is normal behaviour still or just an interop 'enhancement', here's my error:</p>\n<pre><code>A first chance exception of type 'System.Runtime.InteropServices.SEHException' occurred in blah.exe\nAn unhandled exception of type 'System.Runtime.InteropServices.SEHException' occurred in blah.exe\n\nAdditional information: External component has thrown an exception.\n</code></pre>\n<p>Not terribly helpful. If I must terminate with a new line that's cool but is the std library so far optimized that it can't handle the odd EOF?</p>\n<p>I think it should at least throw an exception that unwinds the stack to find a handler or terminate, but the stack is still deeply inside the std:: functions. Is this just a feature of the debug flags in VS?</p>\n<p><strong>EDIT</strong></p>\n<pre><code>    ifstream is(\"MyfileorSummat.txt\");\n    string line;\n    while (getline(is, line)) { //But when is reads last line @#&amp;#@, it breaks, in the middle of a chain of std calls.\n</code></pre>\n", "Tags": "<c++><interop><std><getline>", "OwnerUserId": "866333", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_8144234_8144268_0": {"section_id": 3354, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_8144234_8144268_0": {"section_id": 3224, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_8144234_8144268_0": {"section_id": 4121, "quality": 0.8571428571428571, "length": 12}}}});