post_cb({"32268576": {"CommentCount": "3", "CreationDate": "2015-08-28T10:12:57.213", "PostTypeId": "1", "AcceptedAnswerId": "32269299", "LastEditorUserId": "66191", "LastActivityDate": "2015-08-28T10:49:16.250", "LastEditDate": "2015-08-28T10:26:49.667", "ViewCount": "631", "FavoriteCount": "2", "Title": "C++ std::unique_ptr stored inside std::map use of deleted function ill formed", "Id": "32268576", "Score": "6", "Body": "<p>I have the following code which won't compile and it's Friday and I'm a bit frazzled.</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;memory&gt;\n#include &lt;utility&gt;\n#include &lt;map&gt;\n\ntemplate&lt; typename T, typename ...Args &gt;\nstd::unique_ptr&lt; T &gt; make_unique( Args &amp;&amp; ...args )\n{\n    return std::unique_ptr&lt; T &gt;( new T( std::forward&lt; Args &gt;( args )... ) );\n}\n\nstruct A\n{\n};\n\nstd::map&lt; std::string, std::unique_ptr&lt; A &gt; &gt; _map = { { \"A\", make_unique&lt; A &gt;() } }; // &lt;-- ERROR!!\n</code></pre>\n<p>The following compiles without a problem</p>\n<pre><code>int main()\n{\n    std::pair&lt; std::string, std::unique_ptr&lt; A &gt; &gt; p { \"B\", make_unique&lt; A &gt;() };\n    _map.insert( std::make_pair( \"C\", make_unique&lt; A &gt;() ) );\n}\n</code></pre>\n<p>The error I'm getting is (roughly, as removed g++ fluff)</p>\n<pre><code>use of deleted function 'constexpr std::pair&lt;...&gt;( const st::pair&lt;...&gt; &amp; )\n'constexp std::pair&lt;...&gt;::pair( const std::pair&lt;...&gt; &amp; ) is implicitly deleted because the default definition would be illegal.\n</code></pre>\n<p>Argghh!!\nJust read this in the c++11 standard.</p>\n<blockquote>\n<p id=\"so_32268576_32268576_0\">When an aggregate is initialized by an initializer list, as specified\n  in 8.5.4, the elements of the initializer list are taken as\n  initializers for the members of the aggregate, in increasing subscript\n  or member order. Each member is <strong>copy-initialized</strong> from the\n  corresponding initializer-clause</p>\n</blockquote>\n<p>bummer!!!</p>\n<p>Anyone know if it's just plain impossible with initialiser lists?</p>\n", "Tags": "<c++><dictionary><unique-ptr>", "OwnerUserId": "66191", "AnswerCount": "1"}, "32269299": {"ParentId": "32268576", "CommentCount": "1", "Body": "<p>You can't do much about it: elements in an initializer list are copied. This will not get along with classes that are move-only.</p>\n<p>There's a way to bypass this \"defect\" but it isn't very nice to read; you decide</p>\n<pre><code>using map_type  = std::map&lt; std::string, std::unique_ptr&lt; A &gt; &gt;;\nusing pair_type = map_type::value_type;\npair_type elements[] = { { \"A\", std::make_unique&lt; A &gt;() }, { \"B\", std::make_unique&lt; A &gt;() } };\n\nmap_type myMap { std::make_move_iterator( begin(elements) ), std::make_move_iterator( end(elements) ) };\n</code></pre>\n<p>which will make <code>myMap</code> iterate over the range and move the elements within, rather than copying. Method kindly taken from <a href=\"https://stackoverflow.com/questions/8468774/can-i-list-initialize-a-vector-of-move-only-type\">this</a> other question.</p>\n", "OwnerUserId": "2692339", "PostTypeId": "2", "Id": "32269299", "Score": "4", "CreationDate": "2015-08-28T10:49:16.250", "LastActivityDate": "2015-08-28T10:49:16.250"}, "bq_ids": {"n4140": {"so_32268576_32268576_0": {"section_id": 3299, "quality": 0.9565217391304348, "length": 22}}, "n3337": {"so_32268576_32268576_0": {"section_id": 3169, "quality": 0.9565217391304348, "length": 22}}, "n4659": {"so_32268576_32268576_0": {"section_id": 4065, "quality": 0.7391304347826086, "length": 17}}}});