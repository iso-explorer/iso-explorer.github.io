post_cb({"48331916": {"Id": "48331916", "PostTypeId": "2", "Body": "<p>First of all, the C++ standard itself barely says about padding bits. Essentially all discussion of padding bits comes from the base document (i.e., the C standard).</p>\n<p>So the real question is what the C standard says about things. Its footnote 54 gives a fairly concise summary of padding bits in general:</p>\n<blockquote>\n<p id=\"so_48331676_48331916_0\">Some combinations of padding bits might generate trap representations, for example, if one padding bit is a parity bit. Regardless, no arithmetic operation on valid values can generate a trap representation other than as part of an exceptional condition such as an overflow. All other combinations of padding bits are alternative object representations of the value specified by the value bits.</p>\n</blockquote>\n<p>Operators might change a padding big. The obvious case would be a padding bit that represented parity. If you change a value's parity, the parity bit would change to match.</p>\n<p>The \"alternative object representations of the value\" part basically mean that as long as you stay \"in bounds\", the padding bits don't affect your results. For example, if you compare two values, only the representation bits are used to determine the results (6.2.6.1/4):</p>\n<blockquote>\n<p id=\"so_48331676_48331916_1\">Two values (other than NaNs) with the same object representation compare equal, but values that compare equal may have different object representations.</p>\n</blockquote>\n<p>The times and places you have to be careful mostly involve undefined or implementation defined behavior. For example, if you store a value into one value in a union, then retrieve a different value in the union, it's possible the second could have the padding bits set to a trap representation, so even looking at the value that way could crash your program (or whatever).</p>\n<p>Likewise, if you were to take two values, <code>memcpy</code> each to an buffer of unsigned char, some bits of those bytes might compare as not-equal, even if the values they represented did compare equal.</p>\n<p>One place this can bit you even if you never use <code>mempy</code> directly is with some of the compare-and-exchange operators. These use <code>memcpy</code> and <code>memcmp</code> for the underlying operations, so they're also subject to comparing not equal, even though the values being represented are equal:</p>\n<p>[atomics.types.operations]/23:</p>\n<blockquote>\n<p id=\"so_48331676_48331916_2\">The memcpy and memcmp semantics of the compare-and-exchange operations may result in failed comparisons for values that compare equal with operator== if the underlying type has padding bits, trap bits, or alternate representations of the same value. Thus, compare_exchange_strong should be used with extreme care. On the other hand, compare_exchange_weak should converge rapidly.</p>\n</blockquote>\n<p>Side note: the two large quotes are descriptive, not normative--from a normative viewpoint, padding bits have almost no meaning; almost anything that could expose padding bits or their values involves implementation defined or undefined behavior. The only normative quote here is the one that basically says: \"padding bits have no effect.\"</p>\n", "LastActivityDate": "2018-01-18T23:24:21.707", "Score": "4", "CreationDate": "2018-01-18T23:24:21.707", "ParentId": "48331676", "CommentCount": "4", "OwnerUserId": "179910"}, "bq_ids": {"n4140": {"so_48331676_48331676_3": {"length": 14, "quality": 0.8235294117647058, "section_id": 6160}, "so_48331676_48331676_4": {"length": 16, "quality": 0.6666666666666666, "section_id": 6138}, "so_48331676_48331916_2": {"length": 32, "quality": 0.9696969696969697, "section_id": 1205}, "so_48331676_48331676_0": {"length": 26, "quality": 0.896551724137931, "section_id": 7210}, "so_48331676_48331676_2": {"length": 8, "quality": 0.8, "section_id": 7202}, "so_48331676_48331676_1": {"length": 34, "quality": 0.8095238095238095, "section_id": 7202}}, "n3337": {"so_48331676_48331676_3": {"length": 14, "quality": 0.8235294117647058, "section_id": 5921}, "so_48331676_48331676_4": {"length": 16, "quality": 0.6666666666666666, "section_id": 5902}, "so_48331676_48331916_2": {"length": 32, "quality": 0.9696969696969697, "section_id": 1203}, "so_48331676_48331676_0": {"length": 24, "quality": 0.8275862068965517, "section_id": 6954}, "so_48331676_48331676_2": {"length": 8, "quality": 0.8, "section_id": 6946}, "so_48331676_48331676_1": {"length": 34, "quality": 0.8095238095238095, "section_id": 6946}}, "n4659": {"so_48331676_48331676_3": {"length": 14, "quality": 0.8235294117647058, "section_id": 7657}, "so_48331676_48331676_4": {"length": 16, "quality": 0.6666666666666666, "section_id": 7635}, "so_48331676_48331916_2": {"length": 32, "quality": 0.9696969696969697, "section_id": 1285}, "so_48331676_48331676_0": {"length": 22, "quality": 0.7586206896551724, "section_id": 8719}, "so_48331676_48331676_2": {"length": 8, "quality": 0.8, "section_id": 8711}, "so_48331676_48331676_1": {"length": 34, "quality": 0.8095238095238095, "section_id": 8711}}}, "48331842": {"Id": "48331842", "PostTypeId": "2", "Body": "<p>If an implementation specifies a storage format for integer types that includes padding bits, it may write anything it likes to such bits when an object is written, and may impose any requirement it sees fit on the values such bits must hold, behaving in arbitrary fashion if that requirement isn't met, subject to two constraints:</p>\n<ol>\n<li><p>If any write to an object of such type has yielded a particular bit pattern, that bit pattern must be acceptable, and must yield the same value, when read from any object of that type.</p></li>\n<li><p>If all of the bits of an integer-type object are zero, the object must be regarded as valid and must read zero.</p></li>\n</ol>\n<p>If an implementation ignores padding bits on reads, bitwise operators may affect them or not in any manner the implementation sees fit.  If an implementation were to trap when the total number of \"1\" bits in a multi-byte integer is odd, but always write a padding bit value that made the total parity be even, bitwise operators would be required to compute the parity bit based upon the data bits and write it appropriately.</p>\n", "LastActivityDate": "2018-01-18T23:15:38.863", "Score": "1", "CreationDate": "2018-01-18T23:15:38.863", "ParentId": "48331676", "CommentCount": "4", "OwnerUserId": "363751"}, "48331676": {"ViewCount": "308", "Body": "<h2>C++ standard</h2>\n<p>If a <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"noreferrer\">C++14</a>\nimplementation includes padding bits in the underlying bytes of an <code>unsigned int</code> , does the standard specify if bitwise operations must not be performed on padding bits ?</p>\n<p>Additionally, does the C++14 standard specify if equality and relational\noperators must ignore the padding bits ?\n<br/><br/></p>\n<h2>Guidelines</h2>\n<p>If there is a lack of specification on that matter, is there some kind of\nconsensus on the expected behavior of those operators on padding bits?</p>\n<p>I found conflicting answers on Stack Overflow. <a href=\"https://stackoverflow.com/questions/29394518/whats-the-result-of-a-b/29394559#29394559\">Lightness Races in Orbit</a> and <a href=\"https://stackoverflow.com/questions/29394518/whats-the-result-of-a-b/29394674#29394674\">ecatmur</a> say that bitwise operators are unsuitable for arithmetic because they are applied on all bits (including padding bits), while <a href=\"https://stackoverflow.com/questions/4475540/c-question-padding-bits-in-unsigned-integers-and-bitwise-operations-c89/4475689#4475689\">Christoph</a> and <a href=\"https://stackoverflow.com/questions/29394518/whats-the-result-of-a-b/29394720#29394720\">Bartek Banachewicz</a> say that the bitwise operators work on the logical value of integers and ignore padding.\n<br><br/></br></p>\n<h2>References</h2>\n<p>Related answers: on the existence of padding bits\n(<a href=\"https://stackoverflow.com/questions/42297434/does-uint-max-have-all-bits-set-to-1/42297684#42297684\">1</a>,\n<a href=\"https://stackoverflow.com/questions/3949457/can-an-integer-be-nan-in-c/3949459#3949459\">2</a>,\n<a href=\"https://stackoverflow.com/questions/12125650/what-do-the-c-and-c-standards-say-about-bit-level-integer-representation-and-m/12125881#12125881\">3</a>),\non the absence of clear C++ specification\n(<a href=\"https://stackoverflow.com/questions/29394518/whats-the-result-of-a-b\">4</a>).</p>\n<p>Definition of padding bits in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3797.pdf\" rel=\"noreferrer\">C++14</a> - \u00a7 3.9.1 - Fundamental types:</p>\n<blockquote>\n<p id=\"so_48331676_48331676_0\">For narrow character types, all bits of the object representation participate in the value representation. For unsigned narrow character types, all possible bit patterns of the value representation represent numbers. These requirements do not hold for other types.</p>\n</blockquote>\n<p>Definition of object representation and value representation in C++14 - \u00a7 3.9 - Types:</p>\n<blockquote>\n<p id=\"so_48331676_48331676_1\">The <em>object representation</em> of an object of type <code>T</code> is the sequence of <em>N</em> <code>unsigned char</code> objects taken up by the object of type <code>T</code>, where <em>N</em> equals <code>sizeof(T)</code>. The <em>value representation</em> of an object is the set of bits that hold the value of type <code>T</code>. For trivially copyable types, the value representation is a set of bits in the object representation that determines a <em>value</em>, which is one discrete element of an implementation-defined set of values.<sup>44</sup></p>\n<p id=\"so_48331676_48331676_2\">Footnote 44) The intent is that the memory model of C++ is compatible with that of ISO/IEC 9899 Programming Language C.</p>\n</blockquote>\n<p>Definition of bitwise AND in C++14 - \u00a7 5.11 - Bitwise AND operator:</p>\n<blockquote>\n<p id=\"so_48331676_48331676_3\">The usual arithmetic conversions are performed; the result is the bitwise AND function of the operands. The operator applies only to integral or unscoped enumeration operands.</p>\n</blockquote>\n<p>Definition of addition in C++14 - \u00a7 5.7 - Additive operators:</p>\n<blockquote>\n<p id=\"so_48331676_48331676_4\">The usual arithmetic conversions are performed for operands of arithmetic or enumeration type. For addition, [...] both operands shall have arithmetic or unscoped enumeration type [...]. The result of the binary <code>+</code> operator is the sum of the operands.</p>\n</blockquote>\n", "Title": "Does C++14 define the behavior of bitwise operators on the padding bits of unsigned int?", "CreationDate": "2018-01-18T22:57:45.813", "LastActivityDate": "2018-01-18T23:24:21.707", "CommentCount": "14", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2018-01-18T23:03:14.383", "LastEditorUserId": "2587908", "Id": "48331676", "Score": "9", "OwnerUserId": "9232450", "Tags": "<c++><c++14><bitwise-operators><unsigned-integer><unspecified-behavior>", "AnswerCount": "2"}});