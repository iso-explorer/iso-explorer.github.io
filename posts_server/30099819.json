post_cb({"30100102": {"ParentId": "30099819", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>C++ doesn't have normal Unicode support. You just can't wirte normally globalized application in C++ without using 3rd party libraries. Read <a href=\"https://stackoverflow.com/questions/17103925/how-well-is-unicode-supported-in-c11\">this</a> insightful SO answer. If you really need to write an application which uses Unicode I'd look at <a href=\"http://site.icu-project.org\" rel=\"nofollow noreferrer\">ICU</a> library.</p>\n", "OwnerUserId": "643393", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:06:33.787", "Id": "30100102", "Score": "3", "CreationDate": "2015-05-07T11:43:53.537", "LastActivityDate": "2015-05-07T11:43:53.537"}, "30102182": {"ParentId": "30099819", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>On Windows, Microsoft <a href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/ff381407%28v=vs.85%29.aspx\" rel=\"nofollow noreferrer\">guarantees</a> that <code>wchar_t</code> supports Unicode, so <code>L\"\ud57c\ub85c\"</code> is the correct way to produce a UTF-16 string literal as a <code>const wchar_t*</code>. On other platforms, this doesn't necessarily hold, and you should use the C++11 Unicode string literals (<code>u8\"...\"</code>, <code>u\"...\"</code>, and <code>U\"...\"</code>) if you need your code to be portable\u2014e.g., use <code>u8\"\ud57c\ub85c\"</code> to produce a UTF-8 encoded <code>const char*</code> (as of Visual Studio 2015).</p>\n<p>The other problem you are encountering is with how Visual Studio interprets the encoding of your source file. For example, <code>\u304a</code> is encoded as <code>0xAA 0xAA</code> in EUC-KR (code page 949), which is the encoding for <code>\u00aa\u00aa</code> in code page 1252 (fr-FR)\u2014that is, if you saved your source file containing <code>\u304a</code> in EUC-KR but compile it in an fr-FR locale, your literal will encode <code>\u00aa\u00aa</code>.</p>\n<p>If you need to include non-ASCII characters in your source, you should save them with in a UTF (i.e., UTF-8/16/32) with an explicit BOM\u2014described in the <a href=\"https://stackoverflow.com/a/1660901/596219\">answer to this question</a>.</p>\n", "OwnerUserId": "596219", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T12:21:52.580", "Id": "30102182", "Score": "2", "CreationDate": "2015-05-07T13:14:49.680", "LastActivityDate": "2015-05-07T13:14:49.680"}, "30099819": {"CommentCount": "2", "AcceptedAnswerId": "30100102", "CreationDate": "2015-05-07T11:31:06.437", "LastActivityDate": "2015-05-07T13:14:49.680", "PostTypeId": "1", "ViewCount": "668", "FavoriteCount": "4", "Title": "c++ string literal still confusing", "Id": "30099819", "Score": "9", "Body": "<p>I've been reading some articles about Unicode and realized I'm still left confused what to exactly do about it.</p>\n<p>As a c++ programmer on Windows platform, the disciplines given to me were mostly same from any teacher: always use Unicode character set; templatize it or use TCHAR if possible; prefer wchar_t, std::wstring over char, std::string.</p>\n<pre><code>#include &lt;tchar.h&gt;\n#include &lt;string&gt;\ntypedef std::basic_string&lt;TCHAR&gt; tstring;\n // ...\nstatic const char* const s_hello = \"\ud57c\ub85c\"; // bad\nstatic const wchar_t* const s_wchar_hello = L\"\ud57c\ub85c\" // better\nstatic LPCTSTR s_tchar_hello = TEXT(\"\ud57c\ub85c\") // even better\nstatic const tstring s_tstring_hello( TEXT(\"\ud57c\ub85c\") ); // best\n</code></pre>\n<p>Somehow I messed up, and I lead myself to believe that If I say \"something\", that means it is ASCII formatted, and if I say L\"something\" it is Unicode. Then I read this:</p>\n<blockquote>\n<p id=\"so_30099819_30099819_0\">Type wchar_t is a distinct type whose values can represent distinct codes for all members of the largest extended character set specified among the supported locales (22.3.1). Type wchar_t shall have the same size, signedness, and alignment requirements (3.11) as one of the other integral types, called its underlying type. Types char16_t and char32_t denote distinct types with the same size, signedness, and alignment as uint_least16_t and uint_least32_t, respectively, in , called the underlying types.</p>\n</blockquote>\n<p>So what? If my locale says start from codepage 949, the extend of wchar_t is from 949 + 2^(sizeof(wchar_t)*8)? And the way it speaks sounds like 'I don't care if your implementation of c++ use UTF encoding or what'.</p>\n<p>At least, I could understand that everything depends on what locale the application is on. Thus I tested:</p>\n<pre><code>#define TEST_OSTREAM_PRINT(x) \\\nstd::cout &lt;&lt; \"----\" &lt;&lt; std::endl; \\\nstd::cout &lt;&lt; \"cout : \" &lt;&lt; x &lt;&lt; std::endl; \\\nstd::wcout &lt;&lt; \"wcout : \" &lt;&lt; L##x &lt;&lt; std::endl;\n\nint main()\n{\n    std::ostream&amp; os = std::cout;\n\n    std::cout &lt;&lt; \" * Info : \" &lt;&lt; std::endl\n              &lt;&lt; \"     sizeof(char) : \" &lt;&lt; sizeof(char) &lt;&lt; std::endl\n              &lt;&lt; \"     sizeof(wchar_t) : \" &lt;&lt; sizeof(wchar_t) &lt;&lt; std::endl\n              &lt;&lt; \"     littel endian? : \" &lt;&lt; IsLittelEndian() &lt;&lt; std::endl;\n    std::cout &lt;&lt; \" - LC_ALL: \" &lt;&lt; setlocale(LC_ALL, NULL) &lt;&lt; std::endl;\n    std::cout &lt;&lt; \" - LC_CTYPE: \" &lt;&lt; setlocale(LC_CTYPE, NULL) &lt;&lt; std::endl;\n\n    TEST_OSTREAM_PRINT(\"\ud57c\ub85c\");\n    TEST_OSTREAM_PRINT(\"\u304a\u306f\u3088\u3046\u3002\");\n    TEST_OSTREAM_PRINT(\"\u4f60\u597d\");\n    TEST_OSTREAM_PRINT(\"resume\");\n    TEST_OSTREAM_PRINT(\"r\u00e9sum\u00e9\");\n\n    return 0;\n}\n</code></pre>\n<p>Then output was:</p>\n<pre><code>Info\n sizeof(char) = 1\n sizeof(wchar_t) = 2\n LC_ALL = C\n LC_CTYPE = C\n----\ncout : \ud57c\ub85c\nwcout : ----\ncout : \u304a\u306f\u3088\u3046\u3002\nwcout : ----\ncout : ?\u597d\nwcout : ----\ncout : resume\nwcout : resume\n----\ncout : r?sum?\nwcout : r?um\n</code></pre>\n<p>Another output with Korean locale:</p>\n<pre><code>Info\n sizeof(char) = 1\n sizeof(wchar_t) = 2\n LC_ALL = Korean_Korea.949\n LC_CTYPE = Korean_Korea.949\n----\ncout : \ud57c\ub85c\nwcout : \ud57c\ub85c\n----\ncout : \u304a\u306f\u3088\u3046\u3002\nwcout : \u304a\u306f\u3088\u3046\u3002\n----\ncout : ?\u597d\nwcout : ----\ncout : resume\nwcout : resume\n----\ncout : r?sum?\nwcout : resume\n</code></pre>\n<p>Another output:</p>\n<pre><code>Info\n sizeof(char) = 1\n sizeof(wchar_t) = 2\n LC_ALL = fr-FR\n LC_CTYPE = fr-FR\n----\ncout : CU\u00b7I\nwcout : ----\ncout : \u00aa\u00aa\u00aaI\u00aae\u00aa|\u00a1\uffe1\nwcout : ----\ncout : ?u\u00bf\nwcout : ----\ncout : resume\nwcout : resume\n----\ncout : r?sum?\nwcout : resume\n</code></pre>\n<p>It turns out If I don't give the right locale, application fails to handle certain range of characters, no matter I used char or wchar_t. That's not only problem. Visual studio gives warning:</p>\n<pre><code>warning C4566: character represented by universal-character-name '\\u4F60' cannot be represented in the current code page (949)\n</code></pre>\n<p>I'm not sure if this is describing what I'm getting as output or something else.</p>\n<p>Question. What would be the best practices and why? How one can make an application platform/implementation/nation independent? what exactly happens to string literals on the source? how are string values are interpreted by application?</p>\n", "Tags": "<c++><unicode>", "OwnerUserId": "2883715", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_30099819_30099819_0": {"section_id": 7214, "quality": 0.9444444444444444, "length": 51}}, "n3337": {"so_30099819_30099819_0": {"section_id": 6958, "quality": 0.9444444444444444, "length": 51}}, "n4659": {"so_30099819_30099819_0": {"section_id": 8723, "quality": 0.9259259259259259, "length": 50}}}});