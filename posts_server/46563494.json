post_cb({"bq_ids": {"n4140": {"so_46563494_46576503_0": {"length": 10, "quality": 0.5263157894736842, "section_id": 6137}}, "n3337": {"so_46563494_46576503_0": {"length": 10, "quality": 0.5263157894736842, "section_id": 5901}}, "n4659": {"so_46563494_46576503_0": {"length": 10, "quality": 0.5263157894736842, "section_id": 7634}}}, "46576503": {"Id": "46576503", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_46563494_46576503_0\"><strong>[expr.mul]/4</strong> The binary <code>/</code> operator yields the quotient, and the binary <code>%</code> operator yields the remainder from the division of the first expression by the second. If the second operand of <code>/</code> or <code>%</code> is zero the behavior is undefined...</p>\n</blockquote>\n<p>When zero is entered for <code>number2</code>, your program exhibits undefined behavior. Which means that any outcome at all is possible; the C++ standard places no requirements on the behavior of such a program.</p>\n", "LastActivityDate": "2017-10-05T01:26:42.540", "Score": "0", "CreationDate": "2017-10-05T01:26:42.540", "ParentId": "46563494", "CommentCount": "4", "OwnerUserId": "1670129"}, "46563494": {"ViewCount": "32", "Body": "<p>To avoid stacking catch blocks in writing exception handling code, I thought to try to write a catch-all exception handler using the c++11 features. In doing so I noticed some odd behavior that worked the same way on both Centos 7 and Windows 7 and 8.1 using Code::Blocks IDE on both systems (you have to check the settings-&gt;compiler-&gt;c++11 ISO checkbox to get this to work.) I had two kinds of exceptions, a hardware divide by zero <em>(number1/number2)</em> and a synthetic divide by zero function <em>quotient(number1, number2)</em> that throws a declared exception when there is a zero denominator. Here's the code:</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;exception&gt;\n#include &lt;typeinfo&gt;\n#include &lt;stdexcept&gt;\n\nusing namespace std;\n\nclass DivideByZero : public runtime_error\n{\npublic:\n    DivideByZero() :\n        runtime_error(\"Divide by zero exception\") {}\n};\n\ntemplate &lt;typename T&gt;\nT quotient(T numer, T denom)\n{\n    if (denom == 0)\n    {\n        throw DivideByZero();\n    }\n    else\n    {\n        return numer / denom;\n    }\n}\n\nint main()\n{\n    double number1, number2, ratio;\n    cout &lt;&lt; \"Enter a numerator: \";\n    cin &gt;&gt; number1;\n    cout &lt;&lt; \"Enter a denominator: \";\n    cin &gt;&gt; number2;\n    try\n    {\n        ratio = number1/number2;\n        //ratio = quotient(number1, number2);\n        cout &lt;&lt; \"Result is: \" &lt;&lt; ratio &lt;&lt; endl;\n    }\n    catch (...)\n    {\n        std::exception_ptr p = std::current_exception();\n        cerr &lt;&lt; \"Exception: \"\n             &lt;&lt; (p ?\n                 p.__cxa_exception_type()-&gt;name() :\n                 \"Anonymous\")\n             &lt;&lt; endl;\n    }\n    return 0;\n}\n</code></pre>\n<p>I would comment out the hardware or the synthetic division code line and then build/run with different integer and real types.</p>\n<p>The results were similar on both Centos 7 and the Windows systems, for i5 and i7 Intel processors.</p>\n<p>When executing the synthetic divide (quotient) line that throws a declared exception on all systems, it worked the same way for all the integer and real types, correctly printing out the exception number and the declared exception text to cerr: </p>\n<pre><code>Exception: 12DivideByZero\n</code></pre>\n<p>Pretty nice, no more stacking exceptions and missing any that might occur!</p>\n<p>However, when executing the hardware divide line (number1/number2) for both integer and real types, the exception handling was bypassed completely in different ways. For real types like double, the exception is caught and the the cerr text is not printed, what comes out is the display line printed after the code causing the exception, <strong>which you should not see</strong> and what appears to be the infinite value for all the real types: </p>\n<pre><code>Result is: inf\n</code></pre>\n<p>For all integer types you don't even get that, you get no display line and on Linux it ends normally, on Windows it dies and goes looking for a solution to your bad program.</p>\n<p>Seems odd to me, I'm sure some maven will explain the lack of consistency in exception handling in c++11.</p>\n<p>the Code::Blocks on both Windows systems was using a recent download of the mingw32-g++.exe for compiling, and of course, Centos 7 is using the 64 bit g++ compiler. Not that it made any difference, the systems behaved similarly.</p>\n", "Title": "exception_ptr in a catch-all handler works oddly on both Centos 7 and Windows", "CreationDate": "2017-10-04T11:17:48.017", "LastActivityDate": "2017-10-05T01:26:42.540", "CommentCount": "3", "LastEditDate": "2017-10-04T11:43:18.963", "PostTypeId": "1", "LastEditorUserId": "15416", "Id": "46563494", "Score": "0", "OwnerUserId": "8711164", "Tags": "<c++><linux><windows><c++11>", "AnswerCount": "1"}});