post_cb({"12167294": {"CommentCount": "1", "Body": "<p>Implementation details.</p>\n<blockquote>\n<p id=\"so_12167220_12167294_0\">(C99, 5.1.2.3p1) \"The semantic descriptions in this International Standard describe the behavior of an abstract machine in which issues of optimization are irrelevant.\"</p>\n</blockquote>\n", "CreationDate": "2012-08-28T20:47:30.993", "ParentId": "12167220", "Id": "12167294", "LastActivityDate": "2012-08-28T20:47:30.993", "PostTypeId": "2", "Score": "1", "OwnerUserId": "1119701"}, "12167301": {"LastActivityDate": "2012-08-28T21:00:16.463", "CommentCount": "5", "Body": "<p>Yes. C99 6.5.10:6</p>\n<blockquote>\n<p id=\"so_12167220_12167301_0\"><strong>Two pointers compare equal if and only if</strong> both are null pointers, <strong>both\n  are pointers to the same</strong> object (including a pointer to an object and\n  a subobject at its beginning) or <strong>function</strong>, \u2026</p>\n</blockquote>\n<p>Edit: the rest of the paragraph, since it turns out to have some importance:</p>\n<blockquote>\n<p id=\"so_12167220_12167301_1\">both are pointers to one past the last element of the same array\n  object, or one is a pointer to one past the end of one array object\n  and the other is a pointer to the start of a different array object\n  that happens to immediately follow the first array object in the\n  address space.</p>\n</blockquote>\n<p>What I take from it:</p>\n<ul>\n<li>equality applied to the wrong operands is, in so many words, unspecified. It can be accidentally true for extraneous reasons but it is not undefined when you use it wrong the way <code>&lt;</code> is undefined when you use it wrong.</li>\n<li>to the best of my understanding, the rest of the paragraph does not apply to functions, because a function neither is an object nor can it be an element of an array.</li>\n</ul>\n", "CreationDate": "2012-08-28T20:48:30.667", "LastEditDate": "2012-08-28T21:00:16.463", "ParentId": "12167220", "Id": "12167301", "LastEditorUserId": "139746", "PostTypeId": "2", "Score": "3", "OwnerUserId": "139746"}, "12167321": {"LastActivityDate": "2012-08-28T22:01:43.013", "CommentCount": "0", "Body": "<p>Many compilers with optimizations turned on will make two functions have the same address. For example, from <a href=\"http://msdn.microsoft.com/en-us/library/bxwfs976%28v=vs.110%29.aspx\" rel=\"nofollow\">msdn</a>:</p>\n<blockquote>\n<p id=\"so_12167220_12167321_0\">/OPT:ICF <strong>can result in the same address being assigned to different\n  functions</strong> or read only data members (const variables compiled with\n  /Gy). So, /OPT:ICF can break a program that depends on the address of\n  functions or read-only data members being different. See /Gy (Enable\n  Function-Level Linking) for more information.</p>\n</blockquote>\n<p><strong>ICF</strong>: Identical Code Folding</p>\n", "CreationDate": "2012-08-28T20:49:39.690", "LastEditDate": "2012-08-28T22:01:43.013", "ParentId": "12167220", "Id": "12167321", "LastEditorUserId": "906773", "PostTypeId": "2", "Score": "2", "OwnerUserId": "906773"}, "12167352": {"LastActivityDate": "2012-08-29T06:49:09.810", "CommentCount": "2", "Body": "<p>The C++11 standard says</p>\n<blockquote>\n<p id=\"so_12167220_12167352_0\"><strong>5.10 Equality operators</strong><br>\n  Pointers of the same type (after pointer conversions) can be compared for equality. Two pointers of the same type compare equal if and only if they are both null, both point to the same function, or both represent the same address (3.9.2).</br></p>\n</blockquote>\n<p>If you don't have any pointers to the functions, they just might have the same address, but we wouldn't know. If you <em>are</em> comparing pointers to two different functions, they must not compare equal.</p>\n<hr>\n<p>One cause for confusion might be that the MSVC compilers are known to combine code for template functions that happen to produce identical machine code for different types (like <code>int</code> and <code>long</code>). This is not compliant.</p>\n<p>However, this is for functions with <em>different</em> signatures, and not exactly what this question is about.</p>\n</hr>", "CreationDate": "2012-08-28T20:52:19.480", "LastEditDate": "2012-08-29T06:49:09.810", "ParentId": "12167220", "Id": "12167352", "LastEditorUserId": "597607", "PostTypeId": "2", "Score": "7", "OwnerUserId": "597607"}, "bq_ids": {"n4140": {"so_12167220_12167352_0": {"length": 17, "quality": 0.5666666666666667, "section_id": 6155}, "so_12167220_12167301_1": {"length": 16, "quality": 0.5161290322580645, "section_id": 6143}}, "n3337": {"so_12167220_12167352_0": {"length": 27, "quality": 0.9, "section_id": 5917}, "so_12167220_12167301_1": {"length": 16, "quality": 0.5161290322580645, "section_id": 5907}}}, "12167220": {"CreationDate": "2012-08-28T20:41:45.737", "ViewCount": "198", "Id": "12167220", "AcceptedAnswerId": "12167352", "Score": "7", "Title": "Pointers of several functions", "CommentCount": "0", "Body": "<p>Is there any guarantees that the functions which differs only by its names (not parameters and return type also) can't share the same address in C and C++? I don't see anything about it in the standard.</p>\n<pre><code>#include &lt;cassert&gt;\n\nvoid foo() {}\n\nvoid bar() {}\n\nint main()\n{\n    assert(foo != bar);\n}\n</code></pre>\n", "Tags": "<c++><c>", "LastActivityDate": "2012-08-29T06:49:09.810", "PostTypeId": "1", "AnswerCount": "4", "OwnerUserId": "1608835"}});