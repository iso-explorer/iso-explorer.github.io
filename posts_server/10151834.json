post_cb({"bq_ids": {"n4140": {"so_10151834_10152170_1": {"length": 107, "quality": 0.9469026548672567, "section_id": 7210}}, "n3337": {"so_10151834_10152170_1": {"length": 107, "quality": 0.9469026548672567, "section_id": 6954}}, "n4659": {"so_10151834_10152170_1": {"length": 103, "quality": 0.911504424778761, "section_id": 8719}}}, "10152888": {"Id": "10152888", "PostTypeId": "2", "Body": "<p>Aside from being pointers, <code>unsigned char *</code> and <code>char *</code> have nothing in common (EdChum already mentioned the fact that <code>char</code>, <code>signed char</code> and <code>unsigned char</code> are three different types). You could say the same thing for <code>Foo *</code> and <code>Bar *</code> pointer types to any dissimilar structures.</p>\n<p><code>static_cast</code> means that a pointer of the source type can be used as a pointer of the destination type, which requires a subtype relationship. Hence it cannot be used in the context of your question; what you need is either <code>reinterpret_cast</code> which does exactly what you want or a C-style cast.</p>\n", "LastActivityDate": "2012-04-14T10:31:03.663", "CommentCount": "0", "CreationDate": "2012-04-14T10:31:03.663", "ParentId": "10151834", "Score": "4", "OwnerUserId": "149530"}, "10152170": {"Id": "10152170", "PostTypeId": "2", "Body": "<p>They are completely different types see standard:</p>\n<blockquote>\n<p id=\"so_10151834_10152170_0\">3.9.1  Fundamental types                           [basic.fundamental]</p>\n<p id=\"so_10151834_10152170_1\">1 Objects  declared  as  characters char) shall be large enough to\n  store   any member of the implementation's basic  character set.  If a\n  character  from this set is stored in a character object, the integral\n  value  of that character object is equal to the value of the single\n  character   literal  form of that character.  It is\n  implementation-defined whether   a char object can hold negative\n  values.  Characters can be  explicitly   declared   unsigned   or<br>\n  signed.    <strong><em>Plain   char,  signed char,  and   unsigned char are\n  three distinct types.</em></strong>  A char, a signed char, and an  unsigned char\n  occupy  the  same  amount  of storage and have the same  alignment\n  requirements (<em>basic.types</em>); that is, they  have  the  same   object \n  representation.   For  character types, all bits of the object<br>\n  representation participate in the value representation.  For  unsigned\n  character types, all possible bit patterns of the value representation\n  represent numbers. These requirements do not hold for other types.  In\n  any  particular implementation, a plain char object can take on either\n  the same values as a signed char or an  unsigned char; which  one  is \n  implementation-defined.</br></br></p>\n</blockquote>\n<p>So analogous to this is also why the following fails:</p>\n<pre><code>unsigned int* a = new unsigned int(10);\nint* b = static_cast&lt;int*&gt;(a); // error different types\n</code></pre>\n<p><code>a</code> and <code>b</code> are completely different types, really what you are questioning is why is static_cast so restrictive when it can perform the following without problem</p>\n<pre><code>unsigned int a = new unsigned int(10);\nint b = static_cast&lt;int&gt;(a); // OK but may result in loss of precision\n</code></pre>\n<p>and why can it not deduce that the target types are the same bit-field width and can be represented? It can do this for scalar types but for pointers, unless the target is derived from the source and you wish to perform a downcast then casting between pointers is not going to work.</p>\n<p>Bjarne Stroustrop states why <code>static_cast</code>'s are useful in this link: <a href=\"http://www.stroustrup.com/bs_faq2.html#static-cast\" rel=\"noreferrer\">http://www.stroustrup.com/bs_faq2.html#static-cast</a> but in abbreviated form it is for the user to state clearly what their intentions are and to give the compiler the opportunity to check that what you are intending can be achieved, since <code>static_cast</code> does not support casting between different pointer types then the compiler can catch this error to alert the user and if they really want to do this conversion they then should use <code>reinterpret_cast</code>.</p>\n", "LastEditorUserId": "853569", "LastActivityDate": "2015-04-30T10:00:23.320", "Score": "26", "CreationDate": "2012-04-14T08:26:34.850", "ParentId": "10151834", "CommentCount": "11", "OwnerUserId": "704848", "LastEditDate": "2015-04-30T10:00:23.320"}, "10151834": {"ViewCount": "20206", "Body": "<p>Apparently the compiler considers them to be unrelated types and hence <code>reinterpret_cast</code> is required. Why is this the rule?</p>\n", "AcceptedAnswerId": "10152170", "Title": "Why can't I static_cast between char * and unsigned char *?", "CreationDate": "2012-04-14T07:21:56.460", "Id": "10151834", "CommentCount": "4", "FavoriteCount": "6", "PostTypeId": "1", "LastActivityDate": "2015-04-30T10:00:23.320", "Score": "31", "OwnerUserId": "430154", "Tags": "<c++><char><reinterpret-cast><static-cast><unsigned-char>", "AnswerCount": "3"}, "10151970": {"Id": "10151970", "PostTypeId": "2", "Body": "<p>you're trying to convert unrelated pointers with a static_cast. That's not what static_cast is for. Here you can see: <a href=\"http://www.cplusplus.com/doc/tutorial/typecasting/\" rel=\"nofollow\">Type Casting</a>.</p>\n<p>With static_cast you can convert numerical data (e.g. char to unsigned char should work) or pointer to related classes (related by some inheritance). This is both not the case. You want to convert one unrelated pointer to another so you have to use reinterpret_cast.</p>\n<p>Basically what you are trying to do is for the compiler the same as trying to convert a char * to a void *.</p>\n<hr>\n<p>Ok, here some additional thoughts why allowing this is fundamentally wrong. static_cast can be used to convert numerical types into each other. So it is perfectly legal to write the following:</p>\n<pre><code>char x = 5;\nunsigned char y = static_cast&lt;unsigned char&gt;(x);\n</code></pre>\n<p>what is also possible:</p>\n<pre><code>double d = 1.2;\nint i = static_cast&lt;int&gt;(d);\n</code></pre>\n<p>If you look at this code in assembler you'll see that the second cast is not a mere re-interpretation of the bit pattern of d but instead some assembler instructions for conversions are inserted here.</p>\n<p>Now if we extend this behavior to arrays, the case where simply a different way of interpreting the bit pattern is sufficient, it might work. But what about casting arrays of doubles to arrays of ints?\nThat's where you either have to declare that you simple want a re-interpretation of the bit patterns - there's a mechanism for that called reinterpret_cast, or you must do some extra work. As you can see simple extending the static_cast for pointer / arrays is not sufficient since it needs to behave similar to static_casting single values of the types. This sometimes needs extra code and it is not clearly definable how this should be done for arrays. In your case - stopping at \\0 - because it's the convention? This is not sufficient for non-string cases (number). What will happen if the size of the data-type changes (e.g. int vs. double on x86-32bit)?</p>\n<p>The behavior you want can't be properly defined for all use-cases that's why it's not in the C++ standard. Otherwise you would have to remember things like: \"i can cast this type to the other as long as they are of type integer, have the same width and ...\". This way it's totally clear - either they are related CLASSES - then you can cast the pointers, or they are numerical types - then you can cast the values.</p>\n</hr>", "LastEditorUserId": "79996", "LastActivityDate": "2012-04-14T11:02:38.157", "Score": "5", "CreationDate": "2012-04-14T07:45:52.300", "ParentId": "10151834", "CommentCount": "4", "OwnerUserId": "79996", "LastEditDate": "2012-04-14T11:02:38.157"}});