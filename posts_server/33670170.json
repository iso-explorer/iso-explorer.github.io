post_cb({"33670433": {"ParentId": "33670170", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_33670170_33670433_0\">how does the standard library distinguish 0 from 5 at compilation time, if these literals aren't template arguments?</p>\n</blockquote>\n<p>This has nothing to do with the standard library at all, <code>nullptr_t</code> is a built-in type known to the compiler, and obviously the compiler knows the difference between <code>5</code> and <code>0</code></p>\n<blockquote>\n<p id=\"so_33670170_33670433_1\">Can one create a custom class which would similarly distinguish arguments of its constructor at compilation time, not using <code>std::nullptr_t</code> for this?</p>\n</blockquote>\n<p>In general no.</p>\n<p>You can write a type that can be initialized from <code>0</code> and not from <code>5</code> by making it take an argument of a pointer type, because <code>0</code> is a valid null pointer constant but <code>5</code> is not. But you couldn't write a type that can be constructed from <code>3</code> and not from <code>5</code>, or anything else like that.</p>\n", "OwnerUserId": "981959", "PostTypeId": "2", "Id": "33670433", "Score": "11", "CreationDate": "2015-11-12T11:29:51.523", "LastActivityDate": "2015-11-12T11:29:51.523"}, "33670170": {"CommentCount": "1", "AcceptedAnswerId": "33670255", "CreationDate": "2015-11-12T11:13:58.500", "LastActivityDate": "2015-11-12T20:14:10.390", "PostTypeId": "1", "ViewCount": "1106", "FavoriteCount": "1", "Title": "How is 0 distinguished from other integers when initializing nullptr_t?", "Id": "33670170", "Score": "19", "Body": "<p>As I understand, <code>std::nullptr_t</code> can be initialized from <code>nullptr</code> as well as from <code>0</code>. But at the same time the third initialization below doesn't work, despite <code>5</code> has the same type as <code>0</code>:</p>\n<pre><code>#include &lt;memory&gt;\n\nint main()\n{\n    std::nullptr_t null1=0;\n    std::nullptr_t null2=nullptr;\n    std::nullptr_t null3=5; // error: cannot convert \u2018int\u2019 to \u2018std::nullptr_t\u2019 in initialization\n}\n</code></pre>\n<p>How does this work? I.e. how does the standard library distinguish <code>0</code> from <code>5</code> at compilation time, if these literals aren't template arguments?</p>\n<p>Can one create a custom class which would similarly distinguish arguments of its constructor at compilation time, not using <code>std::nullptr_t</code> for this?</p>\n", "Tags": "<c++><types><type-conversion>", "OwnerUserId": "673852", "AnswerCount": "3"}, "33670325": {"ParentId": "33670170", "PostTypeId": "2", "CommentCount": "0", "Body": "<blockquote>\n<p id=\"so_33670170_33670325_0\"><code>N3337 [conv.ptr]/1:</code> <strong>A null pointer constant is an integral constant expression prvalue of integer type that evaluates to\n  zero</strong> or a prvalue of type <code>std::nullptr_t</code>. A null pointer constant can be converted to a pointer type; the\n  result is the null pointer value of that type and is distinguishable from every other value of object pointer or\n  function pointer type. Such a conversion is called a null pointer conversion. Two null pointer values of the\n  same type shall compare equal. The conversion of a null pointer constant to a pointer to cv-qualified type is\n  a single conversion, and not the sequence of a pointer conversion followed by a qualification conversion. <strong>A null pointer constant of integral type can be converted to a prvalue of type <code>std::nullptr_t</code>.</strong></p>\n</blockquote>\n<p><code>0</code> is a null pointer constant of integral type, so it can be converted to a prvalue of type <code>std::nullptr_t</code>. <code>5</code> is not a null pointer constant, so it can't be.</p>\n", "OwnerUserId": "496161", "LastEditorUserId": "496161", "LastEditDate": "2015-11-12T11:33:04.667", "Id": "33670325", "Score": "11", "CreationDate": "2015-11-12T11:23:31.310", "LastActivityDate": "2015-11-12T11:33:04.667"}, "bq_ids": {"n4140": {"so_33670170_33670255_1": {"section_id": 39, "quality": 0.9512195121951219, "length": 39}, "so_33670170_33670325_0": {"section_id": 39, "quality": 0.8441558441558441, "length": 65}}, "n3337": {"so_33670170_33670255_1": {"section_id": 36, "quality": 0.9024390243902439, "length": 37}, "so_33670170_33670325_0": {"section_id": 36, "quality": 0.922077922077922, "length": 71}}, "n4659": {"so_33670170_33670255_1": {"section_id": 39, "quality": 0.9512195121951219, "length": 39}, "so_33670170_33670325_0": {"section_id": 39, "quality": 0.8441558441558441, "length": 65}}}, "33670255": {"ParentId": "33670170", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>A <code>nullptr_t</code> can be only assigned the value <code>nullptr</code> or <code>0</code> which is implicitly converted.</p>\n<p>According to N4296 (page.86): </p>\n<blockquote>\n<p id=\"so_33670170_33670255_0\"><strong>4.10    Pointer conversions</strong> </p>\n<p id=\"so_33670170_33670255_1\">A <em>null pointer constant</em> is an <strong>integer literal</strong> with value <strong>zero</strong>\n  or a prvalue of type <code>std::nullptr_t</code>. A null pointer constant can be\n  converted to a pointer type; the result is the <em>null pointer value</em> of\n  that type and is distinguishable from every other value of object\n  pointer or function pointer type. [...] A null pointer constant of\n  integral type can be <strong>converted</strong> to a prvalue of type <code>std::nullptr_t</code>. </p>\n</blockquote>\n<p>You can <strong>not</strong> create a similar type within C++ yourself.</p>\n<p><code>std::nullptr_t</code> is implemented as a <strong>built-in</strong> type and its distinct properties are enforced by the compiler.</p>\n<hr>\n<p><em>EDIT: Fixed  paragraph on built-in types. Thanks Yakk!</em></p>\n</hr>", "OwnerUserId": "2430189", "LastEditorUserId": "2430189", "LastEditDate": "2015-11-12T20:14:10.390", "Id": "33670255", "Score": "21", "CreationDate": "2015-11-12T11:19:37.557", "LastActivityDate": "2015-11-12T20:14:10.390"}});