post_cb({"13227449": {"ParentId": "13226942", "CommentCount": "1", "CreationDate": "2012-11-05T07:02:51.697", "OwnerUserId": "134713", "PostTypeId": "2", "Id": "13227449", "Score": "1", "Body": "<p>I will try to keep it more simple to you.Lets say there is a small program:</p>\n<pre><code>#include &lt;stdio.h&gt;\nvoid my_int_func(int x)\n{\n    printf( \"%d\\n\", x );\n}\n\nint main()\n{\n    void (*foo)(int);\n    // the ampersand is actually optional\n    foo = &amp;my_int_func;\n\n    return 0;\n}\n</code></pre>\n<p>As you can see above there is a function which takes an integer and returns a void.\ninside main i am initializing a function pointer foo with my_int_func.And please see carefully the comment \"the ampersand is an optional\".\nActually it says all.there is no difference in initializing with an an ampersand and without an ampersand.</p>\n<p>so there is no difference in both of your statements.</p>\n", "LastActivityDate": "2012-11-05T07:02:51.697"}, "13227276": {"ParentId": "13226942", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-11-05T06:51:03.817", "Score": "5", "LastEditorUserId": "1322972", "LastEditDate": "2012-11-05T06:58:33.517", "Id": "13227276", "OwnerUserId": "1322972", "Body": "<p>First, the speed of the template wrapper instantiation is going to be almost entirely at the mercy of your optimizer. </p>\n<p>That said, I've reduced your samples to the most basic code I can think of, specifically to check the invoke of the function parameters. You can read on, but you'll see they invoke exactly the same. There is no benefit for one declaration vs another. Further, I included the one you left out, (reference-decl)</p>\n<pre><code>#include &lt;cstdio&gt;\n\nint hello(int x)\n{\n    return x;\n}\n\ntemplate&lt;typename Type&gt; \nvoid apply1(Type x, Type (f)(Type))\n{\n    f(x);\n}\n\ntemplate&lt;typename Type&gt; \nvoid apply2(Type x, Type (*f)(Type))\n{\n    f(x);\n}\n\ntemplate&lt;typename Type&gt; \nvoid apply3(Type x, Type (&amp;f)(Type))\n{\n    f(x);\n}\n\nint main(int argc, char *argv[])\n{\n    apply1(1,hello);\n    apply2(2,hello);\n    apply3(3,hello);\n    return 0;\n}\n</code></pre>\n<p>The actual asm generated from the deductions is:</p>\n<p><strong>apply1</strong></p>\n<pre><code>__Z6apply1IiEvT_PFS0_S0_E:\nLeh_func_begin2:\n    pushq   %rbp\nLtmp2:\n    movq    %rsp, %rbp\nLtmp3:\n    subq    $16, %rsp\nLtmp4:\n    movl    %edi, -4(%rbp)\n    movq    %rsi, -16(%rbp)\n    movq    -16(%rbp), %rax\n    movl    -4(%rbp), %ecx\n    movl    %ecx, %edi\n    callq   *%rax\n    addq    $16, %rsp\n    popq    %rbp\n    ret\nLeh_func_end2:\n</code></pre>\n<p><strong>apply2</strong></p>\n<pre><code>__Z6apply2IiEvT_PFS0_S0_E:\nLeh_func_begin3:\n    pushq   %rbp\nLtmp5:\n    movq    %rsp, %rbp\nLtmp6:\n    subq    $16, %rsp\nLtmp7:\n    movl    %edi, -4(%rbp)\n    movq    %rsi, -16(%rbp)\n    movq    -16(%rbp), %rax\n    movl    -4(%rbp), %ecx\n    movl    %ecx, %edi\n    callq   *%rax\n    addq    $16, %rsp\n    popq    %rbp\n    ret\nLeh_func_end3:\n</code></pre>\n<p><strong>apply3</strong></p>\n<pre><code>__Z6apply3IiEvT_RFS0_S0_E:\nLeh_func_begin4:\n    pushq   %rbp\nLtmp8:\n    movq    %rsp, %rbp\nLtmp9:\n    subq    $16, %rsp\nLtmp10:\n    movl    %edi, -4(%rbp)\n    movq    %rsi, -16(%rbp)\n    movq    -16(%rbp), %rax\n    movl    -4(%rbp), %ecx\n    movl    %ecx, %edi\n    callq   *%rax\n    addq    $16, %rsp\n    popq    %rbp\n    ret\nLeh_func_end4:\n</code></pre>\n<p>They are <strong>identical</strong> (as I suspected they would be). There is no difference that I can see <em>whatsoever</em>.</p>\n<p>Note: it is worth mentioning the way the compiler <em>saw</em> these declarations by name mangling examination:</p>\n<pre><code>apply1: __Z6apply1IiEvT_PFS0_S0_E\napply2: __Z6apply2IiEvT_PFS0_S0_E\napply3: __Z6apply3IiEvT_RFS0_S0_E\n</code></pre>\n", "LastActivityDate": "2012-11-05T06:58:33.517"}, "13227752": {"ParentId": "13226942", "CommentCount": "0", "CreationDate": "2012-11-05T07:28:40.083", "OwnerUserId": "19563", "PostTypeId": "2", "Id": "13227752", "Score": "5", "Body": "<pre><code>void apply1(double(f)(double));\nvoid apply2(double(*f)(double));\n</code></pre>\n<p>These two functions have identical signatures so there should be no difference. They both take a pointer to function parameter.</p>\n<p>ISO/IEC 14882:2011 8.3.5 [dcl.fct] / 5:</p>\n<blockquote>\n<p id=\"so_13226942_13227752_0\">After determining the type of each parameter, any parameter of type \"array of T\" or \"function returning T\" is adjusted to be \"pointer to T\" or \"pointer to function returning T,\" respectively.</p>\n</blockquote>\n", "LastActivityDate": "2012-11-05T07:28:40.083"}, "bq_ids": {"n4140": {"so_13226942_13227752_0": {"section_id": 3241, "quality": 1.0, "length": 16}}, "n3337": {"so_13226942_13227752_0": {"section_id": 3114, "quality": 1.0, "length": 16}}, "n4659": {"so_13226942_13227752_0": {"section_id": 3997, "quality": 0.75, "length": 12}}}, "13226942": {"CommentCount": "4", "AcceptedAnswerId": "13227276", "PostTypeId": "1", "LastEditorUserId": "19563", "CreationDate": "2012-11-05T06:20:29.167", "LastActivityDate": "2012-11-05T08:19:52.997", "LastEditDate": "2012-11-05T08:19:52.997", "ViewCount": "409", "FavoriteCount": "0", "Title": "Difference between Type(f)(Type) and Type(*f)(Type) for function pointers?", "Id": "13226942", "Score": "3", "Body": "<p>What is the difference between these two function prototypes ?</p>\n<pre><code>void apply1(double(f)(double));\nvoid apply2(double(*f)(double));\n</code></pre>\n<p>If the goal is to apply the provided function to an array, is there a version faster compared to the other one ?</p>\n<p>EDIT :\nAn example of implementation :</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;cmath&gt;\n\n// First version\ntemplate&lt;typename Type&gt; void apply1(std::vector&lt;Type&gt;&amp; v, Type(f)(Type))\n{\n    for (unsigned int i = 0; i &lt; v.size(); ++i) {\n        v[i] = f(v[i]);\n    }\n}\n\n// Second version\ntemplate&lt;typename Type&gt; void apply2(std::vector&lt;Type&gt;&amp; v, Type(*f)(Type))\n{\n    for (unsigned int i = 0; i &lt; v.size(); ++i) {\n        v[i] = f(v[i]);\n    }\n}\n\n// Main\nint main()\n{\n   std::vector&lt;double&gt; v = {1., 2., 3., 4., 5.};\n   apply1(v, std::sin);\n   apply2(v, std::sin);\n   return 0;\n}\n</code></pre>\n", "Tags": "<c++><function-pointers>", "OwnerUserId": "882932", "AnswerCount": "3"}});