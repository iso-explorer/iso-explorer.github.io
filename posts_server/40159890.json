post_cb({"bq_ids": {"n4140": {"so_40159890_40160218_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 1920}, "so_40159890_40159890_0": {"length": 24, "quality": 0.96, "section_id": 1920}, "so_40159890_40160218_1": {"length": 9, "quality": 0.9, "section_id": 1920}}, "n3337": {"so_40159890_40160218_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 1909}, "so_40159890_40159890_0": {"length": 24, "quality": 0.96, "section_id": 1909}, "so_40159890_40160218_1": {"length": 9, "quality": 0.9, "section_id": 1909}}, "n4659": {"so_40159890_40160218_0": {"length": 20, "quality": 0.9090909090909091, "section_id": 2191}, "so_40159890_40160218_1": {"length": 9, "quality": 0.9, "section_id": 2191}}}, "40159890": {"ViewCount": "154", "Body": "<p>According to C++11 specification: </p>\n<blockquote>\n<p id=\"so_40159890_40159890_0\">The results of including <code>&lt;iostream&gt;</code> in a translation unit shall be as if <code>&lt;iostream&gt;</code> defined an instance of <code>ios_base::Init</code> with static storage duration. Similarly, the entire program shall behave as if there were at least\n  one instance of <code>ios_base::Init</code> with static storage duration</p>\n</blockquote>\n<p>This implies that if my code looks like that:</p>\n<pre><code>// A.cpp\n#include &lt;iostream&gt;\nusing namespace std;\nunsigned long foo() {\n    cerr &lt;&lt; \"bar\"; \n    return 42;\n}\n</code></pre>\n<p>and </p>\n<pre><code>// B.cpp\n\nusing namespace std;\nextern unsigned long foo();\n\nnamespace {\nunsigned long test() {\n    int id = foo();\n    return id;\n}\n\nunsigned long id = test();\n}\n\n\nint main() {\n     return 0;\n}\n</code></pre>\n<p>then I should be safe calling <code>cerr</code> without the risk of a static initialization fiasco.</p>\n<p>Unfortunately, that code segfaults... Why? I don't think gcc 6.2.1 decided to ignore the C++11 specification, and I included <code>&lt;iostream&gt;</code> in A.cpp. According to the specification it should suffice.</p>\n", "AcceptedAnswerId": "40160218", "Title": "Static order initialization fiasco, iostream and C++11", "CreationDate": "2016-10-20T16:34:34.317", "Id": "40159890", "CommentCount": "9", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2016-10-20T18:01:37.843", "LastEditorUserId": "1060159", "LastActivityDate": "2016-10-20T18:01:37.843", "Score": "4", "OwnerUserId": "1060159", "Tags": "<c++><c++11><static><static-order-fiasco>", "AnswerCount": "1"}, "40160218": {"Id": "40160218", "PostTypeId": "2", "Body": "<p>The full quote of the paragraph includes:</p>\n<blockquote>\n<p id=\"so_40159890_40160218_0\">The objects are constructed and the associations are established at some time prior to or during the first\n  time an object of class ios_base::Init is constructed, and in any case before the body of main begins\n  execution. 293)</p>\n</blockquote>\n<p>And with the footnote</p>\n<blockquote>\n<p id=\"so_40159890_40160218_1\">293) If it is possible for them to do so, implementations are encouraged to initialize the objects earlier than required.</p>\n</blockquote>\n<p>So, the guarantee is that the iostreams will work <em>at the latest</em> when entering main. There is no strict requirement that they should work earlier, unless the translation unit includes <code>&lt;iostream&gt;</code>.</p>\n<p>You have found a way to circumvent this!</p>\n<p>When calling <code>foo()</code> from B.cpp, the <code>ios_base::Init</code> instance included in A.cpp may, or may not, have been initialized. </p>\n", "LastActivityDate": "2016-10-20T16:54:23.203", "CommentCount": "2", "CreationDate": "2016-10-20T16:54:23.203", "ParentId": "40159890", "Score": "6", "OwnerUserId": "597607"}});