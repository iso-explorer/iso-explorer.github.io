post_cb({"35960756": {"Id": "35960756", "PostTypeId": "2", "Body": "<p>I have no idea why you posted this question again when I already <a href=\"https://stackoverflow.com/questions/35957019/why-return-type-of-same-named-method-should-be-same-in-sub-class-java\">gave you the answer here</a>. But here is the <em>correct</em> answer again.</p>\n<p>Java methods and C++ virtual functions <em>can</em> be hidden, but different return types <em>are</em> allowed when overriding, as long as they are <em>compatible</em>. It is only <em>conflicting</em> return types that are disallowed. For example, in C++:</p>\n<pre><code>struct Base {\n    virtual Base* f() { return nullptr; }\n};\n\nstruct Derived : Base {\n    Derived* f() override { return nullptr; }\n};\n</code></pre>\n<p>And in Java:</p>\n<pre><code>class Base {\n    Base f() { return null; }\n}\n\nclass Derived extends Base {\n    @Override\n    Derived f() { return null; }\n}\n</code></pre>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-03-12T17:10:57.790", "Score": "0", "CreationDate": "2016-03-12T17:10:57.790", "ParentId": "35958755", "CommentCount": "0", "LastEditDate": "2017-05-23T12:23:50.220", "OwnerUserId": "1563039"}, "35958833": {"Id": "35958833", "PostTypeId": "2", "Body": "<p>Virtual functions of C++ are part of the <em>interface</em> of your class, while non-virtual may be part of <em>implementation</em> as well. When you extend a class, you tell the compiler that you are going to comply with all of its interface, including signatures of its virtual functions.</p>\n<p>All non-private / non-final Java methods are virtual, so the same argument applies to them.</p>\n<p>As far as object type being sufficient to determine what method to call goes, you may not necessarily know the type at compile time. The compiler must determine the way to look up the method by the static type, including a virtual look-up. This requires the compiler to know the signature and the return type.</p>\n", "LastEditorUserId": "335858", "LastActivityDate": "2016-03-12T15:08:42.007", "Score": "2", "CreationDate": "2016-03-12T14:26:28.287", "ParentId": "35958755", "CommentCount": "4", "LastEditDate": "2016-03-12T15:08:42.007", "OwnerUserId": "335858"}, "bq_ids": {"n4140": {"so_35958755_35958933_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 7008}}, "n3337": {"so_35958755_35958933_2": {"length": 13, "quality": 0.9285714285714286, "section_id": 6754}}, "n4659": {"so_35958755_35958933_2": {"length": 12, "quality": 0.8571428571428571, "section_id": 8505}}}, "35959005": {"Id": "35959005", "PostTypeId": "2", "Body": "<p>You guessed correctly, \"polymorphic\" is the key word :)\nPolymorphism means that, if <code>Y</code> is a subclass of <code>X</code>, then <code>Y</code> effectively <em>is</em> <code>X</code>, and can be used as <code>X</code> anywhere.</p>\n<p>Now, that means, if <code>X</code> has a method <code>void k()</code>, then <code>Y</code> must also have the same method (otherwise, you would not be able to use it as <code>X</code>). But you cannot have two different methods with the same signature, and therefore <code>Y.k()</code> must also return <code>void</code> (otherwise, it would be a different method). </p>\n<p>In C++ case, non-virtual functions aren't polymorphic: <code>A.k</code> and <code>B.k</code> are two completely different methods in that case, and therefore there is no restriction.</p>\n<p>To put it simply, let's change your example a little bit: suppose, that you defined <code>X.k</code> to return <code>int</code>, and <code>Y.k()</code> as <code>void</code>. Imagine a function like this:</p>\n<pre><code>     int plusOne(X x) {\n        return x.k() + 1\n     }\n</code></pre>\n<p>This should compile and work, right? But what about <code>plusOne(new Y())</code>? \nThis must also work, because <code>Y</code> is <code>X</code> ... but, if it was possible for <code>Y.k()</code> to return a void, what would <code>plusOne</code> do with it?</p>\n", "LastActivityDate": "2016-03-12T14:40:11.063", "Score": "4", "CreationDate": "2016-03-12T14:40:11.063", "ParentId": "35958755", "CommentCount": "10", "OwnerUserId": "4254517"}, "35958933": {"Id": "35958933", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_35958755_35958933_0\">If it polymorphic behavior problem. Then I think object is enough to determined the function calling</p>\n</blockquote>\n<p>Dynamic polymorphism happens at run time, but the type of the return value is determined at compile time. </p>\n<blockquote>\n<p id=\"so_35958755_35958933_1\">why we can't change return type in sub-class or child class?</p>\n</blockquote>\n<p>Think about the following example, (To be convenient for explanation I changed your sample code a little about the return type)</p>\n<pre><code>class A{\n    public:\n        virtual int k(){  // returns int\n            std::cout &lt;&lt; \"k from A\";\n            return 0;\n        }\n};\nclass B:public A{\n    public:\n        std::string k(){  // returns std::string\n            std::cout &lt;&lt; \"k from B\";\n            return std::string();\n        }\n};\nint main(){\n    A* pa = new B;\n    int r = pa-&gt;k(); // r is supposed to be int, the type is deduced at compile time\n\n    delete pa;\n    return 0;\n}\n</code></pre>\n<p>Calling the virtual function <code>f()</code> via base class pointer (or reference), an <code>int</code> is supposed to be returned, but according to the result of dynamic dispatch, <code>B::k()</code> will be called in fact, but it will return a totally different type (i.e. <code>std::string</code>). It's conflicting and ill-formed.</p>\n<p>From the c++ standard, $10.3/7 Virtual functions [class.virtual]</p>\n<blockquote>\n<p id=\"so_35958755_35958933_2\">The return type of an overriding function shall be either identical to\n  the return type of the overridden function or covariant with the\n  classes of the functions.</p>\n</blockquote>\n", "LastEditorUserId": "3309790", "LastActivityDate": "2016-03-12T15:06:13.820", "Score": "3", "CreationDate": "2016-03-12T14:33:47.883", "ParentId": "35958755", "CommentCount": "0", "LastEditDate": "2016-03-12T15:06:13.820", "OwnerUserId": "3309790"}, "35958755": {"ViewCount": "88", "Body": "<pre><code>#include &lt;iostream&gt;\nclass A{\n    public:\n        void k(){\n            std::cout &lt;&lt; \"k from A\";\n        }\n};\nclass B:public A{\n    public:\n        int k(){\n            std::cout &lt;&lt; \"k from B\"; \n            return 0;\n        }\n};\nint main(){\n    B obj;\n    obj.k();\n\n    return 0;\n}\n</code></pre>\n<p>without virtual it's working fine, But When I changed A's function to virtual then It's saying return type should be same why?</p>\n<p>I tried same thing in Java.</p>\n<pre><code>class X{\n    public void k(){\n        System.out.println(\"k From X\");\n    }\n}\npublic class Y{\n    public int k(){\n        System.out.println(\"k From Y\");\n        return 0;\n    }\n}\n</code></pre>\n<p>Java also showing error when I tried different return type in sub-class. ( I think because by default all instance methods are virtual by default ) I was expecting <code>int k()</code> should hide <code>void k()</code> and <code>int k()</code> should invoke from Y's object.</p>\n<p>So I think it's problem with virtual. why child class should be use same return type when function declared as virtual?</p>\n<p>If it polymorphic behavior problem. Then I think object is enough to determined the function calling. \nExample:</p>\n<pre><code>class X{\n    public void k(){\n        System.out.println(\"k From X\");\n    }\n}\npublic class Y extends X{\n    public int k(){\n        System.out.println(\"k From Y\");\n        return 0;\n    }\n    public static void main(String[] args){\n        X obj=new Y();\n        obj.k(); // object Y found now just call k() from Y.\n    }\n}\n</code></pre>\n<p>Can any body explain? why we can't change return type in sub-class or child class?</p>\n", "AcceptedAnswerId": "35959005", "Title": "Why hiding of virtual functions/methods not allowed in Java or C++", "CreationDate": "2016-03-12T14:19:41.850", "Id": "35958755", "CommentCount": "3", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2016-03-12T15:17:42.723", "LastEditorUserId": "2769917", "LastActivityDate": "2016-03-12T17:10:57.790", "Score": "4", "OwnerUserId": "2769917", "Tags": "<java><c++><override><hiding>", "AnswerCount": "4"}});