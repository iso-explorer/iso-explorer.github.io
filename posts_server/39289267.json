post_cb({"39289267": {"CommentCount": "12", "ViewCount": "117", "PostTypeId": "1", "LastEditorUserId": "191463", "CreationDate": "2016-09-02T09:41:00.423", "LastActivityDate": "2016-09-02T16:59:04.447", "Title": "Behaviour of attempting to access a character at index -1 for std::string?", "AcceptedAnswerId": "39289422", "LastEditDate": "2016-09-02T13:11:11.480", "Id": "39289267", "Score": "-1", "Body": "<p>Is there any guaranteed behaviour for attempting to access a character at <code>-1</code> in a std::string?</p>\n<p>Eg if I do:</p>\n<pre><code>for (int i = 0; i &lt; str.size(); i++) {\n  if (str[i-1] == 'a' &amp;&amp; str[i+1] == 'c') {\n    //etc\n  }\n}\n</code></pre>\n<p>Then on the first iteration it will do <code>str[-1]</code>, what does the standard say will happen? I know it says in C++11 that str[str.size()] will return the null character, but sites like cppreference and cplusplus don't say anything about other out of bounds accesses.</p>\n<p>(if I run the code above, then nothing bad happens, but I want to make sure that this is standard)</p>\n", "Tags": "<c++><string>", "OwnerUserId": "191463", "AnswerCount": "2"}, "39289311": {"ParentId": "39289267", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>Quoted from c++11 standard:</p>\n<blockquote>\n<p id=\"so_39289267_39289311_0\">[string.access]</p>\n<p id=\"so_39289267_39289311_1\">const_reference operator[](size_type pos) const;\n  reference operator[](size_type pos);</p>\n<p id=\"so_39289267_39289311_2\">Requires: pos &lt;= size(). Otherwise, returns a reference to an object of type charT with value charT(), where modifying the object leads to undefined behavior.</p>\n<p id=\"so_39289267_39289311_3\">Throws: Nothing.</p>\n<p id=\"so_39289267_39289311_4\">Complexity: constant time</p>\n<p id=\"so_39289267_39289311_5\">Returns: *(begin() + pos) if pos &lt; size().</p>\n</blockquote>\n<p>Your -1 is converted to the unsigned <code>size_type</code>, producing the maximum value of the type.</p>\n<p>It then it should return a nul char.</p>\n<p>Note: my clang doesn't have this behavior and says in its docs that <em>data access with this operator is unchecked and out_of_range lookups are not defined.</em></p>\n", "OwnerUserId": "719263", "LastEditorUserId": "719263", "LastEditDate": "2016-09-02T13:30:00.080", "Id": "39289311", "Score": "-1", "CreationDate": "2016-09-02T09:43:33.813", "LastActivityDate": "2016-09-02T13:30:00.080"}, "bq_ids": {"n4140": {"so_39289267_39289311_2": {"section_id": 1617, "quality": 0.9411764705882353, "length": 16}, "so_39289267_39289311_5": {"section_id": 1617, "quality": 0.8, "length": 4}, "so_39289267_39289311_1": {"section_id": 1619, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_39289267_39289311_2": {"section_id": 1613, "quality": 0.9411764705882353, "length": 16}, "so_39289267_39289311_5": {"section_id": 1613, "quality": 0.8, "length": 4}, "so_39289267_39289311_1": {"section_id": 1615, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_39289267_39289311_2": {"section_id": 1770, "quality": 0.9411764705882353, "length": 16}, "so_39289267_39289311_1": {"section_id": 1772, "quality": 0.7142857142857143, "length": 5}, "so_39289267_39289311_5": {"section_id": 1770, "quality": 0.8, "length": 4}}}, "39289422": {"ParentId": "39289267", "PostTypeId": "2", "CommentCount": "9", "Body": "<blockquote>\n<p id=\"so_39289267_39289422_0\">Is there any guaranteed behaviour for access the character at -1 in a std::string?</p>\n</blockquote>\n<p>Formally, it depends. In practice, it is <em>undefined behaviour</em>, so there are no guarantees.</p>\n<p>The parameter of <code>operator[]</code> is unsigned, so <code>-1</code> is the maximum value that type can hold (<code>std::numeric_limits&lt;std::string::size_type&gt;::max()</code>). Since that is also the maximum value <code>std::string::size()</code> can hold, it could be well defined <em>only</em> in the (extremely improbable) case that the string has the largest size allowed, in which case a reference to the null terminator is returned.</p>\n<p>From the C++11 standard, and the N3936 draft of the C++14 standard,</p>\n<blockquote>\n<p id=\"so_39289267_39289422_1\"><strong>21.4.5 basic_string element access [string.access]</strong></p>\n<pre><code>const_reference operator[](size_type pos) const;\nreference       operator[](size_type pos);\n</code></pre>\n<ol>\n<li>Requires: <code>pos &lt;= size()</code>.</li>\n<li>Returns: <code>*(begin() + pos)</code> if <code>pos &lt; size()</code>. Otherwise, returns a reference to an object of type <code>charT</code> with value <code>charT()</code>, where\n  modifying the object leads to undefined behavior. ....</li>\n</ol>\n</blockquote>\n", "OwnerUserId": "661519", "LastEditorUserId": "661519", "LastEditDate": "2016-09-02T16:59:04.447", "Id": "39289422", "Score": "1", "CreationDate": "2016-09-02T09:49:06.773", "LastActivityDate": "2016-09-02T16:59:04.447"}});