post_cb({"13803720": {"ViewCount": "416", "Body": "<p>I am building a C++ program that needs to store a map of strings to function pointers.  However, every function may have different return types and parameters.  The way I am attempting to solve this problem is by creating the functions as taking an array of void pointers and returning an array of void pointers, and then casting the arguments and return values as needed.</p>\n<p>To figure out how this would work, I'm trying to build a simple dummy, but can't get it to compile.  I've tried a number of things, but I keep getting different errors.  here's an example:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nvoid** string2map(void** args){\n    //takes a string of the form \"key:value;key:value;...\" and returns a map&lt;string,string&gt;\n    string st = *((string**) args)[0];\n    map&lt;string, string&gt; result = map &lt;string, string&gt;();\n    //code doesnt matter\n    return (void*) &amp;((void*) &amp;result);\n}\n\nint main(){\n    string test = \"hello:there;how:are you?\";\n    map&lt;string, string&gt; result = *(map&lt;string, string&gt;**)string2map((void*) &amp;((void*) &amp;test))[0];\n\n    return 0;\n}\n</code></pre>\n<p>when I try to compile, I get:</p>\n<pre><code>void.cpp: In function 'void** string2map(void**)':\nvoid.cpp:12:34: error: lvalue required as unary '&amp;' operand\nvoid.cpp: In function 'int main()':\nvoid.cpp:17:89: error: lvalue required as unary '&amp;' operand\n</code></pre>\n<p>Obviously there are plenty of things wrong here, but I really just don't know where to start.  Can anyone either show me what's wrong with the code above, or give me an alternative to the way I am currently doing it?</p>\n<p><strong>NOTE</strong></p>\n<p>The reason I am returning a <code>void**</code> instead of just <code>void*</code> is that there might be a circumstance where I need to return multiple values of different types.  An example would be if, above, I wanted to return both the resulting map AND the number of entries in the map.  I haven't even gotten to the point of figuring out how to construct that array yet, though.</p>\n<p><strong>EDIT</strong></p>\n<p>So based on the responses so far, it seems pretty clear that this is the wrong way of solving this problem.  With that in mind, can anyone suggest a better one?  I need to be able to store the various function in a single map, which means I need to be able to define a single data type to functions that take and return different types.  And it IS important to be able to return multiple values.</p>\n", "AcceptedAnswerId": "13818361", "Title": "return an array of void*", "CreationDate": "2012-12-10T15:16:30.237", "Id": "13803720", "CommentCount": "9", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2012-12-10T15:40:31.590", "LastEditorUserId": "702948", "LastActivityDate": "2012-12-11T10:44:54.940", "Score": "1", "OwnerUserId": "702948", "Tags": "<c++><arrays><function-pointers><void-pointers>", "AnswerCount": "6"}, "13803876": {"Id": "13803876", "PostTypeId": "2", "Body": "<p>Ignoring my own horror at the idea of blatantly throwing type safety to the wind, two things spring immediately to mind. </p>\n<p>First, what exactly do you think will be pointed to when string2map goes out of scope? </p>\n<p>Second is that you don't have to cast to void*. Void* gets special treatment in C++ in that anything can be cast to it.</p>\n<p>If you insist on trying to push this, I'd start by changing the return type to void, and then take the void* as an input parameter to your function.</p>\n<p>For example:</p>\n<pre><code>void string2map(void* args, void* returnedMap);\n</code></pre>\n<p>This way you'd have to instantiate your map in a scope that will actually <em>have</em> a map to point to.</p>\n", "LastEditorUserId": "151073", "LastActivityDate": "2012-12-10T15:35:15.570", "Score": "1", "CreationDate": "2012-12-10T15:25:39.617", "ParentId": "13803720", "CommentCount": "0", "OwnerUserId": "151073", "LastEditDate": "2012-12-10T15:35:15.570"}, "13804572": {"Id": "13804572", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_13803720_13804572_0\">The way I am attempting to solve this problem is by creating the functions as taking an array of void pointers and returning an array of void pointers, and then casting the arguments and return values as needed.</p>\n</blockquote>\n<p>That's (really really) bad. Have a look instead at std::function and std::bind - those should cover differences between function signatures and bound arguments in an elegant way.</p>\n<blockquote>\n<p id=\"so_13803720_13804572_1\">The reason I am returning a void** instead of just void* is that there might be a circumstance where I need to return multiple values of different types.</p>\n</blockquote>\n<p>Then return an object that contains the values. For generics have a look at std::tuple or boost::any.</p>\n<p>Here's some code:</p>\n<pre><code>void function1(int, const char); // defined elsewhere\nstd::tuple&lt;int,int&gt; function2(std::string&amp;); // defined elsewhere\n\nstd::map&lt;std::string,std::function&lt;void(void)&gt;&gt; functionmap;\nfunctionmap.insert( std::make_pair(\"function1\", std::bind(&amp;function1, 2, 'c')) );\n\nstd::tuple&lt;int,int&gt; result;\nfunctionmap.insert( std::make_pair(\"function2\", [&amp;result] { \n    result = function2(\"this is a test\"); } );\n\n// call function1\nfunctionmap[\"function1\"]();\n\n// call function2\nfunctionmap[\"function2\"](); // result will now contain the result \n                            // of calling function2\n</code></pre>\n", "LastActivityDate": "2012-12-10T16:04:17.993", "CommentCount": "0", "CreationDate": "2012-12-10T16:04:17.993", "ParentId": "13803720", "Score": "0", "OwnerUserId": "186997"}, "13804743": {"Id": "13804743", "PostTypeId": "2", "Body": "<p>Is this what you tried to do?</p>\n<pre><code>int Foo(int a) { return a; }\ntypedef int (*FooFunc)(int);\n\nvoid Bar(){}\n\ntypedef std::map&lt;std::string, void*&gt;  FunctionMap;  \n// you should use boost::any or something similar instead of void* here\n\nFunctionMap CreateFunctionMap(const std::string&amp; args)\n{\n    FunctionMap result;\n    result[\"Foo\"] = &amp;Foo;\n    result[\"Bar\"] = &amp;Bar;\n    return result;\n}\n\nvoid Call(FunctionMap::const_reference functionInfo)\n{\n    // @hansmaad The key will give information on the signatures. \n    // there are a few distinct options, so it will be a conditional \n    // with a couple of clauses.\n    if (functionInfo.first == \"Foo\")\n    {\n        auto f = static_cast&lt;FooFunc&gt;(functionInfo.second);\n        std::cout &lt;&lt; f(42);\n    }\n    else if (functionInfo.first == \"Bar\")\n    {\n        /* */\n    }\n}\n\nint main()\n{\n    auto functions = CreateFunctionMap(\"...\");\n    std::for_each(begin(functions), end(functions), Call);\n}\n</code></pre>\n", "LastEditorUserId": "498298", "LastActivityDate": "2012-12-10T16:21:02.643", "Score": "0", "CreationDate": "2012-12-10T16:14:42.463", "ParentId": "13803720", "CommentCount": "0", "OwnerUserId": "498298", "LastEditDate": "2012-12-10T16:21:02.643"}, "bq_ids": {"n4140": {"so_13803720_13803890_1": {"length": 6, "quality": 0.75, "section_id": 6065}, "so_13803720_13803890_0": {"length": 9, "quality": 0.75, "section_id": 6066}}, "n3337": {"so_13803720_13803890_1": {"length": 6, "quality": 0.75, "section_id": 5833}, "so_13803720_13803890_0": {"length": 9, "quality": 0.75, "section_id": 5834}}, "n4659": {"so_13803720_13803890_1": {"length": 6, "quality": 0.75, "section_id": 7561}, "so_13803720_13803890_0": {"length": 9, "quality": 0.75, "section_id": 7562}}}, "13805284": {"Id": "13805284", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_13803720_13805284_0\">@hansmaad The key will give information on the signatures. there are a few distinct options, so it will be a conditional with a couple of clauses. \u2013 ewok 33 mins ago</p>\n</blockquote>\n<p>In that case, the typical solution is like this:</p>\n<pre><code>typedef void (*func_ptr)();\nstd::map&lt;std::string, func_ptr&gt; func_map;\n\nmap&lt;string,string&gt; string2map(string arg){\n    //takes a string of the form \"key:value;key:value;...\" and returns a map&lt;string,string&gt;\n    map&lt;string, string&gt; result = map &lt;string, string&gt;();\n    //...\n    return result;\n}\n\n// ...\n\n// Add function to the map\nfunc_map[\"map&lt;string,string&gt;(string)\" = (func_ptr)string2map;\n\n// Call function in the map\nstd::map&lt;std::string, func_ptr&gt;::iterator it = ...\nif (it-&gt;first == \"map&lt;string,string&gt;(string)\")\n{\n    map&lt;string,string&gt; (*func)(string) = (map&lt;string,string&gt;(*)(string))it-&gt;second;\n    map&lt;string,string&gt; result = func(\"key1;value1;key2;value2\");\n}\n</code></pre>\n<p>For brevity, I have used C-style casts of the function pointers. The correct C++ cast would be <code>reinterpret_cast&lt;&gt;()</code>.</p>\n<p>The function pointers are converted to a common type on insertion into the map and converted back to their correct type when invoking them.</p>\n", "LastActivityDate": "2012-12-10T16:44:35.937", "CommentCount": "0", "CreationDate": "2012-12-10T16:44:35.937", "ParentId": "13803720", "Score": "0", "OwnerUserId": "430719"}, "13818361": {"Id": "13818361", "PostTypeId": "2", "Body": "<p>You're converting a <code>map&lt;string,string&gt;</code> to a <code>void**</code>, returning it then converting it back to a <code>map&lt;string,string</code>.  Why not just return a <code>map&lt;string,string&gt;</code>?  It's also called <code>string2map</code> which implies you will only ever call it with a string (backed up by the fact you pass in a string, which is converted to a <code>void**</code> then converted straight back).  Unless you have a good reason to convert to and from <code>void**</code> all over the place this is probably what you need:</p>\n<pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n\nusing namespace std;\n\nmap&lt;string, string&gt; string2map(string st){\n    map&lt;string, string&gt; result = map &lt;string, string&gt;();\n    //code doesnt matter\n    return result;\n}\n\nint main(){\n    string test = \"hello:there;how:are you?\";\n    map&lt;string, string&gt; result = string2map(test);\n    return 0;\n}\n</code></pre>\n<p><strong>EDIT:</strong> </p>\n<p>I've just reread your question.  You might want to look up Generalised Functors and look at Boost's <code>std::function</code> as possible solutions to this problem.  It's possible to change the return type of a function via a wrapper class, something like:</p>\n<pre><code>template&lt; class T &gt;\nclass ReturnVoid\n{\npublic:\n    ReturnVoid( T (*functor)() ) : m_functor( functor ) {}\n\n    void operator() { Result = functor(); }\n\nprivate:\n    T (*m_functor)();\n    T Result;\n};\n\n//  Specialise for void since you can't have a member of type 'void'\ntemplate&lt;&gt;\nReturnVoid&lt; void &gt;\n{\npublic:\n    ReturnVoid( T (*functor)() ) : m_functor( functor ) {}\n\n    void operator() { functor(); }\n\nprivate:\n    T (*m_functor)();\n};\n</code></pre>\n<p>Using this as a wrapper might help you store functors with different return types in the same array.</p>\n", "LastEditorUserId": "1669169", "LastActivityDate": "2012-12-11T10:44:54.940", "Score": "1", "CreationDate": "2012-12-11T10:32:30.313", "ParentId": "13803720", "CommentCount": "0", "OwnerUserId": "1669169", "LastEditDate": "2012-12-11T10:44:54.940"}, "13803890": {"Id": "13803890", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_13803720_13803890_0\">$5.3.1/3 - \"The result of the unary &amp; operator is a pointer to its\n  operand. The operand shall be an <strong>lvalue or a qualifiedid</strong>.\"</p>\n<p id=\"so_13803720_13803890_1\">$5.3.1/2 - \"The result of each of the following unary operators is a\n  <strong>prvalue</strong>.\"</p>\n</blockquote>\n<p>So, in effect you are trying to take the address of an rvalue which is not allowed.</p>\n<p>Further, C++ does not allow to return an array.</p>\n<p>So, you really want to start looking at what you want. Return the map by value instead is one definite option.</p>\n", "LastEditorUserId": "418110", "LastActivityDate": "2012-12-10T15:33:01.527", "Score": "1", "CreationDate": "2012-12-10T15:26:55.837", "ParentId": "13803720", "CommentCount": "0", "OwnerUserId": "418110", "LastEditDate": "2012-12-10T15:33:01.527"}});