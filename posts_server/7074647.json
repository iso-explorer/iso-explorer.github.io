post_cb({"bq_ids": {"n4140": {"so_7074647_7074714_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 7151}, "so_7074647_7074714_1": {"length": 9, "quality": 1.0, "section_id": 7150}, "so_7074647_7074714_4": {"length": 18, "quality": 0.9, "section_id": 7151}}, "n3337": {"so_7074647_7074714_2": {"length": 10, "quality": 0.9090909090909091, "section_id": 6895}, "so_7074647_7074714_1": {"length": 9, "quality": 1.0, "section_id": 6894}, "so_7074647_7074714_4": {"length": 18, "quality": 0.9, "section_id": 6895}}, "n4659": {"so_7074647_7074714_2": {"length": 9, "quality": 0.8181818181818182, "section_id": 4051}, "so_7074647_7074714_1": {"length": 7, "quality": 0.7777777777777778, "section_id": 8651}, "so_7074647_7074714_4": {"length": 14, "quality": 0.7, "section_id": 8652}}}, "7074785": {"Id": "7074785", "PostTypeId": "2", "Body": "<p>use local statics </p>\n<pre><code>Singleton* Singleton::getInstance()\n{\n    static Singleton obj; return &amp;Singleton;\n}\n</code></pre>\n", "LastActivityDate": "2011-08-16T07:19:41.330", "Score": "2", "CreationDate": "2011-08-16T07:19:41.330", "ParentId": "7074647", "CommentCount": "7", "OwnerUserId": "896161"}, "7074928": {"Id": "7074928", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_7074647_7074928_0\">Now, I think there is a problem in the pattern there, if one desires\n  to provide the Singleton in a library to others: if the user calls\n  Singleton::Instance() from another compilation unit (during a static\n  data member initialization, for example) before _instance is\n  initialized, then a following call of Singleton::Instance() might\n  create another instance of the Singleton, with unwanted results, since\n  _instance might have been initialized to 0 first.</p>\n</blockquote>\n<p>No problem: static variables are <strong>zero-initialized</strong> before any dynamic initialization takes place.</p>\n<p>On the other hand, the code you then introduce as solution to non-existent problem, namely</p>\n<pre><code>Singleton* Singleton::_instance = Singleton::Instance();\n</code></pre>\n<p><strong>is</strong> problematic \u2013 no guarantee about order of (dynamic) initialization between translation unit.</p>\n<p>Cheers &amp; hth.,</p>\n", "LastEditorUserId": "464581", "LastActivityDate": "2011-08-16T07:47:43.047", "Score": "3", "CreationDate": "2011-08-16T07:35:58.340", "ParentId": "7074647", "CommentCount": "11", "LastEditDate": "2011-08-16T07:47:43.047", "OwnerUserId": "464581"}, "7074714": {"Id": "7074714", "PostTypeId": "2", "Body": "<h2>Static initialization happens before dynamic initialization</h2>\n<p>The singleton solution you have quoted works because</p>\n<pre><code>Singleton* Singleton::_instance = 0;\n</code></pre>\n<p>describes a <em>static initialization</em> (namely <em>zero initialization</em> in this case, but a <em>constant initialization</em> would work as well if used), which is guaranteed to happen before any dynamic initialization (and therefore before any code is run). All requirements of static initialization are guaranteed here, as _instance is a global variable of a built-in type (a pointer) and initialized with zero.</p>\n<p>The other solution you have provided does not change anything significant, because still only the zero initialization of _instance is guaranteed to happen before code from other modules is called, as the initialization by Singleton::Instance call is a dynamic one and therefore is subject to <a href=\"http://www.parashift.com/c++-faq-lite/ctors.html#faq-10.14\" rel=\"nofollow\"><em>static</em> initialization order fiasco</a>.</p>\n<h2>Implementation - data segment</h2>\n<p>Note: Static initialization is most often implemented by storing the value of the variable, which was computed compile time, in a <a href=\"http://en.wikipedia.org/wiki/Data_segment#Data\" rel=\"nofollow\">data segment</a> of the executable.</p>\n<h2>Terminology, standard quote</h2>\n<p>While most programmers (including <a href=\"http://www2.research.att.com/~bs/C++0xFAQ.html#constexpr\" rel=\"nofollow\">Bjarne Stroustrup</a>) call the initialization style used in the original singleton implemementation \"compile time initialization\", the standard calls it \"static initialization\", as opposed to a \"dynamic initialization\" (which is what is most often called run-time). See <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow\">C++0x draft 3.6.2</a> (shortened, emphasis mine):</p>\n<blockquote>\n<p id=\"so_7074647_7074714_0\"><strong>3.6.2 Initialization of non-local variables</strong> [basic.start.init]</p>\n<p id=\"so_7074647_7074714_1\">... Non-local variables with static storage duration are initialized\n  as a consequence of program initiation. ... as follows.</p>\n<p id=\"so_7074647_7074714_2\">2 Variables with static storage duration (3.7.1) ... shall be zero-initialized (8.5)\n  before any other initialization takes place.</p>\n<p id=\"so_7074647_7074714_3\"><em>Constant initialization</em> is performed:\n  ...</p>\n<ul>\n<li>if an object with static or thread storage duration is not initialized by a constructor call and if every full-expression that appears in its initializer is a constant expression.</li>\n</ul>\n<p id=\"so_7074647_7074714_4\"><strong>Together, zero-initialization and constant initialization are called static initialization; all other initialization is\n  dynamic initialization. Static initialization shall be performed before any dynamic initialization takes place.</strong></p>\n</blockquote>\n", "LastEditorUserId": "16673", "LastActivityDate": "2011-08-16T12:32:37.237", "Score": "6", "CreationDate": "2011-08-16T07:11:46.807", "ParentId": "7074647", "CommentCount": "11", "LastEditDate": "2011-08-16T12:32:37.237", "OwnerUserId": "16673"}, "7074647": {"ViewCount": "3908", "Body": "<p>Is it possible to initialize the Instance of a Singleton when it is really needed?</p>\n<p>Consider this pattern taken from the famous \"Design Patterns\":</p>\n<pre><code>class Singleton {\npublic:\n   static Singleton* Instance();\nprotected:\n   Singleton();\nprivate:\n   static Singleton* _instance;\n}\n\nSingleton* Singleton::_instance = 0; // unit.cpp\n\nstatic Singleton* Singleton::Instance() {\n   if (_instance == 0) {\n       _instance = new Singleton;\n   }\n   return _instance;\n}\n</code></pre>\n<p>Now, I think there is a problem in the pattern there, if one desires to provide the Singleton in a library to others: if the user calls <code>Singleton::Instance()</code> from another compilation unit (during a static data member initialization, for example) before _instance is initialized, then a following call of <code>Singleton::Instance()</code> might create another instance of the Singleton, with unwanted results, since _instance might have been initialized to 0 first.</p>\n<p>I think one solution is to initialize _instance this way:</p>\n<pre><code>Singleton* Singleton::_instance = Singleton::Instance();\n</code></pre>\n<p>Anyway, that makes the initialization not \"lazy\" for those who don't need to call Singleton::Instance() to initialize their static data.</p>\n<p>Are there better solutions so that the inizialization can happen when the Singleton instance is needed?</p>\n", "Title": "Is lazy initialization really possible with static data members?", "CreationDate": "2011-08-16T07:04:01.580", "LastActivityDate": "2011-08-16T12:32:37.237", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2011-08-16T07:13:58.983", "LastEditorUserId": "82320", "Id": "7074647", "Score": "2", "OwnerUserId": "896156", "Tags": "<c++><lazy-loading>", "AnswerCount": "3"}});