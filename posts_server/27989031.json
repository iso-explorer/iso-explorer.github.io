post_cb({"27989291": {"ParentId": "27989031", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>Since neither lambda capture they can be converted to function pointers with compatible signatures, so <code>gcc</code> and <code>clang</code> are correct here.</p>\n<p>There is a gcc bug report which summarizes this topic well: <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=54557\" rel=\"noreferrer\"> [c++ lambda] error in assigning lambda expr though \"operator?:\" while capturing </a> that covers this and says:</p>\n<blockquote>\n<p id=\"so_27989031_27989291_0\">The compiler behaviour looks correct to me. The difference of the\n  lambda expressions in bar and <code>foo3</code> compared to the other two is that\n  these are capture-free lambdas and thus have a conversion function to\n  function pointer. </p>\n<p id=\"so_27989031_27989291_1\">Each lambda expression corresponds to a unique class type, so what we\n  have in <code>foo1</code> and <code>foo2</code> can be compared with the following\n  class-example:</p>\n<pre><code>struct A{}; struct B{};\nvoid f() { false ? A() : B(); }\n</code></pre>\n<p id=\"so_27989031_27989291_2\">This expression has no common type for the conditional operator and is\n  ill-formed.</p>\n<p id=\"so_27989031_27989291_3\">What we have in <code>bar</code> and <code>foo3</code> can be compared with the following\n  class-example :</p>\n<pre><code>struct A\n{\n    typedef void (*F)();\n    operator F();\n};\n\nstruct B\n{\n    typedef void (*F)();\n    operator F();\n};\n\nvoid f() { false ? A() : B(); }\n</code></pre>\n<p id=\"so_27989031_27989291_4\">This is well-formed, because in the last step of the conditional\n  operator conversion attempts (5.16p5), more general conversions are\n  attempted and these find the common pointer to function.</p>\n</blockquote>\n<p><code>5.16p5</code> says:</p>\n<blockquote>\n<p id=\"so_27989031_27989291_5\">Otherwise, the result is a prvalue. If the second and third operands\n  do not have the same type, and either has (possibly cv-qualified)\n  class type, overload resolution is used to determine the conversions\n  (if any) to be applied to the operands (13.3.1.2, 13.6). If the\n  overload resolution fails, the program is ill-formed. Otherwise, the\n  conversions thus determined are applied, and the converted operands\n  are used in place of the original operands for the remainder of this\n  section.</p>\n</blockquote>\n<p>If we change your code as follows:</p>\n<pre><code>int x = 20 ;\nauto increasing = [&amp;x](int lhs, int rhs){return lhs &lt; rhs;};\nauto decreasing = [&amp;x](int lhs, int rhs){return lhs &gt; rhs;};\n</code></pre>\n<p>both <code>gcc</code> and <code>clang</code> generate an error, <code>clang</code> says (<em><a href=\"http://melpon.org/wandbox/permlink/dA32fxH2qly9pL98\" rel=\"noreferrer\">see it live</a></em>):</p>\n<pre><code>error: incompatible operand types ('(lambda at prog.cc:8:23)' and '(lambda at prog.cc:9:23)')\nstd::sort(v.begin(), v.end(), increase ? increasing : decreasing);\n                                      ^ ~~~~~~~~~~   ~~~~~~~~~~\n</code></pre>\n<p>For reference the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"noreferrer\">draft C++11 standard</a> <code>5.1.2</code> <em>[expr.prim.lambda]</em> says:</p>\n<blockquote>\n<p id=\"so_27989031_27989291_6\">The closure type for a lambda-expression with no lambda-capture has a\n  public non-virtual non-explicit const conversion function to pointer\n  to function having the same parameter and return types as the closure\n  type\u2019s function call operator. The value returned by this conversion\n  function shall be the address of a function that, when invoked, has\n  the same effect as invoking the closure type\u2019s function call operator.</p>\n</blockquote>\n<p>The wording is modified in the draft C++14 standard but does not alter this property.</p>\n<p><b>Update</b></p>\n<p>Filed a <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/1147028\" rel=\"noreferrer\">bug report</a>.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-02-27T12:51:25.823", "Id": "27989291", "Score": "10", "CreationDate": "2015-01-16T17:17:28.537", "LastActivityDate": "2015-02-27T12:51:25.823"}, "bq_ids": {"n4140": {"so_27989031_27989291_5": {"section_id": 6171, "quality": 0.9473684210526315, "length": 36}, "so_27989031_27989291_6": {"section_id": 5965, "quality": 0.95, "length": 38}}, "n3337": {"so_27989031_27989291_5": {"section_id": 5932, "quality": 0.9473684210526315, "length": 36}, "so_27989031_27989291_6": {"section_id": 5734, "quality": 0.95, "length": 38}}, "n4659": {"so_27989031_27989291_5": {"section_id": 7669, "quality": 0.9473684210526315, "length": 36}, "so_27989031_27989291_6": {"section_id": 7456, "quality": 0.85, "length": 34}}}, "27989031": {"CommentCount": "4", "AcceptedAnswerId": "27989291", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-01-16T17:01:45.857", "LastActivityDate": "2015-02-27T12:51:25.823", "LastEditDate": "2015-01-20T18:22:54.603", "ViewCount": "1648", "FavoriteCount": "3", "Title": "MSVC error when using capture-less lambda expressions as second and third operand of conditional operator", "Id": "27989031", "Score": "4", "Body": "<p>The code below is happily accepted by both GCC and Clang with <code>-std=c++14</code> but causes a compile error with Visual Studio 2013.</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;algorithm&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nint main() {\n    auto increasing = [](int lhs, int rhs){return lhs &lt; rhs;};\n    auto decreasing = [](int lhs, int rhs){return lhs &gt; rhs;};\n    std::vector&lt;int&gt; v(0, 10);\n    bool increase = true;\n    std::sort(v.begin(), v.end(), increase ? increasing : decreasing);\n    return 0;\n}\n</code></pre>\n<p>The error is:</p>\n<p><code>main.cpp(11): error C2446: ':': no conversion from 'main::&lt;lambda_0228ee097b83254cfd8aa5f4015a245b&gt;' to 'main::&lt;lambda_cb3b816d067baa9d4462132ee332363c&gt;'\nmain.cpp(11): note: No user-defined-conversion operator available that can perform this conversion, or the operator cannot be called</code></p>\n<p>I guess my question is which compiler is compliant here, I am guessing that it is not MSVC, and is there a part of the standard which explicitly deals with this situation?</p>\n", "Tags": "<c++><visual-c++><c++11><visual-studio-2013><language-lawyer>", "OwnerUserId": "2558027", "AnswerCount": "1"}});