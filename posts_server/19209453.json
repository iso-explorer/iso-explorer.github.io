post_cb({"bq_ids": {"n4140": {"so_19209453_19209807_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 7105}, "so_19209453_19209453_1": {"length": 59, "quality": 0.9833333333333333, "section_id": 7104}}, "n3337": {"so_19209453_19209807_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 6849}, "so_19209453_19209453_1": {"length": 60, "quality": 1.0, "section_id": 6848}}, "n4659": {"so_19209453_19209807_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 8606}, "so_19209453_19209453_1": {"length": 59, "quality": 0.9833333333333333, "section_id": 8605}}}, "19209453": {"ViewCount": "340", "Body": "<p>I reproduce below the argument-dependent lookup (ADL) example given in pages 396 and 397 of Stroustrup book (4th edition):</p>\n<pre><code>namespace N {\n    struct S { int i; };\n    void f(S);\n    void g(S);\n    void h(int);\n};\n\nstruct Base {\n    void f(N::S);\n};\n\nstruct D : Base {\n    void mf(N::S);\n\n    void g(N::S x)\n    {\n        f(x);   // call Base::f()\n        mf(x);  // call D::mf()\n        h(1);   // error: no h(int) available\n    }\n};\n</code></pre>\n<p>What the comments say above is correct (I've tested it), but that doesn't seem to agree with what the author says in the next paragraph:</p>\n<blockquote>\n<p id=\"so_19209453_19209453_0\">In the standard, the rules for argument-dependent lookup are phrased\n  in terms of <em>associated namespaces</em> (iso \u00a73.4.2). Basically:</p>\n<ul>\n<li>If an argument is a class member , the associated namespaces are the class itself (including its base classes) and the class's\n  enclosing namespaces.</li>\n<li>If an argument is a member of a namespace, the associated namespaces are the enclosing namespaces.</li>\n<li>If an argument is a built-in type, there are no associated namespaces.</li>\n</ul>\n</blockquote>\n<p>In the example, <code>x</code>, which has type <code>N::S</code> is not a member of class <code>D</code>, nor of its base <code>Base</code>. But it's a member of <code>namespace N</code>. According to the second bullet above, the function <code>N::f(S)</code> should be the one called, instead of <code>Base::f()</code>.</p>\n<p>The result above also doesn't seem to agree with the second bullet in paragraph 3.4.2p2 in the Standard, which says:</p>\n<blockquote>\n<p id=\"so_19209453_19209453_1\">If T is a class type (including unions), its associated classes are:\n  the class itself; the class of which it is a member, if any; and its\n  direct and indirect base classes. Its associated namespaces are the\n  namespaces of which its associated classes are members. Furthermore,\n  if T is a class template specialization, its associated namespaces and\n  classes also include: the namespaces and classes associated with the\n  types of the template arguments provided for template type parameters\n  (excluding template template parameters); the namespaces of which any\n  template template arguments are members; and the classes of which any\n  member templates used as template template arguments are members.</p>\n</blockquote>\n", "AcceptedAnswerId": "19209807", "Title": "I need some clarification regarding this example on Stroustrup's new book about ADL", "CreationDate": "2013-10-06T13:36:09.743", "Id": "19209453", "CommentCount": "5", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2013-10-06T13:53:20.080", "LastEditorUserId": "1042389", "LastActivityDate": "2013-10-06T14:17:29.640", "Score": "3", "OwnerUserId": "1042389", "Tags": "<c++><c++11><argument-dependent-lookup>", "AnswerCount": "1"}, "19209807": {"Id": "19209807", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_19209453_19209807_0\"><strong>3.4.2/3</strong> Let <code>X</code> be the lookup set produced by unqualified lookup (3.4.1) and let <code>Y</code> be the lookup set produced by argument dependent\n  lookup (defined as follows). If <code>X</code> contains</p>\n<ul>\n<li>a declaration of a class member, or</li>\n<li>a block-scope function declaration that is not a using-declaration, or</li>\n<li>a declaration that is neither a function or a function template</li>\n</ul>\n<p id=\"so_19209453_19209807_1\">then Y is empty. Otherwise...</p>\n</blockquote>\n<p>So basically, ADL doesn't kick in when the ordinary lookup finds a member function or local (block-scope) function declaration (or something that's not a function). It does kick in when the ordinary lookup finds a stand-alone namespace-scope function, or when it finds nothing at all.</p>\n", "LastActivityDate": "2013-10-06T14:15:29.207", "CommentCount": "2", "CreationDate": "2013-10-06T14:15:29.207", "ParentId": "19209453", "Score": "4", "OwnerUserId": "1670129"}});