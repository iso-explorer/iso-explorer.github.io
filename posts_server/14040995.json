post_cb({"14041143": {"ParentId": "14040995", "CommentCount": "0", "CreationDate": "2012-12-26T13:16:46.140", "OwnerUserId": "597607", "PostTypeId": "2", "Id": "14041143", "Score": "7", "Body": "<p>It is totally undefined. You just cannot change the value of constants.</p>\n<p>It so happens that the compiler transforms your code into something like</p>\n<pre><code>cout &lt;&lt; 1 &lt;&lt; endl;\n</code></pre>\n<p>but the program could just as well crash, or do something else.</p>\n<p>If you set the warnings level high enough, the compiler will surely tell you that it is not going to work.</p>\n", "LastActivityDate": "2012-12-26T13:16:46.140"}, "14041323": {"ParentId": "14040995", "CommentCount": "1", "CreationDate": "2012-12-26T13:34:04.947", "OwnerUserId": "777186", "PostTypeId": "2", "Id": "14041323", "Score": "3", "Body": "<p>As said by  others, the behaviour is undefined.</p>\n<p>For the sake of completeness, here is the quote from the Standard:</p>\n<blockquote>\n<p id=\"so_14040995_14041323_0\">(\u00a77.1.6.1/4) Except that any class member declared mutable (7.1.1) can be modi\ufb01ed, any attempt to modify a const object during its lifetime (3.8) results in unde\ufb01ned behavior. [ Example:</p>\n<p id=\"so_14040995_14041323_1\">[...]</p>\n<pre><code>const int* ciq = new const int (3);  // initialized as required\nint* iq = const_cast&lt;int*&gt;(ciq);     // cast required\n*iq = 4;                             // unde\ufb01ned: modi\ufb01es a const object\n</code></pre>\n<p id=\"so_14040995_14041323_2\">]</p>\n</blockquote>\n<p>Note that the word <em>object</em> is this paragraph refers to all kinds of objects, including simple integers, as shown in the example \u2013 not only class objects.</p>\n<p>Although the example refers to a pointer to an object with dynamic storage, the text of the paragraph makes it clear that this applies to references to objects with automatic storage as well.</p>\n", "LastActivityDate": "2012-12-26T13:34:04.947"}, "14041067": {"ParentId": "14040995", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-12-26T13:11:05.547", "Score": "-1", "LastEditorUserId": "356440", "LastEditDate": "2012-12-26T13:32:18.463", "Id": "14041067", "OwnerUserId": "356440", "Body": "<p>You are doing a <code>const_cast</code> using the C-like <code>cast operator</code>.</p>\n<p>Using <code>const_cast</code> is not guaranteeing any behaviour.</p>\n<p>if ever you do it, it might work or it might not work. </p>\n<p>(It's not good practice to use C-like operators in C++ you know)</p>\n", "LastActivityDate": "2012-12-26T13:32:18.463"}, "14041126": {"ParentId": "14040995", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-12-26T13:15:38.330", "Score": "4", "LastEditorUserId": "298225", "LastEditDate": "2012-12-26T13:27:53.710", "Id": "14041126", "OwnerUserId": "298225", "Body": "<blockquote>\n<p id=\"so_14040995_14041126_0\">Is this behavior defined?</p>\n</blockquote>\n<p>The behavior of this code is not defined by the C++ standard, because it attempts to modify a const object.</p>\n<blockquote>\n<p id=\"so_14040995_14041126_1\">Would the compiler always use the defined value for constants?</p>\n</blockquote>\n<p>What value the compiler uses in cases like this depends on the implementation. The C++ standard does not impose a requirement.</p>\n<blockquote>\n<p id=\"so_14040995_14041126_2\">Is it possible to construct an example where the compiler would use the value of the latest assignment?</p>\n</blockquote>\n<p>There might be cases where the compiler does modify the value and use it, but they would not be reliable.</p>\n", "LastActivityDate": "2012-12-26T13:27:53.710"}, "14041201": {"ParentId": "14040995", "CommentCount": "12", "CreationDate": "2012-12-26T13:22:14.050", "OwnerUserId": "1817919", "PostTypeId": "2", "Id": "14041201", "Score": "-2", "Body": "<p>Yes you can, but only if you initiate a const as a read-only but not compile-time const, as follows:</p>\n<pre><code>int y=1;\nconst int i= y;\n(int&amp;)i= 2;\ncout &lt;&lt; i &lt;&lt; endl; // prints 2\n</code></pre>\n<p>C++ const keyword can be missleading, it's either a const or a read-only.</p>\n", "LastActivityDate": "2012-12-26T13:22:14.050"}, "14040995": {"CommentCount": "2", "AcceptedAnswerId": "14041323", "PostTypeId": "1", "LastEditorUserId": "171006", "CreationDate": "2012-12-26T13:04:54.680", "LastActivityDate": "2012-12-26T13:34:04.947", "LastEditDate": "2012-12-26T13:15:07.253", "ViewCount": "146", "FavoriteCount": "2", "Title": "const values run-time evaluation", "Id": "14040995", "Score": "3", "Body": "<p>The output of the following code:</p>\n<pre><code>const int i= 1;\n(int&amp;)i= 2;          // or:  const_cast&lt; int&amp;&gt;(i)= 2;\ncout &lt;&lt; i &lt;&lt; endl;\n</code></pre>\n<p>is <strong>1</strong> (at least under VS2012)</p>\n<p>My question:</p>\n<ul>\n<li>Is this behavior defined?</li>\n<li>Would the compiler always use the defined value for constants?</li>\n<li>Is it possible to construct an example where the compiler would use the value of the latest assignment?</li>\n</ul>\n", "Tags": "<c++>", "OwnerUserId": "171006", "AnswerCount": "6"}, "bq_ids": {"n4140": {"so_14040995_14041323_0": {"section_id": 5433, "quality": 0.75, "length": 15}}, "n3337": {"so_14040995_14041323_0": {"section_id": 5228, "quality": 0.75, "length": 15}}, "n4659": {"so_14040995_14041323_0": {"section_id": 6861, "quality": 0.75, "length": 15}}}, "14041222": {"ParentId": "14040995", "CommentCount": "2", "CreationDate": "2012-12-26T13:24:28.623", "OwnerUserId": "1284631", "PostTypeId": "2", "Id": "14041222", "Score": "3", "Body": "<p>The answer is that the behavior is undefined.</p>\n<p>I managed to set up this conclusive example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main(){\n\n        const int i = 1;\n\n        int *p=const_cast&lt;int *&gt;(&amp;i);\n        *p = 2;\n        cout &lt;&lt; i &lt;&lt; endl;\n\n        cout &lt;&lt; *p &lt;&lt; endl;\n\n        cout &lt;&lt; &amp;i &lt;&lt; endl;\n\n        cout &lt;&lt; p &lt;&lt; endl;\n\n        return 0;\n}\n</code></pre>\n<p>which, under gcc 4.7.2 gives:</p>\n<pre><code>1\n2\n0x7fffa9b7ddf4\n0x7fffa9b7ddf4\n</code></pre>\n<p>So, it is like you have the same memory address as it is holding two different values.</p>\n<p>The most probable explanation is that the compiler simply replaces constant values with their literal values.</p>\n", "LastActivityDate": "2012-12-26T13:24:28.623"}});