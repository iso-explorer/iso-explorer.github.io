post_cb({"14400385": {"CommentCount": "1", "CreationDate": "2013-01-18T13:53:21.147", "PostTypeId": "1", "AcceptedAnswerId": "14543166", "LastEditorUserId": "283302", "LastActivityDate": "2013-01-27T00:41:35.583", "LastEditDate": "2013-01-20T23:23:30.653", "ViewCount": "1124", "FavoriteCount": "1", "Title": "Accessing a member variable's address in derived class.Behavior change when member is having different access specifier", "Id": "14400385", "Score": "11", "Body": "<p>I have a base class A and  derived class B</p>\n<p>class B is derived from A as public </p>\n<p>I want to access the member variable's address if <strong>A is class a is member variable</strong> </p>\n<p>I am observing different behavior when i am using protected and public access specifier.</p>\n<p>When member a of class A is <strong>protected</strong> in this case i am getting:</p>\n<p><code>cout&lt;&lt;&amp;A::a &lt;&lt; endl;</code> throwing me an compiler error..</p>\n<p>but <code>cout&lt;&lt;&amp;(A::a)&lt;&lt;endl;</code> is valid and giving me proper result.</p>\n<p>and When member a of class A is <strong>public</strong> in this case i am getting: </p>\n<p>Why this behavior?</p>\n<p>Here is the full code :</p>\n<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nclass A\n{\n    protected:\n    int a;\n    void fun() \n    {\n    cout&lt;&lt;\"A's fun\"&lt;&lt;endl;\n    }\n\npublic:\n    A(int Aarg):a(Aarg)\n    {\n        cout &lt;&lt; \"A's construction done\" &lt;&lt;endl;\n    }\n};\n\n\nclass B: public A\n{\nprotected:\nint b;\npublic:\nvoid fun()\n{\ncout &lt;&lt; \"B's fun\"&lt;&lt;endl;\n}\n\nB(int As, int Bs):A(As), b(Bs)\n{\nstd::cout&lt;&lt;\"B's Construction Done\" &lt;&lt;std::endl;\n}\n\nvoid show()\n{\nA::fun();\n//cout &lt;&lt; a &lt;&lt; endl;\ncout&lt;&lt;&amp;A::a &lt;&lt; endl; //compilation error\n}\n};\n\nint main()\n{\n    B(10,20).show();\n    return 0;\n}\n</code></pre>\n<p><strong>Now there is a undefined behavior i am able to observe:</strong></p>\n<p>If i make my member variable a in class A as public then there will not be any compilation error but output is coming as 1 i dont know why..</p>\n<pre><code>class A{\npublic:\nint a\n....\n....\n</code></pre>\n<p>OUTPUT:</p>\n<p>A's construction done</p>\n<p>B's Construction Done</p>\n<p>A's fun</p>\n<p>0027F91C</p>\n<p>1 (why 1) and no errors as I was able to get when I tried to access protected member?</p>\n", "Tags": "<c++><visual-c++><c++11><public><visual-c++-2010>", "OwnerUserId": "1896646", "AnswerCount": "3"}, "14543166": {"ParentId": "14400385", "LastEditDate": "2013-01-27T00:41:35.583", "CommentCount": "2", "CreationDate": "2013-01-27T00:32:12.570", "OwnerUserId": "585729", "LastEditorUserId": "585729", "PostTypeId": "2", "Id": "14543166", "Score": "3", "Body": "<p>Short answer: There is no undefined behavior involved. The behavior you see is:</p>\n<ul>\n<li>The expression <code>&amp;A::a</code> is an attempt to obtain a pointer to member pointing to member a of class A. If a is protected in A, this expression only passes access checks within class A (or friends of A). In a class B derived from A, you can get the same pointer to member only via the expression <code>&amp;B::a</code> (note that the type of this expression will still be <code>int A::*</code>). So:\n<ul>\n<li>if <code>A::a</code> is protected in A, the expression <code>&amp;A::a</code> is not allowed in a member function of derived class B. This is your compiler error.</li>\n<li>if <code>A::a</code> is public in A, this expression is valid, producing a pointer to memeber. </li>\n</ul></li>\n<li>Streaming a pointer to member to an <code>ostream</code>, for example using <code>cout &lt;&lt; &amp;A::a</code> will print <code>1</code>. This results from invoking <code>ostream::operator &lt;&lt; (bool)</code>. You can use the boolalpha manipulator to see that this is indeed the chosen overload: <code>cout &lt;&lt; boolalpha &lt;&lt; &amp;A::a</code> will print <code>true</code>.</li>\n<li>If you use the modified expression &amp;(A::a) or simply &amp;a, no pointer to member is formed. Here the address of member a of the current object (i.e the same as <code>&amp;(this-&gt;a)</code>) is taken, which is a regular pointer to int. This access to a protected member of a base class subobject of <code>*this</code> is valid, so that variant can be used even if a is protected in A.</li>\n</ul>\n<p>Longer explanation:</p>\n<p>The standard says (5.3.1/3):</p>\n<blockquote>\n<p id=\"so_14400385_14543166_0\">The result of the unary &amp; operator is a pointer to its operand. The\n  operand shall be an lvalue or a qualified- id. If the operand is a\n  qualified-id naming a non-static member m of some class C with type T,\n  the result has type \u201cpointer to member of class C of type T\u201d and is a\n  prvalue designating C::m. [...]</p>\n</blockquote>\n<p>So the expression <code>&amp;A::a</code> attempts to obtain a pointer-to-member to member a of class A.</p>\n<p>In the next paragraph (5.3.1/4), it is elaborated that only the &amp;X::m syntax produces a pointer to member - neither <code>&amp;(X::m)</code>, nor <code>&amp;m</code> or plain <code>X::m</code> do:</p>\n<blockquote>\n<p id=\"so_14400385_14543166_1\">A pointer to member is only formed when an explicit &amp; is used and its\n  operand is a qualified-id not enclosed in parentheses.</p>\n</blockquote>\n<p>But such an expression is only valid, if access is allowed. In case of a protected member (11.4/1) applies:</p>\n<blockquote>\n<p id=\"so_14400385_14543166_2\">An additional access check beyond those described earlier in Clause 11\n  is applied when a non-static data member or non-static member function\n  is a protected member of its naming class (11.2) As described\n  earlier, access to a protected member is granted because the reference\n  occurs in a friend or member of some class C. If the access is to form\n  a pointer to member (5.3.1), the nested-name-specifier shall denote C\n  or a class derived from C. [...]</p>\n</blockquote>\n<p>In your case access to the protected member a would be granted, because the reference to a occurs in a member of class B, derived from A. As the expression attempts to form a pointer to member, the <em>nested-name-specifier</em> (the part before the final \"::a\") must denote B. Thus the simplest allowed form is <code>&amp;B::a</code>. The form <code>&amp;A::a</code>is only allowed within members or friends of class A itself.</p>\n<p>There is no formatted output operator for pointers to member (neither as istream member nor as free operator function), so the compiler will look at overloads that can be called using a standard conversion (sequence). The only standard conversion from pointers to member to something else is described in 4.12/1:</p>\n<blockquote>\n<p id=\"so_14400385_14543166_3\">A prvalue of [...] pointer to member type can be converted to a\n  prvalue of type bool. A [...] null member pointer value is converted\n  to false; any other value is converted to true. [...]</p>\n</blockquote>\n<p>This conversion can be used without additional conversions to call <code>basic_ostream&lt;charT,traits&gt;&amp; basic_ostream&lt;charT,traits&gt;::operator&lt;&lt;(bool n)</code>. Other overloads require longer conversion sequences, so that overload is the best match.</p>\n<p>As <code>&amp;A::a</code> takes the address of some member, it is not a null member pointer value. Thus it will convert to <code>true</code>, which prints as \"1\" (noboolalpha) or \"true\" (boolalpha). </p>\n<p>Finally, the expression <code>&amp;(A::a)</code> is valid in a member of B, even if a is protected in A. by the above rules this expression does not form a pointer to member, so the special access rule quoted above does not apply. For such cases 11.4/1 continues:</p>\n<blockquote>\n<p id=\"so_14400385_14543166_4\">All other accesses involve a (possibly implicit) object expression\n  (5.2.5). In this case, the class of the object expression shall be C\n  or a class derived from C.</p>\n</blockquote>\n<p>Here the object impression is an implicit <code>(*this)</code>, i.e. <code>A::a</code> means the same as <code>(*this).A::a</code>. The type of <code>(*this)</code> obviously is the same as the class where the access occurs (B), so the access is allowed. [Note: <code>int x = A(42).a</code> would not be allowed within B.]</p>\n<p>So <code>&amp;(A::a)</code> within <code>B::show()</code> means the same as <code>&amp;(this-&gt;a)</code> and that is a plain pointer to int.</p>\n", "LastActivityDate": "2013-01-27T00:41:35.583"}, "14400580": {"ParentId": "14400385", "CommentCount": "0", "Body": "<p>Its a syntax problem. The &amp; means you ask for the adress of the element immediately on the right.</p>\n<p>If you write :</p>\n<pre><code>&amp;A::a\n</code></pre>\n<p>It's as if you would have written</p>\n<pre><code>(&amp;A)::a\n</code></pre>\n<p>It means youre asking to access to 'a' from '&amp;A', which is not right.</p>\n<p>The &amp; doesn't apply only on variables, it can also be used on function, see : <a href=\"http://www.cprogramming.com/tutorial/function-pointers.html\" rel=\"nofollow\">http://www.cprogramming.com/tutorial/function-pointers.html</a></p>\n", "OwnerUserId": "959100", "PostTypeId": "2", "Id": "14400580", "Score": "-5", "CreationDate": "2013-01-18T14:05:28.253", "LastActivityDate": "2013-01-18T14:05:28.253"}, "bq_ids": {"n4140": {"so_14400385_14543166_1": {"section_id": 6067, "quality": 1.0, "length": 10}, "so_14400385_14543166_2": {"section_id": 6695, "quality": 0.9545454545454546, "length": 42}, "so_14400385_14543166_4": {"section_id": 6695, "quality": 0.9333333333333333, "length": 14}, "so_14400385_14543166_0": {"section_id": 6066, "quality": 0.8888888888888888, "length": 24}, "so_14400385_14543166_3": {"section_id": 44, "quality": 1.0, "length": 19}}, "n3337": {"so_14400385_14543166_1": {"section_id": 5835, "quality": 1.0, "length": 10}, "so_14400385_14543166_2": {"section_id": 6450, "quality": 0.9545454545454546, "length": 42}, "so_14400385_14543166_4": {"section_id": 6450, "quality": 0.9333333333333333, "length": 14}, "so_14400385_14543166_0": {"section_id": 5834, "quality": 0.8888888888888888, "length": 24}, "so_14400385_14543166_3": {"section_id": 41, "quality": 1.0, "length": 19}}, "n4659": {"so_14400385_14543166_2": {"section_id": 8170, "quality": 0.9545454545454546, "length": 42}, "so_14400385_14543166_1": {"section_id": 7563, "quality": 1.0, "length": 10}, "so_14400385_14543166_4": {"section_id": 8170, "quality": 0.9333333333333333, "length": 14}, "so_14400385_14543166_3": {"section_id": 45, "quality": 1.0, "length": 19}, "so_14400385_14543166_0": {"section_id": 7562, "quality": 0.8888888888888888, "length": 24}}}, "14402204": {"ParentId": "14400385", "CommentCount": "5", "Body": "<p>You are hitting a small quirk in the syntax (not that C++ has few of them...). The default way to access a member variable is through direct use of the name or through <code>this-&gt;</code>. That is, the simpler spelling of your show function would be:</p>\n<pre><code>void B::show() {\n   std::cout &lt;&lt; a &lt;&lt; std::endl;     // alternatively this-&gt;a\n   std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;    //               &amp;(this-&gt;a)\n}\n</code></pre>\n<p>Which has a simple and consistent syntax. Now the language allows you to drop in extra qualifiers to access members of a base when accessing a member:</p>\n<pre><code>std::cout &lt;&lt; A::a &lt;&lt; std::endl;     // Extra qualification\n</code></pre>\n<p>This is really equivalent to <code>this-&gt;A::a</code> and the main uses of the extra qualification are to disambiguate (if two bases had a member <code>a</code>, select the one in <code>A</code>) and in the case of virtual function disabling dynamic dispatch.</p>\n<p>Now you can do the same with pointers, as in <code>&amp;this-&gt;A::a</code>, which will take the address of the member <code>a</code> in the subobject <code>A</code> of the current object. The problem in this case is that you cannot drop the <code>this-&gt;</code> qualifier, as the syntax <code>&amp;A::a</code> is reserved to obtain a pointer to member, although by adding an extra set of parenthesis, as in <code>&amp;(A::a)</code> the parser can no longer interpret that as obtaining a pointer to member but rather as taking the address of the object represented by <code>A::a</code>, which as seen before is the member in the base.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "14402204", "Score": "4", "CreationDate": "2013-01-18T15:33:05.810", "LastActivityDate": "2013-01-18T15:33:05.810"}});