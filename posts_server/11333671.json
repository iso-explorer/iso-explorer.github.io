post_cb({"11333795": {"ParentId": "11333671", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>It is fine. The C++ standard actually clarifies the use of <code>this</code> pointers in initializer lists:</p>\n<blockquote>\n<p id=\"so_11333671_11333795_0\"><strong>12.6.2 Initializing bases and members [class.base.init]</strong></p>\n<p id=\"so_11333671_11333795_1\"><em>Paragraph 7:</em> Names in the <code>expression-list</code> of a <code>mem-initializer</code> <strong>are evaluated in the scope of the constructor</strong> for which the <code>mem-initializer</code> is specified. <em>[Example:</em></p>\n<pre><code>    class X {\n        int a;\n        int b;\n        int i;\n        int j;\n    public:\n        const int&amp; r;\n        X(int i): r(a), b(i), i(i), j(this-&gt;i) {}\n    };\n</code></pre>\n<p id=\"so_11333671_11333795_2\">initializes <code>X::r</code> to refer to <code>X::a</code>, initializes <code>X::b</code> with the\n  value of the constructor parameter <code>i</code>, initializes <code>X::i</code> with the\n  value of the constructor parameter <code>i</code>, and <strong>initializes <code>X::j</code> with\n  the value of <code>X::i</code></strong>; this takes place each time an object of class <code>X</code>\n  is created. ] <strong>[Note: because the <code>mem-initializer</code> are evaluated in\n  the scope of the constructor, the <code>this</code> pointer can be used in the\n  expression-list of a <code>mem-initializer</code> to refer to the object being\n  initialized. ]</strong></p>\n</blockquote>\n<p>The type of the <code>this</code> pointer in the initializer of <code>Baz</code> is in fact of type <code>Baz</code>. Of course, you have to be mindful of the fact that not all of the members may have been initialized. Many, if not all, compilers set at their highest warning levels (which you really should be doing anyway) will warn about you passing a <code>this</code> pointer to the base class.</p>\n<p>However, it looks like you're making it more complicated that it needs to be. Why not just put the virtual function <code>parse_bar()</code> in the <code>Bar</code> class, and forget about the <code>Foo</code> class?       </p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Bar\n{             \npublic:      \n    Bar() {}      \n    virtual ~Bar() {}      \n    void parse_self () { parse_bar(); } \nprivate: // Template method pattern\n    virtual void parse_bar() const = 0;         \n};        \n\nclass Baz : public Bar\n{      \npublic:      \n    Baz () {}     \nprivate: // Yes, this does override the private `parse_bar()` member!\n    virtual void parse_bar() const { std::cout &lt;&lt; \"Hello World\\n\"; }      \n};\n\nint main ()\n{ \n    Baz baz; \n    baz.parse_self(); \n} \n</code></pre>\n<p>This does essentially the same function but with less code.</p>\n", "OwnerUserId": "308661", "LastEditorUserId": "308661", "LastEditDate": "2012-07-04T18:26:33.423", "Id": "11333795", "Score": "3", "CreationDate": "2012-07-04T18:13:45.537", "LastActivityDate": "2012-07-04T18:26:33.423"}, "11333804": {"ParentId": "11333671", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>There are two points that have to be noted in this case.</p>\n<p>Firstly, in the  constructor initializer list <code>this</code> pointer refers to a non-constructed (or not-fully-constructed) object. It is OK to access such pointer, but the object it refers to can only be used in limited ways. See 12.7 in the language specification.</p>\n<p>Secondly, in your specific example what you are actually doing is converting <code>this</code> pointer to <code>Foo *</code> type before attempting any access. This is completely safe since by that moment the <code>Foo</code> subobject is fully constructed. (I assume that, whatever access will follow, if any, will be restricted only to the fully constructed <code>Foo</code> subobject). </p>\n<p>The only concern is this case is whether it is legal to convert <code>this</code> to <code>Foo *</code> type, i.e. whether the conversion process itself should succeed. The answer is: yes, in case of ordinary (non-virtual) inheritance such conversion is perfectly legal and safe (again, explicitly allowed in 12.7)</p>\n", "OwnerUserId": "187690", "LastEditorUserId": "187690", "LastEditDate": "2012-07-04T19:32:57.850", "Id": "11333804", "Score": "4", "CreationDate": "2012-07-04T18:15:11.413", "LastActivityDate": "2012-07-04T19:32:57.850"}, "11333671": {"CommentCount": "0", "ViewCount": "2014", "CreationDate": "2012-07-04T18:02:04.957", "LastActivityDate": "2012-07-04T19:32:57.850", "Title": "Use of this in initializer list", "AcceptedAnswerId": "11333804", "PostTypeId": "1", "Id": "11333671", "Score": "2", "Body": "<p>Suppose I have a class <code>Baz</code> that inherits from classes <code>Foo</code> and <code>Bar</code>, in that order. The constructor for class <code>Bar</code> takes a pointer to a <code>Foo</code> object. What I would like to do is to pass <code>this</code> as the <code>Foo</code> object to the <code>Bar</code> constructor:</p>\n<pre><code>Baz () : Foo(), Bar(this) {}\n</code></pre>\n<p>A working example:</p>\n<pre><code>#include &lt;iostream&gt;\nclass Bar;\nclass Foo {\n  public:\n  virtual ~Foo() {}\n  virtual void parse_bar (Bar&amp;) const = 0;\n};  \n\nclass Bar {\n  private:\n  const Foo * parser;\n  public:\n  Bar (const Foo * parser_in) : parser(parser_in) {}\n  virtual ~Bar() {}\n  void parse_self () { parser-&gt;parse_bar (*this); }\n};  \n\nclass Baz : public Foo, public Bar {\n  public:\n  Baz () : Foo(), Bar(this) {}\n  virtual void parse_bar (Bar &amp;) const { std::cout &lt;&lt; \"Hello World\\n\"; }\n};\n\nint main () {\n  Baz baz;\n  baz.parse_self();\n}\n</code></pre>\n<p>This happens to work on my computer, with my compilers (tested with a couple of them). However section 9.3.2 of the 2003 standard makes me a bit uneasy that I might just be getting lucky, that using <code>this</code> this way is undefined behavior. Strictly speaking, the initializer list is outside the body of the constructor. Here's the relevant text, emphasis mine:  </p>\n<blockquote>\n<p id=\"so_11333671_11333671_0\">9.3.2 The <code>this</code> pointer<br>\n  In the <strong>body</strong> of a nonstatic member function, the keyword <code>this</code> is a non-lvalue expression whose value is the address of the object for which the function is called.</br></p>\n</blockquote>\n<p>So is my usage legal and well-defined, or is it undefined behavior?</p>\n", "Tags": "<c++><this><language-lawyer><initializer-list>", "OwnerUserId": "774499", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_11333671_11333795_1": {"section_id": 440, "quality": 0.8, "length": 8}, "so_11333671_11333795_2": {"section_id": 440, "quality": 0.9393939393939394, "length": 31}, "so_11333671_11333671_0": {"section_id": 5895, "quality": 0.75, "length": 12}}, "n3337": {"so_11333671_11333795_1": {"section_id": 431, "quality": 0.8, "length": 8}, "so_11333671_11333795_2": {"section_id": 431, "quality": 0.9393939393939394, "length": 31}, "so_11333671_11333671_0": {"section_id": 5666, "quality": 0.75, "length": 12}}, "n4659": {"so_11333671_11333795_1": {"section_id": 460, "quality": 0.8, "length": 8}, "so_11333671_11333795_2": {"section_id": 460, "quality": 0.9393939393939394, "length": 31}, "so_11333671_11333671_0": {"section_id": 7378, "quality": 0.75, "length": 12}}}});