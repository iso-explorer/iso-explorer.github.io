post_cb({"8758353": {"ViewCount": "4051", "Body": "<p>I'm probably missing something obvious, but I can't see any difference between between <code>std::condition_variable</code> and <code>std::condition_variable_any</code>. Why do we need both?</p>\n", "AcceptedAnswerId": "8758379", "Title": "Whats the difference between std::condition_variable and std::condition_variable_any?", "CreationDate": "2012-01-06T13:14:16.157", "Id": "8758353", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2012-01-06T13:29:37.883", "LastEditorUserId": "636019", "LastActivityDate": "2012-01-06T13:32:40.207", "Score": "14", "OwnerUserId": "320608", "Tags": "<c++><c++11><std><condition-variable>", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_8758353_8758379_0": {"length": 27, "quality": 1.0, "section_id": 2977}}, "n3337": {"so_8758353_8758379_0": {"length": 27, "quality": 1.0, "section_id": 2847}}, "n4659": {"so_8758353_8758379_0": {"length": 27, "quality": 1.0, "section_id": 3736}}}, "8758524": {"Id": "8758524", "PostTypeId": "2", "Body": "<p>The difference is the parameter to the <code>wait()</code> functions. All the wait functions in <code>std::condition_variable</code> take a lock parameter of type <code>std::unique_lock&lt;std::mutex&gt;&amp;</code>, whereas the wait functions for <code>std::condition_variable_any</code> are all templates, and take a lock parameter of type <code>Lockable&amp;</code>, where <code>Lockable</code> is a template parameter.</p>\n<p>This means that <code>std::condition_variable_any</code> can work with user-defined mutex and lock types, and with things like <code>boost::shared_lock</code> --- anything that has <code>lock()</code> and <code>unlock()</code> member functions.</p>\n<p>e.g.</p>\n<pre><code>std::condition_variable_any cond;\nboost::shared_mutex m;\n\nvoid foo() {\n    boost::shared_lock&lt;boost::shared_mutex&gt; lk(m);\n    while(!some_condition()) {\n        cond.wait(lk);\n    }\n}\n</code></pre>\n<p>See the documentation for the just::thread implementation of the C++11 thread library for details:</p>\n<p><a href=\"http://www.stdthread.co.uk/doc/headers/condition_variable/condition_variable.html\" rel=\"noreferrer\"><code>std::condition_variable</code> documentation</a></p>\n<p><a href=\"http://www.stdthread.co.uk/doc/headers/condition_variable/condition_variable_any.html\" rel=\"noreferrer\"><code>std::condition_variable_any</code> documentation</a></p>\n<p>or check out the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"noreferrer\">latest public draft of the C++11 standard</a></p>\n", "LastActivityDate": "2012-01-06T13:28:18.623", "CommentCount": "0", "CreationDate": "2012-01-06T13:28:18.623", "ParentId": "8758353", "Score": "16", "OwnerUserId": "5597"}, "8758379": {"Id": "8758379", "PostTypeId": "2", "Body": "<p><code>std::condition_variable</code> is more specialized, and therefore can be more efficient when you don't need the flexibility of <code>std::condition_variable_any</code>.</p>\n<p>From N3290 \u00a730.5[thread.condition]/1</p>\n<blockquote>\n<p id=\"so_8758353_8758379_0\">Class <code>condition_variable</code> provides\n  a condition variable that can only wait on an object of type <code>unique_lock&lt;mutex&gt;</code>, allowing maximum\n  efficiency on some platforms. Class <code>condition_variable_any</code> provides a general condition variable that\n   can wait on objects of user-supplied lock types.</p>\n</blockquote>\n<p>Actually, in LLVM's libc++, <code>condition_variable_any</code> is implemented using the more specialized <code>condition_variable</code> (which uses pthread_cond_t) on a shared_mutex. </p>\n", "LastEditorUserId": "224671", "LastActivityDate": "2012-01-06T13:32:40.207", "Score": "12", "CreationDate": "2012-01-06T13:16:38.637", "ParentId": "8758353", "CommentCount": "1", "OwnerUserId": "224671", "LastEditDate": "2012-01-06T13:32:40.207"}});