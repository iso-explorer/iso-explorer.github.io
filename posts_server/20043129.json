post_cb({"20043129": {"CommentCount": "0", "AcceptedAnswerId": "20043180", "PostTypeId": "1", "LastEditorUserId": "1782465", "CreationDate": "2013-11-18T08:25:02.330", "LastActivityDate": "2013-11-18T09:41:38.093", "LastEditDate": "2013-11-18T09:41:38.093", "ViewCount": "265", "FavoriteCount": "1", "Title": "Will returning a vector<vector <int> > from a function invoke any move constructors in C++11", "Id": "20043129", "Score": "4", "Body": "<p>In C++11 will returning a <code>vector&lt;vector&lt;int&gt; &gt;</code> from a function invoke any move constructors? Or would the below code just make another copy of the all the vectors and their elements?</p>\n<pre><code>vector&lt; vector&lt;int&gt; &gt; Func() {\n  vector&lt; vector&lt;int&gt; &gt; vec;\n  //vec is filled here\n  return vec;\n}\n</code></pre>\n<p>For stl containers of simple types is there a general to find when a move constructor is used or copy is made when returning them as values from functions? </p>\n", "Tags": "<c++><c++11><move-semantics>", "OwnerUserId": "48206", "AnswerCount": "1"}, "20043180": {"ParentId": "20043129", "PostTypeId": "2", "CommentCount": "3", "Body": "<p><code>return</code> statements are specifically covered by the standard to be automatically treated as a move. So yes, this will invoke the move constructor.</p>\n<p>The letter of the law for this is C++11, <code>[class.copy]\u00a731+32</code>:</p>\n<blockquote>\n<p id=\"so_20043129_20043180_0\"><strong>31</strong> When certain criteria are met, an implementation is allowed to omit the copy/move construction of a class object ... This elision of copy/move operations, called <em>copy elision,</em> is permitted in the following circumstances (which may be combined to eliminate multiple copies):</p>\n<ul>\n<li>in a return statement in a function with a class return type, when the expression is the name of a non-volatile automatic object (other than a function or catch-clause parameter) with the same cvunqualified type as the function return type, the copy/move operation can be omitted by constructing the automatic object directly into the function's return value</li>\n<li>...</li>\n</ul>\n<p id=\"so_20043129_20043180_1\"><strong>32</strong> When the criteria for elision of a copy operation are met or would be met save for the fact that the source object is a function parameter, and the object to be copied is designated by an lvalue, <strong>overload resolution to select the constructor for the copy is first performed as if the object were designated by an rvalue.</strong> If overload resolution fails, or if the type of the first parameter of the selected constructor is not an rvalue reference to the object\u2019s type (possibly cv-qualified), overload resolution is performed again, considering the object as an lvalue.\n  ...</p>\n</blockquote>\n<p>(Emphasis mine)</p>\n<p>Combined and applied to your case, this means that when returning a local variable from a function, a move is attempted first and only if that's not possible, a copy will be performed.</p>\n<p>(And, as @BjornPollex points out, it's quite likely even the move will be elided)</p>\n", "OwnerUserId": "1782465", "LastEditorUserId": "1782465", "LastEditDate": "2013-11-18T08:38:45.087", "Id": "20043180", "Score": "3", "CreationDate": "2013-11-18T08:27:57.053", "LastActivityDate": "2013-11-18T08:38:45.087"}, "bq_ids": {"n4140": {"so_20043129_20043180_1": {"section_id": 481, "quality": 0.82, "length": 41}, "so_20043129_20043180_0": {"section_id": 480, "quality": 0.9615384615384616, "length": 25}}, "n3337": {"so_20043129_20043180_1": {"section_id": 472, "quality": 1.0, "length": 50}, "so_20043129_20043180_0": {"section_id": 471, "quality": 0.9615384615384616, "length": 25}}, "n4659": {"so_20043129_20043180_0": {"section_id": 502, "quality": 0.9615384615384616, "length": 25}, "so_20043129_20043180_1": {"section_id": 504, "quality": 0.74, "length": 37}}}});