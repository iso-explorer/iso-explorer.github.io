post_cb({"28522481": {"Id": "28522481", "PostTypeId": "2", "Body": "<p>In C: </p>\n<p><code>struct a</code> and <code>struct b</code> are not compatible types. Even in</p>\n<pre><code>typedef struct s1 { int x; } t1, *tp1;\ntypedef struct s2 { int x; } t2, *tp2;\n</code></pre>\n<p><code>s1</code> and <code>s2</code> are not compatible types. (See example in 6.7.8/p5.) An easy way to identify non-compatible structs is that if two struct types are compatible, then something of one type can be assigned to something of the other type. If you would expect the compiler to complain when you try to do that, then they are not compatible types.</p>\n<p>Therefore, <code>struct a *</code> and <code>struct b *</code> are also not compatible types, and so <code>struct a</code> and <code>struct b</code> do not share a common initial subsequence. Your union-punning is instead governed by the same rule for union punning in other cases (6.5.2.3 footnote 95):</p>\n<blockquote>\n<p id=\"so_28521188_28522481_0\">If the member used to read the contents of a union object is not the\n  same as the member last used to store a value in the object, the\n  appropriate part of the object representation of the value is\n  reinterpreted as an object representation in the new type as described\n  in 6.2.6 (a process sometimes called \u2018\u2018type punning\u2019\u2019). This might be\n  a trap representation.</p>\n</blockquote>\n<hr>\n<p>In C++, <code>struct a</code> and <code>struct b</code> also do not share a common initial subsequence. [class.mem]/p18 (quoting N4140):</p>\n<blockquote>\n<p id=\"so_28521188_28522481_1\">Two standard-layout structs share a common initial sequence if\n  corresponding members have layout-compatible types and either neither\n  member is a bit-field or both are bit-fields with the same width for a\n  sequence of one or more initial members.</p>\n</blockquote>\n<p>[basic.types]/p9:</p>\n<blockquote>\n<p id=\"so_28521188_28522481_2\">If two types <code>T1</code> and <code>T2</code> are the same type, then <code>T1</code> and <code>T2</code> are\n  <em>layout-compatible</em> types. [ <em>Note</em>: Layout-compatible enumerations are described in 7.2. Layout-compatible standard-layout structs and\n  standard-layout unions are described in 9.2. \u2014<em>end note</em> ]</p>\n</blockquote>\n<p><code>struct a *</code> and <code>struct b *</code> are neither structs nor unions nor enumerations; therefore they are only layout-compatible if they are the same type, which they are not.</p>\n<p>It is true that ([basic.compound]/p3)</p>\n<blockquote>\n<p id=\"so_28521188_28522481_3\">Pointers to cv-qualified and cv-unqualified versions (3.9.3) of\n  layout-compatible types shall have the same value representation and\n  alignment requirements (3.11).</p>\n</blockquote>\n<p>But that does not mean those pointer types are layout-compatible types, as that term is defined in the standard.</p>\n</hr>", "LastActivityDate": "2015-02-15T02:34:26.357", "CommentCount": "2", "CreationDate": "2015-02-15T02:34:26.357", "ParentId": "28521188", "Score": "5", "OwnerUserId": "2756719"}, "28528625": {"Id": "28528625", "PostTypeId": "2", "Body": "<p>What you <em>could</em> do (and i've been bitten by this before), is declare both struct's initial pointer to be <code>void*</code> and do casting. Since void is convertible to/from any pointer type, you would only be forced to pay an ugliness tax, and not risk gcc <em>reordering your operations</em> (which I've seen happen -- even if you use a union), as a result of compiler bugs in some versions. As  @T.C. correctly points out, layout compatibility of a given type means that at the language level they are convertible; even if types might incidentally have the same size they are not necessarily layout compatible; which might give some greedy compilers to assume some other things based on that.</p>\n", "LastActivityDate": "2015-02-15T17:04:13.143", "CommentCount": "0", "CreationDate": "2015-02-15T17:04:13.143", "ParentId": "28521188", "Score": "2", "OwnerUserId": "479941"}, "bq_ids": {"n4140": {"so_28521188_28528989_0": {"length": 23, "quality": 0.6388888888888888, "section_id": 5913}, "so_28521188_28521188_0": {"length": 31, "quality": 0.8611111111111112, "section_id": 5878}, "so_28521188_28522481_3": {"length": 12, "quality": 0.8571428571428571, "section_id": 7223}, "so_28521188_28522481_2": {"length": 15, "quality": 0.7894736842105263, "section_id": 7209}, "so_28521188_28522481_1": {"length": 25, "quality": 1.0, "section_id": 5878}}, "n3337": {"so_28521188_28528989_0": {"length": 22, "quality": 0.6111111111111112, "section_id": 5685}, "so_28521188_28521188_0": {"length": 31, "quality": 0.8611111111111112, "section_id": 5649}, "so_28521188_28522481_3": {"length": 12, "quality": 0.8571428571428571, "section_id": 6967}, "so_28521188_28522481_2": {"length": 16, "quality": 0.8421052631578947, "section_id": 6953}, "so_28521188_28522481_1": {"length": 25, "quality": 1.0, "section_id": 5649}}, "n4659": {"so_28521188_28528989_0": {"length": 21, "quality": 0.5833333333333334, "section_id": 7404}, "so_28521188_28522481_1": {"length": 15, "quality": 0.6, "section_id": 7359}, "so_28521188_28522481_3": {"length": 9, "quality": 0.6428571428571429, "section_id": 8732}}}, "28528989": {"Id": "28528989", "PostTypeId": "2", "Body": "<p>I've had a similar question <a href=\"https://stackoverflow.com/questions/27889199/union-of-structs-sharing-same-first-members\">some time ago</a>, and I think I can answer yours.</p>\n<p>Yes, <code>struct a</code> and <code>struct b</code> are <em>not</em> compatible types, and pointers to them are also incompatible.</p>\n<p>Yes, what you are doing is illegal even <em>from the outdated point of view of the C89 standard</em>. However, it may be interesting to note that if you reverse the order of elements in <code>struct a</code> and <code>struct b</code>, you would be able to access <code>int i</code> of a <code>struct c</code> instance (but not access its <code>next</code> pointer in any way, i.e. <code>bar-&gt;i = 9;</code> instead of <code>bar-&gt;next-&gt;i = 9;</code>), but only from the C89 standard's point of view.</p>\n<p>But even if you'll reverse the order of elements in the two <code>struct</code>s, what you're doing would still be illegal from the point of view of the C99 and C11 standards (as interpreted by the commitee). In C99, the part of the standard you have quoted has been changed to this:</p>\n<blockquote>\n<p id=\"so_28521188_28528989_0\">One special guarantee is made in order to simplify the use of unions: if a union contains several structures that share a common initial sequence (see below), and if the union object currently contains one of these structures, it is permitted to inspect the common initial part of any of them <strong>anywhere that a declaration of the completed type of the union is visible</strong>.</p>\n</blockquote>\n<p>The last phrase is a bit ambiguous, since you can interpret \"visible\" in several ways, but, according to the commitee, this means that the inspection should be performed <em>on an object of the union type in question</em>.</p>\n<p>So, in your case, the correct way to handle this would be something along the lines of:</p>\n<pre><code>struct a {\n    int i;\n    struct a *next;\n};\n\nstruct b {\n    int i;\n    struct b *next;\n};\n\nunion un {\n    struct a a;\n    struct b b;\n};\n\nstruct c {\n    int x, x2, x3;\n    union un u;\n};\n\n/* ... */\n\nvoid foo(union un *bar) {\n    bar.b-&gt;next-&gt;i = 9; /* This is the \"inspection\" operation */\n    return;\n}\n\n/* ... */\n\nfoo(&amp;c.u);\n</code></pre>\n<p>That is all fine and interesting from the language-lawyer point of view, but in reality, if you don't apply different packing settings to them, <code>struct</code>s with the same initial sequence will have it with the same layout (in 99.9% of cases). Actually, they should have the same layout even in your original setup, since the pointers to <code>struct a</code> and <code>struct b</code> should have the same size. So, if your compiler doesn't get nasty when you break <em>strict aliasing</em>, you can more-or-less safely typecast between them, or use them in a union the way you're using them now.</p>\n<p><strong>EDIT</strong>: as noted by @underscore_d in the comments to this answer, since the appropriate clauses in the C++ standards do not have the line \"anywhere that a declaration of the completed type of the union is visible\" in their appropriate parts, it may be possible that the C++ standard has the same stance on the subject as the C89 standard.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2016-01-05T16:08:37.547", "Score": "2", "CreationDate": "2015-02-15T17:37:29.470", "ParentId": "28521188", "CommentCount": "4", "OwnerUserId": "3079266", "LastEditDate": "2017-05-23T10:27:32.853"}, "28521188": {"ViewCount": "755", "Body": "<p>I've compiled this in gcc and g++ with pedantic and I don't get a warning in either one:</p>\n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\nstruct a {\n    struct a *next;\n    int i;\n};\n\nstruct b {\n    struct b *next;\n    int i;\n};\n\nstruct c {\n    int x, x2, x3;\n    union {\n        struct a a;\n        struct b b;\n    } u;\n};\n\nvoid foo(struct b *bar) {\n    bar-&gt;next-&gt;i = 9;\n    return;\n}\n\nint main(int argc, char *argv[]) {\n    struct c c;\n    memset(&amp;c, 0, sizeof c);\n    c.u.a.next = (struct a *)calloc(1, sizeof(struct a));\n    foo(&amp;c.u.b);\n    printf(\"%d\\n\", c.u.a.next-&gt;i);\n    return 0;\n}\n</code></pre>\n<p>Is this legal to do in C and C++? I've read about the type-punning but I don't understand. Is <code>foo(&amp;c.u.b)</code> any different from <code>foo((struct b *)&amp;c.u.a)</code>? Wouldn't they be exactly the same? This exception for structs in a union (from C89 in 3.3.2.3) says:</p>\n<blockquote>\n<p id=\"so_28521188_28521188_0\">If a union contains several structures that share a common initial\n  sequence, and if the union object currently contains one of these\n  structures, it is permitted to inspect the common initial part of any\n  of them. <strong>Two structures share a common initial sequence if\n  corresponding members have compatible types for a sequence of one or\n  more initial members.</strong></p>\n</blockquote>\n<p>In the union the first member of <code>struct a</code> is <code>struct a *next</code>, and the first member of <code>struct b</code> is <code>struct b *next</code>. As you can see a pointer to <code>struct a *next</code> is written, and then in foo a pointer to <code>struct b *next</code> is read.  Are they compatible types? They're both pointers to a struct and pointers to any struct should be the same size, so they should be compatible and the layout should be the same right? Is it ok to read <code>i</code> from one struct and write to the other? Am I committing any type of aliasing or type-punning violation?</p>\n", "AcceptedAnswerId": "28522481", "Title": "Type punning a struct in C and C++ via a union", "CreationDate": "2015-02-14T22:52:42.353", "Id": "28521188", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-02-14T23:27:50.857", "LastEditorUserId": "4704515", "LastActivityDate": "2016-01-05T16:08:37.547", "Score": "10", "OwnerUserId": "4704515", "Tags": "<c++><c><language-lawyer><strict-aliasing><type-punning>", "AnswerCount": "4"}, "28521500": {"Id": "28521500", "PostTypeId": "2", "Body": "<p>Yes, this is fine; the bolded part of the quote in your question covers this case.</p>\n", "LastActivityDate": "2015-02-14T23:36:56.933", "CommentCount": "0", "CreationDate": "2015-02-14T23:36:56.933", "ParentId": "28521188", "Score": "-1", "OwnerUserId": "560648"}});