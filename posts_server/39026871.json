post_cb({"bq_ids": {"n4140": {"so_39026871_39026871_1": {"section_id": 5873, "quality": 1.0, "length": 31}, "so_39026871_39027160_0": {"section_id": 3285, "quality": 1.0, "length": 17}, "so_39026871_39028696_9": {"section_id": 7201, "quality": 0.9375, "length": 30}}, "n3337": {"so_39026871_39026871_1": {"section_id": 5644, "quality": 1.0, "length": 31}, "so_39026871_39027160_0": {"section_id": 3155, "quality": 1.0, "length": 17}, "so_39026871_39028696_9": {"section_id": 6945, "quality": 0.9375, "length": 30}}, "n4659": {"so_39026871_39026871_1": {"section_id": 7356, "quality": 1.0, "length": 31}, "so_39026871_39028696_9": {"section_id": 8710, "quality": 0.9375, "length": 30}, "so_39026871_39027160_0": {"section_id": 4047, "quality": 0.9411764705882353, "length": 16}}}, "39028696": {"ParentId": "39026871", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-08-18T22:55:22.563", "Score": "1", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T10:29:08.530", "Id": "39028696", "OwnerUserId": "321013", "Body": "<p>Putting this as a partial answer wrt. <code>memcpy(&amp;num_1, buf, sizeAll)</code>:</p>\n<p>Note: <a href=\"https://stackoverflow.com/a/39028624/321013\">James' answer</a> is much more concise and definitive.</p>\n<p>I asked:</p>\n<blockquote>\n<ul>\n<li><p id=\"so_39026871_39028696_0\"><code>memcpy</code> must be allowed to write to multiple \"memory objects\" in this way at once, i.e. specifically</p>\n<ul>\n<li>Calling <code>memcpy</code> with the target address of <code>num_1</code> and a size that is larger than the size of the <code>num_1</code> \"object\" is legal. </li>\n<li>The [C++ (14) Standard][2], AFAICT, refers description of <code>memcpy</code> to the [C99 Standard][3], and that one states:</li>\n</ul>\n<blockquote>\n<p id=\"so_39026871_39028696_4\">7.21.2.1 The memcpy function</p>\n<p id=\"so_39026871_39028696_5\"><strong>2</strong> The memcpy function copies n characters from the object pointed to by s2 \n    into <em>the object pointed to by s1</em>.</p>\n</blockquote>\n<p id=\"so_39026871_39028696_3\">So for me the question here wrt. this is whether the target range we have here can be considered \"an object\" according to the C or C++\n  Standard.</p></li>\n</ul>\n</blockquote>\n<p>Thinking and searching a bit more, I found in the C Standard:</p>\n<blockquote>\n<p id=\"so_39026871_39028696_6\">\u00a7 6.2.6 Representations of types</p>\n<p id=\"so_39026871_39028696_7\">\u00a7 6.2.6.1 General</p>\n<p id=\"so_39026871_39028696_8\"><strong>2</strong> Except for bit-fields, objects are composed of contiguous sequences of one or more bytes, the number, order, and encoding of\n  which are either explicitly specified or implementation-defined.</p>\n</blockquote>\n<p>So at least it is implied that \"an object\" =&gt; \"contiguous sequence of bytes\".</p>\n<p>I'm not so bold to claim that the inverse -- \"contiguous sequence of bytes\" =&gt; \"an object\" -- holds, but at least \"an object\" doesn't seem to be defined more strictly here.</p>\n<p>Then, as quoted in Q, \u00a79.2/13 of the C++ Standard (and \u00a7 1.8/5) seem to guarantee that we <em>do</em> have a contiguous sequence of bytes (including padding).</p>\n<p><em>Then</em>, \u00a73.9/3 says:</p>\n<blockquote>\n<p id=\"so_39026871_39028696_9\"><strong>3</strong> For any trivially copyable type T, if two pointers to T point to\n  distinct T objects obj1 and obj2, where neither obj1 nor obj2 is a\n  base-class subobject, if the underlying bytes (1.7) making up obj1 are\n  copied into obj2, obj2 shall subsequently hold the same value as obj1.\n  [ Example:        </p>\n<pre><code>T* t1p;\nT* t2p;       \n     // provided that t2p points to an initialized object ...         \nstd::memcpy(t1p, t2p, sizeof(T));  \n     // at this point, every subobject of trivially copyable type in *t1p contains        \n     // the same value as the corresponding subobject in *t2p\n</code></pre>\n<p id=\"so_39026871_39028696_10\">\u2014end example ]</p>\n</blockquote>\n<p>So this explicitly allows the application of <code>memcpy</code> to <em>whole</em> objects of <em>Trivially Copyable</em> types.</p>\n<p>In the example, the three members comprise a \"trivially copyable sub-object\", and indeed I think wrapping them in an actual subobject of distinct type would still mandate exactly the same memory layout for the explicit object as for the three members:</p>\n<pre><code>struct MyStandardLayout_Flat {\n    char mem_a;\n    int16_t num_1;\n    int32_t num_2;\n    int64_t num_3;\n    char mem_z;\n};\n\nstruct MyStandardLayout_Sub {\n    int16_t num_1;\n    int32_t num_2;\n    int64_t num_3;\n};\n\nstruct MyStandardLayout_Composite {\n    char mem_a;\n    // Note that the padding here is different from the padding in MyStandardLayout_Flat, but that doesn't change how num_* are layed out.\n    MyStandardLayout_Sub nums;\n    char mem_z;\n};\n</code></pre>\n<p>The memory layout of <code>nums</code> in <code>_Composite</code> and the three members of <code>_Flat</code> should be layed out completely the same, because the same basic rules apply.</p>\n<p>So <strong>in conclusion</strong>, given that the \"sub object\" num_1 to num_3 will be represented by an equivalent contiguous sequence of bytes as a full Trivially Copyable sub-object, I: </p>\n<ul>\n<li>have a <em>very, very</em> hard time imagining an implementation or optimizer that breaks this</li>\n<li>Would say it either can be:\n\n<ul>\n<li>read as <strong>Undefined</strong> Behavior, <strong>iff</strong> we conclude that C++\u00a73.9/3 implies that <em>only</em> (full) objects of Trivially Copyable Type are allowed to be be treated thusly by <code>memcpy</code> or conclude from C99\u00a76.2.6.1/2 and the general spec of <code>memcpy</code> 7.21.2.1 that the contiguous sequence of the num_* bytes does not comprise a \"valid object\" for the purposes of memcopy.</li>\n<li>read as <strong>Defined</strong> Behavior, <strong>iff</strong> we conclude that C++\u00a73.9/3 does not normatively limit the applicability of <code>memcpy</code> to other types or memory ranges and conclude that the definition of <code>memcpy</code> (and the \"object term\") in the C99 Standard allows to treat adjacent variables as a single object contiguous bytes target.</li>\n</ul></li>\n</ul>\n", "LastActivityDate": "2016-08-18T22:55:22.563"}, "39028624": {"ParentId": "39026871", "CommentCount": "2", "CreationDate": "2016-08-18T22:47:00.710", "OwnerUserId": "451601", "PostTypeId": "2", "Id": "39028624", "Score": "2", "Body": "<blockquote>\n<p id=\"so_39026871_39028624_0\">is legal to reinterpret the memory range of the three members as a \"conceptual\"(?) char array</p>\n</blockquote>\n<p>No, arbitrary subsets of members of objects are not themselves an object of any kind.  If you can't take the <code>sizeof</code> something, it's not a thing.  Similarly, as suggested by the link you provided, if you can't identify the thing to <code>std::is_standard_layout</code>, it's not a thing.  </p>\n<p>Analogous would be </p>\n<pre><code>size_t n = (char*)&amp;num_3 - (char*)&amp;num_1;\n</code></pre>\n<p>It would compile, but it's UB: subtracted pointers must belong to the same object.  </p>\n<p>That said, I think you're in safe territory even if the standard isn't explicit.  If <code>MyStandardLayout</code> is a standard layout, it stands to reason that a subset of it also is, even if it has no name and is not an identifiable type of its own.  </p>\n<p>But I wouldn't do it.  Assignment is absolutely safe, and potentially faster than memcpy.  If the subset is meaningful and has many members, I would consider making it an explicit struct, and using assignment instead of <code>memcpy</code>, taking advantage of the default member-wise copy constructor supplied by the compiler.  </p>\n", "LastActivityDate": "2016-08-18T22:47:00.710"}, "39027160": {"ParentId": "39026871", "CommentCount": "5", "CreationDate": "2016-08-18T20:43:24.963", "OwnerUserId": "2015579", "PostTypeId": "2", "Id": "39027160", "Score": "3", "Body": "<p>\u00a78.5</p>\n<blockquote>\n<p id=\"so_39026871_39027160_0\">(6.2) \u2014 if T is a (possibly cv-qualified) non-union class type, each non-static data member and each base-class\n  subobject is zero-initialized and padding is initialized to zero bits;</p>\n</blockquote>\n<p>Now the standard does not actually say that these zero-bits will be writeable, but I can't think of an architecture that has this level of granularity on memory access permissions (nor would we want one to).</p>\n<p>So I would say that <em>in practice</em> this re-writing zeros will always be safe, even if not specifically declared so by the Powers that Be.</p>\n", "LastActivityDate": "2016-08-18T20:43:24.963"}, "39026871": {"CommentCount": "6", "AcceptedAnswerId": "39028696", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-08-18T20:23:19.337", "LastActivityDate": "2016-08-18T22:55:22.563", "LastEditDate": "2017-05-23T10:33:45.623", "ViewCount": "183", "FavoriteCount": "1", "Title": "Can I use memcpy to write to multiple adjacent Standard Layout sub-objects?", "Id": "39026871", "Score": "6", "Body": "<p><strong>Disclaimer:</strong> This is trying to drill down on a larger problem, so please don't get hung up with whether the example makes any sense in practice.</p>\n<p>And, yes, if you want to <em>copy</em> objects, please use / provide the copy-constructor. (But note how even the example does not copy a whole object; it tries to blit some memory over a few adjacent(Q.2) integers.)</p>\n<hr>\n<p>Given a C++ <a href=\"http://en.cppreference.com/w/cpp/concept/StandardLayoutType\" rel=\"nofollow noreferrer\">Standard Layout</a> <code>struct</code>, can I use <code>memcpy</code> to write to multiple (adjacent) sub-objects at once?</p>\n<p>Complete example: ( <strike><a href=\"https://ideone.com/1lP2Gd\" rel=\"nofollow noreferrer\">https://ideone.com/1lP2Gd</a></strike> <a href=\"https://ideone.com/YXspBk\" rel=\"nofollow noreferrer\">https://ideone.com/YXspBk</a>)</p>\n<pre><code>#include &lt;vector&gt;\n#include &lt;iostream&gt;\n#include &lt;assert.h&gt;\n#include &lt;inttypes.h&gt;\n#include &lt;stddef.h&gt;\n#include &lt;memory.h&gt;\n\nstruct MyStandardLayout {\n    char mem_a;\n    int16_t num_1;\n    int32_t num_2;\n    int64_t num_3;\n    char mem_z;\n\n    MyStandardLayout()\n    : mem_a('a')\n    , num_1(1 + (1 &lt;&lt; 14))\n    , num_2(1 + (1 &lt;&lt; 30))\n    , num_3(1LL + (1LL &lt;&lt; 62))\n    , mem_z('z')\n    { }\n\n    void print() const {\n        std::cout &lt;&lt; \n            \"MySL Obj: \" &lt;&lt;\n            mem_a &lt;&lt; \" / \" &lt;&lt;\n            num_1 &lt;&lt; \" / \" &lt;&lt;\n            num_2 &lt;&lt; \" / \" &lt;&lt;\n            num_3 &lt;&lt; \" / \" &lt;&lt;\n            mem_z &lt;&lt; \"\\n\";\n    }\n};\n\nvoid ZeroInts(MyStandardLayout* pObj) {\n    const size_t first = offsetof(MyStandardLayout, num_1);\n    const size_t third = offsetof(MyStandardLayout, num_3);\n    std::cout &lt;&lt; \"ofs(1st) =  \" &lt;&lt; first &lt;&lt; \"\\n\";\n    std::cout &lt;&lt; \"ofs(3rd) =  \" &lt;&lt; third &lt;&lt; \"\\n\";\n    assert(third &gt; first);\n    const size_t delta = third - first;\n    std::cout &lt;&lt; \"delta =  \" &lt;&lt; delta &lt;&lt; \"\\n\";\n    const size_t sizeAll = delta + sizeof(MyStandardLayout::num_3);\n    std::cout &lt;&lt; \"sizeAll =  \" &lt;&lt; sizeAll &lt;&lt; \"\\n\";\n\n    std::vector&lt;char&gt; buf( sizeAll, 0 );\n    memcpy(&amp;pObj-&gt;num_1, &amp;buf[0], sizeAll);\n}\n\nint main()\n{\n    MyStandardLayout obj;\n    obj.print();\n    ZeroInts(&amp;obj);\n    obj.print();\n\n    return 0;\n}\n</code></pre>\n<p>Given the wording in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">C++ Standard</a>:</p>\n<blockquote>\n<h2>9.2 Class Members</h2>\n<p id=\"so_39026871_39026871_0\">...</p>\n<p id=\"so_39026871_39026871_1\"><strong>13</strong> Nonstatic data members of a (non-union) class with the same access control (Clause 11) are allocated so that later members have\n  higher addresses within a class object. (...) Implementation alignment requirements might cause two\n  adjacent members not to be allocated immediately after each other; (...)</p>\n</blockquote>\n<p>I would conclude that it is guaranteed that <code>num_1</code> to <code>num_3</code> have increasing addresses and are adjacent modulo padding.</p>\n<p>For the above example to be fully defined, I see these requirements, of which I am not sure they hold:</p>\n<ul>\n<li><p><code>memcpy</code> must be allowed to write to multiple \"memory objects\" in this way at once, i.e. specifically</p>\n<ul>\n<li>Calling <code>memcpy</code> with the target address of <code>num_1</code> and a size that is larger than the size of the <code>num_1</code> \"object\" is legal. (Given that <code>num_1</code> is not part of an array.) (<a href=\"https://stackoverflow.com/questions/25390577/is-memcpya-1-b-1-0-defined-in-c11\">Is memcpy(&amp;a + 1, &amp;b + 1, 0) defined in C11?</a> seems a good related question, but doesn't quite fit.) </li>\n<li>The <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n4296.pdf\" rel=\"nofollow noreferrer\">C++ (14) Standard</a>, AFAICT, refers description of <code>memcpy</code> to the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"nofollow noreferrer\">C99 Standard</a>, and that one states:</li>\n</ul>\n<blockquote>\n<p id=\"so_39026871_39026871_2\">7.21.2.1 The memcpy function</p>\n<p id=\"so_39026871_39026871_3\"><strong>2</strong> The memcpy function copies n characters from the object pointed to by s2 \n  into <em>the object pointed to by s1</em>.</p>\n</blockquote>\n<p>So for me the question here wrt. this is whether the target range we have here can be considered \"an object\" according to the C or C++ Standard. Note: A (part of an) array of chars, declared and defined as such, <em>certainly</em> can be assumed to count as \"an object\" for the purposes of <code>memcpy</code> because I'm pretty sure I'm allowed to copy from one part of a char array to another part of (another) char array.  </p>\n<p>So <em>then</em> the question would be if it is legal to reinterpret the memory range of the three members as a \"conceptual\"(?) char array.</p></li>\n<li><p>Calculating <code>sizeAll</code> is legal, that is usage of <a href=\"http://en.cppreference.com/w/cpp/types/offsetof\" rel=\"nofollow noreferrer\"><code>offsetof</code></a> is legal as shown.</p></li>\n<li><p>Writing to the padding in between the members is legal.</p></li>\n</ul>\n<p>Do these properties hold? Have I missed anything else?</p>\n</hr>", "Tags": "<c++><language-lawyer><memcpy>", "OwnerUserId": "321013", "AnswerCount": "3"}});