post_cb({"42948254": {"ParentId": "42947064", "CommentCount": "2", "Body": "<p>This seems to be <strong>explicitly disallowed</strong> by the standard.\nEnding an objects lifetime, and starting a new objects\nlifetime in the same location is explicitly allowed,\n<strong>unless</strong> it's a base class:</p>\n<blockquote>\n<h2>\u00a73.8 Object Lifetime</h2>\n<p id=\"so_42947064_42948254_0\">\u00a73.8.7 - If, after the lifetime of an object has ended and before the storage\n  which the object occupied is reused or released, a new object is\n  created at the storage location which the original object occupied, a\n  pointer that pointed to the original object, a reference that referred\n  to the original object, or the name of the original object will\n  automatically refer to the new object and, once the lifetime of the\n  new object has started, can be used to manipulate the new object, <strong>if</strong>:</p>\n<ul>\n<li><p id=\"so_42947064_42948254_1\">the storage for the new object exactly overlays the storage location\n  which the original object occupied, and</p></li>\n<li><p id=\"so_42947064_42948254_2\">the new object is of the\n  same type as the original object (ignoring the top-level\n  cv-qualifiers), and</p></li>\n<li><p id=\"so_42947064_42948254_3\">[snip] and</p></li>\n<li><p id=\"so_42947064_42948254_4\">the original object was a most derived object (1.8) of type T and the\n  new object is a <strong>most derived object</strong> of type T (that is, they are not\n  base class subobjects).</p></li>\n</ul>\n</blockquote>\n", "OwnerUserId": "3202093", "PostTypeId": "2", "Id": "42948254", "Score": "8", "CreationDate": "2017-03-22T10:00:37.850", "LastActivityDate": "2017-03-22T10:00:37.850"}, "bq_ids": {"n4140": {"so_42947064_42948254_2": {"section_id": 7195, "quality": 1.0, "length": 9}, "so_42947064_42948254_1": {"section_id": 7195, "quality": 1.0, "length": 10}, "so_42947064_42948254_0": {"section_id": 7195, "quality": 0.9772727272727273, "length": 43}, "so_42947064_42948254_4": {"section_id": 7195, "quality": 1.0, "length": 17}}, "n3337": {"so_42947064_42948254_0": {"section_id": 6939, "quality": 0.9772727272727273, "length": 43}, "so_42947064_42948254_1": {"section_id": 6939, "quality": 1.0, "length": 10}, "so_42947064_42948254_2": {"section_id": 6939, "quality": 1.0, "length": 9}, "so_42947064_42948254_4": {"section_id": 6939, "quality": 1.0, "length": 17}}, "n4659": {"so_42947064_42948254_0": {"section_id": 8704, "quality": 0.9772727272727273, "length": 43}, "so_42947064_42948254_1": {"section_id": 8704, "quality": 1.0, "length": 10}, "so_42947064_42948254_2": {"section_id": 8704, "quality": 1.0, "length": 9}, "so_42947064_42948254_4": {"section_id": 8704, "quality": 1.0, "length": 17}}}, "42947064": {"CommentCount": "7", "AcceptedAnswerId": "42948254", "CreationDate": "2017-03-22T09:12:05.793", "LastActivityDate": "2017-03-22T10:00:37.850", "PostTypeId": "1", "ViewCount": "369", "FavoriteCount": "1", "Title": "Manually constructing a trivial base class via placement-new", "Id": "42947064", "Score": "14", "Body": "<p><em>Beware, we're skirting the dragon's lair.</em></p>\n<p>Consider the following two classes:</p>\n<pre><code>struct Base {\n    std::string const *str;\n};\n\nstruct Foo : Base {\n    Foo() { std::cout &lt;&lt; *str &lt;&lt; \"\\n\"; }\n};\n</code></pre>\n<p>As you can see, I'm accessing an uninitialized pointer. Or am I?</p>\n<p>Let's assume I'm only working with <code>Base</code> classes that are <a href=\"http://en.cppreference.com/w/cpp/types/is_trivial\" rel=\"noreferrer\">trivial</a>, nothing more than (potentially nested) bags of pointers.</p>\n<pre><code>static_assert(std::is_trivial&lt;Base&gt;{}, \"!\");\n</code></pre>\n<p>I would like to construct <code>Foo</code> in three steps:</p>\n<ol>\n<li><p>Allocate raw storage for a <code>Foo</code></p></li>\n<li><p>Initialize a suitably-placed <code>Base</code> subobject via placement-new</p></li>\n<li><p>Construct <code>Foo</code> via placement-new.</p></li>\n</ol>\n<p>My implementation is as follows:</p>\n<pre><code>std::unique_ptr&lt;Foo&gt; makeFooWithBase(std::string const &amp;str) {\n\n    static_assert(std::is_trivial&lt;Base&gt;{}, \"!\");\n\n    // (1)\n    auto storage = std::make_unique&lt;\n        std::aligned_storage_t&lt;sizeof(Foo), alignof(Foo)&gt;\n    &gt;();\n\n    Foo * const object = reinterpret_cast&lt;Foo *&gt;(storage.get());\n    Base * const base = object;\n\n    // (2)\n    new (base) Base{&amp;str};\n\n    // (3)\n    new (object) Foo(); \n\n    storage.release();\n    return std::unique_ptr&lt;Foo&gt;{object};\n}\n</code></pre>\n<p>Since <code>Base</code> is trivial, my understanding is that:</p>\n<ul>\n<li><p>Skipping the trivial destructor of the <code>Base</code> constructed at <code>(2)</code> is fine;</p></li>\n<li><p>The trivial default constructor of the <code>Base</code> subobject constructed as part of the <code>Foo</code> at <code>(3)</code> does nothing;</p></li>\n</ul>\n<p>And so <code>Foo</code> receives an initialized pointer, and all is well.</p>\n<p>Of course, this is what happens in practice, even at -O3 (<a href=\"http://coliru.stacked-crooked.com/a/44ecfa3329cf6226\" rel=\"noreferrer\">see for yourself!</a>).<br>\nBut is it safe, or will the dragon snatch and eat me one day?</br></p>\n", "Tags": "<c++><language-lawyer><object-lifetime><placement-new>", "OwnerUserId": "3233393", "AnswerCount": "1"}});