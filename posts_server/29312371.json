post_cb({"bq_ids": {"n4140": {"so_29312371_29312569_4": {"length": 38, "quality": 0.95, "section_id": 7152}, "so_29312371_29312569_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 7151}, "so_29312371_29312569_2": {"length": 18, "quality": 0.9, "section_id": 7151}, "so_29312371_29312569_3": {"length": 18, "quality": 1.0, "section_id": 7152}}, "n3337": {"so_29312371_29312569_4": {"length": 38, "quality": 0.95, "section_id": 6896}, "so_29312371_29312569_0": {"length": 13, "quality": 0.8666666666666667, "section_id": 6895}, "so_29312371_29312569_2": {"length": 18, "quality": 0.9, "section_id": 6895}, "so_29312371_29312569_3": {"length": 18, "quality": 1.0, "section_id": 6896}}, "n4659": {"so_29312371_29312569_4": {"length": 38, "quality": 0.95, "section_id": 8653}, "so_29312371_29312569_0": {"length": 9, "quality": 0.6, "section_id": 4051}, "so_29312371_29312569_2": {"length": 14, "quality": 0.7, "section_id": 8652}, "so_29312371_29312569_3": {"length": 17, "quality": 0.9444444444444444, "section_id": 8653}}}, "29312371": {"ViewCount": "916", "Body": "<p>1) If I'm not mistaken, C++ standard guarantees that static variables in a single translation unit are initialized in their definition order. And I'm confused about the following code fragment:</p>\n<pre><code>extern int n;\nint k = n;\nint n = 2;\n</code></pre>\n<p><code>extern int n;</code> is the declaration, not the definition, so <code>k</code> is defined before <code>n</code>, but GCC, Clang and MSVC all show me that <code>k == 2</code> after the initialization of the global variables. For me it's unclear how can <code>k</code> be assigned 2 after <code>int k = n;</code>, because <code>n</code> is not initialized at that point yet and its value must be zero. </p>\n<p>If we change the last line to:</p>\n<pre><code>int n = func();\n</code></pre>\n<p>where <code>func()</code> is non-constexpr, then <code>k</code> will be assigned zero, as I expect. So, do initialization of the global variables at the compile time change the order of the initialization?</p>\n<p>2) Here is another code fragment:</p>\n<pre><code>class Base\n{\npublic:\n    struct static_constructor\n    {\n        static_constructor()\n        {\n             i = 1;\n        }\n    };\n    static static_constructor constructor;\n    static int i;\n};\n\nBase::static_constructor Base::constructor;\nint Base::i = 2;\n</code></pre>\n<p>When <code>Base::constructor</code> is defined, its constructor is called, and <code>i = 1</code> assignment is performed. But at this point <code>Base::i</code> is not defined yet, so, please, could you explain me what happens at this point and why is <code>Base::i</code> equal to 1 in the end?</p>\n", "AcceptedAnswerId": "29312569", "Title": "C++ static variables initialization order", "CreationDate": "2015-03-28T00:50:16.370", "Id": "29312371", "CommentCount": "1", "FavoriteCount": "2", "PostTypeId": "1", "LastActivityDate": "2015-03-28T01:24:23.767", "Score": "4", "OwnerUserId": "3133604", "Tags": "<c++><initialization><global-variables><static-members><static-variables>", "AnswerCount": "1"}, "29312569": {"Id": "29312569", "PostTypeId": "2", "Body": "<p>The first scenario is well-defined in [basic.start.init]/2:</p>\n<blockquote>\n<p id=\"so_29312371_29312569_0\">Variables with static storage duration (3.7.1) or thread storage duration (3.7.2) shall be zero-initialized (8.5) before any other initialization takes place.</p>\n<p id=\"so_29312371_29312569_1\"><em>Constant initialization</em> is performed:</p>\n<ul>\n<li>if each full-expression (including implicit conversions) that appears in the initializer of a reference with static or thread storage duration is a constant expression (5.19) and the reference is bound to an lvalue designating an object with static storage duration or to a temporary (see 12.2);</li>\n<li>if an object with static or thread storage duration is initialized by a constructor call, if the constructor is a <code>constexpr</code> constructor, if all constructor arguments are constant expressions (including conversions), and if, after function invocation substitution (7.1.5), every constructor call and full-expression in the <em>mem-initializers</em> and in the <em>brace-or-equal-initializers</em> for non-static data members is a constant expression;</li>\n<li>if an object with static or thread storage duration is not initialized by a constructor call and if every full-expression that appears in its initializer is a constant expression.</li>\n</ul>\n<p id=\"so_29312371_29312569_2\">Together, zero-initialization and constant initialization are called <em>static initialization</em>; all other initialization is <em>dynamic initialization</em>. <strong>Static initialization shall be performed before any dynamic initialization takes place.</strong> (...)</p>\n</blockquote>\n<p>(Emphasis mine)</p>\n<p>The upshot of this fairly lengthy paragraph is that</p>\n<pre><code>int n = 2;\n</code></pre>\n<p>is <strong>static initialization</strong>, while</p>\n<pre><code>int k = n;\n</code></pre>\n<p>is <strong>dynamic initialization</strong> (because <code>n</code> is not a constant expression), and therefore <code>n</code> is initialized before <code>k</code> even if it appears later in the code.</p>\n<p>The same logic applies in the case of the <code>Base::static_constructor</code> example -- because the constructor of <code>Base::static_constructor</code> is not <code>constexpr</code>, <code>Base::constructor</code> is <strong>dynamically initialized</strong>, whereas <code>Base::i</code> is <strong>statically initialized</strong>. The initialization of <code>Base::i</code> therefore takes place before the initialization of <code>Base::constructor</code>.</p>\n<p>On the other hand, the second case with</p>\n<pre><code>int n = func();\n</code></pre>\n<p>puts you squarely in the territory of unspecified behavior, and it is quite explicitly mentioned in [basic.start.init]/3:</p>\n<blockquote>\n<p id=\"so_29312371_29312569_3\">An implementation is permitted to perform the initialization of a non-local variable with static storage duration as a static initialization even if such initialization is not required to be done statically, provided that</p>\n<ul>\n<li>the dynamic version of the initialization does not change the value of any other object of namespace scope prior to its initialization, and</li>\n<li>the static version of the initialization produces the same value in the initialized variable as would be produced by the dynamic initialization if all variables not required to be initialized statically were initialized dynamically.</li>\n</ul>\n<p id=\"so_29312371_29312569_4\">[<em>Note:</em> As a consequence, if the initialization of an object <code>obj1</code> refers to an object <code>obj2</code> of namespace scope potentially requiring dynamic initialization and defined later in the same translation unit, it is unspecified whether the value of <code>obj2</code> used will be the value of the fully initialized <code>obj2</code> (because <code>obj2</code> was statically initialized) or will be the value of <code>obj2</code> merely zero-initialized. For example,</p>\n<pre><code>inline double fd() { return 1.0; }\nextern double d1;\ndouble d2 = d1;     // unspecified:\n                    // may be statically initialized to 0.0 or\n                    // dynamically initialized to 0.0 if d1 is\n                    // dynamically initialized, or 1.0 otherwise\ndouble d1 = fd();   // may be initialized statically or dynamically to 1.0\n</code></pre>\n<p id=\"so_29312371_29312569_5\"><em>-- end note</em>]</p>\n</blockquote>\n", "LastEditorUserId": "4301306", "LastActivityDate": "2015-03-28T01:24:23.767", "Score": "3", "CreationDate": "2015-03-28T01:18:36.247", "ParentId": "29312371", "CommentCount": "10", "LastEditDate": "2015-03-28T01:24:23.767", "OwnerUserId": "4301306"}});