post_cb({"623693": {"LastEditDate": "2009-03-08T16:43:13.617", "Body": "<p>I have a testing struct definition as follows:</p>\n<pre><code>struct test{\n    int a, b, c;\n    bool d, e;\n    int f;\n    long g, h;\n};\n</code></pre>\n<p>And somewhere I use it this way:</p>\n<pre><code>test* t = new test;   // create the testing struct\nint* ptr = (int*) t;\nptr[2] = 15;          // directly manipulate the third word\ncout &lt;&lt; t-&gt;c;         // look if it really affected the third integer\n</code></pre>\n<p>This works correctly on my Windows - it prints 15 as expected, but is it safe? Can I be really sure the variable is on the spot in memory I want it to be - expecially in case of such combined structs (for example f is on my compiler the fifth word, but it is a sixth variable)?</p>\n<p>If not, is there any other way to manipulate struct members directly without actually having struct-&gt;member construct in the code?</p>\n", "CreationDate": "2009-03-08T14:59:14.287", "LastEditorDisplayName": "Jonathan Leffler", "AcceptedAnswerId": "623709", "CommentCount": "0", "OwnerUserId": "38256", "Score": "1", "Title": "Accessing struct members directly", "LastActivityDate": "2009-03-10T17:03:28.450", "PostTypeId": "1", "Tags": "<c++><memory><struct>", "AnswerCount": "8", "FavoriteCount": "1", "Id": "623693", "ViewCount": "10428", "LastEditorUserId": "15168"}, "623710": {"PostTypeId": "2", "ParentId": "623693", "Body": "<p>It's probably not safe and is 100% un-readable; thus making that kind of code unacceptable in real life production code.</p>\n", "CreationDate": "2009-03-08T15:09:19.537", "Score": "1", "Id": "623710", "CommentCount": "0", "OwnerDisplayName": "Max", "OwnerUserId": "446303", "LastActivityDate": "2009-03-08T15:09:19.537"}, "623702": {"PostTypeId": "2", "ParentId": "623693", "Body": "<p>No you can't be sure. The compiler is free to introduce padding between structure members. </p>\n", "CreationDate": "2009-03-08T15:04:11.437", "OwnerDisplayName": "anon", "CommentCount": "0", "Id": "623702", "Score": "5", "LastActivityDate": "2009-03-08T15:04:11.437"}, "623797": {"PostTypeId": "2", "ParentId": "623693", "Body": "<p>Aside from padding/alignment issues other answers have brought up, your code violates strict aliasing rules, which means it may break for optimized builds (not sure how MSVC does this, but GCC <code>-O3</code> will break on this type of behavior).  Essentially, because <code>test *t</code> and <code>int *ptr</code> are of different types, the compiler may assume they point to different parts of memory, and it may reorder operations.</p>\n<p>Consider this minor modification:</p>\n<pre><code>test* t = new test;\nint* ptr = (int*) t;\n\nt-&gt;c = 13;\nptr[2] = 15;\ncout &lt;&lt; t-&gt;c;\n</code></pre>\n<p>The output at the end could be either <code>13</code> or <code>15</code>, depending on the order of operations the compiler uses.</p>\n", "CreationDate": "2009-03-08T16:18:00.523", "Score": "0", "Id": "623797", "CommentCount": "2", "OwnerDisplayName": "Tom", "OwnerUserId": "40620", "LastActivityDate": "2009-03-08T16:18:00.523"}, "623711": {"PostTypeId": "2", "ParentId": "623693", "Body": "<p>You are probably looking for the <code>offsetof</code> macro. This will get you the byte offset of the member. You can then manipulate the member at that offset. Note though, this macro is implementation specific. Include <code>stddef.h</code> to get it to work.</p>\n", "CreationDate": "2009-03-08T15:12:03.663", "Score": "2", "Id": "623711", "CommentCount": "0", "OwnerDisplayName": "dirkgently", "OwnerUserId": "66692", "LastActivityDate": "2009-03-08T15:12:03.663"}, "bq_ids": {"n3337": {"so_623693_631299_0": {"quality": 0.9117647058823529, "length": 31, "section_id": 5650}}}, "631299": {"PostTypeId": "2", "ParentId": "623693", "Body": "<p>According to paragraph 9.2.17 of the standard, it is in fact legal to cast a pointer-to-struct to a pointer to its first member, providing the struct is <a href=\"http://www.parashift.com/c++-faq-lite/intrinsic-types.html#faq-26.7\" rel=\"nofollow noreferrer\">POD</a>:</p>\n<blockquote>\n<p id=\"so_623693_631299_0\">A pointer to a POD-struct object,\n  suitably converted using a\n  reinterpret_cast, points to its\n  initial member (or if that member is a\n  bit-field, then to the unit in which\n  it resides) and vice versa. [Note:\n  There might therefore be unnamed\n  padding within a POD-struct object,\n  but not at its beginning, as necessary\n  to achieve appropriate alignment. ]</p>\n</blockquote>\n<p>However, the standard makes no guarantees about the layout of structs -- even POD structs -- other than that the address of a later member will be greater than the address of an earlier member, provided there are no access specifiers (<code>private:</code>, <code>protected:</code> or <code>public:</code>) between them.  So, treating the initial part of your <code>struct test</code> as an array of 3 integers is technically undefined behaviour.</p>\n", "CreationDate": "2009-03-10T17:03:28.463", "Score": "0", "CommentCount": "0", "Id": "631299", "OwnerUserId": "47984", "LastActivityDate": "2009-03-10T17:03:28.463"}, "623709": {"LastEditDate": "2009-03-08T15:14:49.053", "Body": "<p>It looks like you are asking two questions</p>\n<p><strong>Is it safe to treat &amp;test as a 3 length int arrray?</strong></p>\n<p>It's probably best to avoid this.  This may be a defined action in the C++ standard but even if it is, it's unlikely that everyone you work with will understand what you are doing here.  I believe this is not supported if you read the standard because of the potential to pad structs but I am not sure.  </p>\n<p><strong>Is there a better way to access a member without it's name?</strong></p>\n<p>Yes.  Try using the <a href=\"http://www.cplusplus.com/reference/clibrary/cstddef/offsetof.html\" rel=\"noreferrer\">offsetof</a> macro/operator.  This will provide the memory offset of a particular member within a structure and will allow you to correctly position a point to that member.</p>\n<pre><code>size_t offset = offsetof(mystruct,c);\nint* pointerToC = (int*)((char*)&amp;someTest + offset);\n</code></pre>\n<p>Another way though would be to just take the address of c directly</p>\n<pre><code>int* pointerToC = &amp;(someTest-&gt;c);\n</code></pre>\n", "LastEditorUserId": "23283", "LastEditorDisplayName": "JaredPar", "CommentCount": "3", "OwnerUserId": "23283", "Score": "13", "PostTypeId": "2", "ParentId": "623693", "LastActivityDate": "2009-03-08T15:14:49.040", "OwnerDisplayName": "JaredPar", "Id": "623709", "CreationDate": "2009-03-08T15:08:52.733"}, "623755": {"LastEditDate": "2017-05-23T12:34:17.677", "OwnerUserId": "9530", "Body": "<p>To add to <a href=\"https://stackoverflow.com/questions/623693/accessing-struct-members-directly/623709#623709\">JaredPar's answer</a>, another option in C++ only (not in plain C) is to create a pointer-to-member object:</p>\n<pre><code>struct test\n{\n  int a, b, c;\n  bool d, e;\n  int f;\n  long g, h;\n};\n\nint main(void)\n{\n  test t1, t2;\n\n  int test::*p;  // declare p as pointing to an int member of test\n  p = &amp;test::c;  // p now points to 'c', but it's not associating with an object\n  t1-&gt;*p = 3;    // sets t1.c to 3\n  t2-&gt;*p = 4;    // sets t2.c to 4\n\n  p = &amp;test::f;\n  t1-&gt;*p = 5;    // sets t1.f to 5\n  t2-&gt;*p = 6;    // sets t2.f to 6\n}\n</code></pre>\n", "CreationDate": "2009-03-08T15:52:07.077", "CommentCount": "0", "Score": "4", "PostTypeId": "2", "ParentId": "623693", "LastActivityDate": "2009-03-08T15:52:07.077", "OwnerDisplayName": "Adam Rosenfield", "Id": "623755", "LastEditorUserId": "-1"}, "623740": {"PostTypeId": "2", "ParentId": "623693", "Body": "<p>use set methods and boost::bind for create functor which will change this variable.</p>\n", "CreationDate": "2009-03-08T15:34:08.213", "Score": "0", "Id": "623740", "CommentCount": "0", "OwnerDisplayName": "bb", "OwnerUserId": "72000", "LastActivityDate": "2009-03-08T15:34:08.213"}});