post_cb({"15488195": {"Id": "15488195", "PostTypeId": "2", "Body": "<p>Your Operating System should take care of the memory and clean it up when you exit your program, but it is in general good practice to free up any memory you have reserved. I think personally it is best to get into the correct mindset of doing so, as while you are doing simple programs, you are most likely doing so to learn.</p>\n<p>Either way, the only way to guaranteed that the memory is freed up is by doing so yourself.</p>\n", "LastActivityDate": "2013-03-18T22:29:52.267", "CommentCount": "0", "CreationDate": "2013-03-18T22:29:52.267", "ParentId": "15488099", "Score": "6", "OwnerUserId": "408182"}, "15488157": {"Id": "15488157", "PostTypeId": "2", "Body": "<p>Yes it is good practice. You should NEVER assume that your OS will take care of your memory deallocation, if you get into this habit, it will screw you later on.</p>\n<p>To answer your question, however, upon exiting from the main, the OS frees all memory held by that process, so that includes any threads that you may have spawned or variables allocated. The OS will take care of freeing up that memory for others to use.</p>\n", "LastEditorUserId": "2022562", "LastActivityDate": "2013-03-18T22:56:35.413", "Score": "39", "CreationDate": "2013-03-18T22:27:40.150", "ParentId": "15488099", "CommentCount": "6", "OwnerUserId": "2022562", "LastEditDate": "2013-03-18T22:56:35.413"}, "15677497": {"Id": "15677497", "PostTypeId": "2", "Body": "<p>Not to mention that if you are going to apply for a job as a C++ programmer there is a very good chance that you won't get past the interview because of the missing delete. First - programmers don't like any leaks usually (and the guy at the interview will be surely one of them) and second - most companies (all I worked in at least) have the \"no-leak\" policy. Generally, the software you write is supposed to run for quite a while, creating and destroying objects on the go. In such an environment leaks can lead to disasters...</p>\n", "LastActivityDate": "2013-03-28T08:48:28.487", "CommentCount": "0", "CreationDate": "2013-03-28T08:48:28.487", "ParentId": "15488099", "Score": "2", "OwnerUserId": "2210241"}, "15519758": {"Id": "15519758", "PostTypeId": "2", "Body": "<p>You got a lot of professional experience answers. Here I'm telling a naive but an answer I considered as the fact. </p>\n<ul>\n<li><p><strong>Summary</strong> </p>\n<blockquote>\n<p id=\"so_15488099_15519758_0\"><code>3.</code> Does it have deeper consequences? </p>\n</blockquote>\n<p>A: Will answer in some detail. </p>\n<blockquote>\n<p id=\"so_15488099_15519758_1\"><code>2.</code> Is it just good practice?</p>\n</blockquote>\n<p>A: It is considered a good practice. Release resources/memory you've retrieved when you're sure about it no longer used. </p>\n<blockquote id=\"so_15488099_15519758_2\">\n<ol>\n<li>Why would I need to delete <code>str</code> if I am going to end the program anyways? \n  <br/>\n  I wouldn't care if that memory goes to a land full of unicorns if I am just going to exit, right? </li>\n</ol>\n</blockquote>\n<p>A: You need <strong>or</strong> need not, in fact, <strong>you</strong> tell why. There're some explanation follows. </p>\n<p>I think it depends. Here are some assumed questions; the term <em>program</em> may mean either an application or a function.</p>\n<blockquote>\n<p id=\"so_15488099_15519758_3\">Q: Does it depend on what the program does? </p>\n</blockquote>\n<p>A: If <em>universe destroyed</em> was acceptable, then no. However, the program might not work correctly as expected, and even be a program that doesn't complete what it supposed to. You might want to seriously think about why you build a program like this? </p>\n<blockquote>\n<p id=\"so_15488099_15519758_4\">Q: Does it depend on how the program is complicated? </p>\n</blockquote>\n<p>A: No. See Explanation.  </p>\n<blockquote>\n<p id=\"so_15488099_15519758_5\">Q: Does it depend on what the stability of the program is expected? </p>\n</blockquote>\n<p>A: Closely. </p>\n<p>And I consider it depends on </p>\n<ol>\n<li>What's the <em>universe</em> of the program? </li>\n<li>How's the expectation of the program that it done its work?</li>\n<li><p>How much does the program care about others, and the <em>universe</em> where it is? </p>\n<p>About the term <em>universe</em>, see Explanation. </p></li>\n</ol>\n<p>For summary, it depends on what do <strong>you</strong> care about. </p></li>\n</ul>\n<hr>\n<ul>\n<li><p><strong>Explanation</strong> </p>\n<p><strong>Important:</strong> If we define the term <em>program</em> as a function, then its universe is <em>application</em>. There are many details omitted; as an idea for understanding, it's long enough, though. </p>\n<p>We may ever seen this kind of diagram which illustrates the relationship between application software and system software. </p>\n<p><img alt=\"9RJKM.gif\" src=\"https://i.stack.imgur.com/9RJKM.gif\"/></p>\n<p>But for being aware the scope of which one covers, I'd suggest a reversed layout. Since we are talking about software only, the hardware layer is omitted in following diagram. </p>\n<p><img alt=\"mjLai.jpg\" src=\"https://i.stack.imgur.com/mjLai.jpg\"/></p>\n<p>With this diagram, we realize that the OS covers the biggest scope, which is current the <em>universe</em>, sometimes we say the <em>environment</em>. You may imagine that the whole achitecture consists of a lot of disks like the diagram, to be either a cylinder or torus(a ball is fine but difficult to imagine). Here I should mention that the outmost of OS is in fact a <em>unibody</em>, the runtime may be either single or multiple by different implemention. </p>\n<p>It's important that the runtime is responsible to both OS and applications, but the latter is more critical. Runtime is the universe of applications, if it's destroyed all applications run under it are gone. </p>\n<p>Unlike human on the Earth, we live here, but we don't consist of Earth; we will still live in other suitable environment if the time when the Earth are destroying and we weren't there. </p>\n<p>However, we can no longer exist when the universe is destroyed, because we are not only live in the universe, but also consist of the universe. </p>\n<p>As mentioned above, the runtime is also responsible to the OS. The <strong>left circle</strong> in the following diagram is what it may looks like. </p>\n<p><img alt=\"ScsZs.jpg\" src=\"https://i.stack.imgur.com/ScsZs.jpg\"/></p>\n<p>This is mostly like a C program in the OS. When the relationship between an application and OS match this, is just the same situation as runtime in the OS above. In this diagram, the OS is the universe of applications. The reason of the applications here should be responsible to the OS, is that OS might not virtualize the code of them, or allowed to be crashed. If OS are always prevent they to do so, then it's self-responsible, no matter what applications do. But think about the <strong>drivers</strong>, it's one of the scenarios that OS must allowed to be crashed, since this kind of applications are treated as <strong>part of OS</strong>. </p>\n<p>Finally, let's see the <strong>right circle</strong> in the diagram above. In this case, the application itself be the universe. Sometimes, we call this kind of application <em>operating system</em>. If an OS never allowed custom code to be loaded and run, then it does all the things itself. Even it allowed, after itself is terminated, the memory goes <strong>nowhere</strong> but <strong>hardware</strong>. All the deallocation that may be necessary, is before it was terminated. </p>\n<p>So, how much does your program care about the others? How much does it care about its universe? And how's the expectation of the program that it done its work? It depends on <strong>what do you care about</strong>. </p></li>\n</ul>\n</hr>", "LastEditorUserId": "927012", "LastActivityDate": "2013-03-30T06:16:55.167", "Score": "2", "CreationDate": "2013-03-20T09:33:22.167", "ParentId": "15488099", "CommentCount": "0", "OwnerUserId": "927012", "LastEditDate": "2013-03-30T06:16:55.167"}, "15631309": {"Id": "15631309", "PostTypeId": "2", "Body": "<p><strong>TECHNICALLY</strong>, a programmer shouldn't rely on the OS to do any thing.\nThe OS isn't required to reclaim lost memory in this fashion. </p>\n<p><em><strong>If you do write the code that deletes all your dynamically allocated memory, then you are future proofing the code and letting others use it in a larger project.</strong></em></p>\n<p>Source: <a href=\"http://www.hpl.hp.com/personal/Hans_Boehm/gc/myths.ps\" rel=\"nofollow\" title=\"Memory Allocation Myths andHalf\u2212Truths; Allocation Myth 4\">Allocation and GC Myths</a>(PostScript alert!)</p>\n<pre>\nAllocation Myth 4: Non-garbage-collected programs should always\ndeallocate all memory they allocate.\n\nThe Truth: Omitted deallocations in frequently executed code cause\ngrowing leaks. They are rarely acceptable. but Programs that retain\nmost allocated memory until program exit often perform better without\nany intervening deallocation. Malloc is much easier to implement if\nthere is no free.\n\nIn most cases, deallocating memory just before program exit is\npointless. The OS will reclaim it anyway. Free will touch and page in\nthe dead objects; the OS won't.\n\nConsequence: Be careful with \"leak detectors\" that count allocations.\nSome \"leaks\" are good!\n</pre>\n<ul>\n<li><p>I think it's a very poor practice to use malloc/new without calling free/delete.</p></li>\n<li><p>If the memory's going to get reclaimed anyway, what harm can there be from explicitly deallocating when you need to?</p></li>\n<li><p>Maybe if the OS \"reclaims\" memory faster than free does then you'll see increased performance; this technique won't help you with any program that must remain running for any long period of time.</p></li>\n</ul>\n<p><em><strong>Having said that, so I'd recommend you use free/delete.</strong></em></p>\n<hr>\n<p><em><strong>If you get into this habit, who's to say that you won't one day accidentally apply this approach somewhere it matters?</strong></em></p></hr>\n<hr>\n<p>One should always deallocate resources after one is done with them, be it file handles/memory/mutexs. By having that habit, one will not make that sort of mistake when building servers. Some servers are expected to run 24x7. In those cases, any leak of any sort means that your server will eventually run out of that resource and hang/crash in some way. A short utility program, ya a leak isn't that bad. Any server, any leak is death. Do yourself a favor. Clean up after yourself. It's a good habit. </p>\n<hr>\n<pre>\nThink about your class 'A' having to deconstruct. If you don't call\n'delete' on 'a', that destructor won't get called. Usually, that won't\nreally matter if the process ends anyway. But what if the destructor\nhas to release e.g. objects in a database? Flush a cache to a logfile?\nWrite a memory cache back to disk? **You see, it's not just 'good\npractice' to delete objects, in some situations it is required**. \n</pre>\n</hr></hr>", "LastEditorUserId": "1219487", "LastActivityDate": "2013-04-06T00:52:37.207", "Score": "2", "CreationDate": "2013-03-26T07:09:58.783", "ParentId": "15488099", "CommentCount": "0", "OwnerUserId": "2195663", "LastEditDate": "2013-04-06T00:52:37.207"}, "15488273": {"Id": "15488273", "PostTypeId": "2", "Body": "<p>Contrary answer:  No, it is a waste of time.  A program with a vast amount of allocated data would have to touch nearly every page in order to return all of the allocations to the free list.  This wastes CPU time, creates memory pressure for uninteresting data, and possibly even causes the process to swap pages back in from disk.  Simply exiting releases all of the memory back to the OS without any further action.</p>\n<p>(not that I disagree with the reasons in \"Yes\", I just think there are arguments both ways)</p>\n", "LastActivityDate": "2013-03-18T22:35:48.663", "CommentCount": "5", "CreationDate": "2013-03-18T22:35:48.663", "ParentId": "15488099", "Score": "16", "OwnerUserId": "479989"}, "bq_ids": {"n4140": {"so_15488099_15491548_1": {"length": 47, "quality": 0.9215686274509803, "section_id": 7192}}, "n3337": {"so_15488099_15491548_1": {"length": 47, "quality": 0.9215686274509803, "section_id": 6936}}, "n4659": {"so_15488099_15491548_1": {"length": 47, "quality": 0.9215686274509803, "section_id": 8701}}}, "15488099": {"ViewCount": "2585", "Body": "<p>Lets say I have a function like this: </p>\n<pre><code>int main()\n{\n    char* str = new char[10];\n\n    for(int i=0;i&lt;5;i++)\n    {\n        //Do stuff with str\n    }\n\n    delete[] str;\n    return 0;\n}\n</code></pre>\n<ol>\n<li><p>Why would I need to delete <code>str</code> if I am going to end the program anyways?\nI wouldn't care if that memory goes to a land full of unicorns if I am just going to exit, right? </p></li>\n<li><p>Is it just good practice? </p></li>\n<li><p>Does it have deeper consequences? </p></li>\n</ol>\n", "Title": "Why do I need to delete[]?", "CreationDate": "2013-03-18T22:24:21.277", "LastActivityDate": "2014-08-13T11:38:55.053", "CommentCount": "13", "FavoriteCount": "11", "PostTypeId": "1", "LastEditDate": "2014-08-13T11:38:55.053", "LastEditorUserId": "2246344", "Id": "15488099", "Score": "44", "OwnerUserId": "2036498", "Tags": "<c++><memory><memory-management><memory-leaks><delete-operator>", "AnswerCount": "15"}, "15715872": {"Id": "15715872", "PostTypeId": "2", "Body": "<p>Instead of talking about this specific example i will talk about general cases, so generally it is important to explicitly call delete to de-allocate memory because (in case of C++) you may have some code in the destructor that you want to execute. Like maybe writing some data to a log file or sending shutting down signal to some other process etc. If you let the OS free your memory for you, your code in your destructor will not be executed. </p>\n<p>On the other hand most operating systems will deallocate the memory when your program ends. But it is good practice to deallocate it yourself and like I gave destructor example above the OS won't call your destructor, which can create undesirable behavior in certain cases!</p>\n<p>I personally consider it bad practice to rely on OS to free your memory (even though it will do) the reason is if later on you have to integrate your code with a larger program you will spend hours to track down and fix memory leaks! </p>\n<p>So clean your room before leaving!</p>\n", "LastActivityDate": "2013-03-30T06:52:52.903", "CommentCount": "0", "CreationDate": "2013-03-30T06:52:52.903", "ParentId": "15488099", "Score": "1", "OwnerUserId": "1012551"}, "15491548": {"Id": "15491548", "PostTypeId": "2", "Body": "<p>I cannot agree more to Eric Lippert's excellent advice:     </p>\n<blockquote>\n<p id=\"so_15488099_15491548_0\"><em><strong>So the answer to the question \"should I free memory before my program exits?\" is \"it depends on what your program does\".</strong></em></p></blockquote>\n<p>Other answers here have provided arguments for and against both, but the real crux of the matter is <strong><em>what your program does</em></strong>. Consider a more non-trivial example wherein the <em>type</em> instance being dynamically allocated is an custom class and the class destructor performs some actions which produces <strong><em>side effect</em></strong>. In such a situation the argument of memory leaks or not is trivial the more important problem is that failing to call <code>delete</code> on such a class instance will result in Undefined behavior.</p>\n<p><strong>[basic.life] 3.8 Object lifetime<br>\nPara 4:</br></strong> </p>\n<blockquote>\n<p id=\"so_15488099_15491548_1\">A program may end the lifetime of any object by reusing the storage which the object occupies or by explicitly calling the destructor for an object of a class type with a non-trivial destructor. For an object of a class type with a non-trivial destructor, the program is not required to call the destructor explicitly before the storage which the object occupies is reused or released; however, <strong>if there is no explicit call to the destructor or if a delete-expression (5.3.5) is not used to release the storage, the destructor shall not be implicitly called and any program that depends on the side e\ufb00ects produced by the destructor has unde\ufb01ned\n  behavior.</strong></p>\n</blockquote>\n<p>So the answer to your question is as Eric says <strong><em>\"depends on what your program does\"</em></strong></p>\n", "LastActivityDate": "2013-03-19T04:34:09.097", "CommentCount": "1", "CreationDate": "2013-03-19T04:34:09.097", "ParentId": "15488099", "Score": "3", "OwnerUserId": "452307"}, "15493853": {"Id": "15493853", "PostTypeId": "2", "Body": "<p><code>new</code> and <code>delete</code> are <strong><em>reserved keyword</em></strong> brothers. They should cooperate with each other through a code block or through the parent object's lifecyle. Whenever the younger brother commits a fault (<code>new</code>), the older brother will want to to clean (<code>delete</code>) it up. Then the mother (your program) will be happy and proud of them.</p>\n", "LastEditorUserId": "777186", "LastActivityDate": "2013-04-03T02:17:47.300", "Score": "4", "CreationDate": "2013-03-19T07:35:58.837", "ParentId": "15488099", "CommentCount": "6", "OwnerUserId": "2118405", "LastEditDate": "2013-04-03T02:17:47.300"}, "15518410": {"Id": "15518410", "PostTypeId": "2", "Body": "<p>Most operating systems will reclaim memory upon process exit.  Exceptions may include certain RTOS's, old mobile devices etc.</p>\n<p>In an absolute sense your app won't leak memory; however it's good practice to clean up memory you allocate even if you <em>know</em> it won't cause a real leak.  This issue is leaks are much, much harder to fix than not having them to begin with.   Let's say you decide that you want to move the functionality in your main() to another function.  You'll may end up with a real leak.</p>\n<p>It's also bad aesthetics, many developers will look at the unfreed 'str' and feel slight nausea :(</p>\n", "LastActivityDate": "2013-03-20T08:17:53.010", "CommentCount": "1", "CreationDate": "2013-03-20T08:17:53.010", "ParentId": "15488099", "Score": "2", "OwnerUserId": "222593"}, "15488422": {"Id": "15488422", "PostTypeId": "2", "Body": "<p>Important note : <code>delete</code>'s freeing of memory is almost just a side-effect. The important thing it does is to destruct the object. With RAII designs, this could mean anything from closing files, freeing OS handles, terminating threads, or deleting temporary files. </p>\n<p>Some of these actions would be handled by the OS automatically when your process exits, but not all.</p>\n<p>In your example, there's no reason NOT to call <code>delete</code>. but there's no reason to call <code>new</code> either, so you can sidestep  the issue this way.</p>\n<pre><code>char str[10];\n</code></pre>\n<p>Or, you can sidestep the delete (and the exception safety issues involved) by using smart pointers...</p>\n<p>So, generally you should always be making sure your object's lifetime is properly managed.  </p>\n<p>But it's not always easy: Workarounds for the <a href=\"http://www.parashift.com/c++-faq/static-init-order-on-first-use.html\">static initialization order fiasco</a> often mean that you have no choice but to rely on the OS cleaning up a handful of singleton-type objects for you.</p>\n", "LastEditorUserId": "1737", "LastActivityDate": "2013-03-18T22:53:04.177", "Score": "24", "CreationDate": "2013-03-18T22:47:31.227", "ParentId": "15488099", "CommentCount": "3", "OwnerUserId": "1737", "LastEditDate": "2013-03-18T22:53:04.177"}, "15489737": {"Id": "15489737", "PostTypeId": "2", "Body": "<p>If in fact your question really is \"I have this trivial program, is it OK that I don't free a few bytes before it exits?\" the answer is yes, that's fine. On any modern operating system that's going to be just fine. And the program is trivial; it's not like you're going to be putting it into a pacemaker or running the braking systems of a Toyota Camry with this thing. If the only customer is you then the only person you can possibly impact by being sloppy is you.</p>\n<p>The problem then comes in when you start to generalize to non-trivial cases from the answer to this question asked about a trivial case. </p>\n<p>So let's instead ask two questions about some non-trivial cases.</p>\n<blockquote>\n<p id=\"so_15488099_15489737_0\">I have a long-running service that allocates and deallocates memory in complex ways, perhaps involving multiple allocators hitting multiple heaps. Shutting down my service in the normal mode is a complicated and time-consuming process that involves ensuring that external state -- files, databases, etc -- are consistently shut down. Should I ensure that every byte of memory that I allocated is deallocated before I shut down?</p>\n</blockquote>\n<p>Yes, and I'll tell you why. One of the worst things that can happen to a long-running service is if it accidentally leaks memory. Even tiny leaks can add up to huge leaks over time. A standard technique for finding and fixing memory leaks is to instrument the allocation heaps so that at shutdown time they log all the resources that were ever allocated without being freed. Unless you like chasing down a lot of false positives and spending a lot of time in the debugger, <em>always free your memory</em> even if doing so is not strictly speaking necessary.</p>\n<p>The user is already expecting that shutting the service down might take <em>billions of nanoseconds</em> so who cares if you cause a little extra pressure on the virtual allocator making sure that everything is cleaned up?  This is just the price you pay for big complicated software. And it's not like you're shutting down the service all the time, so again, who cares if its a few milliseconds slower than it could be?</p>\n<blockquote>\n<p id=\"so_15488099_15489737_1\">I have that same long-running service. If I detect that one of my internal data structures is corrupt I wish to \"fail fast\". The program is in an undefined state, it is likely running with elevated privileges, and I am going to assume that if I detect corrupted state, it is because my service is actively being attacked by hostile parties. The safest thing to do is to shut down the service immediately. I would rather allow the attackers to deny service to the clients than to risk the service staying up and compromising my users' data further. In this emergency shutdown scenario should I make sure that every byte of memory I allocated is freed?</p>\n</blockquote>\n<p>Of course not. The operating system is going to take care of that for you. If your heap is corrupt, the attackers may be <em>hoping</em> that you free memory as part of their exploit. Every millisecond counts. And why would you bother polishing the doorknobs and mopping the kitchen before you drop a tactical nuke on the building? </p>\n<p>So the answer to the question \"should I free memory before my program exits?\" is \"it depends on what your program does\".  </p>\n", "LastEditorUserId": "88656", "LastActivityDate": "2013-03-19T01:03:17.910", "Score": "73", "CreationDate": "2013-03-19T00:58:01.963", "ParentId": "15488099", "CommentCount": "8", "OwnerUserId": "88656", "LastEditDate": "2013-03-19T01:03:17.910"}, "15667764": {"Id": "15667764", "PostTypeId": "2", "Body": "<p>Another reason that I haven't see mentioned yet is to keep the output of static and dynamic analyzer tools (e.g. valgrind or Coverity) cleaner and quieter. Clean output with zero memory leaks or zero reported issues means that when a new one pops up it is easier to detect and fix.</p>\n<p>You never know how your simple example will be used or evolved. Its better to start as clean and crisp as possible.</p>\n", "LastActivityDate": "2013-03-27T19:29:57.933", "CommentCount": "0", "CreationDate": "2013-03-27T19:29:57.933", "ParentId": "15488099", "Score": "2", "OwnerUserId": "1880559"}, "15619784": {"Id": "15619784", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_15488099_15619784_0\">Why would I need to delete str if I am going to end the program anyways? </p>\n</blockquote>\n<p>Because you don't want to be lazy ...</p>\n<blockquote>\n<p id=\"so_15488099_15619784_1\">I wouldn't care if that memory goes to a land full of unicorns if I am just going to exit, right? </p>\n</blockquote>\n<p>Nope, I don't care about the land of unicorns either. The Land of Arwen is a different matter, Then we could cut their horns off and put them to good use(I've heard its a good aphrodisiac). </p>\n<blockquote>\n<p id=\"so_15488099_15619784_2\">Is it just good practice? </p>\n</blockquote>\n<p>It is justly a good practice. </p>\n<blockquote>\n<p id=\"so_15488099_15619784_3\">Does it have deeper consequences? </p>\n</blockquote>\n<p>Someone else has to clean up after you. Maybe you like that, I moved out from under my parents' roof many years ago. </p>\n<p>Place a <em>while(1)</em> loop construct around your code without delete. The code-complexity does not matter. Memory leaks are related to process time. </p>\n<p>From the perspective of debug, <strong>not releasing</strong> system resources(file handles, etc) can cause more significant and hard to find bugs. Memory-leaks while important are typically much easier to diagnose(<em>why can't I write to this file?</em>). Bad style will become more of a problem if you start working with threads. </p>\n<pre><code>int main()\n{\n\n    while(1)\n    { \n        char* str = new char[10];\n\n        for(int i=0;i&lt;5;i++)\n        {\n            //Do stuff with str\n        }\n    }\n\n    delete[] str;\n    return 0;\n}\n</code></pre>\n", "OwnerDisplayName": "user2076992", "LastEditorUserId": "927012", "LastActivityDate": "2013-03-25T17:13:28.883", "Score": "2", "CreationDate": "2013-03-25T16:22:31.800", "ParentId": "15488099", "CommentCount": "0", "LastEditDate": "2013-03-25T17:13:28.883"}, "15517687": {"Id": "15517687", "PostTypeId": "2", "Body": "<p>It's a fair question, and there are a few things to consider when answering:</p>\n<ul>\n<li>some objects have more complex destructors which don't just release memory when they're deleted. They may have other side effects, which you <em>don't</em> want to skip.</li>\n<li>It is not guaranteed by the C++ standard that your memory will be released when the process terminates. (Of course on a modern OS it will be freed, but if you were on some weird OS which didn't do that, you'd have to free your memory properly</li>\n<li>on the other hand, running destructors at program exit can actually take up quite a lot of time, and if all the do is release memory (which would be released anyway), then yes, it makes a lot of sense to just short-circuit that and exit immediately instead.</li>\n</ul>\n", "LastActivityDate": "2013-03-20T07:28:30.163", "CommentCount": "0", "CreationDate": "2013-03-20T07:28:30.163", "ParentId": "15488099", "Score": "2", "OwnerUserId": "33213"}});