post_cb({"31619921": {"ParentId": "31619467", "CommentCount": "1", "Body": "<p>The library implementor must implement the behaviour mandated by the C++ standard, and the C++ standard specifies:</p>\n<pre><code>basic_string(const basic_string&amp; str,\n             size_type pos, size_type n = npos,\n             const Allocator&amp; a = Allocator());\n</code></pre>\n<blockquote>\n<p id=\"so_31619467_31619921_0\">Requires: pos &lt;= str.size()<br/>\n  Throws: out_of_range if pos &gt; str.size().</p>\n</blockquote>\n<p>In the case of</p>\n<pre><code>basic_string(const charT* s, size_type n,\n             const Allocator&amp; a = Allocator());\n</code></pre>\n<p>the standard says merely:</p>\n<blockquote>\n<p id=\"so_31619467_31619921_1\">Requires: s points to an array of at least n elements of charT.</p>\n</blockquote>\n<p>(All from \u00a721.4.2 [string.cons])</p>\n<p>Since the standard doesn't specify what happens in the second case if the requirement is not met, that is undefined behaviour leaving the library implementation free to do anything it wants to do. However, there is no way that the library can actually detect the fact that the requirement wasn't met, so it's free to assume that the requirement is met and then let the program break in whatever way the hardware reacts to reading an invalid address.</p>\n<p>If you are seeking a rationale, you should seek a rationale for the standard. The library implementor has practically no flexibility.</p>\n", "OwnerUserId": "1566221", "PostTypeId": "2", "Id": "31619921", "Score": "2", "CreationDate": "2015-07-24T21:16:34.177", "LastActivityDate": "2015-07-24T21:16:34.177"}, "31619561": {"ParentId": "31619467", "PostTypeId": "2", "CommentCount": "4", "CreationDate": "2015-07-24T20:51:03.290", "Score": "3", "LastEditorUserId": "2382734", "LastEditDate": "2015-07-24T21:08:01.163", "Id": "31619561", "OwnerUserId": "2382734", "Body": "<p>The difference in the two cases is simply that in the first one, it is <em>possible</em> for the implementation to check if there is an error in the parameter passed, while in the second one it is <em>impossible</em> (there is no way of checking which is the length of the string, since only a pointer is passed).</p>\n<p>So the general rule could be the following:</p>\n<ol>\n<li>If possibile, check a possible failure condition and raise an exception;</li>\n<li>otherwise, nothing can be done from the implementer point of view, and in the specification of the function document the possibility of an undefined behaviour.</li>\n</ol>\n", "LastActivityDate": "2015-07-24T21:08:01.163"}, "31619467": {"CommentCount": "1", "ViewCount": "46", "CreationDate": "2015-07-24T20:43:56.553", "LastActivityDate": "2015-07-24T21:16:34.177", "Title": "How do library implementers decide when to throw an exception vs. exhibit undefined behavior?", "AcceptedAnswerId": "31619561", "PostTypeId": "1", "Id": "31619467", "Score": "3", "Body": "<p>Specifically considering the C++ <code>string</code> class constructor spec, we have:</p>\n<pre><code>string (const string&amp; str, size_t pos, size_t len = npos);\nstring (const char* s, size_t n);\n</code></pre>\n<p>which are essentially of the same form/intent, excepting string vs. c-string.  The exception specification however is very different:</p>\n<blockquote>\n<p id=\"so_31619467_31619467_0\">If pos is greater then str's length, an out_of_range exception is\n  thrown.</p>\n<p id=\"so_31619467_31619467_1\">If n is greater than the array pointed by s, it causes\n  undefined behavior.</p>\n</blockquote>\n<p>I wonder why this is?  Performance aside, when is it a good idea to throw an exception vs. permitting \"undefined behavior\"?  The answer would seemingly depend on the following:</p>\n<ul>\n<li>the client's ability to recognize the fault a priori (i.e. the client is much less likely to recognize a potential issue with file access than with, say, popping from an empty stack that the client has explicitly been using)</li>\n<li>the client's interest in handling the potential issue (i.e. perhaps file access issues more often need to be handled, because less predictable?)</li>\n<li>what \"makes the most sense\" from the implementer's standpoint (perhaps the string version throws because it is more connected to c++ style, hence exception semantics)</li>\n</ul>\n", "Tags": "<c++><exception-handling>", "OwnerUserId": "2179687", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_31619467_31619921_1": {"section_id": 1573, "quality": 0.8333333333333334, "length": 5}, "so_31619467_31619467_1": {"section_id": 3740, "quality": 0.5714285714285714, "length": 4}}, "n3337": {"so_31619467_31619921_1": {"section_id": 1637, "quality": 0.8333333333333334, "length": 5}, "so_31619467_31619467_1": {"section_id": 3602, "quality": 0.5714285714285714, "length": 4}}, "n4659": {"so_31619467_31619921_1": {"section_id": 1726, "quality": 0.8333333333333334, "length": 5}}}, "31619629": {"ParentId": "31619467", "CommentCount": "0", "Body": "<p>The cause for the behaviour in your example is pretty obvious.</p>\n<ul>\n<li>In the first case the size of the copied string is known, it is one of the attributes of the object. It's simple to check the other parameter based on that.</li>\n<li>In the second case you have only a pointer. Generally you can't say how big the corresponding memory area is. Therefore you can't check if the other parameter is correct.</li>\n</ul>\n", "OwnerUserId": "5114938", "PostTypeId": "2", "Id": "31619629", "Score": "1", "CreationDate": "2015-07-24T20:55:33.877", "LastActivityDate": "2015-07-24T20:55:33.877"}});