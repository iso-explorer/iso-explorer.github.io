post_cb({"17663654": {"Id": "17663654", "PostTypeId": "2", "Body": "<p>With the naive implementation, you increment the input iterator <code>n</code> times, not just <code>n - 1</code> times. This is not just potentially inefficient (since iterators can have arbitrary and arbitrarily expensive user-defined types), but it may also be outright undesirable when the input iterator doesn't support a meaningful \"past-the-end\" state.</p>\n<p>For a simple example, consider reading <code>n</code> elements from <code>std::cin</code>:</p>\n<pre><code>#include &lt;iostream&gt;    // for std:cin\n#include &lt;iterator&gt;    // for std::istream_iterator\n\n\nstd::istream_iterator it(std::cin);\nint dst[3];\n</code></pre>\n<p>With the naive solution, the program blocks on the final increment:</p>\n<pre><code>int * p = dst;\n\nfor (unsigned int i = 0; i != 3; ++i) { *p++ = *it++; }   // blocks!\n</code></pre>\n<p>The standard library algorithm doesn't block:</p>\n<pre><code>#include &lt;algorithm&gt;\n\nstd::copy_n(it, 3, dst);    // fine\n</code></pre>\n<hr>\n<p>Note that the standard doesn't actually explicitly speak about iterator increments. It only says (25.3.1/5) that <code>copy_n(first, n, result)</code> has</p>\n<blockquote>\n<p id=\"so_17663449_17663654_0\"><em>Effects:</em>  For each non-negative integer <code>i &lt; n</code>, performs <code>*(result + i) = *(first + i)</code>.</p>\n</blockquote>\n<p>There is only a note in 24.2.3/3:</p>\n<blockquote>\n<p id=\"so_17663449_17663654_1\">[input-iterator] algorithms can be used with istreams as the source of the input\n  data through the <code>istream_iterator</code> class template.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "596781", "LastActivityDate": "2013-07-15T21:25:45.733", "Score": "7", "CreationDate": "2013-07-15T20:48:28.457", "ParentId": "17663449", "CommentCount": "3", "OwnerUserId": "596781", "LastEditDate": "2013-07-15T21:25:45.733"}, "17663733": {"Id": "17663733", "PostTypeId": "2", "Body": "<p>That is just an implementation. The implementation in GCC 4.4 is different (and conceptually simpler):</p>\n<pre><code>template&lt;typename InputIterator, typename _Size, typename _OutputIterator&gt;\n_OutputIterator\ncopy_n(_InputIterator __first, _Size __n,\n     _OutputIterator __result)\n{\n  for (; __n &gt; 0; --__n)\n{\n  *__result = *__first;\n  ++__first;\n  ++__result;\n}\n  return __result;\n}\n</code></pre>\n<p>[With a bit of handwaving, since I only provided the implementation when the input iterator is an <em>input iterator</em>, there is a different implementation for the case where the iterator is a <em>random access iterator</em>] That implementation has a bug in that it increments the input iterator one time more than expected.</p>\n<p>The implementation in GCC 4.8 is a bit more convoluted:</p>\n<pre><code>template&lt;typename _InputIterator, typename _Size, typename _OutputIterator&gt;\n_OutputIterator\ncopy_n(_InputIterator __first, _Size __n,\n     _OutputIterator __result)\n{\n  if (__n &gt; 0)\n{\n  while (true)\n    {\n      *__result = *__first;\n      ++__result;\n      if (--__n &gt; 0)\n    ++__first;\n      else\n    break;\n    }\n}\n  return __result;\n}\n</code></pre>\n", "LastEditorUserId": "36565", "LastActivityDate": "2013-07-15T20:59:16.650", "Score": "13", "CreationDate": "2013-07-15T20:53:32.057", "ParentId": "17663449", "CommentCount": "7", "OwnerUserId": "36565", "LastEditDate": "2013-07-15T20:59:16.650"}, "17663557": {"Id": "17663557", "PostTypeId": "2", "Body": "<p>Compare it with the naive implementation:</p>\n<pre><code>template&lt; class InputIt, class Size, class OutputIt&gt;\nOutputIt copy_n(InputIt first, Size count, OutputIt result)\n{\n  for (Size i = 0; i &lt; count; ++i) {\n    *result++ = *first++;\n  }\n  return result;\n}\n</code></pre>\n<p>This version does one more increment of <code>first</code>!</p>\n<ol>\n<li><p><code>count==0</code>, both do <code>0</code> increments of <code>first</code>.</p></li>\n<li><p><code>count==1</code>, their version does zero increments of <code>first</code>.  The above version does 1.</p></li>\n<li><p><code>count==2</code>, their version does one increments of <code>first</code>.  The above version does 2.</p></li>\n</ol>\n<p>A possibility is to handle iterators that are dereferenceable, but not incrementable.  At least in STL days, there was a distinction.  I am not sure if input iterators have this property today.</p>\n<p><a href=\"http://gcc.gnu.org/bugzilla/show_bug.cgi?id=50119\">Here</a> is a bug that seems to occur if you use the naive implementation, and <a href=\"http://en.cppreference.com/w/cpp/iterator/istream_iterator\">Here</a> is some documentation that claims \"The actual read operation is performed when the iterator is incremented, not when it is dereferenced.\"</p>\n<p>I have not yet tracked down the chapter-and-verse for the existence of dereferenceable, non-incrementable input iterators.  Apparently the standard details how many times <code>copy_n</code> dereferences the input/output iterators, but does not detail how many times it increments the input iterator.</p>\n<p>The naive implementation increments the input iterator one more time than the non-naive implementation.  If we have a single-pass input iterator that reads on <code>++</code> with insufficient space, <code>copy_n</code> could block needlessly on further input, trying to read data past the end of the input stream.</p>\n", "LastEditorUserId": "1774667", "LastActivityDate": "2013-07-16T12:30:19.163", "Score": "20", "CreationDate": "2013-07-15T20:42:26.177", "ParentId": "17663449", "CommentCount": "16", "OwnerUserId": "1774667", "LastEditDate": "2013-07-16T12:30:19.163"}, "bq_ids": {"n4140": {"so_17663449_17663654_0": {"length": 6, "quality": 0.75, "section_id": 1286}, "so_17663449_17663654_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 5570}}, "n3337": {"so_17663449_17663654_0": {"length": 6, "quality": 0.75, "section_id": 1281}, "so_17663449_17663654_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 5352}}, "n4659": {"so_17663449_17663654_0": {"length": 6, "quality": 0.75, "section_id": 1409}, "so_17663449_17663654_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 7017}}}, "17663567": {"Id": "17663567", "PostTypeId": "2", "Body": "<p>Because of the initial check</p>\n<pre><code>if (count &gt; 0)\n</code></pre>\n<p>we know that count &gt; 0, therefore the author of that code felt that he didn't need to test against count again until he reached the value of 1. Remember that \"for\" executes the conditional test at the start of every iteration, not at the end.</p>\n<pre><code>Size count = 1;\nfor (Size i = 1; i &lt; count; ++i) {\n    std::cout &lt;&lt; i &lt;&lt; std::endl;\n}\n</code></pre>\n<p>would print nothing.</p>\n<p>Thus the code eliminates a conditional branch, and if Size is 1, it eliminates the need to increment/adjust \"first\" - hence it being a pre-increment.</p>\n", "LastActivityDate": "2013-07-15T20:42:51.750", "CommentCount": "0", "CreationDate": "2013-07-15T20:42:51.750", "ParentId": "17663449", "Score": "1", "OwnerUserId": "257645"}, "17663449": {"ViewCount": "2547", "Body": "<p>When I like to know how a algorithm in the C++ Standard Library could be implemented, I always look at <a href=\"http://en.cppreference.com/w/cpp/algorithm\" rel=\"noreferrer\">http://en.cppreference.com/w/cpp/algorithm</a>, which is a great source. But sometimes I don't understand some implementation details and I would need some explanation why something is done that particular way. For example in the implementation of <a href=\"http://en.cppreference.com/w/cpp/algorithm/copy_n\" rel=\"noreferrer\"><code>std::copy_n</code></a>, why the first assignment is made outside the loop and the loop therefore starts with <code>1</code>?</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>template&lt; class InputIt, class Size, class OutputIt&gt;\nOutputIt copy_n(InputIt first, Size count, OutputIt result)\n{\n    if (count &gt; 0) {\n        *result++ = *first;\n        for (Size i = 1; i &lt; count; ++i) {\n            *result++ = *++first;\n        }\n    }\n    return result;\n}\n</code></pre>\n<p>Additionally: Do you know a site where possible algorithm implementations are explained?</p>\n", "AcceptedAnswerId": "17663557", "Title": "C++ <algorithm> implementation explained", "CreationDate": "2013-07-15T20:36:40.713", "Id": "17663449", "CommentCount": "3", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2013-07-16T07:54:29.773", "LastEditorUserId": "237483", "LastActivityDate": "2013-07-16T12:30:19.163", "Score": "30", "OwnerUserId": "237483", "Tags": "<c++><stl-algorithm>", "AnswerCount": "4"}});