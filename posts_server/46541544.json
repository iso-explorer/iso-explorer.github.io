post_cb({"bq_ids": {"n4140": {"so_46541544_46543078_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 703}}, "n3337": {"so_46541544_46543078_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 693}}, "n4659": {"so_46541544_46543078_1": {"length": 11, "quality": 0.9166666666666666, "section_id": 732}}}, "46541544": {"ViewCount": "73", "Body": "<p>According to <a href=\"http://en.cppreference.com/w/cpp/container/deque\" rel=\"nofollow noreferrer\">C++ standard</a> std::deque is something like </p>\n<pre><code>std::vector&lt;std::array&lt;T, M&gt; *&gt;\n</code></pre>\n<p>If so, how is it possible that insertion or removal of elements at the end or beginning is constant O(1)? If the capacity of the vector exceeded and we insert something at the end or beginning there is no guarantee the the entire vector is not reallocated, so we have 0(N/M) that actually is 0(N), isn't it? (N is the size of the deque).</p>\n", "AcceptedAnswerId": "46543078", "Title": "Why is the complexity of insertion or removal of elements at the end or beginning of std::deque constant O(1)?", "CreationDate": "2017-10-03T09:38:50.593", "Id": "46541544", "CommentCount": "7", "LastEditDate": "2017-10-03T09:41:42.557", "PostTypeId": "1", "LastEditorUserId": "8035619", "LastActivityDate": "2017-10-03T11:03:46.777", "Score": "4", "OwnerUserId": "8035619", "Tags": "<c++11>", "AnswerCount": "2"}, "46542298": {"Id": "46542298", "PostTypeId": "2", "Body": "<p>Amortized constant complexity for insertion at the front is (typically) achieved by assigning from the <em>middle</em> of the vector of pointers outwards.</p>\n<p>For example, if we have a deque with 3 nodes, each holding up to 4 elements, we might assign its vector of 8 pointers thus:</p>\n<pre><code>[ nil, nil, nil, N1*, N2*, N3*, nil, nil ]\n</code></pre>\n<p>Here <code>N1</code> and <code>N3</code> might themselves be partially filled:</p>\n<pre><code>N1: [ nil, nil, nil, 1 ]\nN2: [ 2, 3, 4, 5 ]\nN3: [ 6, 7, nil, nil ]\n</code></pre>\n<p>As we <code>push_front</code> onto the deque, first <code>N1</code> is filled towards the front, then additional nodes are allocated and added to the vector of pointers. Once the vector of pointers is filled at the front, any additional <code>push_front</code> results in an exponential expansion with the additional space assigned at the front:</p>\n<pre><code>[ N1*, N2*, N3*, N4*, N5*, N6*, nil, nil ]\n  |                         `---------------------------------------\\\n  `-----------------------------------v                             v\n[ nil, nil, nil, nil, nil, nil, nil, N0*, N1*, N2*, N3*, N4*, N5*, N6*, nil, nil ]\n</code></pre>\n<p>This exponential growth policy achieves O(1) amortized complexity for both <code>deque::push_front</code> and <code>deque::push_back</code> for the same reason that <code>vector::push_back</code> has O(1) amortized complexity.</p>\n", "LastActivityDate": "2017-10-03T10:19:44.907", "CommentCount": "4", "CreationDate": "2017-10-03T10:19:44.907", "ParentId": "46541544", "Score": "2", "OwnerUserId": "567292"}, "46543078": {"Id": "46543078", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_46541544_46543078_0\">If the capacity of the vector exceeded and we insert something at the end or beginning there is no guarantee the the entire vector is not reallocated, so we have 0(N/M) that actually is 0(N), isn't it? (N is the size of the deque).</p>\n</blockquote>\n<p>Yes, but no elements need to be copied/moved to reallocate that vector, only the pointers to the arrays need to be moved to the new storage.</p>\n<p>The standard states:</p>\n<blockquote>\n<p id=\"so_46541544_46543078_1\"><strong>[container.requirements.general]</strong><br>\n  -2- All of the complexity requirements in this Clause are stated solely in terms of the number of operations on the contained objects.</br></p>\n</blockquote>\n<p>So the fact there are N/M copies of pointers isn't counted in the O(1) complexity requirement. And since those operations on pointers are very cheap, the performance of those operations is not a problem in practice. The <code>deque</code> needs to allocate a new page for every M elements inserted, but it never needs to reallocate the existing pages and move every existing element, so it avoids the most expensive operations on vector, so vector's exponential growth is not needed to make deques cheap.</p>\n", "LastActivityDate": "2017-10-03T11:03:46.777", "CommentCount": "0", "CreationDate": "2017-10-03T11:03:46.777", "ParentId": "46541544", "Score": "3", "OwnerUserId": "981959"}});