post_cb({"25239571": {"ParentId": "25239203", "PostTypeId": "2", "CommentCount": "1", "CreationDate": "2014-08-11T09:06:51.953", "Score": "1", "LastEditorUserId": "661519", "LastEditDate": "2014-08-11T09:21:00.297", "Id": "25239571", "OwnerUserId": "661519", "Body": "<p>You can take advantage of the fact that arrays in user defined types are copied and assigned when instances of that type are copied or assigned, for example</p>\n<pre><code>template &lt;size_t N, size_t M&gt;\nstruct Foo\n{\n  int data[N][M];\n};\n\ntemplate &lt;size_t N, size_t M&gt;\nvoid func1(Foo&lt;N, M&gt; foo)\n{\n  foo.data[1][2] = 42;\n}\n\nint main()\n{\n  Foo&lt;3, 3&gt; f;\n  f.data[0][0]=2;\n  ...\n  func1(f);\n}\n</code></pre>\n<p>Here, <code>func1</code> has a local copy of the <code>foo</code>, which has its own copy of the array. I have used templates to generalize to arbitrary sizes.</p>\n<p>Note that C++ provides the <code>std::array</code> template, which you could use instead of <code>Foo</code>, so in real code you would do something like this:</p>\n<pre><code>#include &lt;array&gt;\n\ntemplate &lt;typename T, size_t N, size_t M&gt;\nvoid func1(std::array&lt;std::array&lt;T, N&gt;, M&gt; arr)\n{\n  arr[1][2] = 42;\n}\n\nint main()\n{\n  std::array&lt;std::array&lt;int, 3&gt;, 3&gt; a;\n  a[0][0]=2;\n  ...\n  func1(a);\n}\n</code></pre>\n<p>If you are stuck with pre-C++11 implementations, you can use either <code>std::tr1::array</code> (header <code>&lt;tr1/array&gt;</code> or <code>boost::array</code> from the boost library. It is also a nice exercise to roll out your own.</p>\n", "LastActivityDate": "2014-08-11T09:21:00.297"}, "25239356": {"ParentId": "25239203", "CommentCount": "0", "CreationDate": "2014-08-11T08:56:56.243", "OwnerUserId": "1805657", "PostTypeId": "2", "Id": "25239356", "Score": "0", "Body": "<p>An array is passed as a pointer, and it is not very C++`ish to pass 2d arrays as pointer.\nYou should a class to encapsulate the array and pass a reference to that class.</p>\n<p>This way the \"user\" doesn't know of the underlying implementation of your array as well and you can change it without affecting functionality later on.\nAnd of course passing a const reference to a class instance will be as lightweight as passing pointers, hence there will be no performance impact.</p>\n", "LastActivityDate": "2014-08-11T08:56:56.243"}, "25239203": {"CommentCount": "9", "ViewCount": "186", "PostTypeId": "1", "LastEditorUserId": "3002139", "CreationDate": "2014-08-11T08:48:31.143", "LastActivityDate": "2014-08-11T10:40:58.060", "Title": "Passing 2D array by value doesn't work", "AcceptedAnswerId": "25239594", "LastEditDate": "2014-08-11T09:03:09.387", "Id": "25239203", "Score": "-2", "Body": "<p>I am trying to pass a 2d array to a function. I don't want the actual array to be modified. So pass it by value. But my actual 2darray is getting modified.(when i modify myArray, x is getting modified). Why is it so?</p>\n<pre><code>int main(int argc, const char* argv[])\n{\n    int x[3][3];\n    x[0][0]=2;\n    x[0][1]=2;\n    x[0][2]=2;\n    x[1][0]=2;\n    x[1][1]=2;\n    x[1][2]=2;\n    x[2][0]=2;\n    x[2][1]=2;\n    x[2][2]=2;\n    func1(x);\n}\n\nvoid func1(int myArray[][3])\n{\n    int i, j;\n    int ROWS=3;\n    int COLS=3;\n\n     for (i=0; i&lt;ROWS; i++)\n     {\n         for (j=0; j&lt;COLS; j++)\n         {\n             myArray[i][j] =3;\n         }\n     }\n}\n</code></pre>\n<p>And is it possible to pass a 2D array by value if we don't know both dimensions?.</p>\n", "Tags": "<c++><c><arrays><function-calls><function-call>", "OwnerUserId": "3852475", "AnswerCount": "4"}, "25239492": {"ParentId": "25239203", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-08-11T09:02:45.467", "Score": "0", "LastEditorUserId": "3723423", "LastEditDate": "2014-08-11T09:38:08.673", "Id": "25239492", "OwnerUserId": "3723423", "Body": "<p>In standard C++,  section <em>8.3.5 Functions</em> point 5 explains that: </p>\n<blockquote>\n<p id=\"so_25239203_25239492_0\">After determining the type of each parameter, any parameter of type\n  \u201carray of T\u201d or \u201cfunction returning T\u201d is adjusted to be \u201cpointer to\n  T\u201d or \u201cpointer to function returning T,\u201d respectively.</p>\n</blockquote>\n<p>This is why your function works in fact with a pointer and modifies the original value. </p>\n<p>Point 8 explains further that:  </p>\n<blockquote>\n<p id=\"so_25239203_25239492_1\">If the type of a parameter includes a type of the form \u201carray of\n  runtime bound of T\u201d, \u201cpointer to array of unknown bound of T\u201d, or\n  \u201creference to array of unknown bound of T\u201d, the program is ill-formed.</p>\n</blockquote>\n<p>So, you have to know the size in advance.  </p>\n<p><strong><em>Alternative:</em></strong> </p>\n<p>If you'd like to work by value, better use standard containers, such as vectors (here, <code>vector&lt;vector&lt;int&gt;&gt;</code>). Your x would then be declared in main() with:  </p>\n<pre><code>vector&lt;vector&lt;int&gt;&gt; x(3, vector&lt;int&gt;(3));  // initialised vector of 3 vector of 3 ints\n</code></pre>\n<p>or even better, to get rid of your long list of assignments to the same constant:  </p>\n<pre><code>vector&lt;vector&lt;int&gt;&gt; x(3, vector&lt;int&gt;(3, 2));  // vector of 3 vector of 3 ints with value 2\n</code></pre>\n<p>And your function be defined as:  </p>\n<pre><code>void func1(vector&lt;vector&lt;int&gt;&gt; myArray)\n{   // resets all existing values to 3.  \n    for (size_t i = 0; i&lt;myArray.size(); i++)\n        for (size_t j = 0; j&lt;myArray[i].size(); j++)\n            myArray[i][j] = 3;\n}  \n</code></pre>\n", "LastActivityDate": "2014-08-11T09:38:08.673"}, "25239594": {"ParentId": "25239203", "CommentCount": "3", "CreationDate": "2014-08-11T09:07:53.953", "OwnerUserId": "908821", "PostTypeId": "2", "Id": "25239594", "Score": "0", "Body": "<p>to prevent func1 from being changed, change it to a const pointer. </p>\n<pre><code>void func1(const int (*myArray)[3])\n{\n    int i, j;\n    int ROWS=3;\n    int COLS=3;\n\n     for (i=0; i&lt;ROWS; i++)\n     {\n         for (j=0; j&lt;COLS; j++)\n         {\n            // myArray[i][j] =3; //compilation error, is now const\n            cout &lt;&lt;\" \"&lt;&lt;myArray[i][j];  \n         }\n     }\n}\n</code></pre>\n", "LastActivityDate": "2014-08-11T09:07:53.953"}, "bq_ids": {"n4140": {"so_25239203_25239492_0": {"section_id": 3241, "quality": 1.0, "length": 16}, "so_25239203_25239492_1": {"section_id": 3244, "quality": 0.8235294117647058, "length": 14}}, "n3337": {"so_25239203_25239492_0": {"section_id": 3114, "quality": 1.0, "length": 16}, "so_25239203_25239492_1": {"section_id": 3117, "quality": 0.8235294117647058, "length": 14}}, "n4659": {"so_25239203_25239492_0": {"section_id": 3997, "quality": 0.75, "length": 12}, "so_25239203_25239492_1": {"section_id": 6103, "quality": 0.7058823529411765, "length": 12}}}});