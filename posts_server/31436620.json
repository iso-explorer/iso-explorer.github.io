post_cb({"31437166": {"Id": "31437166", "PostTypeId": "2", "Body": "<p><code>pc</code> <code>pf</code> and <code>pd</code> are all different types that access memory specified in <code>block</code> as <code>uint64_t</code>, so for say '<code>pf</code> the shared types are <code>float</code> and <code>uint64_t</code>. </p>\n<p>One would violate the strict aliasing rule were once to write using one type and read using another since the compile could we reorder the operations thinking there is no shared access. This is not your case however, since the <code>uint64_t</code> array is only used for assignment, it is exactly the same as using <code>alloca</code> to allocate the memory.</p>\n<p>Incidentally there is no issue with the strict aliasing rule when casting from any type to a char type and visa versa. This is a common pattern used for data serialization and deserialization.</p>\n", "LastActivityDate": "2015-07-15T17:29:55.110", "CommentCount": "0", "CreationDate": "2015-07-15T17:29:55.110", "ParentId": "31436620", "Score": "1", "OwnerUserId": "232918"}, "31436620": {"ViewCount": "1541", "Body": "<p><em>The answers I got for this question until now has two exactly the opposite kinds of answers: \"it's safe\" and \"it's undefined behaviour\". I decided to rewrite the question in whole to get some better clarifying answers, for me and for anyone who might arrive here via Google.</em></p>\n<p><em>Also, I removed the <code>C</code> tag and now this question is C++ specific</em></p>\n<p>I am making an 8-byte-aligned memory heap that will be used in my virtual machine. The most obvious approach that I can think of is by allocating an array of <code>std::uint64_t</code>.</p>\n<pre><code>std::unique_ptr&lt;std::uint64_t[]&gt; block(new std::uint64_t[100]);\n</code></pre>\n<p>Let's assume <code>sizeof(float) == 4</code> and <code>sizeof(double) == 8</code>. I want to store a float and a double in <code>block</code> and print the value.</p>\n<pre><code>float* pf = reinterpret_cast&lt;float*&gt;(&amp;block[0]);\ndouble* pd = reinterpret_cast&lt;double*&gt;(&amp;block[1]);\n*pf = 1.1;\n*pd = 2.2;\nstd::cout &lt;&lt; *pf &lt;&lt; std::endl;\nstd::cout &lt;&lt; *pd &lt;&lt; std::endl;\n</code></pre>\n<p>I'd also like to store a C-string saying \"hello\".</p>\n<pre><code>char* pc = reinterpret_cast&lt;char*&gt;(&amp;block[2]);\nstd::strcpy(pc, \"hello\\n\");\nstd::cout &lt;&lt; pc;\n</code></pre>\n<p>Now I want to store \"Hello, world!\" which goes over 8 bytes, but I still can use 2 consecutive cells.</p>\n<pre><code>char* pc2 = reinterpret_cast&lt;char*&gt;(&amp;block[3]);\nstd::strcpy(pc2, \"Hello, world\\n\");\nstd::cout &lt;&lt; pc2;\n</code></pre>\n<p>For integers, I don't need a <code>reinterpret_cast</code>.</p>\n<pre><code>block[5] = 1;\nstd::cout &lt;&lt; block[5] &lt;&lt; std::endl;\n</code></pre>\n<p>I'm allocating <code>block</code> as an array of <code>std::uint64_t</code> for the sole purpose of memory alignment. I also do not expect anything larger than 8 bytes by its own to be stored in there. The type of the block can be anything if the starting address is guaranteed to be 8-byte-aligned.</p>\n<p>Some people already answered that what I'm doing is totally safe, but some others said that I'm definitely invoking undefined behaviour.</p>\n<p>Am I writing correct code to do what I intend? If not, what is the appropriate way?</p>\n", "AcceptedAnswerId": "31483849", "Title": "What is the correct way to allocate and use an untyped memory block in C++?", "CreationDate": "2015-07-15T17:01:41.837", "Id": "31436620", "CommentCount": "9", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2015-07-27T06:18:17.963", "LastEditorUserId": "3747990", "LastActivityDate": "2015-07-27T10:28:47.300", "Score": "20", "OwnerUserId": "3998522", "Tags": "<c++><memory-management>", "AnswerCount": "8"}, "31541333": {"Id": "31541333", "PostTypeId": "2", "Body": "<p>If you tag this as C++ question,\n(1) why use uint64_t[] but not std::vector?\n(2) in term of memory management, your code lack of management logic, which should keep track of which blocks are in use and which are free and the tracking of contiguoous blocks, and of course the allocate and release block methods.\n(3) the code shows an unsafe way of using memory. For example, the char* is not const and therefore the block can be potentially be written to and overwrite the next block(s). The reinterpret_cast is consider danger and should be abstract from the memory user logic. \n(4) the code doesn't show the allocator logic. In C world, the malloc function is untyped and in C++ world, the operator new is typed. You should consider something like the new operator.</p>\n", "LastActivityDate": "2015-07-21T14:02:54.100", "CommentCount": "2", "CreationDate": "2015-07-21T14:02:54.100", "ParentId": "31436620", "Score": "-3", "OwnerUserId": "4960518"}, "31436956": {"Id": "31436956", "PostTypeId": "2", "Body": "<p>Update for the new question:</p>\n<p>The great news is there's a simple and easy solution to your real problem: Allocate the memory with <code>new</code> (<code>unsigned char[size]</code>). Memory allocated with <code>new</code> is guaranteed in the standard to be aligned in a way suitable for use as any type, and you can safely alias any type with <code>char*</code>.</p>\n<p>The standard reference, 3.7.3.1/2, allocation functions:</p>\n<blockquote>\n<p id=\"so_31436620_31436956_0\">The pointer returned shall be suitably aligned so that it can be\n  converted to a pointer of any complete object type and then used to\n  access the object or array in the storage allocated</p>\n</blockquote>\n<hr>\n<p>Original answer for the original question:</p>\n<p>At least in C++98/03 in 3.10/15 we have the following which pretty clearly makes it still undefined behavior (since you're accessing the value through a type that's not enumerated in the list of exceptions):</p>\n<blockquote>\n<p id=\"so_31436620_31436956_1\">If a program attempts to access the stored value of an object through\n  an lvalue of other than one of the following types the behavior is\n  undefined):</p>\n<p id=\"so_31436620_31436956_2\">\u2014 the dynamic type of the object,</p>\n<p id=\"so_31436620_31436956_3\">\u2014 a cvqualified version of the dynamic type of the object,</p>\n<p id=\"so_31436620_31436956_4\">\u2014 a type that is the signed or unsigned type corresponding to the dynamic type of the object,</p>\n<p id=\"so_31436620_31436956_5\">\u2014 a type that is the signed or unsigned type corresponding to a cvqualified version of the dynamic type of the object,</p>\n<p id=\"so_31436620_31436956_6\">\u2014 an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union),</p>\n<p id=\"so_31436620_31436956_7\">\u2014 a type that is a (possibly cvqualified) base class type of the dynamic type of the object,</p>\n<p id=\"so_31436620_31436956_8\">\u2014 a char or unsigned char type.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-27T10:28:47.300", "Score": "5", "CreationDate": "2015-07-15T17:18:48.537", "ParentId": "31436620", "CommentCount": "3", "OwnerUserId": "251738", "LastEditDate": "2015-07-27T10:28:47.300"}, "31436801": {"Id": "31436801", "PostTypeId": "2", "Body": "<p>Yes, because the memory locations pointed to by <code>pf</code> could overlap depending on the size of <code>float</code> and <code>double</code>.  If they didn't, then the results of reading <code>*pd</code> and <code>*pf</code> would be well defined but not the results of reading from <code>block</code> or <code>pc</code>.</p>\n", "LastActivityDate": "2015-07-15T17:10:45.173", "CommentCount": "9", "CreationDate": "2015-07-15T17:10:45.173", "ParentId": "31436620", "Score": "0", "OwnerUserId": "1687119"}, "31483849": {"Id": "31483849", "PostTypeId": "2", "Body": "<h1>The global allocation functions</h1>\n<p>To allocate an arbitrary (untyped) block of memory, the global allocation functions (\u00a73.7.4/2);</p>\n<blockquote id=\"so_31436620_31483849_0\">\n<pre><code>void* operator new(std::size_t);\nvoid* operator new[](std::size_t);\n</code></pre>\n</blockquote>\n<p>Can be used to do this (\u00a73.7.4.1/2).</p>\n<p>\u00a73.7.4.1/2</p>\n<blockquote>\n<p id=\"so_31436620_31483849_1\">The allocation function attempts to allocate the requested amount of storage. If it is successful, it shall return the address of the start of a block of storage whose length in bytes shall be at least as large as the requested size. There are no constraints on the contents of the allocated storage on return from the allocation function. The order, contiguity, and initial value of storage allocated by successive calls to an allocation function are unspecified. The pointer returned shall be suitably aligned so that it can be converted to a pointer of any complete object type with a fundamental alignment requirement (3.11) and then used to access the object or array in the storage allocated (until the storage is explicitly deallocated by a call to a corresponding deallocation function).</p>\n</blockquote>\n<p>And 3.11 has this to say about a <em>fundamental alignment requirement</em>;</p>\n<p>\u00a73.11/2</p>\n<blockquote>\n<p id=\"so_31436620_31483849_2\">A fundamental alignment is represented by an alignment less than or equal to the greatest alignment supported by the implementation in all contexts, which is equal to <code>alignof(std::max_align_t)</code>.</p>\n</blockquote>\n<p>Just to be sure on the requirement that the allocation functions must behave like this;</p>\n<p>\u00a73.7.4/3</p>\n<blockquote>\n<p id=\"so_31436620_31483849_3\">Any allocation and/or deallocation functions defined in a C++ program, including the default versions in the library, shall conform to the semantics specified in 3.7.4.1 and 3.7.4.2.</p>\n</blockquote>\n<p>Quotes from <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4527.pdf\" rel=\"nofollow noreferrer\">C++ WD n4527</a>.</p>\n<p>Assuming the 8-byte alignment is less than the fundamental alignment of the platform (and it looks like it is, but this can be verified on the target platform with <code>static_assert(alignof(std::max_align_t) &gt;= 8)</code>) - you can use the global <code>::operator new</code> to allocate the memory required. Once allocated, the memory can be segmented and used given the size and alignment requirements you have. </p>\n<p><em>An alternative here is</em> the <a href=\"http://en.cppreference.com/w/cpp/types/aligned_storage\" rel=\"nofollow noreferrer\"><code>std::aligned_storage</code></a> and it would be able to give you memory aligned at whatever the requirement is.</p>\n<pre><code>typename std::aligned_storage&lt;sizeof(T), alignof(T)&gt;::type buffer[100];\n</code></pre>\n<p>From the question, I assume here that the both the size and alignment of <code>T</code> would be 8.</p>\n<hr>\n<p>A sample of what the final memory block could look like is (basic RAII included);</p>\n<pre><code>struct DataBlock {\n    const std::size_t element_count;\n    static constexpr std::size_t element_size = 8;\n    void * data = nullptr;\n    explicit DataBlock(size_t elements) : element_count(elements)\n    {\n        data = ::operator new(elements * element_size);\n    }\n    ~DataBlock()\n    {\n        ::operator delete(data);\n    }\n    DataBlock(DataBlock&amp;) = delete; // no copy\n    DataBlock&amp; operator=(DataBlock&amp;) = delete; // no assign\n    // probably shouldn't move either\n    DataBlock(DataBlock&amp;&amp;) = delete;\n    DataBlock&amp; operator=(DataBlock&amp;&amp;) = delete;\n\n    template &lt;class T&gt;\n    T* get_location(std::size_t index)\n    {\n        // https://stackoverflow.com/a/6449951/3747990\n        // C++ WD n4527 3.9.2/4\n        void* t = reinterpret_cast&lt;void*&gt;(reinterpret_cast&lt;unsigned char*&gt;(data) + index*element_size);\n        // 5.2.9/13\n        return static_cast&lt;T*&gt;(t);\n\n        // C++ WD n4527 5.2.10/7 would allow this to be condensed\n        //T* t = reinterpret_cast&lt;T*&gt;(reinterpret_cast&lt;unsigned char*&gt;(data) + index*element_size);\n        //return t;\n    }\n};\n// ....\nDataBlock block(100);\n</code></pre>\n<p>I've constructed more detailed examples of the <code>DataBlock</code> with suitable template <code>construct</code> and <code>get</code> functions etc., <a href=\"http://coliru.stacked-crooked.com/a/37af4796160ecd8c\" rel=\"nofollow noreferrer\"><strong>live demo here</strong></a> and <a href=\"http://coliru.stacked-crooked.com/a/8b7251effad9b667\" rel=\"nofollow noreferrer\"><strong>here with further error checking etc.</strong></a>.</p>\n<h1>A note on the aliasing</h1>\n<p>It does look like there are some aliasing issues in the original code (strictly speaking); you allocate memory of one type and cast it to another type.</p>\n<p>It may probably work as you expect on your target platform, but you cannot rely on it. The most practical comment I've seen on this is;</p>\n<blockquote>\n<p id=\"so_31436620_31483849_4\"><a href=\"https://stackoverflow.com/questions/31204824/why-give-a-c-compiler-warning-when-returning-an-rvalue-reference#comment50412114_31204824\">\"Undefined behaviour has the nasty result of usually doing what you think it should do, until it doesn\u2019t\u201d - hvd</a>.</p>\n</blockquote>\n<p>The code you have probably will work. I think it is better to use the appropriate global allocation functions and be sure that there is no undefined behaviour when allocating and using the memory you require.</p>\n<p>Aliasing will still be applicable; once the memory is allocated - aliasing is applicable in how it is used. Once you have an arbitrary block of memory allocated (as above with the global allocation functions) and the lifetime of an object begins (\u00a73.8/1) - aliasing rules apply.</p>\n<h1>What about <code>std::allocator</code>?</h1>\n<p>Whilst the <a href=\"http://en.cppreference.com/w/cpp/memory/allocator\" rel=\"nofollow noreferrer\"><code>std::allocator</code></a> is for homogenous data containers and what your are looking for is akin to heterogeneous allocations, the implementation in your standard library (given the <a href=\"http://en.cppreference.com/w/cpp/concept/Allocator\" rel=\"nofollow noreferrer\">Allocator concept</a>) offers some guidance on raw memory allocations and corresponding construction of the objects required.</p>\n</hr>", "LastEditorUserId": "-1", "LastActivityDate": "2015-07-23T10:09:24.560", "Score": "11", "CreationDate": "2015-07-17T20:03:42.507", "ParentId": "31436620", "CommentCount": "1", "OwnerUserId": "3747990", "LastEditDate": "2017-05-23T11:58:47.177"}, "bq_ids": {"n4140": {"so_31436620_31436956_4": {"length": 8, "quality": 1.0, "section_id": 7239}, "so_31436620_31436956_5": {"length": 10, "quality": 1.0, "section_id": 7239}, "so_31436620_31483849_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 7181}, "so_31436620_31436956_8": {"length": 4, "quality": 1.0, "section_id": 45}, "so_31436620_31483849_1": {"length": 66, "quality": 0.9428571428571428, "section_id": 7177}, "so_31436620_31436956_7": {"length": 9, "quality": 1.0, "section_id": 7239}, "so_31436620_31483849_3": {"length": 12, "quality": 0.8, "section_id": 7175}, "so_31436620_31436956_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 7177}, "so_31436620_31483849_2": {"length": 15, "quality": 1.0, "section_id": 7241}, "so_31436620_31436956_6": {"length": 16, "quality": 1.0, "section_id": 7239}, "so_31436620_31436956_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 7239}, "so_31436620_31436956_3": {"length": 5, "quality": 1.0, "section_id": 7239}}, "n3337": {"so_31436620_31436956_4": {"length": 8, "quality": 1.0, "section_id": 6983}, "so_31436620_31436956_5": {"length": 10, "quality": 1.0, "section_id": 6983}, "so_31436620_31483849_0": {"length": 4, "quality": 0.6666666666666666, "section_id": 6074}, "so_31436620_31436956_8": {"length": 4, "quality": 1.0, "section_id": 42}, "so_31436620_31483849_1": {"length": 66, "quality": 0.9428571428571428, "section_id": 6921}, "so_31436620_31436956_7": {"length": 9, "quality": 1.0, "section_id": 6983}, "so_31436620_31436956_3": {"length": 5, "quality": 1.0, "section_id": 6983}, "so_31436620_31436956_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 6921}, "so_31436620_31483849_2": {"length": 15, "quality": 1.0, "section_id": 6985}, "so_31436620_31436956_6": {"length": 16, "quality": 1.0, "section_id": 6983}, "so_31436620_31436956_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 6983}, "so_31436620_31483849_3": {"length": 12, "quality": 0.8, "section_id": 6919}}, "n4659": {"so_31436620_31436956_4": {"length": 8, "quality": 1.0, "section_id": 8748}, "so_31436620_31436956_5": {"length": 10, "quality": 1.0, "section_id": 8748}, "so_31436620_31483849_0": {"length": 6, "quality": 1.0, "section_id": 8307}, "so_31436620_31436956_8": {"length": 4, "quality": 1.0, "section_id": 46}, "so_31436620_31483849_1": {"length": 63, "quality": 0.9, "section_id": 8685}, "so_31436620_31436956_7": {"length": 9, "quality": 1.0, "section_id": 8748}, "so_31436620_31436956_3": {"length": 5, "quality": 1.0, "section_id": 8748}, "so_31436620_31436956_0": {"length": 16, "quality": 0.9411764705882353, "section_id": 8685}, "so_31436620_31483849_2": {"length": 14, "quality": 0.9333333333333333, "section_id": 8750}, "so_31436620_31436956_6": {"length": 16, "quality": 1.0, "section_id": 8748}, "so_31436620_31436956_1": {"length": 13, "quality": 0.9285714285714286, "section_id": 8748}, "so_31436620_31483849_3": {"length": 12, "quality": 0.8, "section_id": 8683}}}, "31581365": {"Id": "31581365", "PostTypeId": "2", "Body": "<p>I'll make it short: All your code works with defined semantics if you allocate the block using</p>\n<pre><code>std::unique_ptr&lt;char[], std::free&gt;\n    mem(static_cast&lt;char*&gt;(std::malloc(800)));\n</code></pre>\n<p>Because</p>\n<ol>\n<li>every type is allowed to alias with a <code>char[]</code> and</li>\n<li><code>malloc()</code> is guaranteed to return a block of memory sufficiently aligned for all types (except maybe SIMD ones).</li>\n</ol>\n<p>We pass <code>std::free</code> as a custom deleter, because we used <code>malloc()</code>, not <code>new[]</code>, so calling <code>delete[]</code>, the default, would be undefined behaviour.</p>\n<p>If you're a purist, you can also use <code>operator new</code>:</p>\n<pre><code>std::unique_ptr&lt;char[]&gt;\n    mem(static_cast&lt;char*&gt;(operator new[](800)));\n</code></pre>\n<p>Then we don't need a custom deleter. Or</p>\n<pre><code>std::unique_ptr&lt;char[]&gt; mem(new char[800]);\n</code></pre>\n<p>to avoid the <code>static_cast</code> from <code>void*</code> to <code>char*</code>. But <code>operator new</code> can be replaced by the user, so I'm always a bit wary of using it. OTOH; <code>malloc</code> cannot be replaced (only in platform-specific ways, such as <code>LD_PRELOAD</code>).</p>\n", "LastActivityDate": "2015-07-23T07:57:27.783", "CommentCount": "0", "CreationDate": "2015-07-23T07:57:27.783", "ParentId": "31436620", "Score": "1", "OwnerUserId": "134841"}, "31488443": {"Id": "31488443", "PostTypeId": "2", "Body": "<p>The behavior of C++ and the CPU are distinct.  Although the standard provides memory suitable for any object, the rules and optimizations imposed by the CPU make the alignment for any given object \"undefined\" - an array of short would reasonably be 2 byte aligned, but an array of a 3 byte structure may be 8 byte aligned.  A union of all possible types can be created and used between your storage and the usage to ensure no alignment rules are broken.</p>\n<pre><code>union copyOut {\n      char Buffer[200]; // max string length\n      int16 shortVal;\n      int32 intVal;\n      int64 longIntVal;\n      float fltVal;\n      double doubleVal;\n} copyTarget;\nmemcpy( copyTarget.Buffer, Block[n], sizeof( data ) );  // move from unaligned space into union\n// use copyTarget member here.\n</code></pre>\n", "LastActivityDate": "2015-07-18T06:22:30.043", "CommentCount": "0", "CreationDate": "2015-07-18T06:22:30.043", "ParentId": "31436620", "Score": "0", "OwnerUserId": "5129715"}, "31441574": {"Id": "31441574", "PostTypeId": "2", "Body": "<p>A lot of discussion here and given some answers that are <em>slightly</em> wrong, but making up good points, I just try to summarize:</p>\n<ul>\n<li><p>exactly following the text of the standard (no matter what version) ... yes, this is undefined behaviour. Note the standard doesn't even have the term <em>strict aliasing</em> -- just a set of rules to enforce it no matter what implementations could define.</p></li>\n<li><p>understanding the reason behind the \"strict aliasing\" rule, it should work nicely on any implementation <strong>as long</strong> as neither <code>float</code> or <code>double</code> take more than 64 bits.</p></li>\n<li><p>the standard won't guarantee you anything about the size of <code>float</code> or <code>double</code> (intentionally) and that's the reason why it <em>is</em> that restrictive in the first place.</p></li>\n<li><p>you can get around all this by ensuring your \"heap\" is an <em>allocated object</em> (e.g. get it with <code>malloc()</code>) and access the aligned slots through <code>char *</code> and shifting your offset by 3 bits.</p></li>\n<li><p>you still have to make sure that anything you store in such a slot won't take more than 64 bits. (that's the hard part when it comes to portability)</p></li>\n</ul>\n<p>In a nutshell: your code should be safe on any \"sane\" implementation as long as size constraints aren't a problem (means: the answer to the question in your title is most likely <strong>no</strong>), BUT it's still undefined behaviour (means: the answer to your last paragraph is <strong>yes</strong>)</p>\n", "LastEditorUserId": "2371524", "LastActivityDate": "2015-07-16T06:59:50.683", "Score": "2", "CreationDate": "2015-07-15T21:35:50.623", "ParentId": "31436620", "CommentCount": "7", "OwnerUserId": "2371524", "LastEditDate": "2015-07-16T06:59:50.683"}});