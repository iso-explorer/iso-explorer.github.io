post_cb({"25048219": {"ParentId": "25047109", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I believe <code>clang</code> is correct here.</p>\n<p>We can see from the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\">draft C++ standard</a> section <code>6.4.2</code> <em>The switch statement</em> that this involves a <em>contextually implicit conversion</em>. Paragraph <em>2</em> says (*emphasis mine going forward):</p>\n<blockquote>\n<p id=\"so_25047109_25048219_0\">The condition shall be of integral type, enumeration type, or class\n  type. If of class type, the condition is <strong>contextually implicitly\n  converted (Clause 4)</strong> to an integral or enumeration type.</p>\n</blockquote>\n<p>We can see the section we need to use is <code>4</code> <em>Standard conversions</em> and paragraph <em>5</em> covers these cases, it says:</p>\n<blockquote>\n<p id=\"so_25047109_25048219_1\">Certain language constructs require conversion to a value having one\n  of a specified set of types appropriate to the construct. An\n  expression e of class type E appearing in such a context is said to be\n  <strong>contextually implicitly converted</strong> to a specified type T and is\n  well-formed if and only if e can be implicitly converted to a type T\n  that is determined as follows: E is searched for conversion functions\n  whose return type is cv T or reference to cv T such that T is allowed\n  by the context. There shall be exactly one such T.</p>\n</blockquote>\n<p>This does not reference section <code>8.5</code> which allows for overload resolution by specifically referring to section <code>13.3</code> without allowing overload resolution we can not use:</p>\n<pre><code>template &lt;typename T&gt;\noperator T () const\n</code></pre>\n<p>and therefore there is no ambiguity.</p>\n<p>Note this is different from paragraph <em>4</em> which covers <em>bool conversions</em> in contexts of <em>if</em>, <em>while</em> etc... and says (<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_25047109_25048219_2\">Certain language constructs require that an expression be converted to\n  a Boolean value. An expression e appearing in such a context is said\n  to be contextually converted to bool and is well-formed if and only if\n  the declaration bool t(e); <strong>is well-formed, for some invented temporary\n  variable t (8.5).</strong></p>\n</blockquote>\n<p>which specifically allows for overload resolution and refers directly to section <code>13.3</code> which covers this. It makes sense that it is allowed since we have a specific destination type <em>bool</em> to convert to which we don't have in the <em>switch</em> case. </p>\n<p><b>Why</b></p>\n<p>We can figure this out by going looking at <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3323.pdf\">N3323: A Proposal to Tweak Certain C++ Contextual Conversions, v3</a> it covers this issue. It would be hard to quote the whole paper so I will attempt to quote enough of the context. It says:</p>\n<blockquote>\n<p id=\"so_25047109_25048219_3\">The context in which a C++ expression appears often influences how the\n  expression is evaluated, and therefore may impose requirements on the\n  expression to ensure such evaluation is possible. [...]</p>\n<p id=\"so_25047109_25048219_4\">In four cases, the FDIS (N3290) uses different language to specify an\n  analogous contextdependent conversion. In those four contexts, when an\n  operand is of class type, that type must have a \u201csingle non-explicit\n  conversion function\u201d to a suitable (context-specific) type. [...]</p>\n</blockquote>\n<p>and includes:</p>\n<blockquote>\n<p id=\"so_25047109_25048219_5\">[stmt.switch]/2: \u201cThe condition shall be of integral type, enumeration\n  type, or of a class type for which a single non-explicit conversion\n  function to integral or enumeration type exists (12.3).\u201d</p>\n</blockquote>\n<p>and says:</p>\n<blockquote>\n<p id=\"so_25047109_25048219_6\">The principal issue, in each of the four contexts cited in the\n  Introduction, seems to lie in their common helpful but very strict\n  requirement that limits a class to only one conversion operator [...]</p>\n<p id=\"so_25047109_25048219_7\">Another concern is the scope of the qualifier \u201csingle\u201d in the current\n  wording. Must there be but a single conversion function in the class,\n  or may there be several so long as a single one is appropriate to the\n  context?</p>\n<p id=\"so_25047109_25048219_8\">The current language seems unclear on this point. It is also\n  unclear whether a conversion operator that produces a reference to an\n  appropriate type is an appropriate conversion operator. (A question on\n  this point was posted to the Core reflector on 2011-02-21, but has\n  gone unanswered as of this writing.) Current compiler practice seems\n  to admit such operators, but the current language seems not to.</p>\n</blockquote>\n<p>and proposes:</p>\n<blockquote>\n<p id=\"so_25047109_25048219_9\">To address all these concerns, we recommend instead to use the proven\n  approach typified by the term contextually converted to bool as\n  defined in [conv]/3. We therefore propose a modest addition to\n  [conv]/3 to define contextual conversion to other specified types, and\n  then appeal to this new definition.</p>\n</blockquote>\n<p>and the new language would be as follows;</p>\n<blockquote>\n<p id=\"so_25047109_25048219_10\">Certain other language constructs require similar conversion, but to a\n  value having one of a specified set of types appropriate to the\n  construct. An expression e of class type E appearing in such a context\n  is said to be contextually implicitly converted to a specified type T\n  and is well-formed if and only if e can be implicitly converted to a\n  type T that is determined as follows: E is searched for conversion\n  functions whose return type is cv T or reference to cv T such that T\n  is allowed by the context. There shall be exactly one such T.</p>\n</blockquote>\n<p>Note <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3486.html\">N3486: C++ Editor's Report, October 2012</a> shows us when <code>N3323</code> was incorporated in the draft standard.</p>\n<p><b>Update</b></p>\n<p>Filed a <a href=\"https://gcc.gnu.org/bugzilla/show_bug.cgi?id=62110\">gcc bug report</a>.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2014-08-12T19:35:24.860", "Id": "25048219", "Score": "15", "CreationDate": "2014-07-30T22:46:29.960", "LastActivityDate": "2014-08-12T19:35:24.860"}, "25047109": {"CommentCount": "17", "ViewCount": "1173", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2014-07-30T21:17:11.240", "LastActivityDate": "2014-08-12T23:28:16.083", "Title": "Classes with both template and non-template conversion operators in the condition of switch statement", "FavoriteCount": "4", "LastEditDate": "2017-05-23T11:44:52.287", "Id": "25047109", "Score": "23", "Body": "<p>The problem originally arose in <a href=\"https://stackoverflow.com/questions/25046418/internal-compiler-error-templated-conversion-operator-in-switch-expression\">this question</a>. Consider the following code:</p>\n<pre><code>class Var\n{\npublic:\n\n    operator int () const\n    { return 0; }\n\n    template &lt;typename T&gt;\n    operator T () const\n    { return T(); }\n\n};\n\nint main()\n{\n    Var v;\n    switch (v)\n    { }\n}\n</code></pre>\n<p>Without the <code>operator int() const { return 0; }</code>, both g++ and clang <a href=\"https://stackoverflow.com/a/25046529/2756719\">reject</a> the code.</p>\n<p>However, the above code, with the <code>operator int()</code>, is <a href=\"http://coliru.stacked-crooked.com/a/fd275beb734f3763\" rel=\"nofollow noreferrer\">accepted</a> by clang but <a href=\"http://coliru.stacked-crooked.com/a/16a7feed152068f1\" rel=\"nofollow noreferrer\">rejected</a> by g++ with the following error:</p>\n<pre><code>main.cpp:17:14: error: default type conversion can't deduce template argument for 'template&lt;class T&gt; Var::operator T() const'\n     switch (v)\n              ^\n</code></pre>\n<p>Which compiler is correct?</p>\n", "Tags": "<c++><c++11><language-lawyer><implicit-conversion><c++14>", "OwnerUserId": "2756719", "AnswerCount": "6"}, "25047700": {"ParentId": "25047109", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>If i'm reading this section correctly on overloading, Clang is correct</p>\n<blockquote>\n<p id=\"so_25047109_25047700_0\">13.3.3 Best viable function [over.match.best]</p>\n<p id=\"so_25047109_25047700_1\">[...] Given these definitions, a viable function F1 is defined to be a better function than another viable function F2 if for all arguments i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then [...]</p>\n<p id=\"so_25047109_25047700_2\">\u2014 F1 is a non-template function and F2 is a function template specialization, or, if not that,[...]</p>\n</blockquote>\n<p>The Draft is free to read.  Not sure if any changes in 13.3.3 were put into the final spec (i haven't payed for it)</p>\n<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf\" rel=\"nofollow\">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3337.pdf</a></p>\n<p>I'd file a G++ bug :-)  They might fire back with a different section of the standard to justify, but it appears to be non-standards compliant.</p>\n<p>Edit for aschepler's comment:</p>\n<p>From: <a href=\"http://publib.boulder.ibm.com/infocenter/comphelp/v101v121/index.jsp?topic=/com.ibm.xlcpp101.aix.doc/language_ref/cplr315.html\" rel=\"nofollow\">http://publib.boulder.ibm.com/infocenter/comphelp/v101v121/index.jsp?topic=/com.ibm.xlcpp101.aix.doc/language_ref/cplr315.html</a></p>\n<blockquote>\n<p id=\"so_25047109_25047700_3\">Suppose that f is an overloaded function name. When you call the overloaded function f(), the compiler creates a set of candidate functions. This set of functions includes all of the functions named f that can be accessed from the point where you called f(). The compiler may include as a candidate function an alternative representation of one of those accessible functions named f to facilitate overload resolution.</p>\n<p id=\"so_25047109_25047700_4\">After creating a set of candidate functions, the compiler creates a set of viable functions. This set of functions is a subset of the candidate functions. The number of parameters of each viable function agrees with the number of arguments you used to call f().</p>\n</blockquote>\n", "OwnerUserId": "369789", "LastEditorUserId": "369789", "LastEditDate": "2014-07-30T22:09:38.697", "Id": "25047700", "Score": "1", "CreationDate": "2014-07-30T21:58:51.193", "LastActivityDate": "2014-07-30T22:09:38.697"}, "25047376": {"ParentId": "25047109", "PostTypeId": "2", "CommentCount": "10", "Body": "<p><strong>6.4.2/2 The <code>switch</code> statement</strong> (emphasis mine)</p>\n<blockquote>\n<p id=\"so_25047109_25047376_0\">The condition shall be of integral type, enumeration type, or of a class type for which a <strong>single non-explicit conversion function</strong> to integral or enumeration type exists (12.3). If the condition is of class type, the condition is converted by calling that conversion function, and the result of the conversion is used in place of the original condition for the remainder of this section.</p>\n</blockquote>\n<p>So my interpretation is that g++ is correct here.</p>\n", "OwnerUserId": "2644390", "LastEditorUserId": "2644390", "LastEditDate": "2014-07-30T22:31:12.607", "Id": "25047376", "Score": "9", "CreationDate": "2014-07-30T21:33:09.137", "LastActivityDate": "2014-07-30T22:31:12.607"}, "25047378": {"ParentId": "25047109", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>In my hummble opinion and based on <em>\u00a713.3.3/1 Best viable function [over.match.best]</em>, the non-template overloaded conversion operator (i.e., <code>operator int() const</code>) has a higher precedence in terms of overload resolution picking, than its template counterpart (i.e., <code>template &lt;typename T&gt; operator T () const</code>).</p>\n<p>Thus, overloaded resolution would correctly choose <code>operator int() const</code> over <code>template &lt;typename T&gt; operator T () const</code> since is the best viable function.</p>\n<p>Furthermore, and since the non-template version would be chosen over the template one (i.e., the template would not be materialized/qualified by the compiler), <code>class Var</code> would have a single conversion function and thus the requirement in <em>\u00a76.4.2/2 The switch statement [stmt.switch]</em> for single integral conversion would be satisfied.  </p>\n<p>Consequently, Clang is right and GCC is wrong. </p>\n", "OwnerUserId": "2352671", "LastEditorUserId": "2352671", "LastEditDate": "2014-07-30T22:05:34.893", "Id": "25047378", "Score": "2", "CreationDate": "2014-07-30T21:33:16.557", "LastActivityDate": "2014-07-30T22:05:34.893"}, "25048348": {"ParentId": "25047109", "CommentCount": "0", "Body": "<p>Here are the relevant quotes, but the final answer depends quite a bit on interpretation.  I can't even decide on a favorite right now.</p>\n<p>N3797 6.4.2/2:</p>\n<blockquote>\n<p id=\"so_25047109_25048348_0\">The condition shall be of integral type, enumeration type, or class type.  If of class type, the condition is contextually implicitly converted (Clause 4) to an integral or enumeration type.</p>\n</blockquote>\n<p>4/5:</p>\n<blockquote>\n<p id=\"so_25047109_25048348_1\">Certain language constructs require conversion to a value having one of a specified set of types appropriate to the construct.  An expression <code>e</code> of class type <code>E</code> appearing in such a context is said to be <em>contextually implicitly converted to</em> a specified type <code>T</code> and is well-formed if and only if <code>e</code> can be implicitly converted to a type <code>T</code> that is determined as follows: <code>E</code> is searched for conversion functions whose return type is <em>cv</em> <code>T</code> or reference to <em>cv</em> <code>T</code> such that <code>T</code> is allowed by the context.  There shall be exactly one such <code>T</code>.</p>\n</blockquote>\n<p>14.5.2/6:</p>\n<blockquote>\n<p id=\"so_25047109_25048348_2\">A specialization of a conversion function is not found by name lookup.  Instead, any conversion function templates visible in the context of the use are considered.  For each such operator, if argument deduction succeeds (14.8.2.3), the resulting specialization is used as if found by name lookup.</p>\n</blockquote>\n<p>14.5.2/8:</p>\n<blockquote>\n<p id=\"so_25047109_25048348_3\">Overload resolution (13.3.3.2) and partial ordering (14.5.6.2) are used to select the best conversion function among multiple specializations of conversion function templates and/or non-template conversion functions.</p>\n</blockquote>\n<p>Interpretation 1: 4/5 says \"conversion functions\", not \"conversion functions and conversion function templates\".  Therefore <code>Var::operator int() const</code> is the only option, and clang is correct.</p>\n<p>Interpretation 2 [weak?]: 14.5.2 requires us to compare the conversion function template by overload resolution and partial ordering, on the same initial standing as the non-template conversion function.  Those compare function template specializations and functions, not function templates, so we'll do template argument deduction.  Template argument deduction for a conversion function template requires a target type.  Although we usually have a clearer target type, in this case we'll just try (in theory anyway) all types in the set of allowable types.  But it is clear that the non-template function is a better viable function that all the template specializations, so overload resolution selects the non-template function.  clang is correct.</p>\n<p>Interpretation 3: Since overload resolution requires template argument deduction, and template argument deduction requires a known target type, the semantics of 4/5 must be considered first, and then its converted type (if any) can be used for the overload resolution process.  14.5.2 requires that the conversion function template be considered, but then we find that there are multiple valid types <code>T</code> for which we have a conversion function to <code>T</code> [that function possibly being a function template specialization].  The program is ill-formed, and therefore g++ is correct.</p>\n", "OwnerUserId": "459640", "PostTypeId": "2", "Id": "25048348", "Score": "2", "CreationDate": "2014-07-30T22:59:37.593", "LastActivityDate": "2014-07-30T22:59:37.593"}, "bq_ids": {"n4140": {"so_25047109_25048348_1": {"section_id": 4, "quality": 0.9782608695652174, "length": 45}, "so_25047109_25048348_3": {"section_id": 117, "quality": 0.9, "length": 18}, "so_25047109_25048219_1": {"section_id": 4, "quality": 0.9782608695652174, "length": 45}, "so_25047109_25048348_2": {"section_id": 115, "quality": 0.9230769230769231, "length": 24}, "so_25047109_25047700_1": {"section_id": 603, "quality": 0.85, "length": 17}, "so_25047109_25048219_2": {"section_id": 3, "quality": 0.9583333333333334, "length": 23}, "so_25047109_25048219_10": {"section_id": 4, "quality": 0.9183673469387755, "length": 45}, "so_25047109_25048219_0": {"section_id": 3890, "quality": 0.9444444444444444, "length": 17}, "so_25047109_25048219_5": {"section_id": 3890, "quality": 0.5555555555555556, "length": 10}, "so_25047109_25047700_2": {"section_id": 111, "quality": 1.0, "length": 5}, "so_25047109_25048348_0": {"section_id": 3890, "quality": 0.9444444444444444, "length": 17}}, "n3337": {"so_25047109_25047376_0": {"section_id": 3750, "quality": 0.9375, "length": 30}, "so_25047109_25048348_3": {"section_id": 112, "quality": 0.9, "length": 18}, "so_25047109_25047700_1": {"section_id": 593, "quality": 0.85, "length": 17}, "so_25047109_25048219_2": {"section_id": 2, "quality": 0.9583333333333334, "length": 23}, "so_25047109_25048348_2": {"section_id": 110, "quality": 0.9230769230769231, "length": 24}, "so_25047109_25048219_0": {"section_id": 3750, "quality": 0.6666666666666666, "length": 12}, "so_25047109_25048219_5": {"section_id": 3750, "quality": 0.8333333333333334, "length": 15}, "so_25047109_25047700_2": {"section_id": 106, "quality": 1.0, "length": 5}, "so_25047109_25048348_0": {"section_id": 3750, "quality": 0.6666666666666666, "length": 12}}, "n4659": {"so_25047109_25048348_1": {"section_id": 4, "quality": 0.9782608695652174, "length": 45}, "so_25047109_25048219_10": {"section_id": 4, "quality": 0.9183673469387755, "length": 45}, "so_25047109_25048219_1": {"section_id": 4, "quality": 0.9782608695652174, "length": 45}, "so_25047109_25048219_5": {"section_id": 4776, "quality": 0.5555555555555556, "length": 10}, "so_25047109_25047700_1": {"section_id": 629, "quality": 0.85, "length": 17}, "so_25047109_25048219_2": {"section_id": 3, "quality": 0.9583333333333334, "length": 23}, "so_25047109_25048348_2": {"section_id": 119, "quality": 0.9230769230769231, "length": 24}, "so_25047109_25048348_3": {"section_id": 121, "quality": 0.9, "length": 18}, "so_25047109_25048219_0": {"section_id": 4776, "quality": 0.9444444444444444, "length": 17}, "so_25047109_25047700_2": {"section_id": 115, "quality": 1.0, "length": 5}, "so_25047109_25048348_0": {"section_id": 4776, "quality": 0.9444444444444444, "length": 17}}}, "25048975": {"ParentId": "25047109", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>I believe gcc is correct, but the standard is flawed.</p>\n<p>gcc is correct because the standard mandates a single non-explicit conversion operator to integral or enumeration types for types used in <code>switch</code>.</p>\n<p>The standard is wrong because detecting that case involves solving the halting problem.</p>\n<p><code>operator T</code> can have a SFINAE clause of arbitrary complexity attached to it.  The compiler, under the standard, must determine if there is a <code>T</code> such that the <code>T</code> is an <code>enum</code>.</p>\n<pre><code>template&lt;class...Ts&gt;\nstruct evil {\n  enum { bob = 3+sizeof...(Ts) };\n};\n\nstruct test {\n  operator int() const { return -1; };\n  template&lt;class T, typename std::enable_if&lt;T::bob==2&gt;::type* unused=nullptr&gt;\n  operator T() const { return T::bob; }\n};\nint main() {\n  switch( test{} ) {\n    case -1: std::cout &lt;&lt; \"int\\n\"; break;\n    case 2: std::cout &lt;&lt; \"bob\\n\"; break;\n    default: std::cout &lt;&lt; \"unexpected\\n\"; break;\n  }\n}\n</code></pre>\n<p>The above code demonstrates a case where we have an infinite number of <code>enum</code>s implicitly available.  We have an <code>operator T</code> that will cast to type <code>T</code> if and only if <code>T::bob==2</code>.  Now, there are no such <code>enum</code>s in our program (and even if we removed the <code>3+</code> there would still not be, because it is not an <code>enum class</code> -- easily rectified).</p>\n<p>So <code>test</code> can only be converted to <code>int</code>, and as such the <code>switch</code> statement should compile.  gcc fails this test, and claims that the <code>template operator T</code> makes it ambiguous (without telling us what <code>T</code>, naturally).</p>\n<p>Replacing <code>enum type</code> with <code>enum class type</code>, and removing the <code>3+</code> makes the <code>switch</code> statement illegal under the standard.  But for the compiler to figure that out, it basically has to instantiate all possible templates in the program looking for a secret <code>enum</code> with the property in question.  With a bit of work, I can thus force the compiler to solve NP complete problems (or, excluding compiler limitations, the halting problem) in order to determine if a progrma should compile or not.</p>\n<p>I do not know what the right wording should be.  But the wording as written sure isn't sound.</p>\n", "OwnerUserId": "1774667", "LastEditorUserId": "1774667", "LastEditDate": "2014-08-01T11:00:57.830", "Id": "25048975", "Score": "3", "CreationDate": "2014-07-31T00:09:32.710", "LastActivityDate": "2014-08-01T11:00:57.830"}});