post_cb({"41507081": {"ParentId": "41506343", "LastEditDate": "2017-01-07T19:55:07.203", "CommentCount": "3", "CreationDate": "2017-01-06T13:45:00.113", "OwnerUserId": "4987285", "LastEditorUserId": "4987285", "PostTypeId": "2", "Id": "41507081", "Score": "11", "Body": "<p>Consider <a href=\"http://en.cppreference.com/w/cpp/language/user_literal\" rel=\"nofollow noreferrer\">this</a>:</p>\n<blockquote>\n<p id=\"so_41506343_41507081_0\">If the literal operator is a template, it must have an empty parameter list and can have only one template parameter, which must be a non-type template parameter pack with element type char</p>\n</blockquote>\n<p>In other terms, the declaration of a literal operator template should be:</p>\n<pre><code>template &lt;char...&gt; double operator \"\" _x();\n</code></pre>\n<p>That is not your case.</p>\n<hr>\n<p>I'm not a language-lawyer, but I guess the section of the standard that is relevant for your case is <a href=\"http://eel.is/c++draft/over.literal\" rel=\"nofollow noreferrer\">[over.literal]</a> (link to the working draft).</p>\n<p>An excerpt from <a href=\"http://eel.is/c++draft/over.literal#2\" rel=\"nofollow noreferrer\">[over.literal]/2</a> follows:</p>\n<blockquote>\n<p id=\"so_41506343_41507081_1\">A function template declared with a\u00a0literal-operator-id\u00a0is a\u00a0literal operator template.</p>\n</blockquote>\n<p>Below <a href=\"http://eel.is/c++draft/over.literal#5\" rel=\"nofollow noreferrer\">[over.literal]/5</a> is quoted:</p>\n<blockquote>\n<p id=\"so_41506343_41507081_2\">The declaration of a literal operator template shall have an empty\u00a0parameter-declaration-clause\u00a0and its template-parameter-list\u00a0shall have a single\u00a0template-parameter\u00a0that is a non-type template parameter pack ([temp.variadic]) with element type\u00a0char.</p>\n</blockquote>\n<p>It seems to me that declarations similar to the one in the question are explicitly disallowed by the standard.<br>\nMore in general, a function template that declares a literal operator must adhere strictly to the given pattern.</br></p>\n<hr>\n<blockquote>\n<p id=\"so_41506343_41507081_3\">am I doing this incorrectly, or is this genuinely not allowed?</p>\n</blockquote>\n<p>I would say that's <em>genuinely not allowed</em>.</p>\n<p>Anyway, you can still use a template function if you have complex logic that you don't want to repeat in each operator:</p>\n<pre><code>template&lt;typename T&gt;\nFoo&lt;T&gt; create(const T *str) {\n    // your logic...\n    return Foo&lt;T&gt;{str};\n}\n\nFoo&lt;char&gt; operator\"\" _foo(const char *str, std::size_t) {\n    return create(str);\n}\n\nFoo&lt;wchar_t&gt; operator\"\" _foo(const wchar_t *str, std::size_t) {\n    return create(str);\n}\n</code></pre>\n<p>It's a matter of an extra layer of indirection and that's all.<br>\nObviously, it doesn't worth it if all your operators are one line body functions.</br></p>\n</hr></hr>", "LastActivityDate": "2017-01-07T19:55:07.203"}, "41506343": {"CommentCount": "8", "ViewCount": "888", "PostTypeId": "1", "LastEditorUserId": "498730", "CreationDate": "2017-01-06T13:02:28.747", "LastActivityDate": "2017-01-07T19:55:07.203", "Title": "Can I template user-defined literals?", "AcceptedAnswerId": "41507081", "LastEditDate": "2017-01-06T16:11:37.250", "Id": "41506343", "Score": "14", "Body": "<p>Suppose I have some class:</p>\n<pre><code>template &lt;typename T&gt;\nclass Foo {\n  const T* x_;\npublic:\n  Foo(const T* str) : x_{str} {}\n};\n</code></pre>\n<p>and I provide some user-defined literals that create a <code>Foo</code> object:</p>\n<pre><code>Foo&lt;char&gt; operator\"\" _foo(const char* str, std::size_t) {\n  return Foo&lt;char&gt;{str};\n}\n\nFoo&lt;wchar_t&gt; operator\"\" _foo(const wchar_t* str, std::size_t) {\n  return Foo&lt;wchar_t&gt;{str};\n}\n\n// etc. for char16_t and char32_t.\n</code></pre>\n<p>My question is this: why can I not template these and save having to rewrite code?</p>\n<pre><code>template &lt;typename T&gt;\nFoo&lt;T&gt; operator\"\" _foo(const T* str, std::size_t) {\n  return Foo&lt;T&gt;{str};\n}\n</code></pre>\n<p>gcc 5.4.0 (Ubuntu 5.4.0-6ubuntu1~16.04.4) and 7.0.0 (compiled myself) report:</p>\n<pre><code>error: \u2018Foo&lt;T&gt; operator\"\"_foo(const T*, std::size_t)\u2019 has invalid argument list\nFoo&lt;T&gt; operator\"\" _foo(const T* str, std::size_t) {\n                                                ^\n</code></pre>\n<p>The error message seems to be clear enough, but I don't see a reason why I shouldn't be allowed to do this in principle; so, am I doing this incorrectly, or is this genuinely not allowed?</p>\n", "Tags": "<c++><c++11><templates><user-defined-literals>", "OwnerUserId": "498730", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_41506343_41507081_1": {"section_id": 668, "quality": 0.8571428571428571, "length": 6}, "so_41506343_41507081_2": {"section_id": 671, "quality": 0.9047619047619048, "length": 19}, "so_41506343_41507081_0": {"section_id": 671, "quality": 0.6190476190476191, "length": 13}}, "n3337": {"so_41506343_41507081_1": {"section_id": 658, "quality": 0.8571428571428571, "length": 6}, "so_41506343_41507081_2": {"section_id": 661, "quality": 0.9047619047619048, "length": 19}, "so_41506343_41507081_0": {"section_id": 661, "quality": 0.6190476190476191, "length": 13}}, "n4659": {"so_41506343_41507081_1": {"section_id": 696, "quality": 0.8571428571428571, "length": 6}, "so_41506343_41507081_0": {"section_id": 699, "quality": 0.6190476190476191, "length": 13}, "so_41506343_41507081_2": {"section_id": 699, "quality": 0.9047619047619048, "length": 19}}}});