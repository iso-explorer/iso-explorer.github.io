post_cb({"30474867": {"CommentCount": "7", "ViewCount": "208", "PostTypeId": "1", "LastEditorUserId": "434551", "CreationDate": "2015-05-27T06:35:22.117", "LastActivityDate": "2015-11-19T02:24:10.150", "Title": "Never use ' #include \"filename.h\" ' directive", "FavoriteCount": "1", "LastEditDate": "2015-05-27T06:38:21.893", "Id": "30474867", "Score": "2", "Body": "<p>I have a question about the \"AV Rule 33\" in [1].</p>\n<p>It says \"The #include directive shall use the <code>&lt;filename.h&gt;</code> notation to include header files.\". </p>\n<p>The document \"explains\" it by \"divergence in vendor implementations\", but I have problems believing it. A \"local header\" file is a local header file?!</p>\n<p>Do compiler differ that much in the definition of \"local\"?</p>\n<p>[1] <a href=\"http://www.stroustrup.com/JSF-AV-rules.pdf\" rel=\"nofollow\">http://www.stroustrup.com/JSF-AV-rules.pdf</a></p>\n", "Tags": "<c++><c>", "OwnerUserId": "1154652", "AnswerCount": "3"}, "30476562": {"ParentId": "30474867", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I've worked with some compilers over 10 years ago which might warrant that kind of rationale. I'm not suggesting it's a good rationale and trying to defend it, but just want to clarify why it might have arisen.</p>\n<p>Basically in our case, we tripped up because we had local project headers (for small projects like plugins) named with rather clashy names like simply <code>rect.h</code> or <code>mem.h</code>. We thought the use of local-style include directives would protect us from clashes, and it did on most compilers except one we encountered.</p>\n<p>I can't remember exactly which compiler tripped us up (I think it was an old version of CodeWarrior, but my memory could be failing me). In any case, this compiler was treating:</p>\n<pre><code>#include \"rect.h\"\n</code></pre>\n<p>... synonymously with:</p>\n<pre><code>#include &lt;rect.h&gt;\n</code></pre>\n<p>Basically it made no difference in the former include style that <code>rect.h</code> was in the exact same directory as the source file including it. It still prioritized searching for header files in the order they appeared in the specified include paths for the project and compiler settings, so we got a lot of clashes there with standard headers and OS headers that we had little choice to resolve except by naming the header files better, less generally, in a less clash-prone way. Maybe we could have tried some other things like:</p>\n<pre><code>#include \"./rect.h\"\n</code></pre>\n<p>... perhaps that would have worked (though it looks a bit goofy). We might have also been able to try to force, through the project and compiler settings, the preprocessor to prioritize the project's own directory above all other include paths. We didn't try exhausting all possible solutions and just went for renaming our header files with a prefix convention we apply consistently to make avoiding conflicts more of a no-brainer without having to analyze things on a case-by-case basis.</p>\n<p>This was especially awkward since we were getting it in a third party library outside of our control, and changing such code is pretty gross (ex: we might need to do it again with a new version of the library).</p>\n<p>That's all we did. We didn't actually come up with a coding standard suggesting to avoid the former include style in favor of only using the latter, but I can see why someone might establish that rationale in response to a similar compiler issue.</p>\n<p>The problem is that if we're targeting multiple platforms and use a wide variety of compilers and sometimes porting to new ones, we unfortunately have to target the lowest common denominator. If that lowest common denominator makes no distinction between <code>#include \"rect.h\"</code> and <code>#include &lt;rect.h&gt;</code>, then the idea that these two are different becomes an illusion on some compilers and a reality on others.</p>\n<p>This inconsistency can be a source of confusion, and it might lead to less porting headaches to simply adopt the latter style everywhere to gain back that consistency and perhaps more quickly realize, in foresight rather than in hindsight after looking at a bunch of build errors from trying to port the code, to name headers in a less clashy way.</p>\n", "OwnerUserId": "4842163", "LastEditorUserId": "4842163", "LastEditDate": "2015-11-19T02:24:10.150", "Id": "30476562", "Score": "2", "CreationDate": "2015-05-27T08:04:16.363", "LastActivityDate": "2015-11-19T02:24:10.150"}, "bq_ids": {"n4140": {"so_30474867_30475447_7": {"section_id": 505, "quality": 1.0, "length": 7}, "so_30474867_30475447_2": {"section_id": 504, "quality": 0.9130434782608695, "length": 21}, "so_30474867_30475447_5": {"section_id": 505, "quality": 0.9230769230769231, "length": 24}}, "n3337": {"so_30474867_30475447_2": {"section_id": 495, "quality": 0.9130434782608695, "length": 21}, "so_30474867_30475447_7": {"section_id": 496, "quality": 1.0, "length": 7}, "so_30474867_30475447_5": {"section_id": 496, "quality": 0.9230769230769231, "length": 24}}, "n4659": {"so_30474867_30475447_2": {"section_id": 525, "quality": 0.9130434782608695, "length": 21}, "so_30474867_30475447_7": {"section_id": 526, "quality": 1.0, "length": 7}, "so_30474867_30475447_5": {"section_id": 526, "quality": 0.9230769230769231, "length": 24}}}, "30475447": {"ParentId": "30474867", "CommentCount": "13", "Body": "<p>Seems like a strange rationale. At least in C, either form is implementation-specific.</p>\n<p>C11 6.10.2 and C++03 16.2 seem 100% identical here:</p>\n<blockquote>\n<p id=\"so_30474867_30475447_0\">A preprocessing directive of the form</p>\n<p id=\"so_30474867_30475447_1\"><code># include &lt;h-char-sequence&gt; new-line</code></p>\n<p id=\"so_30474867_30475447_2\">searches a sequence of implementation-defined places for a header\n  identified uniquely by the specified sequence between the &lt; and &gt;\n  delimiters, and causes the replacement of that directive by the entire\n  contents of the header. How the places are specified or the header\n  identified is implementation-defined. </p>\n<p id=\"so_30474867_30475447_3\">A preprocessing directive of\n  the form</p>\n<p id=\"so_30474867_30475447_4\"><code># include \"q-char-sequence\" new-line</code></p>\n<p id=\"so_30474867_30475447_5\">causes the replacement of that directive by the entire contents of the source file identified by the\n  specified sequence between the \" delimiters. The named source file is\n  searched for in an implementation-defined manner. If this search is not supported, or if the search\n  fails, the directive is reprocessed as if it read</p>\n<p id=\"so_30474867_30475447_6\"><code># include &lt;h-char-sequence&gt; new-line</code></p>\n<p id=\"so_30474867_30475447_7\">with the identical contained sequence (including &gt; characters, if any) from the original\n  directive.</p>\n</blockquote>\n<p>As we can read in the standard(s), <em>both</em> forms use implementation-defined searches. The standard <em>explicitly</em> states that if <code>#include \"filename.h\"</code> fails, it will revert to treat it like <code>#include &lt;filename.h&gt;\"</code>. So the rationale doesn't make any sense.</p>\n", "OwnerUserId": "584518", "PostTypeId": "2", "Id": "30475447", "Score": "2", "CreationDate": "2015-05-27T07:08:15.887", "LastActivityDate": "2015-05-27T07:08:15.887"}, "30475109": {"ParentId": "30474867", "CommentCount": "1", "Body": "<p>The pdf clearly states</p>\n<blockquote>\n<p id=\"so_30474867_30475109_0\">However, due to the unfortunate divergence in vendor implementations,\n  only the &lt; filename.h &gt; form will be used.</p>\n</blockquote>\n<p>By which he means that in order to include the files provided by vendors you should not do \"filename.h\" as it will only search in the local path only. </p>\n", "OwnerUserId": "2959769", "PostTypeId": "2", "Id": "30475109", "Score": "0", "CreationDate": "2015-05-27T06:50:26.263", "LastActivityDate": "2015-05-27T06:50:26.263"}});