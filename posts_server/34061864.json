post_cb({"34062277": {"Id": "34062277", "PostTypeId": "2", "Body": "<p>Class member function local variables are declared in fact in an inner scope of the class scope. </p>\n<p>As it is known any declaration of a variable in an inner scope hides a declaration with the same name in the outer scope.</p>\n<p>Consider the following code snippet</p>\n<pre><code>int x = 1;\n\nnamepsace N1\n{\n    int x = 2;\n\n    struct A\n    {\n        int x = 3;\n    };\n\n    struct B : A\n    {\n        int x = 4;\n        void f( int x = 5 ) { { int x = 6; } }\n    };\n}\n</code></pre>\n<p>You can imagine the scopes the following way</p>\n<pre><code>int x = 1; // global namespace\n{\n    int x = 2; // namepsace N1\n    {\n        int x = 3;  // struct A scope\n        {\n            int x = 4; // struct B scope\n            {\n                int x = 5; // the funcion f's outer-most scope\n                {\n                    int x = 6; // function f's inner scope\n                    std::cout &lt;&lt; x &lt;&lt; std::endl;    // outputs 6\n                    // here can not output the function parameter x = 5\n                    std::cout &lt;&lt; B::x &lt;&lt; std::endl; // outputs 4\n                    std::cout &lt;&lt; A::x &lt;&lt; std::endl; // outputs 3\n                    std::cout &lt;&lt; N::x &lt;&lt; std::endl; // outputs 2\n                    std::cout &lt;&lt; ::x &lt;&lt; std::endl;  // outputs 1\n                }  \n            }\n        }\n    }\n}\n</code></pre>\n<p>To test this you can place all the output statements showed above inside the member function definition</p>\n<pre><code>    struct B : A\n    {\n        int x = 4;\n        void f( int x = 5 ) \n        { \n            { \n                int x = 6; \n\n                std::cout &lt;&lt; x &lt;&lt; std::endl;    // outputs 6\n                // here can not output the function parameter x = 5\n                std::cout &lt;&lt; B::x &lt;&lt; std::endl; // outputs 4\n                std::cout &lt;&lt; A::x &lt;&lt; std::endl; // outputs 3\n                std::cout &lt;&lt; N::x &lt;&lt; std::endl; // outputs 2\n                std::cout &lt;&lt; ::x &lt;&lt; std::endl;  // outputs 1\n            } \n        }\n    };\n</code></pre>\n", "LastEditorUserId": "2877241", "LastActivityDate": "2015-12-03T09:43:02.657", "Score": "1", "CreationDate": "2015-12-03T09:31:23.753", "ParentId": "34061864", "CommentCount": "1", "LastEditDate": "2015-12-03T09:43:02.657", "OwnerUserId": "2877241"}, "bq_ids": {"n4140": {"so_34061864_34061982_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 7080}}, "n3337": {"so_34061864_34061982_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 6824}}, "n4659": {"so_34061864_34061982_0": {"length": 14, "quality": 0.8235294117647058, "section_id": 8581}}}, "34061982": {"Id": "34061982", "PostTypeId": "2", "Body": "<p>This is well-defined:</p>\n<blockquote>\n<p id=\"so_34061864_34061982_0\"><code>N3337 [basic.scope.hiding]/3:</code> In a member function definition, the declaration of a name at block scope hides the declaration of a member\n  of the class with the same name; see 3.3.7.</p>\n</blockquote>\n<p><code>m</code> is in a member function definition at block scope, so it hides the class member <code>m</code>.</p>\n", "LastActivityDate": "2015-12-03T09:17:59.893", "Score": "6", "CreationDate": "2015-12-03T09:17:59.893", "ParentId": "34061864", "CommentCount": "1", "OwnerUserId": "496161"}, "34061864": {"ViewCount": "183", "Body": "<p>Suppose you have this very silly code (it's just to make it easy to ask the coming question):</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass A\n{\npublic:\n    A() : m(0) {}\n\n    void showM1( int m )\n    {\n        std::cout &lt;&lt; m &lt;&lt; std::endl;\n    }\n\n    void showM2()\n    {   \n        int m = 5;\n        std::cout &lt;&lt; m &lt;&lt; std::endl;\n    }\n\n    int m;\n};\n\nint main()\n{\n    A a;\n    a.showM1( 5 );\n    a.showM2();\n}\n</code></pre>\n<p><a href=\"http://cpp.sh/7dws\" rel=\"nofollow noreferrer\">When I tested</a>, no suprise, it displays 5 and 5. \nBut is this really deterministic?\nIs the priority ALWAYS given to the local variable (or method parameter) and object attribute comes next?</p>\n<p>I'm asking because we renamed some variables in a huge project and just would like to be sure the behaviour is not \"undertermined\" and could vary on platforms, compilers...</p>\n<p>PS: I know this is bad practce and found topics mentioning that the best way is to avoid name conflict (like <a href=\"https://stackoverflow.com/questions/18042699/is-it-bad-to-have-the-same-name-for-parameter-as-for-member-variable\">this one</a>)....</p>\n", "AcceptedAnswerId": "34061982", "Title": "Priority between local variable and class attribute in case of name conflict", "CreationDate": "2015-12-03T09:11:54.797", "Id": "34061864", "CommentCount": "0", "LastEditDate": "2017-05-23T12:02:43.670", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2015-12-03T09:43:02.657", "Score": "2", "OwnerUserId": "3336423", "Tags": "<c++>", "AnswerCount": "3"}, "34062111": {"Id": "34062111", "PostTypeId": "2", "Body": "<p>I think the answer is YES, the local variable in a function or block will always cover the other variables with the same name. If you want to reference m of A, use this-&gt;m.</p>\n", "LastActivityDate": "2015-12-03T09:23:55.183", "Score": "0", "CreationDate": "2015-12-03T09:23:55.183", "ParentId": "34061864", "CommentCount": "0", "OwnerUserId": "3889933"}});