post_cb({"bq_ids": {"n4140": {"so_29181013_29181056_1": {"length": 17, "quality": 1.0, "section_id": 6068}}, "n4659": {"so_29181013_29181056_1": {"length": 17, "quality": 1.0, "section_id": 7564}}}, "29181013": {"ViewCount": "119", "FavoriteCount": "1", "AcceptedAnswerId": "29181056", "Title": "Why are we allowed to take the address of an incomplete type?", "CreationDate": "2015-03-21T09:11:06.563", "LastActivityDate": "2015-03-21T11:34:26.650", "CommentCount": "5", "Body": "<p>Consider this code:</p>\n<pre><code>class Addressable;\nclass Class1  { void foo(Addressable &amp;a) { (void) &amp;a; } };  // OK\nclass Addressable { void *operator &amp;() { return this; } };\nclass Class2  { void foo(Addressable &amp;a) { (void) &amp;a; } };  // Error: operator &amp; private\n</code></pre>\n<p>Why does C++ allow taking the address of an incomplete reference type?</p>\n<p>Couldn't it be potentially illegal, as shown above? Is this intentional?</p>\n", "PostTypeId": "1", "Id": "29181013", "Score": "10", "OwnerUserId": "541686", "Tags": "<c++><reference><incomplete-type>", "AnswerCount": "1"}, "29181056": {"Id": "29181056", "PostTypeId": "2", "LastEditDate": "2015-03-21T11:34:26.650", "CommentCount": "4", "LastEditorUserId": "743382", "LastActivityDate": "2015-03-21T11:34:26.650", "CreationDate": "2015-03-21T09:15:59.147", "ParentId": "29181013", "Score": "5", "Body": "<p>Yes, that's intentional, and the possibility of breakage if <code>operator&amp;</code> is overloaded is known.</p>\n<p>Taking the address of incomplete types has been possible since long before C++. In C, there is absolutely no risk of any breakage, because <code>&amp;</code> cannot be overloaded.</p>\n<p>C++ chose not to unnecessarily break previously valid programs, and simply specified that if an incomplete type does turn out to have an overloaded <code>&amp;</code> operator, it's unspecified whether the overloaded operator gets used.</p>\n<p>Quoting N4140:</p>\n<blockquote>\n<p id=\"so_29181013_29181056_0\"><strong>5.3.1 Unary operators [expr.unary.op]</strong></p>\n<p id=\"so_29181013_29181056_1\">If <code>&amp;</code> is applied to an lvalue of incomplete class type and the complete type declares <code>operator&amp;()</code>, it is unspecified whether the operator has the built-in meaning or the operator function is called.</p>\n</blockquote>\n<p>This can be interpreted to apply even to a class currently being declared, and even when a declaration of <code>operator&amp;</code> has already been seen:</p>\n<pre><code>extern struct A a;\nstruct A {\n  int operator&amp;();\n  decltype(&amp;a) m; // int, or A *?\n};\nint main() {\n  return A().m; // only valid if m is int\n}\n</code></pre>\n<p>Here, GCC gives <code>m</code> type <code>A *</code> and rejects the program, but clang gives it type <code>int</code> and accepts it.</p>\n", "OwnerUserId": "743382"}});