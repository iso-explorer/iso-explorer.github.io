post_cb({"15850840": {"CommentCount": "2", "AcceptedAnswerId": "15850895", "PostTypeId": "1", "LastEditorUserId": "325334", "CreationDate": "2013-04-06T12:17:13.390", "LastActivityDate": "2013-04-06T18:57:27.553", "LastEditDate": "2013-04-06T18:57:27.553", "ViewCount": "2243", "FavoriteCount": "3", "Title": "\"ambiguous overload for 'operator[]'\" if conversion operator to int exist", "Id": "15850840", "Score": "11", "Body": "<p>I'm trying to implement the vector like and the map like [] operator for a class. But I get error messages from my compilers (g++ and clang++). Found out that they only occurs if the class has also conversion operators to integer types.</p>\n<p>Now I have two problems. The first is that I don't know why the compiler can't distinguish between [](const std::string&amp;) and  when the class has conversion operators to ints.\nThe second... I need the conversion and the index operator. Does anyone know how to fix that?</p>\n<p>thanks in advance and best regards from me</p>\n<p>works:</p>\n<pre><code>#include &lt;stdint.h&gt;\n#include &lt;string&gt;\n\nstruct Foo\n{\n    Foo&amp; operator[](const std::string &amp;foo) {}\n    Foo&amp; operator[](size_t index) {}\n};\n\nint main()\n{\n    Foo f;\n    f[\"foo\"];\n    f[2];\n}\n</code></pre>\n<p>does not work:</p>\n<pre><code>#include &lt;stdint.h&gt;\n#include &lt;string&gt;\n\nstruct Foo\n{\n    operator uint32_t() {}\n    Foo&amp; operator[](const std::string &amp;foo) {}\n    Foo&amp; operator[](size_t index) {}\n};\n\nint main()\n{\n    Foo f;\n    f[\"foo\"];\n    f[2];\n}\n</code></pre>\n<p>compiler error:</p>\n<pre><code>main.cpp: In function 'int main()':\nmain.cpp:14:9: error: ambiguous overload for 'operator[]' in 'f[\"foo\"]'\nmain.cpp:14:9: note: candidates are:\nmain.cpp:14:9: note: operator[](long int, const char*) &lt;built-in&gt;\nmain.cpp:7:7: note: Foo&amp; Foo::operator[](const string&amp;)\nmain.cpp:8:7: note: Foo&amp; Foo::operator[](size_t) &lt;near match&gt;\nmain.cpp:8:7: note:   no known conversion for argument 1 from 'const char [4]' to 'size_t {aka long unsigned int}'\n</code></pre>\n", "Tags": "<c++>", "OwnerUserId": "325334", "AnswerCount": "3"}, "15850895": {"ParentId": "15850840", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>The problem is that your class has a conversion operator to <code>uint32_t</code>, so the compiler does not know whether to:</p>\n<ol>\n<li>Construct a <code>std::string</code> from the string literal and invoke your overload accepting an <code>std::string</code>;</li>\n<li>Convert your <code>Foo</code> object into an <code>uint32_t</code> and use it as an index into the string literal.</li>\n</ol>\n<p>While option 2 may sound confusing, consider that the following expression is legal in C++:</p>\n<pre><code>1[\"foo\"];\n</code></pre>\n<p>This is because of how the built-in subscript operator is defined. Per Paragraph 8.3.4/6 of the C++11 Standard:</p>\n<blockquote>\n<p id=\"so_15850840_15850895_0\">Except where it has been declared for a class (13.5.5), the subscript operator [] is interpreted in such\n  a way that <code>E1[E2]</code> is identical to <code>*((E1)+(E2))</code>. Because of the conversion rules that apply to +, if <code>E1</code> is an\n  array and <code>E2</code> an integer, then <code>E1[E2]</code> refers to the <code>E2</code>-th member of <code>E1</code>. Therefore, despite its asymmetric\n  appearance, <strong>subscripting is a commutative operation</strong>.</p>\n</blockquote>\n<p>Therefore, the above expression <code>1[\"foo\"]</code> is equivalent to <code>\"foo\"[1]</code>, which evaluates to <code>o</code>. To resolve the ambiguity, you can either make the conversion operator <code>explicit</code> (in C++11):</p>\n<pre><code>struct Foo\n{\n    explicit operator uint32_t() { /* ... */ }\n//  ^^^^^^^^\n};\n</code></pre>\n<p>Or you can leave that conversion operator as it is, and construct the <code>std::string</code> object explicitly:</p>\n<pre><code>    f[std::string(\"foo\")];\n//    ^^^^^^^^^^^^     ^\n</code></pre>\n<p>Alternatively, you can add a further overload of the subscript operator that accepts a <code>const char*</code>, which would be a better match than any of the above (since it requires no user-defined conversion):</p>\n<pre><code>struct Foo\n{\n    operator uint32_t() { /* ... */ }\n    Foo&amp; operator[](const std::string &amp;foo) { /* ... */ }\n    Foo&amp; operator[](size_t index) { /* ... */ }\n    Foo&amp; operator[](const char* foo) { /* ... */ }\n    //              ^^^^^^^^^^^\n};\n</code></pre>\n<p>Also notice, that your functions have a non-void return type, but currently miss a <code>return</code> statement. This injects <strong>Undefined Behavior</strong> in your program.</p>\n", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "LastEditDate": "2013-04-06T12:44:58.360", "Id": "15850895", "Score": "17", "CreationDate": "2013-04-06T12:23:49.390", "LastActivityDate": "2013-04-06T12:44:58.360"}, "15850901": {"ParentId": "15850840", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The problem is that <code>f[\"foo\"]</code> can be resolved as:</p>\n<ol>\n<li>Convert <code>\"foo\"</code> to <code>std::string</code> (be it <code>s</code>) and do <code>f[s]</code> calling <code>Foo::operator[](const std::string&amp;)</code>.</li>\n<li>Convert <code>f</code> to integer calling <code>Foo::operator int()</code> (be it <code>i</code>) and do <code>i[\"foo\"]</code> using the well known fact that built-in <code>[]</code> operator is commutative.</li>\n</ol>\n<p>Both have one custom type conversion, hence the ambiguity.</p>\n<p>The easy solution is to add yet another overload:</p>\n<pre><code>Foo&amp; operator[](const char *foo) {}\n</code></pre>\n<p>Now, calling <code>f[\"foo\"]</code> will call the new overload without needing any custom type conversion, so the ambiguity is broken.</p>\n<p>NOTE: The conversion from type <code>char[4]</code> (type type of <code>\"foo\"</code>) into <code>char*</code> is considered trivial and doesn't count. </p>\n", "OwnerUserId": "865874", "LastEditorUserId": "865874", "LastEditDate": "2013-04-06T12:36:44.543", "Id": "15850901", "Score": "2", "CreationDate": "2013-04-06T12:24:08.923", "LastActivityDate": "2013-04-06T12:36:44.543"}, "bq_ids": {"n4140": {"so_15850840_15850895_0": {"section_id": 3233, "quality": 0.9696969696969697, "length": 32}}, "n3337": {"so_15850840_15850895_0": {"section_id": 3106, "quality": 0.9696969696969697, "length": 32}}, "n4659": {"so_15850840_15850895_0": {"section_id": 3990, "quality": 0.9696969696969697, "length": 32}}}, "15851559": {"ParentId": "15850840", "CommentCount": "1", "Body": "<p>As noted in other answers, your problem is that <code>[]</code> commutes by default -- <code>a[b]</code> is the same as <code>b[a]</code> for <code>char const*</code>, and with your class being convertible to <code>uint32_t</code> this is as good a match as the <code>char*</code> being converted to <code>std::string</code>.</p>\n<p>What I'm providing here is a way to make an \"extremely attractive overload\" for when you are having exactly this kind of problem, where an overload doesn't get called despite your belief that it should.</p>\n<p>So here is a <code>Foo</code> with an \"extremely attractive overload\" for <code>std::string</code>:</p>\n<pre><code>struct Foo\n{\n  operator uint32_t() {return 1;}\n  Foo&amp; lookup_by_string(const std::string &amp;foo) { return *this; }\n  Foo&amp; operator[](size_t index) {return *this;}\n  template&lt;\n    typename String,\n    typename=typename std::enable_if&lt;\n      std::is_convertible&lt; String, std::string &gt;::value\n    &gt;::type\n  &gt; Foo&amp; operator[]( String&amp;&amp; str ) {\n    return lookup_by_string( std::forward&lt;String&gt;(str) );\n  }\n};\n</code></pre>\n<p>where we create a free standing \"lookup by string\" function, then write a template that captures <em>any</em> type that can be converted into a <code>std::string</code>.</p>\n<p>Because it \"hides\" the user-defined conversion within the body of the template <code>operator[]</code>, when checking for matching no user defined conversion occurs, so this is preferred to other operations that require user defined conversions (like <code>uint32_t[char*]</code>).  In effect, this is a \"more attractive\" overload than any overload that doesn't match the arguments exactly.</p>\n<p>This can lead to problems, if you have another overload that takes a <code>const Bar&amp;</code>, and <code>Bar</code> has a conversion to <code>std::string</code>, the above overload may surprise you and capture the passed in <code>Bar</code> -- both rvalues and non-const variables match the above <code>[]</code> signature better than <code>[const Bar&amp;]</code>!</p>\n", "OwnerUserId": "1774667", "PostTypeId": "2", "Id": "15851559", "Score": "2", "CreationDate": "2013-04-06T13:30:49.350", "LastActivityDate": "2013-04-06T13:30:49.350"}});