post_cb({"32898379": {"ParentId": "32898066", "CommentCount": "0", "CreationDate": "2015-10-01T23:32:28.823", "OwnerUserId": "1116364", "PostTypeId": "2", "Id": "32898379", "Score": "3", "Body": "<p>Usually you can think of a lambda as equivalent to this:</p>\n<pre><code>class ANON {\n  int data;\n  public:\n    void operator ()(void) const {\n      cout &lt;&lt; data &lt;&lt; endl;\n    }\n} lambda;\n// auto lambda = [data]() {cout &lt;&lt; data &lt;&lt; endl;}\n</code></pre>\n<p>This should give you an idea of how capture is implemented. Capture all (be it by copy <code>=</code> or reference <code>&amp;</code>) will probably be no more than syntactic sugar for specifying all used/available variables for capture in the current scope.</p>\n<p>But since ...</p>\n<blockquote>\n<p id=\"so_32898066_32898379_0\">[..] An implementation may define the closure type differently from what is described below provided this does not alter the observable behavior of the program other than by changing: [..] the size and/or alignment of the closure type [..]</p>\n<p id=\"so_32898066_32898379_1\">[N4431 \u00a75.1.2/3]</p>\n</blockquote>\n<p>... it would be legal for an implementation to use some sort of \"black magic\" for capture all by reference lambdas and just use a pointer to the captured stack frame, rewriting accesses to the variables as accesses to some offset of that pointer:</p>\n<pre><code>class ANON {\n  void * stack_frame;\n  public:\n    void operator ()(void) const {\n      cout &lt;&lt; *static_cast&lt;int *&gt;(stack_frame + 8) &lt;&lt; endl;\n    }\n} lambda;\n</code></pre>\n<p>So using <code>&amp;</code> <em>might</em> (some day) be more efficient, but as already said this is implementation defined and this nothing to be relied upon.</p>\n", "LastActivityDate": "2015-10-01T23:32:28.823"}, "32898201": {"ParentId": "32898066", "CommentCount": "0", "CreationDate": "2015-10-01T23:11:13.593", "OwnerUserId": "3159253", "PostTypeId": "2", "Id": "32898201", "Score": "2", "Body": "<p>Internally lambdas are /usually/ implemented as ad-hoc classes  whose single instance object is constructed in the point of lambda definition and which are exposing a functor to be called later. So lambda performance should be compared with passing a method to a function using <code>std::bind</code>.</p>\n<p>Captures aren't mystical entities as well. If captures are reference-captures, entities which they refer to are detroyed when go out of the scope as usual, so beware if your lambda isn't local: inside its body it may refer to object which have been destroyed already.</p>\n", "LastActivityDate": "2015-10-01T23:11:13.593"}, "32898066": {"CommentCount": "4", "ViewCount": "613", "CreationDate": "2015-10-01T22:54:41.200", "LastActivityDate": "2015-10-01T23:32:28.823", "Title": "Lambda function performance impact of capture", "AcceptedAnswerId": "32898379", "PostTypeId": "1", "Id": "32898066", "Score": "3", "Body": "<p>I just wrote a pretty big capture:</p>\n<pre><code>[this, &amp;newIndex, &amp;indexedDirs, &amp;filters, &amp;flags, &amp;indexRecursion](){...\n</code></pre>\n<p>I use this lambda (indexRecursion) for a recursion with thoudands of elements and asked myself, if it would be more efficient to use the \"global\" capture <code>[&amp;]</code>. Since I have no clue of the implementation of the capture I need some explanation. Please with background too.</p>\n", "Tags": "<c++><lambda>", "OwnerUserId": "978486", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_32898066_32898379_0": {"section_id": 5962, "quality": 1.0, "length": 22}}, "n3337": {"so_32898066_32898379_0": {"section_id": 5731, "quality": 1.0, "length": 22}}, "n4659": {"so_32898066_32898379_0": {"section_id": 7452, "quality": 1.0, "length": 22}}}});