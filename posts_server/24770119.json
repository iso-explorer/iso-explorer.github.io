post_cb({"24770416": {"ParentId": "24770119", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2014-07-16T00:41:13.277", "Score": "1", "LastEditorUserId": "3204551", "LastEditDate": "2014-07-16T01:14:12.950", "Id": "24770416", "OwnerUserId": "3204551", "Body": "<p>From the C++1y draft:</p>\n<blockquote>\n<h3>5.3.5 Delete <code>[expr.delete]</code></h3>\n<p id=\"so_24770119_24770416_0\">[...]<br>\n  11 When a delete-expression is executed, the selected deallocation function shall be called with the address of the block of storage to be reclaimed as its first argument and (if the two-parameter deallocation function is used) the size of the block as its second argument.83</br></p>\n<p id=\"so_24770119_24770416_1\">Footnote 83) If the static type of the object to be deleted is complete and is different from the dynamic type, and the destructor is not\n  virtual, the size might be incorrect, but that case is already undefined, as stated above.</p>\n</blockquote>\n<blockquote>\n<h2>17.6.4.6 Replacement functions <code>[replacement.functions]</code></h2>\n<p id=\"so_24770119_24770416_2\">1 Clauses 18 through 30 and Annex D describe the behavior of numerous functions defined by the C++ standard library. Under some circumstances, however, certain of these function descriptions also apply to replacement functions defined in the program (17.3).<br>\n  2 A C++ program may provide the definition for any of twelve dynamic memory allocation function signatures declared in header <code>&lt;new&gt;</code> (3.7.4, 18.6):</br></p>\n<pre><code>operator new(std::size_t)\noperator new(std::size_t, const std::nothrow_t&amp;)\noperator new[](std::size_t)\noperator new[](std::size_t, const std::nothrow_t&amp;)\nperator delete(void*)\noperator delete(void*, const std::nothrow_t&amp;)\noperator delete[](void*)\noperator delete[](void*, const std::nothrow_t&amp;)\n</code></pre>\n</blockquote>\n<p>note by me: The next four are new in C++1y</p>\n<blockquote>\n<pre><code>operator delete(void*, std::size_t)\noperator delete(void*, std::size_t, const std::nothrow_t&amp;)\noperator delete[](void*, std::size_t)\noperator delete[](void*, std::size_t, const std::nothrow_t&amp;)\n</code></pre>\n<p id=\"so_24770119_24770416_3\">3 The program\u2019s definitions are used instead of the default versions supplied by the implementation (18.6). Such replacement occurs prior to program startup (3.2, 3.6). The program\u2019s definitions shall not be specified as inline. No diagnostic is required.</p>\n</blockquote>\n<p>Also take a look at the proposal which introduces sized deallocation in C++1y:<br>\n<a href=\"http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3536.html\" rel=\"nofollow\">http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2013/n3536.html</a></br></p>\n", "LastActivityDate": "2014-07-16T01:14:12.950"}, "24770119": {"CommentCount": "8", "AcceptedAnswerId": "24770416", "ClosedDate": "2014-07-16T04:48:16.340", "CreationDate": "2014-07-16T00:05:16.347", "LastActivityDate": "2014-07-16T01:40:49.190", "PostTypeId": "1", "ViewCount": "159", "Title": "Operator delete signature unexpected behavior", "Id": "24770119", "Score": "1", "Body": "<p>In his book C++ Programming Language(4th ed), stroustroup has mentioned that the global operator new &amp; delete can be overloaded by writing global functions with the following signatures:</p>\n<pre><code>void* operator new(size_t);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// use for individual object\nvoid* operator new[](size_t);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// use for array\nvoid operator delete(void*, size_t);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// use for individual object\nvoid operator delete[](void*, size_t);\u00a0\u00a0\u00a0\u00a0// use for array\n</code></pre>\n<p><strong>NOTE:</strong> The size_t parameter is passed for the delete to determine the correct object size specifically when deleting a derived object pointed by a base pointer(base needs virtual dtor so that correct size is passed).</p>\n<p>I was trying to overload the global versions for the individual object. The operator new works fine. The operator delete with the above signature works fine, but delete doesn't get called. If I change the delete signature so that it just takes a void *, it does get called. What could be the problem:</p>\n<p>Here is code:</p>\n<pre><code>void * operator new (size_t size)\n{\n    cout &lt;&lt; \"My operator new called\\n\";\n    auto p = malloc(size);\n    return p;\n}\n\nvoid operator delete (void * ptr, size_t size) // Removing size_t parameter makes it work\n{\n    cout &lt;&lt; \"My operator delete called\\n\";\n    free(ptr);\n}\n</code></pre>\n<p>Strange is also the fact that if I make the operator delete a member of a class so that its overloaded just for that class, both delete signatures(with size_t and without size_t) seem to work!</p>\n<p>Passing size_t parameter in delete does seem logical as explained in the NOTE I had mentioned. But what could be the reason for this behavior? I am using VS2013 for testing out the examples.</p>\n", "Tags": "<c++><operator-overloading><new-operator>", "OwnerUserId": "602798", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_24770119_24770416_3": {"section_id": 6318, "quality": 0.8571428571428571, "length": 18}, "so_24770119_24770416_2": {"section_id": 6316, "quality": 0.5833333333333334, "length": 21}, "so_24770119_24770416_0": {"section_id": 6115, "quality": 0.9545454545454546, "length": 21}, "so_24770119_24770416_1": {"section_id": 6115, "quality": 0.95, "length": 19}}, "n3337": {"so_24770119_24770416_3": {"section_id": 6075, "quality": 0.8571428571428571, "length": 18}, "so_24770119_24770416_2": {"section_id": 6073, "quality": 0.5833333333333334, "length": 21}, "so_24770119_24770416_0": {"section_id": 408, "quality": 0.8636363636363636, "length": 19}, "so_24770119_24770416_1": {"section_id": 408, "quality": 0.8, "length": 16}}, "n4659": {"so_24770119_24770416_3": {"section_id": 7828, "quality": 0.8095238095238095, "length": 17}, "so_24770119_24770416_2": {"section_id": 7826, "quality": 0.5833333333333334, "length": 21}, "so_24770119_24770416_0": {"section_id": 7612, "quality": 0.6818181818181818, "length": 15}, "so_24770119_24770416_1": {"section_id": 7612, "quality": 0.95, "length": 19}}}, "24770898": {"ParentId": "24770119", "CommentCount": "0", "CreationDate": "2014-07-16T01:40:49.190", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "24770898", "Score": "1", "Body": "<p>In C++11, non-member <code>void operator delete(void*, size_t)</code> is \"placement deallocation with additional arguments\". It corresponds to the placement allocation with additional arguments (if you defined one):  <code>void *operator new(size_t, size_t)</code>. </p>\n<p>Clarification of this, according to 3.7.4.2, <code>T::operator delete(void*, size_t)</code> is a usual deallocation function, but N3337 does not say that <code>::operator delete(void *, size_t)</code> is a usual deallocation function; in fact that signature for <code>::operator delete</code> does not appear anywhere in the document. Specifically, 17.6.4.6 does not list it amongst the global versions.</p>\n<p>In C++1y, <code>::operator delete(void*, size_t)</code> is a usual deallocation function (i.e. non-placement). It seems to me at this is a breaking change between C++11 and C++1y.</p>\n<p>According to N3797, in C++1y if you replace <code>operator delete(void *)</code> then you must also replace <code>operator delete(void *, size_t)</code> and vice versa.  (Otherwise, presumably, the program is ill-formed).</p>\n<p>Also according to N3797, either of those two functions may be called for deallocation, but I don't see a clear specification of in which circumstances which function is called.</p>\n<p>Note: <em>overloading</em> is the wrong term; when you define a usual allocation operator, it <em>replaces</em> the standard library version.</p>\n", "LastActivityDate": "2014-07-16T01:40:49.190"}});