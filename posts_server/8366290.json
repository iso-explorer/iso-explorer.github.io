post_cb({"8366290": {"CommentCount": "7", "ViewCount": "3408", "CreationDate": "2011-12-03T07:25:46.543", "LastActivityDate": "2011-12-03T07:47:06.020", "Title": "variable arguments in c++ with different datatypes", "FavoriteCount": "1", "PostTypeId": "1", "Id": "8366290", "Score": "1", "Body": "<p>please read through the following code</p>\n<pre><code>#define  INT    0\n#define  CHAR   1\n#define  FLOAT  2\n#define  DOUBLE 3\n\nint createKey(int keySize,vector&lt;int&gt; &amp;types, ...){ \n    va_list varlist;\n    va_start(varlist,types.size());\n\n    int intKey;\n    float floatKey;\n    char charKey;\n    double doubleKey;\n\n    char *key = (char*)malloc(keySize);\n    int offset = 0;\n\n    for(int i=0;i&lt;types.size();i++){\n        switch(types[i]){\n            case INT:\n                intKey = va_arg(varlist,int);\n                memcpy(&amp;key[offset],&amp;intKey,sizeof(int));\n                offset += sizeof(int);\n            break;\n\n            case CHAR:\n                charKey = va_arg(varlist,char);\n                memcpy(&amp;key[offset],&amp;charKey,sizeof(char));\n                offset += sizeof(char);\n            break;\n\n            case FLOAT:\n                floatKey = va_arg(varlist,float);\n                memcpy(&amp;key[offset],&amp;floatKey,sizeof(float));\n                offset += sizeof(float);\n            break;\n\n            case DOUBLE:\n                doubleKey = va_arg(varlist,double);\n                memcpy(&amp;key[offset],&amp;doubleKey,sizeof(double));\n                offset += sizeof(double);\n            break;\n\n        }\n        va_end(varlist);\n    }\n\n    int testIntKey;\n    char testCharKey;\n    float testFloatKey;\n    double testDoubleKey;\n\n    offset = 0;\n\n    for(int i=0;i&lt;types.size();i++) {\n        switch(types[i]){\n            case INT:\n                memcpy(&amp;testIntKey,&amp;key[offset],sizeof(int));\n                cout&lt;&lt;testIntKey&lt;&lt;endl;\n                offset += sizeof(int);\n            break;\n\n            case CHAR:\n                memcpy(&amp;testCharKey,&amp;key[offset],sizeof(char));\n                cout&lt;&lt;testCharKey&lt;&lt;endl;\n                offset += sizeof(char);\n\n            break;\n\n            case FLOAT:\n                memcpy(&amp;testFloatKey,&amp;key[offset],sizeof(float));\n                cout&lt;&lt;testFloatKey&lt;&lt;endl;\n                offset += sizeof(float);\n            break;\n\n            case DOUBLE:\n                memcpy(&amp;testDoubleKey,&amp;key[offset],sizeof(double));\n                cout&lt;&lt;testDoubleKey&lt;&lt;endl;\n                offset += sizeof(double);\n            break;\n        }\n    }\n\n}\n</code></pre>\n<p>In the above code, I am trying to create a key that is a combination of one or more of the datatypes(int,char,float,double)...I used ellipses as i donot know the number of arguments that may be passed to createKey(). Now the above code when compiled shows the following warnings..</p>\n<pre><code>varargsTest.cpp: In function \u2018int createKey(int, std::vector&lt;int, std::allocator&lt;int&gt; &gt;&amp;, ...)\u2019:\nvarargsTest.cpp:20: warning: second parameter of \u2018va_start\u2019 not last named argument\nvarargsTest.cpp:39: warning: \u2018char\u2019 is promoted to \u2018int\u2019 when passed through \u2018...\u2019\nvarargsTest.cpp:39: note: (so you should pass \u2018int\u2019 not \u2018char\u2019 to \u2018va_arg\u2019)\nvarargsTest.cpp:39: note: if this code is reached, the program will abort\nvarargsTest.cpp:45: warning: \u2018float\u2019 is promoted to \u2018double\u2019 when passed through \u2018...\u2019\nvarargsTest.cpp:45: note: if this code is reached, the program will abort\n</code></pre>\n<p>and when i run the program with the following ..</p>\n<pre><code>int main()\n{\n    vector&lt;int&gt; types;\n\n    types.push_back(INT);\n    types.push_back(CHAR);\n    types.push_back(INT);\n\n    createKey(9,types,85,'s',97);\n\n}\n</code></pre>\n<p>I get <code>Illegal instruction.</code> </p>\n<p>How could this problem be solved...Is this the right approach to handle these kind of problems?</p>\n", "Tags": "<c++>", "OwnerUserId": "502867", "AnswerCount": "1"}, "8366323": {"ParentId": "8366290", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>When you call a function with a variable argument list (which is generally a bad idea in C++), then any <code>float</code> expressions are automatically promoted (converted) to <code>double</code>, and any <code>char</code> (any of the three flavours) and <code>short</code> (two flavours) are promoted to <code>int</code>.  Therefore, as the error message says, you cannot expect <code>va_arg()</code> to collect a <code>float</code> or a <code>char</code> type; you need to collect a <code>double</code> or <code>int</code> and coerce the result if necessary.</p>\n<p>In general, C++ programmers look unfavourably on variable argument list functions because they are inherently not type-safe and C++ invests a lot of effort into being type-safe.</p>\n<p>The 1998 C++ standard essentially incorporates the (1989) C standard specification for <code>&lt;stdarg.h&gt;</code> verbatim.  The 1999 C standard says:</p>\n<blockquote>\n<h2>\u00a77.15.1.1 The va_arg macro</h2>\n<h3>Synopsis</h3>\n<pre><code>#include &lt;stdarg.h&gt;\ntype va_arg(va_list ap, type);\n</code></pre>\n<h3>Description</h3>\n<p id=\"so_8366290_8366323_0\">The <code>va_arg</code> macro expands to an expression that has the specified type and the value of\n  the next argument in the call. The parameter <code>ap</code> shall have been initialized by the\n  <code>va_start</code> or <code>va_copy</code> macro (without an intervening invocation of the <code>va_end</code><sup>212)</sup>\n  macro for the same <code>ap</code>). Each invocation of the <code>va_arg</code> macro modifies <code>ap</code> so that the\n  values of successive arguments are returned in turn. The parameter <code>type</code> shall be a type\n  name specified such that the type of a pointer to an object that has the specified type can\n  be obtained simply by postfixing a <code>*</code> to <code>type</code>. If there is no actual next argument, or if\n  <code>type</code> is not compatible with the type of the actual next argument (as promoted according\n  to the default argument promotions), the behavior is undefined, except for the following\n  cases:</p>\n<p id=\"so_8366290_8366323_1\">\u2014 one type is a signed integer type, the other type is the corresponding unsigned integer type, and the value is representable in both types;</p>\n<p id=\"so_8366290_8366323_2\">\u2014 one type is pointer to void and the other is a pointer to a character type.</p>\n<h3>Returns</h3>\n<p id=\"so_8366290_8366323_3\">The first invocation of the <code>va_arg</code> macro after that of the <code>va_start</code> macro returns the\n  value of the argument after that specified by <code>parmN</code>. Successive invocations return the\n  values of the remaining arguments in succession.</p>\n<p id=\"so_8366290_8366323_4\"><sup>212)</sup> It is permitted to create a pointer to a va_list and pass that pointer to another function, in which\n  case the original function may make further use of the original list after the other function returns.</p>\n</blockquote>\n<p>The C89 standard is similar but does not support/define <code>va_copy</code>.</p>\n", "OwnerUserId": "15168", "LastEditorUserId": "15168", "LastEditDate": "2011-12-03T07:47:06.020", "Id": "8366323", "Score": "3", "CreationDate": "2011-12-03T07:36:08.060", "LastActivityDate": "2011-12-03T07:47:06.020"}, "bq_ids": {"n4140": {"so_8366290_8366323_2": {"section_id": 5946, "quality": 0.875, "length": 7}, "so_8366290_8366323_1": {"section_id": 7212, "quality": 0.7333333333333333, "length": 11}}, "n3337": {"so_8366290_8366323_2": {"section_id": 5913, "quality": 0.875, "length": 7}, "so_8366290_8366323_1": {"section_id": 6956, "quality": 0.7333333333333333, "length": 11}}, "n4659": {"so_8366290_8366323_2": {"section_id": 7432, "quality": 0.875, "length": 7}, "so_8366290_8366323_1": {"section_id": 8721, "quality": 0.7333333333333333, "length": 11}}}});