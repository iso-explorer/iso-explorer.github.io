post_cb({"42579091": {"ParentId": "42578832", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>The classes from the standard library are normally templates and can use a specific allocator for special needs. By default, they use the standard allocator (<code>std::allocator</code>) which uses <code>operator new</code> and <code>operator delete</code>:</p>\n<blockquote>\n<p id=\"so_42578832_42579091_0\">20.7.9.1 allocator members [allocator.members] <br/>...<br/></p>\n<pre><code>pointer allocate(size_type n, allocator&lt;void&gt;::const_pointer hint = 0);\n</code></pre>\n<p id=\"so_42578832_42579091_1\">...<br/>Remark: the storage is obtained by calling ::operator new(std::size_t) (18.6.1), but it is unspecified\n  when or how often this function is called...</p>\n<pre><code>void deallocate(pointer p, size_type n);\n</code></pre>\n<p id=\"so_42578832_42579091_2\">...<br>Remarks: Uses ::operator delete(void*, std::size_t) (18.6.1), but it is unspecified when this\n  function is called.</br></p>\n</blockquote>\n<p>The fact that it is unspecified when the operators new and delete are called allows implementations to cache unused memory blocks for performance reasons.</p>\n", "OwnerUserId": "3545273", "LastEditorUserId": "3545273", "LastEditDate": "2017-03-03T12:39:44.267", "Id": "42579091", "Score": "1", "CreationDate": "2017-03-03T12:37:53.153", "LastActivityDate": "2017-03-03T12:39:44.267"}, "42579081": {"ParentId": "42578832", "PostTypeId": "2", "CommentCount": "2", "Body": "<h2>Standard library containers</h2>\n<p>Standard library containers take an allocator template argument that is used to control how memory is allocated. By default, they use <a href=\"http://en.cppreference.com/w/cpp/memory/allocator\" rel=\"nofollow noreferrer\"><code>std::allocator&lt;T&gt;</code></a>. <code>std::allocator&lt;T&gt;</code> has a member function <a href=\"http://en.cppreference.com/w/cpp/memory/allocator/allocate\" rel=\"nofollow noreferrer\"><code>std::allocator&lt;T&gt;::allocate()</code></a> that:</p>\n<blockquote>\n<p id=\"so_42578832_42579081_0\">Allocates <code>n * sizeof(T)</code> bytes of uninitialized storage by calling <code>::operator new(std::size_t)</code></p>\n</blockquote>\n<p>Likewise, there is a <a href=\"http://en.cppreference.com/w/cpp/memory/allocator/deallocate\" rel=\"nofollow noreferrer\"><code>std::allocator&lt;T&gt;::deallocate()</code></a> function that calls <code>operator delete(void *)</code>.</p>\n<h2><code>std::function</code></h2>\n<p><code>std::function</code> has <a href=\"http://en.cppreference.com/w/cpp/utility/functional/function/function\" rel=\"nofollow noreferrer\">several constructors</a>, some of which allow you to specify an allocator object to use for its internal allocations. If you don't specify one, then it will use <code>std::allocator</code>.</p>\n<h2>Lambdas</h2>\n<p>I'm not sure what allocations you expect to be done with lambdas. When you declare a lambda, the compiler synthesizes an unnamed functor type behind the scenes that implements the lambda in its <code>operator()</code>. If you capture any variables from the local scope, those variables simply become part of that type's definition, increasing the size of the lambda type, but there isn't any dynamic allocation required; the captured variables are just members of the lambda's unnamed type. If you were to assign the lambda to something like a <code>std::function</code>, then there could be dynamic allocation done by the <code>std::function</code> to accommodate the lambda's increased size.</p>\n", "OwnerUserId": "919747", "LastEditorUserId": "919747", "LastEditDate": "2017-03-03T12:42:37.633", "Id": "42579081", "Score": "3", "CreationDate": "2017-03-03T12:37:27.830", "LastActivityDate": "2017-03-03T12:42:37.633"}, "42579217": {"ParentId": "42578832", "CommentCount": "2", "Body": "<p>The standard containers accept a templated argument that is an allocator.   By default, that allocator for each of the standard containers is of type <code>std::allocator&lt;T&gt;</code>   (e.g. the default allocator for a <code>std::vector&lt;T&gt;</code> is of type <code>std::allocator&lt;T&gt;</code>).   <code>std::allocator</code> uses the function <code>::operator new(size_t)</code> to allocate raw memory.</p>\n<p>Part of the workings of a typical new expression (e.g. of the form <code>new Type</code>) is calling the function <code>::operator new(size_t)</code>.   However, a default allocator is not required to use such a new expression.</p>\n<p>Part of the interface for an allocator is providing a member function <code>construct(pointer p, const_reference val)</code>.  This member function of <code>std::allocate&lt;T&gt;</code> returns <code>new((void *)p) T(val)</code>   (which is sometimes describes as a placement-new expression).</p>\n<p>There is no requirement that non-default allocators (e.g. an allocator type supplied by a programmer for use instead of a default allocator) use <code>::operator new()</code> or a new expression.</p>\n", "OwnerUserId": "4706785", "PostTypeId": "2", "Id": "42579217", "Score": "1", "CreationDate": "2017-03-03T12:43:52.823", "LastActivityDate": "2017-03-03T12:43:52.823"}, "bq_ids": {"n4140": {"so_42578832_42579091_2": {"section_id": 4244, "quality": 0.8181818181818182, "length": 9}, "so_42578832_42579091_1": {"section_id": 4240, "quality": 0.8571428571428571, "length": 12}}, "n3337": {"so_42578832_42579091_2": {"section_id": 4085, "quality": 0.7272727272727273, "length": 8}, "so_42578832_42579091_1": {"section_id": 4081, "quality": 0.8571428571428571, "length": 12}}, "n4659": {"so_42578832_42579091_2": {"section_id": 5503, "quality": 0.6363636363636364, "length": 7}, "so_42578832_42579091_1": {"section_id": 6399, "quality": 0.8571428571428571, "length": 12}}}, "42578832": {"CommentCount": "4", "ViewCount": "73", "CreationDate": "2017-03-03T12:24:06.093", "LastActivityDate": "2017-03-03T12:43:52.823", "Title": "Does the C++ standard guarantee that dynamic allocations are done with new?", "AcceptedAnswerId": "42579081", "PostTypeId": "1", "Id": "42578832", "Score": "0", "Body": "<p>simple learning question. Is it specified in the C++ standard how std classes allocate memory? I would assume that internally, all allocations are at some point forwarded to <code>new</code> / <code>new[]</code>. I'm especially interested in allocations done by containers, std::function and lambdas.  </p>\n", "Tags": "<c++><dynamic><standards><new-operator><allocation>", "OwnerUserId": "2532768", "AnswerCount": "3"}});