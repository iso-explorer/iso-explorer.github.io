post_cb({"bq_ids": {"n4140": {"so_38371924_38373019_2": {"length": 6, "quality": 0.75, "section_id": 5440}}, "n3337": {"so_38371924_38373019_2": {"length": 6, "quality": 0.75, "section_id": 5235}}, "n4659": {"so_38371924_38373019_2": {"length": 6, "quality": 0.75, "section_id": 6867}}}, "38373019": {"Id": "38373019", "PostTypeId": "2", "Body": "<p>In answer to the second question</p>\n<blockquote>\n<p id=\"so_38371924_38373019_0\">How can I get the code to compile with GCC?</p>\n</blockquote>\n<p>I would simplify the expression being passed to the <code>decltype()</code>. If the compilation of the <code>call</code> method is dependent on the compilation of <code>x.foo(*this);</code>, then that is what you should use.</p>\n<pre><code>struct Foo\n{\n    template &lt;typename T&gt; void foo(T&amp;&amp; x) { x.hello(); }\n};\n\nstruct Caller\n{    \n    template &lt;typename T&gt;\n    auto call(T&amp;&amp; x, int) -&gt; decltype(x.foo(*this))\n    {\n        //x.foo(*this);\n    }\n    template &lt;typename T&gt;\n    void call(T&amp;&amp;, char){ std::cout &lt;&lt; \"hello\" &lt;&lt; std::endl;}\n};\n\nint main()\n{\n  Caller c;\n  c.call(Foo(), 0);\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/fc8446c818022ca4\" rel=\"nofollow\">Demo here.</a></p>\n<hr>\n<p>I think the OP's issue with gcc lies in the address being taken of the function (or decaying to a function pointer if not explicitly taken). I think this is something of a corner case in the standard. The <code>x.hello()</code> would need to exist (compile) if the method <code>Foo::foo</code> is required; in general taking the address of something satisfies that, but in an unevaluated context (<code>decltype()</code>), I'm not sure if that would apply - certainly clang does not require it to exist (nor does MSVC).</p>\n<p>In that respect,</p>\n<blockquote>\n<p id=\"so_38371924_38373019_1\">Who is right? Clang or GCC?</p>\n</blockquote>\n<p>I suspect clang implements a more permissive reading of the standard and probably more correct reading. The operand to a <code>decltype()</code> is an unevaluated operand, see <a href=\"http://eel.is/c++draft/dcl.type.simple#4\" rel=\"nofollow\">[dcl.type.simple]/4</a>;</p>\n<blockquote>\n<p id=\"so_38371924_38373019_2\">The operand of the decltype specifier is an unevaluated operand (Clause [expr]).</p>\n</blockquote>\n</hr>", "LastEditorUserId": "3747990", "LastActivityDate": "2016-07-17T18:27:36.797", "Score": "2", "CreationDate": "2016-07-14T11:29:42.267", "ParentId": "38371924", "CommentCount": "21", "LastEditDate": "2016-07-17T18:27:36.797", "OwnerUserId": "3747990"}, "38371924": {"ViewCount": "126", "Body": "<p>While continuing work from <a href=\"https://stackoverflow.com/a/38347040/678093\">my previous question</a>, I came across different behavior of clang and GCC.<br>\nI need to check the member function pointer because I need to know if the function is inherited or not.</br></p>\n<p>When comparing member function pointers in an SFINAE context, member function <code>Foo::foo()</code> exists, but its body contains code (<code>x.hello()</code>) which eventually does not compile.</p>\n<p>The following code compiles with clang.\nGCC however seems to evaluate the function body of <code>Foo::foo()</code> and exits with an error (<code>'struct Caller' has no member named 'hello'</code>), despite being in an unevaluated SFINAE context (or so I hope).</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;type_traits&gt;\n\nstruct Foo\n{\n    template &lt;typename T&gt; void foo(T&amp;&amp; x) { x.hello(); }\n};\n\nstruct Caller\n{    \n    template &lt;typename T&gt;\n    auto call(T&amp;&amp; x) -&gt; decltype(\n        std::enable_if_t&lt;\n            std::is_same&lt;\n                decltype(&amp;T::template foo&lt;decltype(*this)&gt;),\n                void (T::*)(decltype(*this))\n            &gt;::value\n        &gt;())\n    {\n        //x.foo(*this);\n    }\n};\n\nint main()\n{\n  Caller c;\n  c.call(Foo());\n}\n</code></pre>\n<p>I tested with:</p>\n<ul>\n<li>clang 3.8.0</li>\n<li>g++ 6.1.0</li>\n</ul>\n<p>Compiler options for both: <code>-std=c++14 -O2 -Wall -pedantic -pthread</code></p>\n<p><kbd><a href=\"http://coliru.stacked-crooked.com/a/15f0f4fa3c2698fd\" rel=\"nofollow noreferrer\">live example</a></kbd></p>\n<p><strong>My questions:</strong></p>\n<ol>\n<li>who is right? Clang or GCC?</li>\n<li>How can I get the code to compile with GCC?</li>\n</ol>\n", "Title": "Clang vs. GCC: Error in unevaluated context breaks SFINAE", "CreationDate": "2016-07-14T10:34:31.730", "LastActivityDate": "2016-07-17T18:27:36.797", "CommentCount": "1", "FavoriteCount": "0", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:22:53.637", "LastEditorUserId": "-1", "Id": "38371924", "Score": "3", "OwnerUserId": "678093", "Tags": "<c++><templates><gcc><sfinae><clang++>", "AnswerCount": "1"}});