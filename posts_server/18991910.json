post_cb({"18991910": {"ViewCount": "2821", "Body": "<p>So I'm trying to figure out how this works: <a href=\"https://stackoverflow.com/questions/10766112/c11-i-can-go-from-multiple-args-to-tuple-but-can-i-go-from-tuple-to-multiple\">C++11: I can go from multiple args to tuple, but can I go from tuple to multiple args?</a></p>\n<p>The piece of black magic I do not understand is this code fragment:</p>\n<pre><code>f(std::get&lt;N&gt;(std::forward&lt;Tuple&gt;(t))...)\n</code></pre>\n<p>it's the expression inside <code>f</code> that I don't understand.</p>\n<p>I understand that the expression somehow unpacks/expands what's inside <code>t</code> into a list of arguments. But could someone care to explain how this is done? When I look at the definition of <code>std::get</code> (<a href=\"http://en.cppreference.com/w/cpp/utility/tuple/get\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/utility/tuple/get</a>), I don't see how <code>N</code> fits in...? As far as I can tell, N is a sequence of integers. </p>\n<p>Based on what I can observe, I'm assuming that expressions in the form <code>E&lt;X&gt;...</code> where <code>X</code> is the sequence of types <code>X1</code>. <code>X2</code>, ... <code>Xn</code>, the expression will be expanded as <code>E&lt;X1&gt;, E&lt;X2&gt; ... E&lt;Xn&gt;</code>. Is this how it works?</p>\n<p><strong>Edit</strong>: In this case N is not a sequence of types, but integers. But I'm guessing this language construct applies to both types and values.</p>\n", "AcceptedAnswerId": "18993037", "Title": "Unpacking arguments from tuples", "CreationDate": "2013-09-24T20:57:26.803", "Id": "18991910", "CommentCount": "11", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:00:27.860", "LastEditorUserId": "-1", "LastActivityDate": "2013-09-24T22:37:52.850", "Score": "8", "OwnerUserId": "122943", "Tags": "<c++><templates><c++11><variadic-templates>", "AnswerCount": "2"}, "18993037": {"Id": "18993037", "PostTypeId": "2", "Body": "<p>I think that @Xeo's comment summed it up well.  From 14.5.3 of the C++11 standard:</p>\n<blockquote>\n<p id=\"so_18991910_18993037_0\">A pack expansion consists of a <em>pattern</em> and an <em>ellipsis</em>, the\n  instantiation of which produces zero or more instantiations of the\n  pattern in a list.</p>\n</blockquote>\n<p>In your case, by the time you finish with the recursive template instantiation and end up in the partial specialization, you have</p>\n<pre><code>f(std::get&lt;N&gt;(std::forward&lt;Tuple&gt;(t))...);\n</code></pre>\n<p>...where <code>N</code> is parameter pack of four <code>int</code>s (<code>0</code>, <code>1</code>, <code>2</code>, and <code>3</code>).  From the standardese above, the <em>pattern</em> here is </p>\n<pre><code>std::get&lt;N&gt;(std::forward&lt;Tuple&gt;(t))\n</code></pre>\n<p>The application of the <code>...</code> ellipsis to the above pattern causes it to be expanded into four instantiations in list form, i.e.</p>\n<pre><code>f(std::get&lt;0&gt;(t), std::get&lt;1&gt;(t), std::get&lt;2&gt;(t), std::get&lt;3&gt;(t));\n</code></pre>\n", "LastActivityDate": "2013-09-24T22:15:57.850", "CommentCount": "0", "CreationDate": "2013-09-24T22:15:57.850", "ParentId": "18991910", "Score": "5", "OwnerUserId": "98654"}, "bq_ids": {"n4140": {"so_18991910_18993037_0": {"length": 12, "quality": 1.0, "section_id": 121}}, "n3337": {"so_18991910_18993037_0": {"length": 12, "quality": 1.0, "section_id": 116}}, "n4659": {"so_18991910_18993037_0": {"length": 10, "quality": 0.8333333333333334, "section_id": 125}}}, "18993297": {"Id": "18993297", "PostTypeId": "2", "Body": "<p>The fundamental ingredient to expanding the <code>std::tuple&lt;T...&gt;</code> is actually omitted from the code: you need to obtain a a second parameter back: in addition to the list of types of the <code>std::tuple&lt;...&gt;</code> you need a parameter pack with indices <code>0, 1, ..., n</code>. Once you have these two parameters packs, you can expand them in tandem:</p>\n<pre><code>template &lt;typename F, typename... T, int... N&gt;\nvoid call_impl(F&amp;&amp; fun, std::tuple&lt;T...&gt;&amp;&amp; t) {\n    fun(std::get&lt;N&gt;(t)...);\n}\n</code></pre>\n<p>The real magic lies in conjuring up the second parameter pack when you just have a <code>std::tuple&lt;T...&gt;</code>. It takes a bit of template programming. Here is an approach to create the list of indices:</p>\n<pre><code>template &lt;int... Indices&gt; struct indices;\ntemplate &lt;&gt; struct indices&lt;-1&gt; { typedef indices&lt;&gt; type; };\ntemplate &lt;int... Indices&gt;\nstruct indices&lt;0, Indices...&gt;\n{\n    typedef indices&lt;0, Indices...&gt; type;\n};\ntemplate &lt;int Index, int... Indices&gt;\nstruct indices&lt;Index, Indices...&gt;\n{\n    typedef typename indices&lt;Index - 1, Index, Indices...&gt;::type type;\n};\n\ntemplate &lt;typename T&gt;\ntypename indices&lt;std::tuple_size&lt;T&gt;::value - 1&gt;::type const*\nmake_indices()\n{\n    return 0;\n}\n</code></pre>\n<p>So, if you have a function template, let's call it <code>call()</code> which takes a function object and a <code>std::tuple&lt;T...&gt;</code> with the arguments to the function. An easy approach is to rewrite the <code>call_impl()</code> mentioned above to deal with deducing the indices:</p>\n<pre><code>template &lt;typename F, typename Tuple, int... N&gt;\nvoid call_impl(F&amp;&amp; fun, Tuple&amp;&amp; t, indices&lt;Indices...&gt; const*)\n{\n    fun(std::get&lt;N&gt;(t)...);\n}\n\ntemplate &lt;typename F, typename Tuple&gt;\nvoid call(F&amp;&amp; fun, Tuple&amp;&amp; t)\n{\n    call_imle(std::forward&lt;F&gt;(fun), std::forward&lt;Tuple&gt;(t), make_indices&lt;Tuple&gt;());\n}\n</code></pre>\n<p>What this code doesn't really extend is the correct use of <code>std::forward&lt;...&gt;()</code> with the various <code>std::tuple&lt;...&gt;</code> elements when calling the function. Just using <code>std::forward&lt;Tuple&gt;(t)</code> does <strong>not</strong> work because it possibly moves the entire <code>std::tuple&lt;...&gt;</code> rather than moving the elements. I <strong>think</strong> something like a suitable element-wise move of a <code>std::tuple&lt;...&gt;</code> can be done but I haven't done it, yet.</p>\n", "LastActivityDate": "2013-09-24T22:37:52.850", "CommentCount": "4", "CreationDate": "2013-09-24T22:37:52.850", "ParentId": "18991910", "Score": "2", "OwnerUserId": "1120273"}});