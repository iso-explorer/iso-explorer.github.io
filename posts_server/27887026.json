post_cb({"bq_ids": {"n4140": {"so_27887026_27887447_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 3913}}, "n3337": {"so_27887026_27887447_0": {"length": 12, "quality": 0.9230769230769231, "section_id": 3773}}}, "27887026": {"ViewCount": "733", "Body": "<p>I got the following discrepancy between compiling as 'C' vs. compiling as 'C++'</p>\n<pre><code>struct A {\n  int x;\n  int y;\n};\n\nstruct A get() {\n  return {0};      \n}\n</code></pre>\n<p>When compiling as 'C++' everything goes fine.\nHowever, when compiling as 'C'; i am getting:</p>\n<p>error : expected expression</p>\n<p>which i can fix by doing: </p>\n<pre><code>return (struct A){0};      \n</code></pre>\n<p>However, i wonder where the difference comes from. Can any one point in the language reference where this difference comes from?</p>\n", "AcceptedAnswerId": "27887447", "Title": "return {0} from a function in C?", "CreationDate": "2015-01-11T12:27:06.757", "Id": "27887026", "CommentCount": "6", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2015-01-11T13:14:59.923", "LastEditorUserId": "2696576", "LastActivityDate": "2015-01-11T13:22:19.533", "Score": "15", "OwnerUserId": "582782", "Tags": "<c++><c><compiler-errors><type-conversion>", "AnswerCount": "1"}, "27887447": {"PostTypeId": "2", "Body": "<p>The two use completely different mechanisms, one of which is C++11-specific, the other of which is C99-specific.</p>\n<p>The first bit,</p>\n<pre><code>struct A get() {\n  return {0};\n}\n</code></pre>\n<p>depends on [stmt.return] (6.6.3 (2)) in C++11, which says</p>\n<blockquote>\n<p id=\"so_27887026_27887447_0\">(...) A return statement with a <em>braced-init-list</em> initializes the object or reference to be returned from the function by copy-list-initialization from the specified initializer list. [ <em>Example:</em></p>\n<pre><code>std::pair&lt;std::string,int&gt; f(const char *p, int x) {\n  return {p,x};\n}\n</code></pre>\n<p id=\"so_27887026_27887447_1\">-- <em>end example</em> ]</p>\n</blockquote>\n<p>This passage does not exist in C (nor C++ before C++11), so the C compiler cannot handle it.</p>\n<p>On the other hand,</p>\n<pre><code>struct A get() {\n  return (struct A){0};\n}\n</code></pre>\n<p>uses a C99 feature called \"compound literals\" that does not exist in C++ (although some C++ compilers, notably gcc, provide it as a language extension; gcc warns about it with -pedantic). The semantics are described in detail in section 6.5.2.5 of the C99 standard; the money quote is</p>\n<blockquote>\n<p id=\"so_27887026_27887447_2\">4 A postfix expression that consists of a parenthesized type name followed by a brace-enclosed list of initializers is a <em>compound literal</em>. It provides an unnamed object whose value is given by the initializer list. (footnote 80)</p>\n<p id=\"so_27887026_27887447_3\">80) Note that this differs from a cast expression. For example, a cast specifies a conversion to scalar types or <code>void</code> only, and the result of a cast expression is not an lvalue.</p>\n</blockquote>\n<p>So in this case <code>(struct A){0}</code> is an unnamed object that is copied into the return value and returned. (note that modern compilers will elide this copy, so you do not have to fear runtime overhead from it)</p>\n<p>And there you  have it, chapters and verses. Why these features exist the way they do in their respective languages may prove to be a fascinating discussion, but I fear that it is difficult for anyone outside the respective standardization committees to give an authoritative answer to the question. Both features were introduced after C and C++ split ways, and they're not developed side by side (nor would it make sense to do so). Divergence is inevitable even in small things.</p>\n", "LastActivityDate": "2015-01-11T13:11:25.943", "Id": "27887447", "CommentCount": "5", "CreationDate": "2015-01-11T13:11:25.943", "ParentId": "27887026", "Score": "24", "OwnerUserId": "4301306"}});