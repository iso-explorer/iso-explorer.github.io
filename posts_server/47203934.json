post_cb({"47204114": {"ParentId": "47203934", "CommentCount": "0", "CreationDate": "2017-11-09T14:17:20.507", "OwnerUserId": "1812788", "PostTypeId": "2", "Id": "47204114", "Score": "1", "Body": "<p>It won\u2019t work with <code>std::hash</code>:</p>\n<blockquote>\n<p id=\"so_47203934_47204114_0\">The actual hash functions are implementation-dependent and are not required to fulfill any other quality criteria except those specified above. Notably, some implementations use trivial (identity) hash functions which map an integer to itself. In other words, these hash functions are designed to work with unordered associative containers, but not as cryptographic hashes, for example.</p>\n</blockquote>\n<p><a href=\"http://en.cppreference.com/w/cpp/utility/hash\" rel=\"nofollow noreferrer\">http://en.cppreference.com/w/cpp/utility/hash</a></p>\n", "LastActivityDate": "2017-11-09T14:17:20.507"}, "47203934": {"CommentCount": "3", "ViewCount": "73", "PostTypeId": "1", "LastEditorUserId": "8914046", "CreationDate": "2017-11-09T14:08:57.583", "LastActivityDate": "2017-11-09T19:40:51.700", "Title": "c++ hash<string> is there a way to get the same value in linux and windows", "LastEditDate": "2017-11-09T14:15:16.770", "Id": "47203934", "Score": "3", "Body": "<p>I try to find a way to get the same result when I hash a given string in windows and in linux.\nbut for example if I run the following code:</p>\n<pre><code>hash&lt;string&gt; h;\ncout &lt;&lt; h(\"hello\");\n</code></pre>\n<p>it will return 3305111549 in windows and 2762169579135187400 in linux.</p>\n<p>If it is not possible to get the same return value accross these 2 platforms, is there any other decent hash function that would return the same value on both systems?</p>\n", "Tags": "<c++><hash>", "OwnerUserId": "8914046", "AnswerCount": "4"}, "47204428": {"ParentId": "47203934", "CommentCount": "0", "CreationDate": "2017-11-09T14:32:01.650", "OwnerUserId": "8157187", "PostTypeId": "2", "Id": "47204428", "Score": "2", "Body": "<p>Not only you cannot depend on hash values among different platforms, but the standard doesn't guarantee that the hash value will be the same among different runs of the same program. It only guarantees that the value will be the same during the same run.</p>\n<p>This is the <strong>only</strong> requirement the C++14 standard poses for the returned value (beside that it's type should be <code>std::size_t</code>) (17.6.3.4):</p>\n<blockquote>\n<p id=\"so_47203934_47204428_0\"><strong>The value returned shall depend only on the argument <code>k</code> for the\n  duration of the program. [ Note: Thus all evaluations of the\n  expression <code>h(k)</code> with the same value for k yield the same result for a\n  given execution of the program. \u2014 end note ]</strong>\n  [ Note: For two di\ufb00erent values t1 and t2, the probability that h(t1) and &gt; h(t2) compare equal should be very small, approaching 1.0 /\n  numeric_limits::max(). \u2014 end note ]</p>\n</blockquote>\n<p>(where <code>h</code> is a hash functor, <code>k</code> is the key)</p>\n<p>If you want to have the same value, then use a well-known hash algorithm, like <a href=\"https://github.com/aappleby/smhasher/wiki/MurmurHash3\" rel=\"nofollow noreferrer\">MurmurHash3</a>.</p>\n", "LastActivityDate": "2017-11-09T14:32:01.650"}, "47204130": {"ParentId": "47203934", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2017-11-09T14:17:59.643", "Score": "3", "LastEditorUserId": "8202288", "LastEditDate": "2017-11-09T19:40:51.700", "Id": "47204130", "OwnerUserId": "8202288", "Body": "<p>No. As per <a href=\"http://en.cppreference.com/w/cpp/utility/hash\" rel=\"nofollow noreferrer\">std::hash</a> reference, emphasis mine:</p>\n<blockquote>\n<p id=\"so_47203934_47204130_0\">The actual hash functions are <strong>implementation-dependent</strong> and are not\n  required to fulfill any other quality criteria except those specified\n  above.</p>\n</blockquote>\n<p>More specifically you are using the <a href=\"http://en.cppreference.com/w/cpp/string/basic_string/hash\" rel=\"nofollow noreferrer\">std::hash&lt;std::string&gt; </a> template specialization whose hashes:</p>\n<blockquote>\n<p id=\"so_47203934_47204130_1\">equal the hashes of corresponding <strong>std::basic_string_view</strong> classes</p>\n</blockquote>\n<p>which are also implementation dependent. So no, you can not expect the same <code>std::hash</code> results with different implementations. Furthermore since C++14:</p>\n<blockquote>\n<p id=\"so_47203934_47204130_2\">Hash functions are only required to produce the same result for the\n  same input within a single execution of a program;</p>\n</blockquote>\n", "LastActivityDate": "2017-11-09T19:40:51.700"}, "47204346": {"ParentId": "47203934", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2017-11-09T14:27:45.090", "Score": "1", "LastEditorUserId": "1621391", "LastEditDate": "2017-11-09T14:46:54.183", "Id": "47204346", "OwnerUserId": "1621391", "Body": "<blockquote>\n<p id=\"so_47203934_47204346_0\">I try to find a way to get the same result when I hash a given string\n  in windows and in linux. but for example if I run the following code:</p>\n<pre><code>hash&lt;string&gt; h;\ncout &lt;&lt; h(\"hello\");\n</code></pre>\n<p id=\"so_47203934_47204346_1\">it will return 3305111549 in windows and 2762169579135187400 in linux.</p>\n</blockquote>\n<p>The results are correct. As mentioned in other answers, the C++ standard doesn't even guarantee that the values will be the same between various execution of the same program.</p>\n<blockquote>\n<p id=\"so_47203934_47204346_2\">If it is not possible to get the same return value accross these 2\n  platforms, is there any other decent hash function that would return\n  the same value on both systems?</p>\n</blockquote>\n<p><strong>Yes!</strong>. You may want to check out <a href=\"https://softwareengineering.stackexchange.com/questions/49550/which-hashing-algorithm-is-best-for-uniqueness-and-speed\">Best hashing algorithms for speed and uniqueness</a> for a list of good hash functions to implement.</p>\n<p><strong>However,</strong> after you select the one you want to use, you need one more extra guarantee: that the underlaying representations of characters are the same between the two platforms. That is that the numerical representations of <code>'a'</code> in platform 1 is same as <code>'a'</code> in platform 2. If one platform uses ASCII and the other uses a different encoding scheme, you aren't likely to get the same results.</p>\n<hr>\n<p>Again, <code>std::hash&lt;&gt;</code> already has a <em>specialization</em> for <code>std::hash&lt;std::string&gt;</code>. So, other than your standard library's provision, there's nothing you can do about enforcing a behavior for the result of <code>std::hash&lt;std::string&gt;()(\"hello\")</code>. Your option is to use:</p>\n<ul>\n<li>a custom hash function-object, e.g <code>myNAMESPACE::hash&lt;std::string&gt;()(\"hello\")</code>, or </li>\n<li>use a custom string type, and specialize it for <code>std::hash</code>; e.g <code>std::hash&lt;MyString&gt;()(\"hello\")</code></li>\n</ul>\n</hr>", "LastActivityDate": "2017-11-09T14:46:54.183"}, "bq_ids": {"n4140": {"so_47203934_47204428_0": {"section_id": 6288, "quality": 0.7222222222222222, "length": 26}}, "n3337": {"so_47203934_47204428_0": {"section_id": 6048, "quality": 0.6388888888888888, "length": 23}}, "n4659": {"so_47203934_47204428_0": {"section_id": 7795, "quality": 0.7222222222222222, "length": 26}}}});