post_cb({"18659520": {"ParentId": "18659427", "CommentCount": "16", "CreationDate": "2013-09-06T13:53:17.987", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "18659520", "Score": "5", "Body": "<p>You're wrong in your third bullet point (and maybe first one too).</p>\n<p>You state \"The line <code>float g = *f;</code> doesn't break the rules for just the same reason.\", where \"just the same reason\" (a little vague) seems to refer to \"accessing through its original type\". But that's not what you're doing. You're accessing an <code>int32_t</code> (named <code>a</code>) through an lvalue of type <code>float</code> (obtained from the expression <code>*f</code>). So you're violating the standard.</p>\n<p>I also believe (but less sure on this one) that storing a value is an access to (that) stored value, so even <code>*f = 1.0f;</code> violates the rules.</p>\n", "LastActivityDate": "2013-09-06T13:53:17.987"}, "31539561": {"ParentId": "18659427", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2015-07-21T12:52:17.670", "Score": "0", "LastEditorUserId": "-1", "LastEditDate": "2017-05-23T11:52:23.417", "Id": "31539561", "OwnerUserId": "146041", "Body": "<p>I've learned the hard way that quoting 6.5.7 from the C99 standard is unhelpful without also looking at 6.5.6. See <a href=\"https://stackoverflow.com/a/31536900/146041\">this answer</a> for the relevant quotes.</p>\n<p>6.5.6 makes it clear that the type of an object can, under certain circumstances, change many times during its lifetime. It can take on the type of the value that was most recently <em>written</em> to it. This is really useful.</p>\n<p>We need to draw a distinction between \"declared type\" and \"effective type\". A local variable, or static global, has a declared type. You are stuck with that type, I think, for the lifetime of that object. You may <em>read</em> from the object using a <code>char *</code>, but the \"effective type\" doesn't change unfortunately.</p>\n<p>But the memory returned by <code>malloc</code> has \"no declared type\". This will remain true until it is <code>free</code>d. It will never have a declared type, but it's effective type can change according to 6.5.6, always taking on the type of the most recent write.</p>\n<p>So, this is legal:</p>\n<pre><code>int main() {\n    void * vp = malloc(sizeof(int)+sizeof(float)); // it's big enough,\n                    //  and malloc will look after alignment for us.\n    int32_t *ap = vp;\n    *ap = 5;      // make int32_t the 'effective type'\n    float* f = vp;\n    *f = 1.0f;    // this (legally) changes the effective type.\n\n    // int32_t b = *ap;   // Not defined, because the\n                          // effective type is wrong\n    float g = *f;    // OK, because the effective type is (currently) correct.\n}\n</code></pre>\n<p>So, basically, writing to a <code>malloc</code>-ed space is a valid way to change its type. But I guess that doesn't give us a way to look at the pre-existing through the \"lens\" of a new type, which might be interesting; it's impossible unless, I think, we use the various <code>char*</code> exceptions to peek at data of the \"wrong\" type.</p>\n", "LastActivityDate": "2015-07-21T12:52:17.670"}, "18664954": {"ParentId": "18659427", "CommentCount": "2", "CreationDate": "2013-09-06T19:12:49.187", "OwnerUserId": "365496", "PostTypeId": "2", "Id": "18664954", "Score": "1", "Body": "<p>There are some significant ambiguities in the specification of object lifetime and access, but here are some problems with the code according to my reading of the spec.</p>\n<pre><code>float* f = (float*)(&amp;a);\n</code></pre>\n<p>This performs a <code>reinterpret_cast</code> and as long as <code>float</code> does not require stricter alignment than <code>int32_t</code> then you can cast the resulting value back to an <code>int32_t*</code> and you will get the original pointer. Using the result is not otherwise defined in any case.</p>\n<pre><code>*f = 1.0f;\n</code></pre>\n<p>Assuming <code>*f</code> aliases with <code>a</code> (and that the storage for an <code>int32_t</code> has the appropriate alignment and size for a <code>float</code>) then the above line ends the lifetime of the <code>int32_t</code> object and places a <code>float</code> object in its place:</p>\n<blockquote>\n<p id=\"so_18659427_18664954_0\">The lifetime of an object of type T begins when: storage with the proper alignment and size for type T is obtained, and if the object has non-trivial initialization, its initialization is complete.</p>\n<p id=\"so_18659427_18664954_1\">The lifetime of an object of type T ends when: [...] the storage which the object occupies is reused or released.</p>\n<p id=\"so_18659427_18664954_2\"><em>\u20143.8 Object lifetime [basic.life]/1</em></p>\n</blockquote>\n<p>We're reusing the storage, but if <code>int32_t</code> has the same size and alignment requirements then it seems like a <code>float</code> always existed in the same place (since the storage was 'obtained'). Perhaps we can avoid this ambiguity by changing this line to <code>new (f) float {1.0f};</code>, so we know that the <code>float</code> object has a lifetime that began at or before the completion of the initialization.</p>\n<p>Additionally, 'access' does not necessarily just mean 'read'. It can mean both reads and writes. So the write performed by <code>*f = 1.0f;</code> could be considered 'accessing the stored value' by writing over it, in which case this is also an aliasing violation.</p>\n<p>So now assuming that a float object exists and the <code>int32_t</code> object's lifetime has ended:</p>\n<pre><code>int32_t b = a;\n</code></pre>\n<p>This code accesses the stored value of a <code>float</code> object through a glvalue with type <code>int32_t</code>, and is clearly an aliasing violation. The program has undefined behavior under 3.10/10.</p>\n<pre><code>float g = *f;\n</code></pre>\n<p>Assuming that <code>int32_t</code> has the right alignment and size requirements, and that the pointer <code>f</code> has been obtained in a way that allows its use to be well defined, then this should legally access the <code>float</code> object that was initialized with <code>1.0f</code>.</p>\n", "LastActivityDate": "2013-09-06T19:12:49.187"}, "18659979": {"ParentId": "18659427", "CommentCount": "0", "CreationDate": "2013-09-06T14:17:47.760", "OwnerUserId": "951890", "PostTypeId": "2", "Id": "18659979", "Score": "2", "Body": "<p>I think this statement is incorrect:</p>\n<blockquote>\n<p id=\"so_18659427_18659979_0\">The line int32_t b = a; doesn't violate the rules because I am accessing through its original type.</p>\n</blockquote>\n<p>The object that is stored at location <code>&amp;a</code> is now a float, so you are attempting to access the stored value of a float through an lvalue of the wrong type.</p>\n", "LastActivityDate": "2013-09-06T14:17:47.760"}, "bq_ids": {"n4140": {"so_18659427_18659427_0": {"section_id": 7239, "quality": 0.7777777777777778, "length": 14}, "so_18659427_18664954_0": {"section_id": 7189, "quality": 0.9444444444444444, "length": 17}, "so_18659427_18664954_1": {"section_id": 7189, "quality": 0.9090909090909091, "length": 10}}, "n3337": {"so_18659427_18659427_0": {"section_id": 6983, "quality": 0.7777777777777778, "length": 14}, "so_18659427_18664954_0": {"section_id": 6933, "quality": 0.9444444444444444, "length": 17}, "so_18659427_18664954_1": {"section_id": 6933, "quality": 0.9090909090909091, "length": 10}}, "n4659": {"so_18659427_18659427_0": {"section_id": 8748, "quality": 0.7777777777777778, "length": 14}, "so_18659427_18664954_0": {"section_id": 8697, "quality": 0.8888888888888888, "length": 16}, "so_18659427_18664954_1": {"section_id": 8697, "quality": 0.8181818181818182, "length": 9}}}, "18659427": {"CommentCount": "7", "ViewCount": "423", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2013-09-06T13:48:49.750", "LastActivityDate": "2015-07-21T12:52:17.670", "Title": "C/C++ strict aliasing, object lifetime and modern compilers", "FavoriteCount": "2", "LastEditDate": "2017-05-23T12:31:21.340", "Id": "18659427", "Score": "8", "Body": "<p>I am facing confusion about the C++ strict-aliasing rule and its possible implications. Consider the following code:<br/></p>\n<pre><code>int main() {\n  int32_t a = 5;\n  float* f = (float*)(&amp;a);\n  *f = 1.0f;\n\n  int32_t b = a;   // Probably not well-defined?\n  float g = *f;    // What about this?\n}\n</code></pre>\n<p>Looking at the C++ specs, section 3.10.10, technically none of the given code seems to violate the \"aliasing-rules\" given there:</p>\n<blockquote>\n<p id=\"so_18659427_18659427_0\">If a program attempts to access the stored value of an object through an lvalue of other than one of the following types the behavior is unde\ufb01ned:<br>\n  ... a list of qualified accessor types ...</br></p>\n</blockquote>\n<ul>\n<li><code>*f = 1.0f;</code> doesn't break the rules because there is no access to a <em>stored value</em>, i.e. I am just writing to memory through a pointer. I'm not reading from memory or trying to interpret a value here.</li>\n<li>The line <code>int32_t b = a;</code> doesn't violate the rules because I am accessing through its original type.</li>\n<li>The line <code>float g = *f;</code> doesn't break the rules for just the same reason.</li>\n</ul>\n<p>In <a href=\"https://stackoverflow.com/questions/18624449/shared-memory-buffers-in-c-without-violating-strict-aliasing-rules\">another thread</a>, member CortAmmon actually makes the same point in a response, and adding that any possible undefined behavior arising through writes to <em>alive objects</em>, as in  <code>*f = 1.0f;</code>, would be accounted for by the standard's definition of \"object lifetime\" (which seem to be trivial for POD types).<br/></p>\n<p>HOWEVER: There is <em>plenty</em> of evidence on the internet that above code will produce UB on modern compilers. See <a href=\"http://www.mail-archive.com/linux-btrfs@vger.kernel.org/msg01647.html\" rel=\"nofollow noreferrer\">here</a> and <a href=\"http://cellperformance.beyond3d.com/articles/2006/06/understanding-strict-aliasing.html\" rel=\"nofollow noreferrer\">here</a> for example.<br>\nThe argumentation in most cases is that the compiler is free to consider <code>&amp;a</code> and <code>f</code> as not aliasing each other and therefore free to reschedule instructions.<br/></br></p>\n<p>The big question now is if such compiler behavior would actually be an \"over-interpretation\" of the standard.<br>\nThe only time the standard talks about \"aliasing\" specifically is in a footnote to 3.10.10 where it makes clear that those are the rules that shall govern aliasing.<br>\nAs I mentioned earlier, I do not see the any of the above code violating the standard, yet it would be believed illegal by a large number of people (and possibly compiler people).<br/></br></br></p>\n<p>I would really really appreciate some clarification here.<br/></p>\n<p>Small Update:<br>\nAs member BenVoigt pointed out correctly, <code>int32_t</code> may not align with <code>float</code> on some platforms so the given code may be in violation of the \"storage of sufficient alignment and size\" rule. I would like to state that <code>int32_t</code> was chosen intentionally to align with <code>float</code> on most platforms and that the assumption for this question is that the types do indeed align.<br/></br></p>\n<p>Small Update #2:<br>\nAs several members have pointed out, the line <code>int32_t b = a;</code> is probably in violation of the standard, although not with absolute certainty. I agree with that standpoint and, not changing any aspect of the question, ask readers to exclude that line from my statement above that none of the code is in violation of the standard.</br></p>\n", "Tags": "<c++><memory><compiler-construction><strict-aliasing><type-punning>", "OwnerUserId": "1232524", "AnswerCount": "4"}});