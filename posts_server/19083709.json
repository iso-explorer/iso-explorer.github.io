post_cb({"bq_ids": {"n4140": {"so_19083709_19083981_3": {"length": 29, "quality": 0.8055555555555556, "section_id": 39}, "so_19083709_19083981_4": {"length": 15, "quality": 0.9375, "section_id": 624}, "so_19083709_19083981_5": {"length": 12, "quality": 1.0, "section_id": 638}, "so_19083709_19083981_1": {"length": 36, "quality": 1.0, "section_id": 297}, "so_19083709_19083981_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 2515}, "so_19083709_19083981_0": {"length": 12, "quality": 1.0, "section_id": 601}}, "n3337": {"so_19083709_19083981_3": {"length": 35, "quality": 0.9722222222222222, "section_id": 36}, "so_19083709_19083981_4": {"length": 15, "quality": 0.9375, "section_id": 614}, "so_19083709_19083981_5": {"length": 12, "quality": 1.0, "section_id": 628}, "so_19083709_19083981_1": {"length": 36, "quality": 1.0, "section_id": 288}, "so_19083709_19083981_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 6460}, "so_19083709_19083981_0": {"length": 12, "quality": 1.0, "section_id": 591}}, "n4659": {"so_19083709_19083981_3": {"length": 29, "quality": 0.8055555555555556, "section_id": 39}, "so_19083709_19083981_4": {"length": 15, "quality": 0.9375, "section_id": 650}, "so_19083709_19083981_5": {"length": 12, "quality": 1.0, "section_id": 666}, "so_19083709_19083981_1": {"length": 36, "quality": 1.0, "section_id": 304}, "so_19083709_19083981_2": {"length": 6, "quality": 0.6666666666666666, "section_id": 3249}, "so_19083709_19083981_0": {"length": 12, "quality": 1.0, "section_id": 627}}}, "19083981": {"Id": "19083981", "PostTypeId": "2", "Body": "<p>Numbering those four overloads for reference:</p>\n<pre><code>template&lt;typename T&gt;\nint Bar(T*, typename T::DummyType* = 0);             // #1\n\ntemplate&lt;typename T&gt;\nint Bar(T*, ...);                                    // #2\n\ntemplate&lt;typename T&gt;\nint Bar(typename T::DummyType* = 0);                 // #3\n\ntemplate&lt;typename T&gt;\nint Bar(...);                                        // #4\n</code></pre>\n<hr>\n<p>As per [temp.deduct.type]/5, <code>typename T::DummyType</code> is a non-deduced context for <code>T</code>. I.e., the parameter <code>typename T::DummyType* dummy_</code> cannot be used to deduce <code>T</code>. Therefore, for the first two calls</p>\n<pre><code>Bar((Foo*)NULL);\nBar((int*)NULL);\n</code></pre>\n<p><code>T</code> can be deduced for the first two overloads, but not for the second two. This is why overloads #3 and #4 are not viable for these calls. After this deduction, every occurrence of <code>T</code> in the function signature will be substituted with the deduced type. This can result in a substitution failure, see call 2 below.</p>\n<hr>\n<p>For the first call, the following two overloads are viable:</p>\n<pre><code>/*substituted template*/\nint Bar&lt;Foo&gt;(Foo*, Foo::DummyType* = 0);             // #1\n\n/*substituted template*/\nint Bar&lt;Foo&gt;(Foo*, ...);                             // #2\n</code></pre>\n<p>As per [over.match.viable]/2, the default arguments are ignored for overload resolution:</p>\n<blockquote>\n<p id=\"so_19083709_19083981_0\">First, to be a viable function, a candidate function shall have enough parameters to agree in number with the arguments in the list.</p>\n<ul>\n<li>If there are <em>m</em> arguments in the list, all candidate functions having exactly <em>m</em> parameters are viable.</li>\n<li>A candidate function having fewer than <em>m</em> parameters is viable only if it has an ellipsis in its parameter list (8.3.5). For the purposes of overload resolution, any argument for which there is no corresponding parameter is considered to \u201cmatch the ellipsis\u201d (13.3.3.1.3).</li>\n<li>A candidate function having more than <em>m</em> parameters is viable only if the <em>(m+1)</em>-st parameter has a default argument (8.3.6). For the purposes of overload resolution, the parameter list is truncated on the right, so that there are exactly <em>m</em> parameters.</li>\n</ul>\n</blockquote>\n<p>So, we actually compare those two signatures here:</p>\n<pre><code>/*substituted template*/\nint Bar&lt;Foo&gt;(Foo*);                                 // #1\n\n/*substituted template*/\nint Bar&lt;Foo&gt;(Foo*);                                 // #2\n</code></pre>\n<p>These two rank as Exact Matches and therefore are ambiguous.</p>\n<hr>\n<p>For the second call, we have a substitution failure for the first overload (see below), so it's not in the list of viable functions. Only one overload remains viable:</p>\n<pre><code>/*substituted template*/\nint Bar&lt;int&gt;(int*);                                 // #2\n</code></pre>\n<p>Substitution failure:</p>\n<p>For the second call <code>Bar((int*)NULL);</code>, the substitution of <code>T</code> for <code>int</code> results in a substitution failure in the first overload [temp.deduct]/5:</p>\n<blockquote>\n<p id=\"so_19083709_19083981_1\">When all template arguments have been deduced or obtained from default template arguments, all uses of template parameters in the template parameter list of the template and the function type are replaced with the corresponding deduced or default argument values. If the substitution results in an invalid type, as described above, type deduction fails.</p>\n</blockquote>\n<p>The invalid type here is <code>int::DummyType</code>.</p>\n<hr>\n<p>For the third and fourth call, only the last two overloads are viable (because of the number of arguments). The rest is similar to the first two overloads.</p>\n<p>The third call has to select from the overloads</p>\n<pre><code>/*substituted template*/\nint Bar&lt;Foo&gt;(Foo::DummyType* = 0);                   // #3\n\n/*substituted template*/\nint Bar&lt;Foo&gt;(...);                                   // #4\n</code></pre>\n<p>which is ambiguous like the first call.</p>\n<hr>\n<p>For the fourth call, the third overload results in a substitution failure, and only the fourth overload remains viable (and is selected unambiguously).</p>\n<hr>\n<h2>Follow-up question.</h2>\n<p>First call: <code>Bar0((Foo*)NULL, NULL)</code></p>\n<p>Overloads:</p>\n<pre><code>// Bar0 #0\ntemplate&lt;typename T&gt;\nstatic int Bar0(const T* foo, typename T::DummyType* dummy_);\n\n// Bar0 #1\ntemplate&lt;typename T&gt;\nstatic int Bar0(const T* foo, ...);\n</code></pre>\n<p>In <code>Bar0</code> #0, <code>T</code> is again in an non-deduced context, therefore only the first argument is used for deduction. The substituted template signatures look like:</p>\n<pre><code>// substituted template\nstatic int Bar0&lt;Foo&gt;(const Foo*, Foo::DummyType*);  // #0\n\n// substituted template\nstatic int Bar0&lt;Foo&gt;(const Foo* foo, ...);          // #1\n</code></pre>\n<p>The definition of <code>NULL</code> now becomes somewhat relevant:</p>\n<p>[support.types]/3</p>\n<blockquote>\n<p id=\"so_19083709_19083981_2\">The macro <code>NULL</code> is an implementation-defined C++ null pointer constant in this International Standard.</p>\n</blockquote>\n<p>[conv.ptr]/1</p>\n<blockquote>\n<p id=\"so_19083709_19083981_3\">A <em>null pointer constant</em> is an integral constant expression (5.19) prvalue of integer type that evaluates to zero or a prvalue of type <code>std::nullptr_t</code>. A null pointer constant can be converted to a pointer type; the result is the <em>null pointer value</em> of that type and is distinguishable from every other value of object pointer or function pointer type.</p>\n</blockquote>\n<p>The exact type of <code>NULL</code> isn't specified (one more reason to use <code>nullptr</code> instead!). But we know it's convertable to <code>Foo::DummyType*</code>. This conversion is a <em>standard conversion</em>. Matching <code>NULL</code> with the ellipsis is a so-called <em>ellipsis conversion</em>; it's not really a conversion, only in terms of overload resolution [over.ics.ellipsis]/1:</p>\n<blockquote>\n<p id=\"so_19083709_19083981_4\">An ellipsis conversion sequence occurs when an argument in a function call is matched with the ellipsis parameter specification of the function called (see 5.2.2).</p>\n</blockquote>\n<p>Now, the two overloads are viable and have to be ranked. Fortunately, this is simple here [over.ics.rank]/2</p>\n<blockquote>\n<p id=\"so_19083709_19083981_5\">a standard conversion sequence is a better conversion sequence than a user-defined conversion sequence or an ellipsis conversion sequence</p>\n</blockquote>\n<p>Therefore, the conversion sequence <em>type of <code>NULL</code></em> to <code>Foo::DummyType*</code>, as required for the overload #0, is the better conversion sequence, when compared to the ellipsis conversion sequence for matching <code>NULL</code> with the <code>...</code> of overload #2.</p>\n<p>[over.match.best] now specifies that the function selected is the one with the best conversion sequence. Therefore, overload #0 is unambiguously selected.</p>\n<hr>\n<p>Second call: <code>Bar1((Foo*)NULL, NULL)</code></p>\n<p>Overloads:</p>\n<pre><code>// Bar1 #2\ntemplate&lt;typename T&gt;\nstatic int Bar1(const T*, DummyType2&lt;T, typename T::DummyType&gt;*);\n\n// Bar1 #3\ntemplate&lt;typename T&gt;\nstatic int Bar1(const T*, ...);\n</code></pre>\n<p>Here, the important part is the <code>T</code> in <code>DummyType2&lt;T, ..&gt;</code>. It is <em>not</em> in a non-deduced context. Therefore, the compiler tries deduce <code>T</code> from the first <em>and</em> the second argument. As the second argument in the call has some unspecified integral or <code>std::nullptr_t</code> type, type deduction fails for overload <code>Bar1</code> #2. Overload <code>Bar1</code> #3 remains viable and is unambiguously selected.</p>\n<p>If you however change overload <code>Bar1</code> #2 to:</p>\n<pre><code>// Bar1 #2\ntemplate&lt;typename T&gt;\nstatic int Bar1(const T*, DummyType2&lt;int, typename T::DummyType&gt;*);\n</code></pre>\n<p>Then <code>T</code> is deduced only from the first argument, and this overload is preferred &amp; selected (for the same reason as in the first call of the follow-up question).</p>\n<p>You could also (instead of changing the overload) change the second call to:</p>\n<pre><code>Bar1((Foo*)NULL, (DummyType2&lt;Foo, int&gt;*)NULL)\n</code></pre>\n<p>This way, <code>T</code> can be unambiguously deduced to <code>Foo</code>, and the overload <code>Bar1</code> #2 is selected.</p>\n</hr></hr></hr></hr></hr></hr></hr>", "LastEditorUserId": "420683", "LastActivityDate": "2013-09-30T23:39:26.947", "Score": "1", "CreationDate": "2013-09-29T22:20:17.153", "ParentId": "19083709", "CommentCount": "2", "OwnerUserId": "420683", "LastEditDate": "2013-09-30T23:39:26.947"}, "19083709": {"ViewCount": "605", "Body": "<p>Compiling following code in VS2012 without any problem.</p>\n<pre><code>struct Foo\n{\n    typedef int DummyType;\n};\n\ntemplate&lt;typename T&gt;\nint Bar(T* foo, typename T::DummyType* dummy_ = 0) { return 0; }\n\ntemplate&lt;typename T&gt;\nint Bar(T* foo, ...) { return 1; }\n\ntemplate&lt;typename T&gt;\nint Bar(typename T::DummyType* dummy_ = 0) { return 2; }\n\ntemplate&lt;typename T&gt;\nint Bar(...) { return 3; }\n\n\nvoid fn()\n{\n    Bar((Foo*)NULL);\n    Bar((int*)NULL);\n\n    Bar&lt;Foo&gt;();\n    Bar&lt;int&gt;();\n}\n</code></pre>\n<p>But trying VS2013RC got following errors. Is this a VS2013RC bug or problem with the code itself. What the standard says about match overload function with template function specialization and variadic functions.</p>\n<pre><code>1&gt;c:\\users\\dummy\\documents\\visual studio 2013\\projects\\test\\test.cpp(25): error C2668: 'Bar' : ambiguous call to overloaded function\n1&gt;          c:\\users\\dummy\\documents\\visual studio 2013\\projects\\test\\test.cpp(15): could be 'int Bar&lt;Foo&gt;(T *,...)'\n1&gt;          with\n1&gt;          [\n1&gt;              T=Foo\n1&gt;          ]\n1&gt;          c:\\users\\dummy\\documents\\visual studio 2013\\projects\\test\\test.cpp(12): or       'int Bar&lt;Foo&gt;(T *,Foo::DummyType *)'\n1&gt;          with\n1&gt;          [\n1&gt;              T=Foo\n1&gt;          ]\n1&gt;          while trying to match the argument list '(Foo *)'\n1&gt;c:\\users\\dummy\\documents\\visual studio 2013\\projects\\test\\test.cpp(28): error C2668: 'Bar' : ambiguous call to overloaded function\n1&gt;          c:\\users\\dummy\\documents\\visual studio 2013\\projects\\test\\test.cpp(21): could be 'int Bar&lt;Foo&gt;(...)'\n1&gt;          c:\\users\\dummy\\documents\\visual studio 2013\\projects\\test\\test.cpp(18): or       'int Bar&lt;Foo&gt;(Foo::DummyType *)'\n1&gt;          while trying to match the argument list '()'\n</code></pre>\n<p>Thanks for any help!</p>\n<hr>\n<p>Thanks for the answer!</p>\n<p>I just made a new test as follow:</p>\n<pre><code>struct Foo\n{\n    typedef int DummyType;\n};\n\n// Bar0 #0\ntemplate&lt;typename T&gt;\nstatic int Bar0(const T* foo, typename T::DummyType* dummy_) { return 0; }\n\n// Bar0 #1\ntemplate&lt;typename T&gt;\nstatic int Bar0(const T* foo, ...) { return 1; }\n\n\ntemplate&lt;typename T, typename U&gt;\nstruct DummyType2 {};\n\n// Bar1 #2\ntemplate&lt;typename T&gt;\nstatic int Bar1(const T* foo, DummyType2&lt;T, typename T::DummyType&gt;* dummy_) { return 2; }\n\n// Bar1 #3\ntemplate&lt;typename T&gt;\nstatic int Bar1(const T* foo, ...) { return 3; }\n\nvoid fn()\n{\n\n    std::cout&lt;&lt;Bar0((Foo*)NULL, NULL)&lt;&lt;std::endl;   // call 0 matches Bar0 #0\n\n    std::cout&lt;&lt;Bar1((Foo*)NULL, NULL)&lt;&lt;std::endl;   // call 1 matches Bar1 #3\n}\n</code></pre>\n<p>the output is</p>\n<pre><code>0\n3\n</code></pre>\n<p>What is the reason call 0 matches Bar0 #0, but call 1 matches Bar1 #3. Any rules from standard?</p>\n</hr>", "AcceptedAnswerId": "19083981", "Title": "Overload resolution of function templates in VS2013 RC", "CreationDate": "2013-09-29T21:51:15.247", "Id": "19083709", "CommentCount": "0", "LastEditDate": "2013-09-30T23:07:25.603", "PostTypeId": "1", "LastEditorUserId": "528686", "LastActivityDate": "2015-03-10T11:23:33.433", "Score": "0", "OwnerUserId": "528686", "Tags": "<c++><templates><ambiguous><overload-resolution><visual-studio-2013>", "AnswerCount": "1"}});