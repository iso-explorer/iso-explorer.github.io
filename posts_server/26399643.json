post_cb({"26399816": {"ParentId": "26399643", "PostTypeId": "2", "CommentCount": "8", "Body": "<p>In C++, you can do</p>\n<pre><code>char *b = new char[strlen(a) + 1]{};\nstd::copy(a, a + strlen(a), b);\n</code></pre>\n<p>Here's <a href=\"http://coliru.stacked-crooked.com/a/fefa0c4ca482f9c6\" rel=\"nofollow\">a live example</a>. Although, I'd recommend using <code>std::string</code> for its safety and ease of use.</p>\n", "OwnerUserId": "183120", "LastEditorUserId": "183120", "LastEditDate": "2014-10-16T08:50:42.290", "Id": "26399816", "Score": "5", "CreationDate": "2014-10-16T08:39:16.427", "LastActivityDate": "2014-10-16T08:50:42.290"}, "26399643": {"CommentCount": "10", "AcceptedAnswerId": "26399816", "PostTypeId": "1", "LastEditorUserId": "2642204", "CreationDate": "2014-10-16T08:30:52.460", "LastActivityDate": "2014-10-16T16:00:21.307", "LastEditDate": "2014-10-16T16:00:21.307", "ViewCount": "3161", "FavoriteCount": "1", "Title": "How to copy contents of the const char* type variable?", "Id": "26399643", "Score": "9", "Body": "<p>I know the difference between:</p>\n<pre><code>char *a = \"string\";\nchar p[] = \"string\";\n</code></pre>\n<p>from <code>*a</code>, it acts as the following...</p>\n<pre><code>     +-----+     +---+---+---+---+---+---+---+ \n  a: |  *======&gt; | s | t | r | i | n | g |\\0 |    \n     +-----+     +---+---+---+---+---+---+---+ \n</code></pre>\n<p>If I want to create another variable say</p>\n<pre><code>char *b;\n</code></pre>\n<p>and I hope it copies all contents in pointer a points to instead of pointing to the a's content.</p>\n<pre><code>     +-----+     +---+---+---+---+---+---+---+      \n  a: |  *======&gt; | s | t | r | i | n | g |\\0 |    \n     +-----+     +---+---+---+---+---+---+---+ \n  b: |  *======&gt; | s | t | r | i | n | g |\\0 |    \n     +-----+     +---+---+---+---+---+---+---+ \n</code></pre>\n<p>How to do this ?</p>\n", "Tags": "<c++><c><pointers>", "OwnerUserId": "1336041", "AnswerCount": "5"}, "26399772": {"ParentId": "26399643", "CommentCount": "0", "Body": "<p>In C, you can allocate a new buffer b, and then copy your string there with standard library functions like this: </p>\n<pre><code>b = malloc((strlen(a) + 1) * sizeof(char));\nstrcpy(b,a);\n</code></pre>\n<p>Note the <code>+1</code> in the <code>malloc</code> to make room for the terminating <code>'\\0'</code>. The <code>sizeof(char)</code> is redundant, but I use it for consistency.</p>\n<p>In C++, you should use the safer and more elegant <code>std::string</code>:</p>\n<pre><code>std::string b {a};\n</code></pre>\n", "OwnerUserId": "3002139", "PostTypeId": "2", "Id": "26399772", "Score": "7", "CreationDate": "2014-10-16T08:37:19.043", "LastActivityDate": "2014-10-16T08:37:19.043"}, "26399769": {"ParentId": "26399643", "CommentCount": "0", "Body": "<p><code>a</code>'s content, as you posted, points to a read-only memory location set up by the compiler. If you want to have another one at compile-time with distinct values you'll have to define one yourself:</p>\n<pre><code>char *a = \"string\";\nchar *b = \"string\"; // Nb. This might point to the same location as a\n</code></pre>\n<p>Notice that according to \u00a72.14.5, whether these two pointers will point or not to the same memory location is <strong>implementation defined</strong></p>\n<blockquote>\n<p id=\"so_26399643_26399769_0\">Whether all string literals are distinct (that is, are stored in nonoverlapping objects) is implementation de\ufb01ned.</p>\n</blockquote>\n<p>Otherwise go for a heap-stored location like:</p>\n<pre><code>size_t len = strlen(a); // Doesn't include null-terminator character\nchar *b = new char[len+1];\nmemcpy(b, a, len); // Assumes plain ASCII string\nb[len] = '\\0';\n</code></pre>\n<p>I would go for <code>std::string</code>s anyway.</p>\n", "OwnerUserId": "1938163", "PostTypeId": "2", "Id": "26399769", "Score": "4", "CreationDate": "2014-10-16T08:37:09.790", "LastActivityDate": "2014-10-16T08:37:09.790"}, "26399848": {"ParentId": "26399643", "CommentCount": "1", "Body": "<p>The contents of <code>a</code> is what you have labelled as <code>*</code> in your diagram.  <code>a</code> is your little box, and the contents of <code>a</code> are what is in the box!</p>\n<p>The \"string\" is NOT the contents of <code>a</code>. It's somewhere else in memory, and <code>a</code> contains the address of that string. </p>\n<p>Copying the contents of <code>a</code> to <code>b</code> would end up doing this:</p>\n<pre><code>   +-----+     +---+---+---+---+---+---+---+      \na: |  *======&gt; | s | t | r | i | n | g |\\0 |    \n   +-----+  /  +---+---+---+---+---+---+---+ \nb: |  *====/\n   +-----+     \n</code></pre>\n<p>To achieve what you have drawn in your second diagram, you need to take a copy of all the data which <code>a</code> is pointing to. This is not straightforward because how do you decide when to stop copying? There's no general way, but if you have predetermined that you just want to copy a string, then you can use a function which copies a string.</p>\n<p>The common but non-standard <code>strdup</code> function will allocate new space and copy a string. Otherwise, you can allocate space (in any of the usual ways of allocating space in C) and then copy the string over to the allocated space.</p>\n", "OwnerUserId": "1505939", "PostTypeId": "2", "Id": "26399848", "Score": "1", "CreationDate": "2014-10-16T08:41:00.110", "LastActivityDate": "2014-10-16T08:41:00.110"}, "bq_ids": {"n4140": {"so_26399643_26399769_0": {"section_id": 5361, "quality": 0.8, "length": 8}}, "n3337": {"so_26399643_26399769_0": {"section_id": 5157, "quality": 0.8, "length": 8}}, "n4659": {"so_26399643_26399769_0": {"section_id": 6789, "quality": 0.8, "length": 8}}}, "26399743": {"ParentId": "26399643", "CommentCount": "0", "Body": "<p>You can use the non-standard (but available on many implementations) <code>strdup</code> function from <code>&lt;string.h&gt;</code>:</p>\n<pre><code>char *b;\nstrdup(b, a);\n...\nfree(b);\n</code></pre>\n<p>or you can reserve space with <code>malloc</code> and then <code>strcpy</code>:</p>\n<pre><code>char *b;\nb = malloc(strlen(a) + 1);\nstrcpy(b, a);\n...\nfree(b);\n</code></pre>\n", "OwnerUserId": "1606345", "PostTypeId": "2", "Id": "26399743", "Score": "1", "CreationDate": "2014-10-16T08:36:05.063", "LastActivityDate": "2014-10-16T08:36:05.063"}});