post_cb({"bq_ids": {"n4140": {"so_17466466_17467393_1": {"length": 23, "quality": 0.9583333333333334, "section_id": 233}}, "n3337": {"so_17466466_17467393_1": {"length": 23, "quality": 0.9583333333333334, "section_id": 226}}, "n4659": {"so_17466466_17467393_1": {"length": 23, "quality": 0.9583333333333334, "section_id": 243}}}, "17466466": {"ViewCount": "273", "Body": "<p>There is a pattern that I like using for implementing factory classes that goes as follows (taken from my answer to <a href=\"https://stackoverflow.com/questions/10905527/initialization-class-for-other-classes-c/10907093#10907093\">this</a> question):</p>\n<pre><code>class Factory\n{\npublic:\n    template&lt;class DerivedType&gt;\n    DerivedType::CreatedType *createType()\n    {\n        DerivedType::CreatedType *r = (DerivedType::CreatedType) (*(m_creators[DerivedType::id]))();\n        return r;\n    }\nprotected:\n    static std::map&lt;int,void *(*)()&gt; m_creators;\n};\n\nstd::map&lt;int,void *(*)()&gt; Factory::m_creators = std::map&lt;int,void*(*)()&gt;();\n\ntemplate&lt;class Derived, class CreatedType&gt;\nclass CRTPFactory : public Factory\n{\n    typedef typename CreatedType CreatedType;\npublic:\n    static bool register() \n    {\n        Factory::m_creators.push_back(std::make_pair(Derived::id,Derived::create);\n        return true;\n    }\n\nprivate:\n    static bool m_temp;\n};\n\ntemplate&lt;class Derived&gt;\nbool CRTPFactory&lt;Derived&gt;::m_temp = CRTPFactory&lt;Derived&gt;::register();\n\nclass AFactory : public CRTPFactory&lt;AFactory,A&gt;\n{\nprivate:\n    static A *create() \n    {\n        //do all initialization stuff here\n        return new A;\n    }\n\npublic:\n    static const int id = 0;\n};\n</code></pre>\n<p>This allows extension of the factory for new types without having to change the factory class. It also allows for implementing specific creation algorithms for different types without having to change the factory class. There is a major problem with this pattern though. The class AFactory is never used explicitly. It registers its creator function at load time through CRTPFactory's member temp. This might be a little complicated to understand but it's very easy to use. The problem is AFactory isn't compiled so it's static parameters aren't initialized at load time. My question is, is it possible to force the compiler (I'm using VS 2012 but answers for GCC are also good) to compile AFactory without ever explicitly creating an instance of it? \nA solution that I use in VS is to dllexport AFactory, that way the compiler compiles the class even though it doesn't know of anyone instantiating it. This is because it assumes some other dll might instantiate it. The problem with this solution is that the factory class must be implemented in a separate dll as the rest of the code. And also this doesn't work on GCC.</p>\n", "AcceptedAnswerId": "17467393", "Title": "C++: Compiling unused classes", "CreationDate": "2013-07-04T09:16:47.543", "Id": "17466466", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:56:31.330", "LastEditorUserId": "-1", "LastActivityDate": "2013-07-08T16:38:18.370", "Score": "1", "OwnerUserId": "919578", "Tags": "<c++><templates><design-patterns><compiler-construction>", "AnswerCount": "3"}, "17466960": {"Id": "17466960", "PostTypeId": "2", "Body": "<p>You're mistaken in your assumption. <code>class AFactory</code> is definitely compiled. Quite a few times, probably, since it's in a header.</p>\n<p>Your real problem is probably that <code>class AFactory</code> is not <em>registered</em>. Why would it be? Which statement would cause it to be? Every statement is ultimately called either from <code>main()</code> or from the initializer of a global variable. </p>\n", "LastActivityDate": "2013-07-04T09:40:13.933", "CommentCount": "4", "CreationDate": "2013-07-04T09:40:13.933", "ParentId": "17466466", "Score": "1", "OwnerUserId": "15416"}, "17467393": {"Id": "17467393", "PostTypeId": "2", "Body": "<p>Inheriting from <code>CRTPFactory&lt;AFactory,A&gt;</code> causes implicit instantiation of the class, but not the definitions of its members.</p>\n<blockquote>\n<p id=\"so_17466466_17467393_0\"><code>[temp.inst]</code></p>\n<p id=\"so_17466466_17467393_1\">The implicit instantiation of a class template specialization causes the implicit instantiation of the declarations, but not of the definitions or default arguments, of the class member functions, member classes, static data members and member templates;</p>\n</blockquote>\n<p>Instead of inheriting from <code>CRTPFactory&lt;AFactory,A&gt;</code>, you can simply explicitly instantiate the <code>m_temp</code> member.</p>\n<pre><code>template bool CRTPFactory&lt;AFactory,A&gt;::m_temp;\n</code></pre>\n<p>For reference, here's the modified example (in a form that compiles):</p>\n<pre><code>#include &lt;map&gt;\n\nclass Factory\n{\npublic:\n    template&lt;class DerivedType, class CreatedType&gt;\n    CreatedType *createType()\n    {\n        CreatedType *r = (CreatedType) (*(m_creators[DerivedType::id]))();\n        return r;\n    }\nprotected:\n    static std::map&lt;int,void *(*)()&gt; m_creators;\n};\n\nstd::map&lt;int,void *(*)()&gt; Factory::m_creators = std::map&lt;int,void*(*)()&gt;();\n\ntemplate&lt;class Derived, class CreatedType&gt;\nclass CRTPFactory : public Factory\n{\n\npublic:\n    static bool register_() \n    {\n        Factory::m_creators.insert(std::make_pair(Derived::id,Derived::create));\n        return true;\n    }\n\n  static bool m_temp;\n};\n\ntemplate&lt;class Derived, class CreatedType&gt;\nbool CRTPFactory&lt;Derived, CreatedType&gt;::m_temp = CRTPFactory&lt;Derived, CreatedType&gt;::register_();\n\nstruct A\n{\n};\n\nclass AFactory\n{\npublic:\n    static void *create() \n    {\n        //do all initialization stuff here\n        return new A;\n    }\n\npublic:\n    static const int id = 0;\n};\n\ntemplate bool CRTPFactory&lt;AFactory,A&gt;::m_temp;\n</code></pre>\n", "LastEditorUserId": "1690864", "LastActivityDate": "2013-07-08T16:38:18.370", "Score": "3", "CreationDate": "2013-07-04T10:00:30.490", "ParentId": "17466466", "CommentCount": "1", "OwnerUserId": "1690864", "LastEditDate": "2013-07-08T16:38:18.370"}, "17466589": {"Id": "17466589", "PostTypeId": "2", "Body": "<p>Static class member should be explicitly created somewhere.</p>\n<p>Doing something like this in a cpp file of your choice should work:</p>\n<pre><code>int AFactory::id = 0\n</code></pre>\n", "LastActivityDate": "2013-07-04T09:23:03.833", "CommentCount": "3", "CreationDate": "2013-07-04T09:23:03.833", "ParentId": "17466466", "Score": "1", "OwnerUserId": "865281"}});