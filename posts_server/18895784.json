post_cb({"bq_ids": {"n4140": {"so_18895784_18895984_2": {"length": 37, "quality": 0.9736842105263158, "section_id": 456}, "so_18895784_18895784_0": {"length": 10, "quality": 0.6666666666666666, "section_id": 361}}, "n3337": {"so_18895784_18895984_2": {"length": 37, "quality": 0.9736842105263158, "section_id": 447}, "so_18895784_18895784_0": {"length": 10, "quality": 0.6666666666666666, "section_id": 351}}, "n4659": {"so_18895784_18895984_2": {"length": 37, "quality": 0.9736842105263158, "section_id": 479}, "so_18895784_18895784_0": {"length": 10, "quality": 0.6666666666666666, "section_id": 373}}}, "18895784": {"ViewCount": "282", "Body": "<p>I read in the accepted answer <a href=\"https://stackoverflow.com/questions/4782757/rule-of-three-becomes-rule-of-five-with-c11\">here</a> that:</p>\n<blockquote>\n<p id=\"so_18895784_18895784_0\">[a] copy constructor and copy assignment operator won't be generated for a class that explicitly declares a move constructor <strong>or</strong> move assignment operator</p>\n</blockquote>\n<p>I do notice (g++ 4.7.2) that if you define a move constructor, it will be used with, e.g., <code>push_back()</code>, whereas if all you do is <code>= delete</code> the copy constructor, you don't get an implicit move constructor -- you get an error.  <em>[...which leads me to wonder which one (move or copy) is actually used if you don't do anything explicitly...]</em></p>\n<p>However, <a href=\"http://en.cppreference.com/w/cpp/language/copy_constructor#Deleted_implicitly-declared_copy_constructor\" rel=\"nofollow noreferrer\">this online reference</a> does not make the same explicit promises about the copy constructor <em>not</em> being implicitly defined when you define a move constructor.</p>\n<p>So my question is, is the first quote guaranteed by the standard (including the <strong>\"or\"</strong>)?  I would prefer, with some classes which need an explicit destructor, to complete the \"rule of five\" with just a move constructor and a (deleted) move operator and rely on the implicit copy methods <em>not</em> being defined.  If I can't rely on that, then I'll have to explicitly <code>=delete</code> them -- but that's a lot of potentially redundant stuff.</p>\n", "AcceptedAnswerId": "18895984", "Title": "Does an explicit move ctor eliminate implicit copy ctor?", "CreationDate": "2013-09-19T13:19:30.433", "Id": "18895784", "CommentCount": "1", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T12:28:03.057", "LastEditorUserId": "-1", "LastActivityDate": "2013-09-19T13:57:34.013", "Score": "4", "OwnerUserId": "1151724", "Tags": "<c++><c++11><constructor><implicit-declaration>", "AnswerCount": "2"}, "18895984": {"Id": "18895984", "PostTypeId": "2", "Body": "<blockquote>\n<p id=\"so_18895784_18895984_0\">So my question is, is the first quote guaranteed by the standard (including the <strong>\"or\"</strong>)?</p>\n</blockquote>\n<p>Yes, your first quote is guaranted by the standard.</p>\n<p>Quote from the standard (draft n3690):</p>\n<blockquote>\n<p id=\"so_18895784_18895984_1\"><strong>12.8 Copying and moving class objects [class.copy]</strong></p>\n<p id=\"so_18895784_18895984_2\">7/ If the class definition does not explicitly declare a copy constructor, one is declared implicitly. <strong>If the class definition declares a move constructor or move assignment operator, the implicitly declared copy constructor is defined as deleted; otherwise, it is defined as defaulted (8.4).</strong> The latter case is deprecated if the class has a user-declared copy assignment operator or a user-declared destructor.</p>\n</blockquote>\n", "LastActivityDate": "2013-09-19T13:28:24.687", "CommentCount": "0", "CreationDate": "2013-09-19T13:28:24.687", "ParentId": "18895784", "Score": "6", "OwnerUserId": "1394283"}, "18896702": {"Id": "18896702", "PostTypeId": "2", "Body": "<p>An interesting follow-up is why ?</p>\n<p>In C++98 was the <a href=\"http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29\" rel=\"nofollow\">Rule of Three</a>:</p>\n<blockquote>\n<p id=\"so_18895784_18896702_0\">Should you define any one of the following, you should define all three:</p>\n<ul>\n<li>destructor</li>\n<li>copy constructor</li>\n<li>copy assignment operator</li>\n</ul>\n</blockquote>\n<p>This rule of thumb was created because many people only thought about releasing the resource held within the destructor, and forgot the consequences this special behavior had on copies.</p>\n<p>When C++11 came around the corner, a number of people argued that this issue was caused by the default definition provided by the language, and that it would have been better, in hindsight, not to provide them by default. Of course, C provides them by default (for <code>struct</code>) so...</p>\n<p>... some suggested that in fact the Rule of Three could be enforced by the compiler; or at least, since changing the existing behavior might break existing code, that a pendant to the Rule of Three could be enforced by the compiler whenever talking about move constructor or move assignment operator (which guarantees new C++11 code).</p>\n<p>The Rule of Five:</p>\n<blockquote>\n<p id=\"so_18895784_18896702_1\">Should you define any one of the following, you should define all five:</p>\n<ul>\n<li>destructor</li>\n<li>move constructor</li>\n<li>move assignment operator</li>\n<li>copy constructor</li>\n<li>copy assignment operator</li>\n</ul>\n</blockquote>\n<p>was thus nearly fully implemented as:</p>\n<ul>\n<li>if you define a move constructor or move assignment operator, the other 4 methods are implicitly deleted (unless you provide them)</li>\n<li>if you define a destructor, copy constructor or copy assignment operator, the move constructor and move assignment operator are implicitly deleted (unless you provide them)</li>\n</ul>\n<p>the second statement is slightly incomplete for backward compatibility reasons with existing C++98 code (which should compile as C++11 without a change of behavior).</p>\n", "LastActivityDate": "2013-09-19T13:57:34.013", "CommentCount": "0", "CreationDate": "2013-09-19T13:57:34.013", "ParentId": "18895784", "Score": "2", "OwnerUserId": "147192"}});