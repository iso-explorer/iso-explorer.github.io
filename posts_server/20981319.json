post_cb({"20981319": {"CommentCount": "2", "ViewCount": "826", "CreationDate": "2014-01-07T20:33:36.803", "LastActivityDate": "2014-01-10T14:57:41.570", "Title": "Why can a variadic class template have at most one parameter pack?", "FavoriteCount": "1", "PostTypeId": "1", "Id": "20981319", "Score": "0", "Body": "<p>There are moments when wish I could write a class template parameterized by a \npunctuated list of variadic template parameter packs, e.g. </p>\n<pre><code>template&lt;typename ...lhs, int Punct, typename ...rhs&gt;\nstruct tuple_pair\n{\n    std::tuple&lt;lhs...&gt; _lhs;\n    std::tuple&lt;rhs...&gt; _rhs;\n};\n</code></pre>\n<p>or for that matter:</p>\n<pre><code>template&lt;int ...lhs, typename Punct, int ...rhs&gt;\nstruct seq_pair\n{\n    std::integer_sequence&lt;int,lhs...&gt; _lhs;\n    std::integer_sequence&lt;int,rhs...&gt; _rhs;\n};\n</code></pre>\n<p>These may very well be moments when I am wishing for a grubby hack, but anyhow of \ncourse the Standard says I can't have it: \u00a7 14.1.11:</p>\n<blockquote>\n<p id=\"so_20981319_20981319_0\">If a template-parameter of a primary class template or alias template is a \n  template parameter pack, it shall be the last template-parameter.</p>\n</blockquote>\n<p>I do not understand <em>why</em> this is so. It seems to me that in any instantiation,\ne.g.</p>\n<pre><code>tuple_pair&lt;char,short,0,int,long&gt; tp;\nseq_pair&lt;0,2,3,void,4,5,6&gt; sp;\n</code></pre>\n<p>a compiler could distinguish the <code>...lhs</code> arguments from the <code>...rhs</code> as well\nas I can.</p>\n<p>I invite no speculations as to why the Standard is what is - emphatically so - but can\nanyone <em>authoritatively</em> tell us why the C++ template machinery does not or\ncannot support the separation of multiple class template parameter packs in this way?\nI would particularly like to have confirmed or dismissed the suspicion that there is \na fundamental logical obstacle to it that escapes me.</p>\n", "Tags": "<c++><compiler-construction><standards><variadic-templates>", "OwnerUserId": "1362568", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_20981319_20981319_0": {"section_id": 64, "quality": 1.0, "length": 11}}, "n3337": {"so_20981319_20981319_0": {"section_id": 59, "quality": 1.0, "length": 11}}, "n4659": {"so_20981319_20981319_0": {"section_id": 66, "quality": 1.0, "length": 11}}}, "21023429": {"ParentId": "20981319", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>Variadic template lists cannot be manipulated as first class objects. As a a result it is usually more convenient to work with parameter packs wrapped in some template object.</p>\n<p>This is how I would go about passing two lists of types to a template class:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>// create an empty default implementation\ntemplate &lt;typename LeftTuple, typename RightTuple&gt; \nclass tuplePair {};\n\n// specialise to allow tupled lists of types to be passed in\ntemplate &lt;typename ...LHS, typename ...RHS&gt;\nclass tuplePair&lt;tuple&lt;LHS...&gt;, tuple&lt;RHS...&gt; &gt; \n{\n   // ...\n};\n\n//or more catholically:\ntemplate &lt;typename ...LHS, typename ...RHS, template&lt;typename...&gt; class tuple_template&gt;\nclass tuplePair&lt;tuple_template&lt;LHS...&gt;, tuple_template&lt;RHS...&gt;&gt;  \n{\n   // ...\n};\n\ntemplate&lt;typename... X&gt;\nclass some_other_tuple {};\n\n\n\nint main() {\n   tuplePair&lt;tuple&lt;char,char,char&gt;, tuple&lt;char,char,char&gt;&gt; tango_tuple;\n   tuplePair&lt;some_other_tuple&lt;int&gt;, some_other_tuple&lt;char&gt;&gt; other_tuple;\n   return 0;\n}\n</code></pre>\n<p>I this formulation clearer than using some sort of deliminator (<code>void</code>) in any case. As a general rule semantics that afford for a list or tuple object rather than simply using deliminators are more powerful (because they allow nesting) and easier to manipulate.</p>\n<h3>Addendum:</h3>\n<p>I will risk of giving another answer which misses the point, in particular it is not authoritative, in the hope that it might be helpful.</p>\n<p>I have read through the drafts of the variadic template proposal and scanned all 196 threads on comp.std.C++ mentioning the word \"variadic\" and it seems that the only reason for this limitation is simplicity. In particular simplicity of drafting the standard rather than implementation.</p>\n<p>I couldn't find any discussion of generalization that you present (allowing a parameter pack anywhere in the template parameter list which is not followed by a parameter or parameter pack of the same kind). However other generalizations were discussed, such as allowing a parameter pack expansion to appear in places other than the end of of a template <em>specialization</em> and it looks like time just ran out on these discussions.</p>\n<p>Do you have a persuasive use case? I really don't mean to be the <em>\"show me a use case or I will shut you down\"</em> bully, I am just interested.</p>\n", "OwnerUserId": "1513041", "LastEditorUserId": "1513041", "LastEditDate": "2014-01-10T14:57:41.570", "Id": "21023429", "Score": "4", "CreationDate": "2014-01-09T14:49:06.453", "LastActivityDate": "2014-01-10T14:57:41.570"}});