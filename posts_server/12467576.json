post_cb({"12467576": {"CommentCount": "7", "ViewCount": "1199", "PostTypeId": "1", "LastEditorUserId": "1175080", "CreationDate": "2012-09-17T21:47:05.630", "LastActivityDate": "2012-09-17T22:37:15.917", "Title": "How to write binary data into a file without invoking implementation-defined behavior?", "AcceptedAnswerId": "12467929", "LastEditDate": "2012-09-17T22:02:09.877", "Id": "12467576", "Score": "4", "Body": "<p>I am writing a program like this to write some bytes into a file.</p>\n<pre><code>#include &lt;fstream&gt;\n\nint main()\n{\n    char buffer[4] = {0, 0, 255, 255};\n    std::ofstream f(\"foo.txt\", std::ios_base::binary);\n    f.write(buffer, sizeof buffer);\n    f.close();\n    return 0;\n}\n</code></pre>\n<p>This works fine and gives me the expected result on my system.</p>\n<pre><code>$ g++ -std=c++11 -pedantic -Wall -Wextra signedness.cc\n$ ./a.out\n$ cat foo.txt\n$ od -t x1 foo.txt \n0000000 00 00 ff ff\n0000004\n</code></pre>\n<p>The equivalent C code would be:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n    char buffer[4] = {0, 0, 255, 255};\n    FILE *f = fopen(\"bar.txt\", \"wb\");\n    fwrite(buffer, sizeof *buffer, sizeof buffer, f);\n    fclose(f);\n    return 0;\n}\n</code></pre>\n<p>This program also works fine and gives the expected output on my system.</p>\n<p>I want to know if the above way of writing bytes into a file is okay.</p>\n<p>Section 4.7 (Integral conversions) of <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf\" rel=\"nofollow\">C++ n3242.pdf</a> mentions in point 3:</p>\n<blockquote>\n<p id=\"so_12467576_12467576_0\">If the destination type is signed, the value is unchanged if it can be represented in the destination type (and bit-field width); otherwise, the value is implementation-defined.</p>\n</blockquote>\n<p>Section 6.3.1.3 (signed and unsigned integers) of <a href=\"http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf\" rel=\"nofollow\">C n1256.pdf</a> mentions in point 3:</p>\n<blockquote>\n<p id=\"so_12467576_12467576_1\">Otherwise, the new type is signed and the value cannot be represented in it; either the\n  result is implementation-defined or an implementation-defined signal is raised.</p>\n</blockquote>\n<p>From these extracts, it seems like my program invokes implementation-defined behavior when I assign 255 as the last two bytes of <code>char buffer[4]</code> because 255 cannot be represented in <code>char</code> type. If I am right about this, then what would be the right way to write these four bytes into a file? Changing the type of <code>buffer</code> from <code>char</code> to <code>unsigned char</code> doesn't seem to help in C++ because ofstream's <code>write()</code> function still expects the first parameter to of type <code>const char*</code>.</p>\n", "Tags": "<c++><c>", "OwnerUserId": "1175080", "AnswerCount": "3"}, "12467884": {"ParentId": "12467576", "PostTypeId": "2", "CommentCount": "5", "Body": "<p>\"implementation-defined\" is the language of the International Standard for C++, which is a quasi-legal document intended to cover every conceivable case.  </p>\n<p>So it could be running on a machine where char is 9 bits, hence it's inherent in the act of dealing with binary data and files that some aspects will be implementation-defined. By the letter of the Standard you have to study the documentation for each target machine and be sure that the behaviour you need is achieved in each case.</p>\n<p>In the real world, every modern general-purpose CPU has 8-bit bytes and uses 2s-complement arithmetic, so there is nothing to worry about unless you are targeting a very specific situation.</p>\n", "OwnerUserId": "448734", "LastEditorUserId": "448734", "LastEditDate": "2012-09-17T22:37:15.917", "Id": "12467884", "Score": "-1", "CreationDate": "2012-09-17T22:19:56.313", "LastActivityDate": "2012-09-17T22:37:15.917"}, "12467929": {"ParentId": "12467576", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Remember that <code>ofstream</code> is just a typedef for <code>std::basic_ofstream&lt;char&gt;</code>.</p>\n<p>When you don't want things being treated as <code>char</code>, just use <code>std::basic_ofstream&lt;unsigned char&gt;</code> or <code>std::basic_ofstream&lt;uint8_t&gt;</code>.</p>\n<p>Ultimately, though, iostreams are made for formatted I/O.  The API is horrible for binary I/O (since it doesn't take <code>void*</code>) and also incredibly slow.  Furthermore, every character is converted by a \"facet\", making it hard to guarantee 1:1 correspondence between input bytes and bytes on disk.  <code>basic_filebuf</code> is a little better, but not much.  Using <code>fopen</code> and <code>fwrite</code> is still a perfectly valid approach, even in C++.</p>\n", "OwnerUserId": "103167", "LastEditorUserId": "103167", "LastEditDate": "2012-09-17T22:31:16.230", "Id": "12467929", "Score": "5", "CreationDate": "2012-09-17T22:25:12.530", "LastActivityDate": "2012-09-17T22:31:16.230"}, "bq_ids": {"n4140": {"so_12467576_12467576_0": {"section_id": 32, "quality": 0.9285714285714286, "length": 13}}, "n3337": {"so_12467576_12467576_0": {"section_id": 29, "quality": 0.9285714285714286, "length": 13}}, "n4659": {"so_12467576_12467576_0": {"section_id": 32, "quality": 0.7857142857142857, "length": 11}}}, "12467626": {"ParentId": "12467576", "PostTypeId": "2", "CommentCount": "12", "Body": "<p>True, 255 can't be represented in a signed <code>char</code> type, but you're not assigning 255, you're assigning <code>FF</code>, which represents <code>-1</code>.</p>\n<p>You want to be using a <code>uint8_t</code>, as defined in <code>stdint.h</code>, or at the very least use an <code>unsigned char</code>.</p>\n", "OwnerUserId": "389146", "LastEditorUserId": "389146", "LastEditDate": "2012-09-17T22:04:28.610", "Id": "12467626", "Score": "0", "CreationDate": "2012-09-17T21:51:59.203", "LastActivityDate": "2012-09-17T22:04:28.610"}});