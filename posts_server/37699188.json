post_cb({"37701202": {"ParentId": "37699188", "CommentCount": "0", "Body": "<h2>Abstract</h2>\n<p>RTTI per se is not something really formally defined: C++ only says what <code>typeid</code> and <code>dynamic_cast</code> do, not how they're implemented. However, it is convenient indeed to group such kind of operations under a common name which is RTTI.</p>\n<p>Notice an implementation is <em>not</em> required to strictly obtain this information at runtime i.e.</p>\n<p><code>if ( typeid(int) == typeid(double) )</code></p>\n<p>could also be determined during the program evaluation, much like <code>std::is_same</code>. <code>int</code> is undeniably non-polymorphic (it has no 'dynamic' type). <a href=\"http://en.cppreference.com/w/cpp/language/typeid\" rel=\"nofollow\">cppreference</a> even claims:</p>\n<blockquote>\n<p id=\"so_37699188_37701202_0\">When applied to an expression of polymorphic type, evaluation of a typeid expression may involve runtime overhead (a virtual table lookup), <strong>otherwise typeid expression is resolved at compile time.</strong> </p>\n</blockquote>\n<p>But it's to be taken cautiously. </p>\n<h2> </h2>\n<hr>\n<blockquote>\n<p id=\"so_37699188_37701202_1\">Does that mean type_info is a part of RTTI, or is it just a behavior of GCC?</p>\n</blockquote>\n<p><code>type_info</code> is a <em>class</em>. You may not construct any object of that type - you only can through <code>typeid</code>. </p>\n<p><a href=\"https://gcc.gnu.org/onlinedocs/gcc-3.4.4/gcc/C_002b_002b-Dialect-Options.html\" rel=\"nofollow\"><code>-fno-rtti</code></a> disable RTTI under GCC: you can't use <code>typeid</code>, and thereby neither can be <code>type_info</code>. They're very close each other.</p>\n<p>To conclude, the original quote is totally right:</p>\n<blockquote>\n<p id=\"so_37699188_37701202_2\">POD types do have <code>type_info</code>, but don't have RTTI, and that's possible because type_info isn't always RTTI.</p>\n</blockquote>\n<p>The runtime information is available through <code>typeid</code>. There is just nothing dynamic to consider (indeed, <code>dynamic_cast</code> would make no sense).</p>\n</hr>", "OwnerUserId": "2692339", "PostTypeId": "2", "Id": "37701202", "Score": "2", "CreationDate": "2016-06-08T11:27:15.750", "LastActivityDate": "2016-06-08T11:27:15.750"}, "37701796": {"ParentId": "37699188", "CommentCount": "0", "Body": "<p>There is no concept of \"RTTI\" in the standard. Instead, it's said in different words.</p>\n<ul>\n<li><p><code>&lt;typeinfo&gt;</code> is referred to as \"dynamic type identification\" in [support.general]</p></li>\n<li><p>[intro.object] says: \"Some objects are <em>polymorphic</em> (10.3); the implementation generates information associated with each such object that makes it possible to determine that object\u2019s type during program execution\"</p></li>\n<li><p>[expr.dynamic.cast] talks about checks that happen at \"run-time\". All other uses of \"runtime\" in the standard refer to something else.</p></li>\n</ul>\n<p>[expr.typeid] explains what <code>typeid</code> does:</p>\n<blockquote>\n<p id=\"so_37699188_37701796_0\">2 When <code>typeid</code> is applied to a glvalue expression whose type is a\n  polymorphic class type (10.3), the result refers to a <code>std::type_info</code>\n  object representing the type of the most derived object (1.8) (that\n  is, the dynamic type) to which the glvalue refers. ...</p>\n</blockquote>\n<p>The latter is typically referred to a \"run-time\" operation.</p>\n<blockquote>\n<p id=\"so_37699188_37701796_1\">3 When <code>typeid</code> is applied to an expression other than a glvalue of a\n  polymorphic class type, the result refers to a <code>std::type_info</code> object\n  representing the static type of the expression. ... The expression is an unevaluated operand (Clause 5).</p>\n</blockquote>\n<p>While the former can be seen as a \"compile-time\" operation.</p>\n<p>Regardless, GCC doesn't really care and disables <code>typeid</code> and <code>dynamic_cast</code> altogether if you use the <code>-fno-rtti</code> flag:</p>\n<p><a href=\"https://github.com/gcc-mirror/gcc/blob/5d4b30ea56c1733a9149b59105b9645c115cc123/gcc/cp/rtti.c#L285\" rel=\"nofollow\">rtti.c</a>:</p>\n<pre><code>  if (! flag_rtti)\n    {\n      error (\"cannot use typeid with -fno-rtti\");\n      return false;\n    }\n</code></pre>\n<p>Could it disable <code>typeid</code> for polymorphic types only? Sure. But we're going to go with occam's razor in that it's much easier developmentally-wise to prevent the use of <code>typeid</code> altogether.</p>\n", "OwnerUserId": "6292850", "PostTypeId": "2", "Id": "37701796", "Score": "1", "CreationDate": "2016-06-08T11:54:57.350", "LastActivityDate": "2016-06-08T11:54:57.350"}, "37699188": {"CommentCount": "7", "ViewCount": "802", "PostTypeId": "1", "LastEditorUserId": "-1", "CreationDate": "2016-06-08T09:55:13.863", "LastActivityDate": "2016-06-08T11:54:57.350", "Title": "Is type_info not a part of RTTI?", "LastEditDate": "2017-05-23T10:28:39.990", "Id": "37699188", "Score": "7", "Body": "<p>I had asked a question <a href=\"https://stackoverflow.com/questions/35342258/do-c-pod-types-have-rtti\">Do C++ POD types have RTTI?</a> and someone told me in the comments:</p>\n<blockquote>\n<p id=\"so_37699188_37699188_0\">POD types do have type_info, but don't have RTTI, and that's possible\n  because type_info isn't always RTTI.</p>\n</blockquote>\n<p>and it seems right as i could get the <code>type_info</code> of a POD (<em>non-polymorphic</em>) type.</p>\n<p>But while I compile this simple program:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct X\n{\n    int a;\n};\n\nint main()\n{\n    using namespace std;\n\n    std::cout &lt;&lt; typeid(X) &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>with flag <code>-fno-rtti</code> of GCC:</p>\n<pre><code>$ g++ -fno-rtti main.cpp &amp;&amp; ./main\n</code></pre>\n<p>It won't compile:</p>\n<pre><code>main.cpp: In function \u2018int main()\u2019:\nmain.cpp:12:26: error: cannot use typeid with -fno-rtti\n     std::cout &lt;&lt; typeid(X) &lt;&lt; std::endl;\n                          ^\n</code></pre>\n<p>Does that mean <code>type_info</code> is a part of RTTI, or is it just a <em>behavior</em> of GCC?</p>\n", "Tags": "<c++><gcc><rtti>", "OwnerUserId": "417024", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_37699188_37701796_0": {"section_id": 6021, "quality": 0.9583333333333334, "length": 23}, "so_37699188_37701796_1": {"section_id": 6022, "quality": 0.9565217391304348, "length": 22}}, "n3337": {"so_37699188_37701796_0": {"section_id": 5789, "quality": 0.9583333333333334, "length": 23}, "so_37699188_37701796_1": {"section_id": 5790, "quality": 0.9565217391304348, "length": 22}}, "n4659": {"so_37699188_37701796_0": {"section_id": 7520, "quality": 0.9583333333333334, "length": 23}, "so_37699188_37701796_1": {"section_id": 7521, "quality": 0.9565217391304348, "length": 22}}}});