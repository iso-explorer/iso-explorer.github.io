post_cb({"bq_ids": {"n4140": {"so_44721729_44725331_1": {"length": 7, "quality": 0.5384615384615384, "section_id": 5908}, "so_44721729_44725331_0": {"length": 31, "quality": 0.9393939393939394, "section_id": 5908}}, "n3337": {"so_44721729_44725331_1": {"length": 7, "quality": 0.5384615384615384, "section_id": 5680}, "so_44721729_44725331_0": {"length": 31, "quality": 0.9393939393939394, "section_id": 5680}}, "n4659": {"so_44721729_44725331_1": {"length": 12, "quality": 0.9230769230769231, "section_id": 7390}, "so_44721729_44725331_2": {"length": 16, "quality": 0.8888888888888888, "section_id": 6305}, "so_44721729_44725331_0": {"length": 24, "quality": 0.7272727272727273, "section_id": 7390}}}, "44721729": {"ViewCount": "110", "Body": "<p>If I want to use some convenience stuff like <code>make_array</code> I have no chance to declare my array first and later make the definition as done in \"earlier\" times because the type of my var is not available before definition.</p>\n<p>So I found this answer:<br>\n<a href=\"https://stackoverflow.com/questions/8016780/undefined-reference-to-static-constexpr-char\">Undefined reference to static constexpr char[]</a></br></p>\n<p>In the following example I wrote this solution which compiles fine with gcc and I am not sure that this is really valid c++ code, because it is more or less a declaration with definition and later a definition without any content. Is this allowed? ( Compiles fine is not a guarantee that the code is valid c++ )</p>\n<pre><code>#include &lt;experimental/array&gt;\n#include &lt;iostream&gt;\n\nclass Foo\n{\n    private:\n    static decltype(auto) constexpr Bar =\n        std::experimental::make_array(\n            std::experimental::make_array( 1,2,3 ),\n            std::experimental::make_array( 4,5,6 )\n            );\n\n    public:\n    using ARR_TYPE = decltype( Bar );\n\n    static auto&amp; GetArr( int idx )\n    {\n        // range check ...\n        return Bar[idx];\n    }\n};\n\nconstexpr Foo::ARR_TYPE Foo::Bar;\n\nint main()\n{\n    for ( auto el: Foo::GetArr(0))\n    {\n        std::cout &lt;&lt; el &lt;&lt; std::endl;\n    }\n }\n</code></pre>\n", "AcceptedAnswerId": "44725331", "Title": "constexpr: definition and declaration for constexpr members", "CreationDate": "2017-06-23T12:41:24.347", "Id": "44721729", "CommentCount": "0", "PostTypeId": "1", "LastActivityDate": "2017-06-23T15:56:09.430", "Score": "0", "OwnerUserId": "878532", "Tags": "<c++><static><language-lawyer><constexpr>", "AnswerCount": "1"}, "44725331": {"Id": "44725331", "PostTypeId": "2", "Body": "<p>The rules governing <code>static constexpr</code> members changes in C++1z, which is kinda annoying.</p>\n<h2>Pre C++1z</h2>\n<p>From <a href=\"https://timsong-cpp.github.io/cppwp/n4140/class.static.data#3\" rel=\"nofollow noreferrer\">[class.static.data]</a></p>\n<blockquote>\n<p id=\"so_44721729_44725331_0\">[...] A static data member of literal type can be declared in the class definition with the constexpr specifier; if so, its declaration shall specify a brace-or-equal-initializer in which every initializer-clause that is an assignment-expression is a constant expression. [...] <strong>The member shall still be defined in a namespace scope if it is odr-used</strong> ([basic.def.odr]) in the program and the namespace scope definition shall not contain an initializer.</p>\n</blockquote>\n<p>Which means you are <strong>required</strong> to provide a initializer in the declaration, but also to provide a definition at namespace scope <strong>without</strong> an initializer.</p>\n<p>Your code does exactly that.</p>\n<h2>Post C++1z</h2>\n<p>From the same paragraph <a href=\"http://eel.is/c++draft/class.static.data#3\" rel=\"nofollow noreferrer\">[class.static.data]</a></p>\n<blockquote>\n<p id=\"so_44721729_44725331_1\">[...] If the member is declared with the constexpr specifier, it <strong>may be redeclared in namespace scope with no initializer</strong> (this usage is deprecated; see [depr.static_constexpr]). [...]</p>\n</blockquote>\n<p>And from <a href=\"http://eel.is/c++draft/depr.static_constexpr\" rel=\"nofollow noreferrer\">[depr.static_constexpr]</a></p>\n<blockquote>\n<p id=\"so_44721729_44725331_2\">For compatibility with prior C++ International Standards, a constexpr static data member may be redundantly redeclared outside the class with no initializer. This usage is deprecated.</p>\n</blockquote>\n<p>So, this is still legal, but deprecated.</p>\n<p>It should be noted <code>static</code> but not <code>constexpr</code> members (including <code>static const</code> members) are still required to have a definition in namespace scope if it is odr-used.</p>\n", "LastEditorUserId": "4832499", "LastActivityDate": "2017-06-23T15:56:09.430", "Score": "3", "CreationDate": "2017-06-23T15:41:14.183", "ParentId": "44721729", "CommentCount": "1", "OwnerUserId": "4832499", "LastEditDate": "2017-06-23T15:56:09.430"}});