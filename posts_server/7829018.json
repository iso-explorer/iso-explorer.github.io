post_cb({"7829018": {"CommentCount": "15", "AcceptedAnswerId": "7829166", "CreationDate": "2011-10-19T22:32:08.163", "LastActivityDate": "2011-10-20T00:27:04.003", "PostTypeId": "1", "ViewCount": "1129", "FavoriteCount": "1", "Title": "Can we rely on the reduce-capacity trick?", "Id": "7829018", "Score": "8", "Body": "<p>Is it actually guaranteed anywhere that the following reduce-capacity trick will \"work\"?</p>\n<pre><code>int main() {\n   std::string s = \"lololololol\";\n   s = \"\";                        // capacity still non-zero\n\n   string(s).swap(s);             // ?\n}\n</code></pre>\n<p>It doesn't seem to \"work\" for me (in that the capacity remains non-zero), and I can't find anything in the standard that says anything more than that the \"contents\" must be swapped between the two [here, identical] objects.</p>\n<p>Similarly, for sequence containers:</p>\n<pre><code>int main() {\n   vector&lt;int&gt; v { 1,2,3,4,5 };\n   v.clear();                   // capacity still non-zero\n\n   vector&lt;int&gt;(v).swap(v);      // ?\n}\n</code></pre>\n<p>As far as I'm aware, this \"trick\" is semi-widely used; perhaps this widespread adoption is misguided?</p>\n<p><sup>(Of course, in C++11 we have <code>shrink_to_fit</code> [albeit non-binding] instead, making this kind of moot.)</sup></p>\n", "Tags": "<c++><std>", "OwnerUserId": "560648", "AnswerCount": "4"}, "7829748": {"ParentId": "7829018", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>On his <a href=\"http://www.aristeia.com/BookErrata/estl1e-errata.html\" rel=\"nofollow\">errata page</a> for \"Effective STL,\" Scott Meyers notes:</p>\n<blockquote>\n<p id=\"so_7829018_7829748_0\">When string implementations use reference counting, <strong>the swap trick\n  using the copy constructor doesn't decrease the capacity, because the\n  copy constructor isn't allocating any memory; it's just adjusting a\n  reference count.</strong> A more reliable way to perform shrink-to-fit is to\n  create the temporary string via the range constructor, e.g.,\n  string(s.begin(), s.end()).swap(s); This version of the swap trick is\n  safer for vectors, too, because it eliminates any chance that the copy\n  constructor will copy the other vector's excess capacity (which\n  implementations are permitted to do).</p>\n</blockquote>\n<p>As for the 'guarantee,' Meyers notes:</p>\n<blockquote>\n<p id=\"so_7829018_7829748_1\">The language police require that I inform you that there's no\n  guarantee that this technique will truly eliminate excess capacity.\n  Implementers are free to give vectors and strings excess capacity if\n  they want to, and sometimes they want to. [Effective STL, Item 17]</p>\n</blockquote>\n", "OwnerUserId": "124755", "LastEditorUserId": "124755", "LastEditDate": "2011-10-20T00:27:04.003", "Id": "7829748", "Score": "4", "CreationDate": "2011-10-20T00:18:14.763", "LastActivityDate": "2011-10-20T00:27:04.003"}, "7829077": {"ParentId": "7829018", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>From <a href=\"http://www.gotw.ca/gotw/054.htm\" rel=\"nofollow\">http://www.gotw.ca/gotw/054.htm</a>:</p>\n<blockquote>\n<p id=\"so_7829018_7829077_0\">Some implementations may choose to round up the capacity slightly to\n  their next larger internal \"chunk size,\" with the result that the\n  capacity actually ends up being slightly larger than the size.</p>\n</blockquote>\n", "OwnerUserId": "10077", "LastEditorUserId": "10077", "LastEditDate": "2011-10-19T22:53:51.220", "Id": "7829077", "Score": "2", "CreationDate": "2011-10-19T22:38:11.977", "LastActivityDate": "2011-10-19T22:53:51.220"}, "7829383": {"ParentId": "7829018", "CommentCount": "0", "Body": "<p>How this works is probably entirely implementation-defined. Unlike containers such as vector, strings can have very different implementations. </p>\n<p>If the string implementation uses small string optimization, then you can't lower capacity beyond a certain threshold. If the string implementation uses copy-on-write, then no write occurs and no real copy is made.</p>\n<p>According to <a href=\"http://www.gotw.ca/gotw/054.htm\" rel=\"nofollow\">http://www.gotw.ca/gotw/054.htm</a>, shrink-to-fit and clear-completely are different tricks. If the intention is to clear completely, then swapping with a default-constructed string can be expected to give better results.</p>\n", "OwnerUserId": "155693", "PostTypeId": "2", "Id": "7829383", "Score": "0", "CreationDate": "2011-10-19T23:19:53.823", "LastActivityDate": "2011-10-19T23:19:53.823"}, "7829166": {"ParentId": "7829018", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>I've always been taught that there is no guaranteed standard way to lower the capacity.  All methods have been (and still are) implementation defined.  </p>\n<p>\u00a7 23.2.1\\8 says:</p>\n<blockquote>\n<p id=\"so_7829018_7829166_0\">The expression <code>a.swap(b)</code>, for containers <code>a</code> and <code>b</code> of a standard\n  container type other than <code>array</code>, shall exchange the values of <code>a</code> and <code>b</code>\n  without invoking any move, copy, or swap operations on the individual\n  container elements...</p>\n</blockquote>\n<p>This guarantees that the internal pointers of vectors must be swapped.<br>\nHowever, I cannot find anything that guarantee on the capacity of a newly created vector.</br></p>\n<p>\u00a7 21.4.2\\1 says that one of the <code>basic_string</code> default constructor's post conditions is that <code>capacity()</code> returns an unspecified value.<br>\n\u00a7 21.4.2\\3 says that one of the basic_string copy constructor's post conditions is that <code>capacity()</code> returns a value at least as big as <code>size()</code>.<br>\n\u00a7 21.4.6.8\\2 says that <code>string::swap</code> runs in constant time, which (effectively) requires that the internal pointers are swapped.</br></br></p>\n<p>As far as I can tell, a conforming implementation could have <code>string::max_size() { return 4;}</code>, and swapping all internals from one buffer to another would therefore be constant time.  (vector can't do that though)</p>\n<p>Obviously, take this all with a grain of salt.  I'm quoting from the C++ draft from Feb28,'11, and I can't find specifications for the vector's copy constructor.  Also, not finding evidence <em>for</em> is not the same as finding evidence <em>against</em>.</p>\n", "OwnerUserId": "845092", "LastEditorUserId": "845092", "LastEditDate": "2011-10-19T23:17:30.003", "Id": "7829166", "Score": "6", "CreationDate": "2011-10-19T22:49:52.190", "LastActivityDate": "2011-10-19T23:17:30.003"}, "bq_ids": {"n4140": {"so_7829018_7829166_0": {"section_id": 710, "quality": 0.9473684210526315, "length": 18}}, "n3337": {"so_7829018_7829166_0": {"section_id": 699, "quality": 0.9473684210526315, "length": 18}}, "n4659": {"so_7829018_7829166_0": {"section_id": 739, "quality": 0.9473684210526315, "length": 18}}}});