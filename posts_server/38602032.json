post_cb({"38602032": {"CommentCount": "3", "ViewCount": "67", "PostTypeId": "1", "LastEditorUserId": "596781", "CreationDate": "2016-07-27T00:47:08.070", "LastActivityDate": "2016-07-27T21:25:14.727", "Title": "enum underlying type vs normal type", "AcceptedAnswerId": "38604097", "LastEditDate": "2016-07-27T21:25:14.727", "Id": "38602032", "Score": "1", "Body": "<p>If i try to compile below code it will give me error that 'enumerator value too large for underlying type 'char'</p>\n<pre><code>enum class Status:char{one=126,two=127,three=128};\nStatus s = Status::three;\n</code></pre>\n<p>However if i execute following code compiler don't give me any errors and silently ignores that char upper range is crossed</p>\n<pre><code>char x = 128;\n</code></pre>\n<p>So is there any specific reason why compiler don't check in case of normal data type and check for range in case of enum underlying type.</p>\n", "Tags": "<c++><c++11><enums>", "OwnerUserId": "3600304", "AnswerCount": "1"}, "38604097": {"ParentId": "38602032", "CommentCount": "0", "Body": "<p>C++11 introduced restrictions on \"narrowing conversions\" and where they are and aren't allowed. Tucked away in 5.19\u00a73 is a clause that describes \"converted constant expression\"s and specifically precludes narrowing conversions, and then notes that such expressions may be used in [...] enumerator initializers. Thus, you can't do:</p>\n<pre><code>enum class Foo : char { one = 128 };\nunsigned char uc1 = {-1};\n</code></pre>\n<p>but you can do</p>\n<pre><code>enum class Foo : char { one = (char)128 };\nunsigned char uc1 = -1;\n</code></pre>\n<p>5.19 [expr.const] \u00a73</p>\n<blockquote>\n<p id=\"so_38602032_38604097_0\">[...] A converted constant expression of type T is an expression, implicitly converted to a prvalue of type T, where the converted expression is a core constant expression and the implicit conversion sequence contains only user-defined conversions, lvalue-torvalue conversions (4.1), integral promotions (4.5), and integral conversions (4.7) other than narrowing conversions (8.5.4). [ Note: such expressions may be used in new expressions (5.3.4), as case expressions (6.4.2), as enumerator initializers if the underlying type is fixed (7.2), as array bounds (8.3.4), and as integral or enumeration non-type template arguments (14.3). \u2014end note ]</p>\n</blockquote>\n", "OwnerUserId": "257645", "PostTypeId": "2", "Id": "38604097", "Score": "2", "CreationDate": "2016-07-27T05:02:32.467", "LastActivityDate": "2016-07-27T05:02:32.467"}, "bq_ids": {"n4140": {"so_38602032_38604097_0": {"section_id": 6186, "quality": 0.8620689655172413, "length": 50}}, "n3337": {"so_38602032_38604097_0": {"section_id": 5947, "quality": 0.7068965517241379, "length": 41}}, "n4659": {"so_38602032_38604097_0": {"section_id": 7689, "quality": 0.7413793103448276, "length": 43}}}});