post_cb({"9048395": {"Id": "9048395", "PostTypeId": "2", "Body": "<p>It returns the current instance of the type MyClass you are in. It's returned as reference because the assignment operator was explicitly told to return a reference.</p>\n<pre><code>MyClass&amp; operator = (MyClass&amp; other)  { return *this; }\n</code></pre>\n<p>Note the <code>&amp;</code> after MyClass as the return value. A reference is returned.\nUnless the <code>&amp;</code> weren't there right before <code>operator</code>, the instance would be returned by value.</p>\n", "LastEditorUserId": "905619", "LastActivityDate": "2012-01-28T20:47:07.157", "Score": "4", "CreationDate": "2012-01-28T20:36:59.947", "ParentId": "9048379", "CommentCount": "3", "OwnerUserId": "905619", "LastEditDate": "2012-01-28T20:47:07.157"}, "9048404": {"Id": "9048404", "PostTypeId": "2", "Body": "<p>A function returns a reference if its declaration (i.e. its signature) tells so.</p>\n<p>So (assuming a <code>class Foo</code>) if a function is declarated</p>\n<pre><code> Foo fun();\n</code></pre>\n<p>then it returns a value (with copying, etc..)</p>\n<p>But if it is declared as </p>\n<pre><code> Foo&amp; fun();\n</code></pre>\n<p>or as </p>\n<pre><code> const Foo&amp; fun();\n</code></pre>\n<p>a reference is returned.</p>\n<p>The statement <code>return *this;</code> don't define by itself if a reference or a value is returned.</p>\n", "LastActivityDate": "2012-01-28T20:37:54.880", "CommentCount": "1", "CreationDate": "2012-01-28T20:37:54.880", "ParentId": "9048379", "Score": "5", "OwnerUserId": "841108"}, "9048454": {"Id": "9048454", "PostTypeId": "2", "Body": "<p>In C++ the * always means a value, in fact you can look to en English interpretation for these operators as follows:</p>\n<p><code>&amp;</code>: the address of</p>\n<p><code>*</code>: the value of</p>\n<p>So when you say <code>&amp;x</code> it means \"the address of x\" and when you say <code>*x</code> it means \"the value that x points to\". So <code>*this</code> will always return a value.</p>\n<p>Just be sure that the function itself that the hosts the returning is not a reference function. Please remember that in C++ you can create functions with the &amp; or the * operators as well.</p>\n", "LastActivityDate": "2012-01-28T20:44:53.380", "CommentCount": "0", "CreationDate": "2012-01-28T20:44:53.380", "ParentId": "9048379", "Score": "0", "OwnerUserId": "1058538"}, "bq_ids": {"n4140": {"so_9048379_9048390_3": {"length": 24, "quality": 0.8888888888888888, "section_id": 6064}}, "n3337": {"so_9048379_9048390_3": {"length": 24, "quality": 0.8888888888888888, "section_id": 5832}}, "n4659": {"so_9048379_9048390_3": {"length": 23, "quality": 0.8518518518518519, "section_id": 7560}}}, "9048390": {"Id": "9048390", "PostTypeId": "2", "Body": "<h3>The expression <code>*this</code></h3>\n<blockquote>\n<p id=\"so_9048379_9048390_0\">At the end of the assignment was the line \"return *this,\" which they said returned a reference to the object that \"this\" points to</p>\n</blockquote>\n<p>They were wrong.</p>\n<blockquote>\n<p id=\"so_9048379_9048390_1\">Why does it return a reference?</p>\n</blockquote>\n<p>It doesn't.</p>\n<blockquote>\n<p id=\"so_9048379_9048390_2\">If \"this\" is being dereferenced, shouldn't it just return the object?</p>\n</blockquote>\n<p>Yes!</p>\n<p>Dereferencing a pointer yields an <em>lvalue</em>. That means that the result of <code>*this</code> is the actual object that <code>this</code> points to. It's not a reference, but it's not a copy either.</p>\n<blockquote>\n<p id=\"so_9048379_9048390_3\"><code>[C++11: 5.3.1/1]:</code> <strong>The unary <code>*</code> operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and the result is an lvalue referring to the object or function to which the expression points.</strong> If the type of the expression is \u201cpointer to <code>T</code>,\u201d the type of the result is \u201c<code>T</code>.\u201d [..]</p>\n</blockquote>\n<p>It can be hard to conceptualise, since you can never do this yourself in code; it's just a feature of the <code>*</code> operator for native pointers, and has been since C.</p>\n<hr>\n<h3>Returning from <code>operator=</code></h3>\n<p>Because you can't do it yourself, conventionally you'd bind that <em>lvalue</em> expression to a reference in order to use it in different contexts. For example, the expression <code>*this</code> in <code>return *this</code> gets bound to the return type of the function that you're returning from; in this case, an assignment operator.</p>\n<p>Now, we could have the assignment operator return by value in which case an object copy would be made from the lvalue that comes from <code>*this</code>; however, for an assignment operator we usually return by reference so that we avoid an almost-certainly needless copy, and can perform <em>chaining</em>:</p>\n<pre><code>Type a, b, c;\nc = b = a;\n</code></pre>\n<p>It's a convention with benefits, and no downsides. Can you think of a situation when you'd want <code>op=</code> to return by value?</p>\n</hr>", "LastEditorUserId": "560648", "LastActivityDate": "2012-01-28T20:42:58.923", "Score": "3", "CreationDate": "2012-01-28T20:36:23.113", "ParentId": "9048379", "CommentCount": "2", "OwnerUserId": "560648", "LastEditDate": "2012-01-28T20:42:58.923"}, "9048635": {"Id": "9048635", "PostTypeId": "2", "Body": "<p>Every dereferenced pointer is a reference to its pointee, else you'd 'loose' the pointee you're pointing to.</p>\n<p>Invoke method twice on the same object, using a pointer and a reference:</p>\n<pre><code>MyClass* objPtr = .... ;\nobjPtr-&gt;doSomething();\nMyClass&amp; objRef = *objPtr;\nobjRef.doSomething();\n</code></pre>\n<p>Invoke method on distinct objects; original and copy:</p>\n<pre><code>MyClass* objPtr = .... ;\nobjPtr-&gt;doSomething();\nMyClass objCopy = *objPtr; //here, the reference is passed to the (implicit or implemented) copy constructor if possible, else a compile time error occurs.\nobjCopy.doSomething();\n</code></pre>\n<p>That means, if you return a reference from an operator method which has MyClass (rvalue) instead of MyClass&amp; (lvalue) as return type, a copy of *this (MyClass&amp;) is created by reference (leaving aside return value optimizations and rvalue references).\nThis is useful for non modifying const methods such as + and - which have a new value as result while leaving the object on which this method was invoked unmodified.</p>\n<p>Operators like += and your assignment operator modify the object inplace by convention and should therefore return a reference to allow expressions like primitive types support it, since a temporary copy may vanish and cause unexpected results:</p>\n<p>Consider this expression:</p>\n<pre><code>int i = 4;\nint r = (i += 3) &lt;&lt;= 2;\n</code></pre>\n<p>The result r is 28 (added and shifted inplace).\nWhat is the value of i? 28 too, what else.</p>\n<p>But what if hypothetically int::operator+= would return a copy of itself instead of a reference to itself?</p>\n<p>The result r would be 28 too.</p>\n<p>But the value of i?\nIt would be 7, since the inplace left shift was applied to a temporary int returned from the addition which gets assigned to r after that.</p>\n<p>Continuing the assumption, the error may have the same effect (except for the value in i) as this expression: </p>\n<pre><code>int r = (i + 3) &lt;&lt;= 2;\n</code></pre>\n<p>But luckily, the compiler will complain, that he doesn't have an lvalue reference from (i + 3) to do the shift/assignment operation.</p>\n<p>But play with this:</p>\n<pre><code>class Int\n{\nprivate:\n    int val;\npublic:\n    Int(int val) :\n            val(val)\n    {\n    }\n\n    Int operator+(const Int&amp; other)const\n    {\n        return val + other.val;\n    }\n    Int operator+(int prim)const\n    {\n        return val + prim;\n    }\n\n    Int&amp; operator+=(const Int&amp; other)\n    {\n        val += other.val;\n        return *this;\n    }\n    //Error here, Int&amp; would be correct\n    Int operator+=(int prim)\n    {\n        val += prim;\n        return *this;\n    }\n\n    Int operator&lt;&lt;(const Int&amp; other)const\n    {\n        return val &lt;&lt; other.val;\n    }\n    Int operator&lt;&lt;(int prim)const\n    {\n        return val &lt;&lt; prim;\n    }\n\n    Int&amp; operator&lt;&lt;=(const Int&amp; other)\n    {\n        val &lt;&lt;= other.val;\n        return *this;\n    }\n    Int&amp; operator&lt;&lt;=(int prim)\n    {\n        val &lt;&lt;= prim;\n        return *this;\n    }\n\n    operator int()const{\n        return val;\n    }\n};\n\nint main()\n{\n    Int i = 4;\n    Int r = (i += 3) &lt;&lt;= 2;\n\n    cout &lt;&lt; i;\n    return 0;\n}\n</code></pre>\n", "LastEditorUserId": "1175253", "LastActivityDate": "2012-01-28T22:15:10.267", "Score": "1", "CreationDate": "2012-01-28T21:09:27.603", "ParentId": "9048379", "CommentCount": "0", "OwnerUserId": "1175253", "LastEditDate": "2012-01-28T22:15:10.267"}, "9048379": {"ViewCount": "226", "Body": "<p>In my C++ class they were discussing how to create an assignment operator.  At the end of the assignment was the line \"return *this,\" which they said returned a reference to the object that \"this\" points to.  Why does it return a reference?  If \"this\" is being dereferenced, shouldn't it just return the object?</p>\n", "AcceptedAnswerId": "9048404", "Title": "Why does \"return *this\" return a reference?", "CreationDate": "2012-01-28T20:34:11.633", "Id": "9048379", "CommentCount": "2", "LastEditDate": "2012-01-28T20:36:29.853", "PostTypeId": "1", "LastEditorUserId": "560648", "LastActivityDate": "2012-01-28T22:15:10.267", "Score": "0", "OwnerUserId": "892549", "Tags": "<c++>", "AnswerCount": "5"}});