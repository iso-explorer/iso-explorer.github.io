post_cb({"6326845": {"ParentId": "6326805", "CommentCount": "2", "Body": "<p>But why do you need it? Just put the class in the separate file and include namespaces you want in case if you don't want other classes reach them.</p>\n", "OwnerUserId": "585795", "PostTypeId": "2", "Id": "6326845", "Score": "-2", "CreationDate": "2011-06-13T05:03:33.543", "LastActivityDate": "2011-06-13T05:03:33.543"}, "6326856": {"ParentId": "6326805", "CommentCount": "0", "Body": "<p>Because the C++ standard explicitly forbids it.  From C++03 \u00a77.3.4 [namespace.udir]:</p>\n<pre>\n<i>using-directive</i>:\n    using namespace ::<sub>opt</sub> <i>nested-name-specifier</i><sub>opt</sub> <i>namespace-name</i> ;\n</pre>\n<blockquote>\n<p id=\"so_6326805_6326856_0\">A <em>using-directive</em> shall not appear in class scope, but may appear in namespace scope or in block scope. [Note: when looking up a namespace-name in a using-directive, only namespace names are considered, see 3.4.6. ]</p>\n</blockquote>\n<p>Why does the C++ standard forbid it?  I don't know, ask a member of the ISO committee that approved the language standard.</p>\n", "OwnerUserId": "9530", "PostTypeId": "2", "Id": "6326856", "Score": "24", "CreationDate": "2011-06-13T05:05:48.583", "LastActivityDate": "2011-06-13T05:05:48.583"}, "6326867": {"ParentId": "6326805", "PostTypeId": "2", "CommentCount": "14", "Body": "<p>I don't know exactly, but my guess is that allowing this at class scope could cause confusion:</p>\n<pre><code>namespace Hello\n{\n    typedef int World;\n}\n\nclass Blah\n{\n    using namespace Hello;\npublic:\n    World DoSomething();\n}\n\n//Should this be just World or Hello::World ?\nWorld Blah::DoSomething()\n{\n    //Is the using namespace valid in here?\n}\n</code></pre>\n<p>Since there is no obvious way of doing this, the standard just says you can't.</p>\n<p>Now, the reason this is less confusing when we're talking namespace scopes:</p>\n<pre><code>namespace Hello\n{\n    typedef int World;\n}\n\nnamespace Other\n{\n    using namespace Hello;\n    World DoSomething();\n}\n\n//We are outside of any namespace, so we have to fully qualify everything. Therefore either of these are correct:\n\n//Hello was imported into Other, so everything that was in Hello is also in Other. Therefore this is okay:\nOther::World Other::DoSomething()\n{\n    //We're outside of a namespace; obviously the using namespace doesn't apply here.\n    //EDIT: Apparently I was wrong about that... see comments. \n}\n\n//The original type was Hello::World, so this is okay too.\nHello::World Other::DoSomething()\n{\n    //Ditto\n}\n\nnamespace Other\n{\n    //namespace Hello has been imported into Other, and we are inside Other, so therefore we never need to qualify anything from Hello.\n    //Therefore this is unambiguiously right\n    World DoSomething()\n    {\n        //We're inside the namespace, obviously the using namespace does apply here.\n    }\n}\n</code></pre>\n", "OwnerUserId": "82320", "LastEditorUserId": "82320", "LastEditDate": "2011-06-13T19:11:15.153", "Id": "6326867", "Score": "25", "CreationDate": "2011-06-13T05:09:46.667", "LastActivityDate": "2011-06-13T19:11:15.153"}, "6326805": {"CommentCount": "8", "CreationDate": "2011-06-13T04:56:31.347", "PostTypeId": "1", "AcceptedAnswerId": "6326867", "LastEditorUserId": "514235", "LastActivityDate": "2011-06-13T19:11:15.153", "LastEditDate": "2011-06-13T05:10:20.640", "ViewCount": "30688", "FavoriteCount": "8", "Title": "Why \"using namespace X;\" is not allowed inside class/struct level?", "Id": "6326805", "Score": "54", "Body": "<pre><code>class C {\n  using namespace std;  // error\n};\nnamespace N {\n  using namespace std; // ok\n}\nint main () {\n  using namespace std; // ok\n}\n</code></pre>\n<p><strong>Edit</strong>: Want to know motivation behind it.</p>\n", "Tags": "<c++><namespaces><using><language-lawyer>", "OwnerUserId": "514235", "AnswerCount": "4"}, "bq_ids": {"n4140": {"so_6326805_6326856_0": {"section_id": 5509, "quality": 0.85, "length": 17}}, "n3337": {"so_6326805_6326856_0": {"section_id": 5295, "quality": 0.85, "length": 17}}, "n4659": {"so_6326805_6326856_0": {"section_id": 6944, "quality": 0.85, "length": 17}}}, "6327944": {"ParentId": "6326805", "CommentCount": "3", "Body": "<p>I believe that the rationale is that it would probably be confusing. Currently, while processing a class level identifier, lookup will first search in the class scope and then in the enclosing namespace. Allowing the <code>using namespace</code> at class level would have quite some side effects on how the lookup is now performed. In particular, it would have to be performed sometime between checking that particular class scope and checking the enclosing namespace. That is: 1) merge the class level and used namespace level lookups, 2) lookup the used namespace <em>after</em> the class scope but before any other class scope, 3) lookup the used namespace right before the enclosing namespace. 4) lookup merged with the enclosing namespace.</p>\n<ol>\n<li>This would make a big difference, where an identifier at class level would <em>shadow</em> any identifier in the enclosing namespace, but it would not <em>shadow</em> a <em>used</em> namespace. The effect would be strange, in that access to the <em>used</em> namespace from a class in a different namespace and from the same namespace would differ:</li>\n</ol>\n<p>.</p>\n<pre><code>namespace A {\n   void foo() {}\n   struct B {\n      struct foo {};\n      void f() {\n         foo();      // value initialize a A::B::foo object (current behavior)\n      }\n   };\n}\nstruct C {\n   using namespace A;\n   struct foo {};\n   void f() {\n      foo();         // call A::foo\n   }\n};\n</code></pre>\n<ol>\n<li>Lookup right after this class scope. This would have the strange effect of shadowing base classes' members. The current lookup does not mix class and namespace level lookups, and when performing class lookup it will go all the way to the base classes <em>before</em> considering the enclosing namespace. The behavior would be surprising in that it would not consider the namespace in a similar level to the enclosing namespace. Again, the <em>used</em> namespace would be prioritized over the enclosing namespace.</li>\n</ol>\n<p>.</p>\n<pre><code>namespace A {\n   void foo() {}\n}\nvoid bar() {}\nstruct base {\n   void foo();\n   void bar();\n};\nstruct test : base {\n   using namespace A;\n   void f() {\n      foo();           // A::foo()\n      bar();           // base::bar()\n   }\n};\n</code></pre>\n<ol>\n<li>Lookup right before the enclosing namespace. The problem with this approach is again that it would be surprising to many. Consider that the namespace is defined in a different translation unit, so that the following code cannot be seen all at once:</li>\n</ol>\n<p>.</p>\n<pre><code>namespace A {\n   void foo( int ) { std::cout &lt;&lt; \"int\"; }\n}\nvoid foo( double ) { std::cout &lt;&lt; \"double\"; }\nstruct test {\n   using namespace A;\n   void f() {\n      foo( 5.0 );          // would print \"int\" if A is checked *before* the\n                           // enclosing namespace\n   }\n};\n</code></pre>\n<ol>\n<li>Merge with the enclosing namespace. This would have the exact same effect that applying the <code>using</code> declaration at the namespace level. It would not add any new value to that, but will on the other hand complicate lookup for compiler implementors. Namespace identifier lookup is now independent from where in the code the lookup is triggered. When inside a class, if lookup does not find the identifier at class scope it will fall back to namespace lookup, but that is exactly the same namespace lookup that is used in a function definition, there is no need to maintain new state. When the <code>using</code> declaration is found at namespace level, the contents of the <em>used</em> namespace are <em>brought</em> into that namespace for <em>all</em> lookups involving the namespace. If <code>using namespace</code> was allowed at class level, there would be different outcomes for namespace lookup of the exact same namespace depending on where the lookup was triggered from, and that would make the implementation of the lookup much more complex for no additional value.</li>\n</ol>\n<p>Anyway, my recommendation is <strong>not</strong> to employ the <code>using namespace</code> declaration at all. It makes code simpler to reason with without having to keep all namespaces' contents in mind.</p>\n", "OwnerUserId": "36565", "PostTypeId": "2", "Id": "6327944", "Score": "8", "CreationDate": "2011-06-13T08:01:01.903", "LastActivityDate": "2011-06-13T08:01:01.903"}});