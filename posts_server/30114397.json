post_cb({"30114397": {"CommentCount": "4", "AcceptedAnswerId": "30114921", "PostTypeId": "1", "LastEditorUserId": "1708801", "CreationDate": "2015-05-08T01:35:49.663", "LastActivityDate": "2015-05-10T17:06:02.567", "LastEditDate": "2015-05-08T13:33:00.203", "ViewCount": "572", "FavoriteCount": "4", "Title": "\"constructing\" a trivially-copyable object with memcpy", "Id": "30114397", "Score": "9", "Body": "<p>In C++, is this code correct?</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n\nstruct T   // trivially copyable type\n{\n    int x, y;\n};\n\nint main()\n{\n    void *buf = std::malloc( sizeof(T) );\n    if ( !buf ) return 0;\n\n    T a{};\n    std::memcpy(buf, &amp;a, sizeof a);\n    T *b = static_cast&lt;T *&gt;(buf);\n\n    b-&gt;x = b-&gt;y;\n\n    free(buf);\n}\n</code></pre>\n<p>In other words, is <code>*b</code> an object whose lifetime has begun? (If so, when did it begin exactly?)</p>\n", "Tags": "<c++><language-lawyer><lifetime>", "OwnerUserId": "1505939", "AnswerCount": "3"}, "30114921": {"ParentId": "30114397", "PostTypeId": "2", "CommentCount": "9", "Body": "<p>This is unspecified which is supported by <a href=\"http://open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3751.pdf\">N3751: Object Lifetime, Low-level Programming, and\nmemcpy</a> which says amongst other things:</p>\n<blockquote>\n<p id=\"so_30114397_30114921_0\">The C++ standards is currently silent on whether the use of memcpy to\n  copy object representation bytes is conceptually an assignment or an\n  object construction. The difference does matter for semantics-based\n  program analysis and transformation tools, as well as optimizers,\n  tracking object lifetime. This paper suggests that</p>\n<ol>\n<li><p id=\"so_30114397_30114921_1\">uses of memcpy to copy the bytes of two distinct objects of two different trivial copyable tables (but otherwise of the same size) be\n  allowed</p></li>\n<li><p id=\"so_30114397_30114921_2\">such uses are recognized as initialization, or more generally as (conceptually) object construction.</p></li>\n</ol>\n<p id=\"so_30114397_30114921_3\">Recognition as object construction will support binary IO, while still\n  permitting lifetime-based analyses and optimizers.</p>\n</blockquote>\n<p>I can not find any meeting minutes that has this paper discussed, so it seems like it is still an open issue.</p>\n<p>The C++14 draft standard currently says in <code>1.8</code> <em>[intro.object]</em>:</p>\n<blockquote>\n<p id=\"so_30114397_30114921_4\">[...]An object is created by a definition (3.1), by a new-expression\n  (5.3.4) or by the implementation (12.2) when needed.[...]</p>\n</blockquote>\n<p>which we don't have with the <code>malloc</code> and the cases covered in the standard for copying trivial copyable types seem to only refer to already existing objects in section <code>3.9</code> <em>[basic.types]</em>:</p>\n<blockquote>\n<p id=\"so_30114397_30114921_5\">For any object (other than a base-class subobject) of trivially\n  copyable type T, whether or not the object holds a valid value of type\n  T, the underlying bytes (1.7) making up the object can be copied into\n  an array of char or unsigned char.42 If the content of the array of\n  char or unsigned char is copied back into the object, the object shall\n  subsequently hold its original value[...]</p>\n</blockquote>\n<p>and:</p>\n<blockquote>\n<p id=\"so_30114397_30114921_6\">For any trivially copyable type T, if two pointers to T point to\n  distinct T objects obj1 and obj2, where neither obj1 nor obj2 is a\n  base-class subobject, if the underlying bytes (1.7) making up obj1 are\n  copied into obj2,43 obj2 shall subsequently hold the same value as\n  obj1.[...]</p>\n</blockquote>\n<p>which is basically what the proposal says, so that should not be surprising.</p>\n<p>dyp points out a fascinating discussion on this topic from the <em>ub mailing list</em>: <a href=\"http://www.open-std.org/pipermail/ub/2013-September/000127.html\">[ub] Type punning to avoid copying</a>.</p>\n", "OwnerUserId": "1708801", "LastEditorUserId": "1708801", "LastEditDate": "2015-05-10T17:06:02.567", "Id": "30114921", "Score": "10", "CreationDate": "2015-05-08T02:41:48.817", "LastActivityDate": "2015-05-10T17:06:02.567"}, "30114590": {"ParentId": "30114397", "CommentCount": "14", "Body": "<p>From <a href=\"http://en.cppreference.com/w/cpp/language/lifetime\" rel=\"nofollow\">a quick search</a>.  </p>\n<blockquote>\n<p id=\"so_30114397_30114590_0\">\"... lifetime begins when the properly-aligned storage for the object is allocated and ends when the storage is deallocated or reused by another object.\"</p>\n</blockquote>\n<p>So, I would say by this definition, the lifetime begins with the allocation and ends with the free. </p>\n", "OwnerUserId": "977420", "PostTypeId": "2", "Id": "30114590", "Score": "3", "CreationDate": "2015-05-08T01:57:41.987", "LastActivityDate": "2015-05-08T01:57:41.987"}, "bq_ids": {"n4140": {"so_30114397_30114921_5": {"section_id": 7200, "quality": 0.9512195121951219, "length": 39}, "so_30114397_30114921_6": {"section_id": 7201, "quality": 0.9354838709677419, "length": 29}, "so_30114397_30114590_0": {"section_id": 7189, "quality": 0.6428571428571429, "length": 9}, "so_30114397_30114921_4": {"section_id": 5790, "quality": 0.7777777777777778, "length": 7}}, "n3337": {"so_30114397_30114921_5": {"section_id": 6944, "quality": 0.9512195121951219, "length": 39}, "so_30114397_30114921_6": {"section_id": 6945, "quality": 0.9354838709677419, "length": 29}, "so_30114397_30114590_0": {"section_id": 6933, "quality": 0.6428571428571429, "length": 9}, "so_30114397_30114921_4": {"section_id": 5563, "quality": 0.7777777777777778, "length": 7}}, "n4659": {"so_30114397_30114921_5": {"section_id": 8709, "quality": 0.8780487804878049, "length": 36}, "so_30114397_30114921_6": {"section_id": 8710, "quality": 0.9354838709677419, "length": 29}, "so_30114397_30114590_0": {"section_id": 8697, "quality": 0.7142857142857143, "length": 10}}}, "30114645": {"ParentId": "30114397", "PostTypeId": "2", "CommentCount": "2", "Body": "<blockquote>\n<p id=\"so_30114397_30114645_0\">Is this code correct?</p>\n</blockquote>\n<p>Well, it will usually \"work\", but only for trivial types.</p>\n<p>I know you did not ask for it, but lets use an example with a non-trivial type:</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;string&gt;\n\nstruct T   // trivially copyable type\n{\n    std::string x, y;\n};\n\nint main()\n{\n    void *buf = std::malloc( sizeof(T) );\n    if ( !buf ) return 0;\n\n    T a{};\n    a.x = \"test\";\n\n    std::memcpy(buf, &amp;a, sizeof a);    \n    T *b = static_cast&lt;T *&gt;(buf);\n\n    b-&gt;x = b-&gt;y;\n\n    free(buf);\n}\n</code></pre>\n<p>After constructing <code>a</code>, <code>a.x</code> is assigned a value.  Let's assume that <code>std::string</code> is not optimized to use a local buffer for small string values, just a data pointer to an external memory block. The <code>memcpy()</code> copies the internal data of <code>a</code> as-is into <code>buf</code>.  Now <code>a.x</code> and <code>b-&gt;x</code> refer to the same memory address for the <code>string</code> data.  When <code>b-&gt;x</code> is assigned a new value, that memory block is freed, but <code>a.x</code> still refers to it.  When <code>a</code> then goes out of scope at the end of <code>main()</code>, it tries to free the same memory block again.  Undefined behavior occurs.</p>\n<p>If you want to be \"correct\", the right way to construct an object into an existing memory block is to use the <strong>placement-new</strong> operator instead, eg:</p>\n<pre><code>#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n\nstruct T   // does not have to be trivially copyable\n{\n    // any members\n};\n\nint main()\n{\n    void *buf = std::malloc( sizeof(T) );\n    if ( !buf ) return 0;\n\n    T *b = new(buf) T; // &lt;- placement-new\n    // calls the T() constructor, which in turn calls\n    // all member constructors...\n\n    // b is a valid self-contained object,\n    // use as needed...\n\n    b-&gt;~T(); // &lt;-- no placement-delete, must call the destructor explicitly\n    free(buf);\n}\n</code></pre>\n", "OwnerUserId": "65863", "LastEditorUserId": "65863", "LastEditDate": "2015-05-08T02:43:26.987", "Id": "30114645", "Score": "-1", "CreationDate": "2015-05-08T02:04:13.937", "LastActivityDate": "2015-05-08T02:43:26.987"}});