post_cb({"37567362": {"CommentCount": "4", "ViewCount": "134", "CreationDate": "2016-06-01T11:28:10.023", "LastActivityDate": "2016-06-01T13:46:35.503", "Title": "Javas Class<?> equivalent in C++", "PostTypeId": "1", "Id": "37567362", "Score": "4", "Body": "<p>So I'm learning C++ and want to write an entity-component system. For that I need to know what type a component has when i add it to the entity. In java i would just do something like this:</p>\n<pre><code>Class&lt;?&gt; someClass = myComponent.class;\n</code></pre>\n<p>Is there something equivalent I can do in C++? I tried typeid(myComponent) but that doesn't work in situations like this.</p>\n<pre><code>ExtComponent* extended = new ExtComponent();\nComponent* base = dynamic_cast&lt;Component&gt;(extended);\nstd::cout &lt;&lt; typeid(base).name();\n</code></pre>\n<p>This returns \"class Component\" but i would want something that returns \"class ExtComponent\" in such a situation. How do I do this.</p>\n", "Tags": "<java><c++>", "OwnerUserId": "5235321", "AnswerCount": "2"}, "37570002": {"ParentId": "37567362", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2016-06-01T13:22:42.993", "Score": "2", "LastEditorUserId": "2104697", "LastEditDate": "2016-06-01T13:27:52.687", "Id": "37570002", "OwnerUserId": "2104697", "Body": "<p>When dealing with types, everything must be resolved at compile time. You can't resolve them at runtime. That's how C++works. To do things that change the type of an expression, you have to deal with templates.</p>\n<p>If we want to make a container that store a bunch of instance of various types, you need a way to remember which type it was. Since template instantiate a different function with each one their own address, we can use it to generate a unique id for a type:</p>\n<pre><code>template&lt;typename&gt;\nvoid type_id(){}\n\nusing type_id_t = void(*)();\n</code></pre>\n<p>Now, you can use this to store and retrieve in a safe way. Here I will use <code>std::any</code>, but you can replace it by <code>boost::any</code> if you don't have access to C++17 features. </p>\n<pre><code>struct Entity {\n    template&lt;typename T&gt;\n    void assign(T component) {\n        components[type_id&lt;T&gt;] = component;\n    }\n\n    template&lt;typename T&gt;\n    T&amp; retrieve() {\n        return std::any_cast&lt;T&gt;(components[type_id&lt;T&gt;]);\n    }\n\nprivate:\n    std::map&lt;type_id_t, std::any&gt; components;\n};\n</code></pre>\n<p>Here you go. You can try out your entity like this:</p>\n<pre><code>Entity entity;\n\nentity.assign(MyClass{});\n\nMyClass&amp; mc = entity.retreive&lt;MyClass&gt;();\n</code></pre>\n<p>This is a rubbish and simple implementation of entities. Usually, you try to keep entities and components packed into memory, and manage the lifetime of them using an entity manager.</p>\n", "LastActivityDate": "2016-06-01T13:27:52.687"}, "bq_ids": {"n4140": {"so_37567362_37567498_0": {"section_id": 6021, "quality": 0.9583333333333334, "length": 23}}, "n3337": {"so_37567362_37567498_0": {"section_id": 5789, "quality": 0.9583333333333334, "length": 23}}, "n4659": {"so_37567362_37567498_0": {"section_id": 7520, "quality": 0.9583333333333334, "length": 23}}}, "37567498": {"ParentId": "37567362", "PostTypeId": "2", "CommentCount": "2", "CreationDate": "2016-06-01T11:34:52.030", "Score": "6", "LastEditorUserId": "4932834", "LastEditDate": "2016-06-01T13:46:35.503", "Id": "37567498", "OwnerUserId": "4932834", "Body": "<p>If I understand you correctly you want to get <em>dynamic type</em> of object. (not type of variable itself, but to what that variable (<em>really</em>) refers)</p>\n<p>Typeid will work because:</p>\n<p>N3337 5.2.8/2:</p>\n<blockquote>\n<p id=\"so_37567362_37567498_0\">When typeid is applied to a glvalue expression <strong>whose type is a polymorphic class type</strong> (10.3), the result refers\n  to a std::type_info object representing <strong>the type of the most derived object</strong> (1.8) (<strong>that is, the dynamic\n  type</strong>) to which the glvalue refers[...]</p>\n</blockquote>\n<p>So, just add some virtual function (of alternatively virtual base class) to make, and their will do what you want.</p>\n<p>Also you'll have to apply <code>typeid</code> to object, not pointer (because that would return <code>type_info</code> for pointer, not object):</p>\n<pre><code>Base *b = new Base;\n...\ntypeid(*b); //not typeid(b)\n</code></pre>\n", "LastActivityDate": "2016-06-01T13:46:35.503"}});