post_cb({"15122053": {"ParentId": "15121477", "CommentCount": "0", "Body": "<pre><code>/usr/lib/gcc/i686-pc-cygwin/3.4.4/include/c++/bits/stl_algo.h: In function `_ForwardIterator std::upper_bound(_ForwardIterator, _ForwardIterator, const _Tp&amp;, _Compare) [with _ForwardIterator = std::_Rb_tree_iterator&lt;std::pair&lt;const double, std::string&gt; &gt;, _Tp = double, _Compare = bool (*)(std::pair&lt;double, std::string&gt;, double)]':\na.cpp:32:   instantiated from here\n/usr/lib/gcc/i686-pc-cygwin/3.4.4/include/c++/bits/stl_algo.h:2784: error: conversion from `const double' to non-scalar type `std::pair&lt;double, std::string&gt;' requested\n</code></pre>\n<p>stl is a stinky hairy monster of a mess when it comes to figuring out problems.  </p>\n<p>Your problem stems from the fact that a comparator typically compares two elements of the same type, but here you are trying to use it to compare a <code>pair&lt;double,string&gt;</code> and a <code>double</code>.  Thanks to the wonderfully magical obscurity of templates in c++, the compiler doesn't see the fact that your comparator uses two different types as a problem.  </p>\n<p>The implementation of lower_bound always passes the map element in as the first parameter and the comparison value as the right parameter, so you get away with your oddly typed comparator there.  But upper_bound swaps the parameter order around, so you get this type error.  It's trying to stick a double in where a pair is supposed to go.</p>\n<p>Also, you're passing the wrong kind of comparator to <code>upper_bound</code>.  Generally, you should be passing the same \"&lt;\" comparator to both functions.  </p>\n<p>Like others said, using <code>map::upper_bound(keytype&amp;)</code> is a better idea.</p>\n", "OwnerUserId": "1134885", "PostTypeId": "2", "Id": "15122053", "Score": "1", "CreationDate": "2013-02-27T20:46:11.200", "LastActivityDate": "2013-02-27T20:46:11.200"}, "15121837": {"ParentId": "15121477", "CommentCount": "0", "Body": "<p>Your function gte is wrong. it has to be</p>\n<pre><code>bool gte (const double y, pair&lt;double,string&gt; x) {\n  return (x.first-y)&gt;.001;\n}\n</code></pre>\n", "OwnerUserId": "600522", "PostTypeId": "2", "Id": "15121837", "Score": "1", "CreationDate": "2013-02-27T20:34:16.317", "LastActivityDate": "2013-02-27T20:34:16.317"}, "15121738": {"ParentId": "15121477", "LastEditDate": "2013-02-27T20:42:50.717", "CommentCount": "2", "CreationDate": "2013-02-27T20:28:10.327", "OwnerUserId": "1932150", "LastEditorUserId": "1932150", "PostTypeId": "2", "Id": "15121738", "Score": "2", "Body": "<p><strong>IMPORTANT:</strong> This answer explains <strong>why you are getting a compilation error</strong>. However, when available, you should always prefer the member-function versions of an algorithm to the free-function version, because they offer better complexity guarantees.</p>\n<p>Thus, use <code>std::map::upper_bound()</code> and <code>std::map::lower_bound</code>. This said, the following explains why you are getting a compile-time error.</p>\n<hr>\n<p>The order of the arguments of <code>sdt::lower_bound</code> and <code>std::upper_bound</code> is <strong>swapped</strong>. See Paragraphs 25.4.3.1-2 of the C++11 Standard:</p>\n<p>25.4.3.1 <code>lower_bound [lower.bound]</code></p>\n<pre><code> template&lt;class ForwardIterator, class T, class Compare&gt;\n ForwardIterator  lower_bound(\n     ForwardIterator first, \n     ForwardIterator last, \n     const T&amp; value, \n     Compare comp\n     );\n</code></pre>\n<blockquote>\n<p id=\"so_15121477_15121738_0\">1 <em>Requires</em>: The elements e of [first,last) shall be partitioned with respect to the expression <strong>e &lt; value or comp(e, value).</strong></p>\n<p id=\"so_15121477_15121738_1\">2 <em>Returns</em>: The furthermost iterator i in the range [first,last] such that for any iterator j in the range [first,i) the following corresponding conditions hold: <strong>*j &lt; value or comp(*j, value) != false</strong>.</p>\n<p id=\"so_15121477_15121738_2\">[...]</p>\n</blockquote>\n<p>25.4.3.2 <code>upper_bound [upper.bound]</code></p>\n<pre><code>template&lt;class ForwardIterator, class T&gt;\nForwardIterator upper_bound(\n    ForwardIterator first, \n    ForwardIterator last,\n    const T&amp; value);\n    Compare comp\n    );\n</code></pre>\n<blockquote>\n<p id=\"so_15121477_15121738_3\">1 <em>Requires</em>: The elements e of [first,last) shall be partitioned with respect to the expression <strong>!(value &lt; e) or !comp(value, e).</strong></p>\n<p id=\"so_15121477_15121738_4\">2 <em>Returns</em>: The furthermost iterator i in the range [first,last] such that for any iterator j in the\n  range [first,i) the following corresponding conditions hold: <strong>!(value &lt; *j) or comp(value, *j)</strong>\n  == false.</p>\n<p id=\"so_15121477_15121738_5\">[...]</p>\n</blockquote>\n<p>You should modify your comparator function accordingly:</p>\n<pre><code>bool lte (pair&lt;double, string&gt; x, const double y) {\n  ...\n}\n\nbool gte (const double y, pair&lt;double,string&gt; x) {\n  ...\n}\n</code></pre>\n<p>Also, the <code>value_type</code> of an <code>std::map&lt;A, B&gt;</code> is not <code>std::pair&lt;A, B&gt;</code>, but rather <code>std::pair&lt;A const, B&gt;</code>. To avoid useless conversions and copies, I suggest using the following signatures:</p>\n<pre><code>bool lte (pair&lt;double const,string&gt; const&amp; x, double const y) {\n//                    ^^^^^         ^^^^^^\n  ...\n}\n\nbool gte (double const y, pair&lt;double const, string&gt; const&amp; x) {\n//                                    ^^^^^  ^^^^^^\n  ...\n}\n</code></pre>\n</hr>", "LastActivityDate": "2013-02-27T20:42:50.717"}, "15121744": {"ParentId": "15121477", "LastEditDate": "2013-02-27T20:35:16.253", "CommentCount": "4", "CreationDate": "2013-02-27T20:28:24.620", "OwnerUserId": "5987", "LastEditorUserId": "5987", "PostTypeId": "2", "Id": "15121744", "Score": "3", "Body": "<p>The comparison function you use should be strictly less-than, not less-than-or-equal. The algorithm might fail otherwise.</p>\n<p>For efficiency's sake you should use the <a href=\"http://en.cppreference.com/w/cpp/container/map/upper_bound\" rel=\"nofollow\">member function <code>upper_bound</code></a> built into the map, rather than the one in <code>algorithm</code>.</p>\n<p>If you need to account for a miss due to floating point mismatches, do it as a step after.</p>\n<pre><code>map&lt;double,string&gt;::iterator it;\nit = myMap.upper_bound(15.0);\nif (it != myMap.begin())\n{\n    map&lt;double,string&gt;::iterator it2 = it;\n    --it2;\n    if (it2-&gt;first &gt; 15.0 - 0.001)\n        it = it2;\n}\n</code></pre>\n", "LastActivityDate": "2013-02-27T20:35:16.253"}, "15121477": {"CommentCount": "0", "ViewCount": "3942", "CreationDate": "2013-02-27T20:14:20.720", "LastActivityDate": "2013-02-27T20:46:11.200", "PostTypeId": "1", "AcceptedAnswerId": "15121738", "FavoriteCount": "1", "Title": "How can I find the first element of a map where key is greater than val", "Id": "15121477", "Score": "0", "Body": "<p>I have a <code>map&lt;double,T&gt;</code> (say <code>T==string</code>) and I wanted to find the first element of the map such that the key was greater than a given number. I looked in <code>&lt;algorithm&gt;</code> and find <a href=\"http://www.cplusplus.com/reference/algorithm/upper_bound/\" rel=\"nofollow\">upper_bound</a> and <a href=\"http://www.cplusplus.com/reference/algorithm/lower_bound/\" rel=\"nofollow\">lower_bound</a>.</p>\n<p>Strangely I can get the first above using <code>lower_bound</code> but not <code>upper_bound</code>, what am I doing wrong?</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;algorithm&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nbool lte (pair&lt;double,string&gt; x, const double y) {\n  return (x.first-y)&lt;.001;\n}\nbool gte (pair&lt;double,string&gt; x, const double y) {\n  return (x.first-y)&gt;.001;\n}\nint main()\n{\n    map&lt;double,string&gt; myMap;\n    myMap[10.01] = \"A\";\n    myMap[14.62] = \"B\";\n    myMap[16.33] = \"C\";\n    myMap[45.23] = \"D\";\n    myMap[0.23] = \"E\";\n\n    map&lt;double,string&gt;::iterator it;\n    for(it = myMap.begin(); it != myMap.end() ; it++){\n        cout &lt;&lt; it-&gt;first &lt;&lt; \" =&gt; \" &lt;&lt; it-&gt;second &lt;&lt; endl;\n    }\n\n    map&lt;double,string&gt;::iterator firstAbove_1;\n    firstAbove_1 = lower_bound(myMap.begin(), myMap.end(), 15., lte); //\n    cout &lt;&lt; \"first greater that 15 is \" &lt;&lt; firstAbove_1-&gt;second &lt;&lt; '\\n';\n\n    //map&lt;double,string&gt;::iterator firstAbove_2;\n    //firstAbove_2 = upper_bound (myMap.begin(), myMap.end(), 15., gte); //         ^\n    //cout &lt;&lt; \"first greater that 15 is \" &lt;&lt; firstAbove_2-&gt;second &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre>\n", "Tags": "<c++><map><stl><stl-algorithm><upperbound>", "OwnerUserId": "1846968", "AnswerCount": "6"}, "15121923": {"ParentId": "15121477", "CommentCount": "0", "Body": "<p>First of all it's better to use <code>map::lower_bound</code> and <code>map::upper_bound</code> because they will work in <code>O(log n) operations</code>. Not only <code>O(log n) comparsions</code>.</p>\n<p>Anyway I would use <code>lower/upper_bound</code> without predicate but using value (15. + .001)</p>\n", "OwnerUserId": "768110", "PostTypeId": "2", "Id": "15121923", "Score": "1", "CreationDate": "2013-02-27T20:38:51.847", "LastActivityDate": "2013-02-27T20:38:51.847"}, "bq_ids": {"n4140": {"so_15121477_15121738_1": {"section_id": 1423, "quality": 0.7777777777777778, "length": 14}, "so_15121477_15121738_4": {"section_id": 1426, "quality": 0.7647058823529411, "length": 13}, "so_15121477_15121738_3": {"section_id": 1425, "quality": 0.5555555555555556, "length": 5}, "so_15121477_15121738_0": {"section_id": 1422, "quality": 0.7, "length": 7}}, "n3337": {"so_15121477_15121738_1": {"section_id": 1417, "quality": 0.7777777777777778, "length": 14}, "so_15121477_15121738_4": {"section_id": 1420, "quality": 0.7647058823529411, "length": 13}, "so_15121477_15121738_3": {"section_id": 1419, "quality": 0.5555555555555556, "length": 5}, "so_15121477_15121738_0": {"section_id": 1416, "quality": 0.7, "length": 7}}, "n4659": {"so_15121477_15121738_1": {"section_id": 1543, "quality": 0.7777777777777778, "length": 14}, "so_15121477_15121738_3": {"section_id": 1545, "quality": 0.5555555555555556, "length": 5}, "so_15121477_15121738_4": {"section_id": 1546, "quality": 0.7647058823529411, "length": 13}, "so_15121477_15121738_0": {"section_id": 1542, "quality": 0.7, "length": 7}}}, "15121615": {"ParentId": "15121477", "LastEditDate": "2013-02-27T20:31:06.080", "CommentCount": "1", "CreationDate": "2013-02-27T20:20:51.893", "OwnerUserId": "335858", "LastEditorUserId": "335858", "PostTypeId": "2", "Id": "15121615", "Score": "2", "Body": "<p>The <code>gte</code> should be</p>\n<pre><code>bool gte (const double y, pair&lt;double,string&gt; x) {\n    return (y-x.first)&lt;.001;\n}\n</code></pre>\n<p>because you need to switch the arguments around. This gives you the results that you want, yet it is not ideal, because the comparison function is not symmetric. Anyone reading this code would need to pay a lot of attention to what's goes on what side of the comparison to make sense of what you are doing.</p>\n<p>Your program would be more readable if you use member functions <code>lower_bound</code> and <code>upper_bound</code> from your <code>std::map</code>, as opposed to range-based <code>std::lower_bound</code> and <code>std::upper_bound</code>:</p>\n<pre><code>firstAbove_1 = myMap.lower_bound(15.0);\nfirstAbove_2 = myMap.upper_bound(15.0);\n</code></pre>\n<p>Here are the results of running this:</p>\n<pre><code>0.23 =&gt; E\n10.01 =&gt; A\n14.62 =&gt; B\n16.33 =&gt; C\n45.23 =&gt; D\nfirst greater than 15 is C\nfirst greater than 15 is C\n</code></pre>\n<p><a href=\"http://ideone.com/UZT328\" rel=\"nofollow\">Here is a demo on ideone.</a></p>\n", "LastActivityDate": "2013-02-27T20:31:06.080"}});