post_cb({"47736562": {"Id": "47736562", "PostTypeId": "2", "Body": "<p>The rules of the language explicitly state that if the type of the reference is reference-compatible with the type of the lvalue initializer then the reference is bound <em>directly</em> to the initializer. See 8.6.3/5</p>\n<blockquote>\n<p id=\"so_47736479_47736562_0\"><strong>5</strong> A reference to type \u201ccv1 T1\u201d is initialized by an expression of type \u201ccv2 T2\u201d as follows:<br>\n  \u2014 If the reference is an lvalue reference and the initializer expression<br>\n  \u2014 is an lvalue (but is not a bit-field), and \u201ccv1 T1\u201d is reference-compatible with \u201ccv2 T2\u201d,<br>\n  [...]<br>\n  then the reference is bound to the initializer expression lvalue.</br></br></br></br></p>\n</blockquote>\n<p>Reference-compatibility allows extra cv-qualifications in the reference type. So, despite your extra <code>const</code> in your reference type the language still requires it to be bound directly to <code>i</code>. In other words, in your first example the types actually <em>do</em> match.</p>\n<p>In your second example the types are very different, not reference-compatible with each other. Direct binding of reference does not take place.</p>\n", "LastEditorUserId": "187690", "LastActivityDate": "2017-12-10T06:53:50.387", "Score": "3", "CreationDate": "2017-12-10T06:43:38.523", "ParentId": "47736479", "CommentCount": "0", "OwnerUserId": "187690", "LastEditDate": "2017-12-10T06:53:50.387"}, "47736550": {"Id": "47736550", "PostTypeId": "2", "Body": "<p>You have two different cases on your hands. Here</p>\n<pre><code>int i = 42; \nconst int &amp;r2 = i;\n</code></pre>\n<p>You have an object. And a const reference of the same type. <code>r2</code> may be bound to <code>i</code> directly. You may not use <code>r2</code> to modify <code>i</code>, but <code>i</code> itself isn't const. You essentially created a const view of the object. </p>\n<p>This is by design, and when you think about it, very useful. Say we want to print a <code>std::vector</code> of a million objects. Our function should be passed a reference, and it better not modify the vector. So passing by \"const view\" of the vector is exactly what we need.</p>\n<p>In the other case, you have an object of one type, and a reference to a completely unrelated type. The reference cannot bind directly, so indeed we get a temporary <code>int</code> created for it to bind with. That temporary and the original object are separate. As you observed.</p>\n", "LastActivityDate": "2017-12-10T06:41:12.470", "Score": "1", "CreationDate": "2017-12-10T06:41:12.470", "ParentId": "47736479", "CommentCount": "0", "OwnerUserId": "817643"}, "bq_ids": {"n4140": {"so_47736479_47736562_0": {"length": 25, "quality": 1.0, "section_id": 3321}}, "n3337": {"so_47736479_47736562_0": {"length": 25, "quality": 1.0, "section_id": 3191}}, "n4659": {"so_47736479_47736562_0": {"length": 25, "quality": 1.0, "section_id": 4087}}}, "47736529": {"Id": "47736529", "PostTypeId": "2", "Body": "<p>In the double case you are binding an const int reference so in that case a temporary (the conversion) is required, in the first case you are saying that the value can't be changed through the reference but nothing prevents the original from being altered.</p>\n<p>Think of cases like a const volatile int &amp; i = ...; There you are explicitly telling the compiler that i might change for reason that the compiler can not deduce.</p>\n", "LastActivityDate": "2017-12-10T06:38:12.140", "Score": "0", "CreationDate": "2017-12-10T06:38:12.140", "ParentId": "47736479", "CommentCount": "1", "OwnerUserId": "7594711"}, "47736479": {"ViewCount": "63", "Body": "<p>What I expected would happen was that since the types of reference and i do not match i must have been converted to a temporary and then assigned to r2 but when I changed i explicitly to 53 r2 was changed as well</p>\n<pre><code>int i = 42; \nconst int &amp;r2 = i; \n\ni = 53;\nstd::cout &lt;&lt; r2&lt;&lt;\"\\n\";\n\nreturn 0;\n</code></pre>\n<p>The same does not happen when I use double</p>\n<pre><code>double i = 42.4; \nconst int &amp;r2 = i; \n\ni = 53.7;\nstd::cout &lt;&lt; r2&lt;&lt;\"\\n\";\n\nreturn 0;\n</code></pre>\n<p>Here the value that was printed was as expected 42</p>\n", "AcceptedAnswerId": "47736562", "Title": "Why does the value of reference to const int(bound to an int) changes when the value of the int is explicitly changed?", "CreationDate": "2017-12-10T06:28:51.900", "Id": "47736479", "CommentCount": "5", "PostTypeId": "1", "LastActivityDate": "2017-12-10T07:32:21.243", "Score": "1", "OwnerUserId": "8364849", "Tags": "<c++>", "AnswerCount": "4"}, "47736808": {"Id": "47736808", "PostTypeId": "2", "Body": "<p>before assigning to the reference of different type, the type conversion happens and the value will be stored in different location, to which reference will point to. r2 will not point to i if its of different type.  in your case <code>cvttsd2si</code> will called and double value will be converted to signed double word integer.\nCheck the assembly code generated for both the version of code below.</p>\n<p>For different type</p>\n<pre><code> #double i = 42 ;\n movsd   .LC0(%rip), %xmm0   #, tmp90\n movsd   %xmm0, -8(%rbp) # tmp90, i\n # *.cpp:6:     const int &amp;r2 = i; \n movsd   -8(%rbp), %xmm0 # i, tmp91\n cvttsd2si   %xmm0, %eax # tmp91, _2\n movl    %eax, -20(%rbp) # _2, D.39824\n leaq    -20(%rbp), %rax #, tmp92\n movq    %rax, -16(%rbp) # tmp92, r2\n</code></pre>\n<p>When the variable and reference are same type.</p>\n<pre><code># *.cpp:5:     int i = 42;           \nmovl    $42, -12(%rbp)  #, i       \n# *.cpp:6:     const int &amp;r2 = i; \nleaq    -12(%rbp), %rax #, tmp89\nmovq    %rax, -8(%rbp)  # tmp89, r2\n</code></pre>\n", "LastActivityDate": "2017-12-10T07:32:21.243", "Score": "0", "CreationDate": "2017-12-10T07:32:21.243", "ParentId": "47736479", "CommentCount": "0", "OwnerUserId": "5863848"}});