post_cb({"bq_ids": {"n4140": {"so_26021209_28245830_0": {"length": 18, "quality": 1.0, "section_id": 3327}, "so_26021209_28244940_0": {"length": 30, "quality": 0.8823529411764706, "section_id": 6955}}, "n3337": {"so_26021209_28245830_0": {"length": 16, "quality": 0.8888888888888888, "section_id": 3197}, "so_26021209_28244940_0": {"length": 30, "quality": 0.8823529411764706, "section_id": 6702}}, "n4659": {"so_26021209_28245830_0": {"length": 14, "quality": 0.7777777777777778, "section_id": 4093}, "so_26021209_28244940_0": {"length": 30, "quality": 0.8823529411764706, "section_id": 8452}}}, "26021209": {"ViewCount": "1067", "Body": "<p>Reading the answer to <a href=\"https://stackoverflow.com/questions/13243578/stdinitializer-list-and-a-reference-parameter\">this question</a>, I was surprised to find that <code>std::min(std::initializer_list&lt;T&gt;)</code> takes its arguments by value. </p>\n<p>If you use <code>std::initializer_list</code> in the way implied by its name, i.e. as an initializer to some object, I understand that we don't care about copying its elements since they will be copied anyway to initialize the object. However, in this case here we most likely don't need any copy, so it would seem much more reasonable to take the arguments as <code>std::initializer_list&lt;const T&amp;&gt;</code> if only it were possible.</p>\n<p>What's the best practice for this situation? Should you not call the <code>initializer_list</code> version of <code>std::min</code> if you care about not making unnecessary copies, or is there some other trick to avoid the copy?</p>\n", "Title": "Why does std::min(std::initializer_list<T>) take arguments by value?", "CreationDate": "2014-09-24T15:46:33.900", "LastActivityDate": "2015-10-13T16:17:15.580", "CommentCount": "15", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:58:20.520", "LastEditorUserId": "-1", "Id": "26021209", "Score": "8", "OwnerUserId": "1734710", "Tags": "<c++><c++11><std><min><c++-standard-library>", "AnswerCount": "2"}, "28244940": {"Id": "28244940", "PostTypeId": "2", "Body": "<p>To sum up the comments:</p>\n<p>An <code>std::initializer_list</code> is supposed to be a lightweight proxy as described on  <a href=\"http://en.cppreference.com/w/cpp/utility/initializer_list\" rel=\"nofollow\">cppreference.com</a>.\nTherefore a copy of an initializer list should be very fast since the underlying elements are not copied:</p>\n<p><strong>C++11 \u00a718.9/2</strong></p>\n<blockquote>\n<p id=\"so_26021209_28244940_0\">An object of type <code>initializer_list&lt;E&gt;</code> provides access to an array of objects of type <code>const E.</code>\n  [ <em>Note:</em>\n  A pair of pointers or a pointer plus a length would be obvious representations for <code>initializer_list</code>.\n  <code>initializer_list</code> is used to implement initializer lists as specified in 8.5.4. Copying an initializer list does not copy the underlying elements.  \u2014 <em>end note</em> ]</p>\n</blockquote>\n<p>Using a reference though would boil down to using a pointer and therefore an additional indirection.</p>\n<p>The actual problem of <code>std::min</code> therefore is not that it takes the <code>initializer_list</code> by value, but rather, that the arguments to <code>initializer_list</code> have to be copied if they are computed at runtime. [1]\nThat the benchmark at [1] was broken as found out <a href=\"http://nd.home.xs4all.nl/dekkerware/issues/n2772_fix/draft_november_2009.htm\" rel=\"nofollow\">later</a> is unfortunate.</p>\n<pre><code>auto min_var = std::min({1, 2, 3, 4, 5}); // fast\nauto vec = std::vector&lt;int&gt;{1, 2, 3, 4, 5};\nmin_var = std::min({vec[0], vec[1], vec[2], vec[3], vec[4]}); // slow\n</code></pre>\n<p>[1]: <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2722.pdf\" rel=\"nofollow\">N2722</a> p. 2</p>\n", "LastEditorUserId": "3893186", "LastActivityDate": "2015-01-30T21:59:49.497", "Score": "2", "CreationDate": "2015-01-30T21:30:14.250", "ParentId": "26021209", "CommentCount": "4", "OwnerUserId": "3893186", "LastEditDate": "2015-01-30T21:59:49.497"}, "28245830": {"Id": "28245830", "PostTypeId": "2", "Body": "<p>There is no such thing as <code>std::initializer_list&lt;const T&amp;&gt;</code>.  Initializer lists can only hold objects by value.</p>\n<p>See [dcl.init.list]/5:</p>\n<blockquote>\n<p id=\"so_26021209_28245830_0\">An object of type <code>std::initializer_list&lt;E&gt;</code> is constructed from an initializer list as if the implementation allocated a temporary array of N elements of type <code>const E</code>, where N is the number of elements in the initializer list.</p>\n</blockquote>\n<p>There are no arrays of references, so there cannot be an <code>initializer_list</code> of references either.</p>\n<p>My suggestion in this circumstance would be to write a replacement for <code>std::min</code> which takes a variadic template of forwarding references. This works (although I'm sure it can be improved):</p>\n<pre><code>template&lt;typename T, typename... Args&gt;\nT vmin( T arg1, Args&amp;&amp;... args )\n{\n    T *p[] = { &amp;arg1, &amp;args... };\n\n    return **std::min_element( begin(p), end(p), \n            [](T *a, T *b) { return *a &lt; *b; } );\n}\n</code></pre>\n<p><a href=\"http://ideone.com/IfOL44\" rel=\"nofollow\">See it working</a> - using <code>min</code> or <code>mmin</code>, two extra copies are made (for <code>a</code> and <code>b</code>).</p>\n", "LastEditorUserId": "1505939", "LastActivityDate": "2015-01-31T01:38:26.917", "Score": "4", "CreationDate": "2015-01-30T22:40:32.830", "ParentId": "26021209", "CommentCount": "0", "OwnerUserId": "1505939", "LastEditDate": "2015-01-31T01:38:26.917"}});