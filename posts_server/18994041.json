post_cb({"18994041": {"ViewCount": "285", "Body": "<p>Consider an example where a method is pure virtual, takes a parameter of a templated type (injected from an outer type), and that templated type is a local type (defined in a function body). This scenario causes a compile-time error under g++. Admittedly, this is quite a corner case, but it does originate from real code. Here's a compilable, reproducible example:</p>\n<pre><code>#include &lt;cstdio&gt;\n\ntemplate&lt;typename T&gt;\nstruct Outer\n{\n    struct InnerBase\n    {\n        virtual void foo(T const&amp;) = 0;\n        virtual void bar(T const&amp;) {  };\n    };\n\n    struct InnerDerived : public InnerBase\n    {\n        void foo(T const&amp;) override { std::printf(\"virtual call foo() worked\\n\"); }\n        void bar(T const&amp;) override { std::printf(\"virtual call bar() worked\\n\"); }\n    };\n\n    InnerBase* inner;\n    Outer() : inner(new InnerDerived()) {  }\n};\n\n\nstruct NonLocalStruct { };\n\nint main()\n{\n    struct LocalStruct { };\n\n    Outer&lt;NonLocalStruct&gt; a;\n    Outer&lt;LocalStruct&gt;    b;\n\n    a.inner-&gt;foo(NonLocalStruct());     // fine\n    a.inner-&gt;bar(NonLocalStruct());     // fine\n    b.inner-&gt;foo(LocalStruct());        // causes error\n    b.inner-&gt;bar(LocalStruct());        // fine\n\n    return 0;\n}\n</code></pre>\n<p>Can someone explain why this causes a compile error? Why does it work with non-local types but not local ones? Why do non-pure virtual methods work but not pure ones?</p>\n<p>I'm using g++ 4.8.1 with -std=c++11 (I've also tried this example in VS2010 and it compiles and runs without errors).</p>\n<p>The exact error from g++ is:</p>\n<blockquote>\n<p id=\"so_18994041_18994041_0\">test.cpp:8:16: error: 'void Outer::InnerBase::foo(const T&amp;) [with T = main()::LocalStruct]', declared using local type 'const main()::LocalStruct', is used but never defined [-fpermissive]</p>\n</blockquote>\n", "AcceptedAnswerId": "18997863", "Title": "Templates, inner structs, local types, and pure virtual functions, oh my", "CreationDate": "2013-09-24T23:56:44.597", "Id": "18994041", "CommentCount": "2", "PostTypeId": "1", "LastActivityDate": "2013-09-25T06:51:58.143", "Score": "3", "OwnerUserId": "21475", "Tags": "<templates><c++11><g++><pure-virtual>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_18994041_18997863_1": {"length": 8, "quality": 0.6153846153846154, "section_id": 7141}}, "n3337": {"so_18994041_18997863_1": {"length": 8, "quality": 0.6153846153846154, "section_id": 6885}}, "n4659": {"so_18994041_18997863_1": {"length": 8, "quality": 0.6153846153846154, "section_id": 8642}}}, "18997863": {"Id": "18997863", "PostTypeId": "2", "Body": "<p>My guess is that this is a g++ bug, that is somehow related to an old C++98 restriction on the use of local classes as template parameters</p>\n<blockquote>\n<p id=\"so_18994041_18997863_0\">// C++98 Standard</p>\n<p id=\"so_18994041_18997863_1\"><strong>14.3.1/2</strong>: A local type, a type with no linkage, an unnamed type or a type compounded from any of these types shall not be used as a\n  template-argument for a template type-parameter.</p>\n</blockquote>\n<p>In C++11, this restriction has been lifted. As you note, Visual Studio compiles this correctly, and so does Clang. As a work-around, adding the definition of the abstract function works with g++</p>\n<pre><code>template&lt;typename T&gt;\nvoid Outer&lt;T&gt;::InnerBase::foo(T const&amp;) {};\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/a340548561f8829c\" rel=\"nofollow\"><strong>Live Example</strong></a>. </p>\n<p>I think you should submit a <a href=\"http://gcc.gnu.org/bugs/\" rel=\"nofollow\"><strong>bug report</strong></a> to g++.</p>\n", "LastEditorUserId": "819272", "LastActivityDate": "2013-09-25T06:51:58.143", "Score": "1", "CreationDate": "2013-09-25T06:36:26.607", "ParentId": "18994041", "CommentCount": "1", "OwnerUserId": "819272", "LastEditDate": "2013-09-25T06:51:58.143"}});