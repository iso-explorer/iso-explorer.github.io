post_cb({"1751368": {"ParentId": "1751346", "PostTypeId": "2", "CommentCount": "0", "Body": "<pre><code>int64_t s_val = SOME_SIGNED_VALUE;\nuint64_t u_val = static_cast&lt;uint64_t&gt;(s_val);\n</code></pre>\n<p>C++ Standard 4.7/2 states that:</p>\n<blockquote>\n<p id=\"so_1751346_1751368_0\">If the destination type is unsigned, the resulting value is the least unsigned integer congruent to the source integer (modulo 2<sup>n</sup> where n is the number of bits used to represent the unsigned type).  [Note: In a two\u2019s complement representation, this conversion is conceptual and there is no change in the bit pattern (if there is no truncation).  ]</p>\n</blockquote>\n<p>From the other hand, Standard says that \"The mapping performed by <code>reinterpret_cast</code> is implementation-defined.  [Note: it might, or might not, produce a representation different from the original value.  ]\" (5.2.10/3). So, I'd recommend to use <code>static_cast</code>.</p>\n", "OwnerUserId": "123111", "LastEditorUserId": "123111", "LastEditDate": "2009-11-17T20:23:21.817", "Id": "1751368", "Score": "27", "CreationDate": "2009-11-17T19:59:49.680", "LastActivityDate": "2009-11-17T20:23:21.817"}, "1751381": {"ParentId": "1751346", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>You can also <code>reinterpret_cast</code> it, or use a <code>union</code>:</p>\n<pre><code>union {\n   int64_t i64;\n   uint64_t ui64;\n} variable;\n\nvariable.i64 = SOME_SIGNED_VALUE;\nuint64_t a_copy = variable.ui64;\n</code></pre>\n", "OwnerUserId": "6610", "LastEditorUserId": "6610", "LastEditDate": "2009-11-17T20:06:59.753", "Id": "1751381", "Score": "2", "CreationDate": "2009-11-17T20:01:59.747", "LastActivityDate": "2009-11-17T20:06:59.753"}, "1751690": {"ParentId": "1751346", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>Note that you don't need the cast at all.  For all the wrangling about whether the cast will munge bits or not for negative representations, one thing has gotten lost - the cast is completely unnecessary.</p>\n<p>Because of the conversions that C/C++ will do (and how casting is defined), this:</p>\n<pre><code>int64_t s_val = SOME_SIGNED_VALUE;\nuint64_t u_val = s_val;\n</code></pre>\n<p>is exactly equivalent to:</p>\n<pre><code>int64_t s_val = SOME_SIGNED_VALUE;\nuint64_t u_val = static_cast&lt;uint64_t&gt;(s_val);\n</code></pre>\n<p>That said, you might still want the cast because it signals intent.  However, I've heard it argued that you shouldn't use unnecessary casts because it can silence the compiler in situations where you might <em>want</em> a warning.</p>\n<p>Pick your poison.</p>\n", "OwnerUserId": "12711", "LastEditorUserId": "12711", "LastEditDate": "2011-06-03T05:52:56.547", "Id": "1751690", "Score": "10", "CreationDate": "2009-11-17T20:53:34.480", "LastActivityDate": "2011-06-03T05:52:56.547"}, "42496803": {"ParentId": "1751346", "CommentCount": "0", "Body": "<p>Wanted to share this C++14 modern, generic solution. Originally demonstrated <a href=\"https://herbsutter.com/2013/06/13/gotw-93-solution-auto-variables-part-2/\" rel=\"nofollow noreferrer\">here</a>.</p>\n<pre><code>template&lt;class T&gt; \nauto as_unsigned(T t) \n{ \n    return std::make_unsigned_t&lt;T&gt;(t); \n}\n</code></pre>\n<p>Which may be used as follows:</p>\n<pre><code>auto sx = int32_t{ 55 };\nauto ux = as_unsigned(sx);\n</code></pre>\n<p>You can see it in action <a href=\"http://ideone.com/PzM5o2\" rel=\"nofollow noreferrer\">here</a>.</p>\n", "OwnerUserId": "735425", "PostTypeId": "2", "Id": "42496803", "Score": "0", "CreationDate": "2017-02-27T22:17:50.047", "LastActivityDate": "2017-02-27T22:17:50.047"}, "1751346": {"CommentCount": "1", "CreationDate": "2009-11-17T19:56:46.357", "PostTypeId": "1", "AcceptedAnswerId": "1751368", "LastEditorUserId": "108030", "LastActivityDate": "2017-02-27T22:17:50.047", "LastEditDate": "2009-11-17T20:35:29.523", "ViewCount": "11082", "FavoriteCount": "2", "Title": "interpret signed as unsigned", "Id": "1751346", "Score": "20", "Body": "<p>I have a value like this:</p>\n<pre><code>int64_t s_val = SOME_SIGNED_VALUE;\n</code></pre>\n<p>How can I get a</p>\n<pre><code>uint64_t u_val\n</code></pre>\n<p>that has exactly the same bit pattern as <code>s_val</code>, but is treated as unsigned?</p>\n<p>This may be really simple, but after looking on Stackoverflow and elsewhere I haven't turned up the answer.</p>\n", "Tags": "<c++>", "OwnerUserId": "108030", "AnswerCount": "7"}, "1751462": {"ParentId": "1751346", "CommentCount": "4", "Body": "<p>Logical bit pattern (bits of value-representation), i.e. values of binary digits can only be preserved if the original signed value was non-negative, because negative values cannot be represented by an unsigned integer variable. All you need to do is to assign your signed value to your unsigned integral object and you are done</p>\n<pre><code>uint64_t u_val = s_val;\n</code></pre>\n<p>An explicit cast is not necessary, but might be used to suppress compiler warnings.</p>\n<p>As for physical bit pattern (i.e. what you see in raw memory, bits of object-representation), you simply can't \"convert\" it that way. C++ language does not provide you with any methods of conversion that would guarantee to preserve the physical bit pattern. All you can do is to <em>reinterpret</em> the memory occupied by the signed object as an unsigned object of the same size</p>\n<pre><code>STATIC_ASSERT(sizeof(int64_t) == sizeof(uint64_t));\nuint64_t u_val = reinterpret_cast&lt;uint64_t&amp;&gt;(s_val);\n</code></pre>\n<p>Again, this is not a conversion, but rather a memory reinterpretation. This is not guaranteed to work and this is generally illegal.</p>\n", "OwnerUserId": "187690", "PostTypeId": "2", "Id": "1751462", "Score": "4", "CreationDate": "2009-11-17T20:15:39.473", "LastActivityDate": "2009-11-17T20:15:39.473"}, "1751404": {"ParentId": "1751346", "PostTypeId": "2", "CommentCount": "6", "Body": "<p>Generally speaking, it doesn't matter whether you use <code>static_cast&lt;int64_t&gt;</code> or <code>reinterpret_cast&lt;int64_t&gt;</code>. So long as you are running on a processor that uses <a href=\"http://en.wikipedia.org/wiki/Two's_complement\" rel=\"nofollow noreferrer\">two's complement</a> to represent negative numbers, the result is the same. (Practically all modern processors use that.) Under two's complement, a positive number in a signed int is represented the same way in an unsigned int; if it's a negative number it'll be reinterpreted as a large positive number in the unsigned form.</p>\n<p>Basically, what your cast does is tell the compiler to produce different assembly instructions when dealing with that value. E.g. there are different instructions for multiplication and division for signed integers. Although addition and subtraction remains the same (read the wikipedia link and you'll understand).</p>\n", "OwnerUserId": "149330", "LastEditorUserId": "149330", "LastEditDate": "2009-11-17T20:29:11.537", "Id": "1751404", "Score": "6", "CreationDate": "2009-11-17T20:04:48.497", "LastActivityDate": "2009-11-17T20:29:11.537"}, "bq_ids": {"n4140": {"so_1751346_1751368_0": {"section_id": 31, "quality": 0.9666666666666667, "length": 29}}, "n3337": {"so_1751346_1751368_0": {"section_id": 28, "quality": 0.9666666666666667, "length": 29}}, "n4659": {"so_1751346_1751368_0": {"section_id": 31, "quality": 0.9666666666666667, "length": 29}}}, "5253700": {"ParentId": "1751346", "CommentCount": "1", "Body": "<p>I agree static_cast is appropriate in this case, but no one has mentioned a very similar looking case where static_cast wouldn't preserve bits as might be expected.</p>\n<pre><code>char x = -1; // 255\nunsigned int x2 = static_cast&lt;unsigned int&gt;(x); // 4294967295\nunsigned int x3 = static_cast&lt;unsigned int&gt;(static_cast&lt;unsigned char&gt;(x)); // 255\n</code></pre>\n<p>Watch out for <a href=\"http://en.wikipedia.org/wiki/Sign_extension\" rel=\"nofollow\">sign extension</a> when you are casting from a small signed value to a large unsigned value.  Possibly other combinations are vulnerable too - I haven't thought it all the way through.</p>\n", "OwnerUserId": "652592", "PostTypeId": "2", "Id": "5253700", "Score": "4", "CreationDate": "2011-03-09T23:38:00.600", "LastActivityDate": "2011-03-09T23:38:00.600"}});