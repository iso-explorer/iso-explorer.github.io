post_cb({"3917482": {"Id": "3917482", "PostTypeId": "2", "Body": "<p>Your code compiles fine with Comeau Online, and also with MinGW g++ 4.4.1.</p>\n<p>I'm mentioning that just an \"authority argument\".</p>\n<p>From a standards POV access is orthogonal to virtual inheritance. The only problem with virtual inheritance is that it's the most derived class that initializes the virtually-derived-from class further up the inheritance chain (or \"as if\"). In your case the most derived class has the required access to do that, and so the code should compile.</p>\n<p>MSVC also has some other problems with virtual inheritance.</p>\n<p>So, yes, </p>\n<ul>\n<li>the code is valid, and</li>\n<li>it's an MSVC compiler bug.</li>\n</ul>\n<p>FYI, that bug is still present in MSVC 10.0. I found a <a href=\"https://connect.microsoft.com/VisualStudio/feedback/details/552586/inherting-noncopyable-base-allows-equal-sign-initialization\" rel=\"nofollow\">bug report</a> about a similar bug, confirmed by Microsoft. However, with just some cursory googling I couldn't find this particular bug.</p>\n", "LastActivityDate": "2010-10-12T17:41:43.037", "CommentCount": "0", "CreationDate": "2010-10-12T17:41:43.037", "ParentId": "3900192", "Score": "1", "OwnerUserId": "464581"}, "3900192": {"ViewCount": "316", "Body": "<p>consider the following code:</p>\n<pre><code>class A\n{\n    friend class B;\n    friend class C;\n};\n\nclass B: virtual private A\n{\n};\n\nclass C: private B\n{\n};\n\nint main()\n{\n    C x; //OK default constructor generated by compiler\n    C y = x; //compiler error: copy-constructor unavailable in C\n    y = x; //compiler error: assignment operator unavailable in C \n}\n</code></pre>\n<p>The MSVC9.0 (the C++ compiler of Visual Studio 2008) does generate the default constructor but is unable to generate copy and assignment operators for C although C is a friend of A. Is this the expected behavior or is this a Microsoft bug? I think the latter is the case, and if I am right, can anyone point to an article/forum/... where this issue is discussed or where microsoft has reacted to this bug. Thank you in advance.</p>\n<p>P.S. Incidentally, if BOTH private inheritances are changed to protected, everything works</p>\n<p>P.P.S. I need a proof, that the above code is legal OR illegal. It was indeed intended that a class with a virtual private base could not be derived from, as I understand. But they seem to have missed the friend part. So... here it goes, my first bounty :)</p>\n", "AcceptedAnswerId": "3917482", "Title": "MSVC9.0 bug or misunderstanding of virtual inheritance and friends?", "CreationDate": "2010-10-10T11:56:41.420", "Id": "3900192", "CommentCount": "2", "LastEditDate": "2010-10-12T14:03:27.583", "PostTypeId": "1", "LastEditorUserId": "469935", "LastActivityDate": "2010-10-12T20:04:06.060", "Score": "4", "OwnerUserId": "469935", "Tags": "<c++><visual-studio-2008><friend><virtual-inheritance><default-copy-constructor>", "AnswerCount": "4"}, "3900220": {"Id": "3900220", "PostTypeId": "2", "Body": "<p>I think that it's not a bug. Just C has to be a friend of B to be able to copy it's virtual base class A.</p>\n", "LastActivityDate": "2010-10-10T12:04:42.580", "CommentCount": "3", "CreationDate": "2010-10-10T12:04:42.580", "ParentId": "3900192", "Score": "0", "OwnerUserId": "277176"}, "3900390": {"Id": "3900390", "PostTypeId": "2", "Body": "<p>Classes with <code>virtual private</code> base should not be derived from, per <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_closed.html#7\" rel=\"nofollow\">this</a> at the C++ SWG.  The compiler is doing the right thing (up to a point). The issue is not with the visibility of A from C, it's that C should not be allowed to be instantiated at all, implying that the bug is in the first (default) construction rather than the other lines.</p>\n<blockquote>\n<ol>\n<li>Can a class with a private virtual base class be derived from?</li>\n</ol>\n<p id=\"so_3900192_3900390_0\">Section: 11.2  [class.access.base]<br>\n  Status: NAD     Submitter: Jason\n  Merrill     Date: unknown</br></p>\n</blockquote>\n<pre><code>class Foo { public: Foo() {}  ~Foo() {} };\nclass A : virtual private Foo { public: A() {}  ~A() {} };\nclass Bar : public A { public: Bar() {}  ~Bar() {} }; \n</code></pre>\n<blockquote>\n<p id=\"so_3900192_3900390_1\">~Bar() calls\n  ~Foo(), which is ill-formed due to\n  access violation, right? (Bar's\n  constructor has the same problem since\n  it needs to call Foo's constructor.)\n  There seems to be some disagreement\n  among compilers. Sun, IBM and g++\n  reject the testcase, EDG and HP accept\n  it. Perhaps this case should be\n  clarified by a note in the draft. In\n  short, it looks like a class with a\n  virtual private base can't be derived\n  from.</p>\n<p id=\"so_3900192_3900390_2\">Rationale: This is what was intended.</p>\n</blockquote>\n<p>btw the Visual C++ v10 compiler behaviour is the same as noted in the question.  Removing <code>virtual</code> from the inheritance of <code>A</code> in <code>B</code> fixes the problem.  </p>\n", "LastEditorUserId": "210102", "LastActivityDate": "2010-10-10T13:32:35.033", "Score": "1", "CreationDate": "2010-10-10T12:59:33.820", "ParentId": "3900192", "CommentCount": "5", "OwnerUserId": "210102", "LastEditDate": "2010-10-10T13:32:35.033"}, "bq_ids": {"n4140": {"so_3900192_3918423_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 6678}, "so_3900192_3918423_7": {"length": 6, "quality": 0.75, "section_id": 456}, "so_3900192_3918423_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 6682}, "so_3900192_3918423_2": {"length": 10, "quality": 0.6666666666666666, "section_id": 6684}, "so_3900192_3918423_5": {"length": 10, "quality": 0.625, "section_id": 370}, "so_3900192_3918423_3": {"length": 30, "quality": 0.7692307692307693, "section_id": 370}}, "n3337": {"so_3900192_3918423_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 6433}, "so_3900192_3918423_7": {"length": 6, "quality": 0.75, "section_id": 449}, "so_3900192_3918423_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 6437}, "so_3900192_3918423_2": {"length": 10, "quality": 0.6666666666666666, "section_id": 6439}, "so_3900192_3918423_5": {"length": 10, "quality": 0.625, "section_id": 360}, "so_3900192_3918423_6": {"length": 28, "quality": 0.717948717948718, "section_id": 453}, "so_3900192_3918423_3": {"length": 30, "quality": 0.7692307692307693, "section_id": 360}}, "n4659": {"so_3900192_3918423_0": {"length": 20, "quality": 0.9523809523809523, "section_id": 8153}, "so_3900192_3918423_5": {"length": 10, "quality": 0.625, "section_id": 384}, "so_3900192_3918423_1": {"length": 5, "quality": 0.8333333333333334, "section_id": 8157}, "so_3900192_3918423_2": {"length": 10, "quality": 0.6666666666666666, "section_id": 8159}, "so_3900192_3918423_7": {"length": 6, "quality": 0.75, "section_id": 479}, "so_3900192_3918423_3": {"length": 30, "quality": 0.7692307692307693, "section_id": 384}}}, "3918423": {"Id": "3918423", "PostTypeId": "2", "Body": "<p>The way I interpret the Standard, the sample code is well-formed.  (And yes, the <code>friend</code> declarations make a big difference from the thing @Steve Townsend quoted.)</p>\n<blockquote>\n<p id=\"so_3900192_3918423_0\">11.2p1: If a class is declared to be a base class for another class using the <code>private</code> access specifier, the <code>public</code> and <code>protected</code> members of the base class are accessible as <code>private</code> members of the derived class.</p>\n<p id=\"so_3900192_3918423_1\">11.2p4: A member <em>m</em> is accessible when named in class <em>N</em> if</p>\n</blockquote>\n<ul>\n<li><em>m</em> as a member of <em>N</em> is public, or</li>\n<li><em>m</em> as a member of <em>N</em> is private, and the reference occurs in a member or friend of class <em>N</em>, or</li>\n<li><em>m</em> as a member of <em>N</em> is protected, and the reference occurs in a member or friend of class <em>N</em>, or in a member or friend of a class <em>P</em> derived from <em>N</em>, where <em>m</em> as a member of <em>P</em> is private or protected, or</li>\n<li>there exists a base class <em>B</em> of <em>N</em> that is accessible at the point of reference, and <em>m</em> is accessible when named in class <em>B</em>.</li>\n</ul>\n<blockquote>\n<p id=\"so_3900192_3918423_2\">11.4p1: A friend of a class is a function or class that is not a member of the class but is permitted to use the private and protected member names from the class.</p>\n</blockquote>\n<p>There are no statements in Clause 11 (Member access control) which imply that a friend of a class ever has fewer access permissions than the class which befriended it.  Note that \"accessible\" is only defined in the context of a specific class.  Although we sometimes talk about a member or base class being \"accessible\" or \"inaccessible\" in general, it would be more accurate to talk about whether it is \"accessible in all contexts\" or \"accessible in all classes\" (as is the case when only <code>public</code> is used).</p>\n<p>Now for the parts which describe checks on access control in automatically defined methods.</p>\n<blockquote>\n<p id=\"so_3900192_3918423_3\">12.1p7: An implicitly-declared default constructor for a class is <em>implicitly defined</em> when it is used to create an object of its class type (1.8).  The implicitly-defined default constructor performs the set of initializations of the class that would be performed by a user-written default constructor for that class with an empty <em>mem-initializer-list</em> (12.6.2) and an empty function body.  If that user-written default constructor would be ill-formed, the program is ill-formed.</p>\n<p id=\"so_3900192_3918423_4\">12.6.2p6: All sub-objects representing virtual base classes are initialized by the constructor of the most derived class (1.8).  If the constructor of the most derived class does not specify a <em>mem-initializer</em> for a virtual base class <code>V</code>, then <code>V</code>'s default constructor is called to initialize the virtual base class subobject.  If <code>V</code> does not have an accessible default constructor, the initialization is ill-formed.</p>\n<p id=\"so_3900192_3918423_5\">12.4p5: An implicitly-declared destructor is <em>implicitly defined</em> when it is used to destroy an object of its class type (3.7).  A program is ill-formed if the class for which a destructor is implicitly defined has:</p>\n</blockquote>\n<ul>\n<li>a non-static data member of class type (or array thereof) with an inaccessible destructor, or</li>\n<li>a base class with an inaccessible destructor.</li>\n</ul>\n<blockquote>\n<p id=\"so_3900192_3918423_6\">12.8p7: An implicitly-declared copy constructor is <em>implicitly defined</em> if it is used to initialize an object of its class type from a copy of an object of its class type or of a class type derived from its class type.  [Note: the copy constructor is implicitly defined even if the implementation elided its use (12.2).]  A program is ill-formed if the class for which a copy constructor is implicitly defined has:</p>\n</blockquote>\n<ul>\n<li>a nonstatic data member of class type (or array thereof) with an inaccessible or ambiguous copy constructor, or</li>\n<li>a base class with an inaccessible or ambiguous copy constructor.</li>\n</ul>\n<blockquote>\n<p id=\"so_3900192_3918423_7\">12.8p12: A program is ill-formed if the class for which a copy assignment operator is implicitly defined has:</p>\n</blockquote>\n<ul>\n<li>a nonstatic data member of <code>const</code> type, or</li>\n<li>a nonstatic data member of reference type, or</li>\n<li>a nonstatic data member of class type (or array thereof) with an inaccessible copy assignment operator, or</li>\n<li>a base class with an inaccessible copy assignment operator.</li>\n</ul>\n<p>All these requirements mentioning \"inaccessible\" or \"accessible\" must be interpreted in the context of some class, and the only class that makes sense is the one for which a member function is implicitly defined.</p>\n<p>In the original example, <code>class A</code> implicitly has <code>public</code> default constructor, destructor, copy constructor, and copy assignment operator.  By 11.2p4, since <code>class C</code> is a friend of <code>class A</code>, all those members are accessible when named in class <code>C</code>.  Therefore, access checks on those members of <code>class A</code> do not cause the implicit definitions of <code>class C</code>'s default constructor, destructor, copy constructor, or copy assignment operator to be ill-formed.</p>\n", "LastEditorUserId": "459640", "LastActivityDate": "2010-10-12T20:04:06.060", "Score": "2", "CreationDate": "2010-10-12T19:48:14.050", "ParentId": "3900192", "CommentCount": "1", "OwnerUserId": "459640", "LastEditDate": "2010-10-12T20:04:06.060"}});