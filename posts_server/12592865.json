post_cb({"12593274": {"Id": "12593274", "PostTypeId": "2", "Body": "<p>The code should not compile. Pure virtual functions cannot be defined inside the class definition. Move the definition outside of the classes:</p>\n<pre><code>struct IAlpha {\n  virtual ~IAlpha() = 0;\n};\ninline IAlpha::~IAlpha() {}\n// similarly for the rest.\n</code></pre>\n<p>Besides that, the code is correct and should compile.</p>\n", "LastActivityDate": "2012-09-26T01:16:19.977", "Score": "0", "CreationDate": "2012-09-26T01:16:19.977", "ParentId": "12592865", "CommentCount": "1", "OwnerUserId": "36565"}, "17999315": {"Id": "17999315", "PostTypeId": "2", "Body": "<p>You can't define the virtual function to inline.</p>\n<p>Because the inline is in compile.\nThe virtual is in runtime.</p>\n", "LastEditorUserId": "759866", "LastActivityDate": "2013-12-30T18:58:06.497", "Score": "0", "CreationDate": "2013-08-01T16:15:32.147", "ParentId": "12592865", "CommentCount": "0", "LastEditDate": "2013-12-30T18:58:06.497", "OwnerUserId": "2223579"}, "17998482": {"Id": "17998482", "PostTypeId": "2", "Body": "<p>This is a bug in MSVC++ 2010 and earlier. The code actually gets\ncalled even though the compiler claims to have removed the code. It seems to be\nfixed in MSVC++ 2012. Other compilers like gcc or clang do not emit a warning.\nThe syntax \"... = 0 {...}\" is illegal according to the C++03 standard section 10.4.2 (even though MSVC++ does not complain) as it has already been pointed out:</p>\n<blockquote>\n<p id=\"so_12592865_17998482_0\">Note: a function declaration cannot provide both a pure-specifier and\n  a definition</p>\n</blockquote>\n<p>However, defining a pure virtual destructor in general is not illegal and section 12.4.7 states:</p>\n<blockquote>\n<p id=\"so_12592865_17998482_1\">A destructor can be declared virtual (10.3) or pure virtual (10.4); if\n  any objects of that class or any derived class are created in the\n  program, the destructor shall be defined. If a class has a base class\n  with a virtual destructor, its destructor (whether user- or\n  implicitly- declared) is virtual.</p>\n</blockquote>\n<p>My way of disabling the warning is to add the following lines to the header:</p>\n<pre><code>#if defined(_MSC_VER) &amp;&amp; (_MSC_VER &lt;= 1600)\n#  pragma warning(disable:4505)\n#endif\n</code></pre>\n<p>If you want to disable the warnings more locally then <code>#pragma warning( push )</code> and <code>#pragma warning( pop )</code> might be of help. See <a href=\"http://msdn.microsoft.com/en-us/library/2c8f766e%28v=vs.80%29.aspx\" rel=\"nofollow\">http://msdn.microsoft.com/en-us/library/2c8f766e(v=vs.80).aspx</a></p>\n<p>Since the code seems to get called you can ignore the warnings in my opinion.</p>\n", "LastActivityDate": "2013-08-01T15:36:18.420", "Score": "3", "CreationDate": "2013-08-01T15:36:18.420", "ParentId": "12592865", "CommentCount": "1", "OwnerUserId": "1225999"}, "bq_ids": {"n4140": {"so_12592865_17998482_0": {"length": 7, "quality": 0.875, "section_id": 7019}, "so_12592865_17998482_1": {"length": 23, "quality": 0.8518518518518519, "section_id": 405}}, "n3337": {"so_12592865_17998482_0": {"length": 7, "quality": 0.875, "section_id": 6765}, "so_12592865_17998482_1": {"length": 23, "quality": 0.8518518518518519, "section_id": 396}}, "n4659": {"so_12592865_17998482_0": {"length": 7, "quality": 0.875, "section_id": 8516}, "so_12592865_17998482_1": {"length": 23, "quality": 0.8518518518518519, "section_id": 423}}}, "12593045": {"Id": "12593045", "PostTypeId": "2", "Body": "<p>Did you try defining the destructors in a non-inline manner?  Perhaps the warning is related to that.</p>\n<p>Such as <a href=\"http://codepad.org/AxK3FCrf\" rel=\"nofollow\">this code</a>.</p>\n", "LastEditorUserId": "996296", "LastActivityDate": "2012-09-26T01:04:19.393", "Score": "0", "CreationDate": "2012-09-26T00:38:38.147", "ParentId": "12592865", "CommentCount": "1", "LastEditDate": "2012-09-26T01:04:19.393", "OwnerUserId": "996296"}, "12592865": {"ViewCount": "1020", "Body": "<p>So I have an abstract base class with no abstract methods.  In order to enforce abstractness, I've declared the (non-trivial) destructor as pure virtual:</p>\n<pre><code>class AbstractClass\n{\npublic:\n  AbstractClass()\n  {\n    std::wcout &lt;&lt; L\"AbstractClass::AbstractClass()\" &lt;&lt; std::endl;\n  }\n  virtual ~AbstractClass() = 0\n  {\n    std::wcout &lt;&lt; L\"AbstractClass::~AbstractClass()\" &lt;&lt; std::endl;\n  }\n};\n\nclass ConcreteClass : public AbstractClass\n{\npublic:\n  ConcreteClass()\n  {\n    std::wcout &lt;&lt; L\"ConcreteClass::ConcreteClass()\" &lt;&lt; std::endl;\n  }\n  virtual ~ConcreteClass()\n  {\n    std::wcout &lt;&lt; L\"ConcreteClass::~ConcreteClass()\" &lt;&lt; std::endl;\n  }\n};\n</code></pre>\n<p>This builds and works as expected; the output for a code block that simply defines an instance of ConcreteClass is</p>\n<pre>\n\n    AbstractClass::AbstractClass()\n    ConcreteClass::ConcreteClass()\n    ConcreteClass::~ConcreteClass()\n    AbstractClass::~AbstractClass()\n\n</pre>\n<p>Now, when I have derive AbstractClass from another class used as an interface class, itself having a (trivial) virtual destructor (pure or otherwise), it still works:</p>\n<pre><code>class IAlpha\n{\npublic:\n  virtual ~IAlpha() = 0 {}\n};\n\nclass AbstractClass : public IAlpha\n{\npublic:\n  AbstractClass()\n  {\n    std::wcout &lt;&lt; L\"AbstractClass::AbstractClass()\" &lt;&lt; std::endl;\n  }\n  virtual ~AbstractClass() = 0\n  {\n    std::wcout &lt;&lt; L\"AbstractClass::~AbstractClass()\" &lt;&lt; std::endl;\n  }\n};\n\nclass ConcreteClass : public AbstractClass\n{\npublic:\n  ConcreteClass()\n  {\n    std::wcout &lt;&lt; L\"ConcreteClass::ConcreteClass()\" &lt;&lt; std::endl;\n  }\n  virtual ~ConcreteClass()\n  {\n    std::wcout &lt;&lt; L\"ConcreteClass::~ConcreteClass()\" &lt;&lt; std::endl;\n  }\n};\n</code></pre>\n<p>The problem arises when I attempt to implement two different interfaces in this manner:</p>\n<pre><code>class IAlpha\n{\npublic:\n  virtual ~IAlpha() = 0 {}\n};\n\nclass IBeta\n{\npublic:\n  virtual ~IBeta() = 0 {}\n};\n\nclass AbstractClass : public IAlpha, public IBeta\n{\npublic:\n  AbstractClass()\n  {\n    std::wcout &lt;&lt; L\"AbstractClass::AbstractClass()\" &lt;&lt; std::endl;\n  }\n  virtual ~AbstractClass() = 0\n  {\n    std::wcout &lt;&lt; L\"AbstractClass::~AbstractClass()\" &lt;&lt; std::endl;\n  }\n};\n\nclass ConcreteClass : public AbstractClass\n{\npublic:\n  ConcreteClass()\n  {\n    std::wcout &lt;&lt; L\"ConcreteClass::ConcreteClass()\" &lt;&lt; std::endl;\n  }\n  virtual ~ConcreteClass()\n  {\n    std::wcout &lt;&lt; L\"ConcreteClass::~ConcreteClass()\" &lt;&lt; std::endl;\n  }\n};\n</code></pre>\n<p>At this point, when building, I receive the following warning:</p>\n<pre>warning C4505: 'AbstractClass::~AbstractClass' :\nunreferenced local function has been removed</pre>\n<p>Strangely enough, however, the output still shows <code>AbstractClass::~AbstractClass()</code> getting called.</p>\n<p>Is this a bug in MSVC9 (VS 2008)?  Can I safely ignore this warning?</p>\n<p>Edit:  I've tried separating the pure virtual method definitions from the class definition as well, as apparently the <code>= 0 {}</code> syntax is not actually valid.  Unfortunately, C4505 still shows up, whether I specify <code>inline</code> or not.</p>\n<p>Since I've found no way to <code>#pragma</code> out this warning just for these methods (the warning gets triggered from other parts of the code), I may have to remove the pure virtual specifier from <code>AbstractClass</code> and rely on making the constructors protected.  Not an ideal solution, but it beats rearchitecting the class hierarchy to get around an erroneous warning.</p>\n", "Title": "Pure virtual inheritance, multiple inheritance, and C4505", "CreationDate": "2012-09-26T00:12:14.697", "LastActivityDate": "2013-12-30T18:58:06.497", "CommentCount": "0", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2013-06-28T23:54:33.277", "LastEditorUserId": "881229", "Id": "12592865", "Score": "6", "OwnerUserId": "1698745", "Tags": "<c++><destructor><multiple-inheritance><pure-virtual>", "AnswerCount": "4"}});