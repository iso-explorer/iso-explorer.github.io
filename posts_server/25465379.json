post_cb({"25465850": {"Id": "25465850", "PostTypeId": "2", "Body": "<p>This looks like a bug with how the two compilers treat compiler-generated copy constructors.</p>\n<p>This code compiles using both <a href=\"http://goo.gl/Py3YT9\">clang</a> and <a href=\"http://goo.gl/gJpl8j\">g++</a>:</p>\n<pre><code>#include &lt;utility&gt;\n\n// utils\ntemplate &lt;std::size_t N&gt; struct require_constexpr { constexpr std::size_t size() const { return N; } };\nstruct test { \n  constexpr std::size_t size() const { return 0; } \n  constexpr test() { }\n  constexpr test(const test &amp;) { }\n};\ntemplate &lt;typename...&gt; constexpr void noop (void) { }\n\n// size() wrappers\ntemplate &lt;typename T&gt; constexpr std::size_t size (T obj) { return obj.size(); }\ntemplate &lt;typename T&gt; constexpr auto sz1 (T obj) { return size(require_constexpr&lt; obj.size() &gt; { }); }\ntemplate &lt;typename T&gt; constexpr auto sz2 (T obj) { return size(require_constexpr&lt; size(obj) &gt; { }); }\n\nint main (int, char**)\n{\n  constexpr auto const ar = test();\n\n  // Check constexpr-computability of size(), sz1() and the expansion of sz2()\n  noop&lt;\n    require_constexpr&lt;\n      size(require_constexpr&lt; ar.size() &gt; { }) + sz1(ar) +\n      size(require_constexpr&lt; size(ar)  &gt; { })\n    &gt;\n  &gt;();\n\n  noop&lt; require_constexpr&lt; sz2(ar) &gt; &gt;();\n\n  return 0;\n}\n</code></pre>\n<p>But if we change the line</p>\n<pre><code>constexpr test(const test &amp;) { }\n</code></pre>\n<p>to </p>\n<pre><code>constexpr test(const test &amp;) = default;\n</code></pre>\n<p>Then it compiles in neither (<a href=\"http://goo.gl/4u1Jup\">g++</a>, <a href=\"http://goo.gl/t4HbCp\">clang</a>), even though there is absolutely no difference between what the two constructors do (<code>test</code> being a completely empty class), and \u00a712.8 [class.copy]/p13 states that</p>\n<blockquote>\n<p id=\"so_25465379_25465850_0\">If the implicitly-defined constructor would satisfy the requirements\n  of a <code>constexpr</code> constructor (7.1.5), the implicitly-defined\n  constructor is <code>constexpr</code>.</p>\n</blockquote>\n<p>Furthermore, if the implicit copy constructor weren't <code>constexpr</code>, then the explicit-default declaration with <code>constexpr</code> should have caused the program to be ill-formed, with a diagnostic required (\u00a78.4.2 [dcl.fct.def.default]/p2):</p>\n<blockquote>\n<p id=\"so_25465379_25465850_1\">An explicitly-defaulted function may be declared <code>constexpr</code> only if\n  it would have been implicitly declared as <code>constexpr</code>.</p>\n</blockquote>\n<p>But both compilers (<a href=\"http://goo.gl/Gpo8Hc\">clang</a>, <a href=\"http://goo.gl/i467YZ\">g++</a>) compile the second version of code if the second <code>noop</code> call is commented out.</p>\n", "LastActivityDate": "2014-08-23T19:58:42.723", "CommentCount": "1", "CreationDate": "2014-08-23T19:58:42.723", "ParentId": "25465379", "Score": "5", "OwnerUserId": "2756719"}, "27008345": {"Id": "27008345", "PostTypeId": "2", "Body": "<p>The key difference between sz1 and sz2 is that sz1 passes the address of obj to the size member function, which is not a valid result of a constant-expression but is fine as an intermediate result operand.  sz2 performs an lvalue-&gt;rvalue conversion on obj for passing to the size function, and since obj is not constant this makes the expression non-constant.</p>\n<p>T.C.'s point about implicit vs. explicit constructors is interesting.  The source of the difference is that the implicit trivial copy constructor does a bitwise copy, which involves copying a (non-constant) byte of padding, whereas the user-provided copy constructor doesn't copy anything.  But the standard says that the implicit constructor does a memberwise copy, so they ought to be treated the same.</p>\n<p>What's not clear is whether they should both be rejected or both accepted; a strict reading of 5.19 suggests that both should be rejected, as both involve an lvalue-&gt;rvalue conversion for obj using the copy constructor.  I've raised this issue with the C++ committee.</p>\n", "LastActivityDate": "2014-11-19T03:16:27.780", "CommentCount": "0", "CreationDate": "2014-11-19T03:16:27.780", "ParentId": "25465379", "Score": "5", "OwnerUserId": "1714446"}, "bq_ids": {"n4140": {"so_25465379_25465850_1": {"length": 11, "quality": 1.0, "section_id": 3271}, "so_25465379_25465850_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 462}}, "n3337": {"so_25465379_25465850_1": {"length": 11, "quality": 1.0, "section_id": 3143}, "so_25465379_25465850_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 453}}, "n4659": {"so_25465379_25465850_1": {"length": 11, "quality": 1.0, "section_id": 4029}, "so_25465379_25465850_0": {"length": 10, "quality": 0.9090909090909091, "section_id": 485}}}, "25465379": {"ViewCount": "483", "Body": "<p>While experimenting with constexpr functions and templates (and non-type template arguments), I stumbled upon a phenomenon, and I cannot understand which rule brings it into effect.</p>\n<p>So my question essentially is \"Why does this happen\", according to the rules about constexpr-s. \"this\" is the following.</p>\n<p>In one of the constexpr functions, if a parameter is used directly then there is no problem with this parameter being used in a compile-time computation. (example lines 2)</p>\n<p>When the same parameter is used as an argument to another constexpr-function, then the compiler complaints that this expression (the parameter id) is not a constexpr. (example line 3)</p>\n<p>In short:</p>\n<pre><code>template &lt;typename T&gt; constexpr std::size size (T obj) { return obj.size(); }\ntemplate &lt;typename T&gt; constexpr auto sz1 (T obj) { return std::make_index_sequence&lt; obj.size() &gt; { }.size(); } // OK ...\ntemplate &lt;typename T&gt; constexpr auto sz2 (T obj) { return std::make_index_sequence&lt; size(obj) &gt; { }.size(); } // ERROR\n  // \"obj\" is [suddenly] not a constexpr\n</code></pre>\n<p>This happens with both g++-4.9.1 and clang++-3.4.2 .</p>\n<p>Below is a small test program for quick and easy experimentation.</p>\n<hr>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;utility&gt;\n#include &lt;array&gt;\n#include &lt;iostream&gt;\n\n// utils\ntemplate &lt;size_t N&gt; using require_constexpr = std::make_index_sequence&lt;N&gt;;\ntemplate &lt;typename...&gt; constexpr void noop (void) { }\n\n// size() wrappers\ntemplate &lt;typename T&gt; constexpr std::size_t size (T obj) { return obj.size(); }\ntemplate &lt;typename T&gt; constexpr auto sz1 (T obj) { return size(require_constexpr&lt; obj.size() &gt; { }); }\ntemplate &lt;typename T&gt; constexpr auto sz2 (T obj) { return size(require_constexpr&lt; size(obj) &gt; { }); }\n\nint main0 (int, char**)\n{\n  constexpr auto const ar = std::array&lt;int, 4u&gt; { 4, 5, 6, 7 };\n\n  // Check constexpr-computability of size(), sz1() and the expansion of sz2()\n  noop&lt;\n    require_constexpr&lt;\n      size(require_constexpr&lt; ar.size() &gt; { }) + sz1(ar) +\n      size(require_constexpr&lt; size(ar)  &gt; { })\n    &gt;\n  &gt;();\n\n  // But this is an error\n  // ERROR: \"obj\" is not a constexpr in sz2()\n//noop&lt; require_constexpr&lt; sz2(ar) &gt; &gt;();\n\n  return 0;\n}\n</code></pre>\n<hr>\n<p><strong>Edit</strong> Here is the relative compilation output.</p>\n<p><em>clang</em></p>\n<pre><code> src/main1.cpp:12:87: error: non-type template argument is not a constant expression\n     template &lt;typename T&gt; constexpr auto sz2 (T obj) { return size(require_constexpr&lt; size(obj) &gt; { }); }\n                                                                                       ^~~~~~~~~\n src/main1.cpp:28:32: note: in instantiation of function template specialization 'sz2&lt;std::array&lt;int, 4&gt; &gt;' requested here\n       noop&lt; require_constexpr&lt; sz2(ar) &gt; &gt;();\n                                ^\n src/main1.cpp:12:92: note: read of non-constexpr variable 'obj' is not allowed in a constant expression\n     template &lt;typename T&gt; constexpr auto sz2 (T obj) { return size(require_constexpr&lt; size(obj) &gt; { }); }\n                                                                                            ^\n src/main1.cpp:12:92: note: in call to 'array(obj)'\n src/main1.cpp:12:49: note: declared here\n     template &lt;typename T&gt; constexpr auto sz2 (T obj) { return size(require_constexpr&lt; size(obj) &gt; { }); }\n                                            ^\n</code></pre>\n<p><em>gcc</em></p>\n<pre><code>src/main1.cpp: In substitution of \u2018template&lt;long unsigned int N&gt; using require_constexpr = std::make_index_sequence&lt;N&gt; [with long unsigned int N = size&lt;std::array&lt;int, 4ul&gt; &gt;(obj)]\u2019:\nsrc/main1.cpp:12:102:   required from \u2018constexpr auto sz2(T) [with T = std::array&lt;int, 4ul&gt;]\u2019\nsrc/main1.cpp:28:38:   required from here\nsrc/main1.cpp:12:102: error: \u2018obj\u2019 is not a constant expression\n     template &lt;typename T&gt; constexpr auto sz2 (T obj) { return size(require_constexpr&lt; size(obj) &gt; { }); }\n                                                                                                      ^\nsrc/main1.cpp:12:102: note: in template argument for type \u2018long unsigned int\u2019 \n</code></pre>\n</hr></hr>", "AcceptedAnswerId": "25465850", "Title": "constexpr-function parameter is considered constexpr if used directly but not if used to call another constexpr-function", "CreationDate": "2014-08-23T18:57:46.867", "Id": "25465379", "CommentCount": "1", "LastEditDate": "2014-08-26T12:46:07.300", "PostTypeId": "1", "LastEditorUserId": "3970469", "LastActivityDate": "2014-11-19T03:16:27.780", "Score": "11", "OwnerUserId": "3970469", "Tags": "<c++><constexpr>", "AnswerCount": "2"}});