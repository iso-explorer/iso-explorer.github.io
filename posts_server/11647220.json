post_cb({"11647310": {"Id": "11647310", "PostTypeId": "2", "Body": "<p><code>void *</code> is a pointer that can hold any object pointer type, that includes all pointers to structure type. So you can assign any pointer to a structure type to a <code>void *</code>.</p>\n<p>But <code>void *</code> and pointers to structure types are not guaranteed to have the same representation so your case 1 is undefined behavior.</p>\n<blockquote>\n<p id=\"so_11647220_11647310_0\">(C11, 6.2.5p28) \"[...] Pointers to other types need not have the same\n  representation or alignment requirements.\"</p>\n</blockquote>\n", "LastActivityDate": "2012-07-25T10:02:58.670", "CommentCount": "6", "CreationDate": "2012-07-25T10:02:58.670", "ParentId": "11647220", "Score": "4", "OwnerUserId": "1119701"}, "bq_ids": {"n4140": {"so_11647220_11647310_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 7223}}, "n3337": {"so_11647220_11647310_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 6967}}, "n4659": {"so_11647220_11647310_0": {"length": 7, "quality": 0.6363636363636364, "section_id": 8732}}}, "11647220": {"ViewCount": "685", "Body": "<p>In other words, may I reinterpret (not convert!) <code>void*</code> pointer as a pointer to some structure type (assuming that the <code>void*</code> pointer really holds properly converted valid structure address)</p>\n<p>Actually I'm interesting in the following scenario:</p>\n<pre><code>typedef struct void_struct void_struct_t;\n\ntypedef somestruct\n{ \n    int member;\n    // ... other members ...\n}somestruct_t;\n\nunion \n{\n    void*          pv; \n    void_struct_t* pvs; \n    somestruct_t*  ps; \n}u;\n\nsomestruct_t s={};\n\nu.pv= &amp;s;\n\nu.ps-&gt;member=1; // (Case 1)  Ok? unspecified? UB? \n\nu.pvs=(void_struct_t*)&amp;s;\n\nu.ps-&gt;member=1;  // (Case 2) )Ok?\n</code></pre>\n<p>What I found in the C11 standard is rather dissapointing for the Case 1:</p>\n<p>\u00a76.2.5</p>\n<blockquote>\n<p id=\"so_11647220_11647220_0\">28 A pointer to void shall have the same representation and alignment requirements as a &gt;pointer to a character type.[footnote: The same representation and alignment requirements &gt;are meant to imply interchangeability as arguments to functions, return values from &gt;functions, and members of unions.] Similarly, pointers to qualified or unqualified &gt;versions of compatible types shall have the same representation and alignment &gt;requirements. All pointers to structure types shall have the same representation and &gt;alignment requirements as each other. All pointers to union types shall have the same &gt;representation and alignment requirements as each other. Pointers to other types need not &gt;have the same representation or alignment requirements.</p>\n</blockquote>\n<p>It seems, though, that Case 2 is valid, but I'm not 100% sure...</p>\n<p>The question is mostly C-oriented, but I'm interesting in C++ too (I'd want the code would be valid while compiling by C++ compiler). Honestly, I found even less in C++11 standard, so even Case 2 seems questionable for me... however, may be I'm missing something.</p>\n<p><b>[edit]\nWhat is the real problem behind this question?</b></p>\n<p>I have a (potentially large) set of types defined as structs. \nFor each type I need to define a companion type:</p>\n<pre><code>typedef struct companion_for_sometype\n{\n  sometype* p_object;\n  // there are also other members\n}companion_for_sometype;\n</code></pre>\n<p>Obviously, the companion type would be a template in C++, but I need a solution for C \n(more exactly, for \"clean C\", i.e for intersection of C89 and C++ as I want my code to be also valid C++ code).</p>\n<p>Fortunately, it is not a problem even in C, since I can define a macro</p>\n<pre><code>DECLARE_COMPANION(type_name) typedef struct companion_for_##type_name\n{\n  type_name* p_object;\n  // there are also other members\n}companion_for_##type_name;\n</code></pre>\n<p>and just invoke it for every type that need a companion.</p>\n<p>There is also a set of generic operations on companion types.\nThese operations are also defined by macros (since there are no overloads in pure C).</p>\n<p>One of this operations, say </p>\n<pre><code>#define op(companion_type_object) blablabla\n</code></pre>\n<p>should assign a <code>void*</code> pointer to <code>p_object</code> field of the companion object, \ni.e. should do something like this:</p>\n<pre><code>(companion_type_object).p_object= (type_name*) some_function_returning_pvoid(..)\n</code></pre>\n<p>But the macro doesn't know type_name (only an <em>object</em> of companion type is passed to the macro)\nso the macro can't do the appropriate pointer cast.</p>\n<p>The question is actually inspired by this problem.</p>\n<p>To solve it, I decide to reinterpret target pointer in the assignment as void* and then assign to it.\nIt may be done by replacing the pointer in the companion declaration with a union of pointers \n(the question is about this case), or one may reinterpret target pointer directly, say:</p>\n<pre><code>*(void**) &amp;(companion_type_object).p_object= some_function_returning_pvoid(..)\n</code></pre>\n<p>But I can't find any solution without reinterpreting pointers (maybe I'm missing some possibilities though)</p>\n", "AcceptedAnswerId": "11647310", "Title": "Are void* pointer and pointer to some structure (layout-) compatible?", "CreationDate": "2012-07-25T09:58:34.517", "Id": "11647220", "CommentCount": "7", "LastEditDate": "2017-08-05T09:26:57.383", "PostTypeId": "1", "LastEditorUserId": "2757035", "LastActivityDate": "2017-08-05T09:26:57.383", "Score": "2", "OwnerUserId": "396672", "Tags": "<c++><c>", "AnswerCount": "2"}, "11665756": {"Id": "11665756", "PostTypeId": "2", "Body": "<p>In C, <code>void *</code> automatically casts to any object type, so this will work:</p>\n<pre><code>(companion_type_object).p_object = some_function_returning_pvoid(..)\n</code></pre>\n<p>In C++, you need to use <code>static_cast</code>, but you can find out the required type using <code>decltype</code> :</p>\n<pre><code>(companion_type_object).p_object = \n    static_cast&lt;decltype(*(companion_type_object).p_object) *&gt;(\n        some_function_returning_pvoid(..))\n</code></pre>\n<p>In C++03 you should be able to use some compiler extension equivalent to <code>decltype</code>.  Alternatively, you could provide a macro-generated method on <code>companion_type_object</code> to cast a <code>void *</code> to the appropriate type:</p>\n<pre><code>static type_name *void_p_to_object_p(void *p) { return static_cast&lt;type_name *&gt;(p); }\n...\n(companion_type_object).p_object = companion_type_object.void_p_to_object_p(\n    some_function_returning_pvoid(..))\n</code></pre>\n", "LastEditorUserId": "567292", "LastActivityDate": "2012-07-26T09:05:58.460", "Score": "2", "CreationDate": "2012-07-26T08:56:54.750", "ParentId": "11647220", "CommentCount": "7", "OwnerUserId": "567292", "LastEditDate": "2012-07-26T09:05:58.460"}});