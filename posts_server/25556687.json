post_cb({"25556687": {"CommentCount": "0", "ViewCount": "175", "CreationDate": "2014-08-28T19:36:35.743", "LastActivityDate": "2014-08-29T06:31:25.887", "Title": "Relation between hasher and key_equal in std::unordered_set", "FavoriteCount": "0", "PostTypeId": "1", "Id": "25556687", "Score": "2", "Body": "<p>I would say, that there must be a relation between <code>hasher</code> and <code>key_equal</code>. If two elements are the same (calling equal returns true) they must have the same hash, otherwise wrong bucket would be searched for element.</p>\n<p>But there is no such thing written  either at <a href=\"http://www.cplusplus.com/reference/unordered_set/unordered_set/\" rel=\"nofollow\">http://www.cplusplus.com/reference/unordered_set/unordered_set/</a> or <a href=\"http://en.cppreference.com/w/cpp/container/unordered_set\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/container/unordered_set</a></p>\n<p>But it is obviously not working correctly.\nSee example, when I try to filter pairs independent on order of elements ( 1,2 == 2,1)</p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;functional&gt;\n#include &lt;unordered_set&gt;\n\ntemplate &lt;class T&gt;\ninline void hash_combine(std::size_t &amp; seed, const T &amp; v)\n{\n  std::hash&lt;T&gt; hasher;\n  seed ^= hasher(v) + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);\n}\n\nnamespace std\n{\n  template&lt;typename S, typename T&gt;\n  struct hash&lt;pair&lt;S, T&gt;&gt;\n  {\n    inline size_t operator()(const pair&lt;S, T&gt; &amp; v) const\n    {\n      size_t seed = 0;\n      ::hash_combine(seed, v.first);\n      ::hash_combine(seed, v.second);\n      return seed;\n    }\n  };\n}\n\nint main() \n{\n   typedef std::pair&lt;int, int&gt; Pair;\n    Pair pa = std::make_pair(7,5);\n    Pair pb = std::make_pair(5,7);\n    Pair pc = std::make_pair(5,1);\n    Pair pd = std::make_pair(4,3);\n    Pair pe = std::make_pair(5,7);\n\n    struct PairEq\n    {\n        inline bool operator()(const Pair &amp; p1, const Pair &amp; p2) const\n        {\n            return (p1.first == p2.first &amp;&amp; p1.second == p2.second)\n                || (p1.first == p2.second &amp;&amp; p1.second == p2.first);\n        }\n    };\n\n    std::unordered_set&lt;Pair, std::hash&lt;Pair&gt;&gt; h;\n\n    h.insert(pa);\n    h.insert(pb);\n    h.insert(pc);\n    h.insert(pd);\n    h.insert(pe);\n\n   for(auto &amp; p : h)\n   {\n      std::cout &lt;&lt; p.first &lt;&lt; \" \" &lt;&lt; p.second &lt;&lt; \"\\n\";\n   }\n\n   // note 5,7 AND 7,5 is outputted\n}\n</code></pre>\n<p>Is it safe to assume the usual hash properties\n: If two elements are equal, they have the same hash. Two same hashes doesn't mean the same elements?</p>\n", "Tags": "<c++><hash><unordered-set>", "OwnerUserId": "680031", "AnswerCount": "1"}, "25556781": {"ParentId": "25556687", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Yes, this relationship is required, as per the C++ Standard, section \u00a7 23.2.5 / 5 [unord.req] - (Unordered associative containers, emphasis mine)</p>\n<blockquote>\n<p id=\"so_25556687_25556781_0\">The container\u2019s object of type Hash \u2014 denoted by hash \u2014 is called the hash function\n  of the container. The container\u2019s object of type Pred \u2014 denoted by pred \u2014 is called the\n  key equality predicate of the container.</p>\n<p id=\"so_25556687_25556781_1\">Two values k1 and k2 of type Key are considered equivalent if the container\u2019s key equality predicate returns true when passed those values. <strong>If k1 and k2 are equivalent, the container\u2019s hash function shall return the same value for both</strong>.</p>\n</blockquote>\n<hr>\n<p>Note that this requirement stands for all unordered associative containers, not just <code>std::unordered_set</code>.</p>\n</hr>", "OwnerUserId": "3510483", "LastEditorUserId": "3510483", "LastEditDate": "2014-08-29T06:31:25.887", "Id": "25556781", "Score": "3", "CreationDate": "2014-08-28T19:42:34.930", "LastActivityDate": "2014-08-29T06:31:25.887"}, "bq_ids": {"n4140": {"so_25556687_25556781_0": {"section_id": 756, "quality": 0.8260869565217391, "length": 19}, "so_25556687_25556781_1": {"section_id": 757, "quality": 1.0, "length": 23}}, "n3337": {"so_25556687_25556781_0": {"section_id": 750, "quality": 0.5217391304347826, "length": 12}, "so_25556687_25556781_1": {"section_id": 745, "quality": 0.8260869565217391, "length": 19}}, "n4659": {"so_25556687_25556781_0": {"section_id": 816, "quality": 0.8260869565217391, "length": 19}, "so_25556687_25556781_1": {"section_id": 817, "quality": 1.0, "length": 23}}}});