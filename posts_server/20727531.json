post_cb({"20727583": {"Id": "20727583", "PostTypeId": "2", "Body": "<p>In C++, an unsuffixed integer literal has type <code>int</code>, <code>long int</code>, or <code>long long int</code>, whichever is the first in which its value can be represented. (<code>long long int</code> was a relatively recent addition to the language.)</p>\n<p>Probably on your system both <code>215510</code> and <code>10000</code> are of type <code>int</code>, which is probably a 32-bit type.</p>\n<p>Expressions are (usually) evaluated by themselves, without regard to the context in which they appear. So the expression <code>215510*10000</code> is evaluated as an <code>int</code>. Since the mathematical result exceeds <code>INT_MAX</code>, the result is undefined, but it's likely to be <code>-2139867296</code>.</p>\n<p>When that value is converted to a 64-bit unsigned type, it wraps around, yielding <code>18446744071569684320</code> (which is slightly less than 2<sup>64</sup>).</p>\n", "LastActivityDate": "2013-12-22T08:26:00.307", "CommentCount": "2", "CreationDate": "2013-12-22T08:26:00.307", "ParentId": "20727531", "Score": "3", "OwnerUserId": "827263"}, "20727551": {"Id": "20727551", "PostTypeId": "2", "Body": "<p>Because a literal constant like <code>215510</code> is <em>usually</em> an <code>int</code> (not a <code>long</code>) in standard C++. It is not related to Visual Studio (it should be the same with another compiler like <a href=\"http://gcc.gnu.org/\" rel=\"nofollow noreferrer\">GCC</a> a.k.a. <code>g++</code> at least if <code>int</code>-s have 32 bits), so <code>215510 * 10000</code>  is also an <code>int</code>. Try <code>215510L * 10000</code> to have one multiplicand be a <code>long</code> (hence the product also be a <code>long</code> - that won't change the product if <code>long</code>-s are still 32 bits!), or even <code>215510LL</code> to make it <code>long long</code> or with a explicit cast <code>(int64_t)215510</code> ...</p>\n<p>And on your platform, <code>int</code> are probably 32 bits. So the signed <code>INT_MAX</code> is <code>2147483647</code> (which is 2<sup>31</sup> - 1).</p>\n<p>And <a href=\"https://stackoverflow.com/users/827263/keith-thompson\">Keith Thompson</a> commented rightly that </p>\n<blockquote>\n<p id=\"so_20727531_20727551_0\">The type of an integer constant is the first of the corresponding list\n  in which its value can be represented.</p>\n</blockquote>\n<p>per (the C11 standard \u00a76.4.4.1 item 5 or) the C++11 standard \u00a72.14.2 item 2. So on an implementation with 16 bits <code>int</code>-s and 32 bits <code>long</code>-s  <code>215510</code> is a <code>long</code> literal constant (because 215510 &gt; 32767 which would be its <code>INT_MAX</code>....).</p>\n<p><sup>So contrarily to what I believed, the type of a literal integral constant is not defined by its suffix -or lack of it- alone, but also by its value!</sup></p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2013-12-22T08:46:31.283", "Score": "9", "CreationDate": "2013-12-22T08:20:07.637", "ParentId": "20727531", "CommentCount": "8", "OwnerUserId": "841108", "LastEditDate": "2017-05-23T12:19:09.507"}, "20727553": {"Id": "20727553", "PostTypeId": "2", "Body": "<p>It's because you are invoking integer overflow by multiplying two 32-bit numbers whose result is larger than 32 bits.  You need to convert to 64 bits first, as you have already shown.</p>\n", "LastActivityDate": "2013-12-22T08:20:22.443", "CommentCount": "0", "CreationDate": "2013-12-22T08:20:22.443", "ParentId": "20727531", "Score": "11", "OwnerUserId": "4323"}, "bq_ids": {"n4140": {"so_20727531_20727551_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 5341}}, "n3337": {"so_20727531_20727551_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 5138}}, "n4659": {"so_20727531_20727551_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 6762}}}, "20727531": {"ViewCount": "158", "Body": "<p>I have the following code:</p>\n<pre><code>UINT64 time1 = 215510*10000;\nUINT64 time2 = (UINT64)(215510 * 10000);\n</code></pre>\n<p>When printing them or in Watch, it turns out:</p>\n<pre><code>time1 = 18446744071569684320\ntime2 = 18446744071569684320\n</code></pre>\n<hr>\n<p>Actually I know how to make it right here. We have to use one of the following codes in order to get correct answer (the following 3 versions are all right):</p>\n<pre><code>UINT64 time3 = (UINT64)215510 * 10000;\nUINT64 time4 = 215510 * (UINT64)10000;\nUINT64 time5 = (UINT64)215510 * (UINT64)10000;\n</code></pre>\n<hr>\n<p>But why the first two lines cannot give the right answer?</p>\n</hr></hr>", "AcceptedAnswerId": "20727551", "Title": "Why is 215510*10000 != 2155100000?", "CreationDate": "2013-12-22T08:17:31.263", "LastActivityDate": "2013-12-22T08:46:31.283", "CommentCount": "2", "LastEditDate": "2013-12-22T08:22:44.730", "PostTypeId": "1", "Tags": "<c++>", "Id": "20727531", "AnswerCount": "3", "Score": "0", "OwnerUserId": "2589776", "ClosedDate": "2013-12-26T19:25:44.820", "LastEditorUserId": "2864740"}});