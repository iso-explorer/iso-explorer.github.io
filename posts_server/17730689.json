post_cb({"17730689": {"ViewCount": "3439", "Body": "<p>I know that generally the standard places few requirements on the values which have been moved from:</p>\n<p>N3485 17.6.5.15 [lib.types.movedfrom]/1:</p>\n<blockquote>\n<p id=\"so_17730689_17730689_0\">Objects of types defined in the C++ standard library may be moved from (12.8). Move operations may\n  be explicitly specified or implicitly generated. Unless otherwise specified, such moved-from objects shall be placed in a valid but unspecified state.</p>\n</blockquote>\n<p>I can't find anything about <code>vector</code> that explicitly excludes it from this paragraph. However, I can't come up with a sane implementation that would result in the vector being not empty.</p>\n<p>Is there some standardese that entails this that I'm missing or is this similar to <a href=\"https://stackoverflow.com/questions/2256160/is-it-reasonable-to-use-stdbasic-stringt-as-a-contiguous-buffer-when-targeti\">treating <code>basic_string</code> as a contiguous buffer in C++03</a>?</p>\n", "AcceptedAnswerId": "17735913", "Title": "Is a moved-from vector always empty?", "CreationDate": "2013-07-18T17:54:19.593", "Id": "17730689", "CommentCount": "9", "FavoriteCount": "5", "PostTypeId": "1", "LastEditDate": "2017-05-23T11:54:59.723", "LastEditorUserId": "-1", "LastActivityDate": "2015-09-16T14:59:12.417", "Score": "25", "OwnerUserId": "82320", "Tags": "<c++><c++11><vector><language-lawyer><move-semantics>", "AnswerCount": "4"}, "17735913": {"Id": "17735913", "PostTypeId": "2", "Body": "<p>I'm coming to this party late, and offering an additional answer because I do not believe any other answer at this time is completely correct.</p>\n<p><strong>Question:</strong></p>\n<blockquote>\n<p id=\"so_17730689_17735913_0\">Is a moved-from vector always empty?</p>\n</blockquote>\n<p><strong>Answer:</strong></p>\n<p>Usually, but no, not always.</p>\n<p><strong>The gory details:</strong></p>\n<p><code>vector</code> has no standard-defined moved-from state like some types do (e.g. <code>unique_ptr</code> is specified to be equal to <code>nullptr</code> after being moved from).  However the requirements for <code>vector</code> are such that there are not too many options.</p>\n<p>The answer depends on whether we're talking about <code>vector</code>'s move constructor or move assignment operator.  In the latter case, the answer also depends on the <code>vector</code>'s allocator.</p>\n<hr>\n<pre><code>vector&lt;T, A&gt;::vector(vector&amp;&amp; v)\n</code></pre>\n<p>This operation must have constant complexity.  That means that there are no options but to steal resources from <code>v</code> to construct <code>*this</code>, leaving <code>v</code> in an empty state.  This is true no matter what the allocator <code>A</code> is, nor what the type <code>T</code> is.</p>\n<p>So for the move constructor, yes, the moved-from <code>vector</code> will always be empty.  This is not directly specified, but falls out of the complexity requirement, and the fact that there is no other way to implement it.</p>\n<hr>\n<pre><code>vector&lt;T, A&gt;&amp;\nvector&lt;T, A&gt;::operator=(vector&amp;&amp; v)\n</code></pre>\n<p>This is considerably more complicated.  There are 3 major cases:</p>\n<h2>One:</h2>\n<pre><code>allocator_traits&lt;A&gt;::propagate_on_container_move_assignment::value == true\n</code></pre>\n<p>(<code>propagate_on_container_move_assignment</code> evaluates to <code>true_type</code>)</p>\n<p>In this case the move assignment operator will destruct all elements in <code>*this</code>, deallocate capacity using the allocator from <code>*this</code>, move assign the allocators, and then transfer ownership of the memory buffer from <code>v</code> to <code>*this</code>.  Except for the destruction of elements in <code>*this</code>, this is an O(1) complexity operation.  And typically (e.g. in most but not all std::algorithms), the lhs of a move assignment has <code>empty() == true</code> prior to the move assignment.</p>\n<p>Note:  In C++11 the <code>propagate_on_container_move_assignment</code> for <code>std::allocator</code> is <code>false_type</code>, but this has been changed to <code>true_type</code> for C++1y (y == 4 we hope).</p>\n<p>In case One, the moved-from <code>vector</code> will always be empty.</p>\n<h2>Two:</h2>\n<pre><code>allocator_traits&lt;A&gt;::propagate_on_container_move_assignment::value == false\n    &amp;&amp; get_allocator() == v.get_allocator()\n</code></pre>\n<p>(<code>propagate_on_container_move_assignment</code> evaluates to <code>false_type</code>, and the two allocators compare equal)</p>\n<p>In this case, the move assignment operator behaves just like case One, with the following exceptions:</p>\n<ol>\n<li>The allocators are not move assigned.</li>\n<li>The decision between this case and case Three happens at run time, and case Three requires more of <code>T</code>, and thus so does case Two, even though case Two doesn't actually execute those extra requirements on <code>T</code>.</li>\n</ol>\n<p>In case Two, the moved-from <code>vector</code> will always be empty.</p>\n<h2>Three:</h2>\n<pre><code>allocator_traits&lt;A&gt;::propagate_on_container_move_assignment::value == false\n    &amp;&amp; get_allocator() != v.get_allocator()\n</code></pre>\n<p>(<code>propagate_on_container_move_assignment</code> evaluates to <code>false_type</code>, and the two allocators do not compare equal)</p>\n<p>In this case the implementation can not move assign the allocators, nor can it transfer any resources from <code>v</code> to <code>*this</code> (resources being the memory buffer).  In this case, the only way to implement the move assignment operator is to effectively:</p>\n<pre><code>typedef move_iterator&lt;iterator&gt; Ip;\nassign(Ip(v.begin()), Ip(v.end()));\n</code></pre>\n<p>That is, move each individual <code>T</code> from <code>v</code> to <code>*this</code>.  The <code>assign</code> can reuse both <code>capacity</code> and <code>size</code> in <code>*this</code> if available.  For example if <code>*this</code> has the same <code>size</code> as <code>v</code> the implementation can move assign each <code>T</code> from <code>v</code> to <code>*this</code>.  This requires <code>T</code> to be <code>MoveAssignable</code>.  Note that <code>MoveAssignable</code> does not require <code>T</code> to have a move assignment operator.  A copy assignment operator will also suffice.  <code>MoveAssignable</code> just means <code>T</code> has to be assignable from an rvalue <code>T</code>.</p>\n<p>If the <code>size</code> of <code>*this</code> is not sufficient, then new <code>T</code> will have to be constructed in <code>*this</code>.  This requires <code>T</code> to be <code>MoveInsertable</code>.  For any sane allocator I can think of, <code>MoveInsertable</code> boils down to the same thing as <code>MoveConstructible</code>, which means constructible from an rvalue <code>T</code> (does not imply the existence of a move constructor for <code>T</code>).</p>\n<p>In case Three, the moved-from <code>vector</code> will in general not be empty.  It could be full of moved-from elements.  If the elements don't have a move constructor, this could be equivalent to a copy assignment.  However, there is nothing that mandates this.  The implementor is free to do some extra work and execute <code>v.clear()</code> if he so desires, leaving <code>v</code> empty.  I am not aware of any implementation doing so, nor am I aware of any motivation for an implementation to do so.  But I don't see anything forbidding it.</p>\n<p>David Rodr\u00edguez reports that GCC 4.8.1 calls <code>v.clear()</code> in this case, leaving <code>v</code> empty.  <a href=\"http://libcxx.llvm.org\">libc++</a> does not, leaving <code>v</code> not empty.  Both implementations are conforming.</p>\n</hr></hr>", "LastEditorUserId": "82320", "LastActivityDate": "2015-09-16T14:59:12.417", "Score": "37", "CreationDate": "2013-07-18T23:50:57.147", "ParentId": "17730689", "CommentCount": "8", "OwnerUserId": "576911", "LastEditDate": "2015-09-16T14:59:12.417"}, "bq_ids": {"n4140": {"so_17730689_17731528_1": {"length": 5, "quality": 1.0, "section_id": 705}, "so_17730689_17730689_0": {"length": 23, "quality": 0.92, "section_id": 6365}, "so_17730689_17731528_0": {"length": 6, "quality": 1.0, "section_id": 705}, "so_17730689_17731528_2": {"length": 18, "quality": 1.0, "section_id": 707}}, "n3337": {"so_17730689_17731528_1": {"length": 5, "quality": 1.0, "section_id": 695}, "so_17730689_17730689_0": {"length": 23, "quality": 0.92, "section_id": 6122}, "so_17730689_17731528_0": {"length": 6, "quality": 1.0, "section_id": 695}, "so_17730689_17731528_2": {"length": 18, "quality": 1.0, "section_id": 697}}, "n4659": {"so_17730689_17731528_1": {"length": 5, "quality": 1.0, "section_id": 734}, "so_17730689_17730689_0": {"length": 23, "quality": 0.92, "section_id": 7876}, "so_17730689_17731528_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 734}, "so_17730689_17731528_2": {"length": 18, "quality": 1.0, "section_id": 736}}}, "17730888": {"Id": "17730888", "PostTypeId": "2", "Body": "<p>While it might not be a <em>sane</em> implementation in the general case, a valid implementation of the move constructor/assignment is just copying the data from the source, leaving the source untouched. Additionally, for the case of assignment, move can be implemented as swap, and the <em>moved-from</em> container might contain the old value of the <em>moved-to</em> container.</p>\n<p>Implementing move as copy can actually happen if you use polymorphic allocators, as we do, and the allocator is not deemed to be part of the <em>value</em> of the object (and thus, assignment never changes the actual allocator being used). In this context, a move operation can detect whether both the source and the destination use the same allocator. If they use the same allocator the move operation can just move the data from the source. If they use different allocators then the destination must copy the source container.</p>\n", "LastActivityDate": "2013-07-18T18:07:23.563", "CommentCount": "17", "CreationDate": "2013-07-18T18:07:23.563", "ParentId": "17730689", "Score": "5", "OwnerUserId": "36565"}, "17731528": {"Id": "17731528", "PostTypeId": "2", "Body": "<p>I left comments to this effect on other answers, but had to rush off before fully explaining. The result of a moved-from vector must always be empty, or in the case of move assignment, must be either empty or the previous object's state (i.e. a swap), because otherwise the iterator invalidation rules cannot be met, namely that a move does not invalidate them. Consider:</p>\n<pre><code>std::vector&lt;int&gt; move;\nstd::vector&lt;int&gt;::iterator it;\n{\n    std::vector&lt;int&gt; x(some_size);\n    it = x.begin();\n    move = std::move(x);\n}\nstd::cout &lt;&lt; *it;\n</code></pre>\n<p>Here you can see that iterator invalidation <em>does</em> expose the implementation of the move. The requirement for this code to be legal, specifically that the iterator remains valid, prevents the implementation from performing a copy, or small-object-storage or any similar thing. If a copy was made, then <code>it</code> would be invalidated when the optional is emptied, and the same is true if the <code>vector</code> uses some kind of SSO-based storage. Essentially, the only reasonable possible implementation is to swap pointers, or simply move them.</p>\n<p>Kindly view the Standard quotes on requirements for <em>all</em> containers:</p>\n<pre><code>X u(rv)    \nX u = rv    \n</code></pre>\n<blockquote>\n<p id=\"so_17730689_17731528_0\">post: u shall be equal to the value that rv had before this construction</p>\n</blockquote>\n<pre><code>a = rv\n</code></pre>\n<blockquote>\n<p id=\"so_17730689_17731528_1\">a shall be equal to the value that rv had before this assignment</p>\n</blockquote>\n<p>Iterator validity is part of the <em>value</em> of a container. Although the Standard does not unambiguously state this directly, we can see in, for example,</p>\n<blockquote>\n<p id=\"so_17730689_17731528_2\">begin() returns an iterator referring to the first element in the\n  container. end() returns an iterator which is the past-the-end value\n  for the container. If the container is empty, then begin() == end();</p>\n</blockquote>\n<p>Any implementation which actually did move from the elements of the source instead of swapping the memory would be defective, so I suggest that any Standard wordings saying otherwise is a defect- not least of which because the Standard is not in fact very clear on this point. These quotes are from N3691.</p>\n", "LastEditorUserId": "298661", "LastActivityDate": "2013-07-18T19:28:39.157", "Score": "0", "CreationDate": "2013-07-18T18:45:45.920", "ParentId": "17730689", "CommentCount": "21", "OwnerUserId": "298661", "LastEditDate": "2013-07-18T19:28:39.157"}, "17730898": {"Id": "17730898", "PostTypeId": "2", "Body": "<p>In a lot of situations, move-construction and move-assignment can be implemented by delegating to <code>swap</code> - especially if no allocators are involved. There are several reasons for doing that:</p>\n<ul>\n<li><code>swap</code> has to be implemented anyway</li>\n<li>developer efficiency because less code has to be written</li>\n<li>runtime efficiency because fewer operations are executed in total</li>\n</ul>\n<p>Here is an example for move-assignment. In this case, the move-from vector will not be empty, if the moved-to vector was not empty.</p>\n<pre><code>auto operator=(vector&amp;&amp; rhs) -&gt; vector&amp;\n{\n    if (/* allocator is neither move- nor swap-aware */) {\n        swap(rhs);\n    } else {\n        ...\n    }\n    return *this;\n}\n</code></pre>\n", "LastEditorUserId": "1305501", "LastActivityDate": "2013-07-21T12:55:08.033", "Score": "3", "CreationDate": "2013-07-18T18:07:45.500", "ParentId": "17730689", "CommentCount": "4", "OwnerUserId": "1305501", "LastEditDate": "2013-07-21T12:55:08.033"}});