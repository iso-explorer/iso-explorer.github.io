post_cb({"13923800": {"ParentId": "13923684", "CommentCount": "1", "Body": "<p>I think that the difference is that when you do the first (valid) explicit specialization of <code>f</code>:</p>\n<pre><code>template &lt;&gt;\nvoid Foo&lt;char,int&gt;::f() {}\n</code></pre>\n<p>You are doing an implicit instantiation of <code>Foo&lt;char,int&gt;</code>. But when you try the partial specialization with:</p>\n<pre><code>template &lt;typename T&gt;\nvoid Foo&lt;T,int&gt;::f()\n{\n}\n</code></pre>\n<p>The compiler would need to instantiate implicitly <code>Foo&lt;T,int&gt;</code> before doing the specialization, but it cannot do that because of the <code>T</code>. And it fails.</p>\n<p>You can check that is the case with the following code:</p>\n<pre><code>template &lt;typename T, typename S&gt;\nclass Foo\n{\npublic:\n    void f(){}\n    void g(){}\n};\n\n\ntemplate &lt;&gt;\nvoid Foo&lt;char,int&gt;::f() //line 11\n{}\n\ntemplate &lt;&gt;\nclass Foo&lt;char,int&gt; //line 15\n{};\n</code></pre>\n<p>With <code>g++</code> it gives the errors:</p>\n<pre><code>test.cpp:15:7: error: specialization of \u2018Foo&lt;char, int&gt;\u2019 after instantiation\ntest.cpp:15:7: error: redefinition of \u2018class Foo&lt;char, int&gt;\u2019\ntest.cpp:2:7: error: previous definition of \u2018class Foo&lt;char, int&gt;\u2019\n</code></pre>\n<p>With <code>clang++</code> is a bit clearer:</p>\n<pre><code>test.cpp:15:7: error: explicit specialization of 'Foo&lt;char, int&gt;' after instantiation\nclass Foo&lt;char,int&gt;\n      ^~~~~~~~~~~~~\ntest.cpp:11:6: note: implicit instantiation first required here\nvoid Foo&lt;char,int&gt;::f() \n     ^\n</code></pre>\n", "OwnerUserId": "865874", "PostTypeId": "2", "Id": "13923800", "Score": "3", "CreationDate": "2012-12-17T23:09:59.507", "LastActivityDate": "2012-12-17T23:09:59.507"}, "13924883": {"ParentId": "13923684", "CommentCount": "1", "Body": "<p>I tried to find a succinct quote from the standard, but I don't think there is one. The fact is, there is no such thing as a partial specialization of a template function (or, for that matter, of a template alias). Only class templates can have partial specializations.</p>\n<p>Let's forget about templates for a second. In C++, there is a big difference between class names and function names. There can only be one definition of a class within a given scope. (You can have various declarations, but they all refer to the One True Class.) So the name really identifies the class.</p>\n<p>A function name, on the other hand, is a kind of group identity. You can define any number of functions within a scope with exactly the same name. When you use a function name to call a function, the compiler has to figure out which function you really meant by looking at the various possibilities and matching the signature of each of them with the supplied arguments. There's no relationship between the various functions which share a name; they're completely separate entities.</p>\n<p>So, no big deal. You knew all this, right? But now let's go back to templates.</p>\n<p>The name of a templated class is still unique. Although you can define partial specializations, you have to explicitly specialize the same templated class. This mechanism looks superficially like the function-name resolution algorithm referred to above, but there are significant differences -- one of them is that, unlike function prototypes, you cannot have two class templates in the same scope with different kinds of template parameters.</p>\n<p>Templated functions, on the other hand, have no need to define unique names. Templating does not replace the normal function overload mechanism. So when the compiler is trying to figure out what a function name means, it has to consider all templated and non-templated declarations for that function name, resolve the templated ones to a set of template parameter assignments (if possible) and then once it has a list of possible function objects, select the best one with normal overload resolution.</p>\n<p>That's quite a different algorithm from the templated class template parameter resolution. Instead of just matching a list of provided template arguments with a list of declared template parameters, which is how it resolves class templates, it has to take each templated function which might possibly match (has at least the right number of parameters, for example); deduce template parameters by unifying the supplied arguments with the template; and then add the resolve specialization to the overload set for a further round of overload resolution.</p>\n<p>I suppose it would have been possible to have added partial specialization resolution into that process as well, but the interactions between partial specialization and function overloading strike me as likely to lead to pseudo-magical behaviour. In the event, it wasn't necessary and so there is no such mechanism. (You can fully specialize a function template. Full specialization means that there are no template arguments to deduce, so it's not a problem.)</p>\n<p>So that's the scoop: you can't partially specialize a templated function, but there is nothing stopping you from providing any number of function templates with the same name. All of them will be considered in overload resolution, and the best one will win, as usual.</p>\n<p>Usually, that's actually sufficient for your overloading needs. You should think about templated functions just the same way you think about normal functions: come up with a way to select the one you want based on the supplied arguments. If you feel you really need to supply template parameters in a function call, rather than having them be deduced, just make the function a (possibly static) member of a templated class, and supply the template arguments to the class.</p>\n<p>Hope that helps...</p>\n", "OwnerUserId": "1566221", "PostTypeId": "2", "Id": "13924883", "Score": "5", "CreationDate": "2012-12-18T01:13:26.707", "LastActivityDate": "2012-12-18T01:13:26.707"}, "13925256": {"ParentId": "13923684", "PostTypeId": "2", "CommentCount": "1", "Body": "<p>The notion of <strong>partial specialization</strong> only exists for class templates (described by \u00a714.5.5) and member templates (i.e. members of a template class that are themselves template functions, described by \u00a714.5.5.3/2). It does not exist for ordinary members of class templates, nor does it exist for function templates \u2013 simply because it is not described by the Standard.</p>\n<p>Now, you might argue that by giving the definition of a partial specialization of a member function, such as</p>\n<pre><code>template &lt;typename T&gt;\nvoid Foo&lt;T,int&gt;::f()\n{ }\n</code></pre>\n<p>you <em>implicitly</em> define a partial specialization of the class template: <code>Foo&lt;T,int&gt;</code>. That, however, <em>is</em> explicitly ruled out by the Standard:</p>\n<blockquote>\n<p id=\"so_13923684_13925256_0\">(\u00a714.5.5/2) Each class template partial specialization is a distinct template and definitions shall be provided for the members of a template partial specialization (14.5.5.3).</p>\n<p id=\"so_13923684_13925256_1\">(\u00a714.5.5.3/1) [...] The members of the class template partial specialization are unrelated to the members of the primary template. Class template partial specialization members that are used in a way that requires a definition shall be defined; the definitions of members of the primary template are never used as definitions for members of a class template partial specialization. [...]</p>\n</blockquote>\n<p>The latter implies that it is impossible to <em>implicitly</em> define a partial specialization by simply giving the definition of one of its members: The very existence of that member would not follow from the definition of the primary template, hence defining it is equivalent to <em>defining</em> a member function that wasn't <em>declared</em>, and that isn't allowed (even with non-template classes).</p>\n<p>On the other hand, the notion of <strong>explicit specialization</strong> (or <em>full specialization</em>, as you call it) exists for member functions of class templates. It is explicitly described by the Standard:</p>\n<blockquote>\n<p id=\"so_13923684_13925256_2\">(\u00a714.7.3/1)  An explicit specialization of any of the following:<br>\n  [...]<br>\n  \u2014 member function of a class template<br>\n  [...]<br>\n  can be declared by a declaration introduced by template&lt;&gt;; [...]</br></br></br></br></p>\n</blockquote>\n<p>\u00a714.7.3/14 describes the details:</p>\n<blockquote>\n<p id=\"so_13923684_13925256_3\">(\u00a714.7.3/14) A member or a member template of a class template may be explicitly specialized for a given implicit instantiation of the class template, even if the member or member template is defined in the class template definition. [...]</p>\n</blockquote>\n<p>Hence, for explicit specializations of members, the instantiation of the rest of the class template works implicitly \u2013 it is derived from the primary template definition, or any partial specializations if defined.</p>\n", "OwnerUserId": "777186", "LastEditorUserId": "777186", "LastEditDate": "2012-12-18T02:24:17.210", "Id": "13925256", "Score": "6", "CreationDate": "2012-12-18T02:02:57.363", "LastActivityDate": "2012-12-18T02:24:17.210"}, "13923684": {"CommentCount": "1", "AcceptedAnswerId": "13925256", "PostTypeId": "1", "LastEditorUserId": "777186", "CreationDate": "2012-12-17T22:59:23.787", "LastActivityDate": "2012-12-18T02:24:17.210", "LastEditDate": "2012-12-18T02:04:18.707", "ViewCount": "1037", "FavoriteCount": "2", "Title": "Template class incomplete specialization", "Id": "13923684", "Score": "8", "Body": "<p>I came across an interesting point that I wasn't able to explain or find an explanation for. Consider the following template definition (compiled with mingw g++ 4.6.2):</p>\n<pre><code>template &lt;typename T, typename S&gt;\nclass Foo\n{\npublic:\n    void f(){}\n    void g(){}\n};\n</code></pre>\n<p>Should we want to, we can fully specialize any single member function:</p>\n<pre><code>template &lt;&gt;\nvoid Foo&lt;char,int&gt;::f() {}\n</code></pre>\n<p>But partial specialization fails with an \"invalid use of incomplete type 'class Foo&lt;...&gt;'\" error:</p>\n<pre><code>template &lt;typename T, typename S&gt;\nvoid Foo&lt;T,S*&gt;::f()\n{\n}\n\ntemplate &lt;typename T&gt;\nvoid Foo&lt;T,int&gt;::f()\n{\n}\n</code></pre>\n<p>And I can't figure out why. Is it a conscious design decision made to avoid some problem I can't foresee? Is it an oversight?</p>\n<p>Thanks in advance.</p>\n", "Tags": "<c++><template-specialization>", "OwnerUserId": "817643", "AnswerCount": "3"}, "bq_ids": {"n4140": {"so_13923684_13925256_0": {"section_id": 136, "quality": 0.8666666666666667, "length": 13}, "so_13923684_13925256_1": {"section_id": 149, "quality": 0.9354838709677419, "length": 29}, "so_13923684_13925256_3": {"section_id": 276, "quality": 0.9545454545454546, "length": 21}, "so_13923684_13925256_2": {"section_id": 263, "quality": 0.9230769230769231, "length": 12}}, "n3337": {"so_13923684_13925256_0": {"section_id": 130, "quality": 0.8666666666666667, "length": 13}, "so_13923684_13925256_1": {"section_id": 143, "quality": 0.9354838709677419, "length": 29}, "so_13923684_13925256_3": {"section_id": 267, "quality": 0.9545454545454546, "length": 21}, "so_13923684_13925256_2": {"section_id": 254, "quality": 0.9230769230769231, "length": 12}}, "n4659": {"so_13923684_13925256_0": {"section_id": 140, "quality": 0.8666666666666667, "length": 13}, "so_13923684_13925256_1": {"section_id": 153, "quality": 0.9354838709677419, "length": 29}, "so_13923684_13925256_2": {"section_id": 270, "quality": 0.9230769230769231, "length": 12}, "so_13923684_13925256_3": {"section_id": 283, "quality": 0.9545454545454546, "length": 21}}}});