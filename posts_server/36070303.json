post_cb({"bq_ids": {"n4140": {"so_36070303_36086450_0": {"length": 27, "quality": 1.0, "section_id": 639}}, "n3337": {"so_36070303_36086450_0": {"length": 25, "quality": 0.9259259259259259, "section_id": 629}}, "n4659": {"so_36070303_36086450_0": {"length": 27, "quality": 1.0, "section_id": 667}}}, "36073184": {"Id": "36073184", "PostTypeId": "2", "Body": "<p><code>A -&gt; char</code> is <code>A -&gt; char</code>.</p>\n<p><code>A -&gt; int</code>  is <code>A -&gt; char -&gt; int</code> (because <code>char</code> to <code>int</code> is a promotion and so beats the <code>double</code> to <code>int</code> conversion).</p>\n<p><code>A -&gt; double</code> is <code>A -&gt; double</code>.</p>\n<p>Two user-defined conversion sequences are only comparable if they involve the same user-defined conversion function. Thus, <code>A -&gt; char</code> is a better conversion sequence than <code>A -&gt; int</code>, so your first case is unambiguous. Neither <code>A -&gt; int</code> nor <code>A -&gt; double</code> is better than the other, so the second case is ambiguous.</p>\n", "LastActivityDate": "2016-03-17T22:57:54.280", "CommentCount": "0", "CreationDate": "2016-03-17T22:57:54.280", "ParentId": "36070303", "Score": "5", "OwnerUserId": "2756719"}, "36086450": {"Id": "36086450", "PostTypeId": "2", "Body": "<p><strong>TL;DR</strong>: The difference is that in the first case, as opposed to the second, the user-defined conversion sequences (<code>A -&gt; char</code>, <code>A -&gt; int</code>) call the same conversion function (<code>operator char</code>). That enables us to break the tie via [over.ics.rank]/(3.3).</p>\n<hr>\n<p>The best conversion operators for particular functions are selected by  <a href=\"http://eel.is/c++draft/over.match.best#1\" rel=\"nofollow\">[over.match.best]/(1.4)</a> (comparing the conversion sequences of their return types).</p>\n<p>Hence the better conversion function for <code>foo(int)</code> is <code>operator char</code> followed by a promotion to <code>int</code>, as opposed to <code>operator double</code> followed by a floating point conversion.</p>\n<p>Now consider both variants of the second overload:</p>\n<ol>\n<li><p>The best ICS to <code>foo(char)</code> is <strong>also via <code>operator char</code></strong> (identity better than floating point conversion). Thus <a href=\"http://eel.is/c++draft/over.ics.rank#3\" rel=\"nofollow\">[over.ics.rank]/(3.3)</a> is applicable:</p>\n<blockquote>\n<p id=\"so_36070303_36086450_0\">User-defined conversion sequence <code>U1</code> is a better conversion sequence than another user-defined conversion sequence <code>U2</code> <strong>if they contain the same user-defined conversion function</strong> [\u2026] and in either case the second standard conversion sequence of <code>U1</code> is better than the second standard conversion sequence of <code>U2</code>.</p>\n</blockquote>\n<p>Hence the overall conversion to <code>F2</code> is deemed better, and it is selected.</p></li>\n<li><p>The best ICS to <code>foo(double)</code> is <strong>via <code>operator double</code></strong>. We end up with two conversion sequences employing distinct conversion functions; nothing really applies, and we just get an ambiguity.</p></li>\n</ol>\n</hr>", "LastEditorUserId": "3647361", "LastActivityDate": "2016-03-18T14:20:11.220", "Score": "4", "CreationDate": "2016-03-18T14:04:11.397", "ParentId": "36070303", "CommentCount": "0", "OwnerUserId": "3647361", "LastEditDate": "2016-03-18T14:20:11.220"}, "36070303": {"ViewCount": "313", "Body": "<p>Consider simple code :</p>\n<pre><code>#include&lt;iostream&gt;\n\nstruct A {\n    operator double(){\n        std::cout&lt;&lt;\"Conversion function double chosen.\"&lt;&lt;std::endl;\n        return 1.1;\n    }\n    operator char(){\n        std::cout&lt;&lt;\"Conversion function char chosen.\"&lt;&lt;std::endl;\n        return 'a';\n    }\n} a;\n\nvoid foo(int){}\nvoid foo (char){}\nint main() {\n    foo(a);\n}\n</code></pre>\n<p>Above code works fine, and as expected <strong>gcc, clang and VC++</strong> chooses <code>foo(char)</code>. </p>\n<p>Now lets modify the code little bit :</p>\n<pre><code>#include&lt;iostream&gt;\n\nstruct A {\n    operator double(){\n        std::cout&lt;&lt;\"Conversion function double chosen.\"&lt;&lt;std::endl;\n        return 1.1;\n    }\n    operator char(){\n        std::cout&lt;&lt;\"Conversion function char chosen.\"&lt;&lt;std::endl;\n        return 'a';\n    }\n} a;\n\nvoid foo(int){}\nvoid foo (double){} //parameter changed from char to double\nint main() {\n    foo(a);\n}\n</code></pre>\n<p>Now this should have choose <code>foo(double)</code>, but seems only <strong>VC++</strong> is happy with the code while <strong>clang and gcc</strong> are unhappy with the above code.</p>\n<pre><code>main.cpp:11:10: error: call of overloaded 'foo(A&amp;)' is ambiguous\n foo(a);\n     ^\nmain.cpp:8:6: note: candidate: void foo(int)\n void foo(int){}\n      ^\nmain.cpp:9:6: note: candidate: void foo(double)\n void foo (double){} //parameter changed from char to double\n      ^\n</code></pre>\n<p>Can anyone explain why above code fails? or is it bug?.</p>\n<p><strong>One more question</strong>: Do gcc and clang share code of overload resolution?</p>\n", "AcceptedAnswerId": "36086450", "Title": "Overload resolution with multiple functions and multiple conversion operators", "CreationDate": "2016-03-17T19:46:02.487", "Id": "36070303", "CommentCount": "3", "FavoriteCount": "3", "PostTypeId": "1", "LastEditDate": "2016-03-21T11:10:55.297", "LastEditorUserId": "322020", "LastActivityDate": "2016-03-21T11:10:55.297", "Score": "13", "OwnerUserId": "4882052", "Tags": "<c++><overloading><language-lawyer><overload-resolution><conversion-operator>", "AnswerCount": "2"}});