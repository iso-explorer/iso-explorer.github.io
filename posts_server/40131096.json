post_cb({"bq_ids": {"n4140": {"so_40131096_40131922_0": {"length": 35, "quality": 0.9210526315789473, "section_id": 5977}}, "n3337": {"so_40131096_40131922_0": {"length": 32, "quality": 0.8421052631578947, "section_id": 5745}}, "n4659": {"so_40131096_40131922_0": {"length": 35, "quality": 0.9210526315789473, "section_id": 7474}}}, "40131922": {"Id": "40131922", "PostTypeId": "2", "Body": "<p>There is no special rule regarding non parenthesized applications of <code>decltype</code> (ie. <a href=\"http://eel.is/c++draft/expr.prim.lambda#20\">[expr.prim.lambda]/20</a> does not apply). So we just fall back to the usual definition of <code>decltype</code>, which mandates that if the operand is an <em>id-expression</em>, the yielded type is just the declared type of the entity, and that's not a reference type. Hence VC++ is wrong.</p>\n<p>NB: it doesn't matter whether <code>dict</code> is captured or not, because <a href=\"http://eel.is/c++draft/expr.prim.lambda#17\">\u00b617</a>:</p>\n<blockquote>\n<p id=\"so_40131096_40131922_0\">Every <em>id-expression</em> within the <em>compound-statement</em> of a <em>lambda-expression</em> <strong>that is an odr-use (3.2)</strong> of an entity captured by copy is transformed into an access to the corresponding unnamed data member of the\n  closure type. [ <em>Note</em>: <strong>An <em>id-expression</em> that is not an odr-use refers to the original entity</strong>, never to a member of\n  the closure type. Furthermore, such an <em>id-expression</em> does not cause the implicit capture of the entity. <em>\u2014 end\n  note</em> ]</p>\n</blockquote>\n<p><code>decltype</code> never odr-uses any of its operands or suboperands. This rule actually gets pretty problematic at times, e.g. as shown in <a href=\"http://wg21.link/cwg958\">core issue 958</a>:</p>\n<blockquote id=\"so_40131096_40131922_1\">\n<pre><code>int f (int&amp;);\nvoid* f (const int&amp;);\n\nint main()\n{\n   int i;\n   [=] ()-&gt; decltype(f(i)) { return f(i); };\n}\n</code></pre>\n</blockquote>\n<p>Here, <code>decltype(f(i))</code> uses the non-<code>const</code> <code>i</code> from the enclosing scope. However, since the lambda isn't <code>mutable</code>, the <code>i</code> in the body is actually <code>const</code>, hence the trailing-return-type is incorrect. CWG concluded this arises too infrequently to be worth solving.</p>\n", "LastEditorUserId": "3647361", "LastActivityDate": "2016-10-19T12:59:28.710", "Score": "12", "CreationDate": "2016-10-19T12:51:53.183", "ParentId": "40131096", "CommentCount": "12", "OwnerUserId": "3647361", "LastEditDate": "2016-10-19T12:59:28.710"}, "40131096": {"ViewCount": "330", "Body": "<p>The following code works with <a href=\"http://rextester.com/JCZJ90740\" rel=\"noreferrer\">gcc</a></p>\n<pre><code>#include &lt;map&gt;\n\nint main() {\n    std::map&lt;int, double&gt; dict;\n    const auto lambda = [&amp;]()\n    {\n        decltype(dict)::value_type bar;\n    };\n}\n</code></pre>\n<p>But for <a href=\"http://rextester.com/XOGC56856\" rel=\"noreferrer\">msvc</a> I have to additionally use <code>std::remove_reference</code></p>\n<pre><code>#include &lt;map&gt;\n#include &lt;type_traits&gt;\n\nint main() {\n    std::map&lt;int, double&gt; dict;\n    const auto lambda = [&amp;]()\n    {\n        std::remove_reference_t&lt;decltype(dict)&gt;::value_type bar;\n    };\n}\n</code></pre>\n<p>Otherwise I get <a href=\"http://rextester.com/ANYWQ21302\" rel=\"noreferrer\">an error</a>:</p>\n<pre><code>error C2651: 'std::map&lt;int,double,std::less&lt;_Kty&gt;,std::allocator&lt;std::pair&lt;const _Kty,_Ty&gt;&gt;&gt; &amp;': left of '::' must be a class, struct or union\n</code></pre>\n<p>Which compiler shows the correct behaviour according to the standard?</p>\n<p><strong>update:</strong></p>\n<p>For <a href=\"http://rextester.com/WODOOZ34953\" rel=\"noreferrer\">msvc</a> <code>decltype(dict)</code> really is a reference, as the following code</p>\n<pre><code>#include &lt;map&gt;\n\nint main()\n{\n    std::map&lt;int, double&gt; dict;\n    const auto lambda = [&amp;]()\n    {\n        decltype(dict) foo;\n    };\n}\n</code></pre>\n<p>errors with</p>\n<pre><code>error C2530: 'foo': references must be initialized\n</code></pre>\n<p>If this really is wrong behaviour, it could lead to <a href=\"http://rextester.com/UVJOVR83617\" rel=\"noreferrer\">nasty bugs, like dangling references</a> when code is compiled with msvc.</p>\n<pre><code>#include &lt;map&gt;\n\nstd::map&lt;int, double&gt; return_a_map()\n{\n    std::map&lt;int, double&gt; result;\n    return result;\n}\n\nint main()\n{\n    std::map&lt;int, double&gt; dict;\n    const auto lambda = [&amp;]()\n    {\n        decltype(dict) foo = return_a_map();\n        // foo is a dangling reference in msvc\n    };\n}\n</code></pre>\n", "Title": "type of reference-captured object inside lambda", "CreationDate": "2016-10-19T12:12:44.757", "LastActivityDate": "2016-10-19T12:59:28.710", "CommentCount": "2", "FavoriteCount": "2", "PostTypeId": "1", "LastEditDate": "2016-10-19T12:31:12.857", "LastEditorUserId": "1866775", "Id": "40131096", "Score": "17", "OwnerUserId": "1866775", "Tags": "<c++><lambda><language-lawyer><decltype>", "AnswerCount": "1"}});