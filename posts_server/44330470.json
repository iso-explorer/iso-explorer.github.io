post_cb({"44330926": {"Id": "44330926", "PostTypeId": "2", "Body": "<p>Yes, you can.</p>\n<p>As the C++ standard says in \u00a75.2.7/5 about the expression <code>dynamic_cast&lt;T&gt;(v)</code>:</p>\n<blockquote>\n<p id=\"so_44330470_44330926_0\">If <code>T</code> is \u201cpointer to <em>cv1</em> <code>B</code>\u201d and <code>v</code> has type \u201cpointer to <em>cv2</em> <code>D</code>\u201d such that\n  <code>B</code> is a base class of <code>D</code>, the result is a pointer to the unique <code>B</code>\n  subobject of the <code>D</code> object pointed to by <code>v</code>.</p>\n</blockquote>\n<p>An example is given, too:</p>\n<blockquote id=\"so_44330470_44330926_1\">\n<pre><code>struct B { };\nstruct D : B { };\nvoid foo(D* dp) {\n  B* bp = dynamic_cast&lt;B*&gt;(dp); // equivalent to B* bp = dp;\n}\n</code></pre>\n</blockquote>\n<p>As you can see, polymorphic classes are clearly not the only use case of <code>dynamic_cast</code> permitted by the standard.</p>\n<p>By the way, cppreference.com <a href=\"http://en.cppreference.com/w/cpp/language/dynamic_cast\" rel=\"noreferrer\">explains it</a> in less standardese language:</p>\n<blockquote>\n<p id=\"so_44330470_44330926_2\">If <em>new_type</em> is a pointer or reference to Base, and the type of\n  <em>expression</em> is a pointer or reference to Derived, where Base is a\n  unique, accessible base class of Derived, the result is a pointer or\n  reference to the Base class subobject within the Derived object\n  pointed or identified by <em>expression</em>. (Note: an implicit cast and\n  static_cast can perform this conversion as well.)</p>\n</blockquote>\n", "LastEditorUserId": "3313064", "LastActivityDate": "2017-06-02T14:13:50.910", "Score": "11", "CreationDate": "2017-06-02T14:07:36.023", "ParentId": "44330470", "CommentCount": "4", "OwnerUserId": "3313064", "LastEditDate": "2017-06-02T14:13:50.910"}, "bq_ids": {"n4140": {"so_44330470_44330926_0": {"length": 14, "quality": 1.0, "section_id": 6015}}, "n3337": {"so_44330470_44330926_0": {"length": 14, "quality": 1.0, "section_id": 5783}}, "n4659": {"so_44330470_44330926_0": {"length": 14, "quality": 1.0, "section_id": 7514}}}, "44330470": {"ViewCount": "557", "Body": "<p>In <a href=\"https://stackoverflow.com/a/44329645/1277769\">this answer</a>, the following scenario came up:</p>\n<pre><code>#include &lt;cassert&gt;\n\nstruct A {};\n\nstruct B { virtual ~B(){} };\n\nstruct AA{};\ntemplate &lt;class T&gt;\nstruct C : A, T {};\n\nint main()\n{\n  B * b = new C&lt;B&gt;;\n  AA * aa = new C&lt;AA&gt;;\n  assert(dynamic_cast&lt;A*&gt;(b));\n  assert(dynamic_cast&lt;A*&gt;(aa)); //this line doesn't compile, as expected\n}\n</code></pre>\n<p>On g++ 4.8.4 (Ubuntu), this compiles and the assert passes.  My question is, is that really legal?  I feel like you shouldn't be able to <code>dynamic_cast</code> to a non-polymorphic class at all, but I freely admit that I'm not an expert in what's happening here.</p>\n<p>When I tried the opposite direction:</p>\n<pre><code>dynamic_cast&lt;B*&gt;((A*)(new C&lt;B&gt;));\n</code></pre>\n<p>it fails to compile, stating that \"source type is not polymorphic\".  I feel like that's a clue, but it still seems a stretch to find the non-polymorphic base class that belongs to a class that the current pointer is a base of (did that sentence make sense?).</p>\n", "Title": "Can you legally dynamic_cast to non-polymorphic base class of a polymorphic class", "CreationDate": "2017-06-02T13:45:46.490", "LastActivityDate": "2017-06-02T14:13:50.910", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2017-06-02T14:00:51.083", "LastEditorUserId": "366904", "Id": "44330470", "Score": "15", "OwnerUserId": "1277769", "Tags": "<c++><casting><polymorphism>", "AnswerCount": "1"}});