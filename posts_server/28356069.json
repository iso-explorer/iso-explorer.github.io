post_cb({"28356079": {"ParentId": "28356069", "LastEditDate": "2015-02-06T00:14:09.253", "CommentCount": "2", "CreationDate": "2015-02-05T23:35:19.867", "OwnerUserId": "95976", "LastEditorUserId": "95976", "PostTypeId": "2", "Id": "28356079", "Score": "9", "Body": "<p>constructor: first base, then derived</p>\n<p>destruction: </p>\n<ul>\n<li>~derived</li>\n<li>~member derived</li>\n<li>~base</li>\n<li>~member base</li>\n</ul>\n<p>code:</p>\n<pre><code>class member {\n    string s;\n\npublic:\n    member(string s) {\n        this-&gt; s = s;\n    }\n\n    ~member() {\n        cout &lt;&lt; \"~member \" &lt;&lt; s &lt;&lt; endl;\n    }\n};\n\nclass base {\n    member m;\npublic:\n    base() : m(\"base\"){\n    }\n\n    ~base() {\n        cout &lt;&lt; \"~base\" &lt;&lt; endl;\n    }\n};\n\nclass derived : base{\n     member m2;\npublic:\n\n    derived() :m2(\"derived\") {    }\n\n    ~derived() {\n        cout &lt;&lt; \"~derived\" &lt;&lt; endl;\n    }\n};\n\nint main(int argc, const char * argv[]) {\n    derived s;\n\n    return 0;\n}\n</code></pre>\n<h3>References &amp; virtual destructor</h3>\n<p>When you plan to dynamically allocate (i.e. when you use the keywords <code>new</code> &amp; <code>delete</code>) a derived object, then <strong>always</strong> have a <code>virtual</code> or a <code>protected</code> destructor on your base. Dynamically deleting the object on the base class reference would otherwise lead to <strong>memory leaks</strong> in the example below:</p>\n<pre><code>class base {\n    member m;\npublic:\n    base() : m(\"base\"){\n    }\n\n    /* correct behaviour is when you add **virtual** in front of the signature */\n    ~base() {\n        cout &lt;&lt; \"~base\" &lt;&lt; endl;\n    }\n};\n\nclass derived : public base{\n     member m2;\n    char* longArray;\npublic:\n\n    derived() :m2(\"derived\") {\n        longArray = new char[1000];\n    }\n\n\n    ~derived() {\n        delete[] longArray; // never called\n        cout &lt;&lt; \"~derived\" &lt;&lt; endl;\n    }\n};\n\nint main(int argc, const char * argv[]) {\n    base *s = new derived; // mind the downcast to **base**\n\n    delete s; /* only the non-virtual destructor on the base and its members is called. \n               No destructor on derived or its members is called.\n               What happens to the memory allocated by derived?\n               **longArray** is leaked forever. \n               Even without **longArray**, it most probably **leaks** memory, as C++ doesn't define its behaviour \n               */\n    return 0;\n}\n</code></pre>\n<p>Output:</p>\n<ul>\n<li>~base</li>\n<li>~member base</li>\n</ul>\n<p>Only base data is cleaned up, and <code>longArray</code> <strong>leaks</strong>.</p>\n", "LastActivityDate": "2015-02-06T00:14:09.253"}, "28356069": {"CommentCount": "4", "CreationDate": "2015-02-05T23:33:24.080", "PostTypeId": "1", "AcceptedAnswerId": "28356079", "LastEditorUserId": "-1", "LastActivityDate": "2015-02-06T00:15:00.120", "LastEditDate": "2017-05-23T12:10:38.810", "ViewCount": "8317", "FavoriteCount": "4", "Title": "What order are destructors called and member variables destroyed in C++ using inhertitance?", "Id": "28356069", "Score": "7", "Body": "<p>Very similar question as these, except not exactly: <a href=\"https://stackoverflow.com/questions/654428/what-is-the-order-in-which-the-destructors-and-the-constructors-are-called-in-c\">What is the order in which the destructors and the constructors are called in C++</a>\n<a href=\"https://stackoverflow.com/questions/2254263/order-of-member-constructor-and-destructor-calls\">Order of member constructor and destructor calls</a></p>\n<p>I want to know: are the member variables of the derived class destroyed before or after the destructor of the base class is called?</p>\n<p>This is in C++ using Visual Studio 2008.  Thanks.</p>\n", "Tags": "<c++><inheritance><visual-studio-2008><destructor>", "OwnerUserId": "3339089", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_28356069_28356248_0": {"section_id": 404, "quality": 0.9540229885057471, "length": 83}}, "n3337": {"so_28356069_28356248_0": {"section_id": 395, "quality": 0.9540229885057471, "length": 83}}, "n4659": {"so_28356069_28356248_0": {"section_id": 422, "quality": 0.9540229885057471, "length": 83}}}, "28356248": {"ParentId": "28356069", "LastEditDate": "2015-02-06T00:15:00.120", "CommentCount": "6", "CreationDate": "2015-02-05T23:52:06.333", "OwnerUserId": "481267", "LastEditorUserId": "481267", "PostTypeId": "2", "Id": "28356248", "Score": "6", "Body": "<p>Here's what the standard says... (C++11, 12.4/8)</p>\n<blockquote>\n<p id=\"so_28356069_28356248_0\">After executing the body of the destructor and destroying any automatic objects allocated within the body, a\n  destructor for class <code>X</code> calls the destructors for <code>X</code>\u2019s direct non-variant non-static data members, the destructors\n  for <code>X</code>\u2019s direct base classes and, if <code>X</code> is the type of the most derived class (12.6.2), its destructor calls the\n  destructors for <code>X</code>\u2019s virtual base classes. All destructors are called as if they were referenced with a qualified\n  name, that is, ignoring any possible virtual overriding destructors in more derived classes. Bases and\n  members are destroyed in the reverse order of the completion of their constructor (see 12.6.2). A return\n  statement (6.6.3) in a destructor might not directly return to the caller; before transferring control to the\n  caller, the destructors for the members and bases are called. Destructors for elements of an array are called\n  in reverse order of their construction (see 12.6).</p>\n</blockquote>\n<p>Note that this order is indeed the reverse of the order given in 12.6.2/10 in C++11. You can't tell what the order of destruction of virtual bases is from looking at 12.4/8 alone, but you can infer it from 12.6.2/10, which specifies that initialization of virtual bases occurs in depth-first search left-to-right order. (Thus, destruction of virtual bases occurs in the reverse of that order.)</p>\n<p>Anyway, you have your answer. Non-static members are destroyed first, then base classes. But a base class's members will be destroyed before the <em>next</em> base class's destructor starts. It really is exactly like depth-first search.</p>\n", "LastActivityDate": "2015-02-06T00:15:00.120"}});