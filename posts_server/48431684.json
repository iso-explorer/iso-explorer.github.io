post_cb({"48431684": {"ViewCount": "101", "Body": "<p>I'm reading about the template keyword qualifier (<a href=\"https://www.ibm.com/support/knowledgecenter/SSPSQF_9.0.0/com.ibm.xlcpp111.aix.doc/language_ref/keyword_template_qualifier.html\" rel=\"noreferrer\">https://www.ibm.com/support/knowledgecenter/SSPSQF_9.0.0/com.ibm.xlcpp111.aix.doc/language_ref/keyword_template_qualifier.html</a>, and <a href=\"https://stackoverflow.com/questions/610245/where-and-why-do-i-have-to-put-the-template-and-typename-keywords\">Where and why do I have to put the \"template\" and \"typename\" keywords?</a>), but there's still something that confuses me.</p>\n<p>Is it possible to have code like this, that compiles successfully, but results in two different operations?</p>\n<pre><code>SomeObjectInstance.template some_function();\nSomeObjectInstance.some_function();\n</code></pre>\n", "Title": "Can `template` keyword qualifier cause code to compile successfully, but differently?", "CreationDate": "2018-01-24T21:13:23.760", "LastActivityDate": "2018-01-30T20:33:39.953", "CommentCount": "3", "PostTypeId": "1", "Id": "48431684", "Score": "6", "OwnerUserId": "2544357", "Tags": "<c++><templates>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_48431684_48432178_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 73}, "so_48431684_48432178_0": {"length": 18, "quality": 0.9, "section_id": 603}, "so_48431684_48432178_3": {"length": 18, "quality": 1.0, "section_id": 286}, "so_48431684_48432178_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 69}}, "n3337": {"so_48431684_48432178_1": {"length": 10, "quality": 0.9090909090909091, "section_id": 68}, "so_48431684_48432178_0": {"length": 18, "quality": 0.9, "section_id": 593}, "so_48431684_48432178_3": {"length": 18, "quality": 1.0, "section_id": 277}, "so_48431684_48432178_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 64}}, "n4659": {"so_48431684_48432178_1": {"length": 11, "quality": 1.0, "section_id": 75}, "so_48431684_48432178_0": {"length": 18, "quality": 0.9, "section_id": 629}, "so_48431684_48432178_3": {"length": 18, "quality": 1.0, "section_id": 293}, "so_48431684_48432178_2": {"length": 7, "quality": 0.7777777777777778, "section_id": 71}}}, "48432178": {"Id": "48432178", "PostTypeId": "2", "Body": "<p>Yes, you could write something like that, have it be well-formed, and give different results. Basically your own example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nstruct foo {\n    template &lt;int = 0&gt;\n    void some_function() { std::cout &lt;&lt; \"template\\n\"; }\n\n    void some_function() { std::cout &lt;&lt; \"non-template\\n\"; }\n};\n\n\nint main(void) {\n    foo f{};\n\n    f.some_function();\n    f.template some_function();\n\n    return 0;\n}\n</code></pre>\n<p><a href=\"http://coliru.stacked-crooked.com/a/ade129561fdc18f6\" rel=\"nofollow noreferrer\">Will print what you expect</a>. When the compiler sees the first call to <code>some_function</code>, it must check if it can synthesize the template overload. Which it can, since we provided a default argument to the template parameter. Then it does overload resolution with both candidates, and <a href=\"http://eel.is/c++draft/over.match.best#1.6\" rel=\"nofollow noreferrer\">[over.match.best]/1</a> tells us that </p>\n<blockquote>\n<p id=\"so_48431684_48432178_0\">Given these definitions, a viable function F1 is defined to be a\n  better function than another viable function F2 if for all arguments\n  i, ICSi(F1) is not a worse conversion sequence than ICSi(F2), and then</p>\n<ul>\n<li>F1 is not a function template specialization and F2 is a function template specialization, or, if not that,</li>\n</ul>\n</blockquote>\n<p>We have two equally good implicit conversion sequences (empty), and that bullet explicitly says the non-template version is a better candidate given everything else is the same.</p>\n<p>But when the <code>template</code> keyword is used, we defer to <a href=\"http://eel.is/c++draft/temp.names#5\" rel=\"nofollow noreferrer\">[temp.names]/5</a>:</p>\n<blockquote>\n<p id=\"so_48431684_48432178_1\">A name prefixed by the keyword template shall be a template-id or the\n  name shall refer to a class template or an alias template.</p>\n</blockquote>\n<p>A template-id has this grammar production in <a href=\"http://eel.is/c++draft/temp.names#1\" rel=\"nofollow noreferrer\">paragraph 1</a>:</p>\n<blockquote id=\"so_48431684_48432178_2\">\n<pre><code>simple-template-id:\n  template-name &lt; template-argument-list &gt;\n\ntemplate-id:\n  simple-template-id\n  operator-function-id &lt; template-argument-list &gt;\n  literal-operator-id &lt; template-argument-list &gt;\n</code></pre>\n</blockquote>\n<p>The template-argument-list is optional in all of the above. But an astute reader will notice that the angle brackets aren't specified as optional. It seems that we must name the template member function as <code>some_function&lt;&gt;</code>. But fortunately we are doing a function call. Template argument deduction is happening, and it is for this reason that <a href=\"http://eel.is/c++draft/temp.arg.explicit#3\" rel=\"nofollow noreferrer\">[temp.arg.explicit]/3</a> can be applied:</p>\n<blockquote>\n<p id=\"so_48431684_48432178_3\">... If all of the template arguments can be deduced, they may all be omitted; in this case, the empty template argument list <code>&lt;&gt;</code> itself may also be omitted. ...</p>\n</blockquote>\n<p>So we indeed may write <code>f.template some_function();</code>, and it <em>must</em> refer to a template, according to [temp.names]/5. That should have the effect of removing the non-template overload from consideration.</p>\n", "LastEditorUserId": "817643", "LastActivityDate": "2018-01-30T20:33:39.953", "Score": "3", "CreationDate": "2018-01-24T21:48:06.537", "ParentId": "48431684", "CommentCount": "7", "OwnerUserId": "817643", "LastEditDate": "2018-01-30T20:33:39.953"}});