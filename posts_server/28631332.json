post_cb({"28631332": {"CommentCount": "2", "ViewCount": "341", "CreationDate": "2015-02-20T14:29:31.940", "LastActivityDate": "2015-02-20T15:55:44.003", "Title": "for_each on a reverse_iterator of a custom bidirectional iterator requires OutputIterator", "AcceptedAnswerId": "28631860", "PostTypeId": "1", "Id": "28631332", "Score": "4", "Body": "<p>I created a simple <em>immutable</em> bidirectional iterator:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>#include &lt;iostream&gt;\n#include &lt;memory&gt;\n#include &lt;iterator&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nclass my_iterator : public std::iterator&lt;std::bidirectional_iterator_tag, int\n//, std::ptrdiff_t, int*, int\n&gt; {\n  int d_val;\npublic:\n  my_iterator() : d_val(0) {}\n  my_iterator(int val) : d_val(val) {}\n\n  my_iterator  operator--(int) { d_val--; return my_iterator(d_val + 1); }\n  my_iterator &amp;operator--()    { d_val--; return *this; }\n  my_iterator  operator++(int) { d_val++; return my_iterator(d_val - 1); }\n  my_iterator &amp;operator++()    { d_val++; return *this; }\n\n  int operator*() const { return d_val; }\n\n  bool operator==(my_iterator const  &amp;o) { return d_val == o.d_val; }\n  bool operator!=(my_iterator const  &amp;o) { return d_val != o.d_val ; }\n};\n\n\nint main() {\n  std::reverse_iterator&lt;my_iterator&gt; reverse_it_begin(25);\n  std::reverse_iterator&lt;my_iterator&gt; reverse_it_end(12);\n  std::for_each(reverse_it_begin, reverse_it_end, [](int e){ std::cout &lt;&lt; e &lt;&lt; ' '; });\n  std::cout &lt;&lt; '\\n';\n}\n</code></pre>\n<p>The iterator is immutable, since operator*() returns an <em>int</em> instead of a <em>int reference</em>. To the best of my understanding this is possible, since whether an iterator meets the BidirectionalIterator concept or the OutputIterator concept is orthogonal (all 4 combinations are possible).</p>\n<p>However, the code below results in an compile time error, namely:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>/usr/include/c++/4.9/bits/stl_iterator.h:164:9: error: invalid initialization of non-const reference of type 'std::reverse_iterator&lt;my_iterator&gt;::reference {aka int&amp;}' from an rvalue of type 'int'\n</code></pre>\n<p>Full context:</p>\n<pre class=\"lang-cpp prettyprint-override\"><code>In file included from /usr/include/c++/4.9/bits/stl_algobase.h:67:0,\n                from /usr/include/c++/4.9/bits/char_traits.h:39,\n                from /usr/include/c++/4.9/ios:40,\n                from /usr/include/c++/4.9/ostream:38,\n                from /usr/include/c++/4.9/iostream:39,\n                from prog.cpp:1:\n/usr/include/c++/4.9/bits/stl_iterator.h: In instantiation of 'std::reverse_iterator&lt;_Iterator&gt;::reference std::reverse_iterator&lt;_Iterator&gt;::operator*() const [with _Iterator = my_iterator; std::reverse_iterator&lt;_Iterator&gt;::reference = int&amp;]':\n/usr/include/c++/4.9/bits/stl_algo.h:3755:6:   required from '_Funct std::for_each(_IIter, _IIter, _Funct) [with _IIter = std::reverse_iterator&lt;my_iterator&gt;; _Funct = main()::&lt;lambda(int)&gt;]'\nprog.cpp:30:86:   required from here\n/usr/include/c++/4.9/bits/stl_iterator.h:164:9: error: invalid initialization of non-const reference of type 'std::reverse_iterator&lt;my_iterator&gt;::reference {aka int&amp;}' from an rvalue of type 'int'\n  return *--__tmp;\n        ^\n\nSuccess time: 0 mem\n</code></pre>\n<p>The pages on cppreference about the reverse_iterator and for_each state that both need a BidirectionalIterator and an InputIterator respectively. I think both requirements are met, however the stl still assigns a dereferenced value to a reference.</p>\n<p>Why does stl's for_each/reverse_iterator expect a T &amp;operator*() on an iterator that needs not to be an OutputIterator?</p>\n<p>PS: The commented line can fix the problem by stating that references should be stored by value, very hacky of course.</p>\n", "Tags": "<c++><c++11><stl><c++14><reverse-iterator>", "OwnerUserId": "853462", "AnswerCount": "2"}, "28631860": {"ParentId": "28631332", "LastEditDate": "2015-02-20T15:00:10.350", "CommentCount": "0", "CreationDate": "2015-02-20T14:55:00.207", "OwnerUserId": "3647361", "LastEditorUserId": "3647361", "PostTypeId": "2", "Id": "28631860", "Score": "5", "Body": "<p>The iterator requirements for all iterators are listed in [iterator.iterators]:</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/loJ3G.png\"/></p>\n<p><code>reference</code> refers to the typedef of <code>iterator_traits&lt;my_iterator&lt;..&gt;&gt;</code>:</p>\n<blockquote>\n<p id=\"so_28631332_28631860_0\">In the following sections, <code>a</code> and <code>b</code> denote values of type <code>X</code> or\n  <code>const X</code>, <code>difference_type</code> and <strong><code>reference</code> refer to the types</strong>\n<code>iterator_traits&lt;X&gt;::difference_type</code> and\n  <strong><code>iterator_traits&lt;X&gt;::reference</code></strong>, respectively, [..]</p>\n</blockquote>\n<p>Since the primary template of <code>iterator_traits</code> just defaults the typedefs to the types defined in the template argument itself, we're talking about the <code>reference</code> typedef of <code>my_iterator</code> - and that one is inherited from the base <code>std::iterator&lt;...&gt;</code>, which defaults it to <code>T&amp;</code>.<br>\nYour <code>operator*</code> returns an <code>int</code> though, which is certainly not <code>int&amp;</code>.</br></p>\n<p>Uncommenting your line is fine for InputIterators since <code>int</code> is convertible to <code>int</code>:</p>\n<p><img alt=\"enter image description here\" src=\"https://i.stack.imgur.com/y5hzj.png\"/></p>\n<p>It fails for ForwardIterators though - [forward.iterators]/1:</p>\n<blockquote>\n<p id=\"so_28631332_28631860_1\">A class or pointer type <code>X</code> satisfies the requirements of a forward\n  iterator if</p>\n<p id=\"so_28631332_28631860_2\">\u2014 if <code>X</code> is a mutable iterator, <code>reference</code> is a reference to <code>T</code>;\n  <strong>if <code>X</code> is a const iterator, <code>reference</code> is a reference to <code>const T</code>,</strong></p>\n</blockquote>\n", "LastActivityDate": "2015-02-20T15:00:10.350"}, "bq_ids": {"n4140": {"so_28631332_28631860_0": {"section_id": 5565, "quality": 1.0, "length": 13}, "so_28631332_28631860_1": {"section_id": 5573, "quality": 1.0, "length": 7}, "so_28631332_28631860_2": {"section_id": 5573, "quality": 1.0, "length": 9}}, "n3337": {"so_28631332_28631860_0": {"section_id": 5347, "quality": 1.0, "length": 13}, "so_28631332_28631860_1": {"section_id": 5355, "quality": 1.0, "length": 7}, "so_28631332_28631860_2": {"section_id": 5355, "quality": 1.0, "length": 9}}, "n4659": {"so_28631332_28631860_0": {"section_id": 7012, "quality": 1.0, "length": 13}, "so_28631332_28631860_1": {"section_id": 7020, "quality": 1.0, "length": 7}, "so_28631332_28631860_2": {"section_id": 7020, "quality": 0.8888888888888888, "length": 8}}}, "28631449": {"ParentId": "28631332", "LastEditDate": "2015-02-20T15:55:44.003", "CommentCount": "2", "CreationDate": "2015-02-20T14:35:50.263", "OwnerUserId": "2756719", "LastEditorUserId": "2756719", "PostTypeId": "2", "Id": "28631449", "Score": "7", "Body": "<p>It doesn't require an OutputIterator. The problem is that your code violates a basic requirement for all input iterators<sup>*</sup>: <code>*r</code> must return <code>reference</code><sup>**</sup>. Your code defines <code>my_iterator::reference</code> as <code>int &amp;</code> (due to <code>std::iterator</code>'s default template argument), but <code>operator*</code> returns an <code>int</code>.</p>\n<p>It is valid for <code>reference</code> to not actually be a reference type (<code>istreambuf_iterator&lt;charT&gt;::reference</code>, for example, is <code>charT</code>), but <code>operator*</code> must return <code>reference</code>. <code>reverse_iterator</code> relies on this, as it defines its <code>reference</code> member, and hence the return type of its <code>operator*</code>, as its wrapped iterator's <code>reference</code>.</p>\n<p>According to the standard, for forward iterators or stronger, <code>reference</code> must be a reference type. But the standard itself lies when it calls <code>vector&lt;bool&gt;::iterator</code> a random access iterator (its <code>operator*</code> must return a proxy), and the committee is apparently planning to lie some more with the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4346.html\" rel=\"nofollow\"><code>array_view</code> proposal</a>. So while making <code>my_iterator::reference</code> <code>int</code> would mean that it is technically no longer a bidirectional iterator, in practice it's likely to work. Hopefully with Concepts we can get better and finer-grained requirements than what we currently have.</p>\n<hr>\n<p><sub><sup>*</sup> There's a contradiction in the standard with respect to output iterators. See <a href=\"http://cplusplus.github.io/LWG/lwg-active.html#2437\" rel=\"nofollow\">LWG issue 2437</a>.</sub></p>\n<p><sub><sup>**</sup> Technically, <code>std::iterator_traits&lt;It&gt;::reference</code>. For class types, <code>iterator_traits</code> by default defers to the member typedef <code>It::reference</code>.</sub></p>\n</hr>", "LastActivityDate": "2015-02-20T15:55:44.003"}});