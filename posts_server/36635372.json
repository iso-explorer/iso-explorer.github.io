post_cb({"36635702": {"Id": "36635702", "PostTypeId": "2", "Body": "<p>The standard has a special rule for this case.</p>\n<blockquote>\n<p id=\"so_36635372_36635702_0\">When a <em>using-declaration</em> brings names from a base class into a derived class scope, member functions and\n  member function templates in the derived class override and/or hide member functions and member function\n  templates with the same name, parameter-type-list (8.3.5), cv-qualification, and <em>ref-qualifier</em> (if any) in a\n  base class (rather than conflicting).</p>\n</blockquote>\n<p>([namespace.udecl]/15)</p>\n<p>Note that as usual, you can force <code>Base::fun</code> to be called by doing <code>d.Base::fun()</code>.</p>\n", "LastActivityDate": "2016-04-14T23:20:26.167", "CommentCount": "0", "CreationDate": "2016-04-14T23:20:26.167", "ParentId": "36635372", "Score": "3", "OwnerUserId": "481267"}, "bq_ids": {"n4140": {"so_36635372_36635740_0": {"length": 11, "quality": 0.55, "section_id": 7003}, "so_36635372_36635702_0": {"length": 35, "quality": 0.9722222222222222, "section_id": 5504}}, "n3337": {"so_36635372_36635740_0": {"length": 11, "quality": 0.55, "section_id": 6749}, "so_36635372_36635702_0": {"length": 35, "quality": 0.9722222222222222, "section_id": 5290}}, "n4659": {"so_36635372_36635740_0": {"length": 11, "quality": 0.55, "section_id": 8500}, "so_36635372_36635702_0": {"length": 32, "quality": 0.8888888888888888, "section_id": 6938}}}, "36635740": {"Id": "36635740", "PostTypeId": "2", "Body": "<p>The link you're referencing is for <code>namespace</code>'s, you should instead refer to the <a href=\"http://en.cppreference.com/w/cpp/language/using_declaration\" rel=\"nofollow\"><code>class</code> using-declaration</a> where it states:</p>\n<blockquote>\n<p id=\"so_36635372_36635740_0\">If the derived class already has a member with the same name, parameter list, and qualifications, the derived class member hides or overrides (doesn't conflict with) the member that is introduced from the base class. </p>\n</blockquote>\n<p>In the case of your posted code, <code>void fun()</code> in <code>Base</code> is hidden by <code>void fun()</code> in <code>Derived</code>, so no, they're not both \"visible\", unless you are explicit when you call <code>fun</code>, example:</p>\n<pre><code>class Base { \n    public:\n        void fun() { std::cout &lt;&lt; \"base\" &lt;&lt; std::endl; }\n};\n\nclass Derived : public Base { \n    public:\n        using Base::fun;\n        void fun() { std::cout &lt;&lt; \"derived\" &lt;&lt; std::endl; }\n};\n\nDerived d;\nd.fun(); // name lookup calls Derived::fun\nd.Base::fun(); // explicitly call Base::fun\n</code></pre>\n<p>Additionally, since you've publicly derived from <code>Base</code>, strictly speaking, you don't need the <code>using</code> declaration; you would in the instance that <code>void fun()</code> were <code>protected</code> in <code>Base</code> or you <code>private</code>/<code>protected</code>'ly inherited from <code>Base</code>, example:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Base {\n    public:\n        void fun() { std::cout &lt;&lt; \"base\" &lt;&lt; std::endl; }\n    protected:\n        void fun2() { std::cout &lt;&lt; \"base2\" &lt;&lt; std::endl; }\n};\n\n// class default is private\nclass Private : Base {\n    public:\n        // fun() won't be accessible since private inheritance and no using\n        // fun2 can now be accessed directly\n        using Base::fun2;\n};\n\nclass Public : public Base {\n    public:\n        // fun is already public\n        using Base::fun2; // bring into scope\n};\n\nclass Derived : public Base {\n    public:\n        using Base::fun;\n        using Base::fun2;\n\n        // overriden method fun, no conflict, choose this method if type is Derived\n        void fun() { std::cout &lt;&lt; \"derived\" &lt;&lt; std::endl; }\n};\n\nint main(int argc, char* argv[])\n{\n    Private p;\n    Public u;\n    Derived d;\n\n    // generates a compiler error since Base is privately inherited\n    //p.fun();\n    p.fun2(); // OK, output: base2\n\n    u.fun(); // OK, output: base\n    u.fun2(); // OK, output: base2\n\n    // use Derived::fun since override\n    d.fun(); // OK, output: derived\n    d.Base::fun(); // OK, output: base\n    d.fun2(); // OK, output: base2\n\n    return 0;\n}\n</code></pre>\n<p>Hope that can help</p>\n", "LastActivityDate": "2016-04-14T23:24:09.850", "CommentCount": "0", "CreationDate": "2016-04-14T23:24:09.850", "ParentId": "36635372", "Score": "0", "OwnerUserId": "1152524"}, "36635372": {"ViewCount": "55", "Body": "<p>Basically, my question is related to name lookup and <code>using</code> declaration (<a href=\"http://en.cppreference.com/w/cpp/language/namespace\" rel=\"nofollow\">http://en.cppreference.com/w/cpp/language/namespace</a>).<br>\nSuppose we have the following (definitely stupid) codes:  </br></p>\n<pre><code>class Base { \npublic:\n    void fun()\n    {std::cout &lt;&lt; \"Base fun\" &lt;&lt; std::endl;}\n};\n\nclass Derived : public Base { \npublic:\n    // Here both names \"fun\" are visible or not?\n    using Base::fun;//let's call this func_1\n\n    void fun() //let's call this func_2\n    {\n        std::cout &lt;&lt; \"Derived fun\" &lt;&lt; std::endl;\n    }\n};\n\nDerived d;\nd.fun(); // This resolves to func_2, why?\n</code></pre>\n<p>Therefore, my understand is now we should have <strong>both</strong> names visible, and then for name lookup, there should be some ambiguity. But actually it is not. What is the reason or in other words, do I misunderstand some concepts?</p>\n", "Title": "effects of using declaration on name lookup for two exactly same names", "CreationDate": "2016-04-14T22:51:36.280", "LastActivityDate": "2016-04-14T23:24:09.850", "CommentCount": "1", "LastEditDate": "2016-04-14T22:57:00.167", "PostTypeId": "1", "LastEditorUserId": "3959454", "Id": "36635372", "Score": "0", "OwnerUserId": "5754243", "Tags": "<c++><name-lookup><using-declaration>", "AnswerCount": "2"}});