post_cb({"bq_ids": {"n4140": {"so_29463711_29463883_0": {"length": 11, "quality": 1.0, "section_id": 175}}, "n3337": {"so_29463711_29463883_0": {"length": 11, "quality": 1.0, "section_id": 169}}, "n4659": {"so_29463711_29463883_0": {"length": 9, "quality": 0.8181818181818182, "section_id": 180}}}, "29463711": {"ViewCount": "210", "Body": "<p>I have a simple templated wrapper struct with a member function calling <code>.error()</code> on an object of its template type.</p>\n<pre><code>template &lt;typename T&gt;\nstruct Wrapper {\n    T t;\n    decltype(auto) f() {\n        return t.error(); // calls .error()\n    }\n};\n</code></pre>\n<p>If I instantiate this with a type that doesn't have an <code>error()</code> member function, it's fine as long as I don't call it.  This is the behavior I want.</p>\n<pre><code>Wrapper&lt;int&gt; w; // no problem here\n// w.error(); // uncommented causes compilation failure\n</code></pre>\n<p>If I use what I thought was the semantic equivalent with a trailing return type, it errors on the variable declaration</p>\n<pre><code>template &lt;typename T&gt;\nstruct Wrapper {\n    T t;\n    auto f() -&gt; decltype(t.error()) {\n        return t.error();\n    }\n};\n\nWrapper&lt;int&gt; w; // error here\n</code></pre>\n<p>I'll accept that the two are not semantically equivalent, but is there anyway to get the behavior of the former using a trailing return type (C++11 only) without specializing the whole class with some kind of <code>HasError</code> tmp trickery?</p>\n", "AcceptedAnswerId": "29463883", "Title": "decltype(auto) in member function ignores invalid body, decltype(expr) fails", "CreationDate": "2015-04-06T00:10:05.247", "Id": "29463711", "CommentCount": "4", "FavoriteCount": "1", "PostTypeId": "1", "LastActivityDate": "2015-04-06T02:49:30.177", "Score": "4", "OwnerUserId": "1013719", "Tags": "<c++><templates><c++11><c++14>", "AnswerCount": "2"}, "29464685": {"Id": "29464685", "PostTypeId": "2", "Body": "<p>One approach is a tagged crtp.</p>\n<pre><code>  // todo:\n  template&lt;class T&gt;\n  struct has_error; // true_type if T.error() is valid\n\n  template&lt;class D,class T,bool Test=has_error&lt;T&gt;{}&gt;\n  struct do_whatever {\n    D* self(){return static_cast&lt;D*&gt;(this);}\n    D const* self()const{return static_cast&lt;D const*&gt;(this);}\n\n    auto f()-&gt;decltype(self()-&gt;t.error()) {\n      return self()-&gt;t.error();\n    }\n  };\n  template&lt;class D,class T&gt;\n  struct do_whatever&lt;D,T,false&gt;{};\n</code></pre>\n<p>now <code>f()</code> just isn't there if <code>T</code> has no <code>error()</code>.</p>\n", "LastActivityDate": "2015-04-06T02:49:30.177", "CommentCount": "0", "CreationDate": "2015-04-06T02:49:30.177", "ParentId": "29463711", "Score": "2", "OwnerUserId": "1774667"}, "29463883": {"Id": "29463883", "PostTypeId": "2", "Body": "<p>The difference between the versions</p>\n<pre><code>decltype(auto) f();\nauto f() -&gt; decltype(t.error());\n</code></pre>\n<p>is that the function <em>declaration</em> of the second can be invalid. Return type deduction for function templates happens when the <em>definition</em> is instantiated <sup>[dcl.spec.auto]/12</sup>. Although I could not find anything about return type deduction for member functions of class templates, I think they behave similarly.</p>\n<p>Implicitly instantiating the class template <code>Wrapper</code> leads to the instantiation of the <em>declarations</em>, but not of the <em>definitions</em> of all (non-virtual) member functions <sup>[temp.inst]/1</sup>. The declaration <code>decltype(auto) f();</code> has a non-deduced placeholder but is valid. On the other hand, <code>auto f() -&gt; decltype(t.error());</code> has an invalid return type for some instantiations.</p>\n<hr>\n<p>A simple solution in C++11 is to postpone the determination of the return type, e.g. by turning <code>f</code> into a function template:</p>\n<pre><code>template&lt;typename U = T&gt;\nauto f() -&gt; decltype( std::declval&lt;U&amp;&gt;().error() );\n</code></pre>\n<p>The definition of that function worries me a bit, though:</p>\n<pre><code>template&lt;typename U = T&gt;\nauto f() -&gt; decltype( std::declval&lt;U&amp;&gt;().error() )\n{\n    return t.error();\n}\n</code></pre>\n<p>For the specializations of <code>Wrapper</code> where <code>t.error()</code> is not valid, the above <code>f</code> is a function template that cannot produce valid specializations. This could fall under [temp.res]/8, which says that such templates are ill-formed, No Diagnostic Required:</p>\n<blockquote>\n<p id=\"so_29463711_29463883_0\">If no valid specialization can be generated for a template, and that template is not instantiated, the template is ill-formed, no diagnostic\n  required.</p>\n</blockquote>\n<p>However, I suspect that rule has been introduced to <em>allow</em>, but not require, implementations to check for errors in non-instantiated templates. In this case, there is no programming error in the <em>source code</em>; the error would occur in instantiations of the class template described by the source code. Therefore, I think it should be fine.</p>\n<hr>\n<p>An alternative solution is to use a fall-back return type to make the function <em>declaration</em> well-formed even if the <em>definition</em> is not (for all instantiations):</p>\n<pre><code>#include &lt;type_traits&gt;\n\ntemplate&lt;typename T&gt; struct type_is { using type = T; };\n\ntemplate &lt;typename T&gt;\nstruct Wrapper {\n    T t;\n\n    template&lt;typename U=T, typename=void&gt;\n    struct error_return_type_or_void : type_is&lt;void&gt; {};\n\n    template&lt;typename U&gt;\n    struct error_return_type_or_void\n        &lt;U, decltype(std::declval&lt;U&amp;&gt;().error(), void())&gt;\n    : type_is&lt;decltype(std::declval&lt;U&amp;&gt;().error())&gt; {};\n\n    auto f() -&gt; typename error_return_type_or_void&lt;&gt;::type {\n        return t.error();\n    }\n};\n</code></pre>\n</hr></hr>", "LastEditorUserId": "420683", "LastActivityDate": "2015-04-06T01:00:37.320", "Score": "5", "CreationDate": "2015-04-06T00:37:23.220", "ParentId": "29463711", "CommentCount": "6", "OwnerUserId": "420683", "LastEditDate": "2015-04-06T01:00:37.320"}});