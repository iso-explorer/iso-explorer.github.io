post_cb({"4782757": {"CommentCount": "2", "AcceptedAnswerId": "4782927", "PostTypeId": "1", "LastEditorUserId": "168175", "CreationDate": "2011-01-24T13:51:45.600", "LastActivityDate": "2017-07-04T03:08:31.937", "LastEditDate": "2011-12-19T16:00:48.497", "ViewCount": "51612", "FavoriteCount": "266", "Title": "Rule-of-Three becomes Rule-of-Five with C++11?", "Id": "4782757", "Score": "290", "Body": "<p>So, after watching <a href=\"http://channel9.msdn.com/shows/Going+Deep/C9-Lectures-Introduction-to-STL-with-Stephan-T-Lavavej/\" rel=\"noreferrer\">this wonderful lecture</a> on rvalue references, I thought that every class would benefit of such a \"move constructor\", <code>template&lt;class T&gt; MyClass(T&amp;&amp; other)</code> <strong><em>edit</em></strong> and of course a \"move assignment operator\", <code>template&lt;class T&gt; MyClass&amp; operator=(T&amp;&amp; other)</code> as Philipp points out in his answer, if it has dynamically allocated members, or generally stores pointers. Just like you <em>should</em> have a copy-ctor, assignment operator and destructor if the points mentioned before apply.\nThoughts?</p>\n", "Tags": "<c++><constructor><c++11><rvalue-reference><rule-of-three>", "OwnerUserId": "500104", "AnswerCount": "8"}, "4782901": {"ParentId": "4782757", "CommentCount": "0", "Body": "<p>We cannot say that rule of 3 becomes rule of 4 (or 5) now without breaking all existing code that does enforce rule of 3 and does not implement any form of move semantics.</p>\n<p>Rule of 3 means if you implement one you must implement all 3.</p>\n<p>Also not aware there will be any auto-generated move. The purpose of \"rule of 3\" is because they automatically exist and if you implement one, it is most likely the default implementation of the other two is wrong.</p>\n", "OwnerUserId": "442284", "PostTypeId": "2", "Id": "4782901", "Score": "3", "CreationDate": "2011-01-24T14:07:37.290", "LastActivityDate": "2011-01-24T14:07:37.290"}, "4782979": {"ParentId": "4782757", "CommentCount": "9", "Body": "<p>In the general case, then yes, the rule of three just became the of five, with the move assignment operator and move constructor added in. However, not <em>all</em> classes are copyable and movable, some are just movable, some are just copyable.</p>\n", "OwnerUserId": "298661", "PostTypeId": "2", "Id": "4782979", "Score": "2", "CreationDate": "2011-01-24T14:16:09.290", "LastActivityDate": "2011-01-24T14:16:09.290"}, "4782927": {"ParentId": "4782757", "PostTypeId": "2", "CommentCount": "15", "Body": "<p>I'd say the Rule of Three becomes the Rule of Three, Four and Five:</p>\n<blockquote>\n<p id=\"so_4782757_4782927_0\">Each class should explicitly define exactly one\n  of the following set of special member\n  functions:</p>\n<ul>\n<li>None</li>\n<li>Destructor, copy constructor, copy assignment operator</li>\n</ul>\n<p id=\"so_4782757_4782927_1\">In addition, each class that explicitly defines a destructor may explicitly define a move constructor and/or a move assignment operator.</p>\n<p id=\"so_4782757_4782927_2\">Usually, one of the following sets of special member\n  functions is sensible:</p>\n<ul>\n<li>None (for many simple classes where the implicitly generated special member functions are correct and fast)</li>\n<li>Destructor, copy constructor, copy assignment operator (in this case the\n  class will not be movable)</li>\n<li>Destructor, move constructor, move assignment operator (in this case the class will not be copyable, useful for resource-managing classes where the underlying resource is not copyable)</li>\n<li>Destructor, copy constructor, copy assignment operator, move constructor (because of copy elision, there is no overhead if the copy assignment operator takes its argument by value)</li>\n<li>Destructor, copy constructor, copy assignment operator, move constructor,\n  move assignment operator</li>\n</ul>\n</blockquote>\n<p>Note that move constructor and move assignment operator won't be generated for a class that explicitly declares any of the other special member functions, that copy constructor and copy assignment operator won't be generated for a class that explicitly declares a move constructor or move assignment operator, and that a class with a explicitly declared destructor and implicitly defined copy constructor or implicitly defined copy assignment operator is considered deprecated. In particular, the following perfectly valid C++03 polymorphic base class</p>\n<pre><code>class C {\n  virtual ~C() { }   // allow subtype polymorphism\n};\n</code></pre>\n<p>should be rewritten as follows:</p>\n<pre><code>class C {\n  C(const C&amp;) = default;               // Copy constructor\n  C(C&amp;&amp;) = default;                    // Move constructor\n  C&amp; operator=(const C&amp;) &amp; = default;  // Copy assignment operator\n  C&amp; operator=(C&amp;&amp;) &amp; = default;       // Move assignment operator\n  virtual ~C() { }                     // Destructor\n};\n</code></pre>\n<p>A bit annoying, but probably better than the alternative (automatic generation of all special member functions).</p>\n<p>In contrast to the Rule of the Big Three, where failing to adhere to the rule can cause serious damage, not explicitly declaring the move constructor and move assignment operator is generally fine but often suboptimal with respect to efficiency. As mentioned above, move constructor and move assignment operators are only generated if there is no explicitly declared copy constructor, copy assignment operator or destructor. This is not symmetric to the traditional C++03 behavior with respect to auto-generation of copy constructor and copy assignment operator, but is much safer. So the possibility to define move constructors and move assignment operators is very useful and creates new possibilities (purely movable classes), but classes that adhere to the C++03 Rule of the Big Three will still be fine.</p>\n<p>For resource-managing classes you can define the copy constructor and copy assignment operator as deleted (which counts as definition) if the underlying resource cannot be copied. Often you still want move constructor and move assignment operator. Copy and move assignment operators will often be implemented using <code>swap</code>, as in C++03. If you have a move constructor and move assignment operator, specializing <code>std::swap</code> will become unimportant because the generic <code>std::swap</code> uses the move constructor and move assignment operator if available, and that should be fast enough.</p>\n<p>Classes that are not meant for resource management (i.e., no non-empty destructor) or subtype polymorphism (i.e., no virtual destructor) should declare none of the five special member functions; they will all be auto-generated and behave correct and fast.</p>\n", "OwnerUserId": "178761", "LastEditorUserId": "2296458", "LastEditDate": "2015-01-03T00:40:01.483", "Id": "4782927", "Score": "275", "CreationDate": "2011-01-24T14:10:43.220", "LastActivityDate": "2015-01-03T00:40:01.483"}, "27891048": {"ParentId": "4782757", "CommentCount": "1", "Body": "<p>Here's a short update on the current status and related developments since Jan 24 '11. </p>\n<p>According to the C++11 Standard (see Annex D's [depr.impldec]):</p>\n<blockquote>\n<p id=\"so_4782757_27891048_0\">The implicit declaration of a copy constructor is deprecated if the class has a user-declared copy assignment operator or a user-declared destructor. The implicit declaration of a copy assignment operator is deprecated if the class has a user-declared copy constructor or a user-declared destructor.</p>\n</blockquote>\n<p>It was actually <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3578.pdf\">proposed</a> to obsolete the deprecated behavior <em>giving C++14 a true \u201crule of five\u201d instead of the traditional \u201crule of three\u201d.</em> In 2013 the EWG voted against this proposal to be implemented in C++2014. The major rationale for the decision on the proposal had to do with general concerns about breaking existing code. </p>\n<p>Recently, it has been <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2014/n3839.pdf\">proposed</a> again to adapt the C++11 wording so as to achieve the informal Rule of Five, namely that </p>\n<blockquote>\n<p id=\"so_4782757_27891048_1\"><strong>no copy function, move function, or destructor be compiler-generated if any of these functions is user-provided.</strong></p>\n</blockquote>\n<p>If approved by the EWG, the \"rule\" is likely to be adopted for C++17.</p>\n", "OwnerUserId": "463755", "PostTypeId": "2", "Id": "27891048", "Score": "8", "CreationDate": "2015-01-11T19:17:23.650", "LastActivityDate": "2015-01-11T19:17:23.650"}, "4782837": {"ParentId": "4782757", "PostTypeId": "2", "CommentCount": "7", "Body": "<p>Yes, I think it would be nice to provide a move constructor for such classes, but remember that:</p>\n<ul>\n<li><p>It's only an optimization.</p>\n<p>Implementing only one or two of the copy constructor, assignment operator or destructor will probably lead to bugs, while not having a move constructor will just potentially reduce performance.</p></li>\n<li><p>Move constructor cannot always be applied without modifications.</p>\n<p>Some classes always have their pointers allocated, and thus such classes always delete their pointers in the destructor. In these cases you'll need to add extra checks to say whether their pointers are allocated or have been moved away (are now null).</p></li>\n</ul>\n", "OwnerUserId": "300805", "LastEditorUserId": "1331457", "LastEditDate": "2013-02-01T13:29:46.830", "Id": "4782837", "Score": "14", "CreationDate": "2011-01-24T14:00:28.463", "LastActivityDate": "2013-02-01T13:29:46.830"}, "4786477": {"ParentId": "4782757", "PostTypeId": "2", "CommentCount": "4", "Body": "<p>Basically, it's like this: If you don't declare any move operations, you should respect the rule of three. If you declare a move operation, there is no harm in \"violating\" the rule of three as the generation of compiler-generated operations has gotten very restrictive. Even if you don't declare move operations and violate the rule of three, a C++0x compiler is expected to give you a warning in case one special function was user-declared and other special functions have been auto-generated due to a now deprecated \"C++03 compatibility rule\".</p>\n<p>I think it's safe to say that this rule becomes a little less significant. The real problem in C++03 is that implementing different copy semantics required you to user-declare <em>all</em> related special functions so that none of them is compiler-generated (which would otherwise do the wrong thing). But C++0x changes the rules about special member function generation. If the user declares just one of these functions to change the copy semantics it'll prevent the compiler from auto-generating the remaining special functions. This is good because a missing declaration turns a runtime error into a compilation error now (or at least a warning). As a C++03 compatibility measure some operations are still generated but this generation is deemed deprecated and should at least produce a warning in C++0x mode.</p>\n<p>Due to the rather restrictive rules about compiler-generated special functions and the C++03 compatibility, the rule of three stays the rule of three.</p>\n<p>Here are some exaples that should be fine with newest C++0x rules:</p>\n<pre><code>template&lt;class T&gt;\nclass unique_ptr\n{\n   T* ptr;\npublic:\n   explicit unique_ptr(T* p=0) : ptr(p) {}\n   ~unique_ptr();\n   unique_ptr(unique_ptr&amp;&amp;);\n   unique_ptr&amp; operator=(unique_ptr&amp;&amp;);\n};\n</code></pre>\n<p>In the above example, there is no need to declare any of the other special functions as deleted. They simply won't be generated due to the restrictive rules. The presence of a user-declared move operations disables compiler-generated copy operations. But in a case like this:</p>\n<pre><code>template&lt;class T&gt;\nclass scoped_ptr\n{\n   T* ptr;\npublic:\n   explicit scoped_ptr(T* p=0) : ptr(p) {}\n   ~scoped_ptr();\n};\n</code></pre>\n<p>a C++0x compiler is now expected to produce a warning about possibly compiler-generated copy operations that might do the wrong thing. Here, the rule of three matters and should be respected. A warning in this case is totally appropriate and gives the user the chance to handle the bug. We can get rid of the issue via deleted functions:</p>\n<pre><code>template&lt;class T&gt;\nclass scoped_ptr\n{\n   T* ptr;\npublic:\n   explicit scoped_ptr(T* p=0) : ptr(p) {}\n   ~scoped_ptr();\n   scoped_ptr(scoped_ptr const&amp;) = delete;\n   scoped_ptr&amp; operator=(scoped_ptr const&amp;) = delete;\n};\n</code></pre>\n<p>So, the rule of three still applies here simply because of the C++03 compatibility.</p>\n", "OwnerUserId": "172531", "LastEditorUserId": "172531", "LastEditDate": "2011-01-24T20:14:41.570", "Id": "4786477", "Score": "4", "CreationDate": "2011-01-24T19:55:52.517", "LastActivityDate": "2011-01-24T20:14:41.570"}, "4783428": {"ParentId": "4782757", "CommentCount": "0", "Body": "<p>I don't think so, <a href=\"http://en.wikipedia.org/wiki/Rule_of_three_%28C%2B%2B_programming%29\" rel=\"noreferrer\">the rule of three</a> is a rule of thumb that states that a class that implements one of the following but not them all is probably buggy.</p>\n<ol>\n<li>Copy constructor</li>\n<li>Assignment operator</li>\n<li>Destructor</li>\n</ol>\n<p>However leaving out the move constructor or move assignment operator does not imply a bug. It <em>may</em> be a missed opportunity at optimization (in most cases) or that move semantics aren't relevant for this class but this isn't a bug.</p>\n<p>While it may be best practice to define a move constructor when relevant, it isn't mandatory. There are many cases in which a move constructor isn't relevant for a class (e.g. <code>std::complex</code>) and all classes that behave correctly in C++03 will continue to behave correctly in C++0x even if they don't define a move constructor.</p>\n", "OwnerUserId": "3848", "PostTypeId": "2", "Id": "4783428", "Score": "17", "CreationDate": "2011-01-24T14:56:36.483", "LastActivityDate": "2011-01-24T14:56:36.483"}, "13951447": {"ParentId": "4782757", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>I can't believe that nobody linked to <a href=\"https://web.archive.org/web/20161023192637/https://rmf.io/cxx11/rule-of-zero\" rel=\"nofollow noreferrer\">this</a>.</p>\n<p>Basically article argues for \"Rule of Zero\".\nIt is not appropriate for me to quote entire article but I believe this is the main point:</p>\n<blockquote>\n<p id=\"so_4782757_13951447_0\">Classes that have custom destructors, copy/move constructors or copy/move assignment operators should deal exclusively with ownership.\n  Other classes should not have custom destructors, copy/move\n  constructors or copy/move assignment operators.</p>\n</blockquote>\n<p>Also this bit is IMHO important:</p>\n<blockquote>\n<p id=\"so_4782757_13951447_1\">Common \"ownership-in-a-package\" classes are included in the standard\n  library: <code>std::unique_ptr</code> and <code>std::shared_ptr</code>. Through the use of\n  custom deleter objects, both have been made flexible enough to manage\n  virtually any kind of resource.</p>\n</blockquote>\n", "OwnerUserId": "700825", "LastEditorUserId": "2688027", "LastEditDate": "2017-07-04T03:08:31.937", "Id": "13951447", "Score": "54", "CreationDate": "2012-12-19T11:30:12.553", "LastActivityDate": "2017-07-04T03:08:31.937"}, "bq_ids": {"n4140": {"so_4782757_27891048_1": {"section_id": 4014, "quality": 0.625, "length": 5}, "so_4782757_27891048_0": {"section_id": 4904, "quality": 0.8461538461538461, "length": 22}, "so_4782757_4782927_0": {"section_id": 361, "quality": 0.5454545454545454, "length": 6}}, "n3337": {"so_4782757_27891048_1": {"section_id": 6785, "quality": 0.625, "length": 5}, "so_4782757_27891048_0": {"section_id": 4699, "quality": 0.8461538461538461, "length": 22}, "so_4782757_4782927_0": {"section_id": 351, "quality": 0.5454545454545454, "length": 6}}, "n4659": {"so_4782757_27891048_1": {"section_id": 4871, "quality": 0.625, "length": 5}, "so_4782757_27891048_0": {"section_id": 6306, "quality": 0.8461538461538461, "length": 22}, "so_4782757_4782927_0": {"section_id": 373, "quality": 0.5454545454545454, "length": 6}}}});