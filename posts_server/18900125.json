post_cb({"bq_ids": {"n4140": {"so_18900125_18901407_1": {"length": 10, "quality": 1.0, "section_id": 715}, "so_18900125_18901407_0": {"length": 4, "quality": 0.8, "section_id": 735}}, "n3337": {"so_18900125_18901407_1": {"length": 8, "quality": 0.8, "section_id": 704}, "so_18900125_18901407_0": {"length": 4, "quality": 0.8, "section_id": 724}}, "n4659": {"so_18900125_18901407_1": {"length": 10, "quality": 1.0, "section_id": 745}, "so_18900125_18901407_0": {"length": 4, "quality": 0.8, "section_id": 764}}}, "18902829": {"Id": "18902829", "PostTypeId": "2", "Body": "<p>Regarding \"Knowing that, why one needs a custom allocator, what does it change ?\"</p>\n<ul>\n<li>A custom allocator may optimize allocations of small objects</li>\n<li>optimize allocations of objects having a common size </li>\n<li>squeeze the last bit out of memory </li>\n<li>...</li>\n</ul>\n<p>The default one has one strategy, only (likely).</p>\n", "LastActivityDate": "2013-09-19T18:59:43.513", "Score": "0", "CreationDate": "2013-09-19T18:59:43.513", "ParentId": "18900125", "CommentCount": "0", "OwnerUserId": "2249683"}, "18900125": {"ViewCount": "309", "Body": "<p>When I have studied the STL i have been through the Allocator, I have found a lot of stuff on internet and more or less i have understood what they do. I have seen a Custom Allocator to see how they are implemented, but my question is how they are used by containers, let's say into the Vector ?</p>\n<p>They always said vector is using DEFAULT Allocator. For example the empty vector constructor is :  </p>\n<pre><code>   explicit vector (const allocator&amp; alloc = allocator());\n</code></pre>\n<p>But how vector uses allocator ? </p>\n<p>When and where, vector, behind the scene, is using Allocator::allocate() and Allocator::construct() ?</p>\n<p>Knowing that, why one needs a custom allocator, what does it change ?</p>\n", "Title": "How does vector use default allocator?", "CreationDate": "2013-09-19T16:23:48.467", "LastActivityDate": "2013-09-19T18:59:43.513", "CommentCount": "5", "LastEditDate": "2013-09-19T16:40:16.060", "PostTypeId": "1", "LastEditorUserId": "44729", "Id": "18900125", "Score": "5", "OwnerUserId": "2051951", "Tags": "<c++>", "AnswerCount": "3"}, "18901407": {"Id": "18901407", "PostTypeId": "2", "Body": "<p>As @BenjaminLindley mentioned, there are many places that allocators may be used inside containers.  One example is <code>push_back</code>, <strong>which uses allocator traits to construct a copy of its argument inside the container</strong>.</p>\n<p>The standard (23.2.3) describes <code>push_back</code> as:</p>\n<blockquote>\n<pre><code>a.push_back(t)\n</code></pre>\n<p id=\"so_18900125_18901407_0\">Appends a copy of t. Requires: T shall be CopyInsertable into X.</p>\n</blockquote>\n<p>Later, the term CopyInsertable is defined as:</p>\n<blockquote>\n<p id=\"so_18900125_18901407_1\">T is CopyInsertable into X means that, in addition to T being\n  MoveInsertable into X, the following expression is well-formed:</p>\n<pre><code>allocator_traits&lt;A&gt;::construct(a, p, t)\n</code></pre>\n</blockquote>\n<p>...which can be turned into:</p>\n<blockquote id=\"so_18900125_18901407_2\">\n<pre><code>a.construct(p, t)\n</code></pre>\n</blockquote>\n<p>...which effectively uses the allocator <code>a</code> to construct a copy of <code>t</code> at location <code>p</code>.</p>\n", "LastActivityDate": "2013-09-19T17:36:46.180", "Score": "2", "CreationDate": "2013-09-19T17:36:46.180", "ParentId": "18900125", "CommentCount": "0", "OwnerUserId": "98654"}, "18901952": {"Id": "18901952", "PostTypeId": "2", "Body": "<p>Different compilers use different implementations of the STL, and it is up to these implementations to determine how they use the Allocators. This can lead to some unfortunate results.</p>\n<p>For example, I work primarily with embedded systems based on the ARM architecture, and at one point, I tried to implement my own Allocator based on fixed-size memory blocks for use with <code>list</code>, <code>map</code>, and <code>set</code> (I wasn't expecting it to work for <code>vector</code>, since a large-enough vector would exceed the size of the blocks). In the process, I discovered that the ARM compiler v3.1 uses a version of the RogueWave implementation of the STL in which some containers made certain assumptions about the behavior of Allocators. In the case of <code>map</code> and <code>set</code>, for instance:</p>\n<ul>\n<li>It never called <code>Allocator::max_size()</code> - it assumed that it returned something big enough that it didn't have to worry about it.</li>\n<li>It assumed that <code>allocate()</code> was slow, and tried to optimize it by allocating several objects at once (<code>vector</code> is designed to do this, but I wasn't expecting the same behavior to apply to containers like <code>map</code> and <code>set</code> that don't use contiguous memory). Basically, instead of calling <code>allocate(sizeof(T))</code>, it called <code>allocate(sizeof(T) * 20)</code> to get a pool of memory that it could then re-allocate internally as new objects were created.</li>\n</ul>\n<p>These assumptions pretty much torpedoed my attempts to use the STL in that project - I eventually wound up using <code>boost::intrusive</code> containers instead.</p>\n", "LastActivityDate": "2013-09-19T18:06:34.673", "Score": "2", "CreationDate": "2013-09-19T18:06:34.673", "ParentId": "18900125", "CommentCount": "0", "OwnerUserId": "2332809"}});