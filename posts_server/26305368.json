post_cb({"bq_ids": {"n4140": {"so_26305368_26305550_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 231}, "so_26305368_26305550_2": {"length": 16, "quality": 1.0, "section_id": 274}, "so_26305368_26305550_1": {"length": 5, "quality": 1.0, "section_id": 231}}, "n3337": {"so_26305368_26305550_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 224}, "so_26305368_26305550_2": {"length": 16, "quality": 1.0, "section_id": 265}, "so_26305368_26305550_1": {"length": 5, "quality": 1.0, "section_id": 224}}, "n4659": {"so_26305368_26305550_0": {"length": 5, "quality": 0.8333333333333334, "section_id": 239}, "so_26305368_26305550_2": {"length": 16, "quality": 1.0, "section_id": 281}, "so_26305368_26305550_1": {"length": 5, "quality": 1.0, "section_id": 239}}}, "26305368": {"ViewCount": "1894", "Body": "<p>I have defined a simple class-template with one member function. It is defined outside the class with an additional (explicit) specialization, also defined outside the class. All in one headerfile. If you include this header in multiple translation units you get a linker error due to One-Definition-Rule. </p>\n<pre><code>// Header with a template\n\ntemplate &lt;class T&gt;\nclass TestClass\n{\npublic:\n    TestClass() {};\n    ~TestClass() {};\n    bool MemberFunction();\n};\n\ntemplate &lt;class T&gt;\nbool TestClass&lt;T&gt;::MemberFunction()\n{\n    return true;\n}\n\ntemplate &lt;&gt;\nbool TestClass&lt;double&gt;::MemberFunction()\n{\n    return true;\n};\n</code></pre>\n<p>Everything fine so far. But If I put the definition of the member function inside the class body, the linker error disappears and the functions can be used throughout different translation units. </p>\n<pre><code>// Header with a template\n\ntemplate &lt;class T&gt;\nclass TestClass\n{\npublic:\n    TestClass() {};\n    ~TestClass() {};\n    bool MemberFunction()\n    {\n        return true;\n    }\n};\n\ntemplate &lt;&gt;\nbool TestClass&lt;double&gt;::MemberFunction()\n{\n    return true;\n};\n</code></pre>\n<p>My question is why does it work that way? I use MSVC 2012. ODR has some exceptions on templates what I first thought to be the reason. But the definition of the \"Base\" function inside/outside the class makes the difference here.</p>\n", "AcceptedAnswerId": "26305550", "Title": "C++ - Define member function outside template-class but in header", "CreationDate": "2014-10-10T17:59:34.130", "Id": "26305368", "CommentCount": "2", "FavoriteCount": "1", "PostTypeId": "1", "LastEditDate": "2014-10-10T18:29:28.647", "LastEditorUserId": "679906", "LastActivityDate": "2014-10-11T14:37:57.663", "Score": "1", "OwnerUserId": "679906", "Tags": "<c++><templates><one-definition-rule>", "AnswerCount": "1"}, "26305550": {"Id": "26305550", "PostTypeId": "2", "Body": "<p>14.7/5 says </p>\n<blockquote>\n<p id=\"so_26305368_26305550_0\">5 For a given template and a given set of template-arguments,</p>\n<ul>\n<li>an explicit instantiation definition shall appear at most once in a program,</li>\n<li><strong>an explicit specialization shall be defined at most once in a program (according to 3.2)</strong>, and</li>\n<li>both an explicit instantiation and a declaration of an explicit specialization shall not appear in a program unless the explicit\n  instantiation follows a declaration of the explicit specialization. </li>\n</ul>\n<p id=\"so_26305368_26305550_1\">An\n  implementation is not required to diagnose a violation of this rule.</p>\n</blockquote>\n<p>The second bullet applies to your case. The ODR defined in 3.2 says the same thing, albeit in a less distilled form.</p>\n<p>Regardless of where and how the non-specialized version of member function is defined, the <em>specialized</em> version definition</p>\n<pre><code>template &lt;&gt; bool TestClass&lt;double&gt;::MemberFunction()\n{\n    return true;\n};\n</code></pre>\n<p>has to go into a <code>.cpp</code> file. If kept in the header file, it will produce an ODR violation once the header gets included into more than one translation unit. GCC reliably detect this violation. MSVC seems to be less reliable in that regard. But, as the quote above states, an implementation is not required to diagnose a violation of this rule.</p>\n<p>The header file should only contain a non-defining <em>declaration</em> of that specialization </p>\n<pre><code>template &lt;&gt; bool TestClass&lt;double&gt;::MemberFunction();\n</code></pre>\n<p>The fact that in MSVC the error appears or disappears depending on such seemingly unrelated factor as how the non-specialized version of the function is defined must be a quirk of MSVC compiler.</p>\n<hr>\n<p>After further research, it appears that MSVC implementation is actually broken: its behavior goes beyond what's allowed by the \"no diagnostic is required\" permission given by the language specification.</p>\n<p>The behavior you observed in your experiments in consistent with the following: declaring the primary function template as <code>inline</code> automatically makes the explicit specialization of that template <code>inline</code> as well. This is not supposed to be that way. In 14.7.3/14 the language specification says </p>\n<blockquote>\n<p id=\"so_26305368_26305550_2\">An explicit specialization of a function template is inline only if it\n  is declared with the inline specifier or defined as deleted, and\n  independently of whether its function template is inline.</p>\n</blockquote>\n</hr>", "LastEditorUserId": "187690", "LastActivityDate": "2014-10-11T14:37:57.663", "Score": "4", "CreationDate": "2014-10-10T18:11:06.413", "ParentId": "26305368", "CommentCount": "13", "OwnerUserId": "187690", "LastEditDate": "2014-10-11T14:37:57.663"}});