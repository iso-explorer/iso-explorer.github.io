post_cb({"19413260": {"ParentId": "19411865", "CommentCount": "1", "Body": "<p>The error is telling you that:</p>\n<pre><code>/usr/include/c++/4.8.1/bits/stl_pair.h:127:17: error: \u2018constexpr std::pair&lt;_T1, _T2&gt;::pair(const std::pair&lt;_T1, _T2&gt;&amp;) [with _T1 = trie&lt;std::basic_string&lt;char&gt; &gt;::iterator; _T2 = bool]\u2019 declared to take const reference, but implicit declaration would take non-const\n   constexpr pair(const pair&amp;) = default;\n</code></pre>\n<p>In other words, the implicit copy constructor generated for pair would have signature pair(pair&amp;) rather than pair(const pair&amp;). According to <a href=\"http://en.cppreference.com/w/cpp/language/copy_constructor\" rel=\"nofollow\">cppreference</a></p>\n<blockquote>\n<p id=\"so_19411865_19413260_0\"><strong>Implicitly-declared copy constructor</strong></p>\n<p id=\"so_19411865_19413260_1\">If no user-defined copy constructors are provided for a class type (struct, class, or union), the compiler will always declare a copy constructor as an inline public member of its class. This implicitly-declared copy constructor has the form T::T(const T&amp;) if all of the following is true:</p>\n<ul>\n<li>all direct and virtual bases of T have copy constructors with references to const or to - const volatile as their first parameters</li>\n<li>all non-static members of T have copy constructors with references to const or to const volatile as their first parameters</li>\n</ul>\n<p id=\"so_19411865_19413260_2\">Otherwise, the implicitly-declared copy constructor is T::T(T&amp;). (Note that due to these rules, the implicitly-declared copy constructor cannot bind to a volatile lvalue argument)</p>\n</blockquote>\n<p>Most likely your iterator is not declaring its copy constructor with iterator(const iterator&amp;).</p>\n", "OwnerUserId": "139091", "PostTypeId": "2", "Id": "19413260", "Score": "3", "CreationDate": "2013-10-16T20:31:35.543", "LastActivityDate": "2013-10-16T20:31:35.543"}, "19411955": {"ParentId": "19411865", "CommentCount": "0", "Body": "<p>The clue seems to be in the part of the error message that says:</p>\n<pre><code> \u2018constexpr std::pair&lt;_T1, _T2&gt;::pair(const std::pair&lt;_T1, _T2&gt;&amp;) \\\n     [with _T1 = trie&lt;std::basic_string&lt;char&gt; &gt;::iterator; _T2 = bool]\u2019\n</code></pre>\n<p>This suggests that your <code>trie</code> is somehow implicated (read: it is your bug, not the standard library). But without a whole lot more code, one would be hard pressed to narrow it down further for you.</p>\n", "OwnerUserId": "1967396", "PostTypeId": "2", "Id": "19411955", "Score": "0", "CreationDate": "2013-10-16T19:22:33.453", "LastActivityDate": "2013-10-16T19:22:33.453"}, "19411865": {"CommentCount": "21", "AcceptedAnswerId": "19413260", "PostTypeId": "1", "LastEditorUserId": "1830736", "CreationDate": "2013-10-16T19:17:28.193", "LastActivityDate": "2013-10-16T20:31:35.543", "LastEditDate": "2013-10-16T20:27:51.027", "ViewCount": "2089", "FavoriteCount": "1", "Title": "Is this a standard library error, or mine?", "Id": "19411865", "Score": "2", "Body": "<p>When I try to compile a program I'm working on, I get the following error:</p>\n<pre><code>In file included from /usr/include/c++/4.8.1/bits/stl_algobase.h:64:0,\n                 from /usr/include/c++/4.8.1/bits/char_traits.h:39,\n                 from /usr/include/c++/4.8.1/string:40,\n                 from main.cpp:1:\n/usr/include/c++/4.8.1/bits/stl_pair.h: In instantiation of \u2018struct std::pair&lt;trie&lt;std::basic_string&lt;char&gt; &gt;::iterator, bool&gt;\u2019:\nmain.cpp:7:15:   required from here\n/usr/include/c++/4.8.1/bits/stl_pair.h:127:17: error: \u2018constexpr std::pair&lt;_T1, _T2&gt;::pair(const std::pair&lt;_T1, _T2&gt;&amp;) [with _T1 = trie&lt;std::basic_string&lt;char&gt; &gt;::iterator; _T2 = bool]\u2019 declared to take const reference, but implicit declaration would take non-const\n       constexpr pair(const pair&amp;) = default;\n                 ^\n</code></pre>\n<p>If I'm reading the error correctly, this sounds like a problem with the standard library, although my money is still that it's my fault somehow...</p>\n<p>If it matters, here is main.cpp (<code>trie.h</code> is a class I'm working on):</p>\n<pre><code>#include &lt;string&gt;\n#include \"trie.h\"\n\nint main()\n{\n    trie&lt;std::string&gt; t;\n    t.insert(\"te\");\n    trie&lt;std::string&gt; u(std::move(t));\n\n    for(auto i: u)\n        ;\n}\n</code></pre>\n<hr>\n<p>EDIT:  And here is the relevant trie code.  <code>trie.h</code>:</p>\n<pre><code>template&lt;typename T&gt;\nclass trie {\npublic:\n    // misc. declarations\n    class iterator;\n    typedef T key_type;\n    typedef T value_type;\n    typedef size_t size_type;\n    typedef iterator const_iterator;\n\n    // constructors\n    trie(trie&lt;T&gt;* const = nullptr, bool = false);\n    trie(const trie&lt;T&gt;&amp;, trie&lt;T&gt;* const = nullptr);\n    trie(trie&lt;T&gt;&amp;&amp;);\n    template&lt;typename InputIt&gt; trie(InputIt, InputIt, trie&lt;T&gt;* const = nullptr);\n\n    // destructor, auto-generated one is fine\n    ~trie() =default;\n\n    // ...\n\n    // other members\n    std::pair&lt;iterator,bool&gt; insert(const value_type&amp;);\n\n    // ...\n\nprivate:\n    std::map&lt;typename T::value_type, std::unique_ptr&lt;trie&lt;T&gt;&gt;&gt; children;\n    trie&lt;T&gt;* parent;\n    bool is_leaf = false;\n};\n\n#include \"trie_iterator.h\"\n\n// ...\n\ntemplate&lt;typename T&gt;\nstd::pair&lt;typename trie&lt;T&gt;::iterator,bool&gt; trie&lt;T&gt;::insert(const value_type&amp; value)\n{\n  bool inserted = false;\n  bool at_leaf = false;\n  std::stack&lt;typename iterator::state&gt; parents;\n  trie&lt;T&gt;* currentNode{this};\n\n  for(const auto&amp; it = value.begin(); it != value.end(); ++it) {\n    bool is_last = (it + 1 == value.end());\n    auto childIt = currentNode-&gt;children.find(*it);\n    if(childIt == currentNode-&gt;children.end()) {\n      inserted = true;\n      if(is_last) {\n        // The sequence is new to this trie, so insert it.\n        // It is the last element, so don't create a new trie.\n        parents.emplace(\n          currentNode,\n          currentNode-&gt;children.emplace({*it, {nullptr}}).first\n        );\n      }\n      else {\n        // Create a new trie and follow it.\n        std::unique_ptr&lt;trie&lt;T&gt;&gt; p(new trie&lt;T&gt;(currentNode));\n        currentNode = currentNode-&gt;children.emplace(*it, std::move(p)).first-&gt;second;\n      }\n    }\n    else {\n      if(is_last) {\n        if(childIt-&gt;second != nullptr) {\n          inserted = true;\n          at_leaf = true;\n          childIt-&gt;second-&gt;is_leaf = true;\n        }\n        // Done.  Build a return value.\n        // TODO\n      }\n      else {\n        if(childIt-&gt;second == nullptr) {\n          childIt-&gt;second = new trie&lt;T&gt;(currentNode);\n          inserted = true;\n        }\n        currentNode = childIt-&gt;second;\n      }\n    }\n  }\n  // Build pair and return it\n  return {{std::move(parents), value, at_leaf}, inserted};\n}\n</code></pre>\n<p>I apologize for how lengthy this code is; note that <strong>the implementation of <code>insert</code> doesn't matter; the error appears no matter what</strong>, including with an empty <code>insert</code> body.</p>\n<p>And here is the <code>trie&lt;T&gt;::iterator</code> class:</p>\n<pre><code>template&lt;typename T&gt;\nclass trie&lt;T&gt;::iterator {\n    friend class trie&lt;T&gt;;\n    // TODO: Either this structure or trie::parent is not needed\n    struct state {\n        state(const trie&lt;T&gt;* const node, const typename std::map&lt;typename T::value_type, std::unique_ptr&lt;trie&lt;T&gt;&gt;&gt;::const_iterator&amp; node_map_it ) :\n            node{node}, node_map_it{node_map_it} {}\n        bool operator==(const state&amp; other) const {\n            return node == other.node &amp;&amp; node_map_it == other.node_map_it;\n        }\n        const trie&lt;T&gt;* node;\n        typename std::map&lt;typename T::value_type, std::unique_ptr&lt;trie&lt;T&gt;&gt;&gt;::const_iterator node_map_it;\n    };\n    enum class fall_to {left, right};\npublic:\n    iterator() =default;\n    iterator(trie&lt;T&gt;* node) {\n        parents.emplace(node, node-&gt;children.cbegin());\n        at_end = (parents.top().node_map_it == parents.top().node-&gt;children.cend());\n        at_leaf = parents.top().node-&gt;is_leaf;\n        fall_down();\n    }\n    ~iterator() =default;\n    iterator(typename trie&lt;T&gt;::iterator&amp; other) =default;\n    iterator(typename trie&lt;T&gt;::iterator&amp;&amp; other) :\n        parents{std::move(other.parents)},\n        built{std::move(other.built)}\n    {}\n    iterator&amp; operator=(typename trie&lt;T&gt;::iterator other) {\n        swap(*this, other);\n        return *this;\n    }\n\n    void swap(typename trie&lt;T&gt;::iterator&amp; other) {\n        std::swap(parents, other.parents);\n        std::swap(built, other.built);\n    }\n    static void swap(typename trie&lt;T&gt;::iterator&amp; a, typename trie&lt;T&gt;::iterator&amp; b) { a.swap(b); }\n\n    const T&amp; operator*() const { return built; }\n    const T* operator-&gt;() const { return &amp;built; }\n\n    void operator++() {\n        if(at_leaf)\n            at_leaf = false;\n        else\n            while(++parents.top().node_map_it == parents.top().node-&gt;children.cend())\n                walk_up();\n        fall_down();\n    }\n    void operator--() {\n        if(at_leaf)\n            walk_up();\n        while(parents.top().node_map_it-- == parents.top().node-&gt;children.cbegin()) {\n            at_leaf = parents.top().node-&gt;is_leaf;\n            if(at_leaf)\n                // No need to fall down.\n                return;\n            walk_up();\n        }\n        fall_down(fall_to::right);\n    }\n\n    bool operator==(const typename trie&lt;T&gt;::iterator&amp; other) const {\n        return parents.top() == other.parents.top() &amp;&amp; at_end == other.at_end;\n    }\n    bool operator!=(const typename trie&lt;T&gt;::iterator&amp; other) const { return !operator==(other); }\nprivate:\n    iterator(const std::stack&lt;state&gt;&amp; parents, const T&amp; built, bool at_end) :\n        parents{parents}, built{built}, at_end{at_end} {}\n    void inline fall_down(const enum fall_to fall = fall_to::left) {\n        // TODO: This function could possibly be made smaller.\n        trie&lt;T&gt;* child;\n        if(at_leaf)\n            return;\n        while((child = parents.top().node_map_it-&gt;second.get()) != nullptr) {\n            built.push_back(parents.top().node_map_it-&gt;first);\n            if(fall == fall_to::left) {\n                parents.emplace(child, child-&gt;children.cbegin());\n                at_leaf = child-&gt;is_leaf;\n                if(at_leaf)\n                    return;\n            }\n            else // fall_to::right\n                parents.emplace(child, --child-&gt;children.cend());\n        }\n        // One final push_back to put the final element (the one that has no\n        // children) in built.\n        built.push_back(parents.top().node_map_it-&gt;first);\n    }\n    void inline walk_up() {\n        built.pop_back();\n        parents.pop();\n    }\n\n    std::stack&lt;state&gt; parents;\n    // TODO: we could switch the use of push_back and pop_back for insert and erase\n    // using an end iterator, to gain some additional compatibility.\n    T built;\n    bool at_end;\n    bool at_leaf;\n};\n</code></pre>\n</hr>", "Tags": "<c++><c++11><stl>", "OwnerUserId": "1830736", "AnswerCount": "2"}, "bq_ids": {"n4140": {"so_19411865_19413260_2": {"section_id": 457, "quality": 0.625, "length": 10}}, "n3337": {"so_19411865_19413260_2": {"section_id": 448, "quality": 0.625, "length": 10}}, "n4659": {"so_19411865_19413260_2": {"section_id": 480, "quality": 0.625, "length": 10}}}});