post_cb({"13360640": {"CommentCount": "0", "ViewCount": "418", "PostTypeId": "1", "LastEditorUserId": "1139697", "CreationDate": "2012-11-13T12:19:11.973", "LastActivityDate": "2012-11-13T13:03:56.660", "Title": "Negation operator and comparison", "AcceptedAnswerId": "13360673", "LastEditDate": "2012-11-13T12:20:45.260", "Id": "13360640", "Score": "3", "Body": "<p>Lets take some code samples:</p>\n<pre><code>! 4 &gt; 0;\n</code></pre>\n<p>From C++ standard we know, that negation will be done first, than comparison. But if we expand this example a little:</p>\n<pre><code>#include &lt;iostream&gt;\n\nclass Test\n{\npublic:\n    bool operator!() const\n    {\n            std::cout &lt;&lt; \"operator!\" &lt;&lt; std::endl;\n            return false;\n    }\n\n    bool operator&gt;(const int &amp;) const\n    {\n            std::cout &lt;&lt; \"operator&gt;\" &lt;&lt; std::endl;\n            return false;\n    }\n};\n\n\nint main(int argc, char * argv[])\n{\n    Test t;\n    std::cout &lt;&lt; \"t &gt; 0;\" &lt;&lt; std::endl;\n    t &gt; 0;\n    std::cout &lt;&lt; \"! t &gt; 0;\" &lt;&lt; std::endl;\n    ! t &gt; 0;\n    std::cout &lt;&lt; \"!t.operator&gt;(0)\" &lt;&lt; std::endl;\n    ! t.operator&gt;(0);\n\n    return 0;\n}\n</code></pre>\n<p>Output of this program will be:</p>\n<pre><code>t &gt; 0;\noperator&gt;\n! t &gt; 0;\noperator!\n!t.operator&gt;(0)\noperator&gt;\n</code></pre>\n<ol>\n<li>First call (control call) is quite clear. We check if operator we want is called.</li>\n<li>Second call is proof of what I stated first. negation operator is called first, than on result (bool) operator&gt; is called.</li>\n<li>Third call is what bothers me.</li>\n</ol>\n<p>And here pops my question. Why <code>SomeObjInstance &gt; 0</code> call is different from <code>SomeObjInstance.operator&gt;(0)</code>. I know that it's not common to call operators in second manner (as members), but why this calls differs? I always tought that <code>SomeObjInstance &gt; 0</code> is translated under the hood to member call <code>SomeObjInstance.operator&gt;(0)</code> or function call <code>bool operator&gt;(const Test &amp;, int)</code> if member operator is not present. </p>\n<p>Where this behaviour is described in C++ standard, or maybe is this some kind of undefined behaviour?</p>\n", "Tags": "<c++><comparison><negation>", "OwnerUserId": "223880", "AnswerCount": "3"}, "13360673": {"ParentId": "13360640", "PostTypeId": "2", "CommentCount": "3", "CreationDate": "2012-11-13T12:21:51.513", "Score": "6", "LastEditorUserId": "1139697", "LastEditDate": "2012-11-13T12:48:28.907", "Id": "13360673", "OwnerUserId": "1139697", "Body": "<p>The member access operator <code>.*</code> has a higher precedence than the negation operator <code>!</code>.</p>\n<blockquote>\n<p id=\"so_13360640_13360673_0\">Where this behaviour is described in C++ standard, or maybe is this some kind of undefined behaviour?</p>\n</blockquote>\n<p>This is most likely the relevant paragraph:</p>\n<blockquote>\n<h3>13.5 Overloaded operators [over.oper]</h3>\n<p id=\"so_13360640_13360673_1\">5) Operator functions are usually not called directly; instead they are invoked to evaluate the operators they implement (13.5.1 \u2013 13.5.7). They can be explicitly called, however, using the operator-function-id as the name of the function in the function call syntax (5.2.2).</p>\n</blockquote>\n<p>In your first example <code>t &gt; 0;</code> it will use the according operator with the precedence for the relational comparison operators. However, in your second version <code>t.operator&gt;(0)</code> you use it as a function call. Thereby the <code>Test::operator&gt;</code> is used as a member function, which will result in your described behavior, as it looses its operator characteristics (<em>\"they can be explicitly called, however, using the operator-function-id as the name of the function in the function call syntax\"</em>).</p>\n<p>See also:</p>\n<ul>\n<li><a href=\"http://en.cppreference.com/w/cpp/language/operator_precedence\" rel=\"nofollow noreferrer\">C++ Operator Precedence</a></li>\n</ul>\n", "LastActivityDate": "2012-11-13T12:48:28.907"}, "13360980": {"ParentId": "13360640", "PostTypeId": "2", "CommentCount": "0", "CreationDate": "2012-11-13T12:42:35.667", "Score": "2", "LastEditorUserId": "219335", "LastEditDate": "2012-11-13T13:03:56.660", "Id": "13360980", "OwnerUserId": "219335", "Body": "<p>Just wear your compiler hat for a moment. You need to parse and evaluate an expression according to a clear set of rules (including operator precedence). The fact that the evaluation involves calling a member function ( <code>operator&gt;()</code> ) that also would have been called if the expression used an operator <code>&gt;</code> - so what? Do you want to make a special case and assume that in this case the default precedence should be changed? And how far are you prepared to go with it? E.g. if this method is called indirectly, or by a function pointer? I think it would complicate compiler's logic and still allow counter-intuitive examples, similar to your original question.</p>\n", "LastActivityDate": "2012-11-13T13:03:56.660"}, "bq_ids": {"n4140": {"so_13360640_13360673_1": {"section_id": 651, "quality": 0.8888888888888888, "length": 24}}, "n3337": {"so_13360640_13360673_1": {"section_id": 641, "quality": 0.8888888888888888, "length": 24}}, "n4659": {"so_13360640_13360673_1": {"section_id": 679, "quality": 0.8888888888888888, "length": 24}}}, "13360699": {"ParentId": "13360640", "CommentCount": "0", "CreationDate": "2012-11-13T12:23:22.430", "OwnerUserId": "1782465", "PostTypeId": "2", "Id": "13360699", "Score": "1", "Body": "<p><code>.</code> and <code>()</code> have higher priority than <code>!</code>. The operator syntax is parsed as</p>\n<pre><code>(!t) &gt; 0;\n</code></pre>\n<p>while the explicit invocation is parsed as </p>\n<pre><code>!((t.operator&gt;)())\n</code></pre>\n", "LastActivityDate": "2012-11-13T12:23:22.430"}});