post_cb({"7518875": {"PostTypeId": "2", "Body": "<p>Historically, the string data has not been const because it would prevent several common optimizations, like copy-on-write (COW). This is now, IIANM, far less common, because it behaves badly with multithreaded programs.</p>\n<p>BTW, yes they are now required to be contiguous:</p>\n<blockquote>\n<p id=\"so_7518732_7518875_0\">[string.require].5: The char-like objects in a basic_string object shall be stored contiguously. That is, for any basic_string\n  object s, the identity &amp;*(s.begin() + n) == &amp;*s.begin() + n shall hold for all values of n such that 0 &lt;= n &lt; s.size().</p>\n</blockquote>\n<p>Another reason might be to avoid code such as:</p>\n<pre><code>std::string ret;\nstrcpy(ret.data(), \"whatthe...\");\n</code></pre>\n<p>Or any other function that returns a preallocated char array.</p>\n", "LastActivityDate": "2011-09-22T18:29:23.313", "LastEditorUserId": "865874", "Id": "7518875", "CommentCount": "8", "CreationDate": "2011-09-22T17:21:41.330", "ParentId": "7518732", "Score": "2", "OwnerUserId": "865874", "LastEditDate": "2011-09-22T18:29:23.313"}, "7518732": {"ViewCount": "4216", "Body": "<p>Vector's new method <code>data()</code> provides a const and non-const version.<br>\nHowever string's <code>data()</code> method only provides a const version.</br></p>\n<p>I think they changed the wording about <code>std::string</code> so that the chars are now required to be contiguous (like <code>std::vector</code>).</p>\n<p>Was <code>std::string::data</code> just missed? Or is the a good reason to only allow const access to a string's underlying characters?</p>\n<p>note: <code>std::vector::data</code> has another nice feature, it's not undefined behavior to call <code>data()</code> on an empty vector.  Whereas <code>&amp;vec.front()</code> is undefined behavior if it's empty.</p>\n", "AcceptedAnswerId": "7519345", "Title": "Why are std::vector::data and std::string::data different?", "CreationDate": "2011-09-22T17:10:13.770", "Id": "7518732", "CommentCount": "12", "FavoriteCount": "4", "PostTypeId": "1", "LastEditDate": "2011-09-22T17:38:58.730", "LastEditorUserId": "28817", "LastActivityDate": "2016-04-22T19:54:16.697", "Score": "30", "OwnerUserId": "28817", "Tags": "<c++><standards><c++11>", "AnswerCount": "4"}, "7519345": {"PostTypeId": "2", "Body": "<p>In C++98/03 there was good reason to not have a non-const <code>data()</code> due to the fact that string was often implemented as COW.  A non-const <code>data()</code> would have required a copy to be made if the refcount was greater than 1.  While possible, this was not seen as desirable in C++98/03.</p>\n<p>In Oct. 2005 the committee voted in <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#464\" rel=\"nofollow noreferrer\">LWG 464</a> which added the const and non-const <code>data()</code> to <code>vector</code>, and added const and non-const <code>at()</code> to <code>map</code>.  At that time, <code>string</code> had not been changed so as to outlaw COW.  But later, by C++11, a COW <code>string</code> is no longer conforming.  The <code>string</code> spec was also tightened up in C++11 such that it is required to be contiguous, and there's always a terminating null exposed by <code>operator[](size())</code>.  In C++03, the terminating null was only guaranteed by the const overload of <code>operator[]</code>.</p>\n<p>So in short a non-const <code>data()</code> looks a lot more reasonable for a C++11 <code>string</code>.  To the best of my knowledge, it was never proposed.</p>\n<p><strong>Update</strong></p>\n<pre><code>charT* data() noexcept;\n</code></pre>\n<p>was added <code>basic_string</code> in the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/n4582.pdf\" rel=\"nofollow noreferrer\">C++1z working draft N4582</a> by <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0272r1.html\" rel=\"nofollow noreferrer\">David Sankel's P0272R1</a> at the Jacksonville meeting in Feb. 2016.</p>\n<p>Nice job David!</p>\n", "LastActivityDate": "2016-04-22T19:54:16.697", "LastEditorUserId": "576911", "Id": "7519345", "CommentCount": "8", "CreationDate": "2011-09-22T18:03:19.790", "ParentId": "7518732", "Score": "29", "OwnerUserId": "576911", "LastEditDate": "2016-04-22T19:54:16.697"}, "bq_ids": {"n4140": {"so_7518732_7518875_0": {"length": 14, "quality": 0.7368421052631579, "section_id": 1566}}, "n3337": {"so_7518732_7518875_0": {"length": 14, "quality": 0.7368421052631579, "section_id": 1561}}}, "7624286": {"PostTypeId": "2", "Body": "<p>@Christian Rau</p>\n<p>From the time the original Plauger (around 1995 I think) <code>string</code> class was STL-ized by the committee (turned into a Sequence, templatified), <code>std::string</code> has always been <code>std::vector</code> plus string-related stuff (conversion from/to 0-terminated, concatenation, ...), plus some oddities, like COW that's actually \"<strong>Copy on Write and on non-<code>const</code> <code>begin()</code>/<code>end()</code>/<code>operator[]</code></strong>\".</p>\n<p>But ultimately a <code>std::string</code> is really a <code>std::vector</code> under another name, with a slightly different focus and intent. So:</p>\n<ul>\n<li>just like <code>std::vector</code>, <code>std::string</code> has either a size data member or both start and end data members;</li>\n<li>just like <code>std::vector</code>, <code>std::string</code> does not care about the value of its elements, embedded NUL or others.</li>\n</ul>\n<p><code>std::string</code> is <strong>not</strong> a C string with syntax sugar, utility functions and some encapsulation, just like  <code>std::vector&lt;T&gt;</code> is not <code>T[]</code> with syntax sugar, utility functions and some encapsulation.</p>\n", "LastActivityDate": "2013-02-27T04:21:21.400", "LastEditorUserId": "1631193", "Id": "7624286", "CommentCount": "0", "CreationDate": "2011-10-02T02:40:13.990", "ParentId": "7518732", "Score": "0", "OwnerUserId": "963864", "LastEditDate": "2013-02-27T04:21:21.400"}, "7518959": {"PostTypeId": "2", "Body": "<p>Although I'm not that well-versed in the standard, it might be due to the fact that <code>std::string</code> doesn't need to contain null-terminated data, but it can and it doesn't need to contain an explicit length field, but it can. So changing the undelying data and e.g. adding a <code>'\\0'</code> in the middle might get the strings length field out of sync with the actual char data and thus leave the object in an invalid state.</p>\n", "LastActivityDate": "2011-09-22T17:29:34.510", "Id": "7518959", "CommentCount": "3", "CreationDate": "2011-09-22T17:29:34.510", "ParentId": "7518732", "Score": "1", "OwnerUserId": "743214"}});