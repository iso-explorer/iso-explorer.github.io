post_cb({"4498340": {"Id": "4498340", "PostTypeId": "2", "Body": "<p>It is quite common in code to have a \"convention\" which you then follow, and as long as it is done consistently across your team etc. people will be able to understand it.</p>\n<p>It is far better to declare your shared pointer typedefs in a \"forward\" file. Something like this:</p>\n<pre><code>namespace boost { template&lt; typename T &gt; class shared_ptr; }\n\nnamespace MyStuff\n{\n   class Foo;\n   class Bar;\n   class Baz;\n\n   typedef boost::shared_ptr&lt;Foo&gt; FooPtr;\n   typedef boost::shared_ptr&lt;Bar&gt; BarPtr;\n   typedef boost::shared_ptr&lt;Baz&gt; BazPtr;\n\n}\n</code></pre>\n<p>You will sometimes want to use other pointers than shared_ptr but your convention would then be to use a different notation with XPtr meaning shared_ptr.</p>\n<p>Of course you might use a different notation.</p>\n<p>I think we use <code>FooWeakPtr</code> to mean <code>weak_ptr&lt;Foo&gt;</code>\n<code>FooConstPtr</code> to mean <code>shared_ptr&lt;const Foo&gt;</code></p>\n<p>for example.</p>\n<p>Should be in your coding standards document.</p>\n", "LastActivityDate": "2010-12-21T10:34:09.493", "Score": "1", "CreationDate": "2010-12-21T10:34:09.493", "ParentId": "4497504", "CommentCount": "0", "OwnerUserId": "442284"}, "4501880": {"Id": "4501880", "PostTypeId": "2", "Body": "<p>I prefer this kind of approach to it:</p>\n<pre><code>   namespace Internal\n   {\n      template &lt;class T&gt;\n      struct DeclareShared\n      {\n         typedef std::shared_ptr&lt;T&gt; type;\n      };\n\n      template &lt;class T&gt;\n      struct DeclareUnique\n      {\n         typedef std::unique_ptr&lt;T&gt; type;\n      };\n   }\n\n   // Inherit one of these classes to use a generic smart pointer interface.\n\n   // If class is abstract, use this interface.\n   template &lt;class T&gt;\n   struct SharedAbstract\n   {\n      typedef typename Internal::DeclareShared&lt;T&gt;::type APtr;\n   };\n\n   template &lt;class T&gt;\n   struct Shared\n   {\n      typedef typename Internal::DeclareShared&lt;T&gt;::type Ptr;\n\n      template &lt;class... P&gt;\n      static Ptr shared(P&amp;&amp;... args) \n      { \n         return std::make_shared&lt;T&gt;(std::forward&lt;P&gt;(args)...); \n      }\n   };\n\n   template &lt;class T&gt;\n   struct UniqueAbstract\n   {\n      typedef typename Internal::DeclareUnique&lt;T&gt;::type AUPtr;\n   };\n\n   template &lt;class T&gt;\n   struct Unique\n   {\n      typedef typename Internal::DeclareUnique&lt;T&gt;::type UPtr;\n\n      template &lt;class... P&gt;\n      static UPtr shared(P&amp;&amp;... args) \n      { \n         return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;P&gt;(args)...)); \n      }\n   };\n</code></pre>\n<p>Added more interfaces for scoped ptr, etc and whatever you'd want you could do things like:</p>\n<pre><code>struct Foo : public Shared&lt;Foo&gt;, public Unique&lt;Foo&gt;\n{};\n\nFoo::Ptr foo = Foo::shared();\nFoo::UPtr unique = Foo::unique();\n</code></pre>\n<p>I'm not sure how VS10 copes with variadic templates, but this works fine on GCC4.5+ at least.</p>\n", "LastActivityDate": "2010-12-21T17:04:02.107", "Score": "0", "CreationDate": "2010-12-21T17:04:02.107", "ParentId": "4497504", "CommentCount": "0", "OwnerUserId": "257903"}, "4497540": {"Id": "4497540", "PostTypeId": "2", "Body": "<p>Regarding the <code>typedef</code>, you should take a look on <a href=\"https://stackoverflow.com/questions/4429417/whats-the-best-strategy-for-typedefing-shared-pointers\">this question</a> which addresses the exact same issue.</p>\n<p>For the second part, I believe you are mistaken as <code>std::shared_ptr</code> can be used for incomplete types, as specified in 20.9.10.2/2 of N3225 :</p>\n<blockquote>\n<p id=\"so_4497504_4497540_0\">The template parameter <code>T</code> of <code>shared_ptr</code>\n  may be an incomplete type.</p>\n</blockquote>\n<p>If your current implementation does not support that, I think it should be considered a bug.</p>\n", "LastEditorUserId": "-1", "LastActivityDate": "2010-12-21T08:46:23.470", "Score": "1", "CreationDate": "2010-12-21T08:46:23.470", "ParentId": "4497504", "CommentCount": "3", "LastEditDate": "2017-05-23T12:25:19.770", "OwnerUserId": "451980"}, "4497504": {"ViewCount": "638", "Body": "<p>I am busy designing a new C++ application.  In this application I want to minimize potential errors with pointers, and since the application should be plain C++ (no .Net or other fancy things), I am investigating shared pointers and I am considering using shared pointers everywhere (instead of normal pointers).</p>\n<p>I worked out some tricks to make it easier to work with shared pointers, e.g.: using a typedef within the class, like this:</p>\n<pre><code>class X\n   {\n   public:\n      ...\n      typedef std::shared_ptr&lt;X&gt; Ptr;\n   };\n</code></pre>\n<p>That way you can easily write X::Ptr, which is easier to write than \"std::shared_ptr\" everywhere.</p>\n<p>I also noticed some disadvantages to shared pointers:</p>\n<ul>\n<li>Everywhere I use a shared pointer I need to include <code>&lt;memory&gt;</code></li>\n<li>I can't use forward declaration anymore if I just want to use the pointer</li>\n</ul>\n<p>Are there any other tricks to make shared pointers easier to work with?</p>\n", "AcceptedAnswerId": "4498024", "Title": "Ways to make it easier to work with shared pointers in C++", "CreationDate": "2010-12-21T08:40:51.007", "Id": "4497504", "CommentCount": "1", "LastEditDate": "2010-12-21T10:52:33.040", "PostTypeId": "1", "LastEditorUserId": "15416", "LastActivityDate": "2010-12-21T17:04:02.107", "Score": "1", "OwnerUserId": "163551", "Tags": "<c++><visual-studio-2010><c++11><shared-ptr>", "AnswerCount": "5"}, "bq_ids": {"n4140": {"so_4497504_4497540_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 4375}}, "n3337": {"so_4497504_4497540_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 4212}}, "n4659": {"so_4497504_4497540_0": {"length": 6, "quality": 0.8571428571428571, "section_id": 5638}}}, "4497545": {"Id": "4497545", "PostTypeId": "2", "Body": "<p>Don't just pick one smart pointer to use everywhere.  Not every screw is a Phillips head.</p>\n<p>Also, you can use forward declarations for any smart pointer exactly the same as raw pointers:</p>\n<pre><code>struct X;\n\n...\nstd::shared_ptr&lt;X&gt; ptr;  // legal\n\nstruct X {};\nptr = std::shared_ptr&lt;X&gt;(new X); // legal\n</code></pre>\n<p>This is the second time I've heard this misconception on SO and it's simply 100% false.</p>\n", "LastActivityDate": "2010-12-21T08:46:37.263", "Score": "3", "CreationDate": "2010-12-21T08:46:37.263", "ParentId": "4497504", "CommentCount": "0", "OwnerUserId": "301883"}, "4498024": {"Id": "4498024", "PostTypeId": "2", "Body": "<p>DON'T! </p>\n<p>The only way to minimize pointer errors is to use <em>the right</em> pointer types. And that's <em>types</em>, plural.</p>\n<p>Shared pointers are not a silver bullet. They become memory leaks as soon when you have cyclical references (and if plan to use them <em>everywhere</em>, those will show up pretty quickly)</p>\n<p>If you want error-free C++ applications, you have to work for it. You have to understand your application. You have to understand the ownership semantics of different objects. Shared pointers just give you shared ownership, which is generally a decent lowest denominator. Everything else can be replaced by shared ownership and it'll work, sort of.</p>\n<p>But the default case is that an object is owned by <em>one</em> other entity. It is owned by a function, and should be destroyed when that function returns, or it is owned by a class, or whatever else. Often, you don't need pointers at all. the object is stored by value in a <code>std::vector</code>, perhaps. Or it is just a local variable or a class member. If it <em>is</em> a pointer, it'll often be better expressed by a <code>scoped_ptr</code> or perhaps one which allows transfer of ownership (<code>unique_ptr</code> or <code>auto_ptr</code>).</p>\n<p><code>shared_ptr</code> is what you might fall back to when you can give no guarantees about the lifetime or ownership of an object. But when you use that, you also need to use <code>weak_ptr</code> to break cycles.</p>\n<p>Really, a better approach is to <em>avoid</em> pointers as much as at all possible. When you <em>do</em> need a pointer, use one which has the most specific ownership semantics possible (prefer <code>scoped_ptr</code>, which doesn't allow transfer of ownership at all, then if you need it, fall back to one which allows you to <em>move</em> ownership, such as <code>unique_ptr</code>, and only as a last resort should you use <code>shared_ptr</code>, which allows you to share ownership freely among any number of clients.</p>\n<p>There's no magic wand you can wave to make your C++ code \"just work\". The only way to achieve that is to write good solid C++ code. And you do that by knowing, and using, the tools at your disposal, not by pretending that \"hey, <code>shared_ptr</code> is just like a garbage collector, isn't it? I can just ignore all questions of object lifetime or memory leaks if I use it\".</p>\n", "LastActivityDate": "2010-12-21T09:59:18.140", "Score": "7", "CreationDate": "2010-12-21T09:59:18.140", "ParentId": "4497504", "CommentCount": "6", "OwnerUserId": "33213"}});