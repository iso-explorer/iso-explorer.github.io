post_cb({"18040435": {"ParentId": "18040393", "CommentCount": "3", "Body": "<p>You have to use wide characters:</p>\n<p>try with:</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    wchar_t a = L'\\u1234';\n    wcout &lt;&lt; a &lt;&lt; endl;\n}\n</code></pre>\n", "OwnerUserId": "2368240", "PostTypeId": "2", "Id": "18040435", "Score": "3", "CreationDate": "2013-08-04T06:48:00.683", "LastActivityDate": "2013-08-04T06:48:00.683"}, "18040393": {"CommentCount": "0", "ViewCount": "1725", "CreationDate": "2013-08-04T06:41:44.560", "LastActivityDate": "2015-09-06T14:27:26.507", "Title": "Printing unicode characters c++ linux", "AcceptedAnswerId": "18040428", "PostTypeId": "1", "Id": "18040393", "Score": "0", "Body": "<p>I am using a raspberry pi and trying to print unicode characters with something like this:</p>\n<p>test.cpp:</p>\n<pre><code>#include&lt;iostream&gt;\nusing namespace std;\nint main() {\n    char a=L'\\u1234';\n    cout &lt;&lt; a &lt;&lt; endl;\n    return 0;\n}\n</code></pre>\n<p>When I compile with g++, I get this warning:</p>\n<pre><code>test.cpp: In function \"int main()\":\ntest.cpp:4:9: warning: large integer implicitly truncated to unsigned type [-Woverflow]\n</code></pre>\n<p>And the output is:</p>\n<pre><code>4\n</code></pre>\n<p>Also, this is not in the GUI and my distribution is raspbian wheezy if that is relevant.</p>\n", "Tags": "<c++><linux><unicode><raspberry-pi>", "OwnerUserId": "2649898", "AnswerCount": "3"}, "18040428": {"ParentId": "18040393", "PostTypeId": "2", "CommentCount": "3", "Body": "<p>You must set the local before you can use it, unless your native system is using it. </p>\n<pre><code> setlocale(LC_CTYPE,\"\");\n</code></pre>\n<p>To print the stirng use <code>wcout</code> instead of <code>cout</code>.</p>\n<pre><code>#include&lt;iostream&gt;\n#include &lt;locale&gt;\n\nint main()\n{\n    setlocale(LC_CTYPE,\"\");\n    wchar_t a=L'\\u1234';\n    std::wcout &lt;&lt; a &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>\n", "OwnerUserId": "2282011", "LastEditorUserId": "2282011", "LastEditDate": "2013-08-04T07:28:53.390", "Id": "18040428", "Score": "1", "CreationDate": "2013-08-04T06:47:19.760", "LastActivityDate": "2013-08-04T07:28:53.390"}, "bq_ids": {"n4140": {"so_18040393_32413257_1": {"section_id": 6076, "quality": 0.7391304347826086, "length": 17}, "so_18040393_32413257_3": {"section_id": 5313, "quality": 0.9411764705882353, "length": 16}}, "n3337": {"so_18040393_32413257_1": {"section_id": 5844, "quality": 0.7391304347826086, "length": 17}, "so_18040393_32413257_3": {"section_id": 5110, "quality": 0.9411764705882353, "length": 16}}, "n4659": {"so_18040393_32413257_1": {"section_id": 7572, "quality": 0.7391304347826086, "length": 17}, "so_18040393_32413257_3": {"section_id": 6737, "quality": 0.9411764705882353, "length": 16}}}, "32413257": {"ParentId": "18040393", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>As a reference to one of the previous answers, you should not use wchar_t and w* functions on Linux. POSIX APIs use <code>char</code> data type and most POSIX implementations use UTF-8 as a default encoding. Quoting the C++ standard (ISO/IEC 14882:2011) </p>\n<blockquote>\n<p id=\"so_18040393_32413257_0\">5.3.3 Sizeof</p>\n<p id=\"so_18040393_32413257_1\"><strong>sizeof(char), sizeof(signed char) and sizeof(unsigned char)</strong> are <strong>1</strong>.\n  The result of sizeof applied to any other fundamental type (3.9.1) is\n  implementation-defined. [ Note: in particular, sizeof(bool),\n  sizeof(char16_t), sizeof(char32_t), and <strong>sizeof(wchar_t)</strong> are\n  <strong>implementation-defined</strong>. 74 \u2014 end note ]</p>\n</blockquote>\n<p>UTF-8 uses 1-byte code units and up to 4 code units to represent a code point, so <code>char</code> is enough to store UTF-8 strings, though to manipulate them you are going to need to find out if a specific code unit is represented by multiple bytes and build your processing logic with that in mind. <code>wchar_t</code> has an implementation-defined size and the Linux distributions that I have seen have a size of 4 bytes for this data type.</p>\n<p>There is another problem that the mapping from the source code to the object code may transform your encoding in a compiler-specific way:</p>\n<blockquote>\n<p id=\"so_18040393_32413257_2\">2.2 Phases of translation</p>\n<p id=\"so_18040393_32413257_3\">Physical <strong>source file characters</strong> are <strong>mapped</strong>, in an\n  <strong>implementation-defined manner</strong>, to the basic source character set\n  (introducing new-line characters for end-of-line indicators) if\n  necessary.</p>\n</blockquote>\n<p>Anyway, in the most cases you don't have any conversions on your source code so the strings that you put into <code>char*</code> stay unmodified. If you encode your source code with UTF-8 then you are going to have bytes representing UTF-8 code units in your <code>char*</code>s.</p>\n<p>As for your code example: it does not work as expected because 1 <code>char</code> has a size of 1 byte. Unicode <em>code points</em> may require several (up to 4) UTF-8 <em>code units</em> to be serialized (for UTF-8 <code>1 code unit == 1 byte</code>). You can see <a href=\"http://unicode-table.com/en/1234/\" rel=\"nofollow\">here</a> that <code>U+1234</code> requires three bytes <code>E1 88 B4</code> when UTF-8 is used and, therefore, cannot be stored in a single char. If you modify your code as follows it's going to work just fine:</p>\n<pre><code>#include &lt;iostream&gt;\nint main() {\n    char* str = \"\\u1234\";\n    std::cout &lt;&lt; str &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>This is going to output <code>\u1234</code> though you may see nothing depending on your console and the installed fonts, the actual bytes are going to be there. Note that with double quotes you also have a <code>\\0</code> terminator in-memory.</p>\n<p>You could also use an array, but not with single quotes since you would need a different data type (see <a href=\"http://en.cppreference.com/w/cpp/language/character_literal\" rel=\"nofollow\">here</a> for more information):</p>\n<pre><code>#include &lt;iostream&gt;\nint main() {\n    char* str = \"\\u1234\";\n    std::cout &lt;&lt; str &lt;&lt; std::endl;\n\n    // size of the array is 4 because \\0 is appended\n    // for string literals and there are 3 bytes\n    // needed to represent the code point\n    char arr[4] = \"\\u1234\";\n    std::cout.write(arr, 3);\n    std::cout &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>\n<p>The output is going to be <code>\u1234</code> on the two different lines in this case.</p>\n", "OwnerUserId": "1038266", "LastEditorUserId": "1038266", "LastEditDate": "2015-09-06T14:27:26.507", "Id": "32413257", "Score": "4", "CreationDate": "2015-09-05T12:51:51.557", "LastActivityDate": "2015-09-06T14:27:26.507"}});