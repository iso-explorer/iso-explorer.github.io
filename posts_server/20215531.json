post_cb({"bq_ids": {"n4140": {"so_20215531_20218433_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 7070}}, "n3337": {"so_20215531_20218433_0": {"length": 7, "quality": 0.7777777777777778, "section_id": 6814}}}, "20215531": {"ViewCount": "98", "Body": "<p>I noticed that the manual designation typedef on OuterClass too costly and sometimes leads to embarrassing errors.\nSo I decided to make a copy-paste friendly typedef on OuterClass.\nHere's what I got:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nstruct A{\n  typedef A NextOuterClass;\n  typedef A SelfClass;\n  struct B{\n    typedef NextOuterClass OuterClass;\n    typedef B NextOuterClass;\n    typedef B SelfClass;\n    struct C{\n      typedef NextOuterClass OuterClass;\n      typedef C NextOuterClass;\n      typedef C SelfClass;\n    };\n  };\n};\n\n#define CHECK(OWNER,TYPE)\\\n  static_assert(\\\n  std::is_same&lt;OWNER::TYPE::OuterClass,OWNER&gt;::value,\\\n  #OWNER\"::\"#TYPE\" - not ok\"\\\n);\nCHECK(A,B);\nCHECK(A::B,C);\n#undef CHECK\n\nint main(){return 0;}\n</code></pre>\n<p>It works quite well, but not always:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nstruct I{\n  typedef I NextOuterClass;\n  typedef I SelfClass;\n};\n\nstruct D{\n  typedef D NextOuterClass;\n  typedef D SelfClass;\n  struct E:public I{\n    typedef NextOuterClass OuterClass; // NextOuterClass == I::NextOuterClass\n    typedef E NextOuterClass;\n    typedef E SelfClass;\n    typedef I ParentClass;\n  };\n};\n\n#define CHECK(OWNER,TYPE)\\\n  static_assert(\\\n  std::is_same&lt;OWNER::TYPE::OuterClass,OWNER&gt;::value,\\\n  #OWNER\"::\"#TYPE\" - not ok\"\\\n);\nCHECK(D,E); // D::E - not ok\n#undef CHECK\n\nint main(){return 0;}\n</code></pre>\n<p>If I remove the \"typedef I NextOuterClass;\", then it will work, but it is a bad decision because the class \"I\" may also have sub-classes:</p>\n<pre><code>#include &lt;type_traits&gt;\n\nstruct I{\n  typedef I NextOuterClass;\n  typedef I SelfClass;\n  struct G{\n    typedef NextOuterClass OuterClass;\n    typedef G NextOuterClass;\n    typedef G SelfClass;\n  };\n};\n\nstruct D{\n  typedef D NextOuterClass;\n  typedef D SelfClass;\n  struct E:public I{\n    typedef NextOuterClass OuterClass; // NextOuterClass == I::NextOuterClass\n    typedef E NextOuterClass;\n    typedef E SelfClass;\n    typedef I ParentClass;\n  };\n};\n\n#define CHECK(OWNER,TYPE)\\\n  static_assert(\\\n  std::is_same&lt;OWNER::TYPE::OuterClass,OWNER&gt;::value,\\\n  #OWNER\"::\"#TYPE\" - not ok\"\\\n);\nCHECK(I,G);\nCHECK(D,E); // D::E - not ok\n#undef CHECK\n\nint main(){return 0;}\n</code></pre>\n<p>I have tried to exploit the features of \"private\" and \"template\", but still has not reached the desired behavior.</p>\n<p>In C++11 or C++14 have any reliable way to find OuterClass?</p>\n<p>It would be nice to have such things here:</p>\n<pre><code>std::get_outer_class&lt;T&gt;::type\nstd::is_nested_class&lt;T&gt;::value\n</code></pre>\n", "Title": "How to make copy-paste friendly typedef for OuterClass in C++11?", "CreationDate": "2013-11-26T11:13:59.150", "LastActivityDate": "2013-11-27T11:21:12.583", "CommentCount": "0", "LastEditDate": "2013-11-27T11:21:12.583", "PostTypeId": "1", "LastEditorUserId": "636019", "Id": "20215531", "Score": "0", "OwnerUserId": "1555759", "Tags": "<c++><c++11><code-generation><rtti><visual-c++-2010>", "AnswerCount": "1"}, "20218433": {"PostTypeId": "2", "Body": "<p>Your example is ill-formed:</p>\n<blockquote>\n<p id=\"so_20215531_20218433_0\"><strong>3.3.7/1</strong> The following rules describe the scope of names declared in classes.</p>\n<ol>\n<li>The potential scope of a name declared in a class consists not only of the declarative region following\n  the name\u2019s point of declaration, but also of all function bodies, brace-or-equal-initializers of non-static\n  data members, and default arguments in that class (including such things in nested classes).</li>\n<li>A name <code>N</code> used in a class <code>S</code> shall refer to the same declaration in its context and when re-evaluated in\n  the completed scope of S. No diagnostic is required for a violation of this rule.</li>\n<li>If reordering member declarations in a class yields an alternate valid program under (1) and (2), the\n  program is ill-formed, no diagnostic is required.</li>\n</ol>\n</blockquote>\n<p>Your approach relies on the name <code>NextOuterClass</code> referring to different things at different points in the nested class definition. Which is precisely what (2) prohibits.</p>\n", "LastActivityDate": "2013-11-26T13:30:20.583", "Id": "20218433", "CommentCount": "1", "CreationDate": "2013-11-26T13:30:20.583", "ParentId": "20215531", "Score": "1", "OwnerUserId": "1670129"}});