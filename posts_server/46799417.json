post_cb({"46799684": {"ParentId": "46799417", "PostTypeId": "2", "CommentCount": "2", "Body": "<p>It sounds like you have the following:</p>\n<pre><code>template &lt;&gt;\nCat&lt;int&gt;::~Cat()\n{\n    std::cout &lt;&lt; \"int\" &lt;&lt; std::endl;\n}\n</code></pre>\n<p>in a header file that is included in two translation units. An explicit specialization of a function template is a non-inline function (C++14 [temp.expl.spec]/12); so this is an ODR violation. </p>\n<p>It's the same error you'd get if you implemented a non-template member function (or a free function) in the same place: both translation units end up with a copy of the function, which is not allowed even if the two copies are identical.</p>\n<p>To fix this, put the keyword <code>inline</code> before <code>template&lt;&gt;</code>.</p>\n<hr>\n<p>There was some discussion in comments about the legality of providing an explicit specialization for a member function of a class template.  I believe this is correct, with restrictions according to C++14 [temp.expl.spec]/6:</p>\n<blockquote>\n<p id=\"so_46799417_46799684_0\">If a template, a member template or a member of a class template is explicitly specialized then that specialization shall be declared before the first use of that specialization that would cause an implicit instantiation to take place, in every translation unit in which such a use occurs; no diagnostic is required. If the program does not provide a definition for an explicit specialization and either the specialization is used in a way that would cause an implicit instantiation to take place or the member is a virtual member function, the\n  program is ill-formed, no diagnostic required.</p>\n</blockquote>\n<p>Also, section 7:</p>\n<blockquote>\n<p id=\"so_46799417_46799684_1\">The placement of explicit specialization declarations for function templates, class templates, variable templates, member functions of class templates, static data members of class templates, member classes of class templates, member enumerations of class templates, member class templates of class templates, member function templates of class templates, static data member templates of class templates, member functions of member templates of class templates, member functions of member templates of non-template classes, static data member templates of non-template classes, member function templates of member classes of class templates, etc., and the placement of partial specialization declarations of class templates, variable templates, member class templates of non-template classes, static data member templates of non-template classes, member class templates of class templates, etc., can affect whether a program is well-formed according to the relative positioning of the explicit specialization declarations and their points of instantiation in the translation unit as specified above and below. When writing a specialization, <strong>be careful about its\n  location; or to make it compile will be such a trial as to kindle its self-immolation</strong>.</p>\n</blockquote>\n<p>In your program it is in the perfect location: immediately after the class definition.  The risky sitautions occur when the class might have been instantiated before a declaration at least of the specialization was encountered.</p>\n</hr>", "OwnerUserId": "1505939", "LastEditorUserId": "1505939", "LastEditDate": "2017-10-18T01:33:28.530", "Id": "46799684", "Score": "3", "CreationDate": "2017-10-17T21:42:14.270", "LastActivityDate": "2017-10-18T01:33:28.530"}, "46799417": {"CommentCount": "13", "AcceptedAnswerId": "46799520", "CreationDate": "2017-10-17T21:21:55.927", "LastActivityDate": "2017-10-18T01:33:28.530", "PostTypeId": "1", "ViewCount": "55", "FavoriteCount": "0", "Title": "\"Destructor already defined\" with a specialized destructor", "Id": "46799417", "Score": "1", "Body": "<p>I am experimenting with specialized destructors. This code is perfectly valid and compiles just fine:</p>\n<pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\ntemplate &lt;typename T&gt;\nclass Cat\n{\npublic:\n    ~Cat();\n};\n\ntemplate &lt;typename T&gt;\nCat&lt;T&gt;::~Cat()\n{\n    std::cout &lt;&lt; \"T\" &lt;&lt; std::endl;\n}\n\ntemplate &lt;&gt;\nCat&lt;int&gt;::~Cat()\n{\n    std::cout &lt;&lt; \"int\" &lt;&lt; std::endl;\n}\n\n\nint main()\n{\n    Cat&lt;int&gt; c1;\n    Cat&lt;float&gt; c2;\n    return 0;\n}\n</code></pre>\n<p>However if I put the class and the destructors in a separate file \"Cat.h\" and do <code>#include \"Cat.h\"</code> in Main.cpp, I'm getting a linker error: <code>LNK2005   \"public: __thiscall Cat&lt;int&gt;::~Cat&lt;int&gt;(void)\" (??1?$Cat@H@@QAE@XZ) already defined in Cat.obj</code>. Why?</p>\n", "Tags": "<c++><templates><template-specialization>", "OwnerUserId": "4154993", "AnswerCount": "2"}, "46799520": {"ParentId": "46799417", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Chances are your <code>Cat.cpp</code> and <code>main.cpp</code> translation units both include the same <code>Cat.h</code> header file. Put your entire template class in a header file, remove the <code>Cat.cpp</code> translation unit and compile without it.<br>\n<a href=\"https://wandbox.org/permlink/rzZQq8PsFpF2SXkb\" rel=\"nofollow noreferrer\">Live example</a><br>\nMore details in this SO post:<br>\n<a href=\"https://stackoverflow.com/questions/495021/why-can-templates-only-be-implemented-in-the-header-file\">Why can templates only be implemented in the header file?</a>.</br></br></br></p>\n", "OwnerUserId": "8202288", "LastEditorUserId": "8202288", "LastEditDate": "2017-10-17T21:56:14.360", "Id": "46799520", "Score": "1", "CreationDate": "2017-10-17T21:30:17.273", "LastActivityDate": "2017-10-17T21:56:14.360"}, "bq_ids": {"n4140": {"so_46799417_46799684_1": {"section_id": 269, "quality": 0.9921875, "length": 127}, "so_46799417_46799684_0": {"section_id": 268, "quality": 1.0, "length": 50}}, "n3337": {"so_46799417_46799684_1": {"section_id": 260, "quality": 0.8203125, "length": 105}, "so_46799417_46799684_0": {"section_id": 259, "quality": 1.0, "length": 50}}, "n4659": {"so_46799417_46799684_1": {"section_id": 276, "quality": 0.9921875, "length": 127}, "so_46799417_46799684_0": {"section_id": 275, "quality": 1.0, "length": 50}}}});