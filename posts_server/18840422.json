post_cb({"18840652": {"Id": "18840652", "PostTypeId": "2", "Body": "<p>Good question.  The answer is \"depends\".</p>\n<pre><code>if (-1) { // this is always true\n}\n</code></pre>\n<p>On the other hand, suppose you are on a 16 bit machine:</p>\n<pre><code>if (-65536) { // this is always false\n}\n</code></pre>\n<p>On the other hand, </p>\n<pre><code>int a = whatever doesn't matter;\nif (a &lt; 0) { // this might or might not be true\n    if (a) { // this will always be true if we get here\n    }\n}\n</code></pre>\n<p>So negative numbers are not always false, except sometimes they always are.</p>\n", "LastActivityDate": "2013-09-17T03:03:05.720", "Score": "-2", "CreationDate": "2013-09-17T03:03:05.720", "ParentId": "18840422", "CommentCount": "5", "OwnerUserId": "2780630"}, "18840449": {"Id": "18840449", "PostTypeId": "2", "Body": "<p>All non-zero values will be converted to <code>true</code>, and zero values to <code>false</code>. With negative numbers being non-zero, they are converted to <code>true</code>.</p>\n<p>Quoting from the C++11 standard (emphasis mine):</p>\n<blockquote>\n<p id=\"so_18840422_18840449_0\">4.12 Boolean conversions [conv.bool]</p>\n<p id=\"so_18840422_18840449_1\">1 A prvalue of arithmetic, unscoped enumeration, pointer, or pointer\n  to member type can be converted to a prvalue of type bool. <strong>A zero\n  value, null pointer value, or null member pointer value is converted\n  to <code>false</code>; any other value is converted to <code>true</code>.</strong> A prvalue of type\n  std::nullptr_t can be converted to a prvalue of type bool; the\n  resulting value is false.</p>\n</blockquote>\n<hr>\n<blockquote>\n<p id=\"so_18840422_18840449_2\">Are they always true/false regardless of compilers?</p>\n</blockquote>\n<p>You will only get the above guarantee when your compiler is standards-compliant, or at least, complies with this specific part of the standard. In practice, all compilers have this standard behavior, so there isn't much to worry about.</p>\n</hr>", "LastEditorUserId": "1619294", "LastActivityDate": "2013-09-17T02:55:29.650", "Score": "43", "CreationDate": "2013-09-17T02:39:43.430", "ParentId": "18840422", "CommentCount": "0", "LastEditDate": "2013-09-17T02:55:29.650", "OwnerUserId": "1619294"}, "bq_ids": {"n4140": {"so_18840422_18840464_1": {"length": 28, "quality": 1.0, "section_id": 44}, "so_18840422_18840449_1": {"length": 39, "quality": 1.0, "section_id": 44}, "so_18840422_18863247_1": {"length": 26, "quality": 1.0, "section_id": 44}}, "n3337": {"so_18840422_18840464_1": {"length": 28, "quality": 1.0, "section_id": 41}, "so_18840422_18840449_1": {"length": 39, "quality": 1.0, "section_id": 41}, "so_18840422_18863247_1": {"length": 26, "quality": 1.0, "section_id": 41}}, "n4659": {"so_18840422_18840464_1": {"length": 28, "quality": 1.0, "section_id": 45}, "so_18840422_18840449_1": {"length": 39, "quality": 1.0, "section_id": 45}, "so_18840422_18863247_1": {"length": 26, "quality": 1.0, "section_id": 45}}}, "18840507": {"Id": "18840507", "PostTypeId": "2", "Body": "<p>You can test it yourself by compiling this:</p>\n<pre><code>#include &lt;stdio.h&gt;\n\nint main(int argc, char** argv) {\n    if (-1) {\n        printf(\"-1 is true\\n\");\n    } else {\n        printf(\"-1 is false\\n\");\n    }\n    return 0;\n}\n</code></pre>\n<p>Results:</p>\n<blockquote>\n<p id=\"so_18840422_18840507_0\">$ gcc -Wall -pedantic test.c -o test-c<br>\n  $ g++ -Wall -pedantic test.c -o test-cpp<br>\n  $ ./test-c<br>\n  -1 is true<br>\n  $ ./test-cpp<br>\n  -1 is true</br></br></br></br></br></p>\n</blockquote>\n<p>Of course, to answer the second part of your question, \"Are they always true/false regardless of compilers?\", the only way to be completely sure is to look at the spec. In general though, compilers will warn you if you do something dangerous, and you can see from the output above, that even with \"pedantic\" <a href=\"http://gcc.gnu.org/onlinedocs/gcc-4.4.5/gcc/Warning-Options.html\" rel=\"nofollow\">warnings</a>, <code>gcc</code> considers this code to be perfectly fine.</p>\n", "LastEditorUserId": "212555", "LastActivityDate": "2013-09-18T02:54:21.327", "Score": "5", "CreationDate": "2013-09-17T02:46:45.880", "ParentId": "18840422", "CommentCount": "2", "LastEditDate": "2013-09-18T02:54:21.327", "OwnerUserId": "212555"}, "18840464": {"Id": "18840464", "PostTypeId": "2", "Body": "<p>Anything that is not <code>0</code> will be converted to <code>true</code>(<em>1 in the case of C</em>) a <code>zero</code> value will be converted to <code>false</code>(<em>0 in the case of C</em>). With respect to <em>C</em> if we look at the <a href=\"http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf\" rel=\"nofollow\">C99 draft standard</a> section <code>6.3.1.2</code> <em>Boolean type</em> paragraph <em>1</em> says:</p>\n<blockquote>\n<p id=\"so_18840422_18840464_0\">When any scalar value is converted to _Bool, the result is 0 if the value compares equal\n  to 0; otherwise, the result is 1.</p>\n</blockquote>\n<p>For completeness sake if we look at section <code>7.16</code> <em>Boolean type and values </em> paragraph <em>2</em> says:</p>\n<pre><code>The macro \n\n bool\n\nexpands to _Bool.\n</code></pre>\n<p>with respect to <em>C++</em> the <a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3485.pdf\" rel=\"nofollow\">draft C++ standard</a> in section <code>4.12</code> <em>Boolean conversions</em> paragraph <em>1</em> says(<em>emphasis mine</em>):</p>\n<blockquote>\n<p id=\"so_18840422_18840464_1\">A prvalue of arithmetic, unscoped enumeration, pointer, or pointer to member type can be converted to a prvalue of type bool. <strong>A zero value, null pointer value, or null member pointer value is converted to false; any other value is converted to true.</strong>[...]</p>\n</blockquote>\n<p>This should hold regardless of which compiler you use.</p>\n", "LastEditorUserId": "1708801", "LastActivityDate": "2013-09-17T03:16:08.047", "Score": "2", "CreationDate": "2013-09-17T02:41:37.853", "ParentId": "18840422", "CommentCount": "0", "LastEditDate": "2013-09-17T03:16:08.047", "OwnerUserId": "1708801"}, "18840422": {"ViewCount": "33719", "Body": "<p>When evaluating integers as booleans in C/C++, are negative numbers true or false?  Are they always true/false regardless of compilers?</p>\n", "AcceptedAnswerId": "18840449", "Title": "Do negative numbers return false in C/C++?", "CreationDate": "2013-09-17T02:36:54.167", "Id": "18840422", "CommentCount": "8", "FavoriteCount": "9", "PostTypeId": "1", "LastActivityDate": "2014-07-21T18:49:05.320", "Score": "33", "OwnerUserId": "2453816", "Tags": "<c++><c><boolean>", "AnswerCount": "5"}, "18863247": {"Id": "18863247", "PostTypeId": "2", "Body": "<p>Short answer: Yes, negative values, and any non-zero values in general, are treated as true when used as conditions.</p>\n<p>For C, there are a number of contexts in which an expression is treated as a condition. Conditions are not necessarily of type <code>bool</code> or <code>_Bool</code>; that type was only added to the language by the 1999 standard.</p>\n<p>The most obvious of these contexts is the expression in an <code>if</code> statement, but there are other examples: <code>while</code>, <code>do-while</code>, the second expression in a <code>for</code> header, the first operand of the <code>?:</code> conditional operator, and the operand(s) of the <code>!</code>, <code>&amp;&amp;</code>, and <code>||</code> operators. (I <em>think</em> that's an exhaustive list, but I'm not certain.)</p>\n<p>Here's what the C standard says about the behavior of the <code>if</code> statement (the \"two forms\" refer to <code>if</code> with and without an <code>else</code> clause):</p>\n<blockquote>\n<p id=\"so_18840422_18863247_0\">In both forms, the first substatement is executed if the expression compares unequal to 0.</p>\n</blockquote>\n<p>Which means that this:</p>\n<pre><code>if (foo) ...\n</code></pre>\n<p>is equivalent to this:</p>\n<pre><code>if ((foo) != 0) ...\n</code></pre>\n<p>(adding extra parentheses to avoid any operator precedence issues). The meaning is clear if <code>foo</code> is of type <code>int</code>. If <code>foo</code> is of some floating-point type, <code>0</code> is converted to the same type (which can cause some subtleties if the value happens to be a negative zero or a NaN). And if <code>foo</code> is a pointer, <code>0</code> is treated as a null pointer constant; <code>if (ptr)</code> is equivalent to <code>if (ptr != NULL)</code> (assuming the definition of <code>NULL</code> is visible).</p>\n<p>For C++, the rules are stated a bit differently, but the effect is the same. The condition in a C++ <code>if</code> statement is converted to type <code>bool</code> (unlike in C, the type <code>bool</code> has been built into C++ since its early history). The conversion of a value of any scalar type to <code>bool</code> is defined by the C++ standard as:</p>\n<blockquote>\n<p id=\"so_18840422_18863247_1\">A zero value, null pointer value, or null member pointer value is\n  converted to <strong>false</strong>; any other value is converted to true. A\n  prvalue of type <strong>std::nullptr_t</strong> can be converted to a prvalue of\n  type <strong>bool</strong>; the resulting value is <strong>false</strong>.</p>\n</blockquote>\n<p>So in both C and C++, any scalar (i.e., integer, floating-point, or pointer) value can be used as a condition, and the condition is false if the scalar is equal to zero, and true if it's not equal to zero. C defines this as an inequality comparison to <code>0</code>; C++ defines it as a conversion to the <code>bool</code> -- but the result is the same.</p>\n<p>This is getting a bit off the topic of the question, but I'll mention that it's important to note that a value that is treated as a true condition is not necessarily <em>equal</em> to <code>true</code>. <code>true</code> (which is <code>1</code> in C if you have <code>#include &lt;stdbool.h&gt;</code>, and a unique value of type <code>bool</code> in C++) is just one of many values that possess \"truthiness\" when used in a condition. Which is why you should almost never write:</p>\n<pre><code>if (cond == true) ...\n</code></pre>\n<p>in either C or C++ (unless you really need to compare it to that one value); just write:</p>\n<pre><code>if (cond) ...\n</code></pre>\n<p>A C++ example:</p>\n<pre><code>#include &lt;iostream&gt;\nint main() {\n    int n = 2;\n    if (n)         std::cout &lt;&lt; \"n has truthiness\\n\";\n    else           std::cout &lt;&lt; \"n does not have truthiness\\n\";\n    if (n == true) std::cout &lt;&lt; \"n == true\\n\";\n    else           std::cout &lt;&lt; \"n != true\\n\";\n}\n</code></pre>\n<p>The output is:</p>\n<pre><code>n has truthiness\nn != true\n</code></pre>\n", "LastActivityDate": "2013-09-18T03:13:44.087", "Score": "3", "CreationDate": "2013-09-18T03:13:44.087", "ParentId": "18840422", "CommentCount": "0", "OwnerUserId": "827263"}});