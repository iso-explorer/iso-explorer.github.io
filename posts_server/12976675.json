post_cb({"12976675": {"CreationDate": "2012-10-19T14:44:18.043", "ViewCount": "550", "Id": "12976675", "AcceptedAnswerId": "12976749", "Score": "1", "Title": "Can I move through an array by incrementing a pointer? Qt", "LastEditorUserId": "15168", "CommentCount": "6", "Body": "<p>Let's say I have an array of QStrings and a QString pointer. I want to use the pointer to iterate through the entire array; could I do this?</p>\n<pre><code>QString * strPointer;\nQString data[100];\nstrPointer = &amp; data[0]; //address to first element\n\nstrPointer ++; //address to second element\n</code></pre>\n<p>Would this be valid or am I doing something wrong?</p>\n", "Tags": "<c++><arrays><qt><pointers>", "LastEditDate": "2012-10-19T17:06:15.680", "LastActivityDate": "2012-10-19T17:06:15.680", "PostTypeId": "1", "AnswerCount": "4", "OwnerUserId": "1717634"}, "bq_ids": {"n4140": {"so_12976675_12977340_0": {"length": 106, "quality": 0.9636363636363636, "section_id": 6142}}, "n3337": {"so_12976675_12977340_0": {"length": 106, "quality": 0.9636363636363636, "section_id": 5906}}}, "12976749": {"CommentCount": "1", "Body": "<p>You're on the right lines. Here's one way</p>\n<pre><code>QString data[100];\nfor (QString* strPointer = &amp;data[0]; strPointer != &amp;data[100]; ++strPointer)\n{\n    ...\n}\n</code></pre>\n", "CreationDate": "2012-10-19T14:47:49.497", "ParentId": "12976675", "Id": "12976749", "LastActivityDate": "2012-10-19T14:47:49.497", "PostTypeId": "2", "Score": "2", "OwnerUserId": "1534269"}, "12977296": {"CommentCount": "0", "Body": "<p>Yes, this is fine so long as the type of the pointer matches what's actually being pointed to in the array.  By incrementing a pointer you are performing pointer arithmetic.</p>\n<p>It may be interesting to note that because iterators in the Standard Library are written to look &amp; feel like pointers in many ways, and all the Standard Library algorithms take iterators specified as template parameters, it is legal and well-defined to use these algorithms with raw pointers as well.  For example, this is perfectly legitimate, even with your pointers:</p>\n<pre><code>const size_t num_data = sizeof(data)/sizeof(data[0]);\nstd::copy( &amp;data[0], &amp;data[num_data], ostream_iterator&lt;QString&gt;(cout,\"\\n\") );\n</code></pre>\n<p>...assuming of course you have implemented <code>operator&lt;&lt;</code> for a <code>QString</code> object.</p>\n<p>Now, all this being said, take a look at this:</p>\n<pre><code>QString data[100];\n</code></pre>\n<p>The <code>100</code> here is what's called a <a href=\"http://en.wikipedia.org/wiki/Magic_number_%28programming%29\" rel=\"nofollow\">Magic Number</a>.  The use of Magic Numbers is widely considered to be an <a href=\"http://en.wikipedia.org/wiki/Anti-pattern\" rel=\"nofollow\">anti-pattern</a>, or a bad practice.  Ask yourself a couple questions:</p>\n<ol>\n<li>How do you know that 100 elements will be enough?</li>\n<li>If you don't need 100 elements, are you being wasteful?</li>\n<li>If you need more than 100 elements, will your program crash?</li>\n</ol>\n<p>It's best to avoid using magic numbers wherever you can.  Your choice of <code>100</code> here is arbitrary.  It would be better to use a collection type that grows and shrinks as you add and remove objects.  <code>std::vector</code> is a good place to start:</p>\n<pre><code>std::vector&lt;QString&gt; data;\n</code></pre>\n<p>Now you can add items:</p>\n<pre><code>data.push_back( ... );\n</code></pre>\n<p>...remove them, and iterate easily, using iterators:</p>\n<pre><code>std::copy( data.begin(), data.end(), ostream_iterator&lt;QString&gt;(cout,\"\\n\") );\n</code></pre>\n", "CreationDate": "2012-10-19T15:14:35.417", "ParentId": "12976675", "Id": "12977296", "LastActivityDate": "2012-10-19T15:14:35.417", "PostTypeId": "2", "Score": "1", "OwnerUserId": "241536"}, "12977340": {"CommentCount": "0", "Body": "<p>Yes, incrementing a pointer to an element of an array will produce a pointer to the next element or to a position one past the end of the array.</p>\n<blockquote>\n<p id=\"so_12976675_12977340_0\">When an expression that has integral type is added to or subtracted\n  from a pointer, the result has the type of the pointer operand. If the\n  pointer operand points to an element of an array object, and the array\n  is large enough, the result points to an element offset from the\n  original element such that the difference of the subscripts of the\n  resulting and original array elements equals the integral expression.\n  In other words, ifthe expression P points to the i-th element of an\n  array object, the expressions (P)+N (equivalently, N+(P)) and (P)-N\n  (where N has the value n) point to, respectively, the i + n-th and i \u2212\n  n-th elements of the array object, provided they exist. Moreover, if\n  the expression P points to the last element of an array object, the\n  expression (P)+1 points one past the last element of the array object,\n  and if the expression Q points one past the last element of an array\n  object, the expression (Q)-1 points to the last element of the array\n  object. If both the pointer operand and the result point to elements\n  of the same array object, or one past the last element of the array\n  object, the evaluation shall not produce an overflow; otherwise, the\n  behavior is undefined.<br/><em>\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u2014 [expr.add] 5.7 /5</em></p>\n</blockquote>\n", "CreationDate": "2012-10-19T15:16:49.510", "ParentId": "12976675", "Id": "12977340", "LastActivityDate": "2012-10-19T15:16:49.510", "PostTypeId": "2", "Score": "0", "OwnerUserId": "365496"}, "12976722": {"CommentCount": "0", "Body": "<p>Yes, it is. Remember about checking index - operator++ can go \"too far\" - beyond the array.</p>\n", "CreationDate": "2012-10-19T14:46:40.060", "ParentId": "12976675", "Id": "12976722", "LastActivityDate": "2012-10-19T14:46:40.060", "PostTypeId": "2", "Score": "0", "OwnerUserId": "1066739"}});