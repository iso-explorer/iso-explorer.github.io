post_cb({"3660859": {"Id": "3660859", "PostTypeId": "2", "Body": "<p>ISO/IEC 14882 (First edition 1998-09-01) in p. 8.5.1.7 states the following:</p>\n<blockquote>\n<p id=\"so_3659839_3660859_0\">If there are fewer initializers in the\n  list than there are members in the\n  aggregate, then each member not\n  explicitly initialized shall be\n  default-initialized (8.5). [Example:\n  struct S { int a; char* b; int c; }; S\n  ss = { 1, \"asdf\" }; initializes ss.a\n  with 1, ss.b with \"asdf\", and ss.c\n  with the value of an expression of the\n  form int(), that is, 0. ]</p>\n</blockquote>\n<p>Simply, the answer to your question is no.</p>\n", "OwnerDisplayName": "user405725", "LastActivityDate": "2010-09-07T17:00:17.870", "Score": "1", "CreationDate": "2010-09-07T17:00:17.870", "ParentId": "3659839", "CommentCount": "0"}, "3659873": {"Id": "3659873", "PostTypeId": "2", "Body": "<p>According to the <a href=\"http://msdn.microsoft.com/en-us/library/81k8cwsz(VS.71).aspx\" rel=\"nofollow noreferrer\">msdn</a>, if fewer initializers are specified, the remaining elements are initialized with 0, so the code should work nonetheless.</p>\n", "LastActivityDate": "2010-09-07T15:04:57.897", "CommentCount": "1", "CreationDate": "2010-09-07T15:04:57.897", "ParentId": "3659839", "Score": "0", "OwnerUserId": "127059"}, "bq_ids": {"n4140": {"so_3659839_3660859_0": {"length": 21, "quality": 0.7241379310344828, "section_id": 3304}}, "n3337": {"so_3659839_3660859_0": {"length": 21, "quality": 0.7241379310344828, "section_id": 3174}}, "n4659": {"so_3659839_3660859_0": {"length": 19, "quality": 0.6551724137931034, "section_id": 4070}}}, "3660601": {"Id": "3660601", "PostTypeId": "2", "Body": "<p>Just for the sake of a non-Boost answer\u2026</p>\n<p>You can add an initialization requirement by modifying <code>my_struct_type</code>.</p>\n<pre><code>template&lt; typename T &gt;\nstruct must_be_initialized {\n    T value;\n\n    must_be_initialized( T const &amp;v ) : value( v ) {}\n     // no default constructor!\n\n    operator T&amp; () { return value; }\n    operator T const&amp; () const { return value; }\n};\n\nstruct my_struct_type {\n    must_be_initialized&lt; double &gt; f;\n    int i;\n    char c;\n};\n\nmy_struct_type expected[14] =\n{\n    { 1.234, 0, 'c' },\n    { 3.141, 1, 'z' },\n    { 2.718, 0, 'a' }\n     // error: no default constructor exists\n};\n</code></pre>\n<p><code>my_struct_type</code> is still an aggregate, but it is not POD.</p>\n", "LastActivityDate": "2010-09-07T16:30:12.403", "CommentCount": "4", "CreationDate": "2010-09-07T16:30:12.403", "ParentId": "3659839", "Score": "1", "OwnerUserId": "153285"}, "3659936": {"Id": "3659936", "PostTypeId": "2", "Body": "<p>First: There might be a warning for this. Have you tried compiling at the highest warning level?</p>\n<p>Then: If you swap which value is calculated and which is literal, you could raise a compile-time error: </p>\n<pre><code>my_struct_type my_array[] = // &lt;== note the empty []\n{\n    { 1.234, 0, 'c' },\n    { 3.141, 1, 'z' },\n    { 2.718, 0, 'a' }\n};\n\nBOOST_STATIC_ASSERT( sizeof(my_array)/sizeof(my_array[0]) == 14 );\n</code></pre>\n", "LastActivityDate": "2010-09-07T15:12:15.453", "CommentCount": "1", "CreationDate": "2010-09-07T15:12:15.453", "ParentId": "3659839", "Score": "4", "OwnerUserId": "140719"}, "3659839": {"ViewCount": "1026", "Body": "<p>I am using an aggregate initializer to set up a block of static data for a unit test.</p>\n<p>I would like to use the array size as the expected number of elements, but this can fail if too few initializers are provided:</p>\n<pre><code>my_struct_type expected[14] =\n{\n    { 1.234, 0, 'c' },\n    { 3.141, 1, 'z' },\n    { 2.718, 0, 'a' }\n};\n</code></pre>\n<p>This gives no compiler error in Visual Studio 2008.</p>\n<p>I would like to be able to use it as such:</p>\n<pre><code>const unsigned expected_size = sizeof(expected) / sizeof(my_struct_type);\n\nBOOST_CHECK_EQUAL(points.size(), expected_size);\n\nfor( int i = 0; i &lt; expected_size; i++ )\n{\n    BOOST_CHECK_EQUAL(points[i].value, expected[i].value);\n    BOOST_CHECK_EQUAL(points[i].count, expected[i].count);\n    BOOST_CHECK_EQUAL(points[i].sym,   expected[i].sym);\n}\n</code></pre>\n<p>but because I don't have a compile-time guarantee of 14 points, this runs off the <strike>end of the array</strike> end of the provided values and into the default-initialized values.</p>\n<p>Can I somehow enforce the number of aggregate array initializers at compile-time?</p>\n", "AcceptedAnswerId": "3659936", "Title": "Can I cause a compile error on \"too few initializers\"?", "CreationDate": "2010-09-07T15:00:40.400", "Id": "3659839", "CommentCount": "0", "LastEditDate": "2010-09-07T18:00:04.990", "PostTypeId": "1", "LastEditorUserId": "44390", "LastActivityDate": "2010-09-07T18:00:04.990", "Score": "2", "OwnerUserId": "44390", "Tags": "<c++><compiler-errors><aggregate><initializer-list><boost-test>", "AnswerCount": "5"}, "3659976": {"Id": "3659976", "PostTypeId": "2", "Body": "<p>Actually it won't run off the end of the array, because the compiler will default-initialize all the elements of the array that you didn't initialize yourself.</p>\n<p>If you're trying to make sure that you have a specific number of configured initializers, I'm not sure how to do that.</p>\n<p>If you just want to make sure the array is the number of items you have:</p>\n<pre><code>my_struct_type expected[] =\n{\n    { 1.234, 0, 'c' },\n    { 3.141, 1, 'z' },\n    { 2.718, 0, 'a' }\n};\n</code></pre>\n<p>Will do the trick. Then just use <code>sizeof(expected) / sizeof(expected[0])</code> to get the total number of array elements.</p>\n", "LastEditorUserId": "251738", "LastActivityDate": "2010-09-07T17:11:53.147", "Score": "5", "CreationDate": "2010-09-07T15:15:18.383", "ParentId": "3659839", "CommentCount": "4", "OwnerUserId": "251738", "LastEditDate": "2010-09-07T17:11:53.147"}});