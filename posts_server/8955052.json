post_cb({"bq_ids": {"n4140": {"so_8955052_8955207_0": {"section_id": 4706, "quality": 0.8888888888888888, "length": 8}, "so_8955052_8955220_1": {"section_id": 300, "quality": 0.7142857142857143, "length": 5}}, "n3337": {"so_8955052_8955207_0": {"section_id": 4515, "quality": 0.8888888888888888, "length": 8}, "so_8955052_8955220_1": {"section_id": 291, "quality": 0.7142857142857143, "length": 5}}, "n4659": {"so_8955052_8955207_0": {"section_id": 6103, "quality": 0.8888888888888888, "length": 8}, "so_8955052_8955220_1": {"section_id": 307, "quality": 0.7142857142857143, "length": 5}}}, "8955207": {"ParentId": "8955052", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>Several definitions depend upon <code>declval</code> giving reasonable results for <em>cv-qualified</em> <code>void</code>.  An example is <code>is_assignable</code>:</p>\n<pre><code>template &lt;class T, class U&gt;\nstruct is_assignable;\n</code></pre>\n<blockquote>\n<p id=\"so_8955052_8955207_0\">The expression <code>declval&lt;T&gt;() = declval&lt;U&gt;()</code> is well-formed when treated\n  as an unevaluated operand ...</p>\n</blockquote>\n<p>The intent is that \"well-formed\" refers to the well-formed-ness of the assignment expression, and not whether <code>declval&lt;T&gt;</code> itself is well-formed.  I.e. we want to worry about just one thing at a time.</p>\n", "OwnerUserId": "576911", "LastEditorUserId": "576911", "LastEditDate": "2012-01-21T17:59:07.163", "Id": "8955207", "Score": "10", "CreationDate": "2012-01-21T17:53:18.513", "LastActivityDate": "2012-01-21T17:59:07.163"}, "8955172": {"ParentId": "8955052", "CommentCount": "4", "Body": "<p>I don't know if this is the actual reason, but <code>add_rvalue_reference</code> has different behavior for <code>void</code>.</p>\n<p><code>add_rvalue_reference&lt;void&gt;::type</code> is simply <code>void</code>.</p>\n<p><code>void&amp;&amp;</code> is an error.</p>\n", "OwnerUserId": "964135", "PostTypeId": "2", "Id": "8955172", "Score": "14", "CreationDate": "2012-01-21T17:48:08.440", "LastActivityDate": "2012-01-21T17:48:08.440"}, "8955052": {"CommentCount": "8", "AcceptedAnswerId": "8955172", "PostTypeId": "1", "LastEditorUserId": "560648", "CreationDate": "2012-01-21T17:30:54.297", "LastActivityDate": "2012-01-21T22:02:26.457", "LastEditDate": "2012-01-21T22:02:26.457", "ViewCount": "1069", "FavoriteCount": "2", "Title": "Why is 'declval' specified in terms of 'add_rvalue_reference<T>::type' and not 'T&&'?", "Id": "8955052", "Score": "17", "Body": "<p><code>\u00a720.2.4 [declval]</code></p>\n<pre><code>template &lt;class T&gt;\ntypename add_rvalue_reference&lt;T&gt;::type declval() noexcept; // as unevaluated operand\n</code></pre>\n<p>Why use <code>add_rvalue_reference</code> here?</p>\n<p>From <code>\u00a720.9.7.2 [meta.trans.ref]</code> on <code>add_rvalue_reference</code>:</p>\n<blockquote>\n<p id=\"so_8955052_8955052_0\">If <code>T</code> names an object or function type then the member typedef <code>type</code> shall name <code>T&amp;&amp;</code>; otherwise, <code>type</code> shall name <code>T</code>. [ <em>Note:</em> This rule reflects the semantics of reference collapsing (8.3.2). For example, when a type <code>T</code> names a type <code>T1&amp;</code>, the type <code>add_rvalue_reference&lt;T&gt;::type</code> is not an rvalue reference. <em>\u2014end note</em> ]</p>\n</blockquote>\n<p>Since <code>add_rvalue_reference</code> is meant to reflect reference collapsing anyways, why not just use <code>T&amp;&amp;</code> like the following?</p>\n<pre><code>template&lt;class T&gt;\nT&amp;&amp; declval();\n</code></pre>\n<p>What could go wrong? What exactly are the differences between the two versions?</p>\n", "Tags": "<c++><c++11>", "OwnerUserId": "500104", "AnswerCount": "3"}, "8955220": {"ParentId": "8955052", "PostTypeId": "2", "CommentCount": "0", "Body": "<p>The difference is that <code>add_rvalue_reference&lt;&gt;</code> only really adds the <code>&amp;&amp;</code> part if <code>T</code> is an object or function type. If <code>T</code> isn't an object or function type (e.g. <code>void</code>) you don't want to add <code>&amp;&amp;</code>.</p>\n<p>See <a href=\"http://ideone.com/as8Bi\">this example on Ideone</a>.<br>\n<a href=\"http://www.boost.org/doc/libs/1_45_0/libs/utility/doc/html/declval.html\">This webpage of Boost's implementation</a> explains:</br></p>\n<blockquote>\n<p id=\"so_8955052_8955220_0\">The role of the function template <code>declval()</code> is a transformation of a type <code>T</code> into a value without using or evaluating this function. The name is supposed to direct the reader's attention to the fact that the expression <code>declval&lt;T&gt;()</code> is an lvalue if and only if <code>T</code> is an lvalue-reference, otherwise an rvalue. To extend the domain of this function we can do a bit better by changing its declaration to</p>\n<pre><code>template&lt;class T&gt;\ntypename std::add_rvalue_reference&lt;T&gt;::type declval(); // not used\n</code></pre>\n<p id=\"so_8955052_8955220_1\">which ensures that we can also use cv <code>void</code> as template parameter.</p>\n</blockquote>\n", "Id": "8955220", "LastEditDate": "2012-01-21T18:08:48.550", "OwnerDisplayName": "user142019", "Score": "10", "CreationDate": "2012-01-21T17:54:43.980", "LastActivityDate": "2012-01-21T18:08:48.550", "LastEditorDisplayName": "user142019"}});