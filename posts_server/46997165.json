post_cb({"46999091": {"ParentId": "46997165", "PostTypeId": "2", "CommentCount": "4", "Body": "<p><a href=\"http://eel.is/c++draft/temp.deduct.call#2\" rel=\"nofollow noreferrer\">[temp.deduct.call]/1 &amp; 3</a> [emphasis mine]:</p>\n<blockquote>\n<p id=\"so_46997165_46999091_0\"><strong>/1</strong></p>\n<p id=\"so_46997165_46999091_1\">Template argument deduction is done by comparing each function\n  template parameter type (call it <code>P</code>) that contains\n  template-parameters that participate in template argument deduction\n  with the type of the corresponding argument of the call (call it <code>A</code>)\n  as described below. ...</p>\n<p id=\"so_46997165_46999091_2\"><strong>/3</strong></p>\n<p id=\"so_46997165_46999091_3\">... A forwarding reference is <strong>an rvalue reference to a cv-unqualified\n  template parameter</strong> that does not represent a template parameter of a\n  class template (during class template argument deduction\n  ([over.match.class.deduct])). <strong>If <code>P</code> is a forwarding reference and the\n  argument is an lvalue, the type \u201clvalue reference to <code>A</code>\u201d is used in\n  place of <code>A</code> for type deduction</strong>.</p>\n<p id=\"so_46997165_46999091_4\">[ <em>Example:</em></p>\n<pre><code>...\ntemplate &lt;class T&gt; int f(T&amp;&amp; heisenreference);\nint i;\nint n1 = f(i);                  // calls f&lt;int&amp;&gt;(int&amp;)\n...\n</code></pre>\n<p id=\"so_46997165_46999091_5\">\u2014 end example]</p>\n</blockquote>\n<p>Applied to your example, the <code>foo(a)</code> call will, for template argument deduction, resolve to <code>void foo&lt;A&amp;&gt;(A&amp;)</code>, which is an exact match for the cv-unqualified lvalue <code>a</code>. The non-template function <code>void foo(const A&amp;)</code>, will, by <a href=\"http://eel.is/c++draft/over.ics.rank#3.2.6\" rel=\"nofollow noreferrer\">[over.ics.rank]/3.2.6</a> (thanks @M.M for correcting which ranking rule that disambiguates these two), provide a worse conversion sequence than the template deducted one, and <code>void foo&lt;A&amp;&gt;(A&amp;)</code> will be have precedence in overload resolution.</p>\n<blockquote>\n<p id=\"so_46997165_46999091_6\"><strong>/3.2</strong></p>\n<p id=\"so_46997165_46999091_7\">Standard conversion sequence <code>S1</code> is a better conversion sequence than\n  standard conversion sequence <code>S2</code> if</p>\n<ul>\n<li><p id=\"so_46997165_46999091_8\">...</p></li>\n<li><p id=\"so_46997165_46999091_9\"><strong>/3.2.6</strong> \u2014 <code>S1</code> and <code>S2</code> are reference bindings (8.5.3), and the types to which the references refer are the same type except for top-level\n  cv-qualifiers, and the type to which the reference initialized by <code>S2</code>\n  refers is more cv-qualified than the type to which the reference\n  initialized by <code>S1</code> refers.</p></li>\n</ul>\n</blockquote>\n<p>If you modify your example such that the non-template overload have the same top-level cv-qualifier(s) as the template deducted one (e.g. by removing the <code>const</code> cv-qualifier from the non-template function), it will result in the prior being chosen by overload resolution, .</p>\n<pre><code>class A {};\n\ntemplate&lt; typename T &gt;\nvoid foo( T&amp;&amp; )\n{\n    std::cout &lt;&lt; \"T&amp;&amp;\" &lt;&lt; std::endl;\n}\n\nvoid foo( A&amp; )\n{\n    std::cout &lt;&lt; \"A&amp;\" &lt;&lt; std::endl;\n}\n\nint main()\n{\n    A a;\n    foo( a ); // \"A&amp;\"\n}\n</code></pre>\n", "OwnerUserId": "4573247", "LastEditorUserId": "4573247", "LastEditDate": "2017-10-29T11:10:30.430", "Id": "46999091", "Score": "2", "CreationDate": "2017-10-29T10:26:45.967", "LastActivityDate": "2017-10-29T11:10:30.430"}, "46997165": {"CommentCount": "0", "ViewCount": "25", "PostTypeId": "1", "LastEditorUserId": "4573247", "CreationDate": "2017-10-29T05:37:13.517", "LastActivityDate": "2017-10-29T11:10:30.430", "Title": "Binding priority of forwarding reference", "AcceptedAnswerId": "46999091", "LastEditDate": "2017-10-29T10:30:38.537", "Id": "46997165", "Score": "1", "Body": "<p>Can someone please help me to understand why the following code outputs <code>T&amp;&amp;</code> and NOT <code>const A&amp;</code>:</p>\n<pre><code>class A{};\n\ntemplate&lt; typename T &gt;\nvoid foo( T&amp;&amp; )\n{\n   std::cout &lt;&lt; \"T&amp;&amp;\" &lt;&lt; std::endl;\n}\n\n\nvoid foo( const A&amp; )\n{\n   std::cout &lt;&lt; \"const A&amp;\" &lt;&lt; std::endl;\n}\n\n\nint main()\n{\n  A a;\n  foo( a );\n}\n</code></pre>\n", "Tags": "<c++><templates><c++14><forwarding-reference>", "OwnerUserId": "7006673", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_46997165_46999091_9": {"section_id": 639, "quality": 0.9130434782608695, "length": 21}, "so_46997165_46999091_1": {"section_id": 302, "quality": 0.75, "length": 18}, "so_46997165_46999091_7": {"section_id": 603, "quality": 0.8888888888888888, "length": 8}}, "n3337": {"so_46997165_46999091_9": {"section_id": 629, "quality": 0.9130434782608695, "length": 21}, "so_46997165_46999091_1": {"section_id": 293, "quality": 0.75, "length": 18}, "so_46997165_46999091_7": {"section_id": 593, "quality": 0.8888888888888888, "length": 8}}, "n4659": {"so_46997165_46999091_9": {"section_id": 667, "quality": 0.9130434782608695, "length": 21}, "so_46997165_46999091_3": {"section_id": 311, "quality": 0.9310344827586207, "length": 27}, "so_46997165_46999091_1": {"section_id": 309, "quality": 1.0, "length": 24}, "so_46997165_46999091_7": {"section_id": 629, "quality": 0.8888888888888888, "length": 8}}}});