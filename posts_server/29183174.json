post_cb({"bq_ids": {"n4140": {"so_29183174_29183174_1": {"length": 5, "quality": 1.0, "section_id": 1582}}, "n3337": {"so_29183174_29183174_1": {"length": 5, "quality": 1.0, "section_id": 1578}}, "n4659": {"so_29183174_29183174_1": {"length": 5, "quality": 1.0, "section_id": 1733}}}, "29183221": {"Id": "29183221", "PostTypeId": "2", "Body": "<p>No, it's not implicit, but explicit. Also in C++11 21.4/5 is</p>\n<pre><code>basic_string(basic_string&amp;&amp; str) noexcept;\n</code></pre>\n", "LastActivityDate": "2015-03-21T13:24:41.673", "CommentCount": "0", "CreationDate": "2015-03-21T13:24:41.673", "ParentId": "29183174", "Score": "3", "OwnerUserId": "204847"}, "29183174": {"ViewCount": "67", "Body": "<p>I'm aware that <code>std::basic_string</code> in practice supports move semantics, but the rvalue reference argument constructor I find in C++11 looks like this in the class definition:</p>\n<i>C++11 \u00a721.4/5</i>:\n\n<blockquote id=\"so_29183174_29183174_0\">\n<pre><code>basic_string(basic_string&amp;&amp;, const Allocator&amp;);\n</code></pre>\n</blockquote>\n<p>Then in the detailed discussion it's again shown without a default for the allocator argument:</p>\n<i>C++11 \u00a721.4.2/17</i>:\n\n<blockquote id=\"so_29183174_29183174_1\">\n<pre><code>basic_string(basic_string&amp;&amp; str, const Allocator&amp; alloc);\n</code></pre>\n</blockquote>\n<p>Disregarding obvious intent that the class should be movable, does the class then formally have an implicitly generated move constructor?</p>\n", "AcceptedAnswerId": "29183221", "Title": "Does std::basic_string formally have an implicitly generated move constructor?", "CreationDate": "2015-03-21T13:18:33.293", "Id": "29183174", "CommentCount": "3", "PostTypeId": "1", "LastActivityDate": "2015-03-21T13:24:41.673", "Score": "2", "OwnerUserId": "464581", "Tags": "<c++><language-lawyer><move-semantics>", "AnswerCount": "1"}});