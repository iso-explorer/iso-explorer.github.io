post_cb({"38801955": {"ViewCount": "203", "Body": "<p>There is a paragraph about guaranteed copy elision in c++ draft n4606 [dcl.init] 17.6:</p>\n<blockquote id=\"so_38801955_38801955_0\">\n<ul>\n<li>If the destination type is a (possibly cv-qualified) class type:\n  \n  <ul>\n<li>If the initializer expression is a prvalue and the cv-unqualified version of the source type is the same class as the class of the destination, the initializer expression is used to initialize the destination object. [ <em>Example</em>: <code>T x = T(T(T()));</code> calls the <code>T</code> default constructor to initialize <code>x</code>. \u2014 <em>end example</em> ]</li>\n<li>[...]</li>\n</ul></li>\n</ul>\n</blockquote>\n<p>There is also a <a href=\"https://stackoverflow.com/questions/38043319/how-does-guaranteed-copy-elision-work\">Q&amp;A</a> talks about how it works.</p>\n<p>To myself understanding, the rule I quoted guarantees that no ctors should get involved when initializer expression is a prvalue and the cv-unqualified version of the source type is the same class as the class of the destination. So that no needs to check the existence of copy or move ctor, which makes following codes to be legal in C++17:</p>\n<pre><code>struct A {\n    A() {}\n    A(A const &amp;) = delete;\n    A(A &amp;&amp;) = delete;\n};\nA f() { return A(); } // it's illegal in C++14, and suppose to be legal in C++17\n</code></pre>\n<p>However, what drives me crazy is I can't find similar rules in list-initialization section in c++ draft n4606. What I found is ([dcl.init.list] 3.6)</p>\n<blockquote>\n<p id=\"so_38801955_38801955_1\">[...]</p>\n<ul>\n<li>Otherwise, if <code>T</code> is a class type, constructors are considered. The applicable constructors are enumerated and the best one is chosen through overload resolution (13.3, 13.3.1.7). If a narrowing conversion (see below) is required to convert any of the arguments, the program is ill-formed.\n  [...]</li>\n</ul>\n</blockquote>\n<p>Since list-initialization has higher priority than the first rule I quoted, we should consider the rule in list-initialized section when the initializer is a initializer-list. As we can see, constructors are considered when list-initialize a class type <code>T</code>. So, continued to the previous example, will</p>\n<pre><code>A ff() { return {A()}; }\n</code></pre>\n<p>be legal in C++17? And can someone find where the standard draft specify how does guaranteed copy elision work in list-initialization?</p>\n", "AcceptedAnswerId": "38805510", "Title": "How does guaranteed copy elision work in list-initialization in C++1z?", "CreationDate": "2016-08-06T08:01:31.403", "Id": "38801955", "CommentCount": "3", "LastEditDate": "2017-05-23T12:08:35.727", "PostTypeId": "1", "LastEditorUserId": "-1", "LastActivityDate": "2016-08-06T15:26:53.973", "Score": "9", "OwnerUserId": "5845611", "Tags": "<c++><c++1z><copy-elision><list-initialization>", "AnswerCount": "1"}, "bq_ids": {"n4140": {"so_38801955_38801955_0": {"length": 19, "quality": 0.6333333333333333, "section_id": 3296}, "so_38801955_38805510_0": {"length": 9, "quality": 0.9, "section_id": 480}}, "n3337": {"so_38801955_38801955_0": {"length": 19, "quality": 0.6333333333333333, "section_id": 3166}, "so_38801955_38805510_0": {"length": 9, "quality": 0.9, "section_id": 471}}, "n4659": {"so_38801955_38801955_0": {"length": 27, "quality": 0.9, "section_id": 4058}, "so_38801955_38805510_0": {"length": 9, "quality": 0.9, "section_id": 502}}}, "38805510": {"Id": "38805510", "PostTypeId": "2", "Body": "<p><a href=\"http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0135r1.html\" rel=\"noreferrer\">Guaranteed elision</a> works by redefining prvalue expressions to mean \"will initialize an object\". They don't construct temporaries anymore; temporaries are instead constructed by certain <em>uses</em> of prvalue expressions.</p>\n<p>Please note the frequent use of the word \"expression\" above. I point that out because of one very important fact: a braced-init-list <em>is not an expression.</em> The standard is very clear about this. It is not an expression, and only <em>expressions</em> can be prvalues.</p>\n<p>Indeed, consider the section of the standard on elision:</p>\n<blockquote>\n<p id=\"so_38801955_38805510_0\">This elision of copy/move operations, called copy elision, is permitted in the following circumstances:</p>\n<ul>\n<li>in a return statement in a function with a class return type, when the <strong>expression</strong> is the name of a non-volatile automatic object...</li>\n<li>...</li>\n<li>when a temporary class object that has not been bound to a reference (12.2) would be copied/moved to a class object with the same cv-unqualified type</li>\n</ul>\n</blockquote>\n<p>These all involve expressions (temporary class objects are expressions). Braced-init-lists aren't expressions.</p>\n<p>As such, if you issue <code>return {anything};</code>, the construction of the return value from <code>anything</code> will not be elided, regardless of what <code>anything</code> is. According to the standard, of course; compilers may differ due to bugs.</p>\n<p>Now that being said, if you have a prvalue expression of the same type as the return value, you are highly unlikely to want to type <code>return {prvalue};</code> instead of just <code>return prvalue;</code>. And if the expression was of a different type, then it doesn't qualify for elision anyway.</p>\n", "LastEditorUserId": "734069", "LastActivityDate": "2016-08-06T15:26:53.973", "Score": "5", "CreationDate": "2016-08-06T14:46:33.367", "ParentId": "38801955", "CommentCount": "4", "OwnerUserId": "734069", "LastEditDate": "2016-08-06T15:26:53.973"}});